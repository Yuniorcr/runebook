<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="redis">
    <body>
      <group id="redis">
        <trans-unit id="e231fa35664a84f1e5009d81e7f6bba1d485eec3" translate="yes" xml:space="preserve">
          <source>An error is returned when &lt;code&gt;key&lt;/code&gt; exists but does not hold a list value.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 存在するがリスト値を保持していない場合、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="6bdfaaedacc744e822937a491c0aa265faa0a3c9" translate="yes" xml:space="preserve">
          <source>An error is returned when &lt;code&gt;key&lt;/code&gt; exists but does not hold a sorted set.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 存在するが、ソートされたセットを保持していない場合、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="cafd7db432cc1bfe0eb095227c59268bb7b93c9e" translate="yes" xml:space="preserve">
          <source>An error is returned when &lt;code&gt;seconds&lt;/code&gt; is invalid.</source>
          <target state="translated">&lt;code&gt;seconds&lt;/code&gt; が無効な場合、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="8e9136354e1045681dd2f7a86b9527fc481d91cd" translate="yes" xml:space="preserve">
          <source>An error is returned when the value stored at &lt;code&gt;key&lt;/code&gt; is not a set.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されている値がセットでない場合、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="b4eb1a0965c235064ac8aba79722ddaff3491eef" translate="yes" xml:space="preserve">
          <source>An example of Sentinel output:</source>
          <target state="translated">Sentinelの出力例。</target>
        </trans-unit>
        <trans-unit id="e3a2b833146840fa4cd410d9b71d1f7b478f823c" translate="yes" xml:space="preserve">
          <source>An example of output when &lt;a href=&quot;role&quot;&gt;ROLE&lt;/a&gt; is called in a master instance:</source>
          <target state="translated">マスターインスタンスで&lt;a href=&quot;role&quot;&gt;ROLE&lt;/a&gt;が呼び出されたときの出力例：</target>
        </trans-unit>
        <trans-unit id="579d469e7cac2523515437d9b8d6112fe3d93c9e" translate="yes" xml:space="preserve">
          <source>An example of output when &lt;a href=&quot;role&quot;&gt;ROLE&lt;/a&gt; is called in a replica instance:</source>
          <target state="translated">レプリカインスタンスで&lt;a href=&quot;role&quot;&gt;ROLE&lt;/a&gt;が呼び出されたときの出力例：</target>
        </trans-unit>
        <trans-unit id="1d6f1c424d50ab94243fe38cbdfeabffd674d66c" translate="yes" xml:space="preserve">
          <source>An example of unlock script would be similar to the following:</source>
          <target state="translated">アンロックスクリプトの例は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="89fe7da248c22605a4e15750b1f9beb107181168" translate="yes" xml:space="preserve">
          <source>An example sampling the temperature of a sensor using fixed-size strings (using a binary format is better in real implementations).</source>
          <target state="translated">固定サイズの文字列を使用してセンサの温度をサンプリングする例(実際の実装ではバイナリ形式を使用した方が良いでしょう)。</target>
        </trans-unit>
        <trans-unit id="4eae947ad09e05cad458fca2075b30ae1b15869c" translate="yes" xml:space="preserve">
          <source>An interesting pattern using &lt;code&gt;SORT ... STORE&lt;/code&gt; consists in associating an &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; timeout to the resulting key so that in applications where the result of a &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; operation can be cached for some time. Other clients will use the cached list instead of calling &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; for every request. When the key will timeout, an updated version of the cache can be created by calling &lt;code&gt;SORT ... STORE&lt;/code&gt; again.</source>
          <target state="translated">&lt;code&gt;SORT ... STORE&lt;/code&gt; を使用した興味深いパターンは、結果のキーに&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;タイムアウトを関連付けて、&lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt;操作の結果をしばらくキャッシュできるアプリケーションで使用できるようにすることです。他のクライアントは、リクエストごとに&lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt;を呼び出す代わりに、キャッシュされたリストを使用します。キーがタイムアウトすると、 &lt;code&gt;SORT ... STORE&lt;/code&gt; 再度呼び出すことにより、キャッシュの更新バージョンを作成できます。</target>
        </trans-unit>
        <trans-unit id="c296bdf9668142740fec726611d45d470138dafa" translate="yes" xml:space="preserve">
          <source>An iteration starts when the cursor is set to 0, and terminates when the cursor returned by the server is 0. The following is an example of SCAN iteration:</source>
          <target state="translated">反復はカーソルが0になると開始し、サーバから返されたカーソルが0になると終了します。 以下にSCANの反復の例を示します。</target>
        </trans-unit>
        <trans-unit id="060444849d7b2e77c482c80d4ddc007637e5e3e9" translate="yes" xml:space="preserve">
          <source>And so for until the iteration is complete and no result is returned. See the &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; page about iterating for more information.</source>
          <target state="translated">繰り返しが完了するまで、結果は返されません。詳細については、反復に関する&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;ページを参照してください。</target>
        </trans-unit>
        <trans-unit id="abbabebfac6efc7292e2eb1b2e18a22fb8f0b07b" translate="yes" xml:space="preserve">
          <source>And so forth.</source>
          <target state="translated">といった感じで。</target>
        </trans-unit>
        <trans-unit id="4c3a5cf2099eac6b70d3351f9f2b307f8576cbfe" translate="yes" xml:space="preserve">
          <source>And so forth. Eventually this will allow to visit all the entries in the stream. Obviously, we can start the iteration from any ID, or even from a specific time, by providing a given incomplete start ID. Moreover, we can limit the iteration to a given ID or time, by providing an end ID or incomplete ID instead of &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="translated">などなど。最終的には、これによりストリーム内のすべてのエントリにアクセスできます。明らかに、任意の不完全な開始IDを指定することにより、任意のIDから、または特定の時間からでも反復を開始できます。さらに、 &lt;code&gt;+&lt;/code&gt; の代わりに終了IDまたは不完全なIDを指定することで、反復を特定のIDまたは時間に制限できます。</target>
        </trans-unit>
        <trans-unit id="bd50a85c7e0471c36280c42d04f369b2283aaee5" translate="yes" xml:space="preserve">
          <source>And so forth. Eventually, the call will not return any item, but just an empty array, then we know that there is nothing more to fetch from our stream (and we would have to retry the operation, hence this command also supports a blocking mode).</source>
          <target state="translated">といった具合です。最終的には、呼び出しはアイテムを返さずに空の配列だけを返しますが、これ以上ストリームから取得するものは何もないことがわかります (そして、操作を再試行しなければならないので、このコマンドはブロッキングモードもサポートしています)。</target>
        </trans-unit>
        <trans-unit id="087d39ee1a0310d3323a4cfd02c6576b584cb468" translate="yes" xml:space="preserve">
          <source>Another example: if we imagine a cluster formed of the following four nodes called A, B, C and D, we may send just the following set of commands to A:</source>
          <target state="translated">別の例として、A,B,C,Dと呼ばれる4つのノードからなるクラスタを想像すると、Aには以下のようなコマンドを送信することができます。</target>
        </trans-unit>
        <trans-unit id="852a8d39c81588746b082fd9f4167b5bb251bb69" translate="yes" xml:space="preserve">
          <source>Any other ID, that is, 0 or any other valid ID or incomplete ID (just the millisecond time part), will have the effect of returning entries that are pending for the consumer sending the command with IDs greater than the one provided. So basically if the ID is not &lt;code&gt;&amp;gt;&lt;/code&gt;, then the command will just let the client access its pending entries: messages delivered to it, but not yet acknowledged. Note that in this case, both &lt;code&gt;BLOCK&lt;/code&gt; and &lt;code&gt;NOACK&lt;/code&gt; are ignored.</source>
          <target state="translated">その他のID、つまり0またはその他の有効なIDまたは不完全なID（ミリ秒の時間部分のみ）は、提供されたIDより大きいIDでコマンドを送信するコンシューマーに対して保留中のエントリを返す効果があります。したがって、基本的にIDが &lt;code&gt;&amp;gt;&lt;/code&gt; でない場合、コマンドはクライアントに保留中のエントリ（メッセージは配信されますが、まだ確認されていない）へのアクセスを許可します。この場合、 &lt;code&gt;BLOCK&lt;/code&gt; と &lt;code&gt;NOACK&lt;/code&gt; の両方が無視されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ed0eff051adefea749add42d4d6cb2b879ab75ce" translate="yes" xml:space="preserve">
          <source>Any other ID, that is, 0 or any other valid ID or incomplete ID (just the millisecond time part), will have the effect of returning entries that are pending for the consumer sending the command. So basically if the ID is not &lt;code&gt;&amp;gt;&lt;/code&gt;, then the command will just let the client access its pending entries: delivered to it, but not yet acknowledged.</source>
          <target state="translated">他のID、つまり0またはその他の有効なIDまたは不完全なID（ミリ秒の時間部分のみ）は、コマンドを送信するコンシューマーが保留中のエントリを返す効果があります。したがって、基本的にIDが &lt;code&gt;&amp;gt;&lt;/code&gt; でない場合、コマンドはクライアントに保留中のエントリへのアクセスを許可します。配信されますが、まだ確認されていません。</target>
        </trans-unit>
        <trans-unit id="bf48c58a252cd0f11f754a6235c3bf6580ab92b5" translate="yes" xml:space="preserve">
          <source>Anyway even assuming a single-instance locking primitive, starting with 2.6.12 it is possible to create a much simpler locking primitive, equivalent to the one discussed here, using the &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command to acquire the lock, and a simple Lua script to release the lock. The pattern is documented in the &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command page.</source>
          <target state="translated">とにかく、2.6.12以降の単一インスタンスのロックプリミティブを想定している場合でも、&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;コマンドを使用してロックを取得し、簡単なLuaスクリプトを使用してロック。パターンは、&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;コマンドページに記載されています。</target>
        </trans-unit>
        <trans-unit id="274153f2cd2566cd42de1da9ffc1b6d3d2cf50ae" translate="yes" xml:space="preserve">
          <source>Apart from the reversed ordering, &lt;a href=&quot;zrevrange&quot;&gt;ZREVRANGE&lt;/a&gt; is similar to &lt;a href=&quot;zrange&quot;&gt;ZRANGE&lt;/a&gt;.</source>
          <target state="translated">逆の順序以外は、&lt;a href=&quot;zrevrange&quot;&gt;ZREVRANGE&lt;/a&gt;はZRANGEに似てい&lt;a href=&quot;zrange&quot;&gt;ます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dae9346322df90f8b168ba54317fbcb22d67c378" translate="yes" xml:space="preserve">
          <source>Apart from the reversed ordering, &lt;a href=&quot;zrevrangebylex&quot;&gt;ZREVRANGEBYLEX&lt;/a&gt; is similar to &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt;.</source>
          <target state="translated">逆の順序以外は、&lt;a href=&quot;zrevrangebylex&quot;&gt;ZREVRANGEBYLEX&lt;/a&gt;はZRANGEBYLEXに似てい&lt;a href=&quot;zrangebylex&quot;&gt;ます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5c43ee3f0eb54ffe03d2d092f2d6166614a936e" translate="yes" xml:space="preserve">
          <source>Apart from the reversed ordering, &lt;a href=&quot;zrevrangebyscore&quot;&gt;ZREVRANGEBYSCORE&lt;/a&gt; is similar to &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;.</source>
          <target state="translated">逆の順序以外は、&lt;a href=&quot;zrevrangebyscore&quot;&gt;ZREVRANGEBYSCORE&lt;/a&gt;はZRANGEBYSCOREに似てい&lt;a href=&quot;zrangebyscore&quot;&gt;ます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5abab69f4dc0a66b2f4a79cd40ada74327713efb" translate="yes" xml:space="preserve">
          <source>Appendix: Redis expires</source>
          <target state="translated">付録。Redisの期限切れ</target>
        </trans-unit>
        <trans-unit id="9ff199315ef371177323189f4cb9355c80a5471f" translate="yes" xml:space="preserve">
          <source>Appends the specified stream entry to the stream at the specified key. If the key does not exist, as a side effect of running this command the key is created with a stream value.</source>
          <target state="translated">指定されたストリームエントリを、指定されたキーでストリームに追加します。キーが存在しない場合は、このコマンドを実行した副作用として、ストリーム値でキーが作成されます。</target>
        </trans-unit>
        <trans-unit id="32f650d6228cf15fb1f6755ed7de0b1329f744eb" translate="yes" xml:space="preserve">
          <source>Appends the specified stream entry to the stream at the specified key. If the key does not exist, as a side effect of running this command the key is created with a stream value. The creation of stream's key can be disabled with the &lt;code&gt;NOMKSTREAM&lt;/code&gt; option.</source>
          <target state="translated">指定されたストリームエントリを、指定されたキーのストリームに追加します。キーが存在しない場合、このコマンドを実行した場合の副作用として、キーはストリーム値で作成されます。ストリームのキーの作成は、 &lt;code&gt;NOMKSTREAM&lt;/code&gt; オプションを使用して無効にできます。</target>
        </trans-unit>
        <trans-unit id="8a442180dde4ebe00bdaaebef087550dde9ed275" translate="yes" xml:space="preserve">
          <source>As a side effect a pending message entry is created in the pending entries list (PEL) of the consumer group: it means the message was delivered to a given consumer, but it was not yet acknowledged via &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;.</source>
          <target state="translated">副作用として、コンシューマグループのペンディングエントリリスト（PEL）にペンディングメッセージエントリが作成されます。これは、メッセージが特定のコンシューマに配信されたが、&lt;a href=&quot;xack&quot;&gt;XACKで&lt;/a&gt;まだ確認されていないことを意味します。</target>
        </trans-unit>
        <trans-unit id="f8d3a747f6516b67780fd78990e06b49b5087892" translate="yes" xml:space="preserve">
          <source>As a side effect of &lt;code&gt;A&lt;/code&gt; knowing and being known by all the other nodes, it will send gossip sections in the heartbeat packets that will allow each other node to create a link with each other one, forming a full mesh in a matter of seconds, even if the cluster is large.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; が他のすべてのノードを認識し、認識していることの副作用として、Aはハートビートパケットでゴシップセクションを送信し、他のノードが互いにリンクを作成できるようにし、数秒でフルメッシュを形成します。クラスターが大きい場合でも。</target>
        </trans-unit>
        <trans-unit id="90aa44b5c0b6d562f721575257b4845fb2c1994d" translate="yes" xml:space="preserve">
          <source>As a side effect of the command execution, if a slot among the ones specified as argument is set as &lt;code&gt;importing&lt;/code&gt;, this state gets cleared once the node assigns the (previously unbound) slot to itself.</source>
          <target state="translated">コマンド実行の副作用として、引数として指定されたスロットの1つが &lt;code&gt;importing&lt;/code&gt; として設定されている場合、ノードがそれ自体に（以前はバインドされていなかった）スロットを割り当てると、この状態はクリアされます。</target>
        </trans-unit>
        <trans-unit id="a31cef2ee08d5e8239d818737dfa96674f437698" translate="yes" xml:space="preserve">
          <source>As a side effect of the command execution, the node may go into &lt;em&gt;down&lt;/em&gt; state because not all hash slots are covered.</source>
          <target state="translated">コマンド実行の副作用として、すべてのハッシュスロットがカバーされていないため、ノードが&lt;em&gt;ダウン&lt;/em&gt;状態になる場合があります。</target>
        </trans-unit>
        <trans-unit id="fdfda2f0f0a65c5c9350447421bdbd24d0c16cd7" translate="yes" xml:space="preserve">
          <source>As a side effect of this command the HyperLogLog internals may be updated to reflect a different estimation of the number of unique items added so far (the cardinality of the set).</source>
          <target state="translated">このコマンドの副作用として、HyperLogの内部が更新され、これまでに追加されたユニークなアイテムの数(セットのカーディナリティ)を別の推定値に反映されることがあります。</target>
        </trans-unit>
        <trans-unit id="e3b0ef422a5105dd7a168f1bd22deb9e931a8ad3" translate="yes" xml:space="preserve">
          <source>As already stated, calls to &lt;code&gt;redis.call()&lt;/code&gt; resulting in a Redis command error will stop the execution of the script and return an error, in a way that makes it obvious that the error was generated by a script:</source>
          <target state="translated">既に述べたように、 &lt;code&gt;redis.call()&lt;/code&gt; を呼び出すとRedisコマンドエラーが発生し、スクリプトの実行が停止してエラーが返されます。これにより、エラーがスクリプトによって生成されたことが明らかになります。</target>
        </trans-unit>
        <trans-unit id="09ac6956fbf7cebafd273a67f1e1e0cc18c9d7d7" translate="yes" xml:space="preserve">
          <source>As of Redis 4.0.0, HSET is variadic and allows for multiple &lt;code&gt;field&lt;/code&gt;/&lt;code&gt;value&lt;/code&gt; pairs.</source>
          <target state="translated">Redis 4.0.0以降、HSETは可変個引数であり、複数の &lt;code&gt;field&lt;/code&gt; / &lt;code&gt;value&lt;/code&gt; ペアを使用できます。</target>
        </trans-unit>
        <trans-unit id="824fabdff9eac7426b269cefa6ab8cb7c6a7fa7e" translate="yes" xml:space="preserve">
          <source>As of v5.0, the optional &lt;code&gt;TYPE type&lt;/code&gt; subcommand can be used to filter the list by clients' type, where &lt;em&gt;type&lt;/em&gt; is one of &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;master&lt;/code&gt;, &lt;code&gt;replica&lt;/code&gt; and &lt;code&gt;pubsub&lt;/code&gt;. Note that clients blocked into the &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; command are considered to belong to the &lt;code&gt;normal&lt;/code&gt; class.</source>
          <target state="translated">V5.0のように、任意 &lt;code&gt;TYPE type&lt;/code&gt; サブコマンドは、クライアントのタイプによってリストをフィルタリングするために使用することができる&lt;em&gt;タイプ&lt;/em&gt;のものである &lt;code&gt;normal&lt;/code&gt; 、 &lt;code&gt;master&lt;/code&gt; 、 &lt;code&gt;replica&lt;/code&gt; と &lt;code&gt;pubsub&lt;/code&gt; 。&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;コマンドでブロックされたクライアントは、 &lt;code&gt;normal&lt;/code&gt; クラスに属すると見なされることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f7fd0e1ced5f80a8c1942174a609b55088d136aa" translate="yes" xml:space="preserve">
          <source>As of version 6.0 you can use this option to ask &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; to only return objects that match a given &lt;code&gt;type&lt;/code&gt;, allowing you to iterate through the database looking for keys of a specific type. The &lt;strong&gt;TYPE&lt;/strong&gt; option is only available on the whole-database &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;, not &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; or &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; etc.</source>
          <target state="translated">バージョン6.0では、このオプションを使用して、特定の &lt;code&gt;type&lt;/code&gt; に一致するオブジェクトのみを返すように&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;に要求できます。これにより、データベースを反復処理して特定のタイプのキーを探すことができます。&lt;strong&gt;TYPEの&lt;/strong&gt;オプションは、全データベースでのみ使用可能です&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;、ない&lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt;または&lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt;など&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f512cd2f467fc007a16339b78f3f8bd4aa4ddc3" translate="yes" xml:space="preserve">
          <source>As per Redis 4.0.0, HMSET is considered deprecated. Please use &lt;a href=&quot;hset&quot;&gt;HSET&lt;/a&gt; in new code.</source>
          <target state="translated">Redis 4.0.0に従い、HMSETは非推奨と見なされます。新しいコードで&lt;a href=&quot;hset&quot;&gt;HSET&lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="52e2ff1f75cd0a86ae75552c78ee5cbb2c5d2636" translate="yes" xml:space="preserve">
          <source>As per Redis 6.2, GETSET is considered deprecated. Please use &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; with &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; parameter in new code.</source>
          <target state="translated">Redis 6.2によると、GETSETは非推奨と見なされます。新しいコードでは、&lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt;パラメーターを指定して&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="eca69203d6944d9aedfa83b1745a14df6f143d34" translate="yes" xml:space="preserve">
          <source>As per Redis 6.2.0, BRPOPLPUSH is considered deprecated. Please use &lt;a href=&quot;blmove&quot;&gt;BLMOVE&lt;/a&gt; in new code.</source>
          <target state="translated">Redis 6.2.0に従い、BRPOPLPUSHは非推奨と見なされます。新しいコードで&lt;a href=&quot;blmove&quot;&gt;BLMOVE&lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="50625700b094276571780430ad92d3906e72fb6e" translate="yes" xml:space="preserve">
          <source>As per Redis 6.2.0, RPOPLPUSH is considered deprecated. Please use &lt;a href=&quot;lmove&quot;&gt;LMOVE&lt;/a&gt; in new code.</source>
          <target state="translated">Redis 6.2.0に従い、RPOPLPUSHは非推奨と見なされます。新しいコードで&lt;a href=&quot;lmove&quot;&gt;LMOVE&lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="3cf598b1b6e40341f8808136a0a46e1f4d5d8d97" translate="yes" xml:space="preserve">
          <source>As you can see 3.333 is converted into 3, &lt;em&gt;somekey&lt;/em&gt; is excluded, and the &lt;em&gt;bar&lt;/em&gt; string is never returned as there is a nil before.</source>
          <target state="translated">ご覧のとおり、3.333は3に変換され、&lt;em&gt;somekey&lt;/em&gt;は除外され、以前はnilであったため、&lt;em&gt;バー&lt;/em&gt;文字列が返されることはありません。</target>
        </trans-unit>
        <trans-unit id="b20dcd69a8805b2228dfb60a21cf7d97acd5f67c" translate="yes" xml:space="preserve">
          <source>As you can see 3.333 is converted into 3, and the &lt;em&gt;bar&lt;/em&gt; string is never returned as there is a nil before.</source>
          <target state="translated">ご覧のとおり、3.333は3に変換され、以前はnilがあるため、&lt;em&gt;bar&lt;/em&gt;文字列は返されません。</target>
        </trans-unit>
        <trans-unit id="ec8e8f706055fbdba6360cfb1b417dae6427300e" translate="yes" xml:space="preserve">
          <source>As you can see &lt;strong&gt;NOT&lt;/strong&gt; is special as it only takes an input key, because it performs inversion of bits so it only makes sense as an unary operator.</source>
          <target state="translated">ご覧のとおり、&lt;strong&gt;NOT&lt;/strong&gt;は入力キーのみを受け取るので特別です。ビットの反転を実行するため、単項演算子としてのみ意味があります。</target>
        </trans-unit>
        <trans-unit id="a732d9b394f216e3ee5501e430e6cf1a3865a69a" translate="yes" xml:space="preserve">
          <source>As you can see in this way removing a node is fragile, we need to send &lt;a href=&quot;cluster-forget&quot;&gt;CLUSTER FORGET&lt;/a&gt; commands to all the nodes ASAP hoping there are no gossip sections processing in the meantime. Because of this problem the command implements a ban-list with an expire time for each entry.</source>
          <target state="translated">このようにノードの削除は脆弱であることを確認できるように、その間に処理中のゴシップセクションがないことを期待して、すべてのノードに&lt;a href=&quot;cluster-forget&quot;&gt;CLUSTER FORGET&lt;/a&gt;コマンドをできるだけ早く送信する必要があります。この問題のため、コマンドは、各エントリの有効期限付きの禁止リストを実装します。</target>
        </trans-unit>
        <trans-unit id="aeec0e9426a0a0a54fbf363e2b26ff697ce52419" translate="yes" xml:space="preserve">
          <source>As you can see most of the calls returned zero elements, but the last call where a COUNT of 1000 was used in order to force the command to do more scanning for that iteration.</source>
          <target state="translated">ご覧のように、ほとんどの呼び出しがゼロの要素を返していますが、最後の呼び出しではCOUNT 1000が使用されており、その繰り返しのためにコマンドがさらにスキャンを行うように強制されています。</target>
        </trans-unit>
        <trans-unit id="f1947772b8e632184927e0616393e7edcce03ca1" translate="yes" xml:space="preserve">
          <source>As you can see the &lt;strong&gt;SCAN return value&lt;/strong&gt; is an array of two values: the first value is the new cursor to use in the next call, the second value is an array of elements.</source>
          <target state="translated">&lt;strong&gt;SCANの戻り値&lt;/strong&gt;は2つの値の配列であることがわかります。最初の値は次の呼び出しで使用する新しいカーソルで、2番目の値は要素の配列です。</target>
        </trans-unit>
        <trans-unit id="53b31465005a9966a63fe8728e23f94c240abdb1" translate="yes" xml:space="preserve">
          <source>Ask the server to close the connection. The connection is closed as soon as all pending replies have been written to the client.</source>
          <target state="translated">サーバーに接続を閉じるように依頼します。保留中の返信がすべてクライアントに書き込まれると、接続は閉じられます。</target>
        </trans-unit>
        <trans-unit id="14070ea7474a205db9d3fb81cc4d13bc90f1f1d9" translate="yes" xml:space="preserve">
          <source>Assign itself all the hash slots of its master, and propagate the new configuration to every node which is reachable ASAP, and eventually to every other node.</source>
          <target state="translated">自分自身にマスタのすべてのハッシュスロットを割り当て、新しい設定を早急に到達可能なすべてのノードに伝搬させ、最終的には他のすべてのノードに伝搬させます。</target>
        </trans-unit>
        <trans-unit id="dad88cac85a84619b71e6377f7daff4cceaf9449" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;mylist&lt;/code&gt; is a list of numbers, this command will return the same list with the elements sorted from small to large. In order to sort the numbers from large to small, use the &lt;code&gt;DESC&lt;/code&gt; modifier:</source>
          <target state="translated">&lt;code&gt;mylist&lt;/code&gt; が数値のリストであると仮定すると、このコマンドは、要素を小さいものから大きいものにソートした同じリストを返します。数値を大きい順に並べ替えるには、 &lt;code&gt;DESC&lt;/code&gt; 修飾子を使用します。</target>
        </trans-unit>
        <trans-unit id="010bc7ebc048785c84f0ef161a24878d38afdc74" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; and &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt; commands only delete keys that were present at the time the command was invoked. Keys created during an asynchronous flush will be unaffected.</source>
          <target state="translated">非同期&lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt;および&lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt;コマンドは、コマンドが呼び出されたときに存在していたキーのみを削除します。非同期フラッシュ中に作成されたキーは影響を受けません。</target>
        </trans-unit>
        <trans-unit id="917fb2b280881b904605b028a37696fbc08e07d1" translate="yes" xml:space="preserve">
          <source>At this point the new conversions are available, specifically:</source>
          <target state="translated">この時点で新しい変換が可能になっています、具体的には。</target>
        </trans-unit>
        <trans-unit id="08f85fbfa8d38f4d4fc4368e61ca47c40b831995" translate="yes" xml:space="preserve">
          <source>At this point you add all the elements into a sorted set using this algorithm:</source>
          <target state="translated">この時点で、このアルゴリズムを使用してソートされた集合にすべての要素を追加します。</target>
        </trans-unit>
        <trans-unit id="7f922bf277a422b7aa1b3e6b1ecb1c33f7f356b4" translate="yes" xml:space="preserve">
          <source>At this point, each time you want to get a weighted random element, just compute a random number between 0 and 1 (which is like calling &lt;code&gt;rand()&lt;/code&gt; in most languages), so you can just do:</source>
          <target state="translated">この時点で、重み付けされたランダム要素を取得するたびに、0と1の間の乱数を計算するだけです &lt;code&gt;rand()&lt;/code&gt; ほとんどの言語でrand（）を呼び出すのと同じです）。</target>
        </trans-unit>
        <trans-unit id="eeda06eb4e4b735e9051a2d2f05c160b9b8289f8" translate="yes" xml:space="preserve">
          <source>Atomic rewrite process</source>
          <target state="translated">アトミックリライト処理</target>
        </trans-unit>
        <trans-unit id="9081c20623d6921cb283f837b5ab328f068f4ee0" translate="yes" xml:space="preserve">
          <source>Atomically returns and removes the first/last element (head/tail depending on the &lt;code&gt;wherefrom&lt;/code&gt; argument) of the list stored at &lt;code&gt;source&lt;/code&gt;, and pushes the element at the first/last element (head/tail depending on the &lt;code&gt;whereto&lt;/code&gt; argument) of the list stored at &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="translated">アトミックに戻り、最初/最後の要素を除去する（頭部/尾部に応じて &lt;code&gt;wherefrom&lt;/code&gt; 引数）に格納されたリストの &lt;code&gt;source&lt;/code&gt; 、及び（に応じてヘッド/テール最初/最後の要素に要素をプッシュ &lt;code&gt;whereto&lt;/code&gt; 格納されたリストの引数を）で &lt;code&gt;destination&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f74a4fa429114feaddb20d28202c0f4085635272" translate="yes" xml:space="preserve">
          <source>Atomically returns and removes the last element (tail) of the list stored at &lt;code&gt;source&lt;/code&gt;, and pushes the element at the first element (head) of the list stored at &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; に格納されているリストの最後の要素（末尾）を原子的に返し、削除し、 &lt;code&gt;destination&lt;/code&gt; に格納されているリストの最初の要素（先頭）に要素をプッシュします。</target>
        </trans-unit>
        <trans-unit id="f6a41c1878a1c7a7b99d6378b8645723ed06556f" translate="yes" xml:space="preserve">
          <source>Atomically sets &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt; and returns the old value stored at &lt;code&gt;key&lt;/code&gt;. Returns an error when &lt;code&gt;key&lt;/code&gt; exists but does not hold a string value.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; を &lt;code&gt;value&lt;/code&gt; に原子的に設定し、keyに格納された古い値を返し &lt;code&gt;key&lt;/code&gt; 。 &lt;code&gt;key&lt;/code&gt; 存在するが文字列値を保持していない場合はエラーを返します。</target>
        </trans-unit>
        <trans-unit id="8b11c68f40fb668f25d5ebde4e4f0d736514c197" translate="yes" xml:space="preserve">
          <source>Atomically transfer a key from a source Redis instance to a destination Redis instance. On success the key is deleted from the original instance and is guaranteed to exist in the target instance.</source>
          <target state="translated">ソースの Redis インスタンスからデスティネーションの Redis インスタンスにキーをアトム単位で転送します。成功した場合、キーは元のインスタンスから削除され、ターゲットのインスタンスに存在することが保証されます。</target>
        </trans-unit>
        <trans-unit id="120b36c4fdcd059217cbe9ce714cea19b13fd52a" translate="yes" xml:space="preserve">
          <source>Atomicity of scripts</source>
          <target state="translated">スクリプトの原子性</target>
        </trans-unit>
        <trans-unit id="6a7f6b699ae2620127572c6b19a3962b68ea30ba" translate="yes" xml:space="preserve">
          <source>Available libraries</source>
          <target state="translated">利用可能なライブラリ</target>
        </trans-unit>
        <trans-unit id="fc1c7e083bc573df54c3a610bc7a64ef713879e0" translate="yes" xml:space="preserve">
          <source>B sends node A a heartbeat packet, where node D is listed.</source>
          <target state="translated">Bは、ノードDが記載されたハートビートパケットをノードAに送信する。</target>
        </trans-unit>
        <trans-unit id="7729f6e6ec6ba874a64709376383726e87372daa" translate="yes" xml:space="preserve">
          <source>BGREWRITEAOF</source>
          <target state="translated">BGREWRITEAOF</target>
        </trans-unit>
        <trans-unit id="458f7ff8a0210a97fe946685d4c3eaec2c4d3268" translate="yes" xml:space="preserve">
          <source>BGREWRITEAOF   Asynchronously rewrite the append-only file</source>
          <target state="translated">BGREWRITEAOF 追加専用ファイルを非同期に書き換えます。</target>
        </trans-unit>
        <trans-unit id="a27e9a0dccc378a573407c1d809762f71f913c63" translate="yes" xml:space="preserve">
          <source>BGSAVE</source>
          <target state="translated">BGSAVE</target>
        </trans-unit>
        <trans-unit id="7faf716555dfc6c9000f52854e242ef60d56665d" translate="yes" xml:space="preserve">
          <source>BGSAVE   Asynchronously save the dataset to disk</source>
          <target state="translated">BGSAVE 非同期にデータセットをディスクに保存します。</target>
        </trans-unit>
        <trans-unit id="ab695def32445abd5af69c89b4fc9a578a6be30c" translate="yes" xml:space="preserve">
          <source>BGSAVE  [SCHEDULE]   Asynchronously save the dataset to disk</source>
          <target state="translated">BGSAVE [SCHEDULE]非同期的にデータセットをディスクに保存します。</target>
        </trans-unit>
        <trans-unit id="aa73037de86a35867f756331811a0b553f9a4512" translate="yes" xml:space="preserve">
          <source>BITCOUNT</source>
          <target state="translated">BITCOUNT</target>
        </trans-unit>
        <trans-unit id="558065aa2007c718ef4867af43bb99fd2d71d712" translate="yes" xml:space="preserve">
          <source>BITCOUNT  key [start end]   Count set bits in a string</source>
          <target state="translated">BITCOUNT key [start end]文字列内の設定ビット数</target>
        </trans-unit>
        <trans-unit id="4648876b3aec23fc361c9cc8f6b361de8992e75b" translate="yes" xml:space="preserve">
          <source>BITFIELD</source>
          <target state="translated">BITFIELD</target>
        </trans-unit>
        <trans-unit id="4e856b858022af2e0acd6b68544eced1b0992122" translate="yes" xml:space="preserve">
          <source>BITFIELD  key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]   Perform arbitrary bitfield integer operations on strings</source>
          <target state="translated">BITFIELDキー [GET型オフセット][SET型オフセット値][INCRBY型オフセットインクリメント][OVERFLOW WRAP|SAT|FAIL]文字列に対して任意のビットフィールド整数演算を行います。</target>
        </trans-unit>
        <trans-unit id="a5aaf403ca55d3d64f12bde81881e9c02072728a" translate="yes" xml:space="preserve">
          <source>BITOP</source>
          <target state="translated">BITOP</target>
        </trans-unit>
        <trans-unit id="fbf06b661d51c935ecb7a0e541d91fa350da1c52" translate="yes" xml:space="preserve">
          <source>BITOP  operation destkey key [key ...]   Perform bitwise operations between strings</source>
          <target state="translated">BITOP操作 destkey key [key ...]文字列間でビット演算を行う。</target>
        </trans-unit>
        <trans-unit id="6429405be50a33193090d8d4c0a4575b80d167fc" translate="yes" xml:space="preserve">
          <source>BITPOS</source>
          <target state="translated">BITPOS</target>
        </trans-unit>
        <trans-unit id="3eedfee8a6aaf27b486a0a74ef694737767592c5" translate="yes" xml:space="preserve">
          <source>BITPOS  key bit [start] [end]   Find first bit set or clear in a string</source>
          <target state="translated">BITPOS キービット [start][end]文字列の最初のビットのセットまたはクリアを検索します。</target>
        </trans-unit>
        <trans-unit id="fc2dfb0c3d9a6c59a7ce67610ea5adaf29a615be" translate="yes" xml:space="preserve">
          <source>BLMOVE</source>
          <target state="translated">BLMOVE</target>
        </trans-unit>
        <trans-unit id="db9a7aeda5f34e5b6dc6bfc16ff9ad89a6ecbdee" translate="yes" xml:space="preserve">
          <source>BLMOVE  source destination LEFT|RIGHT LEFT|RIGHT timeout   Pop an element from a list, push it to another list and return it; or block until one is available</source>
          <target state="translated">BLMOVE source destination LEFT|RIGHT LEFT|RIGHT timeout リストから要素をポップし、別のリストにプッシュして返す。</target>
        </trans-unit>
        <trans-unit id="f05499a7141cb9854f00176880caa9ac423867f3" translate="yes" xml:space="preserve">
          <source>BLPOP</source>
          <target state="translated">BLPOP</target>
        </trans-unit>
        <trans-unit id="0412d709e7cedab62c94968e19cc0014d112f86b" translate="yes" xml:space="preserve">
          <source>BLPOP  key [key ...] timeout   Remove and get the first element in a list, or block until one is available</source>
          <target state="translated">BLPOP キー [キー ...]タイムアウト リストの最初の要素を削除して取得したり、利用可能になるまでブロックしたりする。</target>
        </trans-unit>
        <trans-unit id="5fa06c19410e8a659911506832eca92eaf0050d6" translate="yes" xml:space="preserve">
          <source>BRPOP</source>
          <target state="translated">BRPOP</target>
        </trans-unit>
        <trans-unit id="30c26bc19b012eb7d9f5f55b03c3f9d84b9cf9c5" translate="yes" xml:space="preserve">
          <source>BRPOP  key [key ...] timeout   Remove and get the last element in a list, or block until one is available</source>
          <target state="translated">BRPOP キー [キー ...]タイムアウト リストの最後の要素を削除して取得するか、利用可能になるまでブロックします。</target>
        </trans-unit>
        <trans-unit id="c32cdb6143356d21802163582eddef7653863e06" translate="yes" xml:space="preserve">
          <source>BRPOPLPUSH</source>
          <target state="translated">BRPOPLPUSH</target>
        </trans-unit>
        <trans-unit id="74721eebf76b2ddc61de86b46cc0aec39763409c" translate="yes" xml:space="preserve">
          <source>BRPOPLPUSH  source destination timeout   Pop a value from a list, push it to another list and return it; or block until one is available</source>
          <target state="translated">BRPOPLPUSH ソース デスティネーションのタイムアウト リストから値をポップし、それを別のリストにプッシュして返します。</target>
        </trans-unit>
        <trans-unit id="06a6c1ed02823440cc121edde6eb065e5de27fb8" translate="yes" xml:space="preserve">
          <source>BRPOPLPUSH  source destination timeout   Pop an element from a list, push it to another list and return it; or block until one is available</source>
          <target state="translated">BRPOPLPUSH ソース デスティネーションのタイムアウト リストから要素をポップし、それを別のリストにプッシュして返します。</target>
        </trans-unit>
        <trans-unit id="fe7a2ea791972d134e771e602c9bb77407df350d" translate="yes" xml:space="preserve">
          <source>BZPOPMAX</source>
          <target state="translated">BZPOPMAX</target>
        </trans-unit>
        <trans-unit id="b6758ab6d65fab9e15ff22d76094622028d82dec" translate="yes" xml:space="preserve">
          <source>BZPOPMAX  key [key ...] timeout   Remove and return the member with the highest score from one or more sorted sets, or block until one is available</source>
          <target state="translated">BZPOPMAX key [key ...]タイムアウト ソートされた1つ以上のセットの中から、最も高いスコアを持つメンバーを削除して返す、または1つが利用可能になるまでブロックする。</target>
        </trans-unit>
        <trans-unit id="cc5c70cba5a0768ab8e3b521a15ca38c10af43e5" translate="yes" xml:space="preserve">
          <source>BZPOPMIN</source>
          <target state="translated">BZPOPMIN</target>
        </trans-unit>
        <trans-unit id="34934a39c9faa59399a1c05af5d02cc1bce19590" translate="yes" xml:space="preserve">
          <source>BZPOPMIN  key [key ...] timeout   Remove and return the member with the lowest score from one or more sorted sets, or block until one is available</source>
          <target state="translated">BZPOPMIN キー [キー ...]タイムアウト ソートされた 1 つ以上のセットの中から、最も低いスコアを持つメンバーを削除して返すか、または 1 つが利用可能になるまでブロックする。</target>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="translated">Background</target>
        </trans-unit>
        <trans-unit id="baab43179123dd499c2cc2c83ab2bfdd9cbd1aec" translate="yes" xml:space="preserve">
          <source>Bandwidth and EVALSHA</source>
          <target state="translated">帯域幅とEVALSHA</target>
        </trans-unit>
        <trans-unit id="65f639d2a40570f68ed54fc56bf243ceac2035a0" translate="yes" xml:space="preserve">
          <source>Basic usage:</source>
          <target state="translated">基本的な使い方です。</target>
        </trans-unit>
        <trans-unit id="7df3c519fe73f3ffe3f8fb928955ded445b7f85e" translate="yes" xml:space="preserve">
          <source>Basically the command sets a state in the connection, that is valid only for the next command execution, that will modify the behavior of client tracking.</source>
          <target state="translated">基本的に、このコマンドは接続の状態を設定し、それは次のコマンド実行時にのみ有効で、クライアントトラッキングの動作を変更します。</target>
        </trans-unit>
        <trans-unit id="12e09074a5a31051e466bb25ea4c7f7009a10585" translate="yes" xml:space="preserve">
          <source>Basically we have a counter for every IP, for every different second. But this counters are always incremented setting an expire of 10 seconds so that they'll be removed by Redis automatically when the current second is a different one.</source>
          <target state="translated">基本的には、IPごとに、異なる秒数ごとにカウンターを用意しています。しかし、このカウンタは常に10秒の有効期限を設定してインクリメントされているので、現在の秒数が異なる場合には自動的にRedisによって削除されます。</target>
        </trans-unit>
        <trans-unit id="3bc673f7ca5e59c74c138e173d60ace2cc7f15b0" translate="yes" xml:space="preserve">
          <source>Basically, the function considers the right of the string as padded with zeros if you look for clear bits and specify no range or the &lt;em&gt;start&lt;/em&gt; argument &lt;strong&gt;only&lt;/strong&gt;.</source>
          <target state="translated">基本的に、クリアビットを探して範囲を指定しないか、&lt;em&gt;開始&lt;/em&gt;引数&lt;strong&gt;のみ&lt;/strong&gt;を指定した場合、関数は文字列の右側にゼロが埋め込まれていると見なします。</target>
        </trans-unit>
        <trans-unit id="14b677b3a5e36da0c5dac8a200bd5400f84443e8" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; streams back &lt;strong&gt;all&lt;/strong&gt; commands, its use comes at a cost. The following (totally unscientific) benchmark numbers illustrate what the cost of running &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; can be.</source>
          <target state="translated">&lt;a href=&quot;monitor&quot;&gt;MONITORは&lt;/a&gt;&lt;strong&gt;すべての&lt;/strong&gt;コマンドをストリームバック&lt;strong&gt;する&lt;/strong&gt;ため、その使用にはコストがかかります。次の（まったく科学的ではない）ベンチマークの数値は、&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;の実行にかかるコストを示しています。</target>
        </trans-unit>
        <trans-unit id="168e98970df56293fbc42baf15adc634cb88819b" translate="yes" xml:space="preserve">
          <source>Because Redis does not have control over how its allocations are mapped to memory pages, high &lt;code&gt;used_memory_rss&lt;/code&gt; is often the result of a spike in memory usage.</source>
          <target state="translated">Redisはメモリページへの割り当てのマッピング方法を制御できないため、 &lt;code&gt;used_memory_rss&lt;/code&gt; が高くなるのは、多くの場合、メモリ使用量が急増した結果です。</target>
        </trans-unit>
        <trans-unit id="9157dfb92d6b10926d702b4d13ee089e71af6988" translate="yes" xml:space="preserve">
          <source>Because Redis' strings are binary-safe, a bitmap is trivially encoded as a bytes stream. The first byte of the string corresponds to offsets 0..7 of the bitmap, the second byte to the 8..15 range, and so forth.</source>
          <target state="translated">Redisの文字列はバイナリセーフなので、ビットマップは簡単にバイトストリームとしてエンコードされる。文字列の最初のバイトはビットマップのオフセット0~7に対応し、2番目のバイトは8~15の範囲に対応する。</target>
        </trans-unit>
        <trans-unit id="ba14992feb507791cf455ac84d4bc0c1654fa142" translate="yes" xml:space="preserve">
          <source>Because of security concerns, all administrative commands are not logged by &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;'s output.</source>
          <target state="translated">セキュリティ上の懸念から、すべての管理コマンドが&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;の出力によってログに記録されるわけではありません。</target>
        </trans-unit>
        <trans-unit id="5c7ae78faec3383e9f506c3f0134610891480461" translate="yes" xml:space="preserve">
          <source>Because of the &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; semantic, C4 can check if the old value stored at &lt;code&gt;key&lt;/code&gt; is still an expired timestamp. If it is, the lock was acquired.</source>
          <target state="translated">&lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt;セマンティクスのため、C4は &lt;code&gt;key&lt;/code&gt; に保存された古い値がまだ期限切れのタイムスタンプであるかどうかを確認できます。そうである場合、ロックが取得されました。</target>
        </trans-unit>
        <trans-unit id="02e8504630183a9016b44fe68aa220f28cac8de4" translate="yes" xml:space="preserve">
          <source>Because of the first &lt;em&gt;normalized&lt;/em&gt; part in every element (before the colon character), we are forcing a given comparison, however after the range is queries using &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; the application can display to the user the second part of the string, after the colon.</source>
          <target state="translated">すべての要素の最初の&lt;em&gt;正規化&lt;/em&gt;部分（コロン文字の前）があるため、特定の比較を強制していますが、範囲が&lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt;を使用したクエリの後で、アプリケーションはユーザーに文字列の2番目の部分（コロンの後）を表示できます。</target>
        </trans-unit>
        <trans-unit id="7d59e94adcd8272e3572e2454feb728deea07f9f" translate="yes" xml:space="preserve">
          <source>Because of the high performance nature of Redis, it is possible to try a lot of passwords in parallel in very short time, so make sure to generate a strong and very long password so that this attack is infeasible. A good way to generate strong passwords is via the &lt;a href=&quot;acl-genpass&quot;&gt;ACL GENPASS&lt;/a&gt; command.</source>
          <target state="translated">Redisは高性能であるため、非常に短時間で多数のパスワードを並行して試すことができます。この攻撃が実行されないように、強力で非常に長いパスワードを生成するようにしてください。強力なパスワードを生成する良い方法は、&lt;a href=&quot;acl-genpass&quot;&gt;ACLGENPASS&lt;/a&gt;コマンドを使用することです。</target>
        </trans-unit>
        <trans-unit id="05dcf4c78858f10b7a1c629d42f2c28c91d50489" translate="yes" xml:space="preserve">
          <source>Because of this semantic &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; can be used in order to set different keys representing different fields of an unique logic object in a way that ensures that either all the fields or none at all are set.</source>
          <target state="translated">このセマンティクスのため、&lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt;を使用して、一意のロジックオブジェクトのさまざまなフィールドを表すさまざまなキーを設定し、すべてのフィールドを設定するか、まったく設定しないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="5743095da9632a185291117b22aab7a1ce272b02" translate="yes" xml:space="preserve">
          <source>Because of this the &lt;strong&gt;TAKEOVER&lt;/strong&gt; option should be used with care.</source>
          <target state="translated">このため、&lt;strong&gt;TAKEOVER&lt;/strong&gt;オプションは注意して使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="409eae8dc6d494086fe4746042f7a180a489be81" translate="yes" xml:space="preserve">
          <source>Because when a given node is part of the cluster, all the other nodes participating in the cluster knows about it, in order for a node to be completely removed from a cluster, the &lt;a href=&quot;cluster-forget&quot;&gt;CLUSTER FORGET&lt;/a&gt; command must be sent to all the remaining nodes, regardless of the fact they are masters or replicas.</source>
          <target state="translated">特定のノードがクラスターの一部である場合、クラスターに参加している他のすべてのノードはそれを認識しているため、ノードをクラスターから完全に削除するには、&lt;a href=&quot;cluster-forget&quot;&gt;CLUSTER FORGET&lt;/a&gt;コマンドを残りのすべてのノードに送信する必要があります。それらがマスターまたはレプリカであるという事実の。</target>
        </trans-unit>
        <trans-unit id="b69310332fe10ffd788fd56a9c44b252e49e79dc" translate="yes" xml:space="preserve">
          <source>Behavior of &lt;code&gt;BLPOP&lt;/code&gt; when multiple elements are pushed inside a list.</source>
          <target state="translated">複数の要素がリスト内にプッシュされたときの &lt;code&gt;BLPOP&lt;/code&gt; の動作。</target>
        </trans-unit>
        <trans-unit id="ece0bd32123faa73ffba96af59789eb1a4470a5d" translate="yes" xml:space="preserve">
          <source>Benchmark result &lt;strong&gt;with&lt;/strong&gt;&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; running (&lt;code&gt;redis-cli monitor &amp;gt; /dev/null&lt;/code&gt;):</source>
          <target state="translated">ベンチマーク結果&lt;strong&gt;と&lt;/strong&gt;&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;実行（ &lt;code&gt;redis-cli monitor &amp;gt; /dev/null&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e3f9de77c51bcc4c2a59cae3df6e39530202793d" translate="yes" xml:space="preserve">
          <source>Benchmark result &lt;strong&gt;without&lt;/strong&gt;&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; running:</source>
          <target state="translated">&lt;a href=&quot;monitor&quot;&gt;MONITORを&lt;/a&gt;実行し&lt;strong&gt;ない場合の&lt;/strong&gt;ベンチマーク結果：</target>
        </trans-unit>
        <trans-unit id="a0cee838302dd7dccb0ba96b0e4f12c473f5ce1f" translate="yes" xml:space="preserve">
          <source>Bitmaps are a very space-efficient representation of certain kinds of information. One example is a Web application that needs the history of user visits, so that for instance it is possible to determine what users are good targets of beta features.</source>
          <target state="translated">ビットマップは、ある種の情報を空間効率よく表現したものです。一例としては、ユーザの訪問履歴を必要とするウェブアプリケーションがあります。</target>
        </trans-unit>
        <trans-unit id="927448b58910f0636586793360308442afd14b22" translate="yes" xml:space="preserve">
          <source>Bitmaps are not an actual data type, but a set of bit-oriented operations defined on the String type (for more information refer to the &lt;a href=&quot;https://redis.io/topics/data-types-intro#bitmaps&quot;&gt;Bitmaps section of the Data Types Introduction page&lt;/a&gt;). This means that bitmaps can be used with string commands, and most importantly with &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; and &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt;.</source>
          <target state="translated">ビットマップは実際のデータ型ではありませんが、文字列型で定義されたビット指向の操作のセットです（詳細について&lt;a href=&quot;https://redis.io/topics/data-types-intro#bitmaps&quot;&gt;は、「データ型の概要」ページの&lt;/a&gt;「ビットマップ」セクションを参照してください）。これは、ビットマップを文字列コマンドで使用できることを意味します。最も重要なのは、&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;と&lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt;で使用できることです。</target>
        </trans-unit>
        <trans-unit id="23c5f7ddc4fdd4c0470d5c822a63678ca6ac8364" translate="yes" xml:space="preserve">
          <source>Bits and positional offsets</source>
          <target state="translated">ビットと位置オフセット</target>
        </trans-unit>
        <trans-unit id="01b1462f91bf6adae4924e41a337cd3105d30fba" translate="yes" xml:space="preserve">
          <source>Blocking behavior</source>
          <target state="translated">ブロッキング行動</target>
        </trans-unit>
        <trans-unit id="0138f8dd5046866e565b72d9550fe5224c0fb4c2" translate="yes" xml:space="preserve">
          <source>Blocking for data</source>
          <target state="translated">データのブロッキング</target>
        </trans-unit>
        <trans-unit id="b9cbba32c11fb20d3cd9b4d8a8851ece3dbdac10" translate="yes" xml:space="preserve">
          <source>Blocking list operations on lists or sorted sets have a &lt;em&gt;pop&lt;/em&gt; behavior. Bascially, the element is removed from the list or sorted set in order to be returned to the client. In this scenario you want the items to be consumed in a fair way, depending on the moment clients blocked on a given key arrived. Normally Redis uses the FIFO semantics in this use cases.</source>
          <target state="translated">リストまたはソートされたセットでのリスト操作のブロックには、&lt;em&gt;ポップ&lt;/em&gt;動作があります。基本的に、要素はリストまたはソートされたセットから削除され、クライアントに返されます。このシナリオでは、特定のキーでブロックされたクライアントが到着した瞬間に応じて、アイテムが公平に消費されるようにします。通常、Redisはこの使用例でFIFOセマンティクスを使用します。</target>
        </trans-unit>
        <trans-unit id="c7b48b477a47bc528502abd2750eaf8176a42526" translate="yes" xml:space="preserve">
          <source>Blocking list operations on lists or sorted sets have a &lt;em&gt;pop&lt;/em&gt; behavior. Basically, the element is removed from the list or sorted set in order to be returned to the client. In this scenario you want the items to be consumed in a fair way, depending on the moment clients blocked on a given key arrived. Normally Redis uses the FIFO semantics in this use cases.</source>
          <target state="translated">リストまたはソートされたセットに対するリスト操作のブロックには、&lt;em&gt;ポップ&lt;/em&gt;動作があります。基本的に、要素はクライアントに返されるためにリストまたはソートされたセットから削除されます。このシナリオでは、特定のキーでブロックされたクライアントが到着した瞬間に応じて、アイテムを公平に消費する必要があります。通常、RedisはこのユースケースでFIFOセマンティクスを使用します。</target>
        </trans-unit>
        <trans-unit id="83af529ff0234ebb19ae9fc92954913ed20af976" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are zero-based indexes, where &lt;code&gt;0&lt;/code&gt; is the first element, &lt;code&gt;1&lt;/code&gt; is the next element and so on. They can also be negative numbers indicating offsets from the end of the sorted set, with &lt;code&gt;-1&lt;/code&gt; being the last element of the sorted set, &lt;code&gt;-2&lt;/code&gt; the penultimate element and so on.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; と &lt;code&gt;stop&lt;/code&gt; はどちらもゼロから始まるインデックスで、 &lt;code&gt;0&lt;/code&gt; が最初の要素、 &lt;code&gt;1&lt;/code&gt; が次の要素、以下同様です。また、ソート済みセットの最後からのオフセットを示す負の数にすることもできます。 &lt;code&gt;-1&lt;/code&gt; はソート済みセットの最後の要素、 &lt;code&gt;-2&lt;/code&gt; は最後から2番目の要素などです。</target>
        </trans-unit>
        <trans-unit id="23a10624171d72fb4e9f07612b39ccbc04699493" translate="yes" xml:space="preserve">
          <source>Both commands were introduced in Redis 3.2.10 and Redis 4.0.0 respectively.</source>
          <target state="translated">どちらのコマンドもRedis 3.2.10とRedis 4.0.0でそれぞれ導入されました。</target>
        </trans-unit>
        <trans-unit id="3146bb227c4234d6267f94725155f23545044b63" translate="yes" xml:space="preserve">
          <source>Both quantities are 64-bit numbers. When an ID is auto-generated, the first part is the Unix time in milliseconds of the Redis instance generating the ID. The second part is just a sequence number and is used in order to distinguish IDs generated in the same millisecond.</source>
          <target state="translated">どちらの量も64ビットの数値です。IDが自動生成される場合、最初の部分は、IDを生成したRedisインスタンスのUnix時間をミリ秒単位で表します。2番目の部分は単なるシーケンス番号で、同じミリ秒で生成されたIDを区別するために使用されます。</target>
        </trans-unit>
        <trans-unit id="4a1f2ae398c91bf9d6a2b34bf5c23ed87585d341" translate="yes" xml:space="preserve">
          <source>Both representations are prefixed with a 16 bytes header, that includes a magic, an encoding / version field, and the cached cardinality estimation computed, stored in little endian format (the most significant bit is 1 if the estimation is invalid since the HyperLogLog was updated since the cardinality was computed).</source>
          <target state="translated">どちらの表現も16バイトのヘッダが先頭に付き、マジック、エンコーディング/バージョンフィールド、キャッシュされたカーディナリティ推定値がリトルエンディアン形式で格納されています(カーディナリティが計算されてからHyperLogLogが更新されたため、推定値が無効な場合は最上位ビットが1になります)。</target>
        </trans-unit>
        <trans-unit id="c7a36cc87678ec27033bceb0e99f2d1deac9e434" translate="yes" xml:space="preserve">
          <source>Both the value already contained in the string key and the increment argument can be optionally provided in exponential notation, however the value computed after the increment is stored consistently in the same format, that is, an integer number followed (if needed) by a dot, and a variable number of digits representing the decimal part of the number. Trailing zeroes are always removed.</source>
          <target state="translated">文字列キーに既に含まれている値と増分引数の両方とも、オプションで指数表記で提供することができますが、増分後に計算された値は一貫して同じ形式で保存されます。後続のゼロは常に削除されます。</target>
        </trans-unit>
        <trans-unit id="046892586ee04199d779966b3fd711b935a2c4ee" translate="yes" xml:space="preserve">
          <source>Breaking the compatibility with the past was considered but rejected, at least for Redis 4.0, so instead two read only variants of the commands were added. They are exactly like the original commands but refuse the &lt;code&gt;STORE&lt;/code&gt; and &lt;code&gt;STOREDIST&lt;/code&gt; options. The two variants are called &lt;code&gt;GEORADIUS_RO&lt;/code&gt; and &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt;, and can safely be used in replicas.</source>
          <target state="translated">過去との互換性を壊すことは考慮されましたが、少なくともRedis 4.0では拒否されたため、代わりにコマンドの2つの読み取り専用バリアントが追加されました。これらは元のコマンドとまったく同じですが、 &lt;code&gt;STORE&lt;/code&gt; および &lt;code&gt;STOREDIST&lt;/code&gt; オプションを拒否します。2つのバリアントは &lt;code&gt;GEORADIUS_RO&lt;/code&gt; および &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; と呼ばれ、レプリカで安全に使用できます。</target>
        </trans-unit>
        <trans-unit id="11d2a59be0a7424e67e9c632e3f055f99238638f" translate="yes" xml:space="preserve">
          <source>Bulk string reply</source>
          <target state="translated">一括文字列返信</target>
        </trans-unit>
        <trans-unit id="3e53e1d484c0afdd9ee478c43d641e56563db80a" translate="yes" xml:space="preserve">
          <source>But in the above case the output would be the same, since we have pending messages only for a single consumer. However what is important to keep in mind is that this operation, filtering by a specific consumer, is not inefficient even when there are many pending messages from many consumers: we have a pending entries list data structure both globally, and for every consumer, so we can very efficiently show just messages pending for a single consumer.</source>
          <target state="translated">しかし、上記のケースでは、1つのコンシューマに対してのみ保留メッセージがあるので、出力は同じになります。しかし、覚えておくべき重要なことは、この操作、特定の消費者によるフィルタリングは、多くの消費者からの多くの保留メッセージがあっても非効率ではないということです:私たちはグローバルに、そしてすべての消費者に対して保留エントリリストのデータ構造を持っているので、単一の消費者に対して保留されているメッセージだけを非常に効率的に表示することができます。</target>
        </trans-unit>
        <trans-unit id="9fb6518aff837e3fbb56cbdada4b700f62c1931e" translate="yes" xml:space="preserve">
          <source>By default (if /dev/urandom is available) the password is strong and can be used for other uses in the context of a Redis application, for instance in order to create unique session identifiers or other kind of unguessable and not colliding IDs. The password generation is also very cheap because we don't really ask /dev/urandom for bits at every execution. At startup Redis creates a seed using /dev/urandom, then it will use SHA256 in counter mode, with HMAC-SHA256(seed,counter) as primitive, in order to create more random bytes as needed. This means that the application developer should be feel free to abuse &lt;a href=&quot;acl-genpass&quot;&gt;ACL GENPASS&lt;/a&gt; to create as many secure pseudorandom strings as needed.</source>
          <target state="translated">デフォルトでは（/ dev / urandomが使用可能な場合）、パスワードは強力であり、Redisアプリケーションのコンテキストで他の用途に使用できます。たとえば、一意のセッションIDや、他の種類の推測不可能で衝突しないIDを作成するために使用できます。実行のたびに/ dev / urandomにビットを要求しないため、パスワードの生成も非常に安価です。起動時に、Redisは/ dev / urandomを使用してシードを作成し、必要に応じてさらにランダムなバイトを作成するために、HMAC-SHA256（seed、counter）をプリミティブとして、カウンターモードでSHA256を使用します。これは、アプリケーション開発者が&lt;a href=&quot;acl-genpass&quot;&gt;ACL GENPASS&lt;/a&gt;を悪用して、必要な数の安全な疑似ランダム文字列を自由に作成できることを意味します。</target>
        </trans-unit>
        <trans-unit id="5c8217506d8ebbaa0e107de581511ee5f509b818" translate="yes" xml:space="preserve">
          <source>By default all the bytes contained in the string are examined. It is possible to specify the counting operation only in an interval passing the additional arguments &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt;.</source>
          <target state="translated">デフォルトでは、文字列に含まれるすべてのバイトが検査されます。追加の引数&lt;em&gt;start&lt;/em&gt;および&lt;em&gt;end&lt;/em&gt;を渡す間隔でのみ、カウント操作を指定できます。</target>
        </trans-unit>
        <trans-unit id="9e9840a0fb9a28f465bc984e84fdef1e46818881" translate="yes" xml:space="preserve">
          <source>By default all the matching items are returned. It is possible to limit the results to the first N matching items by using the &lt;strong&gt;COUNT &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt;&lt;/strong&gt; option. However note that internally the command needs to perform an effort proportional to the number of items matching the specified area, so to query very large areas with a very small &lt;code&gt;COUNT&lt;/code&gt; option may be slow even if just a few results are returned. On the other hand &lt;code&gt;COUNT&lt;/code&gt; can be a very effective way to reduce bandwidth usage if normally just the first results are used.</source>
          <target state="translated">デフォルトでは、一致するすべてのアイテムが返されます。&lt;strong&gt;COUNT &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; &lt;/strong&gt;オプションを使用して、最初のN個の一致するアイテムに結果を制限することができます。ただし、内部的にコマンドは指定された領域に一致するアイテムの数に比例する作業を実行する必要があるため、非常に小さな &lt;code&gt;COUNT&lt;/code&gt; オプションを使用して非常に大きな領域をクエリする場合、結果が少しでも返されると遅くなる場合があります。一方、通常は最初の結果のみを使用する場合、 &lt;code&gt;COUNT&lt;/code&gt; は帯域幅の使用量を削減するための非常に効果的な方法です。</target>
        </trans-unit>
        <trans-unit id="38a3d7ce77609a064a8c66435e5a2ddef01589e2" translate="yes" xml:space="preserve">
          <source>By default the &lt;a href=&quot;lolwut&quot;&gt;LOLWUT&lt;/a&gt; command will display the piece corresponding to the current Redis version, however it is possible to display a specific version using the following form:</source>
          <target state="translated">デフォルトでは、&lt;a href=&quot;lolwut&quot;&gt;LOLWUT&lt;/a&gt;コマンドは現在のRedisバージョンに対応するピースを表示しますが、次のフォームを使用して特定のバージョンを表示することができます。</target>
        </trans-unit>
        <trans-unit id="1f9b368afa2761dde4363a1630f17429f8bc58b2" translate="yes" xml:space="preserve">
          <source>By default the client is unblocked as if the timeout of the command was reached, however if an additional (and optional) argument is passed, it is possible to specify the unblocking behavior, that can be &lt;strong&gt;TIMEOUT&lt;/strong&gt; (the default) or &lt;strong&gt;ERROR&lt;/strong&gt;. If &lt;strong&gt;ERROR&lt;/strong&gt; is specified, the behavior is to unblock the client returning as error the fact that the client was force-unblocked. Specifically the client will receive the following error:</source>
          <target state="translated">デフォルトでは、コマンドのタイムアウトに達したかのようにクライアントのブロックが解除されますが、追加の（およびオプションの）引数が渡された場合、ブロック解除の動作を指定できます。これは&lt;strong&gt;TIMEOUT&lt;/strong&gt;（デフォルト）または&lt;strong&gt;ERROR&lt;/strong&gt;です。場合は&lt;strong&gt;ERRORが&lt;/strong&gt;指定され、動作がエラーとしてクライアントが強制的にブロックされていないという事実を返すクライアントのブロックを解除することです。具体的には、クライアントは次のエラーを受け取ります。</target>
        </trans-unit>
        <trans-unit id="876aa0f6c00a7c0060c29d93b8e069bbd151098c" translate="yes" xml:space="preserve">
          <source>By default the command returns the items to the client. It is possible to store the results with one of these options:</source>
          <target state="translated">デフォルトでは、コマンドはクライアントにアイテムを返します。これらのオプションのいずれかを使用して結果を保存することができます。</target>
        </trans-unit>
        <trans-unit id="91bf3b958012756b0a4a417df15abcf41ceea42c" translate="yes" xml:space="preserve">
          <source>By default the scripting engine is always set to &lt;code&gt;REPL_ALL&lt;/code&gt;. By calling this function the user can switch on/off AOF and or replicas propagation, and turn them back later at her/his wish.</source>
          <target state="translated">デフォルトでは、スクリプトエンジンは常に &lt;code&gt;REPL_ALL&lt;/code&gt; に設定されています。この関数を呼び出すことにより、ユーザーはAOFやレプリカの伝播をオン/オフに切り替え、後で希望に応じて元に戻すことができます。</target>
        </trans-unit>
        <trans-unit id="d3714f33148cc538954cff3b58af732446c5cd76" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; returns the sorted elements to the client. With the &lt;code&gt;STORE&lt;/code&gt; option, the result will be stored as a list at the specified key instead of being returned to the client.</source>
          <target state="translated">デフォルトでは、&lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt;はソートされた要素をクライアントに返します。 &lt;code&gt;STORE&lt;/code&gt; のオプション、結果ではなく、クライアントに返されるの指定されたキーでリストとして保存されます。</target>
        </trans-unit>
        <trans-unit id="2ee8f070e37dc92ade46a57ac677a11708d8c9aa" translate="yes" xml:space="preserve">
          <source>By default, &lt;strong&gt;WRAP&lt;/strong&gt; is used if not otherwise specified.</source>
          <target state="translated">特に指定がない場合、デフォルトでは&lt;strong&gt;WRAP&lt;/strong&gt;が使用されます。</target>
        </trans-unit>
        <trans-unit id="f7b1d35e79bbf2da51d0b5f48b7d7d355bd0c2fd" translate="yes" xml:space="preserve">
          <source>By default, all the bytes contained in the string are examined. It is possible to look for bits only in a specified interval passing the additional arguments &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; (it is possible to just pass &lt;em&gt;start&lt;/em&gt;, the operation will assume that the end is the last byte of the string. However there are semantic differences as explained later). The range is interpreted as a range of bytes and not a range of bits, so &lt;code&gt;start=0&lt;/code&gt; and &lt;code&gt;end=2&lt;/code&gt; means to look at the first three bytes.</source>
          <target state="translated">デフォルトでは、文字列に含まれるすべてのバイトが検査されます。追加の引数&lt;em&gt;start&lt;/em&gt;と&lt;em&gt;end&lt;/em&gt;を渡して、指定された間隔でのみビットを検索することが可能です（&lt;em&gt;start&lt;/em&gt;だけを渡すこともできます。操作では、終了が文字列の最後のバイトであると想定されます。ただし、説明されているように意味上の違いがあります。後で）。範囲はビットの範囲ではなくバイトの範囲として解釈されるため、 &lt;code&gt;start=0&lt;/code&gt; および &lt;code&gt;end=2&lt;/code&gt; は最初の3バイトを調べることを意味します。</target>
        </trans-unit>
        <trans-unit id="ac56e3917c99c4ddfa64494c6e26b8240c053966" translate="yes" xml:space="preserve">
          <source>By default, all the matching items are returned. It is possible to limit the results to the first N matching items by using the &lt;strong&gt;COUNT &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt;&lt;/strong&gt; option. However note that internally the command needs to perform an effort proportional to the number of items matching the specified area, so to query very large areas with a very small &lt;code&gt;COUNT&lt;/code&gt; option may be slow even if just a few results are returned. On the other hand &lt;code&gt;COUNT&lt;/code&gt; can be a very effective way to reduce bandwidth usage if normally just the first results are used.</source>
          <target state="translated">デフォルトでは、一致するすべてのアイテムが返されます。&lt;strong&gt;COUNT &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; &lt;/strong&gt;オプションを使用すると、結果を最初のN個の一致するアイテムに制限することができます。ただし、内部的には、コマンドは指定された領域に一致するアイテムの数に比例する作業を実行する必要があるため、非常に小さな &lt;code&gt;COUNT&lt;/code&gt; オプションを使用して非常に大きな領域をクエリすると、返される結果がわずかであっても時間がかかる場合があります。一方、 &lt;code&gt;COUNT&lt;/code&gt; は、通常は最初の結果のみが使用される場合、帯域幅の使用量を削減するための非常に効果的な方法です。</target>
        </trans-unit>
        <trans-unit id="f97c897415a76335a4f3d3db770776a7a0ccedc3" translate="yes" xml:space="preserve">
          <source>By default, it stores the results in the &lt;code&gt;destintion&lt;/code&gt; sorted set with their geospatial information.</source>
          <target state="translated">デフォルトでは、地理空間情報とともに結果を &lt;code&gt;destintion&lt;/code&gt; ソートセットに保存します。</target>
        </trans-unit>
        <trans-unit id="5bcfb1fa8d4e16c5703f601d9b874b8021ef089f" translate="yes" xml:space="preserve">
          <source>By default, or when provided with the optional &lt;code&gt;=&lt;/code&gt; argument, the command performs exact trimming. That means that the trimmed stream's length will be exactly the minimum between its original length and the specified maximum length.</source>
          <target state="translated">デフォルトで、またはオプションの &lt;code&gt;=&lt;/code&gt; 引数が指定されている場合、コマンドは正確なトリミングを実行します。つまり、トリミングされたストリームの長さは、元の長さと指定された最大長の間の最小値になります。</target>
        </trans-unit>
        <trans-unit id="3dfdd218a8c7dcfad82b579c16fc98a90e0423ca" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;destination&lt;/code&gt; key is created in the logical database used by the connection. The &lt;code&gt;DB&lt;/code&gt; option allows specifying an alternative logical database index for the destination key.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;destination&lt;/code&gt; キーは接続で使用される論理データベースに作成されます。 &lt;code&gt;DB&lt;/code&gt; のオプションは、先のキーのための代替論理データベースのインデックスを指定することができます。</target>
        </trans-unit>
        <trans-unit id="ecf8d58c1f5391dbccf4f7678d43b4f133487bae" translate="yes" xml:space="preserve">
          <source>By default, the command pops a single element from the beginning of the list. When provided with the optional &lt;code&gt;count&lt;/code&gt; argument, the reply will consist of up to &lt;code&gt;count&lt;/code&gt; elements, depending on the list's length.</source>
          <target state="translated">デフォルトでは、コマンドはリストの最初から1つの要素をポップします。オプションの &lt;code&gt;count&lt;/code&gt; 引数を指定すると、リストの長さに応じて、応答は最大 &lt;code&gt;count&lt;/code&gt; 個の要素で構成されます。</target>
        </trans-unit>
        <trans-unit id="6fecef221e5ae822414f939e112035853e985bf7" translate="yes" xml:space="preserve">
          <source>By default, the command pops a single element from the end of the list. When provided with the optional &lt;code&gt;count&lt;/code&gt; argument, the reply will consist of up to &lt;code&gt;count&lt;/code&gt; elements, depending on the list's length.</source>
          <target state="translated">デフォルトでは、コマンドはリストの最後から1つの要素をポップします。オプションの &lt;code&gt;count&lt;/code&gt; 引数を指定すると、リストの長さに応じて、応答は最大 &lt;code&gt;count&lt;/code&gt; 個の要素で構成されます。</target>
        </trans-unit>
        <trans-unit id="3b7bd3b6d4bf2d2679ef9988f3c531b70e60e21c" translate="yes" xml:space="preserve">
          <source>By default, the command pops a single member from the set. When provided with the optional &lt;code&gt;count&lt;/code&gt; argument, the reply will consist of up to &lt;code&gt;count&lt;/code&gt; members, depending on the set's cardinality.</source>
          <target state="translated">デフォルトでは、コマンドはセットから1つのメンバーをポップします。オプションの &lt;code&gt;count&lt;/code&gt; 引数が指定されている場合、応答は、セットのカーディナリティに応じて、最大 &lt;code&gt;count&lt;/code&gt; のメンバーで構成されます。</target>
        </trans-unit>
        <trans-unit id="877bdcad724a6306efbd3a664f11efc0ec0b6fe6" translate="yes" xml:space="preserve">
          <source>By default, the command returns unsorted items. Two different sorting methods can be invoked using one of the following two options:</source>
          <target state="translated">既定では、このコマンドはソートされていない項目を返します。次の 2 つの異なるソート方法は、次の 2 つのオプションのいずれかを使用して呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="5529ebf0aa9355a448e5873d36ba97d16befd8bf" translate="yes" xml:space="preserve">
          <source>By default, the interval specified by &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; is closed (inclusive). It is possible to specify an open interval (exclusive) by prefixing the score with the character &lt;code&gt;(&lt;/code&gt;. For example:</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;min&lt;/code&gt; と &lt;code&gt;max&lt;/code&gt; で指定された間隔は閉じています（両端を含みます）。スコアの前に文字 &lt;code&gt;(&lt;/code&gt; ）を付けることにより、オープンインターバル（排他的）を指定できます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="b8a1843f4f52d23022ae70457e87a2bbc0c8ed29" translate="yes" xml:space="preserve">
          <source>By default, the resulting score of an element is the sum of its scores in the sorted sets where it exists.</source>
          <target state="translated">デフォルトでは、結果として得られる要素のスコアは、その要素が存在するソートされたセットのスコアの合計となります。</target>
        </trans-unit>
        <trans-unit id="4665873e5c58037455475bf4706b458811098286" translate="yes" xml:space="preserve">
          <source>By default, the resulting score of an element is the sum of its scores in the sorted sets where it exists. Because intersection requires an element to be a member of every given sorted set, this results in the score of every element in the resulting sorted set to be equal to the number of input sorted sets.</source>
          <target state="translated">デフォルトでは、結果として得られる要素のスコアは、その要素が存在するソートされた集合のスコアの合計となります。交差は要素が与えられたソート集合のすべてのメンバーである必要があるので、結果として得られるソート集合のすべての要素のスコアは入力されたソート集合の数と等しくなります。</target>
        </trans-unit>
        <trans-unit id="9bd72014f313a48aa376a2f9743fd29947ddbfa2" translate="yes" xml:space="preserve">
          <source>By getting the string representation of a bitmap, the client can then parse the response's bytes by extracting the bit values using native bit operations in its native programming language. Symmetrically, it is also possible to set an entire bitmap by performing the bits-to-bytes encoding in the client and calling &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; with the resultant string.</source>
          <target state="translated">クライアントは、ビットマップの文字列表現を取得することにより、ネイティブプログラミング言語のネイティブビット演算を使用してビット値を抽出することにより、応答のバイトを解析できます。対称的に、クライアントでビットからバイトへのエンコードを実行し、結果の文字列を使用して&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;を呼び出すことにより、ビットマップ全体を設定することもできます。</target>
        </trans-unit>
        <trans-unit id="855731f4a53411098556da94791141678c87de9e" translate="yes" xml:space="preserve">
          <source>C1 and C2 read &lt;code&gt;lock.foo&lt;/code&gt; to check the timestamp, because they both received &lt;code&gt;0&lt;/code&gt; after executing &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;, as the lock is still held by C3 that crashed after holding the lock.</source>
          <target state="translated">C1とC2 は、ロックを保持した後にクラッシュしたC3によってロックが保持されているため、&lt;a href=&quot;setnx&quot;&gt;SETNXの&lt;/a&gt;実行後にどちらも &lt;code&gt;0&lt;/code&gt; を受け取ったため、 &lt;code&gt;lock.foo&lt;/code&gt; を読み取ってタイムスタンプをチェックしました。</target>
        </trans-unit>
        <trans-unit id="2d7ad86157ffa8a81154afc21adf4e9506f4075d" translate="yes" xml:space="preserve">
          <source>C1 sends &lt;code&gt;DEL lock.foo&lt;/code&gt;</source>
          <target state="translated">C1は &lt;code&gt;DEL lock.foo&lt;/code&gt; を送信します</target>
        </trans-unit>
        <trans-unit id="59e76a6cffa5164edb0398cd905358d159247029" translate="yes" xml:space="preserve">
          <source>C1 sends &lt;code&gt;SETNX lock.foo&lt;/code&gt; and it succeeds</source>
          <target state="translated">C1は &lt;code&gt;SETNX lock.foo&lt;/code&gt; を送信し、成功します</target>
        </trans-unit>
        <trans-unit id="4f7c62ca261230ba7bd6b9233369caaf27e7f01d" translate="yes" xml:space="preserve">
          <source>C2 sends &lt;code&gt;DEL lock.foo&lt;/code&gt;</source>
          <target state="translated">C2は &lt;code&gt;DEL lock.foo&lt;/code&gt; を送信します</target>
        </trans-unit>
        <trans-unit id="193179deba47ad9e120a60484e3cc95253ac5a6a" translate="yes" xml:space="preserve">
          <source>C2 sends &lt;code&gt;SETNX lock.foo&lt;/code&gt; and it succeeds</source>
          <target state="translated">C2は &lt;code&gt;SETNX lock.foo&lt;/code&gt; を送信し、成功します</target>
        </trans-unit>
        <trans-unit id="151ee6de467b9561ff1e9f5ec7724e1aafaaa74e" translate="yes" xml:space="preserve">
          <source>C4 sends &lt;code&gt;GET lock.foo&lt;/code&gt; to check if the lock expired. If it is not, it will sleep for some time and retry from the start.</source>
          <target state="translated">C4は &lt;code&gt;GET lock.foo&lt;/code&gt; を送信して、ロックの有効期限が切れているかどうかを確認します。そうでない場合は、しばらくスリープし、最初から再試行します。</target>
        </trans-unit>
        <trans-unit id="80d7499d35c9d242f43ac8ad8f3d435904ce4b07" translate="yes" xml:space="preserve">
          <source>C4 sends &lt;code&gt;SETNX lock.foo&lt;/code&gt; in order to acquire the lock</source>
          <target state="translated">C4 はロックを取得するために &lt;code&gt;SETNX lock.foo&lt;/code&gt; を送信します</target>
        </trans-unit>
        <trans-unit id="810aa98e90b76fd25ebaacd1fecaebbe5cca1fd8" translate="yes" xml:space="preserve">
          <source>CJSON</source>
          <target state="translated">CJSON</target>
        </trans-unit>
        <trans-unit id="289fd6dd86c78fc18484670bd5337ffc1457b23f" translate="yes" xml:space="preserve">
          <source>CLIENT</source>
          <target state="translated">CLIENT</target>
        </trans-unit>
        <trans-unit id="63a953234a4a4b23595b8f5c3d66ad8e228bb360" translate="yes" xml:space="preserve">
          <source>CLIENT CACHING  YES|NO   Instruct the server about tracking or not keys in the next request</source>
          <target state="translated">CLIENT CACHING YES|NO 次のリクエストで鍵を追跡するかどうかをサーバに指示する</target>
        </trans-unit>
        <trans-unit id="9a086feff67c072f67169a1a10544440c06a27bb" translate="yes" xml:space="preserve">
          <source>CLIENT GETNAME   Get the current connection name</source>
          <target state="translated">CLIENT GETNAME 現在の接続名を取得します。</target>
        </trans-unit>
        <trans-unit id="4c39ac03d0deadf47c0778e94147170cfe5cc290" translate="yes" xml:space="preserve">
          <source>CLIENT GETREDIR   Get tracking notifications redirection client ID if any</source>
          <target state="translated">CLIENT GETREDIR トラッキング通知のリダイレクトのクライアントIDを取得します。</target>
        </trans-unit>
        <trans-unit id="1f043bd4293df18cf326994e345f63d6a607a715" translate="yes" xml:space="preserve">
          <source>CLIENT ID   Returns the client ID for the current connection</source>
          <target state="translated">CLIENT ID 現在の接続のクライアントIDを返します。</target>
        </trans-unit>
        <trans-unit id="2cc6c98e277f7b4b6dd7682b2772443f1b2745eb" translate="yes" xml:space="preserve">
          <source>CLIENT INFO   Returns information about the current client connection.</source>
          <target state="translated">CLIENT INFO 現在のクライアント接続に関する情報を返します。</target>
        </trans-unit>
        <trans-unit id="a606744e377765ead3bebe7af7be75bec984bac6" translate="yes" xml:space="preserve">
          <source>CLIENT KILL  [ip:port] [ID client-id] [TYPE normal|master|slave|pubsub] [ADDR ip:port] [SKIPME yes/no]   Kill the connection of a client</source>
          <target state="translated">CLIENT KILL [ip:port][ID client-id][TYPE normal|master|slave|pubsub][ADDR ip:port][SKIPME yes/no]クライアントの接続を切断します。</target>
        </trans-unit>
        <trans-unit id="0962c4ff7046d5e0349aa07792ed564b6ac58b3e" translate="yes" xml:space="preserve">
          <source>CLIENT KILL  [ip:port] [ID client-id] [TYPE normal|master|slave|pubsub] [USER username] [ADDR ip:port] [SKIPME yes/no]   Kill the connection of a client</source>
          <target state="translated">CLIENT KILL [ip:port][ID client-id][TYPE normal|master|slave|pubsub][USER username][ADDR ip:port][SKIPME yes/no]クライアントの接続を切断します。</target>
        </trans-unit>
        <trans-unit id="40f78df8d4251b437ca6d0591e3d79df9db9a668" translate="yes" xml:space="preserve">
          <source>CLIENT KILL and Redis Sentinel</source>
          <target state="translated">CLIENT KILL と Redis Sentinel</target>
        </trans-unit>
        <trans-unit id="5abdfb863c66ad1708626a5caaaa3f3ae356f31e" translate="yes" xml:space="preserve">
          <source>CLIENT LIST  [TYPE normal|master|replica|pubsub]   Get the list of client connections</source>
          <target state="translated">CLIENT LIST [TYPE normal|master|replica|pubsub]クライアント接続のリストを取得します。</target>
        </trans-unit>
        <trans-unit id="0f9e74e993d542e852824191d195f334f18cdbad" translate="yes" xml:space="preserve">
          <source>CLIENT LIST  [TYPE normal|master|replica|pubsub] [ID client-id [client-id ...]]   Get the list of client connections</source>
          <target state="translated">CLIENT LIST [TYPE normal|master|replica|pubsub][ID client-id [client-id ...]クライアント接続のリストを取得します</target>
        </trans-unit>
        <trans-unit id="cdde82d80a6c631c41a96bc80027350e01ff9d66" translate="yes" xml:space="preserve">
          <source>CLIENT PAUSE  timeout   Stop processing commands from clients for some time</source>
          <target state="translated">CLIENT PAUSE タイムアウト クライアントからのコマンド処理をしばらくの間停止します。</target>
        </trans-unit>
        <trans-unit id="cdc920d32af4c13e5383224eaafad4a5e97a22e0" translate="yes" xml:space="preserve">
          <source>CLIENT REPLY  ON|OFF|SKIP   Instruct the server whether to reply to commands</source>
          <target state="translated">CLIENT REPLY ON|OFF|SKIP コマンドに返信するかどうかをサーバに指示する</target>
        </trans-unit>
        <trans-unit id="5de18cdee05387ac2edf2c59d640ef325da93c25" translate="yes" xml:space="preserve">
          <source>CLIENT SETNAME  connection-name   Set the current connection name</source>
          <target state="translated">CLIENT SETNAME connection-name 現在の接続名を設定します。</target>
        </trans-unit>
        <trans-unit id="95279f3b4d86b3dc0268ddf4db1feb274847cc8c" translate="yes" xml:space="preserve">
          <source>CLIENT TRACKING  ON|OFF [REDIRECT client-id] [PREFIX prefix [PREFIX prefix ...]] [BCAST] [OPTIN] [OPTOUT] [NOLOOP]   Enable or disable server assisted client side caching support</source>
          <target state="translated">CLIENT TRACKING ON|OFF [REDIRECT client-id][PREFIX prefix [PREFIX prefix ...]]BCAST][OPTIN][OPTOUT][NOLOOP]サーバー支援型クライアントサイドキャッシングのサポートを有効または無効にします。</target>
        </trans-unit>
        <trans-unit id="bd550a8d7b9512156ea1471fdd3b700157d0ab6e" translate="yes" xml:space="preserve">
          <source>CLIENT TRACKINGINFO   Return information about server assisted client side caching for the current connection</source>
          <target state="translated">CLIENT TRACKINGINFO 現在の接続のためのサーバ支援型クライアントサイドキャッシングに関する情報を返します。</target>
        </trans-unit>
        <trans-unit id="326b6f4d4510070631ac4ab9eaf85a825c42c2a7" translate="yes" xml:space="preserve">
          <source>CLIENT UNBLOCK  client-id [TIMEOUT|ERROR]   Unblock a client blocked in a blocking command from a different connection</source>
          <target state="translated">CLIENT UNBLOCK client-id [TIMEOUT|ERROR]ブロッキングコマンドでブロックされたクライアントを別の接続からブロック解除する</target>
        </trans-unit>
        <trans-unit id="e3b9b52696ca51803a72a1787b8689b560877e3b" translate="yes" xml:space="preserve">
          <source>CLUSTER</source>
          <target state="translated">CLUSTER</target>
        </trans-unit>
        <trans-unit id="89c0d390cdc52475692a036944dfe3e1af10aa52" translate="yes" xml:space="preserve">
          <source>CLUSTER ADDSLOTS  slot [slot ...]   Assign new hash slots to receiving node</source>
          <target state="translated">CLUSTER ADDSLOTS slot [slot ...]受信ノードに新しいハッシュスロットを割り当てる</target>
        </trans-unit>
        <trans-unit id="00fb8c41d977c173c87d67428daf985f10049f97" translate="yes" xml:space="preserve">
          <source>CLUSTER BUMPEPOCH   Advance the cluster config epoch</source>
          <target state="translated">CLUSTER BUMPEPOCH クラスタ構成エポックを前進させる</target>
        </trans-unit>
        <trans-unit id="fc6a3f907637996a1389e46617de4c73581acb5f" translate="yes" xml:space="preserve">
          <source>CLUSTER COUNT-FAILURE-REPORTS  node-id   Return the number of failure reports active for a given node</source>
          <target state="translated">CLUSTER COUNT-FAILURE-REPORTS node-id 指定されたノードでアクティブな障害レポートの数を返します。</target>
        </trans-unit>
        <trans-unit id="8de0ad0623c7725bc7b50d19dfafe919652d9ddd" translate="yes" xml:space="preserve">
          <source>CLUSTER COUNTKEYSINSLOT  slot   Return the number of local keys in the specified hash slot</source>
          <target state="translated">CLUSTER COUNTKEYSINSLOT slot 指定されたハッシュスロット内のローカル鍵の数を返します。</target>
        </trans-unit>
        <trans-unit id="a291825c5518befaa628dbca584ac74adfdd3dc0" translate="yes" xml:space="preserve">
          <source>CLUSTER DELSLOTS  slot [slot ...]   Set hash slots as unbound in receiving node</source>
          <target state="translated">CLUSTER DELSLOTS slot [slot ...]受信ノードでハッシュスロットをアンバウンドに設定します。</target>
        </trans-unit>
        <trans-unit id="9b2690b6fa91e96bd2f73d5972dcb19de160e151" translate="yes" xml:space="preserve">
          <source>CLUSTER FAILOVER  [FORCE|TAKEOVER]   Forces a replica to perform a manual failover of its master.</source>
          <target state="translated">CLUSTER FAILOVER [FORCE|TAKEOVER]レプリカにマスターの手動フェイルオーバーを強制的に実行させます。</target>
        </trans-unit>
        <trans-unit id="94cefd9c3cfc8c0aca11125b97d7b0fd362d0d4a" translate="yes" xml:space="preserve">
          <source>CLUSTER FLUSHSLOTS   Delete a node's own slots information</source>
          <target state="translated">CLUSTER FLUSHSLOTS ノード自身のスロット情報を削除します。</target>
        </trans-unit>
        <trans-unit id="e739c9ee11fd419a688da991d447a266021c6ef0" translate="yes" xml:space="preserve">
          <source>CLUSTER FORGET  node-id   Remove a node from the nodes table</source>
          <target state="translated">CLUSTER FORGET node-id ノードテーブルからノードを削除する</target>
        </trans-unit>
        <trans-unit id="63b393dc8cc3734128967f68eb934005c0c5a24f" translate="yes" xml:space="preserve">
          <source>CLUSTER GETKEYSINSLOT  slot count   Return local key names in the specified hash slot</source>
          <target state="translated">CLUSTER GETKEYSINSLOT slot count 指定されたハッシュスロット内のローカルキー名を返します。</target>
        </trans-unit>
        <trans-unit id="96ff44fb1ff41b2047e38a9dd4b9b91ab3a48e50" translate="yes" xml:space="preserve">
          <source>CLUSTER INFO   Provides info about Redis Cluster node state</source>
          <target state="translated">CLUSTER INFO Redis クラスタのノード状態に関する情報を提供します。</target>
        </trans-unit>
        <trans-unit id="bceb7d0f89d15cad163cf00743841fee0d54ad57" translate="yes" xml:space="preserve">
          <source>CLUSTER KEYSLOT  key   Returns the hash slot of the specified key</source>
          <target state="translated">CLUSTER KEYSLOT key 指定したキーのハッシュスロットを返します。</target>
        </trans-unit>
        <trans-unit id="db6dfe9195f872c1e24e77eca06229e51f545369" translate="yes" xml:space="preserve">
          <source>CLUSTER MEET  ip port   Force a node cluster to handshake with another node</source>
          <target state="translated">CLUSTER MEET ip port ノードクラスタが他のノードとのハンドシェイクを強制的に行います。</target>
        </trans-unit>
        <trans-unit id="4c0ca20cada3909d25d2d4e2035e56d2e9daba1b" translate="yes" xml:space="preserve">
          <source>CLUSTER MYID   Return the node id</source>
          <target state="translated">CLUSTER MYID ノードIDを返します。</target>
        </trans-unit>
        <trans-unit id="45bb4b8fb75be9f6506f8df1b5feecc8fcb42818" translate="yes" xml:space="preserve">
          <source>CLUSTER NODES   Get Cluster config for the node</source>
          <target state="translated">CLUSTER NODES ノードのクラスタ設定を取得します。</target>
        </trans-unit>
        <trans-unit id="cb1b81c97abbdb844bd68109bd5c641a604ec477" translate="yes" xml:space="preserve">
          <source>CLUSTER REPLICAS  node-id   List replica nodes of the specified master node</source>
          <target state="translated">CLUSTER REPLICAS node-id 指定されたマスターノードのレプリカノードをリストアップします。</target>
        </trans-unit>
        <trans-unit id="0c1d4ab714df1ed96b53ecea55f9b15118926ddd" translate="yes" xml:space="preserve">
          <source>CLUSTER REPLICATE  node-id   Reconfigure a node as a replica of the specified master node</source>
          <target state="translated">CLUSTER REPLICATE node-id 指定されたマスター・ノードのレプリカとしてノードを再構成します。</target>
        </trans-unit>
        <trans-unit id="fdd669bf0a4695d61100d82b95672d6f0265fa98" translate="yes" xml:space="preserve">
          <source>CLUSTER RESET  [HARD|SOFT]   Reset a Redis Cluster node</source>
          <target state="translated">CLUSTER RESET [HARD|SOFT]Redisクラスタノードのリセット</target>
        </trans-unit>
        <trans-unit id="4452e5582d47e8dfe0990f92ac43fa0dcf4415d8" translate="yes" xml:space="preserve">
          <source>CLUSTER SAVECONFIG   Forces the node to save cluster state on disk</source>
          <target state="translated">CLUSTER SAVECONFIG クラスタの状態をディスクに保存するようにノードを強制的にします。</target>
        </trans-unit>
        <trans-unit id="0352d198b3e3c3480eec41371b3ead5bc1188b13" translate="yes" xml:space="preserve">
          <source>CLUSTER SET-CONFIG-EPOCH  config-epoch   Set the configuration epoch in a new node</source>
          <target state="translated">CLUSTER SET-CONFIG-EPOCH config-epoch 新規ノードのコンフィグレーションエポックを設定します。</target>
        </trans-unit>
        <trans-unit id="717b30894068edcc566f30c183079158fcd2ebb3" translate="yes" xml:space="preserve">
          <source>CLUSTER SETSLOT  slot IMPORTING|MIGRATING|STABLE|NODE [node-id]   Bind a hash slot to a specific node</source>
          <target state="translated">CLUSTER SETSLOT slot IMPORTING|MIGRATING|STABLE|NODE [node-id]ハッシュスロットを特定のノードにバインドします。</target>
        </trans-unit>
        <trans-unit id="6998d43f245cd331b3038d9db49ce51e5fbe657b" translate="yes" xml:space="preserve">
          <source>CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; IMPORTING &lt;code&gt;&amp;lt;source-node-id&amp;gt;&lt;/code&gt;</source>
          <target state="translated">CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; IMPORTING &lt;code&gt;&amp;lt;source-node-id&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df0cda76712dac386672dd77ffb08df9386d4ded" translate="yes" xml:space="preserve">
          <source>CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; MIGRATING &lt;code&gt;&amp;lt;destination-node-id&amp;gt;&lt;/code&gt;</source>
          <target state="translated">CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; MIGRATING &lt;code&gt;&amp;lt;destination-node-id&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e87c55a08cdeb007d9466cda6f41bd3aa8b0b08f" translate="yes" xml:space="preserve">
          <source>CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; NODE &lt;code&gt;&amp;lt;node-id&amp;gt;&lt;/code&gt;</source>
          <target state="translated">CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; NODE &lt;code&gt;&amp;lt;node-id&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8050d05e7c830b724efadb1fb19908cbba0c3b12" translate="yes" xml:space="preserve">
          <source>CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; STABLE</source>
          <target state="translated">CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; STABLE</target>
        </trans-unit>
        <trans-unit id="87d7c95e3334e2c65e594f6606b11d6fa033b8e3" translate="yes" xml:space="preserve">
          <source>CLUSTER SLAVES  node-id   List replica nodes of the specified master node</source>
          <target state="translated">CLUSTER SLAVES node-id 指定されたマスターノードのレプリカノードをリストアップします。</target>
        </trans-unit>
        <trans-unit id="0b83235580afb6dcdbb5aaae9069030836332846" translate="yes" xml:space="preserve">
          <source>CLUSTER SLOTS   Get array of Cluster slot to node mappings</source>
          <target state="translated">CLUSTER SLOTS クラスタスロットとノードのマッピングの配列を取得します。</target>
        </trans-unit>
        <trans-unit id="2e4854d8dd31ab3a1bd0bbce1a9b8c73da88c413" translate="yes" xml:space="preserve">
          <source>COMMAND</source>
          <target state="translated">COMMAND</target>
        </trans-unit>
        <trans-unit id="5d475d3ae2a090a5dd4fb9bcb4834f2b0f5e8e36" translate="yes" xml:space="preserve">
          <source>COMMAND   Get array of Redis command details</source>
          <target state="translated">COMMAND Redisコマンドの詳細の配列を取得します。</target>
        </trans-unit>
        <trans-unit id="243f2ac950baaf718523fe42c2f35baa4d002daa" translate="yes" xml:space="preserve">
          <source>COMMAND COUNT   Get total number of Redis commands</source>
          <target state="translated">COMMAND COUNT Redisコマンドの総数を取得します。</target>
        </trans-unit>
        <trans-unit id="b5c43f716c4692946b372734d13302625935ddef" translate="yes" xml:space="preserve">
          <source>COMMAND GETKEYS   Extract keys given a full Redis command</source>
          <target state="translated">COMMAND GETKEYS Redisのフルコマンドで与えられたキーを抽出します。</target>
        </trans-unit>
        <trans-unit id="e4f0ee016bdc14d304548515037906095d7beb51" translate="yes" xml:space="preserve">
          <source>COMMAND INFO  command-name [command-name ...]   Get array of specific Redis command details</source>
          <target state="translated">COMMAND INFO command-name [command-name ...]特定の Redis コマンドの詳細の配列を取得します。</target>
        </trans-unit>
        <trans-unit id="2fb60054b43a25d7a958d3d19bdb1aa7809577a8" translate="yes" xml:space="preserve">
          <source>CONFIG</source>
          <target state="translated">CONFIG</target>
        </trans-unit>
        <trans-unit id="d3f495884e312ef94089cef1025f98afac649a7f" translate="yes" xml:space="preserve">
          <source>CONFIG GET  parameter   Get the value of a configuration parameter</source>
          <target state="translated">CONFIG GET パラメータ 構成パラメータの値を取得します。</target>
        </trans-unit>
        <trans-unit id="d6c004f361be600273602c08f69569c9b929d35b" translate="yes" xml:space="preserve">
          <source>CONFIG RESETSTAT   Reset the stats returned by INFO</source>
          <target state="translated">CONFIG RESETSTAT INFO で返された統計情報をリセットします。</target>
        </trans-unit>
        <trans-unit id="07fd8b85f66f97280cb2ad55982da60cacbe7682" translate="yes" xml:space="preserve">
          <source>CONFIG REWRITE   Rewrite the configuration file with the in memory configuration</source>
          <target state="translated">CONFIG REWRITE メモリ内の設定で設定ファイルを書き換えます。</target>
        </trans-unit>
        <trans-unit id="d27538b14c1ebc5ce34011e7bb5ef99fff52c53d" translate="yes" xml:space="preserve">
          <source>CONFIG REWRITE is also able to rewrite the configuration file from scratch if the original one no longer exists for some reason. However if the server was started without a configuration file at all, the CONFIG REWRITE will just return an error.</source>
          <target state="translated">CONFIG REWRITEは、何らかの理由で元の設定ファイルが存在しなくなった場合、設定ファイルを一から書き換えることもできます。しかし、サーバーが設定ファイルなしで起動された場合、CONFIG REWRITEはエラーを返すだけです。</target>
        </trans-unit>
        <trans-unit id="bcdc354e91b58a18cc7f424a767e01c256e6b42b" translate="yes" xml:space="preserve">
          <source>CONFIG SET  parameter value   Set a configuration parameter to the given value</source>
          <target state="translated">CONFIG SET パラメータ値 コンフィグレーション・パラメータを指定した値に設定します。</target>
        </trans-unit>
        <trans-unit id="aecf0292da85cb2048d8b648567127d024d4074f" translate="yes" xml:space="preserve">
          <source>COPY</source>
          <target state="translated">COPY</target>
        </trans-unit>
        <trans-unit id="b3729b7bb933c36d809f0e8ba9d3228341d27148" translate="yes" xml:space="preserve">
          <source>COPY  source destination [DB destination-db] [REPLACE]   Copy a key</source>
          <target state="translated">COPY ソースデスティネーション [DB destination-db][REPLACE]キーをコピーします。</target>
        </trans-unit>
        <trans-unit id="5ba6c24ce4497d078be48b670ad16cc43d57f929" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; with a broken, negative, out of range, or otherwise invalid cursor, will result into undefined behavior but never into a crash. What will be undefined is that the guarantees about the returned elements can no longer be ensured by the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; implementation.</source>
          <target state="translated">壊れた、負の、範囲外のカーソル、または無効なカーソルで&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;を呼び出すと、未定義の動作になりますが、クラッシュすることはありません。未定義になるのは、返された要素に関する保証が&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;実装によって保証されなくなったことです。</target>
        </trans-unit>
        <trans-unit id="5f46be6632e20880fa3190f308734a7c2debc935" translate="yes" xml:space="preserve">
          <source>Calling SCAN with a corrupted cursor</source>
          <target state="translated">破損したカーソルでのSCANの呼び出し</target>
        </trans-unit>
        <trans-unit id="1e0b7fe9d077c2aa9a5144f650dffdcf03fa241c" translate="yes" xml:space="preserve">
          <source>Capped streams</source>
          <target state="translated">キャップ付きストリーム</target>
        </trans-unit>
        <trans-unit id="677509e3c92011eb7431eb950f99423de593897c" translate="yes" xml:space="preserve">
          <source>Care should be taken when executing &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; in the context of a pipelined request, since even in a pipeline the order of execution of commands must be guaranteed. If &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; will return a &lt;code&gt;NOSCRIPT&lt;/code&gt; error the command can not be reissued later otherwise the order of execution is violated.</source>
          <target state="translated">パイプラインでもリクエストの実行順序を保証する必要があるため、パイプライン化されたリクエストのコンテキストで&lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt;を実行する場合は注意が必要です。&lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt;が &lt;code&gt;NOSCRIPT&lt;/code&gt; エラーを返す場合、コマンドを後で再発行することはできません。そうでない場合、実行の順序に違反します。</target>
        </trans-unit>
        <trans-unit id="3c95b0aba9bde834d03663b5e6a82abbc6926a9f" translate="yes" xml:space="preserve">
          <source>Checking for all the available categories is as simple as:</source>
          <target state="translated">利用可能なすべてのカテゴリをチェックするのは簡単です。</target>
        </trans-unit>
        <trans-unit id="8eaf1e254fa69f8ab1d24e1e39a78203c7080474" translate="yes" xml:space="preserve">
          <source>Client IP address and port (4.0 only).</source>
          <target state="translated">クライアントの IP アドレスとポート (4.0 のみ)。</target>
        </trans-unit>
        <trans-unit id="5cf75075a191bc11d161c66570997946e05f966f" translate="yes" xml:space="preserve">
          <source>Client libraries may use Redis in order to test their own hashing algorithm, generating random keys and hashing them with both their local implementation and using Redis &lt;a href=&quot;cluster-keyslot&quot;&gt;CLUSTER KEYSLOT&lt;/a&gt; command, then checking if the result is the same.</source>
          <target state="translated">クライアントライブラリは、Redisを使用して独自のハッシュアルゴリズムをテストし、ランダムキーを生成して、ローカル実装とRedis &lt;a href=&quot;cluster-keyslot&quot;&gt;CLUSTER KEYSLOT&lt;/a&gt;コマンドの両方でハッシュし、結果が同じかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="5993bbb849b531146b7a95269c1882c6ff8a9ed3" translate="yes" xml:space="preserve">
          <source>Client name if set via the &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt; command (4.0 only).</source>
          <target state="translated">&lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt;コマンドで設定されている場合のクライアント名（4.0のみ）。</target>
        </trans-unit>
        <trans-unit id="d75dc68bbdd56c9cbd58d4bbdabda84bcca2c47f" translate="yes" xml:space="preserve">
          <source>Cluster</source>
          <target state="translated">Cluster</target>
        </trans-unit>
        <trans-unit id="4a4e6b60b2ae77bbe874af6a70cdbaba6049e713" translate="yes" xml:space="preserve">
          <source>Cluster clients must be aware of key positions in commands so commands can go to matching instances, but Redis commands vary between accepting one key, multiple keys, or even multiple keys separated by other data.</source>
          <target state="translated">クラスタクライアントは、コマンドが一致するインスタンスに行くことができるように、コマンドのキー位置を認識する必要がありますが、Redisのコマンドは、1つのキーを受け入れるか、複数のキーを受け入れるか、あるいは他のデータで区切られた複数のキーを受け入れるかの違いがあります。</target>
        </trans-unit>
        <trans-unit id="13fb8a1716343d8d81faf3b82f500e80a846e807" translate="yes" xml:space="preserve">
          <source>Cluster note: in a Redis Cluster clients can subscribe to every node, and can also publish to every other node. The cluster will make sure that published messages are forwarded as needed. That said, &lt;a href=&quot;pubsub&quot;&gt;PUBSUB&lt;/a&gt;'s replies in a cluster only report information from the node's Pub/Sub context, rather than the entire cluster.</source>
          <target state="translated">クラスターに関する注意：Redisクラスターでは、クライアントはすべてのノードにサブスクライブでき、他のすべてのノードに公開することもできます。クラスターは、公開されたメッセージが必要に応じて転送されることを確認します。とは&lt;a href=&quot;pubsub&quot;&gt;いえ&lt;/a&gt;、クラスター内のPUBSUBの応答は、クラスター全体ではなく、ノードのPub / Subコンテキストからの情報のみを報告します。</target>
        </trans-unit>
        <trans-unit id="e3c356fac15c94ebf5b7447ee6cfaeb09fa342b3" translate="yes" xml:space="preserve">
          <source>Command Arity</source>
          <target state="translated">コマンドアリティ</target>
        </trans-unit>
        <trans-unit id="b25b9ea512e65182e9de25869fda9886e798f471" translate="yes" xml:space="preserve">
          <source>Command Name</source>
          <target state="translated">コマンド名</target>
        </trans-unit>
        <trans-unit id="72da5b475c49e9d5cba38602d80b0de205cc6bb7" translate="yes" xml:space="preserve">
          <source>Command arity &lt;em&gt;includes&lt;/em&gt; counting the command name itself.</source>
          <target state="translated">コマンドアリティに&lt;em&gt;は&lt;/em&gt;、コマンド名自体のカウントが&lt;em&gt;含まれ&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="7b7be4b904754c3884cb0bf72bfeb125fc2e6d02" translate="yes" xml:space="preserve">
          <source>Command arity follows a simple pattern:</source>
          <target state="translated">コマンドのアリティはシンプルなパターンに従います。</target>
        </trans-unit>
        <trans-unit id="da09292eaa6e23b8b1b1824949fffe53ca537116" translate="yes" xml:space="preserve">
          <source>Command flags is &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; containing one or more status replies:</source>
          <target state="translated">コマンドフラグは、1つ以上のステータス応答を含む&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;配列応答&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="d8fdc321243166f52a9f1732c47f181f168fb6cd" translate="yes" xml:space="preserve">
          <source>Command name is the command returned as a lowercase string.</source>
          <target state="translated">コマンド名は、小文字の文字列として返されるコマンドです。</target>
        </trans-unit>
        <trans-unit id="c03350e2365b375b5bb4ce53303074533ba05e9e" translate="yes" xml:space="preserve">
          <source>Command options</source>
          <target state="translated">コマンドオプション</target>
        </trans-unit>
        <trans-unit id="a4618f4b2f49e68da5c5eab1cb65f4e2cbae4e8c" translate="yes" xml:space="preserve">
          <source>Commands about keys already migrated are correctly processed in the context of the node which is the target of the migration, the new hash slot owner, in order to guarantee consistency.</source>
          <target state="translated">既に移行された鍵に関するコマンドは、整合性を保証するために、移行対象である新しいハッシュスロットの所有者であるノードのコンテキストで正しく処理されます。</target>
        </trans-unit>
        <trans-unit id="b7c78328ebde5dad6a0b828ac630676fb4437227" translate="yes" xml:space="preserve">
          <source>Commands about this hash slot are refused and a &lt;code&gt;MOVED&lt;/code&gt; redirection is generated as usually, but in the case the command follows an &lt;code&gt;ASKING&lt;/code&gt; command, in this case the command is executed.</source>
          <target state="translated">このハッシュスロットに関するコマンドは拒否され、通常どおり &lt;code&gt;MOVED&lt;/code&gt; リダイレクトが生成されますが、コマンドが &lt;code&gt;ASKING&lt;/code&gt; コマンドに続く場合、この場合、コマンドが実行されます。</target>
        </trans-unit>
        <trans-unit id="aa013f0386471baba0b09b24b999134de43d82e4" translate="yes" xml:space="preserve">
          <source>Commands denied because accessing keys not allowed in the current ACL rules.</source>
          <target state="translated">現在のACLルールではキーへのアクセスが許可されていないため、コマンドが拒否されました。</target>
        </trans-unit>
        <trans-unit id="3aef01612894a7eb8b7ac8feeb71f973dac67ca6" translate="yes" xml:space="preserve">
          <source>Commands denied because against the current ACL rules.</source>
          <target state="translated">現在の ACL ルールに反するため、コマンドが拒否されました。</target>
        </trans-unit>
        <trans-unit id="5080f3f78852fa61575aea2ee4cbd726a5e4c31e" translate="yes" xml:space="preserve">
          <source>Commands not logged by MONITOR</source>
          <target state="translated">MONITOR でログに記録されないコマンド</target>
        </trans-unit>
        <trans-unit id="b16b78407a41c93dd4cb4577acb6af8003abc8f6" translate="yes" xml:space="preserve">
          <source>Comments and the overall structure of the original redis.conf are preserved as much as possible.</source>
          <target state="translated">コメントや元の redis.conf の全体構造は可能な限り保存されています。</target>
        </trans-unit>
        <trans-unit id="b2729f5c12d7e85d14c701273c4956c936eacdf5" translate="yes" xml:space="preserve">
          <source>Complete list of commands currently requiring key location parsing:</source>
          <target state="translated">現在、キーロケーションの解析を必要とするコマンドの完全なリスト。</target>
        </trans-unit>
        <trans-unit id="85cf1af73ea4830e4844b1efcacdc1968badce3f" translate="yes" xml:space="preserve">
          <source>Computes the difference between the first and all successive input sorted sets and stores the result in &lt;code&gt;destination&lt;/code&gt;. The total number of input keys is specified by &lt;code&gt;numkeys&lt;/code&gt;.</source>
          <target state="translated">最初の入力とすべての連続する入力ソートセットの差を計算し、結果を &lt;code&gt;destination&lt;/code&gt; 格納します。入力キーの総数は &lt;code&gt;numkeys&lt;/code&gt; で指定されます。</target>
        </trans-unit>
        <trans-unit id="fdc6213bb38f415f44656ea01a54b34f86489a7e" translate="yes" xml:space="preserve">
          <source>Computes the intersection of &lt;code&gt;numkeys&lt;/code&gt; sorted sets given by the specified keys, and stores the result in &lt;code&gt;destination&lt;/code&gt;. It is mandatory to provide the number of input keys (&lt;code&gt;numkeys&lt;/code&gt;) before passing the input keys and the other (optional) arguments.</source>
          <target state="translated">指定されたキーで指定された &lt;code&gt;numkeys&lt;/code&gt; ソートセットの共通部分を計算し、結果を &lt;code&gt;destination&lt;/code&gt; に格納します。入力キーとその他の（オプションの）引数を渡す前に、入力キーの数（ &lt;code&gt;numkeys&lt;/code&gt; ）を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="9e0628d44bd94fff2a05cbf6e7329ac8c1542b4c" translate="yes" xml:space="preserve">
          <source>Computes the union of &lt;code&gt;numkeys&lt;/code&gt; sorted sets given by the specified keys, and stores the result in &lt;code&gt;destination&lt;/code&gt;. It is mandatory to provide the number of input keys (&lt;code&gt;numkeys&lt;/code&gt;) before passing the input keys and the other (optional) arguments.</source>
          <target state="translated">指定されたキーによって指定された &lt;code&gt;numkeys&lt;/code&gt; ソートセットの和集合を計算し、結果を &lt;code&gt;destination&lt;/code&gt; に格納します。入力キーとその他の（オプションの）引数を渡す前に、入力キーの数（ &lt;code&gt;numkeys&lt;/code&gt; ）を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="1ac361d8a1971640b6145bcc2b23471d096806f1" translate="yes" xml:space="preserve">
          <source>Conditions where a SHUTDOWN fails</source>
          <target state="translated">SHUTDOWNが失敗する条件</target>
        </trans-unit>
        <trans-unit id="6512ee1541e9a6c52d5bf7cf465332e8df25ea3c" translate="yes" xml:space="preserve">
          <source>Connection</source>
          <target state="translated">Connection</target>
        </trans-unit>
        <trans-unit id="ce5886d8502f58f63f333861b5077fd91e99a286" translate="yes" xml:space="preserve">
          <source>Consistency and WAIT</source>
          <target state="translated">一貫性とWAIT</target>
        </trans-unit>
        <trans-unit id="5f2f16b6f5d5be95f9b3876b338cd86be1794d28" translate="yes" xml:space="preserve">
          <source>Consistency with range functions in various programming languages</source>
          <target state="translated">様々なプログラミング言語におけるレンジ関数との整合性</target>
        </trans-unit>
        <trans-unit id="b36b2f89bb23664788c6f3dd35338c638ba28a39" translate="yes" xml:space="preserve">
          <source>Consumer groups in 30 seconds</source>
          <target state="translated">30秒で消費者グループ</target>
        </trans-unit>
        <trans-unit id="bd58f13135bb4a18278653a136394b666aadff83" translate="yes" xml:space="preserve">
          <source>Consumers in a consumer group are auto-created every time a new consumer name is mentioned by some command. However sometimes it may be useful to remove old consumers since they are no longer used. This form returns the number of pending messages that the consumer had before it was deleted.</source>
          <target state="translated">消費者グループの消費者は、新しい消費者名が何らかのコマンドで言及されるたびに自動生成されます。しかし、古いコンシューマはもう使われていないので、古いコンシューマを削除した方が便利な場合もあります。このフォームは、そのコンシューマが削除される前に持っていた保留中のメッセージの数を返します。</target>
        </trans-unit>
        <trans-unit id="93fee3ae260963d2ed888e760affe7075d85b781" translate="yes" xml:space="preserve">
          <source>Consumers in a consumer group are auto-created every time a new consumer name is mentioned by some command. They can also be explicitly created by using the following form:</source>
          <target state="translated">コンシューマ・グループのコンシューマは、新しいコンシューマ名が何らかのコマンドで言及されるたびに自動的に作成されます。また、以下の形式で明示的に作成することもできます。</target>
        </trans-unit>
        <trans-unit id="e04bdc35bafea7cf8c81eec69e12b57349af7a26" translate="yes" xml:space="preserve">
          <source>Conversion between Lua and Redis data types</source>
          <target state="translated">LuaとRedisのデータ型間の変換</target>
        </trans-unit>
        <trans-unit id="c74388ea06d766117ef931f93cf1e85e7c07bf21" translate="yes" xml:space="preserve">
          <source>Cost of running &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;の実行コスト</target>
        </trans-unit>
        <trans-unit id="f43fec16935ea429ca6c4332ec8b80a51c3b6c5e" translate="yes" xml:space="preserve">
          <source>Cost of running MONITOR</source>
          <target state="translated">MONITORのランニングコスト</target>
        </trans-unit>
        <trans-unit id="e55d91fd97c87e8a34c622a7e4794ffcc51bd61d" translate="yes" xml:space="preserve">
          <source>Count argument extension</source>
          <target state="translated">カウント引数拡張</target>
        </trans-unit>
        <trans-unit id="ed6fd4dc25ec3bdb3875f3c7192bde09b87a5801" translate="yes" xml:space="preserve">
          <source>Count the number of set bits (population counting) in a string.</source>
          <target state="translated">文字列のセットビット数(母集団数)をカウントします。</target>
        </trans-unit>
        <trans-unit id="852a7b974be96bbc7c6036398114250aedbb0dca" translate="yes" xml:space="preserve">
          <source>Create a key associated with a value that is obtained by deserializing the provided serialized value (obtained via &lt;a href=&quot;dump&quot;&gt;DUMP&lt;/a&gt;).</source>
          <target state="translated">提供されたシリアル化された値（&lt;a href=&quot;dump&quot;&gt;DUMP&lt;/a&gt;を介して取得）を逆シリアル化することによって取得される値に関連付けられたキーを作成します。</target>
        </trans-unit>
        <trans-unit id="1b9548967da77ce66eb092905a2179716e7c9d5d" translate="yes" xml:space="preserve">
          <source>Create a new consumer group associated with a stream.</source>
          <target state="translated">ストリームに関連付けられた新しい消費者グループを作成します。</target>
        </trans-unit>
        <trans-unit id="5c0f29bb78fb88abe065ad6df1e2bc2b5123eed8" translate="yes" xml:space="preserve">
          <source>Create an ACL user with the specified rules or modify the rules of an existing user. This is the main interface in order to manipulate Redis ACL users interactively: if the username does not exist, the command creates the username without any privilege, then reads from left to right all the rules provided as successive arguments, setting the user ACL rules as specified.</source>
          <target state="translated">指定されたルールでACLユーザを作成したり、既存のユーザのルールを変更したりします。これはRedis ACLユーザを対話的に操作するためのメインインターフェースです:ユーザ名が存在しない場合、コマンドは特権なしでユーザ名を作成し、連続した引数として提供されたすべてのルールを左から右に読み込んで、ユーザのACLルールを指定した通りに設定します。</target>
        </trans-unit>
        <trans-unit id="e8db62ea4abea13f4e50ca9316893c361ba8afd9" translate="yes" xml:space="preserve">
          <source>D ends re-added in the nodes table of A.</source>
          <target state="translated">AのノードテーブルにDの端が再追加されました。</target>
        </trans-unit>
        <trans-unit id="d6ddfbac6ec07c32e2eb043cdffc4a0b7cf14714" translate="yes" xml:space="preserve">
          <source>D is now empty, but still listed in the nodes table of A, B and C.</source>
          <target state="translated">Dは空になりましたが、A、B、Cのノードテーブルにはまだリストされています。</target>
        </trans-unit>
        <trans-unit id="5231dbf5c92399c707fd162111bff340755773aa" translate="yes" xml:space="preserve">
          <source>DBSIZE</source>
          <target state="translated">DBSIZE</target>
        </trans-unit>
        <trans-unit id="cd67c53a53d3f0097d3c5a23561287ae0d9fb415" translate="yes" xml:space="preserve">
          <source>DBSIZE   Return the number of keys in the selected database</source>
          <target state="translated">DBSIZE 選択されたデータベースのキーの数を返します。</target>
        </trans-unit>
        <trans-unit id="3f67e8f4eecf241b91f4cc8c976a487ade34d09d" translate="yes" xml:space="preserve">
          <source>DEBUG</source>
          <target state="translated">DEBUG</target>
        </trans-unit>
        <trans-unit id="64d12201fd531f0183ba8e8b6982cd30fb3885db" translate="yes" xml:space="preserve">
          <source>DEBUG OBJECT  key   Get debugging information about a key</source>
          <target state="translated">DEBUG OBJECT key キーに関するデバッグ情報を取得します。</target>
        </trans-unit>
        <trans-unit id="a9e1eb844a55b579a65a4c4467b589dca48f8f1a" translate="yes" xml:space="preserve">
          <source>DEBUG SEGFAULT   Make the server crash</source>
          <target state="translated">DEBUG SEGFAULT サーバーをクラッシュさせる</target>
        </trans-unit>
        <trans-unit id="d05cdacee2c153d405a26e62250727ce77ea0892" translate="yes" xml:space="preserve">
          <source>DECR</source>
          <target state="translated">DECR</target>
        </trans-unit>
        <trans-unit id="60ab4c3e9133d30eaf0ded676cadb4c538c56082" translate="yes" xml:space="preserve">
          <source>DECR  key   Decrement the integer value of a key by one</source>
          <target state="translated">DECR key キーの整数値を 1 つデクリメントします。</target>
        </trans-unit>
        <trans-unit id="dd8d57c1b1a5522fa21a54d374912c18ca797f47" translate="yes" xml:space="preserve">
          <source>DECRBY</source>
          <target state="translated">DECRBY</target>
        </trans-unit>
        <trans-unit id="8c2782a79fd11dffe9a2c86222797cdb763ac992" translate="yes" xml:space="preserve">
          <source>DECRBY  key decrement   Decrement the integer value of a key by the given number</source>
          <target state="translated">DECRBY key decrement キーの整数値を、与えられた数だけデクリメントします。</target>
        </trans-unit>
        <trans-unit id="4d017cb3dcf43d965d38a31c9ad97cefabc893fb" translate="yes" xml:space="preserve">
          <source>DEL</source>
          <target state="translated">DEL</target>
        </trans-unit>
        <trans-unit id="85fb2865a5ba87d91f28447addbf73c6630fa434" translate="yes" xml:space="preserve">
          <source>DEL  key [key ...]   Delete a key</source>
          <target state="translated">DEL キー [キー ...]キーを削除します。</target>
        </trans-unit>
        <trans-unit id="f70fbda4bf2a0042e1d9cc7f61715651b43106d6" translate="yes" xml:space="preserve">
          <source>DISCARD</source>
          <target state="translated">DISCARD</target>
        </trans-unit>
        <trans-unit id="7bb67c7109691456662bb20fddb311696e25ac95" translate="yes" xml:space="preserve">
          <source>DISCARD   Discard all commands issued after MULTI</source>
          <target state="translated">DISCARD MULTI後に発行されたコマンドを全て破棄します。</target>
        </trans-unit>
        <trans-unit id="fac3a6812b938bfbdd2af221e2fba7ec856f466e" translate="yes" xml:space="preserve">
          <source>DUMP</source>
          <target state="translated">DUMP</target>
        </trans-unit>
        <trans-unit id="88b9c1225fe8ce252d48041c949b9e8d2d7b90b3" translate="yes" xml:space="preserve">
          <source>DUMP  key   Return a serialized version of the value stored at the specified key.</source>
          <target state="translated">DUMP key 指定されたキーに格納されている値のシリアライズされたバージョンを返します。</target>
        </trans-unit>
        <trans-unit id="4220ea2836e7841048c2cdb7caf3ef474641deb4" translate="yes" xml:space="preserve">
          <source>Debugging Lua scripts</source>
          <target state="translated">Lua スクリプトのデバッグ</target>
        </trans-unit>
        <trans-unit id="f34ef3d0e6d55088a63bbe9a7135854f8a4a3c06" translate="yes" xml:space="preserve">
          <source>Decrements the number stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;decrement&lt;/code&gt;. If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されている数値を &lt;code&gt;decrement&lt;/code&gt; だけ減らします。キーが存在しない場合、操作を実行する前に &lt;code&gt;0&lt;/code&gt; に設定されます。キーに誤ったタイプの値が含まれている場合、または整数として表現できない文字列が含まれている場合は、エラーが返されます。この操作は64ビットの符号付き整数に制限されています。</target>
        </trans-unit>
        <trans-unit id="eabc98dcb44b2f848dc2b5fd749cc1976767b1ef" translate="yes" xml:space="preserve">
          <source>Decrements the number stored at &lt;code&gt;key&lt;/code&gt; by one. If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to &lt;strong&gt;64 bit signed integers&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されている数を1つ減らします。キーが存在しない場合、操作を実行する前に &lt;code&gt;0&lt;/code&gt; に設定されます。キーに誤ったタイプの値が含まれている場合、または整数として表現できない文字列が含まれている場合は、エラーが返されます。この操作は&lt;strong&gt;64ビットの符号付き整数に&lt;/strong&gt;制限されてい&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="543341d8d409be4e8e87f012a0d71ed9115a00c9" translate="yes" xml:space="preserve">
          <source>Delete all the keys found expired.</source>
          <target state="translated">見つかった期限切れのキーをすべて削除します。</target>
        </trans-unit>
        <trans-unit id="093f69205f9dd67871820195d9a0ab6b921ee71c" translate="yes" xml:space="preserve">
          <source>Delete all the keys of all the existing databases, not just the currently selected one. This command never fails.</source>
          <target state="translated">現在選択されているデータベースだけでなく、既存のすべてのデータベースのすべてのキーを削除します。このコマンドは決して失敗しません。</target>
        </trans-unit>
        <trans-unit id="1a8bf3d0326f070451b1d5d0c69c59a369de9555" translate="yes" xml:space="preserve">
          <source>Delete all the keys of the currently selected DB. This command never fails.</source>
          <target state="translated">現在選択されているDBのすべてのキーを削除します。このコマンドは決して失敗しません。</target>
        </trans-unit>
        <trans-unit id="26c0e71676fb555cdd0bb73d03160139913dfe07" translate="yes" xml:space="preserve">
          <source>Delete all the specified ACL users and terminate all the connections that are authenticated with such users. Note: the special &lt;code&gt;default&lt;/code&gt; user cannot be removed from the system, this is the default user that every new connection is authenticated with. The list of users may include usernames that do not exist, in such case no operation is performed for the non existing users.</source>
          <target state="translated">指定されたすべてのACLユーザーを削除し、そのようなユーザーで認証されたすべての接続を終了します。注：特別な &lt;code&gt;default&lt;/code&gt; ユーザーをシステムから削除することはできません。これは、すべての新しい接続が認証されるデフォルトユーザーです。ユーザーのリストには、存在しないユーザー名が含まれている場合があります。その場合、存在しないユーザーに対して操作は実行されません。</target>
        </trans-unit>
        <trans-unit id="5165f9fa25a0905a85123f97b0428c87e1a5bb61" translate="yes" xml:space="preserve">
          <source>Deletes all slots from a node.</source>
          <target state="translated">ノードからすべてのスロットを削除します。</target>
        </trans-unit>
        <trans-unit id="80a85a3d0c778d43ae904d63695fe309c4c3c24d" translate="yes" xml:space="preserve">
          <source>Deployment is hard if we have to make sure all instances contain a given command, especially in a distributed environment.</source>
          <target state="translated">特に分散環境では、すべてのインスタンスに与えられたコマンドが含まれていることを確認しなければならない場合、デプロイは困難です。</target>
        </trans-unit>
        <trans-unit id="5ff30b622ac74ad50b3a17678781b111c2a76d5c" translate="yes" xml:space="preserve">
          <source>Design pattern</source>
          <target state="translated">デザインパターン</target>
        </trans-unit>
        <trans-unit id="21a2deb58a8a8547be11baa26a8458026dc5e0be" translate="yes" xml:space="preserve">
          <source>Design pattern: Locking with &lt;code&gt;SETNX&lt;/code&gt;</source>
          <target state="translated">設計パターン： &lt;code&gt;SETNX&lt;/code&gt; を使用したロック</target>
        </trans-unit>
        <trans-unit id="fa7fb27a452f3b56f97bc25556a2c1c23541060b" translate="yes" xml:space="preserve">
          <source>Destroy a consumer group.</source>
          <target state="translated">消費者団体を破壊する。</target>
        </trans-unit>
        <trans-unit id="2a999a830e915e0d76daa09bf5db1dee24489f35" translate="yes" xml:space="preserve">
          <source>Details on strings comparison</source>
          <target state="translated">弦の比較の詳細</target>
        </trans-unit>
        <trans-unit id="b5cf1dd7b9908b60a915b47bdf1a512163a4abd6" translate="yes" xml:space="preserve">
          <source>Details on why the ban-list is needed</source>
          <target state="translated">禁止リストが必要な理由の詳細</target>
        </trans-unit>
        <trans-unit id="e861bf6485a8747057af520bff1e2bd98ca908ee" translate="yes" xml:space="preserve">
          <source>Detect timed out replicas.</source>
          <target state="translated">タイムアウトしたレプリカを検出します。</target>
        </trans-unit>
        <trans-unit id="c1a87c7e48f6afb9828d520eaa5085ecfdb87723" translate="yes" xml:space="preserve">
          <source>Differences between XREAD and XREADGROUP</source>
          <target state="translated">XREADとXREADGROUPの違い</target>
        </trans-unit>
        <trans-unit id="954c7e91bbe922ce8d0679c169669338d8457c3c" translate="yes" xml:space="preserve">
          <source>Differences in Redis prior 2.1.3</source>
          <target state="translated">Redis先行2.1.3の違い</target>
        </trans-unit>
        <trans-unit id="d60417fd68044b5a922b2a39105c16f898e592ce" translate="yes" xml:space="preserve">
          <source>Different instances may have different implementations of a command.</source>
          <target state="translated">異なるインスタンスでは、コマンドの実装が異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="0e666a0e590c18bbb2775c33bdd4b4b2755c4fd8" translate="yes" xml:space="preserve">
          <source>Different return values are used for different subcommands.</source>
          <target state="translated">サブコマンドごとに異なる戻り値が使用されます。</target>
        </trans-unit>
        <trans-unit id="8519d2a89e19a4522b7059222e7d87dd5565a1b3" translate="yes" xml:space="preserve">
          <source>Disables read queries for a connection to a Redis Cluster slave node.</source>
          <target state="translated">Redis Cluster スレーブノードへの接続の読み取りクエリを無効にします。</target>
        </trans-unit>
        <trans-unit id="3c9664e573a114e8272bfbfb19ccbd51925d8d78" translate="yes" xml:space="preserve">
          <source>Distribution of returned elements</source>
          <target state="translated">返された要素の分布</target>
        </trans-unit>
        <trans-unit id="7ccde4db71eed2460dfb04d6817e8c9f76a501f5" translate="yes" xml:space="preserve">
          <source>Due to the single-threaded nature of Redis, it is not possible to kill a client connection while it is executing a command. From the client point of view, the connection can never be closed in the middle of the execution of a command. However, the client will notice the connection has been closed only when the next command is sent (and results in network error).</source>
          <target state="translated">Redis のシングルスレッドの性質上、コマンド実行中にクライアントの接続を終了させることはできません。クライアントから見れば、コマンドの実行中に接続を閉じることはできません。しかし、クライアントは次のコマンドが送信されたときにのみ、接続が閉じられたことに気づくでしょう (その結果、ネットワークエラーが発生します)。</target>
        </trans-unit>
        <trans-unit id="6781cfc8284296eb70ba05270579b9deac096a80" translate="yes" xml:space="preserve">
          <source>ECHO</source>
          <target state="translated">ECHO</target>
        </trans-unit>
        <trans-unit id="e7ec2091f33799c975a8d7a6ea9bc9b6bc50c88f" translate="yes" xml:space="preserve">
          <source>ECHO  message   Echo the given string</source>
          <target state="translated">ECHO メッセージ 与えられた文字列をエコーします。</target>
        </trans-unit>
        <trans-unit id="225a586b70502eff079ebfff31adfbc6e0bf2d35" translate="yes" xml:space="preserve">
          <source>EVAL</source>
          <target state="translated">EVAL</target>
        </trans-unit>
        <trans-unit id="ea1523936796cac657906bcb4392d72c0f622a53" translate="yes" xml:space="preserve">
          <source>EVAL  script numkeys key [key ...] arg [arg ...]   Execute a Lua script server side</source>
          <target state="translated">EVAL script numkeys key [key ...]arg [arg ...]Lua スクリプトをサーバー側で実行します。</target>
        </trans-unit>
        <trans-unit id="8b8522c1abed78aca4ba0ae5b2f9d4375bf6841d" translate="yes" xml:space="preserve">
          <source>EVALSHA</source>
          <target state="translated">EVALSHA</target>
        </trans-unit>
        <trans-unit id="9ca231b5b5f90e450c680cb2bea30ab1800479a3" translate="yes" xml:space="preserve">
          <source>EVALSHA  sha1 numkeys key [key ...] arg [arg ...]   Execute a Lua script server side</source>
          <target state="translated">EVALSHA sha1 numkeys key [key ...]arg [arg ...]Lua スクリプトをサーバーサイドで実行します。</target>
        </trans-unit>
        <trans-unit id="e29c908995e16002c05ec47ec36aaf34a1bd4b78" translate="yes" xml:space="preserve">
          <source>EVALSHA in the context of pipelining</source>
          <target state="translated">パイプラインの文脈でのEVALSHA</target>
        </trans-unit>
        <trans-unit id="ea837e81db8c2bd7fcea29a56cd54086382f1f43" translate="yes" xml:space="preserve">
          <source>EXEC</source>
          <target state="translated">EXEC</target>
        </trans-unit>
        <trans-unit id="2b1156bdd8031e124d3a9ae093559b5a4386e538" translate="yes" xml:space="preserve">
          <source>EXEC   Execute all commands issued after MULTI</source>
          <target state="translated">EXEC MULTI の後に発行された全てのコマンドを実行します。</target>
        </trans-unit>
        <trans-unit id="644b5806e118fe0af3936c64572a1496ddda7507" translate="yes" xml:space="preserve">
          <source>EXISTS</source>
          <target state="translated">EXISTS</target>
        </trans-unit>
        <trans-unit id="08807aa77041e8b29bbcefa207328a0789129027" translate="yes" xml:space="preserve">
          <source>EXISTS  key [key ...]   Determine if a key exists</source>
          <target state="translated">EXISTS key [key ...]キーが存在するかどうかを判定します。</target>
        </trans-unit>
        <trans-unit id="1215753c2320bb44b6a871baac293e5bf276e781" translate="yes" xml:space="preserve">
          <source>EXPIRE</source>
          <target state="translated">EXPIRE</target>
        </trans-unit>
        <trans-unit id="436d86e478f5d801c08f118762eb43ed84923c39" translate="yes" xml:space="preserve">
          <source>EXPIRE  key seconds   Set a key's time to live in seconds</source>
          <target state="translated">EXPIRE key seconds キーの有効期限を秒単位で設定します。</target>
        </trans-unit>
        <trans-unit id="ce90cafacba153e381a002cc83387fcbd4d6f68f" translate="yes" xml:space="preserve">
          <source>EXPIREAT</source>
          <target state="translated">EXPIREAT</target>
        </trans-unit>
        <trans-unit id="34c23f46d63812eec7d4e21acb84ed6214c2b5cc" translate="yes" xml:space="preserve">
          <source>EXPIREAT  key timestamp   Set the expiration for a key as a UNIX timestamp</source>
          <target state="translated">EXPIREAT key timestamp 鍵の有効期限をUNIXのタイムスタンプとして設定します。</target>
        </trans-unit>
        <trans-unit id="1f423012c27396dae7aa028cc182a29eea955b66" translate="yes" xml:space="preserve">
          <source>Each failure report has a time to live of two times the &lt;em&gt;node timeout&lt;/em&gt; time.</source>
          <target state="translated">各障害レポートの&lt;em&gt;存続&lt;/em&gt;時間は、&lt;em&gt;ノードのタイムアウト&lt;/em&gt;時間の2倍です。</target>
        </trans-unit>
        <trans-unit id="e89059e939f6644b3364536eb50a1abdc89a1613" translate="yes" xml:space="preserve">
          <source>Each line is composed of a succession of &lt;code&gt;property=value&lt;/code&gt; fields separated by a space character.</source>
          <target state="translated">各行は、空白文字で区切られた一連の &lt;code&gt;property=value&lt;/code&gt; フィールドで構成されています。</target>
        </trans-unit>
        <trans-unit id="4918aff92ee02999f29bacd99ab30d0a000253c7" translate="yes" xml:space="preserve">
          <source>Each line is composed of the following fields:</source>
          <target state="translated">各行は以下のフィールドで構成されています。</target>
        </trans-unit>
        <trans-unit id="853014cc58f5042914b68be7e44d86291316a8d3" translate="yes" xml:space="preserve">
          <source>Each nested result is:</source>
          <target state="translated">各ネストされた結果は</target>
        </trans-unit>
        <trans-unit id="001afdca6677847da08247ab1ec58a7506cae0eb" translate="yes" xml:space="preserve">
          <source>Each node in a Redis Cluster has its view of the current cluster configuration, given by the set of known nodes, the state of the connection we have with such nodes, their flags, properties and assigned slots, and so forth.</source>
          <target state="translated">Redisクラスタ内の各ノードは、既知のノードのセット、そのようなノードとの接続の状態、そのフラグ、プロパティ、割り当てられたスロットなどによって与えられる、現在のクラスタ構成のビューを持っています。</target>
        </trans-unit>
        <trans-unit id="ebe29cd1a064ec2dc6312d2e8c8e3c40f46f1f35" translate="yes" xml:space="preserve">
          <source>Each reported event has the following fields:</source>
          <target state="translated">報告された各イベントには、以下のフィールドがあります。</target>
        </trans-unit>
        <trans-unit id="4031491a0a21d3efcb1ae0e642e160153ab9452c" translate="yes" xml:space="preserve">
          <source>Each result includes all active replicas of the master instance for the listed slot range. Failed replicas are not returned.</source>
          <target state="translated">各結果には、リストされたスロット範囲のマスターインスタンスのすべてのアクティブなレプリカが含まれます。失敗したレプリカは返されません。</target>
        </trans-unit>
        <trans-unit id="39a5a1ac33abf7ccbf42de1a62abad74d800f2a8" translate="yes" xml:space="preserve">
          <source>Each subcommand is documented below. At the end you'll find a description of how live resharding is performed using this command and other related commands.</source>
          <target state="translated">各サブコマンドについては以下に説明します。最後に、このコマンドとその他の関連コマンドを使ってライブリシャーディングがどのように行われるかの説明があります。</target>
        </trans-unit>
        <trans-unit id="2d0820e2ed028ade2f8d73ff5b41f73cd289b4e1" translate="yes" xml:space="preserve">
          <source>Each top-level result contains six nested results. Each nested result is:</source>
          <target state="translated">各トップレベルの結果には、6 つの入れ子になった結果が含まれます。各入れ子になった結果は</target>
        </trans-unit>
        <trans-unit id="b5f7d21b9ba2cb092f0980b7560e9cd91a246461" translate="yes" xml:space="preserve">
          <source>Effects on the node:</source>
          <target state="translated">ノードへの影響。</target>
        </trans-unit>
        <trans-unit id="1940e8677e72b823aadf3f1babad911e272f4f7b" translate="yes" xml:space="preserve">
          <source>Elements that were not constantly present in the collection during a full iteration, may be returned or not: it is undefined.</source>
          <target state="translated">フルイテレーション中にコレクション内に常に存在していなかった要素が返されるかどうかは、定義されていません。</target>
        </trans-unit>
        <trans-unit id="fa43f0d9868a88416f82c35ed64e1745c1e56215" translate="yes" xml:space="preserve">
          <source>Elements with the same score</source>
          <target state="translated">同じスコアを持つ要素</target>
        </trans-unit>
        <trans-unit id="127cfef1e8e010cbd37725ea8863aa38e5d50815" translate="yes" xml:space="preserve">
          <source>Emitting Redis logs from scripts</source>
          <target state="translated">スクリプトからRedisのログを出力する</target>
        </trans-unit>
        <trans-unit id="1f733b322f80ecf7300735b8315383e95cf78665" translate="yes" xml:space="preserve">
          <source>Enables read queries for a connection to a Redis Cluster replica node.</source>
          <target state="translated">Redis Clusterレプリカノードへの接続の読み取りクエリを有効にします。</target>
        </trans-unit>
        <trans-unit id="6fb65c66a66392a71ca206846f2ac13ca3b45368" translate="yes" xml:space="preserve">
          <source>End slot range</source>
          <target state="translated">エンドスロット範囲</target>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">エラー処理</target>
        </trans-unit>
        <trans-unit id="6ad4930b258ad43ab07d5ba00c43530ba3b62093" translate="yes" xml:space="preserve">
          <source>Evaluates a script cached on the server side by its SHA1 digest. Scripts are cached on the server side using the &lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt; command. The command is otherwise identical to &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;.</source>
          <target state="translated">SHA1ダイジェストによってサーバー側にキャッシュされたスクリプトを評価します。スクリプトは、&lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt;コマンドを使用してサーバー側にキャッシュされます。その他の点では、コマンドは&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;と同じです。</target>
        </trans-unit>
        <trans-unit id="3784064b237e9150f97da5ef4677aaab4b0c6d07" translate="yes" xml:space="preserve">
          <source>Even if other clients are actively pushing new items at the end of the list.</source>
          <target state="translated">他のクライアントがリストの最後に新しい項目を積極的にプッシュしていたとしても。</target>
        </trans-unit>
        <trans-unit id="7dd20b200cf466b9bb17c87ac888deb51e1a343f" translate="yes" xml:space="preserve">
          <source>Even running instances will always check the computer clock, so for instance if you set a key with a time to live of 1000 seconds, and then set your computer time 2000 seconds in the future, the key will be expired immediately, instead of lasting for 1000 seconds.</source>
          <target state="translated">実行中のインスタンスであっても、常にコンピュータの時計をチェックしているので、例えば、1000秒生きる時間を設定したキーを設定した後、将来コンピュータの時間を2000秒に設定した場合、キーは1000秒持続するのではなく、すぐに期限切れになります。</target>
        </trans-unit>
        <trans-unit id="d27fcdec12658758c11ddcfe5132a9543098333e" translate="yes" xml:space="preserve">
          <source>Event name.</source>
          <target state="translated">イベント名。</target>
        </trans-unit>
        <trans-unit id="9ad3a7a35d62cd7230213de79ba4b1043488e12a" translate="yes" xml:space="preserve">
          <source>Eventually if all the entries in a macro-node are marked as deleted, the whole node is destroyed and the memory reclaimed. This means that if you delete a large amount of entries from a stream, for instance more than 50% of the entries appended to the stream, the memory usage per entry may increment, since what happens is that the stream will start to be fragmented. However the stream performances will remain the same.</source>
          <target state="translated">最終的に、マクロノード内のすべてのエントリが削除されたとマークされた場合、ノード全体が破壊され、メモリが再利用されます。これは、ストリームから大量のエントリを削除した場合、例えばストリームに追加されたエントリの50%以上を削除した場合、ストリームが断片化され始めるため、エントリあたりのメモリ使用量が増加する可能性があることを意味します。しかし、ストリームの性能は変わりません。</target>
        </trans-unit>
        <trans-unit id="792161cf042fd5babb68da92f1bbb2902dc3526e" translate="yes" xml:space="preserve">
          <source>Every Redis instance is &lt;em&gt;guaranteed&lt;/em&gt; to have all the above libraries so you can be sure that the environment for your Redis scripts is always the same.</source>
          <target state="translated">すべてのRedisインスタンスには上記のすべてのライブラリが含ま&lt;em&gt;れ&lt;/em&gt;ていることが&lt;em&gt;保証さ&lt;/em&gt;れているため、Redisスクリプトの環境は常に同じです。</target>
        </trans-unit>
        <trans-unit id="ff1000733402cd15305f0a4763cbc390865561a4" translate="yes" xml:space="preserve">
          <source>Every entry is composed of four (or six starting with Redis 4.0) fields:</source>
          <target state="translated">すべてのエントリは、4つ(Redis 4.0からは6つ)のフィールドで構成されています。</target>
        </trans-unit>
        <trans-unit id="c3f1325124fc7f8408e9843db0ab98baea3e119b" translate="yes" xml:space="preserve">
          <source>Every new connection starts without an assigned name.</source>
          <target state="translated">すべての新しい接続は、割り当てられた名前なしで開始されます。</target>
        </trans-unit>
        <trans-unit id="51df853590a285fd9b12bc8e0d4650ccb232f700" translate="yes" xml:space="preserve">
          <source>Every time a node processes gossip packets from other nodes, it creates (and refreshes the TTL if needed) &lt;strong&gt;failure reports&lt;/strong&gt;, remembering that a given node said another given node is in &lt;code&gt;PFAIL&lt;/code&gt; condition.</source>
          <target state="translated">ノードは他のノードからのゴシップパケットを処理するたびに、&lt;strong&gt;障害レポートを&lt;/strong&gt;作成（および必要に応じてTTLを更新）し、特定のノードが別の特定のノードが &lt;code&gt;PFAIL&lt;/code&gt; 状態にあることを思い出します。</target>
        </trans-unit>
        <trans-unit id="c8f9b9897ccaf6988795d0fa2e49d6b67f29b456" translate="yes" xml:space="preserve">
          <source>Every time a user performs a page view, the application can register that in the current day the user visited the web site using the &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt; command setting the bit corresponding to the current day.</source>
          <target state="translated">ユーザーがページビューを実行するたびに、アプリケーションは、当日に対応するビットを設定する&lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt;コマンドを使用して、当日ユーザーがWebサイトを訪問したことを登録できます。</target>
        </trans-unit>
        <trans-unit id="434360186a18d9c330717a5f17d631c11575acb2" translate="yes" xml:space="preserve">
          <source>Every time this script executed the resulting list will have exactly the following elements:</source>
          <target state="translated">このスクリプトが実行されるたびに、結果として得られるリストは正確に以下の要素を持つようになります。</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="815030c996b00efbe374a3c45d7121d3e9fc4929" translate="yes" xml:space="preserve">
          <source>Example of zero padding:</source>
          <target state="translated">パディングをゼロにした例。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="c687d1b70c080536289366ba8155bc643fc72076" translate="yes" xml:space="preserve">
          <source>Exclusive intervals and infinity</source>
          <target state="translated">排他的な間隔と無限大</target>
        </trans-unit>
        <trans-unit id="114f30848cb8a83d62c97a5a6476b435a78150bd" translate="yes" xml:space="preserve">
          <source>Exclusive ranges</source>
          <target state="translated">専用レンジ</target>
        </trans-unit>
        <trans-unit id="55912897a10d768ac59806e69e2501c331778457" translate="yes" xml:space="preserve">
          <source>Exclusive ranges and iterating the PEL</source>
          <target state="translated">排他的範囲とPELの反復処理</target>
        </trans-unit>
        <trans-unit id="8e788d736a6e3a42271b3b6edc6a324f07e11667" translate="yes" xml:space="preserve">
          <source>Executed scripts are guaranteed to be in the script cache of a given execution of a Redis instance forever. This means that if an &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; is performed against a Redis instance all the subsequent &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; calls will succeed.</source>
          <target state="translated">実行されたスクリプトは、Redisインスタンスの特定の実行のスクリプトキャッシュに永久に存在することが保証されています。つまり、Redisインスタンスに対して&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;が実行されると、後続のすべての&lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt;呼び出しが成功します。</target>
        </trans-unit>
        <trans-unit id="446763d77e17832a47ad829663f2f4ba29ce76f7" translate="yes" xml:space="preserve">
          <source>Executes all previously queued commands in a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt; and restores the connection state to normal.</source>
          <target state="translated">以前にキューに入れられたすべてのコマンドを&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;トランザクション&lt;/a&gt;で実行し、接続状態を通常に戻します。</target>
        </trans-unit>
        <trans-unit id="d80b1a46f6734fb75c0119610c9901aef0c08607" translate="yes" xml:space="preserve">
          <source>Executing a Lua Script with Redis 2.6 or newer.</source>
          <target state="translated">Redis 2.6以降でLuaスクリプトを実行します。</target>
        </trans-unit>
        <trans-unit id="e1a9d983dc0912bcd36f098a1b8c4b6851a2ccbc" translate="yes" xml:space="preserve">
          <source>Expire accuracy</source>
          <target state="translated">期限切れ精度</target>
        </trans-unit>
        <trans-unit id="5bbbfc0dcb3f1ea6203152c364bf711f30071354" translate="yes" xml:space="preserve">
          <source>Expires and persistence</source>
          <target state="translated">期限切れと執着</target>
        </trans-unit>
        <trans-unit id="a4432b0943d588c17ab5d7e63d136bb9786a862c" translate="yes" xml:space="preserve">
          <source>Extended form of XPENDING</source>
          <target state="translated">XPENDINGの拡張形</target>
        </trans-unit>
        <trans-unit id="ceae3e065a822da58b9dd577a4a2215264628a2c" translate="yes" xml:space="preserve">
          <source>FLUSHALL</source>
          <target state="translated">FLUSHALL</target>
        </trans-unit>
        <trans-unit id="a1dc7fedbb3161c8d2db024cd3ee46e2af26f812" translate="yes" xml:space="preserve">
          <source>FLUSHALL  [ASYNC]   Remove all keys from all databases</source>
          <target state="translated">FLUSHALL [ASYNC]すべてのデータベースからすべてのキーを削除します。</target>
        </trans-unit>
        <trans-unit id="10bb3c2c2d36018ba538d533264f2171634a8d95" translate="yes" xml:space="preserve">
          <source>FLUSHDB</source>
          <target state="translated">FLUSHDB</target>
        </trans-unit>
        <trans-unit id="b40b961b1c26ac58fbd9ac2f12f0c446fb2897d9" translate="yes" xml:space="preserve">
          <source>FLUSHDB  [ASYNC]   Remove all keys from the current database</source>
          <target state="translated">FLUSHDB [ASYNC]現在のデータベースからすべてのキーを削除します。</target>
        </trans-unit>
        <trans-unit id="a5f0b2c20a29e7587597abea3e79fa609ca01e4c" translate="yes" xml:space="preserve">
          <source>FORCE option: manual failover when the master is down</source>
          <target state="translated">FORCEオプション:マスターがダウンしているときに手動でフェイルオーバーを行う</target>
        </trans-unit>
        <trans-unit id="f9c28b26fa472599864dea91ca5f8cd92a5475d7" translate="yes" xml:space="preserve">
          <source>Failures to authenticate their connections with &lt;a href=&quot;auth&quot;&gt;AUTH&lt;/a&gt; or &lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;auth&quot;&gt;AUTH&lt;/a&gt;または&lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt;との接続の認証に失敗しました。</target>
        </trans-unit>
        <trans-unit id="4a0878bdd16e36ba72b474afe51ae9c582fef6d5" translate="yes" xml:space="preserve">
          <source>Fetching a single entry from a stream, providing the ID of the entry to fetch two times: as start and end of the query interval.</source>
          <target state="translated">ストリームから単一のエントリを取得します。取得するエントリのIDを、クエリ間隔の開始と終了の2回に分けて指定します。</target>
        </trans-unit>
        <trans-unit id="d11485369737f36370f75a3ff43b46d72effc624" translate="yes" xml:space="preserve">
          <source>Fetching data from a stream via a consumer group, and not acknowledging such data, has the effect of creating &lt;em&gt;pending entries&lt;/em&gt;. This is well explained in the &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; command, and even better in our &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introduction to Redis Streams&lt;/a&gt;. The &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; command will immediately remove the pending entry from the Pending Entry List (PEL) since once a message is successfully processed, there is no longer need for the consumer group to track it and to remember the current owner of the message.</source>
          <target state="translated">コンシューマグループを介してストリームからデータをフェッチし、そのようなデータを確認しないと、&lt;em&gt;保留中のエントリ&lt;/em&gt;が作成さ&lt;em&gt;れます&lt;/em&gt;。これは&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;コマンドで十分に説明されており、&lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;Redis Streamsの紹介で&lt;/a&gt;さらに詳しく説明されています。&lt;a href=&quot;xack&quot;&gt;XACKの&lt;/a&gt;メッセージが正常に処理されると、それを追跡すると、メッセージの現在の所有者を覚えておくことが、消費者のグループのために、もはや必要がないため、コマンドはすぐに保留エントリーリスト（PEL）から保留中のエントリを削除します。</target>
        </trans-unit>
        <trans-unit id="13b9c9d38a4b96f103ca63910ffc56743e00fd12" translate="yes" xml:space="preserve">
          <source>Fetching single items</source>
          <target state="translated">単一アイテムの取得</target>
        </trans-unit>
        <trans-unit id="894f8f81f5445488b186c9a058eccf6bacfbb0db" translate="yes" xml:space="preserve">
          <source>Finally it is possible to get help from the command, in case the user can't remember the exact syntax, by using the &lt;code&gt;HELP&lt;/code&gt; subcommand:</source>
          <target state="translated">最後に、ユーザーが正確な構文を思い出せない場合に備えて、 &lt;code&gt;HELP&lt;/code&gt; サブコマンドを使用して、コマンドからヘルプを取得することができます。</target>
        </trans-unit>
        <trans-unit id="8330be22b4e169fe5141dfbcacb82dc81724e13f" translate="yes" xml:space="preserve">
          <source>Finally it is possible to get help from the command, in case the user can't remember the exact syntax, by using the &lt;code&gt;HELP&lt;/code&gt; subcommnad:</source>
          <target state="translated">最後に、 &lt;code&gt;HELP&lt;/code&gt; サブコマンドを使用して、ユーザーが正確な構文を思い出せない場合に、コマンドからヘルプを取得することができます。</target>
        </trans-unit>
        <trans-unit id="5388f4a7abea666722d4311743c9d3e1d5bfc3b1" translate="yes" xml:space="preserve">
          <source>Finally it is possible to get the list of every consumer in a specific consumer group:</source>
          <target state="translated">最後に、特定の消費者グループのすべての消費者のリストを取得することができます。</target>
        </trans-unit>
        <trans-unit id="7cbe1b741345fc3839fb4d58149e9dd7af6c272a" translate="yes" xml:space="preserve">
          <source>Finally it is possible to pass an additional argument to the command, in order to see the messages having a specific owner:</source>
          <target state="translated">最後に、特定の所有者を持つメッセージを見るために、コマンドに追加の引数を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="58b2c6378bac42febc100a9e0341d2094c29e52e" translate="yes" xml:space="preserve">
          <source>Finally it possible to set the next message to deliver using the &lt;code&gt;SETID&lt;/code&gt; subcommand. Normally the next ID is set when the consumer is created, as the last argument of &lt;code&gt;XGROUP CREATE&lt;/code&gt;. However using this form the next ID can be modified later without deleting and creating the consumer group again. For instance if you want the consumers in a consumer group to re-process all the messages in a stream, you may want to set its next ID to 0:</source>
          <target state="translated">最後に、 &lt;code&gt;SETID&lt;/code&gt; サブコマンドを使用して、配信する次のメッセージを設定することができます。通常、次のIDは、コンシューマーの作成時に &lt;code&gt;XGROUP CREATE&lt;/code&gt; の最後の引数として設定されます。ただし、このフォームを使用すると、コンシューマーグループを削除して再度作成しなくても、後で次のIDを変更できます。たとえば、コンシューマグループのコンシューマにストリーム内のすべてのメッセージを再処理させたい場合は、次のIDを0に設定できます。</target>
        </trans-unit>
        <trans-unit id="53e0098dbba7db3bdb2ae206e024574f2dd74ced" translate="yes" xml:space="preserve">
          <source>Finally to also have the match len:</source>
          <target state="translated">最後に、またマッチレンを持っています。</target>
        </trans-unit>
        <trans-unit id="8081b937f79256e42e7fd856b20cf39a90419c3e" translate="yes" xml:space="preserve">
          <source>Finally to get some help if you don't remember the syntax, use the HELP subcommand:</source>
          <target state="translated">最後に、構文を覚えていない場合にヘルプを得るには、HELPサブコマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="4827d8054bd5c8af82f3e09e291390e27412f49f" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;code&gt;MAXLEN&lt;/code&gt; option tells the command to compare the provided element only with a given maximum number of list items. So for instance specifying &lt;code&gt;MAXLEN 1000&lt;/code&gt; will make sure that the command performs only 1000 comparisons, effectively running the algorithm on a subset of the list (the first part or the last part depending on the fact we use a positive or negative rank). This is useful to limit the maximum complexity of the command. It is also useful when we expect the match to be found very early, but want to be sure that in case this is not true, the command does not take too much time to run.</source>
          <target state="translated">最後に、 &lt;code&gt;MAXLEN&lt;/code&gt; オプションは、指定された要素のみを指定された最大数のリスト項目と比較するようにコマンドに指示します。したがって、たとえば &lt;code&gt;MAXLEN 1000&lt;/code&gt; を指定すると、コマンドが1000回の比較のみを実行し、リストのサブセット（正または負のランクを使用するという事実に応じて、最初の部分または最後の部分）でアルゴリズムを効果的に実行します。これは、コマンドの最大の複雑さを制限するのに役立ちます。一致が非常に早く見つかると予想される場合にも役立ちますが、これが当てはまらない場合は、コマンドの実行にそれほど時間がかからないようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="fc63c9b0ba92886f08fc9cdd2dca430983266b7e" translate="yes" xml:space="preserve">
          <source>First Key in Argument List</source>
          <target state="translated">引数リストの最初のキー</target>
        </trans-unit>
        <trans-unit id="a8e315abf463cfb1c344b54fca5c387403cc9c5a" translate="yes" xml:space="preserve">
          <source>First replica of master for slot range</source>
          <target state="translated">スロットレンジ用マスターの初レプリカ</target>
        </trans-unit>
        <trans-unit id="5d728758adcdd5154d3be55552c1c061ef1489b2" translate="yes" xml:space="preserve">
          <source>Flags</source>
          <target state="translated">Flags</target>
        </trans-unit>
        <trans-unit id="4e0b6894626b05a7f879581f17814069cc8b9e6d" translate="yes" xml:space="preserve">
          <source>Flush the Append Only File if AOF is enabled.</source>
          <target state="translated">AOFが有効な場合は、Append Only Fileをフラッシュします。</target>
        </trans-unit>
        <trans-unit id="3b424754326ab3315277697bc94804652181fadd" translate="yes" xml:space="preserve">
          <source>Flush the Lua scripts cache.</source>
          <target state="translated">Lua スクリプトのキャッシュをフラッシュします。</target>
        </trans-unit>
        <trans-unit id="f6bb844e2e06d69091cb567be5df64888a2d1098" translate="yes" xml:space="preserve">
          <source>Flushes all previously queued commands in a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt; and restores the connection state to normal.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;トランザクション&lt;/a&gt;で以前にキューに入れられたすべてのコマンドをフラッシュし、接続状態を通常に戻します。</target>
        </trans-unit>
        <trans-unit id="8c64c01f5213c6c086d3f83c900e781d98a8b4d5" translate="yes" xml:space="preserve">
          <source>Flushes all the previously watched keys for a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;トランザクションの&lt;/a&gt;以前に監視されたすべてのキーをフラッシュします。</target>
        </trans-unit>
        <trans-unit id="e859a22c051906372e6ed21806faadd4fdf27b1c" translate="yes" xml:space="preserve">
          <source>For Redis 2.6 what happens is that the command performing multiple pushes is executed, and &lt;em&gt;only after&lt;/em&gt; the execution of the command the blocked clients are served. Consider this sequence of commands.</source>
          <target state="translated">Redis 2.6では、複数のプッシュを実行するコマンドが実行され、コマンドの実行&lt;em&gt;後&lt;/em&gt;に&lt;em&gt;のみ&lt;/em&gt;、ブロックされたクライアントにサービスが提供されます。この一連のコマンドを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="c9543ba9d8e4550fc68513216cde163b99c314dc" translate="yes" xml:space="preserve">
          <source>For a description of the &lt;code&gt;WEIGHTS&lt;/code&gt; and &lt;code&gt;AGGREGATE&lt;/code&gt; options, see &lt;a href=&quot;zunionstore&quot;&gt;ZUNIONSTORE&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;WEIGHTS&lt;/code&gt; および &lt;code&gt;AGGREGATE&lt;/code&gt; オプションの説明については、&lt;a href=&quot;zunionstore&quot;&gt;ZUNIONSTOREを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="9618151d729f751e6074523159514ecdfdb57ef1" translate="yes" xml:space="preserve">
          <source>For an introduction to HyperLogLog data structure check the &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; command page.</source>
          <target state="translated">HyperLogLogデータ構造の概要については、&lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt;コマンドページを確認してください。</target>
        </trans-unit>
        <trans-unit id="6fcc6360d01cc6597619a76bd12e34dfa8c068d5" translate="yes" xml:space="preserve">
          <source>For an introduction to sorted sets, see the data types page on &lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;sorted sets&lt;/a&gt;.</source>
          <target state="translated">ソートされたセットの概要については、上のデータ・タイプ・ページを参照してください&lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;ソートされたセット&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9e36005d4ed916277f75df55af354619d0ef5d5b" translate="yes" xml:space="preserve">
          <source>For each command type, the following line is added:</source>
          <target state="translated">コマンドの種類ごとに、以下の行を追加します。</target>
        </trans-unit>
        <trans-unit id="e6d8b4b7b9b4f1b118134e1b85eed9b0b1555262" translate="yes" xml:space="preserve">
          <source>For each consumer group listed the command also shows the number of consumers known in that group and the pending messages (delivered but not yet acknowledged) in that group.</source>
          <target state="translated">リストされた各コンシューマ・グループに対して、コマンドはそのグループ内の既知のコンシューマの数と、そのグループ内の保留中のメッセージ(配信されたがまだ確認されていない)も表示します。</target>
        </trans-unit>
        <trans-unit id="2f01796f139a1dd83db65e8858f0ea9b62d77fdf" translate="yes" xml:space="preserve">
          <source>For each database, the following line is added:</source>
          <target state="translated">各データベースに対して、以下の行を追加します。</target>
        </trans-unit>
        <trans-unit id="0553e67e4dc3e5df5405dbaf017a41c48cd92358" translate="yes" xml:space="preserve">
          <source>For each replica, the following line is added:</source>
          <target state="translated">各レプリカについて、以下の行を追加します。</target>
        </trans-unit>
        <trans-unit id="4121db15148ef3ce1e89f4557d512e7c05a4cd89" translate="yes" xml:space="preserve">
          <source>For every &lt;code&gt;field&lt;/code&gt; that does not exist in the hash, a &lt;code&gt;nil&lt;/code&gt; value is returned. Because non-existing keys are treated as empty hashes, running &lt;a href=&quot;hmget&quot;&gt;HMGET&lt;/a&gt; against a non-existing &lt;code&gt;key&lt;/code&gt; will return a list of &lt;code&gt;nil&lt;/code&gt; values.</source>
          <target state="translated">ハッシュに存在しないすべての &lt;code&gt;field&lt;/code&gt; について、 &lt;code&gt;nil&lt;/code&gt; 値が返されます。非既存のキーが動作して、空のハッシュとして扱われるので&lt;a href=&quot;hmget&quot;&gt;HMGETを&lt;/a&gt;非既存のに対して &lt;code&gt;key&lt;/code&gt; のリストを返します &lt;code&gt;nil&lt;/code&gt; の値を。</target>
        </trans-unit>
        <trans-unit id="ebdc0b5372eb98dde6f0761af59221e15f0a9f9e" translate="yes" xml:space="preserve">
          <source>For every &lt;code&gt;member&lt;/code&gt; that does not exist in the sorted set, a &lt;code&gt;nil&lt;/code&gt; value is returned.</source>
          <target state="translated">ソートされたセットに存在しないすべての &lt;code&gt;member&lt;/code&gt; について、 &lt;code&gt;nil&lt;/code&gt; 値が返されます。</target>
        </trans-unit>
        <trans-unit id="4313528e119e8db789aa6be23b8a03a247c203b4" translate="yes" xml:space="preserve">
          <source>For every &lt;code&gt;member&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; is returned if the value is a member of the set, or &lt;code&gt;0&lt;/code&gt; if the element is not a member of the set or if &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">すべてのための &lt;code&gt;member&lt;/code&gt; 、 &lt;code&gt;1&lt;/code&gt; は値がセットのメンバー、またはある場合に返される &lt;code&gt;0&lt;/code&gt; 要素がセットのメンバーでない場合、または場合は &lt;code&gt;key&lt;/code&gt; 存在しません。</target>
        </trans-unit>
        <trans-unit id="b69fc5b2026538496f23b6b8fb03889d7e1936d3" translate="yes" xml:space="preserve">
          <source>For eviction purposes, you may use the &lt;code&gt;IDLETIME&lt;/code&gt; or &lt;code&gt;FREQ&lt;/code&gt; modifiers. See &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; for more information (Redis 5.0 or greater).</source>
          <target state="translated">エビクションの目的で、 &lt;code&gt;IDLETIME&lt;/code&gt; または &lt;code&gt;FREQ&lt;/code&gt; 修飾子を使用できます。詳細については、&lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt;を参照してください（Redis 5.0以降）。</target>
        </trans-unit>
        <trans-unit id="910c18521d782016253b4584c3c1718149e1c25d" translate="yes" xml:space="preserve">
          <source>For example a common problem when implementing Markov chains and other algorithms is to select an element at random from a set, but different elements may have different weights that change how likely it is they are picked.</source>
          <target state="translated">例えば、マルコフ連鎖や他のアルゴリズムを実装する際によくある問題は、集合からランダムに要素を選択することですが、要素ごとに異なる重みがあり、それによって選択される可能性が変化します。</target>
        </trans-unit>
        <trans-unit id="00e8032c1c0863c866e402146d15139ddaca7eea" translate="yes" xml:space="preserve">
          <source>For example in order to take the count of all the unique search queries performed in a day, a program needs to call &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; every time a query is processed. The estimated number of unique queries can be retrieved with &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; at any time.</source>
          <target state="translated">たとえば、1日に実行されたすべての一意の検索クエリの数を取得するには、クエリが処理されるたびにプログラムが&lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt;を呼び出す必要があります。一意のクエリの推定数は、&lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt;を使用していつでも取得できます。</target>
        </trans-unit>
        <trans-unit id="862ca7fa622c308433f665edc841f44e39e5d232" translate="yes" xml:space="preserve">
          <source>For example the following command assigns slots 1 2 3 to the node receiving the command:</source>
          <target state="translated">例えば、以下のコマンドは、コマンドを受信したノードにスロット1、2、3を割り当てます。</target>
        </trans-unit>
        <trans-unit id="49606e7b6de7a4d4946192e9ed0aa5fb1d49ac0b" translate="yes" xml:space="preserve">
          <source>For example the following command increments an 5 bit signed integer at bit offset 100, and gets the value of the 4 bit unsigned integer at bit offset 0:</source>
          <target state="translated">例えば、以下のコマンドは、ビットオフセット 100 で 5 ビット符号付き整数をインクリメントし、ビットオフセット 0 で 4 ビット符号なし整数の値を取得します。</target>
        </trans-unit>
        <trans-unit id="b525686b0a28b28e11781b09afa87dd48c9db63b" translate="yes" xml:space="preserve">
          <source>For example the following command increments an 8 bit signed integer at bit offset 100, and gets the value of the 4 bit unsigned integer at bit offset 0:</source>
          <target state="translated">例えば、以下のコマンドは、ビットオフセット 100 で 8 ビット符号付き整数をインクリメントし、ビットオフセット 0 で 4 ビット符号なし整数の値を取得します。</target>
        </trans-unit>
        <trans-unit id="a97e5209e5c4a8fe8fdeedf84b0123aa8fa78b8b" translate="yes" xml:space="preserve">
          <source>For example the following command will trim the stream to exactly the latest 1000 items:</source>
          <target state="translated">例えば、以下のコマンドは、ストリームを最新の1000項目に正確にトリミングします。</target>
        </trans-unit>
        <trans-unit id="bb5422e2190f7f64ad2cf5faf5279a8730064c02" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;LREM list -2 &quot;hello&quot;&lt;/code&gt; will remove the last two occurrences of &lt;code&gt;&quot;hello&quot;&lt;/code&gt; in the list stored at &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">たとえば、 &lt;code&gt;LREM list -2 &quot;hello&quot;&lt;/code&gt; は、listに格納されている &lt;code&gt;list&lt;/code&gt; 内の &lt;code&gt;&quot;hello&quot;&lt;/code&gt; の最後の2つの出現を削除します。</target>
        </trans-unit>
        <trans-unit id="806b6380a574787b8a29a883731b6c80cdcdcc0d" translate="yes" xml:space="preserve">
          <source>For example, after setting a few bits, getting the string value of the bitmap would look like this:</source>
          <target state="translated">例えば、数ビットを設定した後、ビットマップの文字列値を取得すると次のようになります。</target>
        </trans-unit>
        <trans-unit id="b555dc3155500027017fa2a4b40d9e13b0289813" translate="yes" xml:space="preserve">
          <source>For example, if I have two streams &lt;code&gt;mystream&lt;/code&gt; and &lt;code&gt;writers&lt;/code&gt;, and I want to read data from both the streams starting from the first element they contain, I could call &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; like in the following example.</source>
          <target state="translated">たとえば、 &lt;code&gt;mystream&lt;/code&gt; と &lt;code&gt;writers&lt;/code&gt; の 2つのストリームがあり、両方のストリームに含まれる最初の要素からデータを読み取る場合、次の例のように&lt;a href=&quot;xread&quot;&gt;XREADを&lt;/a&gt;呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="cd44de0983e01c60e504cf2bf01e0f7c36d85e53" translate="yes" xml:space="preserve">
          <source>For example, the example above could be replaced by:</source>
          <target state="translated">例えば、上の例は、次のように置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="d36a4d27e7c4e26652f2b3ff43e697bb99cdbe49" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;LTRIM foobar 0 2&lt;/code&gt; will modify the list stored at &lt;code&gt;foobar&lt;/code&gt; so that only the first three elements of the list will remain.</source>
          <target state="translated">例： &lt;code&gt;LTRIM foobar 0 2&lt;/code&gt; は、 &lt;code&gt;foobar&lt;/code&gt; 保存されているリストを変更して、リストの最初の3つの要素のみが残るようにします。</target>
        </trans-unit>
        <trans-unit id="aac3daaf191be281b6ccb464e390234af5058fcd" translate="yes" xml:space="preserve">
          <source>For example: consider &lt;code&gt;source&lt;/code&gt; holding the list &lt;code&gt;a,b,c&lt;/code&gt;, and &lt;code&gt;destination&lt;/code&gt; holding the list &lt;code&gt;x,y,z&lt;/code&gt;. Executing &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; results in &lt;code&gt;source&lt;/code&gt; holding &lt;code&gt;a,b&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; holding &lt;code&gt;c,x,y,z&lt;/code&gt;.</source>
          <target state="translated">例：リスト &lt;code&gt;a,b,c&lt;/code&gt; 保持する &lt;code&gt;source&lt;/code&gt; と、リスト &lt;code&gt;x,y,z&lt;/code&gt; 保持する &lt;code&gt;destination&lt;/code&gt; を検討してください。&lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt;を実行 &lt;code&gt;a,b&lt;/code&gt; &lt;code&gt;source&lt;/code&gt; はa、bを保持し、 &lt;code&gt;destination&lt;/code&gt; &lt;code&gt;c,x,y,z&lt;/code&gt; 保持します。</target>
        </trans-unit>
        <trans-unit id="58bac03f69d7fb418a6dae21d7a1d10de406cdc5" translate="yes" xml:space="preserve">
          <source>For example: consider &lt;code&gt;source&lt;/code&gt; holding the list &lt;code&gt;a,b,c&lt;/code&gt;, and &lt;code&gt;destination&lt;/code&gt; holding the list &lt;code&gt;x,y,z&lt;/code&gt;. Executing &lt;code&gt;LMOVE source destination RIGHT LEFT&lt;/code&gt; results in &lt;code&gt;source&lt;/code&gt; holding &lt;code&gt;a,b&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; holding &lt;code&gt;c,x,y,z&lt;/code&gt;.</source>
          <target state="translated">例：リスト &lt;code&gt;a,b,c&lt;/code&gt; 保持している &lt;code&gt;source&lt;/code&gt; と、リスト &lt;code&gt;x,y,z&lt;/code&gt; 保持している &lt;code&gt;destination&lt;/code&gt; について考えてみます。実行 &lt;code&gt;LMOVE source destination RIGHT LEFT&lt;/code&gt; もたらす &lt;code&gt;source&lt;/code&gt; 保持 &lt;code&gt;a,b&lt;/code&gt; 及び &lt;code&gt;destination&lt;/code&gt; 保持 &lt;code&gt;c,x,y,z&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9a6b3077ebbc22869bdfb44c11c89f9170d1471" translate="yes" xml:space="preserve">
          <source>For expires to work well, the computer time must be taken stable. If you move an RDB file from two computers with a big desync in their clocks, funny things may happen (like all the keys loaded to be expired at loading time).</source>
          <target state="translated">期限切れがうまく機能するためには、コンピュータの時間が安定していなければならない。2台のコンピュータの時計が大きく同期している状態でRDBファイルを移動すると、おかしなことが起こるかもしれません (ロードされたすべてのキーがロード時に期限切れになっているような)。</target>
        </trans-unit>
        <trans-unit id="f28bf0b4c581b256fa3b954009c5dc47ca8cc986" translate="yes" xml:space="preserve">
          <source>For further information about Redis streams please check our &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introduction to Redis Streams document&lt;/a&gt;.</source>
          <target state="translated">Redisストリームの詳細については、Redisストリームの&lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;紹介ドキュメントを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="9419f194b12efba96ec9e9a8a47640ef77051d15" translate="yes" xml:space="preserve">
          <source>For instance an application with a persistent connection to Redis can be sure that if a script was sent once it is still in memory, so EVALSHA can be used against those scripts in a pipeline without the chance of an error being generated due to an unknown script (we'll see this problem in detail later).</source>
          <target state="translated">例えば、Redisへの持続的な接続を持つアプリケーションでは、スクリプトが一度送信されたものがまだメモリに残っていることを確認することができるので、未知のスクリプトが原因でエラーが発生することなく、パイプライン内のスクリプトに対してEVALSHAを使用することができます(この問題については後で詳しく説明します)。</target>
        </trans-unit>
        <trans-unit id="dc915bb7cfa9bbec54b9f20262e4f69d0c2936e5" translate="yes" xml:space="preserve">
          <source>For instance in the above example, the last items that we received for the stream &lt;code&gt;mystream&lt;/code&gt; has ID &lt;code&gt;1526999352406-0&lt;/code&gt;, while for the stream &lt;code&gt;writers&lt;/code&gt; has the ID &lt;code&gt;1526985685298-0&lt;/code&gt;.</source>
          <target state="translated">上記の例では例えば、我々は、ストリームのために受信した最後の項目 &lt;code&gt;mystream&lt;/code&gt; は ID持っ &lt;code&gt;1526999352406-0&lt;/code&gt; 、ストリームのためながら、 &lt;code&gt;writers&lt;/code&gt; ID持っ &lt;code&gt;1526985685298-0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12e98a029b908a48582debab0c6f730b78e90807" translate="yes" xml:space="preserve">
          <source>For instance the LCS between &quot;foo&quot; and &quot;fao&quot; is &quot;fo&quot;, since scanning the two strings from left to right, the longest common set of characters is composed of the first &quot;f&quot; and then the &quot;o&quot;.</source>
          <target state="translated">例えば、&quot;foo &quot;と &quot;fao &quot;の間のLCSは &quot;fo &quot;で、2つの文字列を左から右に走査すると、最初の &quot;f &quot;とその後の &quot;o &quot;で構成されているので、最も長い共通の文字セットは &quot;fo &quot;です。</target>
        </trans-unit>
        <trans-unit id="abfec42c58b79c70de1796787342d5de058e9f11" translate="yes" xml:space="preserve">
          <source>For instance what in &lt;code&gt;redis.conf&lt;/code&gt; looks like:</source>
          <target state="translated">たとえば、 &lt;code&gt;redis.conf&lt;/code&gt; の内容は次のようになります。</target>
        </trans-unit>
        <trans-unit id="310775bb715bff8a1231237bf82d220b152e2252" translate="yes" xml:space="preserve">
          <source>For instance when Redis is used in order to implement a queue, producers and consumers of messages may want to set the name of the connection according to their role.</source>
          <target state="translated">例えば、キューを実装するためにRedisを使用する場合、メッセージの生成者と消費者は、それぞれの役割に応じて接続の名前を設定したいと思うかもしれません。</target>
        </trans-unit>
        <trans-unit id="de61480f11e8a3010955bfd7cae332ac3deef0b2" translate="yes" xml:space="preserve">
          <source>For instance, in the above example the element &quot;c&quot; is present multiple times, if I want the index of the second match, I'll write:</source>
          <target state="translated">例えば、上の例では要素 &quot;c &quot;が複数回存在しているので、2回目にマッチした時のインデックスを知りたい場合はこう書きます。</target>
        </trans-unit>
        <trans-unit id="42fe68157034ba62944abb2ee31fe519ec8ceb83" translate="yes" xml:space="preserve">
          <source>For more information about replication in Redis please check the &lt;a href=&quot;https://redis.io/topics/replication&quot;&gt;replication page&lt;/a&gt;.</source>
          <target state="translated">Redisでのレプリケーションの詳細については、&lt;a href=&quot;https://redis.io/topics/replication&quot;&gt;レプリケーションページ&lt;/a&gt;を確認してください。</target>
        </trans-unit>
        <trans-unit id="f14c631da3e9eabaf78a7f5c398db9fc1eb1c9a2" translate="yes" xml:space="preserve">
          <source>For more information refer to the &lt;a href=&quot;https://redis.io/topics/latency-monitor&quot;&gt;Latency Monitoring Framework page&lt;/a&gt;.</source>
          <target state="translated">詳細については、&lt;a href=&quot;https://redis.io/topics/latency-monitor&quot;&gt;レイテンシモニタリングフレームワークのページを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4d1d2a650d31219d2da12b4e4c6aaa52db811850" translate="yes" xml:space="preserve">
          <source>For most commands the first key is position 1. Position 0 is always the command name itself.</source>
          <target state="translated">ほとんどのコマンドでは、最初のキーの位置は 1 です。位置 0 は常にコマンド名そのものです。</target>
        </trans-unit>
        <trans-unit id="f3b735d69f1d53bb920c323089af35c7960cd5bc" translate="yes" xml:space="preserve">
          <source>For nested data types, the optional &lt;code&gt;SAMPLES&lt;/code&gt; option can be provided, where &lt;code&gt;count&lt;/code&gt; is the number of sampled nested values. By default, this option is set to &lt;code&gt;5&lt;/code&gt;. To sample the all of the nested values, use &lt;code&gt;SAMPLES 0&lt;/code&gt;.</source>
          <target state="translated">ネストされたデータ型の場合、オプションの &lt;code&gt;SAMPLES&lt;/code&gt; オプションを指定できます。ここで、 &lt;code&gt;count&lt;/code&gt; は、サンプリングされたネストされた値の数です。デフォルトでは、このオプションは &lt;code&gt;5&lt;/code&gt; に設定されています。ネストされたすべての値をサンプリングするには、 &lt;code&gt;SAMPLES 0&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="29cc98c67031f5feb4c8c0734d6bcf119180ebd0" translate="yes" xml:space="preserve">
          <source>For real-time metrics and statistics involving large inputs a good approach is to use a replica (with read-only option disabled) where the bit-wise operations are performed to avoid blocking the master instance.</source>
          <target state="translated">大規模な入力を含むリアルタイムのメトリクスや統計情報については、マスター・インスタンスをブロックしないようにビット単位の演算を行うレプリカ(読み取り専用オプションを無効にした状態)を使用するのが良いアプローチです。</target>
        </trans-unit>
        <trans-unit id="86c11a7ed67c320eacf7f860ba9da8b316757034" translate="yes" xml:space="preserve">
          <source>For security concerns, certain special administration commands like &lt;code&gt;CONFIG&lt;/code&gt; are not logged into the &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; output.</source>
          <target state="translated">セキュリティ上の理由から、 &lt;code&gt;CONFIG&lt;/code&gt; などの特定の特別な管理コマンドは&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;出力にログインしません。</target>
        </trans-unit>
        <trans-unit id="906c5a5f8c50388c930df8c6fdc394c6fc2a805e" translate="yes" xml:space="preserve">
          <source>For the LCS algorithm:</source>
          <target state="translated">LCSアルゴリズムの場合。</target>
        </trans-unit>
        <trans-unit id="68c60647d6f0b610c394981eaeb8a9621bab7be5" translate="yes" xml:space="preserve">
          <source>For the subsequent calls, you'll need to programmatically advance the last entry's ID returned. Most Redis client should abstract this detail, but the implementation can also be in the application if needed. In the example above, this means incrementing the sequence of &lt;code&gt;1526985685298-0&lt;/code&gt; by one, from 0 to 1. The second call would, therefore, be:</source>
          <target state="translated">以降の呼び出しでは、最後に返されたエントリのIDをプログラムで進める必要があります。ほとんどのRedisクライアントはこの詳細を抽象化する必要がありますが、必要に応じて実装をアプリケーションに含めることもできます。上記の例では、これは &lt;code&gt;1526985685298-0&lt;/code&gt; のシーケンスを0から1に1ずつインクリメントすることを意味します。したがって、2番目の呼び出しは次のようになります。</target>
        </trans-unit>
        <trans-unit id="1d4a1b4aeeb486fd399846319b2294f91ddedb8b" translate="yes" xml:space="preserve">
          <source>For this reason, Redis 3.2 introduces a new command that only works when script effects replication is enabled, and is able to control the scripting replication engine. The command is called &lt;code&gt;redis.set_repl()&lt;/code&gt; and fails raising an error if called when script effects replication is disabled.</source>
          <target state="translated">このため、Redis 3.2には、スクリプトエフェクトレプリケーションが有効になっている場合にのみ機能し、スクリプトレプリケーションエンジンを制御できる新しいコマンドが導入されています。コマンドは &lt;code&gt;redis.set_repl()&lt;/code&gt; と呼ばれ、スクリプトがレプリケーションを無効にしているときに呼び出された場合、エラーが発生して失敗します。</target>
        </trans-unit>
        <trans-unit id="51865baeeba9dd27720c605912d3014b8edbbb78" translate="yes" xml:space="preserve">
          <source>Forces a node to save the &lt;code&gt;nodes.conf&lt;/code&gt; configuration on disk. Before to return the command calls &lt;code&gt;fsync(2)&lt;/code&gt; in order to make sure the configuration is flushed on the computer disk.</source>
          <target state="translated">ノードに &lt;code&gt;nodes.conf&lt;/code&gt; 設定を強制的にディスクに保存させます。コマンドを返す前に、設定がコンピュータディスクにフラッシュされていることを確認するために、 &lt;code&gt;fsync(2)&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="620cbfd5798a03238a582c36dc6180b1d68a8181" translate="yes" xml:space="preserve">
          <source>Fortunately, it's possible to avoid this issue using the following algorithm. Let's see how C4, our sane client, uses the good algorithm:</source>
          <target state="translated">幸いなことに、次のアルゴリズムを使えば、この問題を回避することができます。正気のクライアントであるC4がどのように良いアルゴリズムを使っているか見てみましょう。</target>
        </trans-unit>
        <trans-unit id="e02d5afefc425c600d8eecdd85f79d3604e46010" translate="yes" xml:space="preserve">
          <source>From the point of view of the syntax, the commands are almost the same, however &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;&lt;em&gt;requires&lt;/em&gt; a special and mandatory option:</source>
          <target state="translated">構文の観点からは、コマンドはほとんど同じですが、&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUPに&lt;/a&gt;&lt;em&gt;は&lt;/em&gt;特別で必須のオプション&lt;em&gt;が必要&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="86f3ae974780a50a7664a8c324379a24cfdab877" translate="yes" xml:space="preserve">
          <source>Fun fact: Reddit's 2017 April fools' project &lt;a href=&quot;https://reddit.com/r/place&quot;&gt;r/place&lt;/a&gt; was &lt;a href=&quot;https://redditblog.com/2017/04/13/how-we-built-rplace/&quot;&gt;built using the Redis BITFIELD command&lt;/a&gt; in order to take an in-memory representation of the collaborative canvas.</source>
          <target state="translated">&lt;a href=&quot;https://redditblog.com/2017/04/13/how-we-built-rplace/&quot;&gt;面白い&lt;/a&gt;事実：Redditの2017エイプリルフールのプロジェクト&lt;a href=&quot;https://reddit.com/r/place&quot;&gt;r / place&lt;/a&gt;は、コラボレーションキャンバスのメモリ内表現を取得するために、Redis BITFIELDコマンドを使用して構築されました。</target>
        </trans-unit>
        <trans-unit id="53eb3603814482cd94f53dcb8dd480c97fb7a365" translate="yes" xml:space="preserve">
          <source>Furthermore, the following commands are also not logged:</source>
          <target state="translated">さらに、以下のコマンドもログに記録されません。</target>
        </trans-unit>
        <trans-unit id="29ad85263278e1f788abee93dcd93c6b5f400940" translate="yes" xml:space="preserve">
          <source>GEOADD</source>
          <target state="translated">GEOADD</target>
        </trans-unit>
        <trans-unit id="fe36dd170b2d009a6fb9b3209da995c6be0a8014" translate="yes" xml:space="preserve">
          <source>GEOADD  key longitude latitude member [longitude latitude member ...]   Add one or more geospatial items in the geospatial index represented using a sorted set</source>
          <target state="translated">GEOADD キー経度緯度メンバー [経度緯度メンバー ...]ソートされた集合を用いて表現された地理空間インデックスに、1つ以上の地理空間項目を追加する。</target>
        </trans-unit>
        <trans-unit id="9aee98cec79ef9607b17d14a98e26344f2559e24" translate="yes" xml:space="preserve">
          <source>GEODIST</source>
          <target state="translated">GEODIST</target>
        </trans-unit>
        <trans-unit id="d87009d6893410d7c22a72e0781ff862c94b8508" translate="yes" xml:space="preserve">
          <source>GEODIST  key member1 member2 [m|km|ft|mi]   Returns the distance between two members of a geospatial index</source>
          <target state="translated">GEODIST key member1 member2 [m|km|ft|mi]地理空間インデックスの2つのメンバー間の距離を返します。</target>
        </trans-unit>
        <trans-unit id="0a8e4fd28c6ceedcd2cf757094650298262be7f7" translate="yes" xml:space="preserve">
          <source>GEODIST  key member1 member2 [unit]   Returns the distance between two members of a geospatial index</source>
          <target state="translated">GEODIST key member1 member2 [unit]地理空間インデックスの2つのメンバ間の距離を返します。</target>
        </trans-unit>
        <trans-unit id="d944f228d17ba584e232ef6b37a2330565210913" translate="yes" xml:space="preserve">
          <source>GEOHASH</source>
          <target state="translated">GEOHASH</target>
        </trans-unit>
        <trans-unit id="15d5ff901e592f20465c4a81d62cdf535660ac71" translate="yes" xml:space="preserve">
          <source>GEOHASH  key member [member ...]   Returns members of a geospatial index as standard geohash strings</source>
          <target state="translated">GEOHASH key member [member ....]地理空間インデックスのメンバーを標準のジオハッシュ文字列として返します。</target>
        </trans-unit>
        <trans-unit id="567f488d82e3265931365c2760b37b40e268471e" translate="yes" xml:space="preserve">
          <source>GEOPOS</source>
          <target state="translated">GEOPOS</target>
        </trans-unit>
        <trans-unit id="681795a057130a9988e5c024a1915dc60c2ecb58" translate="yes" xml:space="preserve">
          <source>GEOPOS  key member [member ...]   Returns longitude and latitude of members of a geospatial index</source>
          <target state="translated">GEOPOS key member [member ....]地理空間インデックスのメンバーの経度と緯度を返す。</target>
        </trans-unit>
        <trans-unit id="f883ad1ea5b9628a7c035af52696e8e216f48428" translate="yes" xml:space="preserve">
          <source>GEORADIUS</source>
          <target state="translated">GEORADIUS</target>
        </trans-unit>
        <trans-unit id="78a8e700f33e02c64280e94efe97493736549c5c" translate="yes" xml:space="preserve">
          <source>GEORADIUS  key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]   Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a point</source>
          <target state="translated">GEORADIUS キー経度緯度半径 m|km|ft|mi [WITHCOORD][WITHDIST][WITHHASH][COUNT count][ASC|DESC][STORE key][STOREDIST key]地理空間インデックスを表すソートされたセットを取得し、点からの最大距離に一致するメンバーを取得します。</target>
        </trans-unit>
        <trans-unit id="ae4c6b87ec31f7b6af274155550a43bc379afb42" translate="yes" xml:space="preserve">
          <source>GEORADIUSBYMEMBER</source>
          <target state="translated">GEORADIUSBYMEMBER</target>
        </trans-unit>
        <trans-unit id="cf98dab16a680969ed5a7c59dd91c064dd5ffd22" translate="yes" xml:space="preserve">
          <source>GEORADIUSBYMEMBER  key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]   Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a member</source>
          <target state="translated">GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD][WITHDIST][WITHHASH][COUNT count][ASC|DESC][STORE key][STOREDIST key]地理空間インデックスを表すソートされた集合に問い合わせて、メンバーからの最大距離に一致するメンバーを取得します。</target>
        </trans-unit>
        <trans-unit id="8c656e42e400e0e0513de5eb5312afe50a9bf1f5" translate="yes" xml:space="preserve">
          <source>GEOSEARCH</source>
          <target state="translated">GEOSEARCH</target>
        </trans-unit>
        <trans-unit id="3f9c1bdbc9920ba8577c53041094c05d6b105844" translate="yes" xml:space="preserve">
          <source>GEOSEARCH  key [FROMMEMBER member] [FROMLONLAT longitude latitude] [BYRADIUS radius m|km|ft|mi] [BYBOX width height m|km|ft|mi] [ASC|DESC] [COUNT count] [WITHCOORD] [WITHDIST] [WITHHASH]   Query a sorted set representing a geospatial index to fetch members inside an area of a box or a circle.</source>
          <target state="translated">GEOSEARCHキー [FROMMEMBER member][FROMLONLAT経度緯度][BYRADIUS半径m|km|ft|mi][BYBOX幅高さm|km|ft|mi][ASC|DESC][COUNT count][WITHCOORD][WITHDIST][WITHHASH]地理空間インデックスを表すソートされた集合を取得して、箱や円の領域内のメンバーを取得します。</target>
        </trans-unit>
        <trans-unit id="6b6122a14306dc58653c28237fae16723377d12d" translate="yes" xml:space="preserve">
          <source>GEOSEARCHSTORE</source>
          <target state="translated">GEOSEARCHSTORE</target>
        </trans-unit>
        <trans-unit id="8ad42c0130aa6e2dd8ebab61f847d23ba5e52254" translate="yes" xml:space="preserve">
          <source>GEOSEARCHSTORE  destination source [FROMMEMBER member] [FROMLONLAT longitude latitude] [BYRADIUS radius m|km|ft|mi] [BYBOX width height m|km|ft|mi] [ASC|DESC] [COUNT count] [WITHCOORD] [WITHDIST] [WITHHASH] [STOREDIST]   Query a sorted set representing a geospatial index to fetch members inside an area of a box or a circle, and store the result in another key.</source>
          <target state="translated">GEOSEARCHSTORE 宛先ソース [FROMMEMBER member][FROMLONLAT 経度緯度][BYRADIUS radius m|km|ft|mi][BYBOX width height m|km|ft|mi][ASC|DESC][COUNT count][WITHCOORD][WITHDIST][WITHHASH][STOREDIST]地理空間インデックスを表すソートされたセットを取得し、箱や円の領域内のメンバーを取得します。を作成し、その結果を別のキーに格納します。</target>
        </trans-unit>
        <trans-unit id="f030bbbd32966cde41037b98a8849c46b76e4bc1" translate="yes" xml:space="preserve">
          <source>GET</source>
          <target state="translated">GET</target>
        </trans-unit>
        <trans-unit id="7d7f9a21ff2fe871d6f138989249c29532bb7fdc" translate="yes" xml:space="preserve">
          <source>GET  key   Get the value of a key</source>
          <target state="translated">GET key キーの値を取得します。</target>
        </trans-unit>
        <trans-unit id="ef9841e66f1ceb2a8ca3c4b61209bfb1ccb07d46" translate="yes" xml:space="preserve">
          <source>GETBIT</source>
          <target state="translated">GETBIT</target>
        </trans-unit>
        <trans-unit id="c67560b598b48f8d8597f643fcac2a09acec11dd" translate="yes" xml:space="preserve">
          <source>GETBIT  key offset   Returns the bit value at offset in the string value stored at key</source>
          <target state="translated">GETBIT key offset key に格納されている文字列値の offset のビット値を返します。</target>
        </trans-unit>
        <trans-unit id="171dc01acd21b14b16885f344959333f303f7868" translate="yes" xml:space="preserve">
          <source>GETRANGE</source>
          <target state="translated">GETRANGE</target>
        </trans-unit>
        <trans-unit id="120d6e3c8bea25d9ffe941d0b9d148464db210c6" translate="yes" xml:space="preserve">
          <source>GETRANGE  key start end   Get a substring of the string stored at a key</source>
          <target state="translated">GETRANGE key start end キーに格納されている文字列の部分文字列を取得します。</target>
        </trans-unit>
        <trans-unit id="6a4472582074006f8a0d04a695a91bfb64d3f211" translate="yes" xml:space="preserve">
          <source>GETSET</source>
          <target state="translated">GETSET</target>
        </trans-unit>
        <trans-unit id="ea14ecdc443c7b2197bfb8f599d84d9e3ddc91a9" translate="yes" xml:space="preserve">
          <source>GETSET  key value   Set the string value of a key and return its old value</source>
          <target state="translated">GETSET キーの値 キーの文字列値を設定し、その古い値を返します。</target>
        </trans-unit>
        <trans-unit id="0f33bfb55b7c38358e7fef810b5a8c3a19e508c9" translate="yes" xml:space="preserve">
          <source>Generate a new &lt;code&gt;configEpoch&lt;/code&gt; unilaterally, just taking the current greatest epoch available and incrementing it if its local configuration epoch is not already the greatest.</source>
          <target state="translated">新しい &lt;code&gt;configEpoch&lt;/code&gt; を一方的に生成し、現在利用可能な最大のエポックを取得し、ローカル構成エポックがまだ最大でない場合は、それを増分します。</target>
        </trans-unit>
        <trans-unit id="8770e1d00765da154add27070eb66b76abb639e9" translate="yes" xml:space="preserve">
          <source>Geo</source>
          <target state="translated">Geo</target>
        </trans-unit>
        <trans-unit id="00754e7ec718eca2346352874423afcfcd99de6c" translate="yes" xml:space="preserve">
          <source>Geohash string properties</source>
          <target state="translated">ジオハッシュ文字列プロパティ</target>
        </trans-unit>
        <trans-unit id="fcba9fe6c6b3ee7a7679d8a80f01c177efafb91f" translate="yes" xml:space="preserve">
          <source>Get keys from the source node with &lt;a href=&quot;cluster-getkeysinslot&quot;&gt;CLUSTER GETKEYSINSLOT&lt;/a&gt; command and move them into the destination node using the &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; command.</source>
          <target state="translated">&lt;a href=&quot;cluster-getkeysinslot&quot;&gt;CLUSTER GETKEYSINSLOT&lt;/a&gt;コマンドを使用してソースノードからキーを取得し、&lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt;コマンドを使用してそれらを宛先ノードに移動します。</target>
        </trans-unit>
        <trans-unit id="09aec2d48c2bf33e9f4de1efe0b69e4c3361c2f6" translate="yes" xml:space="preserve">
          <source>Get the value of &lt;code&gt;key&lt;/code&gt;. If the key does not exist the special value &lt;code&gt;nil&lt;/code&gt; is returned. An error is returned if the value stored at &lt;code&gt;key&lt;/code&gt; is not a string, because &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; only handles string values.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; の値を取得します。キーが存在しない場合は、特別な値 &lt;code&gt;nil&lt;/code&gt; が返されます。&lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt;は文字列値のみを処理するため、 &lt;code&gt;key&lt;/code&gt; に格納されている値が文字列でない場合はエラーが返されます。</target>
        </trans-unit>
        <trans-unit id="4f07c68cfde1cce4484071399ec3dcac10ef3226" translate="yes" xml:space="preserve">
          <source>Given a list of SHA1 digests as arguments this command returns an array of 1 or 0, where 1 means the specific SHA1 is recognized as a script already present in the scripting cache, while 0 means that a script with this SHA1 was never seen before (or at least never seen after the latest SCRIPT FLUSH command).</source>
          <target state="translated">引数として SHA1 ダイジェストのリストが与えられると、このコマンドは 1 または 0 の配列を返します。1 は特定の SHA1 がスクリプトキャッシュに既に存在するスクリプトとして認識されていることを意味し、0 はこの SHA1 を持つスクリプトが以前に見られたことがないことを意味します (少なくとも最新の SCRIPT FLUSH コマンドの後には見られたことがない)。</target>
        </trans-unit>
        <trans-unit id="5e47705fe8d80f510ddf59025f5bedac0bd2d833" translate="yes" xml:space="preserve">
          <source>Given a sorted set representing a geospatial index, populated using the &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; command, it is often useful to obtain back the coordinates of specified members. When the geospatial index is populated via &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; the coordinates are converted into a 52 bit geohash, so the coordinates returned may not be exactly the ones used in order to add the elements, but small errors may be introduced.</source>
          <target state="translated">&lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;コマンドを使用して入力された、地理空間インデックスを表すソートされたセットが与えられた場合、指定されたメンバーの座標を取得することはしばしば役立ちます。地理空間インデックスが&lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;を介して入力されると、座標は52ビットのジオハッシュに変換されるため、返される座標は要素を追加するために使用されたものとは正確に一致しない場合がありますが、小さなエラーが発生する場合があります。</target>
        </trans-unit>
        <trans-unit id="1a98977aea8887ddd5a1edb60251e403b53795ab" translate="yes" xml:space="preserve">
          <source>Given a sorted set representing a geospatial index, populated using the &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; command, the command returns the distance between the two specified members in the specified unit.</source>
          <target state="translated">&lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;コマンドを使用して入力された、地理空間インデックスを表すソートされたセットを指定すると、コマンドは、指定された単位内の指定された2つのメンバー間の距離を返します。</target>
        </trans-unit>
        <trans-unit id="f45f257965d0c26e93bb5789953aca2dc751ef9e" translate="yes" xml:space="preserve">
          <source>Global variables protection</source>
          <target state="translated">グローバル変数の保護</target>
        </trans-unit>
        <trans-unit id="107625e2c3bcf140428d9df7e4e1066049947d81" translate="yes" xml:space="preserve">
          <source>Groups, consumers and PELs are returned.</source>
          <target state="translated">グループ、消費者、PELが返却されます。</target>
        </trans-unit>
        <trans-unit id="15d1555c45e5fc58578080840f0c6368a6d6cb11" translate="yes" xml:space="preserve">
          <source>Guarantee of termination</source>
          <target state="translated">終了の保証</target>
        </trans-unit>
        <trans-unit id="5205aa5d3ee9c438b38044d5999ac4ba4201f832" translate="yes" xml:space="preserve">
          <source>HDEL</source>
          <target state="translated">HDEL</target>
        </trans-unit>
        <trans-unit id="f0d9eb5c49197bfd6feeb0c9d7b482f5e211f201" translate="yes" xml:space="preserve">
          <source>HDEL  key field [field ...]   Delete one or more hash fields</source>
          <target state="translated">HDEL キーフィールド [フィールド ....]1 つ以上のハッシュフィールドを削除します。</target>
        </trans-unit>
        <trans-unit id="c65f99f8c5376adadddc46d5cbcf5762f9e55eb7" translate="yes" xml:space="preserve">
          <source>HELLO</source>
          <target state="translated">HELLO</target>
        </trans-unit>
        <trans-unit id="194f965f233e82e8b705df8610029d9234df6a34" translate="yes" xml:space="preserve">
          <source>HELLO  protover [AUTH username password] [SETNAME clientname]   switch Redis protocol</source>
          <target state="translated">HELLO protover [AUTH username password][SETNAME clientname]switch Redis protocol</target>
        </trans-unit>
        <trans-unit id="b48dcfbcf4eca1611582a1cc8baa82d9d2fa2960" translate="yes" xml:space="preserve">
          <source>HEXISTS</source>
          <target state="translated">HEXISTS</target>
        </trans-unit>
        <trans-unit id="a807653048c48da53e448a2b285039ef0573aae8" translate="yes" xml:space="preserve">
          <source>HEXISTS  key field   Determine if a hash field exists</source>
          <target state="translated">HEXISTS キーフィールド ハッシュフィールドが存在するかどうかを判断します。</target>
        </trans-unit>
        <trans-unit id="2aa481a50927484124964b6f73bac3881de47ff3" translate="yes" xml:space="preserve">
          <source>HGET</source>
          <target state="translated">HGET</target>
        </trans-unit>
        <trans-unit id="53e1681d3979ea38127102b70459b3a4ea647f65" translate="yes" xml:space="preserve">
          <source>HGET  key field   Get the value of a hash field</source>
          <target state="translated">HGET キーフィールド ハッシュフィールドの値を取得します。</target>
        </trans-unit>
        <trans-unit id="0949fe15e4d07355cc1f8bdf2d7d0a3bc27e0498" translate="yes" xml:space="preserve">
          <source>HGETALL</source>
          <target state="translated">HGETALL</target>
        </trans-unit>
        <trans-unit id="a9f2d8c36ab9a92512a3abf304cf22c78a10d32a" translate="yes" xml:space="preserve">
          <source>HGETALL  key   Get all the fields and values in a hash</source>
          <target state="translated">HGETALL key ハッシュ内のすべてのフィールドと値を取得します。</target>
        </trans-unit>
        <trans-unit id="bec3f40ebfc071338931e9ec346c383954f688e2" translate="yes" xml:space="preserve">
          <source>HINCRBY</source>
          <target state="translated">HINCRBY</target>
        </trans-unit>
        <trans-unit id="85ba7d4ce6a861db6587eaef82d0c559a1acad5a" translate="yes" xml:space="preserve">
          <source>HINCRBY  key field increment   Increment the integer value of a hash field by the given number</source>
          <target state="translated">HINCRBY キーフィールドのインクリメント ハッシュフィールドの整数値を指定した数だけ増加させます。</target>
        </trans-unit>
        <trans-unit id="a93522c3800a73e9eb332f7f840625aacdc296f3" translate="yes" xml:space="preserve">
          <source>HINCRBYFLOAT</source>
          <target state="translated">HINCRBYFLOAT</target>
        </trans-unit>
        <trans-unit id="b074f9cd10320d76be5375524c56b4c4f5083f25" translate="yes" xml:space="preserve">
          <source>HINCRBYFLOAT  key field increment   Increment the float value of a hash field by the given amount</source>
          <target state="translated">HINCRBYFLOAT キーフィールドのインクリメント ハッシュフィールドの float 値を指定した量だけ増加させます。</target>
        </trans-unit>
        <trans-unit id="a857392e173da21b13e4d3e033f1d7d6aadde58a" translate="yes" xml:space="preserve">
          <source>HKEYS</source>
          <target state="translated">HKEYS</target>
        </trans-unit>
        <trans-unit id="4880894873a3e4a3dcf54bf74bebf960afb44a7c" translate="yes" xml:space="preserve">
          <source>HKEYS  key   Get all the fields in a hash</source>
          <target state="translated">HKEYS key ハッシュ内のすべてのフィールドを取得します。</target>
        </trans-unit>
        <trans-unit id="4d36dfb03a6ecdea21a171dc0c30adebe8d01184" translate="yes" xml:space="preserve">
          <source>HLEN</source>
          <target state="translated">HLEN</target>
        </trans-unit>
        <trans-unit id="bcfcea9d003f5af07b2bb8099e2b496b1e9e832a" translate="yes" xml:space="preserve">
          <source>HLEN  key   Get the number of fields in a hash</source>
          <target state="translated">HLEN key ハッシュ内のフィールド数を取得します。</target>
        </trans-unit>
        <trans-unit id="480987a6e9c4e7cd1d65f5ffad4b88a1132f2c6f" translate="yes" xml:space="preserve">
          <source>HMGET</source>
          <target state="translated">HMGET</target>
        </trans-unit>
        <trans-unit id="5b7367a8f047e6e2ad4600495794ba1f6c7d8f47" translate="yes" xml:space="preserve">
          <source>HMGET  key field [field ...]   Get the values of all the given hash fields</source>
          <target state="translated">HMGET キーフィールド [フィールド ....]与えられたすべてのハッシュフィールドの値を取得します。</target>
        </trans-unit>
        <trans-unit id="fb5089ab3a0516d344f9de817ed332775e142279" translate="yes" xml:space="preserve">
          <source>HMSET</source>
          <target state="translated">HMSET</target>
        </trans-unit>
        <trans-unit id="b9ce7bb49b575eba9a143cb12bd3a727345953bd" translate="yes" xml:space="preserve">
          <source>HMSET  key field value [field value ...]   Set multiple hash fields to multiple values</source>
          <target state="translated">HMSET キーフィールド値 [フィールド値 ...]複数のハッシュフィールドを複数の値に設定する</target>
        </trans-unit>
        <trans-unit id="f36a969e90bd023793807636ddb180dde5956fd7" translate="yes" xml:space="preserve">
          <source>HSCAN</source>
          <target state="translated">HSCAN</target>
        </trans-unit>
        <trans-unit id="1f717593e9570c814ba25178e664e1d1c164122d" translate="yes" xml:space="preserve">
          <source>HSCAN  key cursor [MATCH pattern] [COUNT count]   Incrementally iterate hash fields and associated values</source>
          <target state="translated">HSCAN キーカーソル [MATCH パターン][COUNT カウント]ハッシュフィールドと関連する値の反復処理を増加させます。</target>
        </trans-unit>
        <trans-unit id="00cee6cf2b7799f7538096724dbd92d41cec6aeb" translate="yes" xml:space="preserve">
          <source>HSET</source>
          <target state="translated">HSET</target>
        </trans-unit>
        <trans-unit id="665396b991835984fc7e3e34cd2fe5312ecf417d" translate="yes" xml:space="preserve">
          <source>HSET  key field value   Set the string value of a hash field</source>
          <target state="translated">HSET キーフィールド値 ハッシュフィールドの文字列値を設定します。</target>
        </trans-unit>
        <trans-unit id="bc6fdaa755b1bfae0ec78315f5fb3674c528f4e4" translate="yes" xml:space="preserve">
          <source>HSET  key field value [field value ...]   Set the string value of a hash field</source>
          <target state="translated">HSET キーフィールド値 [フィールド値 ...]ハッシュフィールドの文字列値を設定します。</target>
        </trans-unit>
        <trans-unit id="f08f81142bc45f390db40acaf0af8de40d5f8df0" translate="yes" xml:space="preserve">
          <source>HSETNX</source>
          <target state="translated">HSETNX</target>
        </trans-unit>
        <trans-unit id="8f0805bb5892aca6c147d761f188dcc8c135168b" translate="yes" xml:space="preserve">
          <source>HSETNX  key field value   Set the value of a hash field, only if the field does not exist</source>
          <target state="translated">HSETNX キーフィールド値 ハッシュフィールドの値を設定する。</target>
        </trans-unit>
        <trans-unit id="653e2c00767d7da99a4ad249e0220683a0f21927" translate="yes" xml:space="preserve">
          <source>HSTRLEN</source>
          <target state="translated">HSTRLEN</target>
        </trans-unit>
        <trans-unit id="bb8103389cfdcecf46656f06573ed3513c20d29d" translate="yes" xml:space="preserve">
          <source>HSTRLEN  key field   Get the length of the value of a hash field</source>
          <target state="translated">HSTRLEN キーフィールド ハッシュフィールドの値の長さを取得します。</target>
        </trans-unit>
        <trans-unit id="75c2a102095c5cfb3745c7635997fd6d46e1ed99" translate="yes" xml:space="preserve">
          <source>HVALS</source>
          <target state="translated">HVALS</target>
        </trans-unit>
        <trans-unit id="2cf3758bf2c3fcb0cf4699e1fad2c529e7f60c18" translate="yes" xml:space="preserve">
          <source>HVALS  key   Get all the values in a hash</source>
          <target state="translated">HVALS キー ハッシュ内のすべての値を取得します。</target>
        </trans-unit>
        <trans-unit id="1679a916ecf39377920740d5654170e7e20f04f9" translate="yes" xml:space="preserve">
          <source>Handling deadlocks</source>
          <target state="translated">デッドロックの処理</target>
        </trans-unit>
        <trans-unit id="17348a159bc90f6828002f9fa69a3bdc1006ad33" translate="yes" xml:space="preserve">
          <source>Handling of strings with different lengths</source>
          <target state="translated">長さの異なる文字列の取り扱い</target>
        </trans-unit>
        <trans-unit id="5551ebd48f7eaa66477f72c449e4b2ccfc0f9609" translate="yes" xml:space="preserve">
          <source>Hashes</source>
          <target state="translated">Hashes</target>
        </trans-unit>
        <trans-unit id="abef659c43351c90fc57bd2f1f2ca21c74a56b5c" translate="yes" xml:space="preserve">
          <source>Hashes can be encoded as &lt;code&gt;ziplist&lt;/code&gt; or &lt;code&gt;hashtable&lt;/code&gt;. The &lt;code&gt;ziplist&lt;/code&gt; is a special encoding used for small hashes.</source>
          <target state="translated">ハッシュは、次のように符号化することができる &lt;code&gt;ziplist&lt;/code&gt; または &lt;code&gt;hashtable&lt;/code&gt; 。 &lt;code&gt;ziplist&lt;/code&gt; は、小さなハッシュのために使用される特殊なエンコーディングです。</target>
        </trans-unit>
        <trans-unit id="a9f98aceea4b6640fde4f0db2b67c8b62670525a" translate="yes" xml:space="preserve">
          <source>Helper functions to return Redis types</source>
          <target state="translated">Redisの型を返すためのヘルパー関数</target>
        </trans-unit>
        <trans-unit id="71f2a2c44b12e8d025ffdb0ba44d167f2eb32dc5" translate="yes" xml:space="preserve">
          <source>Here are a few conversion examples:</source>
          <target state="translated">ここでは、いくつかの変換例を紹介します。</target>
        </trans-unit>
        <trans-unit id="bd16d98ee220a06318e7c2f0edf89d89e391fb27" translate="yes" xml:space="preserve">
          <source>Here is the description of fields for Redis &amp;gt;= 2.4.</source>
          <target state="translated">Redis&amp;gt; = 2.4のフィールドの説明を次に示します。</target>
        </trans-unit>
        <trans-unit id="1953d7d107ad4ade79603b02cdb1e8adc699e514" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;clients&lt;/strong&gt; section:</source>
          <target state="translated">&lt;strong&gt;クライアント&lt;/strong&gt;セクションのすべてのフィールドの意味は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="aa545dc398491c6907d2041f2ded31d190284a9f" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;cpu&lt;/strong&gt; section:</source>
          <target state="translated">&lt;strong&gt;CPU&lt;/strong&gt;セクションのすべてのフィールドの意味は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="d3d5c7888fb0526434ccb545db7ed9e893e48b61" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;memory&lt;/strong&gt; section:</source>
          <target state="translated">&lt;strong&gt;メモリ&lt;/strong&gt;セクションのすべてのフィールドの意味は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="d1e56b526c805770cba7347f8a39b9426d10e67e" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;persistence&lt;/strong&gt; section:</source>
          <target state="translated">以下は、&lt;strong&gt;永続性&lt;/strong&gt;セクションのすべてのフィールドの意味です。</target>
        </trans-unit>
        <trans-unit id="799881fdedd2437b9e8155aa33f7576cc6d468a1" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;replication&lt;/strong&gt; section:</source>
          <target state="translated">&lt;strong&gt;レプリケーション&lt;/strong&gt;セクションのすべてのフィールドの意味は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="0d613b28b44d140ea4afd266be689c2f86ce192d" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;server&lt;/strong&gt; section:</source>
          <target state="translated">&lt;strong&gt;サーバー&lt;/strong&gt;セクションのすべてのフィールドの意味は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="9700349259df5577664d69e8579a5af99e65c52f" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;stats&lt;/strong&gt; section:</source>
          <target state="translated">&lt;strong&gt;stats&lt;/strong&gt;セクションのすべてのフィールドの意味は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="4bd3033708ea4b8a6d1fbb504db04260b3b5e786" translate="yes" xml:space="preserve">
          <source>Here is the meaning of the fields:</source>
          <target state="translated">畑の意味はここにあります。</target>
        </trans-unit>
        <trans-unit id="e97f41ad39a769cdba126aa050e98bd0bf28b8b9" translate="yes" xml:space="preserve">
          <source>Here's the default configuration for the default user:</source>
          <target state="translated">こちらがデフォルトのユーザーの設定です。</target>
        </trans-unit>
        <trans-unit id="4d96106a2b4866d88034cf3cbc99a16013a0e36c" translate="yes" xml:space="preserve">
          <source>Hint: it is possible to switch to a different key based on the current Unix time, in this way it is possible to have just a relatively small amount of samples per key, to avoid dealing with very big keys, and to make this pattern more friendly to be distributed across many Redis instances.</source>
          <target state="translated">ヒント:現在のUnixの時刻に基づいて別のキーに切り替えることが可能です。この方法では、キーごとに比較的少量のサンプルを持つことができ、非常に大きなキーを扱うのを避け、このパターンを多くのRedisインスタンスに分散させやすくすることができます。</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="b51e386256184dc34229a5ca92a34accb7024327" translate="yes" xml:space="preserve">
          <source>How Redis expires keys</source>
          <target state="translated">Redisはどのようにキーを期限切れにするか</target>
        </trans-unit>
        <trans-unit id="e21860bf37328b97ebb0ddd904694c78e4a7b382" translate="yes" xml:space="preserve">
          <source>How does it work?</source>
          <target state="translated">どうやって使うのか?</target>
        </trans-unit>
        <trans-unit id="88559343d1f8627b05ed905092ec3f856b6418a7" translate="yes" xml:space="preserve">
          <source>How expires are handled in the replication link and AOF file</source>
          <target state="translated">レプリケーションリンクとAOFファイルでの期限切れの処理方法</target>
        </trans-unit>
        <trans-unit id="a8dbfaf95083e1d6e63da157f09e95d8c10fa20f" translate="yes" xml:space="preserve">
          <source>How multiple clients blocked on a single stream are served</source>
          <target state="translated">1つのストリームでブロックされた複数のクライアントがどのようにしてサービスを提供するか</target>
        </trans-unit>
        <trans-unit id="d5868df09b7eeb0561970a8e423e96c9ad849dbe" translate="yes" xml:space="preserve">
          <source>How to specify intervals</source>
          <target state="translated">インターバルの指定方法</target>
        </trans-unit>
        <trans-unit id="d7cd6ea4777d91cd4768a12501593a68c032c01e" translate="yes" xml:space="preserve">
          <source>However Lua scripts running in Redis 6 or greater, are able to switch to RESP3 mode, and get the replies using the new available types. Similarly Lua scripts are able to reply to clients using the new types. Please make sure to understand &lt;a href=&quot;https://github.com/antirez/resp3&quot;&gt;the capabilities for RESP3&lt;/a&gt; before continuing reading this section.</source>
          <target state="translated">ただし、Redis 6以降で実行されているLuaスクリプトは、RESP3モードに切り替えて、使用可能な新しいタイプを使用して応答を取得できます。同様に、Luaスクリプトは、新しいタイプを使用してクライアントに応答できます。このセクションを読み続ける前に&lt;a href=&quot;https://github.com/antirez/resp3&quot;&gt;、RESP3の機能を&lt;/a&gt;必ず理解してください。</target>
        </trans-unit>
        <trans-unit id="7a00a1128dbff721f5566b479531909bd1900b68" translate="yes" xml:space="preserve">
          <source>However because &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; has very little state associated (just the cursor) it has the following drawbacks:</source>
          <target state="translated">ただし、&lt;a href=&quot;scan&quot;&gt;SCANに&lt;/a&gt;はほとんど関連付けられていない状態（カーソルのみ）があるため、次の欠点があります。</target>
        </trans-unit>
        <trans-unit id="d5314787731edc5f7c64fb20d0e8d7d8aa980d1c" translate="yes" xml:space="preserve">
          <source>However if the offset is prefixed with a &lt;code&gt;#&lt;/code&gt; character, the specified offset is multiplied by the integer type width, so for example:</source>
          <target state="translated">ただし、オフセットの前に &lt;code&gt;#&lt;/code&gt; 文字を付けると、指定したオフセットに整数型の幅が乗算されます。たとえば、次のようになります。</target>
        </trans-unit>
        <trans-unit id="f5cfa667464e115c28334f27e6f622c0e6fc2a1c" translate="yes" xml:space="preserve">
          <source>However in this context the obtained queue is not &lt;em&gt;reliable&lt;/em&gt; as messages can be lost, for example in the case there is a network problem or if the consumer crashes just after the message is received but it is still to process.</source>
          <target state="translated">ただし、このコンテキストでは、取得されたキューは&lt;em&gt;信頼性&lt;/em&gt;がありません。たとえば、ネットワークに問題がある場合や、メッセージを受信した直後にコンシューマーがクラッシュしたが、まだ処理中である場合などは、メッセージが失われる可能&lt;em&gt;性&lt;/em&gt;があります。</target>
        </trans-unit>
        <trans-unit id="32db1099030ce3f6b2493101785b95bdd63b63e3" translate="yes" xml:space="preserve">
          <source>However it returns OK to the caller ASAP, so the &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt; command execution is not paused by itself.</source>
          <target state="translated">ただし、呼び出し元にOKをすぐに返すため、&lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt;コマンドの実行はそれ自体で一時停止されません。</target>
        </trans-unit>
        <trans-unit id="5ebc54eeb70e7c4776f4ca626c28b6528713adcd" translate="yes" xml:space="preserve">
          <source>However node hash slots can be in a special state, used in order to communicate errors after a node restart (mismatch between the keys in the AOF/RDB file, and the node hash slots configuration), or when there is a resharding operation in progress. This two states are &lt;strong&gt;importing&lt;/strong&gt; and &lt;strong&gt;migrating&lt;/strong&gt;.</source>
          <target state="translated">ただし、ノードハッシュスロットは、ノードの再起動後（AOF / RDBファイルのキーとノードハッシュスロット構成の不一致）、またはリシャーディング操作が進行中の場合にエラーを通知するために使用される特別な状態になる可能性があります。 。この2つの状態は&lt;strong&gt;インポート&lt;/strong&gt;と&lt;strong&gt;移行&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="74506a394d8d9a9db887f0b3d8806ba4f46848f4" translate="yes" xml:space="preserve">
          <source>However note that with streams this is not a problem: stream entries are not removed from the stream when clients are served, so every client waiting will be served as soon as an &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; command provides data to the stream.</source>
          <target state="translated">ただし、ストリームの場合、これは問題ではないことに注意してください。クライアントにサービスが提供されてもストリームエントリはストリームから削除されないため、&lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt;コマンドがストリームにデータを提供するとすぐに、待機しているすべてのクライアントにサービスが提供されます。</target>
        </trans-unit>
        <trans-unit id="5d5d9fa16c29cdab06e0b69ea5b8063d64e64fa1" translate="yes" xml:space="preserve">
          <source>However note that:</source>
          <target state="translated">しかし、それに注意してください。</target>
        </trans-unit>
        <trans-unit id="c2edee6acbd228e132336d8defe53364f46f07e4" translate="yes" xml:space="preserve">
          <source>However once the data structures are bigger and are promoted to use real hash tables, the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family of commands will resort to the normal behavior. Note that since this special behavior of returning all the elements is true only for small aggregates, it has no effects on the command complexity or latency. However the exact limits to get converted into real hash tables are &lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;user configurable&lt;/a&gt;, so the maximum number of elements you can see returned in a single call depends on how big an aggregate data type could be and still use the packed representation.</source>
          <target state="translated">ただし、データ構造が大きくなり、実際のハッシュテーブルを使用するようにプロモートされると、&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;ファミリーのコマンドは通常の動作に頼ります。すべての要素を返すというこの特別な動作は小さな集合体にのみ当てはまるため、コマンドの複雑さや待ち時間には影響しません。ただし、実際のハッシュテーブルに変換するための正確な制限は&lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;ユーザーが設定&lt;/a&gt;できるため、1回の呼び出しで返される要素の最大数は、集約データ型がどれほど大きくても、パックされた表現を使用できるかによって異なります。</target>
        </trans-unit>
        <trans-unit id="b21c3d5072091035e19308ba188163eb9b4582ee" translate="yes" xml:space="preserve">
          <source>However starting with Redis 2.8.12 or greater, the command accepts the following form:</source>
          <target state="translated">ただし、Redis 2.8.12 以降では、コマンドは以下の形式を受け付けます。</target>
        </trans-unit>
        <trans-unit id="3d9349e56b3bf2d47d692509fd1873664bc86e71" translate="yes" xml:space="preserve">
          <source>However the command cannot simply drop the node from the internal node table of the node receiving the command, it also implements a ban-list, not allowing the same node to be added again as a side effect of processing the &lt;em&gt;gossip section&lt;/em&gt; of the heartbeat packets received from other nodes.</source>
          <target state="translated">ただし、コマンドは、コマンドを受信するノードの内部ノードテーブルからノードを単に削除することはできません。禁止リストも実装しているため、ハートビートパケットの&lt;em&gt;ゴシップセクション&lt;/em&gt;の処理の副作用として同じノードを再度追加することはできません。他のノードから受信した。</target>
        </trans-unit>
        <trans-unit id="77d71597c94f649040209c65345b9adb784d1ada" translate="yes" xml:space="preserve">
          <source>However the number of returned elements is reasonable, that is, in practical terms SCAN may return a maximum number of elements in the order of a few tens of elements when iterating a large collection, or may return all the elements of the collection in a single call when the iterated collection is small enough to be internally represented as an encoded data structure (this happens for small sets, hashes and sorted sets).</source>
          <target state="translated">しかし、返される要素の数は合理的です。現実的には、SCANは大きなコレクションを反復処理する際には、数十個の要素の順番で最大の要素数を返します。また、反復処理されたコレクションが内部的に符号化されたデータ構造として表現されるほど小さい場合には、1回の呼び出しでコレクションのすべての要素を返すかもしれません(これは小さな集合、ハッシュ、ソートされた集合で起こります)。</target>
        </trans-unit>
        <trans-unit id="4a9bd4d796e3f1d19b335cd4b8d1d2f3544974af" translate="yes" xml:space="preserve">
          <source>However the user can apply a transformation to the encoded string so that the first part of the element inserted in the sorted set will compare as the user requires for the specific application. For example if I want to add strings that will be compared in a case-insensitive way, but I still want to retrieve the real case when querying, I can add strings in the following way:</source>
          <target state="translated">しかし、ユーザーはエンコードされた文字列に変換を適用して、ソートされたセットに挿入された要素の最初の部分が、ユーザーが特定のアプリケーションで必要とするように比較されるようにすることができます。例えば、大文字小文字を区別しない方法で比較される文字列を追加したいが、クエリの際には実在の大文字小文字を取得したい場合、次のように文字列を追加することができます。</target>
        </trans-unit>
        <trans-unit id="794f44a2bce77c8dc3d6e6888d73f15fd3089fde" translate="yes" xml:space="preserve">
          <source>However the user is still able to write commands with random behavior using the following simple trick. Imagine I want to write a Redis script that will populate a list with N random integers.</source>
          <target state="translated">しかし、以下の簡単なトリックを使えば、ユーザはランダムな動作をするコマンドを書くことができます。N個の乱数整数でリストを生成するRedisスクリプトを書きたいと想像してみてください。</target>
        </trans-unit>
        <trans-unit id="fb5b52cca56c4cdd87edf1dfc660cd981c3a9505" translate="yes" xml:space="preserve">
          <source>However there is a way for the user to tune the order of magnitude of the number of returned elements per call using the &lt;strong&gt;COUNT&lt;/strong&gt; option.</source>
          <target state="translated">ただし、&lt;strong&gt;COUNT&lt;/strong&gt;オプションを使用して、呼び出しごとに返される要素の数の桁をユーザーが調整する方法があります。</target>
        </trans-unit>
        <trans-unit id="7f8f1c30670b30342c4d809208def1afc1fbfd2c" translate="yes" xml:space="preserve">
          <source>However there is an exception to this rule, and it is when a new cluster is created from scratch. Redis Cluster &lt;em&gt;config epoch collision resolution&lt;/em&gt; algorithm can deal with new nodes all configured with the same configuration at startup, but this process is slow and should be the exception, only to make sure that whatever happens, two more nodes eventually always move away from the state of having the same configuration epoch.</source>
          <target state="translated">ただし、このルールには例外があり、新しいクラスターが最初から作成される場合です。Redisクラスター構成&lt;em&gt;エポック衝突解決&lt;/em&gt;アルゴリズムは、起動時にすべて同じ構成で構成された新しいノードを処理できますが、このプロセスは遅く、例外になるはずです。何が起こっても、最終的に2つのノードが常に状態から離れることを確認するためです。同じ構成エポックを持つこと。</target>
        </trans-unit>
        <trans-unit id="142631746a79e235cfed163ccdfe702d6be0326c" translate="yes" xml:space="preserve">
          <source>However this also means that executing slow scripts is not a good idea. It is not hard to create fast scripts, as the script overhead is very low, but if you are going to use slow scripts you should be aware that while the script is running no other client can execute commands.</source>
          <target state="translated">しかし、これは遅いスクリプトを実行するのは良い考えではないということでもあります。スクリプトのオーバーヘッドは非常に低いので、高速なスクリプトを作成することは難しくありませんが、低速なスクリプトを使用する場合は、スクリプトが実行されている間は他のクライアントがコマンドを実行できないことに注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="0a33083c754611907b7f894af6eb43aadc3e4c17" translate="yes" xml:space="preserve">
          <source>However this is a useful feature since, sometimes, we need to execute certain commands only in the master in order to create, for example, intermediate values.</source>
          <target state="translated">しかし、これは便利な機能です。</target>
        </trans-unit>
        <trans-unit id="d0af8abe6ce309a54e5c3abb2294351b6406b863" translate="yes" xml:space="preserve">
          <source>However this is just a best-effort attempt so it is possible to still lose a write synchronously replicated to multiple replicas.</source>
          <target state="translated">しかし、これはベストエフォートの試みに過ぎないので、複数のレプリカに同期的に複製された書き込みを失う可能性があります。</target>
        </trans-unit>
        <trans-unit id="ddd90e4937b6a5514534f2c76508301017283476" translate="yes" xml:space="preserve">
          <source>However trying to execute it again results into an error since the slots are already assigned:</source>
          <target state="translated">しかし、再度実行しようとすると、スロットが既に割り当てられているため、エラーになります。</target>
        </trans-unit>
        <trans-unit id="8abb1412bd4f6007eadde6067935f55706c8b96f" translate="yes" xml:space="preserve">
          <source>However using &lt;strong&gt;FORCE&lt;/strong&gt; we still need the majority of masters to be available in order to authorize the failover and generate a new configuration epoch for the replica that is going to become master.</source>
          <target state="translated">ただし、&lt;strong&gt;FORCE&lt;/strong&gt;を使用する場合は、フェイルオーバーを承認し、マスターになるレプリカの新しい構成エポックを生成するために、大部分のマスターを使用可能にする必要があります。</target>
        </trans-unit>
        <trans-unit id="c681766630e9b93da85df642b31ac53297dab87b" translate="yes" xml:space="preserve">
          <source>However what is often very useful, is to know the match position in each strings:</source>
          <target state="translated">しかし、多くの場合、非常に便利なのは、各文字列のマッチ位置を知ることです。</target>
        </trans-unit>
        <trans-unit id="f7eb54420a392ba9d9fb195f48555b2f9849c4e4" translate="yes" xml:space="preserve">
          <source>However while blocking commands like &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; are able to provide all the elements that are part of a Set in a given moment, The SCAN family of commands only offer limited guarantees about the returned elements since the collection that we incrementally iterate can change during the iteration process.</source>
          <target state="translated">ただし、&lt;a href=&quot;smembers&quot;&gt;SMEMBERSの&lt;/a&gt;ようなブロッキングコマンドは、特定の瞬間にセットの一部であるすべての要素を提供できますが、SCANファミリのコマンドは、反復処理するコレクションが反復プロセス中に変更される可能性があるため、返された要素について限られた保証しか提供しません。</target>
        </trans-unit>
        <trans-unit id="8368348c7a15aab35b99bad0b61100388ed947ac" translate="yes" xml:space="preserve">
          <source>However while the replicas connected to a master will not expire keys independently (but will wait for the &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; coming from the master), they'll still take the full state of the expires existing in the dataset, so when a replica is elected to master it will be able to expire the keys independently, fully acting as a master.</source>
          <target state="translated">ただし、マスターに接続されたレプリカはキーを個別に期限切れにすることはありませんが（マスターからの&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;を待機します）、データセット内に存在する期限切れの完全な状態を取るため、レプリカがマスターに選択されます。キーを個別に期限切れにすることができ、完全にマスターとして機能します。</target>
        </trans-unit>
        <trans-unit id="e7564bd1b123b79267215f60720a7ba2c7d0f2a4" translate="yes" xml:space="preserve">
          <source>However, note that:</source>
          <target state="translated">ただし、その点には注意してください。</target>
        </trans-unit>
        <trans-unit id="ae8b2a13bc4ae56dbd4d97a2490048eefaa8824d" translate="yes" xml:space="preserve">
          <source>However, this behavior changes if you are looking for clear bits and specify a range with both &lt;strong&gt;start&lt;/strong&gt; and &lt;strong&gt;end&lt;/strong&gt;. If no clear bit is found in the specified range, the function returns -1 as the user specified a clear range and there are no 0 bits in that range.</source>
          <target state="translated">ただし、クリアビットを探して&lt;strong&gt;start&lt;/strong&gt;と&lt;strong&gt;endの&lt;/strong&gt;両方で範囲を指定すると、この動作は変わります。指定された範囲にクリアビットが見つからない場合、ユーザーがクリア範囲を指定し、その範囲に0ビットがないため、関数は-1を返します。</target>
        </trans-unit>
        <trans-unit id="078d1434700af53deba94cb889757980e4b68051" translate="yes" xml:space="preserve">
          <source>Humans may use this command in order to check what is the hash slot, and then the associated Redis Cluster node, responsible for a given key.</source>
          <target state="translated">人間は、ハッシュスロットが何であるかを確認するために、このコマンドを使用することができ、その後、関連するRedisクラスタノードは、与えられたキーに責任があります。</target>
        </trans-unit>
        <trans-unit id="d68bb5655889a7436b2eff6315d03293170f63d0" translate="yes" xml:space="preserve">
          <source>HyperLogLog</source>
          <target state="translated">HyperLogLog</target>
        </trans-unit>
        <trans-unit id="58b5c100f0d44808f0dbfcc3722f78c2d81f1aaf" translate="yes" xml:space="preserve">
          <source>HyperLogLog representation</source>
          <target state="translated">ハイパーログログ表現</target>
        </trans-unit>
        <trans-unit id="28c10e9d5a5781ed8d9e57c706ceb5a1dd97ff5f" translate="yes" xml:space="preserve">
          <source>I can start with this small Ruby program:</source>
          <target state="translated">この小さなRubyのプログラムから始められます。</target>
        </trans-unit>
        <trans-unit id="5188851d79e499077ff8c17718081d6a2d5d7980" translate="yes" xml:space="preserve">
          <source>IDs are guaranteed to be always incremental: If you compare the ID of the entry just inserted it will be greater than any other past ID, so entries are totally ordered inside a stream. In order to guarantee this property, if the current top ID in the stream has a time greater than the current local time of the instance, the top entry time will be used instead, and the sequence part of the ID incremented. This may happen when, for instance, the local clock jumps backward, or if after a failover the new master has a different absolute time.</source>
          <target state="translated">ID は常にインクリメンタルであることが保証されています:挿入されたばかりのエントリの ID を比較すると、それは他の過去のどの ID よりも大きくなりますので、エントリはストリーム内で完全に順序付けられます。この特性を保証するために、ストリーム内の現在の先頭のIDの時刻がインスタンスの現在のローカル時刻よりも大きい場合、代わりに先頭のエントリの時刻が使用され、IDのシーケンス部分がインクリメントされます。これは、例えば、ローカルクロックが後方にジャンプした場合や、フェイルオーバー後に新しいマスターが異なる絶対時刻を持っている場合などに発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="c0f8745b1bebe7ddae3a87f4efc1207e5b87a40b" translate="yes" xml:space="preserve">
          <source>IDs are specified by two numbers separated by a &lt;code&gt;-&lt;/code&gt; character:</source>
          <target state="translated">IDは、 &lt;code&gt;-&lt;/code&gt; 文字で区切られた2つの数字で指定されます。</target>
        </trans-unit>
        <trans-unit id="70aab9650acd50b2b8e1776f69b86b88bbbe99e5" translate="yes" xml:space="preserve">
          <source>INCR</source>
          <target state="translated">INCR</target>
        </trans-unit>
        <trans-unit id="c59620ba3e9207aaf8fb1bf70e412a9caa358cb2" translate="yes" xml:space="preserve">
          <source>INCR  key   Increment the integer value of a key by one</source>
          <target state="translated">INCR key キーの整数値を 1 つインクリメントします。</target>
        </trans-unit>
        <trans-unit id="af14b6096425a1f909b7628ce8491716c2d581ba" translate="yes" xml:space="preserve">
          <source>INCRBY</source>
          <target state="translated">INCRBY</target>
        </trans-unit>
        <trans-unit id="9ab1bc6a3a0563b50a9e4bcb930106db12e2ae4e" translate="yes" xml:space="preserve">
          <source>INCRBY  key increment   Increment the integer value of a key by the given amount</source>
          <target state="translated">INCRBY key incrementment キーの整数値を指定した量だけ増加させます。</target>
        </trans-unit>
        <trans-unit id="769650b0192d046cb68b526ab27d41d927ea5cc8" translate="yes" xml:space="preserve">
          <source>INCRBYFLOAT</source>
          <target state="translated">INCRBYFLOAT</target>
        </trans-unit>
        <trans-unit id="2e3bba4aaf8bd64291b4999ea2633e1cde536fe3" translate="yes" xml:space="preserve">
          <source>INCRBYFLOAT  key increment   Increment the float value of a key by the given amount</source>
          <target state="translated">INCRBYFLOAT key incrementment キーの float 値を指定した量だけ増加させます。</target>
        </trans-unit>
        <trans-unit id="9c9cf999829193894067bbd9e1484756ab736ac0" translate="yes" xml:space="preserve">
          <source>INFO</source>
          <target state="translated">INFO</target>
        </trans-unit>
        <trans-unit id="42089cfb2067d721afeae473b5079898e863248e" translate="yes" xml:space="preserve">
          <source>INFO  [section]   Get information and statistics about the server</source>
          <target state="translated">INFO [セクション]サーバーに関する情報や統計情報を取得します。</target>
        </trans-unit>
        <trans-unit id="fc967bd2cc1b3485f1ee6c3bccb3832c0009ded5" translate="yes" xml:space="preserve">
          <source>Ideally, the &lt;code&gt;used_memory_rss&lt;/code&gt; value should be only slightly higher than &lt;code&gt;used_memory&lt;/code&gt;. When rss &amp;gt;&amp;gt; used, a large difference means there is memory fragmentation (internal or external), which can be evaluated by checking &lt;code&gt;mem_fragmentation_ratio&lt;/code&gt;. When used &amp;gt;&amp;gt; rss, it means part of Redis memory has been swapped off by the operating system: expect some significant latencies.</source>
          <target state="translated">理想的には、 &lt;code&gt;used_memory_rss&lt;/code&gt; の値は、used_memoryよりもわずかに高くなければなりませ &lt;code&gt;used_memory&lt;/code&gt; 。rss &amp;gt;&amp;gt;を使用する場合、大きな違いはメモリの断片化（内部または外部）が存在することを意味し、 &lt;code&gt;mem_fragmentation_ratio&lt;/code&gt; を確認することで評価できます。&amp;gt;&amp;gt; rssを使用すると、Redisメモリの一部がオペレーティングシステムによってスワップオフされたことを意味します。かなりのレイテンシが予想されます。</target>
        </trans-unit>
        <trans-unit id="73b4eda93b2219c5cea27cedcc70f71581e15c99" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; fails, no data gets lost as the old AOF will be untouched.</source>
          <target state="translated">場合&lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOFが&lt;/a&gt;失敗した古いAOFがそのままであるように、データは失われません取得します。</target>
        </trans-unit>
        <trans-unit id="1d20f361447b1eebe4e4808ffc994e347a4065d3" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; returns &lt;code&gt;0&lt;/code&gt; the key is already locked by some other client. We can either return to the caller if it's a non blocking lock, or enter a loop retrying to hold the lock until we succeed or some kind of timeout expires.</source>
          <target state="translated">&lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;が &lt;code&gt;0&lt;/code&gt; を返す場合、キーは他のクライアントによってすでにロックされています。非ブロッキングロックの場合は呼び出し元に戻るか、ループに入ると、成功するか、ある種のタイムアウトが発生するまでロックの保持を再試行できます。</target>
        </trans-unit>
        <trans-unit id="b2860996021d578f69065139684f5cafa8d2519b" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; returns &lt;code&gt;1&lt;/code&gt; the client acquired the lock, setting the &lt;code&gt;lock.foo&lt;/code&gt; key to the Unix time at which the lock should no longer be considered valid. The client will later use &lt;code&gt;DEL lock.foo&lt;/code&gt; in order to release the lock.</source>
          <target state="translated">&lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;が &lt;code&gt;1&lt;/code&gt; を返す場合、クライアントはロックを取得し、 &lt;code&gt;lock.foo&lt;/code&gt; キーを、ロックが有効であると見なされなくなったUnix時間に設定します。クライアントは後でロックを解放するために &lt;code&gt;DEL lock.foo&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="a5eee6810815d94e86b03260de66be0feb7ce88c" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;watch&quot;&gt;WATCH&lt;/a&gt; was used, &lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt; unwatches all keys watched by the connection.</source>
          <target state="translated">&lt;a href=&quot;watch&quot;&gt;WATCH&lt;/a&gt;が使用された場合、&lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt;は接続によって監視されているすべてのキーの監視を解除します。</target>
        </trans-unit>
        <trans-unit id="db30f622717bd53f660e926c446f65281d373325" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BGSAVE SCHEDULE&lt;/code&gt; is used, the command will immediately return &lt;code&gt;OK&lt;/code&gt; when an AOF rewrite is in progress and schedule the background save to run at the next opportunity.</source>
          <target state="translated">場合 &lt;code&gt;BGSAVE SCHEDULE&lt;/code&gt; 使用され、コマンドはすぐに戻ります &lt;code&gt;OK&lt;/code&gt; をAOF書き換えが進行中であるときに、背景は次の機会に実行するようにスケジュールセーブ。</target>
        </trans-unit>
        <trans-unit id="20ed44b2bda4227d511c46587683f47a00d993b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WITHCOORD&lt;/code&gt;, &lt;code&gt;WITHDIST&lt;/code&gt; or &lt;code&gt;WITHHASH&lt;/code&gt; options are specified, the command returns an array of arrays, where each sub-array represents a single item.</source>
          <target state="translated">場合 &lt;code&gt;WITHCOORD&lt;/code&gt; 、 &lt;code&gt;WITHDIST&lt;/code&gt; 又は &lt;code&gt;WITHHASH&lt;/code&gt; オプションが指定され、コマンドは、各サブアレイは、単一のアイテムを表す配列の配列を返します。</target>
        </trans-unit>
        <trans-unit id="73dfe5f15062ceece61a6acc3449e57743eeff88" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;destination&lt;/code&gt; already exists, it is overwritten.</source>
          <target state="translated">&lt;code&gt;destination&lt;/code&gt; すでに存在する場合は、上書きされます。</target>
        </trans-unit>
        <trans-unit id="ec00a71247f51a83461ff727be4fdc2a9b8eef53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; already exists and is a string, this command appends the &lt;code&gt;value&lt;/code&gt; at the end of the string. If &lt;code&gt;key&lt;/code&gt; does not exist it is created and set as an empty string, so &lt;a href=&quot;append&quot;&gt;APPEND&lt;/a&gt; will be similar to &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; in this special case.</source>
          <target state="translated">場合は &lt;code&gt;key&lt;/code&gt; すでに存在し、文字列で、このコマンドが追加され &lt;code&gt;value&lt;/code&gt; 文字列の末尾。場合は &lt;code&gt;key&lt;/code&gt; 存在しないので、それは、空の文字列として作成し、セットされた&lt;a href=&quot;append&quot;&gt;APPENDは&lt;/a&gt;のようになります。&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;この特殊なケースインチ</target>
        </trans-unit>
        <trans-unit id="f65de86e658742c07d7bc6102da39df199a9b701" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist a nil bulk reply is returned.</source>
          <target state="translated">場合は &lt;code&gt;key&lt;/code&gt; 存在しない場合はnilバルク応答が返されます。</target>
        </trans-unit>
        <trans-unit id="bd4417fe5a7c2042f71015b09d46b92838be30fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, a new sorted set with the specified members as sole members is created, like if the sorted set was empty. If the key exists but does not hold a sorted set, an error is returned.</source>
          <target state="translated">場合は &lt;code&gt;key&lt;/code&gt; 存在しないソートセットが空であるかのように、唯一のメンバーとして指定されたメンバーを持つ新しいソートセットは、作成されます。キーは存在するが、ソートされたセットを保持していない場合は、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="e64662be889ce64c17aaa1cc9189ce3256310f93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; does not exist in the sorted set or &lt;code&gt;key&lt;/code&gt; does not exist, &lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;member&lt;/code&gt; ソートセットかに存在しない &lt;code&gt;key&lt;/code&gt; 、存在しない&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;バルクの文字列の返信&lt;/a&gt;： &lt;code&gt;nil&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="f23ea3c8266e3f5959aed27b93602e9cafb796f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; does not exist in the sorted set, or &lt;code&gt;key&lt;/code&gt; does not exist, &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">場合 &lt;code&gt;member&lt;/code&gt; ソートセットに存在しない場合、または &lt;code&gt;key&lt;/code&gt; 存在しない場合、 &lt;code&gt;nil&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="1e3e9eec1dfb85dde46f12f033df8c95cb570dc1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; exists in the sorted set, &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the rank of &lt;code&gt;member&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;member&lt;/code&gt; がソートされたセットに存在する場合、&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;整数応答&lt;/a&gt;： &lt;code&gt;member&lt;/code&gt; のランク。</target>
        </trans-unit>
        <trans-unit id="b0602d8252b35c86b3177857f428ef2b6ebe2844" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;password&lt;/code&gt; matches the password in the configuration file, the server replies with the &lt;code&gt;OK&lt;/code&gt; status code and starts accepting commands. Otherwise, an error is returned and the clients needs to try a new password.</source>
          <target state="translated">パスワードが構成ファイルの &lt;code&gt;password&lt;/code&gt; 一致する場合、サーバーは &lt;code&gt;OK&lt;/code&gt; ステータスコードで応答し、コマンドの受け入れを開始します。そうでない場合、エラーが返され、クライアントは新しいパスワードを試す必要があります。</target>
        </trans-unit>
        <trans-unit id="25efaee0f3cfe5471248ed210126224686506e29" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; does not exist, the value &lt;code&gt;nil&lt;/code&gt; is returned and no operation is performed. If &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; are the same, the operation is equivalent to removing the first/last element from the list and pushing it as first/last element of the list, so it can be considered as a list rotation command (or a no-op if &lt;code&gt;wherefrom&lt;/code&gt; is the same as &lt;code&gt;whereto&lt;/code&gt;).</source>
          <target state="translated">場合 &lt;code&gt;source&lt;/code&gt; 存在しない場合、値 &lt;code&gt;nil&lt;/code&gt; 返され、何も動作は行われません。場合は &lt;code&gt;source&lt;/code&gt; と &lt;code&gt;destination&lt;/code&gt; 同じであり、それはリスト回転指令（又はノー・オペレーションとみなすことができるので、動作は、リストから最初/最後の要素を除去し、リストの最初/最後の要素としてそれを押すと等価ですあれば &lt;code&gt;wherefrom&lt;/code&gt; 同じである &lt;code&gt;whereto&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d8a36f67086d264992352bae73959a976d08f592" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; does not exist, the value &lt;code&gt;nil&lt;/code&gt; is returned and no operation is performed. If &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; are the same, the operation is equivalent to removing the last element from the list and pushing it as first element of the list, so it can be considered as a list rotation command.</source>
          <target state="translated">場合 &lt;code&gt;source&lt;/code&gt; 存在しない場合、値 &lt;code&gt;nil&lt;/code&gt; 返され、何も動作は行われません。場合は &lt;code&gt;source&lt;/code&gt; と &lt;code&gt;destination&lt;/code&gt; 同じであり、動作は、リストから最後の要素を除去し、リストの最初の要素としてそれを押すと同等であるので、リスト回転指令とみなすことができます。</target>
        </trans-unit>
        <trans-unit id="5b26bcfdadbb106d42a10a68f68adf4977b43380" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ttl&lt;/code&gt; is 0 the key is created without any expire, otherwise the specified expire time (in milliseconds) is set.</source>
          <target state="translated">&lt;code&gt;ttl&lt;/code&gt; が0の場合、キーは有効期限なしで作成されます。それ以外の場合、指定された有効期限（ミリ秒単位）が設定されます。</target>
        </trans-unit>
        <trans-unit id="2c1e9f5fc6b657f9746f093601d0e06e3be8a993" translate="yes" xml:space="preserve">
          <source>If AOF is activated, these additional fields will be added:</source>
          <target state="translated">AOFを有効にすると、これらのフィールドが追加されます。</target>
        </trans-unit>
        <trans-unit id="3a074c9af49d118ca170e19c962a9318fe91cfe4" translate="yes" xml:space="preserve">
          <source>If a Redis 6.0 instance, or greater, is using the &lt;a href=&quot;https://redis.io/topics/acl&quot;&gt;Redis ACL system&lt;/a&gt;.</source>
          <target state="translated">Redis6.0以降のインスタンスが&lt;a href=&quot;https://redis.io/topics/acl&quot;&gt;RedisACLシステム&lt;/a&gt;を使用している場合。</target>
        </trans-unit>
        <trans-unit id="52fb5f5179b2d79edc8c3b551f845f186e716372" translate="yes" xml:space="preserve">
          <source>If a Redis child is creating a snapshot on disk, the AOF rewrite is &lt;em&gt;scheduled&lt;/em&gt; but not started until the saving child producing the RDB file terminates. In this case the &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; will still return an OK code, but with an appropriate message. You can check if an AOF rewrite is scheduled looking at the &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command as of Redis 2.6.</source>
          <target state="translated">Redisの子がディスク上にスナップショットを作成している場合、AOFの書き換えが&lt;em&gt;スケジュールされます&lt;/em&gt;が、RDBファイルを生成する保存中の子が終了するまで開始されません。この場合、&lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt;はOKコードを返しますが、適切なメッセージが表示されます。Redis 2.6の時点で、&lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;コマンドを見て、AOFの書き換えがスケジュールされているかどうかを確認できます。</target>
        </trans-unit>
        <trans-unit id="a26aac34716b82962d62dd7eb321e26db471b019" translate="yes" xml:space="preserve">
          <source>If a Redis child is creating a snapshot on disk, the AOF rewrite is &lt;em&gt;scheduled&lt;/em&gt; but not started until the saving child producing the RDB file terminates. In this case the &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; will still return an positive status reply, but with an appropriate message. You can check if an AOF rewrite is scheduled looking at the &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command as of Redis 2.6 or successive versions.</source>
          <target state="translated">Redisの子がディスク上にスナップショットを作成している場合、AOFの書き換えは&lt;em&gt;スケジュールされます&lt;/em&gt;が、RDBファイルを生成している保存中の子が終了するまで開始されません。この場合、&lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt;は引き続き肯定的なステータス応答を返しますが、適切なメッセージが表示されます。Redis 2.6以降のバージョンの&lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;コマンドを参照して、AOFの書き換えがスケジュールされているかどうかを確認できます。</target>
        </trans-unit>
        <trans-unit id="7fab76e64c7a99cf5ff09d3faf8bcf4e7b29c3b9" translate="yes" xml:space="preserve">
          <source>If a Redis server is already acting as replica, the command &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; NO ONE will turn off the replication, turning the Redis server into a MASTER. In the proper form &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; hostname port will make the server a replica of another server listening at the specified hostname and port.</source>
          <target state="translated">Redisサーバーがすでにレプリカとして機能している場合、&lt;a href=&quot;replicaof&quot;&gt;REPLICOF&lt;/a&gt; NO ONE コマンドはレプリケーションをオフにして、Redisサーバーをマスターにします。適切な形式の&lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt;ホスト名ポートは、サーバーを、指定されたホスト名とポートでリッスンする別のサーバーのレプリカにします。</target>
        </trans-unit>
        <trans-unit id="6bba5cc9a8544de84799044ff9489eaddadc2beb" translate="yes" xml:space="preserve">
          <source>If a SYNC operation is on-going, these additional fields are provided:</source>
          <target state="translated">SYNC 操作が進行中の場合、これらの追加フィールドが提供されます。</target>
        </trans-unit>
        <trans-unit id="b39dab88e7088d47355746e00cd5a3b16aea36b7" translate="yes" xml:space="preserve">
          <source>If a cluster instance has non-contiguous slots (e.g. 1-400,900,1800-6000) then master and replica IP/Port results will be duplicated for each top-level slot range reply.</source>
          <target state="translated">クラスタインスタンスが連続しないスロット(例:1-400,900,1800-6000)を持っている場合、マスターとレプリカのIP/ポートの結果は、各トップレベルのスロット範囲の応答に対して重複します。</target>
        </trans-unit>
        <trans-unit id="59220272c64271f85f1f97cc7691835ad64c2de3" translate="yes" xml:space="preserve">
          <source>If a command accepts an unlimited number of keys, the last key position is -1.</source>
          <target state="translated">コマンドが無制限の数のキーを受け付ける場合、最後のキー位置は-1となります。</target>
        </trans-unit>
        <trans-unit id="140a2742270e0d194dfebacb6a9c7a4820592aff" translate="yes" xml:space="preserve">
          <source>If a command accepts one key, the first key and last key positions is 1.</source>
          <target state="translated">コマンドが1つのキーを受け付ける場合、最初のキーと最後のキーの位置は1になります。</target>
        </trans-unit>
        <trans-unit id="c31655fb4face26cd02e88dd6486f34dd31bb51e" translate="yes" xml:space="preserve">
          <source>If a command accepts two keys (e.g. &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt;, &lt;a href=&quot;smove&quot;&gt;SMOVE&lt;/a&gt;, &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;, ...) then the last key position is the location of the last key in the argument list.</source>
          <target state="translated">コマンドが2つのキー（例：&lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt;、&lt;a href=&quot;smove&quot;&gt;SMOVE&lt;/a&gt;、&lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;、...）を受け入れる場合、最後のキーの位置は、引数リスト内の最後のキーの位置です。</target>
        </trans-unit>
        <trans-unit id="610d9883b3ed9e5bbf61e781dfb38f2ca5532e85" translate="yes" xml:space="preserve">
          <source>If a command is received about a key that does not exists, an &lt;code&gt;ASK&lt;/code&gt; redirection is emitted by the node, asking the client to retry only that specific query into &lt;code&gt;destination-node&lt;/code&gt;. In this case the client should not update its hash slot to node mapping.</source>
          <target state="translated">存在しないキーに関するコマンドが受信されると、ノードによって &lt;code&gt;ASK&lt;/code&gt; リダイレクションが発行され、特定のクエリのみを &lt;code&gt;destination-node&lt;/code&gt; に再試行するようクライアントに要求します。この場合、クライアントはハッシュスロットをノードマッピングに更新しないでください。</target>
        </trans-unit>
        <trans-unit id="adc3a75aac4d6b35ed7b12ce05235e4cc640c05b" translate="yes" xml:space="preserve">
          <source>If a command is received about an existing key, the command is processed as usually.</source>
          <target state="translated">既存のキーに関するコマンドを受信した場合は、通常通り処理されます。</target>
        </trans-unit>
        <trans-unit id="a64d2ec3bb10e34eb579070274923657d7138a2a" translate="yes" xml:space="preserve">
          <source>If a key is overwritten by &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;, like in the case of an existing key &lt;code&gt;Key_A&lt;/code&gt; that is overwritten by a call like &lt;code&gt;RENAME Key_B Key_A&lt;/code&gt;, it does not matter if the original &lt;code&gt;Key_A&lt;/code&gt; had a timeout associated or not, the new key &lt;code&gt;Key_A&lt;/code&gt; will inherit all the characteristics of &lt;code&gt;Key_B&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RENAME Key_B Key_A&lt;/code&gt; のような呼び出しによって上書きされる既存のキー &lt;code&gt;Key_A&lt;/code&gt; の場合のように、キーが&lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;によって上書きされる場合、元の &lt;code&gt;Key_A&lt;/code&gt; にタイムアウトが関連付けられているかどうかに関係なく、新しいキー &lt;code&gt;Key_A&lt;/code&gt; はすべて継承します &lt;code&gt;Key_B&lt;/code&gt; の特性。</target>
        </trans-unit>
        <trans-unit id="0360f4a1e3e37b28bbc1c81856843472bd113d44" translate="yes" xml:space="preserve">
          <source>If a key is renamed with &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;, the associated time to live is transferred to the new key name.</source>
          <target state="translated">キーの名前が&lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;に変更された場合、関連付けられた存続時間が新しいキー名に転送されます。</target>
        </trans-unit>
        <trans-unit id="dba073505eef52f13e35c2d2b072e15bc497f1c3" translate="yes" xml:space="preserve">
          <source>If a load operation is on-going, these additional fields will be added:</source>
          <target state="translated">負荷操作が進行中の場合、これらの追加フィールドが追加されます。</target>
        </trans-unit>
        <trans-unit id="a8036cb18b462f0b09c70d787c53e11501cfbc97" translate="yes" xml:space="preserve">
          <source>If a node with unbound hash slots receives a heartbeat packet from another node that claims to be the owner of some of those hash slots, the association is established instantly. Moreover, if a heartbeat or update message is received with a configuration epoch greater than the node's own, the association is re-established.</source>
          <target state="translated">束縛されていないハッシュスロットを持つノードが、そのハッシュスロットの一部の所有者であると主張する別のノードからハートビートパケットを受信した場合、その関連付けは即座に確立されます。さらに、ハートビートまたは更新メッセージが、ノード自身の設定エポックよりも大きい設定エポックで受信された場合、アソシエーションは再確立されます。</target>
        </trans-unit>
        <trans-unit id="e6947348d36ca3b7d6ec64b0d3d493bff74f2cca" translate="yes" xml:space="preserve">
          <source>If a server is already a replica of some master, &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; hostname port will stop the replication against the old server and start the synchronization against the new one, discarding the old dataset.</source>
          <target state="translated">サーバーがすでにマスターのレプリカである場合、&lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt;ホスト名ポートは古いサーバーに対するレプリケーションを停止し、新しいサーバーに対する同期を開始して、古いデータセットを破棄します。</target>
        </trans-unit>
        <trans-unit id="8355cef42438c57bf29e119daff3edf69a2eafac" translate="yes" xml:space="preserve">
          <source>If a server is already a replica of some master, &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; hostname port will stop the replication against the old server and start the synchronization against the new one, discarding the old dataset.</source>
          <target state="translated">サーバーがすでにマスターのレプリカである場合、&lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt;ホスト名ポートは古いサーバーに対するレプリケーションを停止し、新しいサーバーに対する同期を開始して、古いデータセットを破棄します。</target>
        </trans-unit>
        <trans-unit id="796f8c82d2cb3bc6674d519060d62df76a47b5cf" translate="yes" xml:space="preserve">
          <source>If an AOF rewrite is already in progress the command returns an error and no AOF rewrite will be scheduled for a later time.</source>
          <target state="translated">AOFの書き換えが既に進行中の場合はエラーを返し、後から書き換えは行われません。</target>
        </trans-unit>
        <trans-unit id="aa95f2ff011f2ee3af55365c22aa9caf33f28db8" translate="yes" xml:space="preserve">
          <source>If an option already exists in the old redis.conf file, it will be rewritten at the same position (line number).</source>
          <target state="translated">古いredis.confファイルに既にオプションが存在する場合は、同じ位置(行番号)に書き換えられます。</target>
        </trans-unit>
        <trans-unit id="4658daabd5c918d6c9d2de1223a7f5eb6d9fd842" translate="yes" xml:space="preserve">
          <source>If an option was not already present, but it is set to a non-default value, it is appended at the end of the file.</source>
          <target state="translated">オプシ ョ ンが既に存在していないが、 それがデ フ ォル ト 以外の値に設定 さ れてい る 場合は、 それがフ ァ イ ルの末尾に追加 さ れます。</target>
        </trans-unit>
        <trans-unit id="e4228aca6b611c430e003ee894c91eb30a1b6cd7" translate="yes" xml:space="preserve">
          <source>If an option was not already present, but it is set to its default value, it is not added by the rewrite process.</source>
          <target state="translated">既に存在していないオプションがデフォルト値に設定されている場合は、書き換え処理では追加されません。</target>
        </trans-unit>
        <trans-unit id="b63f671253761bdf3174af266654497deb63ef4b" translate="yes" xml:space="preserve">
          <source>If another client, for instance C5, was faster than C4 and acquired the lock with the &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; operation, the C4 &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; operation will return a non expired timestamp. C4 will simply restart from the first step. Note that even if C4 set the key a bit a few seconds in the future this is not a problem.</source>
          <target state="translated">別のクライアント（C5など）がC4より高速で、&lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt;操作でロックを取得した場合、C4 &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt;操作は期限切れでないタイムスタンプを返します。C4は最初のステップから再起動します。C4が数秒後にキーを少し設定しても、これは問題ではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="37cf40db32d54ae3579f3237037ff5c92145f193" translate="yes" xml:space="preserve">
          <source>If at a given time a node has another node flagged with &lt;code&gt;PFAIL&lt;/code&gt;, and at the same time collected the majority of other master nodes &lt;em&gt;failure reports&lt;/em&gt; about this node (including itself if it is a master), then it elevates the failure state of the node from &lt;code&gt;PFAIL&lt;/code&gt; to &lt;code&gt;FAIL&lt;/code&gt;, and broadcasts a message forcing all the nodes that can be reached to flag the node as &lt;code&gt;FAIL&lt;/code&gt;.</source>
          <target state="translated">ある時点で、ノードに &lt;code&gt;PFAIL&lt;/code&gt; のフラグが立てられた別のノードがあり、同時にこのノードに関する他のマスターノード&lt;em&gt;障害レポートの&lt;/em&gt;大部分（マスターの場合はそれ自体を含む）を収集すると、ノードの障害状態が上昇します。 &lt;code&gt;PFAIL&lt;/code&gt; から &lt;code&gt;FAIL&lt;/code&gt; にメッセージをブロードキャストし、到達可能なすべてのノードにノードに &lt;code&gt;FAIL&lt;/code&gt; のフラグを付けるように強制します。</target>
        </trans-unit>
        <trans-unit id="5f5470ee8997d2330c4f1d3cb52035e4a73f57ce" translate="yes" xml:space="preserve">
          <source>If count is bigger than the number of elements inside the Set, the command will only return the whole set without additional elements.</source>
          <target state="translated">countがセット内の要素数よりも大きい場合、このコマンドは追加の要素を含まないセット全体を返します。</target>
        </trans-unit>
        <trans-unit id="b7b84ded8883c2f1d689aced4377969210247451" translate="yes" xml:space="preserve">
          <source>If every line in the file is valid, all the ACLs are loaded.</source>
          <target state="translated">ファイル内のすべての行が有効な場合、すべての ACL がロードされます。</target>
        </trans-unit>
        <trans-unit id="7166a4c2e9e0a7b189fdf30ab0234c6d47986ab4" translate="yes" xml:space="preserve">
          <source>If instead the message was already delivered to this consumer, and it is just re-fetching the same message again, then the &lt;em&gt;last delivery counter&lt;/em&gt; is updated to the current time, and the &lt;em&gt;number of deliveries&lt;/em&gt; is incremented by one. You can access those message properties using the &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command.</source>
          <target state="translated">代わりに、メッセージがすでにこのコンシューマに配信されていて、同じメッセージを再度フェッチしているだけの場合、&lt;em&gt;最後の配信カウンタ&lt;/em&gt;が現在の時刻に更新され、&lt;em&gt;配信数が&lt;/em&gt; 1つ増えます。&lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt;コマンドを使用して、これらのメッセージプロパティにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="5eb7b53c8c56d77ba922276fcf8d6fc9a5555deb" translate="yes" xml:space="preserve">
          <source>If instead you want consumers to fetch the whole stream history, use zero as the starting ID for the consumer group:</source>
          <target state="translated">代わりに、コンシューマがストリームの履歴全体を取得したい場合は、コンシューマグループの開始IDとしてゼロを使用します。</target>
        </trans-unit>
        <trans-unit id="766551fe9e9ea8009a726c50e78e04cbf000fc57" translate="yes" xml:space="preserve">
          <source>If more than 25% of keys were expired, start again from step 1.</source>
          <target state="translated">鍵の有効期限が25%以上切れていた場合は、手順1からやり直してください。</target>
        </trans-unit>
        <trans-unit id="18ba579c412c6a80f5484abbbc6da80390ec5935" translate="yes" xml:space="preserve">
          <source>If multiple clients are blocked for the same key, the first client to be served is the one that was waiting for more time (the first that blocked for the key). Once a client is unblocked it does not retain any priority, when it blocks again with the next call to &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; it will be served accordingly to the number of clients already blocked for the same key, that will all be served before it (from the first to the last that blocked).</source>
          <target state="translated">同じキーに対して複数のクライアントがブロックされている場合、サービスを受ける最初のクライアントは、より長い時間待っていたクライアントです（キーに対して最初にブロックされたクライアント）。クライアントがブロック解除されると、クライアントは優先度を保持せず、&lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt;への次の呼び出しで再びブロックすると、同じキーに対してすでにブロックされているクライアントの数に応じてサービスが提供されます。最後にブロックされた）。</target>
        </trans-unit>
        <trans-unit id="2d45448e42846cf1223f90529d7153a4f2ea7d57" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;pattern&lt;/code&gt; is specified, all the channels are listed, otherwise if pattern is specified only channels matching the specified glob-style pattern are listed.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; が指定されていない場合、すべてのチャネルがリストされます。それ以外の場合、パターンが指定されている場合、指定されたグロブスタイルのパターンに一致するチャネルのみがリストされます。</target>
        </trans-unit>
        <trans-unit id="ea2697ae6fd039b4a66dbcb2f98b8550bd0df116" translate="yes" xml:space="preserve">
          <source>If no reset type is specified, the default is &lt;strong&gt;soft&lt;/strong&gt;.</source>
          <target state="translated">リセットタイプが指定されていない場合、デフォルトは&lt;strong&gt;soft&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="7a5e1cf1e0228d3ddab066d68bd268b73f915f6a" translate="yes" xml:space="preserve">
          <source>If none of the specified keys exist, &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; blocks the connection until another client performs an &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; or &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt; operation against one of the keys.</source>
          <target state="translated">指定されたキーが存在しない場合、&lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt;は、別のクライアントが&lt;a href=&quot;lpush&quot;&gt;いずれ&lt;/a&gt;かのキーに対してLPUSHまたは&lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;操作を実行するまで接続をブロックします。</target>
        </trans-unit>
        <trans-unit id="dfae9157f2f024976d442ab776949fdf1b2e1598" translate="yes" xml:space="preserve">
          <source>If one or both the members are missing, the command returns NULL.</source>
          <target state="translated">片方または両方のメンバが欠落している場合、コマンドは NULL を返します。</target>
        </trans-unit>
        <trans-unit id="65c7882ecd3026e90538dbca3412ed2c9efa54bf" translate="yes" xml:space="preserve">
          <source>If one or more line in the file is not valid, nothing is loaded, and the old ACL rules defined in the server memory continue to be used.</source>
          <target state="translated">ファイル内の1行以上が有効でない場合、何もロードされず、サーバメモリに定義されている古いACLルールが引き続き使用されます。</target>
        </trans-unit>
        <trans-unit id="4eccea0e4c99dbf5582f258e7eec112ee8e36e5c" translate="yes" xml:space="preserve">
          <source>If persistence is enabled this commands makes sure that Redis is switched off without the lost of any data. This is not guaranteed if the client uses simply &lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt; and then &lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; because other clients may alter the DB data between the two commands.</source>
          <target state="translated">永続化が有効になっている場合、このコマンドにより、データを失うことなくRedisが確実にオフになります。他のクライアントが2つのコマンド間でDBデータを変更する可能性があるため、クライアントが単に&lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt;を使用してから&lt;a href=&quot;quit&quot;&gt;QUITを&lt;/a&gt;使用する場合、これは保証されません。</target>
        </trans-unit>
        <trans-unit id="3c4893d742c042232e8b2da1b66fa8109b95fc06" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; option is specified, the return value will be &lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;:</source>
          <target state="translated">場合&lt;a href=&quot;incr&quot;&gt;INCRの&lt;/a&gt;オプションが指定され、戻り値は次のようになります&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;バルクの文字列の返信&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="5342c7f917832f9f61b997cae89d595cc203017d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ABSTTL&lt;/code&gt; modifier was used, &lt;code&gt;ttl&lt;/code&gt; should represent an absolute &lt;a href=&quot;http://en.wikipedia.org/wiki/Unix_time&quot;&gt;Unix timestamp&lt;/a&gt; (in milliseconds) in which the key will expire. (Redis 5.0 or greater).</source>
          <target state="translated">&lt;code&gt;ABSTTL&lt;/code&gt; 修飾子が使用された場合、 &lt;code&gt;ttl&lt;/code&gt; は、キーが期限切れになる絶対&lt;a href=&quot;http://en.wikipedia.org/wiki/Unix_time&quot;&gt;Unixタイムスタンプ&lt;/a&gt;（ミリ秒単位）を表す必要があります。（Redis 5.0以降）。</target>
        </trans-unit>
        <trans-unit id="48c94188363158a9ff98bf015f1ddfb2076ba94d" translate="yes" xml:space="preserve">
          <source>If the &lt;strong&gt;BLOCK&lt;/strong&gt; option is not used, the command is synchronous, and can be considered somewhat related to &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;: it will return a range of items inside streams, however it has two fundamental differences compared to &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; even if we just consider the synchronous usage:</source>
          <target state="translated">&lt;strong&gt;BLOCK&lt;/strong&gt;オプションが使用されていない場合、コマンドは同期的であり、&lt;a href=&quot;xrange&quot;&gt;XRANGEに&lt;/a&gt;いくらか関連していると見なすことができます。ストリーム内のアイテムの範囲を返しますが、同期の使用のみを考慮した場合でも、&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;と比較して2つの基本的な違いがあります。</target>
        </trans-unit>
        <trans-unit id="2a8ebc8cb8dd39729bf6fdaaa9469b8e9dd31c5f" translate="yes" xml:space="preserve">
          <source>If the &lt;strong&gt;FORCE&lt;/strong&gt; option is given, the replica does not perform any handshake with the master, that may be not reachable, but instead just starts a failover ASAP starting from point 4. This is useful when we want to start a manual failover while the master is no longer reachable.</source>
          <target state="translated">場合&lt;strong&gt;FORCEの&lt;/strong&gt;オプションが指定され、レプリカがマスターと任意のハンドシェイクを実行しない、それが到達可能ではないかもしれないが、その代わりただ、フェイルオーバーは、私たちがマスターしばらく手動フェールオーバーを開始したいときに便利である点4から始まるできるだけ早く開始します到達できなくなりました。</target>
        </trans-unit>
        <trans-unit id="41e165a8913dade3e9bd91924016ff8d6cab273f" translate="yes" xml:space="preserve">
          <source>If the AOF rewrite could start, but the attempt at starting it fails (for instance because of an error in creating the child process), an error is returned to the caller.</source>
          <target state="translated">AOFの書き換えを開始できたにもかかわらず、子プロセスの作成に失敗した場合(例えば、子プロセスの作成に失敗した場合)、呼び出し元にエラーが返されます。</target>
        </trans-unit>
        <trans-unit id="32dde384b66bbd79b525259d52aa9797e8b17bb3" translate="yes" xml:space="preserve">
          <source>If the Redis server is password protected via the &lt;code&gt;requirepass&lt;/code&gt; option.</source>
          <target state="translated">Redisサーバーが &lt;code&gt;requirepass&lt;/code&gt; オプションを介してパスワードで保護されている場合。</target>
        </trans-unit>
        <trans-unit id="fded77f647c95a1a86355a7eafad08fd193bd854" translate="yes" xml:space="preserve">
          <source>If the above condition happens using a Redis 2.6 server or greater, Client &lt;strong&gt;A&lt;/strong&gt; will be served with the &lt;code&gt;c&lt;/code&gt; element, because after the &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; command the list contains &lt;code&gt;c,b,a&lt;/code&gt;, so taking an element from the left means to return &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">上記の条件がRedis 2.6以降のサーバーで発生した場合、&lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;コマンドの後にリストに &lt;code&gt;c,b,a&lt;/code&gt; が含まれるため、クライアント&lt;strong&gt;Aに&lt;/strong&gt;は &lt;code&gt;c&lt;/code&gt; 要素が提供されるため、左から要素を取得すると &lt;code&gt;c&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="dc531ff7f9715b58415dfa6813dab3cc7b073afd" translate="yes" xml:space="preserve">
          <source>If the approximated cardinality estimated by the HyperLogLog changed after executing the command, &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; returns 1, otherwise 0 is returned. The command automatically creates an empty HyperLogLog structure (that is, a Redis String of a specified length and with a given encoding) if the specified key does not exist.</source>
          <target state="translated">コマンドの実行後に、HyperLogLogによって推定された近似カーディナリティーが変更された場合、&lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt;は1を返し、それ以外の場合は0を返します。指定されたキーが存在しない場合、コマンドは自動的に空のHyperLogLog構造（つまり、指定された長さと指定されたエンコーディングのRedis文字列）を作成します。</target>
        </trans-unit>
        <trans-unit id="2a7df869ee4ed74778e5142a4cec6fc019c36dbe" translate="yes" xml:space="preserve">
          <source>If the client is subscribed to a channel or a pattern, it will instead return a multi-bulk with a &quot;pong&quot; in the first position and an empty bulk in the second position, unless an argument is provided in which case it returns a copy of the argument.</source>
          <target state="translated">クライアントがチャンネルまたはパターンを購読している場合、代わりに、最初の位置に「ポン」を、2番目の位置に空のバルクを持つマルチバルクを返します。</target>
        </trans-unit>
        <trans-unit id="1e3b4ecb886491d18a97620613800a70a1d78a2c" translate="yes" xml:space="preserve">
          <source>If the client tries to blocks for multiple keys, but at least one key contains elements, the returned key / element pair is the first key from left to right that has one or more elements. In this case the client is not blocked. So for instance &lt;code&gt;BLPOP key1 key2 key3 key4 0&lt;/code&gt;, assuming that both &lt;code&gt;key2&lt;/code&gt; and &lt;code&gt;key4&lt;/code&gt; are non-empty, will always return an element from &lt;code&gt;key2&lt;/code&gt;.</source>
          <target state="translated">クライアントが複数のキーをブロックしようとしたが、少なくとも1つのキーに要素が含まれている場合、返されるキー/要素のペアは、1つ以上の要素を持つ左から右への最初のキーです。この場合、クライアントはブロックされません。したがって、たとえば &lt;code&gt;BLPOP key1 key2 key3 key4 0&lt;/code&gt; は、 &lt;code&gt;key2&lt;/code&gt; と &lt;code&gt;key4&lt;/code&gt; の両方が空でないと仮定すると、常に &lt;code&gt;key2&lt;/code&gt; から要素を返します。</target>
        </trans-unit>
        <trans-unit id="c4c4a551c5294109d275f4efb02ba586ea39cd4b" translate="yes" xml:space="preserve">
          <source>If the command contains multiple keys, in case none exist, the behavior is the same as point 2, if all exist, it is the same as point 1, however if only a partial number of keys exist, the command emits a &lt;code&gt;TRYAGAIN&lt;/code&gt; error in order for the keys interested to finish being migrated to the target node, so that the multi keys command can be executed.</source>
          <target state="translated">コマンドに複数のキーが含まれている場合、存在しない場合の動作はポイント2と同じです。すべてが存在する場合、ポイント1と同じですが、キーの一部しか存在しない場合、コマンドは &lt;code&gt;TRYAGAIN&lt;/code&gt; エラーを出力します。マルチキーコマンドを実行できるように、対象のキーがターゲットノードへの移行を完了するように順序付けます。</target>
        </trans-unit>
        <trans-unit id="b47c13f341545793a768bad91b706c8230117dd6" translate="yes" xml:space="preserve">
          <source>If the command is sent as part of a &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; transaction, the command does not block but instead just return ASAP the number of replicas that acknowledged the previous write commands.</source>
          <target state="translated">コマンドが&lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt;トランザクションの一部として送信される場合、コマンドはブロックせず、代わりに以前の書き込みコマンドを確認したレプリカの数をASAPに返します。</target>
        </trans-unit>
        <trans-unit id="b2647b206316067e60c5c58ad3dabbd5311d10db" translate="yes" xml:space="preserve">
          <source>If the command is successful the new incremented value is stored as the new value of the key (replacing the old one), and returned to the caller as a string.</source>
          <target state="translated">コマンドが成功した場合、新しいインクリメントされた値がキーの新しい値として保存され (古い値を置き換える)、文字列として呼び出し元に返されます。</target>
        </trans-unit>
        <trans-unit id="e13c77b4e4b0cd6a39fdb6c6dd3019929d6f047e" translate="yes" xml:space="preserve">
          <source>If the command succeeds the new replica will immediately try to contact its master in order to replicate from it.</source>
          <target state="translated">このコマンドが成功した場合、新しいレプリカはすぐにマスターに連絡して、レプリカを複製しようとします。</target>
        </trans-unit>
        <trans-unit id="58e50abae2f1a6949ff81b62d232f71c48c7e358" translate="yes" xml:space="preserve">
          <source>If the current hash slot owner is the node receiving the command, but for effect of the command the slot would be assigned to a different node, the command will return an error if there are still keys for that hash slot in the node receiving the command.</source>
          <target state="translated">現在のハッシュスロットの所有者がコマンドを受信しているノードで、コマンドの効果のためにスロットが別のノードに割り当てられている場合、コマンドを受信しているノードにそのハッシュスロットの鍵が残っている場合、コマンドはエラーを返します。</target>
        </trans-unit>
        <trans-unit id="8bdc0729f7e8e3e8d69c4bf5f17ea02031eef1ea" translate="yes" xml:space="preserve">
          <source>If the destination variable exists, it is treated as one of the source sets and its cardinality will be included in the cardinality of the computed HyperLogLog.</source>
          <target state="translated">宛先変数が存在する場合、その変数はソースセットの一つとして扱われ、そのカーディナリティは計算されたHyperLogのカーディナリティに含まれます。</target>
        </trans-unit>
        <trans-unit id="b16a9421e847dd28010cba3e62963f9099073a99" translate="yes" xml:space="preserve">
          <source>If the elements in the sorted set have different scores, the returned elements are unspecified.</source>
          <target state="translated">ソートされた集合の要素のスコアが異なる場合、返される要素は不特定です。</target>
        </trans-unit>
        <trans-unit id="3481b2e7b6d800470df672a8874ad9a04f6afdca" translate="yes" xml:space="preserve">
          <source>If the instance is a replica, these additional fields are provided:</source>
          <target state="translated">インスタンスがレプリカの場合は、これらの追加フィールドが提供されます。</target>
        </trans-unit>
        <trans-unit id="a39168a871f5b0b2ac68a8345a687deba4b95089" translate="yes" xml:space="preserve">
          <source>If the link between master and replica is down, an additional field is provided:</source>
          <target state="translated">マスターとレプリカ間のリンクがダウンしている場合は、追加のフィールドが提供されます。</target>
        </trans-unit>
        <trans-unit id="5d43590cf68cfd82fc6f591b087a5f138a1a7c3f" translate="yes" xml:space="preserve">
          <source>If the message was never delivered to anyone, that is, if we are talking about a new message, then a PEL (Pending Entry List) is created.</source>
          <target state="translated">メッセージが誰にも配信されなかった場合、つまり新しいメッセージの話をしている場合は、PEL(Pending Entry List)が作成されます。</target>
        </trans-unit>
        <trans-unit id="638ffe7f713cb2cff80e46aae12ead14d0ec33c3" translate="yes" xml:space="preserve">
          <source>If the node is a replica it is turned into an (empty) master. Its dataset is flushed, so at the end the node will be an empty master.</source>
          <target state="translated">ノードがレプリカの場合、それは(空の)マスタになります。そのデータセットはフラッシュされるので、最後には空のマスターになります。</target>
        </trans-unit>
        <trans-unit id="1785c288c16b021950b10d9d886a7eae6f023094" translate="yes" xml:space="preserve">
          <source>If the node receiving the command is not already a replica, but is a master, the command will only succeed, and the node will be converted into a replica, only if the following additional conditions are met:</source>
          <target state="translated">コマンドを受け取ったノードが既にレプリカではなくマスターである場合、コマンドは成功し、以下の追加条件が満たされた場合にのみ、そのノードはレプリカに変換されます。</target>
        </trans-unit>
        <trans-unit id="0d7f2602b57e25d3482f6de95a393b6a52d114e4" translate="yes" xml:space="preserve">
          <source>If the object you try to inspect is missing, a null bulk reply is returned.</source>
          <target state="translated">検査しようとしたオブジェクトが見つからない場合は、NULLバルク応答が返されます。</target>
        </trans-unit>
        <trans-unit id="502f345996f0414bbb8039bdf0ba7a24bdfc3f8f" translate="yes" xml:space="preserve">
          <source>If the password provided via AUTH matches the password in the configuration file, the server replies with the &lt;code&gt;OK&lt;/code&gt; status code and starts accepting commands. Otherwise, an error is returned and the clients needs to try a new password.</source>
          <target state="translated">AUTHを介して提供されたパスワードが構成ファイルのパスワードと一致する場合、サーバーは &lt;code&gt;OK&lt;/code&gt; ステータスコードで応答し、コマンドの受け入れを開始します。それ以外の場合は、エラーが返され、クライアントは新しいパスワードを試す必要があります。</target>
        </trans-unit>
        <trans-unit id="8069378ad909326b9b791fda111aafbf70922eb2" translate="yes" xml:space="preserve">
          <source>If the rules contain errors, the error is returned.</source>
          <target state="translated">ルールにエラーが含まれている場合は、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="ed8b33783f226cf240802124131a6b3112f200a2" translate="yes" xml:space="preserve">
          <source>If the script already called write commands the only allowed command becomes &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; that stops the server without saving the current data set on disk (basically the server is aborted).</source>
          <target state="translated">スクリプトがすでに書き込みコマンドを呼び出している場合、許可される唯一のコマンドは &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; となり、現在のデータセットをディスクに保存せずにサーバーを停止します（基本的にサーバーは中止されます）。</target>
        </trans-unit>
        <trans-unit id="7d7312df2553f6628fdfae5411ba0776826d8dfb" translate="yes" xml:space="preserve">
          <source>If the script already performed write operations it can not be killed in this way because it would violate Lua script atomicity contract. In such a case only &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; is able to kill the script, killing the Redis process in an hard way preventing it to persist with half-written information.</source>
          <target state="translated">スクリプトがすでに書き込み操作を実行している場合は、Luaスクリプトの原子性規約に違反するため、この方法で強制終了することはできません。このような場合、スクリプトを &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; できるのはSHUTDOWN NOSAVEだけであり、Redisプロセスを強制的に強制終了して、半分書き込まれた情報が保持されないようにします。</target>
        </trans-unit>
        <trans-unit id="5aeedf1a85f8e143cfd4057ccfb92d5e01611feb" translate="yes" xml:space="preserve">
          <source>If the server does not remember a script with this SHA1 digest, a special error is returned telling the client to use &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; instead.</source>
          <target state="translated">サーバーがこのSHA1ダイジェストのスクリプトを覚えていない場合は、代わりに&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;を使用するようにクライアントに指示する特別なエラーが返されます。</target>
        </trans-unit>
        <trans-unit id="8c526024cc2b0adff52463eae82153b3e7035275" translate="yes" xml:space="preserve">
          <source>If the server is configured with the &lt;code&gt;min-slaves-to-write&lt;/code&gt; (or starting with Redis 5 with the &lt;code&gt;min-replicas-to-write&lt;/code&gt;) directive, an additional field is provided:</source>
          <target state="translated">サーバーが &lt;code&gt;min-slaves-to-write&lt;/code&gt; ディレクティブで構成されている場合（またはRedis 5から &lt;code&gt;min-replicas-to-write&lt;/code&gt; を使用して開始されている場合）、追加のフィールドが提供されます。</target>
        </trans-unit>
        <trans-unit id="160c785d0bbfa994844826d34af71d6ba78bcac0" translate="yes" xml:space="preserve">
          <source>If the server still remembers a script with a matching SHA1 digest, the script is executed.</source>
          <target state="translated">一致する SHA1 ダイジェストを持つスクリプトをサーバがまだ記憶している場合、スクリプトが実行されます。</target>
        </trans-unit>
        <trans-unit id="a73ff8adff60cf3faa9396c7d82031cce8e1eee5" translate="yes" xml:space="preserve">
          <source>If the slot is in &lt;em&gt;migrating&lt;/em&gt; state, the state gets cleared when the slot is assigned to another node.</source>
          <target state="translated">スロットが&lt;em&gt;移行中の&lt;/em&gt;状態の場合、スロットが別のノードに割り当てられると、状態はクリアされます。</target>
        </trans-unit>
        <trans-unit id="4fb7824817ed0173726151921ede13e72a5a9bcf" translate="yes" xml:space="preserve">
          <source>If the slot was in &lt;em&gt;importing&lt;/em&gt; state in the node receiving the command, and the command assigns the slot to this node (which happens in the target node at the end of the resharding of a hash slot from one node to another), the command has the following side effects: A) the &lt;em&gt;importing&lt;/em&gt; state is cleared. B) If the node config epoch is not already the greatest of the cluster, it generates a new one and assigns the new config epoch to itself. This way its new hash slot ownership will win over any past configuration created by previous failovers or slot migrations.</source>
          <target state="translated">コマンドを受信するノードでスロットが&lt;em&gt;インポート&lt;/em&gt;状態であり、コマンドがこのノードにスロットを割り当てる場合（これは、あるノードから別のノードへのハッシュスロットの再シャーディングの最後にターゲットノードで発生します）、コマンドは次の副作用：A）&lt;em&gt;インポート&lt;/em&gt;状態がクリアされます。 B）ノード構成エポックがクラスターの最大のものではない場合、新しい構成エポックが生成され、それ自体に新しい構成エポックが割り当てられます。このようにして、新しいハッシュスロットの所有権は、以前のフェイルオーバーまたはスロットの移行によって作成された過去の構成よりも優先されます。</target>
        </trans-unit>
        <trans-unit id="e8cd47d9356aab972b5f2bd3e87e1b06b6cacf48" translate="yes" xml:space="preserve">
          <source>If the source set does not exist or does not contain the specified element, no operation is performed and &lt;code&gt;0&lt;/code&gt; is returned. Otherwise, the element is removed from the source set and added to the destination set. When the specified element already exists in the destination set, it is only removed from the source set.</source>
          <target state="translated">ソースセットが存在しないか、指定された要素が含まれていない場合、操作は実行されず、 &lt;code&gt;0&lt;/code&gt; が返されます。それ以外の場合、要素はソースセットから削除され、宛先セットに追加されます。指定された要素が宛先セットにすでに存在する場合、ソースセットからのみ削除されます。</target>
        </trans-unit>
        <trans-unit id="3ca48297ca2c9df85be826386d88391801b54916" translate="yes" xml:space="preserve">
          <source>If the specified stream doesn't exist when creating a group, an error will be returned. You can use the optional &lt;code&gt;MKSTREAM&lt;/code&gt; subcommand as the last argument after the &lt;code&gt;ID&lt;/code&gt; to automatically create the stream, if it doesn't exist. Note that if the stream is created in this way it will have a length of 0:</source>
          <target state="translated">グループの作成時に指定されたストリームが存在しない場合、エラーが返されます。オプションの &lt;code&gt;MKSTREAM&lt;/code&gt; サブコマンドを &lt;code&gt;ID&lt;/code&gt; の後の最後の引数として使用して、ストリームが存在しない場合は自動的に作成できます。ストリームがこのように作成された場合、長さは0になることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b2a65b6aeeded425b23af7e95965a0f641dbdc37" translate="yes" xml:space="preserve">
          <source>If the user already exists, the provided ACL rules are simply applied &lt;em&gt;in addition&lt;/em&gt; to the rules already set. For example:</source>
          <target state="translated">ユーザーがすでに存在する場合は、すでに設定されているルール&lt;em&gt;に加え&lt;/em&gt;て、提供されているACLルールが適用されるだけです。例えば：</target>
        </trans-unit>
        <trans-unit id="da52acca0f5817a572a7d2dfec4d48663d8d1b71" translate="yes" xml:space="preserve">
          <source>If the user inserts all the elements in a sorted set with the same score (for example 0), all the elements of the sorted set are sorted lexicographically, and range queries on elements are possible using the command &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; (Note: it is also possible to query sorted sets by range of scores using &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;).</source>
          <target state="translated">ユーザーが同じスコア（0など）のソート済みセットにすべての要素を挿入すると、ソート済みセットのすべての要素が辞書順にソートされ、&lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt;コマンドを使用して要素に対する範囲クエリが可能になります（注：&lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;を使用して、スコアの範囲でソートされたセットをクエリします。</target>
        </trans-unit>
        <trans-unit id="bb5f5ae1336c1db943d20a454954235747a6d64e" translate="yes" xml:space="preserve">
          <source>If the user will be idle more than 60 seconds, the key will be deleted and only subsequent page views that have less than 60 seconds of difference will be recorded.</source>
          <target state="translated">ユーザーが60秒以上アイドル状態になると、そのキーは削除され、60秒未満の差がある後続のページビューのみが記録されます。</target>
        </trans-unit>
        <trans-unit id="dca107e1698238aa60bfb450d46b8e949be6578e" translate="yes" xml:space="preserve">
          <source>If there are no keys to migrate in the source instance &lt;code&gt;NOKEY&lt;/code&gt; is returned. Because missing keys are possible in normal conditions, from expiry for example, &lt;code&gt;NOKEY&lt;/code&gt; isn't an error.</source>
          <target state="translated">ソースインスタンスに移行するキーがない場合、 &lt;code&gt;NOKEY&lt;/code&gt; が返されます。たとえば、 &lt;code&gt;NOKEY&lt;/code&gt; などの通常の条件ではキーが欠落している可能性があるため、NOKEYはエラーではありません。</target>
        </trans-unit>
        <trans-unit id="65645be10cc140f75bd2c8251142687f4fa78461" translate="yes" xml:space="preserve">
          <source>If we generate a configuration epoch which happens to collide with another instance, eventually our configuration epoch, or the one of another instance with our same epoch, will be moved away using the &lt;em&gt;configuration epoch collision resolution algorithm&lt;/em&gt;.</source>
          <target state="translated">別のインスタンスと衝突する構成エポックを生成すると、最終的には構成エポック、または同じエポックを持つ別のインスタンスの1つが、&lt;em&gt;構成エポック衝突解決アルゴリズム&lt;/em&gt;を使用して移動され&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="b6f79d56180a9ad1d3aeb8220feacf255be61da4" translate="yes" xml:space="preserve">
          <source>If we look for clear bits (the bit argument is 0) and the string only contains bit set to 1, the function returns the first bit not part of the string on the right. So if the string is three bytes set to the value &lt;code&gt;0xff&lt;/code&gt; the command &lt;code&gt;BITPOS key 0&lt;/code&gt; will return 24, since up to bit 23 all the bits are 1.</source>
          <target state="translated">クリアビット（ビット引数は0）を探し、文字列に1に設定されたビットのみが含まれている場合、関数は右側の文字列の一部ではない最初のビットを返します。したがって、文字列が値 &lt;code&gt;0xff&lt;/code&gt; に設定された3バイトの場合、ビット23まではすべてのビットが1であるため、コマンド &lt;code&gt;BITPOS key 0&lt;/code&gt; は24を返します。</target>
        </trans-unit>
        <trans-unit id="44b33ba5659f824ae39b000fc70d2cf7d6138c7b" translate="yes" xml:space="preserve">
          <source>If we look for set bits (the bit argument is 1) and the string is empty or composed of just zero bytes, -1 is returned.</source>
          <target state="translated">セットされたビット(ビットの引数が1)を探し、文字列が空か0バイトだけで構成されている場合は、-1が返されます。</target>
        </trans-unit>
        <trans-unit id="2012c008377fbb50737408462ade88dce859c2ba" translate="yes" xml:space="preserve">
          <source>If you call &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; or &lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt;, there's no need to manually call &lt;a href=&quot;unwatch&quot;&gt;UNWATCH&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;または&lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt;を呼び出す場合、手動で&lt;a href=&quot;unwatch&quot;&gt;UNWATCH&lt;/a&gt;を呼び出す必要はありません。</target>
        </trans-unit>
        <trans-unit id="7adf0ee2bf057d6e4f3261ad571f6a13a6962d80" translate="yes" xml:space="preserve">
          <source>If you have a stream and multiple clients, and you want all the clients to get all the messages, you do not need a consumer group.</source>
          <target state="translated">ストリームと複数のクライアントを持っていて、すべてのクライアントがすべてのメッセージを取得したい場合は、消費者グループは必要ありません。</target>
        </trans-unit>
        <trans-unit id="7914b0ae2e05e8d2f74a0d7390601ab548d893de" translate="yes" xml:space="preserve">
          <source>If you have a stream and multiple clients, and you want the stream to be &lt;em&gt;partitioned&lt;/em&gt; or &lt;em&gt;sharded&lt;/em&gt; across your clients, so that each client will get a sub set of the messages arriving in a stream, you need a consumer group.</source>
          <target state="translated">ストリームと複数のクライアントがあり、ストリームをクライアント間で&lt;em&gt;パーティション化&lt;/em&gt;または&lt;em&gt;シャーディングし&lt;/em&gt;て、各クライアントがストリームに到着するメッセージのサブセットを取得するようにする場合は、コンシューマーグループが必要です。</target>
        </trans-unit>
        <trans-unit id="560057ad39d223339741232ee3fcc91b0feb1edf" translate="yes" xml:space="preserve">
          <source>If you have a stream and multiple clients, and you want the stream to be &lt;em&gt;partitioned&lt;/em&gt; or &lt;em&gt;shareded&lt;/em&gt; across your clients, so that each client will get a sub set of the messages arriving in a stream, you need a consumer group.</source>
          <target state="translated">ストリームと複数のクライアントがあり、ストリームをクライアント間で&lt;em&gt;分割&lt;/em&gt;または&lt;em&gt;共有し&lt;/em&gt;て、各クライアントがストリームに到着するメッセージのサブセットを取得できるようにする場合は、コンシューマーグループが必要です。</target>
        </trans-unit>
        <trans-unit id="b31dd57013b909fbb7b7346c7faa280640e4841b" translate="yes" xml:space="preserve">
          <source>If you like science fiction, think of time flowing at infinite speed inside a &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; block...</source>
          <target state="translated">SFが好きなら、&lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;ブロック内で無限の速度で流れる時間を考えてみてください...</target>
        </trans-unit>
        <trans-unit id="c010cb9076ea01e47bb02d7ca64129ac264912a3" translate="yes" xml:space="preserve">
          <source>If you look for an &lt;code&gt;XGET&lt;/code&gt; command you'll be disappointed because &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; is effectively the way to go in order to fetch a single entry from a stream. All you have to do is to specify the ID two times in the arguments of XRANGE:</source>
          <target state="translated">あなたが探している場合 &lt;code&gt;XGET&lt;/code&gt; のコマンドので、あなたは失望するだろう&lt;a href=&quot;xrange&quot;&gt;XRANGEが&lt;/a&gt;効果的にストリームから単一のエントリをフェッチするために移動するための方法です。XRANGEの引数でIDを2回指定するだけです。</target>
        </trans-unit>
        <trans-unit id="9b173c7e7e26659d2dc21433cf73d902805a206a" translate="yes" xml:space="preserve">
          <source>If you request details about non-existing commands, their return position will be nil.</source>
          <target state="translated">存在しないコマンドの詳細を要求した場合、その戻り値はnilになります。</target>
        </trans-unit>
        <trans-unit id="12acfb0048a8a9bf03f38f7e388902128cc410f3" translate="yes" xml:space="preserve">
          <source>Imagine you have a web service and you are interested in the latest N pages &lt;em&gt;recently&lt;/em&gt; visited by your users, such that each adjacent page view was not performed more than 60 seconds after the previous. Conceptually you may consider this set of page views as a &lt;em&gt;Navigation session&lt;/em&gt; of your user, that may contain interesting information about what kind of products he or she is looking for currently, so that you can recommend related products.</source>
          <target state="translated">Webサービスがあり、ユーザーが&lt;em&gt;最近&lt;/em&gt;アクセスした最新のNページに関心があり、隣接する各ページの表示が前のページから60秒以上実行されなかったとします。概念的には、この一連のページビューをユーザーの&lt;em&gt;ナビゲーションセッション&lt;/em&gt;と見なすことができます。これには、ユーザーが現在探している製品の種類に関する興味深い情報が含まれているため、関連製品を推奨できます。</target>
        </trans-unit>
        <trans-unit id="3fb9a33bf9d1d9a11eb463de937edd8bbe41eff8" translate="yes" xml:space="preserve">
          <source>Imagine you have elements A, B and C with weights 1, 2 and 3. You compute the sum of the weights, which is 1+2+3 = 6</source>
          <target state="translated">重み1、2、3を持つ要素A、B、Cがあると想像してみてください。重みの合計を計算すると,1+2+3=6となります。</target>
        </trans-unit>
        <trans-unit id="28adac3b6124834ed39c280b45702edaf27ac85d" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;wait&quot;&gt;WAITを&lt;/a&gt;実装します。</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">実施内容</target>
        </trans-unit>
        <trans-unit id="11672e7162d8cdc131bd8b02c509dcb60a9d776d" translate="yes" xml:space="preserve">
          <source>Implementation details and notes</source>
          <target state="translated">実装内容と注意点</target>
        </trans-unit>
        <trans-unit id="cc7649d9b862b15149646b67450f76a9d95f07c8" translate="yes" xml:space="preserve">
          <source>Implementation details: MEET and PING packets</source>
          <target state="translated">実装の詳細。MEETパケットとPINGパケット</target>
        </trans-unit>
        <trans-unit id="c5a3d437892d8fb38c145f676153ba0009f546b9" translate="yes" xml:space="preserve">
          <source>Important: &lt;strong&gt;there is no need to use the same COUNT value&lt;/strong&gt; for every iteration. The caller is free to change the count from one iteration to the other as required, as long as the cursor passed in the next call is the one obtained in the previous call to the command.</source>
          <target state="translated">重要：反復ごとに&lt;strong&gt;同じCOUNT値を使用する必要はありません&lt;/strong&gt;。次の呼び出しで渡されたカーソルが前のコマンドの呼び出しで取得されたものである限り、呼び出し元は必要に応じて1つの反復から別の反復にカウントを自由に変更できます。</target>
        </trans-unit>
        <trans-unit id="b6980584e557c93bab34f4259447d38dd3a9c928" translate="yes" xml:space="preserve">
          <source>Importing and migrating slots are emitted in the &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; output as follows:</source>
          <target state="translated">スロットのインポートと移行は、&lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODESの&lt;/a&gt;出力で次のように行われます。</target>
        </trans-unit>
        <trans-unit id="50ac60eae9cbac9b1534be93c64ff4eb8e05e3df" translate="yes" xml:space="preserve">
          <source>Importing and migrating slots are provided as &lt;strong&gt;additional info&lt;/strong&gt;. If the node has a given hash slot assigned, it will be also a plain number in the list of hash slots, so clients that don't have a clue about hash slots migrations can just skip this special fields.</source>
          <target state="translated">&lt;strong&gt;追加情報&lt;/strong&gt;として、スロットのインポートと移行が提供されます。ノードに特定のハッシュスロットが割り当てられている場合、それはハッシュスロットのリストでもプレーンな番号になるため、ハッシュスロットの移行に関する手掛かりがないクライアントは、この特別なフィールドをスキップできます。</target>
        </trans-unit>
        <trans-unit id="779e3f1f46c82af5ed6e618104fadfbd8c5eb506" translate="yes" xml:space="preserve">
          <source>In Cluster mode, both &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;newkey&lt;/code&gt; must be in the same &lt;strong&gt;hash slot&lt;/strong&gt;, meaning that in practice only keys that have the same hash tag can be reliably renamed in cluster.</source>
          <target state="translated">クラスタモードでは、 &lt;code&gt;key&lt;/code&gt; と &lt;code&gt;newkey&lt;/code&gt; の両方が同じ&lt;strong&gt;ハッシュスロット&lt;/strong&gt;にある必要があります。つまり、実際には、同じハッシュタグを持つキーのみがクラスタ内で確実に名前を変更できます。</target>
        </trans-unit>
        <trans-unit id="e69ceca772f34d784aadd1c27595fdabe97b5262" translate="yes" xml:space="preserve">
          <source>In Redis 2.4 the expire might not be pin-point accurate, and it could be between zero to one seconds out.</source>
          <target state="translated">Redis 2.4では、期限切れはピンポイントで正確ではないかもしれません。</target>
        </trans-unit>
        <trans-unit id="404f7b7c02b7867c0901ee21294f6e2f5fef0d3c" translate="yes" xml:space="preserve">
          <source>In Redis 2.6 or older the command returns &lt;code&gt;-1&lt;/code&gt; if the key does not exist or if the key exist but has no associated expire.</source>
          <target state="translated">Redis 2.6以前では、キーが存在しない場合、またはキーは存在するが有効期限が関連付けられていない場合、コマンドは &lt;code&gt;-1&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="8b69e0b775a7565070cf9c5f2db4bd807c015a5f" translate="yes" xml:space="preserve">
          <source>In Redis Cluster, each node keeps track of which master is serving a particular hash slot.</source>
          <target state="translated">Redis Clusterでは、各ノードはどのマスターが特定のハッシュスロットを提供しているかを追跡します。</target>
        </trans-unit>
        <trans-unit id="d172f4fd77faed8def89fa030ed71bc01d833ea7" translate="yes" xml:space="preserve">
          <source>In Redis version 4, commands that may return elements in random order, like &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; (because Redis Sets are &lt;em&gt;unordered&lt;/em&gt;) have a different behavior when called from Lua, and undergo a silent lexicographical sorting filter before returning data to Lua scripts. So &lt;code&gt;redis.call(&quot;smembers&quot;,KEYS[1])&lt;/code&gt; will always return the Set elements in the same order, while the same command invoked from normal clients may return different results even if the key contains exactly the same elements. However starting with Redis 5 there is no longer such ordering step, because Redis 5 replicates scripts in a way that no longer needs non-deterministic commands to be converted into deterministic ones. In general, even when developing for Redis 4, never assume that certain commands in Lua will be ordered, but instead rely on the documentation of the original command you call to see the properties it provides.</source>
          <target state="translated">Redisバージョン4では、&lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt;（Redisセットが&lt;em&gt;順序付けされていない&lt;/em&gt;ため）のようにランダムな順序で要素を返す可能性のあるコマンドは、Luaから呼び出されたときの動作が異なり、Luaスクリプトにデータを返す前にサイレント辞書式ソートフィルターを実行します。したがって、 &lt;code&gt;redis.call(&quot;smembers&quot;,KEYS[1])&lt;/code&gt; は常に同じ順序でSet要素を返しますが、通常のクライアントから呼び出された同じコマンドは、キーにまったく同じ要素が含まれている場合でも、異なる結果を返す場合があります。ただし、Redis 5以降、Redis 5は、非決定論的コマンドを決定論的コマンドに変換する必要がなくなった方法でスクリプトを複製するため、そのような順序付けステップはなくなりました。一般に、Redis 4用に開発する場合でも、Luaの特定のコマンドが順序付けられるとは決して想定せず、代わりに、呼び出す元のコマンドのドキュメントに依存して、提供されるプロパティを確認します。</target>
        </trans-unit>
        <trans-unit id="d0bdbf698aa8eaf887d7877ad1c2d9ea20b7520a" translate="yes" xml:space="preserve">
          <source>In Redis versions prior &lt;strong&gt;2.1.3&lt;/strong&gt; altering a key with an expire set using a command altering its value had the effect of removing the key entirely. This semantics was needed because of limitations in the replication layer that are now fixed.</source>
          <target state="translated">&lt;strong&gt;2.1.3&lt;/strong&gt;より前のバージョンのRedisでは、コマンドを使用して有効期限を設定してキーを変更し、その値を変更すると、キーが完全に削除されました。このセマンティクスは、現在修正されているレプリケーションレイヤーの制限のために必要でした。</target>
        </trans-unit>
        <trans-unit id="532b5a4c8c089bdea2a3dcd755e5c2d0a78f31ac" translate="yes" xml:space="preserve">
          <source>In a Redis Cluster clients can publish to every node. The cluster makes sure that published messages are forwarded as needed, so clients can subscribe to any channel by connecting to any one of the nodes.</source>
          <target state="translated">Redisクラスタでは、クライアントはすべてのノードに公開することができます。クラスタは公開されたメッセージが必要に応じて転送されるようにしているので、クライアントはどのノードに接続しても任意のチャンネルを購読することができます。</target>
        </trans-unit>
        <trans-unit id="34f272b3296928896a7fa9c51b4f28ffa23b9540" translate="yes" xml:space="preserve">
          <source>In future versions of Redis it is possible that we'll trigger a node garbage collection in case a given macro-node reaches a given amount of deleted entries. Currently with the usage we anticipate for this data structure, it is not a good idea to add such complexity.</source>
          <target state="translated">Redisの将来のバージョンでは、マクロノードが削除されたエントリの量に達した場合に、ノードのガベージコレクションをトリガーする可能性があります。現在のところ、このデータ構造のために予想される使用方法では、このような複雑さを追加するのは良い考えではありません。</target>
        </trans-unit>
        <trans-unit id="420ffa2728e82649ac426218fc502611ceb5c012" translate="yes" xml:space="preserve">
          <source>In general what you should know is that setting the &lt;code&gt;appendonly&lt;/code&gt; parameter to &lt;code&gt;yes&lt;/code&gt; will start a background process to save the initial append-only file (obtained from the in memory data set), and will append all the subsequent commands on the append-only file, thus obtaining exactly the same effect of a Redis server that started with AOF turned on since the start.</source>
          <target state="translated">一般的に知っておくべきことは、 &lt;code&gt;appendonly&lt;/code&gt; パラメータを &lt;code&gt;yes&lt;/code&gt; に設定すると、バックグラウンドプロセスが開始され、最初の追加専用ファイル（メモリ内データセットから取得）が保存され、以降のすべてのコマンドが追加専用ファイルに追加されます。したがって、起動後にAOFをオンにして起動したRedisサーバーとまったく同じ効果が得られます。</target>
        </trans-unit>
        <trans-unit id="464e556758431df2768b0136fb61ecadb0a9af07" translate="yes" xml:space="preserve">
          <source>In its synchronous form, the command can get new data as long as there are more items available. However, at some point, we'll have to wait for producers of data to use &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; to push new entries inside the streams we are consuming. In order to avoid polling at a fixed or adaptive interval the command is able to block if it could not return any data, according to the specified streams and IDs, and automatically unblock once one of the requested keys accept data.</source>
          <target state="translated">同期形式では、使用可能な項目がまだある限り、コマンドは新しいデータを取得できます。ただし、ある時点で、データのプロデューサーが&lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt;を使用して、使用しているストリーム内に新しいエントリをプッシュするのを待つ必要があります。固定間隔または適応間隔でのポーリングを回避するために、コマンドは、指定されたストリームとIDに従ってデータを返せなかった場合にブロックし、要求されたキーの1つがデータを受け入れると自動的にブロックを解除できます。</target>
        </trans-unit>
        <trans-unit id="f71d43ee55e218973fa1e5cb6ebd10de6f4de1c3" translate="yes" xml:space="preserve">
          <source>In options where bytes or other quantities are specified, it is not possible to use the &lt;code&gt;redis.conf&lt;/code&gt; abbreviated form (&lt;code&gt;10k&lt;/code&gt;, &lt;code&gt;2gb&lt;/code&gt; ... and so forth), everything should be specified as a well-formed 64-bit integer, in the base unit of the configuration directive. However since Redis version 3.0 or greater, it is possible to use &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; with memory units for &lt;code&gt;maxmemory&lt;/code&gt;, client output buffers, and replication backlog size.</source>
          <target state="translated">バイトまたはその他の量が指定されているオプションでは、 &lt;code&gt;redis.conf&lt;/code&gt; の省略形（ &lt;code&gt;10k&lt;/code&gt; 、 &lt;code&gt;2gb&lt;/code&gt; など）を使用することはできません。すべてを整形式の64ビット整数として構成ディレクティブの基本単位。ただし、Redisバージョン3.0以降では、 &lt;code&gt;maxmemory&lt;/code&gt; 、クライアント出力バッファー、レプリケーションバックログサイズのメモリユニットで&lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt;を使用することが可能です。</target>
        </trans-unit>
        <trans-unit id="a7b5d3135e15286cfdbe38c07d4aa01f9fe0988a" translate="yes" xml:space="preserve">
          <source>In order to authenticate the current connection with one of the connections defined in the ACL list (see &lt;a href=&quot;acl-setuser&quot;&gt;ACL SETUSER&lt;/a&gt;) and the official &lt;a href=&quot;https://redis.io/topics/acl&quot;&gt;ACL guide&lt;/a&gt; for more information.</source>
          <target state="translated">ACLリスト（&lt;a href=&quot;acl-setuser&quot;&gt;ACL SETUSERを&lt;/a&gt;参照）および詳細については公式&lt;a href=&quot;https://redis.io/topics/acl&quot;&gt;ACLガイド&lt;/a&gt;で定義されている接続の1つを使用して、現在の接続を認証するため。</target>
        </trans-unit>
        <trans-unit id="74befe185bf5845d0b7429c8d4ecaac4587e1561" translate="yes" xml:space="preserve">
          <source>In order to avoid these problems while avoiding the bandwidth penalty, Redis implements the &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; command.</source>
          <target state="translated">帯域幅のペナルティを回避しながらこれらの問題を回避するために、Redisは&lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt;コマンドを実装しています。</target>
        </trans-unit>
        <trans-unit id="4e60382da8db79c78bf47f321f4d7ec3aa869b88" translate="yes" xml:space="preserve">
          <source>In order to block, the &lt;strong&gt;BLOCK&lt;/strong&gt; option is used, together with the number of milliseconds we want to block before timing out. Normally Redis blocking commands take timeouts in seconds, however this command takes a millisecond timeout, even if normally the server will have a timeout resolution near to 0.1 seconds. This time it is possible to block for a shorter time in certain use cases, and if the server internals will improve over time, it is possible that the resolution of timeouts will improve.</source>
          <target state="translated">ブロックするには、&lt;strong&gt;BLOCK&lt;/strong&gt;オプションと、タイムアウトする前にブロックするミリ秒数を使用します。通常、Redisブロッキングコマンドはタイムアウトを秒単位で取得しますが、通常、サーバーのタイムアウトが0.1秒に近い場合でも、このコマンドはミリ秒のタイムアウトを取得します。今回は、特定のユースケースでより短い時間ブロックすることが可能であり、サーバーの内部が時間とともに改善する場合、タイムアウトの解決が改善する可能性があります。</target>
        </trans-unit>
        <trans-unit id="0040f93cb8c4b8bdab630ff12697ba1b0160ca64" translate="yes" xml:space="preserve">
          <source>In order to enable script effects replication, you need to issue the following Lua command before any write operated by the script:</source>
          <target state="translated">スクリプト効果のレプリケーションを有効にするには、スクリプトが操作する書き込みの前に以下のLuaコマンドを発行する必要があります。</target>
        </trans-unit>
        <trans-unit id="013756f6d564f805aee9f75f0b5914a1c30d7b5d" translate="yes" xml:space="preserve">
          <source>In order to enable this form, the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; option is used, and the normal &lt;em&gt;key&lt;/em&gt; argument is set to an empty string. The actual key names will be provided after the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; argument itself, like in the following example:</source>
          <target state="translated">このフォームを有効にするには、&lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt;オプションを使用し、通常の&lt;em&gt;キー&lt;/em&gt;引数を空の文字列に設定します。実際のキー名は、次の例のように、&lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt;引数自体の後に提供されます。</target>
        </trans-unit>
        <trans-unit id="ae1f75fb4769a06b17ea6f198ef59cd43ba00d55" translate="yes" xml:space="preserve">
          <source>In order to enable tracking, use:</source>
          <target state="translated">追跡を有効にするには、使用してください。</target>
        </trans-unit>
        <trans-unit id="7e7cf3fffb86f4198755cdccfe390f7daca4376b" translate="yes" xml:space="preserve">
          <source>In order to enforce this behavior in scripts Redis does the following:</source>
          <target state="translated">この動作をスクリプトで強制するために、Redisは以下のようにしています。</target>
        </trans-unit>
        <trans-unit id="4210ec3e973c5d5ac271cc1ab7ffcffaa3f2c4da" translate="yes" xml:space="preserve">
          <source>In order to fix a broken cluster where certain slots are unassigned.</source>
          <target state="translated">特定のスロットが割り当てられていない壊れたクラスタを修正するために。</target>
        </trans-unit>
        <trans-unit id="4708216948f38c6f376d2b00aef53c77bfc810bd" translate="yes" xml:space="preserve">
          <source>In order to iterate a stream, we can proceed as follows. Let's assume that we want two elements per iteration. We start fetching the first two elements, which is trivial:</source>
          <target state="translated">ストリームの反復処理を行うには、以下のように進めます。反復ごとに2つの要素が必要な場合を想定してみましょう。最初の2つの要素の取得を開始しますが、これは些細なことです。</target>
        </trans-unit>
        <trans-unit id="93f82278196654b93d4f14013ea15fe416b7d299" translate="yes" xml:space="preserve">
          <source>In order to make it a pure function, but still be sure that every invocation of the script will result in different random elements, we can simply add an additional argument to the script that will be used in order to seed the Lua pseudo-random number generator. The new script is as follows:</source>
          <target state="translated">これを純粋な関数にしつつも、スクリプトを実行するたびに異なるランダム要素が得られるようにするために、スクリプトに追加の引数を追加するだけで、Lua擬似乱数発生器の種付けに使用することができます。新しいスクリプトは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="5e754dbb6b6073549994be57928409b8a9518fbf" translate="yes" xml:space="preserve">
          <source>In order to make sure the redis.conf file is always consistent, that is, on errors or crashes you always end with the old file, or the new one, the rewrite is performed with a single &lt;code&gt;write(2)&lt;/code&gt; call that has enough content to be at least as big as the old file. Sometimes additional padding in the form of comments is added in order to make sure the resulting file is big enough, and later the file gets truncated to remove the padding at the end.</source>
          <target state="translated">redis.confファイルが常に一貫していることを確認するために、つまり、エラーまたはクラッシュが発生すると、常に古いファイルまたは新しいファイルで終了します。書き換えは、十分なコンテンツを持つ単一の &lt;code&gt;write(2)&lt;/code&gt; 呼び出しで実行されます。少なくとも古いファイルと同じ大きさになるようにします。結果のファイルが十分に大きいことを確認するために、コメント形式の追加のパディングが追加される場合があります。その後、ファイルが切り捨てられて、末尾のパディングが削除されます。</target>
        </trans-unit>
        <trans-unit id="45b71d9b591350682c94742bdef7ff99466f0e92" translate="yes" xml:space="preserve">
          <source>In order to make this locking algorithm more robust, a client holding a lock should always check the timeout didn't expire before unlocking the key with &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; because client failures can be complex, not just crashing but also blocking a lot of time against some operations and trying to issue &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; after a lot of time (when the LOCK is already held by another client).</source>
          <target state="translated">このロックアルゴリズムをより堅牢にするために、ロックを保持しているクライアントは、&lt;a href=&quot;del&quot;&gt;DELで&lt;/a&gt;キーのロックを解除する前に、タイムアウトが期限切れになっていないことを常に確認する必要があります。そして、しばらくしてから&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;を発行しようとします（LOCKがすでに別のクライアントによって保持されている場合）。</target>
        </trans-unit>
        <trans-unit id="26d3078f4ebbdf0701299addb5fed6bbed540a2c" translate="yes" xml:space="preserve">
          <source>In order to obtain a correct behavior without sacrificing consistency, when a key expires, a &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; operation is synthesized in both the AOF file and gains all the attached replicas nodes. This way the expiration process is centralized in the master instance, and there is no chance of consistency errors.</source>
          <target state="translated">一貫性を犠牲にすることなく正しい動作を実現するために、キーの有効期限が切れると、&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;操作がAOFファイルで合成され、接続されているすべてのレプリカノードを取得します。このようにして、有効期限プロセスはマスターインスタンスに集中化され、一貫性エラーの可能性はありません。</target>
        </trans-unit>
        <trans-unit id="a4d1c1dcdd2afe763b414a4824111916d472be49" translate="yes" xml:space="preserve">
          <source>In order to switch to RESP3 a script should call this function:</source>
          <target state="translated">RESP3 に切り替えるには、スクリプトはこの関数を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="40403839cd4ec5549ce4c8b0b88fe76bd596deee" translate="yes" xml:space="preserve">
          <source>In other words there is a one-to-one conversion between Lua and Redis types. The following table shows you all the conversions rules:</source>
          <target state="translated">つまり、LuaとRedisの型の間には一対一の変換があります。以下の表は、すべての変換ルールを示しています。</target>
        </trans-unit>
        <trans-unit id="b63d884600898ba55bb1960529b41996e05a6f02" translate="yes" xml:space="preserve">
          <source>In practical terms, Redis databases should be used to separate different keys belonging to the same application (if needed), and not to use a single Redis instance for multiple unrelated applications.</source>
          <target state="translated">現実的には、Redisデータベースは、(必要に応じて)同じアプリケーションに属する異なるキーを分離するために使用し、関連性のない複数のアプリケーションに単一のRedisインスタンスを使用しないようにすべきです。</target>
        </trans-unit>
        <trans-unit id="73283192b40f30e6bf23bca973e203da21ec7a06" translate="yes" xml:space="preserve">
          <source>In practical terms, Redis databases should mainly used in order to, if needed, separate different keys belonging to the same application, and not in order to use a single Redis instance for multiple unrelated applications.</source>
          <target state="translated">実用的には、Redisデータベースは主に、必要に応じて同じアプリケーションに属する異なる鍵を分離するために使用されるべきであり、1つのRedisインスタンスを関連性のない複数のアプリケーションに使用するために使用されるべきではありません。</target>
        </trans-unit>
        <trans-unit id="1cb1bb56f86e93948082da017865db052e971cd7" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;COUNT&lt;/code&gt; option documentation, we state that sometimes this family of commands may return all the elements of a Set, Hash or Sorted Set at once in a single call, regardless of the &lt;code&gt;COUNT&lt;/code&gt; option value. The reason why this happens is that the cursor-based iterator can be implemented, and is useful, only when the aggregate data type that we are scanning is represented as an hash table. However Redis uses a &lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;memory optimization&lt;/a&gt; where small aggregate data types, until they reach a given amount of items or a given max size of single elements, are represented using a compact single-allocation packed encoding. When this is the case, &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; has no meaningful cursor to return, and must iterate the whole data structure at once, so the only sane behavior it has is to return everything in a call.</source>
          <target state="translated">では &lt;code&gt;COUNT&lt;/code&gt; の時々コマンドのこの家族は関係なく、単一の呼び出しで一度に設定し、ハッシュまたはソートセットのすべての要素を返すことがオプションのマニュアル、我々の状態 &lt;code&gt;COUNT&lt;/code&gt; のオプション値。これが発生する理由は、カーソルベースのイテレータを実装でき、スキャンする集計データ型がハッシュテーブルとして表される場合にのみ有用であるためです。ただし、Redisは&lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;メモリの最適化を&lt;/a&gt;使用して、特定のアイテム数または単一の要素の特定の最大サイズに達するまで、小さな集計データ型をコンパクトな単一割り当てのパックエンコーディングを使用して表現します。この場合、&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 返す意味のあるカーソルはなく、一度にデータ構造全体を反復処理する必要があるため、呼び出しですべてを返すのが唯一の正常な動作です。</target>
        </trans-unit>
        <trans-unit id="8c0e05b70b67e4b92ac3373b78b09162115732be" translate="yes" xml:space="preserve">
          <source>In the above case the entry &lt;code&gt;1526985054069-0&lt;/code&gt; exists, otherwise the server would have sent us the next one. Using &lt;code&gt;COUNT&lt;/code&gt; is also the base in order to use &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; as an iterator.</source>
          <target state="translated">上記の場合、エントリ &lt;code&gt;1526985054069-0&lt;/code&gt; が存在します。それ以外の場合、サーバーは次のエントリを送信します。使用 &lt;code&gt;COUNT&lt;/code&gt; はまた、使用するために塩基である&lt;a href=&quot;xrange&quot;&gt;XRANGEを&lt;/a&gt;イテレータとして。</target>
        </trans-unit>
        <trans-unit id="f40be215733bf9374d8b827188eeddff85363cc0" translate="yes" xml:space="preserve">
          <source>In the above example of counting days, even after 10 years the application is online we still have just &lt;code&gt;365*10&lt;/code&gt; bits of data per user, that is just 456 bytes per user. With this amount of data &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; is still as fast as any other O(1) Redis command like &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; or &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;.</source>
          <target state="translated">上記の日数を数える例では、アプリケーションがオンラインになった後10年経過しても、ユーザーあたりのデータは &lt;code&gt;365*10&lt;/code&gt; ビットであり、ユーザーあたりのバイト数は456バイトです。このデータ量でも、&lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt;は、&lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt;や&lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;などの他のO（1）Redisコマンドと同じくらい高速です。</target>
        </trans-unit>
        <trans-unit id="76a0365bc0972ed4321b2f354ddf621810b8b004" translate="yes" xml:space="preserve">
          <source>In the above example we claim the message with ID &lt;code&gt;1526569498055-0&lt;/code&gt;, only if the message is idle for at least one hour without the original consumer or some other consumer making progresses (acknowledging or claiming it), and assigns the ownership to the consumer &lt;code&gt;Alice&lt;/code&gt;.</source>
          <target state="translated">上記の例では、メッセージがID &lt;code&gt;1526569498055-0&lt;/code&gt; であると主張します。メッセージが少なくとも1時間アイドル状態で、元のコンシューマーまたは他のコンシューマーが進行（承認または主張）していない場合に限り、所有権をコンシューマー &lt;code&gt;Alice&lt;/code&gt; に割り当てます。。</target>
        </trans-unit>
        <trans-unit id="0bef89cf285951fc9b88c842b027336864d10794" translate="yes" xml:space="preserve">
          <source>In the above example you can see that the reported information are the number of elements of the stream, details about the radix tree representing the stream mostly useful for optimization and debugging tasks, the number of consumer groups associated with the stream, the last generated ID that may not be the same as the last entry ID in case some entry was deleted. Finally the full first and last entry in the stream are shown, in order to give some sense about what is the stream content.</source>
          <target state="translated">上記の例では、ストリームの要素数、ストリームを表す基底木の詳細、ストリームに関連付けられたコンシューマグループの数、最後に生成された ID (エントリが削除された場合には最後のエントリ ID と同じではない可能性があります)が報告されていることがわかります。最後に、ストリームの完全な最初のエントリと最後のエントリが表示され、ストリームの内容が何であるかを知ることができます。</target>
        </trans-unit>
        <trans-unit id="5e1f5dbd04f5dc1db0a038c0d0e6f0ff4a4acd34" translate="yes" xml:space="preserve">
          <source>In the above locking algorithm there is a problem: what happens if a client fails, crashes, or is otherwise not able to release the lock? It's possible to detect this condition because the lock key contains a UNIX timestamp. If such a timestamp is equal to the current Unix time the lock is no longer valid.</source>
          <target state="translated">上記のロックアルゴリズムには問題があります:クライアントが失敗したり、クラッシュしたり、 ロックを解除できなかったりした場合はどうなるのでしょうか? ロックキーにはUNIXタイムスタンプが含まれているので、この状態を検出することができます。そのようなタイムスタンプが現在の Unix 時間と等しい場合、ロックはもはや有効ではありません。</target>
        </trans-unit>
        <trans-unit id="7063c49f04f76f5d83a38b2826e82b8706b19e78" translate="yes" xml:space="preserve">
          <source>In the case of &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt;, keys are every other position so the step value is 2. Compare with &lt;a href=&quot;mget&quot;&gt;MGET&lt;/a&gt; above where the step value is just 1.</source>
          <target state="translated">&lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt;の場合、キーは1つおきの位置にあるため、ステップ値は2です。ステップ値が1である上記の&lt;a href=&quot;mget&quot;&gt;MGETと&lt;/a&gt;比較してください。</target>
        </trans-unit>
        <trans-unit id="51cf6b9278dbdee20c8485961f1e557cd7119742" translate="yes" xml:space="preserve">
          <source>In the context of a node that has received a &lt;code&gt;DELSLOTS&lt;/code&gt; command and has consequently removed the associations for the passed hash slots, we say those hash slots are &lt;em&gt;unbound&lt;/em&gt;. Note that the existence of unbound hash slots occurs naturally when a node has not been configured to handle them (something that can be done with the &lt;code&gt;ADDSLOTS&lt;/code&gt; command) and if it has not received any information about who owns those hash slots (something that it can learn from heartbeat or update messages).</source>
          <target state="translated">&lt;code&gt;DELSLOTS&lt;/code&gt; コマンドを受信し、その結果、渡されたハッシュスロットの関連付けが削除されたノードのコンテキストでは、それらのハッシュスロットは&lt;em&gt;バインドされてい&lt;/em&gt;ませ&lt;em&gt;ん&lt;/em&gt;。バインドされていないハッシュスロットの存在は、ノードがそれらを処理するように構成されていない場合（ &lt;code&gt;ADDSLOTS&lt;/code&gt; コマンドで実行できるもの）、およびそれらのハッシュスロットの所有者に関する情報（受信可能なもの）を受信して​​いない場合に自然に発生します。ハートビートまたは更新メッセージから学ぶ）。</target>
        </trans-unit>
        <trans-unit id="0c3893e92cc9396f13c9f99b5e7ad611d2ac46c2" translate="yes" xml:space="preserve">
          <source>In the context of a stream consumer group, this command changes the ownership of a pending message, so that the new owner is the consumer specified as the command argument. Normally this is what happens:</source>
          <target state="translated">ストリーム・コンシューマ・グループのコンテキストでは、このコマンドは保留中のメッセージの所有者を変更し、新しい所有者はコマンド引数で指定されたコンシューマになります。通常はこのようになります。</target>
        </trans-unit>
        <trans-unit id="57bf1b4701a5c94880ee6e46bfe56ac8c7000db8" translate="yes" xml:space="preserve">
          <source>In the example above, the first call uses zero as a cursor, to start the iteration. The second call uses the cursor returned by the previous call as the first element of the reply, that is, 17.</source>
          <target state="translated">上の例では、最初の呼び出しではゼロをカーソルとして使用して反復を開始します。2回目の呼び出しでは、前の呼び出しで返されたカーソルを応答の最初の要素、つまり17として使用します。</target>
        </trans-unit>
        <trans-unit id="64f37e2cb3f5829eb3ba5c3a4f7f3eea2d872acc" translate="yes" xml:space="preserve">
          <source>In the extended form we no longer see the summary information, instead there are detailed information for each message in the pending entries list. For each message four attributes are returned:</source>
          <target state="translated">拡張されたフォームでは、要約情報は表示されなくなり、代わりに保留中のエントリリストの各メッセージの詳細情報が表示されます。各メッセージに対して、4つの属性が返されます。</target>
        </trans-unit>
        <trans-unit id="611f148b8dfb6f6978d2aeb35216b9ff55929cae" translate="yes" xml:space="preserve">
          <source>In the extended form we no longer see the summary information, instead there is detailed information for each message in the pending entries list. For each message four attributes are returned:</source>
          <target state="translated">拡張されたフォームでは、要約情報は表示されなくなり、代わりに保留中のエントリリストの各メッセージの詳細情報が表示されます。各メッセージに対して、4つの属性が返されます。</target>
        </trans-unit>
        <trans-unit id="bec3c889a89e0a9bff423ca26bc6e8f597b12b82" translate="yes" xml:space="preserve">
          <source>In the following example the first call to &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; does not use a timeout and asks for the write to reach 1 replica. It returns with success. In the second attempt instead we put a timeout, and ask for the replication of the write to two replicas. Since there is a single replica available, after one second &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; unblocks and returns 1, the number of replicas reached.</source>
          <target state="translated">次の例では、&lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;への最初の呼び出しはタイムアウトを使用せず、1つのレプリカに到達するための書き込みを要求します。成功して帰ってきました。代わりに、2回目の試行でタイムアウトを設定し、2つのレプリカへの書き込みのレプリケーションを要求します。使用可能なレプリカが1つあるため、1秒の&lt;a href=&quot;wait&quot;&gt;WAITが&lt;/a&gt;ブロックを解除して1を返した後、レプリカの数に達しました。</target>
        </trans-unit>
        <trans-unit id="8e23d6a61281506fa3e98f414bcf348728e15107" translate="yes" xml:space="preserve">
          <source>In the following example we can see how floats and arrays containing nils and keys are handled:</source>
          <target state="translated">次の例では、ニルスとキーを含む浮動小数点演算子と配列がどのように処理されるかを見ることができます。</target>
        </trans-unit>
        <trans-unit id="275502ca7bb30b2b024cd13d4001c3a1615096d6" translate="yes" xml:space="preserve">
          <source>In the following example we can see how floats and arrays with nils are handled:</source>
          <target state="translated">次の例では、nilsを持つfloatと配列がどのように処理されるかを見ることができます。</target>
        </trans-unit>
        <trans-unit id="67aa25f5afe2285456ce925944008c892a8bde6a" translate="yes" xml:space="preserve">
          <source>In the following example we'll show why the command must not just remove a given node from the nodes table, but also prevent it for being re-inserted again for some time.</source>
          <target state="translated">以下の例では、コマンドがノードテーブルから指定されたノードを削除するだけでなく、それがしばらくの間再挿入されないようにする必要がある理由を示します。</target>
        </trans-unit>
        <trans-unit id="1b27ba03d8db2c5155774200622adb0e3f3e2724" translate="yes" xml:space="preserve">
          <source>In the following example you can see how the encoding changes once Redis is no longer able to use the space saving encoding.</source>
          <target state="translated">以下の例では、Redisが省スペースエンコーディングを使用できなくなった後、エンコーディングがどのように変化するかを見ることができます。</target>
        </trans-unit>
        <trans-unit id="d52481dfbaf58234ade345bdada825c509d89e9a" translate="yes" xml:space="preserve">
          <source>In the specific case of the implementation of &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;, Redis remembers, for each client, the replication offset of the produced replication stream when a given write command was executed in the context of a given client. When &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; is called Redis checks if the specified number of replicas already acknowledged this offset or a greater one.</source>
          <target state="translated">&lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;の実装の特定のケースでは、Redisは各クライアントについて、特定のクライアントのコンテキストで特定の書き込みコマンドが実行されたときに生成されたレプリケーションストリームのレプリケーションオフセットを記憶しています。とき&lt;a href=&quot;wait&quot;&gt;WAITは、&lt;/a&gt;レプリカの指定された数は既にこのオフセット以上のものを認めた場合はRedisのチェックと呼ばれています。</target>
        </trans-unit>
        <trans-unit id="903ead95cd2a4a5b9cbb852a8e750aedc79fee51" translate="yes" xml:space="preserve">
          <source>In this case, &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; will auto-complete the start interval with &lt;code&gt;-0&lt;/code&gt; and end interval with &lt;code&gt;-18446744073709551615&lt;/code&gt;, in order to return all the entries that were generated between a given millisecond and the end of the other specified millisecond. This also means that repeating the same millisecond two times, we get all the entries within such millisecond, because the sequence number range will be from zero to the maximum.</source>
          <target state="translated">この場合、&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;は、指定されたミリ秒から指定された他のミリ秒の終わりまでの間に生成されたすべてのエントリを返すために、開始間隔を &lt;code&gt;-0&lt;/code&gt; で、終了間隔を &lt;code&gt;-18446744073709551615&lt;/code&gt; で自動補完します。これは、同じミリ秒を2回繰り返すと、シーケンス番号の範囲がゼロから最大になるため、そのようなミリ秒以内にすべてのエントリを取得することも意味します。</target>
        </trans-unit>
        <trans-unit id="9a9dd8640d5d9c354f3497144f8f471bfe5130bf" translate="yes" xml:space="preserve">
          <source>In this form the command returns general information about the stream stored at the specified key.</source>
          <target state="translated">この形式では、コマンドは指定されたキーに格納されているストリームに関する一般的な情報を返します。</target>
        </trans-unit>
        <trans-unit id="fb6df0247f8ef1848f5f3284e1802dec98219082" translate="yes" xml:space="preserve">
          <source>In this form the command returns the entire state of the stream, including entries, groups, consumers and PELs. This form is available since Redis 6.0.</source>
          <target state="translated">この形式では、コマンドは、エントリ、グループ、コンシューマ、PELを含むストリーム全体の状態を返します。この形式は Redis 6.0 以降で利用可能です。</target>
        </trans-unit>
        <trans-unit id="d9dc316159e0ab75070b1301d7b7adb86e569cda" translate="yes" xml:space="preserve">
          <source>In this form we just get as output all the consumer groups associated with the stream:</source>
          <target state="translated">この形式では、ストリームに関連付けられたすべての消費者グループを出力として取得するだけです。</target>
        </trans-unit>
        <trans-unit id="ddaa9f098110e2f5ed979aa965f072762268f6b4" translate="yes" xml:space="preserve">
          <source>In this form, the command outputs the total number of pending messages for this consumer group, which is one, followed by the smallest and greatest ID among the pending messages, and then list every consumer in the consumer group with at least one pending message, and the number of pending messages it has.</source>
          <target state="translated">本実施形態では、コマンドは、このコンシューマ・グループの保留メッセージの合計数を1とし、保留メッセージの中で最も小さいIDと最も大きいIDの後に、保留メッセージが少なくとも1つあるコンシューマ・グループ内の全てのコンシューマをリストアップし、それが持っている保留メッセージの数を出力する。</target>
        </trans-unit>
        <trans-unit id="7449f50cc271410bffecdb508cde8a6a6c5d9a68" translate="yes" xml:space="preserve">
          <source>In this particular case, running a single &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; client can reduce the throughput by more than 50%. Running more &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; clients will reduce throughput even more.</source>
          <target state="translated">この特定のケースでは、単一の&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;クライアントを実行すると、スループットが50％以上減少する可能性があります。より多くの&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;クライアントを実行すると、スループットがさらに低下します。</target>
        </trans-unit>
        <trans-unit id="9499b337b96eb666a58f2a5ab4a4329e2007a622" translate="yes" xml:space="preserve">
          <source>In this replication mode, while Lua scripts are executed, Redis collects all the commands executed by the Lua scripting engine that actually modify the dataset. When the script execution finishes, the sequence of commands that the script generated are wrapped into a MULTI / EXEC transaction and are sent to replicas and AOF.</source>
          <target state="translated">このレプリケーションモードでは、Luaスクリプトが実行されている間、RedisはLuaスクリプトエンジンが実行したコマンドのうち、実際にデータセットを修正するものをすべて収集します。スクリプトの実行が終了すると、スクリプトが生成した一連のコマンドはMULTI/EXECトランザクションにラップされ、レプリカやAOFに送信されます。</target>
        </trans-unit>
        <trans-unit id="9c59d992fdad2d2103f7862e5997a95c45fa8f53" translate="yes" xml:space="preserve">
          <source>In this way the example consumer code will fetch only new messages, process them, and acknowledge them via &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;. However the example code above is not complete, because it does not handle recovering after a crash. What will happen if we crash in the middle of processing messages, is that our messages will remain in the pending entries list, so we can access our history by giving &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; initially an ID of 0, and performing the same loop. Once providing an ID of 0 the reply is an empty set of messages, we know that we processed and acknowledged all the pending messages: we can start to use &lt;code&gt;&amp;gt;&lt;/code&gt; as ID, in order to get the new messages and rejoin the consumers that are processing new things.</source>
          <target state="translated">このように、サンプルのコンシューマーコードは、新しいメッセージのみをフェッチして処理し、&lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;を介してそれらを確認します。ただし、上記のサンプルコードは、クラッシュ後の回復を処理しないため、完全ではありません。メッセージの処理中にクラッシュした場合は、メッセージが保留中のエントリリストに残るため、&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUPに&lt;/a&gt;最初にID 0を指定し、同じループを実行することで履歴にアクセスできます。 ID 0を指定すると、応答は空のメッセージセットになり、保留中のすべてのメッセージを処理して確認応答したことがわかります。新しいメッセージを取得して処理中のコンシューマーに再参加するために、IDとして &lt;code&gt;&amp;gt;&lt;/code&gt; の使用を開始できます。新しいもの。</target>
        </trans-unit>
        <trans-unit id="ef44dcb3d65131c01d1f4f06af638521f8511b76" translate="yes" xml:space="preserve">
          <source>In this way the example consumer code will fetch only new messages, process them, and acknowledge them via &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;. However the example code above is not complete, because it does not handle recovering after a crash. What will happen if we crash in the middle of processing messages, is that our messages will remain in the pending entries list, so we can access our history by giving &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; initially an ID of 0, and performing the same loop. Once providing and ID of 0 the reply is an empty set of messages, we know that we processed and acknowledged all the pending messages: we can start to use &lt;code&gt;&amp;gt;&lt;/code&gt; as ID, in order to get the new messages and rejoin the consumers that are processing new things.</source>
          <target state="translated">このようにして、サンプルのコンシューマコードは新しいメッセージのみをフェッチし、それらを処理して、&lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;を介してそれらを確認します。ただし、上記のサンプルコードは、クラッシュ後の回復を処理しないため、完全ではありません。メッセージの処理中にクラッシュした場合、メッセージは保留中のエントリのリストに残るため、最初に&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;に0のIDを指定し、同じループを実行することで履歴にアクセスできます。 IDが0になると、応答は空のメッセージセットになります。保留中のすべてのメッセージを処理して確認したことがわかります。 &lt;code&gt;&amp;gt;&lt;/code&gt; をIDとして使用して、新しいメッセージを取得し、処理中のコンシューマーに再参加できます。新しいもの。</target>
        </trans-unit>
        <trans-unit id="0c6aff080ab580caca11c078c7c0fd0c074cc4b5" translate="yes" xml:space="preserve">
          <source>In this way when a node in migrating state generates an &lt;code&gt;ASK&lt;/code&gt; redirection, the client contacts the target node, sends &lt;code&gt;ASKING&lt;/code&gt;, and immediately after sends the command. This way commands about non-existing keys in the old node or keys already migrated to the target node are executed in the target node, so that:</source>
          <target state="translated">このようにして、移行状態のノードが &lt;code&gt;ASK&lt;/code&gt; リダイレクトを生成すると、クライアントはターゲットノードに接続し、 &lt;code&gt;ASKING&lt;/code&gt; を送信し、直後にコマンドを送信します。このようにして、古いノードに存在しないキーまたはターゲットノードに既に移行されたキーに関するコマンドがターゲットノードで実行され、次のようになります。</target>
        </trans-unit>
        <trans-unit id="8a4976fd385ad81414ef5f0b5eb1d542ebee200c" translate="yes" xml:space="preserve">
          <source>Incomplete IDs</source>
          <target state="translated">不完全なID</target>
        </trans-unit>
        <trans-unit id="d076531fdc3e2f8747b11778603627c7ff4c3c03" translate="yes" xml:space="preserve">
          <source>Increment the specified &lt;code&gt;field&lt;/code&gt; of a hash stored at &lt;code&gt;key&lt;/code&gt;, and representing a floating point number, by the specified &lt;code&gt;increment&lt;/code&gt;. If the increment value is negative, the result is to have the hash field value &lt;strong&gt;decremented&lt;/strong&gt; instead of incremented. If the field does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if one of the following conditions occur:</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納され、浮動小数点数を表すハッシュの指定された &lt;code&gt;field&lt;/code&gt; を、指定された &lt;code&gt;increment&lt;/code&gt; だけ増分します。増分値が負の場合、結果はハッシュフィールド値が増分されるのではなく&lt;strong&gt;減分さ&lt;/strong&gt;れます。フィールドが存在しない場合は、操作を実行する前に &lt;code&gt;0&lt;/code&gt; に設定されます。次のいずれかの条件が発生すると、エラーが返されます。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0b2569a3073ebcb62549ecb7ec5a99e5e6f20a57" translate="yes" xml:space="preserve">
          <source>Increment the string representing a floating point number stored at &lt;code&gt;key&lt;/code&gt; by the specified &lt;code&gt;increment&lt;/code&gt;. By using a negative &lt;code&gt;increment&lt;/code&gt; value, the result is that the value stored at the key is decremented (by the obvious properties of addition). If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if one of the following conditions occur:</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されている浮動小数点数を表す文字列を、指定された &lt;code&gt;increment&lt;/code&gt; 。負の &lt;code&gt;increment&lt;/code&gt; を使用すると、キーに格納された値が（明らかな加算特性により）減ります。キーが存在しない場合は、操作を実行する前に &lt;code&gt;0&lt;/code&gt; に設定されます。次のいずれかの条件が発生すると、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="b0ab00f78f69567a82e2e724fbf2c011708c66b2" translate="yes" xml:space="preserve">
          <source>Increments the number stored at &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;increment&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created. If &lt;code&gt;field&lt;/code&gt; does not exist the value is set to &lt;code&gt;0&lt;/code&gt; before the operation is performed.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているハッシュの &lt;code&gt;field&lt;/code&gt; に格納されている数を &lt;code&gt;increment&lt;/code&gt; だけ増分します。 &lt;code&gt;key&lt;/code&gt; が存在しない場合は、ハッシュを保持する新しいキーが作成されます。場合は &lt;code&gt;field&lt;/code&gt; 値が存在しないに設定されて &lt;code&gt;0&lt;/code&gt; 操作が実行される前に。</target>
        </trans-unit>
        <trans-unit id="05fa8f17b5cc5360627e65f0e1bfbcb74f909616" translate="yes" xml:space="preserve">
          <source>Increments the number stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;increment&lt;/code&gt;. If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers.</source>
          <target state="translated">格納されている番号インクリメント &lt;code&gt;key&lt;/code&gt; により &lt;code&gt;increment&lt;/code&gt; 。キーが存在しない場合は、操作を実行する前に &lt;code&gt;0&lt;/code&gt; に設定されます。キーに誤ったタイプの値が含まれている場合、または整数として表現できない文字列が含まれている場合は、エラーが返されます。この操作は64ビットの符号付き整数に制限されています。</target>
        </trans-unit>
        <trans-unit id="f9bd9898aaa3a2048914100ede9b89ccf7adc73a" translate="yes" xml:space="preserve">
          <source>Increments the number stored at &lt;code&gt;key&lt;/code&gt; by one. If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されている数を1 増やします。キーが存在しない場合は、操作を実行する前に &lt;code&gt;0&lt;/code&gt; に設定されます。キーに誤ったタイプの値が含まれている場合、または整数として表現できない文字列が含まれている場合は、エラーが返されます。この操作は64ビットの符号付き整数に制限されています。</target>
        </trans-unit>
        <trans-unit id="b3b4497f3f9f641c1f07a98ba2294810e7c1c3a5" translate="yes" xml:space="preserve">
          <source>Increments the score of &lt;code&gt;member&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;increment&lt;/code&gt;. If &lt;code&gt;member&lt;/code&gt; does not exist in the sorted set, it is added with &lt;code&gt;increment&lt;/code&gt; as its score (as if its previous score was &lt;code&gt;0.0&lt;/code&gt;). If &lt;code&gt;key&lt;/code&gt; does not exist, a new sorted set with the specified &lt;code&gt;member&lt;/code&gt; as its sole member is created.</source>
          <target state="translated">増分のスコア &lt;code&gt;member&lt;/code&gt; に格納されたソートセット内 &lt;code&gt;key&lt;/code&gt; によって &lt;code&gt;increment&lt;/code&gt; 。場合 &lt;code&gt;member&lt;/code&gt; ソートセットに存在しない、それが付加され &lt;code&gt;increment&lt;/code&gt; （以前のスコアであったかのようにそのスコアとして &lt;code&gt;0.0&lt;/code&gt; ）。 &lt;code&gt;key&lt;/code&gt; が存在しない場合は、指定された &lt;code&gt;member&lt;/code&gt; を唯一のメンバーとする新しいソートセットが作成されます。</target>
        </trans-unit>
        <trans-unit id="b9e98de9b6972c3697024196bb1cf498f5df1583" translate="yes" xml:space="preserve">
          <source>Information about slots propagation and warnings</source>
          <target state="translated">スロットの伝播と警告に関する情報</target>
        </trans-unit>
        <trans-unit id="2adcb9298d658f855997a0893baf52120d4879fe" translate="yes" xml:space="preserve">
          <source>Initiates a replication stream from the master.</source>
          <target state="translated">マスターからのレプリケーション・ストリームを開始します。</target>
        </trans-unit>
        <trans-unit id="df92aa3b0e06eb79bf7c8f7098db769523ac9333" translate="yes" xml:space="preserve">
          <source>Insert all the specified values at the head of the list stored at &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, it is created as empty list before performing the push operations. When &lt;code&gt;key&lt;/code&gt; holds a value that is not a list, an error is returned.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているリストの先頭に、指定されたすべての値を挿入します。 &lt;code&gt;key&lt;/code&gt; が存在しない場合は、プッシュ操作を実行する前に空のリストとして作成されます。ときに &lt;code&gt;key&lt;/code&gt; リストではない値を保持し、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="d56f1eeeec0b6889ab12fc76a629d9cf4f377993" translate="yes" xml:space="preserve">
          <source>Insert all the specified values at the tail of the list stored at &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, it is created as empty list before performing the push operation. When &lt;code&gt;key&lt;/code&gt; holds a value that is not a list, an error is returned.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているリストの末尾に、指定されたすべての値を挿入します。 &lt;code&gt;key&lt;/code&gt; が存在しない場合は、プッシュ操作を実行する前に空のリストとして作成されます。ときに &lt;code&gt;key&lt;/code&gt; リストではない値を保持し、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="76405c7e5205b84962c7bcad1e955500c9c01bf2" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;element&lt;/code&gt; in the list stored at &lt;code&gt;key&lt;/code&gt; either before or after the reference value &lt;code&gt;pivot&lt;/code&gt;.</source>
          <target state="translated">参照値 &lt;code&gt;pivot&lt;/code&gt; 前または後に、 &lt;code&gt;key&lt;/code&gt; 格納されているリストに &lt;code&gt;element&lt;/code&gt; を挿入します。</target>
        </trans-unit>
        <trans-unit id="41914bb38b36cf790ad6dea5c850ff4f739bdf2f" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; at the head of the list stored at &lt;code&gt;key&lt;/code&gt;, only if &lt;code&gt;key&lt;/code&gt; already exists and holds a list. In contrary to &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;, no operation will be performed when &lt;code&gt;key&lt;/code&gt; does not yet exist.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているリストの先頭に &lt;code&gt;value&lt;/code&gt; を挿入します。ただし、 &lt;code&gt;key&lt;/code&gt; がすでに存在し、リストを保持している場合のみです。反して&lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;とき、何も操作は行われません &lt;code&gt;key&lt;/code&gt; まだ存在していません。</target>
        </trans-unit>
        <trans-unit id="483c4cdd37e1303cef072b494af9c173f5ba1e3a" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; at the tail of the list stored at &lt;code&gt;key&lt;/code&gt;, only if &lt;code&gt;key&lt;/code&gt; already exists and holds a list. In contrary to &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;, no operation will be performed when &lt;code&gt;key&lt;/code&gt; does not yet exist.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; に格納されているリストの末尾に &lt;code&gt;value&lt;/code&gt; を挿入します。ただし、 &lt;code&gt;key&lt;/code&gt; が既に存在し、リストを保持している場合のみです。&lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;とは逆に、 &lt;code&gt;key&lt;/code&gt; がまだ存在しない場合は何も実行されません。</target>
        </trans-unit>
        <trans-unit id="d817081530a979658954b262ec5b27debd913f6b" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; in the list stored at &lt;code&gt;key&lt;/code&gt; either before or after the reference value &lt;code&gt;pivot&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 格納されているリストの &lt;code&gt;value&lt;/code&gt; を、参照値 &lt;code&gt;pivot&lt;/code&gt; 前または後に挿入します。</target>
        </trans-unit>
        <trans-unit id="5796a562198c08a1669595d2cc6b1a7851ecca7f" translate="yes" xml:space="preserve">
          <source>Inserts specified values at the head of the list stored at &lt;code&gt;key&lt;/code&gt;, only if &lt;code&gt;key&lt;/code&gt; already exists and holds a list. In contrary to &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;, no operation will be performed when &lt;code&gt;key&lt;/code&gt; does not yet exist.</source>
          <target state="translated">挿入はで保存され、リストの先頭に値を指定した &lt;code&gt;key&lt;/code&gt; 場合にのみ、 &lt;code&gt;key&lt;/code&gt; すでに存在し、リストを保持しています。反して&lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;とき、何も操作は行われません &lt;code&gt;key&lt;/code&gt; まだ存在していません。</target>
        </trans-unit>
        <trans-unit id="ea8b02564feb5003f96c3e70699d8d56ef9971fc" translate="yes" xml:space="preserve">
          <source>Inserts specified values at the tail of the list stored at &lt;code&gt;key&lt;/code&gt;, only if &lt;code&gt;key&lt;/code&gt; already exists and holds a list. In contrary to &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;, no operation will be performed when &lt;code&gt;key&lt;/code&gt; does not yet exist.</source>
          <target state="translated">挿入はで保存され、リストの末尾に値を指定した &lt;code&gt;key&lt;/code&gt; 場合にのみ、 &lt;code&gt;key&lt;/code&gt; すでに存在し、リストを保持しています。反して&lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;とき、何も操作は行われません &lt;code&gt;key&lt;/code&gt; まだ存在していません。</target>
        </trans-unit>
        <trans-unit id="0b2cd21b122572712ccbe21dcfb324c039d60a6f" translate="yes" xml:space="preserve">
          <source>Instead Redis 2.4 works in a different way: clients are served &lt;em&gt;in the context&lt;/em&gt; of the push operation, so as long as &lt;code&gt;LPUSH foo a b c&lt;/code&gt; starts pushing the first element to the list, it will be delivered to the Client &lt;strong&gt;A&lt;/strong&gt;, that will receive &lt;code&gt;a&lt;/code&gt; (the first element pushed).</source>
          <target state="translated">別の方法で代わりのRedis 2.4作品：クライアントが提供されている&lt;em&gt;文脈に&lt;/em&gt;そう限り、プッシュ操作の &lt;code&gt;LPUSH foo a b c&lt;/code&gt; 、リストの最初の要素をプッシュ開始し、それがクライアントに配信されます&lt;strong&gt;A&lt;/strong&gt;、受け取ることになります（プッシュされた最初の要素）。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="895d5878b1e7aebe2b652bf4030490cc648a385d" translate="yes" xml:space="preserve">
          <source>Instead of releasing the lock with &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;, send a script that only removes the key if the value matches.</source>
          <target state="translated">&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;でロックを解除する代わりに、値が一致した場合にのみキーを削除するスクリプトを送信します。</target>
        </trans-unit>
        <trans-unit id="e1fb6600644f1089e2f02671b1d169470ef167d3" translate="yes" xml:space="preserve">
          <source>Instead of setting a fixed string, set a non-guessable large random string, called token.</source>
          <target state="translated">固定文字列を設定する代わりに、トークンと呼ばれる推測不可能な大きなランダム文字列を設定します。</target>
        </trans-unit>
        <trans-unit id="7e8138295a5156481cc0eb58921ff5f1b45d907b" translate="yes" xml:space="preserve">
          <source>Instead, if the lock is expired because the Unix time at &lt;code&gt;lock.foo&lt;/code&gt; is older than the current Unix time, C4 tries to perform:</source>
          <target state="translated">代わりに、 &lt;code&gt;lock.foo&lt;/code&gt; のUnix時間が現在のUnix時間より古いためにロックが期限切れになった場合、C4は次のことを実行しようとします。</target>
        </trans-unit>
        <trans-unit id="9e41d77e11789212e3a04485592bea0019722472" translate="yes" xml:space="preserve">
          <source>Instruct Redis to start an &lt;a href=&quot;https://redis.io/topics/persistence#append-only-file&quot;&gt;Append Only File&lt;/a&gt; rewrite process. The rewrite will create a small optimized version of the current Append Only File.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/persistence#append-only-file&quot;&gt;追加のみのファイルの&lt;/a&gt;書き換えプロセスを開始するようにRedisに指示します。書き換えにより、現在の追加専用ファイルの小さな最適化バージョンが作成されます。</target>
        </trans-unit>
        <trans-unit id="5d3a484e0575c563f1fd55a805b93fd40c42e60d" translate="yes" xml:space="preserve">
          <source>Integer reply</source>
          <target state="translated">整数応答</target>
        </trans-unit>
        <trans-unit id="b78aed63c34c1be3f06c6bc59978ffe5ffe055ac" translate="yes" xml:space="preserve">
          <source>Introduction to EVAL</source>
          <target state="translated">エバールの紹介</target>
        </trans-unit>
        <trans-unit id="698c191721344bee0279a531fba2023586cfe9e4" translate="yes" xml:space="preserve">
          <source>It can also take the following values:</source>
          <target state="translated">また、以下の値を取ることもできます。</target>
        </trans-unit>
        <trans-unit id="35178e7f69534d7802151005b608f5f33b33d650" translate="yes" xml:space="preserve">
          <source>It contains a 64-bit checksum that is used to make sure errors will be detected. The &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; command makes sure to check the checksum before synthesizing a key using the serialized value.</source>
          <target state="translated">エラーが確実に検出されるようにするために使用される64ビットのチェックサムが含まれています。&lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt;コマンドは、シリアル化された値を使用してキーを合成する前にチェックサムを確認してくださいます。</target>
        </trans-unit>
        <trans-unit id="d3cca1eb042dc5b5456d254387aa0bc9411f0e98" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;very important&lt;/strong&gt; to understand that you should use the &lt;code&gt;$&lt;/code&gt; ID only for the first call to &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt;. Later the ID should be the one of the last reported item in the stream, otherwise you could miss all the entries that are added in between.</source>
          <target state="translated">&lt;a href=&quot;xread&quot;&gt;XIDの&lt;/a&gt;最初の呼び出しにのみ &lt;code&gt;$&lt;/code&gt; ID を使用する必要があることを理解することは&lt;strong&gt;非常に重要&lt;/strong&gt;です。後で、IDはストリームで最後に報告された項目の1つになるはずです。そうしないと、間に追加されたすべてのエントリを見逃す可能性があります。</target>
        </trans-unit>
        <trans-unit id="80e58a0abe147b5052a4b292609ed6e990761a9f" translate="yes" xml:space="preserve">
          <source>It is also possible to &lt;code&gt;GET&lt;/code&gt; the element itself using the special pattern &lt;code&gt;#&lt;/code&gt;:</source>
          <target state="translated">特別なパターン &lt;code&gt;#&lt;/code&gt; を使用して要素自体を &lt;code&gt;GET&lt;/code&gt; することもできます。</target>
        </trans-unit>
        <trans-unit id="98ad7fac6612120c355f6682c4b1a531c848bd30" translate="yes" xml:space="preserve">
          <source>It is also possible to compute the LCS between the content of two keys:</source>
          <target state="translated">また、2つの鍵の内容の間でLCSを計算することも可能である。</target>
        </trans-unit>
        <trans-unit id="b33a1c4c42a6d6feaa0bef4f81f6ace9278b22e9" translate="yes" xml:space="preserve">
          <source>It is also possible to use the &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; and &lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt; string commands to efficiently access a range of bit offsets in a bitmap. Below is a sample implementation in idiomatic Redis Lua scripting that can be run with the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; command:</source>
          <target state="translated">&lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt;および&lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt;文字列コマンドを使用して、ビットマップ内のビットオフセットの範囲に効率的にアクセスすることもできます。以下は、&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;コマンドで実行できる慣用的なRedisLuaスクリプトのサンプル実装です。</target>
        </trans-unit>
        <trans-unit id="344f6904cadbf67817bc580b98a14096a5ecb81b" translate="yes" xml:space="preserve">
          <source>It is important to note that step 3 is the only time when a Redis Cluster node will create a new config epoch without agreement from other nodes. This only happens when a manual configuration is operated. However it is impossible that this creates a non-transient setup where two nodes have the same config epoch, since Redis Cluster uses a config epoch collision resolution algorithm.</source>
          <target state="translated">重要なのは、ステップ3はRedis Clusterノードが他のノードからの同意なしに新しいコンフィグエポックを作成するときだけであるということです。これは手動設定が操作された場合にのみ発生します。しかし、Redis Clusterがコンフィグエポック衝突解決アルゴリズムを使用しているため、これが2つのノードが同じコンフィグエポックを持つ非過渡的なセットアップを作成することは不可能です。</target>
        </trans-unit>
        <trans-unit id="75e2007346bb90c5a30dbb62b43b72fa8d6f2346" translate="yes" xml:space="preserve">
          <source>It is important to note that the &lt;strong&gt;MATCH&lt;/strong&gt; filter is applied after elements are retrieved from the collection, just before returning data to the client. This means that if the pattern matches very little elements inside the collection, &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; will likely return no elements in most iterations. An example is shown below:</source>
          <target state="translated">&lt;strong&gt;MATCH&lt;/strong&gt;フィルターは、要素がコレクションから取得された後、データをクライアントに返す直前に適用されることに注意してください。これは、パターンがコレクション内の非常に小さな要素と一致する場合、&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;はほとんどの反復で要素を返さない可能性が高いことを意味します。以下に例を示します。</target>
        </trans-unit>
        <trans-unit id="05004148ae7826284b52ac4960264eb06c78f9cd" translate="yes" xml:space="preserve">
          <source>It is important to note that the &lt;strong&gt;TYPE&lt;/strong&gt; filter is also applied after elements are retrieved from the database, so the option does not reduce the amount of work the server has to do to complete a full iteration, and for rare types you may receive no elements in many iterations.</source>
          <target state="translated">&lt;strong&gt;TYPE&lt;/strong&gt;フィルターは、要素がデータベースから取得された後にも適用されるため、このオプションは、サーバーが完全な反復を完了するために実行する必要のある作業量を削減せず、まれなタイプの場合、要素を受け取らない可能性があることに注意してください。多くの反復で。</target>
        </trans-unit>
        <trans-unit id="6a489978b872ba9db6fad974b8d4112fa3f8ddea" translate="yes" xml:space="preserve">
          <source>It is important to understand that this command &lt;em&gt;fans out&lt;/em&gt; to all the clients that are waiting for the same range of IDs, so every consumer will get a copy of the data, unlike to what happens when blocking list pop operations are used.</source>
          <target state="translated">このコマンドは、同じ範囲のIDを待機しているすべてのクライアントに&lt;em&gt;ファンアウト&lt;/em&gt;するため、ブロックリストポップ操作が使用されている場合とは異なり、すべてのコンシューマーがデータのコピーを取得することを理解することが重要です。</target>
        </trans-unit>
        <trans-unit id="c6bd66f1e8688cc2dae7b39af1276712b3930256" translate="yes" xml:space="preserve">
          <source>It is important to understand that this command is &lt;em&gt;fans out&lt;/em&gt; to all the clients that are waiting for the same range of IDs, so every consumer will get a copy of the data, unlike to what happens when blocking list pop operations are used.</source>
          <target state="translated">このコマンドは、同じ範囲のIDを待機しているすべてのクライアントに&lt;em&gt;ファンアウト&lt;/em&gt;するため、ブロッキングリストのポップ操作を使用した場合とは異なり、すべてのコンシューマーがデータのコピーを取得することを理解することが重要です。</target>
        </trans-unit>
        <trans-unit id="c855a69b0dba328dc98ac3bd3b714e220d6e64d4" translate="yes" xml:space="preserve">
          <source>It is never repeated, so if &lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt; returns the same number, the caller can be sure that the underlying client did not disconnect and reconnect the connection, but it is still the same connection.</source>
          <target state="translated">これが繰り返されることはないため、&lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt;が同じ番号を返す場合、呼び出し元は、基礎となるクライアントが接続を切断して再接続しなかったことを確認できますが、それでも同じ接続です。</target>
        </trans-unit>
        <trans-unit id="18c6232a5064b912687168695e794e952ea903ef" translate="yes" xml:space="preserve">
          <source>It is not possible for the key to get lost in the event of a timeout, but the client calling &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt;, in the event of a timeout error, should check if the key is &lt;em&gt;also&lt;/em&gt; present in the target instance and act accordingly.</source>
          <target state="translated">タイムアウトが発生したときにキーが失われることはありませんが、タイムアウトエラーが発生した場合に&lt;a href=&quot;migrate&quot;&gt;MIGRATEを&lt;/a&gt;呼び出すクライアントは、キーがターゲットインスタンスに&lt;em&gt;も&lt;/em&gt;存在するかどうかを確認し、それに応じて動作する必要があります。</target>
        </trans-unit>
        <trans-unit id="7a383107db035b97cc0f3e4c5c6844b9b02c255f" translate="yes" xml:space="preserve">
          <source>It is possible for an infinite number of clients to iterate the same collection at the same time, as the full state of the iterator is in the cursor, that is obtained and returned to the client at every call. Server side no state is taken at all.</source>
          <target state="translated">イテレータの完全な状態はカーソルにあり、呼び出すたびに取得されてクライアントに返されるので、無限の数のクライアントが同時に同じコレクションを反復処理することが可能です。サーバ側では状態は一切取られません。</target>
        </trans-unit>
        <trans-unit id="a485e395caaea14094a0b8ec68e5e3e0a8915e73" translate="yes" xml:space="preserve">
          <source>It is possible to call &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; using as argument a key that already has an existing expire set. In this case the time to live of a key is &lt;em&gt;updated&lt;/em&gt; to the new value. There are many useful applications for this, an example is documented in the &lt;em&gt;Navigation session&lt;/em&gt; pattern section below.</source>
          <target state="translated">すでに有効期限が設定されているキーを引数として使用して&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;を呼び出すことができます。この場合、キーの有効期間は新しい値に&lt;em&gt;更新さ&lt;/em&gt;れます。これには多くの便利なアプリケーションがあり、例は以下の&lt;em&gt;ナビゲーションセッション&lt;/em&gt;パターンセクションに記載されています。</target>
        </trans-unit>
        <trans-unit id="a7f5fb81c26b1abadccf00465e65f7fa65dea140" translate="yes" xml:space="preserve">
          <source>It is possible to call &lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt; inside Lua scripts like with normal clients, However one subtle aspect of the behavior changes between Redis 2.8.11 and Redis 2.8.12. Before the 2.8.12 release the database selected by the Lua script was &lt;em&gt;transferred&lt;/em&gt; to the calling script as current database. Starting from Redis 2.8.12 the database selected by the Lua script only affects the execution of the script itself, but does not modify the database selected by the client calling the script.</source>
          <target state="translated">通常のクライアントと同様にLuaスクリプト内で&lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt;を呼び出すことは可能ですが、Redis 2.8.11とRedis 2.8.12では動作の微妙な側面が1つ変更されています。2.8.12リリースの前に、Luaスクリプトによって選択されたデータベースは、現在のデータベースとして呼び出しスクリプトに&lt;em&gt;転送さ&lt;/em&gt;れました。Redis 2.8.12以降、Luaスクリプトによって選択されたデータベースはスクリプト自体の実行にのみ影響し、スクリプトを呼び出すクライアントによって選択されたデータベースは変更しません。</target>
        </trans-unit>
        <trans-unit id="0958a04d7552830b3684f48a6c436807896935c0" translate="yes" xml:space="preserve">
          <source>It is possible to call Redis commands from a Lua script using two different Lua functions:</source>
          <target state="translated">2つの異なるLua関数を使用して、LuaスクリプトからRedisコマンドを呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="b0a209f43840d7a1f6f04e02663cf8a792cab884" translate="yes" xml:space="preserve">
          <source>It is possible to entirely remove the connection name setting it to the empty string, that is not a valid connection name since it serves to this specific purpose.</source>
          <target state="translated">接続名を空の文字列に設定して完全に削除することも可能ですが、これはこの特定の目的のためのものなので、有効な接続名ではありません。</target>
        </trans-unit>
        <trans-unit id="db23050fd5ba19a3417f8b624df748886d949634" translate="yes" xml:space="preserve">
          <source>It is possible to get just the length of the slow log using the command &lt;strong&gt;SLOWLOG LEN&lt;/strong&gt;.</source>
          <target state="translated">コマンド&lt;strong&gt;SLOWLOG LEN&lt;/strong&gt;を使用して、遅いログの長さだけを取得することが可能です。</target>
        </trans-unit>
        <trans-unit id="db19130f0bd00fca33ef9a77ffc0a1ce2466b31d" translate="yes" xml:space="preserve">
          <source>It is possible to give the command in the following special form in order to make it more efficient:</source>
          <target state="translated">以下のような特殊な形式でコマンドを与えることで、より効率的にコマンドを与えることができます。</target>
        </trans-unit>
        <trans-unit id="e24f1bfbfced0e2fc3e90a67dd138360e0226aa2" translate="yes" xml:space="preserve">
          <source>It is possible to limit the size of the stream to a maximum number of elements using the &lt;strong&gt;MAXLEN&lt;/strong&gt; option.</source>
          <target state="translated">&lt;strong&gt;MAXLEN&lt;/strong&gt;オプションを使用して、ストリームのサイズを最大要素数に制限することができます。</target>
        </trans-unit>
        <trans-unit id="712b25407c86c3da9193a8517aa1f28826626087" translate="yes" xml:space="preserve">
          <source>It is possible to limit the size of the stream to a maximum number of elements using the &lt;strong&gt;MAXLEN&lt;/strong&gt; option. By default, or when used with the &lt;code&gt;=&lt;/code&gt; argument, the &lt;strong&gt;MAXLEN&lt;/strong&gt; option performs an exact trimming. That means that the trimmed stream's length will be exactly the minimum between its original length and the specified maximum length.</source>
          <target state="translated">&lt;strong&gt;MAXLEN&lt;/strong&gt;オプションを使用して、ストリームのサイズを要素の最大数に制限することができます。デフォルトで、または &lt;code&gt;=&lt;/code&gt; 引数とともに使用すると、&lt;strong&gt;MAXLEN&lt;/strong&gt;オプションは正確なトリミングを実行します。つまり、トリミングされたストリームの長さは、元の長さと指定された最大長の間の最小値になります。</target>
        </trans-unit>
        <trans-unit id="ee2ff105ab5c2c719dd08acac18181138935047b" translate="yes" xml:space="preserve">
          <source>It is possible to make this system more robust modifying the unlock schema as follows:</source>
          <target state="translated">以下のようにアンロックスキーマを変更することで、このシステムをより強固なものにすることができます。</target>
        </trans-unit>
        <trans-unit id="493e108b328a9e96e14d97d5ac7db908da18cbb1" translate="yes" xml:space="preserve">
          <source>It is possible to modify the maximum time a script can be executed with millisecond precision, either via &lt;code&gt;redis.conf&lt;/code&gt; or using the CONFIG GET / CONFIG SET command. The configuration parameter affecting max execution time is called &lt;code&gt;lua-time-limit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;redis.conf&lt;/code&gt; またはCONFIG GET / CONFIG SETコマンドを使用して、スクリプトをミリ秒の精度で実行できる最大時間を変更できます。最大実行時間に影響を与える構成パラメーターは、 &lt;code&gt;lua-time-limit&lt;/code&gt; と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="16570d1ed8c0ba499d85c4796bacd5587bfbf468" translate="yes" xml:space="preserve">
          <source>It is possible to only iterate elements matching a given glob-style pattern, similarly to the behavior of the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; command that takes a pattern as only argument.</source>
          <target state="translated">パターンを唯一の引数として取る&lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt;コマンドの動作と同様に、特定のグロブスタイルのパターンに一致する要素のみを繰り返すことが可能です。</target>
        </trans-unit>
        <trans-unit id="1b6a2609bc05ff6f008c837f6095456b47106ecb" translate="yes" xml:space="preserve">
          <source>It is possible to pass an additional argument to the command, in order to see the messages having a specific owner:</source>
          <target state="translated">特定の所有者を持つメッセージを見るために、コマンドに追加の引数を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="4c90a5608f4fab2983bbd179b23cb40526ff6f3e" translate="yes" xml:space="preserve">
          <source>It is possible to pass the &lt;code&gt;WITHSCORES&lt;/code&gt; option in order to return the scores of the elements together with the elements. The returned list will contain &lt;code&gt;value1,score1,...,valueN,scoreN&lt;/code&gt; instead of &lt;code&gt;value1,...,valueN&lt;/code&gt;. Client libraries are free to return a more appropriate data type (suggestion: an array with (value, score) arrays/tuples).</source>
          <target state="translated">要素とともに要素のスコアを返すために、 &lt;code&gt;WITHSCORES&lt;/code&gt; オプションを渡すことができます。返されるリストには、 &lt;code&gt;value1,score1,...,valueN,scoreN&lt;/code&gt; 代わりに &lt;code&gt;value1,...,valueN&lt;/code&gt; score1、...、valueN、scoreNが含まれます。クライアントライブラリは、より適切なデータ型を自由に返すことができます（推奨：（値、スコア）配列/タプルを含む配列）。</target>
        </trans-unit>
        <trans-unit id="5fd91c3878c3497da37709cc86d8056d11e4d945" translate="yes" xml:space="preserve">
          <source>It is possible to provide multiple filters at the same time. The command will handle multiple filters via logical AND. For example:</source>
          <target state="translated">複数のフィルタを同時に提供することが可能です。コマンドは、論理 AND を介して複数のフィルタを処理します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="1c3121b308c1fd1777b057f001ac070f1a4f6932" translate="yes" xml:space="preserve">
          <source>It is possible to push multiple elements using a single command call just specifying multiple arguments at the end of the command. Elements are inserted one after the other to the head of the list, from the leftmost element to the rightmost element. So for instance the command &lt;code&gt;LPUSH mylist a b c&lt;/code&gt; will result into a list containing &lt;code&gt;c&lt;/code&gt; as first element, &lt;code&gt;b&lt;/code&gt; as second element and &lt;code&gt;a&lt;/code&gt; as third element.</source>
          <target state="translated">コマンドの最後に複数の引数を指定するだけで、単一のコマンド呼び出しを使用して複数の要素をプッシュできます。要素は、左端の要素から右端の要素まで、リストの先頭に次々に挿入されます。したがって、たとえば、 &lt;code&gt;LPUSH mylist a b c&lt;/code&gt; コマンドは、 &lt;code&gt;c&lt;/code&gt; を最初の要素、 &lt;code&gt;b&lt;/code&gt; を2番目の要素、 &lt;code&gt;a&lt;/code&gt; を3番目の要素として含むリストになります。</target>
        </trans-unit>
        <trans-unit id="f7c76d9bc80fdf12c410c3b35eb8ad68df167802" translate="yes" xml:space="preserve">
          <source>It is possible to push multiple elements using a single command call just specifying multiple arguments at the end of the command. Elements are inserted one after the other to the tail of the list, from the leftmost element to the rightmost element. So for instance the command &lt;code&gt;RPUSH mylist a b c&lt;/code&gt; will result into a list containing &lt;code&gt;a&lt;/code&gt; as first element, &lt;code&gt;b&lt;/code&gt; as second element and &lt;code&gt;c&lt;/code&gt; as third element.</source>
          <target state="translated">コマンドの最後に複数の引数を指定するだけで、単一のコマンド呼び出しを使用して複数の要素をプッシュできます。要素は、左端の要素から右端の要素まで、リストの末尾に次々に挿入されます。だから、例えば、コマンド &lt;code&gt;RPUSH mylist a b c&lt;/code&gt; 含むリストになり最初の要素として &lt;code&gt;b&lt;/code&gt; 第二要素とのような &lt;code&gt;c&lt;/code&gt; 第三元素として。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6156ba53b9a2d5fcb6563a933eb7f9a8915352ac" translate="yes" xml:space="preserve">
          <source>It is possible to reset only specific events by providing the &lt;code&gt;event&lt;/code&gt; names as arguments.</source>
          <target state="translated">&lt;code&gt;event&lt;/code&gt; 名を引数として指定することにより、特定のイベントのみをリセットすることができます。</target>
        </trans-unit>
        <trans-unit id="1b01178931bb71c8630b481c710157203df1e465" translate="yes" xml:space="preserve">
          <source>It is possible to send &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt; in a MULTI/EXEC block together with the &lt;code&gt;INFO replication&lt;/code&gt; command in order to get the current master offset at the time the clients are blocked. This way it is possible to wait for a specific offset in the replica side in order to make sure all the replication stream was processed.</source>
          <target state="translated">クライアントがブロックされているときに現在のマスターオフセットを取得するために、 &lt;code&gt;INFO replication&lt;/code&gt; コマンドと一緒にMULTI / EXECブロックで&lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt;を送信することが可能です。このようにして、すべてのレプリケーションストリームが処理されたことを確認するために、レプリカ側で特定のオフセットを待つことができます。</target>
        </trans-unit>
        <trans-unit id="0ec5055f100665a2489124e5d7125126bd09824c" translate="yes" xml:space="preserve">
          <source>It is possible to specify an optional modifier to alter the behavior of the command. Specifically:</source>
          <target state="translated">オプションの修飾子を指定して、コマンドの動作を変更することができます。具体的には</target>
        </trans-unit>
        <trans-unit id="45f8f96397f97e0b1f0e90886760fbff08204ef1" translate="yes" xml:space="preserve">
          <source>It is possible to switch persistence from RDB snapshotting to append-only file (and the other way around) using the &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; command. For more information about how to do that please check the &lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;persistence page&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt;コマンドを使用して、永続性をRDBスナップショットから追加専用ファイル（およびその逆）に切り替えることができます。その方法の詳細については、&lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;永続化ページ&lt;/a&gt;を確認してください。</target>
        </trans-unit>
        <trans-unit id="7e2a6138f902bc8b4bcfbc90caefbe979c90132a" translate="yes" xml:space="preserve">
          <source>It is possible to terminate a script that executes only read-only commands using the &lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt; command. This does not violate the scripting semantic as no data was yet written to the dataset by the script.</source>
          <target state="translated">&lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt;コマンドを使用して、読み取り専用コマンドのみを実行するスクリプトを終了することができます。スクリプトによってデータセットにまだデータが書き込まれていないため、これはスクリプトのセマンティクスに違反しません。</target>
        </trans-unit>
        <trans-unit id="e71c9ce4c62f0cde3cb804acf308d1e98fe95b09" translate="yes" xml:space="preserve">
          <source>It is possible to use &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; and &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; together at every page view to have a counter counting only the latest N page views separated by less than the specified amount of seconds.</source>
          <target state="translated">すべてのページビューで&lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;と&lt;a href=&quot;expire&quot;&gt;EXPIREを&lt;/a&gt;一緒に使用して、指定された秒数未満で区切られた最新のNページビューのみをカウントするカウンターを使用することができます。</target>
        </trans-unit>
        <trans-unit id="2dd681e578f9014910b8ac5ae0c3612f0ad14944" translate="yes" xml:space="preserve">
          <source>It is possible to use &lt;code&gt;BY&lt;/code&gt; and &lt;code&gt;GET&lt;/code&gt; options against hash fields with the following syntax:</source>
          <target state="translated">次の構文を使用して、ハッシュフィールドに対して &lt;code&gt;BY&lt;/code&gt; および &lt;code&gt;GET&lt;/code&gt; オプションを使用できます。</target>
        </trans-unit>
        <trans-unit id="b7c843f5e285c955a784fb3560240c16b6f9efa9" translate="yes" xml:space="preserve">
          <source>It is possible to use them in &lt;code&gt;geohash.org&lt;/code&gt; URLs such as &lt;code&gt;http://geohash.org/&amp;lt;geohash-string&amp;gt;&lt;/code&gt;. This is an &lt;a href=&quot;http://geohash.org/sqdtr74hyu0&quot;&gt;example of such URL&lt;/a&gt;.</source>
          <target state="translated">これらを &lt;code&gt;http://geohash.org/&amp;lt;geohash-string&amp;gt;&lt;/code&gt; などの &lt;code&gt;geohash.org&lt;/code&gt; URLで使用できます。これはその&lt;a href=&quot;http://geohash.org/sqdtr74hyu0&quot;&gt;ようなURLの例です&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b30cb831388a0a49ee8acf0fd13e74a7abc3ab8f" translate="yes" xml:space="preserve">
          <source>It is possible to write to the Redis log file from Lua scripts using the &lt;code&gt;redis.log&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;redis.log&lt;/code&gt; 関数を使用して、LuaスクリプトからRedisログファイルに書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="dee99c37f02de301ed26c2711bf105931901e4b7" translate="yes" xml:space="preserve">
          <source>It is the blocking version because it blocks the connection when there are no members to pop from any of the given sorted sets. A member with the highest score is popped from first sorted set that is non-empty, with the given keys being checked in the order that they are given.</source>
          <target state="translated">これは、与えられたソートされたセットのいずれからもポップするメンバーがいない場合に接続をブロックするためのブロッキングバージョンです。最も高いスコアを持つメンバーは、最初にソートされた空でないセットからポップされ、与えられたキーが与えられた順にチェックされます。</target>
        </trans-unit>
        <trans-unit id="b7063c25aabd8a7e88f52a969b68eec3fd17473b" translate="yes" xml:space="preserve">
          <source>It is the blocking version because it blocks the connection when there are no members to pop from any of the given sorted sets. A member with the lowest score is popped from first sorted set that is non-empty, with the given keys being checked in the order that they are given.</source>
          <target state="translated">これは、与えられたソートされたセットのいずれからもポップするメンバーがいない場合に接続をブロックするためのブロッキングバージョンです。スコアが最も低いメンバーは、最初にソートされた空でないセットからポップされ、与えられたキーが与えられた順にチェックされます。</target>
        </trans-unit>
        <trans-unit id="164013c6ace79ff08b57e9e952d3d8fc12045787" translate="yes" xml:space="preserve">
          <source>It just assumes that the Earth is a sphere, since the used distance formula is the Haversine formula. This formula is only an approximation when applied to the Earth, which is not a perfect sphere. The introduced errors are not an issue when used in the context of social network sites that need to query by radius and most other applications. However in the worst case the error may be up to 0.5%, so you may want to consider other systems for error-critical applications.</source>
          <target state="translated">使用されている距離の公式はハベルサインの公式なので、地球が球体であると仮定しているだけです。この式は、完全な球体ではない地球に適用した場合の近似値にすぎません。導入された誤差は、半径による問い合わせが必要なソーシャルネットワークサイトや他のほとんどのアプリケーションのコンテキストで使用する場合には問題ありません。しかし、最悪の場合、誤差は0.5%までになる可能性がありますので、誤差が重要なアプリケーションでは他のシステムを検討した方が良いかもしれません。</target>
        </trans-unit>
        <trans-unit id="78cca099dcd0e67e0e370e606d28021ee24c5299" translate="yes" xml:space="preserve">
          <source>It should display some computer art. There are no limits as long as the output works well in a normal terminal display. However the output should not be limited to graphics (like LOLWUT 5 and 6 actually do), but can be generative poetry and other non graphical things.</source>
          <target state="translated">何らかのコンピュータアートを表示してくれるはずです。出力が通常の端末ディスプレイでうまく動作する限り、制限はありません。しかし、出力はグラフィックに限定されるべきではなく(LOLWUT 5や6が実際に行っているように)、生成的な詩やその他のグラフィカルではないものであっても構いません。</target>
        </trans-unit>
        <trans-unit id="886b0ba44681d142ee0340c1b1c340fb49ca65a9" translate="yes" xml:space="preserve">
          <source>It starts accepting commands again from other clients, but will reply with a BUSY error to all the clients sending normal commands. The only allowed commands in this status are &lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt; and &lt;code&gt;SHUTDOWN
NOSAVE&lt;/code&gt;.</source>
          <target state="translated">他のクライアントからのコマンドの受け入れを再開しますが、通常のコマンドを送信するすべてのクライアントにBUSYエラーで応答します。このステータスで許可されるコマンドは、&lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt;と &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="c9c449f7e951338dc4ce45209e7239b6180f2387" translate="yes" xml:space="preserve">
          <source>It stops processing all the pending commands from normal and pub/sub clients. However interactions with replicas will continue normally.</source>
          <target state="translated">通常のクライアントや pub/sub クライアントからの保留中のコマンドの処理をすべて停止します。ただし、レプリカとのインタラクションは通常通り継続されます。</target>
        </trans-unit>
        <trans-unit id="de49d1f951abef9774a1080b68edfd084cab6b36" translate="yes" xml:space="preserve">
          <source>It supports several other functions: &lt;code&gt;bit.tobit&lt;/code&gt;, &lt;code&gt;bit.tohex&lt;/code&gt;, &lt;code&gt;bit.bnot&lt;/code&gt;, &lt;code&gt;bit.band&lt;/code&gt;, &lt;code&gt;bit.bor&lt;/code&gt;, &lt;code&gt;bit.bxor&lt;/code&gt;, &lt;code&gt;bit.lshift&lt;/code&gt;, &lt;code&gt;bit.rshift&lt;/code&gt;, &lt;code&gt;bit.arshift&lt;/code&gt;, &lt;code&gt;bit.rol&lt;/code&gt;, &lt;code&gt;bit.ror&lt;/code&gt;, &lt;code&gt;bit.bswap&lt;/code&gt;. All available functions are documented in the &lt;a href=&quot;http://bitop.luajit.org/api.html&quot;&gt;Lua BitOp documentation&lt;/a&gt;</source>
          <target state="translated">他のいくつかの機能をサポートしています： &lt;code&gt;bit.tobit&lt;/code&gt; 、 &lt;code&gt;bit.tohex&lt;/code&gt; 、 &lt;code&gt;bit.bnot&lt;/code&gt; 、 &lt;code&gt;bit.band&lt;/code&gt; 、 &lt;code&gt;bit.bor&lt;/code&gt; 、 &lt;code&gt;bit.bxor&lt;/code&gt; 、 &lt;code&gt;bit.lshift&lt;/code&gt; 、 &lt;code&gt;bit.rshift&lt;/code&gt; 、 &lt;code&gt;bit.arshift&lt;/code&gt; 、 &lt;code&gt;bit.rol&lt;/code&gt; 、 &lt;code&gt;bit.ror&lt;/code&gt; 、 &lt;code&gt;bit.bswap&lt;/code&gt; 。使用可能なすべての関数は、&lt;a href=&quot;http://bitop.luajit.org/api.html&quot;&gt;Lua BitOpのドキュメントに&lt;/a&gt;記載されています。</target>
        </trans-unit>
        <trans-unit id="aa6a033ac7293343a89e1b83064df26de033f26b" translate="yes" xml:space="preserve">
          <source>Iteratating a stream incrementally, returning just a few items at every iteration. However it is semantically much more robust than the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family of functions.</source>
          <target state="translated">ストリームを段階的に反復し、反復ごとに数個のアイテムのみを返します。ただし、意味的には&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;ファミリーの関数よりもはるかに堅牢です。</target>
        </trans-unit>
        <trans-unit id="3fa52c04afc758e80cafb88b8a1109903b053dfb" translate="yes" xml:space="preserve">
          <source>Iterating a stream</source>
          <target state="translated">ストリームの反復処理</target>
        </trans-unit>
        <trans-unit id="51c1f7544778c11ca5b79e2c5f951971fc09700a" translate="yes" xml:space="preserve">
          <source>Iterating a stream incrementally, returning just a few items at every iteration. However it is semantically much more robust than the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family of functions.</source>
          <target state="translated">ストリームを段階的に反復し、反復ごとに数個のアイテムを返します。ただし、&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;ファミリーの関数よりも意味的にはるかに堅牢です。</target>
        </trans-unit>
        <trans-unit id="6cb66fccc1c9fe8583ef2426d5ce548dc6f7ff69" translate="yes" xml:space="preserve">
          <source>Iterating with XREVRANGE</source>
          <target state="translated">XREVRANGEを使った反復処理</target>
        </trans-unit>
        <trans-unit id="ac745b350ec3c8d6357a81e49fd4c8b3f51fac37" translate="yes" xml:space="preserve">
          <source>Iterating with earlier versions of Redis</source>
          <target state="translated">以前のバージョンのRedisで反復処理を行う</target>
        </trans-unit>
        <trans-unit id="4794d4e58656f4a052385045d3fd4b0331ebddea" translate="yes" xml:space="preserve">
          <source>Iteration of a Hash value.</source>
          <target state="translated">ハッシュ値の繰り返し。</target>
        </trans-unit>
        <trans-unit id="ac97fd8044e211b8965191abd3e1372d4a6075d6" translate="yes" xml:space="preserve">
          <source>KEYS</source>
          <target state="translated">KEYS</target>
        </trans-unit>
        <trans-unit id="d4d3343d1b4f35172b9d4fabff52e12ab9514f83" translate="yes" xml:space="preserve">
          <source>KEYS  pattern   Find all keys matching the given pattern</source>
          <target state="translated">KEYS パターン 指定されたパターンに一致するすべてのキーを検索します。</target>
        </trans-unit>
        <trans-unit id="8001eeb819fd035ff21dae0c64b60f000bfc9daa" translate="yes" xml:space="preserve">
          <source>Key step count allows us to find key positions in commands like &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; where the format is &lt;code&gt;MSET _key1_ _val1_ [key2] [val2] [key3] [val3]...&lt;/code&gt;.</source>
          <target state="translated">キーステップカウントを使用すると、&lt;a href=&quot;mset&quot;&gt;MSETの&lt;/a&gt;ようなコマンドのキー位置を見つけることができます。形式は &lt;code&gt;MSET _key1_ _val1_ [key2] [val2] [key3] [val3]...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5651c683f14c95aa972cfdbc300d9fecfe02019" translate="yes" xml:space="preserve">
          <source>Keys</source>
          <target state="translated">Keys</target>
        </trans-unit>
        <trans-unit id="5e0969e73b8800b103eeedd8f6bcdbbbf0f4fa78" translate="yes" xml:space="preserve">
          <source>Keys are checked in the order that they are given. Let's say that the key &lt;code&gt;list1&lt;/code&gt; doesn't exist and &lt;code&gt;list2&lt;/code&gt; and &lt;code&gt;list3&lt;/code&gt; hold non-empty lists. Consider the following command:</source>
          <target state="translated">キーは与えられた順にチェックされます。レッツは、キーと言う &lt;code&gt;list1&lt;/code&gt; 存在せず、 &lt;code&gt;list2&lt;/code&gt; と &lt;code&gt;list3&lt;/code&gt; 非空のリストを保持します。次のコマンドを検討してください。</target>
        </trans-unit>
        <trans-unit id="393be168e99116be87234133e2763b06336c48c1" translate="yes" xml:space="preserve">
          <source>Keys expiring information is stored as absolute Unix timestamps (in milliseconds in case of Redis version 2.6 or greater). This means that the time is flowing even when the Redis instance is not active.</source>
          <target state="translated">キーの有効期限の情報は、Unixの絶対的なタイムスタンプ(Redisバージョン2.6以上の場合はミリ秒単位)として保存されます。これは、Redisインスタンスがアクティブでなくても時間が流れていることを意味します。</target>
        </trans-unit>
        <trans-unit id="d3023dfa16df6ad208cc7d5460854b58da1edb26" translate="yes" xml:space="preserve">
          <source>Keys that do not exist are considered to be empty sets.</source>
          <target state="translated">存在しないキーは空のセットとみなされます。</target>
        </trans-unit>
        <trans-unit id="d71481abd644158f5a9fbc5c9cecdf74dc0540c6" translate="yes" xml:space="preserve">
          <source>Keys that do not exist are considered to be empty sets. With one of the keys being an empty set, the resulting set is also empty (since set intersection with an empty set always results in an empty set).</source>
          <target state="translated">存在しないキーは空集合とみなされます。キーの1つが空集合である場合、結果として得られる集合も空になります(空集合との集合の交点は常に空集合になるので)。</target>
        </trans-unit>
        <trans-unit id="a78a3a71051e865654da3b71a5c55513e9449b8a" translate="yes" xml:space="preserve">
          <source>Keys with an expire</source>
          <target state="translated">有効期限のあるキー</target>
        </trans-unit>
        <trans-unit id="7bcef127a442604057181ff7e89e6774cfcbdec1" translate="yes" xml:space="preserve">
          <source>Keyspace hits</source>
          <target state="translated">キースペースのヒット</target>
        </trans-unit>
        <trans-unit id="0ecc36a9eabb580bee92d3334fc963c0e285c8f2" translate="yes" xml:space="preserve">
          <source>Keyspace misses</source>
          <target state="translated">キースペースを逃す</target>
        </trans-unit>
        <trans-unit id="18937f1c4a4cfb92babe800429a63d572cde1150" translate="yes" xml:space="preserve">
          <source>Kills the currently executing Lua script, assuming no write operation was yet performed by the script.</source>
          <target state="translated">現在実行中の Lua スクリプトをキルします。</target>
        </trans-unit>
        <trans-unit id="a5a5fafee83492d8b176cbbdd5bb0860a6fdbf28" translate="yes" xml:space="preserve">
          <source>Known limitations:</source>
          <target state="translated">既知の制限事項。</target>
        </trans-unit>
        <trans-unit id="a452e11c491a60de5436b1999a469cdaa66c0c00" translate="yes" xml:space="preserve">
          <source>LASTSAVE</source>
          <target state="translated">LASTSAVE</target>
        </trans-unit>
        <trans-unit id="fb2ee42881d40ddc3d3aec1d41500b08e5d25e19" translate="yes" xml:space="preserve">
          <source>LASTSAVE   Get the UNIX time stamp of the last successful save to disk</source>
          <target state="translated">LASTSAVE 最後にディスクへの保存に成功したときの UNIX タイムスタンプを取得します。</target>
        </trans-unit>
        <trans-unit id="49d6c10ecea9234f6d1697a89998efd2571a5a9d" translate="yes" xml:space="preserve">
          <source>LATENCY</source>
          <target state="translated">LATENCY</target>
        </trans-unit>
        <trans-unit id="0501d335a5299cb1743cbb10c7b8477444d0a1c2" translate="yes" xml:space="preserve">
          <source>LATENCY DOCTOR   Return a human readable latency analysis report.</source>
          <target state="translated">LATENCY DOCTOR 人間が読めるレイテンシ解析レポートを返します。</target>
        </trans-unit>
        <trans-unit id="186301f764b22cd2877e1aabbbb1538d6d5f7100" translate="yes" xml:space="preserve">
          <source>LATENCY GRAPH  event   Return a latency graph for the event.</source>
          <target state="translated">LATENCY GRAPH event イベントのレイテンシグラフを返します。</target>
        </trans-unit>
        <trans-unit id="4bd2b2b9b61f8de610b1da572e4c2d464408238b" translate="yes" xml:space="preserve">
          <source>LATENCY HELP   Show helpful text about the different subcommands.</source>
          <target state="translated">LATENCY HELP さまざまなサブコマンドに関する有用なテキストを表示します。</target>
        </trans-unit>
        <trans-unit id="d4448a36c961ebd2847369404270a681d688d37d" translate="yes" xml:space="preserve">
          <source>LATENCY HISTORY  event   Return timestamp-latency samples for the event.</source>
          <target state="translated">LATENCY HISTORY イベント イベントのタイムスタンプ・レイテンシのサンプルを返します。</target>
        </trans-unit>
        <trans-unit id="40376256cb5363f7be31b5131fdde6f208ad798b" translate="yes" xml:space="preserve">
          <source>LATENCY LATEST   Return the latest latency samples for all events.</source>
          <target state="translated">LATENCY LATEST すべてのイベントの最新のレイテンシサンプルを返します。</target>
        </trans-unit>
        <trans-unit id="a46ae60e5ee406730f6e4d649edcf9436c10620d" translate="yes" xml:space="preserve">
          <source>LATENCY RESET  [event [event ...]]   Reset latency data for one or more events.</source>
          <target state="translated">LATENCY RESET [イベント [イベント ...]1 つ以上のイベントのレイテンシデータをリセットします。</target>
        </trans-unit>
        <trans-unit id="c6fdb30d112715d0c3b5d8a01834e5fa3472abec" translate="yes" xml:space="preserve">
          <source>LCS algorithm</source>
          <target state="translated">エルシーエスアルゴリズム</target>
        </trans-unit>
        <trans-unit id="89288dff0eca7e3500efaf0b7acd0c70cae1edc4" translate="yes" xml:space="preserve">
          <source>LCS is very useful in order to evaluate how similar two strings are. Strings can represent many things. For instance if two strings are DNA sequences, the LCS will provide a measure of similarity between the two DNA sequences. If the strings represent some text edited by some user, the LCS could represent how different the new text is compared to the old one, and so forth.</source>
          <target state="translated">LCSは2つの文字列がどれだけ似ているかを評価するのに非常に便利です。文字列は多くのものを表すことができます。例えば、2つの文字列がDNA配列である場合、LCSは2つのDNA配列間の類似性の尺度を提供します。文字列が何人かのユーザーによって編集されたテキストを表している場合、LCSは新しいテキストが古いテキストと比べてどれだけ違うかを表すことができます。</target>
        </trans-unit>
        <trans-unit id="b9ffd63c8ba805a842d4d3d2465da47916360545" translate="yes" xml:space="preserve">
          <source>LDB can be enabled in one of two modes: asynchronous or synchronous. In asynchronous mode the server creates a forked debugging session that does not block and all changes to the data are &lt;strong&gt;rolled back&lt;/strong&gt; after the session finishes, so debugging can be restarted using the same initial state. The alternative synchronous debug mode blocks the server while the debugging session is active and retains all changes to the data set once it ends.</source>
          <target state="translated">LDBは、非同期または同期の2つのモードのいずれかで有効にできます。非同期モードでは、サーバーはブロックしない分岐したデバッグセッションを作成し、セッションの終了後にデータへのすべての変更が&lt;strong&gt;ロールバックさ&lt;/strong&gt;れるため、同じ初期状態を使用してデバッグを再開できます。代替の同期デバッグモードでは、デバッグセッションがアクティブである間はサーバーがブロックされ、終了するとデータセットに対するすべての変更が保持されます。</target>
        </trans-unit>
        <trans-unit id="14d2c13614325f3af7fa95efeb5dd818bb2ab0d1" translate="yes" xml:space="preserve">
          <source>LINDEX</source>
          <target state="translated">LINDEX</target>
        </trans-unit>
        <trans-unit id="a2dedc00417f0b7b29562ddaa4e03af088097cdb" translate="yes" xml:space="preserve">
          <source>LINDEX  key index   Get an element from a list by its index</source>
          <target state="translated">LINDEX キーインデックス リストの要素をインデックスで取得します。</target>
        </trans-unit>
        <trans-unit id="40088c47225008784271c2935753b4ae98fd6ec7" translate="yes" xml:space="preserve">
          <source>LINSERT</source>
          <target state="translated">LINSERT</target>
        </trans-unit>
        <trans-unit id="b2f2247f94ae9fe4fba40fd22b1b94acb748b154" translate="yes" xml:space="preserve">
          <source>LINSERT  key BEFORE|AFTER pivot element   Insert an element before or after another element in a list</source>
          <target state="translated">LINSERT キー BEFORE|AFTER ピボット要素 リスト内の別の要素の前後に要素を挿入</target>
        </trans-unit>
        <trans-unit id="ca09700aae0c450ed6c327c789e3e1e3fef9f931" translate="yes" xml:space="preserve">
          <source>LINSERT  key BEFORE|AFTER pivot value   Insert an element before or after another element in a list</source>
          <target state="translated">LINSERT キー BEFORE|AFTER ピボット値 リスト内の別の要素の前または後に要素を挿入する</target>
        </trans-unit>
        <trans-unit id="19ce1639e2d6248a60334eca45396c2f1f706007" translate="yes" xml:space="preserve">
          <source>LLEN</source>
          <target state="translated">LLEN</target>
        </trans-unit>
        <trans-unit id="defc92ee8b39130b63cdf033e9edada00210e4f3" translate="yes" xml:space="preserve">
          <source>LLEN  key   Get the length of a list</source>
          <target state="translated">LLEN key リストの長さを取得します。</target>
        </trans-unit>
        <trans-unit id="cb98d0989512bc7d03fd0083653a3d72b76da663" translate="yes" xml:space="preserve">
          <source>LMOVE</source>
          <target state="translated">LMOVE</target>
        </trans-unit>
        <trans-unit id="78baeb2f5149c1548b47f47678b64129f94c3043" translate="yes" xml:space="preserve">
          <source>LMOVE  source destination LEFT|RIGHT LEFT|RIGHT   Pop an element from a list, push it to another list and return it</source>
          <target state="translated">LMOVE 元の行先 LEFT|RIGHT LEFT|RIGHT リストから要素をポップして、別のリストにプッシュして返す</target>
        </trans-unit>
        <trans-unit id="9cd49a9c6357f14037353e324dbbd426c30c77ff" translate="yes" xml:space="preserve">
          <source>LOLWUT</source>
          <target state="translated">LOLWUT</target>
        </trans-unit>
        <trans-unit id="91989e8620d79bb9a73795ebf9495785796e20eb" translate="yes" xml:space="preserve">
          <source>LOLWUT  [VERSION version]   Display some computer art and the Redis version</source>
          <target state="translated">LOLWUT [VERSION版]いくつかのコンピュータアートとRedis版を表示します。</target>
        </trans-unit>
        <trans-unit id="b8e5b9325998311e1bd0cdebf30f7c4698bea549" translate="yes" xml:space="preserve">
          <source>LOLWUT implementations should be safe and carefully checked for security, and resist to untrusted inputs if they take arguments.</source>
          <target state="translated">LOLWUTの実装は安全性を確認して慎重にセキュリティをチェックし、引数を取る場合は信頼されない入力に抵抗する必要があります。</target>
        </trans-unit>
        <trans-unit id="8b789d56cc69b68e8cc9454d61b8f6bcb54c00bd" translate="yes" xml:space="preserve">
          <source>LOLWUT must always display the Redis version at the end.</source>
          <target state="translated">LOLWUTは常に最後にRedisのバージョンを表示しなければなりません。</target>
        </trans-unit>
        <trans-unit id="b7fd4a8e75c582938a820d5ac113cfb69399cf55" translate="yes" xml:space="preserve">
          <source>LOLWUT output should be completely useless. Displaying some useful Redis internal metrics does not count as a valid LOLWUT.</source>
          <target state="translated">LOLWUTの出力は全く役に立たないはずです。いくつかの有用なRedis内部メトリクスを表示しても、有効なLOLWUTとしてはカウントされません。</target>
        </trans-unit>
        <trans-unit id="b93af8b70d5c9191d5ace878da62d412c38ce8b2" translate="yes" xml:space="preserve">
          <source>LOLWUT output should be fast to generate so that the command can be called in production instances without issues. It should remain fast even when the user experiments with odd parameters.</source>
          <target state="translated">LOLWUT の出力は、本番環境で問題なくコマンドを呼び出すことができるように、高速に生成されなければなりません。ユーザが奇数のパラメータを使って実験した場合でも、高速であるべきです。</target>
        </trans-unit>
        <trans-unit id="0f982fb7857c5b2bb4e69ef661e4d5d07a8ccdf1" translate="yes" xml:space="preserve">
          <source>LOLWUT wants to be a reminder that there is more in programming than just putting some code together in order to create something useful. Every LOLWUT version should have the following properties:</source>
          <target state="translated">LOLWUTは、プログラミングには、単にコードをまとめて有用なものを作るだけではないということを思い出させてくれることを望んでいます。LOLWUTのすべてのバージョンは、以下のプロパティを持つべきです。</target>
        </trans-unit>
        <trans-unit id="6f58be63c72a45daadb6f09041398ad98c6ac9a7" translate="yes" xml:space="preserve">
          <source>LPOP</source>
          <target state="translated">LPOP</target>
        </trans-unit>
        <trans-unit id="c0a0f50764c15280585040d66db05c7ea7d4701a" translate="yes" xml:space="preserve">
          <source>LPOP  key   Remove and get the first element in a list</source>
          <target state="translated">LPOP キー リストの最初の要素を削除して取得します。</target>
        </trans-unit>
        <trans-unit id="75ee742440d0263541b4bf6b56f59ba72ebbd18e" translate="yes" xml:space="preserve">
          <source>LPOP  key [count]   Remove and get the first elements in a list</source>
          <target state="translated">LPOPキー [count]リストの最初の要素を削除して取得します。</target>
        </trans-unit>
        <trans-unit id="8692b4b41c5b80f3fc1b6efeb4604f7278100aec" translate="yes" xml:space="preserve">
          <source>LPOS</source>
          <target state="translated">LPOS</target>
        </trans-unit>
        <trans-unit id="2f8be8617cbb634559fc59c4d3862bfd42f75d83" translate="yes" xml:space="preserve">
          <source>LPOS  key element [RANK rank] [COUNT num-matches] [MAXLEN len]   Return the index of matching elements on a list</source>
          <target state="translated">LPOS キー要素 [RANK rank][COUNT num-matches][MAXLEN len]リスト上の一致する要素のインデックスを返します。</target>
        </trans-unit>
        <trans-unit id="4f49fc76e42ddd892d0dbf761cab7456fba6707a" translate="yes" xml:space="preserve">
          <source>LPUSH</source>
          <target state="translated">LPUSH</target>
        </trans-unit>
        <trans-unit id="5005b933581b136ea08ec907be2cf03efef61621" translate="yes" xml:space="preserve">
          <source>LPUSH  key element [element ...]   Prepend one or multiple elements to a list</source>
          <target state="translated">LPUSH key element [element ...]1つまたは複数の要素をリストに追加する</target>
        </trans-unit>
        <trans-unit id="a3260ebe55f682088cc638c2329d0a5d2a5f9c43" translate="yes" xml:space="preserve">
          <source>LPUSH  key value [value ...]   Prepend one or multiple values to a list</source>
          <target state="translated">LPUSH キー値 [value ...]1 つまたは複数の値をリストに追加します。</target>
        </trans-unit>
        <trans-unit id="73023347f78efa6f33e2849831f260102f26f9dc" translate="yes" xml:space="preserve">
          <source>LPUSHX</source>
          <target state="translated">LPUSHX</target>
        </trans-unit>
        <trans-unit id="ed89f101b9e76dd34f817063ee39924d1d879b9e" translate="yes" xml:space="preserve">
          <source>LPUSHX  key element [element ...]   Prepend an element to a list, only if the list exists</source>
          <target state="translated">LPUSHX key element [element ....]リストが存在する場合にのみ、リストに要素を前置します。</target>
        </trans-unit>
        <trans-unit id="11960d83f4ba3a64c1274bec7eeaf405b1c4abbe" translate="yes" xml:space="preserve">
          <source>LPUSHX  key value   Prepend a value to a list, only if the list exists</source>
          <target state="translated">LPUSHX キー値 リストが存在する場合にのみ、値をリストに前置します。</target>
        </trans-unit>
        <trans-unit id="3b47c23e3107b92100b9303bb9ab3d1a9ccc56bd" translate="yes" xml:space="preserve">
          <source>LRANGE</source>
          <target state="translated">LRANGE</target>
        </trans-unit>
        <trans-unit id="326594fa342712e825205a5b864121b10bd2f5cf" translate="yes" xml:space="preserve">
          <source>LRANGE  key start stop   Get a range of elements from a list</source>
          <target state="translated">LRANGE キー start stop リストから要素の範囲を取得します。</target>
        </trans-unit>
        <trans-unit id="abfc25d80dc9a80384bd4c9697b510b323ecc45b" translate="yes" xml:space="preserve">
          <source>LREM</source>
          <target state="translated">LREM</target>
        </trans-unit>
        <trans-unit id="254b612ba99c38d18c49c669440c641123e2f3a7" translate="yes" xml:space="preserve">
          <source>LREM  key count element   Remove elements from a list</source>
          <target state="translated">LREM キーカウント要素 リストから要素を削除する</target>
        </trans-unit>
        <trans-unit id="f0b649e2191175bc6abf8bc7b2d0b6ec6fbf904d" translate="yes" xml:space="preserve">
          <source>LREM  key count value   Remove elements from a list</source>
          <target state="translated">LREM キーカウント値 リストから要素を削除する</target>
        </trans-unit>
        <trans-unit id="70e8f03d6f4f36a9430ac8c4d4a1515597b0b252" translate="yes" xml:space="preserve">
          <source>LSET</source>
          <target state="translated">LSET</target>
        </trans-unit>
        <trans-unit id="67b8e37be9910fff9bc7142f035eae99cc3cc4f5" translate="yes" xml:space="preserve">
          <source>LSET  key index element   Set the value of an element in a list by its index</source>
          <target state="translated">LSET key index element リスト内の要素の値をインデックスで設定します。</target>
        </trans-unit>
        <trans-unit id="4f03203283df161a2d6f2abf4d29626d32823249" translate="yes" xml:space="preserve">
          <source>LSET  key index value   Set the value of an element in a list by its index</source>
          <target state="translated">LSET key index value リスト内の要素の値をインデックスで設定します。</target>
        </trans-unit>
        <trans-unit id="13cbd920c001e22788dd4d82cdc291c6caac4662" translate="yes" xml:space="preserve">
          <source>LTRIM</source>
          <target state="translated">LTRIM</target>
        </trans-unit>
        <trans-unit id="6c5b375830efe50dd05881b52f80e2aa747afced" translate="yes" xml:space="preserve">
          <source>LTRIM  key start stop   Trim a list to the specified range</source>
          <target state="translated">LTRIM キー start stop リストを指定した範囲にトリミングします。</target>
        </trans-unit>
        <trans-unit id="de6a27da313b316346ea7dcf9f866c5fcdaff765" translate="yes" xml:space="preserve">
          <source>Last Key in Argument List</source>
          <target state="translated">引数リストの最後のキー</target>
        </trans-unit>
        <trans-unit id="65fe7d4d518c0668f04d8585ccfbc20334e6fd38" translate="yes" xml:space="preserve">
          <source>Lastly, there are three important rules to note:</source>
          <target state="translated">最後に、注意すべき重要なルールが3つあります。</target>
        </trans-unit>
        <trans-unit id="d4e1040fdde9172717ea80a7cdcb3b316461fb75" translate="yes" xml:space="preserve">
          <source>Later it will be trivial to know the number of single days the user visited the web site simply calling the &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; command against the bitmap.</source>
          <target state="translated">後で、ユーザーがビットマップに対して&lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt;コマンドを呼び出すだけでWebサイトにアクセスした日数を知るのは簡単です。</target>
        </trans-unit>
        <trans-unit id="78d7ed93f503a940a73a89268b71f5daa31c6b65" translate="yes" xml:space="preserve">
          <source>Latest event latency in millisecond.</source>
          <target state="translated">最新のイベントレイテンシをミリ秒単位で表示しています。</target>
        </trans-unit>
        <trans-unit id="6167261c71ec337f0f15b900208ad184a4f7b0c9" translate="yes" xml:space="preserve">
          <source>Latest fork(2) time</source>
          <target state="translated">最新のフォーク(2)の時間</target>
        </trans-unit>
        <trans-unit id="0122f9d36a5bc7edfbaa17dc0a7b017882cfb3ae" translate="yes" xml:space="preserve">
          <source>Let's assume we have four nodes, A, B, C and D. In order to end with just a three nodes cluster A, B, C we may follow these steps:</source>
          <target state="translated">4つのノード、A,B,C,Dを持っていると仮定してみましょう。</target>
        </trans-unit>
        <trans-unit id="2f5c5e27076a7756eeef955cec8a1510af3fb9c4" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution-ShareAlike License 4.0.</source>
          <target state="translated">クリエイティブ・コモンズ 表示-継承ライセンス4.0の下でライセンスされています。</target>
        </trans-unit>
        <trans-unit id="98cf5d780c53575d17f1d32cf3823650dcaa6c52" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt; this command returns the remaining time to live of a key that has an expire set, with the sole difference that &lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt; returns the amount of remaining time in seconds while &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; returns it in milliseconds.</source>
          <target state="translated">&lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt;と同様に、このコマンドは、有効期限が設定されているキーの残りの有効期間を返します。唯一の違いは、&lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt;は残り時間を秒単位で返し、&lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt;はミリ秒単位で返します。</target>
        </trans-unit>
        <trans-unit id="199ff2ec8051414c46a22a354ba2c4bf9f64de93" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; this command can be used in order to iterate the whole stream content, however note that in this case, the next command calls should use the ID of the last entry, with the sequence number decremneted by one. However if the sequence number is already 0, the time part of the ID should be decremented by 1, and the sequence part should be set to the maxium possible sequence number, that is, 18446744073709551615, or could be omitted at all, and the command will automatically assume it to be such a number (see &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; for more info about incomplete IDs).</source>
          <target state="translated">同様&lt;a href=&quot;xrange&quot;&gt;XRANGEは&lt;/a&gt;、このコマンドは、この場合には、次のコマンド呼び出しが1でdecremnetedシーケンス番号と、最後のエントリのIDを使用する必要があることに注意してください、全体のストリームコンテンツを反復するために使用することができます。ただし、シーケンス番号がすでに0の場合、IDの時間部分を1だけ減らし、シーケンス部分を最大可能なシーケンス番号、つまり18446744073709551615に設定するか、まったく省略して、コマンドは自動的にそのような数であると想定します（不完全なIDの詳細については、&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="7a5a0a2011829340fa32a8f044e479cef542a701" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; the &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; command can be used in a blocking way. There are no differences in this regard.</source>
          <target state="translated">&lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt;と同様に、&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;コマンドはブロックする方法で使用できます。この点で違いはありません。</target>
        </trans-unit>
        <trans-unit id="964c6e379f4b517ab54346bbc59cea679f55f58d" translate="yes" xml:space="preserve">
          <source>Like for the &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; command start and end can contain negative values in order to index bytes starting from the end of the string, where -1 is the last byte, -2 is the penultimate, and so forth.</source>
          <target state="translated">&lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt;コマンドの場合と同様に、文字列の最後からバイトをインデックスするために、startおよびendに負の値を含めることができます。-1は最後のバイト、-2は最後から2番目のバイトなどです。</target>
        </trans-unit>
        <trans-unit id="ce45b8148c6f69841bc195d50623329ea61f3da8" translate="yes" xml:space="preserve">
          <source>Lines can contain a section name (starting with a # character) or a property. All the properties are in the form of &lt;code&gt;field:value&lt;/code&gt; terminated by &lt;code&gt;\r\n&lt;/code&gt;.</source>
          <target state="translated">行には、セクション名（＃文字で始まる）またはプロパティを含めることができます。すべてのプロパティは、 &lt;code&gt;\r\n&lt;/code&gt; 終了する &lt;code&gt;field:value&lt;/code&gt; の形式です。</target>
        </trans-unit>
        <trans-unit id="39de9fe457bd2e361245f87b008646c82403b58e" translate="yes" xml:space="preserve">
          <source>List of rules</source>
          <target state="translated">ルール一覧</target>
        </trans-unit>
        <trans-unit id="57c9502a7d7d48fd4a86b45fefb2b163491c3ae1" translate="yes" xml:space="preserve">
          <source>Lists</source>
          <target state="translated">Lists</target>
        </trans-unit>
        <trans-unit id="899acbf6050de7813479a962bcb80b73089f0f38" translate="yes" xml:space="preserve">
          <source>Lists can be encoded as &lt;code&gt;ziplist&lt;/code&gt; or &lt;code&gt;linkedlist&lt;/code&gt;. The &lt;code&gt;ziplist&lt;/code&gt; is the special representation that is used to save space for small lists.</source>
          <target state="translated">リストは &lt;code&gt;ziplist&lt;/code&gt; または &lt;code&gt;linkedlist&lt;/code&gt; としてエンコードできます。 &lt;code&gt;ziplist&lt;/code&gt; は小さなリストのためのスペースを節約するために使用される特殊な表現です。</target>
        </trans-unit>
        <trans-unit id="db5be7f471516f84344dd104ba9b8aa174ce8d02" translate="yes" xml:space="preserve">
          <source>Lists the currently &lt;em&gt;active channels&lt;/em&gt;. An active channel is a Pub/Sub channel with one or more subscribers (not including clients subscribed to patterns).</source>
          <target state="translated">現在&lt;em&gt;アクティブなチャネルを&lt;/em&gt;一覧表示&lt;em&gt;します&lt;/em&gt;。アクティブチャネルは、1つ以上のサブスクライバー（パターンにサブスクライブしているクライアントは含まない）を持つPub / Subチャネルです。</target>
        </trans-unit>
        <trans-unit id="dcea1d44bcfef24039b8c1d6348290fc06d43c9a" translate="yes" xml:space="preserve">
          <source>Load a script into the scripts cache, without executing it. After the specified command is loaded into the script cache it will be callable using &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; with the correct SHA1 digest of the script, exactly like after the first successful invocation of &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;.</source>
          <target state="translated">スクリプトを実行せずにスクリプトキャッシュにロードします。指定されたコマンドがスクリプトキャッシュにロードされた後、最初に&lt;a href=&quot;eval&quot;&gt;EVALが&lt;/a&gt;正常に呼び出された後とまったく同じように、スクリプトの正しいSHA1ダイジェストで&lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt;を使用して呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="735c2e48480d01f1dceaeb55af3cf36dcdd6249a" translate="yes" xml:space="preserve">
          <source>Loads a module from a dynamic library at runtime.</source>
          <target state="translated">実行時に動的ライブラリからモジュールをロードします。</target>
        </trans-unit>
        <trans-unit id="694b70e7b053ef29ce888020d6a15ef0d17437e5" translate="yes" xml:space="preserve">
          <source>Lua boolean -&amp;gt; Redis boolean true or false. &lt;strong&gt;Note that this is a change compared to the RESP2 mode&lt;/strong&gt;, where returning true from Lua returned the number 1 to the Redis client, and returning false used to return NULL.</source>
          <target state="translated">Lua boolean-&amp;gt; Redis booleantrueまたはfalse。&lt;strong&gt;これは、&lt;/strong&gt; Luaからtrueを返すとRedisクライアントに数値1が返され、falseを返すとNULLを返す&lt;strong&gt;RESP2モードと比較した変更であることに注意してください&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="bcd47c9d2232eb759e90bf52905602d787217e6e" translate="yes" xml:space="preserve">
          <source>Lua boolean false -&amp;gt; Redis Nil bulk reply.</source>
          <target state="translated">Lua boolean false-&amp;gt; Redis Nil一括返信。</target>
        </trans-unit>
        <trans-unit id="197815ca05866b7c30c1048b9d86321ee4ce6238" translate="yes" xml:space="preserve">
          <source>Lua boolean true -&amp;gt; Redis integer reply with value of 1.</source>
          <target state="translated">Lua boolean true-&amp;gt;値1のRedis整数応答。</target>
        </trans-unit>
        <trans-unit id="02dda41ef75370280dc992551fadb03b88d21b1f" translate="yes" xml:space="preserve">
          <source>Lua does not export commands to access the system time or other external state.</source>
          <target state="translated">Luaでは、システム時刻などの外部状態にアクセスするためのコマンドをエクスポートしません。</target>
        </trans-unit>
        <trans-unit id="738b234f859993680828647d652f6de5655b0815" translate="yes" xml:space="preserve">
          <source>Lua has a single numerical type, Lua numbers. There is no distinction between integers and floats. So we always convert Lua numbers into integer replies, removing the decimal part of the number if any. &lt;strong&gt;If you want to return a float from Lua you should return it as a string&lt;/strong&gt;, exactly like Redis itself does (see for instance the &lt;a href=&quot;zscore&quot;&gt;ZSCORE&lt;/a&gt; command).</source>
          <target state="translated">Luaには、Lua番号という単一の数値タイプがあります。整数と浮動小数点数の区別はありません。したがって、常にLuaの数値を整数の応答に変換し、小数部がある場合はそれを削除します。&lt;strong&gt;Luaから浮動小数点数を返したい場合は&lt;/strong&gt;、Redis自体が行うのとまったく同じように、&lt;strong&gt;それを文字列として返す必要&lt;/strong&gt;があります（たとえば、&lt;a href=&quot;zscore&quot;&gt;ZSCORE&lt;/a&gt;コマンドを参照）。</target>
        </trans-unit>
        <trans-unit id="8a5d229484ee19b076e60e7fc0d0b8345579dcc1" translate="yes" xml:space="preserve">
          <source>Lua null -&amp;gt; Redis RESP3 new null reply (protocol &lt;code&gt;&quot;_\r\n&quot;&lt;/code&gt;).</source>
          <target state="translated">Lua null-&amp;gt; Redis RESP3の新しいnull応答（プロトコル &lt;code&gt;&quot;_\r\n&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7c212b1d165a2bdadf01bf8c01c306a9c3e780aa" translate="yes" xml:space="preserve">
          <source>Lua number -&amp;gt; Redis integer reply (the number is converted into an integer)</source>
          <target state="translated">Lua番号-&amp;gt; Redis整数応答（数値は整数に変換されます）</target>
        </trans-unit>
        <trans-unit id="0fcb79bd3680efc38fab49be15ad5a556da29a6c" translate="yes" xml:space="preserve">
          <source>Lua pseudo random number generation functions &lt;code&gt;math.random&lt;/code&gt; and &lt;code&gt;math.randomseed&lt;/code&gt; are modified in order to always have the same seed every time a new script is executed. This means that calling &lt;code&gt;math.random&lt;/code&gt; will always generate the same sequence of numbers every time a script is executed if &lt;code&gt;math.randomseed&lt;/code&gt; is not used.</source>
          <target state="translated">Lua擬似乱数生成関数 &lt;code&gt;math.random&lt;/code&gt; および &lt;code&gt;math.randomseed&lt;/code&gt; は、新しいスクリプトが実行されるたびに常に同じシードを持つように変更されています。呼び出すことをこの手段 &lt;code&gt;math.random&lt;/code&gt; は常に同じ数列にあればスクリプトが実行されるたびに発生します &lt;code&gt;math.randomseed&lt;/code&gt; が使用されていませんが。</target>
        </trans-unit>
        <trans-unit id="e026038d7a23da497563d39bf562be4e8b076af8" translate="yes" xml:space="preserve">
          <source>Lua scripts can return a value that is converted from the Lua type to the Redis protocol using a set of conversion rules.</source>
          <target state="translated">Luaスクリプトは、一連の変換ルールを使用して、Lua型からRedisプロトコルに変換された値を返すことができます。</target>
        </trans-unit>
        <trans-unit id="eec8779958c6af77259f2bed4f2206965d44330b" translate="yes" xml:space="preserve">
          <source>Lua string -&amp;gt; Redis bulk reply</source>
          <target state="translated">Lua文字列-&amp;gt; Redis一括返信</target>
        </trans-unit>
        <trans-unit id="0b78d29489185b7463559dbd5991d9b98e6ea241" translate="yes" xml:space="preserve">
          <source>Lua table (array) -&amp;gt; Redis multi bulk reply (truncated to the first nil inside the Lua array if any)</source>
          <target state="translated">Luaテーブル（配列）-&amp;gt; Redisマルチバルク応答（もしあれば、Lua配列内の最初のnilに切り捨てられます）</target>
        </trans-unit>
        <trans-unit id="011559d094bdd466ae90420b82cf3259960bb378" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;double&lt;/code&gt; field set to a field-value Lua table -&amp;gt; Redis double reply.</source>
          <target state="translated">単一の &lt;code&gt;double&lt;/code&gt; フィールドがフィールド値に設定されたLuaテーブルLuaテーブル-&amp;gt; Redisの二重応答。</target>
        </trans-unit>
        <trans-unit id="92dffb8e404af7ee6cc40117a693313890548b7f" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;err&lt;/code&gt; field -&amp;gt; Redis error reply</source>
          <target state="translated">1つの &lt;code&gt;err&lt;/code&gt; フィールドを持つLuaテーブル-&amp;gt; Redisエラー応答</target>
        </trans-unit>
        <trans-unit id="31b3bac91c4fbeb254b85ca62a253ad709c8a47f" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;map&lt;/code&gt; field set to a field-value Lua table -&amp;gt; Redis map reply.</source>
          <target state="translated">単一の &lt;code&gt;map&lt;/code&gt; フィールドがフィールド値に設定されたLuaテーブル-&amp;gt; Redisマップ応答。</target>
        </trans-unit>
        <trans-unit id="860f10116eaffeabf918bd97496952f6a8568b86" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;ok&lt;/code&gt; field -&amp;gt; Redis status reply</source>
          <target state="translated">単一の &lt;code&gt;ok&lt;/code&gt; フィールドを持つLuaテーブル-&amp;gt; Redisステータスの応答</target>
        </trans-unit>
        <trans-unit id="c86e8370e8448b07f033d118ba308f34fc561150" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;set&lt;/code&gt; field set to a field-value Lua table -&amp;gt; Redis set reply, the values are discarded and can be anything.</source>
          <target state="translated">単一の &lt;code&gt;set&lt;/code&gt; フィールドがフィールド値に設定されたLuaテーブルLuaテーブル-&amp;gt; Redisセット応答。値は破棄され、何でもかまいません。</target>
        </trans-unit>
        <trans-unit id="f4b1c471ce1efbe25d7232b293140a21b7fea826" translate="yes" xml:space="preserve">
          <source>MEMORY</source>
          <target state="translated">MEMORY</target>
        </trans-unit>
        <trans-unit id="5f530d724793deebbb2b735aad30cfb0c16904b5" translate="yes" xml:space="preserve">
          <source>MEMORY DOCTOR   Outputs memory problems report</source>
          <target state="translated">メモリ問題のレポートを出力するMEMORY DOCTOR</target>
        </trans-unit>
        <trans-unit id="f41c78df06ee10a6b220b355855965b8d5802f0d" translate="yes" xml:space="preserve">
          <source>MEMORY HELP   Show helpful text about the different subcommands</source>
          <target state="translated">MEMORY HELP 様々なサブコマンドについての有用なテキストを表示します。</target>
        </trans-unit>
        <trans-unit id="c46a26bce66617f3cb9ccdc83db737a6115fdc5d" translate="yes" xml:space="preserve">
          <source>MEMORY MALLOC-STATS   Show allocator internal stats</source>
          <target state="translated">MEMORY MALLOC-STATS アロケータの内部統計を表示します。</target>
        </trans-unit>
        <trans-unit id="eb96d4965b5bb6522ee6573db44c8a6e1ce6edba" translate="yes" xml:space="preserve">
          <source>MEMORY PURGE   Ask the allocator to release memory</source>
          <target state="translated">MEMORY PURGE アロケータにメモリの解放を求める</target>
        </trans-unit>
        <trans-unit id="d3303c80cf9ee1aa6f783b72419ffa190e2a905d" translate="yes" xml:space="preserve">
          <source>MEMORY STATS   Show memory usage details</source>
          <target state="translated">MEMORY STATS メモリ使用量の詳細を表示</target>
        </trans-unit>
        <trans-unit id="de9aed5605340cafa3f173e741e4bc7253d17f99" translate="yes" xml:space="preserve">
          <source>MEMORY USAGE  key [SAMPLES count]   Estimate the memory usage of a key</source>
          <target state="translated">MEMORY USAGE key [SAMPLES count]キーのメモリ使用量を推定する</target>
        </trans-unit>
        <trans-unit id="eb4b445b699787b561e4b67d4f6b08a7ef32cf55" translate="yes" xml:space="preserve">
          <source>MGET</source>
          <target state="translated">MGET</target>
        </trans-unit>
        <trans-unit id="ffbcf2b819692d7b52978ca1ef1e227536a082fe" translate="yes" xml:space="preserve">
          <source>MGET  key [key ...]   Get the values of all the given keys</source>
          <target state="translated">MGET key [key ....]与えられたすべてのキーの値を取得します。</target>
        </trans-unit>
        <trans-unit id="883beaf0f91aca7f9ebc4802e0bab2501cbbc8ea" translate="yes" xml:space="preserve">
          <source>MIGRATE</source>
          <target state="translated">MIGRATE</target>
        </trans-unit>
        <trans-unit id="c26be640f072695430c6befbdaab1be7da9a4af0" translate="yes" xml:space="preserve">
          <source>MIGRATE  host port key|&quot;&quot; destination-db timeout [COPY] [REPLACE] [AUTH password] [AUTH2 username password] [KEYS key [key ...]]   Atomically transfer a key from a Redis instance to another one.</source>
          <target state="translated">MIGRATE ホストポートキー|&quot;&quot; destination-db タイムアウト [COPY][REPLACE][AUTH パスワード][AUTH2 ユーザー名パスワード][KEYS キー [キー ...]Redisインスタンスから別のインスタンスにキーをアトミックに転送します。</target>
        </trans-unit>
        <trans-unit id="2f0b2cdf3b3d88df6ed56ef5576fa5ec1a8aa5b1" translate="yes" xml:space="preserve">
          <source>MIGRATE  host port key|&quot;&quot; destination-db timeout [COPY] [REPLACE] [KEYS key [key ...]]   Atomically transfer a key from a Redis instance to another one.</source>
          <target state="translated">MIGRATE ホストポートキー|&quot;&quot; destination-db タイムアウト [COPY][REPLACE][KEYS キー [キー ...]Redisインスタンスから別のインスタンスにキーをアトミックに転送します。</target>
        </trans-unit>
        <trans-unit id="66bffe2295ae671e5d45439c77216938c792414b" translate="yes" xml:space="preserve">
          <source>MODULE</source>
          <target state="translated">MODULE</target>
        </trans-unit>
        <trans-unit id="43ac8ce01de13f2da2af292daa0522a8dce0815f" translate="yes" xml:space="preserve">
          <source>MODULE LIST   List all modules loaded by the server</source>
          <target state="translated">MODULE LIST サーバがロードした全てのモジュールのリスト</target>
        </trans-unit>
        <trans-unit id="ead5dec077ff0d8c33078bffc3edb3a161d0c8b1" translate="yes" xml:space="preserve">
          <source>MODULE LOAD  path [ arg [arg ...]]   Load a module</source>
          <target state="translated">MODULE LOAD パス[arg [arg ....]]モジュールのロード</target>
        </trans-unit>
        <trans-unit id="c8d0e227668f65977f974daf28058d755a01a58f" translate="yes" xml:space="preserve">
          <source>MODULE UNLOAD  name   Unload a module</source>
          <target state="translated">MODULE UNLOAD name モジュールのアンロード</target>
        </trans-unit>
        <trans-unit id="6da5b5979c630adef5abc39370410d7de4a1b8ef" translate="yes" xml:space="preserve">
          <source>MONITOR</source>
          <target state="translated">MONITOR</target>
        </trans-unit>
        <trans-unit id="55d4d86d6d24375e297cf38db11a4bacd4febc84" translate="yes" xml:space="preserve">
          <source>MONITOR   Listen for all requests received by the server in real time</source>
          <target state="translated">MONITOR サーバーが受信したすべてのリクエストをリアルタイムでリッスンします。</target>
        </trans-unit>
        <trans-unit id="3bf08a84f15b98ce4d14b707f4a093b3cc8b853e" translate="yes" xml:space="preserve">
          <source>MOVE</source>
          <target state="translated">MOVE</target>
        </trans-unit>
        <trans-unit id="001d5d6407276cba944eda42b69684ebbbae5d55" translate="yes" xml:space="preserve">
          <source>MOVE  key db   Move a key to another database</source>
          <target state="translated">MOVE key db キーを別のデータベースに移動します。</target>
        </trans-unit>
        <trans-unit id="4a4d41a590643b6020afed2c32a7fa4d49b49601" translate="yes" xml:space="preserve">
          <source>MSET</source>
          <target state="translated">MSET</target>
        </trans-unit>
        <trans-unit id="9a5861cd64b36ffe83c01382e80e50105a256980" translate="yes" xml:space="preserve">
          <source>MSET  key value [key value ...]   Set multiple keys to multiple values</source>
          <target state="translated">MSET キー値 [キー値 ...]複数のキーを複数の値に設定します。</target>
        </trans-unit>
        <trans-unit id="f7daca0dd0ee4f7979861ac9b4fb059852d07494" translate="yes" xml:space="preserve">
          <source>MSETNX</source>
          <target state="translated">MSETNX</target>
        </trans-unit>
        <trans-unit id="48498dbffef6df5e6474fe5db88a9722de54676a" translate="yes" xml:space="preserve">
          <source>MSETNX  key value [key value ...]   Set multiple keys to multiple values, only if none of the keys exist</source>
          <target state="translated">MSETNX キー値 [キー値 ...]キーが存在しない場合のみ、複数のキーを複数の値に設定します。</target>
        </trans-unit>
        <trans-unit id="73cadb41b45514de9061a72461b466eafd7a01b0" translate="yes" xml:space="preserve">
          <source>MULTI</source>
          <target state="translated">MULTI</target>
        </trans-unit>
        <trans-unit id="bb76d99632737ac9f4ecd1c2218ac5cae7373df0" translate="yes" xml:space="preserve">
          <source>MULTI   Mark the start of a transaction block</source>
          <target state="translated">MULTI トランザクションブロックの開始をマークする</target>
        </trans-unit>
        <trans-unit id="5162c1f5fa963969d600908fd5531f9515bcd0ad" translate="yes" xml:space="preserve">
          <source>Manually issue the &lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; command to stop a &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; stream running via &lt;code&gt;telnet&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt;コマンドを手動で発行して、 &lt;code&gt;telnet&lt;/code&gt; 経由で実行されている&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;ストリームを停止します。</target>
        </trans-unit>
        <trans-unit id="1ab2b333d1a4eb7dc9f5b2c393ae0acfe6aa0aa8" translate="yes" xml:space="preserve">
          <source>Manually issue the &lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; or &lt;a href=&quot;reset&quot;&gt;RESET&lt;/a&gt; commands to stop a &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; stream running via &lt;code&gt;telnet&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt;または&lt;a href=&quot;reset&quot;&gt;RESET&lt;/a&gt;コマンドを手動で発行して、 &lt;code&gt;telnet&lt;/code&gt; 経由で実行されている&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;ストリームを停止します。</target>
        </trans-unit>
        <trans-unit id="195fbe53b32ee6173d85e3798809ae2267b7bfce" translate="yes" xml:space="preserve">
          <source>Marks the given keys to be watched for conditional execution of a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;トランザクションの&lt;/a&gt;条件付き実行を監視するために、指定されたキーをマークします。</target>
        </trans-unit>
        <trans-unit id="c8683729a7a727945cae9baf35f4c55f1439a9ae" translate="yes" xml:space="preserve">
          <source>Marks the start of a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt; block. Subsequent commands will be queued for atomic execution using &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;トランザクション&lt;/a&gt;ブロックの開始をマークします。後続のコマンドは、&lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;を使用したアトミック実行のためにキューに入れられます。</target>
        </trans-unit>
        <trans-unit id="f713e2ee906af8b74a13e92b2e0d07f7715b2d2e" translate="yes" xml:space="preserve">
          <source>Master for slot range represented as nested IP/Port array</source>
          <target state="translated">ネストされたIP/ポート配列で表されるスロット範囲のマスター</target>
        </trans-unit>
        <trans-unit id="826539552e055ad1bd8dd2263cef37308d024f80" translate="yes" xml:space="preserve">
          <source>Master output</source>
          <target state="translated">マスター出力</target>
        </trans-unit>
        <trans-unit id="221cc49f520f042d2c8db1934cf7365d8019893a" translate="yes" xml:space="preserve">
          <source>Matches are produced from the last one to the first one, since this is how the algorithm works, and it more efficient to emit things in the same order. The above array means that the first match (second element of the array) is between positions 2-3 of the first string and 0-1 of the second. Then there is another match between 4-7 and 5-8.</source>
          <target state="translated">マッチは最後のものから最初のものへと生成されます。これはアルゴリズムがどのように動作するかということと、同じ順序でものを出す方が効率的だからです。上記の配列は、最初のマッチ(配列の2番目の要素)が最初の文字列の2-3の位置と2番目の文字列の0-1の間にあることを意味します。そして、4-7 と 5-8 の間に別のマッチがあります。</target>
        </trans-unit>
        <trans-unit id="3a00e4f9797b4c734ae7a585f001ffa257119f27" translate="yes" xml:space="preserve">
          <source>Meaning of the flags (field number 3):</source>
          <target state="translated">フラグ(フィールド番号3)の意味。</target>
        </trans-unit>
        <trans-unit id="716383f923909d0c089205fcba00d4705b3601a5" translate="yes" xml:space="preserve">
          <source>Merge multiple HyperLogLog values into an unique value that will approximate the cardinality of the union of the observed Sets of the source HyperLogLog structures.</source>
          <target state="translated">複数のHyperLogLogの値を、元のHyperLog構造体の観測されたSetの和のカーディナリティに近い一意の値にマージします。</target>
        </trans-unit>
        <trans-unit id="d48699ea9bf170ea49610c0892198d522150833b" translate="yes" xml:space="preserve">
          <source>Migrating multiple keys with a single command call</source>
          <target state="translated">単一のコマンドコールによる複数のキーの移行</target>
        </trans-unit>
        <trans-unit id="1dc9fdcdad40a742a94a677f3b78a05f4ed5e6b5" translate="yes" xml:space="preserve">
          <source>Migration and importing slots are only added to the node flagged as &lt;code&gt;myself&lt;/code&gt;. This information is local to a node, for its own slots.</source>
          <target state="translated">移行およびインポートスロットは、 &lt;code&gt;myself&lt;/code&gt; フラグが付けられたノードにのみ追加されます。この情報は、独自のスロットについて、ノードに対してローカルです。</target>
        </trans-unit>
        <trans-unit id="b39875ef4297a449c400e22ef1b7f5a9df1b0b1a" translate="yes" xml:space="preserve">
          <source>Modules that register custom data types can not be unloaded.</source>
          <target state="translated">カスタムデータ型を登録しているモジュールはアンロードできません。</target>
        </trans-unit>
        <trans-unit id="bf4ac897fe1476ddf0632fbae3fd4061b3a77806" translate="yes" xml:space="preserve">
          <source>More details about the Redis HyperLogLog implementation can be found in &lt;a href=&quot;http://antirez.com/news/75&quot;&gt;this blog post&lt;/a&gt;. The source code of the implementation in the &lt;code&gt;hyperloglog.c&lt;/code&gt; file is also easy to read and understand, and includes a full specification for the exact encoding used for the sparse and dense representations.</source>
          <target state="translated">Redis HyperLogLog実装の詳細については、&lt;a href=&quot;http://antirez.com/news/75&quot;&gt;このブログ投稿を&lt;/a&gt;ご覧ください。 &lt;code&gt;hyperloglog.c&lt;/code&gt; ファイル内の実装のソースコードも読みやすく、理解しやすく、疎および密表現に使用される正確なエンコーディングの完全な仕様が含まれています。</target>
        </trans-unit>
        <trans-unit id="66fbce4faebab20f5ca1d3b33c08e967f22406cb" translate="yes" xml:space="preserve">
          <source>More information about the Current Epoch and Config Epoch variables are available in the Redis Cluster specification document.</source>
          <target state="translated">Current EpochとConfig Epoch変数についての詳細は、Redis Clusterの仕様書に記載されています。</target>
        </trans-unit>
        <trans-unit id="76f5a5481231f7dff85e48d6a0993bd209662a44" translate="yes" xml:space="preserve">
          <source>Moreover &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; does not need to be reciprocal. If I send the command to A in order to join B, I don't need to also send it to B in order to join A.</source>
          <target state="translated">さらに、&lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt;は相互である必要はありません。Bに参加するためにコマンドをAに送信した場合、Aに参加するためにコマンドをBにも送信する必要はありません。</target>
        </trans-unit>
        <trans-unit id="9e46ae1b67b3a95c0efb340b998c24643ca486fb" translate="yes" xml:space="preserve">
          <source>Moreover, as a side effect, &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; will increment the count of attempted deliveries of the message unless the &lt;code&gt;JUSTID&lt;/code&gt; option has been specified (which only delivers the message ID, not the message itself). In this way messages that cannot be processed for some reason, for instance because the consumers crash attempting to process them, will start to have a larger counter and can be detected inside the system.</source>
          <target state="translated">また、副作用として、&lt;a href=&quot;xclaim&quot;&gt;XCLAIMが&lt;/a&gt;ない限り、メッセージの配達試みのカウントをインクリメントする &lt;code&gt;JUSTID&lt;/code&gt; のオプションは（ないメッセージ自体、唯一のメッセージIDを提供している）が指定されています。このようにして、たとえばコンシューマーがメッセージを処理しようとしてクラッシュしたなどの理由で処理できないメッセージは、より大きなカウンターを持ち始め、システム内で検出できます。</target>
        </trans-unit>
        <trans-unit id="8993f2e40360ac488b5303cad3bacad41d3a08f1" translate="yes" xml:space="preserve">
          <source>Moreover, as a side effect, &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; will increment the count of attempted deliveries of the message. In this way messages that cannot be processed for some reason, for instance because the consumers crash attempting to process them, will start to have a larger counter and can be detected inside the system.</source>
          <target state="translated">さらに、副作用として、&lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;はメッセージの配信試行回数を増やします。このようにして、たとえばコンシューマがメッセージを処理しようとしてクラッシュしたために何らかの理由で処理できないメッセージは、より大きなカウンタを持ち始め、システム内で検出できます。</target>
        </trans-unit>
        <trans-unit id="6330fc6bbcd49c1766a676116e26172a91d38595" translate="yes" xml:space="preserve">
          <source>Moreover, if you are new to streams, we recommend to read our &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introduction to Redis Streams&lt;/a&gt;. Make sure to understand the concept of consumer group in the introduction so that following how this command works will be simpler.</source>
          <target state="translated">さらに、ストリーム&lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;に慣れてい&lt;/a&gt;ない場合は、Redis Streamsの紹介を読むことをお勧めします。このコマンドがどのように機能するかを簡単に理解できるように、はじめにコンシューマグループの概念を必ず理解してください。</target>
        </trans-unit>
        <trans-unit id="fde66fa86f8517d887e54616bf1fb31656fc7f81" translate="yes" xml:space="preserve">
          <source>Motivations</source>
          <target state="translated">Motivations</target>
        </trans-unit>
        <trans-unit id="eaf7a15ddfb6c5c306f486c8bf293512f163a845" translate="yes" xml:space="preserve">
          <source>Movable Keys</source>
          <target state="translated">可動キー</target>
        </trans-unit>
        <trans-unit id="f77b47b8d13d94af9785e089c536b9963ca2c823" translate="yes" xml:space="preserve">
          <source>Move &lt;code&gt;key&lt;/code&gt; from the currently selected database (see &lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt;) to the specified destination database. When &lt;code&gt;key&lt;/code&gt; already exists in the destination database, or it does not exist in the source database, it does nothing. It is possible to use &lt;a href=&quot;move&quot;&gt;MOVE&lt;/a&gt; as a locking primitive because of this.</source>
          <target state="translated">現在選択されているデータベース（&lt;a href=&quot;select&quot;&gt;SELECTを&lt;/a&gt;参照）から指定された宛先データベースに &lt;code&gt;key&lt;/code&gt; を移動します。 &lt;code&gt;key&lt;/code&gt; が宛先データベースにすでに存在する場合、またはソースデータベースに存在しない場合、何もしません。このため、&lt;a href=&quot;move&quot;&gt;MOVE&lt;/a&gt;をロックプリミティブとして使用できます。</target>
        </trans-unit>
        <trans-unit id="17c083c9f9d68a5d0169cd11d9c0c04115759b24" translate="yes" xml:space="preserve">
          <source>Move &lt;code&gt;member&lt;/code&gt; from the set at &lt;code&gt;source&lt;/code&gt; to the set at &lt;code&gt;destination&lt;/code&gt;. This operation is atomic. In every given moment the element will appear to be a member of &lt;code&gt;source&lt;/code&gt;&lt;strong&gt;or&lt;/strong&gt;&lt;code&gt;destination&lt;/code&gt; for other clients.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; のセットから &lt;code&gt;destination&lt;/code&gt; セットに &lt;code&gt;member&lt;/code&gt; を移動します。この操作はアトミックです。常に、要素は他のクライアントの &lt;code&gt;source&lt;/code&gt; &lt;strong&gt;または&lt;/strong&gt; &lt;code&gt;destination&lt;/code&gt; メンバーであるように見えます。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="95a91b78dd0ce912aadce361711a043cae9a887e" translate="yes" xml:space="preserve">
          <source>Multiple parallel iterations</source>
          <target state="translated">複数の並列反復</target>
        </trans-unit>
        <trans-unit id="f492964822aab7cec6aa84fefaffe8fba8b6cd36" translate="yes" xml:space="preserve">
          <source>Nested Result Array</source>
          <target state="translated">入れ子になった結果の配列</target>
        </trans-unit>
        <trans-unit id="fdc70576104b358de95d88f0255666aac631aff0" translate="yes" xml:space="preserve">
          <source>New fields are regularly added for debugging purpose. Some could be removed in the future. A version safe Redis client using this command should parse the output accordingly (i.e. handling gracefully missing fields, skipping unknown fields).</source>
          <target state="translated">新しいフィールドはデバッグのために定期的に追加されます。いくつかは将来的に削除される可能性があります。このコマンドを使用するバージョンセーフの Redis クライアントは、出力をそれに応じて解析しなければなりません (つまり、フィールドの欠落を優雅に処理したり、未知のフィールドをスキップしたりすること)。</target>
        </trans-unit>
        <trans-unit id="861e51e24f78632f52937df883ebeed5a0766d52" translate="yes" xml:space="preserve">
          <source>New keys are always created in the target node. During a hash slot migration we'll have to move only old keys, not new ones.</source>
          <target state="translated">新しい鍵は常にターゲットノードに作成されます。ハッシュスロットの移行の際には、新しい鍵ではなく古い鍵だけを移動させなければなりません。</target>
        </trans-unit>
        <trans-unit id="97bfa87b383568ddb64d92c09cf59316bbb313bd" translate="yes" xml:space="preserve">
          <source>No repeated elements are returned.</source>
          <target state="translated">繰り返し要素は返されません。</target>
        </trans-unit>
        <trans-unit id="75e932f04e490ddd2c64a4420d419573bd058eac" translate="yes" xml:space="preserve">
          <source>Nodes in &lt;code&gt;PFAIL&lt;/code&gt; state are provided in gossip sections of heartbeat packets.</source>
          <target state="translated">&lt;code&gt;PFAIL&lt;/code&gt; 状態のノードは、ハートビートパケットのゴシップセクションで提供されます。</target>
        </trans-unit>
        <trans-unit id="c02697f1f51c2f137246d46e8911c8e7f53e6636" translate="yes" xml:space="preserve">
          <source>Non existing elements are reported as NULL elements of the array.</source>
          <target state="translated">存在しない要素は、配列のNULL要素として報告されます。</target>
        </trans-unit>
        <trans-unit id="5dfb2fbf84cf8de01a0c2542d485d2207dc976ae" translate="yes" xml:space="preserve">
          <source>Non used lines are blanked. For instance if you used to have multiple &lt;code&gt;save&lt;/code&gt; directives, but the current configuration has fewer or none as you disabled RDB persistence, all the lines will be blanked.</source>
          <target state="translated">使用されていない行は空白になります。たとえば、以前は複数の &lt;code&gt;save&lt;/code&gt; ディレクティブがあったが、RDBの永続性を無効にしたために現在の構成が少ないかまったくない場合、すべての行が空白になります。</target>
        </trans-unit>
        <trans-unit id="de44f50198c0734dcccb5b1c5d4825eb72c13aba" translate="yes" xml:space="preserve">
          <source>Non-blocking behavior</source>
          <target state="translated">ノンブロッキング動作</target>
        </trans-unit>
        <trans-unit id="5cbfa62b0d0a8a33923d06127db99370a393ad0d" translate="yes" xml:space="preserve">
          <source>Non-blocking usage</source>
          <target state="translated">ノンブロッキングの使い方</target>
        </trans-unit>
        <trans-unit id="bcbbb0c35f64190eb100cd6befa838fbd5037874" translate="yes" xml:space="preserve">
          <source>Non-existent keys are treated as empty strings, so the command will return zero.</source>
          <target state="translated">存在しないキーは空文字列として扱われるので、コマンドは0を返します。</target>
        </trans-unit>
        <trans-unit id="46b493cea7b65b3003ea2e423707591849b0ee78" translate="yes" xml:space="preserve">
          <source>Non-existent keys are treated as empty strings.</source>
          <target state="translated">存在しないキーは空の文字列として扱われます。</target>
        </trans-unit>
        <trans-unit id="9a60acaa61d5a344489afdd9e5311dbf8888aa00" translate="yes" xml:space="preserve">
          <source>Normally &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt; is simply used in order to get range of items where the score is the indexed integer key, however it is possible to do less obvious things with the command.</source>
          <target state="translated">通常、&lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;は、スコアがインデックス付き整数キーであるアイテムの範囲を取得するために単純に使用されますが、コマンドを使用してあまり明確でないことを行うことができます。</target>
        </trans-unit>
        <trans-unit id="4dba9f7be4e65fcc1fd8d86533e96e912932e110" translate="yes" xml:space="preserve">
          <source>Normally Redis keys are created without an associated time to live. The key will simply live forever, unless it is removed by the user in an explicit way, for instance using the &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; command.</source>
          <target state="translated">通常、Redisキーは、有効期間が関連付けられていない状態で作成されます。たとえば、&lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;コマンドを使用するなど、ユーザーが明示的な方法で削除しない限り、キーは永久に存続します。</target>
        </trans-unit>
        <trans-unit id="488e099ce2d3130dde9348d7a491fea120dffc25" translate="yes" xml:space="preserve">
          <source>Normally Redis represents positions of elements using a variation of the Geohash technique where positions are encoded using 52 bit integers. The encoding is also different compared to the standard because the initial min and max coordinates used during the encoding and decoding process are different. This command however &lt;strong&gt;returns a standard Geohash&lt;/strong&gt; in the form of a string as described in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Wikipedia article&lt;/a&gt; and compatible with the &lt;a href=&quot;http://geohash.org&quot;&gt;geohash.org&lt;/a&gt; web site.</source>
          <target state="translated">通常、Redisは、位置が52ビット整数を使用してエンコードされるGeohash技術のバリエーションを使用して、要素の位置を表します。エンコードおよびデコードプロセス中に使用される初期の最小および最大座標が異なるため、エンコードも標準とは異なります。ただし&lt;strong&gt;、&lt;/strong&gt;このコマンドは、&lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Wikipediaの記事に&lt;/a&gt;記載されている&lt;a href=&quot;http://geohash.org&quot;&gt;geohash.org&lt;/a&gt; Webサイトと互換性の&lt;strong&gt;ある標準のGeohash&lt;/strong&gt;を文字列の形式で&lt;strong&gt;返します&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="48fbc2c3360b2ccdab702dc73f1af3fdad88932d" translate="yes" xml:space="preserve">
          <source>Normally hash slots associated to a given node are in one of the following formats, as already explained above:</source>
          <target state="translated">通常、与えられたノードに関連付けられたハッシュスロットは、上で説明したように、以下の形式のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="20da22f8d3c73a214f41394b1c9a9c08c0230154" translate="yes" xml:space="preserve">
          <source>Normally if there is an AOF child process performing an AOF rewrite, Redis will simply kill it and exit. However there are two conditions where it is unsafe to do so, and the &lt;strong&gt;SHUTDOWN&lt;/strong&gt; command will be refused with an error instead. This happens when:</source>
          <target state="translated">通常、AOF書き換えを実行するAOF子プロセスがある場合、Redisは単にそれを強制終了して終了します。ただし、これを行うのが安全ではない状況が2つあり、代わりに&lt;strong&gt;SHUTDOWN&lt;/strong&gt;コマンドがエラーで拒否されます。これは次の場合に発生します：</target>
        </trans-unit>
        <trans-unit id="f552eaf00c55408f0aa996335bcd91c4da8dcdb7" translate="yes" xml:space="preserve">
          <source>Normally replica nodes will redirect clients to the authoritative master for the hash slot involved in a given command, however clients can use replicas in order to scale reads using the &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; command.</source>
          <target state="translated">通常、レプリカノードは、指定されたコマンドに関連するハッシュスロットの信頼できるマスターにクライアントをリダイレクトしますが、クライアントは&lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt;コマンドを使用して読み取りをスケーリングするためにレプリカを使用できます。</target>
        </trans-unit>
        <trans-unit id="0b040d0fd81d55e920e28d6b8b43687a96fedfb9" translate="yes" xml:space="preserve">
          <source>Normally replicating scripts instead of the effects of the scripts makes sense, however not in all the cases. So starting with Redis 3.2, the scripting engine is able to, alternatively, replicate the sequence of write commands resulting from the script execution, instead of replication the script itself. See the next section for more information. In this section we'll assume that scripts are replicated by sending the whole script. Let's call this replication mode &lt;strong&gt;whole scripts replication&lt;/strong&gt;.</source>
          <target state="translated">通常、スクリプトの効果の代わりにスクリプトを複製することには意味がありますが、すべての場合に当てはまるわけではありません。そのため、Redis 3.2以降では、スクリプトエンジンは、スクリプト自体を複製する代わりに、スクリプトの実行結果である書き込みコマンドのシーケンスを複製することができます。詳細については、次のセクションを参照してください。このセクションでは、スクリプト全体を送信することによってスクリプトが複製されると想定します。このレプリケーションモードを&lt;strong&gt;スクリプト全体を&lt;/strong&gt;レプリケーションと呼びましょう。</target>
        </trans-unit>
        <trans-unit id="632bc7f3cbfc39c1e051fc94bc2f5127d08b095a" translate="yes" xml:space="preserve">
          <source>Normally the OK code is immediately returned. Redis forks, the parent continues to serve the clients, the child saves the DB on disk then exits.</source>
          <target state="translated">通常はすぐにOKコードが返されます。Redisがフォークすると、親はクライアントにサービスを提供し続け、子はDBをディスクに保存してから終了します。</target>
        </trans-unit>
        <trans-unit id="de2018dd71c22fe4b55fd2f381e3bcbd8ea7b844" translate="yes" xml:space="preserve">
          <source>Normally you may think at a Redis stream as an append-only data structure, however Redis streams are represented in memory, so we are able to also delete entries. This may be useful, for instance, in order to comply with certain privacy policies.</source>
          <target state="translated">通常、Redisのストリームは追加のみのデータ構造と考えるかもしれませんが、Redisのストリームはメモリで表現されているので、エントリを削除することもできます。これは、例えば、特定のプライバシーポリシーに準拠するために便利かもしれません。</target>
        </trans-unit>
        <trans-unit id="675cc42aab3b45855f7e4f48b1a8a2f9ea1abcdc" translate="yes" xml:space="preserve">
          <source>Normally you use the command like that in order to get new messages and process them. In pseudo-code:</source>
          <target state="translated">通常は、新しいメッセージを取得して処理するために、このようなコマンドを使用します。疑似コードで</target>
        </trans-unit>
        <trans-unit id="92faf092f64b7750013de7ad70293bed4c22e467" translate="yes" xml:space="preserve">
          <source>Note for Lua newbies: in order to avoid using global variables in your scripts simply declare every variable you are going to use using the &lt;em&gt;local&lt;/em&gt; keyword.</source>
          <target state="translated">Luaの初心者への注意：スクリプトでグローバル変数を使用しないようにするには、使用するすべての変数を&lt;em&gt;local&lt;/em&gt;キーワードを使用して宣言するだけです。</target>
        </trans-unit>
        <trans-unit id="386ff54d1c33b65d55947a3bc043df349ed6b50a" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;, &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;, &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; and &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; all work very similarly, so this documentation covers all the four commands. However an obvious difference is that in the case of &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;, &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; and &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; the first argument is the name of the key holding the Set, Hash or Sorted Set value. The &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; command does not need any key name argument as it iterates keys in the current database, so the iterated object is the database itself.</source>
          <target state="translated">なお、&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;、&lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;、&lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt;と&lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt;すべての作業は非常に同様に、このドキュメントはすべての4つのコマンドをカバーしていて。ただし、明らかな違いは、&lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;、&lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt;、および&lt;a href=&quot;zscan&quot;&gt;ZSCANの場合&lt;/a&gt;、最初の引数はSet、Hash、またはSorted Setの値を保持するキーの名前であることです。&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;それは現在のデータベースにキーを反復して反復オブジェクトがデータベースそのものであるので、このコマンドは、任意のキー名の引数を必要としません。</target>
        </trans-unit>
        <trans-unit id="b8af6b6330cf6687e8cc50e67b81c7d7beffd113" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; does not make Redis a strongly consistent store: while synchronous replication is part of a replicated state machine, it is not the only thing needed. However in the context of Sentinel or Redis Cluster failover, &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; improves the real world data safety.</source>
          <target state="translated">&lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;はRedisを強い整合性のあるストアにするわけではないことに注意してください。同期複製は複製された状態マシンの一部ですが、必要なのはそれだけではありません。ただし、SentinelまたはRedisクラスターのフェイルオーバーのコンテキストでは、&lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;は実際のデータの安全性を向上させます。</target>
        </trans-unit>
        <trans-unit id="196f50bc6a6ac776d1991175d0001fae97125b81" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; is also available since Redis 3.2.10 and Redis 4.0.0 in order to provide a read-only command that can be used in replicas. See the &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; page for more information.</source>
          <target state="translated">&lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; は、レプリカで使用できる読み取り専用コマンドを提供するために、Redis 3.2.10およびRedis 4.0.0以降でも使用できることに注意してください。詳細は&lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt;ページをご覧ください。</target>
        </trans-unit>
        <trans-unit id="7f4713a8dfe3582f9f0fc3ed836bf0396dfbd617" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;TAKEOVER violates the last-failover-wins principle&lt;/strong&gt; of Redis Cluster, since the configuration epoch generated by the replica violates the normal generation of configuration epochs in several ways:</source>
          <target state="translated">&lt;strong&gt;TAKEOVER&lt;/strong&gt;はRedisクラスター&lt;strong&gt;のlast-failover-wins原則&lt;/strong&gt;に&lt;strong&gt;違反して&lt;/strong&gt;いることに注意してください。レプリカによって生成された構成エポックは、いくつかの点で構成エポックの通常の生成に違反しています。</target>
        </trans-unit>
        <trans-unit id="b1e5f99b4ded8ce6be23a9f6f9872d3e5595ab46" translate="yes" xml:space="preserve">
          <source>Note that Redis Cluster needs to form a full mesh (each node is connected with each other node), but in order to create a cluster, there is no need to send all the &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; commands needed to form the full mesh. What matter is to send enough &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; messages so that each node can reach each other node through a &lt;em&gt;chain of known nodes&lt;/em&gt;. Thanks to the exchange of gossip information in heartbeat packets, the missing links will be created.</source>
          <target state="translated">Redisクラスターはフルメッシュを形成する必要があります（各ノードは他のノードに接続されています）が、クラスターを作成するために、フルメッシュを形成するために必要なすべての&lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt;コマンドを送信する必要はありません。重要なのは、各ノードが&lt;em&gt;既知のノードのチェーンを&lt;/em&gt;介して他のノードに到達できるように、十分な&lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt;メッセージを送信することです。ハートビートパケットのゴシップ情報の交換のおかげで、ミッシングリンクが作成されます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2d97296cb1d6030b84b67b56dc33de3881c08256" translate="yes" xml:space="preserve">
          <source>Note that a script can switch back and forth from RESP3 and RESP2 by calling the function with the argument '3' or '2'.</source>
          <target state="translated">スクリプトは、引数 '3' または '2' で関数を呼び出すことで、RESP3 と RESP2 を切り替えることができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="17fc5decb8a235b9d4881b1185aa05ef897a69aa" translate="yes" xml:space="preserve">
          <source>Note that bit positions are returned always as absolute values starting from bit zero even when &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; are used to specify a range.</source>
          <target state="translated">&lt;em&gt;開始&lt;/em&gt;と&lt;em&gt;終了&lt;/em&gt;を使用して範囲を指定した場合でも、ビット位置は常にビット0から始まる絶対値として返されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d47127e4277fb6af8f1ec3e041d7aadf84ff3fe6" translate="yes" xml:space="preserve">
          <source>Note that calling &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;/&lt;a href=&quot;pexpire&quot;&gt;PEXPIRE&lt;/a&gt; with a non-positive timeout or &lt;a href=&quot;expireat&quot;&gt;EXPIREAT&lt;/a&gt;/&lt;a href=&quot;pexpireat&quot;&gt;PEXPIREAT&lt;/a&gt; with a time in the past will result in the key being &lt;a href=&quot;del&quot;&gt;deleted&lt;/a&gt; rather than expired (accordingly, the emitted &lt;a href=&quot;https://redis.io/topics/notifications&quot;&gt;key event&lt;/a&gt; will be &lt;code&gt;del&lt;/code&gt;, not &lt;code&gt;expired&lt;/code&gt;).</source>
          <target state="translated">（注）呼び出しがその&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; / &lt;a href=&quot;pexpire&quot;&gt;PEXPIRE&lt;/a&gt;非正タイムアウトまたは有する&lt;a href=&quot;expireat&quot;&gt;EXPIREAT&lt;/a&gt; / &lt;a href=&quot;pexpireat&quot;&gt;PEXPIREAT&lt;/a&gt;キーであることになり、過去の時間は&lt;a href=&quot;del&quot;&gt;削除&lt;/a&gt;（従って、放出された有効期限が切れたのではなく、&lt;a href=&quot;https://redis.io/topics/notifications&quot;&gt;キーイベントが&lt;/a&gt;あろう &lt;code&gt;del&lt;/code&gt; ない、 &lt;code&gt;expired&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="134cdffcc8cc8242a1731baa707e6b6f212bd203" translate="yes" xml:space="preserve">
          <source>Note that each &lt;code&gt;OVERFLOW&lt;/code&gt; statement only affects the &lt;a href=&quot;incrby&quot;&gt;INCRBY&lt;/a&gt; commands that follow it in the list of subcommands, up to the next &lt;code&gt;OVERFLOW&lt;/code&gt; statement.</source>
          <target state="translated">各 &lt;code&gt;OVERFLOW&lt;/code&gt; ステートメントは、次の &lt;code&gt;OVERFLOW&lt;/code&gt; ステートメントまで、サブコマンドのリストでそれに続く&lt;a href=&quot;incrby&quot;&gt;INCRBY&lt;/a&gt;コマンドにのみ影響することに注意してください。</target>
        </trans-unit>
        <trans-unit id="c59e6cb007a017cde6a0590f3fe3a6903d02fdbc" translate="yes" xml:space="preserve">
          <source>Note that for correctly implementing this pattern it is important to avoid multiple clients rebuilding the cache at the same time. Some kind of locking is needed here (for instance using &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;).</source>
          <target state="translated">このパターンを正しく実装するには、複数のクライアントが同時にキャッシュを再構築しないようにすることが重要です。ここでは何らかのロックが必要です（たとえば、&lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;を使用）。</target>
        </trans-unit>
        <trans-unit id="ab5932614de576b14cea0fbf3d424f67389687d0" translate="yes" xml:space="preserve">
          <source>Note that for the same reason a Lua script or a &lt;code&gt;MULTI/EXEC&lt;/code&gt; block may push elements into a list and afterward &lt;strong&gt;delete the list&lt;/strong&gt;. In this case the blocked clients will not be served at all and will continue to be blocked as long as no data is present on the list after the execution of a single command, transaction, or script.</source>
          <target state="translated">同じ理由で、Luaスクリプトまたは &lt;code&gt;MULTI/EXEC&lt;/code&gt; ブロックが要素をリストにプッシュし、後でリストを&lt;strong&gt;削除する&lt;/strong&gt;場合があることに注意してください。この場合、ブロックされたクライアントはまったく提供されず、単一のコマンド、トランザクション、またはスクリプトの実行後にリストにデータが存在しない限り、ブロックされ続けます。</target>
        </trans-unit>
        <trans-unit id="fcc828a00ba6196c133772751828406df7944657" translate="yes" xml:space="preserve">
          <source>Note that if a replica is added, moved, or removed from a given master node, and we ask &lt;a href=&quot;cluster-replicas&quot;&gt;CLUSTER REPLICAS&lt;/a&gt; to a node that has not yet received the configuration update, it may show stale information. However eventually (in a matter of seconds if there are no network partitions) all the nodes will agree about the set of nodes associated with a given master.</source>
          <target state="translated">特定のマスターノードでレプリカが追加、移動、または削除され、構成の更新をまだ受け取っていないノードに&lt;a href=&quot;cluster-replicas&quot;&gt;CLUSTER REPLICAS&lt;/a&gt;を要求すると、古い情報が表示される場合があることに注意してください。ただし、最終的に（ネットワークパーティションがない場合は数秒で）、すべてのノードが特定のマスターに関連付けられたノードのセットについて合意します。</target>
        </trans-unit>
        <trans-unit id="21094e1f69e7fc1828b555fe35532f052b5ac245" translate="yes" xml:space="preserve">
          <source>Note that if a replica is added, moved, or removed from a given master node, and we ask &lt;a href=&quot;cluster-slaves&quot;&gt;CLUSTER SLAVES&lt;/a&gt; to a node that has not yet received the configuration update, it may show stale information. However eventually (in a matter of seconds if there are no network partitions) all the nodes will agree about the set of nodes associated with a given master.</source>
          <target state="translated">特定のマスターノードでレプリカが追加、移動、または削除され、構成の更新をまだ受信していないノードに&lt;a href=&quot;cluster-slaves&quot;&gt;CLUSTER SLAVES&lt;/a&gt;を要求すると、古い情報が表示される場合があることに注意してください。ただし、最終的に（ネットワークパーティションがない場合は数秒で）、すべてのノードが特定のマスターに関連付けられたノードのセットについて合意します。</target>
        </trans-unit>
        <trans-unit id="92bc3cdf3318fb930ded8c852b6a00267accad1a" translate="yes" xml:space="preserve">
          <source>Note that if you have a list of numbers from 0 to 100, &lt;code&gt;LRANGE list 0 10&lt;/code&gt; will return 11 elements, that is, the rightmost item is included. This &lt;strong&gt;may or may not&lt;/strong&gt; be consistent with behavior of range-related functions in your programming language of choice (think Ruby's &lt;code&gt;Range.new&lt;/code&gt;, &lt;code&gt;Array#slice&lt;/code&gt; or Python's &lt;code&gt;range()&lt;/code&gt; function).</source>
          <target state="translated">0から100までの数値のリストがある場合、 &lt;code&gt;LRANGE list 0 10&lt;/code&gt; は11個の要素を返します。つまり、右端の項目が含まれます。これ&lt;strong&gt;は&lt;/strong&gt;、選択したプログラミング言語の範囲関連関数の動作と一致する&lt;strong&gt;場合&lt;/strong&gt;と一致し&lt;strong&gt;ない場合があり&lt;/strong&gt;ます（Rubyの &lt;code&gt;Range.new&lt;/code&gt; 、 &lt;code&gt;Array#slice&lt;/code&gt; 、またはPythonの &lt;code&gt;range()&lt;/code&gt; 関数と考えてください）。</target>
        </trans-unit>
        <trans-unit id="b145f3c9b171e7c40ecd23d7161660cea0ebde1c" translate="yes" xml:space="preserve">
          <source>Note that it is valid to call this command without channels. In this case it will just return an empty list.</source>
          <target state="translated">チャンネルなしでこのコマンドを呼び出すことが有効であることに注意してください。この場合、空のリストを返すだけです。</target>
        </trans-unit>
        <trans-unit id="7cbc0087feeeb4b8394154849c8ec33aeb518c13" translate="yes" xml:space="preserve">
          <source>Note that non-existing keys are treated like empty lists, so when &lt;code&gt;key&lt;/code&gt; does not exist, the command will always return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">存在しない &lt;code&gt;key&lt;/code&gt; は空のリストのように扱われるため、キーが存在しない場合、コマンドは常に &lt;code&gt;0&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="e83de8fca6610aa183e7aad22115791cd55bc9fb" translate="yes" xml:space="preserve">
          <source>Note that normally clients willing to fetch the map between Cluster hash slots and node addresses should use &lt;a href=&quot;cluster-slots&quot;&gt;CLUSTER SLOTS&lt;/a&gt; instead. &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt;, that provides more information, should be used for administrative tasks, debugging, and configuration inspections. It is also used by &lt;code&gt;redis-trib&lt;/code&gt; in order to manage a cluster.</source>
          <target state="translated">通常、クラスターハッシュスロットとノードアドレスの間でマップをフェッチするクライアントは、代わりに&lt;a href=&quot;cluster-slots&quot;&gt;CLUSTER SLOTS&lt;/a&gt;を使用する必要があることに注意してください。詳細情報を提供する&lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODESは&lt;/a&gt;、管理タスク、デバッグ、および構成の検査に使用する必要があります。また、クラスターを管理するために &lt;code&gt;redis-trib&lt;/code&gt; によって使用されます。</target>
        </trans-unit>
        <trans-unit id="1f6b2fdffdf326f5f641aa170f10beb1a26d5924" translate="yes" xml:space="preserve">
          <source>Note that once a node assigns a set of slots to itself, it will start propagating this information in heartbeat packet headers. However the other nodes will accept the information only if they have the slot as not already bound with another node, or if the configuration epoch of the node advertising the new hash slot, is greater than the node currently listed in the table.</source>
          <target state="translated">ノードがスロットのセットを自分自身に割り当てると、その情報はハートビートパケットヘッダで伝搬を開始することに注意してください。しかし、他のノードは、スロットが他のノードとまだバインドされていない場合、または、新しいハッシュスロットを広告するノードのコンフィグレーションエポックが、現在テーブルにリストされているノードよりも大きい場合にのみ、情報を受け入れます。</target>
        </trans-unit>
        <trans-unit id="34efcb15ecc544550f9bd4f238eeb1c37bfe6eb5" translate="yes" xml:space="preserve">
          <source>Note that the command implements the full hashing algorithm, including support for &lt;strong&gt;hash tags&lt;/strong&gt;, that is the special property of Redis Cluster key hashing algorithm, of hashing just what is between &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; if such a pattern is found inside the key name, in order to force multiple keys to be handled by the same node.</source>
          <target state="translated">コマンドは、&lt;strong&gt;ハッシュタグの&lt;/strong&gt;サポートを含む完全なハッシュアルゴリズムを実装することに注意してください。これは、Redisクラスターのキーハッシュアルゴリズムの特別なプロパティであり、このようなパターンがキー名の中に見つかった場合、 &lt;code&gt;{&lt;/code&gt; と &lt;code&gt;}&lt;/code&gt; の間にあるものだけをハッシュします。複数のキーを同じノードで処理するように強制します。</target>
        </trans-unit>
        <trans-unit id="44319adff6c7cf60df65ef2f592ee1b07d9db575" translate="yes" xml:space="preserve">
          <source>Note that the format does not have any space, so &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; output format is plain CSV with space as separator even when this special slots are emitted. However a complete parser for the format should be able to handle them.</source>
          <target state="translated">この形式にはスペースがないため、&lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODESの&lt;/a&gt;出力形式は、この特別なスロットが発行された場合でも、区切り文字としてスペースを含むプレーンCSVであることに注意してください。ただし、形式の完全なパーサーはそれらを処理できる必要があります。</target>
        </trans-unit>
        <trans-unit id="277c523b6a84e71c0289aa21eae881f107096f52" translate="yes" xml:space="preserve">
          <source>Note that the indexes are still reported in the &quot;natural&quot; way, that is, considering the first element starting from the head of the list at index 0, the next element at index 1, and so forth. This basically means that the returned indexes are stable whatever the rank is positive or negative.</source>
          <target state="translated">インデックスは、リストの先頭から始まる最初の要素をインデックス0、次の要素をインデックス1、というように、&quot;自然な &quot;方法で報告されることに注意してください。これは、基本的に、返されるインデックスは、順位が正であろうと負であろうと安定していることを意味します。</target>
        </trans-unit>
        <trans-unit id="6cf3d39f27c1b799248d5e59a73b1a5b0f086afd" translate="yes" xml:space="preserve">
          <source>Note that the maximum offset that you can set is 2&lt;sup&gt;29&lt;/sup&gt; -1 (536870911), as Redis Strings are limited to 512 megabytes. If you need to grow beyond this size, you can use multiple keys.</source>
          <target state="translated">Redis文字列は512メガバイトに制限されているため、設定できる最大オフセットは2 &lt;sup&gt;29&lt;/sup&gt; -1（536870911）であることに注意してください。このサイズを超えて拡張する必要がある場合は、複数のキーを使用できます。</target>
        </trans-unit>
        <trans-unit id="365b9132d09f3318597589e9536ca42a38461cb4" translate="yes" xml:space="preserve">
          <source>Note that the message is claimed only if its idle time is greater the minimum idle time we specify when calling &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;. Because as a side effect &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; will also reset the idle time (since this is a new attempt at processing the message), two consumers trying to claim a message at the same time will never both succeed: only one will successfully claim the message. This avoids that we process a given message multiple times in a trivial way (yet multiple processing is possible and unavoidable in the general case).</source>
          <target state="translated">メッセージが要求されるのは、そのアイドル時間が、&lt;a href=&quot;xclaim&quot;&gt;XCLAIMを&lt;/a&gt;呼び出すときに指定する最小アイドル時間より大きい場合のみであることに注意してください。副作用として&lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;はアイドル時間もリセットするため（これはメッセージを処理するための新しい試みであるため）、同時にメッセージを要求しようとする2つのコンシューマーは両方が成功することはなく、1つだけがメッセージを正常に要求します。これにより、特定のメッセージを簡単な方法で複数回処理することが回避されます（ただし、一般的なケースでは、複数の処理が可能であり、不可避です）。</target>
        </trans-unit>
        <trans-unit id="dbbe3c8e1b4fe3c7e220f023943635e1ebf82c17" translate="yes" xml:space="preserve">
          <source>Note that this algorithm runs in &lt;code&gt;O(N*M)&lt;/code&gt; time, where N is the length of the first string and M is the length of the second string. So either spin a different Redis instance in order to run this algorithm, or make sure to run it against very small strings.</source>
          <target state="translated">このアルゴリズムは &lt;code&gt;O(N*M)&lt;/code&gt; 時間で実行されることに注意してください。ここで、Nは最初の文字列の長さ、Mは2番目の文字列の長さです。したがって、このアルゴリズムを実行するために別のRedisインスタンスをスピンするか、非常に小さい文字列に対して実行するようにしてください。</target>
        </trans-unit>
        <trans-unit id="900544e94991ba5defea5df80a0dccc1aa474e00" translate="yes" xml:space="preserve">
          <source>Note that this command is not suitable when you need a guaranteed uniform distribution of the returned elements. For more information about the algorithms used for &lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt;, look up both the Knuth sampling and Floyd sampling algorithms.</source>
          <target state="translated">このコマンドは、返される要素の均一な分布を保証する必要がある場合には適していないことに注意してください。&lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt;に使用されるアルゴリズムの詳細については、クヌースサンプリングアルゴリズムとフロイドサンプリングアルゴリズムの両方を調べてください。</target>
        </trans-unit>
        <trans-unit id="581b6da11286a19b84f5dbf7d26c9c4e1e18433c" translate="yes" xml:space="preserve">
          <source>Note that this command is not suitable when you need a guaranteed uniform distribution of the returned elements. For more information about the algorithms used for SPOP, look up both the Knuth sampling and Floyd sampling algorithms.</source>
          <target state="translated">このコマンドは、返された要素の一様な分布を保証する必要がある場合には適していないことに注意してください。SPOP に使用されるアルゴリズムの詳細については、Knuth サンプリングと Floyd サンプリングの両方のアルゴリズムを参照してください。</target>
        </trans-unit>
        <trans-unit id="7aae41763fe9b0bc6731024cb063283c77ec4608" translate="yes" xml:space="preserve">
          <source>Note that this implementation of workers is trivially scalable and reliable, because even if a message is lost the item is still in the queue and will be processed at the next iteration.</source>
          <target state="translated">このワーカーの実装は、メッセージが失われた場合でも、アイテムはキューに残っており、次の繰り返しで処理されるため、些細なことでもスケーラブルで信頼性が高いことに注意してください。</target>
        </trans-unit>
        <trans-unit id="de6800f82ca82bf510c822b7935a67d6ca2bf21c" translate="yes" xml:space="preserve">
          <source>Note that we have a race here, but it is not a problem: &lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt; may return false but the key may be created by another client before we create it inside the &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; block. However this race will just miss an API call under rare conditions, so the rate limiting will still work correctly.</source>
          <target state="translated">ここでは競合があることに注意してください。ただし、問題はありません&lt;a href=&quot;exists&quot;&gt;。EXISTS&lt;/a&gt;はfalseを返す場合がありますが、&lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;ブロック内にキーを作成する前に、別のクライアントによってキーが作成される場合があります。ただし、このレースはまれな状況でAPI呼び出しを逃すだけなので、レート制限は引き続き正しく機能します。</target>
        </trans-unit>
        <trans-unit id="290162572eb7adbad822a4117dca945c127babde" translate="yes" xml:space="preserve">
          <source>Note that you need a recent version of redis-cli in order to read the slow log output, since it uses some features of the protocol that were not formerly implemented in redis-cli (deeply nested multi bulk replies).</source>
          <target state="translated">遅いログ出力を読むためには、redis-cli の最新バージョンが必要になることに注意してください。</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="translated">そのことに注意してください。</target>
        </trans-unit>
        <trans-unit id="851be398fabf2219f9c3aa64609a72f0559cc785" translate="yes" xml:space="preserve">
          <source>Note the used of &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; and &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; in order to make sure that we'll both increment and set the expire at every API call.</source>
          <target state="translated">&lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt;および&lt;a href=&quot;exec&quot;&gt;EXECの&lt;/a&gt;使用に注意してください。これは、すべてのAPI呼び出しでインクリメントと期限切れの両方を確実に行うためです。</target>
        </trans-unit>
        <trans-unit id="0ab5850865b49bbe39f155ec6e364488933508f0" translate="yes" xml:space="preserve">
          <source>Note this rule is not enforced in order to provide the user with opportunities to abuse the Redis single instance configuration, at the cost of writing scripts not compatible with Redis Cluster.</source>
          <target state="translated">このルールは、Redisクラスタと互換性のないスクリプトを書くことを犠牲にして、ユーザにRedisのシングルインスタンス設定を悪用する機会を提供するために施行されていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="9dfbcfbbaf119bccc3c44b098de0573996677b97" translate="yes" xml:space="preserve">
          <source>Note: A Redis instance that is configured for not persisting on disk (no AOF configured, nor &quot;save&quot; directive) will not dump the RDB file on &lt;a href=&quot;shutdown&quot;&gt;SHUTDOWN&lt;/a&gt;, as usually you don't want Redis instances used only for caching to block on when shutting down.</source>
          <target state="translated">注：ディスクに永続化しないように構成されている（AOFが構成されていない、または「保存」ディレクティブがない）Redisインスタンスは、&lt;a href=&quot;shutdown&quot;&gt;SHUTDOWN&lt;/a&gt;でRDBファイルをダンプしません。シャットダウンしています。</target>
        </trans-unit>
        <trans-unit id="4ffe4a3dcb4982dba6203770d54b7b49b3ebdb4a" translate="yes" xml:space="preserve">
          <source>Note: Since the &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command options can replace &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;, &lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt;, &lt;a href=&quot;psetex&quot;&gt;PSETEX&lt;/a&gt;, &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt;, it is possible that in future versions of Redis these three commands will be deprecated and finally removed.</source>
          <target state="translated">注：&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;コマンドオプションは&lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;、&lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt;、&lt;a href=&quot;psetex&quot;&gt;PSETEX&lt;/a&gt;、&lt;a href=&quot;getset&quot;&gt;GETSETを&lt;/a&gt;置き換えることができるため、Redisの将来のバージョンでは、これら3つのコマンドが非推奨になり、最終的に削除される可能性があります。</target>
        </trans-unit>
        <trans-unit id="40e3fa9c72775db4fd05d5cf7a3a493e93afca05" translate="yes" xml:space="preserve">
          <source>Note: Since the &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command options can replace &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;, &lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt;, &lt;a href=&quot;psetex&quot;&gt;PSETEX&lt;/a&gt;, it is possible that in future versions of Redis these three commands will be deprecated and finally removed.</source>
          <target state="translated">注：&lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;コマンドオプションは&lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;、&lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt;、&lt;a href=&quot;psetex&quot;&gt;PSETEXを&lt;/a&gt;置き換えることができるため、Redisの将来のバージョンでは、これらの3つのコマンドが非推奨になり、最終的に削除される可能性があります。</target>
        </trans-unit>
        <trans-unit id="81129f6603906deb00ee7e872ec230ada40b4ee1" translate="yes" xml:space="preserve">
          <source>Note: The &lt;strong&gt;GT&lt;/strong&gt;, &lt;strong&gt;LT&lt;/strong&gt; and &lt;strong&gt;NX&lt;/strong&gt; options are mutually exclusive.</source>
          <target state="translated">注：&lt;strong&gt;GT&lt;/strong&gt;、&lt;strong&gt;LT&lt;/strong&gt;、および&lt;strong&gt;NX&lt;/strong&gt;オプションは相互に排他的です。</target>
        </trans-unit>
        <trans-unit id="3d6762a6aa2cf0aca37a59f773d7789ef284a403" translate="yes" xml:space="preserve">
          <source>Note: an important part of this behavior is that the PRNG that Redis implements as &lt;code&gt;math.random&lt;/code&gt; and &lt;code&gt;math.randomseed&lt;/code&gt; is guaranteed to have the same output regardless of the architecture of the system running Redis. 32-bit, 64-bit, big-endian and little-endian systems will all produce the same output.</source>
          <target state="translated">注：この動作の重要な部分は、Redisが &lt;code&gt;math.random&lt;/code&gt; および &lt;code&gt;math.randomseed&lt;/code&gt; として実装するPRNGが、Redisを実行しているシステムのアーキテクチャーに関係なく、同じ出力を持つことが保証されていることです。32ビット、64ビット、ビッグエンディアン、リトルエンディアンのシステムはすべて同じ出力を生成します。</target>
        </trans-unit>
        <trans-unit id="19d14832252be8ae1106f6c63fb642cd3e9e2df4" translate="yes" xml:space="preserve">
          <source>Note: as a side effect of calling this function, it is possible that the HyperLogLog is modified, since the last 8 bytes encode the latest computed cardinality for caching purposes. So &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; is technically a write command.</source>
          <target state="translated">注：この関数を呼び出すことの副作用として、最後の8バイトがキャッシュのために計算された最新のカーディナリティをエンコードするため、HyperLogLogが変更される可能性があります。したがって、&lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt;は技術的には書き込みコマンドです。</target>
        </trans-unit>
        <trans-unit id="ca716680732d1d3e7b5dc5d38bf23aaa2688e964" translate="yes" xml:space="preserve">
          <source>Note: as you can see Lua arrays are returned as Redis multi bulk replies, that is a Redis return type that your client library will likely convert into an Array type in your programming language.</source>
          <target state="translated">注意:Luaの配列はRedisのマルチバルクリプライとして返されますが、これはRedisのリターン型であり、クライアントライブラリがプログラミング言語でArray型に変換する可能性が高いです。</target>
        </trans-unit>
        <trans-unit id="a094e9a0339a167054eac3028e87a3e324531dab" translate="yes" xml:space="preserve">
          <source>Note: of course as usually it is not guaranteed that the error text remains the same, however the error code will remain &lt;code&gt;-UNBLOCKED&lt;/code&gt;.</source>
          <target state="translated">注：もちろん、通常はエラーテキストが同じであるとは限りませんが、エラーコードは &lt;code&gt;-UNBLOCKED&lt;/code&gt; のままです。</target>
        </trans-unit>
        <trans-unit id="3ba013a44d25a035abd0e8ad87d8b610e34b72b2" translate="yes" xml:space="preserve">
          <source>Note: the command has a complexity of just O(log(N)) because it uses elements ranks (see &lt;a href=&quot;zrank&quot;&gt;ZRANK&lt;/a&gt;) to get an idea of the range. Because of this there is no need to do a work proportional to the size of the range.</source>
          <target state="translated">注：このコマンドは、要素のランク（&lt;a href=&quot;zrank&quot;&gt;ZRANKを&lt;/a&gt;参照）を使用して範囲の概念を取得するため、O（log（N））の複雑さしかありません。このため、範囲のサイズに比例した作業を行う必要はありません。</target>
        </trans-unit>
        <trans-unit id="a4cf334aa22d4d43d68ebc7afbb42dd9e08a0e09" translate="yes" xml:space="preserve">
          <source>Note: we use the &lt;strong&gt;COUNT&lt;/strong&gt; option in the example, so that for each stream the call will return at maximum two elements per stream.</source>
          <target state="translated">注：この例では&lt;strong&gt;COUNT&lt;/strong&gt;オプションを使用しているため、ストリームごとに、ストリームごとに最大2つの要素で呼び出しが返されます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
