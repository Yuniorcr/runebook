<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="vue">
    <body>
      <group id="vue">
        <trans-unit id="3018c9188b3b3d4a23f0075a78973fd85df51141" translate="yes" xml:space="preserve">
          <source>However, for applications that use &lt;strong&gt;only&lt;/strong&gt; global component definitions via &lt;code&gt;app.component&lt;/code&gt;, we recommend kebab-case instead. The reasons are:</source>
          <target state="translated">ただし、 &lt;code&gt;app.component&lt;/code&gt; を介してグローバルコンポーネント定義&lt;strong&gt;のみ&lt;/strong&gt;を使用するアプリケーションの場合は、代わりにkebab -caseをお勧めします。理由は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="92e85fdd91d6f41600c13668283501481ec58917" translate="yes" xml:space="preserve">
          <source>However, if you&amp;rsquo;re requiring/importing components using a &lt;strong&gt;module system&lt;/strong&gt;, e.g. via Webpack or Browserify, you&amp;rsquo;ll get an error:</source>
          <target state="translated">ただし、&lt;strong&gt;モジュールシステム&lt;/strong&gt;を使用してコンポーネントを要求/インポートする場合（WebpackやBrowserifyなど）、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="002e68a8e4165cd18ac4324c9c1241124753edbf" translate="yes" xml:space="preserve">
          <source>However, if you&amp;rsquo;ve ruled out the above and find yourself in this extremely rare situation of having to manually force an update, you can do so with &lt;a href=&quot;../api/index#vm-forceUpdate&quot;&gt;&lt;code&gt;$forceUpdate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ただし、上記を除外し、手動で更新を強制しなければならないという非常にまれな状況に陥った場合は、&lt;a href=&quot;../api/index#vm-forceUpdate&quot;&gt; &lt;code&gt;$forceUpdate&lt;/code&gt; &lt;/a&gt;使用して実行できます。</target>
        </trans-unit>
        <trans-unit id="2d036c8bdba9e735ef24169304153c34c8f3b798" translate="yes" xml:space="preserve">
          <source>However, if you've ruled out the above and find yourself in this extremely rare situation of having to manually force an update, you can do so with &lt;a href=&quot;../api/instance-methods#forceupdate&quot;&gt;&lt;code&gt;$forceUpdate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ただし、上記を除外し、手動で更新を強制する必要があるという非常にまれな状況に陥った場合は、&lt;a href=&quot;../api/instance-methods#forceupdate&quot;&gt; &lt;code&gt;$forceUpdate&lt;/code&gt; &lt;/a&gt;使用して行うことができます。</target>
        </trans-unit>
        <trans-unit id="cb3610b4f1219dad3d7eab3e3d1d0df611f8efc2" translate="yes" xml:space="preserve">
          <source>However, in Vue 3, the performance of stateful components has improved to the point that the difference is negligible. In addition, stateful components now also include the ability to return multiple root nodes.</source>
          <target state="translated">しかし、Vue 3では、ステートフル コンポーネントの性能は、その差が無視できるほど向上しています。さらに、ステートフル コンポーネントには、複数のルート ノードを返す機能も追加されました。</target>
        </trans-unit>
        <trans-unit id="317d1532f6f3ac08090592a8fdf8e37b997ac4a2" translate="yes" xml:space="preserve">
          <source>However, in some cases you may want to have both on the same element, for example having a CSS animation triggered by Vue, along with a CSS transition effect on hover. In these cases, you will have to explicitly declare the type you want Vue to care about in a &lt;code&gt;type&lt;/code&gt; attribute, with a value of either &lt;code&gt;animation&lt;/code&gt; or &lt;code&gt;transition&lt;/code&gt;.</source>
          <target state="translated">ただし、場合によっては、両方を同じ要素に配置する必要があります。たとえば、CSSアニメーションがVueによってトリガーされ、ホバー時のCSSトランジション効果が適用されます。これらの場合、 &lt;code&gt;type&lt;/code&gt; 属性で、Vueが気にするタイプを明示的に宣言する必要があります。値は、 &lt;code&gt;animation&lt;/code&gt; または &lt;code&gt;transition&lt;/code&gt; のいずれかです。</target>
        </trans-unit>
        <trans-unit id="88b48c81e2c3197a6ab15508375bec7eb9392d39" translate="yes" xml:space="preserve">
          <source>However, just as with other directives, the shorthand is only available when an argument is provided. That means the following syntax is invalid:</source>
          <target state="translated">しかし、他のディレクティブと同様に、この短縮形は引数が与えられたときにのみ利用可能です。つまり、以下の構文は無効です。</target>
        </trans-unit>
        <trans-unit id="8e607f87fc1472f8d762256cb7690621e8b2099d" translate="yes" xml:space="preserve">
          <source>However, not everyone wants to use TypeScript. In many smaller-scale use cases, introducing a type system may result in more overhead than productivity gain. In those cases you&amp;rsquo;d be better off going with Vue instead, since using Angular without TypeScript can be challenging.</source>
          <target state="translated">ただし、誰もがTypeScriptの使用を望んでいるわけではありません。多くの小規模なユースケースでは、型システムを導入すると、生産性の向上よりもオーバーヘッドが大きくなる可能性があります。 TypeScriptなしでAngularを使用するのは難しい場合があるため、それらの場合は、代わりにVueを使用するほうがよいでしょう。</target>
        </trans-unit>
        <trans-unit id="73e089bb95641b06647f01ce72a8df5b24a857f3" translate="yes" xml:space="preserve">
          <source>However, sometimes a part of a component's template belongs to this component logically, while from a technical point of view, it would be preferable to move this part of the template somewhere else in the DOM, outside of the Vue app.</source>
          <target state="translated">しかし、コンポーネントのテンプレートの一部が論理的にこのコンポーネントに属している場合もありますが、技術的な観点からは、テンプレートのこの部分を Vue アプリ以外の DOM 内の別の場所に移動させることが望ましいでしょう。</target>
        </trans-unit>
        <trans-unit id="f5a38a0e30cb26490e5f05809a78f3a4c9e4964e" translate="yes" xml:space="preserve">
          <source>However, that level of flexibility is usually not required. It's often possible to replace &lt;code&gt;resolveDynamicComponent&lt;/code&gt; with a more direct alternative.</source>
          <target state="translated">ただし、通常、そのレベルの柔軟性は必要ありません。多くの場合、 &lt;code&gt;resolveDynamicComponent&lt;/code&gt; をより直接的な代替手段に置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="ec8343c1410b44b823f35ff99f46fde41c340d0f" translate="yes" xml:space="preserve">
          <source>However, there are downsides to dependency injection. It couples components in your application to the way they&amp;rsquo;re currently organized, making refactoring more difficult. Provided properties are also not reactive. This is by design, because using them to create a central data store scales just as poorly as &lt;a href=&quot;#Accessing-the-Root-Instance&quot;&gt;using &lt;code&gt;$root&lt;/code&gt;&lt;/a&gt; for the same purpose. If the properties you want to share are specific to your app, rather than generic, or if you ever want to update provided data inside ancestors, then that&amp;rsquo;s a good sign that you probably need a real state management solution like &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt; instead.</source>
          <target state="translated">ただし、依存性注入には欠点があります。これは、アプリケーションのコンポーネントを現在整理されている方法に結合し、リファクタリングをより困難にします。提供されたプロパティも反応しません。これは設計によるものです。中央データストアを作成するために使用すると、同じ目的で&lt;a href=&quot;#Accessing-the-Root-Instance&quot;&gt; &lt;code&gt;$root&lt;/code&gt; &lt;/a&gt;を使用する場合と同じようにスケーリングが不十分になるためです。共有するプロパティがジェネリックではなくアプリに固有のものである場合、または提供されたデータを祖先内で更新したい場合は、おそらく&lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt;などの実際の状態管理ソリューションが必要であることを示しています。</target>
        </trans-unit>
        <trans-unit id="2a5d7767d7e276c46e20eda1a815bca70a1441e7" translate="yes" xml:space="preserve">
          <source>However, there are times where we need to update the data inside of the component where the data is injected. In this scenario, we recommend providing a method that is responsible for mutating the reactive property.</source>
          <target state="translated">しかし、データが注入されたコンポーネント内部のデータを更新する必要がある場合があります。このシナリオでは、反応性プロパティの変異を担当するメソッドを提供することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="1eff740b8e2a37ddfa14b1eb95316301f5907a17" translate="yes" xml:space="preserve">
          <source>However, this approach is potentially problematic for components that are reused because they'll all share the same debounced function. To keep the component instances independent from each other, we can add the debounced function in the &lt;code&gt;created&lt;/code&gt; lifecycle hook:</source>
          <target state="translated">ただし、このアプローチは、すべて同じデバウンスされた関数を共有するため、再利用されるコンポーネントにとって潜在的に問題があります。コンポーネントインスタンスを互いに独立させておくために、 &lt;code&gt;created&lt;/code&gt; ライフサイクルフックにデバウンスされた関数を追加できます。</target>
        </trans-unit>
        <trans-unit id="484afbd80ed598ca9c40608f3d779c450b8063ca" translate="yes" xml:space="preserve">
          <source>However, this can be a bit verbose if you have multiple conditional classes. That&amp;rsquo;s why it&amp;rsquo;s also possible to use the object syntax inside array syntax:</source>
          <target state="translated">ただし、複数の条件付きクラスがある場合、これは少し冗長になる可能性があります。そのため、配列構文内でオブジェクト構文を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="85cd8c9d4719bfdd0176caad9283969d3ff23830" translate="yes" xml:space="preserve">
          <source>However, this can be a bit verbose if you have multiple conditional classes. That's why it's also possible to use the object syntax inside array syntax:</source>
          <target state="translated">しかし、複数の条件付きクラスを持っている場合、これは少し冗長になります。そのため、配列構文の中でオブジェクト構文を使うことも可能です。</target>
        </trans-unit>
        <trans-unit id="226b6257bd14a41b418cc2a3219aded857a502c5" translate="yes" xml:space="preserve">
          <source>However, this won&amp;rsquo;t automatically pass any data to the component, because components have isolated scopes of their own. In order to pass the iterated data into the component, we should also use props:</source>
          <target state="translated">ただし、コンポーネントには独自のスコープが含まれているため、コンポーネントにデータが自動的に渡されることはありません。反復されたデータをコンポーネントに渡すには、propsも使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="fc101cca76508ab598f5b4b585c1e6780fad8310" translate="yes" xml:space="preserve">
          <source>However, this won't automatically pass any data to the component, because components have isolated scopes of their own. In order to pass the iterated data into the component, we should also use props:</source>
          <target state="translated">しかし、これでは自動的にコンポーネントにデータを渡すことはできません。イテレートされたデータをコンポーネントに渡すためには、プロップも使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="4f0c334fd910aa57b2a33967cd21852214b1f058" translate="yes" xml:space="preserve">
          <source>However, this won't work if we try to provide some component instance property here:</source>
          <target state="translated">しかし、ここでコンポーネントのインスタンスプロパティを提供しようとするとうまくいきません。</target>
        </trans-unit>
        <trans-unit id="004b32fe588f88c41b42b4992994b442c861a69c" translate="yes" xml:space="preserve">
          <source>However, watching a reactive object or array will always return a reference to the current value of that object for both the current and previous value of the state. To fully watch deeply nested objects and arrays, a deep copy of values may be required. This can be achieved with a utility such as &lt;a href=&quot;https://lodash.com/docs/4.17.15#cloneDeep&quot;&gt;lodash.cloneDeep (opens new window)&lt;/a&gt;</source>
          <target state="translated">ただし、リアクティブオブジェクトまたは配列を監視すると、状態の現在の値と以前の値の両方について、そのオブジェクトの現在の値への参照が常に返されます。深くネストされたオブジェクトと配列を完全に監視するには、値の深いコピーが必要になる場合があります。これは、&lt;a href=&quot;https://lodash.com/docs/4.17.15#cloneDeep&quot;&gt;lodash.cloneDeep（新しいウィンドウを開く）&lt;/a&gt;などのユーティリティを使用して実現できます。</target>
        </trans-unit>
        <trans-unit id="9beda99dc2b127dc999f5b7cc2a4cd360648f73d" translate="yes" xml:space="preserve">
          <source>However, when communicating between distant descendants/ancestors, &lt;code&gt;$emit&lt;/code&gt; won&amp;rsquo;t help you. Instead, the simplest possible upgrade would be to use a centralized event hub. This has the added benefit of allowing you to communicate between components no matter where they are in the component tree - even between siblings! Because Vue instances implement an event emitter interface, you can actually use an empty Vue instance for this purpose.</source>
          <target state="translated">ただし、離れた子孫/祖先の間で通信する場合、 &lt;code&gt;$emit&lt;/code&gt; は役に立ちません。代わりに、最も簡単なアップグレードは、集中型のイベントハブを使用することです。これには、コンポーネントツリー内のどこにあるかに関係なく、コンポーネント間で通信できるという追加の利点があります-兄弟間でも！Vueインスタンスはイベントエミッターインターフェースを実装しているため、実際にはこの目的で空のVueインスタンスを使用できます。</target>
        </trans-unit>
        <trans-unit id="a6f9aa6296c86949de208bc5300b04f5bbd8e693" translate="yes" xml:space="preserve">
          <source>However, when using the composition API to explicitly create reactive objects, the best practice is to never hold a reference to the original raw object and only work with the reactive version:</source>
          <target state="translated">ただし、コンポジション API を使用して明示的にリアクティブなオブジェクトを作成する場合は、元の raw オブジェクトへの参照を保持せず、リアクティブなバージョンのみを使用するのがベスト プラクティスです。</target>
        </trans-unit>
        <trans-unit id="1a1f757f908ed45ae57de4307c1068e94a1b0cef" translate="yes" xml:space="preserve">
          <source>However, you can still wrap default slot content in a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; if you wish to be explicit:</source>
          <target state="translated">ただし、明示的にしたい場合は、デフォルトのスロットコンテンツを &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; でラップすることもできます。</target>
        </trans-unit>
        <trans-unit id="29e3b3dcfde111c535bca8f3776cc120ca6d19c2" translate="yes" xml:space="preserve">
          <source>Hybrid-App Development</source>
          <target state="translated">ハイブリッドアプリ開発</target>
        </trans-unit>
        <trans-unit id="2a7fc3d6b914325c881febd71fbf6f3338aea8b7" translate="yes" xml:space="preserve">
          <source>I hope that right now, you&amp;rsquo;re reading this sentence in your preferred language. If not, would you like to help us get there?</source>
          <target state="translated">今あなたがこの文章をあなたの好きな言語で読んでいることを望みます。そうでない場合、私たちがそこに着くのを手伝っていただけませんか？</target>
        </trans-unit>
        <trans-unit id="b957c41023281a182ae498da3fc29d81076e5bc0" translate="yes" xml:space="preserve">
          <source>I&amp;rsquo;m glad you asked! The answer is no. About 90% of the API is the same and the core concepts haven&amp;rsquo;t changed. It&amp;rsquo;s long because we like to offer very detailed explanations and include a lot of examples. Rest assured, &lt;strong&gt;this is not something you have to read from top to bottom!&lt;/strong&gt;</source>
          <target state="translated">聞いてよかった！答えはいいえだ。APIの約90％は同じであり、コアコンセプトに変更はありません。私たちは非常に詳細な説明を提供し、多くの例を含めるのが好きなので、それは長いです。安心してください、&lt;strong&gt;これは上から下に読む必要があるものではありません！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7cc4427647cd69fcbdf57ea287139ca162e4fbe9" translate="yes" xml:space="preserve">
          <source>IDE Support</source>
          <target state="translated">IDE サポート</target>
        </trans-unit>
        <trans-unit id="615578cf02895b5ceadb54ba5821d7c10372fcdc" translate="yes" xml:space="preserve">
          <source>IDL attr &amp;amp; value</source>
          <target state="translated">IDL属性と値</target>
        </trans-unit>
        <trans-unit id="edb8f6c14252759cd8673c61a24376d32e17b93a" translate="yes" xml:space="preserve">
          <source>Icons</source>
          <target state="translated">Icons</target>
        </trans-unit>
        <trans-unit id="31aa3a07a8b9c23bb9e5b73c71b5e12fcbbbc57f" translate="yes" xml:space="preserve">
          <source>Identity hazards are in general rare. However, to properly utilize these APIs while safely avoiding identity hazards requires a solid understanding of how the reactivity system works.</source>
          <target state="translated">アイデンティティハザードは一般的にはまれである。しかし、アイデンティティハザードを安全に回避しながらこれらのAPIを適切に利用するには、反応性システムがどのように機能するかをしっかりと理解する必要があります。</target>
        </trans-unit>
        <trans-unit id="b3507f10505e91a18afb212ac7e9aa0befd70ebf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt;&amp;lsquo;s template did &lt;strong&gt;not&lt;/strong&gt; contain a &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element, any content provided between its opening and closing tag would be discarded.</source>
          <target state="translated">場合は &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt; のテンプレートはなかった&lt;strong&gt;ではない&lt;/strong&gt;含まれている &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 要素を、その開閉タグの間に設けられたすべてのコンテンツが破棄されるだろう。</target>
        </trans-unit>
        <trans-unit id="74b581a78f3cd91716bbaddac8b29eb9776b03b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;teleport&amp;gt;&lt;/code&gt; contains a Vue component, it will remain a logical child component of the &lt;code&gt;&amp;lt;teleport&amp;gt;&lt;/code&gt;'s parent:</source>
          <target state="translated">&lt;code&gt;&amp;lt;teleport&amp;gt;&lt;/code&gt; にVueコンポーネントが含まれている場合、それは &lt;code&gt;&amp;lt;teleport&amp;gt;&lt;/code&gt; の親の論理的な子コンポーネントのままになります。</target>
        </trans-unit>
        <trans-unit id="6b06f1fcb96eb40ac85f5cac5c66c2b155891fcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;todo-button&amp;gt;&lt;/code&gt;'s template did &lt;strong&gt;not&lt;/strong&gt; contain a &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element, any content provided between its opening and closing tag would be discarded.</source>
          <target state="translated">場合は &lt;code&gt;&amp;lt;todo-button&amp;gt;&lt;/code&gt; のテンプレートはなかった&lt;strong&gt;ではない&lt;/strong&gt;含まれている &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 要素を、その開閉タグの間に設けられた任意のコンテンツは破棄されます。</target>
        </trans-unit>
        <trans-unit id="201ba7f76ed37c8b5c2f564825de9c9ebb281704" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;config.isCustomElement&lt;/code&gt; is assigned to when using a runtime-only build, a warning will be emitted instructing the user to pass the option in the build setup instead;</source>
          <target state="translated">場合 &lt;code&gt;config.isCustomElement&lt;/code&gt; がに割り当てられているランタイムのみのビルドを使用した場合、警告ではなく、ビルド設定でオプションを渡すためにユーザに指示放出されます。</target>
        </trans-unit>
        <trans-unit id="4775d5880e56a64ce430a67fd93821ff5271a8f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;elementOrSelector&lt;/code&gt; argument is not provided, the template will be rendered as an off-document element, and you will have to use native DOM API to insert it into the document yourself.</source>
          <target state="translated">場合 &lt;code&gt;elementOrSelector&lt;/code&gt; の引数が提供されていない、テンプレートがオフの文書要素としてレンダリングされます、そしてあなたは、文書自身にそれを挿入するためにネイティブのDOM APIを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="0b1be49ac332b8febaafa2d94f48398afa699acf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flush&lt;/code&gt; is set to &lt;code&gt;'sync'&lt;/code&gt;, the callback will be called synchronously, as soon as the value changes.</source>
          <target state="translated">場合は &lt;code&gt;flush&lt;/code&gt; に設定されている &lt;code&gt;'sync'&lt;/code&gt; 、コールバックはすぐに値が変化すると、同期的に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="6814c905755d5d0673271362491140f9bfec32ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isButtonDisabled&lt;/code&gt; has the value of &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, or &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;disabled&lt;/code&gt; attribute will not even be included in the rendered &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">場合 &lt;code&gt;isButtonDisabled&lt;/code&gt; は値がある &lt;code&gt;null&lt;/code&gt; 、 &lt;code&gt;undefined&lt;/code&gt; 、または &lt;code&gt;false&lt;/code&gt; 、 &lt;code&gt;disabled&lt;/code&gt; 属性がさえ、レンダリングには含まれません &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; 要素。</target>
        </trans-unit>
        <trans-unit id="fe1c53b1161887bd5b64d08a53a8b025bd8d8769" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setup&lt;/code&gt; returns an object, the properties on the object can be accessed in the component's template, as well as the properties of the &lt;code&gt;props&lt;/code&gt; passed into &lt;code&gt;setup&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;setup&lt;/code&gt; がオブジェクトを返す場合、オブジェクトのプロパティは、コンポーネントのテンプレートでアクセスできます。また、 &lt;code&gt;setup&lt;/code&gt; に渡された &lt;code&gt;props&lt;/code&gt; のプロパティにもアクセスできます。</target>
        </trans-unit>
        <trans-unit id="72354f5499649f8d82fce993f6a021a2603b963e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setup&lt;/code&gt; returns an object, the properties on the object will be merged on to the render context for the component's template:</source>
          <target state="translated">&lt;code&gt;setup&lt;/code&gt; がオブジェクトを返す場合、オブジェクトのプロパティは、コンポーネントのテンプレートのレンダリングコンテキストにマージされます。</target>
        </trans-unit>
        <trans-unit id="b2eb06e2e36786f2679f43f6de53626bf2d00da9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;title&lt;/code&gt; is an optional prop, it could be missing from &lt;code&gt;props&lt;/code&gt;. In that case, &lt;code&gt;toRefs&lt;/code&gt; won't create a ref for &lt;code&gt;title&lt;/code&gt;. Instead you'd need to use &lt;code&gt;toRef&lt;/code&gt;:</source>
          <target state="translated">場合 &lt;code&gt;title&lt;/code&gt; 、オプションの小道具である、それはから欠落することができ &lt;code&gt;props&lt;/code&gt; 。その場合、 &lt;code&gt;toRefs&lt;/code&gt; は &lt;code&gt;title&lt;/code&gt; の参照を作成しません。代わりに、 &lt;code&gt;toRef&lt;/code&gt; を使用する必要があります：</target>
        </trans-unit>
        <trans-unit id="deb91108b05984da997ff690270396ce3ba6ac45" translate="yes" xml:space="preserve">
          <source>If I upgrade to Vue 2, will I also have to upgrade Vuex and Vue Router?</source>
          <target state="translated">Vue 2にアップグレードしたら、VuexとVue Routerもアップグレードしないといけないのでしょうか?</target>
        </trans-unit>
        <trans-unit id="af93e3aeb163599bea53f782e2751ff74ad451b7" translate="yes" xml:space="preserve">
          <source>If Vue didn&amp;rsquo;t have this rule, clicking on one button would affect the data of &lt;em&gt;all other instances&lt;/em&gt;, like below:</source>
          <target state="translated">Vueにこのルールがない場合、1つのボタンをクリックすると、以下のように&lt;em&gt;他&lt;/em&gt;の&lt;em&gt;すべてのインスタンスの&lt;/em&gt;データに影響します。</target>
        </trans-unit>
        <trans-unit id="b7586f731f0b07604a55b0bff8fa3025687fb239" translate="yes" xml:space="preserve">
          <source>If a Vue instance didn&amp;rsquo;t receive the &lt;code&gt;el&lt;/code&gt; option at instantiation, it will be in &amp;ldquo;unmounted&amp;rdquo; state, without an associated DOM element. &lt;code&gt;vm.$mount()&lt;/code&gt; can be used to manually start the mounting of an unmounted Vue instance.</source>
          <target state="translated">Vueインスタンスがインスタンス化時に &lt;code&gt;el&lt;/code&gt; オプションを受信しなかった場合、関連付けられたDOM要素なしで「アンマウント」状態になります。 &lt;code&gt;vm.$mount()&lt;/code&gt; を使用して、マウント解除されたVueインスタンスのマウントを手動で開始できます。</target>
        </trans-unit>
        <trans-unit id="6d5c5a2c7610113711661bfb46b69f9a5e5ddb79" translate="yes" xml:space="preserve">
          <source>If a component only makes sense in the context of a single parent component, that relationship should be evident in its name. Since editors typically organize files alphabetically, this also keeps these related files next to each other.</source>
          <target state="translated">あるコンポーネントが単一の親コンポーネントのコンテキストでのみ意味を持つ場合、その関係はその名前で明らかになるべきです。エディタは通常、ファイルをアルファベット順に整理するので、関連するファイルを隣り合わせにしておきます。</target>
        </trans-unit>
        <trans-unit id="d6080ced28d2ad5267aab8c60cb9e3ee41fcc9d3" translate="yes" xml:space="preserve">
          <source>If a component receives slots from its parent, they can be passed on directly to a child component:</source>
          <target state="translated">コンポーネントが親からスロットを受け取ると、そのスロットを直接子コンポーネントに渡すことができます。</target>
        </trans-unit>
        <trans-unit id="fed6b31ac8ff605e55f7cdbf21aabd756efc8bb1" translate="yes" xml:space="preserve">
          <source>If a new ref is assigned to a property linked to an existing ref, it will replace the old ref:</source>
          <target state="translated">既存のRefにリンクされたプロパティに新しいRefが割り当てられた場合は、古いRefに置き換わります。</target>
        </trans-unit>
        <trans-unit id="b5928a9e5cf47cbe7b8911ef9b07fba741c7d9aa" translate="yes" xml:space="preserve">
          <source>If a runtime error occurs during a component&amp;rsquo;s render, it will be passed to the global &lt;code&gt;Vue.config.errorHandler&lt;/code&gt; config function if it has been set. It might be a good idea to leverage this hook together with an error-tracking service like &lt;a href=&quot;https://sentry.io&quot;&gt;Sentry&lt;/a&gt;, which provides &lt;a href=&quot;https://sentry.io/for/vue/&quot;&gt;an official integration&lt;/a&gt; for Vue.</source>
          <target state="translated">コンポーネントのレンダリング中に実行時エラーが発生した場合、それが設定されていれば、グローバル &lt;code&gt;Vue.config.errorHandler&lt;/code&gt; 構成関数に渡されます。このフックを、Vueの&lt;a href=&quot;https://sentry.io/for/vue/&quot;&gt;公式統合&lt;/a&gt;を提供する&lt;a href=&quot;https://sentry.io&quot;&gt;Sentry&lt;/a&gt;などのエラー追跡サービスと一緒に活用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="642e3ac102c57674c11d312a80ed33358ce20b95" translate="yes" xml:space="preserve">
          <source>If a runtime error occurs during a component's render, it will be passed to the global &lt;code&gt;app.config.errorHandler&lt;/code&gt; config function if it has been set. It might be a good idea to leverage this hook together with an error-tracking service like &lt;a href=&quot;https://sentry.io&quot;&gt;Sentry (opens new window)&lt;/a&gt;, which provides &lt;a href=&quot;https://sentry.io/for/vue/&quot;&gt;an official integration (opens new window)&lt;/a&gt; for Vue.</source>
          <target state="translated">コンポーネントのレンダリング中にランタイムエラーが発生した場合、それが設定されていれば、グローバル &lt;code&gt;app.config.errorHandler&lt;/code&gt; 構成関数に渡されます。このフックを、Vueの&lt;a href=&quot;https://sentry.io/for/vue/&quot;&gt;公式統合（新しいウィンドウを開く&lt;/a&gt;&lt;a href=&quot;https://sentry.io&quot;&gt;）&lt;/a&gt;を提供するSentry（新しいウィンドウを開く）などのエラー追跡サービスと一緒に活用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="8ec559a16f0238f7c29fe23c19c2dec1b891987a" translate="yes" xml:space="preserve">
          <source>If an object is assigned as a ref's value, the object is made deeply reactive by the &lt;a href=&quot;basic-reactivity#reactive&quot;&gt;reactive&lt;/a&gt; method.</source>
          <target state="translated">オブジェクトがrefの値として割り当てられている場合、オブジェクトは&lt;a href=&quot;basic-reactivity#reactive&quot;&gt;リアクティブ&lt;/a&gt;メソッドによって深くリアクティブになります。</target>
        </trans-unit>
        <trans-unit id="08aa6aa203690ff56afb57ae212ba05b4f6c10ba" translate="yes" xml:space="preserve">
          <source>If both event and callback are given, remove the listener for that specific callback only.</source>
          <target state="translated">イベントとコールバックの両方が与えられた場合、その特定のコールバックのみのリスナーを削除します。</target>
        </trans-unit>
        <trans-unit id="94a6cbe6ca363d5ecbd722fc5378a6b8f28c5053" translate="yes" xml:space="preserve">
          <source>If instead, your intent is to conditionally skip execution of the loop, you can place the &lt;code&gt;v-if&lt;/code&gt; on a wrapper element (or &lt;a href=&quot;conditional#Conditional-Groups-with-v-if-on-lt-template-gt&quot;&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;&lt;/a&gt;). For example:</source>
          <target state="translated">代わりに、ループの実行を条件付きでスキップすることが目的である &lt;code&gt;v-if&lt;/code&gt; は、ラッパー要素（または&lt;a href=&quot;conditional#Conditional-Groups-with-v-if-on-lt-template-gt&quot;&gt; &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; &lt;/a&gt;）にv-ifを配置できます。例えば：</target>
        </trans-unit>
        <trans-unit id="50d9bd5e8b2424d69b89a9acc464902a1ecc6350" translate="yes" xml:space="preserve">
          <source>If it needs to be injected from a property with a different name, use &lt;code&gt;from&lt;/code&gt; to denote the source property:</source>
          <target state="translated">別の名前のプロパティから挿入する必要がある場合は、fromプロパティを使用 &lt;code&gt;from&lt;/code&gt; てソースプロパティを示します。</target>
        </trans-unit>
        <trans-unit id="f0caf8a9ac2bcc9fe7de24b53400b7eedb0a1ea6" translate="yes" xml:space="preserve">
          <source>If multiple &lt;code&gt;errorCaptured&lt;/code&gt; hooks exist on a component&amp;rsquo;s inheritance chain or parent chain, all of them will be invoked on the same error.</source>
          <target state="translated">コンポーネントの継承チェーンまたは親チェーンに複数の &lt;code&gt;errorCaptured&lt;/code&gt; フックが存在する場合、それらはすべて同じエラーで呼び出されます。</target>
        </trans-unit>
        <trans-unit id="9f4ae8d54b54e963413f7f1cfbf43652de62cd55" translate="yes" xml:space="preserve">
          <source>If multiple &lt;code&gt;errorCaptured&lt;/code&gt; hooks exist on a component's inheritance chain or parent chain, all of them will be invoked on the same error.</source>
          <target state="translated">コンポーネントの継承チェーンまたは親チェーンに複数の &lt;code&gt;errorCaptured&lt;/code&gt; フックが存在する場合、それらはすべて同じエラーで呼び出されます。</target>
        </trans-unit>
        <trans-unit id="8faa43e0b6fd3244a15d3b9a3afc829c3468152d" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;render&lt;/code&gt; function nor &lt;code&gt;template&lt;/code&gt; option is present, the in-DOM HTML of the mounting DOM element will be extracted as the template. In this case, Runtime + Compiler build of Vue should be used.</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; 機能も &lt;code&gt;template&lt;/code&gt; オプションも存在しない場合、マウントするDOM要素のDOM内HTMLがテンプレートとして抽出されます。この場合、VueのRuntime + Compilerビルドを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="9b01e73de7162db0cb72a3eeafeeb2620b8021a4" translate="yes" xml:space="preserve">
          <source>If no CSS transitions/animations are detected and no JavaScript hooks are provided, the DOM operations for insertion and/or removal will be executed immediately on next frame (Note: this is a browser animation frame, different from Vue&amp;rsquo;s concept of &lt;code&gt;nextTick&lt;/code&gt;).</source>
          <target state="translated">CSSトランジション/アニメーションが検出されず、JavaScriptフックが提供されない場合、挿入および/または削除のDOM操作は次のフレームですぐに実行されます（注：これは、Vueの &lt;code&gt;nextTick&lt;/code&gt; の概念とは異なるブラウザーアニメーションフレームです）。</target>
        </trans-unit>
        <trans-unit id="b064733da54289be43813af974ffc4066d5f06c7" translate="yes" xml:space="preserve">
          <source>If no CSS transitions/animations are detected and no JavaScript hooks are provided, the DOM operations for insertion and/or removal will be executed immediately on next frame (Note: this is a browser animation frame, different from Vue's concept of &lt;code&gt;nextTick&lt;/code&gt;).</source>
          <target state="translated">CSS遷移/アニメーションが検出されず、JavaScriptフックが提供されていない場合、挿入または削除、あるいはその両方のDOM操作は次のフレームですぐに実行されます（注：これはブラウザーアニメーションフレームであり、Vueの &lt;code&gt;nextTick&lt;/code&gt; の概念とは異なります）。</target>
        </trans-unit>
        <trans-unit id="5bc33fe28ba69d339fb37eab66ba597ee9dc10b1" translate="yes" xml:space="preserve">
          <source>If no arguments are provided, remove all event listeners;</source>
          <target state="translated">引数を指定しない場合は、すべてのイベントリスナーを削除します。</target>
        </trans-unit>
        <trans-unit id="91aba20875e905d73638256716c23f9b7b43a58d" translate="yes" xml:space="preserve">
          <source>If only the event is provided, remove all listeners for that event;</source>
          <target state="translated">イベントのみが提供されている場合は、そのイベントのすべてのリスナーを削除します。</target>
        </trans-unit>
        <trans-unit id="575587717723913920c46177080895c689efec3d" translate="yes" xml:space="preserve">
          <source>If render function is present in the Vue option, the template will be ignored.</source>
          <target state="translated">Vueオプションにレンダリング機能がある場合、テンプレートは無視されます。</target>
        </trans-unit>
        <trans-unit id="85fd7702f7debf176df5e9e28d28b4d2f2479f88" translate="yes" xml:space="preserve">
          <source>If required, a deep clone of the original object can be obtained by passing &lt;code&gt;vm.$data&lt;/code&gt; through &lt;code&gt;JSON.parse(JSON.stringify(...))&lt;/code&gt;.</source>
          <target state="translated">必要に応じて、 &lt;code&gt;JSON.parse(JSON.stringify(...))&lt;/code&gt; を介して &lt;code&gt;vm.$data&lt;/code&gt; を渡すことにより、元のオブジェクトのディープクローンを取得できます。</target>
        </trans-unit>
        <trans-unit id="21380cb2235ba519b963494fea54adad9607a338" translate="yes" xml:space="preserve">
          <source>If so, please feel free to fork the repo for &lt;a href=&quot;https://github.com/vuejs/vuejs.org/&quot;&gt;these docs&lt;/a&gt; or for any other officially maintained documentation, then start translating. Once you&amp;rsquo;ve made some progress, open an issue or pull request in the main repo and we&amp;rsquo;ll put out a call for more contributors to help you out.</source>
          <target state="translated">その場合は、&lt;a href=&quot;https://github.com/vuejs/vuejs.org/&quot;&gt;これらのドキュメント&lt;/a&gt;またはその他の公式に維持されているドキュメントのリポジトリをフォークして、翻訳を開始してください。ある程度の進展があったら、メインリポジトリで課題またはプルリクエストを開いてください。そうすれば、より多くの寄稿者に支援を求めるための呼び出しを出します。</target>
        </trans-unit>
        <trans-unit id="b3b0a88772445b0201a5544af343a6bd0d139fcc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;errorCaptured&lt;/code&gt; hook itself throws an error, both this error and the original captured error are sent to the global &lt;code&gt;config.errorHandler&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;errorCaptured&lt;/code&gt; フック自体がエラーをスローした場合、このエラーと元のキャプチャされたエラーの両方がグローバル &lt;code&gt;config.errorHandler&lt;/code&gt; に送信されます。</target>
        </trans-unit>
        <trans-unit id="009579549300fafa52dbcc22a4317c4e5cd4cffe" translate="yes" xml:space="preserve">
          <source>If the VNode is always an HTML element then we can pass its name directly to &lt;code&gt;h&lt;/code&gt;:</source>
          <target state="translated">VNodeが常にHTML要素である場合、その名前を &lt;code&gt;h&lt;/code&gt; に直接渡すことができます。</target>
        </trans-unit>
        <trans-unit id="20828a01491d3d176994e014e8243f15e5cec364" translate="yes" xml:space="preserve">
          <source>If the bound value is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; then the attribute will not be included on the rendered element.</source>
          <target state="translated">バインドされた値が &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; 場合、属性はレンダリングされた要素に含まれません。</target>
        </trans-unit>
        <trans-unit id="7303cbac97656642d551545dc4e5cababd70308f" translate="yes" xml:space="preserve">
          <source>If the component is a functional component, the render function also receives an extra argument &lt;code&gt;context&lt;/code&gt;, which provides access to contextual data since functional components are instance-less.</source>
          <target state="translated">コンポーネントが機能コンポーネントの場合、レンダリングコンポーネントは追加の引数 &lt;code&gt;context&lt;/code&gt; も受け取ります。これにより、機能コンポーネントはインスタンスを持たないため、コンテキストデータにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="778a0693bfbcff846a92b8e406613e51b0ccd2e7" translate="yes" xml:space="preserve">
          <source>If the initial value of your &lt;code&gt;v-model&lt;/code&gt; expression does not match any of the options, the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; element will render in an &quot;unselected&quot; state. On iOS this will cause the user not being able to select the first item because iOS does not fire a change event in this case. It is therefore recommended to provide a disabled option with an empty value, as demonstrated in the example above.</source>
          <target state="translated">&lt;code&gt;v-model&lt;/code&gt; 式の初期値がどのオプションとも一致しない場合、 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 要素は「選択されていない」状態でレンダリングされます。この場合、iOSは変更イベントを発生させないため、iOSでは、ユーザーは最初のアイテムを選択できなくなります。したがって、上記の例に示すように、無効なオプションに空の値を指定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="71e1040d1b4539c4a4df0fdf98d510e6cb4c6439" translate="yes" xml:space="preserve">
          <source>If the initial value of your &lt;code&gt;v-model&lt;/code&gt; expression does not match any of the options, the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; element will render in an &amp;ldquo;unselected&amp;rdquo; state. On iOS this will cause the user not being able to select the first item because iOS does not fire a change event in this case. It is therefore recommended to provide a disabled option with an empty value, as demonstrated in the example above.</source>
          <target state="translated">&lt;code&gt;v-model&lt;/code&gt; 式の初期値がどのオプションとも一致しない場合、 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 要素は「選択されていない」状態でレンダリングされます。iOSでは、この場合iOSは変更イベントを発生させないため、ユーザーは最初のアイテムを選択できなくなります。したがって、上記の例で示したように、無効なオプションには空の値を指定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="e40b666fff5068ba41fcb1fb1d0acd4ce7a992d8" translate="yes" xml:space="preserve">
          <source>If the methods &lt;code&gt;toTitleDate&lt;/code&gt; or &lt;code&gt;formatDate&lt;/code&gt; access any reactive data then it will be tracked as a rendering dependency, just as if it had been used in the template directly.</source>
          <target state="translated">メソッド &lt;code&gt;toTitleDate&lt;/code&gt; または &lt;code&gt;formatDate&lt;/code&gt; がリアクティブデータにアクセスする場合、テンプレートで直接使用されているかのように、レンダリングの依存関係として追跡されます。</target>
        </trans-unit>
        <trans-unit id="5c148d9a336221fd54485bc5ad61e9a1e229c73a" translate="yes" xml:space="preserve">
          <source>If the string starts with &lt;code&gt;#&lt;/code&gt; it will be used as a &lt;code&gt;querySelector&lt;/code&gt; and use the selected element's innerHTML as the template string. This allows the use of the common &lt;code&gt;&amp;lt;script type=&quot;x-template&quot;&amp;gt;&lt;/code&gt; trick to include templates.</source>
          <target state="translated">文字列が &lt;code&gt;#&lt;/code&gt; で始まる場合、それは &lt;code&gt;querySelector&lt;/code&gt; として使用され、選択された要素のinnerHTMLをテンプレート文字列として使用します。これにより、一般的な &lt;code&gt;&amp;lt;script type=&quot;x-template&quot;&amp;gt;&lt;/code&gt; トリックを使用してテンプレートを含めることができます。</target>
        </trans-unit>
        <trans-unit id="3be14640de0939678c1a24bad38088404e2ca8c9" translate="yes" xml:space="preserve">
          <source>If the string starts with &lt;code&gt;#&lt;/code&gt; it will be used as a querySelector and use the selected element&amp;rsquo;s innerHTML as the template string. This allows the use of the common &lt;code&gt;&amp;lt;script type=&quot;x-template&quot;&amp;gt;&lt;/code&gt; trick to include templates.</source>
          <target state="translated">文字列が &lt;code&gt;#&lt;/code&gt; で始まる場合、それはquerySelectorとして使用され、選択された要素のinnerHTMLをテンプレート文字列として使用します。これにより、一般的な &lt;code&gt;&amp;lt;script type=&quot;x-template&quot;&amp;gt;&lt;/code&gt; トリックを使用してテンプレートを含めることができます。</target>
        </trans-unit>
        <trans-unit id="95e2a9dfaa380a0de81081767f202693968ef8fc" translate="yes" xml:space="preserve">
          <source>If the transition component provided &lt;a href=&quot;#JavaScript-Hooks&quot;&gt;JavaScript hooks&lt;/a&gt;, these hooks will be called at appropriate timings.</source>
          <target state="translated">遷移コンポーネントが&lt;a href=&quot;#JavaScript-Hooks&quot;&gt;JavaScriptフックを&lt;/a&gt;提供した場合、これらのフックは適切なタイミングで呼び出されます。</target>
        </trans-unit>
        <trans-unit id="2ecd8a7c716c95da925d56a24dbff68dbe3cb732" translate="yes" xml:space="preserve">
          <source>If the transition component provided &lt;a href=&quot;#javascript-hooks&quot;&gt;JavaScript hooks&lt;/a&gt;, these hooks will be called at appropriate timings.</source>
          <target state="translated">遷移コンポーネントが&lt;a href=&quot;#javascript-hooks&quot;&gt;JavaScriptフックを&lt;/a&gt;提供した場合、これらのフックは適切なタイミングで呼び出されます。</target>
        </trans-unit>
        <trans-unit id="2db2c73fe7d859c72406458c11b699f22e3d0c62" translate="yes" xml:space="preserve">
          <source>If the type of the generic is unknown, it's recommended to cast &lt;code&gt;ref&lt;/code&gt; to &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">ジェネリックのタイプが不明な場合は、 &lt;code&gt;ref&lt;/code&gt; を &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; にキャストすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="0743f97ca671f5c9ea8b899455cd80afbfe69b8a" translate="yes" xml:space="preserve">
          <source>If the type of the generic is unknown, it's recommended to cast &lt;code&gt;ref&lt;/code&gt; to &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">ジェネリックのタイプが不明な場合は、 &lt;code&gt;ref&lt;/code&gt; を &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; にキャストすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="4b3b75b60aea9cf846f97bdc9f59bd5b35161f3f" translate="yes" xml:space="preserve">
          <source>If there are no props then the children can usually be passed as the second argument. In cases where that would be ambiguous, &lt;code&gt;null&lt;/code&gt; can be passed as the second argument to keep the children as the third argument.</source>
          <target state="translated">小道具がない場合は、通常、子を2番目の引数として渡すことができます。それがあいまいな場合は、2番目の引数として &lt;code&gt;null&lt;/code&gt; を渡して、子を3番目の引数として保持できます。</target>
        </trans-unit>
        <trans-unit id="0bebbf9e60227c2180beccfec6669351ce887915" translate="yes" xml:space="preserve">
          <source>If there&amp;rsquo;s a 3rd-party router you prefer to use, such as &lt;a href=&quot;https://github.com/visionmedia/page.js&quot;&gt;Page.js&lt;/a&gt; or &lt;a href=&quot;https://github.com/flatiron/director&quot;&gt;Director&lt;/a&gt;, integration is &lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/compare/master...pagejs&quot;&gt;similarly easy&lt;/a&gt;. Here&amp;rsquo;s a &lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/tree/pagejs&quot;&gt;complete example&lt;/a&gt; using Page.js.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/visionmedia/page.js&quot;&gt;Page.js&lt;/a&gt;や&lt;a href=&quot;https://github.com/flatiron/director&quot;&gt;Director&lt;/a&gt;など、使用するサードパーティのルーターがある場合、統合も&lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/compare/master...pagejs&quot;&gt;同様に簡単&lt;/a&gt;です。Page.jsを使用した&lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/tree/pagejs&quot;&gt;完全な例&lt;/a&gt;を次に示します。</target>
        </trans-unit>
        <trans-unit id="4a4deb4463100ef774d066f03629b21cdc02fb26" translate="yes" xml:space="preserve">
          <source>If there's a 3rd-party router you prefer to use, such as &lt;a href=&quot;https://github.com/visionmedia/page.js&quot;&gt;Page.js (opens new window)&lt;/a&gt; or &lt;a href=&quot;https://github.com/flatiron/director&quot;&gt;Director (opens new window)&lt;/a&gt;, integration is &lt;a href=&quot;https://github.com/phanan/vue-3.0-simple-routing-example/compare/master...pagejs&quot;&gt;similarly straightforward (opens new window)&lt;/a&gt;. Here's a &lt;a href=&quot;https://github.com/phanan/vue-3.0-simple-routing-example/tree/pagejs&quot;&gt;complete example (opens new window)&lt;/a&gt; using Page.js.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/visionmedia/page.js&quot;&gt;Page.js（新しいウィンドウを開く）&lt;/a&gt;や&lt;a href=&quot;https://github.com/flatiron/director&quot;&gt;Director（新しいウィンドウを開く&lt;/a&gt;）など、使用したいサードパーティのルーターがある場合、統合も&lt;a href=&quot;https://github.com/phanan/vue-3.0-simple-routing-example/compare/master...pagejs&quot;&gt;同様に簡単です（新しいウィンドウを開きます）&lt;/a&gt;。これは、Page.jsを使用した&lt;a href=&quot;https://github.com/phanan/vue-3.0-simple-routing-example/tree/pagejs&quot;&gt;完全な例（新しいウィンドウを開く）&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="a7c1c9810ed91033d943c8c7395ef1ff554427a5" translate="yes" xml:space="preserve">
          <source>If this component received an &lt;code&gt;id&lt;/code&gt; attribute and a &lt;code&gt;v-on:close&lt;/code&gt; listener, the &lt;code&gt;$attrs&lt;/code&gt; object will now look like this:</source>
          <target state="translated">このコンポーネントが &lt;code&gt;id&lt;/code&gt; 属性と &lt;code&gt;v-on:close&lt;/code&gt; リスナーを受け取った場合、 &lt;code&gt;$attrs&lt;/code&gt; オブジェクトは次のようになります。</target>
        </trans-unit>
        <trans-unit id="403bdf723c083d8b2ccede629d30e16d178e61fd" translate="yes" xml:space="preserve">
          <source>If this option is available at instantiation, the instance will immediately enter compilation; otherwise, the user will have to explicitly call &lt;code&gt;vm.$mount()&lt;/code&gt; to manually start the compilation.</source>
          <target state="translated">このオプションをインスタンス化時に使用できる場合、インスタンスはすぐにコンパイルに入ります。それ以外の場合、ユーザーは明示的に &lt;code&gt;vm.$mount()&lt;/code&gt; を呼び出して手動でコンパイルを開始する必要があります。</target>
        </trans-unit>
        <trans-unit id="31295f224ed5601010e4bf662145dc4776218b9c" translate="yes" xml:space="preserve">
          <source>If using a build step: pass the &lt;code&gt;isCustomElement&lt;/code&gt; option to the Vue template compiler. If using &lt;code&gt;vue-loader&lt;/code&gt;, this should be passed via &lt;code&gt;vue-loader&lt;/code&gt;'s &lt;code&gt;compilerOptions&lt;/code&gt; option:</source>
          <target state="translated">ビルドステップを使用する場合： &lt;code&gt;isCustomElement&lt;/code&gt; オプションをVueテンプレートコンパイラに渡します。 &lt;code&gt;vue-loader&lt;/code&gt; を使用する場合、これは &lt;code&gt;vue-loader&lt;/code&gt; の &lt;code&gt;compilerOptions&lt;/code&gt; オプションを介して渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="e2a7080e683c7a64c86aa780d504104684e2c8cf" translate="yes" xml:space="preserve">
          <source>If using on-the-fly template compilation, pass it via &lt;code&gt;app.config.isCustomElement&lt;/code&gt;:</source>
          <target state="translated">オンザフライのテンプレートコンパイルを使用する場合は、 &lt;code&gt;app.config.isCustomElement&lt;/code&gt; を介して渡します。</target>
        </trans-unit>
        <trans-unit id="330f73efd7b8fa6913e10b944928e9083afdfa3e" translate="yes" xml:space="preserve">
          <source>If using string keys or non-typed symbols, the type of the injected value will need to be explicitly declared:</source>
          <target state="translated">文字列キーや型なしシンボルを使用する場合は、注入される値の型を明示的に宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="34cd39cc6503370abf981fdea53d1f2a726cdba6" translate="yes" xml:space="preserve">
          <source>If we need to resolve a component by name then we can call &lt;code&gt;resolveComponent&lt;/code&gt;:</source>
          <target state="translated">私たちは名前でコンポーネントを解決する必要があるならば、我々は呼び出すことができ &lt;code&gt;resolveComponent&lt;/code&gt; を：</target>
        </trans-unit>
        <trans-unit id="6c8df13c30163597104a70bd9ea70be42706e226" translate="yes" xml:space="preserve">
          <source>If we need to update the list items, we do so in JavaScript, using the reactivity we mentioned earlier. We then make all the changes to the JavaScript copy, the virtual DOM, and perform a diff between this and the actual DOM. Only then do we make our updates to just what has changed. The Virtual DOM allows us to make performant updates to our UIs!</source>
          <target state="translated">リストの項目を更新する必要がある場合は、先ほど説明したリアクティブを使用して JavaScript で更新します。次に、JavaScript のコピーである仮想 DOM にすべての変更を加え、実際の DOM との差分を実行します。そして、変更された部分だけを更新します。仮想 DOM を使うことで、UI をパフォーマンスの高い形で更新することができます。</target>
        </trans-unit>
        <trans-unit id="46541c29071775d267576f2d4f8b07035cf486fe" translate="yes" xml:space="preserve">
          <source>If we update the first value, the sum is not adjusted.</source>
          <target state="translated">最初の値を更新した場合、合計は調整されません。</target>
        </trans-unit>
        <trans-unit id="aaf205117227a86a1eb58ae18d3718adb780a6c9" translate="yes" xml:space="preserve">
          <source>If we want to add a custom element defined outside of Vue (e.g. using the Web Components API), we need to 'instruct' Vue to treat it as a custom element. Let's use the following template as an example.</source>
          <target state="translated">Vue の外部で定義されたカスタム要素を追加したい場合(Web Components API を使用するなど)、Vue にカスタム要素として扱うように「指示」する必要があります。以下のテンプレートを例にしてみましょう。</target>
        </trans-unit>
        <trans-unit id="62fcea7a8afcf7157ecc5757dd89328f51812842" translate="yes" xml:space="preserve">
          <source>If we want to pass the length of todo-items directly to &lt;code&gt;TodoListStatistics&lt;/code&gt;, we would pass the prop down the hierarchy: &lt;code&gt;TodoList&lt;/code&gt; -&amp;gt; &lt;code&gt;TodoListFooter&lt;/code&gt; -&amp;gt; &lt;code&gt;TodoListStatistics&lt;/code&gt;. With provide/inject approach, we can do this directly:</source>
          <target state="translated">&lt;code&gt;TodoListStatistics&lt;/code&gt; アイテムの長さをTodoListStatisticsに直接渡したい場合は、階層の &lt;code&gt;TodoList&lt;/code&gt; 小道具を渡します：TodoList- &amp;gt; &lt;code&gt;TodoListFooter&lt;/code&gt; - &amp;gt; &lt;code&gt;TodoListStatistics&lt;/code&gt; 。提供/注入アプローチを使用すると、これを直接行うことができます。</target>
        </trans-unit>
        <trans-unit id="c3bb928534fcb45cb1f88d282a370e12143b6fe8" translate="yes" xml:space="preserve">
          <source>If we wanted to change prop or event names to something different, we would need to add a &lt;code&gt;model&lt;/code&gt; option to &lt;code&gt;ChildComponent&lt;/code&gt; component:</source>
          <target state="translated">小道具やイベントの名前を別の名前に変更したい場合は、 &lt;code&gt;ChildComponent&lt;/code&gt; コンポーネントに &lt;code&gt;model&lt;/code&gt; オプションを追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="a150e823a3a8131b7c978145134a1ff444cb639e" translate="yes" xml:space="preserve">
          <source>If we were to apply these states to a transition, it would look something like this:</source>
          <target state="translated">これらの状態を移行に当てはめると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="498688a211069d7a5c4191f5c3fef214e9f67f92" translate="yes" xml:space="preserve">
          <source>If we're writing a lot of &lt;code&gt;render&lt;/code&gt; functions, it might feel painful to write something like this:</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; 関数をたくさん書いている場合、次のようなものを書くのは苦痛に感じるかもしれません。</target>
        </trans-unit>
        <trans-unit id="ac2fb212b41d06f075a5186ea4df933d818c54bc" translate="yes" xml:space="preserve">
          <source>If you already have the &lt;code&gt;tag&lt;/code&gt; prop defined in your Vue 2 code, like in the example above, everything will work as before</source>
          <target state="translated">上記の例のように、Vue 2コードで &lt;code&gt;tag&lt;/code&gt; propがすでに定義されている場合は、すべてが以前と同じように機能します。</target>
        </trans-unit>
        <trans-unit id="916a06724e966c52ae5b3afbcb15fb0a47533851" translate="yes" xml:space="preserve">
          <source>If you also want to apply a transition on the initial render of a node, you can add the &lt;code&gt;appear&lt;/code&gt; attribute:</source>
          <target state="translated">ノードの初期レンダーにもトランジションを適用したい場合は、 &lt;code&gt;appear&lt;/code&gt; 属性を追加できます。</target>
        </trans-unit>
        <trans-unit id="7ec74309d0b36ccc7bac1396b5fe53120fd641ab" translate="yes" xml:space="preserve">
          <source>If you are a fan of CSS-in-JS, many of the popular CSS-in-JS libraries support Vue (e.g. &lt;a href=&quot;https://github.com/styled-components/vue-styled-components&quot;&gt;styled-components-vue&lt;/a&gt; and &lt;a href=&quot;https://github.com/egoist/vue-emotion&quot;&gt;vue-emotion&lt;/a&gt;). The main difference between React and Vue here is that the default method of styling in Vue is through more familiar &lt;code&gt;style&lt;/code&gt; tags in &lt;a href=&quot;single-file-components&quot;&gt;single-file components&lt;/a&gt;.</source>
          <target state="translated">CSS-in-JSのファンであれば、人気のあるCSS-in-JSライブラリの多くがVueをサポートして&lt;a href=&quot;https://github.com/styled-components/vue-styled-components&quot;&gt;います&lt;/a&gt;（たとえば、styled-components-vueや&lt;a href=&quot;https://github.com/egoist/vue-emotion&quot;&gt;vue-emotion&lt;/a&gt;）。ここでのReactとVueの主な違いは、Vueでのデフォルトのスタイル設定方法が、&lt;a href=&quot;single-file-components&quot;&gt;単一ファイルコンポーネントの&lt;/a&gt;より馴染みのある &lt;code&gt;style&lt;/code&gt; タグを使用することです。</target>
        </trans-unit>
        <trans-unit id="8905225615c521ffb76784bc94d7b858597c4fa8" translate="yes" xml:space="preserve">
          <source>If you are an experienced frontend developer and want to know how Vue compares to other libraries/frameworks, check out the &lt;a href=&quot;guide/comparison&quot;&gt;Comparison with Other Frameworks&lt;/a&gt;.</source>
          <target state="translated">経験豊富なフロントエンド開発者であり、Vueが他のライブラリ/フレームワークと比較する方法を知りたい場合は、&lt;a href=&quot;guide/comparison&quot;&gt;他のフレームワークと&lt;/a&gt;の比較を確認してください。</target>
        </trans-unit>
        <trans-unit id="fbcbc82a190068637d910f1c319db9b6e1926788" translate="yes" xml:space="preserve">
          <source>If you are developing a large project, working with other developers, or sometimes include 3rd-party HTML/CSS (e.g. from Auth0), consistent scoping will ensure that your styles only apply to the components they are meant for.</source>
          <target state="translated">大規模なプロジェクトを開発していたり、他の開発者と一緒に作業をしていたり、時にはサードパーティの HTML/CSS (Auth0 など)が含まれていたりする場合、一貫したスコーピングを行うことで、あなたのスタイルがそれらのコンポーネントにのみ適用されることを保証します。</target>
        </trans-unit>
        <trans-unit id="d40ab587db89fe2bdc56b68cb15d14ec1f64b7eb" translate="yes" xml:space="preserve">
          <source>If you are familiar with Virtual DOM concepts and prefer the raw power of JavaScript, you can also &lt;a href=&quot;render-function&quot;&gt;directly write render functions&lt;/a&gt; instead of templates, with optional JSX support.</source>
          <target state="translated">仮想DOMの概念に精通していて、JavaScriptの生の力を好む場合は、オプションのJSXサポートを使用して、テンプレートの代わりに&lt;a href=&quot;render-function&quot;&gt;レンダリング関数を直接作成する&lt;/a&gt;こともできます。</target>
        </trans-unit>
        <trans-unit id="4e11ad49faa82bff233bacdfdaea43495b37d7cb" translate="yes" xml:space="preserve">
          <source>If you are relying on this override functionality for &lt;code&gt;v-bind&lt;/code&gt;, we currently recommend ensuring that your &lt;code&gt;v-bind&lt;/code&gt; attribute is defined before individual properties.</source>
          <target state="translated">&lt;code&gt;v-bind&lt;/code&gt; のこのオーバーライド機能に依存している場合は、現在、 &lt;code&gt;v-bind&lt;/code&gt; 属性が個々のプロパティの前に定義されていることを確認することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="97f259b9cb4dd6eabd10bd96771a986250a3f5c4" translate="yes" xml:space="preserve">
          <source>If you are using Vue 2.x and below, you may be interested in some of the change detection caveats that exist for those versions, &lt;a href=&quot;change-detection&quot;&gt;explored in more detail here&lt;/a&gt;.</source>
          <target state="translated">Vue 2.x以下を使用している場合は、これらのバージョンに存在する変更検出の警告のいくつかに興味があるかもしれません。&lt;a href=&quot;change-detection&quot;&gt;詳細については、こちらをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="53fa108116f2ee5b4db44f6418ab708557dafa0b" translate="yes" xml:space="preserve">
          <source>If you are using Webpack, and prefer separating JavaScript and template files, you can use &lt;a href=&quot;https://github.com/ktsn/vue-template-loader&quot;&gt;vue-template-loader (opens new window)&lt;/a&gt;, which also transforms the template files into JavaScript render functions during the build step.</source>
          <target state="translated">Webpackを使用していて、JavaScriptファイルとテンプレートファイルを分離したい場合は、&lt;a href=&quot;https://github.com/ktsn/vue-template-loader&quot;&gt;vue-template-loader（新しいウィンドウを開きます）&lt;/a&gt;を使用できます。これにより、ビルドステップ中にテンプレートファイルがJavaScriptレンダリング関数に変換されます。</target>
        </trans-unit>
        <trans-unit id="96c8aaaa2941143cf085fd81f80dc6fc001828e4" translate="yes" xml:space="preserve">
          <source>If you are using Webpack, and prefer separating JavaScript and template files, you can use &lt;a href=&quot;https://github.com/ktsn/vue-template-loader&quot;&gt;vue-template-loader&lt;/a&gt;, which also transforms the template files into JavaScript render functions during the build step.</source>
          <target state="translated">Webpackを使用していて、JavaScriptファイルとテンプレートファイルを分離したい場合は、&lt;a href=&quot;https://github.com/ktsn/vue-template-loader&quot;&gt;vue-template-loaderを&lt;/a&gt;使用できます。これにより、ビルドステップ中にテンプレートファイルがJavaScriptレンダリング関数に変換されます。</target>
        </trans-unit>
        <trans-unit id="b51a0d95775f6901a19eb4a518eb8294d6f3dd90" translate="yes" xml:space="preserve">
          <source>If you are using a custom Webpack configuration &lt;code&gt;ts-loader&lt;/code&gt; needs to be configured to parse &lt;code&gt;&amp;lt;script lang=&quot;ts&quot;&amp;gt;&lt;/code&gt; blocks in &lt;code&gt;.vue&lt;/code&gt; files:</source>
          <target state="translated">カスタムWebpack構成を使用している場合、 &lt;code&gt;.vue&lt;/code&gt; ファイル内の &lt;code&gt;&amp;lt;script lang=&quot;ts&quot;&amp;gt;&lt;/code&gt; ブロックを解析するように &lt;code&gt;ts-loader&lt;/code&gt; を構成する必要があります。</target>
        </trans-unit>
        <trans-unit id="e9339c27c9dc6e2ed60dd362c87632e60f6c3e6b" translate="yes" xml:space="preserve">
          <source>If you are using filters that were globally registered and then used throughout your app, it's likely not convenient to replace them with computed properties or methods in each individual component.</source>
          <target state="translated">グローバルに登録されたフィルタを使用していて、その後アプリ全体で使用している場合、個々のコンポーネント内で計算されたプロパティやメソッドに置き換えるのは便利ではないでしょう。</target>
        </trans-unit>
        <trans-unit id="89858e35b068365a82039534b03f306fb0a1b8c0" translate="yes" xml:space="preserve">
          <source>If you are using native ES Modules, there is also an ES Modules compatible build:</source>
          <target state="translated">ネイティブのESモジュールを使用している場合は、ESモジュール互換のビルドもあります。</target>
        </trans-unit>
        <trans-unit id="f554b9ea3847cd26d76c47af993f74bd496cd6f0" translate="yes" xml:space="preserve">
          <source>If you are using template-based functional components, you will also have to manually add attributes and listeners. Since we have access to the individual context contents, we can use &lt;code&gt;data.attrs&lt;/code&gt; to pass along any HTML attributes and &lt;code&gt;listeners&lt;/code&gt;&lt;em&gt;(the alias for &lt;code&gt;data.on&lt;/code&gt;)&lt;/em&gt; to pass along any event listeners.</source>
          <target state="translated">テンプレートベースの機能コンポーネントを使用している場合は、手動で属性とリスナーを追加する必要もあります。個々のコンテキストコンテンツにアクセスできるため、 &lt;code&gt;data.attrs&lt;/code&gt; を使用してHTML属性を渡し、 &lt;code&gt;listeners&lt;/code&gt; &lt;em&gt;（ &lt;code&gt;data.on&lt;/code&gt; のエイリアス）&lt;/em&gt;を使用してイベントリスナーを渡すことができます。</target>
        </trans-unit>
        <trans-unit id="8f0f868039c608a8992e0ecad40e6cc8c9afaa6c" translate="yes" xml:space="preserve">
          <source>If you are using the full build, i.e. directly including Vue via a script tag without a build tool, make sure to use the minified version (&lt;code&gt;vue.min.js&lt;/code&gt;) for production. Both versions can be found in the &lt;a href=&quot;installation#Direct-lt-script-gt-Include&quot;&gt;Installation guide&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;vue.min.js&lt;/code&gt; を使用している場合、つまり、ビルドツールを使用せずにスクリプトタグを介してVueを直接インクルードしている場合は、本番用に必ず縮小バージョン（vue.min.js）を使用してください。どちらのバージョンも&lt;a href=&quot;installation#Direct-lt-script-gt-Include&quot;&gt;インストールガイドに&lt;/a&gt;記載されています。</target>
        </trans-unit>
        <trans-unit id="5a4b189cf522ce6e29c54b33668d5386275afda1" translate="yes" xml:space="preserve">
          <source>If you are using the full build, i.e. directly including Vue via a script tag without a build tool, make sure to use the minified version for production. This can be found in the &lt;a href=&quot;../installation#cdn&quot;&gt;Installation guide&lt;/a&gt;.</source>
          <target state="translated">フルビルドを使用している場合、つまりビルドツールを使用せずにスクリプトタグを介してVueを直接含める場合は、縮小版を本番環境に使用してください。これは、&lt;a href=&quot;../installation#cdn&quot;&gt;インストールガイドに&lt;/a&gt;記載されています。</target>
        </trans-unit>
        <trans-unit id="3b60cd1fba6c46a688fbdbb235e044cb83c5b7b5" translate="yes" xml:space="preserve">
          <source>If you are using third party plugins such as &lt;code&gt;Vuex&lt;/code&gt; or &lt;code&gt;Vue Router&lt;/code&gt;, always check the documentation to know what that particular plugin expects to receive as a second parameter.</source>
          <target state="translated">次のようなサードパーティ製のプラグインを使用している場合は &lt;code&gt;Vuex&lt;/code&gt; や &lt;code&gt;Vue Router&lt;/code&gt; 、常にその特定のプラグインを期待は、2番目のパラメータとして受信するかを知るためのマニュアルを参照してください。</target>
        </trans-unit>
        <trans-unit id="c2e4fd881ce2746ee5cbf62bd67517fc2f4914a1" translate="yes" xml:space="preserve">
          <source>If you bundle your app with webpack with &lt;code&gt;target: 'node'&lt;/code&gt; and properly externalize &lt;code&gt;vue&lt;/code&gt;, this is the build that will be loaded.</source>
          <target state="translated">appを &lt;code&gt;target: 'node'&lt;/code&gt; webpackにバンドルし、 &lt;code&gt;vue&lt;/code&gt; を適切に外部化すると、これがロードされるビルドになります。</target>
        </trans-unit>
        <trans-unit id="4b2fe8b591e825c2bd65db72f8f115e0c3a56502" translate="yes" xml:space="preserve">
          <source>If you didn't have one defined &lt;em&gt;and&lt;/em&gt; your styling or other behaviors relied on the presence of the &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; root element to work properly, simply add &lt;code&gt;tag=&quot;span&quot;&lt;/code&gt; to the &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">あなたは1つが定義されていなかった場合&lt;em&gt;や&lt;/em&gt;、あなたのスタイリングや他の行動がの存在に依存していた &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; を正しく動作させるには、ルート要素、単に追加 &lt;code&gt;tag=&quot;span&quot;&lt;/code&gt; に &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="eb198153df2b83a6a3a26e2ebd225100fb4f2173" translate="yes" xml:space="preserve">
          <source>If you do &lt;strong&gt;not&lt;/strong&gt; want a component to automatically inherit attributes, you can set &lt;code&gt;inheritAttrs: false&lt;/code&gt; in the component's options.</source>
          <target state="translated">コンポーネントに属性を自動的に継承さ&lt;strong&gt;せ&lt;/strong&gt;たく&lt;strong&gt;ない&lt;/strong&gt;場合は、コンポーネントのオプションで &lt;code&gt;inheritAttrs: false&lt;/code&gt; を設定できます。</target>
        </trans-unit>
        <trans-unit id="0b251e43cfeb3150b9ce15a72f34811cb195e1d1" translate="yes" xml:space="preserve">
          <source>If you do &lt;strong&gt;not&lt;/strong&gt; want the root element of a component to inherit attributes, you can set &lt;code&gt;inheritAttrs: false&lt;/code&gt; in the component&amp;rsquo;s options. For example:</source>
          <target state="translated">コンポーネントのルート要素に属性を継承さ&lt;strong&gt;せ&lt;/strong&gt;たく&lt;strong&gt;ない&lt;/strong&gt;場合は、コンポーネントのオプションで &lt;code&gt;inheritAttrs: false&lt;/code&gt; を設定できます。例えば：</target>
        </trans-unit>
        <trans-unit id="83b896d00583e6604507095ce6adcb8923125b4d" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t declare &lt;code&gt;message&lt;/code&gt; in the data option, Vue will warn you that the render function is trying to access a property that doesn&amp;rsquo;t exist.</source>
          <target state="translated">データオプションで &lt;code&gt;message&lt;/code&gt; を宣言しない場合、Vueは、レンダリング関数が存在しないプロパティにアクセスしようとしていることを警告します。</target>
        </trans-unit>
        <trans-unit id="16f2472fe4831b78a6cfd9861a2ec950de0ec835" translate="yes" xml:space="preserve">
          <source>If you don't declare &lt;code&gt;message&lt;/code&gt; in the data option, Vue will warn you that the render function is trying to access a property that doesn't exist.</source>
          <target state="translated">データオプションで &lt;code&gt;message&lt;/code&gt; を宣言しない場合、Vueは、レンダリング関数が存在しないプロパティにアクセスしようとしていることを警告します。</target>
        </trans-unit>
        <trans-unit id="46b8f4debe19961ca67a65010685320784bdc244" translate="yes" xml:space="preserve">
          <source>If you find type inference or member completion isn&amp;rsquo;t working, annotating certain methods may help address these problems. Using the &lt;code&gt;--noImplicitAny&lt;/code&gt; option will help find many of these unannotated methods.</source>
          <target state="translated">型の推論またはメンバーの補完が機能しない場合は、特定のメソッドに注釈を付けると、これらの問題に対処できる場合があります。 &lt;code&gt;--noImplicitAny&lt;/code&gt; オプションを使用すると、これらの注釈なしメソッドの多くを見つけることができます。</target>
        </trans-unit>
        <trans-unit id="c99d9927ea3c8d31465469a680b0264760b24597" translate="yes" xml:space="preserve">
          <source>If you find yourself needing to force an update in Vue, in 99.99% of cases, you&amp;rsquo;ve made a mistake somewhere.</source>
          <target state="translated">Vueを強制的に更新する必要がある場合は、99.99％のケースで、どこかで間違いを犯しています。</target>
        </trans-unit>
        <trans-unit id="69e34e7997217094f6f692152e0f58e36b5ef7b7" translate="yes" xml:space="preserve">
          <source>If you find yourself needing to force an update in Vue, in 99.99% of cases, you've made a mistake somewhere. For example, you may be relying on state that isn't tracked by Vue's reactivity system, e.g. with &lt;code&gt;data&lt;/code&gt; property added after component creation.</source>
          <target state="translated">Vueで強制的に更新する必要がある場合は、99.99％のケースで、どこかで間違いを犯しています。たとえば、コンポーネントの作成後に追加された &lt;code&gt;data&lt;/code&gt; プロパティなど、Vueの反応性システムによって追跡されていない状態に依存している可能性があります。</target>
        </trans-unit>
        <trans-unit id="a282623f6bdd7b021ecb4c856f00a4975082becf" translate="yes" xml:space="preserve">
          <source>If you happen to be using partials in a performance-critical part of your app, then you should upgrade to &lt;a href=&quot;render-function#Functional-Components&quot;&gt;functional components&lt;/a&gt;. They must be in a plain JS/JSX file (rather than in a &lt;code&gt;.vue&lt;/code&gt; file) and are stateless and instanceless, like partials. This makes rendering extremely fast.</source>
          <target state="translated">アプリのパフォーマンスが重要な部分でパーシャルを使用している場合は、&lt;a href=&quot;render-function#Functional-Components&quot;&gt;機能コンポーネントに&lt;/a&gt;アップグレードする必要があります。それらは（ &lt;code&gt;.vue&lt;/code&gt; ファイルではなく）プレーンなJS / JSXファイルになければならず、パーシャルのようにステートレスでインスタンスレスです。これにより、レンダリングが非常に高速になります。</target>
        </trans-unit>
        <trans-unit id="a40b516039aedc82e1c9170530033902c12726ed" translate="yes" xml:space="preserve">
          <source>If you have a complex type or interface, you can cast it using &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/basic-types.html#type-assertions&quot;&gt;type assertion (opens new window)&lt;/a&gt;:</source>
          <target state="translated">複雑な型またはインターフェースがある場合は、&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/basic-types.html#type-assertions&quot;&gt;型アサーション&lt;/a&gt;を使用してキャストできます（新しいウィンドウが開きます）：</target>
        </trans-unit>
        <trans-unit id="f6790c4d625e03a0db14e824c77f7252c8ac6b22" translate="yes" xml:space="preserve">
          <source>If you have any questions on how you can get more involved with your local Vue community, reach out at &lt;a href=&quot;https://www.twitter.com/vuejs_events&quot;&gt;@Vuejs_Events&lt;/a&gt;!</source>
          <target state="translated">地元のVueコミュニティにもっと参加する方法について質問がある場合は、&lt;a href=&quot;https://www.twitter.com/vuejs_events&quot;&gt;@ Vuejs_Events&lt;/a&gt;に連絡してください！</target>
        </trans-unit>
        <trans-unit id="065d3201caaa2141d71da739cdfc7e30446a0749" translate="yes" xml:space="preserve">
          <source>If you have any tests, run them and see what still fails. If you don&amp;rsquo;t have tests, just open the app in your browser and keep an eye out for warnings or errors as you navigate around.</source>
          <target state="translated">テストがある場合は、それらを実行して、まだ失敗するものを確認します。テストがない場合は、ブラウザーでアプリを開き、移動する際の警告やエラーに注意してください。</target>
        </trans-unit>
        <trans-unit id="96e155ed303418e4faa49bd76ee26339a7c63a25" translate="yes" xml:space="preserve">
          <source>If you inspect this element in your chrome developer tools and open the Accessibility tab inside the Elements tab, you will see how the input gets its name from the label:</source>
          <target state="translated">クローム開発者ツールでこの要素を検査し、要素タブの中のアクセシビリティタブを開くと、入力がどのようにラベルから名前を取得しているかがわかります。</target>
        </trans-unit>
        <trans-unit id="4b6b5852b50da5bcf815176a6c34db9a40804fe5" translate="yes" xml:space="preserve">
          <source>If you need multiple aliases, you can also use an array syntax:</source>
          <target state="translated">複数のエイリアスが必要な場合は、配列構文を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="a86c834af1858680fe5ab3f3504c46895d429410" translate="yes" xml:space="preserve">
          <source>If you need to add new routes after the router has been instantiated, you can replace the router&amp;rsquo;s matcher with a new one that includes the route you&amp;rsquo;d like to add:</source>
          <target state="translated">ルーターがインスタンス化された後に新しいルートを追加する必要がある場合は、ルーターのマッチャーを、追加するルートを含む新しいマッチャーに置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="ddaed66412f9035c897a73c53b95d7b75a77f86c" translate="yes" xml:space="preserve">
          <source>If you need to compile templates on the client (e.g. passing a string to the &lt;code&gt;template&lt;/code&gt; option, or mounting to an element using its in-DOM HTML as the template), you will need the compiler and thus the full build:</source>
          <target state="translated">クライアントでテンプレートをコンパイルする必要がある場合（たとえば、 &lt;code&gt;template&lt;/code&gt; オプションに文字列を渡す、またはそのDOM内のHTMLをテンプレートとして使用して要素にマウントする）場合は、コンパイラーと完全なビルドが必要になります。</target>
        </trans-unit>
        <trans-unit id="ff7acc8749dfed6e4ff7f305eea543f1d2a84302" translate="yes" xml:space="preserve">
          <source>If you need to compile templates on the client (e.g. passing a string to the template option, or mounting to an element using its in-DOM HTML as the template), you will need the compiler and thus the full build:</source>
          <target state="translated">クライアント上でテンプレートをコンパイルする必要がある場合(例えば、テンプレートオプションに文字列を渡したり、in-DOM HTMLをテンプレートとして使用して要素にマウントするなど)、コンパイラとフルビルドが必要になります。</target>
        </trans-unit>
        <trans-unit id="5c99f87095091faefdae01d0f1c8e79606b30cab" translate="yes" xml:space="preserve">
          <source>If you need to destructure your props, you can do this by utilizing the &lt;a href=&quot;reactivity-fundamentals#destructuring-reactive-state&quot;&gt;toRefs&lt;/a&gt; inside of the &lt;code&gt;setup&lt;/code&gt; function:</source>
          <target state="translated">小道具を&lt;a href=&quot;reactivity-fundamentals#destructuring-reactive-state&quot;&gt;分解&lt;/a&gt;する必要がある場合は、 &lt;code&gt;setup&lt;/code&gt; 関数内のtoRefsを利用してこれを行うことができます。</target>
        </trans-unit>
        <trans-unit id="1f48f8167c0a23ab61df4005f4d4a72ae2eb587c" translate="yes" xml:space="preserve">
          <source>If you need to programmatically generate routes when starting up your app, you can do so by dynamically pushing definitions to a routes array. For example:</source>
          <target state="translated">アプリの起動時にプログラムでルートを生成する必要がある場合は、定義をルート配列に動的にプッシュすることで行うことができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="c75b905774715058912c0cd6cc8289b46519b9fd" translate="yes" xml:space="preserve">
          <source>If you need to stagger list transitions, you can control timing by setting and accessing a &lt;code&gt;data-index&lt;/code&gt; (or similar attribute) on an element. See &lt;a href=&quot;transitions#Staggering-List-Transitions&quot;&gt;an example here&lt;/a&gt;.</source>
          <target state="translated">リストの遷移をずらす必要がある場合は、要素の &lt;code&gt;data-index&lt;/code&gt; （または同様の属性）を設定してアクセスすることにより、タイミングを制御できます。こちら&lt;a href=&quot;transitions#Staggering-List-Transitions&quot;&gt;の例をご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f36db052506affc289d8cbab07f304cc42b2cfc" translate="yes" xml:space="preserve">
          <source>If you only need very simple routing and do not wish to involve a full-featured router library, you can do so by dynamically rendering a page-level component like this:</source>
          <target state="translated">非常にシンプルなルーティングだけが必要で、フル機能のルータライブラリを使用したくない場合は、以下のようにページレベルのコンポーネントを動的にレンダリングすることで実現できます。</target>
        </trans-unit>
        <trans-unit id="83934613eeb1fab05cbec23a2b6576ef65c9de74" translate="yes" xml:space="preserve">
          <source>If you open up your JavaScript console again and enter &lt;code&gt;app2.message = 'some new message'&lt;/code&gt;, you&amp;rsquo;ll once again see that the bound HTML - in this case the &lt;code&gt;title&lt;/code&gt; attribute - has been updated.</source>
          <target state="translated">JavaScriptコンソールを再度開いて &lt;code&gt;app2.message = 'some new message'&lt;/code&gt; と入力すると、バインドされたHTML（この場合は &lt;code&gt;title&lt;/code&gt; 属性）が更新されていることが再びわかります。</target>
        </trans-unit>
        <trans-unit id="aee69dbd3a0e9f50e62e6f6016f428f6608cc1d0" translate="yes" xml:space="preserve">
          <source>If you prefer a class-based API when declaring components, you can use the officially maintained &lt;a href=&quot;https://github.com/vuejs/vue-class-component&quot;&gt;vue-class-component&lt;/a&gt; decorator:</source>
          <target state="translated">コンポーネントを宣言するときにクラスベースのAPIを使用する場合は、公式に保守されている&lt;a href=&quot;https://github.com/vuejs/vue-class-component&quot;&gt;vue-class-component&lt;/a&gt;デコレーターを使用できます。</target>
        </trans-unit>
        <trans-unit id="75403d1bbcd622140e98147df81237f72e89afbb" translate="yes" xml:space="preserve">
          <source>If you prefer something more interactive, you can also check out &lt;a href=&quot;https://scrimba.com/playlist/pXKqta&quot;&gt;this tutorial series on Scrimba&lt;/a&gt;, which gives you a mix of screencast and code playground that you can pause and play around with anytime.</source>
          <target state="translated">もっとインタラクティブなものがお好みなら、&lt;a href=&quot;https://scrimba.com/playlist/pXKqta&quot;&gt;このチュートリアルシリーズのScrimba&lt;/a&gt;もチェックしてください。スクリーンキャストとコードプレイグラウンドを組み合わせて、いつでも一時停止して遊ぶことができます。</target>
        </trans-unit>
        <trans-unit id="026a80f81fcc351d7fe1000884a4c6e0166e6fc9" translate="yes" xml:space="preserve">
          <source>If you put the number two in the first cell, and the number 3 in the second and asked for the SUM, the spreadsheet would give it to you. No surprises there. But if you update that first number, the SUM automagically updates too.</source>
          <target state="translated">最初のセルに 2 番目の数字を入れ、2 番目のセルに 3 番目の数字を入れて SUM を求めると、スプレッドシートはそれを与えてくれます。驚きはありません。しかし、最初の数字を更新すると、SUMも自動的に更新されます。</target>
        </trans-unit>
        <trans-unit id="a1803a0174123ec0c71857041cc2fd5b41d4ca83" translate="yes" xml:space="preserve">
          <source>If you really need to override another &lt;code&gt;!important&lt;/code&gt;, you must use the string syntax:</source>
          <target state="translated">本当に別の &lt;code&gt;!important&lt;/code&gt; をオーバーライドする必要がある場合は、文字列構文を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="b9b3464a0443a4fd3675c6560f46c9a5c23720d5" translate="yes" xml:space="preserve">
          <source>If you really want to duplicate the same element/component many times, you can do so with a factory function. For example, the following render function is a perfectly valid way of rendering 20 identical paragraphs:</source>
          <target state="translated">本当に同じ要素/コンポーネントを何度も複製したい場合は、ファクトリー関数を使用して複製することができます。例えば、以下の render 関数は、20 個の同一の段落をレンダリングするための完全に有効な方法です。</target>
        </trans-unit>
        <trans-unit id="82b8fa8fd3b7f04299490484030ca94869913190" translate="yes" xml:space="preserve">
          <source>If you rely on watching array mutations, add the &lt;code&gt;deep&lt;/code&gt; property to ensure that your callback is triggered correctly.</source>
          <target state="translated">配列の変更の監視に依存している場合は、 &lt;code&gt;deep&lt;/code&gt; プロパティを追加して、コールバックが正しくトリガーされるようにします。</target>
        </trans-unit>
        <trans-unit id="035e11da3a8ba14dbdb2e0af739ac5d197d754c9" translate="yes" xml:space="preserve">
          <source>If you still want to call an unwatch function inside the callback, you should check its availability first:</source>
          <target state="translated">それでもコールバック内でアンウォッチ関数を呼び出したい場合は、まずその利用可能性を確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="e745791f30101cac58a2b81a7963801c737409a8" translate="yes" xml:space="preserve">
          <source>If you try this in your template however, Vue will show an error, explaining that &lt;strong&gt;every component must have a single root element&lt;/strong&gt;. You can fix this error by wrapping the template in a parent element, such as:</source>
          <target state="translated">ただし、テンプレートでこれを試行すると、Vueはエラーを表示し、&lt;strong&gt;すべてのコンポーネントに単一のルート要素が必要であることを&lt;/strong&gt;説明し&lt;strong&gt;ます&lt;/strong&gt;。このエラーを修正するには、次のようにテンプレートを親要素でラップします。</target>
        </trans-unit>
        <trans-unit id="14259c72550c39ee6e4f5a0f4cc02294d8e66215" translate="yes" xml:space="preserve">
          <source>If you use a module bundle like webpack, this may cause Vue&amp;rsquo;s source code to be bundled into the plugin, and more often than not that&amp;rsquo;s not what you'd expect. A common practice to prevent this from happening is to configure the module bundler to exclude Vue from the final bundle. In webpack's case, you can use the &lt;a href=&quot;https://webpack.js.org/configuration/externals/&quot;&gt;&lt;code&gt;externals&lt;/code&gt; (opens new window)&lt;/a&gt; configuration option:</source>
          <target state="translated">webpackのようなモジュールバンドルを使用する場合、これによりVueのソースコードがプラグインにバンドルされる可能性があり、多くの場合、それは期待したものではありません。これを防ぐための一般的な方法は、最終バンドルからVueを除外するようにモジュールバンドラーを構成することです。webpackの場合、&lt;a href=&quot;https://webpack.js.org/configuration/externals/&quot;&gt; &lt;code&gt;externals&lt;/code&gt; （新しいウィンドウを開く）&lt;/a&gt;構成オプションを使用できます。</target>
        </trans-unit>
        <trans-unit id="867330159a7ddc38fc78ddc898cba459aac34c10" translate="yes" xml:space="preserve">
          <source>If you use any non-Vue custom elements in your templates, such as a web component, PascalCase ensures that your Vue components remain distinctly visible.</source>
          <target state="translated">Webコンポーネントなど、Vue以外のカスタム要素をテンプレートに使用している場合、PascalCaseはVueコンポーネントを明確に表示できるようにします。</target>
        </trans-unit>
        <trans-unit id="60f8e15ea64a01da65a785bd3977a29768fe4144" translate="yes" xml:space="preserve">
          <source>If you want to coerce a prop, setup a local computed value based on it instead. For example, instead of:</source>
          <target state="translated">プロップを強制したい場合は、そのプロップに基づいてローカルで計算された値を設定します。例えば、代わりに</target>
        </trans-unit>
        <trans-unit id="ec0a06cc0af41c0df81514c72a42baf2a7b4e3e2" translate="yes" xml:space="preserve">
          <source>If you want to dive right in and start playing with single-file components, check out &lt;a href=&quot;https://codesandbox.io/s/o29j95wx9&quot;&gt;this simple todo app&lt;/a&gt; on CodeSandbox.</source>
          <target state="translated">すぐに始めて、単一ファイルのコンポーネントで遊んでみたい場合は、CodeSandboxで&lt;a href=&quot;https://codesandbox.io/s/o29j95wx9&quot;&gt;この単純なtodoアプリ&lt;/a&gt;をチェックしてください。</target>
        </trans-unit>
        <trans-unit id="19c4d2e8e9b44f23f256752921c6f56b3515e01e" translate="yes" xml:space="preserve">
          <source>If you want to dive right in and start playing with single-file components, check out &lt;a href=&quot;https://codesandbox.io/s/vue-todo-list-app-with-single-file-component-vzkl3?file=/src/App.vue&quot;&gt;this simple todo app (opens new window)&lt;/a&gt; on CodeSandbox.</source>
          <target state="translated">すぐに飛び込んで単一ファイルのコンポーネントで遊び始めたい場合は、CodeSandboxで&lt;a href=&quot;https://codesandbox.io/s/vue-todo-list-app-with-single-file-component-vzkl3?file=/src/App.vue&quot;&gt;このシンプルなtodoアプリ（新しいウィンドウを開きます）&lt;/a&gt;をチェックしてください。</target>
        </trans-unit>
        <trans-unit id="221bedd32adb2426b2b5127135897cde8d509422" translate="yes" xml:space="preserve">
          <source>If you want to pass all the properties of an object as props, you can use &lt;code&gt;v-bind&lt;/code&gt; without an argument (&lt;code&gt;v-bind&lt;/code&gt; instead of &lt;code&gt;:prop-name&lt;/code&gt;). For example, given a &lt;code&gt;post&lt;/code&gt; object:</source>
          <target state="translated">オブジェクトのすべてのプロパティを小道具として渡したい場合は、引数なしで &lt;code&gt;v-bind&lt;/code&gt; を使用できます（ &lt;code&gt;:prop-name&lt;/code&gt; の代わりに &lt;code&gt;v-bind&lt;/code&gt; ）。たとえば、 &lt;code&gt;post&lt;/code&gt; オブジェクトが与えられた場合：</target>
        </trans-unit>
        <trans-unit id="46daea4d2cc73e0262635e93ef739858416c1a90" translate="yes" xml:space="preserve">
          <source>If you want to pass all the properties of an object as props, you can use &lt;code&gt;v-bind&lt;/code&gt; without an argument (&lt;code&gt;v-bind&lt;/code&gt; instead of &lt;code&gt;v-bind:prop-name&lt;/code&gt;). For example, given a &lt;code&gt;post&lt;/code&gt; object:</source>
          <target state="translated">あなたが小道具としてオブジェクトのすべてのプロパティを渡したい場合は、使用することができ &lt;code&gt;v-bind&lt;/code&gt; （引数なしで &lt;code&gt;v-bind&lt;/code&gt; の代わりに &lt;code&gt;v-bind:prop-name&lt;/code&gt; ）。たとえば、 &lt;code&gt;post&lt;/code&gt; オブジェクトが与えられた場合：</target>
        </trans-unit>
        <trans-unit id="caa62e4207841b276f4bf69747cc49086ed59533" translate="yes" xml:space="preserve">
          <source>If you want to register a directive locally instead, components also accept a &lt;code&gt;directives&lt;/code&gt; option:</source>
          <target state="translated">代わりにディレクティブをローカルに登録する場合、コンポーネントは &lt;code&gt;directives&lt;/code&gt; オプションも受け入れます。</target>
        </trans-unit>
        <trans-unit id="a5c60bce10cae3d5303941aa3e57ed099d7e4435" translate="yes" xml:space="preserve">
          <source>If you want user input to be automatically typecast as a number, you can add the &lt;code&gt;number&lt;/code&gt; modifier to your &lt;code&gt;v-model&lt;/code&gt; managed inputs:</source>
          <target state="translated">ユーザー入力を数値として自動的に型キャストする場合は、 &lt;code&gt;number&lt;/code&gt; 修飾子を &lt;code&gt;v-model&lt;/code&gt; 管理対象入力に追加できます。</target>
        </trans-unit>
        <trans-unit id="2a16d061cc634d4f68b39e327bf7521b345a10fa" translate="yes" xml:space="preserve">
          <source>If you want whitespace from user input to be trimmed automatically, you can add the &lt;code&gt;trim&lt;/code&gt; modifier to your &lt;code&gt;v-model&lt;/code&gt;-managed inputs:</source>
          <target state="translated">ユーザー入力の空白を自動的にトリミングする場合は、 &lt;code&gt;v-model&lt;/code&gt; 管理の入力に &lt;code&gt;trim&lt;/code&gt; 修飾子を追加できます。</target>
        </trans-unit>
        <trans-unit id="27e01c628ccff4f037b351b0e994f9073ee50cc8" translate="yes" xml:space="preserve">
          <source>If you were previously relying on &lt;code&gt;vm.$watch&lt;/code&gt; to do something with the DOM after a component updates, you can instead do so in the &lt;code&gt;updated&lt;/code&gt; lifecycle hook.</source>
          <target state="translated">コンポーネントの更新後、以前に &lt;code&gt;vm.$watch&lt;/code&gt; を使用してDOMを操作していた場合は、代わりに &lt;code&gt;updated&lt;/code&gt; ライフサイクルフックで行うことができます。</target>
        </trans-unit>
        <trans-unit id="43daed9c097353737805c1bf2ab9ef52cfa52fb5" translate="yes" xml:space="preserve">
          <source>If you wish to hardware-accelerate an element, you can apply any of these properties (not all are necessary, only one):</source>
          <target state="translated">要素をハードウェアアクセラレーションしたい場合は、これらのプロパティのいずれかを適用することができます(すべてが必要なわけではなく、1つだけ)。</target>
        </trans-unit>
        <trans-unit id="d09ac65f465dd8ab501455462ff8cb0ee50716d0" translate="yes" xml:space="preserve">
          <source>If you would like to also toggle a class in the list conditionally, you can do it with a ternary expression:</source>
          <target state="translated">リスト内のクラスを条件付きで切り替えたい場合は、三項式で行うことができます。</target>
        </trans-unit>
        <trans-unit id="bba4a4286bcc04db765fc3867dbf7ddb1a48e9be" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to learn more about Vue before diving in, we created a video walking through the core principles and a sample project.</source>
          <target state="translated">始める前にVueについて詳しく知りたい場合は、基本原則とサンプルプロジェクトを紹介する動画を作成しました。</target>
        </trans-unit>
        <trans-unit id="8bdbab444a3ccfd0f249abc5bdb15834f654b882" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re a &lt;strong&gt;Browserify&lt;/strong&gt; user that would like to use async components, its creator has unfortunately &lt;a href=&quot;https://github.com/substack/node-browserify/issues/58#issuecomment-21978224&quot;&gt;made it clear&lt;/a&gt; that async loading &amp;ldquo;is not something that Browserify will ever support.&amp;rdquo; Officially, at least. The Browserify community has found &lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/620&quot;&gt;some workarounds&lt;/a&gt;, which may be helpful for existing and complex applications. For all other scenarios, we recommend using Webpack for built-in, first-class async support.</source>
          <target state="translated">非同期コンポーネントを使用したい&lt;strong&gt;Browserify&lt;/strong&gt;ユーザーの場合、その作成者は残念ながら、非同期読み込みは「Browserifyがサポートするものではない」&lt;a href=&quot;https://github.com/substack/node-browserify/issues/58#issuecomment-21978224&quot;&gt;ことを明らかに&lt;/a&gt;しました。少なくとも公式には。 Browserifyコミュニティは、既存の複雑なアプリケーションに役立つ&lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/620&quot;&gt;いくつかの回避策&lt;/a&gt;を見つけました。他のすべてのシナリオでは、組み込みのファーストクラスの非同期サポートにWebpackを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="edcc3ba94bcb1cfdcb2e9c17bd2ce8899e7c55b1" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re coming from React, you may be wondering how vuex compares to &lt;a href=&quot;https://github.com/reactjs/redux&quot;&gt;redux&lt;/a&gt;, the most popular Flux implementation in that ecosystem. Redux is actually view-layer agnostic, so it can easily be used with Vue via &lt;a href=&quot;https://yarnpkg.com/en/packages?q=redux%20vue&amp;amp;p=1&quot;&gt;simple bindings&lt;/a&gt;. Vuex is different in that it &lt;em&gt;knows&lt;/em&gt; it&amp;rsquo;s in a Vue app. This allows it to better integrate with Vue, offering a more intuitive API and improved development experience.</source>
          <target state="translated">Reactから来ている場合は、vuex がそのエコシステムで最も人気のあるFlux実装である&lt;a href=&quot;https://github.com/reactjs/redux&quot;&gt;redux&lt;/a&gt;と比較して不思議に思うかもしれません。Reduxは実際にはビューレイヤーに依存しないため、&lt;a href=&quot;https://yarnpkg.com/en/packages?q=redux%20vue&amp;amp;p=1&quot;&gt;単純なバインディング&lt;/a&gt;を介してVueで簡単に使用できます。Vuexは、Vueアプリ内にあることを&lt;em&gt;認識&lt;/em&gt;して&lt;em&gt;いる&lt;/em&gt;点が異なります。これにより、Vueとの統合が向上し、より直感的なAPIと改善された開発エクスペリエンスが提供されます。</target>
        </trans-unit>
        <trans-unit id="ac6cff90ff8235cb92a798958233e09ce65f41ef" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not careful, recursive components can also lead to infinite loops:</source>
          <target state="translated">注意しないと、再帰コンポーネントが無限ループを引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="31dfe6cb288a0519fc0e0e9ea5786682c1441d3d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not using a module system with &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;require&lt;/code&gt;, you can probably skip this section for now. If you are, we have some special instructions and tips just for you.</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; / &lt;code&gt;require&lt;/code&gt; でモジュールシステムを使用していない場合は、おそらく今のところこのセクションをスキップできます。もしそうなら、私たちはあなたのためだけに特別な指示とヒントをいくつか持っています。</target>
        </trans-unit>
        <trans-unit id="4cd1a70ae99b09e3c3ad5742cdad75a7a51ef4df" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not yet familiar with Vue&amp;rsquo;s components, you can skip this for now.</source>
          <target state="translated">Vueのコンポーネントにまだ慣れていない場合は、今のところこれをスキップできます。</target>
        </trans-unit>
        <trans-unit id="3fc717a96a6a10a9a99af5efe59b5bba0e6a070d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re still here, then it&amp;rsquo;s likely you&amp;rsquo;re using a module system, such as with Babel and Webpack. In these cases, we recommend creating a &lt;code&gt;components&lt;/code&gt; directory, with each component in its own file.</source>
          <target state="translated">まだここにいる場合は、BabelやWebpackなどのモジュールシステムを使用している可能性があります。このような場合は、 &lt;code&gt;components&lt;/code&gt; ディレクトリを作成し、各コンポーネントを独自のファイルに含めることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="ea196c4500fb63b55d56b5fae7f497c03397f1ba" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re writing a lot of &lt;code&gt;render&lt;/code&gt; functions, it might feel painful to write something like this:</source>
          <target state="translated">たくさんの &lt;code&gt;render&lt;/code&gt; 関数を書いている場合、次のようなものを書くのは苦痛に感じるかもしれません：</target>
        </trans-unit>
        <trans-unit id="609a6f861acf12bf2b5f3b2a6f3ec765be8efafd" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve ever had to manually manipulate DOM in Vue, you might have come across this pattern:</source>
          <target state="translated">VueでDOMを手動で操作する必要があった場合は、次のパターンに遭遇した可能性があります。</target>
        </trans-unit>
        <trans-unit id="f4ecc2bc675d03a98476e9bf350d5918a55d45a0" translate="yes" xml:space="preserve">
          <source>If you're coming from React, you may be wondering how vuex compares to &lt;a href=&quot;https://github.com/reactjs/redux&quot;&gt;redux (opens new window)&lt;/a&gt;, the most popular Flux implementation in that ecosystem. Redux is actually view-layer agnostic, so it can easily be used with Vue via &lt;a href=&quot;https://classic.yarnpkg.com/en/packages?q=redux%20vue&amp;amp;p=1&quot;&gt;simple bindings (opens new window)&lt;/a&gt;. Vuex is different in that it &lt;em&gt;knows&lt;/em&gt; it's in a Vue app. This allows it to better integrate with Vue, offering a more intuitive API and improved development experience.</source>
          <target state="translated">Reactから来ている場合、vuexがそのエコシステムで最も人気のあるFlux実装である&lt;a href=&quot;https://github.com/reactjs/redux&quot;&gt;redux（新しいウィンドウを開く）&lt;/a&gt;とどのように比較されるのか疑問に思われるかもしれません。Reduxは実際にはビューレイヤーに依存しないため、&lt;a href=&quot;https://classic.yarnpkg.com/en/packages?q=redux%20vue&amp;amp;p=1&quot;&gt;単純なバインディング&lt;/a&gt;を介してVueで簡単に使用できます（新しいウィンドウが開きます）。Vuexは、Vueアプリ内にあることを&lt;em&gt;認識&lt;/em&gt;して&lt;em&gt;いる&lt;/em&gt;という点で異なります。これにより、Vueとの統合が改善され、より直感的なAPIと改善された開発エクスペリエンスが提供されます。</target>
        </trans-unit>
        <trans-unit id="4383a33376cb43b8f9f3a34ad4ebc3a22a32fdbb" translate="yes" xml:space="preserve">
          <source>If you're not using a module system with &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;require&lt;/code&gt;, you can probably skip this section for now. If you are, we have some special instructions and tips just for you.</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; / &lt;code&gt;require&lt;/code&gt; でモジュールシステムを使用していない場合は、おそらく今のところこのセクションをスキップできます。もしそうなら、私たちはあなたのためだけにいくつかの特別な指示とヒントを持っています。</target>
        </trans-unit>
        <trans-unit id="d391b26209861300899a2add1af08ef09f4194f8" translate="yes" xml:space="preserve">
          <source>If you're not yet familiar with Vue's components, you can skip this for now.</source>
          <target state="translated">Vueのコンポーネントにまだ慣れていない方は、今のところは飛ばしていただいて構いません。</target>
        </trans-unit>
        <trans-unit id="913e0a49efe5be77ae2656044ce4cc773b612ae8" translate="yes" xml:space="preserve">
          <source>If you're still here, then it's likely you're using a module system, such as with Babel and Webpack. In these cases, we recommend creating a &lt;code&gt;components&lt;/code&gt; directory, with each component in its own file.</source>
          <target state="translated">まだここにいる場合は、BabelやWebpackなどのモジュールシステムを使用している可能性があります。このような場合は、各コンポーネントを独自のファイルに入れて、 &lt;code&gt;components&lt;/code&gt; ディレクトリを作成することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f123dacf3d9e21f599eddd3ec553d8bc240c00ee" translate="yes" xml:space="preserve">
          <source>If you're using a &lt;a href=&quot;../installation#cdn&quot;&gt;CDN&lt;/a&gt; build of Vue then &lt;code&gt;createApp&lt;/code&gt; is exposed via the global &lt;code&gt;Vue&lt;/code&gt; object:</source>
          <target state="translated">Vueの&lt;a href=&quot;../installation#cdn&quot;&gt;CDN&lt;/a&gt;ビルドを使用している場合、 &lt;code&gt;createApp&lt;/code&gt; はグローバル &lt;code&gt;Vue&lt;/code&gt; オブジェクトを介して公開されます。</target>
        </trans-unit>
        <trans-unit id="256d7614924d2b75c2300fd933e837e95c0b7657" translate="yes" xml:space="preserve">
          <source>If your component has multiple root elements, you would need to define which component will receive this class. You can do this using &lt;code&gt;$attrs&lt;/code&gt; component property:</source>
          <target state="translated">コンポーネントに複数のルート要素がある場合は、このクラスを受け取るコンポーネントを定義する必要があります。 &lt;code&gt;$attrs&lt;/code&gt; コンポーネントプロパティを使用してこれを行うことができます。</target>
        </trans-unit>
        <trans-unit id="1e55f976e59b49199d2ea7af9a5149f956c1e601" translate="yes" xml:space="preserve">
          <source>If your directive needs multiple values, you can also pass in a JavaScript object literal. Remember, directives can take any valid JavaScript expression.</source>
          <target state="translated">ディレクティブに複数の値が必要な場合は、 JavaScript オブジェクトリテラルを渡すこともできます。覚えておいてください、ディレクティブは有効な JavaScript の式を受け取ることができます。</target>
        </trans-unit>
        <trans-unit id="242aaacd829f9f99856dd2793dfdfc9507666410" translate="yes" xml:space="preserve">
          <source>If your module bundler of choice happens to be &lt;a href=&quot;https://rollupjs.org/&quot;&gt;Rollup (opens new window)&lt;/a&gt;, you basically get the same effect for free, as by default Rollup will treat absolute module IDs (&lt;code&gt;'vue'&lt;/code&gt; in our case) as external dependencies and not include them in the final bundle. During bundling though, it might emit a &lt;a href=&quot;https://rollupjs.org/guide/en/#warning-treating-module-as-external-dependency&quot;&gt;&amp;ldquo;Treating vue as external dependency&amp;rdquo; (opens new window)&lt;/a&gt; warning, which can be suppressed with the &lt;code&gt;external&lt;/code&gt; option:</source>
          <target state="translated">選択したモジュールバンドラーがたまたま&lt;a href=&quot;https://rollupjs.org/&quot;&gt;ロールアップ（新しいウィンドウを開く）の&lt;/a&gt;場合、基本的に同じ効果が無料で得られます。デフォルトでは、ロールアップは絶対モジュールID（この場合は &lt;code&gt;'vue'&lt;/code&gt; ）を外部依存関係として扱い、それらをに含めないためです。最終バンドル。ただし、バンドル中に、&lt;a href=&quot;https://rollupjs.org/guide/en/#warning-treating-module-as-external-dependency&quot;&gt;「vueを外部依存関係として扱う」（新しいウィンドウを開く）&lt;/a&gt;警告が表示される場合があります。これは、 &lt;code&gt;external&lt;/code&gt; オプションで抑制できます。</target>
        </trans-unit>
        <trans-unit id="5a721aa3beb5717086550f15e05596fdcd9ca355" translate="yes" xml:space="preserve">
          <source>If your plugin relies on an affected Vue 2.x global API, for instance:</source>
          <target state="translated">プラグインが影響を受ける Vue 2.x グローバル API に依存している場合、例えば、次のようになります。</target>
        </trans-unit>
        <trans-unit id="8119918563dea634ba032ddd3981c094251dbb90" translate="yes" xml:space="preserve">
          <source>Imagine the case where we have a standalone primitive value (for example, a string) and we want to make it reactive. Of course, we could make an object with a single property equal to our string, and pass it to &lt;code&gt;reactive&lt;/code&gt;. Vue has a method that will do the same for us - it's a &lt;code&gt;ref&lt;/code&gt;:</source>
          <target state="translated">スタンドアロンのプリミティブ値（たとえば、文字列）があり、それをリアクティブにしたい場合を想像してみてください。もちろん、文字列に等しい単一のプロパティを持つオブジェクトを作成し、それを &lt;code&gt;reactive&lt;/code&gt; に渡すこともできます。Vueには私たちのために同じことをするメソッドがあります-それは &lt;code&gt;ref&lt;/code&gt; です：</target>
        </trans-unit>
        <trans-unit id="ac40dacaf019bddc14aed2d0fa2773dee73842cf" translate="yes" xml:space="preserve">
          <source>Imagine this is the template for &lt;code&gt;bootstrap-date-input&lt;/code&gt;:</source>
          <target state="translated">これが &lt;code&gt;bootstrap-date-input&lt;/code&gt; のテンプレートであると想像してください：</target>
        </trans-unit>
        <trans-unit id="b5a9cca298c2ad31236d51c99a03c78bea9e1757" translate="yes" xml:space="preserve">
          <source>Implementation-wise &lt;code&gt;defineComponent&lt;/code&gt; does nothing but return the object passed to it. However, in terms of typing, the returned value has a synthetic type of a constructor for manual render function, TSX and IDE tooling support.</source>
          <target state="translated">実装に関しては、 &lt;code&gt;defineComponent&lt;/code&gt; は渡されたオブジェクトを返すだけです。ただし、入力に関しては、戻り値には、手動レンダリング関数、TSX、およびIDEツールのサポートのためのコンストラクターの合成タイプが含まれています。</target>
        </trans-unit>
        <trans-unit id="224c21757ea8bf64841521a52786c7584cd3070c" translate="yes" xml:space="preserve">
          <source>Implicit parent-child communication</source>
          <target state="translated">暗黙の親子コミュニケーション</target>
        </trans-unit>
        <trans-unit id="55330d37bd375d0971edbec4ed65271fd1ecea19" translate="yes" xml:space="preserve">
          <source>Implicit parent-child communication &lt;sup&gt;use with caution&lt;/sup&gt;</source>
          <target state="translated">暗黙の親子通信の&lt;sup&gt;使用には注意が必要です&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="28826b0d2e02701105ec50963d8f7e90554a6576" translate="yes" xml:space="preserve">
          <source>Import it as a &lt;a href=&quot;#cdn&quot;&gt;CDN package&lt;/a&gt; on the page</source>
          <target state="translated">ページ上の&lt;a href=&quot;#cdn&quot;&gt;CDNパッケージ&lt;/a&gt;としてインポートします</target>
        </trans-unit>
        <trans-unit id="e9992581d590be676f25bb4ed76a8393ef92057e" translate="yes" xml:space="preserve">
          <source>Imported dependencies are also esm-bundler builds and will in turn import their dependencies (e.g. @vue/runtime-core imports @vue/reactivity)</source>
          <target state="translated">インポートされた依存関係は esm-bundler ビルドでもあり、その依存関係もインポートされます (例:@vue/runtime-core は @vue/reactivity をインポートします)。</target>
        </trans-unit>
        <trans-unit id="836e63c09fd6ddabcf1825ec759e9e296d10a1ec" translate="yes" xml:space="preserve">
          <source>Imports dependencies (e.g. &lt;code&gt;@vue/runtime-core&lt;/code&gt;, &lt;code&gt;@vue/runtime-compiler&lt;/code&gt;)</source>
          <target state="translated">依存関係をインポートします（例： &lt;code&gt;@vue/runtime-core&lt;/code&gt; 、 &lt;code&gt;@vue/runtime-compiler&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="a5200b178a45fe7d68a514c32e5d600863251de0" translate="yes" xml:space="preserve">
          <source>In 2.2 we introduced the &lt;code&gt;model&lt;/code&gt; component option that allows the component to customize the prop and event to use for &lt;code&gt;v-model&lt;/code&gt;. However, this still only allowed a single &lt;code&gt;v-model&lt;/code&gt; to be used on the component.</source>
          <target state="translated">2.2では、コンポーネントが &lt;code&gt;v-model&lt;/code&gt; に使用する小道具とイベントをカスタマイズできるようにする &lt;code&gt;model&lt;/code&gt; コンポーネントオプションを導入しました。ただし、これでも、コンポーネントで使用できる &lt;code&gt;v-model&lt;/code&gt; は1つだけでした。</target>
        </trans-unit>
        <trans-unit id="cff0737239eca41b60241cc75c9ed0aa10e7cf12" translate="yes" xml:space="preserve">
          <source>In 2.2.0+ and above, &lt;code&gt;activated&lt;/code&gt; and &lt;code&gt;deactivated&lt;/code&gt; will fire for all nested components inside a &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; tree.</source>
          <target state="translated">2.2.0以降では、 &lt;code&gt;activated&lt;/code&gt; および &lt;code&gt;deactivated&lt;/code&gt; は、 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; ツリー内のすべてのネストされたコンポーネントに対して発生します。</target>
        </trans-unit>
        <trans-unit id="b549760aeed2ab9d1d4db1c8e2a9ad9c0ecadc86" translate="yes" xml:space="preserve">
          <source>In 2.2.0+, this hook also captures errors in component lifecycle hooks. Also, when this hook is &lt;code&gt;undefined&lt;/code&gt;, captured errors will be logged with &lt;code&gt;console.error&lt;/code&gt; instead of crashing the app.</source>
          <target state="translated">2.2.0以降では、このフックはコンポーネントのライフサイクルフックのエラーもキャプチャします。また、このフックが &lt;code&gt;undefined&lt;/code&gt; の場合、アプリをクラッシュさせるのではなく、キャプチャされたエラーが &lt;code&gt;console.error&lt;/code&gt; でログに記録されます。</target>
        </trans-unit>
        <trans-unit id="999b4c5d77cbbc3bee12f8c040b08340523086be" translate="yes" xml:space="preserve">
          <source>In 2.2.0+, when using &lt;code&gt;v-for&lt;/code&gt; with a component, a &lt;a href=&quot;list#key&quot;&gt;&lt;code&gt;key&lt;/code&gt;&lt;/a&gt; is now required.</source>
          <target state="translated">2.2.0以降 &lt;code&gt;v-for&lt;/code&gt; は、コンポーネントでv-forを使用するときに、&lt;a href=&quot;list#key&quot;&gt; &lt;code&gt;key&lt;/code&gt; &lt;/a&gt;が必要になります。</target>
        </trans-unit>
        <trans-unit id="ecaafff83b9fcb93b3e419ce8a4773d634c3148b" translate="yes" xml:space="preserve">
          <source>In 2.4.0+, this hook also captures errors thrown inside Vue custom event handlers.</source>
          <target state="translated">2.4.0+では、このフックはVueカスタムイベントハンドラ内でスローされるエラーも捕捉します。</target>
        </trans-unit>
        <trans-unit id="edef70fc2b7c008af4bf42ee31332936b525d0f1" translate="yes" xml:space="preserve">
          <source>In 2.5.0+ injections can be optional with default value:</source>
          <target state="translated">2.5.0+では、デフォルト値で注入をオプションにすることができます。</target>
        </trans-unit>
        <trans-unit id="4b8a8ed5d2d9e4a1e1eed10aaf95fe05167d5fd5" translate="yes" xml:space="preserve">
          <source>In 2.5.0+, if you are using &lt;a href=&quot;single-file-components&quot;&gt;single-file components&lt;/a&gt;, template-based functional components can be declared with:</source>
          <target state="translated">2.5.0以降では、&lt;a href=&quot;single-file-components&quot;&gt;単一ファイルコンポーネント&lt;/a&gt;を使用している場合、テンプレートベースの機能コンポーネントを次のように宣言できます。</target>
        </trans-unit>
        <trans-unit id="98c67c0761e7da9c00c57d35a0738163cb924a2e" translate="yes" xml:space="preserve">
          <source>In 2.6+, &lt;code&gt;v-for&lt;/code&gt; can also work on values that implement the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol&quot;&gt;Iterable Protocol&lt;/a&gt;, including native &lt;code&gt;Map&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt;. However, it should be noted that Vue 2.x currently does not support reactivity on &lt;code&gt;Map&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt; values, so cannot automatically detect changes.</source>
          <target state="translated">2.6以降では、 &lt;code&gt;v-for&lt;/code&gt; は、ネイティブの &lt;code&gt;Map&lt;/code&gt; や &lt;code&gt;Set&lt;/code&gt; など、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol&quot;&gt;Iterable Protocol&lt;/a&gt;を実装する値でも機能します。ただし、Vue 2.xは現在 &lt;code&gt;Map&lt;/code&gt; および &lt;code&gt;Set&lt;/code&gt; 値の反応性をサポートしていないため、変更を自動的に検出できないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="5553d76d7cbc80714e9fa7174eeef5474643a592" translate="yes" xml:space="preserve">
          <source>In 2.6.0+, this hook also captures errors thrown inside &lt;code&gt;v-on&lt;/code&gt; DOM listeners. In addition, if any of the covered hooks or handlers returns a Promise chain (e.g. async functions), the error from that Promise chain will also be handled.</source>
          <target state="translated">2.6.0以降では、このフックは &lt;code&gt;v-on&lt;/code&gt; DOMリスナー内でスローされたエラーもキャプチャします。さらに、対象のフックまたはハンドラーのいずれかがPromiseチェーン（非同期関数など）を返す場合、そのPromiseチェーンからのエラーも処理されます。</target>
        </trans-unit>
        <trans-unit id="5b65e8c99e14e1d3d5fad411cf67fa65a409639e" translate="yes" xml:space="preserve">
          <source>In 2.6.0, we introduced a new unified syntax (the &lt;code&gt;v-slot&lt;/code&gt; directive) for named and scoped slots. It replaces the &lt;code&gt;slot&lt;/code&gt; and &lt;code&gt;slot-scope&lt;/code&gt; attributes, which are now deprecated, but have &lt;em&gt;not&lt;/em&gt; been removed and are still documented &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;here&lt;/a&gt;. The rationale for introducing the new syntax is described in this &lt;a href=&quot;https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md&quot;&gt;RFC&lt;/a&gt;.</source>
          <target state="translated">2.6.0では、名前付きスロットとスコープスロットに新しい統合構文（ &lt;code&gt;v-slot&lt;/code&gt; ディレクティブ）を導入しました。これは、現在は廃止されているが削除されて&lt;em&gt;おらず&lt;/em&gt;、&lt;a href=&quot;#Deprecated-Syntax&quot;&gt;ここで&lt;/a&gt;説明されている、 &lt;code&gt;slot&lt;/code&gt; および &lt;code&gt;slot-scope&lt;/code&gt; 属性に代わるものです。新しい構文を導入する根拠は、この&lt;a href=&quot;https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md&quot;&gt;RFCで&lt;/a&gt;説明されています。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="256728aff9fb16c0f4d2df842f2c3e5ad55c5e9b" translate="yes" xml:space="preserve">
          <source>In 2.x, &lt;code&gt;domProps&lt;/code&gt; contained a nested list within the VNode props:</source>
          <target state="translated">2.xでは、 &lt;code&gt;domProps&lt;/code&gt; はVNodeprops内にネストされたリストを含んでいました。</target>
        </trans-unit>
        <trans-unit id="d6ccc8617c6c0b63bdc2bf15b8a89fb2407da706" translate="yes" xml:space="preserve">
          <source>In 2.x, Vue instance could be used to trigger handlers attached imperatively via the event emitter API (&lt;code&gt;$on&lt;/code&gt;, &lt;code&gt;$off&lt;/code&gt; and &lt;code&gt;$once&lt;/code&gt;). This was used to create &lt;em&gt;event hubs&lt;/em&gt; to create global event listeners used across the whole application:</source>
          <target state="translated">2.xでは、Vueインスタンスを使用して、イベントエミッターAPI（ &lt;code&gt;$on&lt;/code&gt; 、 &lt;code&gt;$off&lt;/code&gt; 、および &lt;code&gt;$once&lt;/code&gt; ）を介して命令的にアタッチされたハンドラーをトリガーできました。これは、アプリケーション全体で使用されるグローバルイベントリスナーを作成するための&lt;em&gt;イベントハブ&lt;/em&gt;を作成するために使用されました。</target>
        </trans-unit>
        <trans-unit id="17dd1fdaef79b3831922864fd8d39f0ad9deb676" translate="yes" xml:space="preserve">
          <source>In 2.x, Vue provided the &lt;code&gt;inline-template&lt;/code&gt; attribute on child components to use its inner content as its template instead of treating it as distributed content.</source>
          <target state="translated">2.xでは、Vueは子コンポーネントに &lt;code&gt;inline-template&lt;/code&gt; 属性を提供し、内部コンテンツを分散コンテンツとして扱うのではなく、テンプレートとして使用しました。</target>
        </trans-unit>
        <trans-unit id="9c2328f43db77fe0efd8f47e998984f47eac46ba" translate="yes" xml:space="preserve">
          <source>In 2.x, developers could access direct child components of the current instance with &lt;code&gt;this.$children&lt;/code&gt;:</source>
          <target state="translated">2.xでは、開発者は &lt;code&gt;this.$children&lt;/code&gt; ：を使用して現在のインスタンスの直接の子コンポーネントにアクセスできました。</target>
        </trans-unit>
        <trans-unit id="ec9424ae231a6fda6ed873b7a8e6ae8e39088d9d" translate="yes" xml:space="preserve">
          <source>In 2.x, developers could define the &lt;code&gt;data&lt;/code&gt; option with either an &lt;code&gt;object&lt;/code&gt; or a &lt;code&gt;function&lt;/code&gt;.</source>
          <target state="translated">2.xでは、開発者は &lt;code&gt;object&lt;/code&gt; または &lt;code&gt;function&lt;/code&gt; いずれかを使用して &lt;code&gt;data&lt;/code&gt; オプションを定義できました。</target>
        </trans-unit>
        <trans-unit id="41dd71f6a7a373cd112dab134b7ff3db3d648f20" translate="yes" xml:space="preserve">
          <source>In 2.x, developers could use filters in order to apply common text formatting.</source>
          <target state="translated">2.xでは、開発者は一般的なテキストフォーマットを適用するためにフィルタを使用することができます。</target>
        </trans-unit>
        <trans-unit id="a7063d13de2f5ae058926813bdf953c4a105676c" translate="yes" xml:space="preserve">
          <source>In 2.x, if an element has both &lt;code&gt;v-bind=&quot;object&quot;&lt;/code&gt; and an identical individual property defined, the individual property would always overwrite bindings in the &lt;code&gt;object&lt;/code&gt;.</source>
          <target state="translated">2.xでは、要素に &lt;code&gt;v-bind=&quot;object&quot;&lt;/code&gt; と同一の個別プロパティの両方が定義されている場合、個別プロパティは常に &lt;code&gt;object&lt;/code&gt; バインディングを上書きします。</target>
        </trans-unit>
        <trans-unit id="eea559fa1a9771817cc8e8333085080656e09848" translate="yes" xml:space="preserve">
          <source>In 2.x, invalid values were coerced to &lt;code&gt;'true'&lt;/code&gt; for enumerated attributes. This was usually unintended and unlikely to be relied upon on a large scale. In 3.x &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;'true'&lt;/code&gt; should be explicitly specified.</source>
          <target state="translated">2.xでは、列挙された属性に対して無効な値が &lt;code&gt;'true'&lt;/code&gt; 強制変換されていました。これは通常意図せず、大規模に依存する可能性は低いです。3.xでは、 &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;'true'&lt;/code&gt; を明示的に指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="69daab13ee1934deef652bdaaf6f2e3de088df88" translate="yes" xml:space="preserve">
          <source>In 2.x, multi-root components were not supported and would emit a warning when a user accidentally created one. As a result, many components are wrapped in a single &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; in order to fix this error.</source>
          <target state="translated">2.xでは、マルチルートコンポーネントはサポートされておらず、ユーザーが誤って作成した場合に警告を発していました。その結果、このエラーを修正するために、多くのコンポーネントが単一の &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; にラップされます。</target>
        </trans-unit>
        <trans-unit id="afd9ee258c65347ba2ff8b78a2b85cee0fc8e414" translate="yes" xml:space="preserve">
          <source>In 2.x, the &lt;code&gt;render&lt;/code&gt; function automatically received arguments such as &lt;code&gt;h&lt;/code&gt;.</source>
          <target state="translated">2.xでは、 &lt;code&gt;render&lt;/code&gt; 関数は &lt;code&gt;h&lt;/code&gt; などの引数を自動的に受け取りました。</target>
        </trans-unit>
        <trans-unit id="788d01321951def977b78828f17cb248ccea9ad7" translate="yes" xml:space="preserve">
          <source>In 2.x, the &lt;code&gt;render&lt;/code&gt; function would automatically receive the &lt;code&gt;h&lt;/code&gt; function (which is a conventional alias for &lt;code&gt;createElement&lt;/code&gt;) as an argument:</source>
          <target state="translated">2.xでは、 &lt;code&gt;render&lt;/code&gt; 関数は引数として &lt;code&gt;h&lt;/code&gt; 関数（ &lt;code&gt;createElement&lt;/code&gt; の従来のエイリアス）を自動的に受け取ります。</target>
        </trans-unit>
        <trans-unit id="9729a27f715ad913ceb2a7d973c83313e4f3c50f" translate="yes" xml:space="preserve">
          <source>In 2.x, using a &lt;code&gt;v-model&lt;/code&gt; on a component was an equivalent of passing a &lt;code&gt;value&lt;/code&gt; prop and emitting an &lt;code&gt;input&lt;/code&gt; event:</source>
          <target state="translated">2.xでは、コンポーネントで &lt;code&gt;v-model&lt;/code&gt; を使用することは、 &lt;code&gt;value&lt;/code&gt; propを渡して &lt;code&gt;input&lt;/code&gt; イベントを発行することと同等でした。</target>
        </trans-unit>
        <trans-unit id="46afcbced92e335f7123d55a58b836b7295afd1d" translate="yes" xml:space="preserve">
          <source>In 2.x, we had the following strategies for coercing &lt;code&gt;v-bind&lt;/code&gt; values:</source>
          <target state="translated">2.xでは、 &lt;code&gt;v-bind&lt;/code&gt; 値を強制するために次の戦略がありました。</target>
        </trans-unit>
        <trans-unit id="dd5a25ed12428fc14990ccb2e9c191fa49adb981" translate="yes" xml:space="preserve">
          <source>In 2.x, when a component has been registered, the render function would work well when passing the component's name as a string to the first argument:</source>
          <target state="translated">2.xでは、コンポーネントが登録されている場合、最初の引数にコンポーネント名を文字列として渡すと、render関数がうまく動作するようになっていました。</target>
        </trans-unit>
        <trans-unit id="3fe8f6026316d3a73f1bd42ee8c89d43dee6ad5b" translate="yes" xml:space="preserve">
          <source>In 2.x, when using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; on the same element, &lt;code&gt;v-for&lt;/code&gt; would take precedence.</source>
          <target state="translated">2.xでは、同じ要素で &lt;code&gt;v-for&lt;/code&gt; &lt;code&gt;v-if&lt;/code&gt; と &lt;code&gt;v-for&lt;/code&gt; を使用すると、v-forが優先されます。</target>
        </trans-unit>
        <trans-unit id="fd2fe7a68d07b5928c0025bf237e90e00d49b1ff" translate="yes" xml:space="preserve">
          <source>In 3.0, the result will be:</source>
          <target state="translated">3.0では結果が出ます。</target>
        </trans-unit>
        <trans-unit id="2d272f52a84ee8fe9eda14c5af6c7e7e9aea55cf" translate="yes" xml:space="preserve">
          <source>In 3.0, we are limiting Vue's special treatment of the &lt;code&gt;is&lt;/code&gt; prop to the &lt;code&gt;&amp;lt;component&amp;gt;&lt;/code&gt; tag only.</source>
          <target state="translated">3.0では、私たちはのヴューの特別な処理を制限していること &lt;code&gt;is&lt;/code&gt; と小道具 &lt;code&gt;&amp;lt;component&amp;gt;&lt;/code&gt; タグのみ。</target>
        </trans-unit>
        <trans-unit id="f03706ae0b18cf04d0e1184566cc22dd43bd8796" translate="yes" xml:space="preserve">
          <source>In 3.x &lt;code&gt;v-model&lt;/code&gt; on the custom component is an equivalent of passing a &lt;code&gt;modelValue&lt;/code&gt; prop and emitting an &lt;code&gt;update:modelValue&lt;/code&gt; event:</source>
          <target state="translated">3.xでは、カスタムコンポーネントの &lt;code&gt;v-model&lt;/code&gt; は、 &lt;code&gt;modelValue&lt;/code&gt; プロップを渡して &lt;code&gt;update:modelValue&lt;/code&gt; イベントを発行するのと同じです。</target>
        </trans-unit>
        <trans-unit id="eaffa537c62e5c878c892ad624027bd74bf34114" translate="yes" xml:space="preserve">
          <source>In 3.x, &lt;code&gt;h&lt;/code&gt; is now globally imported instead of being automatically passed as an argument.</source>
          <target state="translated">3.xでは、 &lt;code&gt;h&lt;/code&gt; は引数として自動的に渡されるのではなく、グローバルにインポートされるようになりました。</target>
        </trans-unit>
        <trans-unit id="c1cbfb34fe6f9b877113b6bdc0dd73e927141d87" translate="yes" xml:space="preserve">
          <source>In 3.x, &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; should be used to explicitly remove an attribute.</source>
          <target state="translated">3.xでは、属性を明示的に削除するには、 &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="f2bef6847fad523068826498b632dcae11c29c52" translate="yes" xml:space="preserve">
          <source>In 3.x, &lt;code&gt;v-if&lt;/code&gt; will always have the higher precedence than &lt;code&gt;v-for&lt;/code&gt;.</source>
          <target state="translated">3.xでは、 &lt;code&gt;v-if&lt;/code&gt; は常に &lt;code&gt;v-for&lt;/code&gt; よりも優先されます。</target>
        </trans-unit>
        <trans-unit id="c0c1b7ac08bfa5b7cc8606dcd35f2331e4abc8e3" translate="yes" xml:space="preserve">
          <source>In 3.x, components now can have multiple root nodes! However, this does require developers to explicitly define where attributes should be distributed.</source>
          <target state="translated">3.xでは、コンポーネントは複数のルートノードを持つことができるようになりました。しかし、これは開発者が属性をどこに分散させるかを明示的に定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="2af3acd686b51e5d6705eac439e47596866c1ce8" translate="yes" xml:space="preserve">
          <source>In 3.x, filters are removed and no longer supported. Instead, we recommend replacing them with method calls or computed properties.</source>
          <target state="translated">3.xでは、フィルタは削除され、サポートされなくなりました。その代わりに、メソッド呼び出しや計算されたプロパティで置き換えることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="e53eba82a86ea2e9f0b2f6f6cfedb74733b2d04f" translate="yes" xml:space="preserve">
          <source>In 3.x, since the &lt;code&gt;render&lt;/code&gt; function no longer receives any arguments, it will primarily be used inside of the &lt;code&gt;setup()&lt;/code&gt; function. This has the added benefit of gaining access to reactive state and functions declared in scope, as well as the arguments passed to &lt;code&gt;setup()&lt;/code&gt;.</source>
          <target state="translated">3.xでは、 &lt;code&gt;render&lt;/code&gt; 関数は引数を受け取らなくなったため、主に &lt;code&gt;setup()&lt;/code&gt; 関数内で使用されます。これには、スコープで宣言されたリアクティブ状態と関数、および &lt;code&gt;setup()&lt;/code&gt; に渡される引数にアクセスできるという追加の利点があります。</target>
        </trans-unit>
        <trans-unit id="46410326ff00ce7f5b9a576648a6b047f922589a" translate="yes" xml:space="preserve">
          <source>In 3.x, slots are defined as children of the current node as an object:</source>
          <target state="translated">3.xでは、スロットは現在のノードの子としてオブジェクトとして定義されます。</target>
        </trans-unit>
        <trans-unit id="6a39c3c93b98afd50fbd7886344976a75f0114a1" translate="yes" xml:space="preserve">
          <source>In 3.x, the &lt;code&gt;$children&lt;/code&gt; property is removed and no longer supported. Instead, if you need to access a child component instance, we recommend using &lt;a href=&quot;../component-template-refs#template-refs&quot;&gt;$refs&lt;/a&gt;.</source>
          <target state="translated">3.xでは、 &lt;code&gt;$children&lt;/code&gt; プロパティが削除され、サポートされなくなりました。代わりに、子コンポーネントインスタンスにアクセスする必要がある場合は、&lt;a href=&quot;../component-template-refs#template-refs&quot;&gt;$ refs&lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="d4eb8d2b66bb84443ed0a747129452a3b8f78766" translate="yes" xml:space="preserve">
          <source>In 3.x, the &lt;code&gt;data&lt;/code&gt; option has been standardized to only accept a &lt;code&gt;function&lt;/code&gt; that returns an &lt;code&gt;object&lt;/code&gt;.</source>
          <target state="translated">3.xでは、 &lt;code&gt;data&lt;/code&gt; オプションは、 &lt;code&gt;object&lt;/code&gt; を返す &lt;code&gt;function&lt;/code&gt; のみを受け入れるように標準化されています。</target>
        </trans-unit>
        <trans-unit id="0577d8ad30ab5a25ec81d48069dddfe6636d8797" translate="yes" xml:space="preserve">
          <source>In 3.x, the entire VNode props structure is flattened. Using the example from above, here is what it would look like now.</source>
          <target state="translated">3.xでは、VNodeのプロップス構造全体がフラット化されています。上の例を使って、現在は以下のようになっています。</target>
        </trans-unit>
        <trans-unit id="8c698a95795682a639eda0b4dab592ffcd0ccbfd" translate="yes" xml:space="preserve">
          <source>In 3.x, the performance difference between stateful and functional components has been drastically reduced and will be insignificant in most use cases. As a result, the migration path for developers using &lt;code&gt;functional&lt;/code&gt; on SFCs is to remove the attribute and rename all references of &lt;code&gt;props&lt;/code&gt; to &lt;code&gt;$props&lt;/code&gt; and &lt;code&gt;attrs&lt;/code&gt; to &lt;code&gt;$attrs&lt;/code&gt;.</source>
          <target state="translated">3.xでは、ステートフルコンポーネントと機能コンポーネントのパフォーマンスの違いが大幅に減少し、ほとんどのユースケースで重要ではなくなりました。その結果、SFCで &lt;code&gt;functional&lt;/code&gt; を使用する開発者の移行パスは、属性を削除し、 &lt;code&gt;props&lt;/code&gt; のすべての参照の名前を &lt;code&gt;$props&lt;/code&gt; 、 &lt;code&gt;attrs&lt;/code&gt; を &lt;code&gt;$attrs&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="986b6c70c99847e99bd40a423d7f7e30f14d0d1e" translate="yes" xml:space="preserve">
          <source>In 3.x, with VNodes being context-free, we can no longer use a string ID to implicitly lookup registered components. Instead, we need to use an imported &lt;code&gt;resolveComponent&lt;/code&gt; method:</source>
          <target state="translated">3.xでは、VNodeが文脈自由であるため、文字列IDを使用して登録済みコンポーネントを暗黙的に検索することはできなくなりました。代わりに、インポートされた &lt;code&gt;resolveComponent&lt;/code&gt; メソッドを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="1649eb8974b30107ef48d872705e3f78ccfacc0f" translate="yes" xml:space="preserve">
          <source>In 3x, if an element has both &lt;code&gt;v-bind=&quot;object&quot;&lt;/code&gt; and an identical individual property defined, the order of how the bindings are declared determines how they are merged. In other words, rather than assuming developers want the individual property to always override what is defined in the &lt;code&gt;object&lt;/code&gt;, developers now have more control over the desired merging behavior.</source>
          <target state="translated">3xでは、要素に &lt;code&gt;v-bind=&quot;object&quot;&lt;/code&gt; と同一の個別プロパティの両方が定義されている場合、バインディングの宣言方法の順序によって、バインディングのマージ方法が決まります。言い換えると、開発者が個々のプロパティが &lt;code&gt;object&lt;/code&gt; で定義されているものを常にオーバーライドすることを望んでいると想定するのではなく、開発者は目的のマージ動作をより細かく制御できるようになりました。</target>
        </trans-unit>
        <trans-unit id="9feb4596eedd196dbf2408c8aca99b22823b66c2" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../guide/single-file-component&quot;&gt;single-file components&lt;/a&gt;, &lt;code&gt;scoped&lt;/code&gt; styles will not apply to content inside &lt;code&gt;v-html&lt;/code&gt;, because that HTML is not processed by Vue's template compiler. If you want to target &lt;code&gt;v-html&lt;/code&gt; content with scoped CSS, you can instead use &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS modules (opens new window)&lt;/a&gt; or an additional, global &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; element with a manual scoping strategy such as BEM.</source>
          <target state="translated">で&lt;a href=&quot;../guide/single-file-component&quot;&gt;単一ファイルのコンポーネント&lt;/a&gt;、 &lt;code&gt;scoped&lt;/code&gt; スタイルは、コンテンツ内部のには適用されません &lt;code&gt;v-html&lt;/code&gt; そのHTMLがVueののテンプレートコンパイラによって処理されていないため、。スコープ付きCSSで &lt;code&gt;v-html&lt;/code&gt; コンテンツをターゲットにする場合は、代わりに&lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSSモジュール（新しいウィンドウを開きます）&lt;/a&gt;またはBEMなどの手動スコープ戦略を使用した追加のグローバル &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 要素を使用できます。</target>
        </trans-unit>
        <trans-unit id="1efb26c55b50e56d58b23c52bfa3f35fba3a9ae3" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../guide/single-file-components&quot;&gt;single-file components&lt;/a&gt;, &lt;code&gt;scoped&lt;/code&gt; styles will not apply to content inside &lt;code&gt;v-html&lt;/code&gt;, because that HTML is not processed by Vue&amp;rsquo;s template compiler. If you want to target &lt;code&gt;v-html&lt;/code&gt; content with scoped CSS, you can instead use &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS modules&lt;/a&gt; or an additional, global &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; element with a manual scoping strategy such as BEM.</source>
          <target state="translated">で&lt;a href=&quot;../guide/single-file-components&quot;&gt;単一ファイルのコンポーネント&lt;/a&gt;、 &lt;code&gt;scoped&lt;/code&gt; スタイルは、コンテンツ内部のには適用されません &lt;code&gt;v-html&lt;/code&gt; そのHTMLがVueののテンプレートコンパイラによって処理されていないため、。スコープCSSを使用して &lt;code&gt;v-html&lt;/code&gt; コンテンツをターゲットにしたい場合は、代わりに、&lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSSモジュール&lt;/a&gt;またはBEMなどの手動スコープ戦略で追加のグローバル &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 要素を使用できます。</target>
        </trans-unit>
        <trans-unit id="0c8d376f7dee4247b96adc0876ef4edbaf45e20c" translate="yes" xml:space="preserve">
          <source>In JavaScript, PascalCase is the convention for classes and prototype constructors - essentially, anything that can have distinct instances. Vue components also have instances, so it makes sense to also use PascalCase. As an added benefit, using PascalCase within JSX (and templates) allows readers of the code to more easily distinguish between components and HTML elements.</source>
          <target state="translated">JavaScript では、PascalCase はクラスとプロトタイプ コンストラクタのための規約であり、基本的には、異なるインスタンスを持つことができるすべてのものを指します。Vue コンポーネントもインスタンスを持っているので、PascalCase を使用することは理にかなっています。さらに、JSX (およびテンプレート)内で PascalCase を使用することで、コードを読む人はコンポーネントと HTML 要素をより簡単に区別することができます。</target>
        </trans-unit>
        <trans-unit id="0e6aff66522249011aa1aa6c3f9299f8a6a28ad8" translate="yes" xml:space="preserve">
          <source>In JavaScript, splitting objects with multiple properties over multiple lines is widely considered a good convention, because it&amp;rsquo;s much easier to read. Our templates and &lt;a href=&quot;../guide/render-function#JSX&quot;&gt;JSX&lt;/a&gt; deserve the same consideration.</source>
          <target state="translated">JavaScriptでは、複数のプロパティを持つオブジェクトを複数行に分割することは、はるかに読みやすいため、適切な規則と広く見なされています。テンプレートと&lt;a href=&quot;../guide/render-function#JSX&quot;&gt;JSX&lt;/a&gt;も同じように検討する必要があります。</target>
        </trans-unit>
        <trans-unit id="c13d73a2ddf37e7463ec10f8ded7afc62e432e0e" translate="yes" xml:space="preserve">
          <source>In JavaScript, splitting objects with multiple properties over multiple lines is widely considered a good convention, because it's much easier to read. Our templates and &lt;a href=&quot;../guide/render-function#jsx&quot;&gt;JSX&lt;/a&gt; deserve the same consideration.</source>
          <target state="translated">JavaScriptでは、複数のプロパティを持つオブジェクトを複数の行に分割することは、読みやすいため、広く適切な規則と見なされています。テンプレートと&lt;a href=&quot;../guide/render-function#jsx&quot;&gt;JSX&lt;/a&gt;は同じ考慮に値します。</target>
        </trans-unit>
        <trans-unit id="d1511320f9fca1ecdb726d3628235620054c333a" translate="yes" xml:space="preserve">
          <source>In Object-based syntax, the value of each property can either be &lt;code&gt;null&lt;/code&gt; or a validator function. The validation function will receive the additional arguments passed to the &lt;code&gt;$emit&lt;/code&gt; call. For example, if &lt;code&gt;this.$emit('foo', 1)&lt;/code&gt; is called, the corresponding validator for &lt;code&gt;foo&lt;/code&gt; will receive the argument &lt;code&gt;1&lt;/code&gt;. The validator function should return a boolean to indicate whether the event arguments are valid.</source>
          <target state="translated">オブジェクトベースの構文では、各プロパティの値は &lt;code&gt;null&lt;/code&gt; またはバリデーター関数のいずれかになります。検証関数は、 &lt;code&gt;$emit&lt;/code&gt; 呼び出しに渡された追加の引数を受け取ります。たとえば、 &lt;code&gt;this.$emit('foo', 1)&lt;/code&gt; が呼び出された場合、対応する &lt;code&gt;foo&lt;/code&gt; のバリデーターは引数 &lt;code&gt;1&lt;/code&gt; を受け取ります。バリデーター関数は、イベント引数が有効かどうかを示すブール値を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="0e2913db7ffdacc418eed127754b210542e820db" translate="yes" xml:space="preserve">
          <source>In Polymer, the team has also made its data-binding system very limited in order to compensate for the performance. For example, the only expressions supported in Polymer templates are boolean negation and single method calls. Its computed property implementation is also not very flexible.</source>
          <target state="translated">また、Polymerでは、パフォーマンスを補うためにデータバインディングシステムを非常に限定したものにしています。例えば、Polymerのテンプレートでサポートされている式は、ブーリアン否定と単一メソッド呼び出しのみです。また、計算されたプロパティの実装も柔軟性に欠けています。</target>
        </trans-unit>
        <trans-unit id="b180ff4b776b13afecd7e06c14be26a036f40513" translate="yes" xml:space="preserve">
          <source>In React, all components express their UI within render functions using JSX, a declarative XML-like syntax that works within JavaScript.</source>
          <target state="translated">Reactでは、すべてのコンポーネントはJavaScript内で動作する宣言的なXMLのような構文であるJSXを使用して、レンダー関数内でUIを表現しています。</target>
        </trans-unit>
        <trans-unit id="0c74e086bdc4e1b0963bd8e65da5a6cf41a27ae4" translate="yes" xml:space="preserve">
          <source>In React, everything is just JavaScript. Not only are HTML structures expressed via JSX, the recent trends also tend to put CSS management inside JavaScript as well. This approach has its own benefits, but also comes with various trade-offs that may not seem worthwhile for every developer.</source>
          <target state="translated">Reactでは、すべてがJavaScriptになっています。HTMLの構造をJSXで表現するだけでなく、最近のトレンドではCSSの管理もJavaScriptの中に入れる傾向にあります。このアプローチにはそれなりのメリットがありますが、すべての開発者にとって価値があるとは思えない様々なトレードオフがあります。</target>
        </trans-unit>
        <trans-unit id="e01224b36d0e229721ad0a27e329111636e12ad4" translate="yes" xml:space="preserve">
          <source>In React, when a component&amp;rsquo;s state changes, it triggers the re-render of the entire component sub-tree, starting at that component as root. To avoid unnecessary re-renders of child components, you need to either use &lt;code&gt;PureComponent&lt;/code&gt; or implement &lt;code&gt;shouldComponentUpdate&lt;/code&gt; whenever you can. You may also need to use immutable data structures to make your state changes more optimization-friendly. However, in certain cases you may not be able to rely on such optimizations because &lt;code&gt;PureComponent/shouldComponentUpdate&lt;/code&gt; assumes the entire sub tree&amp;rsquo;s render output is determined by the props of the current component. If that is not the case, then such optimizations may lead to inconsistent DOM state.</source>
          <target state="translated">Reactでは、コンポーネントの状態が変化すると、コンポーネントのサブツリー全体の再レンダリングがトリガーされ、そのコンポーネントがルートとして開始されます。子コンポーネントの再描画不要を回避するには、いずれかの利用に必要 &lt;code&gt;PureComponent&lt;/code&gt; や実装 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; をいつでもすることができます。状態の変更をより最適化しやすくするために、不変のデータ構造を使用する必要がある場合もあります。ただし、場合によっては、 &lt;code&gt;PureComponent/shouldComponentUpdate&lt;/code&gt; がサブツリー全体のレンダリング出力が現在のコンポーネントのプロパティによって決定されると想定しているため、このような最適化に依存できない場合があります。そうでない場合は、そのような最適化によってDOM状態が不整合になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="2cfb65095765445c51ed3990754a7aea8c4e09af" translate="yes" xml:space="preserve">
          <source>In Vue 2 we recommended working around with these restrictions by using the &lt;code&gt;is&lt;/code&gt; prop on a native tag:</source>
          <target state="translated">Vue 2では、ネイティブタグで &lt;code&gt;is&lt;/code&gt; propを使用して、これらの制限を回避することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="84d17b0d924f04ce8ace3de17c7feceb2d55c631" translate="yes" xml:space="preserve">
          <source>In Vue 2, &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt;, like other custom components, needed a root element, which by default was a &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; but was customizable via the &lt;code&gt;tag&lt;/code&gt; prop.</source>
          <target state="translated">Vue 2では、他のカスタムコンポーネントと同様に、 &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; にはルート要素が必要でした。ルート要素はデフォルトで &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; でしたが、 &lt;code&gt;tag&lt;/code&gt; propを介してカスタマイズできました。</target>
        </trans-unit>
        <trans-unit id="3eee5e53bb1e22d2f1df0e9f8eff653441f88183" translate="yes" xml:space="preserve">
          <source>In Vue 2, &lt;code&gt;Vue.prototype&lt;/code&gt; was commonly used to add properties that would be accessible in all components.</source>
          <target state="translated">Vue 2では、 &lt;code&gt;Vue.prototype&lt;/code&gt; は通常、すべてのコンポーネントでアクセス可能なプロパティを追加するために使用されていました。</target>
        </trans-unit>
        <trans-unit id="623539054d5afbfeafa88a7593570669aa7a26b8" translate="yes" xml:space="preserve">
          <source>In Vue 2, &lt;code&gt;keyCodes&lt;/code&gt; were supported as a way to modify a &lt;code&gt;v-on&lt;/code&gt; method.</source>
          <target state="translated">Vue 2では、 &lt;code&gt;v-on&lt;/code&gt; メソッドを変更する方法として &lt;code&gt;keyCodes&lt;/code&gt; がサポートされていました。</target>
        </trans-unit>
        <trans-unit id="714deb450dd9f768ce9fb1850ea76c03a9c0b8ff" translate="yes" xml:space="preserve">
          <source>In Vue 2, custom directives were created by using the hooks listed below to target an element&amp;rsquo;s lifecycle, all of which are optional:</source>
          <target state="translated">Vue 2では、以下にリストされているフックを使用してカスタムディレクティブを作成し、要素のライフサイクルをターゲットにしました。これらはすべてオプションです。</target>
        </trans-unit>
        <trans-unit id="427f3cc45180bf04421bacb75902b51bf88d889a" translate="yes" xml:space="preserve">
          <source>In Vue 2, functional components had two primary use cases:</source>
          <target state="translated">Vue 2では、機能コンポーネントには2つの主要なユースケースがありました。</target>
        </trans-unit>
        <trans-unit id="4027dc7058f32b3afa9b989de298f0e1274c6387" translate="yes" xml:space="preserve">
          <source>In Vue 2, mixins were the primary tool to abstract parts of component logic into reusable chunks. However, they have a few issues:</source>
          <target state="translated">Vue 2では、コンポーネントロジックの一部を再利用可能なチャンクに抽象化するための主要なツールとして、ミックスインが使用されていました。しかし、これらにはいくつかの問題があります。</target>
        </trans-unit>
        <trans-unit id="e49b054972b109d8d92e090576574f314196d960" translate="yes" xml:space="preserve">
          <source>In Vue 2, the component instance had to be accessed through the &lt;code&gt;vnode&lt;/code&gt; argument:</source>
          <target state="translated">Vue 2では、コンポーネントインスタンスは &lt;code&gt;vnode&lt;/code&gt; 引数を介してアクセスする必要がありました。</target>
        </trans-unit>
        <trans-unit id="71cf60ceefe843452e7ace61c7f5d7fb5a10e2c5" translate="yes" xml:space="preserve">
          <source>In Vue 2, using the &lt;code&gt;ref&lt;/code&gt; attribute inside &lt;code&gt;v-for&lt;/code&gt; will populate the corresponding &lt;code&gt;$refs&lt;/code&gt; property with an array of refs. This behavior becomes ambiguous and inefficient when there are nested &lt;code&gt;v-for&lt;/code&gt;s present.</source>
          <target state="translated">Vue 2では、 &lt;code&gt;v-for&lt;/code&gt; 内で &lt;code&gt;ref&lt;/code&gt; 属性を使用すると、対応する &lt;code&gt;$refs&lt;/code&gt; プロパティにrefの配列が入力されます。ネストされた &lt;code&gt;v-for&lt;/code&gt; が存在する場合、この動作はあいまいで非効率的になります。</target>
        </trans-unit>
        <trans-unit id="88a36b69d1b9520442812684a11396300f78b7ba" translate="yes" xml:space="preserve">
          <source>In Vue 2, you can access attributes passed to your components with &lt;code&gt;this.$attrs&lt;/code&gt;, and event listeners with &lt;code&gt;this.$listeners&lt;/code&gt;. In combination with &lt;code&gt;inheritAttrs: false&lt;/code&gt;, they allow the developer to apply these attributes and listeners to some other element instead of the root element:</source>
          <target state="translated">Vue 2では、 &lt;code&gt;this.$attrs&lt;/code&gt; を使用してコンポーネントに渡された属性にアクセスし、this。$ listenersを使用し &lt;code&gt;this.$listeners&lt;/code&gt; イベントリスナーにアクセスできます。 &lt;code&gt;inheritAttrs: false&lt;/code&gt; と組み合わせると、開発者はこれらの属性とリスナーをルート要素ではなく他の要素に適用できます。</target>
        </trans-unit>
        <trans-unit id="a8d3795b44e395241dad3f754562828449a79603" translate="yes" xml:space="preserve">
          <source>In Vue 2, you can define the props that a component receives, but you can't declare which events it can emit:</source>
          <target state="translated">Vue 2 では、コンポーネントが受信するプロップを定義できますが、どのイベントを発行するかを宣言することはできません。</target>
        </trans-unit>
        <trans-unit id="850444a28d2f3a6b68ecd836b4765b12b999a6f4" translate="yes" xml:space="preserve">
          <source>In Vue 2.x, &lt;code&gt;Vue.observable&lt;/code&gt; directly mutates the object passed to it, so that it is equivalent to the object returned, as &lt;a href=&quot;../guide/instance#Data-and-Methods&quot;&gt;demonstrated here&lt;/a&gt;. In Vue 3.x, a reactive proxy will be returned instead, leaving the original object non-reactive if mutated directly. Therefore, for future compatibility, we recommend always working with the object returned by &lt;code&gt;Vue.observable&lt;/code&gt;, rather than the object originally passed to it.</source>
          <target state="translated">Vue 2.xでは、 &lt;code&gt;Vue.observable&lt;/code&gt; は渡されたオブジェクトを直接変更するため、&lt;a href=&quot;../guide/instance#Data-and-Methods&quot;&gt;ここに示され&lt;/a&gt;ているように、返されたオブジェクトと同等になります。Vue 3.xでは、代わりにリアクティブプロキシが返され、直接変更された場合、元のオブジェクトは非リアクティブのままになります。したがって、将来の互換性のために、最初に渡されたオブジェクトではなく、常に &lt;code&gt;Vue.observable&lt;/code&gt; によって返されたオブジェクトを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="04a1b8d86ca382e0241c1abe50e3ee3fb8996f94" translate="yes" xml:space="preserve">
          <source>In Vue 2.x, a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; tag could not have a &lt;code&gt;key&lt;/code&gt;. Instead, you could place the &lt;code&gt;key&lt;/code&gt;s on each of its children.</source>
          <target state="translated">Vue 2.xでは、 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; タグに &lt;code&gt;key&lt;/code&gt; 含めることができませんでした。代わりに、各子に &lt;code&gt;key&lt;/code&gt; を配置できます。</target>
        </trans-unit>
        <trans-unit id="17cb196394bb87ca2a8e06b2510d6358e84a7776" translate="yes" xml:space="preserve">
          <source>In Vue 2.x, application root container's &lt;code&gt;outerHTML&lt;/code&gt; is replaced with root component template (or eventually compiled to a template, if root component has no template/render option). Vue 3.x now uses application container's &lt;code&gt;innerHTML&lt;/code&gt; instead - this means the container itself is no longer considered part of the template.</source>
          <target state="translated">Vue 2.xでは、アプリケーションルートコンテナの &lt;code&gt;outerHTML&lt;/code&gt; がルートコンポーネントテンプレートに置き換えられます（または、ルートコンポーネントにテンプレート/レンダリングオプションがない場合は、最終的にテンプレートにコンパイルされます）。Vue 3.xは、代わりにアプリケーションコンテナの &lt;code&gt;innerHTML&lt;/code&gt; を使用するようになりました。これは、コンテナ自体がテンプレートの一部とは見なされなくなったことを意味します。</target>
        </trans-unit>
        <trans-unit id="f3ecd8d4cc17aab927b205f633e4d33dda883445" translate="yes" xml:space="preserve">
          <source>In Vue 2.x, it was recommended to use &lt;code&gt;key&lt;/code&gt;s on &lt;code&gt;v-if&lt;/code&gt;/&lt;code&gt;v-else&lt;/code&gt;/&lt;code&gt;v-else-if&lt;/code&gt; branches.</source>
          <target state="translated">Vueの2.xでは、それが使用することを推奨された &lt;code&gt;key&lt;/code&gt; にSを &lt;code&gt;v-if&lt;/code&gt; / &lt;code&gt;v-else&lt;/code&gt; / &lt;code&gt;v-else-if&lt;/code&gt; 分岐します。</target>
        </trans-unit>
        <trans-unit id="45d36ea70a8bf1cfdc715d58ac1911e3fd754fa1" translate="yes" xml:space="preserve">
          <source>In Vue 2.x, the resulting &lt;code&gt;$data&lt;/code&gt; is:</source>
          <target state="translated">Vue 2.xでは、結果の &lt;code&gt;$data&lt;/code&gt; は次のようになります。</target>
        </trans-unit>
        <trans-unit id="61abdd8d6816689fd4d5efd6b7f0f6d0421fa89e" translate="yes" xml:space="preserve">
          <source>In Vue 2.x, whitelisting tags as custom elements was done via &lt;code&gt;Vue.config.ignoredElements&lt;/code&gt;:</source>
          <target state="translated">Vue 2.xでは、カスタム要素としてのタグのホワイトリストは &lt;code&gt;Vue.config.ignoredElements&lt;/code&gt; を介して行われました。</target>
        </trans-unit>
        <trans-unit id="05a2d802b261d3390a36b39b1e88da6952ae1bfe" translate="yes" xml:space="preserve">
          <source>In Vue 3's virtual DOM, event listeners are now just attributes, prefixed with &lt;code&gt;on&lt;/code&gt;, and as such are part of the &lt;code&gt;$attrs&lt;/code&gt; object, so &lt;code&gt;$listeners&lt;/code&gt; has been removed.</source>
          <target state="translated">Vue 3の仮想DOMでは、イベントリスナーは単なる属性であり、接頭辞は &lt;code&gt;on&lt;/code&gt; であるため、 &lt;code&gt;$attrs&lt;/code&gt; オブジェクトの一部であるため、 &lt;code&gt;$listeners&lt;/code&gt; は削除されました。</target>
        </trans-unit>
        <trans-unit id="a2a8ffd46210564bab462dab866e0a61658c85fd" translate="yes" xml:space="preserve">
          <source>In Vue 3, APIs that globally mutate Vue's behavior are now moved to application instances created by the new &lt;code&gt;createApp&lt;/code&gt; method. In addition, their effects are now scoped to that specific application's instance:</source>
          <target state="translated">Vue 3では、Vueの動作をグローバルに変更するAPIが、新しい &lt;code&gt;createApp&lt;/code&gt; メソッドによって作成されたアプリケーションインスタンスに移動されるようになりました。さらに、それらの効果は、その特定のアプリケーションのインスタンスにスコープされます。</target>
        </trans-unit>
        <trans-unit id="724f98bfd4825d659b3ef73bec24c9d1b1bd8450" translate="yes" xml:space="preserve">
          <source>In Vue 3, components now have official support for multi-root node components, i.e., fragments!</source>
          <target state="translated">Vue 3 では、コンポーネントがマルチルートノードコンポーネント、つまりフラグメントを公式にサポートするようになりました。</target>
        </trans-unit>
        <trans-unit id="7f3d29f7ef97ea630c136e861259ef7779f3f469" translate="yes" xml:space="preserve">
          <source>In Vue 3, however, we&amp;rsquo;ve created a more cohesive API for custom directives. As you can see, they differ greatly from our component lifecycle methods even though we&amp;rsquo;re hooking into similar events. We&amp;rsquo;ve now unified them like so:</source>
          <target state="translated">ただし、Vue 3では、カスタムディレクティブ用のよりまとまりのあるAPIを作成しました。ご覧のとおり、同様のイベントにフックしているにもかかわらず、コンポーネントのライフサイクルメソッドとは大きく異なります。これで、次のように統合されました。</target>
        </trans-unit>
        <trans-unit id="b6331f262fcf12a91763745c6aeed71d9b733b3c" translate="yes" xml:space="preserve">
          <source>In Vue 3, such usage will no longer automatically create an array in &lt;code&gt;$refs&lt;/code&gt;. To retrieve multiple refs from a single binding, bind &lt;code&gt;ref&lt;/code&gt; to a function which provides more flexibility (this is a new feature):</source>
          <target state="translated">Vue 3では、このような使用法で &lt;code&gt;$refs&lt;/code&gt; 配列が自動的に作成されなくなりました。単一のバインディングから複数のrefを取得するには、 &lt;code&gt;ref&lt;/code&gt; をより柔軟性のある関数にバインドします（これは新機能です）。</target>
        </trans-unit>
        <trans-unit id="a5ecfbda9c9364a4d1cfde77270eb84b68591725" translate="yes" xml:space="preserve">
          <source>In Vue 3, the check of whether an element is a component or not has been moved to the template compilation phase, therefore this config option is only respected when using the runtime compiler. If you are using the runtime-only build, &lt;code&gt;isCustomElement&lt;/code&gt; must be passed to &lt;code&gt;@vue/compiler-dom&lt;/code&gt; in the build setup instead - for example, via the &lt;a href=&quot;https://vue-loader.vuejs.org/options.html#compileroptions&quot;&gt;&lt;code&gt;compilerOptions&lt;/code&gt; option in vue-loader (opens new window)&lt;/a&gt;.</source>
          <target state="translated">Vue 3では、要素がコンポーネントであるかどうかのチェックがテンプレートのコンパイルフェーズに移動されたため、この構成オプションはランタイムコンパイラを使用する場合にのみ尊重されます。ランタイムのみのビルドを使用している場合は、代わりにビルドセットアップで &lt;code&gt;isCustomElement&lt;/code&gt; を &lt;code&gt;@vue/compiler-dom&lt;/code&gt; に渡す必要があります-たとえば、&lt;a href=&quot;https://vue-loader.vuejs.org/options.html#compileroptions&quot;&gt;vue-loaderの&lt;/a&gt; &lt;code&gt;compilerOptions&lt;/code&gt; オプションを介して（新しいウィンドウを開きます）。</target>
        </trans-unit>
        <trans-unit id="40b845930e81b44f047a329d5c6204f7f931bd74" translate="yes" xml:space="preserve">
          <source>In Vue 3, the global and internal APIs have been restructured with tree-shaking support in mind. As a result, the global APIs can now only be accessed as named exports for the ES Modules build. For example, our previous snippets should now look like this:</source>
          <target state="translated">Vue 3 では、グローバル API と内部 API がツリーシェイクのサポートを念頭に置いて再構築されました。その結果、グローバル API は、ES モジュール ビルドの名前付きエクスポートとしてのみアクセスできるようになりました。たとえば、以前のスニペットは次のようになります。</target>
        </trans-unit>
        <trans-unit id="f24e9367bc712cd5e99e214445d49ec8f87dc977" translate="yes" xml:space="preserve">
          <source>In Vue 3, the instance is now part of the &lt;code&gt;binding&lt;/code&gt;:</source>
          <target state="translated">Vue 3では、インスタンスは &lt;code&gt;binding&lt;/code&gt; 一部になりました：</target>
        </trans-unit>
        <trans-unit id="73645e0f3791358bf3f0d6ad20122b90a31ffd47" translate="yes" xml:space="preserve">
          <source>In Vue 3, we have &lt;a href=&quot;fragments&quot;&gt;fragment support&lt;/a&gt;, so components no longer &lt;em&gt;need&lt;/em&gt; a root node. Consequently, &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; no longer renders one by default.</source>
          <target state="translated">Vue 3では&lt;a href=&quot;fragments&quot;&gt;フラグメントがサポートされているため&lt;/a&gt;、コンポーネントにルートノードは&lt;em&gt;必要あり&lt;/em&gt;ません。その結果、 &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; はデフォルトでレンダリングしなくなりました。</target>
        </trans-unit>
        <trans-unit id="0e7bdcdf994f4cc1a00dd74f8f22ad2f859a405b" translate="yes" xml:space="preserve">
          <source>In Vue 3, you&amp;rsquo;ll have to import it explicitly:</source>
          <target state="translated">Vue 3では、明示的にインポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="9d2bc8b0bef1be017e069553012e806d6ad3eeb6" translate="yes" xml:space="preserve">
          <source>In Vue 3.0 we can make any variable reactive anywhere with a new &lt;code&gt;ref&lt;/code&gt; function, like this:</source>
          <target state="translated">Vue 3.0では、次のような新しい &lt;code&gt;ref&lt;/code&gt; 関数を使用して、任意の変数をどこでもリアクティブにすることができます。</target>
        </trans-unit>
        <trans-unit id="1261249a8779a24fb5636b8856b66bfb7e4d50aa" translate="yes" xml:space="preserve">
          <source>In Vue 3.x, the &quot;use production build&quot; tip will only show up when using the &quot;dev + full build&quot; (the build that includes the runtime compiler and has warnings).</source>
          <target state="translated">Vue 3.xでは、&quot;use production build &quot;のヒントは、&quot;dev+full build&quot; (ランタイムコンパイラを含むビルドで、警告があるビルド)を使用している場合にのみ表示されます。</target>
        </trans-unit>
        <trans-unit id="bf9927c60d35977a34e50e99413e889e84532170" translate="yes" xml:space="preserve">
          <source>In Vue 3.x, the &lt;code&gt;key&lt;/code&gt; should be placed on the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; tag instead.</source>
          <target state="translated">Vue 3.xでは、代わりに &lt;code&gt;key&lt;/code&gt; を &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; タグに配置する必要があります。</target>
        </trans-unit>
        <trans-unit id="9ed32cf518158ed818bb81f6b262961d6f11529c" translate="yes" xml:space="preserve">
          <source>In Vue, a component is essentially a Vue instance with pre-defined options. Registering a component in Vue is straightforward:</source>
          <target state="translated">Vue では、コンポーネントは基本的に、あらかじめ定義されたオプションを持つ Vue インスタンスです。Vue にコンポーネントを登録するのは簡単です。</target>
        </trans-unit>
        <trans-unit id="9c55128700791de0665f1315237d38efdb9e6612" translate="yes" xml:space="preserve">
          <source>In Vue, a component is essentially an instance with pre-defined options. Registering a component in Vue is straightforward: we create a component object as we did with &lt;code&gt;App&lt;/code&gt; objects and we define it in parent's &lt;code&gt;components&lt;/code&gt; option:</source>
          <target state="translated">Vueでは、コンポーネントは基本的に事前定義されたオプションを持つインスタンスです。Vueへのコンポーネントの登録は簡単です &lt;code&gt;App&lt;/code&gt; オブジェクトの場合と同じようにコンポーネントオブジェクトを作成し、親の &lt;code&gt;components&lt;/code&gt; オプションで定義します。</target>
        </trans-unit>
        <trans-unit id="640123531948ef3b9eb7980eb088b64ca536081b" translate="yes" xml:space="preserve">
          <source>In Vue, a component&amp;rsquo;s dependencies are automatically tracked during its render, so the system knows precisely which components actually need to re-render when state changes. Each component can be considered to have &lt;code&gt;shouldComponentUpdate&lt;/code&gt; automatically implemented for you, without the nested component caveats.</source>
          <target state="translated">Vueでは、コンポーネントの依存関係はそのレンダリング中に自動的に追跡されるため、システムは、状態が変化したときに実際にどのコンポーネントを再レンダリングする必要があるかを正確に把握しています。各コンポーネントは、ネストされたコンポーネントの警告なしに、 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; が自動的に実装されていると見なすことができます。</target>
        </trans-unit>
        <trans-unit id="18335155b76d4fad8194e8bdec133a87f6304254" translate="yes" xml:space="preserve">
          <source>In Vue, we also have &lt;a href=&quot;render-function&quot;&gt;render functions&lt;/a&gt; and even &lt;a href=&quot;render-function#JSX&quot;&gt;support JSX&lt;/a&gt;, because sometimes you do need that power. However, as the default experience we offer templates as a simpler alternative. Any valid HTML is also a valid Vue template, and this leads to a few advantages of its own:</source>
          <target state="translated">Vueでは、&lt;a href=&quot;render-function&quot;&gt;レンダリング機能が&lt;/a&gt;あり、&lt;a href=&quot;render-function#JSX&quot;&gt;JSX&lt;/a&gt;もサポートされています。これは、その機能が必要になる場合があるためです。ただし、デフォルトのエクスペリエンスとして、より簡単な代替手段としてテンプレートを提供しています。有効なHTMLはすべて有効なVueテンプレートでもあり、これには独自のいくつかの利点があります。</target>
        </trans-unit>
        <trans-unit id="030d10ad2ba05486f4deb446ef11d5e04ed0a4f7" translate="yes" xml:space="preserve">
          <source>In Webpack 4+, you can use the &lt;code&gt;mode&lt;/code&gt; option:</source>
          <target state="translated">Webpack 4+では、 &lt;code&gt;mode&lt;/code&gt; オプションを使用できます。</target>
        </trans-unit>
        <trans-unit id="d4f0bbfd3f2e8bb6462aabfac3883c560be6e8a5" translate="yes" xml:space="preserve">
          <source>In a large application, it is necessary to divide the whole app into components to make development manageable. We will talk a lot more about components &lt;a href=&quot;guide/component-basics&quot;&gt;later in the guide&lt;/a&gt;, but here's an (imaginary) example of what an app's template might look like with components:</source>
          <target state="translated">大規模なアプリケーションでは、開発を管理しやすくするために、アプリ全体をコンポーネントに分割する必要があります。この&lt;a href=&quot;guide/component-basics&quot;&gt;ガイドの後半で&lt;/a&gt;コンポーネントについて詳しく説明しますが、アプリのテンプレートがコンポーネントでどのように見えるかの（架空の）例を次に示します。</target>
        </trans-unit>
        <trans-unit id="316b5f68fcb7371b1ffc1163190a5aa5dbe2b1f0" translate="yes" xml:space="preserve">
          <source>In a large application, it is necessary to divide the whole app into components to make development manageable. We will talk a lot more about components &lt;a href=&quot;guide/components&quot;&gt;later in the guide&lt;/a&gt;, but here&amp;rsquo;s an (imaginary) example of what an app&amp;rsquo;s template might look like with components:</source>
          <target state="translated">大規模なアプリケーションでは、開発を管理しやすくするために、アプリケーション全体をコンポーネントに分割する必要があります。この&lt;a href=&quot;guide/components&quot;&gt;ガイドの後半で&lt;/a&gt;コンポーネントについて詳しく説明しますが、コンポーネントを使用したアプリのテンプレートの外観の（架空の）例を次に示します。</target>
        </trans-unit>
        <trans-unit id="cce007380584fe599b155e880cbf38a37b8c5865" translate="yes" xml:space="preserve">
          <source>In a template it can be useful to use a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; tag to hold a &lt;code&gt;v-if&lt;/code&gt; or &lt;code&gt;v-for&lt;/code&gt; directive. When migrating to a &lt;code&gt;render&lt;/code&gt; function, the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; tag is no longer required and can be discarded.</source>
          <target state="translated">テンプレートでは、 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; タグを使用して &lt;code&gt;v-if&lt;/code&gt; または &lt;code&gt;v-for&lt;/code&gt; ディレクティブを保持すると便利な場合があります。 &lt;code&gt;render&lt;/code&gt; 関数に移行する場合、 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; タグは不要になり、破棄できます。</target>
        </trans-unit>
        <trans-unit id="b9d1075c896ee6a04f422ac930836698aaea2b0a" translate="yes" xml:space="preserve">
          <source>In a typical app, however, you&amp;rsquo;ll likely have an array of posts in &lt;code&gt;data&lt;/code&gt;:</source>
          <target state="translated">ただし、一般的なアプリでは、 &lt;code&gt;data&lt;/code&gt; 一連の投稿がある可能性があります。</target>
        </trans-unit>
        <trans-unit id="1f0341aaa53b971cc7f7cd6eab8ea717e277b0a1" translate="yes" xml:space="preserve">
          <source>In a typical app, however, you'll likely have an array of posts in &lt;code&gt;data&lt;/code&gt;:</source>
          <target state="translated">ただし、一般的なアプリでは、 &lt;code&gt;data&lt;/code&gt; 一連の投稿がある可能性があります。</target>
        </trans-unit>
        <trans-unit id="86d8dde57e2c8045db642f017abe87ff72fbc20c" translate="yes" xml:space="preserve">
          <source>In addition to 2.x hard-coded &lt;code&gt;v-model&lt;/code&gt; modifiers like &lt;code&gt;.trim&lt;/code&gt;, now 3.x supports custom modifiers:</source>
          <target state="translated">&lt;code&gt;.trim&lt;/code&gt; などの2.xハードコードされた &lt;code&gt;v-model&lt;/code&gt; 修飾子に加えて、3.xはカスタム修飾子をサポートするようになりました。</target>
        </trans-unit>
        <trans-unit id="4f4e2e50a87f6ed41c151d22eff006d5759a7c9c" translate="yes" xml:space="preserve">
          <source>In addition to data properties, Vue instances expose a number of useful instance properties and methods. These are prefixed with &lt;code&gt;$&lt;/code&gt; to differentiate them from user-defined properties. For example:</source>
          <target state="translated">データプロパティに加えて、Vueインスタンスは多くの便利なインスタンスプロパティとメソッドを公開します。これらは、ユーザー定義のプロパティと区別するために &lt;code&gt;$&lt;/code&gt; が前に付けられます。例えば：</target>
        </trans-unit>
        <trans-unit id="30b7afc0333bb298c35216e487d1e9e77e4192ca" translate="yes" xml:space="preserve">
          <source>In addition to public APIs, many of the internal components/helpers are now exported as named exports as well. This allows the compiler to output code that only imports features when they are used. For example the following template:</source>
          <target state="translated">公開APIに加えて、内部コンポーネント/ヘルパーの多くが名前付きエクスポートとしてエクスポートされるようになりました。これにより、コンパイラは機能が使用されたときだけインポートするコードを出力できるようになりました。例えば、以下のようなテンプレートです。</target>
        </trans-unit>
        <trans-unit id="80219b5bbf693b189078749f367546bbbcf16aa2" translate="yes" xml:space="preserve">
          <source>In addition to text interpolation, we can also bind element attributes like this:</source>
          <target state="translated">テキスト補間以外にも、このように要素の属性をバインドすることもできます。</target>
        </trans-unit>
        <trans-unit id="a5994728cbddc196dcd0ef1858badc921029a1e1" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;watch&lt;/code&gt; option, you can also use the imperative &lt;a href=&quot;../api/index#vm-watch&quot;&gt;vm.$watch API&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;watch&lt;/code&gt; オプションに加えて、命令型の&lt;a href=&quot;../api/index#vm-watch&quot;&gt;vm。$ watch APIを&lt;/a&gt;使用することもできます。</target>
        </trans-unit>
        <trans-unit id="5150e3e352b277b1ba1aa7eeef457bb44d050905" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;watch&lt;/code&gt; option, you can also use the imperative &lt;a href=&quot;../api/instance-methods#watch&quot;&gt;vm.$watch API&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;watch&lt;/code&gt; オプションに加えて、命令型の&lt;a href=&quot;../api/instance-methods#watch&quot;&gt;vm。$ watchAPIを&lt;/a&gt;使用することもできます。</target>
        </trans-unit>
        <trans-unit id="3e32faab7e104e620749fb0ceef10880dd5beb4c" translate="yes" xml:space="preserve">
          <source>In addition to the default set of directives shipped in core (&lt;code&gt;v-model&lt;/code&gt; and &lt;code&gt;v-show&lt;/code&gt;), Vue also allows you to register your own custom directives. Note that in Vue 2.0, the primary form of code reuse and abstraction is components - however there may be cases where you need some low-level DOM access on plain elements, and this is where custom directives would still be useful. An example would be focusing on an input element, like this one:</source>
          <target state="translated">コア（ &lt;code&gt;v-model&lt;/code&gt; および &lt;code&gt;v-show&lt;/code&gt; ）に付属するデフォルトのディレクティブセットに加えて、Vueでは独自のカスタムディレクティブを登録することもできます。Vue 2.0では、コードの再利用と抽象化の主要な形式はコンポーネントです。ただし、プレーン要素で低レベルのDOMアクセスが必要な場合があり、カスタムディレクティブが役立つ場合もあります。たとえば、次のように入力要素に焦点を当てます。</target>
        </trans-unit>
        <trans-unit id="0565e3d1e3c82f3b31c0ab6ec47170e5dc305765" translate="yes" xml:space="preserve">
          <source>In addition to the default set of directives shipped in core (like &lt;code&gt;v-model&lt;/code&gt; or &lt;code&gt;v-show&lt;/code&gt;), Vue also allows you to register your own custom directives. Note that in Vue, the primary form of code reuse and abstraction is components - however, there may be cases where you need some low-level DOM access on plain elements, and this is where custom directives would still be useful. An example would be focusing on an input element, like this one:</source>
          <target state="translated">コアで出荷されるデフォルトのディレクティブセット（ &lt;code&gt;v-model&lt;/code&gt; や &lt;code&gt;v-show&lt;/code&gt; など）に加えて、Vueでは独自のカスタムディレクティブを登録することもできます。Vueでは、コードの再利用と抽象化の主な形式はコンポーネントであることに注意してください。ただし、プレーン要素で低レベルのDOMアクセスが必要な場合があり、カスタムディレクティブが引き続き役立つ場合があります。例として、次のような入力要素に焦点を当てます。</target>
        </trans-unit>
        <trans-unit id="7d28a8c09a6baf609edfa9fc404ef67e9134cea0" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;type&lt;/code&gt; can also be a custom constructor function and the assertion will be made with an &lt;code&gt;instanceof&lt;/code&gt; check. For example, given the following constructor function exists:</source>
          <target state="translated">さらに、 &lt;code&gt;type&lt;/code&gt; はカスタムコンストラクター関数にすることもでき、アサーションは &lt;code&gt;instanceof&lt;/code&gt; チェックで作成されます。たとえば、次のコンストラクタ関数があるとします。</target>
        </trans-unit>
        <trans-unit id="a858e091d2bb7c6e47ea11f2b98a3648f57a8e3b" translate="yes" xml:space="preserve">
          <source>In addition, each instance/component can still own and manage its own private state:</source>
          <target state="translated">さらに、各インスタンス/コンポーネントは、まだ独自のプライベート状態を所有し、管理することができます。</target>
        </trans-unit>
        <trans-unit id="ee9ca0d32bcd7721be259373df69a9266664877b" translate="yes" xml:space="preserve">
          <source>In addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should &lt;strong&gt;not&lt;/strong&gt; attempt to mutate a prop inside a child component. If you do, Vue will warn you in the console.</source>
          <target state="translated">さらに、親コンポーネントが更新されるたびに、子コンポーネントのすべての小道具が最新の値で更新されます。つまり、子コンポーネント内のプロップを変更しようとし&lt;strong&gt;ないで&lt;/strong&gt;ください。その場合、Vueはコンソールで警告します。</target>
        </trans-unit>
        <trans-unit id="b81d142d3c922310cfbb8a89684dac0a487a2272" translate="yes" xml:space="preserve">
          <source>In addition, rather than implicitly provide &lt;code&gt;h&lt;/code&gt; in a &lt;code&gt;render&lt;/code&gt; function, &lt;code&gt;h&lt;/code&gt; is now imported globally.</source>
          <target state="translated">さらに、 &lt;code&gt;render&lt;/code&gt; 関数で暗黙的に &lt;code&gt;h&lt;/code&gt; を提供するのではなく、 &lt;code&gt;h&lt;/code&gt; がグローバルにインポートされるようになりました。</target>
        </trans-unit>
        <trans-unit id="85215d9d308bd40086a0e1662ab21ebbec8c5c6d" translate="yes" xml:space="preserve">
          <source>In addition, since the &lt;code&gt;createApp&lt;/code&gt; method returns the application instance itself, you can chain other methods after it which can be found in the following sections.</source>
          <target state="translated">さらに、 &lt;code&gt;createApp&lt;/code&gt; メソッドはアプリケーションインスタンス自体を返すため、次のセクションで説明するように、その後に他のメソッドをチェーンできます。</target>
        </trans-unit>
        <trans-unit id="65713f74baf60786834c58f72d45052056f1fa2d" translate="yes" xml:space="preserve">
          <source>In addition, unlike 2.x, the loader function no longer receives the &lt;code&gt;resolve&lt;/code&gt; and &lt;code&gt;reject&lt;/code&gt; arguments and must always return a Promise.</source>
          <target state="translated">また、2.xのとは異なり、ローダ機能はもはや受けない &lt;code&gt;resolve&lt;/code&gt; し、 &lt;code&gt;reject&lt;/code&gt; の引数を、常に約束を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="21451e63b33f7fd3f9f0613a2eed3c9fd082315c" translate="yes" xml:space="preserve">
          <source>In addition, when &lt;code&gt;data()&lt;/code&gt; from a component and its mixins or extends base are merged, the merge is now performed &lt;em&gt;shallowly&lt;/em&gt;:</source>
          <target state="translated">さらに、コンポーネントとそのミックスインまたは拡張ベースからの &lt;code&gt;data()&lt;/code&gt; がマージされると、マージは&lt;em&gt;浅く&lt;/em&gt;実行されるようになりました。</target>
        </trans-unit>
        <trans-unit id="3636deb3b0c4953ecaa1f52798bd8dc37c3b5533" translate="yes" xml:space="preserve">
          <source>In addition, when referencing scoped slots, they could be referenced using the following syntax:</source>
          <target state="translated">さらに、スコープ付きスロットを参照する場合は、以下の構文を使用して参照することができます。</target>
        </trans-unit>
        <trans-unit id="5985a88954adf2a60500ab64ac8c41d6f599d628" translate="yes" xml:space="preserve">
          <source>In addition, you could define your own aliases via the global &lt;code&gt;config.keyCodes&lt;/code&gt; option.</source>
          <target state="translated">さらに、グローバル &lt;code&gt;config.keyCodes&lt;/code&gt; オプションを使用して独自のエイリアスを定義できます。</target>
        </trans-unit>
        <trans-unit id="2dbcc3158e141581bb6b942a272d46856d1b275a" translate="yes" xml:space="preserve">
          <source>In case you haven&amp;rsquo;t noticed yet, Vue performs DOM updates &lt;strong&gt;asynchronously&lt;/strong&gt;. Whenever a data change is observed, it will open a queue and buffer all the data changes that happen in the same event loop. If the same watcher is triggered multiple times, it will be pushed into the queue only once. This buffered de-duplication is important in avoiding unnecessary calculations and DOM manipulations. Then, in the next event loop &amp;ldquo;tick&amp;rdquo;, Vue flushes the queue and performs the actual (already de-duped) work. Internally Vue tries native &lt;code&gt;Promise.then&lt;/code&gt;, &lt;code&gt;MutationObserver&lt;/code&gt;, and &lt;code&gt;setImmediate&lt;/code&gt; for the asynchronous queuing and falls back to &lt;code&gt;setTimeout(fn, 0)&lt;/code&gt;.</source>
          <target state="translated">まだ気付いていない場合のために、VueはDOM更新を&lt;strong&gt;非同期で&lt;/strong&gt;実行し&lt;strong&gt;ます&lt;/strong&gt;。データの変更が確認されると、キューが開き、同じイベントループで発生するすべてのデータ変更がバッファリングされます。同じウォッチャーが複数回トリガーされた場合、キューに1回だけプッシュされます。このバッファーされた重複除外は、不要な計算やDOM操作を回避する上で重要です。次に、次のイベントループ「ティック」で、Vueはキューをフラッシュし、実際の（すでに重複除外されている）作業を実行します。内部的には、Vue は非同期のキューイングに対してネイティブの &lt;code&gt;Promise.then&lt;/code&gt; 、 &lt;code&gt;MutationObserver&lt;/code&gt; 、および &lt;code&gt;setImmediate&lt;/code&gt; を試行し、 &lt;code&gt;setTimeout(fn, 0)&lt;/code&gt; フォールバックします。</target>
        </trans-unit>
        <trans-unit id="613464b2036a68a6ebb2b0e396760bb7f079d24b" translate="yes" xml:space="preserve">
          <source>In case you haven't noticed yet, Vue performs DOM updates &lt;strong&gt;asynchronously&lt;/strong&gt;. Whenever a data change is observed, it will open a queue and buffer all the data changes that happen in the same event loop. If the same watcher is triggered multiple times, it will be pushed into the queue only once. This buffered de-duplication is important in avoiding unnecessary calculations and DOM manipulations. Then, in the next event loop &quot;tick&quot;, Vue flushes the queue and performs the actual (already de-duped) work. Internally Vue tries native &lt;code&gt;Promise.then&lt;/code&gt;, &lt;code&gt;MutationObserver&lt;/code&gt;, and &lt;code&gt;setImmediate&lt;/code&gt; for the asynchronous queuing and falls back to &lt;code&gt;setTimeout(fn, 0)&lt;/code&gt;.</source>
          <target state="translated">まだ気付いていない場合は、VueはDOMの更新を&lt;strong&gt;非同期で&lt;/strong&gt;実行し&lt;strong&gt;ます&lt;/strong&gt;。データの変更が観察されるたびに、キューが開かれ、同じイベントループで発生するすべてのデータの変更がバッファリングされます。同じウォッチャーが複数回トリガーされた場合、キューにプッシュされるのは1回だけです。このバッファリングされた重複排除は、不要な計算やDOM操作を回避する上で重要です。次に、次のイベントループ「tick」で、Vueはキューをフラッシュし、実際の（すでに重複排除された）作業を実行します。内部的に、Vueは非同期キューイングに対してネイティブの &lt;code&gt;Promise.then&lt;/code&gt; 、 &lt;code&gt;MutationObserver&lt;/code&gt; 、および &lt;code&gt;setImmediate&lt;/code&gt; を試行し、 &lt;code&gt;setTimeout(fn, 0)&lt;/code&gt; フォールバックします。</target>
        </trans-unit>
        <trans-unit id="e8cd65af0c1ac7f1a471b3ebe14997d44c5a24c9" translate="yes" xml:space="preserve">
          <source>In case you prefer setting up your own build setup from scratch, you will need to manually configure webpack with &lt;a href=&quot;https://vue-loader.vuejs.org&quot;&gt;vue-loader (opens new window)&lt;/a&gt;. To learn more about webpack itself, check out &lt;a href=&quot;https://webpack.js.org/configuration/&quot;&gt;their official docs (opens new window)&lt;/a&gt; and &lt;a href=&quot;https://webpack.academy/p/the-core-concepts&quot;&gt;webpack learning academy (opens new window)&lt;/a&gt;.</source>
          <target state="translated">独自のビルドセットアップを最初からセットアップしたい場合は、&lt;a href=&quot;https://vue-loader.vuejs.org&quot;&gt;vue-loaderを&lt;/a&gt;使用してwebpackを手動で構成する必要があります（新しいウィンドウが開きます）。webpack自体の詳細については&lt;a href=&quot;https://webpack.js.org/configuration/&quot;&gt;、公式ドキュメント（新しいウィンドウを開く）&lt;/a&gt;と&lt;a href=&quot;https://webpack.academy/p/the-core-concepts&quot;&gt;webpackラーニングアカデミー（新しいウィンドウを開く&lt;/a&gt;）を確認してください。</target>
        </trans-unit>
        <trans-unit id="aaebcaa832cc872ee62580c8ab1928e2e9c98159" translate="yes" xml:space="preserve">
          <source>In case you prefer setting up your own build setup from scratch, you will need to manually configure webpack with &lt;a href=&quot;https://vue-loader.vuejs.org&quot;&gt;vue-loader&lt;/a&gt;. To learn more about webpack itself, check out &lt;a href=&quot;https://webpack.js.org/configuration/&quot;&gt;their official docs&lt;/a&gt; and &lt;a href=&quot;https://webpack.academy/p/the-core-concepts&quot;&gt;Webpack Academy&lt;/a&gt;.</source>
          <target state="translated">独自のビルドセットアップを最初からセットアップする場合は、&lt;a href=&quot;https://vue-loader.vuejs.org&quot;&gt;vue-loaderを&lt;/a&gt;使用してwebpackを手動で構成する必要があります。Webpack自体の詳細については&lt;a href=&quot;https://webpack.js.org/configuration/&quot;&gt;、公式ドキュメント&lt;/a&gt;と&lt;a href=&quot;https://webpack.academy/p/the-core-concepts&quot;&gt;Webpack Academy&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="14c7c4ad32435f4b7855ae564fc2ea7c8c969cd8" translate="yes" xml:space="preserve">
          <source>In cases like above, when &lt;em&gt;only&lt;/em&gt; the default slot is provided content, the component&amp;rsquo;s tags can be used as the slot&amp;rsquo;s template. This allows us to use &lt;code&gt;v-slot&lt;/code&gt; directly on the component:</source>
          <target state="translated">上記のような場合、デフォルトのスロット&lt;em&gt;のみ&lt;/em&gt;がコンテンツを提供するとき、コンポーネントのタグをスロットのテンプレートとして使用できます。これにより、コンポーネントで &lt;code&gt;v-slot&lt;/code&gt; 直接使用できます。</target>
        </trans-unit>
        <trans-unit id="afdc559a28e8fc0df8af77b29c0a99f33040dfa0" translate="yes" xml:space="preserve">
          <source>In cases like above, when &lt;em&gt;only&lt;/em&gt; the default slot is provided content, the component's tags can be used as the slot's template. This allows us to use &lt;code&gt;v-slot&lt;/code&gt; directly on the component:</source>
          <target state="translated">上記のような場合、デフォルトのスロット&lt;em&gt;のみ&lt;/em&gt;にコンテンツが提供されると、コンポーネントのタグをスロットのテンプレートとして使用できます。これにより、コンポーネントで直接 &lt;code&gt;v-slot&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="4aa7f570dcb37787dd83b543d84d7b6f36311f16" translate="yes" xml:space="preserve">
          <source>In cases like this, we can mark components as &lt;code&gt;functional&lt;/code&gt;, which means that they&amp;rsquo;re stateless (no &lt;a href=&quot;../api/index#Options-Data&quot;&gt;reactive data&lt;/a&gt;) and instanceless (no &lt;code&gt;this&lt;/code&gt; context). A &lt;strong&gt;functional component&lt;/strong&gt; looks like this:</source>
          <target state="translated">このような場合、コンポーネントを &lt;code&gt;functional&lt;/code&gt; としてマークできます。つまり、コンポーネントはステートレス（&lt;a href=&quot;../api/index#Options-Data&quot;&gt;反応データなし&lt;/a&gt;）であり、インスタンスレス（ &lt;code&gt;this&lt;/code&gt; コンテキストなし）です。&lt;strong&gt;機能性成分&lt;/strong&gt;のようになります。</target>
        </trans-unit>
        <trans-unit id="fa13d1c0d73e56359fd93a07fd88a5c686b9d9da" translate="yes" xml:space="preserve">
          <source>In cases where a component is only used once, the debouncing can be applied directly within &lt;code&gt;methods&lt;/code&gt;:</source>
          <target state="translated">コンポーネントが1回だけ使用される場合、デバウンスは &lt;code&gt;methods&lt;/code&gt; 内で直接適用できます。</target>
        </trans-unit>
        <trans-unit id="3afbf4c975278f424bbb47c6b13d6c21a3be2dbb" translate="yes" xml:space="preserve">
          <source>In cases where a watcher effect needs to be re-run &lt;strong&gt;after&lt;/strong&gt; component updates (i.e. when working with &lt;a href=&quot;composition-api-template-refs#watching-template-refs&quot;&gt;Template Refs&lt;/a&gt;), we can pass an additional &lt;code&gt;options&lt;/code&gt; object with the &lt;code&gt;flush&lt;/code&gt; option (default is &lt;code&gt;'pre'&lt;/code&gt;):</source>
          <target state="translated">コンポーネントの更新&lt;strong&gt;後に&lt;/strong&gt;ウォッチャーエフェクトを再実行する必要がある場合（つまり、&lt;a href=&quot;composition-api-template-refs#watching-template-refs&quot;&gt;テンプレート参照を&lt;/a&gt;使用する場合）、 &lt;code&gt;flush&lt;/code&gt; オプションを &lt;code&gt;options&lt;/code&gt; て追加のオプションオブジェクトを渡すことができます（デフォルトは &lt;code&gt;'pre'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7115593cdb5e7c5bc03b8752b74312ce66ca58e0" translate="yes" xml:space="preserve">
          <source>In committed code, prop definitions should always be as detailed as possible, specifying at least type(s).</source>
          <target state="translated">コミットされたコードでは、prop の定義は常に可能な限り詳細に、少なくとも type(s)を指定しなければなりません。</target>
        </trans-unit>
        <trans-unit id="7bfd4fed8d270a9c14023eb29a927d5b4c0ecab4" translate="yes" xml:space="preserve">
          <source>In comparison, &lt;code&gt;v-show&lt;/code&gt; is much simpler - the element is always rendered regardless of initial condition, with CSS-based toggling.</source>
          <target state="translated">比較すると、 &lt;code&gt;v-show&lt;/code&gt; ははるかに単純です。要素は、CSSベースの切り替えにより、初期状態に関係なく常にレンダリングされます。</target>
        </trans-unit>
        <trans-unit id="d22711c22222a7cebea6f132a3ff7ea151c0f818" translate="yes" xml:space="preserve">
          <source>In comparison, a method invocation will &lt;strong&gt;always&lt;/strong&gt; run the function whenever a re-render happens.</source>
          <target state="translated">これに対して、メソッドの呼び出しでは、再レンダリングが発生するたびに関数が&lt;strong&gt;常に&lt;/strong&gt;実行されます。</target>
        </trans-unit>
        <trans-unit id="bb1736ea3b5962d2582e096afba361a049ac9d2c" translate="yes" xml:space="preserve">
          <source>In components that use &lt;code&gt;inheritAttrs: false&lt;/code&gt;, make sure that styling still works as intended. If you previously relied on the special behavior of &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;style&lt;/code&gt;, some visuals might be broken as these attributes might now be applied to another element.</source>
          <target state="translated">&lt;code&gt;inheritAttrs: false&lt;/code&gt; を使用するコンポーネントでは、スタイリングが意図したとおりに機能することを確認してください。以前に &lt;code&gt;class&lt;/code&gt; と &lt;code&gt;style&lt;/code&gt; 特別な動作に依存していた場合、これらの属性が別の要素に適用される可能性があるため、一部のビジュアルが壊れている可能性があります。</target>
        </trans-unit>
        <trans-unit id="07f3fad6ea47761ecb752634045422b5f91f5f10" translate="yes" xml:space="preserve">
          <source>In development, Vue will warn you if a component is ever provided incorrectly formatted props, helping you catch potential sources of error.</source>
          <target state="translated">開発中のVueは、コンポーネントが誤ったフォーマットの小道具を提供された場合に警告を発し、エラーの原因となる可能性のあるものを検出するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="9a8c437a03d6e7a0e6f5698507548a4d93c2d7fe" translate="yes" xml:space="preserve">
          <source>In every subcomponent of a &lt;code&gt;new Vue&lt;/code&gt; instance, this root instance can be accessed with the &lt;code&gt;$root&lt;/code&gt; property. For example, in this root instance:</source>
          <target state="translated">&lt;code&gt;new Vue&lt;/code&gt; インスタンスのすべてのサブコンポーネントでは、このルートインスタンスに &lt;code&gt;$root&lt;/code&gt; プロパティを使用してアクセスできます。たとえば、このルートインスタンスでは：</target>
        </trans-unit>
        <trans-unit id="097d80c1c9662de13d79de78efe60775b83d52ef" translate="yes" xml:space="preserve">
          <source>In fact, you can think of dependency injection as sort of &amp;ldquo;long-range props&amp;rdquo;, except:</source>
          <target state="translated">実際、依存関係の注入は、以下を除いて、一種の「長距離小道具」と考えることができます。</target>
        </trans-unit>
        <trans-unit id="7bc506457177d40f6c274f20bb75f39f6557a677" translate="yes" xml:space="preserve">
          <source>In general, whenever something can be achieved in plain JavaScript, we want to avoid introducing a special syntax like filters to take care of the same concern. Here&amp;rsquo;s how you can replace Vue&amp;rsquo;s built-in directive filters:</source>
          <target state="translated">一般的に、プレーンなJavaScriptで何かを達成できる場合は常に、フィルターのような特別な構文を導入して同じ問題に対処することは避けたいと考えています。Vueの組み込みディレクティブフィルターを置き換える方法を次に示します。</target>
        </trans-unit>
        <trans-unit id="ae9ee797c12050e7d3af19214520a26751de6044" translate="yes" xml:space="preserve">
          <source>In large applications, we may need to divide the app into smaller chunks and only load a component from the server when it&amp;rsquo;s needed. To make that easier, Vue allows you to define your component as a factory function that asynchronously resolves your component definition. Vue will only trigger the factory function when the component needs to be rendered and will cache the result for future re-renders. For example:</source>
          <target state="translated">大規模なアプリケーションでは、アプリを小さなチャンクに分割し、必要な場合にのみサーバーからコンポーネントをロードする必要がある場合があります。これを簡単にするために、Vueではコンポーネント定義を非同期的に解決するファクトリー関数としてコンポーネントを定義できます。Vueは、コンポーネントをレンダリングする必要がある場合にのみファクトリー関数をトリガーし、将来の再レンダリングのために結果をキャッシュします。例えば：</target>
        </trans-unit>
        <trans-unit id="0e1a8f47d0de2c3d5f962fb51601c60c71a4205c" translate="yes" xml:space="preserve">
          <source>In large applications, we may need to divide the app into smaller chunks and only load a component from the server when it's needed. To make that possible, Vue has a &lt;code&gt;defineAsyncComponent&lt;/code&gt; method:</source>
          <target state="translated">大規模なアプリケーションでは、アプリを小さなチャンクに分割し、必要な場合にのみサーバーからコンポーネントを読み込む必要がある場合があります。これを可能にするために、Vueには &lt;code&gt;defineAsyncComponent&lt;/code&gt; メソッドがあります。</target>
        </trans-unit>
        <trans-unit id="447ec0f63a19e47502450736e07a06c1647bfe27" translate="yes" xml:space="preserve">
          <source>In many Vue projects, global components will be defined using &lt;code&gt;Vue.component&lt;/code&gt;, followed by &lt;code&gt;new Vue({ el: '#container' })&lt;/code&gt; to target a container element in the body of every page.</source>
          <target state="translated">多くのVueプロジェクトでは、グローバルコンポーネントは &lt;code&gt;Vue.component&lt;/code&gt; を使用して定義され、その後に &lt;code&gt;new Vue({ el: '#container' })&lt;/code&gt; が続き、すべてのページの本文のコンテナー要素をターゲットにします。</target>
        </trans-unit>
        <trans-unit id="46c352f653c2ccd99c8d1eeb1bac3b46074aed40" translate="yes" xml:space="preserve">
          <source>In many Vue projects, global components will be defined using &lt;code&gt;app.component()&lt;/code&gt;, followed by &lt;code&gt;app.mount('#app')&lt;/code&gt; to target a container element in the body of every page.</source>
          <target state="translated">多くのVueプロジェクトでは、グローバルコンポーネントは &lt;code&gt;app.component()&lt;/code&gt; を使用して定義され、その後に &lt;code&gt;app.mount('#app')&lt;/code&gt; を使用して、すべてのページの本文のコンテナー要素をターゲットにします。</target>
        </trans-unit>
        <trans-unit id="53ccc949f90a192c185068356f4f8dd5029eb128" translate="yes" xml:space="preserve">
          <source>In many cases though, you&amp;rsquo;ll still run into strange behavior (e.g. &lt;code&gt;0.035.toFixed(2)&lt;/code&gt; rounds up to &lt;code&gt;0.04&lt;/code&gt;, but &lt;code&gt;0.045&lt;/code&gt; rounds down to &lt;code&gt;0.04&lt;/code&gt;). To work around these issues, you can use the &lt;a href=&quot;http://openexchangerates.github.io/accounting.js/&quot;&gt;&lt;code&gt;accounting&lt;/code&gt;&lt;/a&gt; library to more reliably format currencies.</source>
          <target state="translated">しかし多くの場合、あなたはまだ、奇妙な行動に実行されます（例えば &lt;code&gt;0.035.toFixed(2)&lt;/code&gt; に切り上げ &lt;code&gt;0.04&lt;/code&gt; が、 &lt;code&gt;0.045&lt;/code&gt; ラウンドにダウン &lt;code&gt;0.04&lt;/code&gt; ）。これらの問題を回避するには、&lt;a href=&quot;http://openexchangerates.github.io/accounting.js/&quot;&gt; &lt;code&gt;accounting&lt;/code&gt; &lt;/a&gt;ライブラリを使用して通貨をより確実にフォーマットできます。</target>
        </trans-unit>
        <trans-unit id="c390053bb2e4d5c93dcd01989be3871147f8ba8c" translate="yes" xml:space="preserve">
          <source>In many cases, you may want the same behavior on &lt;code&gt;bind&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt;, but don&amp;rsquo;t care about the other hooks. For example:</source>
          <target state="translated">多くの場合、 &lt;code&gt;bind&lt;/code&gt; と &lt;code&gt;update&lt;/code&gt; で同じ動作が必要になることがありますが、他のフックは気にしません。例えば：</target>
        </trans-unit>
        <trans-unit id="a111823d1c021115efbe8d836af1c2f184002aa1" translate="yes" xml:space="preserve">
          <source>In most cases, Vue can automatically figure out when the transition has finished. By default, Vue waits for the first &lt;code&gt;transitionend&lt;/code&gt; or &lt;code&gt;animationend&lt;/code&gt; event on the root transition element. However, this may not always be desired - for example, we may have a choreographed transition sequence where some nested inner elements have a delayed transition or a longer transition duration than the root transition element.</source>
          <target state="translated">ほとんどの場合、トランジションが終了すると、Vueは自動的に判断できます。デフォルトでは、Vue はルート遷移要素の最初の &lt;code&gt;transitionend&lt;/code&gt; または &lt;code&gt;animationend&lt;/code&gt; イベントを待ちます。ただし、これが常に望ましいとは限りません。たとえば、一部のネストされた内部要素の遷移が遅延したり、遷移期間がルート遷移要素よりも長い場合に、振付の遷移シーケンスがある場合があります。</target>
        </trans-unit>
        <trans-unit id="5bb963c73fa00775099a6347ea2baa7e2a3e2c72" translate="yes" xml:space="preserve">
          <source>In most cases, it&amp;rsquo;s best to avoid reaching into other component instances or manually manipulating DOM elements. There are cases, however, when it can be appropriate.</source>
          <target state="translated">ほとんどの場合、他のコンポーネントインスタンスに手を伸ばしたり、DOM要素を手動で操作したりすることは避けるのが最善です。ただし、適切な場合もあります。</target>
        </trans-unit>
        <trans-unit id="b6c86a77b0b04c3ca150f69dd5331a352786535a" translate="yes" xml:space="preserve">
          <source>In most cases, reaching into the parent makes your application more difficult to debug and understand, especially if you mutate data in the parent. When looking at that component later, it will be very difficult to figure out where that mutation came from.</source>
          <target state="translated">ほとんどの場合、親に手を伸ばすと、アプリケーションのデバッグや理解が難しくなります。後でそのコンポーネントを見たときに、その突然変異がどこから来たのかを理解するのは非常に難しいでしょう。</target>
        </trans-unit>
        <trans-unit id="d68b5e8d96b9910b923cbe675afd9e3c75b80ac2" translate="yes" xml:space="preserve">
          <source>In most cases, you should only use it for custom option handling like demonstrated in the example above. It's also a good idea to ship them as &lt;a href=&quot;plugins&quot;&gt;Plugins&lt;/a&gt; to avoid duplicate application.</source>
          <target state="translated">ほとんどの場合、上記の例で示したようなカスタムオプション処理にのみ使用する必要があります。アプリケーションの重複を避けるために、&lt;a href=&quot;plugins&quot;&gt;プラグイン&lt;/a&gt;として出荷することもお勧めします。</target>
        </trans-unit>
        <trans-unit id="419bd771510d306d9921bc5eb07cb10e9cc4094a" translate="yes" xml:space="preserve">
          <source>In natural English, adjectives and other descriptors do typically appear before the nouns, while exceptions require connector words. For example:</source>
          <target state="translated">自然英語では、形容詞やその他の記述子は通常名詞の前に現れますが、例外的に接続語が必要になります。例えば</target>
        </trans-unit>
        <trans-unit id="e5c5a11b792a6a6c3c9dbe85b25f28ab2feb0a79" translate="yes" xml:space="preserve">
          <source>In normal use cases you shouldn&amp;rsquo;t have to call this method yourself. Prefer controlling the lifecycle of child components in a data-driven fashion using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt;.</source>
          <target state="translated">通常の使用例では、このメソッドを自分で呼び出す必要はありません。 &lt;code&gt;v-if&lt;/code&gt; と &lt;code&gt;v-for&lt;/code&gt; を使用して、データ駆動の方法で子コ​​ンポーネントのライフサイクルを制御することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="9689e82d55bf91d0bdb0a6e4890e0cb8c481ba5f" translate="yes" xml:space="preserve">
          <source>In order to be more explicit and legible, we have now renamed these initial state classes:</source>
          <target state="translated">より明示的で読みやすいように、これらの初期状態クラスの名前を変更しました。</target>
        </trans-unit>
        <trans-unit id="7967705f3df6230388a8007a18675ebf06f8935f" translate="yes" xml:space="preserve">
          <source>In order to better understand how to create your own Vue.js plugins, we will create a very simplified version of a plugin that displays &lt;code&gt;i18n&lt;/code&gt; ready strings.</source>
          <target state="translated">独自のVue.jsプラグインを作成する方法をよりよく理解するために、 &lt;code&gt;i18n&lt;/code&gt; 対応の文字列を表示する非常に単純化されたバージョンのプラグインを作成します。</target>
        </trans-unit>
        <trans-unit id="d2f3b2527a93cc83ec0b5cf78ef1f46a48fed02f" translate="yes" xml:space="preserve">
          <source>In other cases, it returns a stop handle which can be called to explicitly stop the watcher:</source>
          <target state="translated">他のケースでは、ウォッチャーを明示的に停止させるために呼び出すことができるストップハンドルを返します。</target>
        </trans-unit>
        <trans-unit id="3930e2dc2ac43f310bce905c8d03f08738173196" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;ref&lt;/code&gt; creates a &lt;strong&gt;Reactive Reference&lt;/strong&gt; to our value. The concept of working with &lt;strong&gt;References&lt;/strong&gt; will be used often throughout the Composition API.</source>
          <target state="translated">言い換えると、 &lt;code&gt;ref&lt;/code&gt; は値への&lt;strong&gt;リアクティブ参照&lt;/strong&gt;を作成します。&lt;strong&gt;参照を操作&lt;/strong&gt;するという概念は、CompositionAPI全体で頻繁に使用されます。</target>
        </trans-unit>
        <trans-unit id="26030f8aadd2fe6b946e53d81af4d02ba1edcf5f" translate="yes" xml:space="preserve">
          <source>In other words, E2E tests validate all of the layers in your application. This not only includes your frontend code, but all associated backend services and infrastructure that are more representative of the environment that your users will be in. By testing how user actions impact your application, E2E tests are often the key to higher confidence in whether an application is functioning properly or not.</source>
          <target state="translated">言い換えれば、E2E テストは、アプリケーションのすべてのレイヤーを検証します。これには、フロントエンドコードだけでなく、関連するすべてのバックエンドサービスやインフラストラクチャが含まれ、ユーザーがいる環境をより代表するものとなります。ユーザーのアクションがアプリケーションにどのような影響を与えるかをテストすることで、E2E テストは、アプリケーションが適切に機能しているかどうかの信頼性を高める鍵となります。</target>
        </trans-unit>
        <trans-unit id="37b63ec681a094ed6d524d075cda699de0092770" translate="yes" xml:space="preserve">
          <source>In other words, you &lt;strong&gt;will not have access&lt;/strong&gt; to the following component options:</source>
          <target state="translated">つまり、次のコンポーネントオプションに&lt;strong&gt;アクセスでき&lt;/strong&gt;なくなります。</target>
        </trans-unit>
        <trans-unit id="4d273535df632e4e8ae9260566c4f2451d604b5c" translate="yes" xml:space="preserve">
          <source>In our case, let&amp;rsquo;s make that point the &lt;code&gt;tree-folder&lt;/code&gt; component. We know the child that creates the paradox is the &lt;code&gt;tree-folder-contents&lt;/code&gt; component, so we&amp;rsquo;ll wait until the &lt;code&gt;beforeCreate&lt;/code&gt; lifecycle hook to register it:</source>
          <target state="translated">私たちのケースでは、 &lt;code&gt;tree-folder&lt;/code&gt; コンポーネントを指すようにします。パラドックスを作成する子は &lt;code&gt;tree-folder-contents&lt;/code&gt; コンポーネントであることがわかっているため、 &lt;code&gt;beforeCreate&lt;/code&gt; ライフサイクルフックまで待機して登録します。</target>
        </trans-unit>
        <trans-unit id="8fc49bd00753f672db39f74244a5be9e57229d11" translate="yes" xml:space="preserve">
          <source>In our experience, it&amp;rsquo;s better to &lt;em&gt;always&lt;/em&gt; add a unique key, so that you and your team simply never have to worry about these edge cases. Then in the rare, performance-critical scenarios where object constancy isn&amp;rsquo;t necessary, you can make a conscious exception.</source>
          <target state="translated">私たちの経験では、&lt;em&gt;常に&lt;/em&gt;一意のキーを追加することをお勧めします。これにより、あなたとあなたのチームはこれらのエッジケースについて心配する必要がなくなります。次に、オブジェクトの恒常性が必要ない、パフォーマンスが重要なまれなシナリオで、意識的な例外を作成できます。</target>
        </trans-unit>
        <trans-unit id="78698544f2ebea81bf74621176fba4067b232946" translate="yes" xml:space="preserve">
          <source>In our experience, it's better to &lt;em&gt;always&lt;/em&gt; add a unique key, so that you and your team simply never have to worry about these edge cases. Then in the rare, performance-critical scenarios where object constancy isn't necessary, you can make a conscious exception.</source>
          <target state="translated">私たちの経験では、&lt;em&gt;常に&lt;/em&gt;一意のキーを追加することをお勧めします。そうすれば、あなたとあなたのチームはこれらのエッジケースについて心配する必要がなくなります。次に、オブジェクトの不変性が必要ない、まれでパフォーマンスが重要なシナリオでは、意識的な例外を作成できます。</target>
        </trans-unit>
        <trans-unit id="0aa9363da25541b78e6af0972c3f9bb895597ac0" translate="yes" xml:space="preserve">
          <source>In previous example, you may want the same behavior on &lt;code&gt;mounted&lt;/code&gt; and &lt;code&gt;updated&lt;/code&gt;, but don't care about the other hooks. You can do it by passing the callback to directive:</source>
          <target state="translated">前の例では、 &lt;code&gt;mounted&lt;/code&gt; および &lt;code&gt;updated&lt;/code&gt; 同じ動作が必要な場合がありますが、他のフックは気にしません。コールバックをディレクティブに渡すことでそれを行うことができます：</target>
        </trans-unit>
        <trans-unit id="a7da1d060c31fa0a41ee9f1ab266ae7cb095dc2c" translate="yes" xml:space="preserve">
          <source>In situations where computed properties are not feasible (e.g. inside nested &lt;code&gt;v-for&lt;/code&gt; loops), you can use a method:</source>
          <target state="translated">計算されたプロパティが実現できない状況（ネストされた &lt;code&gt;v-for&lt;/code&gt; ループ内など）では、次のメソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="0f3807437f4c73a9a48f84e425ea613aac544cc0" translate="yes" xml:space="preserve">
          <source>In some cases, we may need &amp;ldquo;two-way binding&amp;rdquo; for a prop. Unfortunately, true two-way binding can create maintenance issues, because child components can mutate the parent without the source of that mutation being obvious in both the parent and the child.</source>
          <target state="translated">場合によっては、小道具に「双方向バインディング」が必要になることがあります。残念ながら、真の双方向バインディングはメンテナンスの問題を引き起こす可能性があります。これは、子コンポーネントが、親と子の両方で変更のソースが明らかでない場合でも、親を変更できるためです。</target>
        </trans-unit>
        <trans-unit id="d3a61aecf34702fc3ac15dbd55af0193cd0d21b7" translate="yes" xml:space="preserve">
          <source>In some cases, we might need &quot;two-way binding&quot; for a prop (sometimes in addition to existing &lt;code&gt;v-model&lt;/code&gt; for the different prop). To do so, we recommended emitting events in the pattern of &lt;code&gt;update:myPropName&lt;/code&gt;. For example, for &lt;code&gt;ChildComponent&lt;/code&gt; from the previous example with the &lt;code&gt;title&lt;/code&gt; prop, we could communicate the intent of assigning a new value with:</source>
          <target state="translated">場合によっては、プロップに「双方向バインディング」が必要になることがあります（異なるプロップの既存の &lt;code&gt;v-model&lt;/code&gt; に加えて）。そのためには、 &lt;code&gt;update:myPropName&lt;/code&gt; のパターンでイベントを発行することをお勧めします。たとえば、前の例の &lt;code&gt;ChildComponent&lt;/code&gt; の &lt;code&gt;title&lt;/code&gt; propの場合、新しい値を割り当てる意図を次のように伝えることができます。</target>
        </trans-unit>
        <trans-unit id="1940a94800d8a762af2d6a0c31713ae2122b98c5" translate="yes" xml:space="preserve">
          <source>In such cases you can specify an explicit transition duration (in milliseconds) using the &lt;code&gt;duration&lt;/code&gt; prop on the &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">このような場合は、 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; コンポーネントの &lt;code&gt;duration&lt;/code&gt; プロパティを使用して、明示的な遷移時間（ミリ秒単位）を指定できます。</target>
        </trans-unit>
        <trans-unit id="5a26c3605ae94474098786b85b0faf6c2e5c873c" translate="yes" xml:space="preserve">
          <source>In terms of what has changed, at a high level:</source>
          <target state="translated">何が変わったかという点では、高いレベルで。</target>
        </trans-unit>
        <trans-unit id="eb7b8e5881c6c604581549ecd2e87a6d5a150d11" translate="yes" xml:space="preserve">
          <source>In that case, the &lt;code&gt;.native&lt;/code&gt; listener in the parent would silently break. There would be no errors, but the &lt;code&gt;onFocus&lt;/code&gt; handler wouldn&amp;rsquo;t be called when we expected it to.</source>
          <target state="translated">その場合、親の &lt;code&gt;.native&lt;/code&gt; リスナーは黙って中断します。エラーは発生しませんが、 &lt;code&gt;onFocus&lt;/code&gt; たときにonFocusハンドラーが呼び出されませんでした。</target>
        </trans-unit>
        <trans-unit id="8c963edc9ad3f82196cbef815577797afa016c7d" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/dist/&quot;&gt;&lt;code&gt;dist/&lt;/code&gt; directory of the NPM package&lt;/a&gt; you will find many different builds of Vue.js. Here&amp;rsquo;s an overview of the difference between them:</source>
          <target state="translated">&lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/dist/&quot;&gt;NPMパッケージ&lt;/a&gt;の &lt;code&gt;dist/&lt;/code&gt; ディレクトリーには、 Vue.jsの多くの異なるビルドがあります。これらの違いの概要は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="096cc70c4fb5904b4142f8704ac2119fe695246e" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue@3.0.2/dist/&quot;&gt;&lt;code&gt;dist/&lt;/code&gt; directory of the npm package (opens new window)&lt;/a&gt; you will find many different builds of Vue.js. Here is an overview of which &lt;code&gt;dist&lt;/code&gt; file should be used depending on the use-case.</source>
          <target state="translated">&lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue@3.0.2/dist/&quot;&gt;npmパッケージ&lt;/a&gt;の &lt;code&gt;dist/&lt;/code&gt; ディレクトリ（新しいウィンドウが開きます）には、Vue.jsのさまざまなビルドがあります。ユースケースに応じて使用する必要がある &lt;code&gt;dist&lt;/code&gt; ファイルの概要は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="1f40ffd220cc5bc553599168b68b9a1d61abb356" translate="yes" xml:space="preserve">
          <source>In the above example, the handler will only be called if &lt;code&gt;$event.key&lt;/code&gt; is equal to &lt;code&gt;'PageDown'&lt;/code&gt;.</source>
          <target state="translated">上記の例では、ハンドラーは &lt;code&gt;$event.key&lt;/code&gt; が &lt;code&gt;'PageDown'&lt;/code&gt; と等しい場合にのみ呼び出されます。</target>
        </trans-unit>
        <trans-unit id="a3446d8a02b83d478e2220ffc2e826c8e079f0f9" translate="yes" xml:space="preserve">
          <source>In the case of boolean attributes, where their mere existence implies &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;v-bind&lt;/code&gt; works a little differently. For example:</source>
          <target state="translated">ブール属性の場合、それらの単なる存在が &lt;code&gt;true&lt;/code&gt; 意味する場合、 &lt;code&gt;v-bind&lt;/code&gt; の動作は少し異なります。例えば：</target>
        </trans-unit>
        <trans-unit id="4792c37807464f6bc3e88fc7e7650b64df280b7d" translate="yes" xml:space="preserve">
          <source>In the case of boolean attributes, where their mere existence implies &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;v-bind&lt;/code&gt; works a little differently. In this example:</source>
          <target state="translated">ブール属性の場合、それらの単なる存在が &lt;code&gt;true&lt;/code&gt; を意味する場合、 &lt;code&gt;v-bind&lt;/code&gt; 動作は少し異なります。この例では：</target>
        </trans-unit>
        <trans-unit id="bb18b983202c7fe25cd6f2bdde9cc28d610f7cf0" translate="yes" xml:space="preserve">
          <source>In the console, enter &lt;code&gt;app4.todos.push({ text: 'New item' })&lt;/code&gt;. You should see a new item appended to the list.</source>
          <target state="translated">コンソールで、 &lt;code&gt;app4.todos.push({ text: 'New item' })&lt;/code&gt; ます。リストに追加された新しいアイテムが表示されます。</target>
        </trans-unit>
        <trans-unit id="baf8e367f46b7e0b83ce3e0f831c56fb3167cb4c" translate="yes" xml:space="preserve">
          <source>In the event we need to define the status of the date-picker component via a &lt;code&gt;data-status&lt;/code&gt; property, it will be applied to the root node (i.e., &lt;code&gt;div.date-picker&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;data-status&lt;/code&gt; プロパティを介してdate-pickerコンポーネントのステータスを定義する必要がある場合、それはルートノード（つまり、 &lt;code&gt;div.date-picker&lt;/code&gt; ）に適用されます。</target>
        </trans-unit>
        <trans-unit id="95310bafe87b1cd719e23dc5ad106b31232edbf5" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;currentTabComponent&lt;/code&gt; can contain either:</source>
          <target state="translated">上記の例では、 &lt;code&gt;currentTabComponent&lt;/code&gt; に次のいずれかを含めることができます。</target>
        </trans-unit>
        <trans-unit id="d04b574a39526af2226086b101aac912fd89cf7c" translate="yes" xml:space="preserve">
          <source>In the example above, either &lt;code&gt;appear&lt;/code&gt; attribute or &lt;code&gt;v-on:appear&lt;/code&gt; hook will cause an appear transition.</source>
          <target state="translated">上記の例では、 &lt;code&gt;appear&lt;/code&gt; 属性または &lt;code&gt;v-on:appear&lt;/code&gt; フックのいずれかが表示遷移を引き起こします。</target>
        </trans-unit>
        <trans-unit id="483be1a650754b9854fa661d0a114900f298cd73" translate="yes" xml:space="preserve">
          <source>In the example above, if we change the list of &lt;code&gt;todos&lt;/code&gt;, this change won't be reflected in the injected &lt;code&gt;todoLength&lt;/code&gt; property. This is because &lt;code&gt;provide/inject&lt;/code&gt; bindings are &lt;em&gt;not&lt;/em&gt; reactive by default. We can change this behavior by passing a &lt;code&gt;ref&lt;/code&gt; property or &lt;code&gt;reactive&lt;/code&gt; object to &lt;code&gt;provide&lt;/code&gt;. In our case, if we wanted to react to changes in the ancestor component, we would need to assign a Composition API &lt;code&gt;computed&lt;/code&gt; property to our provided &lt;code&gt;todoLength&lt;/code&gt;:</source>
          <target state="translated">我々はリスト変更する場合、上記の例では、 &lt;code&gt;todos&lt;/code&gt; 、この変化は注入には反映されない &lt;code&gt;todoLength&lt;/code&gt; のプロパティ。これは、 &lt;code&gt;provide/inject&lt;/code&gt; バインディングがデフォルトでリアクティブでは&lt;em&gt;ない&lt;/em&gt;ためです。 &lt;code&gt;ref&lt;/code&gt; プロパティまたは &lt;code&gt;reactive&lt;/code&gt; オブジェクトを渡して &lt;code&gt;provide&lt;/code&gt; 、この動作を変更できます。この場合、祖先コンポーネントの変更に対応する場合は、CompositionAPIの &lt;code&gt;computed&lt;/code&gt; プロパティを提供された &lt;code&gt;todoLength&lt;/code&gt; に割り当てる必要があります。</target>
        </trans-unit>
        <trans-unit id="2def93c9e7b3255befa3e7efa09f860a33357348" translate="yes" xml:space="preserve">
          <source>In the example above, the method &lt;code&gt;increment&lt;/code&gt; will be called when the &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; is clicked.</source>
          <target state="translated">上記の例では、 &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; がクリックされたときにメソッド &lt;code&gt;increment&lt;/code&gt; が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="62a3df45a50f5bfc852f235683adae371735692a" translate="yes" xml:space="preserve">
          <source>In the future, you can consult the &lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;API reference&lt;/a&gt; for a full list of instance properties and methods.</source>
          <target state="translated">今後、インスタンスのプロパティとメソッドの完全なリストについては、&lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;APIリファレンス&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="61e01a36c0b76503c82d3b378dd53c34675f6cd7" translate="yes" xml:space="preserve">
          <source>In the parent, we can support this feature by adding a &lt;code&gt;postFontSize&lt;/code&gt; data property:</source>
          <target state="translated">親では、 &lt;code&gt;postFontSize&lt;/code&gt; データプロパティを追加することでこの機能をサポートできます。</target>
        </trans-unit>
        <trans-unit id="bd63d2b019faa52d4307ffd579cbe3aabbbc0774" translate="yes" xml:space="preserve">
          <source>In the two examples above, we happen to pass string values, but &lt;em&gt;any&lt;/em&gt; type of value can actually be passed to a prop.</source>
          <target state="translated">上記の2つの例では、たまたま文字列値を渡していますが、実際には&lt;em&gt;任意の&lt;/em&gt;タイプの値をプロップに渡すことができます。</target>
        </trans-unit>
        <trans-unit id="dd9b704f820476ed2050280cb293d51fab68d129" translate="yes" xml:space="preserve">
          <source>In these cases, you can also use the &lt;code&gt;key&lt;/code&gt; attribute to transition between different states of the same element. Instead of using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-else&lt;/code&gt;, the above example could be rewritten as:</source>
          <target state="translated">このような場合、 &lt;code&gt;key&lt;/code&gt; 属性を使用して、同じ要素の異なる状態間を遷移することもできます。 &lt;code&gt;v-if&lt;/code&gt; と &lt;code&gt;v-else&lt;/code&gt; を使用する代わりに、上記の例は次のように書き直すことができます。</target>
        </trans-unit>
        <trans-unit id="270ed3979fc2c798270823f8c8f6f6d7b3c0fe7a" translate="yes" xml:space="preserve">
          <source>In these cases, you can define your components as plain JavaScript objects:</source>
          <target state="translated">このような場合は、コンポーネントをプレーンな JavaScript オブジェクトとして定義することができます。</target>
        </trans-unit>
        <trans-unit id="ba09958fde7b27bfaf33999c7469e63cc8666df2" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;change&lt;/code&gt; event listener is passed from the parent component to the child and it will be triggered on native &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;&lt;code&gt;change&lt;/code&gt; event. We won't need to emit an event from the &lt;code&gt;date-picker&lt;/code&gt; explicitly:</source>
          <target state="translated">この場合、 &lt;code&gt;change&lt;/code&gt; イベントリスナーは親コンポーネントから子に渡され、ネイティブの &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; &lt;code&gt;change&lt;/code&gt; イベントでトリガーされます。 &lt;code&gt;date-picker&lt;/code&gt; 明示的にイベントを発行する必要はありません。</target>
        </trans-unit>
        <trans-unit id="2a3f7f2ff8f42344402992b4038b21897eb06f33" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;filterA&lt;/code&gt;, defined with a single argument, will receive the value of &lt;code&gt;message&lt;/code&gt;, and then the &lt;code&gt;filterB&lt;/code&gt; function will be called with the result of &lt;code&gt;filterA&lt;/code&gt; passed into &lt;code&gt;filterB&lt;/code&gt;&amp;lsquo;s single argument.</source>
          <target state="translated">この場合、 &lt;code&gt;filterA&lt;/code&gt; 単一の引数で定義され、値の受信する &lt;code&gt;message&lt;/code&gt; 、その後 &lt;code&gt;filterB&lt;/code&gt; の機能の結果で呼び出される &lt;code&gt;filterA&lt;/code&gt; に渡さ &lt;code&gt;filterB&lt;/code&gt; の単一の引数。</target>
        </trans-unit>
        <trans-unit id="b094d0f631f3cc4f6960b2f03d3f031dd3ba5545" translate="yes" xml:space="preserve">
          <source>In this case, child component will expect a &lt;code&gt;title&lt;/code&gt; prop and emits &lt;code&gt;update:title&lt;/code&gt; event to sync:</source>
          <target state="translated">この場合、子コンポーネントは &lt;code&gt;title&lt;/code&gt; プロップを期待し、同期する &lt;code&gt;update:title&lt;/code&gt; イベントを発行します。</target>
        </trans-unit>
        <trans-unit id="87475fd1d00b371cef287b525052f62f24411b8f" translate="yes" xml:space="preserve">
          <source>In this case, even when &lt;code&gt;child-component&lt;/code&gt; is rendered in the different place, it will remain a child of &lt;code&gt;parent-component&lt;/code&gt; and will receive a &lt;code&gt;name&lt;/code&gt; prop from it.</source>
          <target state="translated">この場合、 &lt;code&gt;child-component&lt;/code&gt; が別の場所でレンダリングされても、 &lt;code&gt;parent-component&lt;/code&gt; 子のままであり、そこから &lt;code&gt;name&lt;/code&gt; propを受け取ります。</target>
        </trans-unit>
        <trans-unit id="51f8bfe75335d793eeba7a8a459bb7388dddda84" translate="yes" xml:space="preserve">
          <source>In this case, two different values for &lt;code&gt;class&lt;/code&gt; are defined:</source>
          <target state="translated">この場合、 &lt;code&gt;class&lt;/code&gt; は2つの異なる値が定義されています。</target>
        </trans-unit>
        <trans-unit id="35bd1cc27abd4ba52e44235a43fbbdc36c5c6e07" translate="yes" xml:space="preserve">
          <source>In this case, using the &lt;code&gt;watch&lt;/code&gt; option allows us to perform an asynchronous operation (accessing an API) and sets a condition for performing this operation. None of that would be possible with a computed property.</source>
          <target state="translated">この場合、 &lt;code&gt;watch&lt;/code&gt; オプションを使用すると、非同期操作（APIへのアクセス）を実行し、この操作を実行するための条件を設定できます。計算されたプロパティでは、それは不可能です。</target>
        </trans-unit>
        <trans-unit id="5a41e15d26b4745e4e15ab1dd537dc8ed976bef4" translate="yes" xml:space="preserve">
          <source>In this case, using the &lt;code&gt;watch&lt;/code&gt; option allows us to perform an asynchronous operation (accessing an API), limit how often we perform that operation, and set intermediary states until we get a final answer. None of that would be possible with a computed property.</source>
          <target state="translated">この場合、 &lt;code&gt;watch&lt;/code&gt; オプションを使用すると、非同期操作（APIへのアクセス）の実行、その操作の実行頻度の制限、最終的な回答が得られるまでの中間状態の設定が可能になります。計算されたプロパティではそれは不可能です。</target>
        </trans-unit>
        <trans-unit id="c77863cfdbda9f76e5977da8ad51a7454c3913a0" translate="yes" xml:space="preserve">
          <source>In this component, all descendants of &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; needed access to a &lt;code&gt;getMap&lt;/code&gt; method, in order to know which map to interact with. Unfortunately, using the &lt;code&gt;$parent&lt;/code&gt; property didn&amp;rsquo;t scale well to more deeply nested components. That&amp;rsquo;s where dependency injection can be useful, using two new instance options: &lt;code&gt;provide&lt;/code&gt; and &lt;code&gt;inject&lt;/code&gt;.</source>
          <target state="translated">このコンポーネントでは、どのマップと対話するかを知るために、 &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; のすべての子孫が &lt;code&gt;getMap&lt;/code&gt; メソッドにアクセスする必要がありました。残念ながら、 &lt;code&gt;$parent&lt;/code&gt; プロパティを使用しても、より深くネストされたコンポーネントに適切にスケーリングできませんでした。ここで、2つの新しいインスタンスオプション、 &lt;code&gt;provide&lt;/code&gt; と &lt;code&gt;inject&lt;/code&gt; を使用して、依存性注入が役立ちます。</target>
        </trans-unit>
        <trans-unit id="2f4bcb81fce1b99e6d7bcbd862cd7e2191686fff" translate="yes" xml:space="preserve">
          <source>In this example, we are creating animation through the use of interpolation, attached to the mouse movement. The CSS transition is applied to the element as well, to let the element know what kind of easing to use while it's updating.</source>
          <target state="translated">この例では、マウスの動きに付随して補間を利用してアニメーションを作成しています。要素にもCSSトランジションを適用し、更新中にどのようなイージングを使用するかを要素に知らせるようにしています。</target>
        </trans-unit>
        <trans-unit id="87c32991080d62b6805604f45e74c2b9dbeebfae" translate="yes" xml:space="preserve">
          <source>In this example, we&amp;rsquo;ve chosen to name the object containing all our slot props &lt;code&gt;slotProps&lt;/code&gt;, but you can use any name you like.</source>
          <target state="translated">この例では、我々はすべて私たちのスロット小道具含むオブジェクト命名することにしました &lt;code&gt;slotProps&lt;/code&gt; を、しかし、あなたはあなたが好きな名前を使用することができます。</target>
        </trans-unit>
        <trans-unit id="b16da33edc850538e8b64bc474cfc99b18b1ed65" translate="yes" xml:space="preserve">
          <source>In this example, we've chosen to name the object containing all our slot props &lt;code&gt;slotProps&lt;/code&gt;, but you can use any name you like.</source>
          <target state="translated">この例では、すべてのスロット小道具 &lt;code&gt;slotProps&lt;/code&gt; を含むオブジェクトに名前を付けることを選択しましたが、任意の名前を使用できます。</target>
        </trans-unit>
        <trans-unit id="2fe86abd2c9033c394d4520eeee5520850f8fc84" translate="yes" xml:space="preserve">
          <source>In this example, when &lt;code&gt;eventName&lt;/code&gt;&amp;lsquo;s value is &lt;code&gt;&quot;focus&quot;&lt;/code&gt;, &lt;code&gt;v-on:[eventName]&lt;/code&gt; will be equivalent to &lt;code&gt;v-on:focus&lt;/code&gt;.</source>
          <target state="translated">この例では、 &lt;code&gt;eventName&lt;/code&gt; の値が &lt;code&gt;&quot;focus&quot;&lt;/code&gt; の場合、 &lt;code&gt;v-on:[eventName]&lt;/code&gt; は &lt;code&gt;v-on:focus&lt;/code&gt; と同等になります。</target>
        </trans-unit>
        <trans-unit id="3ee4d6d04f3346c2de61ff6305b7eecf8246b8e0" translate="yes" xml:space="preserve">
          <source>In this example, when &lt;code&gt;eventName&lt;/code&gt;'s value is &lt;code&gt;&quot;focus&quot;&lt;/code&gt;, &lt;code&gt;v-on:[eventName]&lt;/code&gt; will be equivalent to &lt;code&gt;v-on:focus&lt;/code&gt;.</source>
          <target state="translated">この例では、 &lt;code&gt;eventName&lt;/code&gt; の値が &lt;code&gt;&quot;focus&quot;&lt;/code&gt; 場合、 &lt;code&gt;v-on:[eventName]&lt;/code&gt; は &lt;code&gt;v-on:focus&lt;/code&gt; と同等になります。</target>
        </trans-unit>
        <trans-unit id="301b4eda5dbc41617be06964e971e23018f19d78" translate="yes" xml:space="preserve">
          <source>In this example:</source>
          <target state="translated">この例では</target>
        </trans-unit>
        <trans-unit id="224e78735239ecbe7e73bb9d8e2936f204860e9c" translate="yes" xml:space="preserve">
          <source>In this next section, we'll go over some web animation and transitions basics, and link off to some resources for further exploration. If you're already familiar with web animation and how those principles might work with some of Vue's directives, feel free to skip this next section. For anyone else looking to learn a little more about web animation basics before diving in, read on.</source>
          <target state="translated">次のセクションでは、ウェブアニメーションとトランジションの基本について説明し、さらに詳しい情報を得るためにいくつかのリソースにリンクします。すでにウェブアニメーションに精通していて、それらの原則が Vue のディレクティブとどのように機能するかを知っている場合は、この次のセクションは読み飛ばしてください。飛び込む前にウェブアニメーションの基本をもう少し学びたいと思っている人は、ぜひ読んでみてください。</target>
        </trans-unit>
        <trans-unit id="3b90fada6407b38a0e73129e45014412d2857eb5" translate="yes" xml:space="preserve">
          <source>In this, any change to &lt;code&gt;todos.length&lt;/code&gt; will be reflected correctly in the components, where &lt;code&gt;todoLength&lt;/code&gt; is injected. Read more about &lt;code&gt;computed&lt;/code&gt; in the &lt;a href=&quot;reactivity-computed-watchers#computed-values&quot;&gt;Computed and Watch section&lt;/a&gt; and &lt;code&gt;reactive&lt;/code&gt; provide/inject in the &lt;a href=&quot;composition-api-provide-inject#reactivity&quot;&gt;Composition API section&lt;/a&gt;.</source>
          <target state="translated">この場合、 &lt;code&gt;todos.length&lt;/code&gt; への変更は、 &lt;code&gt;todoLength&lt;/code&gt; が挿入されるコンポーネントに正しく反映されます。 &lt;code&gt;computed&lt;/code&gt; 詳細については「&lt;a href=&quot;reactivity-computed-watchers#computed-values&quot;&gt;計算と監視」セクションを&lt;/a&gt;、 &lt;code&gt;reactive&lt;/code&gt; 提供/注入については「&lt;a href=&quot;composition-api-provide-inject#reactivity&quot;&gt;構成API」セクション&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="83141900cc37f0045fe7fc8eeac34df78525c24e" translate="yes" xml:space="preserve">
          <source>In v2.1.8, we introduced &lt;code&gt;v-enter-to&lt;/code&gt; to address the timing gap between enter/leave transitions. However, for backward compatibility, the &lt;code&gt;v-enter&lt;/code&gt; name was untouched:</source>
          <target state="translated">v2.1.8では、エンター/リーブ遷移間のタイミングギャップに対処する &lt;code&gt;v-enter-to&lt;/code&gt; にv-enter-toを導入しました。ただし、下位互換性のために、 &lt;code&gt;v-enter&lt;/code&gt; 名は変更されていません。</target>
        </trans-unit>
        <trans-unit id="a932790edae9a805888ba88043f905fae94eda92" translate="yes" xml:space="preserve">
          <source>In-browser Sandbox on &lt;a href=&quot;https://v3.vue.new&quot;&gt;CodeSandbox (opens new window)&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://v3.vue.new&quot;&gt;CodeSandboxの&lt;/a&gt;ブラウザ内サンドボックス（新しいウィンドウを開きます）</target>
        </trans-unit>
        <trans-unit id="18af7a938545bae476e6597aaaf4d9729f2bb10a" translate="yes" xml:space="preserve">
          <source>In-browser playground on &lt;a href=&quot;https://codepen.io/yyx990803/pen/OJNoaZL&quot;&gt;Codepen (opens new window)&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://codepen.io/yyx990803/pen/OJNoaZL&quot;&gt;Codepenの&lt;/a&gt;ブラウザ内プレイグラウンド（新しいウィンドウが開きます）</target>
        </trans-unit>
        <trans-unit id="72b54df78801726764e7a6e4a3da6b7ab270929d" translate="yes" xml:space="preserve">
          <source>In-browser template compilation:</source>
          <target state="translated">ブラウザ内テンプレートのコンパイル。</target>
        </trans-unit>
        <trans-unit id="edb555d4f2dd9b0c24bb7bd03390992336ca209c" translate="yes" xml:space="preserve">
          <source>In-template expressions are very convenient, but they are meant for simple operations. Putting too much logic in your templates can make them bloated and hard to maintain. For example, if we have an object with a nested array:</source>
          <target state="translated">テンプレート内の式は非常に便利ですが、単純な操作のためのものです。テンプレートに多くのロジックを入れすぎると、テンプレートが肥大化してメンテナンスが難しくなることがあります。例えば、入れ子になった配列を持つオブジェクトがあるとします。</target>
        </trans-unit>
        <trans-unit id="f0f426e265453130f5824fc7740883c382b44aac" translate="yes" xml:space="preserve">
          <source>In-template expressions are very convenient, but they are meant for simple operations. Putting too much logic in your templates can make them bloated and hard to maintain. For example:</source>
          <target state="translated">テンプレート内の式は非常に便利ですが、単純な操作のためのものです。テンプレートに多くのロジックを入れすぎると、テンプレートが肥大化してメンテナンスが大変になることがあります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="14f1365ed8291193e8cace94a5ade677414a902d" translate="yes" xml:space="preserve">
          <source>Individual nodes</source>
          <target state="translated">個々のノード</target>
        </trans-unit>
        <trans-unit id="8a0e39acb1c9c6d6a7975a0cc9ac25b374494a2e" translate="yes" xml:space="preserve">
          <source>Information about the parent document: footnotes/copyrights/links to privacy statement</source>
          <target state="translated">親文書に関する情報:脚注/著作権/プライバシーポリシーへのリンク</target>
        </trans-unit>
        <trans-unit id="7754e67b3434e8bddbe642373114506a298fbefb" translate="yes" xml:space="preserve">
          <source>Information and the operation of user interface must be understandable to all users</source>
          <target state="translated">ユーザーインターフェースの情報や操作は、すべてのユーザーが理解できるものでなければならない。</target>
        </trans-unit>
        <trans-unit id="62ac95bcfcaea7ee52c78bc13557436b1b7e8b9e" translate="yes" xml:space="preserve">
          <source>Information for React Developers</source>
          <target state="translated">React開発者のための情報</target>
        </trans-unit>
        <trans-unit id="f7fe66c9daa7dc6cfca9b6a287a3553348c8c87d" translate="yes" xml:space="preserve">
          <source>Injecting a property into the root component, with a value provided by the application:</source>
          <target state="translated">アプリケーションから提供された値を持つプロパティをルート・コンポーネントに注入します。</target>
        </trans-unit>
        <trans-unit id="73bfac40439f515d418c73435ab088df8607873d" translate="yes" xml:space="preserve">
          <source>Injections can be optional with default value:</source>
          <target state="translated">注入はデフォルト値で任意に設定できます。</target>
        </trans-unit>
        <trans-unit id="d55df74fbab3d4d77132f63aeb4395de7ec9a282" translate="yes" xml:space="preserve">
          <source>Inline Template Attribute</source>
          <target state="translated">インラインテンプレート属性</target>
        </trans-unit>
        <trans-unit id="a44289ee2d1bd2c3982f79cb3d372150789f0e39" translate="yes" xml:space="preserve">
          <source>Inline Templates</source>
          <target state="translated">インラインテンプレート</target>
        </trans-unit>
        <trans-unit id="b59e8ce6b81b97e1c066f696c45f14d51b2387b4" translate="yes" xml:space="preserve">
          <source>Inline templates attributes</source>
          <target state="translated">インラインテンプレートの属性</target>
        </trans-unit>
        <trans-unit id="e351cce80f83cbfe40944664026f6d9aab7cb539" translate="yes" xml:space="preserve">
          <source>Inlines all Vue core internal packages - i.e. it's a single file with no dependencies on other files. This means you must import everything from this file and this file only to ensure you are getting the same instance of code.</source>
          <target state="translated">すべての Vue コアの内部パッケージをインライン化します。つまり、コードのインスタンスが同じであることを確認するために、このファイルとこのファイルからすべてをインポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="9ef635bdfe6ae64380c953e554f1a2566d43a6f8" translate="yes" xml:space="preserve">
          <source>Input fields</source>
          <target state="translated">入力フィールド</target>
        </trans-unit>
        <trans-unit id="d6a0f79f1797a1db2dda5bb9c7106c3808038d31" translate="yes" xml:space="preserve">
          <source>Inside &lt;code&gt;v-for&lt;/code&gt; blocks we have full access to parent scope properties. &lt;code&gt;v-for&lt;/code&gt; also supports an optional second argument for the index of the current item.</source>
          <target state="translated">&lt;code&gt;v-for&lt;/code&gt; ブロックの内部では、親スコープのプロパティに完全にアクセスできます。 &lt;code&gt;v-for&lt;/code&gt; は、現在のアイテムのインデックスのオプションの2番目の引数もサポートします。</target>
        </trans-unit>
        <trans-unit id="916038a23e13909a2f75bbe445827872088c10bc" translate="yes" xml:space="preserve">
          <source>Install a Vue.js plugin. If the plugin is an Object, it must expose an &lt;code&gt;install&lt;/code&gt; method. If it is a function itself, it will be treated as the install method.</source>
          <target state="translated">Vue.jsプラグインをインストールします。プラグインがオブジェクトの場合、 &lt;code&gt;install&lt;/code&gt; メソッドを公開する必要があります。関数自体の場合は、インストール方法として扱われます。</target>
        </trans-unit>
        <trans-unit id="df082a453d9989c585680725b67df591a35ff7cd" translate="yes" xml:space="preserve">
          <source>Install a Vue.js plugin. If the plugin is an Object, it must expose an &lt;code&gt;install&lt;/code&gt; method. If it is a function itself, it will be treated as the install method. The install method will be called with Vue as the argument.</source>
          <target state="translated">Vue.jsプラグインをインストールします。プラグインがオブジェクトの場合、 &lt;code&gt;install&lt;/code&gt; メソッドを公開する必要があります。それ自体が関数の場合は、インストール方法として扱われます。installメソッドは、Vueを引数として呼び出されます。</target>
        </trans-unit>
        <trans-unit id="d8a20feef8f2799f45b48c087bb1f2c9b59bf8bd" translate="yes" xml:space="preserve">
          <source>Install it using &lt;a href=&quot;#npm&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#npm&quot;&gt;npm&lt;/a&gt;を使用してインストールします</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="d6d358674017f8697b8b19f7ff45ce7429f3312b" translate="yes" xml:space="preserve">
          <source>Installing Rollup</source>
          <target state="translated">ロールアップのインストール</target>
        </trans-unit>
        <trans-unit id="76cfe08fef21bde292ada7bf7c0aed2cb8221c4a" translate="yes" xml:space="preserve">
          <source>Instance DOM Options</source>
          <target state="translated">インスタンス DOM オプション</target>
        </trans-unit>
        <trans-unit id="ff364c35cc3bd1adde1c021645e9ea7d4cfa6d27" translate="yes" xml:space="preserve">
          <source>Instance Lifecycle Hooks</source>
          <target state="translated">インスタンス ライフサイクル フック</target>
        </trans-unit>
        <trans-unit id="dd4a61ab3dc44ab9b5a205303724a68f74a735a7" translate="yes" xml:space="preserve">
          <source>Instance Methods</source>
          <target state="translated">インスタンスメソッド</target>
        </trans-unit>
        <trans-unit id="973fbc314de18d3a6034820e1c145f308866aa0a" translate="yes" xml:space="preserve">
          <source>Instance Methods / Data</source>
          <target state="translated">インスタンスメソッド/データ</target>
        </trans-unit>
        <trans-unit id="072a5ac49177533e4f02b944ecefcab1e2a8405f" translate="yes" xml:space="preserve">
          <source>Instance Methods / Events</source>
          <target state="translated">インスタンス メソッド/イベント</target>
        </trans-unit>
        <trans-unit id="217d7335931d2bbee9b9778f9ae71c201b5b2ba6" translate="yes" xml:space="preserve">
          <source>Instance Methods / Lifecycle</source>
          <target state="translated">インスタンス メソッド/ライフサイクル</target>
        </trans-unit>
        <trans-unit id="227bff69876b172aeee6752f9b003b6b9627ce6c" translate="yes" xml:space="preserve">
          <source>Instance Properties</source>
          <target state="translated">インスタンスのプロパティ</target>
        </trans-unit>
        <trans-unit id="8e111ccced14747a0574e33ed0b08f79642573af" translate="yes" xml:space="preserve">
          <source>Instead of a computed property, we can define the same function as a method. For the end result, the two approaches are indeed exactly the same. However, the difference is that &lt;strong&gt;computed properties are cached based on their reactive dependencies.&lt;/strong&gt; A computed property will only re-evaluate when some of its reactive dependencies have changed. This means as long as &lt;code&gt;author.books&lt;/code&gt; has not changed, multiple access to the &lt;code&gt;publishedBooksMessage&lt;/code&gt; computed property will immediately return the previously computed result without having to run the function again.</source>
          <target state="translated">計算されたプロパティの代わりに、メソッドと同じ関数を定義できます。最終結果として、2つのアプローチはまったく同じです。ただし、違いは、&lt;strong&gt;計算されたプロパティがリアクティブな依存関係に基づいてキャッシュされることです。&lt;/strong&gt;計算されたプロパティは、そのリアクティブな依存関係の一部が変更された場合にのみ再評価されます。つまり、 &lt;code&gt;author.books&lt;/code&gt; が変更されていない限り、 &lt;code&gt;publishedBooksMessage&lt;/code&gt; の計算プロパティに複数回アクセスすると、関数を再度実行しなくても、以前に計算された結果がすぐに返されます。</target>
        </trans-unit>
        <trans-unit id="b4f963982241acc7a523f3640f34c5d31eeeb04c" translate="yes" xml:space="preserve">
          <source>Instead of a computed property, we can define the same function as a method. For the end result, the two approaches are indeed exactly the same. However, the difference is that &lt;strong&gt;computed properties are cached based on their reactive dependencies.&lt;/strong&gt; A computed property will only re-evaluate when some of its reactive dependencies have changed. This means as long as &lt;code&gt;message&lt;/code&gt; has not changed, multiple access to the &lt;code&gt;reversedMessage&lt;/code&gt; computed property will immediately return the previously computed result without having to run the function again.</source>
          <target state="translated">計算されたプロパティの代わりに、メソッドと同じ関数を定義できます。最終結果については、2つのアプローチはまったく同じです。ただし、&lt;strong&gt;計算されたプロパティはリアクティブな依存関係に基づいてキャッシュされる&lt;/strong&gt;点が&lt;strong&gt;異なります。&lt;/strong&gt;計算されたプロパティは、そのリアクティブな依存関係の一部が変更された場合にのみ再評価されます。つまり、 &lt;code&gt;message&lt;/code&gt; が変更されていない限り、 &lt;code&gt;reversedMessage&lt;/code&gt; 計算プロパティへの複数のアクセスは、関数を再度実行する必要なく、以前に計算された結果をすぐに返します。</target>
        </trans-unit>
        <trans-unit id="1b4b07b3bfde3c37c88bc87409ab0932e79deaf1" translate="yes" xml:space="preserve">
          <source>Instead of binding directly to a method name, we can also use methods in an inline JavaScript statement:</source>
          <target state="translated">メソッド名に直接バインドするのではなく、インラインのJavaScriptステートメントでメソッドを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="e8cfda798ff1c2483b2312e929e673f1a5762a04" translate="yes" xml:space="preserve">
          <source>Instead of hard-coding the content for each todo, we can let the parent component take control by making every todo a slot, then binding &lt;code&gt;todo&lt;/code&gt; as a slot prop:</source>
          <target state="translated">各todoのコンテンツをハードコーディングする代わりに、すべてのtodoをスロットにしてから、 &lt;code&gt;todo&lt;/code&gt; をスロットプロップとしてバインドすることで、親コンポーネントに制御を任せることができます。</target>
        </trans-unit>
        <trans-unit id="4b69ebfba064bf598fe0cf47768da6d783b96402" translate="yes" xml:space="preserve">
          <source>Instead of using filters, we recommend replacing them with computed properties or methods.</source>
          <target state="translated">フィルターを使うのではなく、計算されたプロパティやメソッドに置き換えることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="ce7ba8338e1ddfeb030dce1f2c4b233f9f6e562c" translate="yes" xml:space="preserve">
          <source>Instead of using this interface to watch events emitted by the store itself (e.g. &lt;code&gt;store.on('mutation', callback)&lt;/code&gt;), a new method &lt;code&gt;store.subscribe&lt;/code&gt; is introduced. Typical usage inside a plugin would be:</source>
          <target state="translated">このインターフェイスを使用して、ストア自体が &lt;code&gt;store.on('mutation', callback)&lt;/code&gt; するイベントを監視する代わりに（例：store.on（ 'mutation'、callback））、新しいメソッド &lt;code&gt;store.subscribe&lt;/code&gt; が導入されました。プラグイン内の一般的な使用法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="c042f3d9b71b32db250543be269d410c99d13527" translate="yes" xml:space="preserve">
          <source>Instead of:</source>
          <target state="translated">代わりに</target>
        </trans-unit>
        <trans-unit id="c45f60db0ef01bd679b8e4fcc3944f81d86bbcba" translate="yes" xml:space="preserve">
          <source>Instead, &lt;strong&gt;a component&amp;rsquo;s &lt;code&gt;data&lt;/code&gt; option must be a function&lt;/strong&gt;, so that each instance can maintain an independent copy of the returned data object:</source>
          <target state="translated">代わりに、各インスタンスが返されたデータオブジェクトの独立したコピーを維持できるように&lt;strong&gt;、コンポーネントの &lt;code&gt;data&lt;/code&gt; オプションは関数&lt;/strong&gt;で&lt;strong&gt;なければなりません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="de7d48ff36cd012d479333deddf79964e9f6ef8d" translate="yes" xml:space="preserve">
          <source>Instead, retrieve reactive data directly.</source>
          <target state="translated">代わりに、反応性のあるデータを直接取得します。</target>
        </trans-unit>
        <trans-unit id="3f19e4bbba14c8cf11229dc99c18e65e5c769ff2" translate="yes" xml:space="preserve">
          <source>Instead, we recommend combining the two prefixes into &lt;code&gt;$_&lt;/code&gt;, as a convention for user-defined private properties that guarantee no conflicts with Vue.</source>
          <target state="translated">代わりに、Vueとの競合を保証しないユーザー定義のプライベートプロパティの規則として、2つのプレフィックスを &lt;code&gt;$_&lt;/code&gt; に結合することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="c287d7ed2127cbc1824f61b424108dfdd71928ca" translate="yes" xml:space="preserve">
          <source>Instead, we want each component instance to only manage its own data. For that to happen, each instance must generate a unique data object. In JavaScript, this can be accomplished by returning the object in a function:</source>
          <target state="translated">その代わりに、各コンポーネントのインスタンスが自分のデータだけを管理するようにしたいのです。そのためには、各インスタンスが一意のデータオブジェクトを生成しなければなりません。JavaScriptでは、関数でオブジェクトを返すことで実現できます。</target>
        </trans-unit>
        <trans-unit id="96b563c3c711449585b436481ceb793428c3903f" translate="yes" xml:space="preserve">
          <source>Instead, you can make your global filters available to all components through &lt;a href=&quot;../../api/application-config#globalproperties&quot;&gt;globalProperties&lt;/a&gt;:</source>
          <target state="translated">代わりに、&lt;a href=&quot;../../api/application-config#globalproperties&quot;&gt;globalPropertiesを&lt;/a&gt;使用してすべてのコンポーネントでグローバルフィルターを使用できるようにすることができます。</target>
        </trans-unit>
        <trans-unit id="ce0cc627a5064aba30be950b8ad2481ae6f54dff" translate="yes" xml:space="preserve">
          <source>Instead, you must always specify the name of the slot if you wish to use the shorthand:</source>
          <target state="translated">その代わり、短縮記号を使用したい場合は必ずスロット名を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="e8afed2c977a300920d4774ed7aaf9deb5512321" translate="yes" xml:space="preserve">
          <source>Instead, you should use an array of &lt;strong&gt;objects&lt;/strong&gt; so that &lt;code&gt;v-model&lt;/code&gt; can update the field on the object. For example:</source>
          <target state="translated">代わりに、 &lt;code&gt;v-model&lt;/code&gt; がオブジェクトのフィールドを更新できるように、&lt;strong&gt;オブジェクトの&lt;/strong&gt;配列を使用する必要があります。例えば：</target>
        </trans-unit>
        <trans-unit id="10f4428424192063dd20e3361c36aa4d16de843c" translate="yes" xml:space="preserve">
          <source>Instead:</source>
          <target state="translated">Instead:</target>
        </trans-unit>
        <trans-unit id="ed58f29743f8e14b9c8e13d41e070a1cc1d1c9f5" translate="yes" xml:space="preserve">
          <source>Instructions</source>
          <target state="translated">Instructions</target>
        </trans-unit>
        <trans-unit id="379c57f76110aace6f90c62a627b81f0dbbb50b8" translate="yes" xml:space="preserve">
          <source>Integrating 3rd-Party Routers</source>
          <target state="translated">サードパーティ製ルーターの統合</target>
        </trans-unit>
        <trans-unit id="17e18e17ef79745c1f295aa1481626993cd060bc" translate="yes" xml:space="preserve">
          <source>Interestingly, there are quite a few similarities in how Angular and Vue are addressing these AngularJS issues.</source>
          <target state="translated">興味深いことに、AngularとVueがこれらのAngularJSの問題に取り組んでいる点では、かなりの類似点があります。</target>
        </trans-unit>
        <trans-unit id="99dbe2588887c00092f294adc50297fc9daf034b" translate="yes" xml:space="preserve">
          <source>Interface forms, controls, and navigation are operable</source>
          <target state="translated">インターフェースフォーム、コントロール、ナビゲーションは操作可能</target>
        </trans-unit>
        <trans-unit id="bfd4997099c9dd515cd8fce4f842d086b138a78e" translate="yes" xml:space="preserve">
          <source>Internal Helpers</source>
          <target state="translated">内部ヘルパー</target>
        </trans-unit>
        <trans-unit id="a02ab300dc1e2d3aba3bbbb2499900bcfcafa6b5" translate="yes" xml:space="preserve">
          <source>Internally, scoped slots work by wrapping your slot content in a function passed a single argument:</source>
          <target state="translated">内部的には、スコープされたスロットは、1つの引数を渡された関数の中でスロットの内容をラップすることで動作します。</target>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="8c3512fba6689d1150362df7589fdd0259a7670c" translate="yes" xml:space="preserve">
          <source>Interpolation on textareas (&lt;code&gt;&amp;lt;textarea&amp;gt;{{text}}&amp;lt;/textarea&amp;gt;&lt;/code&gt;) won't work. Use &lt;code&gt;v-model&lt;/code&gt; instead.</source>
          <target state="translated">textareas（ &lt;code&gt;&amp;lt;textarea&amp;gt;{{text}}&amp;lt;/textarea&amp;gt;&lt;/code&gt; ）の補間は機能しません。代わりに &lt;code&gt;v-model&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="722656fd1f60b606e49464736f37b7a9d40935be" translate="yes" xml:space="preserve">
          <source>Interpolation on textareas won't work. Use &lt;code&gt;v-model&lt;/code&gt; instead.</source>
          <target state="translated">textareasの補間は機能しません。代わりに &lt;code&gt;v-model&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="74ebae54b757a56e2bc6baaef1874a08b06640a9" translate="yes" xml:space="preserve">
          <source>Interpolation within Attributes &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;削除された&lt;/sup&gt;属性内の補間&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="fb6efaa267240ec6e8121cc0f552cf518066ff57" translate="yes" xml:space="preserve">
          <source>Interpolation within attributes is no longer valid. For example:</source>
          <target state="translated">属性内での補間は無効になりました。例えば</target>
        </trans-unit>
        <trans-unit id="10efc8300e4de32a0bfa767fd16f85f0fca31378" translate="yes" xml:space="preserve">
          <source>Interpolations</source>
          <target state="translated">Interpolations</target>
        </trans-unit>
        <trans-unit id="b4e6a310890f62289340d7802703b8c2586c6d86" translate="yes" xml:space="preserve">
          <source>Intro</source>
          <target state="translated">Intro</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="9ac25b7dbef348b38cd7447ba00e5e06fcb8b0d0" translate="yes" xml:space="preserve">
          <source>It also automatically prevents you from using the same plugin more than once, so calling it multiple times on the same plugin will install the plugin only once.</source>
          <target state="translated">また、同じプラグインを複数回使用することを自動的に防止してくれるので、同じプラグインで複数回呼び出すと1回だけインストールされます。</target>
        </trans-unit>
        <trans-unit id="52da9e9435184a9a9be23be1c62462bd7a0b062b" translate="yes" xml:space="preserve">
          <source>It also makes it much easier for designers and less experienced developers to parse and contribute to the codebase.</source>
          <target state="translated">また、デザイナーや経験の浅い開発者が解析してコードベースに貢献することも、より簡単になります。</target>
        </trans-unit>
        <trans-unit id="a407600c5553a0b6afce3b2e7009380cff190cf2" translate="yes" xml:space="preserve">
          <source>It also makes it possible to use values other than &lt;code&gt;'true'&lt;/code&gt; and &lt;code&gt;'false'&lt;/code&gt;, or even keywords yet to come, for attributes like &lt;code&gt;contenteditable&lt;/code&gt;</source>
          <target state="translated">また、 &lt;code&gt;contenteditable&lt;/code&gt; などの属性に、 &lt;code&gt;'true'&lt;/code&gt; と &lt;code&gt;'false'&lt;/code&gt; 以外の値、またはこれから登場するキーワードを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="50744937982614ead76f6bef3b2eb792cfd3c531" translate="yes" xml:space="preserve">
          <source>It also returns &lt;code&gt;true&lt;/code&gt; if the proxy is created by &lt;a href=&quot;#readonly&quot;&gt;&lt;code&gt;readonly&lt;/code&gt;&lt;/a&gt;, but is wrapping another proxy created by &lt;a href=&quot;#reactive&quot;&gt;&lt;code&gt;reactive&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">プロキシが&lt;a href=&quot;#readonly&quot;&gt; &lt;code&gt;readonly&lt;/code&gt; &lt;/a&gt;で作成されている場合も &lt;code&gt;true&lt;/code&gt; を返しますが、&lt;a href=&quot;#reactive&quot;&gt; &lt;code&gt;reactive&lt;/code&gt; &lt;/a&gt;によって作成された別のプロキシをラップしています。</target>
        </trans-unit>
        <trans-unit id="242a4787e446f757f3ac8fde1ce7050c81ebb1cc" translate="yes" xml:space="preserve">
          <source>It can also be used to force replacement of an element/component instead of reusing it. This can be useful when you want to:</source>
          <target state="translated">また、要素/コンポーネントを再利用する代わりに強制的に置換するためにも使用できます。これは、次のような場合に便利です。</target>
        </trans-unit>
        <trans-unit id="bf94cb95d2a6204ed6e671a125bae5746aa13ec0" translate="yes" xml:space="preserve">
          <source>It cannot generate projects from user-built &lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#presets&quot;&gt;presets&lt;/a&gt;, which can be especially useful for enterprise environments with pre-established conventions.</source>
          <target state="translated">ユーザーが作成した&lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#presets&quot;&gt;プリセット&lt;/a&gt;からプロジェクトを生成することはできません。これは、事前に確立された規則を持つエンタープライズ環境で特に役立ちます。</target>
        </trans-unit>
        <trans-unit id="37750b9b71f6bf6ac1b868dd8c8eae2a17dab1cf" translate="yes" xml:space="preserve">
          <source>It depends on a few factors:</source>
          <target state="translated">それはいくつかの要因によります。</target>
        </trans-unit>
        <trans-unit id="70b676c863532ffe7d78b42611fe7b4038b9d1dc" translate="yes" xml:space="preserve">
          <source>It does not allow any configuration during project generation, while Vue CLI runs on top of an upgradeable runtime dependency that can be extended via &lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#plugins&quot;&gt;plugins&lt;/a&gt;.</source>
          <target state="translated">Vue CLIは、&lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#plugins&quot;&gt;プラグイン&lt;/a&gt;を介して拡張できるアップグレード可能なランタイム依存関係の上で実行されますが、プロジェクト生成中の構成は許可されません。</target>
        </trans-unit>
        <trans-unit id="240dd640eed272f9ee3a7566a0beee5ed35abc4a" translate="yes" xml:space="preserve">
          <source>It generally takes more time to navigate through nested sub-directories, than scrolling through a single &lt;code&gt;components&lt;/code&gt; directory.</source>
          <target state="translated">通常、単一の &lt;code&gt;components&lt;/code&gt; ディレクトリをスクロールするよりも、ネストされたサブディレクトリをナビゲートする方が時間がかかります。</target>
        </trans-unit>
        <trans-unit id="338465a67b58e6eaa9650c8e5d83c288832f2b5a" translate="yes" xml:space="preserve">
          <source>It is a common practice for plugin authors to install the plugins automatically in their UMD builds using &lt;code&gt;Vue.use&lt;/code&gt;. For instance, this is how the official &lt;code&gt;vue-router&lt;/code&gt; plugin installs itself in a browser environment:</source>
          <target state="translated">プラグインの作成者は、 &lt;code&gt;Vue.use&lt;/code&gt; を使用してUMDビルドにプラグインを自動的にインストールするのが一般的です。たとえば、これは公式の &lt;code&gt;vue-router&lt;/code&gt; プラグインがブラウザ環境にそれ自体をインストールする方法です。</target>
        </trans-unit>
        <trans-unit id="23f753667cec6acdcb632b79682184c7b7b2e7aa" translate="yes" xml:space="preserve">
          <source>It is a very common need to call &lt;code&gt;event.preventDefault()&lt;/code&gt; or &lt;code&gt;event.stopPropagation()&lt;/code&gt; inside event handlers. Although we can do this easily inside methods, it would be better if the methods can be purely about data logic rather than having to deal with DOM event details.</source>
          <target state="translated">イベントハンドラー内で &lt;code&gt;event.preventDefault()&lt;/code&gt; または &lt;code&gt;event.stopPropagation()&lt;/code&gt; を呼び出すことは非常に一般的です。これはメソッド内で簡単に実行できますが、メソッドがDOMイベントの詳細を処理する必要がないよりも、純粋にデータロジックに関するものである方がよいでしょう。</target>
        </trans-unit>
        <trans-unit id="b9b82ff6a9ecc8371804166f686dd29269fd8e00" translate="yes" xml:space="preserve">
          <source>It is also possible to add an &quot;else block&quot; with &lt;code&gt;v-else&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;v-else&lt;/code&gt; で「elseブロック」を追加することもできます。</target>
        </trans-unit>
        <trans-unit id="4e8708ee403dc8bba50752b03a6d6d4b4352acb0" translate="yes" xml:space="preserve">
          <source>It is also possible to add an &amp;ldquo;else block&amp;rdquo; with &lt;code&gt;v-else&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;v-else&lt;/code&gt; を使用して「elseブロック」を追加することもできます。</target>
        </trans-unit>
        <trans-unit id="2528b05b485478cec60d8b3a4617e597495c046e" translate="yes" xml:space="preserve">
          <source>It is also possible to call a method directly from a template. As we'll see shortly, it's usually better to use a &lt;a href=&quot;computed&quot;&gt;computed property&lt;/a&gt; instead. However, using a method can be useful in scenarios where computed properties aren't a viable option. You can call a method anywhere that a template supports JavaScript expressions:</source>
          <target state="translated">テンプレートから直接メソッドを呼び出すこともできます。後で説明しますが、通常は、代わりに&lt;a href=&quot;computed&quot;&gt;計算プロパティ&lt;/a&gt;を使用することをお勧めします。ただし、メソッドの使用は、計算されたプロパティが実行可能なオプションではないシナリオで役立つ場合があります。テンプレートがJavaScript式をサポートしている場所であればどこでもメソッドを呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="821ab047e92b1bb797a359c27dd615c7dcb8237f" translate="yes" xml:space="preserve">
          <source>It is also possible to use a JavaScript expression in a directive argument by wrapping it with square brackets:</source>
          <target state="translated">また、JavaScriptの式を角括弧で囲むことで、ディレクティブの引数に使用することも可能です。</target>
        </trans-unit>
        <trans-unit id="f11aad10ac88ab1f4f9941c1804dfd826b7419eb" translate="yes" xml:space="preserve">
          <source>It is best to provide all the information the user needs to fill out forms outside any inputs.</source>
          <target state="translated">ユーザーが必要とするすべての情報を、任意の入力以外のフォームに記入して提供するのがベストです。</target>
        </trans-unit>
        <trans-unit id="42c0231656f976858a53174ef4b684db8fe6384f" translate="yes" xml:space="preserve">
          <source>It is highly recommended that you document all of the events emitted by each of your components using &lt;code&gt;emits&lt;/code&gt;.</source>
          <target state="translated">非常にあなたが使用してコンポーネントの各々によって放出されたイベントのすべて文書化することが推奨され &lt;code&gt;emits&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b1e03924ee6970dca117928a311e1533f2014100" translate="yes" xml:space="preserve">
          <source>It is no longer supported to have &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt;s with the same name in the same template. When a slot is rendered it is &amp;ldquo;used up&amp;rdquo; and cannot be rendered elsewhere in the same render tree. If you must render the same content in multiple places, pass that content as a prop.</source>
          <target state="translated">同じテンプレートに同じ名前の &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; を含めることはサポートされなくなりました。スロットがレンダリングされると、そのスロットは「使い切られ」、同じRender Treeの他の場所にはレンダリングできません。同じコンテンツを複数の場所にレンダリングする必要がある場合は、そのコンテンツを小道具として渡します。</target>
        </trans-unit>
        <trans-unit id="d9093e211b6a6e41ed8691587734eee35acd8952" translate="yes" xml:space="preserve">
          <source>It is now prohibited to replace a component instance&amp;rsquo;s root $data. This prevents some edge cases in the reactivity system and makes the component state more predictable (especially with type-checking systems).</source>
          <target state="translated">現在、コンポーネントインスタンスのルート$ dataを置き換えることは禁止されています。これにより、反応性システムの一部のエッジケースが防止され、コンポーネントの状態がより予測可能になります（特に、型チェックシステムを使用）。</target>
        </trans-unit>
        <trans-unit id="7ae415c6af2657c64c911e26e414175ec588acbe" translate="yes" xml:space="preserve">
          <source>It is often a good idea to bind to a style object directly so that the template is cleaner:</source>
          <target state="translated">スタイルオブジェクトに直接バインドした方がテンプレートがすっきりすることが多いです。</target>
        </trans-unit>
        <trans-unit id="1576748fb05ab8ce1c2e6c48f332f0a5704cb1b7" translate="yes" xml:space="preserve">
          <source>It is often overlooked that the source of truth in Vue applications is the raw &lt;code&gt;data&lt;/code&gt; object - a Vue instance only proxies access to it. Therefore, if you have a piece of state that should be shared by multiple instances, you can share it by identity:</source>
          <target state="translated">Vueアプリケーションの真実のソースが生 &lt;code&gt;data&lt;/code&gt; オブジェクトであることはしばしば見落とされています-Vueインスタンスはアクセスをプロキシするだけです。したがって、複数のインスタンスで共有する必要がある状態がある場合は、IDで共有できます。</target>
        </trans-unit>
        <trans-unit id="bc0742430bf64e7ed852fa2fe5b348a0bbd7e7ff" translate="yes" xml:space="preserve">
          <source>It is often overlooked that the source of truth in Vue applications is the reactive &lt;code&gt;data&lt;/code&gt; object - a component instance only proxies access to it. Therefore, if you have a piece of state that should be shared by multiple instances, you can use a &lt;a href=&quot;reactivity-fundamentals#declaring-reactive-state&quot;&gt;reactive&lt;/a&gt; method to make an object reactive:</source>
          <target state="translated">Vueアプリケーションの信頼できる情報源がリアクティブ &lt;code&gt;data&lt;/code&gt; オブジェクトであるということは見過ごされがちです。コンポーネントインスタンスは、そのオブジェクトへのアクセスをプロキシするだけです。したがって、複数のインスタンスで共有する必要のある状態がある場合は、&lt;a href=&quot;reactivity-fundamentals#declaring-reactive-state&quot;&gt;リアクティブ&lt;/a&gt;メソッドを使用してオブジェクトをリアクティブにすることができます。</target>
        </trans-unit>
        <trans-unit id="5941b8bede80f37fd666d64ae0a8585594d8e00a" translate="yes" xml:space="preserve">
          <source>It is possible to add a new property directly to the component instance without including it in &lt;code&gt;data&lt;/code&gt;. However, because this property isn't backed by the reactive &lt;code&gt;$data&lt;/code&gt; object, it won't automatically be tracked by &lt;a href=&quot;reactivity&quot;&gt;Vue's reactivity system&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 含めずに、コンポーネントインスタンスに新しいプロパティを直接追加することができます。ただし、このプロパティはリアクティブ &lt;code&gt;$data&lt;/code&gt; オブジェクトによってサポートされていないため、&lt;a href=&quot;reactivity&quot;&gt;Vueの&lt;/a&gt;リアクティブシステムによって自動的に追跡されることはありません。</target>
        </trans-unit>
        <trans-unit id="37285a48f031be7bbbf86e2ffcd3313292517a4b" translate="yes" xml:space="preserve">
          <source>It is recommended to avoid using both on the same element due to the syntax ambiguity.</source>
          <target state="translated">構文が曖昧なので、同じ要素で両方を使用するのは避けることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="751efadc9528a2e4327d95ba9475fe587b4ec316" translate="yes" xml:space="preserve">
          <source>It is recommended to define all emitted events in order to better document how a component should work.</source>
          <target state="translated">コンポーネントがどのように動作するかをより良く文書化するために、すべての放出イベントを定義することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="41c09ac650c82070b83c3fbdfde0270b1b2629a2" translate="yes" xml:space="preserve">
          <source>It is recommended to provide a &lt;code&gt;key&lt;/code&gt; attribute with &lt;code&gt;v-for&lt;/code&gt; whenever possible, unless the iterated DOM content is simple, or you are intentionally relying on the default behavior for performance gains.</source>
          <target state="translated">反復されたDOMコンテンツが単純である場合、またはパフォーマンス向上のためにデフォルトの動作に意図的に依存している場合を除き、可能な限り、 &lt;code&gt;key&lt;/code&gt; 属性に &lt;code&gt;v-for&lt;/code&gt; を提供することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="9f05d3baca3585e87a234c817a735dc07843bbe4" translate="yes" xml:space="preserve">
          <source>It is recommended to use &lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;VSCode (opens new window)&lt;/a&gt; with our official extension &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=octref.vetur&quot;&gt;Vetur (opens new window)&lt;/a&gt;, which provides comprehensive IDE support for Vue 3.</source>
          <target state="translated">Vue 3の包括的なIDEサポートを提供&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=octref.vetur&quot;&gt;する&lt;/a&gt;公式の拡張機能Vetur（新しいウィンドウを開く&lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;）&lt;/a&gt;とともにVSCode（新しいウィンドウを開く）を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="a7779dc053f2ed486b907c53be703697ec71f15b" translate="yes" xml:space="preserve">
          <source>It is recommended to use landmark HTML elements with redundant landmark role attributes in order to maximize compatibility with legacy &lt;a href=&quot;https://caniuse.com/#feat=html5semantic&quot;&gt;browsers that don&amp;rsquo;t support HTML5 semantic elements (opens new window)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://caniuse.com/#feat=html5semantic&quot;&gt;HTML5セマンティック要素をサポートしない（新しいウィンドウを開く）&lt;/a&gt;レガシーブラウザとの互換性を最大化するために、冗長なランドマークロール属性を持つランドマークHTML要素を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="158301256c28a9020989b897a8c306e76ca398cb" translate="yes" xml:space="preserve">
          <source>It mostly works well, but the delayed state updates can cause strange behavior. For example, click on the &lt;code&gt;Result&lt;/code&gt; tab and try entering &lt;code&gt;9.999&lt;/code&gt; into one of those inputs. When the input loses focus, its value will update to &lt;code&gt;$10.00&lt;/code&gt;. When looking at the calculated total however, you&amp;rsquo;ll see that &lt;code&gt;9.999&lt;/code&gt; is what&amp;rsquo;s stored in our data. The version of reality that the user sees is out of sync!</source>
          <target state="translated">ほとんど正常に動作しますが、状態の更新が遅れると奇妙な動作が発生する可能性があります。たとえば、[ &lt;code&gt;Result&lt;/code&gt; ]タブをクリックして、これらの入力の1つに &lt;code&gt;9.999&lt;/code&gt; を入力してみます。入力がフォーカスを失うと、その値は &lt;code&gt;$10.00&lt;/code&gt; 更新されます。ただし、計算された合計を見ると、 &lt;code&gt;9.999&lt;/code&gt; がデータに格納されていることがわかります。ユーザーが見る現実のバージョンは同期していません！</target>
        </trans-unit>
        <trans-unit id="5c7b220831f2244cc3f3b0618d0e11be1b6ee123" translate="yes" xml:space="preserve">
          <source>It only offers a single template that assumes you&amp;rsquo;re building a single-page application, while Vue offers a wide variety of default options for various purposes and build systems.</source>
          <target state="translated">これは、単一ページのアプリケーションを構築していることを想定した単一のテンプレートのみを提供しますが、Vueは、さまざまな目的とシステムの構築のための幅広いデフォルトオプションを提供します。</target>
        </trans-unit>
        <trans-unit id="d429d77b592d7a12031c03e84167b80ce44e01ac" translate="yes" xml:space="preserve">
          <source>It requires saving the &lt;code&gt;picker&lt;/code&gt; to the component instance, when it&amp;rsquo;s possible that only lifecycle hooks need access to it. This isn&amp;rsquo;t terrible, but it could be considered clutter.</source>
          <target state="translated">ライフサイクルフックのみにアクセスする必要がある可能性がある場合は、 &lt;code&gt;picker&lt;/code&gt; をコンポーネントインスタンスに保存する必要があります。これはひどいことではありませんが、乱雑と見なされる可能性があります。</target>
        </trans-unit>
        <trans-unit id="4498754208578dfe241aa59ce513436b21cdefe3" translate="yes" xml:space="preserve">
          <source>It should be no surprise that one of the first criteria is that a component testing library should have is being as compatible with the Vue ecosystem as possible. While this may seem comprehensive, some key integration areas to keep in mind include single file components (SFCs), Vuex, Vue Router, and any other Vue specific plugins that your application relies on.</source>
          <target state="translated">コンポーネント テスト ライブラリが持つべき最初の基準の 1 つは、Vue エコシステムと可能な限り互換性があることです。これは包括的に見えるかもしれませんが、心に留めておくべき重要な統合領域には、シングルファイルコンポーネント(SFC)、Vuex、Vue Router、およびアプリケーションが依存しているその他の Vue 固有のプラグインが含まれています。</target>
        </trans-unit>
        <trans-unit id="6c27ec712f1c3f7f2e2036cb2ee97cb69409b690" translate="yes" xml:space="preserve">
          <source>It should be noted that &lt;strong&gt;these limitations do &lt;em&gt;not&lt;/em&gt; apply if you are using string templates from one of the following sources&lt;/strong&gt;:</source>
          <target state="translated">ことに留意すべきである&lt;strong&gt;これらの制限がない&lt;em&gt;ではない&lt;/em&gt;あなたは、次のいずれかのソースから文字列テンプレートを使用している場合に適用されます&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="2b6375c65084a2fbe49aa4574ab7168511258809" translate="yes" xml:space="preserve">
          <source>It should be noted that &lt;strong&gt;this limitation does &lt;em&gt;not&lt;/em&gt; apply if you are using string templates from one of the following sources&lt;/strong&gt;:</source>
          <target state="translated">ことに留意すべきで&lt;strong&gt;、この制限がない&lt;em&gt;ではない&lt;/em&gt;あなたは、次のいずれかのソースから文字列テンプレートを使用している場合に適用されます&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="59833298d090a415397bceadf5ff0bd3a66b0de9" translate="yes" xml:space="preserve">
          <source>It will render:</source>
          <target state="translated">レンダリングします。</target>
        </trans-unit>
        <trans-unit id="13566b680265d72cb595dc1be3858a3b3f978e1f" translate="yes" xml:space="preserve">
          <source>It would be much nicer if we could collocate code related to the same logical concern. And this is exactly what the Composition API enables us to do.</source>
          <target state="translated">同じ論理的な関心事に関連するコードを並べることができれば、より良いものになるでしょう。そして、これはまさにコンポジションAPIが可能にしてくれるものです。</target>
        </trans-unit>
        <trans-unit id="e8131a6805d411d3c8871b6a4ec5d84d6d47f8b3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s actually possible to transition between any number of elements, either by using multiple &lt;code&gt;v-if&lt;/code&gt;s or binding a single element to a dynamic property. For example:</source>
          <target state="translated">実際には、複数の &lt;code&gt;v-if&lt;/code&gt; を使用するか、単一の要素を動的プロパティにバインドすることにより、任意の数の要素間を遷移できます。例えば：</target>
        </trans-unit>
        <trans-unit id="1f0eec334e7b1ca80024f1af665b1bef3cd4f2a0" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also a good idea to explicitly add &lt;code&gt;v-bind:css=&quot;false&quot;&lt;/code&gt; for JavaScript-only transitions so that Vue can skip the CSS detection. This also prevents CSS rules from accidentally interfering with the transition.</source>
          <target state="translated">JavaScriptのみのトランジションに対して &lt;code&gt;v-bind:css=&quot;false&quot;&lt;/code&gt; を明示的に追加して、VueがCSS検出をスキップできるようにすることもお勧めします。これにより、CSSルールが誤って移行を妨害することも防ぎます。</target>
        </trans-unit>
        <trans-unit id="ea8bac071f56eff3c599037448c4745e3f78f107" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common for an app to be organized into a tree of nested components:</source>
          <target state="translated">アプリがネストされたコンポーネントのツリーに編成されるのは一般的です：</target>
        </trans-unit>
        <trans-unit id="529381524bf490d0fa30c365c3a6643e1ab87406" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easier to locate the handler function implementations within your JS code by skimming the HTML template.</source>
          <target state="translated">HTMLテンプレートを読み飛ばすことで、JSコード内でハンドラー関数の実装を簡単に見つけることができます。</target>
        </trans-unit>
        <trans-unit id="3cb4d6d25e874e731b1a5bd3fcf3592c111ac7d3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to toggle the presence of an element, too:</source>
          <target state="translated">要素の存在を切り替えるのも簡単です：</target>
        </trans-unit>
        <trans-unit id="e8a1b4e2622ff4412a28418661a05714360fa046" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that many of these limitations are intentional design decisions made by the create-react-app team and they do have their advantages. For example, as long as your project&amp;rsquo;s needs are very simple and you never need to &amp;ldquo;eject&amp;rdquo; to customize your build process, you&amp;rsquo;ll be able to update it as a dependency. You can read more about the &lt;a href=&quot;https://github.com/facebookincubator/create-react-app#philosophy&quot;&gt;differing philosophy here&lt;/a&gt;.</source>
          <target state="translated">これらの制限の多くは、create-react-appチームによる意図的な設計上の決定であり、それらには利点があることに注意することが重要です。たとえば、プロジェクトのニーズが非常にシンプルで、ビルドプロセスをカスタマイズするために「イジェクト」する必要がない場合は、依存関係としてプロジェクトを更新できます。&lt;a href=&quot;https://github.com/facebookincubator/create-react-app#philosophy&quot;&gt;異なる哲学&lt;/a&gt;について詳しくは、こちらをご覧ください。</target>
        </trans-unit>
        <trans-unit id="eba37741216bb34acb503b7bccb11a46196d44f7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that you should never replace the original state object in your actions - the components and the store need to share reference to the same object in order for mutations to be observed.</source>
          <target state="translated">アクションで元の状態オブジェクトを決して置き換えてはならないことに注意することが重要です。コンポーネントとストアは、変化が観察されるために同じオブジェクトへの参照を共有する必要があります。</target>
        </trans-unit>
        <trans-unit id="471a1dd215ec1df9cced88727c09d955351467bb" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s rare that global components are ever referenced in JavaScript, so following a convention for JavaScript makes less sense.</source>
          <target state="translated">JavaScriptでグローバルコンポーネントが参照されることはめったにないため、JavaScriptの規則に従うことはあまり意味がありません。</target>
        </trans-unit>
        <trans-unit id="6dbbee3b3142d705f32e4ea9a33d016015abd4b0" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s recommended to wrap the entire contents in a new element, like this:</source>
          <target state="translated">次のように、コンテンツ全体を新しい要素でラップすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="fb69fc29789fe29cf276273312bfe243527744c9" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s sometimes useful to emit a specific value with an event. For example, we may want the &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; component to be in charge of how much to enlarge the text by. In those cases, we can use &lt;code&gt;$emit&lt;/code&gt;&amp;lsquo;s 2nd parameter to provide this value:</source>
          <target state="translated">イベントで特定の値を出力すると便利な場合があります。たとえば、 &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; コンポーネントがテキストをどれだけ拡大するかを担当する場合があります。このような場合、 &lt;code&gt;$emit&lt;/code&gt; の2番目のパラメーターを使用して、この値を提供できます。</target>
        </trans-unit>
        <trans-unit id="8852ff75403c297afd1a8a3cdb0552cf73fe06bf" translate="yes" xml:space="preserve">
          <source>It's actually possible to transition between any number of elements, either by using &lt;code&gt;v-if&lt;/code&gt;/&lt;code&gt;v-else-if&lt;/code&gt;/&lt;code&gt;v-else&lt;/code&gt; or binding a single element to a dynamic property. For example:</source>
          <target state="translated">実際には、 &lt;code&gt;v-if&lt;/code&gt; / &lt;code&gt;v-else-if&lt;/code&gt; / &lt;code&gt;v-else&lt;/code&gt; を使用するか、単一の要素を動的プロパティにバインドすることにより、任意の数の要素間で遷移することができます。例えば：</target>
        </trans-unit>
        <trans-unit id="ad47c16fba81b79a86241bf8888fad85c94ce363" translate="yes" xml:space="preserve">
          <source>It's common for an app to be organized into a tree of nested components:</source>
          <target state="translated">アプリは、ネストされたコンポーネントのツリーに編成されるのが一般的です。</target>
        </trans-unit>
        <trans-unit id="6af319375896cfcb2ac29299a5aeee693d621695" translate="yes" xml:space="preserve">
          <source>It's easier to locate the handler function implementations within your JS code by skimming the HTML template.</source>
          <target state="translated">HTML テンプレートをスキップすることで、JS コード内のハンドラ関数の実装を簡単に見つけることができます。</target>
        </trans-unit>
        <trans-unit id="a17ba0c11ce9ca8328a5aebef189aaa88d9ead34" translate="yes" xml:space="preserve">
          <source>It's easy to toggle the presence of an element, too:</source>
          <target state="translated">要素の有無の切り替えも簡単です。</target>
        </trans-unit>
        <trans-unit id="f5cd7c29493393f218043384194d7b5510c8dde1" translate="yes" xml:space="preserve">
          <source>It's generally recommended to keep directives independent of the component instance they are used in. Accessing the instance from within a custom directive is often a sign that the directive should rather be a component itself. However, there are situations where this actually makes sense.</source>
          <target state="translated">一般的には、ディレクティブをコンポーネントのインスタンスから独立したものにしておくことが推奨されています。カスタムディレクティブの中からインスタンスにアクセスすることは、 ディレクティブがコンポーネントそのものであるべきであることを示すことがよくあります。しかし、これが実際には意味のある状況もあります。</target>
        </trans-unit>
        <trans-unit id="1f29b81017a607c886e9905a378f2d9bd55f8c75" translate="yes" xml:space="preserve">
          <source>It's important to note the runtime config only affects runtime template compilation - it won't affect pre-compiled templates.</source>
          <target state="translated">ランタイム設定はランタイムテンプレートのコンパイルにしか影響しないことに注意してください-コンパイル済みのテンプレートには影響しません。</target>
        </trans-unit>
        <trans-unit id="d2fd4ae770137b3e9b3a6d876b8827f3129a2fcc" translate="yes" xml:space="preserve">
          <source>It's much more common for a component to use &lt;code&gt;props&lt;/code&gt; than the other properties, and very often a component uses only &lt;code&gt;props&lt;/code&gt;.</source>
          <target state="translated">コンポーネントが他のプロパティよりも &lt;code&gt;props&lt;/code&gt; を使用することははるかに一般的であり、非常に多くの場合、コンポーネントは &lt;code&gt;props&lt;/code&gt; のみを使用します。</target>
        </trans-unit>
        <trans-unit id="aebac3eeeb53ba07a891673ff03acf90d6ccc73e" translate="yes" xml:space="preserve">
          <source>It's now much clearer what the difference between these states is.</source>
          <target state="translated">これらの州の違いが何であるかがはっきりしてきました。</target>
        </trans-unit>
        <trans-unit id="08a696ed981dd37807dbf8cb59239f76cfd4a209" translate="yes" xml:space="preserve">
          <source>It's rare that global components are ever referenced in JavaScript, so following a convention for JavaScript makes less sense.</source>
          <target state="translated">JavaScriptでグローバルコンポーネントが参照されることは稀なので、JavaScriptの規約に従うことはあまり意味がありません。</target>
        </trans-unit>
        <trans-unit id="320f04e4adc498746e8285c25d0174bb0a242c0d" translate="yes" xml:space="preserve">
          <source>It's sometimes useful to emit a specific value with an event. For example, we may want the &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; component to be in charge of how much to enlarge the text by. In those cases, we can pass a second parameter to &lt;code&gt;$emit&lt;/code&gt; to provide this value:</source>
          <target state="translated">イベントで特定の値を発行すると便利な場合があります。たとえば、 &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; コンポーネントで、テキストをどれだけ拡大するかを管理することができます。そのような場合、次の値を提供するために2番目のパラメーターを &lt;code&gt;$emit&lt;/code&gt; に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="6c7d46141f064bc144bcd65cad47e0b1500c6ec5" translate="yes" xml:space="preserve">
          <source>Iteration &amp;amp; Communication</source>
          <target state="translated">反復とコミュニケーション</target>
        </trans-unit>
        <trans-unit id="ab84ddacf62192827bb778b54f0d73df28c81a56" translate="yes" xml:space="preserve">
          <source>Its guiding principle is that the more tests resemble the way software is used, the more confidence they can provide.</source>
          <target state="translated">その指針となる原則は、ソフトウェアの使用方法に似たテストが多いほど、自信を持って提供できるということです。</target>
        </trans-unit>
        <trans-unit id="51cc248e464b2aea646387386136d3ee2f3468fd" translate="yes" xml:space="preserve">
          <source>JAWS (opens new window)</source>
          <target state="translated">JAWS (新しいウィンドウが開きます)</target>
        </trans-unit>
        <trans-unit id="0e4779d05c5a545a6bd2f3323d3fe430a37f5d7b" translate="yes" xml:space="preserve">
          <source>JSX</source>
          <target state="translated">JSX</target>
        </trans-unit>
        <trans-unit id="acc00892c117ef61e4f9ab3d9331cb95e0f00caa" translate="yes" xml:space="preserve">
          <source>JSX vs Templates</source>
          <target state="translated">JSXとテンプレート</target>
        </trans-unit>
        <trans-unit id="48785657daead33de8f57e1fb9950e0b74a5ba21" translate="yes" xml:space="preserve">
          <source>JavaScript Expressions</source>
          <target state="translated">JavaScriptの表現</target>
        </trans-unit>
        <trans-unit id="de6da78717be0e5457a235494d2556f25b2595f3" translate="yes" xml:space="preserve">
          <source>JavaScript Hooks</source>
          <target state="translated">JavaScriptフック</target>
        </trans-unit>
        <trans-unit id="6cea98e1f2bba3a82d53ff16b1849c803f2e2665" translate="yes" xml:space="preserve">
          <source>JavaScript doesn&amp;rsquo;t usually work like this -- If we were to write something comparable in JavaScript:</source>
          <target state="translated">JavaScriptは通常このようには機能しません-JavaScriptで同等の何かを書くとしたら：</target>
        </trans-unit>
        <trans-unit id="b2bdc615d0b1e25db680b5ea62ca160d5e24612e" translate="yes" xml:space="preserve">
          <source>JavaScript&amp;rsquo;s native &lt;code&gt;.filter&lt;/code&gt; can also manage much more complex filtering operations, because you have access to the full power of JavaScript within computed properties. For example, if you wanted to find all active users and case-insensitively match against both their name and email:</source>
          <target state="translated">JavaScriptのネイティブ &lt;code&gt;.filter&lt;/code&gt; は、計算されたプロパティ内のJavaScriptの全機能にアクセスできるため、はるかに複雑なフィルタリング操作も管理できます。たとえば、すべてのアクティブユーザーを検索し、大文字と小文字を区別せずに、ユーザーの名前と電子メールの両方に対して一致させる場合：</target>
        </trans-unit>
        <trans-unit id="c7afff3f789cd350ad5ef2e0ccd58b4b677f1d64" translate="yes" xml:space="preserve">
          <source>Jest</source>
          <target state="translated">Jest</target>
        </trans-unit>
        <trans-unit id="a46d5413cffceb72c83f4112df056475b52ee003" translate="yes" xml:space="preserve">
          <source>Jest is a JavaScript test framework that is focused on simplicity. One of its unique features is the ability to take snapshots of tests in order to provide an alternative means of verifying units of your application.</source>
          <target state="translated">Jest はシンプルさに焦点を当てた JavaScript テストフレームワークです。そのユニークな機能の一つは、アプリケーションのユニットを検証するための代替手段を提供するために、テストのスナップショットを取る機能です。</target>
        </trans-unit>
        <trans-unit id="be4bdcf0feb91c266b9ddb8530b4392dc9b7e35e" translate="yes" xml:space="preserve">
          <source>Join the Vue.js Community!</source>
          <target state="translated">Vue.jsコミュニティに参加してみませんか?</target>
        </trans-unit>
        <trans-unit id="b05d0122984642cf7090c52ffdac8dd94d5f6d18" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;is&lt;/code&gt;, &lt;code&gt;resolveDynamicComponent&lt;/code&gt; supports passing a component name, an HTML element name, or a component options object.</source>
          <target state="translated">と同様 &lt;code&gt;is&lt;/code&gt; 、 &lt;code&gt;resolveDynamicComponent&lt;/code&gt; は、コンポーネント名、HTML要素名、またはコンポーネントオプションオブジェクトの受け渡しをサポートしています。</target>
        </trans-unit>
        <trans-unit id="91b48b329205efd9bbd9fce3544a036c29c0a8fa" translate="yes" xml:space="preserve">
          <source>Just like all other properties of the component instance, the &lt;code&gt;methods&lt;/code&gt; are accessible from within the component's template. Inside a template they are most commonly used as event listeners:</source>
          <target state="translated">コンポーネントインスタンスの他のすべてのプロパティと同様に、 &lt;code&gt;methods&lt;/code&gt; はコンポーネントのテンプレート内からアクセスできます。テンプレート内では、イベントリスナーとして最も一般的に使用されます。</target>
        </trans-unit>
        <trans-unit id="2aa1596972789e18182ccfc21abdfcfd9e0ff36e" translate="yes" xml:space="preserve">
          <source>Just like how we set up a watcher on the &lt;code&gt;user&lt;/code&gt; property inside our component using the &lt;code&gt;watch&lt;/code&gt; option, we can do the same using the &lt;code&gt;watch&lt;/code&gt; function imported from Vue. It accepts 3 arguments:</source>
          <target state="translated">&lt;code&gt;watch&lt;/code&gt; オプションを使用してコンポーネント内の &lt;code&gt;user&lt;/code&gt; プロパティにウォッチャーを設定する方法と同じように、Vueからインポートされた &lt;code&gt;watch&lt;/code&gt; 関数を使用して同じことを行うことができます。3つの引数を受け入れます。</target>
        </trans-unit>
        <trans-unit id="61cbea5eb9c474841bbd881e5ab4ec7c34f644ee" translate="yes" xml:space="preserve">
          <source>Just like with HTML elements, it&amp;rsquo;s often useful to be able to pass content to a component, like this:</source>
          <target state="translated">HTML要素と同様に、次のように、コンテンツをコンポーネントに渡すことができると便利です。</target>
        </trans-unit>
        <trans-unit id="a98b5180199c5ab496bb93100cd4afe9c3a4168f" translate="yes" xml:space="preserve">
          <source>Just like with HTML elements, it's often useful to be able to pass content to a component, like this:</source>
          <target state="translated">HTML要素と同じように、このようにコンポーネントにコンテンツを渡すことができると便利なことが多いです。</target>
        </trans-unit>
        <trans-unit id="027fca0ba6266bff1583f80f2ced47d62346398f" translate="yes" xml:space="preserve">
          <source>Just to support relatively little markup in a template:</source>
          <target state="translated">テンプレート内のマークアップが比較的少ないのをサポートするためだけに。</target>
        </trans-unit>
        <trans-unit id="ba65d86ead17c56d628584a8788a419c56876378" translate="yes" xml:space="preserve">
          <source>Keep in mind that we've only scratched the surface of Composition API and what it allows us to do. To learn more about it, refer to the in-depth guide.</source>
          <target state="translated">コンポジションAPIとそれによって何ができるようになるのかについては、まだ表面上のことしか知らないことを覚えておいてください。それについてもっと詳しく知りたい場合は、詳細なガイドを参照してください。</target>
        </trans-unit>
        <trans-unit id="d66c8dcebdd2226f233aec952c13c29103045708" translate="yes" xml:space="preserve">
          <source>Keep in mind, however, that components built with this pattern are still inherently fragile. For example, imagine we add a new &lt;code&gt;&amp;lt;google-map-region&amp;gt;&lt;/code&gt; component and when &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; appears within that, it should only render markers that fall within that region:</source>
          <target state="translated">ただし、このパターンで構築されたコンポーネントは依然として本質的に壊れやすいことに注意してください。たとえば、新しい &lt;code&gt;&amp;lt;google-map-region&amp;gt;&lt;/code&gt; コンポーネントを追加し、その中に &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; が表示された場合、そのリージョン内にあるマーカーのみをレンダリングする必要があるとします。</target>
        </trans-unit>
        <trans-unit id="467e7f276ee2b9a2f53b3949e288efde8bd26ea9" translate="yes" xml:space="preserve">
          <source>Key Aliases</source>
          <target state="translated">キーエイリアス</target>
        </trans-unit>
        <trans-unit id="6da44efd57019ab966f7e6f60ef152a26f453f56" translate="yes" xml:space="preserve">
          <source>Key Codes</source>
          <target state="translated">キーコード</target>
        </trans-unit>
        <trans-unit id="c2970ed4e4bcc1bc09ed400bc881c877da7aa156" translate="yes" xml:space="preserve">
          <source>Key Modifiers</source>
          <target state="translated">キー修飾子</target>
        </trans-unit>
        <trans-unit id="6c5f93229012cbadeede1c515b6352e435db9e2b" translate="yes" xml:space="preserve">
          <source>KeyCode Modifiers</source>
          <target state="translated">キーコード修飾子</target>
        </trans-unit>
        <trans-unit id="3e3436c44b271fc9f4ddc4a5694abe70d414be31" translate="yes" xml:space="preserve">
          <source>Keyed &lt;code&gt;v-for&lt;/code&gt;&lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">キー付き &lt;code&gt;v-for&lt;/code&gt; &lt;sup&gt;エッセンシャル&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="c75c97df0a3fadad8262ee8e7d09b174b5374e8e" translate="yes" xml:space="preserve">
          <source>Keyed v-for</source>
          <target state="translated">キー付きVフォー</target>
        </trans-unit>
        <trans-unit id="9cf20628a323dc6f8efd78ac79c3f26ce8cbd3a6" translate="yes" xml:space="preserve">
          <source>Keys:</source>
          <target state="translated">Keys:</target>
        </trans-unit>
        <trans-unit id="bb23b6faea770d3a5e16178dbc59584678b24aa0" translate="yes" xml:space="preserve">
          <source>Knockout</source>
          <target state="translated">Knockout</target>
        </trans-unit>
        <trans-unit id="bc0968409752cc62e7fa235b2d725b7b8c2c6eb5" translate="yes" xml:space="preserve">
          <source>Knockout was a pioneer in the MVVM and dependency tracking spaces and its reactivity system is very similar to Vue&amp;rsquo;s. Its &lt;a href=&quot;http://knockoutjs.com/documentation/browser-support.html&quot;&gt;browser support&lt;/a&gt; is also very impressive considering everything it does, with support back to IE6! Vue on the other hand only supports IE9+.</source>
          <target state="translated">KnockoutはMVVMおよび依存関係追跡スペースのパイオニアであり、その反応性システムはVueのそれに非常に似ています。その&lt;a href=&quot;http://knockoutjs.com/documentation/browser-support.html&quot;&gt;ブラウザーサポート&lt;/a&gt;も、IE6へのサポートとともに、すべてのことを考えると非常に印象的です！一方、VueはIE9 +のみをサポートしています。</target>
        </trans-unit>
        <trans-unit id="2228985493d9e43e461c7be5525529248735ad9c" translate="yes" xml:space="preserve">
          <source>Labels</source>
          <target state="translated">Labels</target>
        </trans-unit>
        <trans-unit id="e61cef41ba854e90306988f5c1e5bd34137d6595" translate="yes" xml:space="preserve">
          <source>Labels are typically placed on top or to the left of the form fields:</source>
          <target state="translated">ラベルは通常、フォームフィールドの上部または左側に配置されます。</target>
        </trans-unit>
        <trans-unit id="f24edb29b6ba5554a247bb7953f4370fb8f7aae0" translate="yes" xml:space="preserve">
          <source>Landmark Purpose</source>
          <target state="translated">ランドマークの目的</target>
        </trans-unit>
        <trans-unit id="626b6c1d454d11a862220dbe8b7b34d0bcd6de9d" translate="yes" xml:space="preserve">
          <source>Landmarks</source>
          <target state="translated">Landmarks</target>
        </trans-unit>
        <trans-unit id="ec1be2a3865871adce929dfefc2959c96918a558" translate="yes" xml:space="preserve">
          <source>Landmarks provide programmatic access to sections within an application. Users who rely on assistive technology can navigate to each section of the application and skip over content. You can use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles&quot;&gt;ARIA roles (opens new window)&lt;/a&gt; to help you achieve this.</source>
          <target state="translated">ランドマークは、アプリケーション内のセクションへのプログラムによるアクセスを提供します。支援技術に依存しているユーザーは、アプリケーションの各セクションに移動して、コンテンツをスキップできます。これを実現するために、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles&quot;&gt;ARIAロール（新しいウィンドウを開く）&lt;/a&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="a8d8aa2835fc3129b6920d079159549c156fa63c" translate="yes" xml:space="preserve">
          <source>Large applications can often grow in complexity, due to multiple pieces of state scattered across many components and the interactions between them. To solve this problem, Vue offers &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;vuex&lt;/a&gt;: our own Elm-inspired state management library. It even integrates into &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt;, providing zero-setup access to &lt;a href=&quot;https://raw.githubusercontent.com/vuejs/vue-devtools/master/media/demo.gif&quot;&gt;time travel debugging&lt;/a&gt;.</source>
          <target state="translated">大規模なアプリケーションは、多くのコンポーネントに分散している複数の状態とそれらの間の相互作用により、複雑さが増すことがよくあります。この問題を解決するために、Vueは&lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;vuexを&lt;/a&gt;提供しています。これは、エルムにインスパイアされた独自の状態管理ライブラリです。さらに、&lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtoolsに&lt;/a&gt;統合して、&lt;a href=&quot;https://raw.githubusercontent.com/vuejs/vue-devtools/master/media/demo.gif&quot;&gt;タイムトラベルデバッグ&lt;/a&gt;へのセットアップ不要のアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="af32dbeca45c38e1ab5bbca67861fc2b513411a7" translate="yes" xml:space="preserve">
          <source>Large applications can often grow in complexity, due to multiple pieces of state scattered across many components and the interactions between them. To solve this problem, Vue offers &lt;a href=&quot;https://next.vuex.vuejs.org/&quot;&gt;Vuex (opens new window)&lt;/a&gt;, our own Elm-inspired state management library. It even integrates into &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools (opens new window)&lt;/a&gt;, providing zero-setup access to &lt;a href=&quot;https://raw.githubusercontent.com/vuejs/vue-devtools/master/media/demo.gif&quot;&gt;time travel debugging (opens new window)&lt;/a&gt;.</source>
          <target state="translated">大規模なアプリケーションは、多くのコンポーネントに散在する複数の状態とそれらの間の相互作用により、複雑さが増すことがよくあります。この問題を解決するために、Vueは独自のElmに着想を得た状態管理ライブラリである&lt;a href=&quot;https://next.vuex.vuejs.org/&quot;&gt;Vuex（新しいウィンドウを開きます）を&lt;/a&gt;提供しています。&lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools（新しいウィンドウを開く）&lt;/a&gt;にも統合され、&lt;a href=&quot;https://raw.githubusercontent.com/vuejs/vue-devtools/master/media/demo.gif&quot;&gt;タイムトラベルデバッグ（新しいウィンドウを開く&lt;/a&gt;）へのゼロセットアップアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="72406d3bbbb2f67e5c1e70370160f257ae0ba129" translate="yes" xml:space="preserve">
          <source>Lastly, the styling in Vue&amp;rsquo;s single-file components is very flexible. Through &lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;vue-loader&lt;/a&gt;, you can use any preprocessor, post-processor, and even deep integration with &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS Modules&lt;/a&gt; &amp;ndash; all within the &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">最後に、Vueの単一ファイルコンポーネントのスタイル設定は非常に柔軟です。スルー&lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;VUE-ローダー&lt;/a&gt;、あなたが持つ任意のプリプロセッサ、ポストプロセッサ、さらに深い統合に使用できる&lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSSモジュール&lt;/a&gt;内のすべてを- &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 要素。</target>
        </trans-unit>
        <trans-unit id="8c1e35e7e7dfbb463a1648c90eafb0e342703312" translate="yes" xml:space="preserve">
          <source>Latest stable version: 2.6.10</source>
          <target state="translated">最新の安定版:2.6.10</target>
        </trans-unit>
        <trans-unit id="25f41560444b01511b3f085284b9287b245c68e3" translate="yes" xml:space="preserve">
          <source>Latest version:</source>
          <target state="translated">最新版です。</target>
        </trans-unit>
        <trans-unit id="8bc4535d8b22b1a2065eb7b3e8da9f8806324bc4" translate="yes" xml:space="preserve">
          <source>Learn how to use teleport with a free lesson on Vue School</source>
          <target state="translated">ヴュースクールの無料レッスンでテレポートの使い方を学ぶ</target>
        </trans-unit>
        <trans-unit id="be0c59519c5e2b5fe13b0f7ff4bf498d719b4a7e" translate="yes" xml:space="preserve">
          <source>Learn more about dependency injection in &lt;a href=&quot;../api/index#provide-inject&quot;&gt;the API doc&lt;/a&gt;.</source>
          <target state="translated">依存関係注入の詳細については&lt;a href=&quot;../api/index#provide-inject&quot;&gt;、APIドキュメントを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="13b64b875178e4752802d8b808be11083d0726fa" translate="yes" xml:space="preserve">
          <source>Learning Curve</source>
          <target state="translated">学習曲線</target>
        </trans-unit>
        <trans-unit id="c8de89461bb526135e97877a49d087c4f8f53917" translate="yes" xml:space="preserve">
          <source>Leaves prod/dev branches with &lt;code&gt;process.env.NODE_ENV guards&lt;/code&gt; (must be replaced by bundler)</source>
          <target state="translated">prod / devブランチに &lt;code&gt;process.env.NODE_ENV guards&lt;/code&gt; を残します（bundleに置き換える必要があります）</target>
        </trans-unit>
        <trans-unit id="70fa6a52f9f95d2228d742b21a7f9256e534287a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s add &lt;code&gt;setup&lt;/code&gt; to our component:</source>
          <target state="translated">コンポーネントに &lt;code&gt;setup&lt;/code&gt; を追加しましょう：</target>
        </trans-unit>
        <trans-unit id="4d915f196841018fe83a9580c35cc5af5850df5c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s add it to our &lt;code&gt;setup&lt;/code&gt; function:</source>
          <target state="translated">それを &lt;code&gt;setup&lt;/code&gt; 関数に追加しましょう：</target>
        </trans-unit>
        <trans-unit id="0ccfd80d1c7d66dca3a0e6fc501777ae369d0d15" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s dive into a simple example where a &lt;code&gt;render&lt;/code&gt; function would be practical. Say you want to generate anchored headings:</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; 関数が実用的である簡単な例を見てみましょう。アンカーされた見出しを生成したいとします。</target>
        </trans-unit>
        <trans-unit id="17834c351c272bdff2a7fbc013f9102fea710211" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s imagine that in our app, we have a view to show a list of repositories of a certain user. On top of that, we want to apply search and filter capabilities. Our component handling this view could look like this:</source>
          <target state="translated">私たちのアプリで、特定のユーザーのリポジトリのリストを表示するビューがあると想像してみましょう。さらに、検索機能とフィルター機能を適用したいと考えています。このビューを処理するコンポーネントは、次のようになります。</target>
        </trans-unit>
        <trans-unit id="f97599b335f4e992e78c12be5dd024497eba4df8" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s move our search functionality into &lt;code&gt;setup&lt;/code&gt;:</source>
          <target state="translated">検索機能を &lt;code&gt;setup&lt;/code&gt; 移しましょう：</target>
        </trans-unit>
        <trans-unit id="8ae601ac39b42a0ce2f774ed4c117e44fb796a7c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you have a list of todos:</source>
          <target state="translated">ToDoリストのリストがあるとします。</target>
        </trans-unit>
        <trans-unit id="a0a681ce0e5b2dc3f8e587da2d3c87e6868974b2" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you want to make a custom directive that allows you to pin elements to your page using fixed positioning. We could create a custom directive where the value updates the vertical positioning in pixels, like this:</source>
          <target state="translated">固定位置を使用して要素をページに固定できるカスタムディレクティブを作成するとします。次のように、値が垂直位置をピクセル単位で更新するカスタムディレクティブを作成できます。</target>
        </trans-unit>
        <trans-unit id="2a858d496553eddcff13ca95af4e5a9c35dff1f6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you&amp;rsquo;re building a file directory tree, like in Finder or File Explorer. You might have a &lt;code&gt;tree-folder&lt;/code&gt; component with this template:</source>
          <target state="translated">Finderやエクスプローラなどのファイルディレクトリツリーを構築しているとしましょう。次のテンプレートを使用して、 &lt;code&gt;tree-folder&lt;/code&gt; コンポーネントがあるとします。</target>
        </trans-unit>
        <trans-unit id="6c99d3d3fdfa8bd3e1baa14373a303cb25022aea" translate="yes" xml:space="preserve">
          <source>Let's assume that we want to rewrite the following code, which contains a &lt;code&gt;MyMap&lt;/code&gt; component that provides a &lt;code&gt;MyMarker&lt;/code&gt; component with the user's location, using the Composition API.</source>
          <target state="translated">我々が含まれている次のコードを、書き直したいと仮定しましょう &lt;code&gt;MyMap&lt;/code&gt; 提供するコンポーネント &lt;code&gt;MyMarker&lt;/code&gt; の構成のAPIを使用して、ユーザの位置にコンポーネントを。</target>
        </trans-unit>
        <trans-unit id="ad199543d13fb602b1787ea12617af19cdac14b3" translate="yes" xml:space="preserve">
          <source>Let's begin by setting up the plugin object. It is recommended to create it in a separate file and export it, as shown below to keep the logic contained and separate.</source>
          <target state="translated">まずはプラグインオブジェクトの設定から始めましょう。以下のように、別ファイルで作成してエクスポートしておくと、ロジックを封じ込めて分離した状態を保つことができます。</target>
        </trans-unit>
        <trans-unit id="41a4107dc8befffcdc08d9bfc4c038af7438f2a1" translate="yes" xml:space="preserve">
          <source>Let's create an example custom modifier, &lt;code&gt;capitalize&lt;/code&gt;, that capitalizes the first letter of the string provided by the &lt;code&gt;v-model&lt;/code&gt; binding.</source>
          <target state="translated">&lt;code&gt;v-model&lt;/code&gt; バインディングによって提供される文字列の最初の文字を大文字にするカスタム修飾子 &lt;code&gt;capitalize&lt;/code&gt; の例を作成しましょう。</target>
        </trans-unit>
        <trans-unit id="9efaf7a4338ac2db9e77c15bcbe109038634f1e0" translate="yes" xml:space="preserve">
          <source>Let's dive deeper into how each argument can be used.</source>
          <target state="translated">それぞれの引数がどのように使えるのか、深く掘り下げてみましょう。</target>
        </trans-unit>
        <trans-unit id="965ee87d9a7fdfe5a2fefa407fc1fd4f95ef4d94" translate="yes" xml:space="preserve">
          <source>Let's dive into an example where a &lt;code&gt;render()&lt;/code&gt; function would be practical. Say we want to generate anchored headings:</source>
          <target state="translated">&lt;code&gt;render()&lt;/code&gt; 関数が実用的である例に飛び込みましょう。固定された見出しを生成するとします。</target>
        </trans-unit>
        <trans-unit id="042f68db1406bc20e0022ac27f2ee63637a48856" translate="yes" xml:space="preserve">
          <source>Let's look at this search field:</source>
          <target state="translated">この検索フィールドを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="c3b719b12c1068d11a2e6d04fa1b3077e20bd35b" translate="yes" xml:space="preserve">
          <source>Let's modify our &lt;code&gt;modal-button&lt;/code&gt; to use &lt;code&gt;&amp;lt;teleport&amp;gt;&lt;/code&gt; and tell Vue &quot;&lt;strong&gt;teleport&lt;/strong&gt; this HTML &lt;strong&gt;to&lt;/strong&gt; the &quot;&lt;strong&gt;body&lt;/strong&gt;&quot; tag&quot;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;teleport&amp;gt;&lt;/code&gt; を使用するように &lt;code&gt;modal-button&lt;/code&gt; を変更し、VueにこのHTML&lt;strong&gt;を&lt;/strong&gt;「&lt;strong&gt;body&lt;/strong&gt;」タグに&lt;strong&gt;テレポートする&lt;/strong&gt;ように指示しましょう。&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="098aabc545a2bc27663da4a434b6c0b7fe35c63e" translate="yes" xml:space="preserve">
          <source>Let's say you have a list of todos:</source>
          <target state="translated">トドのリストを持っているとしましょう。</target>
        </trans-unit>
        <trans-unit id="c3669759690ca7d10550e7dab45e8ba8a6d06189" translate="yes" xml:space="preserve">
          <source>Let's say you want to make a custom directive that allows you to pin elements to your page using fixed positioning. We could create a custom directive where the value updates the vertical positioning in pixels, like this:</source>
          <target state="translated">固定位置を使ってページに要素を固定できるようなカスタムディレクティブを作りたいとしましょう。このように、値が垂直方向の位置をピクセル単位で更新するようなカスタムディレクティブを作ることができます。</target>
        </trans-unit>
        <trans-unit id="16967b5d529c071e7c31b4b0d1d25c9f1bdbe5b1" translate="yes" xml:space="preserve">
          <source>Let's take a look at &lt;code&gt;modal-button&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;modal-button&lt;/code&gt; 見てみましょう。</target>
        </trans-unit>
        <trans-unit id="67530659cbfc12250ac15b4825a7142987ed4730" translate="yes" xml:space="preserve">
          <source>Library Authors</source>
          <target state="translated">図書館の著者</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MITライセンスに基づいてライセンスされています。</target>
        </trans-unit>
        <trans-unit id="963a6d001df804654ef3a7108a4f994e4ad3043d" translate="yes" xml:space="preserve">
          <source>Lifecycle Diagram</source>
          <target state="translated">ライフサイクル図</target>
        </trans-unit>
        <trans-unit id="2404fc2fb7f08994c22ba2e88d94f0289f80699e" translate="yes" xml:space="preserve">
          <source>Lifecycle Events (in the order they are called)</source>
          <target state="translated">ライフサイクルイベント(呼ばれている順</target>
        </trans-unit>
        <trans-unit id="e15c95b3b57b4bc9945881310c2f7fa52f895a6d" translate="yes" xml:space="preserve">
          <source>Lifecycle Hook Registration Inside &lt;code&gt;setup&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;setup&lt;/code&gt; 内のライフサイクルフック登録</target>
        </trans-unit>
        <trans-unit id="4e48f698aadae9546857e8298a5bcd17843d6036" translate="yes" xml:space="preserve">
          <source>Lifecycle Hooks</source>
          <target state="translated">ライフサイクルフック</target>
        </trans-unit>
        <trans-unit id="37857eb2e2aa8efab7a0ac716f62d18f83e34871" translate="yes" xml:space="preserve">
          <source>Lifecycle hooks</source>
          <target state="translated">ライフサイクルフック</target>
        </trans-unit>
        <trans-unit id="c76af71af244f2f6db8f83760d5be272f79f446b" translate="yes" xml:space="preserve">
          <source>Lifecycle hooks can be registered with directly-imported &lt;code&gt;onX&lt;/code&gt; functions:</source>
          <target state="translated">ライフサイクルフックは、直接インポートされた &lt;code&gt;onX&lt;/code&gt; 関数に登録できます。</target>
        </trans-unit>
        <trans-unit id="260f808c2d6d1ca9299afb5f45b0231a77889ebf" translate="yes" xml:space="preserve">
          <source>Lighthouse (opens new window)</source>
          <target state="translated">灯台(新しいウィンドウが開きます</target>
        </trans-unit>
        <trans-unit id="a47cbdd94a999f599791f292c086fca7922c6de4" translate="yes" xml:space="preserve">
          <source>Like components and props, event names provide an automatic case transformation. If you emit an event from the child component in camel case, you will be able to add a kebab-cased listener in the parent:</source>
          <target state="translated">コンポーネントや小道具と同様に、イベント名は自動的に大文字小文字を変換してくれます。子コンポーネントからキャメルケースでイベントを出すと、親コンポーネントにケバブケースのリスナーを追加できるようになります。</target>
        </trans-unit>
        <trans-unit id="63aded01a7c9673b7fc6a79a471f805a19e31546" translate="yes" xml:space="preserve">
          <source>Likewise for &lt;code&gt;altKey&lt;/code&gt;, &lt;code&gt;shiftKey&lt;/code&gt;, and &lt;code&gt;metaKey&lt;/code&gt;</source>
          <target state="translated">同様に、 &lt;code&gt;altKey&lt;/code&gt; 、 &lt;code&gt;shiftKey&lt;/code&gt; 、および &lt;code&gt;metaKey&lt;/code&gt; の場合</target>
        </trans-unit>
        <trans-unit id="4df77b1e0de2b6983ce6696ce595e7de4eec752e" translate="yes" xml:space="preserve">
          <source>Line Highlighting</source>
          <target state="translated">ラインハイライト</target>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="34959794ca38ca0b2f99ab6b512cce0bcb1574fd" translate="yes" xml:space="preserve">
          <source>List Entering/Leaving Transitions</source>
          <target state="translated">入退社・退社のトランジション一覧</target>
        </trans-unit>
        <trans-unit id="ec66c1c1aadebafa9aea3a9e5e78a70374186e6e" translate="yes" xml:space="preserve">
          <source>List Move Transitions</source>
          <target state="translated">リストの移動遷移</target>
        </trans-unit>
        <trans-unit id="97c5ac00feef7e4e4dea6fbc37427502208da0a0" translate="yes" xml:space="preserve">
          <source>List Rendering</source>
          <target state="translated">リストレンダリング</target>
        </trans-unit>
        <trans-unit id="7a1568935f8a040f0ddeb7118a253e76a0ba1ee0" translate="yes" xml:space="preserve">
          <source>List Rendering - &lt;code&gt;v-for&lt;/code&gt; with &lt;code&gt;v-if&lt;/code&gt;</source>
          <target state="translated">一覧レンダリング- &lt;code&gt;v-for&lt;/code&gt; と &lt;code&gt;v-if&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9b44b03037bd0f155ca305c63ebd74b1d0758424" translate="yes" xml:space="preserve">
          <source>List Rendering - Displaying Filtered/Sorted Results</source>
          <target state="translated">リストのレンダリング-フィルタリング/ソートされた結果の表示</target>
        </trans-unit>
        <trans-unit id="014a81574bf11dd8c3a37e832221bd011f6da627" translate="yes" xml:space="preserve">
          <source>List Rendering: Maintaining State</source>
          <target state="translated">リストのレンダリング。状態の維持</target>
        </trans-unit>
        <trans-unit id="66a9aa57e0afea8cd99a3f75a8c6d3489f047106" translate="yes" xml:space="preserve">
          <source>List Transitions</source>
          <target state="translated">リスト トランジション</target>
        </trans-unit>
        <trans-unit id="78b30713ef8e682cdf6d1254269a44a2a34f3330" translate="yes" xml:space="preserve">
          <source>Listen for a custom event on the current vm. Events can be triggered by &lt;code&gt;vm.$emit&lt;/code&gt;. The callback will receive all the additional arguments passed into these event-triggering methods.</source>
          <target state="translated">現在のVMでカスタムイベントをリッスンします。イベントは &lt;code&gt;vm.$emit&lt;/code&gt; によってトリガーできます。コールバックは、これらのイベントトリガーメソッドに渡されるすべての追加の引数を受け取ります。</target>
        </trans-unit>
        <trans-unit id="e49f77d4075cf41a76ef9beacb50d0f6b9aefcc0" translate="yes" xml:space="preserve">
          <source>Listen for a custom event, but only once. The listener will be removed once it triggers for the first time.</source>
          <target state="translated">カスタムイベントをリッスンしますが、一度だけです。リスナーは最初にトリガーされると削除されます。</target>
        </trans-unit>
        <trans-unit id="43e6ad0a03b8b1a9446a11f0e19551c8b4dc800d" translate="yes" xml:space="preserve">
          <source>Listen for an event only once with &lt;code&gt;$once(eventName, eventHandler)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$once(eventName, eventHandler)&lt;/code&gt; だけリッスンします</target>
        </trans-unit>
        <trans-unit id="696df6abce8abb54e8cd9a4d788b6b19b808783e" translate="yes" xml:space="preserve">
          <source>Listen for an event with &lt;code&gt;$on(eventName, eventHandler)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$on(eventName, eventHandler)&lt;/code&gt; イベントをリッスンします</target>
        </trans-unit>
        <trans-unit id="2a358a8843be76d3c49082380039fa0679262430" translate="yes" xml:space="preserve">
          <source>Listening for Native Events on Components with &lt;code&gt;v-on&lt;/code&gt;&lt;sup&gt;changed&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;v-on&lt;/code&gt; が&lt;sup&gt;変更さ&lt;/sup&gt;れたコンポーネントでのネイティブイベントのリッスン&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="6d24ce075567f8634478a57941ae0b0eecc75979" translate="yes" xml:space="preserve">
          <source>Listening to Child Components Events</source>
          <target state="translated">子コンポーネントのイベントを聞く</target>
        </trans-unit>
        <trans-unit id="4068e29f0d00dd78b6cb63522d95b7fd8466fe66" translate="yes" xml:space="preserve">
          <source>Listening to Events</source>
          <target state="translated">イベントのリスニング</target>
        </trans-unit>
        <trans-unit id="a5bab41dbcd17d889c6e2f819506e9dcf076f282" translate="yes" xml:space="preserve">
          <source>Listening to custom events on a child component (the handler is called when &quot;my-event&quot; is emitted on the child):</source>
          <target state="translated">子コンポーネント上のカスタムイベントをリスンする(子コンポーネント上で &quot;my-event &quot;が放出されたときにハンドラが呼び出される)。</target>
        </trans-unit>
        <trans-unit id="454c823d312bb21fb3768d64892637753b93fb76" translate="yes" xml:space="preserve">
          <source>Listening to custom events on a child component (the handler is called when &amp;ldquo;my-event&amp;rdquo; is emitted on the child):</source>
          <target state="translated">子コンポーネントのカスタムイベントをリッスンします（「my-event」が子で発行されると、ハンドラーが呼び出されます）：</target>
        </trans-unit>
        <trans-unit id="8631bfe9aed59c0e3f179ac4e96195bbc6860960" translate="yes" xml:space="preserve">
          <source>Listening to the kebab-cased version will have no effect:</source>
          <target state="translated">ケバブ漬けバージョンを聴いても何の効果もありません。</target>
        </trans-unit>
        <trans-unit id="6674c82db55a9741fe74df825e79591da8cece35" translate="yes" xml:space="preserve">
          <source>Loader function does not inherently receive &lt;code&gt;resolve&lt;/code&gt; and &lt;code&gt;reject&lt;/code&gt; arguments and must return a Promise</source>
          <target state="translated">Loaderの機能は、本質的に受信しない &lt;code&gt;resolve&lt;/code&gt; し、 &lt;code&gt;reject&lt;/code&gt; の引数をとの約束を返す必要があります</target>
        </trans-unit>
        <trans-unit id="ba43e280bc7445e5b4f1d1db31b10f615d04d7e1" translate="yes" xml:space="preserve">
          <source>Local Registration</source>
          <target state="translated">ローカル登録</target>
        </trans-unit>
        <trans-unit id="5aa492ab1eff8abbb7c26a1b8e7859024fe0d373" translate="yes" xml:space="preserve">
          <source>Local Registration in a Module System</source>
          <target state="translated">モジュールシステムにおけるローカル登録</target>
        </trans-unit>
        <trans-unit id="c21bde3b85066869a4def12bbecd2597d5f1d6cf" translate="yes" xml:space="preserve">
          <source>Logic is now decoupled from the presentation layer, making maintenance (change/extension of logic) much easier.</source>
          <target state="translated">ロジックがプレゼンテーション層から切り離され、メンテナンス(ロジックの変更・拡張)が格段に楽になりました。</target>
        </trans-unit>
        <trans-unit id="972ab90613dd62fd50f5c7d4e44d82a2703fc0da" translate="yes" xml:space="preserve">
          <source>MAGic (opens new window)</source>
          <target state="translated">MAGic(新しいウィンドウが開きます</target>
        </trans-unit>
        <trans-unit id="9061dc1c4c01489f1dced5faf2e16a1e14bb1c24" translate="yes" xml:space="preserve">
          <source>Magnifier (opens new window)</source>
          <target state="translated">拡大鏡(新しいウィンドウが開きます</target>
        </trans-unit>
        <trans-unit id="9ba90cc7a29b593100819375e54c2166bf952ca3" translate="yes" xml:space="preserve">
          <source>Maintaining State</source>
          <target state="translated">状態の維持</target>
        </trans-unit>
        <trans-unit id="b0f21a5d13bd1abc123a654d0af01af3751372ba" translate="yes" xml:space="preserve">
          <source>Make Vue ignore custom elements defined outside of Vue (e.g., using the Web Components APIs). Otherwise, it will throw a warning about an &lt;code&gt;Unknown custom element&lt;/code&gt;, assuming that you forgot to register a global component or misspelled a component name.</source>
          <target state="translated">Vueの外部で定義されたカスタム要素を無視する（たとえば、WebコンポーネントAPIを使用する）。それ以外の場合は、グローバルコンポーネントの登録を忘れたか、コンポーネント名のスペルを間違えた場合、 &lt;code&gt;Unknown custom element&lt;/code&gt; に関する警告がスローされます。</target>
        </trans-unit>
        <trans-unit id="40cc7de2e3efbc03590e2caf3615a6df24defc19" translate="yes" xml:space="preserve">
          <source>Make an object reactive. Internally, Vue uses this on the object returned by the &lt;code&gt;data&lt;/code&gt; function.</source>
          <target state="translated">オブジェクトをリアクティブにします。内部的には、Vueは &lt;code&gt;data&lt;/code&gt; 関数によって返されたオブジェクトでこれを使用します。</target>
        </trans-unit>
        <trans-unit id="7801d7d110e57ae1f3c6effb3b2240aea5dc9f4f" translate="yes" xml:space="preserve">
          <source>Make sure that &lt;code&gt;script&lt;/code&gt; part of the component has TypeScript set as a language:</source>
          <target state="translated">コンポーネントの &lt;code&gt;script&lt;/code&gt; 部分にTypeScriptが言語として設定されていることを確認してください。</target>
        </trans-unit>
        <trans-unit id="1ca710d6ed72907ab1882247d85dafbe4c288636" translate="yes" xml:space="preserve">
          <source>Make sure to read about &lt;a href=&quot;#Explanation-of-Different-Builds&quot;&gt;the different builds of Vue&lt;/a&gt; and use the &lt;strong&gt;production&lt;br/&gt; version&lt;/strong&gt; in your published site, replacing &lt;code&gt;vue.js&lt;/code&gt; with &lt;code&gt;vue.min.js&lt;/code&gt;. This is a smaller build optimized for speed instead of development experience.</source>
          <target state="translated">&lt;a href=&quot;#Explanation-of-Different-Builds&quot;&gt;Vueのさまざまなビルド&lt;/a&gt;についてお読みになり、公開サイトで&lt;strong&gt;製品&lt;br/&gt;バージョン&lt;/strong&gt;を使用して、 &lt;code&gt;vue.js&lt;/code&gt; を &lt;code&gt;vue.min.js&lt;/code&gt; に置き換えてください。これは、開発経験ではなく、速度を重視して最適化された小さなビルドです。</target>
        </trans-unit>
        <trans-unit id="e3c022bac6422a256a8effaab478918265d7cabe" translate="yes" xml:space="preserve">
          <source>Managing many state transitions can quickly increase the complexity of a Vue instance or component. Fortunately, many animations can be extracted out into dedicated child components. Let&amp;rsquo;s do this with the animated integer from our earlier example:</source>
          <target state="translated">多くの状態遷移を管理すると、Vueインスタンスまたはコンポーネントの複雑さが急速に高まります。幸い、多くのアニメーションを専用の子コンポーネントに抽出できます。前の例のアニメーション化された整数でこれを実行してみましょう：</target>
        </trans-unit>
        <trans-unit id="6d84634068387565bc44457e74c1fb936b41ea6b" translate="yes" xml:space="preserve">
          <source>Managing many state transitions can quickly increase the complexity of a component instance. Fortunately, many animations can be extracted out into dedicated child components. Let's do this with the animated integer from our earlier example:</source>
          <target state="translated">多くの状態遷移を管理すると、コンポーネント インスタンスの複雑さがすぐに増してしまいます。幸いなことに、多くのアニメーションは専用の子コンポーネントに抽出することができます。先ほどの例の整数のアニメーションを使ってみましょう。</target>
        </trans-unit>
        <trans-unit id="7c3bd17fad3bf74f92a5f858b73034ae0e335d8b" translate="yes" xml:space="preserve">
          <source>Managing state on &lt;code&gt;this.$root&lt;/code&gt; and/or using a &lt;a href=&quot;../guide/migration#dispatch-and-broadcast-replaced&quot;&gt;global event bus&lt;/a&gt; can be convenient for very simple cases, but are not appropriate for most applications. Vuex offers not only a central place to manage state, but also tools for organizing, tracking, and debugging state changes.</source>
          <target state="translated">&lt;code&gt;this.$root&lt;/code&gt; 状態を管理したり、&lt;a href=&quot;../guide/migration#dispatch-and-broadcast-replaced&quot;&gt;グローバルイベントバス&lt;/a&gt;を使用したりすることは、非常に単純な場合には便利ですが、ほとんどのアプリケーションには適していません。Vuexは、状態を管理するための中心的な場所を提供するだけでなく、状態の変更を整理、追跡、およびデバッグするためのツールも提供します。</target>
        </trans-unit>
        <trans-unit id="345f632fb618327d0737b3e43648e569b92b65d3" translate="yes" xml:space="preserve">
          <source>Managing state on &lt;code&gt;this.$root&lt;/code&gt; and/or using a global event bus can be convenient for very simple cases, but it is not appropriate for most applications.</source>
          <target state="translated">&lt;code&gt;this.$root&lt;/code&gt; 状態を管理したり、グローバルイベントバスを使用したりすることは、非常に単純なケースでは便利ですが、ほとんどのアプリケーションには適していません。</target>
        </trans-unit>
        <trans-unit id="f8ce6aa2bb23c0ea42fa8eff08fdeb57d8d46f86" translate="yes" xml:space="preserve">
          <source>Manipulate children, props, or data before passing them on to a child component</source>
          <target state="translated">子、小道具、またはデータを操作してから子コンポーネントに渡す</target>
        </trans-unit>
        <trans-unit id="ef483ab0b23465192e501c234b66b1aaf6d75a30" translate="yes" xml:space="preserve">
          <source>Many JS libraries like GreenSock will assume you want hardware acceleration and will apply them by default, so you do not need to set them manually.</source>
          <target state="translated">GreenSockのような多くのJSライブラリは、ハードウェアアクセラレーションを必要としていると仮定し、デフォルトで適用しますので、手動で設定する必要はありません。</target>
        </trans-unit>
        <trans-unit id="94450504feac5b15b4e2b00b870ff24df0d15b30" translate="yes" xml:space="preserve">
          <source>Many files with similar names, making rapid file switching in code editors more difficult.</source>
          <target state="translated">似たような名前のファイルが多く、コードエディタでの迅速なファイル切り替えが難しくなっています。</target>
        </trans-unit>
        <trans-unit id="e9845a3a28b614ba4d1f3f00fed1ceb01c5a0858" translate="yes" xml:space="preserve">
          <source>Many nested sub-directories, which increases the time it takes to browse components in an editor&amp;rsquo;s sidebar.</source>
          <target state="translated">多くのネストされたサブディレクトリ。これにより、エディターのサイドバーでコンポーネントを参照するのにかかる時間が長くなります。</target>
        </trans-unit>
        <trans-unit id="16185e750a239f48af50dd807d021ebe27373d96" translate="yes" xml:space="preserve">
          <source>Many nested sub-directories, which increases the time it takes to browse components in an editor's sidebar.</source>
          <target state="translated">サブディレクトリが多く入れ子になっているため、エディタのサイドバーでコンポーネントを閲覧するのにかかる時間が長くなります。</target>
        </trans-unit>
        <trans-unit id="871f71bb96ca0bb4e5791c4ef660e24c2c568ffe" translate="yes" xml:space="preserve">
          <source>Many of your components will be relatively generic, possibly only wrapping an element like an input or a button. We sometimes refer to these as &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;base components&lt;/a&gt; and they tend to be used very frequently across your components.</source>
          <target state="translated">コンポーネントの多くは比較的汎用的で、おそらく入力やボタンなどの要素をラップするだけです。これらは&lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;基本コンポーネント&lt;/a&gt;と呼ばれることもあり、コンポーネント全体で非常に頻繁に使用される傾向があります。</target>
        </trans-unit>
        <trans-unit id="d3f90d76037526451c4d4d6a19af05a35509fe8a" translate="yes" xml:space="preserve">
          <source>Mapping an Array to Elements with &lt;code&gt;v-for&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;v-for&lt;/code&gt; を使用した配列の要素へのマッピング</target>
        </trans-unit>
        <trans-unit id="985fac5003727ca9f43295099936da1f418deb05" translate="yes" xml:space="preserve">
          <source>Marks an object so that it will never be converted to a proxy. Returns the object itself.</source>
          <target state="translated">プロキシに変換されないようにオブジェクトをマークします。オブジェクト自体を返します。</target>
        </trans-unit>
        <trans-unit id="f03a6d54b8b6514c9c14a1dc9c7ad30c6d8ce6b1" translate="yes" xml:space="preserve">
          <source>Meta Instance Methods</source>
          <target state="translated">メタインスタンスメソッド</target>
        </trans-unit>
        <trans-unit id="2f4694e23c9582e9a5db1045c363b51dfc44e4fe" translate="yes" xml:space="preserve">
          <source>Method Event Handlers</source>
          <target state="translated">メソッドイベントハンドラ</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="d7d319f93f2d93a0aa10747398e65d855aff93ad" translate="yes" xml:space="preserve">
          <source>Methods called from a template should not have any side effects, such as changing data or triggering asynchronous processes. If you find yourself tempted to do that you should probably use a &lt;a href=&quot;instance#lifecycle-hooks&quot;&gt;lifecycle hook&lt;/a&gt; instead.</source>
          <target state="translated">テンプレートから呼び出されたメソッドには、データの変更や非同期プロセスのトリガーなどの副作用があってはなりません。そうしたいと思った場合は、代わりに&lt;a href=&quot;instance#lifecycle-hooks&quot;&gt;ライフサイクルフックを&lt;/a&gt;使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="7695e9b47d9ba02cf1af67839a1c5a56784566b4" translate="yes" xml:space="preserve">
          <source>Methods in Inline Handlers</source>
          <target state="translated">インラインハンドラのメソッド</target>
        </trans-unit>
        <trans-unit id="d1290d394bc9cbc272b779c93460593c97002ca1" translate="yes" xml:space="preserve">
          <source>Methods to be mixed into the Vue instance. You can access these methods directly on the VM instance, or use them in directive expressions. All methods will have their &lt;code&gt;this&lt;/code&gt; context automatically bound to the Vue instance.</source>
          <target state="translated">Vueインスタンスに混合されるメソッド。これらのメソッドには、VMインスタンスで直接アクセスするか、ディレクティブ式で使用できます。すべてのメソッドは、 &lt;code&gt;this&lt;/code&gt; コンテキストを自動的にVueインスタンスにバインドします。</target>
        </trans-unit>
        <trans-unit id="6fde24be2acb622eb42db4cc92f8e9d97e13fc25" translate="yes" xml:space="preserve">
          <source>Methods to be mixed into the component instance. You can access these methods directly on the VM instance, or use them in directive expressions. All methods will have their &lt;code&gt;this&lt;/code&gt; context automatically bound to the component instance.</source>
          <target state="translated">コンポーネントインスタンスに混合されるメソッド。これらのメソッドには、VMインスタンスで直接アクセスすることも、ディレクティブ式で使用することもできます。すべてのメソッドは、 &lt;code&gt;this&lt;/code&gt; コンテキストをコンポーネントインスタンスに自動的にバインドします。</target>
        </trans-unit>
        <trans-unit id="431ecb390fd9ca8c90c7d10a3d2d7c57e8f24d12" translate="yes" xml:space="preserve">
          <source>Middlewares &lt;sup&gt;replaced&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;置き換えられた&lt;/sup&gt;ミドルウェア&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="a7c29497fcc9380f26664db064158964ed034b2e" translate="yes" xml:space="preserve">
          <source>Middlewares are replaced by plugins. A plugin is a function that receives the store as the only argument, and can listen to the mutation event on the store:</source>
          <target state="translated">ミドルウェアはプラグインに置き換えられます。プラグインはストアを唯一の引数として受け取り、ストア上の突然変異イベントを聞くことができる関数です。</target>
        </trans-unit>
        <trans-unit id="a6b3e991aad9c53aed3b0912de764a87bdc4c052" translate="yes" xml:space="preserve">
          <source>Migration Strategy</source>
          <target state="translated">移住戦略</target>
        </trans-unit>
        <trans-unit id="de3452a9ee78ce898468e14c739e9cdea57d03f0" translate="yes" xml:space="preserve">
          <source>Migration from Vue 1.x</source>
          <target state="translated">Vue 1.xからの移行</target>
        </trans-unit>
        <trans-unit id="33235c234b4d4ff968729d9a75b61daade922a4c" translate="yes" xml:space="preserve">
          <source>Migration from Vue Router 0.7.x</source>
          <target state="translated">Vue Router 0.7.xからの移行</target>
        </trans-unit>
        <trans-unit id="85c2e4a1b81a8d15a3bcd89e26321a5e8bae795c" translate="yes" xml:space="preserve">
          <source>Migration from Vuex 0.6.x to 1.0</source>
          <target state="translated">Vuex 0.6.xから1.0への移行</target>
        </trans-unit>
        <trans-unit id="27e6c208056129d07214b4839a815039f22c4fbb" translate="yes" xml:space="preserve">
          <source>Migration guide - &lt;code&gt;$attrs&lt;/code&gt; includes &lt;code&gt;class&lt;/code&gt; &amp;amp; &lt;code&gt;style&lt;/code&gt;</source>
          <target state="translated">移行ガイド- &lt;code&gt;$attrs&lt;/code&gt; は &lt;code&gt;class&lt;/code&gt; と &lt;code&gt;style&lt;/code&gt; 含まれています</target>
        </trans-unit>
        <trans-unit id="40d7041841fb6a16a593419ba9210aa34bce92e8" translate="yes" xml:space="preserve">
          <source>Migration guide - &lt;code&gt;$attrs&lt;/code&gt;includes &lt;code&gt;class&lt;/code&gt; &amp;amp; &lt;code&gt;style&lt;/code&gt;</source>
          <target state="translated">移行ガイド- &lt;code&gt;$attrs&lt;/code&gt; は &lt;code&gt;class&lt;/code&gt; と &lt;code&gt;style&lt;/code&gt; 含まれています</target>
        </trans-unit>
        <trans-unit id="c410c172a6db22b44797723b74a9f97cbe8cbd47" translate="yes" xml:space="preserve">
          <source>Migration guide - &lt;code&gt;$listeners&lt;/code&gt; removed</source>
          <target state="translated">移行ガイド- &lt;code&gt;$listeners&lt;/code&gt; 削除されました</target>
        </trans-unit>
        <trans-unit id="635802e8d697afd466dea0285928d4c2564eeacf" translate="yes" xml:space="preserve">
          <source>Migration guide - &lt;code&gt;.native&lt;/code&gt; modifier removed</source>
          <target state="translated">移行ガイド &lt;code&gt;.native&lt;/code&gt; 修飾子が削除されました</target>
        </trans-unit>
        <trans-unit id="cab0b41dde0e20543a039acd14df0e338cbee9d6" translate="yes" xml:space="preserve">
          <source>Migration guide - Changes in the Render Functions API</source>
          <target state="translated">移行ガイド-Render Functions API の変更点</target>
        </trans-unit>
        <trans-unit id="ca5be8322a9bb8f637fd7d36053e4e1060c3e536" translate="yes" xml:space="preserve">
          <source>Migration guide - New Emits Option</source>
          <target state="translated">移行ガイド-新しいエミットオプション</target>
        </trans-unit>
        <trans-unit id="b2363ce7759901b489bcaeaac53540d1809dbe21" translate="yes" xml:space="preserve">
          <source>Migration: Render Functions</source>
          <target state="translated">マイグレーション。レンダー機能</target>
        </trans-unit>
        <trans-unit id="0a893ece8e469a3ca3d935c49f41d08d04b75ecc" translate="yes" xml:space="preserve">
          <source>Misc</source>
          <target state="translated">Misc</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="01468459ec2045f5366f9299c5e3667f7a39c98e" translate="yes" xml:space="preserve">
          <source>Mixin Merge Behavior Change</source>
          <target state="translated">ミクシン マージ 挙動変更</target>
        </trans-unit>
        <trans-unit id="56ce9269c79d7b84814a50d956fd29f09b1efb47" translate="yes" xml:space="preserve">
          <source>Mixin hooks are called in the order they are provided, and called before the component&amp;rsquo;s own hooks.</source>
          <target state="translated">Mixinフックは提供された順に呼び出され、コンポーネントの独自のフックの前に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="696c1c53029e4a11c64d6af9a07cc08ca71e59d3" translate="yes" xml:space="preserve">
          <source>Mixin hooks are called in the order they are provided, and called before the component's own hooks.</source>
          <target state="translated">ミキシングフックは、提供された順に呼び出され、コンポーネント自身のフックの前に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="d634308003ff858f289d2833f637dfc9bee3fc78" translate="yes" xml:space="preserve">
          <source>Mixins</source>
          <target state="translated">Mixins</target>
        </trans-unit>
        <trans-unit id="06fc764968134bc875ae2b80299dfa521ccaf9ca" translate="yes" xml:space="preserve">
          <source>Mixins are a flexible way to distribute reusable functionalities for Vue components. A mixin object can contain any component options. When a component uses a mixin, all options in the mixin will be &amp;ldquo;mixed&amp;rdquo; into the component&amp;rsquo;s own options.</source>
          <target state="translated">ミックスインは、Vueコンポーネントの再利用可能な機能を柔軟に配布する方法です。mixinオブジェクトには、任意のコンポーネントオプションを含めることができます。コンポーネントがミックスインを使用する場合、ミックスインのすべてのオプションがコンポーネントの独自のオプションに「ミックス」されます。</target>
        </trans-unit>
        <trans-unit id="41c21dcea103087b7aa285323c1c82e7014cf7e0" translate="yes" xml:space="preserve">
          <source>Mixins are conflict-prone: Since properties from each feature are merged into the same component, you still have to know about every other feature to avoid property name conflicts and for debugging.</source>
          <target state="translated">ミキシングは競合を起こしやすい。各機能のプロパティが同じコンポーネントにマージされるため、プロパティ名の競合を避けたり、デバッグのために他の機能について知っておく必要があります。</target>
        </trans-unit>
        <trans-unit id="1f849d0cf8da656a7c4361043b523a5ce2e1fc1e" translate="yes" xml:space="preserve">
          <source>Mixins distribute reusable functionalities for Vue components. A mixin object can contain any component options. When a component uses a mixin, all options in the mixin will be &quot;mixed&quot; into the component's own options.</source>
          <target state="translated">ミキシンは、Vue コンポーネントの再利用可能な機能を配布します。ミキシン オブジェクトには、任意のコンポーネント オプションを含めることができます。コンポーネントがミキシンを使用すると、ミキシン内のすべてのオプションがコンポーネント自身のオプションに「混合」されます。</target>
        </trans-unit>
        <trans-unit id="049a096df6b896be6526afb4fccc301157e04515" translate="yes" xml:space="preserve">
          <source>MobX has become quite popular in the React community and it actually uses a nearly identical reactivity system to Vue. To a limited extent, the React + MobX workflow can be thought of as a more verbose Vue, so if you&amp;rsquo;re using that combination and are enjoying it, jumping into Vue is probably the next logical step.</source>
          <target state="translated">MobXはReactコミュニティで非常に人気があり、実際にはVueとほぼ同じ反応システムを使用しています。限られた範囲で、React + MobXワークフローはより冗長なVueと考えることができます。そのため、その組み合わせを使用していて楽しんでいる場合は、おそらくVueにジャンプすることが次の論理的なステップです。</target>
        </trans-unit>
        <trans-unit id="b1d702459399a2512fba5a402d4d5f26aee34693" translate="yes" xml:space="preserve">
          <source>Mobile</source>
          <target state="translated">Mobile</target>
        </trans-unit>
        <trans-unit id="814d5c9075ac58da08deb4e3d88f6089a78f380d" translate="yes" xml:space="preserve">
          <source>Mocha</source>
          <target state="translated">Mocha</target>
        </trans-unit>
        <trans-unit id="20716d7589116671fbeb6c4a74532bdfef915478" translate="yes" xml:space="preserve">
          <source>Mocha is a JavaScript test framework that is focused on being flexible. Because of this flexibility, it allows you to choose different libraries to fulfill other common features such as spying (e.g., Sinon) and assertions (e.g., Chai). Another unique feature of Mocha is that it can also execute tests in the browser in addition to Node.js.</source>
          <target state="translated">Mochaは、柔軟性を重視したJavaScriptのテストフレームワークです。この柔軟性のため、スパイ(Sinonなど)やアサーション(Chaiなど)などの他の共通機能を満たすために、異なるライブラリを選択することができます。また、Node.js以外にもブラウザ上でテストを実行できるのもMochaの特徴です。</target>
        </trans-unit>
        <trans-unit id="59f243cbe64caef0641a9876a4078a94f8defc16" translate="yes" xml:space="preserve">
          <source>Modifier Keys:</source>
          <target state="translated">修飾キー。</target>
        </trans-unit>
        <trans-unit id="91de419c6a3b3cf41aa4545caf2eb8b01499b085" translate="yes" xml:space="preserve">
          <source>Modifier(s)</source>
          <target state="translated">Modifier(s)</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="c78835db37c935d808d9977de5814282ad48b4f6" translate="yes" xml:space="preserve">
          <source>Modifiers Keys:</source>
          <target state="translated">修飾キー</target>
        </trans-unit>
        <trans-unit id="42425619360ca471965f2dfefff097e5132ba384" translate="yes" xml:space="preserve">
          <source>Modifiers added to a component &lt;code&gt;v-model&lt;/code&gt; will be provided to the component via the &lt;code&gt;modelModifiers&lt;/code&gt; prop. In the below example, we have created a component that contains a &lt;code&gt;modelModifiers&lt;/code&gt; prop that defaults to an empty object.</source>
          <target state="translated">コンポーネント &lt;code&gt;v-model&lt;/code&gt; に追加された修飾子は、 &lt;code&gt;modelModifiers&lt;/code&gt; プロパティを介してコンポーネントに提供されます。以下の例では、デフォルトで空のオブジェクトになる &lt;code&gt;modelModifiers&lt;/code&gt; プロパティを含むコンポーネントを作成しました。</target>
        </trans-unit>
        <trans-unit id="9c9674aab8b56f915029a2d1e586af8120c00891" translate="yes" xml:space="preserve">
          <source>Modifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way. For example, the &lt;code&gt;.prevent&lt;/code&gt; modifier tells the &lt;code&gt;v-on&lt;/code&gt; directive to call &lt;code&gt;event.preventDefault()&lt;/code&gt; on the triggered event:</source>
          <target state="translated">修飾子は、ドットで示された特別な接尾辞であり、ディレクティブが特別な方法でバインドされる必要があることを示します。たとえば、 &lt;code&gt;.prevent&lt;/code&gt; 修飾子は、トリガーされたイベントで &lt;code&gt;event.preventDefault()&lt;/code&gt; を呼び出すように &lt;code&gt;v-on&lt;/code&gt; ディレクティブに指示します。</target>
        </trans-unit>
        <trans-unit id="8c585db7d0122a15a54cf6c6876ffe8cc3e86e63" translate="yes" xml:space="preserve">
          <source>Module Systems</source>
          <target state="translated">モジュールシステム</target>
        </trans-unit>
        <trans-unit id="2333c18157c24df8052238f52f365426ca0dbb73" translate="yes" xml:space="preserve">
          <source>Module bundlers like &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack (opens new window)&lt;/a&gt; support &lt;a href=&quot;https://webpack.js.org/guides/tree-shaking/&quot;&gt;tree-shaking (opens new window)&lt;/a&gt;, which is a fancy term for &amp;ldquo;dead code elimination.&amp;rdquo; Unfortunately, due to how the code is written in previous Vue versions, global APIs like &lt;code&gt;Vue.nextTick()&lt;/code&gt; are not tree-shakeable and will be included in the final bundle regardless of where they are actually used or not.</source>
          <target state="translated">&lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack（新しいウィンドウを開く）の&lt;/a&gt;ようなモジュールバンドラーは、&lt;a href=&quot;https://webpack.js.org/guides/tree-shaking/&quot;&gt;ツリーシェイク（新しいウィンドウを開く&lt;/a&gt;）をサポートします。これは、「デッドコード除去」のファンシーな用語です。残念ながら、以前のVueバージョンでのコードの記述方法により、 &lt;code&gt;Vue.nextTick()&lt;/code&gt; などのグローバルAPIはツリーシェイク可能ではなく、実際に使用されているかどうかに関係なく、最終バンドルに含まれます。</target>
        </trans-unit>
        <trans-unit id="a6d2bd6abfd4bb67af5f7cf3bcc6c49be04098be" translate="yes" xml:space="preserve">
          <source>More mature tooling support. Vue provides official support for &lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;webpack&lt;/a&gt; and &lt;a href=&quot;https://github.com/vuejs/vueify&quot;&gt;Browserify&lt;/a&gt;, while Riot relies on community support for build system integration.</source>
          <target state="translated">より成熟したツールのサポート。Vueは&lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;webpack&lt;/a&gt;と&lt;a href=&quot;https://github.com/vuejs/vueify&quot;&gt;Browserifyの&lt;/a&gt;公式サポートを提供しますが、Riotはビルドシステム統合のコミュニティサポートに依存しています。</target>
        </trans-unit>
        <trans-unit id="bd951adc5c3182ed45f637e554b6230120cad548" translate="yes" xml:space="preserve">
          <source>Most of the methods exposed by the application instance return that same instance, allowing for chaining:</source>
          <target state="translated">アプリケーションのインスタンスによって公開されているメソッドのほとんどは、同じインスタンスを返すので、連鎖させることができます。</target>
        </trans-unit>
        <trans-unit id="51829624f8ae979b2184273f19ad9bb547f0cb2e" translate="yes" xml:space="preserve">
          <source>Most of the time when developing a third-party library we want to build it in a way that allows the consumers of the library to &lt;a href=&quot;https://webpack.js.org/guides/tree-shaking/&quot;&gt;tree shake (opens new window)&lt;/a&gt; it. To enable tree-shaking we need to build &lt;code&gt;esm&lt;/code&gt; modules. Since webpack and, in turn, vue-cli do not support building &lt;code&gt;esm&lt;/code&gt; modules we need to rely on &lt;a href=&quot;https://rollupjs.org/&quot;&gt;rollup (opens new window)&lt;/a&gt;.</source>
          <target state="translated">ほとんどの場合、サードパーティのライブラリを開発するときは、ライブラリの利用者がライブラリを&lt;a href=&quot;https://webpack.js.org/guides/tree-shaking/&quot;&gt;ツリーシェイク（新しいウィンドウを開く）&lt;/a&gt;できるようにライブラリを構築したいと考えています。ツリーシェー &lt;code&gt;esm&lt;/code&gt; を有効にするには、esmモジュールを構築する必要があります。webpackとvue-cliは &lt;code&gt;esm&lt;/code&gt; モジュールのビルドをサポートしていないため、&lt;a href=&quot;https://rollupjs.org/&quot;&gt;ロールアップ&lt;/a&gt;に依存する必要があります（新しいウィンドウが開きます）。</target>
        </trans-unit>
        <trans-unit id="9dd700564f82afc8781e8c7bd3517f4f9cfa75b4" translate="yes" xml:space="preserve">
          <source>Most of the tips below are enabled by default if you are using &lt;a href=&quot;https://cli.vuejs.org&quot;&gt;Vue CLI (opens new window)&lt;/a&gt;. This section is only relevant if you are using a custom build setup.</source>
          <target state="translated">&lt;a href=&quot;https://cli.vuejs.org&quot;&gt;Vue CLI&lt;/a&gt;を使用している場合（新しいウィンドウを開く）、以下のヒントのほとんどはデフォルトで有効になっています。このセクションは、カスタムビルドセットアップを使用している場合にのみ関係します。</target>
        </trans-unit>
        <trans-unit id="8ac57078adf5d9e220c754f33e3cab2a4c61f61d" translate="yes" xml:space="preserve">
          <source>Most of the tips below are enabled by default if you are using &lt;a href=&quot;https://cli.vuejs.org&quot;&gt;Vue CLI&lt;/a&gt;. This section is only relevant if you are using a custom build setup.</source>
          <target state="translated">&lt;a href=&quot;https://cli.vuejs.org&quot;&gt;Vue CLI&lt;/a&gt;を使用している場合、以下のヒントのほとんどはデフォルトで有効になっています。このセクションは、カスタムビルドセットアップを使用している場合にのみ該当します。</target>
        </trans-unit>
        <trans-unit id="5e26a19f206db5f80980c1565b38336a5204a51f" translate="yes" xml:space="preserve">
          <source>Most of the use cases for &lt;code&gt;inline-template&lt;/code&gt; assumes a no-build-tool setup, where all templates are written directly inside the HTML page.</source>
          <target state="translated">&lt;code&gt;inline-template&lt;/code&gt; ほとんどのユースケースは、すべてのテンプレートがHTMLページ内に直接書き込まれるビルドツールなしのセットアップを想定しています。</target>
        </trans-unit>
        <trans-unit id="ff6e88abb4082a25af5cddfc16c8063e7092c245" translate="yes" xml:space="preserve">
          <source>Most use cases of mutating a prop can be replaced by one of these options:</source>
          <target state="translated">プロップの突然変異のほとんどのユースケースは、これらのオプションのいずれかで置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="2c94530449d59bc0026f72f09d5cab721902ce23" translate="yes" xml:space="preserve">
          <source>Mounting App Instance</source>
          <target state="translated">アプリインスタンスのマウント</target>
        </trans-unit>
        <trans-unit id="e0f67e8c3b01357d6a48d990b7305e54d0bf81af" translate="yes" xml:space="preserve">
          <source>Mounts a root component of the application instance on the provided DOM element.</source>
          <target state="translated">アプリケーションインスタンスのルートコンポーネントを、指定された DOM 要素にマウントします。</target>
        </trans-unit>
        <trans-unit id="0f6138bafcc1d5e10b1c4ef89a77bfaf9ad800f1" translate="yes" xml:space="preserve">
          <source>Mouse Button Modifiers</source>
          <target state="translated">マウスボタンモディファイア</target>
        </trans-unit>
        <trans-unit id="6a5aa2d48e5943f597c67e02c2fd245883968d95" translate="yes" xml:space="preserve">
          <source>Much better, isn&amp;rsquo;t it?</source>
          <target state="translated">はるかに良いですね。</target>
        </trans-unit>
        <trans-unit id="47ce4ea06250a3aebfb8fdef175fa9bb75c62c5f" translate="yes" xml:space="preserve">
          <source>Much better, isn't it?</source>
          <target state="translated">だいぶ良くなったわね?</target>
        </trans-unit>
        <trans-unit id="48f57c7776187e52ab80734a4cd047017fdbc252" translate="yes" xml:space="preserve">
          <source>Much like a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; tag, a &lt;code&gt;&amp;lt;component&amp;gt;&lt;/code&gt; tag is only required in templates as a syntactical placeholder and should be discarded when migrating to a &lt;code&gt;render&lt;/code&gt; function.</source>
          <target state="translated">似 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; タグ、 &lt;code&gt;&amp;lt;component&amp;gt;&lt;/code&gt; タグは、構文プレースホルダとしてテンプレートに必要とされ、への移行時に破棄されるべき &lt;code&gt;render&lt;/code&gt; 機能。</target>
        </trans-unit>
        <trans-unit id="d62651fa8a2e7b83b1b472f6394d7ec9c1b77f13" translate="yes" xml:space="preserve">
          <source>Much simpler! Sort of. The code is shorter, but also requires greater familiarity with Vue instance properties. In this case, you have to know that when you pass children without a &lt;code&gt;v-slot&lt;/code&gt; directive into a component, like the &lt;code&gt;Hello world!&lt;/code&gt; inside of &lt;code&gt;anchored-heading&lt;/code&gt;, those children are stored on the component instance at &lt;code&gt;$slots.default&lt;/code&gt;. If you haven&amp;rsquo;t already, &lt;strong&gt;it&amp;rsquo;s recommended to read through the &lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;instance properties API&lt;/a&gt; before diving into render functions.&lt;/strong&gt;</source>
          <target state="translated">はるかに簡単です！ちょっと。コードは短くなりますが、Vueインスタンスのプロパティをよく理解する必要もあります。この場合、 &lt;code&gt;v-slot&lt;/code&gt; ディレクティブのない子を &lt;code&gt;Hello world!&lt;/code&gt; などのコンポーネントに渡すときに、そのことを知っておく必要があります。 &lt;code&gt;$slots.default&lt;/code&gt; &lt;code&gt;anchored-heading&lt;/code&gt; 内部では、これらの子は$ slots.defaultのコンポーネントインスタンスに格納されます。まだ行っていない場合は、&lt;strong&gt;レンダリング関数に飛び込む前に&lt;/strong&gt;&lt;strong&gt;、&lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;インスタンスプロパティAPI&lt;/a&gt;を一読することをお勧めします。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae7fd6f6c6f4ea4c4eacb2f56da39f0b2fb1a420" translate="yes" xml:space="preserve">
          <source>Multi-attribute elements</source>
          <target state="translated">多属性要素</target>
        </trans-unit>
        <trans-unit id="ceea8f5866781984f4ad8f3e46247846aa62fb94" translate="yes" xml:space="preserve">
          <source>Multi-attribute elements &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">マルチ属性要素を&lt;sup&gt;強く推奨&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="c74c369ff94e794c799780bff5d5ea7fad8ef38a" translate="yes" xml:space="preserve">
          <source>Multi-word component names</source>
          <target state="translated">複数単語のコンポーネント名</target>
        </trans-unit>
        <trans-unit id="d3d1a8c17e83b5f0002fdfe859df802f2669490e" translate="yes" xml:space="preserve">
          <source>Multi-word component names &lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">マルチワードのコンポーネント名は&lt;sup&gt;必須です&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="0f05bd0026ab6ceb1bb040af8f4b0c24c530607d" translate="yes" xml:space="preserve">
          <source>Multiline text</source>
          <target state="translated">マルチラインテキスト</target>
        </trans-unit>
        <trans-unit id="9a85758f90e2757c68d0fceaab52f21c4531a196" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;v-model&lt;/code&gt; bindings</source>
          <target state="translated">複数の &lt;code&gt;v-model&lt;/code&gt; バインディング</target>
        </trans-unit>
        <trans-unit id="4871212ed8d1d6698fc58f7b90833df012ebc65c" translate="yes" xml:space="preserve">
          <source>Multiple Event Handlers</source>
          <target state="translated">複数のイベントハンドラ</target>
        </trans-unit>
        <trans-unit id="df30563657ae4c69b0249bc2ce91dacff84cf5a3" translate="yes" xml:space="preserve">
          <source>Multiple Sections</source>
          <target state="translated">複数のセクション</target>
        </trans-unit>
        <trans-unit id="f6620aef040214a72d3c2e57f8f5384fa762cf0c" translate="yes" xml:space="preserve">
          <source>Multiple Values</source>
          <target state="translated">複数の値</target>
        </trans-unit>
        <trans-unit id="e7051b9f8df86c845f6fca692b6b3cadd5b8a10a" translate="yes" xml:space="preserve">
          <source>Multiple checkboxes, bound to the same Array:</source>
          <target state="translated">複数のチェックボックスは、同じ配列にバインドされています。</target>
        </trans-unit>
        <trans-unit id="ec5f3b4f279a5fac1d619ddd625a66c322263084" translate="yes" xml:space="preserve">
          <source>Multiple checkboxes, bound to the same array:</source>
          <target state="translated">複数のチェックボックスを同じ配列にバインドします。</target>
        </trans-unit>
        <trans-unit id="4bb517cb00682f4c08a606d69d3a2147fe97738f" translate="yes" xml:space="preserve">
          <source>Multiple nodes where only 1 is rendered at a time</source>
          <target state="translated">一度に1つだけレンダリングされる複数のノード</target>
        </trans-unit>
        <trans-unit id="e6e9d08847648f1f24b432d66915720d2a3cd5b3" translate="yes" xml:space="preserve">
          <source>Multiple select (bound to Array):</source>
          <target state="translated">複数選択(Array にバインド)。</target>
        </trans-unit>
        <trans-unit id="ba3eb3692fb6af84e61cce398babaf5e0445cbe0" translate="yes" xml:space="preserve">
          <source>Multiple select (bound to array):</source>
          <target state="translated">複数選択(配列にバインド)。</target>
        </trans-unit>
        <trans-unit id="fb0467cdaf45c60b95eca56ed7e05421c4b98185" translate="yes" xml:space="preserve">
          <source>Mustaches cannot be used inside HTML attributes. Instead, use a &lt;a href=&quot;../api/directives#v-bind&quot;&gt;&lt;code&gt;v-bind&lt;/code&gt; directive&lt;/a&gt;:</source>
          <target state="translated">口ひげはHTML属性内では使用できません。代わりに、&lt;a href=&quot;../api/directives#v-bind&quot;&gt; &lt;code&gt;v-bind&lt;/code&gt; ディレクティブを&lt;/a&gt;使用してください：</target>
        </trans-unit>
        <trans-unit id="646b4dd27caf266ac22f395b2a33613ba629a308" translate="yes" xml:space="preserve">
          <source>Mustaches cannot be used inside HTML attributes. Instead, use a &lt;a href=&quot;../api/index#v-bind&quot;&gt;v-bind directive&lt;/a&gt;:</source>
          <target state="translated">口ひげはHTML属性内では使用できません。代わりに、&lt;a href=&quot;../api/index#v-bind&quot;&gt;v-bindディレクティブを&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="678c5ab9e821362e494de6bbb3ed5d891d1e67f1" translate="yes" xml:space="preserve">
          <source>Mutating Reactive Properties</source>
          <target state="translated">反応性特性の変異</target>
        </trans-unit>
        <trans-unit id="a1ceb98e8d45e6f84a7b372d2bc5ecdc0a979de1" translate="yes" xml:space="preserve">
          <source>Mutating a prop locally is now considered an anti-pattern, e.g. declaring a prop and then setting &lt;code&gt;this.myProp = 'someOtherValue'&lt;/code&gt; in the component. Due to the new rendering mechanism, whenever the parent component re-renders, the child component&amp;rsquo;s local changes will be overwritten.</source>
          <target state="translated">プロップをローカルで変更することは、アンチパターンと見なされます。たとえば、プロップを宣言してから、コンポーネントで &lt;code&gt;this.myProp = 'someOtherValue'&lt;/code&gt; 設定します。新しいレンダリングメカニズムにより、親コンポーネントが再レンダリングされるたびに、子コンポーネントのローカルの変更が上書きされます。</target>
        </trans-unit>
        <trans-unit id="0acccbc6d162746eb3fb69dff7df3fa404b932c2" translate="yes" xml:space="preserve">
          <source>Mutation Methods</source>
          <target state="translated">突然変異法</target>
        </trans-unit>
        <trans-unit id="5f08c22f9167f78491a6ca2175a2bc368b8504f7" translate="yes" xml:space="preserve">
          <source>Mutation methods, as the name suggests, mutate the original array they are called on. In comparison, there are also non-mutating methods, e.g. &lt;code&gt;filter()&lt;/code&gt;, &lt;code&gt;concat()&lt;/code&gt; and &lt;code&gt;slice()&lt;/code&gt;, which do not mutate the original array but &lt;strong&gt;always return a new array&lt;/strong&gt;. When working with non-mutating methods, you can replace the old array with the new one:</source>
          <target state="translated">名前が示すように、変異メソッドは、呼び出された元の配列を変異させます。比較すると、 &lt;code&gt;filter()&lt;/code&gt; 、 &lt;code&gt;concat()&lt;/code&gt; 、 &lt;code&gt;slice()&lt;/code&gt; などの非変更メソッドもあり、元の配列は変更しませんが、&lt;strong&gt;常に新しい配列を返し&lt;/strong&gt;ます。非変異メソッドを使用する場合、古い配列を新しい配列に置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="7d94ebbf07f5417771d7c7fd06f208703494bf50" translate="yes" xml:space="preserve">
          <source>NPM</source>
          <target state="translated">NPM</target>
        </trans-unit>
        <trans-unit id="5d35915fe00d2c128685549b04a6a30f49020050" translate="yes" xml:space="preserve">
          <source>NPM is the recommended installation method when building large scale applications with Vue. It pairs nicely with module bundlers such as &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt; or &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt;. Vue also provides accompanying tools for authoring &lt;a href=&quot;single-file-components&quot;&gt;Single File Components&lt;/a&gt;.</source>
          <target state="translated">NPMは、Vueを使用して大規模なアプリケーションを構築するときに推奨されるインストール方法です。&lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt;や&lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt;などのモジュールバンドルとうまく組み合わせられます。Vueは、&lt;a href=&quot;single-file-components&quot;&gt;単一ファイルコンポーネント&lt;/a&gt;をオーサリングするための付属ツールも提供します。</target>
        </trans-unit>
        <trans-unit id="69a28f26a2d6401b08eedd57c6a1a5681efe2332" translate="yes" xml:space="preserve">
          <source>NVDA (opens new window)</source>
          <target state="translated">NVDA(新しいウィンドウが開きます</target>
        </trans-unit>
        <trans-unit id="39674384c8d92e5f7a36d0d3f3e397a2e95cfa07" translate="yes" xml:space="preserve">
          <source>Name Casing</source>
          <target state="translated">ネームケーシング</target>
        </trans-unit>
        <trans-unit id="0ab2cdaecd6bb74527ceec8c7c8e94dbe4ba99ce" translate="yes" xml:space="preserve">
          <source>Name conflicts (e.g. multiple &lt;code&gt;ButtonDelete.vue&lt;/code&gt; components) make it more difficult to quickly navigate to a specific component in a code editor.</source>
          <target state="translated">名前の競合（複数の &lt;code&gt;ButtonDelete.vue&lt;/code&gt; コンポーネントなど）により、コードエディターで特定のコンポーネントにすばやく移動することがより困難になります。</target>
        </trans-unit>
        <trans-unit id="7a6baafc30ef8e96b10f64b5ae02d071b89f11b7" translate="yes" xml:space="preserve">
          <source>Named Slots</source>
          <target state="translated">ネームドスロット</target>
        </trans-unit>
        <trans-unit id="ad1343c1fa843d537b321f552fb2d9e3249973f3" translate="yes" xml:space="preserve">
          <source>Named Slots Shorthand</source>
          <target state="translated">ネームドスロットの略語</target>
        </trans-unit>
        <trans-unit id="eb77d0a7e3904d77f8e4a7c84a101f0e60e5b947" translate="yes" xml:space="preserve">
          <source>Named Slots with the &lt;code&gt;slot&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;slot&lt;/code&gt; 属性を持つ名前付きスロット</target>
        </trans-unit>
        <trans-unit id="8e9a0bbd092de06c02318f4224dc00dd0e597d4b" translate="yes" xml:space="preserve">
          <source>Native Rendering</source>
          <target state="translated">ネイティブレンダリング</target>
        </trans-unit>
        <trans-unit id="26068455a90075c00bf4839b741d52af3487813b" translate="yes" xml:space="preserve">
          <source>NativeScript</source>
          <target state="translated">NativeScript</target>
        </trans-unit>
        <trans-unit id="1877cf043460c0f80e9625a96954e7851b08330d" translate="yes" xml:space="preserve">
          <source>NativeScript + Vue.js Guide (opens new window)</source>
          <target state="translated">NativeScript+Vue.jsガイド(新しいウィンドウが開きます</target>
        </trans-unit>
        <trans-unit id="f940a2947c24bf59462a669f4fe8ca87501b7ae3" translate="yes" xml:space="preserve">
          <source>NerdeFocus (opens new window)</source>
          <target state="translated">ネルデフォーカス(新しいウィンドウが開きます</target>
        </trans-unit>
        <trans-unit id="826fdcb80bf0630de536146d505abc527b2a01df" translate="yes" xml:space="preserve">
          <source>Nest headings in their ranking order: &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; - &lt;code&gt;&amp;lt;h6&amp;gt;&lt;/code&gt;</source>
          <target state="translated">ランキング順のネスト見出し： &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; - &lt;code&gt;&amp;lt;h6&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="248d641e1dd50d8e9bc4a5ff4268e7392bab4e5d" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;defineAsyncComponent&lt;/code&gt; helper method that explicitly defines async components</source>
          <target state="translated">非同期コンポーネントを明示的に定義する新しい &lt;code&gt;defineAsyncComponent&lt;/code&gt; ヘルパーメソッド</target>
        </trans-unit>
        <trans-unit id="2b1f77c5995cd9dac2e37e8101252626e5271812" translate="yes" xml:space="preserve">
          <source>New in 2.1.0+</source>
          <target state="translated">2.1.0+の新機能</target>
        </trans-unit>
        <trans-unit id="2ebe6a1174c620d032840e985bebc14e9c813501" translate="yes" xml:space="preserve">
          <source>New in 2.1.0+: returns a Promise if no callback is provided and Promise is supported in the execution environment. Please note that Vue does not come with a Promise polyfill, so if you target browsers that don&amp;rsquo;t support Promises natively (looking at you, IE), you will have to provide a polyfill yourself.</source>
          <target state="translated">2.1.0以降の新機能：コールバックが提供されておらず、Promiseが実行環境でサポートされている場合、Promiseを返します。VueにはPromiseポリフィルが付属していないので、Promiseをネイティブでサポートしていないブラウザー（IEを見て）を対象とする場合は、自分でポリフィルを提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="a23469cb28697e68c77d280bbb32f3803b532a34" translate="yes" xml:space="preserve">
          <source>New in 2.1.4+</source>
          <target state="translated">2.1.4+の新機能</target>
        </trans-unit>
        <trans-unit id="6c6aade3e6584c7a8b32cab964c7a674d3b07efd" translate="yes" xml:space="preserve">
          <source>New in 2.2.0</source>
          <target state="translated">2.2.0の新機能</target>
        </trans-unit>
        <trans-unit id="0f9f45aff79e86f97a647ac660d1cac6b64f6ae9" translate="yes" xml:space="preserve">
          <source>New in 2.2.0+</source>
          <target state="translated">2.2.0+の新機能</target>
        </trans-unit>
        <trans-unit id="0222464ccf0d40a3f2619ea19d32c2ebca8e8947" translate="yes" xml:space="preserve">
          <source>New in 2.3.0+</source>
          <target state="translated">2.3.0+の新機能</target>
        </trans-unit>
        <trans-unit id="b02f6830ecc8383c4879860f5a1da68ddd041c03" translate="yes" xml:space="preserve">
          <source>New in 2.4.0+</source>
          <target state="translated">2.4.0+の新機能</target>
        </trans-unit>
        <trans-unit id="50e01eb5f080e39b850973e99d037d430ae13836" translate="yes" xml:space="preserve">
          <source>New in 2.5.0+</source>
          <target state="translated">2.5.0+の新機能</target>
        </trans-unit>
        <trans-unit id="053c4407e09eb77d114f51a7a8bc3d31c0dc62de" translate="yes" xml:space="preserve">
          <source>New in 2.6.0+</source>
          <target state="translated">2.6.0+の新機能</target>
        </trans-unit>
        <trans-unit id="be41335dc7a0ff9171513e80c9b33fbd4144bd7a" translate="yes" xml:space="preserve">
          <source>New to Vue.js? Check out our &lt;a href=&quot;../../index&quot;&gt;Essentials Guide&lt;/a&gt; to get started.</source>
          <target state="translated">Vue.jsは初めてですか？開始するには、&lt;a href=&quot;../../index&quot;&gt;Essentialsガイド&lt;/a&gt;を確認してください。</target>
        </trans-unit>
        <trans-unit id="3f170caead65df254d786032a409a6f6d204bca6" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="translated">次のステップ</target>
        </trans-unit>
        <trans-unit id="1e1bc63fa69d5b8906a90d616cc23894236797b1" translate="yes" xml:space="preserve">
          <source>Nightwatch's Official Website (opens new window)</source>
          <target state="translated">ナイトウォッチ公式サイト(別ウィンドウで開きます</target>
        </trans-unit>
        <trans-unit id="7ce8836503e7153aa1a402805b5adb8e46245b8f" translate="yes" xml:space="preserve">
          <source>Nightwatch.js</source>
          <target state="translated">Nightwatch.js</target>
        </trans-unit>
        <trans-unit id="7fa11e6f2aa3af114b0e34eb2cd5e3891fde04fd" translate="yes" xml:space="preserve">
          <source>Nightwatch.js is an end-to-end testing framework that can be used to test web applications and websites, as well as Node.js unit and integration testing.</source>
          <target state="translated">Nightwatch.jsは、Node.jsのユニットテストや統合テストだけでなく、WebアプリケーションやWebサイトのテストにも使えるエンドツーエンドのテストフレームワークです。</target>
        </trans-unit>
        <trans-unit id="1c463bc393dd8ee82390da1c8679bbb86e610abe" translate="yes" xml:space="preserve">
          <source>No longer necessary, since warnings come with stack traces by default now.</source>
          <target state="translated">警告はデフォルトでスタックトレースと一緒に表示されるようになったので、不要になりました。</target>
        </trans-unit>
        <trans-unit id="66c6e5d0b724903ee1ff6e6099b203d955086d1a" translate="yes" xml:space="preserve">
          <source>No real use. If you do happen to rely on this feature somehow and aren&amp;rsquo;t sure how to work around it, post on &lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;the forum&lt;/a&gt; for ideas.</source>
          <target state="translated">実際の使用はありません。どういうわけかこの機能に依存していて、それを回避する方法がわからない場合は、アイデアを&lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;フォーラム&lt;/a&gt;に投稿してください。</target>
        </trans-unit>
        <trans-unit id="499b8c29716c6bc9380fa29ea0c868d469132ef2" translate="yes" xml:space="preserve">
          <source>Nodes, Trees, and the Virtual DOM</source>
          <target state="translated">ノード、ツリー、仮想 DOM</target>
        </trans-unit>
        <trans-unit id="67dbd82660f093394a26b3ae3623994010f0c69e" translate="yes" xml:space="preserve">
          <source>Non-Prop Attributes</source>
          <target state="translated">非プロップ属性</target>
        </trans-unit>
        <trans-unit id="3a775c24cf85519f3493a1f3184bcda0bc6bbbc5" translate="yes" xml:space="preserve">
          <source>Non-flux state management</source>
          <target state="translated">非フラックス状態の管理</target>
        </trans-unit>
        <trans-unit id="7d2d13e9ec1357ce0a1972e320ea404789b39c3f" translate="yes" xml:space="preserve">
          <source>Non-flux state management &lt;sup&gt;use with caution&lt;/sup&gt;</source>
          <target state="translated">非フラックス状態管理の&lt;sup&gt;使用には注意が必要&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7522eb1254b40f819eb00d0f412303761a8a0ac4" translate="yes" xml:space="preserve">
          <source>Not needed*</source>
          <target state="translated">必要ありません*。</target>
        </trans-unit>
        <trans-unit id="c63d0df42b260685a2a9914a2f95611f71b33e28" translate="yes" xml:space="preserve">
          <source>Notable New Features</source>
          <target state="translated">注目すべき新機能</target>
        </trans-unit>
        <trans-unit id="54aa04fe9a9673dccd2cdb7588ee890d8cbf364d" translate="yes" xml:space="preserve">
          <source>Note every child in a &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; must be &lt;strong&gt;uniquely keyed&lt;/strong&gt; for the animations to work properly.</source>
          <target state="translated">アニメーションが適切に機能するためには、 &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; のすべての子が&lt;strong&gt;一意にキー設定さ&lt;/strong&gt;れている必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ca49da0909b8a4408a3a2c4586e5b1467d69929a" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../api/refs-api#ref&quot;&gt;refs&lt;/a&gt; returned from &lt;code&gt;setup&lt;/code&gt; are &lt;a href=&quot;reactivity-fundamentals#ref-unwrapping&quot;&gt;automatically unwrapped&lt;/a&gt; when accessed in the template so you shouldn't use &lt;code&gt;.value&lt;/code&gt; in templates.</source>
          <target state="translated">注意&lt;a href=&quot;../api/refs-api#ref&quot;&gt;レフリー&lt;/a&gt;から返された &lt;code&gt;setup&lt;/code&gt; あり&lt;a href=&quot;reactivity-fundamentals#ref-unwrapping&quot;&gt;、自動的に開封された&lt;/a&gt;テンプレートにアクセスするときに使用するべきではありませんので、 &lt;code&gt;.value&lt;/code&gt; テンプレートに。</target>
        </trans-unit>
        <trans-unit id="4cc23cd0cef0d3813fd341bfd31bf6563a5bf5c6" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;refs-api#ref&quot;&gt;refs&lt;/a&gt; returned from &lt;code&gt;setup&lt;/code&gt; are automatically unwrapped when accessed in the template so there's no need for &lt;code&gt;.value&lt;/code&gt; in templates.</source>
          <target state="translated">注意&lt;a href=&quot;refs-api#ref&quot;&gt;レフリー&lt;/a&gt;から返された &lt;code&gt;setup&lt;/code&gt; は必要ありませんので、テンプレートにアクセスしたときに自動的に開封されている &lt;code&gt;.value&lt;/code&gt; テンプレートでは。</target>
        </trans-unit>
        <trans-unit id="01d9b9321e6ff665ab2980ef004ad4d70ee364dd" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; requires the components being switched between to all have names, either using the &lt;code&gt;name&lt;/code&gt; option on a component, or through local/global registration.</source>
          <target state="translated">&lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; では、コンポーネントで &lt;code&gt;name&lt;/code&gt; オプションを使用するか、ローカル/グローバル登録を通じて、すべてのコンポーネントに名前を付ける必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f371b641eda948d758990f934853de8872ee227f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;inheritAttrs: false&lt;/code&gt; option does &lt;strong&gt;not&lt;/strong&gt; affect &lt;code&gt;style&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt; bindings.</source>
          <target state="translated">&lt;code&gt;inheritAttrs: false&lt;/code&gt; オプションは &lt;code&gt;style&lt;/code&gt; と &lt;code&gt;class&lt;/code&gt; バインディングに&lt;strong&gt;は&lt;/strong&gt;影響し&lt;strong&gt;ない&lt;/strong&gt;ことに注意してください。</target>
        </trans-unit>
        <trans-unit id="4865cbc834beecb2b610f666cf562d7362926a15" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;mounted&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; guarantee that all child components have also been mounted. If you want to wait until the entire view has been rendered, you can use &lt;a href=&quot;#vm-nextTick&quot;&gt;vm.$nextTick&lt;/a&gt; inside of &lt;code&gt;mounted&lt;/code&gt;:</source>
          <target state="translated">注 &lt;code&gt;mounted&lt;/code&gt; ん&lt;strong&gt;ではない&lt;/strong&gt;すべての子コンポーネントにもマウントされていることを保証します。あなたは全体のビューがレンダリングされるまで待ちたい場合は、使用することができ&lt;a href=&quot;#vm-nextTick&quot;&gt;、VMを$ nextTickする。&lt;/a&gt;内部 &lt;code&gt;mounted&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="eb05a4351598578542e96c7b1ebb606ca8a12371" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;mounted&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; guarantee that all child components have also been mounted. If you want to wait until the entire view has been rendered, you can use &lt;a href=&quot;instance-methods#nexttick&quot;&gt;vm.$nextTick&lt;/a&gt; inside of &lt;code&gt;mounted&lt;/code&gt;:</source>
          <target state="translated">注 &lt;code&gt;mounted&lt;/code&gt; ん&lt;strong&gt;ではない&lt;/strong&gt;すべての子コンポーネントにもマウントされていることを保証します。あなたは全体のビューがレンダリングされるまで待ちたい場合は、使用することができ&lt;a href=&quot;instance-methods#nexttick&quot;&gt;、VMを$ nextTickする。&lt;/a&gt;内部 &lt;code&gt;mounted&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8aa1b05ebbda7e5b2744c6d248de2032ac1d216f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;target=&quot;_blank&quot;&lt;/code&gt; is not supported on &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt;, so if you need to open a link in a new tab, you have to use &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; instead.</source>
          <target state="translated">なお、 &lt;code&gt;target=&quot;_blank&quot;&lt;/code&gt; でサポートされていません &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; あなたは新しいタブでリンクを開く必要がある場合ので、あなたが使用する必要があり、 &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 代わりに。</target>
        </trans-unit>
        <trans-unit id="e4d9853311324c1062785017be6c36f8e6cda485" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;updated&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; guarantee that all child components have also been re-rendered. If you want to wait until the entire view has been re-rendered, you can use &lt;a href=&quot;#vm-nextTick&quot;&gt;vm.$nextTick&lt;/a&gt; inside of &lt;code&gt;updated&lt;/code&gt;:</source>
          <target state="translated">ことを注意 &lt;code&gt;updated&lt;/code&gt; ない&lt;strong&gt;ではない&lt;/strong&gt;、すべての子コンポーネントも再描画されていることを保証します。あなたはビュー全体が再描画されるまで待つしたい場合は、使用することができ&lt;a href=&quot;#vm-nextTick&quot;&gt;、VMを$ nextTickする。&lt;/a&gt;内部の &lt;code&gt;updated&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="736452a7cde671c4028bd0f51d1cfa315c95c76a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;updated&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; guarantee that all child components have also been re-rendered. If you want to wait until the entire view has been re-rendered, you can use &lt;a href=&quot;instance-methods#nexttick&quot;&gt;vm.$nextTick&lt;/a&gt; inside of &lt;code&gt;updated&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;updated&lt;/code&gt; は、すべての子コンポーネントも再レンダリングされたことを保証するものでは&lt;strong&gt;ない&lt;/strong&gt;ことに注意してください。ビュー全体が再レンダリングされるまで待ちたい場合は、 &lt;code&gt;updated&lt;/code&gt; ：内で&lt;a href=&quot;instance-methods#nexttick&quot;&gt;vm。$ nextTickを&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="e111be77d17fe6743b1bb02879c8402ce1acfd03" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;v-bind&lt;/code&gt; with the &lt;code&gt;.sync&lt;/code&gt; modifier does &lt;strong&gt;not&lt;/strong&gt; work with expressions (e.g. &lt;code&gt;v-bind:title.sync=&amp;rdquo;doc.title + &amp;lsquo;!&amp;rsquo;&amp;rdquo;&lt;/code&gt; is invalid). Instead, you must only provide the name of the property you want to bind, similar to &lt;code&gt;v-model&lt;/code&gt;.</source>
          <target state="translated">なお、 &lt;code&gt;v-bind&lt;/code&gt; と &lt;code&gt;.sync&lt;/code&gt; 修飾子がない&lt;strong&gt;ではない&lt;/strong&gt;表情で作業（例えば &lt;code&gt;v-bind:title.sync=&amp;rdquo;doc.title + &amp;lsquo;!&amp;rsquo;&amp;rdquo;&lt;/code&gt; 無効です）。代わりに、 &lt;code&gt;v-model&lt;/code&gt; のように、バインドするプロパティの名前のみを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="771a269b6d8c0e9ec3e7216d190b9a4d937f48ce" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;v-show&lt;/code&gt; doesn&amp;rsquo;t support the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element, nor does it work with &lt;code&gt;v-else&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;v-show&lt;/code&gt; は &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 要素をサポートしておらず、 &lt;code&gt;v-else&lt;/code&gt; でも機能しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="8b9184088f073256f499eaedf7653670276bb736" translate="yes" xml:space="preserve">
          <source>Note that &lt;em&gt;you should not use an arrow function to define a watcher&lt;/em&gt; (e.g. &lt;code&gt;searchQuery: newValue =&amp;gt; this.updateAutocomplete(newValue)&lt;/code&gt;). The reason is arrow functions bind the parent context, so &lt;code&gt;this&lt;/code&gt; will not be the component instance as you expect and &lt;code&gt;this.updateAutocomplete&lt;/code&gt; will be undefined.</source>
          <target state="translated">&lt;em&gt;ウォッチャーを定義するために矢印関数を使用しない&lt;/em&gt;で&lt;em&gt;ください&lt;/em&gt;（例： &lt;code&gt;searchQuery: newValue =&amp;gt; this.updateAutocomplete(newValue)&lt;/code&gt; ）。その理由は、矢印関数が親コンテキストをバインドするため、 &lt;code&gt;this&lt;/code&gt; は期待どおりのコンポーネントインスタンスではなく、 &lt;code&gt;this.updateAutocomplete&lt;/code&gt; は未定義になります。</target>
        </trans-unit>
        <trans-unit id="a4d9068c552bdf157869d707a68e7ff8a3725d0e" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;&lt;code&gt;v-slot&lt;/code&gt; can only be added to a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;&lt;/strong&gt; (with &lt;a href=&quot;#Abbreviated-Syntax-for-Lone-Default-Slots&quot;&gt;one exception&lt;/a&gt;), unlike the deprecated &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;&lt;code&gt;slot&lt;/code&gt; attribute&lt;/a&gt;.</source>
          <target state="translated">非推奨の&lt;a href=&quot;#Deprecated-Syntax&quot;&gt; &lt;code&gt;slot&lt;/code&gt; &lt;/a&gt;属性とは異なり、&lt;strong&gt; &lt;code&gt;v-slot&lt;/code&gt; は &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;のみ追加できることに&lt;/strong&gt;注意してください（&lt;a href=&quot;#Abbreviated-Syntax-for-Lone-Default-Slots&quot;&gt;1つの例外を除く&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="da6d6a25d31f792c92e4d4f94e109dce6aa1ce03" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;&lt;code&gt;v-slot&lt;/code&gt; can only be added to a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;&lt;/strong&gt; (with &lt;a href=&quot;#abbreviated-syntax-for-lone-default-slots&quot;&gt;one exception&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;v-slot&lt;/code&gt; は &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; に&lt;/strong&gt;&lt;strong&gt;のみ追加できることに&lt;/strong&gt;注意してください（&lt;a href=&quot;#abbreviated-syntax-for-lone-default-slots&quot;&gt;1つの例外を除く&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="776dcb74ada7f4cc1814737bb17df3646b8395ff" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;locally registered components are &lt;em&gt;not&lt;/em&gt; also available in subcomponents&lt;/strong&gt;. For example, if you wanted &lt;code&gt;ComponentA&lt;/code&gt; to be available in &lt;code&gt;ComponentB&lt;/code&gt;, you&amp;rsquo;d have to use:</source>
          <target state="translated">&lt;strong&gt;ローカルに登録されたコンポーネントは、サブコンポーネントでも使用でき&lt;em&gt;ない&lt;/em&gt;&lt;/strong&gt;ことに注意してください。あなたが望んでいた場合たとえば、 &lt;code&gt;ComponentA&lt;/code&gt; はで利用できるようにするために &lt;code&gt;ComponentB&lt;/code&gt; 、あなたが使用する必要があるだろう。</target>
        </trans-unit>
        <trans-unit id="bf48dec89b052e2c67a866740d5df77b8220622a" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;locally registered components are &lt;em&gt;not&lt;/em&gt; also available in subcomponents&lt;/strong&gt;. For example, if you wanted &lt;code&gt;ComponentA&lt;/code&gt; to be available in &lt;code&gt;ComponentB&lt;/code&gt;, you'd have to use:</source>
          <target state="translated">&lt;strong&gt;ローカルに登録されたコンポーネントは、サブコンポーネントでも使用でき&lt;em&gt;ない&lt;/em&gt;&lt;/strong&gt;ことに注意してください。あなたが望んでいた場合たとえば、 &lt;code&gt;ComponentA&lt;/code&gt; はで利用できるようにするために &lt;code&gt;ComponentB&lt;/code&gt; 、あなたが使用する必要があるだろう。</target>
        </trans-unit>
        <trans-unit id="8881ac4ac19e2ded818c92290bbcf16a14c24745" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;you should not use an arrow function to define a method&lt;/strong&gt; (e.g. &lt;code&gt;plus: () =&amp;gt; this.a++&lt;/code&gt;). The reason is arrow functions bind the parent context, so &lt;code&gt;this&lt;/code&gt; will not be the Vue instance as you expect and &lt;code&gt;this.a&lt;/code&gt; will be undefined.</source>
          <target state="translated">&lt;strong&gt;メソッドの定義にアロー関数を使用しない&lt;/strong&gt;で&lt;strong&gt;ください&lt;/strong&gt;（例： &lt;code&gt;plus: () =&amp;gt; this.a++&lt;/code&gt; ）。理由は、矢印関数が親コンテキストをバインドするため、 &lt;code&gt;this&lt;/code&gt; は期待どおりのVueインスタンスではなく、 &lt;code&gt;this.a&lt;/code&gt; は未定義になります。</target>
        </trans-unit>
        <trans-unit id="641353cb3566fc5149312b741e1f12c37e6b249c" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;you should not use an arrow function to define a method&lt;/strong&gt; (e.g. &lt;code&gt;plus: () =&amp;gt; this.a++&lt;/code&gt;). The reason is arrow functions bind the parent context, so &lt;code&gt;this&lt;/code&gt; will not be the component instance as you expect and &lt;code&gt;this.a&lt;/code&gt; will be undefined.</source>
          <target state="translated">&lt;strong&gt;メソッドを定義するために矢印関数を使用しないように&lt;/strong&gt;注意し&lt;strong&gt;てください&lt;/strong&gt;（例： &lt;code&gt;plus: () =&amp;gt; this.a++&lt;/code&gt; ）。その理由は、矢印関数が親コンテキストをバインドするため、 &lt;code&gt;this&lt;/code&gt; は期待どおりのコンポーネントインスタンスではなく、 &lt;code&gt;this.a&lt;/code&gt; は未定義になります。</target>
        </trans-unit>
        <trans-unit id="835968cbd8027db3d9ca26ddf24e18c1f5c52040" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;you should not use an arrow function to define a watcher&lt;/strong&gt; (e.g. &lt;code&gt;searchQuery: newValue =&amp;gt; this.updateAutocomplete(newValue)&lt;/code&gt;). The reason is arrow functions bind the parent context, so &lt;code&gt;this&lt;/code&gt; will not be the Vue instance as you expect and &lt;code&gt;this.updateAutocomplete&lt;/code&gt; will be undefined.</source>
          <target state="translated">&lt;strong&gt;ウォッチャーの定義にアロー関数を使用しない&lt;/strong&gt;で&lt;strong&gt;ください&lt;/strong&gt;（例： &lt;code&gt;searchQuery: newValue =&amp;gt; this.updateAutocomplete(newValue)&lt;/code&gt; ）。理由は、矢印関数が親コンテキストをバインドするため、 &lt;code&gt;this&lt;/code&gt; は期待どおりのVueインスタンスではなく、 &lt;code&gt;this.updateAutocomplete&lt;/code&gt; が未定義になるためです。</target>
        </trans-unit>
        <trans-unit id="ae4a42d86a3cca81f57342eb0f1aed6f05d0e695" translate="yes" xml:space="preserve">
          <source>Note that Vue&amp;rsquo;s event system is different from the browser&amp;rsquo;s &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget&quot;&gt;EventTarget API&lt;/a&gt;. Though they work similarly, &lt;code&gt;$emit&lt;/code&gt;, &lt;code&gt;$on&lt;/code&gt;, and &lt;code&gt;$off&lt;/code&gt; are &lt;strong&gt;not&lt;/strong&gt; aliases for &lt;code&gt;dispatchEvent&lt;/code&gt;, &lt;code&gt;addEventListener&lt;/code&gt;, and &lt;code&gt;removeEventListener&lt;/code&gt;.</source>
          <target state="translated">Vueのイベントシステムは、ブラウザの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget&quot;&gt;EventTarget API&lt;/a&gt;とは異なることに注意してください。 &lt;code&gt;$emit&lt;/code&gt; 、 &lt;code&gt;$on&lt;/code&gt; 、および &lt;code&gt;$off&lt;/code&gt; は同様に機能しますが、 &lt;code&gt;dispatchEvent&lt;/code&gt; 、 &lt;code&gt;addEventListener&lt;/code&gt; 、および &lt;code&gt;removeEventListener&lt;/code&gt; のエイリアスではあり&lt;strong&gt;ません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="081986e34f15d320aaefef70aa73f69abdde7609" translate="yes" xml:space="preserve">
          <source>Note that all native HTML and SVG tags don't need to be matched in this function - Vue parser performs this check automatically</source>
          <target state="translated">この関数では、すべてのネイティブ HTML タグと SVG タグを一致させる必要はありません-Vue パーサーが自動的にこのチェックを行います。</target>
        </trans-unit>
        <trans-unit id="34975db8bc1ca3043980cfeb4c62b733ac3c9bed" translate="yes" xml:space="preserve">
          <source>Note that every child in a &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; must be &lt;a href=&quot;special-attributes#key&quot;&gt;&lt;strong&gt;uniquely keyed&lt;/strong&gt;&lt;/a&gt; for the animations to work properly.</source>
          <target state="translated">アニメーションが正しく機能するには、 &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; 内のすべての子に&lt;a href=&quot;special-attributes#key&quot;&gt;&lt;strong&gt;一意のキー&lt;/strong&gt;&lt;/a&gt;を設定する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9c4518368215428ba1ec224631fb3c0691204e72" translate="yes" xml:space="preserve">
          <source>Note that for other directives (e.g. &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-show&lt;/code&gt;), JavaScript&amp;rsquo;s normal truthiness still applies.</source>
          <target state="translated">他のディレクティブ（ &lt;code&gt;v-if&lt;/code&gt; や &lt;code&gt;v-show&lt;/code&gt; など）については、JavaScriptの通常の真実性が引き続き適用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="59c87a2470ce03d315d2bf588709c8b05af9d942" translate="yes" xml:space="preserve">
          <source>Note that if you use an arrow function with a computed property, &lt;code&gt;this&lt;/code&gt; won&amp;rsquo;t be the component&amp;rsquo;s instance, but you can still access the instance as the function&amp;rsquo;s first argument:</source>
          <target state="translated">計算されたプロパティで矢印関数を使用する場合、 &lt;code&gt;this&lt;/code&gt; はコンポーネントのインスタンスにはなりませんが、関数の最初の引数としてインスタンスにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="56e9ff50c8f4d3af5530daf6166e647efccff678" translate="yes" xml:space="preserve">
          <source>Note that if you use an arrow function with a computed property, &lt;code&gt;this&lt;/code&gt; won't be the component's instance, but you can still access the instance as the function's first argument:</source>
          <target state="translated">計算されたプロパティで矢印関数を使用する場合、 &lt;code&gt;this&lt;/code&gt; はコンポーネントのインスタンスにはなりませんが、関数の最初の引数としてインスタンスにアクセスできることに注意してください。</target>
        </trans-unit>
        <trans-unit id="76ac594b131a812ccc4dec6f17d0ccc6f38ab19e" translate="yes" xml:space="preserve">
          <source>Note that if you use an arrow function with the &lt;code&gt;data&lt;/code&gt; property, &lt;code&gt;this&lt;/code&gt; won&amp;rsquo;t be the component&amp;rsquo;s instance, but you can still access the instance as the function&amp;rsquo;s first argument:</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; プロパティでアロー関数を使用する場合、 &lt;code&gt;this&lt;/code&gt; はコンポーネントのインスタンスにはなりませんが、関数の最初の引数としてインスタンスにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="b844a1894b3639cf8e6947f52c1732f36fa3f2ea" translate="yes" xml:space="preserve">
          <source>Note that if you use an arrow function with the &lt;code&gt;data&lt;/code&gt; property, &lt;code&gt;this&lt;/code&gt; won't be the component's instance, but you can still access the instance as the function's first argument:</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; プロパティでarrow関数を使用する場合、 &lt;code&gt;this&lt;/code&gt; はコンポーネントのインスタンスにはなりませんが、関数の最初の引数としてインスタンスにアクセスできることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b92212320fc7b39925a58ec2e6b387152eda8b23" translate="yes" xml:space="preserve">
          <source>Note that in ES2015+, placing a variable name like &lt;code&gt;ComponentA&lt;/code&gt; inside an object is shorthand for &lt;code&gt;ComponentA: ComponentA&lt;/code&gt;, meaning the name of the variable is both:</source>
          <target state="translated">ES2015 +では、 &lt;code&gt;ComponentA&lt;/code&gt; のような変数名をオブジェクト内に配置することは、 &lt;code&gt;ComponentA: ComponentA&lt;/code&gt; 省略形です。つまり、変数の名前は両方です。</target>
        </trans-unit>
        <trans-unit id="38d7decb45ee1373ac91755a507d8307efe29952" translate="yes" xml:space="preserve">
          <source>Note that in this method we update the state of our app without touching the DOM - all DOM manipulations are handled by Vue, and the code you write is focused on the underlying logic.</source>
          <target state="translated">このメソッドでは、DOM に触れることなくアプリの状態を更新することに注意してください。DOM の操作はすべて Vue によって処理され、あなたが書くコードは基礎となるロジックに焦点を当てています。</target>
        </trans-unit>
        <trans-unit id="d39c5b6e21dbfd1407f27da7320c3009d1f4fce3" translate="yes" xml:space="preserve">
          <source>Note that it&amp;rsquo;s &lt;strong&gt;not&lt;/strong&gt; recommended to use &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; together. Refer to &lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;style guide&lt;/a&gt; for details.</source>
          <target state="translated">それがだと注意&lt;strong&gt;ません&lt;/strong&gt;使用することをお勧め &lt;code&gt;v-if&lt;/code&gt; と &lt;code&gt;v-for&lt;/code&gt; 一緒に。詳細は&lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;スタイルガイド&lt;/a&gt;をご参照ください。</target>
        </trans-unit>
        <trans-unit id="faa9c0503d39b650734e81c8480f148f8158dc6a" translate="yes" xml:space="preserve">
          <source>Note that it's &lt;strong&gt;not&lt;/strong&gt; recommended to use &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; together. Refer to &lt;a href=&quot;../style-guide/index#avoid-v-if-with-v-for-essential&quot;&gt;style guide&lt;/a&gt; for details.</source>
          <target state="translated">それがだと注意&lt;strong&gt;ません&lt;/strong&gt;使用することをお勧め &lt;code&gt;v-if&lt;/code&gt; と &lt;code&gt;v-for&lt;/code&gt; 一緒に。詳細については、&lt;a href=&quot;../style-guide/index#avoid-v-if-with-v-for-essential&quot;&gt;スタイルガイド&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="8cc9bca625b5e998dd62bb4f93dc90d8caa850ab" translate="yes" xml:space="preserve">
          <source>Note that modifier keys are different from regular keys and when used with &lt;code&gt;keyup&lt;/code&gt; events, they have to be pressed when the event is emitted. In other words, &lt;code&gt;keyup.ctrl&lt;/code&gt; will only trigger if you release a key while holding down &lt;code&gt;ctrl&lt;/code&gt;. It won&amp;rsquo;t trigger if you release the &lt;code&gt;ctrl&lt;/code&gt; key alone. If you do want such behaviour, use the &lt;code&gt;keyCode&lt;/code&gt; for &lt;code&gt;ctrl&lt;/code&gt; instead: &lt;code&gt;keyup.17&lt;/code&gt;.</source>
          <target state="translated">修飾キーは通常のキーとは異なり、キー &lt;code&gt;keyup&lt;/code&gt; イベントで使用する場合、イベントが発生したときにそれらを押す必要があることに注意してください。つまり、 &lt;code&gt;ctrl&lt;/code&gt; を押しながらキーを &lt;code&gt;keyup.ctrl&lt;/code&gt; 場合にのみ、keyup.ctrlがトリガーされます。 &lt;code&gt;ctrl&lt;/code&gt; キーだけを離してもトリガーされません。このような動作が必要な場合は、代わりに &lt;code&gt;ctrl&lt;/code&gt; の &lt;code&gt;keyCode&lt;/code&gt; を使用してください： &lt;code&gt;keyup.17&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a575c0c184061dc0e5bebafa17e97ed49b8df32d" translate="yes" xml:space="preserve">
          <source>Note that modifier keys are different from regular keys and when used with &lt;code&gt;keyup&lt;/code&gt; events, they have to be pressed when the event is emitted. In other words, &lt;code&gt;keyup.ctrl&lt;/code&gt; will only trigger if you release a key while holding down &lt;code&gt;ctrl&lt;/code&gt;. It won't trigger if you release the &lt;code&gt;ctrl&lt;/code&gt; key alone</source>
          <target state="translated">修飾キーは通常のキーとは異なり、キー &lt;code&gt;keyup&lt;/code&gt; イベントで使用する場合は、イベントが発行されたときに押す必要があることに注意してください。つまり、 &lt;code&gt;keyup.ctrl&lt;/code&gt; は、 &lt;code&gt;ctrl&lt;/code&gt; キーを押しながらキーを離した場合にのみトリガーされます。 &lt;code&gt;ctrl&lt;/code&gt; キーを単独で離してもトリガーされません</target>
        </trans-unit>
        <trans-unit id="782e93758e1a8da260782325b450852c804d73f2" translate="yes" xml:space="preserve">
          <source>Note that objects and arrays in JavaScript are passed by reference, so if the prop is an array or object, mutating the object or array itself inside the child component &lt;strong&gt;will&lt;/strong&gt; affect parent state.</source>
          <target state="translated">JavaScriptのオブジェクトと配列は参照によって渡されるため、propが配列またはオブジェクトの場合、子コンポーネント内でオブジェクトまたは配列自体を変更する&lt;strong&gt;と&lt;/strong&gt;、親の状態に影響します。</target>
        </trans-unit>
        <trans-unit id="3151ecc6011010f2ef8540f5f9ad70909763b9e7" translate="yes" xml:space="preserve">
          <source>Note that props are validated &lt;strong&gt;before&lt;/strong&gt; a component instance is created, so instance properties (e.g. &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;computed&lt;/code&gt;, etc) will not be available inside &lt;code&gt;default&lt;/code&gt; or &lt;code&gt;validator&lt;/code&gt; functions.</source>
          <target state="translated">コンポーネントのインスタンスが作成さ&lt;strong&gt;れる前に&lt;/strong&gt;小道具が検証さ&lt;strong&gt;れる&lt;/strong&gt;ため、インスタンスのプロパティ（例： &lt;code&gt;data&lt;/code&gt; 、 &lt;code&gt;computed&lt;/code&gt; など）は、 &lt;code&gt;default&lt;/code&gt; または &lt;code&gt;validator&lt;/code&gt; 関数内では使用できません。</target>
        </trans-unit>
        <trans-unit id="84136e18c6c864e905f34757af495e8cd152f729" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; elements are still efficiently re-used, because they don&amp;rsquo;t have &lt;code&gt;key&lt;/code&gt; attributes.</source>
          <target state="translated">&lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; 要素は &lt;code&gt;key&lt;/code&gt; 属性を持たないため、依然として効率的に再利用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="8c6f6de9e542ddf567ea5a5cf5a2069dcc0d7d80" translate="yes" xml:space="preserve">
          <source>Note that the abbreviated syntax for default slot &lt;strong&gt;cannot&lt;/strong&gt; be mixed with named slots, as it would lead to scope ambiguity:</source>
          <target state="translated">スコープのあいまいさを招くため、デフォルトスロットの省略構文を名前付きスロットと混在さ&lt;strong&gt;せることはできません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="d9393e6c94f522abc9f4a9fa2054455519ccc108" translate="yes" xml:space="preserve">
          <source>Note that the same merge strategies are used in &lt;code&gt;Vue.extend()&lt;/code&gt;.</source>
          <target state="translated">同じマージ戦略が &lt;code&gt;Vue.extend()&lt;/code&gt; で使用されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b19b165a75219255a66fd8c95f88d1f25d66fca4" translate="yes" xml:space="preserve">
          <source>Note that with &lt;code&gt;immediate&lt;/code&gt; option you won&amp;rsquo;t be able to unwatch the given property on the first callback call.</source>
          <target state="translated">&lt;code&gt;immediate&lt;/code&gt; オプションでは、最初のコールバック呼び出しで指定されたプロパティを監視解除できないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="a7894715668a9552d744e1da5cfc8208dcef0a9e" translate="yes" xml:space="preserve">
          <source>Note that with &lt;code&gt;immediate&lt;/code&gt; option you won't be able to unwatch the given property on the first callback call.</source>
          <target state="translated">&lt;code&gt;immediate&lt;/code&gt; オプションを使用すると、最初のコールバック呼び出しで指定されたプロパティの監視を解除できないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="b0d1222c87974bff7446442d086ef17e96241dd6" translate="yes" xml:space="preserve">
          <source>Note that with this approach, you can only use methods, not computed properties, as the latter only make sense when defined in the context of an individual component.</source>
          <target state="translated">このアプローチでは、メソッドのみを使用することができ、計算されたプロパティは使用できないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="09e5eb4daa67f823465bf8f428dfecbb3f5135d5" translate="yes" xml:space="preserve">
          <source>Note that you have to include &lt;code&gt;strict: true&lt;/code&gt; (or at least &lt;code&gt;noImplicitThis: true&lt;/code&gt; which is a part of &lt;code&gt;strict&lt;/code&gt; flag) to leverage type checking of &lt;code&gt;this&lt;/code&gt; in component methods otherwise it is always treated as &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">あなたが含まれなければならないことに留意されたい &lt;code&gt;strict: true&lt;/code&gt; （または少なくとも &lt;code&gt;noImplicitThis: true&lt;/code&gt; の一部であり、 &lt;code&gt;strict&lt;/code&gt; フラグ）のレバレッジ型チェックに &lt;code&gt;this&lt;/code&gt; コンポーネントのメソッドでそれ以外の場合は、常にとして扱われる &lt;code&gt;any&lt;/code&gt; タイプ。</target>
        </trans-unit>
        <trans-unit id="3c9f11f51925aec7450ae0935dd3b229a967e2c1" translate="yes" xml:space="preserve">
          <source>Note that you must use &lt;a href=&quot;https://github.com/vuejs/vue-router&quot;&gt;Vue Router&lt;/a&gt; 2.4.0+ if you wish to use the above syntax for route components.</source>
          <target state="translated">ルートコンポーネントに上記の構文を使用する場合は、&lt;a href=&quot;https://github.com/vuejs/vue-router&quot;&gt;Vue Router&lt;/a&gt; 2.4.0+を使用する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a9a477d195904adab9bde1cc82c2b08801e6b422" translate="yes" xml:space="preserve">
          <source>Note that you still have to declare the &lt;code&gt;checked&lt;/code&gt; prop in component&amp;rsquo;s &lt;code&gt;props&lt;/code&gt; option.</source>
          <target state="translated">コンポーネントの &lt;code&gt;props&lt;/code&gt; オプションで &lt;code&gt;checked&lt;/code&gt; プロップを宣言する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="translated">そのことに注意してください。</target>
        </trans-unit>
        <trans-unit id="ea28128f17211fcef9f44807c81be52f215e0561" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;is=&quot;todo-item&quot;&lt;/code&gt; attribute. This is necessary in DOM templates, because only an &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element is valid inside a &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;. It does the same thing as &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt;, but works around a potential browser parsing error. See &lt;a href=&quot;components#DOM-Template-Parsing-Caveats&quot;&gt;DOM Template Parsing Caveats&lt;/a&gt; to learn more.</source>
          <target state="translated">&lt;code&gt;is=&quot;todo-item&quot;&lt;/code&gt; 属性に注意してください。 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 要素のみが &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; 内で有効であるため、これはDOMテンプレートで必要です。 &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt; と同じことを行いますが、潜在的なブラウザ解析エラーを回避します。詳細については、&lt;a href=&quot;components#DOM-Template-Parsing-Caveats&quot;&gt;DOMテンプレートの解析に関する警告&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="dd73b9ea52e1db8097dc7a516386c176573e1dbe" translate="yes" xml:space="preserve">
          <source>Note this &lt;code&gt;props&lt;/code&gt; object is reactive - i.e. it is updated when new props are passed in, and can be observed and reacted upon using &lt;code&gt;watchEffect&lt;/code&gt; or &lt;code&gt;watch&lt;/code&gt;:</source>
          <target state="translated">この &lt;code&gt;props&lt;/code&gt; オブジェクトはリアクティブであることに注意してください。つまり、新しい小道具が渡されると更新され、 &lt;code&gt;watchEffect&lt;/code&gt; または &lt;code&gt;watch&lt;/code&gt; を使用して監視および反応できます。</target>
        </trans-unit>
        <trans-unit id="056476ec0b830039894a5b3089419b4a5d60c537" translate="yes" xml:space="preserve">
          <source>Note, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; is designed for the case where it has one direct child component that is being toggled. It does not work if you have &lt;code&gt;v-for&lt;/code&gt; inside it. When there are multiple conditional children, as above, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; requires that only one child is rendered at a time.</source>
          <target state="translated">注、 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 、それがトグルされている1つの直接の子要素を持っている場合のために設計されています。内部に &lt;code&gt;v-for&lt;/code&gt; がある場合は機能しません。上記のように複数の条件付き子がある場合、 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; は一度に1つの子のみがレンダリングされることを要求します。</target>
        </trans-unit>
        <trans-unit id="da58435f34b35b1887295eb16c900d592e7442c7" translate="yes" xml:space="preserve">
          <source>Note: In 3.x, slots can be rendered as the root with native &lt;a href=&quot;fragments&quot;&gt;fragments&lt;/a&gt; support!</source>
          <target state="translated">注：3.xでは、スロットはネイティブ&lt;a href=&quot;fragments&quot;&gt;フラグメントを&lt;/a&gt;サポートするルートとしてレンダリングできます。</target>
        </trans-unit>
        <trans-unit id="1d29dd3fc2d4ef6a6ce13aedfe8172fb47b148bd" translate="yes" xml:space="preserve">
          <source>Note: On Macintosh keyboards, meta is the command key (⌘). On Windows keyboards, meta is the Windows key (⊞). On Sun Microsystems keyboards, meta is marked as a solid diamond (◆). On certain keyboards, specifically MIT and Lisp machine keyboards and successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled &amp;ldquo;META&amp;rdquo;. On Symbolics keyboards, meta is labeled &amp;ldquo;META&amp;rdquo; or &amp;ldquo;Meta&amp;rdquo;.</source>
          <target state="translated">注：Macintoshキーボードでは、メタはコマンドキー（⌘）です。Windowsキーボードでは、メタはWindowsキー（⊞）です。Sun Microsystemsキーボードでは、メタは塗りつぶされたひし形（◆）としてマークされています。特定のキーボード、特にMITおよびLispマシンのキーボードとその後継機（Knightキーボード、スペースカデットキーボードなど）では、メタに「META」というラベルが付いています。シンボリックキーボードでは、メタには「META」または「Meta」というラベルが付いています。</target>
        </trans-unit>
        <trans-unit id="9028e9d05d6a455c1974133f7e5293ddabaa337b" translate="yes" xml:space="preserve">
          <source>Note: in versions before 2.3.0, the &lt;code&gt;props&lt;/code&gt; option is required if you wish to accept props in a functional component. In 2.3.0+ you can omit the &lt;code&gt;props&lt;/code&gt; option and all attributes found on the component node will be implicitly extracted as props.</source>
          <target state="translated">注：2.3.0より前のバージョンでは、機能コンポーネントで小道具を受け入れる場合は、 &lt;code&gt;props&lt;/code&gt; オプションが必要です。2.3.0以降では、 &lt;code&gt;props&lt;/code&gt; オプションを省略でき、コンポーネントノードにあるすべての属性が暗黙的にpropsとして抽出されます。</target>
        </trans-unit>
        <trans-unit id="334bf93841cedfd326dcac54017cd67d04bd2494" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;provide&lt;/code&gt; and &lt;code&gt;inject&lt;/code&gt; bindings are NOT reactive. This is intentional. However, if you pass down a reactive object, properties on that object do remain reactive.</source>
          <target state="translated">注： &lt;code&gt;provide&lt;/code&gt; バインディングと &lt;code&gt;inject&lt;/code&gt; バインディングは反応しません。これは意図的なものです。ただし、リアクティブオブジェクトを渡すと、そのオブジェクトのプロパティはリアクティブのままになります。</target>
        </trans-unit>
        <trans-unit id="94a9d4709f41005aebf7f630aea0e9e8dcba6214" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;provide&lt;/code&gt; and &lt;code&gt;inject&lt;/code&gt; bindings are NOT reactive. This is intentional. However, if you pass down an observed object, properties on that object do remain reactive.</source>
          <target state="translated">注：バインディングの &lt;code&gt;provide&lt;/code&gt; と &lt;code&gt;inject&lt;/code&gt; は反応しません。これは意図的なものです。ただし、監視対象のオブジェクトを渡す場合、そのオブジェクトのプロパティは引き続き反応します。</target>
        </trans-unit>
        <trans-unit id="0908b002b159b7c5ec7a450ce89576a7ca8ba515" translate="yes" xml:space="preserve">
          <source>Note: the beta channel may conflict with the stable version of devtools so you may need to temporarily disable the stable version for the beta channel to work properly.</source>
          <target state="translated">注意:ベータ版チャンネルは安定版の devtools と競合する可能性があるので、ベータ版チャンネルが正常に動作するためには、一時的に安定版を無効にする必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="458f74037e32ee6cfbdde797c11bd7a73de43a01" translate="yes" xml:space="preserve">
          <source>Note: this option does &lt;strong&gt;not&lt;/strong&gt; affect &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;style&lt;/code&gt; bindings.</source>
          <target state="translated">注：このオプションは、 &lt;code&gt;class&lt;/code&gt; と &lt;code&gt;style&lt;/code&gt; バインディングに&lt;strong&gt;は&lt;/strong&gt;影響し&lt;strong&gt;ませ&lt;/strong&gt;ん。</target>
        </trans-unit>
        <trans-unit id="08b75004d7b0e0a6d3825e3c52c9e938d2e8a019" translate="yes" xml:space="preserve">
          <source>Note: this section only affects cases where Vue templates are directly written in the page's HTML.</source>
          <target state="translated">注:このセクションは、Vue テンプレートがページの HTML に直接記述されている場合にのみ影響します。</target>
        </trans-unit>
        <trans-unit id="6381b17960004aa9578834992d92eb41037168d9" translate="yes" xml:space="preserve">
          <source>Note: this section only affects cases where Vue templates are directly written in the page's HTML. When using in-DOM templates, the template is subject to native HTML parsing rules. Some HTML elements, such as &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;ol&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; have restrictions on what elements can appear inside them, and some elements such as &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; can only appear inside certain other elements.</source>
          <target state="translated">注：このセクションは、VueテンプレートがページのHTMLに直接記述されている場合にのみ影響します。 DOM内テンプレートを使用する場合、テンプレートはネイティブHTML解析ルールの対象となります。 &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;ol&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; などの一部のHTML要素には、内部に表示できる要素に制限があり、 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; などの一部の要素は他の特定の要素の内部に表示されます。</target>
        </trans-unit>
        <trans-unit id="0598de4737485dd16187bee300278ba69862eb70" translate="yes" xml:space="preserve">
          <source>Note: when mutating (rather than replacing) an Object or an Array, the old value will be the same as new value because they reference the same Object/Array. Vue doesn&amp;rsquo;t keep a copy of the pre-mutate value.</source>
          <target state="translated">注：オブジェクトまたは配列を（置き換えるのではなく）変更すると、同じオブジェクト/配列を参照するため、古い値は新しい値と同じになります。Vueは事前変換値のコピーを保持しません。</target>
        </trans-unit>
        <trans-unit id="b91291f0de6e06db99bb183c76dabbf60ffa395f" translate="yes" xml:space="preserve">
          <source>Notice all actions that mutate the store&amp;rsquo;s state are put inside the store itself. This type of centralized state management makes it easier to understand what type of mutations could happen and how they are triggered. Now when something goes wrong, we&amp;rsquo;ll also have a log of what happened leading up to the bug.</source>
          <target state="translated">ストアの状態を変更するすべてのアクションがストア自体の内部に置かれていることに注意してください。このタイプの一元化された状態管理により、発生する可能性のある変異のタイプと、それらがどのようにトリガーされるかを理解しやすくなります。何か問題が発生すると、バグに至るまでに何が起こったかのログも表示されます。</target>
        </trans-unit>
        <trans-unit id="571333a47c31bbee3623511f092d63b988f1b343" translate="yes" xml:space="preserve">
          <source>Notice all actions that mutate the store's state are put inside the store itself. This type of centralized state management makes it easier to understand what type of mutations could happen and how they are triggered. Now when something goes wrong, we'll also have a log of what happened leading up to the bug.</source>
          <target state="translated">ストアの状態を変異させるすべてのアクションは、ストア自体の内部に置かれていることに注意してください。このタイプの集中的な状態管理により、どのようなタイプの突然変異が起こり、どのようにトリガーされるかをより簡単に理解することができます。これで、何か問題が発生したときには、バグに至るまでに何が起こったかのログを取得することができるようになります。</target>
        </trans-unit>
        <trans-unit id="7fd794a6843de7d3ad1a1df1f2c8c06559b41eae" translate="yes" xml:space="preserve">
          <source>Notice how you can include &lt;code&gt;autocomplete='on'&lt;/code&gt; on the form element and it will apply to all inputs in your form. You can also set different &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete&quot;&gt;values for autocomplete attribute (opens new window)&lt;/a&gt; for each input.</source>
          <target state="translated">フォーム要素に &lt;code&gt;autocomplete='on'&lt;/code&gt; を含める方法に注意してください。これは、フォームのすべての入力に適用されます。入力ごとに&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete&quot;&gt;オートコンプリート属性（新しいウィンドウを開く）&lt;/a&gt;に異なる値を設定することもできます。</target>
        </trans-unit>
        <trans-unit id="73647a8d9626dfeb015e786688a6df3934b4f805" translate="yes" xml:space="preserve">
          <source>Notice that this will move the actual DOM nodes instead of being destroyed and recreated, and it will keep any component instances alive as well. All stateful HTML elements (i.e. a playing video) will keep their state.</source>
          <target state="translated">これにより、実際の DOM ノードが破壊されて再作成されるのではなく移動され、コンポーネント インスタンスも生きたまま維持されることに注意してください。すべてのステートフルな HTML 要素 (再生中の動画など)は、その状態を維持します。</target>
        </trans-unit>
        <trans-unit id="5bc1f6f3474e7672908319c7bc94aae61f59580d" translate="yes" xml:space="preserve">
          <source>Notice that when clicking on the buttons, each one maintains its own, separate &lt;code&gt;count&lt;/code&gt;. That&amp;rsquo;s because each time you use a component, a new &lt;strong&gt;instance&lt;/strong&gt; of it is created.</source>
          <target state="translated">ボタンをクリックすると、ボタンごとに独自の &lt;code&gt;count&lt;/code&gt; 維持されることに注意してください。これは、コンポーネントを使用するたびに、その新しい&lt;strong&gt;インスタンス&lt;/strong&gt;が作成されるためです。</target>
        </trans-unit>
        <trans-unit id="6d30d0e0ff05d60e422be32271f1e21965033ef6" translate="yes" xml:space="preserve">
          <source>Notice that when clicking on the buttons, each one maintains its own, separate &lt;code&gt;count&lt;/code&gt;. That's because each time you use a component, a new &lt;strong&gt;instance&lt;/strong&gt; of it is created.</source>
          <target state="translated">ボタンをクリックすると、それぞれが独自の個別の &lt;code&gt;count&lt;/code&gt; 維持することに注意してください。これは、コンポーネントを使用するたびに、そのコンポーネントの新しい&lt;strong&gt;インスタンス&lt;/strong&gt;が作成されるためです。</target>
        </trans-unit>
        <trans-unit id="dc80ae205fd608099bd57a38126221c490c9a421" translate="yes" xml:space="preserve">
          <source>Notice that when the component's &lt;code&gt;created&lt;/code&gt; lifecycle hook triggers, the &lt;code&gt;modelModifiers&lt;/code&gt; prop contains &lt;code&gt;capitalize&lt;/code&gt; and its value is &lt;code&gt;true&lt;/code&gt; - due to it being set on the &lt;code&gt;v-model&lt;/code&gt; binding &lt;code&gt;v-model.capitalize=&quot;myText&quot;&lt;/code&gt;.</source>
          <target state="translated">コンポーネントの &lt;code&gt;created&lt;/code&gt; ライフサイクルフックがトリガーされると、 &lt;code&gt;modelModifiers&lt;/code&gt; プロパティに &lt;code&gt;capitalize&lt;/code&gt; が含まれ、その値が &lt;code&gt;true&lt;/code&gt; になります。これは &lt;code&gt;v-model&lt;/code&gt; バインディング &lt;code&gt;v-model.capitalize=&quot;myText&quot;&lt;/code&gt; に設定されているためです。</target>
        </trans-unit>
        <trans-unit id="777758140398dbba4754b09995581bb165f2d561" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;v-model&lt;/code&gt; should work perfectly with this component:</source>
          <target state="translated">これで、 &lt;code&gt;v-model&lt;/code&gt; はこのコンポーネントで完全に機能するはずです。</target>
        </trans-unit>
        <trans-unit id="f41ecd46e8d6d6bb70e920ed57d983ae6565a184" translate="yes" xml:space="preserve">
          <source>Now both &lt;code&gt;ComponentA&lt;/code&gt; and &lt;code&gt;ComponentC&lt;/code&gt; can be used inside &lt;code&gt;ComponentB&lt;/code&gt;&amp;lsquo;s template.</source>
          <target state="translated">今両方 &lt;code&gt;ComponentA&lt;/code&gt; と &lt;code&gt;ComponentC&lt;/code&gt; が内部で使用することができ &lt;code&gt;ComponentB&lt;/code&gt; のテンプレート。</target>
        </trans-unit>
        <trans-unit id="d88909194979ead139b391709a958720c86553b7" translate="yes" xml:space="preserve">
          <source>Now both &lt;code&gt;ComponentA&lt;/code&gt; and &lt;code&gt;ComponentC&lt;/code&gt; can be used inside &lt;code&gt;ComponentB&lt;/code&gt;'s template.</source>
          <target state="translated">今両方 &lt;code&gt;ComponentA&lt;/code&gt; と &lt;code&gt;ComponentC&lt;/code&gt; が内部で使用することができ &lt;code&gt;ComponentB&lt;/code&gt; のテンプレート。</target>
        </trans-unit>
        <trans-unit id="caffa3b79738c5125111f76c75b50ac902d4aecd" translate="yes" xml:space="preserve">
          <source>Now everything inside the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; elements will be passed to the corresponding slots.</source>
          <target state="translated">これで、 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 要素内のすべてが対応するスロットに渡されます。</target>
        </trans-unit>
        <trans-unit id="64af1694b13df77b316f8c73909dd8b963af9613" translate="yes" xml:space="preserve">
          <source>Now everything inside the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; elements will be passed to the corresponding slots. Any content not wrapped in a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; using &lt;code&gt;v-slot&lt;/code&gt; is assumed to be for the default slot.</source>
          <target state="translated">これで、 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 要素内のすべてが対応するスロットに渡されます。 &lt;code&gt;v-slot&lt;/code&gt; を使用して &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; でラップされていないコンテンツは、デフォルトスロット用であると見なされます。</target>
        </trans-unit>
        <trans-unit id="3e4140c0dde663257b36afdec9358a935995f01d" translate="yes" xml:space="preserve">
          <source>Now in Vue 3, all functional components are created with a plain function. In other words, there is no need to define the &lt;code&gt;{ functional: true }&lt;/code&gt; component option.</source>
          <target state="translated">現在、Vue 3では、すべての機能コンポーネントがプレーン関数で作成されています。つまり、 &lt;code&gt;{ functional: true }&lt;/code&gt; コンポーネントオプションを定義する必要はありません。</target>
        </trans-unit>
        <trans-unit id="6d0f458e8cae4f3622f936273f3e1139e34d7a7b" translate="yes" xml:space="preserve">
          <source>Now in the component where you&amp;rsquo;ve defined this &lt;code&gt;ref&lt;/code&gt;, you can use:</source>
          <target state="translated">これで、この &lt;code&gt;ref&lt;/code&gt; を定義したコンポーネントで、次を使用できます。</target>
        </trans-unit>
        <trans-unit id="10c100aabba7af200c0826cfd9a4189752cd557e" translate="yes" xml:space="preserve">
          <source>Now it&amp;rsquo;s time to take a deep dive! One of Vue&amp;rsquo;s most distinct features is the unobtrusive reactivity system. Models are just plain JavaScript objects. When you modify them, the view updates. It makes state management simple and intuitive, but it&amp;rsquo;s also important to understand how it works to avoid some common gotchas. In this section, we are going to dig into some of the lower-level details of Vue&amp;rsquo;s reactivity system.</source>
          <target state="translated">それでは、詳細を見ていきましょう。Vueの最も特徴的な機能の1つは、目立たない反応システムです。モデルは単なるJavaScriptオブジェクトです。それらを変更すると、ビューが更新されます。状態管理がシンプルで直感的になりますが、一般的な問題を回避するためにそれがどのように機能するかを理解することも重要です。このセクションでは、Vueの反応性システムの下位レベルの詳細を掘り下げます。</target>
        </trans-unit>
        <trans-unit id="416cefac38d5a91dc03601ff2321b1747824eafd" translate="yes" xml:space="preserve">
          <source>Now it&amp;rsquo;s time to take a deep dive! One of Vue&amp;rsquo;s most distinct features is the unobtrusive reactivity system. Models are proxied JavaScript objects. When you modify them, the view updates. It makes state management simple and intuitive, but it&amp;rsquo;s also important to understand how it works to avoid some common gotchas. In this section, we are going to dig into some of the lower-level details of Vue&amp;rsquo;s reactivity system.</source>
          <target state="translated">さあ、深く掘り下げましょう！Vueの最も特徴的な機能の1つは、目立たない反応性システムです。モデルはプロキシされたJavaScriptオブジェクトです。それらを変更すると、ビューが更新されます。状態管理をシンプルかつ直感的にしますが、いくつかの一般的な落とし穴を回避するためにどのように機能するかを理解することも重要です。このセクションでは、Vueの反応性システムの低レベルの詳細のいくつかを掘り下げていきます。</target>
        </trans-unit>
        <trans-unit id="8b6e6c5e29a0011ecf92b2b3f2e105991af96fc7" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s add a button to enlarge the text right before the content of every post:</source>
          <target state="translated">次に、すべての投稿のコンテンツの直前にテキストを拡大するボタンを追加しましょう：</target>
        </trans-unit>
        <trans-unit id="27f3edc7f43414bdb880e462618cc2a4be655f49" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s dive into an example, transitioning entering and leaving using the same CSS classes we&amp;rsquo;ve used previously:</source>
          <target state="translated">次に、例を見て、前に使用したのと同じCSSクラスを使用して出入りを遷移させます。</target>
        </trans-unit>
        <trans-unit id="dd26b2548ee21e904e0d33fa95d291ffe37c263c" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s dive into an example. Here&amp;rsquo;s a JavaScript transition using Velocity.js:</source>
          <target state="translated">それでは、例を見てみましょう。Velocity.jsを使用したJavaScriptトランジションは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="88e72442353d1cc70a649bbfb7fde5fcd5a0942a" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s start with extracting the first logical concern (marked as &quot;1&quot; in the original snippet).</source>
          <target state="translated">それでは、最初の論理的な懸念事項（元のスニペットで「1」とマークされている）を抽出することから始めましょう。</target>
        </trans-unit>
        <trans-unit id="db457f96df4f0407b03b33810d84f20e49792e2d" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s update the transition for our on/off buttons with &lt;code&gt;out-in&lt;/code&gt;:</source>
          <target state="translated">次に、 &lt;code&gt;out-in&lt;/code&gt; を使用してオン/オフボタンの遷移を更新します。</target>
        </trans-unit>
        <trans-unit id="61d7e41c0d0afefd3a6e0b42734a3aa3ca5ebe0d" translate="yes" xml:space="preserve">
          <source>Now let's add a button to enlarge the text right before the content of every post:</source>
          <target state="translated">それでは、すべての投稿の内容の直前にテキストを拡大するボタンを追加してみましょう。</target>
        </trans-unit>
        <trans-unit id="56027a462aa3978a9b96d4374ca36d15fa649ef8" translate="yes" xml:space="preserve">
          <source>Now let's build the directive that accomplishes this:</source>
          <target state="translated">これを実現するディレクティブを作ってみましょう。</target>
        </trans-unit>
        <trans-unit id="f599733aef531ac3cec8a9e1bc4b342515b0f147" translate="yes" xml:space="preserve">
          <source>Now let's dive into an example, transitioning entering and leaving using the same CSS classes we've used previously:</source>
          <target state="translated">さて、以前に使用したのと同じCSSクラスを使用して、入力と退出を遷移させる例に飛び込んでみましょう。</target>
        </trans-unit>
        <trans-unit id="3324adaea061622687d6176489328922e25a0701" translate="yes" xml:space="preserve">
          <source>Now let's dive into an example. Here's a JavaScript transition using &lt;a href=&quot;https://greensock.com/&quot;&gt;GreenSock (opens new window)&lt;/a&gt;:</source>
          <target state="translated">それでは、例を見てみましょう。&lt;a href=&quot;https://greensock.com/&quot;&gt;GreenSock&lt;/a&gt;を使用したJavaScriptの移行は次のとおりです（新しいウィンドウが開きます）：</target>
        </trans-unit>
        <trans-unit id="6f77a5a07be37fa843c2b64e4b6651919be0542c" translate="yes" xml:space="preserve">
          <source>Now let's extend our directive logic to recalculate the distance to pin on component update:</source>
          <target state="translated">ここでは、コンポーネントの更新時にピンまでの距離を再計算するために、ディレクティブのロジックを拡張してみましょう。</target>
        </trans-unit>
        <trans-unit id="7b244b43642c6b5693f8cc0207f277488e09d82e" translate="yes" xml:space="preserve">
          <source>Now let's update the transition for our on/off buttons with &lt;code&gt;out-in&lt;/code&gt;:</source>
          <target state="translated">それでは、オン/オフボタンのトランジションを &lt;code&gt;out-in&lt;/code&gt; 更新しましょう：</target>
        </trans-unit>
        <trans-unit id="9b586c00a91f7688367b4cacd0212bee0c1ca54f" translate="yes" xml:space="preserve">
          <source>Now that the custom directive lifecycle hooks mirror those of the components themselves, they become easier to reason about and remember!</source>
          <target state="translated">カスタムディレクティブのライフサイクルフックがコンポーネント自体のそれを反映するようになったので、理由を説明したり覚えたりするのがより簡単になりました。</target>
        </trans-unit>
        <trans-unit id="17aacb98515307b9797f4efe520f56ffcc9d7f5e" translate="yes" xml:space="preserve">
          <source>Now that we have our prop set up, we can check the &lt;code&gt;modelModifiers&lt;/code&gt; object keys and write a handler to change the emitted value. In the code below we will capitalize the string whenever the &lt;code&gt;&amp;lt;input /&amp;gt;&lt;/code&gt; element fires an &lt;code&gt;input&lt;/code&gt; event.</source>
          <target state="translated">これで小道具が設定されたので、 &lt;code&gt;modelModifiers&lt;/code&gt; オブジェクトキーを確認し、出力された値を変更するハンドラーを作成できます。以下のコードでは、 &lt;code&gt;&amp;lt;input /&amp;gt;&lt;/code&gt; 要素が &lt;code&gt;input&lt;/code&gt; イベントを発生させるたびに文字列を大文字にします。</target>
        </trans-unit>
        <trans-unit id="8cf65b7d19a965e9b08bfa030c0b0ce8f415f6a3" translate="yes" xml:space="preserve">
          <source>Now that we know how watchers are updating the components, you might ask how those changes eventually make it to the DOM! Perhaps you&amp;rsquo;ve heard of the Virtual DOM before, many frameworks including Vue use this paradigm to make sure our interfaces reflect the changes we&amp;rsquo;re updating in JavaScript effectively</source>
          <target state="translated">ウォッチャーがコンポーネントをどのように更新しているかがわかったので、これらの変更が最終的にどのようにDOMに反映されるかを尋ねることができます。おそらく以前に仮想DOMについて聞いたことがあると思いますが、Vueを含む多くのフレームワークはこのパラダイムを使用して、JavaScriptで更新している変更をインターフェイスに効果的に反映させています。</target>
        </trans-unit>
        <trans-unit id="c8f0e4739b10c5c53576af812b04069f5b1133df" translate="yes" xml:space="preserve">
          <source>Now that we know the &lt;strong&gt;why&lt;/strong&gt; we can get to the &lt;strong&gt;how&lt;/strong&gt;. To start working with the Composition API we first need a place where we can actually use it. In a Vue component, we call this place the &lt;code&gt;setup&lt;/code&gt;.</source>
          <target state="translated">これで、&lt;strong&gt;なぜ&lt;/strong&gt;&lt;strong&gt;どのように&lt;/strong&gt;到達できるの&lt;strong&gt;かがわかりました&lt;/strong&gt;。Composition APIの使用を開始するには、最初に実際に使用できる場所が必要です。Vueコンポーネントでは、この場所を &lt;code&gt;setup&lt;/code&gt; と呼びます。</target>
        </trans-unit>
        <trans-unit id="850bba741090a632ab041dbea9329ab10babf270" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; component is a &lt;strong&gt;fully transparent wrapper&lt;/strong&gt;, meaning it can be used exactly like a normal &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; element: all the same attributes and listeners will work, without the &lt;code&gt;.native&lt;/code&gt; modifier.</source>
          <target state="translated">今 &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; コンポーネントがある&lt;strong&gt;完全に透明ラッパー&lt;/strong&gt;、それは正確に通常のように使うことができることを意味、 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 要素：すべての同じ属性とリスナーはせずに、動作します &lt;code&gt;.native&lt;/code&gt; 修飾子。</target>
        </trans-unit>
        <trans-unit id="5577e953820ec1b24aed02306173d947e4a546b7" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;focus&lt;/code&gt; directive will be available in both &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Bar&lt;/code&gt; instances and their descendants.</source>
          <target state="translated">今、 &lt;code&gt;focus&lt;/code&gt; ディレクティブは両方で利用できるようになります &lt;code&gt;Foo&lt;/code&gt; と &lt;code&gt;Bar&lt;/code&gt; のインスタンスとその子孫。</target>
        </trans-unit>
        <trans-unit id="33d4814b929f161b38b9f934ab2aa6a05b1be4d4" translate="yes" xml:space="preserve">
          <source>Now the &lt;em&gt;Posts&lt;/em&gt; tab maintains its state (the selected post) even when it&amp;rsquo;s not rendered. See &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/Lp20op9o/&quot;&gt;this fiddle&lt;/a&gt; for the complete code.</source>
          <target state="translated">これで、[ &lt;em&gt;投稿&lt;/em&gt; ]タブは、レンダリングされていなくてもその状態（選択された投稿）を維持します。完全なコードについては、&lt;a href=&quot;https://jsfiddle.net/chrisvfritz/Lp20op9o/&quot;&gt;このフィドル&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="fa9b9e0ccefb495f319a6491a7e676d9dacfb2b2" translate="yes" xml:space="preserve">
          <source>Now the &lt;em&gt;Posts&lt;/em&gt; tab maintains its state (the selected post) even when it's not rendered.</source>
          <target state="translated">これで、[&lt;em&gt;投稿&lt;/em&gt;]タブは、レンダリングされていない場合でも、その状態（選択された投稿）を維持します。</target>
        </trans-unit>
        <trans-unit id="3a866376561d170695076f998d16ef29475c4851" translate="yes" xml:space="preserve">
          <source>Now those inputs will be rendered from scratch each time you toggle. See for yourself:</source>
          <target state="translated">これで、トグルするたびに入力がスクラッチからレンダリングされるようになりました。自分の目で確かめてみてください。</target>
        </trans-unit>
        <trans-unit id="0c9d8ea18bd7c1be0ebb6900315a3a7aaedea656" translate="yes" xml:space="preserve">
          <source>Now we can compose multiple states with these child components. It's exciting- we can use any combination of transition strategies that have been covered on this page, along with those offered by Vue's &lt;a href=&quot;transitions-enterleave&quot;&gt;built-in transition system&lt;/a&gt;. Together, there are very few limits to what can be accomplished.</source>
          <target state="translated">これで、これらの子コンポーネントを使用して複数の状態を構成できます。エキサイティングです。このページで説明されている移行戦略と、Vueの&lt;a href=&quot;transitions-enterleave&quot;&gt;組み込み移行システム&lt;/a&gt;によって提供される戦略を任意に組み合わせて使用​​できます。一緒に、達成できることにはほとんど制限がありません。</target>
        </trans-unit>
        <trans-unit id="5237d0862d1e32d66a1238befdcec2a1cee4d6bd" translate="yes" xml:space="preserve">
          <source>Now we can pass the todo into each repeated component using &lt;code&gt;v-bind&lt;/code&gt;:</source>
          <target state="translated">これで、 &lt;code&gt;v-bind&lt;/code&gt; を使用して、繰り返される各コンポーネントにtodoを渡すことができます。</target>
        </trans-unit>
        <trans-unit id="8ac2bcabccc1a40d27783fa177eb9745afd5270c" translate="yes" xml:space="preserve">
          <source>Now we get:</source>
          <target state="translated">今、手に入れた。</target>
        </trans-unit>
        <trans-unit id="3ca602ef2620d2d54650ef4ef89bcc645f4b53a2" translate="yes" xml:space="preserve">
          <source>Now we need to react to the changes made to the &lt;code&gt;user&lt;/code&gt; prop. For that we will use the standalone &lt;code&gt;watch&lt;/code&gt; function.</source>
          <target state="translated">次に、 &lt;code&gt;user&lt;/code&gt; プロパティに加えられた変更に対応する必要があります。そのために、スタンドアロンの &lt;code&gt;watch&lt;/code&gt; 機能を使用します。</target>
        </trans-unit>
        <trans-unit id="923823ddc53818b43f37e1756295008b20a5e569" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll answer both what the community can do for you and what you can do for the community.</source>
          <target state="translated">コミュニティがあなたのためにできることと、あなたがコミュニティのためにできることの両方に答えます。</target>
        </trans-unit>
        <trans-unit id="65acc113a97fb20c77fd8e66d6b9e5577e37c2d1" translate="yes" xml:space="preserve">
          <source>Now when using &lt;code&gt;v-model&lt;/code&gt; on this component:</source>
          <target state="translated">このコンポーネントで &lt;code&gt;v-model&lt;/code&gt; を使用する場合：</target>
        </trans-unit>
        <trans-unit id="248dcb3a91e49c1782db9a10e1b75d0c45f374c4" translate="yes" xml:space="preserve">
          <source>Now when we use &lt;code&gt;&amp;lt;submit-button&amp;gt;&lt;/code&gt; in a parent component, providing no content for the slot:</source>
          <target state="translated">次に、親コンポーネントで &lt;code&gt;&amp;lt;submit-button&amp;gt;&lt;/code&gt; を使用すると、スロットにコンテンツが提供されません。</target>
        </trans-unit>
        <trans-unit id="a992bbc0f49c4600f1fce407f7a3883535b20007" translate="yes" xml:space="preserve">
          <source>Now when we use the &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; component, we can optionally define an alternative &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; for todo items, but with access to data from the child:</source>
          <target state="translated">&lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; コンポーネントを使用する場合、オプションで、todoアイテムの代替 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; を定義できますが、子からのデータにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="5c6ac744ac13f4f3529e5b95ada6cc236397759d" translate="yes" xml:space="preserve">
          <source>Now when you run &lt;code&gt;vm.fullName = 'John Doe'&lt;/code&gt;, the setter will be invoked and &lt;code&gt;vm.firstName&lt;/code&gt; and &lt;code&gt;vm.lastName&lt;/code&gt; will be updated accordingly.</source>
          <target state="translated">ここで、 &lt;code&gt;vm.fullName = 'John Doe'&lt;/code&gt; を実行すると、セッターが呼び出され、それに応じて &lt;code&gt;vm.firstName&lt;/code&gt; と &lt;code&gt;vm.lastName&lt;/code&gt; が更新されます。</target>
        </trans-unit>
        <trans-unit id="99a7fc3db6e58b44e0a648173eebd65a414924c6" translate="yes" xml:space="preserve">
          <source>Now whenever &lt;code&gt;sourceOfTruth&lt;/code&gt; is mutated, both &lt;code&gt;appA&lt;/code&gt; and &lt;code&gt;appB&lt;/code&gt; will update their views automatically. We have a single source of truth now, but debugging would be a nightmare. Any piece of data could be changed by any part of our app at any time, without leaving a trace.</source>
          <target state="translated">これで、 &lt;code&gt;sourceOfTruth&lt;/code&gt; が変更されるたびに、 &lt;code&gt;appA&lt;/code&gt; と &lt;code&gt;appB&lt;/code&gt; の両方がビューを自動的に更新します。現在、信頼できる唯一の情報源がありますが、デバッグは悪夢になります。痕跡を残すことなく、いつでもアプリのどの部分でもデータを変更できます。</target>
        </trans-unit>
        <trans-unit id="c95a512db9f39a3a016016301d2d32cc53d1129b" translate="yes" xml:space="preserve">
          <source>Now whenever &lt;code&gt;sourceOfTruth&lt;/code&gt; is mutated, both &lt;code&gt;vmA&lt;/code&gt; and &lt;code&gt;vmB&lt;/code&gt; will update their views automatically. Subcomponents within each of these instances would also have access via &lt;code&gt;this.$root.$data&lt;/code&gt;. We have a single source of truth now, but debugging would be a nightmare. Any piece of data could be changed by any part of our app at any time, without leaving a trace.</source>
          <target state="translated">これで、 &lt;code&gt;sourceOfTruth&lt;/code&gt; が変更されるたびに、 &lt;code&gt;vmA&lt;/code&gt; と &lt;code&gt;vmB&lt;/code&gt; の両方がビューを自動的に更新します。これらの各インスタンス内のサブコンポーネントも &lt;code&gt;this.$root.$data&lt;/code&gt; 介してアクセスできます。現在、単一の真の情報源がありますが、デバッグは悪夢です。データの一部は、トレースを残さずに、アプリのどの部分でもいつでも変更できます。</target>
        </trans-unit>
        <trans-unit id="f0a99cd123681e2aa2af5f62113a3388dd485458" translate="yes" xml:space="preserve">
          <source>Now you can compose it in another component&amp;rsquo;s template:</source>
          <target state="translated">これで、別のコンポーネントのテンプレートで作成できます。</target>
        </trans-unit>
        <trans-unit id="a045cd84f5be21505ce08157ae51e1f45c687302" translate="yes" xml:space="preserve">
          <source>Now you can compose it in another component's template:</source>
          <target state="translated">これで、別のコンポーネントのテンプレートに合成できるようになりました。</target>
        </trans-unit>
        <trans-unit id="1476c1cb56c53ca2f243a141ad4a636da2115a2b" translate="yes" xml:space="preserve">
          <source>Now, if anything changes in either property, the &lt;code&gt;MyMarker&lt;/code&gt; component will automatically be updated as well!</source>
          <target state="translated">これで、いずれかのプロパティに変更があった場合、 &lt;code&gt;MyMarker&lt;/code&gt; コンポーネントも自動的に更新されます。</target>
        </trans-unit>
        <trans-unit id="a93161c9554bdbf350b67c1c62a2064b5a47aa2d" translate="yes" xml:space="preserve">
          <source>Now, in Vue 3, since functional components are defined as pure functions, async components definitions need to be explicitly defined by wrapping it in a new &lt;code&gt;defineAsyncComponent&lt;/code&gt; helper:</source>
          <target state="translated">現在、Vue 3では、機能コンポーネントは純粋関数として定義されているため、非同期コンポーネントの定義は、新しい &lt;code&gt;defineAsyncComponent&lt;/code&gt; ヘルパーでラップして明示的に定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="a3cafea5f9fea2834964a51ae219c94edcf43d7b" translate="yes" xml:space="preserve">
          <source>Now, whenever a new property is added to &lt;code&gt;post&lt;/code&gt; objects, it will automatically be available inside &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">新しいプロパティが &lt;code&gt;post&lt;/code&gt; オブジェクトに追加されると、 &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; 内で自動的に利用できるようになります。</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="1249f1b2253683fc003ea8f094caa69928eaf837" translate="yes" xml:space="preserve">
          <source>Nuxt.js</source>
          <target state="translated">Nuxt.js</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="86580d14a7ddf3bcd41cb5bf79f5c784db2009b3" translate="yes" xml:space="preserve">
          <source>Object Change Detection Caveats</source>
          <target state="translated">オブジェクト変更検出の注意点</target>
        </trans-unit>
        <trans-unit id="bff5a67a67ce40c0fd925410f2eb22f8e622ed24" translate="yes" xml:space="preserve">
          <source>Object Literals</source>
          <target state="translated">オブジェクトリテラル</target>
        </trans-unit>
        <trans-unit id="68654e143c9a95a12dddf5b994152ad350c30fec" translate="yes" xml:space="preserve">
          <source>Object Syntax</source>
          <target state="translated">オブジェクト構文</target>
        </trans-unit>
        <trans-unit id="955b2e0aa5e53a4916bce29cbfdc2fd4cc269476" translate="yes" xml:space="preserve">
          <source>Official Declaration in NPM Packages</source>
          <target state="translated">NPMパッケージでの公式宣言</target>
        </trans-unit>
        <trans-unit id="e0d4eccd8c718c1a4aa53fa3e4adb3463704c6c3" translate="yes" xml:space="preserve">
          <source>Official Flux-Like Implementation</source>
          <target state="translated">フラックスライクな公式実装</target>
        </trans-unit>
        <trans-unit id="253fefc301bfd7132218b7557a6391250b616a46" translate="yes" xml:space="preserve">
          <source>Official Jest Website (opens new window)</source>
          <target state="translated">ジェスト公式サイト(別ウィンドウで開きます</target>
        </trans-unit>
        <trans-unit id="8c7e814049718b1d932cec7462837ebe879f922b" translate="yes" xml:space="preserve">
          <source>Official Mocha Website (opens new window)</source>
          <target state="translated">モカ公式サイト(別ウィンドウで開きます</target>
        </trans-unit>
        <trans-unit id="d41ddeb6775e329516c16fc6584211bbddf25a44" translate="yes" xml:space="preserve">
          <source>Official Router</source>
          <target state="translated">公式ルーター</target>
        </trans-unit>
        <trans-unit id="25d0bd72df27202461d0c5f9c7e08418ec21f91d" translate="yes" xml:space="preserve">
          <source>Official Vue 2 CLI Plugin - Jest (opens new window)</source>
          <target state="translated">Official Vue 2 CLI Plugin-Jest (新しいウィンドウが開きます)</target>
        </trans-unit>
        <trans-unit id="b102013e2e4e3b2a122cd90521f7abb18b815e29" translate="yes" xml:space="preserve">
          <source>Official Vue CLI Cypress Plugin (opens new window)</source>
          <target state="translated">公式Vue CLI Cypressプラグイン(新しいウィンドウが開きます</target>
        </trans-unit>
        <trans-unit id="4283002bfc2991c088ab89cd2443eafba975ab6b" translate="yes" xml:space="preserve">
          <source>Official Vue CLI Nightwatch Plugin (opens new window)</source>
          <target state="translated">Official Vue CLI Nightwatch Plugin (新しいウィンドウが開きます)</target>
        </trans-unit>
        <trans-unit id="7e38d4cb7819fb2b7ca582192edc9ff4825e473e" translate="yes" xml:space="preserve">
          <source>Official Vue CLI Plugin - Mocha (opens new window)</source>
          <target state="translated">公式Vue CLIプラグイン-Mocha (新しいウィンドウが開きます)</target>
        </trans-unit>
        <trans-unit id="0f5bc6dab6176b349e0ef77df3008fa9ea3cb2b1" translate="yes" xml:space="preserve">
          <source>Official Vue Test Utils Documentation (opens new window)</source>
          <target state="translated">Vue Test Utils 公式ドキュメント(新しいウィンドウが開きます</target>
        </trans-unit>
        <trans-unit id="34e4e38b0d8be787a92f6532c519c8963542cb77" translate="yes" xml:space="preserve">
          <source>Official Vue Testing Library Website (opens new window)</source>
          <target state="translated">Vue Testing Library公式サイト(新しいウィンドウが開きます</target>
        </trans-unit>
        <trans-unit id="2fafe60967df029303e74079e269747316a51820" translate="yes" xml:space="preserve">
          <source>Ok, so far, we&amp;rsquo;re just wrapping that object and returning it. Cool, but not that useful yet. But watch this, we can also intercept this object while we wrap it in the Proxy. This interception is called a trap.</source>
          <target state="translated">さて、これまでのところ、そのオブジェクトをラップして返すだけです。かっこいいですが、まだそれほど役に立ちません。ただし、これに注意してください。プロキシでラップしているときに、このオブジェクトをインターセプトすることもできます。この傍受はトラップと呼ばれます。</target>
        </trans-unit>
        <trans-unit id="76f5c4c2f29b26dd8b70d7595e8bde56c7c36488" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;input&lt;/code&gt;, emit an &lt;code&gt;update:modelValue&lt;/code&gt; event with the new value</source>
          <target state="translated">上の &lt;code&gt;input&lt;/code&gt; 、放射 &lt;code&gt;update:modelValue&lt;/code&gt; 新しい値でイベントを</target>
        </trans-unit>
        <trans-unit id="28ad6876beffc882a2da696718cda5f0b89ad0ed" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;input&lt;/code&gt;, emit its own custom &lt;code&gt;input&lt;/code&gt; event with the new value</source>
          <target state="translated">上の &lt;code&gt;input&lt;/code&gt; 、独自のカスタム発する &lt;code&gt;input&lt;/code&gt; 新しい値でイベントを</target>
        </trans-unit>
        <trans-unit id="8353eb035df2b7f6ca17019debdf96a3f22eb88a" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;setup()&lt;/code&gt; function, you don't need to pass a typing to &lt;code&gt;props&lt;/code&gt; parameter as it will infer types from &lt;code&gt;props&lt;/code&gt; component option.</source>
          <target state="translated">上の &lt;code&gt;setup()&lt;/code&gt; 関数で、あなたはに入力を渡す必要はありません &lt;code&gt;props&lt;/code&gt; それから種類を推測しますように、パラメータ &lt;code&gt;props&lt;/code&gt; コンポーネントオプション。</target>
        </trans-unit>
        <trans-unit id="cf41ca9bc7d54b6c5ac4b857c3027240934a3189" translate="yes" xml:space="preserve">
          <source>On Macintosh keyboards, meta is the command key (⌘). On Windows keyboards, meta is the Windows key (⊞). On Sun Microsystems keyboards, meta is marked as a solid diamond (◆). On certain keyboards, specifically MIT and Lisp machine keyboards and successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled &amp;ldquo;META&amp;rdquo;. On Symbolics keyboards, meta is labeled &amp;ldquo;META&amp;rdquo; or &amp;ldquo;Meta&amp;rdquo;.</source>
          <target state="translated">Macintoshキーボードでは、metaはコマンドキー（⌘）です。Windowsキーボードでは、メタはWindowsキーです（⊞）。Sun Microsystemsのキーボードでは、メタは塗りつぶされたひし形（◆）としてマークされています。特定のキーボード、特にMITおよびLispマシンのキーボードと、ナイトキーボード、スペースカデットキーボードなどの後継機では、メタは「META」とラベル付けされています。Symbolicsキーボードでは、メタには「META」または「Meta」というラベルが付いています。</target>
        </trans-unit>
        <trans-unit id="8d04e03632e4eea5ab7fbb011f47571b7d133e29" translate="yes" xml:space="preserve">
          <source>On a higher level, we can divide components into two categories: presentational ones and logical ones. We recommend using templates for presentational components and render function / JSX for logical ones. The percentage of these components depends on the type of app you are building, but in general we find presentational ones to be much more common.</source>
          <target state="translated">より高いレベルでは、コンポーネントを2つのカテゴリに分けることができます:現在のものと論理的なものです。提示的なコンポーネントにはテンプレートを使用し、論理的なコンポーネントにはレンダリング関数/JSXを使用することをお勧めします。これらのコンポーネントの割合は、構築しているアプリの種類によって異なりますが、一般的には、提示型のコンポーネントの方がはるかに一般的です。</target>
        </trans-unit>
        <trans-unit id="6c3d3824299b5122ad70d07d38a8fd8a0336c35b" translate="yes" xml:space="preserve">
          <source>On conditional branches</source>
          <target state="translated">条件分岐について</target>
        </trans-unit>
        <trans-unit id="ecfd81e3f5a0816680f9b8987dee9ab76e3a2d2b" translate="yes" xml:space="preserve">
          <source>On normal components, attributes not defined as props are automatically added to the root element of the component, replacing or &lt;a href=&quot;class-and-style&quot;&gt;intelligently merging with&lt;/a&gt; any existing attributes of the same name.</source>
          <target state="translated">通常のコンポーネントでは、propsとして定義されていない属性はコンポーネントのルート要素に自動的に追加され、同じ名前の既存の属性に置き換えられるか、&lt;a href=&quot;class-and-style&quot;&gt;インテリジェントにマージされ&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="115970ef5ff2b56182595889250a6ca56011969e" translate="yes" xml:space="preserve">
          <source>On root Vue instances (i.e. instances created with &lt;code&gt;new Vue({ ... })&lt;/code&gt;), you must use &lt;code&gt;propsData&lt;/code&gt; instead of &lt;code&gt;props&lt;/code&gt;.</source>
          <target state="translated">ルートVueインスタンス（つまり、 &lt;code&gt;new Vue({ ... })&lt;/code&gt; 作成されたインスタンス）では、 &lt;code&gt;props&lt;/code&gt; ではなく &lt;code&gt;propsData&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="6cc2844f3ba73496715d5d711c0cabc37d43bc1d" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;code&gt;$refs&lt;/code&gt; are designed primarily for programmatic access in JavaScript - it is not recommended to rely on them in templates, because that would mean referring to state that does not belong to the instance itself. This would violate Vue&amp;rsquo;s data-driven view model.</source>
          <target state="translated">一方、 &lt;code&gt;$refs&lt;/code&gt; は主にJavaScriptでのプログラムによるアクセス用に設計されています。テンプレートでそれらに依存することはお勧めできません。インスタンス自体に属さない状態を参照することになるためです。これは、Vueのデータ駆動型ビューモデルに違反します。</target>
        </trans-unit>
        <trans-unit id="b540e34dd34eb0880938f77efa7424968025eadc" translate="yes" xml:space="preserve">
          <source>On the other hand, the runtime-only build is fully CSP-compliant. When using the runtime-only build with &lt;a href=&quot;https://github.com/vuejs-templates/webpack-simple&quot;&gt;Webpack + vue-loader&lt;/a&gt; or &lt;a href=&quot;https://github.com/vuejs-templates/browserify-simple&quot;&gt;Browserify + vueify&lt;/a&gt;, your templates will be precompiled into &lt;code&gt;render&lt;/code&gt; functions which work perfectly in CSP environments.</source>
          <target state="translated">一方、ランタイムのみのビルドはCSPに完全に準拠しています。&lt;a href=&quot;https://github.com/vuejs-templates/webpack-simple&quot;&gt;Webpack + vue-loader&lt;/a&gt;または&lt;a href=&quot;https://github.com/vuejs-templates/browserify-simple&quot;&gt;Browserify + vueify&lt;/a&gt;でランタイムのみのビルドを使用すると、テンプレートは、CSP環境で完全に機能 &lt;code&gt;render&lt;/code&gt; 関数にプリコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="8d767e2d19bb7e35a75d58e381e3d41454c0c3f2" translate="yes" xml:space="preserve">
          <source>On this page, we&amp;rsquo;ll only cover entering, leaving, and list transitions, but you can see the next section for &lt;a href=&quot;transitioning-state&quot;&gt;managing state transitions&lt;/a&gt;.</source>
          <target state="translated">このページでは、遷移の開始、終了、リストのみを扱いますが、&lt;a href=&quot;transitioning-state&quot;&gt;状態遷移の管理&lt;/a&gt;に関する次のセクションをご覧ください。</target>
        </trans-unit>
        <trans-unit id="e4cdb09dd5b26c91e66320cefa8ce757b9de6879" translate="yes" xml:space="preserve">
          <source>On this page, we'll only cover entering, and leaving, but you can see the next sections for &lt;a href=&quot;transitions-list&quot;&gt;list transitions&lt;/a&gt; and &lt;a href=&quot;transitions-state&quot;&gt;managing state transitions&lt;/a&gt;.</source>
          <target state="translated">このページでは、入場と退場についてのみ説明しますが、&lt;a href=&quot;transitions-list&quot;&gt;リスト遷移&lt;/a&gt;と&lt;a href=&quot;transitions-state&quot;&gt;状態遷移の管理&lt;/a&gt;については次のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="37eb05f4d4e96c1234bdb668f4b2f5b554eed08a" translate="yes" xml:space="preserve">
          <source>Once a prop is registered, you can pass data to it as a custom attribute, like this:</source>
          <target state="translated">プロップが登録されると、以下のようにカスタム属性としてデータを渡すことができます。</target>
        </trans-unit>
        <trans-unit id="d2e7a62de13ea6daf472e90fd22d2267995fceed" translate="yes" xml:space="preserve">
          <source>Once a user changes route, bring focus back to the skip link. This can be achieved by calling focus to the &lt;code&gt;ref&lt;/code&gt; provided below:</source>
          <target state="translated">ユーザーがルートを変更したら、フォーカスをスキップリンクに戻します。これは、以下に提供されている &lt;code&gt;ref&lt;/code&gt; フォーカスを呼び出すことで実現できます。</target>
        </trans-unit>
        <trans-unit id="66af394c02eb313b263b2c4b24ed3c50b4c07c98" translate="yes" xml:space="preserve">
          <source>Once again, try not to overuse this pattern. While convenient in those rare cases when you have to render a lot of static content, it&amp;rsquo;s simply not necessary unless you actually notice slow rendering &amp;ndash; plus, it could cause a lot of confusion later. For example, imagine another developer who&amp;rsquo;s not familiar with &lt;code&gt;v-once&lt;/code&gt; or simply misses it in the template. They might spend hours trying to figure out why the template isn&amp;rsquo;t updating correctly.</source>
          <target state="translated">もう一度、このパターンを使いすぎないようにしてください。多くの静的コンテンツをレンダリングする必要があるというまれなケースでは便利ですが、遅いレンダリングに実際に気づかない限り、それは必要ありません。さらに、後で多くの混乱を引き起こす可能性があります。たとえば、 &lt;code&gt;v-once&lt;/code&gt; に慣れていない、または単にテンプレートでそれを見逃している別の開発者を想像してみてください。テンプレートが正しく更新されない理由を解明するために何時間も費やす可能性があります。</target>
        </trans-unit>
        <trans-unit id="e74c60c8736c1be5dff55d13ab945f687b554058" translate="yes" xml:space="preserve">
          <source>Once again, try not to overuse this pattern. While convenient in those rare cases when you have to render a lot of static content, it's simply not necessary unless you actually notice slow rendering - plus, it could cause a lot of confusion later. For example, imagine another developer who's not familiar with &lt;code&gt;v-once&lt;/code&gt; or simply misses it in the template. They might spend hours trying to figure out why the template isn't updating correctly.</source>
          <target state="translated">もう一度、このパターンを使いすぎないようにしてください。大量の静的コンテンツをレンダリングする必要があるまれなケースでは便利ですが、実際にレンダリングが遅いことに気付かない限り、それは単に必要ではありません。さらに、後で多くの混乱を引き起こす可能性があります。たとえば、 &lt;code&gt;v-once&lt;/code&gt; に慣れていない、または単にテンプレートでそれを見逃している別の開発者を想像してみてください。テンプレートが正しく更新されない理由を理解するために何時間も費やす可能性があります。</target>
        </trans-unit>
        <trans-unit id="167f3f5ddd7e9428d499efaab9f381bdb3ed2c55" translate="yes" xml:space="preserve">
          <source>Once from &lt;code&gt;$emit()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$emit()&lt;/code&gt; から一度。</target>
        </trans-unit>
        <trans-unit id="5c922783f828b42530826b639b30161731661fae" translate="yes" xml:space="preserve">
          <source>Once from a native event listener applied to the root element.</source>
          <target state="translated">ルート要素に適用されたネイティブイベントリスナーから1回。</target>
        </trans-unit>
        <trans-unit id="60427c06e75efde50ce039ae0b452cc000ae7ef8" translate="yes" xml:space="preserve">
          <source>Once observed, you can no longer add reactive properties to the root data object. It is therefore recommended to declare all root-level reactive properties upfront, before creating the instance.</source>
          <target state="translated">一度観測されると、ルート データ オブジェクトにリアクティブ プロパティを追加することはできなくなります。そのため、インスタンスを作成する前に、すべてのルートレベルの反応性プロパティを前もって宣言しておくことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="e8b9b74226ba51585f69fe08ce0443127353058d" translate="yes" xml:space="preserve">
          <source>Once the file is created we will need to open it with our editor of choice and add the following code.</source>
          <target state="translated">ファイルを作成したら、お好みのエディタで開き、次のコードを追加します。</target>
        </trans-unit>
        <trans-unit id="decb1a1fde9ee9b3e759b559bcf2ede344d13377" translate="yes" xml:space="preserve">
          <source>Once you feel comfortable with the knowledge you&amp;rsquo;ve just digested, we recommend coming back to read the full guide on &lt;a href=&quot;components-dynamic-async&quot;&gt;Dynamic &amp;amp; Async Components&lt;/a&gt;, as well as the other pages in the Components In-Depth section of the sidebar.</source>
          <target state="translated">ダイジェストした知識に納得できたら、サイドバーの[Components In-Depth]セクションの他のページだけでなく、&lt;a href=&quot;components-dynamic-async&quot;&gt;動的および非同期コンポーネント&lt;/a&gt;に関する完全なガイドを読むことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="60acc179819cc9885eb67653fbd8f4d03d08954a" translate="yes" xml:space="preserve">
          <source>Once you feel comfortable with the knowledge you've just digested, we recommend coming back to read the full guide on &lt;a href=&quot;component-dynamic-async&quot;&gt;Dynamic &amp;amp; Async Components&lt;/a&gt;, as well as the other pages in the Components In-Depth section of the sidebar.</source>
          <target state="translated">消化したばかりの知識に慣れたら、戻って&lt;a href=&quot;component-dynamic-async&quot;&gt;動的および非同期コンポーネント&lt;/a&gt;に関する完全なガイドと、サイドバーの「コンポーネントの詳細」セクションの他のページを読むことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f50329c826448bbda1ee5ce8c2c416fac8c003a3" translate="yes" xml:space="preserve">
          <source>One important note is that these FLIP transitions do not work with elements set to &lt;code&gt;display: inline&lt;/code&gt;. As an alternative, you can use &lt;code&gt;display: inline-block&lt;/code&gt; or place elements in a flex context.</source>
          <target state="translated">重要な注意点の1つは、これらのFLIP遷移は、 &lt;code&gt;display: inline&lt;/code&gt; するように設定された要素（インライン）では機能しないことです。別の方法として、 &lt;code&gt;display: inline-block&lt;/code&gt; 使用するか、要素をflexコンテキストに配置できます。</target>
        </trans-unit>
        <trans-unit id="15a19c04bf3761da4954cadebd24295dde2b8675" translate="yes" xml:space="preserve">
          <source>One important thing to note is that &lt;strong&gt;separation of concerns is not equal to separation of file types.&lt;/strong&gt; In modern UI development, we have found that instead of dividing the codebase into three huge layers that interweave with one another, it makes much more sense to divide them into loosely-coupled components and compose them. Inside a component, its template, logic and styles are inherently coupled, and collocating them actually makes the component more cohesive and maintainable.</source>
          <target state="translated">注意すべき重要な点の1つは&lt;strong&gt;、関心事の分離はファイルタイプの分離と同じではないということです。&lt;/strong&gt;最近のUI開発では、コードベースを相互に織り交ぜる3つの巨大なレイヤーに分割する代わりに、それらを疎結合コンポーネントに分割して構成する方がはるかに理にかなっていることがわかりました。コンポーネントの内部では、そのテンプレート、ロジック、およびスタイルが本質的に結合されており、それらを配置することで、コンポーネントはよりまとまりやすく、保守しやすくなります。</target>
        </trans-unit>
        <trans-unit id="b2c093743cd92f3eef8061e180eeec927b862729" translate="yes" xml:space="preserve">
          <source>One of the issues with placeholders is that they don't meet the &lt;a href=&quot;https://www.w3.org/WAI/WCAG21/Understanding/contrast-minimum.html&quot;&gt;color contrast criteria (opens new window)&lt;/a&gt; by default; fixing the color contrast makes the placeholder look like pre-populated data in the input fields. Looking at the following example, you can see that the Last Name placeholder which meets the color contrast criteria looks like pre-populated data:</source>
          <target state="translated">プレースホルダーの問題の1つは、デフォルトで&lt;a href=&quot;https://www.w3.org/WAI/WCAG21/Understanding/contrast-minimum.html&quot;&gt;色のコントラストの基準を&lt;/a&gt;満たしていない（新しいウィンドウが開く）ことです。色のコントラストを修正すると、プレースホルダーは入力フィールドに事前入力されたデータのように見えます。次の例を見ると、色のコントラストの基準を満たすLastNameプレースホルダーが事前入力されたデータのように見えることがわかります。</target>
        </trans-unit>
        <trans-unit id="ba41464fb51dc3d17291a7984b07e3ead107d6cd" translate="yes" xml:space="preserve">
          <source>One of the most common transition types uses CSS transitions. Here&amp;rsquo;s an example:</source>
          <target state="translated">最も一般的な遷移タイプの1つはCSS遷移を使用します。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="f3084514831f9a3660901b496859b78c114ded95" translate="yes" xml:space="preserve">
          <source>One of the most common transition types uses CSS transitions. Here's an example:</source>
          <target state="translated">最も一般的な遷移タイプの1つは、CSSの遷移を使用しています。ここに例を示します。</target>
        </trans-unit>
        <trans-unit id="7b71ee323d52ac501596f9b35d6767689ddb4ebc" translate="yes" xml:space="preserve">
          <source>One of the most common uses for these methods is to communicate between a parent and its direct children. In these cases, you can actually &lt;a href=&quot;components#Form-Input-Components-using-Custom-Events&quot;&gt;listen to an &lt;code&gt;$emit&lt;/code&gt; from a child with &lt;code&gt;v-on&lt;/code&gt;&lt;/a&gt;. This allows you to keep the convenience of events with added explicitness.</source>
          <target state="translated">これらのメソッドの最も一般的な用途の1つは、親とその直接の子の間の通信です。これらの場合、実際に&lt;a href=&quot;components#Form-Input-Components-using-Custom-Events&quot;&gt;は&lt;/a&gt; &lt;code&gt;v-on&lt;/code&gt; の子からの &lt;code&gt;$emit&lt;/code&gt; 聞くことができます。これにより、明示性を追加してイベントの利便性を維持できます。</target>
        </trans-unit>
        <trans-unit id="f582da9a59b59f7794fc88389aa5092b1a4c440b" translate="yes" xml:space="preserve">
          <source>One of the most important pieces of accessibility is making sure that design can support accessible implementation. Design should consider not only color contrast, font selection, text sizing, and language, but also how the content is structured in the application.</source>
          <target state="translated">アクセシビリティの最も重要な部分の1つは、デザインがアクセシブルな実装をサポートできることを確認することです。デザインは、色のコントラスト、フォントの選択、テキストのサイズ、言語だけでなく、アプリケーション内でコンテンツがどのように構成されているかを考慮する必要があります。</target>
        </trans-unit>
        <trans-unit id="c5441c2b16e737c07dfa65dd03fc760dc9068959" translate="yes" xml:space="preserve">
          <source>One of the primary benefits that end-to-end (E2E) testing is known for is its ability to test your application across multiple browsers. While it may seem desirable to have 100% cross-browser coverage, it is important to note that cross browser testing has diminishing returns on a team's resources due the additional time and machine power required to run them consistently. As a result, it is important to be mindful of this trade-off when choosing the amount of cross-browser testing your application needs.</source>
          <target state="translated">エンドツーエンド(E2E)テストが知られている主な利点の一つは、複数のブラウザにまたがってアプリケーションをテストできることです。100%クロスブラウザをカバーすることが望ましいと思われるかもしれませんが、クロスブラウザテストを一貫して実行するために必要な追加の時間とマシンパワーのために、チームのリソースに対するリターンが減少することに注意することが重要です。結果として、アプリケーションが必要とするクロスブラウザテストの量を選択する際には、このトレードオフを念頭に置くことが重要です。</target>
        </trans-unit>
        <trans-unit id="6ba1aa62162a2a83d170cfdbdcd416abaeb0b419" translate="yes" xml:space="preserve">
          <source>One of the primary problems with end-to-end (E2E) tests and development is that running the entire suite takes a long time. Typically, this is only done in continuous integration and deployment (CI/CD) pipelines. Modern E2E testing frameworks have helped to solve this by adding features like parallelization, which allows for CI/CD pipelines to often run magnitudes faster than before. In addition, when developing locally, the ability to selectively run a single test for the page you are working on while also providing hot reloading of tests can help to boost a developer's workflow and productivity.</source>
          <target state="translated">エンドツーエンド (E2E)テストと開発の主な問題の 1 つは、スイート全体の実行に長い時間がかかることです。一般的に、これは継続的インテグレーションとデプロイメント(CI/CD)パイプラインでのみ行われます。最新の E2E テストフレームワークは、並列化のような機能を追加することで、CI/CD パイプラインを以前よりも大幅に高速に実行できるようにすることで、この問題を解決しています。さらに、ローカルで開発する場合、テストのホットリロードを提供しながら、作業中のページの単一テストを選択的に実行する機能は、開発者のワークフローと生産性を向上させるのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="70774a581a1c775647bf86a829f4e0651d0e222a" translate="yes" xml:space="preserve">
          <source>One or More Named Parameters &lt;sup&gt;changed&lt;/sup&gt;</source>
          <target state="translated">1つ以上の名前付きパラメーターが&lt;sup&gt;変更されました&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="4e3d2bc9560217cd384652200da10fbf0bdb8e0b" translate="yes" xml:space="preserve">
          <source>One thing to note: similar to how &lt;code&gt;v-bind:class&lt;/code&gt; and &lt;code&gt;v-bind:style&lt;/code&gt; have special treatment in templates, they have their own top-level fields in VNode data objects. This object also allows you to bind normal HTML attributes as well as DOM properties such as &lt;code&gt;innerHTML&lt;/code&gt; (this would replace the &lt;code&gt;v-html&lt;/code&gt; directive):</source>
          <target state="translated">注意すべき点の1つ：テンプレートで &lt;code&gt;v-bind:class&lt;/code&gt; および &lt;code&gt;v-bind:style&lt;/code&gt; が特別に扱われるのと同様に、VNodeデータオブジェクトに独自のトップレベルフィールドがあります。このオブジェクトを使用すると、通常のHTML属性や &lt;code&gt;innerHTML&lt;/code&gt; などのDOMプロパティをバインドすることもできます（これにより、 &lt;code&gt;v-html&lt;/code&gt; ディレクティブが置き換えられます）。</target>
        </trans-unit>
        <trans-unit id="0d00cba8d56cb34c07366778b058997e1e6be989" translate="yes" xml:space="preserve">
          <source>One time bindings (&lt;code&gt;{{* foo }}&lt;/code&gt;) have been replaced by the new &lt;a href=&quot;../api/index#v-once&quot;&gt;&lt;code&gt;v-once&lt;/code&gt; directive&lt;/a&gt;.</source>
          <target state="translated">ワンタイムバインディング（ &lt;code&gt;{{* foo }}&lt;/code&gt; ）は、新しい&lt;a href=&quot;../api/index#v-once&quot;&gt; &lt;code&gt;v-once&lt;/code&gt; ディレクティブに&lt;/a&gt;置き換えられました。</target>
        </trans-unit>
        <trans-unit id="b15ca056f8f4ec061aff57aa3f191e7c02753b7c" translate="yes" xml:space="preserve">
          <source>One way to share configurations e.g. components or directives among apps is to create a factory function, like this:</source>
          <target state="translated">コンポーネントやディレクティブなどの設定をアプリ間で共有する方法として、以下のようなファクトリ関数を作成する方法があります。</target>
        </trans-unit>
        <trans-unit id="b6a0ca5f17117a2d79de1ddff5f7c2037c280f5f" translate="yes" xml:space="preserve">
          <source>One-Time Bindings &lt;sup&gt;replaced&lt;/sup&gt;</source>
          <target state="translated">ワンタイムバインディングが&lt;sup&gt;置き換えられました&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="6a82bece6c6f4d9547ea740b83ea3c0446063eb1" translate="yes" xml:space="preserve">
          <source>One-Way Data Flow</source>
          <target state="translated">一方向データフロー</target>
        </trans-unit>
        <trans-unit id="545c63628a39318763f613482d1fbb98218b985f" translate="yes" xml:space="preserve">
          <source>Only UMD builds are available from Bower.</source>
          <target state="translated">BowerからはUMDビルドのみの提供となります。</target>
        </trans-unit>
        <trans-unit id="afb58a0b3374e0000a3d5235d1868b2071496402" translate="yes" xml:space="preserve">
          <source>Only Vue Router 2 is compatible with Vue 2, so if you&amp;rsquo;re updating Vue, you&amp;rsquo;ll have to update Vue Router as well. That&amp;rsquo;s why we&amp;rsquo;ve included details on the migration path here in the main docs. For a complete guide on using the new Vue Router, see the &lt;a href=&quot;https://router.vuejs.org/en/&quot;&gt;Vue Router docs&lt;/a&gt;.</source>
          <target state="translated">Vue Router 2のみがVue 2と互換性があるため、Vueを更新する場合は、Vue Routerも更新する必要があります。そのため、メインのドキュメントに移行パスの詳細を含めました。新しいVueルーターの使用に関する完全なガイドについては、&lt;a href=&quot;https://router.vuejs.org/en/&quot;&gt;Vueルーターのドキュメントを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="83950822db2f31bcab4a982049e8a2377ef9aa81" translate="yes" xml:space="preserve">
          <source>Only Vue Router 2 is compatible with Vue 2, so yes, you&amp;rsquo;ll have to follow the &lt;a href=&quot;migration-vue-router&quot;&gt;migration path for Vue Router&lt;/a&gt; as well. Fortunately, most applications don&amp;rsquo;t have a lot of router code, so this likely won&amp;rsquo;t take more than an hour.</source>
          <target state="translated">Vue Router 2のみがVue 2と互換性があるので、はい、&lt;a href=&quot;migration-vue-router&quot;&gt;Vue Routerの移行パスも&lt;/a&gt;たどる必要があります。幸いなことに、ほとんどのアプリケーションにはルーターコードが多くないので、これにはおそらく1時間もかかりません。</target>
        </trans-unit>
        <trans-unit id="2cbd6f69ac9f00bc6cc9a5cada50b773f8b9b204" translate="yes" xml:space="preserve">
          <source>Only in 2.2.0+: Also works with Array + index.</source>
          <target state="translated">2.2.0+のみ:Array+indexでも動作するようになりました。</target>
        </trans-unit>
        <trans-unit id="1c17fd71b6108eae91a98b2783d1ada7a72eca67" translate="yes" xml:space="preserve">
          <source>Opacity behaves similarly. Thus, they are ideal candidates for movement on the web.</source>
          <target state="translated">不透明度も同様に動作します。したがって、それらはウェブ上での動きの理想的な候補となります。</target>
        </trans-unit>
        <trans-unit id="1c41eb847c8622b8581eed87c208351ff18e6769" translate="yes" xml:space="preserve">
          <source>Operable (opens new window)</source>
          <target state="translated">操作可能(新しいウィンドウが開きます</target>
        </trans-unit>
        <trans-unit id="caec8acecc60ba151e62b5850f83574dfd99c0d7" translate="yes" xml:space="preserve">
          <source>Optimal compatibility with the Vue ecosystem</source>
          <target state="translated">Vue エコシステムとの最適な互換性</target>
        </trans-unit>
        <trans-unit id="95478f28e516ba5806445048a3c04633ee9620d8" translate="yes" xml:space="preserve">
          <source>Optimization Efforts</source>
          <target state="translated">最適化の取り組み</target>
        </trans-unit>
        <trans-unit id="e4b9f85b5d7b01dca8287331249e33d3c5156887" translate="yes" xml:space="preserve">
          <source>Option #1: Use &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag</source>
          <target state="translated">オプション＃1： &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; タグを使用する</target>
        </trans-unit>
        <trans-unit id="6301bb50d7829f5c1bc253cc74ede56ad6a957e0" translate="yes" xml:space="preserve">
          <source>Option #2: Default Slot</source>
          <target state="translated">オプション2:デフォルトスロット</target>
        </trans-unit>
        <trans-unit id="780c075090673488095ee8c24e310c188ceb0e25" translate="yes" xml:space="preserve">
          <source>Option Merging</source>
          <target state="translated">マージオプション</target>
        </trans-unit>
        <trans-unit id="f674131a41d74d291985eeac34569e45a2796480" translate="yes" xml:space="preserve">
          <source>Optional configuration options</source>
          <target state="translated">オプションの設定オプション</target>
        </trans-unit>
        <trans-unit id="34b239efa2fca3d9404779824c96746803cb0ac3" translate="yes" xml:space="preserve">
          <source>Options / Assets</source>
          <target state="translated">オプション/資産</target>
        </trans-unit>
        <trans-unit id="a8322b7d3e6ea2843e0f110827e9f381192e83db" translate="yes" xml:space="preserve">
          <source>Options / Composition</source>
          <target state="translated">オプション・構成</target>
        </trans-unit>
        <trans-unit id="23f8ac645a29b2a587df1e001744b1d9555b758c" translate="yes" xml:space="preserve">
          <source>Options / DOM</source>
          <target state="translated">オプション/DOM</target>
        </trans-unit>
        <trans-unit id="7e61ca3b6c7817347db226ad3551cc64c2d446f7" translate="yes" xml:space="preserve">
          <source>Options / Data</source>
          <target state="translated">オプション/データ</target>
        </trans-unit>
        <trans-unit id="83461f255e0b700d1fc468a6266119fa610f9019" translate="yes" xml:space="preserve">
          <source>Options / Lifecycle Hooks</source>
          <target state="translated">オプション/ライフサイクルフック</target>
        </trans-unit>
        <trans-unit id="7d2f97ccdee65e286d78a496a5ee8cd549c930ee" translate="yes" xml:space="preserve">
          <source>Options / Misc</source>
          <target state="translated">オプション/その他</target>
        </trans-unit>
        <trans-unit id="b30e44ad585ea6e546f21a0445864b10944795c8" translate="yes" xml:space="preserve">
          <source>Options / Misc - inheritAttrs</source>
          <target state="translated">オプション/その他-inheritAttrs</target>
        </trans-unit>
        <trans-unit id="474ba12c459599d7f3d05d19597c94aa345c6ae6" translate="yes" xml:space="preserve">
          <source>Options API</source>
          <target state="translated">オプションAPI</target>
        </trans-unit>
        <trans-unit id="c65a7777ad439fc6385d6da8d4c12a4f89868164" translate="yes" xml:space="preserve">
          <source>Options such as &lt;code&gt;acceptStatement&lt;/code&gt;, &lt;code&gt;deep&lt;/code&gt;, &lt;code&gt;priority&lt;/code&gt;, etc have all been removed. To replace &lt;code&gt;twoWay&lt;/code&gt; directives, see &lt;a href=&quot;#Two-Way-Filters-replaced&quot;&gt;this example&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;acceptStatement&lt;/code&gt; 、 &lt;code&gt;deep&lt;/code&gt; 、 &lt;code&gt;priority&lt;/code&gt; などのオプションはすべて削除されました。 &lt;code&gt;twoWay&lt;/code&gt; ディレクティブを置き換えるには、&lt;a href=&quot;#Two-Way-Filters-replaced&quot;&gt;この例を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="268262a68726a842a9214f48a664175ac456e7a4" translate="yes" xml:space="preserve">
          <source>Options that expect object values, for example &lt;code&gt;methods&lt;/code&gt;, &lt;code&gt;components&lt;/code&gt; and &lt;code&gt;directives&lt;/code&gt;, will be merged into the same object. The component&amp;rsquo;s options will take priority when there are conflicting keys in these objects:</source>
          <target state="translated">&lt;code&gt;methods&lt;/code&gt; 、 &lt;code&gt;components&lt;/code&gt; 、 &lt;code&gt;directives&lt;/code&gt; などのオブジェクト値を必要とするオプションは、同じオブジェクトにマージされます。これらのオブジェクトに競合するキーがある場合、コンポーネントのオプションが優先されます。</target>
        </trans-unit>
        <trans-unit id="2cf7aafc0cf21a0635200b597f31b1c9a97361eb" translate="yes" xml:space="preserve">
          <source>Options that expect object values, for example &lt;code&gt;methods&lt;/code&gt;, &lt;code&gt;components&lt;/code&gt; and &lt;code&gt;directives&lt;/code&gt;, will be merged into the same object. The component's options will take priority when there are conflicting keys in these objects:</source>
          <target state="translated">&lt;code&gt;methods&lt;/code&gt; 、 &lt;code&gt;components&lt;/code&gt; 、 &lt;code&gt;directives&lt;/code&gt; など、オブジェクト値を期待するオプションは、同じオブジェクトにマージされます。これらのオブジェクトに競合するキーがある場合、コンポーネントのオプションが優先されます。</target>
        </trans-unit>
        <trans-unit id="9cccb1cf88b26495b712b582b1851dcc7cb203e2" translate="yes" xml:space="preserve">
          <source>Or a &lt;code&gt;setup&lt;/code&gt; function, function name will be used as component name</source>
          <target state="translated">または &lt;code&gt;setup&lt;/code&gt; 機能、機能名はコンポーネント名として使用されます</target>
        </trans-unit>
        <trans-unit id="6e8a33817f19f064f5e6cf9b1efc94083145cda9" translate="yes" xml:space="preserve">
          <source>Or a data/computed property:</source>
          <target state="translated">またはデータ/計算されたプロパティ。</target>
        </trans-unit>
        <trans-unit id="60f24c4199344a7f41d53a7637411a2eabdf966c" translate="yes" xml:space="preserve">
          <source>Or a render function:</source>
          <target state="translated">あるいはレンダー関数。</target>
        </trans-unit>
        <trans-unit id="023f1403c5535c7569fdca6e12645578c310b4c5" translate="yes" xml:space="preserve">
          <source>Or alternatively, you could use Webpack&amp;rsquo;s asynchronous &lt;code&gt;import&lt;/code&gt; when you register the component locally:</source>
          <target state="translated">または、コンポーネントをローカルに登録するときに、Webpackの非同期 &lt;code&gt;import&lt;/code&gt; 使用することもできます。</target>
        </trans-unit>
        <trans-unit id="45c03a2813f8f4d2212c4aad0f6ca1365bfc8c76" translate="yes" xml:space="preserve">
          <source>Or better yet, pass removal methods an index:</source>
          <target state="translated">または、より良いのは、削除方法をインデックスに渡すことです。</target>
        </trans-unit>
        <trans-unit id="7655b19551e9be2b132e49ba50a30e1355a9890c" translate="yes" xml:space="preserve">
          <source>Or even other components:</source>
          <target state="translated">あるいは他の部品でも。</target>
        </trans-unit>
        <trans-unit id="03b6295d62d0a9f390c82c14d8335ae12a8dffb8" translate="yes" xml:space="preserve">
          <source>Or if &lt;code&gt;myElement&lt;/code&gt; is the last child:</source>
          <target state="translated">または、 &lt;code&gt;myElement&lt;/code&gt; が最後の子である場合：</target>
        </trans-unit>
        <trans-unit id="a001bd7723a1c2e569009fd7dcd66c9ec91d9d8c" translate="yes" xml:space="preserve">
          <source>Or if you&amp;rsquo;re using ES2015 modules, such as through Babel and Webpack, that might look more like:</source>
          <target state="translated">または、BabelやWebpackなどを介してES2015モジュールを使用している場合は、次のようになります。</target>
        </trans-unit>
        <trans-unit id="b481ed2ba5dbbc7e0f7386d267111e8bdfabf1ae" translate="yes" xml:space="preserve">
          <source>Or if you're using ES2015 modules, such as through Babel and Webpack, that might look more like:</source>
          <target state="translated">あるいは、BabelやWebpackを介してES2015のモジュールを使用している場合は、そちらの方が似ているかもしれません。</target>
        </trans-unit>
        <trans-unit id="bc8ab6aa568615f78c04477ef62787486065b5dc" translate="yes" xml:space="preserve">
          <source>Or in a render function:</source>
          <target state="translated">またはレンダリング関数の中で。</target>
        </trans-unit>
        <trans-unit id="4959514a6e663f87294927771d85f57df1ba3c86" translate="yes" xml:space="preserve">
          <source>Or with Yarn:</source>
          <target state="translated">または毛糸と一緒に。</target>
        </trans-unit>
        <trans-unit id="24f03f9044ac60a104f95613db5b63ecc9c3a137" translate="yes" xml:space="preserve">
          <source>Or with a render function:</source>
          <target state="translated">あるいはレンダー機能を使って</target>
        </trans-unit>
        <trans-unit id="7f55d71b1414a39798d6cca5dd9a4e4bcb171abc" translate="yes" xml:space="preserve">
          <source>Or with component methods:</source>
          <target state="translated">またはコンポーネントメソッドで。</target>
        </trans-unit>
        <trans-unit id="af14db0c16953bef3557a6e30a1aace5e18d1edd" translate="yes" xml:space="preserve">
          <source>Or, for the more advanced component syntax with options:</source>
          <target state="translated">または、オプションを使用したより高度なコンポーネント構文にも対応しています。</target>
        </trans-unit>
        <trans-unit id="4e16431e1f0d282812696aa421107f6f8ecec16e" translate="yes" xml:space="preserve">
          <source>Or, for those who preferred the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; in a single-file component:</source>
          <target state="translated">または、単一ファイルコンポーネントで &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; を好む人のために：</target>
        </trans-unit>
        <trans-unit id="014d7bb6d9a77fedd188db250f7b0d093aca38d2" translate="yes" xml:space="preserve">
          <source>Or, if the event handler is a method:</source>
          <target state="translated">または、イベントハンドラがメソッドの場合。</target>
        </trans-unit>
        <trans-unit id="283f8ac5294276aa36ea18c510c09f047be7a9ce" translate="yes" xml:space="preserve">
          <source>Or, if you&amp;rsquo;re using the runtime-only build of Vue:</source>
          <target state="translated">または、Vueのランタイムのみのビルドを使用している場合：</target>
        </trans-unit>
        <trans-unit id="1ce87eef2b959ce134a14284177345e12a8eb332" translate="yes" xml:space="preserve">
          <source>Or, if you&amp;rsquo;ve been unit-testing an application involving &lt;a href=&quot;../component-dynamic-async&quot;&gt;async components&lt;/a&gt;, chances are you&amp;rsquo;ve written something like this:</source>
          <target state="translated">または、&lt;a href=&quot;../component-dynamic-async&quot;&gt;非同期コンポーネント&lt;/a&gt;を含むアプリケーションの単体テストを行っている場合は、次のように記述している可能性があります。</target>
        </trans-unit>
        <trans-unit id="42dd049e1164508d70fdffd3fa7096495d134200" translate="yes" xml:space="preserve">
          <source>Or, the &lt;code&gt;slot&lt;/code&gt; attribute can also be used directly on a normal element:</source>
          <target state="translated">または、 &lt;code&gt;slot&lt;/code&gt; 属性を通常の要素で直接使用することもできます。</target>
        </trans-unit>
        <trans-unit id="2ab1ce11bd9c8abf32d55c7982f3dae620e8cb0a" translate="yes" xml:space="preserve">
          <source>Or, using &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify (opens new window)&lt;/a&gt; with Grunt and &lt;a href=&quot;https://github.com/jmreidy/grunt-browserify&quot;&gt;grunt-browserify (opens new window)&lt;/a&gt;:</source>
          <target state="translated">または、使用して&lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify（新しいウィンドウが開きます）&lt;/a&gt;うなり声とで&lt;a href=&quot;https://github.com/jmreidy/grunt-browserify&quot;&gt;イサキ-browserify（新しいウィンドウが開きます）&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="c548ba963676210f5bfb2bdd1152c86a09840f88" translate="yes" xml:space="preserve">
          <source>Or, using &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify (opens new window)&lt;/a&gt; with Gulp:</source>
          <target state="translated">または、&lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;Gulpでenvify（新しいウィンドウを開く）&lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="eda804a2c09c29b8cf6a5a0b90c532b90ce7782e" translate="yes" xml:space="preserve">
          <source>Or, using &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; with Grunt and &lt;a href=&quot;https://github.com/jmreidy/grunt-browserify&quot;&gt;grunt-browserify&lt;/a&gt;:</source>
          <target state="translated">または、使用して&lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt;うなり声とで&lt;a href=&quot;https://github.com/jmreidy/grunt-browserify&quot;&gt;面倒-browserify&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="4a6aaeff2cbead89c1f4935f438fab6a604b15ba" translate="yes" xml:space="preserve">
          <source>Or, using &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; with Gulp:</source>
          <target state="translated">または、&lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;Gulp&lt;/a&gt;でenvifyを使用します。</target>
        </trans-unit>
        <trans-unit id="f1956be0d3870d999ee378a0178cc016dd3ada0f" translate="yes" xml:space="preserve">
          <source>Order matters when using modifiers because the relevant code is generated in the same order. Therefore using &lt;code&gt;@click.prevent.self&lt;/code&gt; will prevent &lt;strong&gt;all clicks&lt;/strong&gt; while &lt;code&gt;@click.self.prevent&lt;/code&gt; will only prevent clicks on the element itself.</source>
          <target state="translated">関連するコードは同じ順序で生成されるため、修飾子を使用する場合は順序が重要です。したがって、 &lt;code&gt;@click.prevent.self&lt;/code&gt; を使用すると、&lt;strong&gt;すべてのクリック&lt;/strong&gt;が防止され&lt;strong&gt;ますが&lt;/strong&gt;、 &lt;code&gt;@click.self.prevent&lt;/code&gt; は、要素自体のクリックのみが防止されます。</target>
        </trans-unit>
        <trans-unit id="1dde4fa7292ce9cc3269b98cdb60ec01006edb1f" translate="yes" xml:space="preserve">
          <source>Order matters when using modifiers because the relevant code is generated in the same order. Therefore using &lt;code&gt;v-on:click.prevent.self&lt;/code&gt; will prevent &lt;strong&gt;all clicks&lt;/strong&gt; while &lt;code&gt;v-on:click.self.prevent&lt;/code&gt; will only prevent clicks on the element itself.</source>
          <target state="translated">関連するコードが同じ順序で生成されるため、修飾子を使用する場合は順序が重要です。したがって、 &lt;code&gt;v-on:click.prevent.self&lt;/code&gt; を使用すると&lt;strong&gt;すべてのクリック&lt;/strong&gt;が防止され、 &lt;code&gt;v-on:click.self.prevent&lt;/code&gt; を使用すると要素自体のクリックのみが防止されます。</target>
        </trans-unit>
        <trans-unit id="39e64d7abff6f773ffb6cbec098e4c76feffd596" translate="yes" xml:space="preserve">
          <source>Order of words in component names</source>
          <target state="translated">コンポーネント名の語順</target>
        </trans-unit>
        <trans-unit id="4ca3deef66606ab2cc6dd3240ad8a0d842c161e3" translate="yes" xml:space="preserve">
          <source>Order of words in component names &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">コンポーネント名の単語の順序を&lt;sup&gt;強く推奨&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="519255ae1f74ffc5ddd29979295c7572f048ad81" translate="yes" xml:space="preserve">
          <source>Organization</source>
          <target state="translated">Organization</target>
        </trans-unit>
        <trans-unit id="ce2a84f2c2447c5ea7220c9144eb3ca335437fca" translate="yes" xml:space="preserve">
          <source>Organizing Components</source>
          <target state="translated">構成要素の整理</target>
        </trans-unit>
        <trans-unit id="c5c0f6920c95f31314076af49b17314ea73698db" translate="yes" xml:space="preserve">
          <source>Organizing Transitions into Components</source>
          <target state="translated">トランジションをコンポーネントに整理する</target>
        </trans-unit>
        <trans-unit id="360d7d42956f7872b9ede3cea3c30a3ba0acec02" translate="yes" xml:space="preserve">
          <source>Organizing logics with component's options (&lt;code&gt;data&lt;/code&gt;, &lt;code&gt;computed&lt;/code&gt;, &lt;code&gt;methods&lt;/code&gt;, &lt;code&gt;watch&lt;/code&gt;) works in most cases. However, when our components get bigger, the list of &lt;strong&gt;logical concerns&lt;/strong&gt; also grows. This can lead to components that are hard to read and understand, especially for people who didn't write them in the first place.</source>
          <target state="translated">ほとんどの場合、コンポーネントのオプション（ &lt;code&gt;data&lt;/code&gt; 、 &lt;code&gt;computed&lt;/code&gt; 、 &lt;code&gt;methods&lt;/code&gt; 、 &lt;code&gt;watch&lt;/code&gt; ）を使用してロジックを整理することができます。ただし、コンポーネントが大きくなると、&lt;strong&gt;論理的な懸念事項&lt;/strong&gt;のリストも増えます。これは、特に最初からコンポーネントを作成しなかった人々にとって、読みにくく、理解しにくいコンポーネントにつながる可能性があります。</target>
        </trans-unit>
        <trans-unit id="0ba799c410addb3c357f8f4ace9cc3fe6bde69ff" translate="yes" xml:space="preserve">
          <source>Other Examples</source>
          <target state="translated">その他の例</target>
        </trans-unit>
        <trans-unit id="c3d0ce766708c752c9789d75994b0abdc210827b" translate="yes" xml:space="preserve">
          <source>Other Helpful Tools</source>
          <target state="translated">その他の便利なツール</target>
        </trans-unit>
        <trans-unit id="e6f144ccf73f0c206f299610267139c1512e90bc" translate="yes" xml:space="preserve">
          <source>Other Minor Changes</source>
          <target state="translated">その他の軽微な変更</target>
        </trans-unit>
        <trans-unit id="f12ddde082114607d0effddf28c1425f7adad67d" translate="yes" xml:space="preserve">
          <source>Other Projects</source>
          <target state="translated">その他のプロジェクト</target>
        </trans-unit>
        <trans-unit id="8096cf3d3237b4ba8c7121f2a65c1398f3cfa1d7" translate="yes" xml:space="preserve">
          <source>Other non-boolean attrs</source>
          <target state="translated">その他の非ブーリアン属性</target>
        </trans-unit>
        <trans-unit id="b8975bed11b093ad4d25765fbdba52b25cdf43ca" translate="yes" xml:space="preserve">
          <source>Our &lt;a href=&quot;https://vuejs.org/coc&quot;&gt;Code of Conduct&lt;/a&gt; is a guide to make it easier to enrich all of us and the technical communities in which we participate.</source>
          <target state="translated">私たち&lt;a href=&quot;https://vuejs.org/coc&quot;&gt;の行動規範&lt;/a&gt;は、私たち全員と私たちが参加する技術コミュニティをより豊かにすることを容易にするためのガイドです。</target>
        </trans-unit>
        <trans-unit id="e13c5dab7f9b9edcb291ceb3ccaa49cace4cfdc4" translate="yes" xml:space="preserve">
          <source>Our custom directive is now flexible enough to support a few different use cases.</source>
          <target state="translated">私たちのカスタムディレクティブは、いくつかの異なるユースケースにも対応できるように柔軟になりました。</target>
        </trans-unit>
        <trans-unit id="6914ca8cedbdd86cdefec4f8279bb23f3c749797" translate="yes" xml:space="preserve">
          <source>Our custom directive is now flexible enough to support a few different use cases. To make it even more dynamic, we can also allow to modify a bound value. Let's create an additional property &lt;code&gt;pinPadding&lt;/code&gt; and bind it to the &lt;code&gt;&amp;lt;input type=&quot;range&quot;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">カスタムディレクティブは、いくつかの異なるユースケースをサポートするのに十分な柔軟性を備えています。さらに動的にするために、バインドされた値を変更することもできます。追加のプロパティ &lt;code&gt;pinPadding&lt;/code&gt; を作成し、それを &lt;code&gt;&amp;lt;input type=&quot;range&quot;&amp;gt;&lt;/code&gt; にバインドしましょう。</target>
        </trans-unit>
        <trans-unit id="37f52ec20ab2f8bf7b37f62b547cb8e20c076916" translate="yes" xml:space="preserve">
          <source>Our setup code is kept separate from our cleanup code, making it more difficult to programmatically clean up anything we set up.</source>
          <target state="translated">セットアップコードはクリーンアップコードとは別のものになっているため、セットアップしたものをプログラム的にクリーンアップすることが難しくなっています。</target>
        </trans-unit>
        <trans-unit id="238d7a51a5c3679447b882c1766791e18087ee23" translate="yes" xml:space="preserve">
          <source>Over time though, Knockout development has slowed and it&amp;rsquo;s begun to show its age a little. For example, its component system lacks a full set of lifecycle hooks and although it&amp;rsquo;s a very common use case, the interface for passing children to a component feels a little clunky compared to &lt;a href=&quot;components#Content-Distribution-with-Slots&quot;&gt;Vue&amp;rsquo;s&lt;/a&gt;.</source>
          <target state="translated">しかし、時間の経過とともに、Knockoutの開発は鈍化し、年齢が少し表示され始めました。たとえば、そのコンポーネントシステムにはライフサイクルフックの完全なセットがありません。これは非常に一般的な使用例ですが、子をコンポーネントに渡すためのインターフェースは、&lt;a href=&quot;components#Content-Distribution-with-Slots&quot;&gt;Vueのに&lt;/a&gt;比べて少し不格好な感じがします。</target>
        </trans-unit>
        <trans-unit id="801ee7630523d9225a5832eb0b586c416639bcdd" translate="yes" xml:space="preserve">
          <source>Overall this removes the need for a whole class of performance optimizations from the developer&amp;rsquo;s plate, and allows them to focus more on building the app itself as it scales.</source>
          <target state="translated">全体として、これにより、開発者の側からクラス全体のパフォーマンス最適化の必要がなくなり、スケーリングに応じてアプリ自体の構築に集中できるようになります。</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="9ddaaee77cc1ce72a49a759b344df34d9c4b8e47" translate="yes" xml:space="preserve">
          <source>Parcel</source>
          <target state="translated">Parcel</target>
        </trans-unit>
        <trans-unit id="33422ae8d86c599fdf8a4eca4a9f0b44c416cdcc" translate="yes" xml:space="preserve">
          <source>Partials have been removed in favor of more explicit data flow between components, using props. Unless you&amp;rsquo;re using a partial in a performance-critical area, the recommendation is to use a &lt;a href=&quot;components&quot;&gt;normal component&lt;/a&gt; instead. If you were dynamically binding the &lt;code&gt;name&lt;/code&gt; of a partial, you can use a &lt;a href=&quot;components#Dynamic-Components&quot;&gt;dynamic component&lt;/a&gt;.</source>
          <target state="translated">小道具を使用して、コンポーネント間のより明示的なデータフローを優先して、パーシャルが削除されました。パフォーマンスが重要な領域でパーシャルを使用していない限り、代わりに&lt;a href=&quot;components&quot;&gt;通常のコンポーネント&lt;/a&gt;を使用することをお勧めします。パーシャルの &lt;code&gt;name&lt;/code&gt; を動的にバインドしていた場合は、&lt;a href=&quot;components#Dynamic-Components&quot;&gt;動的コンポーネントを&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="338863b7eee72484e07f62862d08e6032c44cc9e" translate="yes" xml:space="preserve">
          <source>PascalCase has a few advantages over kebab-case:</source>
          <target state="translated">PascalCaseはkebab-caseに比べていくつかの利点があります。</target>
        </trans-unit>
        <trans-unit id="548d3885edc6e4335d13093c595410a7b884affc" translate="yes" xml:space="preserve">
          <source>PascalCase works best with autocompletion in code editors, as it&amp;rsquo;s consistent with how we reference components in JS(X) and templates, wherever possible. However, mixed case filenames can sometimes create issues on case-insensitive file systems, which is why kebab-case is also perfectly acceptable.</source>
          <target state="translated">PascalCaseは、可能な限りJS（X）およびテンプレートのコンポーネントを参照する方法と一貫しているため、コードエディターのオートコンプリートで最適に動作します。ただし、大文字と小文字が混在するファイル名は、大文字と小文字を区別しないファイルシステムで問題を引き起こすことがあります。そのため、ケバブケースも完全に受け入れられます。</target>
        </trans-unit>
        <trans-unit id="030bc27225285970757d5743a8972ff008b358d3" translate="yes" xml:space="preserve">
          <source>PascalCase works best with autocompletion in code editors, as it's consistent with how we reference components in JS(X) and templates, wherever possible. However, mixed case filenames can sometimes create issues on case-insensitive file systems, which is why kebab-case is also perfectly acceptable.</source>
          <target state="translated">PascalCaseは、JS(X)やテンプレートでコンポーネントを参照する方法と一致しているため、コードエディタでの自動補完に最も適しています。しかし、大文字と小文字が混在したファイル名は、大文字小文字を区別しないファイルシステムで問題を起こすことがあります。</target>
        </trans-unit>
        <trans-unit id="7a196eac2c28fafbe4d9187661633bcbf6027ce5" translate="yes" xml:space="preserve">
          <source>Pass props to an instance during its creation. This is primarily intended to make unit testing easier.</source>
          <target state="translated">インスタンスの作成中にpropsを渡す。これは主にユニットテストを容易にすることを目的としています。</target>
        </trans-unit>
        <trans-unit id="b15f86774ec499f2e12e99cefb07c19682388f39" translate="yes" xml:space="preserve">
          <source>Passing Attributes and Events to Child Elements/Components</source>
          <target state="translated">属性とイベントを子要素/コンポーネントに渡す</target>
        </trans-unit>
        <trans-unit id="2d887895f60f5b27f1b6d8b4caca996b7ba1b2ec" translate="yes" xml:space="preserve">
          <source>Passing Data to Child Components with Props</source>
          <target state="translated">プロップを使用した子コンポーネントへのデータの受け渡し</target>
        </trans-unit>
        <trans-unit id="433763659eeaa495cbff9aab4fe004119a2898a6" translate="yes" xml:space="preserve">
          <source>Passing Static or Dynamic Props</source>
          <target state="translated">静的または動的な小道具を渡す</target>
        </trans-unit>
        <trans-unit id="69be14b609ea17960c4d679c5eac924f94c81a81" translate="yes" xml:space="preserve">
          <source>Passing a Boolean</source>
          <target state="translated">ブール値を渡す</target>
        </trans-unit>
        <trans-unit id="d0fe306e90e1b3d68f9dfb33a59e5241fa360572" translate="yes" xml:space="preserve">
          <source>Passing a Number</source>
          <target state="translated">ナンバーパス</target>
        </trans-unit>
        <trans-unit id="7c0a78154538069738bcf2cc5806f8c67f3744ba" translate="yes" xml:space="preserve">
          <source>Passing an Array</source>
          <target state="translated">配列を渡す</target>
        </trans-unit>
        <trans-unit id="acf0b569b0457811ee77b0ce38bc6a81b61b14f2" translate="yes" xml:space="preserve">
          <source>Passing an Object</source>
          <target state="translated">オブジェクトを渡す</target>
        </trans-unit>
        <trans-unit id="d7c9bb0f37131e5505011ab717b8002aabd88b14" translate="yes" xml:space="preserve">
          <source>Passing in &lt;code&gt;immediate: true&lt;/code&gt; in the option will trigger the callback immediately with the current value of the expression:</source>
          <target state="translated">&lt;code&gt;immediate: true&lt;/code&gt; 渡す：オプションでtrueを指定すると、式の現在の値ですぐにコールバックがトリガーされます。</target>
        </trans-unit>
        <trans-unit id="035acdf774e378174fd9c2b1135b63f7dfac1cf3" translate="yes" xml:space="preserve">
          <source>Passing the Properties of an Object</source>
          <target state="translated">オブジェクトのプロパティを渡す</target>
        </trans-unit>
        <trans-unit id="c6e21e8099f57238a0c9760ebd07a5a614584331" translate="yes" xml:space="preserve">
          <source>People need to feel safe asking questions when contributing/reviewing content. Here's how you can do that:</source>
          <target state="translated">コンテンツを投稿/レビューする際には、人々は安心して質問をする必要があります。そのための方法をご紹介します。</target>
        </trans-unit>
        <trans-unit id="90e116a18efa00a0e0767d89a0a941c40133b88a" translate="yes" xml:space="preserve">
          <source>Perceivable (opens new window)</source>
          <target state="translated">知覚可能(新しいウィンドウが開きます</target>
        </trans-unit>
        <trans-unit id="ebf952b12947766273332fa80b06a64c003fbf12" translate="yes" xml:space="preserve">
          <source>Perform the side effect lazily;</source>
          <target state="translated">副作用を怠惰に行う。</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="93bd1b9f8459e0acda65f78340bb55e6188adccd" translate="yes" xml:space="preserve">
          <source>Performance gains from 2.x for functional components are now negligible in 3.x, so we recommend just using stateful components</source>
          <target state="translated">3.xでは機能コンポーネントの2.xからのパフォーマンスの向上は無視できる程度になっていますので、ステートフルコンポーネントの使用のみを推奨します。</target>
        </trans-unit>
        <trans-unit id="c141d90b1516060d8a91d0883b728d5ba2fca7a4" translate="yes" xml:space="preserve">
          <source>Performance-wise, Vue outperforms Ember &lt;a href=&quot;https://stefankrause.net/js-frameworks-benchmark8/table.html&quot;&gt;by a fair margin&lt;/a&gt;, even after the latest Glimmer engine update in Ember 3.x. Vue automatically batches updates, while in Ember you need to manually manage run loops in performance-critical situations.</source>
          <target state="translated">Ember 3.xでの最新のグリマーエンジンの更新後でも、VueはEmberより&lt;a href=&quot;https://stefankrause.net/js-frameworks-benchmark8/table.html&quot;&gt;かなり&lt;/a&gt;パフォーマンスが優れています。Vueは自動的に更新をバッチ処理しますが、Emberではパフォーマンスがクリティカルな状況で実行ループを手動で管理する必要があります。</target>
        </trans-unit>
        <trans-unit id="ed212fa164b940b935ec0a25b32878a0917c7268" translate="yes" xml:space="preserve">
          <source>Placeholder</source>
          <target state="translated">Placeholder</target>
        </trans-unit>
        <trans-unit id="11275f5de90c26fd6cc8ef9a7af920c6f1101f2b" translate="yes" xml:space="preserve">
          <source>Please note we used &lt;code&gt;model-value&lt;/code&gt; with kebab-case here because we are working with in-DOM templates. You can find a detailed explanation on kebab-cased vs camelCased attributes in the &lt;a href=&quot;#dom-template-parsing-caveats&quot;&gt;DOM Template Parsing Caveats&lt;/a&gt; section</source>
          <target state="translated">ここでは、DOM内のテンプレートを使用しているため、kebab-caseで &lt;code&gt;model-value&lt;/code&gt; を使用していることに注意してください。ケバブケースとキャメルケースの属性の詳細な説明は、&lt;a href=&quot;#dom-template-parsing-caveats&quot;&gt;DOMテンプレートの解析に関する警告&lt;/a&gt;セクションにあります。</target>
        </trans-unit>
        <trans-unit id="07ba11f36689ab7bebcb8bac7bb946785fdc5fcf" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js&quot;&gt;VNode class declaration&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js&quot;&gt;VNodeクラス宣言を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ac81e979c05bfcd7c0a62185f40c627cb4bf8d0e" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer&quot;&gt;vue-server-renderer package documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer&quot;&gt;vue-server-rendererパッケージのドキュメントを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="1dadf730922f5cc0e3cc5b34354923331bd7cd59" translate="yes" xml:space="preserve">
          <source>Plugin users will now be able to &lt;code&gt;inject['i18n']&lt;/code&gt; into their components and access the object.</source>
          <target state="translated">プラグインユーザーは、コンポーネントに &lt;code&gt;inject['i18n']&lt;/code&gt; 挿入して、オブジェクトにアクセスできるようになります。</target>
        </trans-unit>
        <trans-unit id="ab2e26dd8b8868a3969cb3321e0c983c0d9d67d4" translate="yes" xml:space="preserve">
          <source>Plugins</source>
          <target state="translated">Plugins</target>
        </trans-unit>
        <trans-unit id="a39e5a3d43de88abead0db5ad2318b757a0d742a" translate="yes" xml:space="preserve">
          <source>Plugins also allow us to use &lt;code&gt;inject&lt;/code&gt; to provide a function or attribute to the plugin's users. For example, we can allow the application to have access to the &lt;code&gt;options&lt;/code&gt; parameter to be able to use the translations object.</source>
          <target state="translated">プラグインを使用すると、 &lt;code&gt;inject&lt;/code&gt; を使用して、プラグインのユーザーに関数または属性を提供することもできます。たとえば、アプリケーションが &lt;code&gt;options&lt;/code&gt; パラメータにアクセスできるようにして、translationsオブジェクトを使用できるようにすることができます。</target>
        </trans-unit>
        <trans-unit id="5fd12b92cd6c82b740fa6a101861368f2df9e451" translate="yes" xml:space="preserve">
          <source>Plugins are self-contained code that usually add global-level functionality to Vue. It is either an &lt;code&gt;object&lt;/code&gt; that exposes an &lt;code&gt;install()&lt;/code&gt; method, or a &lt;code&gt;function&lt;/code&gt;.</source>
          <target state="translated">プラグインは自己完結型のコードであり、通常はVueにグローバルレベルの機能を追加します。これは、 &lt;code&gt;install()&lt;/code&gt; メソッドを公​​開する &lt;code&gt;object&lt;/code&gt; または &lt;code&gt;function&lt;/code&gt; いずれかです。</target>
        </trans-unit>
        <trans-unit id="2ec26164bdb69a59c55861e3e8bf8c2338afa489" translate="yes" xml:space="preserve">
          <source>Plugins may add to Vue&amp;rsquo;s global/instance properties and component options. In these cases, type declarations are needed to make plugins compile in TypeScript. Fortunately, there&amp;rsquo;s a TypeScript feature to augment existing types called &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation&quot;&gt;module augmentation&lt;/a&gt;.</source>
          <target state="translated">プラグインは、Vueのグローバル/インスタンスプロパティとコンポーネントオプションに追加できます。これらの場合、プラグインをTypeScriptでコンパイルするには、型宣言が必要です。さいわい、&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation&quot;&gt;モジュールの拡張&lt;/a&gt;と呼ばれる既存の型を拡張するTypeScript機能があります。</target>
        </trans-unit>
        <trans-unit id="a77c0e9519023f6d3be8c4d42d0b610cd78973f1" translate="yes" xml:space="preserve">
          <source>Plugins usually add global-level functionality to Vue. There is no strictly defined scope for a plugin - there are typically several types of plugins:</source>
          <target state="translated">プラグインは通常、Vueにグローバルレベルの機能を追加します。プラグインには厳密に定義されたスコープはなく、通常、いくつかのタイプのプラグインがあります。</target>
        </trans-unit>
        <trans-unit id="6b444c9bbd597a6dbe29c3f8f817d1db7e6559dd" translate="yes" xml:space="preserve">
          <source>Polymer</source>
          <target state="translated">Polymer</target>
        </trans-unit>
        <trans-unit id="48e622aad7a867a5952bf32f2af768cae8dc7ee2" translate="yes" xml:space="preserve">
          <source>Polymer is another Google-sponsored project and in fact was a source of inspiration for Vue as well. Vue&amp;rsquo;s components can be loosely compared to Polymer&amp;rsquo;s custom elements and both provide a very similar development style. The biggest difference is that Polymer is built upon the latest Web Components features and requires non-trivial polyfills to work (with degraded performance) in browsers that don&amp;rsquo;t support those features natively. In contrast, Vue works without any dependencies or polyfills down to IE9.</source>
          <target state="translated">PolymerはGoogleが後援する別のプロジェクトで、実際にはVueのインスピレーションの源でもありました。VueのコンポーネントはPolymerのカスタム要素と大まかに比較でき、どちらも非常に類似した開発スタイルを提供します。最大の違いは、Polymerが最新のWebコンポーネント機能に基づいて構築されており、これらの機能をネイティブでサポートしていないブラウザーで（パフォーマンスの低下を伴う）動作するために重要なポリフィルが必要なことです。対照的に、VueはIE9までの依存関係やポリフィルなしで機能します。</target>
        </trans-unit>
        <trans-unit id="e3ed11ed8d0e10e94e25f6a0c663996776050be2" translate="yes" xml:space="preserve">
          <source>Pre-Compiling Templates</source>
          <target state="translated">コンパイル前のテンプレート</target>
        </trans-unit>
        <trans-unit id="15730848aa8545d4e8c4a13694b301ad43855149" translate="yes" xml:space="preserve">
          <source>Preact and Other React-Like Libraries</source>
          <target state="translated">Preact とその他の React ライクなライブラリ</target>
        </trans-unit>
        <trans-unit id="8329b838710df96576166a6b1eb910a04281650a" translate="yes" xml:space="preserve">
          <source>Precautions</source>
          <target state="translated">Precautions</target>
        </trans-unit>
        <trans-unit id="13b722a113ea767b74d7b7af219e735b33c584e7" translate="yes" xml:space="preserve">
          <source>Prefer class selectors over element selectors in &lt;code&gt;scoped&lt;/code&gt; styles, because large numbers of element selectors are slow.</source>
          <target state="translated">多数の要素セレクターは遅いため、 &lt;code&gt;scoped&lt;/code&gt; スタイルの要素セレクターよりもクラスセレクターを優先します。</target>
        </trans-unit>
        <trans-unit id="90eceb016c51a762f15c7287008c113f6f37296c" translate="yes" xml:space="preserve">
          <source>Prefix</source>
          <target state="translated">Prefix</target>
        </trans-unit>
        <trans-unit id="0862f2579db5a3bc1211bb13bd8e3d71a3009a33" translate="yes" xml:space="preserve">
          <source>Pretty cool, right?</source>
          <target state="translated">カッコいいでしょ?</target>
        </trans-unit>
        <trans-unit id="1f991a95af1936160af34e1fab9584d14813afc2" translate="yes" xml:space="preserve">
          <source>Prevent Mutating Reactive Objects with &lt;code&gt;readonly&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; リアクティブオブジェクトの変更を防止する</target>
        </trans-unit>
        <trans-unit id="d28e5e120a6410b8fa39239f3e826f7cc472afd9" translate="yes" xml:space="preserve">
          <source>Previously, &lt;code&gt;v-el&lt;/code&gt;/&lt;code&gt;v-ref&lt;/code&gt; combined with &lt;code&gt;v-for&lt;/code&gt; would produce an array of elements/components, because there was no way to give each item a unique name. You can still achieve this behavior by giving each item the same &lt;code&gt;ref&lt;/code&gt;:</source>
          <target state="translated">以前は、 &lt;code&gt;v-el&lt;/code&gt; / &lt;code&gt;v-ref&lt;/code&gt; を &lt;code&gt;v-for&lt;/code&gt; と組み合わせると、要素/コンポーネントの配列が生成されました。これは、各アイテムに一意の名前を付ける方法がなかったためです。各アイテムに同じ &lt;code&gt;ref&lt;/code&gt; を与えることで、この動作を実現できます。</target>
        </trans-unit>
        <trans-unit id="d470a2a77dc4521dc133ec45eef2767f713b0387" translate="yes" xml:space="preserve">
          <source>Previously, &lt;code&gt;v-for=&quot;number in 10&quot;&lt;/code&gt; would have &lt;code&gt;number&lt;/code&gt; starting at 0 and ending at 9. Now it starts at 1 and ends at 10.</source>
          <target state="translated">以前は、 &lt;code&gt;v-for=&quot;number in 10&quot;&lt;/code&gt; は0から9 までの &lt;code&gt;number&lt;/code&gt; でしたが、現在は1から10で終わります。</target>
        </trans-unit>
        <trans-unit id="23b9c4376379f9e662432b9880582c302a480f64" translate="yes" xml:space="preserve">
          <source>Previously, async components were created by simply defining a component as a function that returned a promise, such as:</source>
          <target state="translated">以前の非同期コンポーネントは、単にコンポーネントをプロミスを返す関数として定義することで作成されていました。</target>
        </trans-unit>
        <trans-unit id="1140ac9954dc5a38cef519f604f5c32be573d951" translate="yes" xml:space="preserve">
          <source>Primarily used to preserve component state or avoid re-rendering.</source>
          <target state="translated">主に、コンポーネントの状態を保持したり、再レンダリングを回避するために使用されます。</target>
        </trans-unit>
        <trans-unit id="dcdf83698ed6217a7ad9789255b8e995292e5ef5" translate="yes" xml:space="preserve">
          <source>Prime heading: title of the page</source>
          <target state="translated">主な見出し:ページのタイトル</target>
        </trans-unit>
        <trans-unit id="4a8cf08007961260be446ac5857bf7c4959fc651" translate="yes" xml:space="preserve">
          <source>Principles</source>
          <target state="translated">Principles</target>
        </trans-unit>
        <trans-unit id="54685256c4d8355200332707df1e1ca7c0e02261" translate="yes" xml:space="preserve">
          <source>Priority A Rules: Essential (Error Prevention)</source>
          <target state="translated">優先順位Aのルール。エッセンシャル(エラー防止</target>
        </trans-unit>
        <trans-unit id="5e8b1025d5987c3729d2b01eada46b2522bba9e3" translate="yes" xml:space="preserve">
          <source>Priority A: Essential</source>
          <target state="translated">優先度A:必須</target>
        </trans-unit>
        <trans-unit id="387f936830407167742df6ab963bfa0088949c5b" translate="yes" xml:space="preserve">
          <source>Priority B Rules: Strongly Recommended (Improving Readability)</source>
          <target state="translated">優先度Bのルール。強く推奨(読みやすさの向上</target>
        </trans-unit>
        <trans-unit id="736596242b03557a18a34e5f65ea6a2b562cbebd" translate="yes" xml:space="preserve">
          <source>Priority B: Strongly Recommended</source>
          <target state="translated">優先度B:強く推奨</target>
        </trans-unit>
        <trans-unit id="bdd836597207d18ba5b3d19036238a4cd88fa60f" translate="yes" xml:space="preserve">
          <source>Priority C Rules: Recommended (Minimizing Arbitrary Choices and Cognitive Overhead)</source>
          <target state="translated">優先順位Cのルール。推奨(恣意的な選択と認知的オーバーヘッドの最小化</target>
        </trans-unit>
        <trans-unit id="2974ce185c92ec782a626e16a8514e803539b365" translate="yes" xml:space="preserve">
          <source>Priority C: Recommended</source>
          <target state="translated">優先度C:おすすめ</target>
        </trans-unit>
        <trans-unit id="47bd70395bb96139b28544a3748794466e50c29a" translate="yes" xml:space="preserve">
          <source>Priority D Rules: Use with Caution (Potentially Dangerous Patterns)</source>
          <target state="translated">優先度Dのルール。注意して使用する(潜在的に危険なパターン</target>
        </trans-unit>
        <trans-unit id="94fef0d8e8f642d6dc69557c9f10b185198cefc4" translate="yes" xml:space="preserve">
          <source>Priority D: Use with Caution</source>
          <target state="translated">優先順位D。注意して使用してください</target>
        </trans-unit>
        <trans-unit id="f5cd87102ef90d5553f07151bd4bd9dd0bc22e76" translate="yes" xml:space="preserve">
          <source>Private property names</source>
          <target state="translated">私有財産の名称</target>
        </trans-unit>
        <trans-unit id="190351e7c1964109dd0d07bb44b4406d321887f5" translate="yes" xml:space="preserve">
          <source>Private property names &lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">プライベートプロパティ名は&lt;sup&gt;必須&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7d03d42c737cd08e3c616e333f7637225318bb7d" translate="yes" xml:space="preserve">
          <source>Problem solved!</source>
          <target state="translated">問題解決!</target>
        </trans-unit>
        <trans-unit id="c5c5063b096172b05347461de69b1892f161c926" translate="yes" xml:space="preserve">
          <source>Production Deployment</source>
          <target state="translated">生産展開</target>
        </trans-unit>
        <trans-unit id="24b510d5213c71d3e2ce9940d48c8b9fa3d13829" translate="yes" xml:space="preserve">
          <source>Programmatic Event Listeners</source>
          <target state="translated">プログラムイベントリスナー</target>
        </trans-unit>
        <trans-unit id="6ac41420921db4b82a6fc5a064c1c845ef1ef7bc" translate="yes" xml:space="preserve">
          <source>Programmatic Navigation</source>
          <target state="translated">プログラムナビゲーション</target>
        </trans-unit>
        <trans-unit id="476b867d91093b69a7500380688c889567822c8b" translate="yes" xml:space="preserve">
          <source>Programmatically choose one of several other components to delegate to</source>
          <target state="translated">他のいくつかのコンポーネントの中から、委任するコンポーネントをプログラムで選択します。</target>
        </trans-unit>
        <trans-unit id="f6f4da8d93e88a08220e03b7810451d3ba540a34" translate="yes" xml:space="preserve">
          <source>Project</source>
          <target state="translated">Project</target>
        </trans-unit>
        <trans-unit id="ee3cf99bb774be8991c68e2bbfef328b2095ab6c" translate="yes" xml:space="preserve">
          <source>Project Creation</source>
          <target state="translated">プロジェクト作成</target>
        </trans-unit>
        <trans-unit id="cf8dbc35f90ca7fe4e3262afb2f4d8617ccb053f" translate="yes" xml:space="preserve">
          <source>Prop Casing (camelCase vs kebab-case)</source>
          <target state="translated">プロップケーシング(ラクダケース対ケバブケース</target>
        </trans-unit>
        <trans-unit id="1c763ccd366cdd65c783dc8f22bc1a65ff00cadb" translate="yes" xml:space="preserve">
          <source>Prop Mutation &lt;sup&gt;deprecated&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;廃止された&lt;/sup&gt;プロップ変異&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
