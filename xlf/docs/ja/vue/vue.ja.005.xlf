<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="vue">
    <body>
      <group id="vue">
        <trans-unit id="be3c142060e44ba8c62b670b8883bcca7cd5a4cc" translate="yes" xml:space="preserve">
          <source>This guide assumes that you have already read &lt;a href=&quot;component-provide-inject&quot;&gt;Provide / Inject&lt;/a&gt;, &lt;a href=&quot;composition-api-introduction&quot;&gt;Composition API Introduction&lt;/a&gt;, and &lt;a href=&quot;reactivity-fundamentals&quot;&gt;Reactivity Fundamentals&lt;/a&gt;.</source>
          <target state="translated">このガイドは、&lt;a href=&quot;component-provide-inject&quot;&gt;Provide / Inject&lt;/a&gt;、&lt;a href=&quot;composition-api-introduction&quot;&gt;Composition APIの概要&lt;/a&gt;、および&lt;a href=&quot;reactivity-fundamentals&quot;&gt;ReactivityFundamentals&lt;/a&gt;をすでに読んでいることを前提としています。</target>
        </trans-unit>
        <trans-unit id="59b0a231c686d6b708f4d2d26c98389f653ba04e" translate="yes" xml:space="preserve">
          <source>This guide assumes that you have already read the &lt;a href=&quot;composition-api-introduction&quot;&gt;Composition API Introduction&lt;/a&gt; and &lt;a href=&quot;reactivity-fundamentals&quot;&gt;Reactivity Fundamentals&lt;/a&gt;. Read that first if you are new to Composition API.</source>
          <target state="translated">このガイドは、&lt;a href=&quot;composition-api-introduction&quot;&gt;CompositionAPIの概要&lt;/a&gt;と&lt;a href=&quot;reactivity-fundamentals&quot;&gt;反応性の基礎&lt;/a&gt;をすでに読んでいることを前提としています。Composition APIを初めて使用する場合は、最初にそれをお読みください。</target>
        </trans-unit>
        <trans-unit id="73a1f77be28de1f8cd112541c8e445f32b88426b" translate="yes" xml:space="preserve">
          <source>This guide is primarily for users with prior Vue 2 experience who want to learn about the new features and changes in Vue 3. &lt;strong&gt;This is not something you have to read from top to bottom before trying out Vue 3.&lt;/strong&gt; While it looks like a lot has changed, a lot of what you know and love about Vue is still the same; but we wanted to be as thorough as possible and provide detailed explanations and examples for every documented change.</source>
          <target state="translated">このガイドでは、主にVueの3の新機能と変更点について学びたいと思う前にVueの2経験を持つユーザーのためにされた&lt;strong&gt;このVueの3を試す前に、あなたは上から下に読む必要はありものではありません&lt;/strong&gt;たくさん持っているように見えますが変更されましたが、Vueについてあなたが知っていて好きなことの多くはまだ同じです。しかし、私たちは可能な限り徹底し、文書化されたすべての変更について詳細な説明と例を提供したいと考えました。</target>
        </trans-unit>
        <trans-unit id="029497cad2c3a227399525b3094cb469885f9f59" translate="yes" xml:space="preserve">
          <source>This guide will provide an overview of different design elements that are available for your use in creating documentation.</source>
          <target state="translated">このガイドでは、ドキュメントを作成する際に使用できるさまざまなデザイン要素の概要を説明します。</target>
        </trans-unit>
        <trans-unit id="99d8b5af0048a10c4665e00dd894160ce4940650" translate="yes" xml:space="preserve">
          <source>This has been replaced with a &lt;a href=&quot;https://router.vuejs.org/en/advanced/scroll-behavior.html&quot;&gt;&lt;code&gt;scrollBehavior&lt;/code&gt; option&lt;/a&gt; that accepts a function, so that the scroll behavior is completely customizable - even per route. This opens many new possibilities, but to replicate the old behavior of:</source>
          <target state="translated">これは、関数を受け入れる&lt;a href=&quot;https://router.vuejs.org/en/advanced/scroll-behavior.html&quot;&gt; &lt;code&gt;scrollBehavior&lt;/code&gt; オプションに&lt;/a&gt;置き換えられたため、スクロール動作は完全にカスタマイズ可能です-ルートごとでも可能です。これは多くの新しい可能性を開きますが、以下の古い動作を複製します。</target>
        </trans-unit>
        <trans-unit id="f10052c0b9e092f83c38d6274c0a1d795d171aa8" translate="yes" xml:space="preserve">
          <source>This has been reworked as a &lt;a href=&quot;../api/index#delimiters&quot;&gt;component-level option&lt;/a&gt;. This allows you to use alternative delimiters within your app without breaking 3rd-party components.</source>
          <target state="translated">これは、&lt;a href=&quot;../api/index#delimiters&quot;&gt;コンポーネントレベルのオプション&lt;/a&gt;として作り直されました。これにより、サードパーティのコンポーネントを壊すことなく、アプリ内で別の区切り文字を使用できます。</target>
        </trans-unit>
        <trans-unit id="898f8bcaeb338ce5f524c8f533de606d8f44d3a0" translate="yes" xml:space="preserve">
          <source>This has quickly gotten out of hand. That&amp;rsquo;s why to provide context information to descendent components arbitrarily deep, we instead recommend &lt;a href=&quot;#Dependency-Injection&quot;&gt;dependency injection&lt;/a&gt;.</source>
          <target state="translated">これはすぐに手に負えなくなった。そのため、子孫コンポーネントにコンテキスト情報を任意に深く提供するために、&lt;a href=&quot;#Dependency-Injection&quot;&gt;依存関係注入&lt;/a&gt;をお勧めします。</target>
        </trans-unit>
        <trans-unit id="7999999aa4a7bfbcc499f10673ce25fba6720104" translate="yes" xml:space="preserve">
          <source>This has two potential issues:</source>
          <target state="translated">これには2つの潜在的な問題があります。</target>
        </trans-unit>
        <trans-unit id="963611d5d3d89faff52fcf7b4bfcf0767cf6c914" translate="yes" xml:space="preserve">
          <source>This helps you to more quickly find a component when you need to edit it or review how to use it.</source>
          <target state="translated">これにより、コンポーネントを編集する必要がある場合や、使用方法を確認する必要がある場合に、より迅速にコンポーネントを見つけることができます。</target>
        </trans-unit>
        <trans-unit id="890a52b4154ab564b050c448a049340ff861abb4" translate="yes" xml:space="preserve">
          <source>This increased modularity not only makes it easier to migrate to Vue 2, but also allows currency parsing and formatting to be:</source>
          <target state="translated">このモジュール性の向上により、Vue 2への移行が容易になっただけでなく、通貨のパースやフォーマットも可能になりました。</target>
        </trans-unit>
        <trans-unit id="436f872e6df27f11a6bfa0004df035d1ba2d2bdf" translate="yes" xml:space="preserve">
          <source>This is a contrived example, but we have managed to separate our app into two smaller units, and the child is reasonably well-decoupled from the parent via the props interface. We can now further improve our &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt; component with more complex template and logic without affecting the parent app.</source>
          <target state="translated">これは不自然な例ですが、アプリを2つの小さなユニットに分離することができ、子はpropsインターフェースを介して親からかなり適切に分離されています。これで、親アプリに影響を与えることなく、より複雑なテンプレートとロジックを使用して &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt; コンポーネントをさらに改善できます。</target>
        </trans-unit>
        <trans-unit id="0656ba279b49d46a5cdfd7935d734273e07a9de6" translate="yes" xml:space="preserve">
          <source>This is a great tip to remember!</source>
          <target state="translated">これは覚えておくと便利なヒントです</target>
        </trans-unit>
        <trans-unit id="2e19f220c4bd03c63d74d3c19c553f790da9b66d" translate="yes" xml:space="preserve">
          <source>This is a low-level internal API change and does not affect most developers.</source>
          <target state="translated">これは低レベルの内部APIの変更であり、ほとんどの開発者には影響しません。</target>
        </trans-unit>
        <trans-unit id="1103f0107c054609536e73ad83ba83989e32a52e" translate="yes" xml:space="preserve">
          <source>This is definitely the most difficult page in the guide to write, but we do feel it&amp;rsquo;s important. Odds are, you&amp;rsquo;ve had problems you tried to solve and you&amp;rsquo;ve used another library to solve them. You&amp;rsquo;re here because you want to know if Vue can solve your specific problems better. That&amp;rsquo;s what we hope to answer for you.</source>
          <target state="translated">これは間違いなくガイドで書くのが最も難しいページですが、重要だと感じています。奇妙なことに、あなたはあなたが解決しようとした問題を抱えていて、それらを解決するために別のライブラリを使用したことがあります。あなたがここにいるのは、Vueが特定の問題をよりよく解決できるかどうかを知りたいからです。それをお答えしたいと思います。</target>
        </trans-unit>
        <trans-unit id="ac302dcb2061f99b9d2af5d1c922a8db1ee40057" translate="yes" xml:space="preserve">
          <source>This is especially important because of &lt;a href=&quot;v-on-native-modifier-removed&quot;&gt;the removal of the &lt;code&gt;.native&lt;/code&gt; modifier&lt;/a&gt;. Any listeners for events that aren't declared with &lt;code&gt;emits&lt;/code&gt; will now be included in the component's &lt;code&gt;$attrs&lt;/code&gt;, which by default will be bound to the component's root node.</source>
          <target state="translated">&lt;a href=&quot;v-on-native-modifier-removed&quot;&gt; &lt;code&gt;.native&lt;/code&gt; &lt;/a&gt;修飾子が削除されているため、これは特に重要です。 &lt;code&gt;emits&lt;/code&gt; 宣言されていないイベントのリスナーは、コンポーネントの &lt;code&gt;$attrs&lt;/code&gt; に含まれるようになり、デフォルトではコンポーネントのルートノードにバインドされます。</target>
        </trans-unit>
        <trans-unit id="6e75c804038e58ba6a3277c3614a92aeb116d1c9" translate="yes" xml:space="preserve">
          <source>This is now an &lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;option on route definitions&lt;/a&gt;. So for example, you will update:</source>
          <target state="translated">これは&lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;ルート定義のオプションになりました&lt;/a&gt;。たとえば、次のように更新します。</target>
        </trans-unit>
        <trans-unit id="50fa440286db22b789b949c9a5abab1c06513e69" translate="yes" xml:space="preserve">
          <source>This is now an &lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;option on the definition for the route&lt;/a&gt; you&amp;rsquo;d like to alias to. So for example, you will update:</source>
          <target state="translated">これは、エイリアスを設定&lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;するルートの定義のオプションになり&lt;/a&gt;ました。たとえば、次のように更新します。</target>
        </trans-unit>
        <trans-unit id="56cbae9ff95e4616e32a9cc520227cb6feaa2c74" translate="yes" xml:space="preserve">
          <source>This is often useful, because even with &lt;code&gt;type=&quot;number&quot;&lt;/code&gt;, the value of HTML input elements always returns a string. If the value cannot be parsed with &lt;code&gt;parseFloat()&lt;/code&gt;, then the original value is returned.</source>
          <target state="translated">&lt;code&gt;type=&quot;number&quot;&lt;/code&gt; を使用しても、HTML入力要素の値は常に文字列を返すため、これは多くの場合に役立ちます。 &lt;code&gt;parseFloat()&lt;/code&gt; で値を解析できない場合は、元の値が返されます。</target>
        </trans-unit>
        <trans-unit id="a70c72c5011c169a2c1648b6eacd7fc7b9c7fc32" translate="yes" xml:space="preserve">
          <source>This is only relevant for &lt;a href=&quot;../guide/single-file-component&quot;&gt;single-file components&lt;/a&gt;. It does &lt;em&gt;not&lt;/em&gt; require that the &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/scoped-css.html&quot;&gt;&lt;code&gt;scoped&lt;/code&gt; attribute (opens new window)&lt;/a&gt; be used. Scoping could be through &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS modules (opens new window)&lt;/a&gt;, a class-based strategy such as &lt;a href=&quot;http://getbem.com/&quot;&gt;BEM (opens new window)&lt;/a&gt;, or another library/convention.</source>
          <target state="translated">これは、&lt;a href=&quot;../guide/single-file-component&quot;&gt;単一ファイルのコンポーネントに&lt;/a&gt;のみ関係します。&lt;a href=&quot;https://vue-loader.vuejs.org/en/features/scoped-css.html&quot;&gt; &lt;code&gt;scoped&lt;/code&gt; &lt;/a&gt;属性（新しいウィンドウを開く）を使用する必要&lt;em&gt;は&lt;/em&gt;ありませ&lt;em&gt;ん&lt;/em&gt;。スコープは、&lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSSモジュール（新しいウィンドウを開く）&lt;/a&gt;、&lt;a href=&quot;http://getbem.com/&quot;&gt;BEM（新しいウィンドウを開く）&lt;/a&gt;などのクラスベースの戦略、または別のライブラリ/コンベンションを介して行うことができます。</target>
        </trans-unit>
        <trans-unit id="6ff9fb25dfd7792976ece7fcf3da5a64a5e24732" translate="yes" xml:space="preserve">
          <source>This is only relevant for &lt;a href=&quot;../guide/single-file-components&quot;&gt;single-file components&lt;/a&gt;. It does &lt;em&gt;not&lt;/em&gt; require that the &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/scoped-css.html&quot;&gt;&lt;code&gt;scoped&lt;/code&gt; attribute&lt;/a&gt; be used. Scoping could be through &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS modules&lt;/a&gt;, a class-based strategy such as &lt;a href=&quot;http://getbem.com/&quot;&gt;BEM&lt;/a&gt;, or another library/convention.</source>
          <target state="translated">これは、&lt;a href=&quot;../guide/single-file-components&quot;&gt;単一ファイルのコンポーネントに&lt;/a&gt;のみ関連します。&lt;a href=&quot;https://vue-loader.vuejs.org/en/features/scoped-css.html&quot;&gt; &lt;code&gt;scoped&lt;/code&gt; &lt;/a&gt;属性を使用する必要&lt;em&gt;は&lt;/em&gt;ありませ&lt;em&gt;ん&lt;/em&gt;。スコーピングは、&lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSSモジュール&lt;/a&gt;、&lt;a href=&quot;http://getbem.com/&quot;&gt;BEM&lt;/a&gt;などのクラスベースの戦略、または別のライブラリ/コンベンションを通じて行うことができます。</target>
        </trans-unit>
        <trans-unit id="e3ecbb65364f0fdf669d68bae076b4de3385cb21" translate="yes" xml:space="preserve">
          <source>This is our starting point, except it's not working yet because our &lt;code&gt;repositories&lt;/code&gt; variable is not reactive. This means from a user's perspective, the repository list would remain empty. Let's fix that!</source>
          <target state="translated">これが出発点ですが、 &lt;code&gt;repositories&lt;/code&gt; 変数が反応しないためにまだ機能していません。これは、ユーザーの観点からは、リポジトリリストは空のままであることを意味します。それを直そう！</target>
        </trans-unit>
        <trans-unit id="dc711e31ffaf8ca030cc8750019aa32c295521fa" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;mixins&lt;/code&gt;.</source>
          <target state="translated">これは &lt;code&gt;mixins&lt;/code&gt; 似ています。</target>
        </trans-unit>
        <trans-unit id="55d606ea96e61ab331639ff4a07074c626da1c5c" translate="yes" xml:space="preserve">
          <source>This is something to be cautious of.</source>
          <target state="translated">これは気をつけなければならないことです。</target>
        </trans-unit>
        <trans-unit id="a1427909eab695a82c73616bf6ca58eaea604e27" translate="yes" xml:space="preserve">
          <source>This is something we do not recommend. Use at your own risk.</source>
          <target state="translated">お勧めできないものです。自己責任でご利用ください。</target>
        </trans-unit>
        <trans-unit id="88701949f327d90fdaf4b1fc05d4c2989b12c90a" translate="yes" xml:space="preserve">
          <source>This is the &lt;strong&gt;alias&lt;/strong&gt; of the global &lt;code&gt;Vue.delete&lt;/code&gt;.</source>
          <target state="translated">これは、グローバル &lt;code&gt;Vue.delete&lt;/code&gt; の&lt;strong&gt;エイリアス&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="7cdad8ed28d3f01ce5f9bf60ef04514b89cb1a36" translate="yes" xml:space="preserve">
          <source>This is the &lt;strong&gt;alias&lt;/strong&gt; of the global &lt;code&gt;Vue.set&lt;/code&gt;.</source>
          <target state="translated">これは、グローバル &lt;code&gt;Vue.set&lt;/code&gt; の&lt;strong&gt;エイリアス&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="834201b2fb84fb7b9e921e1c6e4ca406e0641f68" translate="yes" xml:space="preserve">
          <source>This is the cost of going lower-level, but it also gives you much more control over the interaction details compared to &lt;code&gt;v-model&lt;/code&gt;.</source>
          <target state="translated">これは、低レベルになるためのコストですが、 &lt;code&gt;v-model&lt;/code&gt; と比較して、相互作用の詳細をはるかに制御することもできます。</target>
        </trans-unit>
        <trans-unit id="3e3405a7d34055c0dba177a68cd0d783f73f679e" translate="yes" xml:space="preserve">
          <source>This is the default order we recommend for component options. They&amp;rsquo;re split into categories, so you&amp;rsquo;ll know where to add custom attributes and directives.</source>
          <target state="translated">これは、コンポーネントオプションに推奨されるデフォルトの順序です。それらはカテゴリに分割されているので、カスタム属性とディレクティブを追加する場所がわかります。</target>
        </trans-unit>
        <trans-unit id="c0efd0e005041f4d6aacd45e88dd9d81bd95f535" translate="yes" xml:space="preserve">
          <source>This is the default order we recommend for component options. They&amp;rsquo;re split into categories, so you&amp;rsquo;ll know where to add new properties from plugins.</source>
          <target state="translated">これは、コンポーネントオプションに推奨されるデフォルトの順序です。それらはカテゴリに分割されているので、プラグインから新しいプロパティを追加する場所がわかります。</target>
        </trans-unit>
        <trans-unit id="7a7f1cb949f47a835f88db5681466149b0c54598" translate="yes" xml:space="preserve">
          <source>This is the default order we recommend for component options. They're split into categories, so you'll know where to add custom attributes and directives.</source>
          <target state="translated">これは、私たちがコンポーネントオプションに推奨するデフォルトの順序です。カテゴリに分割されているので、どこにカスタム属性やディレクティブを追加すればいいのかがわかります。</target>
        </trans-unit>
        <trans-unit id="854f223c43426961a4fb3c1457dda5eadb68ad78" translate="yes" xml:space="preserve">
          <source>This is the default order we recommend for component options. They're split into categories, so you'll know where to add new properties from plugins.</source>
          <target state="translated">これは、私たちが推奨するコンポーネントオプションのデフォルトの順序です。カテゴリに分かれているので、プラグインから新しいプロパティを追加する場所がわかります。</target>
        </trans-unit>
        <trans-unit id="c10f048c28db476791d645c8e86e33a10cf5fe82" translate="yes" xml:space="preserve">
          <source>This is the official style guide for Vue-specific code. If you use Vue in a project, it&amp;rsquo;s a great reference to avoid errors, bikeshedding, and anti-patterns. However, we don&amp;rsquo;t believe that any style guide is ideal for all teams or projects, so mindful deviations are encouraged based on past experience, the surrounding tech stack, and personal values.</source>
          <target state="translated">これは、Vue固有のコードの公式スタイルガイドです。プロジェクトでVueを使用する場合、エラー、バイクシェディング、アンチパターンを回避するための優れたリファレンスです。ただし、スタイルガイドがすべてのチームまたはプロジェクトに理想的であるとは考えていないため、過去の経験、周囲の技術スタック、および個人的な価値観に基づいて、注意深く逸脱することが推奨されます。</target>
        </trans-unit>
        <trans-unit id="260db489520475eb4d9d940e59e1b8c6d90f9b1c" translate="yes" xml:space="preserve">
          <source>This is the official style guide for Vue-specific code. If you use Vue in a project, it's a great reference to avoid errors, bikeshedding, and anti-patterns. However, we don't believe that any style guide is ideal for all teams or projects, so mindful deviations are encouraged based on past experience, the surrounding tech stack, and personal values.</source>
          <target state="translated">Vue特有のコードの公式スタイルガイドです。プロジェクトで Vue を使用する場合、エラーやバイシェディング、アンチパターンを回避するための参考になります。ただし、どのスタイル ガイドもすべてのチームやプロジェクトにとって理想的なものではないと考えているので、過去の経験や周囲の技術スタック、個人的な価値観に基づいて慎重に逸脱することが推奨されます。</target>
        </trans-unit>
        <trans-unit id="48dc851eaa2d4a0946dac12cbc41fef4c40d2c4e" translate="yes" xml:space="preserve">
          <source>This is the very essence of Vue's reactivity system. When you return an object from &lt;code&gt;data()&lt;/code&gt; in a component, it is internally made reactive by &lt;code&gt;reactive()&lt;/code&gt;. The template is compiled into a &lt;a href=&quot;render-function&quot;&gt;render function&lt;/a&gt; that makes use of these reactive properties.</source>
          <target state="translated">これがVueの反応性システムの本質です。コンポーネントの &lt;code&gt;data()&lt;/code&gt; からオブジェクトを返すと、 &lt;code&gt;reactive()&lt;/code&gt; によって内部的にリアクティブになります。テンプレートは、これらのリアクティブプロパティを利用&lt;a href=&quot;render-function&quot;&gt;するレンダリング関数に&lt;/a&gt;コンパイルされます。</target>
        </trans-unit>
        <trans-unit id="1dae6e4af70b8947160604a318d2c8290aa71604" translate="yes" xml:space="preserve">
          <source>This is what an example looks like in action:</source>
          <target state="translated">このような例は、実際に行動してみるとわかります。</target>
        </trans-unit>
        <trans-unit id="86ed47f21689beea18108b3f71c70d7446716f52" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t always desirable though, so Vue offers a way for you to say, &amp;ldquo;These two elements are completely separate - don&amp;rsquo;t re-use them.&amp;rdquo; Add a &lt;code&gt;key&lt;/code&gt; attribute with unique values:</source>
          <target state="translated">ただし、これが常に望ましいとは限らないため、Vueは「これらの2つの要素は完全に分離されているので、再利用しないでください」と言う方法を提供します。一意の値を持つ &lt;code&gt;key&lt;/code&gt; 属性を追加します。</target>
        </trans-unit>
        <trans-unit id="b6310262b7c83dfb01581e044a227be964f646d9" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t recommended, as it results in:</source>
          <target state="translated">次のような結果になるため、これはお勧めできません。</target>
        </trans-unit>
        <trans-unit id="82d553ff76c7a0d3860ad174bd983d0f26df9bc2" translate="yes" xml:space="preserve">
          <source>This isn't recommended, as it results in:</source>
          <target state="translated">これは結果的にお勧めできません。</target>
        </trans-unit>
        <trans-unit id="6f6cde4441aa77022965104cf28c119fa672b5f2" translate="yes" xml:space="preserve">
          <source>This makes it possible to use &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; on multiple conditional children:</source>
          <target state="translated">これにより、複数の条件付き子で &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; を使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="a6a89a509e1a13dc277b1946145eb663eb6a0bc1" translate="yes" xml:space="preserve">
          <source>This makes overriding internal styles easier, with human-readable class names that don&amp;rsquo;t have too high specificity, but are still very unlikely to result in a conflict.</source>
          <target state="translated">これにより、特定性が高すぎない人間が読めるクラス名を使用して、内部スタイルのオーバーライドが容易になりますが、依然として競合が発生する可能性はほとんどありません。</target>
        </trans-unit>
        <trans-unit id="6039ba72679e27c3de3fe59517757185e2ef8639" translate="yes" xml:space="preserve">
          <source>This makes overriding internal styles easier, with human-readable class names that don't have too high specificity, but are still very unlikely to result in a conflict.</source>
          <target state="translated">これにより、内部スタイルのオーバーライドが容易になり、人間が読めるようなクラス名であれば、あまり特異性は高くありませんが、コンフリクトが発生する可能性は非常に低くなります。</target>
        </trans-unit>
        <trans-unit id="ed5bca688970af00ecf6916734fc1be51e2996ec" translate="yes" xml:space="preserve">
          <source>This may be useful when you want to, for example, programmatically focus this input on component mount:</source>
          <target state="translated">これは、例えば、プログラム的にこの入力をコンポーネントのマウントにフォーカスしたい場合などに便利です。</target>
        </trans-unit>
        <trans-unit id="7dbccff00d4246ffaab0d554ac15f4da6d514888" translate="yes" xml:space="preserve">
          <source>This means you &lt;strong&gt;can&lt;/strong&gt; install/import these deps individually without ending up with different instances of these dependencies, but you must make sure they all resolve to the same version.</source>
          <target state="translated">つまり、これらの依存関係のインスタンスが異なることなく、これらのDepを個別にインストール/インポート&lt;strong&gt;でき&lt;/strong&gt;ます&lt;strong&gt;が&lt;/strong&gt;、すべてが同じバージョンに解決されることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="4df7db840cfd9d37352281ab6a0b379ab7ce5543" translate="yes" xml:space="preserve">
          <source>This method has to be called before calling &lt;code&gt;new Vue()&lt;/code&gt;</source>
          <target state="translated">このメソッドは、 &lt;code&gt;new Vue()&lt;/code&gt; 呼び出す前に呼び出す必要があります</target>
        </trans-unit>
        <trans-unit id="d0ddd876bb6fb1b94f32ad08f1b3a4e6d7b7cb98" translate="yes" xml:space="preserve">
          <source>This method should not be confused with the &lt;a href=&quot;options-composition#provide-inject&quot;&gt;provide component option&lt;/a&gt; or the &lt;a href=&quot;composition-api#provide-inject&quot;&gt;provide function&lt;/a&gt; in the composition API. While those are also part of the same &lt;code&gt;provide&lt;/code&gt;/&lt;code&gt;inject&lt;/code&gt; mechanism, they are used to configure values provided by a component rather than an application.</source>
          <target state="translated">このメソッドを、compositionAPIのprovidecomponent&lt;a href=&quot;options-composition#provide-inject&quot;&gt;オプション&lt;/a&gt;または&lt;a href=&quot;composition-api#provide-inject&quot;&gt;provide関数&lt;/a&gt;と混同しないでください。これらも同じ &lt;code&gt;provide&lt;/code&gt; / &lt;code&gt;inject&lt;/code&gt; メカニズムの一部ですが、アプリケーションではなくコンポーネントによって提供される値を構成するために使用されます。</target>
        </trans-unit>
        <trans-unit id="fbaf50c98606e0673b924b093900524e24db8aeb" translate="yes" xml:space="preserve">
          <source>This might be helpful when we have an HTML element with &lt;code&gt;change&lt;/code&gt; event as a root element of &lt;code&gt;date-picker&lt;/code&gt;.</source>
          <target state="translated">これは、 &lt;code&gt;date-picker&lt;/code&gt; のルート要素として &lt;code&gt;change&lt;/code&gt; イベントを持つHTML要素がある場合に役立つ可能性があります。</target>
        </trans-unit>
        <trans-unit id="b90aee8ca6c8b63ccbcb1d903920d255bfac3961" translate="yes" xml:space="preserve">
          <source>This might seem like magic, but under the hood, Vue is using an animation technique called &lt;a href=&quot;https://aerotwist.com/blog/flip-your-animations/&quot;&gt;FLIP (opens new window)&lt;/a&gt; to smoothly transition elements from their old position to their new position using transforms.</source>
          <target state="translated">これは魔法のように思えるかもしれませんが、内部では、Vueは&lt;a href=&quot;https://aerotwist.com/blog/flip-your-animations/&quot;&gt;FLIP（新しいウィンドウを開く）&lt;/a&gt;と呼ばれるアニメーション技法を使用して、変換を使用して要素を古い位置から新しい位置にスムーズに移行しています。</target>
        </trans-unit>
        <trans-unit id="e730d7896b6b323bd3f0e7b2da6d31281de59f5f" translate="yes" xml:space="preserve">
          <source>This might seem like magic, but under the hood, Vue is using an animation technique called &lt;a href=&quot;https://aerotwist.com/blog/flip-your-animations/&quot;&gt;FLIP&lt;/a&gt; to smoothly transition elements from their old position to their new position using transforms.</source>
          <target state="translated">これは魔法のように思えるかもしれませんが、内部では、Vueは&lt;a href=&quot;https://aerotwist.com/blog/flip-your-animations/&quot;&gt;FLIP&lt;/a&gt;と呼ばれるアニメーション技術を使用して、変換を使用して要素を元の位置から新しい位置にスムーズに移行します。</target>
        </trans-unit>
        <trans-unit id="ab8d674415749229910a074d53ea9c4b24dec081" translate="yes" xml:space="preserve">
          <source>This not only documents your component, but will also warn users in the browser&amp;rsquo;s JavaScript console if they pass the wrong type. You&amp;rsquo;ll learn much more about &lt;a href=&quot;#Prop-Validation&quot;&gt;type checks and other prop validations&lt;/a&gt; further down this page.</source>
          <target state="translated">これはコンポーネントを文書化するだけでなく、ブラウザのJavaScriptコンソールで間違った型を渡した場合に警告を表示します。このページのさらに下の方で、&lt;a href=&quot;#Prop-Validation&quot;&gt;型チェックとその他のプロップ検証&lt;/a&gt;について詳しく学びます。</target>
        </trans-unit>
        <trans-unit id="2eede98c99888e9e8fb70ceb48eb9cdf213e42e5" translate="yes" xml:space="preserve">
          <source>This not only documents your component, but will also warn users in the browser's JavaScript console if they pass the wrong type. You'll learn much more about &lt;a href=&quot;#prop-validation&quot;&gt;type checks and other prop validations&lt;/a&gt; further down this page.</source>
          <target state="translated">これは、コンポーネントを文書化するだけでなく、ユーザーが間違ったタイプを渡した場合にブラウザーのJavaScriptコンソールでユーザーに警告します。このページのさらに下で&lt;a href=&quot;#prop-validation&quot;&gt;、タイプチェックやその他の小道具の検証&lt;/a&gt;について詳しく学びます。</target>
        </trans-unit>
        <trans-unit id="2de9e673c8caad296afdff84c173090ed0754386" translate="yes" xml:space="preserve">
          <source>This option is no longer necessary now that Vue&amp;rsquo;s transition system has explicit &lt;a href=&quot;transitions#Transitions-on-Initial-Render&quot;&gt;&lt;code&gt;appear&lt;/code&gt; transition control&lt;/a&gt;.</source>
          <target state="translated">Vueのトランジションシステムに明示的な&lt;a href=&quot;transitions#Transitions-on-Initial-Render&quot;&gt;トランジションコントロール&lt;/a&gt; &lt;code&gt;appear&lt;/code&gt; なったため、このオプションは不要になりました。</target>
        </trans-unit>
        <trans-unit id="dda8e2bba6581f8fe39ba87ae1f467605782e672" translate="yes" xml:space="preserve">
          <source>This page applies only to Vue 2.x and below, and assumes you've already read the &lt;a href=&quot;reactivity&quot;&gt;Reactivity Section&lt;/a&gt;. Please read that section first.</source>
          <target state="translated">このページはVue2.x以下にのみ適用され、&lt;a href=&quot;reactivity&quot;&gt;反応性セクションを&lt;/a&gt;すでに読んでいることを前提としています。最初にそのセクションをお読みください。</target>
        </trans-unit>
        <trans-unit id="550e8beaeefdf603cb020b147e312a77724aa11b" translate="yes" xml:space="preserve">
          <source>This page assumes you&amp;rsquo;ve already read the &lt;a href=&quot;components&quot;&gt;Components Basics&lt;/a&gt;. Read that first if you are new to components.</source>
          <target state="translated">このページは、&lt;a href=&quot;components&quot;&gt;コンポーネントの基本を&lt;/a&gt;既に読んでいることを前提としています。コンポーネントを初めて使用する場合は、まずそれをお読みください。</target>
        </trans-unit>
        <trans-unit id="2f257c4f8981d39250383dd3af755f3faa35ddba" translate="yes" xml:space="preserve">
          <source>This page assumes you've already read the &lt;a href=&quot;component-basics&quot;&gt;Components Basics&lt;/a&gt;. Read that first if you are new to components.</source>
          <target state="translated">このページは、&lt;a href=&quot;component-basics&quot;&gt;コンポーネントの基本を&lt;/a&gt;すでに読んでいることを前提としています。コンポーネントを初めて使用する場合は、最初にそれをお読みください。</target>
        </trans-unit>
        <trans-unit id="16e672f7510e855eb83e9a420fd1aab887fa1937" translate="yes" xml:space="preserve">
          <source>This page is not required reading in order to learn how to use Vue well, but it provides more information, should you be curious how rendering works under the hood.</source>
          <target state="translated">このページは、Vue の使い方を学ぶための必須の読み物ではありませんが、レンダリングがフードの下でどのように動作するのか興味がある方のために、より多くの情報を提供しています。</target>
        </trans-unit>
        <trans-unit id="7e9eda44994bfc72fde4d3d3f83007e54ed25512" translate="yes" xml:space="preserve">
          <source>This pair of options are used together to allow an ancestor component to serve as a dependency injector for all its descendants, regardless of how deep the component hierarchy is, as long as they are in the same parent chain. If you are familiar with React, this is very similar to React&amp;rsquo;s context feature.</source>
          <target state="translated">このペアのオプションを一緒に使用すると、コンポーネントが同じ親チェーン内にある限り、コンポーネント階層の深さに関係なく、祖先コンポーネントがそのすべての子孫の依存関係インジェクターとして機能できます。Reactに精通している場合、これはReactのコンテキスト機能とよく似ています。</target>
        </trans-unit>
        <trans-unit id="2a14bf9014246214857ff883acbf4909435d0e01" translate="yes" xml:space="preserve">
          <source>This pair of options are used together to allow an ancestor component to serve as a dependency injector for all its descendants, regardless of how deep the component hierarchy is, as long as they are in the same parent chain. If you are familiar with React, this is very similar to React's &lt;code&gt;context&lt;/code&gt; feature.</source>
          <target state="translated">このオプションのペアは、コンポーネント階層の深さに関係なく、同じ親チェーン内にある限り、祖先コンポーネントがすべての子孫の依存性注入として機能できるようにするために一緒に使用されます。Reactに精通している場合、これはReactの &lt;code&gt;context&lt;/code&gt; 機能と非常によく似ています。</target>
        </trans-unit>
        <trans-unit id="34bf50ff4f4ae88a62c8e8c96ac99d754acfb794" translate="yes" xml:space="preserve">
          <source>This passes each property in the &lt;code&gt;doc&lt;/code&gt; object (e.g. &lt;code&gt;title&lt;/code&gt;) as an individual prop, then adds &lt;code&gt;v-on&lt;/code&gt; update listeners for each one.</source>
          <target state="translated">これにより、 &lt;code&gt;doc&lt;/code&gt; オブジェクト（例： &lt;code&gt;title&lt;/code&gt; ）の各プロパティが個別のプロパティとして渡され、それぞれに &lt;code&gt;v-on&lt;/code&gt; 更新リスナーが追加されます。</target>
        </trans-unit>
        <trans-unit id="557b609a0af0bc72cafc6f2a31afd4730c396e50" translate="yes" xml:space="preserve">
          <source>This pattern allows you to use base components more like raw HTML elements, without having to care about which element is actually at its root:</source>
          <target state="translated">このパターンでは、どの要素が実際にそのルートにあるかを気にすることなく、より生のHTML要素のようにベースコンポーネントを使用することができます。</target>
        </trans-unit>
        <trans-unit id="bbad2c9cdad7376672474e37751ceab152ea3ed1" translate="yes" xml:space="preserve">
          <source>This pattern can serve as a replacement for &lt;code&gt;$dispatch&lt;/code&gt; and &lt;code&gt;$broadcast&lt;/code&gt; in simple scenarios, but for more complex cases, it&amp;rsquo;s recommended to use a dedicated state management layer such as &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt;.</source>
          <target state="translated">このパターンは、単純なシナリオでは &lt;code&gt;$dispatch&lt;/code&gt; と &lt;code&gt;$broadcast&lt;/code&gt; 代わりとして使用できますが、より複雑なケースでは、&lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt;などの専用の状態管理レイヤーを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="3bcacf748b9af6a54554db3c2d36be4ed02362a9" translate="yes" xml:space="preserve">
          <source>This section aims to provide guidance to navigating the testing ecosystem and choosing the right tools for your Vue application or component library.</source>
          <target state="translated">このセクションでは、テストのエコシステムをナビゲートし、Vue アプリケーションやコンポーネント ライブラリに適したツールを選択するためのガイダンスを提供することを目的としています。</target>
        </trans-unit>
        <trans-unit id="5586c0722db91f034d221a64e55d5829bf071baf" translate="yes" xml:space="preserve">
          <source>This section assumes knowledge of &lt;a href=&quot;component-basics&quot;&gt;Components&lt;/a&gt;. Feel free to skip it and come back later.</source>
          <target state="translated">このセクションは、&lt;a href=&quot;component-basics&quot;&gt;コンポーネントの&lt;/a&gt;知識があることを前提としています。スキップして後で戻ってきてください。</target>
        </trans-unit>
        <trans-unit id="c0c88f592f793e32dd9e76308d4a6ba8bd42fb51" translate="yes" xml:space="preserve">
          <source>This section assumes knowledge of &lt;a href=&quot;component-basics&quot;&gt;Vue Components&lt;/a&gt;. Feel free to skip it and come back later.</source>
          <target state="translated">このセクションは、&lt;a href=&quot;component-basics&quot;&gt;Vueコンポーネントの&lt;/a&gt;知識があることを前提としています。スキップして後で戻ってきてください。</target>
        </trans-unit>
        <trans-unit id="9cba143bcc5fd060440f37e2cac40aebf229b0f3" translate="yes" xml:space="preserve">
          <source>This section assumes knowledge of &lt;a href=&quot;components&quot;&gt;Components&lt;/a&gt;. Feel free to skip it and come back later.</source>
          <target state="translated">このセクションは、&lt;a href=&quot;components&quot;&gt;コンポーネント&lt;/a&gt;に関する知識があることを前提としています。スキップして後で戻ってください。</target>
        </trans-unit>
        <trans-unit id="d97537d143e717763c891d635c44d8f795dd0407" translate="yes" xml:space="preserve">
          <source>This section assumes knowledge of &lt;a href=&quot;components&quot;&gt;Vue Components&lt;/a&gt;. Feel free to skip it and come back later.</source>
          <target state="translated">このセクションは、&lt;a href=&quot;components&quot;&gt;Vueコンポーネントの&lt;/a&gt;知識があることを前提としています。スキップして後で戻ってください。</target>
        </trans-unit>
        <trans-unit id="fb5b15406f75921e192409d91ff1b17d27fd994a" translate="yes" xml:space="preserve">
          <source>This section contains the search functionality for the application</source>
          <target state="translated">このセクションでは、アプリケーションの検索機能</target>
        </trans-unit>
        <trans-unit id="4b3b7709525d03239edb056d669680878e9735ae" translate="yes" xml:space="preserve">
          <source>This section uses &lt;a href=&quot;../guide/single-file-component&quot;&gt;single-file component&lt;/a&gt; syntax for code examples</source>
          <target state="translated">このセクションでは、コード例に&lt;a href=&quot;../guide/single-file-component&quot;&gt;単一ファイルのコンポーネント&lt;/a&gt;構文を使用します</target>
        </trans-unit>
        <trans-unit id="bd61b2e32ea112a3e4dcdeb333fabe9dfc18a2f7" translate="yes" xml:space="preserve">
          <source>This section uses &lt;a href=&quot;single-file-component&quot;&gt;single-file component&lt;/a&gt; syntax for code examples</source>
          <target state="translated">このセクションでは、コード例に&lt;a href=&quot;single-file-component&quot;&gt;単一ファイルのコンポーネント&lt;/a&gt;構文を使用します</target>
        </trans-unit>
        <trans-unit id="f775635fcd735f353cd0996d158644d66269c8fe" translate="yes" xml:space="preserve">
          <source>This solves the inconsistency between &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; and makes outputting &lt;code&gt;aria-*&lt;/code&gt; attributes easier</source>
          <target state="translated">これにより、 &lt;code&gt;true&lt;/code&gt; と &lt;code&gt;false&lt;/code&gt; の間の不整合が解決され、 &lt;code&gt;aria-*&lt;/code&gt; 属性の出力が容易になります。</target>
        </trans-unit>
        <trans-unit id="df51509bdf6631bdbd029391b7a92d14a5f11a4f" translate="yes" xml:space="preserve">
          <source>This solves the inconsistency between normal non-boolean attributes and &amp;ldquo;enumerated attributes&amp;rdquo;</source>
          <target state="translated">これにより、通常の非ブール属性と「列挙された属性」の間の不整合が解決されます。</target>
        </trans-unit>
        <trans-unit id="d34f69dcd5eb3d4acee6efe3176754e358fc43d6" translate="yes" xml:space="preserve">
          <source>This template doesn't feel great. It's not only verbose, but we're duplicating &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; for every heading level. And when we add the anchor element, we have to again duplicate it in every &lt;code&gt;v-if/v-else-if&lt;/code&gt; branch.</source>
          <target state="translated">このテンプレートは気分が良くありません。冗長であるだけでなく、すべての見出しレベルで &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; を複製しています。また、アンカー要素を追加するときは、すべての &lt;code&gt;v-if/v-else-if&lt;/code&gt; ブランチで再度複製する必要があります。</target>
        </trans-unit>
        <trans-unit id="1d2671e140fbe7037587dd494d52b8c4c16af6fa" translate="yes" xml:space="preserve">
          <source>This term comes up in programming quite a bit these days, but what do people mean when they say it? Reactivity is a programming paradigm that allows us to adjust to changes in a declarative manner. The canonical example that people usually show, because it&amp;rsquo;s a great one, is an Excel spreadsheet.</source>
          <target state="translated">この用語は最近プログラミングでかなり出てきますが、人々がそれを言うときはどういう意味ですか？反応性は、宣言的な方法で変更に適応できるようにするプログラミングパラダイムです。人々が通常示す標準的な例は、それが素晴らしいものであるため、Excelスプレッドシートです。</target>
        </trans-unit>
        <trans-unit id="da345bd2efafe0aab297aeb02da75f10e9617d3e" translate="yes" xml:space="preserve">
          <source>This will allow you to check all the events that a component emits and optionally &lt;a href=&quot;component-custom-events#validate-emitted-events&quot;&gt;validate them&lt;/a&gt;.</source>
          <target state="translated">これにより、コンポーネントが発行するすべてのイベントを確認し、オプションで&lt;a href=&quot;component-custom-events#validate-emitted-events&quot;&gt;それらを検証できます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="95cf660900b36fb7082d6da4112e034f7880c495" translate="yes" xml:space="preserve">
          <source>This will always apply &lt;code&gt;errorClass&lt;/code&gt;, but &lt;code&gt;activeClass&lt;/code&gt; will only be applied when &lt;code&gt;isActive&lt;/code&gt; is truthy.</source>
          <target state="translated">これは常に &lt;code&gt;errorClass&lt;/code&gt; を適用しますが、 &lt;code&gt;activeClass&lt;/code&gt; は &lt;code&gt;isActive&lt;/code&gt; がtrueの場合にのみ適用されます。</target>
        </trans-unit>
        <trans-unit id="a4b9ed84f139c1b6b2a23ad5d5ae02e8e0087d2f" translate="yes" xml:space="preserve">
          <source>This will always apply &lt;code&gt;errorClass&lt;/code&gt;, but will only apply &lt;code&gt;activeClass&lt;/code&gt; when &lt;code&gt;isActive&lt;/code&gt; is truthy.</source>
          <target state="translated">これは常に &lt;code&gt;errorClass&lt;/code&gt; を適用しますが、 &lt;code&gt;isActive&lt;/code&gt; がtrueの場合にのみ &lt;code&gt;activeClass&lt;/code&gt; を適用します。</target>
        </trans-unit>
        <trans-unit id="c7c41413208280e0438efd8becdf4788ac79009e" translate="yes" xml:space="preserve">
          <source>This will be a new top-level option in the Vue CLI config.</source>
          <target state="translated">これは、Vue CLI 構成の新しいトップレベルのオプションになります。</target>
        </trans-unit>
        <trans-unit id="5821e5689d374e0b8784257f0965bfa2f10466c3" translate="yes" xml:space="preserve">
          <source>This will lead to issues when using components with elements that have such restrictions. For example:</source>
          <target state="translated">これにより、このような制限がある要素を持つコンポーネントを使用する場合に問題が発生します。例えば</target>
        </trans-unit>
        <trans-unit id="049aecf164473e3032284f57bc6b9b045f4cb629" translate="yes" xml:space="preserve">
          <source>This will no longer work:</source>
          <target state="translated">これはもう通用しません。</target>
        </trans-unit>
        <trans-unit id="2666e307d1675c13748bab8a1f1fd08d861b57f6" translate="yes" xml:space="preserve">
          <source>This will only render the last value in the array which the browser supports. In this example, it will render &lt;code&gt;display: flex&lt;/code&gt; for browsers that support the unprefixed version of flexbox.</source>
          <target state="translated">これは、ブラウザがサポートする配列の最後の値のみをレンダリングします。この例では、プレフィックスのないバージョンのflexboxをサポートするブラウザー用に &lt;code&gt;display: flex&lt;/code&gt; がdisplay：flexをレンダリングします。</target>
        </trans-unit>
        <trans-unit id="5c6bceae6f976ba05296ec0765f401478684d036" translate="yes" xml:space="preserve">
          <source>This will render the same result. We can also bind to a &lt;a href=&quot;computed&quot;&gt;computed property&lt;/a&gt; that returns an object. This is a common and powerful pattern:</source>
          <target state="translated">これは同じ結果をレンダリングします。オブジェクトを返す&lt;a href=&quot;computed&quot;&gt;計算されたプロパティに&lt;/a&gt;バインドすることもできます。これは一般的で強力なパターンです。</target>
        </trans-unit>
        <trans-unit id="d7b864922bd15ed63c01468766857939d0bedd4b" translate="yes" xml:space="preserve">
          <source>This will tell webpack to treat the Vue module as an external library and not bundle it.</source>
          <target state="translated">これは webpack に、Vue モジュールを外部ライブラリとして扱い、バンドルしないように指示します。</target>
        </trans-unit>
        <trans-unit id="526567b8517e99354a6d4a7125884ed748c75aee" translate="yes" xml:space="preserve">
          <source>This works well, but there&amp;rsquo;s one caveat to be aware of:</source>
          <target state="translated">これは適切に機能しますが、注意する点が1つあります。</target>
        </trans-unit>
        <trans-unit id="37f50c9fec60cfa63ed8f8710f68526faca79202" translate="yes" xml:space="preserve">
          <source>This would pin the element 200px from the top of the page. But what happens if we run into a scenario when we need to pin the element from the left, instead of the top? Here&amp;rsquo;s where a dynamic argument that can be updated per component instance comes in very handy:</source>
          <target state="translated">これにより、要素がページの上部から200pxに固定されます。しかし、要素を上ではなく左から固定する必要があるシナリオに遭遇した場合はどうなりますか？ここで、コンポーネントインスタンスごとに更新できる動的引数が非常に役立ちます。</target>
        </trans-unit>
        <trans-unit id="3e3f2385e5295eb0996806c6e44de1cd3bf29c86" translate="yes" xml:space="preserve">
          <source>This would pin the element 200px from the top of the page. But what happens if we run into a scenario when we need to pin the element from the left, instead of the top? Here's where a dynamic argument that can be updated per component instance comes in very handy:</source>
          <target state="translated">これにより、ページの上から200pxの位置に要素を固定することができます。しかし、要素を上からではなく左から固定する必要がある場合はどうなるでしょうか?ここで、コンポーネントのインスタンスごとに更新できる動的な引数が非常に便利です。</target>
        </trans-unit>
        <trans-unit id="99af979b8150c4855a484c40f48bb6c2a78e8cf7" translate="yes" xml:space="preserve">
          <source>Though the &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; component can be wonderful for components entering and leaving, you can also activate an animation without mounting a component, by adding a conditional class.</source>
          <target state="translated">けれども &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; コンポーネントは、コンポーネントが入ると残すための素晴らしいことができ、あなたはまた、条件付きのクラスを追加することで、部品を実装せずにアニメーションを有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="a9de901ca4a37c13bd513536f6104058a8ebeab4" translate="yes" xml:space="preserve">
          <source>Though this provided some convenience in terms of root instances having a shared state, this has led to confusion due to the fact that its only possible on the root instance.</source>
          <target state="translated">これにより、ルートインスタンスが共有状態を持つという点では便利になりましたが、ルートインスタンス上でのみ可能であるという事実のために混乱を招いていました。</target>
        </trans-unit>
        <trans-unit id="9e255605141c6fd6ae34a1f00f4a710389219fe6" translate="yes" xml:space="preserve">
          <source>Though you can achieve great effects for simple animation with the two handles the cubic-bezier ease offers, JavaScript allows multiple handles, and therefore, allows for much more variance.</source>
          <target state="translated">単純なアニメーションでも、3次ベジェのように2つのハンドルで大きな効果を得ることができますが、JavaScriptでは複数のハンドルを使用することができるため、より多くのバリエーションが可能になります。</target>
        </trans-unit>
        <trans-unit id="f3296891d857a3b88e24b3a8f562ed3941e52be8" translate="yes" xml:space="preserve">
          <source>Though you might have seen labels wrapping the input fields like this:</source>
          <target state="translated">このように入力フィールドにラベルが巻かれているのを見たことがあるかもしれませんが、このように入力フィールドにラベルが巻かれています。</target>
        </trans-unit>
        <trans-unit id="7071bdcdc5a765649d86527bc55dbc0b17011d91" translate="yes" xml:space="preserve">
          <source>Thus allowing the parent component to focus the input inside &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; with:</source>
          <target state="translated">したがって、親コンポーネントが &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; 内の入力にフォーカスできるようにします。</target>
        </trans-unit>
        <trans-unit id="39b83fd8c5087d08e03db371955b52edd99734c1" translate="yes" xml:space="preserve">
          <source>Tightly coupled component names</source>
          <target state="translated">緊密に結合されたコンポーネント名</target>
        </trans-unit>
        <trans-unit id="257e6044f44501278b17551ce75788f6ca913a8d" translate="yes" xml:space="preserve">
          <source>Tightly coupled component names &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">密結合コンポーネント名を&lt;sup&gt;強くお勧めします&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="098024dc5537ca3623978ac7c0a6140ce39062b8" translate="yes" xml:space="preserve">
          <source>Timing</source>
          <target state="translated">Timing</target>
        </trans-unit>
        <trans-unit id="40b635fbbc82098772ee7e3177e62a9c14ea2014" translate="yes" xml:space="preserve">
          <source>Tips, Callouts, Alerts, and Line Highlights</source>
          <target state="translated">ヒント、コールアウト、アラート、ラインハイライト</target>
        </trans-unit>
        <trans-unit id="881f5e312126d5e8ea790db899552b0144c3c571" translate="yes" xml:space="preserve">
          <source>To access component instance properties, we need to convert &lt;code&gt;provide&lt;/code&gt; to be a function returning an object</source>
          <target state="translated">コンポーネントインスタンスのプロパティにアクセスするには、 &lt;code&gt;provide&lt;/code&gt; をオブジェクトを返す関数に変換する必要があります</target>
        </trans-unit>
        <trans-unit id="e19f5499c85a1ceeb0b480c98eff4e4346929cd2" translate="yes" xml:space="preserve">
          <source>To add line highlighting to your code blocks, you need to append the line number in curly braces.</source>
          <target state="translated">コードブロックに行のハイライトを追加するには、中括弧で行番号を追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="4ddd888c6582ef9d6fa2ab28bf309c8d36b0be42" translate="yes" xml:space="preserve">
          <source>To add methods to a component instance we use the &lt;code&gt;methods&lt;/code&gt; option. This should be an object containing the desired methods:</source>
          <target state="translated">コンポーネントインスタンスにメソッドを追加するには、 &lt;code&gt;methods&lt;/code&gt; オプションを使用します。これは、目的のメソッドを含むオブジェクトである必要があります。</target>
        </trans-unit>
        <trans-unit id="20869228946fc9bfb3ec15b09cdff057ca44c507" translate="yes" xml:space="preserve">
          <source>To add reactivity between provided and injected values, we can use a &lt;a href=&quot;reactivity-fundamentals#creating-standalone-reactive-values-as-refs&quot;&gt;ref&lt;/a&gt; or &lt;a href=&quot;reactivity-fundamentals#declaring-reactive-state&quot;&gt;reactive&lt;/a&gt; when providing a value.</source>
          <target state="translated">提供された値と注入された値の間に反応性を追加するために、値を提供するときに&lt;a href=&quot;reactivity-fundamentals#creating-standalone-reactive-values-as-refs&quot;&gt;ref&lt;/a&gt;または&lt;a href=&quot;reactivity-fundamentals#declaring-reactive-state&quot;&gt;reactiveを&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="7f0cfd696ee7275a932682ace8d519ee632cc69c" translate="yes" xml:space="preserve">
          <source>To add validation, the event is assigned a function that receives the arguments passed to the &lt;code&gt;$emit&lt;/code&gt; call and returns a boolean to indicate whether the event is valid or not.</source>
          <target state="translated">検証を追加するために、イベントには、 &lt;code&gt;$emit&lt;/code&gt; 呼び出しに渡された引数を受け取り、イベントが有効かどうかを示すブール値を返す関数が割り当てられます。</target>
        </trans-unit>
        <trans-unit id="788042730e582de0e5c9cadbed06a9452fa7048a" translate="yes" xml:space="preserve">
          <source>To address these issues, we added a new way to organize code by logical concerns: the &lt;a href=&quot;composition-api-introduction&quot;&gt;Composition API&lt;/a&gt;.</source>
          <target state="translated">これらの問題に対処するために、論理的な懸念事項によってコードを整理する新しい方法、&lt;a href=&quot;composition-api-introduction&quot;&gt;CompositionAPI&lt;/a&gt;を追加しました。</target>
        </trans-unit>
        <trans-unit id="b8f6ddc9e83523ba73e6944910a55021c297893e" translate="yes" xml:space="preserve">
          <source>To address this problem, Vue provides &lt;strong&gt;event modifiers&lt;/strong&gt; for &lt;code&gt;v-on&lt;/code&gt;. Recall that modifiers are directive postfixes denoted by a dot.</source>
          <target state="translated">この問題に対処するために、Vueには &lt;code&gt;v-on&lt;/code&gt; の&lt;strong&gt;イベント修飾子&lt;/strong&gt;が用意されています。修飾子は、ドットで示されるディレクティブの接尾辞であることを思い出してください。</target>
        </trans-unit>
        <trans-unit id="1f82c84ad360cae69c196ca0363ef72d7d1df639" translate="yes" xml:space="preserve">
          <source>To also build &lt;code&gt;umd&lt;/code&gt; and &lt;code&gt;cjs&lt;/code&gt; modules we can simply add a few lines of configuration to our &lt;code&gt;rollup.config.js&lt;/code&gt; and &lt;code&gt;package.json&lt;/code&gt;</source>
          <target state="translated">また、ビルドするには &lt;code&gt;umd&lt;/code&gt; と &lt;code&gt;cjs&lt;/code&gt; 我々は単に私たちへの設定の数行を追加することができ、モジュール &lt;code&gt;rollup.config.js&lt;/code&gt; と &lt;code&gt;package.json&lt;/code&gt; を</target>
        </trans-unit>
        <trans-unit id="a6fbfda62f8c47b0cf26f2ea631c53bf263f1ecd" translate="yes" xml:space="preserve">
          <source>To also detect nested value changes inside Objects, you need to pass in &lt;code&gt;deep: true&lt;/code&gt; in the options argument. Note that you don&amp;rsquo;t need to do so to listen for Array mutations.</source>
          <target state="translated">オブジェクト内のネストされた値の変更も検出するには、オプションの引数に &lt;code&gt;deep: true&lt;/code&gt; を渡す必要があります。Arrayミューテーションをリッスンするためにそうする必要はないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="cce00248496d96a2067177aed26ff61ce35a2340" translate="yes" xml:space="preserve">
          <source>To also detect nested value changes inside Objects, you need to pass in &lt;code&gt;deep: true&lt;/code&gt; in the options argument. Note that you don't need to do so to listen for array mutations.</source>
          <target state="translated">オブジェクト内のネストされた値の変更も検出するには、options引数に &lt;code&gt;deep: true&lt;/code&gt; を渡す必要があります。配列の変異をリッスンするためにそうする必要はないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="b4e407d7b5fb83d759864567de67b6dc7262ee1c" translate="yes" xml:space="preserve">
          <source>To animate, by one definition, means to bring to life. Unfortunately, when designers create icons, logos, and mascots, they&amp;rsquo;re usually delivered as images or static SVGs. So although GitHub&amp;rsquo;s octocat, Twitter&amp;rsquo;s bird, and many other logos resemble living creatures, they don&amp;rsquo;t really seem alive.</source>
          <target state="translated">アニメーションとは、1つの定義では、命を吹き込むことを意味します。残念ながら、デザイナーがアイコン、ロゴ、マスコットを作成すると、通常は画像または静的SVGとして配信されます。したがって、GitHubのオクトキャット、Twitterの鳥、その他の多くのロゴは生き物に似ていますが、実際には生きているようには見えません。</target>
        </trans-unit>
        <trans-unit id="8a3a9f59e5420390dc20b2d39b4aad21d989a106" translate="yes" xml:space="preserve">
          <source>To animate, by one definition, means to bring to life. Unfortunately, when designers create icons, logos, and mascots, they're usually delivered as images or static SVGs. So although GitHub's octocat, Twitter's bird, and many other logos resemble living creatures, they don't really seem alive.</source>
          <target state="translated">アニメーション化とは、ある定義では「命を吹き込む」という意味です。しかし残念なことに、デザイナーがアイコンやロゴ、マスコットを作成する際には、通常は画像や静的な SVG で提供されます。GitHub のタコキャットや Twitter の鳥など、多くのロゴは生き物に似ていますが、実際には生きているようには見えません。</target>
        </trans-unit>
        <trans-unit id="49b12f0b2b03b56612ac89d3a0da0c957181b463" translate="yes" xml:space="preserve">
          <source>To apply and &lt;em&gt;automatically re-apply&lt;/em&gt; a side effect based on reactive state, we can use the &lt;code&gt;watchEffect&lt;/code&gt; method. It runs a function immediately while reactively tracking its dependencies and re-runs it whenever the dependencies are changed.</source>
          <target state="translated">反応状態に基づいて副作用を適用し、&lt;em&gt;自動的に再適用&lt;/em&gt;するには、 &lt;code&gt;watchEffect&lt;/code&gt; メソッドを使用できます。依存関係を事後的に追跡しながら関数をすぐに実行し、依存関係が変更されるたびに関数を再実行します。</target>
        </trans-unit>
        <trans-unit id="3bd440feea95e8113a121d0207c819f60960da69" translate="yes" xml:space="preserve">
          <source>To avoid rendering a list if it should be hidden (e.g. &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;&lt;/code&gt;). In these cases, move the &lt;code&gt;v-if&lt;/code&gt; to a container element (e.g. &lt;code&gt;ul&lt;/code&gt;, &lt;code&gt;ol&lt;/code&gt;).</source>
          <target state="translated">非表示にする必要がある場合にリストをレンダリングしないようにする（例： &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;&lt;/code&gt; ）。このような場合は、 &lt;code&gt;v-if&lt;/code&gt; をコンテナー要素（ &lt;code&gt;ul&lt;/code&gt; 、 &lt;code&gt;ol&lt;/code&gt; など）に移動します。</target>
        </trans-unit>
        <trans-unit id="11af8c48788875166f2c82baaf2047c13709005d" translate="yes" xml:space="preserve">
          <source>To avoid these problems, in Vue 3 we introduce&amp;hellip;</source>
          <target state="translated">これらの問題を回避するために、Vue3では&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="f959a2209cc4ae6dde0fc52d270647a756227800" translate="yes" xml:space="preserve">
          <source>To change a model name, instead of a &lt;code&gt;model&lt;/code&gt; component option, now we can pass an &lt;em&gt;argument&lt;/em&gt; to &lt;code&gt;v-model&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;model&lt;/code&gt; コンポーネントオプションの代わりにモデル名を変更するには、 &lt;code&gt;v-model&lt;/code&gt; に&lt;em&gt;引数&lt;/em&gt;を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="f2f16b9b50a22626214a8a2ce30432a9dda3b421" translate="yes" xml:space="preserve">
          <source>To configure our build with Rollup we will need to create a &lt;code&gt;rollup.config.js&lt;/code&gt; file in the root of our project:</source>
          <target state="translated">Rollupを使用してビルドを構成するには、プロジェクトのルートに &lt;code&gt;rollup.config.js&lt;/code&gt; ファイルを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="63f956073caa60e7478f9715ae3f9c555d2f8969" translate="yes" xml:space="preserve">
          <source>To create a VNode for a component, the first argument passed to &lt;code&gt;h&lt;/code&gt; should be the component itself:</source>
          <target state="translated">コンポーネントのVNodeを作成するには、 &lt;code&gt;h&lt;/code&gt; に渡される最初の引数はコンポーネント自体である必要があります。</target>
        </trans-unit>
        <trans-unit id="19a4ddff02308f2d46c7bfb2cc80ec93a6254881" translate="yes" xml:space="preserve">
          <source>To create a reactive state from a JavaScript object, we can use a &lt;code&gt;reactive&lt;/code&gt; method:</source>
          <target state="translated">JavaScriptオブジェクトからリアクティブ状態を作成するには、 &lt;code&gt;reactive&lt;/code&gt; メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="e1c205fa5653088d04441a5d46746a863c98b018" translate="yes" xml:space="preserve">
          <source>To deal with caveat 2, you can use &lt;code&gt;splice&lt;/code&gt;:</source>
          <target state="translated">警告2に対処するには、 &lt;code&gt;splice&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="6d872aff4853ffd947160017a366852e73bfc2ed" translate="yes" xml:space="preserve">
          <source>To explain what&amp;rsquo;s happening, let&amp;rsquo;s call our components A and B. The module system sees that it needs A, but first A needs B, but B needs A, but A needs B, etc. It&amp;rsquo;s stuck in a loop, not knowing how to fully resolve either component without first resolving the other. To fix this, we need to give the module system a point at which it can say, &amp;ldquo;A needs B &lt;em&gt;eventually&lt;/em&gt;, but there&amp;rsquo;s no need to resolve B first.&amp;rdquo;</source>
          <target state="translated">何が起こっているのかを説明するために、コンポーネントAとBを呼びましょう。モジュールシステムは、Aが必要であるが、最初はAがBを必要とするが、BはAが必要であるが、AはBが必要である、などを認識します。最初に他方を解決せずに、どちらかのコンポーネントを完全に解決します。これを修正するには、モジュールシステムに「Aには&lt;em&gt;最終的&lt;/em&gt;にB が必要ですが、最初にBを解決する必要はありません」と言えるポイントを与える必要があります。</target>
        </trans-unit>
        <trans-unit id="2f704c78b660c6599dd1fd0c78c96300ee070e37" translate="yes" xml:space="preserve">
          <source>To filter items in a list (e.g. &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;&lt;/code&gt;). In these cases, replace &lt;code&gt;users&lt;/code&gt; with a new computed property that returns your filtered list (e.g. &lt;code&gt;activeUsers&lt;/code&gt;).</source>
          <target state="translated">リスト内のアイテムをフィルタリングするには（例： &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;&lt;/code&gt; ）。これらの場合、 &lt;code&gt;users&lt;/code&gt; を、フィルターされたリストを返す新しい計算されたプロパティで置き換えます（例： &lt;code&gt;activeUsers&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ac31ac440566ea1907419215aa2f6fe6b76e4bb3" translate="yes" xml:space="preserve">
          <source>To get started with Vue, all you need is familiarity with HTML and ES5 JavaScript (i.e. plain JavaScript). With these basic skills, you can start building non-trivial applications within less than a day of reading &lt;a href=&quot;../index&quot;&gt;the guide&lt;/a&gt;.</source>
          <target state="translated">Vueを使い始めるために必要なのは、HTMLおよびES5 JavaScript（つまり、プレーンJavaScript）に精通していることだけです。これらの基本的なスキルがあれば&lt;a href=&quot;../index&quot;&gt;、ガイド&lt;/a&gt;を読んでから 1日も経たないうちに、重要なアプリケーションの作成を開始できます。</target>
        </trans-unit>
        <trans-unit id="776030a16d16967752ee7198797ade27b5d2a7fc" translate="yes" xml:space="preserve">
          <source>To get type inference for the arguments passed to &lt;code&gt;setup()&lt;/code&gt;, the use of &lt;a href=&quot;global-api#definecomponent&quot;&gt;defineComponent&lt;/a&gt; is needed.</source>
          <target state="translated">&lt;code&gt;setup()&lt;/code&gt; に渡された引数の型推論を取得するには、&lt;a href=&quot;global-api#definecomponent&quot;&gt;defineComponentを&lt;/a&gt;使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="8c6a7be936df8f4976d7c991e70077b80aee512a" translate="yes" xml:space="preserve">
          <source>To give Vue a hint so that it can track each node&amp;rsquo;s identity, and thus reuse and reorder existing elements, you need to provide a unique &lt;code&gt;key&lt;/code&gt; attribute for each item:</source>
          <target state="translated">Vueにヒントを与えて各ノードのIDを追跡し、既存の要素を再利用して並べ替えるには、各アイテムに一意の &lt;code&gt;key&lt;/code&gt; 属性を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="5fcb75ebf027b9d0a0175ff64ac67858b09230bc" translate="yes" xml:space="preserve">
          <source>To give Vue a hint so that it can track each node's identity, and thus reuse and reorder existing elements, you need to provide a unique &lt;code&gt;key&lt;/code&gt; attribute for each item:</source>
          <target state="translated">Vueにヒントを与えて、各ノードのIDを追跡し、既存の要素を再利用して並べ替えることができるようにするには、各アイテムに一意の &lt;code&gt;key&lt;/code&gt; 属性を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="c75de4b3808772ba349e727ba7f78014a936ee3b" translate="yes" xml:space="preserve">
          <source>To help solve this problem, we can adopt a &lt;strong&gt;store pattern&lt;/strong&gt;:</source>
          <target state="translated">この問題を解決するために、&lt;strong&gt;ストアパターンを&lt;/strong&gt;採用でき&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="6bab7ec362c384e83157e34842533353476c5f9b" translate="yes" xml:space="preserve">
          <source>To hide the link unless it is focused, you can add the following style:</source>
          <target state="translated">フォーカスされていない限りリンクを非表示にするには、以下のスタイルを追加します。</target>
        </trans-unit>
        <trans-unit id="5b08b3c5e2c296cf501fe81d8b1fdad39e5bceb5" translate="yes" xml:space="preserve">
          <source>To keep the old behavior work, and as we will be coercing &lt;code&gt;false&lt;/code&gt; to &lt;code&gt;'false'&lt;/code&gt;, in 3.x Vue developers need to make &lt;code&gt;v-bind&lt;/code&gt; expression resolve to &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;'false'&lt;/code&gt; for &lt;code&gt;contenteditable&lt;/code&gt; and &lt;code&gt;spellcheck&lt;/code&gt;.</source>
          <target state="translated">以前の動作の仕事を維持し、我々は強制変換されるようにするに &lt;code&gt;false&lt;/code&gt; する &lt;code&gt;'false'&lt;/code&gt; 3.xのVueの開発者で、確認する必要があり &lt;code&gt;v-bind&lt;/code&gt; に表現決意を &lt;code&gt;false&lt;/code&gt; または &lt;code&gt;'false'&lt;/code&gt; するために &lt;code&gt;contenteditable&lt;/code&gt; と &lt;code&gt;spellcheck&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55eb8a7e0c9b146414452970176fd17030d598fc" translate="yes" xml:space="preserve">
          <source>To learn more about programmatic listeners, check out the API for &lt;a href=&quot;../api/index#Instance-Methods-Events&quot;&gt;Events Instance Methods&lt;/a&gt;.</source>
          <target state="translated">プログラムリスナーの詳細については、&lt;a href=&quot;../api/index#Instance-Methods-Events&quot;&gt;イベントインスタンスメソッドの&lt;/a&gt; APIをご覧ください。</target>
        </trans-unit>
        <trans-unit id="f63e037fab7411a20c7d6797002ce6c1ea370d23" translate="yes" xml:space="preserve">
          <source>To let TypeScript properly infer types inside Vue component options, you need to define components with &lt;code&gt;Vue.component&lt;/code&gt; or &lt;code&gt;Vue.extend&lt;/code&gt;:</source>
          <target state="translated">TypeScriptがVueコンポーネントオプション内のタイプを適切に推測できるようにするには、 &lt;code&gt;Vue.component&lt;/code&gt; または &lt;code&gt;Vue.extend&lt;/code&gt; でコンポーネントを定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="d5a0debe65b75107b626e13146620736020251e6" translate="yes" xml:space="preserve">
          <source>To let TypeScript properly infer types inside Vue component options, you need to define components with &lt;code&gt;defineComponent&lt;/code&gt; global method:</source>
          <target state="translated">TypeScriptがVueコンポーネントオプション内のタイプを適切に推測できるようにするには、 &lt;code&gt;defineComponent&lt;/code&gt; グローバルメソッドを使用してコンポーネントを定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="07d5d14cc89427095a5243c18af0d1e934e75f1c" translate="yes" xml:space="preserve">
          <source>To let users interact with your app, we can use the &lt;code&gt;v-on&lt;/code&gt; directive to attach event listeners that invoke methods on our Vue instances:</source>
          <target state="translated">ユーザーがアプリを操作できるようにするには、 &lt;code&gt;v-on&lt;/code&gt; ディレクティブを使用して、Vueインスタンスのメソッドを呼び出すイベントリスナーをアタッチします。</target>
        </trans-unit>
        <trans-unit id="d33212d2502112422cf740d702a092d37f765943" translate="yes" xml:space="preserve">
          <source>To let users interact with your app, we can use the &lt;code&gt;v-on&lt;/code&gt; directive to attach event listeners that invoke methods on our instances:</source>
          <target state="translated">ユーザーがアプリを操作できるようにするために、 &lt;code&gt;v-on&lt;/code&gt; ディレクティブを使用して、インスタンスのメソッドを呼び出すイベントリスナーをアタッチできます。</target>
        </trans-unit>
        <trans-unit id="b795d5e4656eb47b1b382ba73bb73ecac50f9c6e" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;item&lt;/code&gt; available to the slot content provided by the parent, we can add a &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element and bind it as an attribute:</source>
          <target state="translated">ようにするには &lt;code&gt;item&lt;/code&gt; 親によって設けられたスロットのコンテンツが利用できる、我々は、追加することができ &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 要素を属性としてそれをバインドします。</target>
        </trans-unit>
        <trans-unit id="a2252111700f506a786c1bdd74f51e20a902d095" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;user&lt;/code&gt; available to the slot content in the parent, we can bind &lt;code&gt;user&lt;/code&gt; as an attribute to the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">ようにするには &lt;code&gt;user&lt;/code&gt; 親のスロットのコンテンツが利用できる、我々はバインドすることができ &lt;code&gt;user&lt;/code&gt; する属性として &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 要素：</target>
        </trans-unit>
        <trans-unit id="8d5ee521751945f607f368f2972a7a5e30916787" translate="yes" xml:space="preserve">
          <source>To make Composition API feature-complete compared to Options API, we also need a way to register lifecycle hooks inside &lt;code&gt;setup&lt;/code&gt;. This is possible thanks to several new functions exported from Vue. Lifecycle hooks on composition API have the same name as for Options API but are prefixed with &lt;code&gt;on&lt;/code&gt;: i.e. &lt;code&gt;mounted&lt;/code&gt; would look like &lt;code&gt;onMounted&lt;/code&gt;.</source>
          <target state="translated">オプションAPIと比較してCompositionAPIの機能を完全なものにするには、 &lt;code&gt;setup&lt;/code&gt; 内にライフサイクルフックを登録する方法も必要です。これは、Vueからエクスポートされたいくつかの新しい関数のおかげで可能です。コンポジションAPIのライフサイクルフックの名前は &lt;code&gt;onMounted&lt;/code&gt; 場合と同じですが、プレフィックスとして &lt;code&gt;on&lt;/code&gt; が付けられます。つまり、 &lt;code&gt;mounted&lt;/code&gt; はonMountedのようになります。</target>
        </trans-unit>
        <trans-unit id="6f339c5f06bd1c70bd6a59a91fa2c7296dfce01e" translate="yes" xml:space="preserve">
          <source>To overcome caveat 1, both of the following will accomplish the same as &lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt;, but will also trigger state updates in the reactivity system:</source>
          <target state="translated">警告1を克服するために、次の両方が &lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt; と同じように機能しますが、反応性システムで状態の更新もトリガーします。</target>
        </trans-unit>
        <trans-unit id="b21e4db7e451cf3b08481a1ab12a6f11393d30f0" translate="yes" xml:space="preserve">
          <source>To pass content to named slots from the parent, use the special &lt;code&gt;slot&lt;/code&gt; attribute on &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; (using the &lt;code&gt;&amp;lt;base-layout&amp;gt;&lt;/code&gt; component described &lt;a href=&quot;#Named-Slots&quot;&gt;here&lt;/a&gt; as example):</source>
          <target state="translated">コンテンツを親から名前付きスロットに渡すには、 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 特別な &lt;code&gt;slot&lt;/code&gt; 属性を使用します（例として&lt;a href=&quot;#Named-Slots&quot;&gt;ここで&lt;/a&gt;説明されている &lt;code&gt;&amp;lt;base-layout&amp;gt;&lt;/code&gt; コンポーネントを使用）。</target>
        </trans-unit>
        <trans-unit id="7d224921563544c4b732cb7daad7320d9fff997d" translate="yes" xml:space="preserve">
          <source>To pass scoped slots to a child component using render functions, use the &lt;code&gt;scopedSlots&lt;/code&gt; field in VNode data:</source>
          <target state="translated">レンダー関数を使用してスコープスロットを子コンポーネントに渡すには、VNodeデータの &lt;code&gt;scopedSlots&lt;/code&gt; フィールドを使用します。</target>
        </trans-unit>
        <trans-unit id="3040fecd05b5350f6cd19b5d9d470249a65d3a34" translate="yes" xml:space="preserve">
          <source>To provide content to named slots, we can use the &lt;code&gt;v-slot&lt;/code&gt; directive on a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;, providing the name of the slot as &lt;code&gt;v-slot&lt;/code&gt;&amp;lsquo;s argument:</source>
          <target state="translated">名前付きスロットにコンテンツを提供するには、 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; で &lt;code&gt;v-slot&lt;/code&gt; ディレクティブを使用して、スロットの名前を &lt;code&gt;v-slot&lt;/code&gt; の引数として指定できます。</target>
        </trans-unit>
        <trans-unit id="71b95472ceb5c02875dbc3b9d728b462388305b4" translate="yes" xml:space="preserve">
          <source>To provide content to named slots, we need to use the &lt;code&gt;v-slot&lt;/code&gt; directive on a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element, providing the name of the slot as &lt;code&gt;v-slot&lt;/code&gt;'s argument:</source>
          <target state="translated">名前のスロットにコンテンツを提供するために、我々は、使用する必要がある &lt;code&gt;v-slot&lt;/code&gt; 上のディレクティブ &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; とスロットの名前を提供し、要素を &lt;code&gt;v-slot&lt;/code&gt; の引数：</target>
        </trans-unit>
        <trans-unit id="f9822cbc90becc7c85283ddc496bc85247e9e908" translate="yes" xml:space="preserve">
          <source>To receive props passed to a slot, the parent component can use &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; with the &lt;code&gt;slot-scope&lt;/code&gt; attribute (using the &lt;code&gt;&amp;lt;slot-example&amp;gt;&lt;/code&gt; described &lt;a href=&quot;#Scoped-Slots&quot;&gt;here&lt;/a&gt; as example):</source>
          <target state="translated">スロットに渡された小道具を受け取るために、親コンポーネントは &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; と &lt;code&gt;slot-scope&lt;/code&gt; 属性を使用できます（ &lt;code&gt;&amp;lt;slot-example&amp;gt;&lt;/code&gt; として&lt;a href=&quot;#Scoped-Slots&quot;&gt;ここで&lt;/a&gt;説明されている&amp;lt;slot-example&amp;gt;を使用）。</target>
        </trans-unit>
        <trans-unit id="d3f9cfe4e2cdeebe7bd4ec32a7761a9fc73b24fe" translate="yes" xml:space="preserve">
          <source>To scope styles, Vue adds a unique attribute to component elements, such as &lt;code&gt;data-v-f3f3eg9&lt;/code&gt;. Then selectors are modified so that only matching elements with this attribute are selected (e.g. &lt;code&gt;button[data-v-f3f3eg9]&lt;/code&gt;).</source>
          <target state="translated">スタイルをスコープするために、Vueは &lt;code&gt;data-v-f3f3eg9&lt;/code&gt; などの固有の属性をコンポーネント要素に追加します。次に、セレクターが変更され、この属性を持つ一致する要素のみが選択されます（例： &lt;code&gt;button[data-v-f3f3eg9]&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e1258805ea6cb31e4a16aebae91838cb2b51823e" translate="yes" xml:space="preserve">
          <source>To solve this problem, Vue provides a &lt;code&gt;$listeners&lt;/code&gt; property containing an object of listeners being used on the component. For example:</source>
          <target state="translated">この問題を解決するために、Vueは、コンポーネントで使用されているリスナーのオブジェクトを含む &lt;code&gt;$listeners&lt;/code&gt; プロパティを提供しています。例えば：</target>
        </trans-unit>
        <trans-unit id="74e4ed250349981c3620f36729665b310ba83bc0" translate="yes" xml:space="preserve">
          <source>To specify a theme for our date picker plugin, we might need to add a specific class, like this:</source>
          <target state="translated">日付ピッカープラグインのテーマを指定するには、以下のように特定のクラスを追加する必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="db281192f2ae7e8aaae42433318460411bdce998" translate="yes" xml:space="preserve">
          <source>To specify prop validations, you can provide an object with validation requirements to the value of &lt;code&gt;props&lt;/code&gt;, instead of an array of strings. For example:</source>
          <target state="translated">prop検証を指定するには、文字列の配列の代わりに、 &lt;code&gt;props&lt;/code&gt; の値に対する検証要件をオブジェクトに提供できます。例えば：</target>
        </trans-unit>
        <trans-unit id="df730f7289460e401600ab8828525feef7da880a" translate="yes" xml:space="preserve">
          <source>To start transitioning towards a more robust solution using Vue 2.0, let&amp;rsquo;s first wrap this filter in a new &lt;code&gt;&amp;lt;currency-input&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">Vue 2.0を使用してより堅牢なソリューションへの移行を開始するには、まず、このフィルターを新しい &lt;code&gt;&amp;lt;currency-input&amp;gt;&lt;/code&gt; コンポーネントでラップします。</target>
        </trans-unit>
        <trans-unit id="69b37bec21337bb3fab748d90757734b339759ac" translate="yes" xml:space="preserve">
          <source>To take advantage of our newly created &lt;code&gt;esm&lt;/code&gt; module we need to add a few fields in our &lt;code&gt;package.json&lt;/code&gt; file:</source>
          <target state="translated">新しく作成した &lt;code&gt;esm&lt;/code&gt; モジュールを利用するには、 &lt;code&gt;package.json&lt;/code&gt; ファイルにいくつかのフィールドを追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="aceeb4fc5def0e78eb9b247f42dfe35a650c1ee1" translate="yes" xml:space="preserve">
          <source>To test most Vue components, they must be mounted to the DOM (either virtual or real) in order to fully assert that they are working. This is another framework-agnostic concept. As a result, component testing frameworks were created to give users the ability to do this in a reliable way while also providing Vue-specific conveniences such as integrations for Vuex, Vue Router, and other Vue plugins.</source>
          <target state="translated">ほとんどの Vue コンポーネントをテストするには、それらが動作していることを完全に主張するためには、それらを DOM (仮想または実物)にマウントする必要があります。これもフレームワークにとらわれないコンセプトです。その結果、コンポーネント テスト フレームワークは、Vuex、Vue Router、およびその他の Vue プラグインの統合など、Vue 固有の便利な機能を提供しながら、信頼性の高い方法でこれを行う能力をユーザーに提供するために作成されました。</target>
        </trans-unit>
        <trans-unit id="a7ce5efe8104fcb04d9fe2076a11036b5f04f71a" translate="yes" xml:space="preserve">
          <source>To use these components in templates, they must be registered so that Vue knows about them. There are two types of component registration: &lt;strong&gt;global&lt;/strong&gt; and &lt;strong&gt;local&lt;/strong&gt;. So far, we&amp;rsquo;ve only registered components globally, using &lt;code&gt;Vue.component&lt;/code&gt;:</source>
          <target state="translated">これらのコンポーネントをテンプレートで使用するには、Vueがそれらを認識できるように登録する必要があります。コンポーネントの登録には、&lt;strong&gt;グローバル&lt;/strong&gt;と&lt;strong&gt;ローカルの&lt;/strong&gt; 2つのタイプがあります。これまでのところ、 &lt;code&gt;Vue.component&lt;/code&gt; を使用して、コンポーネントをグローバルにのみ登録しています。</target>
        </trans-unit>
        <trans-unit id="c646dfddede1e8b816398b2a45bcbd049b84852a" translate="yes" xml:space="preserve">
          <source>To use these components in templates, they must be registered so that Vue knows about them. There are two types of component registration: &lt;strong&gt;global&lt;/strong&gt; and &lt;strong&gt;local&lt;/strong&gt;. So far, we've only registered components globally, using the &lt;code&gt;component&lt;/code&gt; method of our app:</source>
          <target state="translated">これらのコンポーネントをテンプレートで使用するには、Vueがそれらを認識できるように登録する必要があります。コンポーネント登録には、&lt;strong&gt;グローバル&lt;/strong&gt;と&lt;strong&gt;ローカルの&lt;/strong&gt;2種類があります。これまでのところ、アプリの &lt;code&gt;component&lt;/code&gt; メソッドを使用して、コンポーネントをグローバルに登録しただけです。</target>
        </trans-unit>
        <trans-unit id="083ac4d1bdb64c24b06053515311f1dbb9c56468" translate="yes" xml:space="preserve">
          <source>Toggles the element&amp;rsquo;s &lt;code&gt;display&lt;/code&gt; CSS property based on the truthy-ness of the expression value.</source>
          <target state="translated">式の値の真実さに基づいて、要素の &lt;code&gt;display&lt;/code&gt; CSSプロパティを切り替えます。</target>
        </trans-unit>
        <trans-unit id="c759e0477d126a03e9d103eb8525e47fab0be4d4" translate="yes" xml:space="preserve">
          <source>Toggles the element's &lt;code&gt;display&lt;/code&gt; CSS property based on the truthy-ness of the expression value.</source>
          <target state="translated">式の値の真実性に基づいて、要素の &lt;code&gt;display&lt;/code&gt; CSSプロパティを切り替えます。</target>
        </trans-unit>
        <trans-unit id="e2062eeee29d80bbd790b6b1c6949a13f04e9706" translate="yes" xml:space="preserve">
          <source>Track the function that changes it</source>
          <target state="translated">それを変更する機能を追跡する</target>
        </trans-unit>
        <trans-unit id="a6caa355a086fc2249c03acc2b1839b71a8b078d" translate="yes" xml:space="preserve">
          <source>Tracking Runtime Errors</source>
          <target state="translated">ランタイムエラーの追跡</target>
        </trans-unit>
        <trans-unit id="a176cdd957b46dda003cee3ad2c254dd6615b0eb" translate="yes" xml:space="preserve">
          <source>Transform and Opacity</source>
          <target state="translated">変形と不透明度</target>
        </trans-unit>
        <trans-unit id="89ce581f0ea8d1b2420e91fc530ed304c21108f8" translate="yes" xml:space="preserve">
          <source>Transition &lt;code&gt;stagger&lt;/code&gt; Attribute &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">移行 &lt;code&gt;stagger&lt;/code&gt; 属性が&lt;sup&gt;削除されました&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="da0592cf78795180a4901cee778a25e6a87d50a4" translate="yes" xml:space="preserve">
          <source>Transition Class Change</source>
          <target state="translated">トランジション クラスチェンジ</target>
        </trans-unit>
        <trans-unit id="9f251498a9b6cf9beba1d76cd01407a53ded18fc" translate="yes" xml:space="preserve">
          <source>Transition Classes</source>
          <target state="translated">トランジションクラス</target>
        </trans-unit>
        <trans-unit id="e11311738d4c6ffea274c409ecdda9e0756654ab" translate="yes" xml:space="preserve">
          <source>Transition Group Root Element</source>
          <target state="translated">遷移グループ ルート要素</target>
        </trans-unit>
        <trans-unit id="378b930e1b5fcf70d0c6bd07479947a4eb546d50" translate="yes" xml:space="preserve">
          <source>Transition Modes</source>
          <target state="translated">移行モード</target>
        </trans-unit>
        <trans-unit id="c63dd8b039c9bc74f39dc660f1a5dd0332bdb933" translate="yes" xml:space="preserve">
          <source>Transition Modes so that you can orchestrate ordering during a transition.</source>
          <target state="translated">トランジションモードでは、トランジション中にオーケストレーションを行うことができます。</target>
        </trans-unit>
        <trans-unit id="e88887fef46466032f502eb29f868554693e91d2" translate="yes" xml:space="preserve">
          <source>Transitioning Between Components</source>
          <target state="translated">コンポーネント間の移行</target>
        </trans-unit>
        <trans-unit id="729ea31da2993e21396230fd8222c60977213fa2" translate="yes" xml:space="preserve">
          <source>Transitioning Between Elements</source>
          <target state="translated">要素間の遷移</target>
        </trans-unit>
        <trans-unit id="a49e21a903b97ba094868eb0afba5e8256564527" translate="yes" xml:space="preserve">
          <source>Transitioning Single Elements/Components</source>
          <target state="translated">単一要素/コンポーネントの遷移</target>
        </trans-unit>
        <trans-unit id="683fee2e7c72141affe501b569a593b5a663b63c" translate="yes" xml:space="preserve">
          <source>Transitioning between components is even simpler - we don&amp;rsquo;t even need the &lt;code&gt;key&lt;/code&gt; attribute. Instead, we wrap a &lt;a href=&quot;components#Dynamic-Components&quot;&gt;dynamic component&lt;/a&gt;:</source>
          <target state="translated">コンポーネント間の移行はさらに簡単です- &lt;code&gt;key&lt;/code&gt; 属性も必要ありません。代わりに、&lt;a href=&quot;components#Dynamic-Components&quot;&gt;動的コンポーネント&lt;/a&gt;をラップします。</target>
        </trans-unit>
        <trans-unit id="3ebf68016515c38ab5d5bb14e02906e976906a37" translate="yes" xml:space="preserve">
          <source>Transitioning between components is even simpler - we don't even need the &lt;code&gt;key&lt;/code&gt; attribute. Instead, we wrap a &lt;a href=&quot;component-basics#dynamic-components&quot;&gt;dynamic component&lt;/a&gt;:</source>
          <target state="translated">コンポーネント間での移行はさらに簡単です-私たちも必要としない &lt;code&gt;key&lt;/code&gt; 属性を。代わりに、&lt;a href=&quot;component-basics#dynamic-components&quot;&gt;動的コンポーネント&lt;/a&gt;をラップします。</target>
        </trans-unit>
        <trans-unit id="57e93cce4e6bbda7187841b2d8bb8c9ea9bb591d" translate="yes" xml:space="preserve">
          <source>Transitioning different states in an application, with &lt;code&gt;watchers&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;watchers&lt;/code&gt; 使用して、アプリケーション内のさまざまな状態を遷移します。</target>
        </trans-unit>
        <trans-unit id="ab39260fea78bd5cdfde4b98ccfd4bc7bd02a43c" translate="yes" xml:space="preserve">
          <source>Transitions</source>
          <target state="translated">Transitions</target>
        </trans-unit>
        <trans-unit id="2c61460002f7db08fe602f2c55ec5b58109e727a" translate="yes" xml:space="preserve">
          <source>Transitions can be reused through Vue&amp;rsquo;s component system. To create a reusable transition, all you have to do is place a &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; component at the root, then pass any children into the transition component.</source>
          <target state="translated">トランジションは、Vueのコンポーネントシステムを介して再利用できます。再利用可能なトランジションを作成するには、ルートに &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; または &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; コンポーネントを配置し、トランジションコンポーネントに子を渡すだけです。</target>
        </trans-unit>
        <trans-unit id="3389419ab0dc8619c42e92046a205d6cbaad10df" translate="yes" xml:space="preserve">
          <source>Transitions can be reused through Vue's component system. To create a reusable transition, all you have to do is place a &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; component at the root, then pass any children into the transition component.</source>
          <target state="translated">トランジションは、Vueのコンポーネントシステムを介して再利用できます。再利用可能なトランジションを作成するには、ルートに &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; または &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; コンポーネントを配置し、子をトランジションコンポーネントに渡すだけです。</target>
        </trans-unit>
        <trans-unit id="e66fe7bf85c8e42bb35f5c119b60107ac08d7dd2" translate="yes" xml:space="preserve">
          <source>Transitions on Initial Render</source>
          <target state="translated">初期レンダリング時の遷移</target>
        </trans-unit>
        <trans-unit id="ea9b9a14750b0c53f7e4ae9826cc61972586d91e" translate="yes" xml:space="preserve">
          <source>Transitions with Style Bindings</source>
          <target state="translated">スタイルバインディングによるトランジション</target>
        </trans-unit>
        <trans-unit id="00ba1a884606d8d53aae517b3c977aedd3829998" translate="yes" xml:space="preserve">
          <source>Translate Docs</source>
          <target state="translated">ドキュメントの翻訳</target>
        </trans-unit>
        <trans-unit id="8ad8302d110b05d7e02330dac58628134fdcff02" translate="yes" xml:space="preserve">
          <source>Translations</source>
          <target state="translated">Translations</target>
        </trans-unit>
        <trans-unit id="eafcab92249a0ffd49ad48547d7448759e6aa04c" translate="yes" xml:space="preserve">
          <source>Trigger an event on the current instance. Any additional arguments will be passed into the listener&amp;rsquo;s callback function.</source>
          <target state="translated">現在のインスタンスでイベントをトリガーします。追加の引数は、リスナーのコールバック関数に渡されます。</target>
        </trans-unit>
        <trans-unit id="ff7ce3c92d4d6dbb6b2b78de21280fe459138d0f" translate="yes" xml:space="preserve">
          <source>Trigger an event on the current instance. Any additional arguments will be passed into the listener's callback function.</source>
          <target state="translated">現在のインスタンスのイベントをトリガーします。追加の引数はリスナーのコールバック関数に渡されます。</target>
        </trans-unit>
        <trans-unit id="dfdc40b121c3b5e2b8c970420d2e421c9a7ed7cd" translate="yes" xml:space="preserve">
          <source>Trigger the function so it can update the final value</source>
          <target state="translated">最終的な値を更新できるように関数をトリガーする</target>
        </trans-unit>
        <trans-unit id="23b1b4852352a99bc2e60b5c2bca0de04c5a0e58" translate="yes" xml:space="preserve">
          <source>Trigger transitions</source>
          <target state="translated">トリガーの遷移</target>
        </trans-unit>
        <trans-unit id="157ebe584fb6f0fc58df93caa511c65b6198fe3d" translate="yes" xml:space="preserve">
          <source>Triggers the &lt;code&gt;beforeDestroy&lt;/code&gt; and &lt;code&gt;destroyed&lt;/code&gt; hooks.</source>
          <target state="translated">&lt;code&gt;beforeDestroy&lt;/code&gt; をトリガーし、フックを &lt;code&gt;destroyed&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="d420c849a5dc1f0529452193788a65de950aab62" translate="yes" xml:space="preserve">
          <source>Truthiness/Falsiness with &lt;code&gt;v-bind&lt;/code&gt;&lt;sup&gt;changed&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;v-bind&lt;/code&gt; 真実/偽りが&lt;sup&gt;変更されました&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d01a4f9ab1ff7fae7cb3dedf5ed58a422558aa71" translate="yes" xml:space="preserve">
          <source>Try this lesson on Scrimba</source>
          <target state="translated">Scrimbaのレッスンを試してみる</target>
        </trans-unit>
        <trans-unit id="32ae11a86cc97e517601b6c7e4ad185de28233ca" translate="yes" xml:space="preserve">
          <source>Try to change the value of &lt;code&gt;books&lt;/code&gt; array in the application &lt;code&gt;data&lt;/code&gt; and you will see how &lt;code&gt;publishedBooksMessage&lt;/code&gt; is changing accordingly.</source>
          <target state="translated">アプリケーション &lt;code&gt;data&lt;/code&gt; &lt;code&gt;books&lt;/code&gt; 配列の値を変更してみると、 &lt;code&gt;publishedBooksMessage&lt;/code&gt; がそれに応じてどのように変化するかがわかります。</target>
        </trans-unit>
        <trans-unit id="31d5f8ded86e9c7db19490f3af36b27e26fc547c" translate="yes" xml:space="preserve">
          <source>Turn on Production Mode</source>
          <target state="translated">生産モードをオンにする</target>
        </trans-unit>
        <trans-unit id="6ad6b070d8858ef9034c2b27714131daa17dc2f1" translate="yes" xml:space="preserve">
          <source>Two of the most commonly used directives in Vue.js are &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt;. So it's no surprise that there comes a time when developers want to use both together. While this is not a recommended practice, there may be times when this is necessary, so we wanted to provide guidance for how it works.</source>
          <target state="translated">Vue.jsで最も一般的に使用されるディレクティブの2つは、 &lt;code&gt;v-if&lt;/code&gt; と &lt;code&gt;v-for&lt;/code&gt; です。したがって、開発者が両方を一緒に使用したいときが来るのは当然のことです。これは推奨される方法ではありませんが、必要な場合があるため、その仕組みについてガイダンスを提供したいと思います。</target>
        </trans-unit>
        <trans-unit id="7f301c8844da472aa1a826f8a27afb3c78a049e5" translate="yes" xml:space="preserve">
          <source>Two-Way Filters &lt;sup&gt;replaced&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;交換された&lt;/sup&gt;双方向フィルター&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d5541b2f56b10335a874486b8e8c3fb6f6652d19" translate="yes" xml:space="preserve">
          <source>Type Checks</source>
          <target state="translated">タイプチェック</target>
        </trans-unit>
        <trans-unit id="d4a86cb946d4af4766f6a695502b64f3ea0cd58b" translate="yes" xml:space="preserve">
          <source>TypeScript</source>
          <target state="translated">TypeScript</target>
        </trans-unit>
        <trans-unit id="aec373f2c6104f4e0717f76308cbda4cbd9ffa55" translate="yes" xml:space="preserve">
          <source>TypeScript Support</source>
          <target state="translated">TypeScript のサポート</target>
        </trans-unit>
        <trans-unit id="8170f1ce20dc21f163cf51322861b52a4e97389f" translate="yes" xml:space="preserve">
          <source>TypeScript should be able to infer most of the types without defining types explicitly. For example, if you have a component with a number &lt;code&gt;count&lt;/code&gt; property, you will have an error if you try to call a string-specific method on it:</source>
          <target state="translated">TypeScriptは、型を明示的に定義しなくても、ほとんどの型を推測できるはずです。たとえば、number &lt;code&gt;count&lt;/code&gt; プロパティを持つコンポーネントがある場合、そのコンポーネントで文字列固有のメソッドを呼び出そうとすると、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="d55ceb4ee3907ab73fac7e8e26ce07c11d3e0af7" translate="yes" xml:space="preserve">
          <source>Typically this is done on the top of &lt;code&gt;App.vue&lt;/code&gt; as it will be the first focusable element on all your pages:</source>
          <target state="translated">通常、これは &lt;code&gt;App.vue&lt;/code&gt; の上部で実行されます。これは、すべてのページで最初にフォーカス可能な要素になるためです。</target>
        </trans-unit>
        <trans-unit id="04c49cff5528c3adc7123ea4b4bd10c092f423a6" translate="yes" xml:space="preserve">
          <source>Typically this is used to avoid conflicting with server-side frameworks that also use mustache syntax.</source>
          <target state="translated">通常、これは口ひげの構文も使用するサーバーサイドフレームワークとの衝突を避けるために使用されます。</target>
        </trans-unit>
        <trans-unit id="5614fd83d7c12176ea9d23d0a9a55af15cb1297f" translate="yes" xml:space="preserve">
          <source>Typing</source>
          <target state="translated">Typing</target>
        </trans-unit>
        <trans-unit id="008b2efd937ff1c3483ebcd86c95416cf9a4fc6a" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;computed&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;computed&lt;/code&gt; 入力</target>
        </trans-unit>
        <trans-unit id="51b08374e53ad50d899f5b39f4b437e0d89dd152" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;reactive&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;reactive&lt;/code&gt; 入力</target>
        </trans-unit>
        <trans-unit id="ea78cd4e8a3266b63fc59c7788f1a2d9d235e682" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;refs&lt;/code&gt;</source>
          <target state="translated">タイピング &lt;code&gt;refs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0bd6ddea889188f5409ccc93b3f07e4e036e69a1" translate="yes" xml:space="preserve">
          <source>UMD</source>
          <target state="translated">UMD</target>
        </trans-unit>
        <trans-unit id="57c74547c7338aa72bc084a3800f580c969f4939" translate="yes" xml:space="preserve">
          <source>Under no circumstances should 2 alerts be used next to one another, it's a sign that we're not able to explain context well enough.</source>
          <target state="translated">いかなる状況下でも、2つのアラートを隣り合わせで使用してはいけないのは、文脈を十分に説明できていない証拠です。</target>
        </trans-unit>
        <trans-unit id="944d13eb403bd42b865740161f8cbc0987c94607" translate="yes" xml:space="preserve">
          <source>Under the hood, Vue compiles the templates into Virtual DOM render functions. Combined with the reactivity system, Vue is able to intelligently figure out the minimal number of components to re-render and apply the minimal amount of DOM manipulations when the app state changes.</source>
          <target state="translated">Vue は、テンプレートを仮想 DOM レンダリング関数にコンパイルします。リアクティブ システムと組み合わせることで、Vue は、アプリの状態が変化したときに、再レンダリングするコンポーネントの最小数をインテリジェントに把握し、最小限の DOM 操作を適用することができます。</target>
        </trans-unit>
        <trans-unit id="1a1ce3521c0de87c0b96c0765bcfe6f68f1f6e9e" translate="yes" xml:space="preserve">
          <source>Understandable (opens new window)</source>
          <target state="translated">理解できる(新しいウィンドウが開きます</target>
        </trans-unit>
        <trans-unit id="efebc0e828d40a601d9f18dd32ec7ffc783e63b7" translate="yes" xml:space="preserve">
          <source>Unfortunately, HTML doesn&amp;rsquo;t allow custom elements to be self-closing - only &lt;a href=&quot;https://www.w3.org/TR/html/syntax.html#void-elements&quot;&gt;official &amp;ldquo;void&amp;rdquo; elements&lt;/a&gt;. That&amp;rsquo;s why the strategy is only possible when Vue&amp;rsquo;s template compiler can reach the template before the DOM, then serve the DOM spec-compliant HTML.</source>
          <target state="translated">残念ながら、HTMLではカスタム要素を自己完結させることはできません。&lt;a href=&quot;https://www.w3.org/TR/html/syntax.html#void-elements&quot;&gt;公式の「void」要素&lt;/a&gt;のみです。そのため、VueのテンプレートコンパイラがDOMの前にテンプレートに到達し、DOM仕様に準拠したHTMLを提供できる場合にのみ、この戦略が可能になります。</target>
        </trans-unit>
        <trans-unit id="98c83482c6886ad1473a05cf5f78dcfee5bc89dc" translate="yes" xml:space="preserve">
          <source>Unfortunately, HTML doesn't allow custom elements to be self-closing - only &lt;a href=&quot;https://www.w3.org/TR/html/syntax.html#void-elements&quot;&gt;official &quot;void&quot; elements (opens new window)&lt;/a&gt;. That's why the strategy is only possible when Vue's template compiler can reach the template before the DOM, then serve the DOM spec-compliant HTML.</source>
          <target state="translated">残念ながら、HTMLではカスタム要素を自動で閉じることはできません。&lt;a href=&quot;https://www.w3.org/TR/html/syntax.html#void-elements&quot;&gt;公式の「void」要素（新しいウィンドウを開く）のみ&lt;/a&gt;です。そのため、この戦略は、VueのテンプレートコンパイラがDOMの前にテンプレートに到達し、DOM仕様に準拠したHTMLを提供できる場合にのみ可能です。</target>
        </trans-unit>
        <trans-unit id="cde72f0f84d52a7aa84d7462ed5f19ec98ac0985" translate="yes" xml:space="preserve">
          <source>Unfortunately, due to HTML&amp;rsquo;s case insensitivity, DOM templates must still use kebab-case.</source>
          <target state="translated">残念ながら、HTMLの大文字と小文字は区別されないため、DOMテンプレートはまだkebab-caseを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="b10a452c474e61495690e111a7011d55f17f26b9" translate="yes" xml:space="preserve">
          <source>Unfortunately, due to HTML's case insensitivity, DOM templates must still use kebab-case.</source>
          <target state="translated">残念ながら、HTML の大文字小文字の区別がつかないため、DOM テンプレートはまだ kebab-case を使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="6f5fadc81ad6c9be68633a21c0b94f28044dc294" translate="yes" xml:space="preserve">
          <source>Unfortunately, with such a destructuring the reactivity for both properties would be lost. For such a case, we need to convert our reactive object to a set of refs. These refs will retain the reactive connection to the source object:</source>
          <target state="translated">残念ながら、このような破壊を行うと、両方のプロパティの反応性が失われてしまいます。このような場合のために、反応性のあるオブジェクトを ref のセットに変換する必要があります。これらの参照は、ソース・オブジェクトへのリアクティブな接続を保持します。</target>
        </trans-unit>
        <trans-unit id="438d23452047f4defac8e18aecae37372fcea335" translate="yes" xml:space="preserve">
          <source>Unit Testing</source>
          <target state="translated">ユニットテスト</target>
        </trans-unit>
        <trans-unit id="fa4ba8e0a89b5b3663d1a20fd16ffec2b04f9510" translate="yes" xml:space="preserve">
          <source>Unit testing a Vue application does not significantly differ from testing other types of applications.</source>
          <target state="translated">Vueアプリケーションのユニットテストは、他のタイプのアプリケーションのテストと大きな違いはありません。</target>
        </trans-unit>
        <trans-unit id="6fab82db2414bfb4495b150b0fb016a74e7217d8" translate="yes" xml:space="preserve">
          <source>Unit tests allow you to test individual units of code in isolation. The purpose of unit testing is to provide developers with confidence in their code. By writing thorough, meaningful tests, you achieve the confidence that as new features are built or your code is refactored your application will remain functional and stable.</source>
          <target state="translated">ユニットテストでは、コードの個々のユニットを分離してテストすることができます。ユニットテストの目的は、開発者が自分のコードに自信を持てるようにすることです。徹底した意味のあるテストを書くことで、新しい機能が構築されたり、コードがリファクタリングされたりしても、アプリケーションが機能的で安定した状態を維持できるという自信を得ることができます。</target>
        </trans-unit>
        <trans-unit id="5784cfdccc209a8e200b1ac07b791bba6b8e33be" translate="yes" xml:space="preserve">
          <source>Unless you spread components out over multiple files (for example with &lt;a href=&quot;https://github.com/gajus/react-css-modules&quot;&gt;CSS Modules&lt;/a&gt;), scoping CSS in React is often done via CSS-in-JS solutions (e.g. &lt;a href=&quot;https://github.com/styled-components/styled-components&quot;&gt;styled-components&lt;/a&gt;, &lt;a href=&quot;https://github.com/paypal/glamorous&quot;&gt;glamorous&lt;/a&gt;, and &lt;a href=&quot;https://github.com/emotion-js/emotion&quot;&gt;emotion&lt;/a&gt;). This introduces a new component-oriented styling paradigm that is different from the normal CSS authoring process. Additionally, although there is support for extracting CSS into a single stylesheet at build time, it is still common that a runtime will need to be included in the bundle for styling to work properly. While you gain access to the dynamism of JavaScript while constructing your styles, the tradeoff is often increased bundle size and runtime cost.</source>
          <target state="translated">コンポーネントを複数のファイルに分散しない限り（たとえば、&lt;a href=&quot;https://github.com/gajus/react-css-modules&quot;&gt;CSSモジュールを使用して&lt;/a&gt;）、ReactでのCSSのスコープ設定は、CSS-in-JSソリューション（たとえば、&lt;a href=&quot;https://github.com/styled-components/styled-components&quot;&gt;styled-components&lt;/a&gt;、&lt;a href=&quot;https://github.com/paypal/glamorous&quot;&gt;glamorous&lt;/a&gt;、および&lt;a href=&quot;https://github.com/emotion-js/emotion&quot;&gt;emotion&lt;/a&gt;）を介して行われることがよくあります。これにより、通常のCSSオーサリングプロセスとは異なる、コンポーネント指向の新しいスタイルパラダイムが導入されます。さらに、ビルド時にCSSを単一のスタイルシートに抽出するためのサポートがありますが、スタイリングが正しく機能するためには、ランタイムをバンドルに含める必要があることは依然として一般的です。スタイルの構築中にJavaScriptのダイナミズムにアクセスする一方で、バンドルサイズとランタイムコストの増加がトレードオフになることがよくあります。</target>
        </trans-unit>
        <trans-unit id="cd579c46ea157b603f52518cfa50c5d9581039b9" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;, it renders an actual element: a &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; by default. You can change the element that&amp;rsquo;s rendered with the &lt;code&gt;tag&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; とは異なり、実際の要素をレンダリングします。デフォルトでは &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; です。 &lt;code&gt;tag&lt;/code&gt; 属性を使用してレンダリングされる要素を変更できます。</target>
        </trans-unit>
        <trans-unit id="a6acb74ac65b8a5066968b3279fd2e776accbabb" translate="yes" xml:space="preserve">
          <source>Unlike attributes, directives can't be passed to a different element with &lt;code&gt;v-bind=&quot;$attrs&quot;&lt;/code&gt;.</source>
          <target state="translated">属性とは異なり、 &lt;code&gt;v-bind=&quot;$attrs&quot;&lt;/code&gt; してディレクティブを別の要素に渡すことはできません。</target>
        </trans-unit>
        <trans-unit id="25ca7305c07b7e218db67c93a49432c3e6a15dd6" translate="yes" xml:space="preserve">
          <source>Unlike components and props, event names don&amp;rsquo;t provide any automatic case transformation. Instead, the name of an emitted event must exactly match the name used to listen to that event. For example, if emitting a camelCased event name:</source>
          <target state="translated">コンポーネントや小道具とは異なり、イベント名は自動大文字小文字変換を提供しません。代わりに、発行されたイベントの名前は、そのイベントをリッスンするために使用される名前と正確に一致する必要があります。たとえば、camelCasedイベント名を発行する場合：</target>
        </trans-unit>
        <trans-unit id="1b5932d92048f8173920b18339d8abf66540f64a" translate="yes" xml:space="preserve">
          <source>Unlike components and props, event names will never be used as variable or property names in JavaScript, so there&amp;rsquo;s no reason to use camelCase or PascalCase. Additionally, &lt;code&gt;v-on&lt;/code&gt; event listeners inside DOM templates will be automatically transformed to lowercase (due to HTML&amp;rsquo;s case-insensitivity), so &lt;code&gt;v-on:myEvent&lt;/code&gt; would become &lt;code&gt;v-on:myevent&lt;/code&gt; &amp;ndash; making &lt;code&gt;myEvent&lt;/code&gt; impossible to listen to.</source>
          <target state="translated">コンポーネントやプロップとは異なり、イベント名はJavaScriptで変数名やプロパティ名として使用されることはないため、キャメルケースやパスカルケースを使用する理由はありません。さらに、DOMテンプレート内の &lt;code&gt;v-on&lt;/code&gt; イベントリスナーは自動的に小文字に変換されます（HTMLの大文字と小文字が区別されないため） &lt;code&gt;v-on:myEvent&lt;/code&gt; は &lt;code&gt;v-on:myevent&lt;/code&gt; になり、 &lt;code&gt;myEvent&lt;/code&gt; をリッスンできなくなります。</target>
        </trans-unit>
        <trans-unit id="f006741a889552e701feca503ae9ecc21cef3c4c" translate="yes" xml:space="preserve">
          <source>Unlike in 1.x, these &lt;code&gt;$refs&lt;/code&gt; are not reactive, because they&amp;rsquo;re registered/updated during the render process itself. Making them reactive would require duplicate renders for every change.</source>
          <target state="translated">1.xとは異なり、これらの &lt;code&gt;$refs&lt;/code&gt; は、レンダリングプロセス中に登録/更新されるため、リアクティブではありません。それらを反応させるには、すべての変更に対して複製のレンダリングが必要になります。</target>
        </trans-unit>
        <trans-unit id="fcbebe457290f0fc4402b0c59876bcbdda0f2d4e" translate="yes" xml:space="preserve">
          <source>Unlike most of the application methods, &lt;code&gt;mount&lt;/code&gt; does not return the application. Instead it returns the root component instance.</source>
          <target state="translated">ほとんどのアプリケーションメソッドとは異なり、 &lt;code&gt;mount&lt;/code&gt; はアプリケーションを返しません。代わりに、ルートコンポーネントインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="d2884ecb559d2fe9248396c1892b61a7ac7c3279" translate="yes" xml:space="preserve">
          <source>Unlike single root node components, components with multiple root nodes do not have an automatic attribute fallthrough behavior. If &lt;code&gt;$attrs&lt;/code&gt; are not bound explicitly, a runtime warning will be issued.</source>
          <target state="translated">単一のルートノードコンポーネントとは異なり、複数のルートノードを持つコンポーネントには自動属性フォールスルー動作がありません。 &lt;code&gt;$attrs&lt;/code&gt; が明示的にバインドされていない場合、実行時警告が発行されます。</target>
        </trans-unit>
        <trans-unit id="46a11b676273740dcc6b273657283a0efe154b9e" translate="yes" xml:space="preserve">
          <source>Unlike the other modifiers, which are exclusive to native DOM events, the &lt;code&gt;.once&lt;/code&gt; modifier can also be used on &lt;a href=&quot;component-custom-events&quot;&gt;component events&lt;/a&gt;. If you haven't read about components yet, don't worry about this for now.</source>
          <target state="translated">ネイティブDOMイベント専用の他の修飾子とは異なり、 &lt;code&gt;.once&lt;/code&gt; 修飾子は&lt;a href=&quot;component-custom-events&quot;&gt;コンポーネントイベントで&lt;/a&gt;も使用できます。コンポーネントについてまだ読んでいない場合は、今のところ心配しないでください。</target>
        </trans-unit>
        <trans-unit id="a336f78a69fc6406c5b9e9b9181b8c60e3829997" translate="yes" xml:space="preserve">
          <source>Unlike the other modifiers, which are exclusive to native DOM events, the &lt;code&gt;.once&lt;/code&gt; modifier can also be used on &lt;a href=&quot;components-custom-events&quot;&gt;component events&lt;/a&gt;. If you haven&amp;rsquo;t read about components yet, don&amp;rsquo;t worry about this for now.</source>
          <target state="translated">ネイティブDOMイベント専用のその他の修飾子とは異なり、 &lt;code&gt;.once&lt;/code&gt; 修飾子は&lt;a href=&quot;components-custom-events&quot;&gt;コンポーネントイベントで&lt;/a&gt;も使用できます。コンポーネントについてまだ読んでいない場合は、今のところ心配する必要はありません。</target>
        </trans-unit>
        <trans-unit id="d465ac61f7785357bc3939f874106ce910c0065e" translate="yes" xml:space="preserve">
          <source>Unmounts a root component of the application instance.</source>
          <target state="translated">アプリケーションインスタンスのルートコンポーネントをアンマウントします。</target>
        </trans-unit>
        <trans-unit id="289cb3bfd569e3d20bbdf203e762e02753089f2c" translate="yes" xml:space="preserve">
          <source>Updated in 2.6.0+. &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;See here&lt;/a&gt; for the deprecated syntax using the &lt;code&gt;slot-scope&lt;/code&gt; attribute.</source>
          <target state="translated">2.6.0以降で更新。 &lt;code&gt;slot-scope&lt;/code&gt; 属性を使用した非推奨の構文については、&lt;a href=&quot;#Deprecated-Syntax&quot;&gt;こちら&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="b6850e978579f57a9a7da09e605e48276246d285" translate="yes" xml:space="preserve">
          <source>Updated in 2.6.0+. &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;See here&lt;/a&gt; for the deprecated syntax using the &lt;code&gt;slot&lt;/code&gt; attribute.</source>
          <target state="translated">2.6.0以降で更新。 &lt;code&gt;slot&lt;/code&gt; 属性を使用した非推奨の構文については、&lt;a href=&quot;#Deprecated-Syntax&quot;&gt;こちら&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="4273a6bbb2974f5727228ca361ff3584716df7e4" translate="yes" xml:space="preserve">
          <source>Updates the element&amp;rsquo;s &lt;code&gt;innerHTML&lt;/code&gt;. &lt;strong&gt;Note that the contents are inserted as plain HTML - they will not be compiled as Vue templates&lt;/strong&gt;. If you find yourself trying to compose templates using &lt;code&gt;v-html&lt;/code&gt;, try to rethink the solution by using components instead.</source>
          <target state="translated">要素の &lt;code&gt;innerHTML&lt;/code&gt; を更新します。&lt;strong&gt;コンテンツはプレーンHTMLとして挿入されることに注意してください&lt;/strong&gt;。&lt;strong&gt;これらはVueテンプレートとしてコンパイルされません&lt;/strong&gt;。 &lt;code&gt;v-html&lt;/code&gt; を使用してテンプレートを作成しようとしている場合は、代わりにコンポーネントを使用してソリューションを再考してください。</target>
        </trans-unit>
        <trans-unit id="004c861aa8adec999af936828cfad53817d95e1d" translate="yes" xml:space="preserve">
          <source>Updates the element&amp;rsquo;s &lt;code&gt;textContent&lt;/code&gt;. If you need to update the part of &lt;code&gt;textContent&lt;/code&gt;, you should use &lt;code&gt;{{ Mustache }}&lt;/code&gt; interpolations.</source>
          <target state="translated">要素の &lt;code&gt;textContent&lt;/code&gt; を更新します。 &lt;code&gt;textContent&lt;/code&gt; の一部を更新する必要がある場合は、 &lt;code&gt;{{ Mustache }}&lt;/code&gt; 補間を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="c0dca31a6bb9b094601cb2bf5c3fb308c6b17b07" translate="yes" xml:space="preserve">
          <source>Updates the element's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML&quot;&gt;innerHTML (opens new window)&lt;/a&gt;. &lt;strong&gt;Note that the contents are inserted as plain HTML - they will not be compiled as Vue templates&lt;/strong&gt;. If you find yourself trying to compose templates using &lt;code&gt;v-html&lt;/code&gt;, try to rethink the solution by using components instead.</source>
          <target state="translated">要素の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML&quot;&gt;innerHTMLを&lt;/a&gt;更新します（新しいウィンドウを開きます）。&lt;strong&gt;コンテンツはプレーンHTMLとして挿入されることに注意してください-それらはVueテンプレートとしてコンパイルされません&lt;/strong&gt;。 &lt;code&gt;v-html&lt;/code&gt; を使用してテンプレートを作成しようとしていることに気付いた場合は、代わりにコンポーネントを使用してソリューションを再考してみてください。</target>
        </trans-unit>
        <trans-unit id="b56a36977305fbcc90290b7281ac8a8f0c3bd604" translate="yes" xml:space="preserve">
          <source>Updates the element's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent&quot;&gt;textContent (opens new window)&lt;/a&gt;. If you need to update the part of &lt;code&gt;textContent&lt;/code&gt;, you should use &lt;a href=&quot;../guide/template-syntax#text&quot;&gt;mustache interpolations&lt;/a&gt; instead</source>
          <target state="translated">要素の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent&quot;&gt;textContentを&lt;/a&gt;更新します（新しいウィンドウを開きます）。 &lt;code&gt;textContent&lt;/code&gt; の一部を更新する必要がある場合は、代わりに&lt;a href=&quot;../guide/template-syntax#text&quot;&gt;口ひげ補間&lt;/a&gt;を使用する必要があります</target>
        </trans-unit>
        <trans-unit id="36c47365d1a0fe7112a5f7aa0465ebbfe1515656" translate="yes" xml:space="preserve">
          <source>Updating all these nodes efficiently can be difficult, but thankfully, we never have to do it manually. Instead, we tell Vue what HTML we want on the page, in a template:</source>
          <target state="translated">これらすべてのノードを効率的に更新するのは難しいかもしれませんが、ありがたいことに、手動で更新する必要はありません。その代わりに、テンプレートでページに表示させたい HTML を Vue に伝えます。</target>
        </trans-unit>
        <trans-unit id="728bcaed30d135845ad4d9727bb2fedf3ab532fd" translate="yes" xml:space="preserve">
          <source>Updating all these nodes efficiently can be difficult, but thankfully, you never have to do it manually. Instead, you tell Vue what HTML you want on the page, in a template:</source>
          <target state="translated">これらすべてのノードを効率的に更新するのは難しいかもしれませんが、ありがたいことに、手動で更新する必要はありません。代わりに、テンプレートでページに表示する HTML を Vue に指定します。</target>
        </trans-unit>
        <trans-unit id="df5f7691ac781f41ca5afafd2680476339c01140" translate="yes" xml:space="preserve">
          <source>Upgrade Path</source>
          <target state="translated">アップグレードパス</target>
        </trans-unit>
        <trans-unit id="ec1b871568c8f9b96404fba4999e4bb30bebeba0" translate="yes" xml:space="preserve">
          <source>Usage in Plugins</source>
          <target state="translated">プラグインでの使用法</target>
        </trans-unit>
        <trans-unit id="4904a06bbdeb879018def05329454362a6b30d64" translate="yes" xml:space="preserve">
          <source>Usage inside &lt;code&gt;v-for&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;v-for&lt;/code&gt; 内での使用-for</target>
        </trans-unit>
        <trans-unit id="f3a7118317b50bdd15b995e3d624b912b5b2b04f" translate="yes" xml:space="preserve">
          <source>Usage of &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">使い方 &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e644418d310386dee848ceb934d28e9af6afeacb" translate="yes" xml:space="preserve">
          <source>Usage on Components</source>
          <target state="translated">コンポーネントでの使用法</target>
        </trans-unit>
        <trans-unit id="f552ba1fe9fac09e7847e64d87dc1587fbb26d11" translate="yes" xml:space="preserve">
          <source>Usage with JSX</source>
          <target state="translated">JSXでの使用法</target>
        </trans-unit>
        <trans-unit id="c7ba388099a4f8ff3ba8295c16666928b0c410e2" translate="yes" xml:space="preserve">
          <source>Usage with Render Functions</source>
          <target state="translated">レンダー関数での使用法</target>
        </trans-unit>
        <trans-unit id="a74099084c0693149248e8ca16d0bd6b67bb5c59" translate="yes" xml:space="preserve">
          <source>Usage with Templates</source>
          <target state="translated">テンプレートを使った使い方</target>
        </trans-unit>
        <trans-unit id="a4ee016fea5ce9a71d77f20f1124659e54e0db2b" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://github.com/rollup/plugins/tree/master/packages/replace&quot;&gt;@rollup/plugin-replace (opens new window)&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/rollup/plugins/tree/master/packages/replace&quot;&gt;@ rollup / plugin-replaceを&lt;/a&gt;使用します（新しいウィンドウを開きます）：</target>
        </trans-unit>
        <trans-unit id="4358eb815c9ed342dae4a95fe44e11cf8da5da2f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://github.com/rollup/rollup-plugin-replace&quot;&gt;rollup-plugin-replace&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/rollup/rollup-plugin-replace&quot;&gt;rollup-plugin-replaceを&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="770eccd63737a87d0af971af27197f8bcf7a45af" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://lodash.com/docs/4.15.0#debounce&quot;&gt;lodash&amp;rsquo;s &lt;code&gt;debounce&lt;/code&gt;&lt;/a&gt; (or possibly &lt;a href=&quot;https://lodash.com/docs/4.15.0#throttle&quot;&gt;&lt;code&gt;throttle&lt;/code&gt;&lt;/a&gt;) to directly limit calling the expensive method. You can achieve the same as above like this:</source>
          <target state="translated">&lt;a href=&quot;https://lodash.com/docs/4.15.0#debounce&quot;&gt;lodashの &lt;code&gt;debounce&lt;/code&gt; &lt;/a&gt;（または&lt;a href=&quot;https://lodash.com/docs/4.15.0#throttle&quot;&gt; &lt;code&gt;throttle&lt;/code&gt; &lt;/a&gt;）を使用して、高価なメソッドの呼び出しを直接制限します。あなたはこのように上記と同じことを達成することができます：</target>
        </trans-unit>
        <trans-unit id="f776d9fd3fd7d4cf6f4d0ff2c7bfb1f591f9665e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://lodash.com/docs/4.15.0#orderBy&quot;&gt;lodash&amp;rsquo;s &lt;code&gt;orderBy&lt;/code&gt;&lt;/a&gt; (or possibly &lt;a href=&quot;https://lodash.com/docs/4.15.0#sortBy&quot;&gt;&lt;code&gt;sortBy&lt;/code&gt;&lt;/a&gt;) in a computed property:</source>
          <target state="translated">使用&lt;a href=&quot;https://lodash.com/docs/4.15.0#orderBy&quot;&gt;lodashの &lt;code&gt;orderBy&lt;/code&gt; &lt;/a&gt;（または可能性&lt;a href=&quot;https://lodash.com/docs/4.15.0#sortBy&quot;&gt; &lt;code&gt;sortBy&lt;/code&gt; &lt;/a&gt;計算されたプロパティで）：</target>
        </trans-unit>
        <trans-unit id="6b65b00b4f349332f98c19c8c7946c443739424f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt;&lt;code&gt;beforeRouteEnter&lt;/code&gt;&lt;/a&gt; in the component instead.</source>
          <target state="translated">代わりに、コンポーネントで&lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt; &lt;code&gt;beforeRouteEnter&lt;/code&gt; &lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="ee4b6a0918785a35f0aff111346b42f9d5ed745a" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt;&lt;code&gt;beforeRouteLeave&lt;/code&gt;&lt;/a&gt; in the component instead.</source>
          <target state="translated">代わりに、コンポーネントで&lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt; &lt;code&gt;beforeRouteLeave&lt;/code&gt; &lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="3b146a4d03f95af25cb10c2b0020494c65743663" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#perroute-guard&quot;&gt;&lt;code&gt;beforeEnter&lt;/code&gt;&lt;/a&gt; in the route instead.</source>
          <target state="translated">代わりに、ルートの&lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#perroute-guard&quot;&gt; &lt;code&gt;beforeEnter&lt;/code&gt; &lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="33f1e610a57929c4e74366b0a8a6bb3ea3c38c36" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;$parent&lt;/code&gt; and &lt;code&gt;$children&lt;/code&gt; sparingly - they mostly serve as an escape-hatch. Prefer using props and events for parent-child communication.</source>
          <target state="translated">&lt;code&gt;$parent&lt;/code&gt; と &lt;code&gt;$children&lt;/code&gt; 控えめに使用してください-それらはほとんどエスケープハッチとして機能します。親子のコミュニケーションには小道具やイベントを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="ae236c5510e3bb66bf05b93a526a41048c00529d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Array.prototype.splice&lt;/code&gt; instead. For example:</source>
          <target state="translated">代わりに &lt;code&gt;Array.prototype.splice&lt;/code&gt; を使用してください。例えば：</target>
        </trans-unit>
        <trans-unit id="0de57bc92cbef9103a4feec014e70c0e78ec2fde" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Vue.set&lt;/code&gt; instead.</source>
          <target state="translated">代わりに &lt;code&gt;Vue.set&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="b9da9bf6c22c0cbdcaec5f091c5322fc90e7ae5a" translate="yes" xml:space="preserve">
          <source>Use JavaScript&amp;rsquo;s built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Examples&quot;&gt;&lt;code&gt;.filter&lt;/code&gt; method&lt;/a&gt; in a computed property:</source>
          <target state="translated">計算プロパティでJavaScriptの組み込み&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Examples&quot;&gt; &lt;code&gt;.filter&lt;/code&gt; メソッド&lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="003bf1a1826ab5d9749321efe03218bdcb718541" translate="yes" xml:space="preserve">
          <source>Use JavaScript&amp;rsquo;s built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Examples&quot;&gt;&lt;code&gt;.slice&lt;/code&gt; method&lt;/a&gt; in a computed property:</source>
          <target state="translated">計算プロパティでJavaScriptの組み込み&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Examples&quot;&gt; &lt;code&gt;.slice&lt;/code&gt; メソッド&lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="e7e721c416e04d64ab5e5780f342a54b19396986" translate="yes" xml:space="preserve">
          <source>Use a custom in-DOM check in other hooks. For example, to replace:</source>
          <target state="translated">他のフックでカスタムのin-domチェックを使用します。例えば、置換する。</target>
        </trans-unit>
        <trans-unit id="181538426a8718fe366424835db6e5717dd50aee" translate="yes" xml:space="preserve">
          <source>Use actual heading tags instead of styling text to give the visual appearance of headings</source>
          <target state="translated">見出しの視覚的な外観を与えるために、テキストをスタイリングする代わりに実際の見出しタグを使用します。</target>
        </trans-unit>
        <trans-unit id="81da353e3fb3a59a8169efc41ef1b1548bc374a5" translate="yes" xml:space="preserve">
          <source>Use components instead.</source>
          <target state="translated">代わりにコンポーネントを使用します。</target>
        </trans-unit>
        <trans-unit id="b1b6155be32a2fc7dfe3a4813d55af8d925da09a" translate="yes" xml:space="preserve">
          <source>Use global mixins sparsely and carefully, because it affects every single Vue instance created, including third party components. In most cases, you should only use it for custom option handling like demonstrated in the example above. It&amp;rsquo;s also a good idea to ship them as &lt;a href=&quot;plugins&quot;&gt;Plugins&lt;/a&gt; to avoid duplicate application.</source>
          <target state="translated">グローバルミックスインは、サードパーティのコンポーネントを含め、作成されたすべてのVueインスタンスに影響を与えるため、まばらかつ慎重に使用してください。ほとんどの場合、上記の例で示したようなカスタムオプションの処理にのみ使用する必要があります。また、アプリケーションの重複を避けるため、&lt;a href=&quot;plugins&quot;&gt;プラグイン&lt;/a&gt;として出荷することもお勧めします。</target>
        </trans-unit>
        <trans-unit id="85c08ee2f7039cb44ad9c33cd944c4130587b85f" translate="yes" xml:space="preserve">
          <source>Use plugins by calling the &lt;code&gt;Vue.use()&lt;/code&gt; global method. This has to be done before you start your app by calling &lt;code&gt;new Vue()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Vue.use()&lt;/code&gt; グローバルメソッドを呼び出してプラグインを使用します。これは、 &lt;code&gt;new Vue()&lt;/code&gt; 呼び出してアプリを起動する前に行う必要があります。</target>
        </trans-unit>
        <trans-unit id="8f8e44f9d7cf511d97072bab1fc39f6bfbb414fe" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt; for the optimal debugging experience.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt;を使用して、最適なデバッグエクスペリエンスを実現してください。</target>
        </trans-unit>
        <trans-unit id="fef0499237cdabcdb792468442be5967c7e8686b" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;created&lt;/code&gt; hook instead.</source>
          <target state="translated">代わりに、 &lt;code&gt;created&lt;/code&gt; フックを使用してください。</target>
        </trans-unit>
        <trans-unit id="74f29cc48c4d34caf8438d092e7f5db6485b0b48" translate="yes" xml:space="preserve">
          <source>Use the component&amp;rsquo;s &lt;a href=&quot;../api/index#beforeDestroy&quot;&gt;&lt;code&gt;beforeDestroy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../api/index#destroyed&quot;&gt;&lt;code&gt;destroyed&lt;/code&gt;&lt;/a&gt; hooks instead.</source>
          <target state="translated">代わりに、コンポーネントの&lt;a href=&quot;../api/index#beforeDestroy&quot;&gt; &lt;code&gt;beforeDestroy&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../api/index#destroyed&quot;&gt; &lt;code&gt;destroyed&lt;/code&gt; &lt;/a&gt;フックを使用してください。</target>
        </trans-unit>
        <trans-unit id="537e927a3b754157432123069801236c6891d42d" translate="yes" xml:space="preserve">
          <source>Use the native DOM API:</source>
          <target state="translated">ネイティブの DOM API を使用します。</target>
        </trans-unit>
        <trans-unit id="49f7c44dbc505ff4b6fe57133375f62aee01c648" translate="yes" xml:space="preserve">
          <source>Use the new &lt;code&gt;beforeCreate&lt;/code&gt; hook instead, which is essentially the same thing. It was renamed for consistency with other lifecycle methods.</source>
          <target state="translated">代わりに新しい &lt;code&gt;beforeCreate&lt;/code&gt; フックを使用してください。これは基本的に同じことです。他のライフサイクルメソッドとの一貫性を保つために名前が変更されました。</target>
        </trans-unit>
        <trans-unit id="4c301d9951079bd9b87dc0a676559de31cdc0957" translate="yes" xml:space="preserve">
          <source>Use the new &lt;code&gt;mounted&lt;/code&gt; hook instead.</source>
          <target state="translated">代わりに、新しく &lt;code&gt;mounted&lt;/code&gt; フックを使用してください。</target>
        </trans-unit>
        <trans-unit id="f3d602cbc444cd25effed3179178c8fe1d36b0d9" translate="yes" xml:space="preserve">
          <source>Use the new &lt;code&gt;mounted&lt;/code&gt; hook instead. It should be noted though that with &lt;code&gt;mounted&lt;/code&gt;, there&amp;rsquo;s no guarantee to be in-document. For that, also include &lt;code&gt;Vue.nextTick&lt;/code&gt;/&lt;code&gt;vm.$nextTick&lt;/code&gt;. For example:</source>
          <target state="translated">代わりに、新しく &lt;code&gt;mounted&lt;/code&gt; フックを使用してください。ただし、 &lt;code&gt;mounted&lt;/code&gt; では、ドキュメント内である保証はありません。そのためには、 &lt;code&gt;Vue.nextTick&lt;/code&gt; / &lt;code&gt;vm.$nextTick&lt;/code&gt; も含めます。例えば：</target>
        </trans-unit>
        <trans-unit id="b4605b49670d374a5aa51ee71b7ef52006c5d7a3" translate="yes" xml:space="preserve">
          <source>Use the official &lt;a href=&quot;#cli&quot;&gt;CLI&lt;/a&gt; to scaffold a project, which provides batteries-included build setups for a modern frontend workflow (e.g., hot-reload, lint-on-save, and much more)</source>
          <target state="translated">公式&lt;a href=&quot;#cli&quot;&gt;CLI&lt;/a&gt;を使用して、プロジェクトの足場を作成します。プロジェクトは、最新のフロントエンドワークフロー（ホットリロード、lint-on-saveなど）用のバッテリーを含むビルドセットアップを提供します。</target>
        </trans-unit>
        <trans-unit id="160b6d69d6038c85412ab8171ce4aea2da0fb502" translate="yes" xml:space="preserve">
          <source>Use with caution! Once you apply a mixin globally, it will affect &lt;strong&gt;every&lt;/strong&gt; component instance created afterwards in the given app (for example, child components):</source>
          <target state="translated">注意して使用してください！ミックスインをグローバルに適用すると、後で特定のアプリで作成さ&lt;strong&gt;れるすべての&lt;/strong&gt;コンポーネントインスタンス（子コンポーネントなど）に影響します。</target>
        </trans-unit>
        <trans-unit id="f909c50760bc08f177877869663a7491252c658f" translate="yes" xml:space="preserve">
          <source>Used for &lt;a href=&quot;../guide/component-dynamic-async&quot;&gt;dynamic components&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../guide/component-dynamic-async&quot;&gt;動的コンポーネントに&lt;/a&gt;使用されます。</target>
        </trans-unit>
        <trans-unit id="2e8398bc374e7299bcdc0bcd8814f8339b2d9b2f" translate="yes" xml:space="preserve">
          <source>Used for &lt;a href=&quot;../guide/components#Dynamic-Components&quot;&gt;dynamic components&lt;/a&gt; and to work around &lt;a href=&quot;../guide/components#DOM-Template-Parsing-Caveats&quot;&gt;limitations of in-DOM templates&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../guide/components#Dynamic-Components&quot;&gt;動的コンポーネントに&lt;/a&gt;使用され&lt;a href=&quot;../guide/components#DOM-Template-Parsing-Caveats&quot;&gt;、in-DOMテンプレートの制限を&lt;/a&gt;回避します。</target>
        </trans-unit>
        <trans-unit id="1747aa5023d3689b28a9d8a62ae870f54f3b5d5e" translate="yes" xml:space="preserve">
          <source>Used on content inserted into child components to indicate which named slot the content belongs to.</source>
          <target state="translated">子コンポーネントに挿入されたコンテンツに使用され、コンテンツがどの名前付きスロットに属しているかを示します。</target>
        </trans-unit>
        <trans-unit id="22127d9f3bc8fde382f2797750f0f521f655892f" translate="yes" xml:space="preserve">
          <source>Used to denote a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element as a scoped slot.</source>
          <target state="translated">&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 要素をスコープ付きスロットとして示すために使用されます。</target>
        </trans-unit>
        <trans-unit id="4331447ff379465e5cfbc7b6668bd16157a0f747" translate="yes" xml:space="preserve">
          <source>Used to denote an element or component as a scoped slot. The attribute&amp;rsquo;s value should be a valid JavaScript expression that can appear in the argument position of a function signature. This means in supported environments you can also use ES2015 destructuring in the expression. Serves as a replacement for &lt;a href=&quot;#scope-replaced&quot;&gt;&lt;code&gt;scope&lt;/code&gt;&lt;/a&gt; in 2.5.0+.</source>
          <target state="translated">要素またはコンポーネントをスコープ付きスロットとして示すために使用されます。属性の値は、関数シグネチャの引数の位置に表示できる有効なJavaScript式である必要があります。つまり、サポートされている環境では、式でES2015分解を使用することもできます。2.5.0以降では、&lt;a href=&quot;#scope-replaced&quot;&gt; &lt;code&gt;scope&lt;/code&gt; &lt;/a&gt;代替として機能します。</target>
        </trans-unit>
        <trans-unit id="6e2c7515c0dae7baac879187b01636fa11edecb1" translate="yes" xml:space="preserve">
          <source>Used to programmatically access &lt;a href=&quot;../guide/components#Scoped-Slots&quot;&gt;scoped slots&lt;/a&gt;. For each slot, including the &lt;code&gt;default&lt;/code&gt; one, the object contains a corresponding function that returns VNodes.</source>
          <target state="translated">プログラムで&lt;a href=&quot;../guide/components#Scoped-Slots&quot;&gt;スコープスロットに&lt;/a&gt;アクセスするために使用されます。 &lt;code&gt;default&lt;/code&gt; スロットを含む各スロットについて、オブジェクトにはVNodeを返す対応する関数が含まれています。</target>
        </trans-unit>
        <trans-unit id="76072ee6b19562b61739da43c75a8552a434c5d4" translate="yes" xml:space="preserve">
          <source>Used to programmatically access content &lt;a href=&quot;../guide/component-basics#content-distribution-with-slots&quot;&gt;distributed by slots&lt;/a&gt;. Each &lt;a href=&quot;../guide/component-slots#named-slots&quot;&gt;named slot&lt;/a&gt; has its own corresponding property (e.g. the contents of &lt;code&gt;v-slot:foo&lt;/code&gt; will be found at &lt;code&gt;this.$slots.foo()&lt;/code&gt;). The &lt;code&gt;default&lt;/code&gt; property contains either nodes not included in a named slot or contents of &lt;code&gt;v-slot:default&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../guide/component-basics#content-distribution-with-slots&quot;&gt;スロットによって配布される&lt;/a&gt;コンテンツにプログラムでアクセスするために使用されます。それぞれの&lt;a href=&quot;../guide/component-slots#named-slots&quot;&gt;名前のスロットは&lt;/a&gt;独自の対応する性質を持っている（例えばの内容 &lt;code&gt;v-slot:foo&lt;/code&gt; で発見され &lt;code&gt;this.$slots.foo()&lt;/code&gt; ）。 &lt;code&gt;default&lt;/code&gt; プロパティは、名前付きのスロットまたは内容に含まれていないいずれかのノードが含ま &lt;code&gt;v-slot:default&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d8b5683fd652bb8adfa41ec534ebcd919be8706" translate="yes" xml:space="preserve">
          <source>Used to programmatically access content &lt;a href=&quot;../guide/components#Content-Distribution-with-Slots&quot;&gt;distributed by slots&lt;/a&gt;. Each &lt;a href=&quot;../guide/components#Named-Slots&quot;&gt;named slot&lt;/a&gt; has its own corresponding property (e.g. the contents of &lt;code&gt;v-slot:foo&lt;/code&gt; will be found at &lt;code&gt;vm.$slots.foo&lt;/code&gt;). The &lt;code&gt;default&lt;/code&gt; property contains either nodes not included in a named slot or contents of &lt;code&gt;v-slot:default&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../guide/components#Content-Distribution-with-Slots&quot;&gt;スロットによって分散された&lt;/a&gt;コンテンツにプログラムでアクセスするために使用されます。それぞれの&lt;a href=&quot;../guide/components#Named-Slots&quot;&gt;名前のスロットは&lt;/a&gt;独自の対応する性質がある（例えばの内容 &lt;code&gt;v-slot:foo&lt;/code&gt; で発見され &lt;code&gt;vm.$slots.foo&lt;/code&gt; ）。 &lt;code&gt;default&lt;/code&gt; プロパティは、名前付きのスロットまたは内容に含まれていないいずれかのノードが含ま &lt;code&gt;v-slot:default&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e6bf115dec713a7c40e6db8b7a9b940453656d5" translate="yes" xml:space="preserve">
          <source>User Agent Accessibility Guidelines (UAAG) (opens new window)</source>
          <target state="translated">ユーザーエージェントアクセシビリティガイドライン(UAAG)(新しいウィンドウが開きます</target>
        </trans-unit>
        <trans-unit id="57f2b181d0a5e79a147ea1cdf41457f58dbbb3c9" translate="yes" xml:space="preserve">
          <source>Users</source>
          <target state="translated">Users</target>
        </trans-unit>
        <trans-unit id="88c450bf7dc4b899fc608077fc184ec1727d8b1a" translate="yes" xml:space="preserve">
          <source>Users can navigate an application through headings. Having descriptive headings for every section of your application makes it easier for users to predict the content of each section. When it comes to headings, there are a couple of recommended accessibility practices:</source>
          <target state="translated">ユーザーは見出しを使ってアプリケーションをナビゲートすることができます。アプリケーションの各セクションに説明的な見出しをつけると、ユーザーが各セクションの内容を予測しやすくなります。見出しに関しては、いくつかの推奨されるアクセシビリティの実践方法があります。</target>
        </trans-unit>
        <trans-unit id="cf2aa5abde13c9a2b4d796246137c973fbb88554" translate="yes" xml:space="preserve">
          <source>Users must be able to access the content as technologies advance</source>
          <target state="translated">技術の進歩に伴い、ユーザーがコンテンツにアクセスできるようにする必要がある</target>
        </trans-unit>
        <trans-unit id="f9a271e1f44586e5083fc1918fdaffbb8a054342" translate="yes" xml:space="preserve">
          <source>Users must be able to perceive the information being presented</source>
          <target state="translated">ユーザーは、提示された情報を知覚することができる必要があります。</target>
        </trans-unit>
        <trans-unit id="589f322b8166b58e4896f447ee126a460ba0bbe3" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-labelledby_attribute&quot;&gt;&lt;code&gt;aria-labelledby&lt;/code&gt; (opens new window)&lt;/a&gt; is similar to &lt;code&gt;aria-label&lt;/code&gt; expect it is used if the label text is visible on screen. It is paired to other elements by their &lt;code&gt;id&lt;/code&gt; and you can link multiple &lt;code&gt;id&lt;/code&gt;s:</source>
          <target state="translated">使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-labelledby_attribute&quot;&gt; &lt;code&gt;aria-labelledby&lt;/code&gt; （新しいウィンドウが開きます）&lt;/a&gt;に似ています &lt;code&gt;aria-label&lt;/code&gt; ラベルテキストを画面上に表示されている場合、それが使用されて期待しています。 &lt;code&gt;id&lt;/code&gt; によって他の要素とペアになり、複数の &lt;code&gt;id&lt;/code&gt; をリンクできます。</target>
        </trans-unit>
        <trans-unit id="fa62aeea16980ec64983f9904128d289d5c289d1" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;$emit&lt;/code&gt; with additional arguments:</source>
          <target state="translated">追加の引数を指定して &lt;code&gt;$emit&lt;/code&gt; を使用する：</target>
        </trans-unit>
        <trans-unit id="12da60edc3ad2c7b70d8e9cce9f0a9df3bfdda28" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;$emit&lt;/code&gt; with only an event name:</source>
          <target state="translated">イベント名のみで &lt;code&gt;$emit&lt;/code&gt; を使用する：</target>
        </trans-unit>
        <trans-unit id="6dd92839e80d19c8ccf3963667869ebe9c723664" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;keyCode&lt;/code&gt; attributes is also permitted:</source>
          <target state="translated">&lt;code&gt;keyCode&lt;/code&gt; 属性の使用も許可されています。</target>
        </trans-unit>
        <trans-unit id="08b4f74f4b29aefd57fecf9253958e21fc91a467" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;provide&lt;/code&gt; (discussed &lt;a href=&quot;#provide-inject&quot;&gt;below&lt;/a&gt;) should also be considered as an alternative to &lt;code&gt;globalProperties&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;provide&lt;/code&gt; （&lt;a href=&quot;#provide-inject&quot;&gt;以下で&lt;/a&gt;説明）の使用も、 &lt;code&gt;globalProperties&lt;/code&gt; の代替として検討する必要があります。</target>
        </trans-unit>
        <trans-unit id="890d71127137c4c4cd4e9d9a52e044f00ece5fd0" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;provide&lt;/code&gt; is especially useful when writing a plugin, as an alternative to &lt;code&gt;globalProperties&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;provide&lt;/code&gt; 使用は、 &lt;code&gt;globalProperties&lt;/code&gt; の代わりに、プラグインを作成するときに特に役立ちます。</target>
        </trans-unit>
        <trans-unit id="3b86076651686c0fbe2de9bc0df0db687049714e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-bind.sync&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;v-bind.sync&lt;/code&gt; の使用</target>
        </trans-unit>
        <trans-unit id="520de81fd3ca0b36aa8f7bf6d1956e1927c8833d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-bind.sync&lt;/code&gt; with a literal object, such as in &lt;code&gt;v-bind.sync=&amp;rdquo;{ title: doc.title }&amp;rdquo;&lt;/code&gt;, will not work, because there are too many edge cases to consider in parsing a complex expression like this.</source>
          <target state="translated">&lt;code&gt;v-bind.sync=&amp;rdquo;{ title: doc.title }&amp;rdquo;&lt;/code&gt; ように、リテラルオブジェクトで &lt;code&gt;v-bind.sync&lt;/code&gt; を使用しても機能しません。これは、このような複雑な式を解析する際に考慮すべきエッジケースが多すぎるためです。 。</target>
        </trans-unit>
        <trans-unit id="cb9ed6a801a2b736f9a0652c49f9728b264bc60a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-for=&quot;user in activeUsers&quot;&lt;/code&gt;, we &lt;em&gt;only&lt;/em&gt; iterate over active users during render, making rendering much more efficient.</source>
          <target state="translated">使用して &lt;code&gt;v-for=&quot;user in activeUsers&quot;&lt;/code&gt; 、我々は&lt;em&gt;唯一&lt;/em&gt;はるかに効率的なレンダリングを作り、レンダリング時のアクティブユーザーを反復処理します。</target>
        </trans-unit>
        <trans-unit id="35b55bd9e1ce580fb7b538c51534550ec7476474" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; together is &lt;strong&gt;not recommended&lt;/strong&gt;. See the &lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;style guide&lt;/a&gt; for further information.</source>
          <target state="translated">&lt;code&gt;v-if&lt;/code&gt; と &lt;code&gt;v-for&lt;/code&gt; を一緒に使用することは&lt;strong&gt;お勧めしません&lt;/strong&gt;。詳細については、&lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;スタイルガイド&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e65c164b999421d82c5e3d232a414fe76b72cd6b" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; together is &lt;strong&gt;not recommended&lt;/strong&gt;. See the &lt;a href=&quot;../style-guide/index#avoid-v-if-with-v-for-essential&quot;&gt;style guide&lt;/a&gt; for further information.</source>
          <target state="translated">&lt;code&gt;v-if&lt;/code&gt; と &lt;code&gt;v-for&lt;/code&gt; を一緒に使用することは&lt;strong&gt;お勧めしません&lt;/strong&gt;。詳細については、&lt;a href=&quot;../style-guide/index#avoid-v-if-with-v-for-essential&quot;&gt;スタイルガイド&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d08436e8dc76f8135756ac6e58f6c2e883ec453a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-model&lt;/code&gt; on Components</source>
          <target state="translated">コンポーネントでの &lt;code&gt;v-model&lt;/code&gt; 使用</target>
        </trans-unit>
        <trans-unit id="61103105b06a8a12d7a44547eb3823dbfa7110a6" translate="yes" xml:space="preserve">
          <source>Using Inject</source>
          <target state="translated">インジェクトの使用</target>
        </trans-unit>
        <trans-unit id="32bec21c8cee3e33b5dac0046a374df3c2c48880" translate="yes" xml:space="preserve">
          <source>Using JavaScript Expressions</source>
          <target state="translated">JavaScriptの表現を使う</target>
        </trans-unit>
        <trans-unit id="132307a32976d23c3e63eb2beb64895a6f3b8113" translate="yes" xml:space="preserve">
          <source>Using Provide</source>
          <target state="translated">Provide の使用</target>
        </trans-unit>
        <trans-unit id="5d3e224c9ece88fc5daf98825603dfa596a858f9" translate="yes" xml:space="preserve">
          <source>Using Transitions and Animations Together</source>
          <target state="translated">トランジションとアニメーションの併用</target>
        </trans-unit>
        <trans-unit id="b579cc565a1407302b51f876ebcc73fcff092577" translate="yes" xml:space="preserve">
          <source>Using a Plugin</source>
          <target state="translated">プラグインを使う</target>
        </trans-unit>
        <trans-unit id="9cf1549aea5e4ae2e67b0407f6b2344a0f1eb294" translate="yes" xml:space="preserve">
          <source>Using a watcher to compare values of an array or object that are reactive requires that it has a copy made of just the values.</source>
          <target state="translated">反応性のある配列やオブジェクトの値を比較するためにウォッチャーを使用するには、値だけのコピーを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="0336a05c8502e8781bee82f0a3465066267e8899" translate="yes" xml:space="preserve">
          <source>Using an injected value as data entry:</source>
          <target state="translated">注入された値をデータ入力として使用する</target>
        </trans-unit>
        <trans-unit id="ee566e9a4742cc53aa6541d4b3218cedba54e109" translate="yes" xml:space="preserve">
          <source>Using an injected value as the default for a prop:</source>
          <target state="translated">インジェクションされた値をプロップのデフォルトとして使用します。</target>
        </trans-unit>
        <trans-unit id="cadb29867f8bf5340110eea6965faf58a3f6b48a" translate="yes" xml:space="preserve">
          <source>Using multiple teleports on the same target</source>
          <target state="translated">同じターゲットに複数のテレポートを使用する</target>
        </trans-unit>
        <trans-unit id="33e60545192243d051978512aa4ed96cc42d4d52" translate="yes" xml:space="preserve">
          <source>Using our &lt;code&gt;&amp;lt;dynamic-heading&amp;gt;&lt;/code&gt; example from before, here is how it would look now.</source>
          <target state="translated">私たちの使用 &lt;code&gt;&amp;lt;dynamic-heading&amp;gt;&lt;/code&gt; ここでは、前からの例は、それが今どのように見えるかです。</target>
        </trans-unit>
        <trans-unit id="59268f2ba7d914bcab2c86e53d4606060ae7fc63" translate="yes" xml:space="preserve">
          <source>Using our &lt;code&gt;MyMap&lt;/code&gt; component, our code can be updated as follows:</source>
          <target state="translated">&lt;code&gt;MyMap&lt;/code&gt; コンポーネントを使用すると、コードを次のように更新できます。</target>
        </trans-unit>
        <trans-unit id="bc842072bfc033f9a866308b4dcf7050475c4957" translate="yes" xml:space="preserve">
          <source>Using our &lt;code&gt;MyMap&lt;/code&gt; component, our provided values can be refactored as the following:</source>
          <target state="translated">&lt;code&gt;MyMap&lt;/code&gt; コンポーネントを使用すると、提供された値を次のようにリファクタリングできます。</target>
        </trans-unit>
        <trans-unit id="b9e1a63d9acef5fd371c928b3e6b7280614408e1" translate="yes" xml:space="preserve">
          <source>Using our &lt;code&gt;MyMarker&lt;/code&gt; component, we can refactor it with the following code:</source>
          <target state="translated">&lt;code&gt;MyMarker&lt;/code&gt; コンポーネントを使用して、次のコードでリファクタリングできます。</target>
        </trans-unit>
        <trans-unit id="86942fa2e2d5d629468c3dd32e1a6910c8344b97" translate="yes" xml:space="preserve">
          <source>Using our date-picker component example from the &lt;a href=&quot;#attribute-inheritance&quot;&gt;previous section&lt;/a&gt;, in the event we need to apply all non-prop attributes to the &lt;code&gt;input&lt;/code&gt; element rather than the root &lt;code&gt;div&lt;/code&gt; element, this can be accomplished by using the &lt;code&gt;v-bind&lt;/code&gt; shortcut.</source>
          <target state="translated">&lt;a href=&quot;#attribute-inheritance&quot;&gt;前のセクションの&lt;/a&gt;日付ピッカーコンポーネントの例を使用すると、ルート &lt;code&gt;div&lt;/code&gt; 要素ではなく &lt;code&gt;input&lt;/code&gt; 要素にすべての非prop属性を適用する必要がある場合、これは &lt;code&gt;v-bind&lt;/code&gt; ショートカットを使用して実行できます。</target>
        </trans-unit>
        <trans-unit id="a479ac1ba66150f457dfcfb3c03073ce4ece9b05" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;$listeners&lt;/code&gt; property, you can forward all event listeners on the component to a specific child element with &lt;code&gt;v-on=&quot;$listeners&quot;&lt;/code&gt;. For elements like &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, that you also want to work with &lt;code&gt;v-model&lt;/code&gt;, it&amp;rsquo;s often useful to create a new computed property for listeners, like &lt;code&gt;inputListeners&lt;/code&gt; below:</source>
          <target state="translated">&lt;code&gt;$listeners&lt;/code&gt; プロパティを使用すると、 &lt;code&gt;v-on=&quot;$listeners&quot;&lt;/code&gt; を使用して、コンポーネントのすべてのイベントリスナーを特定の子要素に転送できます。 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; のような要素で、 &lt;code&gt;v-model&lt;/code&gt; も操作したい場合、以下の &lt;code&gt;inputListeners&lt;/code&gt; のように、リスナーの新しい計算済みプロパティを作成すると便利な場合があります。</target>
        </trans-unit>
        <trans-unit id="a02a4af8d1e455a687fdc66fdceb59a54e15b8f3" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&amp;lt;dynamic-heading&amp;gt;&lt;/code&gt; component, which is responsible for rendering out the appropriate heading (i.e., &lt;code&gt;h1&lt;/code&gt;, &lt;code&gt;h2&lt;/code&gt;, &lt;code&gt;h3&lt;/code&gt;, etc.), this could have been written as a single-file component in 2.x as:</source>
          <target state="translated">適切な見出し（つまり、 &lt;code&gt;h1&lt;/code&gt; 、 &lt;code&gt;h2&lt;/code&gt; 、 &lt;code&gt;h3&lt;/code&gt; など）のレンダリングを担当する &lt;code&gt;&amp;lt;dynamic-heading&amp;gt;&lt;/code&gt; コンポーネントを使用すると、これは2.xで次のように単一ファイルコンポーネントとして記述できます。</target>
        </trans-unit>
        <trans-unit id="c482d5a66a3ed1e5cc31f6c18a950ad5c8ab15d8" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; described &lt;a href=&quot;#Other-Examples&quot;&gt;here&lt;/a&gt; as an example, here&amp;rsquo;s the equivalent usage using &lt;code&gt;slot-scope&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; 説明&lt;a href=&quot;#Other-Examples&quot;&gt;ここで&lt;/a&gt;、一例として、ここで使用して同等の使いの &lt;code&gt;slot-scope&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f458b4647572808c3369e3942c8038e15c728d5b" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;debounce&lt;/code&gt; attribute, there&amp;rsquo;d be no way to detect the &amp;ldquo;Typing&amp;rdquo; state, because we lose access to the input&amp;rsquo;s real-time state. By decoupling the debounce function from Vue however, we&amp;rsquo;re able to debounce only the operation we want to limit, removing the limits on features we can develop:</source>
          <target state="translated">&lt;code&gt;debounce&lt;/code&gt; 属性を使用すると、入力のリアルタイム状態にアクセスできなくなるため、「タイピング」状態を検出する方法はありません。ただし、デバウンス機能をVueから分離することで、制限したい操作のみをデバウンスして、開発可能な機能の制限を取り除くことができます。</target>
        </trans-unit>
        <trans-unit id="a87de46920f91d20c4a8374d7b0a5c7e603757dc" translate="yes" xml:space="preserve">
          <source>Using the example above, here is one example of how it could be implemented.</source>
          <target state="translated">上記の例を使用して、どのように実装することができるかの一例を紹介します。</target>
        </trans-unit>
        <trans-unit id="f3341dcb36ab8af8d89b35f44cc440d1a7d17430" translate="yes" xml:space="preserve">
          <source>Using the example above, there would only be one possible implementation of the code:</source>
          <target state="translated">上記の例を使用すると、コードの実装は1つの可能性しかありません。</target>
        </trans-unit>
        <trans-unit id="c9d5a2cbab66f55349694e4719943675255a69f1" translate="yes" xml:space="preserve">
          <source>Using the previously mentioned example of a &lt;code&gt;&amp;lt;dynamic-heading&amp;gt;&lt;/code&gt; component, here is how it looks now.</source>
          <target state="translated">前述の &lt;code&gt;&amp;lt;dynamic-heading&amp;gt;&lt;/code&gt; コンポーネントの例を使用して、現在の外観を次に示します。</target>
        </trans-unit>
        <trans-unit id="b55fb4e45a691d83cb89ad7b70f465e311afb55b" translate="yes" xml:space="preserve">
          <source>Using this strategy, we could even use Pikaday with several input elements, with each new instance automatically cleaning up after itself:</source>
          <target state="translated">この戦略を使えば、複数の入力要素を持つPikadayを使用することもでき、各新しいインスタンスはそれ自身の後始末を自動的に行います。</target>
        </trans-unit>
        <trans-unit id="420b1d24b2826ff84b27e5503c9d5fa275794cf8" translate="yes" xml:space="preserve">
          <source>Using with Composition API</source>
          <target state="translated">コンポジションAPIとの併用</target>
        </trans-unit>
        <trans-unit id="ef7c2de355d1860ca4480d839a4fbef456709fc8" translate="yes" xml:space="preserve">
          <source>Using with Options API</source>
          <target state="translated">オプションAPIでの使用</target>
        </trans-unit>
        <trans-unit id="1305a554f414402ea39d6c0eec337641f1f80daa" translate="yes" xml:space="preserve">
          <source>Using with Suspense</source>
          <target state="translated">サスペンスとの併用</target>
        </trans-unit>
        <trans-unit id="c2e76ca31176d1fccdd6bf8f9d90b0ddb005901f" translate="yes" xml:space="preserve">
          <source>Using with Vue components</source>
          <target state="translated">Vueコンポーネントでの使用</target>
        </trans-unit>
        <trans-unit id="aceea66ab4211a7caa0a8bc0030f6869c29b5f77" translate="yes" xml:space="preserve">
          <source>Usually it is not recommended to visually hide labels, even if the input has an accessible name. However, if the functionality of the input can be understood with surrounding content, then we can hide the visual label.</source>
          <target state="translated">通常、入力にアクセス可能な名前がついていても、ラベルを視覚的に非表示にすることは推奨されていません。しかし、入力の機能が周囲のコンテンツで理解できるのであれば、視覚的なラベルを非表示にすることができます。</target>
        </trans-unit>
        <trans-unit id="902c05ed61ffecdcb861a0a513fb2a3d4db8f937" translate="yes" xml:space="preserve">
          <source>Usually though, you&amp;rsquo;ll want every prop to be a specific type of value. In these cases, you can list props as an object, where the properties&amp;rsquo; names and values contain the prop names and types, respectively:</source>
          <target state="translated">ただし、通常は、すべての小道具を特定のタイプの値にする必要があります。これらの場合、プロパティの名前と値にそれぞれプロップ名とタイプが含まれるオブジェクトとしてプロップをリストできます。</target>
        </trans-unit>
        <trans-unit id="2c03a1928d0df3b20ddcf6357f95f4926b46174c" translate="yes" xml:space="preserve">
          <source>Usually though, you'll want every prop to be a specific type of value. In these cases, you can list props as an object, where the properties' names and values contain the prop names and types, respectively:</source>
          <target state="translated">しかし、通常はすべてのプロップを特定の型の値にしたいと思うでしょう。このような場合には、propをオブジェクトとしてリストアップし、プロパティの名前と値にそれぞれpropの名前と型が含まれます。</target>
        </trans-unit>
        <trans-unit id="f363e5aa689f12e08f65b4262f0add9ceb5a0b70" translate="yes" xml:space="preserve">
          <source>Usually, when we need to pass data from the parent to child component, we use &lt;a href=&quot;component-props&quot;&gt;props&lt;/a&gt;. Imagine the structure where you have some deeply nested components and you only need something from the parent component in the deep nested child. In this case, you still need to pass the prop down the whole component chain which might be annoying.</source>
          <target state="translated">通常、親コンポーネントから子コンポーネントにデータを渡す必要がある場合は、&lt;a href=&quot;component-props&quot;&gt;props&lt;/a&gt;を使用します。深くネストされたコンポーネントがいくつかあり、深くネストされた子の親コンポーネントから何かが必要なだけの構造を想像してみてください。この場合でも、コンポーネントチェーン全体に支柱を渡す必要があり、煩わしい場合があります。</target>
        </trans-unit>
        <trans-unit id="9e1f04aa32791204e8959162d55c6a61602685fd" translate="yes" xml:space="preserve">
          <source>VNode Interface</source>
          <target state="translated">VNode インタフェース</target>
        </trans-unit>
        <trans-unit id="d7fdca34045c394bdf9bbb0a0408e559b64e8a0a" translate="yes" xml:space="preserve">
          <source>VNode Props Format</source>
          <target state="translated">VNode プロップスのフォーマット</target>
        </trans-unit>
        <trans-unit id="2f99862e340a0893eee57fe6c2e3eeeed495dea2" translate="yes" xml:space="preserve">
          <source>VNodes Must Be Unique</source>
          <target state="translated">VNodesはユニークである必要があります</target>
        </trans-unit>
        <trans-unit id="49ce46f211c09d9aa88ca4b4b3542fca5ed37ba1" translate="yes" xml:space="preserve">
          <source>VNodes now have a flat props structure</source>
          <target state="translated">VNodesはフラットな小道具構造になりました。</target>
        </trans-unit>
        <trans-unit id="084ea9ddae2c0ecd015b716116978e8325213232" translate="yes" xml:space="preserve">
          <source>Validate Emitted Events</source>
          <target state="translated">発信されたイベントを検証する</target>
        </trans-unit>
        <trans-unit id="c12f8ca6eecbf13923d4270c3d2e0dc247e9cf95" translate="yes" xml:space="preserve">
          <source>Value Bindings</source>
          <target state="translated">値のバインディング</target>
        </trans-unit>
        <trans-unit id="942a2054dbdb4f692ee9d24cdf0ad9184052d0e9" translate="yes" xml:space="preserve">
          <source>Via CDN: &lt;code&gt;&amp;lt;script src=&quot;https://unpkg.com/vue@next&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;</source>
          <target state="translated">CDN経由： &lt;code&gt;&amp;lt;script src=&quot;https://unpkg.com/vue@next&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f32f685e7efba1be35060ac9fdaec19c6efdb60f" translate="yes" xml:space="preserve">
          <source>Video by &lt;a href=&quot;https://www.vuemastery.com&quot;&gt;Vue Mastery&lt;/a&gt;. Watch Vue Mastery&amp;rsquo;s free &lt;a href=&quot;https://www.vuemastery.com/courses/intro-to-vue-3/intro-to-vue3&quot;&gt;Intro to Vue course&lt;/a&gt;.</source>
          <target state="translated">ビデオ&lt;a href=&quot;https://www.vuemastery.com&quot;&gt;のVueマスタリー&lt;/a&gt;。VueMasteryの無料の&lt;a href=&quot;https://www.vuemastery.com/courses/intro-to-vue-3/intro-to-vue3&quot;&gt;Vue入門コースをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6c0753dc6ec65641eef8979902d3647c228f0b61" translate="yes" xml:space="preserve">
          <source>Video by &lt;a href=&quot;https://www.vuemastery.com&quot;&gt;Vue Mastery&lt;/a&gt;. Watch Vue Mastery&amp;rsquo;s free &lt;a href=&quot;https://www.vuemastery.com/courses/intro-to-vue-js/vue-instance/&quot;&gt;Intro to Vue course&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.vuemastery.com&quot;&gt;Vue Mastery&lt;/a&gt;によるビデオ。Vue Masteryの無料の&lt;a href=&quot;https://www.vuemastery.com/courses/intro-to-vue-js/vue-instance/&quot;&gt;Vue入門コースをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cab0d7e1c96c3ea19c16733af4fdea5420773df9" translate="yes" xml:space="preserve">
          <source>Virtual DOM</source>
          <target state="translated">仮想DOM</target>
        </trans-unit>
        <trans-unit id="df4ad933224c9c018075556e20e9443504c60df4" translate="yes" xml:space="preserve">
          <source>Visibility in headless mode</source>
          <target state="translated">ヘッドレスモードでの視認性</target>
        </trans-unit>
        <trans-unit id="97347f9404e482f1732d8abafe227157226e8e0e" translate="yes" xml:space="preserve">
          <source>Visitor &lt;em&gt;to the&lt;/em&gt; museum</source>
          <target state="translated">博物館&lt;em&gt;への&lt;/em&gt;訪問者</target>
        </trans-unit>
        <trans-unit id="47e69e75f6b5116df912c06bde68d77a66e8ffd9" translate="yes" xml:space="preserve">
          <source>Vite</source>
          <target state="translated">Vite</target>
        </trans-unit>
        <trans-unit id="3dee610647aa7d97b936e215cc6e8fa092669039" translate="yes" xml:space="preserve">
          <source>VoiceOver (opens new window)</source>
          <target state="translated">VoiceOver (新しいウィンドウが開きます)</target>
        </trans-unit>
        <trans-unit id="df144818169dcae305b2c6ce5856caa779bc88c2" translate="yes" xml:space="preserve">
          <source>Vue (pronounced /vjuː/, like &lt;strong&gt;view&lt;/strong&gt;) is a &lt;strong&gt;progressive framework&lt;/strong&gt; for building user interfaces. Unlike other monolithic frameworks, Vue is designed from the ground up to be incrementally adoptable. The core library is focused on the view layer only, and is easy to pick up and integrate with other libraries or existing projects. On the other hand, Vue is also perfectly capable of powering sophisticated Single-Page Applications when used in combination with &lt;a href=&quot;guide/single-file-component&quot;&gt;modern tooling&lt;/a&gt; and &lt;a href=&quot;https://github.com/vuejs/awesome-vue#components--libraries&quot;&gt;supporting libraries (opens new window)&lt;/a&gt;.</source>
          <target state="translated">Vue（&lt;strong&gt;viewの&lt;/strong&gt;ように/vjuː/と発音）は、ユーザーインターフェイスを構築するための&lt;strong&gt;進歩的なフレームワーク&lt;/strong&gt;です。他のモノリシックフレームワークとは異なり、Vueは段階的に採用できるようにゼロから設計されています。コアライブラリはビューレイヤーのみに焦点を当てており、他のライブラリや既存のプロジェクトを簡単に選択して統合できます。一方、Vueは、&lt;a href=&quot;guide/single-file-component&quot;&gt;最新のツール&lt;/a&gt;や&lt;a href=&quot;https://github.com/vuejs/awesome-vue#components--libraries&quot;&gt;サポートライブラリ&lt;/a&gt;と組み合わせて使用​​すると、高度なシングルページアプリケーションを完全に強化できます（新しいウィンドウが開きます）。</target>
        </trans-unit>
        <trans-unit id="1f1f3fe63ade848d4b754b1fabc84dc4fa1c76f2" translate="yes" xml:space="preserve">
          <source>Vue (pronounced /vjuː/, like &lt;strong&gt;view&lt;/strong&gt;) is a &lt;strong&gt;progressive framework&lt;/strong&gt; for building user interfaces. Unlike other monolithic frameworks, Vue is designed from the ground up to be incrementally adoptable. The core library is focused on the view layer only, and is easy to pick up and integrate with other libraries or existing projects. On the other hand, Vue is also perfectly capable of powering sophisticated Single-Page Applications when used in combination with &lt;a href=&quot;guide/single-file-components&quot;&gt;modern tooling&lt;/a&gt; and &lt;a href=&quot;https://github.com/vuejs/awesome-vue#components--libraries&quot;&gt;supporting libraries&lt;/a&gt;.</source>
          <target state="translated">VUEは、（発音/vjuː/、のような&lt;strong&gt;図&lt;/strong&gt;）である&lt;strong&gt;プログレッシブフレームワーク&lt;/strong&gt;のユーザインターフェイスを構築します。他のモノリシックフレームワークとは異なり、Vueは段階的に採用できるように一から設計されています。コアライブラリはビューレイヤーのみに焦点を当てており、他のライブラリや既存のプロジェクトを簡単に選択して統合できます。一方、Vueは、&lt;a href=&quot;guide/single-file-components&quot;&gt;最新のツール&lt;/a&gt;や&lt;a href=&quot;https://github.com/vuejs/awesome-vue#components--libraries&quot;&gt;サポートライブラリ&lt;/a&gt;と組み合わせて使用​​すると、洗練されたシングルページアプリケーションを完全に強化することもできます。</target>
        </trans-unit>
        <trans-unit id="dd79eece92c5ffe4c720051711e0f90d551d945b" translate="yes" xml:space="preserve">
          <source>Vue 2.x has a number of global APIs and configurations that globally mutate Vue&amp;rsquo;s behavior. For instance, to register a global component, you would use the &lt;code&gt;Vue.component&lt;/code&gt; API like this:</source>
          <target state="translated">Vue 2.xには、Vueの動作をグローバルに変更する多数のグローバルAPIと構成があります。たとえば、グローバルコンポーネントを登録するには、 &lt;code&gt;Vue.component&lt;/code&gt; ようにVue.componentAPIを使用します。</target>
        </trans-unit>
        <trans-unit id="893d303c551ebb9fe5672e80454924e163f7fe29" translate="yes" xml:space="preserve">
          <source>Vue 3 now offers an &lt;code&gt;emits&lt;/code&gt; option, similar to the existing &lt;code&gt;props&lt;/code&gt; option. This option can be used to define the events that a component can emit to its parent.</source>
          <target state="translated">Vue 3は、既存の &lt;code&gt;props&lt;/code&gt; オプションと同様に、 &lt;code&gt;emits&lt;/code&gt; オプションを提供するようになりました。このオプションを使用して、コンポーネントがその親に発行できるイベントを定義できます。</target>
        </trans-unit>
        <trans-unit id="cb7940d725dbd937d9de670c4768fc0ccd47788f" translate="yes" xml:space="preserve">
          <source>Vue CLI</source>
          <target state="translated">ビューCLI</target>
        </trans-unit>
        <trans-unit id="f0e97d04ea2024c1a4dbe8d36669c3d0551d334b" translate="yes" xml:space="preserve">
          <source>Vue Devtools</source>
          <target state="translated">Vue Devtools</target>
        </trans-unit>
        <trans-unit id="9b4162890a260c6325ca0e85fd029f15d2319406" translate="yes" xml:space="preserve">
          <source>Vue Docs Writing Guide</source>
          <target state="translated">Vue Docsライティングガイド</target>
        </trans-unit>
        <trans-unit id="bf53a6c36521f7bfb85181c1e488fc3bdefe2160" translate="yes" xml:space="preserve">
          <source>Vue Router</source>
          <target state="translated">ルータービュー</target>
        </trans-unit>
        <trans-unit id="1581d8a5ef292e49547c61633956998a288fd6aa" translate="yes" xml:space="preserve">
          <source>Vue Router 4.0 provides Vue 3 support and has a number of breaking changes of its own. Check out its &lt;a href=&quot;https://next.router.vuejs.org/guide/migration/&quot;&gt;migration guide (opens new window)&lt;/a&gt; for full details.</source>
          <target state="translated">Vue Router4.0はVue3のサポートを提供し、独自の重大な変更がいくつかあります。詳細については、&lt;a href=&quot;https://next.router.vuejs.org/guide/migration/&quot;&gt;移行ガイド（新しいウィンドウが開きます）&lt;/a&gt;を確認してください。</target>
        </trans-unit>
        <trans-unit id="e6e18b7a4f3086a13d2a0b9179ebded28163c885" translate="yes" xml:space="preserve">
          <source>Vue Test Utils</source>
          <target state="translated">ツールテストビュー</target>
        </trans-unit>
        <trans-unit id="a7d1880504f36bb5a94fba498a0a0cfb67577f83" translate="yes" xml:space="preserve">
          <source>Vue Test Utils is the official low-level component testing library that was written to provide users access to Vue specific APIs. If you are new to testing Vue applications, we would recommend using Vue Testing Library, which is an abstraction over Vue Test Utils.</source>
          <target state="translated">Vue Test Utils は、ユーザーが Vue 固有の API へのアクセスを提供するために書かれた公式の低レベル コンポーネント テスト ライブラリです。Vue アプリケーションのテストを初めて行う場合は、Vue Test Utils を抽象化した Vue Testing Library を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="10d701148514b6b1195422aa314e247a9c6ce4ed" translate="yes" xml:space="preserve">
          <source>Vue Testing Library (@testing-library/vue)</source>
          <target state="translated">Vue テスティングライブラリ (@testing-library/vue)</target>
        </trans-unit>
        <trans-unit id="0d00cb6f0b01ec3c037dd727f0b00f8ee2ebbd46" translate="yes" xml:space="preserve">
          <source>Vue Testing Library is a set of tools focused on testing components without relying on implementation details. Built with accessibility in mind, its approach also makes refactoring a breeze.</source>
          <target state="translated">Vue Testing Library は、実装の詳細に依存せずにコンポーネントをテストすることに焦点を当てたツール群です。アクセシビリティを考慮して構築されているため、そのアプローチはリファクタリングを容易にします。</target>
        </trans-unit>
        <trans-unit id="f859c56d5130177d3945e1dec6cc5a5f97ec3630" translate="yes" xml:space="preserve">
          <source>Vue accomplishes this by building a &lt;strong&gt;virtual DOM&lt;/strong&gt; to keep track of the changes it needs to make to the real DOM. Taking a closer look at this line:</source>
          <target state="translated">Vue は、実際のDOMに加える必要のある変更を追跡する&lt;strong&gt;仮想DOM&lt;/strong&gt;を構築することで、これを実現します。この行を詳しく見てみましょう：</target>
        </trans-unit>
        <trans-unit id="3c67c991de8300834c38a25c1ca2498be450c64f" translate="yes" xml:space="preserve">
          <source>Vue also exposes some built-in properties via the component instance, such as &lt;code&gt;$attrs&lt;/code&gt; and &lt;code&gt;$emit&lt;/code&gt;. These properties all have a &lt;code&gt;$&lt;/code&gt; prefix to avoid conflicting with user-defined property names.</source>
          <target state="translated">Vueは、 &lt;code&gt;$attrs&lt;/code&gt; や &lt;code&gt;$emit&lt;/code&gt; など、コンポーネントインスタンスを介していくつかの組み込みプロパティも公開します。これらのプロパティにはすべて、ユーザー定義のプロパティ名との競合を避けるために &lt;code&gt;$&lt;/code&gt; プレフィックスが付いています。</target>
        </trans-unit>
        <trans-unit id="125a9384e967ff4a8c66210cf14fc5911c587de4" translate="yes" xml:space="preserve">
          <source>Vue also offers the &lt;code&gt;.passive&lt;/code&gt; modifier, corresponding to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters&quot;&gt;&lt;code&gt;addEventListener&lt;/code&gt;&amp;lsquo;s &lt;code&gt;passive&lt;/code&gt; option&lt;/a&gt;.</source>
          <target state="translated">Vueは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters&quot;&gt; &lt;code&gt;addEventListener&lt;/code&gt; &lt;/a&gt;の &lt;code&gt;passive&lt;/code&gt; オプションに対応する &lt;code&gt;.passive&lt;/code&gt; 修飾子も提供します。</target>
        </trans-unit>
        <trans-unit id="adf689defceb2bc071b35560777fed6fba514f1f" translate="yes" xml:space="preserve">
          <source>Vue also offers the &lt;code&gt;.passive&lt;/code&gt; modifier, corresponding to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters&quot;&gt;&lt;code&gt;addEventListener&lt;/code&gt;'s &lt;code&gt;passive&lt;/code&gt; option (opens new window)&lt;/a&gt;.</source>
          <target state="translated">Vueは、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters&quot;&gt; &lt;code&gt;addEventListener&lt;/code&gt; &lt;/a&gt;の &lt;code&gt;passive&lt;/code&gt; オプション（新しいウィンドウを開く）に対応する &lt;code&gt;.passive&lt;/code&gt; 修飾子も提供します。</target>
        </trans-unit>
        <trans-unit id="605504cfd5ddde3ecc8c8b4f19e48e377a0c4f3d" translate="yes" xml:space="preserve">
          <source>Vue also provides the &lt;code&gt;v-model&lt;/code&gt; directive that makes two-way binding between form input and app state a breeze:</source>
          <target state="translated">Vueは、フォーム入力とアプリ状態の間の双方向バインディングを簡単にする &lt;code&gt;v-model&lt;/code&gt; ディレクティブも提供します。</target>
        </trans-unit>
        <trans-unit id="885b8f9999638cb0ba7b84d6b1e20f2e73c6af0f" translate="yes" xml:space="preserve">
          <source>Vue automatically binds the &lt;code&gt;this&lt;/code&gt; value for &lt;code&gt;methods&lt;/code&gt; so that it always refers to the component instance. This ensures that a method retains the correct &lt;code&gt;this&lt;/code&gt; value if it's used as an event listener or callback. You should avoid using arrow functions when defining &lt;code&gt;methods&lt;/code&gt;, as that prevents Vue from binding the appropriate &lt;code&gt;this&lt;/code&gt; value.</source>
          <target state="translated">Vueは、 &lt;code&gt;methods&lt;/code&gt; の &lt;code&gt;this&lt;/code&gt; 値を自動的にバインドして、常にコンポーネントインスタンスを参照するようにします。これにより、メソッドがイベントリスナーまたはコールバックとして使用された場合に、メソッドが正しい &lt;code&gt;this&lt;/code&gt; 値を保持することが保証されます。 &lt;code&gt;methods&lt;/code&gt; 定義するときに矢印関数を使用することは避けてください。 &lt;code&gt;this&lt;/code&gt; により、Vueが適切なこの値をバインドできなくなります。</target>
        </trans-unit>
        <trans-unit id="9ca242d2d873eee02c1c2067409c6aa7de3fbf37" translate="yes" xml:space="preserve">
          <source>Vue can help. Since SVGs are just data, we only need examples of what these creatures look like when excited, thinking, or alarmed. Then Vue can help transition between these states, making your welcome pages, loading indicators, and notifications more emotionally compelling.</source>
          <target state="translated">Vueがお手伝いします。SVG は単なるデータなので、興奮しているとき、考えているとき、またはアラームを鳴らしているときに、これらの生き物がどのように見えるかの例があればよいのです。Vue は、これらの状態間の遷移を支援し、ウェルカム ページ、読み込みインジケータ、通知をより感情的に説得力のあるものにすることができます。</target>
        </trans-unit>
        <trans-unit id="f789efe555358e086dec2286a04d16497d60bbf4" translate="yes" xml:space="preserve">
          <source>Vue cannot detect property addition or deletion. Since Vue performs the getter/setter conversion process during instance initialization, a property must be present in the &lt;code&gt;data&lt;/code&gt; object in order for Vue to convert it and make it reactive. For example:</source>
          <target state="translated">Vueはプロパティの追加または削除を検出できません。Vueはインスタンスの初期化中にゲッター/セッター変換プロセスを実行するため、Vueが変換してリアクティブにするためには、 &lt;code&gt;data&lt;/code&gt; オブジェクトにプロパティが存在する必要があります。例えば：</target>
        </trans-unit>
        <trans-unit id="e76acf301d7c1d195a8e6c80016f7abf03185310" translate="yes" xml:space="preserve">
          <source>Vue cannot detect the following changes to an array:</source>
          <target state="translated">Vue は、配列に対する以下の変更を検出できません。</target>
        </trans-unit>
        <trans-unit id="5c6af4e3cef9103ebba7535117ed1fc9a70968ce" translate="yes" xml:space="preserve">
          <source>Vue components provide important features that are not available in plain custom elements, most notably cross-component data flow, custom event communication and build tool integrations.</source>
          <target state="translated">Vue コンポーネントは、プレーンなカスタム要素にはない重要な機能を提供します。特に、クロスコンポーネントデータフロー、カスタムイベント通信、ビルドツール統合などが挙げられます。</target>
        </trans-unit>
        <trans-unit id="37147a4b37600d215ff72836bc22ae45766e8aaf" translate="yes" xml:space="preserve">
          <source>Vue does &lt;strong&gt;not&lt;/strong&gt; support IE8 and below, because it uses ECMAScript 5 features that are un-shimmable in IE8. However it supports all &lt;a href=&quot;https://caniuse.com/#feat=es5&quot;&gt;ECMAScript 5 compliant browsers&lt;/a&gt;.</source>
          <target state="translated">VueはIE8ではシムできないECMAScript 5機能を使用するため、IE8以下をサポートしていませ&lt;strong&gt;ん&lt;/strong&gt;。ただし、&lt;a href=&quot;https://caniuse.com/#feat=es5&quot;&gt;ECMAScript 5に準拠&lt;/a&gt;したすべてのブラウザーをサポートしています。</target>
        </trans-unit>
        <trans-unit id="bcde1702db5cf00f14ae819af084b9d5e13e847d" translate="yes" xml:space="preserve">
          <source>Vue does a runtime validation on props with a &lt;code&gt;type&lt;/code&gt; defined. To provide these types to TypeScript, we need to cast the constructor with &lt;code&gt;PropType&lt;/code&gt;:</source>
          <target state="translated">Vueは、 &lt;code&gt;type&lt;/code&gt; 定義された小道具に対してランタイム検証を行います。これらの型をTypeScriptに提供するには、 &lt;code&gt;PropType&lt;/code&gt; を使用してコンストラクターをキャストする必要があります。</target>
        </trans-unit>
        <trans-unit id="9644530939c86150587d7763eb986ef8509e60fe" translate="yes" xml:space="preserve">
          <source>Vue does not allow dynamically adding new root-level reactive properties to an already created instance. However, it&amp;rsquo;s possible to add reactive properties to a nested object using the &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; method. For example, given:</source>
          <target state="translated">Vueでは、すでに作成されているインスタンスに新しいルートレベルのリアクティブプロパティを動的に追加することはできません。ただし、 &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; メソッドを使用して、ネストされたオブジェクトにリアクティブプロパティを追加することは可能です。たとえば、次の場合：</target>
        </trans-unit>
        <trans-unit id="5ae4e619e0432f9df163ef8635c7eaee1ab68c9d" translate="yes" xml:space="preserve">
          <source>Vue does not allow dynamically adding new root-level reactive properties to an already created instance. However, it&amp;rsquo;s possible to add reactive properties to a nested object using the &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; method:</source>
          <target state="translated">Vueでは、すでに作成されているインスタンスに新しいルートレベルのリアクティブプロパティを動的に追加することはできません。ただし、 &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; メソッドを使用して、ネストされたオブジェクトにリアクティブプロパティを追加することは可能です。</target>
        </trans-unit>
        <trans-unit id="343af74f45c6d504ae330328dd8b0a9201ec2a40" translate="yes" xml:space="preserve">
          <source>Vue does not allow dynamically adding new root-level reactive properties to an already created instance. However, it's possible to add reactive properties to a nested object using the &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; method:</source>
          <target state="translated">Vueでは、作成済みのインスタンスに新しいルートレベルのリアクティブプロパティを動的に追加することはできません。ただし、 &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; メソッドを使用して、ネストされたオブジェクトにリアクティブプロパティを追加することは可能です。</target>
        </trans-unit>
        <trans-unit id="f19e40c5aefab10a48d600828d78fdd34132f866" translate="yes" xml:space="preserve">
          <source>Vue does provide a more generic way to observe and react to data changes on a Vue instance: &lt;strong&gt;watch properties&lt;/strong&gt;. When you have some data that needs to change based on some other data, it is tempting to overuse &lt;code&gt;watch&lt;/code&gt; - especially if you are coming from an AngularJS background. However, it is often a better idea to use a computed property rather than an imperative &lt;code&gt;watch&lt;/code&gt; callback. Consider this example:</source>
          <target state="translated">Vueは、Vueインスタンスでのデータの変化を観察して反応する、より一般的な方法を提供します。&lt;strong&gt;監視プロパティ&lt;/strong&gt;です。他のデータに基づいて変更する必要があるデータがある場合、特にAngularJSのバックグラウンドから来ている場合は、 &lt;code&gt;watch&lt;/code&gt; を使いすぎてしまいがちです。ただし、多くの場合、命令型 &lt;code&gt;watch&lt;/code&gt; コールバックではなく、計算されたプロパティを使用することをお勧めします。この例を考えてみましょう：</target>
        </trans-unit>
        <trans-unit id="c5264d84d3913aaee37aae0efaf21239b2f1ce3b" translate="yes" xml:space="preserve">
          <source>Vue does provide a more generic way to observe and react to data changes on a current active instance: &lt;strong&gt;watch properties&lt;/strong&gt;. When you have some data that needs to change based on some other data, it is tempting to overuse &lt;code&gt;watch&lt;/code&gt; - especially if you are coming from an AngularJS background. However, it is often a better idea to use a computed property rather than an imperative &lt;code&gt;watch&lt;/code&gt; callback. Consider this example:</source>
          <target state="translated">Vueは、現在アクティブなインスタンスのデータ変更を監視して対応するためのより一般的な方法を提供します：&lt;strong&gt;ウォッチプロパティ&lt;/strong&gt;。他のデータに基づいて変更する必要のあるデータがある場合、特にAngularJSのバックグラウンドを使用している場合は、 &lt;code&gt;watch&lt;/code&gt; を使いすぎてしまいがちです。ただし、命令型の &lt;code&gt;watch&lt;/code&gt; コールバックではなく、計算されたプロパティを使用する方がよい場合がよくあります。この例を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="fa20ee25a985c5ea6e1e0de59eb8059a57dc11b9" translate="yes" xml:space="preserve">
          <source>Vue doesn&amp;rsquo;t suffer from this at all because it uses a transparent dependency-tracking observation system with async queueing - all changes trigger independently unless they have explicit dependency relationships.</source>
          <target state="translated">Vueは非同期キューイングを備えた透過的な依存関係追跡監視システムを使用するため、これにまったく影響を受けません。明示的な依存関係がない限り、すべての変更は独立してトリガーされます。</target>
        </trans-unit>
        <trans-unit id="3b2be91f79d826fa58f7ebe4ed4e0d032247230c" translate="yes" xml:space="preserve">
          <source>Vue doesn't include built-in support for debouncing or throttling but it can be implemented using libraries such as &lt;a href=&quot;https://lodash.com/&quot;&gt;Lodash (opens new window)&lt;/a&gt;.</source>
          <target state="translated">Vueには、&lt;a href=&quot;https://lodash.com/&quot;&gt;デバウンス&lt;/a&gt;またはスロットルの組み込みサポートは含まれていませんが、Lodash（新しいウィンドウを開く）などのライブラリを使用して実装できます。</target>
        </trans-unit>
        <trans-unit id="6cec1602b0b81b69b55e68ee2a3e76a167245823" translate="yes" xml:space="preserve">
          <source>Vue embraces classic web technologies and builds on top of them. To show you what that means, we&amp;rsquo;ll dive into some examples.</source>
          <target state="translated">Vueは従来のWebテクノロジーを採用し、それらの上に構築します。それが何を意味するかを示すために、いくつかの例を取り上げます。</target>
        </trans-unit>
        <trans-unit id="a951ea402d433567bd65b048725a50d77f19283f" translate="yes" xml:space="preserve">
          <source>Vue encourages us to build our UIs by encapsulating UI and related behavior into components. We can nest them inside one another to build a tree that makes up an application UI.</source>
          <target state="translated">Vue では、UI と関連する動作をコンポーネントにカプセル化して UI を構築することを推奨しています。コンポーネントを互いに入れ子にして、アプリケーション UI を構成するツリーを構築することができます。</target>
        </trans-unit>
        <trans-unit id="ae4d5a5737de32d531811b293a6b6c8f4dd6038d" translate="yes" xml:space="preserve">
          <source>Vue has a clearer separation between directives and components. Directives are meant to encapsulate DOM manipulations only, while components are self-contained units that have their own view and data logic. In AngularJS, directives do everything and components are just a specific kind of directive.</source>
          <target state="translated">Vue では、ディレクティブとコンポーネントの間に明確な分離があります。ディレクティブはDOM操作のみをカプセル化することを意味し、コンポーネントは独自のビューとデータロジックを持つ自己完結型のユニットです。AngularJSでは、ディレクティブはすべてを行い、コンポーネントは特定の種類のディレクティブに過ぎません。</target>
        </trans-unit>
        <trans-unit id="5f5b28822c7ba305194d65c64adf4bcfa7d893d3" translate="yes" xml:space="preserve">
          <source>Vue has already spread across the globe, with even the core team in at least half a dozen timezones. &lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;The forum&lt;/a&gt; includes 7 languages and counting and many of our docs have &lt;a href=&quot;https://github.com/vuejs?utf8=%E2%9C%93&amp;amp;query=vuejs.org&quot;&gt;actively-maintained translations&lt;/a&gt;. We&amp;rsquo;re very proud of Vue&amp;rsquo;s international reach, but we can do even better.</source>
          <target state="translated">Vueはすでに世界中に広がっており、コアチームでさえ少なくとも6タイムゾーンにあります。&lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;フォーラムに&lt;/a&gt;は7つの言語と数が含まれており、私たちのドキュメントの多くは&lt;a href=&quot;https://github.com/vuejs?utf8=%E2%9C%93&amp;amp;query=vuejs.org&quot;&gt;積極的に翻訳を維持しています&lt;/a&gt;。私たちはVueの国際的なリーチを非常に誇りに思っていますが、さらに良いことができます。</target>
        </trans-unit>
        <trans-unit id="881974d376493ccbbdc99809953ca1768f35401b" translate="yes" xml:space="preserve">
          <source>Vue has better performance and is much, much easier to optimize because it doesn&amp;rsquo;t use dirty checking. AngularJS becomes slow when there are a lot of watchers, because every time anything in the scope changes, all these watchers need to be re-evaluated again. Also, the digest cycle may have to run multiple times to &amp;ldquo;stabilize&amp;rdquo; if some watcher triggers another update. AngularJS users often have to resort to esoteric techniques to get around the digest cycle, and in some situations, there&amp;rsquo;s no way to optimize a scope with many watchers.</source>
          <target state="translated">Vueはダーティチェックを使用しないため、パフォーマンスが向上し、最適化がはるかに容易になります。ウォッチャーが多数ある場合、AngularJSは遅くなります。スコープ内の何かが変更されるたびに、これらすべてのウォッチャーを再評価する必要があるためです。また、一部のウォッチャーが別の更新をトリガーした場合、ダイジェストサイクルを「安定させる」ために複数回実行する必要がある場合があります。AngularJSユーザーは、ダイジェストサイクルを回避するために難解な手法に頼らなければならないことが多く、状況によっては、多くのウォッチャーでスコープを最適化する方法がありません。</target>
        </trans-unit>
        <trans-unit id="2605f10b94203eb3d7c6121d24fd706b16d41799" translate="yes" xml:space="preserve">
          <source>Vue has spread across the globe, with the core team being in at least half a dozen different timezones. &lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;The forum (opens new window)&lt;/a&gt; includes 7 languages and counting and many of our docs have &lt;a href=&quot;https://github.com/vuejs?utf8=%E2%9C%93&amp;amp;q=vuejs.org&quot;&gt;actively-maintained translations (opens new window)&lt;/a&gt;. We're very proud of Vue's international reach, but we can do even better.</source>
          <target state="translated">Vueは世界中に広がり、コアチームは少なくとも半ダースの異なるタイムゾーンにいます。&lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;フォーラム（新しいウィンドウを開きます）に&lt;/a&gt;は7つの言語とカウントが含まれており、ドキュメントの多くは&lt;a href=&quot;https://github.com/vuejs?utf8=%E2%9C%93&amp;amp;q=vuejs.org&quot;&gt;積極的に翻訳を維持しています（新しいウィンドウを開きます）&lt;/a&gt;。私たちはVueの国際的なリーチを非常に誇りに思っていますが、さらに良いことをすることができます。</target>
        </trans-unit>
        <trans-unit id="6c550aa4342c74e83ae493691c6ae0befcbbd2d7" translate="yes" xml:space="preserve">
          <source>Vue implements a content distribution API inspired by the &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Web Components spec draft (opens new window)&lt;/a&gt;, using the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element to serve as distribution outlets for content.</source>
          <target state="translated">Vueは、&lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Webコンポーネントの仕様ドラフト（新しいウィンドウを開く）&lt;/a&gt;に触発されたコンテンツ配信APIを実装し、 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 要素を使用してコンテンツの配信アウトレットとして機能します。</target>
        </trans-unit>
        <trans-unit id="315e39e9d5c8a76f6f5db130e65186a24c2ad2a7" translate="yes" xml:space="preserve">
          <source>Vue implements a content distribution API inspired by the &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Web Components spec draft&lt;/a&gt;, using the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element to serve as distribution outlets for content.</source>
          <target state="translated">Vue は、 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 要素を使用してコンテンツの配布アウトレットとして機能する、&lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Web Components仕様ドラフト&lt;/a&gt;に触発されたコンテンツ配布APIを実装します。</target>
        </trans-unit>
        <trans-unit id="3a793e8d661b43bbe34ed4b73bb734bc567f99e0" translate="yes" xml:space="preserve">
          <source>Vue internally tracks all objects that have been made reactive, so it always returns the same proxy for the same object.</source>
          <target state="translated">Vue は、リアクティブにされたすべてのオブジェクトを内部的に追跡するため、常に同じオブジェクトに対して同じプロキシを返します。</target>
        </trans-unit>
        <trans-unit id="32cc26bda089d22ee9d524a03dbd85e42bb4830f" translate="yes" xml:space="preserve">
          <source>Vue is also available on &lt;a href=&quot;https://unpkg.com/vue@2.6.10/dist/vue.js&quot;&gt;unpkg&lt;/a&gt; and &lt;a href=&quot;https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.10/vue.js&quot;&gt;cdnjs&lt;/a&gt; (cdnjs takes some time to sync so the latest release may not be available yet).</source>
          <target state="translated">Vueは&lt;a href=&quot;https://unpkg.com/vue@2.6.10/dist/vue.js&quot;&gt;unpkg&lt;/a&gt;と&lt;a href=&quot;https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.10/vue.js&quot;&gt;cdnjs&lt;/a&gt;でも利用できます（cdnjsは同期に時間がかかるため、最新のリリースがまだ利用できない場合があります）。</target>
        </trans-unit>
        <trans-unit id="10ee466f89c6e492df9449492b2c0cad1124cbd6" translate="yes" xml:space="preserve">
          <source>Vue is much less opinionated than Angular, offering official support for a variety of build systems, with no restrictions on how you structure your application. Many developers enjoy this freedom, while some prefer having only one Right Way to build any application.</source>
          <target state="translated">Vue は Angular よりも意見が少なく、アプリケーションの構造に制限がなく、様々なビルドシステムを公式にサポートしています。多くの開発者はこの自由を享受していますが、アプリケーションを構築するための正しい方法が一つしかないことを好む人もいます。</target>
        </trans-unit>
        <trans-unit id="5f16a9a3da3c8339a4180458be820db747efab17" translate="yes" xml:space="preserve">
          <source>Vue is much simpler than AngularJS, both in terms of API and design. Learning enough to build non-trivial applications typically takes less than a day, which is not true for AngularJS.</source>
          <target state="translated">VueはAPIの面でもデザインの面でもAngularJSよりもはるかにシンプルです。トリビアルでないアプリケーションを構築するのに十分な学習時間は、通常1日もかかりませんが、AngularJSの場合はそうではありません。</target>
        </trans-unit>
        <trans-unit id="cffec81f79bb5fd465edfb05ca6c6a20e73cd65d" translate="yes" xml:space="preserve">
          <source>Vue keeps the page updated by building a &lt;strong&gt;virtual DOM&lt;/strong&gt; to keep track of the changes it needs to make to the real DOM. Taking a closer look at this line:</source>
          <target state="translated">Vueは、&lt;strong&gt;仮想DOM&lt;/strong&gt;を構築してページを最新の状態に保ち、実際のDOMに加える必要のある変更を追跡します。この行を詳しく見てみましょう。</target>
        </trans-unit>
        <trans-unit id="c65cd273e5f6ab6e9dff779a723ce1ab6e016a34" translate="yes" xml:space="preserve">
          <source>Vue needs to attach event listeners in order to know when a transition has ended. It can either be &lt;code&gt;transitionend&lt;/code&gt; or &lt;code&gt;animationend&lt;/code&gt;, depending on the type of CSS rules applied. If you are only using one or the other, Vue can automatically detect the correct type.</source>
          <target state="translated">Vueは、遷移がいつ終了したかを知るために、イベントリスナーをアタッチする必要があります。適用されるCSSルールのタイプに応じて、 &lt;code&gt;transitionend&lt;/code&gt; または &lt;code&gt;animationend&lt;/code&gt; のいずれかになります。どちらか一方のみを使用している場合、Vueは正しいタイプを自動的に検出できます。</target>
        </trans-unit>
        <trans-unit id="365212719322a63f4e306455d5f27b8a3966dc5d" translate="yes" xml:space="preserve">
          <source>Vue offers some abstractions that can help work with transitions and animations, particularly in response to something changing. Some of these abstractions include:</source>
          <target state="translated">Vueには、特に何かが変化したときのトランジションやアニメーションの作業に役立ついくつかの抽象化が用意されています。これらの抽象化には、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="2abff090748f024b1aa003637a4b72dd4dc06e5f" translate="yes" xml:space="preserve">
          <source>Vue projects can quickly be set up with Vite by running the following commands in your terminal.</source>
          <target state="translated">Vueプロジェクトは、ターミナルで以下のコマンドを実行することで、Viteを使って素早く設定することができます。</target>
        </trans-unit>
        <trans-unit id="5ecd2fd20f1617fec18255c802e4165961e34ff8" translate="yes" xml:space="preserve">
          <source>Vue provides a &lt;code&gt;transition&lt;/code&gt; wrapper component, allowing you to add entering/leaving transitions for any element or component in the following contexts:</source>
          <target state="translated">Vueは &lt;code&gt;transition&lt;/code&gt; ラッパーコンポーネントを提供し、次のコンテキストで任意の要素またはコンポーネントの開始/終了トランジションを追加できるようにします。</target>
        </trans-unit>
        <trans-unit id="90f6435d17defefabfdaefdbf0248c547a6baa43" translate="yes" xml:space="preserve">
          <source>Vue provides a variety of ways to apply transition effects when items are inserted, updated, or removed from the DOM. This includes tools to:</source>
          <target state="translated">Vue は、アイテムが DOM に挿入、更新、削除されたときにトランジション効果を適用するさまざまな方法を提供しています。これには次のようなツールが含まれます。</target>
        </trans-unit>
        <trans-unit id="c875e25ec6e673bd0fa4b43fbaf93eb5a80089d3" translate="yes" xml:space="preserve">
          <source>Vue provides aliases for the most commonly used key codes when necessary for legacy browser support:</source>
          <target state="translated">Vue は、レガシーブラウザのサポートに必要な場合、最も一般的に使用されるキーコードのエイリアスを提供します。</target>
        </trans-unit>
        <trans-unit id="c90e634ab0c74f1d079a1c75ea53bce697797633" translate="yes" xml:space="preserve">
          <source>Vue provides aliases for the most commonly used keys:</source>
          <target state="translated">Vue は、最も一般的に使用されるキーのエイリアスを提供します。</target>
        </trans-unit>
        <trans-unit id="a311fa8fbae830ba1eadba1b420d03469cdf2806" translate="yes" xml:space="preserve">
          <source>Vue provides an &lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;official CLI (opens new window)&lt;/a&gt; for quickly scaffolding ambitious Single Page Applications. It provides batteries-included build setups for a modern frontend workflow. It takes only a few minutes to get up and running with hot-reload, lint-on-save, and production-ready builds. See &lt;a href=&quot;https://cli.vuejs.org&quot;&gt;the Vue CLI docs (opens new window)&lt;/a&gt; for more details.</source>
          <target state="translated">Vueは、野心的なシングルページアプリケーションをすばやくスキャフォールディングするための&lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;公式CLI（新しいウィンドウを開きます）&lt;/a&gt;を提供します。最新のフロントエンドワークフロー用のバッテリーを含むビルドセットアップを提供します。ホットリロード、lint-on-save、および本番環境対応のビルドを起動して実行するのにかかる時間はわずか数分です。詳細について&lt;a href=&quot;https://cli.vuejs.org&quot;&gt;は、Vue CLIのドキュメント（新しいウィンドウが開きます）&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="83a7e9def36f28bbd974e54d04ac78901b82dde6" translate="yes" xml:space="preserve">
          <source>Vue provides an &lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;official CLI&lt;/a&gt; for quickly scaffolding ambitious Single Page Applications. It provides batteries-included build setups for a modern frontend workflow. It takes only a few minutes to get up and running with hot-reload, lint-on-save, and production-ready builds. See &lt;a href=&quot;https://cli.vuejs.org&quot;&gt;the Vue CLI docs&lt;/a&gt; for more details.</source>
          <target state="translated">Vueは、野心的なシングルページアプリケーションを迅速に足場するための&lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;公式CLI&lt;/a&gt;を提供します。最新のフロントエンドワークフロー用に、バッテリーを含むビルドセットアップを提供します。ホットリロード、lint-on-save、プロダクション対応のビルドを使用できるようになるまで数分しかかかりません。詳細について&lt;a href=&quot;https://cli.vuejs.org&quot;&gt;は、Vue CLIのドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="198884e2076bf367c22dbd13bc52339d681396a7" translate="yes" xml:space="preserve">
          <source>Vue provides an &lt;code&gt;InjectionKey&lt;/code&gt; interface which is a generic type that extends &lt;code&gt;Symbol&lt;/code&gt;. It can be used to sync the type of the injected value between the provider and the consumer:</source>
          <target state="translated">Vueは、 &lt;code&gt;Symbol&lt;/code&gt; を拡張するジェネリック型である &lt;code&gt;InjectionKey&lt;/code&gt; インターフェースを提供します。プロバイダーとコンシューマーの間で注入された値のタイプを同期するために使用できます。</target>
        </trans-unit>
        <trans-unit id="b4d1ad276c1e9b0a434e314eacca760e6163db38" translate="yes" xml:space="preserve">
          <source>Vue provides unobtrusive reactivity on plain JavaScript objects and fully automatic computed properties. In Ember, you need to wrap everything in Ember Objects and manually declare dependencies for computed properties.</source>
          <target state="translated">Vue は、プレーンな JavaScript オブジェクトと完全に自動化された計算されたプロパティに対して控えめなリアクションを提供します。Ember では、すべてを Ember Objects でラップし、計算されたプロパティの依存関係を手動で宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="5a53f20609320f4a24cb94f7b4da549347f4bbbd" translate="yes" xml:space="preserve">
          <source>Vue recommends using templates to build applications in the vast majority of cases. However, there are situations where we need the full programmatic power of JavaScript. That's where we can use the &lt;strong&gt;render function&lt;/strong&gt;.</source>
          <target state="translated">Vueは、ほとんどの場合、テンプレートを使用してアプリケーションを構築することをお勧めします。ただし、JavaScriptの完全なプログラム機能が必要な場合があります。ここで、&lt;strong&gt;レンダリング関数を&lt;/strong&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="7346ec062ad9807eec320c99bd8abe0bacd7643f" translate="yes" xml:space="preserve">
          <source>Vue recommends using templates to build your HTML in the vast majority of cases. There are situations however, where you really need the full programmatic power of JavaScript. That&amp;rsquo;s where you can use the &lt;strong&gt;render function&lt;/strong&gt;, a closer-to-the-compiler alternative to templates.</source>
          <target state="translated">Vueは、ほとんどの場合、テンプレートを使用してHTMLを構築することを推奨しています。ただし、JavaScriptの完全なプログラム機能を本当に必要とする状況もあります。テンプレートに代わるコンパイラに近い代替手段である&lt;strong&gt;render関数&lt;/strong&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="8156b77f1cb02753b763c4feb44d817ea36bfdc0" translate="yes" xml:space="preserve">
          <source>Vue should not be bundled into the library</source>
          <target state="translated">Vueはライブラリにバンドルされてはいけない</target>
        </trans-unit>
        <trans-unit id="9b71c188d7cf41c5602a8754468c8e9d993c9edd" translate="yes" xml:space="preserve">
          <source>Vue tries to render elements as efficiently as possible, often re-using them instead of rendering from scratch. Beyond helping make Vue very fast, this can have some useful advantages. For example, if you allow users to toggle between multiple login types:</source>
          <target state="translated">Vue は可能な限り効率的に要素をレンダリングしようとし、ゼロからレンダリングするのではなく再利用することが多いです。これは、Vue の高速化に役立つだけでなく、いくつかの有用な利点があります。たとえば、ユーザーが複数のログイン タイプを切り替えられるようにした場合などです。</target>
        </trans-unit>
        <trans-unit id="1bfea290ac9ffe33c850d1b0a939949cd7dfe376" translate="yes" xml:space="preserve">
          <source>Vue uses a &lt;code&gt;$&lt;/code&gt; prefix when exposing its own built-in APIs via the component instance. It also reserves the prefix &lt;code&gt;_&lt;/code&gt; for internal properties. You should avoid using names for top-level &lt;code&gt;data&lt;/code&gt; properties that start with either of these characters.</source>
          <target state="translated">Vueは、コンポーネントインスタンスを介して独自の組み込みAPIを公開するときに、 &lt;code&gt;$&lt;/code&gt; プレフィックスを使用します。また、内部プロパティ用にプレフィックス &lt;code&gt;_&lt;/code&gt; を予約します。これらの文字のいずれかで始まるトップレベルの &lt;code&gt;data&lt;/code&gt; プロパティに名前を使用することは避けてください。</target>
        </trans-unit>
        <trans-unit id="444100368a15ace2e6288fb295611b81775b2a56" translate="yes" xml:space="preserve">
          <source>Vue uses the &lt;code&gt;_&lt;/code&gt; prefix to define its own private properties, so using the same prefix (e.g. &lt;code&gt;_update&lt;/code&gt;) risks overwriting an instance property. Even if you check and Vue is not currently using a particular property name, there is no guarantee a conflict won&amp;rsquo;t arise in a later version.</source>
          <target state="translated">Vueは &lt;code&gt;_&lt;/code&gt; 接頭辞を使用して独自のプライベートプロパティを定義するため、同じ接頭辞（例： &lt;code&gt;_update&lt;/code&gt; ）を使用すると、インスタンスプロパティが上書きされるリスクがあります。チェックしていて、Vueが現在特定のプロパティ名を使用していない場合でも、新しいバージョンで競合が発生しないという保証はありません。</target>
        </trans-unit>
        <trans-unit id="85dd560a9154cd8cc040ca30f4c194c517655b32" translate="yes" xml:space="preserve">
          <source>Vue uses the &lt;code&gt;_&lt;/code&gt; prefix to define its own private properties, so using the same prefix (e.g. &lt;code&gt;_update&lt;/code&gt;) risks overwriting an instance property. Even if you check and Vue is not currently using a particular property name, there is no guarantee a conflict won't arise in a later version.</source>
          <target state="translated">Vueは &lt;code&gt;_&lt;/code&gt; プレフィックスを使用して独自のプライベートプロパティを定義するため、同じプレフィックス（ &lt;code&gt;_update&lt;/code&gt; など）を使用すると、インスタンスプロパティが上書きされるリスクがあります。チェックして、Vueが現在特定のプロパティ名を使用していない場合でも、それ以降のバージョンで競合が発生しないという保証はありません。</target>
        </trans-unit>
        <trans-unit id="984f76b6b17c9c7750c863470482e24ce27debcc" translate="yes" xml:space="preserve">
          <source>Vue will automatically sniff whether the target element has CSS transitions or animations applied. If it does, CSS transition classes will be added/removed at appropriate timings.</source>
          <target state="translated">Vue は、対象となる要素に CSS 遷移やアニメーションが適用されているかどうかを自動的に嗅ぎ分けます。適用されている場合は、適切なタイミングで CSS 遷移クラスが追加/削除されます。</target>
        </trans-unit>
        <trans-unit id="3a3622b63c9271442caba43d7cdf8ec076797d3e" translate="yes" xml:space="preserve">
          <source>Vue wraps an observed array&amp;rsquo;s mutation methods so they will also trigger view updates. The wrapped methods are:</source>
          <target state="translated">Vueは観測された配列のミューテーションメソッドをラップするため、ビューの更新もトリガーされます。ラップされたメソッドは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="052994ca379981542bf778170c739a04a769c1d8" translate="yes" xml:space="preserve">
          <source>Vue wraps an observed array's mutation methods so they will also trigger view updates. The wrapped methods are:</source>
          <target state="translated">Vue は、観測された配列のミューテーションメソッドをラップして、ビューの更新もトリガーするようにします。ラップされるメソッドは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="93e1fa19cf5758f9db9d0f3677b23685acc53107" translate="yes" xml:space="preserve">
          <source>Vue&amp;rsquo;s community is growing incredibly fast and if you&amp;rsquo;re reading this, there&amp;rsquo;s a good chance you&amp;rsquo;re ready to join it. So&amp;hellip; welcome!</source>
          <target state="translated">Vueのコミュニティは信じられないほど急速に成長しており、これを読んでいる場合は、参加する準備ができている可能性が十分にあります。だから&amp;hellip;ようこそ！</target>
        </trans-unit>
        <trans-unit id="322e869fcc97102e7e016c8418cdb3094a9f4241" translate="yes" xml:space="preserve">
          <source>Vue&amp;rsquo;s template syntax harnesses the full power of JavaScript expressions, while Handlebars&amp;rsquo; expression and helper syntax is intentionally quite limited in comparison.</source>
          <target state="translated">Vueのテンプレート構文はJavaScript式の全機能を利用しますが、ハンドルバーの式とヘルパー構文は意図的に比較するとかなり制限されています。</target>
        </trans-unit>
        <trans-unit id="624a0a9a36cd9f9702aa8d1741b7285770304340" translate="yes" xml:space="preserve">
          <source>Vue&amp;rsquo;s transition system has changed quite drastically and now uses &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; wrapper elements, rather than the &lt;code&gt;transition&lt;/code&gt; attribute. It&amp;rsquo;s recommended to read the new &lt;a href=&quot;transitions&quot;&gt;Transitions guide&lt;/a&gt; to learn more.</source>
          <target state="translated">Vueの移行システムは大幅に変更され、 &lt;code&gt;transition&lt;/code&gt; 属性ではなく &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; および &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; ラッパー要素を使用するようになりました。詳細については、新しい&lt;a href=&quot;transitions&quot;&gt;移行ガイド&lt;/a&gt;を読むことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="76757ff90e72da993b6b789516932e1e47009d9a" translate="yes" xml:space="preserve">
          <source>Vue&amp;rsquo;s transition system offers many simple ways to animate entering, leaving, and lists, but what about animating your data itself? For example:</source>
          <target state="translated">Vueの移行システムは、入力、終了、リストをアニメーション化する多くの簡単な方法を提供しますが、データ自体のアニメーション化についてはどうでしょうか？例えば：</target>
        </trans-unit>
        <trans-unit id="b31ca06d3a5f393764ec4e9c8ef653d752ddc802" translate="yes" xml:space="preserve">
          <source>Vue's reactivity system buffers invalidated effects and flushes them asynchronously to avoid unnecessary duplicate invocation when there are many state mutations happening in the same &quot;tick&quot;. Internally, a component's &lt;code&gt;update&lt;/code&gt; function is also a watched effect. When a user effect is queued, it is by default invoked &lt;strong&gt;before&lt;/strong&gt; all component &lt;code&gt;update&lt;/code&gt; effects:</source>
          <target state="translated">Vueの反応性システムは、無効化された効果をバッファリングし、それらを非同期的にフラッシュして、同じ「ティック」で多数の状態変異が発生した場合の不要な重複呼び出しを回避します。内部的には、コンポーネントの &lt;code&gt;update&lt;/code&gt; 機能も監視された効果です。ユーザーエフェクトがキューに入れられると、デフォルトでは、すべてのコンポーネント &lt;code&gt;update&lt;/code&gt; エフェクトの&lt;strong&gt;前に&lt;/strong&gt;呼び出されます。</target>
        </trans-unit>
        <trans-unit id="5a97b271690906d44d32706aa7062d75c719e21d" translate="yes" xml:space="preserve">
          <source>Vue's transition system offers many simple ways to animate entering, leaving, and lists, but what about animating your data itself? For example:</source>
          <target state="translated">Vueのトランジションシステムには、入力、退出、リストなどの簡単なアニメーションの方法がたくさんありますが、データそのものをアニメーション化するのはどうでしょうか?例えば、次のようなものです。</target>
        </trans-unit>
        <trans-unit id="49720efe6c6aa6c85c1ae9a211e82f72036b89c2" translate="yes" xml:space="preserve">
          <source>Vue's usage of the &lt;code&gt;is&lt;/code&gt; special prop was simulating what the native attribute does before it was made universally available in browsers. However, in 2.x it was interpreted as rendering a Vue component with the name &lt;code&gt;plastic-button&lt;/code&gt;. This blocks the native usage of Customized Built-in Element mentioned above.</source>
          <target state="translated">VUEの使用法は &lt;code&gt;is&lt;/code&gt; 特殊な小道具はそれがブラウザで普遍的に利用できるようになりました前に、ネイティブの属性が何をシミュレートしました。ただし、2.xでは、名前が &lt;code&gt;plastic-button&lt;/code&gt; のVueコンポーネントをレンダリングするものとして解釈されていました。これにより、上記のカスタマイズされた組み込み要素のネイティブ使用がブロックされます。</target>
        </trans-unit>
        <trans-unit id="747f5a69bf5b0a247d5063d8cba744d0c67792fc" translate="yes" xml:space="preserve">
          <source>Vue.compile( template )</source>
          <target state="translated">Vue.compile(テンプレート )</target>
        </trans-unit>
        <trans-unit id="006274a914f30334bdd61869c339c9cc2f697c2f" translate="yes" xml:space="preserve">
          <source>Vue.compile()</source>
          <target state="translated">Vue.compile()</target>
        </trans-unit>
        <trans-unit id="b7ea66a12347f6ffc2b94442e80c35d15d597413" translate="yes" xml:space="preserve">
          <source>Vue.component</source>
          <target state="translated">Vue.component</target>
        </trans-unit>
        <trans-unit id="5ce4d7fb595d7cb94a3d2b693db1f767216e55af" translate="yes" xml:space="preserve">
          <source>Vue.component( id, [definition] )</source>
          <target state="translated">Vue.component(id,[定義])</target>
        </trans-unit>
        <trans-unit id="e8c7a1fb76f08ecda2c23ba8eb798c4d21544eec" translate="yes" xml:space="preserve">
          <source>Vue.component()</source>
          <target state="translated">Vue.component()</target>
        </trans-unit>
        <trans-unit id="fa7c2ad2da40c783fe07fb4836f3bda4a2b8cf11" translate="yes" xml:space="preserve">
          <source>Vue.config</source>
          <target state="translated">Vue.config</target>
        </trans-unit>
        <trans-unit id="fbf8d19b7eb0ae647266f2c96abf99945277ea9e" translate="yes" xml:space="preserve">
          <source>Vue.config.ignoredElements</source>
          <target state="translated">Vue.config.ignoredElements</target>
        </trans-unit>
        <trans-unit id="5b4f8634a75bc7bfd88be1dd891c9ea29cfa97f5" translate="yes" xml:space="preserve">
          <source>Vue.config.productionTip</source>
          <target state="translated">Vue.config.productionTip</target>
        </trans-unit>
        <trans-unit id="12cb69d1f5d780a9746d6267306c64b64405fa4c" translate="yes" xml:space="preserve">
          <source>Vue.delete( target, propertyName/index )</source>
          <target state="translated">Vue.delete(target,propertyName/index )</target>
        </trans-unit>
        <trans-unit id="68d21641f735f542e8f7c3a7ea648aa0c4e35779" translate="yes" xml:space="preserve">
          <source>Vue.delete()</source>
          <target state="translated">Vue.delete()</target>
        </trans-unit>
        <trans-unit id="580b85815fc398d542e95ec7b5e861e1e012763f" translate="yes" xml:space="preserve">
          <source>Vue.directive</source>
          <target state="translated">Vue.directive</target>
        </trans-unit>
        <trans-unit id="c32347439fe04c6336437069efe2d91df26659e1" translate="yes" xml:space="preserve">
          <source>Vue.directive( id, [definition] )</source>
          <target state="translated">Vue.directive(id,[definition])</target>
        </trans-unit>
        <trans-unit id="b59efa9215d110ba12928742d620af77e6a759f2" translate="yes" xml:space="preserve">
          <source>Vue.directive()</source>
          <target state="translated">Vue.directive()</target>
        </trans-unit>
        <trans-unit id="975e10259e8ed9d0d727102a1cd5cc4b93d7a650" translate="yes" xml:space="preserve">
          <source>Vue.extend( options )</source>
          <target state="translated">Vue.extend(options )</target>
        </trans-unit>
        <trans-unit id="1c725e9693b45558981c599b39d3fda6642f8d5b" translate="yes" xml:space="preserve">
          <source>Vue.extend()</source>
          <target state="translated">Vue.extend()</target>
        </trans-unit>
        <trans-unit id="675dca7e9f347b0a088b36a4d1b36ae828e38f75" translate="yes" xml:space="preserve">
          <source>Vue.filter( id, [definition] )</source>
          <target state="translated">Vue.filter(id,[定義])</target>
        </trans-unit>
        <trans-unit id="23a90de397a54f20910cfb3bd88027e09054324b" translate="yes" xml:space="preserve">
          <source>Vue.filter()</source>
          <target state="translated">Vue.filter()</target>
        </trans-unit>
        <trans-unit id="8bd43b7ad188ce8c3bb9691452ec856dcccbc84c" translate="yes" xml:space="preserve">
          <source>Vue.js</source>
          <target state="translated">Vue.js</target>
        </trans-unit>
        <trans-unit id="fd45ecca01e877661425a659bd70e10fa2aaa543" translate="yes" xml:space="preserve">
          <source>Vue.js API</source>
          <target state="translated">Vue.js API</target>
        </trans-unit>
        <trans-unit id="aad801d0cb83bef6f7c5626839ce4549782c00f2" translate="yes" xml:space="preserve">
          <source>Vue.js allows you to define filters that can be used to apply common text formatting. Filters are usable in two places: &lt;strong&gt;mustache interpolations and &lt;code&gt;v-bind&lt;/code&gt; expressions&lt;/strong&gt; (the latter supported in 2.1.0+). Filters should be appended to the end of the JavaScript expression, denoted by the &amp;ldquo;pipe&amp;rdquo; symbol:</source>
          <target state="translated">Vue.jsでは、一般的なテキスト形式を適用するために使用できるフィルターを定義できます。フィルターは、&lt;strong&gt;口ひげ補間と &lt;code&gt;v-bind&lt;/code&gt; 式の&lt;/strong&gt; 2つの場所で使用でき&lt;strong&gt;ます&lt;/strong&gt;（後者は2.1.0以降でサポートされています）。フィルターは、「パイプ」記号で示されるJavaScript式の最後に追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="9050802f5567e26ffa96732c93096ee9dcffa91f" translate="yes" xml:space="preserve">
          <source>Vue.js is built by design to be incrementally adoptable. This means that it can be integrated into a project multiple ways depending on the requirements.</source>
          <target state="translated">Vue.jsは、インクリメンタルに採用できるように設計されています。つまり、要件に応じて複数の方法でプロジェクトに組み込むことができます。</target>
        </trans-unit>
        <trans-unit id="01b0bd3a6d7b1cc4cde0ebb1b1ce9add80d460a8" translate="yes" xml:space="preserve">
          <source>Vue.js uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying Vue instance&amp;rsquo;s data. All Vue.js templates are valid HTML that can be parsed by spec-compliant browsers and HTML parsers.</source>
          <target state="translated">Vue.jsはHTMLベースのテンプレート構文を使用して、レンダリングされたDOMを基礎となるVueインスタンスのデータに宣言的にバインドできます。すべてのVue.jsテンプレートは有効なHTMLであり、仕様に準拠したブラウザーとHTMLパーサーで解析できます。</target>
        </trans-unit>
        <trans-unit id="89a8a92dc46a36b0e2b8305728a1f8aaf8a88b78" translate="yes" xml:space="preserve">
          <source>Vue.js uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying component instance's data. All Vue.js templates are valid HTML that can be parsed by spec-compliant browsers and HTML parsers.</source>
          <target state="translated">Vue.js は HTML ベースのテンプレート構文を使用しており、レンダリングされた DOM を基礎となるコンポーネント インスタンスのデータに宣言的にバインドすることができます。すべての Vue.js テンプレートは、仕様に準拠したブラウザや HTML パーサーで解析可能な有効な HTML です。</target>
        </trans-unit>
        <trans-unit id="42311314f611dc7df4fd1777e98448bb4c96ecdb" translate="yes" xml:space="preserve">
          <source>Vue.mixin</source>
          <target state="translated">Vue.mixin</target>
        </trans-unit>
        <trans-unit id="e602f02f3f51d5822ae83f16f43c6d8d79e67534" translate="yes" xml:space="preserve">
          <source>Vue.mixin( mixin )</source>
          <target state="translated">Vue.mixin(mixin )</target>
        </trans-unit>
        <trans-unit id="4e4d009b2737b0f51ebf1e738443ba7ede850af2" translate="yes" xml:space="preserve">
          <source>Vue.mixin()</source>
          <target state="translated">Vue.mixin()</target>
        </trans-unit>
        <trans-unit id="5c9a730edbafdfc1ce8565e66bb8641c7e1ed1de" translate="yes" xml:space="preserve">
          <source>Vue.nextTick</source>
          <target state="translated">Vue.nextTick</target>
        </trans-unit>
        <trans-unit id="143fba6c6a7c26c9258fd60cbadd2d844001d109" translate="yes" xml:space="preserve">
          <source>Vue.nextTick( [callback, context] )</source>
          <target state="translated">Vue.nextTick([callback,context])</target>
        </trans-unit>
        <trans-unit id="6fbce1a433934248bd340ceb4888036ac364ba2b" translate="yes" xml:space="preserve">
          <source>Vue.nextTick()</source>
          <target state="translated">Vue.nextTick()</target>
        </trans-unit>
        <trans-unit id="32a54ad5f6f9d484aaf21effb1fa3702f7e1d680" translate="yes" xml:space="preserve">
          <source>Vue.observable( object )</source>
          <target state="translated">Vue.observable(object )</target>
        </trans-unit>
        <trans-unit id="f422890fec57dc45446350cf215180b740a4422a" translate="yes" xml:space="preserve">
          <source>Vue.observable()</source>
          <target state="translated">Vue.observable()</target>
        </trans-unit>
        <trans-unit id="7ea3574e637178c673386a1b01019ea3760cf139" translate="yes" xml:space="preserve">
          <source>Vue.prototype</source>
          <target state="translated">Vue.prototype</target>
        </trans-unit>
        <trans-unit id="c438f73a1c59e3aa3df076ac89cf95e937f458a9" translate="yes" xml:space="preserve">
          <source>Vue.set( target, propertyName/index, value )</source>
          <target state="translated">Vue.set(target,propertyName/index,value )</target>
        </trans-unit>
        <trans-unit id="e8107a8261cab4790e710bac13da561d42e5a9f6" translate="yes" xml:space="preserve">
          <source>Vue.set()</source>
          <target state="translated">Vue.set()</target>
        </trans-unit>
        <trans-unit id="5a623310c41e9f9c01feb186a71709087e21e7da" translate="yes" xml:space="preserve">
          <source>Vue.use</source>
          <target state="translated">Vue.use</target>
        </trans-unit>
        <trans-unit id="4e2c5dd87fde81c317ac0bd9c0ff7bbb87f3c89e" translate="yes" xml:space="preserve">
          <source>Vue.use( plugin )</source>
          <target state="translated">Vue.use(plugin )</target>
        </trans-unit>
        <trans-unit id="f39db1673387c15674c362f9c69fa81a648b0ccf" translate="yes" xml:space="preserve">
          <source>Vue.use()</source>
          <target state="translated">Vue.use()</target>
        </trans-unit>
        <trans-unit id="a17ed02515b1156a989c141f6f9f251c40827a7a" translate="yes" xml:space="preserve">
          <source>Vue.version</source>
          <target state="translated">Vue.version</target>
        </trans-unit>
        <trans-unit id="58df3887d367d6a05cae0279723a97a86100bfeb" translate="yes" xml:space="preserve">
          <source>VuePress provides a custom container plugin to create alert boxes. There are four types:</source>
          <target state="translated">VuePressには、アラートボックスを作成するためのカスタムコンテナプラグインが用意されています。種類は4つあります。</target>
        </trans-unit>
        <trans-unit id="4fde70f98c4cbf6a7b48ee19696e129152a7fb55" translate="yes" xml:space="preserve">
          <source>VuePress uses Prism to provide language syntax highlighting by appending the language to the beginning backticks of a code block:</source>
          <target state="translated">VuePressでは、Prismを使用して、コードブロックの先頭のバックティックに言語を追加することで、言語のシンタックスハイライトを提供しています。</target>
        </trans-unit>
        <trans-unit id="de0b33121be26507e3433bd94203e17aa9b5f222" translate="yes" xml:space="preserve">
          <source>Vuex</source>
          <target state="translated">Vuex</target>
        </trans-unit>
        <trans-unit id="9c6ca3eb223f49942f07259d47688ad89f9e86ad" translate="yes" xml:space="preserve">
          <source>Vuex 2.0 is released, but this guide only covers the migration to 1.0? Is that a typo? Also, it looks like Vuex 1.0 and 2.0 were released simultaneously. What&amp;rsquo;s going on? Which one should I use and what&amp;rsquo;s compatible with Vue 2.0?</source>
          <target state="translated">Vuex 2.0がリリースされましたが、このガイドでは1.0への移行のみを扱いますか？それはタイプミスですか？また、Vuex 1.0と2.0が同時にリリースされたようです。どうしたの？どちらを使用する必要がありますか。また、Vue 2.0と互換性のあるものは何ですか。</target>
        </trans-unit>
        <trans-unit id="c8b618e05a2594cc2596f0d284d48d16432c525a" translate="yes" xml:space="preserve">
          <source>Vuex 4.0 provides Vue 3 support with largely the same API as 3.x. The only breaking change is &lt;a href=&quot;https://next.vuex.vuejs.org/guide/migrating-to-4-0-from-3-x.html#breaking-changes&quot;&gt;how the plugin is installed (opens new window)&lt;/a&gt;.</source>
          <target state="translated">Vuex 4.0は、3.xとほぼ同じAPIでVue3サポートを提供します。唯一の重大な変更は&lt;a href=&quot;https://next.vuex.vuejs.org/guide/migrating-to-4-0-from-3-x.html#breaking-changes&quot;&gt;、プラグインのインストール方法（新しいウィンドウを開く）&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="9dd40be6d96cb39a60cc6c39b8ea11e9937c18f8" translate="yes" xml:space="preserve">
          <source>Vuex is the &lt;a href=&quot;../guide/state-management#official-flux-like-implementation&quot;&gt;official flux-like implementation&lt;/a&gt; for Vue, and offers not only a central place to manage state, but also tools for organizing, tracking, and debugging state changes. It integrates well in the Vue ecosystem (including full &lt;a href=&quot;../guide/installation#vue-devtools&quot;&gt;Vue DevTools&lt;/a&gt; support).</source>
          <target state="translated">Vuexは、Vueの&lt;a href=&quot;../guide/state-management#official-flux-like-implementation&quot;&gt;公式のフラックスのような実装&lt;/a&gt;であり、状態を管理するための中心的な場所だけでなく、状態の変化を整理、追跡、およびデバッグするためのツールも提供します。Vueエコシステムにうまく統合されます（完全な&lt;a href=&quot;../guide/installation#vue-devtools&quot;&gt;Vue DevTools&lt;/a&gt;サポートを含む）。</target>
        </trans-unit>
        <trans-unit id="4d11819e7a1d9589b690ec06234450093f24c627" translate="yes" xml:space="preserve">
          <source>W3C's WAI-ARIA provides guidance on how to build dynamic content and advanced user interface controls.</source>
          <target state="translated">W3CのWAI-ARIAは、ダイナミックコンテンツと高度なユーザーインターフェースコントロールの構築方法についてのガイダンスを提供しています。</target>
        </trans-unit>
        <trans-unit id="066e0172350e0754c39de0933398067fbaebdf66" translate="yes" xml:space="preserve">
          <source>WAI-ARIA Authoring Practices 1.2 (opens new window)</source>
          <target state="translated">WAI-ARIA オーサリングの実践 1.2 (新しいウィンドウが開きます)</target>
        </trans-unit>
        <trans-unit id="45649ea79803ea52f28827ee4e547e4085b9b0c5" translate="yes" xml:space="preserve">
          <source>WAVE (opens new window)</source>
          <target state="translated">WAVE(新しいウィンドウが開きます</target>
        </trans-unit>
        <trans-unit id="43059526c7805cadcc812c12f2c0f217edb0caf4" translate="yes" xml:space="preserve">
          <source>WCAG 2.0 (opens new window)</source>
          <target state="translated">WCAG 2.0 (新しいウィンドウが開きます)</target>
        </trans-unit>
        <trans-unit id="8a7254fa8467e45dc2111643677937dc826c7381" translate="yes" xml:space="preserve">
          <source>WCAG 2.1 (opens new window)</source>
          <target state="translated">WCAG 2.1(新しいウィンドウが開きます</target>
        </trans-unit>
        <trans-unit id="e8bd5df2f8313fd0f66a6834ec679fec70aa231e" translate="yes" xml:space="preserve">
          <source>WCAG 2.1 Four Main Guiding Principles (abbreviated as POUR):</source>
          <target state="translated">WCAG 2.1 4つの主要指導原則(POURと略す)。</target>
        </trans-unit>
        <trans-unit id="f0f3911027dbf5f81418e3868022034d4fbc381c" translate="yes" xml:space="preserve">
          <source>Watch a free lesson on Vue School</source>
          <target state="translated">Vue Schoolの無料レッスンを見る</target>
        </trans-unit>
        <trans-unit id="62e0a695e7ccab369a0f49419284d104f98c2575" translate="yes" xml:space="preserve">
          <source>Watch a free video about Lifecycle Hooks on Vue Mastery</source>
          <target state="translated">Vue MasteryのLifecycle Hooksに関する無料ビデオを見る</target>
        </trans-unit>
        <trans-unit id="307e7187cdc04cab3317a2d6229024de7b88422b" translate="yes" xml:space="preserve">
          <source>Watch a free video about the Composition API on Vue Mastery</source>
          <target state="translated">Vue Mastery の Composition API についての無料ビデオを見る</target>
        </trans-unit>
        <trans-unit id="3535c94715b644deaedbebce90d9555f3e89e9a6" translate="yes" xml:space="preserve">
          <source>Watch a free video course on Vue Mastery</source>
          <target state="translated">Vue Masteryの無料ビデオコースを見る</target>
        </trans-unit>
        <trans-unit id="3cd344bfc05810ff25f79ac8b462005767e2c6fd" translate="yes" xml:space="preserve">
          <source>Watch a free video course on Vue School</source>
          <target state="translated">Vue Schoolの無料動画講座を見る</target>
        </trans-unit>
        <trans-unit id="2f1efcb17036784de8e540836ed981009aebdfb3" translate="yes" xml:space="preserve">
          <source>Watch a free video lesson on Vue School</source>
          <target state="translated">Vue Schoolの無料動画レッスンを見る</target>
        </trans-unit>
        <trans-unit id="0b642e69ff5dd94afbc4e677ac7245afd2b75050" translate="yes" xml:space="preserve">
          <source>Watch a free video on Reactivity in Depth on Vue Mastery</source>
          <target state="translated">Vue Masteryで「反応性の深さ」の無料動画を見る</target>
        </trans-unit>
        <trans-unit id="3f2a20165ccd85b019b022c5d12f356aa7e7ddb2" translate="yes" xml:space="preserve">
          <source>Watch a free video on how to define custom events on Vue School</source>
          <target state="translated">Vue Schoolでカスタムイベントを定義する方法についての無料ビデオを見る</target>
        </trans-unit>
        <trans-unit id="50ef5fd200efa5ea9f0c8791591c28f563aa2607" translate="yes" xml:space="preserve">
          <source>Watch a free video on setup on Vue Mastery</source>
          <target state="translated">Vue Masteryのセットアップの無料ビデオを見る</target>
        </trans-unit>
        <trans-unit id="a603438f7073cd71b9f2b8f7c700ac8737ed9345" translate="yes" xml:space="preserve">
          <source>Watch a reactive property or a computed function on the component instance for changes. The callback gets called with the new value and the old value for the given property. We can only pass top-level &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;prop&lt;/code&gt;, or &lt;code&gt;computed&lt;/code&gt; property name as a string. For more complex expressions or nested properties, use a function instead.</source>
          <target state="translated">コンポーネントインスタンスのリアクティブプロパティまたは計算された関数に変更がないか監視します。コールバックは、指定されたプロパティの新しい値と古い値で呼び出されます。最上位の &lt;code&gt;data&lt;/code&gt; 、 &lt;code&gt;prop&lt;/code&gt; 、または &lt;code&gt;computed&lt;/code&gt; プロパティ名のみを文字列として渡すことができます。より複雑な式やネストされたプロパティの場合は、代わりに関数を使用してください。</target>
        </trans-unit>
        <trans-unit id="6a67bf8a391e3b919ddea5c7191736b34e4eda6f" translate="yes" xml:space="preserve">
          <source>Watch a video explanation on Vue Mastery</source>
          <target state="translated">Vue Masteryの解説動画を見る</target>
        </trans-unit>
        <trans-unit id="955262b41b7d1f92214423e751f80e0d37bd6a39" translate="yes" xml:space="preserve">
          <source>Watch an expression or a computed function on the Vue instance for changes. The callback gets called with the new value and the old value. The expression only accepts dot-delimited paths. For more complex expressions, use a function instead.</source>
          <target state="translated">Vue インスタンス上の式や計算された関数の変更を監視します。コールバックは、新しい値と古い値で呼び出されます。式は、ドットで区切られたパスのみを受け付けます。より複雑な式を使用する場合は、代わりに関数を使用します。</target>
        </trans-unit>
        <trans-unit id="aa35ca415d20b9f4a53f5d20f60b4e2506e17dc4" translate="yes" xml:space="preserve">
          <source>Watch on Arrays</source>
          <target state="translated">配列を見る</target>
        </trans-unit>
        <trans-unit id="0a37889e8f85fb3cc8ac5b854d904e40ddf13894" translate="yes" xml:space="preserve">
          <source>Watcher Debugging</source>
          <target state="translated">ウォッチャーのデバッグ</target>
        </trans-unit>
        <trans-unit id="cdc01934e544fe692a8a590e35cab70ab09f9b33" translate="yes" xml:space="preserve">
          <source>Watchers</source>
          <target state="translated">Watchers</target>
        </trans-unit>
        <trans-unit id="5cf8cbd115de2abf5faeb9247b097fd9a89418e1" translate="yes" xml:space="preserve">
          <source>Watchers allow us to animate changes of any numerical property into another property. That may sound complicated in the abstract, so let&amp;rsquo;s dive into an example using &lt;a href=&quot;https://greensock.com/&quot;&gt;GreenSock&lt;/a&gt;:</source>
          <target state="translated">ウォッチャーを使用すると、数値プロパティの変更を別のプロパティにアニメーション化できます。抽象的には複雑に聞こえるかもしれませんので、&lt;a href=&quot;https://greensock.com/&quot;&gt;GreenSock&lt;/a&gt;を使用した例を見てみましょう：</target>
        </trans-unit>
        <trans-unit id="3e3b9441a3e5ab81aea2316854b5cd4f81568ab3" translate="yes" xml:space="preserve">
          <source>Watchers allow us to animate changes of any numerical property into another property. That may sound complicated in the abstract, so let's dive into an example using &lt;a href=&quot;https://greensock.com/&quot;&gt;GreenSock (opens new window)&lt;/a&gt;:</source>
          <target state="translated">ウォッチャーを使用すると、数値プロパティの変更を別のプロパティにアニメーション化できます。抽象的には複雑に聞こえるかもしれないので、&lt;a href=&quot;https://greensock.com/&quot;&gt;GreenSock&lt;/a&gt;を使用した例に飛び込みましょう（新しいウィンドウを開きます）：</target>
        </trans-unit>
        <trans-unit id="4ba9360cf0bca86052f0efa45b5c520b36dc2561" translate="yes" xml:space="preserve">
          <source>Watchers created via &lt;code&gt;vm.$watch&lt;/code&gt; are now fired before the associated component rerenders. This gives you the chance to further update state before the component rerender, thus avoiding unnecessary updates. For example, you can watch a component prop and update the component&amp;rsquo;s own data when the prop changes.</source>
          <target state="translated">&lt;code&gt;vm.$watch&lt;/code&gt; 作成されたウォッチャーは、関連するコンポーネントが再レンダリングされる前に起動されるようになりました。これにより、コンポーネントが再レンダリングされる前に状態をさらに更新できるため、不要な更新を回避できます。たとえば、コンポーネントのプロップを監視し、プロップが変更されたときにコンポーネント自体のデータを更新できます。</target>
        </trans-unit>
        <trans-unit id="9c56f7248c60849f85774dec247f8195050af1aa" translate="yes" xml:space="preserve">
          <source>Watching Multiple Sources</source>
          <target state="translated">複数のソースを見る</target>
        </trans-unit>
        <trans-unit id="059a180684023e522c315cea524c6d4c3c650aaf" translate="yes" xml:space="preserve">
          <source>Watching Reactive Objects</source>
          <target state="translated">反応性のあるオブジェクトを見る</target>
        </trans-unit>
        <trans-unit id="8debcbf1f849cc32580625667ebbdeef8f8eeb6a" translate="yes" xml:space="preserve">
          <source>Watching Template Refs</source>
          <target state="translated">テンプレ参照を見る</target>
        </trans-unit>
        <trans-unit id="bace31b55ee998845b6d5b8e3891e59a6675d64c" translate="yes" xml:space="preserve">
          <source>Watching a Single Source</source>
          <target state="translated">単一のソースを見る</target>
        </trans-unit>
        <trans-unit id="3d17151eadf5c934a94706826860753d855216f0" translate="yes" xml:space="preserve">
          <source>Watching a template ref for changes can be an alternative to the use of lifecycle hooks that was demonstrated in the previous examples.</source>
          <target state="translated">変更のためのテンプレート参照を見ることは、以前の例で示したライフサイクルフックの使用の代わりになることができます。</target>
        </trans-unit>
        <trans-unit id="e58cc7cd1ba8085ead942b2bbc2bd84439f53be7" translate="yes" xml:space="preserve">
          <source>We also try very hard to avoid bias. As the core team, we obviously like Vue a lot. There are some problems we think it solves better than anything else out there. If we didn&amp;rsquo;t believe that, we wouldn&amp;rsquo;t be working on it. We do want to be fair and accurate though. Where other libraries offer significant advantages, such as React&amp;rsquo;s vast ecosystem of alternative renderers or Knockout&amp;rsquo;s browser support back to IE6, we try to list these as well.</source>
          <target state="translated">また、偏見を避けるために非常に努力しています。コアチームとして、私たちは明らかにVueをとても気に入っています。私たちが他の何よりもうまく解決すると考えるいくつかの問題があります。それが信じられなかったら、私たちはそれに取り組んでいないでしょう。ただし、公正かつ正確である必要があります。Reactの代替レンダラーの広大なエコシステムやIE6へのKnockoutのブラウザーサポートなど、他のライブラリーが重要な利点を提供する場合は、それらも同様にリストアップしようとします。</target>
        </trans-unit>
        <trans-unit id="145d670173003080c2dd95e109d6624af3091f7c" translate="yes" xml:space="preserve">
          <source>We appreciate small, focused PRs. If you'd like to make an extremely large change, please communicate with team members prior to a pull request. Here's a &lt;a href=&quot;https://www.netlify.com/blog/2020/03/31/how-to-scope-down-prs/&quot;&gt;writeup that details why this is so critical (opens new window)&lt;/a&gt; for us to work well on this team. Please understand that though we always appreciate contributions, ultimately we have to prioritize what works best for the project as a whole.</source>
          <target state="translated">小規模で焦点を絞ったPRに感謝します。非常に大きな変更を行う場合は、プルリクエストの前にチームメンバーに連絡してください。&lt;a href=&quot;https://www.netlify.com/blog/2020/03/31/how-to-scope-down-prs/&quot;&gt;これは&lt;/a&gt;、私たちがこのチームでうまく機能するためにこれが非常に重要である（新しいウィンドウを開く）理由を詳しく説明した記事です。私たちは常に貢献に感謝していますが、最終的にはプロジェクト全体に最適なものを優先する必要があることを理解してください。</target>
        </trans-unit>
        <trans-unit id="b3ddf11e5b6912a4511915ec63b40d6843a024e4" translate="yes" xml:space="preserve">
          <source>We are registering the invalidation callback via a passed-in function instead of returning it from the callback because the return value is important for async error handling. It is very common for the effect function to be an async function when performing data fetching:</source>
          <target state="translated">無効化コールバックをコールバックから返すのではなく、パスイン関数を介して登録しているのは、戻り値が非同期エラー処理に重要だからです。データ取得を行う際にエフェクト関数が非同期関数になることはよくあることです。</target>
        </trans-unit>
        <trans-unit id="7cf15350412bdd57a1ba478919853106222c77d2" translate="yes" xml:space="preserve">
          <source>We are still working on a dedicated Migration Build of Vue 3 with Vue 2 compatible behavior and runtime warnings of incompatible usage. If you are planning to migrate a non-trivial Vue 2 app, we strongly recommend waiting for the Migration Build for a smoother experience.</source>
          <target state="translated">Vue 2 と互換性のある動作と、互換性のない使用方法のランタイム警告を備えた Vue 3 の専用移行ビルドを現在も作成中です。Vue 2 以外のアプリの移行を計画している場合は、移行ビルドを待つことを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="1b413666b6609e2e923f9dac7f2dbb73deb11598" translate="yes" xml:space="preserve">
          <source>We are working on a new version of the Devtools with a new UI and refactored internals to support multiple Vue versions. The new version is currently in beta and only supports Vue 3 (for now). Vuex and Router integration is also work in progress.</source>
          <target state="translated">私たちは、複数のVueバージョンをサポートするために、新しいUIとリファクタリングされた内部を持つDevtoolsの新バージョンに取り組んでいます。新しいバージョンは現在ベータ版で、Vue 3のみをサポートしています(今のところ)。VuexとRouterの統合も進行中です。</target>
        </trans-unit>
        <trans-unit id="4590c53baf3d1bcb7b3f91125ba505380d0c3454" translate="yes" xml:space="preserve">
          <source>We can access slot contents as arrays of VNodes from &lt;a href=&quot;../api/instance-properties#slots&quot;&gt;&lt;code&gt;this.$slots&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">私たちは、からのvnodeの配列としてスロットの内容にアクセスすることができます&lt;a href=&quot;../api/instance-properties#slots&quot;&gt; &lt;code&gt;this.$slots&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="19325bef373c7011977b1dc1240632398096e83b" translate="yes" xml:space="preserve">
          <source>We can annotate a payload for the emitted event. Also, all non-declared emitted events will throw a type error when called:</source>
          <target state="translated">エミットされたイベントのペイロードをアノテーションすることができます。また、宣言されていないすべてのイベントは呼び出されたときに型エラーをスローします。</target>
        </trans-unit>
        <trans-unit id="ded0fe3886c210ed1f69601603a576fff08f9afa" translate="yes" xml:space="preserve">
          <source>We can check resources like &lt;a href=&quot;https://csstriggers.com/&quot;&gt;CSS-Triggers (opens new window)&lt;/a&gt; to see which properties will trigger repaints if we animate them. Here, if you look under &lt;code&gt;transform&lt;/code&gt;, you will see:</source>
          <target state="translated">&lt;a href=&quot;https://csstriggers.com/&quot;&gt;CSSトリガー（新しいウィンドウを開く）&lt;/a&gt;などのリソースをチェックして、アニメーション化した場合に再描画をトリガーするプロパティを確認できます。ここで、 &lt;code&gt;transform&lt;/code&gt; の下を見ると、次のように表示されます。</target>
        </trans-unit>
        <trans-unit id="c1d01d3af55b1b61c1d3a9c7fb07204866aad330" translate="yes" xml:space="preserve">
          <source>We can combine this technique with our previous implementation to animate every possible change to our list!</source>
          <target state="translated">このテクニックを以前の実装と組み合わせて、リストの変更をアニメーション化することができます。</target>
        </trans-unit>
        <trans-unit id="cd1d61172e00dd1e1c488b575a87db8e2cda970e" translate="yes" xml:space="preserve">
          <source>We can create extremely smooth animations on the web by being aware of performance. We want to hardware accelerate elements when we can, and use properties that don't trigger repaints. Let's go over some of how we can accomplish this.</source>
          <target state="translated">パフォーマンスを意識することで、Web上で非常に滑らかなアニメーションを作ることができます。可能な限り要素をハードウェアで高速化し、再描画のトリガーとならないようなプロパティを使用したいと考えています。これを実現する方法のいくつかを説明します。</target>
        </trans-unit>
        <trans-unit id="b738e997b0df8d616d9cdb2cc5977352977ba792" translate="yes" xml:space="preserve">
          <source>We can do this because the search button will help visual users identify the purpose of the input field.</source>
          <target state="translated">これができるのは、検索ボタンによって視覚的なユーザーが入力フィールドの目的を特定しやすくなるからです。</target>
        </trans-unit>
        <trans-unit id="578ccaba9c04ab4407d0e1982d8ccf1d0a6b7d5a" translate="yes" xml:space="preserve">
          <source>We can list emitted events in the component's &lt;code&gt;emits&lt;/code&gt; option:</source>
          <target state="translated">コンポーネントの &lt;code&gt;emits&lt;/code&gt; オプションで発行されたイベントを一覧表示できます。</target>
        </trans-unit>
        <trans-unit id="89a5cb8e42f077c1fe5767909f49df6511a23c3c" translate="yes" xml:space="preserve">
          <source>We can now use &lt;code&gt;v-model&lt;/code&gt; directly on our custom inputs, which is not only more consistent with normal inputs, but also means our component is Vuex-friendly.</source>
          <target state="translated">カスタム入力で &lt;code&gt;v-model&lt;/code&gt; を直接使用できるようになりました。これは、通常の入力との整合性が高まるだけでなく、コンポーネントがVuexに対応していることも意味します。</target>
        </trans-unit>
        <trans-unit id="8e665af7b29d480225aa1952784d4bbf8b4eb21b" translate="yes" xml:space="preserve">
          <source>We can pass an array to &lt;code&gt;:class&lt;/code&gt; to apply a list of classes:</source>
          <target state="translated">配列を &lt;code&gt;:class&lt;/code&gt; に渡して、クラスのリストを適用できます。</target>
        </trans-unit>
        <trans-unit id="355091be9a6d8f6adad9082fc7271b2db1fff1d5" translate="yes" xml:space="preserve">
          <source>We can pass an array to &lt;code&gt;v-bind:class&lt;/code&gt; to apply a list of classes:</source>
          <target state="translated">配列を &lt;code&gt;v-bind:class&lt;/code&gt; に渡して、クラスのリストを適用できます。</target>
        </trans-unit>
        <trans-unit id="406b9892cf3e59eeb19dc1064b0235c19adccc7c" translate="yes" xml:space="preserve">
          <source>We can pass an object to &lt;code&gt;:class&lt;/code&gt; (short for &lt;code&gt;v-bind:class&lt;/code&gt;) to dynamically toggle classes:</source>
          <target state="translated">オブジェクトを &lt;code&gt;:class&lt;/code&gt; （ &lt;code&gt;v-bind:class&lt;/code&gt; の略）に渡して、クラスを動的に切り替えることができます。</target>
        </trans-unit>
        <trans-unit id="005cab2aeec12d5fca81549807922fe01dfc3429" translate="yes" xml:space="preserve">
          <source>We can pass an object to &lt;code&gt;v-bind:class&lt;/code&gt; to dynamically toggle classes:</source>
          <target state="translated">オブジェクトを &lt;code&gt;v-bind:class&lt;/code&gt; に渡して、クラスを動的に切り替えることができます。</target>
        </trans-unit>
        <trans-unit id="977e7623c17ea7ebe75cd4f565824983dde786be" translate="yes" xml:space="preserve">
          <source>We can see from the table above, current implementation coerces &lt;code&gt;true&lt;/code&gt; to &lt;code&gt;'true'&lt;/code&gt; but removes the attribute if it's &lt;code&gt;false&lt;/code&gt;. This also led to inconsistency and required users to manually coerce boolean values to string in very common use cases like &lt;code&gt;aria-*&lt;/code&gt; attributes like &lt;code&gt;aria-selected&lt;/code&gt;, &lt;code&gt;aria-hidden&lt;/code&gt;, etc.</source>
          <target state="translated">上記の表からわかるように、現在の実装は &lt;code&gt;true&lt;/code&gt; を &lt;code&gt;'true'&lt;/code&gt; 強制しますが、 &lt;code&gt;false&lt;/code&gt; の場合は属性を削除します。これはまた、矛盾を引き起こし、ユーザーは、 &lt;code&gt;aria-selected&lt;/code&gt; 、 &lt;code&gt;aria-hidden&lt;/code&gt; などの &lt;code&gt;aria-*&lt;/code&gt; 属性のような非常に一般的なユースケースで、ブール値を文字列に手動で強制変換する必要がありました。</target>
        </trans-unit>
        <trans-unit id="c4415051c820f469ebda2e174386196145ce7433" translate="yes" xml:space="preserve">
          <source>We can use &lt;a href=&quot;component-provide-inject&quot;&gt;provide / inject&lt;/a&gt; with the Composition API as well. Both can only be called during &lt;a href=&quot;composition-api-setup&quot;&gt;&lt;code&gt;setup()&lt;/code&gt;&lt;/a&gt; with a current active instance.</source>
          <target state="translated">CompositionAPIで&lt;a href=&quot;component-provide-inject&quot;&gt;provide / inject&lt;/a&gt;を使用することもできます。両方とも、現在アクティブなインスタンスで&lt;a href=&quot;composition-api-setup&quot;&gt; &lt;code&gt;setup()&lt;/code&gt; &lt;/a&gt;中にのみ呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="df72788c45d87bd5e47825b2ad8e91055d4e9ce1" translate="yes" xml:space="preserve">
          <source>We can use CSS to visually hide elements but keep them available for assistive technology:</source>
          <target state="translated">CSS を使用して要素を視覚的に隠しつつ、支援技術のために利用可能な状態を維持することができます。</target>
        </trans-unit>
        <trans-unit id="c0ee275d541bee10b64a1c9ec38cc555e113f6f7" translate="yes" xml:space="preserve">
          <source>We can use the &lt;code&gt;v-for&lt;/code&gt; directive to render a list of items based on an array. The &lt;code&gt;v-for&lt;/code&gt; directive requires a special syntax in the form of &lt;code&gt;item in items&lt;/code&gt;, where &lt;code&gt;items&lt;/code&gt; is the source data array and &lt;code&gt;item&lt;/code&gt; is an &lt;strong&gt;alias&lt;/strong&gt; for the array element being iterated on:</source>
          <target state="translated">&lt;code&gt;v-for&lt;/code&gt; ディレクティブを使用して、配列に基づいて項目のリストをレンダリングできます。 &lt;code&gt;v-for&lt;/code&gt; ディレクティブは、の形で特別な構文が必要 &lt;code&gt;item in items&lt;/code&gt; 、 &lt;code&gt;items&lt;/code&gt; ソース・データ・アレイとなる &lt;code&gt;item&lt;/code&gt; ある&lt;strong&gt;別名&lt;/strong&gt;：上で反復される配列要素のための</target>
        </trans-unit>
        <trans-unit id="08647a6e0d6544e518fabc04e7c8f3381fecd799" translate="yes" xml:space="preserve">
          <source>We can use the &lt;code&gt;v-on&lt;/code&gt; directive to listen to DOM events and run some JavaScript when they&amp;rsquo;re triggered.</source>
          <target state="translated">&lt;code&gt;v-on&lt;/code&gt; ディレクティブを使用してDOMイベントをリッスンし、トリガーされたときにJavaScriptを実行できます。</target>
        </trans-unit>
        <trans-unit id="99b3e0b88025a1cd9dd1aa491f0dd2bc179180f4" translate="yes" xml:space="preserve">
          <source>We can use the &lt;code&gt;v-on&lt;/code&gt; directive, which we typically shorten to the &lt;code&gt;@&lt;/code&gt; symbol, to listen to DOM events and run some JavaScript when they're triggered. The usage would be &lt;code&gt;v-on:click=&quot;methodName&quot;&lt;/code&gt; or with the shortcut, &lt;code&gt;@click=&quot;methodName&quot;&lt;/code&gt;</source>
          <target state="translated">我々は使用することができ &lt;code&gt;v-on&lt;/code&gt; 、我々は通常に短縮され、ディレクティブを &lt;code&gt;@&lt;/code&gt; のDOMイベントに耳を傾け、彼らが起動しているときに、いくつかのJavaScriptを実行するために、シンボル。使用法は、 &lt;code&gt;v-on:click=&quot;methodName&quot;&lt;/code&gt; またはショートカット &lt;code&gt;@click=&quot;methodName&quot;&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="86b6da1cf882bfbaa28b18476abab8f6ff6b7b6e" translate="yes" xml:space="preserve">
          <source>We can use this to coordinate more expressive movement, such as a folding card, as demonstrated below. It's actually two elements transitioning between each other, but since the beginning and end states are scaling the same: horizontally to 0, it appears like one fluid movement. This type of sleight-of-hand can be very useful for realistic UI microinteractions:</source>
          <target state="translated">これを使って、下図のように、折り畳みカードのような、より表現力のある動きを調整することができます。実際には 2 つの要素が互いに遷移していますが、開始状態と終了状態のスケーリングが同じなので、水平方向に 0 を指定すると、1 つの流動的な動きのように見えます。この種の手品は、リアルな UI マイクロインタラクションに非常に役立ちます。</target>
        </trans-unit>
        <trans-unit id="817f50bdc2a016379b436c13b4b442890443585f" translate="yes" xml:space="preserve">
          <source>We could do the same for other &lt;strong&gt;logical concerns&lt;/strong&gt; but you might be already asking the question &amp;ndash; &lt;em&gt;Isn&amp;rsquo;t this just moving the code to the &lt;code&gt;setup&lt;/code&gt; option and making it extremely big?&lt;/em&gt; Well, that&amp;rsquo;s true. That&amp;rsquo;s why before moving on with the other responsibilities, we will first extract the above code into a standalone &lt;strong&gt;composition function&lt;/strong&gt;. Let's start with creating &lt;code&gt;useUserRepositories&lt;/code&gt;:</source>
          <target state="translated">他の&lt;strong&gt;論理的な懸念&lt;/strong&gt;についても同じ&lt;strong&gt;こと&lt;/strong&gt;ができますが、すでに質問をしているかもしれ&lt;em&gt;ません。これは、コードを &lt;code&gt;setup&lt;/code&gt; オプションに移動して、非常に大きくしているだけではありませんか？&lt;/em&gt;まあ、それは本当です。そのため、他の責任に進む前に、まず上記のコードをスタンドアロンの&lt;strong&gt;合成関数に&lt;/strong&gt;抽出し&lt;strong&gt;ます&lt;/strong&gt;。 &lt;code&gt;useUserRepositories&lt;/code&gt; の作成から始めましょう：</target>
        </trans-unit>
        <trans-unit id="283ffe41784517452c4544784a7be6d8d5108fe6" translate="yes" xml:space="preserve">
          <source>We could manage communication between components with this single event hub:</source>
          <target state="translated">このシングルイベントハブでコンポーネント間のコミュニケーションを管理することができました。</target>
        </trans-unit>
        <trans-unit id="0630f4d9efe7a98a7c8142cce5768ccbc2ddb708" translate="yes" xml:space="preserve">
          <source>We discuss &lt;a href=&quot;#Transitioning-Between-Components&quot;&gt;transitioning between components&lt;/a&gt; later, but you can also transition between raw elements using &lt;code&gt;v-if&lt;/code&gt;/&lt;code&gt;v-else&lt;/code&gt;. One of the most common two-element transitions is between a list container and a message describing an empty list:</source>
          <target state="translated">&lt;a href=&quot;#Transitioning-Between-Components&quot;&gt;コンポーネント間の遷移&lt;/a&gt;については後で説明しますが、 &lt;code&gt;v-if&lt;/code&gt; / &lt;code&gt;v-else&lt;/code&gt; を使用してraw要素間を遷移することもできます。最も一般的な2要素の遷移の1つは、リストコンテナーと空のリストを説明するメッセージの間の遷移です。</target>
        </trans-unit>
        <trans-unit id="e2e7b18ff8837f7d2c779646a84e95769cc3303b" translate="yes" xml:space="preserve">
          <source>We discuss &lt;a href=&quot;#transitioning-between-components&quot;&gt;transitioning between components&lt;/a&gt; later, but you can also transition between raw elements using &lt;code&gt;v-if&lt;/code&gt;/&lt;code&gt;v-else&lt;/code&gt;. One of the most common two-element transitions is between a list container and a message describing an empty list:</source>
          <target state="translated">&lt;a href=&quot;#transitioning-between-components&quot;&gt;コンポーネント間の移行&lt;/a&gt;については後で説明しますが、 &lt;code&gt;v-if&lt;/code&gt; / &lt;code&gt;v-else&lt;/code&gt; を使用してraw要素間を移行することもできます。最も一般的な2要素の遷移の1つは、リストコンテナと空のリストを説明するメッセージの間です。</target>
        </trans-unit>
        <trans-unit id="76b661bb8cef40b1e52670e390897ae263c3d477" translate="yes" xml:space="preserve">
          <source>We get similar benefits from updating:</source>
          <target state="translated">更新することで同じようなメリットを得ています。</target>
        </trans-unit>
        <trans-unit id="1404134e0f64ba7c9a0eb5c96c6caba434af9f39" translate="yes" xml:space="preserve">
          <source>We get the following benefits:</source>
          <target state="translated">以下のような特典があります。</target>
        </trans-unit>
        <trans-unit id="836491b426d471931d091eb3bfa8b677fe7b6214" translate="yes" xml:space="preserve">
          <source>We have a separate section for the new Angular because it really is a completely different framework from AngularJS. For example, it features a first-class component system, many implementation details have been completely rewritten, and the API has also changed quite drastically.</source>
          <target state="translated">新しいAngularはAngularJSとは全く違うフレームワークなので、別のセクションで紹介しています。例えば、ファーストクラスのコンポーネントシステムを特徴とし、多くの実装の詳細が完全に書き換えられ、APIも大幅に変更されています。</target>
        </trans-unit>
        <trans-unit id="9e8c721f28fbdf12b00ac6dc8ba0de44aa2efa5c" translate="yes" xml:space="preserve">
          <source>We have already created our very first Vue app! This looks pretty similar to rendering a string template, but Vue has done a lot of work under the hood. The data and the DOM are now linked, and everything is now &lt;strong&gt;reactive&lt;/strong&gt;. How do we know? Open your browser&amp;rsquo;s JavaScript console (right now, on this page) and set &lt;code&gt;app.message&lt;/code&gt; to a different value. You should see the rendered example above update accordingly.</source>
          <target state="translated">すでに最初のVueアプリを作成しました！これは文字列テンプレートのレンダリングとかなり似ていますが、Vueは内部で多くの作業を行っています。データとDOMがリンクされ、すべてが&lt;strong&gt;リアクティブになり&lt;/strong&gt;ます。どうやって知るの？ブラウザーのJavaScriptコンソール（現在、このページ）を &lt;code&gt;app.message&lt;/code&gt; 、app.messageを別の値に設定します。それに応じて、上記のレンダリングされた例が更新されます。</target>
        </trans-unit>
        <trans-unit id="a3de3e0ebfec380551325c5d2024c30336332771" translate="yes" xml:space="preserve">
          <source>We have already created our very first Vue app! This looks pretty similar to rendering a string template, but Vue has done a lot of work under the hood. The data and the DOM are now linked, and everything is now &lt;strong&gt;reactive&lt;/strong&gt;. How do we know? Take a look at the example below where &lt;code&gt;counter&lt;/code&gt; property increments every second and you will see how rendered DOM changes:</source>
          <target state="translated">私たちはすでに最初のVueアプリを作成しました！これは文字列テンプレートのレンダリングと非常によく似ていますが、Vueは内部で多くの作業を行っています。データとDOMがリンクされ、すべてが&lt;strong&gt;リアクティブになりました&lt;/strong&gt;。どうやって知るの？以下の例を見てください。ここでは、 &lt;code&gt;counter&lt;/code&gt; プロパティが毎秒増分し、レンダリングされたDOMがどのように変化するかがわかります。</target>
        </trans-unit>
        <trans-unit id="9882cb189eb18be1f8b18353e20480e68691217f" translate="yes" xml:space="preserve">
          <source>We have created a standalone guide for creating server-rendered Vue applications. This is a very in-depth guide for those who are already familiar with client-side Vue development, server-side Node.js development and webpack. Check it out at &lt;a href=&quot;https://ssr.vuejs.org/&quot;&gt;ssr.vuejs.org (opens new window)&lt;/a&gt;.</source>
          <target state="translated">サーバーでレンダリングされたVueアプリケーションを作成するためのスタンドアロンガイドを作成しました。これは、クライアント側のVue開発、サーバー側のNode.js開発、およびwebpackに既に精通している人向けの非常に詳細なガイドです。&lt;a href=&quot;https://ssr.vuejs.org/&quot;&gt;ssr.vuejs.orgで&lt;/a&gt;チェックしてください（新しいウィンドウが開きます）。</target>
        </trans-unit>
        <trans-unit id="aa5c9fe6c6c8767e1c9e46c7912f5d36985ece63" translate="yes" xml:space="preserve">
          <source>We have created a standalone guide for creating server-rendered Vue applications. This is a very in-depth guide for those who are already familiar with client-side Vue development, server-side Node.js development and webpack. Check it out at &lt;a href=&quot;https://ssr.vuejs.org/&quot;&gt;ssr.vuejs.org&lt;/a&gt;.</source>
          <target state="translated">サーバーレンダリングされたVueアプリケーションを作成するためのスタンドアロンガイドを作成しました。これは、クライアント側のVue開発、サーバー側のNode.js開発、およびWebpackにすでに精通している人のための非常に詳細なガイドです。&lt;a href=&quot;https://ssr.vuejs.org/&quot;&gt;ssr.vuejs.orgで&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="5e2d326202574eaf0a4b0a6f118cf078e50093fa" translate="yes" xml:space="preserve">
          <source>We have moved several pieces of our first logical concern into the &lt;code&gt;setup&lt;/code&gt; method, nicely put close to each other. What&amp;rsquo;s left is calling &lt;code&gt;getUserRepositories&lt;/code&gt; in the &lt;code&gt;mounted&lt;/code&gt; hook and setting up a watcher to do that whenever the &lt;code&gt;user&lt;/code&gt; prop changes.</source>
          <target state="translated">最初の論理的な懸念事項のいくつかを &lt;code&gt;setup&lt;/code&gt; 方法に移し、互いにうまく近づけました。残っているのは、 &lt;code&gt;mounted&lt;/code&gt; フックで &lt;code&gt;getUserRepositories&lt;/code&gt; を呼び出し、 &lt;code&gt;user&lt;/code&gt; 小道具が変更されるたびにそれを行うようにウォッチャーを設定することです。</target>
        </trans-unit>
        <trans-unit id="0f49be9e4b4a0bd2cc13f3ef887bdbb56e8ea881" translate="yes" xml:space="preserve">
          <source>We have some dedicated styles to denote something that's worth highlighting in a particular way. These are captured &lt;a href=&quot;../doc-style-guide#alerts&quot;&gt;on this page (opens new window)&lt;/a&gt;. &lt;strong&gt;They are to be used sparingly.&lt;/strong&gt;</source>
          <target state="translated">特定の方法で強調する価値のあるものを示すために、いくつかの専用のスタイルがあります。これらは&lt;a href=&quot;../doc-style-guide#alerts&quot;&gt;このページに&lt;/a&gt;キャプチャされます（新しいウィンドウが開きます）。&lt;strong&gt;それらは控えめに使用されます。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2365bbdeaabeff7b76c97dd6062eceb546eae44b" translate="yes" xml:space="preserve">
          <source>We have to provide a proper prop name for the event handler, e.g., to handle &lt;code&gt;click&lt;/code&gt; events, the prop name would be &lt;code&gt;onClick&lt;/code&gt;.</source>
          <target state="translated">イベントハンドラーに適切なプロップ名を指定する必要があります。たとえば、 &lt;code&gt;click&lt;/code&gt; イベントを処理するには、プロップ名は &lt;code&gt;onClick&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="7b667182eef0a9564fcc136526a19be6641183fb" translate="yes" xml:space="preserve">
          <source>We intend to drop this internal concept of &quot;enumerated attributes&quot; and treat them as normal non-boolean HTML attributes.</source>
          <target state="translated">この「列挙された属性」という内部概念を捨てて、通常の非ブーリアンHTML属性として扱うつもりです。</target>
        </trans-unit>
        <trans-unit id="3e3eea1c16de0a8e9cf42e189bd675df96a77366" translate="yes" xml:space="preserve">
          <source>We make a copy of the DOM in JavaScript called the Virtual DOM, we do this because touching the DOM with JavaScript is computationally expensive. While performing updates in JavaScript is cheap, finding the required DOM nodes and updating them with JavaScript is expensive. So we batch calls, and change the DOM all at once.</source>
          <target state="translated">JavaScript で DOM のコピーを仮想 DOM と呼ばれる JavaScript で作成していますが、これは JavaScript で DOM に触れると計算コストがかかるためです。JavaScriptで更新を行うのは安価ですが、必要なDOMノードを見つけてJavaScriptで更新するのはコストがかかります。そこで、バッチコールで一括してDOMを変更しています。</target>
        </trans-unit>
        <trans-unit id="73a6f46a302366b1b4d268e8a2baf4204e756c65" translate="yes" xml:space="preserve">
          <source>We mentioned before that in order to have an API that updates a final value when something changes, we&amp;rsquo;re going to have to set new values when something changes. We do this in the handler, in a function called &lt;code&gt;track&lt;/code&gt;, where we pass in the &lt;code&gt;target&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">前に述べたように、何かが変更されたときに最終値を更新するAPIを使用するには、何かが変更されたときに新しい値を設定する必要があります。これは、ハンドラーの &lt;code&gt;track&lt;/code&gt; という関数で行い &lt;code&gt;key&lt;/code&gt; 。ここで、 &lt;code&gt;target&lt;/code&gt; とキーを渡します。</target>
        </trans-unit>
        <trans-unit id="9bd40e61c317c21b5589b1855722a4f76630a6a7" translate="yes" xml:space="preserve">
          <source>We might want the text &quot;Submit&quot; to be rendered inside the &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; most of the time. To make &quot;Submit&quot; the fallback content, we can place it in between the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; tags:</source>
          <target state="translated">ほとんどの場合、「送信」というテキストを &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; 内に表示したい場合があります。フォールバックコンテンツを「送信」するには、 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; タグの間に配置します。</target>
        </trans-unit>
        <trans-unit id="2ce5b81c111ded5524bb8ba95145dfdcec13c623" translate="yes" xml:space="preserve">
          <source>We might want the text &amp;ldquo;Submit&amp;rdquo; to be rendered inside the &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; most of the time. To make &amp;ldquo;Submit&amp;rdquo; the fallback content, we can place it in between the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; tags:</source>
          <target state="translated">ほとんどの場合、「送信」というテキストを &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; 内にレンダリングする必要があります。「送信」をフォールバックコンテンツにするには、 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; タグの間に配置します。</target>
        </trans-unit>
        <trans-unit id="7ea4d2b2947c843536ed2a98837450506cc32476" translate="yes" xml:space="preserve">
          <source>We might want to replace the &lt;code&gt;{{ item }}&lt;/code&gt; with a &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; to customize it on parent component:</source>
          <target state="translated">&lt;code&gt;{{ item }}&lt;/code&gt; を &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; に置き換えて、親コンポーネントでカスタマイズすることもできます。</target>
        </trans-unit>
        <trans-unit id="38b8c040118415f530225ac0a01e6d757fa256dc" translate="yes" xml:space="preserve">
          <source>We might want to replace this fallback content to display the user&amp;rsquo;s first name, instead of last, like this:</source>
          <target state="translated">次のように、このフォールバックコンテンツを置き換えて、姓ではなくユーザーの名を表示することができます。</target>
        </trans-unit>
        <trans-unit id="549db0def9cf014f83eb865e4d0765c64a3bfee1" translate="yes" xml:space="preserve">
          <source>We might want to reuse this component, allowing users to maintain multiple lists (e.g. for shopping, wishlists, daily chores, etc). There&amp;rsquo;s a problem though. Since every instance of the component references the same data object, changing the title of one list will also change the title of every other list. The same is true for adding/editing/deleting a todo.</source>
          <target state="translated">このコンポーネントを再利用して、ユーザーが複数のリストを維持できるようにする場合があります（たとえば、買い物、買い物リスト、毎日の雑用など）。問題があります。コンポーネントのすべてのインスタンスが同じデータオブジェクトを参照するため、1つのリストのタイトルを変更すると、他のすべてのリストのタイトルも変更されます。Todoを追加/編集/削除する場合も同様です。</target>
        </trans-unit>
        <trans-unit id="d78b76b13dec2d9479f1cfb4f190e2eb6e217389" translate="yes" xml:space="preserve">
          <source>We recommend replacing any complex expressions with a &lt;a href=&quot;computed&quot;&gt;computed property&lt;/a&gt;, one of the most fundamental pieces of Vue, which we'll cover shortly.</source>
          <target state="translated">複雑な式は、Vueの最も基本的な部分の1つである&lt;a href=&quot;computed&quot;&gt;計算プロパティ&lt;/a&gt;に置き換えることをお勧めします。これについては、後ほど説明します。</target>
        </trans-unit>
        <trans-unit id="b734f82d47813efa3a6806ce727611d03115657d" translate="yes" xml:space="preserve">
          <source>We recommend:</source>
          <target state="translated">お勧めします。</target>
        </trans-unit>
        <trans-unit id="4b9d55967630e0ffef70ef9b3f460a567135d1e5" translate="yes" xml:space="preserve">
          <source>We removed &lt;code&gt;$on&lt;/code&gt;, &lt;code&gt;$off&lt;/code&gt; and &lt;code&gt;$once&lt;/code&gt; methods from the instance completely. &lt;code&gt;$emit&lt;/code&gt; is still a part of the existing API as it's used to trigger event handlers declaratively attached by a parent component</source>
          <target state="translated">&lt;code&gt;$on&lt;/code&gt; 、 &lt;code&gt;$off&lt;/code&gt; 、 &lt;code&gt;$once&lt;/code&gt; メソッドをインスタンスから完全に削除しました。 &lt;code&gt;$emit&lt;/code&gt; は、親コンポーネントによって宣言的にアタッチされたイベントハンドラーをトリガーするために使用されるため、既存のAPIの一部です。</target>
        </trans-unit>
        <trans-unit id="90f5ee5b56c067fa325613b60b7faa1aebd9325d" translate="yes" xml:space="preserve">
          <source>We surround the arguments with parentheses and delimit the arguments with commas:</source>
          <target state="translated">引数を括弧で囲み、カンマで区切ります。</target>
        </trans-unit>
        <trans-unit id="3f6388f12bd97827e87f720eb7e6528b0cdd918b" translate="yes" xml:space="preserve">
          <source>We use it like this: &lt;code&gt;new Proxy(target, handler)&lt;/code&gt;</source>
          <target state="translated">次のように使用します： &lt;code&gt;new Proxy(target, handler)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="866e301e87de4875c510e32c3de7ad212732a107" translate="yes" xml:space="preserve">
          <source>We want to make a function to translate keys available to the whole application, so we will expose it using &lt;code&gt;app.config.globalProperties&lt;/code&gt;.</source>
          <target state="translated">キーを変換する関数をアプリケーション全体で使用できるようにしたいので、 &lt;code&gt;app.config.globalProperties&lt;/code&gt; を使用して公開します。</target>
        </trans-unit>
        <trans-unit id="02bb8d549018405cd3717be9cfc0482cf533a00b" translate="yes" xml:space="preserve">
          <source>We will assume that our users will pass in an object containing the translated keys in the &lt;code&gt;options&lt;/code&gt; parameter when they use the plugin. Our &lt;code&gt;$translate&lt;/code&gt; function will take a string such as &lt;code&gt;greetings.hello&lt;/code&gt;, look inside the user provided configuration and return the translated value - in this case, &lt;code&gt;Bonjour!&lt;/code&gt;</source>
          <target state="translated">ユーザーがプラグインを使用するときに、 &lt;code&gt;options&lt;/code&gt; パラメーターに変換されたキーを含むオブジェクトを渡すと想定します。私たちの &lt;code&gt;$translate&lt;/code&gt; 機能は、次のような文字列を取る &lt;code&gt;greetings.hello&lt;/code&gt; 、ユーザー提供の構成の内側を見てと翻訳された値を返す-この場合、中 &lt;code&gt;Bonjour!&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f2d79d26a57c657532cfa93323b5aa7856a950f" translate="yes" xml:space="preserve">
          <source>We will cover all of these and more in the next three sections in this Guide. However, aside from these useful API offerings, it's worth mentioning that the class and style declarations we covered earlier can be used to apply animations and transitions as well, for more simple use cases.</source>
          <target state="translated">このガイドの次の 3 つのセクションでは、これらのすべての機能とそれ以上の機能について説明します。しかし、これらの便利な API の提供とは別に、先に説明したクラスとスタイルの宣言は、よりシンプルなユースケースのために、アニメーションやトランジションを適用するためにも使用できることに言及しておく価値があります。</target>
        </trans-unit>
        <trans-unit id="0330d8076787db736d1163a550844572651d3ec8" translate="yes" xml:space="preserve">
          <source>We will need to install Rollup and a few dependencies:</source>
          <target state="translated">Rollupといくつかの依存関係をインストールする必要があります。</target>
        </trans-unit>
        <trans-unit id="9990a125d88c5ba238d041e04854bb4b051a20bc" translate="yes" xml:space="preserve">
          <source>We will start with the lifecycle hook.</source>
          <target state="translated">ライフサイクルフックから始めます。</target>
        </trans-unit>
        <trans-unit id="07bee3c68a3f59f9dbc34ec660b948ec6a34b4f2" translate="yes" xml:space="preserve">
          <source>We will start with the most obvious parts:</source>
          <target state="translated">まずは一番わかりやすいところから始めます。</target>
        </trans-unit>
        <trans-unit id="34746e60611d8ce199ba5e1744dcd31fcb6189c0" translate="yes" xml:space="preserve">
          <source>We will use the &lt;code&gt;i18nPlugin&lt;/code&gt; we created in the &lt;a href=&quot;#writing-a-plugin&quot;&gt;Writing a Plugin&lt;/a&gt; section for demo purposes.</source>
          <target state="translated">デモの目的で、&lt;a href=&quot;#writing-a-plugin&quot;&gt;「プラグインの&lt;/a&gt;作成」 &lt;code&gt;i18nPlugin&lt;/code&gt; で作成したi18nPluginを使用します。</target>
        </trans-unit>
        <trans-unit id="c5b7e00cf3c217540b9859501e68dc10129cbf2f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;d also like &lt;strong&gt;your&lt;/strong&gt; help keeping this document up-to-date because the JavaScript world moves fast! If you notice an inaccuracy or something that doesn&amp;rsquo;t seem quite right, please let us know by &lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/new?title=Inaccuracy+in+comparisons+guide&quot;&gt;opening an issue&lt;/a&gt;.</source>
          <target state="translated">また、JavaScriptの世界は急速に変化しているため、このドキュメントを最新の状態に保つためにも&lt;strong&gt;ご&lt;/strong&gt;協力を&lt;strong&gt;お願いします&lt;/strong&gt;。不正確な点や正しくないと思われる点に気づいた場合は&lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/new?title=Inaccuracy+in+comparisons+guide&quot;&gt;、問題を開い&lt;/a&gt;てお知らせください。</target>
        </trans-unit>
        <trans-unit id="d9d3e90ad0f5f8e3a16d2f0593a1c96b7e9437ba" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll cover VNodes in more detail &lt;a href=&quot;render-function#The-Virtual-DOM&quot;&gt;later&lt;/a&gt;, when we discuss &lt;a href=&quot;render-function&quot;&gt;render functions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;render-function&quot;&gt;レンダー関数&lt;/a&gt;について説明するとき&lt;a href=&quot;render-function#The-Virtual-DOM&quot;&gt;に&lt;/a&gt;、後で VNodeについてさらに詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="a2a13deabe649b5c3118707a53fb4509b5ea3b89" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll explore the arguments passed into these hooks (i.e. &lt;code&gt;el&lt;/code&gt;, &lt;code&gt;binding&lt;/code&gt;, &lt;code&gt;vnode&lt;/code&gt;, and &lt;code&gt;oldVnode&lt;/code&gt;) in the next section.</source>
          <target state="translated">これらのフック（つまり、 &lt;code&gt;el&lt;/code&gt; 、 &lt;code&gt;binding&lt;/code&gt; 、 &lt;code&gt;vnode&lt;/code&gt; 、および &lt;code&gt;oldVnode&lt;/code&gt; ）に渡される引数については、次のセクションで説明します。</target>
        </trans-unit>
        <trans-unit id="48d3e43fe68276b9cc259bd79455e2bc4213c8db" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll talk about &lt;a href=&quot;components&quot;&gt;the component system&lt;/a&gt; in detail later. For now, just know that all Vue components are also Vue instances, and so accept the same options object (except for a few root-specific options).</source>
          <target state="translated">&lt;a href=&quot;components&quot;&gt;コンポーネントシステム&lt;/a&gt;については、後で詳しく説明します。とりあえず、すべてのVueコンポーネントもVueインスタンスであることを知っているだけなので、同じオプションオブジェクトを受け入れます（いくつかのルート固有のオプションを除く）。</target>
        </trans-unit>
        <trans-unit id="8573a8cbd8f1b40ae7525ff0d66bbf6d9920e106" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re simply following the conventions of each language. Within JavaScript, camelCase is more natural. Within HTML, kebab-case is.</source>
          <target state="translated">私たちは単に各言語の慣習に従っています。JavaScript内では、キャメルケースの方が自然です。HTMLでは、ケバブケースです。</target>
        </trans-unit>
        <trans-unit id="b358f1e880381f7d6e871561f446388962244398" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re still limited however, by filters and by Vue 1.0 in general, so let&amp;rsquo;s complete the upgrade to Vue 2.0:</source>
          <target state="translated">ただし、フィルターや一般的にVue 1.0によって制限されているため、Vue 2.0へのアップグレードを完了しましょう。</target>
        </trans-unit>
        <trans-unit id="54237427c42ae1e9fb9b273cbab35c157528d0e1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve briefly introduced the most basic features of Vue.js core - the rest of this guide will cover them and other advanced features with much finer details, so make sure to read through it all!</source>
          <target state="translated">Vue.jsコアの最も基本的な機能を簡単に紹介しました。このガイドの残りの部分では、これらの機能とその他の高度な機能を詳細に説明しますので、必ずお読みください。</target>
        </trans-unit>
        <trans-unit id="eb8b82ed49a41a1aeaad51c988296a83c46302ad" translate="yes" xml:space="preserve">
          <source>We'll be using GreenSock in some of the examples in the sections following. They have a great &lt;a href=&quot;https://greensock.com/ease-visualizer&quot;&gt;ease visualizer (opens new window)&lt;/a&gt; that will help you build nicely crafted eases.</source>
          <target state="translated">次のセクションのいくつかの例では、GreenSockを使用します。彼らはあなたがうまく細工された&lt;a href=&quot;https://greensock.com/ease-visualizer&quot;&gt;イーズ&lt;/a&gt;を構築するのを助ける素晴らしいイーズビジュアライザー（新しいウィンドウを開く）を持っています。</target>
        </trans-unit>
        <trans-unit id="4abdbdf8ec29be45ff4f5a54f8824c87ed93395f" translate="yes" xml:space="preserve">
          <source>We'll cover VNodes in more detail &lt;a href=&quot;render-function#the-virtual-dom-tree&quot;&gt;later&lt;/a&gt;, when we discuss render functions.</source>
          <target state="translated">VNodeについて&lt;a href=&quot;render-function#the-virtual-dom-tree&quot;&gt;は&lt;/a&gt;、後でレンダリング関数について説明するときに詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="d11cb422fd9a8827a4bee9296e2eefeb8799791f" translate="yes" xml:space="preserve">
          <source>We'll talk about &lt;a href=&quot;component-basics&quot;&gt;the component system&lt;/a&gt; in detail later. For now, just be aware that the root component isn't really any different from any other component. The configuration options are the same, as is the behavior of the corresponding component instance.</source>
          <target state="translated">&lt;a href=&quot;component-basics&quot;&gt;コンポーネントシステム&lt;/a&gt;については、後で詳しく説明します。今のところ、ルートコンポーネントは他のコンポーネントと実際には何の違いもないことに注意してください。対応するコンポーネントインスタンスの動作と同様に、構成オプションは同じです。</target>
        </trans-unit>
        <trans-unit id="4763cc35fb84a23678cf26a9f7a29bb762c52dee" translate="yes" xml:space="preserve">
          <source>We're showing you a simple example here, but in a typical Vue application we use Single File Components instead of a string template. You can find more information about them &lt;a href=&quot;single-file-component&quot;&gt;in this section&lt;/a&gt;.</source>
          <target state="translated">ここでは簡単な例を示していますが、一般的なVueアプリケーションでは、文字列テンプレートの代わりに単一ファイルコンポーネントを使用します。これらの詳細について&lt;a href=&quot;single-file-component&quot;&gt;は、このセクションを参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="902ee1e6bc3aa622843aa289195cfdd213ac8ef1" translate="yes" xml:space="preserve">
          <source>We're simply following the conventions of each language. Within JavaScript, camelCase is more natural. Within HTML, kebab-case is.</source>
          <target state="translated">それぞれの言語の規約に従っているだけです。JavaScript の中では、キャメルケースの方が自然です。HTMLでは、ケバブケースです。</target>
        </trans-unit>
        <trans-unit id="ee3ca188b1df773cfd1eeb0376541bfa59686bfe" translate="yes" xml:space="preserve">
          <source>We've briefly introduced the most basic features of Vue.js core - the rest of this guide will cover them and other advanced features with much finer details, so make sure to read through it all!</source>
          <target state="translated">Vue.js コアの最も基本的な機能を簡単に紹介しましたが、このガイドの残りの部分では、これらの機能とその他の高度な機能について詳しく説明していきますので、必ず最後まで読んでください。</target>
        </trans-unit>
        <trans-unit id="c96cc25eb05f1274ae7b9eebefd157220abac3ca" translate="yes" xml:space="preserve">
          <source>Web Accessibility Initiative &amp;ndash; Accessible Rich Internet Applications (WAI-ARIA)</source>
          <target state="translated">Web Accessibility Initiative &amp;ndash;アクセシブルなリッチインターネットアプリケーション（WAI-ARIA）</target>
        </trans-unit>
        <trans-unit id="fcf30cbd1ee6db2c9121250baf622ac22c881128" translate="yes" xml:space="preserve">
          <source>Web Accessibility Perspectives: Explore the Impact and Benefits for Everyone (opens new window)</source>
          <target state="translated">ウェブアクセシビリティの視点。すべての人にとっての影響とメリットを探る(新しいウィンドウが開きます</target>
        </trans-unit>
        <trans-unit id="ff265f994041ba5e431f8222c5c1ba6691182894" translate="yes" xml:space="preserve">
          <source>Web Content Accessibility Guidelines (WCAG)</source>
          <target state="translated">ウェブコンテンツアクセシビリティガイドライン(WCAG</target>
        </trans-unit>
        <trans-unit id="83aec0744d18b3272452883bc73b55a421d84c62" translate="yes" xml:space="preserve">
          <source>Web Content Accessibility Guidelines (WCAG) (opens new window)</source>
          <target state="translated">ウェブコンテンツアクセシビリティガイドライン(WCAG)(新しいウィンドウが開きます</target>
        </trans-unit>
        <trans-unit id="279f4a441a4b12f3b9de64ff7f0e63d1f6fc5d06" translate="yes" xml:space="preserve">
          <source>Web accessibility (also known as a11y) refers to the practice of creating websites that can be used by anyone &amp;mdash; be that a person with a disability, a slow connection, outdated or broken hardware or simply someone in an unfavorable environment. For example, adding subtitles to a video would help both your deaf and hard-of-hearing users and your users who are in a loud environment and can't hear their phone. Similarly, making sure your text isn't too low contrast will help both your low-vision users and your users who are trying to use their phone in bright sunlight.</source>
          <target state="translated">Webアクセシビリティ（a11yとも呼ばれます）とは、障害のある人、接続が遅い人、ハードウェアが古くなっているか壊れている人、または単に不利な環境にいる人など、誰でも使用できるWebサイトを作成する方法を指します。たとえば、ビデオに字幕を追加すると、聴覚障害者と難聴者の両方のユーザーと、騒がしい環境にいて電話が聞こえないユーザーの両方に役立ちます。同様に、テキストのコントラストが低すぎないことを確認すると、弱視のユーザーと、明るい日光の下でスマートフォンを使用しようとしているユーザーの両方に役立ちます。</target>
        </trans-unit>
        <trans-unit id="8917af5cf347fb6a6fe194798f4f56a85c811a01" translate="yes" xml:space="preserve">
          <source>WebAim Color Contrast (opens new window)</source>
          <target state="translated">WebAim カラーコントラスト(新しいウィンドウが開きます</target>
        </trans-unit>
        <trans-unit id="bca0768e3dfd8cfbe2c2bff1e16645bb18dbfe9b" translate="yes" xml:space="preserve">
          <source>WebAim Link Color Contrast (opens new window)</source>
          <target state="translated">WebAimリンク カラーコントラスト(新しいウィンドウが開きます</target>
        </trans-unit>
        <trans-unit id="642803d03826095e048310e6f6fdb2336f081224" translate="yes" xml:space="preserve">
          <source>Webpack</source>
          <target state="translated">Webpack</target>
        </trans-unit>
        <trans-unit id="b0f63abab58780fc9096086a11d8c4fd44969c50" translate="yes" xml:space="preserve">
          <source>Webpack Configuration</source>
          <target state="translated">Webpack の設定</target>
        </trans-unit>
        <trans-unit id="8bea3e418773cf65893996cd6beb9f369dec51f2" translate="yes" xml:space="preserve">
          <source>What About Separation of Concerns?</source>
          <target state="translated">懸念事項の分離は?</target>
        </trans-unit>
        <trans-unit id="c41e81975a805013a596d74998d05b0991be3b34" translate="yes" xml:space="preserve">
          <source>What You Can Do</source>
          <target state="translated">あなたにできること</target>
        </trans-unit>
        <trans-unit id="167fd1d6380ec0bfe627ebef6ee16c27264edd27" translate="yes" xml:space="preserve">
          <source>What is &lt;code&gt;createElement&lt;/code&gt; actually returning? It&amp;rsquo;s not &lt;em&gt;exactly&lt;/em&gt; a real DOM element. It could perhaps more accurately be named &lt;code&gt;createNodeDescription&lt;/code&gt;, as it contains information describing to Vue what kind of node it should render on the page, including descriptions of any child nodes. We call this node description a &amp;ldquo;virtual node&amp;rdquo;, usually abbreviated to &lt;strong&gt;VNode&lt;/strong&gt;. &amp;ldquo;Virtual DOM&amp;rdquo; is what we call the entire tree of VNodes, built by a tree of Vue components.</source>
          <target state="translated">&lt;code&gt;createElement&lt;/code&gt; が実際に返すものは何ですか？そうではありません&lt;em&gt;正確に&lt;/em&gt;、実際のDOM要素。子ノードの説明など、ページにレンダリングする必要があるノードの種類をVueに説明する情報が含まれているため、おそらくより正確に &lt;code&gt;createNodeDescription&lt;/code&gt; という名前を付けることができます。このノードの説明を「仮想ノード」と呼び、通常は&lt;strong&gt;VNodeと&lt;/strong&gt;省略され&lt;strong&gt;ます&lt;/strong&gt;。「仮想DOM」は、Vueコンポーネントのツリーによって構築されたVNodeのツリー全体と呼ばれるものです。</target>
        </trans-unit>
        <trans-unit id="c23944cd8d26c2cb26b60dd0d1caadba140c80c6" translate="yes" xml:space="preserve">
          <source>What is Reactivity?</source>
          <target state="translated">反応性とは?</target>
        </trans-unit>
        <trans-unit id="fe4bf93cce91f7c3fb6d3854aa9288f33a74e958" translate="yes" xml:space="preserve">
          <source>What is Vue.js?</source>
          <target state="translated">Vue.jsとは?</target>
        </trans-unit>
        <trans-unit id="6762984b105eb8b517b607b726e8ea600efa2e2a" translate="yes" xml:space="preserve">
          <source>What is the &lt;code&gt;h()&lt;/code&gt; function returning? It's not &lt;em&gt;exactly&lt;/em&gt; a real DOM element. It returns a plain object which contains information describing to Vue what kind of node it should render on the page, including descriptions of any child nodes. We call this node description a &quot;virtual node&quot;, usually abbreviated to &lt;strong&gt;VNode&lt;/strong&gt;. &quot;Virtual DOM&quot; is what we call the entire tree of VNodes, built by a tree of Vue components.</source>
          <target state="translated">&lt;code&gt;h()&lt;/code&gt; 関数は何を返しますか？そうではありません&lt;em&gt;正確に&lt;/em&gt;、実際のDOM要素。子ノードの説明など、ページにレンダリングする必要のあるノードの種類をVueに説明する情報を含むプレーンオブジェクトを返します。このノードの説明を「仮想ノード」と呼び、通常は&lt;strong&gt;VNodeと&lt;/strong&gt;略され&lt;strong&gt;ます&lt;/strong&gt;。「仮想DOM」は、Vueコンポーネントのツリーによって構築されたVNodeのツリー全体と呼ばれるものです。</target>
        </trans-unit>
        <trans-unit id="87b4db1127a98add882b9a9fa2787d6954410927" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; has multiple children, they should eventually evaluate to a single child. Any child other than the first one will be ignored.</source>
          <target state="translated">とき &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 複数の子を持って、彼らは最終的に、単一の子供に評価する必要があります。最初の子以外の子は無視されます。</target>
        </trans-unit>
        <trans-unit id="4fa4fac2c46b4a9cb5fd7f97a6be2dad1bbe60c8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;count&lt;/code&gt; is mutated, the callback will be called &lt;strong&gt;before&lt;/strong&gt; the component has updated.</source>
          <target state="translated">ときに &lt;code&gt;count&lt;/code&gt; 変異して、コールバックが呼び出されます&lt;strong&gt;前に、&lt;/strong&gt;コンポーネントが更新されました。</target>
        </trans-unit>
        <trans-unit id="309b02e7394c67ecb1bf6afa2ce27ef901e58b3d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;isActive&lt;/code&gt; is truthy, the rendered HTML will be:</source>
          <target state="translated">とき &lt;code&gt;isActive&lt;/code&gt; truthyで、レンダリングされたHTMLは次のようになります。</target>
        </trans-unit>
        <trans-unit id="ac61ff2088162189efe616f91e65e3365c7ef127" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;isActive&lt;/code&gt; or &lt;code&gt;hasError&lt;/code&gt; changes, the class list will be updated accordingly. For example, if &lt;code&gt;hasError&lt;/code&gt; becomes &lt;code&gt;true&lt;/code&gt;, the class list will become &lt;code&gt;&quot;static active text-danger&quot;&lt;/code&gt;.</source>
          <target state="translated">とき &lt;code&gt;isActive&lt;/code&gt; または &lt;code&gt;hasError&lt;/code&gt; 変更、クラスリストが更新されます。たとえば、 &lt;code&gt;hasError&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; になると、クラスリストは &lt;code&gt;&quot;static active text-danger&quot;&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="934dc1b26aeb98269916de2b7fd28293e3c6d44a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ref&lt;/code&gt; is used together with &lt;code&gt;v-for&lt;/code&gt;, the ref you get will be an array containing the child components mirroring the data source.</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; が &lt;code&gt;v-for&lt;/code&gt; と一緒に使用される場合、取得するrefは、データソースをミラーリングする子コンポーネントを含む配列になります。</target>
        </trans-unit>
        <trans-unit id="68799a9bc72bc5436c612e032f0302797e50e850" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;setup&lt;/code&gt; is executed, the component instance has not been created yet. As a result, you will only be able to access the following properties:</source>
          <target state="translated">&lt;code&gt;setup&lt;/code&gt; が実行されたとき、コンポーネントインスタンスはまだ作成されていません。その結果、次のプロパティにのみアクセスできます。</target>
        </trans-unit>
        <trans-unit id="47602c789504fad3106f84efc16c598040016f06" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;text&lt;/code&gt; changes, the &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; will always be replaced instead of patched, so a transition will be triggered.</source>
          <target state="translated">場合は &lt;code&gt;text&lt;/code&gt; の変更、 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 常に置き換えるの代わりに、パッチを適用されますが、遷移がトリガされますので。</target>
        </trans-unit>
        <trans-unit id="e9a272c5ffb0265f805ce14ec56031bc1589886c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; are both used on the same element, &lt;code&gt;v-if&lt;/code&gt; will be evaluated first. See the &lt;a href=&quot;list#v-for-with-v-if&quot;&gt;list rendering guide&lt;/a&gt; for details.</source>
          <target state="translated">場合 &lt;code&gt;v-if&lt;/code&gt; と &lt;code&gt;v-for&lt;/code&gt; 、両方の同一の要素に使用される、 &lt;code&gt;v-if&lt;/code&gt; 最初に評価されるであろう。詳細については、&lt;a href=&quot;list#v-for-with-v-if&quot;&gt;リストレンダリングガイド&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="bcc1cc0e7f7cb99eda1ea39c8e59b8e52d17b215" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;watchEffect&lt;/code&gt; is called during a component's &lt;a href=&quot;composition-api-setup&quot;&gt;setup()&lt;/a&gt; function or &lt;a href=&quot;composition-api-lifecycle-hooks&quot;&gt;lifecycle hooks&lt;/a&gt;, the watcher is linked to the component's lifecycle and will be automatically stopped when the component is unmounted.</source>
          <target state="translated">場合 &lt;code&gt;watchEffect&lt;/code&gt; は、コンポーネントの中に呼び出される&lt;a href=&quot;composition-api-setup&quot;&gt;セットアップ（）&lt;/a&gt;関数または&lt;a href=&quot;composition-api-lifecycle-hooks&quot;&gt;ライフサイクルフック&lt;/a&gt;、ウォッチャは、コンポーネントのライフサイクルにリンクされ、コンポーネントがアンマウントされたときに自動的に停止されます。</target>
        </trans-unit>
        <trans-unit id="ce6c45281f0e9295693c785e9c077ccf9de2ef90" translate="yes" xml:space="preserve">
          <source>When Vue 2.0 was released, the &lt;code&gt;v-model&lt;/code&gt; directive required developers to always use the &lt;code&gt;value&lt;/code&gt; prop. And if developers required different props for different purposes, they would have to resort to using &lt;code&gt;v-bind.sync&lt;/code&gt;. In addition, this hard-coded relationship between &lt;code&gt;v-model&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; led to issues with how native elements and custom elements were handled.</source>
          <target state="translated">Vue 2.0がリリースされたとき、 &lt;code&gt;v-model&lt;/code&gt; ディレクティブでは、開発者は常に &lt;code&gt;value&lt;/code&gt; プロップを使用する必要がありました。また、開発者がさまざまな目的でさまざまな小道具を必要とする場合は、 &lt;code&gt;v-bind.sync&lt;/code&gt; を使用する必要があります。さらに、 &lt;code&gt;v-model&lt;/code&gt; と &lt;code&gt;value&lt;/code&gt; の間のこのハードコードされた関係により、ネイティブ要素とカスタム要素の処理方法に問題が発生しました。</target>
        </trans-unit>
        <trans-unit id="0c133285af76b6277f0041e5a1b902c2f3bc7a50" translate="yes" xml:space="preserve">
          <source>When Vue is updating a list of elements rendered with &lt;code&gt;v-for&lt;/code&gt;, by default it uses an &quot;in-place patch&quot; strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the items, Vue will patch each element in-place and make sure it reflects what should be rendered at that particular index.</source>
          <target state="translated">Vueが &lt;code&gt;v-for&lt;/code&gt; でレンダリングされた要素のリストを更新しているとき、デフォルトでは「インプレースパッチ」戦略を使用します。データアイテムの順序が変更された場合、アイテムの順序に一致するようにDOM要素を移動する代わりに、Vueは各要素にパッチを適用し、その特定のインデックスでレンダリングする必要があるものを反映するようにします。</target>
        </trans-unit>
        <trans-unit id="72a14f3e4c0ab76a85e402fcdb8f819a5ba90c68" translate="yes" xml:space="preserve">
          <source>When Vue is updating a list of elements rendered with &lt;code&gt;v-for&lt;/code&gt;, by default it uses an &amp;ldquo;in-place patch&amp;rdquo; strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the items, Vue will patch each element in-place and make sure it reflects what should be rendered at that particular index. This is similar to the behavior of &lt;code&gt;track-by=&quot;$index&quot;&lt;/code&gt; in Vue 1.x.</source>
          <target state="translated">Vueが &lt;code&gt;v-for&lt;/code&gt; でレンダリングされた要素のリストを更新するとき、デフォルトでは「インプレースパッチ」戦略を使用します。データ項目の順序が変更された場合、DOM要素を項目の順序と一致するように移動するのではなく、Vueは各要素にインプレースパッチを適用し、特定のインデックスでレンダリングされる内容を反映することを確認します。これは、Vue 1.x の &lt;code&gt;track-by=&quot;$index&quot;&lt;/code&gt; の動作に似ています。</target>
        </trans-unit>
        <trans-unit id="2c0ed8c392c7855b9cfcb0f1d593848f3d1d64ec" translate="yes" xml:space="preserve">
          <source>When Vue processes directives, &lt;code&gt;v-for&lt;/code&gt; has a higher priority than &lt;code&gt;v-if&lt;/code&gt;, so that this template:</source>
          <target state="translated">Vueがディレクティブを処理するとき、 &lt;code&gt;v-for&lt;/code&gt; は &lt;code&gt;v-if&lt;/code&gt; よりも優先度が高いため、このテンプレートは次のようになります。</target>
        </trans-unit>
        <trans-unit id="b259e9996f2602892d2efd59722e6bdb4ae4ddf9" translate="yes" xml:space="preserve">
          <source>When Vue processes directives, &lt;code&gt;v-if&lt;/code&gt; has a higher priority than &lt;code&gt;v-for&lt;/code&gt;, so that this template:</source>
          <target state="translated">Vueがディレクティブを処理する場合、 &lt;code&gt;v-if&lt;/code&gt; は &lt;code&gt;v-for&lt;/code&gt; よりも優先度が高いため、このテンプレートは次のようになります。</target>
        </trans-unit>
        <trans-unit id="4ee4a8778693915a3019bc1ea6f3a54f6005a00f" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;ref&lt;/code&gt; is accessed or mutated as a property of a reactive object, it automatically unwraps to the inner value so it behaves like a normal property:</source>
          <target state="translated">場合 &lt;code&gt;ref&lt;/code&gt; は反応オブジェクトのプロパティとしてアクセスまたは変異され、それは通常のプロパティのように振る舞うので、それは自動的に内部値にアンラップ。</target>
        </trans-unit>
        <trans-unit id="22299c2d8ba7d7e0ca3851b5863bdfc318d6f049" translate="yes" xml:space="preserve">
          <source>When a ViewModel is destroyed, all event listeners are automatically removed. You don&amp;rsquo;t need to worry about cleaning it up yourself.</source>
          <target state="translated">ViewModelが破棄されると、すべてのイベントリスナーが自動的に削除されます。自分で掃除する必要はありません。</target>
        </trans-unit>
        <trans-unit id="ea83eee9db8590cd8fc96e20bb41e31cb11921cd" translate="yes" xml:space="preserve">
          <source>When a ViewModel is destroyed, all event listeners are automatically removed. You don't need to worry about cleaning it up yourself.</source>
          <target state="translated">ViewModel が破棄されると、すべてのイベントリスナーが自動的に削除されます。自分で片付けることを心配する必要はありません。</target>
        </trans-unit>
        <trans-unit id="b61abf89b8df56e434a82bb51460860f497d2afd" translate="yes" xml:space="preserve">
          <source>When a Vue instance is created, it adds all the properties found in its &lt;code&gt;data&lt;/code&gt; object to Vue&amp;rsquo;s &lt;strong&gt;reactivity system&lt;/strong&gt;. When the values of those properties change, the view will &amp;ldquo;react&amp;rdquo;, updating to match the new values.</source>
          <target state="translated">Vueインスタンスが作成されると、 &lt;code&gt;data&lt;/code&gt; オブジェクトにあるすべてのプロパティがVueの&lt;strong&gt;反応システム&lt;/strong&gt;に追加され&lt;strong&gt;ます&lt;/strong&gt;。これらのプロパティの値が変更されると、ビューは「反応」し、新しい値と一致するように更新されます。</target>
        </trans-unit>
        <trans-unit id="e10ac371624472fea62e8a9b8d7a32ccc5fd883e" translate="yes" xml:space="preserve">
          <source>When a browser reads this code, it builds a &lt;a href=&quot;https://javascript.info/dom-nodes&quot;&gt;tree of &quot;DOM nodes&quot; (opens new window)&lt;/a&gt; to help it keep track of everything.</source>
          <target state="translated">ブラウザがこのコードを読み取ると&lt;a href=&quot;https://javascript.info/dom-nodes&quot;&gt;、「DOMノード」のツリーが&lt;/a&gt;構築され（新しいウィンドウが開きます）、すべてを追跡できるようになります。</target>
        </trans-unit>
        <trans-unit id="7d9c5b81a5681d40b1461fa8b123f7a49c06375e" translate="yes" xml:space="preserve">
          <source>When a browser reads this code, it builds a &lt;a href=&quot;https://javascript.info/dom-nodes&quot;&gt;tree of &amp;ldquo;DOM nodes&amp;rdquo;&lt;/a&gt; to help it keep track of everything, just as you might build a family tree to keep track of your extended family.</source>
          <target state="translated">ブラウザがこのコードを読み取ると&lt;a href=&quot;https://javascript.info/dom-nodes&quot;&gt;、「DOMノード」の&lt;/a&gt;ツリーが作成され、家系図を作成して拡張ファミリを追跡するのと同じように、すべてを追跡できるようになります。</target>
        </trans-unit>
        <trans-unit id="29317cfc514db816870cce186295052bddc2f50e" translate="yes" xml:space="preserve">
          <source>When a component is toggled inside &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt;, its &lt;code&gt;activated&lt;/code&gt; and &lt;code&gt;deactivated&lt;/code&gt; lifecycle hooks will be invoked accordingly.</source>
          <target state="translated">&lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 内でコンポーネントが切り替えられると、それに応じて、 &lt;code&gt;deactivated&lt;/code&gt; &lt;code&gt;activated&lt;/code&gt; および非アクティブ化されたライフサイクルフックが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="421b8a98b1760ead672f1b77216c67fcc30374a6" translate="yes" xml:space="preserve">
          <source>When a component returns a single root node, non-prop attributes will automatically be added to the root node's attributes. For example, in the instance of a date-picker component:</source>
          <target state="translated">コンポーネントが単一のルート・ノードを返す場合、非プロップ属性はルート・ノードの属性に自動的に追加されます。例えば、データピッカーコンポーネントのインスタンスでは</target>
        </trans-unit>
        <trans-unit id="a4093e40e3a7a628dc648fbb3e9f015f5439f571" translate="yes" xml:space="preserve">
          <source>When a mixin and the component itself contain overlapping options, they will be &quot;merged&quot; using appropriate strategies.</source>
          <target state="translated">ミキシングとコンポーネント自体に重複するオプションが含まれている場合、それらは適切なストラテジーを使用して「マージ」されます。</target>
        </trans-unit>
        <trans-unit id="02bd02b68298dd5a1f896d4edc79b24aabb58235" translate="yes" xml:space="preserve">
          <source>When a mixin and the component itself contain overlapping options, they will be &amp;ldquo;merged&amp;rdquo; using appropriate strategies.</source>
          <target state="translated">ミックスインとコンポーネント自体に重複するオプションが含まれている場合、それらは適切な戦略を使用して「マージ」されます。</target>
        </trans-unit>
        <trans-unit id="15a4799ba709de314050c2aeb417d1c062407080" translate="yes" xml:space="preserve">
          <source>When a native event (e.g., &lt;code&gt;click&lt;/code&gt;) is defined in the &lt;code&gt;emits&lt;/code&gt; option, the component event will be used &lt;strong&gt;instead&lt;/strong&gt; of a native event listener.</source>
          <target state="translated">ネイティブイベント（ &lt;code&gt;click&lt;/code&gt; ）が &lt;code&gt;emits&lt;/code&gt; オプションで定義されている場合、ネイティブイベントリスナーの&lt;strong&gt;代わり&lt;/strong&gt;にコンポーネントイベントが使用されます。</target>
        </trans-unit>
        <trans-unit id="5f72c8ed98813c97629aa3dff3ba23fdf14af142" translate="yes" xml:space="preserve">
          <source>When a nested object is accessed from a reactive proxy, that object is &lt;em&gt;also&lt;/em&gt; converted into a proxy before being returned:</source>
          <target state="translated">ネストされたオブジェクトがリアクティブプロキシからアクセスされると、そのオブジェクト&lt;em&gt;も&lt;/em&gt;返される前にプロキシに変換されます。</target>
        </trans-unit>
        <trans-unit id="3db172a75e05ba77d82b2612c1d789b4232b4b0f" translate="yes" xml:space="preserve">
          <source>When a parent listens for the &lt;code&gt;click&lt;/code&gt; event on the component:</source>
          <target state="translated">親がコンポーネントの &lt;code&gt;click&lt;/code&gt; イベントをリッスンする場合：</target>
        </trans-unit>
        <trans-unit id="0801ddea4aa0f45998c371d842fd8cd4d1bfcbd5" translate="yes" xml:space="preserve">
          <source>When a ref is returned as a property on the render context (the object returned from &lt;a href=&quot;composition-api-setup&quot;&gt;setup()&lt;/a&gt;) and accessed in the template, it automatically unwraps to the inner value. There is no need to append &lt;code&gt;.value&lt;/code&gt; in the template:</source>
          <target state="translated">refがレンダーコンテキスト（&lt;a href=&quot;composition-api-setup&quot;&gt;setup（）&lt;/a&gt;から返されるオブジェクト）のプロパティとして返され、テンプレートでアクセスされると、自動的に内部値にアンラップされます。テンプレートに &lt;code&gt;.value&lt;/code&gt; を追加する必要はありません。</target>
        </trans-unit>
        <trans-unit id="00843c9d85b596ab87a52656147b09febbd8f473" translate="yes" xml:space="preserve">
          <source>When a value is passed to a prop attribute, it becomes a property on that component instance. The value of that property is accessible within the template, just like any other component property.</source>
          <target state="translated">値がprop属性に渡されると、それはそのコンポーネント・インスタンスのプロパティになります。そのプロパティの値は、他のコンポーネント・プロパティと同様に、テンプレート内でアクセス可能です。</target>
        </trans-unit>
        <trans-unit id="c053395d17d13ce80a0364c9ff5e250131f80f75" translate="yes" xml:space="preserve">
          <source>When adding instructions for your input fields, make sure to link it correctly to the input. You can provide additional instructions and bind multiple ids inside an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-labelledby_attribute&quot;&gt;&lt;code&gt;aria-labelledby&lt;/code&gt; (opens new window)&lt;/a&gt;. This allows for more flexible design.</source>
          <target state="translated">入力フィールドに命令を追加するときは、入力に正しくリンクしていることを確認してください。追加の指示を提供し、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-labelledby_attribute&quot;&gt; &lt;code&gt;aria-labelledby&lt;/code&gt; &lt;/a&gt;内で複数のIDをバインドできます（新しいウィンドウを開きます）。これにより、より柔軟な設計が可能になります。</target>
        </trans-unit>
        <trans-unit id="441171155cec8cb7b4886d622933622cf7cc0aa7" translate="yes" xml:space="preserve">
          <source>When an element wrapped in a &lt;code&gt;transition&lt;/code&gt; component is inserted or removed, this is what happens:</source>
          <target state="translated">&lt;code&gt;transition&lt;/code&gt; コンポーネントにラップされた要素が挿入または削除されると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="a6231838dcc377e59b6f7a45b72b3be9da61805a" translate="yes" xml:space="preserve">
          <source>When assigning a &lt;a href=&quot;refs-api#ref&quot;&gt;ref&lt;/a&gt; to a &lt;code&gt;reactive&lt;/code&gt; property, that ref will be automatically unwrapped.</source>
          <target state="translated">&lt;a href=&quot;refs-api#ref&quot;&gt;参照&lt;/a&gt;を &lt;code&gt;reactive&lt;/code&gt; プロパティに割り当てると、その参照は自動的にアンラップされます。</target>
        </trans-unit>
        <trans-unit id="8bedf600c3ab131cb247e5836babdb736c7f1c0b" translate="yes" xml:space="preserve">
          <source>When building out a &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; component, your template will eventually contain more than just the title:</source>
          <target state="translated">&lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; コンポーネントを構築する場合、テンプレートには最終的にタイトルだけではありません。</target>
        </trans-unit>
        <trans-unit id="38bfebbfa9c7071d667afc65ea17c45a78ca6bbc" translate="yes" xml:space="preserve">
          <source>When components begin to feel cramped or difficult to read, adding spaces between multi-line properties can make them easier to skim again. In some editors, such as Vim, formatting options like this can also make them easier to navigate with the keyboard.</source>
          <target state="translated">コンポーネントが窮屈に感じたり、読みにくいと感じ始めたら、複数行のプロパティの間にスペースを追加すると、再度読みやすくなります。Vim などのエディタでは、このような書式設定オプションを使用すると、キーボードでの操作が容易になります。</target>
        </trans-unit>
        <trans-unit id="309c2a92544230a15a51f890171560d2c2b0da32" translate="yes" xml:space="preserve">
          <source>When creating a form, you can use the following elements: &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt;</source>
          <target state="translated">フォームを作成するときは、次の要素を使用できます： &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 、および &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="574ddee43c6d5c376daa9d7c67db78f6a16adac7" translate="yes" xml:space="preserve">
          <source>When custom options are merged, they use the default strategy which overwrites the existing value. If you want a custom option to be merged using custom logic, you need to attach a function to &lt;code&gt;Vue.config.optionMergeStrategies&lt;/code&gt;:</source>
          <target state="translated">カスタムオプションがマージされると、既存の値を上書きするデフォルトの戦略が使用されます。カスタムロジックを使用してカスタムオプションをマージする場合は、 &lt;code&gt;Vue.config.optionMergeStrategies&lt;/code&gt; に関数をアタッチする必要があります。</target>
        </trans-unit>
        <trans-unit id="a48b042d07d089f8ac425b2bfbb816b814258e35" translate="yes" xml:space="preserve">
          <source>When custom options are merged, they use the default strategy which overwrites the existing value. If you want a custom option to be merged using custom logic, you need to attach a function to &lt;code&gt;app.config.optionMergeStrategies&lt;/code&gt;:</source>
          <target state="translated">カスタムオプションがマージされると、既存の値を上書きするデフォルトの戦略が使用されます。カスタムロジックを使用してカスタムオプションをマージする場合は、 &lt;code&gt;app.config.optionMergeStrategies&lt;/code&gt; に関数をアタッチする必要があります。</target>
        </trans-unit>
        <trans-unit id="0246a7b06b284f630c270a3b6fd7d4bf46f87f10" translate="yes" xml:space="preserve">
          <source>When defining a &lt;strong&gt;component&lt;/strong&gt;, &lt;code&gt;data&lt;/code&gt; must be declared as a function that returns the initial data object, because there will be many instances created using the same definition. If we use a plain object for &lt;code&gt;data&lt;/code&gt;, that same object will be &lt;strong&gt;shared by reference&lt;/strong&gt; across all instances created! By providing a &lt;code&gt;data&lt;/code&gt; function, every time a new instance is created we can call it to return a fresh copy of the initial data.</source>
          <target state="translated">定義するときに&lt;strong&gt;コンポーネントを&lt;/strong&gt;、 &lt;code&gt;data&lt;/code&gt; 多くのインスタンスが存在しますので、同じ定義を使用して作成し、初期データオブジェクトを返す関数として宣言しなければなりません。 &lt;code&gt;data&lt;/code&gt; にプレーンオブジェクトを使用すると、作成されたすべてのインスタンス間で同じオブジェクトが&lt;strong&gt;参照によって共有され&lt;/strong&gt;ます。 &lt;code&gt;data&lt;/code&gt; 関数を提供することにより、新しいインスタンスが作成されるたびに、それを呼び出して初期データの新しいコピーを返すことができます。</target>
        </trans-unit>
        <trans-unit id="f6959ec846f757993ef51859848d0ec694e4b4d8" translate="yes" xml:space="preserve">
          <source>When defining a component with PascalCase, you can use either case when referencing its custom element. That means both &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;MyComponentName&amp;gt;&lt;/code&gt; are acceptable. Note, however, that only kebab-case names are valid directly in the DOM (i.e. non-string templates).</source>
          <target state="translated">PascalCaseでコンポーネントを定義する場合、そのカスタム要素を参照するときにどちらのケースでも使用できます。つまり、 &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt; と &lt;code&gt;&amp;lt;MyComponentName&amp;gt;&lt;/code&gt; の両方を使用できます。ただし、DOMで直接有効なのはケバブケース名のみです（つまり、文字列以外のテンプレート）。</target>
        </trans-unit>
        <trans-unit id="11520acb769061d44c7641a4bea26df4e007c1c6" translate="yes" xml:space="preserve">
          <source>When defining a component with kebab-case, you must also use kebab-case when referencing its custom element, such as in &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">kebab-caseでコンポーネントを定義するときは、 &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt; などのカスタム要素を参照するときにkebab-caseも使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="8b21b5775a35c4109c91409425882806e5dcafab" translate="yes" xml:space="preserve">
          <source>When defining components in a string template or a single-file component, you have two options when defining component names:</source>
          <target state="translated">文字列テンプレートまたは単一ファイルのコンポーネントでコンポーネントを定義する場合、コンポーネント名を定義する際には2つのオプションがあります。</target>
        </trans-unit>
        <trans-unit id="066a19ef89f904a34f15aab25b5aa44f5d2acef0" translate="yes" xml:space="preserve">
          <source>When dynamically binding attributes on an element, a common scenario involves using both the &lt;code&gt;v-bind=&quot;object&quot;&lt;/code&gt; syntax as well as individual properties in the same element. However, this raises questions as far as the priority of merging.</source>
          <target state="translated">要素の属性を動的にバインドする場合、一般的なシナリオでは、 &lt;code&gt;v-bind=&quot;object&quot;&lt;/code&gt; 構文と同じ要素の個々のプロパティの両方を使用します。ただし、これにより、マージの優先順位に関して疑問が生じます。</target>
        </trans-unit>
        <trans-unit id="bd74ac6287481f52e2e49b0f37a17fd417c26d06" translate="yes" xml:space="preserve">
          <source>When each computed property contains only a very simple expression, with very few dependencies, it&amp;rsquo;s much easier to write tests confirming that it works correctly.</source>
          <target state="translated">計算された各プロパティに非常に単純な式のみが含まれ、依存関係がほとんどない場合は、正しく機能することを確認するテストを作成する方がはるかに簡単です。</target>
        </trans-unit>
        <trans-unit id="7941adba64b48e32e845c4386f579d258e69a4db" translate="yes" xml:space="preserve">
          <source>When each computed property contains only a very simple expression, with very few dependencies, it's much easier to write tests confirming that it works correctly.</source>
          <target state="translated">各計算されたプロパティが非常に単純な式だけを含み、依存関係が非常に少ない場合、それが正しく動作することを確認するテストを書くのがはるかに簡単になります。</target>
        </trans-unit>
        <trans-unit id="df23522a9402466e18df90100856fe06a436e73c" translate="yes" xml:space="preserve">
          <source>When end-to-end (E2E) tests are run in continuous integration / deployment pipelines, they are often run in headless browsers (i.e., no visible browser is opened for the user to watch). As a result, when errors occur, a critical feature that modern E2E testing frameworks provide 1st class support for is the ability to see snapshots and/or videos of your applications during various testing stages in order to provide insight into why errors are happening. Historically, it was tedious to maintain these integrations.</source>
          <target state="translated">エンドツーエンド(E2E)テストが継続的インテグレーション/デプロイメントパイプラインで実行される場合、多くの場合、ヘッドレスブラウザで実行されます(つまり、ユーザが見るために目に見えるブラウザが開かれていない)。その結果、エラーが発生した場合、最新の E2E テストフレームワークが第一級のサポートを提供している重要な機能は、エラーが発生している理由の洞察を提供するために、様々なテスト段階でアプリケーションのスナップショットやビデオを見る機能です。歴史的に、これらの統合を維持するのは面倒でした。</target>
        </trans-unit>
        <trans-unit id="2b75011d4b1187e131605bb1c9cb8eb76b5decdc" translate="yes" xml:space="preserve">
          <source>When including a property name/key, the argument order for objects used to be &lt;code&gt;(name, value)&lt;/code&gt;. It is now &lt;code&gt;(value, name)&lt;/code&gt; to be more consistent with common object iterators such as lodash&amp;rsquo;s.</source>
          <target state="translated">プロパティ名/キーを含める場合、オブジェクトの引数の順序は &lt;code&gt;(name, value)&lt;/code&gt; でした。今である &lt;code&gt;(value, name)&lt;/code&gt; などlodashのような共通のオブジェクトのイテレータとより一致します。</target>
        </trans-unit>
        <trans-unit id="1bb50b705881ceba60e0753e4ec83e3bcc90e582" translate="yes" xml:space="preserve">
          <source>When including an &lt;code&gt;index&lt;/code&gt;, the argument order for arrays used to be &lt;code&gt;(index, value)&lt;/code&gt;. It is now &lt;code&gt;(value, index)&lt;/code&gt; to be more consistent with JavaScript&amp;rsquo;s native array methods such as &lt;code&gt;forEach&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; を含める場合、配列の引数の順序は &lt;code&gt;(index, value)&lt;/code&gt; でした。これで、 &lt;code&gt;(value, index)&lt;/code&gt; が、JavaScriptの &lt;code&gt;forEach&lt;/code&gt; や &lt;code&gt;map&lt;/code&gt; などのネイティブ配列メソッドとより整合性を持つようになりました。</target>
        </trans-unit>
        <trans-unit id="c307aa08a2101632c0ad4b3a6317b17bab92e104" translate="yes" xml:space="preserve">
          <source>When it comes to building reliable applications, tests can play a critical role in an individual or team's ability to build new features, refactor code, fix bugs, etc. While there are many schools of thought with testing, there are three categories often discussed in the context of web applications:</source>
          <target state="translated">信頼性の高いアプリケーションを構築することに関しては、テストは個人やチームが新機能を構築したり、コードをリファクタリングしたり、バグを修正したりする能力において重要な役割を果たすことができます。テストには多くの流派がありますが、ウェブアプリケーションの文脈でよく議論されるのは3つのカテゴリーです。</target>
        </trans-unit>
        <trans-unit id="57b12026aaf6eb65059456dcbe2dfd1de583b0fb" translate="yes" xml:space="preserve">
          <source>When iterating over an object, the order is based on the enumeration order of &lt;code&gt;Object.keys()&lt;/code&gt;, which is &lt;strong&gt;not&lt;/strong&gt; guaranteed to be consistent across JavaScript engine implementations.</source>
          <target state="translated">オブジェクトを反復する場合、順序は &lt;code&gt;Object.keys()&lt;/code&gt; の列挙順序に基づいています。これは、JavaScriptエンジンの実装全体で一貫しているとは&lt;strong&gt;限りませ&lt;/strong&gt;ん。</target>
        </trans-unit>
        <trans-unit id="fab3293fcdc1fc50ed0d6ad7581641eed28e2498" translate="yes" xml:space="preserve">
          <source>When iterating over an object, the order is based on the enumeration order of &lt;code&gt;Object.keys()&lt;/code&gt;, which isn't guaranteed to be consistent across JavaScript engine implementations.</source>
          <target state="translated">オブジェクトを反復処理する場合、順序は &lt;code&gt;Object.keys()&lt;/code&gt; の列挙順序に基づいており、JavaScriptエンジンの実装全体で一貫しているとは限りません。</target>
        </trans-unit>
        <trans-unit id="230ed0a7a0be6695cb0d232f9093b7cd6c4fcf5a" translate="yes" xml:space="preserve">
          <source>When listening for keyboard events, we often need to check for specific keys. Vue allows adding key modifiers for &lt;code&gt;v-on&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; when listening for key events:</source>
          <target state="translated">キーボードイベントをリッスンするとき、特定のキーをチェックする必要があることがよくあります。Vueでは、キーイベントをリッスンするときに &lt;code&gt;v-on&lt;/code&gt; または &lt;code&gt;@&lt;/code&gt; のキー修飾子を追加できます。</target>
        </trans-unit>
        <trans-unit id="e251d7dfd8699c3af6db56d89c3c03d6f9790c85" translate="yes" xml:space="preserve">
          <source>When listening for keyboard events, we often need to check for specific keys. Vue allows adding key modifiers for &lt;code&gt;v-on&lt;/code&gt; when listening for key events:</source>
          <target state="translated">キーボードイベントをリッスンするとき、特定のキーを確認する必要があることがよくあります。Vueでは、キーイベントをリッスンするときに &lt;code&gt;v-on&lt;/code&gt; のキー修飾子を追加できます。</target>
        </trans-unit>
        <trans-unit id="3e11ceb78177526f054cb2e65a44b13cd1b4c54e" translate="yes" xml:space="preserve">
          <source>When listening to native DOM events, the method receives the native event as the only argument. If using inline statement, the statement has access to the special &lt;code&gt;$event&lt;/code&gt; property: &lt;code&gt;v-on:click=&quot;handle('ok', $event)&quot;&lt;/code&gt;.</source>
          <target state="translated">ネイティブDOMイベントをリスニングするとき、メソッドはネイティブイベントを唯一の引数として受け取ります。インラインステートメントを使用する場合、ステートメントは特別な &lt;code&gt;$event&lt;/code&gt; プロパティにアクセスできます： &lt;code&gt;v-on:click=&quot;handle('ok', $event)&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e2a136029d41ad6a228327504bda8738ba0fa6e" translate="yes" xml:space="preserve">
          <source>When organized alphabetically in editors, your app&amp;rsquo;s base components are all listed together, making them easier to identify.</source>
          <target state="translated">エディターでアルファベット順に整理すると、アプリの基本コンポーネントがすべて一緒にリストされ、簡単に識別できます。</target>
        </trans-unit>
        <trans-unit id="74937f5b6caa6e834c6f6b061e657dfd695c54c2" translate="yes" xml:space="preserve">
          <source>When organized alphabetically in editors, your app's base components are all listed together, making them easier to identify.</source>
          <target state="translated">エディタでアルファベット順に整理すると、アプリの基本コンポーネントがすべて一緒にリストアップされ、識別が容易になります。</target>
        </trans-unit>
        <trans-unit id="def79d873f4e1bf1cac75faa9a431656147056c0" translate="yes" xml:space="preserve">
          <source>When passing arrays to query parameters the QueryString syntax is no longer &lt;code&gt;/foo?users[]=Tom&amp;amp;users[]=Jerry&lt;/code&gt;, instead, the new syntax is &lt;code&gt;/foo?users=Tom&amp;amp;users=Jerry&lt;/code&gt;. Internally, &lt;code&gt;$route.query.users&lt;/code&gt; will still be an Array, but if there&amp;rsquo;s only one parameter in the query: &lt;code&gt;/foo?users=Tom&lt;/code&gt;, when directly accessing this route, there&amp;rsquo;s no way for the router to know if we were expecting &lt;code&gt;users&lt;/code&gt; to be an Array. Because of this, consider adding a computed property and replacing every reference of &lt;code&gt;$route.query.users&lt;/code&gt; with it:</source>
          <target state="translated">クエリパラメータに配列を渡すと、QueryString構文は &lt;code&gt;/foo?users[]=Tom&amp;amp;users[]=Jerry&lt;/code&gt; ではなくなり、代わりに新しい構文は &lt;code&gt;/foo?users=Tom&amp;amp;users=Jerry&lt;/code&gt; になります。内部的には &lt;code&gt;$route.query.users&lt;/code&gt; は配列のままですが、クエリにパラメーターが1つしかない場合： &lt;code&gt;/foo?users=Tom&lt;/code&gt; 、このルートに直接アクセスするときに、 &lt;code&gt;users&lt;/code&gt; が予期していたものであったかどうかをルーターが知る方法はありません。配列になる。このため、計算されたプロパティを追加し、 &lt;code&gt;$route.query.users&lt;/code&gt; すべての参照をそれで置き換えることを検討してください。</target>
        </trans-unit>
        <trans-unit id="c92c1efef67ab553f75dcd81d8995c7af3a57f63" translate="yes" xml:space="preserve">
          <source>When prop validation fails, Vue will produce a console warning (if using the development build).</source>
          <target state="translated">プロップの検証に失敗した場合、Vue はコンソール警告を表示します (開発ビルドを使用している場合)。</target>
        </trans-unit>
        <trans-unit id="101b9b9b96420f85fbf4b82db83c1e9b1572015e" translate="yes" xml:space="preserve">
          <source>When registering a component, it will always be given a name. For example, in the global registration we&amp;rsquo;ve seen so far:</source>
          <target state="translated">コンポーネントを登録するときは、常に名前が付けられます。たとえば、これまでに見てきたグローバル登録では：</target>
        </trans-unit>
        <trans-unit id="23d3b8893cae1a97943ce59e8f17a3cc54c4a8d8" translate="yes" xml:space="preserve">
          <source>When registering a component, it will always be given a name. For example, in the global registration we've seen so far:</source>
          <target state="translated">コンポーネントを登録する際には、必ず名前が付けられます。例えば、今まで見てきたグローバル登録では</target>
        </trans-unit>
        <trans-unit id="a9e5c326f59d187f049e28a2666c0724bc0c2933" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, will preserve and render HTML comments found in templates. The default behavior is discarding them.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; に設定すると、テンプレートで見つかったHTMLコメントが保持およびレンダリングされます。デフォルトの動作では、それらを破棄します。</target>
        </trans-unit>
        <trans-unit id="abe00b8936cd06e1fda1ba07cdc78de54ed7719e" translate="yes" xml:space="preserve">
          <source>When switching between these components though, you&amp;rsquo;ll sometimes want to maintain their state or avoid re-rendering for performance reasons. For example, when expanding our tabbed interface a little:</source>
          <target state="translated">ただし、これらのコンポーネントを切り替えるときは、コンポーネントの状態を維持したり、パフォーマンス上の理由から再レンダリングを回避したりすることが必要になる場合があります。たとえば、タブ付きインターフェイスを少し拡張すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="651beb4b3e6f062a8bc7db612ca2ba6b3d198430" translate="yes" xml:space="preserve">
          <source>When switching between these components though, you'll sometimes want to maintain their state or avoid re-rendering for performance reasons. For example, when expanding our tabbed interface a little:</source>
          <target state="translated">しかし、これらのコンポーネントを切り替えるときには、その状態を維持したり、パフォーマンス上の理由から再レンダリングを避けたりしたくなることもあるでしょう。たとえば、タブ付きインターフェイスを少し拡大したときなどです。</target>
        </trans-unit>
        <trans-unit id="1d1d915145995bbbbc905958405c390550f8e65e" translate="yes" xml:space="preserve">
          <source>When tests fail, it is critical that your component testing framework provides useful error logs that help to minimize the amount of time it takes to debug the problem. In addition to simply telling you what test fails, they should also provides context for why a test fails, e.g., what is expected vs what was received.</source>
          <target state="translated">テストが失敗した場合、コンポーネントテストのフレームワークが、問題のデバッグにかかる時間を最小限に抑えるのに役立つ有用なエラーログを提供することが重要です。どのテストが失敗したかを単に伝えるだけでなく、なぜテストが失敗したのか、例えば、何が期待されているのか、何を受け取ったのかなどのコンテキストを提供しなければなりません。</target>
        </trans-unit>
        <trans-unit id="746d16bd5abc3a9c7e4d55d39555ad4b65929566" translate="yes" xml:space="preserve">
          <source>When tests fail, it is critical that your unit testing framework provides useful errors. This is the job of the assertion library. An assertion with high-quality error messages helps minimize the amount of time it takes to debug the problem. In addition to simply telling you what test is failing, assertion libraries provide context for why a test fails, e.g., what is expected vs what was received.</source>
          <target state="translated">テストが失敗した場合、ユニットテストフレームワークが有用なエラーを提供することが重要です。これがアサーションライブラリの仕事です。高品質のエラーメッセージを持つアサーションは、問題のデバッグにかかる時間を最小限に抑えるのに役立ちます。どのテストが失敗しているかを伝えるだけでなく、アサーション・ライブラリは、テストが失敗した理由、例えば、何が期待されているのか、何を受け取ったのかなどのコンテキストを提供します。</target>
        </trans-unit>
        <trans-unit id="22af2530a0066e4bf48a905ba4a853b99426fc58" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;inline-template&lt;/code&gt; special attribute is present on a child component, the component will use its inner content as its template, rather than treating it as distributed content. This allows more flexible template-authoring.</source>
          <target state="translated">とき &lt;code&gt;inline-template&lt;/code&gt; の特殊な属性は、子コンポーネントに存在している、コンポーネントではなく、配信されたコンテンツとして、それを処理するよりも、そのテンプレートとその内側のコンテンツを使用します。これにより、より柔軟なテンプレート作成が可能になります。</target>
        </trans-unit>
        <trans-unit id="5c0db747b0eba54fa03d888a984d7c54baac77f8" translate="yes" xml:space="preserve">
          <source>When the component renders, &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; will be replaced by &quot;Add Todo&quot;.</source>
          <target state="translated">コンポーネントがレンダリングされると、 &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; は「AddTodo」に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="bcd74cb4ecd8a9224eda5489dff9a3ea0ae979ac" translate="yes" xml:space="preserve">
          <source>When the component renders, &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; will be replaced by &amp;ldquo;Your Profile&amp;rdquo;. Slots can contain any template code, including HTML:</source>
          <target state="translated">コンポーネントがレンダリングされると、 &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; は「Your Profile」に置き換えられます。スロットには、HTMLを含む任意のテンプレートコードを含めることができます。</target>
        </trans-unit>
        <trans-unit id="61a1dbac0913fba4e7eca7a103592962ab67125c" translate="yes" xml:space="preserve">
          <source>When the global filter has the same name as the local filter, the local filter will be preferred.</source>
          <target state="translated">グローバルフィルタがローカルフィルタと同じ名前を持つ場合、ローカルフィルタが優先されます。</target>
        </trans-unit>
        <trans-unit id="124da0bbab39c06d12e465b5be78ea53d3fc66ab" translate="yes" xml:space="preserve">
          <source>When the page loads, that element gains focus (note: &lt;code&gt;autofocus&lt;/code&gt; doesn&amp;rsquo;t work on mobile Safari). In fact, if you haven&amp;rsquo;t clicked on anything else since visiting this page, the input above should be focused now. Now let&amp;rsquo;s build the directive that accomplishes this:</source>
          <target state="translated">ページが読み込まれると、その要素に &lt;code&gt;autofocus&lt;/code&gt; が移ります（注：モバイルSafariではオートフォーカスは機能しません）。実際、このページにアクセスしてから何もクリックしていない場合は、上記の入力に焦点を当てる必要があります。次に、これを実行するディレクティブを作成します。</target>
        </trans-unit>
        <trans-unit id="53fa055e2ff552cf0106e82aee9a9ceb3b099fb5" translate="yes" xml:space="preserve">
          <source>When the page loads, that element gains focus (note: &lt;code&gt;autofocus&lt;/code&gt; doesn't work on mobile Safari). In fact, if you haven't clicked on anything else since visiting this page, the input above should be focused now. Also, you can click on the &lt;code&gt;Rerun&lt;/code&gt; button and input will be focused.</source>
          <target state="translated">ページが読み込まれると、その要素に &lt;code&gt;autofocus&lt;/code&gt; が移ります（注：オートフォーカスはモバイルSafariでは機能しません）。実際、このページにアクセスしてから他に何もクリックしていない場合は、上記の入力に焦点を当てる必要があります。また、[ &lt;code&gt;Rerun&lt;/code&gt; ]ボタンをクリックすると、入力がフォーカスされます。</target>
        </trans-unit>
        <trans-unit id="03ace105eaf0ba1d9f4079a872792b4cfa534918" translate="yes" xml:space="preserve">
          <source>When the value of &lt;code&gt;data&lt;/code&gt; is an object, it&amp;rsquo;s shared across all instances of a component. Imagine, for example, a &lt;code&gt;TodoList&lt;/code&gt; component with this data:</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; の値がオブジェクトの場合、それはコンポーネントのすべてのインスタンスで共有されます。たとえば、次のデータを含む &lt;code&gt;TodoList&lt;/code&gt; コンポーネントを想像してください。</target>
        </trans-unit>
        <trans-unit id="c971f0813e2512d2a41d743091482019c0669839" translate="yes" xml:space="preserve">
          <source>When they exist on the same node, &lt;code&gt;v-for&lt;/code&gt; has a higher priority than &lt;code&gt;v-if&lt;/code&gt;. That means the &lt;code&gt;v-if&lt;/code&gt; will be run on each iteration of the loop separately. This can be useful when you want to render nodes for only &lt;em&gt;some&lt;/em&gt; items, like below:</source>
          <target state="translated">それらが同じノードに存在する場合、 &lt;code&gt;v-for&lt;/code&gt; は &lt;code&gt;v-if&lt;/code&gt; よりも優先されます。つまり、 &lt;code&gt;v-if&lt;/code&gt; はループの各反復で個別に実行されます。これは、以下のように、&lt;em&gt;一部の&lt;/em&gt;アイテムのみのノードをレンダリングする場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="4b3806336239800c5ec794a9d3907163b07e9915" translate="yes" xml:space="preserve">
          <source>When they exist on the same node, &lt;code&gt;v-if&lt;/code&gt; has a higher priority than &lt;code&gt;v-for&lt;/code&gt;. That means the &lt;code&gt;v-if&lt;/code&gt; condition will not have access to variables from the scope of the &lt;code&gt;v-for&lt;/code&gt;:</source>
          <target state="translated">それらが同じノードに存在する場合、 &lt;code&gt;v-if&lt;/code&gt; は &lt;code&gt;v-for&lt;/code&gt; よりも優先されます。つまり、 &lt;code&gt;v-if&lt;/code&gt; 条件は、 &lt;code&gt;v-for&lt;/code&gt; のスコープから変数にアクセスできません。</target>
        </trans-unit>
        <trans-unit id="c810013903d2f4032babdbbdae77af65f2830a27" translate="yes" xml:space="preserve">
          <source>When this data changes, the view will re-render. It should be noted that properties in &lt;code&gt;data&lt;/code&gt; are only &lt;strong&gt;reactive&lt;/strong&gt; if they existed when the instance was created. That means if you add a new property, like:</source>
          <target state="translated">このデータが変更されると、ビューは再レンダリングされます。 &lt;code&gt;data&lt;/code&gt; プロパティは、インスタンスの作成時に存在していた場合にのみ&lt;strong&gt;反応&lt;/strong&gt;することに注意してください。つまり、次のような新しいプロパティを追加した場合、</target>
        </trans-unit>
        <trans-unit id="8672efd0617cd888d9bb1e3c737957074d1bc51c" translate="yes" xml:space="preserve">
          <source>When this method is called on the same plugin multiple times, the plugin will be installed only once.</source>
          <target state="translated">同じプラグインに対してこのメソッドが複数回呼ばれた場合、プラグインは一度だけインストールされます。</target>
        </trans-unit>
        <trans-unit id="8c57990092bff4c63af046b16e646096a1592578" translate="yes" xml:space="preserve">
          <source>When toggling between elements that have &lt;strong&gt;the same tag name&lt;/strong&gt;, you must tell Vue that they are distinct elements by giving them unique &lt;code&gt;key&lt;/code&gt; attributes. Otherwise, Vue&amp;rsquo;s compiler will only replace the content of the element for efficiency. Even when technically unnecessary though, &lt;strong&gt;it&amp;rsquo;s considered good practice to always key multiple items within a &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; component.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;同じタグ名&lt;/strong&gt;を持つ要素間を切り替える場合、Vueに一意の &lt;code&gt;key&lt;/code&gt; 属性を与えることにより、それらが異なる要素であることを伝える必要があります。それ以外の場合、Vueのコンパイラーは、効率のために要素のコンテンツのみを置き換えます。ただし、技術的に不要な場合でも&lt;strong&gt;、 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; コンポーネント内で常に複数の項目にキーを設定することをお勧めします。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a4fd996911a0f54f846028a84e8762021497009a" translate="yes" xml:space="preserve">
          <source>When typing a &lt;code&gt;reactive&lt;/code&gt; property, we can use interfaces:</source>
          <target state="translated">&lt;code&gt;reactive&lt;/code&gt; プロパティを入力するときは、インターフェイスを使用できます。</target>
        </trans-unit>
        <trans-unit id="6bc2b25beebdd34dc380c9fd23b43f7c65cc4486" translate="yes" xml:space="preserve">
          <source>When used for prop binding, the prop must be properly declared in the child component.</source>
          <target state="translated">プロップバインディングに使用する場合は、子コンポーネントで適切に宣言されている必要があります。</target>
        </trans-unit>
        <trans-unit id="48c747cb7a6755cfb07e7973db15c1ed5c7e3ffd" translate="yes" xml:space="preserve">
          <source>When used on a component, &lt;code&gt;v-model&lt;/code&gt; instead does this:</source>
          <target state="translated">コンポーネントで使用すると、 &lt;code&gt;v-model&lt;/code&gt; は代わりにこれを行います。</target>
        </trans-unit>
        <trans-unit id="64fca958e73a8a2c2d35d431e6c2e83b1da085a6" translate="yes" xml:space="preserve">
          <source>When used on a component, &lt;code&gt;v-on&lt;/code&gt; now only listens to custom events &lt;code&gt;$emit&lt;/code&gt;ted by that component. To listen for a native DOM event on the root element, you can use the &lt;code&gt;.native&lt;/code&gt; modifier. For example:</source>
          <target state="translated">コンポーネントで使用する場合、 &lt;code&gt;v-on&lt;/code&gt; はそのコンポーネントによって &lt;code&gt;$emit&lt;/code&gt; れたカスタムイベントのみをリッスンするようになりました。ルート要素のネイティブDOMイベントをリッスンするには、 &lt;code&gt;.native&lt;/code&gt; 修飾子を使用できます。例えば：</target>
        </trans-unit>
        <trans-unit id="39c2818e21858b65998b9cb9c792d34b526f9165" translate="yes" xml:space="preserve">
          <source>When used on a normal element, it listens to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events&quot;&gt;&lt;strong&gt;native DOM events&lt;/strong&gt; (opens new window)&lt;/a&gt; only. When used on a custom element component, it listens to &lt;strong&gt;custom events&lt;/strong&gt; emitted on that child component.</source>
          <target state="translated">通常の要素で使用すると、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events&quot;&gt;&lt;strong&gt;ネイティブDOMイベント&lt;/strong&gt;&lt;/a&gt;のみをリッスンし&lt;strong&gt;ます&lt;/strong&gt;（新しいウィンドウを開きます）。カスタム要素コンポーネントで使用すると、その子コンポーネントで発行された&lt;strong&gt;カスタムイベントを&lt;/strong&gt;リッスンします。</target>
        </trans-unit>
        <trans-unit id="06e820aca19dc00b200ff77d1c2279ec5f556dff" translate="yes" xml:space="preserve">
          <source>When used on a normal element, it listens to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events&quot;&gt;&lt;strong&gt;native DOM events&lt;/strong&gt;&lt;/a&gt; only. When used on a custom element component, it listens to &lt;strong&gt;custom events&lt;/strong&gt; emitted on that child component.</source>
          <target state="translated">通常の要素で使用すると、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events&quot;&gt;&lt;strong&gt;ネイティブDOMイベント&lt;/strong&gt;&lt;/a&gt;のみをリッスンし&lt;strong&gt;ます&lt;/strong&gt;。カスタム要素コンポーネントで使用すると、その子コンポーネントで発行された&lt;strong&gt;カスタムイベントを&lt;/strong&gt;リッスンします。</target>
        </trans-unit>
        <trans-unit id="7424a99bcccbebcb1704239527c00d6ecfad0963" translate="yes" xml:space="preserve">
          <source>When used on components, custom directive will always apply to component's root node, similarly to &lt;a href=&quot;component-attrs&quot;&gt;non-prop attributes&lt;/a&gt;.</source>
          <target state="translated">コンポーネントで使用する場合、カスタムディレクティブは、&lt;a href=&quot;component-attrs&quot;&gt;非prop属性&lt;/a&gt;と同様に、常にコンポーネントのルートノードに適用されます。</target>
        </trans-unit>
        <trans-unit id="ad6354ba0509e976f620f5684a0ecbdb3c62711b" translate="yes" xml:space="preserve">
          <source>When used on elements/components with &lt;code&gt;v-for&lt;/code&gt;, the registered reference will be an Array containing DOM nodes or component instances.</source>
          <target state="translated">要素/コンポーネントで &lt;code&gt;v-for&lt;/code&gt; を使用すると、登録された参照はDOMノードまたはコンポーネントインスタンスを含む配列になります。</target>
        </trans-unit>
        <trans-unit id="f4a7dad4c6cfc5b01fc8733a0ec4ecb22ab51d3e" translate="yes" xml:space="preserve">
          <source>When used on normal components, it will behave like a normal prop:</source>
          <target state="translated">通常のコンポーネントに使用すると、通常のプロップのように動作します。</target>
        </trans-unit>
        <trans-unit id="7e732a1c52ca8cf754429434fdc2c9d76e59a40b" translate="yes" xml:space="preserve">
          <source>When used on plain elements, it will be passed to the &lt;code&gt;createElement&lt;/code&gt; call as the &lt;code&gt;is&lt;/code&gt; option, and also rendered as a native attribute. This supports the usage of customized built-in elements.</source>
          <target state="translated">プレーン要素で使用すると、 &lt;code&gt;is&lt;/code&gt; オプションとして &lt;code&gt;createElement&lt;/code&gt; 呼び出しに渡され、ネイティブ属性としてもレンダリングされます。これは、カスタマイズされた組み込み要素の使用をサポートします。</target>
        </trans-unit>
        <trans-unit id="e351a36d6e4d3bd7a9ce7236de933a0d2d3934ac" translate="yes" xml:space="preserve">
          <source>When used on the reserved &lt;code&gt;&amp;lt;component&amp;gt;&lt;/code&gt; tag, it will behave exactly the same as in 2.x;</source>
          <target state="translated">予約済みの &lt;code&gt;&amp;lt;component&amp;gt;&lt;/code&gt; タグで使用すると、2.xとまったく同じように動作します。</target>
        </trans-unit>
        <trans-unit id="765016b97659c6d561b95942c108d740532eb2f6" translate="yes" xml:space="preserve">
          <source>When used to bind the &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;style&lt;/code&gt; attribute, it supports additional value types such as Array or Objects. See linked guide section below for more details.</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; または &lt;code&gt;style&lt;/code&gt; 属性のバインドに使用すると、配列やオブジェクトなどの追加の値タイプがサポートされます。詳細については、以下のリンクされたガイドセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="3aa4f6aa06672812c020dc14f091831d9a5bfaff" translate="yes" xml:space="preserve">
          <source>When used together with &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;, make sure to nest it inside:</source>
          <target state="translated">&lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; と一緒に使用する場合は、必ず内部にネストしてください。</target>
        </trans-unit>
        <trans-unit id="d2004737a99c7cd400658a4b50d801ecb378d7ff" translate="yes" xml:space="preserve">
          <source>When used together with &lt;code&gt;v-if&lt;/code&gt;, &lt;code&gt;v-for&lt;/code&gt; has a higher priority than &lt;code&gt;v-if&lt;/code&gt;. See the &lt;a href=&quot;list#v-for-with-v-if&quot;&gt;list rendering guide&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;v-if&lt;/code&gt; と一緒に使用すると、 &lt;code&gt;v-for&lt;/code&gt; は &lt;code&gt;v-if&lt;/code&gt; よりも優先されます。詳細については、&lt;a href=&quot;list#v-for-with-v-if&quot;&gt;リストレンダリングガイド&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="bee43712dd211f1c35df632055f8887b9d1cfc4e" translate="yes" xml:space="preserve">
          <source>When used together with v-if, v-for has a higher priority than v-if. See the &lt;a href=&quot;../guide/list#v-for-with-v-if&quot;&gt;list rendering guide&lt;/a&gt; for details.</source>
          <target state="translated">v-ifと一緒に使用すると、v-forはv-ifよりも優先されます。詳細については、&lt;a href=&quot;../guide/list#v-for-with-v-if&quot;&gt;リストレンダリングガイド&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b5bb95376e672859dca4d4310ff771e83f090090" translate="yes" xml:space="preserve">
          <source>When used together, &lt;code&gt;v-if&lt;/code&gt; has a higher priority than &lt;code&gt;v-for&lt;/code&gt;. We don't recommend using these two directives together on one element &amp;mdash; see the &lt;a href=&quot;../guide/list#v-for-with-v-if&quot;&gt;list rendering guide&lt;/a&gt; for details.</source>
          <target state="translated">一緒に使用すると、 &lt;code&gt;v-if&lt;/code&gt; は &lt;code&gt;v-for&lt;/code&gt; よりも優先されます。これらの2つのディレクティブを1つの要素で一緒に使用することはお勧めしません。詳細については、&lt;a href=&quot;../guide/list#v-for-with-v-if&quot;&gt;リストレンダリングガイド&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="8be5b9382ac62c19c6f4c6d35f193f4842773377" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;v-bind&lt;/code&gt;, the only falsy values are now: &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt;. This means &lt;code&gt;0&lt;/code&gt; and empty strings will render as truthy. So for example, &lt;code&gt;v-bind:draggable=&quot;''&quot;&lt;/code&gt; will render as &lt;code&gt;draggable=&quot;true&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;v-bind&lt;/code&gt; で使用した場合、 &lt;code&gt;false&lt;/code&gt; 値は &lt;code&gt;null&lt;/code&gt; 、 &lt;code&gt;undefined&lt;/code&gt; 、falseのみになります。つまり、 &lt;code&gt;0&lt;/code&gt; と空の文字列は真実としてレンダリングされます。したがって、たとえば、 &lt;code&gt;v-bind:draggable=&quot;''&quot;&lt;/code&gt; は &lt;code&gt;draggable=&quot;true&quot;&lt;/code&gt; としてレンダリングされます。</target>
        </trans-unit>
        <trans-unit id="73d22b936f5f6ffa1364c72049c04fab5ebd1aad" translate="yes" xml:space="preserve">
          <source>When used without an argument, can be used to bind an object containing attribute name-value pairs. Note in this mode &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;style&lt;/code&gt; does not support Array or Objects.</source>
          <target state="translated">引数なしで使用すると、属性の名前と値のペアを含むオブジェクトをバインドするために使用できます。このモードでは、 &lt;code&gt;class&lt;/code&gt; と &lt;code&gt;style&lt;/code&gt; は配列またはオブジェクトをサポートしないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="c92b86613bb50d0d3909045ae62372cbd0ba73dc" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;../../api/options-data#watch&quot;&gt;the &lt;code&gt;watch&lt;/code&gt; option&lt;/a&gt; to watch an array, the callback will only trigger when the array is replaced. In other words, the watch callback will no longer be triggered on array mutation. To trigger on mutation, the &lt;code&gt;deep&lt;/code&gt; option must be specified.</source>
          <target state="translated">&lt;a href=&quot;../../api/options-data#watch&quot;&gt; &lt;code&gt;watch&lt;/code&gt; &lt;/a&gt;オプションを使用して配列を監視する場合、コールバックは配列が置き換えられたときにのみトリガーされます。つまり、配列の変更時にウォッチコールバックがトリガーされなくなります。ミューテーションでトリガーするには、 &lt;code&gt;deep&lt;/code&gt; オプションを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="a37ce001f85a01806e0a868532afd28214a23c8d" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;../guide/component-registration#local-registration&quot;&gt;local registration&lt;/a&gt;, you can also directly provide a function that returns a &lt;code&gt;Promise&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;../guide/component-registration#local-registration&quot;&gt;ローカル登録&lt;/a&gt;を使用する場合、 &lt;code&gt;Promise&lt;/code&gt; を返す関数を直接提供することもできます。</target>
        </trans-unit>
        <trans-unit id="c790db75231ac4e455c32a062aaa4b55e184839b" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;components-registration#Local-Registration&quot;&gt;local registration&lt;/a&gt;, you can also directly provide a function that returns a &lt;code&gt;Promise&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;components-registration#Local-Registration&quot;&gt;ローカル登録&lt;/a&gt;を使用する場合、 &lt;code&gt;Promise&lt;/code&gt; を返す関数を直接提供することもできます：</target>
        </trans-unit>
        <trans-unit id="155dd72290bb5a75b47cd1b727e2637716b8c1c8" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;inject&lt;/code&gt; in &lt;code&gt;setup()&lt;/code&gt;, we also need to explicitly import it from &lt;code&gt;vue&lt;/code&gt;. Once we do so, this allows us to invoke it to define how we want to expose it to our component.</source>
          <target state="translated">&lt;code&gt;setup()&lt;/code&gt; で &lt;code&gt;inject&lt;/code&gt; を使用する場合は、 &lt;code&gt;vue&lt;/code&gt; から明示的にインポートする必要もあります。そうすると、これを呼び出して、コンポーネントにどのように公開するかを定義できます。</target>
        </trans-unit>
        <trans-unit id="71dd171ffdf07ffc560f972b60c7a451789477b7" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;provide&lt;/code&gt; in &lt;code&gt;setup()&lt;/code&gt;, we start by explicitly importing the method from &lt;code&gt;vue&lt;/code&gt;. This allows us to define each property with its own invocation of &lt;code&gt;provide&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;setup()&lt;/code&gt; で &lt;code&gt;provide&lt;/code&gt; を使用する場合、 &lt;code&gt;vue&lt;/code&gt; からメソッドを明示的にインポートすることから始めます。これにより、 &lt;code&gt;provide&lt;/code&gt; を独自に呼び出して各プロパティを定義できます。</target>
        </trans-unit>
        <trans-unit id="99c3ac076c214df02b2fff4ef44f92751d560253" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;vue-loader&lt;/code&gt; or &lt;code&gt;vueify&lt;/code&gt;, templates inside &lt;code&gt;*.vue&lt;/code&gt; files are pre-compiled into JavaScript at build time. You don&amp;rsquo;t really need the compiler in the final bundle, and can therefore use the runtime-only build.</source>
          <target state="translated">&lt;code&gt;vue-loader&lt;/code&gt; または &lt;code&gt;vueify&lt;/code&gt; を使用する場合、 &lt;code&gt;*.vue&lt;/code&gt; ファイル内のテンプレートはビルド時にJavaScriptにプリコンパイルされます。最終的なバンドルにはコンパイラーは本当に必要ないため、ランタイムのみのビルドを使用できます。</target>
        </trans-unit>
        <trans-unit id="49fe6055e1baf5ecb1fa9c79e5109c02c820ea28" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;vue-loader&lt;/code&gt;, templates inside &lt;code&gt;*.vue&lt;/code&gt; files are pre-compiled into JavaScript at build time. You don&amp;rsquo;t really need the compiler in the final bundle, and can therefore use the runtime-only build.</source>
          <target state="translated">&lt;code&gt;vue-loader&lt;/code&gt; を使用する場合、 &lt;code&gt;*.vue&lt;/code&gt; ファイル内のテンプレートはビルド時にJavaScriptにプリコンパイルされます。最終バンドルにはコンパイラは実際には必要ないため、ランタイムのみのビルドを使用できます。</target>
        </trans-unit>
        <trans-unit id="f2867cff36a3fe6d83bd3572deaa22405cc206f8" translate="yes" xml:space="preserve">
          <source>When using JavaScript-only transitions, &lt;strong&gt;the &lt;code&gt;done&lt;/code&gt; callbacks are required for the &lt;code&gt;enter&lt;/code&gt; and &lt;code&gt;leave&lt;/code&gt; hooks&lt;/strong&gt;. Otherwise, the hooks will be called synchronously and the transition will finish immediately.</source>
          <target state="translated">JavaScriptの専用のトランジションを使用する場合は、&lt;strong&gt; &lt;code&gt;done&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;コールバックをするために必要な&lt;/strong&gt;&lt;strong&gt; &lt;code&gt;enter&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;および&lt;/strong&gt;&lt;strong&gt; &lt;code&gt;leave&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;フック&lt;/strong&gt;。それ以外の場合、フックは同期的に呼び出され、遷移はすぐに終了します。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="492a825e70975417fd58f060648eb43809c5835c" translate="yes" xml:space="preserve">
          <source>When using JavaScript-only transitions, &lt;strong&gt;the &lt;code&gt;done&lt;/code&gt; callbacks are required for the &lt;code&gt;enter&lt;/code&gt; and &lt;code&gt;leave&lt;/code&gt; hooks&lt;/strong&gt;. Otherwise, the hooks will be called synchronously and the transition will finish immediately. Adding &lt;code&gt;:css=&quot;false&quot;&lt;/code&gt; will also let Vue know to skip CSS detection. Aside from being slightly more performant, this also prevents CSS rules from accidentally interfering with the transition.</source>
          <target state="translated">JavaScriptのみのトランジションを使用する場合&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt; &lt;code&gt;enter&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;フック&lt;/strong&gt;&lt;strong&gt;と&lt;/strong&gt;&lt;strong&gt; &lt;code&gt;leave&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt;フック&lt;/strong&gt;に&lt;strong&gt;は &lt;code&gt;done&lt;/code&gt; コールバックが必要です&lt;/strong&gt;。それ以外の場合、フックは同期的に呼び出され、遷移はすぐに終了します。 &lt;code&gt;:css=&quot;false&quot;&lt;/code&gt; を追加すると、VueにCSS検出をスキップするように通知されます。パフォーマンスがわずかに向上するだけでなく、CSSルールが誤って移行に干渉するのを防ぎます。</target>
        </trans-unit>
        <trans-unit id="dc8e11afcc19c58163c7f043d414ef7a0a2eb199" translate="yes" xml:space="preserve">
          <source>When using Single-File Components, the CSS inside components are injected dynamically as &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; tags via JavaScript. This has a small runtime cost, and if you are using server-side rendering it will cause a &quot;flash of unstyled content&quot;. Extracting the CSS across all components into the same file will avoid these issues, and also result in better CSS minification and caching.</source>
          <target state="translated">シングルファイルコンポーネントを使用する場合、コンポーネント内のCSSは、JavaScriptを介して &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; タグとして動的に挿入されます。これには実行時のコストが小さく、サーバー側のレンダリングを使用している場合は、「スタイルのないコンテンツのフラッシュ」が発生します。すべてのコンポーネントのCSSを同じファイルに抽出すると、これらの問題が回避され、CSSの縮小とキャッシュが向上します。</target>
        </trans-unit>
        <trans-unit id="82fb89cebf9e12b8e890d2c8212be0ff387c7a63" translate="yes" xml:space="preserve">
          <source>When using Single-File Components, the CSS inside components are injected dynamically as &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; tags via JavaScript. This has a small runtime cost, and if you are using server-side rendering it will cause a &amp;ldquo;flash of unstyled content&amp;rdquo;. Extracting the CSS across all components into the same file will avoid these issues, and also result in better CSS minification and caching.</source>
          <target state="translated">単一ファイルコンポーネントを使用する場合、コンポーネント内のCSSは、JavaScriptを介して &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; タグとして動的に挿入されます。これは実行時のコストが小さく、サーバー側のレンダリングを使用している場合は、「スタイルのないコンテンツのフラッシュ」が発生します。すべてのコンポーネントのCSSを同じファイルに抽出すると、これらの問題が回避され、CSSの小型化とキャッシュが改善されます。</target>
        </trans-unit>
        <trans-unit id="6ae9007703022fa5cb7c0cd322bf3a50ec4cecf4" translate="yes" xml:space="preserve">
          <source>When using Vue, we recommend also installing the &lt;a href=&quot;https://github.com/vuejs/vue-devtools#vue-devtools&quot;&gt;Vue Devtools (opens new window)&lt;/a&gt; in your browser, allowing you to inspect and debug your Vue applications in a more user-friendly interface.</source>
          <target state="translated">Vueを使用する場合は、ブラウザーに&lt;a href=&quot;https://github.com/vuejs/vue-devtools#vue-devtools&quot;&gt;Vue Devtools（新しいウィンドウを開く）&lt;/a&gt;もインストールして、よりユーザーフレンドリーなインターフェイスでVueアプリケーションを検査およびデバッグできるようにすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="552be3178df5885d9ef1af398d3a7802f9917a44" translate="yes" xml:space="preserve">
          <source>When using Vue, we recommend also installing the &lt;a href=&quot;https://github.com/vuejs/vue-devtools#vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt; in your browser, allowing you to inspect and debug your Vue applications in a more user-friendly interface.</source>
          <target state="translated">Vueを使用する場合は、ブラウザーに&lt;a href=&quot;https://github.com/vuejs/vue-devtools#vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt;をインストールすることをお勧めします。これにより、ユーザーフレンドリーなインターフェイスでVueアプリケーションを検査およびデバッグできます。</target>
        </trans-unit>
        <trans-unit id="f83ec783173aead30ee96ed5f55121a4a391b2b2" translate="yes" xml:space="preserve">
          <source>When using a build tool like Webpack or Browserify, the production mode will be determined by &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; inside Vue&amp;rsquo;s source code, and it will be in development mode by default. Both build tools provide ways to overwrite this variable to enable Vue&amp;rsquo;s production mode, and warnings will be stripped by minifiers during the build. All &lt;code&gt;vue-cli&lt;/code&gt; templates have these pre-configured for you, but it would be beneficial to know how it is done:</source>
          <target state="translated">WebpackやBrowserifyなどのビルドツールを使用する場合、本番モードはVueのソースコード内の &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; によって決定され、デフォルトでは開発モードになります。どちらのビルドツールも、この変数を上書きしてVueのプロダクションモードを有効にする方法を提供します。警告は、ビルド中に縮小版によって削除されます。すべての &lt;code&gt;vue-cli&lt;/code&gt; テンプレートにはこれらが事前に構成されていますが、それがどのように行われるかを知っておくと便利です。</target>
        </trans-unit>
        <trans-unit id="73ab3894a5373b24631fe2355bde56549085fb2c" translate="yes" xml:space="preserve">
          <source>When using a build tool like Webpack or Browserify, the production mode will be determined by &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; inside Vue's source code, and it will be in development mode by default. Both build tools provide ways to overwrite this variable to enable Vue's production mode, and warnings will be stripped by minifiers during the build. Vue CLI has this pre-configured for you, but it would be beneficial to know how it is done:</source>
          <target state="translated">WebpackやBrowserifyなどのビルドツールを使用する場合、本番モードはVueのソースコード内の &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; によって決定され、デフォルトでは開発モードになります。どちらのビルドツールも、この変数を上書きしてVueの本番モードを有効にする方法を提供し、ビルド中にミニファイアによって警告が削除されます。Vue CLIにはこれが事前に構成されていますが、それがどのように行われるかを知っておくと便利です。</target>
        </trans-unit>
        <trans-unit id="7feb3981a84943e5fbab5765c5ec53aded8a95c4" translate="yes" xml:space="preserve">
          <source>When using buttons inside a form, you must set the type to prevent submitting the form. You can also use an input to create buttons:</source>
          <target state="translated">フォーム内でボタンを使用する場合は、フォームを送信しないようにタイプを設定する必要があります。また、入力を利用してボタンを作成することもできます。</target>
        </trans-unit>
        <trans-unit id="90059bdf6364a692356bb5121dc518a09307b6ec" translate="yes" xml:space="preserve">
          <source>When using in-DOM templates (templates directly written in an HTML file), you should also avoid naming keys with uppercase characters, as browsers will coerce attribute names into lowercase:</source>
          <target state="translated">in-DOMテンプレート(HTMLファイルに直接記述されたテンプレート)を使用する場合は、ブラウザが属性名を小文字にすることを強要するため、キーの名前を大文字にすることも避けなければなりません。</target>
        </trans-unit>
        <trans-unit id="9f49b04be3603b07dc0618756118b73addc7b4bc" translate="yes" xml:space="preserve">
          <source>When using in-DOM templates or in-JavaScript template strings, the template-to-render-function compilation is performed on the fly. This is usually fast enough in most cases, but is best avoided if your application is performance-sensitive.</source>
          <target state="translated">in-DOM テンプレートや in-JavaScript のテンプレート文字列を使用している場合、テンプレートからレンダリング関数へのコンパイルはその場で実行されます。これはたいていの場合は十分に高速ですが、アプリケーションがパフォーマンスに敏感な場合は避けたほうがよいでしょう。</target>
        </trans-unit>
        <trans-unit id="52a194f1e41a6a5db000b3e319f51a2d953f4422" translate="yes" xml:space="preserve">
          <source>When using outside of &lt;a href=&quot;#setup&quot;&gt;setup&lt;/a&gt; or &lt;a href=&quot;#lifecycle-hooks&quot;&gt;Lifecycle Hooks&lt;/a&gt;, please call &lt;code&gt;getCurrentInstance()&lt;/code&gt; on &lt;code&gt;setup&lt;/code&gt; and use the instance instead.</source>
          <target state="translated">外の使用している場合&lt;a href=&quot;#setup&quot;&gt;、セットアップ&lt;/a&gt;や&lt;a href=&quot;#lifecycle-hooks&quot;&gt;ライフサイクルフックを&lt;/a&gt;、電話にてお問い合わせください &lt;code&gt;getCurrentInstance()&lt;/code&gt; に &lt;code&gt;setup&lt;/code&gt; し、代わりにインスタンスを使用します。</target>
        </trans-unit>
        <trans-unit id="8268513fd3714a6bb1e18655deb42d64d8195501" translate="yes" xml:space="preserve">
          <source>When using reactive provide / inject values, &lt;strong&gt;it is recommended to keep any mutations to reactive properties inside of the &lt;em&gt;provider&lt;/em&gt; whenever possible&lt;/strong&gt;.</source>
          <target state="translated">リアクティブな提供/注入値を使用する場合&lt;strong&gt;は、可能な限り、&lt;em&gt;プロバイダー&lt;/em&gt;内のリアクティブプロパティへの変更を保持することをお勧めします&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="0a50aa13ab45b9b9f84e07dc20f120967762dc9a" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;data&lt;/code&gt; property on a component (i.e. anywhere except on &lt;code&gt;new Vue&lt;/code&gt;), the value must be a function that returns an object.</source>
          <target state="translated">コンポーネント（つまり、 &lt;code&gt;new Vue&lt;/code&gt; 以外の場所）で &lt;code&gt;data&lt;/code&gt; プロパティを使用する場合、値はオブジェクトを返す関数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="29cfa5029bb45e9515038e53406ba42c15ddb95c" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;setup&lt;/code&gt; function, it will take two arguments:</source>
          <target state="translated">&lt;code&gt;setup&lt;/code&gt; 関数を使用する場合、2つの引数が必要です。</target>
        </trans-unit>
        <trans-unit id="fe17ea531d76bcff516416b2c63a3806ff1db39b" translate="yes" xml:space="preserve">
          <source>When using the Composition API, the concept of &lt;a href=&quot;reactivity-fundamentals#creating-standalone-reactive-values-as-refs&quot;&gt;reactive refs&lt;/a&gt; and &lt;a href=&quot;component-template-refs&quot;&gt;template refs&lt;/a&gt; are unified. In order to obtain a reference to an in-template element or component instance, we can declare a ref as usual and return it from &lt;a href=&quot;composition-api-setup&quot;&gt;setup()&lt;/a&gt;:</source>
          <target state="translated">Composition APIを使用する場合、&lt;a href=&quot;reactivity-fundamentals#creating-standalone-reactive-values-as-refs&quot;&gt;リアクティブ参照&lt;/a&gt;と&lt;a href=&quot;component-template-refs&quot;&gt;テンプレート参照の&lt;/a&gt;概念が統一されます。テンプレート内の要素またはコンポーネントインスタンスへの参照を取得するために、通常どおりrefを宣言し、&lt;a href=&quot;composition-api-setup&quot;&gt;setup（）&lt;/a&gt;から返すことができます。</target>
        </trans-unit>
        <trans-unit id="2325636eb7899967fe90bf565cfdf8509e2423d9" translate="yes" xml:space="preserve">
          <source>When using the render function, i.e., &lt;code&gt;h&lt;/code&gt;, 2.x used to define the &lt;code&gt;slot&lt;/code&gt; data property on the content nodes.</source>
          <target state="translated">レンダリング関数を使用する場合、つまり、コンテンツノードの &lt;code&gt;slot&lt;/code&gt; データプロパティを定義するために使用される &lt;code&gt;h&lt;/code&gt; 、2.x 。</target>
        </trans-unit>
        <trans-unit id="9b53ab6a7a09c723aad6b1a3af71ea61e4b6a3b8" translate="yes" xml:space="preserve">
          <source>When using this component inside the initial HTML structure, we can see a problem - the modal is being rendered inside the deeply nested &lt;code&gt;div&lt;/code&gt; and the &lt;code&gt;position: absolute&lt;/code&gt; of the modal takes the parent relatively positioned &lt;code&gt;div&lt;/code&gt; as reference.</source>
          <target state="translated">最初のHTML構造内のこのコンポーネントを使用する場合、我々は問題を見ることができる-モーダルが深くネストされた内部にレンダリングされている &lt;code&gt;div&lt;/code&gt; と &lt;code&gt;position: absolute&lt;/code&gt; モーダルの親比較的配置かかり &lt;code&gt;div&lt;/code&gt; 基準として。</target>
        </trans-unit>
        <trans-unit id="b443edf845e80ba0a827955e7f9e75dfd908e2cd" translate="yes" xml:space="preserve">
          <source>When watched value is an object or array, any changes to its properties or elements won't trigger the watcher because they reference the same object/array:</source>
          <target state="translated">ウォッチされている値がオブジェクトや配列である場合、そのプロパティや要素への変更は、同じオブジェクト/配列を参照しているため、ウォッチャーのトリガーにはなりません。</target>
        </trans-unit>
        <trans-unit id="3115fa755473f700797db8a3eaa25ac70279399a" translate="yes" xml:space="preserve">
          <source>When watching an array, the callback will only trigger when the array is replaced. If you need to trigger on mutation, the &lt;code&gt;deep&lt;/code&gt; option must be specified.</source>
          <target state="translated">配列を監視している場合、コールバックは配列が置き換えられたときにのみトリガーされます。ミューテーションでトリガーする必要がある場合は、 &lt;code&gt;deep&lt;/code&gt; オプションを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="6ac33dbea1192d62c5d6e524087e525e604c224b" translate="yes" xml:space="preserve">
          <source>When we click on the button, we need to communicate to the parent that it should enlarge the text of all posts. Fortunately, Vue instances provide a custom events system to solve this problem. The parent can choose to listen to any event on the child component instance with &lt;code&gt;v-on&lt;/code&gt;, just as we would with a native DOM event:</source>
          <target state="translated">ボタンをクリックすると、すべての投稿のテキストを拡大する必要があることを親に伝える必要があります。幸い、Vueインスタンスは、この問題を解決するためのカスタムイベントシステムを提供します。親は、ネイティブDOMイベントの場合と同様 &lt;code&gt;v-on&lt;/code&gt; 、v-onを使用して子コンポーネントインスタンスのイベントをリッスンすることを選択できます。</target>
        </trans-unit>
        <trans-unit id="56b6480e99f62d0b0a2594baeb4025339f0556be" translate="yes" xml:space="preserve">
          <source>When we click on the button, we need to communicate to the parent that it should enlarge the text of all posts. To solve this problem, component instances provide a custom events system. The parent can choose to listen to any event on the child component instance with &lt;code&gt;v-on&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt;, just as we would with a native DOM event:</source>
          <target state="translated">ボタンをクリックすると、すべての投稿のテキストを拡大する必要があることを親に伝える必要があります。この問題を解決するために、コンポーネントインスタンスはカスタムイベントシステムを提供します。親は、ネイティブDOMイベントの場合と同様に、 &lt;code&gt;v-on&lt;/code&gt; または &lt;code&gt;@&lt;/code&gt; を使用して子コンポーネントインスタンスの任意のイベントをリッスンすることを選択できます。</target>
        </trans-unit>
        <trans-unit id="503e44cb3c820763078d2ca02c03c4a8a431e8d6" translate="yes" xml:space="preserve">
          <source>When we defined the &lt;code&gt;&amp;lt;button-counter&amp;gt;&lt;/code&gt; component, you may have noticed that &lt;code&gt;data&lt;/code&gt; wasn&amp;rsquo;t directly provided an object, like this:</source>
          <target state="translated">&lt;code&gt;&amp;lt;button-counter&amp;gt;&lt;/code&gt; コンポーネントを定義したときに、次のように &lt;code&gt;data&lt;/code&gt; がオブジェクトに直接提供されていないことに気付いたかもしれません。</target>
        </trans-unit>
        <trans-unit id="07b462f32af9d739921941c237aa3a2d6e82914c" translate="yes" xml:space="preserve">
          <source>When we want to use a few properties of the large reactive object, it could be tempting to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;ES6 destructuring (opens new window)&lt;/a&gt; to get properties we want:</source>
          <target state="translated">大きなリアクティブオブジェクトのいくつかのプロパティを使用したい場合、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;ES6デストラクチャリング（新しいウィンドウを開く）&lt;/a&gt;を使用して、必要なプロパティを取得したくなるかもしれません。</target>
        </trans-unit>
        <trans-unit id="d25563d9cbbe500885b8017f11094dbe20ce5416" translate="yes" xml:space="preserve">
          <source>When we were learning about form input bindings, we saw that &lt;code&gt;v-model&lt;/code&gt; has &lt;a href=&quot;forms#modifiers&quot;&gt;built-in modifiers&lt;/a&gt; - &lt;code&gt;.trim&lt;/code&gt;, &lt;code&gt;.number&lt;/code&gt; and &lt;code&gt;.lazy&lt;/code&gt;. In some cases, however, you might also want to add your own custom modifiers.</source>
          <target state="translated">フォーム入力バインディングについて学習していたとき、 &lt;code&gt;v-model&lt;/code&gt; には&lt;a href=&quot;forms#modifiers&quot;&gt;組み込みの修飾子&lt;/a&gt;（ &lt;code&gt;.trim&lt;/code&gt; 、 &lt;code&gt;.number&lt;/code&gt; 、および &lt;code&gt;.lazy&lt;/code&gt; )があることがわかりました。ただし、場合によっては、独自のカスタム修飾子を追加することもできます。</target>
        </trans-unit>
        <trans-unit id="3fc31d9024fc1569b72c4369fcb0a381a7a9ef3d" translate="yes" xml:space="preserve">
          <source>When wrapped around a dynamic component, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; caches the inactive component instances without destroying them. Similar to &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; is an abstract component: it doesn&amp;rsquo;t render a DOM element itself, and doesn&amp;rsquo;t show up in the component parent chain.</source>
          <target state="translated">動的コンポーネントをラップすると、 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; は非アクティブなコンポーネントインスタンスを破棄せずにキャッシュします。 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; と同様に、 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; は抽象的なコンポーネントです。DOM要素自体をレンダリングせず、コンポーネントの親チェーンに表示されません。</target>
        </trans-unit>
        <trans-unit id="6024fe4000d9406c04c3b8e635b2733012f8d604" translate="yes" xml:space="preserve">
          <source>When wrapped around a dynamic component, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; caches the inactive component instances without destroying them. Similar to &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; is an abstract component: it doesn't render a DOM element itself, and doesn't show up in the component parent chain.</source>
          <target state="translated">&lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; は、動的コンポーネントをラップアラウンドすると、非アクティブなコンポーネントインスタンスを破棄せずにキャッシュします。 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; と同様に、 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; は抽象コンポーネントです。DOM要素自体をレンダリングせず、コンポーネントの親チェーンに表示されません。</target>
        </trans-unit>
        <trans-unit id="c8cb2aa251b532a1099571f894888303ae87f928" translate="yes" xml:space="preserve">
          <source>When you create a Vue instance, you pass in an &lt;strong&gt;options object&lt;/strong&gt;. The majority of this guide describes how you can use these options to create your desired behavior. For reference, you can also browse the full list of options in the &lt;a href=&quot;../api/index#Options-Data&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="translated">Vueインスタンスを作成するときは、&lt;strong&gt;オプションオブジェクト&lt;/strong&gt;を渡し&lt;strong&gt;ます&lt;/strong&gt;。このガイドの大部分では、これらのオプションを使用して目的の動作を作成する方法について説明しています。参考のために、&lt;a href=&quot;../api/index#Options-Data&quot;&gt;APIリファレンス&lt;/a&gt;でオプションの完全なリストを参照することもできます。</target>
        </trans-unit>
        <trans-unit id="5edfa6e15cc3b92cf84e0d23dc57525471bb32f0" translate="yes" xml:space="preserve">
          <source>When you directly set an item with the index, e.g. &lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt;</source>
          <target state="translated">インデックスを使用してアイテムを直接設定する場合（例： &lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4e05eb2c179f008e282eb11dbfab780273bd17af" translate="yes" xml:space="preserve">
          <source>When you get started with a component that only generates a heading based on the &lt;code&gt;level&lt;/code&gt; prop, you quickly arrive at this:</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; 小道具に基づいて見出しのみを生成するコンポーネントを使い始めると、すぐにこれに到達します。</target>
        </trans-unit>
        <trans-unit id="83380da98aaeb039f4a9465908493672dd7cb6c2" translate="yes" xml:space="preserve">
          <source>When you look closely, you&amp;rsquo;ll see that these components will actually be each other&amp;rsquo;s descendent &lt;em&gt;and&lt;/em&gt; ancestor in the render tree - a paradox! When registering components globally with &lt;code&gt;Vue.component&lt;/code&gt;, this paradox is resolved for you automatically. If that&amp;rsquo;s you, you can stop reading here.</source>
          <target state="translated">よく見ると、これらのコンポーネントは実際にはRender Treeで互いの子孫で&lt;em&gt;あり&lt;/em&gt;祖先であることがわかります-パラドックス！コンポーネントを &lt;code&gt;Vue.component&lt;/code&gt; でグローバルに登録すると、このパラドックスは自動的に解決されます。それがあなたなら、ここで読むのをやめることができます。</target>
        </trans-unit>
        <trans-unit id="f30f5b44a5fc3fcf76c6bc5c1c85bd3a58259448" translate="yes" xml:space="preserve">
          <source>When you modify the length of the array, e.g. &lt;code&gt;vm.items.length = newLength&lt;/code&gt;</source>
          <target state="translated">配列の長さを変更する場合（例： &lt;code&gt;vm.items.length = newLength&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="116f534bd5f4250bf1748ab421ed8f10e572e2f6" translate="yes" xml:space="preserve">
          <source>When you pass a plain JavaScript object to a Vue instance as its &lt;code&gt;data&lt;/code&gt; option, Vue will walk through all of its properties and convert them to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters&quot;&gt;getter/setters&lt;/a&gt; using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt;&lt;code&gt;Object.defineProperty&lt;/code&gt;&lt;/a&gt;. This is an ES5-only and un-shimmable feature, which is why Vue doesn&amp;rsquo;t support IE8 and below.</source>
          <target state="translated">プレーンなJavaScriptオブジェクトを &lt;code&gt;data&lt;/code&gt; オプションとしてVueインスタンスに渡すと、Vueはすべてのプロパティをウォークスルーし、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt; &lt;code&gt;Object.defineProperty&lt;/code&gt; &lt;/a&gt;を使用してそれらを&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters&quot;&gt;ゲッター/セッターに&lt;/a&gt;変換します。これはES5のみでシムできない機能であるため、VueはIE8以下をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="933b3b1c3bc981ed309ab3c1c26b343f83550c6c" translate="yes" xml:space="preserve">
          <source>When you pass a plain JavaScript object to an application or component instance as its &lt;code&gt;data&lt;/code&gt; option, Vue will walk through all of its properties and convert them to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy&quot;&gt;Proxies (opens new window)&lt;/a&gt; using a handler with getters and setters. This is an ES6-only feature, but we offer a version of Vue 3 that uses the older &lt;code&gt;Object.defineProperty&lt;/code&gt; to support IE browsers. Both have the same surface API, but the Proxy version is slimmer and offers improved performance.</source>
          <target state="translated">プレーンなJavaScriptオブジェクトを &lt;code&gt;data&lt;/code&gt; オプションとしてアプリケーションまたはコンポーネントインスタンスに渡すと、Vueはそのすべてのプロパティをウォークスルーし、ゲッターとセッターを備えたハンドラーを使用してそれらを&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy&quot;&gt;プロキシに&lt;/a&gt;変換します（新しいウィンドウを開きます）。これはES6のみの機能ですが、IEブラウザーをサポートするために古い &lt;code&gt;Object.defineProperty&lt;/code&gt; を使用するバージョンのVue3を提供しています。どちらも同じサーフェスAPIを備えていますが、プロキシバージョンはよりスリムで、パフォーマンスが向上しています。</target>
        </trans-unit>
        <trans-unit id="2cc08c055658d2907306b28227fc08089b9c9d0b" translate="yes" xml:space="preserve">
          <source>When you pass an object to a component instance as data, Vue converts it to a proxy. This proxy enables Vue to perform dependency-tracking and change-notification when properties are accessed or modified. Each property is considered a dependency.</source>
          <target state="translated">オブジェクトをデータとしてコンポーネント インスタンスに渡すと、Vue はそれをプロキシに変換します。このプロキシを使用すると、プロパティがアクセスまたは変更されたときに Vue が依存関係の追跡と変更通知を実行できるようになります。各プロパティは依存関係とみなされます。</target>
        </trans-unit>
        <trans-unit id="1b263fbf80fd17168172064fb809118419b3f90b" translate="yes" xml:space="preserve">
          <source>When you register a component globally using &lt;code&gt;Vue.component&lt;/code&gt;, the global ID is automatically set as the component&amp;rsquo;s &lt;code&gt;name&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;Vue.component&lt;/code&gt; を使用してコンポーネントをグローバルに登録すると、グローバルIDがコンポーネントの &lt;code&gt;name&lt;/code&gt; オプションとして自動的に設定されます。</target>
        </trans-unit>
        <trans-unit id="3a59415917e0f7bce0c1e1ce588bc65642dde4e2" translate="yes" xml:space="preserve">
          <source>When you update the number, the change is animated below the input.</source>
          <target state="translated">数字を更新すると、入力の下に変化がアニメーションで表示されます。</target>
        </trans-unit>
        <trans-unit id="9e99dda28553577f5a72c70f4cf761e117d5aa05" translate="yes" xml:space="preserve">
          <source>When you update the number, the change is animated below the input. This makes for a nice demo, but what about something that isn&amp;rsquo;t directly stored as a number, like any valid CSS color for example? Here&amp;rsquo;s how we could accomplish this with &lt;a href=&quot;https://github.com/tweenjs/tween.js&quot;&gt;Tween.js&lt;/a&gt; and &lt;a href=&quot;https://github.com/brehaut/color-js&quot;&gt;Color.js&lt;/a&gt;:</source>
          <target state="translated">数値を更新すると、変更は入力の下でアニメーション化されます。これは素晴らしいデモになりますが、有効なCSSカラーなど、数値として直接格納されないものはどうでしょうか？&lt;a href=&quot;https://github.com/tweenjs/tween.js&quot;&gt;Tween.js&lt;/a&gt;と&lt;a href=&quot;https://github.com/brehaut/color-js&quot;&gt;Color.jsで&lt;/a&gt;これを実現する方法を次に示します。</target>
        </trans-unit>
        <trans-unit id="e0e5cc8bd4dbd3f0f73f17bc44dd88fc965b701e" translate="yes" xml:space="preserve">
          <source>When you use a CSS property that requires &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix&quot;&gt;vendor prefixes (opens new window)&lt;/a&gt; in &lt;code&gt;:style&lt;/code&gt;, for example &lt;code&gt;transform&lt;/code&gt;, Vue will automatically detect and add appropriate prefixes to the applied styles.</source>
          <target state="translated">あなたが必要とCSSのプロパティを使用すると&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix&quot;&gt;、ベンダープレフィックス（新しいウィンドウが開きます）の&lt;/a&gt;中で &lt;code&gt;:style&lt;/code&gt; 、例えば &lt;code&gt;transform&lt;/code&gt; 、Vueが自動的に検出および適用されるスタイルに適切な接頭辞を追加します。</target>
        </trans-unit>
        <trans-unit id="ce2b512d3d14fbcaa1fe4759c2ac6d6267d1b944" translate="yes" xml:space="preserve">
          <source>When you use a CSS property that requires &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix&quot;&gt;vendor prefixes&lt;/a&gt; in &lt;code&gt;v-bind:style&lt;/code&gt;, for example &lt;code&gt;transform&lt;/code&gt;, Vue will automatically detect and add appropriate prefixes to the applied styles.</source>
          <target state="translated">あなたが必要とCSSのプロパティを使用すると&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix&quot;&gt;、ベンダープレフィックス&lt;/a&gt;で &lt;code&gt;v-bind:style&lt;/code&gt; 、例えば &lt;code&gt;transform&lt;/code&gt; 、Vueが自動的に検出および適用されるスタイルに適切な接頭辞を追加します。</target>
        </trans-unit>
        <trans-unit id="6b1215d8f619fb72cc267754d02609941e493e8b" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;class&lt;/code&gt; attribute on a custom component with a single root element, those classes will be added to this element. Existing classes on this element will not be overwritten.</source>
          <target state="translated">単一のルート要素を持つカスタムコンポーネントで &lt;code&gt;class&lt;/code&gt; 属性を使用すると、それらのクラスがこの要素に追加されます。この要素の既存のクラスは上書きされません。</target>
        </trans-unit>
        <trans-unit id="4b326885055699fce588d56dd25601619eb5af2c" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;class&lt;/code&gt; attribute on a custom component, those classes will be added to the component&amp;rsquo;s root element. Existing classes on this element will not be overwritten.</source>
          <target state="translated">カスタムコンポーネントで &lt;code&gt;class&lt;/code&gt; 属性を使用すると、それらのクラスはコンポーネントのルート要素に追加されます。この要素の既存のクラスは上書きされません。</target>
        </trans-unit>
        <trans-unit id="b29e2633e0031493fdfbbbfa60e0c5563fa25e4d" translate="yes" xml:space="preserve">
          <source>When you want to use data inside a slot, such as in:</source>
          <target state="translated">inのようにスロット内のデータを使用したい場合。</target>
        </trans-unit>
        <trans-unit id="5224afaf87d02d75b63b7c58580593c3450a4bdb" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;counter&lt;/code&gt; is modified, for example &lt;code&gt;counter.value = 5&lt;/code&gt;, the watch will trigger and execute the callback (second argument) which in this case will log &lt;code&gt;'The new counter value is: 5'&lt;/code&gt; into our console.</source>
          <target state="translated">&lt;code&gt;counter&lt;/code&gt; が変更されるたびに（たとえば、 &lt;code&gt;counter.value = 5&lt;/code&gt; ）、ウォッチはコールバック（2番目の引数）をトリガーして実行します。この場合、 &lt;code&gt;'The new counter value is: 5'&lt;/code&gt; をコンソールに記録します。</target>
        </trans-unit>
        <trans-unit id="bdd9221b01210b73d5a5bf23b096d0f97ea0e9fb" translate="yes" xml:space="preserve">
          <source>Whenever there are multiple slots, use the full &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; based syntax for &lt;em&gt;all&lt;/em&gt; slots:</source>
          <target state="translated">複数のスロットがある場合は常に、&lt;em&gt;すべての&lt;/em&gt;スロットに対して完全な &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; ベースの構文を使用&lt;em&gt;し&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="3c59757a70411453c39e9877f5bd40fa36fe8fd5" translate="yes" xml:space="preserve">
          <source>Whenever this plugin is added to an application, the &lt;code&gt;install&lt;/code&gt; method will be called if it is an object. If it is a &lt;code&gt;function&lt;/code&gt;, the function itself will be called. In both cases, it will receive two parameters - the &lt;code&gt;app&lt;/code&gt; object resulting from Vue's &lt;code&gt;createApp&lt;/code&gt;, and the options passed in by the user.</source>
          <target state="translated">このプラグインがアプリケーションに追加されるたびに、それがオブジェクトである場合は &lt;code&gt;install&lt;/code&gt; メソッドが呼び出されます。もしそうであれば &lt;code&gt;function&lt;/code&gt; 、機能そのものが呼び出されます。どちらの場合も、Vueの &lt;code&gt;createApp&lt;/code&gt; から生成された &lt;code&gt;app&lt;/code&gt; オブジェクトと、ユーザーから渡されたオプションの2つのパラメーターを受け取ります。</target>
        </trans-unit>
        <trans-unit id="94a8989fc5605591725bf2c16d034ac1a8557ebb" translate="yes" xml:space="preserve">
          <source>Where multiple, equally good options exist, an arbitrary choice can be made to ensure consistency. In these rules, we describe each acceptable option and suggest a default choice. That means you can feel free to make a different choice in your own codebase, as long as you&amp;rsquo;re consistent and have a good reason. Please do have a good reason though! By adapting to the community standard, you will:</source>
          <target state="translated">同等に優れたオプションが複数存在する場合、一貫性を保つために任意の選択を行うことができます。これらのルールでは、許容可能な各オプションについて説明し、デフォルトの選択を提案します。つまり、一貫性があり、正当な理由がある限り、独自のコードベースで別の選択を自由に行うことができます。でも正当な理由があるのでどうぞ！コミュニティ標準に適応することにより、次のことが可能になります。</target>
        </trans-unit>
        <trans-unit id="40389be7b40b64109eb2a221c81a64962b25ce29" translate="yes" xml:space="preserve">
          <source>Where multiple, equally good options exist, an arbitrary choice can be made to ensure consistency. In these rules, we describe each acceptable option and suggest a default choice. That means you can feel free to make a different choice in your own codebase, as long as you're consistent and have a good reason. Please do have a good reason though! By adapting to the community standard, you will:</source>
          <target state="translated">複数の等しく良い選択肢が存在する場合には、整合性を確保するために任意の選択を行うことができる。このルールでは、それぞれの許容可能な選択肢を説明し、デフォルトの選択肢を提案しています。つまり、一貫性があり、正当な理由がある限り、あなた自身のコードベースで別の選択をしても構いません。ただし、正当な理由があることを確認してください! コミュニティの標準に適応することで、あなたは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="64c156561396e2c0ff843d5dfefecf7d5f00b748" translate="yes" xml:space="preserve">
          <source>Where should I start in a migration?</source>
          <target state="translated">移行はどこから始めればいいの?</target>
        </trans-unit>
        <trans-unit id="a916519a784aae97a6a144ef6d4aef7bf8304468" translate="yes" xml:space="preserve">
          <source>Wherever something can be easily accomplished in plain JavaScript, Vue render functions do not provide a proprietary alternative. For example, in a template using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt;:</source>
          <target state="translated">プレーンなJavaScriptで何かを簡単に実行できる場合はどこでも、Vueレンダリング関数は独自の代替手段を提供しません。たとえば、 &lt;code&gt;v-if&lt;/code&gt; と &lt;code&gt;v-for&lt;/code&gt; を使用するテンプレートでは：</target>
        </trans-unit>
        <trans-unit id="5cd4ca7066a7f80f437ded62b2c4ba106bff4e1c" translate="yes" xml:space="preserve">
          <source>Whether the current Vue instance is running on the server.</source>
          <target state="translated">現在の Vue インスタンスがサーバー上で実行されているかどうか。</target>
        </trans-unit>
        <trans-unit id="2496f7d91335bdaa5a94c0ccf88817d25c97566b" translate="yes" xml:space="preserve">
          <source>Which can be used in the template to control the font size of all blog posts:</source>
          <target state="translated">これは、すべてのブログ記事のフォントサイズを制御するためのテンプレートで使用することができます。</target>
        </trans-unit>
        <trans-unit id="63f372ca77a18336d9ceb38b597b82fab9d460d4" translate="yes" xml:space="preserve">
          <source>Which could also be written as:</source>
          <target state="translated">どちらもこう書くことができます。</target>
        </trans-unit>
        <trans-unit id="2f641e57e62a95de7443f1d301628bdc0504168b" translate="yes" xml:space="preserve">
          <source>Which might render something like:</source>
          <target state="translated">これは何かをレンダリングするかもしれません。</target>
        </trans-unit>
        <trans-unit id="f6dc1e7242ce0f196ee79154bfdd52a6d576a6b3" translate="yes" xml:space="preserve">
          <source>Which obsolete features you&amp;rsquo;re using. Most can be upgraded with find-and-replace, but others might take a few minutes. If you&amp;rsquo;re not currently following best practices, Vue 2.0 will also try harder to force you to. This is a good thing in the long run, but could also mean a significant (though possibly overdue) refactor.</source>
          <target state="translated">使用している古い機能。ほとんどは検索と置換を使用してアップグレードできますが、数分かかる場合もあります。現在、ベストプラクティスに従っていない場合、Vue 2.0は強制的に努力します。これは長期的には良いことですが、大幅な（期限切れかもしれませんが）リファクタリングも意味する可能性があります。</target>
        </trans-unit>
        <trans-unit id="13542c96e2b2982abdd966332d81cd761c716dab" translate="yes" xml:space="preserve">
          <source>Which will render:</source>
          <target state="translated">レンダリングされます。</target>
        </trans-unit>
        <trans-unit id="411f7634e21861007457debbcec0bcc5996eff6a" translate="yes" xml:space="preserve">
          <source>While Vue scales up just as well as React, it also scales down just as well as jQuery. That&amp;rsquo;s right - to get started, all you have to do is drop a single script tag into the page:</source>
          <target state="translated">VueはReactと同様にスケールアップしますが、jQueryと同様にスケールダウンします。そうです-開始するには、1つのスクリプトタグをページにドロップするだけです。</target>
        </trans-unit>
        <trans-unit id="67526a3ad5381ad5a3d17e38178b4ebbd75ccade" translate="yes" xml:space="preserve">
          <source>While Vue.js does not natively support mobile app development, there are a number of solutions for creating native iOS and Android apps with Vue.js.</source>
          <target state="translated">Vue.jsはモバイルアプリ開発をネイティブにはサポートしていませんが、Vue.jsを使ってiOSやAndroidのネイティブアプリを作成するためのソリューションはいくつかあります。</target>
        </trans-unit>
        <trans-unit id="41d93357bd259acbade7c18b02dac0a7c343f7e5" translate="yes" xml:space="preserve">
          <source>While all the examples on this page only need a single component, most real applications are organized into a tree of nested, reusable components. For example, a Todo application's component tree might look like this:</source>
          <target state="translated">このページのすべての例は単一のコンポーネントを必要としますが、実際のアプリケーションの多くは、入れ子になった再利用可能なコンポーネントのツリーで構成されています。例えば、Todo アプリケーションのコンポーネントツリーは次のようになります。</target>
        </trans-unit>
        <trans-unit id="0753de87f790a1e2f19722cd77fe0ca388129290" translate="yes" xml:space="preserve">
          <source>While attribute values without any spaces are not required to have quotes in HTML, this practice often leads to &lt;em&gt;avoiding&lt;/em&gt; spaces, making attribute values less readable.</source>
          <target state="translated">スペースを含まない属性値はHTMLで引用符を付ける必要はありませんが、これにより、スペースが&lt;em&gt;回避され&lt;/em&gt;、属性値が読みにくくなります。</target>
        </trans-unit>
        <trans-unit id="d1be13562f7dcc7da151626387e08df77b338b25" translate="yes" xml:space="preserve">
          <source>While computed properties are more appropriate in most cases, there are times when a custom watcher is necessary. That&amp;rsquo;s why Vue provides a more generic way to react to data changes through the &lt;code&gt;watch&lt;/code&gt; option. This is most useful when you want to perform asynchronous or expensive operations in response to changing data.</source>
          <target state="translated">ほとんどの場合、計算されたプロパティがより適切ですが、カスタムウォッチャーが必要な場合があります。これが、Vueが &lt;code&gt;watch&lt;/code&gt; オプションを介してデータの変更に対応するより一般的な方法を提供する理由です。これは、データの変更に応じて非同期または高価な操作を実行する場合に最も役立ちます。</target>
        </trans-unit>
        <trans-unit id="fd4fac6fce5850105ed2b54389e0980507751bfb" translate="yes" xml:space="preserve">
          <source>While computed properties are more appropriate in most cases, there are times when a custom watcher is necessary. That's why Vue provides a more generic way to react to data changes through the &lt;code&gt;watch&lt;/code&gt; option. This is most useful when you want to perform asynchronous or expensive operations in response to changing data.</source>
          <target state="translated">ほとんどの場合、計算されたプロパティの方が適切ですが、カスタムウォッチャーが必要になる場合もあります。そのため、Vueは、 &lt;code&gt;watch&lt;/code&gt; オプションを介してデータの変更に対応するためのより一般的な方法を提供します。これは、データの変更に応じて非同期または高価な操作を実行する場合に最も役立ちます。</target>
        </trans-unit>
        <trans-unit id="c58ceb4be486c0d3bcb8a6914f2874907486034f" translate="yes" xml:space="preserve">
          <source>While developers have traditionally relied on scanning logs in a terminal window to help determine what went wrong in a test, modern end-to-end (E2E) test frameworks allow developers to leverage tools that they are already familiar with, e.g. browser developer tools.</source>
          <target state="translated">開発者は従来、ターミナルウィンドウでログをスキャンして、テストで何がうまくいかなかったかを判断していましたが、最新のエンドツーエンド (E2E)テストフレームワークでは、ブラウザ開発者ツールなど、開発者がすでに使い慣れたツールを活用することができます。</target>
        </trans-unit>
        <trans-unit id="bd77b96c3d24d46385ee19732ac45b61f33bee8a" translate="yes" xml:space="preserve">
          <source>While end-to-end (E2E) testing on the web has gained a negative reputation for unreliable (flaky) tests and slowing down development processes, modern E2E tools have made strides forward to create more reliable, interactive, and useful tests. When choosing an E2E testing framework, the following sections provide some guidance on things to keep in mind when choosing a testing framework for your application.</source>
          <target state="translated">ウェブ上のエンドツーエンド (E2E)テストは、信頼性の低い (欠陥のある)テストや開発プロセスを遅らせるという否定的な評判を得てきましたが、最新の E2E ツールは、より信頼性の高い、インタラクティブで有用なテストを作成するために前進してきました。E2E テストフレームワークを選択する際に、以下のセクションでは、アプリケーションのためにテストフレームワークを選択する際に留意すべきことについてのガイダンスを提供します。</target>
        </trans-unit>
        <trans-unit id="8785c918b15353f580978dd18459f72bc2edbf02" translate="yes" xml:space="preserve">
          <source>While explicitly defined props are preferred for passing information to a child component, authors of component libraries can&amp;rsquo;t always foresee the contexts in which their components might be used. That&amp;rsquo;s why components can accept arbitrary attributes, which are added to the component&amp;rsquo;s root element.</source>
          <target state="translated">明示的に定義されたプロップは子コンポーネントに情報を渡すために推奨されますが、コンポーネントライブラリの作成者は、コンポーネントが使用されるコンテキストを常に予測できるとは限りません。これが、コンポーネントがコンポーネントのルート要素に追加される任意の属性を受け入れることができる理由です。</target>
        </trans-unit>
        <trans-unit id="02c06ac05b4fad90251fe1178ba3f0d2779deb1c" translate="yes" xml:space="preserve">
          <source>While templates work great for most components, it&amp;rsquo;s clear that this isn&amp;rsquo;t one of them. So let&amp;rsquo;s try rewriting it with a &lt;code&gt;render&lt;/code&gt; function:</source>
          <target state="translated">テンプレートはほとんどのコンポーネントに適していますが、これがそれらのコンポーネントの1つではないことは明らかです。それで、 &lt;code&gt;render&lt;/code&gt; 関数でそれを書き直してみましょう：</target>
        </trans-unit>
        <trans-unit id="dccd95c62bd449380bb4f7810be214fe6f2cc294" translate="yes" xml:space="preserve">
          <source>While templates work great for most components, it's clear that this isn't one of them. So let's try rewriting it with a &lt;code&gt;render()&lt;/code&gt; function:</source>
          <target state="translated">テンプレートはほとんどのコンポーネントでうまく機能しますが、これがそれらの1つではないことは明らかです。それでは、 &lt;code&gt;render()&lt;/code&gt; 関数で書き直してみましょう。</target>
        </trans-unit>
        <trans-unit id="38f53a61720d34f8deb200583fb4293a0b28f026" translate="yes" xml:space="preserve">
          <source>While there are many tools in the ecosystem, here are some common end-to-end (E2E) testing frameworks that are being used in the Vue.js ecosystem.</source>
          <target state="translated">エコシステムには多くのツールがありますが、ここではVue.jsのエコシステムで使用されている一般的なエンドツーエンド(E2E)テストフレームワークをいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="4ae4a80a732fb32a76bcecd383d1d0a7ebd43cd2" translate="yes" xml:space="preserve">
          <source>While there are many tools in the ecosystem, here are some common unit testing tools that are being used in the Vue.js ecosystem.</source>
          <target state="translated">エコシステムには多くのツールがありますが、ここではVue.jsのエコシステムでよく使われているユニットテストツールをご紹介します。</target>
        </trans-unit>
        <trans-unit id="50d958d9d37ed58a5f1f97ee679c1620d781626e" translate="yes" xml:space="preserve">
          <source>While this approach is convenient, it leads to a couple of problems. Technically, Vue 2 doesn't have a concept of an &quot;app&quot;. What we define as an app is simply a root Vue instance created via &lt;code&gt;new Vue()&lt;/code&gt;. Every root instance created from the same Vue constructor &lt;strong&gt;shares the same global configuration&lt;/strong&gt;. As a result:</source>
          <target state="translated">このアプローチは便利ですが、いくつかの問題が発生します。技術的には、Vue2には「アプリ」の概念がありません。アプリとして定義するのは、 &lt;code&gt;new Vue()&lt;/code&gt; 介して作成されたルートVueインスタンスです。同じVueコンストラクターから作成されたすべてのルートインスタンス&lt;strong&gt;は、同じグローバル構成を共有します&lt;/strong&gt;。結果として：</target>
        </trans-unit>
        <trans-unit id="26388458f8fca7cd6a63de038df2a21f485dd436" translate="yes" xml:space="preserve">
          <source>While this seems like a convenience, it requires a custom syntax that breaks the assumption of expressions inside of curly braces being &quot;just JavaScript,&quot; which has both learning and implementation costs.</source>
          <target state="translated">これは便利そうに見えますが、中括弧内の式を「ただのJavaScript」という前提を崩すカスタム構文が必要で、学習コストと実装コストの両方がかかります。</target>
        </trans-unit>
        <trans-unit id="dcaa3f23ca2ee3059b2128051891a6ae3197f8a2" translate="yes" xml:space="preserve">
          <source>While unit tests provide developers with some degree of confidence, unit and component tests are limited in their abilities to provide holistic coverage of an application when deployed to production. As a result, end-to-end (E2E) tests provide coverage on what is arguably the most important aspect of an application: what happens when users actually use your applications.</source>
          <target state="translated">ユニットテストは開発者にある程度の信頼性を提供しますが、ユニットテストとコンポーネントテストは、本番環境にデプロイされたときに、アプリケーションの全体的なカバレッジを提供する能力には限界があります。その結果、エンドツーエンド (E2E)テストは、アプリケーションの最も重要な側面である、ユーザが実際にアプリケーションを使用したときに何が起こるかをカバーしています。</target>
        </trans-unit>
        <trans-unit id="008a9bd1fd351881294a8ab7c58eff00ecd921e6" translate="yes" xml:space="preserve">
          <source>Why Composition API?</source>
          <target state="translated">なぜコンポジションAPIなのか?</target>
        </trans-unit>
        <trans-unit id="4d4c575b6d22f5470b02ebf75178499ff65c9979" translate="yes" xml:space="preserve">
          <source>Why Listeners in HTML?</source>
          <target state="translated">なぜHTMLでリスナーを使うのか?</target>
        </trans-unit>
        <trans-unit id="d05a9a10126e300cca0827aed2703aed49fcd394" translate="yes" xml:space="preserve">
          <source>Why do we need caching? Imagine we have an expensive computed property &lt;code&gt;list&lt;/code&gt;, which requires looping through a huge array and doing a lot of computations. Then we may have other computed properties that in turn depend on &lt;code&gt;list&lt;/code&gt;. Without caching, we would be executing &lt;code&gt;list&lt;/code&gt;&amp;rsquo;s getter many more times than necessary! In cases where you do not want caching, use a &lt;code&gt;method&lt;/code&gt; instead.</source>
          <target state="translated">なぜキャッシュが必要なのですか？高価な計算プロパティ &lt;code&gt;list&lt;/code&gt; があると想像してください。これには、巨大な配列をループして多くの計算を行う必要があります。次に、 &lt;code&gt;list&lt;/code&gt; 依存する他の計算されたプロパティがある場合があります。キャッシュがないと、 &lt;code&gt;list&lt;/code&gt; のゲッターを必要以上に何度も実行することになります。キャッシュが不要な場合は、代わりに &lt;code&gt;method&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="7cace55ca4b0d7fffbac7fef7ee11697b6e93db4" translate="yes" xml:space="preserve">
          <source>Why do we need caching? Imagine we have an expensive computed property &lt;strong&gt;A&lt;/strong&gt;, which requires looping through a huge Array and doing a lot of computations. Then we may have other computed properties that in turn depend on &lt;strong&gt;A&lt;/strong&gt;. Without caching, we would be executing &lt;strong&gt;A&lt;/strong&gt;&amp;rsquo;s getter many more times than necessary! In cases where you do not want caching, use a method instead.</source>
          <target state="translated">なぜキャッシュが必要なのですか？計算された高価なプロパティ&lt;strong&gt;A&lt;/strong&gt;があるとします。これには、巨大な配列をループして多くの計算を行う必要があります。次に、&lt;strong&gt;Aに&lt;/strong&gt;依存する他の計算されたプロパティがある場合があります。キャッシングがなければ、&lt;strong&gt;A&lt;/strong&gt;のゲッターは必要以上に実行されます。キャッシュが必要ない場合は、代わりにメソッドを使用してください。</target>
        </trans-unit>
        <trans-unit id="1f4becacb6433612ab9fdced5b1ce8e770411d96" translate="yes" xml:space="preserve">
          <source>Will be equivalent to:</source>
          <target state="translated">と同等のものになります。</target>
        </trans-unit>
        <trans-unit id="30e24dc765d4c7a4af0703d2af20cd8e134ee849" translate="yes" xml:space="preserve">
          <source>Will be evaluated similar to:</source>
          <target state="translated">似たような評価になります。</target>
        </trans-unit>
        <trans-unit id="f06b08a2392c0b43e3833f9f4c17e1475f8d4643" translate="yes" xml:space="preserve">
          <source>Will instead be defined with:</source>
          <target state="translated">で定義されます。</target>
        </trans-unit>
        <trans-unit id="d2b826d3f7d8e2201135c671569ea283afb245af" translate="yes" xml:space="preserve">
          <source>Will result in:</source>
          <target state="translated">結果として</target>
        </trans-unit>
        <trans-unit id="5bcd42cce76c522e00acc375bb83a386e44895e9" translate="yes" xml:space="preserve">
          <source>Will throw an error, because the &lt;code&gt;v-if&lt;/code&gt; directive will be evaluated first and the iteration variable &lt;code&gt;user&lt;/code&gt; does not exist at this moment.</source>
          <target state="translated">&lt;code&gt;v-if&lt;/code&gt; ディレクティブが最初に評価され、反復変数 &lt;code&gt;user&lt;/code&gt; が現時点では存在しないため、エラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="75b523d2bcf5fca866ffcaea5c846072e6f454e3" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;fragments#overview&quot;&gt;fragments&lt;/a&gt; support, components can potentially have more than one root node. When applied to a multi-root component, a directive will be ignored and a warning will be logged.</source>
          <target state="translated">&lt;a href=&quot;fragments#overview&quot;&gt;フラグメントの&lt;/a&gt;サポートにより、コンポーネントは複数のルートノードを持つ可能性があります。マルチルートコンポーネントに適用すると、ディレクティブは無視され、警告がログに記録されます。</target>
        </trans-unit>
        <trans-unit id="2972362a724a19189b0c528b9c31cb4d552d316e" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;migration/fragments#overview&quot;&gt;fragments&lt;/a&gt; support, components can potentially have more than one root nodes. When applied to a multi-root component, directive will be ignored and the warning will be thrown.</source>
          <target state="translated">&lt;a href=&quot;migration/fragments#overview&quot;&gt;フラグメントの&lt;/a&gt;サポートにより、コンポーネントは複数のルートノードを持つ可能性があります。マルチルートコンポーネントに適用すると、ディレクティブは無視され、警告がスローされます。</target>
        </trans-unit>
        <trans-unit id="9f3c68936845bcadd633acd3c5e92f54a35dd57a" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&amp;lt;template v-for&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;lt;template v-for&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="776dc7dc9ff80fd08e48b9caa4c38e270742c451" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;.vue&lt;/code&gt; components, we&amp;rsquo;re entering the realm of advanced JavaScript applications. That means learning to use a few additional tools if you haven&amp;rsquo;t already:</source>
          <target state="translated">&lt;code&gt;.vue&lt;/code&gt; 部品、我々は高度なJavaScriptアプリケーションのレルムを入力しています。つまり、まだ行っていない場合は、いくつかの追加ツールを使用する方法を学びます。</target>
        </trans-unit>
        <trans-unit id="e3840f18f3809fb17a5fc20b99dd0f910da3163d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;.vue&lt;/code&gt; components, we're entering the realm of advanced JavaScript applications. That means learning to use a few additional tools if you haven't already:</source>
          <target state="translated">&lt;code&gt;.vue&lt;/code&gt; 部品、我々は高度なJavaScriptアプリケーションのレルムを入力しています。つまり、まだ行っていない場合は、いくつかの追加ツールの使用方法を学ぶことを意味します。</target>
        </trans-unit>
        <trans-unit id="84703fc2f9027470467014d24c7b02320fb62bd8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;inheritAttrs: false&lt;/code&gt; and &lt;code&gt;$attrs&lt;/code&gt;, you can manually decide which element you want to forward attributes to, which is often desirable for &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;base components&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;inheritAttrs: false&lt;/code&gt; と &lt;code&gt;$attrs&lt;/code&gt; は、手動であなたが頻繁に望ましい前方の属性に、対象となる要素を決定することができ&lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;、ベースコンポーネント&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="4e6cb97e1c707f6c266a663d8286562e9030cd23" translate="yes" xml:space="preserve">
          <source>With Build Tools</source>
          <target state="translated">ビルドツールを使って</target>
        </trans-unit>
        <trans-unit id="e1e4b2e3dbdbf822ef565f7ce5070aedda94bed6" translate="yes" xml:space="preserve">
          <source>With Components</source>
          <target state="translated">コンポーネントと</target>
        </trans-unit>
        <trans-unit id="e94afd24abb64d9b90f7248caba76323b7bd6df5" translate="yes" xml:space="preserve">
          <source>With Composition API:</source>
          <target state="translated">コンポジションAPI付き。</target>
        </trans-unit>
        <trans-unit id="0e14b5de4bdbf06aaa5c7d60756f18b22f131973" translate="yes" xml:space="preserve">
          <source>With ES2015 Symbols, function &lt;code&gt;provide&lt;/code&gt; and object &lt;code&gt;inject&lt;/code&gt;:</source>
          <target state="translated">ES2015のシンボルでは、関数の &lt;code&gt;provide&lt;/code&gt; とオブジェクトの &lt;code&gt;inject&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="91634f01017a54aaae34da9aa5791b8ed1ace732" translate="yes" xml:space="preserve">
          <source>With MobX</source>
          <target state="translated">MobXを使って</target>
        </trans-unit>
        <trans-unit id="a4c0ad0fedf665b5addf50ef4ee3e843c9bae79a" translate="yes" xml:space="preserve">
          <source>With Object-based syntax, you can use following options:</source>
          <target state="translated">オブジェクトベースの構文では、以下のオプションを使用することができます。</target>
        </trans-unit>
        <trans-unit id="0ddaa6dc6d7bbbc58f451bb92e742747f8a0ad5d" translate="yes" xml:space="preserve">
          <source>With Options API:</source>
          <target state="translated">オプションAPIを使用しています。</target>
        </trans-unit>
        <trans-unit id="1b0907e78d48e052b47acae86f3368c0fee26b2f" translate="yes" xml:space="preserve">
          <source>With PascalCase</source>
          <target state="translated">パスカルケースを使って</target>
        </trans-unit>
        <trans-unit id="8e3c02906d7a5cad13118eea9109a6e2b7c11fa1" translate="yes" xml:space="preserve">
          <source>With Vue 3, the API for two-way data binding is being standardized in order to reduce confusion and to allow developers more flexibility with the &lt;code&gt;v-model&lt;/code&gt; directive.</source>
          <target state="translated">Vue 3では、混乱を減らし、開発者が &lt;code&gt;v-model&lt;/code&gt; ディレクティブをより柔軟に使用できるようにするために、双方向データバインディングのAPIが標準化されています。</target>
        </trans-unit>
        <trans-unit id="7c6e8d5c594ae0eeedbf57f7bb713ef9a3488318" translate="yes" xml:space="preserve">
          <source>With a Bundler</source>
          <target state="translated">バンドラ付き</target>
        </trans-unit>
        <trans-unit id="78c796447490b9562e329b4eb4f3c1a45c3a13ab" translate="yes" xml:space="preserve">
          <source>With all these changes, the component and directive we have at the beginning of the guide will be rewritten into something like this:</source>
          <target state="translated">これらの変更に伴い、ガイドの最初にあるコンポーネントとディレクティブは、次のようなものに書き換えられます。</target>
        </trans-unit>
        <trans-unit id="b1f67259032ce5e6a9b51cd6c8ee262fb5c3605c" translate="yes" xml:space="preserve">
          <source>With global tree-shaking, the user only &amp;ldquo;pay&amp;rdquo; for the features they actually use. Even better, knowing that optional features won't increase the bundle size for applications not using them, framework size has become much less a concern for additional core features in the future, if at all.</source>
          <target state="translated">グローバルツリーシェーキングでは、ユーザーは実際に使用する機能に対してのみ「支払い」を行います。さらに良いことに、オプション機能がそれらを使用しないアプリケーションのバンドルサイズを増加させないことを知っているので、フレームワークサイズは、将来の追加のコア機能に対する懸念がほとんどなくなっています。</target>
        </trans-unit>
        <trans-unit id="7b6729eb0e977f70c132c422c576ca3d368d86fc" translate="yes" xml:space="preserve">
          <source>With kebab-case</source>
          <target state="translated">ケバブケース付き</target>
        </trans-unit>
        <trans-unit id="5262fdf2404668ac87ace7bc5320c88ae3fec32d" translate="yes" xml:space="preserve">
          <source>With npm:</source>
          <target state="translated">npmで。</target>
        </trans-unit>
        <trans-unit id="146754717a175d1f89fc3628f35dddfee5647668" translate="yes" xml:space="preserve">
          <source>With one attribute addition, we&amp;rsquo;ve fixed that original transition without having to add any special styling.</source>
          <target state="translated">属性を1つ追加することで、特別なスタイルを追加することなく、元の遷移を修正しました。</target>
        </trans-unit>
        <trans-unit id="689393a6c1bd0377fbe965e3cad93231017b2f2b" translate="yes" xml:space="preserve">
          <source>With one attribute addition, we've fixed that original transition without having to add any special styling.</source>
          <target state="translated">1つの属性を追加することで、特別なスタイリングを追加することなく元のトランジションを修正しました。</target>
        </trans-unit>
        <trans-unit id="36361bcb7732d5e11757dbbeec045c06c4c7e7ac" translate="yes" xml:space="preserve">
          <source>With render function:</source>
          <target state="translated">レンダー機能付き。</target>
        </trans-unit>
        <trans-unit id="726c2d492949be251e96d2fc6891fcc11ab60be3" translate="yes" xml:space="preserve">
          <source>With that said, it&amp;rsquo;s inevitable that the comparison would appear biased towards Vue to some React users, as many of the subjects explored are to some extent subjective. We acknowledge the existence of varying technical taste, and this comparison primarily aims to outline the reasons why Vue could potentially be a better fit if your preferences happen to coincide with ours.</source>
          <target state="translated">そうは言っても、調査された主題の多くはある程度主観的であるため、一部のReactユーザーにとっては比較がVueに偏っているように見えることは避けられません。私たちはさまざまな技術的な好みの存在を認めており、この比較は主に、あなたの好みが偶然私たちのものと一致した場合に、Vueがよりよく適合する理由を概説することを目的としています。</target>
        </trans-unit>
        <trans-unit id="74293b552f92b191f072c0da0451d95393b6de4a" translate="yes" xml:space="preserve">
          <source>With the behavior change of &lt;code&gt;is&lt;/code&gt;, we introduce a new directive &lt;code&gt;v-is&lt;/code&gt; for working around these cases:</source>
          <target state="translated">&lt;code&gt;is&lt;/code&gt; の動作変更に伴い、これらのケースを回避するための新しいディレクティブ &lt;code&gt;v-is&lt;/code&gt; を導入します。</target>
        </trans-unit>
        <trans-unit id="bb0003a3096e960ec10c4bccd66adf7dbf8bea11" translate="yes" xml:space="preserve">
          <source>With the new transition system, you can now &lt;a href=&quot;transitions#Reusable-Transitions&quot;&gt;use components for reusable transitions&lt;/a&gt;.</source>
          <target state="translated">新しい移行システムでは、&lt;a href=&quot;transitions#Reusable-Transitions&quot;&gt;再利用可能な移行用のコンポーネントを使用&lt;/a&gt;できるようになりました。</target>
        </trans-unit>
        <trans-unit id="3828ac5cca844bde7e12cdc97494a2e145077de0" translate="yes" xml:space="preserve">
          <source>With the second parameter, we can pass root props to the application:</source>
          <target state="translated">2番目のパラメータで、アプリケーションにルートプロップスを渡すことができます。</target>
        </trans-unit>
        <trans-unit id="017d2800ca9c44c02e89db888766c57a4c894655" translate="yes" xml:space="preserve">
          <source>With the template:</source>
          <target state="translated">テンプレートを使って</target>
        </trans-unit>
        <trans-unit id="3d5db4b3ecbbcef145192161b4e8a9adf72f34af" translate="yes" xml:space="preserve">
          <source>With this change, provided the module bundler supports tree-shaking, global APIs that are not used in a Vue application will be eliminated from the final bundle, resulting in an optimal file size.</source>
          <target state="translated">この変更により、モジュール バンドルがツリーシェイクをサポートしている場合、Vue アプリケーションで使用されないグローバル API は最終的なバンドルから削除され、最適なファイル サイズになります。</target>
        </trans-unit>
        <trans-unit id="039e52a50855f92c82cc8a84a142a54cd6c17f7d" translate="yes" xml:space="preserve">
          <source>With this knowledge, we can now finish the component we started:</source>
          <target state="translated">この知識があれば、始めたコンポーネントを完成させることができます。</target>
        </trans-unit>
        <trans-unit id="c0b51b14ed767e15b6133cfad9870cba3b70f4a4" translate="yes" xml:space="preserve">
          <source>With this new configuration, our &lt;code&gt;data-status&lt;/code&gt; attribute will be applied to our &lt;code&gt;input&lt;/code&gt; element!</source>
          <target state="translated">この新しい構成では、 &lt;code&gt;data-status&lt;/code&gt; 属性が &lt;code&gt;input&lt;/code&gt; 要素に適用されます。</target>
        </trans-unit>
        <trans-unit id="d064e70d3aeb0eac7d3ba972b7156b0acdc5ed48" translate="yes" xml:space="preserve">
          <source>With those changes in place, we've just moved the whole first logical concern into a single place. We can now do the same with the second concern &amp;ndash; filtering based on &lt;code&gt;searchQuery&lt;/code&gt;, this time with a computed property.</source>
          <target state="translated">これらの変更が行われたので、最初の論理的な懸念事項全体を1つの場所に移動しました。これで、2番目の懸念事項である &lt;code&gt;searchQuery&lt;/code&gt; に基づくフィルタリングでも同じことができます。今回は、計算されたプロパティを使用します。</target>
        </trans-unit>
        <trans-unit id="a89cca8416101fd32770a454f8d5273ad1bc7716" translate="yes" xml:space="preserve">
          <source>Within child components, we can use any combination of transition strategies that have been covered on this page, along with those offered by Vue&amp;rsquo;s &lt;a href=&quot;transitions&quot;&gt;built-in transition system&lt;/a&gt;. Together, there are very few limits to what can be accomplished.</source>
          <target state="translated">子コンポーネント内では、Vueの&lt;a href=&quot;transitions&quot;&gt;組み込み遷移システム&lt;/a&gt;によって提供されるものと一緒に、このページで説明されている遷移戦略の任意の組み合わせを使用できます。同時に、達成できることには非常に少ない制限があります。</target>
        </trans-unit>
        <trans-unit id="b46b3ddd55e7832cce6f8044474d8ac05b815614" translate="yes" xml:space="preserve">
          <source>Without Build Tools</source>
          <target state="translated">ビルドツールなし</target>
        </trans-unit>
        <trans-unit id="f2a1442937e9312fb88d30abe594d3832e40b6c8" translate="yes" xml:space="preserve">
          <source>Woah - this is a super long page! Does that mean 2.0 is completely different, I&amp;rsquo;ll have to learn the basics all over again, and migrating will be practically impossible?</source>
          <target state="translated">うわー-これは非常に長いページです！それは2.0が完全に異なるということですか、私は基本を何度も学ぶ必要があり、移行は実質的に不可能でしょうか？</target>
        </trans-unit>
        <trans-unit id="c9e02cb643a613f1c79faab9079d2f3e58edae60" translate="yes" xml:space="preserve">
          <source>Working with reactivity</source>
          <target state="translated">反応性を利用した作業</target>
        </trans-unit>
        <trans-unit id="3413e9fc86a733fea321b8d4f5dce2cd96c7c946" translate="yes" xml:space="preserve">
          <source>Wrapping values inside an object might seem unnecessary but is required to keep the behavior unified across different data types in JavaScript. That&amp;rsquo;s because in JavaScript, primitive types like &lt;code&gt;Number&lt;/code&gt; or &lt;code&gt;String&lt;/code&gt; are passed by value, not by reference:</source>
          <target state="translated">オブジェクト内で値をラップすることは不要に思えるかもしれませんが、JavaScriptのさまざまなデータ型間で動作を統一するために必要です。これは、JavaScriptでは、 &lt;code&gt;Number&lt;/code&gt; や &lt;code&gt;String&lt;/code&gt; などのプリミティブ型が参照ではなく値で渡されるためです。</target>
        </trans-unit>
        <trans-unit id="5357865535aa2a476144e9beb3464ba1cbdbcf27" translate="yes" xml:space="preserve">
          <source>Writing &amp;amp; Grammar</source>
          <target state="translated">ライティングと文法</target>
        </trans-unit>
        <trans-unit id="6b9c28b71ec2be9f31844a95d25a8e022dbe663f" translate="yes" xml:space="preserve">
          <source>Writing Testable Components</source>
          <target state="translated">テスト可能なコンポーネントの記述</target>
        </trans-unit>
        <trans-unit id="510a261ec2843f68a4816e4735bf0f01c466c291" translate="yes" xml:space="preserve">
          <source>Writing a Plugin</source>
          <target state="translated">プラグインを書く</target>
        </trans-unit>
        <trans-unit id="4835d6c16769322c715842b97457649636213963" translate="yes" xml:space="preserve">
          <source>Writing documentation is an exercise in empathy. We're not describing an objective reality - the source code already does that. Our job is to help shape the relationship between users and the Vue ecosystem. This ever-evolving guide provides some rules and recommendations on how to do that consistently within the Vue ecosystem.</source>
          <target state="translated">ドキュメントを書くことは共感の練習です。私たちは客観的な現実を記述しているわけではありません。私たちの仕事は、ユーザーと Vue エコシステムとの関係を形成するための手助けをすることです。この進化し続けるガイドでは、Vue エコシステム内で一貫してドキュメントを作成する方法について、いくつかのルールと推奨事項を紹介しています。</target>
        </trans-unit>
        <trans-unit id="90541f524186259ca7b45913e319ab878043cca6" translate="yes" xml:space="preserve">
          <source>X-Templates</source>
          <target state="translated">X-Templates</target>
        </trans-unit>
        <trans-unit id="3da53c899f2de058d0a78dc035fc82fa4168e261" translate="yes" xml:space="preserve">
          <source>Yes! We are ready for translation!</source>
          <target state="translated">はい!翻訳の準備ができました!</target>
        </trans-unit>
        <trans-unit id="c56f5c342be3541ee986cb873bbad4da1de25564" translate="yes" xml:space="preserve">
          <source>Yes, even transitions in Vue are data-driven! The most basic example of a dynamic transition binds the &lt;code&gt;name&lt;/code&gt; attribute to a dynamic property.</source>
          <target state="translated">はい、Vueの遷移でさえデータ駆動型です！動的遷移の最も基本的な例は、 &lt;code&gt;name&lt;/code&gt; 属性を動的プロパティにバインドします。</target>
        </trans-unit>
        <trans-unit id="9c7930e65cfb28d01dc27c348442febb4d224313" translate="yes" xml:space="preserve">
          <source>You actually don&amp;rsquo;t need to for debugging anymore, as Vue will nicely format output for you automatically, whether it&amp;rsquo;s a string, number, array, or plain object. If you want the exact same functionality as JavaScript&amp;rsquo;s &lt;code&gt;JSON.stringify&lt;/code&gt; though, then you can use that in a method or computed property.</source>
          <target state="translated">文字列、数値、配列、プレーンオブジェクトのいずれであっても、Vueが出力を自動的に適切にフォーマットするので、実際にデバッグする必要はありません。JavaScriptの &lt;code&gt;JSON.stringify&lt;/code&gt; とまったく同じ機能が必要な場合は、メソッドまたは計算プロパティで使用できます。</target>
        </trans-unit>
        <trans-unit id="e119e2f6092103e55af9dce5ad23bb6ea3fc658c" translate="yes" xml:space="preserve">
          <source>You are forced to be more explicit, by giving your coerced value a name that differentiates it from the value passed in the prop.</source>
          <target state="translated">強制された値にプロップで渡された値とは異なる名前をつけることで、より明示的にすることを余儀なくされています。</target>
        </trans-unit>
        <trans-unit id="259bd96ca0effe183387e9e5f024f56b5205a591" translate="yes" xml:space="preserve">
          <source>You can access a component's lifecycle hook by prefixing the lifecycle hook with &quot;on&quot;.</source>
          <target state="translated">ライフサイクルフックの前に &quot;on &quot;を付けることで、コンポーネントのライフサイクルフックにアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="33c426dccdf7bb9d113711cec6e8b178109d4c59" translate="yes" xml:space="preserve">
          <source>You can access static slot contents as Arrays of VNodes from &lt;a href=&quot;../api/index#vm-slots&quot;&gt;&lt;code&gt;this.$slots&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">あなたはからのvnodeの配列として静的スロットの内容にアクセスすることができます&lt;a href=&quot;../api/index#vm-slots&quot;&gt; &lt;code&gt;this.$slots&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="82c01f592d841d8e339fea13c397b0df69d3de97" translate="yes" xml:space="preserve">
          <source>You can also &lt;a href=&quot;../api/index#keyCodes&quot;&gt;define custom key modifier aliases&lt;/a&gt; via the global &lt;code&gt;config.keyCodes&lt;/code&gt; object:</source>
          <target state="translated">グローバル &lt;code&gt;config.keyCodes&lt;/code&gt; オブジェクトを介して&lt;a href=&quot;../api/index#keyCodes&quot;&gt;カスタムキー修飾子のエイリアス&lt;/a&gt;を定義することもできます。</target>
        </trans-unit>
        <trans-unit id="1813d70fbaf8bba2c2a5a3785639129921bc5052" translate="yes" xml:space="preserve">
          <source>You can also apply a mixin globally for a Vue application:</source>
          <target state="translated">また、Vue アプリケーションに対してグローバルにミックスインを適用することもできます。</target>
        </trans-unit>
        <trans-unit id="622e98e0d6c37bfb7ab2f18e227b46cbc3583f37" translate="yes" xml:space="preserve">
          <source>You can also apply a mixin globally. Use with caution! Once you apply a mixin globally, it will affect &lt;strong&gt;every&lt;/strong&gt; Vue instance created afterwards. When used properly, this can be used to inject processing logic for custom options:</source>
          <target state="translated">ミックスインをグローバルに適用することもできます。注意して使用してください！ミックスインをグローバルに適用すると、後で作成さ&lt;strong&gt;れるすべての&lt;/strong&gt; Vueインスタンスに影響します。これを適切に使用すると、カスタムオプションの処理ロジックを挿入するために使用できます。</target>
        </trans-unit>
        <trans-unit id="9a8823272620bc63ace5da9fd0bc048769cb40d6" translate="yes" xml:space="preserve">
          <source>You can also declare additional global properties and component options:</source>
          <target state="translated">また、追加のグローバルプロパティやコンポーネントオプションを宣言することもできます。</target>
        </trans-unit>
        <trans-unit id="adecb9f768a677f404c477ccc6a1e9688aad9512" translate="yes" xml:space="preserve">
          <source>You can also define JavaScript hooks in attributes:</source>
          <target state="translated">また、JavaScriptのフックを属性で定義することもできます。</target>
        </trans-unit>
        <trans-unit id="beebaf9986e9097a2444f204aa81ae1c568b7cbd" translate="yes" xml:space="preserve">
          <source>You can also give the input an accessible name with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-label_attribute&quot;&gt;&lt;code&gt;aria-label&lt;/code&gt; (opens new window)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-label_attribute&quot;&gt; &lt;code&gt;aria-label&lt;/code&gt; （新しいウィンドウを開きます）&lt;/a&gt;を使用して、入力にアクセス可能な名前を付けることもできます。</target>
        </trans-unit>
        <trans-unit id="503a3e28cf5a8489e2b8f7a242ab27389b2b6691" translate="yes" xml:space="preserve">
          <source>You can also perform one-time interpolations that do not update on data change by using the &lt;a href=&quot;../api/directives#v-once&quot;&gt;v-once directive&lt;/a&gt;, but keep in mind this will also affect any other bindings on the same node:</source>
          <target state="translated">&lt;a href=&quot;../api/directives#v-once&quot;&gt;v-onceディレクティブ&lt;/a&gt;を使用して、データの変更時に更新されない1回限りの補間を実行することもできますが、これは同じノード上の他のバインディングにも影響することに注意してください。</target>
        </trans-unit>
        <trans-unit id="a59db4f1c8c537e3299ed286ab9edc0d67d61747" translate="yes" xml:space="preserve">
          <source>You can also perform one-time interpolations that do not update on data change by using the &lt;a href=&quot;../api/index#v-once&quot;&gt;v-once directive&lt;/a&gt;, but keep in mind this will also affect any other bindings on the same node:</source>
          <target state="translated">&lt;a href=&quot;../api/index#v-once&quot;&gt;v-onceディレクティブ&lt;/a&gt;を使用して、データ変更時に更新されない1回限りの補間を実行することもできますが、これは同じノードの他のバインディングにも影響することに注意してください。</target>
        </trans-unit>
        <trans-unit id="e11efe63fd06b61dcfcaba4eeda09c76401a3855" translate="yes" xml:space="preserve">
          <source>You can also provide a second argument for the property&amp;rsquo;s name (a.k.a. key):</source>
          <target state="translated">プロパティの名前（キー）の2番目の引数を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="7e590ee53b15356b15c6804307c06fa95680eb6f" translate="yes" xml:space="preserve">
          <source>You can also provide a second argument for the property's name (a.k.a. key):</source>
          <target state="translated">また、プロパティの名前 (別名キー)に第二引数を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="0525e813968758780c48d074f432233acab02c34" translate="yes" xml:space="preserve">
          <source>You can also return a &lt;code&gt;Promise&lt;/code&gt; in the factory function, so with Webpack 2 and ES2015 syntax you can do:</source>
          <target state="translated">ファクトリ関数で &lt;code&gt;Promise&lt;/code&gt; を返すこともできるため、Webpack 2とES2015の構文を使用して次のことができます。</target>
        </trans-unit>
        <trans-unit id="2f9cab99bb92ad04f5fd1ef133a533bca320077d" translate="yes" xml:space="preserve">
          <source>You can also return a &lt;code&gt;Promise&lt;/code&gt; in the factory function, so with Webpack 2 or later and ES2015 syntax you can do:</source>
          <target state="translated">ファクトリ関数で &lt;code&gt;Promise&lt;/code&gt; を返すこともできるため、Webpack2以降とES2015構文を使用すると次のことができます。</target>
        </trans-unit>
        <trans-unit id="571c9a02435c95b783b2181af7abafb404a7a321" translate="yes" xml:space="preserve">
          <source>You can also specify custom transition classes by providing the following attributes:</source>
          <target state="translated">また、以下の属性を指定することで、カスタムトランジションクラスを指定することもできます。</target>
        </trans-unit>
        <trans-unit id="123d964ca13d8922b3a59e09ea5d0738f8870247" translate="yes" xml:space="preserve">
          <source>You can also specify separate values for enter and leave durations:</source>
          <target state="translated">また、入室時間と退室時間に別々の値を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="b708002bf5e4f269767c152c0103659f003ed958" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;defineAsyncComponent&lt;/code&gt; when &lt;a href=&quot;component-registration#local-registration&quot;&gt;registering a component locally&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;component-registration#local-registration&quot;&gt;コンポーネントをローカル&lt;/a&gt;に登録するときに &lt;code&gt;defineAsyncComponent&lt;/code&gt; を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="29859f4274a48a2f62e987c9e06a4e3094c11f59" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;of&lt;/code&gt; as the delimiter instead of &lt;code&gt;in&lt;/code&gt;, so that it is closer to JavaScript&amp;rsquo;s syntax for iterators:</source>
          <target state="translated">また、使用することができる &lt;code&gt;of&lt;/code&gt; 区切り文字としての代わり &lt;code&gt;in&lt;/code&gt; 、それはイテレータのためのJavaScriptの構文に近いように、：</target>
        </trans-unit>
        <trans-unit id="56680b86213ebfab218348e1f259349ba40ffdea" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;of&lt;/code&gt; as the delimiter instead of &lt;code&gt;in&lt;/code&gt;, so that it is closer to JavaScript's syntax for iterators:</source>
          <target state="translated">また、使用することができる &lt;code&gt;of&lt;/code&gt; 区切り文字としての代わり &lt;code&gt;in&lt;/code&gt; 、それはイテレータのためのJavaScriptの構文に近いように、：</target>
        </trans-unit>
        <trans-unit id="7003d01ea6e5751b64f6c501e1367eadc0f20feb" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;v-for&lt;/code&gt; to iterate through the properties of an object.</source>
          <target state="translated">&lt;code&gt;v-for&lt;/code&gt; を使用して、オブジェクトのプロパティを反復処理することもできます。</target>
        </trans-unit>
        <trans-unit id="2874f410c245555c54bfa970bdbf6a97ed6f8241" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;../api/index#vm-set&quot;&gt;&lt;code&gt;vm.$set&lt;/code&gt;&lt;/a&gt; instance method, which is an alias for the global &lt;code&gt;Vue.set&lt;/code&gt;:</source>
          <target state="translated">また、使用することができます&lt;a href=&quot;../api/index#vm-set&quot;&gt; &lt;code&gt;vm.$set&lt;/code&gt; &lt;/a&gt;世界の別名であるインスタンスメソッド、 &lt;code&gt;Vue.set&lt;/code&gt; を：</target>
        </trans-unit>
        <trans-unit id="caa2f5e4a5e7cb8569f06fc887bf75bbeb1e905a" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;https://vuejs.org/v2/api/#vm-set&quot;&gt;&lt;code&gt;vm.$set&lt;/code&gt; (opens new window)&lt;/a&gt; instance method, which is an alias for the global &lt;code&gt;Vue.set&lt;/code&gt;:</source>
          <target state="translated">グローバル &lt;code&gt;Vue.set&lt;/code&gt; のエイリアスである&lt;a href=&quot;https://vuejs.org/v2/api/#vm-set&quot;&gt; &lt;code&gt;vm.$set&lt;/code&gt; （新しいウィンドウを開く）&lt;/a&gt;インスタンスメソッドを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="7016af3cddf281827fcb1fb635902cd99d67f65c" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;is&lt;/code&gt; attribute to create regular HTML elements.</source>
          <target state="translated">&lt;code&gt;is&lt;/code&gt; 属性を使用して、通常のHTML要素を作成することもできます。</target>
        </trans-unit>
        <trans-unit id="248865e59fe69c22e3616cb9bf4e8973863a8b12" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;vm.$set&lt;/code&gt; instance method, which is an alias for the global &lt;code&gt;Vue.set&lt;/code&gt;:</source>
          <target state="translated">また、使用することができます &lt;code&gt;vm.$set&lt;/code&gt; 世界の別名であるインスタンスメソッド、 &lt;code&gt;Vue.set&lt;/code&gt; を：</target>
        </trans-unit>
        <trans-unit id="1ae0ee1e212b211b93a0c32174c255bb0860a240" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;vm.$set&lt;/code&gt; instance method, which is an alias to the global &lt;code&gt;Vue.set&lt;/code&gt;:</source>
          <target state="translated">また、使用することができます &lt;code&gt;vm.$set&lt;/code&gt; 世界的に別名であるインスタンスメソッド、 &lt;code&gt;Vue.set&lt;/code&gt; を：</target>
        </trans-unit>
        <trans-unit id="9fcb1d8476b09ce2de67cd75aeb50a678e90199d" translate="yes" xml:space="preserve">
          <source>You can assert its render output with different props using the &lt;code&gt;propsData&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;propsData&lt;/code&gt; オプションを使用して、さまざまな小道具でレンダー出力を表明できます。</target>
        </trans-unit>
        <trans-unit id="a1723b0ed33c8953b91ffd8fc42e598875ee5aa7" translate="yes" xml:space="preserve">
          <source>You can bind as many attributes to the &lt;code&gt;slot&lt;/code&gt; as you need:</source>
          <target state="translated">必要な数の属性を &lt;code&gt;slot&lt;/code&gt; バインドできます。</target>
        </trans-unit>
        <trans-unit id="0e9450a9423cc08d4d6f86fddb51f97f1895339a" translate="yes" xml:space="preserve">
          <source>You can browse the full application API in the &lt;a href=&quot;../api/application-api&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../api/application-api&quot;&gt;APIリファレンス&lt;/a&gt;で完全なアプリケーションAPIを参照できます。</target>
        </trans-unit>
        <trans-unit id="3ff5ae9be823fef3066f1625fd66ddc473d6f7bd" translate="yes" xml:space="preserve">
          <source>You can browse the source of the NPM package at &lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/&quot;&gt;cdn.jsdelivr.net/npm/vue&lt;/a&gt;.</source>
          <target state="translated">NPMパッケージのソースは&lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/&quot;&gt;cdn.jsdelivr.net/npm/vue&lt;/a&gt;で参照できます。</target>
        </trans-unit>
        <trans-unit id="3a50584cf2f28b29d5933a7806dfd6c8fe93a173" translate="yes" xml:space="preserve">
          <source>You can chain other methods after &lt;code&gt;createApp&lt;/code&gt;, they can be found in &lt;a href=&quot;application-api&quot;&gt;Application API&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;createApp&lt;/code&gt; の後に他のメソッドをチェーンすることができます。それらは&lt;a href=&quot;application-api&quot;&gt;ApplicationAPIにあります。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a108d1490b085325e471f3c57d3e9dc0f3ae2bc3" translate="yes" xml:space="preserve">
          <source>You can change &lt;code&gt;seen&lt;/code&gt; from &lt;code&gt;true&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; in the sandbox below to check the effect:</source>
          <target state="translated">あなたは変更することができます &lt;code&gt;seen&lt;/code&gt; から &lt;code&gt;true&lt;/code&gt; の &lt;code&gt;false&lt;/code&gt; 効果を確認するために、次のサンドボックスで：</target>
        </trans-unit>
        <trans-unit id="bfb59a77a247c2d91532f11b2a60d478be4cab66" translate="yes" xml:space="preserve">
          <source>You can check &lt;code&gt;&amp;lt;teleport&amp;gt;&lt;/code&gt; component options in the &lt;a href=&quot;../api/built-in-components#teleport&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../api/built-in-components#teleport&quot;&gt;APIリファレンス&lt;/a&gt;で &lt;code&gt;&amp;lt;teleport&amp;gt;&lt;/code&gt; コンポーネントオプションを確認できます。</target>
        </trans-unit>
        <trans-unit id="48aa82a368ad205d3da3994cb186cdc0a22d46d8" translate="yes" xml:space="preserve">
          <source>You can check the arguments passed into these hooks (i.e. &lt;code&gt;el&lt;/code&gt;, &lt;code&gt;binding&lt;/code&gt;, &lt;code&gt;vnode&lt;/code&gt;, and &lt;code&gt;prevVnode&lt;/code&gt;) in &lt;a href=&quot;../api/application-api#directive&quot;&gt;Custom Directive API&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../api/application-api#directive&quot;&gt;カスタムディレクティブAPI&lt;/a&gt;で、これらのフックに渡された引数（つまり、 &lt;code&gt;el&lt;/code&gt; 、 &lt;code&gt;binding&lt;/code&gt; 、 &lt;code&gt;vnode&lt;/code&gt; 、および &lt;code&gt;prevVnode&lt;/code&gt; ）を確認できます。</target>
        </trans-unit>
        <trans-unit id="7a321e28dae8c3d2b4ba9a95524f5a758d218685" translate="yes" xml:space="preserve">
          <source>You can check the list of available options in the &lt;a href=&quot;../api/global-api#arguments-4&quot;&gt;API Reference&lt;/a&gt;</source>
          <target state="translated">利用可能なオプションのリストは、&lt;a href=&quot;../api/global-api#arguments-4&quot;&gt;APIリファレンス&lt;/a&gt;で確認できます。</target>
        </trans-unit>
        <trans-unit id="498c9c8804cc7d12217ea3d9f3524d82346ca9db" translate="yes" xml:space="preserve">
          <source>You can data-bind to computed properties in templates just like a normal property. Vue is aware that &lt;code&gt;vm.publishedBooksMessage&lt;/code&gt; depends on &lt;code&gt;vm.author.books&lt;/code&gt;, so it will update any bindings that depend on &lt;code&gt;vm.publishedBooksMessage&lt;/code&gt; when &lt;code&gt;vm.author.books&lt;/code&gt; changes. And the best part is that we've created this dependency relationship declaratively: the computed getter function has no side effects, which makes it easier to test and understand.</source>
          <target state="translated">通常のプロパティと同じように、テンプレート内の計算されたプロパティにデータバインドできます。Vueがあることを認識している &lt;code&gt;vm.publishedBooksMessage&lt;/code&gt; が依存する &lt;code&gt;vm.author.books&lt;/code&gt; 、それが依存するすべてのバインディング更新します &lt;code&gt;vm.publishedBooksMessage&lt;/code&gt; &lt;code&gt;vm.author.books&lt;/code&gt; の変更を。そして最良の部分は、この依存関係を宣言的に作成したことです。計算されたゲッター関数には副作用がないため、テストと理解が容易になります。</target>
        </trans-unit>
        <trans-unit id="167a0aedab0a55ff7ffc58babd47e8de07340c0a" translate="yes" xml:space="preserve">
          <source>You can data-bind to computed properties in templates just like a normal property. Vue is aware that &lt;code&gt;vm.reversedMessage&lt;/code&gt; depends on &lt;code&gt;vm.message&lt;/code&gt;, so it will update any bindings that depend on &lt;code&gt;vm.reversedMessage&lt;/code&gt; when &lt;code&gt;vm.message&lt;/code&gt; changes. And the best part is that we&amp;rsquo;ve created this dependency relationship declaratively: the computed getter function has no side effects, which makes it easier to test and understand.</source>
          <target state="translated">通常のプロパティと同じように、テンプレートの計算されたプロパティにデータバインドできます。Vueがあることを認識している &lt;code&gt;vm.reversedMessage&lt;/code&gt; が依存する &lt;code&gt;vm.message&lt;/code&gt; それが依存するすべてのバインディング更新しますので、 &lt;code&gt;vm.reversedMessage&lt;/code&gt; とき &lt;code&gt;vm.message&lt;/code&gt; の変更を。そして最も良い部分は、この依存関係を宣言的に作成したことです。計算されたゲッター関数には副作用がなく、テストと理解が容易になります。</target>
        </trans-unit>
        <trans-unit id="1044eededcd74e76a9fea5a18966c11b17ea2990" translate="yes" xml:space="preserve">
          <source>You can define local filters in a component&amp;rsquo;s options:</source>
          <target state="translated">コンポーネントのオプションでローカルフィルターを定義できます。</target>
        </trans-unit>
        <trans-unit id="7e0ba3946572236040373d70df47614040a79eb8" translate="yes" xml:space="preserve">
          <source>You can definitely include these connector words in component names if you&amp;rsquo;d like, but the order is still important.</source>
          <target state="translated">必要に応じて、これらのコネクタワードをコンポーネント名に含めることはできますが、順序は依然として重要です。</target>
        </trans-unit>
        <trans-unit id="f39a90801437ef44d3dae3a0d0e800d9fa37f7c2" translate="yes" xml:space="preserve">
          <source>You can definitely include these connector words in component names if you'd like, but the order is still important.</source>
          <target state="translated">ご希望であれば、これらのコネクタの単語をコンポーネント名に含めることができますが、順序はやはり重要です。</target>
        </trans-unit>
        <trans-unit id="1c022f147799d0182c220604e3362863fce8a99c" translate="yes" xml:space="preserve">
          <source>You can directly use &lt;code&gt;v-for&lt;/code&gt; on a custom component, like any normal element:</source>
          <target state="translated">通常の要素と同様に、カスタムコンポーネントで &lt;code&gt;v-for&lt;/code&gt; を直接使用できます。</target>
        </trans-unit>
        <trans-unit id="a0f496ff2b9d3f296d22a7febb3e4014d60fe282" translate="yes" xml:space="preserve">
          <source>You can directly use any valid key names exposed via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values&quot;&gt;&lt;code&gt;KeyboardEvent.key&lt;/code&gt; (opens new window)&lt;/a&gt; as modifiers by converting them to kebab-case.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values&quot;&gt; &lt;code&gt;KeyboardEvent.key&lt;/code&gt; （新しいウィンドウを開く）&lt;/a&gt;を介して公開された有効なキー名を、それらをkebab-caseに変換することにより、修飾子として直接使用できます。</target>
        </trans-unit>
        <trans-unit id="7028a553eca439b2e7747d4a1bf01ca9da41dba8" translate="yes" xml:space="preserve">
          <source>You can directly use any valid key names exposed via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values&quot;&gt;&lt;code&gt;KeyboardEvent.key&lt;/code&gt;&lt;/a&gt; as modifiers by converting them to kebab-case.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values&quot;&gt; &lt;code&gt;KeyboardEvent.key&lt;/code&gt; &lt;/a&gt;を介して公開されている有効なキー名を、修飾子としてケバブケースに変換することで直接使用できます。</target>
        </trans-unit>
        <trans-unit id="5b0d30a1d66ac3fa2c67a819e1376ba0a0473acd" translate="yes" xml:space="preserve">
          <source>You can even define fallbacks, to be used in case a slot prop is undefined:</source>
          <target state="translated">スロットプロップが未定義の場合に使用するフォールバックを定義することもできます。</target>
        </trans-unit>
        <trans-unit id="ad42325319e7ea64ca1905e50eeba3ae1d34a1e1" translate="yes" xml:space="preserve">
          <source>You can even order by multiple columns:</source>
          <target state="translated">複数の列で順番を決めることもできます。</target>
        </trans-unit>
        <trans-unit id="7cc0ce516635c38508cc33c06a657a1d3f774e4f" translate="yes" xml:space="preserve">
          <source>You can even use pre-processors such as Pug (formerly known as Jade) to author your Vue templates.</source>
          <target state="translated">Pug (以前は Jade として知られていました)などのプリプロセッサを使用して、Vue テンプレートをオーサリングすることもできます。</target>
        </trans-unit>
        <trans-unit id="bcde8b53cf3059c4972d20e4534b1e469ee4c5fb" translate="yes" xml:space="preserve">
          <source>You can find more information at this site.</source>
          <target state="translated">こちらのサイトで詳しく紹介されています。</target>
        </trans-unit>
        <trans-unit id="517b95ad424054751a98acdcf21d4dc4035ab20f" translate="yes" xml:space="preserve">
          <source>You can get a lot of unique effects and make your animation very stylish by adjusting your easing. CSS allows you to modify this by adjusting a cubic bezier property, &lt;a href=&quot;https://cubic-bezier.com/#.17,.67,.83,.67&quot;&gt;this playground (opens new window)&lt;/a&gt; by Lea Verou is very helpful for exploring this.</source>
          <target state="translated">イージングを調整することで、多くのユニークな効果を得ることができ、アニメーションを非常にスタイリッシュにすることができます。CSSを使用すると、キュービックベジェプロパティを調整してこれを変更できます。LeaVerouによる&lt;a href=&quot;https://cubic-bezier.com/#.17,.67,.83,.67&quot;&gt;この遊び場（新しいウィンドウが開きます）は&lt;/a&gt;、これを探索するのに非常に役立ちます。</target>
        </trans-unit>
        <trans-unit id="3df595af00721f8288076a5f9fba469b9a917832" translate="yes" xml:space="preserve">
          <source>You can have multiple classes toggled by having more fields in the object. In addition, the &lt;code&gt;:class&lt;/code&gt; directive can also co-exist with the plain &lt;code&gt;class&lt;/code&gt; attribute. So given the following template:</source>
          <target state="translated">オブジェクトにさらにフィールドを含めることで、複数のクラスを切り替えることができます。さらに、 &lt;code&gt;:class&lt;/code&gt; ディレクティブはプレーン &lt;code&gt;class&lt;/code&gt; 属性と共存することもできます。したがって、次のテンプレートが与えられます。</target>
        </trans-unit>
        <trans-unit id="5c19203d0961c36adfdf784eff782bb9b89fe5ea" translate="yes" xml:space="preserve">
          <source>You can have multiple classes toggled by having more fields in the object. In addition, the &lt;code&gt;v-bind:class&lt;/code&gt; directive can also co-exist with the plain &lt;code&gt;class&lt;/code&gt; attribute. So given the following template:</source>
          <target state="translated">オブジェクトのフィールドを増やすことで、複数のクラスを切り替えることができます。さらに、 &lt;code&gt;v-bind:class&lt;/code&gt; ディレクティブは、プレーン &lt;code&gt;class&lt;/code&gt; 属性と共存することもできます。したがって、次のテンプレートがあるとします。</target>
        </trans-unit>
        <trans-unit id="8aa030b589eee93625f4864d21a641f8663ff7c6" translate="yes" xml:space="preserve">
          <source>You can have multiple methods in an event handler separated by a comma operator like this:</source>
          <target state="translated">このようにカンマ演算子で区切ってイベントハンドラ内に複数のメソッドを持つことができます。</target>
        </trans-unit>
        <trans-unit id="e56c7af523fb7e0763535f3902c25d971d409bc6" translate="yes" xml:space="preserve">
          <source>You can learn more about &lt;code&gt;reactive&lt;/code&gt; in the &lt;a href=&quot;../api/basic-reactivity&quot;&gt;Basic Reactivity API's&lt;/a&gt; section</source>
          <target state="translated">&lt;code&gt;reactive&lt;/code&gt; について詳しくは、&lt;a href=&quot;../api/basic-reactivity&quot;&gt;Basic ReactivityAPIの&lt;/a&gt;セクションをご覧ください。</target>
        </trans-unit>
        <trans-unit id="d08c4fe759a5cd0a79d2084a4f5a83a750978591" translate="yes" xml:space="preserve">
          <source>You can learn more about &lt;code&gt;refs&lt;/code&gt; in the &lt;a href=&quot;../api/refs-api#ref&quot;&gt;Refs API&lt;/a&gt; section</source>
          <target state="translated">&lt;code&gt;refs&lt;/code&gt; 詳細については、&lt;a href=&quot;../api/refs-api#ref&quot;&gt;RefsAPI&lt;/a&gt;セクションをご覧ください。</target>
        </trans-unit>
        <trans-unit id="b6bd14a02b45ad31d79cd406616fc79e061cec94" translate="yes" xml:space="preserve">
          <source>You can learn more about component attribute inheritance in &lt;a href=&quot;component-attrs&quot;&gt;Non-Prop Attributes&lt;/a&gt; section.</source>
          <target state="translated">コンポーネント属性の継承について詳しくは、「&lt;a href=&quot;component-attrs&quot;&gt;非プロップ属性」&lt;/a&gt;セクションをご覧ください。</target>
        </trans-unit>
        <trans-unit id="fd8478ec92b8428be9713f6498961af7738c99a9" translate="yes" xml:space="preserve">
          <source>You can leverage the power of a full programming language (JavaScript) to build your view. This includes temporary variables, flow controls, and directly referencing JavaScript values in scope.</source>
          <target state="translated">完全なプログラミング言語(JavaScript)の力を活用してビューを構築することができます。これには、一時変数、フローコントロール、スコープ内の JavaScript の値を直接参照することが含まれます。</target>
        </trans-unit>
        <trans-unit id="905d51cd5fa57a6f04be69e05b9de5a2548b1f8f" translate="yes" xml:space="preserve">
          <source>You can modify component state in this hook. However, it is important to have conditionals in your template or render function that short circuits other content when an error has been captured; otherwise the component will be thrown into an infinite render loop.</source>
          <target state="translated">このフックでコンポーネントの状態を変更することができます。しかし、テンプレートやレンダリング関数の中に、エラーが捕捉されたときに他のコンテンツを短絡させるような条件付きのものを用意しておくことが重要です。</target>
        </trans-unit>
        <trans-unit id="483010467e7b1520e8252c976ccc95f6183b6a3a" translate="yes" xml:space="preserve">
          <source>You can modify its properties, listed below, before mounting your application.</source>
          <target state="translated">アプリケーションをマウントする前に、以下のプロパティを変更することができます。</target>
        </trans-unit>
        <trans-unit id="fc726e3c336929e5a4f3f15f2e5d000f5d9087e9" translate="yes" xml:space="preserve">
          <source>You can open the console and play with the example vm yourself. The value of &lt;code&gt;vm.reversedMessage&lt;/code&gt; is always dependent on the value of &lt;code&gt;vm.message&lt;/code&gt;.</source>
          <target state="translated">コンソールを開いて、例のvmを自分で再生できます。値 &lt;code&gt;vm.reversedMessage&lt;/code&gt; は常にの値に依存している &lt;code&gt;vm.message&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e8012275d0890f19d6be6f05bec36e87984695c2" translate="yes" xml:space="preserve">
          <source>You can open the console and play with the previous examples&amp;rsquo; &lt;code&gt;items&lt;/code&gt; array by calling their mutation methods. For example: &lt;code&gt;example1.items.push({ message: 'Baz' })&lt;/code&gt;.</source>
          <target state="translated">コンソールを開き、前の例の &lt;code&gt;items&lt;/code&gt; 配列を変更メソッドを呼び出すことで操作できます。例： &lt;code&gt;example1.items.push({ message: 'Baz' })&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7275711fe53486de9349eeef7453708059692c43" translate="yes" xml:space="preserve">
          <source>You can open the console and play with the previous examples' &lt;code&gt;items&lt;/code&gt; array by calling their mutation methods. For example: &lt;code&gt;example1.items.push({ message: 'Baz' })&lt;/code&gt;.</source>
          <target state="translated">コンソールを開き、ミューテーションメソッドを呼び出すことで、前の例の &lt;code&gt;items&lt;/code&gt; 配列を試すことができます。例： &lt;code&gt;example1.items.push({ message: 'Baz' })&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fba921687af5126b7f400e59dbcbdedd8cdb124c" translate="yes" xml:space="preserve">
          <source>You can optionally pass in some options:</source>
          <target state="translated">オプションでいくつかのオプションを渡すことができます。</target>
        </trans-unit>
        <trans-unit id="69df9eda77fa786bedb0320c7efdaa4e55ad2623" translate="yes" xml:space="preserve">
          <source>You can provide an array of multiple (prefixed) values to a style property, for example:</source>
          <target state="translated">例えば、スタイルプロパティに複数の(接頭辞のついた)値の配列を与えることができます。</target>
        </trans-unit>
        <trans-unit id="81a4f4044c3911054f58336d3572114ed40ddb95" translate="yes" xml:space="preserve">
          <source>You can replace it with:</source>
          <target state="translated">に置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="f3ebee5b6a0c8de1d1b75a459aa211a5e7be2130" translate="yes" xml:space="preserve">
          <source>You can see how we could use this for data visualization, for physics effects, for character animations and interactions, the sky's the limit.</source>
          <target state="translated">データの可視化、物理効果、キャラクターのアニメーションやインタラクションにどのように使用できるかがわかります。</target>
        </trans-unit>
        <trans-unit id="95775e978fa861006adc17e274f17759126e18a9" translate="yes" xml:space="preserve">
          <source>You can see other recommendations for component names in the &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;Style Guide&lt;/a&gt;.</source>
          <target state="translated">コンポーネント名に関するその他の推奨事項は、&lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;スタイルガイド&lt;/a&gt;で確認できます。</target>
        </trans-unit>
        <trans-unit id="c82861be683435cc1668ccd7f2e6b81cafe38300" translate="yes" xml:space="preserve">
          <source>You can see other recommendations for component names in the &lt;a href=&quot;../style-guide/index#base-component-names-strongly-recommended&quot;&gt;Style Guide&lt;/a&gt;.</source>
          <target state="translated">コンポーネント名に関するその他の推奨事項については、&lt;a href=&quot;../style-guide/index#base-component-names-strongly-recommended&quot;&gt;スタイルガイドを参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8cb44edcad32144ea0ed5ecec8aaeb904c53b619" translate="yes" xml:space="preserve">
          <source>You can see the &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/tdv8dt3s/&quot;&gt;full example here&lt;/a&gt;. The advantage over using &lt;code&gt;$parent&lt;/code&gt; is that we can access &lt;code&gt;getMap&lt;/code&gt; in &lt;em&gt;any&lt;/em&gt; descendant component, without exposing the entire instance of &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt;. This allows us to more safely keep developing that component, without fear that we might change/remove something that a child component is relying on. The interface between these components remains clearly defined, just as with &lt;code&gt;props&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://jsfiddle.net/chrisvfritz/tdv8dt3s/&quot;&gt;ここで完全な例&lt;/a&gt;を見ることができます。使用よりも有利 &lt;code&gt;$parent&lt;/code&gt; 私たちがアクセスできるということです &lt;code&gt;getMap&lt;/code&gt; して&lt;em&gt;どんな&lt;/em&gt;のインスタンス全体さらすことなく、子孫コンポーネント &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; 。これにより、子コンポーネントが依存しているものを変更/削除することを恐れることなく、そのコンポーネントをより安全に開発し続けることができます。これらのコンポーネント間のインターフェースは、 &lt;code&gt;props&lt;/code&gt; と同様に明確に定義されたままです。</target>
        </trans-unit>
        <trans-unit id="16bcf864fb3aac6cb97fde8cea277e3092eccb3c" translate="yes" xml:space="preserve">
          <source>You can see the description by inspecting Chrome DevTools:</source>
          <target state="translated">Chrome DevToolsを調べると説明が出てきます。</target>
        </trans-unit>
        <trans-unit id="2e4d8ebb6112a000f5549eb59e46ddfbf5ba539c" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;v-else&lt;/code&gt; directive to indicate an &quot;else block&quot; for &lt;code&gt;v-if&lt;/code&gt;:</source>
          <target state="translated">あなたは使用することができ &lt;code&gt;v-else&lt;/code&gt; のための「elseブロック」を示すために、ディレクティブを &lt;code&gt;v-if&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="245b045b34476511514b4b5c3df43a3bd4d1f68c" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;v-else&lt;/code&gt; directive to indicate an &amp;ldquo;else block&amp;rdquo; for &lt;code&gt;v-if&lt;/code&gt;:</source>
          <target state="translated">あなたは使用することができ &lt;code&gt;v-else&lt;/code&gt; のための「elseブロック」を示すために、ディレクティブを &lt;code&gt;v-if&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2a4fae4f9f57495dc2dabf7c2d98d7cf9f74df2a" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;v-model&lt;/code&gt; directive to create two-way data bindings on form input, textarea, and select elements. It automatically picks the correct way to update the element based on the input type. Although a bit magical, &lt;code&gt;v-model&lt;/code&gt; is essentially syntax sugar for updating data on user input events, plus special care for some edge cases.</source>
          <target state="translated">&lt;code&gt;v-model&lt;/code&gt; ディレクティブを使用して、フォーム入力、textarea、およびselect要素に双方向のデータバインディングを作成できます。入力タイプに基づいて、要素を更新する正しい方法が自動的に選択されます。少し不思議ですが、 &lt;code&gt;v-model&lt;/code&gt; は基本的に、ユーザー入力イベントのデータを更新するための構文シュガーであり、一部のエッジケースには特別な注意が必要です。</target>
        </trans-unit>
        <trans-unit id="b7c793ba84fdf736cdbc25fee71f2a2c7eaf0e57" translate="yes" xml:space="preserve">
          <source>You can use the following modifiers to trigger mouse or keyboard event listeners only when the corresponding modifier key is pressed:</source>
          <target state="translated">以下の修飾子を使用して、対応する修飾子キーが押されたときだけマウスやキーボードのイベントリスナーをトリガーすることができます。</target>
        </trans-unit>
        <trans-unit id="8ddb37f26a92a06753b285b9c9c11e196959baab" translate="yes" xml:space="preserve">
          <source>You can use this technique to create functional images.</source>
          <target state="translated">このテクニックを使って機能的な画像を作成することができます。</target>
        </trans-unit>
        <trans-unit id="28ce5baaf2a7e364a9e6393430ef2a639312b251" translate="yes" xml:space="preserve">
          <source>You can use:</source>
          <target state="translated">使えます。</target>
        </trans-unit>
        <trans-unit id="ca0c657ad0278a0921d29ff9ef965a0e62ef03be" translate="yes" xml:space="preserve">
          <source>You could add a new &lt;code&gt;age&lt;/code&gt; property to the nested &lt;code&gt;userProfile&lt;/code&gt; object with:</source>
          <target state="translated">ネストされた &lt;code&gt;userProfile&lt;/code&gt; オブジェクトに新しい &lt;code&gt;age&lt;/code&gt; プロパティを追加するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="0acc99ee1e9f7a5721274787de8b1c76d139ac14" translate="yes" xml:space="preserve">
          <source>You could resolve both issues with a programmatic listener:</source>
          <target state="translated">プログラムリスナーで両方の問題を解決することができます。</target>
        </trans-unit>
        <trans-unit id="c532773b5fa5995d94c7324ea49825da9f88b956" translate="yes" xml:space="preserve">
          <source>You could use:</source>
          <target state="translated">使えますよ。</target>
        </trans-unit>
        <trans-unit id="4e0ef273090898bde0e037c96c402023d3d76aed" translate="yes" xml:space="preserve">
          <source>You could write:</source>
          <target state="translated">書けばいいんだよ。</target>
        </trans-unit>
        <trans-unit id="1ad84f5c26c15d7162b3722b45d0ba843c67381b" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t have to do anything special in your components to make them testable. Export the raw options:</source>
          <target state="translated">コンポーネントをテスト可能にするために、コンポーネントで特別なことを行う必要はありません。生のオプションをエクスポートします。</target>
        </trans-unit>
        <trans-unit id="3d0f507759bdd0fc68a3de5b0514f524e5f3294e" translate="yes" xml:space="preserve">
          <source>You have two options when defining component names:</source>
          <target state="translated">コンポーネント名を定義する際には、2つのオプションがあります。</target>
        </trans-unit>
        <trans-unit id="32c890526e2b50fb6ddd6a47a453deb3b5176a87" translate="yes" xml:space="preserve">
          <source>You may also find that entrances look better with slightly more time than an exit. The user typically is being guided during the entrance, and is a little less patient upon exit because they want to go on their way.</source>
          <target state="translated">また、入口の方が出口よりも少し時間がある方がよく見えることもあるでしょう。ユーザーは通常、入口の間は案内されていて、出口では自分の道を進みたいので、少し我慢が足りません。</target>
        </trans-unit>
        <trans-unit id="052f909a44e11196b7f8fa3d033ec09119d35042" translate="yes" xml:space="preserve">
          <source>You may be interested to know that Vue&amp;rsquo;s templates actually compile to render functions. This is an implementation detail you usually don&amp;rsquo;t need to know about, but if you&amp;rsquo;d like to see how specific template features are compiled, you may find it interesting. Below is a little demo using &lt;code&gt;Vue.compile&lt;/code&gt; to live-compile a template string:</source>
          <target state="translated">Vueのテンプレートが実際に関数をレンダリングするためにコンパイルされることを知りたいと思うかもしれません。これは通常は知る必要のない実装の詳細ですが、特定のテンプレート機能がどのようにコンパイルされるかを確認したい場合は、興味深いかもしれません。以下は、 &lt;code&gt;Vue.compile&lt;/code&gt; を使用してテンプレート文字列をライブコンパイルする小さなデモです。</target>
        </trans-unit>
        <trans-unit id="8cd17a8f30e925013013a4351cf5807785289ba1" translate="yes" xml:space="preserve">
          <source>You may be interested to know that Vue's templates actually compile to render functions. This is an implementation detail you usually don't need to know about, but if you'd like to see how specific template features are compiled, you may find it interesting. Below is a little demo using &lt;code&gt;Vue.compile&lt;/code&gt; to live-compile a template string:</source>
          <target state="translated">Vueのテンプレートが実際にコンパイルされて関数をレンダリングすることを知りたいと思うかもしれません。これは、通常は知る必要のない実装の詳細ですが、特定のテンプレート機能がどのようにコンパイルされているかを知りたい場合は、興味深いと思うかもしれません。以下は、 &lt;code&gt;Vue.compile&lt;/code&gt; を使用してテンプレート文字列をライブコンパイルする小さなデモです。</target>
        </trans-unit>
        <trans-unit id="6a6dc5bbc4d3bace526bdc2fd08d2cfab5d8dec3" translate="yes" xml:space="preserve">
          <source>You may be wondering:</source>
          <target state="translated">と疑問に思うかもしれません。</target>
        </trans-unit>
        <trans-unit id="143b9f4f1dc7d1bfde27bde6e896dca625ded097" translate="yes" xml:space="preserve">
          <source>You may have noticed that Vue components are very similar to &lt;strong&gt;Custom Elements&lt;/strong&gt;, which are part of the &lt;a href=&quot;https://www.w3.org/wiki/WebComponents/&quot;&gt;Web Components Spec (opens new window)&lt;/a&gt;. That's because Vue's component syntax is loosely modeled after the spec. For example, Vue components implement the &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Slot API (opens new window)&lt;/a&gt; and the &lt;code&gt;is&lt;/code&gt; special attribute. However, there are a few key differences:</source>
          <target state="translated">Vueコンポーネントは、&lt;a href=&quot;https://www.w3.org/wiki/WebComponents/&quot;&gt;Webコンポーネント仕様の&lt;/a&gt;一部である&lt;strong&gt;カスタム要素&lt;/strong&gt;と非常によく似ていることに気付いたかもしれません（新しいウィンドウが開きます）。これは、Vueのコンポーネント構文が仕様に基づいて大まかにモデル化されているためです。たとえば、Vueコンポーネントは&lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Slot APIを&lt;/a&gt;実装し（新しいウィンドウを開きます）、 &lt;code&gt;is&lt;/code&gt; 特別な属性です。ただし、いくつかの重要な違いがあります。</target>
        </trans-unit>
        <trans-unit id="ebc07e2aec6e341f69ef26081c0e5222d68f3b55" translate="yes" xml:space="preserve">
          <source>You may have noticed that Vue components are very similar to &lt;strong&gt;Custom Elements&lt;/strong&gt;, which are part of the &lt;a href=&quot;https://www.w3.org/wiki/WebComponents/&quot;&gt;Web Components Spec&lt;/a&gt;. That&amp;rsquo;s because Vue&amp;rsquo;s component syntax is loosely modeled after the spec. For example, Vue components implement the &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Slot API&lt;/a&gt; and the &lt;code&gt;is&lt;/code&gt; special attribute. However, there are a few key differences:</source>
          <target state="translated">Vueコンポーネントは、&lt;a href=&quot;https://www.w3.org/wiki/WebComponents/&quot;&gt;Web Components Specの&lt;/a&gt;一部である&lt;strong&gt;Custom Elements&lt;/strong&gt;に非常に似ていることに気づいたかもしれません。これは、Vueのコンポーネント構文が仕様に基づいて大まかにモデル化されているためです。たとえば、Vueコンポーネントは&lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Slot API&lt;/a&gt;を実装しており、これ &lt;code&gt;is&lt;/code&gt; 特別な属性です。ただし、いくつかの重要な違いがあります。</target>
        </trans-unit>
        <trans-unit id="f8faf1ddcecc2ccb7d0d4b5801a7f067548f165d" translate="yes" xml:space="preserve">
          <source>You may have noticed we can achieve the same result by invoking a method in the expression:</source>
          <target state="translated">式の中でメソッドを呼び出すことで同じ結果が得られることにお気づきかもしれません。</target>
        </trans-unit>
        <trans-unit id="6f3e133c225d466ecd683f06d0a8f9b03a34053d" translate="yes" xml:space="preserve">
          <source>You may not have accounted for change detection caveats &lt;a href=&quot;list#Caveats&quot;&gt;with arrays&lt;/a&gt; or &lt;a href=&quot;list#Object-Change-Detection-Caveats&quot;&gt;objects&lt;/a&gt;, or you may be relying on state that isn&amp;rsquo;t tracked by Vue&amp;rsquo;s reactivity system, e.g. with &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;list#Caveats&quot;&gt;配列&lt;/a&gt;や&lt;a href=&quot;list#Object-Change-Detection-Caveats&quot;&gt;オブジェクトの&lt;/a&gt;変更検出に関する警告を考慮していないか、 &lt;code&gt;data&lt;/code&gt; などのVueの反応システムによって追跡されていない状態に依存している可能性があります。</target>
        </trans-unit>
        <trans-unit id="f78a45e93ff614ad4d560280cdd81744a9547eeb" translate="yes" xml:space="preserve">
          <source>You may notice that the animations shown above are using things like &lt;code&gt;transforms&lt;/code&gt;, and applying strange properties like &lt;code&gt;perspective&lt;/code&gt;- why were they built that way instead of just using &lt;code&gt;margin&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt; etc?</source>
          <target state="translated">上に示したアニメーションは、 &lt;code&gt;transforms&lt;/code&gt; などを使用し、 &lt;code&gt;perspective&lt;/code&gt; などの奇妙なプロパティを適用していることに気付くかもしれません。 &lt;code&gt;margin&lt;/code&gt; や &lt;code&gt;top&lt;/code&gt; などを使用するのではなく、なぜそのように構築されたのでしょうか。</target>
        </trans-unit>
        <trans-unit id="f56316fe542cc1b3610fe594b75ba3af739e576a" translate="yes" xml:space="preserve">
          <source>You may notice that:</source>
          <target state="translated">ということに気づくかもしれません。</target>
        </trans-unit>
        <trans-unit id="5e2f8675ad97e6ec4ee4ad4c7d9ed72b6a98e329" translate="yes" xml:space="preserve">
          <source>You may wonder why we need both &lt;code&gt;slots()&lt;/code&gt; and &lt;code&gt;children&lt;/code&gt;. Wouldn&amp;rsquo;t &lt;code&gt;slots().default&lt;/code&gt; be the same as &lt;code&gt;children&lt;/code&gt;? In some cases, yes - but what if you have a functional component with the following children?</source>
          <target state="translated">なぜ &lt;code&gt;slots()&lt;/code&gt; と &lt;code&gt;children&lt;/code&gt; の両方が必要なのか不思議に思うかもしれません。Slots &lt;code&gt;slots().default&lt;/code&gt; は &lt;code&gt;children&lt;/code&gt; と同じではありませんか？一部のケースでは、はい-しかし、次の子を持つ機能コンポーネントがある場合はどうなりますか？</target>
        </trans-unit>
        <trans-unit id="f4b169dfdbff18ce5e5cf4146c1cf33c657dfab8" translate="yes" xml:space="preserve">
          <source>You might be concerned that this whole event listening approach violates the good old rules about &quot;separation of concerns&quot;. Rest assured - since all Vue handler functions and expressions are strictly bound to the ViewModel that's handling the current view, it won't cause any maintenance difficulty. In fact, there are several benefits in using &lt;code&gt;v-on&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt;:</source>
          <target state="translated">このイベントリスニングアプローチ全体が、「関心の分離」に関する古き良き規則に違反していることを懸念するかもしれません。安心してください-すべてのVueハンドラー関数と式は、現在のビューを処理するViewModelに厳密にバインドされているため、メンテナンスの問題は発生しません。実際、 &lt;code&gt;v-on&lt;/code&gt; または &lt;code&gt;@&lt;/code&gt; を使用することにはいくつかの利点があります：</target>
        </trans-unit>
        <trans-unit id="11e1b5ea3cb693ce24f280b44d340791c063f5aa" translate="yes" xml:space="preserve">
          <source>You might be concerned that this whole event listening approach violates the good old rules about &amp;ldquo;separation of concerns&amp;rdquo;. Rest assured - since all Vue handler functions and expressions are strictly bound to the ViewModel that&amp;rsquo;s handling the current view, it won&amp;rsquo;t cause any maintenance difficulty. In fact, there are several benefits in using &lt;code&gt;v-on&lt;/code&gt;:</source>
          <target state="translated">このイベントリスニングアプローチ全体が、「懸念の分離」に関する古き良き規則に違反していることを心配するかもしれません。安心してください。すべてのVueハンドラー関数と式は、現在のビューを処理しているViewModelに厳密にバインドされているため、メンテナンスの問題は発生しません。実際、 &lt;code&gt;v-on&lt;/code&gt; を使用することにはいくつかの利点があります。</target>
        </trans-unit>
        <trans-unit id="8b95fdb476d99a0cdcdb7cfdf0abca7591aa1787" translate="yes" xml:space="preserve">
          <source>You might be tempted to solve this problem by nesting child components in directories named after their parent. For example:</source>
          <target state="translated">この問題を解決するには、子コンポーネントを親の名前を付けたディレクトリに入れ子にすると良いでしょう。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="a47591adc396778366644573330c716aad893852" translate="yes" xml:space="preserve">
          <source>You might be tempted to solve this problem differently, nesting all the search components under a &quot;search&quot; directory, then all the settings components under a &quot;settings&quot; directory. We only recommend considering this approach in very large apps (e.g. 100+ components), for these reasons:</source>
          <target state="translated">すべての検索コンポーネントを &quot;search &quot;ディレクトリの下に入れ子にし、すべての設定コンポーネントを &quot;settings &quot;ディレクトリの下に入れて、この問題を別の方法で解決したいと思うかもしれません。これらの理由から、非常に大規模なアプリ(例えば100以上のコンポーネント)でのみ、このアプローチを検討することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="5617302f09918fe6715d17bbf628df2dfc2db645" translate="yes" xml:space="preserve">
          <source>You might be tempted to solve this problem differently, nesting all the search components under a &amp;ldquo;search&amp;rdquo; directory, then all the settings components under a &amp;ldquo;settings&amp;rdquo; directory. We only recommend considering this approach in very large apps (e.g. 100+ components), for these reasons:</source>
          <target state="translated">この問題を別の方法で解決したいと思うかもしれません。すべての検索コンポーネントを「search」ディレクトリの下にネストし、次にすべての設定コンポーネントを「settings」ディレクトリの下にネストします。次の理由により、このアプローチは非常に大きなアプリ（100以上のコンポーネントなど）でのみ検討することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="aa7fb79770049661cccac5c46719619557b2fa6b" translate="yes" xml:space="preserve">
          <source>You might think this will cause Vue to throw away the existing DOM and re-render the entire list - luckily, that is not the case. Vue implements some smart heuristics to maximize DOM element reuse, so replacing an array with another array containing overlapping objects is a very efficient operation.</source>
          <target state="translated">これにより、Vue は既存の DOM を捨ててリスト全体を再レンダリングすることになると思うかもしれませんが、幸いなことにそのようなことはありません。Vue は DOM 要素の再利用を最大化するためにいくつかのスマートなヒューリスティックを実装しているので、配列を重複するオブジェクトを含む別の配列に置き換えることは非常に効率的な操作です。</target>
        </trans-unit>
        <trans-unit id="af73f4fae217fbf1fdd9f84b803aac67150174c7" translate="yes" xml:space="preserve">
          <source>You normally won&amp;rsquo;t have to use these, but they&amp;rsquo;re available for cases when you need to manually listen for events on a component instance. They can also be useful as a code organization tool. For example, you may often see this pattern for integrating a 3rd-party library:</source>
          <target state="translated">通常はこれらを使用する必要はありませんが、コンポーネントインスタンスのイベントを手動でリッスンする必要がある場合に使用できます。また、コード整理ツールとしても役立ちます。たとえば、サードパーティのライブラリを統合するために次のパターンがよく見られることがあります。</target>
        </trans-unit>
        <trans-unit id="32cb581eeb56efa438796b9971ee44ba01ae446b" translate="yes" xml:space="preserve">
          <source>You pass a router property to a Vue instance:</source>
          <target state="translated">Vue インスタンスにルータのプロパティを渡します。</target>
        </trans-unit>
        <trans-unit id="efb25a0ae9444bc1df853a464d4343356ffb5415" translate="yes" xml:space="preserve">
          <source>You probably have noticed the use of &lt;code&gt;toRefs&lt;/code&gt; at the top of our &lt;code&gt;setup&lt;/code&gt;. This is to ensure our watcher will react to changes made to the &lt;code&gt;user&lt;/code&gt; prop.</source>
          <target state="translated">&lt;code&gt;setup&lt;/code&gt; 上部で &lt;code&gt;toRefs&lt;/code&gt; が使用されていることに気付いたと思います。これは、ウォッチャーが &lt;code&gt;user&lt;/code&gt; プロパティに加えられた変更に確実に反応するようにするためです。</target>
        </trans-unit>
        <trans-unit id="6607184e34ec98c705e8936d4bd119debd7a5883" translate="yes" xml:space="preserve">
          <source>You should add a link at the top of each page that goes directly to the main content area so users can skip content that is repeated on multiple Web pages.</source>
          <target state="translated">ユーザーが複数のウェブページで繰り返されるコンテンツをスキップできるように、各ページの上部にメインコンテンツエリアに直接行くリンクを追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="50cbb9b4948567ec7d8fcd49f2d19a471f8d2b2a" translate="yes" xml:space="preserve">
          <source>You should ensure your initial value for &lt;code&gt;text&lt;/code&gt; is &amp;ldquo;hello world&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;text&lt;/code&gt; 初期値が「hello world」であることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="0388064a0faab22748fe939b523209cc3a4161d9" translate="yes" xml:space="preserve">
          <source>You should never replace the original state object in your actions - the components and the store need to share reference to the same object in order for mutations to be observed.</source>
          <target state="translated">コンポーネントとストアは、突然変異を観測するために同じオブジェクトへの参照を共有する必要があります。</target>
        </trans-unit>
        <trans-unit id="f45a86f83ace1c03cb53baba5bc8187e35c91e8d" translate="yes" xml:space="preserve">
          <source>You still have access to the original value of the prop.</source>
          <target state="translated">あなたはまだプロップの元の価値にアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="11c1c2c028934d5bbcb142d155ffb56c0c189c5b" translate="yes" xml:space="preserve">
          <source>You would add new, reactive properties with:</source>
          <target state="translated">で新しい反応性のあるプロパティを追加します。</target>
        </trans-unit>
        <trans-unit id="20728f1a16caf4befc427a8e6e74564862df5ba2" translate="yes" xml:space="preserve">
          <source>You would now write:</source>
          <target state="translated">今なら書くでしょう。</target>
        </trans-unit>
        <trans-unit id="161f58130bcdfa0a115e5914f0b475cdc7c281e0" translate="yes" xml:space="preserve">
          <source>You would use:</source>
          <target state="translated">使うでしょう。</target>
        </trans-unit>
        <trans-unit id="23069654131c71fce55bf35e4df935bea4d59d1a" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll need to update it like this:</source>
          <target state="translated">次のように更新する必要があります。</target>
        </trans-unit>
        <trans-unit id="ce8b38bdf63cc6de78844a6e80332a8d228551d1" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll notice that if you select a post, switch to the &lt;em&gt;Archive&lt;/em&gt; tab, then switch back to &lt;em&gt;Posts&lt;/em&gt;, it&amp;rsquo;s no longer showing the post you selected. That&amp;rsquo;s because each time you switch to a new tab, Vue creates a new instance of the &lt;code&gt;currentTabComponent&lt;/code&gt;.</source>
          <target state="translated">投稿を選択して[ &lt;em&gt;アーカイブ&lt;/em&gt; ]タブに切り替え、次に[ &lt;em&gt;投稿&lt;/em&gt; ]に切り替えると、選択した投稿が表示されなくなっていることに気づくでしょう。これは、新しいタブに切り替えるたびに、Vueが &lt;code&gt;currentTabComponent&lt;/code&gt; の新しいインスタンスを作成するためです。</target>
        </trans-unit>
        <trans-unit id="24954ec56901e878c0cebe8e9e38748e3b95f2bf" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll see other examples of modifiers later, &lt;a href=&quot;events#Event-Modifiers&quot;&gt;for &lt;code&gt;v-on&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;forms#Modifiers&quot;&gt;for &lt;code&gt;v-model&lt;/code&gt;&lt;/a&gt;, when we explore those features.</source>
          <target state="translated">あなたは、後で修飾の他の例を見ることができます&lt;a href=&quot;events#Event-Modifiers&quot;&gt;ため &lt;code&gt;v-on&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;forms#Modifiers&quot;&gt;のための &lt;code&gt;v-model&lt;/code&gt; &lt;/a&gt;、我々はこれらの機能を探索するとき、。</target>
        </trans-unit>
        <trans-unit id="3fca6997a996507a0a2f511c041749b30ea59a71" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve also seen props assigned dynamically with &lt;code&gt;v-bind&lt;/code&gt;, such as in:</source>
          <target state="translated">次のように、 &lt;code&gt;v-bind&lt;/code&gt; で動的に割り当てられた小道具を見たこともあります。</target>
        </trans-unit>
        <trans-unit id="e7be35175595e36028a58566d499b0922b290b29" translate="yes" xml:space="preserve">
          <source>You'll find very quickly that &lt;code&gt;out-in&lt;/code&gt; is the state you will want most of the time 😃</source>
          <target state="translated">&lt;code&gt;out-in&lt;/code&gt; ほとんどの場合に必要な状態であることがすぐにわかります😃</target>
        </trans-unit>
        <trans-unit id="534161e1c7e94319d05a92ec6723a8bacc8c01a4" translate="yes" xml:space="preserve">
          <source>You'll notice that if you select a post, switch to the &lt;em&gt;Archive&lt;/em&gt; tab, then switch back to &lt;em&gt;Posts&lt;/em&gt;, it's no longer showing the post you selected. That's because each time you switch to a new tab, Vue creates a new instance of the &lt;code&gt;currentTabComponent&lt;/code&gt;.</source>
          <target state="translated">投稿を選択して[&lt;em&gt;アーカイブ&lt;/em&gt;]タブに切り替えてから[&lt;em&gt;投稿&lt;/em&gt;]に戻すと、選択した投稿が表示されなくなります。これは、新しいタブに切り替えるたびに、Vueが &lt;code&gt;currentTabComponent&lt;/code&gt; の新しいインスタンスを作成するためです。</target>
        </trans-unit>
        <trans-unit id="daeca355004e5e6b6695c8995c5901fed3362699" translate="yes" xml:space="preserve">
          <source>You'll see other examples of modifiers later, &lt;a href=&quot;events#event-modifiers&quot;&gt;for &lt;code&gt;v-on&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;forms#modifiers&quot;&gt;for &lt;code&gt;v-model&lt;/code&gt;&lt;/a&gt;, when we explore those features.</source>
          <target state="translated">あなたは、後で修飾の他の例を見ることができます&lt;a href=&quot;events#event-modifiers&quot;&gt;ため &lt;code&gt;v-on&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;forms#modifiers&quot;&gt;のための &lt;code&gt;v-model&lt;/code&gt; &lt;/a&gt;、我々はこれらの機能を探索するとき、。</target>
        </trans-unit>
        <trans-unit id="40a835cf811b8522c8db0e1f6d873fc28bdc60bb" translate="yes" xml:space="preserve">
          <source>You've also seen props assigned dynamically with &lt;code&gt;v-bind&lt;/code&gt; or its shortcut, the &lt;code&gt;:&lt;/code&gt; character, such as in:</source>
          <target state="translated">また、次のように、 &lt;code&gt;v-bind&lt;/code&gt; またはそのショートカットである &lt;code&gt;:&lt;/code&gt; 文字を使用して動的に割り当てられた小道具も確認しました。</target>
        </trans-unit>
        <trans-unit id="05b27e33e416edbd67daffe51a424c0c9ef6b0f3" translate="yes" xml:space="preserve">
          <source>Your browser does not support the video tag.</source>
          <target state="translated">お使いのブラウザはビデオタグをサポートしていません。</target>
        </trans-unit>
        <trans-unit id="e16495c712ef4bb3f6daaec07a27bda6dcb2de3b" translate="yes" xml:space="preserve">
          <source>Your inline template needs to be defined inside the DOM element to which Vue is attached.</source>
          <target state="translated">インライン テンプレートは、Vue がアタッチされている DOM 要素の内部で定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="1a898991781228e1b8f324be36491bab255f87e5" translate="yes" xml:space="preserve">
          <source>Your x-template needs to be defined outside the DOM element to which Vue is attached.</source>
          <target state="translated">x-template は、Vue がアタッチされている DOM 要素の外側で定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="719b3279429110b4281221c4c4d4388f5c5f6d57" translate="yes" xml:space="preserve">
          <source>ZoomText (opens new window)</source>
          <target state="translated">ズームテキスト(新しいウィンドウが開きます</target>
        </trans-unit>
        <trans-unit id="954963c855d044c40d394debb8685e798d25e0c3" translate="yes" xml:space="preserve">
          <source>Zooming Tools</source>
          <target state="translated">ズームツール</target>
        </trans-unit>
        <trans-unit id="a221925ebff8ab7b21b8e492fd8afd314da61e41" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;https://github.com/vuejs/eslint-plugin-vue&quot;&gt;GitHub (opens new window)&lt;/a&gt;]</source>
          <target state="translated">[ &lt;a href=&quot;https://github.com/vuejs/eslint-plugin-vue&quot;&gt;GitHub（新しいウィンドウを開きます）&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="808b02ba7769882289f391dd6032af22b8a8bcfc" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;https://github.com/vuejs/jsx-next&quot;&gt;GitHub (opens new window)&lt;/a&gt;]</source>
          <target state="translated">[ &lt;a href=&quot;https://github.com/vuejs/jsx-next&quot;&gt;GitHub（新しいウィンドウを開きます）&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="25af989e02d5c99908ae438d2926502894ee2e7e" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;https://github.com/vuejs/rollup-plugin-vue/tree/next&quot;&gt;GitHub (opens new window)&lt;/a&gt;]</source>
          <target state="translated">[ &lt;a href=&quot;https://github.com/vuejs/rollup-plugin-vue/tree/next&quot;&gt;GitHub（新しいウィンドウを開きます）&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="9baa16f6d48ca446fc08d35723e042c4ab28008f" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;https://github.com/vuejs/vue-class-component/tree/next&quot;&gt;GitHub (opens new window)&lt;/a&gt;]</source>
          <target state="translated">[ &lt;a href=&quot;https://github.com/vuejs/vue-class-component/tree/next&quot;&gt;GitHub（新しいウィンドウを開きます）&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="36204eda54f3ff6c52797fd1a52e5a030c6b5463" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;https://github.com/vuejs/vue-loader/tree/next&quot;&gt;GitHub (opens new window)&lt;/a&gt;]</source>
          <target state="translated">[ &lt;a href=&quot;https://github.com/vuejs/vue-loader/tree/next&quot;&gt;GitHub（新しいウィンドウを開きます）&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="9b8ba12c942b8b26403cd1f4cc7f6445d6ba6cd3" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;https://github.com/vuejs/vue-test-utils-next&quot;&gt;GitHub (opens new window)&lt;/a&gt;]</source>
          <target state="translated">[ &lt;a href=&quot;https://github.com/vuejs/vue-test-utils-next&quot;&gt;GitHub（新しいウィンドウを開きます）&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="38d0755f22a328b4f298c59f5483245132c44891" translate="yes" xml:space="preserve">
          <source>[] Syntax for Arrays in Queries &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">[]クエリの配列の構文が&lt;sup&gt;削除されました&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="05f06f89e67d5e29faafce2571087b800d959cf1" translate="yes" xml:space="preserve">
          <source>a component&amp;rsquo;s options object</source>
          <target state="translated">コンポーネントのオプションオブジェクト</target>
        </trans-unit>
        <trans-unit id="aac58ea6af883add3a2d5783edf0931a374353ca" translate="yes" xml:space="preserve">
          <source>a component's options object</source>
          <target state="translated">コンポーネントのオプションオブジェクト</target>
        </trans-unit>
        <trans-unit id="8d6f977aae904b70e03db8be89e04306d985fff9" translate="yes" xml:space="preserve">
          <source>a computed property</source>
          <target state="translated">けいさんせいぶつ</target>
        </trans-unit>
        <trans-unit id="bdcd6b24d7256da2dc86cd11b5e2bfc22f0bbfd9" translate="yes" xml:space="preserve">
          <source>a data property, with the prop used to set its default value</source>
          <target state="translated">データプロパティで、デフォルト値を設定するためにプロップが使用されます。</target>
        </trans-unit>
        <trans-unit id="0a2a5fb75e421181bc33cbe4cff3883b8bc3e0c5" translate="yes" xml:space="preserve">
          <source>activated</source>
          <target state="translated">activated</target>
        </trans-unit>
        <trans-unit id="afa841449d16eb794efb8d9de6a6f1dba60b5507" translate="yes" xml:space="preserve">
          <source>an array of strings, or</source>
          <target state="translated">文字列の配列</target>
        </trans-unit>
        <trans-unit id="8ba29b644bf0d96ca60dcdd83182f0d4523d6d61" translate="yes" xml:space="preserve">
          <source>an object where the keys are the local binding name and the value is either:</source>
          <target state="translated">キーがローカルバインディング名で、値がどちらかのオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="1f0fd3140718ffb119179b1d6559195ecab794b0" translate="yes" xml:space="preserve">
          <source>an object where:</source>
          <target state="translated">オブジェクトが存在する場所を指定します。</target>
        </trans-unit>
        <trans-unit id="183f9cf8e98ab46fad30f22829e7359386bcc859" translate="yes" xml:space="preserve">
          <source>ancestor components don&amp;rsquo;t need to know which descendants use the properties it provides</source>
          <target state="translated">祖先コンポーネントは、どの子孫が提供するプロパティを使用するかを知る必要はありません</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="435c0eff27e6bd37bfd007287d502c24caaa618e" translate="yes" xml:space="preserve">
          <source>and custom JavaScript hooks:</source>
          <target state="translated">とカスタムJavaScriptフックを使用しています。</target>
        </trans-unit>
        <trans-unit id="467081e5090da9dbbbeef46980aa3215471c51a8" translate="yes" xml:space="preserve">
          <source>app.component</source>
          <target state="translated">app.component</target>
        </trans-unit>
        <trans-unit id="5242c228688e376d238375da2e61daa4d72f01db" translate="yes" xml:space="preserve">
          <source>app.config</source>
          <target state="translated">app.config</target>
        </trans-unit>
        <trans-unit id="18219ca7f262cc06aea854c86b553561b308e57f" translate="yes" xml:space="preserve">
          <source>app.config.globalProperties (&lt;a href=&quot;#vue-prototype-replaced-by-config-globalproperties&quot;&gt;see below&lt;/a&gt;)</source>
          <target state="translated">app.config.globalProperties（&lt;a href=&quot;#vue-prototype-replaced-by-config-globalproperties&quot;&gt;以下を参照&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="2a870440d8c7f82a6a1f2568c003080c77c5339e" translate="yes" xml:space="preserve">
          <source>app.config.isCustomElement (&lt;a href=&quot;#config-ignoredelements-is-now-config-iscustomelement&quot;&gt;see below&lt;/a&gt;)</source>
          <target state="translated">app.config.isCustomElement（&lt;a href=&quot;#config-ignoredelements-is-now-config-iscustomelement&quot;&gt;以下を参照&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="4d85ceb7e6fd9d135c221589e806583d76513472" translate="yes" xml:space="preserve">
          <source>app.directive</source>
          <target state="translated">app.directive</target>
        </trans-unit>
        <trans-unit id="4c693e55b34812b4bae7c65ed8632f25ecb7dd87" translate="yes" xml:space="preserve">
          <source>app.mixin</source>
          <target state="translated">app.mixin</target>
        </trans-unit>
        <trans-unit id="1f2300b97dba467c4a8c4a56ebdb0ce97fcb714d" translate="yes" xml:space="preserve">
          <source>app.use (&lt;a href=&quot;#a-note-for-plugin-authors&quot;&gt;see below&lt;/a&gt;)</source>
          <target state="translated">app.use（&lt;a href=&quot;#a-note-for-plugin-authors&quot;&gt;以下を参照&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="7bc6e046efd172457735b44f7929fe7efc0747f1" translate="yes" xml:space="preserve">
          <source>aria-describedby</source>
          <target state="translated">aria-describedby</target>
        </trans-unit>
        <trans-unit id="e4f0ab341d5e8e82e3d8dc99926c2333f783f688" translate="yes" xml:space="preserve">
          <source>aria-hidden=&quot;true&quot;</source>
          <target state="translated">aria-hidden=&quot;true&quot;</target>
        </trans-unit>
        <trans-unit id="c399d0d9385cb50ef9a74487c5e1ea13ac3f984e" translate="yes" xml:space="preserve">
          <source>aria-label</source>
          <target state="translated">aria-label</target>
        </trans-unit>
        <trans-unit id="ec0bffb04210018ec41d270900cc33a6714de325" translate="yes" xml:space="preserve">
          <source>aria-labelledby</source>
          <target state="translated">aria-labelledby</target>
        </trans-unit>
        <trans-unit id="f68ce285b8377013d64f60cad53e6825b9961b6a" translate="yes" xml:space="preserve">
          <source>as a performance optimization, because they initialized much faster than stateful components</source>
          <target state="translated">は、ステートフルコンポーネントよりもはるかに高速に初期化されるため、パフォーマンスの最適化として</target>
        </trans-unit>
        <trans-unit id="b77cad1467608c98b4675073084c13ea3aba2ffb" translate="yes" xml:space="preserve">
          <source>aside</source>
          <target state="translated">aside</target>
        </trans-unit>
        <trans-unit id="394bb07928a366287168902c26665311049fa093" translate="yes" xml:space="preserve">
          <source>authoring tools</source>
          <target state="translated">オーサリングツール</target>
        </trans-unit>
        <trans-unit id="d006c05ec9429e15a41c040a3bce4c19f3e5bf12" translate="yes" xml:space="preserve">
          <source>automatically apply classes for CSS transitions and animations</source>
          <target state="translated">CSS トランジションやアニメーションのためのクラスを自動的に適用します。</target>
        </trans-unit>
        <trans-unit id="cf96e5119b1388a4b34a03ab22f4668c3d645b8d" translate="yes" xml:space="preserve">
          <source>backed by this data:</source>
          <target state="translated">このデータに裏打ちされた</target>
        </trans-unit>
        <trans-unit id="cce342be435b5f51f04f16e98c3fefe789ea7c5f" translate="yes" xml:space="preserve">
          <source>be able to copy and paste most community code examples without modification</source>
          <target state="translated">ほとんどのコミュニティコードの例を修正せずにコピー&amp;ペーストできるようになります。</target>
        </trans-unit>
        <trans-unit id="761fb4d2dcb65a5b7e1da135705a631428b3960c" translate="yes" xml:space="preserve">
          <source>beforeCreate</source>
          <target state="translated">beforeCreate</target>
        </trans-unit>
        <trans-unit id="fb7b61aa27d85a7c0d89dbb8710f2b4ce42d0a55" translate="yes" xml:space="preserve">
          <source>beforeDestroy</source>
          <target state="translated">beforeDestroy</target>
        </trans-unit>
        <trans-unit id="86fa6b808c6c10e368e48d1722281f10de42f6e9" translate="yes" xml:space="preserve">
          <source>beforeMount</source>
          <target state="translated">beforeMount</target>
        </trans-unit>
        <trans-unit id="8acebefba44388f598e2b99e8302ab67d355632c" translate="yes" xml:space="preserve">
          <source>beforeUnmount</source>
          <target state="translated">beforeUnmount</target>
        </trans-unit>
        <trans-unit id="fc8ab7b582911146b3b4dd03b3bdbdc1ab81a594" translate="yes" xml:space="preserve">
          <source>beforeUpdate</source>
          <target state="translated">beforeUpdate</target>
        </trans-unit>
        <trans-unit id="77c5f425bb928c51b842ddf1e44748f43c932105" translate="yes" xml:space="preserve">
          <source>bind &amp;rarr; &lt;strong&gt;beforeMount&lt;/strong&gt;</source>
          <target state="translated">バインド&amp;rarr; &lt;strong&gt;beforeMount&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4a9fb8d92972382b39b524ce7f8cdc6213d95500" translate="yes" xml:space="preserve">
          <source>binding</source>
          <target state="translated">binding</target>
        </trans-unit>
        <trans-unit id="8e2b6e21dfdfc190c998d11093ac469ffd7f3aed" translate="yes" xml:space="preserve">
          <source>breaking</source>
          <target state="translated">breaking</target>
        </trans-unit>
        <trans-unit id="e7e9a567c503b2e50fdbc398b040c30a13bd8f80" translate="yes" xml:space="preserve">
          <source>checkboxes and radiobuttons use &lt;code&gt;checked&lt;/code&gt; property and &lt;code&gt;change&lt;/code&gt; event;</source>
          <target state="translated">チェックボックスとラジオボタンは、 &lt;code&gt;checked&lt;/code&gt; プロパティと &lt;code&gt;change&lt;/code&gt; イベントを使用します。</target>
        </trans-unit>
        <trans-unit id="db88192ef37fddf9df1a8a94d3fa600728fa8e81" translate="yes" xml:space="preserve">
          <source>checking your codebase for &lt;code&gt;.sync&lt;/code&gt; usage and replace it with &lt;code&gt;v-model&lt;/code&gt;:</source>
          <target state="translated">コードベースで &lt;code&gt;.sync&lt;/code&gt; の使用状況を確認し、 &lt;code&gt;v-model&lt;/code&gt; に置き換えます。</target>
        </trans-unit>
        <trans-unit id="19cbf9910961b7b720be422c5227a48b45481be1" translate="yes" xml:space="preserve">
          <source>child components don&amp;rsquo;t need to know where injected properties are coming from</source>
          <target state="translated">子コンポーネントは、注入されたプロパティがどこから来ているかを知る必要はありません</target>
        </trans-unit>
        <trans-unit id="42685f11da91a55b1f5c5b782edb2f0fc1dd5148" translate="yes" xml:space="preserve">
          <source>children</source>
          <target state="translated">children</target>
        </trans-unit>
        <trans-unit id="a486e7ea0cf0cfcfc85d9c25120d9f0151c2792b" translate="yes" xml:space="preserve">
          <source>colors displayed</source>
          <target state="translated">表示色</target>
        </trans-unit>
        <trans-unit id="5b17a6c606a82dafd93db84a19945afe2d559ed4" translate="yes" xml:space="preserve">
          <source>comments</source>
          <target state="translated">comments</target>
        </trans-unit>
        <trans-unit id="335c4c1e2f05b5297a56769d8de75ad9c4874cd3" translate="yes" xml:space="preserve">
          <source>component</source>
          <target state="translated">component</target>
        </trans-unit>
        <trans-unit id="ddcc491de82ebec3c03853395e5b60c154cbc452" translate="yes" xml:space="preserve">
          <source>componentUpdated &amp;rarr; &lt;strong&gt;updated&lt;/strong&gt;</source>
          <target state="translated">componentUpdated&amp;rarr;&lt;strong&gt;更新&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c212f08ed1157ae268fd83d142afd5ccd48664b2" translate="yes" xml:space="preserve">
          <source>components</source>
          <target state="translated">components</target>
        </trans-unit>
        <trans-unit id="4ebaef57b71a3ae20e28c13e1420fb5ed634b545" translate="yes" xml:space="preserve">
          <source>computed</source>
          <target state="translated">computed</target>
        </trans-unit>
        <trans-unit id="dfba7aade0868074c2861c98e2a9a92f3178a51b" translate="yes" xml:space="preserve">
          <source>config</source>
          <target state="translated">config</target>
        </trans-unit>
        <trans-unit id="f568e3b2e689e9753b26737cdc027b1633a22b7e" translate="yes" xml:space="preserve">
          <source>createApp</source>
          <target state="translated">createApp</target>
        </trans-unit>
        <trans-unit id="43caa510c0daadd6d3dc4ad43a5427148c2e6d9c" translate="yes" xml:space="preserve">
          <source>createRenderer</source>
          <target state="translated">createRenderer</target>
        </trans-unit>
        <trans-unit id="21c50805b553b7a40e48394a5d77d442587ddee2" translate="yes" xml:space="preserve">
          <source>created</source>
          <target state="translated">created</target>
        </trans-unit>
        <trans-unit id="a17c9aaa61e80a1bf71d0d850af4e5baa9800bbd" translate="yes" xml:space="preserve">
          <source>data</source>
          <target state="translated">data</target>
        </trans-unit>
        <trans-unit id="4858ba92ec21f96af837089e5c3d7e06fcbf313a" translate="yes" xml:space="preserve">
          <source>deactivated</source>
          <target state="translated">deactivated</target>
        </trans-unit>
        <trans-unit id="d8844c3455799a9155c640b8dcfd223ef31c8542" translate="yes" xml:space="preserve">
          <source>defineAsyncComponent</source>
          <target state="translated">defineAsyncComponent</target>
        </trans-unit>
        <trans-unit id="0b351e6c4acf449188607d84ef9ac58fe7aff147" translate="yes" xml:space="preserve">
          <source>defineComponent</source>
          <target state="translated">defineComponent</target>
        </trans-unit>
        <trans-unit id="68b8b8520c00c2719c966d9dcb2bb957972581e7" translate="yes" xml:space="preserve">
          <source>delimiters</source>
          <target state="translated">delimiters</target>
        </trans-unit>
        <trans-unit id="a24bc0a57325762a96243f075d13449452f9b8b0" translate="yes" xml:space="preserve">
          <source>descendant components don&amp;rsquo;t need to know where injected properties are coming from</source>
          <target state="translated">子孫コンポーネントは、注入されたプロパティがどこから来ているかを知る必要はありません</target>
        </trans-unit>
        <trans-unit id="7b148f44e1a22c3e6e463576927f5b9c961fe05d" translate="yes" xml:space="preserve">
          <source>destroyed</source>
          <target state="translated">destroyed</target>
        </trans-unit>
        <trans-unit id="154cfec6bb116856227577921ae39f8885428eb2" translate="yes" xml:space="preserve">
          <source>devtools</source>
          <target state="translated">devtools</target>
        </trans-unit>
        <trans-unit id="3d981bf920ab98c455a9796d062745b9d6b5cbfb" translate="yes" xml:space="preserve">
          <source>directive</source>
          <target state="translated">directive</target>
        </trans-unit>
        <trans-unit id="5b41ba2601e37104d54d7666ca68c4f5e11a1c4c" translate="yes" xml:space="preserve">
          <source>directives</source>
          <target state="translated">directives</target>
        </trans-unit>
        <trans-unit id="064b9e1c3d444b95c7dadc7c61ec024d1be16721" translate="yes" xml:space="preserve">
          <source>does the same thing as:</source>
          <target state="translated">と同じことをします。</target>
        </trans-unit>
        <trans-unit id="72ef9ecc0ee2490979708ebb01e137eae4c8f425" translate="yes" xml:space="preserve">
          <source>e.g. &lt;code&gt;.enter&lt;/code&gt;</source>
          <target state="translated">例： &lt;code&gt;.enter&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f1ea4f09db2aaafb0a92c0b9e57751121ed6647" translate="yes" xml:space="preserve">
          <source>el</source>
          <target state="translated">el</target>
        </trans-unit>
        <trans-unit id="53f9ce69544263d25131c6704271a197bba315a5" translate="yes" xml:space="preserve">
          <source>emits</source>
          <target state="translated">emits</target>
        </trans-unit>
        <trans-unit id="01b78ec3ef69d582c34c04fd02137b4b2a0b2057" translate="yes" xml:space="preserve">
          <source>ensure that all your components document their events with the &lt;code&gt;emits&lt;/code&gt; option.</source>
          <target state="translated">すべてのコンポーネントが &lt;code&gt;emits&lt;/code&gt; オプションを使用してイベントを文書化するようにしてください。</target>
        </trans-unit>
        <trans-unit id="fb8cde4c5110e00e8ab6ca4b7d2c6edd8a17e9ab" translate="yes" xml:space="preserve">
          <source>errorCaptured</source>
          <target state="translated">errorCaptured</target>
        </trans-unit>
        <trans-unit id="4c2276426206f2c8fe07194eb022393389343699" translate="yes" xml:space="preserve">
          <source>errorHandler</source>
          <target state="translated">errorHandler</target>
        </trans-unit>
        <trans-unit id="72f59f31388477ad92fbebfc6b623eb3ba553f3e" translate="yes" xml:space="preserve">
          <source>eslint-plugin-vue</source>
          <target state="translated">eslint-plugin-vue</target>
        </trans-unit>
        <trans-unit id="e9922bd8a80da72306d79eeaf9a6b98cb64268db" translate="yes" xml:space="preserve">
          <source>event: &lt;code&gt;input&lt;/code&gt; -&amp;gt; &lt;code&gt;update:modelValue&lt;/code&gt;;</source>
          <target state="translated">イベント： &lt;code&gt;input&lt;/code&gt; -&amp;gt; &lt;code&gt;update:modelValue&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="b27219f98594d851506e670e303db3d394bbf7d6" translate="yes" xml:space="preserve">
          <source>exposes the same events as &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; と同じイベントを公開します。</target>
        </trans-unit>
        <trans-unit id="eecc8a607a5b6bcf2f4cfccabf69cad7dd41577c" translate="yes" xml:space="preserve">
          <source>exposes the same props as &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; except &lt;code&gt;mode&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; を除いて、 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; と同じプロパティを公開します。</target>
        </trans-unit>
        <trans-unit id="2b781ff8e3327e3e897ec571fa02fec12242e7dd" translate="yes" xml:space="preserve">
          <source>extends</source>
          <target state="translated">extends</target>
        </trans-unit>
        <trans-unit id="9ce5ff458c686cc5e9436295af1c60fa27be6140" translate="yes" xml:space="preserve">
          <source>filters</source>
          <target state="translated">filters</target>
        </trans-unit>
        <trans-unit id="d7eb6b340a11a367a1bec55e4a421d949214759f" translate="yes" xml:space="preserve">
          <source>footer</source>
          <target state="translated">footer</target>
        </trans-unit>
        <trans-unit id="acb51e7c16264c729e7521b40c23a4b9d8986b65" translate="yes" xml:space="preserve">
          <source>for all &lt;code&gt;v-model&lt;/code&gt;s without arguments, make sure to change props and events name to &lt;code&gt;modelValue&lt;/code&gt; and &lt;code&gt;update:modelValue&lt;/code&gt; respectively</source>
          <target state="translated">引数のないすべての &lt;code&gt;v-model&lt;/code&gt; について、小道具とイベントの名前をそれぞれ &lt;code&gt;modelValue&lt;/code&gt; と &lt;code&gt;update:modelValue&lt;/code&gt; に変更してください。</target>
        </trans-unit>
        <trans-unit id="d00b39815c187d832cef3239eb7a77580728dc47" translate="yes" xml:space="preserve">
          <source>form</source>
          <target state="translated">form</target>
        </trans-unit>
        <trans-unit id="abb0afab1fe624aaec8f1353940f7784a64dee93" translate="yes" xml:space="preserve">
          <source>fully support both Vue 1.0 and 2.0</source>
          <target state="translated">Vue 1.0 と 2.0 の両方を完全にサポートしています。</target>
        </trans-unit>
        <trans-unit id="f3605082b0a1ec03cd430e3897145a2220e6a57c" translate="yes" xml:space="preserve">
          <source>functional</source>
          <target state="translated">functional</target>
        </trans-unit>
        <trans-unit id="8574ae3fb0102e604b132e245a7a13501af7382a" translate="yes" xml:space="preserve">
          <source>globalProperties</source>
          <target state="translated">globalProperties</target>
        </trans-unit>
        <trans-unit id="27d5482eebd075de44389774fce28c69f45c8a75" translate="yes" xml:space="preserve">
          <source>h</source>
          <target state="translated">h</target>
        </trans-unit>
        <trans-unit id="594fd1615a341c77829e83ed988f137e1ba96231" translate="yes" xml:space="preserve">
          <source>header</source>
          <target state="translated">header</target>
        </trans-unit>
        <trans-unit id="aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d" translate="yes" xml:space="preserve">
          <source>hello</source>
          <target state="translated">hello</target>
        </trans-unit>
        <trans-unit id="33651e92d7f8755c3775bf7e6f2865577e7988de" translate="yes" xml:space="preserve">
          <source>how to build our package</source>
          <target state="translated">パッケージの構築方法</target>
        </trans-unit>
        <trans-unit id="6066146b8f7a1eae3838af761cd6befdb13e6827" translate="yes" xml:space="preserve">
          <source>ignoredElements</source>
          <target state="translated">ignoredElements</target>
        </trans-unit>
        <trans-unit id="9d11a6da206f5d9ba47bfe6d9f54e66f57219274" translate="yes" xml:space="preserve">
          <source>in 2.6.0+. See &lt;a href=&quot;#Named-Slots&quot;&gt;here&lt;/a&gt; for the new, recommended syntax.</source>
          <target state="translated">2.6.0以降。新しい推奨構文については、&lt;a href=&quot;#Named-Slots&quot;&gt;こちら&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="7f4156caffb807ffaf37ccea584a3b209ba5640a" translate="yes" xml:space="preserve">
          <source>in 2.6.0+. See &lt;a href=&quot;#Scoped-Slots&quot;&gt;here&lt;/a&gt; for the new, recommended syntax.</source>
          <target state="translated">2.6.0以降。新しい推奨構文については、&lt;a href=&quot;#Scoped-Slots&quot;&gt;こちら&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="f7f3f9b4b535ba19cfa1c71d40f8666d3627fdf8" translate="yes" xml:space="preserve">
          <source>inheritAttrs</source>
          <target state="translated">inheritAttrs</target>
        </trans-unit>
        <trans-unit id="3014bf5a29cbc2f5b4c95b4c0f384113201b257e" translate="yes" xml:space="preserve">
          <source>inserted &amp;rarr; &lt;strong&gt;mounted&lt;/strong&gt;</source>
          <target state="translated">挿入&amp;rarr;&lt;strong&gt;マウント&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9587db9f8e8a4535e8dcb6eaa79c2cf675a7519b" translate="yes" xml:space="preserve">
          <source>integrate 3rd-party CSS animation libraries, such as &lt;a href=&quot;https://animate.style/&quot;&gt;Animate.css (opens new window)&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://animate.style/&quot;&gt;Animate.css&lt;/a&gt;などのサードパーティのCSSアニメーションライブラリを統合します（新しいウィンドウを開きます）</target>
        </trans-unit>
        <trans-unit id="66fb24fc087a328881af1d47bdb9a574b63023d8" translate="yes" xml:space="preserve">
          <source>integrate 3rd-party CSS animation libraries, such as Animate.css</source>
          <target state="translated">Animate.cssなどのサードパーティのCSSアニメーションライブラリを統合します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
