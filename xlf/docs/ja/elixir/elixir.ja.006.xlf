<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="6b4e1d5251f6539ac9cb9db6500f4e6878385d0e" translate="yes" xml:space="preserve">
          <source>If you alias a module and you don't use the alias, Elixir is going to issue a warning implying the alias is not being used.</source>
          <target state="translated">モジュールにエイリアスを付けてもエイリアスを使用しない場合、Elixirはエイリアスが使用されていないことを示唆する警告を発行します。</target>
        </trans-unit>
        <trans-unit id="353408b9f20e6cd80af272ea14032adbf9497508" translate="yes" xml:space="preserve">
          <source>If you are connected to remote shell, it remains alive after disconnection.</source>
          <target state="translated">リモートシェルに接続している場合は、切断後も生きています。</target>
        </trans-unit>
        <trans-unit id="efc5604d31d0bf68a1f19a9b171547de1fbb3007" translate="yes" xml:space="preserve">
          <source>If you are interested in implementing an event manager, please read the &quot;Alternatives&quot; section below. If you have to implement an event handler to integrate with an existing system, such as Elixir's Logger, please use &lt;code&gt;:gen_event&lt;/code&gt; instead.</source>
          <target state="translated">イベントマネージャの実装に関心がある場合は、以下の「代替案」セクションをお読みください。ElixirのLoggerなどの既存のシステムと統合するためにイベントハンドラーを実装する必要がある場合は、代わりに &lt;code&gt;:gen_event&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="51ef50c4ad529792706bf2b89ce565387c1909b0" translate="yes" xml:space="preserve">
          <source>If you are looking for a distributed key-value store to use in production, you should definitely look into &lt;a href=&quot;http://basho.com/products/riak-kv/&quot;&gt;Riak&lt;/a&gt;, which also runs in the Erlang</source>
          <target state="translated">本番環境で使用する分散型Key-Valueストアを探している場合は、&lt;a href=&quot;http://basho.com/products/riak-kv/&quot;&gt;Riak&lt;/a&gt;も確認する必要があります。RiakもErlangで実行されます</target>
        </trans-unit>
        <trans-unit id="1c8bab3f8a9ae8447c6ed759b9dc3262c1eec9de" translate="yes" xml:space="preserve">
          <source>If you are on Windows, you will have to open up &lt;code&gt;rel/env.bat.eex&lt;/code&gt;, where you will find this:</source>
          <target state="translated">Windowsを使用している場合は、 &lt;code&gt;rel/env.bat.eex&lt;/code&gt; を開く必要があります。</target>
        </trans-unit>
        <trans-unit id="44c91ebf5be7f8382f751128810946bd95b4f4b2" translate="yes" xml:space="preserve">
          <source>If you are planning to write your first library for other developers to use, don&amp;rsquo;t forget to read our &lt;a href=&quot;https://hexdocs.pm/elixir/library-guidelines.html&quot;&gt;Library Guidelines&lt;/a&gt;.</source>
          <target state="translated">他の開発者が使用する最初のライブラリを作成する場合は、&lt;a href=&quot;https://hexdocs.pm/elixir/library-guidelines.html&quot;&gt;ライブラリガイドライン&lt;/a&gt;を必ずお読みください。</target>
        </trans-unit>
        <trans-unit id="2b2be79d72180600413436f842949c96ba6fb15b" translate="yes" xml:space="preserve">
          <source>If you are setting a &lt;code&gt;@moduletag&lt;/code&gt;, you must set that after your call to &lt;code&gt;use ExUnit.Case&lt;/code&gt; otherwise you will see compilation errors.</source>
          <target state="translated">&lt;code&gt;@moduletag&lt;/code&gt; を設定する場合は、呼び出し後に &lt;code&gt;use ExUnit.Case&lt;/code&gt; を使用するように設定する必要があります。そうしないと、コンパイルエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="e14a93bec8f9e7583ef7d4636212d137d7df029a" translate="yes" xml:space="preserve">
          <source>If you are using async tasks, you &lt;strong&gt;must await&lt;/strong&gt; a reply as they are &lt;em&gt;always&lt;/em&gt; sent. If you are not expecting a reply, consider using &lt;a href=&quot;task#start_link/1&quot;&gt;&lt;code&gt;Task.start_link/1&lt;/code&gt;&lt;/a&gt; detailed below.</source>
          <target state="translated">非同期タスクを使用している&lt;em&gt;場合&lt;/em&gt;は、&lt;em&gt;常に&lt;/em&gt;送信される&lt;strong&gt;ため&lt;/strong&gt;、返信を&lt;strong&gt;待つ必要&lt;/strong&gt;が&lt;strong&gt;あり&lt;/strong&gt;ます。返信がない場合は、下記の&lt;a href=&quot;task#start_link/1&quot;&gt; &lt;code&gt;Task.start_link/1&lt;/code&gt; の&lt;/a&gt;使用を検討してください。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f469101752f119e7e176bed241907b041da8adaa" translate="yes" xml:space="preserve">
          <source>If you are using releases, see &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt;&lt;code&gt;mix release&lt;/code&gt;&lt;/a&gt;, there another configuration file called &lt;code&gt;config/releases.exs&lt;/code&gt;. While &lt;code&gt;config/config.exs&lt;/code&gt; and friends mentioned in the previous section are executed whenever you run a Mix command, including when you assemble a release, &lt;code&gt;config/releases.exs&lt;/code&gt; is execute every time your production system boots. Since Mix is not available in a production system, &lt;code&gt;config/releases.exs&lt;/code&gt; must not use any of the functions from Mix.</source>
          <target state="translated">リリースを使用している場合は、「&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt; &lt;code&gt;mix release&lt;/code&gt; &lt;/a&gt;リリース」を参照してください &lt;code&gt;config/releases.exs&lt;/code&gt; という別の構成ファイルがあります。一方で &lt;code&gt;config/config.exs&lt;/code&gt; や友人は、前のセクションで述べたあなたがミックスのコマンドを実行するたびに、リリースを組み立てる際に、含めて、実行されている &lt;code&gt;config/releases.exs&lt;/code&gt; 本番システムが起動するたびに実行されます。Mixは本番システムでは使用できないため、 &lt;code&gt;config/releases.exs&lt;/code&gt; はMixの関数を使用してはなりません。</target>
        </trans-unit>
        <trans-unit id="9e377e363c18762d6989f073da394e35ff6a1d87" translate="yes" xml:space="preserve">
          <source>If you are using several functions from a given module, you can import those functions and reference them as local functions, for example:</source>
          <target state="translated">与えられたモジュールから複数の関数を使用している場合は、それらの関数をインポートしてローカル関数として参照することができます。</target>
        </trans-unit>
        <trans-unit id="d9f991b27b559271b270b3fbea782f7486b09a69" translate="yes" xml:space="preserve">
          <source>If you attempt to define a module that already exists, you will get a warning saying that a module has been redefined.</source>
          <target state="translated">既に存在するモジュールを定義しようとすると、モジュールが再定義されたという警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="8adfc9342331c8cadc540a2cd5ed23c3faf380ba" translate="yes" xml:space="preserve">
          <source>If you connect to localhost once again and perform another request, now everything should work, as long as the routing table contains the correct node names. Outstanding!</source>
          <target state="translated">もう一度ローカルホストに接続して別のリクエストを実行すれば、ルーティングテーブルに正しいノード名が含まれている限り、すべてが動作するはずです。素晴らしい!</target>
        </trans-unit>
        <trans-unit id="9a27ffb13441db905f42c43f88d86b47f09d7485" translate="yes" xml:space="preserve">
          <source>If you create a task using &lt;code&gt;async_nolink&lt;/code&gt; inside an OTP behaviour like &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, you should match on the message coming from the task inside your &lt;a href=&quot;genserver#c:handle_info/2&quot;&gt;&lt;code&gt;GenServer.handle_info/2&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">あなたが使用してタスクを作成する場合 &lt;code&gt;async_nolink&lt;/code&gt; をのようなOTP行動の内側&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;、あなたの内部タスクからのメッセージに一致している必要があり&lt;a href=&quot;genserver#c:handle_info/2&quot;&gt; &lt;code&gt;GenServer.handle_info/2&lt;/code&gt; &lt;/a&gt;コールバック。</target>
        </trans-unit>
        <trans-unit id="55b7d0164ac505a2fe344467d02c4867bf511345" translate="yes" xml:space="preserve">
          <source>If you desire to execute a trusted command inside a shell, with pipes, redirecting and so on, please check &lt;a href=&quot;http://www.erlang.org/doc/man/os.html#cmd-1&quot;&gt;&lt;code&gt;:os.cmd/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">パイプやリダイレクトなどを使用してシェル内で信頼できるコマンドを実行したい場合は、&lt;a href=&quot;http://www.erlang.org/doc/man/os.html#cmd-1&quot;&gt; &lt;code&gt;:os.cmd/1&lt;/code&gt; &lt;/a&gt;を確認してください。</target>
        </trans-unit>
        <trans-unit id="a07182ef0f8b88c81a61025e684458268493b23a" translate="yes" xml:space="preserve">
          <source>If you do not care about the results of the computation, you can run the stream with &lt;a href=&quot;stream#run/1&quot;&gt;&lt;code&gt;Stream.run/1&lt;/code&gt;&lt;/a&gt;. Also set &lt;code&gt;ordered: false&lt;/code&gt;, as you don't care about the order of the results either:</source>
          <target state="translated">計算結果を気にしない場合は、&lt;a href=&quot;stream#run/1&quot;&gt; &lt;code&gt;Stream.run/1&lt;/code&gt; を使用し&lt;/a&gt;てストリームを実行できます。また、 &lt;code&gt;ordered: false&lt;/code&gt; 設定します。結果の順序も気にしないからです。</target>
        </trans-unit>
        <trans-unit id="368841cd2351fb8c28d9325238a5752ebba7a138" translate="yes" xml:space="preserve">
          <source>If you do want to parse unknown switches, remember that Elixir converts switches to atoms. Since atoms are not garbage-collected, OptionParser will only parse switches that translate to atoms used by the runtime to avoid leaking atoms. For instance, the code below will discard the &lt;code&gt;--option-parser-example&lt;/code&gt; switch because the &lt;code&gt;:option_parser_example&lt;/code&gt; atom is never used anywhere:</source>
          <target state="translated">未知のスイッチを解析したい場合は、Elixirがスイッチをアトムに変換することを覚えておいてください。アトムはガベージコレクションされないため、OptionParserは、ランタイムによって使用されるアトムに変換されるスイッチのみを解析して、アトムのリークを回避します。たとえば、 &lt;code&gt;:option_parser_example&lt;/code&gt; アトムはどこでも使用されないため、以下のコードは &lt;code&gt;--option-parser-example&lt;/code&gt; スイッチを破棄します。</target>
        </trans-unit>
        <trans-unit id="bb3116d6b170b69080991a7150c103095c5454b2" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have any use for the error, you don&amp;rsquo;t have to provide it:</source>
          <target state="translated">エラーを使用する必要がない場合は、提供する必要はありません。</target>
        </trans-unit>
        <trans-unit id="c77ad5b32204a8ca68d3f5ddb986c84f0f9228ac" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify a default key value when defining a struct, &lt;code&gt;nil&lt;/code&gt; will be assumed:</source>
          <target state="translated">構造体を定義するときにデフォルトのキー値を指定しない場合、 &lt;code&gt;nil&lt;/code&gt; が想定されます。</target>
        </trans-unit>
        <trans-unit id="2c6d6c827a17a1772b5dade87fd7f321c6f06b85" translate="yes" xml:space="preserve">
          <source>If you don't need a process, then you don't need a process. Use processes only to model runtime properties, such as mutable state, concurrency and failures, never for code organization.</source>
          <target state="translated">プロセスが必要ないのであれば、プロセスは必要ありません。プロセスはランタイムプロパティのモデル化にのみ使用してください。</target>
        </trans-unit>
        <trans-unit id="55f782e4dd6bf586b9ca7b60f48c228585b2ac7c" translate="yes" xml:space="preserve">
          <source>If you don't want to import a function or macro from &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;, use the &lt;code&gt;:except&lt;/code&gt; option and then list the function/macro by arity:</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;から関数またはマクロをインポートしたくない場合は、 &lt;code&gt;:except&lt;/code&gt; オプションを使用して、関数/マクロをアリティ別にリストします。</target>
        </trans-unit>
        <trans-unit id="b0fdad62ae1fb19bf40fae581950eb21ad57ac2c" translate="yes" xml:space="preserve">
          <source>If you don't want to link the caller to the task, then you must use a supervised task with &lt;a href=&quot;task.supervisor&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; and call &lt;a href=&quot;task.supervisor#async_nolink/2&quot;&gt;&lt;code&gt;Task.Supervisor.async_nolink/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">呼び出し元をタスクにリンクしたくない場合は、&lt;a href=&quot;task.supervisor&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; で&lt;/a&gt;監視対象タスクを使用し、&lt;a href=&quot;task.supervisor#async_nolink/2&quot;&gt; &lt;code&gt;Task.Supervisor.async_nolink/2&lt;/code&gt; &lt;/a&gt;を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="a8b7f3eba3dd98ca6590eeed6ea68a53ee96f3d2" translate="yes" xml:space="preserve">
          <source>If you don't want to remove all the entries associated with &lt;code&gt;key&lt;/code&gt; use &lt;a href=&quot;#pop_first/3&quot;&gt;&lt;code&gt;pop_first/3&lt;/code&gt;&lt;/a&gt; instead, that function will remove only the first entry.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 関連付けられているすべてのエントリを削除したくない場合は、代わりに&lt;a href=&quot;#pop_first/3&quot;&gt; &lt;code&gt;pop_first/3&lt;/code&gt; を&lt;/a&gt;使用すると、その関数は最初のエントリのみを削除します。</target>
        </trans-unit>
        <trans-unit id="296ef732a2b3390cd10f991ad01cb9a80eb4f583" translate="yes" xml:space="preserve">
          <source>If you expect a project to be defined, i.e., it is a requirement of the current task, you should call &lt;a href=&quot;#get!/0&quot;&gt;&lt;code&gt;get!/0&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">プロジェクトの定義が必要な場合、つまり、現在のタスクの要件である場合は、代わりに&lt;a href=&quot;#get!/0&quot;&gt; &lt;code&gt;get!/0&lt;/code&gt; を&lt;/a&gt;呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="05da62df25733918acb3c100ca6eefcc7e8a9a05" translate="yes" xml:space="preserve">
          <source>If you find any errors in the tutorial or on the website, &lt;a href=&quot;https://github.com/elixir-lang/elixir-lang.github.com&quot;&gt;please report a bug or send a pull request to our issue tracker&lt;/a&gt;.</source>
          <target state="translated">チュートリアルまたはWebサイトでエラーを見つけた場合は&lt;a href=&quot;https://github.com/elixir-lang/elixir-lang.github.com&quot;&gt;、バグを報告するか、プルリクエストをIssue Trackerに送信してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3352da2349194da360a70c60c5b2d7bfce63e72d" translate="yes" xml:space="preserve">
          <source>If you find yourself in a position where you want to use different configurations in each application for the same dependency or use different dependency versions, then it is likely your codebase has grown beyond what umbrellas can provide.</source>
          <target state="translated">もしあなた自身が、同じ依存関係に対して各アプリケーションで異なる設定を使用したり、異なる依存関係のバージョンを使用したりしたいと考えているのであれば、あなたのコードベースがアンブレラが提供できる以上に成長している可能性が高いでしょう。</target>
        </trans-unit>
        <trans-unit id="966f4145842556d60eacaa5cb05900d76971a573" translate="yes" xml:space="preserve">
          <source>If you find yourself trapping exits to handle exits inside the async stream, consider using &lt;a href=&quot;#async_stream_nolink/6&quot;&gt;&lt;code&gt;async_stream_nolink/6&lt;/code&gt;&lt;/a&gt; to start tasks that are not linked to the calling process.</source>
          <target state="translated">非同期ストリーム内の出口を処理するために出口をトラップしている場合は、&lt;a href=&quot;#async_stream_nolink/6&quot;&gt; &lt;code&gt;async_stream_nolink/6&lt;/code&gt; &lt;/a&gt;を使用して、呼び出しプロセスにリンクされていないタスクを開始することを検討してください。</target>
        </trans-unit>
        <trans-unit id="4197dd8400c648df18d603e11d970a3cb8836276" translate="yes" xml:space="preserve">
          <source>If you forget to escape it, Elixir will raise an error when compiling the code.</source>
          <target state="translated">エスケープを忘れた場合、Elixirはコードをコンパイルする際にエラーを発生させます。</target>
        </trans-unit>
        <trans-unit id="56efc6ca629edeb2fce03d19b2bc73e5833972b7" translate="yes" xml:space="preserve">
          <source>If you have a file that needs to compile other modules in parallel, the spawned processes need to be aware of the compiler environment. This function allows a developer to create a task that is aware of those environments.</source>
          <target state="translated">他のモジュールを並行してコンパイルする必要があるファイルがある場合、スポーンされるプロセスはコンパイラ環境を意識する必要があります。この関数を使うことで、開発者はそれらの環境を意識したタスクを作成することができます。</target>
        </trans-unit>
        <trans-unit id="772ddb24d9ed2ed3cd849be346856ed163202199" translate="yes" xml:space="preserve">
          <source>If you have a struct and you would like to merge a set of keys into the struct, do not use this function, as it would merge all keys on the right side into the struct, even if the key is not part of the struct. Instead, use &lt;a href=&quot;kernel#struct/2&quot;&gt;&lt;code&gt;Kernel.struct/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">構造体があり、キーのセットを構造体にマージする場合は、この関数を使用しないでください。キーが構造体の一部でなくても、右側のすべてのキーが構造体にマージされます。代わりに、&lt;a href=&quot;kernel#struct/2&quot;&gt; &lt;code&gt;Kernel.struct/2&lt;/code&gt; を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="02d90c57cd4c0d17ad045bc9f12b98eb64e0aa31" translate="yes" xml:space="preserve">
          <source>If you have an internal dependency, Mix supports two methods to work with them: Git repositories or umbrella projects.</source>
          <target state="translated">内部に依存関係がある場合、Mixはそれらを扱うための2つの方法をサポートしています。Git リポジトリかアンブレラプロジェクトです。</target>
        </trans-unit>
        <trans-unit id="4e035a407e624050895eb31725f1748d9f855294" translate="yes" xml:space="preserve">
          <source>If you have another computer on the same network with both Erlang and Elixir installed, you can start another shell on it. If you don&amp;rsquo;t, you can start another IEx session in another terminal. In either case, give it the short name of &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">ErlangとElixirの両方がインストールされている同じネットワーク上に別のコンピューターがある場合は、そのコンピューターで別のシェルを起動できます。そうでない場合は、別の端末で別のIExセッションを開始できます。どちらの場合も、短い名前の &lt;code&gt;bar&lt;/code&gt; を付けます。</target>
        </trans-unit>
        <trans-unit id="91e486a025ad182f48607bffbb20dc17512610a7" translate="yes" xml:space="preserve">
          <source>If you have any questions or improvements to the guide, please reach discussion channels such as the &lt;a href=&quot;https://elixirforum.com&quot;&gt;Elixir Forum&lt;/a&gt; or the &lt;a href=&quot;https://github.com/elixir-lang/elixir-lang.github.com/issues&quot;&gt;issues tracker&lt;/a&gt;. Your input is really important to help us guarantee the guides are accessible and up to date!</source>
          <target state="translated">このガイドについて質問や改善がある場合は、&lt;a href=&quot;https://elixirforum.com&quot;&gt;Elixirフォーラム&lt;/a&gt;や&lt;a href=&quot;https://github.com/elixir-lang/elixir-lang.github.com/issues&quot;&gt;問題トラッカー&lt;/a&gt;などのディスカッションチャネルにアクセスしてください。あなたの入力は、ガイドがアクセス可能で最新であることを保証するために本当に重要です！</target>
        </trans-unit>
        <trans-unit id="aab49794b532da97c155763d4fee42c69953f3cd" translate="yes" xml:space="preserve">
          <source>If you have prior programming experience, you may be wondering: &amp;ldquo;could we just guarantee the bucket does not crash in the first place?&amp;rdquo;. As we will see, Elixir developers tend to refer to those practices as &amp;ldquo;defensive programming&amp;rdquo;. That&amp;rsquo;s because a live production system has dozens of different reasons why something can go wrong. The disk can fail, memory can be corrupted, bugs, the network may stop working for a second, etc. If we were to write software that attempted to protect or circumvent all of those errors, we would spend more time handling failures than writing our own software!</source>
          <target state="translated">以前にプログラミングの経験がある場合は、「バケットが最初からクラッシュしないことを保証できますか？」と疑問に思われるかもしれません。後で見るように、Elixir開発者はそれらのプラクティスを「防御的プログラミング」と呼ぶ傾向があります。これは、ライブプロダクションシステムには、何かがうまくいかない理由が多数あるためです。ディスクに障害が発生したり、メモリが破損したり、バグが発生したり、ネットワークが1秒間機能しなくなったりする場合があります。これらのエラーをすべて保護または回避しようとするソフトウェアを作成した場合、独自のソフトウェア！</target>
        </trans-unit>
        <trans-unit id="4ff3bc0809c7cb590dd86540f6bc9220ad4b14e5" translate="yes" xml:space="preserve">
          <source>If you have skipped the Getting Started guide or read it long ago, be sure to re-read the &lt;a href=&quot;../processes&quot;&gt;Processes&lt;/a&gt; chapter. We will use it as a starting point.</source>
          <target state="translated">入門ガイドをスキップしたり、ずっと前に読んだりした場合は、必ず「&lt;a href=&quot;../processes&quot;&gt;プロセス」の&lt;/a&gt;章をもう一度読んでください。出発点として使用します。</target>
        </trans-unit>
        <trans-unit id="d5e749fd5e08cb28911eb18410413620f0bb3b45" translate="yes" xml:space="preserve">
          <source>If you have to, you can think of behaviours like interfaces in object oriented languages like Java: a set of function signatures that a module has to implement.</source>
          <target state="translated">必要であれば、Javaのようなオブジェクト指向言語のインターフェースのような振る舞いを考えることができます:モジュールが実装しなければならない関数シグネチャのセット。</target>
        </trans-unit>
        <trans-unit id="775881310bd0276caea4cdc0616b4fb21efd691c" translate="yes" xml:space="preserve">
          <source>If you haven&amp;rsquo;t yet installed Elixir, visit our &lt;a href=&quot;https://elixir-lang.org/install.html&quot;&gt;installation page&lt;/a&gt;. Once you are done, you can run &lt;code&gt;elixir --version&lt;/code&gt; to get the current Elixir version.</source>
          <target state="translated">Elixirをまだインストールしていない場合は、&lt;a href=&quot;https://elixir-lang.org/install.html&quot;&gt;インストールページ&lt;/a&gt;にアクセスしてください。完了したら、 &lt;code&gt;elixir --version&lt;/code&gt; を実行して、現在のElixirバージョンを取得できます。</target>
        </trans-unit>
        <trans-unit id="68dc8f62a9e86b3efbf7155da89ee4b3f7fa0def" translate="yes" xml:space="preserve">
          <source>If you import a module and you don't use any of the imported functions or macros from this module, Elixir is going to issue a warning implying the import is not being used.</source>
          <target state="translated">モジュールをインポートしても、そのモジュールからインポートした関数やマクロを使用しない場合、Elixirはインポートが使用されていないことを示唆する警告を発行します。</target>
        </trans-unit>
        <trans-unit id="dd8b4968a8e609a12b5b450ac372d4f06174ea20" translate="yes" xml:space="preserve">
          <source>If you intend to shut the task down if it has not responded within &lt;code&gt;timeout&lt;/code&gt; milliseconds, you should chain this together with &lt;a href=&quot;#shutdown/1&quot;&gt;&lt;code&gt;shutdown/1&lt;/code&gt;&lt;/a&gt;, like so:</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; ミリ秒以内に応答がない場合にタスクをシャットダウンする場合は、次のように&lt;a href=&quot;#shutdown/1&quot;&gt; &lt;code&gt;shutdown/1&lt;/code&gt; &lt;/a&gt;と一緒にチェーンする必要があります。</target>
        </trans-unit>
        <trans-unit id="83089d9b73e4091162a26829945c724a24daa00a" translate="yes" xml:space="preserve">
          <source>If you know you are running on a different system that the current one and you are doing multiple matches with the regex, you can manually invoke &lt;a href=&quot;regex#recompile/1&quot;&gt;&lt;code&gt;Regex.recompile/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;regex#recompile!/1&quot;&gt;&lt;code&gt;Regex.recompile!/1&lt;/code&gt;&lt;/a&gt; to perform a runtime version check and recompile the regex if necessary.</source>
          <target state="translated">現在のシステムとは異なるシステムで実行していて、正規表現と複数の一致を行っていることがわかっている場合は、手動で&lt;a href=&quot;regex#recompile/1&quot;&gt; &lt;code&gt;Regex.recompile/1&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;regex#recompile!/1&quot;&gt; &lt;code&gt;Regex.recompile!/1&lt;/code&gt; &lt;/a&gt;を呼び出して、ランタイムバージョンチェックを実行し、正規表現を再コンパイルできます。必要であれば。</target>
        </trans-unit>
        <trans-unit id="3c864040fa40407fd79ba39543ee8e3143a0a20c" translate="yes" xml:space="preserve">
          <source>If you need a general dictionary, use the &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; module. If you need to manipulate keyword lists, use &lt;a href=&quot;keyword&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一般的な辞書が必要な場合は、&lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt;モジュールを使用してください。キーワードリストを操作する必要がある場合は、&lt;a href=&quot;keyword&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="89167dae9b93318185a943b4d7ef66af8fd1ecaf" translate="yes" xml:space="preserve">
          <source>If you need to convert a tuple or a module child specification to a map or modify a child specification, you can use the &lt;a href=&quot;supervisor#child_spec/2&quot;&gt;&lt;code&gt;Supervisor.child_spec/2&lt;/code&gt;&lt;/a&gt; function. For example, to run the stack with a different &lt;code&gt;:id&lt;/code&gt; and a &lt;code&gt;:shutdown&lt;/code&gt; value of 10 seconds (10_000 milliseconds):</source>
          <target state="translated">タプルまたはモジュールの子仕様をマップに変換する必要がある場合、または子仕様を変更する必要がある場合は、&lt;a href=&quot;supervisor#child_spec/2&quot;&gt; &lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; &lt;/a&gt;関数を使用できます。たとえば、異なる &lt;code&gt;:id&lt;/code&gt; と10秒（10_000ミリ秒）の： &lt;code&gt;:shutdown&lt;/code&gt; 値でスタックを実行するには：</target>
        </trans-unit>
        <trans-unit id="5ad76921951319e02147caba8a55f21b979bd0dc" translate="yes" xml:space="preserve">
          <source>If you need to pass options to the Elixir executable at the same time you use &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt;, it can be done as follows:</source>
          <target state="translated">Elixir実行可能ファイルにオプションを渡すと同時に&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;mix run&lt;/code&gt; &lt;/a&gt;を使用する必要がある場合は、次のように実行できます。</target>
        </trans-unit>
        <trans-unit id="f6c0541d61f0fa3dc5971ad5a9aedc3239c20f25" translate="yes" xml:space="preserve">
          <source>If you open up &lt;code&gt;rel/env.sh.eex&lt;/code&gt;, you will see:</source>
          <target state="translated">あなたが開く場合 &lt;code&gt;rel/env.sh.eex&lt;/code&gt; 、あなたが表示されます。</target>
        </trans-unit>
        <trans-unit id="13001202c030e74a6a243756fd13162b4aa903b4" translate="yes" xml:space="preserve">
          <source>If you pass &lt;code&gt;:trim_bom&lt;/code&gt; in the modes parameter, the stream will trim UTF-8, UTF-16 and UTF-32 byte order marks when reading from file.</source>
          <target state="translated">モードパラメータで &lt;code&gt;:trim_bom&lt;/code&gt; を渡すと、ストリームはファイルから読み取るときにUTF-8、UTF-16、およびUTF-32バイトオーダーマークをトリムします。</target>
        </trans-unit>
        <trans-unit id="728af62f46ec9153dd25f06ee03542653209b55d" translate="yes" xml:space="preserve">
          <source>If you prefer to use only operators or skip them, you can pass the following options:</source>
          <target state="translated">演算子のみを使用したい場合や、演算子をスキップしたい場合は、以下のオプションを渡すことができます。</target>
        </trans-unit>
        <trans-unit id="cd3676cec1bf0b821202c618090e6007102597bd" translate="yes" xml:space="preserve">
          <source>If you revisit the &lt;code&gt;KV.Registry.start_link/1&lt;/code&gt; implementation, you will remember it simply passes the options to GenServer:</source>
          <target state="translated">あなたが再訪した場合 &lt;code&gt;KV.Registry.start_link/1&lt;/code&gt; の実装を、あなたはそれが単にGenServerにオプションを渡し覚えているでしょう。</target>
        </trans-unit>
        <trans-unit id="c5d6222828dfd649eaac97782a9142f48d5d1965" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;bin/foo start&lt;/code&gt;, it will start the system using a short name (&lt;code&gt;--sname&lt;/code&gt;) equal to the release name, which in this case is &lt;code&gt;foo&lt;/code&gt;. The next step is to start a system named &lt;code&gt;bar&lt;/code&gt;, so we can connect &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; together, like we did in the previous chapter. But before we achieve this, let&amp;rsquo;s talk a bit about the benefits of releases.</source>
          <target state="translated">&lt;code&gt;bin/foo start&lt;/code&gt; を実行すると、リリース名（この場合は &lt;code&gt;foo&lt;/code&gt; ）と同じ短い名前（ &lt;code&gt;--sname&lt;/code&gt; ）を使用してシステムが起動します。次のステップは、システムの名前を開始することである &lt;code&gt;bar&lt;/code&gt; 我々が接続できるように、 &lt;code&gt;foo&lt;/code&gt; し、 &lt;code&gt;bar&lt;/code&gt; 、我々は前の章で行ったように、一緒に。しかし、これを達成する前に、リリースの利点について少し話しましょう。</target>
        </trans-unit>
        <trans-unit id="b99f38f9001edc5d832c83870cb64c18a6a5f599" translate="yes" xml:space="preserve">
          <source>If you start &lt;code&gt;bar&lt;/code&gt; while &lt;code&gt;foo&lt;/code&gt; is still running, you will see an error like the error below happen 5 times, before the application finally shuts down:</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; の実行中に &lt;code&gt;bar&lt;/code&gt; を開始すると、アプリケーションが最終的にシャットダウンする前に、以下のエラーのようなエラーが5回発生します。</target>
        </trans-unit>
        <trans-unit id="b481bb0915de73d372e211939b206d16352c309c" translate="yes" xml:space="preserve">
          <source>If you supply &lt;code&gt;message&lt;/code&gt;, information about the values will automatically be appended to it.</source>
          <target state="translated">ユーザーが指定する場合は &lt;code&gt;message&lt;/code&gt; 、値に関する情報が自動的に追加されます。</target>
        </trans-unit>
        <trans-unit id="b5d18cb7539ec0d5066e34df4b08df26b2985b68" translate="yes" xml:space="preserve">
          <source>If you try to run our new macro, you will notice it won't even compile, complaining that the variables &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; do not exist. This is because of the ambiguity: &lt;code&gt;unquote(k)&lt;/code&gt; can either be an unquote fragment, as previously, or a regular unquote as in &lt;code&gt;unquote(kv)&lt;/code&gt;.</source>
          <target state="translated">新しいマクロを実行しようとすると、コンパイルされず、変数 &lt;code&gt;k&lt;/code&gt; と &lt;code&gt;v&lt;/code&gt; が存在しないと不平を言うことに気付くでしょう。これはあいまいさのためです &lt;code&gt;unquote(k)&lt;/code&gt; は、以前のように非引用フラグメントであるか、 &lt;code&gt;unquote(kv)&lt;/code&gt; のように通常の非引用である可能性があります。</target>
        </trans-unit>
        <trans-unit id="3166b78eca5a26a7eac84dac5d70e8123ee75f4d" translate="yes" xml:space="preserve">
          <source>If you try to use &lt;a href=&quot;#iodata_to_binary/1&quot;&gt;&lt;code&gt;iodata_to_binary/1&lt;/code&gt;&lt;/a&gt; on chardata, it will result in an argument error. For example, let's try to put a codepoint that is not representable with one byte, like &lt;code&gt;?&amp;pi;&lt;/code&gt;, inside IO data:</source>
          <target state="translated">&lt;a href=&quot;#iodata_to_binary/1&quot;&gt; &lt;code&gt;iodata_to_binary/1&lt;/code&gt; &lt;/a&gt;を使用しようとすると、引数エラーが発生します。たとえば、 &lt;code&gt;?&amp;pi;&lt;/code&gt; のように1バイトで表現できないコードポイントをIOデータ内に配置してみましょう。</target>
        </trans-unit>
        <trans-unit id="6388f463dc6fcda17ad270beeb69b562f1892d55" translate="yes" xml:space="preserve">
          <source>If you want the task to always be restarted:</source>
          <target state="translated">タスクを常に再起動させたい場合。</target>
        </trans-unit>
        <trans-unit id="2e6f3a865c14b0ab4a00bc5b2ae75499da91323c" translate="yes" xml:space="preserve">
          <source>If you want to capture a function from a module, you can do &lt;code&gt;&amp;amp;Module.function()&lt;/code&gt;:</source>
          <target state="translated">モジュールから関数をキャプチャしたい場合は、 &lt;code&gt;&amp;amp;Module.function()&lt;/code&gt; を実行できます：</target>
        </trans-unit>
        <trans-unit id="3f5f07477ffa4335e8ddfc815683832c8430bb08" translate="yes" xml:space="preserve">
          <source>If you want to convert a string-formatted float directly to a float, &lt;a href=&quot;string#to_float/1&quot;&gt;&lt;code&gt;String.to_float/1&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">文字列形式の浮動小数点数を直接浮動小数点数に変換する場合は、&lt;a href=&quot;string#to_float/1&quot;&gt; &lt;code&gt;String.to_float/1&lt;/code&gt; &lt;/a&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="f1f915523fedc99105cfc5944c2a0f3c36308efa" translate="yes" xml:space="preserve">
          <source>If you want to convert a string-formatted integer directly to an integer, &lt;a href=&quot;string#to_integer/1&quot;&gt;&lt;code&gt;String.to_integer/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;string#to_integer/2&quot;&gt;&lt;code&gt;String.to_integer/2&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">文字列形式の整数を直接整数に変換する場合は、&lt;a href=&quot;string#to_integer/1&quot;&gt; &lt;code&gt;String.to_integer/1&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;string#to_integer/2&quot;&gt; &lt;code&gt;String.to_integer/2&lt;/code&gt; &lt;/a&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="fea9eb1c1234b827775e497ef0f42a61c69dfa13" translate="yes" xml:space="preserve">
          <source>If you want to copy contents from an IO device to another device or do a straight copy from a source to a destination without preserving modes, check &lt;a href=&quot;#copy/3&quot;&gt;&lt;code&gt;copy/3&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">コンテンツをIOデバイスから別のデバイスにコピーする場合、またはモードを維持せずにソースから宛先に直接コピーする場合は、代わりに&lt;a href=&quot;#copy/3&quot;&gt; &lt;code&gt;copy/3&lt;/code&gt; を&lt;/a&gt;オンにします。</target>
        </trans-unit>
        <trans-unit id="b19bfe43f6139c3e91cf27f55ce846cdfcd3e3c1" translate="yes" xml:space="preserve">
          <source>If you want to customize formatting through a custom formatter, you can pass a &lt;code&gt;{module, function}&lt;/code&gt; tuple as the &lt;code&gt;pattern&lt;/code&gt;.</source>
          <target state="translated">カスタムフォーマッタを使用してフォーマットをカスタマイズする場合は、 &lt;code&gt;{module, function}&lt;/code&gt; タプルを &lt;code&gt;pattern&lt;/code&gt; として渡すことができます。</target>
        </trans-unit>
        <trans-unit id="65bb6ace50313174bd1da312015129749bbdebb7" translate="yes" xml:space="preserve">
          <source>If you want to denote that keys that were not previously defined in the map are allowed, it is common to end a map type with &lt;code&gt;optional(any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="translated">以前にマップで定義されていなかったキーが許可されることを示す場合は、 &lt;code&gt;optional(any) =&amp;gt; any&lt;/code&gt; マップタイプをoptional（any）=&amp;gt; anyで終了するのが一般的です。</target>
        </trans-unit>
        <trans-unit id="c535a2a3105fc470fcf848d917b271f0d69918bc" translate="yes" xml:space="preserve">
          <source>If you want to keep a custom type private, you can use the &lt;code&gt;@typep&lt;/code&gt; directive instead of &lt;code&gt;@type&lt;/code&gt;.</source>
          <target state="translated">カスタムタイプをプライベートにしたい場合は、 &lt;code&gt;@typep&lt;/code&gt; 代わりに &lt;code&gt;@type&lt;/code&gt; pディレクティブを使用できます。</target>
        </trans-unit>
        <trans-unit id="6270ce3f8ed8957cf75b8c1784c6e548f99f8963" translate="yes" xml:space="preserve">
          <source>If you want to pattern match against an existing variable, you need to use the &lt;a href=&quot;#%255E/1&quot;&gt;&lt;code&gt;^/1&lt;/code&gt;&lt;/a&gt; operator:</source>
          <target state="translated">既存の変数に対してパターンマッチングを行う場合は、&lt;a href=&quot;#%255E/1&quot;&gt; &lt;code&gt;^/1&lt;/code&gt; &lt;/a&gt;演算子を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="0120649e8c4e2ba95fe6dca09a77ff652ec92d44" translate="yes" xml:space="preserve">
          <source>If you want to pattern match against an existing variable, you need to use the &lt;code&gt;^&lt;/code&gt; operator:</source>
          <target state="translated">既存の変数に対してパターンマッチングを行う場合は、 &lt;code&gt;^&lt;/code&gt; 演算子を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="8611f45920c0ede3319c28e69a832c8f54905818" translate="yes" xml:space="preserve">
          <source>If you want to perform ceil operation on other decimal places, use &lt;a href=&quot;float#ceil/2&quot;&gt;&lt;code&gt;Float.ceil/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">他の小数位でceil演算を実行する場合は、代わりに&lt;a href=&quot;float#ceil/2&quot;&gt; &lt;code&gt;Float.ceil/2&lt;/code&gt; を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="f71b7086446556c1e0c878a9ce96ae97c6d27fc0" translate="yes" xml:space="preserve">
          <source>If you want to perform floor operation on other decimal places, use &lt;a href=&quot;float#floor/2&quot;&gt;&lt;code&gt;Float.floor/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">他の小数位でフロア演算を実行する場合は、代わりに&lt;a href=&quot;float#floor/2&quot;&gt; &lt;code&gt;Float.floor/2&lt;/code&gt; を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="e7d23f8f45e8ee5b1da8fce75c5c1d7be726d5c9" translate="yes" xml:space="preserve">
          <source>If you want to perform floored integer division (rounding towards negative infinity), use &lt;a href=&quot;integer#floor_div/2&quot;&gt;&lt;code&gt;Integer.floor_div/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">フロア整数除算（負の無限大に丸める）を実行する場合は、代わりに&lt;a href=&quot;integer#floor_div/2&quot;&gt; &lt;code&gt;Integer.floor_div/2&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="7d5cba5ee293ef2a94c294f0400855682db25758" translate="yes" xml:space="preserve">
          <source>If you want to perform truncated integer division (rounding towards zero), use &lt;a href=&quot;kernel#div/2&quot;&gt;&lt;code&gt;Kernel.div/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">切り捨てられた整数除算（ゼロに向かって丸める）を実行する場合は、代わりに&lt;a href=&quot;kernel#div/2&quot;&gt; &lt;code&gt;Kernel.div/2&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="097c0e312bb8668d5ea944da5700770a1becb6c4" translate="yes" xml:space="preserve">
          <source>If you want to purge all log calls from an application named &lt;code&gt;:foo&lt;/code&gt; and only keep errors from &lt;code&gt;Bar.foo/3&lt;/code&gt;, you can set up two different matches:</source>
          <target state="translated">&lt;code&gt;:foo&lt;/code&gt; という名前のアプリケーションからのすべてのログ呼び出しをパージし、 &lt;code&gt;Bar.foo/3&lt;/code&gt; /3 からのエラーのみを保持する場合は、2つの異なる一致を設定できます。</target>
        </trans-unit>
        <trans-unit id="1d73b5161b517adda283c3e0c50a4ecfba748837" translate="yes" xml:space="preserve">
          <source>If you want to recompile an existing module, check &lt;a href=&quot;#r/1&quot;&gt;&lt;code&gt;r/1&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">既存のモジュールを再コンパイルする場合は、代わりに&lt;a href=&quot;#r/1&quot;&gt; &lt;code&gt;r/1&lt;/code&gt; を&lt;/a&gt;チェックしてください。</target>
        </trans-unit>
        <trans-unit id="1770175208fe6cb10e9c451baa7570e45537e962" translate="yes" xml:space="preserve">
          <source>If you want to reload a single module, consider using &lt;code&gt;r(ModuleName)&lt;/code&gt; instead.</source>
          <target state="translated">単一のモジュールを再ロードする場合は、代わりに &lt;code&gt;r(ModuleName)&lt;/code&gt; の使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="22937dca14ad8e678a5773e217bdaf60e9e08640" translate="yes" xml:space="preserve">
          <source>If you want to remove all duplicated elements, regardless of order, see &lt;a href=&quot;#uniq/1&quot;&gt;&lt;code&gt;uniq/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">順序に関係なく、重複する要素をすべて削除する場合は、&lt;a href=&quot;#uniq/1&quot;&gt; &lt;code&gt;uniq/1&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="1ac9b92a3ff486c5ca2aa293f505af60c2ce005a" translate="yes" xml:space="preserve">
          <source>If you want to run tests manually, you can set the &lt;code&gt;:autorun&lt;/code&gt; option to &lt;code&gt;false&lt;/code&gt; and use &lt;a href=&quot;#run/0&quot;&gt;&lt;code&gt;run/0&lt;/code&gt;&lt;/a&gt; to run tests.</source>
          <target state="translated">テストを手動で実行する場合は、 &lt;code&gt;:autorun&lt;/code&gt; オプションを &lt;code&gt;false&lt;/code&gt; に設定し、&lt;a href=&quot;#run/0&quot;&gt; &lt;code&gt;run/0&lt;/code&gt; &lt;/a&gt;を使用してテストを実行できます。</target>
        </trans-unit>
        <trans-unit id="d9cfb2104d8a7fbed8970b4e565fd893c81bbbd7" translate="yes" xml:space="preserve">
          <source>If you want to search for both &lt;code&gt;.beam&lt;/code&gt; and &lt;code&gt;.app&lt;/code&gt; files, you could do:</source>
          <target state="translated">&lt;code&gt;.beam&lt;/code&gt; ファイルと &lt;code&gt;.app&lt;/code&gt; ファイルの両方を検索する場合は、次のようにします。</target>
        </trans-unit>
        <trans-unit id="e20d3f7642e2bc2878445510d6350ffeaed9f321" translate="yes" xml:space="preserve">
          <source>If you want to specify more than one variable, you separate them by a comma.</source>
          <target state="translated">複数の変数を指定したい場合は、カンマで区切ります。</target>
        </trans-unit>
        <trans-unit id="1680d4186a75a98ad990b5523a395b408476ac2a" translate="yes" xml:space="preserve">
          <source>If you want to unquote a value that is not a quoted expression, such as a map, you need to call &lt;a href=&quot;macro#escape/1&quot;&gt;&lt;code&gt;Macro.escape/1&lt;/code&gt;&lt;/a&gt; before:</source>
          <target state="translated">マップなど、引用された式ではない値の引用符を外したい場合は、前に&lt;a href=&quot;macro#escape/1&quot;&gt; &lt;code&gt;Macro.escape/1&lt;/code&gt; &lt;/a&gt;を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="b27dac4f0c111d42a9f9a5c0743a540f0cc92e81" translate="yes" xml:space="preserve">
          <source>If you wish to find out more about GenServers, the Elixir Getting Started guide provides a tutorial-like introduction. The documentation and links in Erlang can also provide extra insight.</source>
          <target state="translated">GenServersについてもっと知りたい場合は、Elixir Getting Startedガイドがチュートリアルのような紹介をしています。Erlangのドキュメントやリンクもさらに詳しい情報を提供してくれます。</target>
        </trans-unit>
        <trans-unit id="8d47bd8dadb23934d4b2666cf77ccc81ac30266c" translate="yes" xml:space="preserve">
          <source>If you wish to use another value for the accumulator, use &lt;a href=&quot;enum#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">アキュムレータに別の値を使用する場合は、&lt;a href=&quot;enum#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="0943f45dd0efc661e7f07bd6255b9ee24dc17524" translate="yes" xml:space="preserve">
          <source>If you would like to get the result of evaluating file rather than the modules defined in it, see &lt;a href=&quot;#eval_file/2&quot;&gt;&lt;code&gt;eval_file/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ファイルで定義されているモジュールではなく、ファイルの評価結果を取得したい場合は、&lt;a href=&quot;#eval_file/2&quot;&gt; &lt;code&gt;eval_file/2&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="fe37a76c869eaf7d64eb125b004dacbfd79cc33b" translate="yes" xml:space="preserve">
          <source>If you would rather enable it on your system as a whole, you can use the &lt;code&gt;ERL_AFLAGS&lt;/code&gt; environment variable and make sure that it is set accordingly on your terminal/shell configuration.</source>
          <target state="translated">システム全体で有効にする場合は、 &lt;code&gt;ERL_AFLAGS&lt;/code&gt; 環境変数を使用して、端末/シェル構成でそれに応じて設定されていることを確認します。</target>
        </trans-unit>
        <trans-unit id="31456477d49264f6615f64085ad9c83e259679bd" translate="yes" xml:space="preserve">
          <source>If your Git repository requires authentication, such as basic username:password HTTP authentication via URLs, it can be achieved via Git configuration, keeping the access rules outside of source control.</source>
          <target state="translated">Git リポジトリで認証が必要な場合、たとえば URL を経由した基本的な username:password HTTP 認証のような認証が必要な場合は、Git の設定でアクセスルールをソース管理の外に置いておきます。</target>
        </trans-unit>
        <trans-unit id="c5250542055685fe9ce8faf48f1dcf6cf349fd3b" translate="yes" xml:space="preserve">
          <source>If your application does not have a supervision tree, one can be added by changing &lt;code&gt;def application&lt;/code&gt; inside &lt;code&gt;mix.exs&lt;/code&gt; to include a &lt;code&gt;:mod&lt;/code&gt; key with the application callback name:</source>
          <target state="translated">アプリケーションに監視ツリーがない場合は、 &lt;code&gt;mix.exs&lt;/code&gt; 内の &lt;code&gt;def application&lt;/code&gt; を変更して、アプリケーションコールバック名に： &lt;code&gt;:mod&lt;/code&gt; キーを含めることで、ツリーを追加できます。</target>
        </trans-unit>
        <trans-unit id="79acd423fb1e6c91580bcc6a424e71a397cbe715" translate="yes" xml:space="preserve">
          <source>If your implementation passes options or if you are generating custom code based on the struct, you will also need to implement a macro defined as &lt;code&gt;__deriving__(module, struct, options)&lt;/code&gt; to get the options that were passed.</source>
          <target state="translated">実装がオプションを渡す場合、または構造体に基づいてカスタムコードを生成する場合は、 &lt;code&gt;__deriving__(module, struct, options)&lt;/code&gt; として定義されたマクロを実装して、渡されたオプションを取得する必要もあります。</target>
        </trans-unit>
        <trans-unit id="1087391025d5c5314dde0fa06b5f87e55efb46aa" translate="yes" xml:space="preserve">
          <source>If your use case requires exactly what GenEvent provided, or you have to integrate with an existing &lt;code&gt;:gen_event&lt;/code&gt;-based system, you can still use the &lt;a href=&quot;http://erlang.org/doc/man/gen_event.html&quot;&gt;&lt;code&gt;:gen_event&lt;/code&gt;&lt;/a&gt; Erlang module.</source>
          <target state="translated">ユースケースでGenEventが提供するものを正確に必要とする場合、または既存の &lt;code&gt;:gen_event&lt;/code&gt; ベースのシステムと統合する必要がある場合でも、&lt;a href=&quot;http://erlang.org/doc/man/gen_event.html&quot;&gt; &lt;code&gt;:gen_event&lt;/code&gt; &lt;/a&gt; Erlangモジュールを使用できます。</target>
        </trans-unit>
        <trans-unit id="6ef21699df7b35a736d32d74888718170a41c693" translate="yes" xml:space="preserve">
          <source>If, for some reason, the current working directory cannot be retrieved, this function returns the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">何らかの理由で現在の作業ディレクトリを取得できない場合、この関数は指定された &lt;code&gt;path&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="7f29cc51be005a79b079e12bf1ac5f22f7d2dcb7" translate="yes" xml:space="preserve">
          <source>If, in your Calendar, a new day starts at midnight, return {0, 1}.</source>
          <target state="translated">カレンダーで新しい日が真夜中に始まる場合、{0,1}を返します。</target>
        </trans-unit>
        <trans-unit id="41c5fa5884384a5740f83d50fb3866ac1d3665b0" translate="yes" xml:space="preserve">
          <source>If, in your Calendar, a new day starts at noon, return {1, 2}.</source>
          <target state="translated">カレンダーで新しい日が正午から始まる場合、{1,2}を返します。</target>
        </trans-unit>
        <trans-unit id="8f85da886f46e171f187e86eea72582fd0f8930c" translate="yes" xml:space="preserve">
          <source>If, in your Calendar, a new day starts at sunrise, return {1, 4}.</source>
          <target state="translated">カレンダーで新しい日が日の出から始まる場合は、{1,4}を返します。</target>
        </trans-unit>
        <trans-unit id="0d2c4953da7d60583c85fece795d7ebe8ed34cb1" translate="yes" xml:space="preserve">
          <source>If, in your Calendar, a new day starts at sunset, return {3, 4}.</source>
          <target state="translated">カレンダーで新しい日が日没から始まる場合は、{3,4}を返します。</target>
        </trans-unit>
        <trans-unit id="10cb7a9f4dc8fd31623acf09d7d8af1483fab624" translate="yes" xml:space="preserve">
          <source>If, later, the &lt;code&gt;Bar&lt;/code&gt; module is moved outside the &lt;code&gt;Foo&lt;/code&gt; module definition, it must be referenced by its full name (&lt;code&gt;Foo.Bar&lt;/code&gt;) or an alias must be set using the &lt;code&gt;alias&lt;/code&gt; directive discussed above.</source>
          <target state="translated">後で、 &lt;code&gt;Bar&lt;/code&gt; モジュールが &lt;code&gt;Foo&lt;/code&gt; モジュール定義の外に移動された場合、そのフルネーム（ &lt;code&gt;Foo.Bar&lt;/code&gt; ）で参照するか、上記の &lt;code&gt;alias&lt;/code&gt; ディレクティブを使用してエイリアスを設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="d7beb7df4077fd4d4544fa6a837476c871ba893d" translate="yes" xml:space="preserve">
          <source>If, while the code is executing, the system clock changes, some code that executed in 1 second may be reported as taking over 1 hour! To address such concerns, the VM provides a monotonic time via &lt;a href=&quot;system#monotonic_time/0&quot;&gt;&lt;code&gt;System.monotonic_time/0&lt;/code&gt;&lt;/a&gt; which never decreases and does not leap:</source>
          <target state="translated">コードの実行中にシステムクロックが変更されると、1秒で実行された一部のコードが1時間以上かかると報告される場合があります。このような懸念に対処するために、VMは&lt;a href=&quot;system#monotonic_time/0&quot;&gt; &lt;code&gt;System.monotonic_time/0&lt;/code&gt; &lt;/a&gt;を介して単調な時間を提供します。これは決して減少せず、跳躍しません。</target>
        </trans-unit>
        <trans-unit id="acce89fb4ebef796946f7cb6a71ce1c0793fa8d9" translate="yes" xml:space="preserve">
          <source>Image: negative. Swap foreground and background.</source>
          <target state="translated">画像:ネガティブ。前景と背景を入れ替える。</target>
        </trans-unit>
        <trans-unit id="2554c2edabb99cac5d1195a237820679f650e785" translate="yes" xml:space="preserve">
          <source>Image: positive. Normal foreground and background.</source>
          <target state="translated">画像:正。通常の前景と背景。</target>
        </trans-unit>
        <trans-unit id="b4974ec0729731cbfc104f4eeb6f171651724046" translate="yes" xml:space="preserve">
          <source>Imagine a module uses a specialized list implemented in &lt;code&gt;Math.List&lt;/code&gt;. The &lt;code&gt;alias&lt;/code&gt; directive allows referring to &lt;code&gt;Math.List&lt;/code&gt; just as &lt;code&gt;List&lt;/code&gt; within the module definition:</source>
          <target state="translated">モジュールが &lt;code&gt;Math.List&lt;/code&gt; に実装された特殊なリストを使用するとします。 &lt;code&gt;alias&lt;/code&gt; ディレクティブは、を参照することができます &lt;code&gt;Math.List&lt;/code&gt; 同じように &lt;code&gt;List&lt;/code&gt; モジュール定義内：</target>
        </trans-unit>
        <trans-unit id="0c6d0807e9d9e68c71a2dfa2e6c744532d48a480" translate="yes" xml:space="preserve">
          <source>Imagine someone implements &lt;code&gt;Calendar.Holocene&lt;/code&gt;, a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year:</source>
          <target state="translated">誰かが &lt;code&gt;Calendar.Holocene&lt;/code&gt; を実装するとします。これは、現在のグレゴリオ年にちょうど10,000年を追加する、グレゴリオ暦に基づくカレンダーです。</target>
        </trans-unit>
        <trans-unit id="ae47eabc88af2ef4455eb932e8ea60f7ae332748" translate="yes" xml:space="preserve">
          <source>Imagine the given &quot;old&quot; code:</source>
          <target state="translated">与えられた &quot;古い &quot;コードを想像してみてください。</target>
        </trans-unit>
        <trans-unit id="52ac66ba0efe559bd54e9f534310fa769ff5fac4" translate="yes" xml:space="preserve">
          <source>Imagine the situation you have a quoted expression and you want to inject it inside some quote. The first attempt would be:</source>
          <target state="translated">引用符で囲まれた式を持っていて、それを引用符の中に挿入したい場合を想像してみてください。最初の試みは次のようになります。</target>
        </trans-unit>
        <trans-unit id="f60dc9c31d90f01f4ada0187787c8518ff7e6336" translate="yes" xml:space="preserve">
          <source>Imagine you have a directory called &lt;code&gt;projects&lt;/code&gt; with three Elixir projects inside of it: &lt;code&gt;elixir&lt;/code&gt;, &lt;code&gt;ex_doc&lt;/code&gt;, and &lt;code&gt;plug&lt;/code&gt;. You can find all &lt;code&gt;.beam&lt;/code&gt; files inside the &lt;code&gt;ebin&lt;/code&gt; directory of each project as follows:</source>
          <target state="translated">&lt;code&gt;projects&lt;/code&gt; と呼ばれるディレクトリがあり、その中に3つのElixirプロジェクト（ &lt;code&gt;elixir&lt;/code&gt; 、 &lt;code&gt;ex_doc&lt;/code&gt; 、および &lt;code&gt;plug&lt;/code&gt; )があるとします。次のように、各プロジェクトの &lt;code&gt;ebin&lt;/code&gt; ディレクトリ内のすべての &lt;code&gt;.beam&lt;/code&gt; ファイルを見つけることができます。</target>
        </trans-unit>
        <trans-unit id="78e853aca214a1bc65ac8ef6110f03573d680e17" translate="yes" xml:space="preserve">
          <source>Imagine you have the following structure:</source>
          <target state="translated">以下のような構造になっていると想像してみてください。</target>
        </trans-unit>
        <trans-unit id="e874a03e71d708ca4e25914c4864e7d0682296da" translate="yes" xml:space="preserve">
          <source>Immediately halts the Erlang runtime system.</source>
          <target state="translated">Erlangランタイムシステムを即座に停止させます。</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">実施内容</target>
        </trans-unit>
        <trans-unit id="1ef5a932d18820b4b0e243f0726d914bc0a7ff10" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Any&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Any&lt;/code&gt; 実装</target>
        </trans-unit>
        <trans-unit id="5796eba4ad579f1726f97515a9ac4256c827ceb8" translate="yes" xml:space="preserve">
          <source>Implementing behaviours</source>
          <target state="translated">行動の実装</target>
        </trans-unit>
        <trans-unit id="b465297e29160eecd675375f9f56fd85c2f30272" translate="yes" xml:space="preserve">
          <source>Implementing functions like &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;map/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#filter/2&quot;&gt;&lt;code&gt;filter/2&lt;/code&gt;&lt;/a&gt; and others are a good exercise for understanding the power behind &lt;a href=&quot;enum#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt;. When an operation cannot be expressed by any of the functions in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module, developers will most likely resort to &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;reduce/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;enum#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; の&lt;/a&gt;背後にある力を理解するには、&lt;a href=&quot;#map/2&quot;&gt; &lt;code&gt;map/2&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#filter/2&quot;&gt; &lt;code&gt;filter/2&lt;/code&gt; &lt;/a&gt;などの関数を実装することをお勧めします。&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;モジュールのどの関数でも操作を表現できない場合、開発者はおそらく&lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;reduce/3&lt;/code&gt; を使用し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="a11cbfe39e0739e620b6472396d552890b65f2b5" translate="yes" xml:space="preserve">
          <source>Implenting the behaviour explicitly without calling &lt;a href=&quot;kernel.specialforms#super/1&quot;&gt;&lt;code&gt;super/1&lt;/code&gt;&lt;/a&gt; (v1.0)</source>
          <target state="translated">&lt;a href=&quot;kernel.specialforms#super/1&quot;&gt; &lt;code&gt;super/1&lt;/code&gt; &lt;/a&gt;（v1.0）を呼び出さずに動作を明示的に示す</target>
        </trans-unit>
        <trans-unit id="6ee8b57e8a1146e8195323d5ab0ac1b28d4bf4d5" translate="yes" xml:space="preserve">
          <source>Important: do &lt;strong&gt;not&lt;/strong&gt; use this function on IO devices in Unicode mode as it will write the wrong data. In particular, the standard IO device is set to Unicode by default, so writing to stdio with this function will likely result in the wrong data being sent down the wire.</source>
          <target state="translated">重要：誤ったデータを書き込むため、この関数をUnicodeモードのIOデバイスで使用し&lt;strong&gt;ないで&lt;/strong&gt;ください。特に、標準IOデバイスはデフォルトでUnicodeに設定されているため、この関数を使用してstdioに書き込むと、間違ったデータがネットワークに送信される可能性があります。</target>
        </trans-unit>
        <trans-unit id="5ee893c3406c5d187c4ad8d2a37d2b2305b2b378" translate="yes" xml:space="preserve">
          <source>Imports configuration from the given file.</source>
          <target state="translated">指定されたファイルから設定をインポートします。</target>
        </trans-unit>
        <trans-unit id="82d4e22f3ba03649c647ac0cbd6a6f1c75820475" translate="yes" xml:space="preserve">
          <source>Imports functions and macros from other modules.</source>
          <target state="translated">他のモジュールから関数やマクロをインポートします。</target>
        </trans-unit>
        <trans-unit id="ce9dd8afb038714101f1fa2419f409800104c52e" translate="yes" xml:space="preserve">
          <source>Imports: new functions may be added to the &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; module, which is auto-imported. They may collide with local functions defined in your modules. Collisions can be resolved in a backwards compatible fashion using &lt;code&gt;import Kernel, except: [...]&lt;/code&gt; with a list of all functions you don't want to be imported from &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;. We reserve the right to do such additions.</source>
          <target state="translated">インポート：新しい関数が&lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;モジュールに追加され、自動インポートされます。モジュールで定義されたローカル関数と衝突する可能性があります。衝突は &lt;code&gt;import Kernel, except: [...]&lt;/code&gt; を使用して下位互換性のある方法で解決できますが、次の場合を除きます：[...] &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;からインポートしたくないすべての関数のリスト。そのような追加を行う権利を留保します。</target>
        </trans-unit>
        <trans-unit id="6e98571e8ce38e7d695efe3ecee0b6e80bc755f3" translate="yes" xml:space="preserve">
          <source>Improper lists are never deemed as charlists.</source>
          <target state="translated">不適切なリストは決してチャーリストとはみなされません。</target>
        </trans-unit>
        <trans-unit id="fee52b5aef3534510640142b73884d80c6b12f47" translate="yes" xml:space="preserve">
          <source>Improper lists are not printable, even if made only of ASCII characters:</source>
          <target state="translated">不適切なリストは、ASCII文字だけで作っても印刷できません。</target>
        </trans-unit>
        <trans-unit id="c0d4390b7f52bc3219b6b297954aa2698cd9b21f" translate="yes" xml:space="preserve">
          <source>In &amp;ldquo;Basic types&amp;rdquo;, we learned about strings and used the &lt;code&gt;is_binary/1&lt;/code&gt; function for checks:</source>
          <target state="translated">「基本タイプ」では、文字列について学び、チェックに &lt;code&gt;is_binary/1&lt;/code&gt; 関数を使用しました。</target>
        </trans-unit>
        <trans-unit id="96d506b973cc16f3c887c604680a4f164c5bcb6d" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;keywords-and-maps&quot;&gt;chapter 7&lt;/a&gt; we learned about maps:</source>
          <target state="translated">では&lt;a href=&quot;keywords-and-maps&quot;&gt;第7章&lt;/a&gt;私たちは、マップについて学びました。</target>
        </trans-unit>
        <trans-unit id="b97f6da29f9d3821af09c9644f82422d41ba54db" translate="yes" xml:space="preserve">
          <source>In Elixir we group several functions into modules. We&amp;rsquo;ve already used many different modules in the previous chapters such as &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;the &lt;code&gt;String&lt;/code&gt; module&lt;/a&gt;:</source>
          <target state="translated">Elixirでは、いくつかの関数をモジュールにグループ化します。前の章では&lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;、 &lt;code&gt;String&lt;/code&gt; モジュール&lt;/a&gt;など、さまざまなモジュールをすでに使用しています。</target>
        </trans-unit>
        <trans-unit id="8852e2c2070399b66b8e6aac0c4ebb222e49ff1d" translate="yes" xml:space="preserve">
          <source>In Elixir, &lt;code&gt;Integer.is_odd/1&lt;/code&gt; is defined as a macro so that it can be used as a guard. This means that, in order to invoke &lt;code&gt;Integer.is_odd/1&lt;/code&gt;, we need to first require the &lt;code&gt;Integer&lt;/code&gt; module.</source>
          <target state="translated">Elixirでは、 &lt;code&gt;Integer.is_odd/1&lt;/code&gt; はマクロとして定義されているため、ガードとして使用できます。つまり、 &lt;code&gt;Integer.is_odd/1&lt;/code&gt; を呼び出すには、まず &lt;code&gt;Integer&lt;/code&gt; モジュールが必要です。</target>
        </trans-unit>
        <trans-unit id="84a15dcd0ed954400244a91382ebe28f35c7326d" translate="yes" xml:space="preserve">
          <source>In Elixir, a value can be thrown and later be caught. &lt;code&gt;throw&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt; are reserved for situations where it is not possible to retrieve a value unless by using &lt;code&gt;throw&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt;.</source>
          <target state="translated">エリクサーでは、値をスローして後でキャッチすることができます。 &lt;code&gt;throw&lt;/code&gt; と &lt;code&gt;catch&lt;/code&gt; は、 &lt;code&gt;throw&lt;/code&gt; と &lt;code&gt;catch&lt;/code&gt; を使用しないと値を取得できない場合のために予約されています。</target>
        </trans-unit>
        <trans-unit id="0f7dc2374bd2e474c5f95f1dc00588968670f4e9" translate="yes" xml:space="preserve">
          <source>In Elixir, all code runs inside processes. Processes are isolated from each other, run concurrent to one another and communicate via message passing. Processes are not only the basis for concurrency in Elixir, but they also provide the means for building distributed and fault-tolerant programs.</source>
          <target state="translated">Elixirでは、すべてのコードはプロセスの中で実行されます。プロセスは互いに分離されており、互いに並行して実行され、メッセージパッシングを介して通信します。プロセスは、Elixirの同時実行の基礎となるだけでなく、分散型でフォールトトレラントなプログラムを構築するための手段でもあります。</target>
        </trans-unit>
        <trans-unit id="fcd7da208c379530ff673f8c5363361cec7ce112" translate="yes" xml:space="preserve">
          <source>In Elixir, an enumerable is any data type that implements the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol. &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt;s (&lt;code&gt;[1, 2, 3]&lt;/code&gt;), &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt;s (&lt;code&gt;%{foo: 1, bar: 2}&lt;/code&gt;) and &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;s (&lt;code&gt;1..3&lt;/code&gt;) are common data types used as enumerables:</source>
          <target state="translated">エリクサーでは、列挙は、任意のデータ型実装していることで&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;プロトコル。&lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; s（ &lt;code&gt;[1, 2, 3]&lt;/code&gt; ）、&lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; s（ &lt;code&gt;%{foo: 1, bar: 2}&lt;/code&gt; ）および&lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; s（ &lt;code&gt;1..3&lt;/code&gt; ）は、列挙可能として使用される一般的なデータ型です。</target>
        </trans-unit>
        <trans-unit id="ad60a1595fcaea2abc6cfb534bb59968e6aa0a7d" translate="yes" xml:space="preserve">
          <source>In Elixir, code organization is done by modules and functions, processes are not necessary. For example, imagine you are implementing a calculator and you decide to put all the calculator operations behind a &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Elixirでは、コード編成はモジュールと関数によって行われ、プロセスは必要ありません。たとえば、電卓を実装していて、すべての電卓操作を&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; の&lt;/a&gt;背後に置くことにしたとします。</target>
        </trans-unit>
        <trans-unit id="aa0691e43ac9902c05a55318172be1be3b51602d" translate="yes" xml:space="preserve">
          <source>In Elixir, code organization is done by modules and functions, processes are not necessary. For example, imagine you are implementing a calculator and you decide to put all the calculator operations behind a GenServer:</source>
          <target state="translated">Elixirでは、コードの整理はモジュールと関数で行い、プロセスは必要ありません。例えば、電卓を実装していて、電卓の操作をすべてGenServerの後ろに置くことにしたとします。</target>
        </trans-unit>
        <trans-unit id="1a65801df985cbe3e3c9ee19ff7e4341c68a0a15" translate="yes" xml:space="preserve">
          <source>In Elixir, different data types can be compared using comparison operators:</source>
          <target state="translated">Elixirでは、比較演算子を使用して異なるデータ型を比較することができます。</target>
        </trans-unit>
        <trans-unit id="3ef291ece743ba126271fab00a84b2bf1cd10359" translate="yes" xml:space="preserve">
          <source>In Elixir, it is common to loop over an Enumerable, often filtering out some results and mapping values into another list. Comprehensions are syntactic sugar for such constructs: they group those common tasks into the &lt;code&gt;for&lt;/code&gt; special form.</source>
          <target state="translated">Elixirでは、Enumerableをループして、一部の結果を除外し、値を別のリストにマッピングすることがよくあります。内包表記は、そのような構成要素の構文糖衣です。それらは、これらの一般的なタスクを &lt;code&gt;for&lt;/code&gt; 特殊形式にグループ化します。</target>
        </trans-unit>
        <trans-unit id="92fa98b368b718157a766ec2a187b1b728ee06ed" translate="yes" xml:space="preserve">
          <source>In Elixir, records are used mostly in two situations:</source>
          <target state="translated">Elixirでは、レコードは主に2つの状況で使用されます。</target>
        </trans-unit>
        <trans-unit id="19e018a4aa4ddd6ea9b4d083bf7991661ac6f619" translate="yes" xml:space="preserve">
          <source>In Elixir, the &lt;code&gt;=&lt;/code&gt; operator is actually called &lt;em&gt;the match operator&lt;/em&gt;. Let&amp;rsquo;s see why:</source>
          <target state="translated">Elixirでは、 &lt;code&gt;=&lt;/code&gt; 演算子は実際に&lt;em&gt;は一致演算子&lt;/em&gt;と呼ばれ&lt;em&gt;てい&lt;/em&gt;ます。その理由を見てみましょう：</target>
        </trans-unit>
        <trans-unit id="482c60a7cfc2af43cfa398215016e9bcabca31ff" translate="yes" xml:space="preserve">
          <source>In Elixir, this is done by a Supervisor. A Supervisor is a process that supervises other processes and restarts them whenever they crash. To do so, Supervisors manage the whole life-cycle of any supervised processes, including startup and shutdown.</source>
          <target state="translated">Elixirでは、これはSupervisorによって行われます。スーパーバイザは、他のプロセスを監視し、クラッシュした場合にはいつでも再起動するプロセスです。そのために、スーパーバイザは、起動とシャットダウンを含む、監督されたプロセスのライフサイクル全体を管理します。</target>
        </trans-unit>
        <trans-unit id="c6d542894f9023e77ee4252a95cfc7fdde16bf1f" translate="yes" xml:space="preserve">
          <source>In Elixir, we avoid using &lt;code&gt;try/rescue&lt;/code&gt; because &lt;strong&gt;we don&amp;rsquo;t use errors for control flow&lt;/strong&gt;. We take errors literally: they are reserved for unexpected and/or exceptional situations. In case you actually need flow control constructs, &lt;em&gt;throws&lt;/em&gt; should be used. That&amp;rsquo;s what we are going to see next.</source>
          <target state="translated">Elixirでは、&lt;strong&gt;制御フローにエラーを使用しない&lt;/strong&gt;ため、 &lt;code&gt;try/rescue&lt;/code&gt; の使用を避けて&lt;strong&gt;います&lt;/strong&gt;。私たちは文字通りエラーを受け取ります：それらは予期しないおよび/または例外的な状況のために予約されています。実際にフロー制御構造が必要な場合は、&lt;em&gt;スロー&lt;/em&gt;を使用する必要があります。それが次に見るものです。</target>
        </trans-unit>
        <trans-unit id="b26350d75961840721899e4e896ada8152ee4ff0" translate="yes" xml:space="preserve">
          <source>In Elixir, we can compare two different data types:</source>
          <target state="translated">Elixirでは、2つの異なるデータ型を比較することができます。</target>
        </trans-unit>
        <trans-unit id="99415fb48cc7bcce7ee941711b73cb718fae4683" translate="yes" xml:space="preserve">
          <source>In Elixir, we have two idioms for checking how many items there are in a data structure: &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt;. &lt;code&gt;length&lt;/code&gt; means the information must be computed. For example, &lt;code&gt;length(list)&lt;/code&gt; needs to traverse the whole list to calculate its length. On the other hand, &lt;code&gt;tuple_size(tuple)&lt;/code&gt; and &lt;code&gt;byte_size(binary)&lt;/code&gt; do not depend on the tuple and binary size as the size information is pre-computed in the data structure.</source>
          <target state="translated">Elixirでは、データ構造にあるアイテムの数をチェックするための2つのイディオムがあります： &lt;code&gt;length&lt;/code&gt; と &lt;code&gt;size&lt;/code&gt; です。 &lt;code&gt;length&lt;/code&gt; は、情報を計算する必要があることを意味します。たとえば、 &lt;code&gt;length(list)&lt;/code&gt; はその長さを計算するためにリスト全体をトラバースする必要があります。一方、 &lt;code&gt;tuple_size(tuple)&lt;/code&gt; と &lt;code&gt;byte_size(binary)&lt;/code&gt; は、サイズ情報がデータ構造で事前に計算されるため、タプルとバイナリのサイズに依存しません。</target>
        </trans-unit>
        <trans-unit id="f3be4753dceb5fddab1fdca38953766786eecc42" translate="yes" xml:space="preserve">
          <source>In Elixir, we have two main associative data structures: keyword lists and maps. It&amp;rsquo;s time to learn more about them!</source>
          <target state="translated">Elixirには、キーワードリストとマップという2つの主な関連データ構造があります。それらについてもっと学ぶ時が来ました！</target>
        </trans-unit>
        <trans-unit id="6cb8d41ba02e8fc631535705b4f2e08988507e70" translate="yes" xml:space="preserve">
          <source>In Elixir, we have two verbs for checking how many items there are in a data structure: &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt;. &lt;code&gt;length&lt;/code&gt; means the information must be computed. For example, &lt;code&gt;length(list)&lt;/code&gt; needs to traverse the whole list to calculate its length. On the other hand, &lt;code&gt;tuple_size(tuple)&lt;/code&gt; and &lt;code&gt;byte_size(binary)&lt;/code&gt; do not depend on the tuple and binary size as the size information is precomputed in the data structure.</source>
          <target state="translated">Elixirには、データ構造内にあるアイテムの数を確認するための2つの動詞があり &lt;code&gt;size&lt;/code&gt; 。 &lt;code&gt;length&lt;/code&gt; とサイズです。 &lt;code&gt;length&lt;/code&gt; は、情報を計算する必要があることを意味します。たとえば、 &lt;code&gt;length(list)&lt;/code&gt; はその長さを計算するためにリスト全体をトラバースする必要があります。一方、 &lt;code&gt;tuple_size(tuple)&lt;/code&gt; と &lt;code&gt;byte_size(binary)&lt;/code&gt; は、サイズ情報がデータ構造で事前に計算されるため、タプルとバイナリのサイズに依存しません。</target>
        </trans-unit>
        <trans-unit id="3e9adf90c14fca15cafcd8d80e7a0e62f3c9bd2b" translate="yes" xml:space="preserve">
          <source>In Elixir, you can define a binary using &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Elixirでは、 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; を使用してバイナリを定義できます。</target>
        </trans-unit>
        <trans-unit id="3508879bcb04190c581cc69dedcf57a9400be46d" translate="yes" xml:space="preserve">
          <source>In Erlang, this struct is represented by a &lt;code&gt;:file_info&lt;/code&gt; record. Therefore this module also provides functions for converting between the Erlang record and the Elixir struct.</source>
          <target state="translated">Erlangでは、この構造体は &lt;code&gt;:file_info&lt;/code&gt; レコードで表されます。したがって、このモジュールは、ErlangレコードとElixir構造体の間の変換機能も提供します。</target>
        </trans-unit>
        <trans-unit id="08902136d46a0efffdb0a07180738ce463f3cf44" translate="yes" xml:space="preserve">
          <source>In Mix projects, the environment of the application and its dependencies can be overridden via the &lt;code&gt;config/config.exs&lt;/code&gt; file. If you start the application with Mix, that configuration is available at compile time, and at runtime too, but take into account it is not included in the generated application resource file, and it is not available if you start the application without Mix.</source>
          <target state="translated">Mixプロジェクトでは、アプリケーションの環境とその依存関係は、 &lt;code&gt;config/config.exs&lt;/code&gt; ファイルを使用してオーバーライドできます。Mixを使用してアプリケーションを開始する場合、その構成はコンパイル時および実行時にも使用できますが、生成されたアプリケーションリソースファイルには含まれず、Mixなしでアプリケーションを開始した場合は使用できません。</target>
        </trans-unit>
        <trans-unit id="9174170a472a8f04a70eb2658745c2e8ceaf3c42" translate="yes" xml:space="preserve">
          <source>In Unix-like systems, changing the modification time may require you to be either &lt;code&gt;root&lt;/code&gt; or the owner of the file. Having write access may not be enough. In those cases, touching the file the first time (to create it) will succeed, but touching an existing file with fail with &lt;code&gt;{:error, :eperm}&lt;/code&gt;.</source>
          <target state="translated">Unixライクなシステムでは、変更時刻を変更するには、 &lt;code&gt;root&lt;/code&gt; またはファイルの所有者である必要があります。書き込みアクセス権があるだけでは不十分な場合があります。これらの場合、ファイルを最初に（作成するために）タッチすることは成功しますが、既存のファイルをタッチすると &lt;code&gt;{:error, :eperm}&lt;/code&gt; で失敗します。</target>
        </trans-unit>
        <trans-unit id="0de5ec7fc6835af5a7c8c3ee0628180b848d8db4" translate="yes" xml:space="preserve">
          <source>In a GenServer, the code above would be two separate functions, roughly like this:</source>
          <target state="translated">GenServerでは、上記のコードは大体次のような2つの別々の関数になります。</target>
        </trans-unit>
        <trans-unit id="bcadbac52f644d8178e01dd98a388d6072c88e19" translate="yes" xml:space="preserve">
          <source>In a distributed setup with multiple nodes, the API that accepts anonymous functions only works if the caller (client) and the agent have the same version of the caller module.</source>
          <target state="translated">複数のノードを持つ分散設定では、匿名関数を受け付けるAPIは、呼び出し元(クライアント)とエージェントが同じバージョンの呼び出し元モジュールを持っている場合にのみ動作します。</target>
        </trans-unit>
        <trans-unit id="93de78b9e89412d553d71ba4abbfe5315731105f" translate="yes" xml:space="preserve">
          <source>In a nutshell, a version is represented by three numbers:</source>
          <target state="translated">一言で言えば、バージョンは3つの数字で表されます。</target>
        </trans-unit>
        <trans-unit id="4de3e72994971159efbbfa51adb4f6daeb251a7f" translate="yes" xml:space="preserve">
          <source>In a nutshell, an application consists of all of the modules defined in the &lt;code&gt;.app&lt;/code&gt; file, including the &lt;code&gt;.app&lt;/code&gt; file itself. An application has generally only two directories: &lt;code&gt;ebin&lt;/code&gt;, for Elixir artefacts, such as &lt;code&gt;.beam&lt;/code&gt; and &lt;code&gt;.app&lt;/code&gt; files, and &lt;code&gt;priv&lt;/code&gt;, with any other artefact or asset you may need in your application.</source>
          <target state="translated">一言で言えば、アプリケーションは、で定義されたすべてのモジュールから構成 &lt;code&gt;.app&lt;/code&gt; 含むファイル、 &lt;code&gt;.app&lt;/code&gt; ファイル自体。通常、アプリケーションには2つのディレクトリしかありません &lt;code&gt;.beam&lt;/code&gt; や &lt;code&gt;.app&lt;/code&gt; ファイルなどのElixirアーティファクトの場合は &lt;code&gt;ebin&lt;/code&gt; 、アプリケーションで必要になる可能性のある他のアーティファクトやアセットの場合は &lt;code&gt;priv&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="8a78c9d971b121556059db385274a3963a89d465" translate="yes" xml:space="preserve">
          <source>In a nutshell, the first must be used when you want to keep track of the files handled by the system, to avoid the same file from being compiled multiple times. This is common in scripts.</source>
          <target state="translated">一言で言えば、同じファイルが何度もコンパイルされるのを避けるために、システムが扱うファイルを把握しておきたいときに、最初のものを使わなければなりません。これはスクリプトではよくあることです。</target>
        </trans-unit>
        <trans-unit id="ba31b6b4506414b36091cbb58f049c0003b3112c" translate="yes" xml:space="preserve">
          <source>In a regular project, we can assemble a release by simply running &lt;code&gt;mix release&lt;/code&gt;. However, we have an umbrella project, and in such cases Elixir requires some extra input from us. Let&amp;rsquo;s see what is necessary:</source>
          <target state="translated">通常のプロジェクトでは、 &lt;code&gt;mix release&lt;/code&gt; 実行するだけでリリースを組み立てることができます。ただし、包括的プロジェクトがあり、そのような場合、Elixirからの追加の入力が必要です。何が必要か見てみましょう：</target>
        </trans-unit>
        <trans-unit id="a9421fd8baf899a704905f1b7b921c58ff7bb458" translate="yes" xml:space="preserve">
          <source>In addition to the Elixir file extension &lt;code&gt;.ex&lt;/code&gt;, Elixir also supports &lt;code&gt;.exs&lt;/code&gt; files for scripting. Elixir treats both files exactly the same way, the only difference is in intention. &lt;code&gt;.ex&lt;/code&gt; files are meant to be compiled while &lt;code&gt;.exs&lt;/code&gt; files are used for scripting. When executed, both extensions compile and load their modules into memory, although only &lt;code&gt;.ex&lt;/code&gt; files write their bytecode to disk in the format of &lt;code&gt;.beam&lt;/code&gt; files.</source>
          <target state="translated">Elixirファイル拡張子 &lt;code&gt;.ex&lt;/code&gt; に加えて、Elixir はスクリプト用の &lt;code&gt;.exs&lt;/code&gt; ファイルもサポートしています。Elixirは両方のファイルをまったく同じ方法で扱います。唯一の違いは意図です。 &lt;code&gt;.ex&lt;/code&gt; ファイルはスクリプト用に使用されますが、 &lt;code&gt;.exs&lt;/code&gt; ファイルはコンパイルされることを意図しています。実行すると、両方の拡張機能は、コンパイルとだけが、メモリにそのモジュールをロード &lt;code&gt;.ex&lt;/code&gt; ファイルはの形式でディスクに自分のバイトコードを書く &lt;code&gt;.beam&lt;/code&gt; のファイル。</target>
        </trans-unit>
        <trans-unit id="96148bc0703e1fb4ea78297b10992f7426df74e8" translate="yes" xml:space="preserve">
          <source>In addition to the built-in attributes outlined above, custom attributes may also be added. Custom attributes are expressed using the &lt;a href=&quot;kernel#@/1&quot;&gt;&lt;code&gt;@/1&lt;/code&gt;&lt;/a&gt; operator followed by a valid variable name. The value given to the custom attribute must be a valid Elixir value:</source>
          <target state="translated">上記の組み込み属性に加えて、カスタム属性も追加できます。カスタム属性は、&lt;a href=&quot;kernel#@/1&quot;&gt; &lt;code&gt;@/1&lt;/code&gt; &lt;/a&gt;演算子とそれに続く有効な変数名を使用して表されます。カスタム属性に指定する値は、有効なElixir値である必要があります：</target>
        </trans-unit>
        <trans-unit id="3dfd563836d0d4567f592fdf1b54449f8fc77413" translate="yes" xml:space="preserve">
          <source>In addition to the keys provided by the user via &lt;a href=&quot;logger#metadata/1&quot;&gt;&lt;code&gt;Logger.metadata/1&lt;/code&gt;&lt;/a&gt;, the following extra keys are available to the &lt;code&gt;:metadata&lt;/code&gt; list:</source>
          <target state="translated">&lt;a href=&quot;logger#metadata/1&quot;&gt; &lt;code&gt;Logger.metadata/1&lt;/code&gt; &lt;/a&gt;を介してユーザーが提供するキーに加えて、次の追加のキーを &lt;code&gt;:metadata&lt;/code&gt; リストで使用できます。</target>
        </trans-unit>
        <trans-unit id="f1d0e9c42e96c43f7a51f23eb3e0a63cd08fcabb" translate="yes" xml:space="preserve">
          <source>In addition to those, a double quote inside a double-quoted string needs to be escaped as &lt;code&gt;\&quot;&lt;/code&gt;, and, analogously, a single quote inside a single-quoted char list needs to be escaped as &lt;code&gt;\'&lt;/code&gt;. Nevertheless, it is better style to change delimiters as seen above than to escape them.</source>
          <target state="translated">これらに加えて、二重引用符で囲まれた文字列内の二重引用符は &lt;code&gt;\&quot;&lt;/code&gt; としてエスケープする必要があり、同様に、単一引用符で囲まれた文字リスト内の単一引用符は &lt;code&gt;\'&lt;/code&gt; としてエスケープする必要があります。それでも、スタイルの方が優れていますデリミタをエスケープするよりも、上記のように変更します。</target>
        </trans-unit>
        <trans-unit id="81e21312ebc75f6d03fffd3a474b80ff1f053e1d" translate="yes" xml:space="preserve">
          <source>In all of the examples above, we used binaries when writing to files. In the chapter &lt;a href=&quot;binaries-strings-and-char-lists&quot;&gt;&amp;ldquo;Binaries, strings, and charlists&amp;rdquo;&lt;/a&gt;, we mentioned how strings are made of bytes while charlists are lists with Unicode codepoints.</source>
          <target state="translated">上記のすべての例では、ファイルに書き込むときにバイナリを使用しました。&lt;a href=&quot;binaries-strings-and-char-lists&quot;&gt;「バイナリ、文字列、および文字リスト」&lt;/a&gt;の章では、文字列がバイトで構成される方法について説明しましたが、文字リストはUnicodeコードポイントを持つリストです。</target>
        </trans-unit>
        <trans-unit id="8e799b4247b90ad4aaf06f6677263f125c9b2f4f" translate="yes" xml:space="preserve">
          <source>In any case, avoid any of the following:</source>
          <target state="translated">いずれにしても、以下のようなことは避けましょう。</target>
        </trans-unit>
        <trans-unit id="1589dd45f78cf7266ba6322f20d21e370ee7f5aa" translate="yes" xml:space="preserve">
          <source>In both cases, &lt;code&gt;Stack.start_link/1&lt;/code&gt; is always invoked.</source>
          <target state="translated">どちらの場合も、 &lt;code&gt;Stack.start_link/1&lt;/code&gt; は常に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="0ea2013003c5c58a5c3f717cccfc60a91074f95a" translate="yes" xml:space="preserve">
          <source>In both cases, the command-line arguments for the script or expression are available in &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#argv/0&quot;&gt;&lt;code&gt;System.argv/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">どちらの場合も、スクリプトまたは式のコマンドライン引数は&lt;a href=&quot;https://hexdocs.pm/elixir/System.html#argv/0&quot;&gt; &lt;code&gt;System.argv/0&lt;/code&gt; で&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="6d33c9b688f2fa1ee1c39e6a6ee8a9eef85fb236" translate="yes" xml:space="preserve">
          <source>In case a &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function returns a &lt;code&gt;:suspend&lt;/code&gt; accumulator, it must be explicitly handled by the caller and never leak.</source>
          <target state="translated">&lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt;関数が &lt;code&gt;:suspend&lt;/code&gt; アキュムレーターを返す場合、それは呼び出し元によって明示的に処理され、リークすることはありません。</target>
        </trans-unit>
        <trans-unit id="02f1586eeab6e7c0484c69613b04bc3194eb4e79" translate="yes" xml:space="preserve">
          <source>In case a &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function returns the &lt;code&gt;:suspend&lt;/code&gt; accumulator, the &lt;code&gt;:suspended&lt;/code&gt; tuple must be explicitly handled by the caller and never leak. In practice, this means regular enumeration functions just need to be concerned about &lt;code&gt;:done&lt;/code&gt; and &lt;code&gt;:halted&lt;/code&gt; results.</source>
          <target state="translated">&lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt;関数が &lt;code&gt;:suspend&lt;/code&gt; アキュムレーターを返す場合、 &lt;code&gt;:suspended&lt;/code&gt; タプルは呼び出し元によって明示的に処理され、リークしないようにする必要があります。実際には、これは通常の列挙関数が &lt;code&gt;:done&lt;/code&gt; と &lt;code&gt;:halted&lt;/code&gt; の結果を気にする必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="3377f61918ce91a5a78e38bc72a8ef4ed3572f98" translate="yes" xml:space="preserve">
          <source>In case a direct relative path cannot be found, it returns the original path.</source>
          <target state="translated">直接の相対パスが見つからない場合は、元のパスを返します。</target>
        </trans-unit>
        <trans-unit id="6c9cc568db359a5124dd032595b36cc1734cb7b5" translate="yes" xml:space="preserve">
          <source>In case a single file is being tested, it is possible to pass one or more specific line numbers to run only those given tests:</source>
          <target state="translated">一つのファイルがテストされている場合、与えられたテストだけを実行するために、一つ以上の特定の行番号を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="702e65eacb180decf2c9dac0a4fdd10013882322" translate="yes" xml:space="preserve">
          <source>In case a switch &lt;code&gt;SWITCH&lt;/code&gt; is specified to have type &lt;code&gt;:boolean&lt;/code&gt;, it may be passed as &lt;code&gt;--no-SWITCH&lt;/code&gt; as well which will set the option to &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">スイッチ &lt;code&gt;SWITCH&lt;/code&gt; がタイプ &lt;code&gt;:boolean&lt;/code&gt; を持つように指定されている場合、 &lt;code&gt;--no-SWITCH&lt;/code&gt; としても渡され、オプションが &lt;code&gt;false&lt;/code&gt; に設定されます。</target>
        </trans-unit>
        <trans-unit id="888f992f5fc265705743ba6ca955221f42ebdba1" translate="yes" xml:space="preserve">
          <source>In case any entry returns &lt;code&gt;nil&lt;/code&gt;, its key will be removed and the deletion will be considered a success.</source>
          <target state="translated">エントリが &lt;code&gt;nil&lt;/code&gt; を返す場合、そのキーは削除され、削除は成功と見なされます。</target>
        </trans-unit>
        <trans-unit id="a72e1cfffefe65681b735eb6f7dbafbbce0c5ef9" translate="yes" xml:space="preserve">
          <source>In case any of the entries in the middle returns &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;nil&lt;/code&gt; will be returned as per the &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">任意の中間戻りのエントリの場合に &lt;code&gt;nil&lt;/code&gt; 、 &lt;code&gt;nil&lt;/code&gt; の通りに返される&lt;a href=&quot;access&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;モジュール。</target>
        </trans-unit>
        <trans-unit id="de3e20065397014cb42d9b910dde02ad6289d161" translate="yes" xml:space="preserve">
          <source>In case any of the entries in the middle returns &lt;code&gt;nil&lt;/code&gt;, an error will be raised when trying to access it next.</source>
          <target state="translated">途中のエントリのいずれかが &lt;code&gt;nil&lt;/code&gt; を返した場合、次にアクセスしようとするとエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="ffe6dece0fc6fa31895ca4664fd38ac481329ebd" translate="yes" xml:space="preserve">
          <source>In case it does exist, it is a no-op. Otherwise, it is built.</source>
          <target state="translated">存在している場合は、それがない場合です。それ以外の場合はビルドされます。</target>
        </trans-unit>
        <trans-unit id="fe785d8d01b549120d0fdba2f98502200395bc4b" translate="yes" xml:space="preserve">
          <source>In case one wants to access the original &lt;a href=&quot;keyword&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt;, it can be done by accessing &lt;code&gt;Elixir&lt;/code&gt;:</source>
          <target state="translated">元の&lt;a href=&quot;keyword&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt;にアクセスしたい場合は、 &lt;code&gt;Elixir&lt;/code&gt; にアクセスしてください：</target>
        </trans-unit>
        <trans-unit id="a3773025824eaaa4fbaabc9e17eece745001ea94" translate="yes" xml:space="preserve">
          <source>In case something goes wrong, you can also use &lt;a href=&quot;#exit/1&quot;&gt;&lt;code&gt;exit/1&lt;/code&gt;&lt;/a&gt; with a different reason:</source>
          <target state="translated">何か問題が発生した場合は、別の理由で&lt;a href=&quot;#exit/1&quot;&gt; &lt;code&gt;exit/1&lt;/code&gt; &lt;/a&gt;を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="2fa86b82adf3327a6ba51dace9ac5f0221aed458" translate="yes" xml:space="preserve">
          <source>In case the alias is generated automatically by a macro, Elixir won't emit any warnings though, since the alias was not explicitly defined.</source>
          <target state="translated">マクロによってエイリアスが自動的に生成された場合、エイリアスが明示的に定義されていないため、Elixirは警告を発しません。</target>
        </trans-unit>
        <trans-unit id="c438ea8f1248a5429d6990102993e9d6dbcfa2ca" translate="yes" xml:space="preserve">
          <source>In case the conversion fails, it raises an &lt;a href=&quot;unicodeconversionerror&quot;&gt;&lt;code&gt;UnicodeConversionError&lt;/code&gt;&lt;/a&gt;. If a string is given, it returns the string itself.</source>
          <target state="translated">変換が失敗した場合は、&lt;a href=&quot;unicodeconversionerror&quot;&gt; &lt;code&gt;UnicodeConversionError&lt;/code&gt; &lt;/a&gt;が発生します。文字列を指定すると、文字列自体が返されます。</target>
        </trans-unit>
        <trans-unit id="a15baa5f03723748dcf10b5cb52af46c921885dc" translate="yes" xml:space="preserve">
          <source>In case the file doesn't exist, an error is raised.</source>
          <target state="translated">ファイルが存在しない場合はエラーになります。</target>
        </trans-unit>
        <trans-unit id="9aefc659b37d49c39922094af9efb51756248b09" translate="yes" xml:space="preserve">
          <source>In case the import is generated automatically by a macro, Elixir won't emit any warnings though, since the import was not explicitly defined.</source>
          <target state="translated">マクロによってインポートが自動的に生成された場合、インポートが明示的に定義されていないため、Elixirは警告を発しません。</target>
        </trans-unit>
        <trans-unit id="8f7982ac3a103bc11a1e2ceb070d36fd43cc0956" translate="yes" xml:space="preserve">
          <source>In case the task process dies, the current process will exit with the same reason as the task.</source>
          <target state="translated">タスクプロセスが終了した場合、現在のプロセスはタスクと同じ理由で終了します。</target>
        </trans-unit>
        <trans-unit id="5028298a69062b4bcef1005e365f72fcb9b4bd2c" translate="yes" xml:space="preserve">
          <source>In case the test crashes, you will see a report as follows:</source>
          <target state="translated">テストがクラッシュした場合、以下のようなレポートが表示されます。</target>
        </trans-unit>
        <trans-unit id="63f761d55661dfac505485cc96ef395b1517c85a" translate="yes" xml:space="preserve">
          <source>In case there is an error while your structure is being inspected, Elixir will raise an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; error and will automatically fall back to a raw representation for printing the structure.</source>
          <target state="translated">構造の検査中にエラーが発生した場合、Elixirは&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;エラーを発生させ、構造を印刷するための生の表現に自動的にフォールバックします。</target>
        </trans-unit>
        <trans-unit id="05066096207f29449b516520b228a698f4b4f25c" translate="yes" xml:space="preserve">
          <source>In case there is no such message, the current process hangs until a message arrives or waits until a given timeout value.</source>
          <target state="translated">そのようなメッセージがない場合、メッセージが到着するまで現在のプロセスはハングアップするか、指定されたタイムアウト値まで待ちます。</target>
        </trans-unit>
        <trans-unit id="4d02c8c3170ba0952169ceddc222a7d17ada7459" translate="yes" xml:space="preserve">
          <source>In case things are not working as expected, please include as much information as you can in your report, for example: your Elixir version, the code snippet and the error message alongside the error stacktrace. Use sites like &lt;a href=&quot;https://gist.github.com/&quot;&gt;Gist&lt;/a&gt; to paste this information.</source>
          <target state="translated">期待どおりに機能しない場合は、レポートにできる限り多くの情報を含めてください。たとえば、Elixirのバージョン、コードスニペット、エラーメッセージ、エラースタックトレースのほかに、&lt;a href=&quot;https://gist.github.com/&quot;&gt;Gist&lt;/a&gt;などのサイトを使用して、この情報を貼り付けます。</target>
        </trans-unit>
        <trans-unit id="03bcf5fae6ba2e97dc4c9b6b526c4e8e1ed5a2fc" translate="yes" xml:space="preserve">
          <source>In case you need to configure a process, the options should be passed when starting that process.</source>
          <target state="translated">プロセスを設定する必要がある場合は、そのプロセスを起動する際にオプションを渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="402b42bb4e09e34f8b56390600a6d4385db6ff6a" translate="yes" xml:space="preserve">
          <source>In case you need to work with bytes, take a look at the &lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt;&lt;code&gt;:binary&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">バイトで作業する必要がある場合は、&lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt; &lt;code&gt;:binary&lt;/code&gt; モジュールをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ccc59a70627542b407463a1a5ab11815a7059a36" translate="yes" xml:space="preserve">
          <source>In case you want to automatically load &lt;strong&gt;and start&lt;/strong&gt; all of &lt;code&gt;app&lt;/code&gt;'s dependencies, see &lt;a href=&quot;#ensure_all_started/2&quot;&gt;&lt;code&gt;ensure_all_started/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;app&lt;/code&gt; のすべての依存関係を自動的にロード&lt;strong&gt;して開始&lt;/strong&gt;する場合は、&lt;a href=&quot;#ensure_all_started/2&quot;&gt; &lt;code&gt;ensure_all_started/2&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="5f681ed2c3aa6661367fb62449b5900050c12c47" translate="yes" xml:space="preserve">
          <source>In case you want to provide some existing functionality to the user module, please define it in a module which will be imported accordingly; for example, &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt;&lt;/a&gt; doesn't define the &lt;code&gt;test/3&lt;/code&gt; macro in the module that calls &lt;code&gt;use ExUnit.Case&lt;/code&gt;, but it defines &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html#test/3&quot;&gt;&lt;code&gt;ExUnit.Case.test/3&lt;/code&gt;&lt;/a&gt; and just imports that into the caller when used.</source>
          <target state="translated">ユーザーモジュールに既存の機能を提供する場合は、それに応じてインポートされるモジュールで定義してください。例えば、&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; は&lt;/a&gt;定義していない &lt;code&gt;test/3&lt;/code&gt; コールがそのモジュール内のマクロを &lt;code&gt;use ExUnit.Case&lt;/code&gt; 、それは定義&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html#test/3&quot;&gt; &lt;code&gt;ExUnit.Case.test/3&lt;/code&gt; &lt;/a&gt;使用発信者へことだけ輸入。</target>
        </trans-unit>
        <trans-unit id="3ff348aca712691651b4c435346c7c87f48a03c6" translate="yes" xml:space="preserve">
          <source>In case you were using the deprecated &lt;code&gt;:simple_one_for_one&lt;/code&gt; strategy from the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module, you can migrate to the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; in few steps.</source>
          <target state="translated">&lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;モジュールから非推奨の &lt;code&gt;:simple_one_for_one&lt;/code&gt; 戦略を使用していた場合は、いくつかの手順で&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; &lt;/a&gt;に移行できます。</target>
        </trans-unit>
        <trans-unit id="e3fa04a38e1468a79c7262b85ac96321cc9efef6" translate="yes" xml:space="preserve">
          <source>In contrast to keyword lists, maps are very useful with pattern matching. When a map is used in a pattern, it will always match on a subset of the given value:</source>
          <target state="translated">キーワードリストとは対照的に、マップはパターンマッチングで非常に便利です。マップがパターンで使用されると、マップは常に指定された値のサブセットにマッチします。</target>
        </trans-unit>
        <trans-unit id="1a0cd3de6db0a42db7660ce1f70c833f42728634" translate="yes" xml:space="preserve">
          <source>In contrast, the values for the called functions describe those functions, but in the context of the marked function. For example, the last row means that &lt;code&gt;Mod.called2/0&lt;/code&gt; was called once by &lt;code&gt;Mod.some_function/0&lt;/code&gt;, and in that case the total time spent in the function was 50ms.</source>
          <target state="translated">対照的に、呼び出された関数の値はそれらの関数を説明しますが、マークされた関数のコンテキスト内です。たとえば、最後の行は &lt;code&gt;Mod.called2/0&lt;/code&gt; がMod.some_function / 0によって一度呼び出されたことを意味し、その場合、関数で費やされた合計時間は &lt;code&gt;Mod.some_function/0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc4add0dde66d9d0296a0654de0562024d8f9f79" translate="yes" xml:space="preserve">
          <source>In fact, &lt;a href=&quot;erlangerror&quot;&gt;&lt;code&gt;ErlangError&lt;/code&gt;&lt;/a&gt; can be used to rescue any error that is not a proper Elixir error. For example, it can be used to rescue the earlier &lt;code&gt;:badarg&lt;/code&gt; error too, prior to transformation:</source>
          <target state="translated">実際、&lt;a href=&quot;erlangerror&quot;&gt; &lt;code&gt;ErlangError&lt;/code&gt; &lt;/a&gt;は、適切なElixirエラーではないエラーを救うために使用できます。たとえば、変換の前に、以前の &lt;code&gt;:badarg&lt;/code&gt; エラーも救うために使用できます。</target>
        </trans-unit>
        <trans-unit id="0899943a58fd70e4f3d0ccf56e136c5b02dd5f31" translate="yes" xml:space="preserve">
          <source>In fact, connecting to remote shells is so common that we provide a shortcut via the command line as well:</source>
          <target state="translated">実際、リモートシェルへの接続は非常に一般的なので、コマンドラインからのショートカットも提供しています。</target>
        </trans-unit>
        <trans-unit id="86d8ddd11e7d11d4d1da78d64c3d55a307dc74a3" translate="yes" xml:space="preserve">
          <source>In fact, let&amp;rsquo;s open up &lt;code&gt;lib/kv_server/application.ex&lt;/code&gt;:</source>
          <target state="translated">実際、 &lt;code&gt;lib/kv_server/application.ex&lt;/code&gt; を開いてみましょう：</target>
        </trans-unit>
        <trans-unit id="61139d4b1bbde59322a4c8bca7a0561709d9841c" translate="yes" xml:space="preserve">
          <source>In fact, the &lt;code&gt;:bind_quoted&lt;/code&gt; option is recommended every time one desires to inject a value into the quote.</source>
          <target state="translated">実際、 &lt;code&gt;:bind_quoted&lt;/code&gt; オプションは、クォートに値を挿入したいときは常に推奨されます。</target>
        </trans-unit>
        <trans-unit id="e63bd9e9e19b982359b9cda4d5fcbeea34909a27" translate="yes" xml:space="preserve">
          <source>In fact, this pattern is so common that most of the times you will want to use the &lt;code&gt;bind_quoted&lt;/code&gt; option with &lt;a href=&quot;#quote/2&quot;&gt;&lt;code&gt;quote/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">実際、このパターンは非常に一般的であるため、ほとんどの場合、 &lt;code&gt;bind_quoted&lt;/code&gt; &lt;a href=&quot;#quote/2&quot;&gt; &lt;code&gt;quote/2&lt;/code&gt; &lt;/a&gt; bind_quotedオプションを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="be090f2c7b49fa10f6982f61cbff56e2c1ea6990" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;underscore&lt;/code&gt; can be thought of as the reverse of &lt;code&gt;camelize&lt;/code&gt;, however, in some cases formatting may be lost:</source>
          <target state="translated">一般的に、 &lt;code&gt;underscore&lt;/code&gt; は &lt;code&gt;camelize&lt;/code&gt; の逆と考えることができますが、場合によってはフォーマットが失われることがあります。</target>
        </trans-unit>
        <trans-unit id="6a3e2a29096c65e2eb89f937c17a4004e7ef7444" translate="yes" xml:space="preserve">
          <source>In general, a developer should use the former in case they want to react if the file does not exist. The latter should be used when the developer expects their software to fail in case the file cannot be read (i.e. it is literally an exception).</source>
          <target state="translated">一般的に、開発者はファイルが存在しない場合に対応したい場合に前者を使うべきです。後者は、ファイルが読めない場合にソフトウェアが失敗することを想定している場合に使用するべきです (つまり、文字通り例外です)。</target>
        </trans-unit>
        <trans-unit id="d16c9ac73c5397997e3e76ab325334e002852804" translate="yes" xml:space="preserve">
          <source>In general, a developer will want to use the general &lt;code&gt;assert&lt;/code&gt; macro in tests. This macro introspects your code and provides good reporting whenever there is a failure. For example, &lt;code&gt;assert some_fun() == 10&lt;/code&gt; will fail (assuming &lt;code&gt;some_fun()&lt;/code&gt; returns &lt;code&gt;13&lt;/code&gt;):</source>
          <target state="translated">一般に、開発者はテストで一般的な &lt;code&gt;assert&lt;/code&gt; マクロを使用する必要があります。このマクロはコードをイントロスペクトし、障害が発生した場合はいつでも適切なレポートを提供します。たとえば、 &lt;code&gt;assert some_fun() == 10&lt;/code&gt; をアサートすると失敗し &lt;code&gt;some_fun()&lt;/code&gt; が &lt;code&gt;13&lt;/code&gt; を返すと仮定）。</target>
        </trans-unit>
        <trans-unit id="c3d41e104bfcea8fdabed0cd450572fc2e4bac9f" translate="yes" xml:space="preserve">
          <source>In general, the functions in this module rely on the Unicode Standard, but do not contain any of the locale specific behaviour.</source>
          <target state="translated">一般的に、このモジュールの関数は Unicode 標準に依存していますが、ロケール固有の動作は含まれていません。</target>
        </trans-unit>
        <trans-unit id="9c9716a12a8a55aca30fe284f4ffccd27a063bec" translate="yes" xml:space="preserve">
          <source>In general, the tuples above are structured according to the following format:</source>
          <target state="translated">一般的に、上記のタプルは、以下のような形式で構成されています。</target>
        </trans-unit>
        <trans-unit id="6de751c2f24f5d6947a334c2b635bc5f4ec33c5a" translate="yes" xml:space="preserve">
          <source>In general, when the keyword list is the last argument of a function, the square brackets are optional.</source>
          <target state="translated">一般に、キーワードリストが関数の最後の引数である場合、角括弧はオプションです。</target>
        </trans-unit>
        <trans-unit id="6bab1cb15297331e40b3f50701fea2260e1dfe89" translate="yes" xml:space="preserve">
          <source>In guards, when functions would normally raise exceptions, they cause the guard to fail instead. For example, the &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; function only works with lists. If we use it with anything else, a runtime error is raised:</source>
          <target state="translated">ガードでは、関数が通常は例外を発生させると、代わりにガードが失敗します。たとえば、&lt;a href=&quot;kernel#length/1&quot;&gt; &lt;code&gt;length/1&lt;/code&gt; &lt;/a&gt;関数はリストでのみ機能します。それ以外のものと一緒に使用すると、ランタイムエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="a530de2468aeae84b5f9a5ab3d0835429e502343" translate="yes" xml:space="preserve">
          <source>In light of this observation, we should consider moving to another supervision strategy. The two other candidates are &lt;code&gt;:one_for_all&lt;/code&gt; and &lt;code&gt;:rest_for_one&lt;/code&gt;. A supervisor using the &lt;code&gt;:rest_for_one&lt;/code&gt; strategy will kill and restart child processes which were started &lt;em&gt;after&lt;/em&gt; the crashed child. In this case, we would want &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; to terminate if &lt;code&gt;KV.Registry&lt;/code&gt; terminates. This would require the bucket supervisor to be placed after the registry which violates the ordering constraints we have established two paragraphs above.</source>
          <target state="translated">この観察に照らして、別の監督戦略への移行を検討する必要があります。他の2つの候補は &lt;code&gt;:one_for_all&lt;/code&gt; と &lt;code&gt;:rest_for_one&lt;/code&gt; です。 &lt;code&gt;:rest_for_one&lt;/code&gt; 戦略を使用するスーパーバイザは、クラッシュした子の&lt;em&gt;後&lt;/em&gt;に開始さ&lt;em&gt;れ&lt;/em&gt;た子プロセスを強制終了して再起動します。この場合、 &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; が終了した場合に &lt;code&gt;KV.Registry&lt;/code&gt; を終了する必要があります。これには、上記の2つの段落で設定した順序の制約に違反するレジストリの後にバケット監視プログラムを配置する必要があります。</target>
        </trans-unit>
        <trans-unit id="287c5e7fdc75892fe61a19be625743d753001a1c" translate="yes" xml:space="preserve">
          <source>In macro code, the bang on &lt;a href=&quot;kernel#alias!/1&quot;&gt;&lt;code&gt;Kernel.alias!/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#var!/2&quot;&gt;&lt;code&gt;Kernel.var!/2&lt;/code&gt;&lt;/a&gt; signifies that &lt;a href=&quot;https://elixir-lang.org/getting-started/meta/macros.html#macros-hygiene&quot;&gt;macro hygiene&lt;/a&gt; is set aside.</source>
          <target state="translated">マクロコードでは、&lt;a href=&quot;kernel#alias!/1&quot;&gt; &lt;code&gt;Kernel.alias!/1&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;kernel#var!/2&quot;&gt; &lt;code&gt;Kernel.var!/2&lt;/code&gt; &lt;/a&gt;の強打は、&lt;a href=&quot;https://elixir-lang.org/getting-started/meta/macros.html#macros-hygiene&quot;&gt;マクロの衛生状態&lt;/a&gt;が回避されていることを示します。</target>
        </trans-unit>
        <trans-unit id="32bcee841524dde12cdf73859245e9378a9b1abe" translate="yes" xml:space="preserve">
          <source>In many cases it is more convenient to pass the expected value to &lt;a href=&quot;#raise/2&quot;&gt;&lt;code&gt;raise/2&lt;/code&gt;&lt;/a&gt; and generate the message in the &lt;a href=&quot;exception#c:exception/1&quot;&gt;&lt;code&gt;Exception.exception/1&lt;/code&gt;&lt;/a&gt; callback:</source>
          <target state="translated">多くの場合、期待される値を&lt;a href=&quot;#raise/2&quot;&gt; &lt;code&gt;raise/2&lt;/code&gt; &lt;/a&gt;に渡し、&lt;a href=&quot;exception#c:exception/1&quot;&gt; &lt;code&gt;Exception.exception/1&lt;/code&gt; &lt;/a&gt;コールバックでメッセージを生成する方が便利です。</target>
        </trans-unit>
        <trans-unit id="f3a407dd1ba9629c2d87378f7214d938dbbf397b" translate="yes" xml:space="preserve">
          <source>In many cases, we can take advantage of this. In the code above, we used &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; to both check that the given thing is a list &lt;em&gt;and&lt;/em&gt; check some properties of its length (instead of using &lt;code&gt;is_list(something) and length(something) &amp;gt; 0&lt;/code&gt;).</source>
          <target state="translated">多くの場合、これを利用できます。上記のコードでは、&lt;a href=&quot;kernel#length/1&quot;&gt; &lt;code&gt;length/1&lt;/code&gt; &lt;/a&gt;を使用して、指定されたものがリストであること&lt;em&gt;を&lt;/em&gt;確認し、その長さのいくつかのプロパティを確認し &lt;code&gt;is_list(something) and length(something) &amp;gt; 0&lt;/code&gt; を使用する代わりに）。</target>
        </trans-unit>
        <trans-unit id="1718d61cb1f8d442d32bbf909dd936aa49ffeb46" translate="yes" xml:space="preserve">
          <source>In many functional programming languages, it is common to use a list of 2-item tuples as the representation of a key-value data structure. In Elixir, when we have a list of tuples and the first item of the tuple (i.e. the key) is an atom, we call it a keyword list:</source>
          <target state="translated">多くの関数型プログラミング言語では、2項目のタプルのリストをキー値データ構造の表現として使用するのが一般的です。Elixirでは、タプルのリストがあり、タプルの最初の項目(キー)がアトムである場合、これをキーワードリストと呼びます。</target>
        </trans-unit>
        <trans-unit id="68e23cbb5429660e2faf1806ef4a612c49708bf4" translate="yes" xml:space="preserve">
          <source>In most cases, &lt;a href=&quot;#ensure_loaded/1&quot;&gt;&lt;code&gt;ensure_loaded/1&lt;/code&gt;&lt;/a&gt; is enough. &lt;a href=&quot;#ensure_compiled/1&quot;&gt;&lt;code&gt;ensure_compiled/1&lt;/code&gt;&lt;/a&gt; must be used in rare cases, usually involving macros that need to invoke a module for callback information.</source>
          <target state="translated">ほとんどの場合、&lt;a href=&quot;#ensure_loaded/1&quot;&gt; &lt;code&gt;ensure_loaded/1&lt;/code&gt; &lt;/a&gt;で十分です。&lt;a href=&quot;#ensure_compiled/1&quot;&gt; &lt;code&gt;ensure_compiled/1&lt;/code&gt; &lt;/a&gt;は、通常、コールバック情報のためにモジュールを呼び出す必要があるマクロを含む、まれなケースで使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="423cb3333a43148ea91fc3b7a37efcd42c886681" translate="yes" xml:space="preserve">
          <source>In order for the cache mechanism to work, the created ETS table needs to have access &lt;code&gt;:protected&lt;/code&gt; (the default), so all clients can read from it, while only the &lt;code&gt;KV.Registry&lt;/code&gt; process writes to it. We have also set &lt;code&gt;read_concurrency: true&lt;/code&gt; when starting the table, optimizing the table for the common scenario of concurrent read operations.</source>
          <target state="translated">キャッシュメカニズムを機能させるには、作成されたETSテーブルに &lt;code&gt;:protected&lt;/code&gt; （デフォルト）のアクセス権が必要です。これにより、すべてのクライアントがテーブルから読み取ることができ、 &lt;code&gt;KV.Registry&lt;/code&gt; プロセスのみが書き込みを行うことができます。また、テーブルの開始時に &lt;code&gt;read_concurrency: true&lt;/code&gt; 設定し、同時読み取り操作の一般的なシナリオに合わせてテーブルを最適化します。</target>
        </trans-unit>
        <trans-unit id="c81c6a20ae394a892047f71306226257ed4ae14b" translate="yes" xml:space="preserve">
          <source>In order to be loaded, an &lt;code&gt;.app&lt;/code&gt; file must be in the load paths. All &lt;code&gt;:included_applications&lt;/code&gt; will also be loaded.</source>
          <target state="translated">ロードするには、 &lt;code&gt;.app&lt;/code&gt; ファイルがロードパスにある必要があります。すべての &lt;code&gt;:included_applications&lt;/code&gt; もロードされます。</target>
        </trans-unit>
        <trans-unit id="0ce310cabbc38fde237e6f7456d065921f47f408" translate="yes" xml:space="preserve">
          <source>In order to better understand how macros work, let&amp;rsquo;s create a new module where we are going to implement &lt;code&gt;unless&lt;/code&gt;, which does the opposite of &lt;code&gt;if&lt;/code&gt;, as a macro and as a function:</source>
          <target state="translated">より良い方法をマクロの仕事を理解するためには、我々が実装しようとしている新しいモジュールを作成しましょう &lt;code&gt;unless&lt;/code&gt; の反対行い、 &lt;code&gt;if&lt;/code&gt; 、マクロとして機能などを：</target>
        </trans-unit>
        <trans-unit id="98bbe9c7dc0c95fe1893b767af4a2559d441e9f7" translate="yes" xml:space="preserve">
          <source>In order to build a variable, a context is expected. Most of the times, in order to preserve hygiene, the context must be &lt;a href=&quot;kernel.specialforms#__MODULE__/0&quot;&gt;&lt;code&gt;__MODULE__/0&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">変数を作成するには、コンテキストが必要です。ほとんどの場合、衛生状態を維持するには、コンテキストは&lt;a href=&quot;kernel.specialforms#__MODULE__/0&quot;&gt; &lt;code&gt;__MODULE__/0&lt;/code&gt; &lt;/a&gt;必要があります。</target>
        </trans-unit>
        <trans-unit id="09c48209d831c8b2ec6ba4ec948897b23f18046a" translate="yes" xml:space="preserve">
          <source>In order to build our key-value application, we are going to use three main tools:</source>
          <target state="translated">キーバリューアプリケーションを構築するために、3つの主要なツールを使用します。</target>
        </trans-unit>
        <trans-unit id="db1ca29d2377c1f8fa9329bcdb6aca022dc1f156" translate="yes" xml:space="preserve">
          <source>In order to compare more than two clauses, the &lt;a href=&quot;kernel.specialforms#cond/1&quot;&gt;&lt;code&gt;cond/1&lt;/code&gt;&lt;/a&gt; macro has to be used.</source>
          <target state="translated">3つ以上の句を比較するには、&lt;a href=&quot;kernel.specialforms#cond/1&quot;&gt; &lt;code&gt;cond/1&lt;/code&gt; &lt;/a&gt;マクロを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="7bdbf00ad68adfada8cf0d80c6af387a4904e12d" translate="yes" xml:space="preserve">
          <source>In order to configure Mix, the module that &lt;code&gt;use&lt;/code&gt;s &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Mix.Project&lt;/code&gt;&lt;/a&gt; should export a &lt;code&gt;project/0&lt;/code&gt; function that returns a keyword list representing configuration for the project.</source>
          <target state="translated">Mixを構成するには、s &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Mix.Project&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;use&lt;/code&gt; するモジュールが、プロジェクトの構成を表すキーワードリストを返す &lt;code&gt;project/0&lt;/code&gt; 関数をエクスポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="6eb392bb5990ef3fcaeb5fa0f99e17c04d60d3ab" translate="yes" xml:space="preserve">
          <source>In order to continue evolving the language without introducing breaking changes, Elixir will rely on deprecations to demote certain practices and promote new ones. Our deprecation policy is outlined in the &lt;a href=&quot;#deprecations&quot;&gt;&quot;Deprecations&quot; section&lt;/a&gt;.</source>
          <target state="translated">Elixirは、重大な変更を導入せずに言語を進化させ続けるために、非推奨に依存して特定のプラクティスを降格し、新しいプラクティスを推進します。Googleのサポート終了ポリシーについては、&lt;a href=&quot;#deprecations&quot;&gt;「&lt;/a&gt;サポート終了」セクションで説明しています。</target>
        </trans-unit>
        <trans-unit id="642f4f188110996b3a0b6c3fdce8b893ead2d9fa" translate="yes" xml:space="preserve">
          <source>In order to cope with code loading in development, protocols in Elixir provide a slow implementation of protocol dispatching specific to development.</source>
          <target state="translated">開発時のコードロードに対処するために、Elixirのプロトコルは開発に特化したプロトコルディスパッチの遅い実装を提供しています。</target>
        </trans-unit>
        <trans-unit id="6a2b5841e9d7864def29c3c36d34a45ef5565969" translate="yes" xml:space="preserve">
          <source>In order to create our own modules in Elixir, we use the &lt;code&gt;defmodule&lt;/code&gt; macro. We use the &lt;code&gt;def&lt;/code&gt; macro to define functions in that module:</source>
          <target state="translated">Elixirで独自のモジュールを作成するには、 &lt;code&gt;defmodule&lt;/code&gt; マクロを使用します。 &lt;code&gt;def&lt;/code&gt; マクロを使用して、そのモジュールで関数を定義します。</target>
        </trans-unit>
        <trans-unit id="4adfde6fe98ff6cd24536d794e886a1f37546977" translate="yes" xml:space="preserve">
          <source>In order to facilitate software reuse, Elixir provides three directives (&lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt;) plus a macro called &lt;code&gt;use&lt;/code&gt; summarized below:</source>
          <target state="translated">ソフトウェアの再利用を容易にするために、Elixirは3つのディレクティブ（ &lt;code&gt;alias&lt;/code&gt; 、 &lt;code&gt;require&lt;/code&gt; および &lt;code&gt;import&lt;/code&gt; ）と、以下に要約されている &lt;code&gt;use&lt;/code&gt; というマクロを提供しています。</target>
        </trans-unit>
        <trans-unit id="06a700b11907ab62d5a4a0a6df97c7759ea5d0ae" translate="yes" xml:space="preserve">
          <source>In order to finish our &lt;code&gt;TestCase&lt;/code&gt; implementation, we need to be able to access all defined test cases. One way of doing this is by retrieving the tests at runtime via &lt;code&gt;__MODULE__.__info__(:functions)&lt;/code&gt;, which returns a list of all functions in a given module. However, considering that we may want to store more information about each test besides the test name, a more flexible approach is required.</source>
          <target state="translated">&lt;code&gt;TestCase&lt;/code&gt; の実装を完了するには、定義されたすべてのテストケースにアクセスできる必要があります。これを行う1つの方法は、 &lt;code&gt;__MODULE__.__info__(:functions)&lt;/code&gt; を介して実行時にテストを取得することです。これは、指定されたモジュール内のすべての関数のリストを返します。ただし、テスト名の他に、各テストに関するより多くの情報を保存する場合があることを考えると、より柔軟なアプローチが必要です。</target>
        </trans-unit>
        <trans-unit id="c5a3e4590add882007f47566c77c18638d716efc" translate="yes" xml:space="preserve">
          <source>In order to fix the failing test, let&amp;rsquo;s create a file at &lt;code&gt;lib/kv/bucket.ex&lt;/code&gt; with the contents below. Feel free to give a try at implementing the &lt;code&gt;KV.Bucket&lt;/code&gt; module yourself using agents before peeking at the implementation below.</source>
          <target state="translated">失敗したテストを修正するために、 &lt;code&gt;lib/kv/bucket.ex&lt;/code&gt; に以下の内容のファイルを作成しましょう。以下の実装を覗く前に、エージェントを使用して自分で &lt;code&gt;KV.Bucket&lt;/code&gt; モジュールを実装してみてください。</target>
        </trans-unit>
        <trans-unit id="fc7b18c46cad921ea2c996d18c66b0c78849816d" translate="yes" xml:space="preserve">
          <source>In order to fix this bug, we need the registry to monitor every bucket it spawns. Once we set up a monitor, the registry will receive a notification every time a bucket process exits, allowing us to clean the registry up.</source>
          <target state="translated">このバグを修正するには、レジストリがバケットを生成するたびに監視する必要があります。モニターを設定すると、バケットプロセスが終了するたびにレジストリに通知が届くようになり、レジストリをクリーンアップできるようになります。</target>
        </trans-unit>
        <trans-unit id="5a956c6b95ce875304570bf71071ca672fa7f12b" translate="yes" xml:space="preserve">
          <source>In order to get your first project started, Elixir ships with a build tool called Mix. You can get your new project started by running:</source>
          <target state="translated">最初のプロジェクトを始めるために、ElixirにはMixというビルドツールが同梱されています。を実行することで、新しいプロジェクトを開始することができます。</target>
        </trans-unit>
        <trans-unit id="017fd6a1081d196daafbd3b60fc590b568ac6071" translate="yes" xml:space="preserve">
          <source>In order to help IEx understand that an expression consists of multiple lines we can wrap it into parentheses:</source>
          <target state="translated">式が複数行で構成されていることを IEx に理解させるために、式を括弧で囲むことができます。</target>
        </trans-unit>
        <trans-unit id="a957b1a9d6df7d7ce8fa55bcc89ebc9a60d14634" translate="yes" xml:space="preserve">
          <source>In order to invoke the callbacks above, we need to go through the corresponding &lt;code&gt;GenServer&lt;/code&gt; functions. Let&amp;rsquo;s start a registry, create a named bucket, and then look it up:</source>
          <target state="translated">上記のコールバックを呼び出すには、対応する &lt;code&gt;GenServer&lt;/code&gt; 関数を通過する必要があります。レジストリを起動して、名前付きバケットを作成し、それを調べてみましょう。</target>
        </trans-unit>
        <trans-unit id="af452841dd75bb4a44c38345c300f4a14d20c04a" translate="yes" xml:space="preserve">
          <source>In order to make our server handle simultaneous connections, we need to have one process working as an acceptor that spawns other processes to serve requests. One solution would be to change:</source>
          <target state="translated">サーバーが同時接続を扱えるようにするためには、1つのプロセスがアクセプタとして動作し、リクエストを処理するために他のプロセスをスポーンする必要があります。一つの解決策は、以下のように変更することです。</target>
        </trans-unit>
        <trans-unit id="e3a8a476eb42420a16666c234250ab684a970ce4" translate="yes" xml:space="preserve">
          <source>In order to manipulate keyword lists, Elixir provides &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt;the &lt;code&gt;Keyword&lt;/code&gt; module&lt;/a&gt;. Remember, though, keyword lists are simply lists, and as such they provide the same linear performance characteristics as lists. The longer the list, the longer it will take to find a key, to count the number of items, and so on. For this reason, keyword lists are used in Elixir mainly for passing optional values. If you need to store many items or guarantee one-key associates with at maximum one-value, you should use maps instead.</source>
          <target state="translated">Elixirは&lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt;、 &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt;キーワードリストを操作するために、キーワードモジュールを提供しています。ただし、キーワードリストは単なるリストであるため、リストと同じ線形のパフォーマンス特性を提供します。リストが長いほど、キーの検索、アイテム数のカウントなどにかかる時間が長くなります。このため、キーワードリストは主にオプションの値を渡すためにElixirで使用されます。多くのアイテムを保存する必要がある場合、または1つのキーの関連付けを最大1つの値で保証する必要がある場合は、代わりにマップを使用してください。</target>
        </trans-unit>
        <trans-unit id="af5b1e73788ff17dca0429ef7ffa66ff44df9939" translate="yes" xml:space="preserve">
          <source>In order to run distributed code, we need to start the</source>
          <target state="translated">分散コードを実行するためには</target>
        </trans-unit>
        <trans-unit id="62c900a7e8363bd8d8183eca353b3f640ed385cc" translate="yes" xml:space="preserve">
          <source>In order to run the first test, we need to have two nodes running. Move into &lt;code&gt;apps/kv&lt;/code&gt; and let&amp;rsquo;s restart the node named &lt;code&gt;bar&lt;/code&gt; which is going to be used by tests.</source>
          <target state="translated">最初のテストを実行するには、2つのノードを実行する必要があります。 &lt;code&gt;apps/kv&lt;/code&gt; に移動して、テストで使用される &lt;code&gt;bar&lt;/code&gt; という名前のノードを再起動します。</target>
        </trans-unit>
        <trans-unit id="64a048080239b32ae9270b349a43b94c3e07e07c" translate="yes" xml:space="preserve">
          <source>In order to speed up dispatching in production environments, where all implementations are known up-front, Elixir provides a feature called protocol consolidation. Consolidation directly links protocols to their implementations in a way that invoking a function from a consolidated protocol is equivalent to invoking two remote functions.</source>
          <target state="translated">すべての実装が事前にわかっている本番環境でのディスパッチを高速化するために、Elixirはプロトコル統合と呼ばれる機能を提供しています。コンソリデーションは、コンソリデーションされたプロトコルから関数を呼び出すことが、2つのリモート関数を呼び出すことと同等になるように、プロトコルをその実装に直接リンクさせます。</target>
        </trans-unit>
        <trans-unit id="8d8b39acde42481af0b84b36b66305d49c434a4a" translate="yes" xml:space="preserve">
          <source>In order to start a supervisor, we need to first define a child process that will be supervised. As an example, we will define a GenServer that represents a stack:</source>
          <target state="translated">スーパバイザを開始するためには、まず、スーパバイザとなる子プロセスを定義する必要があります。例として、スタックを表す GenServer を定義します。</target>
        </trans-unit>
        <trans-unit id="656310fbcb50af634eac84272798b02ab00dba6a" translate="yes" xml:space="preserve">
          <source>In order to understand the underlying code, we&amp;rsquo;d need macros, so we will revisit this pattern in the meta-programming guide. However, the focus here is on how using module attributes as storage allows developers to create DSLs.</source>
          <target state="translated">基礎となるコードを理解するには、マクロが必要なので、メタプログラミングガイドでこのパターンを再検討します。ただし、ここでは、モジュール属性をストレージとして使用して開発者がDSLを作成する方法に焦点を当てています。</target>
        </trans-unit>
        <trans-unit id="1ca6c027f8dcdd141de11fbd20d5f0afb503fc0f" translate="yes" xml:space="preserve">
          <source>In order to use dependencies, you need to add a &lt;code&gt;:deps&lt;/code&gt; key to your project configuration. We often extract the list of dependencies into its own function:</source>
          <target state="translated">依存関係を使用するには、プロジェクト構成に &lt;code&gt;:deps&lt;/code&gt; キーを追加する必要があります。多くの場合、依存関係のリストを独自の関数に抽出します。</target>
        </trans-unit>
        <trans-unit id="ea5cbfc0efc9a5e4905ac0bfbf89bf8917d5354f" translate="yes" xml:space="preserve">
          <source>In order to use the application environment in our code, we need to replace &lt;code&gt;KV.Router.table/0&lt;/code&gt; with the definition below:</source>
          <target state="translated">コードでアプリケーション環境を使用するには、 &lt;code&gt;KV.Router.table/0&lt;/code&gt; を以下の定義に置き換える必要があります。</target>
        </trans-unit>
        <trans-unit id="dcd42d7d1276fbdd4330c63012ce7d34e85da421" translate="yes" xml:space="preserve">
          <source>In order to write and read files, one must use the functions in the &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module. By default, a file is opened in &lt;code&gt;:binary&lt;/code&gt; mode, which requires the functions &lt;a href=&quot;io#binread/2&quot;&gt;&lt;code&gt;IO.binread/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;io#binwrite/2&quot;&gt;&lt;code&gt;IO.binwrite/2&lt;/code&gt;&lt;/a&gt; to interact with the file. A developer may pass &lt;code&gt;:utf8&lt;/code&gt; as an option when opening the file and then all other functions from &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; are available, since they work directly with Unicode data.</source>
          <target state="translated">ファイルを読み書きするには、&lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;モジュールの関数を使用する必要があります。デフォルトでは、ファイルは &lt;code&gt;:binary&lt;/code&gt; モードで開かれます。これには、ファイルを操作するために関数&lt;a href=&quot;io#binread/2&quot;&gt; &lt;code&gt;IO.binread/2&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;io#binwrite/2&quot;&gt; &lt;code&gt;IO.binwrite/2&lt;/code&gt; &lt;/a&gt;が必要です。開発者は、ファイルを開くときにオプションとして &lt;code&gt;:utf8&lt;/code&gt; を渡すことができます。これにより、&lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;からの他のすべての関数を使用できます。これらの関数はUnicodeデータを直接処理するためです。</target>
        </trans-unit>
        <trans-unit id="82ce7a0943dbb663e7fc6760db6023cf3368a14d" translate="yes" xml:space="preserve">
          <source>In order to write and read files, one must use the functions in the &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module. By default, a file is opened in binary mode, which requires the functions &lt;a href=&quot;io#binread/2&quot;&gt;&lt;code&gt;IO.binread/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;io#binwrite/2&quot;&gt;&lt;code&gt;IO.binwrite/2&lt;/code&gt;&lt;/a&gt; to interact with the file. A developer may pass &lt;code&gt;:utf8&lt;/code&gt; as an option when opening the file, then the slower &lt;a href=&quot;io#read/2&quot;&gt;&lt;code&gt;IO.read/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;io#write/2&quot;&gt;&lt;code&gt;IO.write/2&lt;/code&gt;&lt;/a&gt; functions must be used as they are responsible for doing the proper conversions and providing the proper data guarantees.</source>
          <target state="translated">ファイルの書き込みと読み取りを行うには、&lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;モジュールの関数を使用する必要があります。デフォルトでは、ファイルはバイナリモードで開かれます。ファイルを操作するには、関数&lt;a href=&quot;io#binread/2&quot;&gt; &lt;code&gt;IO.binread/2&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;io#binwrite/2&quot;&gt; &lt;code&gt;IO.binwrite/2&lt;/code&gt; &lt;/a&gt;が必要です。開発者は、ファイルを開くときにオプションとして &lt;code&gt;:utf8&lt;/code&gt; を渡すことができます。適切な変換を実行し、適切なデータ保証を提供する必要があるため、遅い&lt;a href=&quot;io#read/2&quot;&gt; &lt;code&gt;IO.read/2&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;io#write/2&quot;&gt; &lt;code&gt;IO.write/2&lt;/code&gt; &lt;/a&gt;関数を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="31ee06abc4e001e3f6a5b13f3dfe4953038e624e" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;&amp;amp;(&amp;amp;1 * 2)&lt;/code&gt; is equivalent to &lt;code&gt;fn x -&amp;gt; x * 2 end&lt;/code&gt;.</source>
          <target state="translated">つまり、 &lt;code&gt;&amp;amp;(&amp;amp;1 * 2)&lt;/code&gt; は &lt;code&gt;fn x -&amp;gt; x * 2 end&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="886ca2f2765b1ff87730f7dc9a052f3a738d7792" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;&amp;lt;%= @foo %&amp;gt;&lt;/code&gt; translates to:</source>
          <target state="translated">つまり、 &lt;code&gt;&amp;lt;%= @foo %&amp;gt;&lt;/code&gt; 変換されます。</target>
        </trans-unit>
        <trans-unit id="93125c6aa3c9fdcea503c87c1c3998ce536dbba7" translate="yes" xml:space="preserve">
          <source>In other words, &lt;strong&gt;do not&lt;/strong&gt;:</source>
          <target state="translated">つまり、次の&lt;strong&gt;ことをしない&lt;/strong&gt;で&lt;strong&gt;ください&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="6d77f8954062d90a90e9c6b5408cf752db4ed5cd" translate="yes" xml:space="preserve">
          <source>In other words, Elixir will only parse options that are used by the runtime, ignoring all others. If you would like to parse all switches, regardless if they exist or not, you can force creation of atoms by passing &lt;code&gt;allow_nonexistent_atoms: true&lt;/code&gt; as option. Use this option with care. It is only useful when you are building command-line applications that receive dynamically-named arguments and must be avoided in long-running systems.</source>
          <target state="translated">つまり、Elixirはランタイムで使用されるオプションのみを解析し、他のオプションはすべて無視します。スイッチが存在するかどうかに関係なく、すべてのスイッチを解析する場合は、オプションとして &lt;code&gt;allow_nonexistent_atoms: true&lt;/code&gt; を渡すことで、アトムを強制的に作成できます。このオプションは注意して使用してください。これは、動的に名前が付けられた引数を受け取り、実行時間の長いシステムでは回避する必要があるコマンドラインアプリケーションを構築する場合にのみ役立ちます。</target>
        </trans-unit>
        <trans-unit id="38fe91f6b4425a57a05293a344c316d610b9df57" translate="yes" xml:space="preserve">
          <source>In other words, functions using the word &quot;size&quot; in its name will take the same amount of time whether the data structure is tiny or huge. Conversely, functions having &quot;length&quot; in its name will take more time as the data structure grows in size.</source>
          <target state="translated">つまり、名前に「サイズ」という言葉が付いている関数は、データ構造が小さくても大きくても同じ時間がかかります。逆に、名前に「長さ」を持つ関数は、データ構造体が大きくなるほど時間がかかります。</target>
        </trans-unit>
        <trans-unit id="60a4e6e4835459586a75795caa4bfdc4a5131e02" translate="yes" xml:space="preserve">
          <source>In other words, if it is important that a process cleans after itself when your application or the supervision tree is shutting down, then this process must trap exits and its child specification should specify the proper &lt;code&gt;:shutdown&lt;/code&gt; value, ensuring it terminates within a reasonable interval.</source>
          <target state="translated">言い換えると、アプリケーションまたは監視ツリーのシャットダウン時にプロセスが自動的にクリーンアップすることが重要である場合、このプロセスは出口をトラップする必要があり、その子仕様は適切な &lt;code&gt;:shutdown&lt;/code&gt; 値を指定して、妥当な間隔内で終了することを保証する必要があります。</target>
        </trans-unit>
        <trans-unit id="1f496a7679d30119adb2cc52d4073c178807ab2e" translate="yes" xml:space="preserve">
          <source>In other words, it is important to make a distinction between a regular Elixir value (like a list, a map, a process, a reference, etc) and a quoted expression. Some values, such as integers, atoms, and strings, have a quoted expression equal to the value itself. Other values, like maps, need to be explicitly converted. Finally, values like functions and references cannot be converted to a quoted expression at all.</source>
          <target state="translated">つまり、通常のElixirの値(リスト、マップ、プロセス、参照など)と引用符で囲まれた式を区別することが重要です。整数、アトム、文字列などの値の中には、値自体と等しい引用符で囲まれた式を持つものがあります。マップのような他の値は、明示的に変換する必要があります。最後に、関数や参照のような値は引用符付き式に変換することはできません。</target>
        </trans-unit>
        <trans-unit id="6de004f8f04712ff0ec3d814c33ef7cd9f1fbc8d" translate="yes" xml:space="preserve">
          <source>In other words, the atom &lt;code&gt;:jos&amp;eacute;&lt;/code&gt; can only be written with the code points &lt;code&gt;006A 006F 0073 00E9&lt;/code&gt;. Using another normalization form will lead to a tokenizer error. On the other hand, &lt;code&gt;:&quot;jos&amp;eacute;&quot;&lt;/code&gt; may be written as &lt;code&gt;006A 006F 0073 00E9&lt;/code&gt; or &lt;code&gt;006A 006F 0073 0065 0301&lt;/code&gt;, since it is written between quotes.</source>
          <target state="translated">つまり、アトム &lt;code&gt;:jos&amp;eacute;&lt;/code&gt; は、コードポイント &lt;code&gt;006A 006F 0073 00E9&lt;/code&gt; でのみ記述できます。別の正規化形式を使用すると、トークナイザーエラーが発生します。一方、 &lt;code&gt;:&quot;jos&amp;eacute;&quot;&lt;/code&gt; は、引用符で &lt;code&gt;006A 006F 0073 00E9&lt;/code&gt; れているため、006A 006F 0073 00E9または &lt;code&gt;006A 006F 0073 0065 0301&lt;/code&gt; と記述できます。</target>
        </trans-unit>
        <trans-unit id="a46592ea6e94de48f6246d5ad4aa9e7f178675e1" translate="yes" xml:space="preserve">
          <source>In other words, the expression above simply translates to:</source>
          <target state="translated">つまり、上記の表現は単純に訳すと</target>
        </trans-unit>
        <trans-unit id="cf94a3991ed1b9e98b23fc9feebaf13e89fbcbfd" translate="yes" xml:space="preserve">
          <source>In other words, this function tries to strip the &lt;code&gt;from&lt;/code&gt; prefix from &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">つまり、この関数は、 &lt;code&gt;from&lt;/code&gt; 接頭辞を &lt;code&gt;path&lt;/code&gt; から削除しようとします。</target>
        </trans-unit>
        <trans-unit id="05304a75e275a349e9ffa834cabff9641ce49488" translate="yes" xml:space="preserve">
          <source>In other words, this module expects invalid data to be detected elsewhere, usually when retrieving data from the external source. For example, a driver that reads strings from a database will be responsible to check the validity of the encoding. &lt;a href=&quot;string#chunk/2&quot;&gt;&lt;code&gt;String.chunk/2&lt;/code&gt;&lt;/a&gt; can be used for breaking a string into valid and invalid parts.</source>
          <target state="translated">つまり、このモジュールは、通常は外部ソースからデータを取得するときに、無効なデータが他の場所で検出されることを期待します。たとえば、データベースから文字列を読み取るドライバーは、エンコーディングの有効性をチェックする必要があります。&lt;a href=&quot;string#chunk/2&quot;&gt; &lt;code&gt;String.chunk/2&lt;/code&gt; &lt;/a&gt;は、文字列を有効な部分と無効な部分に分割するために使用できます。</target>
        </trans-unit>
        <trans-unit id="558d46588b101dc23bc0d5fd0f4acaf2b4c0f74f" translate="yes" xml:space="preserve">
          <source>In other words, we converted each expression given to &lt;code&gt;case/2&lt;/code&gt; as a step in &lt;code&gt;with&lt;/code&gt;. As soon as any of the steps return something that does not match &lt;code&gt;{:ok, x}&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt; aborts, and returns the non-matching value.</source>
          <target state="translated">つまり、でのステップインとして、 &lt;code&gt;case/2&lt;/code&gt; に与えられた各式を変換し &lt;code&gt;with&lt;/code&gt; 。すぐにステップのいずれかと一致していない何かを返す &lt;code&gt;{:ok, x}&lt;/code&gt; 、 &lt;code&gt;with&lt;/code&gt; アボート、非マッチング値を返しています。</target>
        </trans-unit>
        <trans-unit id="9b5785a062ee13450968c9614ec6ca20310e34ad" translate="yes" xml:space="preserve">
          <source>In other words, we want the registry to keep on running even if a bucket crashes. Let&amp;rsquo;s write a new registry test:</source>
          <target state="translated">つまり、バケットがクラッシュしても、レジストリを実行し続ける必要があります。新しいレジストリテストを作成してみましょう。</target>
        </trans-unit>
        <trans-unit id="32be3988a4bf49863fd56d4a7249dcf02990b46b" translate="yes" xml:space="preserve">
          <source>In other words, when invoked as:</source>
          <target state="translated">として呼び出されたとき、言い換えれば</target>
        </trans-unit>
        <trans-unit id="e8d6c41a56de39aca9e7a91aac78285a5e2f3f02" translate="yes" xml:space="preserve">
          <source>In other words:</source>
          <target state="translated">言い換えれば</target>
        </trans-unit>
        <trans-unit id="49d20f893de0acff7f5dc08503dbde4a71a0e1bc" translate="yes" xml:space="preserve">
          <source>In particular, charlists will be printed back by default in single quotes if they contain only printable ASCII characters:</source>
          <target state="translated">特に、文字列が印刷可能なASCII文字のみを含む場合、デフォルトでは単一引用符で印刷されます。</target>
        </trans-unit>
        <trans-unit id="3467114e6e90f4dae7f2e188d401c44475293e7c" translate="yes" xml:space="preserve">
          <source>In practice, charlists are used mostly when interfacing with Erlang, in particular old libraries that do not accept binaries as arguments. You can convert a charlist to a string and back by using the &lt;code&gt;to_string/1&lt;/code&gt; and &lt;code&gt;to_charlist/1&lt;/code&gt; functions:</source>
          <target state="translated">実際には、charlistは、Erlangとのインターフェース時に主に使用されます。特に、バイナリを引数として受け入れない古いライブラリは使用されます。 &lt;code&gt;to_string/1&lt;/code&gt; および &lt;code&gt;to_charlist/1&lt;/code&gt; 関数を使用して、charlistを文字列に変換したり、逆に変換したりできます。</target>
        </trans-unit>
        <trans-unit id="b004abb70250b3f1e68f41dcfedc223284b584eb" translate="yes" xml:space="preserve">
          <source>In practice, however, Elixir developers rarely use the &lt;code&gt;try/rescue&lt;/code&gt; construct. For example, many languages would force you to rescue an error when a file cannot be opened successfully. Elixir instead provides a &lt;code&gt;File.read/1&lt;/code&gt; function which returns a tuple containing information about whether the file was opened successfully:</source>
          <target state="translated">ただし、実際には、Elixir開発者が &lt;code&gt;try/rescue&lt;/code&gt; コンストラクトを使用することはほとんどありません。たとえば、多くの言語では、ファイルを正常に開くことができない場合にエラーを救済する必要があります。代わりに、Elixirは &lt;code&gt;File.read/1&lt;/code&gt; 関数を提供し、ファイルが正常に開かれたかどうかに関する情報を含むタプルを返します。</target>
        </trans-unit>
        <trans-unit id="8e292cda7fd341df2ad10ad68515a260c1f9ceca" translate="yes" xml:space="preserve">
          <source>In practice, if you find yourself in a position where you need a process registry for dynamic processes, you should use &lt;a href=&quot;https://hexdocs.pm/elixir/Registry.html&quot;&gt;the &lt;code&gt;Registry&lt;/code&gt; module&lt;/a&gt; provided as part of Elixir. It provides functionality similar to the one we have built using a GenServer + &lt;code&gt;:ets&lt;/code&gt; while also being able to perform both writes and reads concurrently. &lt;a href=&quot;https://elixir-lang.org/blog/2017/01/05/elixir-v1-4-0-released/&quot;&gt;It has been benchmarked to scale across all cores even on machines with 40 cores&lt;/a&gt;.</source>
          <target state="translated">実際には、動的プロセスのプロセスレジストリが必要な場合は、Elixirの一部として提供されて&lt;a href=&quot;https://hexdocs.pm/elixir/Registry.html&quot;&gt;いる &lt;code&gt;Registry&lt;/code&gt; モジュール&lt;/a&gt;を使用する必要があります。GenServer + &lt;code&gt;:ets&lt;/code&gt; を使用して構築した機能と同様の機能を提供すると同時に、書き込みと読み取りの両方を同時に実行することもできます。&lt;a href=&quot;https://elixir-lang.org/blog/2017/01/05/elixir-v1-4-0-released/&quot;&gt;40コアのマシンでも、すべてのコアにまたがってスケーリングするようにベンチマークされています&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1db0e725bf7fce8e6792fe7c1b5f4904976e1c8d" translate="yes" xml:space="preserve">
          <source>In practice, it is common to have both server and client functions in the same module. If the server and/or client implementations are growing complex, you may want to have them in different modules.</source>
          <target state="translated">実際には、サーバとクライアントの両方の機能を同じモジュールに入れるのが一般的です。サーバやクライアントの実装が複雑になってきた場合は、それらを別のモジュールに入れたいと思うかもしれません。</target>
        </trans-unit>
        <trans-unit id="70101e1c300d630f1ea86765138df21a3dc6ed93" translate="yes" xml:space="preserve">
          <source>In practice, it is more likely you will reach the Erlang</source>
          <target state="translated">実際には、Erlangの</target>
        </trans-unit>
        <trans-unit id="c83f942e405f3eb5ce3163220a02a8f1db134d20" translate="yes" xml:space="preserve">
          <source>In practice, we are not expecting the processes working as buckets to fail. But, if it does happen, for whatever reason, we can rest assured that our system will continue to work as intended.</source>
          <target state="translated">実際には、バケットとして動作しているプロセスが故障することは想定していません。しかし、何らかの理由で障害が発生した場合でも、システムは意図した通りに動作し続けるので安心してください。</target>
        </trans-unit>
        <trans-unit id="bcd76319c1bff6236a950ae66cde047b189b7040" translate="yes" xml:space="preserve">
          <source>In practice, you rarely load applications by hand because that is part of the start process, explained next.</source>
          <target state="translated">実際には、アプリケーションを手でロードすることはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="b81ae9e0c2bb006469e999756d7c827614795f38" translate="yes" xml:space="preserve">
          <source>In rare circumstances, this function can fail on Unix. It may happen if read permissions do not exist for the parent directories of the current directory. For this reason, returns &lt;code&gt;{:ok, cwd}&lt;/code&gt; in case of success, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">まれに、この関数がUnixで失敗することがあります。現在のディレクトリの親ディレクトリに読み取り権限がない場合に発生することがあります。このため、成功した場合は &lt;code&gt;{:ok, cwd}&lt;/code&gt; を返し &lt;code&gt;{:error, reason}&lt;/code&gt; それ以外の場合は{：error、reason}を返します。</target>
        </trans-unit>
        <trans-unit id="acd5d3b4600c9d05bb359546d1009f1e407c770b" translate="yes" xml:space="preserve">
          <source>In set notation: &lt;code&gt;[\p{ID_Start}\p{Mn}\p{Mc}\p{Nd}\p{Pc}\p{Other_ID_Continue}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]&lt;/code&gt;</source>
          <target state="translated">セット表記： &lt;code&gt;[\p{ID_Start}\p{Mn}\p{Mc}\p{Nd}\p{Pc}\p{Other_ID_Continue}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f49cbc94b22c26f24f368405117b1889a3c176b" translate="yes" xml:space="preserve">
          <source>In set notation: &lt;code&gt;[\p{L}\p{Nl}\p{Other_ID_Start}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]&lt;/code&gt;</source>
          <target state="translated">セット表記： &lt;code&gt;[\p{L}\p{Nl}\p{Other_ID_Start}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c2ccee93d894b5296828c59c78b91159cd164712" translate="yes" xml:space="preserve">
          <source>In some cases, it may be convenient to provide a default implementation for all types. This can be achieved by setting the &lt;code&gt;@fallback_to_any&lt;/code&gt; attribute to &lt;code&gt;true&lt;/code&gt; in the protocol definition:</source>
          <target state="translated">場合によっては、すべてのタイプにデフォルトの実装を提供すると便利です。これは、プロトコル定義で &lt;code&gt;@fallback_to_any&lt;/code&gt; 属性を &lt;code&gt;true&lt;/code&gt; に設定することで実現できます。</target>
        </trans-unit>
        <trans-unit id="371305821a86a1fd6063efb5d024b0464bdede1a" translate="yes" xml:space="preserve">
          <source>In some cases, it may be necessary to inject many values inside a list. For example, imagine you have a list containing &lt;code&gt;[1, 2, 6]&lt;/code&gt; and we want to inject &lt;code&gt;[3, 4, 5]&lt;/code&gt; into it. Using &lt;code&gt;unquote&lt;/code&gt; won&amp;rsquo;t yield the desired result:</source>
          <target state="translated">場合によっては、リスト内に多くの値を挿入する必要があります。たとえば、 &lt;code&gt;[1, 2, 6]&lt;/code&gt; 1、2、6 ]を含むリストがあり、それに &lt;code&gt;[3, 4, 5]&lt;/code&gt; ]を挿入したいとします。 &lt;code&gt;unquote&lt;/code&gt; を使用しても、望ましい結果は得られません。</target>
        </trans-unit>
        <trans-unit id="606ff8e75aa81c7c8c049f5b60f58898dddc0286" translate="yes" xml:space="preserve">
          <source>In some cases, this may lead to undesired formatting. Therefore, &lt;strong&gt;some code generated by the formatter may not be aesthetically pleasing and may require explicit intervention from the developer&lt;/strong&gt;. That's why we do not recommend to run the formatter blindly in an existing codebase. Instead you should format and sanity check each formatted file.</source>
          <target state="translated">場合によっては、これは望ましくないフォーマットにつながる可能性があります。したがって、&lt;strong&gt;フォーマッタによって生成された一部のコードは、見た目が美しくなく、開発者による明示的な介入が必要になる場合があり&lt;/strong&gt;ます。そのため、既存のコードベースで盲目的にフォーマッターを実行することはお勧めしません。代わりに、フォーマットされた各ファイルをフォーマットして健全性チェックを行う必要があります。</target>
        </trans-unit>
        <trans-unit id="e9e037bc0aa6cd7738573dffae9758c75aa58f06" translate="yes" xml:space="preserve">
          <source>In some cases, you don&amp;rsquo;t care about a particular value in a pattern. It is a common practice to bind those values to the underscore, &lt;code&gt;_&lt;/code&gt;. For example, if only the head of the list matters to us, we can assign the tail to underscore:</source>
          <target state="translated">場合によっては、パターン内の特定の値を気にする必要はありません。これらの値をアンダースコア &lt;code&gt;_&lt;/code&gt; にバインドするのが一般的な方法です。たとえば、リストの先頭のみが重要な場合は、アンダースコアに末尾を割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="4bf473ae676eadb3b6d9002d5044ddc6e88467a0" translate="yes" xml:space="preserve">
          <source>In some cases, you may need to inject such &lt;em&gt;values&lt;/em&gt; into &lt;em&gt;quoted expressions&lt;/em&gt;. To do that, we need to first escape those values into quoted expressions with the help of &lt;code&gt;Macro.escape/1&lt;/code&gt;:</source>
          <target state="translated">場合によっては、そのような&lt;em&gt;値&lt;/em&gt;を&lt;em&gt;引用符付きの式&lt;/em&gt;に挿入する必要があります。これを行うには、まず &lt;code&gt;Macro.escape/1&lt;/code&gt; を使用して、これらの値を引用符付きの式にエスケープする必要があります。</target>
        </trans-unit>
        <trans-unit id="f72fba3c3196c1696a309102e4d11fa8e7e9ddc2" translate="yes" xml:space="preserve">
          <source>In some cases, you want to access an alias or a module defined in the caller. For such, you can use the &lt;code&gt;alias!&lt;/code&gt; macro:</source>
          <target state="translated">場合によっては、呼び出し元で定義されたエイリアスまたはモジュールにアクセスする必要があります。そのためには、 &lt;code&gt;alias!&lt;/code&gt; を使用できます！大きい：</target>
        </trans-unit>
        <trans-unit id="ba5d8febe75db79d78b1632bb42524ac427524c5" translate="yes" xml:space="preserve">
          <source>In some situations, you can use the fact the formatter does not generate elegant code as a hint for refactoring. Take this code:</source>
          <target state="translated">状況によっては、フォーマッタがエレガントなコードを生成しないという事実をリファクタリングのヒントとして使うことができます。このコードを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="fa2a12aa6aedffdc527ed2aeaa4a499eafdd3bd3" translate="yes" xml:space="preserve">
          <source>In such cases, developers should instead import or alias the module directly, so that they can customize those as they wish, without the indirection behind &lt;a href=&quot;#use/2&quot;&gt;&lt;code&gt;use/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このような場合、開発者は代わりにモジュールを直接インポートまたはエイリアス化する必要があります。これにより、&lt;a href=&quot;#use/2&quot;&gt; &lt;code&gt;use/2&lt;/code&gt; の&lt;/a&gt;間接参照なしで、必要に応じてモジュールをカスタマイズできます。</target>
        </trans-unit>
        <trans-unit id="7ee68d6d5538c71b755e522365fc502dbb4b5228" translate="yes" xml:space="preserve">
          <source>In summary, documentation is a contract with users of your API, who may not necessarily have access to the source code; whereas code comments are for those who interact directly with the source. You can learn and express different guarantees about your software by separating those two concepts.</source>
          <target state="translated">要約すると、ドキュメントはAPIのユーザーとの契約であり、必ずしもソースコードにアクセスできるとは限らないのに対し、コードコメントはソースと直接やりとりする人のためのものです。この2つの概念を分離することで、ソフトウェアに関する異なる保証を学び、表現することができます。</target>
        </trans-unit>
        <trans-unit id="88056ec75ab5d6672e9f690c2cbe9609ac25a458" translate="yes" xml:space="preserve">
          <source>In the &quot;Mix.Task&quot; section, we have defined a task that would be available to everyone using our project as a dependency. What if we wanted the task to only be available for our project? Just define an alias:</source>
          <target state="translated">Mix.Task &quot;セクションでは、プロジェクトを依存関係として使用しているすべての人が利用できるタスクを定義しました。このタスクを自分のプロジェクトだけで利用できるようにしたい場合はどうしたらいいでしょうか?エイリアスを定義するだけです。</target>
        </trans-unit>
        <trans-unit id="ff37981f126b5bf2fa55d0c06620d51ba16e7f55" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;agent&quot;&gt;previous chapter&lt;/a&gt;, we used agents to represent our buckets. In the &lt;a href=&quot;introduction-to-mix&quot;&gt;introduction to mix&lt;/a&gt;, we specified we would like to name each bucket so we can do the following:</source>
          <target state="translated">では&lt;a href=&quot;agent&quot;&gt;前章&lt;/a&gt;、私たちはバケツを表現するために薬を使用していました。で&lt;a href=&quot;introduction-to-mix&quot;&gt;混合する導入&lt;/a&gt;、我々は、我々は次のことを行うことができますので、各バケットに名前を付けたい指定しました：</target>
        </trans-unit>
        <trans-unit id="3b5fc14f69e9c66ff005f61efabe92506fc54ff9" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;basic-types&quot;&gt;previous chapter&lt;/a&gt;, we saw Elixir provides &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; as arithmetic operators, plus the functions &lt;code&gt;div/2&lt;/code&gt; and &lt;code&gt;rem/2&lt;/code&gt; for integer division and remainder.</source>
          <target state="translated">&lt;a href=&quot;basic-types&quot;&gt;前章&lt;/a&gt;、我々は、エリクサーが提供見 &lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;-&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 、 &lt;code&gt;/&lt;/code&gt; 算術演算子、プラス機能として &lt;code&gt;div/2&lt;/code&gt; 及び &lt;code&gt;rem/2&lt;/code&gt; 整数除算と剰余のために。</target>
        </trans-unit>
        <trans-unit id="f26102656dadf27f08b5ecc06639ee0453b4518a" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;structs&quot;&gt;previous chapter&lt;/a&gt;, we have learned that although structs are maps, they do not share protocol implementations with maps. For example, &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;s (sets based on maps) are implemented as structs. Let&amp;rsquo;s try to use the &lt;code&gt;Size&lt;/code&gt; protocol with a &lt;code&gt;MapSet&lt;/code&gt;:</source>
          <target state="translated">では&lt;a href=&quot;structs&quot;&gt;前章&lt;/a&gt;、我々は、構造体がマップされているものの、彼らはマップでプロトコル実装を共有していないことを学びました。たとえば、&lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt;（マップに基づくセット）は構造体として実装されます。 &lt;code&gt;MapSet&lt;/code&gt; で &lt;code&gt;Size&lt;/code&gt; プロトコルを使用してみましょう：</target>
        </trans-unit>
        <trans-unit id="53173cc148f94bd7e146b01b777ce24e106147bb" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;__using__/1&lt;/code&gt; implementation, we will initialize a module attribute named &lt;code&gt;@tests&lt;/code&gt; to an empty list, then store the name of each defined test in this attribute so the tests can be invoked from the &lt;code&gt;run&lt;/code&gt; function.</source>
          <target state="translated">で &lt;code&gt;__using__/1&lt;/code&gt; の実装、我々は、名前のモジュールの属性に初期化されます &lt;code&gt;@tests&lt;/code&gt; テストから呼び出すことができるように、この属性で定義された各テストの名前を格納し、その後、空のリストには &lt;code&gt;run&lt;/code&gt; 機能。</target>
        </trans-unit>
        <trans-unit id="b21c1f93db813518da68dd14fe39d40364740d5a" translate="yes" xml:space="preserve">
          <source>In the Applications tab, you will see all applications currently running in your system alongside their supervision tree. You can select the &lt;code&gt;kv&lt;/code&gt; application to explore it further:</source>
          <target state="translated">[アプリケーション]タブには、システムで現在実行されているすべてのアプリケーションが監視ツリーとともに表示されます。 &lt;code&gt;kv&lt;/code&gt; アプリケーションを選択して、さらに調査することができます。</target>
        </trans-unit>
        <trans-unit id="bde538c8f6213c2789f457ce470a93e8d2f207d9" translate="yes" xml:space="preserve">
          <source>In the above, process termination refers to unsuccessful termination, which is determined by the &lt;code&gt;:restart&lt;/code&gt; option.</source>
          <target state="translated">上記では、プロセスの終了とは、 &lt;code&gt;:restart&lt;/code&gt; オプションによって決定される失敗した終了を指します。</target>
        </trans-unit>
        <trans-unit id="de44ed6132703d951e8099501d3dde1a95e8c6be" translate="yes" xml:space="preserve">
          <source>In the case of calls to anonymous functions, the inner tuple with the dot special form has only one argument, reflecting the fact that the operator is unary:</source>
          <target state="translated">匿名関数を呼び出す場合、ドット特殊形の内側タプルは引数が1つしかなく、演算子が単項演算子であることを反映しています。</target>
        </trans-unit>
        <trans-unit id="bee66e2e0ed3861603c7e12d98d2bb864e0a4a57" translate="yes" xml:space="preserve">
          <source>In the case of the event &lt;code&gt;:flush&lt;/code&gt; handlers should flush any pending data. This event is triggered by &lt;a href=&quot;#flush/0&quot;&gt;&lt;code&gt;flush/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">イベントの場合、 &lt;code&gt;:flush&lt;/code&gt; ハンドラーは保留中のデータをすべてフラッシュする必要があります。このイベントは、&lt;a href=&quot;#flush/0&quot;&gt; &lt;code&gt;flush/0&lt;/code&gt; &lt;/a&gt;によってトリガーされます。</target>
        </trans-unit>
        <trans-unit id="a7d253a49741f6c380664521d0e7ead5dde4a470" translate="yes" xml:space="preserve">
          <source>In the code above, we have a process, which we call &amp;ldquo;the client&amp;rdquo; sending a request to an agent, &amp;ldquo;the server&amp;rdquo;. The request contains an anonymous function, which must be executed by the server.</source>
          <target state="translated">上記のコードには、エージェントにリクエストを送信する「クライアント」と呼ばれるプロセス「サーバー」があります。リクエストには匿名の関数が含まれており、サーバーで実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="2ea691104e7ec52f4ddc63f9f0cace981d953b17" translate="yes" xml:space="preserve">
          <source>In the environment you can access the current filename, line numbers, set up aliases, the current function and others.</source>
          <target state="translated">環境では、現在のファイル名、行番号、エイリアスの設定、現在の関数などにアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="e0731e3b2d6896ada3ab5956119cf51186ed0825" translate="yes" xml:space="preserve">
          <source>In the environment you can access the filename, line numbers, set up aliases, the function and others.</source>
          <target state="translated">環境では、ファイル名、行番号、エイリアスの設定、関数などにアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="2913df470cab8312823dbbd9aad2e70e4f9242e6" translate="yes" xml:space="preserve">
          <source>In the example above we have created the alias &lt;code&gt;some_alias&lt;/code&gt; that will run the task &lt;code&gt;mix hex.info&lt;/code&gt;, then &lt;a href=&quot;mix.tasks.run&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt; to run an Elixir script, then &lt;a href=&quot;mix.tasks.cmd&quot;&gt;&lt;code&gt;mix cmd&lt;/code&gt;&lt;/a&gt; to execute a command line shell script. This shows how powerful aliases mixed with Mix tasks can be.</source>
          <target state="translated">私たちは、エイリアス作成した上記の例で &lt;code&gt;some_alias&lt;/code&gt; タスクを実行します &lt;code&gt;mix hex.info&lt;/code&gt; 、そして&lt;a href=&quot;mix.tasks.run&quot;&gt; &lt;code&gt;mix run&lt;/code&gt; &lt;/a&gt;エリクサースクリプトを実行し、その後、&lt;a href=&quot;mix.tasks.cmd&quot;&gt; &lt;code&gt;mix cmd&lt;/code&gt; &lt;/a&gt;コマンドラインシェルスクリプトを実行します。これは、Mixタスクと混合したエイリアスがいかに強力かを示しています。</target>
        </trans-unit>
        <trans-unit id="8a1ba160e9b96d6822e0f9cf64aea8a58c334907" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#max/1&quot;&gt;&lt;code&gt;max/1&lt;/code&gt;&lt;/a&gt; returned March 31st instead of April 1st because the structural comparison compares the day before the year. This can be addressed by using &lt;a href=&quot;#max_by/3&quot;&gt;&lt;code&gt;max_by/3&lt;/code&gt;&lt;/a&gt; and by relying on structures where the most significant digits come first. In this particular case, we can use &lt;a href=&quot;date#to_erl/1&quot;&gt;&lt;code&gt;Date.to_erl/1&lt;/code&gt;&lt;/a&gt; to get a tuple representation with year, month and day fields:</source>
          <target state="translated">上記の例では、構造的比較が前年の前日を比較するため、&lt;a href=&quot;#max/1&quot;&gt; &lt;code&gt;max/1&lt;/code&gt; &lt;/a&gt;は4月1日ではなく3月31 日を返しました。これは、&lt;a href=&quot;#max_by/3&quot;&gt; &lt;code&gt;max_by/3&lt;/code&gt; &lt;/a&gt;を使用し、最上位桁が最初に来る構造に依存することで対処できます。この特定のケースでは、&lt;a href=&quot;date#to_erl/1&quot;&gt; &lt;code&gt;Date.to_erl/1&lt;/code&gt; &lt;/a&gt;を使用して、年、月、日のフィールドを持つタプル表現を取得できます。</target>
        </trans-unit>
        <trans-unit id="00b3dfc102ba0bf3e9031dc021dd5e02de63d0cd" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#max/2&quot;&gt;&lt;code&gt;max/2&lt;/code&gt;&lt;/a&gt; returned March 31st instead of April 1st because the structural comparison compares the day before the year. In such cases it is common for modules to provide functions such as &lt;a href=&quot;date#compare/2&quot;&gt;&lt;code&gt;Date.compare/2&lt;/code&gt;&lt;/a&gt; that perform semantic comparison.</source>
          <target state="translated">上記の例では、構造的比較が前年の前日を比較するため、&lt;a href=&quot;#max/2&quot;&gt; &lt;code&gt;max/2&lt;/code&gt; &lt;/a&gt;は4月1日ではなく3月31 日を返しました。そのような場合、モジュールがセマンティック比較を実行する&lt;a href=&quot;date#compare/2&quot;&gt; &lt;code&gt;Date.compare/2&lt;/code&gt; &lt;/a&gt;などの関数を提供するのが一般的です。</target>
        </trans-unit>
        <trans-unit id="7872f4b6748675f8cea9f2aac1d82fd307d18a15" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#min/1&quot;&gt;&lt;code&gt;min/1&lt;/code&gt;&lt;/a&gt; returned April 1st instead of March 31st because the structural comparison compares the day before the year. This can be addressed by using &lt;a href=&quot;#min_by/3&quot;&gt;&lt;code&gt;min_by/3&lt;/code&gt;&lt;/a&gt; and by relying on structures where the most significant digits come first. In this particular case, we can use &lt;a href=&quot;date#to_erl/1&quot;&gt;&lt;code&gt;Date.to_erl/1&lt;/code&gt;&lt;/a&gt; to get a tuple representation with year, month and day fields:</source>
          <target state="translated">上記の例では、構造的比較が前年の前日を比較するため、&lt;a href=&quot;#min/1&quot;&gt; &lt;code&gt;min/1&lt;/code&gt; &lt;/a&gt;は3月31日ではなく4月1 日を返しました。これは、&lt;a href=&quot;#min_by/3&quot;&gt; &lt;code&gt;min_by/3&lt;/code&gt; &lt;/a&gt;を使用し、最上位の桁が最初に来る構造に依存することで対処できます。この特定のケースでは、&lt;a href=&quot;date#to_erl/1&quot;&gt; &lt;code&gt;Date.to_erl/1&lt;/code&gt; &lt;/a&gt;を使用して、年、月、日のフィールドを持つタプル表現を取得できます。</target>
        </trans-unit>
        <trans-unit id="0cf57110afa2caf6b8fbffc8cc551e293da6c450" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#min/2&quot;&gt;&lt;code&gt;min/2&lt;/code&gt;&lt;/a&gt; returned April 1st instead of March 31st because the structural comparison compares the day before the year. In such cases it is common for modules to provide functions such as &lt;a href=&quot;date#compare/2&quot;&gt;&lt;code&gt;Date.compare/2&lt;/code&gt;&lt;/a&gt; that perform semantic comparison.</source>
          <target state="translated">上記の例では、構造的比較が前年の前日を比較するため、&lt;a href=&quot;#min/2&quot;&gt; &lt;code&gt;min/2&lt;/code&gt; &lt;/a&gt;は3月31日ではなく4月1 日を返しました。そのような場合、モジュールがセマンティック比較を実行する&lt;a href=&quot;date#compare/2&quot;&gt; &lt;code&gt;Date.compare/2&lt;/code&gt; &lt;/a&gt;などの関数を提供するのが一般的です。</target>
        </trans-unit>
        <trans-unit id="b3ad3c30dbfab7415bf70f15c8e5b3a581930bcb" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;enum#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt; accumulates the result of each call to &lt;code&gt;fun&lt;/code&gt; into a list in reverse order, which is correctly ordered at the end by calling &lt;a href=&quot;enum#reverse/1&quot;&gt;&lt;code&gt;Enum.reverse/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">上記の例では、&lt;a href=&quot;enum#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; &lt;/a&gt;は、 &lt;code&gt;fun&lt;/code&gt; への各呼び出しの結果を逆の順序でリストに累積します。これは、最後に&lt;a href=&quot;enum#reverse/1&quot;&gt; &lt;code&gt;Enum.reverse/1&lt;/code&gt; を&lt;/a&gt;呼び出すことによって正しく並べられます。</target>
        </trans-unit>
        <trans-unit id="6ab2fe333dba7cd1bd613d8d2e21311292cba7df" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;1..100_000 |&amp;gt; Stream.map(&amp;amp;(&amp;amp;1 * 3))&lt;/code&gt; returns a data type, an actual stream, that represents the &lt;code&gt;map&lt;/code&gt; computation over the range &lt;code&gt;1..100_000&lt;/code&gt;:</source>
          <target state="translated">上記の例では、 &lt;code&gt;1..100_000 |&amp;gt; Stream.map(&amp;amp;(&amp;amp;1 * 3))&lt;/code&gt; は、 &lt;code&gt;1..100_000&lt;/code&gt; の範囲の &lt;code&gt;map&lt;/code&gt; 計算を表す実際のストリームであるデータ型を返します。</target>
        </trans-unit>
        <trans-unit id="d7c845572f115897b2ebea0f8fac31816b299fd4" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;a&lt;/code&gt; returns 10 even if the macro is apparently setting it to 1 because variables defined in the macro do not affect the context the macro is executed in. If you want to set or get a variable in the caller's context, you can do it with the help of the &lt;code&gt;var!&lt;/code&gt; macro:</source>
          <target state="translated">上記の例では、マクロで定義された変数はマクロが実行されるコンテキストに影響しないため、マクロが明らかに1に設定している場合でも、 &lt;code&gt;a&lt;/code&gt; は10を返します。呼び出し元のコンテキストで変数を設定または取得する場合は、 &lt;code&gt;var!&lt;/code&gt; の助けを借りてそれを行うことができます！大きい：</target>
        </trans-unit>
        <trans-unit id="7a7545c257a489979c415df1e9f0cbb1c93d77bd" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;bar&lt;/code&gt; will be returned if &lt;code&gt;foo&lt;/code&gt; evaluates to a truthy value (neither &lt;code&gt;false&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt;). Otherwise, &lt;code&gt;nil&lt;/code&gt; will be returned.</source>
          <target state="translated">上記の例では、 &lt;code&gt;foo&lt;/code&gt; が真の値（ &lt;code&gt;false&lt;/code&gt; でも &lt;code&gt;nil&lt;/code&gt; でもない）に評価された場合、 &lt;code&gt;bar&lt;/code&gt; が返されます。それ以外の場合は、 &lt;code&gt;nil&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="7eacffd5adbf5fd949bb658e0457a877aa95d246" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;value&lt;/code&gt; is going to be &lt;code&gt;7&lt;/code&gt; or &lt;code&gt;13&lt;/code&gt; depending on the value of &lt;code&gt;lucky?&lt;/code&gt;. In case &lt;code&gt;value&lt;/code&gt; has no previous value before case, clauses that do not explicitly bind a value have the variable bound to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">上記の例では、 &lt;code&gt;value&lt;/code&gt; あることを行っている &lt;code&gt;7&lt;/code&gt; または &lt;code&gt;13&lt;/code&gt; の値に応じて &lt;code&gt;lucky?&lt;/code&gt; 。ケースには &lt;code&gt;value&lt;/code&gt; ケースの前に以前の値を持っていない、明示的に値をバインドしていない条項がにバインドされた変数持つ &lt;code&gt;nil&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="72cbf21e3fa3d74880817514a949e8994722f839" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;x&lt;/code&gt; cannot be accessed since it was defined inside the &lt;code&gt;try&lt;/code&gt; clause. A common practice to address this issue is to return the variables defined inside &lt;code&gt;try&lt;/code&gt;:</source>
          <target state="translated">上記の例では、 &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;try&lt;/code&gt; 句内で定義されているため、アクセスできません。この問題に対処する一般的な方法は、 &lt;code&gt;try&lt;/code&gt; 内で定義された変数を返すことです。</target>
        </trans-unit>
        <trans-unit id="3bed3d677daa97ab1f5b51e489879c2e74facf10" translate="yes" xml:space="preserve">
          <source>In the example above, a &lt;code&gt;sum/2&lt;/code&gt; function is defined; this function receives two arguments and returns their sum.</source>
          <target state="translated">上記の例では、 &lt;code&gt;sum/2&lt;/code&gt; 関数が定義されています。この関数は2つの引数を受け取り、それらの合計を返します。</target>
        </trans-unit>
        <trans-unit id="9fb262ec317cb005dd946c4cd7d04d84b1f69668" translate="yes" xml:space="preserve">
          <source>In the example above, a set of macros named &lt;code&gt;user&lt;/code&gt; but with different arities will be defined to manipulate the underlying record.</source>
          <target state="translated">上記の例では、 &lt;code&gt;user&lt;/code&gt; という名前の一連のマクロが、基になるレコードを操作するために定義されます。</target>
        </trans-unit>
        <trans-unit id="0c0f218463838143ec4982ca79e4ec70bc05323d" translate="yes" xml:space="preserve">
          <source>In the example above, a supervisor was started by passing the supervision structure to &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt;. However, supervisors can also be created by explicitly defining a supervision module:</source>
          <target state="translated">上記の例では、監視構造を&lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; に&lt;/a&gt;渡すことにより、監視プログラムが開始されました。ただし、監視モジュールは、監視モジュールを明示的に定義して作成することもできます。</target>
        </trans-unit>
        <trans-unit id="442ca993474ce04915ab444e69370d1fd701d187" translate="yes" xml:space="preserve">
          <source>In the example above, as we mapped over the range, the elements being enumerated were created one by one, during enumeration. The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; module allows us to map the range, without triggering its enumeration:</source>
          <target state="translated">上記の例では、範囲をマッピングしたため、列挙されている要素は、列挙中に1つずつ作成されました。&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt;モジュールは、その列挙をトリガすることなく、私たちは範囲をマッピングすることができます：</target>
        </trans-unit>
        <trans-unit id="73b31064dddafd7aceb7c6dd33acb2dfd723e612" translate="yes" xml:space="preserve">
          <source>In the example above, by using &lt;code&gt;TestCase&lt;/code&gt;, we can write tests using the &lt;code&gt;test&lt;/code&gt; macro, which defines a function named &lt;code&gt;run&lt;/code&gt; to automatically run all tests for us. Our prototype will rely on the match operator (&lt;code&gt;=&lt;/code&gt;) as a mechanism to do assertions.</source>
          <target state="translated">上記の例では、使用して &lt;code&gt;TestCase&lt;/code&gt; 、私たちは使用してテストを書くことができ &lt;code&gt;test&lt;/code&gt; という名前の関数を定義するマクロ、 &lt;code&gt;run&lt;/code&gt; 自動的に私たちのためにすべてのテストを実行するために。私たちのプロトタイプは、アサーションを行うメカニズムとして一致演算子（ &lt;code&gt;=&lt;/code&gt; ）に依存します。</target>
        </trans-unit>
        <trans-unit id="f3bbbdd7b6d7f4d0dd2d5c03396c880a058ec265" translate="yes" xml:space="preserve">
          <source>In the example above, even though the macro injects &lt;code&gt;a = 1&lt;/code&gt;, it does not affect the variable &lt;code&gt;a&lt;/code&gt; defined by the &lt;code&gt;go&lt;/code&gt; function. If a macro wants to explicitly affect the context, it can use &lt;code&gt;var!&lt;/code&gt;:</source>
          <target state="translated">上記の例では、マクロが &lt;code&gt;a = 1&lt;/code&gt; 挿入しても、 &lt;code&gt;go&lt;/code&gt; 関数で定義された変数 &lt;code&gt;a&lt;/code&gt; には影響しません。マクロが明示的にコンテキストに影響を与えたい場合は、 &lt;code&gt;var!&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="df21e3e8f902f80311e9ed366624d965e22d8f36" translate="yes" xml:space="preserve">
          <source>In the example above, even though the right list has more entries than the left one, destructuring works fine. If the right list is smaller, the remaining elements are simply set to &lt;code&gt;nil&lt;/code&gt;:</source>
          <target state="translated">上の例では、右側のリストに左側のリストよりも多くのエントリがありますが、構造化は正常に機能します。正しいリストが小さい場合、残りの要素は単に &lt;code&gt;nil&lt;/code&gt; に設定されます。</target>
        </trans-unit>
        <trans-unit id="ad9447b0ab139bf0ce77de940f7116ad1118f9e7" translate="yes" xml:space="preserve">
          <source>In the example above, pattern matching works because underneath structs are bare maps with a fixed set of fields. As maps, structs store a &amp;ldquo;special&amp;rdquo; field named &lt;code&gt;__struct__&lt;/code&gt; that holds the name of the struct:</source>
          <target state="translated">上記の例では、構造体の下は固定されたフィールドのセットを持つベアマップであるため、パターンマッチングが機能します。マップとして、構造体は構造体の名前を保持する &lt;code&gt;__struct__&lt;/code&gt; という名前の「特別な」フィールドを格納します。</target>
        </trans-unit>
        <trans-unit id="dae57a394eb52ab25120ea39543d455089abff36" translate="yes" xml:space="preserve">
          <source>In the example above, since we are invoking &lt;code&gt;alias&lt;/code&gt; inside the function &lt;code&gt;plus/2&lt;/code&gt;, the alias will be valid only inside the function &lt;code&gt;plus/2&lt;/code&gt;. &lt;code&gt;minus/2&lt;/code&gt; won&amp;rsquo;t be affected at all.</source>
          <target state="translated">上記の例では、関数 &lt;code&gt;plus/2&lt;/code&gt; 内で &lt;code&gt;alias&lt;/code&gt; を呼び出しているため、エイリアスは関数 &lt;code&gt;plus/2&lt;/code&gt; 内でのみ有効です。 &lt;code&gt;minus/2&lt;/code&gt; はまったく影響を受けません。</target>
        </trans-unit>
        <trans-unit id="062b7f604b56dd870819716494d195af709ce6fe" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;|&amp;gt;&lt;/code&gt; pipe is the right-most pipe; &lt;code&gt;arg1&lt;/code&gt; is the AST for &lt;code&gt;100 |&amp;gt; div(5)&lt;/code&gt;, and &lt;code&gt;arg2&lt;/code&gt; is the AST for &lt;code&gt;div(2)&lt;/code&gt;.</source>
          <target state="translated">上記の例では、 &lt;code&gt;|&amp;gt;&lt;/code&gt; パイプは右端のパイプです。 &lt;code&gt;arg1&lt;/code&gt; は &lt;code&gt;100 |&amp;gt; div(5)&lt;/code&gt; のAST であり、 &lt;code&gt;arg2&lt;/code&gt; は &lt;code&gt;div(2)&lt;/code&gt; の ASTです。</target>
        </trans-unit>
        <trans-unit id="3764d5750387486a4a8182c32859bf0c44e3a53a" translate="yes" xml:space="preserve">
          <source>In the example above, the imported &lt;code&gt;List.duplicate/2&lt;/code&gt; is only visible within that specific function. &lt;code&gt;duplicate/2&lt;/code&gt; won&amp;rsquo;t be available in any other function in that module (or any other module for that matter).</source>
          <target state="translated">上記の例では、インポートされた &lt;code&gt;List.duplicate/2&lt;/code&gt; はその特定の関数内でのみ表示されます。 &lt;code&gt;duplicate/2&lt;/code&gt; は、そのモジュール内のほかの関数（またはそのほかのモジュール）では使用できません。</target>
        </trans-unit>
        <trans-unit id="a9ba96d97b36e1f6537a9985e8f45706e25424fa" translate="yes" xml:space="preserve">
          <source>In the example above, the linked process died by sending an &lt;code&gt;exit&lt;/code&gt; signal with a value of 1. The Elixir shell automatically handles those messages and prints them to the terminal.</source>
          <target state="translated">上記の例では、リンクされたプロセスは、値1の &lt;code&gt;exit&lt;/code&gt; 信号を送信することによって停止しました。Elixirシェルは自動的にそれらのメッセージを処理し、端末に出力します。</target>
        </trans-unit>
        <trans-unit id="df1a4779609dfb3efd8db910186e109c073a0338" translate="yes" xml:space="preserve">
          <source>In the example above, the list &lt;code&gt;[1, [2], 3]&lt;/code&gt; is passed as the first argument to the &lt;a href=&quot;list#flatten/1&quot;&gt;&lt;code&gt;List.flatten/1&lt;/code&gt;&lt;/a&gt; function, then the flattened list is passed as the first argument to the &lt;a href=&quot;enum#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; function which doubles each element of the list.</source>
          <target state="translated">上記の例では、リスト &lt;code&gt;[1, [2], 3]&lt;/code&gt; が最初の引数として&lt;a href=&quot;list#flatten/1&quot;&gt; &lt;code&gt;List.flatten/1&lt;/code&gt; &lt;/a&gt;関数に渡され、次にフラット化されたリストが最初の引数として&lt;a href=&quot;enum#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; &lt;/a&gt;関数に渡されます。リストの各要素を2倍にします。</target>
        </trans-unit>
        <trans-unit id="30a372309337ceccb6cd8c47007e31bef89794f8" translate="yes" xml:space="preserve">
          <source>In the example above, the shell will be expecting more input until it finds the closing quote. Sometimes it is not obvious which character the shell is expecting, and the user may find themselves trapped in the state of incomplete expression with no ability to terminate it other than by exiting the shell.</source>
          <target state="translated">上の例では、シェルは最後の引用符を見つけるまで、さらに多くの入力を期待しています。時には、シェルがどの文字を期待しているのかが明らかでない場合もあり、シェルを終了する以外には終了することができず、不完全な式の状態に陥っていることに気づくかもしれません。</target>
        </trans-unit>
        <trans-unit id="2c1055e1dbf2125278d879200ab263f9e383b43c" translate="yes" xml:space="preserve">
          <source>In the example above, this happens:</source>
          <target state="translated">上の例では、このようなことが起こります。</target>
        </trans-unit>
        <trans-unit id="c8625f3069f10910c0e9de120b21d6981d601654" translate="yes" xml:space="preserve">
          <source>In the example above, two modules - &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Foo.Bar&lt;/code&gt; - are created. When nesting, Elixir automatically creates an alias to the inner module, allowing the second module &lt;code&gt;Foo.Bar&lt;/code&gt; to be accessed as &lt;code&gt;Bar&lt;/code&gt; in the same lexical scope where it's defined (the &lt;code&gt;Foo&lt;/code&gt; module). This only happens if the nested module is defined via an alias.</source>
          <target state="translated">上記の例では、 &lt;code&gt;Foo&lt;/code&gt; と &lt;code&gt;Foo.Bar&lt;/code&gt; の 2つのモジュールが作成されます。入れ子になると、Elixirは自動的に内部モジュールのエイリアスを作成し、2番目のモジュール &lt;code&gt;Foo.Bar&lt;/code&gt; が、それが定義されている同じ字句スコープ（ &lt;code&gt;Foo&lt;/code&gt; モジュール）内の &lt;code&gt;Bar&lt;/code&gt; としてアクセスできるようにします。これは、ネストされたモジュールがエイリアスを介して定義されている場合にのみ発生します。</target>
        </trans-unit>
        <trans-unit id="cee742c4ffa43a93d2e20f415d5f42aefbd9bd95" translate="yes" xml:space="preserve">
          <source>In the example above, we are explicitly setting the version attribute for that module. &lt;code&gt;@vsn&lt;/code&gt; is used by the code reloading mechanism in the Erlang</source>
          <target state="translated">上記の例では、そのモジュールのバージョン属性を明示的に設定しています。 &lt;code&gt;@vsn&lt;/code&gt; は、Erlangのコード再読み込みメカニズムによって使用されます</target>
        </trans-unit>
        <trans-unit id="021f23fc44f1b5057c72ccb35305764a702bc70f" translate="yes" xml:space="preserve">
          <source>In the example above, we are mutating both the array and the variable &lt;code&gt;i&lt;/code&gt;. Mutating is not possible in Elixir. Instead, functional languages rely on recursion: a function is called recursively until a condition is reached that stops the recursive action from continuing. No data is mutated in this process. Consider the example below that prints a string an arbitrary number of times:</source>
          <target state="translated">上記の例では、配列と変数 &lt;code&gt;i&lt;/code&gt; の両方を変更しています。エリクサーでは変異は不可能です。代わりに、関数型言語は再帰に依存しています。関数は、再帰的なアクションの続行を停止する条件に達するまで再帰的に呼び出されます。このプロセスではデータは変更されません。文字列を任意の回数出力する以下の例を考えてみましょう：</target>
        </trans-unit>
        <trans-unit id="d5006566e063521dde7ab998be88e6cd1a64640e" translate="yes" xml:space="preserve">
          <source>In the example above, we can access the value &lt;code&gt;foo&lt;/code&gt; under the binding &lt;code&gt;assigns&lt;/code&gt; using &lt;code&gt;@foo&lt;/code&gt;. This is useful because a template, after being compiled, can receive different assigns and would not require recompilation for each variable set.</source>
          <target state="translated">上記の例では、 &lt;code&gt;@foo&lt;/code&gt; &lt;code&gt;foo&lt;/code&gt; を使用して、バインディング &lt;code&gt;assigns&lt;/code&gt; 下で値fooにアクセスできます。テンプレートは、コンパイル後、異なる割り当てを受け取ることができ、変数セットごとに再コンパイルする必要がないため、便利です。</target>
        </trans-unit>
        <trans-unit id="5661752d4cc9fd9fdd4a2d139f2888ecb877cbf6" translate="yes" xml:space="preserve">
          <source>In the example above, we captured &lt;a href=&quot;kernel#is_atom/1&quot;&gt;&lt;code&gt;Kernel.is_atom/1&lt;/code&gt;&lt;/a&gt; as an anonymous function and then invoked it.</source>
          <target state="translated">上記の例では、&lt;a href=&quot;kernel#is_atom/1&quot;&gt; &lt;code&gt;Kernel.is_atom/1&lt;/code&gt; &lt;/a&gt;を無名関数としてキャプチャして呼び出しました。</target>
        </trans-unit>
        <trans-unit id="e3bbf3a8f78417d03c53c8a99adeb57f91aa4785" translate="yes" xml:space="preserve">
          <source>In the example above, we create tasks that sleep from 1 up to 10 seconds and return the number of seconds they slept for. If you execute the code all at once, you should see 1 up to 5 printed, as those were the tasks that have replied in the given time. All other tasks will have been shut down using the &lt;a href=&quot;task#shutdown/2&quot;&gt;&lt;code&gt;Task.shutdown/2&lt;/code&gt;&lt;/a&gt; call.</source>
          <target state="translated">上記の例では、1秒から10秒までスリープするタスクを作成し、スリープした秒数を返します。コードを一度に実行すると、1から5までが表示されます。これらは、所定の時間内に応答したタスクだったためです。他のすべてのタスクは、&lt;a href=&quot;task#shutdown/2&quot;&gt; &lt;code&gt;Task.shutdown/2&lt;/code&gt; &lt;/a&gt;呼び出しを使用してシャットダウンされます。</target>
        </trans-unit>
        <trans-unit id="43dbb6ffa3efa205c169cb0eb943acb32507c0e1" translate="yes" xml:space="preserve">
          <source>In the example above, we defined an anonymous function that receives two arguments, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, and returns the result of &lt;code&gt;a + b&lt;/code&gt;. The arguments are always on the left-hand side of &lt;code&gt;-&amp;gt;&lt;/code&gt; and the code to be executed on the right-hand side. The anonymous function is stored in the variable &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="translated">上記の例では、2つの引数 &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; を受け取り、a &lt;code&gt;a + b&lt;/code&gt; 結果を返す無名関数を定義しました。引数は常に &lt;code&gt;-&amp;gt;&lt;/code&gt; の左側にあり、実行されるコードは右側にあります。無名関数は変数 &lt;code&gt;add&lt;/code&gt; に格納されます。</target>
        </trans-unit>
        <trans-unit id="5b2957729dcc7602ce0c24fbab3553e81f82dbdc" translate="yes" xml:space="preserve">
          <source>In the example above, we defined specs for workers and supervisors. These specs (both for workers as well as supervisors) accept the following options:</source>
          <target state="translated">上記の例では、ワーカーとスーパーバイザーの仕様を定義しました。これらの仕様(労働者と監督者の両方)は、以下のオプションを受け入れます。</target>
        </trans-unit>
        <trans-unit id="5e6b4da92c054f57ac5d7ebeeafc523687c5adff" translate="yes" xml:space="preserve">
          <source>In the example above, we have created a new port that executes the program &lt;code&gt;cat&lt;/code&gt;. &lt;code&gt;cat&lt;/code&gt; is a program available on UNIX systems that receives data from multiple inputs and concatenates them in the output.</source>
          <target state="translated">上記の例では、プログラム &lt;code&gt;cat&lt;/code&gt; を実行する新しいポートを作成しました。 &lt;code&gt;cat&lt;/code&gt; は、複数の入力からデータを受け取り、それらを出力に連結するUNIXシステムで使用可能なプログラムです。</target>
        </trans-unit>
        <trans-unit id="b0e39547d1868b820dfb08e74cce03806dbaf13c" translate="yes" xml:space="preserve">
          <source>In the example above, we have defined a tag called &lt;code&gt;:cd&lt;/code&gt; that is read in the setup callback to configure the working directory the test is going to run on.</source>
          <target state="translated">上記の例では、テストが実行される作業ディレクトリを構成するためにセットアップコールバックで読み取られる &lt;code&gt;:cd&lt;/code&gt; というタグを定義しています。</target>
        </trans-unit>
        <trans-unit id="0fd333e5963bb492deae7a782ebcecbae48824d5" translate="yes" xml:space="preserve">
          <source>In the example above, we have defined an alias named &lt;code&gt;mix all&lt;/code&gt;, that prints &quot;Hello world&quot;, then fetches dependencies specific to the current environment, and compiles the project.</source>
          <target state="translated">上記の例では、 &quot;Hello world&quot;を出力し、現在の環境に固有の依存関係をフェッチしてプロジェクトをコンパイルする、 &lt;code&gt;mix all&lt;/code&gt; という名前のエイリアスを定義しています。</target>
        </trans-unit>
        <trans-unit id="b55e3dbdcda3974f9c85104c4aab9938de0f3064" translate="yes" xml:space="preserve">
          <source>In the example above, we have defined two aliases. One is &lt;code&gt;mix c&lt;/code&gt; which is a shortcut for &lt;a href=&quot;mix.tasks.compile&quot;&gt;&lt;code&gt;mix compile&lt;/code&gt;&lt;/a&gt;. The other is named &lt;code&gt;mix hello&lt;/code&gt;, which is the equivalent to the &lt;code&gt;Mix.Tasks.Hello&lt;/code&gt; we have defined in the &quot;Mix.Task&quot; section.</source>
          <target state="translated">上記の例では、2つのエイリアスを定義しています。1つは、&lt;a href=&quot;mix.tasks.compile&quot;&gt; &lt;code&gt;mix compile&lt;/code&gt; &lt;/a&gt;ショートカットである &lt;code&gt;mix c&lt;/code&gt; です。もう1つは &lt;code&gt;mix hello&lt;/code&gt; という名前で、「Mix.Task」セクションで定義した &lt;code&gt;Mix.Tasks.Hello&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="61eada0cb9cbd1b50540cd6782b9dfeead876351" translate="yes" xml:space="preserve">
          <source>In the example above, we have generated the functions &lt;code&gt;foo/0&lt;/code&gt; and &lt;code&gt;bar/0&lt;/code&gt; dynamically. Now, imagine that we want to convert this functionality into a macro:</source>
          <target state="translated">上記の例では、関数 &lt;code&gt;foo/0&lt;/code&gt; および &lt;code&gt;bar/0&lt;/code&gt; を動的に生成しています。ここで、この機能をマクロに変換したいとします。</target>
        </trans-unit>
        <trans-unit id="5c4c73a0b16c4020cd89858453c999ce24f50d3b" translate="yes" xml:space="preserve">
          <source>In the example above, we have set up &lt;code&gt;MyKeyword&lt;/code&gt; to be aliased as &lt;a href=&quot;keyword&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt;. So now, any reference to &lt;a href=&quot;keyword&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt; will be automatically replaced by &lt;code&gt;MyKeyword&lt;/code&gt;.</source>
          <target state="translated">上記の例では、 &lt;code&gt;MyKeyword&lt;/code&gt; が&lt;a href=&quot;keyword&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt;としてエイリアスされるように設定しています。そのため、&lt;a href=&quot;keyword&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt;への参照はすべて自動的に &lt;code&gt;MyKeyword&lt;/code&gt; に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="053a645de735a836658d24ec36de529750445dbd" translate="yes" xml:space="preserve">
          <source>In the example above, we have used the &lt;code&gt;plug/1&lt;/code&gt; macro to connect functions that will be invoked when there is a web request. Internally, every time you call &lt;code&gt;plug/1&lt;/code&gt;, the Plug library stores the given argument in a &lt;code&gt;@plugs&lt;/code&gt; attribute. Just before the module is compiled, Plug runs a callback that defines a function (&lt;code&gt;call/2&lt;/code&gt;) which handles HTTP requests. This function will run all plugs inside &lt;code&gt;@plugs&lt;/code&gt; in order.</source>
          <target state="translated">上記の例では、 &lt;code&gt;plug/1&lt;/code&gt; マクロを使用して、Webリクエストがあるときに呼び出される関数を接続しています。内部的には、 &lt;code&gt;plug/1&lt;/code&gt; を呼び出すたびに、Plugライブラリは指定された引数を &lt;code&gt;@plugs&lt;/code&gt; 属性に格納します。モジュールがコンパイルされる直前に、プラグはHTTPリクエストを処理する関数（ &lt;code&gt;call/2&lt;/code&gt; ）を定義するコールバックを実行します。この関数は、 &lt;code&gt;@plugs&lt;/code&gt; plugs内のすべてのプラグを順番に実行します。</target>
        </trans-unit>
        <trans-unit id="d04cc9035f609252303b7cf3699ee2289f736ec0" translate="yes" xml:space="preserve">
          <source>In the example above, we imported macros from &lt;code&gt;MyMacros&lt;/code&gt;, replacing the original &lt;a href=&quot;kernel#if/2&quot;&gt;&lt;code&gt;if/2&lt;/code&gt;&lt;/a&gt; implementation by our own within that specific function. All other functions in that module will still be able to use the original one.</source>
          <target state="translated">上記の例では、 &lt;code&gt;MyMacros&lt;/code&gt; からマクロをインポートし、その特定の関数内で独自の&lt;a href=&quot;kernel#if/2&quot;&gt; &lt;code&gt;if/2&lt;/code&gt; &lt;/a&gt;実装を独自のものに置き換えました。そのモジュールの他のすべての関数は、元の関数を引き続き使用できます。</target>
        </trans-unit>
        <trans-unit id="143be83aa54f7c530d19333f4615426ffc2f8abd" translate="yes" xml:space="preserve">
          <source>In the example above, we match &lt;code&gt;thing&lt;/code&gt; against each clause &quot;head&quot; and execute the clause &quot;body&quot; corresponding to the first clause that matches.</source>
          <target state="translated">上記の例では、各句「head」に対して &lt;code&gt;thing&lt;/code&gt; を照合し、一致する最初の句に対応する句「body」を実行します。</target>
        </trans-unit>
        <trans-unit id="6b838b0193a4108fff85d3563dd635cc22b74b28" translate="yes" xml:space="preserve">
          <source>In the example above, we pass a string with &lt;code&gt;\n&lt;/code&gt; escaped and return a version with it unescaped.</source>
          <target state="translated">上記の例では、 &lt;code&gt;\n&lt;/code&gt; エスケープされた文字列を渡し、エスケープされていないバージョンを返します。</target>
        </trans-unit>
        <trans-unit id="e34b35a1a0f6a7ae64d902f20f6d3b6957890f8c" translate="yes" xml:space="preserve">
          <source>In the example above, we show how guards can be used in function clauses. There are several constructs that allow guards; for example:</source>
          <target state="translated">上の例では、関数節でガードがどのように使えるかを示しています。ガードを許可する構文はいくつかあります。</target>
        </trans-unit>
        <trans-unit id="e73b208830253cfcccda8b595f6a7fc37ec019c4" translate="yes" xml:space="preserve">
          <source>In the example below we register the current process and ask for the number of keys in the registry:</source>
          <target state="translated">以下の例では、現在のプロセスを登録し、レジストリ内のキーの数を尋ねています。</target>
        </trans-unit>
        <trans-unit id="600451af2621db08950612f2b8a384ceb1caba3b" translate="yes" xml:space="preserve">
          <source>In the example below we register the current process and look it up both from itself and other processes:</source>
          <target state="translated">以下の例では、現在のプロセスを登録し、自分自身と他のプロセスの両方から検索します。</target>
        </trans-unit>
        <trans-unit id="798fe8739fe086fd76b2f2f854df6fe2d36c1741" translate="yes" xml:space="preserve">
          <source>In the example below we register the current process under the same key in a duplicate registry but with different values:</source>
          <target state="translated">以下の例では、現在のプロセスを同じキーで重複するレジストリに異なる値で登録しています。</target>
        </trans-unit>
        <trans-unit id="78080544e53670fa0133b74d89a92858bb262655" translate="yes" xml:space="preserve">
          <source>In the example below, we have a macro that generates a module with a function named &lt;code&gt;name_length&lt;/code&gt; that returns the length of the module name. The value of this function will be calculated at compilation time and not at runtime.</source>
          <target state="translated">以下の例では、モジュール名の長さを返す &lt;code&gt;name_length&lt;/code&gt; という名前の関数でモジュールを生成するマクロがあります。この関数の値は、実行時ではなくコンパイル時に計算されます。</target>
        </trans-unit>
        <trans-unit id="f8f1d08583916da8a72b67e1316644cdd98dc53a" translate="yes" xml:space="preserve">
          <source>In the example below, we pass a directory to where the &lt;a href=&quot;#c/2&quot;&gt;&lt;code&gt;c/2&lt;/code&gt;&lt;/a&gt; function will write the compiled &lt;code&gt;.beam&lt;/code&gt; files to. This directory is typically named &quot;ebin&quot; in Erlang/Elixir systems:</source>
          <target state="translated">以下の例では、&lt;a href=&quot;#c/2&quot;&gt; &lt;code&gt;c/2&lt;/code&gt; &lt;/a&gt;関数がコンパイル済みの &lt;code&gt;.beam&lt;/code&gt; ファイルを書き込むディレクトリを渡します。このディレクトリは通常、Erlang / Elixirシステムでは「ebin」という名前です。</target>
        </trans-unit>
        <trans-unit id="15375188c3b299d4050635b90946ba7afce11069" translate="yes" xml:space="preserve">
          <source>In the example below, we use a function to get all the maps inside a list:</source>
          <target state="translated">以下の例では、リスト内のすべてのマップを取得する関数を使用します。</target>
        </trans-unit>
        <trans-unit id="7b9f19cdead9cbae542d5210ec70e748cea04410" translate="yes" xml:space="preserve">
          <source>In the examples above, all the comprehensions returned lists as their result. However, the result of a comprehension can be inserted into different data structures by passing the &lt;code&gt;:into&lt;/code&gt; option to the comprehension.</source>
          <target state="translated">上記の例では、すべての内包表記が結果としてリストを返しました。ただし、 &lt;code&gt;:into&lt;/code&gt; オプションを内包に渡すことにより、内包の結果を異なるデータ構造に挿入できます。</target>
        </trans-unit>
        <trans-unit id="e7b33831c78babc5b4b6a0cc0e2347ac123865c0" translate="yes" xml:space="preserve">
          <source>In the examples above, the result returned by the comprehension was always a list. The returned result can be configured by passing an &lt;code&gt;:into&lt;/code&gt; option, that accepts any structure as long as it implements the &lt;a href=&quot;collectable&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; protocol.</source>
          <target state="translated">上記の例では、内包によって返される結果は常にリストでした。返される結果は、 &lt;code&gt;:into&lt;/code&gt; オプションを渡すことで構成できます。これは、&lt;a href=&quot;collectable&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt;プロトコルを実装している限り、任意の構造を受け入れます。</target>
        </trans-unit>
        <trans-unit id="d0daacadfe9f7077fb5dcbe6bf521a065a6a635d" translate="yes" xml:space="preserve">
          <source>In the expression above, &lt;code&gt;n &amp;lt;- [1, 2, 3, 4]&lt;/code&gt; is the &lt;strong&gt;generator&lt;/strong&gt;. It is literally generating values to be used in the comprehension. Any enumerable can be passed on the right-hand side of the generator expression:</source>
          <target state="translated">上記の式では、 &lt;code&gt;n &amp;lt;- [1, 2, 3, 4]&lt;/code&gt; が&lt;strong&gt;ジェネレーター&lt;/strong&gt;です。文字通り、理解に使用される値を生成しています。列挙型は、ジェネレータ式の右側に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="5f3acf5fd7cb6799236adf41693aa239ed339ba4" translate="yes" xml:space="preserve">
          <source>In the first example the accent is before the vowel, so it is considered two graphemes. However, when you reverse it once, you have the vowel followed by the accent, which becomes one grapheme. Reversing it again will keep it as one single grapheme.</source>
          <target state="translated">最初の例では、アクセントが母音の前にあるので、2 つの書記素とみなされます。しかし、これを一度反転させると、母音の後にアクセントが続き、1 つの書記素になります。これをもう一度反転させると、1つの単一のグラフィームとして維持されます。</target>
        </trans-unit>
        <trans-unit id="edabe1bf622029e68e1aff637ff6cf8ec47fb508" translate="yes" xml:space="preserve">
          <source>In the following sections, our examples are going to get longer in size, and it can be tricky to type them all in the shell. It&amp;rsquo;s about time for us to learn how to compile Elixir code and also how to run Elixir scripts.</source>
          <target state="translated">次のセクションでは、例のサイズが長くなるため、すべてシェルで入力するのは難しい場合があります。Elixirコードのコンパイル方法と、Elixirスクリプトの実行方法を学習するときがきました。</target>
        </trans-unit>
        <trans-unit id="ea21b7568312a339bf9ae152813dc701fedd0816" translate="yes" xml:space="preserve">
          <source>In the next chapter, we are going to discuss pattern matching through the use of &lt;code&gt;=&lt;/code&gt;, the match operator.</source>
          <target state="translated">次の章では、一致演算子 &lt;code&gt;=&lt;/code&gt; を使用したパターンマッチングについて説明します。</target>
        </trans-unit>
        <trans-unit id="d8135bc13d648cc8121bc02383bb281b2bb322ce" translate="yes" xml:space="preserve">
          <source>In the next chapter, we will explore GenServers, where the segregation between clients and servers is made more apparent.</source>
          <target state="translated">次の章では、クライアントとサーバの分離がより明確になる GenServers を探っていきます。</target>
        </trans-unit>
        <trans-unit id="71fe1559a8acce4f8cb459f05a93f2c23c27af01" translate="yes" xml:space="preserve">
          <source>In the next chapter, we will start parsing the client requests and sending responses, finishing our server.</source>
          <target state="translated">次の章では、クライアントのリクエストを解析してレスポンスを送信し、サーバーを完成させます。</target>
        </trans-unit>
        <trans-unit id="97a27cfc769eb0315701a749f650534e93e63132" translate="yes" xml:space="preserve">
          <source>In the next chapters, we&amp;rsquo;ll explore structs and protocols before moving to exception handling and other constructs like sigils and comprehensions.</source>
          <target state="translated">次の章では、構造体とプロトコルについて調べてから、例外処理や、シギルや内包表記などの他の構成体に移ります。</target>
        </trans-unit>
        <trans-unit id="83c96bdabbdcc08e2e498fa4f73aafa1f188be21" translate="yes" xml:space="preserve">
          <source>In the previous chapter about &lt;code&gt;GenServer&lt;/code&gt;, we implemented &lt;code&gt;KV.Registry&lt;/code&gt; to manage buckets. At some point, we started monitoring buckets so we were able to take action whenever a &lt;code&gt;KV.Bucket&lt;/code&gt; crashed. Although the change was relatively small, it introduced a question which is frequently asked by Elixir developers: what happens when something fails?</source>
          <target state="translated">&lt;code&gt;GenServer&lt;/code&gt; に関する前の章では、バケットを管理するために &lt;code&gt;KV.Registry&lt;/code&gt; を実装しました。ある時点で、バケットの監視を開始したので、 &lt;code&gt;KV.Bucket&lt;/code&gt; がクラッシュしたときはいつでもアクションを実行できました。変更は比較的小さいものでしたが、Elixir開発者から頻繁に尋ねられる質問が導入されました：何かが失敗するとどうなりますか？</target>
        </trans-unit>
        <trans-unit id="7c0c1e10201013cbed4ae2f15c5fb7856de2269f" translate="yes" xml:space="preserve">
          <source>In the previous chapters, we have always started processes directly. For example, we would call &lt;code&gt;KV.Registry.start_link([])&lt;/code&gt;, which would return &lt;code&gt;{:ok, pid}&lt;/code&gt;, and that would allow us to interact with the registry via its &lt;code&gt;pid&lt;/code&gt;. Now that processes are started by the supervisor, we have to directly ask the supervisor who its children are, and fetch the pid from the returned list of children. In practice, doing so every time would be very expensive. To address this, we often give names to processes, allowing them to be uniquely identified in a single machine from anywhere in our code.</source>
          <target state="translated">前の章では、常に直接プロセスを開始しました。たとえば、 &lt;code&gt;KV.Registry.start_link([])&lt;/code&gt; を呼び出すと、 &lt;code&gt;{:ok, pid}&lt;/code&gt; が返され、その &lt;code&gt;pid&lt;/code&gt; を介してレジストリとやり取りできるようになります。プロセスがスーパーバイザによって開始されたので、スーパーバイザにその子が誰であるかを直接尋ね、返された子のリストからpidをフェッチする必要があります。実際には、毎回そうすることは非常に費用がかかります。これに対処するために、多くの場合、プロセスに名前を付けて、コード内のどこからでも単一のマシンでプロセスを一意に識別できるようにします。</target>
        </trans-unit>
        <trans-unit id="023e1eab071b1e9447d8611d553a6798a82a86d3" translate="yes" xml:space="preserve">
          <source>In the previous example, we were not interested in associating a value to the process:</source>
          <target state="translated">先ほどの例では、プロセスに値を関連付けることには興味がありませんでした。</target>
        </trans-unit>
        <trans-unit id="59cfb6ab9287629bc99d4335b390c03667b20499" translate="yes" xml:space="preserve">
          <source>In the returned result, keys are variable names and values are the corresponding variable values.</source>
          <target state="translated">返された結果では、キーは変数名、値は対応する変数の値です。</target>
        </trans-unit>
        <trans-unit id="de1b308ba8fcb658982badee13287d07ac9706b3" translate="yes" xml:space="preserve">
          <source>In the second line of the failure, right below the test name, there is the location where the test was defined. If you copy the test location in full, including the file and line number, and append it to &lt;code&gt;mix test&lt;/code&gt;, Mix will load and run just that particular test:</source>
          <target state="translated">失敗の2行目のテスト名のすぐ下に、テストが定義された場所があります。テストの場所をファイルと行番号を含めて完全にコピーし、それを &lt;code&gt;mix test&lt;/code&gt; に追加すると、Mixはその特定のテストのみをロードして実行します。</target>
        </trans-unit>
        <trans-unit id="56699ac32b40ebbed14cd456a076f153ca769c75" translate="yes" xml:space="preserve">
          <source>In the session above we interacted with the &amp;ldquo;shopping&amp;rdquo; bucket.</source>
          <target state="translated">上記のセッションでは、「ショッピング」バケットを操作しました。</target>
        </trans-unit>
        <trans-unit id="99f7aeec7f3d83fb7c14ef77613795b1757f5d28" translate="yes" xml:space="preserve">
          <source>In this case, the answer is yes: if the acceptor crashes, there is no need to crash the existing connections. On the other hand, if the task supervisor crashes, there is no need to crash the acceptor too.</source>
          <target state="translated">この場合、答えはイエスです。アクセプタがクラッシュした場合、既存の接続をクラッシュさせる必要はありません。一方、タスクスーパーバイザがクラッシュした場合、アクセプタもクラッシュする必要はありません。</target>
        </trans-unit>
        <trans-unit id="c5b73c40f211641ff7fce3baa3df52cd94ce14cd" translate="yes" xml:space="preserve">
          <source>In this case, there is no module, so we picked the name &lt;code&gt;KV.BucketSupervisor&lt;/code&gt;. It could have been any other name. We also chose the &lt;code&gt;:one_for_one&lt;/code&gt; strategy, which is currently the only available strategy for dynamic supervisors.</source>
          <target state="translated">この場合、モジュールはないので、 &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; という名前を選びました。それは他の名前だったかもしれません。また、 &lt;code&gt;:one_for_one&lt;/code&gt; 戦略を選択しました。これは、現在、動的スーパーバイザで利用可能な唯一の戦略です。</target>
        </trans-unit>
        <trans-unit id="69b79e652a12895505240a6d60f23b561b08605d" translate="yes" xml:space="preserve">
          <source>In this case, we are importing only the function &lt;code&gt;duplicate&lt;/code&gt; (with arity 2) from &lt;code&gt;List&lt;/code&gt;. Although &lt;code&gt;:only&lt;/code&gt; is optional, its usage is recommended in order to avoid importing all the functions of a given module inside the namespace. &lt;code&gt;:except&lt;/code&gt; could also be given as an option in order to import everything in a module &lt;em&gt;except&lt;/em&gt; a list of functions.</source>
          <target state="translated">この場合、 &lt;code&gt;List&lt;/code&gt; から &lt;code&gt;duplicate&lt;/code&gt; た関数（arity 2）のみをインポートしています。けれども &lt;code&gt;:only&lt;/code&gt; オプションであり、その使用は、名前空間内の特定のモジュールのすべての機能をインポートしないようにするために推奨されます。 &lt;code&gt;:except&lt;/code&gt; は、関数のリストを&lt;em&gt;除く&lt;/em&gt;モジュール内のすべてをインポートするためのオプションとして指定することもできます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="98ecd27c52ed18c7b95002136d1b65249ac3fde1" translate="yes" xml:space="preserve">
          <source>In this chapter we will learn more about Elixir basic types: integers, floats, booleans, atoms, strings, lists and tuples. Some basic types are:</source>
          <target state="translated">この章では、Elixirの基本的な型である整数、フロート、ブーリアン、アトム、文字列、リスト、タプルについて学びます。基本的な型には以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="95bc41f24cd4a15d49d6be30cfe2c21aeb083956" translate="yes" xml:space="preserve">
          <source>In this chapter, we are going to explore sigils, which are one of the mechanisms provided by the language for working with textual representations. Sigils start with the tilde (&lt;code&gt;~&lt;/code&gt;) character which is followed by a letter (which identifies the sigil) and then a delimiter; optionally, modifiers can be added after the final delimiter.</source>
          <target state="translated">この章では、テキスト表現を操作するために言語によって提供されるメカニズムの1つであるシギルについて説明します。シギルは、チルド（ &lt;code&gt;~&lt;/code&gt; ）文字で始まり、その後に文字（シギルを識別する）が続き、その後に区切り文字が続きます。オプションで、最後の区切り文字の後に修飾子を追加できます。</target>
        </trans-unit>
        <trans-unit id="8ac2c0d2324769d5f24fd923ab3874ad8881b99a" translate="yes" xml:space="preserve">
          <source>In this chapter, we are going to learn how to use &lt;a href=&quot;http://www.erlang.org/doc/man/gen_tcp.html&quot;&gt;Erlang&amp;rsquo;s &lt;code&gt;:gen_tcp&lt;/code&gt; module&lt;/a&gt; to serve requests. This provides a great opportunity to explore Elixir&amp;rsquo;s &lt;code&gt;Task&lt;/code&gt; module. In future chapters, we will expand our server so it can actually serve the commands.</source>
          <target state="translated">この章では、&lt;a href=&quot;http://www.erlang.org/doc/man/gen_tcp.html&quot;&gt;Erlangの &lt;code&gt;:gen_tcp&lt;/code&gt; モジュール&lt;/a&gt;を使用してリクエストを処理する方法を学びます。これは、Elixirの &lt;code&gt;Task&lt;/code&gt; モジュールを探索する絶好の機会を提供します。今後の章では、サーバーを拡張して実際にコマンドを提供できるようにします。</target>
        </trans-unit>
        <trans-unit id="3790f5eba5f0f0e875bea6125a8a5886ab46f334" translate="yes" xml:space="preserve">
          <source>In this chapter, we have learned more about Mix dependencies and umbrella projects. While we may run &lt;code&gt;kv&lt;/code&gt; without a server, our &lt;code&gt;kv_server&lt;/code&gt; depends directly on &lt;code&gt;kv&lt;/code&gt;. By breaking them into separate applications, we gain more control in how they are developed and tested.</source>
          <target state="translated">この章では、Mixの依存関係とアンブレラプロジェクトについて詳しく学びました。サーバーなしで &lt;code&gt;kv&lt;/code&gt; を実行することもできますが、 &lt;code&gt;kv_server&lt;/code&gt; は &lt;code&gt;kv&lt;/code&gt; に直接依存しています。それらを別々のアプリケーションに分割することにより、それらの開発とテストの方法をより詳細に制御できます。</target>
        </trans-unit>
        <trans-unit id="77b3cbb396af520fe87eb129b43b21e8d9c63f1e" translate="yes" xml:space="preserve">
          <source>In this chapter, we will create our first project using Mix and explore different features in</source>
          <target state="translated">この章では、Mix を使用して最初のプロジェクトを作成し、Mix のさまざまな機能について調べます。</target>
        </trans-unit>
        <trans-unit id="9c4b6a4ca897d48c33e42fad527b3db14a79b9ad" translate="yes" xml:space="preserve">
          <source>In this chapter, we will discuss how to manage dependencies in Mix.</source>
          <target state="translated">この章では、Mixでの依存関係の管理方法について説明します。</target>
        </trans-unit>
        <trans-unit id="d4cdb3f68133770a5d693d42e9c4f0a6b1d29ed8" translate="yes" xml:space="preserve">
          <source>In this chapter, we will go back to the &lt;code&gt;:kv&lt;/code&gt; application and add a routing layer that will allow us to distribute requests between nodes based on the bucket name.</source>
          <target state="translated">この章では、 &lt;code&gt;:kv&lt;/code&gt; アプリケーションに戻り、ルーティング名を追加して、バケット名に基づいてノード間でリクエストを分散できるようにします。</target>
        </trans-unit>
        <trans-unit id="06e8c486e5a64f168562aa1973836cfefc091cf1" translate="yes" xml:space="preserve">
          <source>In this chapter, we will implement the code that parses the commands we described in the first chapter:</source>
          <target state="translated">この章では、第1章で説明したコマンドを解析するコードを実装します。</target>
        </trans-unit>
        <trans-unit id="c851aca018e560f965209935144975cb8ea448f3" translate="yes" xml:space="preserve">
          <source>In this chapter, we will learn about ETS (Erlang Term Storage) and how to use it as a cache mechanism.</source>
          <target state="translated">この章では、ETS (Erlang Term Storage)について学び、キャッシュメカニズムとしての使い方を学びます。</target>
        </trans-unit>
        <trans-unit id="49223bed7f677bd886d57a37c64f3ed6e0f504be" translate="yes" xml:space="preserve">
          <source>In this chapter, we will learn about the &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;cond&lt;/code&gt;, and &lt;code&gt;if&lt;/code&gt; control flow structures.</source>
          <target state="translated">この章では、我々は学びます &lt;code&gt;case&lt;/code&gt; 、 &lt;code&gt;cond&lt;/code&gt; 、そして &lt;code&gt;if&lt;/code&gt; 制御フロー構造。</target>
        </trans-unit>
        <trans-unit id="1590a3a3e635043fe94ad7ec0fb7a6fa472857ed" translate="yes" xml:space="preserve">
          <source>In this chapter, we will learn about the basic constructs for spawning new processes, as well as sending and receiving messages between processes.</source>
          <target state="translated">この章では、新しいプロセスを生成するための基本的な構造と、プロセス間でのメッセージの送受信について学びます。</target>
        </trans-unit>
        <trans-unit id="7f5c0837809d0d37d72c00bc93c0560646fc3127" translate="yes" xml:space="preserve">
          <source>In this chapter, we will learn how to keep and share state between multiple entities. If you have previous programming experience, you may think of globally shared variables, but the model we will learn here is quite different. The next chapters will generalize the concepts introduced here.</source>
          <target state="translated">この章では、複数のエンティティ間で状態を保持し、共有する方法を学びます。プログラミングの経験がある人なら、グローバルに共有された変数を思い浮かべるかもしれませんが、ここで学ぶモデルは全く異なります。次の章では、ここで紹介した概念を一般化していきます。</target>
        </trans-unit>
        <trans-unit id="dc7ec789bc29ccf1df57435cd9cab759827e4cca" translate="yes" xml:space="preserve">
          <source>In this chapter, we will learn how to put those concepts into practice by supervising the &lt;code&gt;KV.Registry&lt;/code&gt; process. After all, if something goes wrong with the registry, the whole registry is lost and no bucket could ever be found! To address this, we will define a &lt;code&gt;KV.Supervisor&lt;/code&gt; module that guarantees that our &lt;code&gt;KV.Registry&lt;/code&gt; is up and running at any given moment.</source>
          <target state="translated">この章では、 &lt;code&gt;KV.Registry&lt;/code&gt; プロセスを監視することにより、これらの概念を実践する方法を学びます。結局のところ、レジストリで何か問題が発生した場合、レジストリ全体が失われ、バケットが見つかりませんでした。これに対処するために、我々は定義されます &lt;code&gt;KV.Supervisor&lt;/code&gt; の保証私たちのことを、そのモジュールを &lt;code&gt;KV.Registry&lt;/code&gt; は、任意の時点で稼働しています。</target>
        </trans-unit>
        <trans-unit id="f4e872a924d2554a59dc215ca3cc9595e893d535" translate="yes" xml:space="preserve">
          <source>In this chapter, we will show how the &lt;code&gt;=&lt;/code&gt; operator in Elixir is actually a match operator and how to use it to pattern match inside data structures. Finally, we will learn about the pin operator &lt;code&gt;^&lt;/code&gt; used to access previously bound values.</source>
          <target state="translated">この章では、Elixir の &lt;code&gt;=&lt;/code&gt; 演算子が実際にどのように一致演算子であるか、およびそれを使用してデータ構造内でパターン一致を行う方法を示します。最後に、以前にバインドされた値にアクセスするために使用されるピン演算子 &lt;code&gt;^&lt;/code&gt; について学習します。</target>
        </trans-unit>
        <trans-unit id="31213f804ca1ba2bcaeea192ccfad5a4a66aadab" translate="yes" xml:space="preserve">
          <source>In this chapter, we will understand what binaries are, how they associate with strings, and what a single-quoted value, &lt;code&gt;'like this'&lt;/code&gt;, means in Elixir.</source>
          <target state="translated">この章では、バイナリとは何か、それらが文字列とどのように関連付けられるか、および &lt;code&gt;'like this'&lt;/code&gt; に」単一引用符で囲まれた値がElixirで何を意味するかを理解します。</target>
        </trans-unit>
        <trans-unit id="cab0abe1635159a22d386896876d7d1271b3ac90" translate="yes" xml:space="preserve">
          <source>In this example above, we have used &lt;code&gt;.&lt;/code&gt; to invoke &lt;code&gt;downcase&lt;/code&gt; in the &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; module, passing &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; as argument.</source>
          <target state="translated">上記の例では、を使用してい &lt;code&gt;.&lt;/code&gt; 起動する &lt;code&gt;downcase&lt;/code&gt; の中で&lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;渡し、モジュール &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; 引数として。</target>
        </trans-unit>
        <trans-unit id="c10b9029231d6bc54c409155c2532fc1a938191b" translate="yes" xml:space="preserve">
          <source>In this example, &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html#__using__/1&quot;&gt;&lt;code&gt;ExUnit.Case.__using__/1&lt;/code&gt;&lt;/a&gt; is called with the keyword list &lt;code&gt;[async: true]&lt;/code&gt; as its argument; &lt;a href=&quot;#use/2&quot;&gt;&lt;code&gt;use/2&lt;/code&gt;&lt;/a&gt; translates to:</source>
          <target state="translated">この例では、&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html#__using__/1&quot;&gt; &lt;code&gt;ExUnit.Case.__using__/1&lt;/code&gt; &lt;/a&gt;がキーワードリスト &lt;code&gt;[async: true]&lt;/code&gt; を引数として呼び出されます。&lt;a href=&quot;#use/2&quot;&gt; &lt;code&gt;use/2&lt;/code&gt; は次のように&lt;/a&gt;変換されます。</target>
        </trans-unit>
        <trans-unit id="9b0189dd5873fd5c12528d067cb5fcd86bb62926" translate="yes" xml:space="preserve">
          <source>In this example, we will also set the number of partitions to the number of schedulers online, which will make the registry more performant on highly concurrent environments:</source>
          <target state="translated">また、この例では、パーティションの数をオンラインのスケジューラの数に設定することで、同時並行性の高い環境でのレジストリのパフォーマンスを向上させます。</target>
        </trans-unit>
        <trans-unit id="bf3e2a2aeea0818b1b9eedf9fbfeaab414232e77" translate="yes" xml:space="preserve">
          <source>In this function, creating the email address will copy the &lt;code&gt;username&lt;/code&gt; and &lt;code&gt;domain&lt;/code&gt; binaries. Now imagine you want to use the resulting email inside another binary:</source>
          <target state="translated">この関数では、電子メールアドレスを作成すると、 &lt;code&gt;username&lt;/code&gt; と &lt;code&gt;domain&lt;/code&gt; バイナリがコピーされます。結果の電子メールを別のバイナリ内で使用したいとします。</target>
        </trans-unit>
        <trans-unit id="ddbd4da73762eca8a66a74cb6eb4786c527ab302" translate="yes" xml:space="preserve">
          <source>In this guide, we will learn how to build a complete Elixir application, with its own supervision tree, configuration, tests and more.</source>
          <target state="translated">このガイドでは、独自の監視ツリー、設定、テストなどを備えた完全なElixirアプリケーションを構築する方法を学びます。</target>
        </trans-unit>
        <trans-unit id="09acda557e592790e954bfce0950e7ceb658a690" translate="yes" xml:space="preserve">
          <source>In this introduction, we have laid the groundwork to finally write our first macro, so let&amp;rsquo;s move to the next chapter.</source>
          <target state="translated">この紹介では、最終的に最初のマクロを書くための基礎を築いたので、次の章に移りましょう。</target>
        </trans-unit>
        <trans-unit id="c76b277befaa00029a051ea468b00e6a56d4277a" translate="yes" xml:space="preserve">
          <source>In this last chapter, we will make the routing table for our distributed key-value store configurable, and then finally package the software for production.</source>
          <target state="translated">この章では、分散型キーバリューストアのルーティングテーブルを設定可能にし、最終的に本番用のソフトウェアをパッケージ化します。</target>
        </trans-unit>
        <trans-unit id="5f9c06a521bbdcc292934d8151f4d75a668e854f" translate="yes" xml:space="preserve">
          <source>In this menu, developers are able to start new shells and alternate between them. Let's give it a try:</source>
          <target state="translated">このメニューでは、開発者は新しいシェルを起動し、それらを交互に切り替えることができます。試してみましょう。</target>
        </trans-unit>
        <trans-unit id="469f4d72bd11aaf469d5b151d58b6e80c06007ce" translate="yes" xml:space="preserve">
          <source>In this section we document common anti-patterns to avoid when writing libraries.</source>
          <target state="translated">このセクションでは、ライブラリを書く際に避けるべき一般的なアンチパターンについて説明します。</target>
        </trans-unit>
        <trans-unit id="eebb3e9870cca1a5d4d8634270c5f11116a4eca3" translate="yes" xml:space="preserve">
          <source>In this section, we will implement the parsing functionality, document it and make sure our documentation is up to date with doctests. This helps us provide documentation with accurate code samples.</source>
          <target state="translated">このセクションでは、構文解析機能を実装し、ドキュメント化し、ドキュメントが doctests で最新の状態になっていることを確認します。これにより、正確なコードサンプルを使ってドキュメントを提供することができます。</target>
        </trans-unit>
        <trans-unit id="06285168ac2e5f025d4d90f97df36744161f8367" translate="yes" xml:space="preserve">
          <source>In this setup, Elixir will escape the following: &lt;code&gt;\0&lt;/code&gt;, &lt;code&gt;\a&lt;/code&gt;, &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\e&lt;/code&gt;, &lt;code&gt;\f&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\t&lt;/code&gt; and &lt;code&gt;\v&lt;/code&gt;. Bytes can be given as hexadecimals via &lt;code&gt;\xNN&lt;/code&gt; and Unicode code points as &lt;code&gt;\uNNNN&lt;/code&gt; escapes.</source>
          <target state="translated">この設定では、Elixirは次をエスケープします： &lt;code&gt;\0&lt;/code&gt; 、 &lt;code&gt;\a&lt;/code&gt; 、 &lt;code&gt;\b&lt;/code&gt; 、 &lt;code&gt;\d&lt;/code&gt; 、 &lt;code&gt;\e&lt;/code&gt; 、 &lt;code&gt;\f&lt;/code&gt; 、 &lt;code&gt;\n&lt;/code&gt; 、 &lt;code&gt;\r&lt;/code&gt; 、 &lt;code&gt;\s&lt;/code&gt; 、 &lt;code&gt;\t&lt;/code&gt; 、 &lt;code&gt;\v&lt;/code&gt; 。バイトは、 &lt;code&gt;\uNNNN&lt;/code&gt; がエスケープするため、 &lt;code&gt;\xNN&lt;/code&gt; およびUnicodeコードポイントを介して16進数として指定できます。</target>
        </trans-unit>
        <trans-unit id="a8dd5e09e7dc956434b7d83de8c59a3badda6a30" translate="yes" xml:space="preserve">
          <source>In this tutorial, we are going to teach you about Elixir fundamentals - the language syntax, how to define modules, how to manipulate the characteristics of common data structures, and more. This chapter will focus on ensuring that Elixir is installed and that you can successfully run Elixir&amp;rsquo;s Interactive Shell, called IEx.</source>
          <target state="translated">このチュートリアルでは、言語構文、モジュールの定義方法、一般的なデータ構造の特性の操作方法など、Elixirの基本について説明します。この章では、Elixirがインストールされていること、およびEExirと呼ばれるElixirのインタラクティブシェルを正常に実行できるようにすることに焦点を当てます。</target>
        </trans-unit>
        <trans-unit id="793085c85e85a2ff028456a29daed3461d17ddd7" translate="yes" xml:space="preserve">
          <source>In your supervisor tree, you would write:</source>
          <target state="translated">上司ツリーでは、あなたが書いていますね。</target>
        </trans-unit>
        <trans-unit id="83526b8b240a9db63b8d55e8fb00ed7f5d21007b" translate="yes" xml:space="preserve">
          <source>In-memory reloading</source>
          <target state="translated">インメモリリロード</target>
        </trans-unit>
        <trans-unit id="d704ee1641420e0d4b1d894e7413ca3a127523fd" translate="yes" xml:space="preserve">
          <source>Indexes are normalized, meaning that negative indexes will be counted from the end (for example, &lt;code&gt;-1&lt;/code&gt; means the last element of the &lt;code&gt;enumerable&lt;/code&gt;).</source>
          <target state="translated">インデックスは正規化されます。つまり、負のインデックスは最後から数えられます（たとえば、 &lt;code&gt;-1&lt;/code&gt; は &lt;code&gt;enumerable&lt;/code&gt; の最後の要素を意味します）。</target>
        </trans-unit>
        <trans-unit id="326e3957dade8d1a772302e6b546ac73cdbf4311" translate="yes" xml:space="preserve">
          <source>Indicates if the current task is recursing.</source>
          <target state="translated">現在のタスクが再帰しているかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="f2a5522bf941f8a31cb4a9be81260d9ace1f85be" translate="yes" xml:space="preserve">
          <source>Infix operator; calculates the bitwise AND of its arguments.</source>
          <target state="translated">Infix演算子:引数のビット単位のANDを計算します。</target>
        </trans-unit>
        <trans-unit id="e2dd1c549a548d8e01a78692703764dc3748f955" translate="yes" xml:space="preserve">
          <source>Infix operator; calculates the bitwise OR of its arguments.</source>
          <target state="translated">Infix演算子:引数のビット単位のORを計算します。</target>
        </trans-unit>
        <trans-unit id="9f117367d5e095016d1671e5594b015b66cce626" translate="yes" xml:space="preserve">
          <source>Infix operator; calculates the bitwise XOR of its arguments.</source>
          <target state="translated">Infix演算子:引数のビット毎のXORを計算します。</target>
        </trans-unit>
        <trans-unit id="a6c9f00063f505c603b4195c6e85acdf426886dc" translate="yes" xml:space="preserve">
          <source>Infix operator; calculates the result of an arithmetic left bitshift.</source>
          <target state="translated">Infix演算子:算術の左ビットシフトの結果を計算します。</target>
        </trans-unit>
        <trans-unit id="39d1b96bbfeb4f731610e743c469a2a9cffcbf06" translate="yes" xml:space="preserve">
          <source>Infix operator; calculates the result of an arithmetic right bitshift.</source>
          <target state="translated">Infix演算子:算術右ビットシフトの結果を計算します。</target>
        </trans-unit>
        <trans-unit id="edfb572bfe264c3828dc3338e200d7d692f743a8" translate="yes" xml:space="preserve">
          <source>Initialization, shutdown and restart logic (as seen in supervisors)</source>
          <target state="translated">初期化、シャットダウン、および再起動ロジック(スーパーバイザに見られるように</target>
        </trans-unit>
        <trans-unit id="db2dd11fcae49760a96da6470cc842932b211ef8" translate="yes" xml:space="preserve">
          <source>Injects the contents of the file at &lt;code&gt;path&lt;/code&gt; as if it was typed into the shell.</source>
          <target state="translated">ファイルの内容を、シェルに入力されたかのように &lt;code&gt;path&lt;/code&gt; 挿入します。</target>
        </trans-unit>
        <trans-unit id="cdae762bf8cb5cd492029bc8d296aa3edef79fb0" translate="yes" xml:space="preserve">
          <source>Injects the stream values into the given collectable as a side-effect.</source>
          <target state="translated">副作用として、ストリーム値を指定されたコレクタブルに注入します。</target>
        </trans-unit>
        <trans-unit id="dc55e2c53e188d355acce4a5c45f90740eaed542" translate="yes" xml:space="preserve">
          <source>Inlined by the compiler.</source>
          <target state="translated">コンパイラでインライン化されています。</target>
        </trans-unit>
        <trans-unit id="d1a321cfbe47a9364ab51334333242edcba4e12d" translate="yes" xml:space="preserve">
          <source>Inlining</source>
          <target state="translated">Inlining</target>
        </trans-unit>
        <trans-unit id="60256592be0f79d02de4ff02fdbe0edd9f4a9db3" translate="yes" xml:space="preserve">
          <source>Input will be consumed until Enter is pressed.</source>
          <target state="translated">Enter を押すまで入力が消費されます。</target>
        </trans-unit>
        <trans-unit id="15148f3718aedfec6834b4f2c01d66f0986c9e24" translate="yes" xml:space="preserve">
          <source>Insert these changes in your code and now you may start your application using the following command &lt;code&gt;PORT=4321 mix run --no-halt&lt;/code&gt;, notice how we are passing the port as a variable, but still defaults to 4040 if none is given.</source>
          <target state="translated">これらの変更をコードに挿入すると、次のコマンド &lt;code&gt;PORT=4321 mix run --no-halt&lt;/code&gt; を使用してアプリケーションを起動できます。ポートを変数として渡す方法に注意してください。ただし、何も指定されていない場合はデフォルトで4040に設定されます。</target>
        </trans-unit>
        <trans-unit id="477a1b44713d7d2cea8e0f490e55ba9af37236ea" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into &lt;code&gt;map_set&lt;/code&gt; if &lt;code&gt;map_set&lt;/code&gt; doesn't already contain it.</source>
          <target state="translated">&lt;code&gt;map_set&lt;/code&gt; にまだ &lt;code&gt;value&lt;/code&gt; が含まれていない場合は、 &lt;code&gt;map_set&lt;/code&gt; に値を挿入します。</target>
        </trans-unit>
        <trans-unit id="1e63d377cb4e0957757e5467d8c996119f6f2f02" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into &lt;code&gt;tuple&lt;/code&gt; at the given &lt;code&gt;index&lt;/code&gt;. Raises an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;index&lt;/code&gt; is negative or greater than the length of &lt;code&gt;tuple&lt;/code&gt;. Index is zero-based.</source>
          <target state="translated">&lt;code&gt;tuple&lt;/code&gt; れた &lt;code&gt;index&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; を挿入します。上昇させる&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;場合 &lt;code&gt;index&lt;/code&gt; 負であるかの長さよりも長い &lt;code&gt;tuple&lt;/code&gt; 。インデックスはゼロベースです。</target>
        </trans-unit>
        <trans-unit id="afa4ba1a8961d06fdaefcb0b7808a06ce72411d7" translate="yes" xml:space="preserve">
          <source>Inserts a mandatory linebreak between two documents.</source>
          <target state="translated">2つの文書間に必須の改行を挿入します。</target>
        </trans-unit>
        <trans-unit id="ee42585ac2116aa5e9e194a89ae83cd36cb233ed" translate="yes" xml:space="preserve">
          <source>Inserts a mandatory single space between two documents.</source>
          <target state="translated">2つの文書の間に必須のシングルスペースを挿入します。</target>
        </trans-unit>
        <trans-unit id="58646ce229b992058a739db41cd5c12f2f3030cf" translate="yes" xml:space="preserve">
          <source>Inserts an element at the end of a tuple.</source>
          <target state="translated">タプルの最後に要素を挿入します。</target>
        </trans-unit>
        <trans-unit id="aefced5d83d6f9626d89c8b81563a063596124ad" translate="yes" xml:space="preserve">
          <source>Inserts an element into a tuple.</source>
          <target state="translated">タプルに要素を挿入します。</target>
        </trans-unit>
        <trans-unit id="82491edefb5fd8fccc5cef67dd8728cddce98356" translate="yes" xml:space="preserve">
          <source>Inserts the given &lt;code&gt;enumerable&lt;/code&gt; into a &lt;code&gt;collectable&lt;/code&gt; according to the transformation function.</source>
          <target state="translated">変換関数に従って、指定された &lt;code&gt;enumerable&lt;/code&gt; &lt;code&gt;collectable&lt;/code&gt; に挿入します。</target>
        </trans-unit>
        <trans-unit id="58e9b11975e38f1615e69956c4ba72b1614985c8" translate="yes" xml:space="preserve">
          <source>Inserts the given &lt;code&gt;enumerable&lt;/code&gt; into a &lt;code&gt;collectable&lt;/code&gt;.</source>
          <target state="translated">指定された &lt;code&gt;enumerable&lt;/code&gt; &lt;code&gt;collectable&lt;/code&gt; 挿入します。</target>
        </trans-unit>
        <trans-unit id="4dc843d3a107d849e18140a0726786e2d0083112" translate="yes" xml:space="preserve">
          <source>Inside &lt;a href=&quot;kernel#defimpl/2&quot;&gt;&lt;code&gt;defimpl/2&lt;/code&gt;&lt;/a&gt;, you can use &lt;code&gt;@protocol&lt;/code&gt; to access the protocol being implemented and &lt;code&gt;@for&lt;/code&gt; to access the module it is being defined for.</source>
          <target state="translated">内部&lt;a href=&quot;kernel#defimpl/2&quot;&gt; &lt;code&gt;defimpl/2&lt;/code&gt; &lt;/a&gt;は、使用することができます &lt;code&gt;@protocol&lt;/code&gt; をプロトコルが実装されてアクセスすると &lt;code&gt;@for&lt;/code&gt; それはのために定義されているモジュールにアクセスします。</target>
        </trans-unit>
        <trans-unit id="9a72c5141d8fa1919f077425c1ba8fcc0bb6e0f3" translate="yes" xml:space="preserve">
          <source>Inside &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; blocks you may introduce other keywords, such as &lt;code&gt;else&lt;/code&gt; used in the &lt;code&gt;if&lt;/code&gt; above. The supported keywords between &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; are static and are:</source>
          <target state="translated">インサイド &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; ブロック次のような他のキーワード、導入することができる &lt;code&gt;else&lt;/code&gt; で使用される &lt;code&gt;if&lt;/code&gt; 上記を。 &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; の間でサポートされるキーワードは静的で、次のとおりです。</target>
        </trans-unit>
        <trans-unit id="7b06fc5ccdbbb6e1341b5ead9ee2126b0e7d8721" translate="yes" xml:space="preserve">
          <source>Inside IEx, hitting &lt;code&gt;Ctrl+C&lt;/code&gt; will open up the &lt;code&gt;BREAK&lt;/code&gt; menu. In this menu you can quit the shell, see process and ETS tables information and much more.</source>
          <target state="translated">IEx内で &lt;code&gt;Ctrl+C&lt;/code&gt; を押すと、 &lt;code&gt;BREAK&lt;/code&gt; メニューが開きます。このメニューでは、シェルを終了し、プロセスとETSテーブルの情報などを表示できます。</target>
        </trans-unit>
        <trans-unit id="03f0e4a7260af9ca9a8463a85cd7efbea72439fd" translate="yes" xml:space="preserve">
          <source>Inside a module, we can define functions with &lt;code&gt;def/2&lt;/code&gt; and private functions with &lt;code&gt;defp/2&lt;/code&gt;. A function defined with &lt;code&gt;def/2&lt;/code&gt; can be invoked from other modules while a private function can only be invoked locally.</source>
          <target state="translated">モジュール内では、 &lt;code&gt;def/2&lt;/code&gt; で関数を定義し、 &lt;code&gt;defp/2&lt;/code&gt; でプライベート関数を定義できます。 &lt;code&gt;def/2&lt;/code&gt; で定義された関数は他のモジュールから呼び出すことができますが、プライベート関数はローカルでのみ呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="1b5876476355703f4f43fdf75b583d0b33e50128" translate="yes" xml:space="preserve">
          <source>Inside umbrellas:</source>
          <target state="translated">傘の内側。</target>
        </trans-unit>
        <trans-unit id="ff7d1285dd1427c76ab7acf44b71a8c8783f99ac" translate="yes" xml:space="preserve">
          <source>Insignificant digits in numbers are kept as is. The formatter however always inserts underscores for decimal numbers with more than 5 digits and converts hexadecimal digits to uppercase</source>
          <target state="translated">数字の中の取るに足らない桁はそのまま保持されます。ただし、フォーマッタは常に5桁以上の10進数にアンダースコアを挿入し、16進数を大文字に変換します。</target>
        </trans-unit>
        <trans-unit id="18ca87afec4298d9de864e32b4eeb6a31786e496" translate="yes" xml:space="preserve">
          <source>Inspect</source>
          <target state="translated">Inspect</target>
        </trans-unit>
        <trans-unit id="8414c282c4799a38a5a542eddf3fbf5bc932cf21" translate="yes" xml:space="preserve">
          <source>Inspect &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;プロトコルの&lt;/small&gt;検査&lt;small&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="8fa2cc0c476786708af2220b5a7c37218a295c0e" translate="yes" xml:space="preserve">
          <source>Inspect.Algebra</source>
          <target state="translated">Inspect.Algebra</target>
        </trans-unit>
        <trans-unit id="cac9e750c4626e97af4bfdac5963505168c991af" translate="yes" xml:space="preserve">
          <source>Inspect.Error</source>
          <target state="translated">Inspect.Error</target>
        </trans-unit>
        <trans-unit id="2f7084207f03105946937040d7f1a8666466847e" translate="yes" xml:space="preserve">
          <source>Inspect.Error &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Inspect.Error &lt;small&gt;例外&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c1eea5039122d61678f099bc1095c3d343dfa88b" translate="yes" xml:space="preserve">
          <source>Inspect.Opts</source>
          <target state="translated">Inspect.Opts</target>
        </trans-unit>
        <trans-unit id="76857fe76fdec2188870db7ef8e5489c2f660af9" translate="yes" xml:space="preserve">
          <source>Inspect.inspect (2)</source>
          <target state="translated">Inspect.インスペクション(2)</target>
        </trans-unit>
        <trans-unit id="11718aedd18c27cc6d385458412c98fc95530888" translate="yes" xml:space="preserve">
          <source>Inspect.t (0)</source>
          <target state="translated">Inspect.t (0)</target>
        </trans-unit>
        <trans-unit id="4b093666bfbe436abd6e75ff4060483a6eed400e" translate="yes" xml:space="preserve">
          <source>Inspects &lt;code&gt;item&lt;/code&gt; according to the given options using the IO &lt;code&gt;device&lt;/code&gt;.</source>
          <target state="translated">IO &lt;code&gt;device&lt;/code&gt; を使用して、指定されたオプションに従って &lt;code&gt;item&lt;/code&gt; 検査します。</target>
        </trans-unit>
        <trans-unit id="c5a3a1e7021ff3bf12f0c5dee5b6d4b45795751a" translate="yes" xml:space="preserve">
          <source>Inspects and writes the given &lt;code&gt;item&lt;/code&gt; to the device.</source>
          <target state="translated">指定された &lt;code&gt;item&lt;/code&gt; を検査してデバイスに書き込みます。</target>
        </trans-unit>
        <trans-unit id="e7503cce5b05ca6c10725fe1362e1e1fb0df01fb" translate="yes" xml:space="preserve">
          <source>Inspects the given argument according to the &lt;a href=&quot;inspect&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol. The second argument is a keyword list with options to control inspection.</source>
          <target state="translated">&lt;a href=&quot;inspect&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt;プロトコルに従って、指定された引数を検査します。2番目の引数は、検査を制御するオプションを含むキーワードリストです。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="410e2de2d51ba0a8c2653a12efa8b959eb14239c" translate="yes" xml:space="preserve">
          <source>Installing external dependencies is simple. Most commonly, we use the &lt;a href=&quot;https://hex.pm&quot;&gt;Hex Package Manager&lt;/a&gt;, by listing the dependency inside the deps function in our &lt;code&gt;mix.exs&lt;/code&gt; file:</source>
          <target state="translated">外部依存関係のインストールは簡単です。最も一般的には、hex &lt;a href=&quot;https://hex.pm&quot;&gt;パッケージマネージャー&lt;/a&gt;を使用して、 &lt;code&gt;mix.exs&lt;/code&gt; ファイルのdeps関数内の依存関係をリストします。</target>
        </trans-unit>
        <trans-unit id="5fc6648d32dcda7f8258be9d7bfe7a810c641ff1" translate="yes" xml:space="preserve">
          <source>Instead &lt;strong&gt;do&lt;/strong&gt;:</source>
          <target state="translated">代わりに&lt;strong&gt;行います&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="70e1c1220b6164c7f3f3c7f9ac3d512f4ed39191" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;MyModule.__behaviour__(:callbacks)&lt;/code&gt;, &lt;code&gt;MyModule.behaviour_info(:callbacks)&lt;/code&gt; can be used.</source>
          <target state="translated">&lt;code&gt;MyModule.__behaviour__(:callbacks)&lt;/code&gt; 代わりに、 &lt;code&gt;MyModule.behaviour_info(:callbacks)&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="a1b879c3f25c9b1c9960a54e86cb4fc16cf79dfc" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;spawn/1&lt;/code&gt; and &lt;code&gt;spawn_link/1&lt;/code&gt;, we use &lt;code&gt;Task.start/1&lt;/code&gt; and &lt;code&gt;Task.start_link/1&lt;/code&gt; which return &lt;code&gt;{:ok, pid}&lt;/code&gt; rather than just the PID. This is what enables tasks to be used in supervision trees. Furthermore, &lt;code&gt;Task&lt;/code&gt; provides convenience functions, like &lt;code&gt;Task.async/1&lt;/code&gt; and &lt;code&gt;Task.await/1&lt;/code&gt;, and functionality to ease distribution.</source>
          <target state="translated">&lt;code&gt;spawn/1&lt;/code&gt; と &lt;code&gt;spawn_link/1&lt;/code&gt; の代わりに、PIDだけでなく &lt;code&gt;{:ok, pid}&lt;/code&gt; を返す &lt;code&gt;Task.start/1&lt;/code&gt; と &lt;code&gt;Task.start_link/1&lt;/code&gt; を使用します。これにより、監視ツリーでタスクを使用できるようになります。さらに、 &lt;code&gt;Task&lt;/code&gt; は &lt;code&gt;Task.async/1&lt;/code&gt; や &lt;code&gt;Task.await/1&lt;/code&gt; などの便利な機能と、配布を容易にする機能を提供します。</target>
        </trans-unit>
        <trans-unit id="2b04d71a821407f326a765c34eafcb3d188ed9ec" translate="yes" xml:space="preserve">
          <source>Instead of abusing the built-in name facility, we will create our own &lt;em&gt;process registry&lt;/em&gt; that associates the bucket name to the bucket process.</source>
          <target state="translated">組み込みの名前機能を悪用する代わりに、バケット名をバケットプロセスに関連付ける独自の&lt;em&gt;プロセスレジストリ&lt;/em&gt;を作成します。</target>
        </trans-unit>
        <trans-unit id="46ebdd1c0d8185516f828a303e26f55b8135c53d" translate="yes" xml:space="preserve">
          <source>Instead of asking &amp;ldquo;how to do X in Elixir&amp;rdquo;, ask &amp;ldquo;how to solve Y in Elixir&amp;rdquo;. In other words, don&amp;rsquo;t ask how to implement a particular solution, instead describe the problem at hand. Stating the problem gives more context and less bias for a correct answer.</source>
          <target state="translated">「エリクサーでXを実行する方法」ではなく、「エリクサーでYを解決する方法」を尋ねます。つまり、特定のソリューションの実装方法を尋ねるのではなく、目の前の問題を説明してください。問題を述べることで、より多くのコンテキストが得られ、正解に対するバイアスが少なくなります。</target>
        </trans-unit>
        <trans-unit id="657f86bb1607bd9dc12a6834cf040e983fea5025" translate="yes" xml:space="preserve">
          <source>Instead of generating intermediate lists, streams build a series of computations that are invoked only when we pass the underlying stream to the &lt;code&gt;Enum&lt;/code&gt; module. Streams are useful when working with large, &lt;em&gt;possibly infinite&lt;/em&gt;, collections.</source>
          <target state="translated">中間リストを生成する代わりに、ストリームは、基礎となるストリームを &lt;code&gt;Enum&lt;/code&gt; モジュールに渡すときにのみ呼び出される一連の計算を構築します。ストリームは、大規模な、&lt;em&gt;場合によっては無限の&lt;/em&gt;コレクションを処理するときに役立ちます。</target>
        </trans-unit>
        <trans-unit id="cbcbdeb5ce82b55a1db6bc95122644a2da9c98f8" translate="yes" xml:space="preserve">
          <source>Instead of sharing protocol implementation with maps, structs require their own protocol implementation. Since a &lt;code&gt;MapSet&lt;/code&gt; has its size precomputed and accessible through &lt;code&gt;MapSet.size/1&lt;/code&gt;, we can define a &lt;code&gt;Size&lt;/code&gt; implementation for it:</source>
          <target state="translated">プロトコル実装をマップと共有する代わりに、構造体は独自のプロトコル実装を必要とします。以来 &lt;code&gt;MapSet&lt;/code&gt; そのサイズが事前に計算を介してアクセスできた &lt;code&gt;MapSet.size/1&lt;/code&gt; 、我々は定義することができる &lt;code&gt;Size&lt;/code&gt; それのための実装を：</target>
        </trans-unit>
        <trans-unit id="b1cda74ad7f0576bffdba14e7c0e5fbf0bd02a81" translate="yes" xml:space="preserve">
          <source>Instead, you can store the value of the &lt;code&gt;try&lt;/code&gt; expression:</source>
          <target state="translated">代わりに、 &lt;code&gt;try&lt;/code&gt; 式の値を保存できます。</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="e340bf5c2746e3a29b7ae3f2341d749b9a8e7f42" translate="yes" xml:space="preserve">
          <source>Integer code points</source>
          <target state="translated">整数コードポイント</target>
        </trans-unit>
        <trans-unit id="03c914e9cf272bd181f63f8ca95aa4134406a908" translate="yes" xml:space="preserve">
          <source>Integers (&lt;code&gt;1234&lt;/code&gt;) and floats (&lt;code&gt;123.4&lt;/code&gt;) in Elixir are represented as a sequence of digits that may be separated by underscore for readability purposes, such as &lt;code&gt;1_000_000&lt;/code&gt;. Integers never contain a dot (&lt;code&gt;.&lt;/code&gt;) in their representation. Floats contain a dot and at least one other digit after the dot. Floats also support the scientific notation, such as &lt;code&gt;123.4e10&lt;/code&gt; or &lt;code&gt;123.4E10&lt;/code&gt;.</source>
          <target state="translated">Elixirの整数（ &lt;code&gt;1234&lt;/code&gt; ）と浮動小数点（ &lt;code&gt;123.4&lt;/code&gt; ）は、 &lt;code&gt;1_000_000&lt;/code&gt; のように、読みやすいようにアンダースコアで区切られた一連の数字として表されます。整数の表現にドット（ &lt;code&gt;.&lt;/code&gt; ）が含まれることはありません。フロートには、ドットと、ドットの後に少なくとも1つの他の数字が含まれます。フロートは、 &lt;code&gt;123.4e10&lt;/code&gt; や &lt;code&gt;123.4E10&lt;/code&gt; などの科学表記もサポートしています。</target>
        </trans-unit>
        <trans-unit id="2b69f8490219ca339df3ffe0a24133cf0845a779" translate="yes" xml:space="preserve">
          <source>Integers can be &lt;code&gt;signed&lt;/code&gt; or &lt;code&gt;unsigned&lt;/code&gt;, defaulting to &lt;code&gt;unsigned&lt;/code&gt;.</source>
          <target state="translated">整数は、 &lt;code&gt;unsigned&lt;/code&gt; &lt;code&gt;signed&lt;/code&gt; または符号なしで、デフォルトは &lt;code&gt;unsigned&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d2871c600eee20d37fb547e17a478f66ee810c41" translate="yes" xml:space="preserve">
          <source>Integers in other bases and Unicode code points</source>
          <target state="translated">他のベースの整数とUnicodeコードポイント</target>
        </trans-unit>
        <trans-unit id="67bd439657ec8c91af9cab8e9c61775e95c7d415" translate="yes" xml:space="preserve">
          <source>Integration with Mix</source>
          <target state="translated">ミックスとの統合</target>
        </trans-unit>
        <trans-unit id="8c7b691a3d33f4bf5d25d380d9c0cebf6d69f172" translate="yes" xml:space="preserve">
          <source>Integration with OS level tracers, such as &lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/LTTng.html&quot;&gt;Linux Trace Toolkit,&lt;/a&gt;&lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/DTRACE.html&quot;&gt;DTRACE,&lt;/a&gt; and &lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/SYSTEMTAP.html&quot;&gt;SystemTap&lt;/a&gt;</source>
          <target state="translated">以下のようなOSレベルのトレーサー、との統合&lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/LTTng.html&quot;&gt;のLinuxトレースツールキット、&lt;/a&gt;&lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/DTRACE.html&quot;&gt;DTRACE、&lt;/a&gt;と&lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/SYSTEMTAP.html&quot;&gt;のSystemTap&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0d798c0b1cd4a6d135dc1e4671cde5f33dab863b" translate="yes" xml:space="preserve">
          <source>Interactive mode</source>
          <target state="translated">インタラクティブモード</target>
        </trans-unit>
        <trans-unit id="6815f4d63967846048009b2275fddb5992a2ae7f" translate="yes" xml:space="preserve">
          <source>Internal dependencies</source>
          <target state="translated">内部依存関係</target>
        </trans-unit>
        <trans-unit id="fd76d47a90f8cc879523d078abeee342549c2a2c" translate="yes" xml:space="preserve">
          <source>Internal dependencies are the ones that are specific to your project. They usually don&amp;rsquo;t make sense outside the scope of your project/company/organization. Most of the time, you want to keep them private, whether due to technical, economic or business reasons.</source>
          <target state="translated">内部依存関係は、プロジェクトに固有のものです。通常、プロジェクト/会社/組織の範囲外では意味がありません。ほとんどの場合、技術的、経済的、またはビジネス上の理由に関係なく、それらを非公開にしておく必要があります。</target>
        </trans-unit>
        <trans-unit id="6edc5ae2d27d92f734915c3bcae38bfcff562e82" translate="yes" xml:space="preserve">
          <source>Internal special form for block expressions.</source>
          <target state="translated">ブロック式の内部特殊フォーム。</target>
        </trans-unit>
        <trans-unit id="7b9df6e3733e8709e741819162ae8b21c5560f05" translate="yes" xml:space="preserve">
          <source>Internal special form to hold aliases information.</source>
          <target state="translated">エイリアス情報を保持するための内部専用フォーム。</target>
        </trans-unit>
        <trans-unit id="7ea238b82c732c14af0d56ae146c57de7821e30a" translate="yes" xml:space="preserve">
          <source>Internally, &lt;a href=&quot;enum#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; is implemented as follows:</source>
          <target state="translated">内部的には、&lt;a href=&quot;enum#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; &lt;/a&gt;は次のように実装されています。</target>
        </trans-unit>
        <trans-unit id="827c1e94219dfeaae7b53280233314ac83030abd" translate="yes" xml:space="preserve">
          <source>Internally, this function uses a &lt;a href=&quot;port&quot;&gt;&lt;code&gt;Port&lt;/code&gt;&lt;/a&gt; for interacting with the outside world. However, if you plan to run a long-running program, ports guarantee stdin/stdout devices will be closed but it does not automatically terminate the program. The documentation for the &lt;a href=&quot;port&quot;&gt;&lt;code&gt;Port&lt;/code&gt;&lt;/a&gt; module describes this problem and possible solutions under the &quot;Zombie processes&quot; section.</source>
          <target state="translated">内部的には、この関数は外部の世界と対話するために&lt;a href=&quot;port&quot;&gt; &lt;code&gt;Port&lt;/code&gt; &lt;/a&gt;を使用します。ただし、長時間実行するプログラムを実行する場合、ポートはstdin / stdoutデバイスが閉じられることを保証しますが、プログラムを自動的に終了しません。&lt;a href=&quot;port&quot;&gt; &lt;code&gt;Port&lt;/code&gt; &lt;/a&gt;モジュールのドキュメントには、「ゾンビプロセス」セクションでこの問題と考えられる解決策が記載されています。</target>
        </trans-unit>
        <trans-unit id="77ae57c279c9e2ef961ac607460659eac146477d" translate="yes" xml:space="preserve">
          <source>Interpolation and escaping in sigils</source>
          <target state="translated">シグイルの補間とエスケープ</target>
        </trans-unit>
        <trans-unit id="f901cbbe7edd4e8b636ff99e09fd9aa3ab5b6c2c" translate="yes" xml:space="preserve">
          <source>Intersperses &lt;code&gt;element&lt;/code&gt; between each element of the enumeration.</source>
          <target state="translated">列挙の各要素の間に &lt;code&gt;element&lt;/code&gt; を散在させます。</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="3ad9a82c5e5ec7f5cdb591679187a3a184cc6e2c" translate="yes" xml:space="preserve">
          <source>Introduction to Mix</source>
          <target state="translated">ミックスの紹介</target>
        </trans-unit>
        <trans-unit id="556666f2a50884d36f095e81af9943cd94538e19" translate="yes" xml:space="preserve">
          <source>Invalid (when setup_all fails)</source>
          <target state="translated">無効(setup_allが失敗した場合</target>
        </trans-unit>
        <trans-unit id="979685031faaab9869c01a670026bc6edde40c74" translate="yes" xml:space="preserve">
          <source>Invoke the required callback &lt;a href=&quot;#c:stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">必要なコールバック&lt;a href=&quot;#c:stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; を&lt;/a&gt;呼び出します。</target>
        </trans-unit>
        <trans-unit id="9c2fcbf3d8569fd3d11cfd7171a8054a4d1a7f48" translate="yes" xml:space="preserve">
          <source>Invoked at the beginning of every nesting.</source>
          <target state="translated">毎回のネスティングの開始時に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="3131af8070d80cb4438964eca7dde39215d4a38c" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value stored under &lt;code&gt;key&lt;/code&gt; in the given term &lt;code&gt;term&lt;/code&gt;.</source>
          <target state="translated">指定された用語 &lt;code&gt;term&lt;/code&gt; の &lt;code&gt;key&lt;/code&gt; 下に格納されている値にアクセスするために呼び出されます。</target>
        </trans-unit>
        <trans-unit id="b22a1f1a89dd3f3bab30cb805e59f8edfe29b611" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value under &lt;code&gt;key&lt;/code&gt; and update it at the same time.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 下の値にアクセスし、同時にそれを更新するために呼び出されます。</target>
        </trans-unit>
        <trans-unit id="f708aba5828f8cac72cfe36605553c37461c0165" translate="yes" xml:space="preserve">
          <source>Invoked in some cases to retrieve a formatted version of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; status.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;ステータスのフォーマットされたバージョンを取得するために呼び出される場合があります。</target>
        </trans-unit>
        <trans-unit id="47f17640bca3b36f9d932ef8aed6fea2692e715d" translate="yes" xml:space="preserve">
          <source>Invoked to &quot;pop&quot; the value under &lt;code&gt;key&lt;/code&gt; out of the given data structure.</source>
          <target state="translated">与えられたデータ構造から &lt;code&gt;key&lt;/code&gt; 下の値を「ポップ」するために呼び出されます。</target>
        </trans-unit>
        <trans-unit id="8ffa339626f86dfddb50d2f5a5ebf28a3fe4886f" translate="yes" xml:space="preserve">
          <source>Invoked to change the state of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; when a different version of a module is loaded (hot code swapping) and the state's term structure should be changed.</source>
          <target state="translated">別のバージョンのモジュールがロードされた（ホットコードスワップ）ときに&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;の状態を変更するために呼び出され、状態の用語構造を変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="7fd464e0a7bfe3444479112d481808fd4426398a" translate="yes" xml:space="preserve">
          <source>Invoked to handle &lt;code&gt;continue&lt;/code&gt; instructions.</source>
          <target state="translated">&lt;code&gt;continue&lt;/code&gt; 命令を処理するために呼び出されました。</target>
        </trans-unit>
        <trans-unit id="823c64bbe586eac0f81ae84a9ece9107aadfc7b3" translate="yes" xml:space="preserve">
          <source>Invoked to handle all other messages.</source>
          <target state="translated">他のすべてのメッセージを処理するために呼び出されます。</target>
        </trans-unit>
        <trans-unit id="251e86e0358f8330275ee3b3f133b8139914e86a" translate="yes" xml:space="preserve">
          <source>Invoked to handle asynchronous &lt;a href=&quot;#cast/2&quot;&gt;&lt;code&gt;cast/2&lt;/code&gt;&lt;/a&gt; messages.</source>
          <target state="translated">非同期&lt;a href=&quot;#cast/2&quot;&gt; &lt;code&gt;cast/2&lt;/code&gt; &lt;/a&gt;メッセージを処理するために呼び出されます。</target>
        </trans-unit>
        <trans-unit id="490b6e99cd71fc7e4dff011cebfd6c5bbbf5b87c" translate="yes" xml:space="preserve">
          <source>Invoked to handle synchronous &lt;a href=&quot;#call/3&quot;&gt;&lt;code&gt;call/3&lt;/code&gt;&lt;/a&gt; messages. &lt;a href=&quot;#call/3&quot;&gt;&lt;code&gt;call/3&lt;/code&gt;&lt;/a&gt; will block until a reply is received (unless the call times out or nodes are disconnected).</source>
          <target state="translated">同期的な&lt;a href=&quot;#call/3&quot;&gt; &lt;code&gt;call/3&lt;/code&gt; &lt;/a&gt;メッセージを処理するために呼び出されます。&lt;a href=&quot;#call/3&quot;&gt; &lt;code&gt;call/3&lt;/code&gt; &lt;/a&gt;は、応答が受信されるまでブロックします（呼び出しがタイムアウトになるか、ノードが切断されない限り）。</target>
        </trans-unit>
        <trans-unit id="971fbd6b9ae7269a95c5e43e7e31db62769d21ec" translate="yes" xml:space="preserve">
          <source>Invoked when initializing a config provider.</source>
          <target state="translated">コンフィグプロバイダの初期化時に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="618d0cf7ef6acc312a2d60fcc796f79659809cb5" translate="yes" xml:space="preserve">
          <source>Invoked when the server is about to exit. It should do any cleanup required.</source>
          <target state="translated">サーバが終了しようとしているときに呼び出されます。必要なクリーンアップを行います。</target>
        </trans-unit>
        <trans-unit id="7d36bf5909d0181e92966ebf880c59e2f526bd11" translate="yes" xml:space="preserve">
          <source>Invoked when the server is started. &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#start/3&quot;&gt;&lt;code&gt;start/3&lt;/code&gt;&lt;/a&gt; will block until it returns.</source>
          <target state="translated">サーバーの起動時に呼び出されます。&lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#start/3&quot;&gt; &lt;code&gt;start/3&lt;/code&gt; &lt;/a&gt;は、戻るまでブロックします。</target>
        </trans-unit>
        <trans-unit id="dc23160ff26718d1a90643ca2158ff18ecfa2d78" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;fun&lt;/code&gt; for each element in the &lt;code&gt;enumerable&lt;/code&gt; with the accumulator.</source>
          <target state="translated">アキュムレータを使用して、 &lt;code&gt;enumerable&lt;/code&gt; の各要素の &lt;code&gt;fun&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="3e3f9c65eaf0d3e4e4ac9e30375324284bc3c5a7" translate="yes" xml:space="preserve">
          <source>Invokes at the end of a nesting.</source>
          <target state="translated">ネスティングの最後に呼び出します。</target>
        </trans-unit>
        <trans-unit id="d9056f0569ac34dc376baf3f7e7aa026280e9f07" translate="yes" xml:space="preserve">
          <source>Invokes the callback with all entries under &lt;code&gt;key&lt;/code&gt; in each partition for the given &lt;code&gt;registry&lt;/code&gt;.</source>
          <target state="translated">指定された &lt;code&gt;registry&lt;/code&gt; 各パーティションの &lt;code&gt;key&lt;/code&gt; 下にあるすべてのエントリでコールバックを呼び出します。</target>
        </trans-unit>
        <trans-unit id="66ee7c7e2a41aa50f02ea0f66057171a17276f9a" translate="yes" xml:space="preserve">
          <source>Invokes the given &lt;code&gt;fun&lt;/code&gt; for each element in the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; の各要素に指定 &lt;code&gt;fun&lt;/code&gt; れたfunを呼び出します。</target>
        </trans-unit>
        <trans-unit id="c515146dfdcfd5de926f55b367fb13cb7ae87958" translate="yes" xml:space="preserve">
          <source>Invokes the given anonymous function &lt;code&gt;fun&lt;/code&gt; with the list of arguments &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">引数のリスト &lt;code&gt;args&lt;/code&gt; を使用して、指定された無名関数 &lt;code&gt;fun&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="2aa0eb875a1a8fbbb92dc87b00ef479f56d53d97" translate="yes" xml:space="preserve">
          <source>Invokes the given function from &lt;code&gt;module&lt;/code&gt; with the list of arguments &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">引数 &lt;code&gt;args&lt;/code&gt; のリストを使用して、 &lt;code&gt;module&lt;/code&gt; から指定された関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="5649c0331fbb3552ad202de096382bf84abd3b21" translate="yes" xml:space="preserve">
          <source>Invokes the given function to each element in the &lt;code&gt;enumerable&lt;/code&gt; to reduce it to a single element, while keeping an accumulator.</source>
          <target state="translated">アキュムレータを保持しながら、 &lt;code&gt;enumerable&lt;/code&gt; 各要素に対して指定された関数を呼び出し、それを単一の要素に減らします。</target>
        </trans-unit>
        <trans-unit id="b0eda3fd7457c0fb4308b75d0bf6df3d4719aced" translate="yes" xml:space="preserve">
          <source>Is equivalent to:</source>
          <target state="translated">と同等です。</target>
        </trans-unit>
        <trans-unit id="a559a239bb82de0629bcb6a428aeb5fd89db0826" translate="yes" xml:space="preserve">
          <source>Is the same as:</source>
          <target state="translated">と同じです。</target>
        </trans-unit>
        <trans-unit id="c5705683fdebc9e7c3a2a72f5f351756cecd2661" translate="yes" xml:space="preserve">
          <source>It accepts a list of &lt;code&gt;imported_paths&lt;/code&gt; that should raise if attempted to be imported again (to avoid recursive imports).</source>
          <target state="translated">（再帰的なインポートを避けるために）再度インポートを試みた場合に発生するはずの &lt;code&gt;imported_paths&lt;/code&gt; れたパスのリストを受け入れます。</target>
        </trans-unit>
        <trans-unit id="8b02345541bef5990635992a1f66fbd5e80cdc19" translate="yes" xml:space="preserve">
          <source>It accepts a set of &lt;code&gt;options&lt;/code&gt; to configure &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;ExUnit&lt;/code&gt;&lt;/a&gt; (the same ones accepted by &lt;a href=&quot;#configure/1&quot;&gt;&lt;code&gt;configure/1&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;ExUnit&lt;/code&gt; &lt;/a&gt;を構成 &lt;code&gt;options&lt;/code&gt; ためのオプションのセットを受け入れます（&lt;a href=&quot;#configure/1&quot;&gt; &lt;code&gt;configure/1&lt;/code&gt; で&lt;/a&gt;受け入れられるものと同じもの）。</target>
        </trans-unit>
        <trans-unit id="9c6bdae26359278127b2679c1e0f6e34574670e1" translate="yes" xml:space="preserve">
          <source>It accepts the same options as &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#parse_head/2&quot;&gt;&lt;code&gt;parse_head/2&lt;/code&gt;&lt;/a&gt; as both functions are built on top of this function. This function may return:</source>
          <target state="translated">どちらの関数もこの関数の上に構築されているため、&lt;a href=&quot;#parse/2&quot;&gt; &lt;code&gt;parse/2&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#parse_head/2&quot;&gt; &lt;code&gt;parse_head/2&lt;/code&gt; &lt;/a&gt;と同じオプションを受け入れます。この関数は以下を返す可能性があります。</target>
        </trans-unit>
        <trans-unit id="52c79809b7aa93e13235dedf1c047e396021dbc2" translate="yes" xml:space="preserve">
          <source>It accepts the struct module or a struct itself and simply removes the &lt;code&gt;__struct__&lt;/code&gt; field from the given struct or from a new struct generated from the given module.</source>
          <target state="translated">構造体モジュールまたは構造体自体を受け入れ、 &lt;code&gt;__struct__&lt;/code&gt; フィールドを特定の構造体または特定のモジュールから生成された新しい構造体から単に削除します。</target>
        </trans-unit>
        <trans-unit id="9db7ae3984a1b1beb1ad6d9414dcb836e49e4a46" translate="yes" xml:space="preserve">
          <source>It allows a developer to dynamically add, delete and register attributes, attach documentation and so forth.</source>
          <target state="translated">開発者が動的に属性を追加・削除・登録したり、ドキュメントを添付したりすることができます。</target>
        </trans-unit>
        <trans-unit id="5e72ef20465fc62c76630754f83ef1dcdcf00df1" translate="yes" xml:space="preserve">
          <source>It allows developers to lookup one or more processes with a given key. If the registry has &lt;code&gt;:unique&lt;/code&gt; keys, a key points to 0 or 1 processes. If the registry allows &lt;code&gt;:duplicate&lt;/code&gt; keys, a single key may point to any number of processes. In both cases, different keys could identify the same process.</source>
          <target state="translated">これにより、開発者は指定されたキーで1つ以上のプロセスを検索できます。レジストリに &lt;code&gt;:unique&lt;/code&gt; キーがある場合、キーは0または1プロセスを指します。レジストリで &lt;code&gt;:duplicate&lt;/code&gt; キーが許可されている場合、1つのキーで任意の数のプロセスを指定できます。どちらの場合も、異なるキーで同じプロセスを識別できます。</target>
        </trans-unit>
        <trans-unit id="4a71454b932a3e5f1fc7b4c0e7b18e42341a6164" translate="yes" xml:space="preserve">
          <source>It also accepts extra options, for the list of available options check &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn_opt-4&quot;&gt;&lt;code&gt;:erlang.spawn_opt/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">追加のオプションも受け入れます。使用可能なオプションのリストについては、&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn_opt-4&quot;&gt; &lt;code&gt;:erlang.spawn_opt/4&lt;/code&gt; を&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="1fbb9737feae3b4fd98e6dc6a9178278f7164fb2" translate="yes" xml:space="preserve">
          <source>It also accepts functions in the format &lt;code&gt;function/arity&lt;/code&gt; and &lt;code&gt;module.function/arity&lt;/code&gt;, for example:</source>
          <target state="translated">また、 &lt;code&gt;function/arity&lt;/code&gt; および &lt;code&gt;module.function/arity&lt;/code&gt; という形式の関数も受け入れます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="99ac564cc223e5941d854a27c61609f6da592403" translate="yes" xml:space="preserve">
          <source>It also accepts single module argument to list all available behaviour callbacks.</source>
          <target state="translated">また、利用可能なすべてのビヘイビアコールバックをリストアップするための単一のモジュール引数も受け付けています。</target>
        </trans-unit>
        <trans-unit id="c75c3d13969e4bc5682206b7605cdbcb131cac76" translate="yes" xml:space="preserve">
          <source>It also checks the inbox for an input message matching:</source>
          <target state="translated">また、入力メッセージが一致するかどうか、受信箱をチェックします。</target>
        </trans-unit>
        <trans-unit id="d684369d14eb5a8f47ce27babf1c852d61fa5f18" translate="yes" xml:space="preserve">
          <source>It also works with operators and other constructs (try &lt;code&gt;h +/2&lt;/code&gt;). Invoking &lt;code&gt;h&lt;/code&gt; without arguments displays the documentation for &lt;code&gt;IEx.Helpers&lt;/code&gt;, which is where &lt;code&gt;h&lt;/code&gt; and other functionality is defined.</source>
          <target state="translated">また、演算子やその他の構成要素でも機能します（ &lt;code&gt;h +/2&lt;/code&gt; 試してください）。引数なしで &lt;code&gt;h&lt;/code&gt; を呼び出すと、 &lt;code&gt;IEx.Helpers&lt;/code&gt; のドキュメントが表示されます。ここには、 &lt;code&gt;h&lt;/code&gt; およびその他の機能が定義されています。</target>
        </trans-unit>
        <trans-unit id="a500beab3e68eedeee4019c52133aa404957a732" translate="yes" xml:space="preserve">
          <source>It can be a regular file, directory, socket, symbolic link, named pipe, or device file. Returns &lt;code&gt;false&lt;/code&gt; for symbolic links pointing to non-existing targets.</source>
          <target state="translated">通常のファイル、ディレクトリ、ソケット、シンボリックリンク、名前付きパイプ、またはデバイスファイルを指定できます。存在しないターゲットを指すシンボリックリンクに対して &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="c22cd573aa0e917048596a531fe8bd4df0ba66d2" translate="yes" xml:space="preserve">
          <source>It can be upgraded to the DynamicSupervisor like this:</source>
          <target state="translated">このようにDynamicSupervisorにアップグレードすることができます。</target>
        </trans-unit>
        <trans-unit id="7d4ae51a95fbbfa60a796e3589c4762cdf4df826" translate="yes" xml:space="preserve">
          <source>It can be used in your &lt;code&gt;mix.exs&lt;/code&gt; to prepend or append new compilers to Mix:</source>
          <target state="translated">&lt;code&gt;mix.exs&lt;/code&gt; で使用して、Mixに新しいコンパイラを追加または追加できます。</target>
        </trans-unit>
        <trans-unit id="28b1a3769a282dd753685d31c1db0ca20ed8c01c" translate="yes" xml:space="preserve">
          <source>It contains the following fields:</source>
          <target state="translated">以下のフィールドが含まれています。</target>
        </trans-unit>
        <trans-unit id="af1426f38289e13f36126375da54309f97a70a12" translate="yes" xml:space="preserve">
          <source>It contains these fields:</source>
          <target state="translated">これらのフィールドが含まれています。</target>
        </trans-unit>
        <trans-unit id="113d9a8235b2ac8f428decf342fbd7858aa4973c" translate="yes" xml:space="preserve">
          <source>It could also be corrected by using multiple guards, so that if an exception causes one guard to fail, the next one is evaluated.</source>
          <target state="translated">また、複数のガードを使用することで、例外によって1つのガードが失敗した場合、次のガードが評価されるように修正することもできます。</target>
        </trans-unit>
        <trans-unit id="1987bff89f1c6703dd2895ae7707929f8d89192f" translate="yes" xml:space="preserve">
          <source>It depends. It is ok to rely on shared state as long as we depend only on a non-shared partition of this state. Although multiple registries may start buckets on the shared bucket supervisor, those buckets and registries are isolated from each other. We would only run into concurrency issues if we used a function like &lt;code&gt;Supervisor.count_children(KV.BucketSupervisor)&lt;/code&gt; which would count all buckets from all registries, potentially giving different results when tests run concurrently.</source>
          <target state="translated">場合によります。この状態の非共有パーティションのみに依存している限り、共有状態に依存することは問題ありません。複数のレジストリーが共有バケット監視プログラムでバケットを開始する場合がありますが、それらのバケットとレジストリーは互いに分離されています。すべてのレジストリからすべてのバケットをカウントする &lt;code&gt;Supervisor.count_children(KV.BucketSupervisor)&lt;/code&gt; のような関数を使用した場合にのみ、同時実行性の問題が発生し、テストが同時に実行されると異なる結果になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="4a261e69bb9abf1be6a9e6bf29d1f5c299e998d0" translate="yes" xml:space="preserve">
          <source>It differs in that the test suite will fail if no tests are executed when the &lt;code&gt;--only&lt;/code&gt; option is used.</source>
          <target state="translated">&lt;code&gt;--only&lt;/code&gt; オプションが使用されているときにテストが実行されない場合、テストスイートが失敗するという点が異なります。</target>
        </trans-unit>
        <trans-unit id="bebaceae48e94abb745e77cdc9d79c5704717c94" translate="yes" xml:space="preserve">
          <source>It doesn&amp;rsquo;t seem to work at all. That&amp;rsquo;s because we are serving requests in the same process that are accepting connections. When one client is connected, we can&amp;rsquo;t accept another client.</source>
          <target state="translated">まったく動かないようです。これは、接続を受け入れるのと同じプロセスでリクエストを処理するためです。あるクライアントが接続されている場合、別のクライアントを受け入れることはできません。</target>
        </trans-unit>
        <trans-unit id="18c00afbabba2721adf88ec3c29e863b42471b6a" translate="yes" xml:space="preserve">
          <source>It enables pretty printing by default with width of 80 characters. The width can be changed by explicitly passing the &lt;code&gt;:width&lt;/code&gt; option.</source>
          <target state="translated">デフォルトでは、幅80文字のきれいな印刷が可能です。 &lt;code&gt;:width&lt;/code&gt; オプションを明示的に渡すことで幅を変更できます。</target>
        </trans-unit>
        <trans-unit id="38c802c651048f44f24f8b3150960035a31699cb" translate="yes" xml:space="preserve">
          <source>It exists for convenience purposes. For example, you could invoke it inside your &lt;code&gt;mix.exs&lt;/code&gt; to read some external data you decided to move to a configuration file:</source>
          <target state="translated">便宜上の目的で存在しています。たとえば、 &lt;code&gt;mix.exs&lt;/code&gt; 内でそれを呼び出して、構成ファイルに移動することを決定したいくつかの外部データを読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="cfbe9f805346901fb7658c3a10caf05daf303078" translate="yes" xml:space="preserve">
          <source>It expects a &lt;code&gt;radius&lt;/code&gt; which chooses how many lines before and after the current line we should print. By default the &lt;code&gt;radius&lt;/code&gt; is of two lines:</source>
          <target state="translated">現在の行の前後に何行印刷するかを選択する &lt;code&gt;radius&lt;/code&gt; が必要です。デフォルトでは、 &lt;code&gt;radius&lt;/code&gt; は2行です。</target>
        </trans-unit>
        <trans-unit id="e8f41592949431573d9fa16ad07b816bc20d280c" translate="yes" xml:space="preserve">
          <source>It expects a child specification or a module, similar to the ones given to &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#start_link/2&quot;&gt;&lt;code&gt;Supervisor.start_link/2&lt;/code&gt;&lt;/a&gt;. For example, if your application starts a supervision tree by running:</source>
          <target state="translated">これは、&lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#start_link/2&quot;&gt; &lt;code&gt;Supervisor.start_link/2&lt;/code&gt; に&lt;/a&gt;指定されたものと同様の子仕様またはモジュールを必要とします。たとえば、次のコマンドを実行して、アプリケーションが監視ツリーを開始したとします。</target>
        </trans-unit>
        <trans-unit id="88606c2938fbdad4196a7b400eb0db21cee6ea05" translate="yes" xml:space="preserve">
          <source>It expects a list of files to compile and an optional path to write the compiled code to. By default files are in-memory compiled. To write compiled files to the current directory, an empty string can be given.</source>
          <target state="translated">コンパイルするファイルのリストと、コンパイルしたコードを書き込むためのオプションのパスを期待しています。デフォルトでは、ファイルはメモリ内でコンパイルされます。コンパイルされたファイルをカレントディレクトリに書き込むには、空の文字列を指定することができます。</target>
        </trans-unit>
        <trans-unit id="f95cc29acd1a8f43652435b365857f4644147164" translate="yes" xml:space="preserve">
          <source>It expects a time zone to put the &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; in. If the time zone is &quot;Etc/UTC&quot;, it always succeeds. Otherwise, the NaiveDateTime is checked against the time zone database given as &lt;code&gt;time_zone_database&lt;/code&gt;. See the &quot;Time zone database&quot; section in the module documentation.</source>
          <target state="translated">それは、タイムゾーンが&lt;a href=&quot;naivedatetime&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt;を入れることを期待します。タイムゾーンが「Etc / UTC」である場合、それは常に成功します。それ以外の場合、NaiveDateTimeは、 &lt;code&gt;time_zone_database&lt;/code&gt; として指定されたタイムゾーンデータベースに対してチェックされます。モジュールのドキュメントの「タイムゾーンデータベース」セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="1a16340d7de1aebc03edf6573a0e15525a829528" translate="yes" xml:space="preserve">
          <source>It expects a time zone to put the NaiveDateTime in. If the time zone is &quot;Etc/UTC&quot;, it always succeeds. Otherwise, the NaiveDateTime is checked against the time zone database given as &lt;code&gt;time_zone_database&lt;/code&gt;. See the &quot;Time zone database&quot; section in the module documentation.</source>
          <target state="translated">それは、タイムゾーンがNaiveDateTimeを入れることを期待します。タイムゾーンが「Etc / UTC」である場合、それは常に成功します。それ以外の場合、NaiveDateTimeは、 &lt;code&gt;time_zone_database&lt;/code&gt; として指定されたタイムゾーンデータベースに対してチェックされます。モジュールのドキュメントの「タイムゾーンデータベース」セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="c6e8dcd4689f9bb5cfe59fd80447b6dfb675bc3e" translate="yes" xml:space="preserve">
          <source>It expects an accumulator and a function that receives each enumerable element, and must return a tuple containing a new enumerable (often a list) with the new accumulator or a tuple with &lt;code&gt;:halt&lt;/code&gt; as first element and the accumulator as second.</source>
          <target state="translated">これは、各列挙可能な要素を受け取るアキュムレータと関数を想定しており、新しいアキュムレータを持つ新しい列挙可能要素（多くの場合はリスト）を含むタプル、または &lt;code&gt;:halt&lt;/code&gt; を最初の要素とし、アキュムレータを2番目とするタプルを返す必要があります。</target>
        </trans-unit>
        <trans-unit id="ae9f951251e613dc3b8cb49889447942b487f90f" translate="yes" xml:space="preserve">
          <source>It expects an accumulator and a function that receives each stream element and an accumulator, and must return a tuple containing a new stream (often a list) with the new accumulator or a tuple with &lt;code&gt;:halt&lt;/code&gt; as first element and the accumulator as second.</source>
          <target state="translated">これは、各ストリーム要素とアキュムレータを受け取るアキュムレータと関数を想定し、新しいアキュムレータを含む新しいストリーム（多くの場合はリスト）を含むタプル、または &lt;code&gt;:halt&lt;/code&gt; を最初の要素とし、アキュムレータを2番目とするタプルを返す必要があります。</target>
        </trans-unit>
        <trans-unit id="cdb9574f709769eda3fcd701f6835100d09de7b2" translate="yes" xml:space="preserve">
          <source>It happens we can also use this same syntax for updating the value:</source>
          <target state="translated">これは、値を更新するために同じ構文を使用することができます。</target>
        </trans-unit>
        <trans-unit id="7d301b15b4e45486cec4db8315f250c006b60e6f" translate="yes" xml:space="preserve">
          <source>It has to be replaced by:</source>
          <target state="translated">に置き換えなければなりません。</target>
        </trans-unit>
        <trans-unit id="272be857efb69d0027fa3d247e076f214cedbf37" translate="yes" xml:space="preserve">
          <source>It includes assigns (like &lt;code&gt;@foo&lt;/code&gt;) and possibly other conveniences in the future.</source>
          <target state="translated">割り当て（ &lt;code&gt;@foo&lt;/code&gt; のような）と将来的には他の便利な機能が含まれます。</target>
        </trans-unit>
        <trans-unit id="6566504417caf3c9fcfa6f04770ab2069caa71e8" translate="yes" xml:space="preserve">
          <source>It includes many features:</source>
          <target state="translated">多くの機能が含まれています。</target>
        </trans-unit>
        <trans-unit id="71b759b7ba0ceba9436adc2e4d919d9a0599963f" translate="yes" xml:space="preserve">
          <source>It is advised to pass to &lt;a href=&quot;#to_argv/2&quot;&gt;&lt;code&gt;to_argv/2&lt;/code&gt;&lt;/a&gt; the same set of &lt;code&gt;options&lt;/code&gt; given to &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt;. Some switches can only be reconstructed correctly with the &lt;code&gt;:switches&lt;/code&gt; information in hand.</source>
          <target state="translated">に渡すことをお勧めし&lt;a href=&quot;#to_argv/2&quot;&gt; &lt;code&gt;to_argv/2&lt;/code&gt; &lt;/a&gt;の同じセット &lt;code&gt;options&lt;/code&gt; に与えられた&lt;a href=&quot;#parse/2&quot;&gt; &lt;code&gt;parse/2&lt;/code&gt; &lt;/a&gt;。一部のスイッチは、手元の &lt;code&gt;:switches&lt;/code&gt; 情報でのみ正しく再構築できます。</target>
        </trans-unit>
        <trans-unit id="5ec9133e5ffa0e2eb38967925bbcd3b498316545" translate="yes" xml:space="preserve">
          <source>It is also possible to put an element at a particular index in a tuple with &lt;code&gt;put_elem/3&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;put_elem/3&lt;/code&gt; を使用して、タプルの特定のインデックスに要素を配置することもできます。</target>
        </trans-unit>
        <trans-unit id="68a13c5162ca9952e7df7f252e41c665b4a6ce1a" translate="yes" xml:space="preserve">
          <source>It is also possible to register the &lt;code&gt;pid&lt;/code&gt;, giving it a name, and allowing everyone that knows the name to send it messages:</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; を登録して名前を付け、その名前を知っているすべての人がメッセージを送信できるようにすることもできます。</target>
        </trans-unit>
        <trans-unit id="a136eb79bc8a61b01254d5faf81fdf246125d6a9" translate="yes" xml:space="preserve">
          <source>It is also possible to spawn a task under a supervisor. The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; module implements the &lt;a href=&quot;#child_spec/1&quot;&gt;&lt;code&gt;child_spec/1&lt;/code&gt;&lt;/a&gt; function, which allows it to be started directly under a supervisor by passing a tuple with a function to run:</source>
          <target state="translated">スーパーバイザーの下でタスクを生成することも可能です。&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;モジュールが実装&lt;a href=&quot;#child_spec/1&quot;&gt; &lt;code&gt;child_spec/1&lt;/code&gt; &lt;/a&gt;、それが実行する機能でタプルを渡すことで、監督の下で直接起動することができる機能、：</target>
        </trans-unit>
        <trans-unit id="d56d59c22a31d0146ae9749c3030a51ef3731009" translate="yes" xml:space="preserve">
          <source>It is also used between &lt;code&gt;fn/end&lt;/code&gt; for building anonymous functions:</source>
          <target state="translated">匿名関数を構築するために &lt;code&gt;fn/end&lt;/code&gt; の間でも使用されます。</target>
        </trans-unit>
        <trans-unit id="56e71075219fd34ef819cdd9dc47abc0939b0f36" translate="yes" xml:space="preserve">
          <source>It is also very common to use &lt;code&gt;IO.inspect/2&lt;/code&gt; with &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#binding/0&quot;&gt;&lt;code&gt;binding()&lt;/code&gt;&lt;/a&gt;, which returns all variable names and their values:</source>
          <target state="translated">また、使用することは非常に一般的です &lt;code&gt;IO.inspect/2&lt;/code&gt; で&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#binding/0&quot;&gt; &lt;code&gt;binding()&lt;/code&gt; &lt;/a&gt;すべての変数名とその値を返します、：</target>
        </trans-unit>
        <trans-unit id="d30bf8f40195feb2fe708ceb6f9af150955200b6" translate="yes" xml:space="preserve">
          <source>It is an integer from 1 to 366.</source>
          <target state="translated">1から366までの整数です。</target>
        </trans-unit>
        <trans-unit id="32489e7a3e2d6e237839e846a2d9f094cd20f95c" translate="yes" xml:space="preserve">
          <source>It is an integer from 1 to 4.</source>
          <target state="translated">1から4までの整数である。</target>
        </trans-unit>
        <trans-unit id="aef7af646cd422fb9f21670a1cedef851042bc5d" translate="yes" xml:space="preserve">
          <source>It is an integer from 1 to 7, where 1 is Monday and 7 is Sunday.</source>
          <target state="translated">1から7までの整数で、1は月曜日、7は日曜日です。</target>
        </trans-unit>
        <trans-unit id="e3505fd23f7d466c912f750fe33536eb913541ef" translate="yes" xml:space="preserve">
          <source>It is available only in the &lt;code&gt;catch&lt;/code&gt; and &lt;code&gt;rescue&lt;/code&gt; clauses of &lt;a href=&quot;#try/1&quot;&gt;&lt;code&gt;try/1&lt;/code&gt;&lt;/a&gt; expressions.</source>
          <target state="translated">これは、&lt;a href=&quot;#try/1&quot;&gt; &lt;code&gt;try/1&lt;/code&gt; &lt;/a&gt;式の &lt;code&gt;catch&lt;/code&gt; および &lt;code&gt;rescue&lt;/code&gt; 句でのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="80946675cc21f317c9b0ef6e5905961ee735ea93" translate="yes" xml:space="preserve">
          <source>It is exactly this supervision system that makes constructs like &lt;code&gt;try/catch&lt;/code&gt; and &lt;code&gt;try/rescue&lt;/code&gt; so uncommon in Elixir. Instead of rescuing an error, we&amp;rsquo;d rather &amp;ldquo;fail fast&amp;rdquo; since the supervision tree will guarantee our application will go back to a known initial state after the error.</source>
          <target state="translated">Elixirでは、 &lt;code&gt;try/catch&lt;/code&gt; や &lt;code&gt;try/rescue&lt;/code&gt; のような構成が非常に珍しくなっているのは、まさにこの監視システムです。エラーを救済する代わりに、監視ツリーはアプリケーションがエラー後に既知の初期状態に戻ることを保証するので、むしろ「フ​​ェイルファスト」します。</target>
        </trans-unit>
        <trans-unit id="d207929393d3a65f7ffe43fdfee93a560fcbb309" translate="yes" xml:space="preserve">
          <source>It is extremely important that &lt;strong&gt;the formatting function does not fail&lt;/strong&gt;, as it will bring that particular logger instance down, causing your system to temporarily lose messages. If necessary, wrap the function in a &lt;code&gt;rescue&lt;/code&gt; and log a default message instead:</source>
          <target state="translated">特定のロガーインスタンスがダウンし、システムが一時的にメッセージを失う原因となるため&lt;strong&gt;、フォーマット機能が失敗しない&lt;/strong&gt;ことが非常に重要です。必要に応じて、関数を &lt;code&gt;rescue&lt;/code&gt; でラップし、代わりにデフォルトのメッセージをログに記録します。</target>
        </trans-unit>
        <trans-unit id="94832ece51ae5f1825006490cfa48c6fe6830752" translate="yes" xml:space="preserve">
          <source>It is important that a macro is defined before its usage. Failing to define a macro before its invocation will raise an error at runtime, since the macro won&amp;rsquo;t be expanded and will be translated to a function call:</source>
          <target state="translated">マクロを使用する前に定義することが重要です。マクロは展開されず、関数呼び出しに変換されるため、呼び出し前にマクロを定義しないと、実行時にエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="0771070acf565ebd4c40d426b39c1e6523d52f21" translate="yes" xml:space="preserve">
          <source>It is important that you choose an editor command that does not block nor that attempts to run an editor directly in the terminal. Command-line based editors likely need extra configuration so they open up the given file and line in a separate window.</source>
          <target state="translated">エディタをブロックしたり、ターミナルで直接エディタを実行しようとしないエディタコマンドを選択することが重要です。コマンドラインベースのエディタは、与えられたファイルと行を別のウィンドウで開くため、余分な設定が必要になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="b481005fe84ee670ac7d11f9a15a1a80d4c1bd8f" translate="yes" xml:space="preserve">
          <source>It is important to bear in mind that variables defined inside &lt;code&gt;try/catch/rescue/after&lt;/code&gt; blocks do not leak to the outer context. This is because the &lt;code&gt;try&lt;/code&gt; block may fail and as such the variables may never be bound in the first place. In other words, this code is invalid:</source>
          <target state="translated">&lt;code&gt;try/catch/rescue/after&lt;/code&gt; ブロック内で定義された変数は外部コンテキストにリークしないことを覚えておくことが重要です。これは、 &lt;code&gt;try&lt;/code&gt; ブロックが失敗する可能性があるため、そもそも変数がバインドされない可能性があるためです。つまり、このコードは無効です。</target>
        </trans-unit>
        <trans-unit id="d6056e64535d65b5186c963f7472dd3b3997efc0" translate="yes" xml:space="preserve">
          <source>It is important to consider the limitations of distributed agents. Agents provide two APIs, one that works with anonymous functions and another that expects an explicit module, function, and arguments.</source>
          <target state="translated">分散エージェントの限界を考慮することが重要です。エージェントは2つのAPIを提供しており、1つは匿名関数で動作するもので、もう1つは明示的なモジュール、関数、引数を期待するものです。</target>
        </trans-unit>
        <trans-unit id="f355f25591ea852cf993c5e79bb23c864b9b3d30" translate="yes" xml:space="preserve">
          <source>It is important to highlight that step 2 is a blocking one. Termination of a supervisor triggers a recursive chain of children terminations, therefore orderly shutting down all descendant processes. The &lt;a href=&quot;#c:stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt; callback is invoked only after termination of the whole supervision tree.</source>
          <target state="translated">ステップ2はブロックするステップであることを強調することが重要です。スーパーバイザの終了は、子の終了の再帰チェーンをトリガーするため、すべての子孫プロセスを正常にシャットダウンします。&lt;a href=&quot;#c:stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt;コールバックは全体のみ監督ツリーの終了後に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="a5cda11adf3996ed10a3333a6901fb7bf070783d" translate="yes" xml:space="preserve">
          <source>It is important to note a couple of things:</source>
          <target state="translated">いくつかのことをメモしておくことが大切です。</target>
        </trans-unit>
        <trans-unit id="c367faed115a28802b3ecac8ce4c9b1b9a88de2a" translate="yes" xml:space="preserve">
          <source>It is important to note that a name without &lt;code&gt;!&lt;/code&gt; does not mean a function will never raise. For example, even &lt;a href=&quot;file#read/1&quot;&gt;&lt;code&gt;File.read/1&lt;/code&gt;&lt;/a&gt; can fail in case of bad arguments:</source>
          <target state="translated">名前のないことに注意することが重要 &lt;code&gt;!&lt;/code&gt; 関数が決して発生しないという意味ではありません。たとえば、引数が正しくない場合、&lt;a href=&quot;file#read/1&quot;&gt; &lt;code&gt;File.read/1&lt;/code&gt; &lt;/a&gt; / 1でも失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="64d0775b812a63ae04cc72818c998dd0360e82ac" translate="yes" xml:space="preserve">
          <source>It is important to note that reading an attribute takes a snapshot of its current value. In other words, the value is read at compilation time and not at runtime. Check the &lt;a href=&quot;module&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt; module for other functions to manipulate module attributes.</source>
          <target state="translated">属性を読み取ると、現在の値のスナップショットが作成されることに注意してください。つまり、値は実行時ではなくコンパイル時に読み取られます。モジュール属性を操作する他の関数については、&lt;a href=&quot;module&quot;&gt; &lt;code&gt;Module&lt;/code&gt; &lt;/a&gt;モジュールを確認してください。</target>
        </trans-unit>
        <trans-unit id="a19241f2445b2abd37c68c335fe23ae6dbe32fe5" translate="yes" xml:space="preserve">
          <source>It is important to notice that &lt;a href=&quot;#import/2&quot;&gt;&lt;code&gt;import/2&lt;/code&gt;&lt;/a&gt; is lexical. This means you can import specific macros inside specific functions:</source>
          <target state="translated">&lt;a href=&quot;#import/2&quot;&gt; &lt;code&gt;import/2&lt;/code&gt; &lt;/a&gt;が字句であることに注意することが重要です。つまり、特定の関数内に特定のマクロをインポートできます。</target>
        </trans-unit>
        <trans-unit id="74faff03e6fb39084e8fdee360d2d52a55c9644f" translate="yes" xml:space="preserve">
          <source>It is not recommended to &lt;code&gt;await&lt;/code&gt; a long-running task inside an OTP behaviour such as &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. Instead, you should match on the message coming from a task inside your &lt;a href=&quot;genserver#c:handle_info/2&quot;&gt;&lt;code&gt;GenServer.handle_info/2&lt;/code&gt;&lt;/a&gt; callback. For more information on the format of the message, see the documentation for &lt;a href=&quot;#async/1&quot;&gt;&lt;code&gt;async/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;などのOTP動作内で長時間実行されるタスクを &lt;code&gt;await&lt;/code&gt; ことはお勧めしません。代わりに、&lt;a href=&quot;genserver#c:handle_info/2&quot;&gt; &lt;code&gt;GenServer.handle_info/2&lt;/code&gt; &lt;/a&gt;コールバック内のタスクからのメッセージを照合する必要があります。メッセージの形式の詳細については、&lt;a href=&quot;#async/1&quot;&gt; &lt;code&gt;async/1&lt;/code&gt; の&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="8f8ca3b4e0816d59dc7e2cc08d33fe47c5a02853" translate="yes" xml:space="preserve">
          <source>It is not required to call this function when terminating the caller, unless exiting with reason &lt;code&gt;:normal&lt;/code&gt; or if the task is trapping exits. If the caller is exiting with a reason other than &lt;code&gt;:normal&lt;/code&gt; and the task is not trapping exits, the caller's exit signal will stop the task. The caller can exit with reason &lt;code&gt;:shutdown&lt;/code&gt; to shut down all of its linked processes, including tasks, that are not trapping exits without generating any log messages.</source>
          <target state="translated">理由 &lt;code&gt;:normal&lt;/code&gt; で終了する場合、またはタスクがトラップしている場合を除き、呼び出し元の終了時にこの関数を呼び出す必要はありません。呼び出し元が &lt;code&gt;:normal&lt;/code&gt; 以外の理由で終了し、タスクが終了をトラップしていない場合、呼び出し元の終了シグナルはタスクを停止します。呼び出し元は、理由 &lt;code&gt;:shutdown&lt;/code&gt; で終了し、ログメッセージを生成せずに出口をトラップしていない、タスクを含む、リンクされたすべてのプロセスをシャットダウンできます。</target>
        </trans-unit>
        <trans-unit id="67f36f6c8c75697bc200a5a574eb5412409dbdaf" translate="yes" xml:space="preserve">
          <source>It is possible to get shell history by passing some options that enable it in the VM. This can be done on a per-need basis when starting IEx:</source>
          <target state="translated">VM でシェルの履歴を有効にするオプションを渡すことで、シェルの履歴を取得することができます。これは IEx の起動時に必要に応じて行うことができます。</target>
        </trans-unit>
        <trans-unit id="69aceb3d7f53fc191d1a69a74161461cd8fbf145" translate="yes" xml:space="preserve">
          <source>It is possible to implement protocols for all Elixir types:</source>
          <target state="translated">すべてのElixirタイプのプロトコルを実装することが可能です。</target>
        </trans-unit>
        <trans-unit id="54b8401178da67a2e8ae820b1821bcca42b37a5a" translate="yes" xml:space="preserve">
          <source>It is possible to load another file by supplying the &lt;code&gt;--dot-iex&lt;/code&gt; option to IEx. See &lt;code&gt;iex --help&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--dot-iex&lt;/code&gt; オプションを指定すると、別のファイルをロードできます。 &lt;code&gt;iex --help&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="4658430a105177a520b05efa9b8a1f1f62f88a4e" translate="yes" xml:space="preserve">
          <source>It is received by formatters and contains the following fields:</source>
          <target state="translated">これはフォーマッタによって受信され、以下のフィールドを含んでいます。</target>
        </trans-unit>
        <trans-unit id="02b1294519dc996fe92a26357c7d5248dd2135f9" translate="yes" xml:space="preserve">
          <source>It is recommended for this function to be invoked in your application's start callback in case you want to register new URIs.</source>
          <target state="translated">新しいURIを登録したい場合に備えて、この関数をアプリケーションのスタートコールバックで呼び出すことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="5e8259dbbda9694f8ea6053003d2b8b79b9d00cb" translate="yes" xml:space="preserve">
          <source>It is recommended that backends support at least the following configuration options:</source>
          <target state="translated">バックエンドは、少なくとも以下の設定オプションをサポートすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="01b6fa79cb9bec0bdf62d160c7cca8aebb12f76e" translate="yes" xml:space="preserve">
          <source>It is recommended that handlers ignore messages where the group leader is in a different node than the one where the handler is installed. For example:</source>
          <target state="translated">グループリーダーがハンドラがインストールされているノードとは異なるノードにあるメッセージは、ハンドラが無視することを推奨します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="f259c2cd34cad051f58a609a1b449871f089e4f6" translate="yes" xml:space="preserve">
          <source>It is recommended to define types for structs. By convention such type is called &lt;code&gt;t&lt;/code&gt;. To define a struct inside a type, the struct literal syntax is used:</source>
          <target state="translated">構造体のタイプを定義することをお勧めします。慣例により、このようなタイプは &lt;code&gt;t&lt;/code&gt; と呼ばれます。タイプ内の構造体を定義するには、構造体リテラル構文を使用します。</target>
        </trans-unit>
        <trans-unit id="2d5fa416a3649615d6c6d6b9cb2027f26118c8ff" translate="yes" xml:space="preserve">
          <source>It is recommended to only use the struct syntax when defining the struct's type. When referring to another struct it's better to use &lt;code&gt;User.t&lt;/code&gt; instead of &lt;code&gt;%User{}&lt;/code&gt;.</source>
          <target state="translated">構造体のタイプを定義するときは、構造体構文のみを使用することをお勧めします。別の構造体を参照する場合は、 &lt;code&gt;%User{}&lt;/code&gt; ではなく &lt;code&gt;User.t&lt;/code&gt; を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="d5056e9d07d3e016975093e74ccd6e13e0e051a1" translate="yes" xml:space="preserve">
          <source>It is seen on &lt;code&gt;case&lt;/code&gt; and &lt;code&gt;cond&lt;/code&gt; constructs between &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt;:</source>
          <target state="translated">これは、上で見ている &lt;code&gt;case&lt;/code&gt; と &lt;code&gt;cond&lt;/code&gt; の間の構造 &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a5a7029e719605ca3d075a3021c347e0da442f5a" translate="yes" xml:space="preserve">
          <source>It is the VM view of the &lt;a href=&quot;#os_time/0&quot;&gt;&lt;code&gt;os_time/0&lt;/code&gt;&lt;/a&gt;. They may not match in case of time warps although the VM works towards aligning them. This time is not monotonic.</source>
          <target state="translated">これは&lt;a href=&quot;#os_time/0&quot;&gt; &lt;code&gt;os_time/0&lt;/code&gt; &lt;/a&gt;のVMビューです。タイムワープの場合、VMはそれらを調整するように機能しますが、一致しない場合があります。今回は単調ではありません。</target>
        </trans-unit>
        <trans-unit id="788b993466f063f33f672e4a2e86998a7111a391" translate="yes" xml:space="preserve">
          <source>It is useful for performing work after initialization or for splitting the work in a callback in multiple steps, updating the process state along the way.</source>
          <target state="translated">初期化後に作業を行ったり、コールバックで複数のステップに分けて作業を行い、途中でプロセスの状態を更新したりするのに便利です。</target>
        </trans-unit>
        <trans-unit id="bb15e04c4610818bfc29250241bbd9f9e91a6db6" translate="yes" xml:space="preserve">
          <source>It is usually compiled to an atom:</source>
          <target state="translated">通常はアトムにコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="609d6804675f59ef88a96987b74ba4711ad19be8" translate="yes" xml:space="preserve">
          <source>It is worth mentioning that some tasks, such as in the case of the &lt;code&gt;format&lt;/code&gt; command in the example above, can accept multiple files so it could be rewritten as:</source>
          <target state="translated">上記の例の &lt;code&gt;format&lt;/code&gt; コマンドの場合など、一部のタスクは複数のファイルを受け入れることができるため、次のように書き直すことができます。</target>
        </trans-unit>
        <trans-unit id="581eca3344ca4bb0aa530a5501c01bfdeab48bb0" translate="yes" xml:space="preserve">
          <source>It is worth noting that an IO stream has side effects and every time you go over the stream you may get different results.</source>
          <target state="translated">IOストリームには副作用があり、ストリームを超えるたびに異なる結果が得られる可能性があることは注目に値します。</target>
        </trans-unit>
        <trans-unit id="d5d4db08190e3953685aadfa886d49cc802cec92" translate="yes" xml:space="preserve">
          <source>It is, however, possible to customize the operating system exit signal by invoking:</source>
          <target state="translated">しかし、起動することで、オペレーティングシステムの終了信号をカスタマイズすることができます。</target>
        </trans-unit>
        <trans-unit id="b7d48f671c8d7393dad3a546a97b3ca8d3a912b7" translate="yes" xml:space="preserve">
          <source>It mainly consists of:</source>
          <target state="translated">主として構成されています。</target>
        </trans-unit>
        <trans-unit id="1e0c789d57c1d4d0b775a90fcdfa554caa5f5673" translate="yes" xml:space="preserve">
          <source>It may also be used in bit strings to specify the type of a given bit segment:</source>
          <target state="translated">また、ビット文字列の中で、与えられたビットセグメントの型を指定するために使用されることもあります。</target>
        </trans-unit>
        <trans-unit id="a3af067d0b325c04e2171267019d9beee23844b2" translate="yes" xml:space="preserve">
          <source>It may be &lt;em&gt;done&lt;/em&gt; when the enumeration is finished by reaching its end, or &lt;em&gt;halted&lt;/em&gt;/&lt;em&gt;suspended&lt;/em&gt; when the enumeration was halted or suspended by the &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">これは、列挙が最後に到達して終了したときに&lt;em&gt;行わ&lt;/em&gt;れるか、または&lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt;関数によって列挙が停止または中断されたときに&lt;em&gt;停止&lt;/em&gt; / &lt;em&gt;中断&lt;/em&gt;されます。</target>
        </trans-unit>
        <trans-unit id="0d98718d8646c579d0371793bd45e746bde50bf4" translate="yes" xml:space="preserve">
          <source>It may raise an exception if an alias or a task can't be found or the task is invalid. Check &lt;a href=&quot;#get!/1&quot;&gt;&lt;code&gt;get!/1&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">エイリアスやタスクが見つからない場合、またはタスクが無効な場合は、例外が発生する可能性があります。詳細については、&lt;a href=&quot;#get!/1&quot;&gt; &lt;code&gt;get!/1&lt;/code&gt; &lt;/a&gt;を確認してください。</target>
        </trans-unit>
        <trans-unit id="96e34b31aa2d5f1e971f892ae829e91c39507ae8" translate="yes" xml:space="preserve">
          <source>It merely logged an error but the parent process is still running. That&amp;rsquo;s because processes are isolated. If we want the failure in one process to propagate to another one, we should link them. This can be done with &lt;code&gt;spawn_link/1&lt;/code&gt;:</source>
          <target state="translated">エラーをログに記録するだけですが、親プロセスはまだ実行中です。プロセスが分離されているからです。あるプロセスの障害を別のプロセスに伝播させたい場合は、それらをリンクする必要があります。これは &lt;code&gt;spawn_link/1&lt;/code&gt; で行うことができます：</target>
        </trans-unit>
        <trans-unit id="a7645b02092dd9c481669b06461dd8a3b1f2ddfe" translate="yes" xml:space="preserve">
          <source>It must be a tagged tuple with one of the following &quot;tags&quot;:</source>
          <target state="translated">以下のいずれかの「タグ」を持つタグ付きタプルでなければなりません。</target>
        </trans-unit>
        <trans-unit id="9191e1a92c69837df58d349dc309a932384aa7e6" translate="yes" xml:space="preserve">
          <source>It must return Elixir's quoted expressions for the nesting.</source>
          <target state="translated">ネスティングのためには、Elixirの引用表現を返さなければなりません。</target>
        </trans-unit>
        <trans-unit id="712b77376d5995f0d379321d9075dffa76132d6d" translate="yes" xml:space="preserve">
          <source>It must return Elixir's quoted expressions for the template.</source>
          <target state="translated">テンプレートに対してElixirの引用符で囲まれた式を返さなければなりません。</target>
        </trans-unit>
        <trans-unit id="38cc5837d518a2974bbdd3756a4a52b60b4904d1" translate="yes" xml:space="preserve">
          <source>It must return a new state that is used only inside the nesting. Once the nesting terminates, the current &lt;code&gt;state&lt;/code&gt; is resumed.</source>
          <target state="translated">入れ子の内部でのみ使用される新しい状態を返す必要があります。ネストが終了すると、現在の &lt;code&gt;state&lt;/code&gt; が再開されます。</target>
        </trans-unit>
        <trans-unit id="0854aef4598e67609aceb61dad3e1730bf8b1dd1" translate="yes" xml:space="preserve">
          <source>It must return the initial state.</source>
          <target state="translated">初期状態を返さなければなりません。</target>
        </trans-unit>
        <trans-unit id="e3fb70c8558503fe57ada3a7512d669bb23cc15f" translate="yes" xml:space="preserve">
          <source>It must return the updated state.</source>
          <target state="translated">更新された状態を返さなければなりません。</target>
        </trans-unit>
        <trans-unit id="168abfa6eb1b0dfa8208332679693b0f2aede472" translate="yes" xml:space="preserve">
          <source>It performs Normalization Form Canonical Decomposition (NFD) on the strings before comparing them. This function is equivalent to:</source>
          <target state="translated">これは,文字列を比較する前に,正規化形式の正準分解(NFD)を行います.この関数は以下に相当します。</target>
        </trans-unit>
        <trans-unit id="00eb69ecf576738c75d84548dd92cdb318ece3aa" translate="yes" xml:space="preserve">
          <source>It raises &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;pid&lt;/code&gt; is not a local process.</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; がローカルプロセスでない場合は、&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;が発生します。</target>
        </trans-unit>
        <trans-unit id="7e7523b5dc45d67bb8b9c0de3919b26ce0d37a20" translate="yes" xml:space="preserve">
          <source>It raises &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; when index is negative or it is out of range of the tuple elements.</source>
          <target state="translated">インデックスが負の場合、またはタプル要素の範囲外の場合は、&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; が&lt;/a&gt;発生します。</target>
        </trans-unit>
        <trans-unit id="a7db82325b8b2d3d85d652577eadfac10c4e6cc9" translate="yes" xml:space="preserve">
          <source>It raises at compile time if the definition uses expressions that aren't allowed in guards, and otherwise creates a macro that can be used both inside or outside guards.</source>
          <target state="translated">定義がガード内で許可されていない式を使用している場合はコンパイル時に発生し、そうでない場合はガード内でもガード外でも使用できるマクロを作成します。</target>
        </trans-unit>
        <trans-unit id="1064c23cd1e6b9f641867dd10b3bf5061844678b" translate="yes" xml:space="preserve">
          <source>It raises at compile time if the definition uses expressions that aren't allowed in guards, and otherwise creates a private macro that can be used both inside or outside guards in the current module.</source>
          <target state="translated">定義がガード内で許可されていない式を使用している場合はコンパイル時に発生し、そうでない場合は現在のモジュール内でガード内でもガード外でも使用できるプライベートマクロを作成します。</target>
        </trans-unit>
        <trans-unit id="b4865031f19e0226674ccac4c00c4c4f11e96290" translate="yes" xml:space="preserve">
          <source>It receives the current &lt;code&gt;config&lt;/code&gt; and the &lt;code&gt;state&lt;/code&gt; returned by &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;. Then you typically read the extra configuration from an external source and merge it into the received &lt;code&gt;config&lt;/code&gt;. Merging should be done with &lt;a href=&quot;config.reader#merge/2&quot;&gt;&lt;code&gt;Config.Reader.merge/2&lt;/code&gt;&lt;/a&gt;, as it performs deep merge. It should return the updated config.</source>
          <target state="translated">現在の &lt;code&gt;config&lt;/code&gt; と&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt;によって返された &lt;code&gt;state&lt;/code&gt; を受け取ります。そして、あなたは一般的に、外部ソースからの追加設定を読んで、それを受け取っにマージ &lt;code&gt;config&lt;/code&gt; 。マージは&lt;a href=&quot;config.reader#merge/2&quot;&gt; &lt;code&gt;Config.Reader.merge/2&lt;/code&gt; &lt;/a&gt;で行う必要があります。深いマージを実行するためです。更新された構成が返されます。</target>
        </trans-unit>
        <trans-unit id="7ff8300751e75adc2c83e12f280310fb0e3959a9" translate="yes" xml:space="preserve">
          <source>It receives the same options as &lt;a href=&quot;#put_env/4&quot;&gt;&lt;code&gt;put_env/4&lt;/code&gt;&lt;/a&gt;. Returns &lt;code&gt;:ok&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#put_env/4&quot;&gt; &lt;code&gt;put_env/4&lt;/code&gt; &lt;/a&gt;と同じオプションを受け取ります。 &lt;code&gt;:ok&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="63a1b1ead1b4654ed54aa371a1a054c21e1c05bd" translate="yes" xml:space="preserve">
          <source>It relies on &lt;a href=&quot;#format_banner/3&quot;&gt;&lt;code&gt;format_banner/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#format_stacktrace/1&quot;&gt;&lt;code&gt;format_stacktrace/1&lt;/code&gt;&lt;/a&gt; to generate the final format.</source>
          <target state="translated">最終的なフォーマットを生成するために、&lt;a href=&quot;#format_banner/3&quot;&gt; &lt;code&gt;format_banner/3&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#format_stacktrace/1&quot;&gt; &lt;code&gt;format_stacktrace/1&lt;/code&gt; &lt;/a&gt;に依存しています。</target>
        </trans-unit>
        <trans-unit id="ff0e052a45a87445bf1db1b18304c3b0b5b06885" translate="yes" xml:space="preserve">
          <source>It represents time as a fraction of a day (starting from midnight). &lt;code&gt;parts_in_day&lt;/code&gt; specifies how much of the day is already passed, while &lt;code&gt;parts_per_day&lt;/code&gt; signifies how many parts there fit in a day.</source>
          <target state="translated">時間を1日の一部として表します（真夜中から開始）。 &lt;code&gt;parts_in_day&lt;/code&gt; は、既に渡された日の量を指定します。一方、 &lt;code&gt;parts_per_day&lt;/code&gt; は、1日にそこに入る部品の数を示します。</target>
        </trans-unit>
        <trans-unit id="ef0b176f883854b3bc16cf9fece54e5b9b4e4c75" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;:ok&lt;/code&gt; if it succeeds.</source>
          <target state="translated">成功すると &lt;code&gt;:ok&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="b4dd7376af1ba434a4580bda89ca9e2039d7b5af" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;:ok&lt;/code&gt; if the agent terminates with the given reason. If the agent terminates with another reason, the call will exit.</source>
          <target state="translated">エージェントが所定の理由で終了した場合は、 &lt;code&gt;:ok&lt;/code&gt; を返します。エージェントが別の理由で終了した場合、コールは終了します。</target>
        </trans-unit>
        <trans-unit id="fa25fad557d19ecb8fc577a65e74f7d1d95fee17" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;:ok&lt;/code&gt; if the expression is valid. Otherwise it returns a tuple in the form of &lt;code&gt;{:error, remainder}&lt;/code&gt; where &lt;code&gt;remainder&lt;/code&gt; is the invalid part of the quoted expression.</source>
          <target state="translated">式が有効な場合は &lt;code&gt;:ok&lt;/code&gt; を返します。それ以外の場合は、 &lt;code&gt;{:error, remainder}&lt;/code&gt; の形式でタプルを返します。ここで、 &lt;code&gt;remainder&lt;/code&gt; は引用された式の無効な部分です。</target>
        </trans-unit>
        <trans-unit id="1aa27a7fb3f7df06a7eb5b40933d88237c6da58a" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;:ok&lt;/code&gt; if the supervisor terminates with the given reason. If it terminates with another reason, the call exits.</source>
          <target state="translated">スーパーバイザが指定された理由で終了した場合、 &lt;code&gt;:ok&lt;/code&gt; を返します。別の理由で終了した場合、呼び出しは終了します。</target>
        </trans-unit>
        <trans-unit id="20439119e73e5c84c38c2e670d5943fecce5bbc5" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;:ok&lt;/code&gt; if there is a supervised process with such &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;{:error, :not_found}&lt;/code&gt; otherwise.</source>
          <target state="translated">そのような &lt;code&gt;id&lt;/code&gt; 持つ監視対象プロセスがある場合は &lt;code&gt;:ok&lt;/code&gt; を返し &lt;code&gt;{:error, :not_found}&lt;/code&gt; そうでない場合は{：error、：not_found}を返します。</target>
        </trans-unit>
        <trans-unit id="c6ba3f217ed1eba268a6fdafd4321bb54d3750b6" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;[]&lt;/code&gt; if &lt;code&gt;amount&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; or if &lt;code&gt;start_index&lt;/code&gt; is out of bounds.</source>
          <target state="translated">これは、戻り &lt;code&gt;[]&lt;/code&gt; 場合 &lt;code&gt;amount&lt;/code&gt; ある &lt;code&gt;0&lt;/code&gt; 又は場合 &lt;code&gt;start_index&lt;/code&gt; 範囲外です。</target>
        </trans-unit>
        <trans-unit id="a24863390fa39668ae8776992d58e83d80073d64" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, modules, warnings}&lt;/code&gt; or &lt;code&gt;{:error, errors, warnings}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{:ok, modules, warnings}&lt;/code&gt; または &lt;code&gt;{:error, errors, warnings}&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="15cf8a959344bff62a34e05c441e26b91698feeb" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, number_of_modules_purged}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{:ok, number_of_modules_purged}&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="115a450f9d17534c1b57fc590c68a557bb8594c5" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, regex}&lt;/code&gt; in case of success, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">成功した場合は &lt;code&gt;{:ok, regex}&lt;/code&gt; を返し &lt;code&gt;{:error, reason}&lt;/code&gt; それ以外の場合は{：error、reason}を返します。</target>
        </trans-unit>
        <trans-unit id="de65d4d5bdecdb8de8753805e8f5f01ea831d124" translate="yes" xml:space="preserve">
          <source>It returns a charlist as if it was a single quoted string, unescaping characters and replacing interpolations.</source>
          <target state="translated">これは、単一の引用符で囲まれた文字列であるかのように文字リストを返し、文字のエスケープを解除し、補間を置き換えます。</target>
        </trans-unit>
        <trans-unit id="a66f3b8a76faa873e28dfa79a7a12532886cbb5f" translate="yes" xml:space="preserve">
          <source>It returns a list of &quot;words&quot; split by whitespace without escaping nor interpreting interpolations.</source>
          <target state="translated">エスケープや補間を行わずに、空白で区切られた「単語」のリストを返します。</target>
        </trans-unit>
        <trans-unit id="11c767a0c0e8da6110101dac7c301abe9c23f7ad" translate="yes" xml:space="preserve">
          <source>It returns a list of &quot;words&quot; split by whitespace. Character unescaping and interpolation happens for each word.</source>
          <target state="translated">これは、空白で区切られた &quot;単語 &quot;のリストを返します。文字のエスケープ解除と補間は各単語に対して行われます。</target>
        </trans-unit>
        <trans-unit id="e5072f624143fef2c9ac9a882f637a2b3946d312" translate="yes" xml:space="preserve">
          <source>It returns a list with all defined functions and macros, public and private, in the shape of &lt;code&gt;[{name, arity}, ...]&lt;/code&gt;.</source>
          <target state="translated">これは、 &lt;code&gt;[{name, arity}, ...]&lt;/code&gt; で、すべての定義済み関数とマクロ（publicとprivate）のリストを返します。</target>
        </trans-unit>
        <trans-unit id="12058e15be1548c9678ae57e51b9c05668dbfa6c" translate="yes" xml:space="preserve">
          <source>It returns a regular expression pattern without escaping nor interpreting interpolations.</source>
          <target state="translated">エスケープや補間を行わずに正規表現パターンを返します。</target>
        </trans-unit>
        <trans-unit id="c2339efe4030b11d97d29c7a067b3b9900e5b1d8" translate="yes" xml:space="preserve">
          <source>It returns a regular expression pattern, unescaping characters and replacing interpolations.</source>
          <target state="translated">正規表現パターンを返し、文字のエスケープを解除し、補間を置き換えます。</target>
        </trans-unit>
        <trans-unit id="2eefd18752fd7d7d11850a6f38a6e135cd46467d" translate="yes" xml:space="preserve">
          <source>It returns a string as if it was a double quoted string, unescaping characters and replacing interpolations.</source>
          <target state="translated">ダブルクォートされた文字列であるかのように文字列を返し、文字のエスケープを解除し、補間を置き換えます。</target>
        </trans-unit>
        <trans-unit id="1309542e01ede5ca574094267b91e1297dcf83b5" translate="yes" xml:space="preserve">
          <source>It returns a three-element tuple with the form &lt;code&gt;{parsed, args, invalid}&lt;/code&gt;, where:</source>
          <target state="translated">&lt;code&gt;{parsed, args, invalid}&lt;/code&gt; という形式の3要素のタプルを返します。ここで、</target>
        </trans-unit>
        <trans-unit id="5d3aa2fe3892cfc7dc8712478400dbcd79a2ad47" translate="yes" xml:space="preserve">
          <source>It returns a tuple of shape &lt;code&gt;{:module, module, binary, term}&lt;/code&gt; where &lt;code&gt;module&lt;/code&gt; is the module name, &lt;code&gt;binary&lt;/code&gt; is the module byte code and &lt;code&gt;term&lt;/code&gt; is the result of the last expression in &lt;code&gt;quoted&lt;/code&gt;.</source>
          <target state="translated">これは、形状 &lt;code&gt;{:module, module, binary, term}&lt;/code&gt; タプルを返します。ここで、 &lt;code&gt;module&lt;/code&gt; はモジュール名、 &lt;code&gt;binary&lt;/code&gt; はモジュールのバイトコード、 &lt;code&gt;term&lt;/code&gt; は &lt;code&gt;quoted&lt;/code&gt; 内の最後の式の結果です。</target>
        </trans-unit>
        <trans-unit id="105ded5280b2ff4b7ca0620f752d88bc06179945" translate="yes" xml:space="preserve">
          <source>It returns a tuple where the first element is the first value for &lt;code&gt;key&lt;/code&gt; and the second element is a keyword list with all entries associated with &lt;code&gt;key&lt;/code&gt; removed. If the &lt;code&gt;key&lt;/code&gt; is not present in the keyword list, &lt;code&gt;{default, keyword_list}&lt;/code&gt; is returned.</source>
          <target state="translated">最初の要素が &lt;code&gt;key&lt;/code&gt; の最初の値であり、2番目の要素がキーワードリストで、 &lt;code&gt;key&lt;/code&gt; 関連付けられているすべてのエントリが削除されたタプルを返します。 &lt;code&gt;key&lt;/code&gt; がキーワードリストにない場合、 &lt;code&gt;{default, keyword_list}&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="60c44e4aa381e2f2476e80a74b5488ef1fbe7e6d" translate="yes" xml:space="preserve">
          <source>It returns a tuple with the configuration and the imported paths.</source>
          <target state="translated">設定とインポートされたパスを含むタプルを返します。</target>
        </trans-unit>
        <trans-unit id="1c6d5c298bfea7e740d50d208c24e0a7cb35ea15" translate="yes" xml:space="preserve">
          <source>It returns a two-element tuple with two lists of elements. The element that triggered the split is part of the second list.</source>
          <target state="translated">これは、2つの要素のリストを持つ2つの要素タプルを返します。分割のきっかけとなった要素は、2 番目のリストの一部となります。</target>
        </trans-unit>
        <trans-unit id="3fdf4c8d7953d6b126d5564a13f2c8bce040ab31" translate="yes" xml:space="preserve">
          <source>It returns the &lt;code&gt;mix.exs&lt;/code&gt; file, the lock manifest, and all config files in the &lt;code&gt;config&lt;/code&gt; directory that do not start with a leading period (for example, &lt;code&gt;.my_config.exs&lt;/code&gt;).</source>
          <target state="translated">これは、 &lt;code&gt;mix.exs&lt;/code&gt; ファイル、ロックマニフェスト、および &lt;code&gt;config&lt;/code&gt; ディレクトリ内のすべての構成ファイル（たとえば、 &lt;code&gt;.my_config.exs&lt;/code&gt; ）を返します。</target>
        </trans-unit>
        <trans-unit id="fe0d0c5e22a39b889893a15373fe9daae0aa2349" translate="yes" xml:space="preserve">
          <source>It returns the ast if it succeeds, raises an exception otherwise. The exception is a &lt;a href=&quot;tokenmissingerror&quot;&gt;&lt;code&gt;TokenMissingError&lt;/code&gt;&lt;/a&gt; in case a token is missing (usually because the expression is incomplete), &lt;a href=&quot;syntaxerror&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="translated">成功するとastを返し、それ以外の場合は例外を発生させます。例外は&lt;a href=&quot;tokenmissingerror&quot;&gt; &lt;code&gt;TokenMissingError&lt;/code&gt; &lt;/a&gt;、（式が不完全であるため、通常は）トークンが欠落している場合&lt;a href=&quot;syntaxerror&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt;さもなければ。</target>
        </trans-unit>
        <trans-unit id="0ddb2097e9b6c67aac6845519cb92def4ddcd595" translate="yes" xml:space="preserve">
          <source>It returns the deleted attribute value (or &lt;code&gt;nil&lt;/code&gt; if nothing was set).</source>
          <target state="translated">削除された属性値（何も設定されていない場合は &lt;code&gt;nil&lt;/code&gt; ）を返します。</target>
        </trans-unit>
        <trans-unit id="02c714a4ea003b7686a6af1daae5b12a336be932" translate="yes" xml:space="preserve">
          <source>It returns the names of the compiled modules.</source>
          <target state="translated">コンパイルされたモジュールの名前を返します。</target>
        </trans-unit>
        <trans-unit id="ae123871707a2b6de82ed2c56ead673cc4cadc39" translate="yes" xml:space="preserve">
          <source>It returns the new map of compiler options.</source>
          <target state="translated">コンパイラオプションの新しいマップを返します。</target>
        </trans-unit>
        <trans-unit id="766f8a3783379e82be75e43a3208cd1da372d673" translate="yes" xml:space="preserve">
          <source>It returns the number of Gregorian days between the dates. Only &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; structs that follow the same or compatible calendars can be compared this way. If two calendars are not compatible, it will raise.</source>
          <target state="translated">日付間のグレゴリオ日数を返します。この方法で比較できるのは、同じまたは互換性のあるカレンダーに従う&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;構造体だけです。2つのカレンダーに互換性がない場合は発生します。</target>
        </trans-unit>
        <trans-unit id="b6852c5d07c3b9783a2c197a51ccbe9ab48fc88a" translate="yes" xml:space="preserve">
          <source>It returns the same as the built-in &lt;code&gt;node()&lt;/code&gt;.</source>
          <target state="translated">組み込みの &lt;code&gt;node()&lt;/code&gt; と同じ結果を返します。</target>
        </trans-unit>
        <trans-unit id="d85ecab1cba97830aafe60c7db9bcdf6c281beb4" translate="yes" xml:space="preserve">
          <source>It returns the term stored in the documentation chunk in the format defined by &lt;a href=&quot;http://erlang.org/eep/eeps/eep-0048.html&quot;&gt;EEP 48&lt;/a&gt; or &lt;code&gt;{:error, reason}&lt;/code&gt; if the chunk is not available.</source>
          <target state="translated">これは、によって定義された形式のドキュメントチャンクに格納されている用語返し&lt;a href=&quot;http://erlang.org/eep/eeps/eep-0048.html&quot;&gt;EEP 48&lt;/a&gt;または &lt;code&gt;{:error, reason}&lt;/code&gt; チャンクが利用できない場合が。</target>
        </trans-unit>
        <trans-unit id="3386214fb50a8516bbdf778fc1cd94340c90a3d8" translate="yes" xml:space="preserve">
          <source>It returns the updated version of the protocol bytecode. If the first element of the tuple is &lt;code&gt;:ok&lt;/code&gt;, it means the protocol was consolidated.</source>
          <target state="translated">プロトコルバイトコードの更新バージョンを返します。タプルの最初の要素が &lt;code&gt;:ok&lt;/code&gt; の場合、プロトコルが統合されたことを意味します。</target>
        </trans-unit>
        <trans-unit id="c027793c4fcbf7f7be6aed911c23cf2d476fffe0" translate="yes" xml:space="preserve">
          <source>It returns:</source>
          <target state="translated">返ってきます。</target>
        </trans-unit>
        <trans-unit id="7e69f73c47c2d4297cd900ce85c28a9c948c1b19" translate="yes" xml:space="preserve">
          <source>It seems we are ready to go! We will use the interactive shell quite a lot in the next chapters to get a bit more familiar with the language constructs and basic types, starting in the next chapter.</source>
          <target state="translated">これで準備ができたようです! 次の章では、次の章から始まる言語の構造や基本的な型についてもう少し詳しく知るために、対話型シェルをかなり多く使うことになるでしょう。</target>
        </trans-unit>
        <trans-unit id="7b61a10d3b18f5d9c1eaf6bc0cc59326c9f15aec" translate="yes" xml:space="preserve">
          <source>It should return &lt;code&gt;{:ok, boolean}&lt;/code&gt; if you can check the membership of a given element in the &lt;code&gt;enumerable&lt;/code&gt; with &lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt; without traversing the whole enumerable.</source>
          <target state="translated">&lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; &lt;/a&gt;全体を走査せずに、 &lt;code&gt;enumerable&lt;/code&gt; 特定の要素のメンバーシップを=== / 2で確認できる場合は &lt;code&gt;{:ok, boolean}&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="4eda1ce345c7961b8d8eaacacd3842665d668e46" translate="yes" xml:space="preserve">
          <source>It should return &lt;code&gt;{:ok, count}&lt;/code&gt; if you can count the number of elements in the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; の要素数をカウントできる場合は &lt;code&gt;{:ok, count}&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="b69c5b898ed0b1df84697cb05eb4de3925bc611c" translate="yes" xml:space="preserve">
          <source>It should return &lt;code&gt;{:ok, size, slicing_fun}&lt;/code&gt; if the &lt;code&gt;enumerable&lt;/code&gt; has a known bound and can access a position in the &lt;code&gt;enumerable&lt;/code&gt; without traversing all previous elements.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; に既知の境界があり、以前のすべての要素を走査せずに &lt;code&gt;enumerable&lt;/code&gt; 位置にアクセスできる場合は &lt;code&gt;{:ok, size, slicing_fun}&lt;/code&gt; を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="c6ec473d814fbb944cadb6ef7ecbd0b54ffb7903" translate="yes" xml:space="preserve">
          <source>It simply prints messages to stdio and stderr.</source>
          <target state="translated">これは、単に stdio と stderr にメッセージを表示するだけです。</target>
        </trans-unit>
        <trans-unit id="c2bf5d9b723f91bde75bc41d3f4bce002f449711" translate="yes" xml:space="preserve">
          <source>It simply returns a charlist without escaping characters and without interpolations.</source>
          <target state="translated">これは、単に文字をエスケープせず、補間せずに文字リストを返します。</target>
        </trans-unit>
        <trans-unit id="c84e40ba905fa3630ef387da0561b471023546c1" translate="yes" xml:space="preserve">
          <source>It simply returns a string without escaping characters and without interpolations.</source>
          <target state="translated">これは、単に文字をエスケープせず、補間せずに文字列を返します。</target>
        </trans-unit>
        <trans-unit id="6ac5bb057ce19bda73528c6e24000df9f4d91f41" translate="yes" xml:space="preserve">
          <source>It simply runs the compilers registered in your project and returns a tuple with the compilation status and a list of diagnostics.</source>
          <target state="translated">プロジェクトに登録されているコンパイラを実行し、コンパイルステータスと診断のリストを含むタプルを返します。</target>
        </trans-unit>
        <trans-unit id="16d9b6683d66aba15c717ff1071205cd0f26c442" translate="yes" xml:space="preserve">
          <source>It supports the following options:</source>
          <target state="translated">以下のオプションをサポートしています。</target>
        </trans-unit>
        <trans-unit id="a2e490ec4460253855b541489b49bac1f8ad8cbb" translate="yes" xml:space="preserve">
          <source>It takes an &lt;code&gt;enumerable&lt;/code&gt; with elements being two-element tuples and returns a tuple with two lists, each of which is formed by the first and second element of each tuple, respectively.</source>
          <target state="translated">要素が2要素のタプルである &lt;code&gt;enumerable&lt;/code&gt; を取り、2つのリストを持つタプルを返します。各リストは、各タプルの最初の要素と2番目の要素によってそれぞれ形成されます。</target>
        </trans-unit>
        <trans-unit id="65267298def1e5c3f27ba97cc79959f0ec4e9b43" translate="yes" xml:space="preserve">
          <source>It takes the &lt;code&gt;kind&lt;/code&gt; spilled by &lt;code&gt;catch&lt;/code&gt; as an argument and normalizes only &lt;code&gt;:error&lt;/code&gt;, returning the untouched payload for others.</source>
          <target state="translated">これは、 &lt;code&gt;catch&lt;/code&gt; によってこぼれた &lt;code&gt;kind&lt;/code&gt; 引数として取り、 &lt;code&gt;:error&lt;/code&gt; のみを正規化して、他の人にそのままのペイロードを返します。</target>
        </trans-unit>
        <trans-unit id="017d4c0f52ec05a16013c629cf13480b366963be" translate="yes" xml:space="preserve">
          <source>It uses &lt;a href=&quot;mix.tasks.xref&quot;&gt;&lt;code&gt;mix xref&lt;/code&gt;&lt;/a&gt; to check if any remote call does not exist or is deprecated, and emits warnings in such cases. This task does not show deprecated local calls (a call to a deprecated function or macro in the same module) nor calls to deprecated functionality in Elixir itself.</source>
          <target state="translated">リモート呼び出しが存在しないか非推奨であるかどうかを確認するために&lt;a href=&quot;mix.tasks.xref&quot;&gt; &lt;code&gt;mix xref&lt;/code&gt; &lt;/a&gt;を使用し、そのような場合は警告を発します。このタスクでは、非推奨のローカル呼び出し（同じモジュール内の非推奨の関数またはマクロの呼び出し）も、Elixir自体の非推奨の機能の呼び出しも表示されません。</target>
        </trans-unit>
        <trans-unit id="14a6eb5a7e6cf2ff92914f35b6fcd693c9459181" translate="yes" xml:space="preserve">
          <source>It uses the given &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; documents as surrounding and the separator document &lt;code&gt;separator&lt;/code&gt; to separate items in &lt;code&gt;docs&lt;/code&gt;. If all entries in the collection are simple documents (texts or strings), then this function attempts to put as much as possible on the same line. If they are not simple, only one entry is shown per line if they do not fit.</source>
          <target state="translated">これは、所与の使用 &lt;code&gt;left&lt;/code&gt; と &lt;code&gt;right&lt;/code&gt; 周囲と分離文書として文書を &lt;code&gt;separator&lt;/code&gt; で別のアイテムに &lt;code&gt;docs&lt;/code&gt; 。コレクションのすべてのエントリが単純なドキュメント（テキストまたは文字列）である場合、この関数は同じ行にできるだけ多くの行を入れようとします。単純でない場合、収まらない場合は、1行に1つのエントリのみが表示されます。</target>
        </trans-unit>
        <trans-unit id="359c8a3a80dc42f4d09ef45dc62e03c2a4526a01" translate="yes" xml:space="preserve">
          <source>It uses the shortest representation according to algorithm described in &quot;Printing Floating-Point Numbers Quickly and Accurately&quot; in Proceedings of the SIGPLAN '96 Conference on Programming Language Design and Implementation.</source>
          <target state="translated">これは、SIGPLAN '96 Conference on Programming Language Design and Implementation の Proceedings of the SIGPLAN '96 Conference on Programming Language Design and Implementation の &quot;Printing Floating-Point Numbers Quickly and Accurately&quot; に記載されているアルゴリズムに従った最短表現を使用しています。</target>
        </trans-unit>
        <trans-unit id="226d68525abc4cd650686c46c4c3000914e7ba94" translate="yes" xml:space="preserve">
          <source>It will also append an &lt;a href=&quot;io.ansi#reset/0&quot;&gt;&lt;code&gt;IO.ANSI.reset/0&lt;/code&gt;&lt;/a&gt; to the chardata when a conversion is performed. If you don't want this behaviour, use &lt;a href=&quot;#format_fragment/2&quot;&gt;&lt;code&gt;format_fragment/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">また、変換が実行されるときに、chardataに&lt;a href=&quot;io.ansi#reset/0&quot;&gt; &lt;code&gt;IO.ANSI.reset/0&lt;/code&gt; &lt;/a&gt;を追加します。この動作を望まない場合は、&lt;a href=&quot;#format_fragment/2&quot;&gt; &lt;code&gt;format_fragment/2&lt;/code&gt; を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="3d625ecd25a91e55e3a68933b351320ae362d970" translate="yes" xml:space="preserve">
          <source>It will also unload all &lt;code&gt;:included_applications&lt;/code&gt;. Note that the function does not purge the application modules.</source>
          <target state="translated">また、すべての &lt;code&gt;:included_applications&lt;/code&gt; をアンロードします。この関数はアプリケーションモジュールを削除しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="84aa5327df0b5a9bb286871a09b1bb5335320dee" translate="yes" xml:space="preserve">
          <source>It will raise &lt;a href=&quot;compileerror&quot;&gt;&lt;code&gt;CompileError&lt;/code&gt;&lt;/a&gt; if the struct is not available.</source>
          <target state="translated">これは、発生します&lt;a href=&quot;compileerror&quot;&gt; &lt;code&gt;CompileError&lt;/code&gt; を&lt;/a&gt;構造体が使用できない場合。</target>
        </trans-unit>
        <trans-unit id="4e6ad31346e231231ef72c5f43225ffd3c66f70d" translate="yes" xml:space="preserve">
          <source>It will return the integer with the given unit, according to &lt;a href=&quot;system#convert_time_unit/3&quot;&gt;&lt;code&gt;System.convert_time_unit/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;system#convert_time_unit/3&quot;&gt; &lt;code&gt;System.convert_time_unit/3&lt;/code&gt; に&lt;/a&gt;よると、指定された単位の整数を返します。</target>
        </trans-unit>
        <trans-unit id="a600be691bf00b4e32fb62041ceec8dd63d79b4c" translate="yes" xml:space="preserve">
          <source>It works with improper lists.</source>
          <target state="translated">不適切なリストでも動作します。</target>
        </trans-unit>
        <trans-unit id="6681def299dea9fa997a7ef9b6707d61767cc884" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to implement protocols for all Elixir data types:</source>
          <target state="translated">すべてのElixirデータ型のプロトコルを実装することが可能です：</target>
        </trans-unit>
        <trans-unit id="999db6f61bff83218a31d16026d001272eea2261" translate="yes" xml:space="preserve">
          <source>It's also possible to pass a block to the &lt;a href=&quot;#if/2&quot;&gt;&lt;code&gt;if/2&lt;/code&gt;&lt;/a&gt; macro. The first example above would be translated to:</source>
          <target state="translated">ブロックを&lt;a href=&quot;#if/2&quot;&gt; &lt;code&gt;if/2&lt;/code&gt; &lt;/a&gt;マクロに渡すことも可能です。上記の最初の例は次のように翻訳されます。</target>
        </trans-unit>
        <trans-unit id="cd7290dd76f46aa64bdbf468714a16cc5352938b" translate="yes" xml:space="preserve">
          <source>It's important to note that it returns the given &lt;code&gt;item&lt;/code&gt; unchanged. This makes it possible to &quot;spy&quot; on values by inserting an &lt;a href=&quot;io#inspect/2&quot;&gt;&lt;code&gt;IO.inspect/2&lt;/code&gt;&lt;/a&gt; call almost anywhere in your code, for example, in the middle of a pipeline.</source>
          <target state="translated">指定された &lt;code&gt;item&lt;/code&gt; 変更せずに返すことに注意することが重要です。これにより、たとえばパイプラインの途中など、コードのほぼどこにでも&lt;a href=&quot;io#inspect/2&quot;&gt; &lt;code&gt;IO.inspect/2&lt;/code&gt; &lt;/a&gt;呼び出しを挿入して、値を「スパイ」することができます。</target>
        </trans-unit>
        <trans-unit id="55e677bb7fe63cf491955ddb64be33b944554c67" translate="yes" xml:space="preserve">
          <source>It's often useful to have the AST for such a pipeline as a list of function applications. This function does exactly that:</source>
          <target state="translated">このようなパイプラインのためのASTを関数アプリケーションのリストとして持っていると便利なことがよくあります。この関数はまさにそれを行います。</target>
        </trans-unit>
        <trans-unit id="b81b47272fec763e900d18ba6a1da4a3098cd954" translate="yes" xml:space="preserve">
          <source>Italic: on. Not widely supported. Sometimes treated as inverse.</source>
          <target state="translated">イタリック体:オン。広くはサポートされていない。反転として扱われることもある。</target>
        </trans-unit>
        <trans-unit id="0418eaaa46e9aed5bab2054a496fec5d581658a8" translate="yes" xml:space="preserve">
          <source>Iterates over the &lt;code&gt;enumerable&lt;/code&gt; and invokes &lt;code&gt;fun&lt;/code&gt; on each element. When an invocation of &lt;code&gt;fun&lt;/code&gt; returns a falsy value (&lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;) iteration stops immediately and &lt;code&gt;false&lt;/code&gt; is returned. In all other cases &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; オブジェクトを反復処理し、各要素で &lt;code&gt;fun&lt;/code&gt; を呼び出します。 &lt;code&gt;fun&lt;/code&gt; を呼び出すと &lt;code&gt;false&lt;/code&gt; 値（falseまたは &lt;code&gt;nil&lt;/code&gt; ）が返されると、反復がすぐに停止し、 &lt;code&gt;false&lt;/code&gt; が返されます。その他の場合はすべて &lt;code&gt;true&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="c421120e85b180763b71f08518f3f5d485454d1b" translate="yes" xml:space="preserve">
          <source>Iterates over the &lt;code&gt;enumerable&lt;/code&gt; and invokes &lt;code&gt;fun&lt;/code&gt; on each element. When an invocation of &lt;code&gt;fun&lt;/code&gt; returns a truthy value (neither &lt;code&gt;false&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt;) iteration stops immediately and &lt;code&gt;true&lt;/code&gt; is returned. In all other cases &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; オブジェクトを反復処理し、各要素で &lt;code&gt;fun&lt;/code&gt; を呼び出します。 &lt;code&gt;fun&lt;/code&gt; の呼び出しが真の値（ &lt;code&gt;false&lt;/code&gt; でも &lt;code&gt;nil&lt;/code&gt; でもない）を返すと、反復は直ちに停止し、 &lt;code&gt;true&lt;/code&gt; が返されます。その他の場合はすべて &lt;code&gt;false&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="1bd3db045f018e16696466f5acea3521773d3a53" translate="yes" xml:space="preserve">
          <source>Its fields are:</source>
          <target state="translated">その分野は</target>
        </trans-unit>
        <trans-unit id="2e084df8c1f3d9f015ea6c2b99c3b679805e965a" translate="yes" xml:space="preserve">
          <source>Joins a list of paths.</source>
          <target state="translated">パスのリストを結合します。</target>
        </trans-unit>
        <trans-unit id="515c03874ab491d886e1d1d7b31a372bcd15aaca" translate="yes" xml:space="preserve">
          <source>Joins the given &lt;code&gt;enumerable&lt;/code&gt; into a binary using &lt;code&gt;joiner&lt;/code&gt; as a separator.</source>
          <target state="translated">&lt;code&gt;joiner&lt;/code&gt; をセパレータとして使用して、指定された &lt;code&gt;enumerable&lt;/code&gt; をバイナリに結合します。</target>
        </trans-unit>
        <trans-unit id="f5648a991099408fa47ca83f65efd1693d2a9815" translate="yes" xml:space="preserve">
          <source>Joins two paths.</source>
          <target state="translated">2つの道をつなぐ。</target>
        </trans-unit>
        <trans-unit id="48d488d22b9c11a34b40d4f43a44d7ca15f5548d" translate="yes" xml:space="preserve">
          <source>Just like &lt;a href=&quot;#runtime_info/0&quot;&gt;&lt;code&gt;runtime_info/0&lt;/code&gt;&lt;/a&gt;, except accepts topic or a list of topics. E.g. topic &lt;code&gt;:applications&lt;/code&gt; will list the applications loaded.</source>
          <target state="translated">&lt;a href=&quot;#runtime_info/0&quot;&gt; &lt;code&gt;runtime_info/0&lt;/code&gt; &lt;/a&gt;と同じですが、トピックまたはトピックのリストを受け入れます。たとえば、トピック &lt;code&gt;:applications&lt;/code&gt; はロードされたアプリケーションをリストします。</target>
        </trans-unit>
        <trans-unit id="e51db24d55d9857675a12f93a5ceb2ca695225d3" translate="yes" xml:space="preserve">
          <source>Keep in mind &lt;code&gt;@enforce_keys&lt;/code&gt; is a simple compile-time guarantee to aid developers when building structs. It is not enforced on updates and it does not provide any sort of value-validation.</source>
          <target state="translated">&lt;code&gt;@enforce_keys&lt;/code&gt; は、構造体を構築するときに開発者を支援する単純なコンパイル時の保証であることを覚えておいてください。これは更新時に強制されず、いかなる種類の値検証も提供しません。</target>
        </trans-unit>
        <trans-unit id="47ce96738f59dcbe1277607a7b62401517ee71a9" translate="yes" xml:space="preserve">
          <source>Keep in mind errors in guards do not leak but simply make the guard fail:</source>
          <target state="translated">ガードのエラーは漏れるのではなく、単にガードを失敗させるだけなので注意しましょう。</target>
        </trans-unit>
        <trans-unit id="019b3d215759f9f759de0ba07f898008173c2b71" translate="yes" xml:space="preserve">
          <source>Keep in mind reversing the same string twice does not necessarily yield the original string:</source>
          <target state="translated">同じ文字列を2回反転させても、必ずしも元の文字列が得られるわけではないことを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="11a21ef1004b00088384d2386c08e0ddfc5a422c" translate="yes" xml:space="preserve">
          <source>Keep in mind single-quoted and double-quoted representations are not equivalent in Elixir as they are represented by different types:</source>
          <target state="translated">Elixirでは、単一引用符で囲まれた表現と二重引用符で囲まれた表現は、異なるタイプで表現されているため、等価ではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="31048d175f380df1b961d6b1c2e7ff99e30846d1" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;a href=&quot;iex#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; runs in the caller process, blocking the caller during the evaluation cycle. The caller process can be freed by calling &lt;a href=&quot;iex.helpers#respawn/0&quot;&gt;&lt;code&gt;respawn/0&lt;/code&gt;&lt;/a&gt;, which starts a new IEx evaluation cycle, letting this one go:</source>
          <target state="translated">&lt;a href=&quot;iex#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt;は呼び出し元プロセスで実行され、評価サイクル中に呼び出し元をブロックすることに注意してください。呼び出し元のプロセスは、&lt;a href=&quot;iex.helpers#respawn/0&quot;&gt; &lt;code&gt;respawn/0&lt;/code&gt; を&lt;/a&gt;呼び出すことで解放できます。これにより、新しいIEx評価サイクルが開始され、これが実行されます。</target>
        </trans-unit>
        <trans-unit id="17dab74a9a2d31002a8d8b98ab8f2a1e7c69175a" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;assert&lt;/code&gt; does not change its semantics based on the expression. In other words, the expression is still required to return a truthy value. For example, the following will fail:</source>
          <target state="translated">&lt;code&gt;assert&lt;/code&gt; は式に基づいてセマンティクスを変更しないことに注意してください。つまり、式は真の値を返す必要があります。たとえば、次は失敗します。</target>
        </trans-unit>
        <trans-unit id="bb7a4e2f437f89496ebbe986e5235a9983fd7b7c" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;filter&lt;/code&gt; is not capable of filtering and transforming an element at the same time. If you would like to do so, consider using &lt;a href=&quot;#flat_map/2&quot;&gt;&lt;code&gt;flat_map/2&lt;/code&gt;&lt;/a&gt;. For example, if you want to convert all strings that represent an integer and discard the invalid one in one pass:</source>
          <target state="translated">&lt;code&gt;filter&lt;/code&gt; は、要素のフィルタリングと変換を同時に行うことができないことに注意してください。そうしたい場合は、&lt;a href=&quot;#flat_map/2&quot;&gt; &lt;code&gt;flat_map/2&lt;/code&gt; の&lt;/a&gt;使用を検討してください。たとえば、整数を表すすべての文字列を変換し、無効な文字列を1回のパスで破棄する場合は、次のようにします。</target>
        </trans-unit>
        <trans-unit id="efcc18a9b0bcb482431019e0321fb20f799d7ca1" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;refute&lt;/code&gt; does not change the semantics of the given expression. In other words, the following will fail:</source>
          <target state="translated">&lt;code&gt;refute&lt;/code&gt; は、与えられた式の意味を変更しないことに注意してください。つまり、以下は失敗します。</target>
        </trans-unit>
        <trans-unit id="2711b72cad7dcad995d5896fe00c416e309a1ef1" translate="yes" xml:space="preserve">
          <source>Keep in mind that all tests are included by default, so unless they are excluded first, the &lt;code&gt;include&lt;/code&gt; option has no effect.</source>
          <target state="translated">すべてのテストはデフォルトで含まれるため、最初に除外しない限り、 &lt;code&gt;include&lt;/code&gt; オプションは効果がないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="681ff07e085798bf6140c0e48749d06c2f822db5" translate="yes" xml:space="preserve">
          <source>Keep in mind that you can always invoke the help task to list all available tasks:</source>
          <target state="translated">利用可能なすべてのタスクをリストアップするために、常にヘルプタスクを呼び出すことができることを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="725b47d6b2cb8b5dc76a5170928fd278550f1b34" translate="yes" xml:space="preserve">
          <source>Keep in mind that, by convention, whenever the inspected value starts with &lt;code&gt;#&lt;/code&gt;, it is representing a data structure in non-valid Elixir syntax. This means the inspect protocol is not reversible as information may be lost along the way:</source>
          <target state="translated">慣例により、検査された値が &lt;code&gt;#&lt;/code&gt; で始まる場合は常に、無効なElixir構文でデータ構造を表していることに注意してください。これは、情報が途中で失われる可能性があるため、検査プロトコルは元に戻せないことを意味します。</target>
        </trans-unit>
        <trans-unit id="b83288ec921378850bb3f1fa7bae00089f1eb1e1" translate="yes" xml:space="preserve">
          <source>Keep in mind that, in order to know if an element is unique or not, this function needs to store all unique values emitted by the stream. Therefore, if the stream is infinite, the number of elements stored will grow infinitely, never being garbage-collected.</source>
          <target state="translated">要素が一意かどうかを知るためには、この関数はストリームから放出されるすべての一意な値を格納する必要があることを覚えておいてください。そのため、ストリームが無限大の場合、格納される要素の数は無限に増え、決してゴミとして収集されることはありません。</target>
        </trans-unit>
        <trans-unit id="84d731972e42a11f20590eec71a88a83f6bff7df" translate="yes" xml:space="preserve">
          <source>Keep in mind that, regardless of how the task created with &lt;code&gt;async_nolink&lt;/code&gt; terminates, the caller's process will always receive a &lt;code&gt;:DOWN&lt;/code&gt; message with the same &lt;code&gt;ref&lt;/code&gt; value that is held by the task struct. If the task terminates normally, the reason in the &lt;code&gt;:DOWN&lt;/code&gt; message will be &lt;code&gt;:normal&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;async_nolink&lt;/code&gt; で作成されたタスクがどのように終了するかに関係なく、呼び出し元のプロセスは常に、タスク構造体によって保持されている同じ &lt;code&gt;ref&lt;/code&gt; 値を持つ &lt;code&gt;:DOWN&lt;/code&gt; メッセージを受信することに注意してください。タスクが正常に終了した場合、 &lt;code&gt;:DOWN&lt;/code&gt; メッセージの理由は &lt;code&gt;:normal&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="43e72793cf5cb6c7b1a0ca2e28a8c6ee6025d9c8" translate="yes" xml:space="preserve">
          <source>Keep in mind the &lt;a href=&quot;#open/0&quot;&gt;&lt;code&gt;open/0&lt;/code&gt;&lt;/a&gt; location may not exist when prying precompiled source code, such as Elixir itself.</source>
          <target state="translated">Elixir自体などのプリコンパイルされたソースコードを&lt;a href=&quot;#open/0&quot;&gt; &lt;code&gt;open/0&lt;/code&gt; &lt;/a&gt;ときは、open / 0の場所が存在しない可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="860e4edfbd6c5d2c7567e3d117fbea1f6f0c0f3d" translate="yes" xml:space="preserve">
          <source>Keep in mind the &lt;a href=&quot;#whereami/1&quot;&gt;&lt;code&gt;whereami/1&lt;/code&gt;&lt;/a&gt; location may not exist when prying precompiled source code, such as Elixir itself.</source>
          <target state="translated">Elixir自体などのプリコンパイルされたソースコードを&lt;a href=&quot;#whereami/1&quot;&gt; &lt;code&gt;whereami/1&lt;/code&gt; &lt;/a&gt;場合、whereami / 1の場所が存在しない可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5cf33f85cbcbea5e44750e3785093cd27fc2107f" translate="yes" xml:space="preserve">
          <source>Keep in mind the location may not exist when opening precompiled source code.</source>
          <target state="translated">プリコンパイルされたソースコードを開く際には、その場所が存在しない可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9d158165f2fc0a37c72c714056603422cfd15842" translate="yes" xml:space="preserve">
          <source>Keep in mind this issue also shows up when performing &quot;rolling upgrades&quot; with agents. By rolling upgrades we mean the following situation: you wish to deploy a new version of your software by &lt;em&gt;shutting down&lt;/em&gt; some of your nodes and replacing them with nodes running a new version of the software. In this setup, part of your environment will have one version of a given module and the other part another version (the newer one) of the same module.</source>
          <target state="translated">この問題は、エージェントで「ローリングアップグレード」を実行するときにも発生することに注意してください。ローリングアップグレードとは、次の状況を意味します。一部のノードを&lt;em&gt;シャットダウンし&lt;/em&gt;、新しいバージョンのソフトウェアを実行しているノードに置き換えることによって、新しいバージョンのソフトウェアを展開する場合。このセットアップでは、環境の一部に特定のモジュールの1つのバージョンがあり、他の部分には同じモジュールの別のバージョン（新しいバージョン）があります。</target>
        </trans-unit>
        <trans-unit id="f0156c07b778f553fcac957532e2ebb3cd9d736c" translate="yes" xml:space="preserve">
          <source>Keep the first paragraph of the documentation concise and simple, typically one-line. Tools like &lt;a href=&quot;https://github.com/elixir-lang/ex_doc/&quot;&gt;ExDoc&lt;/a&gt; use the first line to generate a summary.</source>
          <target state="translated">ドキュメントの最初の段落は簡潔で単純なものにします。通常は1行にします。&lt;a href=&quot;https://github.com/elixir-lang/ex_doc/&quot;&gt;ExDoc&lt;/a&gt;などのツールは、最初の行を使用して要約を生成します。</target>
        </trans-unit>
        <trans-unit id="b89ed6c1e4d3aad0e25530664c1434bb7a8e1390" translate="yes" xml:space="preserve">
          <source>Keeping user's formatting</source>
          <target state="translated">ユーザーのフォーマットを維持する</target>
        </trans-unit>
        <trans-unit id="74808d3df030e992e7b9444241625147986487c1" translate="yes" xml:space="preserve">
          <source>Kernel</source>
          <target state="translated">Kernel</target>
        </trans-unit>
        <trans-unit id="b4d54f6ec686d8eb5175caf8d65ba08cfce6e603" translate="yes" xml:space="preserve">
          <source>Kernel functions</source>
          <target state="translated">カーネル機能</target>
        </trans-unit>
        <trans-unit id="aeaeca0ac29205e969d2b8226d57305ccdd9354c" translate="yes" xml:space="preserve">
          <source>Kernel.ParallelCompiler</source>
          <target state="translated">Kernel.ParallelCompiler</target>
        </trans-unit>
        <trans-unit id="397b329c326c86881a0889837339130cb1378ece" translate="yes" xml:space="preserve">
          <source>Kernel.SpecialForms</source>
          <target state="translated">Kernel.SpecialForms</target>
        </trans-unit>
        <trans-unit id="c8ca7c123549a6d988a750c2deb07a14cc7d13fe" translate="yes" xml:space="preserve">
          <source>Key and value in each tuple will be binaries and will be percent-unescaped.</source>
          <target state="translated">各タプルのキーと値はバイナリとなり、パーセンテージでエスケープされます。</target>
        </trans-unit>
        <trans-unit id="fa0ccdd4ef791d750570b7806e67eebc94ec0038" translate="yes" xml:space="preserve">
          <source>Key-based access to data structures.</source>
          <target state="translated">データ構造へのキーベースのアクセス。</target>
        </trans-unit>
        <trans-unit id="156eb45dfef4d621a4d1c63e18132edae922c7ad" translate="yes" xml:space="preserve">
          <source>Key-value pairs in a map do not follow any order (that's why the printed map in the example above has a different order than the map that was created).</source>
          <target state="translated">マップ内のキーと値のペアは、どのような順序にも従いません(そのため、上の例の印刷されたマップは、作成されたマップとは異なる順序になっています)。</target>
        </trans-unit>
        <trans-unit id="74018238351de8a4b5f41ef51f98e3f2c94d5837" translate="yes" xml:space="preserve">
          <source>KeyError</source>
          <target state="translated">KeyError</target>
        </trans-unit>
        <trans-unit id="15dcfdc21056a09847eba4ff304e968ed3eb85e6" translate="yes" xml:space="preserve">
          <source>KeyError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">KeyError &lt;small&gt;例外&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9feb5a2ad29c5ac9a472aae0705f0b36f56f288c" translate="yes" xml:space="preserve">
          <source>Keys and values can be any term that implements the &lt;a href=&quot;string.chars&quot;&gt;&lt;code&gt;String.Chars&lt;/code&gt;&lt;/a&gt; protocol with the exception of lists, which are explicitly forbidden.</source>
          <target state="translated">キーと値は、明示的に禁止されているリストを除いて、&lt;a href=&quot;string.chars&quot;&gt; &lt;code&gt;String.Chars&lt;/code&gt; &lt;/a&gt;プロトコルを実装する任意の用語にすることができます。</target>
        </trans-unit>
        <trans-unit id="c871f27e8a5b87eb6c4a04f8a42a4f6e2ea2d87a" translate="yes" xml:space="preserve">
          <source>Keys are ordered, as specified by the developer.</source>
          <target state="translated">キーは、開発者が指定した通りに順番に並べられています。</target>
        </trans-unit>
        <trans-unit id="405b7423934af77dcf3ba5a20687064207764857" translate="yes" xml:space="preserve">
          <source>Keys can be given more than once.</source>
          <target state="translated">鍵は複数回渡すことができます。</target>
        </trans-unit>
        <trans-unit id="c61607fe5f12600b764431ebe5f8131aa4311b82" translate="yes" xml:space="preserve">
          <source>Keys for which there are no entries in &lt;code&gt;map&lt;/code&gt; are ignored.</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; エントリがないキーは無視されます。</target>
        </trans-unit>
        <trans-unit id="4694e757bfed2949bf57d46a766c250bec95d827" translate="yes" xml:space="preserve">
          <source>Keys for which there are no entries in the keyword list are ignored.</source>
          <target state="translated">キーワードリストにエントリがないキーは無視されます。</target>
        </trans-unit>
        <trans-unit id="5718a5ffdcdd81ef356ce973873d2a2560146789" translate="yes" xml:space="preserve">
          <source>Keys in maps can be accessed through some of the functions in this module (such as &lt;a href=&quot;map#get/3&quot;&gt;&lt;code&gt;Map.get/3&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;map#fetch/2&quot;&gt;&lt;code&gt;Map.fetch/2&lt;/code&gt;&lt;/a&gt;) or through the &lt;code&gt;map[]&lt;/code&gt; syntax provided by the &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">マップ内のキーには、このモジュールの一部の関数（&lt;a href=&quot;map#get/3&quot;&gt; &lt;code&gt;Map.get/3&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;map#fetch/2&quot;&gt; &lt;code&gt;Map.fetch/2&lt;/code&gt; など&lt;/a&gt;）または&lt;a href=&quot;access&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;モジュールが提供する &lt;code&gt;map[]&lt;/code&gt; 構文を使用してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="b26620768b7c3d13232d03fbd0fd86edae1e9816" translate="yes" xml:space="preserve">
          <source>Keys in the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; that don't exist in the struct are automatically discarded. Note that keys must be atoms, as only atoms are allowed when defining a struct.</source>
          <target state="translated">構造体に存在しない&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; の&lt;/a&gt;キーは自動的に破棄されます。構造体を定義するときはアトムのみが許可されるため、キーはアトムでなければならないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="36720d74567b83e682047245f1678cc00bda2c58" translate="yes" xml:space="preserve">
          <source>Keys must be atoms.</source>
          <target state="translated">キーは原子でなければなりません。</target>
        </trans-unit>
        <trans-unit id="b946356405330b9605587c00c959f1283c7ebe0c" translate="yes" xml:space="preserve">
          <source>Keys must be atoms. Keys with &lt;code&gt;nil&lt;/code&gt; value are discarded, boolean values are converted to &lt;code&gt;--key&lt;/code&gt; or &lt;code&gt;--no-key&lt;/code&gt; (if the value is &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, respectively), and all other values are converted using &lt;a href=&quot;kernel#to_string/1&quot;&gt;&lt;code&gt;Kernel.to_string/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">キーはアトムでなければなりません。 &lt;code&gt;nil&lt;/code&gt; 値を持つキーは破棄され、ブール値は &lt;code&gt;--key&lt;/code&gt; または &lt;code&gt;--no-key&lt;/code&gt; （値がそれぞれ &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; の場合）に変換され、他のすべての値は&lt;a href=&quot;kernel#to_string/1&quot;&gt; &lt;code&gt;Kernel.to_string/1&lt;/code&gt; &lt;/a&gt;を使用して変換されます。</target>
        </trans-unit>
        <trans-unit id="a3926e039fd753c472f6e172496fda0574369261" translate="yes" xml:space="preserve">
          <source>Keyword</source>
          <target state="translated">Keyword</target>
        </trans-unit>
        <trans-unit id="7c134e1191dc5c44edbda73b442ec456eb6a71ed" translate="yes" xml:space="preserve">
          <source>Keyword lists</source>
          <target state="translated">キーワード一覧</target>
        </trans-unit>
        <trans-unit id="018e651a39aa7ad2ac64ac5eb40095fd4e7a830c" translate="yes" xml:space="preserve">
          <source>Keyword lists and maps</source>
          <target state="translated">キーワード一覧と地図</target>
        </trans-unit>
        <trans-unit id="392d9a31ec7b8f0bdc87d00f031b9e9bb8a73cb6" translate="yes" xml:space="preserve">
          <source>Keyword lists are always deep merged.</source>
          <target state="translated">キーワードリストは常にディープマージされています。</target>
        </trans-unit>
        <trans-unit id="4a8ca5bd3ccea7e0c7d15c67c55d6d098576d862" translate="yes" xml:space="preserve">
          <source>Keyword lists are always deep-merged.</source>
          <target state="translated">キーワードリストは常にディープマージされています。</target>
        </trans-unit>
        <trans-unit id="ac0300b9a6363d2ecf2708a6271a27720466a909" translate="yes" xml:space="preserve">
          <source>Keyword lists are important because they have three special characteristics:</source>
          <target state="translated">キーワードリストが重要なのは、3つの特徴があるからです。</target>
        </trans-unit>
        <trans-unit id="f46ce1d1d7d871768a2c62a23f7074163ee126aa" translate="yes" xml:space="preserve">
          <source>Keyword lists play an important role in the language and are quite common in many functions and macros. We will explore them a bit more in a future chapter. Now it is time to talk about &amp;ldquo;Binaries, strings, and char lists&amp;rdquo;.</source>
          <target state="translated">キーワードリストは言語で重要な役割を果たし、多くの関数とマクロで非常に一般的です。これらについては、今後の章でもう少し詳しく説明します。「バイナリ、文字列、文字リスト」について話す時が来ました。</target>
        </trans-unit>
        <trans-unit id="f530db58b3e5088dc7412c6d2298ba3f8456bdeb" translate="yes" xml:space="preserve">
          <source>Keywords</source>
          <target state="translated">Keywords</target>
        </trans-unit>
        <trans-unit id="1ceb47d1e9d15d89ef0224d7d1b562dcf30b3896" translate="yes" xml:space="preserve">
          <source>Keywords as last arguments</source>
          <target state="translated">最後の引数としてのキーワード</target>
        </trans-unit>
        <trans-unit id="c9a539f3ad19c8470b65f3028d300a7bb73e217a" translate="yes" xml:space="preserve">
          <source>Keywords in Elixir are a list of tuples of two elements where the first element is an atom. Using the base constructs, they would be represented as:</source>
          <target state="translated">Elixirのキーワードは、最初の要素が原子である2つの要素のタプルのリストです。基底構造を使用すると、それらは次のように表現されます。</target>
        </trans-unit>
        <trans-unit id="b05203cf89b60eb36609a1a8b7f3cafe0927486a" translate="yes" xml:space="preserve">
          <source>Known issues</source>
          <target state="translated">既知の問題</target>
        </trans-unit>
        <trans-unit id="c2843be90e040c2ace2b060340b9db40c6dbf4a3" translate="yes" xml:space="preserve">
          <source>Known tags</source>
          <target state="translated">既知のタグ</target>
        </trans-unit>
        <trans-unit id="9e805fe1256b3cb3351f4f100e6b23dfaed4c00e" translate="yes" xml:space="preserve">
          <source>Last time we fixed the race condition by replacing the asynchronous operation, a &lt;code&gt;cast&lt;/code&gt;, by a &lt;code&gt;call&lt;/code&gt;, which is synchronous. Unfortunately, the &lt;code&gt;handle_info/2&lt;/code&gt; callback we are using to receive the &lt;code&gt;:DOWN&lt;/code&gt; message and delete the entry from the ETS table does not have a synchronous equivalent. This time, we need to find a way to guarantee the registry has processed the &lt;code&gt;:DOWN&lt;/code&gt; notification sent when the bucket process terminated.</source>
          <target state="translated">前回は、私たちは、非同期操作を置き換えることにより、競合状態を固定 &lt;code&gt;cast&lt;/code&gt; することにより、 &lt;code&gt;call&lt;/code&gt; 同期しています、。残念ながら、 &lt;code&gt;:DOWN&lt;/code&gt; メッセージを受信してETSテーブルからエントリを削除するために使用している &lt;code&gt;handle_info/2&lt;/code&gt; コールバックには、同等の同期機能がありません。今回は、バケットプロセスの終了時に送信された &lt;code&gt;:DOWN&lt;/code&gt; 通知がレジストリで処理されたことを保証する方法を見つける必要があります。</target>
        </trans-unit>
        <trans-unit id="75acd19542cbb9fa88cdabbe078724acb812d8b1" translate="yes" xml:space="preserve">
          <source>Later on we will learn how to compile Elixir code (in &lt;a href=&quot;modules-and-functions&quot;&gt;Chapter 8&lt;/a&gt;) and how to use the Mix build tool (in the &lt;a href=&quot;mix-otp/introduction-to-mix&quot;&gt;Mix &amp;amp; OTP guide&lt;/a&gt;). For now, let&amp;rsquo;s move on to &lt;a href=&quot;basic-types&quot;&gt;Chapter 2&lt;/a&gt;.</source>
          <target state="translated">後でElixirコードをコンパイルする方法（&lt;a href=&quot;modules-and-functions&quot;&gt;8章&lt;/a&gt;）とMixビルドツールの使用方法（&lt;a href=&quot;mix-otp/introduction-to-mix&quot;&gt;Mix＆OTPガイド&lt;/a&gt;）について学びます。とりあえず、&lt;a href=&quot;basic-types&quot;&gt;第2章に&lt;/a&gt;移りましょう。</target>
        </trans-unit>
        <trans-unit id="dec3727f52253a21a625cc6c295ee24dda78903b" translate="yes" xml:space="preserve">
          <source>Lazily drops elements of the enumerable while the given function returns a truthy value.</source>
          <target state="translated">与えられた関数が真実の値を返す間に、列挙可能な要素を軽々と削除します。</target>
        </trans-unit>
        <trans-unit id="ee9b58962b88fa77ea098c1b0d427e9f46c19021" translate="yes" xml:space="preserve">
          <source>Lazily drops the next &lt;code&gt;n&lt;/code&gt; elements from the enumerable.</source>
          <target state="translated">列挙可能なものから次の &lt;code&gt;n&lt;/code&gt; 個の要素を遅延して削除します。</target>
        </trans-unit>
        <trans-unit id="69ade1dc23ccb5f3b64347640778d1f4fe8c44ae" translate="yes" xml:space="preserve">
          <source>Lazily intersperses &lt;code&gt;intersperse_element&lt;/code&gt; between each element of the enumeration.</source>
          <target state="translated">列挙の各要素の間にintersperse_elementをゆっくりと散在さ &lt;code&gt;intersperse_element&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="fb2c9b6a976811f032d7cbfe8165bb5865150558" translate="yes" xml:space="preserve">
          <source>Lazily returns and removes all values associated with &lt;code&gt;key&lt;/code&gt; in the keyword list.</source>
          <target state="translated">キーワードリストの &lt;code&gt;key&lt;/code&gt; に関連付けられたすべての値を遅延して返し、削除します。</target>
        </trans-unit>
        <trans-unit id="b61c3c17ee3d10d7647d9803c70ba26ee27244c1" translate="yes" xml:space="preserve">
          <source>Lazily returns and removes the value associated with &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; の &lt;code&gt;key&lt;/code&gt; に関連付けられた値を遅延して返し、削除します。</target>
        </trans-unit>
        <trans-unit id="0e92baedbf908cf61336dc397f7fe80981871f17" translate="yes" xml:space="preserve">
          <source>Lazily takes elements of the enumerable while the given function returns a truthy value.</source>
          <target state="translated">与えられた関数が真実の値を返す間、列挙可能な要素を軽々と取得します。</target>
        </trans-unit>
        <trans-unit id="450194d4d3b114b2c73dd825ab3cd48712daf267" translate="yes" xml:space="preserve">
          <source>Lazily takes the next &lt;code&gt;count&lt;/code&gt; elements from the enumerable and stops enumeration.</source>
          <target state="translated">enumerableから次の &lt;code&gt;count&lt;/code&gt; 要素を遅延して取得し、列挙を停止します。</target>
        </trans-unit>
        <trans-unit id="9fa3a1af379a945e27159d6cbd53b6758da22a91" translate="yes" xml:space="preserve">
          <source>Leap seconds are not taken into account.</source>
          <target state="translated">うるう秒数は考慮されていません。</target>
        </trans-unit>
        <trans-unit id="824d76b124e6289f372e2ff6bcba91e8939343bd" translate="yes" xml:space="preserve">
          <source>Learn more</source>
          <target state="translated">詳細はこちら</target>
        </trans-unit>
        <trans-unit id="34ce14772451e311453b61a1ddb8221e562b888f" translate="yes" xml:space="preserve">
          <source>Left to right</source>
          <target state="translated">左から右へ</target>
        </trans-unit>
        <trans-unit id="efe84e15d94659b1eca2695c2253c5d3775e58ca" translate="yes" xml:space="preserve">
          <source>Left to right arrow</source>
          <target state="translated">左から右矢印</target>
        </trans-unit>
        <trans-unit id="e68d562699894469c473720b475220fbf042128a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s also add a test to &lt;code&gt;test/kv/bucket_test.exs&lt;/code&gt; that guarantees the bucket is temporary:</source>
          <target state="translated">バケットが一時的であることを保証するテストを &lt;code&gt;test/kv/bucket_test.exs&lt;/code&gt; に追加してみましょう：</target>
        </trans-unit>
        <trans-unit id="404b4b3a784b443893ff8bf31f1dd037577b8b2e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s break that code apart a bit:</source>
          <target state="translated">そのコードを少し分解してみましょう：</target>
        </trans-unit>
        <trans-unit id="4729229379e49f59080304c7286d1586582b445a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s change &lt;code&gt;start/2&lt;/code&gt; once again, to add a supervisor to our tree:</source>
          <target state="translated">&lt;code&gt;start/2&lt;/code&gt; をもう一度変更して、ツリーにスーパーバイザーを追加します。</target>
        </trans-unit>
        <trans-unit id="1a65af3d4df3dd7789d08b039fbd9ffd187026b1" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s change the &lt;code&gt;KV.Registry&lt;/code&gt; to use ETS tables. The first change is to modify our registry to require a name argument, we will use it to name the ETS table and the registry process itself. ETS names and process names are stored in different locations, so there is no chance of conflicts.</source>
          <target state="translated">ETSテーブルを使用するように &lt;code&gt;KV.Registry&lt;/code&gt; を変更してみましょう。最初の変更は、レジストリを変更して名前引数を要求することです。これを使用して、ETSテーブルとレジストリプロセス自体に名前を付けます。ETS名とプロセス名は異なる場所に格納されるため、競合する可能性はありません。</target>
        </trans-unit>
        <trans-unit id="9e05a0ba8c59d0c8c376685e9addab95d169eccc" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s check each case, one by one.</source>
          <target state="translated">それぞれのケースを1つずつ確認してみましょう。</target>
        </trans-unit>
        <trans-unit id="c27f60b2e4915c4a82ea29d51d011f01772e3dd9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create a new Mix project. We are going to creatively name it &lt;code&gt;kv_umbrella&lt;/code&gt;, and this new project will have both the existing &lt;code&gt;kv&lt;/code&gt; application and the new &lt;code&gt;kv_server&lt;/code&gt; application inside. The directory structure will look like this:</source>
          <target state="translated">新しいMixプロジェクトを作成しましょう。クリエイティブに &lt;code&gt;kv_umbrella&lt;/code&gt; という名前を付けます。この新しいプロジェクトには、既存の &lt;code&gt;kv&lt;/code&gt; アプリケーションと新しい &lt;code&gt;kv_server&lt;/code&gt; アプリケーションの両方が含まれます。ディレクトリ構造は次のようになります。</target>
        </trans-unit>
        <trans-unit id="b9686ac5cd9d110e2280341ca7651f1e7a2c3a8f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create our command parser at &lt;code&gt;lib/kv_server/command.ex&lt;/code&gt; and start with the doctest:</source>
          <target state="translated">&lt;code&gt;lib/kv_server/command.ex&lt;/code&gt; にコマンドパーサーを作成して、doctestから始めましょう。</target>
        </trans-unit>
        <trans-unit id="57da67e011a89dbbfb6c22ba016b496c2bf15d61" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create our first project by invoking &lt;code&gt;mix new&lt;/code&gt; from the command line. We&amp;rsquo;ll pass the project name as the argument (&lt;code&gt;kv&lt;/code&gt;, in this case), and tell Mix that our main module should be the all-uppercase &lt;code&gt;KV&lt;/code&gt;, instead of the default, which would have been &lt;code&gt;Kv&lt;/code&gt;:</source>
          <target state="translated">コマンドラインから &lt;code&gt;mix new&lt;/code&gt; を呼び出して、最初のプロジェクトを作成しましょう。引数としてプロジェクト名（この場合は &lt;code&gt;kv&lt;/code&gt; ）を渡し、Mixにメインモジュールをデフォルトの &lt;code&gt;Kv&lt;/code&gt; の代わりにすべて大文字の &lt;code&gt;KV&lt;/code&gt; にするように指示します。</target>
        </trans-unit>
        <trans-unit id="44ccaac6800d7e69a627f543507cef6aaa36f75a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s define a module named &lt;code&gt;Hello&lt;/code&gt; in this shell:</source>
          <target state="translated">このシェルで &lt;code&gt;Hello&lt;/code&gt; という名前のモジュールを定義しましょう：</target>
        </trans-unit>
        <trans-unit id="78d3183a361ff888bc82b3eb6a4eacbf2fa2a5c0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s do so by creating a &amp;ldquo;bogus&amp;rdquo; bucket, which is a synchronous request, after &lt;code&gt;Agent.stop/2&lt;/code&gt; in both tests:</source>
          <target state="translated">両方のテストで &lt;code&gt;Agent.stop/2&lt;/code&gt; の後に、同期リクエストである「偽の」バケットを作成して、それを実行してみましょう。</target>
        </trans-unit>
        <trans-unit id="52cc88c9ff893fa670f476f83f7e11b188b0c8fb" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s do this.</source>
          <target state="translated">これをやろう。</target>
        </trans-unit>
        <trans-unit id="87f2c21bc94f91beaecdd70cb4c1e04e5acba348" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s first play with monitors by starting a new console with &lt;code&gt;iex -S mix&lt;/code&gt;:</source>
          <target state="translated">まず、 &lt;code&gt;iex -S mix&lt;/code&gt; で新しいコンソールを起動して、モニターを操作してみましょう。</target>
        </trans-unit>
        <trans-unit id="3cfccd6e33d5a510641ee1fe031db4c15efbf06a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s get started!</source>
          <target state="translated">始めましょう！</target>
        </trans-unit>
        <trans-unit id="66bbb9d93128da50d0a5fd0f342b723836429324" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s give it a try by running &lt;code&gt;iex kv.exs&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;iex kv.exs&lt;/code&gt; を実行して試してみましょう：</target>
        </trans-unit>
        <trans-unit id="5839691ae3f96ef964d421fd3acb9f807e8f4ab6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s give it a try. Open up &lt;code&gt;lib/kv_server/application.ex&lt;/code&gt;, and let&amp;rsquo;s change the supervisor in the &lt;code&gt;start/2&lt;/code&gt; function to the following:</source>
          <target state="translated">やるだけやってみよう。 &lt;code&gt;lib/kv_server/application.ex&lt;/code&gt; を開き、 &lt;code&gt;start/2&lt;/code&gt; 関数のスーパーバイザーを次のように変更してみましょう。</target>
        </trans-unit>
        <trans-unit id="baa34105a5b53a50e8c2b4ac1b991daa285cda4f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s give the updated supervisor a try inside &lt;code&gt;iex -S mix&lt;/code&gt;:</source>
          <target state="translated">更新されたスーパーバイザーに &lt;code&gt;iex -S mix&lt;/code&gt; 試してみましょう：</target>
        </trans-unit>
        <trans-unit id="56cfa20ba11b54abba073399ca2cc31a1beb82f3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go back to the &lt;code&gt;Math&lt;/code&gt; module defined in the previous chapters, add some documentation and save it to the &lt;code&gt;math.ex&lt;/code&gt; file:</source>
          <target state="translated">前の章で定義した &lt;code&gt;Math&lt;/code&gt; モジュールに戻り、ドキュメントを追加して、 &lt;code&gt;math.ex&lt;/code&gt; ファイルに保存します。</target>
        </trans-unit>
        <trans-unit id="3e193874a827cfe3989b47093b1f35bf1d889de9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s implement the integration test in &lt;code&gt;test/kv_server_test.exs&lt;/code&gt; as shown below:</source>
          <target state="translated">&lt;code&gt;test/kv_server_test.exs&lt;/code&gt; 示すように、test / kv_server_test.exsに統合テストを実装してみましょう。</target>
        </trans-unit>
        <trans-unit id="f3d61bf295e16bbbb18d9e86a778638333f98c0d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s implement those steps. Move to the &lt;code&gt;apps/kv_server&lt;/code&gt; application, open up &lt;code&gt;lib/kv_server.ex&lt;/code&gt;, and add the following functions:</source>
          <target state="translated">それらのステップを実装しましょう。 &lt;code&gt;apps/kv_server&lt;/code&gt; アプリケーションに移動し、 &lt;code&gt;lib/kv_server.ex&lt;/code&gt; を開いて、次の関数を追加します。</target>
        </trans-unit>
        <trans-unit id="39e760533fa67c3a16cee4f61982aced80e52f83" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s learn how to do that.</source>
          <target state="translated">その方法を学びましょう。</target>
        </trans-unit>
        <trans-unit id="cf8ebea7b04a470e898c361b3c01206eb4a8342a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s make another example using streams. Since the &lt;code&gt;IO&lt;/code&gt; module provides streams (that are both &lt;code&gt;Enumerable&lt;/code&gt;s and &lt;code&gt;Collectable&lt;/code&gt;s), an echo terminal that echoes back the upcased version of whatever is typed can be implemented using comprehensions:</source>
          <target state="translated">ストリームを使った別の例を作ってみましょう。 &lt;code&gt;IO&lt;/code&gt; モジュールはストリーム（ &lt;code&gt;Enumerable&lt;/code&gt; と &lt;code&gt;Collectable&lt;/code&gt; の両方）を提供するので、タイプされたものの大文字のバージョンをエコーバックするエコーターミナルは、内包表記を使用して実装できます。</target>
        </trans-unit>
        <trans-unit id="ed8179b6236a6127fea762c1dc4859e7ff9ad41e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s move inside the apps directory and start building &lt;code&gt;kv_server&lt;/code&gt;. This time, we are going to pass the &lt;code&gt;--sup&lt;/code&gt; flag, which will tell Mix to generate a supervision tree automatically for us, instead of building one manually as we did in previous chapters:</source>
          <target state="translated">appsディレクトリ内に移動して、 &lt;code&gt;kv_server&lt;/code&gt; の構築を始めましょう。今回は、前の章で行ったように手動で作成するのではなく、監視ツリーを自動的に生成するようにMixに指示する &lt;code&gt;--sup&lt;/code&gt; フラグを渡します。</target>
        </trans-unit>
        <trans-unit id="9abc4b0404a0faf043a413238fb9c0b85596b7d3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s move to the next chapter. We will finally make our system distributed by adding a bucket routing mechanism. We will use this opportunity to also improve our testing chops.</source>
          <target state="translated">次の章に移りましょう。最後に、バケットルーティングメカニズムを追加して、システムを分散させます。この機会を利用して、テストチョップも改善します。</target>
        </trans-unit>
        <trans-unit id="907c5a40686f1ad77133ab1fb7ed4fb9044e980b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now define a release for &lt;code&gt;:bar&lt;/code&gt;. One first step could be to define a release exactly like &lt;code&gt;foo&lt;/code&gt; inside &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;:bar&lt;/code&gt; のリリースを定義しましょう。最初のステップの1つは、 &lt;code&gt;mix.exs&lt;/code&gt; 内で &lt;code&gt;foo&lt;/code&gt; とまったく同じようにリリースを定義することです。</target>
        </trans-unit>
        <trans-unit id="5a2917bda9d2d2ade9ad2c9418f4b2b9f81e1083" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now see how we can use the power of recursion to sum a list of numbers:</source>
          <target state="translated">再帰の力を使用して数値のリストを合計する方法を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="df2a11fdb0c0854864b329de4b39854b42d8a291" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s put it all together and send messages between processes:</source>
          <target state="translated">それをすべてまとめて、プロセス間でメッセージを送信します。</target>
        </trans-unit>
        <trans-unit id="2fe45cc7fb55e4c742c4dc05c2cb987f67c6d233" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s recap what is happening. Whenever we invoke &lt;code&gt;iex -S mix&lt;/code&gt;, it automatically starts our application by calling &lt;code&gt;Application.start(:kv)&lt;/code&gt;, which then invokes the application callback. The application callback job is to start a &lt;strong&gt;supervision tree&lt;/strong&gt;. Right now, we only have a single supervisor, but sometimes a supervisor is also supervised, giving it a shape of a tree. So far, our supervisor has a single child, a &lt;code&gt;KV.Registry&lt;/code&gt;, which is started with name &lt;code&gt;KV.Registry&lt;/code&gt;.</source>
          <target state="translated">何が起こっているのかを要約してみましょう。 &lt;code&gt;iex -S mix&lt;/code&gt; を呼び出すたびに、 &lt;code&gt;Application.start(:kv)&lt;/code&gt; を呼び出すことでアプリケーションが自動的に開始され、アプリケーションコールバックが呼び出されます。アプリケーションのコールバックジョブは、&lt;strong&gt;監視ツリー&lt;/strong&gt;を開始すること&lt;strong&gt;です&lt;/strong&gt;。現在、監督者は1人だけですが、監督者が監督されてツリーの形をしている場合もあります。これまでのところ、スーパーバイザーには &lt;code&gt;KV.Registry&lt;/code&gt; という名前で始まる単一の子 &lt;code&gt;KV.Registry&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="325ed6370b4676504d3b00af4ba0fd26fde98423" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s reimplement the server callbacks to fix the bug and make the test pass. First, we will modify the GenServer state to two dictionaries: one that contains &lt;code&gt;name -&amp;gt; pid&lt;/code&gt; and another that holds &lt;code&gt;ref -&amp;gt; name&lt;/code&gt;. Then we need to monitor the buckets on &lt;code&gt;handle_cast/2&lt;/code&gt; as well as implement a &lt;code&gt;handle_info/2&lt;/code&gt; callback to handle the monitoring messages. The full server callbacks implementation is shown below:</source>
          <target state="translated">サーバーのコールバックを再実装してバグを修正し、テストに合格しましょう。まず、GenServerの状態を2つの辞書に変更します。1つはname- &lt;code&gt;name -&amp;gt; pid&lt;/code&gt; を含み、もう1つはref- &lt;code&gt;ref -&amp;gt; name&lt;/code&gt; を保持します。次に、 &lt;code&gt;handle_cast/2&lt;/code&gt; のバケットを監視し、監視メッセージを処理するための &lt;code&gt;handle_info/2&lt;/code&gt; コールバックを実装する必要があります。完全なサーバーコールバックの実装を以下に示します。</target>
        </trans-unit>
        <trans-unit id="5859e594dd7ff75c74328e1ec62ef118e79b5173" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s rewrite the test case to use callbacks:</source>
          <target state="translated">コールバックを使用するようにテストケースを書き換えましょう。</target>
        </trans-unit>
        <trans-unit id="7af0235d132a57562aba639e633d1cb04c26a76e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s run the tests once again. This time though, we will pass the &lt;code&gt;--trace&lt;/code&gt; option:</source>
          <target state="translated">もう一度テストを実行してみましょう。今回は &lt;code&gt;--trace&lt;/code&gt; オプションを渡します。</target>
        </trans-unit>
        <trans-unit id="2aced57d244d27459d17d10f2ab48937597ad351" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see in more detail what happens when you request &lt;code&gt;IO.write(pid, binary)&lt;/code&gt;. The &lt;code&gt;IO&lt;/code&gt; module sends a message to the process identified by &lt;code&gt;pid&lt;/code&gt; with the desired operation. A small ad-hoc process can help us see it:</source>
          <target state="translated">&lt;code&gt;IO.write(pid, binary)&lt;/code&gt; をリクエストするとどうなるかを詳しく見てみましょう。 &lt;code&gt;IO&lt;/code&gt; モジュールは、によって識別されるプロセスにメッセージを送信し &lt;code&gt;pid&lt;/code&gt; 所望の動作と。小さなアドホックプロセスは、それを確認するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="67af3c48055ca2b3c2d9f546637c104f51f74e74" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see this in practice. Start a console with &lt;code&gt;iex -S mix&lt;/code&gt; and try:</source>
          <target state="translated">これを実際に見てみましょう。 &lt;code&gt;iex -S mix&lt;/code&gt; でコンソールを起動して、次のことを試してください。</target>
        </trans-unit>
        <trans-unit id="7dee2fe998155b6e01d27bc48c7887e983907b48" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s slightly change our children definition (in &lt;code&gt;KV.Supervisor.init/1&lt;/code&gt;) to be a list of tuples instead of a list of atoms:</source>
          <target state="translated">子の定義（ &lt;code&gt;KV.Supervisor.init/1&lt;/code&gt; 内）を少し変更して、アトムのリストではなくタプルのリストにしましょう。</target>
        </trans-unit>
        <trans-unit id="1bd92f7c84f63683d6101c71449ed203a7800ec9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start &lt;code&gt;iex&lt;/code&gt; with the module above:</source>
          <target state="translated">上記のモジュールで &lt;code&gt;iex&lt;/code&gt; を始めましょう：</target>
        </trans-unit>
        <trans-unit id="9d1661fc8a81e848a401464f1c2a605c5da459d3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start a new project using &lt;code&gt;mix new&lt;/code&gt;. This new project will be named &lt;code&gt;kv_umbrella&lt;/code&gt; and we need to pass the &lt;code&gt;--umbrella&lt;/code&gt; option when creating it. Do not create this new project inside the existing &lt;code&gt;kv&lt;/code&gt; project!</source>
          <target state="translated">&lt;code&gt;mix new&lt;/code&gt; を使って新しいプロジェクトを始めましょう。この新しいプロジェクトの名前は &lt;code&gt;kv_umbrella&lt;/code&gt; で、作成時に &lt;code&gt;--umbrella&lt;/code&gt; オプションを渡す必要があります。この新しいプロジェクトを既存の &lt;code&gt;kv&lt;/code&gt; プロジェクト内に作成しないでください！</target>
        </trans-unit>
        <trans-unit id="9f966b08bc66cb4042c8b3f3f1b9e2153b0cd851" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start by creating a module that defines and imports the &lt;code&gt;test&lt;/code&gt; macro when used:</source>
          <target state="translated">使用時に &lt;code&gt;test&lt;/code&gt; マクロを定義およびインポートするモジュールを作成することから始めましょう。</target>
        </trans-unit>
        <trans-unit id="a0fddb1a8907c2cf50e04a25da3983ae6441dda6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with a test that describes how we want the registry to behave if a bucket stops or crashes:</source>
          <target state="translated">バケットが停止またはクラッシュした場合のレジストリの動作を説明するテストから始めましょう。</target>
        </trans-unit>
        <trans-unit id="1fa11d581397d95e04f2020a68e066fb3e60d04a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a brief look at those generated files.</source>
          <target state="translated">これらの生成されたファイルを簡単に見てみましょう。</target>
        </trans-unit>
        <trans-unit id="04e68357588d11fea0410465b619814c2039a742" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a deeper look at &lt;code&gt;Enumerable&lt;/code&gt;s and, while we&amp;rsquo;re at it, their lazy counterpart, &lt;code&gt;Stream&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;Enumerable&lt;/code&gt; をさらに詳しく見ていきましょう。その間、それらの怠惰な対応物である &lt;code&gt;Stream&lt;/code&gt; を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="91b289146778a1a9ac545041f63405e023909059" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take the supervior for a spin:</source>
          <target state="translated">監督者を試してみましょう：</target>
        </trans-unit>
        <trans-unit id="3b01013918cb505bb54dd81a9af06894999c0120" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write a test to verify our router works. Create a file named &lt;code&gt;test/kv/router_test.exs&lt;/code&gt; containing:</source>
          <target state="translated">ルーターが機能することを確認するためのテストを書いてみましょう。 &lt;code&gt;test/kv/router_test.exs&lt;/code&gt; を含むtest / kv / router_test.exsという名前のファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="fa012006b966bf0a6eab57a8968215cebf134379" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write some code!</source>
          <target state="translated">コードを書いてみましょう！</target>
        </trans-unit>
        <trans-unit id="c67023947ca555b00e6d88ffa6d4701c0c3be370" translate="yes" xml:space="preserve">
          <source>Let's build a stream and then enumerate it:</source>
          <target state="translated">ストリームを作って列挙してみましょう。</target>
        </trans-unit>
        <trans-unit id="af13b7ca9a49d1b748a7f4486807d45530939bbd" translate="yes" xml:space="preserve">
          <source>Let's create a document by concatenating two strings with a break between them:</source>
          <target state="translated">2つの文字列の間に区切りを入れて連結して文書を作成してみましょう。</target>
        </trans-unit>
        <trans-unit id="5d78dfa30452eb74635f4fb43b15b17251e16913" translate="yes" xml:space="preserve">
          <source>Let's explore the basic functions from the &lt;a href=&quot;http://www.erlang.org/doc/man/sys.html&quot;&gt;&lt;code&gt;:sys&lt;/code&gt; module&lt;/a&gt; used for debugging:</source>
          <target state="translated">デバッグに使用される&lt;a href=&quot;http://www.erlang.org/doc/man/sys.html&quot;&gt; &lt;code&gt;:sys&lt;/code&gt; モジュール&lt;/a&gt;の基本的な機能を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="688ee6c95315db8b18bfec15fee2dfd168073eec" translate="yes" xml:space="preserve">
          <source>Let's fix our macro:</source>
          <target state="translated">マクロを直そう</target>
        </trans-unit>
        <trans-unit id="d7fff4c2e7484327d49d843539125f18766ef59b" translate="yes" xml:space="preserve">
          <source>Let's give it a try. First start a new shell:</source>
          <target state="translated">試してみましょう。まず、新しいシェルを起動します。</target>
        </trans-unit>
        <trans-unit id="385a594a813b358193b288faec070338a76a46ba" translate="yes" xml:space="preserve">
          <source>Let's look at a quick case study: we want to check that a function argument is an even or odd integer. With pattern matching, this is impossible to do since there are infinite integers, and thus we can't pattern match on the single even/odd numbers. Let's focus on checking for even numbers since checking for odd ones is almost identical.</source>
          <target state="translated">簡単なケーススタディを見てみましょう。関数の引数が偶数または奇数の整数であるかどうかをチェックしたいとします。パターンマッチングでは、整数は無限に存在するので、これを行うことは不可能です。奇数のチェックはほぼ同じなので、偶数のチェックに焦点を当ててみましょう。</target>
        </trans-unit>
        <trans-unit id="f17d3ddea9ff5b443102e2f1aa7d529504a09b53" translate="yes" xml:space="preserve">
          <source>Let's see a simple example. Imagine that you implement a library that breaks a string in two parts based on the first occurrence of the dash &lt;code&gt;-&lt;/code&gt; character:</source>
          <target state="translated">簡単な例を見てみましょう。あなたはダッシュの最初の出現に基づいて、2つの部分で休憩文字列というライブラリを実装することを想像して &lt;code&gt;-&lt;/code&gt; 文字：</target>
        </trans-unit>
        <trans-unit id="a086f0aa8dc3f13f368da5ddef024d84bd14e45f" translate="yes" xml:space="preserve">
          <source>Let's see an example of a guard used in a function clause:</source>
          <target state="translated">関数節で使用するガードの例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="eb3e603df7a85750e6414b0eb382239bbf870bfb" translate="yes" xml:space="preserve">
          <source>Let's see an example.</source>
          <target state="translated">例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="2bb9a3671c7cc45e630956b53927eeec08220af2" translate="yes" xml:space="preserve">
          <source>Let's see how we could use those functions for debugging the stack server we defined earlier.</source>
          <target state="translated">先ほど定義したスタックサーバのデバッグにこれらの関数を使う方法を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="9944bcda5d8aef46440ac764e0d71869f8b3eb89" translate="yes" xml:space="preserve">
          <source>Let's see some examples. The code below:</source>
          <target state="translated">いくつかの例を見てみましょう。下のコードです。</target>
        </trans-unit>
        <trans-unit id="9a9747f9ce9d128c721ed4b062d8c863cdde1877" translate="yes" xml:space="preserve">
          <source>Let's start with a code example and then explore the available callbacks. Imagine we want a GenServer that works like a stack, allowing us to push and pop elements:</source>
          <target state="translated">まずはコード例から始めて、利用可能なコールバックを探ってみましょう。スタックのように動作し、要素をプッシュしたりポップしたりできる GenServer が欲しいと想像してみてください。</target>
        </trans-unit>
        <trans-unit id="45a0d37d2635e9d8af766d2643fce24860a449d3" translate="yes" xml:space="preserve">
          <source>Let's start with an example:</source>
          <target state="translated">まずは例を挙げてみましょう。</target>
        </trans-unit>
        <trans-unit id="c498b7be97563d9e009446e491717478748954ec" translate="yes" xml:space="preserve">
          <source>Let's suppose you created your own &lt;a href=&quot;kernel#if/2&quot;&gt;&lt;code&gt;if/2&lt;/code&gt;&lt;/a&gt; implementation in the module &lt;code&gt;MyMacros&lt;/code&gt;. If you want to invoke it, you need to first explicitly require the &lt;code&gt;MyMacros&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;MyMacros&lt;/code&gt; モジュールで独自の&lt;a href=&quot;kernel#if/2&quot;&gt; &lt;code&gt;if/2&lt;/code&gt; &lt;/a&gt;実装を作成したとしましょう。それを呼び出したい場合は、最初に &lt;code&gt;MyMacros&lt;/code&gt; を明示的に要求する必要があります。</target>
        </trans-unit>
        <trans-unit id="167e9ac5d10b20cb0dda56b181fe66788b49d6e5" translate="yes" xml:space="preserve">
          <source>Let's suppose you want to investigate what is happening with some particular function. By invoking &lt;a href=&quot;iex#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; from the function, IEx will allow you to access its binding (variables), verify its lexical information and access the process information. Let's see an example:</source>
          <target state="translated">特定の関数で何が起こっているのかを調べたいとしましょう。関数から&lt;a href=&quot;iex#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt;を呼び出すことにより、IExはそのバインディング（変数）へのアクセス、その字句情報の検証、およびプロセス情報へのアクセスを可能にします。例を見てみましょう：</target>
        </trans-unit>
        <trans-unit id="810f288f1e4fdf45c23a3b902942dd7960a5c22f" translate="yes" xml:space="preserve">
          <source>Let's understand what the &lt;code&gt;:shutdown&lt;/code&gt; and &lt;code&gt;:restart&lt;/code&gt; options control.</source>
          <target state="translated">&lt;code&gt;:shutdown&lt;/code&gt; および &lt;code&gt;:restart&lt;/code&gt; オプションが制御するものを理解しましょう。</target>
        </trans-unit>
        <trans-unit id="ed47f098118b3a4908065115144a054c9afe75d6" translate="yes" xml:space="preserve">
          <source>Levels</source>
          <target state="translated">Levels</target>
        </trans-unit>
        <trans-unit id="5ff76884a1b9f933647dc46c0efb08cd23ce4c72" translate="yes" xml:space="preserve">
          <source>Lexical scope</source>
          <target state="translated">語彙的範囲</target>
        </trans-unit>
        <trans-unit id="b8100f5ba8bd048a7cf11d116fbbd73130c3c6f5" translate="yes" xml:space="preserve">
          <source>Library</source>
          <target state="translated">Library</target>
        </trans-unit>
        <trans-unit id="b7e01bf49268dbb685a7684daf71674fc58c2f88" translate="yes" xml:space="preserve">
          <source>Library Guidelines</source>
          <target state="translated">図書館ガイドライン</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">Apache License,Version 2.0の下でライセンスされています。</target>
        </trans-unit>
        <trans-unit id="8c32d4b808a84de40c883809049bbfd2ca84a901" translate="yes" xml:space="preserve">
          <source>Like with &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt;, the functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the list. This is expected on operations such as &lt;a href=&quot;stream#map/2&quot;&gt;&lt;code&gt;Stream.map/2&lt;/code&gt;&lt;/a&gt;. After all, if we want to traverse every element on a stream, the longer the stream, the more elements we need to traverse, and the longer it will take.</source>
          <target state="translated">&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;と同様に、このモジュールの関数は線形時間で動作します。つまり、操作の実行にかかる時間は、リストの長さと同じ割合で増加します。これは、&lt;a href=&quot;stream#map/2&quot;&gt; &lt;code&gt;Stream.map/2&lt;/code&gt; &lt;/a&gt;などの操作で予想されます。結局、ストリーム上のすべての要素をトラバースしたい場合、ストリームが長くなるほど、トラバースする必要のある要素が多くなり、時間がかかります。</target>
        </trans-unit>
        <trans-unit id="e959a6b5621b2dae8ab30d3d3f44c9b21fd9caf5" translate="yes" xml:space="preserve">
          <source>Limit for when a certain time zone period begins or ends.</source>
          <target state="translated">特定の時間帯の開始時と終了時の制限。</target>
        </trans-unit>
        <trans-unit id="447809eeca7d1b001940f2b5c2552166d7274fa3" translate="yes" xml:space="preserve">
          <source>Line &lt;code&gt;0&lt;/code&gt; and column &lt;code&gt;0&lt;/code&gt; would mean the top left corner.</source>
          <target state="translated">行 &lt;code&gt;0&lt;/code&gt; と列 &lt;code&gt;0&lt;/code&gt; は左上隅を意味します。</target>
        </trans-unit>
        <trans-unit id="a5f54e0f2d31735fc8356d4c643062d7468cc599" translate="yes" xml:space="preserve">
          <source>Linking</source>
          <target state="translated">Linking</target>
        </trans-unit>
        <trans-unit id="fce9e7983aa4d178575a43583fbc0a75230dea86" translate="yes" xml:space="preserve">
          <source>Linking can also be done manually by calling &lt;code&gt;Process.link/1&lt;/code&gt;. We recommend that you take a look at &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html&quot;&gt;the &lt;code&gt;Process&lt;/code&gt; module&lt;/a&gt; for other functionality provided by processes.</source>
          <target state="translated">リンクは、 &lt;code&gt;Process.link/1&lt;/code&gt; を呼び出して手動で行うこともできます。&lt;a href=&quot;https://hexdocs.pm/elixir/Process.html&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt;提供するその他の機能については、プロセスモジュールを確認することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="5bf3859293f6be21536ffe679146ee6401148648" translate="yes" xml:space="preserve">
          <source>Links are bi-directional. If you link two processes and one of them crashes, the other side will crash too (unless it is trapping exits). A monitor is uni-directional: only the monitoring process will receive notifications about the monitored one. In other words: use links when you want linked crashes, and monitors when you just want to be informed of crashes, exits, and so on.</source>
          <target state="translated">リンクは双方向です。2つのプロセスをリンクして片方がクラッシュした場合、もう片方もクラッシュします (出口をトラップしている場合を除く)。モニタは一方向です:モニタリングされているプロセスのみが、モニタされているプロセスに関する通知を受け取ります。言い換えれば、リンクされたクラッシュが必要な場合はリンクを使用し、クラッシュや出口などの通知を受けたい場合はモニターを使用します。</target>
        </trans-unit>
        <trans-unit id="b3e008dc1478680d69d7d944ea5e97681e447863" translate="yes" xml:space="preserve">
          <source>Links are bidirectional, which implies that a crash in a bucket will crash the registry. Although we now have the supervisor, which guarantees the registry will be back up and running, crashing the registry still means we lose all data associating bucket names to their respective processes.</source>
          <target state="translated">リンクは双方向であり、バケットがクラッシュするとレジストリがクラッシュすることを意味します。スーパバイザはレジストリのバックアップと実行を保証してくれますが、レジストリをクラッシュさせてしまうと、バケット名とそれぞれのプロセスを関連付けたすべてのデータを失うことになります。</target>
        </trans-unit>
        <trans-unit id="010816f5d4211c808577da6a4d3fff9e452bea0e" translate="yes" xml:space="preserve">
          <source>Links are bidirectional. Linked processes can be unlinked by using &lt;a href=&quot;#unlink/1&quot;&gt;&lt;code&gt;unlink/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">リンクは双方向です。リンクされたプロセスは、&lt;a href=&quot;#unlink/1&quot;&gt; &lt;code&gt;unlink/1&lt;/code&gt; &lt;/a&gt;を使用してリンクを解除できます。</target>
        </trans-unit>
        <trans-unit id="a1fffaaafb7cc996685bceb829c053cc4f7de43d" translate="yes" xml:space="preserve">
          <source>List</source>
          <target state="translated">List</target>
        </trans-unit>
        <trans-unit id="5ea588245c39a0237a816a5a4b5f30b996ac4e47" translate="yes" xml:space="preserve">
          <source>List of allowed expressions</source>
          <target state="translated">許可されている表現の一覧</target>
        </trans-unit>
        <trans-unit id="e6fd9a7c630dc04fe44f8eceb64283a7b0d97ed2" translate="yes" xml:space="preserve">
          <source>List of supported keys in the keyword list:</source>
          <target state="translated">キーワードリストでサポートされているキーのリスト。</target>
        </trans-unit>
        <trans-unit id="0b38e76a685c2b2df84a12add2cb4a8302d42bac" translate="yes" xml:space="preserve">
          <source>List operators never modify the existing list. Concatenating to or removing elements from a list returns a new list. We say that Elixir data structures are &lt;em&gt;immutable&lt;/em&gt;. One advantage of immutability is that it leads to clearer code. You can freely pass the data around with the guarantee no one will mutate it in memory - only transform it.</source>
          <target state="translated">リスト演算子は、既存のリストを変更することはありません。リストに要素を連結またはリストから要素を削除すると、新しいリストが返されます。Elixirのデータ構造は&lt;em&gt;不変である&lt;/em&gt;と言います。不変性の1つの利点は、コードがより明確になることです。誰もがメモリ内でデータを変更することはなく、データを変換するだけで、データを自由に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="b2eb00e5233b62475b0dc3d5e4e0b3fba8fb4994" translate="yes" xml:space="preserve">
          <source>List.Chars</source>
          <target state="translated">List.Chars</target>
        </trans-unit>
        <trans-unit id="9f9dce20c46fcd1c1728dc56a20927edd518996b" translate="yes" xml:space="preserve">
          <source>List.Chars &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="translated">List.Chars &lt;small&gt;プロトコル&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d03be4130ee5ad90ce04ed9ec5d74c5566fe35d8" translate="yes" xml:space="preserve">
          <source>List.Chars.t (0)</source>
          <target state="translated">List.Chars.t (0)</target>
        </trans-unit>
        <trans-unit id="360565f0168323951cb15fd7ca1982778f9a1e7d" translate="yes" xml:space="preserve">
          <source>List.Chars.to_charlist (1)</source>
          <target state="translated">List.Chars.to_charlist (1)</target>
        </trans-unit>
        <trans-unit id="f37415d7b26ed53d3baccb63f14d10f67a7f2022" translate="yes" xml:space="preserve">
          <source>Listens to a port until the port is available and it gets hold of the socket</source>
          <target state="translated">ポートが利用可能になるまでポートをリッスンし、ソケットを取得します。</target>
        </trans-unit>
        <trans-unit id="30045b3ebb820da7e212b26c8d486fa6438d1b21" translate="yes" xml:space="preserve">
          <source>Lists all dependencies and their status.</source>
          <target state="translated">すべての依存関係とその状態を一覧表示します。</target>
        </trans-unit>
        <trans-unit id="576be6f9e3cd2119a02b300937f31a0bfa25055f" translate="yes" xml:space="preserve">
          <source>Lists all required files.</source>
          <target state="translated">必要なファイルをすべてリストアップします。</target>
        </trans-unit>
        <trans-unit id="e5fcc5c6ccb03f1f5363ab1add506f548d93b038" translate="yes" xml:space="preserve">
          <source>Lists all tasks and aliases or prints the documentation for a given task or alias.</source>
          <target state="translated">すべてのタスクとエイリアスを一覧表示するか、指定されたタスクやエイリアスのドキュメントを表示します。</target>
        </trans-unit>
        <trans-unit id="afec6cb6a10a87d6a4707e28871420191c221295" translate="yes" xml:space="preserve">
          <source>Lists are compared element by element.</source>
          <target state="translated">リストは要素ごとに比較されます。</target>
        </trans-unit>
        <trans-unit id="ab57d49cbf8304700835035bc3343277d30e43d1" translate="yes" xml:space="preserve">
          <source>Lists are stored in memory as linked lists, meaning that each element in a list holds its value and points to the following element until the end of the list is reached. This means accessing the length of a list is a linear operation: we need to traverse the whole list in order to figure out its size.</source>
          <target state="translated">つまり、リストの各要素はその値を保持し、リストの最後に到達するまで次の要素を指し示します。これは、リストの長さにアクセスするのは直線的な操作であることを意味します。</target>
        </trans-unit>
        <trans-unit id="c01ea530434a00d0b1bc3bdc3aad101f3c850abd" translate="yes" xml:space="preserve">
          <source>Lists command line arguments.</source>
          <target state="translated">コマンドライン引数をリストアップします。</target>
        </trans-unit>
        <trans-unit id="347e071fbc04592a3c2f0d22435ec182a39831ba" translate="yes" xml:space="preserve">
          <source>Lists in Elixir are effectively linked lists, which means they are internally represented in pairs containing the head and the tail of a list:</source>
          <target state="translated">つまり、リストの先頭と末尾を含むペアで内部的に表現されます。</target>
        </trans-unit>
        <trans-unit id="1298ac093986653b2f114a6ee0f3b99d3384eec7" translate="yes" xml:space="preserve">
          <source>Lists in Elixir are specified between square brackets:</source>
          <target state="translated">Elixir のリストは角括弧で区切って指定します。</target>
        </trans-unit>
        <trans-unit id="bca74458ce5102822957d2008558c1693dad3f4a" translate="yes" xml:space="preserve">
          <source>Lists or tuples?</source>
          <target state="translated">リストかタプルか?</target>
        </trans-unit>
        <trans-unit id="c6c37e3f50d97e7e2b3eda7fd75f9f8b70fa1609" translate="yes" xml:space="preserve">
          <source>Lists, tuples and binaries</source>
          <target state="translated">リスト、タプル、バイナリ</target>
        </trans-unit>
        <trans-unit id="d8107e4dcdc428ba751fa94c9e388d0ea60cfc3c" translate="yes" xml:space="preserve">
          <source>Lists, tuples, bitstrings, maps, structs and function calls will be broken into multiple lines if they are followed by a newline in the opening bracket and preceded by a new line in the closing bracket</source>
          <target state="translated">リスト、タプル、ビットストリング、マップ、構造体、関数呼び出しは、開始カッコの中に改行が続き、終了カッコの中に改行が続く場合、複数行に分割されます。</target>
        </trans-unit>
        <trans-unit id="c7ba7dcf662374aafe652b03d75cb8f6024519d9" translate="yes" xml:space="preserve">
          <source>Literals</source>
          <target state="translated">Literals</target>
        </trans-unit>
        <trans-unit id="91cb6ed4366e6af4c20b2f0bc91cc0d0ee8e284b" translate="yes" xml:space="preserve">
          <source>Loading an application &lt;em&gt;does not&lt;/em&gt; load its modules.</source>
          <target state="translated">アプリケーションをロードしても、そのモジュール&lt;em&gt;は&lt;/em&gt;ロードされ&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="d0935c21f18347f738724d92e6a79d6627db8bae" translate="yes" xml:space="preserve">
          <source>Loading applications</source>
          <target state="translated">アプリケーションの読み込み</target>
        </trans-unit>
        <trans-unit id="c59cbcfe056227b16292e8dcaf0f66d26224a608" translate="yes" xml:space="preserve">
          <source>Loading the application does not start it nor load its modules, but it does load its environment.</source>
          <target state="translated">アプリケーションをロードしてもアプリケーションは起動しませんし、モジュールもロードしませんが、環境はロードします。</target>
        </trans-unit>
        <trans-unit id="44008e484aac635c82b9da39454ca6c5bef5b635" translate="yes" xml:space="preserve">
          <source>Loads all tasks in all code paths.</source>
          <target state="translated">すべてのコードパスですべてのタスクをロードします。</target>
        </trans-unit>
        <trans-unit id="1dbb1340da45613eb5e47a83d481795deec9b49b" translate="yes" xml:space="preserve">
          <source>Loads all tasks in the given &lt;code&gt;paths&lt;/code&gt;.</source>
          <target state="translated">指定された &lt;code&gt;paths&lt;/code&gt; すべてのタスクをロードします。</target>
        </trans-unit>
        <trans-unit id="6a92b205586e28caa29fbe576471eda29c1f626c" translate="yes" xml:space="preserve">
          <source>Loads and persists the given configuration.</source>
          <target state="translated">指定された設定をロードして保持します。</target>
        </trans-unit>
        <trans-unit id="d2d1c8786ab6d688901e2d0162afd3bc568f68c4" translate="yes" xml:space="preserve">
          <source>Loads configuration (typically during system boot).</source>
          <target state="translated">設定をロードします (通常はシステム起動時)。</target>
        </trans-unit>
        <trans-unit id="d450693304ac525200ed85aa5542f49d5d24954d" translate="yes" xml:space="preserve">
          <source>Loads the given &lt;code&gt;app&lt;/code&gt;.</source>
          <target state="translated">指定された &lt;code&gt;app&lt;/code&gt; ロードします。</target>
        </trans-unit>
        <trans-unit id="4fd578a7e27c9f4784b221dfd1d03ff6846abec8" translate="yes" xml:space="preserve">
          <source>Loads the given module's BEAM code (and ensures any previous old version was properly purged before).</source>
          <target state="translated">与えられたモジュールのBEAMコードをロードします(以前の古いバージョンが適切にパージされていることを確認します)。</target>
        </trans-unit>
        <trans-unit id="e7dac36771b4d5bc036c611c2f7df6898fe52037" translate="yes" xml:space="preserve">
          <source>Local or imported functions, like &lt;code&gt;is_function/1&lt;/code&gt;, can be captured without the module:</source>
          <target state="translated">&lt;code&gt;is_function/1&lt;/code&gt; などのローカル関数またはインポートされた関数は、モジュールなしでキャプチャできます。</target>
        </trans-unit>
        <trans-unit id="432e91b2470debe1e676502753dc671697ff7218" translate="yes" xml:space="preserve">
          <source>Locates an executable on the system.</source>
          <target state="translated">システム上の実行ファイルを探します。</target>
        </trans-unit>
        <trans-unit id="e8a78f610457f7b34429c88bd804c091eff64c5b" translate="yes" xml:space="preserve">
          <source>Log Capture</source>
          <target state="translated">ログキャプチャ</target>
        </trans-unit>
        <trans-unit id="8432c24573f3f89fad60802fe8eddf1da6315768" translate="yes" xml:space="preserve">
          <source>Logger</source>
          <target state="translated">Logger</target>
        </trans-unit>
        <trans-unit id="e437244b86e77b12e48c1b63d73645f8df74961f" translate="yes" xml:space="preserve">
          <source>Logger allows developers to rewrite log messages provided by OTP applications into a format more compatible with Elixir log messages by providing a translator.</source>
          <target state="translated">Logger は、OTP アプリケーションによって提供されるログメッセージを、トランスレータを提供することで Elixir のログメッセージとより互換性のある形式に書き換えることができます。</target>
        </trans-unit>
        <trans-unit id="36bf6b0f69a87a997107e50234a8ec7d11ea5aa8" translate="yes" xml:space="preserve">
          <source>Logger also allows log commands to be removed altogether via the &lt;code&gt;:compile_time_purge_matching&lt;/code&gt; option (see below).</source>
          <target state="translated">Loggerでは、 &lt;code&gt;:compile_time_purge_matching&lt;/code&gt; オプションを使用して、ログコマンドを完全に削除することもできます（以下を参照）。</target>
        </trans-unit>
        <trans-unit id="8a326883d3565753f9205b6be5a10ab0cd08e9df" translate="yes" xml:space="preserve">
          <source>Logger.Formatter</source>
          <target state="translated">Logger.Formatter</target>
        </trans-unit>
        <trans-unit id="c6794a4db89c0fa5b4754efb325fa721edd588e7" translate="yes" xml:space="preserve">
          <source>Logger.Translator</source>
          <target state="translated">Logger.Translator</target>
        </trans-unit>
        <trans-unit id="4791cfde57458131db6ad4f6f84effd24dfd10fe" translate="yes" xml:space="preserve">
          <source>Logging is useful for tracking when an event of interest happens in your system. For example, it may be helpful to log whenever a user is deleted.</source>
          <target state="translated">ロギングは、システム内で関心のあるイベントが発生したときに追跡するのに便利です。例えば、ユーザーが削除されたときにログを取ると便利です。</target>
        </trans-unit>
        <trans-unit id="d82e7897f57da03eff4b9dc774004c8bcf4326e9" translate="yes" xml:space="preserve">
          <source>Logs a debug message.</source>
          <target state="translated">デバッグメッセージを記録します。</target>
        </trans-unit>
        <trans-unit id="b4f850d54fddb163d71bfcfbc339485cc6394592" translate="yes" xml:space="preserve">
          <source>Logs a message dynamically.</source>
          <target state="translated">メッセージを動的にログに記録します。</target>
        </trans-unit>
        <trans-unit id="06c091f6fe5aa4035d2433eb7a7a7cc257fb6374" translate="yes" xml:space="preserve">
          <source>Logs a message with the given &lt;code&gt;level&lt;/code&gt;.</source>
          <target state="translated">指定された &lt;code&gt;level&lt;/code&gt; メッセージを記録します。</target>
        </trans-unit>
        <trans-unit id="f285f97af4e85c90120c456b1bce9cedc8d1aeef" translate="yes" xml:space="preserve">
          <source>Logs a warning message.</source>
          <target state="translated">警告メッセージをログに記録します。</target>
        </trans-unit>
        <trans-unit id="a25a9314514d900aacc22fbb93de516450433e79" translate="yes" xml:space="preserve">
          <source>Logs an error message.</source>
          <target state="translated">エラーメッセージをログに記録します。</target>
        </trans-unit>
        <trans-unit id="162237ff6bb976909c470a90784d4d60906673ae" translate="yes" xml:space="preserve">
          <source>Logs an info message.</source>
          <target state="translated">情報メッセージを記録します。</target>
        </trans-unit>
        <trans-unit id="72bca69a37a582766cb9db5733429c69102e1391" translate="yes" xml:space="preserve">
          <source>Looking up, dispatching and registering are efficient and immediate at the cost of delayed unsubscription. For example, if a process crashes, its keys are automatically removed from the registry but the change may not propagate immediately. This means certain operations may return processes that are already dead. When such may happen, it will be explicitly stated in the function documentation.</source>
          <target state="translated">ルックアップ、ディスパッチ、登録は効率的で即時性がありますが、その代償としてサブスクリプションの解除が遅れることがあります。例えば、プロセスがクラッシュした場合、そのキーは自動的にレジストリから削除されますが、変更はすぐには伝わらないかもしれません。つまり、特定の操作によっては、すでに死んでいるプロセスが返される可能性があるということです。そのような場合は、関数のドキュメントに明示的に記載されています。</target>
        </trans-unit>
        <trans-unit id="a76b17c2d110d14324113df51e0e794c11ea854e" translate="yes" xml:space="preserve">
          <source>Loops through recursion</source>
          <target state="translated">再帰によるループ</target>
        </trans-unit>
        <trans-unit id="ce14143dfcbe7563bba16cee9e6c1288ad57742d" translate="yes" xml:space="preserve">
          <source>Low-level function that parses one option.</source>
          <target state="translated">1つのオプションを解析する低レベル関数。</target>
        </trans-unit>
        <trans-unit id="87c8129c4541d2520131c98fdc81bf241066a22c" translate="yes" xml:space="preserve">
          <source>Luckily for us, &lt;code&gt;use GenServer&lt;/code&gt; already defines a &lt;code&gt;Stack.child_spec/1&lt;/code&gt; exactly like above. If you need to customize the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, you can pass the options directly to &lt;code&gt;use GenServer&lt;/code&gt;:</source>
          <target state="translated">幸いにも、 &lt;code&gt;use GenServer&lt;/code&gt; と、上記とまったく同じように &lt;code&gt;Stack.child_spec/1&lt;/code&gt; が既に定義されています。&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;をカスタマイズする必要がある場合は、オプションを直接渡して &lt;code&gt;use GenServer&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="86ad4dfa78b62650b87ab367b0252fd1102bb2f8" translate="yes" xml:space="preserve">
          <source>Luckily, Elixir comes with the ability to package all of the code we have written so far into a single directory, that also includes Elixir and the Erlang Virtual Machine, that has a simple entry point and supports custom configuration. This feature is called releases and it provides many other benefits, which we will see next.</source>
          <target state="translated">幸いなことに、Elixirにはこれまで書いてきたすべてのコードを一つのディレクトリにパッケージ化する機能があります。この機能はリリースと呼ばれ、他にも多くの利点があります。</target>
        </trans-unit>
        <trans-unit id="101e18c9daa819a9267241f7255d5c640b1be10f" translate="yes" xml:space="preserve">
          <source>Luckily, ExUnit ships with a facility to tag tests, allowing us to run specific callbacks or even filter tests altogether based on those tags. We have already used the &lt;code&gt;:capture_log&lt;/code&gt; tag in the previous chapter, which has its semantics specified by ExUnit itself.</source>
          <target state="translated">幸いなことに、ExUnitにはテストにタグを付ける機能が同梱されており、特定のコールバックを実行したり、それらのタグに基づいてテストを完全にフィルター処理したりできます。前の章では、すでに &lt;code&gt;:capture_log&lt;/code&gt; タグを使用しており、そのセマンティクスはExUnit自体で指定されています。</target>
        </trans-unit>
        <trans-unit id="f6e05c123ace841510b2c0f0d5c37124c1c1ac0a" translate="yes" xml:space="preserve">
          <source>Luckily, comprehensions also support the &lt;code&gt;:reduce&lt;/code&gt; option, which would allow us to fuse both steps above into a single step:</source>
          <target state="translated">幸いにも、内包表記は &lt;code&gt;:reduce&lt;/code&gt; オプションもサポートしています。これにより、上記の両方の手順を1つの手順に融合できます。</target>
        </trans-unit>
        <trans-unit id="6a0e82f7ee7ffbbb6bfa830a8dab2a14c17f4f0b" translate="yes" xml:space="preserve">
          <source>Luckily, since the server is being supervised by a supervisor, the supervisor will automatically start a new one, with the initial stack of &lt;code&gt;[:hello]&lt;/code&gt;:</source>
          <target state="translated">幸い、サーバーはスーパーバイザによって監視されているため、スーパーバイザは &lt;code&gt;[:hello]&lt;/code&gt; の初期スタックで新しいサーバーを自動的に起動します。</target>
        </trans-unit>
        <trans-unit id="660bf78961f4ec6bd8bd8b37a3b0b2769db2b14a" translate="yes" xml:space="preserve">
          <source>Macro</source>
          <target state="translated">Macro</target>
        </trans-unit>
        <trans-unit id="da945cd7b80c7fc643a9901f3920877667af55e2" translate="yes" xml:space="preserve">
          <source>Macro hygiene</source>
          <target state="translated">マクロ衛生</target>
        </trans-unit>
        <trans-unit id="7bc6dcd111ca7252229f4855c8539442f853483e" translate="yes" xml:space="preserve">
          <source>Macro-based shortcut for &lt;a href=&quot;iex#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;iex#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; の&lt;/a&gt;マクロベースのショートカット。</target>
        </trans-unit>
        <trans-unit id="56c6a3e6a300260cc21833777ce7d3713e7a1c93" translate="yes" xml:space="preserve">
          <source>Macro.Env</source>
          <target state="translated">Macro.Env</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="2deb7bcc40200f28604560fb6b4cce5afe26789d" translate="yes" xml:space="preserve">
          <source>Macros (local or remote)</source>
          <target state="translated">マクロ(ローカルまたはリモート</target>
        </trans-unit>
        <trans-unit id="17db1c00f2577b6b0146445c282a04ec08ca8847" translate="yes" xml:space="preserve">
          <source>Macros are a powerful construct and Elixir provides many mechanisms to ensure they are used responsibly.</source>
          <target state="translated">マクロは強力な構成要素であり、Elixirはそれらを責任を持って使用するための多くのメカニズムを提供しています。</target>
        </trans-unit>
        <trans-unit id="00166ad41fa2f0b9c76fb59ee48021936b95d500" translate="yes" xml:space="preserve">
          <source>Macros are explicit: it is impossible to run a macro without explicitly invoking it. For example, some languages allow developers to completely rewrite functions behind the scenes, often via parse transforms or via some reflection mechanisms. In Elixir, a macro must be explicitly invoked in the caller during compilation time.</source>
          <target state="translated">マクロは明示的です:明示的に呼び出さないとマクロを実行できません。たとえば、いくつかの言語では、関数を舞台裏で完全に書き換えることができるようになっています。Elixir では、コンパイル時に呼び出し元でマクロを明示的に呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="e631dd92a600a70cff32b8106215cf69b67f9804" translate="yes" xml:space="preserve">
          <source>Macros are hygienic: by default, variables defined inside a macro are not going to affect the user code. Furthermore, function calls and aliases available in the macro context are not going to leak into the user context.</source>
          <target state="translated">マクロは衛生的です:デフォルトでは、マクロ内で定義された変数がユーザーコードに影響を与えることはありません。さらに、マクロのコンテキストで利用可能な関数呼び出しやエイリアスがユーザーのコンテキストに漏れることはありません。</target>
        </trans-unit>
        <trans-unit id="7c5ff8a95ca37f321e50193978d8305c5ccd794f" translate="yes" xml:space="preserve">
          <source>Macros are lexical: it is impossible to inject code or macros globally. In order to use a macro, you need to explicitly &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; the module that defines the macro.</source>
          <target state="translated">マクロは語彙的です。コードやマクロをグローバルに挿入することは不可能です。マクロを使用するには、マクロを定義するモジュールを明示的に &lt;code&gt;require&lt;/code&gt; または &lt;code&gt;import&lt;/code&gt; する必要があります。</target>
        </trans-unit>
        <trans-unit id="78cdc77e6f4d92297e11673135be19d518a8e9cb" translate="yes" xml:space="preserve">
          <source>Macros cannot be overridden as functions and vice-versa.</source>
          <target state="translated">マクロを関数としてオーバーライドすることはできません。</target>
        </trans-unit>
        <trans-unit id="46e2c2440131ab61167e8cad993833b1e1b2ca92" translate="yes" xml:space="preserve">
          <source>Macros constructed out of any combination of the above guards are also valid guards - for example, &lt;a href=&quot;integer#is_even/1&quot;&gt;&lt;code&gt;Integer.is_even/1&lt;/code&gt;&lt;/a&gt;. For more information, see the &quot;Defining custom guard expressions&quot; section shown below.</source>
          <target state="translated">上記のガードの任意の組み合わせから構築されたマクロも有効なガードです（例：&lt;a href=&quot;integer#is_even/1&quot;&gt; &lt;code&gt;Integer.is_even/1&lt;/code&gt; )&lt;/a&gt;。詳細については、以下の「カスタムガード式の定義」セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="b376d89a5de38d7ee4620680cefcbdb63a1fa6c3" translate="yes" xml:space="preserve">
          <source>Macros in Elixir are defined via &lt;code&gt;defmacro/2&lt;/code&gt;.</source>
          <target state="translated">Elixirのマクロは &lt;code&gt;defmacro/2&lt;/code&gt; で定義されます。</target>
        </trans-unit>
        <trans-unit id="8b493bc2b5a09e10063b11f52cb46148a75373e5" translate="yes" xml:space="preserve">
          <source>Macros must be defined before its usage.</source>
          <target state="translated">マクロは使用する前に定義しておく必要があります。</target>
        </trans-unit>
        <trans-unit id="f3a7dd931c836a0537e89bdd7c632c8f1674beb8" translate="yes" xml:space="preserve">
          <source>Macros receive quoted expressions and must return quoted expressions. However, sometimes during the execution of a macro, you may need to work with values and making a distinction between values and quoted expressions will be required.</source>
          <target state="translated">マクロは引用符で囲まれた式を受け取り、引用符で囲まれた式を返さなければなりません。しかし、マクロの実行中に値を扱う必要がある場合があり、値と引用符で囲まれた式を区別する必要があります。</target>
        </trans-unit>
        <trans-unit id="1b8816a712333def9173d859165b24e9a1e3080d" translate="yes" xml:space="preserve">
          <source>Macros&amp;rsquo; language is clear: many languages provide syntax shortcuts for &lt;code&gt;quote&lt;/code&gt; and &lt;code&gt;unquote&lt;/code&gt;. In Elixir, we preferred to have them explicitly spelled out, in order to clearly delimit the boundaries of a macro definition and its quoted expressions.</source>
          <target state="translated">マクロの言語は明確です。多くの言語では、 &lt;code&gt;quote&lt;/code&gt; および &lt;code&gt;unquote&lt;/code&gt; の構文ショートカットが提供されています。エリクサーでは、マクロ定義と引用された式の境界を明確に区切るために、それらを明示的にスペルアウトすることを推奨しました。</target>
        </trans-unit>
        <trans-unit id="38c7f5915403fb594e00a22038d846f701385048" translate="yes" xml:space="preserve">
          <source>Makes a synchronous call to the &lt;code&gt;server&lt;/code&gt; and waits for its reply.</source>
          <target state="translated">&lt;code&gt;server&lt;/code&gt; への同期呼び出しを行い、その応答を待ちます。</target>
        </trans-unit>
        <trans-unit id="d5ca136246f74496fc6eddff8b632654647bdfab" translate="yes" xml:space="preserve">
          <source>Makes the given functions in &lt;code&gt;module&lt;/code&gt; overridable.</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; 内の指定された関数をオーバーライド可能にします。</target>
        </trans-unit>
        <trans-unit id="1d1d2f57486d38837141355b4d2874a9bddc93c3" translate="yes" xml:space="preserve">
          <source>Makes the given functions in the current module overridable.</source>
          <target state="translated">現在のモジュール内の与えられた関数をオーバーライド可能にします。</target>
        </trans-unit>
        <trans-unit id="7fddc4eb9e8f75d21673b2839ad36111f23d7c3e" translate="yes" xml:space="preserve">
          <source>Manually implementing protocols for all types can quickly become repetitive and tedious. In such cases, Elixir provides two options: we can explicitly derive the protocol implementation for our types or automatically implement the protocol for all types. In both cases, we need to implement the protocol for &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">すべてのタイプのプロトコルを手動で実装すると、すぐに繰り返しが多くなり、面倒になります。このような場合、Elixirは2つのオプションを提供します。型のプロトコル実装を明示的に導出するか、すべての型のプロトコルを自動的に実装できます。どちらの場合も、 &lt;code&gt;Any&lt;/code&gt; のプロトコルを実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="d459cd939d93634c990e044cf24d22485f3ceefe" translate="yes" xml:space="preserve">
          <source>Manually it can be started as:</source>
          <target state="translated">手動では以下のように起動できます。</target>
        </trans-unit>
        <trans-unit id="c0e455aaea813fc20786176867857a89ebbb1b93" translate="yes" xml:space="preserve">
          <source>Many functions come in pairs, such as &lt;a href=&quot;file#read/1&quot;&gt;&lt;code&gt;File.read/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;file#read!/1&quot;&gt;&lt;code&gt;File.read!/1&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;file#read/1&quot;&gt;&lt;code&gt;File.read/1&lt;/code&gt;&lt;/a&gt; will return a success or failure tuple, whereas &lt;a href=&quot;file#read!/1&quot;&gt;&lt;code&gt;File.read!/1&lt;/code&gt;&lt;/a&gt; will return a plain value or else raise an exception:</source>
          <target state="translated">&lt;a href=&quot;file#read/1&quot;&gt; &lt;code&gt;File.read/1&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;file#read!/1&quot;&gt; &lt;code&gt;File.read!/1&lt;/code&gt; &lt;/a&gt;など、多くの関数はペアで提供されます。&lt;a href=&quot;file#read/1&quot;&gt; &lt;code&gt;File.read/1&lt;/code&gt; &lt;/a&gt;は成功または失敗のタプルを返し&lt;a href=&quot;file#read!/1&quot;&gt; &lt;code&gt;File.read!/1&lt;/code&gt; &lt;/a&gt;、File.read！/ 1はプレーンな値を返すか、例外を発生させます。</target>
        </trans-unit>
        <trans-unit id="df33d2958d307f1a594471fa7f01b0b82a2cb968" translate="yes" xml:space="preserve">
          <source>Many functions for maps, which implement the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol, are found in the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module. Additionally, the following functions for maps are found in &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;プロトコルを実装するマップの多くの関数は、&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;モジュールにあります。さらに、マップには次の関数が&lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; にあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="27ff6822734db6cb62b200fe4ffc5f764d2dde53" translate="yes" xml:space="preserve">
          <source>Many functions in the &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; module require a time zone database. By default, it uses the default time zone database returned by &lt;a href=&quot;calendar#get_time_zone_database/0&quot;&gt;&lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt;&lt;/a&gt;, which defaults to &lt;a href=&quot;calendar.utconlytimezonedatabase&quot;&gt;&lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt;&lt;/a&gt; which only handles &quot;Etc/UTC&quot; datetimes and returns &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; for any other time zone.</source>
          <target state="translated">&lt;a href=&quot;datetime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;モジュールの多くの関数には、タイムゾーンデータベースが必要です。デフォルトでは、によって返されるデフォルトのタイム・ゾーン・データベース使用&lt;a href=&quot;calendar#get_time_zone_database/0&quot;&gt; &lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt; &lt;/a&gt;、デフォルト&lt;a href=&quot;calendar.utconlytimezonedatabase&quot;&gt; &lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt; &lt;/a&gt;のみ「など/ UTC」日付時刻戻るハンドル &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; の任意の他の時間帯のために。</target>
        </trans-unit>
        <trans-unit id="4225573b276c588447af042b7625b6428887292b" translate="yes" xml:space="preserve">
          <source>Many functions in the &lt;code&gt;Stream&lt;/code&gt; module accept any enumerable as an argument and return a stream as a result. It also provides functions for creating streams. For example, &lt;code&gt;Stream.cycle/1&lt;/code&gt; can be used to create a stream that cycles a given enumerable infinitely. Be careful to not call a function like &lt;code&gt;Enum.map/2&lt;/code&gt; on such streams, as they would cycle forever:</source>
          <target state="translated">&lt;code&gt;Stream&lt;/code&gt; モジュールの多くの関数は、列挙型を引数として受け入れ、結果としてストリームを返します。また、ストリームを作成するための関数も提供します。たとえば、 &lt;code&gt;Stream.cycle/1&lt;/code&gt; を使用して、指定された列挙型を無限に循環させるストリームを作成できます。このようなストリームでは、 &lt;code&gt;Enum.map/2&lt;/code&gt; / 2のような関数を呼び出さないように注意してください。それらは永久に循環します。</target>
        </trans-unit>
        <trans-unit id="76056aa626b027c1c23fdbd95796d51843ce0c06" translate="yes" xml:space="preserve">
          <source>Many functions in the standard library follow the pattern of having a counterpart that raises an exception instead of returning tuples to match against. The convention is to create a function (&lt;code&gt;foo&lt;/code&gt;) which returns &lt;code&gt;{:ok, result}&lt;/code&gt; or &lt;code&gt;{:error, reason}&lt;/code&gt; tuples and another function (&lt;code&gt;foo!&lt;/code&gt;, same name but with a trailing &lt;code&gt;!&lt;/code&gt;) that takes the same arguments as &lt;code&gt;foo&lt;/code&gt; but which raises an exception if there&amp;rsquo;s an error. &lt;code&gt;foo!&lt;/code&gt; should return the result (not wrapped in a tuple) if everything goes fine. The &lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt;&lt;code&gt;File&lt;/code&gt; module&lt;/a&gt; is a good example of this convention.</source>
          <target state="translated">標準ライブラリの多くの関数は、一致するタプルを返す代わりに例外を発生させる対応物を持つパターンに従います。規則は、（関数を作成することである &lt;code&gt;foo&lt;/code&gt; ）を返す &lt;code&gt;{:ok, result}&lt;/code&gt; 又は &lt;code&gt;{:error, reason}&lt;/code&gt; タプルと他の機能（ &lt;code&gt;foo!&lt;/code&gt; 、同じ名前で末尾有する &lt;code&gt;!&lt;/code&gt; 同じ引数をとる） &lt;code&gt;foo&lt;/code&gt; が、これエラーが発生した場合は、例外が発生します。 &lt;code&gt;foo!&lt;/code&gt; すべてが正常に終了した場合は、（タプルでラップされていない）結果を返す必要があります。&lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt; &lt;code&gt;File&lt;/code&gt; モジュールは、&lt;/a&gt;この規則の良い例です。</target>
        </trans-unit>
        <trans-unit id="3703d2917265895ef0ac89964db0000551fe6a21" translate="yes" xml:space="preserve">
          <source>Many functions in this module expect an IO device as an argument. An IO device must be a PID or an atom representing a process. For convenience, Elixir provides &lt;code&gt;:stdio&lt;/code&gt; and &lt;code&gt;:stderr&lt;/code&gt; as shortcuts to Erlang's &lt;code&gt;:standard_io&lt;/code&gt; and &lt;code&gt;:standard_error&lt;/code&gt;.</source>
          <target state="translated">このモジュールの多くの関数は、引数としてIOデバイスを想定しています。IOデバイスは、PIDまたはプロセスを表すアトムでなければなりません。Elixirは、Erlangの &lt;code&gt;:standard_io&lt;/code&gt; および &lt;code&gt;:standard_error&lt;/code&gt; へのショートカットとして、便宜上、 &lt;code&gt;:stdio&lt;/code&gt; および &lt;code&gt;:stderr&lt;/code&gt; を提供しています。</target>
        </trans-unit>
        <trans-unit id="9f2d10ee74f910ee80e0d898322396bd24b9b002" translate="yes" xml:space="preserve">
          <source>Many functions in this module handle what to capture in a regex match via the &lt;code&gt;:capture&lt;/code&gt; option. The supported values are:</source>
          <target state="translated">このモジュールの多くの関数は、 &lt;code&gt;:capture&lt;/code&gt; オプションを介して正規表現の一致でキャプチャするものを処理します。サポートされている値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="d206ef06c5b999d69bec023c3ecff2ae2d89ff16" translate="yes" xml:space="preserve">
          <source>Many functions in this module require a time zone database. By default, it uses the default time zone database returned by &lt;a href=&quot;calendar#get_time_zone_database/0&quot;&gt;&lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt;&lt;/a&gt;, which defaults to &lt;a href=&quot;calendar.utconlytimezonedatabase&quot;&gt;&lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt;&lt;/a&gt; which only handles &quot;Etc/UTC&quot; datetimes and returns &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; for any other time zone.</source>
          <target state="translated">このモジュールの多くの機能には、タイムゾーンデータベースが必要です。デフォルトでは、によって返されるデフォルトのタイム・ゾーン・データベース使用&lt;a href=&quot;calendar#get_time_zone_database/0&quot;&gt; &lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt; &lt;/a&gt;、デフォルト&lt;a href=&quot;calendar.utconlytimezonedatabase&quot;&gt; &lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt; &lt;/a&gt;のみ「など/ UTC」日付時刻戻るハンドル &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; の任意の他の時間帯のために。</target>
        </trans-unit>
        <trans-unit id="94392a82be4b05528cead70b8bc5d289f9e18ce9" translate="yes" xml:space="preserve">
          <source>Many functions in this module work with patterns. For example, &lt;a href=&quot;string#split/2&quot;&gt;&lt;code&gt;String.split/2&lt;/code&gt;&lt;/a&gt; can split a string into multiple strings given a pattern. This pattern can be a string, a list of strings or a compiled pattern:</source>
          <target state="translated">このモジュールの多くの関数はパターンで動作します。たとえば、&lt;a href=&quot;string#split/2&quot;&gt; &lt;code&gt;String.split/2&lt;/code&gt; &lt;/a&gt;は、パターンを指定して、文字列を複数の文字列に分割できます。このパターンは、文字列、文字列のリスト、またはコンパイルされたパターンです。</target>
        </trans-unit>
        <trans-unit id="90b7eedb69a34d71ed449486b5fd918febba2efc" translate="yes" xml:space="preserve">
          <source>Many modules share the same public API. Take a look at &lt;a href=&quot;https://github.com/elixir-lang/plug&quot;&gt;Plug&lt;/a&gt;, which, as its description states, is a &lt;strong&gt;specification&lt;/strong&gt; for composable modules in web applications. Each &lt;em&gt;plug&lt;/em&gt; is a module which &lt;strong&gt;has to&lt;/strong&gt; implement at least two public functions: &lt;code&gt;init/1&lt;/code&gt; and &lt;code&gt;call/2&lt;/code&gt;.</source>
          <target state="translated">多くのモジュールが同じパブリックAPIを共有しています。&lt;a href=&quot;https://github.com/elixir-lang/plug&quot;&gt;Plugを&lt;/a&gt;見てください。Plug は、&lt;strong&gt;説明&lt;/strong&gt;のとおり、Webアプリケーションの構成可能なモジュールの&lt;strong&gt;仕様&lt;/strong&gt;です。各&lt;em&gt;プラグ&lt;/em&gt;は、少なくとも2つのパブリック関数（ &lt;code&gt;init/1&lt;/code&gt; および &lt;code&gt;call/2&lt;/code&gt; )&lt;strong&gt;を&lt;/strong&gt;実装する必要があるモジュールです。</target>
        </trans-unit>
        <trans-unit id="9bad4be1f2158b40250d3557f87cd91435ba7e8c" translate="yes" xml:space="preserve">
          <source>Many of the functions defined in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module internally call this function. This function is also used when the square-brackets access syntax (&lt;code&gt;structure[key]&lt;/code&gt;) is used: the &lt;a href=&quot;#fetch/2&quot;&gt;&lt;code&gt;fetch/2&lt;/code&gt;&lt;/a&gt; callback implemented by the module that defines the &lt;code&gt;structure&lt;/code&gt; struct is invoked and if it returns &lt;code&gt;{:ok, value}&lt;/code&gt; then &lt;code&gt;value&lt;/code&gt; is returned, or if it returns &lt;code&gt;:error&lt;/code&gt; then &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt;モジュールで定義されている関数の多くは、この関数を内部的に呼び出します。この関数は、角かっこアクセス構文（ &lt;code&gt;structure[key]&lt;/code&gt; ）が使用されている場合にも使用されます。 &lt;code&gt;structure&lt;/code&gt; 体struct を定義するモジュールによって実装された&lt;a href=&quot;#fetch/2&quot;&gt; &lt;code&gt;fetch/2&lt;/code&gt; &lt;/a&gt;コールバックが呼び出され、それが &lt;code&gt;{:ok, value}&lt;/code&gt; 返す場合、 &lt;code&gt;value&lt;/code&gt; は返された場合、または &lt;code&gt;:error&lt;/code&gt; が返された場合は &lt;code&gt;nil&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="4c4ca56f0d69fbdc55846e32a022e68f99af15e8" translate="yes" xml:space="preserve">
          <source>Many of the functions in the &lt;code&gt;Macro&lt;/code&gt; module expect an environment. You can read more about these functions in &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html&quot;&gt;the docs for the &lt;code&gt;Macro&lt;/code&gt; module&lt;/a&gt; and learn more about the compilation environment in the &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.Env.html&quot;&gt;docs for &lt;code&gt;Macro.Env&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Macro&lt;/code&gt; モジュールの関数の多くは、環境を想定しています。これらの関数の詳細について&lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html&quot;&gt;は、 &lt;code&gt;Macro&lt;/code&gt; モジュール&lt;/a&gt;の&lt;a href=&quot;https://hexdocs.pm/elixir/Macro.Env.html&quot;&gt;ドキュメントを &lt;code&gt;Macro.Env&lt;/code&gt; &lt;/a&gt;。コンパイル環境の詳細については、Macro.Envのドキュメントをご覧ください。</target>
        </trans-unit>
        <trans-unit id="4faffc8eead5983ad100523dbff786e387103bd2" translate="yes" xml:space="preserve">
          <source>Many of the functions provided for lists, which implement the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol, are found in the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt;プロトコルを実装するリスト用に提供される関数の多くは、&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;モジュールにあります。</target>
        </trans-unit>
        <trans-unit id="be6b19c2b27acff99f70a4437bfc926f0a1ca658" translate="yes" xml:space="preserve">
          <source>Many options can be given by using &lt;code&gt;-&lt;/code&gt; as separator. Order is arbitrary, so the following are all equivalent:</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; をセパレータとして使用すると、多くのオプションを指定できます。順序は任意であるため、以下はすべて同等です。</target>
        </trans-unit>
        <trans-unit id="76b2e23669853bc8630b7ea68a605ae31ce73aeb" translate="yes" xml:space="preserve">
          <source>Many times, inspecting a structure can be implemented in function of existing entities. For example, here is &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;'s &lt;a href=&quot;#inspect/2&quot;&gt;&lt;code&gt;inspect/2&lt;/code&gt;&lt;/a&gt; implementation:</source>
          <target state="translated">多くの場合、構造の検査は既存のエンティティの機能で実装できます。たとえば、&lt;a href=&quot;mapset&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt;の&lt;a href=&quot;#inspect/2&quot;&gt; &lt;code&gt;inspect/2&lt;/code&gt; &lt;/a&gt;実装は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="c31339a8063fd1ca05b6a5ed0e592c82381795d2" translate="yes" xml:space="preserve">
          <source>Map/dictionary as 2nd argument in &lt;a href=&quot;enum#group_by/3&quot;&gt;&lt;code&gt;Enum.group_by/3&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;enum#group_by/3&quot;&gt; &lt;code&gt;Enum.group_by/3&lt;/code&gt; の&lt;/a&gt; 2番目の引数としてのMap / dictionary</target>
        </trans-unit>
        <trans-unit id="6f349d9040ff8d6dc02443f2129355396470884e" translate="yes" xml:space="preserve">
          <source>MapSet</source>
          <target state="translated">MapSet</target>
        </trans-unit>
        <trans-unit id="80071cd75107cd5c4afdb2571725ea6733631038" translate="yes" xml:space="preserve">
          <source>Maps</source>
          <target state="translated">Maps</target>
        </trans-unit>
        <trans-unit id="faaabe818891c225544bd509dabd125356710ead" translate="yes" xml:space="preserve">
          <source>Maps allow any value as a key.</source>
          <target state="translated">マップでは、任意の値をキーとして使用することができます。</target>
        </trans-unit>
        <trans-unit id="d7aa9999474ccd32fc79bec268d52ee73d62bb49" translate="yes" xml:space="preserve">
          <source>Maps also support a specific update syntax to update the value stored under &lt;em&gt;existing&lt;/em&gt; atom keys:</source>
          <target state="translated">マップは、&lt;em&gt;既存の&lt;/em&gt;アトムキーの下に格納されている値を更新するための特定の更新構文もサポートしています。</target>
        </trans-unit>
        <trans-unit id="23b5fbc085bbfa528c48b36100e97092a1cc1ad4" translate="yes" xml:space="preserve">
          <source>Maps and joins the given &lt;code&gt;enumerable&lt;/code&gt; in one pass.</source>
          <target state="translated">指定された &lt;code&gt;enumerable&lt;/code&gt; を1つのパスでマップして結合します。</target>
        </trans-unit>
        <trans-unit id="5099fc13865ed694619ef238561f1ff1eb21e4ca" translate="yes" xml:space="preserve">
          <source>Maps and keyword lists</source>
          <target state="translated">地図とキーワード一覧</target>
        </trans-unit>
        <trans-unit id="382a893f2fca3eb55b96aa13fc13acceacd045d1" translate="yes" xml:space="preserve">
          <source>Maps and reduces an &lt;code&gt;enumerable&lt;/code&gt;, flattening the given results (only one level deep).</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; マッピングして削減し、指定された結果を平坦化します（深さ1レベルのみ）。</target>
        </trans-unit>
        <trans-unit id="f6cdae6c2a90bda1af5114211ccb41e8558a58da" translate="yes" xml:space="preserve">
          <source>Maps are compared by size, then by keys in ascending term order, then by values in key order. In the specific case of maps' key ordering, integers are always considered to be less than floats.</source>
          <target state="translated">マップはサイズによって比較され、次に項の昇順でキーによって比較され、次にキー順で値によって比較されます。マップのキー順の特定のケースでは、整数は常にフロートよりも小さいと考えられています。</target>
        </trans-unit>
        <trans-unit id="2c58aeb4eaddeb4b19dfc3e5c22984c273b6c491" translate="yes" xml:space="preserve">
          <source>Maps are the &quot;go to&quot; key-value data structure in Elixir. Maps can be created with the &lt;code&gt;%{}&lt;/code&gt; syntax, and key-value pairs can be expressed as &lt;code&gt;key =&amp;gt; value&lt;/code&gt;:</source>
          <target state="translated">マップは、Elixirの「移動先」のKey-Valueデータ構造です。マップは &lt;code&gt;%{}&lt;/code&gt; 構文で作成でき、キーと値のペアは &lt;code&gt;key =&amp;gt; value&lt;/code&gt; として表現できます。</target>
        </trans-unit>
        <trans-unit id="c8f244270ac78647558651f3076ad4902cf12b49" translate="yes" xml:space="preserve">
          <source>Maps can be pattern matched on. When a map is on the left-hand side of a pattern match, it will match if the map on the right-hand side contains the keys on the left-hand side and their values match the ones on the left-hand side. This means that an empty map matches every map.</source>
          <target state="translated">マップは、パターン マッチの左側にある場合、右側のマップに左側のキーが含まれていて、その値が左側のキーと一致している場合にマッチします。マップがパターン マッチの左側にある場合、右側のマップに左側のキーが含まれており、その値が左側のキーと一致する場合にマッチします。これは、空のマップがすべてのマップにマッチすることを意味します。</target>
        </trans-unit>
        <trans-unit id="4bdce2ba7f6c277727a64d1e4440d7e5012f407e" translate="yes" xml:space="preserve">
          <source>Maps do not impose any restriction on the key type: anything can be a key in a map. As a key-value structure, maps do not allow duplicated keys. Keys are compared using the exact-equality operator (&lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;). If colliding keys are defined in a map literal, the last one prevails.</source>
          <target state="translated">マップはキーのタイプに制限を課しません。マップのキーは何でもかまいません。キーと値の構造として、マップは重複したキーを許可しません。キーは、完全等価演算子（&lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; &lt;/a&gt;）を使用して比較されます。衝突するキーがマップリテラルで定義されている場合、最後のキーが優先されます。</target>
        </trans-unit>
        <trans-unit id="bd2672e5330a5447b3c12c9d7516bbd11a97aa64" translate="yes" xml:space="preserve">
          <source>Maps have the following syntax for updating a key&amp;rsquo;s value:</source>
          <target state="translated">マップには、キーの値を更新するための次の構文があります。</target>
        </trans-unit>
        <trans-unit id="b18104f0603d252465f48bc07dbe82afd8a5d572" translate="yes" xml:space="preserve">
          <source>Maps the given &lt;code&gt;fun&lt;/code&gt; over &lt;code&gt;enumerable&lt;/code&gt; and flattens the result.</source>
          <target state="translated">指定 &lt;code&gt;fun&lt;/code&gt; れたfunを &lt;code&gt;enumerable&lt;/code&gt; マップし、結果を平坦化します。</target>
        </trans-unit>
        <trans-unit id="5204e90c54387d7f6b5371b939a57cc337fb682b" translate="yes" xml:space="preserve">
          <source>Maps use the &lt;code&gt;%{...}&lt;/code&gt; notation and each key-value is given by pairs marked with &lt;code&gt;=&amp;gt;&lt;/code&gt;, such as &lt;code&gt;%{&quot;hello&quot; =&amp;gt; 1, 2 =&amp;gt; &quot;world&quot;}&lt;/code&gt;.</source>
          <target state="translated">マップは &lt;code&gt;%{...}&lt;/code&gt; 表記を使用し、各Key-Valueは &lt;code&gt;%{&quot;hello&quot; =&amp;gt; 1, 2 =&amp;gt; &quot;world&quot;}&lt;/code&gt; ように &lt;code&gt;=&amp;gt;&lt;/code&gt; でマークされたペアで与えられます。</target>
        </trans-unit>
        <trans-unit id="5b30399c385e93b1607671f629e3c17811777473" translate="yes" xml:space="preserve">
          <source>Maps&amp;rsquo; keys do not follow any ordering.</source>
          <target state="translated">マップのキーは順序付けに従いません。</target>
        </trans-unit>
        <trans-unit id="23e67fceae0d77dd571dd25695fc0499faf1bb77" translate="yes" xml:space="preserve">
          <source>Markdown</source>
          <target state="translated">Markdown</target>
        </trans-unit>
        <trans-unit id="ec2d3f7496eeae736a17fb6cfbbc3d6cec0ede8f" translate="yes" xml:space="preserve">
          <source>Markdown uses backticks (&lt;code&gt;`&lt;/code&gt;) to quote code. Elixir builds on top of that to automatically generate links when module or function names are referenced. For this reason, always use full module names. If you have a module called &lt;code&gt;MyApp.Hello&lt;/code&gt;, always reference it as &lt;code&gt;`MyApp.Hello`&lt;/code&gt; and never as &lt;code&gt;`Hello`&lt;/code&gt;.</source>
          <target state="translated">Markdownは、バッククォート（ &lt;code&gt;`&lt;/code&gt; ）を使用してコードを引用します。Elixirはその上に構築され、モジュールまたは関数名が参照されたときにリンクを自動的に生成します。このため、常に完全なモジュール名を使用してください。あなたが呼ばれるモジュールがある場合は &lt;code&gt;MyApp.Hello&lt;/code&gt; を、いつものようにそれを参照 &lt;code&gt;`MyApp.Hello`&lt;/code&gt; として、決して &lt;code&gt;`Hello`&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="217f8bccae9fba9687ba7ff03998f906b2857c1d" translate="yes" xml:space="preserve">
          <source>Markers &lt;code&gt;&quot;/&quot;&lt;/code&gt; and &lt;code&gt;&quot;|&quot;&lt;/code&gt; are only for use in custom EEx engines and are not implemented by default. Using them without an appropriate implementation raises &lt;a href=&quot;eex.syntaxerror&quot;&gt;&lt;code&gt;EEx.SyntaxError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">マーカー &lt;code&gt;&quot;/&quot;&lt;/code&gt; と &lt;code&gt;&quot;|&quot;&lt;/code&gt; カスタムEExエンジンでのみ使用され、デフォルトでは実装されていません。適切な実装なしでそれらを使用すると、&lt;a href=&quot;eex.syntaxerror&quot;&gt; &lt;code&gt;EEx.SyntaxError&lt;/code&gt; &lt;/a&gt;が発生します。</target>
        </trans-unit>
        <trans-unit id="caae004dd7762602ee13f32c3606f690c674cc52" translate="yes" xml:space="preserve">
          <source>Marks if the system should halt or not at the end of ARGV processing.</source>
          <target state="translated">ARGV処理の終了時にシステムを停止させるかどうかをマークします。</target>
        </trans-unit>
        <trans-unit id="e8df966767fbd3a383c53216799beb4b4564cb74" translate="yes" xml:space="preserve">
          <source>Mastering Markdown</source>
          <target state="translated">マークダウンをマスターする</target>
        </trans-unit>
        <trans-unit id="158acb8638a5ae524e2b6bf247590e2b87f6ec4d" translate="yes" xml:space="preserve">
          <source>MatchError</source>
          <target state="translated">MatchError</target>
        </trans-unit>
        <trans-unit id="96751a5eacdf747401e9907e7e83faf6f1a03e3b" translate="yes" xml:space="preserve">
          <source>MatchError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">MatchError &lt;small&gt;例外&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="ee2dbd5d6d82d0833069b07e7dd2848d3bf4d83a" translate="yes" xml:space="preserve">
          <source>Matches</source>
          <target state="translated">Matches</target>
        </trans-unit>
        <trans-unit id="2d84b42f8474be5f06fc1fe6eb6ae40c8a64822a" translate="yes" xml:space="preserve">
          <source>Matches on or builds a struct.</source>
          <target state="translated">構造体にマッチするか、構造体を構築します。</target>
        </trans-unit>
        <trans-unit id="d1c12ec871d541a72434054efa8076c09aed8fb5" translate="yes" xml:space="preserve">
          <source>Matches the given expression against the given clauses.</source>
          <target state="translated">与えられた句に対して与えられた式をマッチさせます。</target>
        </trans-unit>
        <trans-unit id="8b76a5c96001ffefea3cc84097a4d45e79f04e10" translate="yes" xml:space="preserve">
          <source>Matches the term on the &lt;code&gt;left&lt;/code&gt; against the regular expression or string on the &lt;code&gt;right&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;left&lt;/code&gt; の用語を &lt;code&gt;right&lt;/code&gt; 正規表現または文字列と照合します。</target>
        </trans-unit>
        <trans-unit id="213cb6a13e45b535bfa6e1acc183ec880d53557f" translate="yes" xml:space="preserve">
          <source>Matches the value on the right against the pattern on the left.</source>
          <target state="translated">右側の値と左側のパターンを一致させます。</target>
        </trans-unit>
        <trans-unit id="b35bb5e881268b8de9b651fa2e51e3623ab167b7" translate="yes" xml:space="preserve">
          <source>Mechanism for handling behaviours.</source>
          <target state="translated">行動を処理する仕組み。</target>
        </trans-unit>
        <trans-unit id="0f436c24ccfa651b93064f0d2e54084d164dc06e" translate="yes" xml:space="preserve">
          <source>Membership is tested with the match (&lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;) operator.</source>
          <target state="translated">メンバーシップは、一致（&lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; &lt;/a&gt;）演算子でテストされます。</target>
        </trans-unit>
        <trans-unit id="d89ba7d209c7ddc88fd31bf2598cbf585fb0aa81" translate="yes" xml:space="preserve">
          <source>Merges two URIs.</source>
          <target state="translated">2つのURIをマージします。</target>
        </trans-unit>
        <trans-unit id="4069e43ecbf8943679ac63e2d6e02de8e6a7137b" translate="yes" xml:space="preserve">
          <source>Merges two configurations.</source>
          <target state="translated">2つの構成をマージします。</target>
        </trans-unit>
        <trans-unit id="a9fa5b094d178e27f7bd2a2b568ea8b694678d55" translate="yes" xml:space="preserve">
          <source>Merges two keyword lists into one.</source>
          <target state="translated">2つのキーワードリストを1つに統合します。</target>
        </trans-unit>
        <trans-unit id="acf0cf4f2e4c966874470b9f049a43c211b544d9" translate="yes" xml:space="preserve">
          <source>Merges two maps into one, resolving conflicts through the given &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">2つのマップを1つにマージし、指定された &lt;code&gt;fun&lt;/code&gt; を通じて競合を解決します。</target>
        </trans-unit>
        <trans-unit id="472d94b64a8f716f1678ee270e1d1c87f01b9840" translate="yes" xml:space="preserve">
          <source>Merges two maps into one.</source>
          <target state="translated">2 つのマップを 1 つに統合します。</target>
        </trans-unit>
        <trans-unit id="243261baef2add3b3b97656268303e291d4fa8b4" translate="yes" xml:space="preserve">
          <source>Message and function APIs</source>
          <target state="translated">メッセージと関数のAPI</target>
        </trans-unit>
        <trans-unit id="62a587d636afdda61a08b5027d8d771633fc5216" translate="yes" xml:space="preserve">
          <source>Message format</source>
          <target state="translated">メッセージ形式</target>
        </trans-unit>
        <trans-unit id="7d9a0f1c2be58d1d8ee9acd43a53bc9fde228a1e" translate="yes" xml:space="preserve">
          <source>Meta-programming</source>
          <target state="translated">Meta-programming</target>
        </trans-unit>
        <trans-unit id="9ce697e52d7e466c89411bf1535cdf6ff43e22f1" translate="yes" xml:space="preserve">
          <source>Meta-programming guide</source>
          <target state="translated">メタプログラミングガイド</target>
        </trans-unit>
        <trans-unit id="fa22e0676cd79851be85b6434a7e6e08111fa009" translate="yes" xml:space="preserve">
          <source>Meta-programming in Elixir</source>
          <target state="translated">Elixirでのメタプログラミング</target>
        </trans-unit>
        <trans-unit id="251edc0eb5a820646bda4e103f0f007fd55321f3" translate="yes" xml:space="preserve">
          <source>Metadata</source>
          <target state="translated">Metadata</target>
        </trans-unit>
        <trans-unit id="7f0cf2cb1796c66f262f9ca3a16a007623f8614c" translate="yes" xml:space="preserve">
          <source>Metadata can have any key. Documentation tools often use metadata to provide more data to readers and to enrich the user experience.</source>
          <target state="translated">メタデータは任意のキーを持つことができます。ドキュメンテーションツールは、読者に多くのデータを提供し、ユーザーエクスペリエンスを豊かにするためにメタデータを使用することが多い。</target>
        </trans-unit>
        <trans-unit id="ae75c0cef5625d04c957fd4d6945de2e3cb52281" translate="yes" xml:space="preserve">
          <source>Metadata to be sent to the logger can be read and written with the &lt;a href=&quot;logger#metadata/0&quot;&gt;&lt;code&gt;Logger.metadata/0&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;logger#metadata/1&quot;&gt;&lt;code&gt;Logger.metadata/1&lt;/code&gt;&lt;/a&gt; functions. For example, you can set &lt;code&gt;Logger.metadata([user_id: 13])&lt;/code&gt; to add user_id metadata to the current process. The user can configure the backend to choose which metadata it wants to print and it will replace the &lt;code&gt;$metadata&lt;/code&gt; value.</source>
          <target state="translated">ロガーに送信されるメタデータは、&lt;a href=&quot;logger#metadata/0&quot;&gt; &lt;code&gt;Logger.metadata/0&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;logger#metadata/1&quot;&gt; &lt;code&gt;Logger.metadata/1&lt;/code&gt; &lt;/a&gt;関数で読み書きできます。たとえば、 &lt;code&gt;Logger.metadata([user_id: 13])&lt;/code&gt; を設定して、現在のプロセスにuser_idメタデータを追加できます。ユーザーはバックエンドを構成して、印刷するメタデータを選択でき、 &lt;code&gt;$metadata&lt;/code&gt; 値を置き換えます。</target>
        </trans-unit>
        <trans-unit id="996eccb481568235d0a028deddc16efa49e5113a" translate="yes" xml:space="preserve">
          <source>Microseconds can also be given with a precision, which must be an integer between 0 and 6.</source>
          <target state="translated">また、マイクロ秒には精度を与えることができ、これは0から6までの整数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="dfde79a8eeb31b646662fce17bc79e76db2d4ad1" translate="yes" xml:space="preserve">
          <source>Microseconds with stored precision.</source>
          <target state="translated">蓄積された精度を持つマイクロ秒。</target>
        </trans-unit>
        <trans-unit id="ae8f2632075078189571124ccbd2fa14d6202a8b" translate="yes" xml:space="preserve">
          <source>Migrating from &lt;code&gt;use Mix.Config&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;use Mix.Config&lt;/code&gt; からの移行</target>
        </trans-unit>
        <trans-unit id="7e092faa3e25342ecf5028acae902f24fdcd4cfc" translate="yes" xml:space="preserve">
          <source>Migrating from Supervisor's :simple_one_for_one</source>
          <target state="translated">スーパーバイザーの :simple_one_for_one からの移行</target>
        </trans-unit>
        <trans-unit id="119fff5ad66da150ab8b91c4f195f7205786f58d" translate="yes" xml:space="preserve">
          <source>Missing parent directories are created. Returns &lt;code&gt;:ok&lt;/code&gt; if successful, or &lt;code&gt;{:error, reason}&lt;/code&gt; if an error occurs.</source>
          <target state="translated">見つからない親ディレクトリが作成されます。成功した場合は &lt;code&gt;:ok&lt;/code&gt; を返し、エラーが発生した場合は &lt;code&gt;{:error, reason}&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="9e60798bf941d9439890dc6ea1e2b3874b037fa8" translate="yes" xml:space="preserve">
          <source>Missing parent directories are not created. Returns &lt;code&gt;:ok&lt;/code&gt; if successful, or &lt;code&gt;{:error, reason}&lt;/code&gt; if an error occurs.</source>
          <target state="translated">欠落している親ディレクトリは作成されません。成功した場合は &lt;code&gt;:ok&lt;/code&gt; を返し、エラーが発生した場合は &lt;code&gt;{:error, reason}&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="fd7391b6720b809c7c41ed50cf63fdc87dac6b9d" translate="yes" xml:space="preserve">
          <source>Mix</source>
          <target state="translated">Mix</target>
        </trans-unit>
        <trans-unit id="8a48b8da8f54401b98b40a13634225508f5d8cd7" translate="yes" xml:space="preserve">
          <source>Mix Tasks</source>
          <target state="translated">ミックスタスク</target>
        </trans-unit>
        <trans-unit id="adf80b3737e1d992babad11068b089417997b0c6" translate="yes" xml:space="preserve">
          <source>Mix also falls back to the &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; and &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; environment variables when storing its contents and configuration.</source>
          <target state="translated">Mixは、コンテンツと構成を保存するときに、 &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; および &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; 環境変数にもフォールバックします。</target>
        </trans-unit>
        <trans-unit id="fad17235fd472ad3a611eb5939096f52cba44598" translate="yes" xml:space="preserve">
          <source>Mix also generated a file named &lt;code&gt;test/test_helper.exs&lt;/code&gt; which is responsible for setting up the test framework:</source>
          <target state="translated">Mix は、テストフレームワークのセットアップを担当する &lt;code&gt;test/test_helper.exs&lt;/code&gt; という名前のファイルも生成しました。</target>
        </trans-unit>
        <trans-unit id="d5f417a1b2c5b2cf642913e1126e746153ac794c" translate="yes" xml:space="preserve">
          <source>Mix also generated the appropriate structure for running our project tests. Mix projects usually follow the convention of having a &lt;code&gt;&amp;lt;filename&amp;gt;_test.exs&lt;/code&gt; file in the &lt;code&gt;test&lt;/code&gt; directory for each file in the &lt;code&gt;lib&lt;/code&gt; directory. For this reason, we can already find a &lt;code&gt;test/kv_test.exs&lt;/code&gt; corresponding to our &lt;code&gt;lib/kv.ex&lt;/code&gt; file. It doesn&amp;rsquo;t do much at this point:</source>
          <target state="translated">Mixは、プロジェクトテストを実行するための適切な構造も生成しました。ミックスプロジェクトは通常、 &lt;code&gt;lib&lt;/code&gt; ディレクトリの各ファイルの &lt;code&gt;test&lt;/code&gt; ディレクトリに &lt;code&gt;&amp;lt;filename&amp;gt;_test.exs&lt;/code&gt; ファイルを置くという慣例に従います。このため、 &lt;code&gt;lib/kv.ex&lt;/code&gt; ファイルに対応する &lt;code&gt;test/kv_test.exs&lt;/code&gt; をすでに見つけることができます。この時点ではあまり機能しません。</target>
        </trans-unit>
        <trans-unit id="e787071e1565ddba8a2e537f8771328f0ffb3a18" translate="yes" xml:space="preserve">
          <source>Mix also generates a file at &lt;code&gt;lib/kv.ex&lt;/code&gt; with a module containing exactly one function, called &lt;code&gt;hello&lt;/code&gt;:</source>
          <target state="translated">Mixは、 &lt;code&gt;hello&lt;/code&gt; と呼ばれる関数を1つだけ含むモジュールを含むファイルを &lt;code&gt;lib/kv.ex&lt;/code&gt; に生成します。</target>
        </trans-unit>
        <trans-unit id="71bacf97d94e38a4255175d63dd82250400f8cac" translate="yes" xml:space="preserve">
          <source>Mix also manages your dependencies and integrates nicely with the &lt;a href=&quot;https://hex.pm&quot;&gt;Hex package manager&lt;/a&gt;.</source>
          <target state="translated">Mixは依存関係も管理し、&lt;a href=&quot;https://hex.pm&quot;&gt;Hexパッケージマネージャー&lt;/a&gt;とうまく統合します。</target>
        </trans-unit>
        <trans-unit id="02fd3a28a69477778e8b16f7b3cce09332f74ae5" translate="yes" xml:space="preserve">
          <source>Mix also supports Git and path dependencies:</source>
          <target state="translated">MixはGitとパスの依存関係もサポートしています。</target>
        </trans-unit>
        <trans-unit id="04bb9bcfa3927d3cae40daaaa838d4ef230a39cd" translate="yes" xml:space="preserve">
          <source>Mix and OTP</source>
          <target state="translated">ミックスとOTP</target>
        </trans-unit>
        <trans-unit id="d25cf695ebdb9d0aee542ce2f227391b7ee2bf55" translate="yes" xml:space="preserve">
          <source>Mix and OTP guide</source>
          <target state="translated">ミックスとOTPガイド</target>
        </trans-unit>
        <trans-unit id="a2a56ce9bc8efd270013eaafce32886b18ad521f" translate="yes" xml:space="preserve">
          <source>Mix can be used to manage Erlang projects that don't have any Elixir code. To ensure Mix tasks work correctly for an Erlang project, &lt;code&gt;language: :erlang&lt;/code&gt; has to be part of the configuration returned by &lt;code&gt;project/0&lt;/code&gt;. This setting also makes sure Elixir is not added as a dependency to the generated &lt;code&gt;.app&lt;/code&gt; file or to the escript generated with &lt;a href=&quot;mix.tasks.escript.build&quot;&gt;&lt;code&gt;mix escript.build&lt;/code&gt;&lt;/a&gt;, and so on.</source>
          <target state="translated">Mixは、Elixirコードを持たないErlangプロジェクトの管理に使用できます。ErlangプロジェクトでMixタスクが正しく機能するようにするには、 &lt;code&gt;language: :erlang&lt;/code&gt; が &lt;code&gt;project/0&lt;/code&gt; によって返される構成の一部である必要があります。この設定は、生成された &lt;code&gt;.app&lt;/code&gt; ファイルまたは&lt;a href=&quot;mix.tasks.escript.build&quot;&gt; &lt;code&gt;mix escript.build&lt;/code&gt; &lt;/a&gt;で生成されたescriptなどへの依存関係としてElixirが追加されないようにします。</target>
        </trans-unit>
        <trans-unit id="2cdb0b1920ef5553ebcd1f21161694f9fc79e940" translate="yes" xml:space="preserve">
          <source>Mix is a build tool and, as such, it is not expected to be available in production. Therefore, it is recommended to access &lt;code&gt;Mix.env&lt;/code&gt; only in configuration files and inside &lt;code&gt;mix.exs&lt;/code&gt;, never in your application code (&lt;code&gt;lib&lt;/code&gt;).</source>
          <target state="translated">Mixはビルドツールであるため、本番環境で使用できるとは考えられていません。したがって、アプリケーションコード（ &lt;code&gt;lib&lt;/code&gt; ） &lt;code&gt;Mix.env&lt;/code&gt; なく、構成ファイルと &lt;code&gt;mix.exs&lt;/code&gt; 内でのみMix.envにアクセスすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="c6da9856af4245149570c16ec4188fc5d3115e0f" translate="yes" xml:space="preserve">
          <source>Mix is a build tool that provides tasks for creating, compiling, and testing Elixir projects, managing its dependencies, and more.</source>
          <target state="translated">Mixは、Elixirプロジェクトの作成、コンパイル、テスト、依存関係の管理などのタスクを提供するビルドツールです。</target>
        </trans-unit>
        <trans-unit id="a0df83a511be738d9e0de24c58fdbe9cd553aa72" translate="yes" xml:space="preserve">
          <source>Mix is the project management and build tool for Elixir. Invoking &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt; from the command line will run the tests in each file matching the pattern &lt;code&gt;*_test.exs&lt;/code&gt; found in the &lt;code&gt;test&lt;/code&gt; directory of your project.</source>
          <target state="translated">Mixは、Elixirのプロジェクト管理およびビルドツールです。コマンドラインから&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt; &lt;code&gt;mix test&lt;/code&gt; &lt;/a&gt;を呼び出すと、プロジェクトの &lt;code&gt;test&lt;/code&gt; ディレクトリにある &lt;code&gt;*_test.exs&lt;/code&gt; パターンに一致する各ファイルでテストが実行されます。</target>
        </trans-unit>
        <trans-unit id="6efd811f3c57b4beedb58b4c74d9cfc0e7bd84d8" translate="yes" xml:space="preserve">
          <source>Mix makes a distinction between projects and applications. Based on the contents of our &lt;code&gt;mix.exs&lt;/code&gt; file, we would say we have a Mix project that defines the &lt;code&gt;:kv&lt;/code&gt; application. As we will see in later chapters, there are projects that don&amp;rsquo;t define any application.</source>
          <target state="translated">Mixは、プロジェクトとアプリケーションを区別します。私たちの &lt;code&gt;mix.exs&lt;/code&gt; ファイルの内容に基づいて、 &lt;code&gt;:kv&lt;/code&gt; アプリケーションを定義するMixプロジェクトがあるとします。後の章で見るように、アプリケーションを定義しないプロジェクトがあります。</target>
        </trans-unit>
        <trans-unit id="648fcb70fef0f7b235a3a4efb99b43d14093584b" translate="yes" xml:space="preserve">
          <source>Mix provides many tasks for working with dependencies, which can be seen in &lt;code&gt;mix help&lt;/code&gt;:</source>
          <target state="translated">Mixは、依存関係を操作するための多くのタスクを提供します。これらは、 &lt;code&gt;mix help&lt;/code&gt; で確認できます。</target>
        </trans-unit>
        <trans-unit id="6ad0076d881adfffd287f386c898dd8d3dfe63d9" translate="yes" xml:space="preserve">
          <source>Mix provides the concept of &amp;ldquo;environments&amp;rdquo;. They allow a developer to customize compilation and other options for specific scenarios. By default, Mix understands three environments:</source>
          <target state="translated">Mixは「環境」の概念を提供します。開発者は特定のシナリオに合わせてコンパイルやその他のオプションをカスタマイズできます。デフォルトでは、Mixは3つの環境を理解します。</target>
        </trans-unit>
        <trans-unit id="d0eb4f5b6efc2f498d0a43bf2cce656e8deeb64f" translate="yes" xml:space="preserve">
          <source>Mix responds to the following variables:</source>
          <target state="translated">Mixは以下の変数に反応します。</target>
        </trans-unit>
        <trans-unit id="9083e0d8be0e72f0bd60c89828382861a3d53dd0" translate="yes" xml:space="preserve">
          <source>Mix shell that uses the current process mailbox for communication.</source>
          <target state="translated">現在のプロセスのメールボックスを通信に使用するミックスシェル。</target>
        </trans-unit>
        <trans-unit id="ad263de6a1ec790ca04b9e1c0d40a550701c6fa7" translate="yes" xml:space="preserve">
          <source>Mix ships with many tasks under the &lt;code&gt;profile&lt;/code&gt; namespace, such as &lt;code&gt;cprof&lt;/code&gt; and &lt;code&gt;fprof&lt;/code&gt;</source>
          <target state="translated">Mixは、 &lt;code&gt;cprof&lt;/code&gt; や &lt;code&gt;fprof&lt;/code&gt; などの &lt;code&gt;profile&lt;/code&gt; 名前空間の下に多くのタスクを備えて出荷されます</target>
        </trans-unit>
        <trans-unit id="34cf07547ba5e61214e86cb3580e3d48c9fa65b9" translate="yes" xml:space="preserve">
          <source>Mix supports different environments. Environments allow developers to prepare and organize their project specifically for different scenarios. By default, Mix provides three environments:</source>
          <target state="translated">Mixは様々な環境をサポートしています。環境によって、開発者は様々なシナリオに合わせてプロジェクトを準備したり、整理したりすることができます。デフォルトでは、Mix には 3 つの環境が用意されています。</target>
        </trans-unit>
        <trans-unit id="e1d70ab3fabbbe21fc38f850f28d9a31374f92fc" translate="yes" xml:space="preserve">
          <source>Mix tasks are designed to run only once. This prevents the same task to be executed multiple times. For example, if there are several tasks depending on &lt;a href=&quot;mix.tasks.compile&quot;&gt;&lt;code&gt;mix compile&lt;/code&gt;&lt;/a&gt;, the code will be compiled once. Tasks can be executed again if they are explicitly reenabled using &lt;a href=&quot;mix.task#reenable/1&quot;&gt;&lt;code&gt;Mix.Task.reenable/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">混合タスクは1回だけ実行するように設計されています。これにより、同じタスクが複数回実行されるのを防ぎます。たとえば、&lt;a href=&quot;mix.tasks.compile&quot;&gt; &lt;code&gt;mix compile&lt;/code&gt; &lt;/a&gt;に応じていくつかのタスクがある場合、コードは1回コンパイルされます。&lt;a href=&quot;mix.task#reenable/1&quot;&gt; &lt;code&gt;Mix.Task.reenable/1&lt;/code&gt; を&lt;/a&gt;使用して明示的に再度有効にすると、タスクを再度実行できます。</target>
        </trans-unit>
        <trans-unit id="afb48dfad219bb575ed5a6a2a2d6171fe59e0c43" translate="yes" xml:space="preserve">
          <source>Mix will create a directory named &lt;code&gt;kv&lt;/code&gt; with a few files in it:</source>
          <target state="translated">Mixは、いくつかのファイルを含む &lt;code&gt;kv&lt;/code&gt; という名前のディレクトリを作成します。</target>
        </trans-unit>
        <trans-unit id="8fa02d3dbeffdcfedef855ce25999f5c0e80ec49" translate="yes" xml:space="preserve">
          <source>Mix will default to the &lt;code&gt;:dev&lt;/code&gt; environment, except for the &lt;code&gt;test&lt;/code&gt; task that will default to the &lt;code&gt;:test&lt;/code&gt; environment. The environment can be changed via the &lt;code&gt;MIX_ENV&lt;/code&gt; environment variable:</source>
          <target state="translated">Mixのデフォルトは &lt;code&gt;:dev&lt;/code&gt; 環境になりますが、 &lt;code&gt;test&lt;/code&gt; タスクがデフォルトの &lt;code&gt;:test&lt;/code&gt; 環境になります。環境は &lt;code&gt;MIX_ENV&lt;/code&gt; 環境変数を介して変更できます。</target>
        </trans-unit>
        <trans-unit id="399305e4f380845bf197d5745b3fee53dc94ea53" translate="yes" xml:space="preserve">
          <source>Mix will load the &lt;code&gt;test_helper.exs&lt;/code&gt; file before executing the tests. It is not necessary to &lt;code&gt;require&lt;/code&gt; the &lt;code&gt;test_helper.exs&lt;/code&gt; file in your test files. See &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;Mix.Tasks.Test&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">Mixは、テストを実行する前に &lt;code&gt;test_helper.exs&lt;/code&gt; ファイルをロードします。する必要はありません &lt;code&gt;require&lt;/code&gt; &lt;code&gt;test_helper.exs&lt;/code&gt; テストファイル内のファイルを。詳細については、&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt; &lt;code&gt;Mix.Tasks.Test&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="677bfdd437f39d48687e8e09deb896bdab1ffcab" translate="yes" xml:space="preserve">
          <source>Mix.InvalidTaskError</source>
          <target state="translated">Mix.InvalidTaskError</target>
        </trans-unit>
        <trans-unit id="73acde233ddd7f978233bc0c9c03ffcb591e4127" translate="yes" xml:space="preserve">
          <source>Mix.InvalidTaskError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Mix.InvalidTaskError &lt;small&gt;例外&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="5656de2d70dc1fd33545f113c9c31f4468c93c9f" translate="yes" xml:space="preserve">
          <source>Mix.NoProjectError</source>
          <target state="translated">Mix.NoProjectError</target>
        </trans-unit>
        <trans-unit id="a3cd7de13e58b68149c17286a492f048bc5a4f9f" translate="yes" xml:space="preserve">
          <source>Mix.NoProjectError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Mix.NoProjectError &lt;small&gt;例外&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="2296b8a4da20e50fc86db62a76ae3a0f21236d09" translate="yes" xml:space="preserve">
          <source>Mix.NoTaskError</source>
          <target state="translated">Mix.NoTaskError</target>
        </trans-unit>
        <trans-unit id="4758003c8f1681557fd809da1ff272c0a4bdc616" translate="yes" xml:space="preserve">
          <source>Mix.NoTaskError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Mix.NoTaskError &lt;small&gt;例外&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f736ae59e13a4e4114e4af3bf6ddc51b25a5bb36" translate="yes" xml:space="preserve">
          <source>Mix.Project</source>
          <target state="translated">Mix.Project</target>
        </trans-unit>
        <trans-unit id="467f63e6768ca92e850a24bb5559e6ceb3ff2d65" translate="yes" xml:space="preserve">
          <source>Mix.Shell.IO</source>
          <target state="translated">Mix.Shell.IO</target>
        </trans-unit>
        <trans-unit id="ae6604b3cc7069b10edb34181cf30fa1c7e69549" translate="yes" xml:space="preserve">
          <source>Mix.Shell.Process</source>
          <target state="translated">Mix.Shell.Process</target>
        </trans-unit>
        <trans-unit id="d04ad970550a78d0484fc6fba35ca08880a1b57f" translate="yes" xml:space="preserve">
          <source>Mix.Task</source>
          <target state="translated">Mix.Task</target>
        </trans-unit>
        <trans-unit id="426aac8f0abf87df945411bf3866831ccdd5ee99" translate="yes" xml:space="preserve">
          <source>Mix.Task &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Mix.Taskの&lt;small&gt;動作&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f260e757cec75096bc3eefbfb1c4a14720832017" translate="yes" xml:space="preserve">
          <source>Modifier</source>
          <target state="translated">Modifier</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="63368ee0cfe73d65555cc05d160f4780d59c63dd" translate="yes" xml:space="preserve">
          <source>Modifies command line arguments.</source>
          <target state="translated">コマンドライン引数を変更します。</target>
        </trans-unit>
        <trans-unit id="b8ff02892916ff59f7fbd4e617fccd01f6bca576" translate="yes" xml:space="preserve">
          <source>Module</source>
          <target state="translated">Module</target>
        </trans-unit>
        <trans-unit id="9297e283a310f6ab7d943b5269f1a79016e762cb" translate="yes" xml:space="preserve">
          <source>Module &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">モジュールの&lt;small&gt;動作&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9c3f2aba6913de8da00faed8e2df2428bb1257b7" translate="yes" xml:space="preserve">
          <source>Module Attributes</source>
          <target state="translated">モジュール属性</target>
        </trans-unit>
        <trans-unit id="974d46d1f85954ab50d762a7e03d4820f241857f" translate="yes" xml:space="preserve">
          <source>Module and describe tags</source>
          <target state="translated">モジュールと記述タグ</target>
        </trans-unit>
        <trans-unit id="330765efeb90ac3d911657d7500e925bd8f2537b" translate="yes" xml:space="preserve">
          <source>Module attributes</source>
          <target state="translated">モジュール属性</target>
        </trans-unit>
        <trans-unit id="611dbb58b63e5a3205266276e6a852dcaa7a3969" translate="yes" xml:space="preserve">
          <source>Module attributes in Elixir serve three purposes:</source>
          <target state="translated">Elixirのモジュール属性は3つの目的を持っています。</target>
        </trans-unit>
        <trans-unit id="e1e3ec1d59bfdc3e7d0eaa73499821e62209421e" translate="yes" xml:space="preserve">
          <source>Module attributes reader (&lt;code&gt;@foo&lt;/code&gt;)</source>
          <target state="translated">モジュール属性リーダー（ &lt;code&gt;@foo&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="ddfcf23684bdb5ef441d59b66364129fcb4f0309" translate="yes" xml:space="preserve">
          <source>Module nesting</source>
          <target state="translated">モジュールの入れ子</target>
        </trans-unit>
        <trans-unit id="40144123a36c18a55943d34cbb9a342139e699ec" translate="yes" xml:space="preserve">
          <source>Module to work with, define, and import records.</source>
          <target state="translated">レコードの操作、定義、インポートを行うためのモジュールです。</target>
        </trans-unit>
        <trans-unit id="cc1693df58c9640eee91eb5bd91f74e7ad932311" translate="yes" xml:space="preserve">
          <source>Module-based supervisors</source>
          <target state="translated">モジュールベースのスーパーバイザー</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="2f22992ace2b7b2537bcbf08c8e4ceeca5300f8f" translate="yes" xml:space="preserve">
          <source>Modules adopting the &lt;code&gt;Parser&lt;/code&gt; behaviour will have to implement all the functions defined with the &lt;code&gt;@callback&lt;/code&gt; directive. As you can see, &lt;code&gt;@callback&lt;/code&gt; expects a function name but also a function specification like the ones used with the &lt;code&gt;@spec&lt;/code&gt; directive we saw above. Also note that the &lt;code&gt;term&lt;/code&gt; type is used to represent the parsed value. In Elixir, the &lt;code&gt;term&lt;/code&gt; type is a shortcut to represent any type.</source>
          <target state="translated">&lt;code&gt;Parser&lt;/code&gt; 動作を採用するモジュールは、 &lt;code&gt;@callback&lt;/code&gt; ディレクティブで定義されたすべての関数を実装する必要があります。ご覧のとおり、 &lt;code&gt;@callback&lt;/code&gt; は関数名を想定していますが、上記で見た &lt;code&gt;@spec&lt;/code&gt; ディレクティブで使用されるような関数仕様も想定しています。タイプ &lt;code&gt;term&lt;/code&gt; は、解析された値を表すために使用されることにも注意してください。Elixirでは、タイプ &lt;code&gt;term&lt;/code&gt; はあらゆるタイプを表すショートカットです。</target>
        </trans-unit>
        <trans-unit id="dbf8ec2a137ea97fd047b1bf5fb0e081373aaeef" translate="yes" xml:space="preserve">
          <source>Modules and functions</source>
          <target state="translated">モジュールと機能</target>
        </trans-unit>
        <trans-unit id="f95593466c9236f423e2ca78c791a9ed452a97e0" translate="yes" xml:space="preserve">
          <source>Modules compiled with HiPE would not call this hook.</source>
          <target state="translated">HiPEでコンパイルされたモジュールは、このフックを呼び出しません。</target>
        </trans-unit>
        <trans-unit id="5f7948a408bbeb081e3bf4398d0a06535fe04fa6" translate="yes" xml:space="preserve">
          <source>Modules that are not yet loaded won't show up. Check &lt;a href=&quot;#load_all/0&quot;&gt;&lt;code&gt;load_all/0&lt;/code&gt;&lt;/a&gt; if you want to preload all tasks.</source>
          <target state="translated">まだロードされていないモジュールは表示されません。すべてのタスクをプリロードする場合は、&lt;a href=&quot;#load_all/0&quot;&gt; &lt;code&gt;load_all/0&lt;/code&gt; を&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="bda622c46b037f80824387d421dc386c6556e7d2" translate="yes" xml:space="preserve">
          <source>Modules that interface with the underlying system, such as:</source>
          <target state="translated">のような、基盤となるシステムとのインタフェースとなるモジュール。</target>
        </trans-unit>
        <trans-unit id="49fb186a5c3efc09ccd0d283216aa3aefc8c1db1" translate="yes" xml:space="preserve">
          <source>Monitors or links?</source>
          <target state="translated">モニターやリンク?</target>
        </trans-unit>
        <trans-unit id="b5af02a7afd8f398df475e389f375296b40fcadb" translate="yes" xml:space="preserve">
          <source>Monitors the status of the node.</source>
          <target state="translated">ノードの状態を監視します。</target>
        </trans-unit>
        <trans-unit id="531f01d1f3ee72b3521ad6573e9645c241df955d" translate="yes" xml:space="preserve">
          <source>More detailed information is returned if you provide the &lt;code&gt;--callers&lt;/code&gt; and &lt;code&gt;--details&lt;/code&gt; options.</source>
          <target state="translated">&lt;code&gt;--callers&lt;/code&gt; および--detailsオプションを &lt;code&gt;--details&lt;/code&gt; すると、より詳細な情報が返されます。</target>
        </trans-unit>
        <trans-unit id="679fb30706daaf38b9e2ca52a7581c5f7429d440" translate="yes" xml:space="preserve">
          <source>More examples of paired functions: &lt;a href=&quot;base#decode16/2&quot;&gt;&lt;code&gt;Base.decode16/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;base#decode16!/2&quot;&gt;&lt;code&gt;Base.decode16!/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;file#cwd/0&quot;&gt;&lt;code&gt;File.cwd/0&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;file#cwd!/0&quot;&gt;&lt;code&gt;File.cwd!/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ペアになった関数のその他の例：&lt;a href=&quot;base#decode16/2&quot;&gt; &lt;code&gt;Base.decode16/2&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;base#decode16!/2&quot;&gt; &lt;code&gt;Base.decode16!/2&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;file#cwd/0&quot;&gt; &lt;code&gt;File.cwd/0&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;file#cwd!/0&quot;&gt; &lt;code&gt;File.cwd!/0&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b89d915a104252705d1f85ce849ed077d1dac0ac" translate="yes" xml:space="preserve">
          <source>More information about graphemes can be found in the &lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;Unicode Standard Annex #29&lt;/a&gt;. The current Elixir version implements Extended Grapheme Cluster algorithm.</source>
          <target state="translated">書記素の詳細については、&lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;Unicode Standard Annex＃29を参照してください&lt;/a&gt;。現在のElixirバージョンは、拡張Grapheme Clusterアルゴリズムを実装しています。</target>
        </trans-unit>
        <trans-unit id="a5e8684b13528d21f979a1818ef3d359d73c9599" translate="yes" xml:space="preserve">
          <source>More information about the tuple data type and about functions to manipulate tuples can be found in the &lt;a href=&quot;tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; module; some functions for working with tuples are also available in &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; (such as &lt;a href=&quot;kernel#elem/2&quot;&gt;&lt;code&gt;Kernel.elem/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;kernel#tuple_size/1&quot;&gt;&lt;code&gt;Kernel.tuple_size/1&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">タプルのデータ型とタプルを操作する関数の詳細については、&lt;a href=&quot;tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt;モジュールを参照してください。タプルを操作するための一部の関数は、&lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt;も使用できます（&lt;a href=&quot;kernel#elem/2&quot;&gt; &lt;code&gt;Kernel.elem/2&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;kernel#tuple_size/1&quot;&gt; &lt;code&gt;Kernel.tuple_size/1&lt;/code&gt; など&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="430a22fd9616cca59513735ab6a5d8e059b24d05" translate="yes" xml:space="preserve">
          <source>More information on date times can be found in the &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">日時の詳細については、&lt;a href=&quot;datetime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;モジュールを参照してください。</target>
        </trans-unit>
        <trans-unit id="a10a384a2270f2efaa542fb180ccc3a8a8fab8a8" translate="yes" xml:space="preserve">
          <source>More information on dates can be found in the &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">日付の詳細については、&lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;モジュールを参照してください。</target>
        </trans-unit>
        <trans-unit id="1d09563b1d7bf20501a96abf9b569ef7f610dceb" translate="yes" xml:space="preserve">
          <source>More information on naive date times can be found in the &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">単純な日付時刻の詳細については、&lt;a href=&quot;naivedatetime&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt;モジュールを参照してください。</target>
        </trans-unit>
        <trans-unit id="c85521cfa0af914c1bfcc721a8420c6e8c54e6ca" translate="yes" xml:space="preserve">
          <source>More information on regexes can be found in the &lt;a href=&quot;regex&quot;&gt;&lt;code&gt;Regex&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">正規表現の詳細についてはで見つけることができる&lt;a href=&quot;regex&quot;&gt; &lt;code&gt;Regex&lt;/code&gt; &lt;/a&gt;モジュール。</target>
        </trans-unit>
        <trans-unit id="943682535e16011c70352d95eb0b5a94fc51f1ec" translate="yes" xml:space="preserve">
          <source>More information on regular expressions can be found in the &lt;a href=&quot;regex&quot;&gt;&lt;code&gt;Regex&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">正規表現の詳細については、&lt;a href=&quot;regex&quot;&gt; &lt;code&gt;Regex&lt;/code&gt; &lt;/a&gt;モジュールをご覧ください。</target>
        </trans-unit>
        <trans-unit id="74e1febe16a203d4cc3b9b43ca22bede1863da17" translate="yes" xml:space="preserve">
          <source>More information on times can be found in the &lt;a href=&quot;time&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">時間の詳細については、&lt;a href=&quot;time&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt;モジュールを参照してください。</target>
        </trans-unit>
        <trans-unit id="47345d51b5c718e5874fcd01549e8be7ce1a8743" translate="yes" xml:space="preserve">
          <source>More interestingly, we can match on specific values. The example below asserts that the left side will only match the right side when the right side is a tuple that starts with the atom &lt;code&gt;:ok&lt;/code&gt;:</source>
          <target state="translated">さらに興味深いことに、特定の値で照合できます。以下の例では、右側がアトム &lt;code&gt;:ok&lt;/code&gt; で始まるタプルである場合、左側が右側にのみ一致することを表明しています。</target>
        </trans-unit>
        <trans-unit id="708db7ea87e7a72eeea9cb0dbb3ddbd4f2c25b4b" translate="yes" xml:space="preserve">
          <source>More options are available; for the comprehensive list of available options check &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn_opt-4&quot;&gt;&lt;code&gt;:erlang.spawn_opt/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">より多くのオプションが利用可能です。利用可能なオプションの包括的なリストについては、&lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn_opt-4&quot;&gt; &lt;code&gt;:erlang.spawn_opt/4&lt;/code&gt; を&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="0761006711d858b0c2a58d2cbd1afefe913dcc42" translate="yes" xml:space="preserve">
          <source>Moreover, even when trapping exits, calling &lt;code&gt;await&lt;/code&gt; will still exit if the task has terminated without sending its result back.</source>
          <target state="translated">さらに、トラップが終了しても、結果を返さずにタスクが終了した場合、 &lt;code&gt;await&lt;/code&gt; の呼び出しは終了します。</target>
        </trans-unit>
        <trans-unit id="7a438f48c599e07f621f37d7528ee6f6b3ed9813" translate="yes" xml:space="preserve">
          <source>Most Elixir code has a straight-forward translation to its underlying quoted expression. We recommend you try out different code samples and see what the results are. For example, what does &lt;code&gt;String.upcase(&quot;foo&quot;)&lt;/code&gt; expand to? We have also learned that &lt;code&gt;if(true, do: :this, else: :that)&lt;/code&gt; is the same as &lt;code&gt;if true do :this else :that end&lt;/code&gt;. How does this affirmation hold with quoted expressions?</source>
          <target state="translated">ほとんどのElixirコードは、基になる引用された式への直接的な変換を持っています。さまざまなコードサンプルを試して、結果を確認することをお勧めします。たとえば、 &lt;code&gt;String.upcase(&quot;foo&quot;)&lt;/code&gt; は何に展開されますか？ &lt;code&gt;if(true, do: :this, else: :that)&lt;/code&gt; が &lt;code&gt;if true do :this else :that end&lt;/code&gt; と同じであることも学習しました。この肯定は引用された表現でどのように成り立つのですか？</target>
        </trans-unit>
        <trans-unit id="0687907a8d3988b5e082480eea48abedcef483ec" translate="yes" xml:space="preserve">
          <source>Most editors provide built-in integration with the formatter, allowing a file to be formatted on save or via a chosen keybinding. If you are learning Elixir, editor integration gives you useful and quick feedback when learning the Elixir syntax.</source>
          <target state="translated">ほとんどのエディタにはフォーマッタとの統合機能が組み込まれており、保存時や選択したキーバインドを介してファイルをフォーマットすることができます。Elixir を学習している場合は、エディタとの統合により、Elixir の構文を学習する際に便利で迅速なフィードバックを得ることができます。</target>
        </trans-unit>
        <trans-unit id="024156cd258aa614f1a1e84226c2405ec889367a" translate="yes" xml:space="preserve">
          <source>Most of the functions in this module return &lt;code&gt;:ok&lt;/code&gt; or &lt;code&gt;{:ok, result}&lt;/code&gt; in case of success, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise. Those functions also have a variant that ends with &lt;code&gt;!&lt;/code&gt; which returns the result (instead of the &lt;code&gt;{:ok, result}&lt;/code&gt; tuple) in case of success or raises an exception in case it fails. For example:</source>
          <target state="translated">このモジュールのほとんどの関数は、成功した場合は &lt;code&gt;:ok&lt;/code&gt; または &lt;code&gt;{:ok, result}&lt;/code&gt; を返し &lt;code&gt;{:error, reason}&lt;/code&gt; それ以外の場合は{：error、reason}を返します。これらの関数には、 &lt;code&gt;!&lt;/code&gt; で終わるバリアントもあります。成功した場合は（ &lt;code&gt;{:ok, result}&lt;/code&gt; タプルの代わりに）結果を返し、失敗した場合は例外を発生させます。例えば：</target>
        </trans-unit>
        <trans-unit id="dbffd668417f19cdbcd33d0162e5263a21e09ebf" translate="yes" xml:space="preserve">
          <source>Most of the functions in this module work in linear time. This means that, that the time it takes to perform an operation grows at the same rate as the length of the list. For example &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#last/1&quot;&gt;&lt;code&gt;last/1&lt;/code&gt;&lt;/a&gt; will run in linear time because they need to iterate through every element of the list, but &lt;a href=&quot;#first/1&quot;&gt;&lt;code&gt;first/1&lt;/code&gt;&lt;/a&gt; will run in constant time because it only needs the first element.</source>
          <target state="translated">このモジュールのほとんどの関数は線形時間で動作します。つまり、操作の実行にかかる時間は、リストの長さと同じ割合で増加します。たとえば、&lt;a href=&quot;kernel#length/1&quot;&gt; &lt;code&gt;length/1&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#last/1&quot;&gt; &lt;code&gt;last/1&lt;/code&gt; &lt;/a&gt;はリストのすべての要素を反復処理する必要があるため線形時間で実行されますが、&lt;a href=&quot;#first/1&quot;&gt; &lt;code&gt;first/1&lt;/code&gt; &lt;/a&gt;は最初の要素のみを必要とするため一定時間で実行されます。</target>
        </trans-unit>
        <trans-unit id="ce9701b5552f6ac3d94cc4ca928ec6d05512ce0a" translate="yes" xml:space="preserve">
          <source>Most of the functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the list.</source>
          <target state="translated">このモジュールの関数のほとんどは線形時間で動作します。つまり、操作を実行するのにかかる時間は、リストの長さと同じ割合で成長します。</target>
        </trans-unit>
        <trans-unit id="3fd0b4b5634fc00fd0cd07602c5fab763e2a315d" translate="yes" xml:space="preserve">
          <source>Most of the inlined functions can be seen in effect when capturing the function:</source>
          <target state="translated">インライン化された関数のほとんどは、関数をキャプチャしたときにその効果を見ることができます。</target>
        </trans-unit>
        <trans-unit id="650e20466b330f46fc9cd6f719b3f04d44e3661d" translate="yes" xml:space="preserve">
          <source>Most of the operations in &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; are implemented in terms of reduce. This function should apply the given &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function to each element in the &lt;code&gt;enumerable&lt;/code&gt; and proceed as expected by the returned accumulator.</source>
          <target state="translated">&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;の操作のほとんどは、reduceの観点から実装されています。この関数は、 &lt;code&gt;enumerable&lt;/code&gt; 各要素に指定された&lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt;関数を適用し、返されたアキュムレーターが期待どおりに処理する必要があります。</target>
        </trans-unit>
        <trans-unit id="24b137a5b6dba3724d546a7b4386d3d0c4f7db88" translate="yes" xml:space="preserve">
          <source>Most of the time it is convenient to write modules into files so they can be compiled and reused. Let&amp;rsquo;s assume we have a file named &lt;code&gt;math.ex&lt;/code&gt; with the following contents:</source>
          <target state="translated">ほとんどの場合、モジュールをファイルに書き込んでコンパイルおよび再利用できるようにすると便利です。次の内容の &lt;code&gt;math.ex&lt;/code&gt; という名前のファイルがあるとします。</target>
        </trans-unit>
        <trans-unit id="629b5f27dd5283caadd5c5cbf0f295755b9869cd" translate="yes" xml:space="preserve">
          <source>Most of the time there is one, and just one, valid datetime for a certain date and time in a certain time zone.</source>
          <target state="translated">ほとんどの場合、特定の時間帯の特定の日時に有効な日付と時刻が1つだけ存在します。</target>
        </trans-unit>
        <trans-unit id="91857fb8fa18b4cfe30782a8862e99da6ebb9879" translate="yes" xml:space="preserve">
          <source>Most of the time, Elixir is going to guide you to do the right thing. For example, there is an &lt;code&gt;elem/2&lt;/code&gt; function to access a tuple item but there is no built-in equivalent for lists:</source>
          <target state="translated">ほとんどの場合、エリクサーは正しいことをするようにあなたを導きます。たとえば、タプルアイテムにアクセスする &lt;code&gt;elem/2&lt;/code&gt; 関数がありますが、リストに対応する組み込みの関数はありません。</target>
        </trans-unit>
        <trans-unit id="cca16065899804f7768a7a1720aa616e84369d6b" translate="yes" xml:space="preserve">
          <source>Move the undocumented function to a module with &lt;code&gt;@moduledoc false&lt;/code&gt;, like &lt;code&gt;MyApp.Hidden&lt;/code&gt;, ensuring the function won't be accidentally exposed or imported. Remember you can use &lt;code&gt;@moduledoc false&lt;/code&gt; to hide a whole module and still document each function with &lt;code&gt;@doc&lt;/code&gt;. Tools will still ignore the module.</source>
          <target state="translated">ドキュメントに記載されていない関数を &lt;code&gt;@moduledoc false&lt;/code&gt; ような &lt;code&gt;MyApp.Hidden&lt;/code&gt; falseのモジュールに移動します。これにより、関数が誤って公開またはインポートされないようにします。 &lt;code&gt;@moduledoc false&lt;/code&gt; を使用してモジュール全体を非表示にしても、各関数を &lt;code&gt;@doc&lt;/code&gt; で文書化できることに注意してください。ツールは引き続きモジュールを無視します。</target>
        </trans-unit>
        <trans-unit id="8ba586c26244aa844e20201d605ef816e569e0c3" translate="yes" xml:space="preserve">
          <source>Much better! &lt;code&gt;with&lt;/code&gt; will retrieve the value returned by the right-side of &lt;code&gt;&amp;lt;-&lt;/code&gt; and match it against the pattern on the left side. If the value matches the pattern, &lt;code&gt;with&lt;/code&gt; moves on to the next expression. In case there is no match, the non-matching value is returned.</source>
          <target state="translated">ずっといい！ &lt;code&gt;with&lt;/code&gt; は、 &lt;code&gt;&amp;lt;-&lt;/code&gt; の右側から返された値を取得し、左側のパターンと照合します。値がパターンに一致する場合、 &lt;code&gt;with&lt;/code&gt; は次の式に進みます。一致しない場合は、一致しない値が返されます。</target>
        </trans-unit>
        <trans-unit id="aca1d8661416c63356922cc0e796c657256bdbf6" translate="yes" xml:space="preserve">
          <source>Multi alias/import/require/use</source>
          <target state="translated">マルチエイリアス/インポート/要求/使用</target>
        </trans-unit>
        <trans-unit id="600851f745d8c6c136c80bb6740770dde7f94908" translate="yes" xml:space="preserve">
          <source>Multi-letter aliases in &lt;a href=&quot;optionparser&quot;&gt;&lt;code&gt;OptionParser&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;optionparser&quot;&gt; &lt;code&gt;OptionParser&lt;/code&gt; の&lt;/a&gt;複数文字のエイリアス</target>
        </trans-unit>
        <trans-unit id="cd897f3df67fae1b86657cd6f5002662e25d4a84" translate="yes" xml:space="preserve">
          <source>Multi-line charlists are written with three single-quotes (&lt;code&gt;'''&lt;/code&gt;), the same way multi-line strings are.</source>
          <target state="translated">複数行の文字リストは、複数行の文字列と同じように、3つの単一引用符（ &lt;code&gt;'''&lt;/code&gt; ）で記述されます。</target>
        </trans-unit>
        <trans-unit id="971b1abcdb78d0f06496a5acd8f26ed4ec25bf2b" translate="yes" xml:space="preserve">
          <source>Multi-line lists, maps, tuples, etc.</source>
          <target state="translated">複数行のリスト、地図、タプルなど。</target>
        </trans-unit>
        <trans-unit id="387558e9801635e36ced6d8f96c29ddee6395ce1" translate="yes" xml:space="preserve">
          <source>Multi-line strings in Elixir are written with three double-quotes, and can have unescaped quotes within them. The resulting string will end with a newline. The indentation of the last &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; is used to strip indentation from the inner string. For example:</source>
          <target state="translated">Elixirの複数行の文字列は3つの二重引用符で書かれており、エスケープされていない引用符を含めることができます。結果の文字列は改行で終わります。最後の &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; インデントは、内側の文字列からインデントを取り除くために使用されます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="f3b47d6814f63cc5e3bd080a55da0c264aee3d21" translate="yes" xml:space="preserve">
          <source>Multiple code points that may be perceived as a single character by readers</source>
          <target state="translated">読者が1文字として認識する可能性のある複数のコードポイント</target>
        </trans-unit>
        <trans-unit id="6d1f745a36808f93bd028263c26703cfbaed268c" translate="yes" xml:space="preserve">
          <source>Multiple generators can also be used to calculate the cartesian product of two lists:</source>
          <target state="translated">複数のジェネレータを使用して、2つのリストの直交積を計算することもできます。</target>
        </trans-unit>
        <trans-unit id="7fd421a1aa76b2a83bd80d007c37c141c303064d" translate="yes" xml:space="preserve">
          <source>Multiple guards in the same clause</source>
          <target state="translated">同一句に複数のガード</target>
        </trans-unit>
        <trans-unit id="c528525d61b06dbc869c01826c97062225a9a675" translate="yes" xml:space="preserve">
          <source>Multiple implementations</source>
          <target state="translated">複数の実装</target>
        </trans-unit>
        <trans-unit id="f43d8ba152323821f27a132f7581f8caab516e47" translate="yes" xml:space="preserve">
          <source>Multiple releases. You can assemble different releases with different configuration per application or even with different applications altogether.</source>
          <target state="translated">複数のリリース。アプリケーションごとに異なる設定で異なるリリースを組み立てることができます。</target>
        </trans-unit>
        <trans-unit id="8f4cf21f4344405e752af495c43a5b7beb80cfa4" translate="yes" xml:space="preserve">
          <source>Multiple uses of &lt;code&gt;@compile&lt;/code&gt; will accumulate instead of overriding previous ones. See the &quot;Compile options&quot; section below.</source>
          <target state="translated">&lt;code&gt;@compile&lt;/code&gt; を複数回使用すると、以前の使用を上書きする代わりに累積されます。以下の「コンパイルオプション」セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="cbd5985b43b284860bef16f48015f61c53879304" translate="yes" xml:space="preserve">
          <source>Multiple uses of &lt;code&gt;@dialyzer&lt;/code&gt; will accumulate instead of overriding previous ones.</source>
          <target state="translated">&lt;code&gt;@dialyzer&lt;/code&gt; を複数回使用すると、以前の使用を上書きする代わりに累積されます。</target>
        </trans-unit>
        <trans-unit id="4bc08a47511c7c5ad4c0a467eaca187d877e8749" translate="yes" xml:space="preserve">
          <source>Mutable state and access to shared resources (such as ETS, files, etc.)</source>
          <target state="translated">Mutable 状態と共有リソースへのアクセス (ETS、ファイルなど)</target>
        </trans-unit>
        <trans-unit id="74c5ad44b6579fcbcf0c6ec60e160908d2a983ce" translate="yes" xml:space="preserve">
          <source>My computer is named &lt;code&gt;jv&lt;/code&gt;, so I see &lt;code&gt;foo@jv&lt;/code&gt; in the example above, but you will get a different result. We will use &lt;code&gt;foo@computer-name&lt;/code&gt; in the following examples and you should update them accordingly when trying out the code.</source>
          <target state="translated">私のコンピューターの名前は &lt;code&gt;jv&lt;/code&gt; なので、上の例では &lt;code&gt;foo@jv&lt;/code&gt; れていますが、結果は異なります。次の例では &lt;code&gt;foo@computer-name&lt;/code&gt; を使用します。コードを試すときは、それに応じて更新する必要があります。</target>
        </trans-unit>
        <trans-unit id="a50f07a710ba62544947bf23759e42c6e82ff7d6" translate="yes" xml:space="preserve">
          <source>My particular telnet client can be exited by typing &lt;code&gt;ctrl + ]&lt;/code&gt;, typing &lt;code&gt;quit&lt;/code&gt;, and pressing &lt;code&gt;&amp;lt;Enter&amp;gt;&lt;/code&gt;, but your client may require different steps.</source>
          <target state="translated">私の特定のTelnetクライアントは、 &lt;code&gt;ctrl + ]&lt;/code&gt; を入力し、 &lt;code&gt;quit&lt;/code&gt; を入力して &lt;code&gt;&amp;lt;Enter&amp;gt;&lt;/code&gt; を押すことで終了できますが、クライアントによって異なる手順が必要になる場合があります。</target>
        </trans-unit>
        <trans-unit id="b897ebc1430a2e4abc81cf0b2714edf134f99207" translate="yes" xml:space="preserve">
          <source>NaiveDateTime</source>
          <target state="translated">NaiveDateTime</target>
        </trans-unit>
        <trans-unit id="d49675d6a7db398730976978d05575d69c0eb3c3" translate="yes" xml:space="preserve">
          <source>Name registration</source>
          <target state="translated">名前の登録</target>
        </trans-unit>
        <trans-unit id="368a0ab278773b445741a837271772d0936779aa" translate="yes" xml:space="preserve">
          <source>Named functions</source>
          <target state="translated">名前付き関数</target>
        </trans-unit>
        <trans-unit id="b7cb86483160ed9ca9d1ab540d3476197e0162c0" translate="yes" xml:space="preserve">
          <source>Named functions in Elixir also support default arguments:</source>
          <target state="translated">Elixirの名前付き関数もデフォルトの引数をサポートしています。</target>
        </trans-unit>
        <trans-unit id="8b4617b659a51d0b5756991a46730570511eef04" translate="yes" xml:space="preserve">
          <source>Naming</source>
          <target state="translated">Naming</target>
        </trans-unit>
        <trans-unit id="8af56df8a9cb35f56b67edd6d269d4e86defc0d0" translate="yes" xml:space="preserve">
          <source>Naming Conventions</source>
          <target state="translated">命名規約</target>
        </trans-unit>
        <trans-unit id="7c7072ebdd4d3d7903620768f687a8dfdcc8ce66" translate="yes" xml:space="preserve">
          <source>Naming processes</source>
          <target state="translated">ネーミングプロセス</target>
        </trans-unit>
        <trans-unit id="2dafad67b671623ab79a27e34be51e846c44fb41" translate="yes" xml:space="preserve">
          <source>Negation switches</source>
          <target state="translated">ネゲーションスイッチ</target>
        </trans-unit>
        <trans-unit id="6cf669c72f3ca4537fedf1a696188ac323c60bad" translate="yes" xml:space="preserve">
          <source>Negative Unix times are supported, up to -62167219200 seconds, which is equivalent to &quot;0000-01-01T00:00:00Z&quot; or 0 Gregorian seconds.</source>
          <target state="translated">負のUnix時間は-62167219200秒までサポートされており、これは &quot;0000-01-01T00:00:00:00Z &quot;または0グレゴリオ秒に相当します。</target>
        </trans-unit>
        <trans-unit id="a20bdc82e5703dd99f69be3ffeaf120ee97f50f4" translate="yes" xml:space="preserve">
          <source>Negative indices indicate an offset from the end of the &lt;code&gt;list&lt;/code&gt;. If &lt;code&gt;index&lt;/code&gt; is out of bounds, the original &lt;code&gt;list&lt;/code&gt; is returned.</source>
          <target state="translated">負のインデックスは、 &lt;code&gt;list&lt;/code&gt; 最後からのオフセットを示します。場合は &lt;code&gt;index&lt;/code&gt; 範囲外である、オリジナルの &lt;code&gt;list&lt;/code&gt; 返されます。</target>
        </trans-unit>
        <trans-unit id="02f8888aa8ebd456306e0978a35197f74b636d4e" translate="yes" xml:space="preserve">
          <source>Nested data structures</source>
          <target state="translated">入れ子になったデータ構造</target>
        </trans-unit>
        <trans-unit id="f06563daf6842a8e082fd4615e320fc869bb69d9" translate="yes" xml:space="preserve">
          <source>Nesting</source>
          <target state="translated">Nesting</target>
        </trans-unit>
        <trans-unit id="230c22b07521849e4e1eb0ed24d083dc0b4e9329" translate="yes" xml:space="preserve">
          <source>Nesting a module inside another module affects the name of the nested module:</source>
          <target state="translated">モジュールを別のモジュールの中に入れ子にすると、入れ子にしたモジュールの名前に影響を与えます。</target>
        </trans-unit>
        <trans-unit id="a0587b966ad1346723038626d25a39c4caf0fcf4" translate="yes" xml:space="preserve">
          <source>Nests the given document at the given &lt;code&gt;level&lt;/code&gt;.</source>
          <target state="translated">指定したドキュメントを指定した &lt;code&gt;level&lt;/code&gt; でネストします。</target>
        </trans-unit>
        <trans-unit id="ac15dcab98b84e881f95ff7f13b6c27d1103008b" translate="yes" xml:space="preserve">
          <source>New releases are announced in the read-only &lt;a href=&quot;https://groups.google.com/group/elixir-lang-ann&quot;&gt;announcements mailing list&lt;/a&gt;. All security releases &lt;a href=&quot;https://groups.google.com/forum/#!searchin/elixir-lang-ann/%255Bsecurity%255D%257Csort:date&quot;&gt;will be tagged with &lt;code&gt;[security]&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">新しいリリースは、読み取り専用の&lt;a href=&quot;https://groups.google.com/group/elixir-lang-ann&quot;&gt;アナウンスメーリングリスト&lt;/a&gt;でアナウンスされます。すべてのセキュリティリリースに&lt;a href=&quot;https://groups.google.com/forum/#!searchin/elixir-lang-ann/%255Bsecurity%255D%257Csort:date&quot;&gt;は &lt;code&gt;[security]&lt;/code&gt; の&lt;/a&gt;タグが付けられます。</target>
        </trans-unit>
        <trans-unit id="09050a709859e9c045fb8157c8d7649b286d2c98" translate="yes" xml:space="preserve">
          <source>Newlines before certain operators (such as the pipeline operators) and before other operators (such as comparison operators)</source>
          <target state="translated">特定の演算子(パイプライン演算子など)の前と他の演算子(比較演算子など)の前に改行します。</target>
        </trans-unit>
        <trans-unit id="0c7d720a2e040b46c0d03386d11f05cbd66532dd" translate="yes" xml:space="preserve">
          <source>Newlines inside blocks are kept as in the input except for: 1) expressions that take multiple lines will always have an empty line before and after and 2) empty lines are always squeezed together into a single empty line</source>
          <target state="translated">ブロック内の改行は、以下の点を除いては入力と同じように保持されます。1)複数の行を取る式の前後には常に空行がある。</target>
        </trans-unit>
        <trans-unit id="11fc14203dd0f4441645a9c34d5dd022905f56e4" translate="yes" xml:space="preserve">
          <source>Next steps</source>
          <target state="translated">次のステップ</target>
        </trans-unit>
        <trans-unit id="750891f84c6b7eeddc41453bbdd8ec1255f11a42" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s discuss external and internal dependencies and how Mix helps us manage large codebases.</source>
          <target state="translated">次に、外部および内部の依存関係と、Mixが大規模なコードベースの管理にどのように役立つかについて説明します。</target>
        </trans-unit>
        <trans-unit id="ec26ea6bcbb7c9f81e3f941cb690507a65daec00" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll look at a feature central to Elixir, Processes, which allows us to write concurrent, parallel and distributed programs in an easy and understandable way.</source>
          <target state="translated">次に、Elixirの中心的な機能であるProcessesについて説明します。これにより、並行かつ並列の分散プログラムを簡単に理解できる方法で記述できます。</target>
        </trans-unit>
        <trans-unit id="41cb14263e20c4624e46c802b32ac0cf7c57a851" translate="yes" xml:space="preserve">
          <source>No computation will be done until we call one of the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; functions or &lt;a href=&quot;#run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;関数の1つまたは&lt;a href=&quot;#run/1&quot;&gt; &lt;code&gt;run/1&lt;/code&gt; &lt;/a&gt;を呼び出すまで、計算は行われません。</target>
        </trans-unit>
        <trans-unit id="260f7a8cd4f6938b3cc185a619847cb83d670219" translate="yes" xml:space="preserve">
          <source>Node</source>
          <target state="translated">Node</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
