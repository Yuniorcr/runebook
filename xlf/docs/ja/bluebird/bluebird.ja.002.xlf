<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="bluebird">
    <body>
      <group id="bluebird">
        <trans-unit id="d5b43ccfa15a68ea76732113925885a846a983e2" translate="yes" xml:space="preserve">
          <source>Given an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt;&lt;code&gt;Iterable&lt;/code&gt;&lt;/a&gt;(arrays are &lt;code&gt;Iterable&lt;/code&gt;), or a promise of an &lt;code&gt;Iterable&lt;/code&gt;, which produces promises (or a mix of promises and values), iterate over all the values in the &lt;code&gt;Iterable&lt;/code&gt; into an array and &lt;a href=&quot;http://en.wikipedia.org/wiki/Map_(higher-order_function)&quot;&gt;map the array to another&lt;/a&gt; using the given &lt;code&gt;mapper&lt;/code&gt; function.</source>
          <target state="translated">所与&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt; &lt;code&gt;Iterable&lt;/code&gt; &lt;/a&gt;（配列である &lt;code&gt;Iterable&lt;/code&gt; ）、または約束 &lt;code&gt;Iterable&lt;/code&gt; 、約束（又は約束および値の組み合わせ）を生成する、のすべての値にわたって反復 &lt;code&gt;Iterable&lt;/code&gt; アレイへと&lt;a href=&quot;http://en.wikipedia.org/wiki/Map_(higher-order_function)&quot;&gt;別の配列をマッピング&lt;/a&gt;所与使用 &lt;code&gt;mapper&lt;/code&gt; 関数。</target>
        </trans-unit>
        <trans-unit id="5e99be03578b916bd80ede8ae2a2062901092637" translate="yes" xml:space="preserve">
          <source>Given an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt;&lt;code&gt;Iterable&lt;/code&gt;&lt;/a&gt;(arrays are &lt;code&gt;Iterable&lt;/code&gt;), or a promise of an &lt;code&gt;Iterable&lt;/code&gt;, which produces promises (or a mix of promises and values), iterate over all the values in the &lt;code&gt;Iterable&lt;/code&gt; into an array and iterate over the array serially, in-order.</source>
          <target state="translated">所与&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt; &lt;code&gt;Iterable&lt;/code&gt; &lt;/a&gt;（配列である &lt;code&gt;Iterable&lt;/code&gt; ）、または約束 &lt;code&gt;Iterable&lt;/code&gt; 反復はのすべての値を超える、約束（又は約束および値の組み合わせ）を生成、 &lt;code&gt;Iterable&lt;/code&gt; 、直列アレイ上の配列および反復にインオーダー。</target>
        </trans-unit>
        <trans-unit id="1f8e9d0b39417bd51e7781fa7d8ff0682741fabe" translate="yes" xml:space="preserve">
          <source>Given an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt;&lt;code&gt;Iterable&lt;/code&gt;&lt;/a&gt;(arrays are &lt;code&gt;Iterable&lt;/code&gt;), or a promise of an &lt;code&gt;Iterable&lt;/code&gt;, which produces promises (or a mix of promises and values), iterate over all the values in the &lt;code&gt;Iterable&lt;/code&gt; into an array and return a promise that is fulfilled as soon as &lt;code&gt;count&lt;/code&gt; promises are fulfilled in the array. The fulfillment value is an array with &lt;code&gt;count&lt;/code&gt; values in the order they were fulfilled.</source>
          <target state="translated">与えられた&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt; &lt;code&gt;Iterable&lt;/code&gt; &lt;/a&gt;（配列である &lt;code&gt;Iterable&lt;/code&gt; ）、またはの約束 &lt;code&gt;Iterable&lt;/code&gt; 反復は、内のすべての値を超える、約束（または約束と値の組み合わせ）を生成し、 &lt;code&gt;Iterable&lt;/code&gt; 配列にし、すぐにとして成立する約束を返します &lt;code&gt;count&lt;/code&gt; の約束は配列で満たされます。履行値は、履行された順序での &lt;code&gt;count&lt;/code&gt; 値の配列です。</target>
        </trans-unit>
        <trans-unit id="857f3458334e4f2213e0a21ea4b51230697211bb" translate="yes" xml:space="preserve">
          <source>Given an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt;&lt;code&gt;Iterable&lt;/code&gt;&lt;/a&gt;(arrays are &lt;code&gt;Iterable&lt;/code&gt;), or a promise of an &lt;code&gt;Iterable&lt;/code&gt;, which produces promises (or a mix of promises and values), iterate over all the values in the &lt;code&gt;Iterable&lt;/code&gt; into an array and return a promise that is fulfilled or rejected as soon as a promise in the array is fulfilled or rejected with the respective rejection reason or fulfillment value.</source>
          <target state="translated">所与&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt; &lt;code&gt;Iterable&lt;/code&gt; &lt;/a&gt;（配列である &lt;code&gt;Iterable&lt;/code&gt; ）、または約束 &lt;code&gt;Iterable&lt;/code&gt; 反復はのすべての値にわたって、約束（又は約束および値の組み合わせ）を生成、 &lt;code&gt;Iterable&lt;/code&gt; アレイにとして成立するか拒否する約束を返します配列内のプロミスがそれぞれの拒否理由またはフルフィルメント値で満たされるか拒否されるとすぐに。</target>
        </trans-unit>
        <trans-unit id="69cab8471b98016cf118f04639071683711e51b8" translate="yes" xml:space="preserve">
          <source>Given an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt;&lt;code&gt;Iterable&lt;/code&gt;&lt;/a&gt;(arrays are &lt;code&gt;Iterable&lt;/code&gt;), or a promise of an &lt;code&gt;Iterable&lt;/code&gt;, which produces promises (or a mix of promises and values), iterate over all the values in the &lt;code&gt;Iterable&lt;/code&gt; into an array and return a promise that is fulfilled when all the items in the array are fulfilled. The promise's fulfillment value is an array with fulfillment values at respective positions to the original array. If any promise in the array rejects, the returned promise is rejected with the rejection reason.</source>
          <target state="translated">所与&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt; &lt;code&gt;Iterable&lt;/code&gt; &lt;/a&gt;（配列である &lt;code&gt;Iterable&lt;/code&gt; ）、または約束 &lt;code&gt;Iterable&lt;/code&gt; 、約束（又は約束および値の組み合わせ）を生成する、のすべての値にわたって反復 &lt;code&gt;Iterable&lt;/code&gt; アレイに、すべて満たされている約束を返します配列内のアイテムが満たされます。promiseの履行値は、元の配列のそれぞれの位置に履行値を持つ配列です。配列内のいずれかのプロミスが拒否した場合、返されたプロミスは拒否理由とともに拒否されます。</target>
        </trans-unit>
        <trans-unit id="ba72cdcdd80c07ac4fdce4644a5bd2dcebb0c4dd" translate="yes" xml:space="preserve">
          <source>Gives</source>
          <target state="translated">Gives</target>
        </trans-unit>
        <trans-unit id="dd8ed7e2a547ceb0fcc1dd88e8912c6fe49d6651" translate="yes" xml:space="preserve">
          <source>Global rejection events</source>
          <target state="translated">グローバルな拒絶反応イベント</target>
        </trans-unit>
        <trans-unit id="929a28d261428029e61c0f81c6161fd71ba0b2fe" translate="yes" xml:space="preserve">
          <source>Guides</source>
          <target state="translated">Guides</target>
        </trans-unit>
        <trans-unit id="eecad68c8e79b4757501bd51103a0fe41d4c17f1" translate="yes" xml:space="preserve">
          <source>Happy coding, &lt;a href=&quot;https://github.com/sukima&quot;&gt;@sukima&lt;/a&gt;.</source>
          <target state="translated">ハッピーコーディング、&lt;a href=&quot;https://github.com/sukima&quot;&gt;@ sukima&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0c271c8f62efa33d3ac8edbe0fea6e52fc84150" translate="yes" xml:space="preserve">
          <source>Haskell</source>
          <target state="translated">Haskell</target>
        </trans-unit>
        <trans-unit id="8886c5567b21fd2984bb26867070a05a64fb4320" translate="yes" xml:space="preserve">
          <source>Here is a simple example (where &lt;code&gt;getConnection()&lt;/code&gt; has been defined to return a proper Disposer object)</source>
          <target state="translated">以下は簡単な例です（ &lt;code&gt;getConnection()&lt;/code&gt; は適切なDisposerオブジェクトを返すように定義されています）</target>
        </trans-unit>
        <trans-unit id="26f58fc7b427a0eccff2284be30066c7abd9204c" translate="yes" xml:space="preserve">
          <source>Here is another example with an API that lets us know when a connection is ready. The attempt here is imperfect and we'll describe why soon:</source>
          <target state="translated">ここでは、接続の準備ができたときにそれを知ることができる API を使用した別の例を示します。ここでの試みは不完全ですが、その理由をすぐに説明します。</target>
        </trans-unit>
        <trans-unit id="e65979c6ef8becc2e43f319defd5989fed1be73a" translate="yes" xml:space="preserve">
          <source>Here is another example with an API that lets us know when when a connection is ready. The attempt here is imperfect and we'll describe why soon:</source>
          <target state="translated">ここでは、接続の準備ができたときにそれを知ることができる API を使った別の例を紹介します。ここでの試みは不完全ですが、その理由をすぐに説明します。</target>
        </trans-unit>
        <trans-unit id="4ba16b105db298af09af0af0a8b19da53c43e1d3" translate="yes" xml:space="preserve">
          <source>Here is how to create a disposer for the MySQL driver:</source>
          <target state="translated">ここでは、MySQLドライバのディスポーザを作成する方法を紹介します。</target>
        </trans-unit>
        <trans-unit id="74bcba50f0bf4efbc2a611c31d423e7be3cb7101" translate="yes" xml:space="preserve">
          <source>Here is how to create a disposer for the PostgreSQL driver:</source>
          <target state="translated">PostgreSQLドライバ用のディスポーザを作成する方法を紹介します。</target>
        </trans-unit>
        <trans-unit id="27bacef699ed8cc8da7b95cbf6d769cd8c4fda27" translate="yes" xml:space="preserve">
          <source>Here is some example HTML for the Progress Dialog:</source>
          <target state="translated">ここでは進行状況ダイアログのHTMLの例を示します。</target>
        </trans-unit>
        <trans-unit id="7718e6b52e055c2b6bb02d338b08d91075171e40" translate="yes" xml:space="preserve">
          <source>Here's an example of &lt;code&gt;fs.readFile&lt;/code&gt; with or without promises:</source>
          <target state="translated">以下は、 &lt;code&gt;fs.readFile&lt;/code&gt; ありまたはプロミスなしのfs.readFileの例です。</target>
        </trans-unit>
        <trans-unit id="be1eea5cafc8d8f3342d7b87a0e1c5e1c6e75fa0" translate="yes" xml:space="preserve">
          <source>However because it is possible to handle a rejected promise at any time in the indeterminate future, some programming patterns will result in false positives. Because such programming patterns are not necessary and can always be refactored to never cause false positives, we recommend doing that to keep debugging as easy as possible . You may however feel differently so bluebird provides hooks to implement more complex failure policies.</source>
          <target state="translated">しかし、拒否されたプロミスはいつでも不確定な将来に処理することが可能なので、いくつかのプログラミングパターンでは偽陽性が発生します。そのようなプログラミングパターンは必要なく、いつでもリファクタリングして誤検出を起こさないようにすることができるので、デバッグをできるだけ簡単にするために、そのようにすることをお勧めします。しかし、あなたは違うと感じるかもしれないので、ブルーバードはより複雑な失敗ポリシーを実装するためのフックを提供します。</target>
        </trans-unit>
        <trans-unit id="13c4ea634e9c241cc16a70243b1aa4d2e0af9262" translate="yes" xml:space="preserve">
          <source>However if you want stack traces and cleaner string output, then you should do:</source>
          <target state="translated">しかし、スタックトレースやよりクリーンな文字列出力を望むのであれば、そうすべきです。</target>
        </trans-unit>
        <trans-unit id="43fb3aa6954ef56f7c44e1242c17a1fae9ea1ce7" translate="yes" xml:space="preserve">
          <source>However, a bluebird promise is more powerful than the current implementation of &lt;code&gt;std::future&lt;/code&gt; since while chaining has been discussed it is not yet implemented. Promises can be chained together.</source>
          <target state="translated">ただし、ブルーバードプロミスは、現在の &lt;code&gt;std::future&lt;/code&gt; 実装よりも強力です。これは、チェーンについて説明してきたが、まだ実装されていないためです。約束は連鎖させることができます。</target>
        </trans-unit>
        <trans-unit id="3ead241876e467071326c285d4a421554cfb1153" translate="yes" xml:space="preserve">
          <source>However, if the second &lt;code&gt;getConnection&lt;/code&gt; throws &lt;strong&gt;synchronously&lt;/strong&gt;, the first connection is leaked. This will not happen when using APIs through bluebird promisified methods though. You can wrap functions that could throw in &lt;a href=&quot;promise.method&quot;&gt;&lt;code&gt;Promise.method&lt;/code&gt;&lt;/a&gt; which will turn synchronous rejections into rejected promises.</source>
          <target state="translated">ただし、2番目の &lt;code&gt;getConnection&lt;/code&gt; が&lt;strong&gt;同期的&lt;/strong&gt;にスロー&lt;strong&gt;する&lt;/strong&gt;と、最初の接続がリークされます。ただし、bluebirdで約束された方法でAPIを使用する場合は、これは発生しません。同期拒否を拒否されたプロミスに変える&lt;a href=&quot;promise.method&quot;&gt; &lt;code&gt;Promise.method&lt;/code&gt; &lt;/a&gt;をスローする可能性のある関数をラップできます。</target>
        </trans-unit>
        <trans-unit id="c6545029e669f49f67f406d14c0ceb316e3ab45f" translate="yes" xml:space="preserve">
          <source>However, if you are utilizing the full bluebird API offering, you will &lt;em&gt;almost never&lt;/em&gt; need to resort to nesting promises in the first place. The above should be written more like:</source>
          <target state="translated">ただし、完全なbluebird APIオファリングを利用している場合、そもそもプロミスのネストに頼る必要は&lt;em&gt;ほとんどありません&lt;/em&gt;。上記は次のように書く必要があります。</target>
        </trans-unit>
        <trans-unit id="0e98b78455e3426551238440ba2fef34bfa9f53b" translate="yes" xml:space="preserve">
          <source>However, there are many differences when you look closer:</source>
          <target state="translated">しかし、よく見るといろいろな違いがあります。</target>
        </trans-unit>
        <trans-unit id="0cae8b925e624929841b55477c73030393e870ed" translate="yes" xml:space="preserve">
          <source>I hope this helps illustrate some concepts available with Promises and a different perspective on how promises can represent more then just AJAX data.</source>
          <target state="translated">これが、プロミスで利用できるいくつかの概念と、プロミスがどのように単なるAJAXデータ以上のものを表現できるかという別の視点を説明するのに役立つことを願っています。</target>
        </trans-unit>
        <trans-unit id="6de1ea5d0581cc815a017782a4875ebd7b42beb9" translate="yes" xml:space="preserve">
          <source>IE7 and IE8 do not support using keywords as property names, so if supporting these browsers is required you need to use the compatibility aliases:</source>
          <target state="translated">IE7 と IE8 はキーワードをプロパティ名として使用することをサポートしていないので、これらのブラウザのサポートが必要な場合は互換性のあるエイリアスを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="5a58805bb7bfd807b86a57ffc79cb53fbd8d908e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;index&lt;/code&gt; is negative, the indexed load will become &lt;code&gt;obj.length + index&lt;/code&gt;. So that -1 can be used to read last item in the array, -2 to read the second last and so on. For example:</source>
          <target state="translated">場合は &lt;code&gt;index&lt;/code&gt; 負の場合、インデックス付きの負荷はなり &lt;code&gt;obj.length + index&lt;/code&gt; 。そのため、-1を使用して配列の最後の項目を読み取り、-2を使用して2番目の項目を読み取ることができます。例えば：</target>
        </trans-unit>
        <trans-unit id="48754e7d553962c152a84287f9d6e3171c36cf69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;object&lt;/code&gt; is a trusted &lt;code&gt;Promise&lt;/code&gt;, then it will be treated as a promise for object rather than for its properties. All other objects (except &lt;code&gt;Map&lt;/code&gt;s) are treated for their properties as is returned by &lt;code&gt;Object.keys&lt;/code&gt; - the object's own enumerable properties.</source>
          <target state="translated">場合は &lt;code&gt;object&lt;/code&gt; 信頼されている &lt;code&gt;Promise&lt;/code&gt; 、それはオブジェクトのためにではなく、その性質のための約束として扱われます。他のすべてのオブジェクト（ &lt;code&gt;Map&lt;/code&gt; を除く）は、 &lt;code&gt;Object.keys&lt;/code&gt; （オブジェクト自体の列挙可能なプロパティ）によって返されるプロパティと同様に処理されます。</target>
        </trans-unit>
        <trans-unit id="5e792131e2122a704cd149f5cb06c842a0d1f08e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;thisArg&lt;/code&gt; is a promise or thenable, its resolution will be awaited for and the bound value will be the promise's fulfillment value. If &lt;code&gt;thisArg&lt;/code&gt; rejects then the returned promise is rejected with the &lt;code&gt;thisArg's&lt;/code&gt; rejection reason. Note that this means you cannot use &lt;code&gt;this&lt;/code&gt; without checking inside catch handlers for promises that bind to promise because in case of rejection of &lt;code&gt;thisArg&lt;/code&gt;, &lt;code&gt;this&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;thisArg&lt;/code&gt; がpromiseまたはthenableである場合、その解決は待機され、バインドされた値はpromiseの履行値になります。場合 &lt;code&gt;thisArg&lt;/code&gt; が拒否返さ約束をして拒否され &lt;code&gt;thisArg's&lt;/code&gt; 拒否理由。 &lt;code&gt;thisArg&lt;/code&gt; が拒否された場合、 &lt;code&gt;this&lt;/code&gt; は &lt;code&gt;undefined&lt;/code&gt; なるため、promiseにバインドするpromiseのキャッチハンドラー内をチェックしないと、 &lt;code&gt;this&lt;/code&gt; を使用できないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="17736fb74e4b535caabcc3cb12766cd80da44a84" translate="yes" xml:space="preserve">
          <source>If a bound promise is returned by the callback to &lt;a href=&quot;api/promise.method&quot;&gt;&lt;code&gt;Promise.method&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;api/promise.try&quot;&gt;&lt;code&gt;Promise.try&lt;/code&gt;&lt;/a&gt;, the returned promise will be bound to the same value</source>
          <target state="translated">バインドされたpromiseがコールバックによって&lt;a href=&quot;api/promise.method&quot;&gt; &lt;code&gt;Promise.method&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;api/promise.try&quot;&gt; &lt;code&gt;Promise.try&lt;/code&gt; &lt;/a&gt;に返された場合、返されたpromiseは同じ値にバインドされます</target>
        </trans-unit>
        <trans-unit id="ef5dc1064fadc46c525a97dba4427bc7dea4bdd5" translate="yes" xml:space="preserve">
          <source>If a disposer method throws or returns a rejected promise, it's highly likely that it failed to dispose of the resource. In that case, Bluebird has two options - it can either ignore the error and continue with program execution or throw an exception (crashing the process in node.js).</source>
          <target state="translated">disposer メソッドが拒否されたプロミスを投げたり返したりした場合、リソースの処分に失敗した可能性が高いです。その場合、Bluebird には 2 つの選択肢があります。エラーを無視してプログラムの実行を続けるか、例外を投げる (node.js のプロセスをクラッシュさせる)かのいずれかです。</target>
        </trans-unit>
        <trans-unit id="043349c3f8c506768b7d9272ca348300465fc593" translate="yes" xml:space="preserve">
          <source>If a method name already has an &lt;code&gt;&quot;Async&quot;&lt;/code&gt;-suffix, an exception will be thrown.</source>
          <target state="translated">メソッド名にすでに &lt;code&gt;&quot;Async&quot;&lt;/code&gt; サフィックスが含まれている場合、例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="ea797b951ef4dd11b65a893a9dcb482b48c90fe6" translate="yes" xml:space="preserve">
          <source>If a method name already has an &lt;code&gt;&quot;Async&quot;&lt;/code&gt;-suffix, it will be duplicated. E.g. &lt;code&gt;getAsync&lt;/code&gt;'s promisified name is &lt;code&gt;getAsyncAsync&lt;/code&gt;.</source>
          <target state="translated">メソッド名にすでに &lt;code&gt;&quot;Async&quot;&lt;/code&gt; 接尾辞が付いている場合は、複製されます。たとえば、 &lt;code&gt;getAsync&lt;/code&gt; の正式名称は &lt;code&gt;getAsyncAsync&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="00ca6822bc67d26b0bb8b67bfe840b57c60568ab" translate="yes" xml:space="preserve">
          <source>If a module has multiple argument callbacks as an exception rather than the rule, you can filter out the multiple argument methods in first go and then promisify rest of the module in second go:</source>
          <target state="translated">モジュールが複数の引数のコールバックをルールではなく例外として持っている場合、最初に複数の引数のメソッドをフィルタリングし、2回目にモジュールの残りの部分を宣伝することができます。</target>
        </trans-unit>
        <trans-unit id="39d2831120e0fc914a1f915ed431ccee51054c24" translate="yes" xml:space="preserve">
          <source>If all iterations resolve successfully, the &lt;code&gt;Promise.each&lt;/code&gt; call resolves to a new array containing the resolved values of the original input elements.</source>
          <target state="translated">すべての反復が正常に解決されると、 &lt;code&gt;Promise.each&lt;/code&gt; 呼び出しは、元の入力要素の解決された値を含む新しい配列に解決されます。</target>
        </trans-unit>
        <trans-unit id="129cbea3a99c2245487d23413194e397b8dee441" translate="yes" xml:space="preserve">
          <source>If all iterations resolve successfully, the &lt;code&gt;Promise.mapSeries&lt;/code&gt; call resolves to a new array containing the results of each &lt;code&gt;mapper&lt;/code&gt; execution, in order.</source>
          <target state="translated">すべての反復が正常に解決されると、 &lt;code&gt;Promise.mapSeries&lt;/code&gt; 呼び出しは、各 &lt;code&gt;mapper&lt;/code&gt; 実行の結果を順番に含む新しい配列に解決されます。</target>
        </trans-unit>
        <trans-unit id="72964c7b91aee68d8763c1b1f6924364f8c00e31" translate="yes" xml:space="preserve">
          <source>If any promise in the input array is rejected or any promise returned by the iterator function is rejected, the result will be rejected as well.</source>
          <target state="translated">入力配列内の約束が拒否されたり、イテレータ関数によって返された約束が拒否された場合、結果も同様に拒否されます。</target>
        </trans-unit>
        <trans-unit id="962010428071535fe6f8370fa09691795307bc72" translate="yes" xml:space="preserve">
          <source>If destructuring parameters are supported, &lt;code&gt;.spread(function(arg1, arg2) {})&lt;/code&gt; can be replaced with &lt;code&gt;.then(function([arg1, arg2]){})&lt;/code&gt;.</source>
          <target state="translated">破壊パラメーターがサポートされている場合、 &lt;code&gt;.spread(function(arg1, arg2) {})&lt;/code&gt; は &lt;code&gt;.then(function([arg1, arg2]){})&lt;/code&gt; 置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="f9bcd1a977e9bc00ed376c144fd15da6e11e726d" translate="yes" xml:space="preserve">
          <source>If fetching tweets fails before the document is ready the rejection is reported as unhandled even though it will be eventually handled when the document is ready. This is of course impossible to determine automatically, but you can explicitly do so using &lt;code&gt;.suppressUnhandledRejections()&lt;/code&gt;:</source>
          <target state="translated">ドキュメントの準備ができる前にツイートのフェッチが失敗すると、ドキュメントの準備ができたときに最終的に処理されますが、拒否は未処理として報告されます。これを自動的に決定することはもちろん不可能ですが、 &lt;code&gt;.suppressUnhandledRejections()&lt;/code&gt; を使用して明示的に決定することができます。</target>
        </trans-unit>
        <trans-unit id="d135771ca2084fbac51f59a830fdefe27d1f73a3" translate="yes" xml:space="preserve">
          <source>If not there already, an additional wrapper function is required to undefined leaking or sharing &lt;code&gt;scope&lt;/code&gt;</source>
          <target state="translated">まだそこにない場合、未定義のリークまたは共有 &lt;code&gt;scope&lt;/code&gt; に対して追加のラッパー関数が必要です</target>
        </trans-unit>
        <trans-unit id="2702634b1adf7d64f121049f0317c538e848c615" translate="yes" xml:space="preserve">
          <source>If that ES6 import &lt;a href=&quot;https://github.com/petkaantonov/bluebird/pull/1594&quot;&gt;doesn't work&lt;/a&gt;</source>
          <target state="translated">そのES6インポート&lt;a href=&quot;https://github.com/petkaantonov/bluebird/pull/1594&quot;&gt;が機能しない&lt;/a&gt;場合</target>
        </trans-unit>
        <trans-unit id="dd08bf528d1b25718f075d1d36c59b224befab3e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;index&lt;/code&gt; is still negative after &lt;code&gt;obj.length + index&lt;/code&gt;, it will be clamped to 0.</source>
          <target state="translated">&lt;code&gt;obj.length + index&lt;/code&gt; 後も &lt;code&gt;index&lt;/code&gt; が負の場合、0にクランプされます。</target>
        </trans-unit>
        <trans-unit id="a9c21a6c272866c083275685b7da39922c4ca853" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;nodeFunction&lt;/code&gt; calls its callback with multiple success values, the fulfillment value will be the first fulfillment item.</source>
          <target state="translated">&lt;code&gt;nodeFunction&lt;/code&gt; が複数の成功値でコールバックを呼び出す場合、フルフィルメント値が最初のフルフィルメントアイテムになります。</target>
        </trans-unit>
        <trans-unit id="f04284cbd4e7048ff2d892690b33de55e02378db" translate="yes" xml:space="preserve">
          <source>If the fade out completes successfully, the returned promise will be fulfilled or rejected with the value from &lt;code&gt;xhr&lt;/code&gt;. If &lt;code&gt;.fadeOut&lt;/code&gt; throws an exception or passes an error to the callback, the returned promise will be rejected with the error from &lt;code&gt;.fadeOut&lt;/code&gt;.</source>
          <target state="translated">フェードアウトが正常に完了すると、返されたpromiseは &lt;code&gt;xhr&lt;/code&gt; の値で満たされるか拒否されます。場合 &lt;code&gt;.fadeOut&lt;/code&gt; が例外をスローしたり、コールバックにエラーを渡し、返された約束はからのエラーで拒否されます &lt;code&gt;.fadeOut&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="361168b0ad7608978a2fce0c19d538f5024c4a7e" translate="yes" xml:space="preserve">
          <source>If the handler function passed to &lt;code&gt;.finally&lt;/code&gt; returns a promise, the promise returned by &lt;code&gt;.finally&lt;/code&gt; will not be settled until the promise returned by the handler is settled. If the handler fulfills its promise, the returned promise will be fulfilled or rejected with the original value. If the handler rejects its promise, the returned promise will be rejected with the handler's value. This is similar to throwing an exception in a synchronous &lt;code&gt;finally&lt;/code&gt; block, causing the original value or exception to be forgotten. This delay can be useful if the actions performed by the handler are done asynchronously. For example:</source>
          <target state="translated">渡されたハンドラ関数場合 &lt;code&gt;.finally&lt;/code&gt; は約束を返し、によって返さ約束 &lt;code&gt;.finally&lt;/code&gt; は、ハンドラによって返された約束が決済されるまでは決済されません。ハンドラーがプロミスを満たす場合、返されたプロミスは元の値で満たされるか拒否されます。ハンドラーがpromiseを拒否した場合、返されたpromiseはハンドラーの値とともに拒否されます。これは、同期の &lt;code&gt;finally&lt;/code&gt; ブロックで例外をスローすることに似ており、元の値または例外が忘れられます。この遅延は、ハンドラーによって実行されるアクションが非同期で実行される場合に役立ちます。例えば：</target>
        </trans-unit>
        <trans-unit id="01c2d4f954ef5c2b127397874ff03e84be89fce3" translate="yes" xml:space="preserve">
          <source>If the reducer function returns a promise, then the result of the promise is awaited, before continuing with next iteration. If any promise in the array is rejected or a promise returned by the reducer function is rejected, the result is rejected as well.</source>
          <target state="translated">reducer 関数がプロミスを返した場合は、プロミスの結果を待ってから次の繰り返しを行います。配列内のプロミスが拒否された場合や、レデューサー関数が返したプロミスが拒否された場合は、結果も同様に拒否されます。</target>
        </trans-unit>
        <trans-unit id="9a8efabed45049c7b109e41750da5ffac5adcb88" translate="yes" xml:space="preserve">
          <source>If the waterfall elements are static, you can just replace it with a normal promise chain. For waterfalls with dynamic steps, use &lt;a href=&quot;api/promise.each&quot;&gt;&lt;code&gt;Promise.each&lt;/code&gt;&lt;/a&gt;. Multiple arguments can be ferried in an array.</source>
          <target state="translated">ウォーターフォール要素が静的な場合は、通常のプロミスチェーンに置き換えることができます。動的ステップのある滝の場合は、&lt;a href=&quot;api/promise.each&quot;&gt; &lt;code&gt;Promise.each&lt;/code&gt; を&lt;/a&gt;使用します。複数の引数を配列で渡すことができます。</target>
        </trans-unit>
        <trans-unit id="6feea941cd7828f9478631d06744c6dde53e3bff" translate="yes" xml:space="preserve">
          <source>If too many promises are rejected so that the promise can never become fulfilled, it will be immediately rejected with an &lt;a href=&quot;aggregateerror&quot;&gt;&lt;code&gt;AggregateError&lt;/code&gt;&lt;/a&gt; of the rejection reasons in the order they were thrown in.</source>
          <target state="translated">あまりにも多くのプロミスが拒否され、そのプロミスが決して達成されない場合、拒否された理由の&lt;a href=&quot;aggregateerror&quot;&gt; &lt;code&gt;AggregateError&lt;/code&gt; &lt;/a&gt;がスローされた順に、即座に拒否されます。</target>
        </trans-unit>
        <trans-unit id="c2cf94f34d6e1d8b4f98bef3770ba3552f18a017" translate="yes" xml:space="preserve">
          <source>If you cannot do static promisification (promisify and promisifyAll perform too slowly to use at runtime), you may use &lt;a href=&quot;api/promise.fromcallback&quot;&gt;&lt;code&gt;Promise.fromCallback&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">静的なpromisificationを実行できない場合（promisifyとpromisifyAllの実行速度が遅すぎて実行時に使用できない）、&lt;a href=&quot;api/promise.fromcallback&quot;&gt; &lt;code&gt;Promise.fromCallback&lt;/code&gt; を&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="4aad0286aecb732eace47330d3eb9225ba7439ee" translate="yes" xml:space="preserve">
          <source>If you do have some code using jQuery deferred methods extensively try to see if some of these jQuery deferred patterns and their replacements can be applied:</source>
          <target state="translated">jQuery deferredメソッドを広範囲に使用しているコードがある場合は、これらのjQuery deferredパターンのいくつかとその置換が適用できるかどうかを試してみてください。</target>
        </trans-unit>
        <trans-unit id="ee3233f06ac157e8dbc09dc2625b57a65257f7e1" translate="yes" xml:space="preserve">
          <source>If you don't want to return a bound promise to the consumers of a promise, you can rebind the chain at the end:</source>
          <target state="translated">約束の消費者にバインドされた約束を返したくない場合は、最後にチェーンを再バインドすることができます。</target>
        </trans-unit>
        <trans-unit id="4a1d38286aed9fdb4ea56d22e0878f2efd4afec6" translate="yes" xml:space="preserve">
          <source>If you find this issue in a common library please &lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/new&quot;&gt;open an issue&lt;/a&gt;.</source>
          <target state="translated">共通ライブラリでこの問題を見つけた場合は&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/new&quot;&gt;、問題&lt;/a&gt;を開いてください。</target>
        </trans-unit>
        <trans-unit id="6d2c92c43afa270ba31f20fa3a4fd3f374ada753" translate="yes" xml:space="preserve">
          <source>If you know what you're doing and don't want to silence all warnings, you can create runaway promises without causing this warning by returning e.g. &lt;code&gt;null&lt;/code&gt;:</source>
          <target state="translated">あなたが何をしているのかを知っていて、すべての警告を黙らせたくない場合、たとえば &lt;code&gt;null&lt;/code&gt; を返すことで、この警告を引き起こさずに暴走するプロミスを作成できます：</target>
        </trans-unit>
        <trans-unit id="4317fd792e9166b0fb459f84f12ac0c69c772134" translate="yes" xml:space="preserve">
          <source>If you pass a &lt;code&gt;context&lt;/code&gt;, the &lt;code&gt;nodeFunction&lt;/code&gt; will be called as a method on the &lt;code&gt;context&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;context&lt;/code&gt; を渡すと、 &lt;code&gt;nodeFunction&lt;/code&gt; が &lt;code&gt;context&lt;/code&gt; メソッドとして呼び出されます。</target>
        </trans-unit>
        <trans-unit id="725473ba1a25ffa9ed75e25bf705064099a7373d" translate="yes" xml:space="preserve">
          <source>If you pass a promise object to the &lt;code&gt;resolve&lt;/code&gt; function, the created promise will follow the state of that promise.</source>
          <target state="translated">promiseオブジェクトを &lt;code&gt;resolve&lt;/code&gt; 関数に渡すと、作成されたpromiseはそのpromiseの状態に従います。</target>
        </trans-unit>
        <trans-unit id="c8c7f36a8c78ffc855273674eee0d9d279347fca" translate="yes" xml:space="preserve">
          <source>If you see this warning your code is probably not doing what you expect it to, the most common reason is passing the &lt;em&gt;result&lt;/em&gt; of calling a function to &lt;a href=&quot;api/then&quot;&gt;&lt;code&gt;.then()&lt;/code&gt;&lt;/a&gt; instead of the function &lt;em&gt;itself&lt;/em&gt;:</source>
          <target state="translated">この警告が表示された場合、コードが期待どおりに動作していない可能性があります。最も一般的な理由は、関数の呼び出し&lt;em&gt;結果&lt;/em&gt;を関数&lt;em&gt;自体&lt;/em&gt;ではなく&lt;a href=&quot;api/then&quot;&gt; &lt;code&gt;.then()&lt;/code&gt; &lt;/a&gt;に渡す&lt;em&gt;こと&lt;/em&gt;です。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="209a23ebfb5748a6ab8f80e05376ebdb5ccf11de" translate="yes" xml:space="preserve">
          <source>If you want to coordinate several discrete concurrent promises, use &lt;a href=&quot;promise.join&quot;&gt;&lt;code&gt;Promise.join&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">複数の個別の並行プロミスを調整する場合は、&lt;a href=&quot;promise.join&quot;&gt; &lt;code&gt;Promise.join&lt;/code&gt; を&lt;/a&gt;使用します</target>
        </trans-unit>
        <trans-unit id="5b76d752c005430b67f6283cff61f81e57d83ce0" translate="yes" xml:space="preserve">
          <source>If you want to wrap an API with a promise manually, the correct syntax is:</source>
          <target state="translated">API をプロミスで手動でラップしたい場合、正しい構文は次のようになります。</target>
        </trans-unit>
        <trans-unit id="700d4beb4e694e797eaff4fa5778aa5c5d7f5298" translate="yes" xml:space="preserve">
          <source>If you're familiar with PromiseKit, it is based on a same specification bluebird is based on so the API should feel familiar right away.</source>
          <target state="translated">PromiseKit をよく知っている人なら、bluebird と同じ仕様をベースにしているので、API はすぐに馴染んでくるはずです。</target>
        </trans-unit>
        <trans-unit id="966394e4086caa71b33f7995eed9fbcc4b6e2187" translate="yes" xml:space="preserve">
          <source>If your library needs to do something obtrusive like adding or modifying methods on the &lt;code&gt;Promise&lt;/code&gt; prototype, uses long stack traces or uses a custom unhandled rejection handler then... that's totally ok as long as you don't use &lt;code&gt;require(&quot;bluebird&quot;)&lt;/code&gt;. Instead you should create a file that creates an isolated copy. For example, creating a file called &lt;code&gt;bluebird-extended.js&lt;/code&gt; that contains:</source>
          <target state="translated">ライブラリが &lt;code&gt;Promise&lt;/code&gt; プロトタイプのメソッドの追加や変更など邪魔なことをする必要がある場合は、長いスタックトレースを使用するか、カスタムの未処理の拒否ハンドラを使用します... &lt;code&gt;require(&quot;bluebird&quot;)&lt;/code&gt; を使用しない限り、問題ありません。。代わりに、分離されたコピーを作成するファイルを作成する必要があります。たとえば、以下を含む &lt;code&gt;bluebird-extended.js&lt;/code&gt; というファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="cbc582b62a43024af9610875e2f1c1a993555795" translate="yes" xml:space="preserve">
          <source>If your'e familiar with Java 8 lambdas, you can think of a promise as a &lt;code&gt;Future&lt;/code&gt; you can &lt;code&gt;map&lt;/code&gt; to another future.</source>
          <target state="translated">Java 8ラムダを使い慣れている場合は、約束を別の未来に &lt;code&gt;map&lt;/code&gt; できる &lt;code&gt;Future&lt;/code&gt; と考えることができます。</target>
        </trans-unit>
        <trans-unit id="834102510a799a81df534fb9d6f8cdb91d442836" translate="yes" xml:space="preserve">
          <source>If, at any step:</source>
          <target state="translated">もし、どの段階でも</target>
        </trans-unit>
        <trans-unit id="f76b9571c2fa26f1c9c053453e48baf3102b175e" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;api/reflect&quot;&gt;&lt;code&gt;.reflect()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;api/reflect&quot;&gt; &lt;code&gt;.reflect()&lt;/code&gt; を&lt;/a&gt;実装する</target>
        </trans-unit>
        <trans-unit id="0de27db7a173e23bc1b1a951c986b9e75189651d" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#promisecoroutineaddyieldhandlerfunction-handler---void&quot;&gt;&lt;code&gt;Promise.coroutine.addYieldHandler()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#promisecoroutineaddyieldhandlerfunction-handler---void&quot;&gt; &lt;code&gt;Promise.coroutine.addYieldHandler()&lt;/code&gt; を&lt;/a&gt;実装する</target>
        </trans-unit>
        <trans-unit id="debaea1257108cf0777761addbfa5ec8ad866a63" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#tapfunction-handler---promise&quot;&gt;&lt;code&gt;Promise.prototype.tap()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#tapfunction-handler---promise&quot;&gt; &lt;code&gt;Promise.prototype.tap()&lt;/code&gt; を&lt;/a&gt;実装する</target>
        </trans-unit>
        <trans-unit id="5a1c43a24101780f93b51137f52374d22e70596b" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;.bind&lt;/code&gt; and &lt;code&gt;Promise.bind&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.bind&lt;/code&gt; と &lt;code&gt;Promise.bind&lt;/code&gt; を実装する</target>
        </trans-unit>
        <trans-unit id="0f380a273aee2d6cf970a6fe45244632c5d9b4cc" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;.return()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.return()&lt;/code&gt; を実装する</target>
        </trans-unit>
        <trans-unit id="b4c72d943e49cf756fcbd5f12144b514c9e719f9" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;.throw()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.throw()&lt;/code&gt; を実装する</target>
        </trans-unit>
        <trans-unit id="ae49e6671f17e74abdd91283eaaa890a378ca81b" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;Promise.method()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Promise.method()&lt;/code&gt; を実装する</target>
        </trans-unit>
        <trans-unit id="1d181fb40191fdf3fe9541cbc7a61c14dc076b35" translate="yes" xml:space="preserve">
          <source>Implement RejectionError wrapping and &lt;code&gt;.error()&lt;/code&gt; method</source>
          <target state="translated">RejectionErrorラッピングと &lt;code&gt;.error()&lt;/code&gt; メソッドを実装する</target>
        </trans-unit>
        <trans-unit id="ff1c32750ed475d16c2e3d6ee2570476a4351b7a" translate="yes" xml:space="preserve">
          <source>Implemented &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#global-rejection-events&quot;&gt;global rejection events&lt;/a&gt; (&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/428&quot;&gt;#428&lt;/a&gt;, &lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/357&quot;&gt;#357&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#global-rejection-events&quot;&gt;グローバル拒否イベントを&lt;/a&gt;実装（&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/428&quot;&gt;＃428&lt;/a&gt;、&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/357&quot;&gt;＃357&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="6677e178a6bc2ac6cc38cee7e51212de4486b2b2" translate="yes" xml:space="preserve">
          <source>Implementing general progress interfaces like in C#:</source>
          <target state="translated">C#のような一般的なプログレスインターフェースの実装</target>
        </trans-unit>
        <trans-unit id="733eea0f9f3a4d9f23332caa166015a4f890c124" translate="yes" xml:space="preserve">
          <source>Implementing the example from &lt;a href=&quot;https://github.com/caolan/async#waterfalltasks-callback&quot;&gt;async homepage&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/caolan/async#waterfalltasks-callback&quot;&gt;非同期ホームページ&lt;/a&gt;からの例の実装</target>
        </trans-unit>
        <trans-unit id="97ecdd3f427cfc303e767bb0913667606529c860" translate="yes" xml:space="preserve">
          <source>Implicit &lt;code&gt;Promise.all()&lt;/code&gt; when yielding an array from generators</source>
          <target state="translated">ジェネレーターから配列を生成するときの暗黙の &lt;code&gt;Promise.all()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1dd411a1bd6013312e12e897a0c51cd4f4318ca0" translate="yes" xml:space="preserve">
          <source>Improve &lt;code&gt;promisifyAll&lt;/code&gt; detection of functions that are class constructors. Fixes mongodb 2.x promisification.</source>
          <target state="translated">クラスコンストラクターである関数の &lt;code&gt;promisifyAll&lt;/code&gt; 検出を改善します。mongodb 2.xの誤植を修正します。</target>
        </trans-unit>
        <trans-unit id="213e96bdfb4a128bc3bd87f532efaf90f14c5e6a" translate="yes" xml:space="preserve">
          <source>Improve output of reporting unhandled non-errors</source>
          <target state="translated">ハンドリングされていない非エラーの報告の出力を改善</target>
        </trans-unit>
        <trans-unit id="21437ff0b7933ce8b58f0d38d668c7b9602b5664" translate="yes" xml:space="preserve">
          <source>Improve overall performance when not using &lt;code&gt;.bind()&lt;/code&gt; or cancellation.</source>
          <target state="translated">&lt;code&gt;.bind()&lt;/code&gt; またはキャンセルを使用しない場合の全体的なパフォーマンスを改善します。</target>
        </trans-unit>
        <trans-unit id="a3cd986d15205ea786fe95cf148b685b17a4a66b" translate="yes" xml:space="preserve">
          <source>Improve overall performance.</source>
          <target state="translated">全体のパフォーマンスを向上させる。</target>
        </trans-unit>
        <trans-unit id="d91321dac872eb3a4ecd05762060d481636fa793" translate="yes" xml:space="preserve">
          <source>Improve overall performance. Be able to sustain infinite recursion when using promises.</source>
          <target state="translated">全体的なパフォーマンスを向上させる。プロミスを使用する際に、無限の再帰を維持できるようにする。</target>
        </trans-unit>
        <trans-unit id="23dc55298841549083703a0dc975bff9f3e5d5fc" translate="yes" xml:space="preserve">
          <source>Improve performance of .finally.</source>
          <target state="translated">.finalのパフォーマンスを向上させます。</target>
        </trans-unit>
        <trans-unit id="b5cef6dcb86b0975f111f8f1d79bf5d753600cad" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;.props()&lt;/code&gt; and collection methods when used with immediate values</source>
          <target state="translated">即時値で使用した場合の &lt;code&gt;.props()&lt;/code&gt; およびコレクションメソッドのパフォーマンスを向上させる</target>
        </trans-unit>
        <trans-unit id="6533fb39d2c4b52d57bf0b0080357de93b567761" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;.reduce()&lt;/code&gt; when &lt;code&gt;initialValue&lt;/code&gt; can be synchronously cast to a value</source>
          <target state="translated">&lt;code&gt;initialValue&lt;/code&gt; を同期的に値にキャストできる場合の &lt;code&gt;.reduce()&lt;/code&gt; のパフォーマンスを向上させる</target>
        </trans-unit>
        <trans-unit id="b79e5ce64b3cc6df23f96da6189a55cda2f3a24b" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;.some()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.some()&lt;/code&gt; のパフォーマンスを向上させる</target>
        </trans-unit>
        <trans-unit id="6605838414ae4861872117f11458f4f7c032e53b" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;Promise.method&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Promise.method&lt;/code&gt; のパフォーマンスを向上させる</target>
        </trans-unit>
        <trans-unit id="1801c2ab62399342798816e151c62d526a208232" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;Promise.race&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Promise.race&lt;/code&gt; のパフォーマンスを向上させる</target>
        </trans-unit>
        <trans-unit id="b47c1066dd0e09e1dc6291709e049b1a62126113" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;Promise.try&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Promise.try&lt;/code&gt; のパフォーマンスを向上させる</target>
        </trans-unit>
        <trans-unit id="f0221a27976575e573ab343e0c7bf4e30199750e" translate="yes" xml:space="preserve">
          <source>Improve performance of all collection methods</source>
          <target state="translated">すべての収集方法の性能向上</target>
        </trans-unit>
        <trans-unit id="69bc40cef74e6b8ed6de0d57bc11088841731b08" translate="yes" xml:space="preserve">
          <source>Improve performance of catch filters.</source>
          <target state="translated">キャッチフィルターの性能を向上させる。</target>
        </trans-unit>
        <trans-unit id="493b04565b586c443227bda9dba7b5733786d595" translate="yes" xml:space="preserve">
          <source>Improve performance of collection methods</source>
          <target state="translated">収集方法の性能向上</target>
        </trans-unit>
        <trans-unit id="f3e709b44915764f7a5d40fc9df801ca2e482471" translate="yes" xml:space="preserve">
          <source>Improve performance of generators</source>
          <target state="translated">発電機の性能向上</target>
        </trans-unit>
        <trans-unit id="f2f07a6efaf7192742177f90f38e34f5cffb946a" translate="yes" xml:space="preserve">
          <source>Improve performance of promise chains</source>
          <target state="translated">プロミスチェーンのパフォーマンス向上</target>
        </trans-unit>
        <trans-unit id="ab32070153659d73fbda42374c3ef4d00f9c1281" translate="yes" xml:space="preserve">
          <source>Improve performance of promisified functions on V8</source>
          <target state="translated">V8でのプロミス機能の性能向上</target>
        </trans-unit>
        <trans-unit id="9c964cafe501b6c71e57bfaecc51d7213a1f33ad" translate="yes" xml:space="preserve">
          <source>Improve performance of promisified functions.</source>
          <target state="translated">プロミスされた機能のパフォーマンスを向上させる。</target>
        </trans-unit>
        <trans-unit id="d0964ce694308926e6cce53db966d728b2dd5ab4" translate="yes" xml:space="preserve">
          <source>Improved performance and readability</source>
          <target state="translated">性能と読みやすさの向上</target>
        </trans-unit>
        <trans-unit id="70e80457a02f473b417d800f6ebe8e2a3e15d72c" translate="yes" xml:space="preserve">
          <source>In 2.x, promise cancellation looked very differently. Promise cancellation received a major overhaul for version 3 in order to create a sound variant of cancellable promises. You can still use 2.x cancellation with bluebird 2.x (which is still supported - but not recommended). See &lt;a href=&quot;http://bluebirdjs.com/cancellation.html&quot;&gt;Cancellation&lt;/a&gt; for more details. The 2.x docs are &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/2.x/API.md&quot;&gt;still accessible under the 2.x branch&lt;/a&gt;.</source>
          <target state="translated">2.xでは、約束のキャンセルは非常に異なって見えました。キャンセル可能なプロミスの健全なバリアントを作成するために、プロミスのキャンセルがバージョン3の大幅な見直しを受けました。ブルーバード2.xでも2.xキャンセルを使用できます（これは引き続きサポートされていますが、お勧めしません）。詳しくは&lt;a href=&quot;http://bluebirdjs.com/cancellation.html&quot;&gt;キャンセル&lt;/a&gt;をご覧ください。2.xドキュメントは&lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/2.x/API.md&quot;&gt;、2.xブランチからも引き続きアクセスできます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e8fc7d5be5578254c3c3ba0dde3ab83e463051fa" translate="yes" xml:space="preserve">
          <source>In Node.js you may configure warnings and long stack traces for the entire process using environment variables:</source>
          <target state="translated">Node.jsでは、環境変数を使ってプロセス全体の警告や長いスタックトレースを設定することができます。</target>
        </trans-unit>
        <trans-unit id="361446f42424e75edad97d144b32a1e290e72cc3" translate="yes" xml:space="preserve">
          <source>In Node/io.js most APIs follow a convention of &lt;a href=&quot;https://gist.github.com/CrabDude/10907185&quot;&gt;'error-first, single-parameter'&lt;/a&gt; as such:</source>
          <target state="translated">Node / io.jsでは、ほとんどのAPIは&lt;a href=&quot;https://gist.github.com/CrabDude/10907185&quot;&gt;「エラー優先、単一パラメーター」の&lt;/a&gt;規則に従っています。</target>
        </trans-unit>
        <trans-unit id="20a81f38445f0a6f17f84f7b1c945721cfb38a3e" translate="yes" xml:space="preserve">
          <source>In Web Workers you may use &lt;code&gt;self.addEventListener&lt;/code&gt;.</source>
          <target state="translated">Webワーカーでは、 &lt;code&gt;self.addEventListener&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="6b759cd2431b6c3f52be7951a07c24cc5f5b3b96" translate="yes" xml:space="preserve">
          <source>In addition promises are always unwrapped. A promise implicitly has &lt;code&gt;Task.Unwrap&lt;/code&gt; called on it - that is, promises perform recursive assimilation of promises within them.</source>
          <target state="translated">さらに、promiseは常にアンラップされます。プロミスは暗黙的に &lt;code&gt;Task.Unwrap&lt;/code&gt; が呼び出されます-つまり、プロミスはプロミス内でプロミスの再帰的同化を実行します。</target>
        </trans-unit>
        <trans-unit id="da70284ad0b5f811fe8223b6b3d83e713568a28f" translate="yes" xml:space="preserve">
          <source>In addition promises are always unwrapped. That is, promises perform recursive assimilation of promises within them. You can't have a &lt;code&gt;Promise&amp;lt;Promise&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; where a &lt;code&gt;Future[Future[T]]&lt;/code&gt; is valid in Scala.</source>
          <target state="translated">さらに、promiseは常にアンラップされます。つまり、プロミスはプロミス内でプロミスの再帰的な同化を実行します。Scalaで &lt;code&gt;Future[Future[T]]&lt;/code&gt; が有効な &lt;code&gt;Promise&amp;lt;Promise&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; は使用できません。</target>
        </trans-unit>
        <trans-unit id="b3db467e4305c26c33d91d438b39bab7913a7d8d" translate="yes" xml:space="preserve">
          <source>In all of the above cases the library made its classes available in one way or another. If this is not the case, you can still promisify by creating a throwaway instance:</source>
          <target state="translated">上記のすべてのケースで、ライブラリは何らかの方法でそのクラスを利用できるようにしています。もしそうでない場合でも、スローアウェイのインスタンスを作成することで宣言することができます。</target>
        </trans-unit>
        <trans-unit id="a37bb782f65c2292150ec12a9ec0ac667bbafa9d" translate="yes" xml:space="preserve">
          <source>In bluebird we've chosen to do the latter because resources are typically scarce. For example, if a database connection cannot be disposed of and Bluebird ignores that, the connection pool will be quickly depleted and the process will become unusable (all requests that query the database will wait forever). Since Bluebird doesn't know how to handle that, the only sensible default is to crash the process. That way, rather than getting a useless process that cannot fulfill more requests, we can swap the faulty worker with a new one letting the OS clean up the resources for us.</source>
          <target state="translated">bluebird では、リソースは一般的に不足しているため、後者を選択しました。たとえば、データベース接続を破棄できず、Bluebird がそれを無視した場合、接続プールはすぐに枯渇し、プロセスは使用不能になります (データベースに問い合わせを行うすべてのリクエストは永遠に待たされることになります)。Bluebird はその処理方法を知らないので、唯一の賢明なデフォルトはプロセスをクラッシュさせることです。そうすれば、より多くのリクエストを処理できない役立たずのプロセスを手に入れるよりも、故障したワーカーを新しいものと交換して OS がリソースをクリーンアップしてくれるようになります。</target>
        </trans-unit>
        <trans-unit id="ca0b3dbad60939fa3e3338aec5bf46570e2d8a1a" translate="yes" xml:space="preserve">
          <source>In conjunction with &lt;a href=&quot;disposer&quot;&gt;&lt;code&gt;.disposer&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;using&lt;/code&gt; will make sure that no matter what, the specified disposer will be called when the promise returned by the callback passed to &lt;code&gt;using&lt;/code&gt; has settled. The disposer is necessary because there is no standard interface in node for disposing resources.</source>
          <target state="translated">関連して&lt;a href=&quot;disposer&quot;&gt; &lt;code&gt;.disposer&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;using&lt;/code&gt; 必ずコールバックによって返された約束はに渡されたものを、指定されたディスポーザーが呼び出されますどんなにということになります &lt;code&gt;using&lt;/code&gt; 落ち着きました。ノードにリソースを廃棄するための標準インターフェースがないため、ディスポーザが必要です。</target>
        </trans-unit>
        <trans-unit id="879b1a8e6173fcc0fe684d08d132ce1871ae3253" translate="yes" xml:space="preserve">
          <source>In general, the usage of &lt;a href=&quot;api/promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; is along the lines of &lt;code&gt;var fs = Promise.promisifyAll(require(&quot;fs&quot;))&lt;/code&gt;.</source>
          <target state="translated">一般に、&lt;a href=&quot;api/promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt;の使用法は &lt;code&gt;var fs = Promise.promisifyAll(require(&quot;fs&quot;))&lt;/code&gt; の線に沿っています。</target>
        </trans-unit>
        <trans-unit id="8efb8cf18cab76bf61b065fcc2def10c9ed9fac9" translate="yes" xml:space="preserve">
          <source>In our dialog example perhaps we want to differentiate between a rejected promise because of some problem (bad AJAX, programming error, etc.) or because the user pressed the cancel button.</source>
          <target state="translated">私たちのダイアログの例では、何らかの問題(悪いAJAX、プログラミングエラーなど)のために拒否された約束と、ユーザーがキャンセルボタンを押したために拒否された約束を区別したいと思います。</target>
        </trans-unit>
        <trans-unit id="b6bbd69af3538cceaf0f293038d0f3eaed462ca8" translate="yes" xml:space="preserve">
          <source>In practice:</source>
          <target state="translated">実践では</target>
        </trans-unit>
        <trans-unit id="21b9f4a2f2ffcaff8935b98b291fdfb43db81e8c" translate="yes" xml:space="preserve">
          <source>In recent versions generator libraries started abandoning old ideas of special tokens passed to callbacks and started using promises for what's being yielded.</source>
          <target state="translated">最近のバージョンでは、ジェネレータライブラリはコールバックに渡される特別なトークンの古い考えを放棄して、何が生成されるかにプロミスを使うようになりました。</target>
        </trans-unit>
        <trans-unit id="90361caad2f10101ee0f756a8ebd2978182891e3" translate="yes" xml:space="preserve">
          <source>In the above example, the connection returned by &lt;code&gt;getConnection&lt;/code&gt; can only be used via &lt;code&gt;Promise.using&lt;/code&gt;, like so:</source>
          <target state="translated">上記の例では、 &lt;code&gt;getConnection&lt;/code&gt; によって返される接続は、次のように &lt;code&gt;Promise.using&lt;/code&gt; を介してのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="cb64939e278ff57bb52a7c44ea2a2cbd428cb81a" translate="yes" xml:space="preserve">
          <source>In the explicit construction anti-pattern, promise objects are created for no reason, complicating code.</source>
          <target state="translated">明示的な構造のアンチパターンでは、プロミスオブジェクトは理由もなく作成され、コードを複雑にします。</target>
        </trans-unit>
        <trans-unit id="b0070e87ecff77ecb23ce611e38aac089e617332" translate="yes" xml:space="preserve">
          <source>In the following example you might want to handle just the &lt;code&gt;SyntaxError&lt;/code&gt; from JSON.parse and Filesystem errors from &lt;code&gt;fs&lt;/code&gt; but let programmer errors bubble as unhandled rejections:</source>
          <target state="translated">次の例ではあなただけ処理したいかもしれない &lt;code&gt;SyntaxError&lt;/code&gt; からJSON.parseとファイルシステムのエラーから &lt;code&gt;fs&lt;/code&gt; が、未処理の拒否など、プログラマのエラーバブルをしてみましょう：</target>
        </trans-unit>
        <trans-unit id="73d3bed94715ad4383569042f35e985547cd7283" translate="yes" xml:space="preserve">
          <source>In the latter the indentation stays flat no matter how many previous variables you need, whereas with the former each additional previous value would require an additional nesting level.</source>
          <target state="translated">後者の場合、インデントはいくつ前の変数が必要になってもフラットなままですが、前者の場合は前の値を追加するたびに追加のネスティングレベルが必要になるのに対し、後者の場合は、インデントはフラットなままです。</target>
        </trans-unit>
        <trans-unit id="dd6afd7e774c8e6fdacd9e8f55a35e835be8f939" translate="yes" xml:space="preserve">
          <source>In this case, the promise resolves with itself which was is not intended.</source>
          <target state="translated">この場合、約束は意図されていなかったそれ自体で解決します。</target>
        </trans-unit>
        <trans-unit id="30b4d4283864d46d2836b690ac2cbfeafa74746b" translate="yes" xml:space="preserve">
          <source>Individual promisifcation uses current &lt;code&gt;this&lt;/code&gt; if no explicit receiver is given</source>
          <target state="translated">個々のpromisifcationは、現在使用して &lt;code&gt;this&lt;/code&gt; 明示的な受信機が指定されていない場合</target>
        </trans-unit>
        <trans-unit id="68c8caa0f2f33563e5d4c95632e8edaafba86244" translate="yes" xml:space="preserve">
          <source>Initially the Dialog class sets the two callbacks to &lt;em&gt;noop&lt;/em&gt; functions. It is up to the child class to call them when necessary. We break down the promise creation to one function &lt;code&gt;waitForUser()&lt;/code&gt; that sets the callbacks and returns a promise. At this level the &lt;code&gt;show()&lt;/code&gt; and &lt;code&gt;hide()&lt;/code&gt; are just &lt;em&gt;noop&lt;/em&gt; functions as well and will be implemented by the child classes.</source>
          <target state="translated">最初に、Dialogクラスは2つのコールバックを&lt;em&gt;noop&lt;/em&gt;関数に&lt;em&gt;設定し&lt;/em&gt;ます。必要なときにそれらを呼び出すのは子クラスの役割です。promiseの作成を、コールバックを設定してpromiseを返す1つの関数 &lt;code&gt;waitForUser()&lt;/code&gt; に分解します。このレベルでは、 &lt;code&gt;show()&lt;/code&gt; と &lt;code&gt;hide()&lt;/code&gt; も&lt;em&gt;noop&lt;/em&gt;関数であり、子クラスによって実装されます。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="d84677d86357a2c0115e2ed2adb5f6ec133b7f26" translate="yes" xml:space="preserve">
          <source>Instead of using the Deferred anti-pattern, the code should simply return the promise it already has and propagate values using &lt;code&gt;return&lt;/code&gt;:</source>
          <target state="translated">Deferredアンチパターンを使用する代わりに、コードは単にそれがすでに持っているpromiseを &lt;code&gt;return&lt;/code&gt; を使用して値を伝達する必要があります。</target>
        </trans-unit>
        <trans-unit id="1aed780a746f68d28a85c473dd835c234712b990" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;a href=&quot;api/promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; :</source>
          <target state="translated">代わりに、&lt;a href=&quot;api/promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="659525747c675f26d0d0761f93182ab5228cbc26" translate="yes" xml:space="preserve">
          <source>Into this:</source>
          <target state="translated">これに</target>
        </trans-unit>
        <trans-unit id="a66cb4039287c802cdc27ed98f34dc1c2d5d9411" translate="yes" xml:space="preserve">
          <source>It also works on singletons or specific instances:</source>
          <target state="translated">シングルトンや特定のインスタンスでも動作します。</target>
        </trans-unit>
        <trans-unit id="6b5d95eeedfe49016755274286b46a188fd09776" translate="yes" xml:space="preserve">
          <source>It comes in two variants. - A tapCatch-all variant similar to &lt;a href=&quot;catch&quot;&gt;&lt;code&gt;.catch&lt;/code&gt;&lt;/a&gt; block. This variant is compatible with native promises. - A filtered variant (like other non-JS languages typically have) that lets you only handle specific errors. &lt;strong&gt;This variant is usually preferable&lt;/strong&gt;.</source>
          <target state="translated">これには2つのバリアントがあります。&lt;a href=&quot;catch&quot;&gt; &lt;code&gt;.catch&lt;/code&gt; &lt;/a&gt;ブロックと同様のtapCatch-allバリアント。このバリアントはネイティブプロミスと互換性があります。-特定のエラーのみを処理できるフィルター処理されたバリアント（他の非JS言語が通常持っているように）。&lt;strong&gt;このバリアントは通常望ましい&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="e2a3866a72ba04bc9a62fa718c486091a65f59f8" translate="yes" xml:space="preserve">
          <source>It is equivalent to the following &lt;a href=&quot;catch&quot;&gt;&lt;code&gt;.catch&lt;/code&gt;&lt;/a&gt; pattern:</source>
          <target state="translated">これは、次の&lt;a href=&quot;catch&quot;&gt; &lt;code&gt;.catch&lt;/code&gt; &lt;/a&gt;パターンと同等です。</target>
        </trans-unit>
        <trans-unit id="0b0ded67bc5c7c35daa1f171d80dccf1a33e74e4" translate="yes" xml:space="preserve">
          <source>It is essentially an efficient shortcut for doing a &lt;a href=&quot;map&quot;&gt;&lt;code&gt;.map&lt;/code&gt;&lt;/a&gt; and then &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter&quot;&gt;&lt;code&gt;Array#filter&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">これは基本的に&lt;a href=&quot;map&quot;&gt; &lt;code&gt;.map&lt;/code&gt; &lt;/a&gt;を実行してから&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter&quot;&gt; &lt;code&gt;Array#filter&lt;/code&gt; &lt;/a&gt;を実行するための効率的なショートカットです。</target>
        </trans-unit>
        <trans-unit id="67ad0cadb6c3a5671744781f608f9a02e1c5a392" translate="yes" xml:space="preserve">
          <source>It is more likely that you would write this instead in the sync world:</source>
          <target state="translated">シンクロの世界では代わりにこれを書く可能性の方が高いです。</target>
        </trans-unit>
        <trans-unit id="53a01add8c2bcb3ae05a334c130487578987c686" translate="yes" xml:space="preserve">
          <source>It is often said that promises cannot be cancellable because they can have multiple consumers.</source>
          <target state="translated">プロミスは複数の消費者を持つことができるので、解約できないとよく言われています。</target>
        </trans-unit>
        <trans-unit id="6b0e7d44695db980a8f0ed40ee055bb11d90c7f7" translate="yes" xml:space="preserve">
          <source>It is very subtle but over time this code will exhaust the entire connection pool and the server needs to be restarted. This is because reading the file may fail and then of course &lt;code&gt;.spread&lt;/code&gt; is not called at all and thus the connection is not closed.</source>
          <target state="translated">非常に微妙ですが、時間の経過とともにこのコードは接続プール全体を使い果たし、サーバーを再起動する必要があります。これは、ファイルの読み取りが失敗し、当然 &lt;code&gt;.spread&lt;/code&gt; がまったく呼び出されないため、接続が閉じられないためです。</target>
        </trans-unit>
        <trans-unit id="25e4aad38b66ae4f579919e5442c2f87282d298e" translate="yes" xml:space="preserve">
          <source>It might look like this:</source>
          <target state="translated">こんな感じになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="f3201aa0565e8be1e1547bcb52a2f64c00b2bc44" translate="yes" xml:space="preserve">
          <source>It should be noted that there is no real need to attach the handlers asynchronously. Exactly the same effect can be achieved with:</source>
          <target state="translated">ハンドラを非同期にアタッチする必要はないことに注意してください。全く同じ効果が得られます。</target>
        </trans-unit>
        <trans-unit id="f25d9aa71a1aef724d7f8d933c376e203e6ccfd0" translate="yes" xml:space="preserve">
          <source>It's also possible to use a disposer pattern (but not actual disposers) for transaction management:</source>
          <target state="translated">ディスポーザーパターン(実際のディスポーザーではない)で取引管理をすることも可能です。</target>
        </trans-unit>
        <trans-unit id="a3b38a83ae257f40976a60195f877e73b38d539c" translate="yes" xml:space="preserve">
          <source>Iterate over an array, or a promise of an array, which contains promises (or a mix of promises and values) with the given &lt;code&gt;iterator&lt;/code&gt; function with the signature &lt;code&gt;(value, index, length)&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the resolved value of a respective promise in the input array. &lt;strong&gt;Iteration happens serially&lt;/strong&gt;. If the iterator function returns a promise or a thenable, then the result of the promise is awaited before continuing with next iteration. If any promise in the input array is rejected, then the returned promise is rejected as well.</source>
          <target state="translated">配列または配列のpromiseを反復処理します。これは、シグニチャ &lt;code&gt;(value, index, length)&lt;/code&gt; 指定された &lt;code&gt;iterator&lt;/code&gt; 関数でpromise（またはpromiseとvalueの混合）を含み、 &lt;code&gt;value&lt;/code&gt; はそれぞれのpromiseの解決された値です入力配列。&lt;strong&gt;反復は連続的に行われ&lt;/strong&gt;ます。反復関数がpromiseまたはthenableを返す場合、次の反復を続行する前にpromiseの結果が待機されます。入力配列のプロミスが拒否された場合、返されたプロミスも同様に拒否されます。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d889900760cbb5576feda8db1d4c5015016f6e85" translate="yes" xml:space="preserve">
          <source>Iterate over an array, or a promise of an array, which contains promises (or a mix of promises and values) with the given &lt;code&gt;iterator&lt;/code&gt; function with the signature &lt;code&gt;(value, index, length)&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the resolved value of a respective promise in the input array. Iteration happens serially. If any promise in the input array is rejected the returned promise is rejected as well.</source>
          <target state="translated">配列または配列のpromiseを反復処理します。これは、シグニチャ &lt;code&gt;(value, index, length)&lt;/code&gt; 指定された &lt;code&gt;iterator&lt;/code&gt; 関数でpromise（またはpromiseとvalueの混合）を含み、 &lt;code&gt;value&lt;/code&gt; はそれぞれのpromiseの解決された値です入力配列。反復は連続的に行われます。入力配列内のプロミスが拒否された場合、返されたプロミスも同様に拒否されます。</target>
        </trans-unit>
        <trans-unit id="e027e57610f85225767aafbbf23fed7457e55828" translate="yes" xml:space="preserve">
          <source>Java</source>
          <target state="translated">Java</target>
        </trans-unit>
        <trans-unit id="769460330d98abc38d4f157088d641889b8e080c" translate="yes" xml:space="preserve">
          <source>Just like a future, a promise represents a value over time. The value can resolve to either a fulfilled (ok completion) or rejected (error completion) state.</source>
          <target state="translated">未来と同じように、約束は時間の経過とともに価値を表します。値は、満たされた状態(OK完了)と拒否された状態(エラー完了)のどちらかに解決することができます。</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MITライセンスに基づいてライセンスされています。</target>
        </trans-unit>
        <trans-unit id="d2b04d056ad9ef4e9bfb796dceb8c12c3d2724b7" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;all&quot;&gt;&lt;code&gt;.all&lt;/code&gt;&lt;/a&gt; but for object properties or &lt;code&gt;Map&lt;/code&gt;s* entries instead of iterated values. Returns a promise that is fulfilled when all the properties of the object or the &lt;code&gt;Map&lt;/code&gt;'s' values** are fulfilled. The promise's fulfillment value is an object or a &lt;code&gt;Map&lt;/code&gt; with fulfillment values at respective keys to the original object or a &lt;code&gt;Map&lt;/code&gt;. If any promise in the object or &lt;code&gt;Map&lt;/code&gt; rejects, the returned promise is rejected with the rejection reason.</source>
          <target state="translated">&lt;a href=&quot;all&quot;&gt; &lt;code&gt;.all&lt;/code&gt; &lt;/a&gt;と同様ですが、反復された値ではなく、オブジェクトプロパティまたは &lt;code&gt;Map&lt;/code&gt; s *エントリ用です。オブジェクトのすべてのプロパティまたは &lt;code&gt;Map&lt;/code&gt; の値**が満たされると満たされるpromiseを返します。約束の履行値は、オブジェクトまたはある &lt;code&gt;Map&lt;/code&gt; 元のオブジェクトまたはに各キーで履行値で &lt;code&gt;Map&lt;/code&gt; 。オブジェクトまたは &lt;code&gt;Map&lt;/code&gt; 内の約束が拒否された場合、返された約束は拒否理由とともに拒否されます。</target>
        </trans-unit>
        <trans-unit id="0868022eae9754566ebce8819ba10c34f00156c4" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;catch&quot;&gt;&lt;code&gt;.catch&lt;/code&gt;&lt;/a&gt; but instead of catching all types of exceptions, it only catches operational errors.</source>
          <target state="translated">&lt;a href=&quot;catch&quot;&gt; &lt;code&gt;.catch&lt;/code&gt; &lt;/a&gt;と同様ですが、すべてのタイプの例外をキャッチするのではなく、操作エラーのみをキャッチします。</target>
        </trans-unit>
        <trans-unit id="f7724ecb2f95d5397a59e0da7c44a35554300566" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;finally&quot;&gt;&lt;code&gt;.finally&lt;/code&gt;&lt;/a&gt; that is not called for fulfillments.</source>
          <target state="translated">同様&lt;a href=&quot;finally&quot;&gt; &lt;code&gt;.finally&lt;/code&gt; &lt;/a&gt;成就のために呼ばれません。</target>
        </trans-unit>
        <trans-unit id="4b705bae03f08f49a3c59a2a4c3c23676360ce32" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;promise.some&quot;&gt;&lt;code&gt;Promise.some&lt;/code&gt;&lt;/a&gt;, with 1 as &lt;code&gt;count&lt;/code&gt;. However, if the promise fulfills, the fulfillment value is not an array of 1 but the value directly.</source>
          <target state="translated">同様&lt;a href=&quot;promise.some&quot;&gt; &lt;code&gt;Promise.some&lt;/code&gt; &lt;/a&gt;として1と、 &lt;code&gt;count&lt;/code&gt; 。ただし、promiseが満たされる場合、フルフィルメント値は1の配列ではなく、値です。</target>
        </trans-unit>
        <trans-unit id="a0572842c5b510f6b6c6d450ffa47af7bfa19546" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;then&quot;&gt;&lt;code&gt;.then&lt;/code&gt;&lt;/a&gt;, but any unhandled rejection that ends up here will crash the process (in node) or be thrown as an error (in browsers). The use of this method is heavily discouraged and it only exists for historical reasons.</source>
          <target state="translated">&lt;a href=&quot;then&quot;&gt; &lt;code&gt;.then&lt;/code&gt; &lt;/a&gt;と同様ですが、ここで処理されない未処理の拒否によりプロセスがクラッシュするか（ノード内）、エラーとしてスローされます（ブラウザ内）。この方法の使用は強く推奨されておらず、歴史的な理由でのみ存在します。</target>
        </trans-unit>
        <trans-unit id="1d64e920d46f5914cb7b3fc3949b2df8768d761d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;.map&lt;/code&gt; and &lt;code&gt;.filter&lt;/code&gt;, &lt;code&gt;.reduce&lt;/code&gt; now allows returning promises and thenables from the iteration function.</source>
          <target state="translated">&lt;code&gt;.map&lt;/code&gt; や &lt;code&gt;.filter&lt;/code&gt; と同様に、 &lt;code&gt;.reduce&lt;/code&gt; は繰り返し関数からpromiseとthenableを返すことができるようになりました。</target>
        </trans-unit>
        <trans-unit id="f9b88079f4caa0345add2b49d7a0be51ed016806" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;.then()&lt;/code&gt;, but any unhandled rejection that ends up here will be thrown as an error. Again, only the variant with the progression handler is deprecated here. &lt;code&gt;.done&lt;/code&gt; is still fully supported.</source>
          <target state="translated">&lt;code&gt;.then()&lt;/code&gt; と同様ですが、ここで処理されない未処理の拒否はエラーとしてスローされます。繰り返しになりますが、ここでは、progressionハンドラーを持つバリアントのみが非推奨になっています。 &lt;code&gt;.done&lt;/code&gt; は引き続き完全にサポートされています。</target>
        </trans-unit>
        <trans-unit id="eaab59843408be17f1182d2a7ba7d498c9751120" translate="yes" xml:space="preserve">
          <source>Like calling &lt;code&gt;.then&lt;/code&gt;, but the fulfillment value &lt;em&gt;must be&lt;/em&gt; an array, which is flattened to the formal parameters of the fulfillment handler.</source>
          <target state="translated">&lt;code&gt;.then&lt;/code&gt; を呼び出すのと同じですが、フルフィルメント値&lt;em&gt;は&lt;/em&gt;配列である&lt;em&gt;必要があります&lt;/em&gt;。配列は、フルフィルメントハンドラーの仮パラメーターにフラット化されます。</target>
        </trans-unit>
        <trans-unit id="4d46fec21cdff120fbce1d5c81043ed187891e17" translate="yes" xml:space="preserve">
          <source>Local rejection events</source>
          <target state="translated">地元での拒絶反応イベント</target>
        </trans-unit>
        <trans-unit id="57003616863fe634c645e342ee9080681e419c5f" translate="yes" xml:space="preserve">
          <source>Logging</source>
          <target state="translated">Logging</target>
        </trans-unit>
        <trans-unit id="25c9bdc07ce0dfdf61f61c6ce40dbedeb1c6dd8e" translate="yes" xml:space="preserve">
          <source>Logging after the promise became GCd (requires a native node.js module)</source>
          <target state="translated">プロミスがGCdになった後のロギング (ネイティブのnode.jsモジュールが必要)</target>
        </trans-unit>
        <trans-unit id="44413342754143aa1961f15d95ef6db04a6b6098" translate="yes" xml:space="preserve">
          <source>Long stack traces</source>
          <target state="translated">長いスタックトレース</target>
        </trans-unit>
        <trans-unit id="4d0119ac596cae5eba4e7c9ece07c3d282260f3e" translate="yes" xml:space="preserve">
          <source>Long stack traces are enabled by default in the debug build.</source>
          <target state="translated">デバッグビルドでは、長いスタックトレースはデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="5585738e86f015af086921d0b41e009a6fb65e3d" translate="yes" xml:space="preserve">
          <source>Long stack traces are only supported in Chrome, recent Firefoxes and Internet Explorer 10+</source>
          <target state="translated">ロングスタックトレースはChrome、最近のFirefox、Internet Explorer 10+でのみサポートされています。</target>
        </trans-unit>
        <trans-unit id="9aba1e438bce5b03f5ff76a06150c5afd0f112d5" translate="yes" xml:space="preserve">
          <source>Long stack traces are supported now in IE10+</source>
          <target state="translated">長いスタックトレースがIE10+でサポートされるようになりました。</target>
        </trans-unit>
        <trans-unit id="0d4e72958bdd71df94bdc91c2471299f772d9de9" translate="yes" xml:space="preserve">
          <source>Long stack traces have been re-designed. They are now much more readable, succint, relevant and consistent across bluebird features.</source>
          <target state="translated">長いスタックトレースが再設計されました。これにより、より読みやすく、簡潔で、関連性があり、ブルーバードの機能全体で一貫性があります。</target>
        </trans-unit>
        <trans-unit id="4d32bb2f1ca24d68c701d853a17b879746200c1e" translate="yes" xml:space="preserve">
          <source>Major debuggability improvements:</source>
          <target state="translated">デバッガ性の大幅な改善。</target>
        </trans-unit>
        <trans-unit id="4e7cd8e3e2364f713fb55eb6da548439b6487c93" translate="yes" xml:space="preserve">
          <source>Major internal refactoring related to testing code and source code file layout</source>
          <target state="translated">テストコードとソースコードファイルのレイアウトに関連した主要な内部リファクタリング</target>
        </trans-unit>
        <trans-unit id="7d05db1f390d07e6c3780eb841599459e0bc86db" translate="yes" xml:space="preserve">
          <source>Make .race() and Promise.race() forever pending on empty collections</source>
          <target state="translated">空のコレクションに対して .race()と Promise.race()を永遠に保留するようにします。</target>
        </trans-unit>
        <trans-unit id="a958e3fae41091d69ad2857f0e309f4e5d0123cb" translate="yes" xml:space="preserve">
          <source>Make PromiseRejectionEvent confrom to spec (&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/1509&quot;&gt;&lt;code&gt;#1509&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">PromiseRejectionEventを仕様に変換する（&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/1509&quot;&gt; &lt;code&gt;#1509&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="f545f488c8e51d1bcb95f6e96e06f76a78762db7" translate="yes" xml:space="preserve">
          <source>Make build script's output work without TTY</source>
          <target state="translated">TTYなしでビルドスクリプトの出力が動作するようにする</target>
        </trans-unit>
        <trans-unit id="6de105dd31451a68ffa7b10edcdad659c72911a0" translate="yes" xml:space="preserve">
          <source>Make progress a core feature. Fixes &lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/535&quot;&gt;&lt;code&gt;#535&lt;/code&gt;&lt;/a&gt; Note that progress has been removed in 3.x - this is only a fix necessary for 2.x custom builds.</source>
          <target state="translated">進歩をコア機能にします。修正&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/535&quot;&gt; &lt;code&gt;#535&lt;/code&gt; &lt;/a&gt; 3.xでは進行状況が削除されていることに注意してください。これは2.xカスタムビルドに必要な修正にすぎません。</target>
        </trans-unit>
        <trans-unit id="d25de34f144aaa815f7ee100219c0875ec327f00" translate="yes" xml:space="preserve">
          <source>Make tests pass Internet Explorer 8</source>
          <target state="translated">テストを通過させる Internet Explorer 8</target>
        </trans-unit>
        <trans-unit id="2ae67022300ef1cd200bf479b96deb439531bc00" translate="yes" xml:space="preserve">
          <source>Managing resources properly without leaks can be challenging. Simply using &lt;code&gt;.finally&lt;/code&gt; is not enough as the following example demonstrates:</source>
          <target state="translated">リークなしでリソースを適切に管理することは困難な場合があります。次の例に示すように、単に &lt;code&gt;.finally&lt;/code&gt; を使用するだけでは不十分です。</target>
        </trans-unit>
        <trans-unit id="107b1032597492e8483d652c4a4ce608f171eba8" translate="yes" xml:space="preserve">
          <source>Map Option: concurrency</source>
          <target state="translated">マップオプション:同時実行</target>
        </trans-unit>
        <trans-unit id="a50a46e16b741d58429e4aa0f944bc0391ee46f8" translate="yes" xml:space="preserve">
          <source>Methods of &lt;code&gt;Promise&lt;/code&gt; instances and core static methods of the Promise class to deal with collections of promises or mixed promises and values.</source>
          <target state="translated">&lt;code&gt;Promise&lt;/code&gt; インスタンスのメソッドおよびPromiseクラスのコア静的メソッド。PromiseのコレクションまたはPromiseと値の混合を処理します。</target>
        </trans-unit>
        <trans-unit id="ae38184c5e1cc02a77f22646c0e9e6fb64bf94fd" translate="yes" xml:space="preserve">
          <source>Methods on &lt;code&gt;Function.prototype&lt;/code&gt; are no longer promisified (&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/680&quot;&gt;&lt;code&gt;#680&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;Function.prototype&lt;/code&gt; のメソッドは約束されなくなりました（&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/680&quot;&gt; &lt;code&gt;#680&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="af7ee6528f585594a5d8dbab3c9c2ad5078d7461" translate="yes" xml:space="preserve">
          <source>Minified source file meant to be used in production. Warnings and long straces are disabled. The gzipped size is 17.76KB.</source>
          <target state="translated">本番環境で使用することを意図したミニ化されたソースファイルです。警告や長い文字列は無効化されています。gzip圧縮されたサイズは17.76KBです。</target>
        </trans-unit>
        <trans-unit id="cddf33528c938c1495240e1ee5dc6ea07a8ea077" translate="yes" xml:space="preserve">
          <source>Misc:</source>
          <target state="translated">Misc:</target>
        </trans-unit>
        <trans-unit id="cbb2eaaf602b7e2cec410e3a49e5f52907359976" translate="yes" xml:space="preserve">
          <source>Mongoose works with persistent connections and the driver takes care of reconnections/disposals. For this reason using &lt;code&gt;using&lt;/code&gt; with it isn't required - instead connect on server startup and use promisification to expose promises.</source>
          <target state="translated">Mongooseは永続的な接続で動作し、ドライバーが再接続/破棄を処理します。このため、with usingを &lt;code&gt;using&lt;/code&gt; する必要はありません。代わりに、サーバーの起動時に接続し、promisificationを使用してpromiseを公開します。</target>
        </trans-unit>
        <trans-unit id="bc8341442a59c4454f469778737b7b06e02ad229" translate="yes" xml:space="preserve">
          <source>Mongoose/MongoDB</source>
          <target state="translated">Mongoose/MongoDB</target>
        </trans-unit>
        <trans-unit id="331f3f9f6d3697a3169ac32b4263f8b1778c3e97" translate="yes" xml:space="preserve">
          <source>More Common Examples</source>
          <target state="translated">より一般的な例</target>
        </trans-unit>
        <trans-unit id="5623f76074955ea9ab1db3ab04c9bff15d87a6c2" translate="yes" xml:space="preserve">
          <source>More common examples</source>
          <target state="translated">より一般的な例</target>
        </trans-unit>
        <trans-unit id="eb77d4b0690c471c302bf76046f4c7afa76f3db6" translate="yes" xml:space="preserve">
          <source>More performance improvements when long stack traces are enabled</source>
          <target state="translated">長いスタックトレースを有効にすると、パフォーマンスがさらに向上します。</target>
        </trans-unit>
        <trans-unit id="3a7a86c3c7bb6f061ed4b7dd4612a07ea2e55494" translate="yes" xml:space="preserve">
          <source>More reading:</source>
          <target state="translated">続きを読む</target>
        </trans-unit>
        <trans-unit id="deaa0c393a6613972aaccbf1fecfdad67aa21e88" translate="yes" xml:space="preserve">
          <source>MySQL</source>
          <target state="translated">MySQL</target>
        </trans-unit>
        <trans-unit id="63cd8ad40499d81ac4cfa72cb023f0f0e2a46fc4" translate="yes" xml:space="preserve">
          <source>New in bluebird 3.0</source>
          <target state="translated">ブルーバード3.0の新機能</target>
        </trans-unit>
        <trans-unit id="4c06116ec441fcbe51fa98c044bc02e5a87998c7" translate="yes" xml:space="preserve">
          <source>New method: &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#promiseonunhandledrejectionhandledfunction-handler---undefined&quot;&gt;&lt;code&gt;Promise.onUnhandledRejectionHandled()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">新しいメソッド：&lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#promiseonunhandledrejectionhandledfunction-handler---undefined&quot;&gt; &lt;code&gt;Promise.onUnhandledRejectionHandled()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98ef7df279344d4e364f9fc4312d95513017e539" translate="yes" xml:space="preserve">
          <source>New method: &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#reason---dynamic&quot;&gt;&lt;code&gt;.reason()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">新しいメソッド：&lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#reason---dynamic&quot;&gt; &lt;code&gt;.reason()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7244a976bd562fa5bdab260bfa92ffb53b2f75df" translate="yes" xml:space="preserve">
          <source>New method: &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#value---dynamic&quot;&gt;&lt;code&gt;.value()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">新しいメソッド：&lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#value---dynamic&quot;&gt; &lt;code&gt;.value()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e97753de8b2fb704fe13fb56eee1b6956901e28" translate="yes" xml:space="preserve">
          <source>Node environment detection can no longer be fooled</source>
          <target state="translated">ノード環境の検出が誤魔化せなくなった</target>
        </trans-unit>
        <trans-unit id="36f139c394850c9c9489f54e55411c65c03b1e5e" translate="yes" xml:space="preserve">
          <source>Node installation</source>
          <target state="translated">ノードのインストール</target>
        </trans-unit>
        <trans-unit id="10b3493287f831e81a438811a1ffba01f8cec4b7" translate="yes" xml:space="preserve">
          <source>Node.js</source>
          <target state="translated">Node.js</target>
        </trans-unit>
        <trans-unit id="973a79d67e462fcd740058903de5ac75c5e42ed4" translate="yes" xml:space="preserve">
          <source>Node.js performance: promisified functions try to check amount of passed arguments in most optimal order</source>
          <target state="translated">Node.jsのパフォーマンス:プロミスされた関数は渡された引数の量を最適な順序でチェックしようとする</target>
        </trans-unit>
        <trans-unit id="21d569f35ecd5c10a6a6f1ab8aec8e1753640885" translate="yes" xml:space="preserve">
          <source>Node.js promisified functions will have same &lt;code&gt;.length&lt;/code&gt; as the original function minus one (for the callback parameter)</source>
          <target state="translated">Node.jsの約束された関数は、元の関数と同じ &lt;code&gt;.length&lt;/code&gt; から1を引いたものになります（コールバックパラメーター用）</target>
        </trans-unit>
        <trans-unit id="6c8c6cfa65668d483f7a4b264c38fc353e937af3" translate="yes" xml:space="preserve">
          <source>Nodeify doesn't pass second argument to the callback if the promise is fulfilled with &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">Nodeifyは、promiseが &lt;code&gt;undefined&lt;/code&gt; で満たされている場合、2番目の引数をコールバックに渡しません。</target>
        </trans-unit>
        <trans-unit id="b5673141cf57847c5379b8f84249704a24a566a4" translate="yes" xml:space="preserve">
          <source>None of the collection methods modify the original input. Holes in arrays are treated as if they were defined with the value &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">どの収集メソッドも元の入力を変更しません。配列の穴は、値 &lt;code&gt;undefined&lt;/code&gt; で定義されているかのように扱われます。</target>
        </trans-unit>
        <trans-unit id="7e35ac0a9b7c71da68e4e0db0a51a9c2cf39da4d" translate="yes" xml:space="preserve">
          <source>Normal callbacks:</source>
          <target state="translated">通常のコールバック。</target>
        </trans-unit>
        <trans-unit id="0d7e35c7b10d9ccf8a2e395ca44cbdd4ab1c9fb3" translate="yes" xml:space="preserve">
          <source>Normally stack traces don't go beyond asynchronous boundaries so their utility is greatly reduced in asynchronous code:</source>
          <target state="translated">通常、スタックトレースは非同期の境界を超えないので、非同期コードではその有用性が大幅に低下します。</target>
        </trans-unit>
        <trans-unit id="5bbef690c10dd98cdafb9fad511260630850d165" translate="yes" xml:space="preserve">
          <source>Not only is the code shorter but more importantly, if there is any error it will propagate properly to the final consumer.</source>
          <target state="translated">コードが短くなるだけでなく、より重要なことは、もしエラーが発生した場合、最終的な消費者に適切に伝搬するということです。</target>
        </trans-unit>
        <trans-unit id="601e20ca34667b0a121fe532f625d50ac9e32a89" translate="yes" xml:space="preserve">
          <source>Note - in order to get full stack traces with warnings in Node 6.x+ you need to enable to &lt;code&gt;--trace-warnings&lt;/code&gt; flag which will give you a full stack trace of where the warning is coming from.</source>
          <target state="translated">注-ノード6.x +で警告付きの完全なスタックトレースを取得するには、 &lt;code&gt;--trace-warnings&lt;/code&gt; フラグを有効にする必要があります。これにより、警告の発生元の完全なスタックトレースが得られます。</target>
        </trans-unit>
        <trans-unit id="14f4f32d734d4dde2357de9c28aa2e9db4f442b8" translate="yes" xml:space="preserve">
          <source>Note about disposers in node</source>
          <target state="translated">ノードのディスポーザについての注意点</target>
        </trans-unit>
        <trans-unit id="628368b01a8c147d7adbe65259137f54770d74df" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;spread&quot;&gt;&lt;code&gt;.spread()&lt;/code&gt;&lt;/a&gt; implicitly does &lt;a href=&quot;all&quot;&gt;&lt;code&gt;.all()&lt;/code&gt;&lt;/a&gt; but the ES6 destructuring syntax doesn't, hence the manual &lt;code&gt;.all()&lt;/code&gt; call in the above code.</source>
          <target state="translated">なお&lt;a href=&quot;spread&quot;&gt; &lt;code&gt;.spread()&lt;/code&gt; &lt;/a&gt;暗黙的に行います&lt;a href=&quot;all&quot;&gt; &lt;code&gt;.all()&lt;/code&gt; &lt;/a&gt;が、ES6の非構造構文しない、したがって、手動 &lt;code&gt;.all()&lt;/code&gt; 上記のコードでコール。</target>
        </trans-unit>
        <trans-unit id="4f4cc52a9da922cd3c5be1d218aeb2480ead589e" translate="yes" xml:space="preserve">
          <source>Note that Mongoose already ships with promise support but the promises it offers are significantly slower and don't report unhandled rejections so it is recommended to use automatic promisification with it anyway:</source>
          <target state="translated">Mongoose はすでにプロミスのサポートを提供していますが、それが提供するプロミスはかなり遅く、未処理の拒否を報告しないので、とにかく自動プロミス化を使うことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="29e8a3550207f0693fbe258a0b408370b65284bd" translate="yes" xml:space="preserve">
          <source>Note that bind is only propagated with promise transformation. If you create new promise chains inside a handler, those chains are not bound to the &quot;upper&quot; &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">bindはpromise変換でのみ伝播されることに注意してください。ハンドラー内に新しいpromiseチェーンを作成する場合、それらのチェーンは &lt;code&gt;this&lt;/code&gt; の「上位」にバインドされません。</target>
        </trans-unit>
        <trans-unit id="e18ae6fc287a535de54a7ef47226f40baba44a5f" translate="yes" xml:space="preserve">
          <source>Note that if the node function is a method of some object, you can pass the object as the second argument like so:</source>
          <target state="translated">ノード関数が何らかのオブジェクトのメソッドである場合、次のようにオブジェクトを第2引数に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="049b2f103da24d1cdf9b651db0f13464d2a62368" translate="yes" xml:space="preserve">
          <source>Note that if using ES6, the above can be replaced with &lt;a href=&quot;then&quot;&gt;&lt;code&gt;.then()&lt;/code&gt;&lt;/a&gt; and destructuring:</source>
          <target state="translated">ES6を使用している場合は、上記を&lt;a href=&quot;then&quot;&gt; &lt;code&gt;.then()&lt;/code&gt; に&lt;/a&gt;置き換えて構造を解除できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="e0a368b621b24c61956a2d40d7353ec38ebe9f4e" translate="yes" xml:space="preserve">
          <source>Note that if you have no use for the result object other than retrieving the properties, it is more convenient to use &lt;a href=&quot;promise.join&quot;&gt;&lt;code&gt;Promise.join&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">プロパティを取得する以外に結果オブジェクトを使用しない場合は、&lt;a href=&quot;promise.join&quot;&gt; &lt;code&gt;Promise.join&lt;/code&gt; &lt;/a&gt;を使用する方が便利です。</target>
        </trans-unit>
        <trans-unit id="3de0bd0db4f60bc1b355d5d97bda28262272a5e5" translate="yes" xml:space="preserve">
          <source>Note that it is an error to consume an already cancelled promise, doing such a thing will give you a promise that is rejected with &lt;code&gt;new CancellationError(&quot;late cancellation observer&quot;)&lt;/code&gt; as the rejection reason.</source>
          <target state="translated">すでにキャンセルされたプロミスを消費することはエラーであることに注意してください。このようなことをすると、プロジェクションが拒否され、プロジェクションは拒否理由として &lt;code&gt;new CancellationError(&quot;late cancellation observer&quot;)&lt;/code&gt; で拒否されます。</target>
        </trans-unit>
        <trans-unit id="7fba6dfbb297631502284b27e815e4abd333271d" translate="yes" xml:space="preserve">
          <source>Note that promises model a &lt;em&gt;single value through time&lt;/em&gt;, they only resolve &lt;em&gt;once&lt;/em&gt; - so while they're a good fit for a single event, they are not recommended for multiple event APIs.</source>
          <target state="translated">Promiseは&lt;em&gt;時間の経過&lt;/em&gt;とともに&lt;em&gt;単一の値を&lt;/em&gt;モデル化し、&lt;em&gt;一&lt;/em&gt;&lt;em&gt;度&lt;/em&gt;だけ解決することに注意してください。つまり、Promise は単一のイベントには適していますが、複数のイベントAPIには推奨されません。</target>
        </trans-unit>
        <trans-unit id="6c0a18493f92a9cdbebf344b13ce97703f7982f1" translate="yes" xml:space="preserve">
          <source>Note that the 3.0.1 update is strictly speaking backward-incompatible with 3.0.0. Version 3.0.0 changed the previous behavior of the &lt;code&gt;.each&lt;/code&gt; method and made it work more same as the new &lt;code&gt;.mapSeries&lt;/code&gt; - 3.0.1 unrolls this change by reverting to the &lt;code&gt;.tap&lt;/code&gt;-like behavior found in 2.x However, this would only affect users who updated to 3.0.0 during the short time that it wasn't deprecated and started relying on the new &lt;code&gt;.each&lt;/code&gt; behavior. This seems unlikely, and therefore the major version was not changed.</source>
          <target state="translated">3.0.1アップデートは厳密には3.0.0との下位互換性がないことに注意してください。バージョン3.0.0では、 &lt;code&gt;.each&lt;/code&gt; メソッドの以前の動作が変更され、新しい &lt;code&gt;.mapSeries&lt;/code&gt; と同じように機能しました。3.0.1では、2.x にある &lt;code&gt;.tap&lt;/code&gt; のような動作に戻すことで、この変更が展開されます。ただし、これは非推奨ではなく、新しい &lt;code&gt;.each&lt;/code&gt; 動作に依存し始めた短い期間に3.0.0に更新したユーザーに影響します。これはありそうにないので、メジャーバージョンは変更されませんでした。</target>
        </trans-unit>
        <trans-unit id="11cceaa640eecb54100f4808cad7ab17b5e595d4" translate="yes" xml:space="preserve">
          <source>Note that the 3.0.1 update is strictly speaking backward-incompatible with 3.0.0. Version 3.0.0 changed the previous behavior of the &lt;code&gt;.each&lt;/code&gt; method and made it work the same as the new &lt;code&gt;.mapSeries&lt;/code&gt; - 3.0.1 unrolls this change by reverting to the &lt;code&gt;.tap&lt;/code&gt;-like behavior found in 2.x However, this would only affect users who updated to 3.0.0 during the short time that it wasn't deprecated and started relying on the new &lt;code&gt;.each&lt;/code&gt; behavior. This seems unlikely, and therefore the major version was not changed.</source>
          <target state="translated">3.0.1アップデートは厳密に言えば3.0.0と後方互換性がないことに注意してください。バージョン3.0.0は、 &lt;code&gt;.each&lt;/code&gt; メソッドの以前の動作を変更し、新しい &lt;code&gt;.mapSeries&lt;/code&gt; と同じように &lt;code&gt;.tap&lt;/code&gt; ようにしました。3.0.1は、2.xにある.tapのような動作に戻すことで、この変更を展開します。非推奨ではなく、新しい &lt;code&gt;.each&lt;/code&gt; 動作に依存し始めた短期間に3.0.0に更新したユーザーに影響します。これはありそうもないと思われるため、メジャーバージョンは変更されていません。</target>
        </trans-unit>
        <trans-unit id="ddb0ec4c290533d8d13b5512c50f3aff8444246e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;onCancel&lt;/code&gt; hook is really an optional disconnected optimization, there is no real requirement to register any cancellation hooks for cancellation to work. As such, any errors that may occur while inside the &lt;code&gt;onCancel&lt;/code&gt; callback are not caught and turned into rejections.</source>
          <target state="translated">&lt;code&gt;onCancel&lt;/code&gt; フックは実際にはオプションの切断された最適化であることに注意してください。キャンセルを機能させるためにキャンセルフックを登録する実際の要件はありません。そのため、 &lt;code&gt;onCancel&lt;/code&gt; コールバック内で発生する可能性のあるエラーはキャッチされず、拒否されます。</target>
        </trans-unit>
        <trans-unit id="1635db28b0639fbcd8af0cf2d7a5c771bbc04b90" translate="yes" xml:space="preserve">
          <source>Note that the above is an exceptional case because &lt;code&gt;fs&lt;/code&gt; is a singleton instance. Most libraries can be promisified by requiring the library's classes (constructor functions) and calling promisifyAll on the &lt;code&gt;.prototype&lt;/code&gt;. This only needs to be done once in the entire application's lifetime and after that you may use the library's methods exactly as they are documented, except by appending the &lt;code&gt;&quot;Async&quot;&lt;/code&gt;-suffix to method calls and using the promise interface instead of the callback interface.</source>
          <target state="translated">&lt;code&gt;fs&lt;/code&gt; はシングルトンインスタンスであるため、上記は例外的なケースであることに注意してください。ほとんどのライブラリは、ライブラリのクラス（コンストラクター関数）を要求し、 &lt;code&gt;.prototype&lt;/code&gt; でpromisifyAllを呼び出すことで約束できます。これは、アプリケーションの存続期間全体で一度だけ実行する必要があります。その後、ライブラリのメソッドをドキュメントに記載されているとおりに使用できます。ただし、メソッド呼び出しに &lt;code&gt;&quot;Async&quot;&lt;/code&gt; サフィックスを追加し、コールバックインターフェースではなくpromiseインターフェースを使用します。</target>
        </trans-unit>
        <trans-unit id="684fbd25281e8e786735f4d9605ff396ce6c04e1" translate="yes" xml:space="preserve">
          <source>Note that the original methods on the object are not overwritten but new methods are created with the &lt;code&gt;Async&lt;/code&gt;-suffix. For example, if you &lt;code&gt;promisifyAll&lt;/code&gt; the node.js &lt;code&gt;fs&lt;/code&gt; object use &lt;code&gt;fs.statAsync&lt;/code&gt; to call the promisified &lt;code&gt;stat&lt;/code&gt; method.</source>
          <target state="translated">オブジェクトの元のメソッドは上書きされませんが、新しいメソッドは &lt;code&gt;Async&lt;/code&gt; -suffixで作成されることに注意してください。たとえば、 &lt;code&gt;promisifyAll&lt;/code&gt; node.js &lt;code&gt;fs&lt;/code&gt; オブジェクトの場合、 &lt;code&gt;fs.statAsync&lt;/code&gt; を使用してpromisified &lt;code&gt;stat&lt;/code&gt; メソッドを呼び出します。</target>
        </trans-unit>
        <trans-unit id="8918cb785368659b0f7041103fcbbc46ea52e50b" translate="yes" xml:space="preserve">
          <source>Note that you can mix promises and disposers, so that you can acquire all the things you need in parallel instead of sequentially</source>
          <target state="translated">プロミスとディスポーザーを混ぜることができるので、必要なものを順番に取得するのではなく、並行して取得することができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="2203e249f5db0b7bf8e8cc90b06047ef5edc44d9" translate="yes" xml:space="preserve">
          <source>Note the new method is suffixed with &lt;code&gt;Async&lt;/code&gt;, as in &lt;code&gt;fs.readFileAsync&lt;/code&gt;. It did not replace the &lt;code&gt;fs.readFile&lt;/code&gt; function. Single functions can also be promisified for example:</source>
          <target state="translated">新しいメソッドの末尾には、 &lt;code&gt;fs.readFileAsync&lt;/code&gt; のように &lt;code&gt;Async&lt;/code&gt; が付いていることに注意してください。 &lt;code&gt;fs.readFile&lt;/code&gt; 関数は置き換えられませんでした。たとえば、単一の機能を約束することもできます。</target>
        </trans-unit>
        <trans-unit id="c1642a8259cf0bac4672e4af1533d8b457f9d5a0" translate="yes" xml:space="preserve">
          <source>Notice that use of &lt;code&gt;return this;&lt;/code&gt; in most of the functions? That pattern will allow method chaining as you'll see shortly.</source>
          <target state="translated">&lt;code&gt;return this;&lt;/code&gt; を使用すると、これが返されることに注意してください。ほとんどの機能で？このパターンは、後で説明するように、メソッドチェーンを許可します。</target>
        </trans-unit>
        <trans-unit id="28b7a468a3970ae2784b6d1486ec7ed0a21533b5" translate="yes" xml:space="preserve">
          <source>Now if someone uses this function, they will catch all errors in their Promise &lt;code&gt;.catch&lt;/code&gt; handlers instead of having to handle both synchronous and asynchronous exception flows.</source>
          <target state="translated">誰かがこの関数を使用すると、同期および非同期の例外フローの両方を処理する必要が &lt;code&gt;.catch&lt;/code&gt; 、Promise .catchハンドラーですべてのエラーをキャッチします。</target>
        </trans-unit>
        <trans-unit id="ae7be4be424720d6a240c42d8e70d90f0de37f8e" translate="yes" xml:space="preserve">
          <source>Now the animation is hidden but, unless it throws an exception, the function has no effect on the fulfilled or rejected value of the returned promise. This is similar to how the synchronous &lt;code&gt;finally&lt;/code&gt; keyword behaves.</source>
          <target state="translated">これでアニメーションは非表示になりますが、例外がスローされない限り、関数は返されたプロミスの実行または拒否された値に影響を与えません。これは、同期の &lt;code&gt;finally&lt;/code&gt; キーワードの動作に似ています。</target>
        </trans-unit>
        <trans-unit id="fdea957426d725edc153e2fdbdd6516cd7a9e40a" translate="yes" xml:space="preserve">
          <source>Now to the fun part. For this tutorial we will &lt;em&gt;fake&lt;/em&gt; a lengthy file upload by using &lt;code&gt;setTimeout&lt;/code&gt;. The intent is to provide a promise and to allow a progress to be periodically ticked away. We will expect a function to be passed which is called whenever the progress needs updating. And it returns a promise.</source>
          <target state="translated">楽しい部分です。このチュートリアルでは、 &lt;code&gt;setTimeout&lt;/code&gt; を使用して、長いファイルのアップロードを&lt;em&gt;偽装&lt;/em&gt;します。その目的は、約束を提供し、進行状況を定期的にチェックできるようにすることです。進行状況の更新が必要なときに呼び出される関数が渡されることを期待します。そして、それは約束を返します。</target>
        </trans-unit>
        <trans-unit id="f511b5b4eefa1fbd39717d9bca91d08c89eb55c8" translate="yes" xml:space="preserve">
          <source>Now we can add a &lt;code&gt;cancel()&lt;/code&gt; reject with this in our event listener:</source>
          <target state="translated">これで、イベントリスナーでこれを使用して &lt;code&gt;cancel()&lt;/code&gt; 拒否を追加できます。</target>
        </trans-unit>
        <trans-unit id="dd58dca3cb5c00590780331e30aa954b4d6ecb97" translate="yes" xml:space="preserve">
          <source>Now when the user presses the &lt;strong&gt;Set Name&lt;/strong&gt; button the clock continues to update while the dialog is visible.</source>
          <target state="translated">ユーザーが[ &lt;strong&gt;名前&lt;/strong&gt;の&lt;strong&gt;設定]&lt;/strong&gt;ボタンを押すと、ダイアログが表示されている間、時計は更新を続けます。</target>
        </trans-unit>
        <trans-unit id="c1c4edbd07c221b59e680f6880827ab56a3c246a" translate="yes" xml:space="preserve">
          <source>Now, because there is no catch-all handler, if you typed &lt;code&gt;console.lag&lt;/code&gt; (causes an error you don't expect), you will see:</source>
          <target state="translated">さて、キャッチオールハンドラーがないため、 &lt;code&gt;console.lag&lt;/code&gt; と入力すると（予期しないエラーが発生します）、次のように表示されます。</target>
        </trans-unit>
        <trans-unit id="9cf4af30df052d80876381f9ec0e05811ecd3d08" translate="yes" xml:space="preserve">
          <source>Objective-C</source>
          <target state="translated">Objective-C</target>
        </trans-unit>
        <trans-unit id="d1d56bab874d88dafd718a2b7e212040a9f0e45f" translate="yes" xml:space="preserve">
          <source>Of course you could use hacks like monkey patching or domains but these break down when something can't be monkey patched or new apis are introduced.</source>
          <target state="translated">もちろん、モンキーパッチやドメインのようなハックを使うこともできますが、モンキーパッチができないものや新しいapisが導入されたときには、これらのハックは壊れてしまいます。</target>
        </trans-unit>
        <trans-unit id="f9466283542f875b75d8d6a69434fd428fb07f65" translate="yes" xml:space="preserve">
          <source>Often browser APIs are nonstandard and automatic promisification will fail for them. If you're running into an API that you can't promisify with &lt;a href=&quot;api/promisify&quot;&gt;&lt;code&gt;promisify&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;api/promisifyall&quot;&gt;&lt;code&gt;promisifyAll&lt;/code&gt;&lt;/a&gt; - please consult the &lt;a href=&quot;#working-with-any-other-apis&quot;&gt;working with other APIs section&lt;/a&gt;</source>
          <target state="translated">多くの場合、ブラウザAPIは非標準であり、それらの自動Promisificationは失敗します。promisifyと&lt;a href=&quot;api/promisify&quot;&gt; &lt;code&gt;promisify&lt;/code&gt; All&lt;/a&gt;で&lt;a href=&quot;api/promisifyall&quot;&gt; &lt;code&gt;promisifyAll&lt;/code&gt; &lt;/a&gt;できないAPIを実行している場合- &lt;a href=&quot;#working-with-any-other-apis&quot;&gt;他のAPIの操作セクション&lt;/a&gt;を参照してください</target>
        </trans-unit>
        <trans-unit id="09c49c4361b267a50eb7359cfbbb3c119709f70d" translate="yes" xml:space="preserve">
          <source>Often it is known in certain code paths that a promise is guaranteed to be fulfilled at that point - it would then be extremely inconvenient to use &lt;a href=&quot;api/then&quot;&gt;&lt;code&gt;.then&lt;/code&gt;&lt;/a&gt; to get at the promise's value as the callback is always called asynchronously.</source>
          <target state="translated">多くの場合、特定のコードパスでは、その時点でプロミスが満たされることが保証されています。コールバックは常に非同期で呼び出されるため、&lt;a href=&quot;api/then&quot;&gt; &lt;code&gt;.then&lt;/code&gt; &lt;/a&gt;を使用してプロミスの値を取得することは非常に不便です。</target>
        </trans-unit>
        <trans-unit id="ba70c55cb182e14f7aec5abbfd219d10161351d3" translate="yes" xml:space="preserve">
          <source>Often it is known in certain code paths that a promise is guaranteed to be fulfilled at that point - it would then be extremely inconvenient to use &lt;a href=&quot;then&quot;&gt;&lt;code&gt;.then&lt;/code&gt;&lt;/a&gt; to get at the promise's value as the callback is always called asynchronously.</source>
          <target state="translated">多くの場合、特定のコードパスでは、その時点でプロミスが満たされることが保証されています。コールバックは常に非同期で呼び出されるため、&lt;a href=&quot;then&quot;&gt; &lt;code&gt;.then&lt;/code&gt; &lt;/a&gt;を使用してプロミスの値を取得することは非常に不便です。</target>
        </trans-unit>
        <trans-unit id="fb455bed4997b8d29dbd05a23ac828990139aad3" translate="yes" xml:space="preserve">
          <source>Old Promise Cancellation</source>
          <target state="translated">旧プロミスの解約について</target>
        </trans-unit>
        <trans-unit id="c2882dbf534ae9b61f7574e530dc35a635e26a00" translate="yes" xml:space="preserve">
          <source>On client side, long stack traces currently only work in recent Firefoxes, Chrome and Internet Explorer 10+.</source>
          <target state="translated">クライアント側では、長いスタックトレースは現在のところ、最近のFirefox、Chrome、Internet Explorer 10+でしか動作しません。</target>
        </trans-unit>
        <trans-unit id="4e5a14a36dfaaeaed4f8ef85cfc8efef0579501d" translate="yes" xml:space="preserve">
          <source>One could solve this by either reading the file first or connecting first, and only proceeding if the first step succeeds. However, this would lose a lot of the benefits of using asynchronity and we might almost as well go back to using simple synchronous code.</source>
          <target state="translated">これを解決するには、最初にファイルを読み込むか、最初に接続し、最初のステップが成功した場合にのみ処理を進めるという方法があります。しかし、これでは非同期性を使うメリットの多くが失われてしまい、単純な同期コードの使用に戻ってしまうかもしれません。</target>
        </trans-unit>
        <trans-unit id="6d2c6e796751446bf03d009641c4f94308285962" translate="yes" xml:space="preserve">
          <source>One possible cause is using &lt;code&gt;.indexOf&lt;/code&gt; which returns &lt;code&gt;-1&lt;/code&gt; when it doesn't find the value being searched for.</source>
          <target state="translated">考えられる原因の1つは、検索する値が見つからない場合に &lt;code&gt;-1&lt;/code&gt; を返す &lt;code&gt;.indexOf&lt;/code&gt; を使用していることです。</target>
        </trans-unit>
        <trans-unit id="3bebf09d62dbf5ff3d0ee7b594d24983d9fecce2" translate="yes" xml:space="preserve">
          <source>OperationalError</source>
          <target state="translated">OperationalError</target>
        </trans-unit>
        <trans-unit id="5b01979a9cdca6e73817895c6a9c23e60230c14d" translate="yes" xml:space="preserve">
          <source>OperationalError()</source>
          <target state="translated">OperationalError()</target>
        </trans-unit>
        <trans-unit id="104370c5891b8b4ba98b88fdedf6b3dd37566a91" translate="yes" xml:space="preserve">
          <source>Option: filter</source>
          <target state="translated">オプション:フィルタ</target>
        </trans-unit>
        <trans-unit id="fd4d82f7dc12888a6113e02d99a1cd1ae6480faa" translate="yes" xml:space="preserve">
          <source>Option: multiArgs</source>
          <target state="translated">オプション:multiArgs</target>
        </trans-unit>
        <trans-unit id="c7fb7b92da5e81c452b72cf73b9e7e606a4be8c6" translate="yes" xml:space="preserve">
          <source>Option: promisifier</source>
          <target state="translated">オプション:プロミシファイヤー</target>
        </trans-unit>
        <trans-unit id="739bd13df9b75cbacc926456c2659db41a7a2e16" translate="yes" xml:space="preserve">
          <source>Option: spread</source>
          <target state="translated">オプション:スプレッド</target>
        </trans-unit>
        <trans-unit id="c86f01917e960f8cf0838c6de23ce3408a649b20" translate="yes" xml:space="preserve">
          <source>Option: suffix</source>
          <target state="translated">オプション:接尾辞</target>
        </trans-unit>
        <trans-unit id="ad34d2a8ce003a253f94ae6e4eb935a9468f0f43" translate="yes" xml:space="preserve">
          <source>Optionally, you can define a custom filter through the options object:</source>
          <target state="translated">オプションで、オプションオブジェクトを使ってカスタムフィルタを定義することができます。</target>
        </trans-unit>
        <trans-unit id="8110acd1b3d0f8ca4e9e279edf4604f42dc6b48b" translate="yes" xml:space="preserve">
          <source>Optionally, you can define a custom promisifier, so you could promisifyAll e.g. the chrome APIs used in Chrome extensions.</source>
          <target state="translated">オプションで、カスタムのプロミスファイヤーを定義することができるので、例えばChrome拡張機能で使用されるchrome APIなど、すべてをプロミス化することができます。</target>
        </trans-unit>
        <trans-unit id="889a0e5ec1b3411c0cd35c6e73319943162df789" translate="yes" xml:space="preserve">
          <source>Optionally, you can define a custom suffix through the options object:</source>
          <target state="translated">オプションで、オプションオブジェクトを使ってカスタムサフィックスを定義することができます。</target>
        </trans-unit>
        <trans-unit id="d850b7adaa397dfa33c1141f5bb572b4b4cee8d2" translate="yes" xml:space="preserve">
          <source>Or to use &lt;a href=&quot;api/promise.coroutine.addyieldhandler&quot;&gt;&lt;code&gt;Promise.coroutine.addYieldHandler`&lt;/code&gt;&lt;/a&gt; to teach &lt;a href=&quot;api/promise.coroutine&quot;&gt;&lt;code&gt;Promise.coroutine&lt;/code&gt;&lt;/a&gt; to accept these sort of values.</source>
          <target state="translated">または、&lt;a href=&quot;api/promise.coroutine.addyieldhandler&quot;&gt; &lt;code&gt;Promise.coroutine.addYieldHandler`&lt;/code&gt; &lt;/a&gt;を使用して、&lt;a href=&quot;api/promise.coroutine&quot;&gt; &lt;code&gt;Promise.coroutine&lt;/code&gt; &lt;/a&gt;にこれらの種類の値を受け入れるように指示します。</target>
        </trans-unit>
        <trans-unit id="24ea190190a1068b342fd38d88b87afd5b7878ff" translate="yes" xml:space="preserve">
          <source>Or you could take advantage of the fact that if we reach password validation, then the user promise must be fulfilled:</source>
          <target state="translated">あるいは、パスワードの検証に到達した場合、ユーザーの約束が果たされなければならないという事実を利用することもできます。</target>
        </trans-unit>
        <trans-unit id="0b17d6ff961144643224165079cbd11a9c6bc25a" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;PromptDialog&lt;/code&gt; class is responsible for inheriting from &lt;code&gt;Dialog&lt;/code&gt; and setting up the required DOM scaffolding and eventually call &lt;code&gt;this._okCallback&lt;/code&gt; or &lt;code&gt;this._cancelCallback&lt;/code&gt; as appropriate.</source>
          <target state="translated">私たちの &lt;code&gt;PromptDialog&lt;/code&gt; のクラスから継承する責任がある &lt;code&gt;Dialog&lt;/code&gt; を呼び出し、最終的に、必要なDOMの足場を設定し、 &lt;code&gt;this._okCallback&lt;/code&gt; または &lt;code&gt;this._cancelCallback&lt;/code&gt; を適宜。</target>
        </trans-unit>
        <trans-unit id="57cb5629649d7407a80d8544726571004c96c657" translate="yes" xml:space="preserve">
          <source>PascalCase the suffix</source>
          <target state="translated">パスカルケース接尾辞</target>
        </trans-unit>
        <trans-unit id="feee47953c269413e18b8e3f8b2d28f42be54e4a" translate="yes" xml:space="preserve">
          <source>Pass a handler that will be called regardless of this promise's fate. Returns a new promise chained from this promise. There are special semantics for &lt;a href=&quot;finally&quot;&gt;&lt;code&gt;.finally&lt;/code&gt;&lt;/a&gt; in that the final value cannot be modified from the handler.</source>
          <target state="translated">この約束の運命に関係なく呼び出されるハンドラを渡します。このプロミスからチェーンされた新しいプロミスを返します。最終値をハンドラーから変更できないという点で、&lt;a href=&quot;finally&quot;&gt; &lt;code&gt;.finally&lt;/code&gt; &lt;/a&gt;には特別なセマンティクスがあります。</target>
        </trans-unit>
        <trans-unit id="9b4b02b67bed0ffe4b0b1b17a183e58f6d178ecc" translate="yes" xml:space="preserve">
          <source>Pass it a constructor that inherits from &lt;code&gt;Error&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Error&lt;/code&gt; から継承するコンストラクタを渡します：</target>
        </trans-unit>
        <trans-unit id="ef62afb0d13c7501004b9f7402ac0fe34f1df36d" translate="yes" xml:space="preserve">
          <source>Passing no value or a non-function will have the effect of removing any kind of handling for possibly unhandled rejections.</source>
          <target state="translated">値や非関数を渡すと、処理されていない可能性のあるリジェクトに対して、あらゆる種類の処理を削除する効果があります。</target>
        </trans-unit>
        <trans-unit id="14a1550a1e49d7c4df7b61809151dec155b9464f" translate="yes" xml:space="preserve">
          <source>Performance improvements when long stack traces are enabled</source>
          <target state="translated">長いスタックトレースを有効にした場合のパフォーマンスの向上</target>
        </trans-unit>
        <trans-unit id="f6d83e264c56100a2c68d859c185e245cdf12d6c" translate="yes" xml:space="preserve">
          <source>Perhaps the greatest thing about promises is that it unifies all error handling into one mechanism where errors propagate automatically and have to be explicitly ignored.</source>
          <target state="translated">おそらくプロミスの最大の特徴は、すべてのエラー処理を、エラーが自動的に伝播し、明示的に無視されなければならないメカニズムに統一していることでしょう。</target>
        </trans-unit>
        <trans-unit id="13bc9fc907ba93237d886bb7661f405dca851032" translate="yes" xml:space="preserve">
          <source>Playing with the first example with and without limits, and seeing how it affects the duration when reading 20 files:</source>
          <target state="translated">最初の例を制限のあるなしで遊んで、20個のファイルを読んだときの持続時間にどのように影響するかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="5e982889494e481131cdc4a0b26924bfa22d7d53" translate="yes" xml:space="preserve">
          <source>Please consider reading about &lt;a href=&quot;api/new-promise&quot;&gt;&lt;code&gt;new Promise&lt;/code&gt;&lt;/a&gt; and also consider checking out automatic &lt;a href=&quot;api/promisification&quot;&gt;&lt;code&gt;promisification&lt;/code&gt;&lt;/a&gt; as well as &lt;a href=&quot;api/promise.method&quot;&gt;&lt;code&gt;Promise.method&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;api/new-promise&quot;&gt; &lt;code&gt;new Promise&lt;/code&gt; &lt;/a&gt;について読むことを検討してください。また、&lt;a href=&quot;api/promise.method&quot;&gt; &lt;code&gt;Promise.method&lt;/code&gt; &lt;/a&gt;だけでなく、自動&lt;a href=&quot;api/promisification&quot;&gt; &lt;code&gt;promisification&lt;/code&gt; &lt;/a&gt;も確認してください。</target>
        </trans-unit>
        <trans-unit id="3b51c4c13d41d7852eb369e20c236af48cef84cc" translate="yes" xml:space="preserve">
          <source>Please consider reading more about &lt;a href=&quot;api/synchronous-inspection&quot;&gt;&lt;code&gt;synchronous inspection&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;api/synchronous-inspection&quot;&gt; &lt;code&gt;synchronous inspection&lt;/code&gt; &lt;/a&gt;についてもっと読むことを検討してください</target>
        </trans-unit>
        <trans-unit id="1e14f1308fe5c8dea2b2ef541f7aee826d27d5e0" translate="yes" xml:space="preserve">
          <source>Please consider reading the API docs for &lt;a href=&quot;api/some&quot;&gt;&lt;code&gt;.some&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;api/some&quot;&gt; &lt;code&gt;.some&lt;/code&gt; の&lt;/a&gt; APIドキュメントを読むことを検討してください</target>
        </trans-unit>
        <trans-unit id="c5ef6b96fc3e88fc35fff339fde30327dde1a698" translate="yes" xml:space="preserve">
          <source>Please refer to the relevant section in the documentation about &lt;a href=&quot;api/generators&quot;&gt;&lt;code&gt;Generators&lt;/code&gt;&lt;/a&gt; in order to get usage instructions:</source>
          <target state="translated">使用方法については、&lt;a href=&quot;api/generators&quot;&gt; &lt;code&gt;Generators&lt;/code&gt; &lt;/a&gt;に関するドキュメントの関連セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="5ad1bb14fb0bdc68c8977349fd048e917d0e042c" translate="yes" xml:space="preserve">
          <source>Please see the API docs of &lt;a href=&quot;api/catch&quot;&gt;&lt;code&gt;.catch()&lt;/code&gt;&lt;/a&gt; on how to use predicate catches.</source>
          <target state="translated">述語キャッチの使用方法については、&lt;a href=&quot;api/catch&quot;&gt; &lt;code&gt;.catch()&lt;/code&gt; の&lt;/a&gt; APIドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="7c7ed98d6ff8cb1bb3beee177d5536fda218b9d6" translate="yes" xml:space="preserve">
          <source>Possibly unhandled rejection handler will always get a stack trace, even if the rejection or thrown error was not an error</source>
          <target state="translated">ハンドリングされていない可能性のある拒否ハンドラは、たとえ拒否やスローされたエラーがエラーではなかったとしても、常にスタックトレースを取得します。</target>
        </trans-unit>
        <trans-unit id="24fd6c2d1150de6a47543209150ff4c2a2d3104f" translate="yes" xml:space="preserve">
          <source>PostgreSQL</source>
          <target state="translated">PostgreSQL</target>
        </trans-unit>
        <trans-unit id="642cccd7308199d6f0935637f8e1d6bddc7a7f5d" translate="yes" xml:space="preserve">
          <source>Predicate functions that only check properties have a handy shorthand. In place of a predicate function, you can pass an object, and its properties will be checked against the error object for a match:</source>
          <target state="translated">プロパティのみをチェックする述語関数には、便利なショートカットがあります。述語関数の代わりにオブジェクトを渡すと、そのプロパティがエラーオブジェクトと一致するかどうかがチェックされます。</target>
        </trans-unit>
        <trans-unit id="ef29f5e7937f710796c69d5f2e8ef62b93259503" translate="yes" xml:space="preserve">
          <source>Predicates should allow for very fine grained control over caught errors: pattern matching, error-type sets with set operations and many other techniques can be implemented on top of them.</source>
          <target state="translated">述語は、捕捉されたエラーを非常に細かく制御できるようにしなければなりません:パターンマッチング、セット操作によるエラー型セット、その他多くの技術がその上に実装できます。</target>
        </trans-unit>
        <trans-unit id="966e683ff73ac6a6ff53e83d6497f2f1ad6da22d" translate="yes" xml:space="preserve">
          <source>Preserve bound-with-promise promises across the entire chain (&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/702&quot;&gt;&lt;code&gt;#702&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">チェーン全体で約束付きの約束を維持する（&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/702&quot;&gt; &lt;code&gt;#702&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b1d7cb674f49e0b746c342035d00a2302db4c737" translate="yes" xml:space="preserve">
          <source>Progress bar</source>
          <target state="translated">プログレスバー</target>
        </trans-unit>
        <trans-unit id="51674123623b6ab6e8ea7ca7250debfd7286bf63" translate="yes" xml:space="preserve">
          <source>Progress the underlying promise with &lt;code&gt;value&lt;/code&gt; as the progression value.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; をプログレッション値として、基本的な約束を進めます。</target>
        </trans-unit>
        <trans-unit id="685e262241d88a216ab9353d6e8f0939b5803641" translate="yes" xml:space="preserve">
          <source>Progression</source>
          <target state="translated">Progression</target>
        </trans-unit>
        <trans-unit id="25eee37f31e0eba9807d8e531ecf239e4d0cd542" translate="yes" xml:space="preserve">
          <source>Progression has been removed as there are composability and chaining issues with APIs that use promise progression handlers. Implementing the common use case of progress bars can be accomplished using a pattern similar to &lt;a href=&quot;http://blogs.msdn.com/b/dotnet/archive/2012/06/06/async-in-4-5-enabling-progress-and-cancellation-in-async-apis.aspx&quot;&gt;IProgress&lt;/a&gt; in C#.</source>
          <target state="translated">promiseの進行ハンドラーを使用するAPIには構成可能性と連鎖の問題があるため、進行は削除されました。進行状況バーの一般的な使用例の実装は、C＃の&lt;a href=&quot;http://blogs.msdn.com/b/dotnet/archive/2012/06/06/async-in-4-5-enabling-progress-and-cancellation-in-async-apis.aspx&quot;&gt;IProgress&lt;/a&gt;と同様のパターンを使用して実現できます。</target>
        </trans-unit>
        <trans-unit id="3248b463906e068e9fcc220b46e1a5d372a78fb1" translate="yes" xml:space="preserve">
          <source>Progression migration</source>
          <target state="translated">進行中の移動</target>
        </trans-unit>
        <trans-unit id="be45959fa7407eeadb36fe64732e21bc44a21868" translate="yes" xml:space="preserve">
          <source>Promise config returns reference to Bluebird library</source>
          <target state="translated">Promise config は Bluebird ライブラリへの参照を返します。</target>
        </trans-unit>
        <trans-unit id="fb6113ea309f0d5b9bec49fc1796cd040f492643" translate="yes" xml:space="preserve">
          <source>Promise exception handling mirrors native exception handling in JavaScript. A synchronous function &lt;code&gt;throw&lt;/code&gt;ing is similar to a promise rejecting. Here is an example to illustrate it:</source>
          <target state="translated">Promise例外処理は、JavaScriptのネイティブ例外処理を反映しています。同期関数の &lt;code&gt;throw&lt;/code&gt; は、プロミスの拒否に似ています。これを説明する例を次に示します。</target>
        </trans-unit>
        <trans-unit id="8782a387409c7a9a87576a85d07c1e64505c1544" translate="yes" xml:space="preserve">
          <source>Promise monitoring</source>
          <target state="translated">プロミスのモニタリング</target>
        </trans-unit>
        <trans-unit id="4dbc67ef437634d86ab184513509ef1b7aec9846" translate="yes" xml:space="preserve">
          <source>Promise nuggets</source>
          <target state="translated">プロミスナゲット</target>
        </trans-unit>
        <trans-unit id="cd4139a3b1a43d871cf4ddb3e7a6d5193448c48c" translate="yes" xml:space="preserve">
          <source>Promise progression has been completely removed.</source>
          <target state="translated">プロミスの進行は完全に削除されました。</target>
        </trans-unit>
        <trans-unit id="7726aabf1843e710a9f37fd6b562d6f56faa7e88" translate="yes" xml:space="preserve">
          <source>Promise resolution</source>
          <target state="translated">約束の解決</target>
        </trans-unit>
        <trans-unit id="65f81fcc4877a1e4dd84dd9b0c2863d1631025a9" translate="yes" xml:space="preserve">
          <source>Promise returning functions &lt;em&gt;should never throw&lt;/em&gt;, they should always successfully return a promise which is rejected in the case of an error. Throwing from a promise returning function will force you to use both a &lt;code&gt;} catch {&lt;/code&gt;&lt;em&gt;and&lt;/em&gt; a &lt;code&gt;.catch&lt;/code&gt;. People using promisified APIs do not expect promises to throw. If you're not sure how async APIs work in JS - please &lt;a href=&quot;http://stackoverflow.com/questions/14220321/how-to-return-the-response-from-an-asynchronous-call/16825593#16825593&quot;&gt;see this answer&lt;/a&gt; first.</source>
          <target state="translated">Promiseを返す関数&lt;em&gt;はスローしないで&lt;/em&gt;ください。エラーが発生した場合に拒否されるPromise を常に正常に返す必要があります。promise の &lt;code&gt;.catch&lt;/code&gt; &lt;em&gt;と&lt;/em&gt;、 &lt;code&gt;} catch {&lt;/code&gt; &lt;em&gt;と&lt;/em&gt;.catchの両方を使用する必要があります。約束されたAPIを使用している人々は、約束がスローされることを期待していません。JSで非同期APIがどのように機能するかわからない場合&lt;a href=&quot;http://stackoverflow.com/questions/14220321/how-to-return-the-response-from-an-asynchronous-call/16825593#16825593&quot;&gt;は、&lt;/a&gt;まずこの回答を参照してください。</target>
        </trans-unit>
        <trans-unit id="32c88e7c01a53d5b288b9de6a6aab20cb547871d" translate="yes" xml:space="preserve">
          <source>Promise.all</source>
          <target state="translated">Promise.all</target>
        </trans-unit>
        <trans-unit id="a6755a6ad2728b869d475dc11ace6f3bf5ea4871" translate="yes" xml:space="preserve">
          <source>Promise.all()</source>
          <target state="translated">Promise.all()</target>
        </trans-unit>
        <trans-unit id="8a9f46eacb22a3bbe6409bdb49b4254651eff678" translate="yes" xml:space="preserve">
          <source>Promise.any</source>
          <target state="translated">Promise.any</target>
        </trans-unit>
        <trans-unit id="59a3e9eecb28443ad28e7c96175567acc96c62f3" translate="yes" xml:space="preserve">
          <source>Promise.any()</source>
          <target state="translated">Promise.any()</target>
        </trans-unit>
        <trans-unit id="380ddbb670a463da41bcb2f09102155dde8e708e" translate="yes" xml:space="preserve">
          <source>Promise.bind</source>
          <target state="translated">Promise.bind</target>
        </trans-unit>
        <trans-unit id="c504dbf7b03cd885ada0adc0180bde1c542f6ff6" translate="yes" xml:space="preserve">
          <source>Promise.bind()</source>
          <target state="translated">Promise.bind()</target>
        </trans-unit>
        <trans-unit id="94cffff23a1082b260d53b460f0199319830c332" translate="yes" xml:space="preserve">
          <source>Promise.config</source>
          <target state="translated">Promise.config</target>
        </trans-unit>
        <trans-unit id="14cca1b3fd91fce3c7d78898b9b8ab87641cd45f" translate="yes" xml:space="preserve">
          <source>Promise.config()</source>
          <target state="translated">Promise.config()</target>
        </trans-unit>
        <trans-unit id="0281c083d21b56d693df7c85bdc8760d5a153cb3" translate="yes" xml:space="preserve">
          <source>Promise.coroutine</source>
          <target state="translated">Promise.coroutine</target>
        </trans-unit>
        <trans-unit id="417c8a52e78b52649cc8c0d1a4a5c72e470fba46" translate="yes" xml:space="preserve">
          <source>Promise.coroutine()</source>
          <target state="translated">Promise.coroutine()</target>
        </trans-unit>
        <trans-unit id="1c7ffab7487989ed4fab5bf27ffc68d6a9e83f84" translate="yes" xml:space="preserve">
          <source>Promise.coroutine.addYieldHandler</source>
          <target state="translated">Promise.coroutine.addYieldHandler</target>
        </trans-unit>
        <trans-unit id="b32e1c4e626c99ffd6f0e20eaa5f3f6e5768bfd5" translate="yes" xml:space="preserve">
          <source>Promise.coroutine.addYieldHandler()</source>
          <target state="translated">Promise.coroutine.addYieldHandler()</target>
        </trans-unit>
        <trans-unit id="0eaf3c7722c589dfef45cece747a91a4f63eb1c4" translate="yes" xml:space="preserve">
          <source>Promise.delay</source>
          <target state="translated">Promise.delay</target>
        </trans-unit>
        <trans-unit id="b0fcfeaf123206f651b32c45d020a06c0161b597" translate="yes" xml:space="preserve">
          <source>Promise.delay()</source>
          <target state="translated">Promise.delay()</target>
        </trans-unit>
        <trans-unit id="58c05c22c80b95286ff97a890b8a711ca2bc4455" translate="yes" xml:space="preserve">
          <source>Promise.each</source>
          <target state="translated">Promise.each</target>
        </trans-unit>
        <trans-unit id="a620ec9f632f36f8a08e631069c08191868f6916" translate="yes" xml:space="preserve">
          <source>Promise.each()</source>
          <target state="translated">Promise.each()</target>
        </trans-unit>
        <trans-unit id="36ed6ee5c85807e4301bf69d782f38ceb4470326" translate="yes" xml:space="preserve">
          <source>Promise.filter</source>
          <target state="translated">Promise.filter</target>
        </trans-unit>
        <trans-unit id="86054f183176a3f69e770d2c34d2bdeae915a41e" translate="yes" xml:space="preserve">
          <source>Promise.filter()</source>
          <target state="translated">Promise.filter()</target>
        </trans-unit>
        <trans-unit id="98d41166fbaafb718942a7d54eb7a52ea584c71b" translate="yes" xml:space="preserve">
          <source>Promise.fromCallback</source>
          <target state="translated">Promise.fromCallback</target>
        </trans-unit>
        <trans-unit id="3f0b67925c3695da1eb2886d38a30665c003a3b1" translate="yes" xml:space="preserve">
          <source>Promise.fromCallback()</source>
          <target state="translated">Promise.fromCallback()</target>
        </trans-unit>
        <trans-unit id="fd3f3e356627367a0a1deb529a31724afae6adf2" translate="yes" xml:space="preserve">
          <source>Promise.getNewLibraryCopy</source>
          <target state="translated">Promise.getNewLibraryCopy</target>
        </trans-unit>
        <trans-unit id="89fb5dda745c6bafe6968a6f413760af47aceae1" translate="yes" xml:space="preserve">
          <source>Promise.getNewLibraryCopy()</source>
          <target state="translated">Promise.getNewLibraryCopy()</target>
        </trans-unit>
        <trans-unit id="40fdb4632aedb0a1797f0c8a54579a1fde171242" translate="yes" xml:space="preserve">
          <source>Promise.join</source>
          <target state="translated">Promise.join</target>
        </trans-unit>
        <trans-unit id="23d8f43c5ac526250cf76c302ad4119a7b1ab47b" translate="yes" xml:space="preserve">
          <source>Promise.join()</source>
          <target state="translated">Promise.join()</target>
        </trans-unit>
        <trans-unit id="7978c060e1559749beb237c1e2cd848a0c8c4d0d" translate="yes" xml:space="preserve">
          <source>Promise.map</source>
          <target state="translated">Promise.map</target>
        </trans-unit>
        <trans-unit id="ca13a4d72f15f0ca07d5d50979466ec8d5754e56" translate="yes" xml:space="preserve">
          <source>Promise.map()</source>
          <target state="translated">Promise.map()</target>
        </trans-unit>
        <trans-unit id="4228fbfb6f0c4ca7c03f7f3fe02a32213a675bb6" translate="yes" xml:space="preserve">
          <source>Promise.mapSeries</source>
          <target state="translated">Promise.mapSeries</target>
        </trans-unit>
        <trans-unit id="e726d78ebf8fa9e8d4dd4170765a788187160409" translate="yes" xml:space="preserve">
          <source>Promise.mapSeries()</source>
          <target state="translated">Promise.mapSeries()</target>
        </trans-unit>
        <trans-unit id="02c686952be30df3ceda356456842c51ca54d6b6" translate="yes" xml:space="preserve">
          <source>Promise.method</source>
          <target state="translated">Promise.method</target>
        </trans-unit>
        <trans-unit id="745df198c177406843ab6f0aef1a0ee5dfc83def" translate="yes" xml:space="preserve">
          <source>Promise.method()</source>
          <target state="translated">Promise.method()</target>
        </trans-unit>
        <trans-unit id="84f80dd435e5e59f09d00da45ff238df86a37a40" translate="yes" xml:space="preserve">
          <source>Promise.noConflict</source>
          <target state="translated">Promise.noConflict</target>
        </trans-unit>
        <trans-unit id="7531a2c2c6b7c98ad21e08d5e3ae1c19a0b22683" translate="yes" xml:space="preserve">
          <source>Promise.noConflict()</source>
          <target state="translated">Promise.noConflict()</target>
        </trans-unit>
        <trans-unit id="71c980a14f65b0a2704a085acb674ac28a814685" translate="yes" xml:space="preserve">
          <source>Promise.onPossiblyUnhandledRejection</source>
          <target state="translated">Promise.onPossiblyUnhandledRejection</target>
        </trans-unit>
        <trans-unit id="c371d88740f13aaaca5694582d4b3f1c2be33ab4" translate="yes" xml:space="preserve">
          <source>Promise.onPossiblyUnhandledRejection()</source>
          <target state="translated">Promise.onPossiblyUnhandledRejection()</target>
        </trans-unit>
        <trans-unit id="829674402143cb4c85191f62c464c46f218abca2" translate="yes" xml:space="preserve">
          <source>Promise.onUnhandledRejectionHandled</source>
          <target state="translated">Promise.onUnhandledRejectionHandled</target>
        </trans-unit>
        <trans-unit id="9c2cbfa68db14a1011a8bf225d1d930825635838" translate="yes" xml:space="preserve">
          <source>Promise.onUnhandledRejectionHandled()</source>
          <target state="translated">Promise.onUnhandledRejectionHandled()</target>
        </trans-unit>
        <trans-unit id="1bd4c78395725232fde1b79374d6efc9908e559c" translate="yes" xml:space="preserve">
          <source>Promise.promisify</source>
          <target state="translated">Promise.promisify</target>
        </trans-unit>
        <trans-unit id="1713f0d05877ab5fe29b2ac17f3c75196afacdff" translate="yes" xml:space="preserve">
          <source>Promise.promisify()</source>
          <target state="translated">Promise.promisify()</target>
        </trans-unit>
        <trans-unit id="97bebc26a4bce522904a06ed52ef00804ef373fc" translate="yes" xml:space="preserve">
          <source>Promise.promisifyAll</source>
          <target state="translated">Promise.promisifyAll</target>
        </trans-unit>
        <trans-unit id="582205a63795dfa2ded431e29909f2b0510003b9" translate="yes" xml:space="preserve">
          <source>Promise.promisifyAll()</source>
          <target state="translated">Promise.promisifyAll()</target>
        </trans-unit>
        <trans-unit id="27847ed541d9e1eeb76f5dbeb0044fcdbf775d18" translate="yes" xml:space="preserve">
          <source>Promise.props</source>
          <target state="translated">Promise.props</target>
        </trans-unit>
        <trans-unit id="4f38df349b880a0f534b640b3a8136437dece180" translate="yes" xml:space="preserve">
          <source>Promise.props now takes a &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/f41edac61b7c421608ff439bb5a09b7cffeadcf9/test/mocha/props.js#L197-L217&quot;&gt;thenable-for-collection&lt;/a&gt;</source>
          <target state="translated">Promise.propsは&lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/f41edac61b7c421608ff439bb5a09b7cffeadcf9/test/mocha/props.js#L197-L217&quot;&gt;収集可能なものを&lt;/a&gt;受け取ります</target>
        </trans-unit>
        <trans-unit id="9db0fa212e5a187e62cb941c0f3eb586f29ed38d" translate="yes" xml:space="preserve">
          <source>Promise.props()</source>
          <target state="translated">Promise.props()</target>
        </trans-unit>
        <trans-unit id="6196396df0252ad4dc6749ba58e4f523ddc5109d" translate="yes" xml:space="preserve">
          <source>Promise.race</source>
          <target state="translated">Promise.race</target>
        </trans-unit>
        <trans-unit id="c805ba00efdcb8c7baa42fe61c954261ddd4c775" translate="yes" xml:space="preserve">
          <source>Promise.race()</source>
          <target state="translated">Promise.race()</target>
        </trans-unit>
        <trans-unit id="09422a77b11ac9569156f52e83edb0002c26642c" translate="yes" xml:space="preserve">
          <source>Promise.reduce</source>
          <target state="translated">Promise.reduce</target>
        </trans-unit>
        <trans-unit id="3036bc3d125176ce64d7f9e3b21c3e0d47ea6b85" translate="yes" xml:space="preserve">
          <source>Promise.reduce()</source>
          <target state="translated">Promise.reduce()</target>
        </trans-unit>
        <trans-unit id="783910d23dd1b1558a9b16d71c0ed4b397115fd3" translate="yes" xml:space="preserve">
          <source>Promise.reject</source>
          <target state="translated">Promise.reject</target>
        </trans-unit>
        <trans-unit id="8a2f2af4e6e3d7ca0c77296866bcfff0749f0dd9" translate="yes" xml:space="preserve">
          <source>Promise.reject()</source>
          <target state="translated">Promise.reject()</target>
        </trans-unit>
        <trans-unit id="0a3c75bb1d9e15c9996579992a0721a69da28c55" translate="yes" xml:space="preserve">
          <source>Promise.resolve</source>
          <target state="translated">Promise.resolve</target>
        </trans-unit>
        <trans-unit id="3cf132f388e7330298717bcc33a49e9f948aa7e5" translate="yes" xml:space="preserve">
          <source>Promise.resolve and PromiseResolver.resolve follow thenables too.</source>
          <target state="translated">Promise.resolveとPromiseResolver.resolveもそれに続きます。</target>
        </trans-unit>
        <trans-unit id="47b038849d964f2910c38df87756eeab2c33c845" translate="yes" xml:space="preserve">
          <source>Promise.resolve()</source>
          <target state="translated">Promise.resolve()</target>
        </trans-unit>
        <trans-unit id="2bd5fccacac7e4b32307e5e90275cc00e52adab2" translate="yes" xml:space="preserve">
          <source>Promise.setScheduler</source>
          <target state="translated">Promise.setScheduler</target>
        </trans-unit>
        <trans-unit id="4f357c9ea9b4ced021695eb3da83abef0f53a5bc" translate="yes" xml:space="preserve">
          <source>Promise.setScheduler()</source>
          <target state="translated">Promise.setScheduler()</target>
        </trans-unit>
        <trans-unit id="b2b14953357fd6fd7061ee19d3a46165592f8187" translate="yes" xml:space="preserve">
          <source>Promise.some</source>
          <target state="translated">Promise.some</target>
        </trans-unit>
        <trans-unit id="a7f83b619aac204250fe4b4b48cffc16048afd2a" translate="yes" xml:space="preserve">
          <source>Promise.some()</source>
          <target state="translated">Promise.some()</target>
        </trans-unit>
        <trans-unit id="bcaec27b9cbb2228f24361eaa259b8fadc6e76b0" translate="yes" xml:space="preserve">
          <source>Promise.try</source>
          <target state="translated">Promise.try</target>
        </trans-unit>
        <trans-unit id="285c74e7f15b5592587b905c39313a8c4c3631cd" translate="yes" xml:space="preserve">
          <source>Promise.try()</source>
          <target state="translated">Promise.try()</target>
        </trans-unit>
        <trans-unit id="54ae20ee3d30d8a4d9a8c3f51ddc74ab08078bce" translate="yes" xml:space="preserve">
          <source>Promise.using</source>
          <target state="translated">Promise.using</target>
        </trans-unit>
        <trans-unit id="d12fa97fde3870925fdf7d6a0ac552e0c8c9b94a" translate="yes" xml:space="preserve">
          <source>Promise.using()</source>
          <target state="translated">Promise.using()</target>
        </trans-unit>
        <trans-unit id="1a5d11d2f1ddb5249c87ef7bd69381bb0b693272" translate="yes" xml:space="preserve">
          <source>PromiseInspection</source>
          <target state="translated">PromiseInspection</target>
        </trans-unit>
        <trans-unit id="868dfb6858e3ed48b9b873232bb97b0244d9d0bf" translate="yes" xml:space="preserve">
          <source>Promises are a concurrency primitive with a proven track record and language integration in most modern programming languages. They have been extensively studied since the 80s and will make your life much easier.</source>
          <target state="translated">Promises は、実績のある並行処理プリミティブであり、ほとんどの最新のプログラミング言語で言語統合されています。80年代から広く研究されており、あなたの生活をより簡単にしてくれます。</target>
        </trans-unit>
        <trans-unit id="4979e5d38a5edf382533cb2038c51eb19a4dee6f" translate="yes" xml:space="preserve">
          <source>Promises are now not cancellable by default. This is backwards incompatible change - see &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#cancellable---promise&quot;&gt;&lt;code&gt;.cancellable()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">デフォルトでは、プロミスはキャンセルできません。これは後方互換性のない変更です&lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#cancellable---promise&quot;&gt; &lt;code&gt;.cancellable()&lt;/code&gt; &lt;/a&gt;参照してください</target>
        </trans-unit>
        <trans-unit id="ed5dd788dfd2194a43ab6fd8c2d1b84eb1ecc96e" translate="yes" xml:space="preserve">
          <source>Promises can be rejected with falsy values (or no value at all, equal to rejecting with &lt;code&gt;undefined&lt;/code&gt;), however &lt;code&gt;.asCallback&lt;/code&gt; will call the callback with an &lt;code&gt;Error&lt;/code&gt; object if the promise's rejection reason is a falsy value. You can retrieve the original falsy value from the error's &lt;code&gt;.cause&lt;/code&gt; property.</source>
          <target state="translated">約束は（と拒否に等しい、またはまったく値falsy値で拒否することができ &lt;code&gt;undefined&lt;/code&gt; ）、しかし &lt;code&gt;.asCallback&lt;/code&gt; はでコールバックを呼び出します &lt;code&gt;Error&lt;/code&gt; 約束の拒絶理由がfalsy値である場合、オブジェクト。エラーの &lt;code&gt;.cause&lt;/code&gt; プロパティから元の偽の値を取得できます。</target>
        </trans-unit>
        <trans-unit id="51f657ce6a52627dea6e94af335b6ca122d8163b" translate="yes" xml:space="preserve">
          <source>Promises can have a steep learning curve and it doesn't help that promise standards go out of their way to make it even harder. Bluebird works around the limitations by providing warnings where the standards disallow throwing errors when incorrect usage is detected. See &lt;a href=&quot;warning-explanations&quot;&gt;Warning Explanations&lt;/a&gt; for the possible warnings that bluebird covers.</source>
          <target state="translated">プロミスは急な学習曲線を持つ可能性があり、プロミス標準がそれをさらに難しくするために彼らの道を外れることを助けません。Bluebirdは、誤った使用法が検出されたときに標準がエラーのスローを許可しない警告を提供することにより、制限を回避します。bluebirdがカバーする可能性のある警告&lt;a href=&quot;warning-explanations&quot;&gt;について&lt;/a&gt;は、警告の説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="3be96f5495c2d83069fb9e4fe84ca585a4ab5539" translate="yes" xml:space="preserve">
          <source>Promises do not aim to solve such live updating problems directly. One option would be to use an intermediate promise - for example a &lt;code&gt;.loaded&lt;/code&gt; property on the model that fulfills with nothing.</source>
          <target state="translated">Promiseは、このようなライブアップデートの問題を直接解決することを目的としていません。1つのオプションは、中間プロミスを使用することです。たとえば、何も &lt;code&gt;.loaded&lt;/code&gt; ないモデルの.loadedプロパティです。</target>
        </trans-unit>
        <trans-unit id="63104f36ddfde5f398242d3c9a325847a623a94b" translate="yes" xml:space="preserve">
          <source>Promises have state, they start as pending and can settle to:</source>
          <target state="translated">約束は状態を持っていて、彼らは保留として開始され、解決することができます。</target>
        </trans-unit>
        <trans-unit id="dc07d53901ac77bfe4d99f439fd922d98f514777" translate="yes" xml:space="preserve">
          <source>Promises now clean up all references (to handlers, child promises etc) as soon as possible.</source>
          <target state="translated">プロミスは、すべての参照(ハンドラや子プロミスなどへの参照)を可能な限り早くクリーンアップするようになりました。</target>
        </trans-unit>
        <trans-unit id="4f7e995a45e8a7aa84e5616f32bd9b6d2f616aeb" translate="yes" xml:space="preserve">
          <source>Promises now delete references to handlers attached to them as soon as possible</source>
          <target state="translated">プロミスでは、それらに接続されているハンドラへの参照を可能な限り速やかに削除するようになりました。</target>
        </trans-unit>
        <trans-unit id="85f84a547296b83c2cd9be954bf35fa432933967" translate="yes" xml:space="preserve">
          <source>Promises perform a role similar to &lt;code&gt;IO&lt;/code&gt; in that they allow for easy chaining of asynchronous non-blocking operations. &lt;code&gt;Promise.coroutine&lt;/code&gt; can be seen as similar to &lt;code&gt;do&lt;/code&gt; notation although in practice it's not an accurate comparison.</source>
          <target state="translated">Promiseは、非同期の非ブロッキング操作を簡単に連鎖できるという点で、 &lt;code&gt;IO&lt;/code&gt; と同様の役割を果たします。 &lt;code&gt;Promise.coroutine&lt;/code&gt; は &lt;code&gt;do&lt;/code&gt; 表記に似ていると見なすことができますが、実際には正確な比較ではありません。</target>
        </trans-unit>
        <trans-unit id="3e8ddebed649b44e7a85d5ae2af303397fa7ea81" translate="yes" xml:space="preserve">
          <source>Promises provide a lot of really cool and powerful guarantees like throw safety which are hard to provide when manually converting APIs to use promises. Thus, whenever it is possible to use the &lt;code&gt;Promise.promisify&lt;/code&gt; and &lt;code&gt;Promise.promisifyAll&lt;/code&gt; methods - we recommend you use them. Not only are they the safest form of conversion - they also use techniques of dynamic recompilation to introduce very little overhead.</source>
          <target state="translated">プロミスは、プロミスを使用するようにAPIを手動で変換するときに提供するのが難しいスローの安全性など、本当にクールで強力な多くの保証を提供します。このように、それを使用することが可能である時はいつでも &lt;code&gt;Promise.promisify&lt;/code&gt; と &lt;code&gt;Promise.promisifyAll&lt;/code&gt; 方法を-私たちは、あなたがそれらを使用することをお勧め。変換の最も安全な形式であるだけでなく、動的再コンパイルの手法を使用してオーバーヘッドをほとんど導入しません。</target>
        </trans-unit>
        <trans-unit id="45fe5ca98fd7d2bd4d25dbf8138ba708e64fdca4" translate="yes" xml:space="preserve">
          <source>Promises returned by the &lt;code&gt;mapper&lt;/code&gt; function are awaited for and the returned promise doesn't fulfill until all mapped promises have fulfilled as well. If any promise in the array is rejected, or any promise returned by the &lt;code&gt;mapper&lt;/code&gt; function is rejected, the returned promise is rejected as well.</source>
          <target state="translated">&lt;code&gt;mapper&lt;/code&gt; 関数によって返されたプロミスは待機され、返されたプロミスは、マップされたすべてのプロミスが同様に満たされるまで満たされません。配列内のプロミスが拒否された場合、または &lt;code&gt;mapper&lt;/code&gt; 関数によって返されたプロミスが拒否された場合、返されたプロミスも同様に拒否されます。</target>
        </trans-unit>
        <trans-unit id="7e30cdf817cbb4a8901ddafd58155a4d7d146650" translate="yes" xml:space="preserve">
          <source>Promises:</source>
          <target state="translated">Promises:</target>
        </trans-unit>
        <trans-unit id="7bdd89f28407b699d8b7e554f8c4f6ce47ea6c46" translate="yes" xml:space="preserve">
          <source>Promisification</source>
          <target state="translated">Promisification</target>
        </trans-unit>
        <trans-unit id="590f705f9b259c4f0eb3b51eea47cea46ae9c547" translate="yes" xml:space="preserve">
          <source>Promisification API changes</source>
          <target state="translated">プロミスAPIの変更</target>
        </trans-unit>
        <trans-unit id="1a75c237f8187352ba7d075c4badc17c24ae0667" translate="yes" xml:space="preserve">
          <source>Promisification means converting an existing promise-unaware API to a promise-returning API.</source>
          <target state="translated">プロミス化とは、既存のプロミスを認識していないAPIをプロミスを返すAPIに変換することです。</target>
        </trans-unit>
        <trans-unit id="f53b14543d28697f9e7972521e017a85547d2532" translate="yes" xml:space="preserve">
          <source>Promisification now consider all functions on the object and its prototype chain</source>
          <target state="translated">Promisificationは今、オブジェクトとそのプロトタイプチェーン上のすべての関数を考慮する</target>
        </trans-unit>
        <trans-unit id="0968c7924c5fa044c0bc32de590809b8b7a0237f" translate="yes" xml:space="preserve">
          <source>Promisification on steroids</source>
          <target state="translated">ステロイドでのプロミス化</target>
        </trans-unit>
        <trans-unit id="f0fa280902593381c17c8ba3cc647f71fd36f85f" translate="yes" xml:space="preserve">
          <source>Promisified methods from promisifyAll no longer call the original method when it is overriden</source>
          <target state="translated">promisifyAll から約束されたメソッドは、元のメソッドがオーバーライドされても呼び出されなくなります。</target>
        </trans-unit>
        <trans-unit id="852dd44380a8f2d2fa9332abfb43753326f8154b" translate="yes" xml:space="preserve">
          <source>Promisifier APIs.</source>
          <target state="translated">プロミシファイアAPI。</target>
        </trans-unit>
        <trans-unit id="b7ec2af376bac24219fefb48cbd2c962d80ace5d" translate="yes" xml:space="preserve">
          <source>Promisifies the entire object by going through the object's properties and creating an async equivalent of each function on the object and its prototype chain. The promisified method name will be the original method name suffixed with &lt;code&gt;suffix&lt;/code&gt; (default is &lt;code&gt;&quot;Async&quot;&lt;/code&gt;). Any class properties of the object (which is the case for the main export of many modules) are also promisified, both static and instance methods. Class property is a property with a function value that has a non-empty &lt;code&gt;.prototype&lt;/code&gt; object. Returns the input object.</source>
          <target state="translated">オブジェクトのプロパティを調べ、オブジェクトとそのプロトタイプチェーンの各関数に相当する非同期の等価物を作成することにより、オブジェクト全体を約束します。約束されたメソッド名は、サフィックスが付いた元のメソッド名になり &lt;code&gt;suffix&lt;/code&gt; （デフォルトは &lt;code&gt;&quot;Async&quot;&lt;/code&gt; ）。オブジェクトのクラスプロパティ（多くのモジュールのメインエクスポートの場合）も、静的メソッドとインスタンスメソッドの両方で約束されています。クラスプロパティは、空ではない &lt;code&gt;.prototype&lt;/code&gt; オブジェクトを持つ関数値を持つプロパティです。入力オブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="7adb5806d2a6c639cdca0db8fdac9403bca0bc03" translate="yes" xml:space="preserve">
          <source>Promisifying multiple classes in one go</source>
          <target state="translated">一度に複数のクラスをプロミスする</target>
        </trans-unit>
        <trans-unit id="c938fd9d6e36daebdbc0cf487cfd4869c4aa7f93" translate="yes" xml:space="preserve">
          <source>Proper version check supporting VSCode(&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/1576&quot;&gt;&lt;code&gt;#1576&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">VSCode（&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/1576&quot;&gt; &lt;code&gt;#1576&lt;/code&gt; &lt;/a&gt;）をサポートする適切なバージョンチェック</target>
        </trans-unit>
        <trans-unit id="6e3604888c4b4ec08e2837913d012fe2834ffa83" translate="yes" xml:space="preserve">
          <source>Python</source>
          <target state="translated">Python</target>
        </trans-unit>
        <trans-unit id="4177920eedb2d8d91fca3384f4b40aec4d20dcd2" translate="yes" xml:space="preserve">
          <source>Q and bluebird share a lot of common methods that nevertheless have different names:</source>
          <target state="translated">Qとブルーバードは、それにもかかわらず、異なる名前を持っている多くの共通のメソッドを共有しています。</target>
        </trans-unit>
        <trans-unit id="e9f05aa2c47c6bff64cd5f9cf0a523af4429924d" translate="yes" xml:space="preserve">
          <source>Rate Limiting</source>
          <target state="translated">レート制限</target>
        </trans-unit>
        <trans-unit id="161ffbbe54e77d4760152fa5b4074a0a6142966a" translate="yes" xml:space="preserve">
          <source>Read given files sequentially while summing their contents as an integer. Each file contains just the text &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">内容を整数として合計しながら、指定されたファイルを順番に読み取ります。各ファイルには、テキスト &lt;code&gt;10&lt;/code&gt; のみが含まれています。</target>
        </trans-unit>
        <trans-unit id="26bb4a571dec15958b5bf88436f13b472b9923db" translate="yes" xml:space="preserve">
          <source>Real example 2:</source>
          <target state="translated">実例2.</target>
        </trans-unit>
        <trans-unit id="cf7056b7cac2c0b2ad06995c1808b40114dc8624" translate="yes" xml:space="preserve">
          <source>Real example:</source>
          <target state="translated">実際の例。</target>
        </trans-unit>
        <trans-unit id="ede0567a2a6e0fddab65269f6559f8f6dd06aeb3" translate="yes" xml:space="preserve">
          <source>Rebinding can also be abused to do something gratuitous like this:</source>
          <target state="translated">Rebindingは、このように恩着せがましいことをするために悪用されることもあります。</target>
        </trans-unit>
        <trans-unit id="bf87a9a8812fbf363e857266207b8e2473838eca" translate="yes" xml:space="preserve">
          <source>Reduce minified full browser build file size by not including unused code generation functionality.</source>
          <target state="translated">未使用のコード生成機能を含まないことで、最小化されたフルブラウザビルドのファイルサイズを削減します。</target>
        </trans-unit>
        <trans-unit id="aef1e9eebf3f426cee92bf8ff691ff6719cedbd1" translate="yes" xml:space="preserve">
          <source>Register a node-style callback on this promise. When this promise is either fulfilled or rejected, the node callback will be called back with the node.js convention where error reason is the first argument and success value is the second argument. The error argument will be &lt;code&gt;null&lt;/code&gt; in case of success.</source>
          <target state="translated">このpromiseにノードスタイルのコールバックを登録します。このpromiseが満たされるか拒否されると、nodeコールバックはnode.js規則でコールバックされます。ここで、エラー理由は最初の引数で、成功値は2番目の引数です。成功した場合、エラー引数は &lt;code&gt;null&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="e8d6efc26ea6904bda20ba7769db8ea12c079f56" translate="yes" xml:space="preserve">
          <source>Reject the underlying promise with &lt;code&gt;reason&lt;/code&gt; as the rejection reason.</source>
          <target state="translated">&lt;code&gt;reason&lt;/code&gt; を拒否理由として、根底にある約束を拒否します。</target>
        </trans-unit>
        <trans-unit id="3368ac8416e6d7cbc9d06211f6a676de253db2de" translate="yes" xml:space="preserve">
          <source>Rejections originating from &lt;code&gt;Promise.reject&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Promise.reject&lt;/code&gt; からの拒否</target>
        </trans-unit>
        <trans-unit id="8b0dba4404c73e60c9ff9e9453523c35331ea038" translate="yes" xml:space="preserve">
          <source>Rejections originating from &lt;code&gt;PromiseResolver&lt;/code&gt; where &lt;code&gt;.reject()&lt;/code&gt; method is called explicitly</source>
          <target state="translated">発信拒否 &lt;code&gt;PromiseResolver&lt;/code&gt; &lt;code&gt;.reject()&lt;/code&gt; メソッドが明示的に呼び出されます</target>
        </trans-unit>
        <trans-unit id="41142268db768fb66fa944cf61f77fd9b9826e36" translate="yes" xml:space="preserve">
          <source>Rejections originating from &lt;code&gt;new Promise&lt;/code&gt; constructor where the &lt;code&gt;reject&lt;/code&gt; callback is called explicitly</source>
          <target state="translated">拒否コールバックが明示的に呼び出される &lt;code&gt;new Promise&lt;/code&gt; コンストラクターから発生する &lt;code&gt;reject&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4fe2d523f67748538641074127a1db6157d74f6a" translate="yes" xml:space="preserve">
          <source>Rejections originating from promisified callbacks which use the &lt;code&gt;errback&lt;/code&gt; argument</source>
          <target state="translated">&lt;code&gt;errback&lt;/code&gt; 引数を使用する約束されたコールバックから発生する拒否</target>
        </trans-unit>
        <trans-unit id="8eec88d2942215a1433216bd7c1c773ddcf67d09" translate="yes" xml:space="preserve">
          <source>Rejections originating from thenables using the &lt;code&gt;reject&lt;/code&gt; callback</source>
          <target state="translated">&lt;code&gt;reject&lt;/code&gt; コールバックを使用したthenablesからの拒否</target>
        </trans-unit>
        <trans-unit id="198141ba7b56bcf3bec5a18ddd355c8adf68088b" translate="yes" xml:space="preserve">
          <source>Release control of the &lt;code&gt;Promise&lt;/code&gt; namespace to whatever it was before this library was loaded. Returns a reference to the library namespace so you can attach it to something else.</source>
          <target state="translated">このライブラリがロードされる前の &lt;code&gt;Promise&lt;/code&gt; ネームスペースの制御を解放します。ライブラリの名前空間への参照を返すため、別の名前空間にアタッチできます。</target>
        </trans-unit>
        <trans-unit id="0181ee2fe3f8479b72a162b35eb3977b69562275" translate="yes" xml:space="preserve">
          <source>Remove dependency of es5-shim and es5-sham when using ES3.</source>
          <target state="translated">ES3使用時にes5-shimとes5-shamの依存関係を削除しました。</target>
        </trans-unit>
        <trans-unit id="e444431ea8965e36418e87f29f232d6f066fbe6e" translate="yes" xml:space="preserve">
          <source>Remove kew from benchmarks due to bugs in the library breaking the benchmark</source>
          <target state="translated">ベンチマークを壊すライブラリのバグのため、ベンチマークから kew を削除</target>
        </trans-unit>
        <trans-unit id="1a4dd4da1213db0bc986ba8e811f9173d4dfd37c" translate="yes" xml:space="preserve">
          <source>Remove memoization of thenables</source>
          <target state="translated">イネーブルのメモ書きを削除する</target>
        </trans-unit>
        <trans-unit id="851f4336d464dd91890330239ecdcbcd3eede50c" translate="yes" xml:space="preserve">
          <source>Remove uses of dynamic evaluation (&lt;code&gt;new Function&lt;/code&gt;, &lt;code&gt;eval&lt;/code&gt; etc) when strictly not necessary. Use feature detection to use static evaluation to avoid errors when dynamic evaluation is prohibited.</source>
          <target state="translated">動的評価（ &lt;code&gt;new Function&lt;/code&gt; 、 &lt;code&gt;eval&lt;/code&gt; など）の使用を、厳密に不要な場合は削除します。動的評価が禁止されている場合、エラーを回避するために静的評価を使用するには、機能検出を使用します。</target>
        </trans-unit>
        <trans-unit id="963bc143de16fd9c36ff8020e48785b4de1b5fa2" translate="yes" xml:space="preserve">
          <source>Removed the &lt;code&gt;.inspect()&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;.inspect()&lt;/code&gt; メソッドを削除しました</target>
        </trans-unit>
        <trans-unit id="73c105dee9adb30dced75f9d53b912f789492799" translate="yes" xml:space="preserve">
          <source>Rename PromiseResolver#asCallback to PromiseResolver#callback</source>
          <target state="translated">PromiseResolver#asCallback を PromiseResolver#callback に名前を変更します。</target>
        </trans-unit>
        <trans-unit id="a93b7a7d13386c2b9229d1b2d9f532763ef7e300" translate="yes" xml:space="preserve">
          <source>Report unhandled rejections even when long stack traces are disabled</source>
          <target state="translated">長いスタックトレースが無効化されている場合でも、処理されていない拒否を報告する</target>
        </trans-unit>
        <trans-unit id="212187c4ba067f96c7eec7538c40788ae9024465" translate="yes" xml:space="preserve">
          <source>Represents an error is an explicit promise rejection as opposed to a thrown error. For example, if an error is errbacked by a callback API promisified through &lt;a href=&quot;promise.promisify&quot;&gt;&lt;code&gt;Promise.promisify&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; and is not a typed error, it will be converted to a &lt;code&gt;OperationalError&lt;/code&gt; which has the original error in the &lt;code&gt;.cause&lt;/code&gt; property.</source>
          <target state="translated">エラーは、スローされたエラーではなく明示的なプロミス拒否であることを表します。エラーを通っpromisifiedコールバックAPIによってerrbackedされている場合、例えば、&lt;a href=&quot;promise.promisify&quot;&gt; &lt;code&gt;Promise.promisify&lt;/code&gt; &lt;/a&gt;又は&lt;a href=&quot;promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt;と型付きエラーではない、それはに変換され &lt;code&gt;OperationalError&lt;/code&gt; に元のエラーを有する &lt;code&gt;.cause&lt;/code&gt; プロパティ。</target>
        </trans-unit>
        <trans-unit id="f957ddaaf86217c5ba862399d723b49b7e0b15cb" translate="yes" xml:space="preserve">
          <source>Requires a statement so cannot be used in an expression context</source>
          <target state="translated">文が必要なので、式のコンテキストでは使用できません。</target>
        </trans-unit>
        <trans-unit id="9c076f55ca621ae470e8e6540a2f2547c25d4dbe" translate="yes" xml:space="preserve">
          <source>Resolve the underlying promise with &lt;code&gt;value&lt;/code&gt; as the resolution value. If &lt;code&gt;value&lt;/code&gt; is a thenable or a promise, the underlying promise will assume its state.</source>
          <target state="translated">解決の &lt;code&gt;value&lt;/code&gt; として値を使用して、基になるプロミスを解決します。場合 &lt;code&gt;value&lt;/code&gt; thenableまたは約束で、根本的な約束は、その状態を仮定します。</target>
        </trans-unit>
        <trans-unit id="78389e9ab495397e98445c046d321313be7d1269" translate="yes" xml:space="preserve">
          <source>Resolves to the original array unmodified, this method is meant to be used for side effects. If the iterator function returns a promise or a thenable, then the result of the promise is awaited, before continuing with next iteration.</source>
          <target state="translated">変更されていない元の配列に解決し、このメソッドは副作用のために使用されることを意図しています。イテレータ関数がプロミスまたは thenable を返した場合は、プロミスの結果を待ってから次の反復処理を行います。</target>
        </trans-unit>
        <trans-unit id="ce09507134e744cff09a805076e969ccb76e51c1" translate="yes" xml:space="preserve">
          <source>Resolves to the original array unmodified. This method is meant to be used for side effects.</source>
          <target state="translated">変更されていない元の配列に解決します。このメソッドは、副作用のために使用されることを意図しています。</target>
        </trans-unit>
        <trans-unit id="9e392aa0bd224f1b62eea587068fd172df50f2e7" translate="yes" xml:space="preserve">
          <source>Resource management</source>
          <target state="translated">資源管理</target>
        </trans-unit>
        <trans-unit id="0d5055e26e1fb07ecf2ddfcb210895ed4ebe7ce8" translate="yes" xml:space="preserve">
          <source>Rethink already uses Bluebird promises internally and has promise returning APIs. Use those.</source>
          <target state="translated">Rethink はすでに Bluebird のプロミスを内部で使用しており、プロミスを返す API を持っています。それらを使用します。</target>
        </trans-unit>
        <trans-unit id="89ddb5cfb70d8bad46dda602a6ccbd88515a58d8" translate="yes" xml:space="preserve">
          <source>RethinkDB</source>
          <target state="translated">RethinkDB</target>
        </trans-unit>
        <trans-unit id="48ceb22a9c112e78b0de9c59218daa18a395591e" translate="yes" xml:space="preserve">
          <source>Returns a Disposer object which encapsulates both the resource as well as the method to clean it up. The user can pass this object to &lt;code&gt;Promise.using&lt;/code&gt; to get access to the resource when it becomes available, as well as to ensure it's automatically cleaned up.</source>
          <target state="translated">リソースとそれをクリーンアップするメソッドの両方をカプセル化するDisposerオブジェクトを返します。ユーザーは、このオブジェクトを &lt;code&gt;Promise.using&lt;/code&gt; に渡して、リソースが利用可能になったときにアクセスし、リソースが自動的にクリーンアップされるようにします。</target>
        </trans-unit>
        <trans-unit id="5f6f3eb0a331057a9ce7728d16275ef0f0403798" translate="yes" xml:space="preserve">
          <source>Returns a function that can use &lt;code&gt;yield&lt;/code&gt; to yield promises. Control is returned back to the generator when the yielded promise settles. This can lead to less verbose code when doing lots of sequential async calls with minimal processing in between. Requires node.js 0.12+, io.js 1.0+ or Google Chrome 40+.</source>
          <target state="translated">promise を生成する &lt;code&gt;yield&lt;/code&gt; にyieldを使用できる関数を返します。生成されたプロミスが解決すると、制御がジェネレーターに戻ります。これにより、間に最小限の処理で多数の順次非同期呼び出しを実行するときに、コードが冗長にならない可能性があります。node.js 0.12 +、io.js 1.0+、またはGoogle Chrome 40+が必要です。</target>
        </trans-unit>
        <trans-unit id="0f8e633d273655fa3f1e81f2818120962168742f" translate="yes" xml:space="preserve">
          <source>Returns a function that will wrap the given &lt;code&gt;nodeFunction&lt;/code&gt;. Instead of taking a callback, the returned function will return a promise whose fate is decided by the callback behavior of the given node function. The node function should conform to node.js convention of accepting a callback as last argument and calling that callback with error as the first argument and success value on the second argument.</source>
          <target state="translated">指定された &lt;code&gt;nodeFunction&lt;/code&gt; をラップする関数を返します。コールバックを受け取る代わりに、返された関数は、その運命が与えられたノード関数のコールバック動作によって決定されるpromiseを返します。ノード関数は、最後の引数としてコールバックを受け入れ、最初の引数としてエラーを使用してそのコールバックを呼び出し、2番目の引数で成功値を返すというnode.js規則に準拠する必要があります。</target>
        </trans-unit>
        <trans-unit id="77302444e8cc66fc3523da337688a121188e8a8c" translate="yes" xml:space="preserve">
          <source>Returns a new function that wraps the given function &lt;code&gt;fn&lt;/code&gt;. The new function will always return a promise that is fulfilled with the original functions return values or rejected with thrown exceptions from the original function.</source>
          <target state="translated">指定された関数 &lt;code&gt;fn&lt;/code&gt; をラップする新しい関数を返します。新しい関数は常に、元の関数の戻り値で満たされる、または元の関数からスローされた例外で拒否されるプロミスを返します。</target>
        </trans-unit>
        <trans-unit id="d0084f22c144f601402343afe0d33d4fb7f3e903" translate="yes" xml:space="preserve">
          <source>Returns a new independent copy of the Bluebird library.</source>
          <target state="translated">Bluebird ライブラリの新しい独立したコピーを返します。</target>
        </trans-unit>
        <trans-unit id="1b966690c369fe4ac468c8b47b2a688522f4806f" translate="yes" xml:space="preserve">
          <source>Returns a promise for an array that contains the values returned by the &lt;code&gt;iterator&lt;/code&gt; function in their respective positions. The iterator won't be called for an item until its previous item, and the promise returned by the iterator for that item are fulfilled. This results in a &lt;code&gt;mapSeries&lt;/code&gt; kind of utility but it can also be used simply as a side effect iterator similar to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;code&gt;Array#forEach&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">それぞれの位置にある &lt;code&gt;iterator&lt;/code&gt; 関数によって返された値を含む配列のpromiseを返します。イテレータは、前のアイテムまで呼び出されず、イテレータによって返されたそのアイテムのプロミスが満たされます。これにより、 &lt;code&gt;mapSeries&lt;/code&gt; のようなユーティリティが生成されますが、単に&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt; &lt;code&gt;Array#forEach&lt;/code&gt; &lt;/a&gt;と同様の副作用イテレータとして使用することもできます。</target>
        </trans-unit>
        <trans-unit id="9fa83662ab7e1494742b674953702f77f5f38fa1" translate="yes" xml:space="preserve">
          <source>Returns a promise that is resolved by a node style callback function. This is the most fitting way to do on the fly promisification when libraries don't expose classes for automatic promisification by undefined.</source>
          <target state="translated">ノードスタイルのコールバック関数によって解決されたプロミスを返します。これは、ライブラリが未定義による自動プロミス化のためのクラスを公開していない場合に、オンザフライでプロミス化を行うのに最も適した方法です。</target>
        </trans-unit>
        <trans-unit id="4da867e8cf20d6ea986a5fd922cf7a1fb8f17c8a" translate="yes" xml:space="preserve">
          <source>Returns a promise that will be fulfilled with this promise's fulfillment value or rejection reason. However, if this promise is not fulfilled or rejected within &lt;code&gt;ms&lt;/code&gt; milliseconds, the returned promise is rejected with a &lt;a href=&quot;timeouterror&quot;&gt;&lt;code&gt;TimeoutError&lt;/code&gt;&lt;/a&gt; or the &lt;code&gt;error&lt;/code&gt; as the reason.</source>
          <target state="translated">このプロミスの履行価値または拒否理由で履行されるプロミスを返します。ただし、このプロミスが &lt;code&gt;ms&lt;/code&gt; ミリ秒以内に実行または拒否されない場合、返されたプロミスは&lt;a href=&quot;timeouterror&quot;&gt; &lt;code&gt;TimeoutError&lt;/code&gt; &lt;/a&gt;または &lt;code&gt;error&lt;/code&gt; を理由として拒否されます。</target>
        </trans-unit>
        <trans-unit id="dd6aed551657efa53d35002ee36b6a3e0c3755d8" translate="yes" xml:space="preserve">
          <source>Returns a promise that will be resolved with &lt;code&gt;value&lt;/code&gt; (or &lt;code&gt;undefined&lt;/code&gt;) after given &lt;code&gt;ms&lt;/code&gt; milliseconds. If &lt;code&gt;value&lt;/code&gt; is a promise, the delay will start counting down when it is fulfilled and the returned promise will be fulfilled with the fulfillment value of the &lt;code&gt;value&lt;/code&gt; promise. If &lt;code&gt;value&lt;/code&gt; is a rejected promise, the resulting promise will be rejected immediately.</source>
          <target state="translated">指定された &lt;code&gt;ms&lt;/code&gt; ミリ秒後に &lt;code&gt;value&lt;/code&gt; （または &lt;code&gt;undefined&lt;/code&gt; ）で解決されるpromiseを返します。場合 &lt;code&gt;value&lt;/code&gt; 約束され、それが満たされていると返された約束は履行の値が満たされるとき、遅延がカウントダウンを開始します &lt;code&gt;value&lt;/code&gt; 約束。場合 &lt;code&gt;value&lt;/code&gt; 拒否約束である、結果として約束はすぐに拒否されます。</target>
        </trans-unit>
        <trans-unit id="0baaeaec06f70621397f1ef99fcbfb8ddf084acc" translate="yes" xml:space="preserve">
          <source>Returns back this promise instead of creating a new one. If the &lt;code&gt;callback&lt;/code&gt; argument is not a function, this method does not do anything.</source>
          <target state="translated">新しいプロミスを作成する代わりに、このプロミスを返します。場合は &lt;code&gt;callback&lt;/code&gt; 引数は関数ではありません、このメソッドは何もしません。</target>
        </trans-unit>
        <trans-unit id="f7778ce7c8366fce862636b34420e6d9618d48dd" translate="yes" xml:space="preserve">
          <source>Revert monitoring feature due to crash in browser</source>
          <target state="translated">ブラウザのクラッシュによるリバート監視機能</target>
        </trans-unit>
        <trans-unit id="48334a9d7741c7c5b6ebf7eef29195609c38e705" translate="yes" xml:space="preserve">
          <source>Rollback non-working multiple fresh copies feature</source>
          <target state="translated">ロールバック非動作の複数の新鮮なコピーの特徴</target>
        </trans-unit>
        <trans-unit id="af2379a3b3b95738bc09586b8c9af459a812b070" translate="yes" xml:space="preserve">
          <source>Run example on JSBin</source>
          <target state="translated">JSBinでの実行例</target>
        </trans-unit>
        <trans-unit id="080508f70cca7834ce2ef4eef4f37dd98ffff2b4" translate="yes" xml:space="preserve">
          <source>Running the example:</source>
          <target state="translated">例題を実行します。</target>
        </trans-unit>
        <trans-unit id="e2fa217fe73b363a41e739397cee0e3ca1933591" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.all&quot;&gt;&lt;code&gt;Promise.all(this)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;promise.all&quot;&gt; &lt;code&gt;Promise.all(this)&lt;/code&gt; と&lt;/a&gt;同じです。</target>
        </trans-unit>
        <trans-unit id="2b23caad0148511b77a2cf241f932d7c6709a7d3" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.any&quot;&gt;&lt;code&gt;Promise.any(this)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;promise.any&quot;&gt; &lt;code&gt;Promise.any(this)&lt;/code&gt; と&lt;/a&gt;同じです。</target>
        </trans-unit>
        <trans-unit id="580ea88db97d01930313a97fceee680b30d45b7d" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.filter&quot;&gt;&lt;code&gt;Promise.filter(this, filterer, options)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;promise.filter&quot;&gt; &lt;code&gt;Promise.filter(this, filterer, options)&lt;/code&gt; &lt;/a&gt;同じです。</target>
        </trans-unit>
        <trans-unit id="975ef8a2ddc0a473b966c6a5cf58d6b15ce60290" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.map&quot;&gt;&lt;code&gt;Promise.map(this, mapper, options)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;promise.map&quot;&gt; &lt;code&gt;Promise.map(this, mapper, options)&lt;/code&gt; &lt;/a&gt;同じです。</target>
        </trans-unit>
        <trans-unit id="c6801edeea7902bcdcddad94e4e019a39b6cf35a" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.mapseries&quot;&gt;&lt;code&gt;Promise.mapSeries(this, iterator)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;promise.mapseries&quot;&gt; &lt;code&gt;Promise.mapSeries(this, iterator)&lt;/code&gt; &lt;/a&gt;同じです。</target>
        </trans-unit>
        <trans-unit id="b8c55e09fe61d7950e9b369ac035513826c1d2a6" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.props&quot;&gt;&lt;code&gt;Promise.props(this)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;promise.props&quot;&gt; &lt;code&gt;Promise.props(this)&lt;/code&gt; と&lt;/a&gt;同じです。</target>
        </trans-unit>
        <trans-unit id="8a380c08b4944e2caae2cd146735f961151b5e6e" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.reduce&quot;&gt;&lt;code&gt;Promise.reduce(this, reducer, initialValue)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;promise.reduce&quot;&gt; &lt;code&gt;Promise.reduce(this, reducer, initialValue)&lt;/code&gt; &lt;/a&gt;同じです。</target>
        </trans-unit>
        <trans-unit id="a356dad7c25106bdfd17533e6d57d965a40a5a84" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.some&quot;&gt;&lt;code&gt;Promise.some(this, count)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;promise.some&quot;&gt; &lt;code&gt;Promise.some(this, count)&lt;/code&gt; &lt;/a&gt;同じです。</target>
        </trans-unit>
        <trans-unit id="f6cc344c16a1e8b60323a0d888ae481c9928a8ab" translate="yes" xml:space="preserve">
          <source>Same as calling &lt;a href=&quot;promise.bind&quot;&gt;&lt;code&gt;Promise.bind(thisArg, thisPromise)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;promise.bind&quot;&gt; &lt;code&gt;Promise.bind(thisArg, thisPromise)&lt;/code&gt; &lt;/a&gt;を呼び出すのと同じです。</target>
        </trans-unit>
        <trans-unit id="e458385af15b3281d6aad96024285a33aab42f7e" translate="yes" xml:space="preserve">
          <source>Same as calling &lt;a href=&quot;promise.delay&quot;&gt;&lt;code&gt;Promise.delay(ms, this)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;promise.delay&quot;&gt; &lt;code&gt;Promise.delay(ms, this)&lt;/code&gt; &lt;/a&gt;を呼び出すのと同じです。</target>
        </trans-unit>
        <trans-unit id="c2c078b3023463c3ffc03ea245f314b93b9997db" translate="yes" xml:space="preserve">
          <source>Same limitations regarding to the binding time of &lt;code&gt;reason&lt;/code&gt; to apply as with &lt;a href=&quot;return&quot;&gt;&lt;code&gt;.return&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;return&quot;&gt; &lt;code&gt;.return&lt;/code&gt; &lt;/a&gt;と同じように、適用する &lt;code&gt;reason&lt;/code&gt; のバインド時間に関して同じ制限があります。</target>
        </trans-unit>
        <trans-unit id="c5f6c90a1ad0cebcb9beb15aafa1cb6735ec4a6f" translate="yes" xml:space="preserve">
          <source>Same limitations regarding to the binding time of &lt;code&gt;value&lt;/code&gt; to apply as with &lt;a href=&quot;return&quot;&gt;&lt;code&gt;.return&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;return&quot;&gt; &lt;code&gt;.return&lt;/code&gt; &lt;/a&gt;と同様に、適用する &lt;code&gt;value&lt;/code&gt; のバインド時間に関して同じ制限があります。</target>
        </trans-unit>
        <trans-unit id="7b7e70bcf209a5323526033a9cbf768a3ae70c2c" translate="yes" xml:space="preserve">
          <source>Scala</source>
          <target state="translated">Scala</target>
        </trans-unit>
        <trans-unit id="4c8d353832617594b0903e9beaf0a3bc9414fd0a" translate="yes" xml:space="preserve">
          <source>Scheduler should be a function that asynchronously schedules the calling of the passed in function:</source>
          <target state="translated">スケジューラは、渡された関数の呼び出しを非同期にスケジュールする関数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="b6e22d4f13d0bc08ae5171b4f3faa591b3854aba" translate="yes" xml:space="preserve">
          <source>Scoped prototypes</source>
          <target state="translated">スコープされたプロトタイプ</target>
        </trans-unit>
        <trans-unit id="1e4c2c805f8ac17da444424c8f8bf077911b3260" translate="yes" xml:space="preserve">
          <source>Second example is creating a function that does nothing but manually wrap a callback API and doing a poor job at that:</source>
          <target state="translated">2 番目の例は、コールバック API を手動でラップするだけの関数を作成しています。</target>
        </trans-unit>
        <trans-unit id="c651da6b87ea51d587627a0d63283b28e42fd9e4" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#map-option-concurrency&quot;&gt;Map Option: concurrency&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#map-option-concurrency&quot;&gt;Map Option：concurrencyを&lt;/a&gt;参照してください</target>
        </trans-unit>
        <trans-unit id="3fc2fab79463362dbab8dbab63714a6f37b5961f" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#promisification&quot;&gt;promisification&lt;/a&gt; for more examples.</source>
          <target state="translated">その他の例については、&lt;a href=&quot;#promisification&quot;&gt;約束&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="23a68335a77ae0704a80f59d32facaab6ffbdba9" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;api/cancellation&quot;&gt;&lt;code&gt;Cancellation&lt;/code&gt;&lt;/a&gt; for how to use cancellation.</source>
          <target state="translated">&lt;a href=&quot;api/cancellation&quot;&gt; &lt;code&gt;Cancellation&lt;/code&gt; &lt;/a&gt;使用方法については、キャンセルを参照してください。</target>
        </trans-unit>
        <trans-unit id="5f52e149e8a0803d7f7b841c33681f919e936364" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;api/environment-variables&quot;&gt;&lt;code&gt;Environment Variables&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;api/environment-variables&quot;&gt; &lt;code&gt;Environment Variables&lt;/code&gt; &lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ab38b0ca0dbd1886ea0aa3b5d41ba2fd2e703bb5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;api/error-management-configuration#global-rejection-events&quot;&gt;global rejection events&lt;/a&gt; to learn more about the hooks.</source>
          <target state="translated">フックの詳細については、&lt;a href=&quot;api/error-management-configuration#global-rejection-events&quot;&gt;グローバル拒否イベント&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="06395aee9e31cf27b400d0aac841e6752959ba6e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;api/progression-migration&quot;&gt;Progression Migration&lt;/a&gt; for migration assistance and examples of how to convert APIs that use progression to ones that do not.</source>
          <target state="translated">移行の支援と、進行を使用するAPIを使用しないAPIに変換する方法の例については、&lt;a href=&quot;api/progression-migration&quot;&gt;進行マイグレーション&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="68ba78b1d14da78646ebff542d287d69dbc5a960" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://stackoverflow.com/a/17891099/227176&quot;&gt;this StackOverflow answer&lt;/a&gt; for a more detailed and feature complete way to make custom errors.</source>
          <target state="translated">カスタムエラーを発生させるためのより詳細で機能的な完全な方法については、&lt;a href=&quot;http://stackoverflow.com/a/17891099/227176&quot;&gt;このStackOverflowの回答&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="06706fc1eca556ceadf36cdc2fed09eb5719e880" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://stackoverflow.com/questions/22724883/js-deferred-promise-future-compared-to-functional-languages-like-scala&quot;&gt;this question on StackOverflow&lt;/a&gt; for more differences.</source>
          <target state="translated">その他の違い&lt;a href=&quot;http://stackoverflow.com/questions/22724883/js-deferred-promise-future-compared-to-functional-languages-like-scala&quot;&gt;については、StackOverflow&lt;/a&gt;でこの質問を参照してください。</target>
        </trans-unit>
        <trans-unit id="87f924e288cbca74d9deadff4feb3964dc20a0cb" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://stackoverflow.com/questions/26136389/how-can-i-realize-pattern-promise-deffered&quot;&gt;this question on StackOverflow&lt;/a&gt; for more differences.</source>
          <target state="translated">その他の違い&lt;a href=&quot;http://stackoverflow.com/questions/26136389/how-can-i-realize-pattern-promise-deffered&quot;&gt;については、StackOverflow&lt;/a&gt;でこの質問を参照してください。</target>
        </trans-unit>
        <trans-unit id="6b47ded2bd3e84b6a1d18b1f7005536f6c95a4c4" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;install&quot;&gt;installation&lt;/a&gt; on how to enable long stack traces in your environment.</source>
          <target state="translated">環境で長いスタックトレースを有効にする方法については、&lt;a href=&quot;install&quot;&gt;インストール&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="40938884818bf7e771e25611b0ecc72ecf13d826" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;install&quot;&gt;installation&lt;/a&gt; on how to enable warnings in your environment.</source>
          <target state="translated">ご使用の環境で警告を有効にする方法については、&lt;a href=&quot;install&quot;&gt;インストール&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="fd18968e9220ec2edbcb69219a62b308e07af8ca" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;new-in-bluebird-3&quot;&gt;New in 3.0&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;new-in-bluebird-3&quot;&gt;3.0の新機能を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a128fef004cd14934d7a35ae580447b292348acd" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;api/promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;api/promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="4c964d6768cfba0357dc178ad5c1c5b834096887" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="ec633a7c6034c365e8ffcaf57fd91b71d7eba69d" translate="yes" xml:space="preserve">
          <source>See if this &lt;code&gt;promise&lt;/code&gt; has been cancelled.</source>
          <target state="translated">この &lt;code&gt;promise&lt;/code&gt; がキャンセルされたかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="e2ba106a736de3c98da11dcab4e39f4c475860bf" translate="yes" xml:space="preserve">
          <source>See if this &lt;code&gt;promise&lt;/code&gt; is pending (not fulfilled or rejected or cancelled).</source>
          <target state="translated">この &lt;code&gt;promise&lt;/code&gt; が保留中であるかどうかを確認してください（履行されていない、拒否されている、キャンセルされていない）。</target>
        </trans-unit>
        <trans-unit id="43f5e31f9196af8cf21954e2abe72267402aeb61" translate="yes" xml:space="preserve">
          <source>See if this promise has been fulfilled.</source>
          <target state="translated">この約束が果たされたかどうかを確認してください。</target>
        </trans-unit>
        <trans-unit id="a4923f987cce26c1b5f0647eecfad58c0130790b" translate="yes" xml:space="preserve">
          <source>See if this promise has been rejected.</source>
          <target state="translated">この約束が拒否されたかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="00853e3a835e9b91810aba99eb34ee3eaa60c4cf" translate="yes" xml:space="preserve">
          <source>See the API on &lt;a href=&quot;api/synchronous-inspection&quot;&gt;&lt;code&gt;synchronous inspection&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">詳細については、&lt;a href=&quot;api/synchronous-inspection&quot;&gt; &lt;code&gt;synchronous inspection&lt;/code&gt; &lt;/a&gt;のAPIを参照してください。</target>
        </trans-unit>
        <trans-unit id="b6d3dd68401ad34ac91e21bd296d96dcc691d3a3" translate="yes" xml:space="preserve">
          <source>See the API page about &lt;a href=&quot;api/promise.longstacktraces&quot;&gt;&lt;code&gt;Promise.longStackTraces&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;api/promise.longstacktraces&quot;&gt; &lt;code&gt;Promise.longStackTraces&lt;/code&gt; &lt;/a&gt;に関するAPIページを参照してください</target>
        </trans-unit>
        <trans-unit id="32248b4544c4dacee860f46416e5a89b6310bc5c" translate="yes" xml:space="preserve">
          <source>Sequelize</source>
          <target state="translated">Sequelize</target>
        </trans-unit>
        <trans-unit id="0353c268d6003a0b1d6e372faa2ae4914cf1ab42" translate="yes" xml:space="preserve">
          <source>Sequelize already uses Bluebird promises internally and has promise returning APIs. Use those.</source>
          <target state="translated">Sequelize はすでに Bluebird のプロミスを内部で使用しており、プロミスを返す API を持っています。それらを使用します。</target>
        </trans-unit>
        <trans-unit id="0477fce5eb6ea953b269e6b50843ad48931e59dd" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;multiArgs&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; means the resulting promise will always fulfill with an array of the callback's success value(s). This is needed because promises only support a single success value while some callback API's have multiple success value. The default is to ignore all but the first success value of a callback function.</source>
          <target state="translated">&lt;code&gt;multiArgs&lt;/code&gt; を &lt;code&gt;true&lt;/code&gt; に設定すると、結果のpromiseは常にコールバックの成功値の配列で満たされます。一部のコールバックAPIには複数の成功値があるのに対し、Promiseは単一の成功値しかサポートしないため、これが必要です。デフォルトでは、コールバック関数の最初の成功値以外はすべて無視されます。</target>
        </trans-unit>
        <trans-unit id="9d87c38ef9cdbe40b70787a797d9e70b16e2a6cd" translate="yes" xml:space="preserve">
          <source>Setting a custom scheduler could be necessary when you need a faster way to schedule functions than bluebird does by default. It also makes bluebird possible to use in platforms where normal timing constructs like &lt;code&gt;setTimeout&lt;/code&gt; and &lt;code&gt;process.nextTick&lt;/code&gt; are not available (like Nashhorn).</source>
          <target state="translated">ブルーバードがデフォルトで行うよりも高速に機能をスケジュールする方法が必要な場合は、カスタムスケジューラの設定が必要になることがあります。また、Bluebirdは、 &lt;code&gt;setTimeout&lt;/code&gt; や &lt;code&gt;process.nextTick&lt;/code&gt; などの通常のタイミング構成が利用できないプラットフォーム（Nashhornなど）で使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="3932ebbf539f8a931c6f13cf255530da552644ed" translate="yes" xml:space="preserve">
          <source>Setting the environment variable &lt;code&gt;NODE_ENV&lt;/code&gt; to &lt;code&gt;&quot;development&quot;&lt;/code&gt; also automatically enables long stack traces.</source>
          <target state="translated">環境変数 &lt;code&gt;NODE_ENV&lt;/code&gt; を &lt;code&gt;&quot;development&quot;&lt;/code&gt; に設定すると、長いスタックトレースも自動的に有効になります。</target>
        </trans-unit>
        <trans-unit id="4742ee0d05bf00094d42512b9006ce355572faaf" translate="yes" xml:space="preserve">
          <source>Several examples of databases follow.</source>
          <target state="translated">データベースの例をいくつか挙げておきます。</target>
        </trans-unit>
        <trans-unit id="6e704260c9c34a30c1e1c6e9cc96dcbaba23b9e4" translate="yes" xml:space="preserve">
          <source>Several popular Android libraries use promises - for example the Parse Java API returns &lt;code&gt;Task&lt;/code&gt;s which are similar to JavaScript promises.</source>
          <target state="translated">いくつかの一般的なAndroidライブラリはプロミスを使用しています。たとえば、Parse Java APIはJavaScriptプロミスに似た &lt;code&gt;Task&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="79948cec8617f2b258642406e788e89df84d104b" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;.then(null, null, handler);&lt;/code&gt;. Attach a progress handler that will be called if this promise is progressed. Returns a new promise chained from this promise.</source>
          <target state="translated">速記用 &lt;code&gt;.then(null, null, handler);&lt;/code&gt; 。このpromiseが進行した場合に呼び出される進行ハンドラーをアタッチします。このプロミスからチェーンされた新しいプロミスを返します。</target>
        </trans-unit>
        <trans-unit id="d2d63e7d6731c58944766cb081aef40963e6cb50" translate="yes" xml:space="preserve">
          <source>Showing a live list of rejected promises</source>
          <target state="translated">拒否された約束のライブリストの表示</target>
        </trans-unit>
        <trans-unit id="8bbe005c943c12fa6ff0d2f8cafd5ad98bc70211" translate="yes" xml:space="preserve">
          <source>Signals that an operation has been aborted or cancelled. The default reason used by &lt;a href=&quot;cancel&quot;&gt;&lt;code&gt;.cancel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">操作が中止またはキャンセルされたことを通知します。&lt;a href=&quot;cancel&quot;&gt; &lt;code&gt;.cancel&lt;/code&gt; が&lt;/a&gt;使用するデフォルトの理由。</target>
        </trans-unit>
        <trans-unit id="299f23dc5dcc08c7bfee7c8ae781aacf85c196cb" translate="yes" xml:space="preserve">
          <source>Signals that an operation has timed out. Used as a custom cancellation reason in &lt;a href=&quot;timeout&quot;&gt;&lt;code&gt;.timeout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">操作がタイムアウトしたことを通知します。&lt;a href=&quot;timeout&quot;&gt; &lt;code&gt;.timeout&lt;/code&gt; で&lt;/a&gt;カスタムのキャンセル理由として使用されます。</target>
        </trans-unit>
        <trans-unit id="46bf40da88360ad7bbfcf32d9dd42056cd2f6ff3" translate="yes" xml:space="preserve">
          <source>Significantly improve parallel promise performance and memory usage (+50% faster, -50% less memory)</source>
          <target state="translated">パラレルプロミスのパフォーマンスとメモリ使用量を大幅に改善(+50%の高速化、-50%のメモリ削減</target>
        </trans-unit>
        <trans-unit id="d63c65ce4045c196a80e2036ef184d1e29767129" translate="yes" xml:space="preserve">
          <source>Significantly improve performance of foreign bluebird thenables</source>
          <target state="translated">外国産ブルーバードのセナブルの性能を大幅に向上させる</target>
        </trans-unit>
        <trans-unit id="730519283954b4569cc72648083ced3012f2475e" translate="yes" xml:space="preserve">
          <source>Similarly, with promises:</source>
          <target state="translated">同じように、約束事で。</target>
        </trans-unit>
        <trans-unit id="e16c84188a248cb435f2ade69bfef7f54bb36e8f" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;api/promise.all&quot;&gt;&lt;code&gt;Promise.all&lt;/code&gt;&lt;/a&gt; takes promises, it must also take jQuery deferreds, so the above can be shortened to:</source>
          <target state="translated">以来&lt;a href=&quot;api/promise.all&quot;&gt; &lt;code&gt;Promise.all&lt;/code&gt; が&lt;/a&gt;約束を取る上記に短縮することができますので、それはまた、jQueryのDeferredの作り方を取る必要があります。</target>
        </trans-unit>
        <trans-unit id="71d62301257a57ffc03da0d5c42ed2549e221316" translate="yes" xml:space="preserve">
          <source>Since all objects support having properties you might still wonder why exactly does it have to be an error object and not just any object. In addition to supporting properties, an equally important feature necessary for values that are automatically propagated is the stack trace property (&lt;code&gt;.stack&lt;/code&gt;). A stack trace allows you easily find where an error originated from as it gives the code's call stack - along with line numbers for reference in code files.</source>
          <target state="translated">すべてのオブジェクトがプロパティを持つことをサポートしているので、なぜそれが単なるオブジェクトではなく、エラーオブジェクトでなければならないのか疑問に思うかもしれません。プロパティのサポートに加えて、自動的に伝達される値に必要な同様に重要な機能は、スタックトレースプロパティ（ &lt;code&gt;.stack&lt;/code&gt; ）です。スタックトレースを使用すると、コードファイルの参照用の行番号とともに、コードのコールスタックが提供されるため、エラーの発生場所を簡単に見つけることができます。</target>
        </trans-unit>
        <trans-unit id="92d019d6c6f872eca710a5e9fe46091f1e234c2c" translate="yes" xml:space="preserve">
          <source>Since in bluebird &lt;a href=&quot;api/promisification&quot;&gt;&lt;code&gt;promisification&lt;/code&gt;&lt;/a&gt; is made trivial, you can get long stack traces all the time:</source>
          <target state="translated">ブルーバードでは&lt;a href=&quot;api/promisification&quot;&gt; &lt;code&gt;promisification&lt;/code&gt; &lt;/a&gt;が取るに足らないものになるため、常に長いスタックトレースを取得できます。</target>
        </trans-unit>
        <trans-unit id="fd8d850f23fc1a81c14cb9cdd8a5e00431fefc26" translate="yes" xml:space="preserve">
          <source>Since the array passed to waterfall is static (always the same 3 functions) a plain old promise chain is used:</source>
          <target state="translated">waterfall に渡される配列は静的なので(常に同じ 3 つの関数)、昔ながらのプロミスチェインが使用されます。</target>
        </trans-unit>
        <trans-unit id="ead75c8725f0a9530a5abc673013177ab974cfdf" translate="yes" xml:space="preserve">
          <source>Small performance improvements for all collection methods</source>
          <target state="translated">すべての収集方法でパフォーマンスの小幅な改善</target>
        </trans-unit>
        <trans-unit id="dc101ed1f69471502ee81d7871e2413721d60887" translate="yes" xml:space="preserve">
          <source>So how then could we represent a progress bar like dialog? Well the answer is to manage the progress through callbacks outside the promise API. Bluebird has since &lt;a href=&quot;deprecated-apis#progression&quot;&gt;deprecated the progression feature&lt;/a&gt; and offers an alternative which I hope to illustrate here.</source>
          <target state="translated">では、ダイアログのようなプログレスバーをどのように表すことができるでしょうか。答えは、promise APIの外部でコールバックを使用して進行状況を管理することです。Bluebirdはそれ以降&lt;a href=&quot;deprecated-apis#progression&quot;&gt;、プログレッション機能&lt;/a&gt;を非推奨にしており、ここで説明したい代替手段を提供しています。</target>
        </trans-unit>
        <trans-unit id="e1ae1ffa70bbe4990a8964de54d99ecd7b5fd6b5" translate="yes" xml:space="preserve">
          <source>So please write the same when using promises too:</source>
          <target state="translated">なので、プロミスを使うときも同じように書いてください。</target>
        </trans-unit>
        <trans-unit id="e0e6caa4611dfebbc5e6e21fabaf9c486084de89" translate="yes" xml:space="preserve">
          <source>Some examples of the above practice applied to some popular libraries:</source>
          <target state="translated">上記の実践例のいくつかは、いくつかの人気のあるライブラリに適用されています。</target>
        </trans-unit>
        <trans-unit id="328f2682f2d41aa9dcab87997132944918cfc2f4" translate="yes" xml:space="preserve">
          <source>Some nodebacks expect more than 1 success value but there is no mapping for this in the promise world. You may specify the option &lt;code&gt;spread&lt;/code&gt; to call the nodeback with multiple values when the fulfillment value is an array:</source>
          <target state="translated">一部のノードバックは複数の成功値を期待しますが、promiseの世界ではこれに対するマッピングはありません。フルフィルメント値が配列である場合、オプション &lt;code&gt;spread&lt;/code&gt; を指定して、複数の値でノードバックを呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="d38c75cc8957e65c44573a2e27f3885375d06448" translate="yes" xml:space="preserve">
          <source>Something missing from the above example is proper error handling. When it comes to promises it is a best practise to always &lt;em&gt;reject a promise with an Error&lt;/em&gt; and not with plain data such as an object, string, number, or null/undefined. The reasoning for this is promises are best used as a way to regain some of the syntax you have with the standard &lt;code&gt;try {} catch() {}&lt;/code&gt; blocks with asynchronous code.</source>
          <target state="translated">上記の例で欠けているのは、適切なエラー処理です。&lt;em&gt;promiseに関しては&lt;/em&gt;、オブジェクト、文字列、数値、null / undefinedなどのプレーンデータではなく&lt;em&gt;、&lt;/em&gt;常に&lt;em&gt;エラーでpromiseを拒否する&lt;/em&gt;ことがベストプラクティスです。この理由は、promiseは、非同期コードを使用して標準の &lt;code&gt;try {} catch() {}&lt;/code&gt; ブロックで使用する構文の一部を取り戻す方法として最適に使用されるためです。</target>
        </trans-unit>
        <trans-unit id="f5366b89baa9bf31993646740e57cd8f67859925" translate="yes" xml:space="preserve">
          <source>Sometimes we want to find out when a single one time event has finished. For example - a stream is done. For this we can use &lt;a href=&quot;api/new-promise&quot;&gt;&lt;code&gt;new Promise&lt;/code&gt;&lt;/a&gt;. Note that this option should be considered only if &lt;a href=&quot;#working-with-callback-apis-using-the-node-convention&quot;&gt;automatic conversion&lt;/a&gt; isn't possible.</source>
          <target state="translated">1つのワンタイムイベントがいつ終了したかを知りたい場合があります。たとえば、ストリームが行われます。これには、&lt;a href=&quot;api/new-promise&quot;&gt; &lt;code&gt;new Promise&lt;/code&gt; &lt;/a&gt;を使用できます。このオプションは、&lt;a href=&quot;#working-with-callback-apis-using-the-node-convention&quot;&gt;自動変換&lt;/a&gt;が不可能な場合にのみ検討してください。</target>
        </trans-unit>
        <trans-unit id="c0b9d85f33b2e758641f19550f5a9be3023ea242" translate="yes" xml:space="preserve">
          <source>Sometimes you have to work with APIs that are inconsistent and do not follow a common convention.</source>
          <target state="translated">時々、共通の規約に従わず、一貫性のないAPIで作業をしなければならないことがあります。</target>
        </trans-unit>
        <trans-unit id="47f7595fc4eaf9c4327785c6f28cc0a3cb93f37a" translate="yes" xml:space="preserve">
          <source>Sparse array holes are not skipped by collection methods but treated as existing elements with &lt;code&gt;undefined&lt;/code&gt; value</source>
          <target state="translated">スパース配列の穴はコレクションメソッドによってスキップされませんが、値が &lt;code&gt;undefined&lt;/code&gt; 既存の要素として扱われます</target>
        </trans-unit>
        <trans-unit id="334f0f329646de4898c801e89bc81110c62b9723" translate="yes" xml:space="preserve">
          <source>Start the chain of promises with &lt;code&gt;Promise.try&lt;/code&gt;. Any synchronous exceptions will be turned into rejections on the returned promise.</source>
          <target state="translated">&lt;code&gt;Promise.try&lt;/code&gt; で約束の連鎖を開始します。同期例外はすべて、返されたpromiseの拒否に変わります。</target>
        </trans-unit>
        <trans-unit id="7544908a62ca43e11724d7886c37028c419b528e" translate="yes" xml:space="preserve">
          <source>Starting from 2.7.0 all bluebird instances also fire rejection events globally so that applications can register one universal hook for them.</source>
          <target state="translated">2.7.0 からは、すべての bluebird インスタンスもグローバルに拒否イベントを発生させるようになり、アプリケーションが 1 つのユニバーサルフックを登録できるようになりました。</target>
        </trans-unit>
        <trans-unit id="3603ca6749bcc3136f65ac99d1a525e581f1708b" translate="yes" xml:space="preserve">
          <source>Stream libraries tend to serve a different purpose than promise libraries. Unlike promise libraries streams can represent multiple values.</source>
          <target state="translated">ストリームライブラリは、プロミスライブラリとは異なる目的を果たす傾向があります。プロミスライブラリとは異なり、ストリームは複数の値を表現することができます。</target>
        </trans-unit>
        <trans-unit id="9a8475ec2272fa6b1c6b05f2bd678210b89009cf" translate="yes" xml:space="preserve">
          <source>Such a constructor can be minimally created like so:</source>
          <target state="translated">このようなコンストラクタは、最小限このように作成することができます。</target>
        </trans-unit>
        <trans-unit id="d58681e9c8fb0c509a2cfc71f3a1d6ba692e9b25" translate="yes" xml:space="preserve">
          <source>Such policies could include:</source>
          <target state="translated">そのようなポリシーには、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="8f1919f0096a6b3087e18c842a5097f047b54d80" translate="yes" xml:space="preserve">
          <source>Such wrappers should be rare, if they're common for the reason that the promise library cannot generically promisify them, you should file an issue.</source>
          <target state="translated">このようなラッパーは稀なものであるべきですが、もしプロミスライブラリが一般的にプロミスできないという理由で一般的なものであるならば、問題を提起してください。</target>
        </trans-unit>
        <trans-unit id="0158596539b88e3d14cfe51fe82aba75fca71681" translate="yes" xml:space="preserve">
          <source>Summary of breaking changes</source>
          <target state="translated">ブレイキングの変更点まとめ</target>
        </trans-unit>
        <trans-unit id="c1e51f0164b5bdc44f9880dc21c2988e1430f473" translate="yes" xml:space="preserve">
          <source>Support primitives in catch filters</source>
          <target state="translated">キャッチフィルターのプリミティブをサポート</target>
        </trans-unit>
        <trans-unit id="34c6c2ddc426343eed559ce47d4c777df69eba0c" translate="yes" xml:space="preserve">
          <source>Supported platforms</source>
          <target state="translated">サポートされているプラットフォーム</target>
        </trans-unit>
        <trans-unit id="f02259e275f481a7fdda40736a24df99f0cd3a67" translate="yes" xml:space="preserve">
          <source>Surfacing unhandled errors</source>
          <target state="translated">ハンドリングされていないエラーの浮上</target>
        </trans-unit>
        <trans-unit id="a3f9e4820c3b2f7bbea724b622595d004feda9b4" translate="yes" xml:space="preserve">
          <source>Swallowing all errors (challenge your debugging skills)</source>
          <target state="translated">すべてのエラーを飲み込む(デバッグスキルに挑戦</target>
        </trans-unit>
        <trans-unit id="9d4e83066087dd1079c656c148313dafa0d0a48a" translate="yes" xml:space="preserve">
          <source>Synchronous inspection</source>
          <target state="translated">同期検査</target>
        </trans-unit>
        <trans-unit id="560cd166df807614aa93c9f2544b674451945594" translate="yes" xml:space="preserve">
          <source>Synchronous inspection allows you to retrieve the fulfillment value of an already fulfilled promise or the rejection reason of an already rejected promise synchronously.</source>
          <target state="translated">同期検査では、すでに履行された約束の履行値や、すでに拒否された約束の拒否理由を同期的に取得することができます。</target>
        </trans-unit>
        <trans-unit id="3f22a0a957f0468c0084e1e9ae07dd450cc45ad2" translate="yes" xml:space="preserve">
          <source>That is, you can return either a promise &lt;em&gt;or a plain value&lt;/em&gt; from a &lt;code&gt;then&lt;/code&gt; without wrapping it.</source>
          <target state="translated">つまり、 &lt;code&gt;then&lt;/code&gt; をラップせずにthenからpromise &lt;em&gt;またはplain値&lt;/em&gt;を返すことができます。</target>
        </trans-unit>
        <trans-unit id="34bb1fab188a923aeae77d6108a07ce0c4ce134b" translate="yes" xml:space="preserve">
          <source>That means &lt;code&gt;value&lt;/code&gt; is bound at the time of calling &lt;a href=&quot;return&quot;&gt;&lt;code&gt;.return&lt;/code&gt;&lt;/a&gt; so this will not work as expected:</source>
          <target state="translated">つまり、 &lt;code&gt;value&lt;/code&gt; は&lt;a href=&quot;return&quot;&gt; &lt;code&gt;.return&lt;/code&gt; &lt;/a&gt;の呼び出し時にバインドされるため、これは期待どおりに機能しません。</target>
        </trans-unit>
        <trans-unit id="6e5c6863d3d57d6db5e4a2e948905db8b10466ee" translate="yes" xml:space="preserve">
          <source>That means when you have a problem there probably isn't an existing function tailored exactly to that problem but instead you can just combine the existing utilities to arrive at a solution. The upside of this is that you don't need to come up with all these different functions to solve problems that are not that different from each other. The most important thing to do when migrating from async to bluebird is this profound shift in philosophy.</source>
          <target state="translated">つまり、問題が発生したときに、その問題に正確に対応した既存の関数は存在しないかもしれませんが、その代わりに既存のユーティリティを組み合わせて解決策にたどり着くことができるのです。この利点は、問題を解決するためにこれらの異なる関数を開発する必要がないということです。async から bluebird への移行で最も重要なことは、この哲学の深遠なシフトです。</target>
        </trans-unit>
        <trans-unit id="c31fbbf769a579d258b6c345c7359a66afd6aa22" translate="yes" xml:space="preserve">
          <source>That said, if you have code written using jQuery deferred methods, such as &lt;code&gt;.then&lt;/code&gt;, &lt;code&gt;.done&lt;/code&gt; and so on, you cannot drop-in replace the jQuery deferred with a bluebird promise in that code. Despite having the same names, jQuery deferred methods have different semantics than bluebird promise methods. These differences are due to the completely different goals of the implementations. Bluebird is &lt;a href=&quot;http://en.wikipedia.org/wiki/Domain-specific_language&quot;&gt;an internal DSL&lt;/a&gt; for the domain of asynchronous control flow while jQuery deferreds are a callback aggregator utility (&quot;glorified event emitters&quot;).</source>
          <target state="translated">とは言っても、 &lt;code&gt;.then&lt;/code&gt; 、 &lt;code&gt;.done&lt;/code&gt; などのjQuery遅延メソッドを使用して記述されたコードがある場合、そのコードで、遅延されたjQueryをBluebird promiseで置き換えることはできません。名前は同じですが、jQuery遅延メソッドは、bluebird promiseメソッドとは異なるセマンティクスを持っています。これらの違いは、実装の完全に異なる目標によるものです。 Bluebirdは非同期制御フローのドメインの&lt;a href=&quot;http://en.wikipedia.org/wiki/Domain-specific_language&quot;&gt;内部DSL&lt;/a&gt;であり、jQuery遅延はコールバックアグリゲーターユーティリティ（「Glorifiedイベントエミッター」）です。</target>
        </trans-unit>
        <trans-unit id="9576ae41ed6c2fc691cc3233977df2602674a9e5" translate="yes" xml:space="preserve">
          <source>The &quot;a promise was created in a handler but not returned from it&quot; warning now adds the bluebird API method used to create the non-returned promise at the top of the warning stack</source>
          <target state="translated">a promise was created in handler but not returned from it」という警告は、警告スタックの一番上に、返されなかったプロミスを作成するために使用された bluebird API メソッドを追加するようになりました。</target>
        </trans-unit>
        <trans-unit id="2387bf8a5eec038b8dc1d6a136dd30eb885c69f6" translate="yes" xml:space="preserve">
          <source>The &quot;a promise was created in a handler but not returned from it&quot; warning now highlights the file, line and column where the return statement is missing.</source>
          <target state="translated">ハンドラでプロミスが作成されたが、そこから返されなかった」という警告が、リターン文が見つからないファイル、行、列を強調表示するようになりました。</target>
        </trans-unit>
        <trans-unit id="9172632794382321ca96b52eb375dcf229573bb4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;reflect&quot;&gt;&lt;code&gt;.reflect&lt;/code&gt;&lt;/a&gt; method returns a promise that is always successful when this promise is settled. Its fulfillment value is an object that implements the &lt;a href=&quot;promiseinspection&quot;&gt;&lt;code&gt;PromiseInspection&lt;/code&gt;&lt;/a&gt; interface and reflects the resolution of this promise.</source>
          <target state="translated">&lt;a href=&quot;reflect&quot;&gt; &lt;code&gt;.reflect&lt;/code&gt; &lt;/a&gt;方法は、この約束が決済されたときに、常に成功する約束を返します。そのフルフィルメント値は、&lt;a href=&quot;promiseinspection&quot;&gt; &lt;code&gt;PromiseInspection&lt;/code&gt; &lt;/a&gt;インターフェースを実装し、このプロミスの解決を反映するオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="dcc5097b492ec34ac1dac37541df7fa6d5523657" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.props&lt;/code&gt; method expects to receive an object.</source>
          <target state="translated">&lt;code&gt;.props&lt;/code&gt; メソッドがオブジェクトを受信することを期待します。</target>
        </trans-unit>
        <trans-unit id="b0eb698af924dfb32cf54d281b02888c506ead09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.then(success, fail)&lt;/code&gt; anti-pattern</source>
          <target state="translated">&lt;code&gt;.then(success, fail)&lt;/code&gt; アンチパターン</target>
        </trans-unit>
        <trans-unit id="0fcdb3492bd1cc7aa9ff1b548b88ce52afafa5d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.then&lt;/code&gt; signature is mostly about interop, there is &lt;em&gt;almost&lt;/em&gt; never a reason to use &lt;code&gt;.then(success, fail)&lt;/code&gt; in application code. It is even awkward to express it in the sync parallel:</source>
          <target state="translated">&lt;code&gt;.then&lt;/code&gt; 署名はありません、ほとんど相互運用についてです&lt;em&gt;ほとんど&lt;/em&gt;使用する理由決して &lt;code&gt;.then(success, fail)&lt;/code&gt; アプリケーションコードでは。同期並列でそれを表現するのはさらに厄介です：</target>
        </trans-unit>
        <trans-unit id="e944db85ee16051290ad72f2026b7a41fb2a4813" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;map&lt;/code&gt; operation is expecting an array here (or a promise on one) and instead gets the number &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; の操作は、ここでは、アレイ（または1つの約束を）期待して、代わりに番号を取得される &lt;code&gt;5&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f752091c174b33d9da17500cd7d1d3ae7eb2bd9" translate="yes" xml:space="preserve">
          <source>The Explicit Construction Anti-Pattern</source>
          <target state="translated">明示的な建設アンチパターン</target>
        </trans-unit>
        <trans-unit id="7ae99b6910e577d7be696210c2dbfc212e81ffa5" translate="yes" xml:space="preserve">
          <source>The JavaScript is the same as the &lt;code&gt;PromptDialog&lt;/code&gt; only we will add a &lt;code&gt;setProgress()&lt;/code&gt; method:</source>
          <target state="translated">JavaScriptは、 &lt;code&gt;PromptDialog&lt;/code&gt; と同じですが、 &lt;code&gt;setProgress()&lt;/code&gt; メソッドを追加します。</target>
        </trans-unit>
        <trans-unit id="987db8ad0cd3c6e2880ebfda0417324d809a8643" translate="yes" xml:space="preserve">
          <source>The above calls the function &lt;code&gt;processImage()&lt;/code&gt;&lt;em&gt;immediately&lt;/em&gt; and passes the result to &lt;a href=&quot;api/then&quot;&gt;&lt;code&gt;.then()&lt;/code&gt;&lt;/a&gt; (which is most likely &lt;code&gt;undefined&lt;/code&gt; - the default return value when a function doesn't return anything).</source>
          <target state="translated">上記は関数 &lt;code&gt;processImage()&lt;/code&gt; を&lt;em&gt;すぐに&lt;/em&gt;呼び出し、結果を&lt;a href=&quot;api/then&quot;&gt; &lt;code&gt;.then()&lt;/code&gt; に&lt;/a&gt;渡します（これはおそらく &lt;code&gt;undefined&lt;/code&gt; -関数が何も返さない場合のデフォルトの戻り値）。</target>
        </trans-unit>
        <trans-unit id="1c5b45d618d205b79bdd2339e1eb511e0597ceee" translate="yes" xml:space="preserve">
          <source>The above can also be written as (with a caveat, see below)</source>
          <target state="translated">上記のようにも書くことができます(注意書きあり。</target>
        </trans-unit>
        <trans-unit id="b9d96d94c20e29d7be811aad09d5f2fc69d847ac" translate="yes" xml:space="preserve">
          <source>The above does a &lt;code&gt;console.log&lt;/code&gt; of &lt;code&gt;my-element&lt;/code&gt;. Doing it this way is necessary because neither of the methods (&lt;code&gt;getElementById&lt;/code&gt;, &lt;code&gt;console.log&lt;/code&gt;) can be called as stand-alone methods.</source>
          <target state="translated">上記は &lt;code&gt;my-element&lt;/code&gt; の &lt;code&gt;console.log&lt;/code&gt; を実行します。どちらのメソッド（ &lt;code&gt;getElementById&lt;/code&gt; 、 &lt;code&gt;console.log&lt;/code&gt; ）もスタンドアロンメソッドとして呼び出すことができないため、このようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="4ff51746636ecc3655cfcaa3b14edb8e79b82038" translate="yes" xml:space="preserve">
          <source>The above ensures &lt;code&gt;getConnection&lt;/code&gt; fulfills the contract of a promise-returning function of never throwing a synchronous exception. Also see &lt;a href=&quot;promise.try&quot;&gt;&lt;code&gt;Promise.try&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;promise.method&quot;&gt;&lt;code&gt;Promise.method&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">上記は、 &lt;code&gt;getConnection&lt;/code&gt; が同期例外をスローしないという約束を返す関数の規約を確実に満たすようにします。&lt;a href=&quot;promise.try&quot;&gt; &lt;code&gt;Promise.try&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;promise.method&quot;&gt; &lt;code&gt;Promise.method&lt;/code&gt; &lt;/a&gt;も参照してください</target>
        </trans-unit>
        <trans-unit id="ec563887821c925f0b9a15bbaeb4d94ba4967bb9" translate="yes" xml:space="preserve">
          <source>The above function can then make everyone happy.</source>
          <target state="translated">そうすれば、上記の機能でみんなを幸せにすることができます。</target>
        </trans-unit>
        <trans-unit id="cb5a0fcd51c35945773869b7451e685e33fe2b5b" translate="yes" xml:space="preserve">
          <source>The above has a direct translation:</source>
          <target state="translated">上記には直訳があります。</target>
        </trans-unit>
        <trans-unit id="be3a5d7ac08554519f84fa1292d020a1294faf0a" translate="yes" xml:space="preserve">
          <source>The above without &lt;a href=&quot;bind&quot;&gt;&lt;code&gt;.bind&lt;/code&gt;&lt;/a&gt; could be achieved with:</source>
          <target state="translated">&lt;a href=&quot;bind&quot;&gt; &lt;code&gt;.bind&lt;/code&gt; &lt;/a&gt;なしの上記は、次のようにして実現できます。</target>
        </trans-unit>
        <trans-unit id="a6770726e6458fe58ea6b5f4fd62bd9042424df5" translate="yes" xml:space="preserve">
          <source>The actual subscription API depends on the environment.</source>
          <target state="translated">実際のサブスクリプションAPIは環境に依存します。</target>
        </trans-unit>
        <trans-unit id="f16cc25950a83115317503e4adef79079d08a456" translate="yes" xml:space="preserve">
          <source>The advantage of using &lt;code&gt;.suppressUnhandledRejections()&lt;/code&gt; over &lt;code&gt;.catch(function(){})&lt;/code&gt; is that it doesn't increment the branch count of the promise. Branch counts matter when using cancellation because a promise will only be cancelled if all of its branches want to cancel it.</source>
          <target state="translated">使用しての利点 &lt;code&gt;.suppressUnhandledRejections()&lt;/code&gt; オーバー &lt;code&gt;.catch(function(){})&lt;/code&gt; 、それは約束の分岐カウントをインクリメントしないということです。キャンセルを使用する場合、ブランチの数は重要です。プロミスは、すべてのブランチがキャンセルしたい場合にのみキャンセルされるためです。</target>
        </trans-unit>
        <trans-unit id="9c56f54fb10413e626d1f27ae289fc09dbb6d933" translate="yes" xml:space="preserve">
          <source>The advantages of the new cancellation compared to the old cancellation are:</source>
          <target state="translated">旧解約と比較した場合の新解約のメリットは、以下の通りです。</target>
        </trans-unit>
        <trans-unit id="f38af64a279ce9559ab9430fe352d1985725b5b6" translate="yes" xml:space="preserve">
          <source>The cancellation feature is &lt;strong&gt;by default turned off&lt;/strong&gt;, you can enable it using &lt;a href=&quot;promise.config&quot;&gt;&lt;code&gt;Promise.config&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">キャンセル機能は&lt;strong&gt;デフォルトでオフ&lt;/strong&gt;になっていますが、&lt;a href=&quot;promise.config&quot;&gt; &lt;code&gt;Promise.config&lt;/code&gt; &lt;/a&gt;を使用して有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="6200a8a72cc85fe3cd189630a2f941b849b20c71" translate="yes" xml:space="preserve">
          <source>The concurrency limit applies to Promises returned by the mapper function and it basically limits the number of Promises created. For example, if &lt;code&gt;concurrency&lt;/code&gt; is &lt;code&gt;3&lt;/code&gt; and the mapper callback has been called enough so that there are three returned Promises currently pending, no further callbacks are called until one of the pending Promises resolves. So the mapper function will be called three times and it will be called again only after at least one of the Promises resolves.</source>
          <target state="translated">同時実行制限はマッパー関数によって返されるPromiseに適用され、基本的には作成されるPromiseの数を制限します。たとえば、 &lt;code&gt;concurrency&lt;/code&gt; が &lt;code&gt;3&lt;/code&gt; で、マッパーコールバックが十分に呼び出され、現在保留中の3つのPromiseが返される場合、保留中のPromiseの1つが解決されるまで、それ以上のコールバックは呼び出されません。したがって、マッパー関数は3回呼び出され、Promiseの少なくとも1つが解決された後にのみ再度呼び出されます。</target>
        </trans-unit>
        <trans-unit id="a9dfc798d7155c42f102e1690ecdc5d11f1eed13" translate="yes" xml:space="preserve">
          <source>The current element of the iteration is a &lt;em&gt;pending&lt;/em&gt; promise, that promise will be awaited before running the iterator.</source>
          <target state="translated">反復の現在の要素は&lt;em&gt;保留中の&lt;/em&gt;promiseであり、そのpromiseはイテレーターを実行する前に&lt;em&gt;待機され&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="e4676232a799b417212732864ed73ce3337f094d" translate="yes" xml:space="preserve">
          <source>The current element of the iteration is a &lt;em&gt;pending&lt;/em&gt; promise, that promise will be awaited before running the mapper.</source>
          <target state="translated">反復の現在の要素は&lt;em&gt;保留中の&lt;/em&gt;promiseであり、そのpromiseはマッパーを実行する前に&lt;em&gt;待機&lt;/em&gt;されます。</target>
        </trans-unit>
        <trans-unit id="7901af52e1d3bb0c5159bcb56902f980986ef864" translate="yes" xml:space="preserve">
          <source>The current element of the iteration is a &lt;em&gt;rejected&lt;/em&gt; promise, the iteration will stop and be rejected as well (with the same reason).</source>
          <target state="translated">反復の現在の要素は&lt;em&gt;拒否された&lt;/em&gt;プロミスです。反復は停止し、同様に拒否されます（同じ理由で）。</target>
        </trans-unit>
        <trans-unit id="31ab830fa32b91594137493c8717fb7b7a2afbf7" translate="yes" xml:space="preserve">
          <source>The default approach of bluebird is to immediately log the stack trace when there is an unhandled rejection. This is similar to how uncaught exceptions cause the stack trace to be logged so that you have something to work with when something is not working as expected.</source>
          <target state="translated">bluebird のデフォルトのアプローチは、処理されていない拒絶があったときにすぐにスタックトレースをログに記録することです。これは、捕捉されていない例外がスタックトレースをログに記録するのと似ているので、何かが期待通りに動作していないときに何かを利用することができます。</target>
        </trans-unit>
        <trans-unit id="79301b912f99cabfc6b1d506271ff79825a49941" translate="yes" xml:space="preserve">
          <source>The default filter function will ignore properties that start with a leading underscore, properties that are not valid JavaScript identifiers and constructor functions (function which have enumerable properties in their &lt;code&gt;.prototype&lt;/code&gt;).</source>
          <target state="translated">デフォルトのフィルター関数は、先頭のアンダースコアで始まるプロパティ、有効なJavaScript識別子ではないプロパティ、およびコンストラクター関数（ &lt;code&gt;.prototype&lt;/code&gt; に列挙可能なプロパティを持つ関数）を無視します。</target>
        </trans-unit>
        <trans-unit id="fb7c7d829660ad1b607e4ff44a0e6cb994eacdf1" translate="yes" xml:space="preserve">
          <source>The dialog interface might look like this:</source>
          <target state="translated">ダイアログのインターフェイスは次のようになります。</target>
        </trans-unit>
        <trans-unit id="2ec7326b7197ff7aa9ec6904e534048cbee04708" translate="yes" xml:space="preserve">
          <source>The difference between a &lt;code&gt;Task&lt;/code&gt; and a promise are that a task might not be started and might require a &lt;code&gt;.Start&lt;/code&gt; call where a promise always represents an already started operation.</source>
          <target state="translated">&lt;code&gt;Task&lt;/code&gt; とpromise の違いは、タスクが開始されない可能性があり、 &lt;code&gt;.Start&lt;/code&gt; 呼び出しが必要になる可能性があることです。ここで、promiseは常にすでに開始された操作を表します。</target>
        </trans-unit>
        <trans-unit id="801933290ac764cce3fee90e0b881f138a330a0e" translate="yes" xml:space="preserve">
          <source>The entire prototype chain of the object is promisified on the object. Only enumerable are considered. If the object already has a promisified version of the method, it will be skipped. The target methods are assumed to conform to node.js callback convention of accepting a callback as last argument and calling that callback with error as the first argument and success value on the second argument. If the node method calls its callback with multiple success values, the fulfillment value will be an array of them.</source>
          <target state="translated">オブジェクトのプロトタイプチェーン全体がオブジェクト上でプロミスされます。列挙可能なものだけが考慮されます。オブジェクトに既にプロミスされたバージョンのメソッドがある場合は、そのメソッドはスキップされます。ターゲットメソッドは、最終引数としてコールバックを受け入れ、第1引数にエラー、第2引数に成功値を指定してそのコールバックを呼び出すというnode.jsのコールバック規約に準拠していることが前提となります。nodeメソッドが複数の成功値を持つコールバックを呼び出す場合、達成値はそれらの配列になります。</target>
        </trans-unit>
        <trans-unit id="d6be4df893a1137d6b3ab84348ff99be431c883e" translate="yes" xml:space="preserve">
          <source>The explicit construction anti-pattern</source>
          <target state="translated">明示的な構造のアンチパターン</target>
        </trans-unit>
        <trans-unit id="40e45891046aa649e068bb199da2efeaca661dda" translate="yes" xml:space="preserve">
          <source>The following lifecycle events are available:</source>
          <target state="translated">以下のようなライフサイクルイベントがあります。</target>
        </trans-unit>
        <trans-unit id="b55e86c0fc753c356970890234eaa0b0ce6daee6" translate="yes" xml:space="preserve">
          <source>The function being called expects a Promise, but is given something different. There are two main reasons why this may occur.</source>
          <target state="translated">呼び出される関数はPromiseを期待していますが、それとは異なるものが与えられています。これが発生する主な理由は2つあります。</target>
        </trans-unit>
        <trans-unit id="0fa7caae49fcd453bbf69746e24b32d9fbb6ba35" translate="yes" xml:space="preserve">
          <source>The generic promisification is likely to be faster because it can use internals directly but also handles edge cases like &lt;code&gt;libraryFunction&lt;/code&gt; throwing synchronously or using multiple success values.</source>
          <target state="translated">一般的な約束は、内部を直接使用できるだけでなく、 &lt;code&gt;libraryFunction&lt;/code&gt; が同期してスローしたり、複数の成功値を使用したりといったエッジケースも処理できるため、より高速になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="7b2748080c6d9715db0ad2710e45478c0f7c5d34" translate="yes" xml:space="preserve">
          <source>The global events are:</source>
          <target state="translated">世界的なイベントです。</target>
        </trans-unit>
        <trans-unit id="ac6f6a9e8f68d43e290c78abcefdf4dfcc31bc80" translate="yes" xml:space="preserve">
          <source>The handler functions are now closures, thus less efficient and not reusable</source>
          <target state="translated">ハンドラ関数がクロージャになったため、効率が悪く、再利用できません。</target>
        </trans-unit>
        <trans-unit id="578ba1114aa6fcded1f091d1702ddf63eaf4722c" translate="yes" xml:space="preserve">
          <source>The implementations for this benchmark are found in &lt;a href=&quot;https://github.com/petkaantonov/bluebird/tree/master/benchmark/doxbee-sequential&quot;&gt;&lt;code&gt;benchmark/doxbee-sequential&lt;/code&gt;&lt;/a&gt; directory.</source>
          <target state="translated">このベンチマークの実装は、&lt;a href=&quot;https://github.com/petkaantonov/bluebird/tree/master/benchmark/doxbee-sequential&quot;&gt; &lt;code&gt;benchmark/doxbee-sequential&lt;/code&gt; &lt;/a&gt;ディレクトリにあります。</target>
        </trans-unit>
        <trans-unit id="2beec3e3018a687405477c67e8972c8a6a40dae3" translate="yes" xml:space="preserve">
          <source>The implementations for this benchmark are found in &lt;a href=&quot;https://github.com/petkaantonov/bluebird/tree/master/benchmark/madeup-parallel&quot;&gt;&lt;code&gt;benchmark/madeup-parallel&lt;/code&gt;&lt;/a&gt; directory.</source>
          <target state="translated">このベンチマークの実装は、&lt;a href=&quot;https://github.com/petkaantonov/bluebird/tree/master/benchmark/madeup-parallel&quot;&gt; &lt;code&gt;benchmark/madeup-parallel&lt;/code&gt; &lt;/a&gt;ディレクトリにあります。</target>
        </trans-unit>
        <trans-unit id="5ab9ea41bf2d998f0ea876fa3d95827572dbbe3d" translate="yes" xml:space="preserve">
          <source>The iterator returns a promise or a thenable, it is awaited before continuing to the next iteration.</source>
          <target state="translated">イテレータはプロミスまたはshenableを返し、次のイテレーションに進む前に待機します。</target>
        </trans-unit>
        <trans-unit id="9448500cacb1ff64a30efd5b0e2bea57a588d796" translate="yes" xml:space="preserve">
          <source>The mapper function for a given item is called as soon as possible, that is, when the promise for that item's index in the input array is fulfilled. This doesn't mean that the result array has items in random order, it means that &lt;code&gt;.map&lt;/code&gt; can be used for concurrency coordination unlike &lt;code&gt;.all&lt;/code&gt;.</source>
          <target state="translated">特定のアイテムのマッパー関数は、できるだけ早く、つまり、入力配列内のそのアイテムのインデックスのpromiseが満たされたときに呼び出されます。これは、結果の配列にランダムな順序で項目があることを意味するのではなく、 &lt;code&gt;.all&lt;/code&gt; とは異なり、 &lt;code&gt;.map&lt;/code&gt; を同時実行性の調整に使用できることを意味します。</target>
        </trans-unit>
        <trans-unit id="575b00766f4d58c35e179c44f5a23cda579eb7ad" translate="yes" xml:space="preserve">
          <source>The mapper returns a promise or a thenable, it is awaited before continuing to the next iteration.</source>
          <target state="translated">マッパーは、次の反復に進む前に、プロミスまたはそれに続く可能性を返します。</target>
        </trans-unit>
        <trans-unit id="6416948697e16aeabbf92ec68782960804a2782d" translate="yes" xml:space="preserve">
          <source>The methods of a &lt;code&gt;PromiseResolver&lt;/code&gt; have no effect if the fate of the underlying promise is already decided (follow, reject, fulfill).</source>
          <target state="translated">基本となるプロミスの運命がすでに決定されている場合（フォロー、リジェクト、 &lt;code&gt;PromiseResolver&lt;/code&gt; ）、PromiseResolverのメソッドは効果がありません。</target>
        </trans-unit>
        <trans-unit id="666da53e9ba5fafe397413f91312c555ed1b2845" translate="yes" xml:space="preserve">
          <source>The mortals that can handle it may now release Zalgo by &lt;code&gt;require(&quot;bluebird/zalgo&quot;);&lt;/code&gt;</source>
          <target state="translated">これを扱える人間は &lt;code&gt;require(&quot;bluebird/zalgo&quot;);&lt;/code&gt; でZalgoをリリースするかもしれません。</target>
        </trans-unit>
        <trans-unit id="788c3f097a42e7ff06bdab38fdaf7df400494dfe" translate="yes" xml:space="preserve">
          <source>The new cancellation has &quot;don't care&quot; semantics while the old cancellation had abort semantics. Cancelling a promise simply means that its handler callbacks will not be called.</source>
          <target state="translated">新しいキャンセルは &quot;don't care&quot; のセマンティクスを持っていますが、古いキャンセルはアボートのセマンティクスを持っていました。プロミスをキャンセルするということは、単にそのハンドラのコールバックが呼ばれないことを意味します。</target>
        </trans-unit>
        <trans-unit id="9a98aedc50b84c7ebb0badc2de651f3ecf8937b9" translate="yes" xml:space="preserve">
          <source>The object predicate passed to &lt;code&gt;.catch&lt;/code&gt; in the above code (&lt;code&gt;{code: 'ENOENT'}&lt;/code&gt;) is shorthand for a predicate function &lt;code&gt;function predicate(e) { return isObject(e) &amp;amp;&amp;amp; e.code == 'ENOENT' }&lt;/code&gt;, I.E. loose equality is used.</source>
          <target state="translated">上記のコード（ &lt;code&gt;{code: 'ENOENT'}&lt;/code&gt; ）で &lt;code&gt;.catch&lt;/code&gt; に渡されたオブジェクト述語は、述語関数 &lt;code&gt;function predicate(e) { return isObject(e) &amp;amp;&amp;amp; e.code == 'ENOENT' }&lt;/code&gt; 、IEルーズの省略形です平等が使用されます。</target>
        </trans-unit>
        <trans-unit id="25c421b7ad33c6aa4c4ac1a5b06c22ec76d37875" translate="yes" xml:space="preserve">
          <source>The old progression API was meant to be used for tracking the progress of promise resolution. In retrospect, it did not work or compose very well. We understand that problem better now and the use case could be better solved without it.</source>
          <target state="translated">古いプログレッションAPIは、プロミス解決の進捗状況を追跡するために使用されることを意図していました。振り返ってみると、それは非常にうまく機能していませんでしたし、構成もよくありませんでした。今ではその問題をよりよく理解しており、ユースケースはそれなしでよりよく解決できました。</target>
        </trans-unit>
        <trans-unit id="090f1f6fbdfbd7a3e0db64396e47bb24d64eb73a" translate="yes" xml:space="preserve">
          <source>The order &lt;code&gt;map&lt;/code&gt; calls the mapper function on the array elements is not specified, there is no guarantee on the order in which it'll execute the &lt;code&gt;map&lt;/code&gt;er on the elements. For order guarantee in sequential execution - see &lt;a href=&quot;promise.mapseries&quot;&gt;&lt;code&gt;Promise.mapSeries&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">注文の &lt;code&gt;map&lt;/code&gt; 配列要素にマッパー関数を呼び出し、指定されていない、それが実行でしょう順序に保証はありません &lt;code&gt;map&lt;/code&gt; 要素にerが。順次実行の順序保証については、&lt;a href=&quot;promise.mapseries&quot;&gt; &lt;code&gt;Promise.mapSeries&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="22323bb03a1bb54a462c5535aaf1a55e597ca564" translate="yes" xml:space="preserve">
          <source>The problem with the above is that &lt;code&gt;getConnection&lt;/code&gt; itself might throw for some reason and if it does we'll get a synchronous rejection. An asynchronous operation should always be asynchronous to prevent double guarding and race conditions so it's best to always put the sync parts inside the promise constructor as such:</source>
          <target state="translated">上記の問題は、何らかの理由で &lt;code&gt;getConnection&lt;/code&gt; 自体がスローする可能性があることです。スローすると、同期的に拒否されます。非同期操作は、二重の保護と競合状態を防ぐために常に非同期である必要があります。そのため、同期パーツは常に次のようにpromiseコンストラクター内に配置することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="5b81307bb00a714d49523b7e191e0b6160f8ce58" translate="yes" xml:space="preserve">
          <source>The promisifier gets a reference to the original method and should return a function which returns a promise.</source>
          <target state="translated">promisifierは元のメソッドへの参照を取得し、プロミスを返す関数を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="1a87fc5ef703ad3003e186be301223055a0f1187" translate="yes" xml:space="preserve">
          <source>The resolver function is passed a callback that expects to be called back according to error-first node conventions.</source>
          <target state="translated">リゾルバ関数には、エラー・ファースト・ノードの規約に従ってコールバックされることを期待するコールバックが渡されます。</target>
        </trans-unit>
        <trans-unit id="db5aac58e5c09043c491849101f61a81a5b4d12d" translate="yes" xml:space="preserve">
          <source>The resolver is called synchronously (the following is for documentation purposes and not idiomatic code):</source>
          <target state="translated">リゾルバは同期的に呼び出されます(以下は文書化のためのものであり、慣用的なコードではありません)。</target>
        </trans-unit>
        <trans-unit id="fa4bfc9835f1db3d068610dc3f23387d9b6dbcae" translate="yes" xml:space="preserve">
          <source>The same can also be written more concisely with &lt;code&gt;Function.prototype.bind&lt;/code&gt;:</source>
          <target state="translated">同じことを &lt;code&gt;Function.prototype.bind&lt;/code&gt; でより簡潔に書くこともできます：</target>
        </trans-unit>
        <trans-unit id="e4d032a40184c01ff45a4fcd6a47f5f6ed12cc2d" translate="yes" xml:space="preserve">
          <source>The same thing can be done with less code using jQuery's &lt;a href=&quot;https://api.jquery.com/on/#event-names&quot;&gt;event namespacing&lt;/a&gt;.</source>
          <target state="translated">jQueryの&lt;a href=&quot;https://api.jquery.com/on/#event-names&quot;&gt;イベント名前空間&lt;/a&gt;を使用すると、同じことを少ないコードで行うことができます。</target>
        </trans-unit>
        <trans-unit id="3c2a20abb7e468fc73f206d7f17b3365726ea73c" translate="yes" xml:space="preserve">
          <source>The second argument passed to a disposer is the result promise of the using block, which you can inspect synchronously.</source>
          <target state="translated">ディスポーザに渡される第二引数は、使用中のブロックの結果のプロミスで、同期的に検査することができます。</target>
        </trans-unit>
        <trans-unit id="7e1062ee61728ebe80f9bce80f90c97c30f5a642" translate="yes" xml:space="preserve">
          <source>The situation can be fixed with &lt;code&gt;.finally&lt;/code&gt;:</source>
          <target state="translated">状況は &lt;code&gt;.finally&lt;/code&gt; で修正できます：</target>
        </trans-unit>
        <trans-unit id="d8cfd5d14e8e321897ce3ab8e2b61c1f01768a60" translate="yes" xml:space="preserve">
          <source>The solution is to either convert it to a promise by calling &lt;code&gt;Promise.resolve&lt;/code&gt; on it or &lt;code&gt;Promise.promisify&lt;/code&gt; if it's a callback:</source>
          <target state="translated">ソリューションは、いずれかを呼び出すことによって約束に変換することである &lt;code&gt;Promise.resolve&lt;/code&gt; をそれか上 &lt;code&gt;Promise.promisify&lt;/code&gt; それはコールバックの場合：</target>
        </trans-unit>
        <trans-unit id="a959d4cee575b4382df36392cd8df64e24184dbc" translate="yes" xml:space="preserve">
          <source>The stack trace for &lt;a href=&quot;warning-explanations#warning-a-promise-was-created-in-a-handler-but-none-were-returned-from-it&quot;&gt;forgotten return warnings&lt;/a&gt; is more useful now.</source>
          <target state="translated">&lt;a href=&quot;warning-explanations#warning-a-promise-was-created-in-a-handler-but-none-were-returned-from-it&quot;&gt;忘れられた戻り警告&lt;/a&gt;のスタックトレースがさらに便利になりました。</target>
        </trans-unit>
        <trans-unit id="b7cfeae4442044317b39c717825ad07af88a84b2" translate="yes" xml:space="preserve">
          <source>The standard &lt;a href=&quot;http://promises-aplus.github.io/promises-spec/&quot;&gt;Promises/A+ &lt;code&gt;.then()&lt;/code&gt;&lt;/a&gt; is still supported by Bluebird and support for it will continue indefinitely . However, the variant accepting a third &lt;code&gt;progressHandler&lt;/code&gt; argument is no longer supported.</source>
          <target state="translated">標準の&lt;a href=&quot;http://promises-aplus.github.io/promises-spec/&quot;&gt;Promises / A + &lt;code&gt;.then()&lt;/code&gt; &lt;/a&gt;は引き続きBluebirdでサポートされており、そのサポートは無期限に継続されます。ただし、3番目の &lt;code&gt;progressHandler&lt;/code&gt; 引数を受け入れるバリアントはサポートされなくなりました。</target>
        </trans-unit>
        <trans-unit id="0578afb0e805324fd3d6ef6661225daacb79ec32" translate="yes" xml:space="preserve">
          <source>The suffix must be a valid JavaScript identifier using ASCII letters</source>
          <target state="translated">サフィックスは、ASCII 文字を使った有効な JavaScript の識別子でなければなりません。</target>
        </trans-unit>
        <trans-unit id="51e5ddd442738d3ba0fcf36bd1580ce1e7b6558a" translate="yes" xml:space="preserve">
          <source>The usage pattern is similar to the PostgreSQL example above. You can also use a disposer pattern (but not an actual .disposer). See the PostgreSQL example above for instructions.</source>
          <target state="translated">使用パターンは上記のPostgreSQLの例と似ています。ディスポーザパターンを使用することもできます(実際の.disposerではありません)。手順については、上記のPostgreSQLの例を参照してください。</target>
        </trans-unit>
        <trans-unit id="28bb7fa145553052b5508efe6d9bb705def39d86" translate="yes" xml:space="preserve">
          <source>The usual way to use promises in node is to &lt;a href=&quot;api/promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; some API and start exclusively calling promise returning versions of the APIs methods. E.g.</source>
          <target state="translated">ノードで&lt;a href=&quot;api/promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt;を使用する通常の方法は、いくつかのAPI をPromise.promisifyAllにして、APIメソッドのバージョンを返すpromiseの排他的な呼び出しを開始することです。例えば</target>
        </trans-unit>
        <trans-unit id="9d0826c3236c309fa1a8bb247d52444104239f26" translate="yes" xml:space="preserve">
          <source>The usual way to use promises in node is to &lt;a href=&quot;promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; some API and start exclusively calling promise returning versions of the APIs methods. E.g.</source>
          <target state="translated">ノードで&lt;a href=&quot;promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt;を使用する通常の方法は、いくつかのAPI をPromise.promisifyAllにして、APIメソッドのバージョンを返すpromiseの排他的な呼び出しを開始することです。例えば</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="fdf91bb0325fcdd18970709eb26b34f64a3672d1" translate="yes" xml:space="preserve">
          <source>There are many third party promise libraries available for JavaScript and even the standard library contains a promise implementation in newer versions of browsers and node/io.js. This page will explore why one might use bluebird promises over other third party or the standard library implementations. For reasons to use promises in general, see the &lt;a href=&quot;why-promises&quot;&gt;Why Promises?&lt;/a&gt; article.</source>
          <target state="translated">JavaScriptで利用できるサードパーティのpromiseライブラリは多数あり、標準ライブラリでさえ、新しいバージョンのブラウザとnode /io.jsでのpromiseの実装が含まれています。このページでは、他のサードパーティや標準ライブラリの実装よりもbluebirdpromiseを使用する理由について説明します。一般的にpromiseを使用する理由については、&lt;a href=&quot;why-promises&quot;&gt;Why Promises？を&lt;/a&gt;参照してください。論文。</target>
        </trans-unit>
        <trans-unit id="12dfbb41929f3ee02dc34311b3347fac9dec5515" translate="yes" xml:space="preserve">
          <source>There are many third party promise libraries available for JavaScript and even the standard library contains a promise implementation in newer versions of browsers and node/io.js. This page will explore why one might use bluebird promises over other third party or the standard library implementations. For reasons why to use promises in general, see the &lt;a href=&quot;why-promises&quot;&gt;Why Promises?&lt;/a&gt; article.</source>
          <target state="translated">JavaScriptで利用できるサードパーティのプロミスライブラリは多数あり、標準ライブラリでさえ、新しいバージョンのブラウザとnode / io.jsでのプロミス実装が含まれています。このページでは、他のサードパーティや標準ライブラリの実装よりもBluebirdのプロミスを使用する理由を探ります。一般にプロミスを使用する理由については、&lt;a href=&quot;why-promises&quot;&gt;プロミスを選ぶ理由を&lt;/a&gt;ご覧ください。論文。</target>
        </trans-unit>
        <trans-unit id="0016f6e7c65d90d1ef2d07a4adbd7695a74d6216" translate="yes" xml:space="preserve">
          <source>There are many ways to use bluebird in browsers:</source>
          <target state="translated">ブラウザでブルーバードを使う方法はたくさんあります。</target>
        </trans-unit>
        <trans-unit id="acfa8f7a74926d5b3e71d319fe2e3737e67b4a45" translate="yes" xml:space="preserve">
          <source>There are still a few problems with the earlier code example. It feels like it is doing too much. A &lt;em&gt;squint&lt;/em&gt; test reveals behavior for showing the dialog, set the dialog's message, attach two DOM events, construct a promise, event delegation, hide the dialog, and finally detach DOM events. That is a lot for one little function. A refactoring can help.</source>
          <target state="translated">以前のコード例にはまだいくつかの問題があります。やりすぎのようです。ス&lt;em&gt;クイント&lt;/em&gt;テストでは、ダイアログの表示、ダイアログのメッセージの設定、2つのDOMイベントの添付、promise、イベントの委任の作成、ダイアログの非表示、最後にDOMイベントのアタッチ&lt;em&gt;解除の&lt;/em&gt;動作が明らかになります。これは、1つの小さな機能にとっては多くのことです。リファクタリングが役立ちます。</target>
        </trans-unit>
        <trans-unit id="c2d9fdb7b10a480524179ca553be134c2cab93bd" translate="yes" xml:space="preserve">
          <source>There are two primary methods of converting callback based APIs into promise based ones. You can either manually map the API calls to promise returning functions or you can let the bluebird do it for you. We &lt;strong&gt;strongly&lt;/strong&gt; recommend the latter.</source>
          <target state="translated">コールバックベースのAPIをpromiseベースのAPIに変換するには、主に2つの方法があります。手動でAPI呼び出しをマッピングして戻り関数を約束するか、bluebirdに任せることができます。後者を&lt;strong&gt;強く&lt;/strong&gt;お勧めします。</target>
        </trans-unit>
        <trans-unit id="f594978f8f4cce365338daa917338cba030de34d" translate="yes" xml:space="preserve">
          <source>There is also &lt;a href=&quot;http://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises&quot;&gt;this more general StackOverflow question&lt;/a&gt; about conversion of callback APIs to promises. If you find anything missing in this guide however, please do open an issue or pull request.</source>
          <target state="translated">コールバックAPIから&lt;a href=&quot;http://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises&quot;&gt;Promise&lt;/a&gt;への変換について、このより一般的なStackOverflowの質問もあります。このガイドで不足しているものを見つけた場合は、問題をオープンするか、プルリクエストを行ってください。</target>
        </trans-unit>
        <trans-unit id="82ffbfbc41fe53312b41cce044330748666500e8" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;https://www.promisejs.org/generators/&quot;&gt;excellent article&lt;/a&gt; on promisejs.org detailing how to combine promises with generators to achieve much cleaner code. Instead of the &lt;code&gt;async&lt;/code&gt; function the article proposes, you can use &lt;a href=&quot;api/promise.coroutine&quot;&gt;&lt;code&gt;Promise.coroutine&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">promisejs.orgに&lt;a href=&quot;https://www.promisejs.org/generators/&quot;&gt;優れた記事&lt;/a&gt;があり、promiseをジェネレーターと組み合わせてよりクリーンなコードを実現する方法が詳しく説明されています。記事で提案されている &lt;code&gt;async&lt;/code&gt; 関数の代わりに、&lt;a href=&quot;api/promise.coroutine&quot;&gt; &lt;code&gt;Promise.coroutine&lt;/code&gt; &lt;/a&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="ccd6b50860623f70756069f499d23f01b6d13e5c" translate="yes" xml:space="preserve">
          <source>There is no effect on performance if the user doesn't actually pass a node-style callback function.</source>
          <target state="translated">ユーザーが実際にノードスタイルのコールバック関数を渡さない場合、パフォーマンスに影響はありません。</target>
        </trans-unit>
        <trans-unit id="a899a39eea077d35fbd555f33e92cdecfa97e0f3" translate="yes" xml:space="preserve">
          <source>There is no need to convert timeouts/delays to a bluebird API, bluebird already ships with the &lt;a href=&quot;api/promise.delay&quot;&gt;&lt;code&gt;Promise.delay&lt;/code&gt;&lt;/a&gt; function for this use case. Please consult the &lt;a href=&quot;api/timers&quot;&gt;&lt;code&gt;timers&lt;/code&gt;&lt;/a&gt; section of the docs on usage and examples.</source>
          <target state="translated">タイムアウト/遅延をbluebird APIに変換する必要はありません&lt;a href=&quot;api/promise.delay&quot;&gt; &lt;code&gt;Promise.delay&lt;/code&gt; &lt;/a&gt;、この使用例のPromise.delay関数がすでに付属しています。使用法と例については、ドキュメントの&lt;a href=&quot;api/timers&quot;&gt; &lt;code&gt;timers&lt;/code&gt; &lt;/a&gt;セクションをご覧ください。</target>
        </trans-unit>
        <trans-unit id="816256e371a68e0a4e42cc5d7e31e59e968b1550" translate="yes" xml:space="preserve">
          <source>This APIs are what most core modules in Node/io use and bluebird comes with a fast and efficient way to convert them to promise based APIs through the &lt;code&gt;Promise.promisify&lt;/code&gt; and &lt;code&gt;Promise.promisifyAll&lt;/code&gt; function calls.</source>
          <target state="translated">このAPIはNode / ioのほとんどのコアモジュールが使用するものであり、bluebirdには、 &lt;code&gt;Promise.promisify&lt;/code&gt; および &lt;code&gt;Promise.promisifyAll&lt;/code&gt; 関数呼び出しを介してそれらをpromiseベースのAPIに変換する高速で効率的な方法が付属しています。</target>
        </trans-unit>
        <trans-unit id="3d88bc0890f9955d9aafd69e5e422f7404df8670" translate="yes" xml:space="preserve">
          <source>This abstraction can be expanded on in other ways. For example a notification dialog:</source>
          <target state="translated">この抽象化は他の方法で拡張することができます。例えば、通知ダイアログなどです。</target>
        </trans-unit>
        <trans-unit id="4ef92d2a854bbe01523868d53a897ee9b600001a" translate="yes" xml:space="preserve">
          <source>This also happens when implementing live-updating models with a &lt;code&gt;.then&lt;/code&gt; method that indicates when the model is &quot;ready&quot;. A promise is a process, it starts and it ends.</source>
          <target state="translated">これは、モデルが「準備完了」になったことを示す &lt;code&gt;.then&lt;/code&gt; メソッドを使用してライブ更新モデルを実装するときにも発生します。約束はプロセスであり、それは始まり、そして終わります。</target>
        </trans-unit>
        <trans-unit id="1d9ddcdc77c9d4a96e7a508b17988600ecaa73fc" translate="yes" xml:space="preserve">
          <source>This also means that disposers should not contain code that does anything other than resource disposal. For example, you cannot write code inside a disposer to commit or rollback a transaction, because there is no mechanism for the disposer to signal a failure of the commit or rollback action without crashing the process.</source>
          <target state="translated">これは、ディスポーザにはリソースの処理以外のことをするコードを書いてはいけないということでもあります。たとえば、トランザクションをコミットしたりロールバックしたりするコードをディスポーザの中に書くことはできません。</target>
        </trans-unit>
        <trans-unit id="66b2c8b4731b0f7ba7e6bf98e67448082824c523" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/api/promise.each.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">この記事は部分的または完全に未完成です。この記事の完了に役立つ&lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/api/promise.each.md&quot;&gt;プルリクエスト&lt;/a&gt;を作成できます。</target>
        </trans-unit>
        <trans-unit id="9b70a0a7654e551108da4764c9f005aab32644aa" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/async-dialogs.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">この記事は部分的または完全に未完成です。この記事の完了に役立つ&lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/async-dialogs.md&quot;&gt;プルリクエスト&lt;/a&gt;を作成できます。</target>
        </trans-unit>
        <trans-unit id="e1c525d7a299f5e8e85d4de9a717c3aacb38e9c7" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/beginners-guide.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">この記事は部分的または完全に未完成です。この記事の完了に役立つ&lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/beginners-guide.md&quot;&gt;プルリクエスト&lt;/a&gt;を作成できます。</target>
        </trans-unit>
        <trans-unit id="c52f9c032871178393d4fecda1b976e39b1a06b1" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/deprecated-apis.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">この記事は部分的または完全に未完成です。この記事の完了に役立つ&lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/deprecated-apis.md&quot;&gt;プルリクエスト&lt;/a&gt;を作成できます。</target>
        </trans-unit>
        <trans-unit id="b6f8fae1cd767c72257bf951d6fae38ca4750167" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/features.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">この記事は部分的または完全に未完成です。この記事の完了に役立つ&lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/features.md&quot;&gt;プルリクエスト&lt;/a&gt;を作成できます。</target>
        </trans-unit>
        <trans-unit id="0b80a141eb9286b1bcd67d018003d3e43d4ca6b1" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/getting-started.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">この記事は部分的または完全に未完成です。この記事の完了に役立つ&lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/getting-started.md&quot;&gt;プルリクエスト&lt;/a&gt;を作成できます。</target>
        </trans-unit>
        <trans-unit id="c9d9ce5a1a1cedf3cd3c1bf2b642c4920ce3d476" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/warning-explanations.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">この記事は部分的または完全に未完成です。この記事の完了に役立つ&lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/warning-explanations.md&quot;&gt;プルリクエスト&lt;/a&gt;を作成できます。</target>
        </trans-unit>
        <trans-unit id="01153e43a1c1cb6db13e7e38cfc4a7ca277baf87" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/what-about-generators.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">この記事は部分的または完全に未完成です。この記事の完了に役立つ&lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/what-about-generators.md&quot;&gt;プルリクエスト&lt;/a&gt;を作成できます。</target>
        </trans-unit>
        <trans-unit id="3b2b6fdf4dc9492f2c92f1362815d504f5b44c1e" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/why-performance.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">この記事は部分的または完全に未完成です。この記事の完了に役立つ&lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/why-performance.md&quot;&gt;プルリクエスト&lt;/a&gt;を作成できます。</target>
        </trans-unit>
        <trans-unit id="7a69f82bc8c73af862fe6ee2765641d403ac8822" translate="yes" xml:space="preserve">
          <source>This can be used to create APIs that both accept node-style callbacks and return promises:</source>
          <target state="translated">これを使用して、ノードスタイルのコールバックとプロミスを返すAPIを作成することができます。</target>
        </trans-unit>
        <trans-unit id="2af698572346d77b6e2820e63d397c65adf61bf3" translate="yes" xml:space="preserve">
          <source>This can be useful if a function returns a promise (say into a chain) but can optionally return a static value. Say, for a lazy-loaded value. Example:</source>
          <target state="translated">これは、関数がプロミス(例えばチェーン)を返す場合に便利ですが、オプションで静的な値を返すこともできます。例えば、レイジーロードされた値を返す場合などです。例。</target>
        </trans-unit>
        <trans-unit id="01154032238ce0a62f38ce2edfeea44425f1609e" translate="yes" xml:space="preserve">
          <source>This can happen when you are calling &lt;a href=&quot;api/promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; on a function and invoking it instead of passing it.</source>
          <target state="translated">これは、関数で&lt;a href=&quot;api/promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt;を呼び出して、渡すのではなく呼び出す場合に発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="b7e20e128e0a8a57b67f7c7c358d05477f3c5d61" translate="yes" xml:space="preserve">
          <source>This can happen when you tried to do something like:</source>
          <target state="translated">のようなことをしようとしたときに起こります。</target>
        </trans-unit>
        <trans-unit id="caac030e0f988203bfd2f85f66f13be073b83988" translate="yes" xml:space="preserve">
          <source>This doesn't add much much using &lt;code&gt;window.prompt&lt;/code&gt;; however, one advantage is the API that promises provide. In the case where we call &lt;code&gt;promptPromise(&amp;hellip;)&lt;/code&gt; we can easily react to the result of the dialog without having to worry about how it is implemented. In our example we've implemented the &lt;code&gt;window.prompt&lt;/code&gt; but our call to &lt;code&gt;promptPromise()&lt;/code&gt; doesn't care. This makes a change to an &lt;em&gt;asynchronous&lt;/em&gt; dialog a little more future proof.</source>
          <target state="translated">これは &lt;code&gt;window.prompt&lt;/code&gt; を使用してもそれほど多くは追加されません。ただし、Promiseが提供するAPIが1つの利点です。 &lt;code&gt;promptPromise(&amp;hellip;)&lt;/code&gt; を呼び出す場合、ダイアログの実装方法を気にすることなく、ダイアログの結果に簡単に対応できます。この例では &lt;code&gt;window.prompt&lt;/code&gt; を実装しましたが、 &lt;code&gt;promptPromise()&lt;/code&gt; の呼び出しは関係ありません。これにより、&lt;em&gt;非同期&lt;/em&gt;ダイアログへの変更がもう少し証明されます。</target>
        </trans-unit>
        <trans-unit id="71b6120513a7366580cee8aba7b9480ac2cf93a2" translate="yes" xml:space="preserve">
          <source>This error indicates you have tried to call &lt;a href=&quot;api/promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; on an object that already has a property with the &lt;code&gt;Async&lt;/code&gt; suffix:</source>
          <target state="translated">このエラーは、 &lt;code&gt;Async&lt;/code&gt; サフィックスを持つプロパティが既にあるオブジェクトで&lt;a href=&quot;api/promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt;を呼び出そうとしたことを示します。</target>
        </trans-unit>
        <trans-unit id="a572d9a56addbf0b78e49d060a13678d16002f76" translate="yes" xml:space="preserve">
          <source>This example doesn't work as intended because the &lt;code&gt;then&lt;/code&gt; handler actually swallows the exception and returns &lt;code&gt;undefined&lt;/code&gt; for any further chainers.</source>
          <target state="translated">この例は、 &lt;code&gt;then&lt;/code&gt; ハンドラが実際に例外を飲み込み、それ以降のチェーンに対して &lt;code&gt;undefined&lt;/code&gt; を返すため、意図したとおりに機能しません。</target>
        </trans-unit>
        <trans-unit id="7c54ec4bcf6b3320c0e8ec781b0cb320bbd68320" translate="yes" xml:space="preserve">
          <source>This example pings 4 nameservers, and logs the fastest 2 on console:</source>
          <target state="translated">この例では、4 つのネームサーバを ping し、コンソール上で最速の 2 つをログに記録しています。</target>
        </trans-unit>
        <trans-unit id="2b07ce3ee1a174adcf4f487506a3c9e336575eaf" translate="yes" xml:space="preserve">
          <source>This feature enables subscription to promise lifecycle events via standard global events mechanisms in browsers and Node.js.</source>
          <target state="translated">この機能は、ブラウザやNode.jsの標準的なグローバルイベントメカニズムを介して、ライフサイクルイベントをプロミスするためのサブスクリプションを可能にします。</target>
        </trans-unit>
        <trans-unit id="876ee350821244d6855a5b5648beee14fb439673" translate="yes" xml:space="preserve">
          <source>This feature has to be explicitly enabled by calling &lt;a href=&quot;api/promise.config&quot;&gt;&lt;code&gt;Promise.config&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;monitoring: true&lt;/code&gt;.</source>
          <target state="translated">この機能は、&lt;a href=&quot;api/promise.config&quot;&gt; &lt;code&gt;Promise.config&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;monitoring: true&lt;/code&gt; 呼び出して明示的に有効にする必要があります。</target>
        </trans-unit>
        <trans-unit id="ca7179462cda9a709541b309d7c01bbb585212a4" translate="yes" xml:space="preserve">
          <source>This file contains documentation for APIs that are no longer supported by Bluebird. These APIs still work in Bluebird but will be removed at a future version of the library.</source>
          <target state="translated">このファイルには、Bluebird でサポートされなくなった API のドキュメントが含まれています。これらの API は Bluebird でまだ動作しますが、ライブラリの将来のバージョンで削除される予定です。</target>
        </trans-unit>
        <trans-unit id="4e1d1e209b1192c78f57f02dae0b2d4bf136ca53" translate="yes" xml:space="preserve">
          <source>This happens when a non object value or a promise that resolves with something that is not an object is being passed instead.</source>
          <target state="translated">これは、オブジェクトではない値や、オブジェクトではないもので解決する約束が代わりに渡されたときに起こります。</target>
        </trans-unit>
        <trans-unit id="fb3b4bfaeb441a21b0068d6c2bb1331473c59ffc" translate="yes" xml:space="preserve">
          <source>This happens when you call &lt;code&gt;.some&lt;/code&gt; passing it a negative value or a non-integer.</source>
          <target state="translated">これは、負の値または非整数を渡して &lt;code&gt;.some&lt;/code&gt; を呼び出すと発生します。</target>
        </trans-unit>
        <trans-unit id="361cf2ec170969184f8f35c3d2c58d91c88e0978" translate="yes" xml:space="preserve">
          <source>This inherits from &lt;code&gt;Dialog&lt;/code&gt; and stores references to the required DOM elements that this dialog uses. It then attaches the require DOM events (&lt;code&gt;attachDomEvents()&lt;/code&gt;) which eventually call the callbacks. Then it implements the &lt;code&gt;show()&lt;/code&gt; and &lt;code&gt;hide()&lt;/code&gt; methods. Its usage is more flexible and verbose:</source>
          <target state="translated">これは &lt;code&gt;Dialog&lt;/code&gt; を継承し、このダイアログが使用する必要なDOM要素への参照を格納します。次に、最終的にコールバックを呼び出すrequire DOMイベント（ &lt;code&gt;attachDomEvents()&lt;/code&gt; ）をアタッチします。次に、 &lt;code&gt;show()&lt;/code&gt; &lt;code&gt;hide()&lt;/code&gt; メソッドとhide（）メソッドを実装します。その使用法はより柔軟で冗長です。</target>
        </trans-unit>
        <trans-unit id="1c40c501429304b951f3e9a1e618216d7da3fae9" translate="yes" xml:space="preserve">
          <source>This interface is implemented by &lt;code&gt;Promise&lt;/code&gt; instances as well as the &lt;code&gt;PromiseInspection&lt;/code&gt; result given by &lt;a href=&quot;reflect&quot;&gt;&lt;code&gt;.reflect()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このインターフェースは、 &lt;code&gt;Promise&lt;/code&gt; インスタンスと&lt;a href=&quot;reflect&quot;&gt; &lt;code&gt;.reflect()&lt;/code&gt; &lt;/a&gt;によって与えられる &lt;code&gt;PromiseInspection&lt;/code&gt; の結果によって実装されます。</target>
        </trans-unit>
        <trans-unit id="1625642eae18357d2f9d1a1405e4d5fa15c5195c" translate="yes" xml:space="preserve">
          <source>This is Gorki Kosev's benchmark used in the article &lt;a href=&quot;http://spion.github.io/posts/analysis-generators-and-other-async-patterns-node.html&quot;&gt;Analysis of generators and other async patterns in node&lt;/a&gt;. The benchmark emulates a situation where N=10000 requests are being made concurrently to execute some mixed async/sync action with fast I/O response times.</source>
          <target state="translated">これは、記事「&lt;a href=&quot;http://spion.github.io/posts/analysis-generators-and-other-async-patterns-node.html&quot;&gt;ジェネレーターの分析とノード内の他の非同期パターン」で&lt;/a&gt;使用されているGorki Kosevのベンチマークです。ベンチマークは、高速のI / O応答時間でいくつかの混合非同期/同期アクションを実行するためにN = 10000要求が同時に行われている状況をエミュレートします。</target>
        </trans-unit>
        <trans-unit id="c49dfefe9b869fa007a2d85f8deb59c16587b42f" translate="yes" xml:space="preserve">
          <source>This is a catch-all exception handler, shortcut for calling &lt;a href=&quot;then&quot;&gt;&lt;code&gt;.then(null, handler)&lt;/code&gt;&lt;/a&gt; on this promise. Any exception happening in a &lt;code&gt;.then&lt;/code&gt;-chain will propagate to nearest &lt;code&gt;.catch&lt;/code&gt; handler.</source>
          <target state="translated">これはキャッチオール例外ハンドラーであり、このpromiseで&lt;a href=&quot;then&quot;&gt; &lt;code&gt;.then(null, handler)&lt;/code&gt; &lt;/a&gt;を呼び出すためのショートカットです。 &lt;code&gt;.then&lt;/code&gt; チェーンで発生した例外は、最も近い &lt;code&gt;.catch&lt;/code&gt; ハンドラーに伝播します。</target>
        </trans-unit>
        <trans-unit id="41cc0d7fb9773615b0a72dbe0951bb7f568b688b" translate="yes" xml:space="preserve">
          <source>This is a convenience method for doing:</source>
          <target state="translated">するための便利な方法です。</target>
        </trans-unit>
        <trans-unit id="ab45ed2cecaf14b1bbcc736ecc5d3c6da77d3562" translate="yes" xml:space="preserve">
          <source>This is a throughput benchmark.</source>
          <target state="translated">スループットベンチマークです。</target>
        </trans-unit>
        <trans-unit id="0bb50cb46856cf19733b9b720a91a5dbcedf8961" translate="yes" xml:space="preserve">
          <source>This is an extension to &lt;a href=&quot;catch&quot;&gt;&lt;code&gt;.catch&lt;/code&gt;&lt;/a&gt; to work more like catch-clauses in languages like Java or C#. Instead of manually checking &lt;code&gt;instanceof&lt;/code&gt; or &lt;code&gt;.name === &quot;SomeError&quot;&lt;/code&gt;, you may specify a number of error constructors which are eligible for this catch handler. The catch handler that is first met that has eligible constructors specified, is the one that will be called.</source>
          <target state="translated">これは、JavaやC＃などの言語のcatch-clausesのように機能する&lt;a href=&quot;catch&quot;&gt; &lt;code&gt;.catch&lt;/code&gt; &lt;/a&gt;の拡張機能です。 &lt;code&gt;instanceof&lt;/code&gt; または &lt;code&gt;.name === &quot;SomeError&quot;&lt;/code&gt; を手動でチェックする代わりに、このキャッチハンドラーに適したエラーコンストラクターの数を指定できます。適格なコンストラクターが指定されている最初に検出されたキャッチハンドラーが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="4e6f1e1654fff47bb7489453d9f0b688afc82574" translate="yes" xml:space="preserve">
          <source>This is an extension to &lt;a href=&quot;tapcatch&quot;&gt;&lt;code&gt;.tapCatch&lt;/code&gt;&lt;/a&gt; to filter exceptions similarly to languages like Java or C#. Instead of manually checking &lt;code&gt;instanceof&lt;/code&gt; or &lt;code&gt;.name === &quot;SomeError&quot;&lt;/code&gt;, you may specify a number of error constructors which are eligible for this tapCatch handler. The tapCatch handler that is first met that has eligible constructors specified, is the one that will be called.</source>
          <target state="translated">これは&lt;a href=&quot;tapcatch&quot;&gt; &lt;code&gt;.tapCatch&lt;/code&gt; &lt;/a&gt;の拡張機能で、JavaやC＃などの言語と同様に例外をフィルタリングします。 &lt;code&gt;instanceof&lt;/code&gt; または &lt;code&gt;.name === &quot;SomeError&quot;&lt;/code&gt; を手動でチェックする代わりに、このtapCatchハンドラーに適格なエラーコンストラクターの数を指定できます。適格なコンストラクターが指定されている最初に出会うtapCatchハンドラーが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="de9b1d19482e049c5d2755c5328d90634cf4cf49" translate="yes" xml:space="preserve">
          <source>This is because Bluebird adds the &lt;code&gt;Async&lt;/code&gt; suffix to distinguish the original method from the promisified one, so &lt;code&gt;fooAsync&lt;/code&gt; would have been overridden. In order to avoid this - either rename &lt;code&gt;fooAsync&lt;/code&gt; before promisifying the API, or call &lt;a href=&quot;api/promise.promisify&quot;&gt;&lt;code&gt;Promise.promisify&lt;/code&gt;&lt;/a&gt; manually on select properties.</source>
          <target state="translated">これは、Bluebirdが元のメソッドと約束されたメソッドを区別するために &lt;code&gt;Async&lt;/code&gt; サフィックスを追加するため、fooAsync がオーバーライドされていたため &lt;code&gt;fooAsync&lt;/code&gt; 。これを回避するには、APIを &lt;code&gt;fooAsync&lt;/code&gt; する前にfooAsyncの名前を変更するか、選択したプロパティで手動で&lt;a href=&quot;api/promise.promisify&quot;&gt; &lt;code&gt;Promise.promisify&lt;/code&gt; &lt;/a&gt;を呼び出します。</target>
        </trans-unit>
        <trans-unit id="fb04140a6d6f4216a6dfa405bfd92da440efbba0" translate="yes" xml:space="preserve">
          <source>This is exactly like the synchronous code:</source>
          <target state="translated">これはまさに同期のコードと同じです。</target>
        </trans-unit>
        <trans-unit id="bfb76de6040fe50d520474f7810629da738b7706" translate="yes" xml:space="preserve">
          <source>This is far more readable when done with promises:</source>
          <target state="translated">プロミスでやった方が遥かに読みやすい。</target>
        </trans-unit>
        <trans-unit id="618293c3c21f06bb90993a614c9db3abe676ad93" translate="yes" xml:space="preserve">
          <source>This is reinventing the square wheel because any callback API wrapping can and should be done immediately using the promise library's promisification methods:</source>
          <target state="translated">なぜなら、コールバックAPIのラッピングは、プロミスライブラリのプロミス化メソッドを使ってすぐに行うことができますし、そうすべきだからです。</target>
        </trans-unit>
        <trans-unit id="278f2f5f91e65aca9cba986cd298d5b80d084994" translate="yes" xml:space="preserve">
          <source>This is relevant to browser environments with no module loader.</source>
          <target state="translated">これは、モジュールローダのないブラウザ環境に関連しています。</target>
        </trans-unit>
        <trans-unit id="72dacc01b0328b9bb5e5b49e4a3b2f09a68d5835" translate="yes" xml:space="preserve">
          <source>This is the most common anti-pattern. It is easy to fall into this when you don't really understand promises and think of them as glorified event emitters or callback utility. It's also sometimes called the promise constructor anti-pattern. Let's recap: promises are about making asynchronous code retain most of the lost properties of synchronous code such as flat indentation and one exception channel. This pattern is also called the deferred anti-pattern.</source>
          <target state="translated">これは最も一般的なアンチパターンです。プロミスをよく理解しておらず、プロミスを単なるイベントエミッタやコールバックユーティリティと考えていると、このパターンに陥りがちです。これは、プロミスのコンストラクタのアンチパターンと呼ばれることもあります。要約すると、プロミスは非同期コードに、フラットインデントや1つの例外チャンネルなど、同期コードで失われたプロパティのほとんどを保持させるためのものです。このパターンは遅延アンチパターンとも呼ばれています。</target>
        </trans-unit>
        <trans-unit id="83310ff097e8beff42467f80b6885cac44a4a774" translate="yes" xml:space="preserve">
          <source>This is the point&amp;mdash;to have something that works like &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;throw&lt;/code&gt; in synchronous code.</source>
          <target state="translated">これがポイントです。同期コードで &lt;code&gt;return&lt;/code&gt; および &lt;code&gt;throw&lt;/code&gt; のように機能するものを用意する必要があります。</target>
        </trans-unit>
        <trans-unit id="158db758d5ef9e5d2ebee4458ff60d03b8698f8f" translate="yes" xml:space="preserve">
          <source>This is to enable better stack trace support and to have more consistent and logical code.</source>
          <target state="translated">これは、より良いスタックトレースのサポートを可能にし、より一貫性のある論理的なコードを持つことができるようにするためです。</target>
        </trans-unit>
        <trans-unit id="eb2cd71a05d06d1a123d046c307b240be60c02ec" translate="yes" xml:space="preserve">
          <source>This made-up scenario runs 25 shimmed queries in parallel per each request (N=10000) with fast I/O response times.</source>
          <target state="translated">このメードアップシナリオでは、各リクエスト(N=10000)ごとに25個のシム化されたクエリを並列に実行し、高速なI/O応答時間を実現しています。</target>
        </trans-unit>
        <trans-unit id="1cc8fcf272c1fddb57ef8ff18a07070dc64c720d" translate="yes" xml:space="preserve">
          <source>This means you can insert &lt;code&gt;.tap()&lt;/code&gt; into a &lt;code&gt;.then()&lt;/code&gt; chain without affecting what is passed through the chain. (See example below).</source>
          <target state="translated">これは、チェーンを通過するものに影響を与えることなく、 &lt;code&gt;.tap()&lt;/code&gt; を &lt;code&gt;.then()&lt;/code&gt; チェーンに挿入できることを意味します。 （以下の例を参照してください）。</target>
        </trans-unit>
        <trans-unit id="3c0de91929a03e3312c7e239b95e998f29ef038e" translate="yes" xml:space="preserve">
          <source>This method also supports predicate-based filters. If you pass a predicate function instead of an error constructor, the predicate will receive the error as an argument. The return result of the predicate will be used determine whether the error handler should be called.</source>
          <target state="translated">このメソッドは、述語ベースのフィルタもサポートしています。エラーのコンストラクタの代わりに述語関数を渡すと、述語はエラーを引数として受け取ります。述語の戻り値は、エラーハンドラを呼び出すべきかどうかを判断するために使用されます。</target>
        </trans-unit>
        <trans-unit id="b9befc4f3f3a5debf1bc48e96cdc0758b3d6448b" translate="yes" xml:space="preserve">
          <source>This method is compatible with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all&quot;&gt;&lt;code&gt;Promise.all&lt;/code&gt;&lt;/a&gt; from native promises.</source>
          <target state="translated">このメソッドは、ネイティブプロミスの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all&quot;&gt; &lt;code&gt;Promise.all&lt;/code&gt; &lt;/a&gt;と互換性があります。</target>
        </trans-unit>
        <trans-unit id="a0481512ec7eb9822880d2eb57c4e1770159cdaa" translate="yes" xml:space="preserve">
          <source>This method is convenient when a function can sometimes return synchronously or throw synchronously.</source>
          <target state="translated">このメソッドは、関数が時々同期的に戻ってきたり、同期的に投げることができる場合に便利です。</target>
        </trans-unit>
        <trans-unit id="05db19a6c7c0e842cae324b6edc66273dd337537" translate="yes" xml:space="preserve">
          <source>This method is deprecated. Use &lt;a href=&quot;promise.config&quot;&gt;Promise.config&lt;/a&gt; instead.</source>
          <target state="translated">このメソッドは非推奨です。代わりに&lt;a href=&quot;promise.config&quot;&gt;Promise.config&lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="f63178b611e277d3437aa6cb79a370492a0a4d4d" translate="yes" xml:space="preserve">
          <source>This method is only implemented because it's in the ES6 standard. If you want to race promises to fulfillment the &lt;a href=&quot;any&quot;&gt;&lt;code&gt;.any&lt;/code&gt;&lt;/a&gt; method is more appropriate as it doesn't qualify a rejected promise as the winner. It also has less surprises: &lt;code&gt;.race&lt;/code&gt; must become infinitely pending if an empty array is passed but passing an empty array to &lt;a href=&quot;any&quot;&gt;&lt;code&gt;.any&lt;/code&gt;&lt;/a&gt; is more usefully a &lt;code&gt;RangeError&lt;/code&gt;</source>
          <target state="translated">このメソッドは、ES6標準に含まれているためにのみ実装されています。&lt;a href=&quot;any&quot;&gt; &lt;code&gt;.any&lt;/code&gt; &lt;/a&gt;約束を競合させたい場合は、拒否された約束を勝者として認定しないため、.anyメソッドがより適切です。また、驚きも少​​なくなります。空の配列が渡された場合、 &lt;code&gt;.race&lt;/code&gt; は無限に保留になる必要がありますが、空の配列を&lt;a href=&quot;any&quot;&gt; &lt;code&gt;.any&lt;/code&gt; に&lt;/a&gt;渡すと、RangeErrorがより便利になり &lt;code&gt;RangeError&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17f763d4342a3b00b5440e744954545f7480822a" translate="yes" xml:space="preserve">
          <source>This method is useful for when you want to wait for more than one promise to complete.</source>
          <target state="translated">この方法は、複数の約束が完了するまで待ちたいときに便利です。</target>
        </trans-unit>
        <trans-unit id="e13b547a51d6973b8e8ea8229673f31834f1a93d" translate="yes" xml:space="preserve">
          <source>This method should be used before you use any of the methods which would otherwise alter the global &lt;code&gt;Bluebird&lt;/code&gt; object - to avoid polluting global state.</source>
          <target state="translated">グローバル &lt;code&gt;Bluebird&lt;/code&gt; オブジェクトを変更するメソッドを使用する前に、このメソッドを使用して、グローバル状態の汚染を回避する必要があります。</target>
        </trans-unit>
        <trans-unit id="bb88a06a14951217dbf7da64e1c214d581435513" translate="yes" xml:space="preserve">
          <source>This page describes parallels of using promises in other languages. Promises as a pattern are very common in other languages and knowing what they map to in other languages might help you with grasping them conceptually</source>
          <target state="translated">このページでは、他の言語での約束の使用の類似性について説明します。パターンとしての約束は他の言語では非常に一般的であり、他の言語で何に対応するのかを知っていると、概念的に理解するのに役立つかもしれません。</target>
        </trans-unit>
        <trans-unit id="f8caafd4bd28c25bbaa9e7e7281f27609e085879" translate="yes" xml:space="preserve">
          <source>This page explains how to interface your code with existing callback APIs and libraries you're using. We'll see that making bluebird work with callback APIs is not only easy - it's also fast.</source>
          <target state="translated">このページでは、使用している既存のコールバックAPIやライブラリとコードをインターフェースする方法を説明します。ブルーバードをコールバック API で動作させるのは簡単なだけではなく、高速であることがわかります。</target>
        </trans-unit>
        <trans-unit id="31362f3d4d915353baa5045a042087f3f740de15" translate="yes" xml:space="preserve">
          <source>This page is a reference for migrating to bluebird from other flow control or promise libraries. See &lt;a href=&quot;install&quot;&gt;installation&lt;/a&gt; on how to use bluebird in your environment.</source>
          <target state="translated">このページは、他のフロー制御またはpromiseライブラリからbluebirdに移行するためのリファレンスです。ご使用の環境でbluebirdを使用する方法については、&lt;a href=&quot;install&quot;&gt;インストール&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7a9a982268e14e003930e216d5e26566cf85c426" translate="yes" xml:space="preserve">
          <source>This page will contain common promise anti-patterns that are exercised in the wild.</source>
          <target state="translated">このページでは、野生で行使される共通のお約束のアンチパターンを掲載します。</target>
        </trans-unit>
        <trans-unit id="aa9be090a3976e3bdcf5c7d5ffe1e9f09746eddc" translate="yes" xml:space="preserve">
          <source>This section lists the most common async module replacements.</source>
          <target state="translated">このセクションでは、最も一般的な非同期モジュールの置き換えをリストアップします。</target>
        </trans-unit>
        <trans-unit id="bbbc8fd10030426b3463e06d9b5b51c19c29316d" translate="yes" xml:space="preserve">
          <source>This section only applies to node.js or io.js.</source>
          <target state="translated">この項はnode.jsまたはio.jsのみに適用されます。</target>
        </trans-unit>
        <trans-unit id="dde97755fad5f67be03bd6d1c4049a9360dedd37" translate="yes" xml:space="preserve">
          <source>This superfluous wrapping is also dangerous, any kind of errors and rejections are swallowed and not propagated to the caller of this function.</source>
          <target state="translated">この余計なラッピングもまた危険です。</target>
        </trans-unit>
        <trans-unit id="12297c68c5f136df52d6d18d4a5ba1ec592d81f8" translate="yes" xml:space="preserve">
          <source>This usually happens when you have a promise that resolves or rejects with itself.</source>
          <target state="translated">これは通常、それ自体で解決したり、拒否したりする約束をしている場合に起こります。</target>
        </trans-unit>
        <trans-unit id="22c09fd50a68a2d3dd2ca54a203b3e20039f8ff5" translate="yes" xml:space="preserve">
          <source>This usually means that you simply forgot a &lt;code&gt;return&lt;/code&gt; statement somewhere, which will cause a runaway promise that is not connected to any promise chain.</source>
          <target state="translated">これは通常、単にどこかで &lt;code&gt;return&lt;/code&gt; ステートメントを忘れてしまったことを意味します。これにより、どのプロミスチェーンにも接続されていない暴走プロミスが発生します。</target>
        </trans-unit>
        <trans-unit id="641aada61fdf6b191fac4681998d3181bd3d099f" translate="yes" xml:space="preserve">
          <source>This will ensure that &lt;code&gt;connection.close()&lt;/code&gt; will be called once the promise returned from the &lt;code&gt;Promise.using&lt;/code&gt; closure is resolved or if an exception was thrown in the closure body.</source>
          <target state="translated">これにより、 &lt;code&gt;Promise.using&lt;/code&gt; クロージャーから返されたpromiseが解決された後、またはクロージャー本体で例外がスローされた場合に、 &lt;code&gt;connection.close()&lt;/code&gt; が確実に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="d1caca18b80550e74fc714f5129356a12216a1b3" translate="yes" xml:space="preserve">
          <source>This works because the array acts as a &quot;module&quot; where the indices are the &quot;module&quot;'s properties for classes.</source>
          <target state="translated">これは、配列が「モジュール」として機能し、インデックスがクラスの「モジュール」のプロパティとなるからです。</target>
        </trans-unit>
        <trans-unit id="642f5108aa274866c1da99279aa0b6d98b1fdf21" translate="yes" xml:space="preserve">
          <source>Through the use of &lt;a href=&quot;api/each&quot;&gt;&lt;code&gt;.each&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;api/map&quot;&gt;&lt;code&gt;.map&lt;/code&gt;&lt;/a&gt; doing things just at the right concurrency level becomes a breeze.</source>
          <target state="translated">&lt;a href=&quot;api/each&quot;&gt; &lt;code&gt;.each&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;api/map&quot;&gt; &lt;code&gt;.map&lt;/code&gt; &lt;/a&gt;を使用することで、適切な同時実行レベルでの処理が簡単になります。</target>
        </trans-unit>
        <trans-unit id="22a4ad2c60d9b1a4a4ab47810c732e12faec00b0" translate="yes" xml:space="preserve">
          <source>TimeoutError</source>
          <target state="translated">TimeoutError</target>
        </trans-unit>
        <trans-unit id="ae5a9ed10e48f39a8b693714bce92b1291ca1c8b" translate="yes" xml:space="preserve">
          <source>TimeoutError()</source>
          <target state="translated">TimeoutError()</target>
        </trans-unit>
        <trans-unit id="841cd03a97cd854590864d79ae48ee749c5e902e" translate="yes" xml:space="preserve">
          <source>Timers</source>
          <target state="translated">Timers</target>
        </trans-unit>
        <trans-unit id="23658960168be8cdbfbe275f17c4c761b8a8f3e9" translate="yes" xml:space="preserve">
          <source>To do this we will have two &lt;code&gt;catch()&lt;/code&gt; functions one for &lt;code&gt;UserCanceledError&lt;/code&gt; and one for any other &lt;code&gt;Error&lt;/code&gt;. We can make a custom error like so:</source>
          <target state="translated">これを行うには、2つの &lt;code&gt;catch()&lt;/code&gt; 関数を使用します。1つは &lt;code&gt;UserCanceledError&lt;/code&gt; 用、もう1つはその他の &lt;code&gt;Error&lt;/code&gt; 用です。次のようなカスタムエラーを作成できます。</target>
        </trans-unit>
        <trans-unit id="b1a3ce42d2f42f9c24273b4cda598b33af25fce3" translate="yes" xml:space="preserve">
          <source>To drive home the synchronous nature of the &lt;code&gt;window.prompt&lt;/code&gt; notice that the time stops ticking when the prompt dialog is displayed. Let's fix that by making our own prompt. Since our dialog is just DOM manipulation the page won't be blocked while waiting for user input.</source>
          <target state="translated">&lt;code&gt;window.prompt&lt;/code&gt; の同期的な性質を理解するために、プロンプトダイアログが表示されると時刻が刻々と止まることに注意してください。独自のプロンプトを作成して修正しましょう。私たちのダイアログは単なるDOM操作なので、ユーザー入力を待っている間、ページはブロックされません。</target>
        </trans-unit>
        <trans-unit id="a7035efe5121276c8995557c4e8d8404d5096469" translate="yes" xml:space="preserve">
          <source>To enable long stack traces and warnings in node development:</source>
          <target state="translated">ノード開発で長いスタックトレースと警告を有効にする。</target>
        </trans-unit>
        <trans-unit id="0e38679fea7f9ddcf16ac2341ac48ffb3d6a13cd" translate="yes" xml:space="preserve">
          <source>To enable long stack traces and warnings in node production:</source>
          <target state="translated">ノードプロダクションで長いスタックトレースと警告を有効にする。</target>
        </trans-unit>
        <trans-unit id="302b55ad14f02d86e137c0363366e824866304b7" translate="yes" xml:space="preserve">
          <source>To enable them in all instances of bluebird in node.js, use the environment variable &lt;code&gt;BLUEBIRD_DEBUG&lt;/code&gt;:</source>
          <target state="translated">node.jsのbluebirdのすべてのインスタンスでそれらを有効にするには、環境変数 &lt;code&gt;BLUEBIRD_DEBUG&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="6a347bd13a256b214fb6fa7d0dff43a0c457c811" translate="yes" xml:space="preserve">
          <source>To fix it, simply pass the function reference to &lt;a href=&quot;api/then&quot;&gt;&lt;code&gt;.then()&lt;/code&gt;&lt;/a&gt; as is:</source>
          <target state="translated">修正するには、関数参照をそのまま&lt;a href=&quot;api/then&quot;&gt; &lt;code&gt;.then()&lt;/code&gt; に&lt;/a&gt;渡します。</target>
        </trans-unit>
        <trans-unit id="1ab4b669048933cdcafeed010c60563bc2fd72dd" translate="yes" xml:space="preserve">
          <source>To fix it, you need to &lt;code&gt;return&lt;/code&gt; the promise:</source>
          <target state="translated">それを修正するには、約束を &lt;code&gt;return&lt;/code&gt; 必要があります：</target>
        </trans-unit>
        <trans-unit id="67cb18d088b9f1e447cdd241d432d091a17f83ef" translate="yes" xml:space="preserve">
          <source>To fix, simply remember to add &lt;code&gt;return&lt;/code&gt; in front of your promise-complying function:</source>
          <target state="translated">修正するには、promise準拠の関数の前に &lt;code&gt;return&lt;/code&gt; を追加することを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="9dfea82804728489558d139da2f0b772571e485c" translate="yes" xml:space="preserve">
          <source>To make sure a function that returns a promise is following the implicit but critically important contract of promises, you can start a function with &lt;code&gt;new Promise&lt;/code&gt; if you cannot start a chain immediately:</source>
          <target state="translated">promiseを返す関数が暗黙的であるが極めて重要なpromiseの規約に従っていることを確認するには、チェーンをすぐに開始できない場合に、 &lt;code&gt;new Promise&lt;/code&gt; 関数を開始します。</target>
        </trans-unit>
        <trans-unit id="4f45ac1d08d953780ed4fe1af6ee2f1aafa55655" translate="yes" xml:space="preserve">
          <source>Together with &lt;code&gt;onPossiblyUnhandledRejection&lt;/code&gt; these hooks can be used to implement a debugger that will show a list of unhandled promise rejections updated in real time as promises become handled.</source>
          <target state="translated">&lt;code&gt;onPossiblyUnhandledRejection&lt;/code&gt; と一緒にこれらのフックを使用して、プロミスが処理されるときにリアルタイムで更新される未処理のプロミス拒否のリストを表示するデバッガーを実装できます。</target>
        </trans-unit>
        <trans-unit id="cffb3821e2781468cd3c381c1dd88d7da75f44e5" translate="yes" xml:space="preserve">
          <source>Typically &lt;em&gt;promises&lt;/em&gt; are used in conjunction with asynchronous tasks such as a network request or a &lt;code&gt;setTimeout&lt;/code&gt;; a lesser explored use is dealing with user input. Since a program has to wait for a user to continue some actions it makes sense to consider it an asynchronous event.</source>
          <target state="translated">典型的には、&lt;em&gt;約束は&lt;/em&gt;、ネットワーク要求または非同期タスクと関連して使用される &lt;code&gt;setTimeout&lt;/code&gt; 。あまり調査されていない用途は、ユーザー入力の処理です。プログラムはユーザーがいくつかのアクションを続けるのを待たなければならないので、それを非同期イベントと考えることは理にかなっています。</target>
        </trans-unit>
        <trans-unit id="95e39893849d27ccdda4985a773f9d1a23141d52" translate="yes" xml:space="preserve">
          <source>Unhandled errors are not silently swallowed by default but reported along with helpful stack traces where applicable. All of this is of course configurable.</source>
          <target state="translated">手つかずのエラーはデフォルトでは黙って飲み込まれるのではなく、該当する場所でスタックトレースと一緒に報告されます。もちろん、これらはすべて設定可能です。</target>
        </trans-unit>
        <trans-unit id="3a34c30705919f5365483a84e6ffe973cf51a891" translate="yes" xml:space="preserve">
          <source>Unhandled rejections are tracked per promise, not per error. So if you create multiple branches from a single ancestor and that ancestor gets rejected, each branch with no error handler with the end will cause a possibly unhandled rejection handler invocation</source>
          <target state="translated">手つかずの拒絶は、エラーごとではなく、プロミスごとに追跡されます。そのため、単一の祖先から複数のブランチを作成し、その祖先が拒否された場合、エラーハンドラのないブランチの最後の方にあるそれぞれのブランチは、手つかずの拒否ハンドラの呼び出しが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="4c350ad9142ecaab016e03c764abcb7074c45e90" translate="yes" xml:space="preserve">
          <source>Unless an AMD loader is installed, the script tag installation exposes the library in the &lt;code&gt;Promise&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; namespaces. If you want to restore the &lt;code&gt;Promise&lt;/code&gt; namespace, use &lt;code&gt;var Bluebird = Promise.noConflict()&lt;/code&gt;.</source>
          <target state="translated">AMDローダーがインストールされていない限り、スクリプトタグのインストールにより、 &lt;code&gt;Promise&lt;/code&gt; および &lt;code&gt;P&lt;/code&gt; 名前空間のライブラリが公開されます。 &lt;code&gt;Promise&lt;/code&gt; ネームスペースを復元する場合は、 &lt;code&gt;var Bluebird = Promise.noConflict()&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="44e42a41d2a20532fa9a5c2908e1e8626e2a7e8e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;finally&quot;&gt;&lt;code&gt;.finally&lt;/code&gt;&lt;/a&gt; this is not called for rejections.</source>
          <target state="translated">&lt;a href=&quot;finally&quot;&gt; &lt;code&gt;.finally&lt;/code&gt; &lt;/a&gt;とは異なり、これは拒否のために呼び出されません。</target>
        </trans-unit>
        <trans-unit id="8371d8f357f54bfda7d7c8677986ada6f8fa2ae9" translate="yes" xml:space="preserve">
          <source>Unminified source file meant to be used in development. Warnings and long stack traces are enabled which are taxing on performance.</source>
          <target state="translated">開発で使用することを目的とした未定義のソースファイルです。警告や長いスタックトレースが有効になっていますが、これはパフォーマンスに負担をかけます。</target>
        </trans-unit>
        <trans-unit id="c6395a030ac1269e7ce9bae273ab910b5d2f5034" translate="yes" xml:space="preserve">
          <source>Update acorn dependency</source>
          <target state="translated">どんぐりの依存関係を更新</target>
        </trans-unit>
        <trans-unit id="42a8536e189c405379021d94a1e8532ff836496d" translate="yes" xml:space="preserve">
          <source>Updated logo</source>
          <target state="translated">ロゴの更新</target>
        </trans-unit>
        <trans-unit id="08b6f1fdb58d25854a37bb391362fd81dc049478" translate="yes" xml:space="preserve">
          <source>Usage examples include:</source>
          <target state="translated">使用例としては、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="eb4421a3da2485be27f4aababc58c8de5da2c8d7" translate="yes" xml:space="preserve">
          <source>Use setImmediate if available</source>
          <target state="translated">利用可能な場合は setImmediate を使用します。</target>
        </trans-unit>
        <trans-unit id="289a45d725e898c1ca06ab7fa01837771482ed99" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;api/promise.all&quot;&gt;&lt;code&gt;Promise.all&lt;/code&gt;&lt;/a&gt; to implement the example from &lt;a href=&quot;https://github.com/caolan/async#parallel&quot;&gt;async homepage&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;api/promise.all&quot;&gt; &lt;code&gt;Promise.all&lt;/code&gt; &lt;/a&gt;を使用して、&lt;a href=&quot;https://github.com/caolan/async#parallel&quot;&gt;非同期ホームページ&lt;/a&gt;から例を実装します。</target>
        </trans-unit>
        <trans-unit id="d609f610f666b772e57874290c0b6739f1e46b91" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;api/promise.each&quot;&gt;&lt;code&gt;Promise.each&lt;/code&gt;&lt;/a&gt; to implement the example from &lt;a href=&quot;https://github.com/caolan/async#maparr-iterator-callback&quot;&gt;async homepage&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;api/promise.each&quot;&gt; &lt;code&gt;Promise.each&lt;/code&gt; &lt;/a&gt;を使用して、&lt;a href=&quot;https://github.com/caolan/async#maparr-iterator-callback&quot;&gt;非同期ホームページ&lt;/a&gt;から例を実装します。</target>
        </trans-unit>
        <trans-unit id="7b37cc52da759eea0a61e35010724d1f98be048a" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;api/promise.map&quot;&gt;&lt;code&gt;Promise.map&lt;/code&gt;&lt;/a&gt; to implement the example from &lt;a href=&quot;https://github.com/caolan/async#maparr-iterator-callback&quot;&gt;async homepage&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;api/promise.map&quot;&gt; &lt;code&gt;Promise.map&lt;/code&gt; &lt;/a&gt;を使用して、&lt;a href=&quot;https://github.com/caolan/async#maparr-iterator-callback&quot;&gt;非同期ホームページ&lt;/a&gt;から例を実装します。</target>
        </trans-unit>
        <trans-unit id="87872433fa3fca67fb5bcea17254b8b45dc74c5d" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;api/promise.mapseries&quot;&gt;&lt;code&gt;Promise.mapSeries&lt;/code&gt;&lt;/a&gt; to implement the example from &lt;a href=&quot;https://github.com/caolan/async#seriestasks-callback&quot;&gt;async homepage&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;api/promise.mapseries&quot;&gt; &lt;code&gt;Promise.mapSeries&lt;/code&gt; &lt;/a&gt;を使用して、&lt;a href=&quot;https://github.com/caolan/async#seriestasks-callback&quot;&gt;非同期ホームページ&lt;/a&gt;から例を実装します。</target>
        </trans-unit>
        <trans-unit id="5a34d8c3d20da73e7fdd61d0a9cd7e9a530150eb" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;.reflect()&lt;/code&gt; to implement &lt;code&gt;settleAll&lt;/code&gt; (wait until all promises in an array are either rejected or fulfilled) functionality</source>
          <target state="translated">&lt;code&gt;.reflect()&lt;/code&gt; を使用してsettleAll（配列内のすべての &lt;code&gt;settleAll&lt;/code&gt; が拒否または実行されるまで待機）機能を実装する</target>
        </trans-unit>
        <trans-unit id="a030f13931277422b23a2b7aa92804eba9dbfca1" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;.reflect()&lt;/code&gt; to implement &lt;code&gt;settleProps&lt;/code&gt; (like settleAll for an object's properties) functionality</source>
          <target state="translated">使用 &lt;code&gt;.reflect()&lt;/code&gt; を実装し &lt;code&gt;settleProps&lt;/code&gt; （オブジェクトのプロパティのsettleAllなど）の機能</target>
        </trans-unit>
        <trans-unit id="510bd1d1748aa6be73d0b3f164f968144ae8f326" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;defaultPromisifier&lt;/code&gt; parameter to add enhancements on top of normal node promisification:</source>
          <target state="translated">&lt;code&gt;defaultPromisifier&lt;/code&gt; パラメーターを使用して、通常のノードの約束に加えて拡張機能を追加します。</target>
        </trans-unit>
        <trans-unit id="a7f32ad8c97706d5425fc98083d499e4e2b0f38a" translate="yes" xml:space="preserve">
          <source>Using CoffeeScript's &lt;code&gt;class&lt;/code&gt; for the same:</source>
          <target state="translated">CoffeeScriptの &lt;code&gt;class&lt;/code&gt; を同じに使用する：</target>
        </trans-unit>
        <trans-unit id="39b2fb1fa487e5be55b2254cc478460136f04a5f" translate="yes" xml:space="preserve">
          <source>Using DOM3 &lt;code&gt;addEventListener&lt;/code&gt; APIs (support starting from IE9+):</source>
          <target state="translated">DOM3 &lt;code&gt;addEventListener&lt;/code&gt; APIの使用（IE9 +以降のサポート）：</target>
        </trans-unit>
        <trans-unit id="0031ac8ff26e8b6b8c4fa9f5d7c7a8c5ff06fc8d" translate="yes" xml:space="preserve">
          <source>Using ECMAScript6 generators feature to implement C# 5.0 &lt;code&gt;async/await&lt;/code&gt; like syntax.</source>
          <target state="translated">ECMAScript6ジェネレーター機能を使用して、C＃5.0の &lt;code&gt;async/await&lt;/code&gt; ような構文を実装します。</target>
        </trans-unit>
        <trans-unit id="acac6fbc07a16dd7002db7cd3b214125856ce811" translate="yes" xml:space="preserve">
          <source>Using an abstraction like this the &lt;code&gt;promisePrompt&lt;/code&gt; no longer needs to know anything about the DOM and concentrates on just providing a promise. This will also make things easier to create a promised version of a progress bar or confirmation dialog or any other type of UI that we want to have a value for. All we will need to do is write a class for that dialog type with the same interface and just pass that class into our promise making method.</source>
          <target state="translated">このような抽象化を使用すると、 &lt;code&gt;promisePrompt&lt;/code&gt; はDOMについて何も知る必要がなくなり、promiseの提供のみに集中します。これにより、プログレスバーや確認ダイアログの約束されたバージョンや、値を設定したい他のタイプのUIを簡単に作成できるようになります。必要なのは、同じインターフェイスを使用してそのダイアログタイプのクラスを記述し、そのクラスをPromise作成メソッドに渡すことだけです。</target>
        </trans-unit>
        <trans-unit id="92e2993e6dea235a7dcb1db5bb36202c8485dbc9" translate="yes" xml:space="preserve">
          <source>Using it:</source>
          <target state="translated">それを使って</target>
        </trans-unit>
        <trans-unit id="d829b44477e34c8358b0978984bdca898183bed9" translate="yes" xml:space="preserve">
          <source>Using jQuery after:</source>
          <target state="translated">jQueryを使った後のこと。</target>
        </trans-unit>
        <trans-unit id="c991e6de4c7c9ecea657f843e9921caf549f2112" translate="yes" xml:space="preserve">
          <source>Using jQuery before:</source>
          <target state="translated">以前のjQueryを使用しています。</target>
        </trans-unit>
        <trans-unit id="ee10eda3c3f21aee43203ae597d2c13cd07e6eea" translate="yes" xml:space="preserve">
          <source>Using legacy APIs (support starting from IE6+):</source>
          <target state="translated">レガシーAPIの利用(IE6+からのサポート)。</target>
        </trans-unit>
        <trans-unit id="51f995a28f75764b72a6c79dc89d54dd724921f6" translate="yes" xml:space="preserve">
          <source>Using manual resolver:</source>
          <target state="translated">手動レゾルバを使用しています。</target>
        </trans-unit>
        <trans-unit id="d99578b7705756deffc2aa58f6ae34fb2dbdb0c2" translate="yes" xml:space="preserve">
          <source>Using multiple resources:</source>
          <target state="translated">複数のリソースを使用しています。</target>
        </trans-unit>
        <trans-unit id="a3f65738b0a1c42c2a41e0b59a0029999f986703" translate="yes" xml:space="preserve">
          <source>Using no hooks and using &lt;a href=&quot;api/done&quot;&gt;&lt;code&gt;.done&lt;/code&gt;&lt;/a&gt; to manually to mark end points where rejections will not be handled</source>
          <target state="translated">フックを使用せず、&lt;a href=&quot;api/done&quot;&gt; &lt;code&gt;.done&lt;/code&gt; &lt;/a&gt;を使用して手動で拒否が処理されないエンドポイントをマークする</target>
        </trans-unit>
        <trans-unit id="678ad3a7449dc9211f664a6a26c9f4eeb83dd91e" translate="yes" xml:space="preserve">
          <source>Using no hooks and using &lt;a href=&quot;done&quot;&gt;&lt;code&gt;.done&lt;/code&gt;&lt;/a&gt; to manually to mark end points where rejections will not be handled</source>
          <target state="translated">フックを使用せず、&lt;a href=&quot;done&quot;&gt; &lt;code&gt;.done&lt;/code&gt; &lt;/a&gt;を使用して手動で拒否が処理されないエンドポイントをマークする</target>
        </trans-unit>
        <trans-unit id="7de8d54140fb8771440fc81fb18f3d53f9f6bb4f" translate="yes" xml:space="preserve">
          <source>Using recursion to implement the example from &lt;a href=&quot;https://github.com/caolan/async#whilsttest-fn-callback&quot;&gt;async homepage&lt;/a&gt;:</source>
          <target state="translated">再帰を使用して、&lt;a href=&quot;https://github.com/caolan/async#whilsttest-fn-callback&quot;&gt;非同期のホームページ&lt;/a&gt;から例を実装します。</target>
        </trans-unit>
        <trans-unit id="40c7e148244964ef32867f708db116db37aa2e23" translate="yes" xml:space="preserve">
          <source>Using the same function &lt;code&gt;Promise.method&lt;/code&gt;, there is no need to manually wrap direct return or throw values into a promise:</source>
          <target state="translated">同じ関数 &lt;code&gt;Promise.method&lt;/code&gt; を使用すると、直接の戻り値やスロー値を手動でプロミスにラップする必要がありません。</target>
        </trans-unit>
        <trans-unit id="fdf3b6cb551f8ba0a6b556e915881b1d2f0aa867" translate="yes" xml:space="preserve">
          <source>Using the value &lt;code&gt;0&lt;/code&gt; will explicitly disable a feature despite debug environment otherwise activating it:</source>
          <target state="translated">値 &lt;code&gt;0&lt;/code&gt; を使用すると、デバッグ環境に関係なく機能が明示的に無効になります。</target>
        </trans-unit>
        <trans-unit id="6642c87a17774c8b004c1431ca83c93a48edf11b" translate="yes" xml:space="preserve">
          <source>Using webpack for development/debugging:</source>
          <target state="translated">開発/デバッグにwebpackを使用しています。</target>
        </trans-unit>
        <trans-unit id="a94a8b8570fef0a3371781d1978a7c51f05ee4ff" translate="yes" xml:space="preserve">
          <source>Using webpack for production/performance:</source>
          <target state="translated">本番/パフォーマンスのためにwebpackを使う。</target>
        </trans-unit>
        <trans-unit id="89189507b2a074e98b2e877227343a6e1f27b3ab" translate="yes" xml:space="preserve">
          <source>Utility</source>
          <target state="translated">Utility</target>
        </trans-unit>
        <trans-unit id="02024b434dc6bfc227f2288a4656819d24c77710" translate="yes" xml:space="preserve">
          <source>Warn when &lt;a href=&quot;api/then&quot;&gt;&lt;code&gt;.then()&lt;/code&gt;&lt;/a&gt; is passed non-functions</source>
          <target state="translated">&lt;a href=&quot;api/then&quot;&gt; &lt;code&gt;.then()&lt;/code&gt; &lt;/a&gt;が関数以外に渡されたときに警告する</target>
        </trans-unit>
        <trans-unit id="76bc85fbac802c9c28a4f34074f76273aa28dba3" translate="yes" xml:space="preserve">
          <source>Warning Explanations</source>
          <target state="translated">警告の説明</target>
        </trans-unit>
        <trans-unit id="e326d603e8ef33a0ace61e8bd45d1476027c27c7" translate="yes" xml:space="preserve">
          <source>Warning: .then() only accepts functions</source>
          <target state="translated">警告:.then()は関数のみを受け付けます。</target>
        </trans-unit>
        <trans-unit id="2f253a4ff30df6ead65cd95ca2db9916033eb9d8" translate="yes" xml:space="preserve">
          <source>Warning: a promise was created in a handler but was not returned from it</source>
          <target state="translated">警告:ハンドラでプロミスが作成されましたが、そこから返されませんでした。</target>
        </trans-unit>
        <trans-unit id="5f19b7cfb75065744f09c3f3dbd1dd8602fb5742" translate="yes" xml:space="preserve">
          <source>Warning: a promise was rejected with a non-error</source>
          <target state="translated">警告:約束はエラーではなく拒否されました。</target>
        </trans-unit>
        <trans-unit id="1430f976c596795274458abcfbc4f280cbfcebac" translate="yes" xml:space="preserve">
          <source>Warnings</source>
          <target state="translated">Warnings</target>
        </trans-unit>
        <trans-unit id="f9b093958e9b93291eee426980c6f76c2af8380b" translate="yes" xml:space="preserve">
          <source>Warnings about created promises that are not returned are no longer given if the handler promise has not been chained. This should reduce the amount of false positives with this warning.</source>
          <target state="translated">ハンドラプロミスがチェーン化されていない場合、返されない作成されたプロミスに関する警告は、もはや与えられません。これにより、この警告による誤検知の量が減るはずです。</target>
        </trans-unit>
        <trans-unit id="987519cc8247ea08d785b3bed0d0edba12ab4768" translate="yes" xml:space="preserve">
          <source>Warnings have been added to report usages which are very likely to be programmer errors. See &lt;a href=&quot;api/promise.config&quot;&gt;&lt;code&gt;Promise.config&lt;/code&gt;&lt;/a&gt; for how to enable warnings. See &lt;a href=&quot;warning-explanations&quot;&gt;Warning Explanations&lt;/a&gt; for list of the warnings and their explanations.</source>
          <target state="translated">プログラマーのエラーである可能性が非常に高い使用状況を報告する警告が追加されました。警告を有効にする方法については、&lt;a href=&quot;api/promise.config&quot;&gt; &lt;code&gt;Promise.config&lt;/code&gt; &lt;/a&gt;を参照してください。&lt;a href=&quot;warning-explanations&quot;&gt;警告の&lt;/a&gt;リストとその説明については、警告の説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="2346b64bd2ceb68b2dd0fe9b356367b311b6a6a1" translate="yes" xml:space="preserve">
          <source>We can do better, retaining concurrency and not leaking resources, by using:</source>
          <target state="translated">並行性を保持し、リソースを流出させないように、より良い方法があります。</target>
        </trans-unit>
        <trans-unit id="d449d2a1898fdf6171ab397563a248fe80459a1d" translate="yes" xml:space="preserve">
          <source>We can use the promise constructor to convert it to a promise returning function:</source>
          <target state="translated">プロミスのコンストラクタを使って、プロミスを返す関数に変換することができます。</target>
        </trans-unit>
        <trans-unit id="0998ac30de0c1580642c82716276399b1c613149" translate="yes" xml:space="preserve">
          <source>We will want to keep the same API so our change will be only to the &lt;code&gt;promisePrompt&lt;/code&gt;. It will find the dialog DOM elements, attach events to the elements, show the dialog box, return a promise that is resolved based on the attached events, and finally detaches the events and cleans up after itself (hiding the dialog box for another use later).</source>
          <target state="translated">同じAPIを保持したいので、変更は &lt;code&gt;promisePrompt&lt;/code&gt; に対してのみ行います。ダイアログDOM要素を見つけ、要素にイベントをアタッチし、ダイアログボックスを表示し、アタッチされたイベントに基づいて解決されるプロミスを返し、最後にイベントを切り離してクリーンアップします（後で別の目的でダイアログボックスを非表示にする） ）。</target>
        </trans-unit>
        <trans-unit id="86974e9cfd94347a9d8035a721441882b61e40c8" translate="yes" xml:space="preserve">
          <source>We'll cover several subjects. If you want to get the tl;dr what you need is likely the &lt;a href=&quot;#working-with-callback-apis-using-the-node-convention&quot;&gt;Working with callback APIs using the Node convention&lt;/a&gt; section.</source>
          <target state="translated">いくつかの主題を取り上げます。tl; drを取得したい場合は&lt;a href=&quot;#working-with-callback-apis-using-the-node-convention&quot;&gt;、「ノードの規則の&lt;/a&gt;セクションを使用したコールバックAPIの操作」がおそらく必要です。</target>
        </trans-unit>
        <trans-unit id="41b24863fa5a051446f6f2ae3860594cb7d071eb" translate="yes" xml:space="preserve">
          <source>Well simply, when you have to.</source>
          <target state="translated">まあ、簡単に言えば、必要な時に。</target>
        </trans-unit>
        <trans-unit id="f8c4fdd7823278887156d018b49c43e024631c27" translate="yes" xml:space="preserve">
          <source>What About Generators?</source>
          <target state="translated">ジェネレーターはどうなの?</target>
        </trans-unit>
        <trans-unit id="30a484e5211183ba2cee4378c92b44d3105eeaf7" translate="yes" xml:space="preserve">
          <source>What about promises that have multiple consumers?</source>
          <target state="translated">複数の消費者がいるプロミスは?</target>
        </trans-unit>
        <trans-unit id="6b7c4ebe4c5f3bfe7fb62f4c2a84779817b88487" translate="yes" xml:space="preserve">
          <source>What actually happens is that &lt;code&gt;result&lt;/code&gt; keeps track of how many consumers it has, in this case 2, and only if all the consumers signal cancel will the request be aborted. However, as far as &lt;code&gt;firstConsumer&lt;/code&gt; can tell, the promise was successfully cancelled and its handlers will not be called.</source>
          <target state="translated">実際に何が起こるかというと、 &lt;code&gt;result&lt;/code&gt; はそれが持っているコンシューマの数（この場合は2）を追跡し続け、すべてのコンシューマがキャンセルを通知した場合にのみ、リクエストは中止されます。ただし、 &lt;code&gt;firstConsumer&lt;/code&gt; が確認できる限り、promiseは正常にキャンセルされ、そのハンドラーは呼び出されません。</target>
        </trans-unit>
        <trans-unit id="07c519ceae2b771a7ddeac59daf39ed209a19525" translate="yes" xml:space="preserve">
          <source>What is the the point of promises</source>
          <target state="translated">約束のポイントとは</target>
        </trans-unit>
        <trans-unit id="56aab8af41c28bb5f9c760d67856cb60689f1c68" translate="yes" xml:space="preserve">
          <source>What's new in 2.0</source>
          <target state="translated">2.0の新機能</target>
        </trans-unit>
        <trans-unit id="b2223542269901e7186ce7f97c69174f8009c3e4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;NODE_ENV&lt;/code&gt; environment variable is &lt;code&gt;&quot;development&quot;&lt;/code&gt; setting &lt;code&gt;BLUEBIRD_DEBUG&lt;/code&gt; environment variable to &lt;code&gt;0&lt;/code&gt; can now be used to disable debug mode</source>
          <target state="translated">とき &lt;code&gt;NODE_ENV&lt;/code&gt; の環境変数がある &lt;code&gt;&quot;development&quot;&lt;/code&gt; の設定 &lt;code&gt;BLUEBIRD_DEBUG&lt;/code&gt; のに環境変数を &lt;code&gt;0&lt;/code&gt; になりまし無効にデバッグモードに使用することができます</target>
        </trans-unit>
        <trans-unit id="268de3a5addf552f9cb9505acf541fb1a6c7d1c4" translate="yes" xml:space="preserve">
          <source>When called, the coroutine function will start an instance of the generator and returns a promise for its final value.</source>
          <target state="translated">呼び出されると、コアーチン関数はジェネレーターのインスタンスを開始し、その最終値の約束を返します。</target>
        </trans-unit>
        <trans-unit id="abcda78ef2264e69cff0163a190c8f4b357591ac" translate="yes" xml:space="preserve">
          <source>When chaining &lt;code&gt;.spread&lt;/code&gt;, returning an array of promises also works:</source>
          <target state="translated">&lt;code&gt;.spread&lt;/code&gt; をチェーンするとき、promiseの配列を返すこともできます：</target>
        </trans-unit>
        <trans-unit id="b6c0e36e057ee58c2317285366278f58808242b8" translate="yes" xml:space="preserve">
          <source>When debugging or performing a one-time operation on a variable before passing it to a function, a return variable is forgotten.</source>
          <target state="translated">デバッグや関数に渡す前に変数に対して一度だけの操作を行う場合、戻り値の変数は忘れられてしまいます。</target>
        </trans-unit>
        <trans-unit id="64d8621b03578f1c94ccc629a4cc7c4de3a568ed" translate="yes" xml:space="preserve">
          <source>When there are asynchronous tasks that have the ability to notify progress as they complete it can be tempting to want that in the promise that represents that task. Unfortunately this is a bit of an anti-pattern. That is because the point of promises is to represent a value as if it was natural (like it is in normal synchronous code) and not to be over glorified callback management.</source>
          <target state="translated">非同期タスクがあって、完了したときに進捗状況を通知する機能を持っている場合、そのタスクを表すプロミスの中にそれを入れたいと思うかもしれません。残念ながら、これは少し反パターンです。なぜなら、プロミスのポイントは、(通常の同期コードのように)自然な値を表現することであり、コールバック管理のような派手なものではないからです。</target>
        </trans-unit>
        <trans-unit id="b3f5f46aab39a3a9a507394c2c440bab65f0ea48" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;longStackTraces&lt;/code&gt; the first line in your code after requiring Bluebird should be:</source>
          <target state="translated">&lt;code&gt;longStackTraces&lt;/code&gt; を使用する場合、Bluebirdを要求した後のコードの最初の行は次のようになります。</target>
        </trans-unit>
        <trans-unit id="b9be79b81b6d65c3ed9b6fe0e6688b7fd74367ea" translate="yes" xml:space="preserve">
          <source>When using script tags the global variables &lt;code&gt;Promise&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; (alias for &lt;code&gt;Promise&lt;/code&gt;) become available. Bluebird runs on a wide variety of browsers including older versions. We'd like to thank BrowserStack for giving us a free account which helps us test that.</source>
          <target state="translated">スクリプトタグを使用すると、グローバル変数 &lt;code&gt;Promise&lt;/code&gt; および &lt;code&gt;P&lt;/code&gt; （ &lt;code&gt;Promise&lt;/code&gt; のエイリアス）が使用可能になります。Bluebirdは、古いバージョンを含むさまざまなブラウザで動作します。テストに役立つ無料のアカウントを提供してくれたBrowserStackに感謝します。</target>
        </trans-unit>
        <trans-unit id="4a2fe4cb42752a52e254b8a6bf3ceb42b7e1ac55" translate="yes" xml:space="preserve">
          <source>When using the first signature, you may specify a custom error message with the &lt;code&gt;message&lt;/code&gt; parameter.</source>
          <target state="translated">最初の署名を使用する場合は、 &lt;code&gt;message&lt;/code&gt; パラメータを使用してカスタムエラーメッセージを指定できます。</target>
        </trans-unit>
        <trans-unit id="25f41737292fcc0beb27bde5ba12d4c02e4d5a28" translate="yes" xml:space="preserve">
          <source>When we construct our &lt;code&gt;ProgressDialog&lt;/code&gt; we use the &lt;code&gt;waitForUser()&lt;/code&gt; method to capture the user interaction promise and then use &lt;code&gt;delayedPromise()&lt;/code&gt; to capture the fake network promise and finally &lt;code&gt;Promise.reace()&lt;/code&gt; to manage the two simultaneously and end with a single promise as usual.</source>
          <target state="translated">&lt;code&gt;ProgressDialog&lt;/code&gt; を作成するときは、 &lt;code&gt;waitForUser()&lt;/code&gt; メソッドを使用してユーザーインタラクションプロミスを取得し、 &lt;code&gt;delayedPromise()&lt;/code&gt; を使用して偽のネットワークプロミスを取得し、最後に &lt;code&gt;Promise.reace()&lt;/code&gt; を使用して2つを同時に管理し、通常どおり1つのプロミスで終了します。 。</target>
        </trans-unit>
        <trans-unit id="294f81c22475eef4fbaab8c79a52c780d37a7f28" translate="yes" xml:space="preserve">
          <source>When working with promises the philosophy is basically a complete opposite than when using &lt;code&gt;async&lt;/code&gt;. Async provides a huge bag of uncomposable helper functions that work at a very low level of abstraction. When using promises you can get the utility otherwise provided by uncountable amount of inflexible helper functions by just combining and composing a few existing functions and concepts.</source>
          <target state="translated">promiseを操作するときの哲学は、基本的に &lt;code&gt;async&lt;/code&gt; を使用するときとは正反対です。Asyncは、非常に低レベルの抽象化で機能する、分解できないヘルパー関数の巨大なバッグを提供します。promiseを使用すると、いくつかの既存の関数と概念を組み合わせて構成するだけで、無数の柔軟性のないヘルパー関数によって提供されるユーティリティを取得できます。</target>
        </trans-unit>
        <trans-unit id="aa0d63ddeca860f4dd0ee04e6e6dfb59036ec440" translate="yes" xml:space="preserve">
          <source>Where blocking on a Future in scala is discouraged, in JavaScript it's downright impossible.</source>
          <target state="translated">scalaのFutureでのブロッキングは推奨されていませんが、JavaScriptでは全く不可能です。</target>
        </trans-unit>
        <trans-unit id="a04b5cdd0c9e7373883bf0306180ab9eff2c21cc" translate="yes" xml:space="preserve">
          <source>Which is needed in case error handlers are attached asynchronously to the promise later, which would otherwise result in premature unhandled rejection reporting.</source>
          <target state="translated">これは、エラーハンドラが後で非同期的にプロミスにアタッチされる場合に必要です。</target>
        </trans-unit>
        <trans-unit id="eee12cfe2d4a58cb2a6fc803d3775440ef97f722" translate="yes" xml:space="preserve">
          <source>Which would allow you to use:</source>
          <target state="translated">どっちを使えばいいんだ?</target>
        </trans-unit>
        <trans-unit id="35d4fe62a5e87bc7beed2b0eec9121835e2b2243" translate="yes" xml:space="preserve">
          <source>Which would let you do:</source>
          <target state="translated">あなたにさせてくれるでしょう。</target>
        </trans-unit>
        <trans-unit id="048203462f9f2ccf893052bbc1b4ea9379b53188" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;cancel().&lt;/code&gt; is synchronous - &lt;code&gt;onCancel()&lt;/code&gt; is called asynchronously (in the next turn) just like &lt;code&gt;then&lt;/code&gt; handlers.</source>
          <target state="translated">一方で &lt;code&gt;cancel().&lt;/code&gt; 同期です &lt;code&gt;onCancel()&lt;/code&gt; は &lt;code&gt;then&lt;/code&gt; ハンドラーと同じように非同期に（次のターンで）呼び出されます。</target>
        </trans-unit>
        <trans-unit id="50051d4da0ca7d94943f9fa9969394e5949e12c1" translate="yes" xml:space="preserve">
          <source>While with long stack traces disabled, you would get:</source>
          <target state="translated">長いスタックトレースを無効にしている間は、あなたは得るでしょう。</target>
        </trans-unit>
        <trans-unit id="a448f3eb7ee54eee8b460fbecc359153bf18d65f" translate="yes" xml:space="preserve">
          <source>Why I am switching to promises</source>
          <target state="translated">私がプロミスに切り替える理由</target>
        </trans-unit>
        <trans-unit id="1472dbb2e195b22057a90d66f7a65b38461e79ba" translate="yes" xml:space="preserve">
          <source>Why Performance?</source>
          <target state="translated">なぜパフォーマンス?</target>
        </trans-unit>
        <trans-unit id="103997b340ba267b74ce431e1b85c8fb216b7d7d" translate="yes" xml:space="preserve">
          <source>Why Promises?</source>
          <target state="translated">なぜプロミスなのか?</target>
        </trans-unit>
        <trans-unit id="7eed14a899fe9a4d5bf8f80b6404d95efa7b1db8" translate="yes" xml:space="preserve">
          <source>Why bluebird?</source>
          <target state="translated">なぜブルーバード?</target>
        </trans-unit>
        <trans-unit id="0f975858c19a385aa9526530dd08a5074375be2f" translate="yes" xml:space="preserve">
          <source>With the use of abstract classes can the similarities between &lt;code&gt;PromptDialog&lt;/code&gt; and &lt;code&gt;NotifyDialog&lt;/code&gt; be abstracted? Make a sub class of &lt;code&gt;Dialog&lt;/code&gt; that abstracts the common DOM code (&lt;code&gt;DOMDialog&lt;/code&gt;). Then refactor the &lt;code&gt;PromptDialog&lt;/code&gt; and &lt;code&gt;NotifyDialog&lt;/code&gt; to inherate from &lt;code&gt;DOMDialog&lt;/code&gt; but references the correct DOM selectors.</source>
          <target state="translated">抽象クラスを使用すると、 &lt;code&gt;PromptDialog&lt;/code&gt; と &lt;code&gt;NotifyDialog&lt;/code&gt; の類似点を抽象化できますか？サブクラス作り &lt;code&gt;Dialog&lt;/code&gt; 共通DOMコード（抽象化 &lt;code&gt;DOMDialog&lt;/code&gt; を）。次に、 &lt;code&gt;PromptDialog&lt;/code&gt; および &lt;code&gt;NotifyDialog&lt;/code&gt; をリファクタリングしてDOMDialogから &lt;code&gt;DOMDialog&lt;/code&gt; が、正しいDOMセレクターを参照します。</target>
        </trans-unit>
        <trans-unit id="b389c6872f328b7947b20ae5c017fe2c10bb9526" translate="yes" xml:space="preserve">
          <source>Without arrow functions that provide lexical &lt;code&gt;this&lt;/code&gt;, the correspondence between async and sync code breaks down when writing object-oriented code. &lt;a href=&quot;bind&quot;&gt;&lt;code&gt;.bind&lt;/code&gt;&lt;/a&gt; alleviates this.</source>
          <target state="translated">字句 &lt;code&gt;this&lt;/code&gt; を提供するアロー関数がないと、オブジェクト指向コードを記述するときに、非同期コードと同期コードの対応が崩れます。&lt;a href=&quot;bind&quot;&gt; &lt;code&gt;.bind&lt;/code&gt; は&lt;/a&gt;これを軽減します。</target>
        </trans-unit>
        <trans-unit id="673b91ef144006953b2d0d3e1f31a66ba0a792bd" translate="yes" xml:space="preserve">
          <source>Working with Callbacks</source>
          <target state="translated">コールバックでの作業</target>
        </trans-unit>
        <trans-unit id="4814f16d83ce4c03a7697dffe837dd35ff625c3c" translate="yes" xml:space="preserve">
          <source>Working with any other APIs</source>
          <target state="translated">他のAPIとの連携</target>
        </trans-unit>
        <trans-unit id="d5431ac75df408d5c9ffc310217a12d8d9dcbf00" translate="yes" xml:space="preserve">
          <source>Working with browser APIs</source>
          <target state="translated">ブラウザAPIを使った作業</target>
        </trans-unit>
        <trans-unit id="e3c2aac0738162450c1ba5ec6b637d0caf73d2e1" translate="yes" xml:space="preserve">
          <source>Working with callback APIs using the Node convention</source>
          <target state="translated">Node の規約を使用してコールバック API を操作する</target>
        </trans-unit>
        <trans-unit id="37dd709d1ccc2e12457cf6c183d0dbd315ee98c2" translate="yes" xml:space="preserve">
          <source>Working with databases</source>
          <target state="translated">データベースでの作業</target>
        </trans-unit>
        <trans-unit id="f06f929d4baa5a3ecf78b00957e3722d031a73c3" translate="yes" xml:space="preserve">
          <source>Working with delays</source>
          <target state="translated">遅延を利用した作業</target>
        </trans-unit>
        <trans-unit id="5122dff991374514454140bce7e200af64069d8d" translate="yes" xml:space="preserve">
          <source>Working with delays/setTimeout</source>
          <target state="translated">遅延の処理/setTimeout</target>
        </trans-unit>
        <trans-unit id="a1c7659f3ee1ffff84437f6bd7a29c13e55a9375" translate="yes" xml:space="preserve">
          <source>Working with one time events</source>
          <target state="translated">1回限りのイベントでの作業</target>
        </trans-unit>
        <trans-unit id="37316c9a58ae41ce75652d0e2a54b3a2feb756f2" translate="yes" xml:space="preserve">
          <source>Working with one time events.</source>
          <target state="translated">1回限りのイベントでの作業。</target>
        </trans-unit>
        <trans-unit id="8b04f9b661548e262a9e539e7d756bac07782fea" translate="yes" xml:space="preserve">
          <source>Write a function that takes a &lt;code&gt;Dialog&lt;/code&gt; instance and a default value. Have it return a promise that resolves to the default value if the user clicks cancel.</source>
          <target state="translated">&lt;code&gt;Dialog&lt;/code&gt; インスタンスとデフォルト値を受け取る関数を記述します。ユーザーが[キャンセル]をクリックした場合にデフォルト値に解決されるプロミスを返すようにします。</target>
        </trans-unit>
        <trans-unit id="0cf07d9d6990a0b3a8a806a431339f0ecf271176" translate="yes" xml:space="preserve">
          <source>Yield handlers are called when you yield something that is not supported by default. The first yield handler to return a promise or a thenable will be used. If no yield handler returns a promise or a thenable then an error is raised.</source>
          <target state="translated">yield ハンドラは、デフォルトではサポートされていない何かを返すときに呼び出されます。最初の降伏ハンドラがプロミスやその時対応可能な値を返したときに使用されます。もし yield ハンドラがプロミスや thenable を返さなかった場合は、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="cb668cd94f8eca0b469371342b38d09219dbd2d0" translate="yes" xml:space="preserve">
          <source>Yielding an array from a coroutine is not supported by default. You can use &lt;a href=&quot;api/coroutine.addyieldhandler&quot;&gt;&lt;code&gt;coroutine.addYieldHandler()&lt;/code&gt;&lt;/a&gt; to configure the old behavior (or any behavior you want).</source>
          <target state="translated">コルーチンからの配列の生成は、デフォルトではサポートされていません。あなたは使用することができます&lt;a href=&quot;api/coroutine.addyieldhandler&quot;&gt; &lt;code&gt;coroutine.addYieldHandler()&lt;/code&gt; を&lt;/a&gt;以前の動作（またはあなたが望む任意の動作）を設定します。</target>
        </trans-unit>
        <trans-unit id="b43584c4df9052974185d0f13b0565b92e014095" translate="yes" xml:space="preserve">
          <source>You are able to yield non-promise values by adding your own yield handler using &lt;a href=&quot;promise.coroutine.addyieldhandler&quot;&gt;&lt;code&gt;Promise.coroutine.addYieldHandler&lt;/code&gt;&lt;/a&gt; or calling &lt;code&gt;Promise.coroutine()&lt;/code&gt; with a yield handler function as &lt;code&gt;options.yieldHandler&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;promise.coroutine.addyieldhandler&quot;&gt; &lt;code&gt;Promise.coroutine.addYieldHandler&lt;/code&gt; &lt;/a&gt;を使用して独自のイールドハンドラーを追加するか、 &lt;code&gt;options.yieldHandler&lt;/code&gt; としてイールドハンドラー関数を使用して &lt;code&gt;Promise.coroutine()&lt;/code&gt; を呼び出すことにより、非プロミス値を生成できます。</target>
        </trans-unit>
        <trans-unit id="e127999f42b63c2eddd476b0efc6c0cd617fe5c2" translate="yes" xml:space="preserve">
          <source>You are getting this error because you are enabling long stack traces after a promise has already been created.</source>
          <target state="translated">このエラーが発生しているのは、すでにプロミスが作成された後に長いスタックトレースを有効にしているためです。</target>
        </trans-unit>
        <trans-unit id="bf62350a61d792a4742ad486033ffd83aaf0f56d" translate="yes" xml:space="preserve">
          <source>You are getting this error because you have tried to &lt;code&gt;yield&lt;/code&gt; something in a coroutine without a yield handler, for example:</source>
          <target state="translated">たとえば、yieldハンドラを使用せずにコルーチンで何かを &lt;code&gt;yield&lt;/code&gt; しようとしたため、このエラーが発生しています。</target>
        </trans-unit>
        <trans-unit id="66ca93bb6eb46f59e659c6e2ebfd242ff1f0e6ac" translate="yes" xml:space="preserve">
          <source>You are getting this error when trying to use &lt;a href=&quot;api/promise.coroutine&quot;&gt;&lt;code&gt;Promise.coroutine&lt;/code&gt;&lt;/a&gt; and not passing it a generator function as a parameter. For example:</source>
          <target state="translated">&lt;a href=&quot;api/promise.coroutine&quot;&gt; &lt;code&gt;Promise.coroutine&lt;/code&gt; &lt;/a&gt;を使用しようとして、ジェネレーター関数をパラメーターとして渡さないと、このエラーが発生します。例えば：</target>
        </trans-unit>
        <trans-unit id="91785a774efe083e20f0a926f490793891f37e71" translate="yes" xml:space="preserve">
          <source>You can also pass the resources in an array in the first argument. In this case the handler function will only be called with one argument that is the array containing the resolved resources in respective positions in the array. Example:</source>
          <target state="translated">第一引数に配列内のリソースを渡すこともできます。この場合、ハンドラ関数は、配列内のそれぞれの位置にある解決済みのリソースを含む配列を一つの引数としてのみ呼び出されます。例</target>
        </trans-unit>
        <trans-unit id="e1e28c9edbfac1286ca67380518a1038c18f9339" translate="yes" xml:space="preserve">
          <source>You can also refactor some looping patterns to a more natural form that would &lt;a href=&quot;https://github.com/promises-aplus/promises-spec/issues/179&quot;&gt;leak memory when using native promises&lt;/a&gt;.</source>
          <target state="translated">一部のループパターンをより自然な形式にリファクタリングして、&lt;a href=&quot;https://github.com/promises-aplus/promises-spec/issues/179&quot;&gt;ネイティブプロミスを使用するとメモリリーク&lt;/a&gt;を引き起こすこともできます。</target>
        </trans-unit>
        <trans-unit id="437864fc7461809f33ab9ef10e2c5d258352b129" translate="yes" xml:space="preserve">
          <source>You can also use it as a hook:</source>
          <target state="translated">フックとしても使えます。</target>
        </trans-unit>
        <trans-unit id="5c5b397ce7d92f145be04aede9a7905dd3a775cc" translate="yes" xml:space="preserve">
          <source>You can also use promises to improve code that was written with callbacks:</source>
          <target state="translated">また、コールバックで書かれたコードを改善するためにプロミスを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="283713c3baaf7fbedb1d299415d2545b4024ca50" translate="yes" xml:space="preserve">
          <source>You can change bluebird behavior globally with various environment variables. These global variables affect all instances of bluebird that are running in your environment, rather than just the one you have &lt;code&gt;require&lt;/code&gt;d in your application. The effect an environment variable has depends on the bluebird version.</source>
          <target state="translated">ブルーバードの動作は、さまざまな環境変数でグローバルに変更できます。これらのグローバル変数は、アプリケーションで &lt;code&gt;require&lt;/code&gt; インスタンスだけでなく、環境で実行されているbluebirdのすべてのインスタンスに影響します。環境変数の影響は、bluebirdのバージョンによって異なります。</target>
        </trans-unit>
        <trans-unit id="06b2e22d4bf3505ebf9bddb84ee0510239a546e0" translate="yes" xml:space="preserve">
          <source>You can configure the warning for checking forgotten return statements with &lt;code&gt;wForgottenReturn&lt;/code&gt;:</source>
          <target state="translated">あなたが忘れてしまったreturn文を確認するための警告を設定することができ &lt;code&gt;wForgottenReturn&lt;/code&gt; を：</target>
        </trans-unit>
        <trans-unit id="f5a9baad84a48a76541ea70044c4acc58a16ccf2" translate="yes" xml:space="preserve">
          <source>You can correct this by doing:</source>
          <target state="translated">することで修正することができます。</target>
        </trans-unit>
        <trans-unit id="81293703b0f372c4f1dd8c1c5f5f64e0b6876c85" translate="yes" xml:space="preserve">
          <source>You can get a reference to &lt;a href=&quot;aggregateerror&quot;&gt;&lt;code&gt;AggregateError&lt;/code&gt;&lt;/a&gt; from &lt;code&gt;Promise.AggregateError&lt;/code&gt;.</source>
          <target state="translated">あなたはへの参照を取得することができます&lt;a href=&quot;aggregateerror&quot;&gt; &lt;code&gt;AggregateError&lt;/code&gt; &lt;/a&gt;から &lt;code&gt;Promise.AggregateError&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="1fa9ba97c4236ec4af4790e170f1a3227c61dec4" translate="yes" xml:space="preserve">
          <source>You can get this error for several reasons:</source>
          <target state="translated">このエラーはいくつかの理由で発生します。</target>
        </trans-unit>
        <trans-unit id="ef442967cec8981710fc742773b5611ef039af93" translate="yes" xml:space="preserve">
          <source>You can get this error when you're trying to call &lt;code&gt;.value&lt;/code&gt; or &lt;code&gt;.error&lt;/code&gt; when inspecting a promise where the promise has not been fulfilled or rejected yet.</source>
          <target state="translated">このエラーは、Promiseがまだ満たされていないか拒否されているPromiseを検査するときに &lt;code&gt;.value&lt;/code&gt; または &lt;code&gt;.error&lt;/code&gt; を呼び出そうとすると発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="6f5a4a44a59a1f96bff1bedb0c04a482fd574dd1" translate="yes" xml:space="preserve">
          <source>You can promisify multiple classes in one go by constructing an array out of the classes and passing it to &lt;code&gt;promisifyAll&lt;/code&gt;:</source>
          <target state="translated">クラスから配列を作成し、それを &lt;code&gt;promisifyAll&lt;/code&gt; に渡すことで、一度に複数のクラスを約束することができます。</target>
        </trans-unit>
        <trans-unit id="a9fb5d736e0ab6fce975e6a9b34a4fef475d7bc7" translate="yes" xml:space="preserve">
          <source>You got this error because you used &lt;code&gt;new Promise()&lt;/code&gt; or &lt;code&gt;new Promise(something)&lt;/code&gt; without passing a function as the parameter.</source>
          <target state="translated">パラメータとして関数を渡さずに &lt;code&gt;new Promise()&lt;/code&gt; または &lt;code&gt;new Promise(something)&lt;/code&gt; を使用したため、このエラーが発生しました。</target>
        </trans-unit>
        <trans-unit id="a4d97ed3b9b528f072b3b9ef916af019f8c658c3" translate="yes" xml:space="preserve">
          <source>You got this this error because you've used &lt;code&gt;Promise.promisify&lt;/code&gt; on an object, for example:</source>
          <target state="translated">たとえば、オブジェクトで &lt;code&gt;Promise.promisify&lt;/code&gt; を使用したため、このエラーが発生しました。</target>
        </trans-unit>
        <trans-unit id="9ca3543e4c8b58e9db66720a46ab1377349e2f9b" translate="yes" xml:space="preserve">
          <source>You may also add multiple filters for a catch handler:</source>
          <target state="translated">また、キャッチハンドラに複数のフィルタを追加することもできます。</target>
        </trans-unit>
        <trans-unit id="83847d072bb765ac14ac4e083fdf4b485ddcd196" translate="yes" xml:space="preserve">
          <source>You may also use the custom suffix option to choose another suffix that doesn't result in conflicts.</source>
          <target state="translated">また、カスタムサフィックスオプションを使用して、競合しない別のサフィックスを選択することもできます。</target>
        </trans-unit>
        <trans-unit id="6624c3c603bb59caba6a82386be7841487cbe7f2" translate="yes" xml:space="preserve">
          <source>You may now return promises and thenables from the filterer function used in &lt;code&gt;Promise.filter&lt;/code&gt; and &lt;code&gt;Promise.prototype.filter&lt;/code&gt;.</source>
          <target state="translated">これで、 &lt;code&gt;Promise.filter&lt;/code&gt; と &lt;code&gt;Promise.prototype.filter&lt;/code&gt; で使用されるfilterer関数からpromiseとthenablesを返すことができます。</target>
        </trans-unit>
        <trans-unit id="05e60416b3790827596a6ef7f2cab94aae07bff3" translate="yes" xml:space="preserve">
          <source>You may optionally prepend one predicate function or ErrorClass to pattern match the error (the generic &lt;a href=&quot;catch&quot;&gt;&lt;code&gt;.catch&lt;/code&gt;&lt;/a&gt; methods accepts multiple)</source>
          <target state="translated">オプションで、1つの述語関数またはErrorClassを前に付加して、エラーにパターンマッチングすることができます（一般的な&lt;a href=&quot;catch&quot;&gt; &lt;code&gt;.catch&lt;/code&gt; &lt;/a&gt;メソッドは複数を受け入れます）。</target>
        </trans-unit>
        <trans-unit id="4dea303545fcf8fcdea34efebeca4ef1c0a6fbdc" translate="yes" xml:space="preserve">
          <source>You may optionally specify a concurrency limit:</source>
          <target state="translated">オプションで同時実行の制限を指定することができます。</target>
        </trans-unit>
        <trans-unit id="1f96ba6d073dbbb822c6dc38156f5d2c778c3e34" translate="yes" xml:space="preserve">
          <source>You may register an optional cancellation hook at a root promise by using the &lt;code&gt;onCancel&lt;/code&gt; argument that is passed to the executor function when cancellation is enabled:</source>
          <target state="translated">キャンセルが有効になっているときにexecutor関数に渡される &lt;code&gt;onCancel&lt;/code&gt; 引数を使用して、オプションのキャンセルフックをルートプロミスに登録できます。</target>
        </trans-unit>
        <trans-unit id="da7c4c4ceabe5cd66746addf080121cd0177cb25" translate="yes" xml:space="preserve">
          <source>You may use &lt;a href=&quot;api/promise.setscheduler&quot;&gt;&lt;code&gt;Promise.setScheduler&lt;/code&gt;&lt;/a&gt; to pass a custom scheduler that your environment supports. For example in DukTape:</source>
          <target state="translated">&lt;a href=&quot;api/promise.setscheduler&quot;&gt; &lt;code&gt;Promise.setScheduler&lt;/code&gt; &lt;/a&gt;を使用して、環境がサポートするカスタムスケジューラを渡すことができます。たとえばDukTapeの場合：</target>
        </trans-unit>
        <trans-unit id="72d529e0be153c472000cf98a0b7d4552852d11f" translate="yes" xml:space="preserve">
          <source>You may use browserify on the main export</source>
          <target state="translated">メインのエクスポートでは、ブラウザを使用することができます。</target>
        </trans-unit>
        <trans-unit id="5178ce348175a2d6a2e16b69f6aa6c59ef943a40" translate="yes" xml:space="preserve">
          <source>You may use the &lt;a href=&quot;http://bower.io&quot;&gt;bower&lt;/a&gt; package.</source>
          <target state="translated">&lt;a href=&quot;http://bower.io&quot;&gt;bower&lt;/a&gt;パッケージを使用できます。</target>
        </trans-unit>
        <trans-unit id="79662f72fb448baebdf8a6c7d0131a375dff4095" translate="yes" xml:space="preserve">
          <source>You might have to use a deferred object when wrapping a callback API that doesn't follow the standard convention. Like &lt;code&gt;setTimeout&lt;/code&gt;:</source>
          <target state="translated">標準の規則に従わないコールバックAPIをラップするときは、遅延オブジェクトを使用する必要がある場合があります。同様 &lt;code&gt;setTimeout&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c2ac050d03d9c2bd58543cfcee398d79f07ec7bc" translate="yes" xml:space="preserve">
          <source>You might notice that the promise approach looks very similar to using synchronous I/O:</source>
          <target state="translated">プロミスのアプローチが同期I/Oを使用するのと非常に似ていることに気づくかもしれません。</target>
        </trans-unit>
        <trans-unit id="a07914b7b08162442f33327417b0ff4a50f4409e" translate="yes" xml:space="preserve">
          <source>You passed a non-function where a function was expected.</source>
          <target state="translated">関数が期待されるところに非関数を渡しました。</target>
        </trans-unit>
        <trans-unit id="cc81677e43359861a52ce63568e3d792c6bcee22" translate="yes" xml:space="preserve">
          <source>You should check if this promise is &lt;a href=&quot;isfulfilled&quot;&gt;&lt;code&gt;.isFulfilled()&lt;/code&gt;&lt;/a&gt; in code paths where it's not guaranteed that this promise is fulfilled.</source>
          <target state="translated">このプロミスが満たされていることが保証されていないコードパスで、このプロミスが&lt;a href=&quot;isfulfilled&quot;&gt; &lt;code&gt;.isFulfilled()&lt;/code&gt; &lt;/a&gt;であるかどうかを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="88143ae7a4624ccb7145716c9f902897a88d096d" translate="yes" xml:space="preserve">
          <source>You should check if this promise is &lt;a href=&quot;isrejected&quot;&gt;&lt;code&gt;.isRejected()&lt;/code&gt;&lt;/a&gt; in code paths where it's guaranteed that this promise is rejected.</source>
          <target state="translated">このプロミスが拒否されることが保証されているコードパスで、このプロミスが&lt;a href=&quot;isrejected&quot;&gt; &lt;code&gt;.isRejected()&lt;/code&gt; &lt;/a&gt;であるかどうかを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="a5bc1b292604f8a755bedb0d6bdc5baa78c79e97" translate="yes" xml:space="preserve">
          <source>You should enabled long stack traces if you want better debugging experience. For example:</source>
          <target state="translated">より良いデバッグをしたいのであれば、長いスタックトレースを有効にしてください。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="9389a4bd5323ad51b671d2380af345d329495a0f" translate="yes" xml:space="preserve">
          <source>You should heed this warning because rejecting a promise with a non-error makes debugging extremely hard and costly. Additionally, if you reject with simple primitives such as &lt;code&gt;undefined&lt;/code&gt; (commonly caused by simply calling &lt;code&gt;reject()&lt;/code&gt;) you cannot handle errors at all because it's impossible to tell from &lt;code&gt;undefined&lt;/code&gt; what exactly went wrong. All you can tell the user is that &quot;something went wrong&quot; and lose them forever.</source>
          <target state="translated">エラーなしでプロミスを拒否するとデバッグが非常に困難でコストがかかるため、この警告に注意する必要があります。さらに、 &lt;code&gt;undefined&lt;/code&gt; などの単純なプリミティブで拒否する場合（通常は単純に &lt;code&gt;reject()&lt;/code&gt; を呼び出すことによって引き起こされます）、 &lt;code&gt;undefined&lt;/code&gt; から正確に何が問題だったかを判断できないため、エラーをまったく処理できません。ユーザーにわかるのは、「何かがうまくいかなかった」ということだけであり、それらを永久に失います。</target>
        </trans-unit>
        <trans-unit id="ee7d769e258faced0824e928a0c2037e1a245676" translate="yes" xml:space="preserve">
          <source>You should use promises to turn this:</source>
          <target state="translated">これを回すためにはプロミスを使うべきです。</target>
        </trans-unit>
        <trans-unit id="3801444ae548127f53972d4de9db926d35147429" translate="yes" xml:space="preserve">
          <source>Your library can then use &lt;code&gt;var Promise = require(&quot;bluebird-extended&quot;);&lt;/code&gt; and do whatever it wants with it. Then if the application or other library uses their own bluebird promises they will all play well together because of Promises/A+ thenable assimilation magic.</source>
          <target state="translated">ライブラリは &lt;code&gt;var Promise = require(&quot;bluebird-extended&quot;);&lt;/code&gt; 使用できます。そして、それでやりたいことを何でもします。次に、アプリケーションまたは他のライブラリが独自のブルーバードプロミスを使用する場合、Promises / A +の同化可能な魔法のため、それらはすべてうまく連携します。</target>
        </trans-unit>
        <trans-unit id="2ea5d7794d32ab52b93c85c9e6c21b1aea324d24" translate="yes" xml:space="preserve">
          <source>because &lt;code&gt;data&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt; at the time &lt;code&gt;.return&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;.return&lt;/code&gt; が呼び出された時点では &lt;code&gt;data&lt;/code&gt; が &lt;code&gt;undefined&lt;/code&gt; れていないためです。</target>
        </trans-unit>
        <trans-unit id="2c304689dc11138fde5d03ea645ecb41953e1334" translate="yes" xml:space="preserve">
          <source>bugfix</source>
          <target state="translated">bugfix</target>
        </trans-unit>
        <trans-unit id="321ef65dd8e0fe725eb1aefadf1bd87479757769" translate="yes" xml:space="preserve">
          <source>composes with other bluebird features, like &lt;a href=&quot;promise.all&quot;&gt;&lt;code&gt;Promise.all&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;promise.all&quot;&gt; &lt;code&gt;Promise.all&lt;/code&gt; の&lt;/a&gt;ような他のbluebird機能で構成されます。</target>
        </trans-unit>
        <trans-unit id="4b7615dce52c4c05ce4e1d374e9c61a13717ac7c" translate="yes" xml:space="preserve">
          <source>feature</source>
          <target state="translated">feature</target>
        </trans-unit>
        <trans-unit id="03e02ad7e48448605c30956ca4071a16aaf4bf8b" translate="yes" xml:space="preserve">
          <source>in the case where &lt;code&gt;value&lt;/code&gt; doesn't change its value because its binding time is different than when using a closure.</source>
          <target state="translated">場合に &lt;code&gt;value&lt;/code&gt; その結合時間は、クロージャを使用する場合とは異なるため、その値を変更しません。</target>
        </trans-unit>
        <trans-unit id="fdb19623519a22b9149620557f13925f7b42fd29" translate="yes" xml:space="preserve">
          <source>new Promise</source>
          <target state="translated">新約束</target>
        </trans-unit>
        <trans-unit id="afbedb8dbf47bdab5c49c2b9d92015b7b3581a43" translate="yes" xml:space="preserve">
          <source>new Promise()</source>
          <target state="translated">new Promise()</target>
        </trans-unit>
        <trans-unit id="558916e0aef77e0a7a2bbe15ca31648114109299" translate="yes" xml:space="preserve">
          <source>no setup code required to make cancellation work</source>
          <target state="translated">セットアップコード不要でキャンセルが可能</target>
        </trans-unit>
        <trans-unit id="4397a4d17f5c537ce4e705bcaf7b0efdd50c51d6" translate="yes" xml:space="preserve">
          <source>reasonable semantics for multiple consumer cancellation</source>
          <target state="translated">多重消費者キャンセルのための合理的な意味論</target>
        </trans-unit>
        <trans-unit id="748bc7560ff57854e11d5ab937864f0ff100bb12" translate="yes" xml:space="preserve">
          <source>resolving it with itself tells it &quot;it is done when it is done&quot;</source>
          <target state="translated">自体で解決しても「してもしてもしない」と言われる</target>
        </trans-unit>
        <trans-unit id="9379d4b4f4ef9775cb3c71402acd9e3e7970ea7f" translate="yes" xml:space="preserve">
          <source>throw TypeError when thenable resolves with itself</source>
          <target state="translated">throw TypeError when thenable がそれ自身で解決した場合</target>
        </trans-unit>
        <trans-unit id="44176cf9434e38d37133324ac3fb90ae6fc35afd" translate="yes" xml:space="preserve">
          <source>~~Promise.longStackTraces~~</source>
          <target state="translated">~~Promise.longStackTraces~~</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
