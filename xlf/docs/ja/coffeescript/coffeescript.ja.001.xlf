<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="coffeescript">
    <body>
      <group id="coffeescript">
        <trans-unit id="e11557a88106e7fe5bb613921c6f637bccd31989" translate="yes" xml:space="preserve">
          <source>%%</source>
          <target state="translated">%%</target>
        </trans-unit>
        <trans-unit id="7ccf396b1e0174237c52a3c6bc495b340169bd3c" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2009&amp;ndash;2018 Jeremy Ashkenas</source>
          <target state="translated">&amp;copy;2009&amp;ndash;2018 Jeremy Ashkenas</target>
        </trans-unit>
        <trans-unit id="959d8557a2e201cd876ef4c8e1965cfdffff28c6" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2009&amp;ndash;2020 Jeremy Ashkenas</source>
          <target state="translated">&amp;copy;2009&amp;ndash;2020ジェレミー・アシュケナス</target>
        </trans-unit>
        <trans-unit id="e00eab0c44161a5c6e125f234cee4992a6fcd8e4" translate="yes" xml:space="preserve">
          <source>&amp;hellip;and object properties.</source>
          <target state="translated">&amp;hellip;そしてオブジェクトのプロパティ。</target>
        </trans-unit>
        <trans-unit id="73dd43829ef8eae899eaf52c55d9ad5b84c8821f" translate="yes" xml:space="preserve">
          <source>&amp;quot;text/coffeescript&amp;quot; Script Tags</source>
          <target state="translated">「text / coffeescript」スクリプトタグ</target>
        </trans-unit>
        <trans-unit id="bc2f74c22f98f7b6ffbc2f67453dbfa99bce9a32" translate="yes" xml:space="preserve">
          <source>**</source>
          <target state="translated">**</target>
        </trans-unit>
        <trans-unit id="ebbffb7d7ea5362a22bfa1bab0bfdeb1617cd610" translate="yes" xml:space="preserve">
          <source>//</source>
          <target state="translated">//</target>
        </trans-unit>
        <trans-unit id="53f56e39c6568e87ed693f2d221db24632d7aa00" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#modules&quot;&gt;Modules&lt;/a&gt; and &lt;a href=&quot;#jsx&quot;&gt;JSX&lt;/a&gt; always require transpilation.</source>
          <target state="translated">&lt;a href=&quot;#modules&quot;&gt;モジュール&lt;/a&gt;と&lt;a href=&quot;#jsx&quot;&gt;JSXは&lt;/a&gt;常にトランスパイレーションを必要とします。</target>
        </trans-unit>
        <trans-unit id="2b5a9a675a7d370676eff4f216883a2020ccc476" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://coffeescript.org/#splats&quot;&gt;Splats, a.k.a. object rest/spread syntax, for objects&lt;/a&gt; are supported by Node 8.6+.</source>
          <target state="translated">&lt;a href=&quot;https://coffeescript.org/#splats&quot;&gt;オブジェクトのスプラット、別名オブジェクトレスト/スプレッド構文は、&lt;/a&gt;ノード8.6以降でサポートされています。</target>
        </trans-unit>
        <trans-unit id="7f2498c383e4e6502a04279ccad6e370f86b3e20" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Dynamic_Imports&quot;&gt;Dynamic import&lt;/a&gt; is also supported, with mandatory parentheses:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Dynamic_Imports&quot;&gt;動的インポート&lt;/a&gt;もサポートされ、必須の括弧が付いています。</target>
        </trans-unit>
        <trans-unit id="f82ee4d52cb6f66ab432c78025692d4f93c8400d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://facebook.github.io/react/docs/introducing-jsx.html&quot;&gt;JSX&lt;/a&gt; is JavaScript containing interspersed XML elements. While conceived for &lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt;, it is not specific to any particular library or framework.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/react/docs/introducing-jsx.html&quot;&gt;JSX&lt;/a&gt;は、散在するXML要素を含むJavaScriptです。&lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;Reactの&lt;/a&gt;ために考案されましたが、特定のライブラリやフレームワークに固有のものではありません。</target>
        </trans-unit>
        <trans-unit id="5ab0d5c504f451bb7b8744a031b2895facf00809" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;Async generator functions&lt;/a&gt; are supported by Node 10+.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;非同期ジェネレーター機能&lt;/a&gt;は、ノード10以降でサポートされています。</target>
        </trans-unit>
        <trans-unit id="3eea75d33a4b7141282062785cc396fb0821bbd2" translate="yes" xml:space="preserve">
          <source>&lt;code id=&quot;this&quot;&gt;@&lt;/code&gt;, &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;this&quot;&gt;@&lt;/code&gt; 、 &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6bddde52d2ce96695935a88af3457fe562602600" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;text/coffeescript&quot;&lt;/code&gt; Script Tags</source>
          <target state="translated">&lt;code&gt;&quot;text/coffeescript&quot;&lt;/code&gt; スクリプトタグ</target>
        </trans-unit>
        <trans-unit id="4f3b179798446cf0398649b8ad3d668bf9055a6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--bare&lt;/code&gt; and &lt;code&gt;--no-header&lt;/code&gt; are important because Flow requires the first line of the file to be the comment &lt;code&gt;// @flow&lt;/code&gt;. If you configure your build chain to compile CoffeeScript and pass the result to Flow in-memory, you can get better performance than this example; and a proper build tool should be able to watch your CoffeeScript files and recompile and type-check them for you on save.</source>
          <target state="translated">&lt;code&gt;--bare&lt;/code&gt; Flowはファイルの最初の行をコメント &lt;code&gt;// @flow&lt;/code&gt; する必要があるため、-bareと &lt;code&gt;--no-header&lt;/code&gt; は重要です。CoffeeScriptをコンパイルして結果をFlow in-memoryに渡すようにビルドチェーンを構成すると、この例よりも優れたパフォーマンスが得られます。そして、適切なビルドツールは、CoffeeScriptファイルを監視し、保存時にそれらを再コンパイルして型チェックできる必要があります。</target>
        </trans-unit>
        <trans-unit id="4d635daf3b49933b2580d4b7f115dbf3f7192ece" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a?(b, c)&lt;/code&gt; or &lt;code&gt;a? b, c&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a?(b, c)&lt;/code&gt; または &lt;code&gt;a? b, c&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8b195b055ae12191320d58268dcf96e63ba61e34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a?.b&lt;/code&gt; or &lt;code&gt;a?['b']&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a?.b&lt;/code&gt; または &lt;code&gt;a?['b']&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f26a6ff56f6f4d1453881906a2fedcfdf70a4192" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;console.log sys.inspect object&lt;/code&gt; &amp;rarr; &lt;code&gt;console.log(sys.inspect(object));&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;console.log sys.inspect object&lt;/code&gt; &amp;rarr; &lt;code&gt;console.log(sys.inspect(object));&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="671572b1210bb1454fe66f9c4630dc77eb820b08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt;, &lt;code&gt;no&lt;/code&gt;, &lt;code&gt;off&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 、 &lt;code&gt;no&lt;/code&gt; 、 &lt;code&gt;off&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08092e8ae424c160938c270677dd88a77a69c59c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; keyword shorthand syntax</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; キーワードの簡略構文を取得および &lt;code&gt;set&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6797ae36e87fa19e1efa9483eaa78cd02c6979d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;, as keywords preceding functions or class methods, are intentionally unimplemented in CoffeeScript.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; または &lt;code&gt;set&lt;/code&gt; は、関数またはクラスメソッドに先行するキーワードとして、CoffeeScriptでは意図的に実装されていません。</target>
        </trans-unit>
        <trans-unit id="b4e24c06746537f3bcc316c7b684e6a1288745a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; statements can be written without the use of parentheses and curly brackets. As with functions and other block expressions, multi-line conditionals are delimited by indentation. There&amp;rsquo;s also a handy postfix form, with the &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;unless&lt;/code&gt; at the end.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; ステートメントは、括弧や中括弧を使用せずに記述できます。関数や他のブロック式と同様に、複数行の条件はインデントで区切られます。便利な接尾フォームは、もあります &lt;code&gt;if&lt;/code&gt; または &lt;code&gt;unless&lt;/code&gt; 終わり。</target>
        </trans-unit>
        <trans-unit id="c898449ed9c27c9ce84efe5f7a1f6fed9d1a6120" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; add a useful ability to JavaScript in that you can use them to declare variables within a &lt;em&gt;block&lt;/em&gt; scope, for example within an &lt;code&gt;if&lt;/code&gt; statement body or a &lt;code&gt;for&lt;/code&gt; loop body, whereas &lt;code&gt;var&lt;/code&gt; always declares variables in the scope of an entire function. When CoffeeScript 2 was designed, there was much discussion of whether this functionality was useful enough to outweigh the simplicity offered by never needing to consider variable declaration in CoffeeScript. In the end, it was decided that the simplicity was more valued. In CoffeeScript there remains only one type of variable.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; と &lt;code&gt;const&lt;/code&gt; のあなたは内の変数を宣言するためにそれらを使用することができるという点で、JavaScriptに便利な機能を追加し&lt;em&gt;、ブロック&lt;/em&gt;内例えば、スコープ &lt;code&gt;if&lt;/code&gt; 文の本体または &lt;code&gt;for&lt;/code&gt; のに対し、ループボディ &lt;code&gt;var&lt;/code&gt; が常に全体の関数のスコープ内の変数を宣言します。CoffeeScript 2が設計されたとき、この機能が、CoffeeScriptで変数宣言を考慮する必要がないことによって提供される単純さを上回って十分に役立つかどうかについて多くの議論がありました。結局、シンプルさがより重視されることになりました。CoffeeScriptでは、1つのタイプの変数のみが残っています。</target>
        </trans-unit>
        <trans-unit id="0d755861b046842e4e015fd91408805286afea66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;: block-scoped and reassignment-protected variables</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; および &lt;code&gt;const&lt;/code&gt; ：ブロックスコープおよび再割り当て保護された変数</target>
        </trans-unit>
        <trans-unit id="024f6866b7e8235b2a23e7de0819061f8e8113b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options.ast&lt;/code&gt;, boolean: if true, return an abstract syntax tree of the input CoffeeScript source code.</source>
          <target state="translated">&lt;code&gt;options.ast&lt;/code&gt; 、boolean：trueの場合、入力CoffeeScriptソースコードの抽象構文ツリーを返します。</target>
        </trans-unit>
        <trans-unit id="69bdd67b5f2fb2b4bc55bed7c7cf382b91714c45" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options.bare&lt;/code&gt;, boolean: if true, output without the &lt;a href=&quot;#lexical-scope&quot;&gt;top-level function safety wrapper&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;options.bare&lt;/code&gt; 、boolean：trueの場合、&lt;a href=&quot;#lexical-scope&quot;&gt;トップレベルの関数安全ラッパー&lt;/a&gt;なしで出力します。</target>
        </trans-unit>
        <trans-unit id="7e88224b1d5d85954af2e05694587845ce15ef6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options.filename&lt;/code&gt;, string: the filename to use for the source map. It can include a path (relative or absolute).</source>
          <target state="translated">&lt;code&gt;options.filename&lt;/code&gt; 、string：ソースマップに使用するファイル名。パス（相対パスまたは絶対パス）を含めることができます。</target>
        </trans-unit>
        <trans-unit id="0668f9660893b6c173226ef928d6f8c135d49c5d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options.header&lt;/code&gt;, boolean: if true, output the &lt;code&gt;Generated by CoffeeScript&lt;/code&gt; header.</source>
          <target state="translated">&lt;code&gt;options.header&lt;/code&gt; 、boolean：trueの場合、 &lt;code&gt;Generated by CoffeeScript&lt;/code&gt; ヘッダーを出力します。</target>
        </trans-unit>
        <trans-unit id="5d11ef802af0f76e518643ed277b582fea058806" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options.inlineMap&lt;/code&gt;, boolean: if true, output the source map as a base64-encoded string in a comment at the bottom.</source>
          <target state="translated">&lt;code&gt;options.inlineMap&lt;/code&gt; 、boolean：trueの場合、ソースマップをbase64でエンコードされた文字列として下部のコメントに出力します。</target>
        </trans-unit>
        <trans-unit id="0e70b1c0b6768b86125fef4bd20eb872934d31f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options.sourceMap&lt;/code&gt;, boolean: if true, a source map will be generated; and instead of returning a string, &lt;code&gt;compile&lt;/code&gt; will return an object of the form &lt;code&gt;{js, v3SourceMap, sourceMap}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;options.sourceMap&lt;/code&gt; 、boolean：trueの場合、ソースマップが生成されます。文字列を返す代わりに、 &lt;code&gt;compile&lt;/code&gt; は &lt;code&gt;{js, v3SourceMap, sourceMap}&lt;/code&gt; という形式のオブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="bd359cce40eaca31c9f0f745fb688f4ff5606e6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options.transpile&lt;/code&gt;, &lt;strong&gt;object&lt;/strong&gt;: if set, this must be an object with the &lt;a href=&quot;https://babeljs.io/docs/usage/api/#options&quot;&gt;options to pass to Babel&lt;/a&gt;. See &lt;a href=&quot;#transpilation&quot;&gt;Transpilation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;options.transpile&lt;/code&gt; 、&lt;strong&gt;object&lt;/strong&gt;：設定されている場合、これは&lt;a href=&quot;https://babeljs.io/docs/usage/api/#options&quot;&gt;Babelに渡すオプションを&lt;/a&gt;持つオブジェクトでなければなりません。&lt;a href=&quot;#transpilation&quot;&gt;Transpilationを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="42ddf3bee0d00b958b57a4f0c778746594dce840" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;require()&lt;/code&gt; the given module before starting the REPL or evaluating the code given with the &lt;code&gt;--eval&lt;/code&gt; flag.</source>
          <target state="translated">&lt;code&gt;require()&lt;/code&gt; REPLを開始する前、または &lt;code&gt;--eval&lt;/code&gt; フラグで指定されたコードを評価する前に、指定されたモジュールをrequire（）します。</target>
        </trans-unit>
        <trans-unit id="da337d04d46816ce3f960cc13a8c58049d709032" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;super&lt;/code&gt; and &lt;code&gt;extends&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;super&lt;/code&gt; と &lt;code&gt;extends&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f91468df92b13b248660811a65d1664a64a85a87" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;super&lt;/code&gt; and &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;super&lt;/code&gt; と &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="febc77da193c1450f3079a54b815c08cfb84cae7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;switch&lt;/code&gt; statements can also be used without a control expression, turning them in to a cleaner alternative to &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; chains.</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; ステートメントは、制御式なしで使用することもでき、 &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; チェーンの代わりに、より明確な方法に切り替えます。</target>
        </trans-unit>
        <trans-unit id="f14836fb2c4f448ff7f89a8d54a114f65adceb8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;switch&lt;/code&gt; statements in JavaScript are a bit awkward. You need to remember to &lt;code&gt;break&lt;/code&gt; at the end of every &lt;code&gt;case&lt;/code&gt; statement to avoid accidentally falling through to the default case. CoffeeScript prevents accidental fall-through, and can convert the &lt;code&gt;switch&lt;/code&gt; into a returnable, assignable expression. The format is: &lt;code&gt;switch&lt;/code&gt; condition, &lt;code&gt;when&lt;/code&gt; clauses, &lt;code&gt;else&lt;/code&gt; the default case.</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; JavaScriptのswitchステートメントは少し厄介です。誤ってデフォルトのケースに陥らないように、すべての &lt;code&gt;case&lt;/code&gt; ステートメントの最後で &lt;code&gt;break&lt;/code&gt; することを忘れないでください。CoffeeScriptは偶発的なフォールスルーを防ぎ、 &lt;code&gt;switch&lt;/code&gt; を戻り可能で割り当て可能な式に変換できます。形式は次のとおりです。 &lt;code&gt;switch&lt;/code&gt; 条件、 &lt;code&gt;when&lt;/code&gt; 句、 &lt;code&gt;else&lt;/code&gt; の場合はデフォルトのケース。</target>
        </trans-unit>
        <trans-unit id="beb8408aed5d5e0b2e7958d3840c0f622534b644" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt;, &lt;code&gt;yes&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 、 &lt;code&gt;yes&lt;/code&gt; 、 &lt;code&gt;on&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4cfd4f6560eea48a3bbb6452c625b3643616abf4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;try&lt;/code&gt; expressions have the same semantics as &lt;code&gt;try&lt;/code&gt; statements in JavaScript, though in CoffeeScript, you may omit &lt;em&gt;both&lt;/em&gt; the catch and finally parts. The catch part may also omit the error parameter if it is not needed.</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 式のセマンティクスはJavaScriptの &lt;code&gt;try&lt;/code&gt; ステートメントと同じですが、CoffeeScriptでは、catch部分とfinally部分の&lt;em&gt;両方を&lt;/em&gt;省略できます。キャッチ部分は、必要がない場合はエラー・パラメーターも省略できます。</target>
        </trans-unit>
        <trans-unit id="4068635871de89a0425d7ae15c3ee28c166fda6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unless&lt;/code&gt; can be used as the inverse of &lt;code&gt;if&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;unless&lt;/code&gt; の逆数として使用することができる &lt;code&gt;if&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="146594e8060979ead0f6d28256eb4ef1779d3dcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yield*&lt;/code&gt; is called &lt;code&gt;yield from&lt;/code&gt;, and &lt;code&gt;yield return&lt;/code&gt; may be used if you need to force a generator that doesn&amp;rsquo;t yield.</source>
          <target state="translated">&lt;code&gt;yield*&lt;/code&gt; は &lt;code&gt;yield from&lt;/code&gt; と呼ばれ、 &lt;code&gt;yield return&lt;/code&gt; しないジェネレーターを強制する必要がある場合は、yield returnを使用できます。</target>
        </trans-unit>
        <trans-unit id="eea76de22707204f2de04392630e2b08c9b49475" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;CoffeeScript on the topleft, compiled JavaScript output on the bottomright. The CoffeeScript is editable!&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;左上にCoffeeScript、右下にコンパイルされたJavaScript出力。CoffeeScriptは編集可能です！&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7315b2762c97737d5039c4b20d8a25a1b9ad4687" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Many of the examples can be run (where it makes sense) by pressing the&lt;/em&gt;&lt;small&gt;▶&lt;/small&gt;&lt;em&gt;button on the right. The CoffeeScript on the left is editable, and the JavaScript will update as you edit.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;例の多くは、&lt;/em&gt;&lt;em&gt;右側の&lt;/em&gt;&lt;small&gt;▶ &lt;/small&gt;&lt;em&gt;ボタンを&lt;/em&gt;&lt;em&gt;押すことで（意味のある場所で）実行できます&lt;/em&gt;&lt;em&gt;。左側のCoffeeScriptは編集可能で、編集するとJavaScriptが更新されます。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c277fcd54562e2635bc26a8132a87027a7d6a56f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This reference is structured so that it can be read from top to bottom, if you like. Later sections use ideas and syntax previously introduced. Familiarity with JavaScript is assumed. In all of the following examples, the source CoffeeScript is provided on the left, and the direct compilation into JavaScript is on the right.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;この参照は、必要に応じて上から下に読むことができるように構成されています。以降のセクションでは、以前に紹介したアイデアと構文を使用します。JavaScriptの知識があることを前提としています。以下のすべての例では、ソースのCoffeeScriptが左側にあり、JavaScriptへの直接コンパイルが右側にあります。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a3e61d6a409d40b1cc7e66218d36a04024655912" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CoffeeScript is a little language that compiles into JavaScript.&lt;/strong&gt; Underneath that awkward Java-esque patina, JavaScript has always had a gorgeous heart. CoffeeScript is an attempt to expose the good parts of JavaScript in a simple way.</source>
          <target state="translated">&lt;strong&gt;CoffeeScriptは、JavaScriptにコンパイルされる小さな言語です。&lt;/strong&gt;その扱いにくいJava風の緑青の下で、JavaScriptは常にゴージャスな心を持っていました。CoffeeScriptは、JavaScriptの優れた部分を簡単な方法で公開する試みです。</target>
        </trans-unit>
        <trans-unit id="3a49dc083df4f29ffc84eceec33918bc2ac078a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Latest Version:&lt;/strong&gt;&lt;a href=&quot;https://github.com/jashkenas/coffeescript/tarball/2.4.1&quot;&gt;2.4.1&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;最新バージョン：&lt;/strong&gt;&lt;a href=&quot;https://github.com/jashkenas/coffeescript/tarball/2.4.1&quot;&gt;2.4.1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f5f3c90a7e6596edc44c5d04e245bb687eccf3e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Latest Version:&lt;/strong&gt;&lt;a href=&quot;https://github.com/jashkenas/coffeescript/tarball/2.5.1&quot;&gt;2.5.1&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;最新バージョン：&lt;/strong&gt;&lt;a href=&quot;https://github.com/jashkenas/coffeescript/tarball/2.5.1&quot;&gt;2.5.1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9a78211436f6d425ec38f5c4e02270801f3524f8" translate="yes" xml:space="preserve">
          <source>@</source>
          <target state="translated">@</target>
        </trans-unit>
        <trans-unit id="749387032ae04dba9bbbf8a243b19977245cf1a6" translate="yes" xml:space="preserve">
          <source>A few caveats:</source>
          <target state="translated">いくつかの注意点があります。</target>
        </trans-unit>
        <trans-unit id="2992ef6e06f5285c1589f15bbd6cdefabccc9e93" translate="yes" xml:space="preserve">
          <source>All together now, watch and recompile an entire project as you work on it:</source>
          <target state="translated">これで、プロジェクト全体を見ながら再コンパイルすることができるようになりました。</target>
        </trans-unit>
        <trans-unit id="ef9a81eb41028081130a2daf5219d439c4552d2b" translate="yes" xml:space="preserve">
          <source>All together now:</source>
          <target state="translated">今、みんなで一緒に。</target>
        </trans-unit>
        <trans-unit id="de911cf89f46bf4aab8399057a0b6f4d24430428" translate="yes" xml:space="preserve">
          <source>Along those lines, code blocks within list items or blockquotes are not treated as executable code. Since list items and blockquotes imply their own indentation, it would be ambiguous how to treat indentation between successive code blocks when some are within these other blocks and some are not.</source>
          <target state="translated">これに沿って、リスト項目やブロック引用符の中のコードブロックは実行可能なコードとしては扱われません。リスト項目やブロック引用符はそれ自身のインデントを意味するので、いくつかのコードブロックが他のブロック内にあり、いくつかのブロックがそうでない場合に、連続するコードブロック間のインデントをどのように扱うかは曖昧になるでしょう。</target>
        </trans-unit>
        <trans-unit id="f205799358de5de3653ec6932d7fc9cc5631d19a" translate="yes" xml:space="preserve">
          <source>Also note that any file with an &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; statement will be output without a &lt;a href=&quot;#lexical-scope&quot;&gt;top-level function safety wrapper&lt;/a&gt;; in other words, importing or exporting modules will automatically trigger &lt;a href=&quot;#usage&quot;&gt;bare&lt;/a&gt; mode for that file. This is because per the ES2015 spec, &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; statements must occur at the topmost scope.</source>
          <target state="translated">また、 &lt;code&gt;import&lt;/code&gt; または &lt;code&gt;export&lt;/code&gt; ステートメントを含むファイルは、&lt;a href=&quot;#lexical-scope&quot;&gt;トップレベルの関数安全ラッパー&lt;/a&gt;なしで出力されます。つまり、モジュールをインポートまたはエクスポートすると、そのファイルの&lt;a href=&quot;#usage&quot;&gt;ベアモード&lt;/a&gt;が自動的にトリガーされます。これは、ES2015仕様に従って、 &lt;code&gt;import&lt;/code&gt; または &lt;code&gt;export&lt;/code&gt; ステートメントが最上位のスコープで発生する必要があるためです。</target>
        </trans-unit>
        <trans-unit id="8d8c347317a31c9b96b2eb66a2e233fab6fd3515" translate="yes" xml:space="preserve">
          <source>Although suppressed within this documentation for clarity, all CoffeeScript output (except in files with &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; statements) is wrapped in an anonymous function: &lt;code&gt;(function(){ &amp;hellip; })();&lt;/code&gt;. This safety wrapper, combined with the automatic generation of the &lt;code&gt;var&lt;/code&gt; keyword, make it exceedingly difficult to pollute the global namespace by accident. (The safety wrapper can be disabled with the &lt;a href=&quot;#usage&quot;&gt;&lt;code&gt;bare&lt;/code&gt; option&lt;/a&gt;, and is unnecessary and automatically disabled when using modules.)</source>
          <target state="translated">このドキュメントではわかりやすくするために省略していますが、CoffeeScriptのすべての出力（ &lt;code&gt;import&lt;/code&gt; または &lt;code&gt;export&lt;/code&gt; ステートメントを含むファイルを除く）は、無名関数でラップされています。 &lt;code&gt;(function(){ &amp;hellip; })();&lt;/code&gt; 。この安全なラッパーと &lt;code&gt;var&lt;/code&gt; キーワードの自動生成が組み合わされているため、誤ってグローバル名前空間を汚染することは非常に困難です。（安全ラッパーは&lt;a href=&quot;#usage&quot;&gt; &lt;code&gt;bare&lt;/code&gt; オプション&lt;/a&gt;で無効にすることができ、モジュールを使用する場合は不要で自動的に無効になります。）</target>
        </trans-unit>
        <trans-unit id="d1862e82363559b6fb9a22118afd3352933e73f2" translate="yes" xml:space="preserve">
          <source>Argument parsing and shebang (&lt;code&gt;#!&lt;/code&gt;) lines</source>
          <target state="translated">引数の解析とシバン（ &lt;code&gt;#!&lt;/code&gt; ）行</target>
        </trans-unit>
        <trans-unit id="65f9c0eea18b31eb35e30364b4d18f13f72f3e80" translate="yes" xml:space="preserve">
          <source>Arguments can be forwarded explicitly using splats:</source>
          <target state="translated">引数は splats を使って明示的に転送することができます。</target>
        </trans-unit>
        <trans-unit id="bc8d4bce0a86d2f62284d889ea176cb257eb81cf" translate="yes" xml:space="preserve">
          <source>Array Slicing and Splicing with Ranges</source>
          <target state="translated">配列のスライスとスプライシング</target>
        </trans-unit>
        <trans-unit id="9ba9135f5143cdbcf8f067d358d2f101a0291868" translate="yes" xml:space="preserve">
          <source>As a shortcut for &lt;code&gt;this.property&lt;/code&gt;, you can use &lt;code&gt;@property&lt;/code&gt;.</source>
          <target state="translated">以下のためのショートカットとして &lt;code&gt;this.property&lt;/code&gt; は、使用することができます &lt;code&gt;@property&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d5ff33811e35eec43fb0c6d044ee1aebaa01617" translate="yes" xml:space="preserve">
          <source>As in &lt;a href=&quot;http://yaml.org/&quot;&gt;YAML&lt;/a&gt;, &lt;code&gt;on&lt;/code&gt; and &lt;code&gt;yes&lt;/code&gt; are the same as boolean &lt;code&gt;true&lt;/code&gt;, while &lt;code&gt;off&lt;/code&gt; and &lt;code&gt;no&lt;/code&gt; are boolean &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://yaml.org/&quot;&gt;YAML&lt;/a&gt;と同様に、 &lt;code&gt;on&lt;/code&gt; および &lt;code&gt;yes&lt;/code&gt; はブール値 &lt;code&gt;true&lt;/code&gt; と同じですが、 &lt;code&gt;off&lt;/code&gt; および &lt;code&gt;no&lt;/code&gt; はブール値 &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="c940962594d626d789e7139cf6327778f46a3c66" translate="yes" xml:space="preserve">
          <source>As in Ruby, &lt;code&gt;switch&lt;/code&gt; statements in CoffeeScript can take multiple values for each &lt;code&gt;when&lt;/code&gt; clause. If any of the values match, the clause runs.</source>
          <target state="translated">Rubyと同様に、CoffeeScriptの &lt;code&gt;switch&lt;/code&gt; ステートメントは、 &lt;code&gt;when&lt;/code&gt; 句ごとに複数の値をとることができます。いずれかの値が一致すると、句が実行されます。</target>
        </trans-unit>
        <trans-unit id="785872c21d2152c8e487aa14ed3c436575fb2e25" translate="yes" xml:space="preserve">
          <source>As well as silly things, like passing a &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; statement directly into a function call:</source>
          <target state="translated">また、 &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; ステートメントを関数呼び出しに直接渡すなど、ばかげたことも：</target>
        </trans-unit>
        <trans-unit id="e17003d05d795ba33cb9b8fb93fce1a1e17abcdc" translate="yes" xml:space="preserve">
          <source>Async Functions</source>
          <target state="translated">非同期関数</target>
        </trans-unit>
        <trans-unit id="baaf2143528768ba7feea8a142baf40647bed225" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;==&lt;/code&gt; operator frequently causes undesirable coercion, is intransitive, and has a different meaning than in other languages, CoffeeScript compiles &lt;code&gt;==&lt;/code&gt; into &lt;code&gt;===&lt;/code&gt;, and &lt;code&gt;!=&lt;/code&gt; into &lt;code&gt;!==&lt;/code&gt;. In addition, &lt;code&gt;is&lt;/code&gt; compiles into &lt;code&gt;===&lt;/code&gt;, and &lt;code&gt;isnt&lt;/code&gt; into &lt;code&gt;!==&lt;/code&gt;.</source>
          <target state="translated">なぜなら &lt;code&gt;==&lt;/code&gt; オペレータが頻繁に、望ましくない強制を原因と自動詞であり、他の言語では異なる意味を持ち、CoffeeScriptのコンパイル &lt;code&gt;==&lt;/code&gt; に &lt;code&gt;===&lt;/code&gt; 、及び &lt;code&gt;!=&lt;/code&gt; に &lt;code&gt;!==&lt;/code&gt; 。また、 &lt;code&gt;is&lt;/code&gt; にコンパイル &lt;code&gt;===&lt;/code&gt; 、及び &lt;code&gt;isnt&lt;/code&gt; に &lt;code&gt;!==&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48eae9d012f5bd3812c09f9e579487b2ac854c74" translate="yes" xml:space="preserve">
          <source>Because variable declarations occur at the top of scope, assignment can be used within expressions, even for variables that haven&amp;rsquo;t been seen before:</source>
          <target state="translated">変数の宣言はスコープの先頭で行われるため、代入は式の中で使用できます。これまでにない変数についても同様です。</target>
        </trans-unit>
        <trans-unit id="6a73ea1c2b90501e9d317af3a06faec56721a224" translate="yes" xml:space="preserve">
          <source>Because you don&amp;rsquo;t have direct access to the &lt;code&gt;var&lt;/code&gt; keyword, it&amp;rsquo;s impossible to shadow an outer variable on purpose, you may only refer to it. So be careful that you&amp;rsquo;re not reusing the name of an external variable accidentally, if you&amp;rsquo;re writing a deeply nested function.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; キーワードに直接アクセスできないため、外部変数をわざとシャドウイングすることは不可能であり、参照するだけです。したがって、深くネストされた関数を作成する場合は、外部変数の名前を誤って再利用しないように注意してください。</target>
        </trans-unit>
        <trans-unit id="500d6e30307a158cda828a2b4b51aff3d203b972" translate="yes" xml:space="preserve">
          <source>Besides being used as an ordinary programming language, CoffeeScript may also be written in &amp;ldquo;literate&amp;rdquo; mode. If you name your file with a &lt;code&gt;.litcoffee&lt;/code&gt; extension, you can write it as a Markdown document &amp;mdash; a document that also happens to be executable CoffeeScript code. The compiler will treat any indented blocks (Markdown&amp;rsquo;s way of indicating source code) as executable code, and ignore the rest as comments. Code blocks must also be separated from comments by at least one blank line.</source>
          <target state="translated">CoffeeScriptは、通常のプログラミング言語として使用されるだけでなく、「読み書き」モードで作成することもできます。ファイルに &lt;code&gt;.litcoffee&lt;/code&gt; 拡張子を付けた場合、それをMarkdownドキュメントとして書くことができます。これは、たまたま実行可能なCoffeeScriptコードでもあるドキュメントです。コンパイラは、インデントされたブロック（ソースコードを示すマークダウンの方法）を実行可能コードとして扱い、残りをコメントとして無視します。コードブロックは、コメントと少なくとも1行の空白行で区切る必要もあります。</target>
        </trans-unit>
        <trans-unit id="52c6757f76d4c59aa1a2f5c458ff43e37ce42012" translate="yes" xml:space="preserve">
          <source>Block Regular Expressions</source>
          <target state="translated">ブロック正規表現</target>
        </trans-unit>
        <trans-unit id="88e6d3a6135787b6b130ff7bc9cdd589be5f2a49" translate="yes" xml:space="preserve">
          <source>Block strings, delimited by &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; or &lt;code&gt;'''&lt;/code&gt;, can be used to hold formatted or indentation-sensitive text (or, if you just don&amp;rsquo;t feel like escaping quotes and apostrophes). The indentation level that begins the block is maintained throughout, so you can keep it all aligned with the body of your code.</source>
          <target state="translated">&lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; または &lt;code&gt;'''&lt;/code&gt; で区切られたブロック文字列は、フォーマットされたテキストまたはインデントの影響を受けやすいテキストを保持するために使用できます（または、引用符やアポストロフィをエスケープしたくない場合）。ブロックを開始するインデントレベルは維持されます全体を通して、すべてをコードの本体に揃えることができます。</target>
        </trans-unit>
        <trans-unit id="0860d71a0ec2e658f3d9a3738433ca07ec8f0787" translate="yes" xml:space="preserve">
          <source>Bound (Fat Arrow) Functions</source>
          <target state="translated">バウンド(太矢印)関数</target>
        </trans-unit>
        <trans-unit id="c0919393bb78439cc6bdad954e816bfa9e7b5395" translate="yes" xml:space="preserve">
          <source>Bound (fat arrow) functions</source>
          <target state="translated">バウンド(太矢印)関数</target>
        </trans-unit>
        <trans-unit id="3146c3bce8a6f3c5954cf4d17548170dd8fa9a5d" translate="yes" xml:space="preserve">
          <source>Bound generator functions</source>
          <target state="translated">バウンドジェネレーター機能</target>
        </trans-unit>
        <trans-unit id="66a99a10fccdc00a933b3a257862c3f84baadadd" translate="yes" xml:space="preserve">
          <source>Bound generator functions, a.k.a. generator arrow functions, &lt;a href=&quot;https://stackoverflow.com/questions/27661306/can-i-use-es6s-arrow-function-syntax-with-generators-arrow-notation&quot;&gt;aren&amp;rsquo;t allowed in ECMAScript&lt;/a&gt;. You can write &lt;code&gt;function*&lt;/code&gt; or &lt;code&gt;=&amp;gt;&lt;/code&gt;, but not both. Therefore, CoffeeScript code like this:</source>
          <target state="translated">バインドされたジェネレーター関数、別名ジェネレーターアロー関数&lt;a href=&quot;https://stackoverflow.com/questions/27661306/can-i-use-es6s-arrow-function-syntax-with-generators-arrow-notation&quot;&gt;は、ECMAScriptでは許可されていません&lt;/a&gt;。 &lt;code&gt;function*&lt;/code&gt; または &lt;code&gt;=&amp;gt;&lt;/code&gt; を書くことはできますが、両方を書くことはできません。したがって、CoffeeScriptコードは次のようになります。</target>
        </trans-unit>
        <trans-unit id="3f1d6f17ca16b010bf909bd90956813c62360340" translate="yes" xml:space="preserve">
          <source>Breaking Changes From 1.x</source>
          <target state="translated">1.xからの変更点</target>
        </trans-unit>
        <trans-unit id="3501da7b50f11f0bed95d1651f5526076186c9d5" translate="yes" xml:space="preserve">
          <source>Breaking Changes From CoffeeScript 1.x to 2</source>
          <target state="translated">CoffeeScript 1.x から 2 への変更点</target>
        </trans-unit>
        <trans-unit id="476e56d0eff6f65aab9d09fede93409b5105aa4b" translate="yes" xml:space="preserve">
          <source>But it&amp;rsquo;s also helpful for dealing with functions that return multiple values.</source>
          <target state="translated">ただし、複数の値を返す関数を処理する場合にも役立ちます。</target>
        </trans-unit>
        <trans-unit id="eed3eed03e17d439596291023c0881f19f4179f4" translate="yes" xml:space="preserve">
          <source>By default, Babel doesn&amp;rsquo;t do anything&amp;mdash;it doesn&amp;rsquo;t make assumptions about what you want to transpile to. You need to provide it with a configuration so that it knows what to do. One way to do this is by creating a &lt;a href=&quot;https://babeljs.io/docs/usage/babelrc/&quot;&gt;&lt;code&gt;.babelrc&lt;/code&gt; file&lt;/a&gt; in the folder containing the files you&amp;rsquo;re compiling, or in any parent folder up the path above those files. (Babel supports &lt;a href=&quot;https://babeljs.io/docs/usage/babelrc/&quot;&gt;other ways&lt;/a&gt;, too.) A minimal &lt;code&gt;.babelrc&lt;/code&gt; file would be just &lt;code&gt;{ &quot;presets&quot;: [&quot;@babel/env&quot;] }&lt;/code&gt;. This implies that you have installed &lt;a href=&quot;https://babeljs.io/docs/plugins/preset-env/&quot;&gt;&lt;code&gt;@babel/preset-env&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">デフォルトでは、Babelは何も実行しません。変換先を想定していません。何をすべきかがわかるように、構成を提供する必要があります。これを行う1つの方法は、コンパイルするファイルを含むフォルダー、またはそれらのファイルの上のパスの親フォルダーに&lt;a href=&quot;https://babeljs.io/docs/usage/babelrc/&quot;&gt; &lt;code&gt;.babelrc&lt;/code&gt; ファイル&lt;/a&gt;を作成することです。（Babelは&lt;a href=&quot;https://babeljs.io/docs/usage/babelrc/&quot;&gt;他の方法&lt;/a&gt;もサポートしています。）最小限の &lt;code&gt;.babelrc&lt;/code&gt; ファイルは、単に &lt;code&gt;{ &quot;presets&quot;: [&quot;@babel/env&quot;] }&lt;/code&gt; presets &quot;：[&quot;@ babel / env&quot;]}です。これは、&lt;a href=&quot;https://babeljs.io/docs/plugins/preset-env/&quot;&gt; &lt;code&gt;@babel/preset-env&lt;/code&gt; &lt;/a&gt;がインストールされていることを意味します。</target>
        </trans-unit>
        <trans-unit id="49f1d818998e74de59695f157376f3a90606565f" translate="yes" xml:space="preserve">
          <source>Cake, and Cakefiles</source>
          <target state="translated">ケーキ、ケーキファイル</target>
        </trans-unit>
        <trans-unit id="0088170b2bb2e7f289a6285cc617ed958ec50055" translate="yes" xml:space="preserve">
          <source>Chained Comparisons</source>
          <target state="translated">連鎖比較</target>
        </trans-unit>
        <trans-unit id="0ccff6f387e0efef20c206a781d53627c48f2db7" translate="yes" xml:space="preserve">
          <source>Chaining Function Calls</source>
          <target state="translated">関数呼び出しのチェーン化</target>
        </trans-unit>
        <trans-unit id="0671ba2a2caa16a2ef58982abbdd6ace7b22a6a2" translate="yes" xml:space="preserve">
          <source>Class constructors can&amp;rsquo;t be invoked without &lt;code&gt;new&lt;/code&gt;:</source>
          <target state="translated">クラスコンストラクターは &lt;code&gt;new&lt;/code&gt; なしで呼び出すことはできません。</target>
        </trans-unit>
        <trans-unit id="c53d0a7efe848343f2bc3b9f8c6dabb21e16c959" translate="yes" xml:space="preserve">
          <source>Class methods can&amp;rsquo;t be used with &lt;code&gt;new&lt;/code&gt; (uncommon):</source>
          <target state="translated">クラスメソッドは &lt;code&gt;new&lt;/code&gt; （uncommon）では使用できません：</target>
        </trans-unit>
        <trans-unit id="ed1846afee3be21521286932b99e2aeae9e6414a" translate="yes" xml:space="preserve">
          <source>Classes</source>
          <target state="translated">Classes</target>
        </trans-unit>
        <trans-unit id="76ac356fa19e9b009cd862e7b800bf5b501caee5" translate="yes" xml:space="preserve">
          <source>Classes are compiled to ES2015 classes</source>
          <target state="translated">クラスはES2015のクラスにコンパイルされています</target>
        </trans-unit>
        <trans-unit id="ed3b73338063d6639e5a81aae81f93fb2d0aed3e" translate="yes" xml:space="preserve">
          <source>Code blocks need to maintain consistent indentation relative to each other. When the compiler parses your Literate CoffeeScript file, it first discards all the non-code block lines and then parses the remainder as a regular CoffeeScript file. Therefore the code blocks need to be written as if the comment lines don&amp;rsquo;t exist, with consistent indentation (including whether they are indented with tabs or spaces).</source>
          <target state="translated">コードブロックは、互いに相対的に一貫したインデントを維持する必要があります。コンパイラーがLiterate CoffeeScriptファイルを解析するとき、最初にすべての非コードブロック行を破棄してから、残りを通常のCoffeeScriptファイルとして解析します。したがって、コードブロックは、一貫したインデント（コメントがタブまたはスペースでインデントされているかどうかを含む）で、コメント行が存在しないかのように記述する必要があります。</target>
        </trans-unit>
        <trans-unit id="5fe0a62d44f69e6416546051403b163d3b065fd0" translate="yes" xml:space="preserve">
          <source>Code blocks should also now maintain a consistent indentation level&amp;mdash;so an indentation of one tab (or whatever you consider to be a tab stop, like 2 spaces or 4 spaces) should be treated as your code&amp;rsquo;s &amp;ldquo;left margin,&amp;rdquo; with all code in the file relative to that column.</source>
          <target state="translated">コードブロックも一貫したインデントレベルを維持する必要があります。つまり、1つのタブ（または2つのスペースや4つのスペースなど、タブストップと見なされるもの）のインデントは、コードの「左マージン」として扱われ、すべてのコードがその列に関連するファイル。</target>
        </trans-unit>
        <trans-unit id="d51fafef78efa145bafb428481015a68d05f79b1" translate="yes" xml:space="preserve">
          <source>Code blocks that you want to be part of the commentary, and not executed, must have at least one line (ideally the first line of the block) completely unindented.</source>
          <target state="translated">コメントの一部とし、実行しないコードブロックは、少なくとも1行(理想的にはブロックの最初の1行)を完全にインデントしないようにしなければなりません。</target>
        </trans-unit>
        <trans-unit id="082a42c3704ee38739d3dd41511c5b78ea5ca8f3" translate="yes" xml:space="preserve">
          <source>CoffeeScript</source>
          <target state="translated">CoffeeScript</target>
        </trans-unit>
        <trans-unit id="555ad83e1b73fa461de685e684efafbb06947391" translate="yes" xml:space="preserve">
          <source>CoffeeScript 1 provided the &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;extends&lt;/code&gt; keywords as syntactic sugar for working with prototypal functions. With ES2015, JavaScript has adopted those keywords; so CoffeeScript 2 compiles its &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;extends&lt;/code&gt; keywords to ES2015 classes.</source>
          <target state="translated">CoffeeScript 1は &lt;code&gt;class&lt;/code&gt; を提供し、プロトタイプ関数を操作するための構文糖としてキーワードを &lt;code&gt;extends&lt;/code&gt; 。ES2015では、JavaScriptがそれらのキーワードを採用しています。CoffeeScriptの2ように、そのコンパイルし &lt;code&gt;class&lt;/code&gt; し、 &lt;code&gt;extends&lt;/code&gt; ES2015クラスにキーワードを。</target>
        </trans-unit>
        <trans-unit id="f07be14301b91058d1c6c7135618a2b966428618" translate="yes" xml:space="preserve">
          <source>CoffeeScript 1.x allowed the &lt;code&gt;extends&lt;/code&gt; keyword to set up prototypal inheritance between functions, and &lt;code&gt;super&lt;/code&gt; could be used manually prototype-assigned functions:</source>
          <target state="translated">CoffeeScript 1.xでは、 &lt;code&gt;extends&lt;/code&gt; キーワードを使用して関数間のプロトタイプの継承を設定でき、 &lt;code&gt;super&lt;/code&gt; は手動でプロトタイプに割り当てられた関数を使用できました。</target>
        </trans-unit>
        <trans-unit id="2e05d2fb1ef65aeec22154353f09cc33a5cf2c6c" translate="yes" xml:space="preserve">
          <source>CoffeeScript 2</source>
          <target state="translated">コーヒースクリプト 2</target>
        </trans-unit>
        <trans-unit id="e14399e2ffb6a507f01ea44f0297fe153054114d" translate="yes" xml:space="preserve">
          <source>CoffeeScript 2 aims to output as much idiomatic ES2015+ syntax as possible with as few breaking changes from CoffeeScript 1.x as possible. Some breaking changes, unfortunately, were unavoidable.</source>
          <target state="translated">CoffeeScript 2 は、CoffeeScript 1.x からの変更点をできるだけ少なくして、できるだけ多くの idiomatic ES2015+構文を出力することを目指しています。残念ながら、いくつかの変更は避けられませんでした。</target>
        </trans-unit>
        <trans-unit id="a88022140a2d5d855a42ac84ed596e5d08bb28cc" translate="yes" xml:space="preserve">
          <source>CoffeeScript 2 generates JavaScript that uses the latest, modern syntax. The runtime or browsers where you want your code to run &lt;a href=&quot;#compatibility&quot;&gt;might not support all of that syntax&lt;/a&gt;. In that case, we want to convert modern JavaScript into older JavaScript that will run in older versions of Node or older browsers; for example, &lt;code&gt;{ a } = obj&lt;/code&gt; into &lt;code&gt;a = obj.a&lt;/code&gt;. This is done via transpilers like &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;, &lt;a href=&quot;https://buble.surge.sh/&quot;&gt;Bubl&amp;eacute;&lt;/a&gt; or &lt;a href=&quot;https://github.com/google/traceur-compiler&quot;&gt;Traceur Compiler&lt;/a&gt;.</source>
          <target state="translated">CoffeeScript 2は、最新の最新の構文を使用するJavaScriptを生成します。コードを実行するランタイムまたはブラウザは&lt;a href=&quot;#compatibility&quot;&gt;、その構文のすべてをサポート&lt;/a&gt;していない場合があります。その場合、最新のJavaScriptを古いバージョンのNodeまたは古いブラウザーで実行できる古いJavaScriptに変換したいと考えています。たとえば、 &lt;code&gt;{ a } = obj&lt;/code&gt; into &lt;code&gt;a = obj.a&lt;/code&gt; です。これは、&lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;、&lt;a href=&quot;https://buble.surge.sh/&quot;&gt;Bubl&amp;eacute;、&lt;/a&gt;または&lt;a href=&quot;https://github.com/google/traceur-compiler&quot;&gt;Traceur Compiler&lt;/a&gt;などのトランスパイラーを介して行われます。</target>
        </trans-unit>
        <trans-unit id="ca8a8ef142b86f16c228064c3ea4de5a99994a0a" translate="yes" xml:space="preserve">
          <source>CoffeeScript 2&amp;rsquo;s parsing of Literate CoffeeScript has been refactored to now be more careful about not treating indented lists as code blocks; but this means that all code blocks (unless they are to be interpreted as comments) must be separated by at least one blank line from lists.</source>
          <target state="translated">CoffeeScript 2のLiterate CoffeeScriptの解析は、インデントされたリストをコードブロックとして扱わないように注意するようにリファクタリングされました。ただし、これは、すべてのコードブロック（コメントとして解釈される場合を除く）を、リストから少なくとも1行の空白行で区切る必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="0b2ffccac37a106e2b15a0c8a15a92e2320522bc" translate="yes" xml:space="preserve">
          <source>CoffeeScript borrows &lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#not-in&quot;&gt;chained comparisons&lt;/a&gt; from Python &amp;mdash; making it easy to test if a value falls within a certain range.</source>
          <target state="translated">CoffeeScriptはPythonから&lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#not-in&quot;&gt;連鎖比較&lt;/a&gt;を借用しているため、値が特定の範囲内にあるかどうかを簡単にテストできます。</target>
        </trans-unit>
        <trans-unit id="897a6b8fdb2cee9e51b9a916b9a26978c1b5ce7a" translate="yes" xml:space="preserve">
          <source>CoffeeScript can compile &lt;code&gt;if&lt;/code&gt; statements into JavaScript expressions, using the ternary operator when possible, and closure wrapping otherwise. There is no explicit ternary statement in CoffeeScript &amp;mdash; you simply use a regular &lt;code&gt;if&lt;/code&gt; statement on a single line.</source>
          <target state="translated">CoffeeScriptは、 &lt;code&gt;if&lt;/code&gt; ステートメントをJavaScript式にコンパイルし、可能な場合は三項演算子を使用し、それ以外の場合はクロージャーラップします。CoffeeScriptには明示的な3項ステートメントはありません。1 行で通常の &lt;code&gt;if&lt;/code&gt; ステートメントを使用するだけです。</target>
        </trans-unit>
        <trans-unit id="ed27d5551e9a44acadffac9bd86e6ee4d3d53ca3" translate="yes" xml:space="preserve">
          <source>CoffeeScript does not do any type checking itself; the JavaScript output you see above needs to get passed to Flow for it to validate your code. We expect most people will use a &lt;a href=&quot;#es2015plus-output&quot;&gt;build tool&lt;/a&gt; for this, but here&amp;rsquo;s how to do it the simplest way possible using the &lt;a href=&quot;#cli&quot;&gt;CoffeeScript&lt;/a&gt; and &lt;a href=&quot;https://flow.org/en/docs/usage/&quot;&gt;Flow&lt;/a&gt; command-line tools, assuming you&amp;rsquo;ve already &lt;a href=&quot;https://flow.org/en/docs/install/&quot;&gt;installed Flow&lt;/a&gt; and the &lt;a href=&quot;#installation&quot;&gt;latest CoffeeScript&lt;/a&gt; in your project folder:</source>
          <target state="translated">CoffeeScriptはそれ自体で型チェックを行いません。上記のJavaScript出力は、コードを検証するためにFlowに渡される必要があります。ほとんどの人がこれに&lt;a href=&quot;#es2015plus-output&quot;&gt;ビルドツール&lt;/a&gt;を使用することを期待していますが、プロジェクトフォルダーに&lt;a href=&quot;https://flow.org/en/docs/install/&quot;&gt;Flow&lt;/a&gt;と&lt;a href=&quot;#installation&quot;&gt;最新のCoffeeScript&lt;/a&gt;が既にインストールされていると想定して、&lt;a href=&quot;#cli&quot;&gt;CoffeeScript&lt;/a&gt;と&lt;a href=&quot;https://flow.org/en/docs/usage/&quot;&gt;Flow&lt;/a&gt;コマンドラインツールを使用して、最も簡単な方法でこれを行う方法を次に示します。</target>
        </trans-unit>
        <trans-unit id="06ec89ba18aa176efa0f4a92848e200506fd34ed" translate="yes" xml:space="preserve">
          <source>CoffeeScript has a shortcut for creating objects when you want the key to be set with a variable of the same name. Note that the &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; are required for this shorthand.</source>
          <target state="translated">CoffeeScriptには、キーに同じ名前の変数を設定する場合にオブジェクトを作成するためのショートカットがあります。ことに注意 &lt;code&gt;{&lt;/code&gt; と &lt;code&gt;}&lt;/code&gt; この速記のために必要とされます。</target>
        </trans-unit>
        <trans-unit id="39400b54ccebc49551a1b624ebd5fccd176ecf9a" translate="yes" xml:space="preserve">
          <source>CoffeeScript includes a (very) simple build system similar to &lt;a href=&quot;https://www.gnu.org/software/make/&quot;&gt;Make&lt;/a&gt; and &lt;a href=&quot;http://rake.rubyforge.org/&quot;&gt;Rake&lt;/a&gt;. Naturally, it&amp;rsquo;s called Cake, and is used for the tasks that build and test the CoffeeScript language itself. Tasks are defined in a file named &lt;code&gt;Cakefile&lt;/code&gt;, and can be invoked by running &lt;code&gt;cake [task]&lt;/code&gt; from within the directory. To print a list of all the tasks and options, just type &lt;code&gt;cake&lt;/code&gt;.</source>
          <target state="translated">CoffeeScriptには、&lt;a href=&quot;https://www.gnu.org/software/make/&quot;&gt;Make&lt;/a&gt;および&lt;a href=&quot;http://rake.rubyforge.org/&quot;&gt;Rakeに&lt;/a&gt;似た（非常に）単純なビルドシステムが含まれています。当然、これはCakeと呼ばれ、CoffeeScript言語自体をビルドしてテストするタスクに使用されます。タスクは &lt;code&gt;Cakefile&lt;/code&gt; という名前のファイルで定義され、ディレクトリ内から &lt;code&gt;cake [task]&lt;/code&gt; を実行することで呼び出すことができます。すべてのタスクとオプションのリストを印刷するには、単に &lt;code&gt;cake&lt;/code&gt; と入力します。</target>
        </trans-unit>
        <trans-unit id="eb466ef914e340bd4cbaa0c07a1d399d449cd21c" translate="yes" xml:space="preserve">
          <source>CoffeeScript includes support for generating source maps, a way to tell your JavaScript engine what part of your CoffeeScript program matches up with the code being evaluated. Browsers that support it can automatically use source maps to show your original source code in the debugger. To generate source maps alongside your JavaScript files, pass the &lt;code&gt;--map&lt;/code&gt; or &lt;code&gt;-m&lt;/code&gt; flag to the compiler.</source>
          <target state="translated">CoffeeScriptには、ソースマップの生成のサポートが含まれています。これは、CoffeeScriptプログラムのどの部分が評価対象のコードと一致するかをJavaScriptエンジンに伝える方法です。これをサポートするブラウザーは、ソースマップを自動的に使用して、デバッガーで元のソースコードを表示できます。 JavaScriptファイルと共にソースマップを生成するには、 &lt;code&gt;--map&lt;/code&gt; または &lt;code&gt;-m&lt;/code&gt; フラグをコンパイラに渡します。</target>
        </trans-unit>
        <trans-unit id="3db6d625e027881b87b075cf48db7c76a9bdaa5a" translate="yes" xml:space="preserve">
          <source>CoffeeScript supports &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals&quot;&gt;ES2015 tagged template literals&lt;/a&gt;, which enable customized string interpolation. If you immediately prefix a string with a function name (no space between the two), CoffeeScript will output this &amp;ldquo;function plus string&amp;rdquo; combination as an ES2015 tagged template literal, which will &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals&quot;&gt;behave accordingly&lt;/a&gt;: the function is called, with the parameters being the input text and expression parts that make up the interpolated string. The function can then assemble these parts into an output string, providing custom string interpolation.</source>
          <target state="translated">CoffeeScriptは、カスタマイズされた文字列補間を可能にする&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals&quot;&gt;ES2015タグ付きテンプレートリテラルを&lt;/a&gt;サポートしています。文字列の前に関数名（2つの間にスペースなし）をすぐに付けると、CoffeeScriptはこの「関数と文字列」の組み合わせをES2015タグ付きテンプレートリテラルとして出力し、それに&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals&quot;&gt;応じて動作します&lt;/a&gt;。関数が呼び出され、パラメーターが補間された文字列を構成する入力テキストと式の部分。次に、関数はこれらのパーツを出力文字列にアセンブルし、カスタム文字列補間を提供できます。</target>
        </trans-unit>
        <trans-unit id="6062d895dad2882c3d733740c8180cb30cd93245" translate="yes" xml:space="preserve">
          <source>CoffeeScript supports ES2015 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*&quot;&gt;generator functions&lt;/a&gt; through the &lt;code&gt;yield&lt;/code&gt; keyword. There&amp;rsquo;s no &lt;code&gt;function*(){}&lt;/code&gt; nonsense &amp;mdash; a generator in CoffeeScript is simply a function that yields.</source>
          <target state="translated">CoffeeScriptは、 &lt;code&gt;yield&lt;/code&gt; キーワードを介してES2015 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*&quot;&gt;ジェネレーター関数&lt;/a&gt;をサポートしています。 &lt;code&gt;function*(){}&lt;/code&gt; ナンセンスはありません。CoffeeScriptのジェネレーターは、単純に生成される関数です。</target>
        </trans-unit>
        <trans-unit id="a64e782a7ca1ed608a5e5d8b58e56c5b34418abf" translate="yes" xml:space="preserve">
          <source>CoffeeScript supports interspersed XML elements, without the need for separate plugins or special settings. The XML elements will be compiled as such, outputting JSX that could be parsed like any normal JSX file, for example by &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-react-jsx/&quot;&gt;Babel with the React JSX transform&lt;/a&gt;. CoffeeScript does &lt;em&gt;not&lt;/em&gt; output &lt;code&gt;React.createElement&lt;/code&gt; calls or any code specific to React or any other framework. It is up to you to attach another step in your build chain to convert this JSX to whatever function calls you wish the XML elements to compile to.</source>
          <target state="translated">CoffeeScriptは、個別のプラグインや特別な設定を必要とせずに、散在するXML要素をサポートします。XML要素はそのままコンパイルされ、たとえば&lt;a href=&quot;https://babeljs.io/docs/plugins/transform-react-jsx/&quot;&gt;React JSX変換を使用&lt;/a&gt;するBabelによって、通常のJSXファイルのように解析できるJSXを出力します。CoffeeScriptは&lt;em&gt;、&lt;/em&gt; &lt;code&gt;React.createElement&lt;/code&gt; 呼び出しや、Reactやその他のフレームワークに固有のコードを出力しませ&lt;em&gt;ん&lt;/em&gt;。ビルドチェーンに別のステップを追加して、このJSXを、XML要素をコンパイルする関数呼び出しに変換する必要があります。</target>
        </trans-unit>
        <trans-unit id="59b0754344014d9d6347724f39bcacbaf47c2e7d" translate="yes" xml:space="preserve">
          <source>Command Line</source>
          <target state="translated">コマンドライン</target>
        </trans-unit>
        <trans-unit id="fce06e20e5f7f74aacccab40b59b75a56c8f7305" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">Comments</target>
        </trans-unit>
        <trans-unit id="5d60c7dd62fdcf4abcc61a6a7d335b7117968b4d" translate="yes" xml:space="preserve">
          <source>Compatibility</source>
          <target state="translated">Compatibility</target>
        </trans-unit>
        <trans-unit id="4300e2d5a6e06edd248521ea98c722082a8b228a" translate="yes" xml:space="preserve">
          <source>Compile a &lt;code&gt;.coffee&lt;/code&gt; script into a &lt;code&gt;.js&lt;/code&gt; JavaScript file of the same name.</source>
          <target state="translated">&lt;code&gt;.coffee&lt;/code&gt; スクリプトを同じ名前の &lt;code&gt;.js&lt;/code&gt; JavaScriptファイルにコンパイルします。</target>
        </trans-unit>
        <trans-unit id="e6a3565f7ffca2f5f11e68c1b128efdad5b5cdd7" translate="yes" xml:space="preserve">
          <source>Compile a directory tree of &lt;code&gt;.coffee&lt;/code&gt; files in &lt;code&gt;src&lt;/code&gt; into a parallel tree of &lt;code&gt;.js&lt;/code&gt; files in &lt;code&gt;lib&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; の &lt;code&gt;.coffee&lt;/code&gt; ファイルのディレクトリツリーを &lt;code&gt;lib&lt;/code&gt; の &lt;code&gt;.js&lt;/code&gt; ファイルの並列ツリーにコンパイルします。</target>
        </trans-unit>
        <trans-unit id="0a3b0300d1b064869ff33a3d2ebe6e0e6baae51a" translate="yes" xml:space="preserve">
          <source>Compile and print a little snippet of CoffeeScript directly from the command line. For example:</source>
          <target state="translated">コマンドラインから直接CoffeeScriptをコンパイルして印刷します。例えば</target>
        </trans-unit>
        <trans-unit id="7c79230adcfcd792fe3990fd8abbc8770972c8c7" translate="yes" xml:space="preserve">
          <source>Compile the JavaScript without the &lt;a href=&quot;#lexical-scope&quot;&gt;top-level function safety wrapper&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#lexical-scope&quot;&gt;トップレベルの関数安全ラッパー&lt;/a&gt;なしでJavaScriptをコンパイルします。</target>
        </trans-unit>
        <trans-unit id="cfc3a5e15482fb7edb84902d1ef3f824dafd8030" translate="yes" xml:space="preserve">
          <source>Comprehensions can also be used to iterate over the keys and values in an object. Use &lt;code&gt;of&lt;/code&gt; to signal comprehension over the properties of an object instead of the values in an array.</source>
          <target state="translated">内包表記を使用して、オブジェクトのキーと値を反復することもできます。使用 &lt;code&gt;of&lt;/code&gt; 代わりに、配列内の値のオブジェクトのプロパティを超える信号理解します。</target>
        </trans-unit>
        <trans-unit id="23c37ee042c74f1f491788e4316571902ea348c4" translate="yes" xml:space="preserve">
          <source>Comprehensions should be able to handle most places where you otherwise would use a loop, &lt;code&gt;each&lt;/code&gt;/&lt;code&gt;forEach&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt;, or &lt;code&gt;select&lt;/code&gt;/&lt;code&gt;filter&lt;/code&gt;, for example:</source>
          <target state="translated">内包表記は、あなたがそれ以外の場合は、ループを使用するほとんどの場所に処理することができるはず &lt;code&gt;each&lt;/code&gt; / &lt;code&gt;forEach&lt;/code&gt; のは、 &lt;code&gt;map&lt;/code&gt; 、または &lt;code&gt;select&lt;/code&gt; / &lt;code&gt;filter&lt;/code&gt; たとえば、：</target>
        </trans-unit>
        <trans-unit id="f4408c72041f1642066f98a95c77bb7d47148a6c" translate="yes" xml:space="preserve">
          <source>Concatenate a list of files into a single script:</source>
          <target state="translated">ファイルのリストを1つのスクリプトに連結します。</target>
        </trans-unit>
        <trans-unit id="ec59c7801544b7219c543bca6994038a564b01b6" translate="yes" xml:space="preserve">
          <source>Default values for function parameters and destructured elements</source>
          <target state="translated">関数パラメータと破壊された要素のデフォルト値</target>
        </trans-unit>
        <trans-unit id="bf1be2b7ad07bae2fe92475d10173eb638774def" translate="yes" xml:space="preserve">
          <source>Definition</source>
          <target state="translated">Definition</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="3971221e4434ee7c22e0cd88456435a7a35e2f99" translate="yes" xml:space="preserve">
          <source>Destructuring Assignment</source>
          <target state="translated">デストラクチャリングの課題</target>
        </trans-unit>
        <trans-unit id="693d95d6190509bd73966d59486aedaea1f2f65e" translate="yes" xml:space="preserve">
          <source>Destructuring assignment can be used with any depth of array and object nesting, to help pull out deeply nested properties.</source>
          <target state="translated">デストラクチャリングの割り当ては、任意の深さの配列とオブジェクトの入れ子で使用することができ、深い入れ子になったプロパティを引き出すのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="084d80478954c0fd6df8a1f5371f23b6b7d2b0bb" translate="yes" xml:space="preserve">
          <source>Destructuring assignment can even be combined with splats.</source>
          <target state="translated">デストラクチャー課題はスプラッツと組み合わせることも可能です。</target>
        </trans-unit>
        <trans-unit id="03c2ead8f6c7800e07ddee30aab9ffe372df05ad" translate="yes" xml:space="preserve">
          <source>Destructuring assignment is also useful when combined with class constructors to assign properties to your instance from an options object passed to the constructor.</source>
          <target state="translated">デストラクチャリング代入は、コンストラクタに渡されたオプションオブジェクトからインスタンスにプロパティを代入するために、クラスのコンストラクタと組み合わせて使用する場合にも便利です。</target>
        </trans-unit>
        <trans-unit id="ee64309bcad68d432618adc16618ac8cd4342081" translate="yes" xml:space="preserve">
          <source>Double-quoted block strings, like other double-quoted strings, allow interpolation.</source>
          <target state="translated">二重引用符で囲まれたブロック文字列は、他の二重引用符で囲まれた文字列と同様に、補間を可能にします。</target>
        </trans-unit>
        <trans-unit id="76c71025ffe95216c3f2960d37aa6448ff56912e" translate="yes" xml:space="preserve">
          <source>Due to a syntax clash with &lt;code&gt;super&lt;/code&gt; with accessors, &amp;ldquo;bare&amp;rdquo; &lt;code&gt;super&lt;/code&gt; (the keyword &lt;code&gt;super&lt;/code&gt; without parentheses) no longer compiles to a super call forwarding all arguments.</source>
          <target state="translated">アクセサー付きの &lt;code&gt;super&lt;/code&gt; との構文の衝突により、「裸の」 &lt;code&gt;super&lt;/code&gt; （括弧なしのキーワード &lt;code&gt;super&lt;/code&gt; ）は、すべての引数を転送するsuper呼び出しにコンパイルされなくなりました。</target>
        </trans-unit>
        <trans-unit id="cd6c049a857c66bb824182c8c447a61a862212dd" translate="yes" xml:space="preserve">
          <source>Due to the hoisting required to compile to ES2015 classes, dynamic keys in class methods can&amp;rsquo;t use values from the executable class body unless the methods are assigned in prototype style.</source>
          <target state="translated">ES2015クラスへのコンパイルにはホイストが必要なため、クラスメソッドの動的キーは、メソッドがプロトタイプスタイルで割り当てられていない限り、実行可能なクラス本体の値を使用できません。</target>
        </trans-unit>
        <trans-unit id="abd4833636e3bf75c96fa84f99c79c1dfd504f8f" translate="yes" xml:space="preserve">
          <source>Due to the switch to ES2015 &lt;code&gt;extends&lt;/code&gt; and &lt;code&gt;super&lt;/code&gt;, using these keywords for prototypal functions are no longer supported. The above case could be refactored to:</source>
          <target state="translated">ES2015 &lt;code&gt;extends&lt;/code&gt; および &lt;code&gt;super&lt;/code&gt; への切り替えにより、これらのキーワードをプロトタイプ関数に使用することはサポートされなくなりました。上記のケースは、次のようにリファクタリングできます。</target>
        </trans-unit>
        <trans-unit id="68f15e98bbba94444d4a5758a91c0b8c7f4919c0" translate="yes" xml:space="preserve">
          <source>ES2015 classes and their methods have some restrictions beyond those on regular functions.</source>
          <target state="translated">ES2015のクラスとそのメソッドには、正規の関数以外にもいくつかの制限があります。</target>
        </trans-unit>
        <trans-unit id="686eb8e68104e706ebea5afdbc1c1082e68d1d72" translate="yes" xml:space="preserve">
          <source>ES2015 classes don&amp;rsquo;t allow bound (fat arrow) methods. The CoffeeScript compiler goes through some contortions to preserve support for them, but one thing that can&amp;rsquo;t be accommodated is calling a bound method before it is bound:</source>
          <target state="translated">ES2015クラスはバインドされた（太い矢印）メソッドを許可しません。CoffeeScriptコンパイラーは、サポートを維持するためにいくつかのゆがみを通過しますが、対応できないのは、バインドされる前にバインドされたメソッドを呼び出すことです。</target>
        </trans-unit>
        <trans-unit id="ee88a511a3dd54469352e7cc993bdb9390253e24" translate="yes" xml:space="preserve">
          <source>ES2015 modules are supported in CoffeeScript, with very similar &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; syntax:</source>
          <target state="translated">ES2015モジュールはCoffeeScriptでサポートされており、 &lt;code&gt;import&lt;/code&gt; と &lt;code&gt;export&lt;/code&gt; 構文は非常に似ています。</target>
        </trans-unit>
        <trans-unit id="a673b896c1665557ccd0cee7c0afccf5405fc642" translate="yes" xml:space="preserve">
          <source>ES2017&amp;rsquo;s &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;async functions&lt;/a&gt; are supported through the &lt;code&gt;await&lt;/code&gt; keyword. Like with generators, there&amp;rsquo;s no need for an &lt;code&gt;async&lt;/code&gt; keyword; an async function in CoffeeScript is simply a function that awaits.</source>
          <target state="translated">ES2017の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;非同期関数&lt;/a&gt;は、 &lt;code&gt;await&lt;/code&gt; キーワードでサポートされています。ジェネレーターと同様に、 &lt;code&gt;async&lt;/code&gt; キーワードは必要ありません。CoffeeScriptの非同期関数は、単に待機する関数です。</target>
        </trans-unit>
        <trans-unit id="bfc783ddd79a9914d8fbf1e5c70ddebce72e3d6a" translate="yes" xml:space="preserve">
          <source>Embedded JavaScript</source>
          <target state="translated">埋め込みJavaScript</target>
        </trans-unit>
        <trans-unit id="8d66e6697e4c4d59becd333355a57aeac2ef2cf1" translate="yes" xml:space="preserve">
          <source>Escape backslashes before backticks with more backslashes: &lt;code&gt; \\\`​&lt;/code&gt; becomes &lt;code&gt; \`​&lt;/code&gt;.</source>
          <target state="translated">より多くのバックスラッシュとバッククォートの前にバックスラッシュをエスケープ： &lt;code&gt; \\\`​&lt;/code&gt; になり &lt;code&gt; \`​&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a71f86015fbc5b12f95827124758fcdcd748d4e5" translate="yes" xml:space="preserve">
          <source>Escape backslashes before backticks with more backslashes: &lt;code&gt;\\\`​&lt;/code&gt; becomes &lt;code&gt;\`​&lt;/code&gt;.</source>
          <target state="translated">より多くのバックスラッシュとバッククォートの前にバックスラッシュをエスケープ： &lt;code&gt;\\\`​&lt;/code&gt; になり &lt;code&gt;\`​&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="793787c40f1cf7d655d3a05e62d7be445f6bf321" translate="yes" xml:space="preserve">
          <source>Escape backticks with backslashes: &lt;code&gt; \`​&lt;/code&gt; becomes &lt;code&gt; `​&lt;/code&gt;.</source>
          <target state="translated">バックスラッシュとバッククォートをエスケープ： &lt;code&gt; \`​&lt;/code&gt; となり &lt;code&gt; `​&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec5f2d9c1baacad5c9a2a2c7ebd37ab7e094639c" translate="yes" xml:space="preserve">
          <source>Escape backticks with backslashes: &lt;code&gt;\`​&lt;/code&gt; becomes &lt;code&gt;`​&lt;/code&gt;.</source>
          <target state="translated">バックスラッシュとバッククォートをエスケープ： &lt;code&gt;\`​&lt;/code&gt; となり &lt;code&gt;`​&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca324f5a8ab7f029b85119d0ccec4498c155b7a5" translate="yes" xml:space="preserve">
          <source>Even though functions will always return their final value, it&amp;rsquo;s both possible and encouraged to return early from a function body writing out the explicit return (&lt;code&gt;return value&lt;/code&gt;), when you know that you&amp;rsquo;re done.</source>
          <target state="translated">関数は常に最終値を返しますが、完了したことがわかっている場合は、関数本体から明示的な &lt;code&gt;return value&lt;/code&gt; （戻り値）を書き込んで早期に戻ることが可能であり、推奨されています。</target>
        </trans-unit>
        <trans-unit id="7fde14a080208598ce35fabd5b0ea5f2affbf555" translate="yes" xml:space="preserve">
          <source>Everything is an Expression</source>
          <target state="translated">すべては表現である</target>
        </trans-unit>
        <trans-unit id="7af36896f436a2940c2c5a2723b3bc0c8c329291" translate="yes" xml:space="preserve">
          <source>Everything is an Expression (at least, as much as possible)</source>
          <target state="translated">すべては表現である(少なくとも可能な限り</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="e2a4095571338493938d9208d1a8bdc53cd52da1" translate="yes" xml:space="preserve">
          <source>Existential Operator</source>
          <target state="translated">実存演算子</target>
        </trans-unit>
        <trans-unit id="340b3c1e6a8d3673bdad04f30b83addc47a3c77e" translate="yes" xml:space="preserve">
          <source>Expansion can be used to retrieve elements from the end of an array without having to assign the rest of its values. It works in function parameter lists as well.</source>
          <target state="translated">展開は、残りの値を代入することなく配列の末尾から要素を取得するために使用できます。これは、関数のパラメータリストでも動作します。</target>
        </trans-unit>
        <trans-unit id="9435e660888a944ea96d68e322b87de298b0b35d" translate="yes" xml:space="preserve">
          <source>Finally, class definitions are blocks of executable code, which make for interesting metaprogramming possibilities. In the context of a class definition, &lt;code&gt;this&lt;/code&gt; is the class object itself; therefore, you can assign static properties by using &lt;code&gt;@property: value&lt;/code&gt;.</source>
          <target state="translated">最後に、クラス定義は実行可能なコードのブロックであり、興味深いメタプログラミングの可能性をもたらします。クラス定義のコンテキストでは、 &lt;code&gt;this&lt;/code&gt; はクラスオブジェクト自体です。したがって、 &lt;code&gt;@property: value&lt;/code&gt; を使用して静的プロパティを割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="aa7d66d6f53b9efb770a67714bce600a748ba8a3" translate="yes" xml:space="preserve">
          <source>First, the basics: CoffeeScript uses significant whitespace to delimit blocks of code. You don&amp;rsquo;t need to use semicolons &lt;code&gt;;&lt;/code&gt; to terminate expressions, ending the line will do just as well (although semicolons can still be used to fit multiple expressions onto a single line). Instead of using curly braces &lt;code&gt;{ }&lt;/code&gt; to surround blocks of code in &lt;a href=&quot;#literals&quot;&gt;functions&lt;/a&gt;, &lt;a href=&quot;#conditionals&quot;&gt;if-statements&lt;/a&gt;, &lt;a href=&quot;#switch&quot;&gt;switch&lt;/a&gt;, and &lt;a href=&quot;#try&quot;&gt;try/catch&lt;/a&gt;, use indentation.</source>
          <target state="translated">まず、基本：CoffeeScriptはコードのブロックを区切るために重要な空白を使用します。セミコロンを使用する必要はありません &lt;code&gt;;&lt;/code&gt; 式を終了するには、行を終了することも同様に機能します（ただし、セミコロンを使用して複数の式を1行に収めることはできます）。中括弧 &lt;code&gt;{ }&lt;/code&gt; を使用して、&lt;a href=&quot;#literals&quot;&gt;functions&lt;/a&gt;、&lt;a href=&quot;#conditionals&quot;&gt;if-statements&lt;/a&gt;、&lt;a href=&quot;#switch&quot;&gt;switch&lt;/a&gt;、および&lt;a href=&quot;#try&quot;&gt;try / catch&lt;/a&gt;でコードのブロックを囲む代わりに、インデントを使用します。</target>
        </trans-unit>
        <trans-unit id="ee19e7cadbb13d1440abec3b34a17cd12b6c5c48" translate="yes" xml:space="preserve">
          <source>For a full introduction to source maps, how they work, and how to hook them up in your browser, read the &lt;a href=&quot;https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/&quot;&gt;HTML5 Tutorial&lt;/a&gt;.</source>
          <target state="translated">ソースマップの完全な概要、それらがどのように機能するか、およびそれらをブラウザーに接続する方法については、&lt;a href=&quot;https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/&quot;&gt;HTML5チュートリアルをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e01b86e80df0b25b6f0247ef3986bce39d12f358" translate="yes" xml:space="preserve">
          <source>For completeness:</source>
          <target state="translated">完全性のために。</target>
        </trans-unit>
        <trans-unit id="8a4f6d4faf8398cfa0cd411363607d10de4be976" translate="yes" xml:space="preserve">
          <source>For logic, &lt;code&gt;and&lt;/code&gt; compiles to &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, and &lt;code&gt;or&lt;/code&gt; into &lt;code&gt;||&lt;/code&gt;.</source>
          <target state="translated">ロジックのために、 &lt;code&gt;and&lt;/code&gt; コンパイルに &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 、および &lt;code&gt;or&lt;/code&gt; に &lt;code&gt;||&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1fa703ef8acae65b0063e84a587fc7eda00827c3" translate="yes" xml:space="preserve">
          <source>For readability, the &lt;code&gt;until&lt;/code&gt; keyword is equivalent to &lt;code&gt;while not&lt;/code&gt;, and the &lt;code&gt;loop&lt;/code&gt; keyword is equivalent to &lt;code&gt;while true&lt;/code&gt;.</source>
          <target state="translated">読みやすくするために、 &lt;code&gt;until&lt;/code&gt; キーワードは &lt;code&gt;while not&lt;/code&gt; と同等であり、 &lt;code&gt;loop&lt;/code&gt; キーワードは &lt;code&gt;while true&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="8898a99d18cf365fdf183321827b4e34c0860021" translate="yes" xml:space="preserve">
          <source>From the root of your project:</source>
          <target state="translated">プロジェクトのルートから</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="2f64931a65a6e89a9512c49457d675893ed09df0" translate="yes" xml:space="preserve">
          <source>Functions are defined by an optional list of parameters in parentheses, an arrow, and the function body. The empty function looks like this: &lt;code&gt;-&amp;gt;&lt;/code&gt;</source>
          <target state="translated">関数は、括弧で囲まれたオプションのパラメーターのリスト、矢印、および関数本体によって定義されます。空の関数は次のようになります： &lt;code&gt;-&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="98cb6e01b2ef1f74900d474df5478cc6c3f8d839" translate="yes" xml:space="preserve">
          <source>Functions may also have default values for arguments, which will be used if the incoming argument is missing (&lt;code&gt;undefined&lt;/code&gt;).</source>
          <target state="translated">関数は、引数のデフォルト値を持つこともできます。これは、入力引数がない場合（ &lt;code&gt;undefined&lt;/code&gt; ）に使用されます。</target>
        </trans-unit>
        <trans-unit id="91daad92fe0111679b312c13903a169bf2881f3a" translate="yes" xml:space="preserve">
          <source>Generate an abstract syntax tree of nodes of the CoffeeScript. Used for integrating with JavaScript build tools.</source>
          <target state="translated">CoffeeScript のノードの抽象構文ツリーを生成します。JavaScriptのビルドツールとの統合に使用します。</target>
        </trans-unit>
        <trans-unit id="3c74a2f5bbae6a65aa71e01f3ca337b3eb0139aa" translate="yes" xml:space="preserve">
          <source>Generate source maps alongside the compiled JavaScript files. Adds &lt;code&gt;sourceMappingURL&lt;/code&gt; directives to the JavaScript as well.</source>
          <target state="translated">コンパイルされたJavaScriptファイルとともにソースマップを生成します。JavaScriptにも &lt;code&gt;sourceMappingURL&lt;/code&gt; ディレクティブを追加します。</target>
        </trans-unit>
        <trans-unit id="532aff027e5f3d32201aa60d2efb5271e9bd4744" translate="yes" xml:space="preserve">
          <source>Generator Functions</source>
          <target state="translated">ジェネレータ機能</target>
        </trans-unit>
        <trans-unit id="e76ffcd1f650481542d7dda729cb91d61d3111a0" translate="yes" xml:space="preserve">
          <source>Hopefully, you&amp;rsquo;ll never need to use it, but if you ever need to intersperse snippets of JavaScript within your CoffeeScript, you can use backticks to pass it straight through.</source>
          <target state="translated">うまくいけば、それを使用する必要は決してないでしょうが、CoffeeScript内にJavaScriptのスニペットを散在させる必要がある場合は、バッククォートを使用して直接通過させることができます。</target>
        </trans-unit>
        <trans-unit id="abe858446febb39efadf27fc1b2fba8c7df3ab4e" translate="yes" xml:space="preserve">
          <source>If a variable might be undeclared, the compiler does a thorough check. This is what JavaScript coders &lt;em&gt;should&lt;/em&gt; be typing when they want to check if a mystery variable exists.</source>
          <target state="translated">変数が宣言されていない可能性がある場合、コンパイラは徹底的なチェックを行います。これは、JavaScriptプログラマー&lt;em&gt;が&lt;/em&gt;ミステリー変数が存在するかどうかを確認するときに入力する&lt;em&gt;必要&lt;/em&gt;があるものです。</target>
        </trans-unit>
        <trans-unit id="0cfbe04d5e5abb311561c2a3f5993f9e83c1d7a6" translate="yes" xml:space="preserve">
          <source>If this were saved as &lt;code&gt;executable.coffee&lt;/code&gt;, it could be made executable and run:</source>
          <target state="translated">これを &lt;code&gt;executable.coffee&lt;/code&gt; として保存した場合、実行可能にして実行できます：</target>
        </trans-unit>
        <trans-unit id="42eb1c2c93bbc5c5388c60ca8defece372ea8114" translate="yes" xml:space="preserve">
          <source>If we had used &lt;code&gt;-&amp;gt;&lt;/code&gt; in the callback above, &lt;code&gt;@customer&lt;/code&gt; would have referred to the undefined &amp;ldquo;customer&amp;rdquo; property of the DOM element, and trying to call &lt;code&gt;purchase()&lt;/code&gt; on it would have raised an exception.</source>
          <target state="translated">上記のコールバックで &lt;code&gt;-&amp;gt;&lt;/code&gt; を使用した場合、 &lt;code&gt;@customer&lt;/code&gt; はDOM要素の未定義の「customer」プロパティを参照し、その上で &lt;code&gt;purchase()&lt;/code&gt; を呼び出そうとすると例外が発生します。</target>
        </trans-unit>
        <trans-unit id="7e3d568c0c336ebae7d8c3b53ecc75b8f5da93b6" translate="yes" xml:space="preserve">
          <source>If you are using CoffeeScript in a project, you should install it locally for that project so that the version of CoffeeScript is tracked as one of your project&amp;rsquo;s dependencies. Within that project&amp;rsquo;s folder:</source>
          <target state="translated">プロジェクトでCoffeeScriptを使用している場合は、CoffeeScriptのバージョンがプロジェクトの依存関係の1つとして追跡されるように、そのプロジェクト用にローカルにインストールする必要があります。そのプロジェクトのフォルダー内：</target>
        </trans-unit>
        <trans-unit id="9dbf6cbf52cbf3a1c6022d16008907342c32a283" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t need the current iteration value you may omit it: &lt;code&gt;browser.closeCurrentTab() for [0...count]&lt;/code&gt;</source>
          <target state="translated">現在の反復値が必要ない場合は省略できます： &lt;code&gt;browser.closeCurrentTab() for [0...count]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53c4a51d299b5a23747c3c2aa3bbf171cdb568d0" translate="yes" xml:space="preserve">
          <source>If you know of another way to achieve static type checking with CoffeeScript, please &lt;a href=&quot;https://github.com/jashkenas/coffeescript/issues/new&quot;&gt;create an issue&lt;/a&gt; and let us know.</source>
          <target state="translated">CoffeeScriptで静的型チェックを実現する別の方法をご存知の場合は&lt;a href=&quot;https://github.com/jashkenas/coffeescript/issues/new&quot;&gt;、問題&lt;/a&gt;を作成してお知らせください。</target>
        </trans-unit>
        <trans-unit id="e4cb8e7ac3be882b151de631a19cf2ab37f9bb1b" translate="yes" xml:space="preserve">
          <source>If you know the start and end of your loop, or would like to step through in fixed-size increments, you can use a range to specify the start and end of your comprehension.</source>
          <target state="translated">ループの開始と終了がわかっている場合や、固定サイズでステップスルーしたい場合は、範囲を使って理解度の開始と終了を指定することができます。</target>
        </trans-unit>
        <trans-unit id="690eeea1dea81c1df3ff122ee050e1d70f25607b" translate="yes" xml:space="preserve">
          <source>If you need to invoke one task before another &amp;mdash; for example, running &lt;code&gt;build&lt;/code&gt; before &lt;code&gt;test&lt;/code&gt;, you can use the &lt;code&gt;invoke&lt;/code&gt; function: &lt;code&gt;invoke 'build'&lt;/code&gt;. Cake tasks are a minimal way to expose your CoffeeScript functions to the command line, so &lt;a href=&quot;https://coffeescript.org/v2/annotated-source/cake.html&quot;&gt;don&amp;rsquo;t expect any fanciness built-in&lt;/a&gt;. If you need dependencies, or async callbacks, it&amp;rsquo;s best to put them in your code itself &amp;mdash; not the cake task.</source>
          <target state="translated">あるタスクを別のタスクの前に呼び出す必要がある場合（たとえば、 &lt;code&gt;test&lt;/code&gt; 前に &lt;code&gt;build&lt;/code&gt; 実行する場合）、 &lt;code&gt;invoke&lt;/code&gt; 関数を使用できます： &lt;code&gt;invoke 'build'&lt;/code&gt; 。Cakeタスクは、CoffeeScript関数をコマンドラインに公開するための最小限の方法なので、&lt;a href=&quot;https://coffeescript.org/v2/annotated-source/cake.html&quot;&gt;組み込みの空想を期待しないでください&lt;/a&gt;。依存関係や非同期コールバックが必要な場合は、ケーキタスクではなく、コード自体に配置することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="6183792822af0844154cbd94b88cbdf4d74c526f" translate="yes" xml:space="preserve">
          <source>If you plan to use the &lt;code&gt;--transpile&lt;/code&gt; option (see &lt;a href=&quot;#transpilation&quot;&gt;Transpilation&lt;/a&gt;) you will need to also install &lt;code&gt;@babel/core&lt;/code&gt; either globally or locally, depending on whether you are running a globally or locally installed version of CoffeeScript.</source>
          <target state="translated">&lt;code&gt;--transpile&lt;/code&gt; オプション（&lt;a href=&quot;#transpilation&quot;&gt;Transpilationを&lt;/a&gt;参照）を使用する場合は、CoffeeScriptのグローバルにインストールされているバージョンとローカルにインストールされているバージョンのどちらを実行しているかに応じて、グローバルまたはローカルで &lt;code&gt;@babel/core&lt;/code&gt; もインストールする必要があります。</target>
        </trans-unit>
        <trans-unit id="16a1eb24f6b65a8ec749d8523bc57eb23ee0101f" translate="yes" xml:space="preserve">
          <source>If you want to use the compiler&amp;rsquo;s API, for example to make an app that compiles strings of CoffeeScript on the fly, you can &lt;code&gt;require&lt;/code&gt; the full module:</source>
          <target state="translated">コンパイラのAPIを使用する場合、たとえば、CoffeeScriptの文字列をその場でコンパイルするアプリを作成する &lt;code&gt;require&lt;/code&gt; は、完全なモジュールを要求できます。</target>
        </trans-unit>
        <trans-unit id="e2028691c6ca114b3e56e788fbd92f28d5fc0156" translate="yes" xml:space="preserve">
          <source>If you would like to iterate over just the keys that are defined on the object itself, by adding a &lt;code&gt;hasOwnProperty&lt;/code&gt; check to avoid properties that may be inherited from the prototype, use &lt;code&gt;for own key, value of object&lt;/code&gt;.</source>
          <target state="translated">オブジェクト自体に定義されているキーのみを反復処理する場合は、 &lt;code&gt;hasOwnProperty&lt;/code&gt; チェックを追加して、プロトタイプから継承される可能性のあるプロパティを回避し &lt;code&gt;for own key, value of object&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="592b59788a4d3ef118683778c8b805c5c84cd8ca" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to create top-level variables for other scripts to use, attach them as properties on &lt;code&gt;window&lt;/code&gt;; attach them as properties on the &lt;code&gt;exports&lt;/code&gt; object in CommonJS; or use an &lt;a href=&quot;#modules&quot;&gt;&lt;code&gt;export&lt;/code&gt; statement&lt;/a&gt;. If you&amp;rsquo;re targeting both CommonJS and the browser, the &lt;a href=&quot;#existential-operator&quot;&gt;existential operator&lt;/a&gt; (covered below), gives you a reliable way to figure out where to add them: &lt;code&gt;exports ? this&lt;/code&gt;.</source>
          <target state="translated">他のスクリプトで使用するトップレベルの変数を作成する場合は、それらを &lt;code&gt;window&lt;/code&gt; のプロパティとしてアタッチします。CommonJS の &lt;code&gt;exports&lt;/code&gt; オブジェクトのプロパティとしてそれらをアタッチします。または&lt;a href=&quot;#modules&quot;&gt; &lt;code&gt;export&lt;/code&gt; ステートメントを&lt;/a&gt;使用します。CommonJSとブラウザーの両方を対象としている場合、&lt;a href=&quot;#existential-operator&quot;&gt;存在演算子&lt;/a&gt;（下記で説明）は、それらをどこに追加する &lt;code&gt;exports ? this&lt;/code&gt; する信頼できる方法を提供します。これ。</target>
        </trans-unit>
        <trans-unit id="146aec742e33fd45508faaf1fd9479d63b8d9e3b" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to use Node.js&amp;rsquo; CommonJS to &lt;code&gt;require&lt;/code&gt; CoffeeScript files, e.g. &lt;code&gt;require './app.coffee'&lt;/code&gt;, you must first &amp;ldquo;register&amp;rdquo; CoffeeScript as an extension:</source>
          <target state="translated">Node.jsのCommonJSを使用してCoffeeScriptファイルを &lt;code&gt;require&lt;/code&gt; 場合、たとえば &lt;code&gt;require './app.coffee'&lt;/code&gt; 場合は、最初にCoffeeScriptを拡張子として「登録」する必要があります。</target>
        </trans-unit>
        <trans-unit id="46e33650ad57bc5c400b19005fe7df0765a3fb90" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using CoffeeScript via the &lt;a href=&quot;https://coffeescript.org/nodejs_usage&quot;&gt;Node API&lt;/a&gt;, where you call &lt;code&gt;CoffeeScript.compile&lt;/code&gt; with a string to be compiled and an &lt;code&gt;options&lt;/code&gt; object, the &lt;code&gt;transpile&lt;/code&gt; key of the &lt;code&gt;options&lt;/code&gt; object should be the Babel options:</source>
          <target state="translated">あなたが経由でのCoffeeScriptを使用している場合は&lt;a href=&quot;https://coffeescript.org/nodejs_usage&quot;&gt;ノードAPI&lt;/a&gt;を呼び出す、 &lt;code&gt;CoffeeScript.compile&lt;/code&gt; をコンパイルする文字列として &lt;code&gt;options&lt;/code&gt; オブジェクト、 &lt;code&gt;transpile&lt;/code&gt; ののキー &lt;code&gt;options&lt;/code&gt; オブジェクトは、バベルのオプションでなければなりません。</target>
        </trans-unit>
        <trans-unit id="016766665df92106ffce5000526613553ce1231c" translate="yes" xml:space="preserve">
          <source>If, Else, Unless, and Conditional Assignment</source>
          <target state="translated">If,Else,Unless,および条件付き代入</target>
        </trans-unit>
        <trans-unit id="1e1733da0a2b3323346e10e76e4e0da637c155fe" translate="yes" xml:space="preserve">
          <source>In CoffeeScript 1.x, &lt;code&gt;--&lt;/code&gt; was required after the path and filename of the script to be run, but before any arguments passed to that script. This convention is now deprecated. So instead of:</source>
          <target state="translated">CoffeeScript 1.xでは、 &lt;code&gt;--&lt;/code&gt; は、実行するスクリプトのパスとファイル名の後で、そのスクリプトに渡される引数の前に必要でした。この規則は廃止されました。だから代わりに：</target>
        </trans-unit>
        <trans-unit id="7064346047d308376ffa12374eb5bf9c93709bc8" translate="yes" xml:space="preserve">
          <source>In CoffeeScript 1.x, &lt;code&gt;=&amp;gt;&lt;/code&gt; compiled to a regular &lt;code&gt;function&lt;/code&gt; but with references to &lt;code&gt;this&lt;/code&gt;/&lt;code&gt;@&lt;/code&gt; rewritten to use the outer scope&amp;rsquo;s &lt;code&gt;this&lt;/code&gt;, or with the inner function bound to the outer scope via &lt;code&gt;.bind&lt;/code&gt; (hence the name &amp;ldquo;bound function&amp;rdquo;). In CoffeeScript 2, &lt;code&gt;=&amp;gt;&lt;/code&gt; compiles to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;ES2015&amp;rsquo;s &lt;code&gt;=&amp;gt;&lt;/code&gt;&lt;/a&gt;, which behaves slightly differently. The largest difference is that in ES2015, &lt;code&gt;=&amp;gt;&lt;/code&gt; functions lack an &lt;code&gt;arguments&lt;/code&gt; object:</source>
          <target state="translated">CoffeeScript 1.xでは、 &lt;code&gt;=&amp;gt;&lt;/code&gt; は通常の &lt;code&gt;function&lt;/code&gt; コンパイルされますが、 &lt;code&gt;this&lt;/code&gt; / &lt;code&gt;@&lt;/code&gt; への参照を使用して、外側のスコープの &lt;code&gt;this&lt;/code&gt; を使用するように書き直されているか、内側の関数が &lt;code&gt;.bind&lt;/code&gt; を介して外側のスコープにバインドされています。 CoffeeScript 2では、 &lt;code&gt;=&amp;gt;&lt;/code&gt; は&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;ES2015の &lt;code&gt;=&amp;gt;&lt;/code&gt; に&lt;/a&gt;コンパイルされますが、動作は少し異なります。最大の違いは、ES2015では &lt;code&gt;=&amp;gt;&lt;/code&gt; 関数に &lt;code&gt;arguments&lt;/code&gt; オブジェクトがないことです。</target>
        </trans-unit>
        <trans-unit id="04b792bc52fa41c8f5a917a0ddd4654b6dc5918b" translate="yes" xml:space="preserve">
          <source>In CoffeeScript 1.x, this used to fail when trying to pass arguments to the script. Some users on OS X worked around the problem by using &lt;code&gt;#!/usr/bin/env coffee --&lt;/code&gt; as the first line of the file. That didn&amp;rsquo;t work on Linux, however, which cannot parse shebang lines with more than a single argument. While such scripts will still run on OS X, CoffeeScript will now display a warning before compiling or evaluating files that begin with a too-long shebang line. Now that CoffeeScript 2 supports passing arguments without needing &lt;code&gt;--&lt;/code&gt;, we recommend simply changing the shebang lines in such scripts to just &lt;code&gt;#!/usr/bin/env coffee&lt;/code&gt;.</source>
          <target state="translated">CoffeeScript 1.xでは、スクリプトに引数を渡そうとすると失敗していました。 OS Xの一部のユーザーは、ファイルの最初の行として &lt;code&gt;#!/usr/bin/env coffee --&lt;/code&gt; を使用して問題を回避しました。ただし、これはLinuxでは機能しませんでした。複数の引数を持つシバン行を解析できません。このようなスクリプトは引き続きOS Xで実行されますが、CoffeeScriptは、長すぎるシバン行で始まるファイルをコンパイルまたは評価する前に警告を表示します。必要とせずに引数を渡すのCoffeeScript 2つのサポートしていることを今 &lt;code&gt;--&lt;/code&gt; 、私たちはこのようなスクリプトでシェバング行を変更するだけでお勧めします &lt;code&gt;#!/usr/bin/env coffee&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="788287c76d023cee7c5e146f9e2387cfe9252f53" translate="yes" xml:space="preserve">
          <source>In CoffeeScript, comments are denoted by the &lt;code&gt;#&lt;/code&gt; character to the end of a line, or from &lt;code&gt;###&lt;/code&gt; to the next appearance of &lt;code&gt;###&lt;/code&gt;. Comments are ignored by the compiler, though the compiler makes its best effort at reinserting your comments into the output JavaScript after compilation.</source>
          <target state="translated">CoffeeScriptのでは、コメントがで示されている &lt;code&gt;#&lt;/code&gt; の行の最後まで、またはから文字 &lt;code&gt;###&lt;/code&gt; の次の出現に &lt;code&gt;###&lt;/code&gt; 。コメントはコンパイラーによって無視されますが、コンパイラーは、コンパイル後にコメントを出力JavaScriptに再挿入するために最善を尽くします。</target>
        </trans-unit>
        <trans-unit id="9ffbb2a04cb76868837eab857f3bd0071b209bde" translate="yes" xml:space="preserve">
          <source>In ECMAScript this is called &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;spread syntax&lt;/a&gt;, and has been supported for arrays since ES2015 and objects since ES2018.</source>
          <target state="translated">ECMAScriptでは、これは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;スプレッド構文&lt;/a&gt;と呼ばれ、ES2015以降の配列およびES2018以降のオブジェクトでサポートされています。</target>
        </trans-unit>
        <trans-unit id="d2f7a2b157c518d92490aade9f7bd6b939d63730" translate="yes" xml:space="preserve">
          <source>In JavaScript, the &lt;code&gt;this&lt;/code&gt; keyword is dynamically scoped to mean the object that the current function is attached to. If you pass a function as a callback or attach it to a different object, the original value of &lt;code&gt;this&lt;/code&gt; will be lost. If you&amp;rsquo;re not familiar with this behavior, &lt;a href=&quot;https://web.archive.org/web/20150316122013/http://www.digital-web.com/articles/scope_in_javascript&quot;&gt;this Digital Web article&lt;/a&gt; gives a good overview of the quirks.</source>
          <target state="translated">JavaScriptでは、 &lt;code&gt;this&lt;/code&gt; キーワードは動的にスコープされ、現在の関数が関連付けられているオブジェクトを意味します。関数をコールバックとして渡すか、別のオブジェクトにアタッチすると、 &lt;code&gt;this&lt;/code&gt; 元の値は失われます。この振る舞いに慣れていない場合は、&lt;a href=&quot;https://web.archive.org/web/20150316122013/http://www.digital-web.com/articles/scope_in_javascript&quot;&gt;このデジタルWeb記事&lt;/a&gt;で、癖の概要を説明しています。</target>
        </trans-unit>
        <trans-unit id="58ccf15493189686fa8384205d1ffa6634f16256" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;for&lt;/code&gt; loop, &lt;code&gt;from&lt;/code&gt; compiles to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;ES2015 &lt;code&gt;of&lt;/code&gt;&lt;/a&gt;. (Yes, it&amp;rsquo;s unfortunate; the CoffeeScript &lt;code&gt;of&lt;/code&gt; predates the ES2015 &lt;code&gt;of&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; ループ &lt;code&gt;from&lt;/code&gt; のコンパイル&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;ES2015 &lt;code&gt;of&lt;/code&gt; &lt;/a&gt;。（はい、残念ですが、のCoffeeScript &lt;code&gt;of&lt;/code&gt; ES2015以前のもの &lt;code&gt;of&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="a40e241967ca5277adef3eea005b6b4be0ffdb99" translate="yes" xml:space="preserve">
          <source>In addition to supporting ES2015 classes, CoffeeScript provides a shortcut for working with prototypes. The &lt;code&gt;::&lt;/code&gt; operator gives you quick access to an object&amp;rsquo;s prototype:</source>
          <target state="translated">ES2015クラスのサポートに加えて、CoffeeScriptはプロトタイプを操作するためのショートカットを提供します。 &lt;code&gt;::&lt;/code&gt; 演算子は、あなたのオブジェクトのプロトタイプにすばやくアクセスできます。</target>
        </trans-unit>
        <trans-unit id="451347f5385b9e51f536746d2dbc2451299a59b5" translate="yes" xml:space="preserve">
          <source>In the constructor of a derived class (a class that &lt;code&gt;extends&lt;/code&gt; another class), &lt;code&gt;this&lt;/code&gt; cannot be used before calling &lt;code&gt;super&lt;/code&gt;:</source>
          <target state="translated">派生クラス（別のクラスを &lt;code&gt;extends&lt;/code&gt; するクラス）のコンストラクターでは、 &lt;code&gt;this&lt;/code&gt; は &lt;code&gt;super&lt;/code&gt; を呼び出す前に使用できません。</target>
        </trans-unit>
        <trans-unit id="ba1d2a3ac8a3cfec3370e8237d30cfd830778b27" translate="yes" xml:space="preserve">
          <source>Inline &lt;code&gt;###&lt;/code&gt; comments make &lt;a href=&quot;#type-annotations&quot;&gt;type annotations&lt;/a&gt; possible.</source>
          <target state="translated">インライン &lt;code&gt;###&lt;/code&gt; コメントは&lt;a href=&quot;#type-annotations&quot;&gt;型注釈を&lt;/a&gt;可能にします。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="6cb9cbd3b08c7fd8fb0c40e013ef550f116fcf3b" translate="yes" xml:space="preserve">
          <source>Instead of a newline or semicolon, &lt;code&gt;then&lt;/code&gt; can be used to separate conditions from expressions, in &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;, and &lt;code&gt;switch&lt;/code&gt;/&lt;code&gt;when&lt;/code&gt; statements.</source>
          <target state="translated">代わりに改行またはセミコロンで、 &lt;code&gt;then&lt;/code&gt; に、表現とは別の条件に使用することができ &lt;code&gt;while&lt;/code&gt; 、 &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; 、および &lt;code&gt;switch&lt;/code&gt; / &lt;code&gt;when&lt;/code&gt; のステートメント。</target>
        </trans-unit>
        <trans-unit id="288bf7e5a0f1cc7c60023fb37b337bf4edaa3530" translate="yes" xml:space="preserve">
          <source>Instead of compiling the CoffeeScript, just lex and parse it, and print out the parse tree. Used for debugging the compiler.</source>
          <target state="translated">CoffeeScriptをコンパイルするのではなく、Lexして解析して、解析ツリーを出力するだけです。コンパイラのデバッグに使用します。</target>
        </trans-unit>
        <trans-unit id="3ca0e2b8ad0603647ea093f1fbd32497da2b06a4" translate="yes" xml:space="preserve">
          <source>Instead of parsing the CoffeeScript, just lex it, and print out the token stream. Used for debugging the compiler.</source>
          <target state="translated">CoffeeScriptを解析するのではなく、Lexするだけで、トークンストリームを出力します。コンパイラのデバッグに使用します。</target>
        </trans-unit>
        <trans-unit id="1448cab4186e9f54c8b08d7cd2d0636b94d3ac93" translate="yes" xml:space="preserve">
          <source>Instead of writing out the JavaScript as a file, print it directly to &lt;strong&gt;stdout&lt;/strong&gt;.</source>
          <target state="translated">JavaScriptをファイルとして書き出す代わりに、直接&lt;strong&gt;stdoutに出力し&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="7b3c2dba907edd3594545f099a0344f3f1d12c7b" translate="yes" xml:space="preserve">
          <source>It can also be used for safer conditional assignment than the JavaScript pattern &lt;code&gt;a = a || value&lt;/code&gt; provides, for cases where you may be handling numbers or strings.</source>
          <target state="translated">また、JavaScriptパターン &lt;code&gt;a = a || value&lt;/code&gt; よりも安全な条件付き割り当てに使用できます。valueは、数値または文字列を処理する可能性がある場合に提供します。</target>
        </trans-unit>
        <trans-unit id="4656fa0b7f789159a4076da2dd99866678c8fbb1" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a little difficult to check for the existence of a variable in JavaScript. &lt;code&gt;if (variable) &amp;hellip;&lt;/code&gt; comes close, but fails for zero, the empty string, and false (to name just the most common cases). CoffeeScript&amp;rsquo;s existential operator &lt;code&gt;?&lt;/code&gt; returns true unless a variable is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; or undeclared, which makes it analogous to Ruby&amp;rsquo;s &lt;code&gt;nil?&lt;/code&gt;.</source>
          <target state="translated">JavaScriptで変数の存在を確認するのは少し難しいです。 &lt;code&gt;if (variable) &amp;hellip;&lt;/code&gt; が近づいたが、ゼロ、空の文字列、およびfalse（最も一般的なケースを示すため）で失敗した場合。CoffeeScriptの存在演算子 &lt;code&gt;?&lt;/code&gt; 変数が &lt;code&gt;null&lt;/code&gt; 、 &lt;code&gt;undefined&lt;/code&gt; または宣言されていない場合を除き、trueを返します。これにより、Rubyの &lt;code&gt;nil?&lt;/code&gt; 類似していますか？。</target>
        </trans-unit>
        <trans-unit id="0e4779d05c5a545a6bd2f3323d3fe430a37f5d7b" translate="yes" xml:space="preserve">
          <source>JSX</source>
          <target state="translated">JSX</target>
        </trans-unit>
        <trans-unit id="c5be221a82247da9792ee8a3ab8649882bae0a0f" translate="yes" xml:space="preserve">
          <source>JSX and the &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; operators</source>
          <target state="translated">JSXと &lt;code&gt;&amp;lt;&lt;/code&gt; および &lt;code&gt;&amp;gt;&lt;/code&gt; 演算子</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="fb109f3d3ac46e3151be505c1e1c1768023b31d1" translate="yes" xml:space="preserve">
          <source>Just for kicks, a little bit of the compiler is currently implemented in this fashion: See it &lt;a href=&quot;https://gist.github.com/jashkenas/3fc3c1a8b1009c00d9df&quot;&gt;as a document&lt;/a&gt;, &lt;a href=&quot;https://raw.githubusercontent.com/jashkenas/coffeescript/master/src/scope.litcoffee&quot;&gt;raw&lt;/a&gt;, and &lt;a href=&quot;https://cl.ly/LxEu&quot;&gt;properly highlighted in a text editor&lt;/a&gt;.</source>
          <target state="translated">それを参照してください：ちょうどキックのために、コンパイラの少しは、現在、この方法で実装されている&lt;a href=&quot;https://gist.github.com/jashkenas/3fc3c1a8b1009c00d9df&quot;&gt;文書として&lt;/a&gt;、&lt;a href=&quot;https://raw.githubusercontent.com/jashkenas/coffeescript/master/src/scope.litcoffee&quot;&gt;生の&lt;/a&gt;、そして&lt;a href=&quot;https://cl.ly/LxEu&quot;&gt;適切にテキストエディタで強調表示します&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1e7d0e20d61ed8a7062ca711313b21c2b761a366" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;--map&lt;/code&gt;, but include the source map directly in the compiled JavaScript files, rather than in a separate file.</source>
          <target state="translated">&lt;code&gt;--map&lt;/code&gt; と同じですが、ソースマップを個別のファイルではなく、コンパイルされたJavaScriptファイルに直接含めます。</target>
        </trans-unit>
        <trans-unit id="ea7ef5627d33e5626e9aefb01f2fd84df3980789" translate="yes" xml:space="preserve">
          <source>Just like JavaScript (since ES2015), CoffeeScript has destructuring assignment syntax. When you assign an array or object literal to a value, CoffeeScript breaks up and matches both sides against each other, assigning the values on the right to the variables on the left. In the simplest case, it can be used for parallel assignment:</source>
          <target state="translated">JavaScriptと同様に(ES2015以降)、CoffeeScriptにもデストラクチャリング代入構文があります。配列やオブジェクトリテラルを値に代入すると、CoffeeScriptは分解して両側をマッチさせ、右の値を左の変数に代入します。最も単純なケースでは、並列代入にも使えます。</target>
        </trans-unit>
        <trans-unit id="4c6043a5a849b28412ad4dbe8490852a177ab12e" translate="yes" xml:space="preserve">
          <source>Just like in JSX and HTML, denote XML tags using &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;. You can interpolate CoffeeScript code inside a tag using &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;. To avoid compiler errors, when using &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; to mean &amp;ldquo;less than&amp;rdquo; or &amp;ldquo;greater than,&amp;rdquo; you should wrap the operators in spaces to distinguish them from XML tags. So &lt;code&gt;i &amp;lt; len&lt;/code&gt;, not &lt;code&gt;i&amp;lt;len&lt;/code&gt;. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the &amp;ldquo;less than&amp;rdquo; and &amp;ldquo;greater than&amp;rdquo; operators will remove ambiguity.</source>
          <target state="translated">JSXやHTMLと同様に、 &lt;code&gt;&amp;lt;&lt;/code&gt; および &lt;code&gt;&amp;gt;&lt;/code&gt; を使用してXMLタグを示します。 &lt;code&gt;{&lt;/code&gt; および &lt;code&gt;}&lt;/code&gt; を使用して、タグ内のCoffeeScriptコードを補間できます。コンパイラエラーを回避するには、 &lt;code&gt;&amp;lt;&lt;/code&gt; および &lt;code&gt;&amp;gt;&lt;/code&gt; を使用して「より小さい」または「より大きい」を意味する場合、演算子をスペースで囲み、XMLタグと区別します。したがって、 &lt;code&gt;i &amp;lt; len&lt;/code&gt; ではなく、 &lt;code&gt;i&amp;lt;len&lt;/code&gt; です。コンパイラーは、意図したとおりであると確信できる場合に寛容にしようとしますが、常に「より小」および「より大」演算子の周りにスペースを置くと、あいまいさがなくなります。</target>
        </trans-unit>
        <trans-unit id="ee197e1e03ed057d123cd58113296e983974f7c3" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;const&lt;/code&gt; only protects you from &lt;em&gt;reassigning&lt;/em&gt; a variable; it doesn&amp;rsquo;t prevent the variable&amp;rsquo;s value from changing, the way constants usually do in other languages:</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; は変数の&lt;em&gt;再割り当てを&lt;/em&gt;防ぐだけであることに注意してください。変数の値の変更を妨げるものではありません。他の言語での定数の通常の方法と同じです。</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="b52e6ec9fa3d5c13a402c0dc8beb63c9192cad04" translate="yes" xml:space="preserve">
          <source>Language Reference</source>
          <target state="translated">言語リファレンス</target>
        </trans-unit>
        <trans-unit id="b49dc37eaf51e72990aba7aaaf76623a346cbd37" translate="yes" xml:space="preserve">
          <source>Launch an interactive CoffeeScript session to try short snippets. Identical to calling &lt;code&gt;coffee&lt;/code&gt; with no arguments.</source>
          <target state="translated">インタラクティブなCoffeeScriptセッションを起動して、短いスニペットを試してください。引数なしで &lt;code&gt;coffee&lt;/code&gt; を呼ぶのと同じです。</target>
        </trans-unit>
        <trans-unit id="a3e90043205a881c2853c2eca6f3e45fcbc541f7" translate="yes" xml:space="preserve">
          <source>Leading &lt;code&gt;.&lt;/code&gt; closes all open calls, allowing for simpler chaining syntax.</source>
          <target state="translated">リーディング &lt;code&gt;.&lt;/code&gt; すべての開いている呼び出しを閉じ、より単純な連鎖構文を可能にします。</target>
        </trans-unit>
        <trans-unit id="9f985d44bdfbd0484f99e8d147e15d78e5abb70b" translate="yes" xml:space="preserve">
          <source>Lexical Scoping and Variable Safety</source>
          <target state="translated">語彙的なスコープと可変安全性</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MITライセンスに基づいてライセンスされています。</target>
        </trans-unit>
        <trans-unit id="807e50c12f9e6b05f56a04dd9b9ff076073a65d0" translate="yes" xml:space="preserve">
          <source>Like JavaScript and many other languages, CoffeeScript supports strings as delimited by the &lt;code&gt;&quot;&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt; characters. CoffeeScript also supports string interpolation within &lt;code&gt;&quot;&lt;/code&gt;-quoted strings, using &lt;code&gt;#{ &amp;hellip; }&lt;/code&gt;. Single-quoted strings are literal. You may even use interpolation in object keys.</source>
          <target state="translated">JavaScriptや他の多くの言語と同様に、CoffeeScriptは &lt;code&gt;&quot;&lt;/code&gt; または &lt;code&gt;'&lt;/code&gt; 文字で区切られた文字列をサポートします。CoffeeScriptは、 &lt;code&gt;#{ &amp;hellip; }&lt;/code&gt; を使用して、 &lt;code&gt;&quot;&lt;/code&gt; -quoted文字列内の文字列補間もサポートします。一重引用符で囲まれた文字列はリテラルです。オブジェクトキーで補間を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="4f3952077d0c37b4982e8e71fecd691cae455a81" translate="yes" xml:space="preserve">
          <source>List items can be at most only one paragraph long. The second paragraph of a list item would be indented after a blank line, and therefore indistinguishable from a code block.</source>
          <target state="translated">リスト項目の長さは最大でも 1 段落だけです。リスト項目の2段落目は空行の後にインデントされるので、コードブロックと区別がつきません。</target>
        </trans-unit>
        <trans-unit id="f9958a2677c3ef0351f8de1b9c79ba7331f155a4" translate="yes" xml:space="preserve">
          <source>Literate CoffeeScript</source>
          <target state="translated">リテラルなCoffeeScript</target>
        </trans-unit>
        <trans-unit id="e0923ed716463b8c9d5b244e2f6ba2d222d500d9" translate="yes" xml:space="preserve">
          <source>Literate CoffeeScript parsing</source>
          <target state="translated">リテラルなCoffeeScriptのパース</target>
        </trans-unit>
        <trans-unit id="e83f1c0d81e570990421db9c6c5103dd52bab5e9" translate="yes" xml:space="preserve">
          <source>Loops and Comprehensions</source>
          <target state="translated">ループと理解度</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="d0b44f3bb54288ce6ecf8af194238e14f5bd47a8" translate="yes" xml:space="preserve">
          <source>Most modern JavaScript features that CoffeeScript supports can run natively in Node 7.6+, meaning that Node can run CoffeeScript&amp;rsquo;s output without any further processing required. Here are some notable exceptions:</source>
          <target state="translated">CoffeeScriptがサポートする最新のJavaScript機能のほとんどはノード7.6以降でネイティブに実行できます。つまり、ノードはそれ以上の処理を必要とせずにCoffeeScriptの出力を実行できます。ここにいくつかの注目すべき例外があります：</target>
        </trans-unit>
        <trans-unit id="5987894415f15faa1342fc04b8e4f45d10eb5711" translate="yes" xml:space="preserve">
          <source>Most of the loops you&amp;rsquo;ll write in CoffeeScript will be &lt;strong&gt;comprehensions&lt;/strong&gt; over arrays, objects, and ranges. Comprehensions replace (and compile into) &lt;code&gt;for&lt;/code&gt; loops, with optional guard clauses and the value of the current array index. Unlike for loops, array comprehensions are expressions, and can be returned and assigned.</source>
          <target state="translated">CoffeeScriptで作成するループのほとんどは、配列、オブジェクト、および範囲に対する&lt;strong&gt;理解&lt;/strong&gt;です。内包表記は、オプションのガード句と現在の配列インデックスの値を使用して &lt;code&gt;for&lt;/code&gt; ループを置換（およびコンパイル）します。 forループとは異なり、配列内包表記は式であり、返して代入することができます。</target>
        </trans-unit>
        <trans-unit id="e980a53fb5f690679ff0ebade16b508f890902d3" translate="yes" xml:space="preserve">
          <source>Multiline strings are allowed in CoffeeScript. Lines are joined by a single space unless they end with a backslash. Indentation is ignored.</source>
          <target state="translated">CoffeeScriptでは複数行の文字列を使用することができます。行の最後にバックスラッシュを付けない限り、行の間にはスペースが入ります。インデントは無視されます。</target>
        </trans-unit>
        <trans-unit id="9c21b9713784f3e4cfd595b3aa43dab514b15d2c" translate="yes" xml:space="preserve">
          <source>Named functions and function declarations</source>
          <target state="translated">名前付き関数と関数宣言</target>
        </trans-unit>
        <trans-unit id="685d8185cabac29e4bc33d85c18962f2c64b8915" translate="yes" xml:space="preserve">
          <source>Needs to be rewritten the old-fashioned way:</source>
          <target state="translated">昔ながらの書き換えが必要。</target>
        </trans-unit>
        <trans-unit id="9367a041098127356c25562e1a256085d58951ce" translate="yes" xml:space="preserve">
          <source>Newcomers to CoffeeScript often wonder how to generate the JavaScript &lt;code&gt;function foo() {}&lt;/code&gt;, as opposed to the &lt;code&gt;foo = function() {}&lt;/code&gt; that CoffeeScript produces. The first form is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function&quot;&gt;function declaration&lt;/a&gt;, and the second is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function&quot;&gt;function expression&lt;/a&gt;. As stated above, in CoffeeScript &lt;a href=&quot;#expressions&quot;&gt;everything is an expression&lt;/a&gt;, so naturally we favor the expression form. Supporting only one variant helps avoid confusing bugs that can arise from the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function#Function_declaration_hoisting&quot;&gt;subtle differences between the two forms&lt;/a&gt;.</source>
          <target state="translated">CoffeeScriptの初心者は、CoffeeScriptが生成する &lt;code&gt;foo = function() {}&lt;/code&gt; とは対照的に、JavaScript &lt;code&gt;function foo() {}&lt;/code&gt; を生成する方法をよく疑問に思います。最初の形式は&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function&quot;&gt;関数宣言&lt;/a&gt;で、2番目の形式は&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function&quot;&gt;関数式&lt;/a&gt;です。上記のように、CoffeeScriptでは&lt;a href=&quot;#expressions&quot;&gt;すべてが式です&lt;/a&gt;。そのため、当然のことながら式の形式が優先されます。 1つのバリアントのみをサポートすること&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function#Function_declaration_hoisting&quot;&gt;で、2つのフォーム間の微妙な違い&lt;/a&gt;から生じる可能性のあるバグの混乱を回避できます。</target>
        </trans-unit>
        <trans-unit id="10b3493287f831e81a438811a1ffba01f8cec4b7" translate="yes" xml:space="preserve">
          <source>Node.js</source>
          <target state="translated">Node.js</target>
        </trans-unit>
        <trans-unit id="a17d639e61da9d0653ca53ca643f92af7655ebe3" translate="yes" xml:space="preserve">
          <source>Note how because we are assigning the value of the comprehensions to a variable in the example above, CoffeeScript is collecting the result of each iteration into an array. Sometimes functions end with loops that are intended to run only for their side-effects. Be careful that you&amp;rsquo;re not accidentally returning the results of the comprehension in these cases, by adding a meaningful return value &amp;mdash; like &lt;code&gt;true&lt;/code&gt; &amp;mdash; or &lt;code&gt;null&lt;/code&gt;, to the bottom of your function.</source>
          <target state="translated">上記の例では内包の値を変数に割り当てているため、CoffeeScriptは各反復の結果を配列に収集しています。関数は、その副作用のためにのみ実行することを目的としたループで終了する場合があります。これらの場合、関数の最後に意味のある戻り値（ &lt;code&gt;true&lt;/code&gt; など）または &lt;code&gt;null&lt;/code&gt; を追加して、理解の結果を誤って返さないように注意してください。</target>
        </trans-unit>
        <trans-unit id="7878aae2bc5e1df5f94aa51acb2a5c0788234496" translate="yes" xml:space="preserve">
          <source>Note that JavaScript strings are immutable, and can&amp;rsquo;t be spliced.</source>
          <target state="translated">JavaScriptの文字列は不変であり、継ぎ合わせることができないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="d3179b6c8afd9cdc3bb1ec6e1c16cc445004943e" translate="yes" xml:space="preserve">
          <source>Note that if the compiler knows that &lt;code&gt;a&lt;/code&gt; is in scope and therefore declared, &lt;code&gt;a?&lt;/code&gt; compiles to &lt;code&gt;a != null&lt;/code&gt;, &lt;em&gt;not&lt;/em&gt;&lt;code&gt;a !== null&lt;/code&gt;. The &lt;code&gt;!=&lt;/code&gt; makes a loose comparison to &lt;code&gt;null&lt;/code&gt;, which does double duty also comparing against &lt;code&gt;undefined&lt;/code&gt;. The reverse also holds for &lt;code&gt;not a?&lt;/code&gt; or &lt;code&gt;unless a?&lt;/code&gt;.</source>
          <target state="translated">コンパイラが &lt;code&gt;a&lt;/code&gt; がスコープ内にあり、したがって宣言されていることを知っている場合、 &lt;code&gt;a?&lt;/code&gt; &lt;code&gt;a !== null&lt;/code&gt; では&lt;em&gt;なく&lt;/em&gt; &lt;code&gt;a != null&lt;/code&gt; コンパイルされます。 &lt;code&gt;!=&lt;/code&gt; に緩い比較になり &lt;code&gt;null&lt;/code&gt; もと比較する二重の義務行い、 &lt;code&gt;undefined&lt;/code&gt; 。その逆も &lt;code&gt;not a?&lt;/code&gt; または &lt;code&gt;unless a?&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c346bd383bcb5c9fab50c836103159e19fa051e2" translate="yes" xml:space="preserve">
          <source>Note that the CoffeeScript compiler &lt;strong&gt;does not resolve modules&lt;/strong&gt;; writing an &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; statement in CoffeeScript will produce an &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; statement in the resulting output. It is your responsibility to &lt;a href=&quot;#transpilation&quot;&gt;transpile&lt;/a&gt; this ES2015 syntax into code that will work in your target runtimes.</source>
          <target state="translated">CoffeeScriptコンパイラー&lt;strong&gt;はモジュールを解決しない&lt;/strong&gt;ことに注意してください。書き込みを &lt;code&gt;import&lt;/code&gt; または &lt;code&gt;export&lt;/code&gt; のCoffeeScriptでのステートメントは、生成されます &lt;code&gt;import&lt;/code&gt; または &lt;code&gt;export&lt;/code&gt; 結果の出力に声明を。するあなたの責任です&lt;a href=&quot;#transpilation&quot;&gt;transpile&lt;/a&gt;ターゲットランタイムで動作するコードにこのES2015構文を。</target>
        </trans-unit>
        <trans-unit id="3da55fdb5cea2e3963662a9bb50c1c4e14f19b69" translate="yes" xml:space="preserve">
          <source>Note that transpiling doesn&amp;rsquo;t automatically supply &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Polyfill&quot;&gt;polyfills&lt;/a&gt; for your code. CoffeeScript itself will output &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf&quot;&gt;&lt;code&gt;Array.indexOf&lt;/code&gt;&lt;/a&gt; if you use the &lt;code&gt;in&lt;/code&gt; operator, or destructuring or spread/rest syntax; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt;&lt;code&gt;Function.bind&lt;/code&gt;&lt;/a&gt; if you use a bound (&lt;code&gt;=&amp;gt;&lt;/code&gt;) method in a class. Both are supported in Internet Explorer 9+ and all more recent browsers, but you will need to supply polyfills if you need to support Internet Explorer 8 or below and are using features that would cause these methods to be output. You&amp;rsquo;ll also need to supply polyfills if your own code uses these methods or another method added in recent versions of JavaScript. One polyfill option is &lt;a href=&quot;https://babeljs.io/docs/en/babel-polyfill/&quot;&gt;&lt;code&gt;@babel/polyfill&lt;/code&gt;&lt;/a&gt;, though there are many &lt;a href=&quot;https://hackernoon.com/polyfills-everything-you-ever-wanted-to-know-or-maybe-a-bit-less-7c8de164e423&quot;&gt;other&lt;/a&gt;&lt;a href=&quot;https://philipwalton.com/articles/loading-polyfills-only-when-needed/&quot;&gt;strategies&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Polyfill&quot;&gt;トランスパイル&lt;/a&gt;は、コードにポリフィルを自動的に提供しないことに注意してください。 CoffeeScript自体は、 &lt;code&gt;in&lt;/code&gt; 演算子を使用したり、構文を&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf&quot;&gt; &lt;code&gt;Array.indexOf&lt;/code&gt; &lt;/a&gt;たり、スプレッド/レスト構文を使用したりすると、Array.indexOfを出力します。クラスでバウンド（ &lt;code&gt;=&amp;gt;&lt;/code&gt; ）メソッドを使用する場合は、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt; &lt;code&gt;Function.bind&lt;/code&gt; &lt;/a&gt;。どちらもInternet Explorer 9以降およびそれ以降のすべてのブラウザーでサポートされていますが、Internet Explorer 8以下をサポートする必要があり、これらのメソッドを出力させる機能を使用している場合は、ポリフィルを提供する必要があります。独自のコードでこれらのメソッドまたはJavaScriptの最近のバージョンで追加された別のメソッドを使用する場合は、ポリフィルを提供する必要もあります。ポリフィルのオプションの1つは&lt;a href=&quot;https://babeljs.io/docs/en/babel-polyfill/&quot;&gt; &lt;code&gt;@babel/polyfill&lt;/code&gt; &lt;/a&gt;ですが、&lt;a href=&quot;https://hackernoon.com/polyfills-everything-you-ever-wanted-to-know-or-maybe-a-bit-less-7c8de164e423&quot;&gt;他の&lt;/a&gt;&lt;a href=&quot;https://philipwalton.com/articles/loading-polyfills-only-when-needed/&quot;&gt;戦略&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b0e75b1cc5940f3dfdf0f98f2537757533933df2" translate="yes" xml:space="preserve">
          <source>Notice how all of the variable declarations have been pushed up to the top of the closest scope, the first time they appear. &lt;code&gt;outer&lt;/code&gt; is not redeclared within the inner function, because it&amp;rsquo;s already in scope; &lt;code&gt;inner&lt;/code&gt; within the function, on the other hand, should not be able to change the value of the external variable of the same name, and therefore has a declaration of its own.</source>
          <target state="translated">すべての変数宣言が最初に表示されたときに、最も近いスコープの一番上にプッシュされていることに注意してください。 &lt;code&gt;outer&lt;/code&gt; は既にスコープ内にあるため、inner関数内で再宣言されていません。一方、関数 &lt;code&gt;inner&lt;/code&gt; は、同じ名前の外部変数の値を変更できないようにする必要があるため、独自の宣言を持っています。</target>
        </trans-unit>
        <trans-unit id="ca1abda92d5b54711ee766219d8e2c4693c6ca7a" translate="yes" xml:space="preserve">
          <source>Now you would just type:</source>
          <target state="translated">今は入力するだけです。</target>
        </trans-unit>
        <trans-unit id="566c9ccf76b4698b00a6f761b3c71b9f0e05eb29" translate="yes" xml:space="preserve">
          <source>Objects and Arrays</source>
          <target state="translated">オブジェクトと配列</target>
        </trans-unit>
        <trans-unit id="5fc811955d55e0ff5b82d1a49c11e277df049033" translate="yes" xml:space="preserve">
          <source>Older plugins or forks of CoffeeScript supported JSX syntax and referred to it as CSX or CJSX. They also often used a &lt;code&gt;.cjsx&lt;/code&gt; file extension, but this is no longer necessary; regular &lt;code&gt;.coffee&lt;/code&gt; will do.</source>
          <target state="translated">CoffeeScriptの古いプラグインまたはフォークはJSX構文をサポートし、CSXまたはCJSXと呼ばれていました。彼らはしばしば &lt;code&gt;.cjsx&lt;/code&gt; ファイル拡張子を使用しましたが、これはもはや必要ではありません。通常の &lt;code&gt;.coffee&lt;/code&gt; いいです。</target>
        </trans-unit>
        <trans-unit id="47445da7574ef1c2b9f9dbbf29f9a3e160cc9748" translate="yes" xml:space="preserve">
          <source>On non-Windows platforms, a &lt;code&gt;.coffee&lt;/code&gt; file can be made executable by adding a shebang (&lt;code&gt;#!&lt;/code&gt;) line at the top of the file and marking the file as executable. For example:</source>
          <target state="translated">Windows以外のプラットフォームでは、 &lt;code&gt;.coffee&lt;/code&gt; ファイルを実行可能にするには、ファイルの先頭にシバン（ &lt;code&gt;#!&lt;/code&gt; ）行を追加し、ファイルを実行可能としてマークします。例えば：</target>
        </trans-unit>
        <trans-unit id="88e58b2db811a67c2866ad03f41850be69476b09" translate="yes" xml:space="preserve">
          <source>Once installed, you should have access to the &lt;code&gt;coffee&lt;/code&gt; command, which can execute scripts, compile &lt;code&gt;.coffee&lt;/code&gt; files into &lt;code&gt;.js&lt;/code&gt;, and provide an interactive REPL. The &lt;code&gt;coffee&lt;/code&gt; command takes the following options:</source>
          <target state="translated">インストールが完了すると、スクリプトを実行したり、 &lt;code&gt;.coffee&lt;/code&gt; ファイルを &lt;code&gt;.js&lt;/code&gt; にコンパイルしたり、インタラクティブREPLを提供したりできる &lt;code&gt;coffee&lt;/code&gt; コマンドにアクセスできるようになります。 &lt;code&gt;coffee&lt;/code&gt; コマンドは次のオプションがあります。</target>
        </trans-unit>
        <trans-unit id="968e4a68ad115837ed26068f6b0ed2cb269d66ce" translate="yes" xml:space="preserve">
          <source>Once you have &lt;code&gt;@babel/core&lt;/code&gt; and &lt;code&gt;@babel/preset-env&lt;/code&gt; (or other presets or plugins) installed, and a &lt;code&gt;.babelrc&lt;/code&gt; file (or other equivalent) in place, you can use &lt;code&gt;coffee --transpile&lt;/code&gt; to pipe CoffeeScript&amp;rsquo;s output through Babel using the options you&amp;rsquo;ve saved.</source>
          <target state="translated">あなたが持っている一度 &lt;code&gt;@babel/core&lt;/code&gt; および &lt;code&gt;@babel/preset-env&lt;/code&gt; （または他のプリセットやプラグイン）がインストールされ、 &lt;code&gt;.babelrc&lt;/code&gt; ファイル（または他の同等の）代わりに、あなたが使用することができます &lt;code&gt;coffee --transpile&lt;/code&gt; 使用してバベルを通じて、パイプのCoffeeScriptの出力に保存したオプション</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="1863519535480ab59ac39566f63c3643c8a7c46d" translate="yes" xml:space="preserve">
          <source>Operators and Aliases</source>
          <target state="translated">オペレータとエイリアス</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="70d58de47bef0c1dc805b8a5582bf3bb4065cd12" translate="yes" xml:space="preserve">
          <source>Or if you know that the parent function doesn&amp;rsquo;t require arguments, just call &lt;code&gt;super()&lt;/code&gt;:</source>
          <target state="translated">または、親関数が引数を必要としないことがわかっている場合は、単に &lt;code&gt;super()&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="4abfdc58ca2958fb7f19e78ea1f0eafecc095c1b" translate="yes" xml:space="preserve">
          <source>Or if you&amp;rsquo;re running the &lt;code&gt;coffee&lt;/code&gt; command outside of a project folder, using a globally-installed &lt;code&gt;coffeescript&lt;/code&gt; module, &lt;code&gt;@babel/core&lt;/code&gt; needs to be installed globally:</source>
          <target state="translated">または、グローバルにインストールされた &lt;code&gt;coffeescript&lt;/code&gt; モジュールを使用して、プロジェクトフォルダーの外で &lt;code&gt;coffee&lt;/code&gt; コマンドを実行している場合は、 &lt;code&gt;@babel/core&lt;/code&gt; グローバルにインストールする必要があります。</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="3582229790b1aa109582562e652fba246dfb989e" translate="yes" xml:space="preserve">
          <source>Parses the code as Literate CoffeeScript. You only need to specify this when passing in code directly over &lt;strong&gt;stdio&lt;/strong&gt;, or using some sort of extension-less file name.</source>
          <target state="translated">コードをLiterate CoffeeScriptとして解析します。これを指定する必要があるのは、&lt;strong&gt;stdio&lt;/strong&gt;を介してコードを直接渡す場合、またはある種の拡張子のないファイル名を使用する場合のみです。</target>
        </trans-unit>
        <trans-unit id="4f1dcee64c9b040dea753f1d5184978e4fd28e2b" translate="yes" xml:space="preserve">
          <source>Per the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters&quot;&gt;ES2015 spec regarding function default parameters&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values&quot;&gt;destructuring default values&lt;/a&gt;, default values are only applied when a value is missing or &lt;code&gt;undefined&lt;/code&gt;. In CoffeeScript 1.x, the default value would be applied in those cases but also if the value was &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">パー&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters&quot;&gt;ES2015スペック機能のデフォルトのパラメータに関する&lt;/a&gt;と&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values&quot;&gt;デフォルト値を構造化代入&lt;/a&gt;値が欠落しているかされている場合、デフォルト値のみが適用されている &lt;code&gt;undefined&lt;/code&gt; 。CoffeeScript 1.xでは、これらの場合だけでなく、値が &lt;code&gt;null&lt;/code&gt; の場合にもデフォルト値が適用されます。</target>
        </trans-unit>
        <trans-unit id="dd72d92f93bcbc4707fdbf29cee5a48b123c133c" translate="yes" xml:space="preserve">
          <source>Pipe in CoffeeScript to STDIN and get back JavaScript over STDOUT. Good for use with processes written in other languages. An example:</source>
          <target state="translated">CoffeeScriptをSTDINにパイプして、STDOUTを介してJavaScriptを取得します。他の言語で書かれたプロセスでの使用に適しています。例。</target>
        </trans-unit>
        <trans-unit id="bb867dd7a9b38a2aedeac5fcb2379aed6eed2d63" translate="yes" xml:space="preserve">
          <source>Pipe the CoffeeScript compiler&amp;rsquo;s output through Babel before saving or running the generated JavaScript. Requires &lt;code&gt;@babel/core&lt;/code&gt; to be installed, and options to pass to Babel in a &lt;code&gt;.babelrc&lt;/code&gt; file or a &lt;code&gt;package.json&lt;/code&gt; with a &lt;code&gt;babel&lt;/code&gt; key in the path of the file or folder to be compiled. See &lt;a href=&quot;#transpilation&quot;&gt;Transpilation&lt;/a&gt;.</source>
          <target state="translated">生成されたJavaScriptを保存または実行する前に、CoffeeScriptコンパイラの出力をBabelにパイプします。 &lt;code&gt;@babel/core&lt;/code&gt; をインストールし、コンパイルするファイルまたはフォルダーのパスに &lt;code&gt;babel&lt;/code&gt; キーを指定して、 &lt;code&gt;.babelrc&lt;/code&gt; ファイルまたは &lt;code&gt;package.json&lt;/code&gt; でBabelに渡すオプションが必要です。&lt;a href=&quot;#transpilation&quot;&gt;Transpilationを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c65de7239130b2221dc156af1c9b5fa8125b9bf3" translate="yes" xml:space="preserve">
          <source>Polyfills</source>
          <target state="translated">Polyfills</target>
        </trans-unit>
        <trans-unit id="32f6d152131c542beafde761060b9c5187fa0fd9" translate="yes" xml:space="preserve">
          <source>Print out the compiled JS from a one-liner:</source>
          <target state="translated">ワンライナーからコンパイルしたJSをプリントアウトします。</target>
        </trans-unit>
        <trans-unit id="a4e2d5650ff557033b751f41cc52650a02e0ddc8" translate="yes" xml:space="preserve">
          <source>Prototypal Inheritance</source>
          <target state="translated">プロトタイプ継承</target>
        </trans-unit>
        <trans-unit id="d07133c8504b6a0e98371a1b9afe2ca2855a7270" translate="yes" xml:space="preserve">
          <source>Quickstart</source>
          <target state="translated">Quickstart</target>
        </trans-unit>
        <trans-unit id="0d5fda95e3940bc09dc1ccc22666813c0b54f73d" translate="yes" xml:space="preserve">
          <source>Ranges</source>
          <target state="translated">Ranges</target>
        </trans-unit>
        <trans-unit id="24aaf8084dd55feaa39e1aafbe6c650fc362ceae" translate="yes" xml:space="preserve">
          <source>Ranges can also be used to extract slices of arrays. With two dots (&lt;code&gt;3..6&lt;/code&gt;), the range is inclusive (&lt;code&gt;3, 4, 5, 6&lt;/code&gt;); with three dots (&lt;code&gt;3...6&lt;/code&gt;), the range excludes the end (&lt;code&gt;3, 4, 5&lt;/code&gt;). Slices indices have useful defaults. An omitted first index defaults to zero and an omitted second index defaults to the size of the array.</source>
          <target state="translated">範囲は、配列のスライスを抽出するためにも使用できます。2つのドット（と &lt;code&gt;3..6&lt;/code&gt; ）、範囲は包括的である（ &lt;code&gt;3, 4, 5, 6&lt;/code&gt; ）。3つのドット（ &lt;code&gt;3...6&lt;/code&gt; ）を使用すると、範囲は末尾（ &lt;code&gt;3, 4, 5&lt;/code&gt; 除外します。スライスのインデックスには、便利なデフォルトがあります。省略された最初のインデックスはデフォルトでゼロになり、省略された第2インデックスはデフォルトで配列のサイズになります。</target>
        </trans-unit>
        <trans-unit id="87df60de337fb58864343e396696d74611e0d403" translate="yes" xml:space="preserve">
          <source>Resources</source>
          <target state="translated">Resources</target>
        </trans-unit>
        <trans-unit id="28bada3d37bb0a3a9f2a34311d7e6164ba0dc426" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://babeljs.io/docs/plugins/&quot;&gt;Babel&amp;rsquo;s website to learn about presets and plugins&lt;/a&gt; and the multitude of options you have. Another preset you might need is &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-react-jsx/&quot;&gt;&lt;code&gt;@babel/plugin-transform-react-jsx&lt;/code&gt;&lt;/a&gt; if you&amp;rsquo;re using JSX with React (JSX can also be used with other frameworks).</source>
          <target state="translated">&lt;a href=&quot;https://babeljs.io/docs/plugins/&quot;&gt;プリセットとプラグイン&lt;/a&gt;、および多数のオプションについては、BabelのWebサイトを参照してください。ReactでJSXを使用している場合、必要になる可能性があるもう1つのプリセットは&lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-react-jsx/&quot;&gt; &lt;code&gt;@babel/plugin-transform-react-jsx&lt;/code&gt; &lt;/a&gt;です（JSXは他のフレームワークでも使用できます）。</target>
        </trans-unit>
        <trans-unit id="74aa7d3d7d4395b004fa0da48ff50e997cf268b3" translate="yes" xml:space="preserve">
          <source>Similar to block strings and comments, CoffeeScript supports block regexes &amp;mdash; extended regular expressions that ignore internal whitespace and can contain comments and interpolation. Modeled after Perl&amp;rsquo;s &lt;code&gt;/x&lt;/code&gt; modifier, CoffeeScript&amp;rsquo;s block regexes are delimited by &lt;code&gt;///&lt;/code&gt; and go a long way towards making complex regular expressions readable. To quote from the CoffeeScript source:</source>
          <target state="translated">ブロック文字列やコメントと同様に、CoffeeScriptはブロック正規表現（内部の空白を無視し、コメントや補間を含めることができる拡張正規表現）をサポートしています。Perlの &lt;code&gt;/x&lt;/code&gt; 修飾子をモデルにして作成されたCoffeeScriptのブロック正規表現は、 &lt;code&gt;///&lt;/code&gt; で区切られ、複雑な正規表現を読みやすくするために大いに役立ちます。CoffeeScriptソースから引用するには：</target>
        </trans-unit>
        <trans-unit id="8159f92ff6c06035d06cbb7eb3033fede5940b02" translate="yes" xml:space="preserve">
          <source>Similar to how &lt;code&gt;yield return&lt;/code&gt; forces a generator, &lt;code&gt;await return&lt;/code&gt; may be used to force a function to be async.</source>
          <target state="translated">&lt;code&gt;yield return&lt;/code&gt; がジェネレーターを強制する方法と同様に、 &lt;code&gt;await return&lt;/code&gt; を使用して、関数を強制的に非同期にできます。</target>
        </trans-unit>
        <trans-unit id="d4a58561dd9ce9ebf0ef891fdc51fcf365c7dc7e" translate="yes" xml:space="preserve">
          <source>Since CoffeeScript takes care of all variable declaration, it is not possible to declare variables with ES2015&amp;rsquo;s &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt;. &lt;a href=&quot;#unsupported-let-const&quot;&gt;This is intentional&lt;/a&gt;; we feel that the simplicity gained by not having to think about variable declaration outweighs the benefit of having three separate ways to declare variables.</source>
          <target state="translated">CoffeeScriptはすべての変数宣言を処理するため、ES2015の &lt;code&gt;let&lt;/code&gt; または &lt;code&gt;const&lt;/code&gt; を使用して変数を宣言することはできません。&lt;a href=&quot;#unsupported-let-const&quot;&gt;これは意図的なもの&lt;/a&gt;です。変数宣言について考える必要がないことによって得られる単純さは、変数を宣言する3つの別々の方法を持つことの利点よりも重要だと感じています。</target>
        </trans-unit>
        <trans-unit id="5774da7b802f7af9150c4273aaf57f7387c8eb1d" translate="yes" xml:space="preserve">
          <source>Source Maps</source>
          <target state="translated">ソースマップ</target>
        </trans-unit>
        <trans-unit id="da68b1026804cc80434fc637d86d0eb96635cb24" translate="yes" xml:space="preserve">
          <source>Splats also let us elide array elements&amp;hellip;</source>
          <target state="translated">スプラットにより、配列要素を排除することもできます&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="424dbd400ae6e38a2f49aadeb924ee108357cfdb" translate="yes" xml:space="preserve">
          <source>Splats, or Rest Parameters/Spread Syntax</source>
          <target state="translated">スプラット、または休息パラメータ/スプレッド構文</target>
        </trans-unit>
        <trans-unit id="326a96ab3ee59b29761fe875d4032ef3fd1dcd75" translate="yes" xml:space="preserve">
          <source>Start the CoffeeScript REPL (&lt;code&gt;Ctrl-D&lt;/code&gt; to exit, &lt;code&gt;Ctrl-V&lt;/code&gt;for multi-line):</source>
          <target state="translated">CoffeeScript REPLを開始します（終了するには &lt;code&gt;Ctrl-V&lt;/code&gt; &lt;code&gt;Ctrl-D&lt;/code&gt; 、複数行の場合はCtrl-V）：</target>
        </trans-unit>
        <trans-unit id="5653cebc057d4791ce07031ad9286e729de6d691" translate="yes" xml:space="preserve">
          <source>Statements</source>
          <target state="translated">Statements</target>
        </trans-unit>
        <trans-unit id="fd9b9a809e9699ee433dd5e37059d01714f797c7" translate="yes" xml:space="preserve">
          <source>Static methods can be defined using &lt;code&gt;@&lt;/code&gt; before the method name:</source>
          <target state="translated">静的メソッドは、メソッド名の前に &lt;code&gt;@&lt;/code&gt; を使用して定義できます。</target>
        </trans-unit>
        <trans-unit id="bb5eff5196ac991028b63b54dacf4e8686fd3692" translate="yes" xml:space="preserve">
          <source>Static type checking can be achieved in CoffeeScript by using &lt;a href=&quot;https://flow.org/&quot;&gt;Flow&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;https://flow.org/en/docs/types/comments/&quot;&gt;Comment Types syntax&lt;/a&gt;:</source>
          <target state="translated">静的型チェックは、&lt;a href=&quot;https://flow.org/&quot;&gt;Flow&lt;/a&gt;の&lt;a href=&quot;https://flow.org/en/docs/types/comments/&quot;&gt;コメント型構文&lt;/a&gt;を使用してCoffeeScriptで実現できます。</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="84130039777ac54831b333570728881088c16ed5" translate="yes" xml:space="preserve">
          <source>Suppress the &amp;ldquo;Generated by CoffeeScript&amp;rdquo; header.</source>
          <target state="translated">「Generated by CoffeeScript」ヘッダーを抑制します。</target>
        </trans-unit>
        <trans-unit id="292abefb8a7c036089ac917fd0757a7bb6e3111c" translate="yes" xml:space="preserve">
          <source>Switch/When/Else</source>
          <target state="translated">Switch/When/Else</target>
        </trans-unit>
        <trans-unit id="5fd53f2212dd11ad266f50696cd5a9ca1ea708d6" translate="yes" xml:space="preserve">
          <source>Tagged Template Literals</source>
          <target state="translated">タグ付きテンプレートリテラル</target>
        </trans-unit>
        <trans-unit id="468657e1c13e92e3564728da3cdadc47c49817c6" translate="yes" xml:space="preserve">
          <source>Task definitions are written in CoffeeScript, so you can put arbitrary code in your Cakefile. Define a task with a name, a long description, and the function to invoke when the task is run. If your task takes a command-line option, you can define the option with short and long flags, and it will be made available in the &lt;code&gt;options&lt;/code&gt; object. Here&amp;rsquo;s a task that uses the Node.js API to rebuild CoffeeScript&amp;rsquo;s parser:</source>
          <target state="translated">タスク定義はCoffeeScriptで書かれているので、Cakefileに任意のコードを入れることができます。名前、長い説明、タスクの実行時に呼び出す関数を使用してタスクを定義します。タスクがコマンドラインオプションを取る場合、オプションを短いフラグと長いフラグで定義でき、 &lt;code&gt;options&lt;/code&gt; オブジェクトで使用できるようになります。 Node.js APIを使用してCoffeeScriptのパーサーを再構築するタスクを次に示します。</target>
        </trans-unit>
        <trans-unit id="1bc65a5d778ee3969a41b1e46397162f821ca5f0" translate="yes" xml:space="preserve">
          <source>Technically, &lt;code&gt;foo = function() {}&lt;/code&gt; is creating an anonymous function that gets assigned to a variable named &lt;code&gt;foo&lt;/code&gt;. Some very early versions of CoffeeScript named this function, e.g. &lt;code&gt;foo = function foo() {}&lt;/code&gt;, but this was dropped because of compatibility issues with Internet Explorer. For a while this annoyed people, as these functions would be unnamed in stack traces; but modern JavaScript runtimes &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name&quot;&gt;infer the names of such anonymous functions&lt;/a&gt; from the names of the variables to which they&amp;rsquo;re assigned. Given that this is the case, it&amp;rsquo;s simplest to just preserve the current behavior.</source>
          <target state="translated">技術的には、 &lt;code&gt;foo = function() {}&lt;/code&gt; は、 &lt;code&gt;foo&lt;/code&gt; という名前の変数に割り当てられる無名関数を作成しています。CoffeeScriptのごく初期の一部のバージョンでは、この関数に名前を付けていました（例： &lt;code&gt;foo = function foo() {}&lt;/code&gt; ）。ただし、Internet Explorerとの互換性の問題のため、この関数は削除されました。しばらくの間、これらの関数はスタックトレースで名前が付けられていなかったため、このイライラする人たち。しかし、最近のJavaScriptランタイム&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name&quot;&gt;は、そのような匿名関数&lt;/a&gt;の名前を、それらが割り当てられている変数の名前から推測します。これが事実であることを考えると、現在の動作を保持することが最も簡単です。</target>
        </trans-unit>
        <trans-unit id="7572c0330f0713d1c5e756a7afc16d79cdfd440e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/tc39/proposal-regexp-dotall-flag&quot;&gt;regular expression &lt;code&gt;s&lt;/code&gt; (dotall) flag&lt;/a&gt; is supported by Node 9+.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tc39/proposal-regexp-dotall-flag&quot;&gt;正規表現 &lt;code&gt;s&lt;/code&gt; （DOTALL）フラグは&lt;/a&gt;、ノード9+に支持されています。</target>
        </trans-unit>
        <trans-unit id="c056ef78212ae02220f393b10157bf5612f52880" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;coffee&lt;/code&gt; and &lt;code&gt;cake&lt;/code&gt; commands will first look in the current folder to see if CoffeeScript is installed locally, and use that version if so. This allows different versions of CoffeeScript to be installed globally and locally.</source>
          <target state="translated">&lt;code&gt;coffee&lt;/code&gt; と &lt;code&gt;cake&lt;/code&gt; のコマンドは、最初のCoffeeScriptがローカルにインストールされているかどうか、もしそうであれば、そのバージョンを使用するために、現在のフォルダになります。これにより、異なるバージョンのCoffeeScriptをグローバルおよびローカルにインストールできます。</target>
        </trans-unit>
        <trans-unit id="ba748e704aff73a187b5b4d11e627d8c846dc17c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compile&lt;/code&gt; method has the signature &lt;code&gt;compile(code, options)&lt;/code&gt; where &lt;code&gt;code&lt;/code&gt; is a string of CoffeeScript code, and the optional &lt;code&gt;options&lt;/code&gt; is an object with some or all of the following properties:</source>
          <target state="translated">&lt;code&gt;compile&lt;/code&gt; 方法は、署名している &lt;code&gt;compile(code, options)&lt;/code&gt; &lt;code&gt;code&lt;/code&gt; CoffeeScriptのコードの文字列であり、任意 &lt;code&gt;options&lt;/code&gt; 、以下の特性の一部または全てを持つオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="655422e26379c46e7d5bcfbd8d6d8f7315e989f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;node&lt;/code&gt; executable has some useful options you can set, such as &lt;code&gt;--debug&lt;/code&gt;, &lt;code&gt;--debug-brk&lt;/code&gt;, &lt;code&gt;--max-stack-size&lt;/code&gt;, and &lt;code&gt;--expose-gc&lt;/code&gt;. Use this flag to forward options directly to Node.js. To pass multiple flags, use &lt;code&gt;--nodejs&lt;/code&gt; multiple times.</source>
          <target state="translated">&lt;code&gt;node&lt;/code&gt; 実行ファイルは、以下のような設定できるいくつかの有用なオプションが、持っている &lt;code&gt;--debug&lt;/code&gt; 、 &lt;code&gt;--debug-brk&lt;/code&gt; 、 &lt;code&gt;--max-stack-size&lt;/code&gt; 、および &lt;code&gt;--expose-gc&lt;/code&gt; 。このフラグを使用して、オプションを直接Node.jsに転送します。複数のフラグを渡すには、 &lt;code&gt;--nodejs&lt;/code&gt; 複数回使用します。</target>
        </trans-unit>
        <trans-unit id="4d06fa582277c824a5eedd0cdf8c8c43e8fd4e37" translate="yes" xml:space="preserve">
          <source>The CoffeeScript compiler takes care to make sure that all of your variables are properly declared within lexical scope &amp;mdash; you never need to write &lt;code&gt;var&lt;/code&gt; yourself.</source>
          <target state="translated">CoffeeScriptコンパイラーは、すべての変数が字句スコープ内で適切に宣言されていることを確認します &lt;code&gt;var&lt;/code&gt; 自分で作成する必要はありません。</target>
        </trans-unit>
        <trans-unit id="c6f6a454b2aadf8379fc2d7a711646b0c0889b8e" translate="yes" xml:space="preserve">
          <source>The CoffeeScript literals for objects and arrays look very similar to their JavaScript cousins. When each property is listed on its own line, the commas are optional. Objects may be created using indentation instead of explicit braces, similar to &lt;a href=&quot;http://yaml.org&quot;&gt;YAML&lt;/a&gt;.</source>
          <target state="translated">オブジェクトと配列のCoffeeScriptリテラルは、JavaScriptのいとこに非常によく似ています。各プロパティが個別の行にリストされている場合、コンマはオプションです。&lt;a href=&quot;http://yaml.org&quot;&gt;YAMLの&lt;/a&gt;ように、明示的な中括弧の代わりにインデントを使用してオブジェクトを作成できます。</target>
        </trans-unit>
        <trans-unit id="632671d8e925198953b170ddd065e3816277d5e2" translate="yes" xml:space="preserve">
          <source>The Existential Operator</source>
          <target state="translated">実存演算子</target>
        </trans-unit>
        <trans-unit id="c299679511c002544394508b8a38855769b0948a" translate="yes" xml:space="preserve">
          <source>The JavaScript &lt;code&gt;arguments&lt;/code&gt; object is a useful way to work with functions that accept variable numbers of arguments. CoffeeScript provides splats &lt;code&gt;...&lt;/code&gt;, both for function definition as well as invocation, making variable numbers of arguments a little bit more palatable. ES2015 adopted this feature as their &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters&quot;&gt;rest parameters&lt;/a&gt;.</source>
          <target state="translated">JavaScript &lt;code&gt;arguments&lt;/code&gt; オブジェクトは、可変数の引数を受け入れる関数を操作するための便利な方法です。CoffeeScriptは、関数の定義と呼び出しの両方にスプラット &lt;code&gt;...&lt;/code&gt; を提供し、可変数の引数を少し口当たりよくします。ES2015は、&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters&quot;&gt;残りのパラメータ&lt;/a&gt;としてこの機能を採用しました。</target>
        </trans-unit>
        <trans-unit id="cde9be47142db0d427c3f2b4c90516cab84ab990" translate="yes" xml:space="preserve">
          <source>The above example also demonstrates that if properties are missing in the destructured object or array, you can, just like in JavaScript, provide defaults. Note though that unlike with the existential operator, the default is only applied with the value is missing or &lt;code&gt;undefined&lt;/code&gt;&amp;mdash;&lt;a href=&quot;#breaking-changes-default-values&quot;&gt;passing &lt;code&gt;null&lt;/code&gt; will set a value of &lt;code&gt;null&lt;/code&gt;&lt;/a&gt;, not the default.</source>
          <target state="translated">上記の例は、非構造化オブジェクトまたは配列でプロパティが欠落している場合に、JavaScriptと同様にデフォルトを提供できることも示しています。実存オペレータとは異なり、デフォルトは値のみが欠落しているかされて適用されているものの注 &lt;code&gt;undefined&lt;/code&gt; - &lt;a href=&quot;#breaking-changes-default-values&quot;&gt;渡す &lt;code&gt;null&lt;/code&gt; が値を設定します &lt;code&gt;null&lt;/code&gt; で&lt;/a&gt;、デフォルトではないが。</target>
        </trans-unit>
        <trans-unit id="e95f0f8970d570907faaeca191b0a67113a7c21d" translate="yes" xml:space="preserve">
          <source>The accessor variant of the existential operator &lt;code&gt;?.&lt;/code&gt; can be used to soak up null references in a chain of properties. Use it instead of the dot accessor &lt;code&gt;.&lt;/code&gt; in cases where the base value may be &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. If all of the properties exist then you&amp;rsquo;ll get the expected result, if the chain is broken, &lt;code&gt;undefined&lt;/code&gt; is returned instead of the &lt;code&gt;TypeError&lt;/code&gt; that would be raised otherwise.</source>
          <target state="translated">存在演算子 &lt;code&gt;?.&lt;/code&gt; のアクセサバリアント。プロパティのチェーンでnull参照を吸収するために使用できます。ドットアクセサの代わりに使用します &lt;code&gt;.&lt;/code&gt; ベース値が &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; 。すべてのプロパティが存在する場合、期待どおりの結果が得られます。チェーンが壊れている場合は、そうでない場合に &lt;code&gt;TypeError&lt;/code&gt; するTypeErrorの代わりに &lt;code&gt;undefined&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="39b4b99d9e71ee2e70bef418e0e782a2d14d8671" translate="yes" xml:space="preserve">
          <source>The biggest change in CoffeeScript 2 is that now the CoffeeScript compiler produces modern JavaScript syntax (ES6, or ES2015 and later). A CoffeeScript &lt;code&gt;=&amp;gt;&lt;/code&gt; becomes a JS &lt;code&gt;=&amp;gt;&lt;/code&gt;, a CoffeeScript &lt;code&gt;class&lt;/code&gt; becomes a JS &lt;code&gt;class&lt;/code&gt; and so on. Major new features in CoffeeScript 2 include &lt;a href=&quot;#async-functions&quot;&gt;async functions&lt;/a&gt; and &lt;a href=&quot;#jsx&quot;&gt;JSX&lt;/a&gt;. You can read more in the &lt;a href=&quot;https://coffeescript.org/announcing-coffeescript-2/&quot;&gt;announcement&lt;/a&gt;.</source>
          <target state="translated">CoffeeScript 2の最大の変更点は、CoffeeScriptコンパイラーが最新のJavaScript構文（ES6、またはES2015以降）を生成するようになったことです。CoffeeScript &lt;code&gt;=&amp;gt;&lt;/code&gt; はJS &lt;code&gt;=&amp;gt;&lt;/code&gt; になり、CoffeeScript &lt;code&gt;class&lt;/code&gt; はJS &lt;code&gt;class&lt;/code&gt; なります。CoffeeScript 2の主な新機能には、&lt;a href=&quot;#async-functions&quot;&gt;非同期関数&lt;/a&gt;と&lt;a href=&quot;#jsx&quot;&gt;JSXがあり&lt;/a&gt;ます。詳細については、&lt;a href=&quot;https://coffeescript.org/announcing-coffeescript-2/&quot;&gt;発表を&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="c2497321a935f3118d62328f3ee12bcb5c1b7482" translate="yes" xml:space="preserve">
          <source>The command-line version of &lt;code&gt;coffee&lt;/code&gt; is available as a &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; utility, requiring Node 6 or later. The &lt;a href=&quot;https://coffeescript.org/v2/browser-compiler-modern/coffeescript.js&quot;&gt;core compiler&lt;/a&gt; however, does not depend on Node, and can be run in any JavaScript environment, or in the browser (see &lt;a href=&quot;#try&quot;&gt;Try CoffeeScript&lt;/a&gt;).</source>
          <target state="translated">コマンドラインバージョンの &lt;code&gt;coffee&lt;/code&gt; は&lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt;ユーティリティとして使用でき、Node 6以降が必要です。&lt;a href=&quot;https://coffeescript.org/v2/browser-compiler-modern/coffeescript.js&quot;&gt;コアコンパイラは、&lt;/a&gt;しかし、ノードに依存せず、任意のJavaScript環境で実行することができ、またはブラウザに（参照&lt;a href=&quot;#try&quot;&gt;のCoffeeScriptを試してみてください&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="31dc4964bd6db99efc6d651e6a7fe7980e835c06" translate="yes" xml:space="preserve">
          <source>The deprecated version will still work, but it will print a warning before running the script.</source>
          <target state="translated">非推奨バージョンでも動作しますが、スクリプトを実行する前に警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="917837c752afebbd8afb9fd1d5377edebb699af5" translate="yes" xml:space="preserve">
          <source>The fat arrow &lt;code&gt;=&amp;gt;&lt;/code&gt; can be used to both define a function, and to bind it to the current value of &lt;code&gt;this&lt;/code&gt;, right on the spot. This is helpful when using callback-based libraries like Prototype or jQuery, for creating iterator functions to pass to &lt;code&gt;each&lt;/code&gt;, or event-handler functions to use with &lt;code&gt;on&lt;/code&gt;. Functions created with the fat arrow are able to access properties of the &lt;code&gt;this&lt;/code&gt; where they&amp;rsquo;re defined.</source>
          <target state="translated">太い矢印 &lt;code&gt;=&amp;gt;&lt;/code&gt; を使用して、関数を定義することと、関数を &lt;code&gt;this&lt;/code&gt; の現在の値にその場でバインドすることができます。これは、PrototypeやjQueryなどのコールバックベースのライブラリを使用するときに、 &lt;code&gt;each&lt;/code&gt; に渡すイテレータ関数、または &lt;code&gt;on&lt;/code&gt; で使用するイベントハンドラー関数を作成するときに役立ちます。太い矢印で作成された関数は、定義されている &lt;code&gt;this&lt;/code&gt; のプロパティにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="29b0a191e077542f4d37bce4ac1081f2f9f11272" translate="yes" xml:space="preserve">
          <source>The fat arrow was one of the most popular features of CoffeeScript, and ES2015 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;adopted it&lt;/a&gt;; so CoffeeScript 2 compiles &lt;code&gt;=&amp;gt;&lt;/code&gt; to ES &lt;code&gt;=&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">ファットアローはCoffeeScriptの最も人気のある機能の1つであり、ES2015 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;はそれを採用しました&lt;/a&gt;。したがって、CoffeeScript 2は &lt;code&gt;=&amp;gt;&lt;/code&gt; をES &lt;code&gt;=&amp;gt;&lt;/code&gt; にコンパイルします。</target>
        </trans-unit>
        <trans-unit id="881be262b3282151a82d808d99bc918261a00f29" translate="yes" xml:space="preserve">
          <source>The golden rule of CoffeeScript is: &lt;em&gt;&amp;ldquo;It&amp;rsquo;s just JavaScript.&amp;rdquo;&lt;/em&gt; The code compiles one-to-one into the equivalent JS, and there is no interpretation at runtime. You can use any existing JavaScript library seamlessly from CoffeeScript (and vice-versa). The compiled output is readable, pretty-printed, and tends to run as fast or faster than the equivalent handwritten JavaScript.</source>
          <target state="translated">CoffeeScriptの黄金律は、&lt;em&gt;「それ&lt;/em&gt;は&lt;em&gt;単なるJavaScriptです」です。&lt;/em&gt;コードは1対1で同等のJSにコンパイルされ、実行時に解釈は行われません。CoffeeScriptからシームレスに既存のJavaScriptライブラリを使用できます（逆も同様です）。コンパイルされた出力は読みやすく、きれいに印刷されており、同等の手書きJavaScriptよりも高速または高速に実行される傾向があります。</target>
        </trans-unit>
        <trans-unit id="57f6f3bb66cdefe66d61e33b194bae86dc442bf7" translate="yes" xml:space="preserve">
          <source>The only low-level loop that CoffeeScript provides is the &lt;code&gt;while&lt;/code&gt; loop. The main difference from JavaScript is that the &lt;code&gt;while&lt;/code&gt; loop can be used as an expression, returning an array containing the result of each iteration through the loop.</source>
          <target state="translated">CoffeeScriptが提供する唯一の低レベルのループは、 &lt;code&gt;while&lt;/code&gt; ループです。JavaScriptとの主な違いは、 &lt;code&gt;while&lt;/code&gt; ループを式として使用でき、ループの各反復の結果を含む配列を返すことです。</target>
        </trans-unit>
        <trans-unit id="dd6c377bf16ffa88eb3fd655b8bf77b2715b54a5" translate="yes" xml:space="preserve">
          <source>The same syntax can be used with assignment to replace a segment of an array with new values, splicing it.</source>
          <target state="translated">配列のセグメントを新しい値に置き換えてスプライシングするために、同じ構文を代入で使用することができます。</target>
        </trans-unit>
        <trans-unit id="d00bce92adf2e76e903d27d857e2684b1a2fb26a" translate="yes" xml:space="preserve">
          <source>The usual caveats about CoffeeScript apply &amp;mdash; your inline scripts will run within a closure wrapper, so if you want to expose global variables or functions, attach them to the &lt;code&gt;window&lt;/code&gt; object.</source>
          <target state="translated">CoffeeScriptに関する通常の警告が適用されます。インラインスクリプトはクロージャーラッパー内で実行されるため、グローバル変数または関数を公開する場合は、それらを &lt;code&gt;window&lt;/code&gt; オブジェクトにアタッチします。</target>
        </trans-unit>
        <trans-unit id="0407053f9f37c54f4e22762737710b115655c046" translate="yes" xml:space="preserve">
          <source>There are a few ECMAScript features that CoffeeScript intentionally doesn&amp;rsquo;t support.</source>
          <target state="translated">CoffeeScriptが意図的にサポートしていないECMAScript機能がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="dd46d0c19fd2206d2a20dcf63dd1ac447d8ef9a0" translate="yes" xml:space="preserve">
          <source>There are a handful of statements in JavaScript that can&amp;rsquo;t be meaningfully converted into expressions, namely &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt;, and &lt;code&gt;return&lt;/code&gt;. If you make use of them within a block of code, CoffeeScript won&amp;rsquo;t try to perform the conversion.</source>
          <target state="translated">JavaScriptには、意味のある式に変換できないステートメントがいくつかあります。つまり、 &lt;code&gt;break&lt;/code&gt; 、 &lt;code&gt;continue&lt;/code&gt; 、および &lt;code&gt;return&lt;/code&gt; です。コードのブロック内でそれらを使用する場合、CoffeeScriptは変換を実行しようとしません。</target>
        </trans-unit>
        <trans-unit id="8ead996d7aeda765800718ece4a37b9a3d073db9" translate="yes" xml:space="preserve">
          <source>There are very few &lt;a href=&quot;#breaking-changes&quot;&gt;breaking changes from CoffeeScript 1.x to 2&lt;/a&gt;; we hope the upgrade process is smooth for most projects.</source>
          <target state="translated">&lt;a href=&quot;#breaking-changes&quot;&gt;CoffeeScript 1.xから2への重大な変更は&lt;/a&gt;ほとんどありません。ほとんどのプロジェクトでアップグレードプロセスがスムーズであることを願っています。</target>
        </trans-unit>
        <trans-unit id="7625eae784aaf6c02294c43cdfe6aba3b3340de1" translate="yes" xml:space="preserve">
          <source>Things that would otherwise be statements in JavaScript, when used as part of an expression in CoffeeScript, are converted into expressions by wrapping them in a closure. This lets you do useful things, like assign the result of a comprehension to a variable:</source>
          <target state="translated">JavaScriptではステートメントになっていたものが、CoffeeScriptで式の一部として使用されると、クロージャでラップすることで式に変換されます。これにより、内包物の結果を変数に代入するなどの便利なことができます。</target>
        </trans-unit>
        <trans-unit id="4b17290b6006c13901c34d75f37b8174f2cf35d0" translate="yes" xml:space="preserve">
          <source>This also means you cannot pass a reference to &lt;code&gt;this&lt;/code&gt; as an argument to &lt;code&gt;super&lt;/code&gt; in the constructor of a derived class:</source>
          <target state="translated">これは、派生クラスのコンストラクターで &lt;code&gt;this&lt;/code&gt; への参照を引数として &lt;code&gt;super&lt;/code&gt; に渡すこともできないことも意味します。</target>
        </trans-unit>
        <trans-unit id="212e8a3822b15e29b023624fc8e0a3036b265be8" translate="yes" xml:space="preserve">
          <source>This is a limitation of ES2015 classes. As a workaround, assign to &lt;code&gt;this&lt;/code&gt; after the &lt;code&gt;super&lt;/code&gt; call:</source>
          <target state="translated">これはES2015クラスの制限です。回避策として、 &lt;code&gt;super&lt;/code&gt; 呼び出しの後に &lt;code&gt;this&lt;/code&gt; に割り当てます。</target>
        </trans-unit>
        <trans-unit id="ebe0a630e1017ea59b90b6804799a28e26c85ded" translate="yes" xml:space="preserve">
          <source>This is to avoid grammatical ambiguity, since in CoffeeScript such a construct looks identical to a function call (e.g. &lt;code&gt;get(function foo() {})&lt;/code&gt;); and because there is an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt;alternate syntax&lt;/a&gt; that is slightly more verbose but just as effective:</source>
          <target state="translated">これは文法の曖昧さを避けるためです。CoffeeScriptでは、このような構造は関数呼び出しと同じに見えます（たとえば、 &lt;code&gt;get(function foo() {})&lt;/code&gt; ）; もう少し冗長ですが同じくらい効果的な&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt;代替構文&lt;/a&gt;があるためです。</target>
        </trans-unit>
        <trans-unit id="e35a04b81c2c241c9e49ed37e23da66a8ec2f106" translate="yes" xml:space="preserve">
          <source>This list may be incomplete, and excludes versions of Node that support newer features behind flags; please refer to &lt;a href=&quot;http://node.green/&quot;&gt;node.green&lt;/a&gt; for full details. You can &lt;a href=&quot;https://coffeescript.org/test.html&quot;&gt;run the tests in your browser&lt;/a&gt; to see what your browser supports. It is your responsibility to ensure that your runtime supports the modern features you use; or that you &lt;a href=&quot;#transpilation&quot;&gt;transpile&lt;/a&gt; your code. When in doubt, transpile.</source>
          <target state="translated">このリストは不完全な場合があり、フラグの背後にある新しい機能をサポートするノードのバージョンは除外されます。詳細については、&lt;a href=&quot;http://node.green/&quot;&gt;node.green&lt;/a&gt;を参照してください。&lt;a href=&quot;https://coffeescript.org/test.html&quot;&gt;ブラウザーでテスト&lt;/a&gt;を実行して、ブラウザーがサポートするものを確認できます。ランタイムが使用する最新の機能を確実にサポートするようにするのはユーザーの責任です。または、コードを&lt;a href=&quot;#transpilation&quot;&gt;トランスパイルし&lt;/a&gt;ます。疑わしい場合は、トランスパイルします。</target>
        </trans-unit>
        <trans-unit id="df2efdc78bbbd411a239e3ac6067de5bfdc8c098" translate="yes" xml:space="preserve">
          <source>This will make the &lt;code&gt;coffee&lt;/code&gt; and &lt;code&gt;cake&lt;/code&gt; commands available globally.</source>
          <target state="translated">これにより、 &lt;code&gt;coffee&lt;/code&gt; と &lt;code&gt;cake&lt;/code&gt; コマンドが世界中で利用できるようになります。</target>
        </trans-unit>
        <trans-unit id="60e4dcb12e7b736abe3c6d872654f5052718c59b" translate="yes" xml:space="preserve">
          <source>To install, first make sure you have a working copy of the latest stable version of &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt;. You can then install CoffeeScript globally with &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;:</source>
          <target state="translated">インストールするには、最初に&lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.jsの&lt;/a&gt;最新の安定したバージョンの作業用コピーがあることを確認してください。その後、&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npmを使用して&lt;/a&gt; CoffeeScriptをグローバルにインストールできます。</target>
        </trans-unit>
        <trans-unit id="4d491acd5ee23c8cde5200452bec031026aa7e84" translate="yes" xml:space="preserve">
          <source>To iterate a generator function, use &lt;code&gt;from&lt;/code&gt;. See &lt;a href=&quot;#generator-iteration&quot;&gt;Generator Functions&lt;/a&gt;.</source>
          <target state="translated">ジェネレータ関数を繰り返すには、 &lt;code&gt;from&lt;/code&gt; を使用します。&lt;a href=&quot;#generator-iteration&quot;&gt;ジェネレータ関数を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4879760675e96a4c59a258d8b135d6981fed61f9" translate="yes" xml:space="preserve">
          <source>To make things easy, CoffeeScript has built-in support for the popular &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; transpiler. You can use it via the &lt;code&gt;--transpile&lt;/code&gt; command-line option or the &lt;code&gt;transpile&lt;/code&gt; Node API option. To use either, &lt;code&gt;@babel/core&lt;/code&gt; must be installed in your project:</source>
          <target state="translated">物事を簡単にするために、CoffeeScriptには人気の&lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;トランスパイラーのサポートが組み込まれています。 &lt;code&gt;--transpile&lt;/code&gt; コマンドラインオプションまたは &lt;code&gt;transpile&lt;/code&gt; ノードAPIオプションを介して使用できます。いずれかを使用するには、 &lt;code&gt;@babel/core&lt;/code&gt; プロジェクトにインストールする必要があります。</target>
        </trans-unit>
        <trans-unit id="32b8a5b68368acbc341573ad1e61a0edd20250e7" translate="yes" xml:space="preserve">
          <source>To simplify math expressions, &lt;code&gt;**&lt;/code&gt; can be used for exponentiation and &lt;code&gt;//&lt;/code&gt; performs floor division. &lt;code&gt;%&lt;/code&gt; works just like in JavaScript, while &lt;code&gt;%%&lt;/code&gt; provides &lt;a href=&quot;https://en.wikipedia.org/wiki/Modulo_operation&quot;&gt;&amp;ldquo;dividend dependent modulo&amp;rdquo;&lt;/a&gt;:</source>
          <target state="translated">数式を単純化するために、 &lt;code&gt;**&lt;/code&gt; は指数に使用でき、 &lt;code&gt;//&lt;/code&gt; 床除算を実行します。 &lt;code&gt;%&lt;/code&gt; はJavaScriptと同じように機能しますが、 &lt;code&gt;%%&lt;/code&gt; は&lt;a href=&quot;https://en.wikipedia.org/wiki/Modulo_operation&quot;&gt;「配当に依存する剰余」を&lt;/a&gt;提供します。</target>
        </trans-unit>
        <trans-unit id="760008ba15d1db1590d7becaabcd77417431770e" translate="yes" xml:space="preserve">
          <source>To step through a range comprehension in fixed-size chunks, use &lt;code&gt;by&lt;/code&gt;, for example: &lt;code&gt;evens = (x for x in [0..10] by 2)&lt;/code&gt;</source>
          <target state="translated">固定サイズのチャンクで範囲内包を調べるには、たとえば &lt;code&gt;by&lt;/code&gt; を使用します &lt;code&gt;evens = (x for x in [0..10] by 2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ae484c4ea234c74c821257172381d6f5a5706c0" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;--transpile&lt;/code&gt;, see &lt;a href=&quot;#transpilation&quot;&gt;Transpilation&lt;/a&gt;.</source>
          <target state="translated">使用するには &lt;code&gt;--transpile&lt;/code&gt; 、参照&lt;a href=&quot;#transpilation&quot;&gt;Transpilationを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="134608c329dd197fae36575214763a11330c0d6a" translate="yes" xml:space="preserve">
          <source>Transpilation</source>
          <target state="translated">Transpilation</target>
        </trans-unit>
        <trans-unit id="441544b175e1ff168280f364e13483ad37fdc025" translate="yes" xml:space="preserve">
          <source>Transpiling with the CoffeeScript compiler</source>
          <target state="translated">CoffeeScript コンパイラでのトランスパイリング</target>
        </trans-unit>
        <trans-unit id="2996879f5c4aef02081b95d839c49eeb3e309880" translate="yes" xml:space="preserve">
          <source>Try/Catch/Finally</source>
          <target state="translated">Try/Catch/Finally</target>
        </trans-unit>
        <trans-unit id="22d158ab75d63715d420bc5e58daab5d8357398c" translate="yes" xml:space="preserve">
          <source>Type Annotations</source>
          <target state="translated">タイプアノテーション</target>
        </trans-unit>
        <trans-unit id="01692a80e99068bf423c4ff03463fa9389fe6247" translate="yes" xml:space="preserve">
          <source>Unsupported ECMAScript Features</source>
          <target state="translated">サポートされていない ECMAScript の機能</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="ec90f891d39b4bc9b7913655e4904c205deb12d7" translate="yes" xml:space="preserve">
          <source>Watch a file for changes, and recompile it every time the file is saved:</source>
          <target state="translated">ファイルの変更を監視し、ファイルを保存するたびに再コンパイルします。</target>
        </trans-unit>
        <trans-unit id="a208b4d5c38d76b0c844e7782318c919be835059" translate="yes" xml:space="preserve">
          <source>Watch files for changes, rerunning the specified command when any file is updated.</source>
          <target state="translated">ファイルの変更を監視し、ファイルが更新されたときに指定したコマンドを再実行します。</target>
        </trans-unit>
        <trans-unit id="6f5de3a310cd5e9cdc833ca57fe2aff4bc3ad811" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s New In CoffeeScript 2?</source>
          <target state="translated">CoffeeScript 2の新機能</target>
        </trans-unit>
        <trans-unit id="f83e4a5d898f47de1ab2a712714b5389d4018960" translate="yes" xml:space="preserve">
          <source>When CoffeeScript was designed, &lt;code&gt;var&lt;/code&gt; was &lt;a href=&quot;https://github.com/jashkenas/coffeescript/issues/238#issuecomment-153502&quot;&gt;intentionally omitted&lt;/a&gt;. This was to spare developers the mental housekeeping of needing to worry about variable &lt;em&gt;declaration&lt;/em&gt; (&lt;code&gt;var foo&lt;/code&gt;) as opposed to variable &lt;em&gt;assignment&lt;/em&gt; (&lt;code&gt;foo = 1&lt;/code&gt;). The CoffeeScript compiler automatically takes care of declaration for you, by generating &lt;code&gt;var&lt;/code&gt; statements at the top of every function scope. This makes it impossible to accidentally declare a global variable.</source>
          <target state="translated">CoffeeScriptが設計されたとき、 &lt;code&gt;var&lt;/code&gt; は&lt;a href=&quot;https://github.com/jashkenas/coffeescript/issues/238#issuecomment-153502&quot;&gt;意図的に省略されました&lt;/a&gt;。これは、変数の&lt;em&gt;割り当て&lt;/em&gt;（ &lt;code&gt;foo = 1&lt;/code&gt; ）ではなく、変数の&lt;em&gt;宣言&lt;/em&gt;（ &lt;code&gt;var foo&lt;/code&gt; ）について心配する必要があるというメンタルハウスキーピングを開発者に与える必要がありませんでした。 CoffeeScriptコンパイラーは、すべての関数スコープの先頭に &lt;code&gt;var&lt;/code&gt; ステートメントを生成することにより、自動的に宣言を処理します。これにより、誤ってグローバル変数を宣言することができなくなります。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5d84cf7d7535701ca31c3e2199811dcec3bed09b" translate="yes" xml:space="preserve">
          <source>When using a JavaScript loop to generate functions, it&amp;rsquo;s common to insert a closure wrapper in order to ensure that loop variables are closed over, and all the generated functions don&amp;rsquo;t just share the final values. CoffeeScript provides the &lt;code&gt;do&lt;/code&gt; keyword, which immediately invokes a passed function, forwarding any arguments.</source>
          <target state="translated">JavaScriptループを使用して関数を生成する場合、ループ変数が確実に閉じられ、生成されたすべての関数が最終的な値を共有するだけではないことを確認するために、クロージャーラッパーを挿入するのが一般的です。 CoffeeScript には、渡された関数を即座に呼び出して引数を転送する &lt;code&gt;do&lt;/code&gt; キーワードが用意されています。</target>
        </trans-unit>
        <trans-unit id="ce527aeb1c14343036af5875ab0bc15b7dedfc43" translate="yes" xml:space="preserve">
          <source>While it&amp;rsquo;s not recommended for serious use, CoffeeScripts may be included directly within the browser using &lt;code&gt;&amp;lt;script type=&quot;text/coffeescript&quot;&amp;gt;&lt;/code&gt; tags. The source includes a compressed and minified version of the compiler (&lt;a href=&quot;https://coffeescript.org/v2/browser-compiler-legacy/coffeescript.js&quot;&gt;Download current version here, 77k when gzipped&lt;/a&gt;) as &lt;code&gt;docs/v2/browser-compiler-legacy/coffeescript.js&lt;/code&gt;. Include this file on a page with inline CoffeeScript tags, and it will compile and evaluate them in order.</source>
          <target state="translated">本格的な使用は推奨されませんが、CoffeeScriptは &lt;code&gt;&amp;lt;script type=&quot;text/coffeescript&quot;&amp;gt;&lt;/code&gt; タグを使用してブラウザ内に直接含めることができます。ソースには、 &lt;code&gt;docs/v2/browser-compiler-legacy/coffeescript.js&lt;/code&gt; として、圧縮されて縮小されたバージョンのコンパイラー（&lt;a href=&quot;https://coffeescript.org/v2/browser-compiler-legacy/coffeescript.js&quot;&gt;現在のバージョンをここにダウンロード、gzippedの場合は77k&lt;/a&gt;）が含まれています。インラインCoffeeScriptタグを含むページにこのファイルを含めると、それらが順番にコンパイルおよび評価されます。</target>
        </trans-unit>
        <trans-unit id="7d27f693c7d9cd75cdbdffcd127b5355d5fa8843" translate="yes" xml:space="preserve">
          <source>With the addition of &lt;a href=&quot;#jsx&quot;&gt;JSX&lt;/a&gt;, the &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; characters serve as both the &amp;ldquo;less than&amp;rdquo; and &amp;ldquo;greater than&amp;rdquo; operators and as the delimiters for XML tags, like &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;. For best results, in general you should always wrap the operators in spaces to distinguish them from XML tags: &lt;code&gt;i &amp;lt; len&lt;/code&gt;, not &lt;code&gt;i&amp;lt;len&lt;/code&gt;. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the &amp;ldquo;less than&amp;rdquo; and &amp;ldquo;greater than&amp;rdquo; operators will remove ambiguity.</source>
          <target state="translated">&lt;a href=&quot;#jsx&quot;&gt;JSX&lt;/a&gt;が追加されたことで、 &lt;code&gt;&amp;lt;&lt;/code&gt; および &lt;code&gt;&amp;gt;&lt;/code&gt; 文字は、「小なり」演算子と「大なり」演算子の両方、および &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; などのXMLタグの区切り文字として機能します。最良の結果を得るには、一般に、演算子をXMLタグと区別するために常にスペースで囲む必要があります &lt;code&gt;i &amp;lt; len&lt;/code&gt; ではなく &lt;code&gt;i&amp;lt;len&lt;/code&gt; です。コンパイラーは、意図したとおりであると確信できる場合に寛容であろうとしますが、常に「より小」および「より大」演算子の周りにスペースを置くと、あいまいさがなくなります。</target>
        </trans-unit>
        <trans-unit id="91b3860286d34d188fac6fd2475f0b7c570b45ae" translate="yes" xml:space="preserve">
          <source>Write out all compiled JavaScript files into the specified directory. Use in conjunction with &lt;code&gt;--compile&lt;/code&gt; or &lt;code&gt;--watch&lt;/code&gt;.</source>
          <target state="translated">コンパイルされたすべてのJavaScriptファイルを指定されたディレクトリに書き込みます。 &lt;code&gt;--compile&lt;/code&gt; または &lt;code&gt;--watch&lt;/code&gt; と組み合わせて使用​​します。</target>
        </trans-unit>
        <trans-unit id="7fa8e041a9d1bd281a4b489df18b79561d4193cb" translate="yes" xml:space="preserve">
          <source>You can also embed blocks of JavaScript using triple backticks. That&amp;rsquo;s easier than escaping backticks, if you need them inside your JavaScript block.</source>
          <target state="translated">また、トリプルバックティックを使用してJavaScriptのブロックを埋め込むこともできます。JavaScriptブロック内で必要な場合は、バッククォートをエスケープするよりも簡単です。</target>
        </trans-unit>
        <trans-unit id="895151cddefabe084525e0448e8f3c00c754930a" translate="yes" xml:space="preserve">
          <source>You can also transpile CoffeeScript&amp;rsquo;s output without using the &lt;code&gt;transpile&lt;/code&gt; option, for example as part of a build chain. This lets you use transpilers other than Babel, and it gives you greater control over the process. There are many great task runners for setting up JavaScript build chains, such as &lt;a href=&quot;http://gulpjs.com/&quot;&gt;Gulp&lt;/a&gt;, &lt;a href=&quot;https://webpack.github.io/&quot;&gt;Webpack&lt;/a&gt;, &lt;a href=&quot;https://gruntjs.com/&quot;&gt;Grunt&lt;/a&gt; and &lt;a href=&quot;http://broccolijs.com/&quot;&gt;Broccoli&lt;/a&gt;.</source>
          <target state="translated">ビルドチェーンの一部などとして、 &lt;code&gt;transpile&lt;/code&gt; オプションを使用せずにCoffeeScriptの出力をトランスパイルすることもできます。これにより、Babel以外のトランスパイラーを使用でき、プロセスをより詳細に制御できます。以下のようなJavaScriptのビルド・チェーンを設定するための多くの偉大なタスクランナー、あり&lt;a href=&quot;http://gulpjs.com/&quot;&gt;ガルプ&lt;/a&gt;、&lt;a href=&quot;https://webpack.github.io/&quot;&gt;WebPACKの&lt;/a&gt;、&lt;a href=&quot;https://gruntjs.com/&quot;&gt;うなり声&lt;/a&gt;と&lt;a href=&quot;http://broccolijs.com/&quot;&gt;ブロッコリーは&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ea09dd580c1117ec826c105827011d4991d422fb" translate="yes" xml:space="preserve">
          <source>You can iterate over a generator function using &lt;code&gt;for&amp;hellip;from&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;for&amp;hellip;from&lt;/code&gt; を使用してジェネレーター関数を反復できます。</target>
        </trans-unit>
        <trans-unit id="627a15b97853de570b928cbe1078ef7b23d9800d" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;in&lt;/code&gt; to test for array presence, and &lt;code&gt;of&lt;/code&gt; to test for JavaScript object-key presence.</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; を使用して配列の存在をテストしたり、 &lt;code&gt;of&lt;/code&gt; を使用してJavaScriptオブジェクトキーの存在をテストしたりできます。</target>
        </trans-unit>
        <trans-unit id="f5d72942f9c85a2499d5ad0b4ecca991c6daa18a" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;not&lt;/code&gt; as an alias for &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">のエイリアスとして使用 &lt;code&gt;not&lt;/code&gt; &lt;code&gt;!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5cc987de3ea0a3222086b75436a669c943d85b76" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t need to use parentheses to invoke a function if you&amp;rsquo;re passing arguments. The implicit call wraps forward to the end of the line or block expression.</source>
          <target state="translated">引数を渡す場合、関数を呼び出すために括弧を使用する必要はありません。暗黙の呼び出しは、行またはブロック式の終わりまで折り返します。</target>
        </trans-unit>
        <trans-unit id="b83957bfb0e2f86c484bdb23a3ecc8d6b4ba1ba9" translate="yes" xml:space="preserve">
          <source>You might have noticed how even though we don&amp;rsquo;t add return statements to CoffeeScript functions, they nonetheless return their final value. The CoffeeScript compiler tries to make sure that all statements in the language can be used as expressions. Watch how the &lt;code&gt;return&lt;/code&gt; gets pushed down into each possible branch of execution in the function below.</source>
          <target state="translated">CoffeeScript関数にreturnステートメントを追加しなくても、最終的な値を返すことに気づいたかもしれません。CoffeeScriptコンパイラーは、言語内のすべてのステートメントが式として使用できることを確認しようとします。以下の関数で、 &lt;code&gt;return&lt;/code&gt; が実行の各可能なブランチにどのようにプッシュダウンされるかを見てください。</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="94695e0be1a132fc3c8773528fdeaed22b0e2166" translate="yes" xml:space="preserve">
          <source>assigns the value of &lt;code&gt;b&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is not in scope or if &lt;code&gt;a == null&lt;/code&gt;; produces the new value of &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">割り当ての値 &lt;code&gt;b&lt;/code&gt; の場合範囲に場合やない &lt;code&gt;a == null&lt;/code&gt; 。の新しい値生成 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="30118aa1aa8a06fa5365743b3a5db69fc62b9760" translate="yes" xml:space="preserve">
          <source>await</source>
          <target state="translated">await</target>
        </trans-unit>
        <trans-unit id="7a6e8d704c7decefa5e5d4fa00c771cd1a13ce51" translate="yes" xml:space="preserve">
          <source>coffee command</source>
          <target state="translated">コーヒーコマンド</target>
        </trans-unit>
        <trans-unit id="bcf9c16f425ba1f8ea1288d2892a8012be3730df" translate="yes" xml:space="preserve">
          <source>for...from</source>
          <target state="translated">for...from</target>
        </trans-unit>
        <trans-unit id="af10ef20dd9060bbeead0afbc55381a66af442ef" translate="yes" xml:space="preserve">
          <source>in</source>
          <target state="translated">in</target>
        </trans-unit>
        <trans-unit id="b47f363e2b430c0647f14deea3eced9b0ef300ce" translate="yes" xml:space="preserve">
          <source>is</source>
          <target state="translated">is</target>
        </trans-unit>
        <trans-unit id="d5a3e9a0d2ce4a1cae8033c54a253510da7f756a" translate="yes" xml:space="preserve">
          <source>isnt</source>
          <target state="translated">isnt</target>
        </trans-unit>
        <trans-unit id="557f255516719ea16f8f4a0aae1166054e2c9b43" translate="yes" xml:space="preserve">
          <source>not</source>
          <target state="translated">not</target>
        </trans-unit>
        <trans-unit id="de04fa0e29f9b35e24905d2e512bedc9bb6e09e4" translate="yes" xml:space="preserve">
          <source>of</source>
          <target state="translated">of</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="1f1590943b001194a7e6d7ed8992d476ad4e8a6a" translate="yes" xml:space="preserve">
          <source>returns &lt;code&gt;a.b&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is in scope and &lt;code&gt;a != null&lt;/code&gt;; otherwise, &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; がスコープ内にあり &lt;code&gt;a != null&lt;/code&gt; 場合は &lt;code&gt;a.b&lt;/code&gt; 返します。それ以外の場合、 &lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf26d3117231e5075d4fd6c1bf28375ff8a7a8d2" translate="yes" xml:space="preserve">
          <source>returns &lt;code&gt;a&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is in scope and &lt;code&gt;a != null&lt;/code&gt;; otherwise, &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">返す場合はスコープ内にあると &lt;code&gt;a != null&lt;/code&gt; 。そうでなければ、 &lt;code&gt;b&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="effdab22f101bb837e277a0db2e80288c615f7e6" translate="yes" xml:space="preserve">
          <source>returns the result of calling &lt;code&gt;a&lt;/code&gt; (with arguments &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;) if &lt;code&gt;a&lt;/code&gt; is in scope and callable; otherwise, &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; がスコープ内にあり、呼び出し可能である場合 &lt;code&gt;a&lt;/code&gt; （引数bおよび &lt;code&gt;c&lt;/code&gt; を使用して）aを呼び出し &lt;code&gt;a&lt;/code&gt; 結果を返します。それ以外の場合、 &lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8451ba8a14d79753d34cb33b51ba46b4b025eb81" translate="yes" xml:space="preserve">
          <source>super</source>
          <target state="translated">super</target>
        </trans-unit>
        <trans-unit id="e7c2a4c990184f8b6e86a548b889c307e41a3860" translate="yes" xml:space="preserve">
          <source>switch...when...else</source>
          <target state="translated">switch...when...else</target>
        </trans-unit>
        <trans-unit id="46aa5a11884223ec3dcfa5773b33d0a26fc9d06c" translate="yes" xml:space="preserve">
          <source>tests that &lt;code&gt;a&lt;/code&gt; is in scope and &lt;code&gt;a != null&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; がスコープ内にあり &lt;code&gt;a != null&lt;/code&gt; であることをテストします</target>
        </trans-unit>
        <trans-unit id="f52d36be262c616a8c25a3ba007e4c58c101d1eb" translate="yes" xml:space="preserve">
          <source>try...catch...finally</source>
          <target state="translated">try...catch...finally</target>
        </trans-unit>
        <trans-unit id="42e184930956d048c819e40f18f94f0094d47bc6" translate="yes" xml:space="preserve">
          <source>unless</source>
          <target state="translated">unless</target>
        </trans-unit>
        <trans-unit id="6517f89c46c3f0d6db9cb009b8c7d1f98c371fa0" translate="yes" xml:space="preserve">
          <source>while</source>
          <target state="translated">while</target>
        </trans-unit>
        <trans-unit id="f12e1e8f455f823f59cc0134f1795184b98fe5ac" translate="yes" xml:space="preserve">
          <source>yield</source>
          <target state="translated">yield</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
