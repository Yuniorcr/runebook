<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="cb1503c554d562fcb4fdd362460ca0e88facc2f1" translate="yes" xml:space="preserve">
          <source>Get as a tuple the types of the fields of a struct, class, or union. This consists of the fields that take up memory space, excluding the hidden fields like the virtual function table pointer or a context pointer for nested types. If &lt;code&gt;T&lt;/code&gt; isn't a struct, class, or union returns a tuple with one element &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">構造体、クラス、または共用体のフィールドのタイプをタプルとして取得します。これは、仮想関数テーブルポインターやネストされた型のコンテキストポインターなどの非表示フィールドを除いて、メモリ領域を占めるフィールドで構成されます。 &lt;code&gt;T&lt;/code&gt; が構造体、クラス、または共用体でない場合、1つの要素 &lt;code&gt;T&lt;/code&gt; を持つタプルを返します。</target>
        </trans-unit>
        <trans-unit id="8352810d8951fe7d425bf1322ba1521329088590" translate="yes" xml:space="preserve">
          <source>Get as an expression tuple the names of the fields of a struct, class, or union. This consists of the fields that take up memory space, excluding the hidden fields like the virtual function table pointer or a context pointer for nested types. Inherited fields (for classes) are not included. If &lt;code&gt;T&lt;/code&gt; isn't a struct, class, or union, an expression tuple with an empty string is returned.</source>
          <target state="translated">式タプルとして、構造体、クラス、または共用体のフィールドの名前を取得します。これは、仮想関数テーブルポインターやネストされた型のコンテキストポインターなどの非表示フィールドを除いて、メモリ領域を占めるフィールドで構成されます。継承されたフィールド（クラス用）は含まれません。 &lt;code&gt;T&lt;/code&gt; が構造体、クラス、または共用体でない場合、空の文字列を持つ式タプルが返されます。</target>
        </trans-unit>
        <trans-unit id="a198ff5da76a4a9aab19b26589c9b2c10f34f479" translate="yes" xml:space="preserve">
          <source>Get creation/access/modified times of file &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">ファイル &lt;code&gt;name&lt;/code&gt; 作成/アクセス/変更時刻を取得します。</target>
        </trans-unit>
        <trans-unit id="691bafc770aff46bbe0856f713e81a3d1edbf405" translate="yes" xml:space="preserve">
          <source>Get flags for type: 1 means GC should scan for pointers, 2 means arg of this type is passed in SIMD register(s) if available</source>
          <target state="translated">型のフラグを取得します。1 は GC がポインタをスキャンすることを意味し、2 はこの型の arg が SIMD レジスタ(複数可)に渡されることを意味します。</target>
        </trans-unit>
        <trans-unit id="d0005ffe3affeeb682da9580156ed97b001d178e" translate="yes" xml:space="preserve">
          <source>Get flags for type: 1 means GC should scan for pointers, 2 means arg of this type is passed in XMM register</source>
          <target state="translated">型のフラグを取得します。1 は GC がポインタをスキャンすることを意味し、2 はこの型の arg が XMM レジスタに渡されることを意味します。</target>
        </trans-unit>
        <trans-unit id="d67dceb8ecd32907f4c80efef5b62cf3e873c8e4" translate="yes" xml:space="preserve">
          <source>Get index of field. Returns -1 if not found.</source>
          <target state="translated">フィールドのインデックスを取得します。見つからなければ -1 を返します。</target>
        </trans-unit>
        <trans-unit id="7cbd98494450e74ae712eba7afdee4e2a97eaec8" translate="yes" xml:space="preserve">
          <source>Get nth Parameter, folding in tuples.</source>
          <target state="translated">n 番目のパラメータを取得します。</target>
        </trans-unit>
        <trans-unit id="b0d99cd151ddfeaf2b13f0d9a95c891f89fbb223" translate="yes" xml:space="preserve">
          <source>Get offset of base class's vtbl[] initializer from start of csym. Returns ~0 if not this csym.</source>
          <target state="translated">基底クラスの vtbl[]イニシャライザのオフセットを取得します。この csym でない場合は ~0 を返します。</target>
        </trans-unit>
        <trans-unit id="188a425106e789190ec847f6a6792e93a54341a7" translate="yes" xml:space="preserve">
          <source>Get or set compression method used for this member.</source>
          <target state="translated">このメンバに使用される圧縮方法を取得または設定します。</target>
        </trans-unit>
        <trans-unit id="2ee99e17347439a45b11edd2de3c4f3e29784dd4" translate="yes" xml:space="preserve">
          <source>Get or set data of member in uncompressed form. When an existing archive is read &lt;code&gt;ZipArchive.expand&lt;/code&gt; needs to be called before this can be accessed.</source>
          <target state="translated">非圧縮形式でメンバーのデータを取得または設定します。既存のアーカイブが読み取られると、これにアクセスする前に &lt;code&gt;ZipArchive.expand&lt;/code&gt; を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="4c7d46f4532c87d8a4e544df5791739440cc36ce" translate="yes" xml:space="preserve">
          <source>Get or set the OS specific file attributes for this archive member.</source>
          <target state="translated">このアーカイブメンバーのOS固有のファイル属性を取得または設定します。</target>
        </trans-unit>
        <trans-unit id="1296d6fdc83b6b554050c4b4aa7fef3699ac90e1" translate="yes" xml:space="preserve">
          <source>Get or set the last modification time for this member.</source>
          <target state="translated">このメンバーの最終更新時刻を取得または設定します。</target>
        </trans-unit>
        <trans-unit id="a4feb1bf141a1d88be78b9a3366a4467fa93a965" translate="yes" xml:space="preserve">
          <source>Get range that spans all of the &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; intervals in this &lt;a href=&quot;#InversionList&quot;&gt;&lt;code&gt;InversionList&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この&lt;a href=&quot;#InversionList&quot;&gt; &lt;code&gt;InversionList&lt;/code&gt; の&lt;/a&gt;すべての&lt;a href=&quot;#Code%20point&quot;&gt;コードポイント&lt;/a&gt;間隔にまたがる範囲を取得します。</target>
        </trans-unit>
        <trans-unit id="f03d5bd32538b64243f7cd6441ecfa2b2622dbab" translate="yes" xml:space="preserve">
          <source>Get size of file &lt;code&gt;name&lt;/code&gt; in bytes.</source>
          <target state="translated">ファイル &lt;code&gt;name&lt;/code&gt; サイズをバイト単位で取得します。</target>
        </trans-unit>
        <trans-unit id="461490b8f32608cfbfd66725579129263619bc8c" translate="yes" xml:space="preserve">
          <source>Get size of ty</source>
          <target state="translated">タイのサイズを取得</target>
        </trans-unit>
        <trans-unit id="be155f80e71c94e749bac3dc7da0073ca4565577" translate="yes" xml:space="preserve">
          <source>Get targetInfo by key</source>
          <target state="translated">キーでtargetInfoを取得する</target>
        </trans-unit>
        <trans-unit id="73796f5728cf9c28582274f26067b749361695c9" translate="yes" xml:space="preserve">
          <source>Get the Key type of an Associative Array.</source>
          <target state="translated">連想配列のキー型を取得します。</target>
        </trans-unit>
        <trans-unit id="d22a099130780c3f0f5de0e5b8d691ed79199316" translate="yes" xml:space="preserve">
          <source>Get the OS specific file attributes for the archive member.</source>
          <target state="translated">アーカイブメンバーのOS固有のファイル属性を取得します。</target>
        </trans-unit>
        <trans-unit id="79ecfb6529a74964e1e68cd5ab4d563b90f3da7a" translate="yes" xml:space="preserve">
          <source>Get the Value type of an Associative Array.</source>
          <target state="translated">連想配列の値の型を取得します。</target>
        </trans-unit>
        <trans-unit id="98635513b7474e13e846f5ff833241b41e74887e" translate="yes" xml:space="preserve">
          <source>Get the access and modified times of file or folder &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">ファイルまたはフォルダ &lt;code&gt;name&lt;/code&gt; のアクセス時刻と変更時刻を取得します。</target>
        </trans-unit>
        <trans-unit id="5e205b38d81166876ff783947529f334bd179d77" translate="yes" xml:space="preserve">
          <source>Get the cached block info of an interior pointer. Returns null if the interior pointer's block is not cached.</source>
          <target state="translated">内部ポインタのキャッシュされたブロック情報を取得します。内部ポインタのブロックがキャッシュされていない場合は null を返します。</target>
        </trans-unit>
        <trans-unit id="4282bb82ffa1bb1dd9a0f9f0f2bf4c8c171f011b" translate="yes" xml:space="preserve">
          <source>Get the code unit at index i</source>
          <target state="translated">インデックス i でコード単位を取得します。</target>
        </trans-unit>
        <trans-unit id="7c3dd3625eabe5a78ecd2dfc079c83bf66c607d8" translate="yes" xml:space="preserve">
          <source>Get the current thread's instance. Returns by ref. Note that calling &lt;code&gt;get&lt;/code&gt; from any thread outside the &lt;code&gt;TaskPool&lt;/code&gt; that created this instance will return the same reference, so an instance of worker-local storage should only be accessed from one thread outside the pool that created it. If this rule is violated, undefined behavior will result.</source>
          <target state="translated">現在のスレッドのインスタンスを取得します。参照により戻ります。 &lt;code&gt;TaskPool&lt;/code&gt; 外のスレッドから &lt;code&gt;get&lt;/code&gt; を呼び出すことに注意してください。このインスタンスを作成しと、同じ参照が返されるため、ワーカーローカルストレージのインスタンスには、それを作成したプール外の1つのスレッドからのみアクセスする必要があります。このルールに違反すると、未定義の動作が発生します。</target>
        </trans-unit>
        <trans-unit id="2fa40eed5d4831ba4894fa0d2f99824123d18451" translate="yes" xml:space="preserve">
          <source>Get the current time as a &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">現在の時刻を&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;として取得する</target>
        </trans-unit>
        <trans-unit id="f8dce800f00dab2a31ba905f4b229d5e41f026c6" translate="yes" xml:space="preserve">
          <source>Get the current time from the system clock</source>
          <target state="translated">システムクロックから現在の時刻を取得する</target>
        </trans-unit>
        <trans-unit id="7d101e5841a77867eef23ee238263d38f724a6f3" translate="yes" xml:space="preserve">
          <source>Get the current working directory.</source>
          <target state="translated">現在の作業ディレクトリを取得します。</target>
        </trans-unit>
        <trans-unit id="b3b0d480375a5d6d1deedae54218ae4809699a35" translate="yes" xml:space="preserve">
          <source>Get the default &lt;code&gt;Throwable.TraceInfo&lt;/code&gt; implementation for the platform</source>
          <target state="translated">プラットフォームのデフォルトの &lt;code&gt;Throwable.TraceInfo&lt;/code&gt; 実装を取得する</target>
        </trans-unit>
        <trans-unit id="1a4ef6fd99cfc2a1e29f50c6d9ba5ed116754be8" translate="yes" xml:space="preserve">
          <source>Get the drive portion of a path.</source>
          <target state="translated">パスのドライブ部分を取得します。</target>
        </trans-unit>
        <trans-unit id="c1d426ae9f2d48f1089e0e4fbe50dd7b4c9abc89" translate="yes" xml:space="preserve">
          <source>Get the first argument &lt;code&gt;a&lt;/code&gt; that passes an &lt;code&gt;if (unaryFun!pred(a))&lt;/code&gt; test. If no argument passes the test, return the last argument.</source>
          <target state="translated">&lt;code&gt;if (unaryFun!pred(a))&lt;/code&gt; テストに合格する最初の引数 &lt;code&gt;a&lt;/code&gt; を取得します。テストに合格した引数がない場合は、最後の引数を返します。</target>
        </trans-unit>
        <trans-unit id="71fd3b068f374669047aed8f9838bd5650f74328" translate="yes" xml:space="preserve">
          <source>Get the full package name for the given symbol.</source>
          <target state="translated">指定されたシンボルの完全なパッケージ名を取得します。</target>
        </trans-unit>
        <trans-unit id="e88db6759fbbcb530d5bab26ba3ec77a124f346e" translate="yes" xml:space="preserve">
          <source>Get the fully qualified name of a type or a symbol. Can act as an intelligent type/symbol to string converter.</source>
          <target state="translated">型や記号の完全修飾名を取得します。インテリジェントな型/記号から文字列への変換器として機能します。</target>
        </trans-unit>
        <trans-unit id="e02735fcab968c6e59f5f8bdf04603517f7d65eb" translate="yes" xml:space="preserve">
          <source>Get the function type from a callable object &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">呼び出し可能なオブジェクト &lt;code&gt;func&lt;/code&gt; から関数型を取得します。</target>
        </trans-unit>
        <trans-unit id="0126813350919cfa23ae233f4d4ec97faf37d1f5" translate="yes" xml:space="preserve">
          <source>Get the last modification time for this member.</source>
          <target state="translated">このメンバーの最終更新時刻を取得します。</target>
        </trans-unit>
        <trans-unit id="2b55b05c55c5a5fab2ff26e964d410c035b4ab1b" translate="yes" xml:space="preserve">
          <source>Get the linger option.</source>
          <target state="translated">リンガーオプションを取得します。</target>
        </trans-unit>
        <trans-unit id="2731449c54e0db2efeec9062c6ec93a54eb72587" translate="yes" xml:space="preserve">
          <source>Get the message describing the error. Base behavior is to return the &lt;code&gt;Throwable.msg&lt;/code&gt; field. Override to return some other error message.</source>
          <target state="translated">エラーを説明するメッセージを取得します。基本的な動作は、 &lt;code&gt;Throwable.msg&lt;/code&gt; を返すことですフィールドです。オーバーライドして他のエラーメッセージを返します。</target>
        </trans-unit>
        <trans-unit id="4b21108b2b9de9b6cbf7e566c0a2ddc0c0ca72f0" translate="yes" xml:space="preserve">
          <source>Get the module name (including package) for the given symbol.</source>
          <target state="translated">指定したシンボルのモジュール名(パッケージを含む)を取得します。</target>
        </trans-unit>
        <trans-unit id="3288e20d4e0a2e8cea872e1f5d70b8c2b93389f8" translate="yes" xml:space="preserve">
          <source>Get the primitive types of the fields of a struct or class, in topological order.</source>
          <target state="translated">構造体やクラスのフィールドのプリミティブ型をトポロジカルな順序で取得します。</target>
        </trans-unit>
        <trans-unit id="3543b05579b2dbf35e3b0cd1e4b2b942a6076e5c" translate="yes" xml:space="preserve">
          <source>Get the size of the file, ulong.max if file is not searchable, but still throws if an actual error occurs.</source>
          <target state="translated">ファイルのサイズを取得します。ファイルが検索できない場合は ulong.max を取得しますが、実際にエラーが発生した場合はスローされます。</target>
        </trans-unit>
        <trans-unit id="79a49f491dcc81c94695a311e67110f25317cf05" translate="yes" xml:space="preserve">
          <source>Get the socket's address family.</source>
          <target state="translated">ソケットのアドレスファミリを取得します。</target>
        </trans-unit>
        <trans-unit id="4e5a697008886f18598415a18e551017ef50a8a2" translate="yes" xml:space="preserve">
          <source>Get the the default initialization expression for a type.</source>
          <target state="translated">型のデフォルトの初期化式を取得します。</target>
        </trans-unit>
        <trans-unit id="ebb8fbb5373a6b9ecc71521fb5c82104b76b2dda" translate="yes" xml:space="preserve">
          <source>Get the type of the return value from a function, a pointer to function, a delegate, a struct with an opCall, a pointer to a struct with an opCall, or a class with an &lt;code&gt;opCall&lt;/code&gt;. Please note that ref is not part of a type, but the attribute of the function (see template &lt;a href=&quot;#functionAttributes&quot;&gt;&lt;code&gt;functionAttributes&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">関数の戻り値の型、関数へのポインタ、デリゲート、opCall、opCall、または持つクラスを持つ構造体へのポインタを持つ構造体を取得 &lt;code&gt;opCall&lt;/code&gt; を。refはタイプの一部ではなく、関数の属性であることに注意してください（テンプレート&lt;a href=&quot;#functionAttributes&quot;&gt; &lt;code&gt;functionAttributes&lt;/code&gt; を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="2f15e792b4182f5761446203a960686f6a1fd8cb" translate="yes" xml:space="preserve">
          <source>Get the type that a scalar type &lt;code&gt;T&lt;/code&gt; will &lt;a href=&quot;https://dlang.org/spec/type.html#integer-promotions&quot;&gt;promote&lt;/a&gt; to in multi-term arithmetic expressions.</source>
          <target state="translated">多項演算式でスカラー型 &lt;code&gt;T&lt;/code&gt; が&lt;a href=&quot;https://dlang.org/spec/type.html#integer-promotions&quot;&gt;昇格&lt;/a&gt;する型を取得します。</target>
        </trans-unit>
        <trans-unit id="d86851901246015e180e22d937a94cdd4a67d0cf" translate="yes" xml:space="preserve">
          <source>Get the type that all types can be implicitly converted to. Useful e.g. in figuring out an array type from a bunch of initializing values. Returns void if passed an empty list, or if the types have no common type.</source>
          <target state="translated">すべての型が暗黙のうちに変換できる型を取得します。例えば、初期化された値の束から配列の型を見つけるのに便利です。空のリストを渡した場合、あるいは型に共通の型がない場合は void を返します。</target>
        </trans-unit>
        <trans-unit id="d8834c0e5c45f02dee115c0af5916029dd3645eb" translate="yes" xml:space="preserve">
          <source>Get the type that will really be used for passing the given argument to an &lt;code&gt;extern(C++)&lt;/code&gt; function.</source>
          <target state="translated">与えられた引数を &lt;code&gt;extern(C++)&lt;/code&gt; 関数に渡すために実際に使用される型を取得します。</target>
        </trans-unit>
        <trans-unit id="1a8db062181587e0a37ac18deba2e6a2d99a21b8" translate="yes" xml:space="preserve">
          <source>Get the underlying path.</source>
          <target state="translated">その根底にあるパスを取得します。</target>
        </trans-unit>
        <trans-unit id="8aa89601daef2aac5d5712f9ccfde65d17aeb883" translate="yes" xml:space="preserve">
          <source>Get the underlying type which a &lt;code&gt;Typedef&lt;/code&gt; wraps. If &lt;code&gt;T&lt;/code&gt; is not a &lt;code&gt;Typedef&lt;/code&gt; it will alias itself to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Typedef&lt;/code&gt; がラップする基になる型を取得します。 &lt;code&gt;T&lt;/code&gt; が &lt;code&gt;Typedef&lt;/code&gt; でない場合は、 &lt;code&gt;T&lt;/code&gt; にエイリアスします。</target>
        </trans-unit>
        <trans-unit id="bc66c2f8e24da37f6181d5e17247039b03831383" translate="yes" xml:space="preserve">
          <source>Get the value of the .max/.min property as an Expression. Lazily computes the value and caches it in maxval/minval. Reports any errors.</source>
          <target state="translated">.max/.minプロパティの値をExpressionとして取得します。怠惰に値を計算し、maxval/minval にキャッシュします。エラーを報告します。</target>
        </trans-unit>
        <trans-unit id="bb25c1e8984031c906b57204ab00dc5ad735d012" translate="yes" xml:space="preserve">
          <source>Get the various timings like name lookup time, total time, connect time etc. The timed category is passed through the timing parameter while the timing value is stored at val. The value is usable only if res is equal to &lt;code&gt;etc.c.curl.CurlError.ok&lt;/code&gt;.</source>
          <target state="translated">名前のルックアップ時間、合計時間、接続時間など、さまざまなタイミングを取得します。タイミングの値がvalに保存されている間に、時間指定されたカテゴリがタイミングパラメータを介して渡されます。この値は、resが &lt;code&gt;etc.c.curl.CurlError.ok&lt;/code&gt; と等しい場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="912a474bb0a0204ed6b0e20848237a640087bf6c" translate="yes" xml:space="preserve">
          <source>Get tuple, one per function parameter, of the storage classes of the parameters.</source>
          <target state="translated">関数のパラメータごとにパラメータのストレージクラスのタプルを取得します。</target>
        </trans-unit>
        <trans-unit id="36c705a4549f55994270c31cf59dc15c22af56b1" translate="yes" xml:space="preserve">
          <source>Get type information on the contents of the type; null if not available</source>
          <target state="translated">型の内容に関する型情報を取得します。</target>
        </trans-unit>
        <trans-unit id="96f72b00f8ed83794b8d1d1ca2272471a19aedec" translate="yes" xml:space="preserve">
          <source>Get underlying socket handle.</source>
          <target state="translated">ソケットハンドルを取得します。</target>
        </trans-unit>
        <trans-unit id="48ec336cb3c23da76d213eaa7aef8a04ca5f0b14" translate="yes" xml:space="preserve">
          <source>Get various timings defined in &lt;a href=&quot;etc_c_curl#CurlInfo&quot;&gt;&lt;code&gt;etc.c.curl.CurlInfo&lt;/code&gt;&lt;/a&gt;. The value is usable only if the return value is equal to &lt;code&gt;etc.c.curl.CurlError.ok&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;etc_c_curl#CurlInfo&quot;&gt; &lt;code&gt;etc.c.curl.CurlInfo&lt;/code&gt; で&lt;/a&gt;定義されているさまざまなタイミングを取得します。この値は、戻り値が &lt;code&gt;etc.c.curl.CurlError.ok&lt;/code&gt; と等しい場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="efecd1a1ec18ed172626c58e06a872720a3ea949" translate="yes" xml:space="preserve">
          <source>Get with custom data receivers:</source>
          <target state="translated">カスタムデータ受信機で取得します。</target>
        </trans-unit>
        <trans-unit id="bb969faa69556a50edb8b7474adfcb5288a0eabc" translate="yes" xml:space="preserve">
          <source>Get, as a tuple, the default value of the parameters to a function symbol. If a parameter doesn't have the default value, &lt;code&gt;void&lt;/code&gt; is returned instead.</source>
          <target state="translated">関数シンボルへのパラメータのデフォルト値をタプルとして取得します。パラメータにデフォルト値がない場合は、代わりに &lt;code&gt;void&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="6e5eb1b88f56e22db495838fb23d06aff7902858" translate="yes" xml:space="preserve">
          <source>Get, as a tuple, the identifiers of the parameters to a function symbol.</source>
          <target state="translated">関数シンボルのパラメータの識別子をタプルで取得します。</target>
        </trans-unit>
        <trans-unit id="0d9be8cea698e918f8f5553c38491cc55f980684" translate="yes" xml:space="preserve">
          <source>Get, as a tuple, the types of the parameters to a function, a pointer to function, a delegate, a struct with an &lt;code&gt;opCall&lt;/code&gt;, a pointer to a struct with an &lt;code&gt;opCall&lt;/code&gt;, or a class with an &lt;code&gt;opCall&lt;/code&gt;.</source>
          <target state="translated">タプルとして、関数へのパラメーターの型、関数へのポインター、デリゲート、 &lt;code&gt;opCall&lt;/code&gt; を持つ構造体、 &lt;code&gt;opCall&lt;/code&gt; を持つ構造体へのポインター、またはopCallを持つクラスを &lt;code&gt;opCall&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="4a2a322d7843413da4411904750627b588381236" translate="yes" xml:space="preserve">
          <source>Get/set number of elements in the array. It is of type &lt;code&gt;size_t&lt;/code&gt;.</source>
          <target state="translated">配列の要素数を取得/設定します。タイプは &lt;code&gt;size_t&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e903dced1589591dccd55f4a2a573704d37b25f7" translate="yes" xml:space="preserve">
          <source>Get/set socket's blocking flag.</source>
          <target state="translated">ソケットのブロッキングフラグを取得/設定します。</target>
        </trans-unit>
        <trans-unit id="8143cfad11bbcb508b2faa890c629adbe90a1326" translate="yes" xml:space="preserve">
          <source>GetoptResult &lt;strong id=&quot;getopt&quot;&gt;getopt&lt;/strong&gt;(T...)(ref string[] args, T opts);</source>
          <target state="translated">GetoptResult &lt;strong id=&quot;getopt&quot;&gt;getopt&lt;/strong&gt;（T ...）（ref string [] args、T opts）;</target>
        </trans-unit>
        <trans-unit id="3639898092fae686744daf985b5a5af78426e672" translate="yes" xml:space="preserve">
          <source>Gets a &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; at the given index in this cluster.</source>
          <target state="translated">このクラスター内の指定されたインデックスにある&lt;a href=&quot;#Code%20point&quot;&gt;コードポイント&lt;/a&gt;を取得します。</target>
        </trans-unit>
        <trans-unit id="3b7dd24ad864c772981b0d66dc0022feced1b999" translate="yes" xml:space="preserve">
          <source>Gets a larger buffer &lt;code&gt;buf&lt;/code&gt; by calling &lt;code&gt;parent.allocate(goodAllocSize(n))&lt;/code&gt;. If &lt;code&gt;buf&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, returns &lt;code&gt;null&lt;/code&gt;. Otherwise, returns &lt;code&gt;buf[0 .. n]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;parent.allocate(goodAllocSize(n))&lt;/code&gt; を呼び出して、より大きなバッファ &lt;code&gt;buf&lt;/code&gt; を取得します。 &lt;code&gt;buf&lt;/code&gt; が &lt;code&gt;null&lt;/code&gt; の場合、nullを返し &lt;code&gt;null&lt;/code&gt; 。それ以外の場合は、 &lt;code&gt;buf[0 .. n]&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="b2c0f14712193b76cf9f29f4a2238a646ef9482c" translate="yes" xml:space="preserve">
          <source>Gets a range of key/values for &lt;code&gt;aa&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;aa&lt;/code&gt; のキー/値の範囲を取得します。</target>
        </trans-unit>
        <trans-unit id="0f00eae4c2ff9337f7291213da97c9dc6aebf8d8" translate="yes" xml:space="preserve">
          <source>Gets a thread-local instance of ThreadInfo, which should be used as the default instance when info is requested for a thread not created by the Scheduler.</source>
          <target state="translated">スケジューラによって作成されていないスレッドに対して情報を要求する際に、デフォルトのインスタンスとして使用されるべきスレッドローカルの ThreadInfo のインスタンスを取得します。</target>
        </trans-unit>
        <trans-unit id="f6f18bccfb576e34d7b5fa60615448449996ea12" translate="yes" xml:space="preserve">
          <source>Gets a thread-local instance of ThreadInfo.</source>
          <target state="translated">ThreadInfo のスレッドローカルインスタンスを取得します。</target>
        </trans-unit>
        <trans-unit id="b472fcab365d2a6ba9fdba822432b62db948d127" translate="yes" xml:space="preserve">
          <source>Gets an object representing the reader lock for the associated mutex.</source>
          <target state="translated">関連するミューテックスのリーダロックを表すオブジェクトを取得します。</target>
        </trans-unit>
        <trans-unit id="2bad6a1697863b959c51608194a08c6aaf894ca4" translate="yes" xml:space="preserve">
          <source>Gets an object representing the writer lock for the associated mutex.</source>
          <target state="translated">関連するミューテックスのライタロックを表すオブジェクトを取得します。</target>
        </trans-unit>
        <trans-unit id="c2134c8e8821e26937fe2aedd4aa0e2891a164f8" translate="yes" xml:space="preserve">
          <source>Gets called on program shutdown just after GC is terminated.</source>
          <target state="translated">GC が終了した直後のプログラムのシャットダウン時に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="3863a33d5ec162d09008cccc833b8dbca9f1864e" translate="yes" xml:space="preserve">
          <source>Gets called on program startup just before GC is initialized.</source>
          <target state="translated">GC が初期化される直前のプログラム起動時に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="fdc75e27ba04f67b552a395ef0dbfb72c8501519" translate="yes" xml:space="preserve">
          <source>Gets expression at offset of type. Returns NULL if not found.</source>
          <target state="translated">型のオフセットにある式を取得します。見つからなかった場合は NULL を返します。</target>
        </trans-unit>
        <trans-unit id="cc94d4edefc014f546538ff3e9cb05bec4999447" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;i&lt;/code&gt;'th bit in the &lt;code&gt;BitArray&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BitArray&lt;/code&gt; の &lt;code&gt;i&lt;/code&gt; 番目のビットを取得します。</target>
        </trans-unit>
        <trans-unit id="8011563ddbd748ff521930918dc8bcb499b269a2" translate="yes" xml:space="preserve">
          <source>Gets the OS identifier for this thread.</source>
          <target state="translated">このスレッドの OS 識別子を取得します。</target>
        </trans-unit>
        <trans-unit id="685489f583759f962fe7c1daab0034a07cb9d516" translate="yes" xml:space="preserve">
          <source>Gets the Tid associated with name.</source>
          <target state="translated">名前に関連付けられた Tid を取得します。</target>
        </trans-unit>
        <trans-unit id="5c6e15b07949cc6ff89428732b9e3b99b89bcdc8" translate="yes" xml:space="preserve">
          <source>Gets the current collect handler.</source>
          <target state="translated">現在のコレクトハンドラを取得します。</target>
        </trans-unit>
        <trans-unit id="4ee9c2ec9df011130e3394bc652f9b3e7978ed43" translate="yes" xml:space="preserve">
          <source>Gets the current legacy module unit tester.</source>
          <target state="translated">現在のレガシーモジュールのユニットテスターを取得します。</target>
        </trans-unit>
        <trans-unit id="b9fd850a635cce1ec806814a7cb5c442887ef8c8" translate="yes" xml:space="preserve">
          <source>Gets the current module unit tester.</source>
          <target state="translated">現在のモジュールユニットテスターを取得します。</target>
        </trans-unit>
        <trans-unit id="e72b94a5c6c1c6b67ed9a2ba11a48dec6fb51fea" translate="yes" xml:space="preserve">
          <source>Gets the current state of this fiber.</source>
          <target state="translated">このファイバーの現在の状態を取得します。</target>
        </trans-unit>
        <trans-unit id="86b54a37d38df76c69490341ad477a651e752312" translate="yes" xml:space="preserve">
          <source>Gets the current trace handler.</source>
          <target state="translated">現在のトレースハンドラを取得します。</target>
        </trans-unit>
        <trans-unit id="48b50302326e46ace0f0f71974024ade98c4d812" translate="yes" xml:space="preserve">
          <source>Gets the daemon status for this thread. While the runtime will wait for all normal threads to complete before tearing down the process, daemon threads are effectively ignored and thus will not prevent the process from terminating. In effect, daemon threads will be terminated automatically by the OS when the process exits.</source>
          <target state="translated">このスレッドのデーモンの状態を取得します。ランタイムはプロセスが終了する前に通常のスレッドが完了するのを待ちますが、 デーモンスレッドは事実上無視されるため、プロセスの終了を防ぐことはできません。事実上、プロセスが終了すると、デーモンスレッドは OS によって自動的に終了されます。</target>
        </trans-unit>
        <trans-unit id="6388b81675e677f57fc44bb674c4998dc61bbf09" translate="yes" xml:space="preserve">
          <source>Gets the index of the current thread relative to this &lt;code&gt;TaskPool&lt;/code&gt;. Any thread not in this pool will receive an index of 0. The worker threads in this pool receive unique indices of 1 through &lt;code&gt;this.size&lt;/code&gt;.</source>
          <target state="translated">この &lt;code&gt;TaskPool&lt;/code&gt; に関連する現在のスレッドのインデックスを取得します。このプールにないスレッドは、インデックス0を &lt;code&gt;this.size&lt;/code&gt; ます。このプールのワーカースレッドは、this.sizeを通じて1の一意のインデックスを受け取ります。</target>
        </trans-unit>
        <trans-unit id="397d4288bd9f56373ed42093b36baf0cf34c80d4" translate="yes" xml:space="preserve">
          <source>Gets the matching &lt;a href=&quot;https://dlang.org/spec/attribute.html#uda&quot;&gt;user-defined attributes&lt;/a&gt; from the given symbol.</source>
          <target state="translated">指定されたシンボルから一致する&lt;a href=&quot;https://dlang.org/spec/attribute.html#uda&quot;&gt;ユーザー定義属性を&lt;/a&gt;取得します。</target>
        </trans-unit>
        <trans-unit id="ff4bb9618e0f172c3deb93f3fe4c73732cb67c80" translate="yes" xml:space="preserve">
          <source>Gets the mutex associated with this condition.</source>
          <target state="translated">この条件に関連するミューテックスを取得します。</target>
        </trans-unit>
        <trans-unit id="b1cafc8d1ad4c93a1519578fd6ef07cfbae8c0d4" translate="yes" xml:space="preserve">
          <source>Gets the nth number in the underlying representation that makes up the whole &lt;code&gt;BigInt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BigInt&lt;/code&gt; 全体を構成する基本となる表現のn番目の数値を取得します。</target>
        </trans-unit>
        <trans-unit id="801e40683c25723cacc6326aca38101be95c4627" translate="yes" xml:space="preserve">
          <source>Gets the policy used by this mutex.</source>
          <target state="translated">このミューテックスで使用されているポリシーを取得します。</target>
        </trans-unit>
        <trans-unit id="8aba27c226485427875db239e8c2e09071484ea6" translate="yes" xml:space="preserve">
          <source>Gets the scheduling priority for the associated thread.</source>
          <target state="translated">関連するスレッドのスケジューリングの優先度を取得します。</target>
        </trans-unit>
        <trans-unit id="cf58bd5c03eda3fe4cc7594124c4b61e9c109dc9" translate="yes" xml:space="preserve">
          <source>Gets the type of the &lt;code&gt;TypeInfo&lt;/code&gt; object associated with &lt;code&gt;t&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; に関連付けられた &lt;code&gt;TypeInfo&lt;/code&gt; オブジェクトのタイプを取得します</target>
        </trans-unit>
        <trans-unit id="9211b2fb8e24a472f1780790cfdc50455081852e" translate="yes" xml:space="preserve">
          <source>Gets the user-readable label for this thread.</source>
          <target state="translated">このスレッドのユーザが読めるラベルを取得します。</target>
        </trans-unit>
        <trans-unit id="611d2080794dfc9ee82363d9d9da4aa9a138b19f" translate="yes" xml:space="preserve">
          <source>Gets the value if not null. If &lt;code&gt;this&lt;/code&gt; is in the null state, and the optional parameter &lt;code&gt;fallback&lt;/code&gt; was provided, it will be returned. Without &lt;code&gt;fallback&lt;/code&gt;, calling &lt;code&gt;get&lt;/code&gt; with a null state is invalid.</source>
          <target state="translated">nullでない場合、値を取得します。場合 &lt;code&gt;this&lt;/code&gt; ヌル状態であり、オプションのパラメータの &lt;code&gt;fallback&lt;/code&gt; 提供された、それが返されます。 &lt;code&gt;fallback&lt;/code&gt; なしでは、null状態で &lt;code&gt;get&lt;/code&gt; を呼び出すことは無効です。</target>
        </trans-unit>
        <trans-unit id="7ce43e8e9e8874c455bc1d408b4db63789ae5ade" translate="yes" xml:space="preserve">
          <source>Gets the value. &lt;code&gt;this&lt;/code&gt; must not be in the null state. This function is also called for the implicit conversion to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">値を取得します。 &lt;code&gt;this&lt;/code&gt; はnull状態であってはなりません。この関数は、 &lt;code&gt;T&lt;/code&gt; への暗黙的な変換のためにも呼び出されます。</target>
        </trans-unit>
        <trans-unit id="27ec2c5053941a53ff7bc20b3630c9aa87b310af" translate="yes" xml:space="preserve">
          <source>Gets vendor-specific type mangling for C++ ABI.</source>
          <target state="translated">C++ABI のベンダ固有の型マングリングを取得します。</target>
        </trans-unit>
        <trans-unit id="7e2612461374b070bc3713b89e3df4f4c33fbf6f" translate="yes" xml:space="preserve">
          <source>Gets/sets assert hander. null means the default handler is used.</source>
          <target state="translated">assert ハンドラを取得/設定します。</target>
        </trans-unit>
        <trans-unit id="8a46199cc00d346a1fe72a372a1bcb52b3b1947f" translate="yes" xml:space="preserve">
          <source>Gets/sets the allocator for the current process. This allocator must be used for allocating memory shared across threads. Objects created using this allocator can be cast to &lt;code&gt;shared&lt;/code&gt;.</source>
          <target state="translated">現在のプロセスのアロケーターを取得または設定します。このアロケータは、スレッド間で共有されるメモリを割り当てるために使用する必要があります。このアロケータを使用して作成されたオブジェクトは、 &lt;code&gt;shared&lt;/code&gt; にキャストできます。</target>
        </trans-unit>
        <trans-unit id="b3f3fc74fb3ec91a1abfd15e2f2178014ba02b91" translate="yes" xml:space="preserve">
          <source>Gets/sets the allocator for the current thread. This is the default allocator that should be used for allocating thread-local memory. For allocating memory to be shared across threads, use &lt;code&gt;processAllocator&lt;/code&gt; (below). By default, &lt;code&gt;theAllocator&lt;/code&gt; ultimately fetches memory from &lt;code&gt;processAllocator&lt;/code&gt;, which in turn uses the garbage collected heap.</source>
          <target state="translated">現在のスレッドのアロケーターを取得または設定します。これは、スレッドローカルメモリの割り当てに使用するデフォルトのアロケータです。スレッド間で共有されるメモリを割り当てるには、以下の &lt;code&gt;processAllocator&lt;/code&gt; を使用します。デフォルトでは、 &lt;code&gt;theAllocator&lt;/code&gt; は最終的に、ガベージコレクションされたヒープを使用する &lt;code&gt;processAllocator&lt;/code&gt; からメモリをフェッチします。</target>
        </trans-unit>
        <trans-unit id="ce0e5e384b0423d01fbe02461b7f604937af05a9" translate="yes" xml:space="preserve">
          <source>Getting a range of all the named captures in the regex.</source>
          <target state="translated">正規表現内のすべての名前付きキャプチャの範囲を取得します。</target>
        </trans-unit>
        <trans-unit id="3239f451b140324af46d3a3db896ec8a5a618fbd" translate="yes" xml:space="preserve">
          <source>Getting the benefits of multiple adaptable freelists that do not need to be tuned for one specific size but insted automatically adapts itself to frequently used sizes.</source>
          <target state="translated">1つの特定のサイズのために調整する必要はありませんが、インステッドは、頻繁に使用されるサイズに自動的に自分自身を適応させる複数の適応可能なフリーリストの利点を取得します。</target>
        </trans-unit>
        <trans-unit id="c7ae27f036579182bace286ba1e0cf636e5ff36f" translate="yes" xml:space="preserve">
          <source>Getting the priority of a thread that already terminated might return the default priority.</source>
          <target state="translated">すでに終了したスレッドの優先度を取得すると、デフォルトの優先度を返すことがあります。</target>
        </trans-unit>
        <trans-unit id="d5546b9dfb555ac771be9469163d9af49686adbe" translate="yes" xml:space="preserve">
          <source>Give error if we're not an lvalue. If we can, convert expression to be an lvalue.</source>
          <target state="translated">lvalueでない場合はエラーを出します。可能であれば、式をlvalueに変換します。</target>
        </trans-unit>
        <trans-unit id="74474e23aa26985e7a98ca671962a908920e33b2" translate="yes" xml:space="preserve">
          <source>Give up.</source>
          <target state="translated">諦めろ</target>
        </trans-unit>
        <trans-unit id="6839d82e03f5268d9a7cc97802db76c48c8cce6e" translate="yes" xml:space="preserve">
          <source>Given</source>
          <target state="translated">Given</target>
        </trans-unit>
        <trans-unit id="545c45c89bb40c5d7b7b442770eb2c94a5c06899" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;a == b&lt;/code&gt; :</source>
          <target state="translated">与えられ &lt;code&gt;a == b&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="53726705da0088ae9fbab83c8c50c091febc70d1" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;flags&lt;/code&gt; as a combination of &lt;code&gt;AllocFlag&lt;/code&gt; values, or a type &lt;code&gt;T&lt;/code&gt;, returns the allocator that's a closest fit in capabilities.</source>
          <target state="translated">与えられた &lt;code&gt;flags&lt;/code&gt; の組み合わせとして &lt;code&gt;AllocFlag&lt;/code&gt; の値、またはタイプ &lt;code&gt;T&lt;/code&gt; 、能力の最も近いフィット感ですアロケータを返します。</target>
        </trans-unit>
        <trans-unit id="62b1bd97df8e740424d65deb5d1e60e2802ffce0" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;index&lt;/code&gt; into &lt;code&gt;str&lt;/code&gt; and assuming that &lt;code&gt;index&lt;/code&gt; is at the start of a UTF sequence, &lt;code&gt;toUCSindex&lt;/code&gt; determines the number of UCS characters up to &lt;code&gt;index&lt;/code&gt;. So, &lt;code&gt;index&lt;/code&gt; is the index of a code unit at the beginning of a code point, and the return value is how many code points into the string that that code point is.</source>
          <target state="translated">与えられた &lt;code&gt;index&lt;/code&gt; に &lt;code&gt;str&lt;/code&gt; とと仮定して &lt;code&gt;index&lt;/code&gt; UTFシーケンスの開始時で、 &lt;code&gt;toUCSindex&lt;/code&gt; は最大UCS文字の数を決定し &lt;code&gt;index&lt;/code&gt; 。したがって、 &lt;code&gt;index&lt;/code&gt; はコードポイントの先頭にあるコードユニットのインデックスであり、戻り値はそのコードポイントが文字列にあるコードポイントの数です。</target>
        </trans-unit>
        <trans-unit id="bb7cf3072f3bd953aeae94de343ed5c6b8a94867" translate="yes" xml:space="preserve">
          <source>Given D code like:</source>
          <target state="translated">与えられたDのコードは、次のようになります。</target>
        </trans-unit>
        <trans-unit id="d736ecdf41cd9fce2597d330cc34519b6b941a39" translate="yes" xml:space="preserve">
          <source>Given EBP, find return address to caller, and caller's EBP.</source>
          <target state="translated">EBPが与えられた場合、発信者への返送先住所と発信者のEBPを検索します。</target>
        </trans-unit>
        <trans-unit id="eb6400b34d9067d59b3f43922d46e893c8d36002" translate="yes" xml:space="preserve">
          <source>Given a &lt;code&gt;source&lt;/code&gt; range that is expensive to iterate over, returns an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; that asynchronously buffers the contents of &lt;code&gt;source&lt;/code&gt; into a buffer of &lt;code&gt;bufSize&lt;/code&gt; elements in a worker thread, while making previously buffered elements from a second buffer, also of size &lt;code&gt;bufSize&lt;/code&gt;, available via the range interface of the returned object. The returned range has a length iff &lt;code&gt;hasLength!S&lt;/code&gt;. &lt;code&gt;asyncBuf&lt;/code&gt; is useful, for example, when performing expensive operations on the elements of ranges that represent data on a disk or network.</source>
          <target state="translated">与えられた &lt;code&gt;source&lt;/code&gt; 、反復処理に費用がかかる範囲を返し&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;、入力レンジ&lt;/a&gt;は非同期の内容バッファ &lt;code&gt;source&lt;/code&gt; のバッファに &lt;code&gt;bufSize&lt;/code&gt; 第2のバッファから、またサイズの以前に緩衝要素ながら、ワーカースレッドの要素を &lt;code&gt;bufSize&lt;/code&gt; 、利用可能介し返されたオブジェクトの範囲インターフェース。返される範囲の長さは &lt;code&gt;hasLength!S&lt;/code&gt; と異なります。 &lt;code&gt;asyncBuf&lt;/code&gt; は、たとえば、ディスクまたはネットワーク上のデータを表す範囲の要素に対して負荷の高い操作を実行する場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="699c74248abd14b4250ad690ede845e5aad24631" translate="yes" xml:space="preserve">
          <source>Given a Base64 encoded string, calculates the length of the decoded string.</source>
          <target state="translated">Base64でエンコードされた文字列が与えられると、デコードされた文字列の長さを計算します。</target>
        </trans-unit>
        <trans-unit id="bc7d61e132762100a6e8861609dacf0581eebca4" translate="yes" xml:space="preserve">
          <source>Given a C++ function in a C++ source file:</source>
          <target state="translated">C++ソース・ファイル内の C++関数を指定します。</target>
        </trans-unit>
        <trans-unit id="7de884353daa1d02f969775316b89c9805864eba" translate="yes" xml:space="preserve">
          <source>Given a UCS index &lt;code&gt;n&lt;/code&gt; into &lt;code&gt;str&lt;/code&gt;, returns the UTF index. So, &lt;code&gt;n&lt;/code&gt; is how many code points into the string the code point is, and the array index of the code unit is returned.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; へのUCSインデックス &lt;code&gt;n&lt;/code&gt; を指定すると、UTFインデックスを返します。したがって、 &lt;code&gt;n&lt;/code&gt; は、コードポイントが文字列に含まれるコードポイントの数であり、コードユニットの配列インデックスが返されます。</target>
        </trans-unit>
        <trans-unit id="3aa76f9d8ead49fe4c4634dcc93f9d715d5abf9c" translate="yes" xml:space="preserve">
          <source>Given a and p, the function finds x such that</source>
          <target state="translated">a と p が与えられると、関数は次のような x を見つけます。</target>
        </trans-unit>
        <trans-unit id="97696594fbe0457c99be87ef93b37c947e4a5703" translate="yes" xml:space="preserve">
          <source>Given a callable object &lt;code&gt;next&lt;/code&gt; that writes to a user-provided buffer and a second callable object &lt;code&gt;empty&lt;/code&gt; that determines whether more data is available to write via &lt;code&gt;next&lt;/code&gt;, returns an input range that asynchronously calls &lt;code&gt;next&lt;/code&gt; with a set of size &lt;code&gt;nBuffers&lt;/code&gt; of buffers and makes the results available in the order they were obtained via the input range interface of the returned object. Similarly to the input range overload of &lt;code&gt;asyncBuf&lt;/code&gt;, the first half of the buffers are made available via the range interface while the second half are filled and vice-versa.</source>
          <target state="translated">ユーザー提供のバッファーに書き込む呼び出し可能オブジェクト &lt;code&gt;next&lt;/code&gt; と、 &lt;code&gt;next&lt;/code&gt; を介して書き込むデータが &lt;code&gt;nBuffers&lt;/code&gt; あるかどうかを判断する &lt;code&gt;empty&lt;/code&gt; 2番目の呼び出し可能オブジェクトが与えられた場合、一連のサイズnBuffersのバッファーで &lt;code&gt;next&lt;/code&gt; を非同期的に呼び出す入力範囲を返し、結果は、返されたオブジェクトの入力範囲インターフェイスを介して取得された順序で利用できます。 &lt;code&gt;asyncBuf&lt;/code&gt; の入力範囲オーバーロードと同様に、バッファの前半は範囲インターフェイスを介して利用可能になり、後半は満たされます（逆も同様）。</target>
        </trans-unit>
        <trans-unit id="f4bc9912c00cf7ade5e6f59f3c7bafa79a0098bb" translate="yes" xml:space="preserve">
          <source>Given a function &lt;code&gt;f&lt;/code&gt; and a range &lt;code&gt;[a .. b]&lt;/code&gt; such that &lt;code&gt;f(a)&lt;/code&gt; and &lt;code&gt;f(b)&lt;/code&gt; have opposite signs or at least one of them equals &amp;plusmn;0, returns the value of &lt;code&gt;x&lt;/code&gt; in the range which is closest to a root of &lt;code&gt;f(x)&lt;/code&gt;. If &lt;code&gt;f(x)&lt;/code&gt; has more than one root in the range, one will be chosen arbitrarily. If &lt;code&gt;f(x)&lt;/code&gt; returns NaN, NaN will be returned; otherwise, this algorithm is guaranteed to succeed.</source>
          <target state="translated">関数所与 &lt;code&gt;f&lt;/code&gt; 及び範囲を &lt;code&gt;[a .. b]&lt;/code&gt; ように &lt;code&gt;f(a)&lt;/code&gt; 及び &lt;code&gt;f(b)&lt;/code&gt; 反対の符号又はこれらの少なくとも一つを有しているが&amp;plusmn;0に等しい、の値を返し &lt;code&gt;x&lt;/code&gt; Aに最も近い範囲内に &lt;code&gt;f(x)&lt;/code&gt; のルート。場合 &lt;code&gt;f(x)&lt;/code&gt; 範囲内の複数のルートを有し、一方が任意に選択されるであろう。 &lt;code&gt;f(x)&lt;/code&gt; がNaNを返す場合、NaNが返されます。それ以外の場合、このアルゴリズムは成功することが保証されています。</target>
        </trans-unit>
        <trans-unit id="b3d905355b0b0e68c40d2c94bafa678611e3caae" translate="yes" xml:space="preserve">
          <source>Given a new instance tithis of this TemplateDeclaration, see if there already exists an instance. If so, return that existing instance.</source>
          <target state="translated">この TemplateDeclaration の新しいインスタンス tithis が与えられると、既にインスタンスが存在するかどうかを確認します。存在する場合は、その既存のインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="7902cf88ea3243b9d5f9eb153e89c6c4585563c1" translate="yes" xml:space="preserve">
          <source>Given a pointer &lt;code&gt;chunk&lt;/code&gt; to uninitialized memory (but already typed as &lt;code&gt;T&lt;/code&gt;), constructs an object of non-&lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. If &lt;code&gt;T&lt;/code&gt; is a class, initializes the class reference to null.</source>
          <target state="translated">初期化されていないメモリへのポインタ &lt;code&gt;chunk&lt;/code&gt; （ただし、既に &lt;code&gt;T&lt;/code&gt; として型指定されている）を指定すると、そのアドレスに非 &lt;code&gt;class&lt;/code&gt; 型 &lt;code&gt;T&lt;/code&gt; のオブジェクトを構築します。 &lt;code&gt;T&lt;/code&gt; がクラスの場合、クラス参照をnullに初期化します。</target>
        </trans-unit>
        <trans-unit id="abaa134bbbf8060e8ac6344879f8e8d611739ebe" translate="yes" xml:space="preserve">
          <source>Given a pointer &lt;code&gt;chunk&lt;/code&gt; to uninitialized memory (but already typed as a non-class type &lt;code&gt;T&lt;/code&gt;), constructs an object of type &lt;code&gt;T&lt;/code&gt; at that address from arguments &lt;code&gt;args&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is a class, initializes the class reference to &lt;code&gt;args[0]&lt;/code&gt;.</source>
          <target state="translated">初期化されていないメモリへのポインタ &lt;code&gt;chunk&lt;/code&gt; （ただし、既に非クラス型 &lt;code&gt;T&lt;/code&gt; として型指定されている）を指定すると、引数 &lt;code&gt;args&lt;/code&gt; からそのアドレスに &lt;code&gt;T&lt;/code&gt; 型のオブジェクトを構築します。 &lt;code&gt;T&lt;/code&gt; がクラスの場合、クラス参照を &lt;code&gt;args[0]&lt;/code&gt; に初期化します。</target>
        </trans-unit>
        <trans-unit id="58557c048614c0f1ce20fdb67b5db3ba6bf2d1b4" translate="yes" xml:space="preserve">
          <source>Given a pointer &lt;code&gt;chunk&lt;/code&gt; to uninitialized memory (but already typed as a non-class type &lt;code&gt;T&lt;/code&gt;), constructs an object of type &lt;code&gt;T&lt;/code&gt; at that address from arguments &lt;code&gt;args&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is a class, initializes the class reference to &lt;code&gt;args[0]&lt;/code&gt;. This function can be &lt;code&gt;@trusted&lt;/code&gt; if the corresponding constructor of &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;@safe&lt;/code&gt;.</source>
          <target state="translated">初期化されていないメモリへのポインタ &lt;code&gt;chunk&lt;/code&gt; （ただし、既に非クラス型 &lt;code&gt;T&lt;/code&gt; として型指定されている）を指定すると、引数 &lt;code&gt;args&lt;/code&gt; からそのアドレスに &lt;code&gt;T&lt;/code&gt; 型のオブジェクトを構築します。 &lt;code&gt;T&lt;/code&gt; がクラスの場合、クラス参照を &lt;code&gt;args[0]&lt;/code&gt; に初期化します。 &lt;code&gt;T&lt;/code&gt; の対応するコンストラクターが &lt;code&gt;@trusted&lt;/code&gt; 場合、この関数は &lt;code&gt;@safe&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="18ffdf892cf328d6d063a845b68a6520844d64c2" translate="yes" xml:space="preserve">
          <source>Given a pointer: If it is an Object, return that Object. If it is an interface, return the Object implementing the interface. If it is null, return null. Else, undefined crash</source>
          <target state="translated">ポインタが与えられている。それがオブジェクトであれば、そのオブジェクトを返します。インターフェースの場合は、そのインターフェースを実装したオブジェクトを返します。null の場合は null を返します。そうでなければ、未定義のクラッシュ</target>
        </trans-unit>
        <trans-unit id="a2a17bffc5b9d113dc0183d4777b121f1563c333" translate="yes" xml:space="preserve">
          <source>Given a random-access range and a starting point, creates a range that alternately returns the next left and next right element to the starting point.</source>
          <target state="translated">ランダムアクセス範囲と始点が与えられると、次の左要素と次の右要素を始点に交互に返す範囲を作成します。</target>
        </trans-unit>
        <trans-unit id="cf77f4783176c69f24bf5139063bed48dbcdbc05" translate="yes" xml:space="preserve">
          <source>Given a range of elements, constructs an index of its top</source>
          <target state="translated">要素の範囲が与えられると,その先頭のインデックスを作成します.</target>
        </trans-unit>
        <trans-unit id="f82f27390a9cc6295ef9d3e2c499d003645adbcb" translate="yes" xml:space="preserve">
          <source>Given a range of ranges, iterate transversally through the &lt;code&gt;n&lt;/code&gt;th element of each of the enclosed ranges. This function is similar to &lt;code&gt;unzip&lt;/code&gt; in other languages.</source>
          <target state="translated">範囲の範囲を指定すると、囲まれた各範囲の &lt;code&gt;n&lt;/code&gt; 番目の要素を横断的に反復します。この関数は、他の言語の &lt;code&gt;unzip&lt;/code&gt; に似ています。</target>
        </trans-unit>
        <trans-unit id="99d831c39b761ba6173d077a392b684dab424593" translate="yes" xml:space="preserve">
          <source>Given a range of ranges, iterate transversally through the first elements of each of the enclosed ranges.</source>
          <target state="translated">範囲が与えられている場合、囲まれた範囲のそれぞれの最初の要素を横方向に反復処理します。</target>
        </trans-unit>
        <trans-unit id="76deeb26e0b9b94a659a1c8d77489812eb190823" translate="yes" xml:space="preserve">
          <source>Given a range of ranges, returns a range of ranges where the</source>
          <target state="translated">範囲の範囲を指定すると、範囲の範囲の中で</target>
        </trans-unit>
        <trans-unit id="23b1b22050fe1a6a85e37baec0da8ef5a908711a" translate="yes" xml:space="preserve">
          <source>Given a range of sorted &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward ranges&lt;/a&gt;&lt;code&gt;ror&lt;/code&gt;, copies to &lt;code&gt;tgt&lt;/code&gt; the elements that are common to most ranges, along with their number of occurrences. All ranges in &lt;code&gt;ror&lt;/code&gt; are assumed to be sorted by &lt;code&gt;less&lt;/code&gt;. Only the most frequent &lt;code&gt;tgt.length&lt;/code&gt; elements are returned.</source>
          <target state="translated">ソートされた&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;前方範囲&lt;/a&gt; &lt;code&gt;ror&lt;/code&gt; の範囲を指定すると、出現回数とともに、ほとんどの範囲に共通の要素を &lt;code&gt;tgt&lt;/code&gt; にコピーします。 &lt;code&gt;ror&lt;/code&gt; のすべての範囲は、 &lt;code&gt;less&lt;/code&gt; でソートされると想定されています。最も頻度の高い &lt;code&gt;tgt.length&lt;/code&gt; 要素のみが返されます。</target>
        </trans-unit>
        <trans-unit id="6cadfddfad656a52536264d1af9f3900d194ed5c" translate="yes" xml:space="preserve">
          <source>Given a raw memory area &lt;code&gt;chunk&lt;/code&gt; (but already typed as a class type &lt;code&gt;T&lt;/code&gt;), constructs an object of &lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. The constructor is passed the arguments &lt;code&gt;Args&lt;/code&gt;.</source>
          <target state="translated">生のメモリ領域 &lt;code&gt;chunk&lt;/code&gt; （ただし、すでにクラス型 &lt;code&gt;T&lt;/code&gt; として型指定されている）を指定すると、そのアドレスに &lt;code&gt;class&lt;/code&gt; 型 &lt;code&gt;T&lt;/code&gt; のオブジェクトを構築します。コンストラクターには引数 &lt;code&gt;Args&lt;/code&gt; が渡されます。</target>
        </trans-unit>
        <trans-unit id="adbee075f1252282f1c423c0af02edd4265ab66b" translate="yes" xml:space="preserve">
          <source>Given a raw memory area &lt;code&gt;chunk&lt;/code&gt; (but already typed as a class type &lt;code&gt;T&lt;/code&gt;), constructs an object of &lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. The constructor is passed the arguments &lt;code&gt;Args&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is an inner class whose &lt;code&gt;outer&lt;/code&gt; field can be used to access an instance of the enclosing class, then &lt;code&gt;Args&lt;/code&gt; must not be empty, and the first member of it must be a valid initializer for that &lt;code&gt;outer&lt;/code&gt; field. Correct initialization of this field is essential to access members of the outer class inside &lt;code&gt;T&lt;/code&gt; methods.</source>
          <target state="translated">生のメモリ領域 &lt;code&gt;chunk&lt;/code&gt; （ただし、すでにクラス型 &lt;code&gt;T&lt;/code&gt; として型指定されている）を指定すると、そのアドレスに &lt;code&gt;class&lt;/code&gt; 型 &lt;code&gt;T&lt;/code&gt; のオブジェクトを構築します。コンストラクターには引数 &lt;code&gt;Args&lt;/code&gt; が渡されます。場合 &lt;code&gt;T&lt;/code&gt; は、その内部クラスである &lt;code&gt;outer&lt;/code&gt; フィールド取り囲むクラスのインスタンスにアクセスするために使用することができ、その後、 &lt;code&gt;Args&lt;/code&gt; 空であってはならない、それの最初のメンバーは、そのための有効な初期化でなければならない &lt;code&gt;outer&lt;/code&gt; フィールド。このフィールドの正しい初期化は、 &lt;code&gt;T&lt;/code&gt; メソッド内の外部クラスのメンバーにアクセスするために不可欠です。</target>
        </trans-unit>
        <trans-unit id="0653a1ab81721bb4c49575b0fcabecb4d629612a" translate="yes" xml:space="preserve">
          <source>Given a raw memory area &lt;code&gt;chunk&lt;/code&gt;, constructs an object of &lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. The constructor is passed the arguments &lt;code&gt;Args&lt;/code&gt;.</source>
          <target state="translated">生のメモリ領域 &lt;code&gt;chunk&lt;/code&gt; を指定すると、そのアドレスに &lt;code&gt;class&lt;/code&gt; タイプ &lt;code&gt;T&lt;/code&gt; のオブジェクトを構築します。コンストラクターには引数 &lt;code&gt;Args&lt;/code&gt; が渡されます。</target>
        </trans-unit>
        <trans-unit id="74cf19c0277fb6a57dd8ab3cb630a33bfe4fee0c" translate="yes" xml:space="preserve">
          <source>Given a raw memory area &lt;code&gt;chunk&lt;/code&gt;, constructs an object of &lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. The constructor is passed the arguments &lt;code&gt;Args&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is an inner class whose &lt;code&gt;outer&lt;/code&gt; field can be used to access an instance of the enclosing class, then &lt;code&gt;Args&lt;/code&gt; must not be empty, and the first member of it must be a valid initializer for that &lt;code&gt;outer&lt;/code&gt; field. Correct initialization of this field is essential to access members of the outer class inside &lt;code&gt;T&lt;/code&gt; methods.</source>
          <target state="translated">生のメモリ領域 &lt;code&gt;chunk&lt;/code&gt; を指定すると、そのアドレスに &lt;code&gt;class&lt;/code&gt; タイプ &lt;code&gt;T&lt;/code&gt; のオブジェクトを構築します。コンストラクターには引数 &lt;code&gt;Args&lt;/code&gt; が渡されます。場合 &lt;code&gt;T&lt;/code&gt; は、その内部クラスである &lt;code&gt;outer&lt;/code&gt; フィールド取り囲むクラスのインスタンスにアクセスするために使用することができ、その後、 &lt;code&gt;Args&lt;/code&gt; 空であってはならない、それの最初のメンバーは、そのための有効な初期化でなければならない &lt;code&gt;outer&lt;/code&gt; フィールド。このフィールドの正しい初期化は、 &lt;code&gt;T&lt;/code&gt; メソッド内の外部クラスのメンバーにアクセスするために不可欠です。</target>
        </trans-unit>
        <trans-unit id="e137ad6b52d9b560e6ecf089479316e86462ce01" translate="yes" xml:space="preserve">
          <source>Given a raw memory area &lt;code&gt;chunk&lt;/code&gt;, constructs an object of non-&lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. The constructor is passed the arguments &lt;code&gt;args&lt;/code&gt;, if any.</source>
          <target state="translated">未加工のメモリ領域 &lt;code&gt;chunk&lt;/code&gt; を指定すると、そのアドレスに非 &lt;code&gt;class&lt;/code&gt; タイプ &lt;code&gt;T&lt;/code&gt; のオブジェクトを構築します。コンストラクタには、引数 &lt;code&gt;args&lt;/code&gt; があれば渡されます。</target>
        </trans-unit>
        <trans-unit id="f8745e4f392d96921746aba6d016d8b75a3eaf5b" translate="yes" xml:space="preserve">
          <source>Given a symbol that could be either a FuncDeclaration or a function template, resolve it to a function symbol.</source>
          <target state="translated">FuncDeclaration または関数テンプレートのいずれかであるシンボルが与えられた場合、それを関数シンボルに解決します。</target>
        </trans-unit>
        <trans-unit id="3ec7e3b2070dd15d8c86e7da24a716e09d94b001" translate="yes" xml:space="preserve">
          <source>Given a type &lt;code&gt;S&lt;/code&gt; that is one of:</source>
          <target state="translated">タイプ &lt;code&gt;S&lt;/code&gt; の場合：</target>
        </trans-unit>
        <trans-unit id="5bf486ff307c1ac9da00abda18e996a0151d6f51" translate="yes" xml:space="preserve">
          <source>Given a type &lt;code&gt;T&lt;/code&gt;, returns its allocation-related flags as a combination of &lt;code&gt;AllocFlag&lt;/code&gt; values.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; を指定すると、割り当て関連のフラグを &lt;code&gt;AllocFlag&lt;/code&gt; 値の組み合わせとして返します。</target>
        </trans-unit>
        <trans-unit id="1ec656f1b47e3a570669cfd79e664b45a8112e7a" translate="yes" xml:space="preserve">
          <source>Given address that is inside a function, figure out which function it is in. Return DHandlerTable if there is one, NULL if not.</source>
          <target state="translated">関数内にあるアドレスが与えられた場合,それがどの関数内にあるかを調べます.DHandlerTableがあればDHandlerTableを返し、なければNULLを返します。</target>
        </trans-unit>
        <trans-unit id="84fb4bae252188c74a52ee250ba7895934a71e72" translate="yes" xml:space="preserve">
          <source>Given an &lt;a href=&quot;https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)&quot;&gt;object factory&lt;/a&gt; of type &lt;code&gt;Factory&lt;/code&gt; or a factory function &lt;code&gt;factoryFunction&lt;/code&gt;, and optionally also &lt;code&gt;BookkeepingAllocator&lt;/code&gt; as a supplemental allocator for bookkeeping, &lt;code&gt;AllocatorList&lt;/code&gt; creates an allocator that lazily creates as many allocators are needed for satisfying client allocation requests.</source>
          <target state="translated">指定された&lt;a href=&quot;https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)&quot;&gt;オブジェクトファクトリ&lt;/a&gt;タイプの &lt;code&gt;Factory&lt;/code&gt; または工場機能 &lt;code&gt;factoryFunction&lt;/code&gt; 、および必要に応じてさらに &lt;code&gt;BookkeepingAllocator&lt;/code&gt; 簿記のための補助的なアロケータとして、 &lt;code&gt;AllocatorList&lt;/code&gt; は多くのアロケータは、クライアントの割り当て要求を満たすために必要とされるように遅延して作成するアロケータを作成します。</target>
        </trans-unit>
        <trans-unit id="2c2ffbad9b196900545a99b58a4a8084fb8e968f" translate="yes" xml:space="preserve">
          <source>Given an &lt;code&gt;AssignExp&lt;/code&gt;, determine if the lvalue will cause the contents of the rvalue to escape. Print error messages when these are detected. Infer &lt;code&gt;scope&lt;/code&gt; attribute for the lvalue where possible, in order to eliminate the error.</source>
          <target state="translated">与えられた &lt;code&gt;AssignExp&lt;/code&gt; 左辺値が右辺値の内容が脱出するようになります場合は、決定します。これらが検出された場合、エラーメッセージを出力します。エラーを排除するために、可能な場合は左辺値の &lt;code&gt;scope&lt;/code&gt; 属性を推測します。</target>
        </trans-unit>
        <trans-unit id="f4edc9674fd3041f4bd8fcdf8c36704d26537a1f" translate="yes" xml:space="preserve">
          <source>Given an Expression, find the variable it really is.</source>
          <target state="translated">式が与えられたとき、それが実際にどのような変数であるかを見つけます。</target>
        </trans-unit>
        <trans-unit id="10135b6f779b47ff66661cf2060528825cdb0465" translate="yes" xml:space="preserve">
          <source>Given an allocator factory, lazily creates as many allocators as needed to satisfy allocation requests. The allocators are stored in a linked list. Requests for allocation are satisfied by searching the list in a linear manner.</source>
          <target state="translated">アロケータファクトリーが与えられると、アロケーション要求を満たすために必要な数だけアロケータを怠惰に作成します。アロケータはリンクされたリストに格納されます。アロケーションの要求は、線形的にリストを検索することで満たされます。</target>
        </trans-unit>
        <trans-unit id="c68fd4e0d6a4caa1cbbef6c7b7cc84e1b16b2800" translate="yes" xml:space="preserve">
          <source>Given an error instantiating the TemplateInstance, give the nested TemplateInstance instantiations that got us here. Those are a list threaded into the nested scopes.</source>
          <target state="translated">TemplateInstance のインスタンス化にエラーが発生した場合、ここでは入れ子になった TemplateInstance のインスタンスを指定します。これらは、入れ子になったスコープにスレッドされたリストです。</target>
        </trans-unit>
        <trans-unit id="0d192178ddf2961ae655bd11083f31d24b553ec6" translate="yes" xml:space="preserve">
          <source>Given an expression e that is an array, determine and set the 'length' variable.</source>
          <target state="translated">配列である式 e が与えられたとき、変数 'length' を決定して設定します。</target>
        </trans-unit>
        <trans-unit id="13b4b240c1888ba281f7a8d067f704fc09eba179" translate="yes" xml:space="preserve">
          <source>Given array literal oldval of type ArrayLiteralExp or StringExp, of length oldlen, change its length to newlen. If the newlen is longer than oldlen, all new elements will be set to the default initializer for the element type.</source>
          <target state="translated">ArrayLiteralExp または StringExp 型の配列リテラル oldval の長さ oldlen が与えられた場合、その長さを newlen に変更します。newlen の長さが oldlen よりも長い場合、すべての新しい要素は要素の型のデフォルトの初期化子に設定されます。</target>
        </trans-unit>
        <trans-unit id="4fe6c27981ac387048ac652b298a3c233afd1136" translate="yes" xml:space="preserve">
          <source>Given array of foreach parameters and an aggregate type, find best opApply overload, if any of the parameter types are missing, attempt to infer them from the aggregate type.</source>
          <target state="translated">foreachパラメータの配列と集約型が与えられている場合,最適なopApplyオーバーロードを見つけ,パラメータ型がない場合は集約型から推論を試みます.</target>
        </trans-unit>
        <trans-unit id="548081a2237345a0383114c21603c8b8dab1f303" translate="yes" xml:space="preserve">
          <source>Given callable (&lt;a href=&quot;std_traits#isCallable&quot;&gt;&lt;code&gt;std.traits.isCallable&lt;/code&gt;&lt;/a&gt;) &lt;code&gt;fun&lt;/code&gt;, create as a range whose front is defined by successive calls to &lt;code&gt;fun()&lt;/code&gt;. This is especially useful to call function with global side effects (random functions), or to create ranges expressed as a single delegate, rather than an entire &lt;code&gt;front&lt;/code&gt;/&lt;code&gt;popFront&lt;/code&gt;/&lt;code&gt;empty&lt;/code&gt; structure. &lt;code&gt;fun&lt;/code&gt; maybe be passed either a template alias parameter (existing function, delegate, struct type defining &lt;code&gt;static opCall&lt;/code&gt;) or a run-time value argument (delegate, function object). The result range models an InputRange (&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;&lt;code&gt;std.range.primitives.isInputRange&lt;/code&gt;&lt;/a&gt;). The resulting range will call &lt;code&gt;fun()&lt;/code&gt; on construction, and every call to &lt;code&gt;popFront&lt;/code&gt;, and the cached value will be returned when &lt;code&gt;front&lt;/code&gt; is called.</source>
          <target state="translated">callable（&lt;a href=&quot;std_traits#isCallable&quot;&gt; &lt;code&gt;std.traits.isCallable&lt;/code&gt; &lt;/a&gt;） &lt;code&gt;fun&lt;/code&gt; を指定して、その前線が &lt;code&gt;fun()&lt;/code&gt; への連続した呼び出しによって定義される範囲として作成します。これは、グローバルな副作用（ランダム関数）で関数を呼び出す場合や、 &lt;code&gt;front&lt;/code&gt; / &lt;code&gt;popFront&lt;/code&gt; / &lt;code&gt;empty&lt;/code&gt; 構造全体ではなく、単一のデリゲートとして表現される範囲を作成する場合に特に便利です。 &lt;code&gt;fun&lt;/code&gt; は、テンプレートエイリアスパラメータ（既存の関数、デリゲート、 &lt;code&gt;static opCall&lt;/code&gt; 定義する構造体タイプ）またはランタイム値の引数（デリゲート、関数オブジェクト）のいずれかを渡される可能性があります。結果の範囲は、InputRange（&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt; &lt;code&gt;std.range.primitives.isInputRange&lt;/code&gt; &lt;/a&gt;）をモデル化します。結果の範囲は &lt;code&gt;fun()&lt;/code&gt; を呼び出します構築時、および &lt;code&gt;popFront&lt;/code&gt; のすべての呼び出し、およびキャッシュされた値は、 &lt;code&gt;front&lt;/code&gt; が呼び出されたときに返されます。</target>
        </trans-unit>
        <trans-unit id="a6cdf45c5874188e502ef446c2f299954ad8e06e" translate="yes" xml:space="preserve">
          <source>Given function arguments, figure out which template function to expand, and return matching result.</source>
          <target state="translated">関数の引数が与えられた場合、どのテンプレート関数を展開するかを考え、マッチした結果を返します。</target>
        </trans-unit>
        <trans-unit id="2c41e0d5b6e5292f4394dbada3bf0e11b9965e54" translate="yes" xml:space="preserve">
          <source>Given that it is only called with &lt;a href=&quot;#safe-values&quot;&gt;safe values&lt;/a&gt; and &lt;a href=&quot;#safe-aliasing&quot;&gt;safe aliasing&lt;/a&gt;, a function has a safe interface when:</source>
          <target state="translated">&lt;a href=&quot;#safe-values&quot;&gt;安全な値&lt;/a&gt;と&lt;a href=&quot;#safe-aliasing&quot;&gt;安全なエイリアシング&lt;/a&gt;でのみ呼び出されることを考えると、関数は次の場合に安全なインターフェイスを持ちます。</target>
        </trans-unit>
        <trans-unit id="f1c0666f9da353f9c6f10f1cf5edecb5189140bb" translate="yes" xml:space="preserve">
          <source>Given that the most frequent use of &lt;code&gt;InSituRegion&lt;/code&gt; is as a stack allocator, it allocates starting at the end on systems where stack grows downwards, such that hot memory is used first.</source>
          <target state="translated">&lt;code&gt;InSituRegion&lt;/code&gt; の最も頻繁な使用はスタックアロケーターとしてであるとすると、ホットメモリーが最初に使用されるように、スタックが下向きに成長するシステムの最後から割り当てを開始します。</target>
        </trans-unit>
        <trans-unit id="433dfce23255598b88ff3eee832e615faf6acb1f" translate="yes" xml:space="preserve">
          <source>Given that ti is an instance of this TemplateDeclaration, deduce the types of the parameters to this, and store those deduced types in dedtypes[].</source>
          <target state="translated">ti がこの TemplateDeclaration のインスタンスであることを考えると、そのパラメータの型を推論し、推論した型を dedtypes[]に格納します。</target>
        </trans-unit>
        <trans-unit id="de6b7e538358277d4d77d0a6dfdd22d328ebcdc2" translate="yes" xml:space="preserve">
          <source>Given y, the function finds x such log(x) - digamma(x) = y.</source>
          <target state="translated">y が与えられると、関数は log(x)-digamma(x)=y のような x を求めます。</target>
        </trans-unit>
        <trans-unit id="992b94a2b2bacb1095a0b111a75eb520df8ea274" translate="yes" xml:space="preserve">
          <source>Given y, the function finds x such that</source>
          <target state="translated">y が与えられると、関数は次のような x を見つけます。</target>
        </trans-unit>
        <trans-unit id="b5ce07b779103b2800f63623f7d95755262b29ac" translate="yes" xml:space="preserve">
          <source>Gives a hint to the processor that the calling thread is in a 'spin-wait' loop, allowing to more efficiently allocate resources.</source>
          <target state="translated">呼び出したスレッドが「スピン待ち」ループに入っていることをプロセッサに通知し、より効率的にリソースを割り当てられるようにします。</target>
        </trans-unit>
        <trans-unit id="a6d6838e980e7d735fe427a6cf2d72e4e8647a21" translate="yes" xml:space="preserve">
          <source>Gives a string containing all of the member variables on their own line.</source>
          <target state="translated">自分の行にあるすべてのメンバ変数を含む文字列を与えます。</target>
        </trans-unit>
        <trans-unit id="7913f0379d403503a25672003418cf5f3eca8630" translate="yes" xml:space="preserve">
          <source>Gives a string in the form of &lt;code&gt;Appender!(A)(data)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Appender!(A)(data)&lt;/code&gt; の形式で文字列を提供します。</target>
        </trans-unit>
        <trans-unit id="e8ea4a4989f9ed3007485f30bc4c477cf8cf78af" translate="yes" xml:space="preserve">
          <source>Gives a template that can be used to apply the same attributes that are on the given type &lt;code&gt;T&lt;/code&gt;. E.g. passing &lt;code&gt;inout shared int&lt;/code&gt; will return &lt;code&gt;SharedInoutOf&lt;/code&gt;.</source>
          <target state="translated">指定されたタイプ &lt;code&gt;T&lt;/code&gt; にあるものと同じ属性を適用するために使用できるテンプレートを提供します。たとえば、 &lt;code&gt;inout shared int&lt;/code&gt; を渡すと &lt;code&gt;SharedInoutOf&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="a2633d057ea2e2d5df044edc1a3e53e74d5c07e4" translate="yes" xml:space="preserve">
          <source>Gives size in bytes of the memory mapped file.</source>
          <target state="translated">メモリマップされたファイルのサイズをバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="16bbae332a1e2ca617ea29aad4cae716be022cf2" translate="yes" xml:space="preserve">
          <source>Gives the &lt;code&gt;sizeof&lt;/code&gt; the largest type given.</source>
          <target state="translated">与えられた最大の型の &lt;code&gt;sizeof&lt;/code&gt; 与えます。</target>
        </trans-unit>
        <trans-unit id="83055a3a0dd1a147d856955312d10beee008598a" translate="yes" xml:space="preserve">
          <source>Gives the difference between two &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">2つの&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;の違いを示します。</target>
        </trans-unit>
        <trans-unit id="7aeb61024a32a4be6fbe1fa0169b6dc0e34e0c60" translate="yes" xml:space="preserve">
          <source>Gives the difference between two &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">2つの&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;の違いを示します。</target>
        </trans-unit>
        <trans-unit id="a3e5e3dc87d1abe001240e5d15a0f4c35cd6e9f2" translate="yes" xml:space="preserve">
          <source>Gives the difference between two &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">2つの&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;の違いを示します。</target>
        </trans-unit>
        <trans-unit id="e0ddf7ec5492699d7655f4aa024331ee0d174c96" translate="yes" xml:space="preserve">
          <source>Gives the difference between two &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">2つの&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt;の違いを示します。</target>
        </trans-unit>
        <trans-unit id="23a706ac15ae0a2795d3b9540c47b5bd8f3ce3a4" translate="yes" xml:space="preserve">
          <source>Gives the last power of two before &lt;code&gt;val&lt;/code&gt;. &amp;lt;&amp;gt;&amp;gt; can be any built-in numerical type.</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; の前に2の最後のべき乗を与えます。&amp;lt;&amp;gt;&amp;gt;は、組み込みの数値型にすることができます。</target>
        </trans-unit>
        <trans-unit id="5eba15a4a12033f10f76ecaeb54e9264300c3d84" translate="yes" xml:space="preserve">
          <source>Gives the next power of two after &lt;code&gt;val&lt;/code&gt;. &lt;code&gt;T&lt;/code&gt; can be any built-in numerical type.</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; の後に次の2のべき乗を与えます。 &lt;code&gt;T&lt;/code&gt; は、任意の組み込み数値型にすることができます。</target>
        </trans-unit>
        <trans-unit id="5dcd127d912205c801dfa9fd55aab21bc7540488" translate="yes" xml:space="preserve">
          <source>Gives the precision for numeric conversions. If the precision is a &lt;b&gt;*&lt;/b&gt;, an additional argument of type &lt;b&gt;int&lt;/b&gt;, preceding the actual argument, is taken as the precision. If it is negative, it is as if there was no</source>
          <target state="translated">数値変換の精度を提供します。精度が&lt;b&gt;*の&lt;/b&gt;場合、実際の引数の前にある&lt;b&gt;int&lt;/b&gt;型の追加の引数が精度として使用されます。負の場合、それはなかったかのようです</target>
        </trans-unit>
        <trans-unit id="066636e1bed1369dff6efcd3fab1c1e8776d7710" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from</source>
          <target state="translated">から&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;を加算または減算した結果を提供します</target>
        </trans-unit>
        <trans-unit id="13fd9f69f64522f3bd20d1184529d631b3677431" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;, as well as assigning the result to this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">加算または減算の結果得られる&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; を&lt;/a&gt;このから&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;、ならびにこれに結果代入&lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f3c64b6298caea8c356268035bf6bb2213d1e63d" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;から&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;を加算または減算した結果を返します。</target>
        </trans-unit>
        <trans-unit id="a1405f5ebc75767bb0c5bcf744b2d2f96a676122" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;, as well as assigning the result to this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;に&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;を加算または減算した結果、およびこのSysTimeに結果を割り当てた結果を&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="aea621df7ee3b5185f92bf03dc43838e74f11ab8" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;から&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;を加算または減算した結果を提供します。</target>
        </trans-unit>
        <trans-unit id="3d5dfde7603919eee6582396d3e52686e64f60c3" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;, as well as assigning the result to this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt;に&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;を加算または減算した結果と、この&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; に&lt;/a&gt;結果を割り当てた結果を返します。</target>
        </trans-unit>
        <trans-unit id="c1b9fd1a6e616c022dd85e5f596721b33e55dad9" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この&lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt;から&lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt;を加算または減算した結果を提供します。</target>
        </trans-unit>
        <trans-unit id="d7bb55c3ac43c11992ce982a465028a297070c37" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a duration from this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;, as well as assigning the result to this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;に期間を加算または減算した結果、およびこのDateTimeに結果を割り当てた結果を&lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="b010645431226eb0d475a6508504f6360118e2aa" translate="yes" xml:space="preserve">
          <source>Gives the string &lt;code&gt;&quot;Nullable.null&quot;&lt;/code&gt; if &lt;code&gt;isNull&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. Otherwise, the result is equivalent to calling &lt;a href=&quot;std_format#formattedWrite&quot;&gt;&lt;code&gt;std.format.formattedWrite&lt;/code&gt;&lt;/a&gt; on the underlying value.</source>
          <target state="translated">&lt;code&gt;isNull&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合、文字列 &lt;code&gt;&quot;Nullable.null&quot;&lt;/code&gt; ます。それ以外の場合、結果は、基になる値で&lt;a href=&quot;std_format#formattedWrite&quot;&gt; &lt;code&gt;std.format.formattedWrite&lt;/code&gt; &lt;/a&gt;を呼び出すのと同じです。</target>
        </trans-unit>
        <trans-unit id="ee3ba1f4d58b51dacaf77da9e736c2398dd52211" translate="yes" xml:space="preserve">
          <source>Giving better error messages inside generic code than the sometimes hard to follow compiler ones.</source>
          <target state="translated">一般的なコードの中では、コンパイラが追いかけるのが難しい場合がありますが、それよりも優れたエラーメッセージを提供します。</target>
        </trans-unit>
        <trans-unit id="fe40132df9803a579f2616316fd9f36e8b76b6f5" translate="yes" xml:space="preserve">
          <source>Glagolitic</source>
          <target state="translated">Glagolitic</target>
        </trans-unit>
        <trans-unit id="52d16b8e3607d3a956a90dad397b270e88b2a626" translate="yes" xml:space="preserve">
          <source>Glibc C runtime</source>
          <target state="translated">Glibc C ランタイム</target>
        </trans-unit>
        <trans-unit id="5f1184f7df96c5928092ad9c6b550699bf887826" translate="yes" xml:space="preserve">
          <source>Global</source>
          <target state="translated">Global</target>
        </trans-unit>
        <trans-unit id="ae4f56ae4da16df74b3d2aeca8b4352281e7be45" translate="yes" xml:space="preserve">
          <source>Global Functions</source>
          <target state="translated">グローバル機能</target>
        </trans-unit>
        <trans-unit id="60d510ca3fec034b096ecb101e79c44baa3bcfa4" translate="yes" xml:space="preserve">
          <source>Global and Static Initializers</source>
          <target state="translated">グローバルイニシャライザとスタティックイニシャライザ</target>
        </trans-unit>
        <trans-unit id="ad8992e0e77b510d8dd8c9f31b8493285307157f" translate="yes" xml:space="preserve">
          <source>Global names</source>
          <target state="translated">グローバル名</target>
        </trans-unit>
        <trans-unit id="fb160cab6ebf08ae16224b7387fbe010ff67af79" translate="yes" xml:space="preserve">
          <source>Global random number generator used by various functions in this module whenever no generator is specified. It is allocated per-thread and initialized to an unpredictable value for each thread.</source>
          <target state="translated">ジェネレータが指定されていない場合は常に、このモジュールの様々な関数で使用されるグローバル乱数発生器。スレッドごとに割り当てられ、スレッドごとに予測不可能な値に初期化されます。</target>
        </trans-unit>
        <trans-unit id="359a7909d420e528181333df942be655d355c0d2" translate="yes" xml:space="preserve">
          <source>Global regex, repeat over the whole input.</source>
          <target state="translated">グローバル正規表現、入力全体を繰り返します。</target>
        </trans-unit>
        <trans-unit id="9d8204544b72aac8944f7aa50f34d5f2b83ebda7" translate="yes" xml:space="preserve">
          <source>Global status of the CTFE engine. Mostly used for performance diagnostics</source>
          <target state="translated">CTFEエンジンのグローバルな状況。主に性能診断に使用</target>
        </trans-unit>
        <trans-unit id="3bb8f4a4ce9e8fc53902a34f5711af6100354847" translate="yes" xml:space="preserve">
          <source>Global variables.</source>
          <target state="translated">グローバル変数。</target>
        </trans-unit>
        <trans-unit id="322346956002b43d1272ba3ca4fad36e87acf31f" translate="yes" xml:space="preserve">
          <source>Go through the variables in function fd that are to be allocated in a closure, and set the .offset fields for those variables to their positions relative to the start of the closure instance. Also turns off nrvo for closure variables.</source>
          <target state="translated">クロージャ内で割り当てられる関数 fd の変数を調べ、それらの変数の .offset フィールドを、クロージャ・インスタンスの開始位置からの相対的な位置に設定します。また、クロージャ変数の nrvo もオフにします。</target>
        </trans-unit>
        <trans-unit id="83644e2182412c095ed367b8519c41f7f1a72b2f" translate="yes" xml:space="preserve">
          <source>Good error handling code tends to clutter up what otherwise would be a neat and clean looking implementation.</source>
          <target state="translated">優れたエラー処理コードは、そうでなければすっきりとした見た目の実装になってしまうものを乱雑にしがちです。</target>
        </trans-unit>
        <trans-unit id="a4cc20ddddd5df91dbeeeac20e28069cdc6d35d5" translate="yes" xml:space="preserve">
          <source>Gothic</source>
          <target state="translated">Gothic</target>
        </trans-unit>
        <trans-unit id="523bd87e510be4584eb678bda56047b4e81b4e41" translate="yes" xml:space="preserve">
          <source>Goto Statement</source>
          <target state="translated">後藤声明</target>
        </trans-unit>
        <trans-unit id="d153d2afa0d10e789b42decd9c86f4c6ba7c4b32" translate="yes" xml:space="preserve">
          <source>GotoCaseStatements &lt;strong id=&quot;gotoCases&quot;&gt;gotoCases&lt;/strong&gt;;</source>
          <target state="translated">GotoCaseStatements &lt;strong id=&quot;gotoCases&quot;&gt;gotoCases&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="2d75a452fb197b862328ddf89077f60c5411007e" translate="yes" xml:space="preserve">
          <source>GotoStatement</source>
          <target state="translated">GotoStatement</target>
        </trans-unit>
        <trans-unit id="469b09861974ba8cba6608f5b50f5a4378e847aa" translate="yes" xml:space="preserve">
          <source>GotoStatements* &lt;strong id=&quot;gotos&quot;&gt;gotos&lt;/strong&gt;;</source>
          <target state="translated">GotoStatements * &lt;strong id=&quot;gotos&quot;&gt;gotos&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="b1b76e26ed39195055923abbd6da5da5869145b4" translate="yes" xml:space="preserve">
          <source>Gotos with forward references</source>
          <target state="translated">前方参照のゴト</target>
        </trans-unit>
        <trans-unit id="dd17342cb47b948d64f169d73cfeec3f8b3e3f31" translate="yes" xml:space="preserve">
          <source>Grammar</source>
          <target state="translated">Grammar</target>
        </trans-unit>
        <trans-unit id="40e6976321b98f0050106aca23fe0094f3e12aec" translate="yes" xml:space="preserve">
          <source>Grapheme &lt;strong id=&quot;decodeGrapheme&quot;&gt;decodeGrapheme&lt;/strong&gt;(Input)(ref Input inp)</source>
          <target state="translated">書記素&lt;strong id=&quot;decodeGrapheme&quot;&gt;decodeGrapheme&lt;/strong&gt;（入力）（ref入力inp）</target>
        </trans-unit>
        <trans-unit id="09e21aefbc5d72becfb6e61403ad83558925c509" translate="yes" xml:space="preserve">
          <source>Grapheme cluster length in &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Code%20point&quot;&gt;コードポイント&lt;/a&gt;での書記素クラスタの長さ。</target>
        </trans-unit>
        <trans-unit id="85a58af54a6759d4a9d1a773cb4f960185f26fe4" translate="yes" xml:space="preserve">
          <source>Grapheme_Base</source>
          <target state="translated">Grapheme_Base</target>
        </trans-unit>
        <trans-unit id="9aa96ceeca035f99f4979af4785877395b3fcca9" translate="yes" xml:space="preserve">
          <source>Grapheme_Extend</source>
          <target state="translated">Grapheme_Extend</target>
        </trans-unit>
        <trans-unit id="2299a70876b7b20196c0e232824b6e303cf0f817" translate="yes" xml:space="preserve">
          <source>Grapheme_Link</source>
          <target state="translated">Grapheme_Link</target>
        </trans-unit>
        <trans-unit id="59d5f5b13f13f6d5e8e88a5a92e137f7d64b2954" translate="yes" xml:space="preserve">
          <source>Greek</source>
          <target state="translated">Greek</target>
        </trans-unit>
        <trans-unit id="305ccd272b16a96e13db1c4faa38b1913caf51d8" translate="yes" xml:space="preserve">
          <source>Greek Extended</source>
          <target state="translated">ギリシャ語の拡張</target>
        </trans-unit>
        <trans-unit id="63e0451063c60d5f6eae102313ee1b6d993a1f76" translate="yes" xml:space="preserve">
          <source>Greek and Coptic</source>
          <target state="translated">ギリシア語とコプト語</target>
        </trans-unit>
        <trans-unit id="73fb2dd5cc2643e9f02bc351410b98713e0c50c9" translate="yes" xml:space="preserve">
          <source>Group separator</source>
          <target state="translated">グループセパレータ</target>
        </trans-unit>
        <trans-unit id="10986e5fcbdd40c81d3e51dfc3ad691df9a6347c" translate="yes" xml:space="preserve">
          <source>Group!(pred, Range) &lt;strong id=&quot;group&quot;&gt;group&lt;/strong&gt;(alias pred = &quot;a == b&quot;, Range)(Range r);</source>
          <target state="translated">Group！（pred、Range）&lt;strong id=&quot;group&quot;&gt;group&lt;/strong&gt;（エイリアスpred = &quot;a == b&quot;、Range）（Range r）;</target>
        </trans-unit>
        <trans-unit id="83af1301254c2810b776d48cab533ffdca19f557" translate="yes" xml:space="preserve">
          <source>Groups consecutively equivalent elements into a single tuple of the element and the number of its repetitions.</source>
          <target state="translated">連続して等価な要素を、その要素とその繰り返し数の単一タプルにグループ化します。</target>
        </trans-unit>
        <trans-unit id="afb8bcba7055a53eb0c5db950f6c2af39388fdf2" translate="yes" xml:space="preserve">
          <source>Grows &lt;code&gt;array&lt;/code&gt; by appending &lt;code&gt;delta&lt;/code&gt; more elements. The needed memory is allocated using &lt;code&gt;alloc&lt;/code&gt;. The extra elements added are either default- initialized, filled with copies of &lt;code&gt;init&lt;/code&gt;, or initialized with values fetched from &lt;code&gt;range&lt;/code&gt;.</source>
          <target state="translated">育つ &lt;code&gt;array&lt;/code&gt; 付加することによって、 &lt;code&gt;delta&lt;/code&gt; より多くの要素を。必要なメモリは、 &lt;code&gt;alloc&lt;/code&gt; を使用して割り当てられます。追加された追加の要素は、デフォルトで初期化されるか、 &lt;code&gt;init&lt;/code&gt; のコピーで満たされるか、または &lt;code&gt;range&lt;/code&gt; からフェッチされた値で初期化されます。</target>
        </trans-unit>
        <trans-unit id="e03f30a2f53aecda689ec68c63bc0d88b73542a6" translate="yes" xml:space="preserve">
          <source>Grows &lt;code&gt;array&lt;/code&gt; by appending &lt;code&gt;delta&lt;/code&gt; more elements. The needed memory is allocated using the same allocator that was used for the array type. The extra elements added are either default-initialized, filled with copies of &lt;code&gt;init&lt;/code&gt;, or initialized with values fetched from &lt;code&gt;range&lt;/code&gt;.</source>
          <target state="translated">育つ &lt;code&gt;array&lt;/code&gt; 付加することによって、 &lt;code&gt;delta&lt;/code&gt; より多くの要素を。必要なメモリは、配列型に使用されたのと同じアロケータを使用して割り当てられます。追加された追加の要素は、デフォルトで初期化されるか、 &lt;code&gt;init&lt;/code&gt; のコピーで満たされるか、 &lt;code&gt;range&lt;/code&gt; からフェッチされた値で初期化されます。</target>
        </trans-unit>
        <trans-unit id="77afda6ffc95cc0f06adb904e94cef0fc69add7d" translate="yes" xml:space="preserve">
          <source>Guaranteed &amp;Omicron;(&lt;code&gt;abs(length - newLength)&lt;/code&gt;) if &lt;code&gt;capacity &amp;gt;= newLength&lt;/code&gt;. If &lt;code&gt;capacity &amp;lt; newLength&lt;/code&gt; the worst case is &amp;Omicron;(&lt;code&gt;newLength&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;capacity &amp;gt;= newLength&lt;/code&gt; 場合、Guaranteed（ &lt;code&gt;abs(length - newLength)&lt;/code&gt; ）が保証されます。場合は &lt;code&gt;capacity &amp;lt; newLength&lt;/code&gt; 最悪の場合は&amp;Omicron;（ある &lt;code&gt;newLength&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="929a28d261428029e61c0f81c6161fd71ba0b2fe" translate="yes" xml:space="preserve">
          <source>Guides</source>
          <target state="translated">Guides</target>
        </trans-unit>
        <trans-unit id="35776951606a73d6ff2bfb1c43d6ba2de2721cad" translate="yes" xml:space="preserve">
          <source>Guillaume Chatelet</source>
          <target state="translated">ギヨーム・シャトレ</target>
        </trans-unit>
        <trans-unit id="971317803587830757efb436fa41eeb1d9292828" translate="yes" xml:space="preserve">
          <source>Guillaume Chatelet Manu Evans</source>
          <target state="translated">ギョーム・シャトレ・マヌ・エヴァンス</target>
        </trans-unit>
        <trans-unit id="c06c55a5bcd005bf56c5234eb953099ffc1de3f1" translate="yes" xml:space="preserve">
          <source>Gujarati</source>
          <target state="translated">Gujarati</target>
        </trans-unit>
        <trans-unit id="265e1c23debf982bad1eb28dbf1fb86580b82eab" translate="yes" xml:space="preserve">
          <source>Gurmukhi</source>
          <target state="translated">Gurmukhi</target>
        </trans-unit>
        <trans-unit id="72c5d728b8c5e13d38cf050220cb41c1803704d1" translate="yes" xml:space="preserve">
          <source>H &lt;code&gt;m&lt;/code&gt;</source>
          <target state="translated">H &lt;code&gt;m&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d44602ce53397cc7e3837311abb7db1d03042b84" translate="yes" xml:space="preserve">
          <source>H. S. Teoh's &lt;a href=&quot;http://wiki.dlang.org/Component_programming_with_ranges&quot;&gt;tutorial on component programming with ranges&lt;/a&gt; for a real-world showcase of the influence of range-based programming on complex algorithms.</source>
          <target state="translated">範囲ベースのプログラミングが複雑なアルゴリズムに及ぼす影響の実際のショーケース用の&lt;a href=&quot;http://wiki.dlang.org/Component_programming_with_ranges&quot;&gt;範囲&lt;/a&gt;を使用したコンポーネントプログラミングに関する HS Teohのチュートリアル。</target>
        </trans-unit>
        <trans-unit id="bbe1ea5931e3b073b2c3409ef7882568b8096068" translate="yes" xml:space="preserve">
          <source>H. S. Teoh's &lt;a href=&quot;https://wiki.dlang.org/Component_programming_with_ranges&quot;&gt;tutorial on component programming with ranges&lt;/a&gt; for a real-world showcase of the influence of range-based programming on complex algorithms.</source>
          <target state="translated">複雑なアルゴリズムに対する範囲ベースのプログラミングの影響を実際に紹介するための、&lt;a href=&quot;https://wiki.dlang.org/Component_programming_with_ranges&quot;&gt;範囲&lt;/a&gt;を使用したコンポーネントプログラミングに関するHSTeohのチュートリアル。</target>
        </trans-unit>
        <trans-unit id="7fa36c2d12dc8308dd96737ca9539591241ccb57" translate="yes" xml:space="preserve">
          <source>HTML can be embedded into the documentation comments, and it will be passed through to the HTML output unchanged. However, since it is not necessarily true that HTML will be the desired output format of the embedded documentation comment extractor, it is best to avoid using it where practical.</source>
          <target state="translated">HTMLをドキュメントコメントに埋め込むことができ、それは変更されずにHTML出力に渡されます。しかし、HTMLが埋め込まれたドキュメントコメント抽出器の望ましい出力形式になるとは限りませんので、実用的な場合には使用しない方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="f40b27d6b8b9a4fc3827264c1da16a04ecf4d094" translate="yes" xml:space="preserve">
          <source>HTTP</source>
          <target state="translated">HTTP</target>
        </trans-unit>
        <trans-unit id="0481530df63832f72dfdebbe0c7a51d57e32da26" translate="yes" xml:space="preserve">
          <source>HTTP &lt;code&gt;conn&lt;/code&gt;</source>
          <target state="translated">HTTP &lt;code&gt;conn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca83e4b247db9f9a4bf080067c192c5cb65a0d61" translate="yes" xml:space="preserve">
          <source>HTTP &lt;strong id=&quot;dup&quot;&gt;dup&lt;/strong&gt;();</source>
          <target state="translated">HTTP &lt;strong id=&quot;dup&quot;&gt;dup&lt;/strong&gt;（）;</target>
        </trans-unit>
        <trans-unit id="e4e09a7d12cb155ba460134c8bdd1f1479d801ce" translate="yes" xml:space="preserve">
          <source>HTTP POST method</source>
          <target state="translated">HTTTP POST方式</target>
        </trans-unit>
        <trans-unit id="923988ff39d0e3042c9df0f259d1de84a01fde11" translate="yes" xml:space="preserve">
          <source>HTTP PUT</source>
          <target state="translated">HTTP PUT</target>
        </trans-unit>
        <trans-unit id="cc2478137d7b71e72935b2fddc027880593e756f" translate="yes" xml:space="preserve">
          <source>HTTP client functionality.</source>
          <target state="translated">HTTPクライアント機能。</target>
        </trans-unit>
        <trans-unit id="827e4a67a71c875b43e732a905d1fd8e7200d6d6" translate="yes" xml:space="preserve">
          <source>HTTP connect request.</source>
          <target state="translated">HTTP接続要求。</target>
        </trans-unit>
        <trans-unit id="51449b9a0615713cbd19f5f01e23d5f58e4358b0" translate="yes" xml:space="preserve">
          <source>HTTP connection to use</source>
          <target state="translated">使用するためのHTTP接続</target>
        </trans-unit>
        <trans-unit id="797634e3b267b6d81699bf16ac8a0f81dc1a1ba6" translate="yes" xml:space="preserve">
          <source>HTTP connection to use  The template parameter &lt;code&gt;T&lt;/code&gt; specifies the type to return. Possible values are &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;ubyte&lt;/code&gt; to return &lt;code&gt;char[]&lt;/code&gt; or &lt;code&gt;ubyte[]&lt;/code&gt;.</source>
          <target state="translated">使用するHTTP接続テンプレートパラメータ &lt;code&gt;T&lt;/code&gt; は、返すタイプを指定します。可能な値は &lt;code&gt;char&lt;/code&gt; および &lt;code&gt;ubyte&lt;/code&gt; で、 &lt;code&gt;char[]&lt;/code&gt; または &lt;code&gt;ubyte[]&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="e5b69d980b7b8a0f8d5057989430d112ecf22206" translate="yes" xml:space="preserve">
          <source>HTTP method used.</source>
          <target state="translated">使用したHTTPメソッド。</target>
        </trans-unit>
        <trans-unit id="bedfc3b8a98f74436dfffc470905a4cb727d6eb4" translate="yes" xml:space="preserve">
          <source>HTTP options request.</source>
          <target state="translated">HTTPオプションのリクエスト。</target>
        </trans-unit>
        <trans-unit id="eca27a5fb0f79404f93ba2b2ff7621d850fa94c3" translate="yes" xml:space="preserve">
          <source>HTTP patch content.</source>
          <target state="translated">HTTPパッチの内容。</target>
        </trans-unit>
        <trans-unit id="0f24bcb381b514379fb794061233a0fac483e67d" translate="yes" xml:space="preserve">
          <source>HTTP post content.</source>
          <target state="translated">HTTPポストの内容です。</target>
        </trans-unit>
        <trans-unit id="fd473bd4cc525d8634b2d06223e94be806e9169e" translate="yes" xml:space="preserve">
          <source>HTTP request, for odd commands like DELETE, TRACE and others</source>
          <target state="translated">HTTP リクエスト、DELETE や TRACE などの奇妙なコマンドのための</target>
        </trans-unit>
        <trans-unit id="7c360b79abb627a8a4c93e546c995b917aedbbb1" translate="yes" xml:space="preserve">
          <source>HTTP status line code e.g. 200.</source>
          <target state="translated">HTTP ステータスのラインコード 例:200.</target>
        </trans-unit>
        <trans-unit id="7fb8b94d5f23dd0fd12704704bd5724a9a81dd11" translate="yes" xml:space="preserve">
          <source>HTTP status line ie. the first line returned in an HTTP response.</source>
          <target state="translated">HTTP ステータス行、つまり HTTP レスポンスで返される最初の行。</target>
        </trans-unit>
        <trans-unit id="5c1ee2091ce3bea9e5a23e0562f6b6fd7953de16" translate="yes" xml:space="preserve">
          <source>HTTP status line of last response. One call to perform may result in several requests because of redirection.</source>
          <target state="translated">最後のレスポンスのHTTPステータス行。1回の呼び出しで実行すると、リダイレクトのために複数のリクエストが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="45f917922bd09e11086c274630d2415137d36f0f" translate="yes" xml:space="preserve">
          <source>HTTP status line reason string.</source>
          <target state="translated">HTTP ステータス行の理由の文字列。</target>
        </trans-unit>
        <trans-unit id="1909e6b2261783a8d317d6f55a66a50ec6cfafb1" translate="yes" xml:space="preserve">
          <source>HTTP trace request.</source>
          <target state="translated">HTTP トレース要求。</target>
        </trans-unit>
        <trans-unit id="52f8dbc2c259a9731d9751db65ced2bb8937f72a" translate="yes" xml:space="preserve">
          <source>HTTP.TimeCond &lt;code&gt;cond&lt;/code&gt;</source>
          <target state="translated">HTTP.TimeCond &lt;code&gt;cond&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a59dd0563a7efe56dbe888a8e6b63f08d0ec7b1a" translate="yes" xml:space="preserve">
          <source>HTTP/FTP delete content.</source>
          <target state="translated">HTTP/FTPでコンテンツを削除します。</target>
        </trans-unit>
        <trans-unit id="c911addb5a09d460fe739f0ee6699cd1115b2ceb" translate="yes" xml:space="preserve">
          <source>HTTP/FTP download to local file system.</source>
          <target state="translated">ローカルファイルシステムへのHTTP/FTPダウンロード。</target>
        </trans-unit>
        <trans-unit id="444e75970e6f6b8a13c7660b530b8789eb9d1688" translate="yes" xml:space="preserve">
          <source>HTTP/FTP fetch content as a range of chunks asynchronously.</source>
          <target state="translated">HTTP/FTP は、コンテンツをチャンクの範囲として非同期にフェッチします。</target>
        </trans-unit>
        <trans-unit id="067f2a38c032292745289e6d568747297c1eb36d" translate="yes" xml:space="preserve">
          <source>HTTP/FTP fetch content as a range of chunks.</source>
          <target state="translated">HTTP/FTP は、チャンクの範囲としてコンテンツをフェッチします。</target>
        </trans-unit>
        <trans-unit id="ba7a6201d2a706377c412c319526144deec7201e" translate="yes" xml:space="preserve">
          <source>HTTP/FTP fetch content as a range of lines asynchronously.</source>
          <target state="translated">HTTP/FTP は、コンテンツを非同期的に行の範囲としてフェッチします。</target>
        </trans-unit>
        <trans-unit id="a30ab80f3f96882837554330daf0f4a6aaa048ff" translate="yes" xml:space="preserve">
          <source>HTTP/FTP fetch content as a range of lines.</source>
          <target state="translated">HTTP/FTP は、行の範囲としてコンテンツをフェッチします。</target>
        </trans-unit>
        <trans-unit id="0a0a651b4d9a70a2c11401ce60fa08020ea7c52c" translate="yes" xml:space="preserve">
          <source>HTTP/FTP get content.</source>
          <target state="translated">HTTP/FTPでコンテンツを取得します。</target>
        </trans-unit>
        <trans-unit id="a18566ddab985dc1d64ecd1c3e55c7fe0283f6cd" translate="yes" xml:space="preserve">
          <source>HTTP/FTP put content.</source>
          <target state="translated">HTTP/FTPでコンテンツを入れています。</target>
        </trans-unit>
        <trans-unit id="fd41ab93c5537d58968dc08902626f4aedcfc790" translate="yes" xml:space="preserve">
          <source>Halfwidth and Fullwidth Forms</source>
          <target state="translated">半角と全角のフォーム</target>
        </trans-unit>
        <trans-unit id="15710324ddc14a3ddc719e414d041bb782d93764" translate="yes" xml:space="preserve">
          <source>Han</source>
          <target state="translated">Han</target>
        </trans-unit>
        <trans-unit id="495fba644d4dd3d28a3df2c5e262bc0aa344bdc1" translate="yes" xml:space="preserve">
          <source>Handle and transcode between various text encodings.</source>
          <target state="translated">様々なテキストエンコーディング間の処理とトランスコードを行います。</target>
        </trans-unit>
        <trans-unit id="4cae35b945ed013183aeec759fb173f2b5e74ee5" translate="yes" xml:space="preserve">
          <source>Handle enums.</source>
          <target state="translated">enumsを処理します。</target>
        </trans-unit>
        <trans-unit id="70c0fd2c64cbbc7d9a73e18bc0fd02b46b142b9f" translate="yes" xml:space="preserve">
          <source>Handle exceptions thrown from range primitives.</source>
          <target state="translated">範囲プリミティブからスローされた例外を処理します。</target>
        </trans-unit>
        <trans-unit id="ed3da861f4c68bd404277c3815bb4277903ee0c7" translate="yes" xml:space="preserve">
          <source>Handle the postblit call on lvalue, or the move of rvalue.</source>
          <target state="translated">lvalueのポストブリット呼び出し、またはrvalueの移動を処理します。</target>
        </trans-unit>
        <trans-unit id="e61477ad33d711243071181209298dcaac99b754" translate="yes" xml:space="preserve">
          <source>Handle to the system-specific semaphore.</source>
          <target state="translated">システム固有のセマフォへのハンドル。</target>
        </trans-unit>
        <trans-unit id="362f233bfd36bbe9ffba21ece507104cececa24e" translate="yes" xml:space="preserve">
          <source>Handlers</source>
          <target state="translated">Handlers</target>
        </trans-unit>
        <trans-unit id="bd7d4b95fcd93ad906141f781368bc43c7c7f10a" translate="yes" xml:space="preserve">
          <source>Hangul</source>
          <target state="translated">Hangul</target>
        </trans-unit>
        <trans-unit id="46a74e921ed0b81734815d203a76d63ac9b445e2" translate="yes" xml:space="preserve">
          <source>Hangul Compatibility Jamo</source>
          <target state="translated">ハングル互換性ジャモ</target>
        </trans-unit>
        <trans-unit id="6e435e03b7ff7b49d783dd12f4139eb337e88129" translate="yes" xml:space="preserve">
          <source>Hangul Jamo</source>
          <target state="translated">ハングルジャモ</target>
        </trans-unit>
        <trans-unit id="1af30ae437546a0c8f4e8c904b38e9e32c465cd5" translate="yes" xml:space="preserve">
          <source>Hangul Jamo Extended-A</source>
          <target state="translated">ハングル Jamo Extended-A</target>
        </trans-unit>
        <trans-unit id="7f76ea3a5ca65b3f7be6271028b86fb4c24ad5b4" translate="yes" xml:space="preserve">
          <source>Hangul Jamo Extended-B</source>
          <target state="translated">ハングル Jamo Extended-B</target>
        </trans-unit>
        <trans-unit id="a3c09f1beeeb5e6518d7a5aa130f9229a5bab1c8" translate="yes" xml:space="preserve">
          <source>Hangul Syllables</source>
          <target state="translated">ハングル音節</target>
        </trans-unit>
        <trans-unit id="9649db5db6338c7bb1ab5215b20988c58817b67a" translate="yes" xml:space="preserve">
          <source>Hangul syllables are not covered by this function. See &lt;code&gt;composeJamo&lt;/code&gt; below.</source>
          <target state="translated">ハングル音節はこの機能の対象外です。以下の &lt;code&gt;composeJamo&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="ed413af43425a39818253cc0c5de7394d4a39735" translate="yes" xml:space="preserve">
          <source>Hanunoo</source>
          <target state="translated">Hanunoo</target>
        </trans-unit>
        <trans-unit id="e938944cea2d9cc40e1f9955e4a0cfe8a2544308" translate="yes" xml:space="preserve">
          <source>Hardware Control</source>
          <target state="translated">ハードウェア制御</target>
        </trans-unit>
        <trans-unit id="624a7b201d0ea02f7b27a09976e5469ea739a9e3" translate="yes" xml:space="preserve">
          <source>Has the same meaning as outside of a character class.</source>
          <target state="translated">文字クラスの外と同じ意味を持つ。</target>
        </trans-unit>
        <trans-unit id="ff69afc8afb157be53fcca5d806ead0afca8f54a" translate="yes" xml:space="preserve">
          <source>Hash &lt;strong id=&quot;makeDigest&quot;&gt;makeDigest&lt;/strong&gt;(Hash)();</source>
          <target state="translated">ハッシュ&lt;strong id=&quot;makeDigest&quot;&gt;makeDigest&lt;/strong&gt;（Hash）（）;</target>
        </trans-unit>
        <trans-unit id="512530e2001855653aa805d74cb64a05638ad3fd" translate="yes" xml:space="preserve">
          <source>Hash options.</source>
          <target state="translated">ハッシュオプション。</target>
        </trans-unit>
        <trans-unit id="82c3b55a6e6190b4ea897a708e89b49564008ef7" translate="yes" xml:space="preserve">
          <source>Hash syntax for json objects.</source>
          <target state="translated">json オブジェクトのハッシュ構文。</target>
        </trans-unit>
        <trans-unit id="8d05adeedcb7aa54cc03e4f260b3e38d1479ae1c" translate="yes" xml:space="preserve">
          <source>HashTab container for internal usage.</source>
          <target state="translated">内部で使用するためのHashTabコンテナ。</target>
        </trans-unit>
        <trans-unit id="201cd54dff7c562fa04665ce3ec7f389323b7356" translate="yes" xml:space="preserve">
          <source>Have some variables that are maybescopes that were assigned values from other maybescope variables. Now that semantic analysis of the function is complete, we can finalize this by turning off maybescope for array elements that cannot be scope.</source>
          <target state="translated">他のmaybescope変数から値を代入したmaybescopesである変数をいくつか持っています。これで関数のセマンティック解析が完了したので、スコープできない配列要素のmaybescopeをオフにすることで最終的に確定です。</target>
        </trans-unit>
        <trans-unit id="dea56ebbd4737b0cd9262ab0c819e3683d0b5416" translate="yes" xml:space="preserve">
          <source>Having unmatched parentheses can hose the output of Ddoc, as the macros depend on properly nested parentheses. This function replaces all ( with ( and ) with ) to preserve text literally. This also means macros in the text won't be expanded.</source>
          <target state="translated">マッチしない括弧を持つと、マクロは適切にネストされた括弧に依存するため、Ddoc の出力を阻害する可能性があります。この関数は、文字通りテキストを保持するために、すべての(と()を)に置き換えます。これは、テキスト内のマクロが展開されないことも意味します。</target>
        </trans-unit>
        <trans-unit id="71653e5271aa72abad98ba52f8927b0be428b96b" translate="yes" xml:space="preserve">
          <source>Haystack &lt;code&gt;haystack&lt;/code&gt;</source>
          <target state="translated">干し草の &lt;code&gt;haystack&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e0403de1effb4e88849c3d2d079f299e89f093ed" translate="yes" xml:space="preserve">
          <source>HeaderFormat &lt;code&gt;header&lt;/code&gt;</source>
          <target state="translated">HeaderFormat &lt;code&gt;header&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c97d4c3dede14ee24bc42018c52f19917fd481c9" translate="yes" xml:space="preserve">
          <source>Headings</source>
          <target state="translated">Headings</target>
        </trans-unit>
        <trans-unit id="348d00693e12bc983bd092677b90434b5a4d869e" translate="yes" xml:space="preserve">
          <source>Hebrew</source>
          <target state="translated">Hebrew</target>
        </trans-unit>
        <trans-unit id="fbea2ec13adcf999e380e13a429a4e17dc3d8090" translate="yes" xml:space="preserve">
          <source>Help Information Generation</source>
          <target state="translated">ヘルプ情報生成</target>
        </trans-unit>
        <trans-unit id="1e7eebdb08c9dbf27c7668e2badd51e667707d3c" translate="yes" xml:space="preserve">
          <source>Helper</source>
          <target state="translated">Helper</target>
        </trans-unit>
        <trans-unit id="5e31a530e83afec402c4c09898e79e56b473dc7d" translate="yes" xml:space="preserve">
          <source>Helper for NewExp Create a string literal consisting of 'value' duplicated 'dim' times.</source>
          <target state="translated">NewExpのヘルパー 'value'が'dim'倍に複製された'value'からなる文字列リテラルを作成します。</target>
        </trans-unit>
        <trans-unit id="766c386647e8e48a9fcd435724f1d350167f7ed5" translate="yes" xml:space="preserve">
          <source>Helper for NewExp Create an array literal consisting of 'elem' duplicated 'dim' times.</source>
          <target state="translated">NewExpのヘルパー 'elem' を 'dim' 倍に複製した 'elem' からなる配列リテラルを作成します。</target>
        </trans-unit>
        <trans-unit id="c02c79263e4ed8c5595da2dd0c63a6d49edcd0eb" translate="yes" xml:space="preserve">
          <source>Helper function for &lt;code&gt;getRightThis()&lt;/code&gt;. Gets &lt;code&gt;this&lt;/code&gt; of the next outer aggregate.</source>
          <target state="translated">&lt;code&gt;getRightThis()&lt;/code&gt; のヘルパー関数。次の外部集計の &lt;code&gt;this&lt;/code&gt; を取得します。</target>
        </trans-unit>
        <trans-unit id="467531459771317152c9703e3f120447d81f80b5" translate="yes" xml:space="preserve">
          <source>Helper function for easy error propagation. If error occurs, returns ErrorExp. Otherwise returns NULL.</source>
          <target state="translated">エラー伝播を容易にするためのヘルパー関数。エラーが発生した場合は ErrorExp を返します。それ以外の場合はNULLを返します。</target>
        </trans-unit>
        <trans-unit id="3576c823fa70ffbb40f146b4e65274f6dc08a676" translate="yes" xml:space="preserve">
          <source>Helper function for the expansion of manifest constant.</source>
          <target state="translated">顕在定数の展開のためのヘルパー関数。</target>
        </trans-unit>
        <trans-unit id="f45a0f048cca01c298f3e28147b97707c3bec7c9" translate="yes" xml:space="preserve">
          <source>Helper function that returns a &lt;code&gt;FormatSpec&lt;/code&gt; for a single specifier given in &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fmt&lt;/code&gt; で指定された単一の指定子の &lt;code&gt;FormatSpec&lt;/code&gt; を返すヘルパー関数。</target>
        </trans-unit>
        <trans-unit id="10a93d4497e85393cb5499fb73d96c729ebc3ddb" translate="yes" xml:space="preserve">
          <source>Helper function that returns a complex number with the specified real and imaginary parts.</source>
          <target state="translated">指定した実部と虚部を持つ複素数を返すヘルパー関数です。</target>
        </trans-unit>
        <trans-unit id="b43936919328317134bad177cd4f68d6f84246ac" translate="yes" xml:space="preserve">
          <source>Helper function to turn operator into template argument list</source>
          <target state="translated">演算子をテンプレートの引数リストにするヘルパー関数</target>
        </trans-unit>
        <trans-unit id="934835a36e88b263f02948e4dbd8c5dd04401bc0" translate="yes" xml:space="preserve">
          <source>Helper functions</source>
          <target state="translated">ヘルパー機能</target>
        </trans-unit>
        <trans-unit id="3c9b3433e6f225e4ae00ef2041d44d91bfbf7113" translate="yes" xml:space="preserve">
          <source>Helpers</source>
          <target state="translated">Helpers</target>
        </trans-unit>
        <trans-unit id="736e7e325114a8cd6d30377592f7bf25b8688457" translate="yes" xml:space="preserve">
          <source>Hence, the following errors can be statically detected:</source>
          <target state="translated">そのため、以下のようなエラーを静的に検出することができます。</target>
        </trans-unit>
        <trans-unit id="e9e62a53ff4cde1bc51ffbf3814a1010c7743286" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;o&lt;/code&gt; supplies the</source>
          <target state="translated">ここで &lt;code&gt;o&lt;/code&gt; は</target>
        </trans-unit>
        <trans-unit id="1ede5efd1d10c5200eb2a32aa68abb7fc6f76c2f" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;o&lt;/code&gt; supplies the &lt;code&gt;this&lt;/code&gt; reference to the inner class instance of &lt;code&gt;Outer&lt;/code&gt;.</source>
          <target state="translated">ここで &lt;code&gt;o&lt;/code&gt; は、 &lt;code&gt;this&lt;/code&gt; 参照を &lt;code&gt;Outer&lt;/code&gt; の内部クラスインスタンスに提供します。</target>
        </trans-unit>
        <trans-unit id="8cf320d31b7dd0774140c8f2ed90c8c274ff772d" translate="yes" xml:space="preserve">
          <source>Here block names are unambiguous as no scripts are searched and thus to search use simply &lt;code&gt;unicode.block.BlockName&lt;/code&gt; notation.</source>
          <target state="translated">ここでは、スクリプトが検索されないため、ブロック名は明確であり、検索には単純に &lt;code&gt;unicode.block.BlockName&lt;/code&gt; 表記を使用します。</target>
        </trans-unit>
        <trans-unit id="6dcb204b7bfbc922a65c81d29d2d9fe0db1b0d9c" translate="yes" xml:space="preserve">
          <source>Here is an example function in both forms:</source>
          <target state="translated">ここでは、両方の形式の関数の例を示します。</target>
        </trans-unit>
        <trans-unit id="d0b4b9e647805e60f485e34136037cafd1a89034" translate="yes" xml:space="preserve">
          <source>Here the method &lt;code&gt;add&lt;/code&gt; returns the base type, which doesn't implement the &lt;code&gt;remove&lt;/code&gt; method. The &lt;code&gt;template this&lt;/code&gt; parameter can be used for this purpose:</source>
          <target state="translated">ここで、メソッド &lt;code&gt;add&lt;/code&gt; は、基本メソッドを返します。これは、 &lt;code&gt;remove&lt;/code&gt; メソッドを実装していません。 &lt;code&gt;template this&lt;/code&gt; パラメータは、この目的のために使用することができます。</target>
        </trans-unit>
        <trans-unit id="c4a0b731de4fd47e1ec934359b73224f54545eef" translate="yes" xml:space="preserve">
          <source>Here the method &lt;code&gt;initWith&lt;/code&gt; is overloaded with two versions, one accepting &lt;code&gt;in char*&lt;/code&gt;, the other one &lt;code&gt;NSString&lt;/code&gt;. These two methods are mapped to two different Objective-C selectors, &lt;code&gt;initWithUTF8String:&lt;/code&gt; and &lt;code&gt;initWithString:&lt;/code&gt;.</source>
          <target state="translated">ここで、メソッド &lt;code&gt;initWith&lt;/code&gt; は2つのバージョンでオーバーロードされています。1つ &lt;code&gt;in char*&lt;/code&gt; で受け入れ、もう1つは &lt;code&gt;NSString&lt;/code&gt; で受け入れます。これらの2つのメソッドは、2つの異なるObjective-Cセレクター、 &lt;code&gt;initWithUTF8String:&lt;/code&gt; および &lt;code&gt;initWithString:&lt;/code&gt; にマップされます。</target>
        </trans-unit>
        <trans-unit id="7394eed5672426c0a80d302b8f8393ed7eec5e66" translate="yes" xml:space="preserve">
          <source>Here's an example of C code providing a callback to D code:</source>
          <target state="translated">ここでは、Dコードへのコールバックを提供するCコードの例を示します。</target>
        </trans-unit>
        <trans-unit id="ca207d127693f0056dad58049c5cee1c802022ff" translate="yes" xml:space="preserve">
          <source>Here's an example of a</source>
          <target state="translated">以下に例を示します。</target>
        </trans-unit>
        <trans-unit id="62b798df4ae2b665a95d9fcc9f504deddb178a54" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;S&lt;/code&gt; has a temporary workspace &lt;code&gt;buf[]&lt;/code&gt;. The normal postblit will pointlessly free and reallocate it. The custom &lt;code&gt;opAssign&lt;/code&gt; will reuse the existing storage.</source>
          <target state="translated">ここで、 &lt;code&gt;S&lt;/code&gt; には一時的なワークスペース &lt;code&gt;buf[]&lt;/code&gt; ます。通常のポストブリットは無意味に解放して再割り当てします。カスタム &lt;code&gt;opAssign&lt;/code&gt; は既存のストレージを再利用します。</target>
        </trans-unit>
        <trans-unit id="8062e6745c830b66848176f824bd120bb6ff6bff" translate="yes" xml:space="preserve">
          <source>Here, an implementation may assume (without having knowledge of the body of &lt;code&gt;make&lt;/code&gt;) that all references in &lt;code&gt;make&lt;/code&gt;'s result refer to other &lt;code&gt;List&lt;/code&gt; objects created by &lt;code&gt;make&lt;/code&gt;, and that no other part of the program refers to any of these objects.</source>
          <target state="translated">ここでは、実装は、（本体の知識を有することなく想定できる &lt;code&gt;make&lt;/code&gt; におけるすべての参照こと） &lt;code&gt;make&lt;/code&gt; の結果が他を参照して &lt;code&gt;List&lt;/code&gt; によって作成されたオブジェクト &lt;code&gt;make&lt;/code&gt; 、プログラムの他の部分は、これらのオブジェクトのいずれかを意味しないこと。</target>
        </trans-unit>
        <trans-unit id="aa7249d3729c33470954c40f7854c88ac6ea3626" translate="yes" xml:space="preserve">
          <source>Hex Strings</source>
          <target state="translated">六角紐</target>
        </trans-unit>
        <trans-unit id="55d1c93cb26fa4369bf6dcef06802017d907bd51" translate="yes" xml:space="preserve">
          <source>Hex strings allow string literals to be created using hex data. The hex data need not form valid UTF characters.</source>
          <target state="translated">16 進文字列では、16 進データを使用して文字列リテラルを作成することができます。16進データは有効なUTF文字を形成する必要はありません。</target>
        </trans-unit>
        <trans-unit id="d39bdde77ca95b7a4b0450ffc2d016efdeac30d3" translate="yes" xml:space="preserve">
          <source>Hex_Digit</source>
          <target state="translated">Hex_Digit</target>
        </trans-unit>
        <trans-unit id="c45ee0a2d08a303c51fd2da33a102a3979857332" translate="yes" xml:space="preserve">
          <source>Hexadecimal floats are preceded by a &lt;b&gt;0x&lt;/b&gt; or &lt;b&gt;0X&lt;/b&gt; and the exponent is a &lt;b&gt;p&lt;/b&gt; or &lt;b&gt;P&lt;/b&gt; followed by a decimal number serving as the exponent of 2.</source>
          <target state="translated">16進浮動小数点の前には&lt;b&gt;0x&lt;/b&gt;または&lt;b&gt;0Xが付き&lt;/b&gt;、指数は&lt;b&gt;p&lt;/b&gt;または&lt;b&gt;Pの&lt;/b&gt;後に2の指数として機能する10進数が続きます。</target>
        </trans-unit>
        <trans-unit id="f16858a5f250d36219d82e048f143333094b2747" translate="yes" xml:space="preserve">
          <source>Hexadecimal integers are a sequence of hexadecimal digits preceded by a &amp;lsquo;0x&amp;rsquo; or &amp;lsquo;0X&amp;rsquo;.</source>
          <target state="translated">16進整数は、「0x」または「0X」が前に付いた一連の16進数です。</target>
        </trans-unit>
        <trans-unit id="11ddb91ab70b44df8f22cc56bf0f33cd3a59aeec" translate="yes" xml:space="preserve">
          <source>Hexadecimal notation</source>
          <target state="translated">十六進表記法</target>
        </trans-unit>
        <trans-unit id="66364879eee2501137250fec2b98de691bb34dff" translate="yes" xml:space="preserve">
          <source>Hexadecimal notation with explicit suffixes</source>
          <target state="translated">明示的な接尾辞を持つ16進表記法</target>
        </trans-unit>
        <trans-unit id="4606d5486909f59f9ecd950c1b17f287693253b2" translate="yes" xml:space="preserve">
          <source>Hexadecimal, lower case</source>
          <target state="translated">16進数、小文字</target>
        </trans-unit>
        <trans-unit id="bf0117ce1416e40b23cca8ffd7b3aa016afb333f" translate="yes" xml:space="preserve">
          <source>Hexadecimal, upper case</source>
          <target state="translated">16進数、大文字</target>
        </trans-unit>
        <trans-unit id="30b3eea9819f7439bb0562c0c53437f8d9a50617" translate="yes" xml:space="preserve">
          <source>Hidden parameters include the &lt;code&gt;this&lt;/code&gt; parameter of a class, struct or nested function and the selector parameter for Objective-C methods.</source>
          <target state="translated">非表示のパラメーターには、クラス、構造体、または入れ子関数の &lt;code&gt;this&lt;/code&gt; パラメーターと、Objective-Cメソッドのセレクターパラメーターが含まれます。</target>
        </trans-unit>
        <trans-unit id="53541869fd4c351759ad332d3244e2355b446808" translate="yes" xml:space="preserve">
          <source>High Private Use Surrogates</source>
          <target state="translated">私的利用率の高いサロゲート</target>
        </trans-unit>
        <trans-unit id="a2c5b830397db70f03f56d26786a97a92aad7755" translate="yes" xml:space="preserve">
          <source>High Surrogates</source>
          <target state="translated">高サロゲート</target>
        </trans-unit>
        <trans-unit id="f8ac1be04c27612db7a3ef64fd5edd48a9cbefb5" translate="yes" xml:space="preserve">
          <source>High level</source>
          <target state="translated">ハイレベル</target>
        </trans-unit>
        <trans-unit id="0720fad238d3af6e0d988b6041fc7aff02b725de" translate="yes" xml:space="preserve">
          <source>High level bit level manipulation, bit arrays, bit fields.</source>
          <target state="translated">高レベルのビットレベルの操作、ビット配列、ビットフィールド。</target>
        </trans-unit>
        <trans-unit id="a05a4fbe2b607cf88b24dc00ca5c949b2b6f1756" translate="yes" xml:space="preserve">
          <source>High level primitives for SMP parallelism.</source>
          <target state="translated">SMP並列化のための高レベルのプリミティブ。</target>
        </trans-unit>
        <trans-unit id="2ced0d4c7e1faee3d9f900306c2e846112d18012" translate="yes" xml:space="preserve">
          <source>High-level interface for allocators. Implements bundled allocation/creation and destruction/deallocation of data including &lt;code&gt;struct&lt;/code&gt;s and &lt;code&gt;class&lt;/code&gt;es, and also array primitives related to allocation. This module is the entry point for both making use of allocators and for their documentation.</source>
          <target state="translated">アロケーター用の高水準インターフェース。 &lt;code&gt;struct&lt;/code&gt; sと &lt;code&gt;class&lt;/code&gt; es を含むデータのバンドルされた割り当て/作成と破棄/割り当て解除を実装します。また、割り当てに関連する配列プリミティブも実装します。このモジュールは、アロケーターを使用するためと、それらのドキュメントのためのエントリポイントです。</target>
        </trans-unit>
        <trans-unit id="e4a71da2c94aa8ebb4eabe525bf9bfaf87c49456" translate="yes" xml:space="preserve">
          <source>Highest generated value (&lt;code&gt;modulus - 1&lt;/code&gt;).</source>
          <target state="translated">生成された最大値（ &lt;code&gt;modulus - 1&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9a7ebfdbeeab34f9a74c5ea30182aae05ebb58ca" translate="yes" xml:space="preserve">
          <source>Highest possible &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">可能な限り高い &lt;code&gt;LogLevel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="464c7e7834d9d7bd5320fc6bf866ca1e41042986" translate="yes" xml:space="preserve">
          <source>Highlighting</source>
          <target state="translated">Highlighting</target>
        </trans-unit>
        <trans-unit id="b95101e7e46150f6462631854125e5fff96c059a" translate="yes" xml:space="preserve">
          <source>Highlighting of D code is performed by the following macros:</source>
          <target state="translated">Dコードのハイライトは以下のマクロで行います。</target>
        </trans-unit>
        <trans-unit id="683f475e2ebb85d31bca86c12acb027ecf0e8eb2" translate="yes" xml:space="preserve">
          <source>Highlighting of D keywords</source>
          <target state="translated">Dキーワードのハイライト表示</target>
        </trans-unit>
        <trans-unit id="c4ca1644d89763135e446cfbeade41acbff8ee52" translate="yes" xml:space="preserve">
          <source>Highlighting of D keywords.</source>
          <target state="translated">Dキーワードのハイライト表示。</target>
        </trans-unit>
        <trans-unit id="935e04346b38d14f49040acb6c379fad11a7bf81" translate="yes" xml:space="preserve">
          <source>Highlighting of a function parameter section.</source>
          <target state="translated">関数パラメータ部のハイライト表示。</target>
        </trans-unit>
        <trans-unit id="826389bac96eaeab4717271d63b43c94f3297c72" translate="yes" xml:space="preserve">
          <source>Highlighting of a name=value function parameter.</source>
          <target state="translated">name=value関数パラメータのハイライト表示</target>
        </trans-unit>
        <trans-unit id="51eda7a8eeff739d414894834699b4db25dca6d2" translate="yes" xml:space="preserve">
          <source>Highlighting of a template constraint.</source>
          <target state="translated">テンプレート制約のハイライト表示</target>
        </trans-unit>
        <trans-unit id="cc13dc42b045774509fcd534fa3f901ea5ee4636" translate="yes" xml:space="preserve">
          <source>Highlighting of a template's individual parameters.</source>
          <target state="translated">テンプレートの個々のパラメータをハイライト表示します。</target>
        </trans-unit>
        <trans-unit id="61100e35b4349aa073e0605d9e5a97e7d22147a5" translate="yes" xml:space="preserve">
          <source>Highlighting of a template's parameter list.</source>
          <target state="translated">テンプレートのパラメータリストをハイライト表示します。</target>
        </trans-unit>
        <trans-unit id="c13fcc9292d599790bf9edbd77af674db96191fd" translate="yes" xml:space="preserve">
          <source>Highlighting of all the members of a class.</source>
          <target state="translated">クラスの全メンバーのハイライト表示。</target>
        </trans-unit>
        <trans-unit id="e4ae17c8f2cb1ec34256f6f0903677d6b391295e" translate="yes" xml:space="preserve">
          <source>Highlighting of all the members of a module.</source>
          <target state="translated">モジュールの全メンバーをハイライト表示します。</target>
        </trans-unit>
        <trans-unit id="c09feb09e99ce22a8559d127647547ccdb5c7c15" translate="yes" xml:space="preserve">
          <source>Highlighting of all the members of a struct.</source>
          <target state="translated">構造体のすべてのメンバをハイライト表示します。</target>
        </trans-unit>
        <trans-unit id="cbef76e4daad8898695a45761c2de54a52f8635b" translate="yes" xml:space="preserve">
          <source>Highlighting of all the members of a template.</source>
          <target state="translated">テンプレートの全メンバーをハイライト表示します。</target>
        </trans-unit>
        <trans-unit id="0faf83c3ae32ade36ccd67312a59a723e525d473" translate="yes" xml:space="preserve">
          <source>Highlighting of all the members of an enum.</source>
          <target state="translated">列挙型の全メンバのハイライト表示。</target>
        </trans-unit>
        <trans-unit id="e8d93f96992576e6ba1194d00e53b1efd8bd3019" translate="yes" xml:space="preserve">
          <source>Highlighting of all the sections.</source>
          <target state="translated">全セクションのハイライト表示。</target>
        </trans-unit>
        <trans-unit id="4778b67265bf5d04ac6df97ab091affb27b022ea" translate="yes" xml:space="preserve">
          <source>Highlighting of auto-detected keywords</source>
          <target state="translated">自動検出されたキーワードの強調表示</target>
        </trans-unit>
        <trans-unit id="dd81b3fecd0f20ab2c7c2cd23019f77363841968" translate="yes" xml:space="preserve">
          <source>Highlighting of auto-detected parameters</source>
          <target state="translated">自動検出されたパラメータのハイライト</target>
        </trans-unit>
        <trans-unit id="2d5dbc630aa84bc9b06ad40e57222a60ed6a293a" translate="yes" xml:space="preserve">
          <source>Highlighting of auto-detected symbol</source>
          <target state="translated">自動検出されたシンボルのハイライト</target>
        </trans-unit>
        <trans-unit id="5a59602c4760ed030bee0db0f8f2fc1e157c8fe6" translate="yes" xml:space="preserve">
          <source>Highlighting of auto-detected symbol that starts with underscore</source>
          <target state="translated">アンダースコアで始まる自動検出シンボルの強調表示</target>
        </trans-unit>
        <trans-unit id="03eeb845c1ab1c169a400e57021a9975be5fcd70" translate="yes" xml:space="preserve">
          <source>Highlighting of comments</source>
          <target state="translated">コメントのハイライト</target>
        </trans-unit>
        <trans-unit id="b342620229626113c8bd37f08c3e00019479575f" translate="yes" xml:space="preserve">
          <source>Highlighting of current declaration name</source>
          <target state="translated">現在の宣言名のハイライト表示</target>
        </trans-unit>
        <trans-unit id="176f12498ba670eeda224994c2d82350441886fe" translate="yes" xml:space="preserve">
          <source>Highlighting of current function declaration parameters</source>
          <target state="translated">現在の関数宣言パラメータのハイライト表示</target>
        </trans-unit>
        <trans-unit id="6b99cfaf4826b1d374574b650af15bdd57440bdb" translate="yes" xml:space="preserve">
          <source>Highlighting of declaration name to which a particular section is referring.</source>
          <target state="translated">特定のセクションが参照している宣言名を強調表示します。</target>
        </trans-unit>
        <trans-unit id="0ccd215d873103285e575951e68bee16377784a3" translate="yes" xml:space="preserve">
          <source>Highlighting of ditto declarations.</source>
          <target state="translated">ディットー宣言のハイライト表示。</target>
        </trans-unit>
        <trans-unit id="e60176b3b0d8bba6525dbfb5d2184816b026c16d" translate="yes" xml:space="preserve">
          <source>Highlighting of function parameters.</source>
          <target state="translated">関数パラメータのハイライト表示</target>
        </trans-unit>
        <trans-unit id="738f3d1a73adb20a6fc751e428562fd5770c4fbf" translate="yes" xml:space="preserve">
          <source>Highlighting of non-special sections is done.</source>
          <target state="translated">特別な部分以外は強調表示しています。</target>
        </trans-unit>
        <trans-unit id="4e9319188986e049a769be81e81ed23eb17972c2" translate="yes" xml:space="preserve">
          <source>Highlighting of string literals</source>
          <target state="translated">文字列リテラルのハイライト</target>
        </trans-unit>
        <trans-unit id="9dc393c818c0c8fcccd04642b35f2031235608ef" translate="yes" xml:space="preserve">
          <source>Highlighting of the authors section.</source>
          <target state="translated">著者セクションのハイライト。</target>
        </trans-unit>
        <trans-unit id="c04db9dc0d813c1ccd8c3f2345ab8b620b85f230" translate="yes" xml:space="preserve">
          <source>Highlighting of the base type of a class.</source>
          <target state="translated">クラスの基底型を強調表示します。</target>
        </trans-unit>
        <trans-unit id="a07587fe4175acb9782fe36fd142c60cdfdd6da4" translate="yes" xml:space="preserve">
          <source>Highlighting of the bugs section.</source>
          <target state="translated">バグ部分のハイライト表示。</target>
        </trans-unit>
        <trans-unit id="7882769ed43990ada8c8b23f2c29f9e27cd0f71b" translate="yes" xml:space="preserve">
          <source>Highlighting of the contents of a non-standard section.</source>
          <target state="translated">規格外の部分の内容を強調表示する。</target>
        </trans-unit>
        <trans-unit id="4f9d3c220f1308abbd19a33e68d9159fe1a7bcac" translate="yes" xml:space="preserve">
          <source>Highlighting of the copyright section.</source>
          <target state="translated">著作権の部分を強調しています。</target>
        </trans-unit>
        <trans-unit id="7d6e48fe7e09c72518d7c42b2053ac6afd252e38" translate="yes" xml:space="preserve">
          <source>Highlighting of the date section.</source>
          <target state="translated">日付部分のハイライト表示。</target>
        </trans-unit>
        <trans-unit id="895c3d9b137fe00aae27a823464b74cfac8c6e8b" translate="yes" xml:space="preserve">
          <source>Highlighting of the declaration.</source>
          <target state="translated">宣言のハイライト。</target>
        </trans-unit>
        <trans-unit id="63dc31f05686ee2516c9b1d4403bc34707de916c" translate="yes" xml:space="preserve">
          <source>Highlighting of the deprecated section.</source>
          <target state="translated">非推奨のセクションを強調表示します。</target>
        </trans-unit>
        <trans-unit id="c8decd9303e1480e7050896c2d68e41aba55a19d" translate="yes" xml:space="preserve">
          <source>Highlighting of the description of a declaration.</source>
          <target state="translated">宣言の記述を強調表示します。</target>
        </trans-unit>
        <trans-unit id="c34c68b3feaf8a8af047b5dc0b27284ee8a4a976" translate="yes" xml:space="preserve">
          <source>Highlighting of the description section.</source>
          <target state="translated">説明部分のハイライト表示。</target>
        </trans-unit>
        <trans-unit id="66395af507be6d2f2c64374c4dcc34d87ba08e37" translate="yes" xml:space="preserve">
          <source>Highlighting of the examples section.</source>
          <target state="translated">例の部分を強調しています。</target>
        </trans-unit>
        <trans-unit id="6c9891d5d62ba75e6f4bc3861099aa91d8757c3e" translate="yes" xml:space="preserve">
          <source>Highlighting of the history section.</source>
          <target state="translated">歴史の部分を強調しています。</target>
        </trans-unit>
        <trans-unit id="b7f85e62f0cd3405e5bd64486a1604e80fdbaccf" translate="yes" xml:space="preserve">
          <source>Highlighting of the license section.</source>
          <target state="translated">ライセンス部分の強調表示。</target>
        </trans-unit>
        <trans-unit id="a1bf0eef04a7e415262c4a93c4981e89e888edcc" translate="yes" xml:space="preserve">
          <source>Highlighting of the parameter name.</source>
          <target state="translated">パラメータ名をハイライト表示します。</target>
        </trans-unit>
        <trans-unit id="f88d01cfff7b61b2efa32b18d2de859fdd295ab7" translate="yes" xml:space="preserve">
          <source>Highlighting of the parameter value.</source>
          <target state="translated">パラメータ値をハイライト表示します。</target>
        </trans-unit>
        <trans-unit id="e1964e06337cb784d3309fe34806373d2ea7eb8f" translate="yes" xml:space="preserve">
          <source>Highlighting of the returns section.</source>
          <target state="translated">リターンズセクションのハイライト表示。</target>
        </trans-unit>
        <trans-unit id="833453d17a268f3c235ee74c7f3da2609550d437" translate="yes" xml:space="preserve">
          <source>Highlighting of the section name of a non-standard section.</source>
          <target state="translated">標準以外のセクションのセクション名をハイライト表示します。</target>
        </trans-unit>
        <trans-unit id="c7903d232b908137bafe89e336276f896f569fc5" translate="yes" xml:space="preserve">
          <source>Highlighting of the see-also section.</source>
          <target state="translated">See-alsoセクションのハイライト。</target>
        </trans-unit>
        <trans-unit id="df390d31d75e9b616a073ce0adb1eeb2634d7fd5" translate="yes" xml:space="preserve">
          <source>Highlighting of the standards section.</source>
          <target state="translated">基準の部分を強調表示します。</target>
        </trans-unit>
        <trans-unit id="f0d2af38c35f5e37acd97274204555972b2988bd" translate="yes" xml:space="preserve">
          <source>Highlighting of the summary section.</source>
          <target state="translated">まとめ部分のハイライト。</target>
        </trans-unit>
        <trans-unit id="21e5f168213fe615e9ee4675e90cca4182bf4f11" translate="yes" xml:space="preserve">
          <source>Highlighting of the throws section.</source>
          <target state="translated">投球部のハイライト。</target>
        </trans-unit>
        <trans-unit id="0dff0c156a9e500788193fc7d13465ffae833297" translate="yes" xml:space="preserve">
          <source>Highlighting of the type an enum is based upon</source>
          <target state="translated">列挙型のベースとなる型のハイライト表示</target>
        </trans-unit>
        <trans-unit id="6b50d26c177d3621167352e70fcbe2f923cd28c3" translate="yes" xml:space="preserve">
          <source>Highlighting of the version section.</source>
          <target state="translated">バージョン部分のハイライト表示。</target>
        </trans-unit>
        <trans-unit id="ba1d0a643c81d860412a884b89435cac1cf023d7" translate="yes" xml:space="preserve">
          <source>Hiragana</source>
          <target state="translated">Hiragana</target>
        </trans-unit>
        <trans-unit id="835fe32e11d06c07988640ea18d5a882081aeaae" translate="yes" xml:space="preserve">
          <source>History:</source>
          <target state="translated">History:</target>
        </trans-unit>
        <trans-unit id="b44fed8b2ad60db45d1dfeb77fbed8d582ca1505" translate="yes" xml:space="preserve">
          <source>Hoist-load + hoist-store barrier. Corresponds to &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;LLVM AtomicOrdering.Acquire&lt;/a&gt; and C++11/C11 &lt;code&gt;memory_order_acquire&lt;/code&gt;.</source>
          <target state="translated">ホイストロード+ホイストストアバリア。対応&lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;LLVM AtomicOrdering.Acquire&lt;/a&gt;およびC ++ 11 / C11の &lt;code&gt;memory_order_acquire&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e61310c65ecb57873a154d2408b9cc4403ad4a2" translate="yes" xml:space="preserve">
          <source>Holds information about a socket address retrieved by &lt;code&gt;getAddressInfo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;getAddressInfo&lt;/code&gt; によって取得されたソケットアドレスに関する情報を保持します。</target>
        </trans-unit>
        <trans-unit id="c10ba96a990de4f937f02e9f283e74796b47e3f8" translate="yes" xml:space="preserve">
          <source>Home of the TZ Database files</source>
          <target state="translated">TZデータベースファイルのホーム</target>
        </trans-unit>
        <trans-unit id="b3e0a103daa9ae3f375b2654f0a482c7c0d36297" translate="yes" xml:space="preserve">
          <source>Hook</source>
          <target state="translated">Hook</target>
        </trans-unit>
        <trans-unit id="df83ba56b9bf84a7f6828386bfb0ec0b4ea31298" translate="yes" xml:space="preserve">
          <source>Hook &lt;strong id=&quot;hook&quot;&gt;hook&lt;/strong&gt;;</source>
          <target state="translated">フック&lt;strong id=&quot;hook&quot;&gt;フック&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="c491dcee1ba5406ded29938b72d3efa58c8898bc" translate="yes" xml:space="preserve">
          <source>Hook for &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;=&lt;/code&gt; that ensures comparison against integral values has the behavior expected by the usual arithmetic rules. The built-in semantics yield surprising behavior when comparing signed values against unsigned values, for example &lt;code&gt;0u &amp;lt; -1&lt;/code&gt;. The call &lt;code&gt;hookOpCmp(x, y)&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt; if and only if &lt;code&gt;x&lt;/code&gt; is smaller than &lt;code&gt;y&lt;/code&gt; in abstract arithmetic sense.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&lt;/code&gt; 、および &lt;code&gt;&amp;gt;=&lt;/code&gt; のフックは、整数値との比較が通常の算術規則で期待される動作になることを保証します。組み込みのセマンティクスは、符号付きの値を符号なしの値と比較すると、驚くべき動作をもたらします（例： &lt;code&gt;0u &amp;lt; -1&lt;/code&gt; 。呼び出し &lt;code&gt;hookOpCmp(x, y)&lt;/code&gt; は、 &lt;code&gt;x&lt;/code&gt; が抽象的な算術的な意味で &lt;code&gt;y&lt;/code&gt; よりも小さい場合にのみ &lt;code&gt;-1&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="9cf42c2609ccf8480c4c29b09d1eeb015d535402" translate="yes" xml:space="preserve">
          <source>Hook for &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; that ensures comparison against integral values has the behavior expected by the usual arithmetic rules. The built-in semantics yield surprising behavior when comparing signed values against unsigned values for equality, for example &lt;code&gt;uint.max == -1&lt;/code&gt; or &lt;code&gt;-1_294_967_296 == 3_000_000_000u&lt;/code&gt;. The call &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if and only if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; represent the same arithmetic number.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; および &lt;code&gt;!=&lt;/code&gt; をフックして、整数値との比較が通常の算術規則で期待される動作になるようにします。組み込みのセマンティクスは、符号付きの値と符号なしの値が等しいか &lt;code&gt;-1_294_967_296 == 3_000_000_000u&lt;/code&gt; かを比較するときに驚くべき動作をもたらします。たとえば、 &lt;code&gt;uint.max == -1&lt;/code&gt; または-1_294_967_296 == 3_000_000_000uです。 &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; の呼び出しは、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; が同じ算術数を表す場合にのみ &lt;code&gt;true&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="041c61fdd24218cf59730fd0cdbaa1de754b6893" translate="yes" xml:space="preserve">
          <source>Hook that implements</source>
          <target state="translated">実装するフック</target>
        </trans-unit>
        <trans-unit id="b449d04fd061c7af394902d015ecf01abcf02e96" translate="yes" xml:space="preserve">
          <source>Hook that prints to &lt;code&gt;stderr&lt;/code&gt; a trace of all integral errors, without affecting default behavior.</source>
          <target state="translated">デフォルトの動作に影響を与えることなく、すべての積分エラーのトレースを &lt;code&gt;stderr&lt;/code&gt; に出力するフック。</target>
        </trans-unit>
        <trans-unit id="efbf28167139074d8823a898190b189c85ea78aa" translate="yes" xml:space="preserve">
          <source>Hook that provides arithmetically correct comparisons for equality and ordering. Comparing an object of type &lt;code&gt;Checked!(X, ProperCompare)&lt;/code&gt; against another integral (for equality or ordering) ensures that no surprising conversions from signed to unsigned integral occur before the comparison. Using &lt;code&gt;Checked!(X, ProperCompare)&lt;/code&gt; on either side of a comparison for equality against a floating-point number makes sure the integral can be properly converted to the floating point type, thus making sure equality is transitive.</source>
          <target state="translated">等価性と順序付けについて算術的に正しい比較を提供するフック。タイプ &lt;code&gt;Checked!(X, ProperCompare)&lt;/code&gt; オブジェクトを別の整数（等価または順序付け）と比較すると、比較前に、符号付きから符号なし整数への予期しない変換が発生しなくなります。使用 &lt;code&gt;Checked!(X, ProperCompare)&lt;/code&gt; 浮動小数点数に対する平等のための比較のいずれかの側には、必ず積分は正しくので必ず平等で推移で作り、浮動小数点型に変換することができます。</target>
        </trans-unit>
        <trans-unit id="d806e6661a85f88dc9eaa221319b2117db0f755d" translate="yes" xml:space="preserve">
          <source>Hook that reserves a special value as a &quot;Not a Number&quot; representative. For signed integrals, the reserved value is &lt;code&gt;T.min&lt;/code&gt;. For signed integrals, the reserved value is &lt;code&gt;T.max&lt;/code&gt;.</source>
          <target state="translated">「非数」の代表として特別な値を予約するフック。符号付き積分の場合、予約値は &lt;code&gt;T.min&lt;/code&gt; です。符号付き積分の場合、予約値は &lt;code&gt;T.max&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="33488d4b3cbb5ba16b0673469e60db7094fb670e" translate="yes" xml:space="preserve">
          <source>Horizontal Rules</source>
          <target state="translated">水平方向のルール</target>
        </trans-unit>
        <trans-unit id="7212f381e90838fabdee36fb0501fbba0ed9cd58" translate="yes" xml:space="preserve">
          <source>Horizontal tab</source>
          <target state="translated">水平タブ</target>
        </trans-unit>
        <trans-unit id="3ac6fafe4ab0f338471b45cb71f20d044e5f5cc2" translate="yes" xml:space="preserve">
          <source>Horizontal tab (U+0009).</source>
          <target state="translated">水平タブ(U+0009)。</target>
        </trans-unit>
        <trans-unit id="bbb1b4f452c31b5eb2b5c0983d50e71cb342831f" translate="yes" xml:space="preserve">
          <source>Host compiler vendor string and language version.</source>
          <target state="translated">ホスト・コンパイラ・ベンダーの文字列と言語バージョン。</target>
        </trans-unit>
        <trans-unit id="e118cd39d323f526da5b0f63e4f3c3b86e96af36" translate="yes" xml:space="preserve">
          <source>Hour of the day [0 - 24).</source>
          <target state="translated">時間帯[0~24]。</target>
        </trans-unit>
        <trans-unit id="47f45a8e9beb5422f5775e424c56239ab38cf0a6" translate="yes" xml:space="preserve">
          <source>Hours past midnight.</source>
          <target state="translated">12時過ぎの時間帯。</target>
        </trans-unit>
        <trans-unit id="aea1f84448c4cd135127feb893d3e5b86649ead7" translate="yes" xml:space="preserve">
          <source>How Garbage Collection Works</source>
          <target state="translated">ごみ収集の仕組み</target>
        </trans-unit>
        <trans-unit id="5e1ecfe3dd4c1b701a8f4295c2bd308de6db519e" translate="yes" xml:space="preserve">
          <source>How a socket is shutdown:</source>
          <target state="translated">ソケットのシャットダウン方法</target>
        </trans-unit>
        <trans-unit id="14072cd783ee679dcd4faa9d6011722e64957f7d" translate="yes" xml:space="preserve">
          <source>How does this meet our assumptions about errors?</source>
          <target state="translated">これはどのようにして誤差についての仮定に合致するのでしょうか?</target>
        </trans-unit>
        <trans-unit id="2cef028c4c427db32ab248fb0fa09f711b8938d4" translate="yes" xml:space="preserve">
          <source>How does this meet our criteria?</source>
          <target state="translated">これはどうやって基準を満たしているのでしょうか?</target>
        </trans-unit>
        <trans-unit id="46c019e7726b602bf175d16d3e47d3c9855717af" translate="yes" xml:space="preserve">
          <source>How much &lt;code&gt;r&lt;/code&gt; was actually advanced, which may be less than &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; did not have at least &lt;code&gt;n&lt;/code&gt; elements.</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; が実際にどれだけ進んだか &lt;code&gt;r&lt;/code&gt; が少なくとも &lt;code&gt;n&lt;/code&gt; 個の要素を持っていなかった場合は、 &lt;code&gt;n&lt;/code&gt; 未満になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="39a1caec9f5c9eff0c38eb6253af004f14eeaf48" translate="yes" xml:space="preserve">
          <source>How the deprecation messages are presented to the user.</source>
          <target state="translated">非推奨のメッセージをどのようにユーザーに提示するか。</target>
        </trans-unit>
        <trans-unit id="45ad0b30a0ba21c8300555e31b930fb7fa5c8e56" translate="yes" xml:space="preserve">
          <source>How to check an entire string</source>
          <target state="translated">文字列全体をチェックする方法</target>
        </trans-unit>
        <trans-unit id="3944bdd486c5b281b0d76b6fea24f7aa42d88928" translate="yes" xml:space="preserve">
          <source>However for class types, identity assignment is not allowed. All class types have reference semantics, so identity assignment by default rebinds the left-hand-side to the argument at the right, and this is not overridable.</source>
          <target state="translated">しかし、クラス型の場合は、ID の代入は許可されていません。すべてのクラス型は参照セマンティクスを持っているので、アイデンティティの代入はデフォルトでは左側を右側の引数にリバインドしており、これはオーバーライドできません。</target>
        </trans-unit>
        <trans-unit id="d81485ead3a03b09d4ef041206a388f9ba3d1726" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;Rebindable!(Widget)&lt;/code&gt; does allow reassignment, while otherwise behaving exactly like a &lt;code&gt;const Widget&lt;/code&gt;.</source>
          <target state="translated">ただし、 &lt;code&gt;Rebindable!(Widget)&lt;/code&gt; は再割り当てを許可しますが、それ以外は &lt;code&gt;const Widget&lt;/code&gt; とまったく同じように動作します。</target>
        </trans-unit>
        <trans-unit id="39fcf81b03ae2153072256cf5c2ed783812c0162" translate="yes" xml:space="preserve">
          <source>However, if the AA element type is a struct which supports an implicit constructor call from the assigned value, implicit construction is used for setting the AA entry:</source>
          <target state="translated">ただし、AA要素型が代入値からの暗黙のコンストラクタ呼び出しをサポートする構造体である場合、AAエントリの設定には暗黙のコンストラクションを使用します。</target>
        </trans-unit>
        <trans-unit id="be6cc5f771eb95dadab03bad5c4c89972ffb70a4" translate="yes" xml:space="preserve">
          <source>However, in &lt;code&gt;-betterC&lt;/code&gt;&lt;code&gt;assert&lt;/code&gt; expressions don't use Druntime's assert and are directed to &lt;code&gt;assert&lt;/code&gt; of the C runtime library instead.</source>
          <target state="translated">ただし、 &lt;code&gt;-betterC&lt;/code&gt; の &lt;code&gt;assert&lt;/code&gt; 式ではDruntimeのアサートを使用せず、代わりにCランタイムライブラリの &lt;code&gt;assert&lt;/code&gt; を対象としています。</target>
        </trans-unit>
        <trans-unit id="5a66b8122994e01e172373073ab6d4fa34b94942" translate="yes" xml:space="preserve">
          <source>However, it should be noted that the time zone information on Windows is frequently less accurate than that in the IANA time zone database, and if someone really wants accurate time zone information, they should use the IANA time zone database files with &lt;a href=&quot;#PosixTimeZone&quot;&gt;&lt;code&gt;PosixTimeZone&lt;/code&gt;&lt;/a&gt; on Windows rather than &lt;a href=&quot;#WindowsTimeZone&quot;&gt;&lt;code&gt;WindowsTimeZone&lt;/code&gt;&lt;/a&gt;, whereas &lt;a href=&quot;#WindowsTimeZone&quot;&gt;&lt;code&gt;WindowsTimeZone&lt;/code&gt;&lt;/a&gt; makes more sense when trying to match what Windows will think the time is in a specific time zone.</source>
          <target state="translated">ただし、Windowsのタイムゾーン情報はIANAタイムゾーンデータベースよりも正確でないことがよくあり、誰かが本当に正確なタイムゾーン情報を必要とする場合は、Windowsの&lt;a href=&quot;#PosixTimeZone&quot;&gt; &lt;code&gt;PosixTimeZone&lt;/code&gt; &lt;/a&gt;でIANAタイムゾーンデータベースファイルを使用する必要があります。より&lt;a href=&quot;#WindowsTimeZone&quot;&gt; &lt;code&gt;WindowsTimeZone&lt;/code&gt; &lt;/a&gt;、一方&lt;a href=&quot;#WindowsTimeZone&quot;&gt; &lt;code&gt;WindowsTimeZone&lt;/code&gt; は、&lt;/a&gt; Windowsは時間が特定の時間帯であると思われる内容と一致するようにしようとしたとき、より理にかなっています。</target>
        </trans-unit>
        <trans-unit id="6fe9389c4ddd121d6493079f489aee81befd5618" translate="yes" xml:space="preserve">
          <source>However, on Windows, it may be the unabbreviated name (e.g. Pacific Daylight Time). Regardless, it is not the same as name.</source>
          <target state="translated">ただし、Windowsでは、省略されていない名前(例:太平洋夏時間)になっている場合があります。それとは関係なく、名前と同じではありません。</target>
        </trans-unit>
        <trans-unit id="47c13d8e213a10f9001fd45644c1b3afeb68823d" translate="yes" xml:space="preserve">
          <source>However, on Windows, it may be the unabbreviated name (e.g. Pacific Standard Time). Regardless, it is not the same as name.</source>
          <target state="translated">ただし、Windowsでは、省略されていない名前(例えば太平洋標準時)になっている場合があります。それに関わらず、名前とは違います。</target>
        </trans-unit>
        <trans-unit id="eff8dd0f2d633371467a00fc8759aea595ab2872" translate="yes" xml:space="preserve">
          <source>However, when doing overload resolution, the functions in the base class are not considered:</source>
          <target state="translated">ただし、オーバーロード解決を行う際には、基底クラスの関数は考慮されません。</target>
        </trans-unit>
        <trans-unit id="599b7a863c6a59d1092f07e1710589a8785bdb8d" translate="yes" xml:space="preserve">
          <source>Human readable string representing the IPv4 address in dotted-decimal form.</source>
          <target state="translated">IPv4アドレスを10進数で表現した、人間が読める文字列。</target>
        </trans-unit>
        <trans-unit id="aff39bc2ec043587101457aaa3ae19023826875e" translate="yes" xml:space="preserve">
          <source>Human readable string representing the IPv4 port.</source>
          <target state="translated">IPv4ポートを表す人間が読める文字列。</target>
        </trans-unit>
        <trans-unit id="a79746cad8ecf9d33b60d8dd5347136a9d85ef98" translate="yes" xml:space="preserve">
          <source>Human readable string representing this address.</source>
          <target state="translated">このアドレスを表す人間が読める文字列。</target>
        </trans-unit>
        <trans-unit id="4c4d996a690c3ac43662d610a18221ccc97faec3" translate="yes" xml:space="preserve">
          <source>Hyphen</source>
          <target state="translated">Hyphen</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="47af55839c3e9c9ba933349c6295cd1ce082a6a3" translate="yes" xml:space="preserve">
          <source>I &lt;code&gt;im&lt;/code&gt;</source>
          <target state="translated">I &lt;code&gt;im&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="84ff080e0a1bf2c778d5efdc523acd4678a5928f" translate="yes" xml:space="preserve">
          <source>I &lt;code&gt;sizes&lt;/code&gt;</source>
          <target state="translated">私は &lt;code&gt;sizes&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d4ce4e386de11613809ef416e70170284dffb219" translate="yes" xml:space="preserve">
          <source>I &lt;code&gt;startingIndex&lt;/code&gt;</source>
          <target state="translated">私は &lt;code&gt;startingIndex&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3df1df26aa4ea931d9e988f62da215ed0c3e81a7" translate="yes" xml:space="preserve">
          <source>I came, I coded, I crashed.</source>
          <target state="translated">私は来て、コーディングして、クラッシュした。</target>
        </trans-unit>
        <trans-unit id="81cb37800b131d16bca390e388601790ff6f313b" translate="yes" xml:space="preserve">
          <source>I.e. is it a single return statement or some compound statement that unconditionally hits a return statement.</source>
          <target state="translated">つまり、単一のリターン文なのか、それとも無条件にリターン文に当たる複合文なのか。</target>
        </trans-unit>
        <trans-unit id="d8212950b3ac05f1c5deaff0d3a32ce51c051e7f" translate="yes" xml:space="preserve">
          <source>I/O operation successful</source>
          <target state="translated">入出力操作成功</target>
        </trans-unit>
        <trans-unit id="a07107356f25616c07b6fd35ca4ce30f409251c5" translate="yes" xml:space="preserve">
          <source>IBM Advanced Interactive eXecutive OS</source>
          <target state="translated">IBMアドバンストインタラクティブeXecutive OS</target>
        </trans-unit>
        <trans-unit id="7e73f4b459341f6552e0a60723ed4f4fb582c963" translate="yes" xml:space="preserve">
          <source>IDS_Binary_Operator</source>
          <target state="translated">IDS_Binary_Operator</target>
        </trans-unit>
        <trans-unit id="dfddbbc74d0d43db63cde2a6e1024f6ba8221fff" translate="yes" xml:space="preserve">
          <source>IDS_Trinary_Operator</source>
          <target state="translated">IDS_Trinary_Operator</target>
        </trans-unit>
        <trans-unit id="0a50f9983af5839dd0d0dc6f249331d57b64db6f" translate="yes" xml:space="preserve">
          <source>ID_Continue</source>
          <target state="translated">ID_Continue</target>
        </trans-unit>
        <trans-unit id="92936d6f1e8f3e471e6f43d46a9887af5d007bd8" translate="yes" xml:space="preserve">
          <source>ID_Start</source>
          <target state="translated">ID_Start</target>
        </trans-unit>
        <trans-unit id="3f4e414c32b3902ba3f69c8b82e07f90e3313525" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point arithmetic can set several flags based on what happened with a computation:</source>
          <target state="translated">IEEE 754 浮動小数点演算は、計算で何が起こったかに基づいて、いくつかのフラグを設定することができます。</target>
        </trans-unit>
        <trans-unit id="ca31149be1b5f9a497eaee503fda4915c7e1c829" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point arithmetic includes the ability to set 4 different rounding modes. These are accessible via the functions in &lt;code&gt;core.stdc.fenv&lt;/code&gt;.</source>
          <target state="translated">IEEE 754浮動小数点演算には、4つの異なる丸めモードを設定する機能が含まれています。これらは、 &lt;code&gt;core.stdc.fenv&lt;/code&gt; の関数を介してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="c9fbff470ecc71dad6d33f5eeaccc83f4e863050" translate="yes" xml:space="preserve">
          <source>IEEE exception status flags ('sticky bits')</source>
          <target state="translated">IEEE例外ステータスフラグ ('sticky bits')</target>
        </trans-unit>
        <trans-unit id="a2584841fe85abc74e15db0f23c9cdba2dd8ab2a" translate="yes" xml:space="preserve">
          <source>IEEE hardware exceptions. By default, all exceptions are masked (disabled).</source>
          <target state="translated">IEEE ハードウェア例外。デフォルトでは、すべての例外はマスクされています(無効化されています)。</target>
        </trans-unit>
        <trans-unit id="b9e2d958b9ca41f87ae15ec8c35999c50ae4ff8c" translate="yes" xml:space="preserve">
          <source>IEEE rounding modes. The default mode is roundToNearest.</source>
          <target state="translated">IEEE丸めモード。デフォルトのモードは roundToNearest です。</target>
        </trans-unit>
        <trans-unit id="7d81343ef8eab15b8d8f8c68c7c8bdb404ed88bb" translate="yes" xml:space="preserve">
          <source>ILS &lt;strong id=&quot;inlineStatusStmt&quot;&gt;inlineStatusStmt&lt;/strong&gt;;</source>
          <target state="translated">ILS &lt;strong id=&quot;inlineStatusStmt&quot;&gt;inlineStatusStmt&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="362fa36f30a060b9e1fcf247cb78ff4ce49924f2" translate="yes" xml:space="preserve">
          <source>IMP</source>
          <target state="translated">IMP</target>
        </trans-unit>
        <trans-unit id="bdc4004339f8557d5a75257afe0bb8aef0ebaaba" translate="yes" xml:space="preserve">
          <source>IP multicast hops</source>
          <target state="translated">IPマルチキャストホップ</target>
        </trans-unit>
        <trans-unit id="20fe7e463770b20399ece7b586c1bbb5d3def572" translate="yes" xml:space="preserve">
          <source>IP multicast interface</source>
          <target state="translated">アイピーマルチキャストインタフェース</target>
        </trans-unit>
        <trans-unit id="7279e4b3160656f1f51a778df4e83b92cb83cf30" translate="yes" xml:space="preserve">
          <source>IP multicast loopback</source>
          <target state="translated">アイピーマルチキャストループバック</target>
        </trans-unit>
        <trans-unit id="9ebd1fbe7ba3cf5bdc775290d0d686e15bf4c0b2" translate="yes" xml:space="preserve">
          <source>IP unicast hop limit</source>
          <target state="translated">IPユニキャストホップ制限</target>
        </trans-unit>
        <trans-unit id="cc01b492cee0acdf48f0b298c26fa47256bd3faf" translate="yes" xml:space="preserve">
          <source>IPA Extensions</source>
          <target state="translated">IPA拡張機能</target>
        </trans-unit>
        <trans-unit id="80570baac1433d8da38eb560349f85ffa3c24938" translate="yes" xml:space="preserve">
          <source>IPv6 address ends with a single colon</source>
          <target state="translated">IPv6 アドレスは単一のコロンで終わる</target>
        </trans-unit>
        <trans-unit id="f971f61e6734e2eb397d8944032e3b5547c71b4c" translate="yes" xml:space="preserve">
          <source>IPv6 address starts with a single colon</source>
          <target state="translated">IPv6アドレスは単一のコロンで始まる</target>
        </trans-unit>
        <trans-unit id="ffeae36229b4084ab3f5431d5a5e2894acff57f8" translate="yes" xml:space="preserve">
          <source>IPv6-enabled</source>
          <target state="translated">IPv6-enabled</target>
        </trans-unit>
        <trans-unit id="ae9887477b5a4dc86ce15b0c56db938ec92c9140" translate="yes" xml:space="preserve">
          <source>IRState* &lt;code&gt;irs&lt;/code&gt;</source>
          <target state="translated">IRState * &lt;code&gt;irs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="445867d9c88cb9ec795d4d1edb4358f7f32ed23d" translate="yes" xml:space="preserve">
          <source>ISO 8601</source>
          <target state="translated">ISO8601</target>
        </trans-unit>
        <trans-unit id="0f3e173e17d8fbdbf144076143d8cd16c3b60805" translate="yes" xml:space="preserve">
          <source>ISO Week Date</source>
          <target state="translated">ISO週の日付</target>
        </trans-unit>
        <trans-unit id="6edb4ac9bcba71ad7ccb4ee02897a84fda819a4e" translate="yes" xml:space="preserve">
          <source>ISO/IEC 9899:1999 (E)</source>
          <target state="translated">ISO/IEC 9899:1999(E</target>
        </trans-unit>
        <trans-unit id="8e40d146e834aa0554ad9d258a39d303ac74b95c" translate="yes" xml:space="preserve">
          <source>ISO/IEC 9899:1999 (E)  These are the various functions called by the assert() macro. They are all noreturn functions, although D doesn't have a specific attribute for that.</source>
          <target state="translated">ISO/IEC 9899:1999 (E)これらはassert()マクロによって呼び出される様々な関数です。Dには特定の属性はありませんが、これらはすべてノルターン関数です。</target>
        </trans-unit>
        <trans-unit id="79c91cb6efbe5dfcc03f77ea0bf59ceecfb03a1b" translate="yes" xml:space="preserve">
          <source>Iain Buclaw</source>
          <target state="translated">アイアン・ブクロー</target>
        </trans-unit>
        <trans-unit id="a61268b8e652624d626d166308f20560b1d3aa63" translate="yes" xml:space="preserve">
          <source>Id::max or Id::min</source>
          <target state="translated">Id::max または Id::min</target>
        </trans-unit>
        <trans-unit id="06b6ace8ca3f18249e8ba4ea9090c0f34564ce1c" translate="yes" xml:space="preserve">
          <source>Identifier</source>
          <target state="translated">Identifier</target>
        </trans-unit>
        <trans-unit id="d884429135c14548b3e978b368447365cb96cfc8" translate="yes" xml:space="preserve">
          <source>Identifier (inside Identifier.idPool) with deterministic name based on the source location.</source>
          <target state="translated">識別子(Identifier.idPool内)で、ソースの場所に基づいた決定論的な名前を持つ。</target>
        </trans-unit>
        <trans-unit id="d39412a656d9c3c7bf8a3a174965f8e76b9c6aae" translate="yes" xml:space="preserve">
          <source>Identifier : NonVoidInitializer</source>
          <target state="translated">識別:NonVoidInitializer</target>
        </trans-unit>
        <trans-unit id="2ea823871928966eb34d2d6331730d76f54cfc52" translate="yes" xml:space="preserve">
          <source>Identifier &lt;code&gt;id&lt;/code&gt;</source>
          <target state="translated">識別子 &lt;code&gt;id&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd812024edf80fc26687c86baab342484d1cca2a" translate="yes" xml:space="preserve">
          <source>Identifier &lt;code&gt;ident&lt;/code&gt;</source>
          <target state="translated">識別子 &lt;code&gt;ident&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f032313123f1ffabc6636b37a2cdfb763957f48d" translate="yes" xml:space="preserve">
          <source>Identifier &lt;code&gt;module_&lt;/code&gt;</source>
          <target state="translated">識別子 &lt;code&gt;module_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ff20fb48822c4ece471eaa71420a8e3f17752e0" translate="yes" xml:space="preserve">
          <source>Identifier &lt;strong id=&quot;identifier&quot;&gt;identifier&lt;/strong&gt;;</source>
          <target state="translated">識別子&lt;strong id=&quot;identifier&quot;&gt;識別子&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="964e8904f66adfee7e7841e9b8d4ec24e389fed4" translate="yes" xml:space="preserve">
          <source>Identifier Emphasis</source>
          <target state="translated">識別子 強調</target>
        </trans-unit>
        <trans-unit id="57fd2f9988cc1bead6d88fdd99fa28550daa5071" translate="yes" xml:space="preserve">
          <source>Identifier required for this condition to pass. If &lt;code&gt;null&lt;/code&gt;, this conditiion will use an integer level.</source>
          <target state="translated">この条件に合格するために必要な識別子。 &lt;code&gt;null&lt;/code&gt; の場合、この条件は整数レベルを使用します。</target>
        </trans-unit>
        <trans-unit id="72a03d37bdb5a52d9cfa01295909001833684faa" translate="yes" xml:space="preserve">
          <source>Identifier value (e.g. &lt;code&gt;Id.unitTest&lt;/code&gt;) or &lt;code&gt;TOK.identifier&lt;/code&gt;</source>
          <target state="translated">識別子の値（例： &lt;code&gt;Id.unitTest&lt;/code&gt; ）または &lt;code&gt;TOK.identifier&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22dcd4202be0468eb915e08817484731c04ef629" translate="yes" xml:space="preserve">
          <source>IdentifierList</source>
          <target state="translated">IdentifierList</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="29849b8a9887214097873771c1ada1e4a2b26c67" translate="yes" xml:space="preserve">
          <source>Identifiers in documentation comments that are function parameters or are names that are in scope at the associated declaration are emphasized in the output. This emphasis can take the form of italics, boldface, a hyperlink, etc. How it is emphasized depends on what it is</source>
          <target state="translated">ドキュメントのコメントの中で、関数のパラメータであったり、関連する宣言でスコープ内にある名前である識別子は、出力で強調されます。この強調は、イタリック体、太字、ハイパーリンクなどの形をとることができます。どのように強調されるかは、それが何であるかによって異なります。</target>
        </trans-unit>
        <trans-unit id="ee26ed57025d5c31d0bf47a619bdb084494918ff" translate="yes" xml:space="preserve">
          <source>Identifiers start with a letter, &lt;code&gt;_&lt;/code&gt;, or universal alpha, and are followed by any number of letters, &lt;code&gt;_&lt;/code&gt;, digits, or universal alphas. Universal alphas are as defined in ISO/IEC 9899:1999(E) Appendix D of the C99 Standard. Identifiers can be arbitrarily long, and are case sensitive.</source>
          <target state="translated">識別子は、文字 &lt;code&gt;_&lt;/code&gt; 、またはユニバーサルアルファで始まり、その後に任意の数の文字 &lt;code&gt;_&lt;/code&gt; 、数字、またはユニバーサルアルファが続きます。ユニバーサルアルファは、C99標準のISO / IEC 9899：1999（E）付録Dで定義されています。識別子は任意の長さにすることができ、大文字と小文字が区別されます。</target>
        </trans-unit>
        <trans-unit id="745651339d520944f46b951509355e65410d85d8" translate="yes" xml:space="preserve">
          <source>Identifiers* &lt;code&gt;ids&lt;/code&gt;</source>
          <target state="translated">識別子* &lt;code&gt;ids&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8bce0759953389b7f6673a7b1dcdcbe2f5adafd6" translate="yes" xml:space="preserve">
          <source>Identifiers* &lt;code&gt;pkg_identifiers&lt;/code&gt;</source>
          <target state="translated">識別子* &lt;code&gt;pkg_identifiers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd196121fbac89b149b3c74f08384f1bdda01148" translate="yes" xml:space="preserve">
          <source>Identify Statement types with this enum rather than virtual functions.</source>
          <target state="translated">仮想関数ではなく、この列挙でステートメントタイプを識別します。</target>
        </trans-unit>
        <trans-unit id="897cc900af9b1d4567cf3ac949c0ce028e5b29c4" translate="yes" xml:space="preserve">
          <source>Identify the characteristics of the host CPU, providing information about cache sizes and assembly optimisation hints. This module is provided primarily for assembly language programmers.</source>
          <target state="translated">ホストCPUの特性を識別し、キャッシュサイズとアセンブリ最適化のヒントに関する情報を提供します。このモジュールは、主にアセンブリ言語プログラマのために提供されます。</target>
        </trans-unit>
        <trans-unit id="294c861b2aa613142591a5192af15c07f9d87cde" translate="yes" xml:space="preserve">
          <source>Identify the compiler used and its various features.</source>
          <target state="translated">使用されているコンパイラとその様々な機能を識別します。</target>
        </trans-unit>
        <trans-unit id="2adbbf9ddb856b5eee69eb90a8ddc235f490d75b" translate="yes" xml:space="preserve">
          <source>Identify whether a variable is defined in the environment.</source>
          <target state="translated">環境内で変数が定義されているかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="560e8754d1a43d2889127379ce8941035430acdf" translate="yes" xml:space="preserve">
          <source>Identity Assignment Overload</source>
          <target state="translated">アイデンティティ割り当ての過負荷</target>
        </trans-unit>
        <trans-unit id="feaad94f17d0151c7ee9d808da8437d06bd6ced9" translate="yes" xml:space="preserve">
          <source>Identity Expressions</source>
          <target state="translated">アイデンティティ表現</target>
        </trans-unit>
        <trans-unit id="3541f48427fcdd81e30c7c16278c379163644459" translate="yes" xml:space="preserve">
          <source>Ideographic</source>
          <target state="translated">Ideographic</target>
        </trans-unit>
        <trans-unit id="5b6b53689a3fc635c459675544040944bd74d306" translate="yes" xml:space="preserve">
          <source>Ideographic Description Characters</source>
          <target state="translated">イデオグラフィックの説明文字</target>
        </trans-unit>
        <trans-unit id="250ad5161fad3e8519e80733a4a75b5049da3f8e" translate="yes" xml:space="preserve">
          <source>Idiomatic Use of &lt;code&gt;std.experimental.allocator&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std.experimental.allocator&lt;/code&gt; の慣用的な使用</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="828467146cd8af7a4600851262e42a7b8fdfff46" translate="yes" xml:space="preserve">
          <source>If !is null, elements[] can be sparse and basis is used for the &quot;default&quot; element value. In other words, non-null elements[i] overrides this 'basis' value.</source>
          <target state="translated">もし !がnullの場合、elements[]は疎にすることができ、&quot;デフォルト &quot;の要素値にはbasisが使用されます。言い換えれば、nullでないelements[i]はこの'basis'値を上書きします。</target>
        </trans-unit>
        <trans-unit id="9ddd459237f2459c44b509144a91e81da646bb40" translate="yes" xml:space="preserve">
          <source>If 'e' is a tree of commas, returns the rightmost expression by stripping off it from the tree. The remained part of the tree is returned via e0. Otherwise 'e' is directly returned and e0 is set to NULL.</source>
          <target state="translated">e' がカンマの木である場合、木からそれを取り除いて一番右の式を返します。ツリーに残った部分は e0 を介して返されます。それ以外の場合は 'e' が直接返され、e0 は NULL に設定されます。</target>
        </trans-unit>
        <trans-unit id="1b4dc8c105f5a3f750e979db674fe11913e62d44" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;std_range_primitives#ElementType&quot;&gt;&lt;code&gt;std.range.primitives.ElementType&lt;/code&gt;&lt;/a&gt;!R is a floating-point type and &lt;code&gt;R&lt;/code&gt; is a &lt;a href=&quot;std_range_primitives#isRandomAccessRange&quot;&gt;random-access range&lt;/a&gt; with length and slicing, then &lt;code&gt;sum&lt;/code&gt; uses the &lt;a href=&quot;http://en.wikipedia.org/wiki/Pairwise_summation&quot;&gt;pairwise summation&lt;/a&gt; algorithm.</source>
          <target state="translated">場合&lt;a href=&quot;std_range_primitives#ElementType&quot;&gt; &lt;code&gt;std.range.primitives.ElementType&lt;/code&gt; &lt;/a&gt;！Rは、浮動小数点型であり、そして &lt;code&gt;R&lt;/code&gt; は、である&lt;a href=&quot;std_range_primitives#isRandomAccessRange&quot;&gt;ランダムアクセスの範囲&lt;/a&gt;の長さとスライスと、その後 &lt;code&gt;sum&lt;/code&gt; 使用&lt;a href=&quot;http://en.wikipedia.org/wiki/Pairwise_summation&quot;&gt;ペアワイズ加算&lt;/a&gt;アルゴリズム。</target>
        </trans-unit>
        <trans-unit id="5461d4fe41b7c975dcc4f74fcf29adecaffabc9a" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;std_range_primitives#ElementType&quot;&gt;&lt;code&gt;std.range.primitives.ElementType&lt;/code&gt;&lt;/a&gt;!R is a floating-point type and &lt;code&gt;R&lt;/code&gt; is a &lt;a href=&quot;std_range_primitives#isRandomAccessRange&quot;&gt;random-access range&lt;/a&gt; with length and slicing, then &lt;code&gt;sum&lt;/code&gt; uses the &lt;a href=&quot;https://en.wikipedia.org/wiki/Pairwise_summation&quot;&gt;pairwise summation&lt;/a&gt; algorithm.</source>
          <target state="translated">場合&lt;a href=&quot;std_range_primitives#ElementType&quot;&gt; &lt;code&gt;std.range.primitives.ElementType&lt;/code&gt; &lt;/a&gt;！Rは、浮動小数点型であり、そして &lt;code&gt;R&lt;/code&gt; は、である&lt;a href=&quot;std_range_primitives#isRandomAccessRange&quot;&gt;ランダムアクセスの範囲&lt;/a&gt;の長さとスライスと、その後 &lt;code&gt;sum&lt;/code&gt; 使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Pairwise_summation&quot;&gt;ペアワイズ加算&lt;/a&gt;アルゴリズム。</target>
        </trans-unit>
        <trans-unit id="d3c45083751ac69c2e8e598d9798f65c4de37c86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!!value&lt;/code&gt; is true, &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;new WindowsException(GetLastError(), msg)&lt;/code&gt; is thrown. &lt;code&gt;WindowsException&lt;/code&gt; assumes that the last operation set &lt;code&gt;GetLastError()&lt;/code&gt; appropriately.</source>
          <target state="translated">場合 &lt;code&gt;!!value&lt;/code&gt; trueで、 &lt;code&gt;value&lt;/code&gt; 返されます。それ以外の場合は、 &lt;code&gt;new WindowsException(GetLastError(), msg)&lt;/code&gt; がスローされます。 &lt;code&gt;WindowsException&lt;/code&gt; は、最後の操作で &lt;code&gt;GetLastError()&lt;/code&gt; が適切に設定されていることを前提としています。</target>
        </trans-unit>
        <trans-unit id="8df9d33ad5bc28652f3433433542fda31081bb55" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!isInfinite!Source&lt;/code&gt; and &lt;code&gt;source.walkLength&lt;/code&gt; is not evenly divisible by &lt;code&gt;chunkSize&lt;/code&gt;, the back element of this range will contain fewer than &lt;code&gt;chunkSize&lt;/code&gt; elements.</source>
          <target state="translated">&lt;code&gt;!isInfinite!Source&lt;/code&gt; と &lt;code&gt;source.walkLength&lt;/code&gt; が &lt;code&gt;chunkSize&lt;/code&gt; で割り切れない場合、この範囲の後方要素には &lt;code&gt;chunkSize&lt;/code&gt; 要素よりも少ない要素が含まれます。</target>
        </trans-unit>
        <trans-unit id="da45e2d8d90136b7f84f13e1858fb6ece371b4b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;new E(msg, file, line)&lt;/code&gt; is thrown. Or if &lt;code&gt;E&lt;/code&gt; doesn't take a message and can be constructed with &lt;code&gt;new E(file, line)&lt;/code&gt;, then &lt;code&gt;new E(file, line)&lt;/code&gt; will be thrown.</source>
          <target state="translated">&lt;code&gt;!value&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; の場合、 &lt;code&gt;value&lt;/code&gt; が返されます。それ以外の場合は、 &lt;code&gt;new E(msg, file, line)&lt;/code&gt; がスローされます。または、 &lt;code&gt;E&lt;/code&gt; がメッセージを取得せず、 &lt;code&gt;new E(file, line)&lt;/code&gt; で構築できる場合、 &lt;code&gt;new E(file, line)&lt;/code&gt; がスローされます。</target>
        </trans-unit>
        <trans-unit id="9ae58cb23b72d887da98d9fdd1704ba37b0874fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;@live&lt;/code&gt; functions call non-&lt;code&gt;@live&lt;/code&gt; functions, those called functions are expected to present an &lt;code&gt;@live&lt;/code&gt; compatible interface, although it is not checked. if non-&lt;code&gt;@live&lt;/code&gt; functions call &lt;code&gt;@live&lt;/code&gt; functions, arguments passed are expected to follow &lt;code&gt;@live&lt;/code&gt; conventions.</source>
          <target state="translated">場合 &lt;code&gt;@live&lt;/code&gt; 機能が非呼び出す &lt;code&gt;@live&lt;/code&gt; 機能を、それらと呼ばれる機能を提供することが期待されている &lt;code&gt;@live&lt;/code&gt; それがチェックされていないものの、互換性のあるインターフェイスを。非場合 &lt;code&gt;@live&lt;/code&gt; 関数が呼び出す &lt;code&gt;@live&lt;/code&gt; 機能を、渡された引数が続くことが予想される &lt;code&gt;@live&lt;/code&gt; 規則を。</target>
        </trans-unit>
        <trans-unit id="e70bac81fdcc8ee63f8a6ffecb44cdbcf2f794c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has no state, the resulting object is allocated in static shared storage.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; に状態がない場合、結果のオブジェクトは静的共有ストレージに割り当てられます。</target>
        </trans-unit>
        <trans-unit id="7b2c6010fe0ff7fc814ba13aa84690947c8cb83d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has state and is copyable, the result will &lt;a href=&quot;std_algorithm_mutation#move&quot;&gt;&lt;code&gt;std.algorithm.mutation.move&lt;/code&gt;&lt;/a&gt; the supplied allocator &lt;code&gt;A a&lt;/code&gt; within. The result itself is allocated in its own statically-typed allocator.</source>
          <target state="translated">場合 &lt;code&gt;A&lt;/code&gt; は状態を有し、コピー可能であり、結果はます&lt;a href=&quot;std_algorithm_mutation#move&quot;&gt; &lt;code&gt;std.algorithm.mutation.move&lt;/code&gt; &lt;/a&gt;付属アロケータ &lt;code&gt;A a&lt;/code&gt; を内。結果自体は、静的に型付けされた独自のアロケーターに割り当てられます。</target>
        </trans-unit>
        <trans-unit id="e90491f805af73197e670ba7dcdbdea4f3f9187b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has state and is not copyable, the result will move the passed-in argument into the result. The result itself is allocated in its own statically-typed allocator.</source>
          <target state="translated">場合 &lt;code&gt;A&lt;/code&gt; は状態を持っており、コピーできません、結果は結果に渡された引数を移動します。結果自体は、静的に型付けされた独自のアロケーターに割り当てられます。</target>
        </trans-unit>
        <trans-unit id="8e3921430ef3c9cb639e4397d8b838ecfe391c50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has state, the result will &lt;a href=&quot;std_algorithm_mutation#move&quot;&gt;&lt;code&gt;std.algorithm.mutation.move&lt;/code&gt;&lt;/a&gt; the supplied allocator &lt;code&gt;A a&lt;/code&gt; within. The result itself is allocated in its own statically-typed allocator.</source>
          <target state="translated">場合 &lt;code&gt;A&lt;/code&gt; は状態を有し、その結果、あろう&lt;a href=&quot;std_algorithm_mutation#move&quot;&gt; &lt;code&gt;std.algorithm.mutation.move&lt;/code&gt; &lt;/a&gt;付属アロケータ &lt;code&gt;A a&lt;/code&gt; を内。結果自体は、静的に型付けされた独自のアロケーターに割り当てられます。</target>
        </trans-unit>
        <trans-unit id="85c9db39cbb0a223dde8b65577a816ac4ae74ca1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Allocator&lt;/code&gt; implements &lt;code&gt;owns&lt;/code&gt;, forwards to it. Otherwise, returns &lt;code&gt;Ternary.unknown&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Allocator&lt;/code&gt; が &lt;code&gt;owns&lt;/code&gt; を実装している場合は、それに転送します。それ以外の場合は、 &lt;code&gt;Ternary.unknown&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="602c75c69645dadebf41e326ef28dced33652078" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BookkeepingAllocator&lt;/code&gt; is not &lt;code&gt;NullAllocator&lt;/code&gt;, &lt;code&gt;bkalloc&lt;/code&gt; is defined and accessible.</source>
          <target state="translated">&lt;code&gt;BookkeepingAllocator&lt;/code&gt; が &lt;code&gt;NullAllocator&lt;/code&gt; でない場合、 &lt;code&gt;bkalloc&lt;/code&gt; が定義され、アクセス可能です。</target>
        </trans-unit>
        <trans-unit id="e61003ea748193c575ad061853d1dd56eb5e4c1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ElementType!R&lt;/code&gt; is a floating-point type and &lt;code&gt;R&lt;/code&gt; is a finite input range (but not a random-access range with slicing), then &lt;code&gt;sum&lt;/code&gt; uses the &lt;a href=&quot;http://en.wikipedia.org/wiki/Kahan_summation&quot;&gt;Kahan summation&lt;/a&gt; algorithm.</source>
          <target state="translated">場合 &lt;code&gt;ElementType!R&lt;/code&gt; 浮動小数点型であり、そして &lt;code&gt;R&lt;/code&gt; は、有限の入力範囲（ただし、スライシングとランダムアクセス範囲）であり、次いで、 &lt;code&gt;sum&lt;/code&gt; 使用&lt;a href=&quot;http://en.wikipedia.org/wiki/Kahan_summation&quot;&gt;カハン加算&lt;/a&gt;アルゴリズム。</target>
        </trans-unit>
        <trans-unit id="fc27324f1313ac32b98b4d9a0fcd3f12a5ee0a27" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ElementType!R&lt;/code&gt; is a floating-point type and &lt;code&gt;R&lt;/code&gt; is a finite input range (but not a random-access range with slicing), then &lt;code&gt;sum&lt;/code&gt; uses the &lt;a href=&quot;https://en.wikipedia.org/wiki/Kahan_summation&quot;&gt;Kahan summation&lt;/a&gt; algorithm.</source>
          <target state="translated">場合 &lt;code&gt;ElementType!R&lt;/code&gt; 浮動小数点型であり、そして &lt;code&gt;R&lt;/code&gt; は、有限の入力範囲（ただし、スライシングとランダムアクセス範囲）であり、次いで、 &lt;code&gt;sum&lt;/code&gt; 使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Kahan_summation&quot;&gt;カハン加算&lt;/a&gt;アルゴリズム。</target>
        </trans-unit>
        <trans-unit id="e00af2edb93d47ac443e7418f444a801ea32bd2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FreeList&lt;/code&gt; has been instantiated with &lt;code&gt;maxSize == chooseAtRuntime&lt;/code&gt;, then the &lt;code&gt;max&lt;/code&gt; property is writable. Setting it must precede any allocation.</source>
          <target state="translated">&lt;code&gt;FreeList&lt;/code&gt; が &lt;code&gt;maxSize == chooseAtRuntime&lt;/code&gt; でインスタンス化されている場合、 &lt;code&gt;max&lt;/code&gt; プロパティは書き込み可能です。設定は、割り当ての前に行う必要があります。</target>
        </trans-unit>
        <trans-unit id="619bff2f62db09894cc368f16063c71698b3e91a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FreeList&lt;/code&gt; has been instantiated with &lt;code&gt;minSize == chooseAtRuntime&lt;/code&gt;, then the &lt;code&gt;min&lt;/code&gt; property is writable. Setting it must precede any allocation.</source>
          <target state="translated">&lt;code&gt;FreeList&lt;/code&gt; が &lt;code&gt;minSize == chooseAtRuntime&lt;/code&gt; でインスタンス化されている場合、 &lt;code&gt;min&lt;/code&gt; プロパティは書き込み可能です。設定は、割り当ての前に行う必要があります。</target>
        </trans-unit>
        <trans-unit id="614802dd9535195f4c34d795221ff4407109b94d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;hookOpOpAssign&lt;/code&gt;, &lt;code&gt;opOpAssign&lt;/code&gt; forwards to &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt;, where &lt;code&gt;payload&lt;/code&gt; is a reference to the internally held data so the hook can change it.</source>
          <target state="translated">&lt;code&gt;Hook&lt;/code&gt; が &lt;code&gt;hookOpOpAssign&lt;/code&gt; を定義している場合、 &lt;code&gt;opOpAssign&lt;/code&gt; は &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt; に転送します。ここで、 &lt;code&gt;payload&lt;/code&gt; は内部的に保持されているデータへの参照であり、フックによって変更できます。</target>
        </trans-unit>
        <trans-unit id="6213f7b3e2cf0b3c2b2e856da1c03c2c3603a41e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hook&lt;/code&gt; does not define &lt;code&gt;hookOpBinary&lt;/code&gt; but defines &lt;code&gt;onOverflow&lt;/code&gt;, &lt;code&gt;opBinary&lt;/code&gt; forwards to &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; in case an overflow occurs.</source>
          <target state="translated">場合は &lt;code&gt;Hook&lt;/code&gt; 定義されていません &lt;code&gt;hookOpBinary&lt;/code&gt; が、定義を &lt;code&gt;onOverflow&lt;/code&gt; 、 &lt;code&gt;opBinary&lt;/code&gt; に転送 &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; の場合では、オーバーフローが発生します。</target>
        </trans-unit>
        <trans-unit id="48a7fb4afe12c2822acfff866c271812d59b89d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hook&lt;/code&gt; does not define &lt;code&gt;hookOpUnary&lt;/code&gt; but defines &lt;code&gt;onOverflow&lt;/code&gt;, &lt;code&gt;opUnary&lt;/code&gt; forwards to &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; in case an overflow occurs. For &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;, the payload is assigned from the result of the call to &lt;code&gt;onOverflow&lt;/code&gt;.</source>
          <target state="translated">場合は &lt;code&gt;Hook&lt;/code&gt; 定義されていません &lt;code&gt;hookOpUnary&lt;/code&gt; をしかし定義 &lt;code&gt;onOverflow&lt;/code&gt; 、 &lt;code&gt;opUnary&lt;/code&gt; に転送 &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; オーバーフローが発生した場合には。 &lt;code&gt;++&lt;/code&gt; と &lt;code&gt;--&lt;/code&gt; 、ペイロードはへの呼び出しの結果から割り当てられ &lt;code&gt;onOverflow&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10cd8aa857d486ec2d02cef4465f8ceb45e4e90d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; holds state, &lt;code&gt;parent&lt;/code&gt; is a public member of type &lt;code&gt;KRRegion&lt;/code&gt;. Otherwise, &lt;code&gt;parent&lt;/code&gt; is an &lt;code&gt;alias&lt;/code&gt; for &lt;code&gt;ParentAllocator.instance&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ParentAllocator&lt;/code&gt; が状態を保持している場合、 &lt;code&gt;parent&lt;/code&gt; は &lt;code&gt;KRRegion&lt;/code&gt; 型のパブリックメンバーです。それ以外の場合、 &lt;code&gt;parent&lt;/code&gt; は &lt;code&gt;ParentAllocator.instance&lt;/code&gt; の &lt;code&gt;alias&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3bbccd514894e82c4ce13569d09888036cf3359f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; is &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;, only the constructor taking &lt;code&gt;data&lt;/code&gt; is defined and the user is responsible for freeing &lt;code&gt;data&lt;/code&gt; if desired.</source>
          <target state="translated">&lt;code&gt;ParentAllocator&lt;/code&gt; が&lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt; &lt;code&gt;NullAllocator&lt;/code&gt; の&lt;/a&gt;場合、 &lt;code&gt;data&lt;/code&gt; を取得するコンストラクターのみが定義され、ユーザーは必要に応じて &lt;code&gt;data&lt;/code&gt; を解放する必要があります。</target>
        </trans-unit>
        <trans-unit id="d42312f5e4b477adba48781c375b173d6250fd1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; is different from &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Region&lt;/code&gt; deallocates the chunk of memory during destruction.</source>
          <target state="translated">場合 &lt;code&gt;ParentAllocator&lt;/code&gt; が異なっている&lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt; &lt;code&gt;NullAllocator&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;Region&lt;/code&gt; 破壊中にメモリのチャンクの割り当てを解除します。</target>
        </trans-unit>
        <trans-unit id="9a65e34991edf1fabbde944025e9467eaa28acfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; is stateful, &lt;code&gt;parent&lt;/code&gt; is a property giving access to an &lt;code&gt;AffixAllocator!ParentAllocator&lt;/code&gt;. Otherwise, &lt;code&gt;parent&lt;/code&gt; is an alias for &lt;code&gt;AffixAllocator!ParentAllocator.instance&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ParentAllocator&lt;/code&gt; がステートフルの場合、 &lt;code&gt;parent&lt;/code&gt; は &lt;code&gt;AffixAllocator!ParentAllocator&lt;/code&gt; へのアクセスを提供するプロパティです。それ以外の場合、 &lt;code&gt;parent&lt;/code&gt; は &lt;code&gt;AffixAllocator!ParentAllocator.instance&lt;/code&gt; のエイリアスです。</target>
        </trans-unit>
        <trans-unit id="43d333c4fd79ece4dce7180ff004a1dd304cfda4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Prefix&lt;/code&gt; is &lt;code&gt;void&lt;/code&gt;, the alignment is that of the parent. Otherwise, the alignment is the same as the &lt;code&gt;Prefix&lt;/code&gt;'s alignment.</source>
          <target state="translated">場合は &lt;code&gt;Prefix&lt;/code&gt; あり &lt;code&gt;void&lt;/code&gt; 、アライメントは、親のことです。それ以外の場合、配置は &lt;code&gt;Prefix&lt;/code&gt; の配置と同じです。</target>
        </trans-unit>
        <trans-unit id="6ef958a14b28e8a87e35d39d726513cf1a24e3ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Prefix&lt;/code&gt; is not &lt;code&gt;void&lt;/code&gt;, &lt;code&gt;Allocator&lt;/code&gt; must guarantee an alignment at least as large as &lt;code&gt;Prefix.alignof&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Prefix&lt;/code&gt; が &lt;code&gt;void&lt;/code&gt; でない場合、 &lt;code&gt;Allocator&lt;/code&gt; は少なくとも &lt;code&gt;Prefix.alignof&lt;/code&gt; と同じ大きさの配置を保証する必要があります。</target>
        </trans-unit>
        <trans-unit id="4bde56d414db390f6de687beeb6a7de19e32b07b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; defines a destructor, the generated code for &lt;code&gt;opAssign&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;S&lt;/code&gt; がデストラクタを定義する場合、 &lt;code&gt;opAssign&lt;/code&gt; に対して生成されるコードは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="8fa12abad24500172f1e1f4de478a1e097e94f32" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; does not have a postblit or a destructor, but contains at least one field that defines an &lt;code&gt;opAssign&lt;/code&gt; function (which is not disabled), then the body will make member-wise assignments:</source>
          <target state="translated">場合は &lt;code&gt;S&lt;/code&gt; が postblitまたはデストラクタを持っていますが、定義された少なくとも一つのフィールドが含まれていません &lt;code&gt;opAssign&lt;/code&gt; （無効になっていない）機能を、そして身体はメンバーごとの割り当てを行います。</target>
        </trans-unit>
        <trans-unit id="135d5e0bd9ac5cff9f359e01e49ee96d18ba1175" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; has a disabled destructor or at least one field that has a disabled &lt;code&gt;opAssign&lt;/code&gt;, &lt;code&gt;S.opAssign&lt;/code&gt; is going to be generated, but marked with &lt;code&gt;@disable&lt;/code&gt;</source>
          <target state="translated">場合は &lt;code&gt;S&lt;/code&gt; が無効になってい無効デストラクタまたは少なくとも一つのフィールドがある &lt;code&gt;opAssign&lt;/code&gt; を、 &lt;code&gt;S.opAssign&lt;/code&gt; が生成されることになるだろうが、でマークされ &lt;code&gt;@disable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e5d3671bcdce32a3ae79160f07ed6d9617aa8c77" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Source&lt;/code&gt; has structural conformance with the &lt;code&gt;interface&lt;/code&gt;&lt;code&gt;Targets&lt;/code&gt;, wrap creates an internal wrapper class which inherits &lt;code&gt;Targets&lt;/code&gt; and wraps the &lt;code&gt;src&lt;/code&gt; object, then returns it.</source>
          <target state="translated">&lt;code&gt;Source&lt;/code&gt; が &lt;code&gt;interface&lt;/code&gt; &lt;code&gt;Targets&lt;/code&gt; に構造的に準拠している場合、wrapは &lt;code&gt;Targets&lt;/code&gt; を継承して &lt;code&gt;src&lt;/code&gt; オブジェクトをラップする内部ラッパークラスを作成し、それを返します。</target>
        </trans-unit>
        <trans-unit id="a6a1c6b133b0871dee66034a379d92385c6acfa0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Source&lt;/code&gt; is a forward range, the resulting range will be forward ranges as well. Otherwise, the resulting chunks will be input ranges consuming the same input: iterating over &lt;code&gt;front&lt;/code&gt; will shrink the chunk such that subsequent invocations of &lt;code&gt;front&lt;/code&gt; will no longer return the full chunk, and calling &lt;code&gt;popFront&lt;/code&gt; on the outer range will invalidate any lingering references to previous values of &lt;code&gt;front&lt;/code&gt;.</source>
          <target state="translated">場合は &lt;code&gt;Source&lt;/code&gt; 前進レンジで、結果の範囲は、同様に、前方の範囲になります。繰り返し処理：それ以外の場合は、得られたチャンクは、同じ入力を消費入力範囲となり &lt;code&gt;front&lt;/code&gt; の後続の呼び出しことチャンクは、収縮する &lt;code&gt;front&lt;/code&gt; もはや完全なチャンクを返し、呼び出し &lt;code&gt;popFront&lt;/code&gt; の外側範囲にする前の値への余韻の参照を無効にします &lt;code&gt;front&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68e4c36f3a209b42eda6036b89cfd912aefdf8d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;StopWatch.init&lt;/code&gt; is used, then the constructed StopWatch isn't running (and can't be, since no constructor ran).</source>
          <target state="translated">&lt;code&gt;StopWatch.init&lt;/code&gt; が使用されている場合、構築されたStopWatchは実行されていません（コンストラクターが実行されていないため、実行できません）。</target>
        </trans-unit>
        <trans-unit id="8fa16aaee056c365a9ba1b96bbf4c7ab3e0c7909" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Store&lt;/code&gt; is a range, the &lt;code&gt;BinaryHeap&lt;/code&gt; cannot grow beyond the size of that range. If &lt;code&gt;Store&lt;/code&gt; is a container that supports &lt;code&gt;insertBack&lt;/code&gt;, the &lt;code&gt;BinaryHeap&lt;/code&gt; may grow by adding elements to the container.</source>
          <target state="translated">場合 &lt;code&gt;Store&lt;/code&gt; が範囲で、 &lt;code&gt;BinaryHeap&lt;/code&gt; その範囲の大きさを超えて成長することはできません。場合 &lt;code&gt;Store&lt;/code&gt; がサポートするコンテナである &lt;code&gt;insertBack&lt;/code&gt; を、 &lt;code&gt;BinaryHeap&lt;/code&gt; コンテナに要素を追加することによって成長します。</target>
        </trans-unit>
        <trans-unit id="dbe0360bc543f33ed0b90fcff8d9687e9b9ea633" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type, returns a reference to the created &lt;code&gt;T&lt;/code&gt; object. Otherwise, returns a &lt;code&gt;T*&lt;/code&gt; pointing to the created object. In all cases, returns &lt;code&gt;null&lt;/code&gt; if allocation failed.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; がクラス型の場合、作成された &lt;code&gt;T&lt;/code&gt; オブジェクトへの参照を返します。それ以外の場合は、作成されたオブジェクトを指す &lt;code&gt;T*&lt;/code&gt; 返します。すべての場合において、割り当てが失敗した場合は &lt;code&gt;null&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="85b009305a8588231d9cf9c49742c5425d7c6707" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a nested struct, the context pointer in &lt;code&gt;T.init&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; がネストされた構造体の場合、 &lt;code&gt;T.init&lt;/code&gt; のコンテキストポインターは &lt;code&gt;null&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="86a83fbe1dd6e8e6329df1be326be31fbac7542c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a struct which has &lt;code&gt;@disable this();&lt;/code&gt;, &lt;code&gt;T.init&lt;/code&gt; might return a logically incorrect object.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が &lt;code&gt;@disable this();&lt;/code&gt; を持つ構造体の場合 、 &lt;code&gt;T.init&lt;/code&gt; は論理的に正しくないオブジェクトを返す可能性があります。</target>
        </trans-unit>
        <trans-unit id="28ecbbbd57ec70df9468c10b69230725191bde07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a struct with a destructor or postblit defined, source is reset to its &lt;code&gt;.init&lt;/code&gt; value after it is moved into target, otherwise it is left unchanged.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; がデストラクタまたはポストブリットが定義された構造体である場合、ソースはターゲットに移動された後、 &lt;code&gt;.init&lt;/code&gt; 値にリセットされます。それ以外の場合、ソースは変更されません。</target>
        </trans-unit>
        <trans-unit id="be0ddbf38059d4859dc637f9816765cfecd51bd9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a value type, then &lt;code&gt;Unique!T&lt;/code&gt; will be implemented as a reference to a &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; は値型である、そして &lt;code&gt;Unique!T&lt;/code&gt; 参照として実装されます &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ad884b639da3b067a89fc2f9254b6e884145e3b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an inner class whose &lt;code&gt;outer&lt;/code&gt; field can be used to access an instance of the enclosing class, then &lt;code&gt;Args&lt;/code&gt; must not be empty, and the first member of it must be a valid initializer for that &lt;code&gt;outer&lt;/code&gt; field. Correct initialization of this field is essential to access members of the outer class inside &lt;code&gt;T&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; が &lt;code&gt;outer&lt;/code&gt; クラスを使用して外側のクラスのインスタンスにアクセスできる内部クラスの場合、 &lt;code&gt;Args&lt;/code&gt; は空であってはならず、その最初のメンバーはその &lt;code&gt;outer&lt;/code&gt; フィールドの有効な初期化子でなければなりません。このフィールドの正しい初期化は、 &lt;code&gt;T&lt;/code&gt; メソッド内の外部クラスのメンバーにアクセスするために不可欠です。</target>
        </trans-unit>
        <trans-unit id="5e5dca16a0b08e551a0873d6f42ddf6d816c0620" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt;'s constructor throws, deallocates the allocated memory and propagates the exception.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; のコンストラクターがスローした場合、割り当てられたメモリの割り当てを解除し、例外を伝播します。</target>
        </trans-unit>
        <trans-unit id="f9ccf6d42185874390122acb61e0fffade4a1d7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;U&lt;/code&gt; is also an instance of &lt;code&gt;Checked&lt;/code&gt;, both hooks (left- and right-hand side) are introspected for the method &lt;code&gt;hookOpCmp&lt;/code&gt;. If both define it, priority is given to the left-hand side.</source>
          <target state="translated">場合 &lt;code&gt;U&lt;/code&gt; はまた、のインスタンスで &lt;code&gt;Checked&lt;/code&gt; 、両方のフック（左右側）メソッドのためにイントロスペクトさ &lt;code&gt;hookOpCmp&lt;/code&gt; 。両方で定義した場合、左側が優先されます。</target>
        </trans-unit>
        <trans-unit id="f714d4a1a2b46c6585bd14b3632f61dc774fe527" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;U&lt;/code&gt; is also an instance of &lt;code&gt;Checked&lt;/code&gt;, both hooks (left- and right-hand side) are introspected for the method &lt;code&gt;hookOpEquals&lt;/code&gt;. If both define it, priority is given to the left-hand side.</source>
          <target state="translated">場合 &lt;code&gt;U&lt;/code&gt; はまた、のインスタンスで &lt;code&gt;Checked&lt;/code&gt; 、両方のフック（左右側）メソッドのためにイントロスペクトさ &lt;code&gt;hookOpEquals&lt;/code&gt; 。両方で定義した場合、左側が優先されます。</target>
        </trans-unit>
        <trans-unit id="6530603e838c2a2e64b1bcfb9217be83aec2dafc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Yes.checkDns&lt;/code&gt; then a DNS check for MX records will be made</source>
          <target state="translated">&lt;code&gt;Yes.checkDns&lt;/code&gt; の場合、MXレコードのDNSチェックが行われます</target>
        </trans-unit>
        <trans-unit id="a1992ec3ad4038c0370a2f08b90896545a010903" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Yes.pipeOnPop&lt;/code&gt;, simply iterating the range without ever calling &lt;code&gt;front&lt;/code&gt; is enough to have &lt;code&gt;tee&lt;/code&gt; mirror elements to &lt;code&gt;outputRange&lt;/code&gt; (or, respectively, &lt;code&gt;fun&lt;/code&gt;). If &lt;code&gt;No.pipeOnPop&lt;/code&gt;, only elements for which &lt;code&gt;front&lt;/code&gt; does get called will be also sent to &lt;code&gt;outputRange&lt;/code&gt;/&lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;Yes.pipeOnPop&lt;/code&gt; 、単にこれまでに呼び出すことなく、範囲を反復 &lt;code&gt;front&lt;/code&gt; 持っているのに十分である &lt;code&gt;tee&lt;/code&gt; にミラー素子を &lt;code&gt;outputRange&lt;/code&gt; （それぞれまたは、 &lt;code&gt;fun&lt;/code&gt; ）。 &lt;code&gt;No.pipeOnPop&lt;/code&gt; の場合、 &lt;code&gt;front&lt;/code&gt; が呼び出される要素のみが &lt;code&gt;outputRange&lt;/code&gt; / &lt;code&gt;fun&lt;/code&gt; にも送信されます。</target>
        </trans-unit>
        <trans-unit id="7a50176d4624d41b95b9071257e16a7702021f98" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Yes.pipeOnPop&lt;/code&gt;, simply iterating the range without ever calling &lt;code&gt;front&lt;/code&gt; is enough to have &lt;code&gt;tee&lt;/code&gt; mirror elements to &lt;code&gt;outputRange&lt;/code&gt; (or, respectively, &lt;code&gt;fun&lt;/code&gt;). Note that each &lt;code&gt;popFront()&lt;/code&gt; call will mirror the old &lt;code&gt;front&lt;/code&gt; value, not the new one. This means that the last value will not be forwarded if the range isn't iterated until empty. If &lt;code&gt;No.pipeOnPop&lt;/code&gt;, only elements for which &lt;code&gt;front&lt;/code&gt; does get called will be also sent to &lt;code&gt;outputRange&lt;/code&gt;/&lt;code&gt;fun&lt;/code&gt;. If &lt;code&gt;front&lt;/code&gt; is called twice for the same element, it will still be sent only once. If this caching is undesired, consider using &lt;a href=&quot;std_algorithm_iteration#map&quot;&gt;&lt;code&gt;std.algorithm.iteration.map&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">場合 &lt;code&gt;Yes.pipeOnPop&lt;/code&gt; 、単にこれまでに呼び出すことなく、範囲を反復 &lt;code&gt;front&lt;/code&gt; 持っているのに十分である &lt;code&gt;tee&lt;/code&gt; にミラー素子を &lt;code&gt;outputRange&lt;/code&gt; （それぞれまたは、 &lt;code&gt;fun&lt;/code&gt; ）。各 &lt;code&gt;popFront()&lt;/code&gt; 呼び出しは、新しい値ではなく、古い &lt;code&gt;front&lt;/code&gt; 値をミラーリングすることに注意してください。これは、範囲が空になるまで繰り返されない場合、最後の値が転送されないことを意味します。 &lt;code&gt;No.pipeOnPop&lt;/code&gt; の場合、 &lt;code&gt;front&lt;/code&gt; が呼び出される要素のみが &lt;code&gt;outputRange&lt;/code&gt; / &lt;code&gt;fun&lt;/code&gt; にも送信されます。 &lt;code&gt;front&lt;/code&gt; 場合同じ要素に対して2回呼び出されても、1回だけ送信されます。このキャッシュが望ましくない場合は、代わりに&lt;a href=&quot;std_algorithm_iteration#map&quot;&gt; &lt;code&gt;std.algorithm.iteration.map&lt;/code&gt; の&lt;/a&gt;使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="6b44ae6759ea792f0bca17c48004575c328a9fdc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = &quot;abcde&quot;&lt;/code&gt;, then &lt;code&gt;findSkip(a, &quot;x&quot;)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; and leaves &lt;code&gt;a&lt;/code&gt; unchanged, whereas &lt;code&gt;findSkip(a, &quot;c&quot;)&lt;/code&gt; advances &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;&quot;de&quot;&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;a = &quot;abcde&quot;&lt;/code&gt; 、次いで &lt;code&gt;findSkip(a, &quot;x&quot;)&lt;/code&gt; を返し &lt;code&gt;false&lt;/code&gt; 葉に対し、不変 &lt;code&gt;findSkip(a, &quot;c&quot;)&lt;/code&gt; 進むと &lt;code&gt;&quot;de&quot;&lt;/code&gt; 戻る &lt;code&gt;true&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22d1d40c86b33d24346ec7f18b6caa5014b1c725" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; and &lt;code&gt;b = [4, 5, 6, 7]&lt;/code&gt;, &lt;code&gt;bringToFront(a, b)&lt;/code&gt; leaves &lt;code&gt;a = [4, 5, 6]&lt;/code&gt; and &lt;code&gt;b = [7, 1, 2, 3]&lt;/code&gt;.</source>
          <target state="translated">もし &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; 及び &lt;code&gt;b = [4, 5, 6, 7]&lt;/code&gt; 、 &lt;code&gt;bringToFront(a, b)&lt;/code&gt; 葉 &lt;code&gt;a = [4, 5, 6]&lt;/code&gt; と &lt;code&gt;b = [7, 1, 2, 3]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="161672661d076244bfa4e1cb23db5cb7cee3f0b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [1, 2, 3]&lt;/code&gt;, &lt;code&gt;reverse(a)&lt;/code&gt; changes it to &lt;code&gt;[3, 2, 1]&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; 、 &lt;code&gt;reverse(a)&lt;/code&gt; に変更し &lt;code&gt;[3, 2, 1]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c20592a36a578c54537352b677f5ac5e2a4bd22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [1.2, 3.4]&lt;/code&gt;, then &lt;code&gt;initializeAll(a)&lt;/code&gt; leaves &lt;code&gt;a = [double.init, double.init]&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;a = [1.2, 3.4]&lt;/code&gt; 、その後 &lt;code&gt;initializeAll(a)&lt;/code&gt; 葉 &lt;code&gt;a = [double.init, double.init]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f19fe74876068eb9761e0ed018d3efe050a2dc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [10, 20, 30]&lt;/code&gt; and &lt;code&gt;b = [40, 6, 15]&lt;/code&gt;, then &lt;code&gt;completeSort(a, b)&lt;/code&gt; leaves &lt;code&gt;a = [6, 10, 15]&lt;/code&gt; and &lt;code&gt;b = [20, 30, 40]&lt;/code&gt;. The range &lt;code&gt;a&lt;/code&gt; must be sorted prior to the call, and as a result the combination &lt;code&gt;&lt;a href=&quot;std_range#chain&quot;&gt;std.range.chain&lt;/a&gt;(a, b)&lt;/code&gt; is sorted.</source>
          <target state="translated">もし &lt;code&gt;a = [10, 20, 30]&lt;/code&gt; と &lt;code&gt;b = [40, 6, 15]&lt;/code&gt; 、次いで &lt;code&gt;completeSort(a, b)&lt;/code&gt; 葉 &lt;code&gt;a = [6, 10, 15]&lt;/code&gt; と &lt;code&gt;b = [20, 30, 40]&lt;/code&gt; 。範囲 &lt;code&gt;a&lt;/code&gt; は呼び出しの前にソートする必要があり、その結果、組み合わせ &lt;code&gt;&lt;a href=&quot;std_range#chain&quot;&gt;std.range.chain&lt;/a&gt;(a, b)&lt;/code&gt; がソートされます。</target>
        </trans-unit>
        <trans-unit id="8653b5c90f101e5bb8cf18c8696bdaa4b97980b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [5, 4, 3, 2, 1]&lt;/code&gt;, then &lt;code&gt;partialSort(a, 3)&lt;/code&gt; leaves &lt;code&gt;a[0 .. 3] = [1, 2, 3]&lt;/code&gt;. The other elements of &lt;code&gt;a&lt;/code&gt; are left in an unspecified order.</source>
          <target state="translated">場合 &lt;code&gt;a = [5, 4, 3, 2, 1]&lt;/code&gt; 次に、 &lt;code&gt;partialSort(a, 3)&lt;/code&gt; 出る &lt;code&gt;a[0 .. 3] = [1, 2, 3]&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt; の他の要素は、不特定の順序で残されます。</target>
        </trans-unit>
        <trans-unit id="761844ca385c58407529b15b7f0264a9fdc0b35e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;allowDuplicates&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, then inserting the same element more than once continues to add more elements. If it is &lt;code&gt;false&lt;/code&gt;, duplicate elements are ignored on insertion. If duplicates are allowed, then new elements are inserted after all existing duplicate elements.</source>
          <target state="translated">場合 &lt;code&gt;allowDuplicates&lt;/code&gt; がに設定されている &lt;code&gt;true&lt;/code&gt; 、その後複数回同一の要素を挿入する複数の要素を追加し続けます。 &lt;code&gt;false&lt;/code&gt; の場合、重複した要素は挿入時に無視されます。重複が許可されている場合は、既存のすべての重複要素の後に新しい要素が挿入されます。</target>
        </trans-unit>
        <trans-unit id="42df331db67fcac4570e8d97255c06bf51fcef31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arr.length &amp;lt; delta&lt;/code&gt;, does nothing and returns &lt;code&gt;false&lt;/code&gt;. Otherwise, destroys the last &lt;code&gt;arr.length - delta&lt;/code&gt; elements in the array and then reallocates the array's buffer. If reallocation fails, fills the array with default-initialized data.</source>
          <target state="translated">&lt;code&gt;arr.length &amp;lt; delta&lt;/code&gt; 場合、何もせずに &lt;code&gt;false&lt;/code&gt; を返します。それ以外の場合は、配列の最後の &lt;code&gt;arr.length - delta&lt;/code&gt; 要素を破棄してから、配列のバッファーを再割り当てします。再割り当てが失敗した場合、配列をデフォルトで初期化されたデータで埋めます。</target>
        </trans-unit>
        <trans-unit id="73774d72a77acb4ae5cc4817197c7e3cc39e3e8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;array.length &amp;lt; delta&lt;/code&gt;, does nothing and returns &lt;code&gt;false&lt;/code&gt;. Otherwise, destroys the last &lt;code&gt;array.length - delta&lt;/code&gt; elements in the array and then reallocates the array's buffer. If reallocation fails, fills the array with default-initialized data.</source>
          <target state="translated">&lt;code&gt;array.length &amp;lt; delta&lt;/code&gt; 場合、何もせずに &lt;code&gt;false&lt;/code&gt; を返します。それ以外の場合は、最後の &lt;code&gt;array.length - delta&lt;/code&gt; 配列のデルタ要素を破棄してから、配列のバッファーを再割り当てします。再割り当てが失敗した場合、配列をデフォルトで初期化されたデータで埋めます。</target>
        </trans-unit>
        <trans-unit id="7b4fa4088c1f332dc1cc2c07bd6dcf7ba46787dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b is null&lt;/code&gt;, does nothing and returns &lt;code&gt;true&lt;/code&gt;. Otherwise, deallocates memory previously allocated with this allocator and returns &lt;code&gt;true&lt;/code&gt; if successful, &lt;code&gt;false&lt;/code&gt; otherwise. An implementation that would not support deallocation (i.e. would always return &lt;code&gt;false&lt;/code&gt; should not define this primitive at all.)</source>
          <target state="translated">&lt;code&gt;b is null&lt;/code&gt; 場合、何もせずに &lt;code&gt;true&lt;/code&gt; を返します。それ以外の場合は、このアロケータで以前に割り当てられたメモリの割り当てを解除し、成功した場合は &lt;code&gt;true&lt;/code&gt; 、それ以外の場合は &lt;code&gt;false&lt;/code&gt; を返します。割り当て解除をサポートしない実装（つまり、常に &lt;code&gt;false&lt;/code&gt; を返す実装）では、このプリミティブをまったく定義しないでください。</target>
        </trans-unit>
        <trans-unit id="8bae244a830c8d1176da79e2579d3599e88c12f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ba&lt;/code&gt; is zero (the default) the attributes of the existing memory will be used for an allocation. If &lt;code&gt;ba&lt;/code&gt; is not zero and no new memory is allocated, the bits in ba will replace those of the current memory block.</source>
          <target state="translated">場合 &lt;code&gt;ba&lt;/code&gt; ゼロ（デフォルト）で、既存のメモリの属性は、割り当てに使用されます。 &lt;code&gt;ba&lt;/code&gt; がゼロでなく、新しいメモリが割り当てられていない場合、baのビットが現在のメモリブロックのビットを置き換えます。</target>
        </trans-unit>
        <trans-unit id="221a7c0321e1759235e9e5a40274abe6cabee406" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;block.length&lt;/code&gt; is within &lt;code&gt;[min, max]&lt;/code&gt; or if the free list is unchecked (&lt;code&gt;minSize == 0 &amp;amp;&amp;amp; maxSize == size_t.max&lt;/code&gt;), then inserts the block at the front of the free list. For all others, forwards to &lt;code&gt; parent.deallocate&lt;/code&gt; if &lt;code&gt;Parent.deallocate&lt;/code&gt; is defined.</source>
          <target state="translated">場合 &lt;code&gt;block.length&lt;/code&gt; は以内である &lt;code&gt;[min, max]&lt;/code&gt; またはフリーリストが（未チェックである場合 &lt;code&gt;minSize == 0 &amp;amp;&amp;amp; maxSize == size_t.max&lt;/code&gt; ）、次いで、フリーリストの先頭にブロックを挿入します。他のすべてのために、転送する &lt;code&gt; parent.deallocate&lt;/code&gt; 場合 &lt;code&gt;Parent.deallocate&lt;/code&gt; が定義されています。</target>
        </trans-unit>
        <trans-unit id="5e4b98282d9ecdaaa0277f0ab4f62ad8d1b53af5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt;, &lt;code&gt;BitmappedBlock&lt;/code&gt; offers a read/write property &lt;code&gt;blockSize&lt;/code&gt;. It must be set before any use of the allocator. Otherwise (i.e. &lt;code&gt;theBlockSize&lt;/code&gt; is a legit constant), &lt;code&gt;blockSize&lt;/code&gt; is an alias for &lt;code&gt;theBlockSize&lt;/code&gt;. Whether constant or variable, must also be a multiple of &lt;code&gt;alignment&lt;/code&gt;. This constraint is &lt;code&gt;assert&lt;/code&gt;ed statically and dynamically.</source>
          <target state="translated">&lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt; 場合、 &lt;code&gt;BitmappedBlock&lt;/code&gt; は読み取り/書き込みプロパティ &lt;code&gt;blockSize&lt;/code&gt; を提供します。アロケータを使用する前に設定する必要があります。それ以外の場合（つまり、 &lt;code&gt;theBlockSize&lt;/code&gt; は正当な定数です）、 &lt;code&gt;blockSize&lt;/code&gt; は &lt;code&gt;theBlockSize&lt;/code&gt; のエイリアスです。定数でも変数でも、 &lt;code&gt;alignment&lt;/code&gt; の倍数でなければなりません。この制約は、静的および動的に &lt;code&gt;assert&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="f93a5a60f8514085265f3aa9ca6972ee5e3faff9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt;, &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; offers a read/write property &lt;code&gt;blockSize&lt;/code&gt;. It must be set before any use of the allocator. Otherwise (i.e. &lt;code&gt;theBlockSize&lt;/code&gt; is a legit constant), &lt;code&gt;blockSize&lt;/code&gt; is an alias for &lt;code&gt;theBlockSize&lt;/code&gt;. Whether constant or variable, must also be a multiple of &lt;code&gt;alignment&lt;/code&gt;. This constraint is &lt;code&gt;assert&lt;/code&gt;ed statically and dynamically.</source>
          <target state="translated">&lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt; 場合、 &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; は読み取り/書き込みプロパティ &lt;code&gt;blockSize&lt;/code&gt; を提供します。アロケータを使用する前に設定する必要があります。それ以外の場合（つまり、 &lt;code&gt;theBlockSize&lt;/code&gt; は正当な定数です）、 &lt;code&gt;blockSize&lt;/code&gt; は &lt;code&gt;theBlockSize&lt;/code&gt; のエイリアスです。定数でも変数でも、 &lt;code&gt;alignment&lt;/code&gt; の倍数でなければなりません。この制約は、静的および動的に &lt;code&gt;assert&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="8e23237ade60446568cde90bc631b8dba6e68c5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a Unicode lowercase &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;, then its uppercase equivalent is returned. Otherwise &lt;code&gt;c&lt;/code&gt; is returned.</source>
          <target state="translated">場合 &lt;code&gt;c&lt;/code&gt; が Unicodeの小文字である&lt;a href=&quot;#Character&quot;&gt;文字&lt;/a&gt;、その大文字が返されます。それ以外の場合は &lt;code&gt;c&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="b4c4b1af0ac218e5d7d40db7db18515091e62fd4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a Unicode uppercase &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;, then its lowercase equivalent is returned. Otherwise &lt;code&gt;c&lt;/code&gt; is returned.</source>
          <target state="translated">場合 &lt;code&gt;c&lt;/code&gt; が Unicodeの大文字&lt;a href=&quot;#Character&quot;&gt;の文字&lt;/a&gt;、その小文字相当が返されます。それ以外の場合は &lt;code&gt;c&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="9744833e493e9a4deaf2d113274c40f2b544663e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dir == Direction.fwd&lt;/code&gt;, then a range iterates forward in time, whereas if &lt;code&gt;dir == Direction.bwd&lt;/code&gt;, then it iterates backwards in time. So, if &lt;code&gt;dir == Direction.fwd&lt;/code&gt; then &lt;code&gt;front == interval.begin&lt;/code&gt;, whereas if &lt;code&gt;dir == Direction.bwd&lt;/code&gt; then &lt;code&gt;front == interval.end&lt;/code&gt;. &lt;code&gt;func&lt;/code&gt; must generate a time point going in the proper direction of iteration, or a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. So, to iterate forward in time, the time point that &lt;code&gt;func&lt;/code&gt; generates must be later in time than the one passed to it. If it's either identical or earlier in time, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. To iterate backwards, then the generated time point must be before the time point which was passed in.</source>
          <target state="translated">&lt;code&gt;dir == Direction.fwd&lt;/code&gt; 場合、範囲は時間的に前方に反復しますが、 &lt;code&gt;dir == Direction.bwd&lt;/code&gt; 場合、時間的に後方に反復します。したがって、 &lt;code&gt;dir == Direction.fwd&lt;/code&gt; 場合は、 &lt;code&gt;front == interval.begin&lt;/code&gt; ですが、 &lt;code&gt;dir == Direction.bwd&lt;/code&gt; 場合は、 &lt;code&gt;front == interval.end&lt;/code&gt; です。 &lt;code&gt;func&lt;/code&gt; は、適切な反復方向に向かう時点を生成する必要があります。そうしないと、&lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt;がスローされます。したがって、時間を先に反復するには、 &lt;code&gt;func&lt;/code&gt; が生成する時点は、渡された時点よりも遅い必要があります。同一またはそれ以前の場合、&lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt;投げられます。逆方向に反復するには、生成された時点が、渡された時点より前でなければなりません。</target>
        </trans-unit>
        <trans-unit id="a610ee5ef0581a49f22c22f37935b0d33a042c3f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;filler&lt;/code&gt; is empty.</source>
          <target state="translated">&lt;code&gt;filler&lt;/code&gt; が空の場合。</target>
        </trans-unit>
        <trans-unit id="59e6f081398b1db2fd694d5b94d19e81b02d48a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fun&lt;/code&gt; is a &lt;code&gt;string&lt;/code&gt;, a new single parameter function  If &lt;code&gt;fun&lt;/code&gt; is not a &lt;code&gt;string&lt;/code&gt;, an alias to &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">場合は &lt;code&gt;fun&lt;/code&gt; ある &lt;code&gt;string&lt;/code&gt; 場合は、新しい単一のパラメータ機能 &lt;code&gt;fun&lt;/code&gt; ない &lt;code&gt;string&lt;/code&gt; 、エイリアス &lt;code&gt;fun&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="109bcbee3e25a658c4c9396a1465014de8c69b2c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fun&lt;/code&gt; is not a string, &lt;code&gt;binaryFun&lt;/code&gt; aliases itself away to &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; が文字列でない場合、 &lt;code&gt;binaryFun&lt;/code&gt; は自分自身を &lt;code&gt;fun&lt;/code&gt; にエイリアスします。</target>
        </trans-unit>
        <trans-unit id="feeb8b9cc07251142d08e56cda48b8463e68f011" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hasLength!Range&lt;/code&gt;, simply returns &lt;code&gt;range.length&lt;/code&gt; without checking &lt;code&gt;upTo&lt;/code&gt; (when specified).</source>
          <target state="translated">場合 &lt;code&gt;hasLength!Range&lt;/code&gt; 、単に返す &lt;code&gt;range.length&lt;/code&gt; をチェックせず &lt;code&gt;upTo&lt;/code&gt; （指定した場合）。</target>
        </trans-unit>
        <trans-unit id="46b7e88c254c5bba652608bb5aa781949149f305" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;haystack&lt;/code&gt; is a random-access range, all three components of the tuple have the same type as &lt;code&gt;haystack&lt;/code&gt;. Otherwise, &lt;code&gt;haystack&lt;/code&gt; must be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; and the type of &lt;code&gt;result[0]&lt;/code&gt; and &lt;code&gt;result[1]&lt;/code&gt; is the same as &lt;a href=&quot;std_range#takeExactly&quot;&gt;&lt;code&gt;std.range.takeExactly&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">場合 &lt;code&gt;haystack&lt;/code&gt; ランダムアクセス範囲は、タプルのすべての3つの構成要素は、同じタイプ有する &lt;code&gt;haystack&lt;/code&gt; 。それ以外の場合、 &lt;code&gt;haystack&lt;/code&gt; は&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;前方の範囲&lt;/a&gt;である必要があり、 &lt;code&gt;result[0]&lt;/code&gt; および &lt;code&gt;result[1]&lt;/code&gt; のタイプは&lt;a href=&quot;std_range#takeExactly&quot;&gt; &lt;code&gt;std.range.takeExactly&lt;/code&gt; &lt;/a&gt;と同じです。</target>
        </trans-unit>
        <trans-unit id="3993b4b628968f5e6dd7d41599d550f5e0f99ef4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;impl.alignedAllocate&lt;/code&gt; exists, calls it and returns the result. Otherwise, always returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;impl.alignedAllocate&lt;/code&gt; が存在する場合は、それを呼び出して結果を返します。それ以外の場合は、常に &lt;code&gt;null&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="02ba66810cd0cea189e643c4eeba55ce0d4de3e3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;impl.deallocate&lt;/code&gt; is not defined, returns &lt;code&gt;false&lt;/code&gt;. Otherwise it forwards the call.</source>
          <target state="translated">&lt;code&gt;impl.deallocate&lt;/code&gt; が定義されていない場合は、 &lt;code&gt;false&lt;/code&gt; を返します。それ以外の場合は、コールを転送します。</target>
        </trans-unit>
        <trans-unit id="48d32ce690c5f4ef93e7705c87fc34b78de3c611" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;input&lt;/code&gt; is a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt;, &lt;code&gt;needle&lt;/code&gt; can be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; too. In this case &lt;code&gt;startsWith!pred(haystack, needle)&lt;/code&gt; is evaluated on each evaluation.</source>
          <target state="translated">場合は &lt;code&gt;input&lt;/code&gt; ある&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;前進レンジ&lt;/a&gt;、 &lt;code&gt;needle&lt;/code&gt; 可能&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;前進レンジ&lt;/a&gt;すぎ。この場合、 &lt;code&gt;startsWith!pred(haystack, needle)&lt;/code&gt; は各評価で評価されます。</target>
        </trans-unit>
        <trans-unit id="26612f521f443b434c0c471a4bb077313e418fc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;less&lt;/code&gt; is the less-than operator, which is the default option, then &lt;code&gt;BinaryHeap&lt;/code&gt; defines a so-called max-heap that optimizes extraction of the</source>
          <target state="translated">場合は &lt;code&gt;less&lt;/code&gt; より少なくよりデフォルトのオプションであるオペレータ、である、そして、 &lt;code&gt;BinaryHeap&lt;/code&gt; の抽出を最適化し、いわゆる最大ヒープを定義します</target>
        </trans-unit>
        <trans-unit id="bfc0979cbe401db983c65651eae478d6291e89b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lhs != WithNaN.defaultValue!Lhs&lt;/code&gt; and the operator does not overflow, the function returns the same result as the built-in operator. In all other cases, returns &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;lhs != WithNaN.defaultValue!Lhs&lt;/code&gt; とオペレータがオーバーフローしない、機能が内蔵された演算子と同じ結果を返します。それ以外の場合はすべて、 &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="7cc27af0c815a7e79af80d07be90722649a52810" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lhs == WithNaN.defaultValue!Lhs&lt;/code&gt;, returns &lt;code&gt;double.init&lt;/code&gt;. Otherwise, has the same semantics as the default comparison.</source>
          <target state="translated">場合 &lt;code&gt;lhs == WithNaN.defaultValue!Lhs&lt;/code&gt; 、戻り &lt;code&gt;double.init&lt;/code&gt; 。それ以外の場合、デフォルトの比較と同じセマンティクスを持ちます。</target>
        </trans-unit>
        <trans-unit id="d151dfc3083b5628c51cfe2464aced84ec2e31e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; reference the same instance, then nothing is done.</source>
          <target state="translated">場合 &lt;code&gt;lhs&lt;/code&gt; と &lt;code&gt;rhs&lt;/code&gt; 同じインスタンスを参照し、何もしません。</target>
        </trans-unit>
        <trans-unit id="1e390340bdf19475ede0638df9c1955fea065de9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;char[]&lt;/code&gt;, &lt;code&gt;wchar[]&lt;/code&gt;, &lt;code&gt;dchar[]&lt;/code&gt;, the line's content will be reused (overwritten) across reads.</source>
          <target state="translated">場合 &lt;code&gt;line&lt;/code&gt; 型有し &lt;code&gt;char[]&lt;/code&gt; 、 &lt;code&gt;wchar[]&lt;/code&gt; 、 &lt;code&gt;dchar[]&lt;/code&gt; 、行の内容を読み取り横切って（上書き）再利用されます。</target>
        </trans-unit>
        <trans-unit id="98f495eca2d1ec291e5bd0a688459f5f1c82028b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;immutable(ubyte)[]&lt;/code&gt;, the behavior is similar to case (1), except that no UTF checking is attempted upon input.</source>
          <target state="translated">場合 &lt;code&gt;line&lt;/code&gt; タイプ有する &lt;code&gt;immutable(ubyte)[]&lt;/code&gt; 、動作は、ケース（1）と同様であり、何らUTFチェックが入力されると試みていないことを除いて。</target>
        </trans-unit>
        <trans-unit id="1a835fb44628e74f7f9ff451e8b58c089bf38a93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;wstring&lt;/code&gt;, or &lt;code&gt;dstring&lt;/code&gt;, a new string of the respective type is allocated every read.</source>
          <target state="translated">場合 &lt;code&gt;line&lt;/code&gt; 型がある &lt;code&gt;string&lt;/code&gt; 、 &lt;code&gt;wstring&lt;/code&gt; の、または &lt;code&gt;dstring&lt;/code&gt; 、それぞれのタイプの新しい文字列は、すべての読み取りが割り当てられています。</target>
        </trans-unit>
        <trans-unit id="18e388959a9abaf079dbbac18945110b36067b2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;ubyte[]&lt;/code&gt;, the behavior is similar to case (2), except that no UTF checking is attempted upon input.</source>
          <target state="translated">場合 &lt;code&gt;line&lt;/code&gt; タイプ有する &lt;code&gt;ubyte[]&lt;/code&gt; 、動作は、ケース（2）と同様であり、何らUTFチェックが入力されると試みていないことを除いて。</target>
        </trans-unit>
        <trans-unit id="c61c7e699d18c7312070fee75c860133527ced6d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;main()&lt;/code&gt; or the thread returns normally, (does not throw an exception), the static destructor is added to the list of functions to be called on thread termination.</source>
          <target state="translated">場合 &lt;code&gt;main()&lt;/code&gt; またはスレッド戻ると、通常、（例外をスローしない）、静的デストラクタは、スレッドの終了時に呼び出される関数のリストに追加されます。</target>
        </trans-unit>
        <trans-unit id="c93fc296f2b731310f3189f9c017eaec2be70e3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxSize == unbounded&lt;/code&gt;, returns &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt;. Otherwise, returns &lt;code&gt;max&lt;/code&gt; for sizes in the interval &lt;code&gt;[min, max]&lt;/code&gt;, and &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;maxSize == unbounded&lt;/code&gt; 場合、 &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt; を返します。それ以外の場合は、間隔 &lt;code&gt;[min, max]&lt;/code&gt; サイズの &lt;code&gt;max&lt;/code&gt; を返し、それ以外の場合は &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="27889a42945896ba8e96a2b9190859d044697880" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt;= r.length&lt;/code&gt;, the algorithm has no effect and returns &lt;code&gt;r[0 .. r.length]&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;n &amp;gt;= r.length&lt;/code&gt; 、アルゴリズムは影響を及ぼさないと戻る &lt;code&gt;r[0 .. r.length]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c001d68799c0a0c1fe4332536339591e3128dd5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is eligible for freelisting, returns &lt;code&gt;max&lt;/code&gt;. Otherwise, returns &lt;code&gt;parent.goodAllocSize(n)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; がフリーリストの対象である場合は、 &lt;code&gt;max&lt;/code&gt; を返します。それ以外の場合は、 &lt;code&gt;parent.goodAllocSize(n)&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="0fec7ab17fff539f84df945449516192c8415a4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is not defined, an infinite random access range with slicing.  If &lt;code&gt;n&lt;/code&gt; is defined, a random access range with slicing.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; が定義されていない場合、スライシングを伴う無限のランダムアクセス範囲。 &lt;code&gt;n&lt;/code&gt; が定義されている場合、スライス付きのランダムアクセス範囲。</target>
        </trans-unit>
        <trans-unit id="7f2409b5e5208bcbd4bd9ae5b46439868d522731" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opCall&lt;/code&gt; is overridden for the struct, and the struct is initialized with a value that is of a different type, then the &lt;code&gt;opCall&lt;/code&gt; operator is called:</source>
          <target state="translated">場合 &lt;code&gt;opCall&lt;/code&gt; は、構造体のために上書きされ、構造体は、異なる型である値で初期化され、その後、 &lt;code&gt;opCall&lt;/code&gt; のオペレータが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="0a8768e44be6ce84df4d8ac63955bf151c1ba410" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opIndex&lt;/code&gt; is declared with only one argument, the compile-time argument to &lt;code&gt;opDollar&lt;/code&gt; may be omitted. In this case, it is illegal to use &lt;code&gt;$&lt;/code&gt; inside an array indexing expression with more than one argument.</source>
          <target state="translated">場合 &lt;code&gt;opIndex&lt;/code&gt; が唯一の引数で宣言されている、とコンパイル時の引数 &lt;code&gt;opDollar&lt;/code&gt; を省略することができます。この場合、複数の引数を持つ配列インデックス式内で &lt;code&gt;$&lt;/code&gt; を使用することは違法です。</target>
        </trans-unit>
        <trans-unit id="1c029e2e84868e89d9aba168477cd4b281e4a698" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a pointer somewhere inside a block allocated with this allocator, &lt;code&gt;result&lt;/code&gt; holds a pointer to the beginning of the allocated block and returns &lt;code&gt;Ternary.yes&lt;/code&gt;. Otherwise, &lt;code&gt;result&lt;/code&gt; holds &lt;code&gt;null&lt;/code&gt; and returns &lt;code&gt;Ternary.no&lt;/code&gt;. If the pointer points immediately after an allocated block, the result is implementation defined.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; がこのアロケータで割り当てられたブロック内のどこかのポインタである場合、 &lt;code&gt;result&lt;/code&gt; は割り当てられたブロックの先頭へのポインタを保持し、 &lt;code&gt;Ternary.yes&lt;/code&gt; を返します。それ以外の場合、 &lt;code&gt;result&lt;/code&gt; は &lt;code&gt;null&lt;/code&gt; を保持し、 &lt;code&gt;Ternary.no&lt;/code&gt; を返します。ポインタが割り当てられたブロックの直後を指している場合、結果は実装定義です。</target>
        </trans-unit>
        <trans-unit id="e2eb2629d5b4956bd1542eca4775455139c95a61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is a relative directory, return it unaltered.</source>
          <target state="translated">場合は &lt;code&gt;path&lt;/code&gt; 相対ディレクトリである、それは不変で返します。</target>
        </trans-unit>
        <trans-unit id="702fecc6b0bc34adfafc2cb51d268f4825e76aef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is already absolute, return it.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; がすでに絶対パスの場合は、それを返します。</target>
        </trans-unit>
        <trans-unit id="051c5165fdb7f4181c26346b52a8a370bb269c20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is empty, return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; が空の場合は &lt;code&gt;null&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="de70cd968c35f871aa7f988334ddd5070ebe64cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is on the form &lt;code&gt;\\&lt;i&gt;server&lt;/i&gt;\&lt;i&gt;share&lt;/i&gt;\...&lt;/code&gt; (UNC path), &lt;a href=&quot;#isValidFilename&quot;&gt;&lt;code&gt;isValidFilename&lt;/code&gt;&lt;/a&gt; is applied to</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; が &lt;code&gt;\\&lt;i&gt;server&lt;/i&gt;\&lt;i&gt;share&lt;/i&gt;\...&lt;/code&gt; （UNCパス）の形式の場合、&lt;a href=&quot;#isValidFilename&quot;&gt; &lt;code&gt;isValidFilename&lt;/code&gt; &lt;/a&gt;が適用されます</target>
        </trans-unit>
        <trans-unit id="5ccfc704dde80078077c0681938c9dc1e45235e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; starts with &lt;code&gt;\\.\&lt;/code&gt; (Win32 device namespace) this function returns &lt;code&gt;false&lt;/code&gt;; such paths are beyond the scope of this module.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; が &lt;code&gt;\\.\&lt;/code&gt; （Win32デバイス名前空間）で始まる場合、この関数は &lt;code&gt;false&lt;/code&gt; を返します。このようなパスは、このモジュールの範囲を超えています。</target>
        </trans-unit>
        <trans-unit id="891daee93beed99df04fb47b76bddba5d0aeec90" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; starts with &lt;code&gt;\\?\&lt;/code&gt; (long UNC path), the only requirement for the rest of the string is that it does not contain the null character.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; が &lt;code&gt;\\?\&lt;/code&gt; （長いUNCパス）で始まる場合、残りの文字列の唯一の要件は、ヌル文字を含まないことです。</target>
        </trans-unit>
        <trans-unit id="cf0839c8941b9553277dcc1246fadae5b4af51e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;postData&lt;/code&gt; is non-null the method will be set to &lt;code&gt;post&lt;/code&gt; for HTTP requests.</source>
          <target state="translated">場合 &lt;code&gt;postData&lt;/code&gt; 非nullである方法がするように設定されます &lt;code&gt;post&lt;/code&gt; HTTP要求のために。</target>
        </trans-unit>
        <trans-unit id="b45cfaf55131d31d198ea2c44bd484f7f79174d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pretty&lt;/code&gt; is false no whitespaces are generated. If &lt;code&gt;pretty&lt;/code&gt; is true serialized string is formatted to be human-readable. Set the &lt;a href=&quot;#JSONOptions.specialFloatLiterals&quot;&gt;&lt;code&gt;JSONOptions.specialFloatLiterals&lt;/code&gt;&lt;/a&gt; flag is set in &lt;code&gt;options&lt;/code&gt; to encode NaN/Infinity as strings.</source>
          <target state="translated">&lt;code&gt;pretty&lt;/code&gt; がfalseの場合、空白は生成されません。場合は &lt;code&gt;pretty&lt;/code&gt; 真シリアライズされた文字列である人間が読めるようにフォーマットされています。設定&lt;a href=&quot;#JSONOptions.specialFloatLiterals&quot;&gt; &lt;code&gt;JSONOptions.specialFloatLiterals&lt;/code&gt; の&lt;/a&gt;フラグが設定された &lt;code&gt;options&lt;/code&gt; 文字列としてのNaN /インフィニティをコードします。</target>
        </trans-unit>
        <trans-unit id="4fe6d0c26964bd6dde3a76798f875b6541f56e6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;primary&lt;/code&gt; does not own &lt;code&gt;b&lt;/code&gt;, then &lt;code&gt;fallback.reallocate(b, newSize)&lt;/code&gt; is attempted. If that fails, an attempt is made to move the allocation from &lt;code&gt;fallback&lt;/code&gt; to &lt;code&gt;primary&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;primary&lt;/code&gt; が &lt;code&gt;b&lt;/code&gt; を所有していない場合は、 &lt;code&gt;fallback.reallocate(b, newSize)&lt;/code&gt; が試行されます。それが失敗した場合、割り当てを &lt;code&gt;fallback&lt;/code&gt; から &lt;code&gt;primary&lt;/code&gt; に移動する試みが行われます。</target>
        </trans-unit>
        <trans-unit id="45d84a0c7a2f66706678e328dd9e74e78023bd34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;printf&lt;/code&gt;-style logging is needed add a &lt;b&gt;f&lt;/b&gt; to the logging call, such as &lt;code&gt;myLogger.infof(&quot;Hello %s&quot;, &quot;world&quot;);&lt;/code&gt; or &lt;code&gt;fatalf(&quot;errno %d&quot;, 1337)&lt;/code&gt;. The additional &lt;b&gt;f&lt;/b&gt; appended to the function name enables &lt;code&gt;printf&lt;/code&gt;-style logging for all combinations of explicit &lt;code&gt;LogLevel&lt;/code&gt; and conditional logging functions and methods.</source>
          <target state="translated">&lt;code&gt;printf&lt;/code&gt; スタイルのロギングが必要な場合は、 &lt;code&gt;myLogger.infof(&quot;Hello %s&quot;, &quot;world&quot;);&lt;/code&gt; などの&lt;b&gt;f&lt;/b&gt;をロギング呼び出しに追加します。または &lt;code&gt;fatalf(&quot;errno %d&quot;, 1337)&lt;/code&gt; 。追加の&lt;b&gt;F&lt;/b&gt;関数名に付加が可能 &lt;code&gt;printf&lt;/code&gt; の明示のすべての組み合わせについてスタイルログを &lt;code&gt;LogLevel&lt;/code&gt; と、条件付きロギング機能および方法。</target>
        </trans-unit>
        <trans-unit id="c809d18303614396b533b1264943fb0bf373af22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; contains equivalent elements, multiple permutations of &lt;code&gt;r&lt;/code&gt; satisfy these constraints. In such cases, &lt;code&gt;pivotPartition&lt;/code&gt; attempts to distribute equivalent elements fairly to the left and right of &lt;code&gt;k&lt;/code&gt; such that &lt;code&gt;k&lt;/code&gt; stays close to &lt;code&gt;r.length / 2&lt;/code&gt;.</source>
          <target state="translated">場合は &lt;code&gt;r&lt;/code&gt; が同等の要素が含まれ、複数の順列 &lt;code&gt;r&lt;/code&gt; はこれらの制約を満たします。このような場合、 &lt;code&gt;pivotPartition&lt;/code&gt; は、 &lt;code&gt;k&lt;/code&gt; が &lt;code&gt;r.length / 2&lt;/code&gt; 近くに留まるように、同等の要素を &lt;code&gt;k&lt;/code&gt; の左側と右側に均等に分散しようとします。</target>
        </trans-unit>
        <trans-unit id="23935d946a100a97c3e455c30306a633f7b98438" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; has a length, then this is &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;). Otherwise, it's &amp;Omicron;(&lt;code&gt;r.length&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; に長さがある場合、これは&amp;Omicron;（ &lt;code&gt;1&lt;/code&gt; ）です。それ以外の場合は、&amp;Omicron;（ &lt;code&gt;r.length&lt;/code&gt; ）です。</target>
        </trans-unit>
        <trans-unit id="f163286db8bb098fc5cc4073249e55f06a301b9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is a string with Unicode characters in it, &lt;code&gt;padLeft&lt;/code&gt; follows D's rules about length for strings, which is not the number of characters, or graphemes, but instead the number of encoding units. If you want to treat each grapheme as only one encoding unit long, then call &lt;a href=&quot;std_uni#byGrapheme&quot;&gt;&lt;code&gt;std.uni.byGrapheme&lt;/code&gt;&lt;/a&gt; before calling this function.</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; がUnicode文字を含む文字列の場合、 &lt;code&gt;padLeft&lt;/code&gt; は文字列の長さに関するDの規則に従います。これは、文字数や書記素ではなく、エンコーディングユニットの数です。各書記素を1つのエンコーディングユニットとしてのみ扱いたい場合は、この関数を呼び出す前に&lt;a href=&quot;std_uni#byGrapheme&quot;&gt; &lt;code&gt;std.uni.byGrapheme&lt;/code&gt; &lt;/a&gt;を呼び出します。</target>
        </trans-unit>
        <trans-unit id="6a927ae2914fb825262976485c0cc9304c3da3c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is not an auto-decodable string (i.e. a narrow string or a user-defined type that implicits converts to a string type), then &lt;code&gt;r&lt;/code&gt; is returned.  Otherwise, &lt;code&gt;r&lt;/code&gt; is converted to its corresponding string type (if it's not already a string) and wrapped in a random-access range where the element encoding type of the string (its code unit) is the element type of the range, and that range returned. The range has slicing.  If &lt;code&gt;r&lt;/code&gt; is quirky enough to be a struct or class which is an input range of characters on its own (i.e. it has the input range API as member functions),</source>
          <target state="translated">場合 &lt;code&gt;r&lt;/code&gt; は自己復号可能な文字列（すなわち、狭い文字列またはユーザー定義型文字列型への暗黙の変換もの）ではない場合、 &lt;code&gt;r&lt;/code&gt; 返されます。それ以外の場合、 &lt;code&gt;r&lt;/code&gt; は対応する文字列型に変換され（まだ文字列でない場合）、ランダムアクセス範囲にラップされます。ランダムアクセス範囲では、文字列の要素エンコードタイプ（そのコード単位）が範囲の要素タイプであり、その範囲戻ってきた。範囲にはスライスがあります。 &lt;code&gt;r&lt;/code&gt; が、それ自体が文字の入力範囲である構造体またはクラスになるのに十分風変わりである場合（つまり、メンバー関数として入力範囲APIを持っている場合）、</target>
        </trans-unit>
        <trans-unit id="df6a47c8f433360081103c7b545791ca9cd35f93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;range&lt;/code&gt; does not have length, and &lt;code&gt;popFront&lt;/code&gt; is called when &lt;code&gt;front.index == Enumerator.max&lt;/code&gt;, the index will overflow and continue from &lt;code&gt;Enumerator.min&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;range&lt;/code&gt; 長さを持っていない、と &lt;code&gt;popFront&lt;/code&gt; をしたときに呼び出され &lt;code&gt;front.index == Enumerator.max&lt;/code&gt; 、インデックスがオーバーフローしてから続行します &lt;code&gt;Enumerator.min&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e2389187db9ad1c90dc2cdb963a735557c21c35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;range&lt;/code&gt; has length, then it is an error to pass a value for &lt;code&gt;start&lt;/code&gt; so that &lt;code&gt;start + range.length&lt;/code&gt; is bigger than &lt;code&gt;Enumerator.max&lt;/code&gt;, thus it is ensured that overflow cannot happen.</source>
          <target state="translated">場合 &lt;code&gt;range&lt;/code&gt; 長さを有し、値渡すエラーで &lt;code&gt;start&lt;/code&gt; するように &lt;code&gt;start + range.length&lt;/code&gt; より大きい &lt;code&gt;Enumerator.max&lt;/code&gt; 、従ってそれはオーバーフローが発生しないことが保証されます。</target>
        </trans-unit>
        <trans-unit id="111a596bfe5993b016245842df9ecb465a3674d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rhs != WithNaN.defaultValue!Rhs&lt;/code&gt; and the operator does not overflow, the function returns the same result as the built-in operator. In all other cases, returns &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;rhs != WithNaN.defaultValue!Rhs&lt;/code&gt; とオペレータがオーバーフローしない、機能が内蔵された演算子と同じ結果を返します。それ以外の場合はすべて、 &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="f5536ec979292168bf217723d15877e765427904" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rhs&lt;/code&gt; is &lt;code&gt;WithNaN.defaultValue!Rhs&lt;/code&gt;, returns &lt;code&gt;WithNaN.defaultValue!Lhs&lt;/code&gt;. Otherwise, returns &lt;code&gt;cast(Lhs) rhs&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;rhs&lt;/code&gt; ある &lt;code&gt;WithNaN.defaultValue!Rhs&lt;/code&gt; 、返し &lt;code&gt;WithNaN.defaultValue!Lhs&lt;/code&gt; 。それ以外の場合は、 &lt;code&gt;cast(Lhs) rhs&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="6ede40fbc0f7d83884db066a6386fc8a519d5ed8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s == 0&lt;/code&gt;, the call may return any empty slice (including &lt;code&gt;null&lt;/code&gt;). Otherwise, the call allocates &lt;code&gt;s&lt;/code&gt; bytes of memory and returns the allocated block, or &lt;code&gt;null&lt;/code&gt; if the request could not be satisfied.</source>
          <target state="translated">もし &lt;code&gt;s == 0&lt;/code&gt; 、コールは（を含む任意の空のスライスを返すことができる &lt;code&gt;null&lt;/code&gt; ）。それ以外の場合、呼び出しは &lt;code&gt;s&lt;/code&gt; バイトのメモリを割り当て、割り当てられたブロックを返すか、要求が満たされない場合は &lt;code&gt;null&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="9eadce3ccc140e91f7b505d0328ee8cc176eeac6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s == SwapStrategy.unstable &amp;amp;&amp;amp; isRandomAccessRange!Range &amp;amp;&amp;amp; hasLength!Range &amp;amp;&amp;amp; hasLvalueElements!Range&lt;/code&gt;, then elements are moved from the end of the range into the slots to be filled. In this case, the absolute minimum of moves is performed.</source>
          <target state="translated">場合 &lt;code&gt;s == SwapStrategy.unstable &amp;amp;&amp;amp; isRandomAccessRange!Range &amp;amp;&amp;amp; hasLength!Range &amp;amp;&amp;amp; hasLvalueElements!Range&lt;/code&gt; スロットを充填するには、要素は、範囲の端から移動されます。この場合、移動の絶対最小値が実行されます。</target>
        </trans-unit>
        <trans-unit id="8bbc6063db8df4c25b1d7ab2586ea771801923fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a function template, i.e. the only member of a template and that member is a function, return that template.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; が関数テンプレートである場合、つまりテンプレートの唯一のメンバーであり、そのメンバーが関数である場合、そのテンプレートを返します。</target>
        </trans-unit>
        <trans-unit id="ac063e0ae979bd086a87ed636e906eb9690bf4e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str&lt;/code&gt; ends with &lt;code&gt;delimiter&lt;/code&gt;, then &lt;code&gt;str&lt;/code&gt; is returned without &lt;code&gt;delimiter&lt;/code&gt; on its end. If it &lt;code&gt;str&lt;/code&gt; does</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; が &lt;code&gt;delimiter&lt;/code&gt; で終わっている場合、 &lt;code&gt;str&lt;/code&gt; はその終わりに &lt;code&gt;delimiter&lt;/code&gt; なしで返されます。それは場合は &lt;code&gt;str&lt;/code&gt; ありません</target>
        </trans-unit>
        <trans-unit id="9a851969ac104167dbde2b6f580e63232a655ac8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str&lt;/code&gt; starts with &lt;code&gt;delimiter&lt;/code&gt;, then the part of &lt;code&gt;str&lt;/code&gt; following &lt;code&gt;delimiter&lt;/code&gt; is returned. If &lt;code&gt;str&lt;/code&gt; does</source>
          <target state="translated">場合 &lt;code&gt;str&lt;/code&gt; がで始まる &lt;code&gt;delimiter&lt;/code&gt; 、その後の一部 &lt;code&gt;str&lt;/code&gt; 以下の &lt;code&gt;delimiter&lt;/code&gt; 返されます。 &lt;code&gt;str&lt;/code&gt; が行う場合</target>
        </trans-unit>
        <trans-unit id="4978f696ceefb2aa4374b5f4ce674343dc8b0fed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sz&lt;/code&gt; is zero, the memory referenced by p will be deallocated as if by a call to &lt;code&gt;free&lt;/code&gt;. If &lt;code&gt;p&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, new memory will be allocated via &lt;code&gt;malloc&lt;/code&gt;. If &lt;code&gt;p&lt;/code&gt; is pointing to memory not allocated from the GC or to the interior of an allocated memory block, no operation is performed and null is returned.</source>
          <target state="translated">場合 &lt;code&gt;sz&lt;/code&gt; がゼロであり、pの参照メモリは、呼び出しによってかのように割り当て解除されます &lt;code&gt;free&lt;/code&gt; 。 &lt;code&gt;p&lt;/code&gt; が &lt;code&gt;null&lt;/code&gt; の場合、新しいメモリは &lt;code&gt;malloc&lt;/code&gt; を介して割り当てられます。 &lt;code&gt;p&lt;/code&gt; がGCから割り当てられていないメモリまたは割り当てられたメモリブロックの内部を指している場合、操作は実行されず、nullが返されます。</target>
        </trans-unit>
        <trans-unit id="b756c4e80a3354d029916e71e883d1d288090aff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ticksPerSec&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, then then &lt;code&gt;TickDuration&lt;/code&gt; failed to get the value of &lt;code&gt;ticksPerSec&lt;/code&gt; on the current system, and &lt;code&gt;TickDuration&lt;/code&gt; is not going to work. That would be highly abnormal though.</source>
          <target state="translated">場合 &lt;code&gt;ticksPerSec&lt;/code&gt; がある &lt;code&gt;0&lt;/code&gt; 、そしてその後、 &lt;code&gt;TickDuration&lt;/code&gt; は、値の取得に失敗しました &lt;code&gt;ticksPerSec&lt;/code&gt; 現在のシステムでは、と &lt;code&gt;TickDuration&lt;/code&gt; は仕事に行くのではありません。それは非常に異常です。</target>
        </trans-unit>
        <trans-unit id="0a174cf4ab1d67c6c049d75173bd4c15d10ca6f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeval.tv_sec&lt;/code&gt; is int, and the result can't fit in an int, then the closest value that can be held in 32 bits will be used for &lt;code&gt;tv_sec&lt;/code&gt;. (so &lt;code&gt;int.max&lt;/code&gt; if it goes over and &lt;code&gt;int.min&lt;/code&gt; if it goes under).</source>
          <target state="translated">場合 &lt;code&gt;timeval.tv_sec&lt;/code&gt; が intで、その結果がintに収まらないことができ、次いで、32ビットで保持することができる最も近い値が使用されます &lt;code&gt;tv_sec&lt;/code&gt; の。（そのため、 &lt;code&gt;int.max&lt;/code&gt; ばint.maxになり、 &lt;code&gt;int.min&lt;/code&gt; とint.minになります）。</target>
        </trans-unit>
        <trans-unit id="b737bf16441ab6f2f4b4d91936f54afa2de4c527" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;toHash&lt;/code&gt; must consistently be the same value when &lt;code&gt;opEquals&lt;/code&gt; returns true. In other words, two objects that are considered equal should always have the same hash value. Otherwise, undefined behavior will result.</source>
          <target state="translated">&lt;code&gt;opEquals&lt;/code&gt; がtrueを返す場合、 &lt;code&gt;toHash&lt;/code&gt; は常に同じ値でなければなりません。つまり、等しいと見なされる2つのオブジェクトは、常に同じハッシュ値を持つ必要があります。そうしないと、未定義の動作が発生します。</target>
        </trans-unit>
        <trans-unit id="46b829bd712225872ea6d9fe14e82ebf07db56c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;toHash&lt;/code&gt; must consistently be the same value when &lt;code&gt;opEquals&lt;/code&gt; returns true. In other words, two structs that are considered equal should always have the same hash value. Otherwise, undefined behavior will result.</source>
          <target state="translated">&lt;code&gt;opEquals&lt;/code&gt; がtrueを返す場合、 &lt;code&gt;toHash&lt;/code&gt; は常に同じ値でなければなりません。つまり、等しいと見なされる2つの構造体は常に同じハッシュ値を持つ必要があります。そうしないと、未定義の動作が発生します。</target>
        </trans-unit>
        <trans-unit id="bdd34bf58210d81d6b36b3924a3e5089f87b29e6" translate="yes" xml:space="preserve">
          <source>If B to A conversion is convariant that requires offseet adjusting, all return statements should be adjusted to return expressions typed A.</source>
          <target state="translated">BからAへの変換が、オフセットの調整を必要とする畳み込み式である場合、すべてのリターン文は、A型のリターン式に調整されるべきである。</target>
        </trans-unit>
        <trans-unit id="5f616405142623769cdbbf978f769d6bf8291c51" translate="yes" xml:space="preserve">
          <source>If JSON value is null, then operator initializes it with object and then sets &lt;code&gt;value&lt;/code&gt; for it.</source>
          <target state="translated">JSON値がnullの場合、オペレーターはそれをオブジェクトで初期化してから、 &lt;code&gt;value&lt;/code&gt; を設定します。</target>
        </trans-unit>
        <trans-unit id="b3d334f3b16094aef354285c2c419452a7b589ea" translate="yes" xml:space="preserve">
          <source>If Source is a &lt;code&gt;struct&lt;/code&gt; then wrapping/unwrapping will create a copy; it is not possible to affect the original &lt;code&gt;struct&lt;/code&gt; through the wrapper.</source>
          <target state="translated">Sourceが &lt;code&gt;struct&lt;/code&gt; 場合、ラップ/アンラップはコピーを作成します。ラッパーを介して元の &lt;code&gt;struct&lt;/code&gt; に影響を与えることはできません。</target>
        </trans-unit>
        <trans-unit id="2e8ce4614eba95d281d33d622683800da451bb90" translate="yes" xml:space="preserve">
          <source>If Statement</source>
          <target state="translated">ステートメント</target>
        </trans-unit>
        <trans-unit id="dd4a3f3a81119e68ec01207d19a926cbd1e5f669" translate="yes" xml:space="preserve">
          <source>If Targets has only one entry and Source is a class which explicitly implements it, wrap simply returns src upcasted to &lt;code&gt;Targets[0]&lt;/code&gt;.</source>
          <target state="translated">Targetsにエントリが1つしかなく、Sourceがそれを明示的に実装するクラスである場合、wrapは単に &lt;code&gt;Targets[0]&lt;/code&gt; アップキャストされたsrcを返します。</target>
        </trans-unit>
        <trans-unit id="562d6a085d036935dc458e97eb2b83b32b781d44" translate="yes" xml:space="preserve">
          <source>If a</source>
          <target state="translated">の場合は</target>
        </trans-unit>
        <trans-unit id="38354ffb09e774c4e1e6d7b1ae1d349a56902b44" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;declaration#StructInitializer&quot;&gt;&lt;i&gt;StructInitializer&lt;/i&gt;&lt;/a&gt; is supplied, the fields are initialized by the &lt;a href=&quot;declaration#StructMemberInitializer&quot;&gt;&lt;i&gt;StructMemberInitializer&lt;/i&gt;&lt;/a&gt; syntax.</source>
          <target state="translated">場合&lt;a href=&quot;declaration#StructInitializer&quot;&gt;&lt;i&gt;StructInitializerが&lt;/i&gt;&lt;/a&gt;供給され、フィールドがで初期化され&lt;a href=&quot;declaration#StructMemberInitializer&quot;&gt;&lt;i&gt;StructMemberInitializerの&lt;/i&gt;&lt;/a&gt;構文。</target>
        </trans-unit>
        <trans-unit id="d74a8d147475df621b5e8ac9d1c6cc1de44dcbfd" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;union S&lt;/code&gt; has fields that define a copy constructor, whenever an object of type &lt;code&gt;S&lt;/code&gt; is initialized by copy, an error will be issued. The same rule applies to overlapped fields (anonymous unions).</source>
          <target state="translated">場合は &lt;code&gt;union S&lt;/code&gt; コピーコンストラクタを定義するフィールドを持っている型のオブジェクトたび、 &lt;code&gt;S&lt;/code&gt; はコピーによって初期化され、エラーが発行されます。同じルールが重複フィールド（匿名ユニオン）にも適用されます。</target>
        </trans-unit>
        <trans-unit id="82eb1a8a8a78d51182899822b5022de27e60420b" translate="yes" xml:space="preserve">
          <source>If a and b are both class objects, then the expression is rewritten as:</source>
          <target state="translated">aとbが両方ともクラスオブジェクトであれば、式は次のように書き換えられます。</target>
        </trans-unit>
        <trans-unit id="5e7e375e1c7dad6e65f441c0e60a25b131f8701e" translate="yes" xml:space="preserve">
          <source>If a cast to a floating-point type is requested and &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;onBadCast&lt;/code&gt;, the cast is verified by ensuring &lt;code&gt;get == cast(T) U(get)&lt;/code&gt;. If that is not &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; is returned.</source>
          <target state="translated">浮動小数点型へのキャストが要求され、 &lt;code&gt;Hook&lt;/code&gt; &lt;code&gt;onBadCast&lt;/code&gt; を定義している場合、そのキャストは、 &lt;code&gt;get == cast(T) U(get)&lt;/code&gt; 確実にすることによって検証されます。それが &lt;code&gt;true&lt;/code&gt; でない場合、 &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="214d150104c62cbd9a8df607ea8c5c4b3837548b" translate="yes" xml:space="preserve">
          <source>If a cast to an integral type is requested and &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;onBadCast&lt;/code&gt;, the cast is verified by ensuring &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;cast(U) get&lt;/code&gt; are the same arithmetic number. (Note that &lt;code&gt;int(-1)&lt;/code&gt; and &lt;code&gt;uint(1)&lt;/code&gt; are different values arithmetically although they have the same bitwise representation and compare equal by language rules.) If the numbers are not arithmetically equal, &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; is returned.</source>
          <target state="translated">整数型へのキャストが要求され、 &lt;code&gt;Hook&lt;/code&gt; &lt;code&gt;onBadCast&lt;/code&gt; を定義している場合、 &lt;code&gt;get&lt;/code&gt; と &lt;code&gt;cast(U) get&lt;/code&gt; が同じ算術数であることを確認することにより、キャストが検証されます。（ &lt;code&gt;int(-1)&lt;/code&gt; と &lt;code&gt;uint(1)&lt;/code&gt; は、同じビットごとの表現を持ち、言語規則によって等しいと比較されますが、算術的に異なる値であることに注意してください。）数値が算術的に等しくない場合、 &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; が返されます。 。</target>
        </trans-unit>
        <trans-unit id="f50b34e635f5b3d69730e335c13e613f658b1407" translate="yes" xml:space="preserve">
          <source>If a choice's return type is void, the choice must throw an exception, unless all the choices are void. In that case, castSwitch itself will return void.</source>
          <target state="translated">選択肢の戻り値の型が void の場合、すべての選択肢が void でない限り、選択肢は例外を投げなければなりません。その場合、castSwitch 自体は void を返します。</target>
        </trans-unit>
        <trans-unit id="fb6d0d046ebbfc4f31bb86cf82620af737d82d69" translate="yes" xml:space="preserve">
          <source>If a constructor's code contains a delegate constructor call, all possible execution paths through the constructor must make exactly one delegate constructor call:</source>
          <target state="translated">コンストラクタのコードにデリゲート コンストラクタの呼び出しが含まれている場合、コンストラクタを介して実行可能なすべてのパスは、正確に 1 回のデリゲート コンストラクタ呼び出しを行う必要があります。</target>
        </trans-unit>
        <trans-unit id="289f1bcf6286485bf50554692831db27b58239e4" translate="yes" xml:space="preserve">
          <source>If a constructor's code contains a delegating constructor call, all possible execution paths through the constructor must make exactly one delegating constructor call:</source>
          <target state="translated">コンストラクタのコードに委譲型コンストラクタの呼び出しが含まれている場合、コンストラクタを介して実行可能なすべてのパスは、正確に 1 つの委譲型コンストラクタの呼び出しを行う必要があります。</target>
        </trans-unit>
        <trans-unit id="74c7db79dd1c4bbec318c1afec835bd55146cddb" translate="yes" xml:space="preserve">
          <source>If a copy constructor is defined, implicit calls to it will be inserted in the following situations:</source>
          <target state="translated">コピーコンストラクタが定義されている場合、以下のような状況では、それに対する暗黙の呼び出しが挿入されます。</target>
        </trans-unit>
        <trans-unit id="3a4c5302b387be4ef4923c3da45ea70ef8244969" translate="yes" xml:space="preserve">
          <source>If a declaration is followed by a documented unittest, the code in the unittest will be inserted in the &lt;b&gt;example&lt;/b&gt; section of the declaration:</source>
          <target state="translated">宣言の後に文書化された単体テストが続く場合、単体テストのコードが宣言の&lt;b&gt;サンプル&lt;/b&gt;セクションに挿入されます。</target>
        </trans-unit>
        <trans-unit id="994d2a230df4885735f193cf875a7c34425353d8" translate="yes" xml:space="preserve">
          <source>If a declaration starts with a</source>
          <target state="translated">宣言が</target>
        </trans-unit>
        <trans-unit id="5abfec0c9b70a28afdd54a250553e480e8e7f188" translate="yes" xml:space="preserve">
          <source>If a delegate is passed, the safety and purity of this function are inferred from &lt;code&gt;Dg&lt;/code&gt;'s safety and purity.</source>
          <target state="translated">デリゲートが渡された場合、この関数の安全性と純度は、 &lt;code&gt;Dg&lt;/code&gt; の安全性と純度から推測されます。</target>
        </trans-unit>
        <trans-unit id="ea319443f8c57e701d411ba01a8cc3309299df11" translate="yes" xml:space="preserve">
          <source>If a delegate that accepts a &lt;a href=&quot;std_variant#Variant&quot;&gt;&lt;code&gt;std.variant.Variant&lt;/code&gt;&lt;/a&gt; is included as the last argument to &lt;code&gt;receive&lt;/code&gt;, it will match any message that was not matched by an earlier delegate. If more than one argument is sent, the &lt;code&gt;Variant&lt;/code&gt; will contain a &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt; of all values sent.</source>
          <target state="translated">&lt;a href=&quot;std_variant#Variant&quot;&gt; &lt;code&gt;std.variant.Variant&lt;/code&gt; &lt;/a&gt;を受け入れるデリゲートが &lt;code&gt;receive&lt;/code&gt; の最後の引数として含まれている場合、それは以前のデリゲートによって一致しなかったすべてのメッセージと一致します。複数の引数が送信される場合、 &lt;code&gt;Variant&lt;/code&gt; は送信されたすべての値の&lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt;が含まれます。</target>
        </trans-unit>
        <trans-unit id="7c6073aed324734814b1c5af997eb904b7a1d366" translate="yes" xml:space="preserve">
          <source>If a delegate that accepts a &lt;a href=&quot;std_variant#Variant&quot;&gt;&lt;code&gt;std.variant.Variant&lt;/code&gt;&lt;/a&gt; is included as the last argument, it will match any message that was not matched by an earlier delegate. If more than one argument is sent, the &lt;code&gt;Variant&lt;/code&gt; will contain a &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt; of all values sent.</source>
          <target state="translated">&lt;a href=&quot;std_variant#Variant&quot;&gt; &lt;code&gt;std.variant.Variant&lt;/code&gt; &lt;/a&gt;を受け入れるデリゲートが最後の引数として含まれている場合、それは以前のデリゲートによって一致しなかったすべてのメッセージと一致します。複数の引数が送信された場合、 &lt;code&gt;Variant&lt;/code&gt; は送信されたすべての値の&lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt;が含まれます。</target>
        </trans-unit>
        <trans-unit id="6772ca1fa3a50c56b1e2254d50cd48e0b56364df" translate="yes" xml:space="preserve">
          <source>If a delegating constructor is not called, a call to the base class's default constructor is issued.</source>
          <target state="translated">委譲コンストラクタが呼び出されない場合は、基底クラスのデフォルトコンストラクタへの呼び出しが行われます。</target>
        </trans-unit>
        <trans-unit id="881137e036e5d861dacc5e49c7e5ec6d46042221" translate="yes" xml:space="preserve">
          <source>If a derived class overrides a base class member function with diferrent &lt;a href=&quot;#FunctionAttributes&quot;&gt;&lt;i&gt;FunctionAttributes&lt;/i&gt;&lt;/a&gt;, the missing attributes will be automatically compensated by the compiler.</source>
          <target state="translated">派生クラスが異なる&lt;a href=&quot;#FunctionAttributes&quot;&gt;&lt;i&gt;FunctionAttributes&lt;/i&gt;&lt;/a&gt;で基本クラスのメンバー関数をオーバーライドする場合、不足している属性はコンパイラーによって自動的に補正されます。</target>
        </trans-unit>
        <trans-unit id="9133da665b338dc9f2d280b762259fd2a4cf7d31" translate="yes" xml:space="preserve">
          <source>If a derived class overrides a base class member function with different &lt;a href=&quot;#FunctionAttributes&quot;&gt;&lt;i&gt;FunctionAttributes&lt;/i&gt;&lt;/a&gt;, the missing attributes will be automatically compensated by the compiler.</source>
          <target state="translated">派生クラスが異なる&lt;a href=&quot;#FunctionAttributes&quot;&gt;&lt;i&gt;FunctionAttributesを&lt;/i&gt;&lt;/a&gt;持つ基本クラスのメンバー関数をオーバーライドする場合、欠落している属性はコンパイラーによって自動的に補正されます。</target>
        </trans-unit>
        <trans-unit id="b01bf1413dae9a84ffd106c13e7efc616299cc07" translate="yes" xml:space="preserve">
          <source>If a documentation comment for a declaration consists only of the identifier &lt;code&gt;ditto&lt;/code&gt; then the documentation comment for the previous declaration at the same declaration scope is applied to this declaration as well.</source>
          <target state="translated">宣言のドキュメンテーションコメントが識別子 &lt;code&gt;ditto&lt;/code&gt; のみで構成されている場合、同じ宣言スコープの前の宣言のドキュメンテーションコメントがこの宣言にも適用されます。</target>
        </trans-unit>
        <trans-unit id="3415ea6dfee5691668c1c8232a3e5910eb9c73a0" translate="yes" xml:space="preserve">
          <source>If a field's type has disabled default construction, then it must be initialized in the constructor.</source>
          <target state="translated">フィールドの型がデフォルトの構築を無効にしている場合は、コンストラクタで初期化する必要があります。</target>
        </trans-unit>
        <trans-unit id="d8f6fa7fc0afa2680299befa1345222924cf9276" translate="yes" xml:space="preserve">
          <source>If a floating literal has a &lt;b&gt;.&lt;/b&gt; and a type suffix, at least one digit must be in-between:</source>
          <target state="translated">浮動リテラルに&lt;b&gt;。&lt;/b&gt;型の接尾辞。少なくとも1桁はその間にある必要があります。</target>
        </trans-unit>
        <trans-unit id="3a19adb71ebefd9a28ba0c9b27281e67156dc538" translate="yes" xml:space="preserve">
          <source>If a floating literal is followed by &lt;b&gt;i&lt;/b&gt;, then it is an</source>
          <target state="translated">浮動リテラルの後に&lt;b&gt;i&lt;/b&gt;が続く場合、それは</target>
        </trans-unit>
        <trans-unit id="8d8575d274fd6277028e0c2b41501d26b560a2c4" translate="yes" xml:space="preserve">
          <source>If a function attempts to test itself for those attributes, then the function is inferred as not having those attributes.</source>
          <target state="translated">関数がこれらの属性について自身をテストしようとした場合、関数はこれらの属性を持っていないと推論されます。</target>
        </trans-unit>
        <trans-unit id="a4a6cb5bd72ee43c0b82dda81af5fd129c286fde" translate="yes" xml:space="preserve">
          <source>If a function call passes no explicit argument, i.e. it would syntactically use &lt;code&gt;()&lt;/code&gt;, then these parentheses may be omitted, similar to a getter invocation of a &lt;a href=&quot;#property-functions&quot;&gt;property function&lt;/a&gt;.</source>
          <target state="translated">関数呼び出しが明示的な引数を渡さない場合、つまり構文的に &lt;code&gt;()&lt;/code&gt; を使用する場合、&lt;a href=&quot;#property-functions&quot;&gt;プロパティ関数の&lt;/a&gt;ゲッター呼び出しと同様に、これらの括弧を省略できます。</target>
        </trans-unit>
        <trans-unit id="3e7b8dc0678edabe73fefcc44809c2cbac6174ce" translate="yes" xml:space="preserve">
          <source>If a function in a derived class overrides a function from its super class, then only one of the &lt;code&gt;in&lt;/code&gt; contracts of the function and its base functions must be satisfied. Overriding functions then becomes a process of</source>
          <target state="translated">派生クラスの関数がそのスーパークラスの関数をオーバーライドする場合、関数とその基本関数の &lt;code&gt;in&lt;/code&gt; コントラクトの1つのみが満たされる必要があります。関数をオーバーライドすると、</target>
        </trans-unit>
        <trans-unit id="833166b5c67f31578b3c0dc74c8f4637740cb9ae" translate="yes" xml:space="preserve">
          <source>If a function returns a delegate or function pointer, the parantheses are required if the returned value is to be called.</source>
          <target state="translated">関数がデリゲートや関数ポインタを返す場合、返された値が呼び出される場合には、そのparanthesesが必要になります。</target>
        </trans-unit>
        <trans-unit id="3fb0c821f0139e65cc3fa8dd141873150a7b34b1" translate="yes" xml:space="preserve">
          <source>If a function returns a delegate or function pointer, the parentheses are required if the returned value is to be called.</source>
          <target state="translated">関数がデリゲートや関数ポインタを返す場合、返された値が呼び出される場合は括弧が必要です。</target>
        </trans-unit>
        <trans-unit id="a1d31581f409e137dd612d786dd84ed15f076e6f" translate="yes" xml:space="preserve">
          <source>If a function with an untyped parameter is specified, this function is called when the variant contains a type that does not match any other function. This can be used to apply the same function across multiple possible types. Exactly one generic function is allowed.</source>
          <target state="translated">型指定されていないパラメータを持つ関数が指定された場合、そのバリアントに他の関数と一致しない型が含まれている場合に、この関数が呼び出されます。これは、複数の可能な型にまたがって同じ関数を適用するために使用することができます。汎用関数は1つだけ許可されています。</target>
        </trans-unit>
        <trans-unit id="a87b66dd6db50119dfebfdc41112382fe6b81c05" translate="yes" xml:space="preserve">
          <source>If a function without parameters is specified, this function is called when &lt;code&gt;variant&lt;/code&gt; doesn't hold a value. Exactly one parameter-less function is allowed.</source>
          <target state="translated">パラメータなしの関数が指定されている場合、 &lt;code&gt;variant&lt;/code&gt; が値を保持していないときにこの関数が呼び出されます。パラメータなしの関数を1つだけ使用できます。</target>
        </trans-unit>
        <trans-unit id="834aeb00a2af9d1c11ab80f05c9f251ecfe858eb" translate="yes" xml:space="preserve">
          <source>If a legacy boolean returning custom handler is used, &lt;code&gt;false&lt;/code&gt; maps to &lt;code&gt;UnitTestResult.fail&lt;/code&gt;, and &lt;code&gt;true&lt;/code&gt; maps to &lt;code&gt;UnitTestResult.pass&lt;/code&gt;. This was the original behavior of the unit testing system.</source>
          <target state="translated">レガシーのブール値を返すカスタムハンドラーが使用されている場合、 &lt;code&gt;false&lt;/code&gt; は &lt;code&gt;UnitTestResult.fail&lt;/code&gt; に、 &lt;code&gt;true&lt;/code&gt; は &lt;code&gt;UnitTestResult.pass&lt;/code&gt; にマッピングされます。これは、単体テストシステムの元の動作でした。</target>
        </trans-unit>
        <trans-unit id="82b2fe9ee0ea82740e7dc777c9a1e9340bcda42d" translate="yes" xml:space="preserve">
          <source>If a library routine cannot handle the Typedef type, you can use the &lt;code&gt;TypedefType&lt;/code&gt; template to extract the type which the Typedef wraps.</source>
          <target state="translated">ライブラリルーチンがTypedefタイプを処理できない場合は、 &lt;code&gt;TypedefType&lt;/code&gt; テンプレートを使用して、Typedefがラップするタイプを抽出できます。</target>
        </trans-unit>
        <trans-unit id="6017cad6474bb7ce228682e278fda385b81e533f" translate="yes" xml:space="preserve">
          <source>If a memory object has only one pointer to it, that pointer is the</source>
          <target state="translated">メモリオブジェクトへのポインタが1つしかない場合、そのポインタは</target>
        </trans-unit>
        <trans-unit id="4aba4b8ca7c725b8d06f470a62c86a1bda5b271f" translate="yes" xml:space="preserve">
          <source>If a mixin has an</source>
          <target state="translated">ミキシンが</target>
        </trans-unit>
        <trans-unit id="016a5428498ce2567043077b67b52a004f09c60b" translate="yes" xml:space="preserve">
          <source>If a module C imports modules A and B, any modifications to B will not silently change code in C that is dependent on A.</source>
          <target state="translated">モジュールCがモジュールAとモジュールBをインポートした場合、Bへの変更はAに依存しているCのコードを黙って変更することはありません。</target>
        </trans-unit>
        <trans-unit id="c291b53fa8bebca9657457c0dc4a5986d2a7e4df" translate="yes" xml:space="preserve">
          <source>If a nested class has the &lt;code&gt;static&lt;/code&gt; attribute, then it can not access variables of the enclosing scope that are local to the stack or need a &lt;code&gt;this&lt;/code&gt; reference:</source>
          <target state="translated">ネストされたクラスに &lt;code&gt;static&lt;/code&gt; 属性がある場合、スタックに対してローカルであるか、 &lt;code&gt;this&lt;/code&gt; 参照が必要な、囲んでいるスコープの変数にアクセスできません。</target>
        </trans-unit>
        <trans-unit id="f84ff68027db236d1e6d7027fe7c21486026d4f8" translate="yes" xml:space="preserve">
          <source>If a nested class has the &lt;code&gt;static&lt;/code&gt; attribute, then it can not access variables of the enclosing scope that are local to the stack or need a &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">ネストされたクラスに &lt;code&gt;static&lt;/code&gt; 属性がある場合、スタックに対してローカルであるか、 &lt;code&gt;this&lt;/code&gt; を必要とする外側のスコープの変数にアクセスできません。</target>
        </trans-unit>
        <trans-unit id="384ca96bef7bf27444107f5f4fec2bea50635462" translate="yes" xml:space="preserve">
          <source>If a new scope is desired for each expansion, use another set of braces:</source>
          <target state="translated">各拡張のために新しいスコープが必要な場合は、別の中括弧のセットを使用します。</target>
        </trans-unit>
        <trans-unit id="56c79f57d1a50238baec29c9e84fb38c7b1202da" translate="yes" xml:space="preserve">
          <source>If a option is required, not passing it will result in an error</source>
          <target state="translated">オプションが必要な場合、それを渡さないとエラーになります。</target>
        </trans-unit>
        <trans-unit id="149e6d9194089a56d26c5e902cbd9179de1d63bd" translate="yes" xml:space="preserve">
          <source>If a parameter-less function is specified it is called when either &lt;code&gt;variant&lt;/code&gt; doesn't hold a value or holds a type which isn't handled by the visiting functions.</source>
          <target state="translated">パラメーターなしの関数が指定されている場合、 &lt;code&gt;variant&lt;/code&gt; が値を保持していないか、訪問関数によって処理されない型を保持しているときに呼び出されます。</target>
        </trans-unit>
        <trans-unit id="7beb51fb64caa2734e6c937b4e1f891bde552887" translate="yes" xml:space="preserve">
          <source>If a pointer contains a</source>
          <target state="translated">ポインタに</target>
        </trans-unit>
        <trans-unit id="54a6b6d625a26fd15e5bed961a528f1a4d8c8d83" translate="yes" xml:space="preserve">
          <source>If a property function has no parameters, it works as a getter. If has exactly one parameter, it works as a setter.</source>
          <target state="translated">パラメータを持たないプロパティ関数は、ゲッターとして動作します。パラメータが1つしかない場合は、セッターとして動作します。</target>
        </trans-unit>
        <trans-unit id="bd63b3bb30889f251334a86eb473db6c340d3649" translate="yes" xml:space="preserve">
          <source>If a protocol name is omitted, any protocol will be matched.</source>
          <target state="translated">プロトコル名を省略した場合は、任意のプロトコルがマッチします。</target>
        </trans-unit>
        <trans-unit id="bc8ed891e7a0d7d840793ac113f827ba325b777c" translate="yes" xml:space="preserve">
          <source>If a range returned by &lt;code&gt;map&lt;/code&gt; or &lt;code&gt;asyncBuf&lt;/code&gt; is used as an input to &lt;code&gt;map&lt;/code&gt;, then as an optimization the copying from the output buffer of the first range to the input buffer of the second range is elided, even though the ranges returned by &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;asyncBuf&lt;/code&gt; are non-random access ranges. This means that the &lt;code&gt;bufSize&lt;/code&gt; parameter passed to the current call to &lt;code&gt;map&lt;/code&gt; will be ignored and the size of the buffer will be the buffer size of &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="translated">範囲は、によって返された場合は &lt;code&gt;map&lt;/code&gt; または &lt;code&gt;asyncBuf&lt;/code&gt; を入力するように使用される &lt;code&gt;map&lt;/code&gt; 範囲により返さあっても、第2の範囲の入力バッファの第1の範囲の出力バッファからコピーする最適化として省略されている、 &lt;code&gt;map&lt;/code&gt; と &lt;code&gt;asyncBuf&lt;/code&gt; 非ランダムアクセス範囲です。つまり、現在の &lt;code&gt;map&lt;/code&gt; の呼び出しに渡された &lt;code&gt;bufSize&lt;/code&gt; パラメータは無視され、バッファのサイズは &lt;code&gt;source&lt;/code&gt; のバッファサイズになります。</target>
        </trans-unit>
        <trans-unit id="b1a76bf15d9ef796c131b625f04b8d1b48403d73" translate="yes" xml:space="preserve">
          <source>If a slice operator appears as the left-hand side of an assignment expression, and the type of the right-hand side is the same as the element type of the left-hand side, then the array contents of the left-hand side are set to the right-hand side.</source>
          <target state="translated">代入式の左辺としてスライス演算子が出現し、右辺の型が左辺の要素型と同じであれば、左辺の配列内容は右辺に設定されます。</target>
        </trans-unit>
        <trans-unit id="290e0c5d88ccb110cac619050e0670bb23f215bd" translate="yes" xml:space="preserve">
          <source>If a strongly pure function throws an exception or an error, the assumptions related to memoization and references do not carry to the thrown exception.</source>
          <target state="translated">強く純粋な関数が例外やエラーを投げた場合、メモリ化や参照に関連する仮定は投げられた例外には適用されません。</target>
        </trans-unit>
        <trans-unit id="b78555ca8d430d27e26cbbff76c2b38ef65ebc11" translate="yes" xml:space="preserve">
          <source>If a struct constructor is annotated with &lt;code&gt;@disable&lt;/code&gt; and has an empty &lt;a href=&quot;function#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt;, the struct has disabled default construction. The only way it can be constructed is via a call to another constructor with a non-empty</source>
          <target state="translated">構造体コンストラクターに &lt;code&gt;@disable&lt;/code&gt; アノテーションが付けられ、&lt;a href=&quot;function#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt;が空の場合、構造体はデフォルトの構築を無効にしています。構築できる唯一の方法は、空でない別のコンストラクターを呼び出すことです。</target>
        </trans-unit>
        <trans-unit id="b3a5f4c5b0a3ecfb344535d097fbd6472ec3aaaf" translate="yes" xml:space="preserve">
          <source>If a subexpression of an expression throws an exception, all temporaries created up to the evaluation of that subexpression will be destroyed per the rules above. No destructor calls will be issued for temporaries not yet constructed.</source>
          <target state="translated">式のサブ式が例外を投げる場合、そのサブ式の評価までに作成されたすべてのテンポラリは上記の規則に従って破棄されます。まだ構築されていないテンポラリに対しては、デストラクタ呼び出しは発行されません。</target>
        </trans-unit>
        <trans-unit id="c750c9691a6ca511a5908ab0fae040fe6ae197ae" translate="yes" xml:space="preserve">
          <source>If a template argument matches a specialized template parameter, the argument is mangled with prefix &lt;b&gt;H&lt;/b&gt;.</source>
          <target state="translated">テンプレート引数が特殊なテンプレートパラメータと一致する場合、引数はプレフィックス&lt;b&gt;Hで&lt;/b&gt;マングルされます。</target>
        </trans-unit>
        <trans-unit id="537fb8313b9340d6a7720624890b667ceaf5eabd" translate="yes" xml:space="preserve">
          <source>If a template contains members whose name is the same as the template identifier and if the type or the parameters type of these members include at least all the template parameters then these members are assumed to be referred to in a template instantiation:</source>
          <target state="translated">テンプレートがテンプレート識別子と同じ名前のメンバを含み、これらのメンバの型またはパラメータ型が少なくともすべてのテンプレートパラメータを含む場合、これらのメンバはテンプレートのインスタンス化で参照されると仮定されます。</target>
        </trans-unit>
        <trans-unit id="89c78b76971977e3949d885ca70ed72b7e954c2c" translate="yes" xml:space="preserve">
          <source>If a template contains members whose name is the same as the template identifier then these members are assumed to be referred to in a template instantiation:</source>
          <target state="translated">テンプレートがテンプレート識別子と同じ名前のメンバを含む場合、これらのメンバはテンプレートのインスタンス化で参照されるものとします。</target>
        </trans-unit>
        <trans-unit id="cae6a5dbef8ce07c71db2a20a8cd25a725a5d57c" translate="yes" xml:space="preserve">
          <source>If a template declares exactly one member, and that member is a class with the same name as the template (see &lt;a href=&quot;#implicit_template_properties&quot;&gt;Eponymous Templates&lt;/a&gt;:)</source>
          <target state="translated">テンプレートが正確に1つのメンバーを宣言し、そのメンバーがテンプレートと同じ名前のクラスである場合（&lt;a href=&quot;#implicit_template_properties&quot;&gt;Eponymous Templatesを&lt;/a&gt;参照:)</target>
        </trans-unit>
        <trans-unit id="6e940bc97403a68b4bd6fcc2185065a84be4a8ef" translate="yes" xml:space="preserve">
          <source>If a template declares exactly one member, and that member is a class with the same name as the template:</source>
          <target state="translated">テンプレートが正確に1つのメンバを宣言しており、そのメンバがテンプレートと同じ名前のクラスである場合。</target>
        </trans-unit>
        <trans-unit id="7228f16c50b7195b2939cb5fdb81b9ec5f38dc52" translate="yes" xml:space="preserve">
          <source>If a template declares exactly one member, and that member is a function with the same name as the template, it is a function template declaration. Alternatively, a function template declaration is a function declaration with a &lt;a href=&quot;#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt; immediately preceding the &lt;a href=&quot;function#Parameters&quot;&gt;&lt;i&gt;Parameters&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">テンプレートが1つのメンバーを宣言し、そのメンバーがテンプレートと同じ名前の関数である場合、それは関数テンプレート宣言です。または、関数テンプレート宣言は、&lt;a href=&quot;function#Parameters&quot;&gt;&lt;i&gt;Parametersの&lt;/i&gt;&lt;/a&gt;直前に&lt;a href=&quot;#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt;がある関数宣言です。&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="7f02f572072804182d7734d7a928006f6d805f14" translate="yes" xml:space="preserve">
          <source>If a template has a &lt;a href=&quot;#aliasparameters&quot;&gt;template alias parameter&lt;/a&gt;, and is instantiated with a local symbol, the instantiated function will implicitly become nested in order to access runtime data of the given local symbol.</source>
          <target state="translated">テンプレートがある場合は&lt;a href=&quot;#aliasparameters&quot;&gt;、テンプレート・エイリアスパラメータを&lt;/a&gt;、そして地元のシンボルとインスタンス化され、インスタンス化された機能は、暗黙的に指定されたローカルシンボルのアクセスランタイムデータに順に入れ子になります。</target>
        </trans-unit>
        <trans-unit id="996438a9f4c88ad530df79801ff8b03c0e475abe" translate="yes" xml:space="preserve">
          <source>If a template is declared in aggregate or function local scope, the instantiated functions will implicitly capture the context of the enclosing scope.</source>
          <target state="translated">テンプレートが集約スコープまたは関数ローカルスコープで宣言されている場合、インスタンス化された関数は暗黙的にスコープのコンテキストを捕捉します。</target>
        </trans-unit>
        <trans-unit id="449794f5173b1c91e0c8a9e969999efee1d1266f" translate="yes" xml:space="preserve">
          <source>If a variable has a scope destructor call, return call for it. Otherwise, return NULL.</source>
          <target state="translated">変数にスコープデストラクタの呼び出しがある場合は、その呼び出しを返します。そうでなければ、NULLを返します。</target>
        </trans-unit>
        <trans-unit id="e7d0ce5000213342db830246324bf60d4a0dcc21" translate="yes" xml:space="preserve">
          <source>If after all the type arguments are examined, there are any type parameters left with no type assigned, they are assigned types corresponding to the template argument in the same position in the</source>
          <target state="translated">すべての型引数を調べた結果,型が割り当てられていない型パラメータが残っていた場合は,テンプレート引数に対応する型が</target>
        </trans-unit>
        <trans-unit id="8425958e6e0e9a1c94e548c8eed6685e1c97af18" translate="yes" xml:space="preserve">
          <source>If aliased to the same object or both null =&amp;gt; equal</source>
          <target state="translated">同じオブジェクトまたは両方にエイリアスされている場合null =&amp;gt;等しい</target>
        </trans-unit>
        <trans-unit id="201815c4325a8fddf0539c89b74ba96e4169f933" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;auto&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;auto&lt;/code&gt; 場合</target>
        </trans-unit>
        <trans-unit id="5aa6bbb7d06b0bd7ec69b77758d95900b4054089" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;enum&lt;/code&gt; is used as type, the random variate is drawn with equal probability from any of the possible values of the enum &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 型がタイプとして使用される場合、ランダム変量は列挙 &lt;code&gt;E&lt;/code&gt; の可能な値のいずれかから等しい確率で引き出されます。</target>
        </trans-unit>
        <trans-unit id="168c9f0755c4bd4e21cdb3d96a893ad7470eff57" translate="yes" xml:space="preserve">
          <source>If an aggregate declaration defines an &lt;code&gt;opCmp&lt;/code&gt; or &lt;code&gt;opEquals&lt;/code&gt; method, it will take precedence to that of the aliased this member. Note that, unlike an &lt;code&gt;opCmp&lt;/code&gt; method, an &lt;code&gt;opEquals&lt;/code&gt; method is implicitly defined for a &lt;code&gt;struct&lt;/code&gt; declaration if a user defined one isn't provided; this means that if the aliased this member &lt;code&gt;opEquals&lt;/code&gt; is preferred it should be explicitly defined:</source>
          <target state="translated">集約宣言で &lt;code&gt;opCmp&lt;/code&gt; または &lt;code&gt;opEquals&lt;/code&gt; メソッドが定義されている場合、エイリアスされたthisメンバーの宣言よりも優先されます。 &lt;code&gt;opCmp&lt;/code&gt; メソッドとは異なり、ユーザー定義のものが提供されていない場合、 &lt;code&gt;struct&lt;/code&gt; 宣言に対して &lt;code&gt;opEquals&lt;/code&gt; メソッドが暗黙的に定義されることに注意してください。つまり、エイリアスされたこのメンバー &lt;code&gt;opEquals&lt;/code&gt; が優先される場合は、明示的に定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="2cf56dfdcc6eee095fd25bd060be3e831d6148d4" translate="yes" xml:space="preserve">
          <source>If an append must reallocate a slice with no possibility of extension, then &lt;code&gt;0&lt;/code&gt; is returned. This happens when the slice references a static array, or if another slice references elements past the end of the current slice.</source>
          <target state="translated">アペンドが拡張の可能性なしにスライスを再割り当てする必要がある場合、 &lt;code&gt;0&lt;/code&gt; が返されます。これは、スライスが静的配列を参照する場合、または別のスライスが現在のスライスの終わりを超えた要素を参照する場合に発生します。</target>
        </trans-unit>
        <trans-unit id="fbeff861e7616c530bb5c083257a7ef08f727eef" translate="yes" xml:space="preserve">
          <source>If an application needs to do its own processing of whichever arguments &lt;code&gt;getopt&lt;/code&gt; did not understand, it can pass the &lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; directive to &lt;code&gt;getopt&lt;/code&gt;:</source>
          <target state="translated">アプリケーションが &lt;code&gt;getopt&lt;/code&gt; が理解できなかった引数の独自の処理を行う必要がある場合、アプリケーションは &lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; ディレクティブを &lt;code&gt;getopt&lt;/code&gt; に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="eaf53aac4b71af8424769f45a7b82ff0df7d317c" translate="yes" xml:space="preserve">
          <source>If an enum has as a base type one of the types in the left column, it is converted to the type in the right column.</source>
          <target state="translated">列挙型が左列の型のいずれかをベースにしている場合は、右列の型に変換されます。</target>
        </trans-unit>
        <trans-unit id="3c064315a80e4366fd87dbfa8b9a5125e74f88b6" translate="yes" xml:space="preserve">
          <source>If an error occurs during the compilation of your program, the use of overloads and overrides needs to be reexamined in the relevant classes.</source>
          <target state="translated">プログラムのコンパイル中にエラーが発生した場合は、関連するクラスでオーバーロードやオーバーライドの使用を再検討する必要があります。</target>
        </trans-unit>
        <trans-unit id="a2623dd123c39f9f457825f03bd99064fa3431f1" translate="yes" xml:space="preserve">
          <source>If an exception is raised in the</source>
          <target state="translated">で例外が発生した場合</target>
        </trans-unit>
        <trans-unit id="180043ac16b1a016937b09456574733627d6647e" translate="yes" xml:space="preserve">
          <source>If an exception is thrown but it has an empty message, then &lt;code&gt;emptyExceptionMsg&lt;/code&gt; is returned.</source>
          <target state="translated">例外がスローされても、メッセージが空の場合、 &lt;code&gt;emptyExceptionMsg&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="eb4162f43906e6c9a7e64e7ecdf711ae4fd96612" translate="yes" xml:space="preserve">
          <source>If an identical type to &lt;code&gt;type&lt;/code&gt; is in &lt;code&gt;type.stringtable&lt;/code&gt;, return the latter one. Otherwise, add it to &lt;code&gt;type.stringtable&lt;/code&gt;. Some types don't get merged and are returned as-is.</source>
          <target state="translated">同一タイプならば &lt;code&gt;type&lt;/code&gt; である &lt;code&gt;type.stringtable&lt;/code&gt; 、後者のいずれかを返します。それ以外の場合は、それを &lt;code&gt;type.stringtable&lt;/code&gt; に追加します。一部のタイプはマージされず、そのまま返されます。</target>
        </trans-unit>
        <trans-unit id="2efd485ddee09f5b6939ce6531c2909633020004" translate="yes" xml:space="preserve">
          <source>If an identity assignment overload is required and does not exist, an identity assignment overload function of the type &lt;code&gt;ref S opAssign(ref S)&lt;/code&gt; will be automatically generated.</source>
          <target state="translated">ID割り当てオーバーロードが必要であり、存在しない場合、タイプ &lt;code&gt;ref S opAssign(ref S)&lt;/code&gt; の ID割り当てオーバーロード関数が自動的に生成されます。</target>
        </trans-unit>
        <trans-unit id="5e5e3f00360d5b8852208ee3415dc3a1a01f6dc8" translate="yes" xml:space="preserve">
          <source>If an implicit conversion is disallowed by the table, an &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; may be converted if:</source>
          <target state="translated">暗黙的な変換がテーブルで許可されていない場合、次の場合に&lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;式&lt;/i&gt;&lt;/a&gt;が変換されることがあります。</target>
        </trans-unit>
        <trans-unit id="9520036db9c2c3cb7627c2cb880cb288fe8ee7ee" translate="yes" xml:space="preserve">
          <source>If an index expression can be rewritten using &lt;code&gt;opIndexAssign&lt;/code&gt; or &lt;code&gt;opIndexOpAssign&lt;/code&gt;, those are preferred over &lt;code&gt;opIndex&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;opIndexAssign&lt;/code&gt; または &lt;code&gt;opIndexOpAssign&lt;/code&gt; を使用してインデックス式を書き換えることができる場合、これらはopIndexよりも優先され &lt;code&gt;opIndex&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74d0247eb6c576e08ded3f7c08dff25cd606da70" translate="yes" xml:space="preserve">
          <source>If an interface has &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt; storage class, then all members of the interface are &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt;. This storage class is not inherited.</source>
          <target state="translated">インターフェイスに &lt;code&gt;const&lt;/code&gt; または &lt;code&gt;immutable&lt;/code&gt; ストレージクラスがある場合、インターフェイスのすべてのメンバーは &lt;code&gt;const&lt;/code&gt; または &lt;code&gt;immutable&lt;/code&gt; です。このストレージクラスは継承されません。</target>
        </trans-unit>
        <trans-unit id="7e7381c9bb35e9f77c152ce0763035229030f128" translate="yes" xml:space="preserve">
          <source>If an option is bound to a numeric type, a number is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">オプ シ ョ ンが数値型に結合 さ れてい る 場合は、 次のオプ シ ョ ン と し て数値が、 またはオプシ ョ ンの右端に &quot;=&quot; 記号で区切られたオプシ ョ ンが期待 さ れます。</target>
        </trans-unit>
        <trans-unit id="e1388310610be9143f93d5757e5dd370de55e952" translate="yes" xml:space="preserve">
          <source>If an option is bound to a string, a string is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">オプションが文字列にバインドされている場合は、文字列が次のオプションとして期待されるか、オプションの右端に &quot;=&quot; 記号で区切られたオプションが期待されます。</target>
        </trans-unit>
        <trans-unit id="cd9d52ae8827e5578c6e463b4801745d426f4b79" translate="yes" xml:space="preserve">
          <source>If an option is bound to an array, a new element is appended to the array each time the option occurs:</source>
          <target state="translated">オプションが配列にバインドされている場合は、オプションが発生するたびに新しい要素が配列に追加されます。</target>
        </trans-unit>
        <trans-unit id="d7c493c513172131987de31a463653700c8dc123" translate="yes" xml:space="preserve">
          <source>If an option is bound to an associative array, a string of the form &quot;name=value&quot; is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">オプションが連想配列にバインドされている場合は、次のオプションとして &quot;name=value&quot; の形式の文字列を指定するか、 あるいはオプションの右端に &quot;=&quot; で区切って指定します。</target>
        </trans-unit>
        <trans-unit id="b6f632caf5c4044e09e5739104d63549a3fc0c34" translate="yes" xml:space="preserve">
          <source>If an option is bound to an enum, an enum symbol as a string is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">オプシ ョ ンが enum に結合 さ れてい る 場合は、 文字列 と し ての enum シンボルが次のオプシ ョ ン と し て、 ま たはオプシ ョ ン内の右端に &quot;=&quot; 記号で区切られてい る こ と が予想 さ れます。</target>
        </trans-unit>
        <trans-unit id="7c32990bfc4d36bb0abf0d415d84bd3e023f0845" translate="yes" xml:space="preserve">
          <source>If an option name has a &quot;+&quot; suffix and is bound to a numeric type, then the option's value tracks the number of times the option occurred on the command line:</source>
          <target state="translated">オプション名の接尾辞が「+」で、数値型にバインドされている場合、そのオプションの値は、そのオプションがコマンドライン上で何回発生したかを追跡します。</target>
        </trans-unit>
        <trans-unit id="3bc9e305061e747e54d09f33e1d219d952240a58" translate="yes" xml:space="preserve">
          <source>If an option string is followed by another string, this string serves as a description for this option. The &lt;code&gt;getopt&lt;/code&gt; function returns a struct of type &lt;code&gt;GetoptResult&lt;/code&gt;. This return value contains information about all passed options as well a &lt;code&gt;bool GetoptResult.helpWanted&lt;/code&gt; flag indicating whether information about these options was requested. The &lt;code&gt;getopt&lt;/code&gt; function always adds an option for &lt;code&gt;--help|-h&lt;/code&gt; to set the flag if the option is seen on the command line.</source>
          <target state="translated">オプション文字列の後に別の文字列が続く場合、この文字列はこのオプションの説明として機能します。 &lt;code&gt;getopt&lt;/code&gt; 関数は、型の構造体を返し &lt;code&gt;GetoptResult&lt;/code&gt; を。この戻り値には、渡されたすべてのオプションに関する情報と、これらのオプションに関する情報が要求されたかどうかを示す &lt;code&gt;bool GetoptResult.helpWanted&lt;/code&gt; フラグが含まれています。 &lt;code&gt;getopt&lt;/code&gt; 関数は常にためのオプション追加 &lt;code&gt;--help|-h&lt;/code&gt; オプションは、コマンドライン上で見られた場合にフラグを設定することを。</target>
        </trans-unit>
        <trans-unit id="cecb4b7cfecf63467f6f4623b6ecf01515e03ef4" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;TaskPool&lt;/code&gt; with non-daemon threads is active, either &lt;code&gt;stop&lt;/code&gt; or &lt;code&gt;finish&lt;/code&gt; must be called on it before the program can terminate.</source>
          <target state="translated">いずれの場合 &lt;code&gt;TaskPool&lt;/code&gt; という非デーモンスレッドとはアクティブで、どちらか &lt;code&gt;stop&lt;/code&gt; や &lt;code&gt;finish&lt;/code&gt; プログラムが終了する前にそれを呼び出さなければなりません。</target>
        </trans-unit>
        <trans-unit id="2442edf64b05fed93875352de9ddef61974e4dcd" translate="yes" xml:space="preserve">
          <source>If any fields have disabled default construction, struct default construction is also disabled.</source>
          <target state="translated">デフォルト構築を無効にしているフィールドがある場合、structのデフォルト構築も無効になります。</target>
        </trans-unit>
        <trans-unit id="a14ab7622e0f011a987d4940247d86d91424d5c2" translate="yes" xml:space="preserve">
          <source>If any fields have disabled default construction, the struct default construction is also disabled.</source>
          <target state="translated">デフォルト構築を無効にしているフィールドがある場合、構造体のデフォルト構築も無効になります。</target>
        </trans-unit>
        <trans-unit id="11956d46948d1d13d7ee53327bbd180ff0d5d12d" translate="yes" xml:space="preserve">
          <source>If any of &lt;code&gt;lead&lt;/code&gt; and &lt;code&gt;vowel&lt;/code&gt; are not a valid hangul jamo of the respective &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt; class returns dchar.init.</source>
          <target state="translated">&lt;code&gt;lead&lt;/code&gt; と &lt;code&gt;vowel&lt;/code&gt; いずれかがそれぞれの&lt;a href=&quot;#Character&quot;&gt;文字&lt;/a&gt;クラスの有効なハングルジャモでない場合、dchar.initを返します。</target>
        </trans-unit>
        <trans-unit id="643424aa2159c0dc971a85e93b28f54bc425b055" translate="yes" xml:space="preserve">
          <source>If any of the arguments in the &lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt; are a</source>
          <target state="translated">引数のいずれかの場合に&lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;は、ArgumentListが&lt;/i&gt;&lt;/a&gt;あります</target>
        </trans-unit>
        <trans-unit id="3744bc315bbcad378bdb3ff87a3b9de7d402fea7" translate="yes" xml:space="preserve">
          <source>If any of the checks fail, a compile error will occur.</source>
          <target state="translated">いずれかのチェックに失敗するとコンパイルエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="def10a047da7cb724c42b1f59da46ab76ef31dc6" translate="yes" xml:space="preserve">
          <source>If any of the keys or values in the</source>
          <target state="translated">のキーまたは値のいずれかが</target>
        </trans-unit>
        <trans-unit id="41bc7edc68b18e54f236d3ac39e824893010bd91" translate="yes" xml:space="preserve">
          <source>If applying the above rules does not result in exactly one type for each template parameter, then it is an error.</source>
          <target state="translated">上記のルールを適用しても、各テンプレートパラメータに対して正確に1つの型にならない場合はエラーとなります。</target>
        </trans-unit>
        <trans-unit id="a7c844c173ee0a673d9ab2e503851d6c710a834c" translate="yes" xml:space="preserve">
          <source>If assertions are enabled and &lt;code&gt;toRange&lt;/code&gt; has been called, then this WorkerLocalStorage instance is no longer worker-local and an assertion failure will result when calling this method. This is not checked when assertions are disabled for performance reasons.</source>
          <target state="translated">アサーションが有効で &lt;code&gt;toRange&lt;/code&gt; が呼び出されている場合、このWorkerLocalStorageインスタンスはワーカーローカルではなくなり、このメソッドを呼び出すとアサーションエラーが発生します。パフォーマンス上の理由でアサーションが無効になっている場合、これはチェックされません。</target>
        </trans-unit>
        <trans-unit id="2a4c7b046cde0bb5e12a60d5ebe77f7e562208f5" translate="yes" xml:space="preserve">
          <source>If at least one of the arguments is NaN, the result is an unspecified value.</source>
          <target state="translated">引数のうち少なくとも1つがNaNの場合、結果は不定値となります。</target>
        </trans-unit>
        <trans-unit id="825f4197814b0d68b55040d1d95ed5fec00d9458" translate="yes" xml:space="preserve">
          <source>If at least one of the arguments is NaN, the result is an unspecified value. See &lt;a href=&quot;std_algorithm_searching#maxElement&quot;&gt;&lt;code&gt;std.algorithm.searching.maxElement&lt;/code&gt;&lt;/a&gt; for examples on how to cope with NaNs.</source>
          <target state="translated">引数の少なくとも1つがNaNの場合、結果は不特定の値になります。NaNに対処する方法の例については、&lt;a href=&quot;std_algorithm_searching#maxElement&quot;&gt; &lt;code&gt;std.algorithm.searching.maxElement&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="51eb056f1717f5d30ca42a509337be76f7a52798" translate="yes" xml:space="preserve">
          <source>If at least one of the arguments is NaN, the result is an unspecified value. See &lt;a href=&quot;std_algorithm_searching#minElement&quot;&gt;&lt;code&gt;std.algorithm.searching.minElement&lt;/code&gt;&lt;/a&gt; for examples on how to cope with NaNs.</source>
          <target state="translated">引数の少なくとも1つがNaNの場合、結果は不特定の値になります。NaNに対処する方法の例については、&lt;a href=&quot;std_algorithm_searching#minElement&quot;&gt; &lt;code&gt;std.algorithm.searching.minElement&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="df118ef438600490adb83de4d6beaa35bff251d8" translate="yes" xml:space="preserve">
          <source>If at least one of the ranges is a multiset, then all occurences of a duplicate element are taken into account. The result is equivalent to merging all input ranges and picking the highest &lt;code&gt;tgt.length&lt;/code&gt;, weight-based ranking elements.</source>
          <target state="translated">範囲の少なくとも1つがマルチセットである場合、重複する要素のすべての出現が考慮されます。結果は、すべての入力範囲をマージし、最も高い &lt;code&gt;tgt.length&lt;/code&gt; の重みベースのランキング要素を選択するのと同じです。</target>
        </trans-unit>
        <trans-unit id="4519d0d5950e5356f4f13b61a821ffce61eda0b3" translate="yes" xml:space="preserve">
          <source>If authentication or redirections are done then the status will be for the last response received.</source>
          <target state="translated">認証やリダイレクトが行われた場合は、最後に受信したレスポンスのステータスとなります。</target>
        </trans-unit>
        <trans-unit id="cd6490598a4d93059510177bb453af0037be62bb" translate="yes" xml:space="preserve">
          <source>If autodecoding is turned off, then this is equivalent to duplicating the array.</source>
          <target state="translated">オートデコードがオフになっている場合、これは配列を複製することと同じことになります。</target>
        </trans-unit>
        <trans-unit id="742bd1e8cf3c2f25ee274ec3880df5cf7f721969" translate="yes" xml:space="preserve">
          <source>If autodecoding is turned on (default), then they are handled as a separate overload.</source>
          <target state="translated">自動デコードがオンになっている場合(デフォルト)、それらは別のオーバーロードとして処理されます。</target>
        </trans-unit>
        <trans-unit id="0a0246e59acc96ca671df31d602e303fc5a3e9ab" translate="yes" xml:space="preserve">
          <source>If blocking argument is true, wait for all worker threads to terminate before returning. This option might be used in applications where task results are never consumed-- e.g. when &lt;code&gt;TaskPool&lt;/code&gt; is employed as a rudimentary scheduler for tasks which communicate by means other than return values.</source>
          <target state="translated">ブロッキング引数がtrueの場合、戻る前にすべてのワーカースレッドが終了するのを待ちます。このオプションは、タスクの結果が消費されないアプリケーションで使用される場合があります。たとえば、戻り値以外の手段で通信するタスクの基本的なスケジューラとして &lt;code&gt;TaskPool&lt;/code&gt; が使用されている場合などです。</target>
        </trans-unit>
        <trans-unit id="7479ca1ded9e48be6a8e038bc9b2488efa665f70" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;Primary&lt;/code&gt; and &lt;code&gt;Fallback&lt;/code&gt; are stateless, &lt;code&gt;FallbackAllocator&lt;/code&gt; defines a static instance called &lt;code&gt;instance&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Primary&lt;/code&gt; と &lt;code&gt;Fallback&lt;/code&gt; の両方がステートレスの場合、 &lt;code&gt;FallbackAllocator&lt;/code&gt; はinstanceという静的インスタンスを定義し &lt;code&gt;instance&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ec43df7b50b565bd7b1219f8c1f3ab8b182ffb2" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are integers (may be constant-folded), the slice expression can be converted to a static array type &lt;code&gt;T[b - a]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; の両方が整数の場合（定数で折りたたまれている可能性があります）、スライス式は静的配列型 &lt;code&gt;T[b - a]&lt;/code&gt; 変換できます。</target>
        </trans-unit>
        <trans-unit id="0deff799fed4758452aa1b15f9e2a5541bd46d3e" translate="yes" xml:space="preserve">
          <source>If both a template with a sequence parameter and a template without a sequence parameter exactly match a template instantiation, the template without a</source>
          <target state="translated">シーケンスパラメータを持つテンプレートとシーケンスパラメータを持たないテンプレートの両方がテンプレートのインスタンス化に完全に一致する場合、そのテンプレートは</target>
        </trans-unit>
        <trans-unit id="220f653add85effdd5e512619500f4b49743b534" translate="yes" xml:space="preserve">
          <source>If both allocators are &lt;code&gt;shared&lt;/code&gt;, the &lt;code&gt;Segregator&lt;/code&gt; will also offer &lt;code&gt;shared&lt;/code&gt; methods.</source>
          <target state="translated">両方のアロケーターが &lt;code&gt;shared&lt;/code&gt; 場合、 &lt;code&gt;Segregator&lt;/code&gt; は &lt;code&gt;shared&lt;/code&gt; メソッドも提供します。</target>
        </trans-unit>
        <trans-unit id="69639385682c3a994448b82bd2bb7cf46189be9b" translate="yes" xml:space="preserve">
          <source>If both are signed or both are unsigned, the smaller type is converted to the larger.</source>
          <target state="translated">両方とも符号付き、または両方とも符号なしの場合は、小さい方の型が大きい方に変換されます。</target>
        </trans-unit>
        <trans-unit id="05fb2e935ce549269270c5d42145fc9b4f07b7f4" translate="yes" xml:space="preserve">
          <source>If both are the same type, no more conversions are done.</source>
          <target state="translated">両方が同じ型であれば、それ以上の変換は行われません。</target>
        </trans-unit>
        <trans-unit id="05dd5c60a4e9b82d4adbecb6f4127f3d732ab860" translate="yes" xml:space="preserve">
          <source>If both arguments are ranges of L-values of the same type then &lt;code&gt;SetSymmetricDifference&lt;/code&gt; will also be a range of L-values of that type.</source>
          <target state="translated">両方の引数が同じタイプのL値の範囲である場合、 &lt;code&gt;SetSymmetricDifference&lt;/code&gt; もそのタイプのL値の範囲になります。</target>
        </trans-unit>
        <trans-unit id="f20cc499ea7bfd3b9b5a7bc116d95b44ec6d1e4b" translate="yes" xml:space="preserve">
          <source>If both operands are of integral types and an overflow or underflow occurs in the computation, wrapping will happen. For example, &lt;code&gt;uint.max + 1 == uint.min&lt;/code&gt;, &lt;code&gt;uint.min - 1 == uint.max&lt;/code&gt;, &lt;code&gt;int.max + 1 == int.min&lt;/code&gt;, and &lt;code&gt;int.min - 1 == int.max&lt;/code&gt;.</source>
          <target state="translated">両方のオペランドが整数型であり、計算でオーバーフローまたはアンダーフローが発生した場合、ラッピングが発生します。たとえば、 &lt;code&gt;uint.max + 1 == uint.min&lt;/code&gt; 、 &lt;code&gt;uint.min - 1 == uint.max&lt;/code&gt; 、 &lt;code&gt;int.max + 1 == int.min&lt;/code&gt; 、および &lt;code&gt;int.min - 1 == int.max&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1166af836d0ff22ec8996cf90c0ca104ddf9187" translate="yes" xml:space="preserve">
          <source>If both operands are of integral types and an overflow or underflow occurs in the computation, wrapping will happen. That is, &lt;code&gt;uint.max + 1 == uint.min&lt;/code&gt; and &lt;code&gt;uint.min - 1 == uint.max&lt;/code&gt;.</source>
          <target state="translated">両方のオペランドが整数型で、計算でオーバーフローまたはアンダーフローが発生した場合、ラップが発生します。つまり、 &lt;code&gt;uint.max + 1 == uint.min&lt;/code&gt; および &lt;code&gt;uint.min - 1 == uint.max&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="88c921254e07ee3d3550bb0c4328e00c73dbba70" translate="yes" xml:space="preserve">
          <source>If both operands are pointers, and the operator is &lt;code&gt;+&lt;/code&gt;, then it is illegal.</source>
          <target state="translated">両方のオペランドがポインターであり、演算子が &lt;code&gt;+&lt;/code&gt; である場合、それは不正です。</target>
        </trans-unit>
        <trans-unit id="d175863c948db7d84910700658bc03bfa12bed2a" translate="yes" xml:space="preserve">
          <source>If both operands are pointers, and the operator is &lt;code&gt;-&lt;/code&gt;, the pointers are subtracted and the result is divided by the size of the type pointed to by the operands. In this calculation the assumed size of &lt;code&gt;void&lt;/code&gt; is one byte. It is an error if the pointers point to different types. The type of the result is &lt;code&gt;ptrdiff_t&lt;/code&gt;.</source>
          <target state="translated">両方のオペランドがポインターであり、演算子が &lt;code&gt;-&lt;/code&gt; である場合、ポインターは減算され、結果はオペランドが指す型のサイズで除算されます。この計算では、 &lt;code&gt;void&lt;/code&gt; の想定サイズは1バイトです。ポインターが異なる型を指している場合はエラーになります。結果のタイプは &lt;code&gt;ptrdiff_t&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d1abf720abea123f60d5888992d6209534bf4e09" translate="yes" xml:space="preserve">
          <source>If both ranges are finite, then one must be (at least) a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; and the other an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt;.</source>
          <target state="translated">両方の範囲が有限である場合、一方は（少なくとも）&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;前方範囲&lt;/a&gt;でなければならず、他方は&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;入力範囲&lt;/a&gt;でなければなりません。</target>
        </trans-unit>
        <trans-unit id="cb5178f6f33c9b3fe021f6007cd182ded54b74f7" translate="yes" xml:space="preserve">
          <source>If both ranges are infinite, then both must be forward ranges.</source>
          <target state="translated">両方の範囲が無限大であれば、両方とも順方向の範囲でなければなりません。</target>
        </trans-unit>
        <trans-unit id="09621590d3975cfd09fe2c0811ba26754a5cdd9d" translate="yes" xml:space="preserve">
          <source>If both ranges are sets (without duplicated elements), the resulting range is going to be a set. If at least one of the ranges is a multiset, the number of occurences of an element &lt;code&gt;x&lt;/code&gt; in the resulting range is &lt;code&gt;abs(a-b)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the number of occurences of &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;r1&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; is the number of occurences of &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;r2&lt;/code&gt;, and &lt;code&gt;abs&lt;/code&gt; is the absolute value.</source>
          <target state="translated">両方の範囲が（重複する要素のない）セットである場合、結果の範囲はセットになります。範囲の少なくとも一方が多重集合である場合、要素の出現箇所の数 &lt;code&gt;x&lt;/code&gt; 得られる範囲内である &lt;code&gt;abs(a-b)&lt;/code&gt; の出現箇所の数であり、 &lt;code&gt;x&lt;/code&gt; における &lt;code&gt;r1&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; はの出現箇所の数であり、 &lt;code&gt;x&lt;/code&gt; における &lt;code&gt;r2&lt;/code&gt; 、および &lt;code&gt;abs&lt;/code&gt; は絶対値です。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c3cd520fd113fc0ea9747b7e4b22c4c42d0b39c5" translate="yes" xml:space="preserve">
          <source>If both ranges have a length member, this function is &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;). Otherwise, this function is &amp;Omicron;(&lt;code&gt;min(r1.length, r2.length)&lt;/code&gt;).</source>
          <target state="translated">両方の範囲に長さのメンバーがある場合、この関数は&amp;Omicron;（ &lt;code&gt;1&lt;/code&gt; ）です。それ以外の場合、この関数は&amp;Omicron;（ &lt;code&gt;min(r1.length, r2.length)&lt;/code&gt; ）です。</target>
        </trans-unit>
        <trans-unit id="077a8fbc08834027e3db2ad54352fdf64c6364ae" translate="yes" xml:space="preserve">
          <source>If both x and n are 0, the result is 1. If n is negative, an integer divide error will occur at runtime, regardless of the value of x.</source>
          <target state="translated">x と n の両方が 0 の場合、結果は 1 になります。 n が負の場合、x の値に関係なく、実行時に整数除算エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="d8d58e2935a54be899c1932e2430b1d836d6854b" translate="yes" xml:space="preserve">
          <source>If break is followed by</source>
          <target state="translated">ブレークの後に</target>
        </trans-unit>
        <trans-unit id="133ff22691958b87ce955cf38fc2654641e5c95a" translate="yes" xml:space="preserve">
          <source>If class invariant checking is turned on, the class invariant is called at the end of the constructor.</source>
          <target state="translated">クラス不変検査をオンにすると、コンストラクタの最後にクラス不変が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="2873dd219021490e067fcdc56ae6ce69a60f4696" translate="yes" xml:space="preserve">
          <source>If code detects an error like &quot;out of memory,&quot; then an Error is thrown with a message saying &quot;Out of memory&quot;. The function call stack is unwound, looking for a handler for the Error. &lt;a href=&quot;statement#TryStatement&quot;&gt;Finally blocks&lt;/a&gt; are executed as the stack is unwound. If an error handler is found, execution resumes there. If not, the default Error handler is run, which displays the message and terminates the program.</source>
          <target state="translated">コードが「メモリ不足」などのエラーを検出すると、「メモリ不足」というメッセージとともにエラーがスローされます。関数呼び出しスタックは巻き戻され、エラーのハンドラーを探します。&lt;a href=&quot;statement#TryStatement&quot;&gt;最後に&lt;/a&gt;、スタックがほどかれるときにブロックが実行されます。エラーハンドラが見つかると、そこで実行が再開されます。そうでない場合は、デフォルトのエラーハンドラが実行され、メッセージが表示されてプログラムが終了します。</target>
        </trans-unit>
        <trans-unit id="026a3ed1741bfc55e99518c871b70d4250291a91" translate="yes" xml:space="preserve">
          <source>If continue is followed by</source>
          <target state="translated">continue の後に</target>
        </trans-unit>
        <trans-unit id="6422eca509193d7e5c40c75cbc0a1df0e38709f1" translate="yes" xml:space="preserve">
          <source>If defined and &lt;code&gt;hookOpCast&lt;/code&gt; is</source>
          <target state="translated">定義されていて、 &lt;code&gt;hookOpCast&lt;/code&gt; が</target>
        </trans-unit>
        <trans-unit id="5a7e95bb168b15f4a8bcb2b5cf99f8ea675a9dca" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;Hook.defaultValue!T&lt;/code&gt; is used as the default initializer of the payload.</source>
          <target state="translated">定義されている場合、 &lt;code&gt;Hook.defaultValue!T&lt;/code&gt; がペイロードのデフォルトの初期化子として使用されます。</target>
        </trans-unit>
        <trans-unit id="03019d524f44be31cdffd6208c1acffd47d8953d" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;Hook.max!T&lt;/code&gt; is used as the maximum value of the payload.</source>
          <target state="translated">定義されている場合、 &lt;code&gt;Hook.max!T&lt;/code&gt; がペイロードの最大値として使用されます。</target>
        </trans-unit>
        <trans-unit id="f5bf55bfa3966b60e1868595f8913387e32b50a0" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;Hook.min!T&lt;/code&gt; is used as the minimum value of the payload.</source>
          <target state="translated">定義されている場合、 &lt;code&gt;Hook.min!T&lt;/code&gt; がペイロードの最小値として使用されます。</target>
        </trans-unit>
        <trans-unit id="c860109476dd6e83e225430bc70cc535b0742b87" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpBinary!op(get, rhs)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol and &lt;code&gt;rhs&lt;/code&gt; is the right-hand side operand) is forwarded to unconditionally for binary operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;^^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">定義されている場合、 &lt;code&gt;hook.hookOpBinary!op(get, rhs)&lt;/code&gt; （ &lt;code&gt;op&lt;/code&gt; は演算子記号で &lt;code&gt;rhs&lt;/code&gt; は右側のオペランドです）は、二項演算子 &lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;-&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 、 &lt;code&gt;/&lt;/code&gt; 、 &lt;code&gt;%&lt;/code&gt; 、 &lt;code&gt;^^&lt;/code&gt; に対して無条件に転送されます。 &lt;code&gt;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;|&lt;/code&gt; 、 &lt;code&gt;^&lt;/code&gt; 、 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 、および &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22acb3135b0d52c02522e9bda0aa4a9ab72a1f15" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpBinaryRight!op(lhs, get)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol and &lt;code&gt;lhs&lt;/code&gt; is the left-hand side operand) is forwarded to unconditionally for binary operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;^^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">定義されている場合、 &lt;code&gt;hook.hookOpBinaryRight!op(lhs, get)&lt;/code&gt; （ &lt;code&gt;op&lt;/code&gt; は演算子記号、 &lt;code&gt;lhs&lt;/code&gt; は左側のオペランド）は、二項演算子 &lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;-&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 、 &lt;code&gt;/&lt;/code&gt; 、 &lt;code&gt;%&lt;/code&gt; 、 &lt;code&gt;^^&lt;/code&gt; に無条件に転送されます。 &lt;code&gt;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;|&lt;/code&gt; 、 &lt;code&gt;^&lt;/code&gt; 、 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 、および &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22f903c768577a0e387a7661822b3ab6e9ea3a27" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpCast!U(get)&lt;/code&gt; is forwarded to unconditionally when the payload is to be cast to type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">定義されている場合、ペイロードがタイプ &lt;code&gt;U&lt;/code&gt; にキャストされるときに、 &lt;code&gt;hook.hookOpCast!U(get)&lt;/code&gt; が無条件に転送されます。</target>
        </trans-unit>
        <trans-unit id="d39d077b66c222df35757287877d0f5e2f125e3c" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpCmp(get, rhs)&lt;/code&gt; is forwarded to unconditionally when the payload is compared for ordering against value &lt;code&gt;rhs&lt;/code&gt; of integral, floating point, or Boolean type.</source>
          <target state="translated">定義されている場合、 &lt;code&gt;hook.hookOpCmp(get, rhs)&lt;/code&gt; は、ペイロードが整数型、浮動小数点型、またはブール型の値 &lt;code&gt;rhs&lt;/code&gt; に対する順序付けと比較されるときに、無条件に転送されます。</target>
        </trans-unit>
        <trans-unit id="61710dc38aff3803efddd69b40c8a0d534e524ab" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpEquals(get, rhs)&lt;/code&gt; is forwarded to unconditionally when the payload is compared for equality against value &lt;code&gt;rhs&lt;/code&gt; of integral, floating point, or Boolean type.</source>
          <target state="translated">定義されている場合、 &lt;code&gt;hook.hookOpEquals(get, rhs)&lt;/code&gt; は、ペイロードが整数型、浮動小数点型、またはブール型の値 &lt;code&gt;rhs&lt;/code&gt; と等しいかどうか比較されるときに無条件に転送されます。</target>
        </trans-unit>
        <trans-unit id="78db295a6db30c78e28bbcb362075d3be4e0b84f" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol and &lt;code&gt;rhs&lt;/code&gt; is the right-hand side operand) is forwarded to unconditionally for binary operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt;.</source>
          <target state="translated">定義されている場合、 &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt; （ &lt;code&gt;op&lt;/code&gt; は演算子記号で &lt;code&gt;rhs&lt;/code&gt; は右側のオペランドです）は、二項演算子 &lt;code&gt;+=&lt;/code&gt; 、 &lt;code&gt;-=&lt;/code&gt; 、 &lt;code&gt;*=&lt;/code&gt; 、 &lt;code&gt;/=&lt;/code&gt; 、 &lt;code&gt;%=&lt;/code&gt; 無条件に転送されます=、 &lt;code&gt;^^=&lt;/code&gt; 、 &lt;code&gt;&amp;amp;=&lt;/code&gt; 、 &lt;code&gt;|=&lt;/code&gt; 、 &lt;code&gt;^=&lt;/code&gt; 、 &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52c14604f1c472b8a4a8bbea3e846c210307c64e" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpUnary!op(get)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol) is forwarded to for unary operators &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt;. In addition, for unary operators &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;, &lt;code&gt;hook.hookOpUnary!op(payload)&lt;/code&gt; is called, where &lt;code&gt;payload&lt;/code&gt; is a reference to the value wrapped by &lt;code&gt;Checked&lt;/code&gt; so the hook can change it.</source>
          <target state="translated">定義されている場合、 &lt;code&gt;hook.hookOpUnary!op(get)&lt;/code&gt; （ &lt;code&gt;op&lt;/code&gt; は演算子記号）が単項演算子 &lt;code&gt;-&lt;/code&gt; および &lt;code&gt;~&lt;/code&gt; 転送されます。さらに、単項演算子 &lt;code&gt;++&lt;/code&gt; および &lt;code&gt;--&lt;/code&gt; 場合、 &lt;code&gt;hook.hookOpUnary!op(payload)&lt;/code&gt; が呼び出されます。ここで、 &lt;code&gt;payload&lt;/code&gt; は、 &lt;code&gt;Checked&lt;/code&gt; によってラップされた値への参照であるため、フックで変更できます。</target>
        </trans-unit>
        <trans-unit id="2297e50d0b2beb4cdd48e76ba56a839dcb04ab78" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookToHash(payload)&lt;/code&gt; (where &lt;code&gt;payload&lt;/code&gt; is a reference to the value wrapped by Checked) is forwarded to when &lt;code&gt;toHash&lt;/code&gt; is called on a Checked type. Custom hashing can be implemented in a &lt;code&gt;Hook&lt;/code&gt;, otherwise the built-in hashing is used.</source>
          <target state="translated">定義されている場合、 &lt;code&gt;hook.hookToHash(payload)&lt;/code&gt; （ &lt;code&gt;payload&lt;/code&gt; はCheckedによってラップされた値への参照）は、Checkedタイプで &lt;code&gt;toHash&lt;/code&gt; が呼び出されたときに転送されます。カスタムハッシュは &lt;code&gt;Hook&lt;/code&gt; で実装できます。それ以外の場合は、組み込みハッシュが使用されます。</target>
        </trans-unit>
        <trans-unit id="33310de24a417af9692c142b1ec271b4bb06c9e6" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.onLowerBound(value, bound)&lt;/code&gt; (where &lt;code&gt;value&lt;/code&gt; is the value being assigned) is forwarded to when the result of binary operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; is smaller than the smallest value representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">定義されている場合、二項演算子の結果 &lt;code&gt;+=&lt;/code&gt; 、 &lt;code&gt;-=&lt;/code&gt; 、 &lt;code&gt;*=&lt;/code&gt; 、 &lt;code&gt;/=&lt;/code&gt; 、 &lt;code&gt;%=&lt;/code&gt; 、 &lt;code&gt;^^=&lt;/code&gt; 、 &lt;code&gt;&amp;amp;=&lt;/code&gt; のときに、 &lt;code&gt;hook.onLowerBound(value, bound)&lt;/code&gt; （ &lt;code&gt;value&lt;/code&gt; は割り当てられる値）に転送されます、 &lt;code&gt;|=&lt;/code&gt; 、 &lt;code&gt;^=&lt;/code&gt; 、 &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; は、 &lt;code&gt;T&lt;/code&gt; で表現可能な最小値よりも小さい。</target>
        </trans-unit>
        <trans-unit id="ab6931e0e7ba4cd85c003adc62fe48bb16dad0a7" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; is forwarded to for unary operators that overflow but only if &lt;code&gt;hookOpUnary&lt;/code&gt; is not defined. Unary &lt;code&gt;~&lt;/code&gt; does not overflow; unary &lt;code&gt;-&lt;/code&gt; overflows only when the most negative value of a signed type is negated, and the result of the hook call is returned. When the increment or decrement operators overflow, the payload is assigned the result of &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt;. When a binary operator overflows, the result of &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; is returned, but only if &lt;code&gt;Hook&lt;/code&gt; does not define &lt;code&gt;hookOpBinary&lt;/code&gt;.</source>
          <target state="translated">定義されている場合、 &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; は、 &lt;code&gt;hookOpUnary&lt;/code&gt; が定義されていない場合にのみ、オーバーフローする単項演算子に転送されます。単項 &lt;code&gt;~&lt;/code&gt; はオーバーフローしません。単項 &lt;code&gt;-&lt;/code&gt; 符号付き型の最も負の値が否定され、フック呼び出しの結果が返された場合にのみオーバーフローします。インクリメント演算子またはデクリメント演算子がオーバーフローすると、ペイロードに &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; の結果が割り当てられます。 2項演算子がオーバーフローすると、 &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; が返されますが、これは &lt;code&gt;Hook&lt;/code&gt; が &lt;code&gt;hookOpBinary&lt;/code&gt; を定義していない場合に限られます。</target>
        </trans-unit>
        <trans-unit id="908a2f8c24579c24ba178c54fd857b4b41ae78ef" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.onUpperBound(value, bound)&lt;/code&gt; (where &lt;code&gt;value&lt;/code&gt; is the value being assigned) is forwarded to when the result of binary operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; is larger than the largest value representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">定義されている場合、 &lt;code&gt;hook.onUpperBound(value, bound)&lt;/code&gt; （ &lt;code&gt;value&lt;/code&gt; は割り当てられている値です）は、二項演算子の結果 &lt;code&gt;+=&lt;/code&gt; 、 &lt;code&gt;-=&lt;/code&gt; 、 &lt;code&gt;*=&lt;/code&gt; 、 &lt;code&gt;/=&lt;/code&gt; 、 &lt;code&gt;%=&lt;/code&gt; 、 &lt;code&gt;^^=&lt;/code&gt; 、 &lt;code&gt;&amp;amp;=&lt;/code&gt; に転送されます、 &lt;code&gt;|=&lt;/code&gt; 、 &lt;code&gt;^=&lt;/code&gt; 、 &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 、 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; は、 &lt;code&gt;T&lt;/code&gt; で表現可能な最大値よりも大きい。</target>
        </trans-unit>
        <trans-unit id="4d3755f1788c95f9d9709ea3791ec92f2804e77a" translate="yes" xml:space="preserve">
          <source>If e is a SliceExp, constant fold it.</source>
          <target state="translated">eがSliceExpならば、それを定数で折りたたむ。</target>
        </trans-unit>
        <trans-unit id="4e157bdef2847bcd47c86d8616eb969d0de41200" translate="yes" xml:space="preserve">
          <source>If e1 is a property function (template), resolve it.</source>
          <target state="translated">e1がプロパティ関数(テンプレート)の場合は、それを解決します。</target>
        </trans-unit>
        <trans-unit id="fe36cf6a431bba3d0f0866cfcc1c8bfbdb70659d" translate="yes" xml:space="preserve">
          <source>If either is null =&amp;gt; non-equal</source>
          <target state="translated">どちらかがnullの場合=&amp;gt;等しくない</target>
        </trans-unit>
        <trans-unit id="51547fe82011becc25f7663a54c1c79b37b3b626" translate="yes" xml:space="preserve">
          <source>If either operand is &lt;code&gt;real&lt;/code&gt;, the other operand is converted to &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="translated">いずれかのオペランドがある場合は &lt;code&gt;real&lt;/code&gt; 、もう一方のオペランドはに変換されます &lt;code&gt;real&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c828619435ec0d80d0eb291888f4070be2665b9" translate="yes" xml:space="preserve">
          <source>If either operand is a floating point type, the other is implicitly converted to floating point and they are brought to a common type via the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;.</source>
          <target state="translated">どちらかのオペランドが浮動小数点型の場合、もう一方は暗黙的に浮動小数点に変換され、&lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;通常の算術変換を&lt;/a&gt;介して共通の型に変換されます。</target>
        </trans-unit>
        <trans-unit id="19204c26120415c2143a5e03cf2be7f558db1190" translate="yes" xml:space="preserve">
          <source>If either the second or third expressions are of type &lt;code&gt;void&lt;/code&gt;, then the resulting type is &lt;code&gt;void&lt;/code&gt;. Otherwise, the second and third expressions are implicitly converted to a common type which becomes the result type of the conditional expression.</source>
          <target state="translated">2番目または3番目の式が &lt;code&gt;void&lt;/code&gt; 型の場合、結果の型は &lt;code&gt;void&lt;/code&gt; になります。それ以外の場合、2番目と3番目の式は暗黙的に共通の型に変換され、条件式の結果の型になります。</target>
        </trans-unit>
        <trans-unit id="653d0a49e3e776a2dacb4a126f5f7199b157c776" translate="yes" xml:space="preserve">
          <source>If expression can be tested for true or false, returns the modified expression. Otherwise returns ErrorExp.</source>
          <target state="translated">式が真か偽かをテストできる場合は、変更された式を返します。そうでない場合は ErrorExp を返します。</target>
        </trans-unit>
        <trans-unit id="b36e87ad6619937152cb1864f5c28a8d82857aaf" translate="yes" xml:space="preserve">
          <source>If expression is shared, check that we can access it. Give error message if not.</source>
          <target state="translated">式が共有されている場合は、それにアクセスできるかどうかを確認します。共有されていない場合はエラーメッセージを表示します。</target>
        </trans-unit>
        <trans-unit id="b903eb11d9ca574de1d125b6a0ddd43ec7f26143" translate="yes" xml:space="preserve">
          <source>If flag &lt;code&gt;KeepTerminator&lt;/code&gt; is set to &lt;code&gt;KeepTerminator.yes&lt;/code&gt;, then the delimiter is included in the strings returned.</source>
          <target state="translated">フラグ &lt;code&gt;KeepTerminator&lt;/code&gt; がKeepTerminator.yesに設定されている &lt;code&gt;KeepTerminator.yes&lt;/code&gt; 、返される文字列には区切り文字が含まれます。</target>
        </trans-unit>
        <trans-unit id="235b8759d68e4d6c00eac4cd7371849cd3084978" translate="yes" xml:space="preserve">
          <source>If found, return list entry that it is, else null.</source>
          <target state="translated">見つかった場合は、それがあるリストエントリを返し、そうでない場合はnullを返します。</target>
        </trans-unit>
        <trans-unit id="a226618dbb0d64b00416429ba20f88cb6f590b46" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point greater than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">func が範囲の現在の &lt;code&gt;front&lt;/code&gt; 以上の時点を生成した場合、&lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt;がスローされます。</target>
        </trans-unit>
        <trans-unit id="6bcd1b67b2b6132e6574059a063d80b5509091a8" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point greater than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. The range will be empty and iteration complete when func generates a time point equal to or less than the &lt;code&gt;begin&lt;/code&gt; of the interval.</source>
          <target state="translated">func が範囲の現在の &lt;code&gt;front&lt;/code&gt; 以上の時点を生成した場合、&lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt;がスローされます。func が間隔の &lt;code&gt;begin&lt;/code&gt; 以下の時点を生成すると、範囲は空になり、反復は完了します。</target>
        </trans-unit>
        <trans-unit id="eefd5cc7fe1ca2c7b897d183dc4a05399326e46f" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point less than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">funcが現在の範囲の &lt;code&gt;front&lt;/code&gt; 以下の時点を生成する場合、&lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt;がスローされます。</target>
        </trans-unit>
        <trans-unit id="c66509b1e052bea9e9d5481b7761f6c20d3b371f" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point less than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. The range will be empty and iteration complete when func generates a time point equal to or beyond the &lt;code&gt;end&lt;/code&gt; of the interval.</source>
          <target state="translated">funcが現在の範囲の &lt;code&gt;front&lt;/code&gt; 以下の時点を生成する場合、&lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt;がスローされます。 func が間隔の &lt;code&gt;end&lt;/code&gt; 以上の時点を生成すると、範囲は空になり、反復は完了します。</target>
        </trans-unit>
        <trans-unit id="74f0c5b3f5f366de0c8aea12cba32b6bdb7a7e22" translate="yes" xml:space="preserve">
          <source>If func retains state which changes as it is called, then some algorithms will not work correctly, because the range's &lt;code&gt;save&lt;/code&gt; will have failed to have really saved the range's state. To avoid such bugs, don't pass a delegate which is not logically pure to &lt;code&gt;fwdRange&lt;/code&gt;. If func is given the same time point with two different calls, it must return the same result both times.  Of course, none of the functions in this module have this problem, so it's only relevant for custom delegates.</source>
          <target state="translated">funcが呼び出されたときに変化する状態を保持している場合、範囲の &lt;code&gt;save&lt;/code&gt; が実際に範囲の状態を保存できなかったため、一部のアルゴリズムは正しく機能しません。このようなバグを回避するには、論理的に純粋ではないデリゲートを &lt;code&gt;fwdRange&lt;/code&gt; に渡さないでください。 funcに2つの異なる呼び出しで同じ時点が指定されている場合、両方の時点で同じ結果を返す必要があります。もちろん、このモジュールのどの関数にもこの問題はありません。そのため、カスタムデリゲートにのみ関係があります。</target>
        </trans-unit>
        <trans-unit id="082731789aa3a0c2389877b2540dad5fb393fea2" translate="yes" xml:space="preserve">
          <source>If func retains state which changes as it is called, then some algorithms will not work correctly, because the range's &lt;code&gt;save&lt;/code&gt; will have failed to have really saved the range's state. To avoid such bugs, don't pass a delegate which is not logically pure to &lt;code&gt;fwdRange&lt;/code&gt;. If func is given the same time point with two different calls, it must return the same result both times.  Of course, none of the functions in this module have this problem, so it's only relevant if when creating a custom delegate.</source>
          <target state="translated">funcが呼び出されたときに変化する状態を保持している場合、範囲の &lt;code&gt;save&lt;/code&gt; が実際に範囲の状態を保存できなかったため、一部のアルゴリズムは正しく機能しません。このようなバグを回避するには、論理的に純粋ではないデリゲートを &lt;code&gt;fwdRange&lt;/code&gt; に渡さないでください。funcに2つの異なる呼び出しで同じ時点が指定されている場合、両方の時点で同じ結果を返す必要があります。もちろん、このモジュールのどの関数にもこの問題はありません。そのため、カスタムデリゲートを作成する場合にのみ関係があります。</target>
        </trans-unit>
        <trans-unit id="811cb1951d7eca66363f0ab4a25ab0f68bd6c804" translate="yes" xml:space="preserve">
          <source>If function a function in a base class, return that base class.</source>
          <target state="translated">基底クラス内の関数であれば、その基底クラスを返します。</target>
        </trans-unit>
        <trans-unit id="3a618122aa9fe1978f9e550b5f42d584977ec33d" translate="yes" xml:space="preserve">
          <source>If in a quoted field any quote by itself, not at the end of a field, will end processing for that field.</source>
          <target state="translated">引用符で囲まれたフィールドの中で、フィールドの最後ではなく、それ自体が引用符で囲まれている場合、そのフィールドの処理は終了します。</target>
        </trans-unit>
        <trans-unit id="fc45bb57ad39df4d2be393733ec74789f2ef7133" translate="yes" xml:space="preserve">
          <source>If instantiated with &lt;code&gt;No.multiblock&lt;/code&gt;, it performs a search for the first zero bit in the bitmap and sets it.</source>
          <target state="translated">&lt;code&gt;No.multiblock&lt;/code&gt; でインスタンス化されている場合、ビットマップの最初のゼロビットの検索を実行して設定します。</target>
        </trans-unit>
        <trans-unit id="7b0f6cec4d5ea8c58428ba7c40e99097b7cb2322" translate="yes" xml:space="preserve">
          <source>If isNested() returns true, isThis() should return false, unless the function needs a dual-context pointer.</source>
          <target state="translated">isNested()が true を返した場合、関数がデュアルコンテキストポインタを必要としない限り、isThis()は false を返すべきです。</target>
        </trans-unit>
        <trans-unit id="b4d04375110c3b3230b38eb2d9c5c313ab9a4587" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;false&lt;/code&gt;, then the third expression is evaluated, and its result is the result of the conditional expression.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; の場合、3番目の式が評価され、その結果は条件式の結果になります。</target>
        </trans-unit>
        <trans-unit id="ba0ab9ea37044a2e2b630f8489bf8ed0e516e703" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;true&lt;/code&gt;, then the second expression is evaluated, and its result is the result of the conditional expression.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; の場合、2番目の式が評価され、その結果は条件式の結果になります。</target>
        </trans-unit>
        <trans-unit id="828463bf31c6d8c05164e51833a7bd26ece74f35" translate="yes" xml:space="preserve">
          <source>If it is desirable to persist a &lt;code&gt;Unique!T&lt;/code&gt; outside of its original scope, then it can be transferred. The transfer can be explicit, by calling &lt;code&gt;release&lt;/code&gt;, or implicit, when returning Unique from a function. The resource &lt;code&gt;T&lt;/code&gt; can be a polymorphic class object or instance of an interface, in which case Unique behaves polymorphically too.</source>
          <target state="translated">&lt;code&gt;Unique!T&lt;/code&gt; を元のスコープ外に永続化することが望ましい場合は、それを転送できます。転送は、 &lt;code&gt;release&lt;/code&gt; を呼び出すことによって明示的に行うことも、関数からUniqueを返すときに暗黙的に行うこともできます。リソース &lt;code&gt;T&lt;/code&gt; は、ポリモーフィッククラスオブジェクトまたはインターフェイスのインスタンスにすることができます。その場合、Uniqueもポリモーフィックに動作します。</target>
        </trans-unit>
        <trans-unit id="1a1dc588bc158cc467f4127355a3912b746c621f" translate="yes" xml:space="preserve">
          <source>If just type T is given and no variable v, then the catch clause is still executed.</source>
          <target state="translated">ちょうど型Tが与えられていて変数vが与えられていない場合、キャッチ句はまだ実行されています。</target>
        </trans-unit>
        <trans-unit id="f71f926a6db933017567619e75df00dc6712f06e" translate="yes" xml:space="preserve">
          <source>If multiple templates with the same</source>
          <target state="translated">同じテンプレートが複数ある場合</target>
        </trans-unit>
        <trans-unit id="35c6c44f6f67de6c4c0a779716275c68fe8b37b2" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;delimiter&lt;/code&gt; is given, then one trailing &lt;code&gt;'\r'&lt;/code&gt;, &lt;code&gt;'\n'&lt;/code&gt;, &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt;, &lt;code&gt;'\f'&lt;/code&gt;, &lt;code&gt;'\v'&lt;/code&gt;, &lt;a href=&quot;std_uni#lineSep&quot;&gt;&lt;code&gt;std.uni.lineSep&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;std_uni#paraSep&quot;&gt;&lt;code&gt;std.uni.paraSep&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;std_uni#nelSep&quot;&gt;&lt;code&gt;std.uni.nelSep&lt;/code&gt;&lt;/a&gt; is removed from the end of &lt;code&gt;str&lt;/code&gt;. If &lt;code&gt;str&lt;/code&gt; does not end with any of those characters, then it is returned unchanged.</source>
          <target state="translated">&lt;code&gt;delimiter&lt;/code&gt; が指定されていない場合、末尾に1つの &lt;code&gt;'\r'&lt;/code&gt; 、 &lt;code&gt;'\n'&lt;/code&gt; 、 &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; 、 &lt;code&gt;'\f'&lt;/code&gt; 、 &lt;code&gt;'\v'&lt;/code&gt; 、&lt;a href=&quot;std_uni#lineSep&quot;&gt; &lt;code&gt;std.uni.lineSep&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;std_uni#paraSep&quot;&gt; &lt;code&gt;std.uni.paraSep&lt;/code&gt; &lt;/a&gt;、または&lt;a href=&quot;std_uni#nelSep&quot;&gt; &lt;code&gt;std.uni.nelSep&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;str&lt;/code&gt; の末尾から削除されます。 &lt;code&gt;str&lt;/code&gt; がこれらの文字で終わっていない場合は、変更されずに返されます。</target>
        </trans-unit>
        <trans-unit id="2b0411e822ff9871e75f5fe6e95c3d0518b1b309" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;needle&lt;/code&gt; is provided, &lt;code&gt;pred(haystack.front)&lt;/code&gt; will be evaluated on each element of the input range.</source>
          <target state="translated">&lt;code&gt;needle&lt;/code&gt; が提供されない場合、 &lt;code&gt;pred(haystack.front)&lt;/code&gt; は入力範囲の各要素で評価されます。</target>
        </trans-unit>
        <trans-unit id="69633a75862efb516486b64d796be076d86f4c19" translate="yes" xml:space="preserve">
          <source>If no call to constructors via &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;super&lt;/code&gt; appear in a constructor, and the base class has a constructor, a call to &lt;code&gt;super()&lt;/code&gt; is inserted at the beginning of the constructor.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; または &lt;code&gt;super&lt;/code&gt; を介したコンストラクターの呼び出しがコンストラクターに表示されず、基本クラスにコンストラクターがある場合、 &lt;code&gt;super()&lt;/code&gt; の呼び出しがコンストラクターの先頭に挿入されます。</target>
        </trans-unit>
        <trans-unit id="a6ba6c3c787fc12e247d6c67731ac7ae3ae18393" translate="yes" xml:space="preserve">
          <source>If no calls to a delegating constructor or &lt;code&gt;super&lt;/code&gt; appear in a constructor, and the base class has a nullary constructor, a call to &lt;code&gt;super()&lt;/code&gt; is inserted at the beginning of the constructor. If that base class has a constructor that requires arguments and no nullary constructor, a matching call to &lt;code&gt;super&lt;/code&gt; is required.</source>
          <target state="translated">委任コンストラクターまたは &lt;code&gt;super&lt;/code&gt; の呼び出しがコンストラクターに表示されず、基本クラスにnullaryコンストラクターがある場合、 &lt;code&gt;super()&lt;/code&gt; の呼び出しがコンストラクターの先頭に挿入されます。その基本クラスに引数を必要とするコンストラクターがあり、nullaryコンストラクターがない場合は、 &lt;code&gt;super&lt;/code&gt; への一致する呼び出しが必要です。</target>
        </trans-unit>
        <trans-unit id="08c68d59ef2b4bb11a75a62d44b96024d217f2ea" translate="yes" xml:space="preserve">
          <source>If no catch handlers are there for the errors, then the program gracefully exits through the default error handler with an appropriate message.</source>
          <target state="translated">エラーに対するキャッチハンドラが存在しない場合、プログラムは適切なメッセージを表示してデフォルトのエラーハンドラを介して優雅に終了します。</target>
        </trans-unit>
        <trans-unit id="a3f4b45154d7d5df5948f5742dc5af04d95c91df" translate="yes" xml:space="preserve">
          <source>If no cycles are found, the ctors and tlsctors are replaced with the ones generated by this algorithm to preserve the old incorrect ordering behavior.</source>
          <target state="translated">サイクルが見つからない場合、ctorsとtlsctorsは、古い不正確な順序付けの動作を維持するために、このアルゴリズムによって生成されたもので置き換えられます。</target>
        </trans-unit>
        <trans-unit id="fd69e84bfca07a56902d7641663496f5b667fb84" translate="yes" xml:space="preserve">
          <source>If no data is available and the main thread access the range it will block until data becomes available. An exception to this is the &lt;code&gt;wait(Duration)&lt;/code&gt; method on the &lt;a href=&quot;#ChunkInputRange&quot;&gt;&lt;code&gt;ChunkInputRange&lt;/code&gt;&lt;/a&gt;. This method will wait at maximum for the specified duration and return true if data is available.</source>
          <target state="translated">データが利用できず、メインスレッドがその範囲にアクセスする場合、データが利用可能になるまでブロックされます。これの例外は、&lt;a href=&quot;#ChunkInputRange&quot;&gt; &lt;code&gt;ChunkInputRange&lt;/code&gt; の&lt;/a&gt; &lt;code&gt;wait(Duration)&lt;/code&gt; メソッドです。このメソッドは、指定された期間最大で待機し、データが利用可能な場合はtrueを返します。</target>
        </trans-unit>
        <trans-unit id="b37f49606e8cab3bb492c893e69c1a2e75dd1924" translate="yes" xml:space="preserve">
          <source>If no data is available and the main thread accesses the range it will block until data becomes available. An exception to this is the &lt;code&gt;wait(Duration)&lt;/code&gt; method on the &lt;a href=&quot;#LineInputRange&quot;&gt;&lt;code&gt;LineInputRange&lt;/code&gt;&lt;/a&gt;. This method will wait at maximum for the specified duration and return true if data is available.</source>
          <target state="translated">データが利用できず、メインスレッドが範囲にアクセスする場合、データが利用可能になるまでメインスレッドはブロックします。これの例外は、&lt;a href=&quot;#LineInputRange&quot;&gt; &lt;code&gt;LineInputRange&lt;/code&gt; の&lt;/a&gt; &lt;code&gt;wait(Duration)&lt;/code&gt; メソッドです。このメソッドは、指定された期間最大で待機し、データが利用可能な場合はtrueを返します。</target>
        </trans-unit>
        <trans-unit id="dee768fdd957e908ee906de5d9f09ab3f15a2b74" translate="yes" xml:space="preserve">
          <source>If no explicit seed is provided, the first element of each work unit is used as a seed. For the final reduction, the result from the first work unit is used as the seed.</source>
          <target state="translated">明示的なシードが提供されていない場合、各作業単位の最初の要素がシードとして使用されます。最終的な削減では,最初の作業単位の結果がシードとして使用されます.</target>
        </trans-unit>
        <trans-unit id="b9beba693b6541f5c4a623aa8005a14a8c088860" translate="yes" xml:space="preserve">
          <source>If no function to call is specified, &lt;code&gt;each&lt;/code&gt; defaults to doing nothing but consuming the entire range. &lt;code&gt;r.front&lt;/code&gt; will be evaluated, but that can be avoided by specifying a lambda with a &lt;code&gt;lazy&lt;/code&gt; parameter.</source>
          <target state="translated">呼び出す関数が指定されていない場合、 &lt;code&gt;each&lt;/code&gt; 関数はデフォルトで範囲全体を消費するだけです。 &lt;code&gt;r.front&lt;/code&gt; が評価されますが、 &lt;code&gt;lazy&lt;/code&gt; パラメーターでラムダを指定することで回避できます。</target>
        </trans-unit>
        <trans-unit id="7b0e9e2df565b7ef14de5d370ee2e7f5508ed495" translate="yes" xml:space="preserve">
          <source>If no needle is provided, the &lt;code&gt;haystack&lt;/code&gt; is advanced as long as &lt;code&gt;pred&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;. Similarly, the haystack is positioned so as &lt;code&gt;pred&lt;/code&gt; evaluates to &lt;code&gt;false&lt;/code&gt; for &lt;code&gt;haystack.front&lt;/code&gt;.</source>
          <target state="translated">針が提供されない場合、 &lt;code&gt;pred&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; と評価される限り、 &lt;code&gt;haystack&lt;/code&gt; は進みます。同様に、干し草の山のように配置され &lt;code&gt;pred&lt;/code&gt; に評価 &lt;code&gt;false&lt;/code&gt; ため &lt;code&gt;haystack.front&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8015dc4a71527e3287d7f4a1a1531193efdd9ebe" translate="yes" xml:space="preserve">
          <source>If no random number generator is passed to &lt;code&gt;randomCover&lt;/code&gt;, the thread-global RNG rndGen will be used internally.</source>
          <target state="translated">&lt;code&gt;randomCover&lt;/code&gt; に乱数ジェネレータが渡されない場合、スレッドグローバルRNG rndGenが内部的に使用されます。</target>
        </trans-unit>
        <trans-unit id="ec48dd4e26e9c9b7bb1bba08590ef49f6e8b00b5" translate="yes" xml:space="preserve">
          <source>If no separator is passed, the  predicate &lt;code&gt;isTerminator&lt;/code&gt; decides whether to accept an element of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">セパレータが渡されない場合、述語 &lt;code&gt;isTerminator&lt;/code&gt; は &lt;code&gt;r&lt;/code&gt; の要素を受け入れるかどうかを決定します。</target>
        </trans-unit>
        <trans-unit id="4f27eb4bbcd5d830894d40b205272557d1b8c1c3" translate="yes" xml:space="preserve">
          <source>If no unittest custom handlers are registered, the following algorithm is executed (the behavior can be affected by the &lt;code&gt;--DRT-testmode&lt;/code&gt; switch below):</source>
          <target state="translated">unittestカスタムハンドラーが登録されていない場合、次のアルゴリズムが実行されます（動作は以下の &lt;code&gt;--DRT-testmode&lt;/code&gt; スイッチの影響を受ける可能性があります）。</target>
        </trans-unit>
        <trans-unit id="d5a9c9c4272e471499a4566ff40a97f218d487f9" translate="yes" xml:space="preserve">
          <source>If no unittest custom handlers are registered, the following algorithm is executed (the behavior can be affected by the &lt;code&gt;--DRT-testmode&lt;/code&gt; switch below): 1. Run all unit tests, tracking tests executed and passes. For each that fails, print the stack trace, and continue. 2. If there are no failures, set the summarize flag to false, and the runMain flag to true. 3. If there are failures, set the summarize flag to true, and the runMain flag to false.</source>
          <target state="translated">unittestカスタムハンドラーが登録されていない場合は、次のアルゴリズムが実行されます（動作は以下の &lt;code&gt;--DRT-testmode&lt;/code&gt; スイッチの影響を受ける可能性があります）。1.すべての単体テストを実行し、テストを実行して合格します。失敗したそれぞれについて、スタックトレースを出力して続行します。2.失敗がない場合は、要約フラグをfalseに設定し、runMainフラグをtrueに設定します。3.エラーがある場合は、summaryフラグをtrueに、runMainフラグをfalseに設定します。</target>
        </trans-unit>
        <trans-unit id="8e742609c87c27dd7441a0c05820a232e71bfca1" translate="yes" xml:space="preserve">
          <source>If no unittests were present, set summarize to false, and runMain to true.</source>
          <target state="translated">unittestsが存在しない場合は、summaryizeをfalseに設定し、runMainをtrueに設定します。</target>
        </trans-unit>
        <trans-unit id="fe70a6ffb1eaff978d001d003d35769a95cf2acb" translate="yes" xml:space="preserve">
          <source>If non-zero, prefix result with 0x (0X).</source>
          <target state="translated">0 以外の場合は、結果の先頭に 0x (0X)を付けます。</target>
        </trans-unit>
        <trans-unit id="bb201c468fcb1936a1cc835ca2cb32dd5d97a148" translate="yes" xml:space="preserve">
          <source>If none of the case expressions match, and there is a default statement, the default statement is transferred to.</source>
          <target state="translated">大文字小文字の表現がどれも一致せず、デフォルト文がある場合は、デフォルト文が転送されます。</target>
        </trans-unit>
        <trans-unit id="ab5f1042c0495e282ce28b3b52048c3700563975" translate="yes" xml:space="preserve">
          <source>If none of the choice matches, a &lt;code&gt;SwitchError&lt;/code&gt; will be thrown. &lt;code&gt;SwitchError&lt;/code&gt; will also be thrown if not all the choices are void and a void choice was executed without throwing anything.</source>
          <target state="translated">&lt;code&gt;SwitchError&lt;/code&gt; 選択肢にも一致しない場合、SwitchErrorがスローされます。 &lt;code&gt;SwitchError&lt;/code&gt; は、すべての選択肢がvoidではなく、何もスローせずにvoidの選択肢が実行された場合にもスローされます。</target>
        </trans-unit>
        <trans-unit id="3ed3959f15bba3be1a16efa6393b19ce9aeff019" translate="yes" xml:space="preserve">
          <source>If not specified, the</source>
          <target state="translated">指定されていない場合は</target>
        </trans-unit>
        <trans-unit id="fe9db14bd961ccfeeb8601ee73a6483367ad2a6a" translate="yes" xml:space="preserve">
          <source>If one is a better match than the other, or one compiles and the other does not, the first is selected.</source>
          <target state="translated">一方が他方よりも優れている場合や、一方がコンパイルされていて他方がコンパイルされていない場合は、最初の方が選択されます。</target>
        </trans-unit>
        <trans-unit id="6dedca9993144f5a2bfb52216f61891e811d98ea" translate="yes" xml:space="preserve">
          <source>If one of the arguments is a &lt;code&gt;NaN&lt;/code&gt;, the other is returned.</source>
          <target state="translated">引数の1つが &lt;code&gt;NaN&lt;/code&gt; の場合、もう1つが返されます。</target>
        </trans-unit>
        <trans-unit id="38f309363d54cf09070c11d4dd142dc6d8bfb60d" translate="yes" xml:space="preserve">
          <source>If one of the arguments is a NaN, the other is returned.</source>
          <target state="translated">引数の片方がNaNの場合、もう片方が返されます。</target>
        </trans-unit>
        <trans-unit id="f22c395490cca8ea1c81135fd8838b0c5b0afefa" translate="yes" xml:space="preserve">
          <source>If one of the numbers is an integral and the other is a floating-point number, &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if and only if the integral can be converted exactly (without approximation) to the floating-point number. This is in order to preserve transitivity of equality: if &lt;code&gt; hookOpEquals(x, y)&lt;/code&gt; and &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt; then &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt;, in case &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; are a mix of integral and floating-point numbers.</source>
          <target state="translated">数値の一方が整数で他方が浮動小数点数の場合、 &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; は、整数を浮動小数点数に（近似なしで）正確に変換できる場合にのみ &lt;code&gt;true&lt;/code&gt; を返します。場合：これは、等価の推移を維持するためにある &lt;code&gt; hookOpEquals(x, y)&lt;/code&gt; と &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt; 次いで &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt; ケースにおいて、 &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; 、及び &lt;code&gt;z&lt;/code&gt; 一体と浮動小数点数の組み合わせであります。</target>
        </trans-unit>
        <trans-unit id="47e27965329d106e5c510ac4b7c35d3cf65701ae" translate="yes" xml:space="preserve">
          <source>If one of the numbers is an integral and the other is a floating-point number, &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; returns a floating-point number that is &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;x &amp;lt; y&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;x == y&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;x &amp;gt; y&lt;/code&gt;, and &lt;code&gt;NaN&lt;/code&gt; if the floating-point number is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">数字の一つは一体であり、他方は浮動小数点数である場合 &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; である浮動小数点数を返す &lt;code&gt;-1&lt;/code&gt; 場合 &lt;code&gt;x &amp;lt; y&lt;/code&gt; 、 &lt;code&gt;0&lt;/code&gt; であれば &lt;code&gt;x == y&lt;/code&gt; 、 &lt;code&gt;1&lt;/code&gt; であれば &lt;code&gt;x &amp;gt; y&lt;/code&gt; 、および &lt;code&gt;NaN&lt;/code&gt; の浮動小数点数である場合に &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4188be61c77849339804ae3977d382498bd8812e" translate="yes" xml:space="preserve">
          <source>If one operand is an enum and the other is the base type of that enum, the result is the base type.</source>
          <target state="translated">一方のオペランドがenumで、他方のオペランドがそのenumの基底型である場合、結果は基底型となります。</target>
        </trans-unit>
        <trans-unit id="422f2e869457e9aec8090f25e67e71da6e5ae6e8" translate="yes" xml:space="preserve">
          <source>If one or both of the operand types is an enum after undergoing the above conversions, the result type is:</source>
          <target state="translated">上記の変換を行った後、オペランド型の片方または両方がenumである場合、結果の型は次のようになります。</target>
        </trans-unit>
        <trans-unit id="34b4e760890c5916b5f472cf9ec3f9d946f615cd" translate="yes" xml:space="preserve">
          <source>If one or both operands are floating point, then a floating point comparison is performed.</source>
          <target state="translated">片方または両方のオペランドが浮動小数点の場合、浮動小数点比較が実行されます。</target>
        </trans-unit>
        <trans-unit id="f34527129f419587a7b124534783120be01591c6" translate="yes" xml:space="preserve">
          <source>If one range is infinite and the other finite, then the finite range must be a forward range, and the infinite range can be an input range.</source>
          <target state="translated">一方の範囲が無限で他方の範囲が有限であれば、有限の範囲は順方向の範囲でなければならず、無限の範囲は入力範囲であってもよい。</target>
        </trans-unit>
        <trans-unit id="1493b0ab4b81a5a5d799727a74239f7ced24db39" translate="yes" xml:space="preserve">
          <source>If only one range is offered to &lt;code&gt;Chain&lt;/code&gt; or &lt;code&gt;chain&lt;/code&gt;, the &lt;code&gt;Chain&lt;/code&gt; type exits the picture by aliasing itself directly to that range's type.</source>
          <target state="translated">&lt;code&gt;Chain&lt;/code&gt; または &lt;code&gt;chain&lt;/code&gt; に提供される範囲が1つだけの場合、 &lt;code&gt;Chain&lt;/code&gt; タイプは、その範囲のタイプに直接エイリアスすることにより、画像を終了します。</target>
        </trans-unit>
        <trans-unit id="4f4dfc7af6d318725cd2bb6acc7371848e22877c" translate="yes" xml:space="preserve">
          <source>If only one type is passed, then an array of that type. Otherwise, an array of &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">1つのタイプのみが渡される場合、そのタイプの配列。それ以外の場合は、&lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt;の配列。</target>
        </trans-unit>
        <trans-unit id="f80a4ee1709480a885baa729f38d366951608f11" translate="yes" xml:space="preserve">
          <source>If operands are integral types</source>
          <target state="translated">オペランドが積分型の場合</target>
        </trans-unit>
        <trans-unit id="c17f6322872f795083ddb63a91c502026d7f7e3d" translate="yes" xml:space="preserve">
          <source>If overlapping is required, use &lt;a href=&quot;https://dlang.org/phobos/std_algorithm_mutation.html#copy&quot;&gt;&lt;code&gt;std.algorithm.mutation.copy&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">オーバーラップが必要な場合は、&lt;a href=&quot;https://dlang.org/phobos/std_algorithm_mutation.html#copy&quot;&gt; &lt;code&gt;std.algorithm.mutation.copy&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="dcfac2e8846ad57a33a3bc26acae8df77dfcdb25" translate="yes" xml:space="preserve">
          <source>If overridding &lt;code&gt;Object.opEquals()&lt;/code&gt; for classes, the class member function signature should look like:</source>
          <target state="translated">クラスの &lt;code&gt;Object.opEquals()&lt;/code&gt; をオーバーライドする場合、クラスメンバー関数のシグネチャは次のようになります。</target>
        </trans-unit>
        <trans-unit id="d70cff54f302f2d4a422baa59aebb43764d5cd42" translate="yes" xml:space="preserve">
          <source>If overriding &lt;code&gt;Object.opCmp()&lt;/code&gt; for classes, the class member function signature should look like:</source>
          <target state="translated">クラスの &lt;code&gt;Object.opCmp()&lt;/code&gt; をオーバーライドする場合、クラスメンバー関数のシグネチャは次のようになります。</target>
        </trans-unit>
        <trans-unit id="3e09a8be6b9d197eccbe61876283b5ca6720c550" translate="yes" xml:space="preserve">
          <source>If p is null, no operation is performed.</source>
          <target state="translated">pがnullの場合、操作は行われません。</target>
        </trans-unit>
        <trans-unit id="352e9b1490dbc9b0a48acbedafe6ae17ff5f3152" translate="yes" xml:space="preserve">
          <source>If paramsym is null a new ScopeDsymbol is used in place of paramsym.</source>
          <target state="translated">paramsymがnullの場合は、新しいScopeDsymbolがparamsymの代わりに使われます。</target>
        </trans-unit>
        <trans-unit id="0167129cd52bf73eb27d8ebdabfdbade4013fad0" translate="yes" xml:space="preserve">
          <source>If passed in a range of code points, returns a range with equivalent capabilities.</source>
          <target state="translated">コードポイントの範囲で渡された場合、同等の能力を持つ範囲を返します。</target>
        </trans-unit>
        <trans-unit id="15542b3779f094229ad4949cf6c05be1fd8cee3c" translate="yes" xml:space="preserve">
          <source>If pointers to D garbage collector allocated memory are passed to C functions, it's critical to ensure that that memory will not be collected by the garbage collector before the C function is done with it. This is accomplished by:</source>
          <target state="translated">D のガベージコレクタに割り当てられたメモリへのポインタが C 関数に渡される場合、C 関数がそれを処理する前に、そのメモリがガベージコレクタによって収集されないことを確実にすることが重要です。これは次のようにして達成されます。</target>
        </trans-unit>
        <trans-unit id="0dd282293b2dd30b59ba588f24339bbfcbc55f38" translate="yes" xml:space="preserve">
          <source>If pointers to memory allocated on the D garbage collector heap are passed to C++ functions, it's critical to ensure that the referenced memory will not be collected by the D garbage collector before the C++ function is done with it. This is accomplished by:</source>
          <target state="translated">D ガベージコレクタヒープに割り当てられたメモリへのポインタが C++関数に渡される場合、C++関数がそれを処理する前に、参照されたメモリが D ガベージコレクタによって収集されないようにすることが重要です。これは次のようにして達成されます。</target>
        </trans-unit>
        <trans-unit id="0fae4029daa6372cee7e8e40ab986342b94efc26" translate="yes" xml:space="preserve">
          <source>If possible, convert array initializer to associative array initializer.</source>
          <target state="translated">可能であれば、配列の初期化子を連想配列の初期化子に変換します。</target>
        </trans-unit>
        <trans-unit id="917024e995f1fa2c71d6754ac363cc3314dc229d" translate="yes" xml:space="preserve">
          <source>If present, the</source>
          <target state="translated">存在する場合は</target>
        </trans-unit>
        <trans-unit id="0b88da18898e09a28c0b2bdc7b134ad9a375efc5" translate="yes" xml:space="preserve">
          <source>If range is a range of bytes, an &lt;code&gt;Encoder&lt;/code&gt; that iterates over the bytes of the corresponding Base64 encoding.  If range is a range of ranges of bytes, an &lt;code&gt;Encoder&lt;/code&gt; that iterates over the Base64 encoded strings of each element of the range.  In both cases, the returned &lt;code&gt;Encoder&lt;/code&gt; will be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; if the given &lt;code&gt;range&lt;/code&gt; is at least a forward range, otherwise it will be only an input range.</source>
          <target state="translated">rangeがバイトの範囲の場合、対応するBase64エンコーディングのバイトを反復する &lt;code&gt;Encoder&lt;/code&gt; 。 rangeがバイトの範囲の範囲である場合、範囲の各要素のBase64エンコードされた文字列を反復する &lt;code&gt;Encoder&lt;/code&gt; 。両方の場合において、返さ &lt;code&gt;Encoder&lt;/code&gt; なり&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;前進レンジ&lt;/a&gt;与えられた場合 &lt;code&gt;range&lt;/code&gt; それ以外の場合のみ入力範囲となり、少なくとも前進レンジです。</target>
        </trans-unit>
        <trans-unit id="8fcc566f870dfdc11f9cf5642881af956a3edafb" translate="yes" xml:space="preserve">
          <source>If range is a range of characters, a &lt;code&gt;Decoder&lt;/code&gt; that iterates over the bytes of the corresponding Base64 decoding.  If range is a range of ranges of characters, a &lt;code&gt;Decoder&lt;/code&gt; that iterates over the decoded strings corresponding to each element of the range. In this case, the length of each subrange must be a multiple of 4; the returned decoder does not keep track of Base64 decoding state across subrange boundaries.  In both cases, the returned &lt;code&gt;Decoder&lt;/code&gt; will be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; if the given &lt;code&gt;range&lt;/code&gt; is at least a forward range, otherwise it will be only an input range.  If the input data contains characters not found in the base alphabet of the current Base64 encoding scheme, the returned range may throw a &lt;code&gt;Base64Exception&lt;/code&gt;.</source>
          <target state="translated">rangeが文字の範囲の場合、対応するBase64デコードのバイトを反復する &lt;code&gt;Decoder&lt;/code&gt; 。 rangeが文字の範囲の範囲である場合、範囲の各要素に対応するデコードされた文字列を反復する &lt;code&gt;Decoder&lt;/code&gt; 。この場合、各部分範囲の長さは4の倍数でなければなりません。返されたデコーダーは、サブ範囲の境界を越えてBase64デコード状態を追跡しません。両方の場合において、返さ &lt;code&gt;Decoder&lt;/code&gt; なり&lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;前進レンジ&lt;/a&gt;与えられた場合 &lt;code&gt;range&lt;/code&gt; それ以外の場合のみ入力範囲となり、少なくとも前進レンジです。入力データに現在のBase64エンコーディングスキームのベースアルファベットにない文字が含まれている場合、返される範囲は &lt;code&gt;Base64Exception&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b6eb7ddfbf5a47c6c6af2b15e78fb247a252fb4" translate="yes" xml:space="preserve">
          <source>If same exact type =&amp;gt; one call to method opEquals</source>
          <target state="translated">同じ型の場合=&amp;gt;メソッドopEqualsの1回の呼び出し</target>
        </trans-unit>
        <trans-unit id="89afd532fed79af758875995d860db76e2e127dd" translate="yes" xml:space="preserve">
          <source>If set at runtime, &lt;code&gt;min&lt;/code&gt; and/or &lt;code&gt;max&lt;/code&gt; must be initialized appropriately.</source>
          <target state="translated">実行時に設定する場合、 &lt;code&gt;min&lt;/code&gt; &lt;code&gt;max&lt;/code&gt; または最大値、あるいはその両方を適切に初期化する必要があります。</target>
        </trans-unit>
        <trans-unit id="7d613cefcf14fab9fa1cdf592c4b64df5fd4a02e" translate="yes" xml:space="preserve">
          <source>If set at runtime, &lt;code&gt;min&lt;/code&gt; and/or &lt;code&gt;max&lt;/code&gt; must be initialized appropriately. The block must have been allocated with this freelist, and no dynamic changing of &lt;code&gt;min&lt;/code&gt; or &lt;code&gt;max&lt;/code&gt; is allowed to occur between allocation and deallocation.</source>
          <target state="translated">実行時に設定する場合、 &lt;code&gt;min&lt;/code&gt; &lt;code&gt;max&lt;/code&gt; または最大値、あるいはその両方を適切に初期化する必要があります。ブロックはこのフリーリストで割り当てられている必要があり、割り当てと割り当て解除の間で &lt;code&gt;min&lt;/code&gt; &lt;code&gt;max&lt;/code&gt; または最大値の動的な変更を行うことはできません。</target>
        </trans-unit>
        <trans-unit id="12dba39acb6108d02380b6b46f58548fdd12a457" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;AllowDayOverflow.no&lt;/code&gt;, then day overflow is not allowed.</source>
          <target state="translated">&lt;code&gt;AllowDayOverflow.no&lt;/code&gt; に設定すると、日のオーバーフローは許可されません。</target>
        </trans-unit>
        <trans-unit id="0c05e2e8281e59d8e307dc66be3d2cc276d8fa30" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;AutoStart.no&lt;/code&gt;, then the StopWatch is not started when it is constructed.</source>
          <target state="translated">&lt;code&gt;AutoStart.no&lt;/code&gt; に設定されている場合、StopWatchは構築時に開始されません。</target>
        </trans-unit>
        <trans-unit id="d6add4cf35e8c50b2af6d41b382ebe3f7e3e974a" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;AutoStart.no&lt;/code&gt;, then the stopwatch is not started when it is constructed.</source>
          <target state="translated">&lt;code&gt;AutoStart.no&lt;/code&gt; に設定した場合、ストップウォッチは構築時に開始されません。</target>
        </trans-unit>
        <trans-unit id="e084739a519921a28023083912a24037cae39c78" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;CheckDns.no&lt;/code&gt;, isEmail does not perform DNS checking.</source>
          <target state="translated">&lt;code&gt;CheckDns.no&lt;/code&gt; に設定すると、isEmailはDNSチェックを実行しません。</target>
        </trans-unit>
        <trans-unit id="0e1f47a96e002fe723252c695ba57f0bd6e6ab0f" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;OpenRight.yes&lt;/code&gt;, then the interval is open to the right (last element is not included).</source>
          <target state="translated">&lt;code&gt;OpenRight.yes&lt;/code&gt; に設定した場合、間隔は右側に開かれます（最後の要素は含まれません）。</target>
        </trans-unit>
        <trans-unit id="37becabb79a088b28ac5682f3e5ecf44b42c3e44" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;PopFirst.no&lt;/code&gt;, then popFront is not called before returning the range.</source>
          <target state="translated">&lt;code&gt;PopFirst.no&lt;/code&gt; に設定すると、範囲を返す前にpopFrontは呼び出されません。</target>
        </trans-unit>
        <trans-unit id="c46457e61c98538473682050d8870e6910707094" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;SortOutput.no&lt;/code&gt;, the output should not be sorted.</source>
          <target state="translated">&lt;code&gt;SortOutput.no&lt;/code&gt; に設定した場合、出力はソートされません。</target>
        </trans-unit>
        <trans-unit id="00965390f3dcb757da046e66cf3e12ece6325eda" translate="yes" xml:space="preserve">
          <source>If set, 0 is the only allowed &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-1985#Denormalized_numbers&quot;&gt; IEEE754 denormalized&lt;/a&gt; number. Requires allowDenorm and storeNormalized.</source>
          <target state="translated">設定されている場合、0が唯一許可される&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-1985#Denormalized_numbers&quot;&gt;IEEE754非正規化&lt;/a&gt;数です。allowDenormとstoreNormalizedが必要です。</target>
        </trans-unit>
        <trans-unit id="61485b68856bc9bc475231ad8439460508956a5d" translate="yes" xml:space="preserve">
          <source>If set, select an exponent bias such that max_exp = 1. i.e. so that the maximum value is &amp;gt;= 1.0 and &amp;lt; 2.0. Ignored if the exponent bias is manually specified.</source>
          <target state="translated">設定されている場合は、max_exp = 1となるような指数バイアスを選択します。つまり、最大値が1.0以上2.0未満になるようにします。指数バイアスが手動で指定されている場合は無視されます。</target>
        </trans-unit>
        <trans-unit id="b15a8a24ac3c0abdda604fa6be697872fed5e457" translate="yes" xml:space="preserve">
          <source>If set, unsigned custom floats are assumed to be negative.</source>
          <target state="translated">設定されている場合、符号なしカスタムフロートは負の値とみなされます。</target>
        </trans-unit>
        <trans-unit id="96c1d18878474b954f19c1048ca19bc4cc441ff0" translate="yes" xml:space="preserve">
          <source>If size dependencies are inevitable, put a &lt;code&gt;static assert&lt;/code&gt; in the code to verify it:</source>
          <target state="translated">サイズの依存関係が避けられない場合は、コードに &lt;code&gt;static assert&lt;/code&gt; を挿入して確認します。</target>
        </trans-unit>
        <trans-unit id="c4932da89fb63071147ad73f57504dc48f8f86d2" translate="yes" xml:space="preserve">
          <source>If some of these fields is not NULL, it is a pointer to b_data.</source>
          <target state="translated">これらのフィールドの一部がNULLでない場合は、b_dataへのポインタとなります。</target>
        </trans-unit>
        <trans-unit id="bf8032a0e0aff5e21ec9404228bec256c45b8757" translate="yes" xml:space="preserve">
          <source>If source has internal pointers that point to itself and doesn't define opPostMove, it cannot be moved, and will trigger an assertion failure.</source>
          <target state="translated">ソースがそれ自身を指す内部ポインタを持ち、opPostMove を定義していない場合、それを移動することはできず、アサーション失敗のトリガーとなります。</target>
        </trans-unit>
        <trans-unit id="c4372423a2292ca511a5a4c383dba5ab95bc4f7d" translate="yes" xml:space="preserve">
          <source>If source has internal pointers that point to itself, it cannot be moved, and will trigger an assertion failure.</source>
          <target state="translated">ソースがそれ自身を指す内部ポインタを持っている場合、それを移動することはできず、アサーション失敗のトリガーとなります。</target>
        </trans-unit>
        <trans-unit id="b61714985a37455e4a9923539bc1db8640864a65" translate="yes" xml:space="preserve">
          <source>If splitting a string on whitespace and token compression is desired, consider using &lt;code&gt;splitter&lt;/code&gt; without specifying a separator.</source>
          <target state="translated">空白とトークン圧縮で文字列を分割する必要がある場合は、セパレータを指定せずに &lt;code&gt;splitter&lt;/code&gt; を使用することを検討してください。</target>
        </trans-unit>
        <trans-unit id="05b6ffe797342cf0d1028469f63301e251d90fab" translate="yes" xml:space="preserve">
          <source>If splitting of data transfer is enabled this callback is called after download of an individual chunk finished. Note! After this callback was set then it have to be called FOR ALL chunks. Even if downloading of this chunk was skipped in CHUNK_BGN_FUNC. This is the reason why we don't need &quot;transfer_info&quot; parameter in this callback and we are not interested in &quot;remains&quot; parameter too.</source>
          <target state="translated">データ転送の分割が有効な場合、このコールバックは個々のチャンクのダウンロードが完了した後に呼び出されます。注意! このコールバックが設定された後は、全てのチャンクに対してコールされなければなりません。CHUNK_BGN_FUNC でこのチャンクのダウンロードがスキップされた場合でも、コールバックはすべてのチャンクに対してコールされなければなりません。これが、このコールバックで &quot;transfer_info &quot;パラメータを必要としない理由であり、&quot;resources &quot;パラメータにも興味がありません。</target>
        </trans-unit>
        <trans-unit id="42671fc7da4232343c7b0b928fc5d03d90a644e7" translate="yes" xml:space="preserve">
          <source>If statements provide simple conditional execution of statements.</source>
          <target state="translated">Ifステートメントは、ステートメントの単純な条件付き実行を提供します。</target>
        </trans-unit>
        <trans-unit id="9c00c0869eed3767fe39aeae02ecce87d06c6f2e" translate="yes" xml:space="preserve">
          <source>If struct constructor is annotated with &lt;code&gt;@disable&lt;/code&gt; and has an empty &lt;a href=&quot;function#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt;, the struct has disabled default construction. The only way it can be constructed is via a call to another constructor with a non-empty</source>
          <target state="translated">構造体コンストラクターに &lt;code&gt;@disable&lt;/code&gt; アノテーションが付けられ、空の&lt;a href=&quot;function#ParameterList&quot;&gt;&lt;i&gt;ParameterListがある&lt;/i&gt;&lt;/a&gt;場合、構造体はデフォルトの構築を無効にします。構築できる唯一の方法は、空でない別のコンストラクターを呼び出すことです。</target>
        </trans-unit>
        <trans-unit id="944569416617efaa7082cf853e519ff0670f8407" translate="yes" xml:space="preserve">
          <source>If struct invariant checking is turned on, the struct invariant is called at the end of the constructor.</source>
          <target state="translated">構造体不変検査をオンにすると、コンストラクタの最後に構造体不変が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="d7768f4c2da4924ba7acf617ca9aea18a8c9c30c" translate="yes" xml:space="preserve">
          <source>If structs declare an &lt;code&gt;opCmp&lt;/code&gt; member function, it should have the following form:</source>
          <target state="translated">構造体が &lt;code&gt;opCmp&lt;/code&gt; メンバー関数を宣言する場合は、次の形式にする必要があります。</target>
        </trans-unit>
        <trans-unit id="3992d8b7bb5105984cffe3cb78e47194ffe3ff8f" translate="yes" xml:space="preserve">
          <source>If structs declare an &lt;code&gt;opEquals&lt;/code&gt; member function for the identity comparison, it could have several forms, such as:</source>
          <target state="translated">構造体がID比較のための &lt;code&gt;opEquals&lt;/code&gt; メンバー関数を宣言する場合、次のようないくつかの形式が考えられます。</target>
        </trans-unit>
        <trans-unit id="a998ede0b415c72a4f5c3800b4d3a122980f04c1" translate="yes" xml:space="preserve">
          <source>If such a match occurs, the inout is considered the common qualifier of the matched qualifiers. If more than two parameters exist, the common qualifier calculation is recursively applied.</source>
          <target state="translated">このような一致が発生した場合、inoutは一致した修飾子の共通修飾子とみなされます。2つ以上のパラメータが存在する場合、共通修飾子の計算は再帰的に適用されます。</target>
        </trans-unit>
        <trans-unit id="b30b7b06cd1e2f9ae926af9377511bb1cde4d9ab" translate="yes" xml:space="preserve">
          <source>If such an</source>
          <target state="translated">もしそのような</target>
        </trans-unit>
        <trans-unit id="a7624c537a3b1ba34be043fd5ddb463081b0a9fb" translate="yes" xml:space="preserve">
          <source>If template type parameters match the literal expressions on function arguments, the deduced types may consider narrowing conversions of them.</source>
          <target state="translated">テンプレート型のパラメータが関数引数のリテラル式と一致する場合、推論型はそれらの変換を絞り込むことを検討してもよい。</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">の場合は</target>
        </trans-unit>
        <trans-unit id="47a53d62849ea833a758681edda290d5ad91413e" translate="yes" xml:space="preserve">
          <source>If the .d source file starts with the string &quot;Ddoc&quot; then it is treated as general purpose documentation, not as a D code source file. From immediately after the &quot;Ddoc&quot; string to the end of the file or any &quot;Macros:&quot; section forms the document. No automatic highlighting is done to that text, other than highlighting of D code embedded between lines delineated with --- lines. Only macro processing is done.</source>
          <target state="translated">.d ソースファイルが文字列 &quot;Ddoc&quot; で始まる場合、それは D コードのソースファイルとしてではなく、汎用ドキュメントとして扱われます。文字列 &quot;Ddoc &quot;の直後からファイルの最後まで、あるいは &quot;Macros:&quot;セクションがドキュメントを形成しています。そのテキストには、---行で区切られた行間に埋め込まれたDコードのハイライト以外の自動ハイライトは行われません。マクロ処理のみが行われます。</target>
        </trans-unit>
        <trans-unit id="e8532e48c96c60a7608facfeb4a22eb5b3d9e1d6" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#Condition&quot;&gt;&lt;i&gt;Condition&lt;/i&gt;&lt;/a&gt; is satisfied, then the following</source>
          <target state="translated">場合は&lt;a href=&quot;#Condition&quot;&gt;&lt;i&gt;、条件が&lt;/i&gt;&lt;/a&gt;満たされ、その後、次のよう</target>
        </trans-unit>
        <trans-unit id="e2fc51761f652cbfa928ace68e58f12bef9531f7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#Config.newEnv&quot;&gt;&lt;code&gt;Config.newEnv&lt;/code&gt;&lt;/a&gt; flag is set in &lt;code&gt;config&lt;/code&gt;, the child process will</source>
          <target state="translated">場合&lt;a href=&quot;#Config.newEnv&quot;&gt; &lt;code&gt;Config.newEnv&lt;/code&gt; の&lt;/a&gt;フラグがセットされた &lt;code&gt;config&lt;/code&gt; 、子プロセスは意志</target>
        </trans-unit>
        <trans-unit id="43745bb1dee3dc73e7455be8ec08aff260e3ec47" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#TemplateArgument&quot;&gt;&lt;i&gt;TemplateArgument&lt;/i&gt;&lt;/a&gt; is one token long, the parentheses can be omitted:</source>
          <target state="translated">場合&lt;a href=&quot;#TemplateArgument&quot;&gt;&lt;i&gt;TemplateArgumentが&lt;/i&gt;&lt;/a&gt; 1つのトークンの長さで、括弧を省略することができます。</target>
        </trans-unit>
        <trans-unit id="2d0280ee3bb99762171b658bd8c55f327440c8eb" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;class#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt; is empty, the struct instance is default initialized.</source>
          <target state="translated">場合&lt;a href=&quot;class#ParameterList&quot;&gt;&lt;i&gt;のParameterListが&lt;/i&gt;&lt;/a&gt;空である、構造体のインスタンスは、デフォルトの初期化です。</target>
        </trans-unit>
        <trans-unit id="91aa0bb3a56c8d252e49de956e4900b6178db3ed" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;function#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt; is empty, the struct instance is default initialized.</source>
          <target state="translated">場合&lt;a href=&quot;function#ParameterList&quot;&gt;&lt;i&gt;のParameterListが&lt;/i&gt;&lt;/a&gt;空である、構造体のインスタンスは、デフォルトの初期化です。</target>
        </trans-unit>
        <trans-unit id="2d70e00070ad7d208c2b59d3486718a575bd6f03" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;BitmappedBlock&lt;/code&gt; object is empty (has no active allocation), allocates all memory within and returns a slice to it. Otherwise, returns &lt;code&gt;null&lt;/code&gt; (i.e. no attempt is made to allocate the largest available block).</source>
          <target state="translated">&lt;code&gt;BitmappedBlock&lt;/code&gt; オブジェクトが空の場合（アクティブな割り当てがない場合）、すべてのメモリを割り当て、そこにスライスを返します。それ以外の場合は、 &lt;code&gt;null&lt;/code&gt; を返します（つまり、利用可能な最大のブロックを割り当てる試みは行われません）。</target>
        </trans-unit>
        <trans-unit id="f5b1d7f6d0725050ed31d8d5e2a2f42a77b9308e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;FileLogger&lt;/code&gt; is managing the &lt;code&gt;File&lt;/code&gt; it logs to, this method will return a reference to this File.</source>
          <target state="translated">&lt;code&gt;FileLogger&lt;/code&gt; がログを記録する &lt;code&gt;File&lt;/code&gt; 管理している場合、このメソッドはこのファイルへの参照を返します。</target>
        </trans-unit>
        <trans-unit id="e82d2c358fbac5f6db431228cfdc4ab90afaecba" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;FileLogger&lt;/code&gt; was constructed with a filename, this method returns this filename. Otherwise an empty &lt;code&gt;string&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;FileLogger&lt;/code&gt; がファイル名で作成された場合、このメソッドはこのファイル名を返します。それ以外の場合は、空の &lt;code&gt;string&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="09e9a0c0fb2463234ac2c4886cea6f7201a979f8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; object is empty (has no active allocation), allocates all memory within and returns a slice to it. Otherwise, returns &lt;code&gt;null&lt;/code&gt; (i.e. no attempt is made to allocate the largest available block).</source>
          <target state="translated">&lt;code&gt;SharedBitmappedBlock&lt;/code&gt; オブジェクトが空の場合（アクティブな割り当てがない場合）は、内部のすべてのメモリを割り当て、それにスライスを返します。それ以外の場合は、 &lt;code&gt;null&lt;/code&gt; を返します（つまり、利用可能な最大のブロックを割り当てる試みは行われません）。</target>
        </trans-unit>
        <trans-unit id="a85af50c42d4408aee171ffd99bd37d80c84bfad" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Task&lt;/code&gt; isn't started yet, execute it in the current thread. If it's done, return its return value, if any. If it's in progress, busy spin until it's done, then return the return value. If it threw an exception, rethrow that exception.</source>
          <target state="translated">&lt;code&gt;Task&lt;/code&gt; がまだ開始されていない場合は、現在のスレッドで実行してください。完了したら、戻り値があればそれを返します。進行中の場合は、完了するまでビジースピンしてから、戻り値を返します。例外をスローした場合は、その例外を再スローします。</target>
        </trans-unit>
        <trans-unit id="1bd6a82f193fead01ba830becd3c29303a62f4f9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Task&lt;/code&gt; isn't started yet, execute it in the current thread. If it's done, return its return value, if any. If it's in progress, wait on a condition variable. If it threw an exception, rethrow that exception.</source>
          <target state="translated">&lt;code&gt;Task&lt;/code&gt; がまだ開始されていない場合は、現在のスレッドで実行してください。完了したら、戻り値があればそれを返します。進行中の場合は、条件変数を待ちます。例外をスローした場合は、その例外を再スローします。</target>
        </trans-unit>
        <trans-unit id="9e212700918e7fcce26dacfc8ea0fc78cc9f1eec" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;VariantN&lt;/code&gt; contains an (associative) array, returns the length of that array. Otherwise, throws an exception.</source>
          <target state="translated">&lt;code&gt;VariantN&lt;/code&gt; に（連想）配列が含まれている場合、その配列の長さを返します。それ以外の場合は、例外をスローします。</target>
        </trans-unit>
        <trans-unit id="aaf923f5ee1964878af77ace59cc74c4aeed3ea4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;VariantN&lt;/code&gt; contains an array, applies &lt;code&gt;dg&lt;/code&gt; to each element of the array in turn. Otherwise, throws an exception.</source>
          <target state="translated">&lt;code&gt;VariantN&lt;/code&gt; に配列が含まれる場合、 &lt;code&gt;dg&lt;/code&gt; を配列の各要素に順番に適用します。それ以外の場合は、例外をスローします。</target>
        </trans-unit>
        <trans-unit id="8cc269de3091c4d2c19acd44245d56ff558f7c59" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;VariantN&lt;/code&gt; object holds a value of the</source>
          <target state="translated">場合 &lt;code&gt;VariantN&lt;/code&gt; のオブジェクトは、の値を保持しています</target>
        </trans-unit>
        <trans-unit id="4b1509a50bbf3491d84d8a56c0c8990227dbda5d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;[ ]&lt;/code&gt; form is used, the slice is of the entire array.</source>
          <target state="translated">場合は &lt;code&gt;[ ]&lt;/code&gt; 形式が使用され、スライスは、全体の配列です。</target>
        </trans-unit>
        <trans-unit id="5bc0d1d6fc33510ec1a8451afec85b978d105f76" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;format&lt;/code&gt; argument is a string literal, it is verified to be a valid format string per the C99 Standard. If the &lt;code&gt;format&lt;/code&gt; parameter is followed by &lt;code&gt;...&lt;/code&gt;, the number and types of the variadic arguments are checked against the format string.</source>
          <target state="translated">場合は &lt;code&gt;format&lt;/code&gt; 引数は文字列リテラルである、C99標準あたりの有効な形式の文字列であることが確認されました。 &lt;code&gt;format&lt;/code&gt; パラメータの後に &lt;code&gt;...&lt;/code&gt; が続く場合、可変個引数の数とタイプがフォーマット文字列と照合されます。</target>
        </trans-unit>
        <trans-unit id="cc574f8cb39cc53c71da6e74a5ec0da4813bcc04" translate="yes" xml:space="preserve">
          <source>If the CURLOPT_INFILE is used, this can be used to inform libcurl about how large the file being sent really is. That allows better error checking and better verifies that the upload was successful. -1 means unknown size.</source>
          <target state="translated">CURLOPT_INFILE が使用されている場合、これは送信されるファイルが実際にどのくらいの大きさなのかを libcurl に通知するために使用することができます。これにより、より良いエラーチェックが可能になり、アップロードが成功したことをより良く確認することができます。-1 は不明なサイズを意味します。</target>
        </trans-unit>
        <trans-unit id="05e890b0ac7f150cc9383bbef3319acbe1eb47b0" translate="yes" xml:space="preserve">
          <source>If the UDA is a type, then any UDAs of the same type on the symbol will match. If the UDA is a template for a type, then any UDA which is an instantiation of that template will match. And if the UDA is a value, then any UDAs on the symbol which are equal to that value will match.</source>
          <target state="translated">UDA が型である場合、シンボル上の同じ型の UDA はすべて一致します。UDA が型のテンプレートである場合、そのテンプレートのインスタンスである UDA はすべて一致します。また、UDAが値であれば、その値に等しいシンボル上のUDAはすべて一致します。</target>
        </trans-unit>
        <trans-unit id="d6829c7076e9b081aaeb04fb4efe46caee211bea" translate="yes" xml:space="preserve">
          <source>If the [EBP] is omitted, it is assumed for local variables. If &lt;code&gt;naked&lt;/code&gt; is used, this no longer holds.</source>
          <target state="translated">[EBP]を省略すると、ローカル変数と見なされます。場合は &lt;code&gt;naked&lt;/code&gt; 使用され、これはもはや保持していません。</target>
        </trans-unit>
        <trans-unit id="1517a4666732a9b97017b3d1661df1ab091b7335" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a sequence, there can be one or two iteration symbols declared. If one, then the symbol is an</source>
          <target state="translated">集約式がシーケンスである場合、宣言された反復記号は1つまたは2つであることができます。1つであれば、そのシンボルは</target>
        </trans-unit>
        <trans-unit id="d74660278291ee85d1999a22558014f3ea28fb7a" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a static or dynamic array of &lt;code&gt;char&lt;/code&gt;s, &lt;code&gt;wchar&lt;/code&gt;s, or &lt;code&gt;dchar&lt;/code&gt;s, then the</source>
          <target state="translated">集約式が &lt;code&gt;char&lt;/code&gt; 、 &lt;code&gt;wchar&lt;/code&gt; 、または &lt;code&gt;dchar&lt;/code&gt; の静的または動的配列である場合、</target>
        </trans-unit>
        <trans-unit id="cbeacb125fa68a379271d564591b63d8e90e22ef" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a struct or class object, but the &lt;code&gt;opApply&lt;/code&gt; for &lt;code&gt;foreach&lt;/code&gt;, or &lt;code&gt;opApplyReverse&lt;/code&gt;&lt;code&gt;foreach_reverse&lt;/code&gt; do not exist, then iteration over struct and class objects can be done with range primitives. For &lt;code&gt;foreach&lt;/code&gt;, this means the following properties and methods must be defined:</source>
          <target state="translated">集約式が構造体またはクラスオブジェクトであるが、 &lt;code&gt;opApply&lt;/code&gt; for &lt;code&gt;foreach&lt;/code&gt; または &lt;code&gt;opApplyReverse&lt;/code&gt; &lt;code&gt;foreach_reverse&lt;/code&gt; が存在しない場合、構造体およびクラスオブジェクトの反復は範囲プリミティブで実行できます。以下のため &lt;code&gt;foreach&lt;/code&gt; 、これは次のプロパティとメソッドを定義する必要がありますを意味します。</target>
        </trans-unit>
        <trans-unit id="2fc73ce3aaae537f6f799c049d4ae92b1b9bca9f" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a struct or class object, the &lt;code&gt;foreach&lt;/code&gt; is defined by the special &lt;span id=&quot;opApply&quot;&gt;&lt;code&gt;opApply&lt;/code&gt;&lt;/span&gt; member function, and the &lt;code&gt;foreach_reverse&lt;/code&gt; behavior is defined by the special &lt;span id=&quot;opApplyReverse&quot;&gt;&lt;code&gt;opApplyReverse&lt;/code&gt;&lt;/span&gt; member function. These functions have the type:</source>
          <target state="translated">集計式が構造体またはクラスオブジェクトの場合、 &lt;code&gt;foreach&lt;/code&gt; は特別な&lt;span id=&quot;opApply&quot;&gt; &lt;code&gt;opApply&lt;/code&gt; &lt;/span&gt;メンバー関数によって定義され、 &lt;code&gt;foreach_reverse&lt;/code&gt; の動作は特別な&lt;span id=&quot;opApplyReverse&quot;&gt; &lt;code&gt;opApplyReverse&lt;/code&gt; &lt;/span&gt;メンバー関数によって定義されます。これらの関数には次のタイプがあります。</target>
        </trans-unit>
        <trans-unit id="a964bd4ba66b1238ba3df838bc73bf80b6db0380" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is an associative array, there can be one or two variables declared. If one, then the variable is said to be the</source>
          <target state="translated">集約式が連想配列である場合、変数は1つまたは2つ宣言することができます。一つであれば、その変数は</target>
        </trans-unit>
        <trans-unit id="28f986b7b478a6b80712dcbe7082b7d096f58800" translate="yes" xml:space="preserve">
          <source>If the aggregate is a static or dynamic array, there can be one or two variables declared. If one, then the variable is said to be the</source>
          <target state="translated">集約体が静的配列または動的配列である場合、1つまたは2つの変数を宣言することができます。1つであれば、その変数は</target>
        </trans-unit>
        <trans-unit id="dae323352e29801474e63b5dca9b04c0df39a8b3" translate="yes" xml:space="preserve">
          <source>If the argument is a CommaExp, set a flag to prevent deprecation messages</source>
          <target state="translated">引数がCommaExpの場合、非推奨メッセージを防ぐためのフラグを設定します。</target>
        </trans-unit>
        <trans-unit id="fd923c5e6b5ba5db493474258e601c811cb53b07" translate="yes" xml:space="preserve">
          <source>If the argument is omitted, it means default construction of the scalar type:</source>
          <target state="translated">引数を省略した場合は、スカラ型のデフォルト構築を意味します。</target>
        </trans-unit>
        <trans-unit id="c2b4ef88a634d75ab4162e14992b099e340c974e" translate="yes" xml:space="preserve">
          <source>If the arguments are all either types that are abstract classes, or expressions that are typed as abstract classes, then &lt;code&gt;true&lt;/code&gt; is returned. Otherwise, &lt;code&gt;false&lt;/code&gt; is returned. If there are no arguments, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">引数がすべて抽象クラスの型か、抽象クラスとして型指定された式の場合、 &lt;code&gt;true&lt;/code&gt; が返されます。それ以外の場合は、 &lt;code&gt;false&lt;/code&gt; が返されます。引数がない場合、 &lt;code&gt;false&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="870a7ff26a7a40d5a235f7261d71e7076bce3fa8" translate="yes" xml:space="preserve">
          <source>If the arguments are all either types that are arithmetic types, or expressions that are typed as arithmetic types, then &lt;code&gt;true&lt;/code&gt; is returned. Otherwise, &lt;code&gt;false&lt;/code&gt; is returned. If there are no arguments, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">引数がすべて算術型の型、または算術型として型指定された式の場合、 &lt;code&gt;true&lt;/code&gt; が返されます。それ以外の場合は、 &lt;code&gt;false&lt;/code&gt; が返されます。引数がない場合、 &lt;code&gt;false&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="c1199d0a51996844d05cb8716b18ac074abdf063" translate="yes" xml:space="preserve">
          <source>If the assigned value type is &lt;b&gt;not&lt;/b&gt; equivalent with the AA element type, the expression could invoke operator overloading with normal indexing access:</source>
          <target state="translated">割り当てられた値の型がAA要素の型と同等で&lt;b&gt;ない&lt;/b&gt;場合、式は通常のインデックスアクセスで演算子のオーバーロードを呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="a4c8c8da96483d4e6d105c51e4ab4887f9f8b55b" translate="yes" xml:space="preserve">
          <source>If the assigned value type is equivalent with the AA element type:</source>
          <target state="translated">割り当てられた値の型がAA要素の型と同等である場合。</target>
        </trans-unit>
        <trans-unit id="39dbd0d9fed3f956fc2681e5931d3927843d2a46" translate="yes" xml:space="preserve">
          <source>If the bounds check in &lt;code&gt;@system&lt;/code&gt; or &lt;code&gt;@trusted&lt;/code&gt; code is disabled, the code correctness must still be guaranteed by the code author.</source>
          <target state="translated">&lt;code&gt;@system&lt;/code&gt; または &lt;code&gt;@trusted&lt;/code&gt; コードで境界チェックが無効になっている場合でも、コードの正確さはコード作成者によって保証されている必要があります。</target>
        </trans-unit>
        <trans-unit id="cc1e679f124dc90842ff4979e66ede34a74890c6" translate="yes" xml:space="preserve">
          <source>If the callback doesn't take any arguments, the callback is invoked whenever the option is seen.</source>
          <target state="translated">コールバックが引数を取らない場合は、オプションを見るたびにコールバックが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="3289fcddad88ae1df9d116fd88b6c6dc79afe870" translate="yes" xml:space="preserve">
          <source>If the callback takes one string argument, the option string (without the leading dash(es)) is passed to the callback. After that, the option string is considered handled and removed from the options array.</source>
          <target state="translated">コールバックが文字列の引数を 1 つ取った場合は、オプション文字列 (先頭のダッシュを除いたもの)がコールバックに渡されます。その後、オプション文字列は処理されたものとみなされ、オプション配列から削除されます。</target>
        </trans-unit>
        <trans-unit id="dad4f3623ab08f61a1b3d8228c7e7a46ecb84bd7" translate="yes" xml:space="preserve">
          <source>If the callback takes two string arguments, the option string is handled as an option with one argument, and parsed accordingly. The option and its value are passed to the callback. After that, whatever was passed to the callback is considered handled and removed from the list.</source>
          <target state="translated">コールバックが2つの文字列引数を取る場合、オプションの文字列は1つの引数を持つオプションとして扱われ、それに応じて解析されます。オプションとその値はコールバックに渡されます。その後、コールバックに渡されたものはすべて処理されたものとみなされ、リストから削除されます。</target>
        </trans-unit>
        <trans-unit id="8d6fa53ba31aeabc61edb3bbeab4d2e35828294c" translate="yes" xml:space="preserve">
          <source>If the caller is a Fiber and is not a Generator, this function will call scheduler.yield() or Fiber.yield(), as appropriate.</source>
          <target state="translated">呼び出し元がFiberであり、Generatorではない場合、この関数は適切にscheduler.yield()またはFiber.yield()を呼び出します。</target>
        </trans-unit>
        <trans-unit id="7fba3a81af609825439d1523a354f0ef5c6b4ecb" translate="yes" xml:space="preserve">
          <source>If the caller is a scheduled Fiber, this yields execution to another scheduled Fiber.</source>
          <target state="translated">呼び出し元がスケジュールされたファイバーである場合、これは別のスケジュールされたファイバーへの実行をもたらします。</target>
        </trans-unit>
        <trans-unit id="682966fbc9a5573324e201e13b7ba309d84a4edb" translate="yes" xml:space="preserve">
          <source>If the capacity is increased, one should assume that all iterators to the elements are invalidated.</source>
          <target state="translated">容量が増加した場合、要素へのイテレータはすべて無効になると仮定すべきである。</target>
        </trans-unit>
        <trans-unit id="881b45b7bdf985b220e8cd0369c0c1827fe806d8" translate="yes" xml:space="preserve">
          <source>If the chunk of memory managed is large, it may be desirable to switch management to free list from the beginning. That way, memory may be used in a more compact manner than region mode. To force free list mode, call &lt;code&gt;switchToFreeList&lt;/code&gt; shortly after construction or when deemed appropriate.</source>
          <target state="translated">管理されるメモリのチャンクが大きい場合、最初から管理を空きリストに切り替えることが望ましい場合があります。このように、メモリは領域モードよりコンパクトな方法で使用できます。フリーリストモードを強制するには、構築直後または適切と見なされたときに &lt;code&gt;switchToFreeList&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="9ac8dd371ddada3a7fc0d5f27220ac56194a508b" translate="yes" xml:space="preserve">
          <source>If the connection proceeds too quickly then need to slow it down</source>
          <target state="translated">接続の進行が早すぎる場合は、それを遅くする必要があります。</target>
        </trans-unit>
        <trans-unit id="a0e6b5ba02714528b40c08b339b490154681d034" translate="yes" xml:space="preserve">
          <source>If the constructor can create a unique object (e.g. if it is &lt;code&gt;pure&lt;/code&gt;), the object can be implicitly convertible to any qualifiers.</source>
          <target state="translated">コンストラクターが一意のオブジェクトを作成できる場合（ &lt;code&gt;pure&lt;/code&gt; 場合など）、オブジェクトは暗黙的に任意の修飾子に変換できます。</target>
        </trans-unit>
        <trans-unit id="cf0cf6c28f3156b6b4f9788d5978b63c0c05e84c" translate="yes" xml:space="preserve">
          <source>If the constructor can create a unique object (i.e. if it is &lt;code&gt;pure&lt;/code&gt;), the object is implicitly convertible to any qualifiers.</source>
          <target state="translated">コンストラクターが一意のオブジェクトを作成できる場合（つまり、オブジェクトが &lt;code&gt;pure&lt;/code&gt; の場合）、オブジェクトは暗黙的に任意の修飾子に変換できます。</target>
        </trans-unit>
        <trans-unit id="52c26c14a7e4c3281fb4736e2032dbcd78185dac" translate="yes" xml:space="preserve">
          <source>If the current count is equal to zero, return. Otherwise, atomically decrement the count by one and return true.</source>
          <target state="translated">現在のカウントがゼロの場合は、リターンします。そうでなければ、アトミックにカウントを1ずつデクリメントしてtrueを返します。</target>
        </trans-unit>
        <trans-unit id="50c1fec6baa7c97f9c101593b09fc41307d590d7" translate="yes" xml:space="preserve">
          <source>If the declaration is disabled but inside a disabled function, returns &lt;code&gt;true&lt;/code&gt; but do not issue an error message.</source>
          <target state="translated">宣言が無効になっているが無効な関数内にある場合、 &lt;code&gt;true&lt;/code&gt; を返しますが、エラーメッセージは発行しません。</target>
        </trans-unit>
        <trans-unit id="553971eeba92d7bd581f90194d8554493054062d" translate="yes" xml:space="preserve">
          <source>If the default value for a parameter is given, all following parameters must also have default values.</source>
          <target state="translated">パラメータにデフォルト値が与えられている場合、それに続くすべてのパラメータにもデフォルト値が与えられている必要があります。</target>
        </trans-unit>
        <trans-unit id="aefb0c84385cb6665755448be70c3bf176cad1d9" translate="yes" xml:space="preserve">
          <source>If the delimiter is an identifier, the identifier must be immediately followed by a newline, and the matching delimiter is the same identifier starting at the beginning of the line:</source>
          <target state="translated">区切り文字が識別子の場合は、識別子の直後に改行を入れなければならず、一致する区切り文字は行頭から始まる同じ識別子となります。</target>
        </trans-unit>
        <trans-unit id="76a3cf7d70aa80e5130f9aadda4aeef632729f66" translate="yes" xml:space="preserve">
          <source>If the delimiter is an identifier, the identifier must be immediately followed by a newline, and the matching delimiter must be the same identifier starting at the beginning of the line:</source>
          <target state="translated">区切り文字が識別子の場合は、識別子の直後に改行を入れ、一致する区切り文字は行頭から始まる同じ識別子でなければなりません。</target>
        </trans-unit>
        <trans-unit id="367e2c9e3e9e32edd1905a00926130379051ac02" translate="yes" xml:space="preserve">
          <source>If the documentation of a member function of a container takes a parameter of type &lt;code&gt;Range&lt;/code&gt;, then it refers to the primary range type of this container. Oftentimes &lt;code&gt;Take!Range&lt;/code&gt; will be used, in which case the range refers to a span of the elements in the container. Arguments to these parameters &lt;b&gt;must&lt;/b&gt; be obtained from the same container instance as the one being worked with. It is important to note that many generic range algorithms return the same range type as their input range.</source>
          <target state="translated">コンテナーのメンバー関数のドキュメンテーションが &lt;code&gt;Range&lt;/code&gt; 型のパラメーターを取る場合、それはこのコンテナーの主要な範囲型を参照します。多くの場合、 &lt;code&gt;Take!Range&lt;/code&gt; が使用されます。この場合、範囲はコンテナ内の要素のスパンを参照します。これらのパラメーターの引数&lt;b&gt;は、&lt;/b&gt;インスタンスと同じコンテナーインスタンスから取得がます。多くの一般的な範囲アルゴリズムは、入力範囲と同じ範囲タイプを返すことに注意することが重要です。</target>
        </trans-unit>
        <trans-unit id="568a7fe362541b12ed21809dd85fad3122bbc2f4" translate="yes" xml:space="preserve">
          <source>If the download receives less than &quot;low speed limit&quot; bytes/second during &quot;low speed time&quot; seconds, the operations is aborted. You could i.e if you have a pretty high speed connection, abort if it is less than 2000 bytes/sec during 20 seconds.</source>
          <target state="translated">ダウンロードが &quot;低速時間 &quot;秒の間に &quot;低速制限 &quot;バイト/秒未満を受信した場合、操作は中断されます。あなたがかなりの高速接続を持っている場合は、すなわち、それが20秒の間に2000バイト/秒未満である場合は中止することができます。</target>
        </trans-unit>
        <trans-unit id="3a1f560a07b490771cc9fc4811b46461cd585b36" translate="yes" xml:space="preserve">
          <source>If the email address is valid or not.</source>
          <target state="translated">メールアドレスが有効かどうか</target>
        </trans-unit>
        <trans-unit id="4f3a54e2dd01849ed176b274b08fe7067255fdd1" translate="yes" xml:space="preserve">
          <source>If the enum</source>
          <target state="translated">もし、列挙された</target>
        </trans-unit>
        <trans-unit id="c1aaeeb72f410c4e6aff61a784ecba88ce60daf3" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to false the functions are never inlined, otherwise they are always inlined.</source>
          <target state="translated">式の評価が false の場合、関数はインライン化されず、そうでない場合は常にインライン化されます。</target>
        </trans-unit>
        <trans-unit id="657b7adb8cca95e26ff1d78ccaa8357b99612950" translate="yes" xml:space="preserve">
          <source>If the expression is a &lt;a href=&quot;function#property-functions&quot;&gt; Property Function&lt;/a&gt;, &lt;code&gt;typeof&lt;/code&gt; gives its return type.</source>
          <target state="translated">式が&lt;a href=&quot;function#property-functions&quot;&gt;プロパティ関数の&lt;/a&gt;場合、 &lt;code&gt;typeof&lt;/code&gt; は戻り値の型を示します。</target>
        </trans-unit>
        <trans-unit id="bbff4334fd247c00a1664b1a8294a75098385c7e" translate="yes" xml:space="preserve">
          <source>If the extended unittest handler is registered, this function returns the result from that handler directly.</source>
          <target state="translated">拡張ユニテストハンドラが登録されている場合、そのハンドラの結果を直接返します。</target>
        </trans-unit>
        <trans-unit id="638ef19a4eda5122a3e4b7247816dfcd0c978607" translate="yes" xml:space="preserve">
          <source>If the extension is empty, this function is equivalent to &lt;a href=&quot;#stripExtension&quot;&gt;&lt;code&gt;stripExtension&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">拡張子が空の場合、この関数は&lt;a href=&quot;#stripExtension&quot;&gt; &lt;code&gt;stripExtension&lt;/code&gt; &lt;/a&gt;と同等です。。</target>
        </trans-unit>
        <trans-unit id="7ef335ccbfb3536483e3c42f2775a824af19d172" translate="yes" xml:space="preserve">
          <source>If the field is initialized on one path, it must be initialized on all paths.</source>
          <target state="translated">フィールドが1つのパスで初期化されている場合は、すべてのパスで初期化する必要があります。</target>
        </trans-unit>
        <trans-unit id="837d5b133d0941d97e1586686594739710856b45" translate="yes" xml:space="preserve">
          <source>If the field type has an &lt;a href=&quot;operatoroverloading#assignment&quot;&gt;&lt;code&gt;opAssign&lt;/code&gt;&lt;/a&gt; method, it will not be used for initialization.</source>
          <target state="translated">フィールドタイプに&lt;a href=&quot;operatoroverloading#assignment&quot;&gt; &lt;code&gt;opAssign&lt;/code&gt; &lt;/a&gt;がある場合メソッド初期化には使用されません。</target>
        </trans-unit>
        <trans-unit id="ced70cd3f9cbddd52606f9834678b1724238171b" translate="yes" xml:space="preserve">
          <source>If the field type is not mutable, multiple initialization will be rejected.</source>
          <target state="translated">フィールド型が mutable でない場合、複数回の初期化は拒否されます。</target>
        </trans-unit>
        <trans-unit id="03c48cf052ea3dedbdf6ccc3c7e899b230bc6471" translate="yes" xml:space="preserve">
          <source>If the file is not opened, returns &lt;code&gt;true&lt;/code&gt;. Otherwise, returns &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/ferror.html&quot;&gt;ferror&lt;/a&gt; for the file handle.</source>
          <target state="translated">ファイルが開かれていない場合は、 &lt;code&gt;true&lt;/code&gt; を返します。それ以外の場合は、ファイルハンドルの&lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/ferror.html&quot;&gt;ferror&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="8450d7a55bd53dbebae5b57df534f9be1005db67" translate="yes" xml:space="preserve">
          <source>If the file is not opened, succeeds vacuously. Otherwise, returns &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/clearerr.html&quot;&gt;clearerr&lt;/a&gt; for the file handle.</source>
          <target state="translated">ファイルが開かれていない場合は、そのまま成功します。それ以外の場合は、ファイルハンドルの&lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/clearerr.html&quot;&gt;clearerr&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="094342c021e1489a63abd256ccc39489b9dd3b66" translate="yes" xml:space="preserve">
          <source>If the file name of a module is an invalid module name (e.g. &lt;code&gt;foo-bar.d&lt;/code&gt;), you may use a module declaration to set a valid module name:</source>
          <target state="translated">モジュールのファイル名が無効なモジュール名である場合（例： &lt;code&gt;foo-bar.d&lt;/code&gt; ）の場合、モジュール宣言を使用して有効なモジュール名を設定できます。</target>
        </trans-unit>
        <trans-unit id="af6d8edab76ddfaae7837345a33fd73f250c8a9f" translate="yes" xml:space="preserve">
          <source>If the file was unopened, succeeds vacuously. Otherwise closes the file (by calling &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fclose.html&quot;&gt;fclose&lt;/a&gt;), throwing on error. Even if an exception is thrown, afterwards the &lt;code&gt;File&lt;/code&gt; object is empty. This is different from &lt;code&gt;detach&lt;/code&gt; in that it always closes the file; consequently, all other &lt;code&gt;File&lt;/code&gt; objects referring to the same handle will see a closed file henceforth.</source>
          <target state="translated">ファイルが開かれていない場合は、空っぽに成功します。それ以外の場合は、（&lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fclose.html&quot;&gt;fclose&lt;/a&gt;を呼び出して）ファイルを閉じ、エラーをスローします。例外がスローされても、その後 &lt;code&gt;File&lt;/code&gt; オブジェクトは空になります。これは、常にファイルを閉じるという点で &lt;code&gt;detach&lt;/code&gt; とは異なります。したがって、他のすべての &lt;code&gt;File&lt;/code&gt; 同じハンドルを参照するオブジェクトは、閉じられたファイルを今後参照します。</target>
        </trans-unit>
        <trans-unit id="527ef94b697e67dac9fb104fb0ef24982a4b2044" translate="yes" xml:space="preserve">
          <source>If the filename already has an extension, it is replaced. If not, the extension is simply appended to the filename. Including a leading dot in &lt;code&gt;ext&lt;/code&gt; is optional.</source>
          <target state="translated">ファイル名にすでに拡張子が付いている場合は、置き換えられます。そうでない場合、拡張子はファイル名に単に追加されます。 &lt;code&gt;ext&lt;/code&gt; に先行ドットを含めることはオプションです。</target>
        </trans-unit>
        <trans-unit id="9ba4ff05c5a39476e966f563ceda94938de67867" translate="yes" xml:space="preserve">
          <source>If the first</source>
          <target state="translated">もし、最初の</target>
        </trans-unit>
        <trans-unit id="fdc87c8a8b7093e7a7ff0e6b20593048b93bffda" translate="yes" xml:space="preserve">
          <source>If the first line starts with &quot;#!&quot;, then that line is ignored.</source>
          <target state="translated">最初の行が &quot;#!&quot;で始まる場合は、その行は無視されます。</target>
        </trans-unit>
        <trans-unit id="0759e4efe42fd76d83650d76ffb9cbdc81cfccae" translate="yes" xml:space="preserve">
          <source>If the first lookup isn't successful, a second one is performed on imports. In the second lookup phase inherited scopes are ignored. This includes the scope of base classes and interfaces (in this example, &lt;code&gt;BaseClass&lt;/code&gt;'s imports would be ignored), as well as imports in mixed-in &lt;code&gt;template&lt;/code&gt;.</source>
          <target state="translated">最初のルックアップが成功しなかった場合、インポートに対して2番目のルックアップが実行されます。2番目のルックアップフェーズでは、継承されたスコープは無視されます。これには、基本クラスとインターフェイスのスコープ（この例では、 &lt;code&gt;BaseClass&lt;/code&gt; のインポートは無視されます）、および混合 &lt;code&gt;template&lt;/code&gt; インポートが含まれます。</target>
        </trans-unit>
        <trans-unit id="f743b99432834f349face5005529142050d8a895" translate="yes" xml:space="preserve">
          <source>If the first lookup wasn't successful, a second one is performed on imports. In the second lookup phase inherited scopes are ignored. This includes scope of base classes and interface (in this example, &lt;code&gt;BaseClass&lt;/code&gt;'s imports would be ignored), as well as imports in mixed-in &lt;code&gt;template&lt;/code&gt;.</source>
          <target state="translated">最初の検索が成功しなかった場合、インポートで2番目の検索が実行されます。 2番目のルックアップフェーズでは、継承されたスコープは無視されます。これには、基本クラスとインターフェースのスコープ（この例では、 &lt;code&gt;BaseClass&lt;/code&gt; のインポートは無視されます）、および混合 &lt;code&gt;template&lt;/code&gt; インポートが含まれます。</target>
        </trans-unit>
        <trans-unit id="4653edc731431a9f55f3a9c2f7b1ee0500507aaf" translate="yes" xml:space="preserve">
          <source>If the floating-point rounding mode is changed within a function, it must be restored before the function exits. If this rule is violated (for example, by the use of inline asm), the rounding mode used for subsequent calculations is undefined.</source>
          <target state="translated">関数内で浮動小数点丸めモードが変更された場合、関数が終了する前に元に戻す必要があります。この規則に違反した場合(例えば、インラインasmの使用など)、その後の計算に使用される丸めモードは未定義となります。</target>
        </trans-unit>
        <trans-unit id="06665db726ed2b3db8e693b6a8e9e8220aa3c936" translate="yes" xml:space="preserve">
          <source>If the format string is fixed, passing it as a template parameter checks the type correctness of the parameters at compile-time. This also can result in better performance.</source>
          <target state="translated">フォーマット文字列が固定されている場合、テンプレートパラメータとして渡すことで、コンパイル時にパラメータの型の正しさがチェックされます。これはパフォーマンスを向上させることにもつながります。</target>
        </trans-unit>
        <trans-unit id="f41ef8f8cc465c8df198d14584ea0805a3861563" translate="yes" xml:space="preserve">
          <source>If the fractional part of x is exactly 0.5, the return value is rounded away from zero.</source>
          <target state="translated">xの端数部分がちょうど0.5の場合、戻り値は0から四捨五入されます。</target>
        </trans-unit>
        <trans-unit id="6a44050dca10920a151c58d6983c48f0ef88a105" translate="yes" xml:space="preserve">
          <source>If the function is passed in string form, the state has name &lt;code&gt;&quot;a&quot;&lt;/code&gt; and the zero-based index in the recurrence has name &lt;code&gt;&quot;n&quot;&lt;/code&gt;. The given string must return the desired value for &lt;code&gt;a[n]&lt;/code&gt; given &lt;code&gt;a[n - 1]&lt;/code&gt;, &lt;code&gt;a[n - 2]&lt;/code&gt;, &lt;code&gt;a[n - 3]&lt;/code&gt;,..., &lt;code&gt;a[n - stateSize]&lt;/code&gt;. The state size is dictated by the number of arguments passed to the call to &lt;code&gt;recurrence&lt;/code&gt;. The &lt;code&gt;Recurrence&lt;/code&gt; struct itself takes care of managing the recurrence's state and shifting it appropriately.</source>
          <target state="translated">関数が文字列形式で渡される場合、状態の名前は &lt;code&gt;&quot;a&quot;&lt;/code&gt; で、繰り返しの0から始まるインデックスの名前は &lt;code&gt;&quot;n&quot;&lt;/code&gt; です。指定された文字列は &lt;code&gt;a[n - 1]&lt;/code&gt; 、 &lt;code&gt;a[n - 2]&lt;/code&gt; 、 &lt;code&gt;a[n - 3]&lt;/code&gt; 、...、 &lt;code&gt;a[n - stateSize]&lt;/code&gt; 指定され &lt;code&gt;a[n]&lt;/code&gt; 必要な値を返す必要があります。状態サイズは、 &lt;code&gt;recurrence&lt;/code&gt; の呼び出しに渡される引数の数によって決まります。 &lt;code&gt;Recurrence&lt;/code&gt; 再発の状態を管理し、適切にシフトするの世話をする自分自身をストラクト。</target>
        </trans-unit>
        <trans-unit id="3c67c2406f3c735811702f591ea611c2970cdc93" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;void&lt;/code&gt;, and the first parameter is &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;out&lt;/code&gt;, then all subsequent &lt;code&gt;return ref&lt;/code&gt; parameters are considered as being assigned to the first parameter for lifetime checking. The &lt;code&gt;this&lt;/code&gt; reference parameter to a struct non-static member function is considered the first parameter.</source>
          <target state="translated">関数が &lt;code&gt;void&lt;/code&gt; を返し、最初のパラメーターが &lt;code&gt;ref&lt;/code&gt; または &lt;code&gt;out&lt;/code&gt; の場合、後続のすべての &lt;code&gt;return ref&lt;/code&gt; パラメーターは、存続期間チェックのために最初のパラメーターに割り当てられていると見なされます。struct非静的メンバー関数への &lt;code&gt;this&lt;/code&gt; 参照パラメーターは、最初のパラメーターと見なされます。</target>
        </trans-unit>
        <trans-unit id="e2f91af04048a7f2df150e8629c6506bcf13c494" translate="yes" xml:space="preserve">
          <source>If the generated copy constructor fails to type check, it will receive the &lt;code&gt;@disable&lt;/code&gt; attribute.</source>
          <target state="translated">生成されたコピーコンストラクターが型チェックに失敗した場合、 &lt;code&gt;@disable&lt;/code&gt; 属性を受け取ります。</target>
        </trans-unit>
        <trans-unit id="8b1f1e5a2ec324dd58e7c90d671571002b1fff9a" translate="yes" xml:space="preserve">
          <source>If the generated time point is ever passed the edge of the range in the proper direction, then the edge of that range will be used instead. So, if iterating forward, and the generated time point is past the interval's &lt;code&gt;end&lt;/code&gt;, then &lt;code&gt;front&lt;/code&gt; becomes &lt;code&gt;end&lt;/code&gt;. If iterating backwards, and the generated time point is before &lt;code&gt;begin&lt;/code&gt;, then &lt;code&gt;front&lt;/code&gt; becomes &lt;code&gt;begin&lt;/code&gt;. In either case, the range would then be empty.</source>
          <target state="translated">生成された時点が範囲の端を適切な方向に通過する場合、代わりにその範囲の端が使用されます。したがって、前方に反復し、生成された時点が間隔の &lt;code&gt;end&lt;/code&gt; を過ぎている場合、 &lt;code&gt;front&lt;/code&gt; は &lt;code&gt;end&lt;/code&gt; になります。逆方向に反復し、生成された時点が &lt;code&gt;begin&lt;/code&gt; の前である場合、 &lt;code&gt;front&lt;/code&gt; が &lt;code&gt;begin&lt;/code&gt; になります。どちらの場合も、範囲は空になります。</target>
        </trans-unit>
        <trans-unit id="f99397fa61eb34180bac28883c2e71092de6779b" translate="yes" xml:space="preserve">
          <source>If the given file is a symbolic link, then this returns the attributes of the symbolic link itself rather than file that it points to. If the given file is</source>
          <target state="translated">与えられたファイルがシンボリックリンクである場合、これはそれが指すファイルではなく、シンボリックリンク自体の属性を返します。与えられたファイルが</target>
        </trans-unit>
        <trans-unit id="a8dd80adc35b72f7e72590ec9517794124fe146d" translate="yes" xml:space="preserve">
          <source>If the given header contains columns not found in the input they will be ignored.</source>
          <target state="translated">与えられたヘッダが入力に見当たらない列を含んでいる場合は、それらは無視されます。</target>
        </trans-unit>
        <trans-unit id="6c1edb4f30ef72dc654568216fa979bf98fad63c" translate="yes" xml:space="preserve">
          <source>If the given header does not match the order in the input, the content will return as it is found in the input.</source>
          <target state="translated">与えられたヘッダが入力の順序と一致しない場合は、内容は入力で見つかった通りに返されます。</target>
        </trans-unit>
        <trans-unit id="02a682f7846fb30dcf203d60bc7b6d3c76c4aec4" translate="yes" xml:space="preserve">
          <source>If the heap has room to grow, inserts &lt;code&gt;value&lt;/code&gt; into the store and returns &lt;code&gt;true&lt;/code&gt;. Otherwise, if &lt;code&gt;less(value, front)&lt;/code&gt;, calls &lt;code&gt;replaceFront(value)&lt;/code&gt; and returns again &lt;code&gt;true&lt;/code&gt;. Otherwise, leaves the heap unaffected and returns &lt;code&gt;false&lt;/code&gt;. This method is useful in scenarios where the smallest &lt;code&gt;k&lt;/code&gt; elements of a set of candidates must be collected.</source>
          <target state="translated">ヒープに拡張の余地がある場合、ストアに &lt;code&gt;value&lt;/code&gt; を挿入し、 &lt;code&gt;true&lt;/code&gt; を返します。それ以外の場合、 &lt;code&gt;less(value, front)&lt;/code&gt; &lt;code&gt;replaceFront(value)&lt;/code&gt; を呼び出して、再度 &lt;code&gt;true&lt;/code&gt; を返します。それ以外の場合は、ヒープに影響を与えずに &lt;code&gt;false&lt;/code&gt; を返します。この方法は、候補のセットの最小の &lt;code&gt;k&lt;/code&gt; 要素を収集する必要があるシナリオで役立ちます。</target>
        </trans-unit>
        <trans-unit id="44b5028eff915a424d2f05a190933f50e1ca6cdc" translate="yes" xml:space="preserve">
          <source>If the indexing key already exists in the AA, the setting runs normal assignment.</source>
          <target state="translated">既にAAにインデックスキーが存在する場合は、通常の代入を実行します。</target>
        </trans-unit>
        <trans-unit id="ed75ab58ae875098848f819360947f45ce239d60" translate="yes" xml:space="preserve">
          <source>If the indexing key does not yet exist in AA, a new AA entry will be allocated, and it will be initialized with the assigned value.</source>
          <target state="translated">インデックスキーがAAにまだ存在しない場合、新しいAAエントリが割り当てられ、割り当てられた値で初期化されます。</target>
        </trans-unit>
        <trans-unit id="e8855e5c687d575ac4df58472c04fb490240846e" translate="yes" xml:space="preserve">
          <source>If the infinite-precision result fits in the result type, return it and do not touch &lt;code&gt;overflow&lt;/code&gt;</source>
          <target state="translated">無限精度の結果が結果の型に収まる場合は、それを返し、 &lt;code&gt;overflow&lt;/code&gt; 触れないでください</target>
        </trans-unit>
        <trans-unit id="4845dcdf1de3a2fc72f78227d54d29b17278e722" translate="yes" xml:space="preserve">
          <source>If the initializer is not present, the immutable can be initialized from the corresponding constructor:</source>
          <target state="translated">イニシャライザが存在しない場合は、対応するコンストラクタから不変体を初期化することができます。</target>
        </trans-unit>
        <trans-unit id="b6a08857ba6ae055c6d0992d75eba874a7e5568d" translate="yes" xml:space="preserve">
          <source>If the input array is already valid, this function returns the original, otherwise it constructs a new array by replacing all illegal sequences with the encoding scheme's replacement sequence.</source>
          <target state="translated">入力配列が既に有効な場合,この関数は元の配列を返します.そうでない場合は,不正な配列をすべてエンコーディング方式の置換シーケンスで置き換えて新しい配列を作成します.</target>
        </trans-unit>
        <trans-unit id="8c989250d06df7a1e7f52d0b71ed6e2b6ea2a097" translate="yes" xml:space="preserve">
          <source>If the input string is already valid, this function returns the original, otherwise it constructs a new string by replacing all illegal code unit sequences with the encoding's replacement character, Invalid sequences will be replaced with the Unicode replacement character (U+FFFD) if the character repertoire contains it, otherwise invalid sequences will be replaced with '?'.</source>
          <target state="translated">入力文字列がすでに有効な場合には元の文字列を返し、そうでない場合には、不正なコード単位のシーケンスをすべてエンコーディングの置換文字に置き換えて新しい文字列を作成します。</target>
        </trans-unit>
        <trans-unit id="c3178232393693733f89474a2be2c7d87e890b8d" translate="yes" xml:space="preserve">
          <source>If the instance &lt;code&gt;toString&lt;/code&gt; has overridden &lt;code&gt;Object.toString&lt;/code&gt;, it is used.</source>
          <target state="translated">インスタンス &lt;code&gt;toString&lt;/code&gt; が &lt;code&gt;Object.toString&lt;/code&gt; をオーバーライドした場合、それが使用されます。</target>
        </trans-unit>
        <trans-unit id="3bbc396d6905590778769668af1612cc2bc09090" translate="yes" xml:space="preserve">
          <source>If the invariant does not hold, then the program enters an invalid state.</source>
          <target state="translated">不変量が保持されない場合、プログラムは無効な状態になります。</target>
        </trans-unit>
        <trans-unit id="29f830d3a5bba4e064a4eb84cc7502640a0b8dc9" translate="yes" xml:space="preserve">
          <source>If the last template parameter in the</source>
          <target state="translated">の最後のテンプレートパラメータが</target>
        </trans-unit>
        <trans-unit id="88a26f48b106a357207e0f09ddece2a679970e48" translate="yes" xml:space="preserve">
          <source>If the last template parameter is set to &lt;code&gt;No.multiblock&lt;/code&gt;, the allocator will only serve allocations which require at most &lt;code&gt;theBlockSize&lt;/code&gt;. The &lt;code&gt;BitmappedBlock&lt;/code&gt; has a specialized implementation for single-block allocations which allows for greater performance, at the cost of not being able to allocate more than one block at a time.</source>
          <target state="translated">最後のテンプレートパラメータが &lt;code&gt;No.multiblock&lt;/code&gt; に設定されている場合、アロケータは最大で &lt;code&gt;theBlockSize&lt;/code&gt; を必要とする割り当てのみを処理します。 &lt;code&gt;BitmappedBlock&lt;/code&gt; は、一度に複数のブロックを割り当てることができないのコストで、より高いパフォーマンスを可能にする単一のブロック割り当てのための特殊な実装を有します。</target>
        </trans-unit>
        <trans-unit id="b95587a219c8d062823f53f5bd2f1a123f7f69f2" translate="yes" xml:space="preserve">
          <source>If the left and right operands are of the same struct type, and the struct type has a &lt;a href=&quot;struct#Postblit&quot;&gt;&lt;i&gt;Postblit&lt;/i&gt;&lt;/a&gt;, then the copy operation is as described in &lt;a href=&quot;struct#struct-postblit&quot;&gt;Struct Postblit&lt;/a&gt;.</source>
          <target state="translated">左と右のオペランドが同じ構造体型で、構造体型に&lt;a href=&quot;struct#Postblit&quot;&gt;&lt;i&gt;Postblit&lt;/i&gt;&lt;/a&gt;がある場合、コピー操作は&lt;a href=&quot;struct#struct-postblit&quot;&gt;Struct Postblitで&lt;/a&gt;説明されているとおりです。</target>
        </trans-unit>
        <trans-unit id="78b1fe866d2fc25a11cfe13642305ae4d6350c6d" translate="yes" xml:space="preserve">
          <source>If the left hand side of an</source>
          <target state="translated">の左側が</target>
        </trans-unit>
        <trans-unit id="eb414c8d10d773bd339d18bd7ab37e8cf26592ba" translate="yes" xml:space="preserve">
          <source>If the left hand side of an assignment is a slice operation on a struct or class instance, it can be overloaded by implementing an &lt;code&gt;opIndexAssign&lt;/code&gt; member function that takes the return value of the &lt;code&gt;opSlice&lt;/code&gt; function as parameter(s). Expressions of the form &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">割り当ての左側が構造体またはクラスインスタンスのスライス操作である場合は、 &lt;code&gt;opSlice&lt;/code&gt; 関数の戻り値をパラメーターとして取る &lt;code&gt;opIndexAssign&lt;/code&gt; メンバー関数を実装することにより、オーバーロードできます。 &lt;code&gt;a[&lt;/code&gt; の形の表現</target>
        </trans-unit>
        <trans-unit id="a4e9f1b74401fc4cc6670aa5c593952f4aacceb0" translate="yes" xml:space="preserve">
          <source>If the left hand side of an assignment is an index operation on a struct or class instance, it can be overloaded by providing an &lt;code&gt;opIndexAssign&lt;/code&gt; member function. Expressions of the form &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">割り当ての左側が構造体またはクラスインスタンスのインデックス操作である場合は、 &lt;code&gt;opIndexAssign&lt;/code&gt; メンバー関数を提供することでオーバーロードできます。 &lt;code&gt;a[&lt;/code&gt; の形の表現</target>
        </trans-unit>
        <trans-unit id="d8a73a5f2389d0e22c2833822feb34b34d4eccd0" translate="yes" xml:space="preserve">
          <source>If the left operand is &lt;code&gt;false&lt;/code&gt;, then the right operand is evaluated. If the result type of the</source>
          <target state="translated">左側のオペランドが &lt;code&gt;false&lt;/code&gt; の場合、右側のオペランドが評価されます。の結果タイプが</target>
        </trans-unit>
        <trans-unit id="60ea3d064b90b5b8a778e152eace4b2f3ae90eb9" translate="yes" xml:space="preserve">
          <source>If the left operand is &lt;code&gt;true&lt;/code&gt;, then the right operand is evaluated. If the result type of the</source>
          <target state="translated">左側のオペランドが &lt;code&gt;true&lt;/code&gt; の場合、右側のオペランドが評価されます。の結果タイプが</target>
        </trans-unit>
        <trans-unit id="019b690c1822d6ef391c3b9bd7b26426c5f16db7" translate="yes" xml:space="preserve">
          <source>If the left operand, converted to type &lt;code&gt;bool&lt;/code&gt;, evaluates to &lt;code&gt;false&lt;/code&gt;, then the right operand is not evaluated. If the result type of the</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 型に変換された左のオペランドが &lt;code&gt;false&lt;/code&gt; と評価された場合、右のオペランドは評価されません。の結果タイプが</target>
        </trans-unit>
        <trans-unit id="553371891fa4522412ee1e69cce9e04315ec8432" translate="yes" xml:space="preserve">
          <source>If the left operand, converted to type &lt;code&gt;bool&lt;/code&gt;, evaluates to &lt;code&gt;true&lt;/code&gt;, then the right operand is not evaluated. If the result type of the</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 型に変換された左のオペランドが &lt;code&gt;true&lt;/code&gt; に評価される場合、右のオペランドは評価されません。の結果タイプが</target>
        </trans-unit>
        <trans-unit id="3b4965e0366e4348265d324ef6cafd070f7970a9" translate="yes" xml:space="preserve">
          <source>If the lock is held by another caller, the method returns. Otherwise, the lock is acquired if it is not already held, and then the internal counter is incremented by one.</source>
          <target state="translated">ロックが他の呼び出し元によって保持されている場合、メソッドは戻ります。そうでなければ、ロックがまだ保持されていない場合はロックを取得し、内部カウンタを 1 つインクリメントします。</target>
        </trans-unit>
        <trans-unit id="55629f3e58b1ed6b51915672626c91dce13adbf6" translate="yes" xml:space="preserve">
          <source>If the lvalue is a static array or a slice, the behavior is as described in &lt;a href=&quot;array#array-copying&quot;&gt;Array Copying&lt;/a&gt; and &lt;a href=&quot;array#array-setting&quot;&gt;Array Setting&lt;/a&gt;.</source>
          <target state="translated">左辺値が静的配列またはスライスである場合、動作は「&lt;a href=&quot;array#array-copying&quot;&gt;配列のコピー&lt;/a&gt;と&lt;a href=&quot;array#array-setting&quot;&gt;配列の設定」で&lt;/a&gt;説明されているとおりです。</target>
        </trans-unit>
        <trans-unit id="9eeb3d42a4d163cc9ef2cce9f7a4d552e700ff44" translate="yes" xml:space="preserve">
          <source>If the lvalue is a user-defined property, the behavior is as described in &lt;a href=&quot;function#property-functions&quot;&gt;Property Functions&lt;/a&gt;.</source>
          <target state="translated">左辺値がユーザー定義のプロパティである場合、動作は&lt;a href=&quot;function#property-functions&quot;&gt;プロパティ関数で&lt;/a&gt;説明されているとおりです。</target>
        </trans-unit>
        <trans-unit id="1e946590fb7a5bc10633af10a8d9500f37b24a5e" translate="yes" xml:space="preserve">
          <source>If the lvalue is the &lt;code&gt;.length&lt;/code&gt; property of a dynamic array, the behavior is as described in &lt;a href=&quot;array#resize&quot;&gt;Setting Dynamic Array Length&lt;/a&gt;.</source>
          <target state="translated">左辺値が動的配列の &lt;code&gt;.length&lt;/code&gt; プロパティである場合、動作は&lt;a href=&quot;array#resize&quot;&gt;動的配列の長さの設定で&lt;/a&gt;説明されているとおりです。</target>
        </trans-unit>
        <trans-unit id="dbdda788f4cd04313acf31a5b41902468d969a5d" translate="yes" xml:space="preserve">
          <source>If the member is a class or struct, undefined lookups will be forwarded to the</source>
          <target state="translated">メンバがクラスまたは構造体の場合、未定義のルックアップは</target>
        </trans-unit>
        <trans-unit id="c199908c7f62621c91cf713b59d48d772db7abde" translate="yes" xml:space="preserve">
          <source>If the modifier &lt;code&gt;'d'&lt;/code&gt; is present, then the number of characters in &lt;code&gt;to&lt;/code&gt; may be only &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;.  If the modifier &lt;code&gt;'d'&lt;/code&gt; is</source>
          <target state="translated">修飾子 &lt;code&gt;'d'&lt;/code&gt; が存在 &lt;code&gt;to&lt;/code&gt; 場合、toの文字数は &lt;code&gt;0&lt;/code&gt; または &lt;code&gt;1&lt;/code&gt; のみです。修飾子 &lt;code&gt;'d'&lt;/code&gt; が</target>
        </trans-unit>
        <trans-unit id="f37f897b787b41e685e34c136ea8c1b433cab685" translate="yes" xml:space="preserve">
          <source>If the need is to remove some elements in the range but the order of the remaining elements does not have to be preserved, you may want to pass &lt;code&gt;SwapStrategy.unstable&lt;/code&gt; to &lt;code&gt;remove&lt;/code&gt;.</source>
          <target state="translated">範囲内の一部の要素を削除する必要があるが、残りの要素の順序を維持する必要がない場合は、 &lt;code&gt;SwapStrategy.unstable&lt;/code&gt; を渡してremoveを実行 &lt;code&gt;remove&lt;/code&gt; ことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="03a264184d81bbe95136e2edec953acc73c6e493" translate="yes" xml:space="preserve">
          <source>If the new array length is longer, the remainder is filled out with the default initializer.</source>
          <target state="translated">新しい配列の長さが長くなると、残りはデフォルトのイニシャライザで塗りつぶされます。</target>
        </trans-unit>
        <trans-unit id="e4175ca1068588312ee2e22b72b62b8fd2ed5c5b" translate="yes" xml:space="preserve">
          <source>If the only pointer to an object is held outside of these areas, then the collector will miss it and free the memory.</source>
          <target state="translated">オブジェクトへの唯一のポインタがこれらの領域の外に保持されている場合、コレクターはそれを見逃してメモリを解放します。</target>
        </trans-unit>
        <trans-unit id="4717846b29b0f5d911b4b2433c06faa02839af64" translate="yes" xml:space="preserve">
          <source>If the operands are integral values, the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt; are applied to bring them to a common type before comparison. Equality is defined as the bit patterns of the common type match exactly.</source>
          <target state="translated">オペランドが整数値の場合、比較の前に、&lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;通常の算術変換&lt;/a&gt;が適用され、それらが共通の型に変換されます。同等性は、一般的なタイプのビットパターンが正確に一致することとして定義されます。</target>
        </trans-unit>
        <trans-unit id="47f360c49b94c4c07ce9dc61c5e3af5635a7a2ca" translate="yes" xml:space="preserve">
          <source>If the operands are of integral types, they undergo the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;, and then are brought to a common type using the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;.</source>
          <target state="translated">オペランドが整数型である場合、それらは&lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;通常の算術変換&lt;/a&gt;を受け、その後、&lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;通常の算術変換&lt;/a&gt;を使用して共通の型に変換されます。</target>
        </trans-unit>
        <trans-unit id="84b7a8c85c49e4f67e102545e92d61c9c7d7721a" translate="yes" xml:space="preserve">
          <source>If the operands are pointers, equality is defined as the bit patterns of the operands match exactly.</source>
          <target state="translated">オペランドがポインタである場合、オペランドのビットパターンが完全に一致していることが等しく定義されます。</target>
        </trans-unit>
        <trans-unit id="d6d2f3784c99d4e2535bc4e5ff87e942828bc905" translate="yes" xml:space="preserve">
          <source>If the operands are the same type, the result will be of that type.</source>
          <target state="translated">オペランドが同じ型の場合、結果はその型になります。</target>
        </trans-unit>
        <trans-unit id="5b2963819db13f5d2cdfe8c71bec58c53fd098f3" translate="yes" xml:space="preserve">
          <source>If the operands are the same type, the result will be the that type.</source>
          <target state="translated">オペランドが同じ型であれば、結果はその型になります。</target>
        </trans-unit>
        <trans-unit id="b17e0053bf5ffe1d2e67cd6799c427ff52f64545" translate="yes" xml:space="preserve">
          <source>If the operands of an associative operator + or * are floating point values, the expression is not reordered.</source>
          <target state="translated">連想演算子+または*のオペランドが浮動小数点値の場合、式の並び替えは行われません。</target>
        </trans-unit>
        <trans-unit id="1ff3f829adb0f4d6d8dd5ae222b510bf5f3ff104" translate="yes" xml:space="preserve">
          <source>If the operation would lead to an over/underflow, this function will return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">操作によってオーバーフローまたはアンダーフローが発生する場合、この関数は &lt;code&gt;0&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="988a22885dd9a150d46126a78cb644539f3b1a37" translate="yes" xml:space="preserve">
          <source>If the operator is &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, and the first operand is a pointer, and the second is an integral type, the resulting type is the type of the first operand, and the resulting value is the pointer plus (or minus) the second operand multiplied by the size of the type pointed to by the first operand.</source>
          <target state="translated">演算子が &lt;code&gt;+&lt;/code&gt; または &lt;code&gt;-&lt;/code&gt; で、最初のオペランドがポインターで、2番目が整数型の場合、結果の型は最初のオペランドの型であり、結果の値はポインターに2番目のオペランドをプラス（またはマイナス）したものです。第1オペランドが指す型のサイズを掛けたもの。</target>
        </trans-unit>
        <trans-unit id="34ffd24d69741e93233760376d587038f7e6c1e1" translate="yes" xml:space="preserve">
          <source>If the operator is &lt;code&gt;=&lt;/code&gt; then it is simple assignment. The right operand is implicitly converted to the type of the left operand, and assigned to it.</source>
          <target state="translated">演算子が &lt;code&gt;=&lt;/code&gt; の場合、それは単純な代入です。右のオペランドは、暗黙的に左のオペランドのタイプに変換され、割り当てられます。</target>
        </trans-unit>
        <trans-unit id="fd1b71b4b4c55aa30d89d8186ad8ca957d4c8944" translate="yes" xml:space="preserve">
          <source>If the optional second</source>
          <target state="translated">オプションの2番目の</target>
        </trans-unit>
        <trans-unit id="c5921859078b177e6c63e26fb0f1ad26714bef56" translate="yes" xml:space="preserve">
          <source>If the parent allocator &lt;code&gt;Allocator&lt;/code&gt; is stateful, an instance of it is stored as a member. Otherwise, &lt;code&gt;AffixAllocator&lt;/code&gt; uses &lt;code&gt;Allocator.instance&lt;/code&gt;. In either case, the name &lt;code&gt;_parent&lt;/code&gt; is uniformly used for accessing the parent allocator.</source>
          <target state="translated">親アロケータである &lt;code&gt;Allocator&lt;/code&gt; がステートフルの場合、そのインスタンスはメンバーとして格納されます。それ以外の場合は、 &lt;code&gt;AffixAllocator&lt;/code&gt; は使用しています &lt;code&gt;Allocator.instance&lt;/code&gt; を。どちらの場合も、名前 &lt;code&gt;_parent&lt;/code&gt; は、親アロケーターへのアクセスに一律に使用されます。</target>
        </trans-unit>
        <trans-unit id="af9326a4bd5d7cb5b11db287f31708f748f7ca2d" translate="yes" xml:space="preserve">
          <source>If the passed buffer is not the last allocation, then &lt;code&gt;delta&lt;/code&gt; can be at most the number of bytes left on the last page. Otherwise, we can expand the last allocation until the end of the virtual address range.</source>
          <target state="translated">渡されたバッファが最後の割り当てではない場合、 &lt;code&gt;delta&lt;/code&gt; は最大で最後のページに残っているバイト数になります。それ以外の場合は、仮想アドレス範囲の終わりまで最後の割り当てを拡張できます。</target>
        </trans-unit>
        <trans-unit id="e540ec8736760fd165d128b0a1be1fa92246d1c7" translate="yes" xml:space="preserve">
          <source>If the process associated with &lt;code&gt;pid&lt;/code&gt; has already terminated, &lt;code&gt;tryWait&lt;/code&gt; has the exact same effect as &lt;code&gt;wait&lt;/code&gt;. In this case, it returns a tuple where the &lt;code&gt;terminated&lt;/code&gt; field is set to &lt;code&gt;true&lt;/code&gt; and the &lt;code&gt;status&lt;/code&gt; field has the same interpretation as the return value of &lt;code&gt;wait&lt;/code&gt;.</source>
          <target state="translated">関連するプロセスが &lt;code&gt;pid&lt;/code&gt; にプロセスがすでに終了している場合、 &lt;code&gt;tryWait&lt;/code&gt; は &lt;code&gt;wait&lt;/code&gt; とまったく同じ効果があります。この場合、 &lt;code&gt;terminated&lt;/code&gt; フィールドが &lt;code&gt;true&lt;/code&gt; に設定され、 &lt;code&gt;status&lt;/code&gt; フィールドの解釈が &lt;code&gt;wait&lt;/code&gt; の戻り値と同じであるタプルを返します。</target>
        </trans-unit>
        <trans-unit id="0cc712808d5442951029c772a2016b0fbaebf6a3" translate="yes" xml:space="preserve">
          <source>If the process has</source>
          <target state="translated">プロセスが</target>
        </trans-unit>
        <trans-unit id="8a1cda6113d7bf95379f37d69fe6660204f54b65" translate="yes" xml:space="preserve">
          <source>If the process has already terminated, this function returns directly. The exit code is cached, so that if wait() is called multiple times on the same &lt;a href=&quot;#Pid&quot;&gt;&lt;code&gt;Pid&lt;/code&gt;&lt;/a&gt; it will always return the same value.</source>
          <target state="translated">プロセスがすでに終了している場合、この関数は直接戻ります。終了コードはキャッシュされるため、同じ&lt;a href=&quot;#Pid&quot;&gt; &lt;code&gt;Pid&lt;/code&gt; &lt;/a&gt;でwait（）が複数回呼び出された場合、常に同じ値が返されます。</target>
        </trans-unit>
        <trans-unit id="04681d73e96e38582bd8e0a705f2c67039e3da37" translate="yes" xml:space="preserve">
          <source>If the process is terminated by a signal, the &lt;code&gt;status&lt;/code&gt; field of the return value will contain a negative number whose absolute value is the signal number. (See &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="translated">プロセスがシグナルによって終了した場合、戻り値の &lt;code&gt;status&lt;/code&gt; フィールドには、絶対値がシグナル番号である負の数が含まれます。（詳細については、&lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;を参照してください。）</target>
        </trans-unit>
        <trans-unit id="2cb4ce468479df22f5efb3ab328110646f8f6c12" translate="yes" xml:space="preserve">
          <source>If the process is terminated by a signal, this function returns a negative number whose absolute value is the signal number. Since POSIX restricts normal exit codes to the range 0-255, a negative return value will always indicate termination by signal. Signal codes are defined in the &lt;code&gt;core.sys.posix.signal&lt;/code&gt; module (which corresponds to the &lt;code&gt;signal.h&lt;/code&gt; POSIX header).</source>
          <target state="translated">プロセスがシグナルで終了した場合、この関数は絶対値がシグナル番号である負の数を返します。POSIXは通常の終了コードを0〜255の範囲に制限しているため、負の戻り値は常にシグナルによる終了を示します。シグナルコードは、 &lt;code&gt;core.sys.posix.signal&lt;/code&gt; モジュール（ &lt;code&gt;signal.h&lt;/code&gt; POSIXヘッダーに対応）で定義されています。</target>
        </trans-unit>
        <trans-unit id="55d51d320c375e52c1f5d554f57416c612f36789" translate="yes" xml:space="preserve">
          <source>If the range is already the lexicographically greatest even permutation, it is permuted back to the least even permutation and false is returned. Otherwise, true is returned, and the range is modified in-place to be the lexicographically next even permutation.</source>
          <target state="translated">範囲が既に辞書的に最大の偶数並べ替えである場合、その範囲は最小の偶数並べ替えに戻され、falseが返されます。そうでない場合はtrueが返され、その範囲は辞書的に次の偶数並べ替えになるように変更されます。</target>
        </trans-unit>
        <trans-unit id="b6341c08a4c104d5a17945be30a12feeaa49cdba" translate="yes" xml:space="preserve">
          <source>If the range is currently the lexicographically greatest permutation, it is permuted back to the least permutation and false is returned. Otherwise, true is returned. One can thus generate all permutations of a range by sorting it according to &lt;code&gt;less&lt;/code&gt;, which produces the lexicographically least permutation, and then calling nextPermutation until it returns false. This is guaranteed to generate all distinct permutations of the range exactly once. If there are</source>
          <target state="translated">現在、範囲が辞書式順序で最大の順列である場合、最小の順列に並べ替えられ、falseが返されます。それ以外の場合は、trueが返されます。したがって、範囲に従ってすべての順列を生成できます。これは &lt;code&gt;less&lt;/code&gt; に従ってソートし、辞書順で最小の順列を生成し、次にfalseが返されるまでnextPermutationを呼び出します。これにより、範囲のすべての異なる順列が1回だけ生成されることが保証されます。ある場合</target>
        </trans-unit>
        <trans-unit id="3c682555e85edc7cea0e0b4d1aeb80e941ac4580" translate="yes" xml:space="preserve">
          <source>If the range runs out before &lt;code&gt;n&lt;/code&gt; elements, &lt;code&gt;take&lt;/code&gt; simply returns the entire range (unlike &lt;a href=&quot;#takeExactly&quot;&gt;&lt;code&gt;takeExactly&lt;/code&gt;&lt;/a&gt;, which will cause an assertion failure if the range ends prematurely):</source>
          <target state="translated">以前に範囲がなくなった場合 &lt;code&gt;n&lt;/code&gt; 要素の、 &lt;code&gt;take&lt;/code&gt; は単に範囲全体を返します（&lt;a href=&quot;#takeExactly&quot;&gt; &lt;code&gt;takeExactly&lt;/code&gt; &lt;/a&gt;とは異なり、範囲が途中で終了するとアサーションエラーが発生します）。</target>
        </trans-unit>
        <trans-unit id="0bfb47486948f76918fc7de4a55b72efe69b4181" translate="yes" xml:space="preserve">
          <source>If the ranges are strings, &lt;code&gt;cmp&lt;/code&gt; performs UTF decoding appropriately and compares the ranges one code point at a time.</source>
          <target state="translated">範囲が文字列の場合、 &lt;code&gt;cmp&lt;/code&gt; はUTFデコードを適切に実行し、一度に1つのコードポイントで範囲を比較します。</target>
        </trans-unit>
        <trans-unit id="ea41ed6834ee0093fe72c06e40f7dc343689c14c" translate="yes" xml:space="preserve">
          <source>If the restrictions above are met, the following copy constructor is generated:</source>
          <target state="translated">上記の制約を満たす場合、以下のようなコピーコンストラクタが生成されます。</target>
        </trans-unit>
        <trans-unit id="7f1cd9d3b49d8a1f62d192e4c5f4c5d296e6ef4a" translate="yes" xml:space="preserve">
          <source>If the return type is int, and the result can't fit in an int, then the closest value that can be held in 32 bits will be used (so &lt;code&gt;int.max&lt;/code&gt; if it goes over and &lt;code&gt;int.min&lt;/code&gt; if it goes under). However, no attempt is made to deal with integer overflow if the return type is long.</source>
          <target state="translated">戻り値の型がintで、結果がintに収まらない場合、32ビットで保持できる最も近い値が使用されます（したがって &lt;code&gt;int.max&lt;/code&gt; が上回れば &lt;code&gt;int.min&lt;/code&gt; が下回ると） 。ただし、戻り値の型が長い場合、整数オーバーフローの処理は行われません。</target>
        </trans-unit>
        <trans-unit id="dd2f2570182620b9927043173b24e489663dd5b6" translate="yes" xml:space="preserve">
          <source>If the return value is not equal to x, the FE_INEXACT exception is raised.</source>
          <target state="translated">戻り値が x と等しくない場合、FE_INEXACT 例外が発生します。</target>
        </trans-unit>
        <trans-unit id="d430fac68e42265828ef3bb0905404a148953d53" translate="yes" xml:space="preserve">
          <source>If the right-hand side is also a Checked but with a different hook or underlying type, the hook and underlying type of this Checked takes precedence.</source>
          <target state="translated">右側がチェックされているが、フックや下のタイプが異なる場合は、このチェックのフックや下のタイプが優先されます。</target>
        </trans-unit>
        <trans-unit id="decd65c423494fe4dd1111ea2c9da5871cfb6a35" translate="yes" xml:space="preserve">
          <source>If the second argument's length is less than that of the range indexed, an exception is thrown.</source>
          <target state="translated">第二引数の長さがインデックス化された範囲の長さよりも小さい場合は例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="09c0c3ad5616d292e80fb1d35bad8dff429d7620" translate="yes" xml:space="preserve">
          <source>If the second character of &lt;code&gt;path&lt;/code&gt; is a colon (&lt;code&gt;':'&lt;/code&gt;), the first character is interpreted as a drive letter, and must be in the range A-Z (case insensitive).</source>
          <target state="translated">の2番目の文字 &lt;code&gt;path&lt;/code&gt; コロン（ &lt;code&gt;':'&lt;/code&gt; ）の場合、最初の文字はドライブ文字として解釈され、AZ（大文字と小文字を区別しない）の範囲内にある必要があります。</target>
        </trans-unit>
        <trans-unit id="c8d361e2ea8510e2f9b6eea1c593f762c25ea047" translate="yes" xml:space="preserve">
          <source>If the second operand is a pointer, and the first is an integral type, and the operator is &lt;code&gt;+&lt;/code&gt;, the operands are reversed and the pointer arithmetic just described is applied.</source>
          <target state="translated">2番目のオペランドがポインターで、最初のオペランドが整数型で、演算子が &lt;code&gt;+&lt;/code&gt; の場合、オペランドは逆になり、先ほど説明したポインター演算が適用されます。</target>
        </trans-unit>
        <trans-unit id="32b0c9d866faa45199f7035225674aa790902392" translate="yes" xml:space="preserve">
          <source>If the sequence ending at &lt;code&gt;startIdx&lt;/code&gt; does not represent a well formed codepoint, then a &lt;a href=&quot;std_utf#UTFException&quot;&gt;&lt;code&gt;std.utf.UTFException&lt;/code&gt;&lt;/a&gt; may be thrown.  &lt;code&gt;cs&lt;/code&gt; indicates whether the comparisons are case sensitive.</source>
          <target state="translated">&lt;code&gt;startIdx&lt;/code&gt; で終わるシーケンスが適切な形式のコードポイントを表していない場合、&lt;a href=&quot;std_utf#UTFException&quot;&gt; &lt;code&gt;std.utf.UTFException&lt;/code&gt; &lt;/a&gt;がスローされることがあります。 &lt;code&gt;cs&lt;/code&gt; は、比較で大文字と小文字が区別されるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="a37342eba6058b3aa514ecc3e65805a0fa7ec8d8" translate="yes" xml:space="preserve">
          <source>If the sequence is a</source>
          <target state="translated">シーケンスが</target>
        </trans-unit>
        <trans-unit id="6e3f474a691ae0e04c816db20a8a1ee2782164f2" translate="yes" xml:space="preserve">
          <source>If the sequence starting at &lt;code&gt;startIdx&lt;/code&gt; does not represent a well formed codepoint, then a &lt;a href=&quot;std_utf#UTFException&quot;&gt;&lt;code&gt;std.utf.UTFException&lt;/code&gt;&lt;/a&gt; may be thrown.</source>
          <target state="translated">&lt;code&gt;startIdx&lt;/code&gt; で始まるシーケンスが整形式のコードポイントを表していない場合、&lt;a href=&quot;std_utf#UTFException&quot;&gt; &lt;code&gt;std.utf.UTFException&lt;/code&gt; &lt;/a&gt;がスローされることがあります。</target>
        </trans-unit>
        <trans-unit id="2ca37c345a633b86c3f0a8d6f14512c0f7890283" translate="yes" xml:space="preserve">
          <source>If the sign bit is set (that is, it's 'negative'), NAN is less than any number; if the sign bit is not set (it is 'positive'), NAN is greater than any number;</source>
          <target state="translated">符号ビットがセットされている場合(つまり、「負」である場合)、NANはどの数値よりも小さく、符号ビットがセットされていない場合(「正」である場合)、NANはどの数値よりも大きくなります。</target>
        </trans-unit>
        <trans-unit id="ad31a32f0506299a66cf84413a7632e943786b66" translate="yes" xml:space="preserve">
          <source>If the signed type is larger than the unsigned type, the unsigned type is converted to the signed type.</source>
          <target state="translated">符号付き型が符号なし型よりも大きい場合、符号なし型は符号付き型に変換されます。</target>
        </trans-unit>
        <trans-unit id="e9a551f8b9f105f8f42e469f990b7c6973a86a1b" translate="yes" xml:space="preserve">
          <source>If the slice bounds can be known at compile time, the slice expression is implicitly convertible to an lvalue of static array. For example:</source>
          <target state="translated">コンパイル時にスライスの境界を知ることができる場合、スライス式は暗黙のうちに静的配列のl値に変換されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="6ad59f15848db49d072bd8cb912bde77ae2b6ed6" translate="yes" xml:space="preserve">
          <source>If the source file does not start with a BOM, then the first character must be less than or equal to U+0000007F.</source>
          <target state="translated">ソースファイルが BOM で始まらない場合は、最初の文字は U+0000007F 以下でなければなりません。</target>
        </trans-unit>
        <trans-unit id="b27e4bb1c5315e54c4ca57d01e83f479ac84dbd7" translate="yes" xml:space="preserve">
          <source>If the string data is UTF-8 and can be accessed directly, return a pointer to it. Do not assume a terminating 0.</source>
          <target state="translated">文字列データがUTF-8で直接アクセス可能な場合は、そのポインタを返す。終端0を想定してはいけません。</target>
        </trans-unit>
        <trans-unit id="5f0ad93f155cd5ae6b24670f9767f5398de5e539" translate="yes" xml:space="preserve">
          <source>If the string does not contain an ampersand, the original will be returned.</source>
          <target state="translated">文字列にアンパサンドが含まれていない場合は、元の文字列が返されます。</target>
        </trans-unit>
        <trans-unit id="1aa7c7c38f043029163560616539bec8cc7f49c1" translate="yes" xml:space="preserve">
          <source>If the string is not a legitimate IPv4 address, &lt;code&gt;ADDR_NONE&lt;/code&gt; is returned.</source>
          <target state="translated">文字列が正当なIPv4アドレスでない場合、 &lt;code&gt;ADDR_NONE&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="b15b906e5c8636437606a7baf9615fdd3533eb67" translate="yes" xml:space="preserve">
          <source>If the string is not modified, the original will be returned.</source>
          <target state="translated">文字列が変更されていない場合は、元の文字列が返されます。</target>
        </trans-unit>
        <trans-unit id="52f9a3df378000710aaee65a7a54a47ac2ca66c0" translate="yes" xml:space="preserve">
          <source>If the struct defines a &lt;b&gt;toString()&lt;/b&gt; method the result is the string returned from this function. Otherwise the result is StructName(field&lt;sub&gt;0&lt;/sub&gt;, field&lt;sub&gt;1&lt;/sub&gt;, ...) where field&lt;sub&gt;n&lt;/sub&gt; is the nth element formatted with the default format.</source>
          <target state="translated">構造体が&lt;b&gt;toString（）&lt;/b&gt;メソッドを定義する場合、結果はこの関数から返される文字列です。それ以外の場合、結果はStructName（field &lt;sub&gt;0&lt;/sub&gt;、field &lt;sub&gt;1&lt;/sub&gt;、...）になります。ここで、field &lt;sub&gt;n&lt;/sub&gt;はデフォルトのフォーマットでフォーマットされたn番目の要素です。</target>
        </trans-unit>
        <trans-unit id="479988510a7f9556e5fa41c90de2fc0cc635572b" translate="yes" xml:space="preserve">
          <source>If the switch &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; is of enum type, all the enum members must appear in the &lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt;s.</source>
          <target state="translated">スイッチ&lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;式&lt;/i&gt;&lt;/a&gt;が列挙型である場合、すべての列挙メンバーが&lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatementに含ま&lt;/i&gt;&lt;/a&gt;れている必要があります。</target>
        </trans-unit>
        <trans-unit id="392ee3a5c086f39b17e3a3bb06e7ae5f17a147b6" translate="yes" xml:space="preserve">
          <source>If the switch &lt;code&gt;--DRT-testmode&lt;/code&gt; is passed to the executable, it can have one of 3 values:</source>
          <target state="translated">スイッチ &lt;code&gt;--DRT-testmode&lt;/code&gt; が実行可能ファイルに渡される場合、次の3つの値のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="a0154ff095266436fcdfa44d46155c17b50639bb" translate="yes" xml:space="preserve">
          <source>If the switch &lt;code&gt;--DRT-testmode&lt;/code&gt; is passed to the executable, it can have one of 3 values: 1. &quot;run-main&quot;: even if unit tests are run (and all pass), main is still run. This is currently the default. 2. &quot;test-or-main&quot;: any unit tests present will cause the program to summarize the results and exit regardless of the result. This will be the default in 2.080. 3. &quot;test-only&quot;, the runtime will always summarize and never run main, even if no tests are present.</source>
          <target state="translated">スイッチ &lt;code&gt;--DRT-testmode&lt;/code&gt; が実行可能ファイルに渡された場合、3つの値のいずれかになります。1. &quot;run-main&quot;：ユニットテストが実行されても（すべて合格）、mainは実行されます。これが現在のデフォルトです。2. &quot;test-or-main&quot;：ユニットテストが存在すると、プログラムは結果を要約し、結果に関係なく終了します。これは2.080のデフォルトになります。3.「テストのみ」の場合、ランタイムが常に要約され、テストが存在しない場合でもメインは実行されません。</target>
        </trans-unit>
        <trans-unit id="cefab3eab3f045d8e153ce4eb6c35b376eb78553" translate="yes" xml:space="preserve">
          <source>If the thread hasn't been started yet, returns &lt;a href=&quot;#ThreadID&quot;&gt;&lt;code&gt;ThreadID&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.init&lt;/code&gt;. Otherwise, returns the result of &lt;code&gt;GetCurrentThreadId&lt;/code&gt; on Windows, and &lt;code&gt;pthread_self&lt;/code&gt; on POSIX.  The value is unique for the current process.</source>
          <target state="translated">スレッドがまだ開始されていない場合は、&lt;a href=&quot;#ThreadID&quot;&gt; &lt;code&gt;ThreadID&lt;/code&gt; &lt;/a&gt; &lt;code&gt;.init&lt;/code&gt; を返します。それ以外の場合は、Windowsでは &lt;code&gt;GetCurrentThreadId&lt;/code&gt; 、POSIXでは &lt;code&gt;pthread_self&lt;/code&gt; の結果を返します。値は現在のプロセスに固有です。</target>
        </trans-unit>
        <trans-unit id="6c09982745040566b9680ca05a80be2c692c0e01" translate="yes" xml:space="preserve">
          <source>If the time zone is &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; (or considered to be equivalent to &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; by section 4.3 of the spec), a &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt;&lt;/a&gt; with a utc offset of &lt;code&gt;0&lt;/code&gt; is used rather than &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt;&lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt;&lt;/a&gt;, whereas &lt;code&gt;&quot;+0000&quot;&lt;/code&gt; uses &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt;&lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">タイムゾーンが &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; （または仕様のセクション4.3で &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; と同等と見なされる）の場合、&lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt; &lt;/a&gt;ではなく、utcオフセットが &lt;code&gt;0&lt;/code&gt; の std.datetime.timezone.SimpleTimeZone が使用され&lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt; &lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&quot;+0000&quot;&lt;/code&gt; &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt; &lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt; &lt;/a&gt;」はstd.datetime.timezone.UTCを使用するのに対し、timezone.UTC。</target>
        </trans-unit>
        <trans-unit id="3134e4dcc33577153221f4543bd47086f16438e4" translate="yes" xml:space="preserve">
          <source>If the two arguments are both lambda functions (or aliases to lambda functions), then they are compared for equality. For the comparison to be computed correctly, the following conditions must be met for both lambda functions:</source>
          <target state="translated">2つの引数が両方ともラムダ関数(またはラムダ関数のエイリアス)である場合、それらは等しくなるように比較されます。比較が正しく計算されるためには、両方のラムダ関数について以下の条件を満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="73a39971fe15042884479dfdbb241d4da31bea94" translate="yes" xml:space="preserve">
          <source>If the two arguments are expressions made up of literals or enums that evaluate to the same value, true is returned.</source>
          <target state="translated">2つの引数が同じ値に評価されるリテラルまたは列挙型の式である場合、trueが返されます。</target>
        </trans-unit>
        <trans-unit id="de4732a957b75ea4620f562388e09ef879657bc9" translate="yes" xml:space="preserve">
          <source>If the two arguments are tuples then &lt;code&gt;isSame&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if the two tuples, after expansion, have the same length and if each pair of nth argument respects the constraints previously specified.</source>
          <target state="translated">2つの引数がタプルの場合、展開後の2つのタプルの長さが同じで、n番目の引数の各ペアが以前に指定された制約を尊重する場合、 &lt;code&gt;isSame&lt;/code&gt; は &lt;code&gt;true&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="a4473404d01a76d50b04f7848135307a27ac80f3" translate="yes" xml:space="preserve">
          <source>If the two operands are different enums, the result is the closest base type common to both. A base type being closer means there is a shorter sequence of conversions to base type to get there from the original type.</source>
          <target state="translated">2つのオペランドが異なるenumである場合、結果は両方に共通する最も近い基底型になります。基底型が近いということは、元の型から基底型への変換が短いことを意味します。</target>
        </trans-unit>
        <trans-unit id="7903bedffa68e879ccc58bd5af9a496c7c800c23" translate="yes" xml:space="preserve">
          <source>If the two ranges are different kinds of UTF code unit (&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;wchar&lt;/code&gt;, or &lt;code&gt;dchar&lt;/code&gt;), then the arrays are compared using UTF decoding to avoid accidentally integer-promoting units.</source>
          <target state="translated">2つの範囲が異なる種類のUTFコード単位（ &lt;code&gt;char&lt;/code&gt; 、 &lt;code&gt;wchar&lt;/code&gt; 、または &lt;code&gt;dchar&lt;/code&gt; ）である場合、誤って整数を昇格させる単位を回避するために、UTFデコードを使用して配列が比較されます。</target>
        </trans-unit>
        <trans-unit id="b866fed7529b50ec607a768135519745618bce85" translate="yes" xml:space="preserve">
          <source>If the type is a class or struct, returns the symbol for it, else null.</source>
          <target state="translated">型がクラスまたは構造体の場合はそのシンボルを返し、そうでない場合はnullを返します。</target>
        </trans-unit>
        <trans-unit id="9cf47ab4617bfcf6525f2e55361b003e49f6a33c" translate="yes" xml:space="preserve">
          <source>If the type of a function literal can be uniquely determined from its context, the parameter type inference is possible.</source>
          <target state="translated">関数リテラルの型がコンテキストから一意に決定できる場合、パラメータの型推論が可能です。</target>
        </trans-unit>
        <trans-unit id="bd9e26eaa127a0681e40e687c51d18388c1cb11f" translate="yes" xml:space="preserve">
          <source>If the type specialization is dependent on a type parameter, the type of that parameter is set to be the corresponding part of the type argument.</source>
          <target state="translated">型の特殊化が型パラメータに依存している場合は、その型パラメータの型が型引数の対応する部分に設定されます。</target>
        </trans-unit>
        <trans-unit id="c38cd0e42755b32d0615eb6b41299ea06a9e9a58" translate="yes" xml:space="preserve">
          <source>If the union defines a &lt;b&gt;toString()&lt;/b&gt; method the result is the string returned from this function. Otherwise the result is the name of the union, without its contents.</source>
          <target state="translated">共用体が&lt;b&gt;toString（）&lt;/b&gt;メソッドを定義している場合、結果はこの関数から返された文字列です。それ以外の場合、結果はユニオンの名前で、内容は含まれません。</target>
        </trans-unit>
        <trans-unit id="5b79753b6512691a7580a1aa8dec230051399447" translate="yes" xml:space="preserve">
          <source>If the union is larger than the first field, the remaining bits are set to 0.</source>
          <target state="translated">ユニオンが最初のフィールドよりも大きい場合、残りのビットは0に設定されます。</target>
        </trans-unit>
        <trans-unit id="47d795dfceba0f8eb2492f885994a47e15c6743a" translate="yes" xml:space="preserve">
          <source>If the union is larger than the initialized field, the remaining bits are set to 0.</source>
          <target state="translated">ユニオンが初期化されたフィールドよりも大きい場合、残りのビットは0に設定されます。</target>
        </trans-unit>
        <trans-unit id="c1ceb76e55274ade5913babacd57bf4f1cb70312" translate="yes" xml:space="preserve">
          <source>If the user-provided size is zero or the user-provided buffer is empty, throws an &lt;code&gt;Exception&lt;/code&gt;. In case of an I/O error throws &lt;code&gt;StdioException&lt;/code&gt;.</source>
          <target state="translated">ユーザー指定のサイズがゼロであるか、ユーザー指定のバッファーが空の場合、 &lt;code&gt;Exception&lt;/code&gt; をスローします。I / Oエラーの場合、 &lt;code&gt;StdioException&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="cc7558759f1a8352a99aba9fedf7f766fc85394c" translate="yes" xml:space="preserve">
          <source>If the variable does not exist, it will be created. If it already exists, it will be overwritten.</source>
          <target state="translated">変数が存在しない場合は作成されます。既に存在する場合は上書きされます。</target>
        </trans-unit>
        <trans-unit id="1eb649b3e71267d6372924b026c8a8d1534bf07a" translate="yes" xml:space="preserve">
          <source>If the variable isn't in the environment, this function returns successfully without doing anything.</source>
          <target state="translated">変数が環境にない場合、この関数は何もせずに正常に戻ります。</target>
        </trans-unit>
        <trans-unit id="d13d09fdf461257eb1bc31ba932d5204cebf3e15" translate="yes" xml:space="preserve">
          <source>If the variadic parameter is an array of delegates with no parameters:</source>
          <target state="translated">variadic パラメータが、パラメータを持たないデリゲートの配列である場合。</target>
        </trans-unit>
        <trans-unit id="a4c2f19305902bafa0ffed68f37389b9cbdc3d33" translate="yes" xml:space="preserve">
          <source>If there are fewer arguments supplied in the</source>
          <target state="translated">で与えられる引数の数が少ない場合は</target>
        </trans-unit>
        <trans-unit id="137908701928a250c21674b47c9c08664cb6489d" translate="yes" xml:space="preserve">
          <source>If there are multiple</source>
          <target state="translated">が複数ある場合</target>
        </trans-unit>
        <trans-unit id="9d520e5d39ca368a2b272ce1cc53485c938b54ac" translate="yes" xml:space="preserve">
          <source>If there are multiple &lt;code&gt;return ref&lt;/code&gt; parameters, the lifetime of the return value is the smallest lifetime of the corresponding arguments.</source>
          <target state="translated">複数の &lt;code&gt;return ref&lt;/code&gt; パラメーターがある場合、戻り値の存続期間は、対応する引数の最小存続期間です。</target>
        </trans-unit>
        <trans-unit id="e237e9fe68b8078484793ae54d1c1e4290772666" translate="yes" xml:space="preserve">
          <source>If there are multiple UDAs in scope for a declaration, they are concatenated:</source>
          <target state="translated">宣言のスコープ内に複数のUDAがある場合、それらは連結されます。</target>
        </trans-unit>
        <trans-unit id="d33b5562bbab16d600772bb0c4e960b31c667c22" translate="yes" xml:space="preserve">
          <source>If there are multiple pragma inlines in a function, the lexically last one takes effect.</source>
          <target state="translated">関数内に複数のpragmaのインラインがある場合、辞書的に最後のものが有効になります。</target>
        </trans-unit>
        <trans-unit id="c4b327a5dc42638f7be9041ec07ceb89c1cacdad" translate="yes" xml:space="preserve">
          <source>If there are no arguments, the result is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">引数がない場合、結果は &lt;code&gt;false&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="b4600b295ae3596b41be4670d227eb72326970dd" translate="yes" xml:space="preserve">
          <source>If there are no user-defined attributes for the symbol, an empty tuple is returned. The expression tuple can be turned into a manipulatable tuple:</source>
          <target state="translated">シンボルに対するユーザー定義の属性がない場合は、空のタプルが返されます。式タプルは操作可能なタプルに変えることができます。</target>
        </trans-unit>
        <trans-unit id="e49abc2a9f1f1c709edab2a411a4d0eb933f0f8e" translate="yes" xml:space="preserve">
          <source>If there are two symbols declared, the first is the</source>
          <target state="translated">2つのシンボルが宣言されている場合、1つ目は</target>
        </trans-unit>
        <trans-unit id="3df841c41211bfc9016bcff2ddd45752571711df" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;new (&lt;/code&gt;&lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;, then those arguments are passed to the class or struct specific &lt;a href=&quot;class#allocators&quot;&gt;allocator function&lt;/a&gt; after the size argument.</source>
          <target state="translated">ある場合は &lt;code&gt;new (&lt;/code&gt; &lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentListは&lt;/i&gt;&lt;/a&gt; &lt;code&gt;)&lt;/code&gt; 、それらの引数は、クラスまたは構造体の特定に渡され&lt;a href=&quot;class#allocators&quot;&gt;アロケータ関数&lt;/a&gt; size引数の後に。</target>
        </trans-unit>
        <trans-unit id="4a441171bce481c9de8d817376b233adfcdc1d3d" translate="yes" xml:space="preserve">
          <source>If there is a constructor defined for the class, the constructor matching the argument list is called.</source>
          <target state="translated">クラスに定義されているコンストラクタがある場合、引数リストに一致するコンストラクタが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="2b9a54f4a31088d1176dc7dd4ca3c5a15fce19ea" translate="yes" xml:space="preserve">
          <source>If there is a constructor defined for the struct, the constructor matching the argument list is called.</source>
          <target state="translated">構造体に対してコンストラクタが定義されている場合、引数リストに一致するコンストラクタが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="6070235a5fc84c6102f81ad3d99d47f62b8d7355" translate="yes" xml:space="preserve">
          <source>If there is an &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;, it must evaluate to either an Object or an instance of an</source>
          <target state="translated">&lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;がある場合、それはObjectまたはのインスタンスのいずれかに評価する必要があります</target>
        </trans-unit>
        <trans-unit id="5a13d6eff463d638a1f16cd2e1b1291d41f27d35" translate="yes" xml:space="preserve">
          <source>If there is an out postcondition (see &lt;a href=&quot;contracts&quot;&gt;Contract Programming&lt;/a&gt;), that postcondition is executed after the &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; is evaluated and before the function actually returns.</source>
          <target state="translated">出力事後条件がある場合（「&lt;a href=&quot;contracts&quot;&gt;契約プログラミング&lt;/a&gt;」を参照）、その事後条件は、&lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;式&lt;/i&gt;&lt;/a&gt;が評価された後、関数が実際に戻る前に実行されます。</target>
        </trans-unit>
        <trans-unit id="f306e547fcde96fa296d39ba4173abf9b358bd47" translate="yes" xml:space="preserve">
          <source>If there is more than one &lt;code&gt;scope&lt;/code&gt; variable going out of scope at the same point, then the destructors are called in the reverse order that the variables were constructed.</source>
          <target state="translated">同じ時点でスコープ外に出る &lt;code&gt;scope&lt;/code&gt; 変数が複数ある場合は、変数が作成されたときとは逆の順序でデストラクタが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="f9d4b8b7f08b3f6307ae69aa1e6c9c14710481c3" translate="yes" xml:space="preserve">
          <source>If there is no &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; and it is not the first</source>
          <target state="translated">&lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;がなく、それが最初ではない場合</target>
        </trans-unit>
        <trans-unit id="b034aafdece95219928b4d5ae1779c324d51f861" translate="yes" xml:space="preserve">
          <source>If there is no constructor for a class, but there is a constructor for the base class, a default constructor is implicitly generated with the form:</source>
          <target state="translated">クラスのコンストラクタが存在せず、基底クラスのコンストラクタが存在する場合、デフォルトのコンストラクタが暗黙のうちにフォームで生成されます。</target>
        </trans-unit>
        <trans-unit id="8a089796c9cda4645dac5b38c15d592eebc4d1ab" translate="yes" xml:space="preserve">
          <source>If there is no default return expression and the predicate does not yield true with any test expression - &lt;code&gt;SwitchError&lt;/code&gt; is thrown. &lt;code&gt;SwitchError&lt;/code&gt; is also thrown if a void return expression was executed without throwing anything.</source>
          <target state="translated">デフォルトの戻り式がなく、述部がどのテスト式でもtrueにならない場合 &lt;code&gt;SwitchError&lt;/code&gt; がスローされます。 &lt;code&gt;SwitchError&lt;/code&gt; は、何もスローせずにvoid戻り式が実行された場合にもスローされます。</target>
        </trans-unit>
        <trans-unit id="9c729a22e9cf50dfda75e0983406587bf80017e7" translate="yes" xml:space="preserve">
          <source>If there is no documentation comment for a declaration, that declaration may not appear in the output. To ensure it does appear in the output, put an empty declaration comment for it.</source>
          <target state="translated">宣言に対するドキュメントコメントがない場合、その宣言は出力に表示されないかもしれません。出力に表示されるようにするには、空の宣言コメントを付けてください。</target>
        </trans-unit>
        <trans-unit id="6fce9903fe99732c7b1d983701bee8c33b687b65" translate="yes" xml:space="preserve">
          <source>If there is no time zone in the string, then &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt; is used. If the time zone is &quot;Z&quot;, then &lt;code&gt;UTC&lt;/code&gt; is used. Otherwise, a &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt;&lt;/a&gt; which corresponds to the given offset from UTC is used. To get the returned &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to be a particular time zone, pass in that time zone and the &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to be returned will be converted to that time zone (though it will still be read in as whatever time zone is in its string).</source>
          <target state="translated">文字列にタイムゾーンがない場合、&lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt;が使用されます。タイムゾーンが「Z」の場合、 &lt;code&gt;UTC&lt;/code&gt; が使用されます。それ以外の場合は、UTCからの特定のオフセットに対応する&lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt; &lt;/a&gt;が使用されます。返される&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;が特定のタイムゾーンになるようにするには、そのタイムゾーンを渡すと、返される&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;がそのタイムゾーンに変換されます（ただし、文字列内のタイムゾーンとして読み込まれます）。</target>
        </trans-unit>
        <trans-unit id="ecb767820c42d2c1eeab40ca9731a8e9ce9ec854" translate="yes" xml:space="preserve">
          <source>If there is no type specialization for the parameter, the type of the parameter is set to the template argument.</source>
          <target state="translated">パラメータに型の特化がない場合は、パラメータの型がテンプレート引数に設定されます。</target>
        </trans-unit>
        <trans-unit id="333c6091877decb710b52473531fc9677d023463" translate="yes" xml:space="preserve">
          <source>If there is only one member of an anonymous enum, the &lt;code&gt;{ }&lt;/code&gt; can be omitted. Gramatically speaking, this is an &lt;a href=&quot;declaration#AutoDeclaration&quot;&gt;&lt;i&gt;AutoDeclaration&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">匿名列挙のメンバーが1つしかない場合は、 &lt;code&gt;{ }&lt;/code&gt; を省略できます。&lt;a href=&quot;declaration#AutoDeclaration&quot;&gt;&lt;i&gt;文法的に&lt;/i&gt;&lt;/a&gt;は、これは&lt;i&gt;AutoDeclaration&lt;/i&gt;です。</target>
        </trans-unit>
        <trans-unit id="81c7998e55322be143bbc65f832d80e17d966603" translate="yes" xml:space="preserve">
          <source>If there's no handler for a particular error, it is handled by the runtime library default handler. If an error is ignored, it is because the programmer specifically added code to ignore an error, which presumably means it was intentional.</source>
          <target state="translated">特定のエラーに対するハンドラがない場合、ランタイムライブラリのデフォルトハンドラで処理されます。エラーが無視される場合、プログラマーがエラーを無視するためにコードを追加したためです。</target>
        </trans-unit>
        <trans-unit id="1504a8955edcaca212d8f1b4743a707d2ef9fdb6" translate="yes" xml:space="preserve">
          <source>If these constraints aren't fulfilled, the function is considered incomparable and &lt;code&gt;isSame&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">これらの制約が満たされない場合、関数は比較 &lt;code&gt;isSame&lt;/code&gt; と見なされ、isSameは &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="b28035cefdbe2f2deeefc61501ea02f89e4a353d" translate="yes" xml:space="preserve">
          <source>If they are both null, then they are equal. If one is null and the other is not, then they are not equal. If they are both non-null, then they are equal if their values are equal.</source>
          <target state="translated">両方ともnullであれば、それらは等しくなります。片方がヌルでもう片方がヌルでない場合、それらは等しくありません。両方ともnullではない場合、それらの値が等しい場合、それらは等しい。</target>
        </trans-unit>
        <trans-unit id="4662c9e57a2220461566af34d1a71bfb063d8fd6" translate="yes" xml:space="preserve">
          <source>If they compare equal, return 0 else value returned by fp.</source>
          <target state="translated">それらが等しい場合は 0 を返し、そうでない場合は fp によって返された値を返します。</target>
        </trans-unit>
        <trans-unit id="489bf198a6a75e62f83ca7fe9ee2482aa193539d" translate="yes" xml:space="preserve">
          <source>If they have range interface, formatted as input range.</source>
          <target state="translated">範囲インターフェイスを持っている場合は、入力範囲としてフォーマットされます。</target>
        </trans-unit>
        <trans-unit id="a2e48f2bb2a2bc86917d71f83c2b5a6ff9f995c9" translate="yes" xml:space="preserve">
          <source>If they have the same ptrs, return 1 else 0.</source>
          <target state="translated">同じptrを持つ場合は1を返し、そうでない場合は0を返します。</target>
        </trans-unit>
        <trans-unit id="2bac3ec55e8f026836fad11da1a5ea396ba6c7f1" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s time zone is &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt;, then TZ is empty. If its time zone is &lt;code&gt;UTC&lt;/code&gt;, then it is &quot;Z&quot;. Otherwise, it is the offset from UTC (e.g. +0100 or -0700). Note that the offset from UTC is</source>
          <target state="translated">この&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;のタイムゾーンが&lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt;である場合、TZは空です。タイムゾーンが &lt;code&gt;UTC&lt;/code&gt; の場合、「Z」です。それ以外の場合は、UTCからのオフセットです（例：+0100または-0700）。UTCからのオフセットは</target>
        </trans-unit>
        <trans-unit id="2c514f7eb520c6d91b2201391b00ffde6396be0d" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s time zone is &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt;, then TZ is empty. If its time zone is &lt;code&gt;UTC&lt;/code&gt;, then it is &quot;Z&quot;. Otherwise, it is the offset from UTC (e.g. +01:00 or -07:00). Note that the offset from UTC is</source>
          <target state="translated">この&lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt;のタイムゾーンが&lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt;である場合、TZは空です。タイムゾーンが &lt;code&gt;UTC&lt;/code&gt; の場合、「Z」です。それ以外の場合は、UTCからのオフセットです（例：+01：00または-07：00）。UTCからのオフセットは</target>
        </trans-unit>
        <trans-unit id="59b4585a3a599edf4de86352eceb935135d14f4b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Nullable&lt;/code&gt; wraps a type that already has a null value (such as a pointer), and that null value is not given for &lt;code&gt;nullValue&lt;/code&gt;, then assigning the null value to this &lt;code&gt;Nullable&lt;/code&gt; is no different than assigning any other value of type &lt;code&gt;T&lt;/code&gt;, and the resulting code will look very strange. It is strongly recommended that this be avoided by using &lt;code&gt;T&lt;/code&gt;'s &quot;built in&quot; null value for &lt;code&gt;nullValue&lt;/code&gt;.</source>
          <target state="translated">この場合は &lt;code&gt;Nullable&lt;/code&gt; 既に（例えばポインタなど）NULL値を有することタイプをラップし、そのNULL値がのために指定されていない &lt;code&gt;nullValue&lt;/code&gt; 、これにNULL値を割り当てる &lt;code&gt;Nullable&lt;/code&gt; 型の他の値に割り当てるより違いはありません &lt;code&gt;T&lt;/code&gt; を、そして結果のコードは非常に奇妙に見えます。 &lt;code&gt;nullValue&lt;/code&gt; に &lt;code&gt;T&lt;/code&gt; の「組み込み」のnull値を使用して、これを回避することを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="bacbc660925702039182b51b563933523f30696f" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Nullable&lt;/code&gt; wraps a type that already has a null value (such as a pointer), then assigning the null value to this &lt;code&gt;Nullable&lt;/code&gt; is no different than assigning any other value of type &lt;code&gt;T&lt;/code&gt;, and the resulting code will look very strange. It is strongly recommended that this be avoided by instead using the version of &lt;code&gt;Nullable&lt;/code&gt; that takes an additional &lt;code&gt;nullValue&lt;/code&gt; template argument.</source>
          <target state="translated">この場合は &lt;code&gt;Nullable&lt;/code&gt; 既に（例えばポインタなど）NULL値を持つタイプをラップし、これにNULL値を割り当てる &lt;code&gt;Nullable&lt;/code&gt; タイプの他の値に割り当てるより違いはありません &lt;code&gt;T&lt;/code&gt; を、得られたコードは非常に奇妙に見えるであろう。これは、追加の &lt;code&gt;nullValue&lt;/code&gt; テンプレート引数を取る &lt;code&gt;Nullable&lt;/code&gt; のバージョンを使用することで回避することを強くお勧めします。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
