<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="relay">
    <body>
      <group id="relay">
        <trans-unit id="330b3e499c3450d42634b5702213e434b7a82a41" translate="yes" xml:space="preserve">
          <source>Routes are responsible for defining the entry points into a Relay application. But in order to understand why routes are necessary, we must first understand the difference between GraphQL queries and fragments.</source>
          <target state="translated">ルートは、Relayアプリケーションへのエントリーポイントを定義する役割を果たします。しかし、なぜルーティングが必要なのかを理解するためには、まず GraphQL クエリとフラグメントの違いを理解する必要があります。</target>
        </trans-unit>
        <trans-unit id="ae0f139d125aa65c3494e803bdab2bfc2845048a" translate="yes" xml:space="preserve">
          <source>Routes can declare a set of parameter names that are required to be supplied to the constructor. This is also a convenient place to document the set of valid parameters.</source>
          <target state="translated">ルートは、コンストラクタに供給する必要のあるパラメータ名のセットを宣言することができます。これは、有効なパラメータのセットを文書化するのにも便利な場所です。</target>
        </trans-unit>
        <trans-unit id="e5ec9f7b8ea16c97f062b9386937889c5390bd89" translate="yes" xml:space="preserve">
          <source>Routes can use &lt;code&gt;prepareParams&lt;/code&gt; to provide default parameters, or pass through, convert or suppress passed-in parameters.</source>
          <target state="translated">ルートは、 &lt;code&gt;prepareParams&lt;/code&gt; を使用してデフォルトのパラメーターを提供したり、渡されたパラメーターをパススルー、変換、または抑制したりできます。</target>
        </trans-unit>
        <trans-unit id="a04e20b09d66a6ec94b9fd8e8520062229d58d02" translate="yes" xml:space="preserve">
          <source>Routes must declare a set of query roots using &lt;code&gt;Relay.QL&lt;/code&gt;. These queries will automatically compose a matching fragment named &lt;code&gt;queryName&lt;/code&gt; on the Relay container used with this route on a &lt;strong&gt;Relay.RootContainer&lt;/strong&gt;.</source>
          <target state="translated">ルートは、 &lt;code&gt;Relay.QL&lt;/code&gt; を使用してクエリルートのセットを宣言する必要があります。これらのクエリは、&lt;strong&gt;Relay.RootContainerの&lt;/strong&gt;このルートで使用されるリレーコンテナー上に、 &lt;code&gt;queryName&lt;/code&gt; という名前の一致するフラグメントを自動的に作成します。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fd81fc06977ad2c7156abd14b5b9caa0f8c40fc2" translate="yes" xml:space="preserve">
          <source>Routes must define a string name.</source>
          <target state="translated">ルートは文字列名を定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="380338bdec53655cfe9114fa55d7fe1d8bdbb27d" translate="yes" xml:space="preserve">
          <source>Routes no longer need to know anything about the query root in Relay Modern. Relay components can be rendered anywhere wrapped in a &lt;code&gt;QueryRenderer&lt;/code&gt;. This should bring more flexibility around picking routing frameworks.</source>
          <target state="translated">ルートはRelay Modernのクエリルートについて何も知る必要がなくなりました。リレーコンポーネントは、 &lt;code&gt;QueryRenderer&lt;/code&gt; でラップされた任意の場所にレンダリングできます。これにより、ルーティングフレームワークの選択に関する柔軟性が高まります。</target>
        </trans-unit>
        <trans-unit id="7d15dd1bec2e055c5b177c9f869305ae6c54c9bb" translate="yes" xml:space="preserve">
          <source>Routing</source>
          <target state="translated">Routing</target>
        </trans-unit>
        <trans-unit id="15f12d3d79029156026af15a57e839303e093597" translate="yes" xml:space="preserve">
          <source>Run the Relay Compiler after making changes to any GraphQL in your Relay application. It may be helpful to add it as a &lt;code&gt;yarn script&lt;/code&gt;. Add an entry to &lt;code&gt;&quot;scripts&quot;&lt;/code&gt; in your package.json file.</source>
          <target state="translated">リレーアプリケーションでGraphQLを変更した後、リレーコンパイラを実行します。 &lt;code&gt;yarn script&lt;/code&gt; として追加すると便利です。package.jsonファイルの &lt;code&gt;&quot;scripts&quot;&lt;/code&gt; にエントリを追加します。</target>
        </trans-unit>
        <trans-unit id="3c5a064ba8a60e5ab65def399ab519978d73b564" translate="yes" xml:space="preserve">
          <source>Runtime Architecture</source>
          <target state="translated">ランタイムアーキテクチャ</target>
        </trans-unit>
        <trans-unit id="b5230ecdf4e78f0dd162281a0a78c6cdc853cbe8" translate="yes" xml:space="preserve">
          <source>Schema</source>
          <target state="translated">Schema</target>
        </trans-unit>
        <trans-unit id="1f0e625b220c0a58aba2033abe91bfe01285293e" translate="yes" xml:space="preserve">
          <source>Schema JSON</source>
          <target state="translated">スキーマJSON</target>
        </trans-unit>
        <trans-unit id="114b03b7a51c1001385ac516c6fa621d46453f66" translate="yes" xml:space="preserve">
          <source>Second, any subscriptions that do have overlapping data IDs are re-read, and the new/previous results are compared. If the result has not changed, the subscription is ignored (this can occur if a field of a record changed that is not relevant to the subscription's selector), otherwise processing continues.</source>
          <target state="translated">このような場合は、そのサブスクリプションは無視されます(これは、サブスクリプションのセレクタに関連しないレコードのフィールドが変更された場合に発生する可能性があります)。結果が変更されていない場合、サブスクリプションは無視され(これは、レコードのフィールドが変更され、サブスクリプションのセレクタに関係のないものが変更された場合に発生する可能性があります)、それ以外の場合は処理が続行されます。</target>
        </trans-unit>
        <trans-unit id="3e32d234cf8a398d348341552d4472b71aa02309" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;interfaces-relay-mutation-request&quot;&gt;RelayMutationRequest&lt;/a&gt; for methods available on the argument object.</source>
          <target state="translated">引数オブジェクトで使用可能なメソッドについては、&lt;a href=&quot;interfaces-relay-mutation-request&quot;&gt;RelayMutationRequest&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="ba186dff4700bd97150240f3ab29c29fbc1b7fc5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;interfaces-relay-query-request&quot;&gt;RelayQueryRequest&lt;/a&gt; for methods available on the argument objects.</source>
          <target state="translated">引数オブジェクトで使用可能なメソッドについては、&lt;a href=&quot;interfaces-relay-query-request&quot;&gt;RelayQueryRequest&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">参照:</target>
        </trans-unit>
        <trans-unit id="0ebcd737a1bf60dbd1447977c888467e35a467a0" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#constructor&quot;&gt;GraphQLMutation &amp;gt; Constructor&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#constructor&quot;&gt;GraphQLMutation&amp;gt;コンストラクタ&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb08c52e72850acd0139ed4cb2152c144c9e58eb" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#getconfigs-abstract-method&quot;&gt;Relay.Mutation::getConfigs()&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#getconfigs-abstract-method&quot;&gt;Relay.Mutation :: getConfigs（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="51b02cf1878520658c9b88fe67978bf776e01dd9" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;api-reference-relay-mutation#getcollisionkey&quot;&gt;Relay.Mutation::getCollisionKey()&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;api-reference-relay-mutation#getcollisionkey&quot;&gt;Relay.Mutation :: getCollisionKey（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8665daeb214113b0a6222a07deb324960005a817" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;api-reference-relay-mutation#getconfigs-abstract-method&quot;&gt;Relay.Mutation::getConfigs()&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;api-reference-relay-mutation#getconfigs-abstract-method&quot;&gt;Relay.Mutation :: getConfigs（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9701bc69d708978bae12176bd6d6b49b6310b158" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-containers#relay-containers&quot;&gt;Containers &amp;gt; Relay Containers&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;guides-containers#relay-containers&quot;&gt;コンテナ&amp;gt;リレーコンテナ&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f63708739a0519c20cb04d22aed0623da8910a3b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-containers#requesting-different-data&quot;&gt;Containers &amp;gt; Requesting Different Data&lt;/a&gt;, &lt;a href=&quot;guides-ready-state&quot;&gt;Ready State&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;guides-containers#requesting-different-data&quot;&gt;コンテナ&amp;gt;異なるデータのリクエスト&lt;/a&gt;、&lt;a href=&quot;guides-ready-state&quot;&gt;準備完了状態&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb81a25d0442cce928322c7171025b8b9f41ba2d" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;Mutations &amp;gt; Fragment variables&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;突然変異&amp;gt;フラグメント変数&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="252cc9e75017b1ba4bc6a1cab81814c7c5e7b9c1" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;Mutations &amp;gt; Fragment variables&lt;/a&gt; and &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutations &amp;gt; Optimistic updates&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;ミューテーション&amp;gt;フラグメント変数&lt;/a&gt;と&lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;ミューテーション&amp;gt;オプティミスティックアップデート&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c325d76133ada9407e339b00806d08a492686a72" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#mutator-configuration&quot;&gt;Mutations &amp;gt; Mutator configuration&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;guides-mutations#mutator-configuration&quot;&gt;Mutations&amp;gt; Mutator configuration&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec1a4ead3e670cf9b7225817b2d5536e60b9dfc8" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutations &amp;gt; Optimistic Updates&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;突然変異&amp;gt;楽観的更新&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f91e5359d2e437a1fabed213a7400919e36a4e8f" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutations &amp;gt; Optimistic updates&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;突然変異&amp;gt;楽観的な更新&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a14ec07edd61e594362c3ba2c69cd02521e8cd7" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#the-fat-query&quot;&gt;Mutations &amp;gt; The fat query&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;guides-mutations#the-fat-query&quot;&gt;ミューテーション&amp;gt;ファットクエリ&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3c9e106abf2efb7313ca2aef582895208bb3b4a9" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-ready-state&quot;&gt;Ready State&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;guides-ready-state&quot;&gt;準備完了状態&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d33a51e631c54521d230f0b77c33a0ffcb95a9e" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#component-and-route&quot;&gt;Root Container &amp;gt; Component and Route&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;guides-root-container#component-and-route&quot;&gt;ルートコンテナー&amp;gt;コンポーネントとルート&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6ba9c7676225015beb8fcd0dc8154429cc521b19" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#force-fetching&quot;&gt;Root Container &amp;gt; Force Fetching&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;guides-root-container#force-fetching&quot;&gt;ルートコンテナー&amp;gt;強制フェッチ&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2d475a6214b773e645b11e09318c20c3c31900a2" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#renderfailure&quot;&gt;Root Container &amp;gt; renderFailure&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;guides-root-container#renderfailure&quot;&gt;ルートコンテナ&amp;gt; renderFailure&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="592bf7ec077fdbfb9bb08cfe9e7520a4dc086e1c" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#renderfetched&quot;&gt;Root Container &amp;gt; renderFetched&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;guides-root-container#renderfetched&quot;&gt;ルートコンテナ&amp;gt; renderFetched&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a187f3307739f3f97bdae9d053fcff505ffdeb1" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#renderloading&quot;&gt;Root Container &amp;gt; renderLoading&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;guides-root-container#renderloading&quot;&gt;ルートコンテナ&amp;gt; renderLoading&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2fcf798559587d9befe424605fcb71c2af445685" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-routes&quot;&gt;Routes&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;guides-routes&quot;&gt;ルート&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2ebcb2b8f4a703f0b6653cd4eb5e389d3a9e4f41" translate="yes" xml:space="preserve">
          <source>See our relay-compiler section in our &lt;a href=&quot;installation-and-setup#set-up-relay-compiler&quot;&gt;Installation and Setup guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;installation-and-setup#set-up-relay-compiler&quot;&gt;インストールおよびセットアップガイドの&lt;/a&gt;リレーコンパイラのセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="ac40c2c295e0947fa5d231ce927c5f063044cb9e" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;api-reference-relay-proptypes&quot;&gt;PropTypes API reference&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;api-reference-relay-proptypes&quot;&gt;PropTypes APIリファレンスを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="db3136f0089c09e6cfa1ecac38be1bb1698a01e9" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;api-reference-relay-ql&quot;&gt;Relay.QL API reference&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;api-reference-relay-ql&quot;&gt;Relay.QL APIリファレンスを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="46ebdef898489cac49931005986e50860c184084" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;api-reference-relay-store&quot;&gt;Store API reference&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;api-reference-relay-store&quot;&gt;Store APIリファレンスを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="5e868bde5bb210d570e0bf68dfd4f714decc2503" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;fragment-container#passing-arguments-to-a-fragment&quot;&gt;Fragment Container docs&lt;/a&gt; for more details.</source>
          <target state="translated">詳細については、&lt;a href=&quot;fragment-container#passing-arguments-to-a-fragment&quot;&gt;フラグメントコンテナのドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="4011d8e185ce992ad373c12339d3c386a366a9d9" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-mutations&quot;&gt;Mutations Guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;guides-mutations&quot;&gt;突然変異ガイドを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="85e710dc6095fa7ec6992d17389697e3d05b22af" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-network-layer&quot;&gt;Network Layer Guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;guides-network-layer&quot;&gt;ネットワーク層ガイドを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f586115c09169458b9424f28db540ede9b2d7ddf" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-root-container&quot;&gt;RootContainer Guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;guides-root-container&quot;&gt;RootContainer Guideを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c7e49836605664cff515afd9b044294d9e1deeee" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-routes&quot;&gt;Routes Guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;guides-routes&quot;&gt;ルートガイドを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="076a9d109c3f1a2389e316e443efa40d8f78df54" translate="yes" xml:space="preserve">
          <source>Server Error</source>
          <target state="translated">サーバーエラー</target>
        </trans-unit>
        <trans-unit id="6b17482f3f882455ee584aa25321c5bdac980242" translate="yes" xml:space="preserve">
          <source>Set up babel-plugin-relay</source>
          <target state="translated">babel-plugin-relayの設定</target>
        </trans-unit>
        <trans-unit id="8a05cf798da4421d2bd58da023c7f3fb287cd45f" translate="yes" xml:space="preserve">
          <source>Set up relay-compiler</source>
          <target state="translated">リレーコンパイラの設定</target>
        </trans-unit>
        <trans-unit id="f72f8a571d6e8bf5eec6f1a2a44a50aeba5d7932" translate="yes" xml:space="preserve">
          <source>Setting up Relay Compiler</source>
          <target state="translated">リレーコンパイラの設定</target>
        </trans-unit>
        <trans-unit id="4d8e8804be8f7d9838f29acdb1972f43499e72bb" translate="yes" xml:space="preserve">
          <source>Setting up babel-plugin-relay</source>
          <target state="translated">babel-plugin-relayの設定</target>
        </trans-unit>
        <trans-unit id="abeed86f05bd23992570bff235c3a5eea268d38d" translate="yes" xml:space="preserve">
          <source>Show More</source>
          <target state="translated">もっと見る</target>
        </trans-unit>
        <trans-unit id="c0d8810501ac79b3d67791d7c14301a445bdcd5c" translate="yes" xml:space="preserve">
          <source>Similar to how a React component's &lt;code&gt;render&lt;/code&gt; method does not directly modify native views, Relay containers do not directly fetch data. Instead, containers declare a &lt;em&gt;specification&lt;/em&gt; of the data needed to render. Relay guarantees that this data is available &lt;em&gt;before&lt;/em&gt; rendering.</source>
          <target state="translated">Reactコンポーネントの &lt;code&gt;render&lt;/code&gt; メソッドがネイティブビューを直接変更しないのと同様に、Relayコンテナーはデータを直接フェッチしません。代わりに、コンテナはレンダリングに必要なデータの&lt;em&gt;仕様&lt;/em&gt;を宣言します。リレーは&lt;em&gt;、&lt;/em&gt;レンダリング&lt;em&gt;前に&lt;/em&gt;このデータが利用可能であることを保証します。</target>
        </trans-unit>
        <trans-unit id="c15fa4b758d35cc97d9959bcc45edd294156d605" translate="yes" xml:space="preserve">
          <source>Simple Example</source>
          <target state="translated">簡単な例</target>
        </trans-unit>
        <trans-unit id="88286b84c7253d721eb28be982c48ae3b8c8564f" translate="yes" xml:space="preserve">
          <source>Simpler Mutation API</source>
          <target state="translated">よりシンプルな突然変異API</target>
        </trans-unit>
        <trans-unit id="38b269b106dd0853215c15032c144a95de107505" translate="yes" xml:space="preserve">
          <source>Since Relay containers define fragments and not queries, they can be easily embedded in multiple contexts. Like React components, Relay containers are highly reusable.</source>
          <target state="translated">Relay コンテナはクエリではなくフラグメントを定義するため、複数のコンテキストに簡単に埋め込むことができます。Reactコンポーネントと同様に、Relayコンテナは再利用性が高いです。</target>
        </trans-unit>
        <trans-unit id="eed3231995e285304e7921a2b3b7268f678be407" translate="yes" xml:space="preserve">
          <source>Since one game can have many hiding spots, we need to create a connection that we can use to link them together.</source>
          <target state="translated">1つのゲームにはたくさんの隠れ場所があるので、それらをつなげるためのつながりを作る必要があります。</target>
        </trans-unit>
        <trans-unit id="1bc4c3be89589c1b9cbd3e1e89f801487097b78c" translate="yes" xml:space="preserve">
          <source>Smaller Bundle Size</source>
          <target state="translated">バンドルサイズを小さくする</target>
        </trans-unit>
        <trans-unit id="eae26374639c4e0cc2a093a378a0ac3891ecab5b" translate="yes" xml:space="preserve">
          <source>So far we looked at the lower-level aspects of data-fetching and saw how various familiar concepts translate to GraphQL. Next, let's step back and look at some higher-level concerns that product developers often face around data-fetching:</source>
          <target state="translated">ここまでは、データフェッチの低レベルの側面を見てきましたが、様々な身近な概念がどのようにGraphQLに変換されるかを見てきました。次に、一歩下がって、製品開発者がデータフェッチに関してよく直面する、より高いレベルの懸念事項を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="d0fc3a75755e472cad5df2903a8721c7c36d0bc7" translate="yes" xml:space="preserve">
          <source>So far we're just using GraphQL as a more efficient version of typical REST approaches. Note two important benefits in the GraphQL version:</source>
          <target state="translated">今のところ、典型的なRESTアプローチのより効率的なバージョンとしてGraphQLを使用しているに過ぎません。GraphQL版には、2つの重要な利点があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d2a06967c509756a257c5cfbc8a853322fb784a3" translate="yes" xml:space="preserve">
          <source>So far we've looked at the process of querying data and keeping views up to date, but we haven't looked at writes. In GraphQL, writes are called &lt;strong&gt;mutations&lt;/strong&gt;. We can think of them as queries with side effects. Here's an example of calling a mutation that might mark a given story as being liked by the current user:</source>
          <target state="translated">ここまでは、データのクエリとビューの更新のプロセスについて説明してきましたが、書き込みについては説明していません。GraphQLでは、書き込みは&lt;strong&gt;ミュー&lt;/strong&gt;テーションと呼ばれます。これらは、副作用のあるクエリと考えることができます。これは、特定のストーリーを現在のユーザーが高く評価しているとマークするミューテーションを呼び出す例です。</target>
        </trans-unit>
        <trans-unit id="5fb4c3d88d69385cf7a448a7c57e653bef0ce88f" translate="yes" xml:space="preserve">
          <source>So far, we've covered two pieces that each contribute to declaring data:</source>
          <target state="translated">これまでに、データの宣言に貢献する2つの部分を取り上げてきました。</target>
        </trans-unit>
        <trans-unit id="647475236d1bc60d884c2b35b08e1b42225bc0f4" translate="yes" xml:space="preserve">
          <source>So for our &lt;code&gt;introduceShip&lt;/code&gt; mutation, we create two types: &lt;code&gt;IntroduceShipInput&lt;/code&gt; and &lt;code&gt;IntroduceShipPayload&lt;/code&gt;:</source>
          <target state="translated">したがって、 &lt;code&gt;introduceShip&lt;/code&gt; ミューテーションでは、 &lt;code&gt;IntroduceShipInput&lt;/code&gt; と &lt;code&gt;IntroduceShipPayload&lt;/code&gt; の 2つのタイプを作成します。</target>
        </trans-unit>
        <trans-unit id="9b153876a947507c9e895bf7e190b67952746372" translate="yes" xml:space="preserve">
          <source>So how do we use this cache? Let's look at two operations: writing to the cache when a response is received, and reading from the cache to determine if a query can be fulfilled locally (the equivalent to &lt;code&gt;_cache.has(key)&lt;/code&gt; above, but for a graph).</source>
          <target state="translated">では、このキャッシュをどのように使用するのでしょうか。2つの操作を見てみましょう。応答を受け取ったときにキャッシュに書き込むことと、キャッシュから読み取ってクエリをローカルで実行できるかどうかを判断すること &lt;code&gt;_cache.has(key)&lt;/code&gt; 上記の_cache.has（key）と同等ですが、グラフの場合）。</target>
        </trans-unit>
        <trans-unit id="ecc4d54395356b7b485a16f80a383e1e01836248" translate="yes" xml:space="preserve">
          <source>So now we know the ID of the Rebels in our system. We can now refetch them:</source>
          <target state="translated">これでシステム内の反乱軍のIDが分かった これで再検査ができる</target>
        </trans-unit>
        <trans-unit id="6a920cd8724dc921d9d4f9bdbe2e23494f550470" translate="yes" xml:space="preserve">
          <source>So on the first query for ships, GraphQL told us there was a next page, but on the next one, it told us we'd reached the end of the connection.</source>
          <target state="translated">つまり、最初の船のクエリでは、GraphQLは次のページがあると教えてくれたのですが、次のクエリでは、接続が終了したと教えてくれたのです。</target>
        </trans-unit>
        <trans-unit id="7d3d5c6eef5a80a3513fea5675a4ae9df60ad431" translate="yes" xml:space="preserve">
          <source>Some fields - especially those for paginated data - can require post-processing on the client in order to merge previously fetched data with new information. Relay Modern supports custom field handlers that can be used to process these fields to work with various pagination patterns and other use cases.</source>
          <target state="translated">フィールドの中には、特にページ分割されたデータ用のものがありますが、以前に取得したデータを新しい情報にマージするために、クライアント側で後処理が必要になる場合があります。Relay Modernは、これらのフィールドを処理するために使用できるカスタムフィールドハンドラをサポートしており、さまざまなページ分割パターンやその他のユースケースに対応しています。</target>
        </trans-unit>
        <trans-unit id="adccc4f5e80b41c5617710fc459b4ed3934af747" translate="yes" xml:space="preserve">
          <source>Sometimes a parent needs to override the default variables of a child component. Imagine that we want to render &lt;code&gt;Child&lt;/code&gt; above with a photo size of 128 instead of the default 64. To do this, we have to ensure that both the fragment &lt;em&gt;and&lt;/em&gt; the container know about the custom variable. To set a custom variable in the &lt;em&gt;query&lt;/em&gt;, use the second argument to &lt;code&gt;getFragment&lt;/code&gt;:</source>
          <target state="translated">親が子コンポーネントのデフォルト変数をオーバーライドする必要がある場合があります。上記の &lt;code&gt;Child&lt;/code&gt; をデフォルトの64ではなく128の写真サイズでレンダリングするとします。これを行うには、フラグメント&lt;em&gt;と&lt;/em&gt;コンテナの両方がカスタム変数を認識していることを確認する必要があります。&lt;em&gt;クエリ&lt;/em&gt;でカスタム変数を設定するには、2番目の引数を &lt;code&gt;getFragment&lt;/code&gt; に使用し&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="e660d20bf684b576ae81f9c3a877a8d530b581ed" translate="yes" xml:space="preserve">
          <source>Source files</source>
          <target state="translated">ソースファイル</target>
        </trans-unit>
        <trans-unit id="2d309b4d42e0ad4602d00da88f45cac2d3d11a5e" translate="yes" xml:space="preserve">
          <source>Specify the data dependencies of a `Relay.Container` as GraphQL fragments.</source>
          <target state="translated">Relay.Container` のデータ依存関係を GraphQL のフラグメントとして指定する。</target>
        </trans-unit>
        <trans-unit id="21f0a8e08151b2997828c63fbaffbc197295bb3a" translate="yes" xml:space="preserve">
          <source>Specify the mutation field in a `Relay.Mutation`.</source>
          <target state="translated">リレー.Mutation`で突然変異フィールドを指定する。</target>
        </trans-unit>
        <trans-unit id="02293aef0bd0213bc1be111d67f416c9ddf1ebdf" translate="yes" xml:space="preserve">
          <source>Specify the queries of a `Relay.Route`.</source>
          <target state="translated">リレー.ルート`のクエリを指定する。</target>
        </trans-unit>
        <trans-unit id="82c2f41708c8462a6d94834b8d39a6c652c2ac2b" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;filters&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; と &lt;code&gt;filters&lt;/code&gt; 指定：</target>
        </trans-unit>
        <trans-unit id="066b54007a4c37add5703334fe870041528f5a58" translate="yes" xml:space="preserve">
          <source>Specifying just the &lt;code&gt;key&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; だけを指定する：</target>
        </trans-unit>
        <trans-unit id="8c5f40f02b986c2adaf7800c3005c0afdbaaab33" translate="yes" xml:space="preserve">
          <source>Start converting your components and mutations to use the Relay Modern APIs from the &lt;code&gt;'react-relay/compat'&lt;/code&gt; module (&lt;code&gt;createFragmentContainer&lt;/code&gt;, &lt;code&gt;createRefetchContainer&lt;/code&gt;, &lt;code&gt;createPaginationContainer&lt;/code&gt;, &lt;code&gt;commitMutation&lt;/code&gt;). It will be easier to go from the leaf components up. The &lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;conversion scripts&lt;/a&gt; should make this step less tedious.</source>
          <target state="translated">&lt;code&gt;'react-relay/compat'&lt;/code&gt; モジュール（ &lt;code&gt;createFragmentContainer&lt;/code&gt; 、 &lt;code&gt;createRefetchContainer&lt;/code&gt; 、 &lt;code&gt;createPaginationContainer&lt;/code&gt; 、 &lt;code&gt;commitMutation&lt;/code&gt; ）からRelay Modern APIを使用するようにコンポーネントとミューテーションを変換し始めます。リーフコンポーネントから上に行く方が簡単です。&lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;変換スクリプトは&lt;/a&gt;、このステップが少なく退屈にする必要があります。</target>
        </trans-unit>
        <trans-unit id="6a5813201a4580fe5f1fbb25f1a522d4d505bf2d" translate="yes" xml:space="preserve">
          <source>Static Methods</source>
          <target state="translated">静的メソッド</target>
        </trans-unit>
        <trans-unit id="49ff3956bbd054bfbc63e2eabd2a1088f21e282f" translate="yes" xml:space="preserve">
          <source>Step 0: Install Relay v1.0</source>
          <target state="translated">ステップ0:Relay v1.0のインストール</target>
        </trans-unit>
        <trans-unit id="95c2707d7e8702851af5473310f89fd4c5bfea2a" translate="yes" xml:space="preserve">
          <source>Step 1: Incrementally convert to Relay Compat</source>
          <target state="translated">ステップ1:リレー・コンパットへのインクリメンタル変換</target>
        </trans-unit>
        <trans-unit id="d071bae177457e9183feaf0fc474e9686b0260a4" translate="yes" xml:space="preserve">
          <source>Step 2: Introduce &amp;lt;QueryRenderer&amp;gt;</source>
          <target state="translated">ステップ2：&amp;lt;QueryRenderer&amp;gt;を導入する</target>
        </trans-unit>
        <trans-unit id="8176e519a1495162afbc0b02a0cc285793d9b9e6" translate="yes" xml:space="preserve">
          <source>Step 3: Introduce Relay Modern runtime</source>
          <target state="translated">ステップ3:リレーモダンのランタイムを導入</target>
        </trans-unit>
        <trans-unit id="5465ead3d787f346532f42480c386d4eba31fbae" translate="yes" xml:space="preserve">
          <source>Step 4: Clean up by replacing Relay Compat with Relay Modern.</source>
          <target state="translated">ステップ4:Relay CompatをRelay Modernに交換してきれいにする</target>
        </trans-unit>
        <trans-unit id="0d8a7046c8d39d9cbd86abcdfb704b161a601f9e" translate="yes" xml:space="preserve">
          <source>Store</source>
          <target state="translated">Store</target>
        </trans-unit>
        <trans-unit id="aec0a8c625d33f2410286cd7972018e4c401dd0d" translate="yes" xml:space="preserve">
          <source>Store Operations</source>
          <target state="translated">店舗運営</target>
        </trans-unit>
        <trans-unit id="2e017d4c10eaa0f64c98ad2b1e9b9a9d85ad4822" translate="yes" xml:space="preserve">
          <source>Structure around mutations to make them predictable.</source>
          <target state="translated">突然変異を中心とした構造で予測可能にする</target>
        </trans-unit>
        <trans-unit id="5697fd85adbd13bf85f28712f9a136e80cc8067e" translate="yes" xml:space="preserve">
          <source>Subscriptions</source>
          <target state="translated">Subscriptions</target>
        </trans-unit>
        <trans-unit id="501433bf93135f5b327aa2f2f9a8b9652febd9e8" translate="yes" xml:space="preserve">
          <source>Support for live queries where supported by the network/server.</source>
          <target state="translated">ネットワーク/サーバーでサポートされているライブクエリのサポート。</target>
        </trans-unit>
        <trans-unit id="13a5b46568a2ea322aa7b25ac8f48a520783301a" translate="yes" xml:space="preserve">
          <source>Supported in both compat and modern mode. When using the pagination container, Relay expects the connection field to be annotated with &lt;code&gt;@connection&lt;/code&gt; directive, for more detailed information and example, please go to &lt;a href=&quot;pagination-container#connection-directive&quot;&gt;&lt;code&gt;PaginationContainer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">互換モードと最新モードの両方でサポートされています。ページネーションコンテナを使用する場合、Relayは接続フィールドに &lt;code&gt;@connection&lt;/code&gt; ディレクティブで注釈が付けられることを期待します。詳細と例については、&lt;a href=&quot;pagination-container#connection-directive&quot;&gt; &lt;code&gt;PaginationContainer&lt;/code&gt; に&lt;/a&gt;アクセスしてください。</target>
        </trans-unit>
        <trans-unit id="3ff1be67feaa88d4848ce4702f24046558ce5b24" translate="yes" xml:space="preserve">
          <source>Supported in classic, compat and modern mode. Detailed usage is explained in &lt;a href=&quot;api-reference-relay-ql#array-fields&quot;&gt;&lt;code&gt;Relay.QL&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">クラシックモード、互換モード、モダンモードでサポートされています。詳細な使用法は&lt;a href=&quot;api-reference-relay-ql#array-fields&quot;&gt; &lt;code&gt;Relay.QL&lt;/code&gt; &lt;/a&gt;で説明されています。</target>
        </trans-unit>
        <trans-unit id="65d6a8d5361414a2749b7b32500d3781b01e64c3" translate="yes" xml:space="preserve">
          <source>Sweet! Let's keep going and get the next four!</source>
          <target state="translated">いいね!このまま行って次の4つを手に入れよう!</target>
        </trans-unit>
        <trans-unit id="28e2c6a12e1af3dcd74179eb09b97b7b134beae3" translate="yes" xml:space="preserve">
          <source>Switch the &lt;code&gt;'react-relay/compat'&lt;/code&gt; references in your app to &lt;code&gt;'react-relay'&lt;/code&gt;. This is more of a clean-up step that prevents your app from pulling in unnecessary &lt;code&gt;'react-relay/classic'&lt;/code&gt; code.</source>
          <target state="translated">アプリの &lt;code&gt;'react-relay/compat'&lt;/code&gt; 参照を &lt;code&gt;'react-relay'&lt;/code&gt; 切り替えます。これは、アプリが不要な &lt;code&gt;'react-relay/classic'&lt;/code&gt; コードを引き込まないようにするためのクリーンアップ手順です。</target>
        </trans-unit>
        <trans-unit id="c64e9942fb642977fbd70ec197abeadd198f3103" translate="yes" xml:space="preserve">
          <source>Table of Contents:</source>
          <target state="translated">目次をご紹介します。</target>
        </trans-unit>
        <trans-unit id="21d278837034557e7a9b46210d42d6e7b8075142" translate="yes" xml:space="preserve">
          <source>Terminology</source>
          <target state="translated">Terminology</target>
        </trans-unit>
        <trans-unit id="3965436aa1e25eb8c1a80de5c7180c888af16646" translate="yes" xml:space="preserve">
          <source>That input argument should contain a (string) &quot;clientMutationId&quot; property for the purposes of reconciling requests and responses (automatically added by the &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; API).</source>
          <target state="translated">その入力引数には、リクエストとレスポンスを調整するための（文字列） &quot;clientMutationId&quot;プロパティが含まれている必要があります（ &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; API によって自動的に追加されます）。</target>
        </trans-unit>
        <trans-unit id="56c0a2575be8f36ad7f5d4d04acffdd56aaaf9ea" translate="yes" xml:space="preserve">
          <source>That used the &lt;code&gt;first&lt;/code&gt; argument to &lt;code&gt;ships&lt;/code&gt; to slice the result set down to the first one. But what if we wanted to paginate through it? On each edge, a cursor will be exposed that we can use to paginate. Let's ask for the first two this time, and get the cursor as well:</source>
          <target state="translated">これは、結果セットを最初のものにスライスするために &lt;code&gt;ships&lt;/code&gt; する &lt;code&gt;first&lt;/code&gt; 引数を使用しました。しかし、それをページ分割したい場合はどうでしょうか。各エッジで、ページ付けに使用できるカーソルが表示されます。今回は最初の2つを要求して、カーソルも取得します。</target>
        </trans-unit>
        <trans-unit id="cdaffd6461c67e56056afce77a9bd307eee56aef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Node&lt;/code&gt; interface and &lt;code&gt;node&lt;/code&gt; field assume globally unique IDs for this refetching. A system without globally unique IDs can usually synthesize them by combining the type with the type-specific ID, which is what was done in this example.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; インタフェースと &lt;code&gt;node&lt;/code&gt; フィールドは、この再フェッチのグローバル一意のIDを前提としています。グローバルに一意のIDを持たないシステムは、通常、タイプをタイプ固有のIDと組み合わせることによってそれらを合成できます。これは、この例で行われたものです。</target>
        </trans-unit>
        <trans-unit id="4249e055d5de1ea8000faee39fa1425b4eb71404" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Node&lt;/code&gt; interface contains a single field, &lt;code&gt;id&lt;/code&gt;, which is a &lt;code&gt;ID!&lt;/code&gt;. The &lt;code&gt;node&lt;/code&gt; root field takes a single argument, a &lt;code&gt;ID!&lt;/code&gt;, and returns a &lt;code&gt;Node&lt;/code&gt;. These two work in concert to allow refetching; if we pass the &lt;code&gt;id&lt;/code&gt; returned in that field to the &lt;code&gt;node&lt;/code&gt; field, we get the object back.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; インタフェースは、単一のフィールドが含ま &lt;code&gt;id&lt;/code&gt; で、 &lt;code&gt;ID!&lt;/code&gt; 。 &lt;code&gt;node&lt;/code&gt; ルート・フィールドは、単一の引数、取り &lt;code&gt;ID!&lt;/code&gt; 、 &lt;code&gt;Node&lt;/code&gt; を返します。これら2つは協調して動作し、再フェッチを可能にします。そのフィールドで返された &lt;code&gt;id&lt;/code&gt; &lt;code&gt;node&lt;/code&gt; フィールドに渡すと、オブジェクトが返されます。</target>
        </trans-unit>
        <trans-unit id="de66ff0a79b624dd454deb3e772e5fb7a040eb35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RecordProxy&lt;/code&gt; serves as an interface to mutate records:</source>
          <target state="translated">&lt;code&gt;RecordProxy&lt;/code&gt; はのmutateレコードへのインタフェースとして機能します。</target>
        </trans-unit>
        <trans-unit id="7b8b179aabf77ea5e811ea7880878bfdfa6368ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RecordSourceSelectorProxy&lt;/code&gt; is the type of the &lt;code&gt;store&lt;/code&gt; that &lt;a href=&quot;mutations#using-updater-and-optimisticupdater&quot;&gt;&lt;code&gt;updater&lt;/code&gt; functions&lt;/a&gt; receive as an argument. The following is the &lt;code&gt;RecordSourceSelectorProxy&lt;/code&gt; interface:</source>
          <target state="translated">&lt;code&gt;RecordSourceSelectorProxy&lt;/code&gt; は、の一種である &lt;code&gt;store&lt;/code&gt; こと&lt;a href=&quot;mutations#using-updater-and-optimisticupdater&quot;&gt; &lt;code&gt;updater&lt;/code&gt; 関数は&lt;/a&gt;、引数として受け取ります。次に、 &lt;code&gt;RecordSourceSelectorProxy&lt;/code&gt; インターフェイスを示します。</target>
        </trans-unit>
        <trans-unit id="858f5c2de227f30eaba7fc1f9d4f04ab2b8c2484" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RelayCompiler&lt;/code&gt; module is a helper class that demonstrates one way of combining these primitives. It takes IR transforms, and given IR definitions, constructs a CompilerContext from them, transforming them, and generating output artifacts intended for use with Relay runtime.</source>
          <target state="translated">&lt;code&gt;RelayCompiler&lt;/code&gt; のモジュールは、これらのプリミティブを組み合わせて1つの方法を示していヘルパークラスです。IR変換を受け取り、IR定義を指定すると、それらからCompilerContextを構築して変換し、Relayランタイムでの使用を目的とした出力アーティファクトを生成します。</target>
        </trans-unit>
        <trans-unit id="a164901ca79b8b4a2a0866d3bc8b9028a8a90acb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Store&lt;/code&gt; is the source of truth for application data and provides the following core operations.</source>
          <target state="translated">&lt;code&gt;Store&lt;/code&gt; アプリケーションデータの真理の源であり、以下のコア操作を提供します。</target>
        </trans-unit>
        <trans-unit id="69b82e1269cd3f5440edfdd8ab8e1cb4218f2a3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;applyUpdate&lt;/code&gt; adds a mutation just like &lt;code&gt;update&lt;/code&gt;, but does not commit it. It returns a &lt;code&gt;RelayMutationTransaction&lt;/code&gt; that can be committed or rollbacked.</source>
          <target state="translated">&lt;code&gt;applyUpdate&lt;/code&gt; は、同じように変異を追加 &lt;code&gt;update&lt;/code&gt; 、それをコミットしません。コミットまたはロールバックできる &lt;code&gt;RelayMutationTransaction&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="c8a27cee9d1d9abe2e77bcb0c575a4357ce66c14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;babel-relay-plugin&lt;/code&gt; must run before the &lt;code&gt;react-native&lt;/code&gt; Babel preset. Thus, in &lt;code&gt;.babelrc&lt;/code&gt;&lt;code&gt;&quot;react-native&quot;&lt;/code&gt; must come after &lt;code&gt;babelRelayPlugin&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;babel-relay-plugin&lt;/code&gt; 前に実行する必要があります &lt;code&gt;react-native&lt;/code&gt; バベルプリセット。したがって、 &lt;code&gt;.babelrc&lt;/code&gt; &lt;code&gt;&quot;react-native&quot;&lt;/code&gt; 、「react-native」は &lt;code&gt;babelRelayPlugin&lt;/code&gt; の後に来る必要があります。</target>
        </trans-unit>
        <trans-unit id="cf0346f82ced9502e9b07bb0b45a4c3bf97fc831" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;commitUpdate&lt;/code&gt; method is analogous to dispatching an action in Flux. Relay processes the mutation as follows:</source>
          <target state="translated">&lt;code&gt;commitUpdate&lt;/code&gt; 方法は、フラックス中にアクションをディスパッチに類似しています。リレーは次のように変異を処理します。</target>
        </trans-unit>
        <trans-unit id="1e1d2e828d0bd7ad1f6ddc74cb042c491b6885f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;graphql&lt;/code&gt; template tag provided by Relay serves as the mechanism to write queries, fragments, mutations or subscriptions in the &lt;a href=&quot;http://graphql.org/learn/&quot;&gt;GraphQL&lt;/a&gt; language. For example:</source>
          <target state="translated">&lt;code&gt;graphql&lt;/code&gt; リレーによって提供されるテンプレートタグにクエリ、フラグメント、変異またはサブスクリプションを書き込むための機構として&lt;a href=&quot;http://graphql.org/learn/&quot;&gt;GraphQLの&lt;/a&gt;言語。例えば：</target>
        </trans-unit>
        <trans-unit id="5916376d8984ac32cb4ef4378494b52a513ccdde" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;react-relay&lt;/code&gt; npm module includes &lt;code&gt;react&lt;/code&gt; as a &lt;em&gt;peer dependency&lt;/em&gt;. Your app should specify React as a dependency explicitly.</source>
          <target state="translated">&lt;code&gt;react-relay&lt;/code&gt; NPMモジュールは、 &lt;code&gt;react&lt;/code&gt; ように&lt;em&gt;、ピア依存&lt;/em&gt;。アプリでは、Reactを依存関係として明示的に指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="687a2b2e72c0944702e22c85dfb54906ee9cc4a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;relay-compiler&lt;/code&gt; script requires both the directory which holds your source files as well as a path to your GraphQL schema in either a .json or .graphql schema file.</source>
          <target state="translated">&lt;code&gt;relay-compiler&lt;/code&gt; スクリプトは、ソースファイルを保持しているディレクトリだけでなく、.jsonまたは.graphqlスキーマファイルのいずれかでごGraphQLスキーマへのパスの両方が必要です。</target>
        </trans-unit>
        <trans-unit id="09a465866585d4ac0fa1f3ec8871e9ae5a93fc4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;renderFailure&lt;/code&gt; callback is called with two arguments: an &lt;code&gt;Error&lt;/code&gt; object and a function to retry the request. If the error was the result of a server error communicated in the server's response, the response payload is available for inspection on &lt;code&gt;error.source&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;renderFailure&lt;/code&gt; の：コールバックは2つの引数で呼び出される &lt;code&gt;Error&lt;/code&gt; オブジェクトと、要求を再試行する機能。エラーがサーバーの応答で伝えられたサーバーエラーの結果であった場合、応答ペイロードは &lt;code&gt;error.source&lt;/code&gt; で検査できます。</target>
        </trans-unit>
        <trans-unit id="3fec68a6615738a8b02b918d7e606ef06cece0ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;renderFetched&lt;/code&gt; callback is always called with a &lt;code&gt;data&lt;/code&gt; argument, which is an object mapping from &lt;code&gt;propName&lt;/code&gt; to query data. It is expected that the &lt;code&gt;renderFetched&lt;/code&gt; callback renders the supplied &lt;code&gt;Component&lt;/code&gt; with them (e.g. using the &lt;a href=&quot;https://facebook.github.io/react/docs/jsx-spread.html&quot;&gt;JSX spread attributes feature&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;renderFetched&lt;/code&gt; コールバックは常にと呼ばれている &lt;code&gt;data&lt;/code&gt; から、オブジェクトのマッピングである引数 &lt;code&gt;propName&lt;/code&gt; クエリデータへ。 &lt;code&gt;renderFetched&lt;/code&gt; コールバックは、指定された &lt;code&gt;Component&lt;/code&gt; をそれらとともにレンダリングすることが期待されます（たとえば、&lt;a href=&quot;https://facebook.github.io/react/docs/jsx-spread.html&quot;&gt;JSXスプレッド属性機能を使用&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="fc694dd64cc47d448a84516c45884dcebf08a20c" translate="yes" xml:space="preserve">
          <source>The API is overall simpler and more predictable.</source>
          <target state="translated">APIは全体的にシンプルで予測しやすいものになっています。</target>
        </trans-unit>
        <trans-unit id="8e85966b9eda2ce8d0b649695a0687a896efc918" translate="yes" xml:space="preserve">
          <source>The Component resulting from &lt;code&gt;createFragmentContainer&lt;/code&gt; will receive the following &lt;code&gt;props&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;createFragmentContainer&lt;/code&gt; の結果であるコンポーネントは、次の &lt;code&gt;props&lt;/code&gt; を受け取ります。</target>
        </trans-unit>
        <trans-unit id="cf72a96b855224dd8974796498f53a592b116371" translate="yes" xml:space="preserve">
          <source>The Component resulting from &lt;code&gt;createPaginationContainer&lt;/code&gt; will receive the following &lt;code&gt;props&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;createPaginationContainer&lt;/code&gt; の結果であるコンポーネントは、次の &lt;code&gt;props&lt;/code&gt; を受け取ります。</target>
        </trans-unit>
        <trans-unit id="d4e8ac825308dd36be82a845d481fc8dfdffbd9f" translate="yes" xml:space="preserve">
          <source>The Component resulting from &lt;code&gt;createRefetchContainer&lt;/code&gt; will receive the following &lt;code&gt;props&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;createRefetchContainer&lt;/code&gt; の結果であるコンポーネントは、次の &lt;code&gt;props&lt;/code&gt; を受け取ります。</target>
        </trans-unit>
        <trans-unit id="a3270609e5596533f39e48f966bd5c2bc4660cc1" translate="yes" xml:space="preserve">
          <source>The DataID of the parent node that contains the connection. This argument is optional.</source>
          <target state="translated">接続を含む親ノードのDataID。この引数はオプションです。</target>
        </trans-unit>
        <trans-unit id="c4a8c9e60c4dd38c187162160297b7cec4fec7f9" translate="yes" xml:space="preserve">
          <source>The IDs we got back were base64 strings. IDs are designed to be opaque (the only thing that should be passed to the &lt;code&gt;id&lt;/code&gt; argument on &lt;code&gt;node&lt;/code&gt; is the unaltered result of querying &lt;code&gt;id&lt;/code&gt; on some object in the system), and base64ing a string is a useful convention in GraphQL to remind viewers that the string is an opaque identifier.</source>
          <target state="translated">返されたIDはbase64文字列でした。IDは不透明になるように設計されており（ &lt;code&gt;node&lt;/code&gt; の &lt;code&gt;id&lt;/code&gt; 引数に渡す必要があるのは、システム内のいくつかのオブジェクトの &lt;code&gt;id&lt;/code&gt; をクエリした結果が変更されないことだけです）、文字列をbase64化することは、GraphQLで便利な規則であり、 stringは不透明な識別子です。</target>
        </trans-unit>
        <trans-unit id="7450121d3a10cfde0d27fedec5e7487c759f4cef" translate="yes" xml:space="preserve">
          <source>The Relay &quot;Environment&quot;</source>
          <target state="translated">リレー &quot;環境&quot;</target>
        </trans-unit>
        <trans-unit id="29a5b8d00ca84a6ecf522b93deabead7921f8457" translate="yes" xml:space="preserve">
          <source>The Relay &quot;Environment&quot; bundles together the configuration, cache storage, and network-handling that Relay needs in order to operate.</source>
          <target state="translated">Relayの &quot;環境 &quot;には、Relayが動作するために必要な設定、キャッシュ・ストレージ、ネットワーク処理がまとめられています。</target>
        </trans-unit>
        <trans-unit id="04d65a89a2e8d48fa93bad9ecd0dc074fc69e421" translate="yes" xml:space="preserve">
          <source>The Relay &amp;quot;Environment&amp;quot;</source>
          <target state="translated">リレー「環境」</target>
        </trans-unit>
        <trans-unit id="ee388b82ec2168b63f7ecfa7840c723aabafb1e3" translate="yes" xml:space="preserve">
          <source>The Relay &lt;code&gt;Store&lt;/code&gt; provides an API for dispatching mutations to the server.</source>
          <target state="translated">リレー &lt;code&gt;Store&lt;/code&gt; は、サーバーにミューテーションをディスパッチするためのAPIを提供します。</target>
        </trans-unit>
        <trans-unit id="8f70d28e27ab15f03147076b8dda3030c0a0078e" translate="yes" xml:space="preserve">
          <source>The Relay Classic and Relay Compat modes produce generated content inline and may catch and log any detected GraphQL validation errors, leaving those errors to be thrown at runtime.</source>
          <target state="translated">Relay ClassicモードとRelay Compatモードでは、生成されたコンテンツをインラインで生成し、検出されたGraphQL検証エラーをキャッチしてログに記録します。</target>
        </trans-unit>
        <trans-unit id="77da780670013088b3893d46cce4bc75359e000f" translate="yes" xml:space="preserve">
          <source>The Relay Compiler fully supports client-side schema extensions, which allows you to extend the server schema by defining additional GraphQL types and fields on the client. Relay expects the client schema to be located in your &lt;code&gt;--src&lt;/code&gt; directory.</source>
          <target state="translated">リレーコンパイラは、クライアント側のスキーマ拡張を完全にサポートします。これにより、クライアントで追加のGraphQLタイプとフィールドを定義することにより、サーバースキーマを拡張できます。Relayは、クライアントスキーマが &lt;code&gt;--src&lt;/code&gt; ディレクトリにあることを想定しています。</target>
        </trans-unit>
        <trans-unit id="c019c5395f2cd9ca47232f5e8ed64fa398b7ada0" translate="yes" xml:space="preserve">
          <source>The Relay Compiler is responsible for generating code as part of a build step which can then be referenced at runtime. By building the query ahead of time, the Relay's runtime is not responsible for generating a query string, and various optimizations can be performed on the query that could be too expensive at runtime (for example, fields that are duplicated in the query can be merged during the build step, to improve efficiency of processing the GraphQL response).</source>
          <target state="translated">Relayコンパイラは、ビルドステップの一部としてコードを生成し、実行時に参照できるようにします。クエリを事前にビルドすることで、Relayのランタイムはクエリ文字列の生成を担当しないため、ランタイムではコストがかかりすぎる可能性のあるクエリに対して様々な最適化を行うことができます(例えば、クエリ内で重複しているフィールドをビルドステップ中にマージして、GraphQLレスポンスの処理効率を向上させることができます)。</target>
        </trans-unit>
        <trans-unit id="b710564e5046fb16b4d54484e5bd00a02c1c71b3" translate="yes" xml:space="preserve">
          <source>The Relay Compiler is responsible for generating code as part of a build step which, at runtime, can be used statically. By building the query ahead of time, the client's JS runtime is not responsible for generating a query string, and fields that are duplicated in the query can be merged during the build step, to improve parsing efficiency. If you have the ability to persist queries to your server, the compiler's code generation process provides a convenient time to convert a query or mutation's text into a unique identifier, which greatly reduces the upload bytes required.</source>
          <target state="translated">Relayコンパイラは、ビルド・ステップの一部としてコードを生成し、実行時に静的に使用できるようにします。クエリを事前にビルドすることで、クライアントのJSランタイムがクエリ文字列の生成を担当しなくなり、クエリ内で重複しているフィールドをビルドステップ中にマージして解析効率を向上させることができます。サーバーにクエリを永続化する機能がある場合、コンパイラのコード生成プロセスは、クエリまたは突然変異のテキストを一意の識別子に変換するのに便利な時間を提供し、必要なアップロードバイトを大幅に削減します。</target>
        </trans-unit>
        <trans-unit id="63623a8a89bd3ad461c1fe2298a373e6892186d0" translate="yes" xml:space="preserve">
          <source>The Relay Modern Core adds support for client schema extensions. These allow Relay to conveniently store some extra information with data fetched from the server and be rendered like any other field fetched from the server. This should be able to replace some use cases that previously required a Flux/Redux store on the side.</source>
          <target state="translated">Relay Modern Coreでは、クライアントスキーマ拡張機能のサポートが追加されました。これにより、Relayはサーバーから取得したデータに追加情報を便利に保存し、サーバーから取得した他のフィールドと同じようにレンダリングすることができます。これにより、これまでFLUX/Reduxのサイドストアを必要としていたいくつかのユースケースを置き換えることができるようになります。</target>
        </trans-unit>
        <trans-unit id="d7d5ac1a62f052029edc67e6900f799b310cde67" translate="yes" xml:space="preserve">
          <source>The Relay Modern packages distributed on NPM use the widely-supported ES5 version of JavaScript to support as many browser environments as possible.</source>
          <target state="translated">NPMで配布されているRelay Modernパッケージは、広くサポートされているES5版のJavaScriptを使用しており、可能な限り多くのブラウザ環境に対応しています。</target>
        </trans-unit>
        <trans-unit id="3f35b4d76fe696a95341841f45e165e3b0c6aad8" translate="yes" xml:space="preserve">
          <source>The Relay Network Layer</source>
          <target state="translated">中継ネットワーク層</target>
        </trans-unit>
        <trans-unit id="6ac0bfad74e5d02ff492fbabe1206cbc172f8a94" translate="yes" xml:space="preserve">
          <source>The Relay Store can be used to programmatically update client-side data inside &lt;a href=&quot;mutations#using-updater-and-optimisticupdater&quot;&gt;&lt;code&gt;updater&lt;/code&gt; functions&lt;/a&gt;. The following is a reference of the Relay Store interface.</source>
          <target state="translated">リレーストアを使用して、&lt;a href=&quot;mutations#using-updater-and-optimisticupdater&quot;&gt; &lt;code&gt;updater&lt;/code&gt; 関数&lt;/a&gt;内のクライアント側データをプログラムで更新できます。以下は、RelayStoreインターフェースのリファレンスです。</target>
        </trans-unit>
        <trans-unit id="d750d1085b7a107c9c036e90d472c451b5fb59af" translate="yes" xml:space="preserve">
          <source>The Relay runtime bundle is roughly 20% of the size of Relay Classic.</source>
          <target state="translated">Relayランタイムバンドルは、Relay Classicの約20%のサイズです。</target>
        </trans-unit>
        <trans-unit id="d69ab39bff551c52cbb39536496919006e7104d5" translate="yes" xml:space="preserve">
          <source>The Relay runtime is a full-featured GraphQL client that is designed for high performance even on low-end mobile devices and is capable of scaling to large, complex apps. The runtime API is not intended to be used directly in product code, but rather to provide a foundation for building higher-level product APIs such as React/Relay. This foundation includes:</source>
          <target state="translated">Relayランタイムは、ローエンドのモバイルデバイスでも高いパフォーマンスを発揮するように設計されており、大規模で複雑なアプリへの拡張が可能な、フル機能を備えたGraphQLクライアントです。ランタイムAPIは製品コードで直接使用することを目的としたものではなく、React/Relayのような高レベルの製品APIを構築するための基盤を提供することを目的としています。この基盤には以下のものが含まれます。</target>
        </trans-unit>
        <trans-unit id="a2170027015b9ca88c5f922e040a93d95772d2c0" translate="yes" xml:space="preserve">
          <source>The Relay store can be mutated programatically in advanced edge cases when optimistic updates need more granular control. The following API methods are useful for mutating your connections and fragments.</source>
          <target state="translated">楽観的な更新でより詳細な制御が必要な場合、高度なエッジケースでは、Relayストアをプログラム的に変異させることができます。以下のAPIメソッドは、接続やフラグメントを変更するのに便利です。</target>
        </trans-unit>
        <trans-unit id="0adc8d247f24c64744fe2ba30ece6da8fd08a649" translate="yes" xml:space="preserve">
          <source>The author of this story also commented on it &amp;mdash; quite common. Now imagine that some other view fetches new information about the author, and her profile photo has changed to a new URI. Here's the &lt;em&gt;only&lt;/em&gt; part of our cached data that changes:</source>
          <target state="translated">この物語の作者もそれにコメントしました-非常に一般的です。ここで、他のビューが作成者に関する新しい情報をフェッチし、彼女のプロフィール写真が新しいURIに変更されたとします。ここだ&lt;em&gt;だけ&lt;/em&gt;変更し、当社のキャッシュされたデータの一部は：</target>
        </trans-unit>
        <trans-unit id="980a4b6788111d51d4fd5d3c6e5054ad267e5ae0" translate="yes" xml:space="preserve">
          <source>The best way to get started right now is to take a look at how these three parts come together to form a working example. The tutorial on the next page will lead you through an example application, using the &lt;a href=&quot;https://github.com/facebook/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt;, to give you an idea of how you can start using Relay on yours.</source>
          <target state="translated">今すぐ始めるための最良の方法は、これらの3つの部分がどのように組み合わさって実際の例を形成するかを確認することです。次のページのチュートリアルでは、&lt;a href=&quot;https://github.com/facebook/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt;を使用したサンプルアプリケーションを紹介し、Relayの使用を開始する方法を示します。</target>
        </trans-unit>
        <trans-unit id="5bc022d566f4b68dd38c73222756f331714be645" translate="yes" xml:space="preserve">
          <source>The client and server are decoupled: the client specifies the data needed instead of &lt;em&gt;relying on&lt;/em&gt; the server endpoint to return the correct data.</source>
          <target state="translated">クライアントとサーバーは分離されています。クライアントは、正しいデータを返すためにサーバーのエンドポイントに&lt;em&gt;依存するので&lt;/em&gt;はなく、必要なデータを指定します。</target>
        </trans-unit>
        <trans-unit id="859e2dd0a260c19654088e28b4f5cf103b3156ab" translate="yes" xml:space="preserve">
          <source>The compiler is a set of modules designed to extract GraphQL documents from across a codebase, transform/optimize them, and generate build artifacts. Examples of common types of artifacts include optimized GraphQL to persist to your server, runtime representations of the queries for use with GraphQL clients such as the Relay runtime, or generated source code for use with GraphQL frameworks for compiled languages (Java/Swift/etc).</source>
          <target state="translated">コンパイラは、コードベース全体からGraphQLドキュメントを抽出し、変換/最適化し、ビルド成果物を生成するように設計されたモジュールのセットです。一般的な成果物の例としては、サーバに永続化するように最適化された GraphQL、Relay ランタイムなどの GraphQL クライアントで使用するためのクエリのランタイム表現、コンパイルされた言語 (Java/Swift/etc)用の GraphQL フレームワークで使用するために生成されたソースコードなどがあります。</target>
        </trans-unit>
        <trans-unit id="aa42964754dbecedd42dff5df9fe665b9c4e7306" translate="yes" xml:space="preserve">
          <source>The compiler module is composed of a set of core building blocks as well as a helper that packages them together in an easy to use API. Some of the main data types and modules in the compiler are as follows:</source>
          <target state="translated">コンパイラー・モジュールは、コア・ビルディング・ブロックのセットと、それらを使いやすい API でパッケージ化するヘルパーで構成されています。コンパイラの主なデータ型とモジュールは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="00a902f03306b6ea1e1e2818025625742f4e212c" translate="yes" xml:space="preserve">
          <source>The component-based approach of React Router v4 does not readily allow for aggregating the data requirements for nested routes, and as such does not readily permit an approach that will avoid request waterfalls from nesting &lt;code&gt;QueryRenderer&lt;/code&gt; components.</source>
          <target state="translated">React Router v4のコンポーネントベースのアプローチでは、ネストされたルートのデータ要件を簡単に集約できません。そのため、リクエストウォーターフォールが &lt;code&gt;QueryRenderer&lt;/code&gt; コンポーネントをネストしないようにするアプローチは簡単には許可されません。</target>
        </trans-unit>
        <trans-unit id="7298679167473c58332d417e6d2bd4de9988163d" translate="yes" xml:space="preserve">
          <source>The container &amp;mdash; named &lt;code&gt;Relay(ProfilePicture)&lt;/code&gt; for debugging &amp;mdash; will retrieve the response for each GraphQL fragment from the local store.</source>
          <target state="translated">コンテナ &lt;code&gt;Relay(ProfilePicture)&lt;/code&gt; デバッグ用にRelay（ProfilePicture）という名前）は、ローカルストアから各GraphQLフラグメントの応答を取得します。</target>
        </trans-unit>
        <trans-unit id="d147ef4301d6fa557024d99f96f08a499bbc3a4a" translate="yes" xml:space="preserve">
          <source>The container passes the results of each fragment (along with the other props) to the &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; component.</source>
          <target state="translated">コンテナーは、各フラグメントの結果を（他のプロップと共に） &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; コンポーネントに渡します。</target>
        </trans-unit>
        <trans-unit id="268b06824cede0c427a01e0d80dbe18daf1354c3" translate="yes" xml:space="preserve">
          <source>The default implementation is as follows:</source>
          <target state="translated">デフォルトの実装は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="bf32b3124e1516fba4edb1784393b843530e0823" translate="yes" xml:space="preserve">
          <source>The defaults we specify here will become available to our fragment builders:</source>
          <target state="translated">ここで指定したデフォルト値は、フラグメントビルダーが利用できるようになります。</target>
        </trans-unit>
        <trans-unit id="fe89d1880c282b0f84f7ad747dcf711ed35e9199" translate="yes" xml:space="preserve">
          <source>The easiest way to get started for now is with the &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt; - this includes an example schema file and configures the &lt;a href=&quot;https://www.npmjs.com/package/babel-relay-plugin&quot;&gt;&lt;code&gt;babel-relay-plugin&lt;/code&gt;&lt;/a&gt; npm module to transpile queries.</source>
          <target state="translated">とりあえず開始する最も簡単な方法は、&lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt;を使用することです。これにはサンプルスキーマファイルが含まれ、クエリをトランスパイルするように&lt;a href=&quot;https://www.npmjs.com/package/babel-relay-plugin&quot;&gt; &lt;code&gt;babel-relay-plugin&lt;/code&gt; &lt;/a&gt; npmモジュールを構成します。</target>
        </trans-unit>
        <trans-unit id="0041bb913fb29f03cef5bab2b320b6add29c71a8" translate="yes" xml:space="preserve">
          <source>The example above did not configure a &lt;code&gt;handlerProvider&lt;/code&gt;, which means that a default one will be provided. Relay Modern comes with a built-in handler that augment the core with special functionality for handling connections (which is not a standard GraphQL feature, but a set of pagination conventions used at Facebook, specified in detail in the &lt;a href=&quot;https://relay.dev/graphql/connections.htm&quot;&gt;Relay Cursor Connections Specification&lt;/a&gt;, and well-supported by Relay itself).</source>
          <target state="translated">上記の例では、 &lt;code&gt;handlerProvider&lt;/code&gt; を構成していません。これは、デフォルトのものが提供されることを意味します。Relay Modernには、接続を処理するための特別な機能（標準のGraphQL機能ではありませんが、Facebookで使用される一連のページ付け規則であり、&lt;a href=&quot;https://relay.dev/graphql/connections.htm&quot;&gt;Relay Cursor Connections Specification&lt;/a&gt;で詳細に指定されています）でコアを拡張する組み込みハンドラーが付属しています。 -リレー自体でサポートされています）。</target>
        </trans-unit>
        <trans-unit id="ef9027831057a9dfdeaac970a51f94ff44007267" translate="yes" xml:space="preserve">
          <source>The example above did not configure a &lt;code&gt;handlerProvider&lt;/code&gt;, which means that a default one will be provided. Relay Modern comes with a couple of built-in handlers that augment the core with special functionality for handling connections (which is not a standard GraphQL feature, but a set of pagination conventions used at Facebook, specified in detail in the &lt;a href=&quot;graphql-connections&quot;&gt;Relay Cursor Connections Specification&lt;/a&gt;, and well-supported by Relay itself) and the &lt;code&gt;viewer&lt;/code&gt; field (again, not a standard GraphQL schema feature, but one which has been conventionally used extensively within Facebook).</source>
          <target state="translated">上記の例では、 &lt;code&gt;handlerProvider&lt;/code&gt; を構成していません。つまり、デフォルトのものが提供されます。 Relay Modernには、接続を処理するための特別な機能（標準のGraphQL機能ではなく、&lt;a href=&quot;graphql-connections&quot;&gt;Relay Cursor Connections Specification&lt;/a&gt;で詳細に指定されているFacebookで使用されるページ付け規則のセット）でコアを強化する2つの組み込みハンドラーが付属しています。そして、Relay自体によって十分にサポートされています）および &lt;code&gt;viewer&lt;/code&gt; フィールド（これも、標準のGraphQLスキーマ機能ではありませんが、従来Facebook内で広く使用されている機能です）。</target>
        </trans-unit>
        <trans-unit id="4657e52da9059d7f3c2e9423e8542337bf25d573" translate="yes" xml:space="preserve">
          <source>The example above is very similar to the classic container API, but in the modern API we can just pass the &lt;code&gt;graphql&lt;/code&gt; template literal directly as the second argument. Relay will infer the prop name from the fragment name according to the fragment naming convention &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt;. The example below is equivalent to the one above:</source>
          <target state="translated">上記の例は、クラシックコンテナーAPIによく似ていますが、最新のAPIでは、 &lt;code&gt;graphql&lt;/code&gt; テンプレートリテラルを2番目の引数として直接渡すことができます。リレーは、フラグメントの命名規則 &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; に従って、フラグメント名からプロップ名を推測します。以下の例は、上記の例と同等です。</target>
        </trans-unit>
        <trans-unit id="1d30073e8f5f3cb9668f92d3d480a82b915306f9" translate="yes" xml:space="preserve">
          <source>The fat query</source>
          <target state="translated">太ったクエリ</target>
        </trans-unit>
        <trans-unit id="9eb6dbc6b6ef5c5d8b4847ee0b1b967260b02889" translate="yes" xml:space="preserve">
          <source>The field name in the response that contains the DataID of the deleted node</source>
          <target state="translated">削除されたノードのDataIDを含むレスポンスのフィールド名</target>
        </trans-unit>
        <trans-unit id="3ca688eaa1e1f955641e421703e810ed047c2005" translate="yes" xml:space="preserve">
          <source>The field name in the response that contains the DataID of the removed node, or the path to the node removed from the connection</source>
          <target state="translated">レスポンス内のフィールド名で、削除されたノードのDataID、または接続から削除されたノードへのパスを含みます。</target>
        </trans-unit>
        <trans-unit id="ba191931e9ab489b27a9f33f746bef212888dc1a" translate="yes" xml:space="preserve">
          <source>The field name in the response that represents the connection</source>
          <target state="translated">接続を表すレスポンスのフィールド名</target>
        </trans-unit>
        <trans-unit id="a1b90e077151b889c8402ab5f53851a0ff440462" translate="yes" xml:space="preserve">
          <source>The field name in the response that represents the newly created edge</source>
          <target state="translated">新しく作成されたエッジを表すレスポンスのフィールド名</target>
        </trans-unit>
        <trans-unit id="f9886e317b707740faab57f9ea8a72831a041943" translate="yes" xml:space="preserve">
          <source>The field name in the response that represents the parent of the connection</source>
          <target state="translated">接続の親を表すレスポンスのフィールド名。</target>
        </trans-unit>
        <trans-unit id="9edac1a03bde2552ba82cb38e1a432234c65b349" translate="yes" xml:space="preserve">
          <source>The final data declaration is equivalent to the following plain GraphQL:</source>
          <target state="translated">最終的なデータ宣言は、以下のプレーンGraphQLと同等です。</target>
        </trans-unit>
        <trans-unit id="cfe19d046a9f42c5d948f0aa018690d7ab173c0c" translate="yes" xml:space="preserve">
          <source>The first query was for a list of stories:</source>
          <target state="translated">最初の問い合わせは、ネタの羅列でした。</target>
        </trans-unit>
        <trans-unit id="097faf4942075ea29d235eddd8bf227710e8b427" translate="yes" xml:space="preserve">
          <source>The function returns a &lt;code&gt;Disposable&lt;/code&gt; on which you could call &lt;code&gt;dispose()&lt;/code&gt; to cancel the refetch.</source>
          <target state="translated">この関数は、 &lt;code&gt;dispose()&lt;/code&gt; を呼び出して再フェッチをキャンセルできる &lt;code&gt;Disposable&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="74925f12cc72e89c1f9fb2151f85c26276ebca60" translate="yes" xml:space="preserve">
          <source>The function returns a &lt;code&gt;Promise&lt;/code&gt; that resolves with an object containing data obtained from the query.</source>
          <target state="translated">この関数は、クエリから取得したデータを含むオブジェクトで解決する &lt;code&gt;Promise&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="84ecd22bdcea1bdfd0329a697bfab6ff7e6e06a6" translate="yes" xml:space="preserve">
          <source>The high-level flow of data through the compiler is represented in the following diagram:</source>
          <target state="translated">コンパイラを介した高レベルのデータの流れを次の図に示します。</target>
        </trans-unit>
        <trans-unit id="0d313c5be837c1f0e863c8d541edf651d250cb38" translate="yes" xml:space="preserve">
          <source>The initial set of variable values available to this component's fragments.</source>
          <target state="translated">このコンポーネントのフラグメントで利用可能な変数値の初期セット。</target>
        </trans-unit>
        <trans-unit id="f7e74d01f7e6ff80db2700d9894a53e56b4a4d76" translate="yes" xml:space="preserve">
          <source>The most-used function is &lt;a href=&quot;#createcontainer-static-method&quot;&gt;&lt;code&gt;createContainer()&lt;/code&gt;&lt;/a&gt; which wraps components with data declarations.</source>
          <target state="translated">最も使用される関数は、データ宣言でコンポーネントをラップする&lt;a href=&quot;#createcontainer-static-method&quot;&gt; &lt;code&gt;createContainer()&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="6618aeb6f5361bcac94a3181ad8b6a8339b0abc1" translate="yes" xml:space="preserve">
          <source>The mutation should take a single argument named &quot;input&quot;.</source>
          <target state="translated">突然変異は、&quot;input &quot;という名前の単一の引数を取らなければなりません。</target>
        </trans-unit>
        <trans-unit id="a3c29d0940ced0048c0feb3200ee57be78138845" translate="yes" xml:space="preserve">
          <source>The new Relay Modern core is more light-weight and significantly faster than the previous version. It is redesigned to work with static queries, which allow us to push more work to build/compilation time. The Modern core is much smaller as a result of removing a lot of the complex features required for dynamic queries. The new core is also an order of magnitude faster in processing the response with an optimized parsing instruction set that is generated at build time. We no longer keep around tracking information needed for dynamic query generation, which drastically reduces the memory overhead of using Relay. This means more memory is left for making the UI feel responsive. Relay Modern also supports persisted queries, reducing the upload size of the request from the full query text to a simple id.</source>
          <target state="translated">新しいRelay Modernコアは、前バージョンよりも軽量化され、大幅に高速化されています。静的なクエリで動作するように再設計されているため、より多くの作業をビルド/コンパイル時間に押し込めるようになっています。ダイナミッククエリに必要な複雑な機能の多くを削除した結果、Modernコアは大幅に小型化されました。新しいコアは、ビルド時に生成される最適化された解析命令セットを使用してレスポンスを処理する際にも、桁違いに速くなっています。動的クエリの生成に必要なトラッキング情報を保持しておく必要がなくなり、Relayを使用する際のメモリオーバーヘッドが大幅に削減されました。つまり、UIの応答性を向上させるために、より多くのメモリを確保できるということです。Relay Modernは永続クエリもサポートしており、リクエストのアップロードサイズを完全なクエリテキストからシンプルなidに削減しています。</target>
        </trans-unit>
        <trans-unit id="bfe2b2be8025972db06fd439006437e8dca5cc49" translate="yes" xml:space="preserve">
          <source>The next logical approach is to use &lt;code&gt;render()&lt;/code&gt; as the means of initiating data-fetching. We could simply render the application once, see what data it needed, fetch that data, and render again. This sounds great, but the problem is that &lt;em&gt;components use data to figure out what to render!&lt;/em&gt; In other words, this would force data-fetching to be staged: first render the root and see what data it needs, then render its children and see what they need, all the way down the tree. If each stage incurs network request, rendering would require slow, serial roundtrips. We needed a way to determine all the data needs up-front or &lt;em&gt;statically&lt;/em&gt;.</source>
          <target state="translated">次の論理的なアプローチは、データのフェッチを開始する手段として &lt;code&gt;render()&lt;/code&gt; を使用することです。アプリケーションを一度レンダリングして、必要なデータを確認し、そのデータをフェッチして、再度レンダリングするだけです。これはすばらしいように聞こえますが、問題は&lt;em&gt;コンポーネントがデータを使用して何をレンダリングするかを理解することです！&lt;/em&gt;言い換えると、これによりデータフェッチが強制的にステージングされます。最初にルートをレンダリングして必要なデータを確認し、次にその子をレンダリングして必要なものをツリー全体で確認します。各ステージでネットワーク要求が発生した場合、レンダリングには低速のシリアルラウンドトリップが必要になります。すべてのデータのニーズを&lt;em&gt;事前&lt;/em&gt;または&lt;em&gt;静的&lt;/em&gt;に判断する方法が必要でした。</target>
        </trans-unit>
        <trans-unit id="5b53cde5515b59c4d3a0131621b4782b7479a272" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;config&lt;/code&gt; parameter can be used to configure a &lt;code&gt;RANGE_ADD&lt;/code&gt; or other type of mutation, as per the &lt;code&gt;Relay.Mutation&lt;/code&gt; API. This tells Relay how to process the response.</source>
          <target state="translated">オプションの &lt;code&gt;config&lt;/code&gt; パラメータが設定するために使用することができます &lt;code&gt;RANGE_ADD&lt;/code&gt; あたりとして、または変異の他のタイプを &lt;code&gt;Relay.Mutation&lt;/code&gt; の API。これは、Relayに応答を処理する方法を伝えます。</target>
        </trans-unit>
        <trans-unit id="3043696978b404d79349bb97fe99dc6847323bfb" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;config&lt;/code&gt; parameter can be used to configure a &lt;code&gt;RANGE_ADD&lt;/code&gt; or other type of mutation, similar to the &lt;code&gt;Relay.Mutation&lt;/code&gt; API.</source>
          <target state="translated">オプションの &lt;code&gt;config&lt;/code&gt; パラメータを設定するために使用することができます &lt;code&gt;RANGE_ADD&lt;/code&gt; かに類似の変異の他のタイプ、 &lt;code&gt;Relay.Mutation&lt;/code&gt; の APIを。</target>
        </trans-unit>
        <trans-unit id="a65fc26cbbecf69c5a0fe03882c96f57450485e1" translate="yes" xml:space="preserve">
          <source>The options listed above are not exhaustive. If you are aware of other routing solutions that work well with Relay Modern, &lt;a href=&quot;https://github.com/facebook/relay/issues/new&quot;&gt;please let us know&lt;/a&gt;.</source>
          <target state="translated">上記のオプションは完全ではありません。Relay Modernで適切に機能する他のルーティングソリューションをご存知の場合は、&lt;a href=&quot;https://github.com/facebook/relay/issues/new&quot;&gt;お知らせください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e4e5487396fd07e7501191686f068ec10dba2a30" translate="yes" xml:space="preserve">
          <source>The pagination container expects the connection field to be annotated with a &lt;code&gt;@connection(key: ...)&lt;/code&gt; directive, where the &lt;code&gt;key&lt;/code&gt; is expected to be a unique identifier under the parent field type &lt;code&gt;User&lt;/code&gt;. A good practice could be &lt;code&gt;&amp;lt;ComponentName&amp;gt;_&amp;lt;fieldName | fieldAlias&amp;gt;&lt;/code&gt;. By default, Relay generates storage key based on the user-supplied &lt;code&gt;key&lt;/code&gt; and all non-filter variables of the field. Relay also provides an advanced feature &lt;code&gt;@connection(key: 'FriendsList_friends', filters:['orderBy', ...])&lt;/code&gt; that allows you to explicitly specify which variables should be used to generate the storage key. Particularly, if you write &lt;code&gt;@connection(key: ..., filters:[])&lt;/code&gt;, Relay will ignore all the variables.</source>
          <target state="translated">ページ設定コンテナは、接続フィールドに &lt;code&gt;@connection(key: ...)&lt;/code&gt; ディレクティブで注釈が付けられることを想定してい &lt;code&gt;key&lt;/code&gt; は、親フィールドタイプ &lt;code&gt;User&lt;/code&gt; の下の一意の識別子であることが想定されています。良い練習は可能性があり &lt;code&gt;&amp;lt;ComponentName&amp;gt;_&amp;lt;fieldName | fieldAlias&amp;gt;&lt;/code&gt; 。デフォルトでは、Relayはユーザー指定の &lt;code&gt;key&lt;/code&gt; とフィールドのすべての非フィルター変数に基づいてストレージキーを生成します。 Relay には、ストレージキーの生成に使用する変数を明示的に指定できる高度な機能 &lt;code&gt;@connection(key: 'FriendsList_friends', filters:['orderBy', ...])&lt;/code&gt; も用意されています。特に、 &lt;code&gt;@connection(key: ..., filters:[])&lt;/code&gt; と書いた場合、Relayはすべての変数を無視します。</target>
        </trans-unit>
        <trans-unit id="c30fe4d3ed3c530120fea7a2dc37c47a35768d8b" translate="yes" xml:space="preserve">
          <source>The plugin needs to understand your schema - &lt;code&gt;schemaData&lt;/code&gt; in the above snippet. There are two ways to get this information, depending on the GraphQL implementation.</source>
          <target state="translated">プラグインはスキーマを理解する必要があります- 上記のスニペットの &lt;code&gt;schemaData&lt;/code&gt; 。GraphQLの実装に応じて、この情報を取得する方法は2つあります。</target>
        </trans-unit>
        <trans-unit id="486acc4ff0b4938f682801c80ee8b2d7dd1df93e" translate="yes" xml:space="preserve">
          <source>The premise of the example is that we want to use GraphQL to query for information about ships and factions in the original Star Wars trilogy.</source>
          <target state="translated">この例の前提として、オリジナルのスター・ウォーズ3部作に登場する船や派閥に関する情報をGraphQLを使ってクエリしたいと考えています。</target>
        </trans-unit>
        <trans-unit id="1d83274a567a8154b4431388aa9d20ca339eaa3b" translate="yes" xml:space="preserve">
          <source>The primary way to declare data requirements is via &lt;code&gt;Relay.Container&lt;/code&gt; &amp;mdash; a higher-order React component that lets React components encode their data requirements.</source>
          <target state="translated">データ要件を宣言する主な方法は、 &lt;code&gt;Relay.Container&lt;/code&gt; &amp;mdash; Reactコンポーネントがデータ要件をエンコードできるようにする高次のReactコンポーネントを使用することです。</target>
        </trans-unit>
        <trans-unit id="808db6b1b18bc85b64f9d26f1bddf44bf5968046" translate="yes" xml:space="preserve">
          <source>The primary way to declare data requirements is via &lt;code&gt;createFragmentContainer&lt;/code&gt; &amp;mdash; a higher-order React component that lets React components encode their data requirements.</source>
          <target state="translated">データ要件を宣言する主な方法は、 &lt;code&gt;createFragmentContainer&lt;/code&gt; &amp;mdash; Reactコンポーネントがデータ要件をエンコードできるようにする高次のReactコンポーネントを使用することです。</target>
        </trans-unit>
        <trans-unit id="444774c5f652cc1826eed622e4a92e2c3f0e2e4b" translate="yes" xml:space="preserve">
          <source>The properties and methods listed below can be accessed on &lt;code&gt;this.props.relay&lt;/code&gt; from the wrapped React component.</source>
          <target state="translated">下記のプロパティとメソッドは、ラップされたReactコンポーネントから &lt;code&gt;this.props.relay&lt;/code&gt; でアクセスできます。</target>
        </trans-unit>
        <trans-unit id="e0742e86024158a29e56877db07e441903db2b90" translate="yes" xml:space="preserve">
          <source>The purpose of the &lt;code&gt;@connection&lt;/code&gt; directive is to allow Relay to uniquely identify different connections under a parent type. The &lt;code&gt;@connection&lt;/code&gt; directive takes 2 arguments that help identify the connection:</source>
          <target state="translated">&lt;code&gt;@connection&lt;/code&gt; ディレクティブの目的は、Relayが親タイプの下のさまざまな接続を一意に識別できるようにすることです。 &lt;code&gt;@connection&lt;/code&gt; のディレクティブは助けが接続を識別するという2つの引数を取ります。</target>
        </trans-unit>
        <trans-unit id="f9c7cfc24fbe1b8654256e17573b27f7600de24e" translate="yes" xml:space="preserve">
          <source>The query and response are traversed together, extracting the results into &lt;code&gt;Record&lt;/code&gt; objects which are added to a fresh &lt;code&gt;RecordSource&lt;/code&gt;.</source>
          <target state="translated">クエリと応答が一緒にトラバースされ、結果が &lt;code&gt;Record&lt;/code&gt; オブジェクトに抽出され、新しい &lt;code&gt;RecordSource&lt;/code&gt; に追加されます。</target>
        </trans-unit>
        <trans-unit id="6fb555f6bd692507da566c1e62919372415cf8fc" translate="yes" xml:space="preserve">
          <source>The query is fetched from the network.</source>
          <target state="translated">クエリはネットワークから取得されます。</target>
        </trans-unit>
        <trans-unit id="595d44efe5adb2587c5aa09916b466fe64246e19" translate="yes" xml:space="preserve">
          <source>The query should request &quot;clientMutationId&quot; as a subselection.</source>
          <target state="translated">クエリは、サブセレクションとして &quot;clientMutationId &quot;を要求する必要があります。</target>
        </trans-unit>
        <trans-unit id="fcd6ab3548bb5d3b4f5a6f857ba30959f05237cb" translate="yes" xml:space="preserve">
          <source>The reasoning is that if &lt;code&gt;babel-plugin-relay&lt;/code&gt; does not run before the &lt;code&gt;es2015-template-literals&lt;/code&gt; transform, it will not transform the Relay.QL template literals correctly. Also in Babel 6, you can&amp;rsquo;t control plugin order. So in React Native, where plugins in &lt;code&gt;.babelrc&lt;/code&gt; are loaded before the projects &lt;code&gt;.babelrc&lt;/code&gt;, it&amp;rsquo;s impossible to use the Babel Relay Plugin without overriding the entire transform list.</source>
          <target state="translated">推論は、 &lt;code&gt;es2015-template-literals&lt;/code&gt; 変換の前に &lt;code&gt;babel-plugin-relay&lt;/code&gt; が実行されない場合、Relay.QLテンプレートリテラルを正しく変換しないためです。また、Babel 6ではプラグインの順序を制御できません。そのため、 &lt;code&gt;.babelrc&lt;/code&gt; のプラグインがプロジェクト &lt;code&gt;.babelrc&lt;/code&gt; の前にロードされるReact Nativeでは、変換リスト全体をオーバーライドしないとBabel Relayプラグインを使用できません。</target>
        </trans-unit>
        <trans-unit id="e29f8bf44ff95dd21005f2f7bb6eccf4ec45e350" translate="yes" xml:space="preserve">
          <source>The result of using the &lt;code&gt;graphql&lt;/code&gt; template tag is a &lt;code&gt;GraphQLTaggedNode&lt;/code&gt;; a runtime representation of the GraphQL document which can be used to define &lt;a href=&quot;query-renderer&quot;&gt;Query Renderers&lt;/a&gt;, &lt;a href=&quot;fragment-container&quot;&gt;Fragment Containers&lt;/a&gt;, &lt;a href=&quot;refetch-container&quot;&gt;Refetch Containers&lt;/a&gt;, &lt;a href=&quot;pagination-container&quot;&gt;Pagination Containers&lt;/a&gt;, etc.</source>
          <target state="translated">&lt;code&gt;graphql&lt;/code&gt; テンプレートタグを使用した結果は &lt;code&gt;GraphQLTaggedNode&lt;/code&gt; です。&lt;a href=&quot;query-renderer&quot;&gt;クエリレンダラー&lt;/a&gt;、&lt;a href=&quot;fragment-container&quot;&gt;フラグメントコンテナー&lt;/a&gt;、&lt;a href=&quot;refetch-container&quot;&gt;リフェッチコンテナー&lt;/a&gt;、&lt;a href=&quot;pagination-container&quot;&gt;ページ&lt;/a&gt;ネーションコンテナーなどを定義するために使用できるGraphQLドキュメントのランタイム表現。</target>
        </trans-unit>
        <trans-unit id="7803dad9067c5d50b3b4bf3ebacbfaade89ec277" translate="yes" xml:space="preserve">
          <source>The runtime automatically removes cached data that is no longer referenced, helping to reduce memory usage.</source>
          <target state="translated">ランタイムは、参照されなくなったキャッシュされたデータを自動的に削除し、メモリ使用量の削減に役立ちます。</target>
        </trans-unit>
        <trans-unit id="7502725bdbb2c17f80ff460d7924092be097b33c" translate="yes" xml:space="preserve">
          <source>The schema described below will be used to demonstrate the functionality that a GraphQL server used by Relay should implement. The two core types are a faction and a ship in the Star Wars universe, where a faction has many ships associated with it. The schema below is the output of the GraphQL.js &lt;a href=&quot;https://github.com/graphql/graphql-js/blob/master/src/utilities/schemaPrinter.js&quot;&gt;&lt;code&gt;schemaPrinter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">以下で説明するスキーマは、Relayで使用されるGraphQLサーバーが実装する機能を示すために使用されます。2つのコアタイプは、派閥とスターウォーズユニバースの船で、派閥には多数の船が関連付けられています。以下のスキーマは、GraphQL.js &lt;a href=&quot;https://github.com/graphql/graphql-js/blob/master/src/utilities/schemaPrinter.js&quot;&gt; &lt;code&gt;schemaPrinter&lt;/code&gt; の&lt;/a&gt;出力です。</target>
        </trans-unit>
        <trans-unit id="d1f4549e3c6f019d48ff8e76296ba821ef51f0c7" translate="yes" xml:space="preserve">
          <source>The second query refetched the information for one of those stories:</source>
          <target state="translated">2番目のクエリは、それらの物語の1つの情報を再設定しました。</target>
        </trans-unit>
        <trans-unit id="c7be7ec56f48de687831bf1d2b8ec095a4494b09" translate="yes" xml:space="preserve">
          <source>The set of IR documents forms a CompilerContext, which is then transformed and optimized.</source>
          <target state="translated">IR ドキュメントのセットは CompilerContext を形成し、変換と最適化が行われます。</target>
        </trans-unit>
        <trans-unit id="e1ce127879727af2e2de7fc1ce77bce3c4f43c30" translate="yes" xml:space="preserve">
          <source>The solution to caching GraphQL is to normalize the hierarchical response into a flat collection of &lt;strong&gt;records&lt;/strong&gt;. Relay implements this cache as a map from IDs to records. Each record is a map from field names to field values. Records may also link to other records (allowing it to describe a cyclic graph), and these links are stored as a special value type that references back into the top-level map. With this approach each server record is stored &lt;em&gt;once&lt;/em&gt; regardless of how it is fetched.</source>
          <target state="translated">GraphQLをキャッシュする解決策は、階層的な応答を&lt;strong&gt;レコードの&lt;/strong&gt;フラットなコレクションに正規化することです。Relayは、このキャッシュをIDからレコードへのマップとして実装します。各レコードは、フィールド名からフィールド値へのマップです。レコードは他のレコードにリンクすることもでき（循環グラフを記述できるようにします）、これらのリンクはトップレベルのマップを参照する特別な値タイプとして保存されます。このアプローチでは、フェッチ方法に関係なく、各サーバーレコードが&lt;em&gt;一度&lt;/em&gt;保存されます。</target>
        </trans-unit>
        <trans-unit id="2238db3c2972a72399f41299cdb2bb500270de90" translate="yes" xml:space="preserve">
          <source>The term &amp;lsquo;variables&amp;rsquo; here refers to the input to the server-side mutation, &lt;strong&gt;not&lt;/strong&gt; to the variables made available to this mutation's fragment builders.</source>
          <target state="translated">ここで「変数」という用語は、サーバーサイドミューテーションへの入力を指し、このミューテーションのフラグメントビルダーが利用できるようにする変数を指すのではあり&lt;strong&gt;ません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="595203acdb212fda1237b7e11b4700b733a663ad" translate="yes" xml:space="preserve">
          <source>The three core assumptions that Relay makes about a GraphQL server are that it provides:</source>
          <target state="translated">RelayがGraphQLサーバについての3つの核心的な前提として挙げているのは、「提供する」ということです。</target>
        </trans-unit>
        <trans-unit id="80a872fa92f56ed5c31e04d7d32ff502b8f3fab1" translate="yes" xml:space="preserve">
          <source>The two methods differ in that instead of sending a query that includes only fields missing from the client, &lt;code&gt;forceFetch&lt;/code&gt; sends a request to refetch each and every fragment. This ensures that the props for the component are freshly fetched from the server.</source>
          <target state="translated">2つのメソッドは、クライアントから欠落しているフィールドのみを含むクエリを送信する代わりに、 &lt;code&gt;forceFetch&lt;/code&gt; がすべてのフラグメントを再フェッチするリクエストを送信するという点で異なります。これにより、コンポーネントのプロパティがサーバーから新たにフェッチされます。</target>
        </trans-unit>
        <trans-unit id="1c4c5b50dcdfa847760bbbedcf52cb8e2ff536e6" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;photo&lt;/code&gt; field has changed; and therefore the record &lt;code&gt;2&lt;/code&gt; has also changed. And that's it. Nothing else in the &lt;em&gt;cache&lt;/em&gt; is affected. But clearly our &lt;em&gt;view&lt;/em&gt; needs to reflect the update: both instances of the author in the UI (as story author and comment author) need to show the new photo.</source>
          <target state="translated">&lt;code&gt;photo&lt;/code&gt; フィールドの値が変更されました。したがって、レコード &lt;code&gt;2&lt;/code&gt; も変更されています。以上です。&lt;em&gt;キャッシュ&lt;/em&gt;内の他のものは影響を受けません。ただし、&lt;em&gt;ビューに&lt;/em&gt;は更新を反映する必要があります。UI内の作成者の両方のインスタンス（ストーリー作成者およびコメント作成者として）は、新しい写真を表示する必要があります。</target>
        </trans-unit>
        <trans-unit id="1232b961ddf31ef587aaa3e408f8aa3d44030a8f" translate="yes" xml:space="preserve">
          <source>Then after making edits to your application files, just run &lt;code&gt;yarn run relay&lt;/code&gt; to generate new files, or &lt;code&gt;yarn run relay -- --watch&lt;/code&gt; to run the compiler as a long-lived process which automatically generates new files whenever you save.</source>
          <target state="translated">次に、アプリケーションファイルを編集した後、 &lt;code&gt;yarn run relay&lt;/code&gt; を実行して新しいファイルを生成するか、 &lt;code&gt;yarn run relay -- --watch&lt;/code&gt; を実行して、保存するたびに新しいファイルを自動的に生成する長期間有効なプロセスとしてコンパイラーを実行します。</target>
        </trans-unit>
        <trans-unit id="ef73d50cc222b2377dc0c600080db66496266f2f" translate="yes" xml:space="preserve">
          <source>Then after making edits to your application files, run &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql&lt;/code&gt; to generate new files, or &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql --watch&lt;/code&gt; to run the compiler as a long-lived process which automatically generates new files whenever you save.</source>
          <target state="translated">次に、アプリケーションファイルを編集した後、 &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql&lt;/code&gt; を実行して新しいファイルを生成するか、 &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql --watch&lt;/code&gt; は、保存するたびに新しいファイルを自動的に生成する長期間有効なプロセスとしてコンパイラを実行します。</target>
        </trans-unit>
        <trans-unit id="57a1f5033c269a68bc8794dc199b363a5c20cf8b" translate="yes" xml:space="preserve">
          <source>Then run &lt;code&gt;yarn run relay&lt;/code&gt; as set up before.</source>
          <target state="translated">次に、前に設定した &lt;code&gt;yarn run relay&lt;/code&gt; を実行します。</target>
        </trans-unit>
        <trans-unit id="45b952755c02df6dff5e78f4c86d5e7d04e71f78" translate="yes" xml:space="preserve">
          <source>Then, add &lt;code&gt;&quot;relay&quot;&lt;/code&gt; to the list of plugins in your .babelrc file. For example:</source>
          <target state="translated">次に、.babelrcファイルのプラグインのリストに &lt;code&gt;&quot;relay&quot;&lt;/code&gt; を追加します。例えば：</target>
        </trans-unit>
        <trans-unit id="fa043b2e7bb17a1863151534669a087d81a912d9" translate="yes" xml:space="preserve">
          <source>There are a variety of solutions for keeping views up to date with a flattened cache. The approach that Relay takes is to maintain a mapping from each UI view to the set of IDs it references. In this case, the story view would subscribe to updates on the story (&lt;code&gt;1&lt;/code&gt;), the author (&lt;code&gt;2&lt;/code&gt;), and the comments (&lt;code&gt;3&lt;/code&gt; and any others). When writing data into the cache, Relay tracks which IDs are affected and notifies &lt;em&gt;only&lt;/em&gt; the views that are subscribed to those IDs. The affected views re-render, and unaffected views opt-out of re-rendering for better performance (Relay provides a safe but effective default &lt;code&gt;shouldComponentUpdate&lt;/code&gt;). Without this strategy, every view would re-render for even the tiniest change.</source>
          <target state="translated">フラット化されたキャッシュを使用してビューを最新の状態に保つためのさまざまなソリューションがあります。 Relayが採用するアプローチは、各UIビューから参照する一連のIDへのマッピングを維持することです。この場合、ストーリービューは、ストーリー（ &lt;code&gt;1&lt;/code&gt; ）、作成者（ &lt;code&gt;2&lt;/code&gt; ）、コメント（ &lt;code&gt;3&lt;/code&gt; およびその他）の更新をサブスクライブします。キャッシュにデータを書き込むとき、Relayは影響を受けるIDを追跡し、それらのIDにサブスクライブしているビュー&lt;em&gt;のみ&lt;/em&gt;に通知します。影響を受けるビューは再レンダリングされ、影響を受けないビューはパフォーマンスを向上させるために再レンダリングをオプトアウトします（リレーは安全ですが効果的なデフォルトの &lt;code&gt;shouldComponentUpdate&lt;/code&gt; を提供します）。この戦略がなければ、すべてのビューがごくわずかな変化でも再レンダリングされます。</target>
        </trans-unit>
        <trans-unit id="19964f32b18bdaa18426e6241372ad8f6c37030a" translate="yes" xml:space="preserve">
          <source>There is currently only one supported way to set the initial value of a variable dynamically: using global variables defined on the query that includes the fragment (or via &lt;code&gt;variables&lt;/code&gt; on the &lt;code&gt;QueryRenderer&lt;/code&gt;).</source>
          <target state="translated">現在、変数の初期値を動的に設定するためにサポートされている方法は1つだけです。フラグメントを含むクエリで定義されたグローバル変数を使用する（または &lt;code&gt;QueryRenderer&lt;/code&gt; の &lt;code&gt;variables&lt;/code&gt; を使用する）。</target>
        </trans-unit>
        <trans-unit id="9d42709663369aca59bb9f2ca4e4c05e806c0bb6" translate="yes" xml:space="preserve">
          <source>Therefore a typical data flow is as follows - note that this flow is managed automatically by higher-level APIs such as React/Relay. First a component will lookup the results of a selector against a record source (e.g. the store's canonical source):</source>
          <target state="translated">したがって、典型的なデータフローは以下のようになります-このフローはReact/Relayなどの高レベルAPIによって自動的に管理されていることに注意してください。最初に、コンポーネントはレコードソース(ストアの正規ソースなど)に対してセレクタの結果を検索します。</target>
        </trans-unit>
        <trans-unit id="7009a3cd68807292f00dff361667a386bda72fff" translate="yes" xml:space="preserve">
          <source>Therefore, a normalized response cache for GraphQL requires processing payloads and queries in parallel. For example, the &lt;code&gt;photo&lt;/code&gt; field from above might be cached with a generated field name such as &lt;code&gt;photo_size(32)&lt;/code&gt; in order to uniquely identify the field and its argument values.</source>
          <target state="translated">したがって、GraphQLの正規化された応答キャッシュでは、ペイロードとクエリを並行して処理する必要があります。たとえば、上記の &lt;code&gt;photo&lt;/code&gt; フィールドは、フィールドとその引数値を一意に識別するために、 &lt;code&gt;photo_size(32)&lt;/code&gt; などの生成されたフィールド名でキャッシュされる場合があります。</target>
        </trans-unit>
        <trans-unit id="046164a952e067900ed0105204b38b9650fcea6c" translate="yes" xml:space="preserve">
          <source>These are the methods and properties that the container will provide as &lt;code&gt;this.props.relay&lt;/code&gt; in the plain React component.</source>
          <target state="translated">これらは、プレーンなReactコンポーネントの &lt;code&gt;this.props.relay&lt;/code&gt; としてコンテナーが提供するメソッドとプロパティです。</target>
        </trans-unit>
        <trans-unit id="5c8268547e740fb58d6875a6309af54d22de03e8" translate="yes" xml:space="preserve">
          <source>These features can be used in a couple of common scenarios: logging the client state for later inspection or interactively poking around the store from your browser's debugger.</source>
          <target state="translated">これらの機能はいくつかの一般的なシナリオで使用することができます:クライアントの状態を後で検査するためにログに記録したり、ブラウザのデバッガからインタラクティブにストアを覗いたりすることができます。</target>
        </trans-unit>
        <trans-unit id="1195afffc2435cbe5e7dac1ec74b6de7550b1719" translate="yes" xml:space="preserve">
          <source>Thinking In Relay</source>
          <target state="translated">リレーで考える</target>
        </trans-unit>
        <trans-unit id="9e48341865426d82a3f397c5e1d57bc38bb5c5ba" translate="yes" xml:space="preserve">
          <source>Thinking in GraphQL</source>
          <target state="translated">グラフQLで考える</target>
        </trans-unit>
        <trans-unit id="587e48e73d1fbcb3548410dad36aa1874f0eaaf5" translate="yes" xml:space="preserve">
          <source>This callback prop is called as the various events of data resolution occur.</source>
          <target state="translated">このコールバックプロップは、データ解決の様々なイベントが発生したときに呼び出されます。</target>
        </trans-unit>
        <trans-unit id="83089afd24bef13575f73fb96b2667f2399b79e8" translate="yes" xml:space="preserve">
          <source>This callback prop is called as the various events of data resolution occurs.</source>
          <target state="translated">このコールバックプロップは、データ解決の様々なイベントが発生した際に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="a79b5038ef8c2e765648d6ba19aa3760d3f3486d" translate="yes" xml:space="preserve">
          <source>This can be upgraded by conditionally rendering a &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt; which will load the data once it is rendered. The code overhead of doing this is dramatically reduced with the new API.</source>
          <target state="translated">これは、データがレンダリングされるとデータをロードする&lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt;を条件付きでレンダリングすることによってアップグレードできます。これを行うコードオーバーヘッドは、新しいAPIで劇的に削減されます。</target>
        </trans-unit>
        <trans-unit id="6aa6b4ce32c479ca8e376d46b66428bac2d82d69" translate="yes" xml:space="preserve">
          <source>This can be upgraded by using a &lt;a href=&quot;refetch-container&quot;&gt;&lt;code&gt;RefetchContainer&lt;/code&gt;&lt;/a&gt; which allows you to specify the exact query to use to fetch the new data.</source>
          <target state="translated">これは、新しいデータをフェッチするために使用する正確なクエリを指定できる&lt;a href=&quot;refetch-container&quot;&gt; &lt;code&gt;RefetchContainer&lt;/code&gt; &lt;/a&gt;を使用してアップグレードできます。</target>
        </trans-unit>
        <trans-unit id="0fa24150c2aafefe95a09ecc07832206180f13d5" translate="yes" xml:space="preserve">
          <source>This causes a generated file to appear in &lt;code&gt;./__generated__/MyComponent.graphql&lt;/code&gt;, with both runtime artifacts (which help to read and write from the Relay Store) and &lt;a href=&quot;https://flow.org/&quot;&gt;Flow types&lt;/a&gt; to help you write type-safe code.</source>
          <target state="translated">これにより、生成されたファイルが &lt;code&gt;./__generated__/MyComponent.graphql&lt;/code&gt; に表示され、ランタイムアーティファクト（リレーストアからの読み取りと書き込みに役立ちます）と&lt;a href=&quot;https://flow.org/&quot;&gt;フロータイプがタイプ&lt;/a&gt;セーフコードの記述に役立ちます。</target>
        </trans-unit>
        <trans-unit id="a9ea7bef6484a7c1cbe254ffda535079f7700daf" translate="yes" xml:space="preserve">
          <source>This document, together with &lt;a href=&quot;runtime-architecture&quot;&gt;Runtime Architecture&lt;/a&gt; and &lt;a href=&quot;compiler-architecture&quot;&gt;Compiler Architecture&lt;/a&gt;, describes the high-level architecture of Relay &quot;Modern&quot;. The intended audience includes developers interested in contributing to Relay, developers hoping to utilize the building blocks of Relay to create higher-level APIs, and anyone interested in understanding more about Relay internals. For developers wanting to learn more about &lt;em&gt;using&lt;/em&gt; Relay to build products, the other sections might be more helpful.</source>
          <target state="translated">このドキュメントでは、&lt;a href=&quot;runtime-architecture&quot;&gt;ランタイムアーキテクチャ&lt;/a&gt;と&lt;a href=&quot;compiler-architecture&quot;&gt;コンパイラアーキテクチャ&lt;/a&gt;とともに、リレー「モダン」の高レベルのアーキテクチャについて説明します。対象読者には、Relayへの貢献に関心のある開発者、Relayのビルディングブロックを利用して高レベルのAPIを作成することを望んでいる開発者、Relayの内部についての理解に関心のある人が含まれます。Relayを&lt;em&gt;使用&lt;/em&gt;して製品を構築する方法について詳しく知りたい開発者にとっては、他のセクションの方が役立つ場合があります。</target>
        </trans-unit>
        <trans-unit id="74dbf4caec721ba1ccc2a6b88d7ee594184d8bbc" translate="yes" xml:space="preserve">
          <source>This example demonstrates all three of these assumptions.</source>
          <target state="translated">この例では、これらの3つの前提条件をすべて示しています。</target>
        </trans-unit>
        <trans-unit id="9479e9ba5c11bcfea7c69c38843fdeb8dbbdfea5" translate="yes" xml:space="preserve">
          <source>This example is not comprehensive, but it is designed to quickly introduce these core assumptions, to provide some context before diving into the more detailed specification of the library.</source>
          <target state="translated">この例は包括的なものではありませんが、ライブラリのより詳細な仕様に飛び込む前に、これらのコアとなる仮定を素早く導入し、ある程度の文脈を提供するように設計されています。</target>
        </trans-unit>
        <trans-unit id="f185525936893aacea00cf71a3224c86985f3df6" translate="yes" xml:space="preserve">
          <source>This fat query looks like any other GraphQL query, with one important distinction. We know some of these fields to be non-scalar (like &lt;code&gt;friendEdge&lt;/code&gt; and &lt;code&gt;friends&lt;/code&gt;) but notice that we have not named any of their children by way of a subquery. In this way, we indicate to Relay that &lt;em&gt;anything&lt;/em&gt; under those non-scalar fields may change as a result of this mutation.</source>
          <target state="translated">このファットクエリは、他のGraphQLクエリと似ていますが、重要な違いが1つあります。これらのフィールドの一部は非スカラーであることはわかっていますが（ &lt;code&gt;friendEdge&lt;/code&gt; や &lt;code&gt;friends&lt;/code&gt; など）、サブクエリを使用してそれらの子に名前を付けていないことに注意してください。この方法で、これらの非スカラーフィールドの下にあるものは&lt;em&gt;すべて&lt;/em&gt;、この突然変異の結果として変更される可能性があることをリレーに示します。</target>
        </trans-unit>
        <trans-unit id="81b1261e20f66bafeb445251ddc3d3efb2158432" translate="yes" xml:space="preserve">
          <source>This fresh &lt;code&gt;RecordSource&lt;/code&gt; would then be published to the store:</source>
          <target state="translated">次に、この新しい &lt;code&gt;RecordSource&lt;/code&gt; がストアに公開されます。</target>
        </trans-unit>
        <trans-unit id="61564f3549d718187ddfeb22e3808eafa802c07e" translate="yes" xml:space="preserve">
          <source>This gets converted into a &quot;lazy&quot; require of a generated file:</source>
          <target state="translated">これは、生成されたファイルの「遅延」要求に変換されます。</target>
        </trans-unit>
        <trans-unit id="ea59f490525a696053dec758108ce2a68882aa64" translate="yes" xml:space="preserve">
          <source>This gets converted into an immediately-invoked function:</source>
          <target state="translated">これは即効性のある機能に変換されます。</target>
        </trans-unit>
        <trans-unit id="01abddd8ac86ef6eb75568464191008b4ca72daa" translate="yes" xml:space="preserve">
          <source>This installs the bin script &lt;code&gt;relay-compiler&lt;/code&gt; in your node_modules folder. It's recommended to run this from a yarn/npm script by adding a script to your &lt;code&gt;package.json&lt;/code&gt; file:</source>
          <target state="translated">これにより、binスクリプト &lt;code&gt;relay-compiler&lt;/code&gt; がnode_modulesフォルダーにインストールされます。 &lt;code&gt;package.json&lt;/code&gt; ファイルにスクリプトを追加して、yarn / npmスクリプトからこれを実行することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="11a6b3482924983de73327e990f1793b755a9291" translate="yes" xml:space="preserve">
          <source>This is a specialization of the general-purpose refetch container that is tailored for the common scenario of paginating through a collection of items by fetching successively more pages of data. See &lt;a href=&quot;pagination-container&quot;&gt;&lt;code&gt;createPaginationContainer&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">これは、より多くのページのデータを連続してフェッチすることによってアイテムのコレクションをページ分割するという一般的なシナリオに合わせて調整された、汎用の再フェッチコンテナーの特殊化です。詳細については、&lt;a href=&quot;pagination-container&quot;&gt; &lt;code&gt;createPaginationContainer&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d4db8c43d3a16c260f2c767a658dfa356471e9a7" translate="yes" xml:space="preserve">
          <source>This is an array of events received so far (see &lt;code&gt;ReadyStateEvent&lt;/code&gt; below).</source>
          <target state="translated">これは、これまでに受信したイベントの配列です（以下の &lt;code&gt;ReadyStateEvent&lt;/code&gt; を参照）。</target>
        </trans-unit>
        <trans-unit id="4d0129df19cfd202bd9745fb3f722df875299901" translate="yes" xml:space="preserve">
          <source>This is an instance of &lt;code&gt;Error&lt;/code&gt; if there is a failure. Otherwise, this is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">これは、 &lt;code&gt;Error&lt;/code&gt; が発生した場合のエラーのインスタンスです。それ以外の場合、これは &lt;code&gt;null&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="69752386ee76a26381a40e623b5c2ca8480c36c2" translate="yes" xml:space="preserve">
          <source>This is only a simple example: in reality the cache must handle one-to-many associations and pagination (among other things).</source>
          <target state="translated">これは単純な例に過ぎません:実際にはキャッシュは一対多の関連付けとページ分割を処理しなければなりません (他のものとの間で)。</target>
        </trans-unit>
        <trans-unit id="7b3c087bb51f2da841015c33dcb71977fe0212c4" translate="yes" xml:space="preserve">
          <source>This is the general constructor for creating &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; instances with optional &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;callbacks&lt;/code&gt; and &lt;code&gt;collisionKey&lt;/code&gt; arguments.</source>
          <target state="translated">これは、オプションの &lt;code&gt;files&lt;/code&gt; 、 &lt;code&gt;callbacks&lt;/code&gt; 、 &lt;code&gt;collisionKey&lt;/code&gt; 引数を使用して &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; インスタンスを作成するための一般的なコンストラクターです。</target>
        </trans-unit>
        <trans-unit id="ab97009210eccb9f3d5c90eae312fb3cfd66a060" translate="yes" xml:space="preserve">
          <source>This is the lowest level of abstraction at which product code may deal with mutations in Relay, and it corresponds to the mutation operation (&quot;a write followed by a fetch&quot;) described in &lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;the GraphQL Specification&lt;/a&gt;. You specify the mutation, the inputs, and the query.</source>
          <target state="translated">これは、製品コードがRelayのミュー&lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;テーションを&lt;/a&gt;処理できる最低レベルの抽象化であり、GraphQL仕様で説明されているミューテーション操作（「書き込みとそれに続くフェッチ」）に対応しています。ミューテーション、入力、クエリを指定します。</target>
        </trans-unit>
        <trans-unit id="71da35a87d2df91e0c17e3a05dce16632307fd68" translate="yes" xml:space="preserve">
          <source>This is true when &lt;em&gt;all&lt;/em&gt; data requirements are ready for rendering.</source>
          <target state="translated">これは、&lt;em&gt;すべての&lt;/em&gt;データ要件がレンダリングの準備ができている場合に当てはまります。</target>
        </trans-unit>
        <trans-unit id="bb078cd30db73d188c6edca1d054b3822d3838fd" translate="yes" xml:space="preserve">
          <source>This is true when the subset of data required for rendering is ready.</source>
          <target state="translated">これは、レンダリングに必要なデータのサブセットが準備できている場合に真です。</target>
        </trans-unit>
        <trans-unit id="12c08d7a8f7eb77071004758dca7ab969bb7d7cb" translate="yes" xml:space="preserve">
          <source>This is where GraphQL comes into play. Components specify one or multiple GraphQL fragments for some of their props describing their data requirements. Each GraphQL fragment has a unique name within an application which allows us to determine the query needed to fetch the full query tree in a build step and load all the required data in a single network request efficiently at runtime.</source>
          <target state="translated">ここでGraphQLの出番です。コンポーネントは、データ要件を記述した小道具の一部に対して、1つまたは複数の GraphQL フラグメントを指定します。各 GraphQL フラグメントにはアプリケーション内で一意の名前が付けられているため、ビルドステップでクエリツリー全体をフェッチするために必要なクエリを決定し、実行時に単一のネットワークリクエストで必要なすべてのデータを効率的にロードすることができます。</target>
        </trans-unit>
        <trans-unit id="40d6df25c7774cfef7c19fa68f7bcd72dbf71d40" translate="yes" xml:space="preserve">
          <source>This may be helpful to reduce redundant fragments when dealing with nested or recursive data within a single Component.</source>
          <target state="translated">これは、単一のコンポーネント内でネストされたデータや再帰的なデータを扱う際に、冗長なフラグメントを減らすのに役立つかもしれません。</target>
        </trans-unit>
        <trans-unit id="7d2596643eab3080985621c3e255ffe66dd1fb15" translate="yes" xml:space="preserve">
          <source>This method can optionally return a promise in order to facilitate proper error propagation.</source>
          <target state="translated">このメソッドは、適切なエラーの伝播を容易にするために、オプションでプロミスを返すことができます。</target>
        </trans-unit>
        <trans-unit id="a5a0085a036246ce072609380ef834dd25b9e599" translate="yes" xml:space="preserve">
          <source>This method is also called after the partial set of variables from &lt;code&gt;setVariables&lt;/code&gt; has been applied. The variables returned are used to populate the fragments.</source>
          <target state="translated">このメソッドは、 &lt;code&gt;setVariables&lt;/code&gt; からの変数の部分セットが適用された後にも呼び出されます。返された変数は、フラグメントを生成するために使用されます。</target>
        </trans-unit>
        <trans-unit id="0603bfcf101a33a1c1eed64335628df20ea3aa9c" translate="yes" xml:space="preserve">
          <source>This method receives an array of queries (instead of a single query) in order to facilitate batching queries to improve network efficiency.</source>
          <target state="translated">このメソッドは、ネットワーク効率を向上させるためにクエリのバッチ処理を容易にするために、(単一のクエリではなく)クエリの配列を受信します。</target>
        </trans-unit>
        <trans-unit id="a87ccc42db63f2f52eeae29ff4feceb34933d42f" translate="yes" xml:space="preserve">
          <source>This should be upgraded to use a &lt;a href=&quot;pagination-container&quot;&gt;&lt;code&gt;PaginationContainer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pagination-container&quot;&gt; &lt;code&gt;PaginationContainer&lt;/code&gt; &lt;/a&gt;を使用するには、これをアップグレードする必要があります。</target>
        </trans-unit>
        <trans-unit id="a7bf020a941d10f70ab32528d56d8597a05d0895" translate="yes" xml:space="preserve">
          <source>This snippet configures &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; to render &lt;code&gt;ProfilePicture&lt;/code&gt; within a &lt;code&gt;ScrollView&lt;/code&gt; component as soon as data is ready.</source>
          <target state="translated">このスニペットは、データの準備ができるとすぐに &lt;code&gt;ScrollView&lt;/code&gt; コンポーネント内で &lt;code&gt;ProfilePicture&lt;/code&gt; をレンダリングするように&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;を構成します。</target>
        </trans-unit>
        <trans-unit id="70500d59ecc10d7cea4a148a7386cb41d2c4d0f0" translate="yes" xml:space="preserve">
          <source>This snippet configures &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; to render the &quot;Loading...&quot; text whenever it needs to fetch data.</source>
          <target state="translated">このスニペットは、&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;がデータをフェッチする必要があるときに「Loading ...」テキストをレンダリングするように構成します。</target>
        </trans-unit>
        <trans-unit id="00b1b28bd3be2fa7e76055fd5d3f672dc5d7fda8" translate="yes" xml:space="preserve">
          <source>This will create a series of &lt;code&gt;__generated__&lt;/code&gt; directories that are co-located with the corresponding files containing &lt;code&gt;graphql&lt;/code&gt; tags.</source>
          <target state="translated">これにより、 &lt;code&gt;graphql&lt;/code&gt; タグを含む対応するファイルと同じ場所に配置される一連の &lt;code&gt;__generated__&lt;/code&gt; ディレクトリが作成されます。</target>
        </trans-unit>
        <trans-unit id="a737ccc7b583949623cef676beba937c7dc28a69" translate="yes" xml:space="preserve">
          <source>This will inform &lt;code&gt;Relay.QL&lt;/code&gt; that this particular field is an array. This will also allow you to use a plural name for the fragment (i.e. &lt;code&gt;bars&lt;/code&gt; instead of &lt;code&gt;bar&lt;/code&gt;).</source>
          <target state="translated">これにより、 &lt;code&gt;Relay.QL&lt;/code&gt; に、この特定のフィールドが配列であることを通知します。これはまた、フラグメントのために複数の名前（つまり、使用できるようになります &lt;code&gt;bars&lt;/code&gt; の代わりに、 &lt;code&gt;bar&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2dcccc952811069ad73564d196e2e6f3b0ec664d" translate="yes" xml:space="preserve">
          <source>This would produce three generated files, and two &lt;code&gt;__generated__&lt;/code&gt; directories:</source>
          <target state="translated">これにより、3つの生成ファイルと2つの &lt;code&gt;__generated__&lt;/code&gt; ディレクトリが生成されます。</target>
        </trans-unit>
        <trans-unit id="0e7c9a4f20eb8494e45f8c514abfa27440507df5" translate="yes" xml:space="preserve">
          <source>To add a new paginating relay container</source>
          <target state="translated">新しいページングリレーコンテナを追加するには</target>
        </trans-unit>
        <trans-unit id="4afe3d419de5a0a7685601e4998733289b1a991a" translate="yes" xml:space="preserve">
          <source>To add a new relay container</source>
          <target state="translated">新しいリレーコンテナを追加するには</target>
        </trans-unit>
        <trans-unit id="da88d2c6beb30dbb3f7e5c35d288e84155365752" translate="yes" xml:space="preserve">
          <source>To add a new relay container that has changing data requirements</source>
          <target state="translated">データ要件が変更された新しいリレーコンテナを追加するには</target>
        </trans-unit>
        <trans-unit id="b78283d8fe106afc67ec588e2762311c4df0a3bd" translate="yes" xml:space="preserve">
          <source>To add a new root for relay components</source>
          <target state="translated">リレー部品の新しいルートを追加するには</target>
        </trans-unit>
        <trans-unit id="2cb466b85716cc24434b2a68c68d7668bbaceabb" translate="yes" xml:space="preserve">
          <source>To call this method on the underlying component, first provide a &lt;code&gt;componentRef&lt;/code&gt; function to the Relay container. This differs from providing a &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/a&gt; function which would provide a reference to the Relay container itself, not the underlying React Component.</source>
          <target state="translated">基礎となるコンポーネントでこのメソッドを呼び出すには、最初に、relayコンテナに &lt;code&gt;componentRef&lt;/code&gt; 関数を提供します。これは、基になるReactコンポーネントではなく、リレーコンテナー自体への参照を提供する&lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt; &lt;code&gt;ref&lt;/code&gt; &lt;/a&gt;関数を提供することとは異なります。</target>
        </trans-unit>
        <trans-unit id="65aa58a75ec1e39e9166d34dcff5d186dbe23e3a" translate="yes" xml:space="preserve">
          <source>To commit a mutation</source>
          <target state="translated">突然変異をコミットするには</target>
        </trans-unit>
        <trans-unit id="89b06193bd6c9ce7d1f792c95362915c77c9675f" translate="yes" xml:space="preserve">
          <source>To create an environment instance in Relay Modern, use the &lt;code&gt;RelayModernEnvironment&lt;/code&gt; class:</source>
          <target state="translated">Relay Modernで環境インスタンスを作成するには、 &lt;code&gt;RelayModernEnvironment&lt;/code&gt; クラスを使用します。</target>
        </trans-unit>
        <trans-unit id="79a86851c1fad2bbe848185a0d8955e026baa0f4" translate="yes" xml:space="preserve">
          <source>To enable &lt;a href=&quot;relay-compat&quot;&gt;compatibility mode&lt;/a&gt;, &lt;code&gt;relay-compiler&lt;/code&gt; enforces a simple naming convention for your queries. Queries must be named as &lt;code&gt;&amp;lt;FileName&amp;gt;&amp;lt;OperationType&amp;gt;&lt;/code&gt;, where &quot;&amp;lt;OperationType&amp;gt;&quot; is one of &quot;Query&quot;, &quot;Mutation&quot;, or &quot;Subscription&quot;. The query above is named &lt;code&gt;ExampleQuery&lt;/code&gt; so should be placed in &lt;code&gt;Example.js&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;relay-compat&quot;&gt;互換モード&lt;/a&gt;を有効にするために、 &lt;code&gt;relay-compiler&lt;/code&gt; はクエリに単純な命名規則を適用します。クエリの名前は &lt;code&gt;&amp;lt;FileName&amp;gt;&amp;lt;OperationType&amp;gt;&lt;/code&gt; である必要があります。ここで、「&amp;lt;OperationType&amp;gt;」は「Query」、「Mutation」、または「Subscription」のいずれかです。上記のクエリは &lt;code&gt;ExampleQuery&lt;/code&gt; という名前なので、 &lt;code&gt;Example.js&lt;/code&gt; に配置する必要があります。</target>
        </trans-unit>
        <trans-unit id="03ec37246eca3b43ea7ac7f76a27cbf7c5cb3d8b" translate="yes" xml:space="preserve">
          <source>To execute this code, Relay needs access to the schema - which can be too large to bundle inside the application. Instead, these &lt;code&gt;Relay.QL&lt;/code&gt; template expressions are transpiled into JavaScript descriptions via the &lt;code&gt;babel-relay-plugin&lt;/code&gt;. This schema information allows Relay to understand things like the types of field arguments, which fields are connections or lists, and how to efficiently refetch records from the server.</source>
          <target state="translated">このコードを実行するには、Relayがスキーマにアクセスする必要があります。スキーマが大きすぎて、アプリケーション内にバンドルできない場合があります。代わりに、これらの &lt;code&gt;Relay.QL&lt;/code&gt; テンプレート式は、 &lt;code&gt;babel-relay-plugin&lt;/code&gt; を介してJavaScript記述に変換されます。このスキーマ情報により、Relayはフィールド引数のタイプ、接続またはリストであるフィールド、サーバーからレコードを効率的に再フェッチする方法などを理解できます。</target>
        </trans-unit>
        <trans-unit id="6be87ed7f838f24ecfdb363ea58800de8f9dfbc1" translate="yes" xml:space="preserve">
          <source>To force fetch a component</source>
          <target state="translated">コンポーネントを強制的に取得するには</target>
        </trans-unit>
        <trans-unit id="e7e54aa101836df2ce7d5415960a239df67598f0" translate="yes" xml:space="preserve">
          <source>To get started building Relay applications, you will need three things:</source>
          <target state="translated">Relayアプリケーションの構築を始めるには、以下の3つのものが必要です。</target>
        </trans-unit>
        <trans-unit id="45fa77bbc0446347a81f6d5b23fa090e9c9d6856" translate="yes" xml:space="preserve">
          <source>To improve perceived responsiveness, you may wish to perform an &quot;optimistic update&quot;, in which the client immediately updates to reflect the anticipated new value even before the response from the server has come back. The simplest way to do this is by providing an &lt;code&gt;optimisticResponse&lt;/code&gt; and adding it to the &lt;code&gt;config&lt;/code&gt; that we pass into &lt;code&gt;commitMutation&lt;/code&gt;:</source>
          <target state="translated">知覚される応答性を向上させるために、「楽観的な更新」を実行することをお勧めします。この更新では、サーバーからの応答が返される前でも、クライアントは予想される新しい値を反映するようにすぐに更新します。これを実行する最も簡単な方法は、提供することである &lt;code&gt;optimisticResponse&lt;/code&gt; をし、それを追加 &lt;code&gt;config&lt;/code&gt; 、我々は中に入ることを &lt;code&gt;commitMutation&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2cf9a932987c095688d86461efe0eedbdc22d8b7" translate="yes" xml:space="preserve">
          <source>To improve perceived responsiveness, you may wish to perform an &quot;optimistic update&quot;, in which the client immediately updates to reflect the anticipated new value even before the response from the server has come back. We do this by providing an &lt;code&gt;optimisticResponse&lt;/code&gt; and adding it to the &lt;code&gt;config&lt;/code&gt; that we pass into &lt;code&gt;commitMutation&lt;/code&gt;:</source>
          <target state="translated">知覚される応答性を改善するために、サーバーからの応答が返ってくる前であっても、クライアントがすぐに更新して予期される新しい値を反映する「楽観的更新」を実行することができます。我々は提供することで、これを行う &lt;code&gt;optimisticResponse&lt;/code&gt; をし、それを追加 &lt;code&gt;config&lt;/code&gt; 、我々は中に入ることを &lt;code&gt;commitMutation&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bebfedde59ec9253c14e34d042772cb6d964fce0" translate="yes" xml:space="preserve">
          <source>To paginate through a connection</source>
          <target state="translated">接続を介してページングするには</target>
        </trans-unit>
        <trans-unit id="b6033100545414ff9dedc545a14635be362e73ed" translate="yes" xml:space="preserve">
          <source>To read from the cache we can walk a query and resolve each field. But wait: that sounds &lt;em&gt;exactly&lt;/em&gt; like what a GraphQL server does when it processes a query. And it is! Reading from the cache is a special case of an executor where a) there's no need for user-defined field functions because all results come from a fixed data structure and b) results are always synchronous &amp;mdash; we either have the data cached or we don't.</source>
          <target state="translated">キャッシュから読み取るには、クエリを実行して各フィールドを解決します。しかし、待ってください。それは、GraphQLサーバーがクエリを処理するときに行うことと&lt;em&gt;まったく同じ&lt;/em&gt;ように聞こえます。そしてそうです！キャッシュからの読み取りは、a）すべての結果が固定データ構造から取得されるためユーザー定義のフィールド関数が不要であり、b）結果が常に同期している、エグゼキューターの特殊なケースです。データは常にキャッシュされているか、キャッシュされているかt。</target>
        </trans-unit>
        <trans-unit id="e168ce7f96f9f96537f762eb07d59ca6c422e92d" translate="yes" xml:space="preserve">
          <source>To start, let's build the plain React version of a &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; component that displays the user's profile photo and a slider to adjust the photo's size.</source>
          <target state="translated">まず、ユーザーのプロフィール写真と写真のサイズを調整するためのスライダーを表示する &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; コンポーネントのプレーンなReactバージョンを作成してみましょう。</target>
        </trans-unit>
        <trans-unit id="fccbd6622bb8847d0929fc4851e9ea2b575ead73" translate="yes" xml:space="preserve">
          <source>To start, let's build the plain React version of a &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; component that displays the text and completion status of a &lt;code&gt;Todo&lt;/code&gt;.</source>
          <target state="translated">まず、 &lt;code&gt;Todo&lt;/code&gt; のテキストと完了ステータスを表示する &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; コンポーネントのプレーンなReactバージョンを作成しましょう。</target>
        </trans-unit>
        <trans-unit id="2ac483e211ecf7cd1ac9ea59c0478cde75088452" translate="yes" xml:space="preserve">
          <source>To start, let's build the plain React version of a hypothetical &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt; component that displays the text and completion status of a &lt;code&gt;Todo&lt;/code&gt;.</source>
          <target state="translated">まず、 &lt;code&gt;Todo&lt;/code&gt; のテキストと完了ステータスを表示する架空の &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt; コンポーネントのプレーンなReactバージョンを作成しましょう。</target>
        </trans-unit>
        <trans-unit id="11ddeec9a3447606ae9ab043cf0ed78d26a53e7b" translate="yes" xml:space="preserve">
          <source>To update a variable for my component</source>
          <target state="translated">コンポーネントの変数を更新するには</target>
        </trans-unit>
        <trans-unit id="3f1189857789cd58adacaebeec728b8e0afcce44" translate="yes" xml:space="preserve">
          <source>To use the Relay Compiler, you need either a .graphql or .json GraphQL schema file, describing your GraphQL server's API. Typically these files are local representations of a server source of truth and are not edited directly. For example, we might have a &lt;code&gt;schema.graphql&lt;/code&gt; like:</source>
          <target state="translated">リレーコンパイラを使用するには、GraphQLサーバーのAPIを記述した.graphqlまたは.json GraphQLスキーマファイルが必要です。通常、これらのファイルはサーバーの真実のソースのローカル表現であり、直接編集されません。たとえば、 &lt;code&gt;schema.graphql&lt;/code&gt; ようなschema.graphqlがあるとします。</target>
        </trans-unit>
        <trans-unit id="9be854f285feec3a5f3620acb9820d1d2c32fbd0" translate="yes" xml:space="preserve">
          <source>To use these pieces to construct a full-fledged GraphQL query that we can send to the server to fetch data, we need to use the &lt;strong&gt;Relay.RootContainer&lt;/strong&gt;.</source>
          <target state="translated">これらの部分を使用して、サーバーに送信してデータをフェッチできる本格的なGraphQLクエリを作成するには、&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="0cef4df4d340703594fc301669e90430e959441b" translate="yes" xml:space="preserve">
          <source>Transforms</source>
          <target state="translated">Transforms</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="7634bede4230d278e0e78179b1dcae8473d4d33a" translate="yes" xml:space="preserve">
          <source>Types for working with queries and their results include:</source>
          <target state="translated">クエリを使用して作業するためのタイプとその結果は次のようになります。</target>
        </trans-unit>
        <trans-unit id="f77a5658e80339ebafab29498f8ee4b43724b2e0" translate="yes" xml:space="preserve">
          <source>Typical Relay Classic code:</source>
          <target state="translated">典型的なリレー・クラシック・コード。</target>
        </trans-unit>
        <trans-unit id="95e39abda529007d77cea645d9c98a79ceba0779" translate="yes" xml:space="preserve">
          <source>Typical old code:</source>
          <target state="translated">典型的な古いコード。</target>
        </trans-unit>
        <trans-unit id="5ea4501b4b61baf5dd246de000e69cf2c83ec128" translate="yes" xml:space="preserve">
          <source>Typically you will not need to import your generated definitions. The &lt;a href=&quot;babel-plugin-relay&quot;&gt;Relay Babel plugin&lt;/a&gt; will convert the &lt;code&gt;graphql&lt;/code&gt; literals to &lt;code&gt;require()&lt;/code&gt; the generated files.</source>
          <target state="translated">通常、生成された定義をインポートする必要はありません。&lt;a href=&quot;babel-plugin-relay&quot;&gt;リレーバベルプラグインが&lt;/a&gt;変換されます &lt;code&gt;graphql&lt;/code&gt; リテラルがする &lt;code&gt;require()&lt;/code&gt; 生成されたファイルを。</target>
        </trans-unit>
        <trans-unit id="fe82c32a588b217dd555d86acd7cd881dee1801f" translate="yes" xml:space="preserve">
          <source>Typically you will not need to import your generated definitions. The &lt;a href=&quot;installation-and-setup#setup-babel-plugin-relay&quot;&gt;Relay Babel plugin&lt;/a&gt; will then convert the &lt;code&gt;graphql&lt;/code&gt; literals in your code into &lt;code&gt;require()&lt;/code&gt; calls for the generated files.</source>
          <target state="translated">通常、生成された定義をインポートする必要はありません。次に、&lt;a href=&quot;installation-and-setup#setup-babel-plugin-relay&quot;&gt;Relay Babelプラグイン&lt;/a&gt;は、コード内の &lt;code&gt;graphql&lt;/code&gt; リテラルを、生成されたファイルの &lt;code&gt;require()&lt;/code&gt; 呼び出しに変換します。</target>
        </trans-unit>
        <trans-unit id="43a4e34531ca0764965880501d0f8c89a74d18d5" translate="yes" xml:space="preserve">
          <source>Underneath the hood, the default network layer uses &lt;code&gt;fetch&lt;/code&gt; (&lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;Living Standard&lt;/a&gt;). The constructor for &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt; takes an optional second argument that accepts any valid initialization property that &lt;code&gt;fetch&lt;/code&gt; accepts.</source>
          <target state="translated">内部では、デフォルトのネットワークレイヤーは &lt;code&gt;fetch&lt;/code&gt; （&lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;Living Standard&lt;/a&gt;）を使用します。コンストラクタ &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt; は、任意の有効な初期化プロパティ受け入れるオプションの第二引数取り &lt;code&gt;fetch&lt;/code&gt; 受け入れを。</target>
        </trans-unit>
        <trans-unit id="b2498fd787926326020b483e3523f960c30e4f9d" translate="yes" xml:space="preserve">
          <source>Unlike queries, failed requests for mutations are not automatically retried.</source>
          <target state="translated">クエリとは異なり、突然変異に対する失敗したリクエストは自動的に再試行されません。</target>
        </trans-unit>
        <trans-unit id="fa7f90794261c83159eb4a91e2dfe23661dee9e6" translate="yes" xml:space="preserve">
          <source>Up until this point we have only interacted with the GraphQL endpoint to perform queries that fetch data. In this guide, you will learn how to use Relay to perform mutations &amp;ndash; operations that consist of writes to the data store followed by a fetch of any changed fields.</source>
          <target state="translated">ここまでは、データをフェッチするクエリを実行するためにGraphQLエンドポイントとのみ対話しました。このガイドでは、Relayを使用して変更（データストアへの書き込みと、それに続く変更されたフィールドのフェッチで構成される操作）を実行する方法を学習します。</target>
        </trans-unit>
        <trans-unit id="706a52f4ea94115123954122a8c78690d8a63036" translate="yes" xml:space="preserve">
          <source>Updater Configs</source>
          <target state="translated">アップデータの設定</target>
        </trans-unit>
        <trans-unit id="f2d05363c2e81a266183ca6ef8b7bd0bdbd8b278" translate="yes" xml:space="preserve">
          <source>Updates the records associated with a mutable record, transversing the source by field name and an object representing pre-defined argument values.</source>
          <target state="translated">フィールド名と事前に定義された引数値を表すオブジェクトによってソースを横切って、変更可能なレコードに関連付けられたレコードを更新します。</target>
        </trans-unit>
        <trans-unit id="77357ed1c74dd26c490773b79c9c64db80714ee8" translate="yes" xml:space="preserve">
          <source>Updates the value of a mutable record's attribute given by the field name and an object representing pre-defined argument values.</source>
          <target state="translated">フィールド名とあらかじめ定義された引数の値を表すオブジェクトによって与えられたミュータブルレコードの属性の値を更新します。</target>
        </trans-unit>
        <trans-unit id="130a5ea1f38180314e9b7e8d2e0c0f8791af7800" translate="yes" xml:space="preserve">
          <source>Updating the client on each response</source>
          <target state="translated">各レスポンスのクライアントへの更新</target>
        </trans-unit>
        <trans-unit id="9c5f928161eaee0e6b37f9f04f9b99fffe3258b5" translate="yes" xml:space="preserve">
          <source>Updating the client optimistically</source>
          <target state="translated">クライアントを楽観的に更新する</target>
        </trans-unit>
        <trans-unit id="683610f0bd36453d03467df7a76f50661ef6f8ac" translate="yes" xml:space="preserve">
          <source>Updating the local cache after receiving query/mutation responses.</source>
          <target state="translated">クエリ/ミューテーション応答を受信した後、ローカルキャッシュを更新します。</target>
        </trans-unit>
        <trans-unit id="5cbc715352505bf09eed712fc8faa91711d9dd6f" translate="yes" xml:space="preserve">
          <source>Updating the store programatically (advanced)</source>
          <target state="translated">ストアをプログラム的に更新する (上級)</target>
        </trans-unit>
        <trans-unit id="b03854fc017532ee497460390d8d2a3a98701a8a" translate="yes" xml:space="preserve">
          <source>Upgrade to react-relay v1.0.0</source>
          <target state="translated">react-relay v1.0.0へのアップグレード</target>
        </trans-unit>
        <trans-unit id="6f683dd933be22f58cc623c7fb6049182ce19997" translate="yes" xml:space="preserve">
          <source>Upgrading setVariables</source>
          <target state="translated">setVariablesのアップグレード</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="64cfd0b3a8ed6125a106524eb46cf6330e091d8e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;commitLocalUpdate&lt;/code&gt; when you need to update the local store without necessarily executing a mutation (such as in the case of debounced operations). The function takes in a Relay &lt;code&gt;environment&lt;/code&gt; and an &lt;code&gt;updater&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;commitLocalUpdate&lt;/code&gt; 実行せずにローカルストアを更新する必要がある場合（デバウンス操作の場合など）は、commitLocalUpdateを使用します。この関数は、リレー &lt;code&gt;environment&lt;/code&gt; と &lt;code&gt;updater&lt;/code&gt; 関数を取り入れます。</target>
        </trans-unit>
        <trans-unit id="9443a1d180d1993141d5ed99d3c993a96f971b4c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;commitMutation&lt;/code&gt; to create and execute mutations. &lt;code&gt;commitMutation&lt;/code&gt; has the following signature:</source>
          <target state="translated">&lt;code&gt;commitMutation&lt;/code&gt; を使用して、ミューテーションを作成および実行します。 &lt;code&gt;commitMutation&lt;/code&gt; には次の署名があります。</target>
        </trans-unit>
        <trans-unit id="855b7cdc9a7b7eedbbade3460ffda75d84c0215a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;introspectionQuery&lt;/code&gt; to generate a Schema JSON for the Babel Relay Plugin, and use &lt;code&gt;printSchema&lt;/code&gt; to generate a user readable type system shorthand:</source>
          <target state="translated">&lt;code&gt;introspectionQuery&lt;/code&gt; を使用してBabel RelayプラグインのスキーマJSON を生成し、 &lt;code&gt;printSchema&lt;/code&gt; を使用してユーザーが読み取り可能な型システムの省略表現を生成します。</target>
        </trans-unit>
        <trans-unit id="9c04ab0245abf53d950383b659bb519121fdf39c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;graphql&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;graphql&lt;/code&gt; の使用</target>
        </trans-unit>
        <trans-unit id="dc3790d0260968db930a9c68e2f92f666400ec99" translate="yes" xml:space="preserve">
          <source>Using Other GraphQL Implementations</source>
          <target state="translated">他の GraphQL 実装を使用する</target>
        </trans-unit>
        <trans-unit id="ce363e86e1227248ffe7c0ac61d5dfa9beb38f62" translate="yes" xml:space="preserve">
          <source>Using The Cache</source>
          <target state="translated">キャッシュの使用</target>
        </trans-unit>
        <trans-unit id="7cc52f33aee5330befcd51c2b80f9fac7ea6a7af" translate="yes" xml:space="preserve">
          <source>Using during conversion in &quot;&lt;a href=&quot;relay-compat&quot;&gt;compatibility mode&lt;/a&gt;&quot;</source>
          <target state="translated">「&lt;a href=&quot;relay-compat&quot;&gt;互換モード&lt;/a&gt;」で変換中に使用する</target>
        </trans-unit>
        <trans-unit id="410e9ae9e9ce0fe0fb15689548590810d66caa99" translate="yes" xml:space="preserve">
          <source>Using updater and optimisticUpdater</source>
          <target state="translated">updaterとoptimisticUpdaterの使用</target>
        </trans-unit>
        <trans-unit id="4ca24372752ba964092860cbbff37a07dae71dd0" translate="yes" xml:space="preserve">
          <source>Using with Relay Classic</source>
          <target state="translated">リレークラシックとの併用</target>
        </trans-unit>
        <trans-unit id="9ea691c61eebccf391fb8820180c4ca2beda5321" translate="yes" xml:space="preserve">
          <source>View composition is &lt;em&gt;exactly&lt;/em&gt; what you're used to &amp;mdash; Relay containers are just standard React components. Here's the &lt;code&gt;&amp;lt;TodoList /&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">ビューの構成は&lt;em&gt;まさに&lt;/em&gt;あなたが慣れているものです&amp;mdash;リレーコンテナは単なる標準のReactコンポーネントです。ここだ &lt;code&gt;&amp;lt;TodoList /&amp;gt;&lt;/code&gt; コンポーネント：</target>
        </trans-unit>
        <trans-unit id="f72b74b27018bdf2391222dafa0211db62f72ce0" translate="yes" xml:space="preserve">
          <source>View composition is &lt;em&gt;exactly&lt;/em&gt; what you're used to &amp;mdash; Relay containers are standard React components. Here's the &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">ビューの構成は、&lt;em&gt;慣れ親しん&lt;/em&gt;だものです&amp;mdash;リレーコンテナーは、標準のReactコンポーネントです。次に &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; コンポーネントを示します。</target>
        </trans-unit>
        <trans-unit id="ff6f9fbff154a814e972c078a22c3cc9628815cf" translate="yes" xml:space="preserve">
          <source>View composition is &lt;em&gt;exactly&lt;/em&gt; what you're used to &amp;mdash; Relay containers are standard React components. Here's the &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">ビューの構成は、&lt;em&gt;慣れ親しん&lt;/em&gt;だものです&amp;mdash;リレーコンテナーは、標準のReactコンポーネントです。ここだ &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; コンポーネント：</target>
        </trans-unit>
        <trans-unit id="1ebbd92b690622c06c90cfb9515becf2b5c48808" translate="yes" xml:space="preserve">
          <source>Warm up</source>
          <target state="translated">ウォームアップ</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="ee4e2bfd72b7c80e3c41f3483341254dd5afffff" translate="yes" xml:space="preserve">
          <source>We built a few scripts to help you with the conversion process. Check them out at &lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;https://github.com/relayjs/relay-codemod&lt;/a&gt;.</source>
          <target state="translated">変換プロセスに役立つスクリプトをいくつか作成しました。&lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;https://github.com/relayjs/relay-codemodで&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="5940197c590089a53a146cb165e633452c87b60e" translate="yes" xml:space="preserve">
          <source>We can change this behavior by supplying the &lt;code&gt;renderLoading&lt;/code&gt; prop:</source>
          <target state="translated">この動作を変更するには、 &lt;code&gt;renderLoading&lt;/code&gt; プロパティを指定します。</target>
        </trans-unit>
        <trans-unit id="99418ef7bda442472813dd7c77c28063f221dc1b" translate="yes" xml:space="preserve">
          <source>We can create a &lt;code&gt;./src/clientSchema.graphql&lt;/code&gt; and define a new type called &lt;code&gt;Setting&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;./src/clientSchema.graphql&lt;/code&gt; を作成し、 &lt;code&gt;Setting&lt;/code&gt; ：と呼ばれる新しいタイプを定義できます。</target>
        </trans-unit>
        <trans-unit id="09384c922b7bcbae85b63823d4facb25583f0ebf" translate="yes" xml:space="preserve">
          <source>We can give Relay instructions in the form of a &lt;code&gt;configs&lt;/code&gt; array on how to use the response from each mutation to update the client-side store. We do this by configuring the mutation with one or more of the following config types:</source>
          <target state="translated">各ミュー &lt;code&gt;configs&lt;/code&gt; からの応答を使用してクライアント側ストアを更新する方法について、configs配列の形式でRelay命令を与えることができます。これを行うには、次の1つ以上の構成タイプを使用してミューテーションを構成します。</target>
        </trans-unit>
        <trans-unit id="0025d01a256751edcecba66775aa9098e4c29a78" translate="yes" xml:space="preserve">
          <source>We can give Relay instructions in the form of a config array on how to use the response from each mutation to update the client-side store. We do this by configuring the mutation with one or more of the following mutation types:</source>
          <target state="translated">各突然変異からのレスポンスを使ってクライアント側のストアを更新する方法について、コンフィグ配列の形でRelayに指示を出すことができます。これを行うには、以下のミューテーションタイプのうち1つ以上でミューテーションを設定します。</target>
        </trans-unit>
        <trans-unit id="8b225a6bc0d167f8b54e806d442a842dc3c15baa" translate="yes" xml:space="preserve">
          <source>We can then extend existing server types in the client schema &lt;code&gt;./src/clientSchema.graphql&lt;/code&gt; with our new &lt;code&gt;Setting&lt;/code&gt; type, like so:</source>
          <target state="translated">次に、クライアントスキーマ &lt;code&gt;./src/clientSchema.graphql&lt;/code&gt; の既存のサーバータイプを、次のように新しい &lt;code&gt;Setting&lt;/code&gt; タイプで拡張できます。</target>
        </trans-unit>
        <trans-unit id="8d988256976c56fbd9f26524c8c8f2411a181121" translate="yes" xml:space="preserve">
          <source>We declare our mutations' data dependencies here, just as we would with a container. This is particularly useful to ensure that a set of fields we might want to use in this mutation's optimistic response have been fetched.</source>
          <target state="translated">コンテナと同じように、ここでミューテーションのデータ依存性を宣言します。これは、このミューテーションの楽観的な応答で使用したいフィールドのセットがフェッチされていることを確認するのに特に便利です。</target>
        </trans-unit>
        <trans-unit id="b7466fdf0dcdc8961e68874158874a25c24afe7b" translate="yes" xml:space="preserve">
          <source>We need a place to hide our treasure, a way to check hiding spots for treasure, and a way to track our turns remaining. For the purposes of this tutorial, we'll hide these data in memory.</source>
          <target state="translated">宝具の隠し場所、宝具の隠し場所を確認する方法、残りターンを把握する方法が必要です。このチュートリアルでは、これらのデータをメモリに隠します。</target>
        </trans-unit>
        <trans-unit id="65874d3946f2b63af172cee5a5b310c785e00be9" translate="yes" xml:space="preserve">
          <source>We need to give Relay instructions on how to use the response payload from each mutation to update the client-side store. We do this by configuring the mutation with one or more of the following mutation types:</source>
          <target state="translated">各突然変異からのレスポンス・ペイロードを使用してクライアント側のストアを更新する方法をRelayに指示する必要があります。これを行うには、以下のミューテーションタイプのうち1つ以上でミューテーションを設定します。</target>
        </trans-unit>
        <trans-unit id="8cbe01efa489ff5ceee170b9e46b9663c23a0b77" translate="yes" xml:space="preserve">
          <source>We ultimately settled on static methods; components would effectively return a query-tree, separate from the view-tree, describing their data dependencies. Relay could then use this query-tree to fetch all the information needed in a single stage and use it to render the components. The problem was finding an appropriate mechanism to describe the query-tree, and a way to efficiently fetch it from the server (i.e. in a single network request). This is the perfect use-case for GraphQL because it provides a syntax for &lt;em&gt;describing data-dependencies as data&lt;/em&gt;, without dictating any particular API. Note that Promises and Observables are often suggested as alternatives, but they represent &lt;em&gt;opaque commands&lt;/em&gt; and preclude various optimizations such as query batching.</source>
          <target state="translated">私たちは最終的に静的メソッドに落ち着きました。コンポーネントは、ビューツリーとは別のクエリツリーを効果的に返し、データの依存関係を記述します。次に、Relayはこのクエリツリーを使用して、単一のステージで必要なすべての情報をフェッチし、それを使用してコンポーネントをレンダリングできます。問題は、クエリツリーを記述するための適切なメカニズムと、それをサーバーから（つまり、単一のネットワーク要求で）効率的にフェッチする方法を見つけることでした。これは、特定のAPIを指定することなく&lt;em&gt;、データ依存関係をdataとして記述&lt;/em&gt;するための構文を提供するため、GraphQLの完全なユースケースです。 PromiseとObservableは代替として提案されることが多いですが、これらは&lt;em&gt;不透明なコマンド&lt;/em&gt;を表し、クエリのバッチ処理などのさまざまな最適化を妨げます。</target>
        </trans-unit>
        <trans-unit id="69182ca2dfd5971872156968dd68015b5e288405" translate="yes" xml:space="preserve">
          <source>We'll now see different &lt;code&gt;likeCount&lt;/code&gt;s depending on how the story is accessed. A view that uses the first query will see an outdated count, while a view using the second query will see the updated count.</source>
          <target state="translated">ストーリーへのアクセス方法に応じて、さまざまな &lt;code&gt;likeCount&lt;/code&gt; が表示されます。最初のクエリを使用するビューには古いカウントが表示され、2番目のクエリを使用するビューには更新されたカウントが表示されます。</target>
        </trans-unit>
        <trans-unit id="4a34c41bd9be871dd6a4b7a07724bb519fe92e77" translate="yes" xml:space="preserve">
          <source>We're almost ready to let Relay fulfill the data requirements for these components and render them. However, there is one problem. In order to actually fetch data with GraphQL, we need a query root. For example, we need to ground the &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; fragment in a concrete node of type &lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">Relayがこれらのコンポーネントのデータ要件を満たし、レンダリングする準備がほぼ整いました。ただし、問題が1つあります。GraphQLを使用して実際にデータをフェッチするには、クエリルートが必要です。たとえば、 &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; フラグメントをタイプ &lt;code&gt;User&lt;/code&gt; の具象ノードに固定する必要があります。</target>
        </trans-unit>
        <trans-unit id="f379242619731bf12c214370913f902c9dc56b87" translate="yes" xml:space="preserve">
          <source>We've found that it's common for the GraphQL schema to differ slightly or even substantially from the form in which data is stored on disk. Put simply: there isn't always a 1:1 correspondence between data changes in your underlying &lt;em&gt;data storage&lt;/em&gt; (disk) and data changes in your &lt;em&gt;product-visible schema&lt;/em&gt; (GraphQL). The perfect example of this is privacy: returning a user-facing field such as &lt;code&gt;age&lt;/code&gt; might require accessing numerous records in our data-storage layer to determine if the active user is even allowed to &lt;em&gt;see&lt;/em&gt; that &lt;code&gt;age&lt;/code&gt; (Are we friends? Is my age shared? Did I block you? etc.).</source>
          <target state="translated">GraphQLスキーマは、データがディスクに格納されている形式とはわずかに、または大幅に異なることがよくあります。簡単に言うと、基礎となる&lt;em&gt;データストレージ&lt;/em&gt;（ディスク）でのデータ変更と&lt;em&gt;製品表示スキーマ&lt;/em&gt;（GraphQL）でのデータ変更の間には、常に1対1の対応があるわけではありません。これの完璧な例はプライバシーです。 &lt;code&gt;age&lt;/code&gt; などのユーザー向けフィールドを返すには、データストレージレイヤーの多数のレコードにアクセスして、アクティブユーザーがその &lt;code&gt;age&lt;/code&gt; を&lt;em&gt;見る&lt;/em&gt;ことが許可されているかどうかを判断する必要がある場合があります（私たちは友達ですか？私の年齢は共有されますか？ ？私はあなたをブロックしましたか？など）。</target>
        </trans-unit>
        <trans-unit id="908ef03db4345c18068bb287000ab8108652ad6f" translate="yes" xml:space="preserve">
          <source>We've found that typical approaches to data-fetching &amp;mdash; with imperative APIs &amp;mdash; force developers to deal with too much of this non-essential complexity. For example, consider &lt;em&gt;optimistic UI updates&lt;/em&gt;. This is a way of giving the user feedback while waiting for a server response. The logic of &lt;em&gt;what&lt;/em&gt; to do can be quite clear: when the user clicks &quot;like&quot;, mark the story as being liked and send the request to the server. But the implementation is often much more complex. Imperative approaches require us to implement all of those steps: reach into the UI and toggle the button, initiate a network request, retry it if necessary, show an error if it fails (and untoggle the button), etc. The same goes for data-fetching: specifying &lt;em&gt;what&lt;/em&gt; data we need often dictates &lt;em&gt;how&lt;/em&gt; and &lt;em&gt;when&lt;/em&gt; it is fetched. Next, we'll explore our approach to solving these concerns with &lt;strong&gt;Relay&lt;/strong&gt;.</source>
          <target state="translated">必須のAPIを使用したデータフェッチへの一般的なアプローチにより、開発者はこの本質的でない複雑さの多くに対処しなければならないことがわかりました。たとえば、&lt;em&gt;楽観的なUIの更新を&lt;/em&gt;検討&lt;em&gt;してください&lt;/em&gt;。これは、サーバーからの応答を待つ間にユーザーにフィードバックを提供する方法です。&lt;em&gt;何&lt;/em&gt;をすべき&lt;em&gt;か&lt;/em&gt;というロジックは非常に明確です。ユーザーが「いいね」をクリックしたときに、ストーリーに「いいね！」とマークを付け、リクエストをサーバーに送信します。しかし、多くの場合、実装ははるかに複雑です。命令型アプローチでは、これらすべての手順を実装する必要があります。UIにアクセスしてボタンを切り替え、ネットワークリクエストを開始し、必要に応じて再試行し、失敗した場合はエラーを表示します（ボタンの切り替えを解除します）など。データについても同様です。 -fetching：必要&lt;em&gt;な&lt;/em&gt;データを指定する&lt;em&gt;どのように&lt;/em&gt;して&lt;em&gt;たときに&lt;/em&gt;、それがフェッチされます。次に、&lt;strong&gt;Relayで&lt;/strong&gt;これらの問題を解決するためのアプローチを探ります。</target>
        </trans-unit>
        <trans-unit id="c57df462a7e454e5b5d9c9c3be330abf92758a69" translate="yes" xml:space="preserve">
          <source>We've seen that Relay containers ensure that GraphQL fragments are fetched &lt;em&gt;before&lt;/em&gt; the component is rendered. But containers also provide another benefit that isn't immediately obvious: &lt;strong&gt;data masking&lt;/strong&gt;. Relay only allows components to access data they specifically ask for in &lt;code&gt;fragments&lt;/code&gt; &amp;mdash; nothing more. So if one component queries for a Story's &lt;code&gt;text&lt;/code&gt;, and another for its &lt;code&gt;author&lt;/code&gt;, each can see &lt;em&gt;only&lt;/em&gt; the field that they asked for. In fact, components can't even see the data requested by their &lt;em&gt;children&lt;/em&gt;: that would also break encapsulation.</source>
          <target state="translated">リレーコンテナーは、コンポーネントがレンダリングされる&lt;em&gt;前に&lt;/em&gt; GraphQLフラグメントが確実にフェッチされることを確認しました。しかし、コンテナーには、すぐには明らかにならないもう1つの利点があります。それは、&lt;strong&gt;データマスキング&lt;/strong&gt;です。リレーは、コンポーネントが &lt;code&gt;fragments&lt;/code&gt; 具体的に要求するデータにアクセスすることのみを許可します。一つの成分ストーリーのためのクエリのであれば &lt;code&gt;text&lt;/code&gt; 、およびそのための別の &lt;code&gt;author&lt;/code&gt; 、それぞれが見ることができる&lt;em&gt;唯一の&lt;/em&gt;彼らが求めていることをフィールドに。実際、コンポーネントは&lt;em&gt;子から&lt;/em&gt;要求されたデータを見ることさえできません。それもカプセル化を壊します。</target>
        </trans-unit>
        <trans-unit id="e1d701dcb15b88a66be26dfbe21cdfc47c48bde8" translate="yes" xml:space="preserve">
          <source>We've seen that Relay containers ensure that GraphQL fragments are fetched &lt;em&gt;before&lt;/em&gt; the component is rendered. But containers also provide another benefit that isn't immediately obvious: &lt;strong&gt;data masking&lt;/strong&gt;. Relay only allows components to access data they specifically ask for in GraphQL fragments &amp;mdash; nothing more. So if one component queries for a Story's &lt;code&gt;text&lt;/code&gt;, and another for its &lt;code&gt;author&lt;/code&gt;, each can see &lt;em&gt;only&lt;/em&gt; the field that they asked for. In fact, components can't even see the data requested by their &lt;em&gt;children&lt;/em&gt;: that would also break encapsulation.</source>
          <target state="translated">リレーコンテナは、コンポーネントがレンダリングされる&lt;em&gt;前に&lt;/em&gt;GraphQLフラグメントがフェッチされることを保証することを確認しました。ただし、コンテナには、すぐにはわからないもう1つの利点があります。それは&lt;strong&gt;データマスキング&lt;/strong&gt;です。リレーは、コンポーネントがGraphQLフラグメントで具体的に要求するデータにのみアクセスできるようにします。それ以上は許可しません。したがって、あるコンポーネントがストーリーの &lt;code&gt;text&lt;/code&gt; クエリし、別のコンポーネントがその作成 &lt;code&gt;author&lt;/code&gt; クエリした場合、それぞれが要求したフィールド&lt;em&gt;のみ&lt;/em&gt;を表示できます。実際、コンポーネントは&lt;em&gt;子から&lt;/em&gt;要求されたデータを見ることさえできません。これもカプセル化を破ります。</target>
        </trans-unit>
        <trans-unit id="deaef06798309bf42fff99bdd598051728c38f5a" translate="yes" xml:space="preserve">
          <source>What we have written here is a mock database interface. We can imagine hooking this up to a real database, but for now let's move on.</source>
          <target state="translated">ここに書いたのは、模擬データベースインターフェースです。これを実際のデータベースに接続することも想像できますが、今のところは先に進みましょう。</target>
        </trans-unit>
        <trans-unit id="73a39c3a3d88bd8125f710502d024ae93180062d" translate="yes" xml:space="preserve">
          <source>What works with what? Relay Compat (&lt;code&gt;'react-relay/compat'&lt;/code&gt;) is the most flexible. Compat components and mutations can be used by everything. Compat components can also have any kind of children.</source>
          <target state="translated">何が何に対応していますか？リレー互換（ &lt;code&gt;'react-relay/compat'&lt;/code&gt; ）が最も柔軟です。互換性のあるコンポーネントとミューテーションはすべてで使用できます。Compatコンポーネントは、あらゆる種類の子を持つこともできます。</target>
        </trans-unit>
        <trans-unit id="0a097138ac94d8bfbf69d6920577e2b751982a49" translate="yes" xml:space="preserve">
          <source>When &quot;force fetching&quot;, this is true if &lt;code&gt;ready&lt;/code&gt; is true as a result of data being available on the client before the server request has completed.</source>
          <target state="translated">「強制フェッチ」の場合、サーバー要求が完了する前にクライアントでデータが使用可能になった結果、 &lt;code&gt;ready&lt;/code&gt; がtrueであれば、これはtrueです。</target>
        </trans-unit>
        <trans-unit id="ec3ad126a1399587ee94fd174e76b0fbd442a34b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;forceFetch&lt;/code&gt; is true and &lt;code&gt;renderFetched&lt;/code&gt; is called as a result of available client data, &lt;code&gt;renderFetched&lt;/code&gt; is called with a second argument that has a &lt;code&gt;stale&lt;/code&gt; boolean property. The &lt;code&gt;stale&lt;/code&gt; property is true if &lt;code&gt;renderFetched&lt;/code&gt; is called before the forced server request completes.</source>
          <target state="translated">とき &lt;code&gt;forceFetch&lt;/code&gt; が真であると &lt;code&gt;renderFetched&lt;/code&gt; が可能なクライアントデータの結果として呼び出され、 &lt;code&gt;renderFetched&lt;/code&gt; を有する第2引数で呼び出された &lt;code&gt;stale&lt;/code&gt; ブール型プロパティを。 &lt;code&gt;stale&lt;/code&gt; 場合はプロパティがtrueで &lt;code&gt;renderFetched&lt;/code&gt; が強制サーバ要求が完了する前に呼ばれています。</target>
        </trans-unit>
        <trans-unit id="eb41ea6dee1bf1db385774c4f83f62a51389acc5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;forceFetch&lt;/code&gt; is true, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; will always send a request to the server. However, if all the data required to render is also available on the client, &lt;code&gt;renderFetched&lt;/code&gt; may still be called before the server request completes.</source>
          <target state="translated">とき &lt;code&gt;forceFetch&lt;/code&gt; が真である、&lt;strong&gt;Relay.RootContainerは&lt;/strong&gt;常にサーバにリクエストを送信します。ただし、レンダリングに必要なすべてのデータがクライアントでも利用できる場合、サーバーリクエストが完了する前に &lt;code&gt;renderFetched&lt;/code&gt; が呼び出される可能性があります。</target>
        </trans-unit>
        <trans-unit id="5e40c2b8419bc5119b554a06ad55e52a926e319f" translate="yes" xml:space="preserve">
          <source>When Relay fulfills data, the &lt;code&gt;onReadyStateChange&lt;/code&gt; callback is called one or more times with an object that describes the current &quot;ready state&quot;. This object has the following properties:</source>
          <target state="translated">Relayがデータを満たすと、 &lt;code&gt;onReadyStateChange&lt;/code&gt; コールバックが、現在の「準備完了状態」を表すオブジェクトを使用して1回以上呼び出されます。このオブジェクトには次のプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="32bb09505d79ce543a4f26cb9022780cf39a8205" translate="yes" xml:space="preserve">
          <source>When all data necessary to render becomes available, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; will render the supplied &lt;code&gt;Component&lt;/code&gt; by default. However, we can change this behavior by supplying a callback to the &lt;code&gt;renderFetched&lt;/code&gt; prop:</source>
          <target state="translated">レンダリングに必要なすべてのデータが利用可能になると、&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;はデフォルトで提供された &lt;code&gt;Component&lt;/code&gt; をレンダリングします。ただし、 &lt;code&gt;renderFetched&lt;/code&gt; プロップにコールバックを提供することで、この動作を変更できます。</target>
        </trans-unit>
        <trans-unit id="e8c530641aad6dea0ce0a725ecb86984b969f2e6" translate="yes" xml:space="preserve">
          <source>When all data requirements are fulfilled, &lt;code&gt;renderFetched&lt;/code&gt; is called to render the view. This callback is expected to spread &lt;code&gt;data&lt;/code&gt; into the supplied &lt;code&gt;Container&lt;/code&gt; when rendering it.</source>
          <target state="translated">すべてのデータ要件が満たされると、ビューをレンダリングするために &lt;code&gt;renderFetched&lt;/code&gt; が呼び出されます。このコールバックは、レンダリング時に、提供された &lt;code&gt;Container&lt;/code&gt; に &lt;code&gt;data&lt;/code&gt; を分散することが期待されています。</target>
        </trans-unit>
        <trans-unit id="f5e881d6a25c5fe2f25b897803df81640312440a" translate="yes" xml:space="preserve">
          <source>When compiling code for production deployment, the plugin can be configured to immediately throw upon encountering a validation problem. The plugin can be further customized for different environments with the following options:</source>
          <target state="translated">本番環境でのデプロイ用にコードをコンパイルする際に、検証の問題が発生した場合に即座にスローするようにプラグインを設定することができます。プラグインは、以下のオプションを使用して、さまざまな環境に合わせてさらにカスタマイズすることができます。</target>
        </trans-unit>
        <trans-unit id="fef005c4b23cdf975a02dadd67a2264bb2944197" translate="yes" xml:space="preserve">
          <source>When data requirements failed to be fulfilled, &lt;code&gt;renderFailure&lt;/code&gt; is called to render the view.</source>
          <target state="translated">データ要件が満たされなかった場合、ビューをレンダリングするために &lt;code&gt;renderFailure&lt;/code&gt; が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="fe6cbba9204bbe45970c08910fca16574ce8a0cc" translate="yes" xml:space="preserve">
          <source>When data requirements have yet to be fulfilled, &lt;code&gt;renderLoading&lt;/code&gt; is called to render the view. If this returns &lt;code&gt;undefined&lt;/code&gt;, the previously rendered view (or nothing if there is no previous view) is rendered.</source>
          <target state="translated">データ要件がまだ満たされていないと、ビューをレンダリングするために &lt;code&gt;renderLoading&lt;/code&gt; が呼び出されます。これが &lt;code&gt;undefined&lt;/code&gt; を返す場合、以前にレンダリングされたビュー（または前のビューがない場合は何も）がレンダリングされます。</target>
        </trans-unit>
        <trans-unit id="9fd4594d265309e3ea2f8851c4e096213978657c" translate="yes" xml:space="preserve">
          <source>When defining a fragment for use with a Fragment container, you can use the &lt;code&gt;@relay(plural: true)&lt;/code&gt; directive to indicate that container expects the prop for that fragment to be a list of items instead of a single item. A query or parent that spreads a &lt;code&gt;@relay(plural: true)&lt;/code&gt; fragment should do so within a plural field (ie a field backed by a &lt;a href=&quot;http://graphql.org/learn/schema/#lists-and-non-null&quot;&gt;GraphQL list&lt;/a&gt;. For example:</source>
          <target state="translated">Fragmentコンテナーで使用するフラグメントを定義する場合、 &lt;code&gt;@relay(plural: true)&lt;/code&gt; ディレクティブを使用して、コンテナーがそのフラグメントのpropが単一のアイテムではなくアイテムのリストであることを期待することを示すことができます。 &lt;code&gt;@relay(plural: true)&lt;/code&gt; フラグメントを拡散するクエリまたは親は、複数のフィールド（つまり、&lt;a href=&quot;http://graphql.org/learn/schema/#lists-and-non-null&quot;&gt;GraphQLリストに基づく&lt;/a&gt;フィールド）内で拡散する必要があります。例：</target>
        </trans-unit>
        <trans-unit id="619aba17233daa1e1d7ee5e3869b79e1331126b3" translate="yes" xml:space="preserve">
          <source>When defining a fragment, you can use the &lt;a href=&quot;graphql-in-relay#argumentdefinitions&quot;&gt;&lt;code&gt;@argumentDefinitions&lt;/code&gt;&lt;/a&gt; directive to specify any arguments, with potentially default values, that the fragment expects.</source>
          <target state="translated">フラグメントを定義するときは、&lt;a href=&quot;graphql-in-relay#argumentdefinitions&quot;&gt; &lt;code&gt;@argumentDefinitions&lt;/code&gt; &lt;/a&gt;ディレクティブを使用して、フラグメントが予期する可能性のあるデフォルト値を含む引数を指定できます。</target>
        </trans-unit>
        <trans-unit id="48fe499e8a7f1e23dc6dcd982b4f071176b969ff" translate="yes" xml:space="preserve">
          <source>When designing a fat query, consider &lt;em&gt;all&lt;/em&gt; of the data that might change as a result of the mutation &amp;ndash; not just the data currently in use by your application. We don't need to worry about overfetching; this query is never executed without first intersecting it with a &amp;lsquo;tracked query&amp;rsquo; of the data our application actually needs. If we omit fields in the fat query, we might observe data inconsistencies in the future when we add views with new data dependencies, or add new data dependencies to existing views.</source>
          <target state="translated">ファットクエリを設計するときは、アプリケーションの現在使用中のデータだけでなく、変更の結果として変更される可能性のある&lt;em&gt;すべて&lt;/em&gt;のデータを考慮してください。オーバーフェッチについて心配する必要はありません。このクエリは、アプリケーションが実際に必要とするデータの「追跡されたクエリ」と最初に交差しない限り、決して実行されません。ファットクエリのフィールドを省略した場合、新しいデータ依存関係を持つビューを追加したり、既存のビューに新しいデータ依存関係を追加したりすると、将来的にデータの不整合が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="8d515b89284c6ce31950922a449ba18618a553f6" translate="yes" xml:space="preserve">
          <source>When incrementally converting a Relay Classic app to Relay Modern, &lt;code&gt;graphql&lt;/code&gt; literals can be translated to be usable by &lt;em&gt;both&lt;/em&gt; runtimes if configured to use compatibility mode:</source>
          <target state="translated">Relay ClassicアプリをRelay Modernに段階的に変換する場合、互換モードを使用するように構成されていれば、 &lt;code&gt;graphql&lt;/code&gt; リテラルを&lt;em&gt;両方の&lt;/em&gt;ランタイムで使用できるように変換できます。</target>
        </trans-unit>
        <trans-unit id="902c49b06415e9d418fef8488cdcaad88a9be3b5" translate="yes" xml:space="preserve">
          <source>When it sends queries, it will automatically fail requests after a 15 second timeout. Also, failed requests are automatically retried twice, with a 1 second delay and a 3 second delay, respectively.</source>
          <target state="translated">クエリを送信すると、15秒のタイムアウト後に自動的にリクエストが失敗します。また、失敗したリクエストは自動的に2回再試行され、それぞれ1秒の遅延と3秒の遅延が発生します。</target>
        </trans-unit>
        <trans-unit id="c328250268c48757d266a5578f320e2cd118ae4e" translate="yes" xml:space="preserve">
          <source>When not nesting routes with Relay data dependencies, such as when using flat routes, it is sufficient to just render a &lt;code&gt;QueryRenderer&lt;/code&gt; for the parts of your application that require Relay data. You can also use the options below that integrate your routes with their data dependencies.</source>
          <target state="translated">フラットルートを使用する場合など、リレーデータに依存するルートをネストしない場合は、リレーデータを必要とするアプリケーションの部分に対して &lt;code&gt;QueryRenderer&lt;/code&gt; をレンダリングするだけで十分です。ルートをデータの依存関係と統合する以下のオプションを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="c958feb46013f0ddcda8fd3772356651d46f8e8a" translate="yes" xml:space="preserve">
          <source>When problems arise developers would need an insight into Relay's store. Relay provides a couple of tools to inspect the store and its records programmatically and visually.</source>
          <target state="translated">問題が発生した場合、開発者はRelayのストアを把握する必要があります。Relayには、ストアとそのレコードをプログラムや視覚的に検査するためのツールがいくつか用意されています。</target>
        </trans-unit>
        <trans-unit id="5d9ce00224dd61a4d32a2854970285a45cfbec29" translate="yes" xml:space="preserve">
          <source>When the &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; above is rendered, Relay will construct a query and send it to the GraphQL server. As soon as all required data has been fetched, &lt;code&gt;ProfilePicture&lt;/code&gt; will be rendered. Props with fragments will contain data that was fetched from the server.</source>
          <target state="translated">上記の&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;がレンダリングされると、Relayはクエリを作成し、それをGraphQLサーバーに送信します。必要なデータがすべてフェッチされるとすぐに、 &lt;code&gt;ProfilePicture&lt;/code&gt; がレンダリングされます。フラグメントのある小道具には、サーバーからフェッチされたデータが含まれます。</target>
        </trans-unit>
        <trans-unit id="c67a5c120de0df00997c004e146051bbad946df1" translate="yes" xml:space="preserve">
          <source>When the server response is received, one of the callbacks is invoked:</source>
          <target state="translated">サーバーからの応答を受信すると、コールバックのいずれかが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="cea8475e3aa555845df5b9bb69835f08e0fe8ca8" translate="yes" xml:space="preserve">
          <source>When the transaction is committed and the response is received from the server, one of the callbacks is invoked: - &lt;code&gt;onSuccess&lt;/code&gt; is called if the mutation succeeded. - &lt;code&gt;onFailure&lt;/code&gt; is called if the mutation failed.</source>
          <target state="translated">トランザクションがコミットされ、サーバーから応答が受信されると、コールバックの1つが呼び出されます &lt;code&gt;onSuccess&lt;/code&gt; が成功した場合、onSuccessが呼び出されます。- ミュー &lt;code&gt;onFailure&lt;/code&gt; が失敗した場合、onFailureが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="15eef2fb6be75cc68d0e3ddb99ea3d827fbcd3d5" translate="yes" xml:space="preserve">
          <source>When this response is normalized, Relay can detect that this result overlaps with existing data based on its &lt;code&gt;id&lt;/code&gt;. Rather than create a new record, Relay will update the existing &lt;code&gt;123&lt;/code&gt; record. The new &lt;code&gt;likeCount&lt;/code&gt; is therefore available to &lt;em&gt;both&lt;/em&gt; queries, as well as any other query that might reference this story.</source>
          <target state="translated">この応答が正規化されると、Relayはこの結果が &lt;code&gt;id&lt;/code&gt; に基づいて既存のデータと重複することを検出できます。新しいレコードを作成するのではなく、Relayは既存の &lt;code&gt;123&lt;/code&gt; レコードを更新します。したがって、新しい &lt;code&gt;likeCount&lt;/code&gt; は&lt;em&gt;両方の&lt;/em&gt;クエリだけでなく、このストーリーを参照する可能性のある他のクエリでも使用できます。</target>
        </trans-unit>
        <trans-unit id="30790e3c432f6503a40e8e00ea839d4b3685867b" translate="yes" xml:space="preserve">
          <source>When upgrading an existing Relay app, replace all &lt;code&gt;require('react-relay')&lt;/code&gt; with &lt;code&gt;require('react-relay/classic')&lt;/code&gt; to continue to import the Relay Classic API.</source>
          <target state="translated">既存のRelayアプリをアップグレードするときは、すべての &lt;code&gt;require('react-relay')&lt;/code&gt; を &lt;code&gt;require('react-relay/classic')&lt;/code&gt; に置き換えて、Relay Classic APIのインポートを続行します。</target>
        </trans-unit>
        <trans-unit id="880864fa4e14c5e5caab7b10626e640aee6def2a" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt;, the restrictions on queries from Relay Classic are removed: queries may contain multiple root fields that use arbitrary arguments and return singular or plural values. The &lt;code&gt;viewer&lt;/code&gt; root field is now optional.</source>
          <target state="translated">&lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt;を使用すると、Relay Classicからのクエリの制限がなくなります。クエリには、任意の引数を使用して単数または複数の値を返す複数のルートフィールドが含まれる場合があります。 &lt;code&gt;viewer&lt;/code&gt; ルートフィールドはオプションになりました。</target>
        </trans-unit>
        <trans-unit id="eec48adcf595a6ca86caad379b181d97a2f010ca" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;pagination-container&quot;&gt;Pagination Container&lt;/a&gt;, Relay expects connection fields to be annotated with a &lt;code&gt;@connection&lt;/code&gt; directive. For more detailed information and an example, check out the &lt;a href=&quot;pagination-container#connection&quot;&gt;docs on using &lt;code&gt;@connection&lt;/code&gt; inside a Pagination Container&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pagination-container&quot;&gt;Pagination Container&lt;/a&gt;を使用する場合、Relayは、接続フィールドに &lt;code&gt;@connection&lt;/code&gt; ディレクティブの注釈が付けられることを想定しています。詳細と例については&lt;a href=&quot;pagination-container#connection&quot;&gt;、ページ&lt;/a&gt; &lt;code&gt;@connection&lt;/code&gt; コンテナ内での@connectionの使用に関するドキュメントを確認してください。</target>
        </trans-unit>
        <trans-unit id="bdabb7b5c56a4bc287f21143e07d2eb721a2af6c" translate="yes" xml:space="preserve">
          <source>When you provide these functions, this is roughly what happens during the mutation request:</source>
          <target state="translated">これらの関数を提供すると、突然変異のリクエストの間に大体こんなことが起こります。</target>
        </trans-unit>
        <trans-unit id="384e273feee00773d8ac2cb8c10110ccc823425a" translate="yes" xml:space="preserve">
          <source>Whenever Relay is fulfilling data requirements, it can be useful to know when certain events occur. For example, we might want to record how long it takes for data to be available, or we might want to log errors to the server. These events are available on most Relay APIs via the &lt;code&gt;onReadyStateChange&lt;/code&gt; callback.</source>
          <target state="translated">リレーがデータ要件を満たしている場合は常に、特定のイベントがいつ発生したかを知ることは有用です。たとえば、データが利用可能になるまでにかかる時間を記録したり、サーバーにエラーを記録したりできます。これらのイベントは、 &lt;code&gt;onReadyStateChange&lt;/code&gt; コールバックを介してほとんどのリレーAPIで使用できます。</target>
        </trans-unit>
        <trans-unit id="e8cd144d9041c40f96f66e2aa651ea3465a4503f" translate="yes" xml:space="preserve">
          <source>Wherever the inverse grammar serves you better, you can use &lt;code&gt;@skip(if: ...)&lt;/code&gt; instead of &lt;code&gt;@include(if: ...)&lt;/code&gt;.</source>
          <target state="translated">逆文法は、より良いあなたを提供していますどこに、あなたが使用することができます &lt;code&gt;@skip(if: ...)&lt;/code&gt; の代わりに &lt;code&gt;@include(if: ...)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f3e2838c0630aa2c4914a0c2d4e6ea23e0c95ac" translate="yes" xml:space="preserve">
          <source>Whether the request was aborted.</source>
          <target state="translated">リクエストが中止されたかどうか。</target>
        </trans-unit>
        <trans-unit id="422efd22184fb3e6c495b98266ee159c3842165d" translate="yes" xml:space="preserve">
          <source>While typically Relay only provides the data for fields explicitly requested by a component's fragment, &lt;code&gt;@relay(mask: false)&lt;/code&gt; can be added to a fragment spread to not mask that data, recursively including the data from the fields of the referenced fragment.</source>
          <target state="translated">通常、Relayはコンポーネントのフラグメントによって明示的に要求されたフィールドのデータのみを提供しますが、 &lt;code&gt;@relay(mask: false)&lt;/code&gt; をフラグメントスプレッドに追加して、そのデータをマスクせず、参照フラグメントのフィールドからのデータを再帰的に含めることができます。</target>
        </trans-unit>
        <trans-unit id="ff506c81a21b554c2790ef2e5a963a42aff57850" translate="yes" xml:space="preserve">
          <source>While you type queries as follows:</source>
          <target state="translated">以下のようにクエリを入力しながら</target>
        </trans-unit>
        <trans-unit id="0b57cc238bcb966947c54d303e25a36f527aba7b" translate="yes" xml:space="preserve">
          <source>While you type queries as:</source>
          <target state="translated">としてクエリを入力している間。</target>
        </trans-unit>
        <trans-unit id="223f6c68b8dfddbadc2aa76589625320726b0252" translate="yes" xml:space="preserve">
          <source>Will cause a generated file to appear in &lt;code&gt;./__generated__/MyComponent.graphql&lt;/code&gt;, with both runtime artifacts (which help to read and write from the Relay Store) and &lt;a href=&quot;https://flow.org/&quot;&gt;Flow types&lt;/a&gt; to help you write type-safe code.</source>
          <target state="translated">生成されたファイルが &lt;code&gt;./__generated__/MyComponent.graphql&lt;/code&gt; に表示され、ランタイムアーティファクト（リレーストアからの読み取りと書き込みに役立ちます）と&lt;a href=&quot;https://flow.org/&quot;&gt;フロータイプの&lt;/a&gt;両方がタイプセーフコードの記述に役立ちます。</target>
        </trans-unit>
        <trans-unit id="8d32def387eb6db627a1048487211194f68d2887" translate="yes" xml:space="preserve">
          <source>With GraphQL it is very common for the results of multiple queries to overlap. However, our response cache from the previous section doesn't account for this overlap &amp;mdash; it caches based on distinct queries. For example, if we issue a query to fetch stories:</source>
          <target state="translated">GraphQLでは、複数のクエリの結果が重複することがよくあります。ただし、前のセクションの応答キャッシュでは、この重複を考慮していません。個別のクエリに基づいてキャッシュします。たとえば、ストーリーをフェッチするクエリを発行すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="326b4ac13e70484638c8e2c275bb7155ff73eafd" translate="yes" xml:space="preserve">
          <source>With a normalized response cache, a record would be created for each story in the list. The &lt;code&gt;stories&lt;/code&gt; field would store links to each of these records.</source>
          <target state="translated">正規化された応答キャッシュを使用すると、リスト内のストーリーごとにレコードが作成されます。 &lt;code&gt;stories&lt;/code&gt; フィールドは、これらのレコードのそれぞれへのリンクを格納します。</target>
        </trans-unit>
        <trans-unit id="9443a9eb3d5ff45b05255468c9ca88197b385e42" translate="yes" xml:space="preserve">
          <source>With some additional configuration, the &lt;code&gt;&quot;relay&quot;&lt;/code&gt; babel plugin can also translate Relay Classic &lt;code&gt;Relay.QL&lt;/code&gt; literals. Most importantly, include a reference to your GraphQL Schema as either a json file or graphql schema file.</source>
          <target state="translated">いくつかの追加構成により、 &lt;code&gt;&quot;relay&quot;&lt;/code&gt; バベルプラグインは、Relay Classic &lt;code&gt;Relay.QL&lt;/code&gt; リテラルも変換できます。最も重要なのは、GraphQLスキーマへの参照をjsonファイルまたはgraphqlスキーマファイルとして含めることです。</target>
        </trans-unit>
        <trans-unit id="b4fdf6745c6472ea632228aac1bf14006ef03d88" translate="yes" xml:space="preserve">
          <source>With the queries out of the way, let's start in on our only mutation: the one that spends a turn by checking a spot for treasure. Here, we define the input to the mutation (the id of a spot to check for treasure) and a list of all of the possible fields that the client might want updates about after the mutation has taken place. Finally, we implement a method that performs the underlying mutation.</source>
          <target state="translated">クエリはここまでにして、唯一の突然変異、つまり宝がある場所をチェックしてターンを過ごすものから始めてみましょう。ここでは、突然変異への入力 (トレジャーをチェックするスポットの ID)と、突然変異が行われた後にクライアントが更新を希望する可能性のあるすべてのフィールドのリストを定義します。最後に、基本となる突然変異を実行するメソッドを実装します。</target>
        </trans-unit>
        <trans-unit id="7ddd9cfe22f7c960a4c67535583b19ffb8497a42" translate="yes" xml:space="preserve">
          <source>With this input and payload, we can issue the following mutation:</source>
          <target state="translated">この入力とペイロードで、以下のような突然変異を発行することができます。</target>
        </trans-unit>
        <trans-unit id="dce3644542cd9fbd082b44d7cadd316ad1975d62" translate="yes" xml:space="preserve">
          <source>With typical approaches to data-fetching we found that it was common for two components to have &lt;em&gt;implicit dependencies&lt;/em&gt;. For example &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt; might use some data without directly ensuring that the data was fetched. This data would often be fetched by some other part of the system, such as &lt;code&gt;&amp;lt;Story /&amp;gt;&lt;/code&gt;. Then when we changed &lt;code&gt;&amp;lt;Story /&amp;gt;&lt;/code&gt; and removed that data-fetching logic, &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt; would suddenly and inexplicably break. These types of bugs are not always immediately apparent, especially in larger applications developed by larger teams. Manual and automated testing can only help so much: this is exactly the type of systematic problem that is better solved by a framework.</source>
          <target state="translated">データフェッチへの一般的なアプローチでは、2つのコンポーネントが&lt;em&gt;暗黙の依存関係&lt;/em&gt;を持つことが一般的であることがわかりました。たとえば、 &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt; は、データがフェッチされたことを直接確認せずに一部のデータを使用する場合があります。このデータは、多くの場合、 &lt;code&gt;&amp;lt;Story /&amp;gt;&lt;/code&gt; などのシステムの他の部分によってフェッチされます。次に、 &lt;code&gt;&amp;lt;Story /&amp;gt;&lt;/code&gt; を変更してそのデータフェッチロジックを削除すると、 &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt; が突然不可解に壊れてしまいました。これらのタイプのバグは、特に大規模なチームによって開発された大規模なアプリケーションでは、すぐに明らかになるとは限りません。手動および自動テストは非常に役立つだけです。これはまさに、フレームワークによってより適切に解決されるタイプの体系的な問題です。</target>
        </trans-unit>
        <trans-unit id="9e36e32aeb9398daa0c7117970d61b1237b724a3" translate="yes" xml:space="preserve">
          <source>With typical approaches to data-fetching we found that it was common for two components to have &lt;em&gt;implicit dependencies&lt;/em&gt;. For example &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; might use some data without directly ensuring that the data was fetched. This data would often be fetched by some other part of the system, such as &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt;. Then when we changed &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; and removed that data-fetching logic, &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; would suddenly and inexplicably break. These types of bugs are not always immediately apparent, especially in larger applications developed by larger teams. Manual and automated testing can only help so much: this is exactly the type of systematic problem that is better solved by a framework.</source>
          <target state="translated">データフェッチへの典型的なアプローチで、2つのコンポーネントが&lt;em&gt;暗黙的な依存関係&lt;/em&gt;を持つことが一般的であることがわかりました。たとえば、 &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; は、データがフェッチされたことを直接確認せずに一部のデータを使用する場合があります。このデータは、 &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; など、システムの他の部分によってフェッチされることがよくあります。次に、 &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; を変更してデータフェッチロジックを削除すると、 &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; が突然、不可解に破損します。これらのタイプのバグは、特に大規模なチームによって開発された大規模なアプリケーションでは、必ずしもすぐに明らかになるとは限りません。手動テストと自動テストは非常に役立ちます。これはまさに、フレームワークによって解決される体系的な問題のタイプです。</target>
        </trans-unit>
        <trans-unit id="d7a484140f5f9f7f5427e1f2c44dbfc1d3ad9eea" translate="yes" xml:space="preserve">
          <source>Workflow</source>
          <target state="translated">Workflow</target>
        </trans-unit>
        <trans-unit id="5c338a274513fe1f278459839f0c78f7e6b91728" translate="yes" xml:space="preserve">
          <source>Writing the game</source>
          <target state="translated">ゲームを書くこと</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="1696149c59259541ba3a1d3a3c3c107fc68c94e9" translate="yes" xml:space="preserve">
          <source>Yes*</source>
          <target state="translated">Yes*</target>
        </trans-unit>
        <trans-unit id="d38ce88b105c03a9bcdfa9b0ae57cef87a38afbe" translate="yes" xml:space="preserve">
          <source>You can also pass variables to the mutation's fragment builder from the outer fragment that contains it.</source>
          <target state="translated">また、変数を含む外部フラグメントから変異のフラグメントビルダーに渡すこともできます。</target>
        </trans-unit>
        <trans-unit id="2a3a0a2cf926b5e31314761fde4d2b924ad01e95" translate="yes" xml:space="preserve">
          <source>You can conditionally include or skip a field based on the value of a boolean variable.</source>
          <target state="translated">boolean変数の値に基づいて、条件付きでフィールドをインクルードしたりスキップしたりすることができます。</target>
        </trans-unit>
        <trans-unit id="e39e4e019fcddf87d5963ed450c0a585f3ac5a5c" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;InteractionManager&lt;/code&gt; on the &lt;a href=&quot;http://facebook.github.io/react-native/docs/interactionmanager.html&quot;&gt;React Native API docs&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;InteractionManager&lt;/code&gt; について詳しくは、&lt;a href=&quot;http://facebook.github.io/react-native/docs/interactionmanager.html&quot;&gt;React Native APIのドキュメントを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="1db4f1b561c182f757185de947874831706c7c3d" translate="yes" xml:space="preserve">
          <source>You can read more about the API &lt;a href=&quot;interfaces-relay-network-layer&quot;&gt;RelayNetworkLayer&lt;/a&gt; interface.</source>
          <target state="translated">API &lt;a href=&quot;interfaces-relay-network-layer&quot;&gt;RelayNetworkLayer&lt;/a&gt;インターフェースについて詳しく読むことができます。</target>
        </trans-unit>
        <trans-unit id="d3732e8bd7b74351797baa672d29727cc8e4b2f3" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;fetchQuery&lt;/code&gt; function to imperatively make GraphQL Requests. This is useful for cases where you want to make requests outside of React but still utilize the Relay store and network layer.</source>
          <target state="translated">&lt;code&gt;fetchQuery&lt;/code&gt; 関数を使用して、GraphQLリクエストを強制的に作成できます。これは、Reactの外部でリクエストを行いながら、Relayストアとネットワーク層を利用する場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="42ec8ab0bbfcf6ce2aa1efbd2295912061dec672" translate="yes" xml:space="preserve">
          <source>You don't have to mimic the entire response payload. Here, we've punted on the like sentence, since it's difficult to localize on the client side. When the server responds, Relay will treat its payload as the source of truth, but in the meantime, the optimistic response will be applied right away, allowing the people who use our product to enjoy instant feedback after having taken an action.</source>
          <target state="translated">レスポンスペイロード全体を真似る必要はありません。ここでは、クライアント側でローカライズするのが難しいため、ライクな文をパンクさせています。サーバが応答すると、Relayはそのペイロードを真実のソースとして扱いますが、その間、楽観的な応答がすぐに適用されるので、製品を使っている人は、アクションを起こした後の即時のフィードバックを楽しむことができます。</target>
        </trans-unit>
        <trans-unit id="db948a53ed55bdbbd4fa17526586780dad70f601" translate="yes" xml:space="preserve">
          <source>You have to implement your own cache strategy. A simple solution is to use &lt;code&gt;QueryResponseCache&lt;/code&gt; (an in-memory cache):</source>
          <target state="translated">独自のキャッシュ戦略を実装する必要があります。簡単な解決策は、 &lt;code&gt;QueryResponseCache&lt;/code&gt; （メモリ内キャッシュ）を使用することです。</target>
        </trans-unit>
        <trans-unit id="d1ae915d1a8b7fa12f92488b10423d30b2ad84e5" translate="yes" xml:space="preserve">
          <source>You will need to Configure your &lt;a href=&quot;networklayer&quot;&gt;Network&lt;/a&gt; to handle subscriptions. The below example uses &lt;a href=&quot;https://github.com/apollographql/subscriptions-transport-ws&quot;&gt;subscriptions-transport-ws&lt;/a&gt;:</source>
          <target state="translated">サブスクリプションを処理するように&lt;a href=&quot;networklayer&quot;&gt;ネットワーク&lt;/a&gt;を構成する必要があります。以下の例では、&lt;a href=&quot;https://github.com/apollographql/subscriptions-transport-ws&quot;&gt;subscriptions-transport-wsを&lt;/a&gt;使用しています。</target>
        </trans-unit>
        <trans-unit id="13eb998680ecc627ba04d1e2c348b212888c8f5b" translate="yes" xml:space="preserve">
          <source>[1] Note that GraphQL itself does not impose this constraint, and Relay Runtime may also be used for schemas that do not conform to it. For example, both systems can be used to query a single denormalized table. However, many of the features that Relay Runtime provides, such as caching and normalization, work best when the data is represented as a normalized graph with stable identities for discrete pieces of information.</source>
          <target state="translated">[1] GraphQL自体はこの制約を課さないことに注意してください。また、Relay Runtimeは、それに準拠していないスキーマにも使用される可能性があります。たとえば、両方のシステムを使用して、単一の非正規化テーブルを照会できます。ただし、キャッシュや正規化など、Relay Runtimeが提供する機能の多くは、データが個別の情報に対して安定したIDを持つ正規化されたグラフとして表される場合に最適に機能します。</target>
        </trans-unit>
        <trans-unit id="7dd3288de30464c56940d838b494bb246d25a587" translate="yes" xml:space="preserve">
          <source>an edge representing the new friend will be added to the viewer's &lt;code&gt;friends&lt;/code&gt; connection</source>
          <target state="translated">新しい友達を表すエッジが、視聴者の &lt;code&gt;friends&lt;/code&gt; 接続に追加されます</target>
        </trans-unit>
        <trans-unit id="33f0663df214f396a65e31c63ea1758c4a24ba18" translate="yes" xml:space="preserve">
          <source>an edge representing the viewer will be added to the new friend's &lt;code&gt;friends&lt;/code&gt; connection</source>
          <target state="translated">閲覧者を表すエッジが新しい友達の &lt;code&gt;friends&lt;/code&gt; 接続に追加されます</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="6a5703deebcf0535c19b19c1b0a27e8341e2ab4d" translate="yes" xml:space="preserve">
          <source>and then later refetch one of the stories whose &lt;code&gt;likeCount&lt;/code&gt; has since been incremented:</source>
          <target state="translated">そして、後で &lt;code&gt;likeCount&lt;/code&gt; がインクリメントされたストーリーの1つを再フェッチします。</target>
        </trans-unit>
        <trans-unit id="6abe6d9392071037cb6a695b9da8b68f203db531" translate="yes" xml:space="preserve">
          <source>and we get back</source>
          <target state="translated">で、元に戻る</target>
        </trans-unit>
        <trans-unit id="b74745ac136841f9501637f3fac7d913abeecf5d" translate="yes" xml:space="preserve">
          <source>and we'll get this result:</source>
          <target state="translated">で、このような結果になります。</target>
        </trans-unit>
        <trans-unit id="f30392ad1d35a35355bcc5ff5b7ab1c4aa4b6b4d" translate="yes" xml:space="preserve">
          <source>applyOptimistic</source>
          <target state="translated">applyOptimistic</target>
        </trans-unit>
        <trans-unit id="481baa434ed8570c01e3d78b4a058c1cea4ffea5" translate="yes" xml:space="preserve">
          <source>applyUpdate (static method)</source>
          <target state="translated">applyUpdate (staticメソッド)</target>
        </trans-unit>
        <trans-unit id="e0d9b66d001ce91f916cb04de6514301d4191e1e" translate="yes" xml:space="preserve">
          <source>babel-plugin-relay</source>
          <target state="translated">babel-plugin-relay</target>
        </trans-unit>
        <trans-unit id="804dd7a640e28824ae34b133455831c85cafaa66" translate="yes" xml:space="preserve">
          <source>both people's friend count will increment</source>
          <target state="translated">両者のフレンド数が増加します</target>
        </trans-unit>
        <trans-unit id="4015b57a143aec5156fd1444a017a32137a3fd0f" translate="yes" xml:space="preserve">
          <source>commit</source>
          <target state="translated">commit</target>
        </trans-unit>
        <trans-unit id="ef1bbfb7f634722c33aa4d7f3c325a4a29ea88d1" translate="yes" xml:space="preserve">
          <source>commitUpdate (static method)</source>
          <target state="translated">コミットアップ</target>
        </trans-unit>
        <trans-unit id="8a1c1339801686eb9bf9a9ac5b4719b8c8b8fc9b" translate="yes" xml:space="preserve">
          <source>constructor</source>
          <target state="translated">constructor</target>
        </trans-unit>
        <trans-unit id="4b45c519aa27393b323501edc492900dac1e0a96" translate="yes" xml:space="preserve">
          <source>create (static method)</source>
          <target state="translated">創る</target>
        </trans-unit>
        <trans-unit id="db646ca2b7d259a49537f70fff30ff3c2c3c18c5" translate="yes" xml:space="preserve">
          <source>createContainer (static method)</source>
          <target state="translated">クリエイトコンテナ</target>
        </trans-unit>
        <trans-unit id="2b28d0e79db5f9b1637a6d02fd886e0beb0a2a87" translate="yes" xml:space="preserve">
          <source>createWithFiles (static method)</source>
          <target state="translated">クリエイトウィズファイル(静的メソッド</target>
        </trans-unit>
        <trans-unit id="42cdc1d74453884d8861396360329db1f2583a19" translate="yes" xml:space="preserve">
          <source>fetchQuery</source>
          <target state="translated">fetchQuery</target>
        </trans-unit>
        <trans-unit id="da32c19d5a974ead91be2f8fa59b4a9c03db9888" translate="yes" xml:space="preserve">
          <source>forceFetch</source>
          <target state="translated">forceFetch</target>
        </trans-unit>
        <trans-unit id="446ce95fe1412056ff2efb4a2eddeb9b14b5b57b" translate="yes" xml:space="preserve">
          <source>fragments</source>
          <target state="translated">fragments</target>
        </trans-unit>
        <trans-unit id="348bf71ffb0d4407dbcecd15dd012e9ca4e50ec6" translate="yes" xml:space="preserve">
          <source>fragments (static property)</source>
          <target state="translated">フラグメント</target>
        </trans-unit>
        <trans-unit id="c7051a4ed355bcc5e03ff249da8ad3c8d98795de" translate="yes" xml:space="preserve">
          <source>getCollisionKey</source>
          <target state="translated">getCollisionKey</target>
        </trans-unit>
        <trans-unit id="9b9964fe7f200e2d2d723f2ce25c45e685f31c1a" translate="yes" xml:space="preserve">
          <source>getConfigs (abstract method)</source>
          <target state="translated">ゲットコンフィグ</target>
        </trans-unit>
        <trans-unit id="1af4f339fc74cdc2a2f63e9dec4d5c78820395ab" translate="yes" xml:space="preserve">
          <source>getDataID(): &lt;a href=&quot;https://github.com/facebook/relay/blob/d0310d69012bba615dacf614319bcf47ee2a0f3f/packages/relay-runtime/ARCHITECTURE.md&quot;&gt;DataID&lt;/a&gt;</source>
          <target state="translated">getDataID（）：&lt;a href=&quot;https://github.com/facebook/relay/blob/d0310d69012bba615dacf614319bcf47ee2a0f3f/packages/relay-runtime/ARCHITECTURE.md&quot;&gt;データID&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0405ea062abe8cd4a0d287f9154a09079dc4bb4d" translate="yes" xml:space="preserve">
          <source>getDebugName</source>
          <target state="translated">getDebugName</target>
        </trans-unit>
        <trans-unit id="327b4db9411eb5735cd4d613988bd27603d51f28" translate="yes" xml:space="preserve">
          <source>getFatQuery (abstract method)</source>
          <target state="translated">getFatQuery(抽象メソッド</target>
        </trans-unit>
        <trans-unit id="97f9623a23d5717ffebb67278d55b1afd1ffd725" translate="yes" xml:space="preserve">
          <source>getFiles</source>
          <target state="translated">getFiles</target>
        </trans-unit>
        <trans-unit id="1778700a36f50cd423696eb753bb860799ac9b24" translate="yes" xml:space="preserve">
          <source>getFragment</source>
          <target state="translated">getFragment</target>
        </trans-unit>
        <trans-unit id="d7c3b79969b5a91a9a376dcbffb251e4515b3ce9" translate="yes" xml:space="preserve">
          <source>getFragment (static method)</source>
          <target state="translated">getFragment(静的メソッド</target>
        </trans-unit>
        <trans-unit id="e8166bd4ce0d5f8fe076afeb9c45240cc7d5f2b5" translate="yes" xml:space="preserve">
          <source>getID</source>
          <target state="translated">getID</target>
        </trans-unit>
        <trans-unit id="a73db9be39fc73bb1d8a15f030515c436d5a3453" translate="yes" xml:space="preserve">
          <source>getLinkedRecord(name: string, args?: ?Variables): ?RecordProxy</source>
          <target state="translated">getLinkedRecord(name:string,args?</target>
        </trans-unit>
        <trans-unit id="88377de01a531764c854a5d87458832e26bb6d7d" translate="yes" xml:space="preserve">
          <source>getLinkedRecords(name: string, args?: ?Variables): ?Array&amp;lt;?RecordProxy&amp;gt;</source>
          <target state="translated">getLinkedRecords（name：string、args ?:？Variables）：？Array &amp;lt;？RecordProxy&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d7fde427ab020029d422a06dc9a3f3cf60a0f286" translate="yes" xml:space="preserve">
          <source>getMutation (abstract method)</source>
          <target state="translated">ゲットミュテーション</target>
        </trans-unit>
        <trans-unit id="c3d4160e6945293e656522a92a11fe8535c041eb" translate="yes" xml:space="preserve">
          <source>getOptimisticConfigs</source>
          <target state="translated">getOptimisticConfigs</target>
        </trans-unit>
        <trans-unit id="e35ed410633190979352fe6ee6d4d885c8a18598" translate="yes" xml:space="preserve">
          <source>getOptimisticResponse</source>
          <target state="translated">getOptimisticResponse</target>
        </trans-unit>
        <trans-unit id="6bd679f8ef0f8733bd010559ff42cbedeb5983bf" translate="yes" xml:space="preserve">
          <source>getOrCreateLinkedRecord(name: string, typeName: string, args?: ?Variables ): RecordProxy</source>
          <target state="translated">getOrCreateLinkedRecord(name:string,typeName:string,args?)レコードプロキシ</target>
        </trans-unit>
        <trans-unit id="759956d4899d707dd6a33742489f969212a28756" translate="yes" xml:space="preserve">
          <source>getPendingTransactions</source>
          <target state="translated">getPendingTransactions</target>
        </trans-unit>
        <trans-unit id="5531a9db2f3b83555a0eff0afe4a7b4598c8f0de" translate="yes" xml:space="preserve">
          <source>getQueryString</source>
          <target state="translated">getQueryString</target>
        </trans-unit>
        <trans-unit id="5b70bfc75fe69a0ac1b8cf3046235fbb64e40599" translate="yes" xml:space="preserve">
          <source>getRootField(fieldName: string): ?RecordProxy</source>
          <target state="translated">getRootField(fieldName:string):?RecordProxy</target>
        </trans-unit>
        <trans-unit id="ab14bf198ad6c14dda7ba6cd7afe5b74fddbdc2e" translate="yes" xml:space="preserve">
          <source>getSource(): &lt;a href=&quot;https://github.com/facebook/relay/blob/d0310d69012bba615dacf614319bcf47ee2a0f3f/packages/relay-runtime/ARCHITECTURE.md&quot;&gt;RecordSource&lt;/a&gt;</source>
          <target state="translated">getSource（）：&lt;a href=&quot;https://github.com/facebook/relay/blob/d0310d69012bba615dacf614319bcf47ee2a0f3f/packages/relay-runtime/ARCHITECTURE.md&quot;&gt;RecordSource&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="264cb99bbdb88c3a503a7cd09445ab43ad54af52" translate="yes" xml:space="preserve">
          <source>getType(): RelayQLType</source>
          <target state="translated">を使用しています。RelayQLType</target>
        </trans-unit>
        <trans-unit id="f5807036ab312a725491c64183d61cf7b9babe1d" translate="yes" xml:space="preserve">
          <source>getValue(name: string, args?: ?Variables): mixed</source>
          <target state="translated">getValue(name:string,args?</target>
        </trans-unit>
        <trans-unit id="43f55a80a8e191422ce37e5ebd8264867fc6316d" translate="yes" xml:space="preserve">
          <source>getVariables</source>
          <target state="translated">getVariables</target>
        </trans-unit>
        <trans-unit id="4349f8288befeff38404853658acf2b002ad2746" translate="yes" xml:space="preserve">
          <source>getVariables (abstract method)</source>
          <target state="translated">ゲット変数</target>
        </trans-unit>
        <trans-unit id="3cfab35ae11b2420cf0d4e4900fa11d44d7f4976" translate="yes" xml:space="preserve">
          <source>gives us</source>
          <target state="translated">私達に与えられた</target>
        </trans-unit>
        <trans-unit id="9fdcc7f29c59e6f9abaaab32c0a1a15b1b78226b" translate="yes" xml:space="preserve">
          <source>graphql</source>
          <target state="translated">graphql</target>
        </trans-unit>
        <trans-unit id="dde2cfc8d1d2de804008dfc4836831a0eccb8444" translate="yes" xml:space="preserve">
          <source>hasOptimisticUpdate</source>
          <target state="translated">hasOptimisticUpdate</target>
        </trans-unit>
        <trans-unit id="a205cb3bee524195c2fdce6610a417b6853a4c32" translate="yes" xml:space="preserve">
          <source>initialVariables</source>
          <target state="translated">initialVariables</target>
        </trans-unit>
        <trans-unit id="4bfbc265fe484eac76b0500e386617d6cf0e573e" translate="yes" xml:space="preserve">
          <source>initialVariables (static property)</source>
          <target state="translated">イニシャル変数</target>
        </trans-unit>
        <trans-unit id="04dcd4fb3277dbb1127599ff7d32d5684b6a02dc" translate="yes" xml:space="preserve">
          <source>injectNetworkLayer (static method)</source>
          <target state="translated">インジェクションネットワークレイヤー</target>
        </trans-unit>
        <trans-unit id="0a776c5ca0800d03ca78f47f75e9eb834365d304" translate="yes" xml:space="preserve">
          <source>injectTaskScheduler (static method)</source>
          <target state="translated">インジェクションタスクスケジューラー</target>
        </trans-unit>
        <trans-unit id="bc813ae20708b8a347a4d53fb6e91311ea7bb33d" translate="yes" xml:space="preserve">
          <source>isContainer (static method)</source>
          <target state="translated">isContainer(静的メソッド</target>
        </trans-unit>
        <trans-unit id="c53397edd355fc4e2d006653db94583eef513e6f" translate="yes" xml:space="preserve">
          <source>onReadyStateChange</source>
          <target state="translated">onReadyStateChange</target>
        </trans-unit>
        <trans-unit id="fb05074bc118e549bee00caf3b25aeedd2a23fb9" translate="yes" xml:space="preserve">
          <source>or: &lt;code&gt;this.props.relay.refetch({}, {}, callback, {force: true})&lt;/code&gt; in a Refetch Container</source>
          <target state="translated">又は： &lt;code&gt;this.props.relay.refetch({}, {}, callback, {force: true})&lt;/code&gt; 再フェッチコンテナで</target>
        </trans-unit>
        <trans-unit id="00525d7718b6def384814a704d781fd95161b685" translate="yes" xml:space="preserve">
          <source>paramDefinitions (static property)</source>
          <target state="translated">paramDefinitions(静的プロパティ</target>
        </trans-unit>
        <trans-unit id="ab47b8a712d90d33736ca95a21ffd78e2edcbc43" translate="yes" xml:space="preserve">
          <source>pendingVariables</source>
          <target state="translated">pendingVariables</target>
        </trans-unit>
        <trans-unit id="46070ca5b7bac4a677b32597aa968e6707fb2947" translate="yes" xml:space="preserve">
          <source>prepareParams (static property)</source>
          <target state="translated">prepareParams (static property)</target>
        </trans-unit>
        <trans-unit id="4c8dd8321c7f8e03d9a33e3aac495748a5310da1" translate="yes" xml:space="preserve">
          <source>prepareVariables</source>
          <target state="translated">prepareVariables</target>
        </trans-unit>
        <trans-unit id="6399eda44b9a365d9ef2884378c34b3d150ac371" translate="yes" xml:space="preserve">
          <source>prepareVariables (static property)</source>
          <target state="translated">prepareVariables (static property)</target>
        </trans-unit>
        <trans-unit id="d32d93402de4dcb749f059cba43572aa23bd03dc" translate="yes" xml:space="preserve">
          <source>queries (static property)</source>
          <target state="translated">クエリ</target>
        </trans-unit>
        <trans-unit id="9dc632a4888b695f2a771b203d0887d10714caef" translate="yes" xml:space="preserve">
          <source>react-relay/classic</source>
          <target state="translated">react-relay/classic</target>
        </trans-unit>
        <trans-unit id="37eca5751d1f6d7dfe5688efc6d86da3dd09c16f" translate="yes" xml:space="preserve">
          <source>render</source>
          <target state="translated">render</target>
        </trans-unit>
        <trans-unit id="62f23262fcec4cdc5eb17faabb63e059d6950930" translate="yes" xml:space="preserve">
          <source>renderFailure</source>
          <target state="translated">renderFailure</target>
        </trans-unit>
        <trans-unit id="2afd39a75e88681d175b8553ff1dce06613384a5" translate="yes" xml:space="preserve">
          <source>renderFetched</source>
          <target state="translated">renderFetched</target>
        </trans-unit>
        <trans-unit id="5e3932629379610ab259e44527d32162c9392f0b" translate="yes" xml:space="preserve">
          <source>renderLoading</source>
          <target state="translated">renderLoading</target>
        </trans-unit>
        <trans-unit id="414e681ebabcd2f23de1f32468992b9c81c5f909" translate="yes" xml:space="preserve">
          <source>returns</source>
          <target state="translated">returns</target>
        </trans-unit>
        <trans-unit id="ff3a6f3b41f1c1e00b77429034bc912cfa7dd364" translate="yes" xml:space="preserve">
          <source>rollback</source>
          <target state="translated">rollback</target>
        </trans-unit>
        <trans-unit id="fc166eb81361ff31179cd3c83da3bfe088b851d3" translate="yes" xml:space="preserve">
          <source>route</source>
          <target state="translated">route</target>
        </trans-unit>
        <trans-unit id="e1d71ee40db65de4abc60e598cad15a41923e787" translate="yes" xml:space="preserve">
          <source>routeName (static property)</source>
          <target state="translated">ルート名(静的プロパティ</target>
        </trans-unit>
        <trans-unit id="9f1125a04ebb1449bdd323a60a2950db5accfb80" translate="yes" xml:space="preserve">
          <source>sendMutation</source>
          <target state="translated">sendMutation</target>
        </trans-unit>
        <trans-unit id="435568d9e02408d6788ecdc6be513d72ccc6cb61" translate="yes" xml:space="preserve">
          <source>sendQueries</source>
          <target state="translated">sendQueries</target>
        </trans-unit>
        <trans-unit id="2880123c67d1aaedb821f0f247cd4c6c4345aab8" translate="yes" xml:space="preserve">
          <source>setLinkedRecord(record: RecordProxy, name: string, args?: ?Variables): RecordProxy</source>
          <target state="translated">setLinkedRecord(record:RecordProxy,name:string,args?)レコードプロキシ</target>
        </trans-unit>
        <trans-unit id="7dc0722d5b1e977d588c3edf8515b019e788c174" translate="yes" xml:space="preserve">
          <source>setLinkedRecords(records: Array&amp;lt;?RecordProxy&amp;gt;, name: string, args?: ?Variables ): RecordProxy</source>
          <target state="translated">setLinkedRecords（records：Array &amp;lt;？RecordProxy&amp;gt;、name：string、args ?:？Variables）：RecordProxy</target>
        </trans-unit>
        <trans-unit id="9a58f84fd8486e41fd7dcfc4d34aa90c06019e22" translate="yes" xml:space="preserve">
          <source>setValue(value: mixed, name: string, args?: ?Variables): RecordProxy</source>
          <target state="translated">setValue(value:mixed,name:string,args?)レコードプロキシ</target>
        </trans-unit>
        <trans-unit id="5548ee17e1e709bc17eb0b6bc474907bee14447b" translate="yes" xml:space="preserve">
          <source>setVariables</source>
          <target state="translated">setVariables</target>
        </trans-unit>
        <trans-unit id="ae2633f3722560d2ad1ff74c21f50ef81ea6b153" translate="yes" xml:space="preserve">
          <source>shouldComponentUpdate</source>
          <target state="translated">shouldComponentUpdate</target>
        </trans-unit>
        <trans-unit id="8a14711da8b864c0b88fb3fe7e873c0b2894566e" translate="yes" xml:space="preserve">
          <source>supports</source>
          <target state="translated">supports</target>
        </trans-unit>
        <trans-unit id="09e391d372ecf222949d736538e76db78674604a" translate="yes" xml:space="preserve">
          <source>the viewer's friendship status with the requester will change</source>
          <target state="translated">依頼元との友好度が変化する</target>
        </trans-unit>
        <trans-unit id="bc5af2310c7f15770a4ed0028648ce367e3e2ec0" translate="yes" xml:space="preserve">
          <source>variables</source>
          <target state="translated">variables</target>
        </trans-unit>
        <trans-unit id="87a0de569c57d54d8721ab12b504cc0797b8a57b" translate="yes" xml:space="preserve">
          <source>with these params:</source>
          <target state="translated">これらのパラメータを使用しています。</target>
        </trans-unit>
        <trans-unit id="edb0f5b1f639a3886e3180c47fe86c3a6a263842" translate="yes" xml:space="preserve">
          <source>yields</source>
          <target state="translated">yields</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
