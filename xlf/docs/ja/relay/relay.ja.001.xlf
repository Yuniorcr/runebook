<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="relay">
    <body>
      <group id="relay">
        <trans-unit id="f9287b3fad8f092d74f4ec6aadb5a29cf9ba2e63" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2013&amp;ndash;present Facebook Inc.</source>
          <target state="translated">&amp;copy;2013&amp;ndash;present Facebook Inc.</target>
        </trans-unit>
        <trans-unit id="ac2bb4599b07dd7b4cea35d8e273b367c0b66305" translate="yes" xml:space="preserve">
          <source>* Modern API doesn't support mutation fragments. You might have to inline the mutation fragments from your legacy mutation in the fragment of the component.</source>
          <target state="translated">*最新のAPIは変異フラグメントをサポートしていません。コンポーネントのフラグメントにある従来のミューテーションのミューテーションフラグメントをインライン化する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="c225bfc176636425ea153120adefbee642d75cea" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;fragment-container&quot;&gt;&lt;code&gt;createFragmentContainer&lt;/code&gt;&lt;/a&gt; returns a basic container that cannot fetch additional data beyond what is declared in its fragment(s). Relay Modern also provides more advanced containers for dynamic use cases (which were previously handled in Relay Classic via &lt;code&gt;setVariables&lt;/code&gt;):</source>
          <target state="translated">&lt;a href=&quot;fragment-container&quot;&gt; &lt;code&gt;createFragmentContainer&lt;/code&gt; &lt;/a&gt;は、フラグメントで宣言されている以上の追加データをフェッチできない基本的なコンテナーを返します。Relay Modernは、動的なユースケース（以前はRelay Classicで &lt;code&gt;setVariables&lt;/code&gt; を介して処理されていました）のためのより高度なコンテナーも提供しています。</target>
        </trans-unit>
        <trans-unit id="77688ea0d1fdf22bab3df470e72bfe7de6cb4724" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://chrome.google.com/webstore/detail/relay-devtools/oppikflppfjfdpjimpdadhelffjpciba&quot;&gt;Chrome Extension&lt;/a&gt; creates a Relay tab in the developer tools interface for debugging apps in Chrome</source>
          <target state="translated">&lt;a href=&quot;https://chrome.google.com/webstore/detail/relay-devtools/oppikflppfjfdpjimpdadhelffjpciba&quot;&gt;Chrome拡張機能&lt;/a&gt;は、Chromeでアプリをデバッグするための開発者ツールインターフェイスにリレータブを作成します</target>
        </trans-unit>
        <trans-unit id="fad91719b9218a6ae11551221b84fc32086535ed" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; allows views to be defined as components where every component is responsible for rendering a part of the UI. Composing other components is how to build complex UIs. Each React component doesn't need to know the inner workings of the composed components.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt;では、ビューをコンポーネントとして定義でき、すべてのコンポーネントがUIの一部のレンダリングを担当します。他のコンポーネントの構成は、複雑なUIを構築する方法です。各Reactコンポーネントは、構成されたコンポーネントの内部動作を知る必要はありません。</target>
        </trans-unit>
        <trans-unit id="a1980b0d9659b15299523fce23afa9e64733250c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/relayjs/relay-debugger/tree/master/react-native-shell&quot;&gt;Electron App&lt;/a&gt; that connects to React Native apps running Relay</source>
          <target state="translated">&lt;a href=&quot;https://github.com/relayjs/relay-debugger/tree/master/react-native-shell&quot;&gt;&lt;/a&gt;Relayを実行するReact Nativeアプリに接続するElectronアプリ</target>
        </trans-unit>
        <trans-unit id="0f80ef8cc2241c7509e6613ced8779935dc25b6f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt; manages the execution of the GraphQL query. It sends the query with given variables, parses the response, saves the data to the internal cache, and finally renders the view.</source>
          <target state="translated">&lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt;は、GraphQLクエリの実行を管理します。指定された変数を使用してクエリを送信し、応答を解析して、データを内部キャッシュに保存し、最後にビューをレンダリングします。</target>
        </trans-unit>
        <trans-unit id="cfac86ab065f686a94d7eabf085884e964606374" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;refetch-container&quot;&gt;&lt;code&gt;createRefetchContainer&lt;/code&gt;&lt;/a&gt; is a variation of &lt;code&gt;createFragmentContainer&lt;/code&gt; that addresses the &quot;see more&quot; use case, where a subset of data is rendered initially and then additional data is fetched on demand. Refetch containers initially fetch data for their fragments just like fragment containers, but also offer a &lt;code&gt;refetch()&lt;/code&gt; method by which additional data can be fetched, or the container can be re-rendered to read data using different variables.</source>
          <target state="translated">&lt;a href=&quot;refetch-container&quot;&gt; &lt;code&gt;createRefetchContainer&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;createFragmentContainer&lt;/code&gt; のバリエーションであり、データのサブセットが最初にレンダリングされ、その後、追加のデータがオンデマンドでフェッチされる「もっと見る」ユースケースに対処します。再フェッチコンテナーは、最初はフラグメントコンテナーと同じようにフラグメントのデータをフェッチしますが、追加のデータをフェッチしたり、コンテナーを再レンダリングしてさまざまな変数を使用してデータを読み取ったりできる &lt;code&gt;refetch()&lt;/code&gt; メソッドも提供します。</target>
        </trans-unit>
        <trans-unit id="f6f0afa9606f188df5aa2880a96f0796da66589e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;relay-compat&quot;&gt;Compat mode&lt;/a&gt; allows the Relay Modern APIs to be incrementally adopted in an existing Relay app. This approach enables the following features compared to Relay Classic:</source>
          <target state="translated">&lt;a href=&quot;relay-compat&quot;&gt;互換モードで&lt;/a&gt;は、Relay Modern APIを既存のRelayアプリで段階的に採用できます。このアプローチでは、Relay Classicと比較して次の機能が有効になります。</target>
        </trans-unit>
        <trans-unit id="3cc7b1d6acf9a6a36373b7d2788a819c007a696a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; receives a &lt;code&gt;user&lt;/code&gt; prop with plain JavaScript data - objects, arrays, strings - and renders as usual.</source>
          <target state="translated">&lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; は、プレーンなJavaScriptデータ（オブジェクト、配列、文​​字列）を含む &lt;code&gt;user&lt;/code&gt; プロップを受け取り、通常どおりレンダリングします。</target>
        </trans-unit>
        <trans-unit id="115b4c121f9af58bd42ac1ea726c7c948a8dafc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@connection&lt;/code&gt; directive</source>
          <target state="translated">&lt;code&gt;@connection&lt;/code&gt; ディレクティブ</target>
        </trans-unit>
        <trans-unit id="b5d3bbc3f0308d432f9237679fd4198f106ffc51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COLLISION_COMMIT_FAILED&lt;/code&gt; &amp;mdash; Transaction was queued for commit but another transaction with the same collision key failed. All transactions in the collision queue, including this one, have been failed. Transaction can be recommitted or rolled back.</source>
          <target state="translated">&lt;code&gt;COLLISION_COMMIT_FAILED&lt;/code&gt; &amp;mdash;トランザクションはコミットのキューに入れられましたが、同じ衝突キーを持つ別のトランザクションが失敗しました。これを含む、衝突キュー内のすべてのトランザクションが失敗しました。トランザクションは再コミットまたはロールバックできます。</target>
        </trans-unit>
        <trans-unit id="8093d07e77e9be3790d54f76445c918f46849774" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COMMITTING&lt;/code&gt; &amp;mdash; Transaction is waiting for the server to respond.</source>
          <target state="translated">&lt;code&gt;COMMITTING&lt;/code&gt; &amp;mdash;トランザクションはサーバーの応答を待っています。</target>
        </trans-unit>
        <trans-unit id="72fc89ccfca88827066da906d579a404ab74ce01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COMMIT_FAILED&lt;/code&gt; &amp;mdash; Transaction was sent to the server for comitting but failed.</source>
          <target state="translated">&lt;code&gt;COMMIT_FAILED&lt;/code&gt; &amp;mdash; コミットのためにトランザクションがサーバーに送信されましたが、失敗しました。</target>
        </trans-unit>
        <trans-unit id="3ea90f9f79de8b7da5c3c317bc9a5b13f75106bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COMMIT_QUEUED&lt;/code&gt; &amp;mdash; Transaction was committed but another transaction with the same collision key is pending, so the transaction has been queued to send to the server.</source>
          <target state="translated">&lt;code&gt;COMMIT_QUEUED&lt;/code&gt; &amp;mdash;トランザクションはコミットされましたが、同じ衝突キーを持つ別のトランザクションが保留になっているため、トランザクションはサーバーに送信するためにキューに入れられました。</target>
        </trans-unit>
        <trans-unit id="1f3d026fc6b13bd99ef80b56496208f62a08c9dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Component&lt;/code&gt; Relay container that defines fragments and the view to render.</source>
          <target state="translated">&lt;code&gt;Component&lt;/code&gt; フラグメントとレンダリングするビューを定義するコンポーネントリレーコンテナー。</target>
        </trans-unit>
        <trans-unit id="bfead01c2b218e3cb68f309d9651d5634bcc584a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Container&lt;/code&gt; Relay container that defines fragments and the view to render.</source>
          <target state="translated">&lt;code&gt;Container&lt;/code&gt; フラグメントとレンダリングするビューを定義するコンテナリレーコンテナ。</target>
        </trans-unit>
        <trans-unit id="d52ff52d23e6ad23c71ab30789b670011882899f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PaginationContainer&lt;/code&gt; is designed to simplify the workflow of loading more items in a list -- in many cases, we don't want to fetch all the data at once but lazily load more data. It relies on a GraphQL server exposing connections in a standardized way. For a detailed spec, please check out &lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;this page&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;PaginationContainer&lt;/code&gt; は、リスト内のより多くのアイテムをロードするワークフローを簡略化するように設計されています。多くの場合、一度にすべてのデータをフェッチするのではなく、より多くのデータを遅延ロードします。標準化された方法で接続を公開するGraphQLサーバーに依存しています。詳細な仕様については、&lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;こちらのページをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c5406da34447a5b22b7d56f6fce92e419b505424" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;QueryRenderer&lt;/code&gt; is the root of a Relay tree. It takes a query, fetches the data and calls the &lt;code&gt;render&lt;/code&gt; callback with the data.</source>
          <target state="translated">&lt;code&gt;QueryRenderer&lt;/code&gt; は、リレーツリーのルートです。クエリを受け取り、データをフェッチして、データを &lt;code&gt;render&lt;/code&gt; コールバックを呼び出します。</target>
        </trans-unit>
        <trans-unit id="593061a9841e95181922e32bf061e078ec44605a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;QueryRenderer&lt;/code&gt; supports rendering small amounts of data directly, instead of requiring a container to access data. &lt;a href=&quot;fragment-container&quot;&gt;Containers&lt;/a&gt; are optional and can be used as your application grows in size and complexity.</source>
          <target state="translated">&lt;code&gt;QueryRenderer&lt;/code&gt; は、コンテナーがデータにアクセスすることを要求する代わりに、少量のデータを直接レンダリングすることをサポートします。&lt;a href=&quot;fragment-container&quot;&gt;コンテナ&lt;/a&gt;はオプションであり、アプリケーションのサイズと複雑さが大きくなるにつれて使用できます。</target>
        </trans-unit>
        <trans-unit id="5dcadb6bea3b3b49c5e438342092e725abab0a3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; doesn't provide any bells and whistles such as fat queries or tracked queries (that is, automatic synthesis at runtime of the mutation query to be sent to the server), instead having the user define a static and explicit query. Restricting yourself to the low-level API is a useful preparatory step that will help you ready your codebase for migration to the new static Relay core. In the meantime, if you want those dynamic features, you can opt in to the higher-level &lt;code&gt;Relay.Mutation&lt;/code&gt; API.</source>
          <target state="translated">&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; は、ファットクエリや追跡されたクエリ（つまり、サーバーに送信されるミューテーションクエリの実行時に自動合成）などの機能を提供せず、ユーザーに静的で明示的なクエリを定義させます。低レベルAPIに制限することは、新しい静的リレーコアに移行するためのコードベースの準備に役立つ便利な準備手順です。それまでの間、これらの動的機能が必要な場合は、より高レベルの &lt;code&gt;Relay.Mutation&lt;/code&gt; APIをオプトインできます。</target>
        </trans-unit>
        <trans-unit id="b9dbe21f8c1dda099d24350958022ccc0bb3f410" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; is a low-level API for modeling a GraphQL mutation.</source>
          <target state="translated">&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; は、GraphQLミューテーションをモデリングするための低レベルAPIです。</target>
        </trans-unit>
        <trans-unit id="127b1aff45435298c344787323bda31e37d71df8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.QL&lt;/code&gt; objects are used by the following APIs:</source>
          <target state="translated">&lt;code&gt;Relay.QL&lt;/code&gt; オブジェクトは、次のAPIによって使用されます。</target>
        </trans-unit>
        <trans-unit id="7e9cc4a6100437d109392de9c4dd32579e5bef54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.Renderer&lt;/code&gt; can then orchestrate the fetching of the queries; diffing them against cached data, fetching any missing information, updating the cache, and finally rendering &lt;code&gt;StoryContainer&lt;/code&gt; once the data is available. The default is to render nothing while data is fetching, but the loading view can be customized via the &lt;code&gt;render&lt;/code&gt; prop. Just as React allows developers to render views without directly manipulating the underlying view, Relay and &lt;code&gt;Relay.Renderer&lt;/code&gt; remove the need to directly communicate with the network.</source>
          <target state="translated">&lt;code&gt;Relay.Renderer&lt;/code&gt; 次に、Relay.Rendererはクエリのフェッチを調整できます。それらをキャッシュされたデータと比較し、不足している情報をフェッチし、キャッシュを更新し、データが利用可能になると &lt;code&gt;StoryContainer&lt;/code&gt; をレンダリングします。デフォルトでは、データのフェッチ中は何もレンダリングされませんが、ローディングビューは &lt;code&gt;render&lt;/code&gt; プロップを介してカスタマイズできます。Reactにより、開発者が基になるビューを直接操作せずにビューをレンダリングできるように、Relayと &lt;code&gt;Relay.Renderer&lt;/code&gt; はネットワークと直接通信する必要をなくします。</target>
        </trans-unit>
        <trans-unit id="af18c48993c9562a944639b49a29f4455950bbaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay&lt;/code&gt; is the entry point to the Relay library. If you're using one of the prebuilt packages it's available as a global; if you're using CommonJS modules you can &lt;code&gt;require()&lt;/code&gt; it.</source>
          <target state="translated">&lt;code&gt;Relay&lt;/code&gt; は、リレーライブラリへのエントリポイントです。ビルド済みのパッケージのいずれかを使用している場合は、グローバルとして使用できます。CommonJSモジュールを使用している場合は、 &lt;code&gt;require()&lt;/code&gt; できます。</target>
        </trans-unit>
        <trans-unit id="5c66e5b2f381152669b034d6f6167ad8cf6ed012" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayContainer&lt;/code&gt; is a higher-order React component that lets a React component encode its data requirements.</source>
          <target state="translated">&lt;code&gt;RelayContainer&lt;/code&gt; は、Reactコンポーネントがデータ要件をエンコードできるようにする高次のReactコンポーネントです。</target>
        </trans-unit>
        <trans-unit id="df2d84ab4a50cd1673857a423e00806293940147" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayMutationRequest&lt;/code&gt; encapsulates a mutation that Relay needs to send to the server. They are made available to network layers via the &lt;code&gt;sendMutation&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;RelayMutationRequest&lt;/code&gt; は、Relayがサーバーに送信する必要がある変更をカプセル化します。これらは、 &lt;code&gt;sendMutation&lt;/code&gt; メソッドを介してネットワークレイヤーで利用できます。</target>
        </trans-unit>
        <trans-unit id="e4dc52a29a31a839078a5cad953c9628f74f0f0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayMutationTransaction.getStatus&lt;/code&gt; can return one of the following strings:</source>
          <target state="translated">&lt;code&gt;RelayMutationTransaction.getStatus&lt;/code&gt; は、次の文字列のいずれかを返します。</target>
        </trans-unit>
        <trans-unit id="242d9ea8a1f2fba8d773760a8233ecf37bf7b5f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayQueryRequest&lt;/code&gt; encapsulates a query that Relay needs to send to the server. They are made available to network layers via the &lt;code&gt;sendQueries&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;RelayQueryRequest&lt;/code&gt; は、Relayがサーバーに送信する必要があるクエリをカプセル化します。これらは、 &lt;code&gt;sendQueries&lt;/code&gt; メソッドを介してネットワークレイヤーで利用できます。</target>
        </trans-unit>
        <trans-unit id="df62ea345a45d0a5fabcd2fdbf901148c6e5a8b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNCOMMITTED&lt;/code&gt; &amp;mdash; Transaction hasn't yet been sent to the server. Transaction can be committed or rolled back.</source>
          <target state="translated">&lt;code&gt;UNCOMMITTED&lt;/code&gt; &amp;mdash;トランザクションはまだサーバーに送信されていません。トランザクションはコミットまたはロールバックできます。</target>
        </trans-unit>
        <trans-unit id="50a52e374bfb1a67a3f6d2363ba22492f2e2e80d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configs&lt;/code&gt;: an array containing the different optimisticUpdater/updater configurations. It provides a convenient way to specify the &lt;code&gt;updater&lt;/code&gt; behavior.</source>
          <target state="translated">&lt;code&gt;configs&lt;/code&gt; ：さまざまなoptimisticUpdater / updater構成を含む配列。これは、 &lt;code&gt;updater&lt;/code&gt; 動作を指定する便利な方法を提供します。</target>
        </trans-unit>
        <trans-unit id="7cc60f97e29bfb6ea62a807eae2cc5e7a17f3eb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configs&lt;/code&gt;: an array containing the updater configurations. It is the same as &lt;a href=&quot;mutations#configs&quot;&gt;&lt;code&gt;configs&lt;/code&gt;&lt;/a&gt; in &lt;code&gt;commitMutation&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;configs&lt;/code&gt; ：アップデーター構成を含む配列。それは同じである&lt;a href=&quot;mutations#configs&quot;&gt; &lt;code&gt;configs&lt;/code&gt; &lt;/a&gt;で &lt;code&gt;commitMutation&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9394dd3d6a30c68a04fbce9521aacc5342c5da92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connectionInfo: Array&amp;lt;{key: string, filters?: Variables, rangeBehavior:
string}&amp;gt;&lt;/code&gt;: An array of objects containing a connection key, an object containing optional filters, and a range behavior depending on what behavior we expect (append, prepend, or ignore).</source>
          <target state="translated">&lt;code&gt;connectionInfo: Array&amp;lt;{key: string, filters?: Variables, rangeBehavior: string}&amp;gt;&lt;/code&gt; ：接続キーを含むオブジェクトの配列、オプションのフィルターを含むオブジェクト、および予想される動作（追加、先頭に追加、追加、または無視）。</target>
        </trans-unit>
        <trans-unit id="43c66a2069ec0b2d4be35833e1ae8977d9b93edf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connectionKeys: Array&amp;lt;{key: string, filters?: Variables}&amp;gt;&lt;/code&gt;: An array of objects containing a connection key and optionally filters.</source>
          <target state="translated">&lt;code&gt;connectionKeys: Array&amp;lt;{key: string, filters?: Variables}&amp;gt;&lt;/code&gt; ：接続キーとオプションでフィルターを含むオブジェクトの配列。</target>
        </trans-unit>
        <trans-unit id="d19b3e482db84864f686a4ee3759da01773329b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deletedIDFieldName: string | Array&amp;lt;string&amp;gt;&lt;/code&gt;: The field name in the response that contains the DataID of the removed node, or the path to the node removed from the connection</source>
          <target state="translated">&lt;code&gt;deletedIDFieldName: string | Array&amp;lt;string&amp;gt;&lt;/code&gt; ：削除されたノードのDataIDを含む応答内のフィールド名、または接続から削除されたノードへのパス</target>
        </trans-unit>
        <trans-unit id="e977f6b2b4f562aa7af31b00751819ad50d520ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deletedIDFieldName: string&lt;/code&gt;: The field name in the response that contains the DataID of the deleted node</source>
          <target state="translated">&lt;code&gt;deletedIDFieldName: string&lt;/code&gt; ：削除されたノードのDataIDを含む応答のフィールド名</target>
        </trans-unit>
        <trans-unit id="22bd764f98c24605fee21c6e86534a102d352d4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;edgeName: string&lt;/code&gt;: The field name in the response that represents the newly created edge</source>
          <target state="translated">&lt;code&gt;edgeName: string&lt;/code&gt; ：新しく作成されたエッジを表す応答のフィールド名</target>
        </trans-unit>
        <trans-unit id="b7ab967dc3d9dac41042965f33de5bbacae6b0e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;environment&lt;/code&gt; An instance of `Relay.Environment` or any object that implements the `RelayEnvironment` interface.</source>
          <target state="translated">&lt;code&gt;environment&lt;/code&gt; `Relay.Environment`のインスタンス、または` RelayEnvironment`インターフェースを実装するオブジェクト。</target>
        </trans-unit>
        <trans-unit id="6a65d389a718020e07ebee40da7bdd44c16a4420" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filters&lt;/code&gt;: An object containing GraphQL calls e.g. &lt;code&gt;const filters = {'orderby': 'chronological'};&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;filters&lt;/code&gt; ：GraphQL呼び出しを含むオブジェクト。例： &lt;code&gt;const filters = {'orderby': 'chronological'};&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41eb5ef20bb9fe4e11e5a7ba243c250838991a3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forceFetch&lt;/code&gt; Whether to send a server request regardless of data available on the client.</source>
          <target state="translated">&lt;code&gt;forceFetch&lt;/code&gt; クライアントで使用可能なデータに関係なく、サーバー要求を送信するかどうか。</target>
        </trans-unit>
        <trans-unit id="d556d0cc8a6f2287f3af67eacd90ec1629094411" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forceFetch&lt;/code&gt; can be called with an empty set of partial variables, meaning it can trigger a refresh of the currently rendered set of data.</source>
          <target state="translated">&lt;code&gt;forceFetch&lt;/code&gt; は、部分変数の空のセットで呼び出すことができます。つまり、現在レンダリングされているデータセットの更新をトリガーできます。</target>
        </trans-unit>
        <trans-unit id="7c4e5ec515c48d1d775f76f1e41f31d520e97786" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forceFetch&lt;/code&gt; is similar to &lt;code&gt;setVariables&lt;/code&gt; because it is also used to change the data requirements by altering &lt;code&gt;variables&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;forceFetch&lt;/code&gt; は、 &lt;code&gt;variables&lt;/code&gt; を変更してデータ要件を変更するためにも使用されるため、 &lt;code&gt;setVariables&lt;/code&gt; に似ています。</target>
        </trans-unit>
        <trans-unit id="78c6f70e52f47838301be68f3a7fc35ddbd14be0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fragments&lt;/code&gt; Declare the component's data requirements using fragments.</source>
          <target state="translated">&lt;code&gt;fragments&lt;/code&gt; を使用してコンポーネントのデータ要件を宣言します。</target>
        </trans-unit>
        <trans-unit id="ffcebb96656094f38726e63b34eb65150f50c9ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getFragment(name[, vars])&lt;/code&gt; Get a reference to a container fragment for inclusion in a parent fragment.</source>
          <target state="translated">&lt;code&gt;getFragment(name[, vars])&lt;/code&gt; 親フラグメントに含めるコンテナフラグメントへの参照を取得します。</target>
        </trans-unit>
        <trans-unit id="4d2af946a8f787de1546269d02d1783ad16d7ce4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;initialVariables&lt;/code&gt; The initial set of variable values available to this component's fragments.</source>
          <target state="translated">&lt;code&gt;initialVariables&lt;/code&gt; このコンポーネントのフラグメントで使用できる変数値の初期セット。</target>
        </trans-unit>
        <trans-unit id="563c728f73a72af11f9bfebcd489b1605c4ad5b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutation&lt;/code&gt;: the &lt;code&gt;graphql&lt;/code&gt; tagged mutation query.</source>
          <target state="translated">&lt;code&gt;mutation&lt;/code&gt; ： &lt;code&gt;graphql&lt;/code&gt; タグ付き突然変異クエリ。</target>
        </trans-unit>
        <trans-unit id="b6a934fa0ef96a565381122a89d9aee1a4fba9dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onCompleted&lt;/code&gt;: a callback function executed when the subscription is closed by the peer without error.</source>
          <target state="translated">&lt;code&gt;onCompleted&lt;/code&gt; ：サブスクリプションがピアによってエラーなしで閉じられたときに実行されるコールバック関数。</target>
        </trans-unit>
        <trans-unit id="a715680a7bcdc7a8e18cff64218bee6c4c5f714a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onCompleted&lt;/code&gt;: a callback function executed with the 'raw' response and errors from the server after the in-memory Relay store is updated with the &lt;code&gt;updater&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;onCompleted&lt;/code&gt; ：インメモリリレーストアが &lt;code&gt;updater&lt;/code&gt; 更新された後、サーバーからの「生の」応答とエラーで実行されるコールバック関数。</target>
        </trans-unit>
        <trans-unit id="7e17c27700518dd0a0d9e3907f0ead05f610d8e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onError&lt;/code&gt;: a callback function executed when Relay encounters an error.</source>
          <target state="translated">&lt;code&gt;onError&lt;/code&gt; ：Relayでエラーが発生したときに実行されるコールバック関数。</target>
        </trans-unit>
        <trans-unit id="5632405e91380cb8466949662b4346c6b8f63bac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onError&lt;/code&gt;: a callback function executed when Relay or the server encounters an error processing the subscription.</source>
          <target state="translated">&lt;code&gt;onError&lt;/code&gt; ：リレーまたはサーバーがサブスクリプションの処理中にエラーを検出したときに実行されるコールバック関数。</target>
        </trans-unit>
        <trans-unit id="13f38fe85bb18ed69b3110347c91c063ca63f296" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onFailure&lt;/code&gt; is called if the mutation failed.</source>
          <target state="translated">&lt;code&gt;onFailure&lt;/code&gt; は、変更が失敗した場合に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="34b282489eb2fc659bf8f182ecccfa58a4f98bbf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onNext&lt;/code&gt;: a callback function executed each time a response is received from the server, with the raw GraphQL response payload.</source>
          <target state="translated">&lt;code&gt;onNext&lt;/code&gt; ：生のGraphQL応答ペイロードを使用して、サーバーから応答を受信するたびに実行されるコールバック関数。</target>
        </trans-unit>
        <trans-unit id="b0c18e8b6186d7338bef8b15b59ec6ca63cd0225" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onSuccess&lt;/code&gt; is called if the mutation succeeded.</source>
          <target state="translated">&lt;code&gt;onSuccess&lt;/code&gt; 突然変異が成功した場合、onSuccessが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="5a1dc36be8e9a3f9069b3ce5c93735b18dee1d9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optimisticResponse&lt;/code&gt;: an object conforming to the mutation's response type definition. If provided, the optimistic response will be normalized to the proxy store before &lt;code&gt;optimisticUpdater&lt;/code&gt; is executed. We suggest you provide an &lt;code&gt;optimisticResponse&lt;/code&gt; for two benefits:</source>
          <target state="translated">&lt;code&gt;optimisticResponse&lt;/code&gt; ：ミューテーションのレスポンスタイプ定義に準拠するオブジェクト。提供された場合、 &lt;code&gt;optimisticUpdater&lt;/code&gt; が実行される前に、オプティミスティックレスポンスがプロキシストアに正規化されます。次の2つのメリットについて、 &lt;code&gt;optimisticResponse&lt;/code&gt; を提供することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="ace8dc4f2ade074a4518666a5d5ce3fc892c20c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optimisticUpdater&lt;/code&gt;: a function that takes in a proxy of the in-memory Relay store. In this function, the client defines 'how to' update the store through the proxy in an imperative way.</source>
          <target state="translated">&lt;code&gt;optimisticUpdater&lt;/code&gt; ：インメモリリレーストアのプロキシを取り込む関数。この関数では、クライアントは、命令型の方法でプロキシを介してストアを更新する「方法」を定義します。</target>
        </trans-unit>
        <trans-unit id="b45ed0f29925a557b65dfee5d20499e8f93783ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parentID: string&lt;/code&gt;: The DataID of the parent node that contains the connection.</source>
          <target state="translated">&lt;code&gt;parentID: string&lt;/code&gt; ：接続を含む親ノードのDataID。</target>
        </trans-unit>
        <trans-unit id="90d6f234e369d7056e4a4a384ce4d56b75c66508" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pathToConnection: Array&amp;lt;string&amp;gt;&lt;/code&gt;: An array containing the field names between the parent and the connection, including the parent and the connection.</source>
          <target state="translated">&lt;code&gt;pathToConnection: Array&amp;lt;string&amp;gt;&lt;/code&gt; ：親と接続を含む、親と接続の間のフィールド名を含む配列。</target>
        </trans-unit>
        <trans-unit id="ca3a99f863b6d6006d89f122d91acd2466426ca1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pendingVariables&lt;/code&gt; contains the set of variables that are being used to fetch the new props, i.e. when &lt;code&gt;this.props.relay.setVariables()&lt;/code&gt; or &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt; are called and the corresponding request is in flight.</source>
          <target state="translated">&lt;code&gt;pendingVariables&lt;/code&gt; には、新しいプロップをフェッチするために使用されている変数のセットが含まれています。つまり、 &lt;code&gt;this.props.relay.setVariables()&lt;/code&gt; または &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt; が呼び出され、対応するリクエストが実行中である場合です。</target>
        </trans-unit>
        <trans-unit id="5294d02523abdadc7890c4089fd2d771e0103adf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prepareVariables&lt;/code&gt; A method to modify the variables based on the runtime environment or previous variable values.</source>
          <target state="translated">&lt;code&gt;prepareVariables&lt;/code&gt; ランタイム環境または以前の変数値に基づいて変数を変更するメソッド。</target>
        </trans-unit>
        <trans-unit id="85e836212ec7a6f4cf39b03986865be121a0bbd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;queryConfig&lt;/code&gt; `QueryConfig` or `Relay.Route` that defines the query roots.</source>
          <target state="translated">&lt;code&gt;queryConfig&lt;/code&gt; クエリのルートを定義するqueryConfig `QueryConfig`または` Relay.Route`。</target>
        </trans-unit>
        <trans-unit id="32d83449d21fcdf971b3e1c1d76474fe6f62d3af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetchVariables&lt;/code&gt; is either a bag of variables or a function that takes in the previous fragment variables and returns new variables.</source>
          <target state="translated">&lt;code&gt;refetchVariables&lt;/code&gt; は、変数のバッグ、または前のフラグメント変数を取り込んで新しい変数を返す関数のいずれかです。</target>
        </trans-unit>
        <trans-unit id="4ae4f5a5447be2154beefea2867a35b518a781d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;render&lt;/code&gt; Called to render when data requirements are being fulfilled.</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; データ要件が満たされているときにレンダリングするために呼び出されます。</target>
        </trans-unit>
        <trans-unit id="55e1260e99e337d383bed6b4b9c2df2228a1e749" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderFailure&lt;/code&gt; Called to render when data failed to be fulfilled.</source>
          <target state="translated">&lt;code&gt;renderFailure&lt;/code&gt; データの実行に失敗したときにレンダリングするために呼び出されます。</target>
        </trans-unit>
        <trans-unit id="a6131b3d70611a404b4ea7dd80f5758c5105f7c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderFetched&lt;/code&gt; Called to render when data requirements are fulfilled.</source>
          <target state="translated">&lt;code&gt;renderFetched&lt;/code&gt; データ要件が満たされたときにレンダリングするために呼び出されます。</target>
        </trans-unit>
        <trans-unit id="1901f50529efd372e2c626214284f332709348a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderLoading&lt;/code&gt; Called to render when data requirements are being fulfilled.</source>
          <target state="translated">&lt;code&gt;renderLoading&lt;/code&gt; データ要件が満たされているときにレンダリングするために呼び出されます。</target>
        </trans-unit>
        <trans-unit id="b0fe2435dec450eee6998923c41267267d40d7d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderVariables&lt;/code&gt; is an optional param that tells Relay which variables to use at when the component is re-rendered after fetching. Without this, the &lt;code&gt;refetchVariables&lt;/code&gt; will be used. You might use this for more advanced usage, for example, to implement pagination, where you would fetch an additional page with variables like &lt;code&gt;{first: 5, after: '...'}&lt;/code&gt;, but you would then render the full collection with &lt;code&gt;{first: 10}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;renderVariables&lt;/code&gt; は、フェッチ後にコンポーネントが再レンダリングされるときに使用する変数をRelayに指示するオプションのパラメーターです。これがない場合、 &lt;code&gt;refetchVariables&lt;/code&gt; が使用されます。これを使用して、たとえば、ページ付けを実装するためのより高度な使用法があります。ここでは、 &lt;code&gt;{first: 5, after: '...'}&lt;/code&gt; ような変数を含む追加のページをフェッチしますが、その後、 &lt;code&gt;{first: 10}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0cef4511de2692e7e2831022f07230dabf3496cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;route&lt;/code&gt; Route that defines the query roots.</source>
          <target state="translated">&lt;code&gt;route&lt;/code&gt; クエリルートを定義するルート。</target>
        </trans-unit>
        <trans-unit id="de20a20a67577265acad0e1c8760490f6ae7d671" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setVariables&lt;/code&gt; does not immediately mutate &lt;code&gt;variables&lt;/code&gt;, but creates a pending state transition. &lt;code&gt;variables&lt;/code&gt; will continue returning the previous values until &lt;code&gt;this.props&lt;/code&gt; has been populated with data that fulfills the new variable values.</source>
          <target state="translated">&lt;code&gt;setVariables&lt;/code&gt; は &lt;code&gt;variables&lt;/code&gt; すぐには変更しませんが、保留中の状態遷移を作成します。 &lt;code&gt;this.props&lt;/code&gt; に新しい変数値を満たすデータが入力されるまで、 &lt;code&gt;variables&lt;/code&gt; は以前の値を返し続けます。</target>
        </trans-unit>
        <trans-unit id="943d019e3b13e343df13a6484ab6136c7156b4e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shouldComponentUpdate&lt;/code&gt; Optionally override RelayContainer's default implementation of `shouldComponentUpdate`.</source>
          <target state="translated">&lt;code&gt;shouldComponentUpdate&lt;/code&gt; オプションで、RelayContainerの `shouldComponentUpdate`のデフォルト実装をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="c12be4a70a038cd4741cb2b9e30195491469abee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static Container: ReactPropTypeValidator&lt;/code&gt; A prop type validator asserting that a prop is a valid Relay container.</source>
          <target state="translated">&lt;code&gt;static Container: ReactPropTypeValidator&lt;/code&gt; プロップが有効なリレーコンテナーであることを表明するプロップタイプバリデーター。</target>
        </trans-unit>
        <trans-unit id="3b4467abcecc2f5f6147438c2f223473973407a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static QueryConfig: ReactPropTypeValidator&lt;/code&gt; A prop type validator asserting that a prop is a valid route.</source>
          <target state="translated">&lt;code&gt;static QueryConfig: ReactPropTypeValidator&lt;/code&gt; プロップが有効なルートであることを表明するプロップタイプバリデーター。</target>
        </trans-unit>
        <trans-unit id="40e983f1da84aaeb0774f71c8242e17b35be1f2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static applyUpdate(mutation, callbacks)&lt;/code&gt; Adds a MutationTransaction to the queue without committing it.</source>
          <target state="translated">&lt;code&gt;static applyUpdate(mutation, callbacks)&lt;/code&gt; MutationTransactionをコミットせずにキューに追加します。</target>
        </trans-unit>
        <trans-unit id="b4d03961b864a4ab573535d598407abfc411cce4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static commitUpdate(mutation, callbacks)&lt;/code&gt; Initiate processing of a mutation.</source>
          <target state="translated">&lt;code&gt;static commitUpdate(mutation, callbacks)&lt;/code&gt; 処理を開始します。</target>
        </trans-unit>
        <trans-unit id="9eebf1a07ed283d2bbed2b968ffb38df36fad9ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static create(mutation, variables, environment)&lt;/code&gt; Create a static mutation</source>
          <target state="translated">&lt;code&gt;static create(mutation, variables, environment)&lt;/code&gt; 静的ミューテーションを作成します</target>
        </trans-unit>
        <trans-unit id="658d18c4b39964f6d9e02a8d4f13d6ca5179a919" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static createContainer(Component, ContainerConfig)&lt;/code&gt; Creates a Relay Container.</source>
          <target state="translated">&lt;code&gt;static createContainer(Component, ContainerConfig)&lt;/code&gt; リレーコンテナを作成します。</target>
        </trans-unit>
        <trans-unit id="ac50a770322cba5b662ec0bbf60235d57453db96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static createWithFiles(mutation, variables, files, environment)&lt;/code&gt; Create a static mutation that accepts a &quot;files&quot; object</source>
          <target state="translated">&lt;code&gt;static createWithFiles(mutation, variables, files, environment)&lt;/code&gt; 「ファイル」オブジェクトを受け入れる静的ミューテーションを作成します</target>
        </trans-unit>
        <trans-unit id="a985a4f33765191da82de5eb97d6c665b299a3b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static fragments&lt;/code&gt; Declare this mutation's data dependencies here</source>
          <target state="translated">&lt;code&gt;static fragments&lt;/code&gt; ここでこのミューテーションのデータ依存関係を宣言します</target>
        </trans-unit>
        <trans-unit id="a1697fb2f2da73763242483e979b5b34e6797e53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static initialVariables&lt;/code&gt; A default set of variables to make available to this mutation's fragment builders</source>
          <target state="translated">&lt;code&gt;static initialVariables&lt;/code&gt; このミューテーションのフラグメントビルダーで使用できるようにするデフォルトの変数セット</target>
        </trans-unit>
        <trans-unit id="9ac61312fa144b893336d3bbdf88826d0034494e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static injectNetworkLayer(networkLayer)&lt;/code&gt; Customize how queries and mutations are sent to the server.</source>
          <target state="translated">&lt;code&gt;static injectNetworkLayer(networkLayer)&lt;/code&gt; クエリとミューテーションをサーバーに送信する方法をカスタマイズします。</target>
        </trans-unit>
        <trans-unit id="49b31e2fd0ee618819eb9668ad9fab057dc448c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static injectTaskScheduler(scheduler)&lt;/code&gt; Configure when Relay processing occurs.</source>
          <target state="translated">&lt;code&gt;static injectTaskScheduler(scheduler)&lt;/code&gt; リレー処理が発生するタイミングを構成します。</target>
        </trans-unit>
        <trans-unit id="3e8afe33d507124df2cb20b712a24c4d395ceeb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static isContainer(Component)&lt;/code&gt; Determine if a given object is a Relay.Container.</source>
          <target state="translated">&lt;code&gt;static isContainer(Component)&lt;/code&gt; 指定されたオブジェクトがRelay.Containerかどうかを判断します。</target>
        </trans-unit>
        <trans-unit id="7938dae1f9d2455348151916c16933ea1c4109f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static paramDefinitions&lt;/code&gt; Declare the expected parameters.</source>
          <target state="translated">&lt;code&gt;static paramDefinitions&lt;/code&gt; 必要なパラメーターを宣言します。</target>
        </trans-unit>
        <trans-unit id="047db3ec3d910088d59dd144e9064188d5d64b54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static prepareParams&lt;/code&gt; Declare additional parameters or conversion for parameters.</source>
          <target state="translated">&lt;code&gt;static prepareParams&lt;/code&gt; 追加のパラメーターまたはパラメーターの変換を宣言します。</target>
        </trans-unit>
        <trans-unit id="4b2b9762a4218dc52cee63114d0eee0ed5d04c5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static prepareVariables&lt;/code&gt; A method to modify the variables based on the runtime environment, previous variables, or the meta route</source>
          <target state="translated">&lt;code&gt;static prepareVariables&lt;/code&gt; ランタイム環境、以前の変数、またはメタルートに基づいて変数を変更するメソッド</target>
        </trans-unit>
        <trans-unit id="2b49e3d2f4dae0d69deb0f6c24085a44cc8a3c5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static queries&lt;/code&gt; Declare the set of query roots.</source>
          <target state="translated">&lt;code&gt;static queries&lt;/code&gt; クエリルートのセットを宣言します。</target>
        </trans-unit>
        <trans-unit id="0c43ab95deb00b1e6ba46964ae86ac05d717b874" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static routeName&lt;/code&gt; Declare the name of this route class.</source>
          <target state="translated">&lt;code&gt;static routeName&lt;/code&gt; このルートクラスの名前を宣言します。</target>
        </trans-unit>
        <trans-unit id="91acf728df7357ed2ba9977f2e4aae1aa271198d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subscription&lt;/code&gt;: the &lt;code&gt;graphql&lt;/code&gt; tagged subscription query.</source>
          <target state="translated">&lt;code&gt;subscription&lt;/code&gt; ： &lt;code&gt;graphql&lt;/code&gt; タグ付きサブスクリプションクエリ。</target>
        </trans-unit>
        <trans-unit id="12ff8bacf233237929ba38ec484648a655ad7959" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.relay.setVariables&lt;/code&gt; can be called to update a subset or all of the variables at the same time. In return, Relay will use the new variables to attempt to fulfill the new fragment. This may involve sending a request to the server if data is not already available on the client.</source>
          <target state="translated">&lt;code&gt;this.props.relay.setVariables&lt;/code&gt; を呼び出して、サブセットまたはすべての変数を同時に更新できます。代わりに、Relayは新しい変数を使用して、新しいフラグメントの実行を試みます。データがクライアントでまだ利用できない場合、これにはサーバーへのリクエストの送信が含まれる場合があります。</target>
        </trans-unit>
        <trans-unit id="c005f6461f75206bcbc927906f1de20a4cf2e450" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.relay&lt;/code&gt; exports the following API to execute the refetch query:</source>
          <target state="translated">&lt;code&gt;this.props.relay&lt;/code&gt; は、次のAPIをエクスポートして、再フェッチクエリを実行します。</target>
        </trans-unit>
        <trans-unit id="7d9577972a7c4a8c614b22a037eaeff82248e3f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.relay&lt;/code&gt; exposes the following APIs:</source>
          <target state="translated">&lt;code&gt;this.props.relay&lt;/code&gt; は、次のAPIを公開します。</target>
        </trans-unit>
        <trans-unit id="3d07b37e84a778ceb1461d9bbc1f056984d50a27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.setVariables&lt;/code&gt; from the old API does not have a direct equivalent in the new API. A big reason for this change is that the new core no longer tracks how to refetch any specific sub-tree from the query. This makes the new core a lot faster, but requires explicit queries for how to fetch new data. Check out these four different scenarios:</source>
          <target state="translated">&lt;code&gt;this.props.setVariables&lt;/code&gt; 古いAPIのthis.props.setVariablesには、新しいAPIに直接対応するものはありません。この変更の大きな理由は、新しいコアがクエリから特定のサブツリーを再フェッチする方法を追跡しなくなったことです。これにより、新しいコアが大幅に高速化されますが、新しいデータをフェッチする方法を明示的に照会する必要があります。次の4つの異なるシナリオを確認してください。</target>
        </trans-unit>
        <trans-unit id="25ab1a5db284767b82e6bbe83b1d6bb7782d76cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updater&lt;/code&gt;: a function that updates the in-memory Relay store based on the &lt;strong&gt;real&lt;/strong&gt; server response. When the server response comes back, Relay first reverts any changes introduced by &lt;code&gt;optimisticUpdater&lt;/code&gt; or &lt;code&gt;optimisticResponse&lt;/code&gt; and then applies the &lt;code&gt;updater&lt;/code&gt; to the store.</source>
          <target state="translated">&lt;code&gt;updater&lt;/code&gt; ：&lt;strong&gt;実&lt;/strong&gt;サーバーの応答に基づいてインメモリリレーストアを更新する関数。サーバーの応答が返されると、Relayは最初に &lt;code&gt;optimisticUpdater&lt;/code&gt; または &lt;code&gt;optimisticResponse&lt;/code&gt; によって導入された変更を元に戻し、次に &lt;code&gt;updater&lt;/code&gt; をストアに適用します。</target>
        </trans-unit>
        <trans-unit id="9e752995a456f07b23c9c5955036c90c0eaa7d48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updater&lt;/code&gt;: an optional function that can supply custom logic for updating the in-memory Relay store based on the server response.</source>
          <target state="translated">&lt;code&gt;updater&lt;/code&gt; ：サーバーの応答に基づいてインメモリリレーストアを更新するためのカスタムロジックを提供できるオプションの関数。</target>
        </trans-unit>
        <trans-unit id="ed67a9853586c7a825bf549e62d6668d890318cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt; contains the set of variables that was used to fetch the current set of props.</source>
          <target state="translated">&lt;code&gt;variables&lt;/code&gt; には、現在の小道具のセットを取得するために使用された変数のセットが含まれています。</target>
        </trans-unit>
        <trans-unit id="7e388933696fbe367df975da86d5ab73799cb8d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt;: an object that contains the variables needed for the mutation.</source>
          <target state="translated">&lt;code&gt;variables&lt;/code&gt; ：ミューテーションに必要な変数を含むオブジェクト。</target>
        </trans-unit>
        <trans-unit id="6e219c17510eb13b16577519ca778d9468c7499a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt;: an object that contains the variables needed for the subscription.</source>
          <target state="translated">&lt;code&gt;variables&lt;/code&gt; ：サブスクリプションに必要な変数を含むオブジェクト。</target>
        </trans-unit>
        <trans-unit id="a3d9fd11099be9837becddb07ecac412bfe16922" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;code&gt;babel-relay-plugin&lt;/code&gt; is deprecated. Use &lt;a href=&quot;babel-plugin-relay#using-with-relay-classic&quot;&gt;&lt;code&gt;babel-plugin-relay&lt;/code&gt;&lt;/a&gt; with Relay Classic.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;babel-relay-plugin&lt;/code&gt; は非推奨です。Relay Classicで&lt;a href=&quot;babel-plugin-relay#using-with-relay-classic&quot;&gt; &lt;code&gt;babel-plugin-relay&lt;/code&gt; &lt;/a&gt;を使用します。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="885b12f18c1ce790e1ceb37bdac14666bf969046" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Container Specification&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;コンテナ仕様&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2dc48bdb0f1a664344b42c6cc9f80bf54c93c0af" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Methods&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Methods&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="372322cdb4339a090833f173c5459433d9f3a2a3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Properties and Methods&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;プロパティとメソッド&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2e24a7da3b4c78d1c9bb8ad4a5672d259fcf1c7d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Properties&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Properties&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b288f7cf5165d63b23f3a477f7c62696473947e3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Props&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Props&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c13abeef99d46d6cc5a5891d80bde92ef26cfbac" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Static Methods&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;静的メソッド&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f0677ff5e5e4c313a098291e00353714c69a25eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphcool/graphql-up&quot;&gt;graphql-up&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/graphql-up&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphcool/graphql-up&quot;&gt;graphqlアップ&lt;/a&gt;&lt;/strong&gt;の&lt;a href=&quot;https://www.npmjs.com/package/graphql-up&quot;&gt; NPM&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a854faa5d5c2fb2a3f2a62f519c3dae0ea44c47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;express-graphql&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/express-graphql&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;急行-graphql&lt;/a&gt;&lt;/strong&gt;上の&lt;a href=&quot;https://www.npmjs.com/package/express-graphql&quot;&gt; NPM&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6882e7b1150b43a134cd9463ab13037397e9d8a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;graphql-js&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/graphql&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;graphql-jsから&lt;/a&gt;&lt;/strong&gt;の&lt;a href=&quot;https://www.npmjs.com/package/graphql&quot;&gt; NPM&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4615a7abdf175713f1dd713a45e9b36b49db0dd8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;graphql-relay-js&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/graphql-relay&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;graphqlリレー-jsから&lt;/a&gt;&lt;/strong&gt;の&lt;a href=&quot;https://www.npmjs.com/package/graphql-relay&quot;&gt; NPM&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="57698c2dcaa9317f5b6564784890d536ca0db31a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://www.graph.cool/&quot;&gt;Graphcool&lt;/a&gt;&lt;/strong&gt; (&lt;a href=&quot;https://www.graph.cool/docs/quickstart/&quot;&gt;Quickstart tutorial&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://www.graph.cool/&quot;&gt;Graphcool&lt;/a&gt;&lt;/strong&gt;（&lt;a href=&quot;https://www.graph.cool/docs/quickstart/&quot;&gt;クイックスタートチュートリアル&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="3ff63fe8231293f18f4614046a48a3f375957330" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; An optimistic update may only be applied once.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;楽観的な更新は1回のみ適用できます。</target>
        </trans-unit>
        <trans-unit id="5a6c17b257e2cfbdb037b374e043ded0a3a0687b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Equivalent &lt;code&gt;applyUpdate&lt;/code&gt; and &lt;code&gt;commitUpdate&lt;/code&gt; methods are also provided on the &lt;code&gt;this.props.relay&lt;/code&gt; prop that is passed to components by &lt;code&gt;Relay.Container&lt;/code&gt;. These dispatch mutations in the context of the currently active &lt;code&gt;Relay.Environment&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;同等の &lt;code&gt;applyUpdate&lt;/code&gt; および &lt;code&gt;commitUpdate&lt;/code&gt; メソッドも、 &lt;code&gt;this.props.relay&lt;/code&gt; によってコンポーネントに渡されるthis.props.relayプロップで提供され &lt;code&gt;Relay.Container&lt;/code&gt; 。これらは、現在アクティブな &lt;code&gt;Relay.Environment&lt;/code&gt; のコンテキストでミューテーションをディスパッチします。</target>
        </trans-unit>
        <trans-unit id="3d08f9d41d143a0795971f924c815549c54cd145" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.Container&lt;/strong&gt; lets components declare fragments.</source>
          <target state="translated">&lt;strong&gt;Relay.Containerを&lt;/strong&gt;使用すると、コンポーネントでフラグメントを宣言できます。</target>
        </trans-unit>
        <trans-unit id="90f9832c4e0fd7965e487450fd253cb3d30e8335" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.Renderer&lt;/strong&gt; is a replacement for &lt;code&gt;Relay.RootContainer&lt;/code&gt; that composes a &lt;code&gt;Relay.ReadyStateRenderer&lt;/code&gt; and performs data fetching for a given &lt;code&gt;queryConfig&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Relay.Rendererで&lt;/strong&gt;の置き換えである &lt;code&gt;Relay.RootContainer&lt;/code&gt; 構成 &lt;code&gt;Relay.ReadyStateRenderer&lt;/code&gt; 所与のためのフェッチと実行データ &lt;code&gt;queryConfig&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="4e196f3c49ca550a94a96a6bd405ee5ae569ab33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; accepts three optional callbacks as props that give us more fine-grained control over the render behavior.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;は、3つのオプションのコールバックを小道具として受け入れ、レンダリング動作をより細かく制御できるようにします。</target>
        </trans-unit>
        <trans-unit id="39c403bfc5a5ae739fbb717b4e88e8b5cb484d46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; also supports the &lt;code&gt;onReadyStateChange&lt;/code&gt; prop which lets us receive fine-grained events as they occur while fulfilling the data requirements.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;は &lt;code&gt;onReadyStateChange&lt;/code&gt; プロップもサポートします。これにより、データ要件を満たしている間に発生した細かいイベントを受け取ることができます。</target>
        </trans-unit>
        <trans-unit id="3d6f9d2435421026549fceef7e0844d153a49bfa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; is a React component that attempts to fulfill the data required in order to render an instance of &lt;code&gt;Component&lt;/code&gt; for a given &lt;code&gt;route&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;は、指定された &lt;code&gt;route&lt;/code&gt; &lt;code&gt;Component&lt;/code&gt; のインスタンスをレンダリングするために必要なデータを&lt;strong&gt;満たそう&lt;/strong&gt;とするReactコンポーネントです。</target>
        </trans-unit>
        <trans-unit id="a2469cd762b58409f3e67b96bf307621bbbfad9c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; is a React component that, given a &lt;code&gt;Component&lt;/code&gt; and a &lt;code&gt;route&lt;/code&gt;, attempts to fulfill the data required in order to render an instance of &lt;code&gt;Component&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;はReactコンポーネントであり、 &lt;code&gt;Component&lt;/code&gt; と &lt;code&gt;route&lt;/code&gt; 指定すると、 &lt;code&gt;Component&lt;/code&gt; のインスタンスをレンダリングするために必要なデータを&lt;strong&gt;満たそ&lt;/strong&gt;うとします。</target>
        </trans-unit>
        <trans-unit id="a3a1abc25b49b43dce645669aa17f103661474d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; renders the loading state whenever it cannot immediately fulfill data needed to render. This often happens on the initial render, but it can also happen if either &lt;code&gt;Component&lt;/code&gt; or &lt;code&gt;route&lt;/code&gt; changes.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;は、レンダリングに必要なデータをすぐに満たすことができない場合は常に、読み込み状態をレンダリングします。これは多くの場合、最初のレンダリングで発生しますが、 &lt;code&gt;Component&lt;/code&gt; または &lt;code&gt;route&lt;/code&gt; が変更された場合にも発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="81df685053c0d0bd1d2397325ab50c0f55f7ca06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.Route&lt;/strong&gt; lets us declare query roots.</source>
          <target state="translated">&lt;strong&gt;Relay.Routeを&lt;/strong&gt;使用すると、クエリのルートを宣言できます。</target>
        </trans-unit>
        <trans-unit id="d333726339af1440c557b36d8dd062e5747d248a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;QueryRenderer&lt;/code&gt; is a React component, so it can be rendered anywhere that a React component can be rendered, not just at the top level. A &lt;code&gt;QueryRenderer&lt;/code&gt; can be rendered &lt;em&gt;within&lt;/em&gt; other Relay components, for example to lazily fetch additional data for a popover. However, a &lt;code&gt;QueryRenderer&lt;/code&gt; will not start loading its data until it is mounted, so nested &lt;code&gt;QueryRenderer&lt;/code&gt; components can lead to avoidable request waterfalls if used unnecessarily.</source>
          <target state="translated">A &lt;code&gt;QueryRenderer&lt;/code&gt; は、最上位レベルでだけでなく、レンダリングすることができる成分に反応することどこにレンダリングすることができるように、コンポーネント反応させています。 A &lt;code&gt;QueryRenderer&lt;/code&gt; をレンダリングすることができる&lt;em&gt;内&lt;/em&gt;レイジーポップオーバーのための追加データをフェッチするために、例えば、他のリレー部品。ただし、 &lt;code&gt;QueryRenderer&lt;/code&gt; はデータがマウントされるまでデータの読み込みを開始しないため、ネストされた &lt;code&gt;QueryRenderer&lt;/code&gt; コンポーネントは、不必要に使用された場合、回避可能なリクエストウォーターフォールにつながる可能性があります。</target>
        </trans-unit>
        <trans-unit id="27c70649f28d5c13e5a545686407c1d433b45c24" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; config is used to append additional children to the mutation query. You may need to use this, for example, to fetch fields on a new object created by the mutation (and which Relay would normally not attempt to fetch because it has not previously fetched anything for that object).</source>
          <target state="translated">A &lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; configが突然変異クエリに追加子供を付加するために使用されます。たとえば、ミューテーションによって作成された新しいオブジェクトのフィールドをフェッチするためにこれを使用する必要がある場合があります（そのオブジェクトの何も以前にフェッチしていないため、通常、Relayはフェッチを試みません）。</target>
        </trans-unit>
        <trans-unit id="b0405a3f3745cc21b6e57c41715133d0cedd35b4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;RefetchContainer&lt;/code&gt; first renders like a regular &lt;a href=&quot;fragment-container&quot;&gt;&lt;code&gt;FragmentContainer&lt;/code&gt;&lt;/a&gt;, but has the option to execute a new query with different variables and render the response of that query instead when the request comes back.</source>
          <target state="translated">A &lt;code&gt;RefetchContainer&lt;/code&gt; は、最初の正規のようにレンダリングさ&lt;a href=&quot;fragment-container&quot;&gt; &lt;code&gt;FragmentContainer&lt;/code&gt; &lt;/a&gt;が、異なる変数を使用して新しいクエリを実行し、要求が戻ってきたときに、代わりにそのクエリの応答をレンダリングするためのオプションがあります。</target>
        </trans-unit>
        <trans-unit id="0b6b1500d0098058dc174f969740040bdd6fdf14" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;renderLoading&lt;/code&gt; callback can simulate the default behavior by returning &lt;code&gt;undefined&lt;/code&gt;. Notice that this is different from a &lt;code&gt;renderLoading&lt;/code&gt; callback that returns &lt;code&gt;null&lt;/code&gt;, which would render nothing whenever data is loading, even if there was a previous view rendered.</source>
          <target state="translated">&lt;code&gt;renderLoading&lt;/code&gt; のコールバックを返すことにより、デフォルトの動作をシミュレートすることができ &lt;code&gt;undefined&lt;/code&gt; 。これは、 &lt;code&gt;null&lt;/code&gt; を返す &lt;code&gt;renderLoading&lt;/code&gt; コールバックとは異なることに注意してください。これは、前のビューがレンダリングされていても、データのロード中は何もレンダリングしません。</target>
        </trans-unit>
        <trans-unit id="59bd5b6c5b1f4d50bad57e4bae0c86bf7e63ff03" translate="yes" xml:space="preserve">
          <source>A Complete Example</source>
          <target state="translated">完全な例</target>
        </trans-unit>
        <trans-unit id="584bb673c7430dcef36b698acb079dd72be2262f" translate="yes" xml:space="preserve">
          <source>A GraphQL Schema</source>
          <target state="translated">グラフQLスキーム</target>
        </trans-unit>
        <trans-unit id="b1a1d3fc840a0a6e5e8ca2b278d7769c45a98c33" translate="yes" xml:space="preserve">
          <source>A GraphQL Server</source>
          <target state="translated">グラフQLサーバー</target>
        </trans-unit>
        <trans-unit id="a7ee882612fb64b227df291f19a923de85574e53" translate="yes" xml:space="preserve">
          <source>A GraphQL schema describes your data model, and provides a GraphQL server with an associated set of resolve methods that know how to fetch data. We will use &lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;graphql-js&lt;/a&gt; and &lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;graphql-relay-js&lt;/a&gt; to build our schema.</source>
          <target state="translated">GraphQLスキーマはデータモデルを記述し、GraphQLサーバーに、データのフェッチ方法を認識している関連する一連のresolveメソッドを提供します。私たちは、使用する&lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;graphql-JS&lt;/a&gt;と&lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;graphqlリレー-jsのを&lt;/a&gt;私たちのスキーマを構築します。</target>
        </trans-unit>
        <trans-unit id="5f6d86fdd10ea1168eecc22cdc48b9e22a21ad2d" translate="yes" xml:space="preserve">
          <source>A complete example</source>
          <target state="translated">完全な例</target>
        </trans-unit>
        <trans-unit id="1b0ee223956194b51488ec093f18ce49cf32ed77" translate="yes" xml:space="preserve">
          <source>A description of how to page through connections.</source>
          <target state="translated">接続を介してページングする方法を説明しています。</target>
        </trans-unit>
        <trans-unit id="97b03c635c48a56b721c11e955de7b0b12f2ab52" translate="yes" xml:space="preserve">
          <source>A description of your data model with an associated set of resolve methods that know how to fetch any data your application could ever need.</source>
          <target state="translated">アプリケーションが必要とするあらゆるデータを取得する方法を知っている解決メソッドの関連セットを持つデータモデルの説明。</target>
        </trans-unit>
        <trans-unit id="cab997b4cd24ec902e4b83aaf3bf43dce9ec7836" translate="yes" xml:space="preserve">
          <source>A faction has many ships in the Star Wars universe. Relay contains functionality to make manipulating one-to-many relationships easy, using a standardized way of expressing these one-to-many relationships. This standard connection model offers ways of slicing and paginating through the connection.</source>
          <target state="translated">スター・ウォーズの宇宙では、派閥には多くの船があります。Relayには、これらの一対多の関係を標準化された方法で表現することで、一対多の関係を簡単に操作できるようにする機能が含まれています。この標準的な接続モデルでは、接続をスライスしたりページ分割したりする方法を提供しています。</target>
        </trans-unit>
        <trans-unit id="ac6dbe38242ad9f607665dc6e4fa2db4283cdd16" translate="yes" xml:space="preserve">
          <source>A map between a &lt;code&gt;fieldName&lt;/code&gt; in the response and one or more DataIDs in the store.</source>
          <target state="translated">応答内の &lt;code&gt;fieldName&lt;/code&gt; とストア内の1つ以上のDataIDの間のマップ。</target>
        </trans-unit>
        <trans-unit id="6d94fea08321dcd17e29b42a404746fc50da107f" translate="yes" xml:space="preserve">
          <source>A map between printed, dot-separated GraphQL calls &lt;em&gt;in alphabetical order&lt;/em&gt; and the behavior we want Relay to exhibit when adding the new edge to connections under the influence of those calls or a function accepting an array of connection arguments, returning that behavior.</source>
          <target state="translated">&lt;em&gt;アルファベット順に&lt;/em&gt;印刷されたドット区切りのGraphQL呼び出しと、それらの呼び出しまたは接続引数の配列を受け入れる関数の影響下で新しいエッジを接続に追加するときにRelayが示す動作との間のマップで、その動作を返します。</target>
        </trans-unit>
        <trans-unit id="1cccdfbe7fde630bea189ab2f8f17ca043aff9a4" translate="yes" xml:space="preserve">
          <source>A mechanism for refetching an object.</source>
          <target state="translated">オブジェクトをリフェッチするためのメカニズム。</target>
        </trans-unit>
        <trans-unit id="dd1a050f9a41554bdba5570ef7cbd29c8928f1fa" translate="yes" xml:space="preserve">
          <source>A naming convention of &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; for fragments is advised. This restriction is required while migrating from classic to modern APIs to allow for cross-compatibility.</source>
          <target state="translated">フラグメントの &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; の命名規則をお勧めします。この制限は、クラシックAPIからモダンAPIに移行するときに相互互換性を確保するために必要です。</target>
        </trans-unit>
        <trans-unit id="b4223851fbff0df13ddb07d4c23c59818ab413eb" translate="yes" xml:space="preserve">
          <source>A normalized cache ensures that the &lt;em&gt;cache&lt;/em&gt; is consistent. But what about our views? Ideally, our React views would always reflect the current information from the cache.</source>
          <target state="translated">正規化された&lt;em&gt;キャッシュ&lt;/em&gt;は、&lt;em&gt;キャッシュの&lt;/em&gt;一貫性を保証します。しかし、私たちの見解はどうですか？理想的には、Reactビューは常にキャッシュからの現在の情報を反映します。</target>
        </trans-unit>
        <trans-unit id="921546babe023949163725db08488e51b22729dc" translate="yes" xml:space="preserve">
          <source>A number of more detailed usage examples can be found &lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/react-relay/classic/mutation/__tests__/RelayGraphQLMutation-test.js&quot;&gt;in the test suite&lt;/a&gt;.</source>
          <target state="translated">より詳細な使用例の多く&lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/react-relay/classic/mutation/__tests__/RelayGraphQLMutation-test.js&quot;&gt;は、テストスイートにあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7bf37966659d061a8f053bad6bab73f29aaece2b" translate="yes" xml:space="preserve">
          <source>A parent component will pass in a reference to some &lt;code&gt;User&lt;/code&gt; &quot;record&quot;.</source>
          <target state="translated">親コンポーネントは、一部の &lt;code&gt;User&lt;/code&gt; 「レコード」への参照を渡します。</target>
        </trans-unit>
        <trans-unit id="3024b82cc133bf6a9ef4feda5d9be663e786bae2" translate="yes" xml:space="preserve">
          <source>A polyfilled environment for Relay using &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; to support older browsers might look like:</source>
          <target state="translated">古いブラウザをサポートするために&lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt;を使用するRelayのポリフィル環境は次のようになります。</target>
        </trans-unit>
        <trans-unit id="61d2ab53d28c9ffa3a83c917db0c7132ab0ec11a" translate="yes" xml:space="preserve">
          <source>A reference for translating between the Relay Classic and Relay Modern APIs.</source>
          <target state="translated">Relay Classic APIとRelay Modern APIの間での翻訳のためのリファレンスです。</target>
        </trans-unit>
        <trans-unit id="0b8683fbbd3c98251a45756a2f2f8175837a100c" translate="yes" xml:space="preserve">
          <source>A simple database</source>
          <target state="translated">シンプルなデータベース</target>
        </trans-unit>
        <trans-unit id="40cf8919ea34c404a49fa4a02115691af647ed4f" translate="yes" xml:space="preserve">
          <source>A simple example</source>
          <target state="translated">簡単な例</target>
        </trans-unit>
        <trans-unit id="dd8ebc46434f8d14a177b5c72d5934bab414bb47" translate="yes" xml:space="preserve">
          <source>A simpler, more predictable mutation API. The restrictions on mutation queries from Relay Classic are also removed: mutation queries are static, fields can be arbitrarily nested, and may use arbitrary arguments.</source>
          <target state="translated">よりシンプルで予測可能なミューテーションAPI。Relay Classic からのミューテーションクエリの制限も取り除かれました。ミューテーションクエリは静的で、フィールドは任意のネストが可能で、任意の引数を使用することができます。</target>
        </trans-unit>
        <trans-unit id="789d37a7cd03e8b6bdc2af935f5617d2f61be663" translate="yes" xml:space="preserve">
          <source>A standard response is to &quot;just use immutable data structures&quot; &amp;mdash; but let's see what would happen if we did:</source>
          <target state="translated">標準的な応答は、「不変のデータ構造を使用する」というものですが、そうするとどうなるか見てみましょう。</target>
        </trans-unit>
        <trans-unit id="e5e4cf2d26ffa89b62883fa16b09362f316c9090" translate="yes" xml:space="preserve">
          <source>A summary of the improvements and new features in Relay Modern.</source>
          <target state="translated">Relay Modernの改良点と新機能のまとめ。</target>
        </trans-unit>
        <trans-unit id="95da6cd41846ca1d215d52c18cb18c520fe5b668" translate="yes" xml:space="preserve">
          <source>A working copy of the treasure hunt can be found in the &lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;relay-examples&lt;/a&gt; repository.</source>
          <target state="translated">宝探しの作業用コピーは、&lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;relay-examples&lt;/a&gt;リポジトリにあります。</target>
        </trans-unit>
        <trans-unit id="1aec4806edaa35984901f978cbb068b50698edb4" translate="yes" xml:space="preserve">
          <source>API Cheatsheet</source>
          <target state="translated">APIチートシート</target>
        </trans-unit>
        <trans-unit id="2c3de2092b0a547759dcfed154c12293c6bfa562" translate="yes" xml:space="preserve">
          <source>API and Runtime</source>
          <target state="translated">APIとランタイム</target>
        </trans-unit>
        <trans-unit id="42949c00e99b70b6ffba23e406246cfa31564e49" translate="yes" xml:space="preserve">
          <source>Achieving View Consistency</source>
          <target state="translated">ビューの一貫性を実現する</target>
        </trans-unit>
        <trans-unit id="81f2d6f8bacd029d8646faa85a14672311eb28b5" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;&quot;relay&quot;&lt;/code&gt; to the list of plugins your .babelrc file. See &lt;a href=&quot;babel-plugin-relay&quot;&gt;the docs&lt;/a&gt; if upgrading an existing Relay app.</source>
          <target state="translated">.babelrcファイルのプラグインのリストに &lt;code&gt;&quot;relay&quot;&lt;/code&gt; を追加します。既存のリレーアプリをアップグレードする場合は&lt;a href=&quot;babel-plugin-relay&quot;&gt;、ドキュメントを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0a60bf5aa8ddfd89ba31ac71650847ae24721ce0" translate="yes" xml:space="preserve">
          <source>Add the variable to the queries that use the fragment and pass it in when fetching the query. For this it can be useful to have a module with a collection of variables for your product.</source>
          <target state="translated">フラグメントを使用するクエリに変数を追加し、クエリを取得する際にそれを渡します。このためには、製品用の変数のコレクションを持つモジュールがあると便利です。</target>
        </trans-unit>
        <trans-unit id="0a4d555b6a81430095f4070dee6163a543de304b" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;handlerProvider&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;handlerProvider&lt;/code&gt; の追加</target>
        </trans-unit>
        <trans-unit id="c313de6babf318503fdf433e2471023cd78a727c" translate="yes" xml:space="preserve">
          <source>Additional Options</source>
          <target state="translated">追加オプション</target>
        </trans-unit>
        <trans-unit id="94c2eff0e92e7480eb248740c04ee58edd887616" translate="yes" xml:space="preserve">
          <source>Additionally, you need a directory containing &lt;code&gt;.js&lt;/code&gt; files that use the &lt;code&gt;graphql&lt;/code&gt; tag to describe GraphQL queries and fragments. Let's call this &lt;code&gt;./src&lt;/code&gt;.</source>
          <target state="translated">さらに、 &lt;code&gt;graphql&lt;/code&gt; タグを使用してGraphQLクエリとフラグメントを記述する &lt;code&gt;.js&lt;/code&gt; ファイルを含むディレクトリが必要です。これを &lt;code&gt;./src&lt;/code&gt; と呼びましょう。</target>
        </trans-unit>
        <trans-unit id="e7c13cb060f72ef8e06bc9f0779c54871d13ff35" translate="yes" xml:space="preserve">
          <source>Advanced Mutation Example</source>
          <target state="translated">高度な突然変異の例</target>
        </trans-unit>
        <trans-unit id="5126940d744a6dff391a643edf858b06f00785ed" translate="yes" xml:space="preserve">
          <source>Advanced usage</source>
          <target state="translated">高度な使い方</target>
        </trans-unit>
        <trans-unit id="78bdcba5217f6a92239c4e8dde28377bb7815364" translate="yes" xml:space="preserve">
          <source>After initially fetching this story our cache might be as follows. Note that the story and comment both link to the same record as &lt;code&gt;author&lt;/code&gt;:</source>
          <target state="translated">このストーリーを最初にフェッチした後、キャッシュは次のようになる可能性があります。ストーリーとコメントの両方が &lt;code&gt;author&lt;/code&gt; と同じレコードにリンクしていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="cefb28e5c89ebf89740e7f56f62c4e404d2462a6" translate="yes" xml:space="preserve">
          <source>All data is fetched in a single round trip.</source>
          <target state="translated">すべてのデータを1往復で取得します。</target>
        </trans-unit>
        <trans-unit id="40454335b535c042b908582ab2dd06293106ac63" translate="yes" xml:space="preserve">
          <source>All of the mutations we've performed so far have waited on a response from the server before updating the client-side store. Relay offers us a chance to craft an optimistic response of the same shape based on what we expect the server's response to be in the event of a successful mutation.</source>
          <target state="translated">これまでに実行した突然変異はすべて、クライアント側のストアを更新する前にサーバからの応答を待っていました。Relayでは、突然変異が成功した場合のサーバからのレスポンスの予想に基づいて、同じ形の楽観的なレスポンスを作成することができます。</target>
        </trans-unit>
        <trans-unit id="6e5ef228d93a867965453c9210e08a5fc6427932" translate="yes" xml:space="preserve">
          <source>Alternatively a &lt;a href=&quot;refetch-container&quot;&gt;&lt;code&gt;RefetchContainer&lt;/code&gt;&lt;/a&gt; can also be used.</source>
          <target state="translated">または、&lt;a href=&quot;refetch-container&quot;&gt; &lt;code&gt;RefetchContainer&lt;/code&gt; &lt;/a&gt;を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="3cb1f93043bd5b1e4766b2a5f1a916dfbf98f41c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can install &lt;code&gt;relay-compiler&lt;/code&gt; globally so you can access it directly:</source>
          <target state="translated">または、 &lt;code&gt;relay-compiler&lt;/code&gt; をグローバルにインストールして、直接アクセスできるようにすることもできます。</target>
        </trans-unit>
        <trans-unit id="4e7be8aae845923a0feac81e1f7b4b0b1b6931db" translate="yes" xml:space="preserve">
          <source>Although the response is hierarchical, we'll cache it by flattening all the records. Here is an example of how Relay would cache this query response:</source>
          <target state="translated">レスポンスは階層化されていますが、すべてのレコードをフラット化してキャッシュします。以下に、Relayがこのクエリレスポンスをキャッシュする例を示します。</target>
        </trans-unit>
        <trans-unit id="c6ec18663142d1b37b9759d8f91cf8ac740a2752" translate="yes" xml:space="preserve">
          <source>An area we've gotten a lot of questions on was mutations and their configs. Relay Modern introduces a new mutation API that allows records and fields to be updated in a more direct manner.</source>
          <target state="translated">これまで多くの質問を受けてきたのは、ミューテーションとその設定についてでした。Relay Modernでは、レコードやフィールドをより直接的な方法で更新できる新しいミューテーションAPIが導入されました。</target>
        </trans-unit>
        <trans-unit id="16a242bdcfab9509fa528a20336ea8be61d5d155" translate="yes" xml:space="preserve">
          <source>An array containing the field names between the parent and the connection, including the parent and the connection</source>
          <target state="translated">親と接続を含む親と接続の間のフィールド名を含む配列</target>
        </trans-unit>
        <trans-unit id="ab5c749afdc7ed704bf1427839cff1f6c54727ed" translate="yes" xml:space="preserve">
          <source>An example using &lt;code&gt;fetch&lt;/code&gt; looks like this:</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; を使用した例は次のようになります。</target>
        </trans-unit>
        <trans-unit id="ecb9a82e766e01fb5997898864c15b00f3207e54" translate="yes" xml:space="preserve">
          <source>An instance of a &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt; encapsulates an in-memory cache of GraphQL data and a network layer that provides access to your GraphQL server. The Environment object is typically not used by developers directly, instead it is passed to each &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt;, which uses the environment to access, modify, and fetch data. Within a container, the current environment can be accessed via &lt;code&gt;this.props.relay.environment&lt;/code&gt;. This is most commonly used to &lt;a href=&quot;mutations&quot;&gt;execute a mutation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;relay-environment&quot;&gt;リレー環境&lt;/a&gt;のインスタンスは、GraphQLデータのメモリ内キャッシュと、GraphQLサーバーへのアクセスを提供するネットワークレイヤーをカプセル化します。通常、Environmentオブジェクトは開発者が直接使用するのではなく、環境を使用してデータにアクセス、変更、フェッチする各&lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt;に渡されます。コンテナ内では、 &lt;code&gt;this.props.relay.environment&lt;/code&gt; を介して現在の環境にアクセスできます。これは&lt;a href=&quot;mutations&quot;&gt;、突然変異&lt;/a&gt;を実行するために最も一般的に使用されます。</target>
        </trans-unit>
        <trans-unit id="6dd9dc1929b158a9c5ea7752c056cc104664b1ef" translate="yes" xml:space="preserve">
          <source>An object that conforms to the &lt;code&gt;Relay.Environment&lt;/code&gt; interface, such as &lt;code&gt;Relay.Store&lt;/code&gt;.</source>
          <target state="translated">オブジェクトに準拠していること &lt;code&gt;Relay.Environment&lt;/code&gt; などのインターフェース、 &lt;code&gt;Relay.Store&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac7cf5ea35aac5de7114e6afc02d20f82b3316f0" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;onReadyStateChange&lt;/code&gt; callback can be supplied to respond to the events involved with the data fulfillment.</source>
          <target state="translated">オプションの &lt;code&gt;onReadyStateChange&lt;/code&gt; コールバックを提供して、データフルフィルメントに関連するイベントに応答できます。</target>
        </trans-unit>
        <trans-unit id="7303f03f73c25d8e0d64d93962d92858e7741e4b" translate="yes" xml:space="preserve">
          <source>And here's a possible response:</source>
          <target state="translated">そして、考えられる対応がこちら。</target>
        </trans-unit>
        <trans-unit id="369fe458331664a040bf70efbb8b99da198958aa" translate="yes" xml:space="preserve">
          <source>And this fragment can then be used to define the Story container:</source>
          <target state="translated">そして、このフラグメントを使用して Story コンテナを定義することができます。</target>
        </trans-unit>
        <trans-unit id="605ea43af6ae69ff62a257b6fd0223b045c71edf" translate="yes" xml:space="preserve">
          <source>Any field in the payload that can be correlated by DataID with one or more records in the client-side store will be merged with the record(s) in the store.</source>
          <target state="translated">ペイロード内の任意のフィールドで、DataIDによってクライアント側ストア内の1つ以上のレコードと相関があるものは、ストア内のレコードとマージされます。</target>
        </trans-unit>
        <trans-unit id="cfe1cdd7971ecdf1250f379fc5280623f121ecd7" translate="yes" xml:space="preserve">
          <source>Any props that we pass to the constructor of a mutation will become available to its instance methods as &lt;code&gt;this.props&lt;/code&gt;. Like in components used within Relay containers, props for which a corresponding fragment has been defined will be populated by Relay with query data:</source>
          <target state="translated">ミュー &lt;code&gt;this.props&lt;/code&gt; のコンストラクターに渡す小道具は、this.propsとしてインスタンスメソッドで使用できるようになります。Relayコンテナー内で使用されるコンポーネントと同様に、対応するフラグメントが定義されているプロップには、Relayによってクエリデータが入力されます。</target>
        </trans-unit>
        <trans-unit id="2c3c3b69096651daf12db619c2e7045eb0884046" translate="yes" xml:space="preserve">
          <source>Any server can be taught to load a schema and speak GraphQL. Our &lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;examples&lt;/a&gt; use Express.</source>
          <target state="translated">どのサーバーでも、スキーマをロードしてGraphQLを話すように教えることができます。私たちの&lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;例では、&lt;/a&gt; Expressを使用しています。</target>
        </trans-unit>
        <trans-unit id="8a830514fbc11a8668a4369e6666ef8944337af6" translate="yes" xml:space="preserve">
          <source>Applications must supply a &lt;a href=&quot;network-layer&quot;&gt;Network Layer&lt;/a&gt; when creating an instance of a Relay Environment. The network layer is an object conforming to a simple interface through which Relay can execute queries, mutations, and subscriptions. Essentially, this object teaches Relay how to talk to your GraphQL server.</source>
          <target state="translated">リレー環境のインスタンスを作成するとき、アプリケーションは&lt;a href=&quot;network-layer&quot;&gt;ネットワーク層を&lt;/a&gt;提供する必要があります。ネットワークレイヤーは、Relayがクエリ、ミューテーション、サブスクリプションを実行できるシンプルなインターフェースに準拠したオブジェクトです。基本的に、このオブジェクトは、RelayにGraphQLサーバーと通信する方法を教えます。</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="dd4d4251ad9eea93ba8b6656973531a29f150428" translate="yes" xml:space="preserve">
          <source>Array fields</source>
          <target state="translated">配列フィールド</target>
        </trans-unit>
        <trans-unit id="f3aab73669ac6dc9de81f7b41eeb64591c4e0ee7" translate="yes" xml:space="preserve">
          <source>As an example, we can log each mutation that is sent to the server as follows:</source>
          <target state="translated">例として、以下のようにサーバに送信された各突然変異をログに記録することができます。</target>
        </trans-unit>
        <trans-unit id="93df315a58852563161dbb62a33b18e1c4b63051" translate="yes" xml:space="preserve">
          <source>As we've learned, Relay containers declare data requirements as GraphQL fragments. This means that, for example, &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; can be embedded not only in &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt;, but any container that fetches a field of type &lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">これまでに学んだように、リレーコンテナはデータ要件をGraphQLフラグメントとして宣言します。これは、たとえば、 &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; を &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; だけでなく、 &lt;code&gt;User&lt;/code&gt; 型のフィールドをフェッチする任意のコンテナに埋め込むことができることを意味します。</target>
        </trans-unit>
        <trans-unit id="923622cbd0c4bbb9c49d319a01f53817606d02a1" translate="yes" xml:space="preserve">
          <source>As we've learned, Relay fragment containers declare data requirements as GraphQL fragments. We're almost ready to let Relay fulfill the data requirements for these components and render them. However, there is one problem. In order to actually fetch data with GraphQL, we need a query root. For example, we need to ground the &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; fragment in a GraphQL query.</source>
          <target state="translated">これまでに学んだように、リレーフラグメントコンテナーはデータ要件をGraphQLフラグメントとして宣言します。Relayがこれらのコンポーネントのデータ要件を満たし、レンダリングする準備がほぼ整いました。ただし、問題が1つあります。GraphQLを使用して実際にデータをフェッチするには、クエリルートが必要です。たとえば、GraphQLクエリで &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; フラグメントを固定する必要があります。</target>
        </trans-unit>
        <trans-unit id="6a71de49f031297e07457bef14ae0f8572e55b44" translate="yes" xml:space="preserve">
          <source>At this point, you can delete everything up until &lt;code&gt;queryType&lt;/code&gt; in &lt;code&gt;./data/schema.js&lt;/code&gt;.</source>
          <target state="translated">この時点で、あなたはまですべてを削除することができます &lt;code&gt;queryType&lt;/code&gt; で &lt;code&gt;./data/schema.js&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="207aae1b1d93e0ae663b416c543d4e3848a98ef0" translate="yes" xml:space="preserve">
          <source>Authoring a schema</source>
          <target state="translated">スキーマのオーサリング</target>
        </trans-unit>
        <trans-unit id="3eb220f88ae787a8eafb5d737da557d0ab6ff6ca" translate="yes" xml:space="preserve">
          <source>Babel Relay Plugin</source>
          <target state="translated">バベルリレープラグイン</target>
        </trans-unit>
        <trans-unit id="0351d5a9ef82b115e9ed00101cebdddfe0dbad30" translate="yes" xml:space="preserve">
          <source>Base React Component</source>
          <target state="translated">ベースのReactコンポーネント</target>
        </trans-unit>
        <trans-unit id="a6551059bdb95efc2dfbc4b7c2ce6ccc9fcd0365" translate="yes" xml:space="preserve">
          <source>Before going any further, we need to serialize our executable schema to JSON for use by the Relay.QL transpiler, then start up the server. From the command line:</source>
          <target state="translated">先に進む前に、実行可能なスキーマをJSONにシリアライズして、Relay.QLトランスパイラで使用する必要があります。コマンドラインから</target>
        </trans-unit>
        <trans-unit id="97cecb9e6bdc8256a26df17eef65a9b41e163cee" translate="yes" xml:space="preserve">
          <source>Before taking a deep dive into the mutations API, let's look at a complete example. Here, we subclass &lt;code&gt;Relay.Mutation&lt;/code&gt; to create a custom mutation that we can use to like a story.</source>
          <target state="translated">ミューテーションAPIについて詳しく説明する前に、完全な例を見てみましょう。ここでは、 &lt;code&gt;Relay.Mutation&lt;/code&gt; をサブクラス化して、ストーリーを好きになるために使用できるカスタム変異を作成します。</target>
        </trans-unit>
        <trans-unit id="949c7a85f6d836f247f0195b7eaa99f0c336e992" translate="yes" xml:space="preserve">
          <source>Behaviors can be one of &lt;code&gt;'append'&lt;/code&gt;, &lt;code&gt;'ignore'&lt;/code&gt;, &lt;code&gt;'prepend'&lt;/code&gt;, &lt;code&gt;'refetch'&lt;/code&gt;, or &lt;code&gt;'remove'&lt;/code&gt;.</source>
          <target state="translated">動作は、 &lt;code&gt;'append'&lt;/code&gt; 、 &lt;code&gt;'ignore'&lt;/code&gt; 、 &lt;code&gt;'prepend'&lt;/code&gt; 、 &lt;code&gt;'refetch'&lt;/code&gt; 、または &lt;code&gt;'remove'&lt;/code&gt; のいずれかです。</target>
        </trans-unit>
        <trans-unit id="a13e0d17d14c44107ca60ab513e5d71d5662c000" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;Faction&lt;/code&gt; and &lt;code&gt;Ship&lt;/code&gt; have identifiers that we can use to refetch them. We expose this capability to Relay through the &lt;code&gt;Node&lt;/code&gt; interface and the &lt;code&gt;node&lt;/code&gt; field on the root query type.</source>
          <target state="translated">&lt;code&gt;Faction&lt;/code&gt; と &lt;code&gt;Ship&lt;/code&gt; の両方には、それらを再フェッチするために使用できる識別子があります。この機能は、 &lt;code&gt;Node&lt;/code&gt; インターフェースとルートクエリタイプの &lt;code&gt;node&lt;/code&gt; フィールドを介してリレーするために公開します。</target>
        </trans-unit>
        <trans-unit id="3148373f94223f76742328ea5464dd9f30817fe7" translate="yes" xml:space="preserve">
          <source>But now, we can also create routes for arbitrary user IDs. For example, if we wanted to construct a route that fetched data for a user defined by the &lt;code&gt;userID&lt;/code&gt; query parameter, we might use:</source>
          <target state="translated">しかし今では、任意のユーザーIDのルートを作成することもできます。たとえば、 &lt;code&gt;userID&lt;/code&gt; クエリパラメータで定義されたユーザーのデータをフェッチするルートを作成する場合は、次のように使用します。</target>
        </trans-unit>
        <trans-unit id="1862f3355eff810374142f7e656f80df21c55213" translate="yes" xml:space="preserve">
          <source>By convention, mutations are named as verbs, their inputs are the name with &quot;Input&quot; appended at the end, and they return an object that is the name with &quot;Payload&quot; appended.</source>
          <target state="translated">慣例では、突然変異は動詞として名前が付けられ、その入力は最後に &quot;Input &quot;が付加された名前になり、&quot;Payload &quot;が付加された名前のオブジェクトが返されます。</target>
        </trans-unit>
        <trans-unit id="178b930518b904dbc5bd0f441c18fc870aac28c3" translate="yes" xml:space="preserve">
          <source>By default, Relay assumes that GraphQL is served at &lt;code&gt;/graphql&lt;/code&gt; relative to the origin where our application is served. This can be re-configured by injecting a custom instantiation of the default network layer.</source>
          <target state="translated">デフォルトでは、RelayはGraphQLが、アプリケーションが提供されているオリジンに対して &lt;code&gt;/graphql&lt;/code&gt; で提供されていると想定しています。これは、デフォルトのネットワーク層のカスタムインスタンスを挿入することで再構成できます。</target>
        </trans-unit>
        <trans-unit id="c01482f7fe504d2a5e3cc944236d88811dd8d351" translate="yes" xml:space="preserve">
          <source>By default, nothing is rendered while loading data for the initial render. If a previous set of &lt;code&gt;Component&lt;/code&gt; and &lt;code&gt;route&lt;/code&gt; were fulfilled and rendered, the default behavior is to continue rendering the previous view.</source>
          <target state="translated">デフォルトでは、初期レンダリング用のデータをロードしている間は何もレンダリングされません。 &lt;code&gt;Component&lt;/code&gt; と &lt;code&gt;route&lt;/code&gt; 以前のセットが満たされ、レンダリングされた場合、デフォルトの動作では、前のビューのレンダリングが続行されます。</target>
        </trans-unit>
        <trans-unit id="4375c1481c81a0b6d8e08ac19523704d5d4da90b" translate="yes" xml:space="preserve">
          <source>Cache Consistency</source>
          <target state="translated">キャッシュの一貫性</target>
        </trans-unit>
        <trans-unit id="14776554d5693e023c3ac7a5a65e4a5058537dfe" translate="yes" xml:space="preserve">
          <source>Cache Updates</source>
          <target state="translated">キャッシュ更新</target>
        </trans-unit>
        <trans-unit id="eed1812845bba88a7ea96dc0731ed87a6365fcc0" translate="yes" xml:space="preserve">
          <source>Caching A Graph</source>
          <target state="translated">グラフのキャッシング</target>
        </trans-unit>
        <trans-unit id="c3fbd240479228aa26381115ef997022e9773856" translate="yes" xml:space="preserve">
          <source>Call this to optimistically apply an update to the store.</source>
          <target state="translated">これを呼び出して楽観的にストアにアップデートを適用します。</target>
        </trans-unit>
        <trans-unit id="ef28016b715246d53e3c0aef32bef448a5df1961" translate="yes" xml:space="preserve">
          <source>Call this to send the mutation to the server.</source>
          <target state="translated">これを呼び出すと、突然変異をサーバーに送信します。</target>
        </trans-unit>
        <trans-unit id="36653c1ff08edcb50e3d0e9893272cf6219ebfe7" translate="yes" xml:space="preserve">
          <source>Callers must provide an appropriate &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;variables&lt;/code&gt;. As per the GraphQL Relay Specification:</source>
          <target state="translated">呼び出し元は、適切な &lt;code&gt;query&lt;/code&gt; と &lt;code&gt;variables&lt;/code&gt; 提供する必要があります。GraphQLリレー仕様に従って：</target>
        </trans-unit>
        <trans-unit id="ec585c24a23bd7001c34d954b9fe9b0796cec5f2" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;hasOptimisticUpdate&lt;/code&gt; with a record from &lt;code&gt;this.props&lt;/code&gt; will return whether that given record is affected by an optimistic mutation. It allows the component to render local optimistic changes differently from data that has successfully synchronized with the server.</source>
          <target state="translated">&lt;code&gt;hasOptimisticUpdate&lt;/code&gt; のレコードを使用してhasOptimisticUpdateを呼び出すと、指定されたレコードが楽観的ミュー &lt;code&gt;this.props&lt;/code&gt; 影響を受けるかどうかが返されます。これにより、コンポーネントは、サーバーと正常に同期したデータとは異なり、ローカルの楽観的な変更をレンダリングできます。</target>
        </trans-unit>
        <trans-unit id="7e92933047a9a8b8023050178520d6236fd1d0bd" translate="yes" xml:space="preserve">
          <source>Calling Component Instance Methods</source>
          <target state="translated">コンポーネント インスタンス メソッドの呼び出し</target>
        </trans-unit>
        <trans-unit id="539001ff0ade75c366a1d2f2ae990718f2b4bd9b" translate="yes" xml:space="preserve">
          <source>Can QueryRenderer using Classic Environment (&lt;code&gt;Store&lt;/code&gt; in &lt;code&gt;react-relay/classic&lt;/code&gt;) use:</source>
          <target state="translated">Classic環境を使用して缶QueryRenderer（ &lt;code&gt;Store&lt;/code&gt; で &lt;code&gt;react-relay/classic&lt;/code&gt; 使用）：</target>
        </trans-unit>
        <trans-unit id="4aacaa8308c0d89cb19bc6280f172bcb3027eef8" translate="yes" xml:space="preserve">
          <source>Can QueryRenderer using Modern Environment use:</source>
          <target state="translated">現代環境を利用した QueryRenderer は使用できますか?</target>
        </trans-unit>
        <trans-unit id="1003218887eb40c1f0a58bc7b7505d15f23175bf" translate="yes" xml:space="preserve">
          <source>Can React Classic Component use:</source>
          <target state="translated">React Classic Componentを使用することができます。</target>
        </trans-unit>
        <trans-unit id="84238b1b418a17b213190530f83d669483ad4f99" translate="yes" xml:space="preserve">
          <source>Can React Compat Component use:</source>
          <target state="translated">React Compat Componentを使用することができます。</target>
        </trans-unit>
        <trans-unit id="1c53c8d6a82f41f51bcb44a951f6d42bbd674773" translate="yes" xml:space="preserve">
          <source>Can React Modern Component use:</source>
          <target state="translated">React Modern Componentを使用することができます。</target>
        </trans-unit>
        <trans-unit id="ce811e756a396388182f7a8551a77979cea636ea" translate="yes" xml:space="preserve">
          <source>Can RelayRootContainer use:</source>
          <target state="translated">RelayRootContainerを使用することができます。</target>
        </trans-unit>
        <trans-unit id="918e312c8dc15e096c8aa60a584cd24fb9b592cd" translate="yes" xml:space="preserve">
          <source>Changing Arguments</source>
          <target state="translated">引数の変更</target>
        </trans-unit>
        <trans-unit id="51cdd39226322d9d0efb448c0d03eb64cb6c777d" translate="yes" xml:space="preserve">
          <source>Changing one thing in a system can have a ripple effect that causes other things to change in turn. Imagine a mutation that we can use to accept a friend request. This can have wide implications:</source>
          <target state="translated">システムの中で一つのことを変更すると、他のことを順番に変更させる波及効果を持つことができます。友達のリクエストを受け入れるための突然変異を想像してみてください。これは幅広い意味合いを持つ可能性があります。</target>
        </trans-unit>
        <trans-unit id="bb73c6b849ccfd7df64b939d3890bbba8b94e10a" translate="yes" xml:space="preserve">
          <source>Classic Component</source>
          <target state="translated">クラシックコンポーネント</target>
        </trans-unit>
        <trans-unit id="9e402ea82ec577f1a7b994361d91b4f9ac1cf510" translate="yes" xml:space="preserve">
          <source>Classic Mutation</source>
          <target state="translated">古典的な突然変異</target>
        </trans-unit>
        <trans-unit id="76be385c076bd3cf6a0e76bbefee914b22199f01" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;&amp;lt;RelayRootContainer&amp;gt;&lt;/code&gt;</source>
          <target state="translated">クラシック： &lt;code&gt;&amp;lt;RelayRootContainer&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9450d4893299b4475b958954ce614f6339c011c9" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;Relay.createContainer&lt;/code&gt;</source>
          <target state="translated">クラシック： &lt;code&gt;Relay.createContainer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdacd86df881f947250264b6f74153f74ca2e17b" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.commitUpdate(mutation...)&lt;/code&gt;</source>
          <target state="translated">クラシック： &lt;code&gt;this.props.relay.commitUpdate(mutation...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4496ce0ff60c519ddb23c737b94a8c3d0f8fae44" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt;</source>
          <target state="translated">クラシック： &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4718307cda6ad09eb778eec75ee2c5f20cd45961" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.setVariable({count: prevCount + pageSize}...)&lt;/code&gt;</source>
          <target state="translated">クラシック： &lt;code&gt;this.props.relay.setVariable({count: prevCount + pageSize}...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a88cd760542eea1905cd9d8225750e276c483cde" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.setVariable({foo: bar}...)&lt;/code&gt;</source>
          <target state="translated">クラシック： &lt;code&gt;this.props.relay.setVariable({foo: bar}...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6f5633b3ae0188027fabbde415e0f3fcc71e6c3" translate="yes" xml:space="preserve">
          <source>Client Caching</source>
          <target state="translated">クライアントキャッシング</target>
        </trans-unit>
        <trans-unit id="d4d64d5c478ea7fd0df7b8579f158dc6ea90455b" translate="yes" xml:space="preserve">
          <source>Client Schema Extensions (Experimental)</source>
          <target state="translated">クライアントスキーマ拡張 (実験)</target>
        </trans-unit>
        <trans-unit id="a359c7ebffb6706034dbf0f013aa73bcc550292c" translate="yes" xml:space="preserve">
          <source>Comparing Relay Classic and Relay Modern</source>
          <target state="translated">Relay ClassicとRelay Modernを比較</target>
        </trans-unit>
        <trans-unit id="c54dbbae41b051460dcc8e3c9aa6f310af3f2775" translate="yes" xml:space="preserve">
          <source>Compat Component</source>
          <target state="translated">コンパットコンポーネント</target>
        </trans-unit>
        <trans-unit id="2171ca54b3db409d7e88bfa689ea2ab5583955c6" translate="yes" xml:space="preserve">
          <source>Compat Mode</source>
          <target state="translated">コンパットモード</target>
        </trans-unit>
        <trans-unit id="ef1a53514cc801546fdbf4bd01e2b4b764618f78" translate="yes" xml:space="preserve">
          <source>Compat Mutation</source>
          <target state="translated">コンパットの突然変異</target>
        </trans-unit>
        <trans-unit id="7ae7318a99d95f75927a3ae6b936e04d175cc04e" translate="yes" xml:space="preserve">
          <source>Compatibility Cheatsheet</source>
          <target state="translated">互換性チェックシート</target>
        </trans-unit>
        <trans-unit id="6d9f235cb9c7c65f0cf0b1b0814cadde6d86abcb" translate="yes" xml:space="preserve">
          <source>Compatibility Mode</source>
          <target state="translated">互換性モード</target>
        </trans-unit>
        <trans-unit id="89e9d1be17321688f8d0501eb1a3bf2c6ca26c3e" translate="yes" xml:space="preserve">
          <source>Complete details on how the server should behave are available in the &lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;GraphQL Cursor Connections&lt;/a&gt; spec.</source>
          <target state="translated">サーバーの動作に関する詳細は、&lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;GraphQL Cursor Connections&lt;/a&gt;仕様に記載されています。</target>
        </trans-unit>
        <trans-unit id="29619ae00dc1b1f13f0d8573c5ca62184c0a6a94" translate="yes" xml:space="preserve">
          <source>Complete details on how the server should behave are available in the &lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;GraphQL Input Object Mutations&lt;/a&gt; spec.</source>
          <target state="translated">サーバーの動作の詳細については、&lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;GraphQL入力オブジェクト変更&lt;/a&gt;仕様をご覧ください。</target>
        </trans-unit>
        <trans-unit id="dd80bd3e0728573910ceff942d6bf05bb7333573" translate="yes" xml:space="preserve">
          <source>Complete details on how the server should behave are available in the &lt;a href=&quot;https://facebook.github.io/relay/graphql/objectidentification.htm&quot;&gt;GraphQL Object Identification&lt;/a&gt; spec.</source>
          <target state="translated">サーバーの動作の詳細については、&lt;a href=&quot;https://facebook.github.io/relay/graphql/objectidentification.htm&quot;&gt;GraphQLオブジェクト識別&lt;/a&gt;仕様を参照してください。</target>
        </trans-unit>
        <trans-unit id="c92c529e0731c57efd7550480196484040b33c3e" translate="yes" xml:space="preserve">
          <source>Component</source>
          <target state="translated">Component</target>
        </trans-unit>
        <trans-unit id="725a4ffad64df11f9defa669f85ec107f9dc492d" translate="yes" xml:space="preserve">
          <source>Component and Route</source>
          <target state="translated">コンポーネントとルート</target>
        </trans-unit>
        <trans-unit id="94c5c072cfb48e6d9ea12f613a057a202a5c287b" translate="yes" xml:space="preserve">
          <source>Components can change their data requirements by using &lt;code&gt;setVariables&lt;/code&gt; to request an update to the current set of &lt;code&gt;variables&lt;/code&gt;.</source>
          <target state="translated">コンポーネントは、 &lt;code&gt;setVariables&lt;/code&gt; を使用して現在の &lt;code&gt;variables&lt;/code&gt; セットの更新を要求することにより、データ要件を変更できます。</target>
        </trans-unit>
        <trans-unit id="31ae8b82fb482703d4497f95cafdbd464174a12e" translate="yes" xml:space="preserve">
          <source>Components can inspect pending mutations on any record (i.e. data made available in props with a corresponding fragment). Calling &lt;code&gt;getPendingTransactions&lt;/code&gt; with a record will return a list of the pending mutation transactions that affect that particular record.</source>
          <target state="translated">コンポーネントは、任意のレコード（つまり、対応するフラグメントを持つ小道具で使用可能にされたデータ）で保留中の変異を検査できます。レコードを &lt;code&gt;getPendingTransactions&lt;/code&gt; してgetPendingTransactionsを呼び出すと、その特定のレコードに影響する保留中のミューテーショントランザクションのリストが返されます。</target>
        </trans-unit>
        <trans-unit id="deee480cd52fae7c121c1d7b8b86ecda66617156" translate="yes" xml:space="preserve">
          <source>Composing Fragments</source>
          <target state="translated">フラグメントの構成</target>
        </trans-unit>
        <trans-unit id="2a321a9ac4f3111d95368aba4e87b1917d75348e" translate="yes" xml:space="preserve">
          <source>Composing Views - It's Plain React</source>
          <target state="translated">ビューを構成する-シンプルなReact</target>
        </trans-unit>
        <trans-unit id="723e2c15fe85b32b7d864e21eb29e93116b04e14" translate="yes" xml:space="preserve">
          <source>Composing child component fragments in a parent fragment.</source>
          <target state="translated">親フラグメントに子コンポーネントフラグメントを合成する。</target>
        </trans-unit>
        <trans-unit id="f82641d3cbab73b5e585b20db3196f350cb839d5" translate="yes" xml:space="preserve">
          <source>Composing fragments defined as local variables.</source>
          <target state="translated">ローカル変数として定義されたフラグメントを構成します。</target>
        </trans-unit>
        <trans-unit id="114b9abd3f0b27b8a9b5084318c5af838acdb163" translate="yes" xml:space="preserve">
          <source>Composing the data descriptions.</source>
          <target state="translated">データの記述を構成する。</target>
        </trans-unit>
        <trans-unit id="59d6b2067a223146a5ead92a4c5fe072d43c9a1e" translate="yes" xml:space="preserve">
          <source>Composing the fragments of child components is discussed in detail in the &lt;a href=&quot;guides-containers&quot;&gt;Containers Guide&lt;/a&gt;, but here's a quick example:</source>
          <target state="translated">子コンポーネントのフラグメントの作成については、&lt;a href=&quot;guides-containers&quot;&gt;コンテナガイド&lt;/a&gt;で詳しく説明していますが、簡単な例を次に示します。</target>
        </trans-unit>
        <trans-unit id="a7b041783bd841c2982c635611a14b9b0478fc32" translate="yes" xml:space="preserve">
          <source>Composing the view logic, and</source>
          <target state="translated">ビューロジックを構成し</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="9d60520748b88da0348eeb8f6543f6f98cdbd262" translate="yes" xml:space="preserve">
          <source>Conditional fields</source>
          <target state="translated">条件付きフィールド</target>
        </trans-unit>
        <trans-unit id="6355cff1e61b5cd688cec493b080516655b2ac6a" translate="yes" xml:space="preserve">
          <source>Configs</source>
          <target state="translated">Configs</target>
        </trans-unit>
        <trans-unit id="6512ee1541e9a6c52d5bf7cf465332e8df25ea3c" translate="yes" xml:space="preserve">
          <source>Connection</source>
          <target state="translated">Connection</target>
        </trans-unit>
        <trans-unit id="81ea0a30d213381b26e05bce9c491003535b147a" translate="yes" xml:space="preserve">
          <source>Consider an input with a server-defined placeholder text and an imperative method to focus the input node:</source>
          <target state="translated">サーバー定義のプレースホルダテキストを持つ入力と、入力ノードにフォーカスを当てるための命令的な方法を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="1956d506ca97255f5713770475161b61eb6cde73" translate="yes" xml:space="preserve">
          <source>Consider rendering the text and comments of a story along with the corresponding author names and photos. Here's the GraphQL query:</source>
          <target state="translated">ストーリーのテキストとコメントを、対応する著者名と写真とともにレンダリングすることを考えてみましょう。これがGraphQLクエリです。</target>
        </trans-unit>
        <trans-unit id="e6443af99d2f470f50affd5057bf48db2d09dae4" translate="yes" xml:space="preserve">
          <source>Container</source>
          <target state="translated">Container</target>
        </trans-unit>
        <trans-unit id="0d5a8d03518c194626d6e3e124e7de20c17a7fe5" translate="yes" xml:space="preserve">
          <source>Container Composition</source>
          <target state="translated">コンテナの構成</target>
        </trans-unit>
        <trans-unit id="b625b62c69e181700306e0871c20a6c94eaa2510" translate="yes" xml:space="preserve">
          <source>Container Specification</source>
          <target state="translated">コンテナ仕様</target>
        </trans-unit>
        <trans-unit id="dfe33c87ae0783b9497dae2f22418a5e90385aa4" translate="yes" xml:space="preserve">
          <source>Container.getFragment()</source>
          <target state="translated">Container.getFragment()</target>
        </trans-unit>
        <trans-unit id="e040a458f46532a90ec69fa0b4bfc33ba151c98b" translate="yes" xml:space="preserve">
          <source>Containers</source>
          <target state="translated">Containers</target>
        </trans-unit>
        <trans-unit id="4b51306faf49817c8299a221a2777da9319cb8d3" translate="yes" xml:space="preserve">
          <source>Containers are Higher-Order Components</source>
          <target state="translated">コンテナは高次部品</target>
        </trans-unit>
        <trans-unit id="46e795775ec1e8e3e71a6a5641d35b084e19a5a9" translate="yes" xml:space="preserve">
          <source>Containers can define a &lt;code&gt;prepareVariables&lt;/code&gt; method which provides the opportunity to modify the variables that are available to fragments. The new variables can be generated based on the previous variables (or the &lt;code&gt;initialVariables&lt;/code&gt; if no previous ones exist) in addition to the runtime environment.</source>
          <target state="translated">コンテナーは、フラグメントで使用可能な変数を変更する機会を提供する &lt;code&gt;prepareVariables&lt;/code&gt; メソッドを定義できます。新しい変数は、ランタイム環境に加えて、以前の変数（または、以前の変数が存在しない場合は &lt;code&gt;initialVariables&lt;/code&gt; ）に基づいて生成できます。</target>
        </trans-unit>
        <trans-unit id="ad0eb4a22e44d99ae045c52ec3f202dc664a29f9" translate="yes" xml:space="preserve">
          <source>Containers declare data requirements on &lt;code&gt;fragments&lt;/code&gt; using GraphQL fragments.</source>
          <target state="translated">コンテナは、GraphQLフラグメントを使用して &lt;code&gt;fragments&lt;/code&gt; データ要件を宣言します。</target>
        </trans-unit>
        <trans-unit id="8928f5de2a918d60f1bbb5d72e6a68cb7502e86a" translate="yes" xml:space="preserve">
          <source>Convenience method that wraps the constructor, passing some default parameters and returning an instance.</source>
          <target state="translated">コンストラクタをラップし、いくつかのデフォルトパラメータを渡してインスタンスを返す便利なメソッドです。</target>
        </trans-unit>
        <trans-unit id="dd226f43ba5c8ff842931a3ca2796d7c444510a9" translate="yes" xml:space="preserve">
          <source>Conversion Playbook</source>
          <target state="translated">コンバージョンプレイブック</target>
        </trans-unit>
        <trans-unit id="aca075e23eed144339279d097d6fa88dc0718ec3" translate="yes" xml:space="preserve">
          <source>Conversion Scripts</source>
          <target state="translated">変換スクリプト</target>
        </trans-unit>
        <trans-unit id="e93c185376ad3e3749d528694597be4eb780596d" translate="yes" xml:space="preserve">
          <source>Create a mutation instance using the &lt;code&gt;new&lt;/code&gt; keyword, optionally passing it some props. Note that &lt;code&gt;this.props&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; available inside the constructor function, but are set for all the methods mentioned below (&lt;code&gt;getCollisionKey&lt;/code&gt;, &lt;code&gt;getOptimisticResponse&lt;/code&gt;, etc). This restriction is due to the fact that mutation props may depend on data from the RelayEnvironment, which isn't known until the mutation is applied with &lt;code&gt;applyUpdate&lt;/code&gt; or &lt;code&gt;commitUpdate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; キーワードを使用してミューテーションインスタンスを作成し、必要に応じて小道具を渡します。 &lt;code&gt;this.props&lt;/code&gt; はコンストラクター関数内で&lt;em&gt;は&lt;/em&gt;使用でき&lt;em&gt;ませ&lt;/em&gt;んが、以下で説明するすべてのメソッド（ &lt;code&gt;getCollisionKey&lt;/code&gt; 、 &lt;code&gt;getOptimisticResponse&lt;/code&gt; など）に対して設定されることに注意してください。この制限は、変異の小道具がRelayEnvironmentからのデータに依存する可能性があるという事実によるものです。これは、変異が &lt;code&gt;applyUpdate&lt;/code&gt; または &lt;code&gt;commitUpdate&lt;/code&gt; で適用されるまで不明です。</target>
        </trans-unit>
        <trans-unit id="70fb5b0ec1a182be6e0a0d9950900f7bbb367668" translate="yes" xml:space="preserve">
          <source>Create a route instance using the &lt;code&gt;new&lt;/code&gt; keyword, optionally passing it some params.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; キーワードを使用してルートインスタンスを作成し、オプションでいくつかのパラメータを渡します。</target>
        </trans-unit>
        <trans-unit id="22330ce575ca322006e65a1cba21c0878bcce956" translate="yes" xml:space="preserve">
          <source>Creates a new Relay Container - see the &lt;a href=&quot;guides-containers&quot;&gt;Container Guide&lt;/a&gt; for more details and examples.</source>
          <target state="translated">新しいリレーコンテナーを作成します- 詳細と例については、&lt;a href=&quot;guides-containers&quot;&gt;コンテナーガイド&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="cc084a8dfcc6a7bce1de7aefac278e961edc50ea" translate="yes" xml:space="preserve">
          <source>Currently the easiest way to create a network layer is via a helper from the &lt;code&gt;relay-runtime&lt;/code&gt; package:</source>
          <target state="translated">現在、ネットワーク層を作成する最も簡単な方法は、 &lt;code&gt;relay-runtime&lt;/code&gt; パッケージのヘルパーを使用することです。</target>
        </trans-unit>
        <trans-unit id="461be9b9f59ebf2cd3bfe288b44d41bb20a992dc" translate="yes" xml:space="preserve">
          <source>Custom HTTP headers can be configured by providing a &lt;code&gt;headers&lt;/code&gt; object:</source>
          <target state="translated">カスタムHTTPヘッダーは、 &lt;code&gt;headers&lt;/code&gt; オブジェクトを提供することで構成できます。</target>
        </trans-unit>
        <trans-unit id="e441c87bb7618c55b15a3915a29a65fc20c0d1cd" translate="yes" xml:space="preserve">
          <source>Custom Network Layers</source>
          <target state="translated">カスタムネットワークレイヤー</target>
        </trans-unit>
        <trans-unit id="c604943e72b71d4741cddde2419706b8dc35d372" translate="yes" xml:space="preserve">
          <source>Custom Routing and More</source>
          <target state="translated">カスタムルーティングとその他</target>
        </trans-unit>
        <trans-unit id="3fe80ac6912200b4e6e928a52d6c87fd5c777197" translate="yes" xml:space="preserve">
          <source>Custom network layers must conform to the following &lt;a href=&quot;interfaces-relay-network-layer&quot;&gt;RelayNetworkLayer&lt;/a&gt; interface. Although the default network layer is an instantiable class that accepts some configuration, this is not a requirement of an injected network layer.</source>
          <target state="translated">カスタムネットワークレイヤーは、次の&lt;a href=&quot;interfaces-relay-network-layer&quot;&gt;RelayNetworkLayer&lt;/a&gt;インターフェイスに準拠する必要があります。デフォルトのネットワーク層は、いくつかの構成を受け入れるインスタンス化可能なクラスですが、これは注入されたネットワーク層の要件ではありません。</target>
        </trans-unit>
        <trans-unit id="342f49485ae8bc8e1ade62ea93e337457051f472" translate="yes" xml:space="preserve">
          <source>Custom network layers that must conform to the &lt;code&gt;RelayNetworkLayer&lt;/code&gt; interface.</source>
          <target state="translated">&lt;code&gt;RelayNetworkLayer&lt;/code&gt; インターフェイスに準拠する必要があるカスタムネットワークレイヤー。</target>
        </trans-unit>
        <trans-unit id="74c9c9c8ea99084415bd2064a41ac8fc43148678" translate="yes" xml:space="preserve">
          <source>Data Components aka Containers</source>
          <target state="translated">データ コンポーネント(別名:コンテナ</target>
        </trans-unit>
        <trans-unit id="682fde2c24e47bc1edbae33948606de2438e015b" translate="yes" xml:space="preserve">
          <source>Data Dependencies With GraphQL</source>
          <target state="translated">GraphQLによるデータの依存関係</target>
        </trans-unit>
        <trans-unit id="b8344c50bb3999d69b17cd5abd2f78e4f029419a" translate="yes" xml:space="preserve">
          <source>Data Masking</source>
          <target state="translated">データマスキング</target>
        </trans-unit>
        <trans-unit id="7054bcb2316977418a434163d17919c53dc34953" translate="yes" xml:space="preserve">
          <source>Data fetched as a result of a &lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; config is not written into the client store, but you can add code that processes it in the &lt;code&gt;onSuccess&lt;/code&gt; callback that you pass into &lt;code&gt;commitUpdate()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; 構成の結果としてフェッチされたデータはクライアントストアに書き込まれませんが、 &lt;code&gt;commitUpdate()&lt;/code&gt; に渡す &lt;code&gt;onSuccess&lt;/code&gt; コールバックにそれを処理するコードを追加できます。</target>
        </trans-unit>
        <trans-unit id="af0a7349a2e7fc64dce9051e92bfe24510a15ba4" translate="yes" xml:space="preserve">
          <source>Data-Fetching APIs</source>
          <target state="translated">データフェッチ API</target>
        </trans-unit>
        <trans-unit id="303a7cb486f5bdd65204f79dab8db7f52fcbe4b2" translate="yes" xml:space="preserve">
          <source>Data/View Consistency</source>
          <target state="translated">データ/ビューの一貫性</target>
        </trans-unit>
        <trans-unit id="895b27c88016513d278a0ce3dc0663fae3829d58" translate="yes" xml:space="preserve">
          <source>Debugging</source>
          <target state="translated">Debugging</target>
        </trans-unit>
        <trans-unit id="ed85a15e615bc7cc2aa9ef71ae94ad5fcb7456cf" translate="yes" xml:space="preserve">
          <source>Debugging Programmatically</source>
          <target state="translated">プログラムによるデバッグ</target>
        </trans-unit>
        <trans-unit id="45cae91f4ddfa0491f43cb639f9ed34ee522658d" translate="yes" xml:space="preserve">
          <source>Debugging Visually</source>
          <target state="translated">視覚的なデバッグ</target>
        </trans-unit>
        <trans-unit id="f33d59090001ed2c388b4cc1db43054af86f06dd" translate="yes" xml:space="preserve">
          <source>Default Network Layer</source>
          <target state="translated">デフォルトのネットワークレイヤ</target>
        </trans-unit>
        <trans-unit id="20f0fc44b4326d9865c55f56d274d841f7d0587e" translate="yes" xml:space="preserve">
          <source>DefaultNetworkLayer (static property)</source>
          <target state="translated">DefaultNetworkLayer(静的プロパティ</target>
        </trans-unit>
        <trans-unit id="af5bf36afc63e00856e220e9305692ac4cae2b78" translate="yes" xml:space="preserve">
          <source>Design a fat query that covers every possible field that could change:</source>
          <target state="translated">変更される可能性のあるすべてのフィールドをカバーするように、太いクエリを設計します。</target>
        </trans-unit>
        <trans-unit id="28c82071e940360118b0611d5c912a71c32a0100" translate="yes" xml:space="preserve">
          <source>Directives</source>
          <target state="translated">Directives</target>
        </trans-unit>
        <trans-unit id="ef7942184e9ad574a626b6cd3619cdb041e9c029" translate="yes" xml:space="preserve">
          <source>During this migration, use the &lt;a href=&quot;relay-compat&quot;&gt;Relay Compat&lt;/a&gt; tools and APIs to work with both Relay Classic and Relay Modern.</source>
          <target state="translated">この移行中に、&lt;a href=&quot;relay-compat&quot;&gt;Relay Compat&lt;/a&gt;ツールとAPIを使用して、Relay ClassicとRelay Modernの両方を操作します。</target>
        </trans-unit>
        <trans-unit id="7c5b3fea8b3510ceda05e64bba7877572b147261" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;RelayMutationTransaction&lt;/code&gt; has methods to check the status of the mutation and provide ways to rollback or resend the mutation as needed.</source>
          <target state="translated">各 &lt;code&gt;RelayMutationTransaction&lt;/code&gt; には、ミューテーションのステータスを確認し、必要に応じてミューテーションをロールバックまたは再送信する方法を提供するメソッドがあります。</target>
        </trans-unit>
        <trans-unit id="bd362bb1462055d845230a17457c0b8e8d86a3b8" translate="yes" xml:space="preserve">
          <source>Either an instance of &lt;code&gt;Relay.Route&lt;/code&gt; or an object with the &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;queries&lt;/code&gt;, and optionally the &lt;code&gt;params&lt;/code&gt; properties.</source>
          <target state="translated">&lt;code&gt;Relay.Route&lt;/code&gt; のインスタンス、または &lt;code&gt;name&lt;/code&gt; 、 &lt;code&gt;queries&lt;/code&gt; 、およびオプションで &lt;code&gt;params&lt;/code&gt; プロパティを持つオブジェクトのいずれか。</target>
        </trans-unit>
        <trans-unit id="d443a1185575c125d61e0af393b044d7b06ef572" translate="yes" xml:space="preserve">
          <source>Environment</source>
          <target state="translated">Environment</target>
        </trans-unit>
        <trans-unit id="b887632c87cffc81f6686f76c25016e576fb2182" translate="yes" xml:space="preserve">
          <source>Even though we have access to the &lt;code&gt;data&lt;/code&gt; object in &lt;code&gt;renderFetched&lt;/code&gt;, the actual data is intentionally opaque. This prevents the &lt;code&gt;renderFetched&lt;/code&gt; from creating an implicit dependency on the fragments declared by &lt;code&gt;Component&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;renderFetched&lt;/code&gt; で &lt;code&gt;data&lt;/code&gt; オブジェクトにアクセスできる場合でも、実際のデータは意図的に不透明です。これにより、 &lt;code&gt;renderFetched&lt;/code&gt; が &lt;code&gt;Component&lt;/code&gt; によって宣言されたフラグメントに暗黙的な依存関係を作成するのを防ぎます。</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="47edfe63fdfee7ee20d0d17ccd2198d126f5e61d" translate="yes" xml:space="preserve">
          <source>Examples on how to migrate &lt;code&gt;this.props.setVariables&lt;/code&gt; calls from the old API.</source>
          <target state="translated">&lt;code&gt;this.props.setVariables&lt;/code&gt; 呼び出しを古いAPIから移行する方法の例。</target>
        </trans-unit>
        <trans-unit id="dba94b198da2fb33fd23ea18f305f3d0a3ec1059" translate="yes" xml:space="preserve">
          <source>Extensible Core</source>
          <target state="translated">拡張可能コア</target>
        </trans-unit>
        <trans-unit id="2dd50f5706aa755699729587eac1b10f1cff5f0e" translate="yes" xml:space="preserve">
          <source>FIELDS_CHANGE</source>
          <target state="translated">FIELDS_CHANGE</target>
        </trans-unit>
        <trans-unit id="48bf3bbfe2cde9b89a0197b2bfecef97b15ae5d4" translate="yes" xml:space="preserve">
          <source>Fetching Data</source>
          <target state="translated">データの取得</target>
        </trans-unit>
        <trans-unit id="9fa4dbe72754c9ca8a7a48295981890f655e2aba" translate="yes" xml:space="preserve">
          <source>Fetching Data For a View</source>
          <target state="translated">ビューのデータ取得</target>
        </trans-unit>
        <trans-unit id="ec6417097316a1a14f3a999d488c8c77877598bd" translate="yes" xml:space="preserve">
          <source>Fetching Data from the Server</source>
          <target state="translated">サーバーからのデータの取得</target>
        </trans-unit>
        <trans-unit id="a342eda81c049d657e5bd1f80671b4b62b62acba" translate="yes" xml:space="preserve">
          <source>Fetching all the data for a view hierarchy.</source>
          <target state="translated">ビュー階層のすべてのデータを取得します。</target>
        </trans-unit>
        <trans-unit id="448b955ee10782eac37b116fa4e7872f8363dbf4" translate="yes" xml:space="preserve">
          <source>Fewer Requirements around Routing</source>
          <target state="translated">ルーティングに関する要件が少ない</target>
        </trans-unit>
        <trans-unit id="6c0e1cc40fccace9c870f52b415d915d429a858c" translate="yes" xml:space="preserve">
          <source>Finally, let's tie it all together in &lt;code&gt;./js/components/App.js&lt;/code&gt;:</source>
          <target state="translated">最後に、すべてを &lt;code&gt;./js/components/App.js&lt;/code&gt; にまとめます。</target>
        </trans-unit>
        <trans-unit id="794475575e8e8e88251415839f49042175570f60" translate="yes" xml:space="preserve">
          <source>Finally, we construct our schema (whose starting query type is the query type we defined above) and export it.</source>
          <target state="translated">最後に、スキーマを構築し(その開始クエリ型は上で定義したクエリ型です)、エクスポートします。</target>
        </trans-unit>
        <trans-unit id="f5d8e52e096ba49348c23c94d52fb5128a53fc82" translate="yes" xml:space="preserve">
          <source>Finds or creates a single record associated with a mutable record. This is a shortcut to &lt;code&gt;RelayRecordProxy.getLinkedRecord&lt;/code&gt; with &lt;code&gt;RelayRecordProxy.setLinkedRecord&lt;/code&gt; should the associated record be non-existant.</source>
          <target state="translated">変更可能なレコードに関連付けられた単一のレコードを検索または作成します。これは、関連するレコードが存在しない場合に、 &lt;code&gt;RelayRecordProxy.getLinkedRecord&lt;/code&gt; 持つ &lt;code&gt;RelayRecordProxy.setLinkedRecord&lt;/code&gt; へのショートカットです。</target>
        </trans-unit>
        <trans-unit id="d4726e1215a3598f0b285dcd1fdabf31356a5b5b" translate="yes" xml:space="preserve">
          <source>First, install the plugin (typically as a &lt;code&gt;devDependency&lt;/code&gt;):</source>
          <target state="translated">まず、プラグインをインストールします（通常は &lt;code&gt;devDependency&lt;/code&gt; として）。</target>
        </trans-unit>
        <trans-unit id="9ee7304a030b3188f69053199e1aa24d2c7e6c40" translate="yes" xml:space="preserve">
          <source>First, let's take a look at the &lt;code&gt;environment&lt;/code&gt; input. To perform the mutation on the correct &lt;code&gt;environment&lt;/code&gt; with the relevant data, it's a good idea to use the &lt;code&gt;environment&lt;/code&gt; used to render the components. It's accessible at &lt;code&gt;this.props.relay.environment&lt;/code&gt; from the component.</source>
          <target state="translated">まず、 &lt;code&gt;environment&lt;/code&gt; 入力を見てみましょう。関連するデータを使用して正しい &lt;code&gt;environment&lt;/code&gt; で変更を実行するには、コンポーネントのレンダリングに使用される &lt;code&gt;environment&lt;/code&gt; 使用することをお勧めします。 &lt;code&gt;this.props.relay.environment&lt;/code&gt; からコンポーネントにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="a3aab624101e00feee75c13777205ffcca8d11b0" translate="yes" xml:space="preserve">
          <source>First, you need &lt;a href=&quot;https://facebook.github.io/watchman&quot;&gt;watchman&lt;/a&gt; installed:</source>
          <target state="translated">まず、&lt;a href=&quot;https://facebook.github.io/watchman&quot;&gt;watchmanを&lt;/a&gt;インストールする必要があります。</target>
        </trans-unit>
        <trans-unit id="0a54de1cc9f2aff2bed1cf76593938b1ded20fcf" translate="yes" xml:space="preserve">
          <source>Flat Routes</source>
          <target state="translated">フラットルート</target>
        </trans-unit>
        <trans-unit id="995180ea866af99054ca25768d4bd2ff5d5c8968" translate="yes" xml:space="preserve">
          <source>Flow Type Generation</source>
          <target state="translated">フロータイプ生成</target>
        </trans-unit>
        <trans-unit id="c46edacfc204a583603ecb9b72b53c55f60dbc6a" translate="yes" xml:space="preserve">
          <source>For a complete example of how to load a &lt;code&gt;schema.js&lt;/code&gt; file, run the introspection query to get schema information, and save it to a JSON file, check out the &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit/blob/master/scripts/updateSchema.js&quot;&gt;starter kit&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;schema.js&lt;/code&gt; ファイルを読み込む方法の完全な例については、イントロスペクションクエリを実行してスキーマ情報を取得し、それをJSONファイルに保存して、&lt;a href=&quot;https://github.com/relayjs/relay-starter-kit/blob/master/scripts/updateSchema.js&quot;&gt;スターターキットを&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="cfe4ba012b2b664f6e8a52e5430ca8b838d37291" translate="yes" xml:space="preserve">
          <source>For a simple application that's already a nice improvement.</source>
          <target state="translated">シンプルなアプリにしては、すでにいい感じに改善されています。</target>
        </trans-unit>
        <trans-unit id="96c534ed5280cce92d6b2b0550da3496f193200e" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;rangeBehaviors&lt;/code&gt; could be written this way:</source>
          <target state="translated">たとえば、 &lt;code&gt;rangeBehaviors&lt;/code&gt; は次のように記述できます。</target>
        </trans-unit>
        <trans-unit id="4999f2258aff41aa7c828698a3d72fe291b86eb2" translate="yes" xml:space="preserve">
          <source>For example, a network layer can be a simple object that conforms to the interface:</source>
          <target state="translated">例えば、ネットワーク層は、インターフェースに準拠した単純なオブジェクトであってもよい。</target>
        </trans-unit>
        <trans-unit id="8ffcdf17f2ad817cd3da93a900284bc63c193056" translate="yes" xml:space="preserve">
          <source>For example, given the two files:</source>
          <target state="translated">例えば、2つのファイルがあるとします。</target>
        </trans-unit>
        <trans-unit id="12bad1fdad02e0f5d5569bcccc232e7c8357d9c5" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;currentDate&lt;/code&gt; is set in &lt;code&gt;QueryRenderer&lt;/code&gt;&lt;code&gt;variables&lt;/code&gt;, then $currentDate may be referenced in any fragment included in the &lt;code&gt;QueryRenderer&lt;/code&gt;&lt;code&gt;query&lt;/code&gt;.</source>
          <target state="translated">たとえば、 &lt;code&gt;currentDate&lt;/code&gt; が &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;code&gt;variables&lt;/code&gt; で設定されている場合、$ currentDateは &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;code&gt;query&lt;/code&gt; 含まれている任意のフラグメントで参照できます。</target>
        </trans-unit>
        <trans-unit id="1178c99ccfd9629da7c347f69a733ccb2674242f" translate="yes" xml:space="preserve">
          <source>For examples of more complex optimistic updates, including adding and removing from a list, see the &lt;a href=&quot;https://github.com/relayjs/relay-examples/tree/master/todo&quot;&gt;Relay Modern Todo example app&lt;/a&gt;.</source>
          <target state="translated">リストへの追加やリストからの削除など、より複雑な楽観的な更新の例については、&lt;a href=&quot;https://github.com/relayjs/relay-examples/tree/master/todo&quot;&gt;Relay Modern Todoサンプルアプリを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="a82abfdd90416cbeaffe64d3e50d78377188efce" translate="yes" xml:space="preserve">
          <source>For more complex use-cases, you may wish to perform custom logic to update Relay's in-memory cache when each subscription response is received. To do so, pass an &lt;code&gt;updater&lt;/code&gt; function:</source>
          <target state="translated">より複雑なユースケースでは、カスタムロジックを実行して、各サブスクリプション応答を受信したときにRelayのメモリ内キャッシュを更新することができます。これを行うには、 &lt;code&gt;updater&lt;/code&gt; 関数を渡します。</target>
        </trans-unit>
        <trans-unit id="2ac9b5543bc0f49df0cfb3a851760d47fc555d44" translate="yes" xml:space="preserve">
          <source>For more complicated mutations, &lt;code&gt;optimisticUpdater&lt;/code&gt; and &lt;code&gt;updater&lt;/code&gt; can be the same function.</source>
          <target state="translated">より複雑なミュー &lt;code&gt;updater&lt;/code&gt; 場合、 &lt;code&gt;optimisticUpdater&lt;/code&gt; とupdaterを同じ関数にすることができます。</target>
        </trans-unit>
        <trans-unit id="1137480158b92303f1522341248742d418f8a480" translate="yes" xml:space="preserve">
          <source>For more details on creating a Network, see the &lt;a href=&quot;network-layer&quot;&gt;NetworkLayer guide&lt;/a&gt;.</source>
          <target state="translated">ネットワーク作成の詳細については、&lt;a href=&quot;network-layer&quot;&gt;NetworkLayerガイドを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="cf88bc6b3b6a4c187092ec351a5b1077c1d26272" translate="yes" xml:space="preserve">
          <source>For new Relay apps or existing apps that have been fully converted to the Compat API, the Relay Modern runtime can be enabled to activate even more features. In addition to those described above, this includes:</source>
          <target state="translated">新規のRelayアプリやCompat APIに完全に変換された既存のアプリでは、Relay Modernランタイムを有効にすることで、さらに多くの機能を有効にすることができます。これには、上記で説明したものに加えて、以下のようなものが含まれます。</target>
        </trans-unit>
        <trans-unit id="18fbf073a81951774f334f655935c2dac6e6377a" translate="yes" xml:space="preserve">
          <source>Force Fetching</source>
          <target state="translated">強制取得</target>
        </trans-unit>
        <trans-unit id="96bbe9b850cec5fbab27d61fde4b1fa63d06e24d" translate="yes" xml:space="preserve">
          <source>Force Fetching with Data from the Client</source>
          <target state="translated">クライアントからのデータを使って強制的にフェッチする</target>
        </trans-unit>
        <trans-unit id="bbba84135de6b052c2210e74e0cc5b2a9d359ddb" translate="yes" xml:space="preserve">
          <source>Found</source>
          <target state="translated">Found</target>
        </trans-unit>
        <trans-unit id="365b08de44008517ff803d0c36a644ac290dba44" translate="yes" xml:space="preserve">
          <source>Found offers integration with Relay Modern and Relay Classic via &lt;a href=&quot;https://github.com/4Catalyzer/found-relay&quot;&gt;Found Relay&lt;/a&gt;. Found Relay runs queries for matched routes in parallel, and supports fetching Relay data in parallel with downloading async bundles from code splitting when using Relay Modern.</source>
          <target state="translated">Foundは、&lt;a href=&quot;https://github.com/4Catalyzer/found-relay&quot;&gt;Found Relay&lt;/a&gt;を介してRelay ModernおよびRelay Classicとの統合を提供します。Found Relayは、一致するルートのクエリを並列で実行し、Relay Modernを使用する場合、コード分割から非同期バンドルをダウンロードすることと並行して、Relayデータをフェッチすることをサポートします。</target>
        </trans-unit>
        <trans-unit id="e58abca7c5abd6b02071e05687c03305e61f7adb" translate="yes" xml:space="preserve">
          <source>Fragment Composition</source>
          <target state="translated">フラグメントの構成</target>
        </trans-unit>
        <trans-unit id="4c9b8ee7dc2184d0aab89be194eb15b57be40cef" translate="yes" xml:space="preserve">
          <source>Fragment composition is achieved via ES6 template string interpolation and &lt;code&gt;getFragment&lt;/code&gt;:</source>
          <target state="translated">フラグメントの構成は、ES6テンプレートの文字列補間と &lt;code&gt;getFragment&lt;/code&gt; によって実現されます。</target>
        </trans-unit>
        <trans-unit id="99eb0c4810611d5c803d75a7ca10220fd2d2cfea" translate="yes" xml:space="preserve">
          <source>Fragment composition works similarly &amp;mdash; a parent container's fragment composes the fragment for each of its children. In this case, &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; needs to fetch information about the &lt;code&gt;User&lt;/code&gt; that is required by &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">フラグメント構成は同様に機能します&amp;mdash;親コンテナのフラグメントは、それぞれの子のフラグメントを構成します。この場合、 &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; は、 &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; で必要な &lt;code&gt;User&lt;/code&gt; に関する情報をフェッチする必要があります。</target>
        </trans-unit>
        <trans-unit id="f4c1ec38ec0f0411751ca1a7fa59d2e3f75e878a" translate="yes" xml:space="preserve">
          <source>Fragment composition works similarly &amp;mdash; a parent container's fragment composes the fragment for each of its children. In this case, &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; needs to fetch information about the &lt;code&gt;Todo&lt;/code&gt;s that are required by &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">フラグメント構成は同様に機能します&amp;mdash;親コンテナのフラグメントは、それぞれの子のフラグメントを構成します。この場合、 &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; についての情報を取得する必要がある &lt;code&gt;Todo&lt;/code&gt; によって必要とされるS &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a7eb65ef2204b222cba330bf9518e103ffff4a9" translate="yes" xml:space="preserve">
          <source>Fragment variables</source>
          <target state="translated">フラグメント変数</target>
        </trans-unit>
        <trans-unit id="6c4797fcf380c1ad929a06c044c27ce633b8a89b" translate="yes" xml:space="preserve">
          <source>FragmentContainer</source>
          <target state="translated">FragmentContainer</target>
        </trans-unit>
        <trans-unit id="e8e4adae3ec551af9e8edf80d04fd880f87f33b9" translate="yes" xml:space="preserve">
          <source>Fragments can be composed in one of two ways:</source>
          <target state="translated">フラグメントは2つの方法のいずれかで構成することができます。</target>
        </trans-unit>
        <trans-unit id="1ec5c60b97bf9a572f6951db4d37f812151af82e" translate="yes" xml:space="preserve">
          <source>Fragments can be embedded within other fragments or queries. For example, the above fragment could be used to fetch user &lt;code&gt;123&lt;/code&gt;'s profile photo:</source>
          <target state="translated">フラグメントは、他のフラグメントまたはクエリ内に埋め込むことができます。たとえば、上記のフラグメントは、ユーザー &lt;code&gt;123&lt;/code&gt; のプロフィール写真を取得するために使用できます。</target>
        </trans-unit>
        <trans-unit id="5749ddc88402f36f29ad8ff8b7fc5a5626b02527" translate="yes" xml:space="preserve">
          <source>Fragments may also compose other fragments that are assigned to local variables:</source>
          <target state="translated">フラグメントは、ローカル変数に代入された他のフラグメントを構成してもよい。</target>
        </trans-unit>
        <trans-unit id="5b32b8542e4c8854b05455c0b114c2bdced713ad" translate="yes" xml:space="preserve">
          <source>Garbage Collection</source>
          <target state="translated">ゴミの収集</target>
        </trans-unit>
        <trans-unit id="13e8bde6a75cc8bafc18233096a72b0f6248985e" translate="yes" xml:space="preserve">
          <source>General-purpose tools for building a GraphQL schema using JavaScript</source>
          <target state="translated">JavaScriptを使ったGraphQLスキーマ構築のための汎用ツール</target>
        </trans-unit>
        <trans-unit id="2b67d1eb9affe329c622f0576365f0ee268cf097" translate="yes" xml:space="preserve">
          <source>Gets a fragment reference for use in a parent's query fragment.</source>
          <target state="translated">親のクエリフラグメントで使用するためのフラグメント参照を取得します。</target>
        </trans-unit>
        <trans-unit id="efadaa65e42a5128618d6d70d6e5f16a32ea9213" translate="yes" xml:space="preserve">
          <source>Gets a reference to a child container's fragment for inclusion in a parent fragment.</source>
          <target state="translated">親フラグメントに含めるための子コンテナのフラグメントへの参照を取得します。</target>
        </trans-unit>
        <trans-unit id="bab08a8b8e5697e21edf5ba8471a6d2976e052d5" translate="yes" xml:space="preserve">
          <source>Gets a string name used to refer to this request for printing debug output.</source>
          <target state="translated">デバッグ出力を印刷するためのこのリクエストを参照するための文字列名を取得します。</target>
        </trans-unit>
        <trans-unit id="c66f9fff87afddb71ece32a2129c20b745b3303d" translate="yes" xml:space="preserve">
          <source>Gets a string representation of the GraphQL mutation.</source>
          <target state="translated">GraphQL の突然変異の文字列表現を取得します。</target>
        </trans-unit>
        <trans-unit id="f2fb6164e4d92fdf7bb9de20c1488df58f14ec49" translate="yes" xml:space="preserve">
          <source>Gets a string representation of the GraphQL query.</source>
          <target state="translated">GraphQL クエリの文字列表現を取得します。</target>
        </trans-unit>
        <trans-unit id="abe1bcf50d4649b6cc620e50d25b565688c7d9a1" translate="yes" xml:space="preserve">
          <source>Gets a unique identifier for this mutation. These identifiers are useful for assigning response payloads to their corresponding mutations when sent in a single GraphQL request.</source>
          <target state="translated">このミューテーションの一意の識別子を取得します。これらの識別子は、単一の GraphQL リクエストで送信されたときに、対応する変異に応答ペイロードを割り当てるのに便利です。</target>
        </trans-unit>
        <trans-unit id="96e072f6fa8b2d20b9da83302dbda948494674bf" translate="yes" xml:space="preserve">
          <source>Gets a unique identifier for this query. These identifiers are useful for assigning response payloads to their corresponding queries when sent in a single GraphQL request.</source>
          <target state="translated">このクエリの一意の識別子を取得します。これらの識別子は、単一の GraphQL リクエストで送信された場合に、対応するクエリにレスポンスペイロードを割り当てるのに便利です。</target>
        </trans-unit>
        <trans-unit id="5406c8eaf62c01411092558cd572b43c5b89bfa6" translate="yes" xml:space="preserve">
          <source>Gets an optional map from name to File objects.</source>
          <target state="translated">name から File オブジェクトへのオプションのマップを取得します。</target>
        </trans-unit>
        <trans-unit id="118b9b0bfba623072bfed30c4a7c6d4b769ead2a" translate="yes" xml:space="preserve">
          <source>Gets the variables used by the mutation. These variables should be serialized and send in the GraphQL request.</source>
          <target state="translated">突然変異で使用される変数を取得します。これらの変数はシリアライズされ、GraphQLリクエストで送信されなければなりません。</target>
        </trans-unit>
        <trans-unit id="5f68839c1e374f581aaccfdd2584db85f5d5531a" translate="yes" xml:space="preserve">
          <source>Gets the variables used by the query. These variables should be serialized and sent in the GraphQL request.</source>
          <target state="translated">クエリで使用される変数を取得します。これらの変数はシリアライズされ、GraphQLリクエストで送信されなければなりません。</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">はじめに</target>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="translated">始めるには</target>
        </trans-unit>
        <trans-unit id="8b19260759d77673b9a877795f157d4044253944" translate="yes" xml:space="preserve">
          <source>Given a connection, one or more DataIDs in the response payload, and a path between the parent and the connection, Relay will remove the node(s) from the connection but leave the associated record(s) in the store.</source>
          <target state="translated">接続、レスポンス・ペイロードに含まれる1つ以上のDataID、および親と接続の間のパスが与えられると、Relayは接続からノードを削除しますが、関連するレコードはストアに残します。</target>
        </trans-unit>
        <trans-unit id="e48271c6488ce169319e6996a17416ab8db56489" translate="yes" xml:space="preserve">
          <source>Given a deletedIDFieldName, Relay will remove the node(s) from the connection.</source>
          <target state="translated">deletedIDFieldNameを指定すると、Relayは接続からノードを削除します。</target>
        </trans-unit>
        <trans-unit id="47de81551f168ce6aed9196d0adf126b977177b6" translate="yes" xml:space="preserve">
          <source>Given a parent, a connection, and one or more DataIDs in the response payload, Relay will remove the node(s) from the connection and delete the associated record(s) from the store.</source>
          <target state="translated">親、接続、およびレスポンス・ペイロードに含まれる1つ以上のDataIDを指定すると、Relayは接続からノードを削除し、ストアから関連するレコードを削除します。</target>
        </trans-unit>
        <trans-unit id="a51dc0bfb8bd3ee42a7194ed76f6218686158817" translate="yes" xml:space="preserve">
          <source>Given a parent, a connection, and the name of the newly created edge in the response payload Relay will add the node to the store and attach it to the connection according to the range behavior specified.</source>
          <target state="translated">親、接続、およびレスポンス・ペイロードに新しく作成されたエッジの名前が指定されると、Relayは指定された範囲の動作に従ってノードをストアに追加し、接続にアタッチします。</target>
        </trans-unit>
        <trans-unit id="524a22d3cb952e409df0e138141726ed755fe115" translate="yes" xml:space="preserve">
          <source>Given a parent, connectionKeys, one or more DataIDs in the response payload, and a path between the parent and the connection, Relay will remove the node(s) from the connection but leave the associated record(s) in the store.</source>
          <target state="translated">親、connectionKeys、レスポンス・ペイロードに含まれる1つ以上のDataID、および親と接続の間のパスが与えられると、Relayは接続からノードを削除しますが、関連するレコードはストアに残します。</target>
        </trans-unit>
        <trans-unit id="6c8602a6c8072fdb24f4522613cbc2f7cfcca2ed" translate="yes" xml:space="preserve">
          <source>Given a parent, information about the connection, and the name of the newly created edge in the response payload Relay will add the node to the store and attach it to the connection according to the range behavior(s) specified in the connectionInfo.</source>
          <target state="translated">親、接続に関する情報、およびレスポンス・ペイロードで新しく作成されたエッジの名前が与えられると、Relayはノードをストアに追加し、connectionInfoで指定された範囲の動作に従って接続にアタッチします。</target>
        </trans-unit>
        <trans-unit id="1d0fa81ee1013085b7d63ff166408f30527ff41a" translate="yes" xml:space="preserve">
          <source>Given the plain React component and a GraphQL fragment, we can now define a &lt;code&gt;Container&lt;/code&gt; to tell Relay about this component's data requirements. Let's look at the code first and then see what's happening:</source>
          <target state="translated">プレーンなReactコンポーネントとGraphQLフラグメントが与えられたら、このコンポーネントのデータ要件をリレーに伝える &lt;code&gt;Container&lt;/code&gt; を定義できます。まずコードを見てから、何が起こっているのかを見てみましょう：</target>
        </trans-unit>
        <trans-unit id="3e96a8e96d952292ce981325cfa1fcff52e52c7e" translate="yes" xml:space="preserve">
          <source>Given these real-world constraints, the approach in GraphQL is for clients to query for things that may change after a mutation. But what exactly do we put in that query? During the development of Relay we explored several ideas &amp;mdash; let's look at them briefly in order to understand why Relay uses the approach that it does:</source>
          <target state="translated">これらの実際の制約を前提として、GraphQLのアプローチは、クライアントが変更後に変更される可能性があるものをクエリすることです。しかし、そのクエリには正確に何を入れますか？Relayの開発中に、いくつかのアイデアを検討しました。Relayが行うアプローチを使用する理由を理解するために、それらを簡単に見てみましょう。</target>
        </trans-unit>
        <trans-unit id="e4eb1ab683c392399fa825b2dea3b7e5f8189912" translate="yes" xml:space="preserve">
          <source>GraphQL</source>
          <target state="translated">GraphQL</target>
        </trans-unit>
        <trans-unit id="d1104d2d1c77df98433b7b7cb498cfbba782bab4" translate="yes" xml:space="preserve">
          <source>GraphQL Relay Specification</source>
          <target state="translated">グラフQLリレー仕様</target>
        </trans-unit>
        <trans-unit id="2462160d86cfb1c5d092d0aa517b3b680333ccb3" translate="yes" xml:space="preserve">
          <source>GraphQL Schema</source>
          <target state="translated">グラフQLスキーム</target>
        </trans-unit>
        <trans-unit id="37f3b6a18cf42e1932e52d60a342d388f522602a" translate="yes" xml:space="preserve">
          <source>GraphQL Subscriptions &amp;amp; Live Queries</source>
          <target state="translated">GraphQLサブスクリプションとライブクエリ</target>
        </trans-unit>
        <trans-unit id="6884fbda0403c3eb6a361b276df83698590e1779" translate="yes" xml:space="preserve">
          <source>GraphQL is designed to support a wide range of data access patterns. In order to understand the structure of an application's data, Relay requires that you follow certain conventions when defining your schema. These are documented in the &lt;a href=&quot;graphql-relay-specification&quot;&gt;GraphQL Relay Specification&lt;/a&gt;.</source>
          <target state="translated">GraphQLは、幅広いデータアクセスパターンをサポートするように設計されています。アプリケーションのデータの構造を理解するために、Relayでは、スキーマを定義するときに特定の規則に従う必要があります。これらは&lt;a href=&quot;graphql-relay-specification&quot;&gt;GraphQLリレー仕様に&lt;/a&gt;記載されています。</target>
        </trans-unit>
        <trans-unit id="55711b09c6616aea30b39a64a358b0d9490999c3" translate="yes" xml:space="preserve">
          <source>GraphQL presents new ways for clients to fetch data by focusing on the needs of product developers and client applications. It provides a way for developers to specify the precise data needed for a view and enables a client to fetch that data in a single network request. Compared to traditional approaches such as REST, GraphQL helps applications to fetch data more efficiently (compared to resource-oriented REST approaches) and avoid duplication of server logic (which can occur with custom endpoints). Furthermore, GraphQL helps developers to decouple product code and server logic. For example, a product can fetch more or less information without requiring a change to every relevant server endpoint. It's a great way to fetch data.</source>
          <target state="translated">GraphQLは、製品開発者とクライアントアプリケーションのニーズに焦点を当て、クライアントがデータを取得するための新しい方法を提供します。GraphQLは、開発者がビューに必要な正確なデータを指定する方法を提供し、クライアントが単一のネットワークリクエストでそのデータを取得することを可能にします。GraphQLは、RESTのような従来のアプローチと比較して、アプリケーションがより効率的にデータを取得し(リソース指向のRESTアプローチと比較して)、サーバーロジックの重複(カスタムエンドポイントで発生する可能性がある)を回避するのに役立ちます。さらに、開発者は GraphQL を使用することで、製品コードとサーバーロジックを分離することができます。たとえば、製品は、関連するサーバーのエンドポイントをすべて変更することなく、より多くの情報を取得したり、より少ない情報を取得したりすることができます。これは、データを取得するための素晴らしい方法です。</target>
        </trans-unit>
        <trans-unit id="cd5d1ec7247a2826222f29ae64e2e192abb30c33" translate="yes" xml:space="preserve">
          <source>GraphQL provides a powerful tool for building efficient, decoupled client applications. Relay builds on this functionality to provide a framework for &lt;strong&gt;declarative data-fetching&lt;/strong&gt;. By separating &lt;em&gt;what&lt;/em&gt; data to fetch from &lt;em&gt;how&lt;/em&gt; it is fetched, Relay helps developers build applications that are robust, transparent, and performant by default. It's a great complement to the component-centric way of thinking championed by React. While each of these technologies &amp;mdash; React, Relay, and GraphQL &amp;mdash; are powerful on their own, the combination is a &lt;strong&gt;UI platform&lt;/strong&gt; that allows us to &lt;em&gt;move fast&lt;/em&gt; and &lt;em&gt;ship high-quality apps at scale&lt;/em&gt;.</source>
          <target state="translated">GraphQLは、効率的で分離されたクライアントアプリケーションを構築するための強力なツールを提供します。 Relayはこの機能に基づいて構築されており、&lt;strong&gt;宣言的なデータフェッチの&lt;/strong&gt;フレームワークを提供します。取得&lt;em&gt;する&lt;/em&gt;データと取得&lt;em&gt;方法&lt;/em&gt;を分離&lt;em&gt;する&lt;/em&gt;ことで、Relayは開発者がデフォルトで堅牢で透過的でパフォーマンスの高いアプリケーションを構築できるようにします。これは、Reactが推進するコンポーネント中心の考え方を補完するものです。これらの各テクノロジー（React、Relay、GraphQL）はそれ自体が強力ですが、この組み合わせは&lt;strong&gt;UIプラットフォーム&lt;/strong&gt;であり、&lt;em&gt;高速&lt;/em&gt;で&lt;em&gt;移動して&lt;/em&gt;&lt;em&gt;高品質のアプリを大規模に出荷&lt;/em&gt;できます。</target>
        </trans-unit>
        <trans-unit id="1745637b6e7ac2208886e0fe73413f315dc1d52e" translate="yes" xml:space="preserve">
          <source>Here's a basic implementation of &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; that ignores styling in order to highlight the functionality:</source>
          <target state="translated">次に、機能を強調するためにスタイリングを無視する &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; の基本的な実装を示します。</target>
        </trans-unit>
        <trans-unit id="c7acba2d971e69e956adf8a6ecc2371b0bf96df3" translate="yes" xml:space="preserve">
          <source>Here's a basic implementation of &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; that ignores styling in order to highlight the functionality:</source>
          <target state="translated">以下は、機能を強調するためにスタイル設定を無視する &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; の基本的な実装です。</target>
        </trans-unit>
        <trans-unit id="dbbbbf44b31cd11738f96ef61375f12e9722988b" translate="yes" xml:space="preserve">
          <source>Here's an example of this mutation in use by a &lt;code&gt;LikeButton&lt;/code&gt; component:</source>
          <target state="translated">&lt;code&gt;LikeButton&lt;/code&gt; コンポーネントで使用されているこのミューテーションの例を次に示します。</target>
        </trans-unit>
        <trans-unit id="385d7c0cfbb336e0125f7ea51dde1cd3078887da" translate="yes" xml:space="preserve">
          <source>Here's an example query that fetches a story's text and its author's name:</source>
          <target state="translated">以下は、ストーリーのテキストと著者名を取得するクエリの例です。</target>
        </trans-unit>
        <trans-unit id="0694e515f41dabfcc348f2df0677999ef99af1ea" translate="yes" xml:space="preserve">
          <source>Here's what happens when the container is rendered:</source>
          <target state="translated">コンテナがレンダリングされるとどうなるかを説明します。</target>
        </trans-unit>
        <trans-unit id="2284d040f5091f510de37a154536196310f9c02d" translate="yes" xml:space="preserve">
          <source>Hint</source>
          <target state="translated">Hint</target>
        </trans-unit>
        <trans-unit id="05531ed7907681dd3a6ac4e94e82348c1af49264" translate="yes" xml:space="preserve">
          <source>Historically, Relay started out internally at Facebook as a routing framework. However, Relay no longer makes any assumptions about routing, and works with a variety of routing options.</source>
          <target state="translated">歴史的に、RelayはFacebookの社内でルーティングフレームワークとしてスタートしました。しかし、Relayはもはやルーティングを前提としたものではなく、さまざまなルーティングオプションを使って動作します。</target>
        </trans-unit>
        <trans-unit id="f96c9aa85d59b7983b33495b149e7fee5f7bf418" translate="yes" xml:space="preserve">
          <source>Hm. There were no more ships; guess there were only five in the system for the rebels. It would have been nice to know that we'd reached the end of the connection, without having to do another round trip in order to verify that. The connection model exposes this capability with a type called &lt;code&gt;PageInfo&lt;/code&gt;. So let's issue the two queries that got us ships again, but this time ask for &lt;code&gt;hasNextPage&lt;/code&gt;:</source>
          <target state="translated">うーん。船はもうありませんでした。反乱軍のシステムには5人しかいなかったと思います。それを確認するために別のラウンドトリップを実行する必要なしに、接続の最後に到達したことを知っていれば、良かったでしょう。接続モデルは、この機能を &lt;code&gt;PageInfo&lt;/code&gt; というタイプで公開します。それでは、再度出荷した2つのクエリを発行してみましょう。ただし、今回は &lt;code&gt;hasNextPage&lt;/code&gt; を要求します。</target>
        </trans-unit>
        <trans-unit id="c2d977e2354e1f199b20eba8fe4202828b60baf5" translate="yes" xml:space="preserve">
          <source>However components using the Relay Modern API (&lt;code&gt;'react-relay'&lt;/code&gt;) and the Relay Classic API (&lt;code&gt;'react-relay/classic'&lt;/code&gt;) cannot be used with each other.</source>
          <target state="translated">ただし、Relay Modern API（ &lt;code&gt;'react-relay'&lt;/code&gt; ）とRelay Classic API（ &lt;code&gt;'react-relay/classic'&lt;/code&gt; ）を使用するコンポーネントは、相互に使用できません。</target>
        </trans-unit>
        <trans-unit id="8f6bd5564a2d8d3eed39f5285b27795de9e86379" translate="yes" xml:space="preserve">
          <source>However the Relay Compiler also automatically generates flow types, as &lt;a href=&quot;https://flow.org/en/docs/types/comments/&quot;&gt;type comments&lt;/a&gt;. To import the types:</source>
          <target state="translated">ただし、Relay Compilerは、&lt;a href=&quot;https://flow.org/en/docs/types/comments/&quot;&gt;タイプコメント&lt;/a&gt;としてフロータイプも自動的に生成します。タイプをインポートするには：</target>
        </trans-unit>
        <trans-unit id="10b177310affbe7aa4dd35d3f040c504f1597c28" translate="yes" xml:space="preserve">
          <source>However, Relay Modern expects modern JavaScript global types (&lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Promise&lt;/code&gt;, &lt;code&gt;Object.assign&lt;/code&gt;) to be defined. If you support older browsers and devices which may not yet provide these natively, consider including a global polyfill in your bundled application, such as &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/docs/usage/polyfill/&quot;&gt;babel-polyfill&lt;/a&gt;.</source>
          <target state="translated">ただし、Relay Modernは、最新のJavaScriptグローバルタイプ（ &lt;code&gt;Map&lt;/code&gt; 、 &lt;code&gt;Set&lt;/code&gt; 、 &lt;code&gt;Promise&lt;/code&gt; 、 &lt;code&gt;Object.assign&lt;/code&gt; ）が定義されることを期待しています。これらをネイティブで提供していない可能性のある古いブラウザーやデバイスをサポートしている場合は、&lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt;や&lt;a href=&quot;https://babeljs.io/docs/usage/polyfill/&quot;&gt;babel-polyfill&lt;/a&gt;などのバンドルアプリケーションにグローバルポリフィルを含めることを検討してください。</target>
        </trans-unit>
        <trans-unit id="44a07f8e11c88d99ebfa0ba8926d9d2bf8daec90" translate="yes" xml:space="preserve">
          <source>However, the fragment could also fetch each of user &lt;code&gt;123&lt;/code&gt;'s friends' profile photos:</source>
          <target state="translated">ただし、このフラグメントは、ユーザー &lt;code&gt;123&lt;/code&gt; の友達のプロフィール写真をそれぞれフェッチすることもできます。</target>
        </trans-unit>
        <trans-unit id="bd69a4732fe12702d5ff5838852eb29e4a9e2e02" translate="yes" xml:space="preserve">
          <source>Idea</source>
          <target state="translated">Idea</target>
        </trans-unit>
        <trans-unit id="3bd280c6059870c93a4668954d90f25f6c6ff4e2" translate="yes" xml:space="preserve">
          <source>If a &quot;force fetch&quot; occurs and there is insufficient data on the client, the same behavior as &lt;strong&gt;Fetching Data from the Server&lt;/strong&gt; can be expected. However, if a &quot;force fetch&quot; occurs and there &lt;em&gt;is&lt;/em&gt; sufficient data on the client to render, we can expect the following behavior:</source>
          <target state="translated">「強制フェッチ」が発生し、クライアントに十分なデータがない場合&lt;strong&gt;、サーバーからのデータのフェッチ&lt;/strong&gt;と同じ動作が期待できます。「力フェッチ」が発生し、そこただし、&lt;em&gt;ある&lt;/em&gt;クライアント上の十分なデータがレンダリングするために、我々は次のような動作を期待することができます。</target>
        </trans-unit>
        <trans-unit id="7ed138709fbda62e44a180d5f323c654e6cc766a" translate="yes" xml:space="preserve">
          <source>If a fragment uses variables that are determined at runtime, &lt;a href=&quot;#note-determining-variable-values-at-runtime&quot;&gt;see below&lt;/a&gt;.</source>
          <target state="translated">フラグメントが実行時に決定される変数を使用する場合は、&lt;a href=&quot;#note-determining-variable-values-at-runtime&quot;&gt;以下を参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c5dc5ba510b8cc7e8340243c616a8461f6de45a" translate="yes" xml:space="preserve">
          <source>If a server request results in a failure to load data, we can expect the following behavior:</source>
          <target state="translated">サーバリクエストの結果、データの読み込みに失敗した場合、以下のような動作が予想されます。</target>
        </trans-unit>
        <trans-unit id="500f13b73830f97ef3d0785c40a8e9be8e6865fb" translate="yes" xml:space="preserve">
          <source>If an error occurs that prevents &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; from fetching the data required for rendering &lt;code&gt;Component&lt;/code&gt;, nothing will be rendered by default. Error handling behavior can be configured by supplying a callback to the &lt;code&gt;renderFailure&lt;/code&gt; prop:</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;が &lt;code&gt;Component&lt;/code&gt; のレンダリングに必要なデータを取得できないエラーが発生した場合、デフォルトでは何もレンダリングされません。エラー処理の動作は、 &lt;code&gt;renderFailure&lt;/code&gt; プロップにコールバックを提供することで構成できます。</target>
        </trans-unit>
        <trans-unit id="e4eb5b8214d4c82b80af57f3c1c0471dea0d3c7b" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;Component&lt;/code&gt; or &lt;code&gt;route&lt;/code&gt; ever changes, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; will immediately start attempting to fulfill the new data requirements.</source>
          <target state="translated">&lt;code&gt;Component&lt;/code&gt; または &lt;code&gt;route&lt;/code&gt; いずれかが変更されると、&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;はすぐに新しいデータ要件を&lt;strong&gt;満たそ&lt;/strong&gt;うとします。</target>
        </trans-unit>
        <trans-unit id="e7c4473f87af75e4695d24734fbf44e9808a4049" translate="yes" xml:space="preserve">
          <source>If insufficient data on the client leads Relay to send a server request for more data, we can expect the following behavior:</source>
          <target state="translated">クライアントのデータが不足しているために、Relayがさらにデータを要求するサーバ・リクエストを送信した場合、以下のような動作が予想されます。</target>
        </trans-unit>
        <trans-unit id="e7125117da9f12ab4891151c4ede73bbfc431ad0" translate="yes" xml:space="preserve">
          <source>If no request is in flight pendingVariables is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">リクエストが処理中でない場合、pendingVariablesは &lt;code&gt;null&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e94ccf62b4c7fbeeff1884ed8210524c0aaf3f8f" translate="yes" xml:space="preserve">
          <source>If not supplied, a unique collision key is derived (meaning that the created mutation will be independent and not collide with any other).</source>
          <target state="translated">指定しない場合は、一意の衝突キーが導出されます(作成された突然変異は独立しており、他のものと衝突しないことを意味します)。</target>
        </trans-unit>
        <trans-unit id="9f1093c79885887f1a46e11c2dbc9de6bfd2239c" translate="yes" xml:space="preserve">
          <source>If sufficient data is available on the client such that Relay does not need to send a server request, we can expect the following behavior:</source>
          <target state="translated">Relayがサーバ・リクエストを送信する必要がないような十分なデータがクライアントにある場合、以下のような動作が期待できます。</target>
        </trans-unit>
        <trans-unit id="1753e3219d9e6a6f6bf62bc19a7f313caa79226f" translate="yes" xml:space="preserve">
          <source>If supplied and set to true, a request for data will always be made to the server regardless of whether data on the client is available already.</source>
          <target state="translated">これを指定して true に設定すると、クライアント上のデータが既に利用可能かどうかに関わらず、常にサーバへのデータの要求が行われます。</target>
        </trans-unit>
        <trans-unit id="b8cb57719ab0a4774595aab7b466840e3a324de3" translate="yes" xml:space="preserve">
          <source>If supplied and set to true, a request for data will always be made to the server regardless of whether data on the client is available to immediately fulfill the data requirements.</source>
          <target state="translated">これを指定して true に設定すると、クライアント上のデータがすぐにデータ要件を満たすことができるかどうかにかかわらず、常にデータの要求がサーバに行われます。</target>
        </trans-unit>
        <trans-unit id="9652265c2b29a20de6e20099f7748481a1d4b122" translate="yes" xml:space="preserve">
          <source>If the Relay part of an application is some widget or single view as part of a larger application, you don't need any routing. You can just render a &lt;code&gt;QueryRenderer&lt;/code&gt; somewhere on the page to fetch and render the data you need there. This option is simple and should be used when sufficient.</source>
          <target state="translated">アプリケーションのリレー部分が、より大きなアプリケーションの一部としてのウィジェットまたは単一のビューである場合、ルーティングは必要ありません。 &lt;code&gt;QueryRenderer&lt;/code&gt; をページのどこかにレンダリングするだけで、そこに必要なデータをフェッチしてレンダリングできます。このオプションは単純なので、十分な場合に使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="9c687f957f6123e9a6702a53723c6fbcdd75a426" translate="yes" xml:space="preserve">
          <source>If the callback returns &lt;code&gt;undefined&lt;/code&gt;, the previously rendered view (or nothing if there is no previous view) is rendered (e.g. when transitioning from one &lt;code&gt;queryConfig&lt;/code&gt; to another).</source>
          <target state="translated">コールバックが &lt;code&gt;undefined&lt;/code&gt; を返す場合、以前にレンダリングされたビュー（または、以前のビューがない場合は何も）がレンダリングされます（たとえば、ある &lt;code&gt;queryConfig&lt;/code&gt; から別のqueryConfigに移行するとき）。</target>
        </trans-unit>
        <trans-unit id="fa97f983a844f15bf5a18032a6bd22f04fd47eea" translate="yes" xml:space="preserve">
          <source>If the component doesn't actually use &lt;code&gt;setVariables()&lt;/code&gt;, and just uses &lt;code&gt;initialVariables&lt;/code&gt; to share values between JS and GraphQL, there are two alternative approaches:</source>
          <target state="translated">コンポーネントが実際に &lt;code&gt;setVariables()&lt;/code&gt; を使用せず、 &lt;code&gt;initialVariables&lt;/code&gt; を使用してJSとGraphQLの間で値を共有する場合、2つの代替アプローチがあります。</target>
        </trans-unit>
        <trans-unit id="6f707589cc2da01315091844b3b383efdccb634c" translate="yes" xml:space="preserve">
          <source>If the mutation defines an optimistic payload - a set of data to apply locally while waiting for the server response - Relay applies this change and updates any affected React components (note that optimistic updates do not overwrite known server data in the cache).</source>
          <target state="translated">突然変異が楽観的ペイロード(サーバのレスポンスを待つ間にローカルで適用するデータセット)を定義している場合、Relayはこの変更を適用し、影響を受けるReactコンポーネントを更新します(楽観的な更新はキャッシュ内の既知のサーバデータを上書きしないことに注意してください)。</target>
        </trans-unit>
        <trans-unit id="9d815af768aaeea304d01b0f060f4bcc34f6f6e5" translate="yes" xml:space="preserve">
          <source>If the mutation would not 'collide' (overlap) with other pending mutations - as specified by its &lt;code&gt;getCollisionKey&lt;/code&gt; implementation - it is sent to the server. If it would conflict, it is enqueued until conflicting mutations have completed.</source>
          <target state="translated">ミューテーションが他の保留中のミューテーションと「衝突」（オーバーラップ）しない場合（その &lt;code&gt;getCollisionKey&lt;/code&gt; 実装で指定されているとおり）、ミューテーションはサーバーに送信されます。競合する場合は、競合するミューテーションが完了するまでキューに入れられます。</target>
        </trans-unit>
        <trans-unit id="e86698a9dbbdbb49974d25aeca449ae1fbb9e654" translate="yes" xml:space="preserve">
          <source>If the render callback is not supplied, the default behavior is to render the container if data is available, the existing view if one exists, or nothing.</source>
          <target state="translated">レンダーコールバックが指定されていない場合のデフォルトの動作は、データが利用可能な場合はコンテナをレンダリングし、既存のビューが存在する場合は既存のビューをレンダリングします。</target>
        </trans-unit>
        <trans-unit id="1a73cc6d4c2d46fb79932c374ed9da299d065e97" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; suffix, the &lt;code&gt;data&lt;/code&gt; prop name will be used:</source>
          <target state="translated">&lt;code&gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; サフィックスがない場合、 &lt;code&gt;data&lt;/code&gt; プロップ名が使用されます。</target>
        </trans-unit>
        <trans-unit id="62768ad0f3d9c4db4330d79d61d8599e64fd7a9c" translate="yes" xml:space="preserve">
          <source>If we do the same thing with the Empire, we'll find that it returns a different ID, and we can refetch it as well:</source>
          <target state="translated">帝国と同じことをすると違うIDが返ってくるので、それもリフェッチすることができます。</target>
        </trans-unit>
        <trans-unit id="62f00a1501647642fb670b9befaa1fb2d5b19d8f" translate="yes" xml:space="preserve">
          <source>If we provide to a mutation a method that conforms to the signature described above, it will be given the opportunity to modify the fragment builders' variables, based on the previous variables (or the &lt;code&gt;initialVariables&lt;/code&gt; if no previous ones exist), the meta route, and the runtime environment. Whatever variables this method returns will become available to this mutation's fragment builders.</source>
          <target state="translated">上記のシグネチャに準拠するメソッドをミューテーションに提供すると、前の変数（または前の変数が存在しない場合は &lt;code&gt;initialVariables&lt;/code&gt; ）、メタルートに基づいて、フラグメントビルダーの変数を変更する機会が与えられます。そしてランタイム環境。このメソッドが返す変数が何であれ、このミューテーションのフラグメントビルダーが利用できるようになります。</target>
        </trans-unit>
        <trans-unit id="29d042cd073944a1316b1c84fe494fc214ee7caa" translate="yes" xml:space="preserve">
          <source>If we replace &lt;code&gt;2&lt;/code&gt; with a new immutable record, we'll also get a new immutable instance of the cache object. However, records &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; are untouched. Because the data is normalized, we can't tell that &lt;code&gt;story&lt;/code&gt;'s contents have changed just by looking at the &lt;code&gt;story&lt;/code&gt; record alone.</source>
          <target state="translated">&lt;code&gt;2&lt;/code&gt; を新しい不変のレコードに置き換えると、キャッシュオブジェクトの新しい不変のインスタンスも取得されます。ただし、レコード &lt;code&gt;1&lt;/code&gt; と &lt;code&gt;3&lt;/code&gt; は変更されません。データは正規化されているので、我々はその言うことができない &lt;code&gt;story&lt;/code&gt; の内容はちょうどを見て、変更した &lt;code&gt;story&lt;/code&gt; だけではレコードを。</target>
        </trans-unit>
        <trans-unit id="3442e671845ad2d6f63d621dcbdd2a0032b009d1" translate="yes" xml:space="preserve">
          <source>If we wanted to create an instance of this route for arbitrary users, we can subclass the &lt;code&gt;Relay.Route&lt;/code&gt; abstract class. &lt;code&gt;Relay.Route&lt;/code&gt; makes it easy to define a set of queries and required parameters to be re-used multiple times:</source>
          <target state="translated">このルートのインスタンスを任意のユーザー用に作成したい場合は、 &lt;code&gt;Relay.Route&lt;/code&gt; 抽象クラスをサブクラス化できます。 &lt;code&gt;Relay.Route&lt;/code&gt; を使用すると、クエリのセットと複数回再利用する必要なパラメーターを簡単に定義できます。</target>
        </trans-unit>
        <trans-unit id="4b62113e72e08231a01f5d4a07e448ee27964d21" translate="yes" xml:space="preserve">
          <source>If you find you need to do something unique (like generate types that conform to an older version of flow, or to parse non-javascript source files), you can build your own version of the Compiler by swapping in your own &lt;code&gt;FileWriter&lt;/code&gt; and &lt;code&gt;ASTCache&lt;/code&gt;, or by adding on an additional &lt;code&gt;IRTransform&lt;/code&gt;. Note, the internal APIs of the &lt;code&gt;RelayCompiler&lt;/code&gt; are under constant iteration, so rolling your own version may lead to incompatibilities with future releases.</source>
          <target state="translated">独自の処理を行う必要がある場合（古いバージョンのフローに準拠するタイプを生成する、JavaScript以外のソースファイルを解析するなど）、独自の &lt;code&gt;FileWriter&lt;/code&gt; と &lt;code&gt;ASTCache&lt;/code&gt; を入れ替えて、独自のバージョンのコンパイラを構築できます。または、追加の &lt;code&gt;IRTransform&lt;/code&gt; を追加します。 &lt;code&gt;RelayCompiler&lt;/code&gt; の内部APIは常に反復されているため、独自のバージョンをロールすると、将来のリリースとの互換性が失われる可能性があります。</target>
        </trans-unit>
        <trans-unit id="7224441b6f15886cd449f3742b23181788ee9b99" translate="yes" xml:space="preserve">
          <source>If you wish to provide your own &lt;code&gt;handlerProvider&lt;/code&gt;, you can do so:</source>
          <target state="translated">独自の &lt;code&gt;handlerProvider&lt;/code&gt; を提供する場合は、次のようにできます。</target>
        </trans-unit>
        <trans-unit id="49a21b30f5b3a1b121343f35b747fe542d51dbf3" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;createRefetchContainer&lt;/code&gt; then your &lt;code&gt;refetch&lt;/code&gt; method may also update these variables to render with new values.</source>
          <target state="translated">&lt;code&gt;createRefetchContainer&lt;/code&gt; を使用している場合、 &lt;code&gt;refetch&lt;/code&gt; メソッドはこれらの変数を更新して、新しい値でレンダリングすることもできます。</target>
        </trans-unit>
        <trans-unit id="0ccc0940cec44b44c366f2d98c395662eb2f306c" translate="yes" xml:space="preserve">
          <source>If you're using a different GraphQL server implementation, we recommend adapting the above example to load the schema from your GraphQL server (e.g. via an HTTP request) and then save the result as JSON.</source>
          <target state="translated">別の GraphQL サーバーの実装を使用している場合は、上記の例を適用して、お使いの GraphQL サーバーからスキーマをロードし(HTTP リクエストなどで)、その結果を JSON として保存することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="2e76567f0db1f25cdaed090474feff64180bb110" translate="yes" xml:space="preserve">
          <source>Imagine we have a simple application that fetches a list of stories, and some details about each one. Here's how that might look in resource-oriented REST:</source>
          <target state="translated">ストーリーのリストと、それぞれの詳細を取得するシンプルなアプリケーションを想像してみてください。以下は、リソース指向の REST でどのように見えるかを示しています。</target>
        </trans-unit>
        <trans-unit id="448e3d99f5bde0fa9efac34be83b204ae98c345a" translate="yes" xml:space="preserve">
          <source>Implement this method in cases where the mutator configuration needed to handle the optimistic response needs to be different than the one that handles the server response.</source>
          <target state="translated">このメソッドは、楽観的な応答を処理するために必要なミューテータの設定が、サーバの応答を処理するものとは異なる必要がある場合に実装されます。</target>
        </trans-unit>
        <trans-unit id="62181f13d4fff5bed161f01ef77d8db655301bec" translate="yes" xml:space="preserve">
          <source>Implement this method to craft an optimistic response having the same shape as the server response payload. This optimistic response will be used to preemptively update the client cache before the server returns, giving the impression that the mutation completed instantaneously.</source>
          <target state="translated">このメソッドを実装して、サーバの応答ペイロードと同じ形状の楽観的な応答を作成します。この楽観的なレスポンスは、サーバが戻ってくる前にクライアントキャッシュを先取りして更新するために使用され、突然変異が瞬時に完了したかのような印象を与えます。</target>
        </trans-unit>
        <trans-unit id="24bc32f306fba32d2cbf91f2cd1999f36a16435a" translate="yes" xml:space="preserve">
          <source>Implement this method to return a collision key. Relay will send any mutations having the same collision key to the server serially and in-order.</source>
          <target state="translated">衝突キーを返すためにこのメソッドを実装します。Relay は、同じコリジョンキーを持つ突然変異をサーバにシリアルに順番に送信します。</target>
        </trans-unit>
        <trans-unit id="1e3fee95e387e2e4175f4c37de616bb736c7491c" translate="yes" xml:space="preserve">
          <source>Implement this method to return a map of &lt;code&gt;File&lt;/code&gt; objects to upload as part of a mutation.</source>
          <target state="translated">このメソッドを実装して、ミューテーションの一部としてアップロードする &lt;code&gt;File&lt;/code&gt; オブジェクトのマップを返します。</target>
        </trans-unit>
        <trans-unit id="48d0a56a8bcb298a554f5516aac54d6f77d81acd" translate="yes" xml:space="preserve">
          <source>Implement this method to return true when the supplied options are supported by this network layer. This is used to declare which features the network layer supports.</source>
          <target state="translated">このメソッドを実装すると、指定されたオプションがこのネットワーク・レイヤーでサポートされている場合に true を返すようになります。これは、ネットワークレイヤがどの機能をサポートしているかを宣言するために使用されます。</target>
        </trans-unit>
        <trans-unit id="b153e451079dd8470ac1e1681b4c8e4668b52b86" translate="yes" xml:space="preserve">
          <source>Implement this method to send mutations to the server. When the server response is obtained, this method must either call &lt;code&gt;mutationRequest.resolve&lt;/code&gt; with the response data, or &lt;code&gt;mutationRequest.reject&lt;/code&gt; with an &lt;code&gt;Error&lt;/code&gt; object.</source>
          <target state="translated">このメソッドを実装して、サーバーに変更を送信します。サーバーの応答が得られた場合、このメソッドは、いずれかを呼び出す必要があり &lt;code&gt;mutationRequest.resolve&lt;/code&gt; を応答データに、または &lt;code&gt;mutationRequest.reject&lt;/code&gt; で &lt;code&gt;Error&lt;/code&gt; オブジェクト。</target>
        </trans-unit>
        <trans-unit id="1d31efc29644775c604543b99db2b73a14120012" translate="yes" xml:space="preserve">
          <source>Implement this method to send queries to the server. For each query request, when the server response is received, this method must either call &lt;code&gt;resolve&lt;/code&gt; with the response data, or &lt;code&gt;reject&lt;/code&gt; with an &lt;code&gt;Error&lt;/code&gt; object.</source>
          <target state="translated">このメソッドを実装して、クエリをサーバーに送信します。クエリ要求ごとに、サーバーの応答が受信されると、このメソッドは応答データで &lt;code&gt;resolve&lt;/code&gt; を呼び出すか、 &lt;code&gt;Error&lt;/code&gt; オブジェクトで &lt;code&gt;reject&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="1774e52d0e556763970083c582a2823556fad1d9" translate="yes" xml:space="preserve">
          <source>Implement this required method to design a &amp;lsquo;fat query&amp;rsquo; &amp;ndash; one that represents every field in your data model that could change as a result of this mutation.</source>
          <target state="translated">この必要なメソッドを実装して「ファットクエリ」を設計します。これは、この変更の結果として変更される可能性があるデータモデルのすべてのフィールドを表します。</target>
        </trans-unit>
        <trans-unit id="55c82c1ede81ef7c75eb0f5ad805b7c8131bec8a" translate="yes" xml:space="preserve">
          <source>Implement this required method to give Relay instructions on how to use the response payload from each mutation to update the client-side store.</source>
          <target state="translated">各突然変異からの応答ペイロードを使用してクライアント側ストアを更新する方法をRelayに指示するために、この必須メソッドを実装します。</target>
        </trans-unit>
        <trans-unit id="17378e1f66fb4d758998ffc792b8f969174e1a87" translate="yes" xml:space="preserve">
          <source>Implement this required method to prepare variables to be used as input to the mutation.</source>
          <target state="translated">突然変異の入力として使用される変数を準備するために、この必須メソッドを実装します。</target>
        </trans-unit>
        <trans-unit id="e0d5783849893b65928056a3e01f878a4ebb371a" translate="yes" xml:space="preserve">
          <source>Implement this required method to return a GraphQL mutation operation that represents the mutation to be performed.</source>
          <target state="translated">この必須メソッドを実装して、実行する変異を表す GraphQL 変異操作を返すようにします。</target>
        </trans-unit>
        <trans-unit id="d8c789b0ff99a369ebb08eda75d64a2002a8918e" translate="yes" xml:space="preserve">
          <source>Importing generated definitions</source>
          <target state="translated">生成された定義のインポート</target>
        </trans-unit>
        <trans-unit id="a8c0b4ec0c84b678651530ba2d81f9beb98a2561" translate="yes" xml:space="preserve">
          <source>In GraphQL, &lt;strong&gt;queries&lt;/strong&gt; declare fields that exist on the root query type. For example, the following query might fetch the name of the user with an &lt;code&gt;id&lt;/code&gt; of &lt;code&gt;123&lt;/code&gt;:</source>
          <target state="translated">GraphQLでは、&lt;strong&gt;クエリ&lt;/strong&gt;はルートクエリタイプに存在するフィールドを宣言します。たとえば、次のクエリは、 &lt;code&gt;123&lt;/code&gt; の &lt;code&gt;id&lt;/code&gt; を持つユーザーの名前をフェッチします。</target>
        </trans-unit>
        <trans-unit id="42cc08262fb0bb543ca0770499256c848ef63cb2" translate="yes" xml:space="preserve">
          <source>In React Native, we can schedule Relay processing so as to avoid interrupting touch gestures as follows:</source>
          <target state="translated">React Nativeでは、以下のようにタッチジェスチャーが途切れないようにRelay処理をスケジュールすることができます。</target>
        </trans-unit>
        <trans-unit id="a5187bfb626e29a7807af4b6499d8505f13e32b2" translate="yes" xml:space="preserve">
          <source>In React, rendering a view requires two inputs: the &lt;em&gt;component&lt;/em&gt; to render, and a &lt;em&gt;root&lt;/em&gt; DOM (UI) node to render into. Rendering Relay containers is similar: we need a &lt;em&gt;container&lt;/em&gt; to render, and a &lt;em&gt;root&lt;/em&gt; in the graph from which to start our query. We also must ensure that the queries for the container are executed and may want to show a loading indicator while data is being fetched. Similar to &lt;code&gt;ReactDOM.render(component, domNode)&lt;/code&gt;, Relay provides &lt;code&gt;&amp;lt;Relay.Renderer Container={...} queryConfig={...}&amp;gt;&lt;/code&gt; for this purpose. The container is the item to render, and the queryConfig provides queries that specify &lt;em&gt;which&lt;/em&gt; item to fetch. Here's how we might render &lt;code&gt;&amp;lt;StoryContainer&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Reactでは、ビューのレンダリングには、レンダリングする&lt;em&gt;コンポーネント&lt;/em&gt;と、レンダリング先の&lt;em&gt;ルート&lt;/em&gt; DOM（UI）ノードの2つの入力が必要です。リレーコンテナーのレンダリングも同様です。レンダリングする&lt;em&gt;コンテナー&lt;/em&gt;と、クエリを開始するグラフの&lt;em&gt;ルート&lt;/em&gt;が必要です。また、コンテナーのクエリが実行されていることを確認する必要があります。また、データのフェッチ中に読み込みインジケーターを表示したい場合もあります。 &lt;code&gt;ReactDOM.render(component, domNode)&lt;/code&gt; と同様に、Relayはこの目的で &lt;code&gt;&amp;lt;Relay.Renderer Container={...} queryConfig={...}&amp;gt;&lt;/code&gt; を提供します。コンテナはレンダリングするアイテムであり、queryConfigはフェッチ&lt;em&gt;する&lt;/em&gt;アイテムを指定するクエリを提供します。これがレンダリングの方法です &lt;code&gt;&amp;lt;StoryContainer&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4f9d43e8de662b43a98bf53a133be5a295724798" translate="yes" xml:space="preserve">
          <source>In Relay, data dependencies are described using &lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt;. For &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt;, the dependency can be expressed as follows. Note that this exactly matches the shape that the component expected for the &lt;code&gt;user&lt;/code&gt; prop.</source>
          <target state="translated">リレーでは、データの依存関係は&lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt;を使用して記述されます。ため &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; 次のように、依存関係を表現することができます。これは、コンポーネントが &lt;code&gt;user&lt;/code&gt; プロップに期待する形状と正確に一致することに注意してください。</target>
        </trans-unit>
        <trans-unit id="1084307d05023abf80689279ae0f77b70f810919" translate="yes" xml:space="preserve">
          <source>In Relay, data dependencies are described using &lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt;. For &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt;, the dependency can be expressed as follows. Note that this exactly matches the shape that the component expected for the &lt;code&gt;item&lt;/code&gt; prop.</source>
          <target state="translated">リレーでは、データの依存関係は&lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt;を使用して記述されます。ため &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; 次のように、依存関係を表現することができます。これは、コンポーネントが &lt;code&gt;item&lt;/code&gt; 小道具に期待する形状と正確に一致することに注意してください。</target>
        </trans-unit>
        <trans-unit id="8218e7619ef161652f44088010026d35f36055e0" translate="yes" xml:space="preserve">
          <source>In Relay, the root of a query is defined by a &lt;strong&gt;QueryRenderer&lt;/strong&gt; so check out that section for more details.</source>
          <target state="translated">Relayでは、クエリのルートは&lt;strong&gt;QueryRenderer&lt;/strong&gt;によって定義されるため、詳細についてはそのセクションを確認してください。</target>
        </trans-unit>
        <trans-unit id="30d65c55146011871e1262a4566a24588803dc0d" translate="yes" xml:space="preserve">
          <source>In Relay, the root of a query is defined by a &lt;strong&gt;Route&lt;/strong&gt;. Continue to learn about Relay routes.</source>
          <target state="translated">リレーでは、クエリのルートは&lt;strong&gt;Route&lt;/strong&gt;によって定義されます。リレールートについて学習を続けます。</target>
        </trans-unit>
        <trans-unit id="c21389450ed39ca7f4877ce1712aa3326324e6a9" translate="yes" xml:space="preserve">
          <source>In a resource-oriented REST system, we can maintain a &lt;strong&gt;response cache&lt;/strong&gt; based on URIs:</source>
          <target state="translated">リソース指向のRESTシステムでは、URIに基づいて&lt;strong&gt;応答キャッシュ&lt;/strong&gt;を維持できます。</target>
        </trans-unit>
        <trans-unit id="ddc4813b133487bd46b76268444d4db66fd4598c" translate="yes" xml:space="preserve">
          <source>In a simple mutation, you only need &lt;code&gt;mutation&lt;/code&gt; and &lt;code&gt;variables&lt;/code&gt;:</source>
          <target state="translated">単純なミューテーションでは、 &lt;code&gt;mutation&lt;/code&gt; と &lt;code&gt;variables&lt;/code&gt; のみが必要です。</target>
        </trans-unit>
        <trans-unit id="753db9b3fed6b02e90a81f5ecfd3b20ecf1201c5" translate="yes" xml:space="preserve">
          <source>In a simple subscription, you only need &lt;code&gt;subscription&lt;/code&gt; and &lt;code&gt;variables&lt;/code&gt;. This is appropriate when you are only changing the properties of existing records that can be identified by their &lt;code&gt;id&lt;/code&gt;:</source>
          <target state="translated">単純なサブスクリプションでは、 &lt;code&gt;subscription&lt;/code&gt; と &lt;code&gt;variables&lt;/code&gt; のみが必要です。これは、 &lt;code&gt;id&lt;/code&gt; で識別できる既存のレコードのプロパティのみを変更する場合に適しています。</target>
        </trans-unit>
        <trans-unit id="2d35beb84697160944c091bfc4ea7475ddba8bba" translate="yes" xml:space="preserve">
          <source>In addition to the bin script, the &lt;code&gt;relay-compiler&lt;/code&gt; package also &lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/relay-compiler/RelayCompilerPublic.js&quot;&gt;exports library code&lt;/a&gt; which you may use to create more complex configurations for the compiler, or to extend the compiler with your own custom output.</source>
          <target state="translated">binスクリプトに加えて、 &lt;code&gt;relay-compiler&lt;/code&gt; パッケージは、コンパイラーのより複雑な構成を作成したり、独自のカスタム出力でコンパイラーを拡張したりするために使用できる&lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/relay-compiler/RelayCompilerPublic.js&quot;&gt;ライブラリコード&lt;/a&gt;もエクスポートします。</target>
        </trans-unit>
        <trans-unit id="1ee7cb663ba30043049419a3987f32bf98b8e3b6" translate="yes" xml:space="preserve">
          <source>In order to incrementally convert an existing codebase, we will need to use the Relay Modern API while continuing to use the Relay Classic runtime until all components are converted.</source>
          <target state="translated">既存のコードベースをインクリメンタルに変換するには、Relay Modern APIを使用する必要がありますが、すべてのコンポーネントが変換されるまでRelay Classicランタイムを使用し続ける必要があります。</target>
        </trans-unit>
        <trans-unit id="b06055f46a51395cce09c8715fc83f412863f99f" translate="yes" xml:space="preserve">
          <source>In order to know how to access your GraphQL server, Relay Modern requires developers to provide an object implementing the &lt;code&gt;NetworkLayer&lt;/code&gt; interface when creating an instance of a &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt;. The environment uses this network layer to execute queries, mutations, and (if your server supports them) subscriptions. This allows developers to use whatever transport (HTTP, WebSockets, etc) and authentication is most appropriate for their application, decoupling the environment from the particulars of each application's network configuration.</source>
          <target state="translated">Relay Modernは、GraphQLサーバーにアクセスする方法を知るために、&lt;a href=&quot;relay-environment&quot;&gt;リレー環境の&lt;/a&gt;インスタンスを作成するときに、 &lt;code&gt;NetworkLayer&lt;/code&gt; インターフェイスを実装するオブジェクトを提供するよう開発者に要求します。環境はこのネットワークレイヤーを使用して、クエリ、ミューテーション、および（サーバーでサポートされている場合は）サブスクリプションを実行します。これにより、開発者はトランスポート（HTTP、WebSocketsなど）を使用でき、認証はアプリケーションに最も適しており、環境を各アプリケーションのネットワーク構成の詳細から切り離します。</target>
        </trans-unit>
        <trans-unit id="3a7aba64216b1cd4d2d2e3ad530a1f3188fad50d" translate="yes" xml:space="preserve">
          <source>In order to resolve a fragment into an array of objects you have to use the &lt;code&gt;@relay(plural: true)&lt;/code&gt; directive.</source>
          <target state="translated">フラグメントをオブジェクトの配列に解決するには、 &lt;code&gt;@relay(plural: true)&lt;/code&gt; ディレクティブを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="e6f38813eb9d2dd5b73b9500e984665cfcbc9419" translate="yes" xml:space="preserve">
          <source>In our experience, the overwhelming majority of products want one specific behavior: fetch &lt;em&gt;all&lt;/em&gt; the data for a view hierarchy while displaying a loading indicator, and then render the &lt;em&gt;entire&lt;/em&gt; view once the data is ready.</source>
          <target state="translated">私たちの経験では、圧倒的多数の製品で特定の動作が1つ必要です。ロードインジケーターを表示しながらビュー階層の&lt;em&gt;すべて&lt;/em&gt;のデータをフェッチ&lt;em&gt;し&lt;/em&gt;、データの準備ができたらビュー&lt;em&gt;全体を&lt;/em&gt;レンダリングします。</target>
        </trans-unit>
        <trans-unit id="6a8da0b71c4c64aea6ae6834a91b9401918c3e7e" translate="yes" xml:space="preserve">
          <source>In that last example, think of &lt;code&gt;$format&lt;/code&gt; and &lt;code&gt;variables.format&lt;/code&gt; as the same value.</source>
          <target state="translated">最後の例では、 &lt;code&gt;$format&lt;/code&gt; と &lt;code&gt;variables.format&lt;/code&gt; を同じ値と考えてください。</target>
        </trans-unit>
        <trans-unit id="3888fb491d2876bafea276807002a772ce2740fc" translate="yes" xml:space="preserve">
          <source>In the diagram above:</source>
          <target state="translated">上の図では</target>
        </trans-unit>
        <trans-unit id="fafabc5dfb7d6fbb341fd52614abab0575f4bf79" translate="yes" xml:space="preserve">
          <source>In the example below, the &lt;code&gt;user&lt;/code&gt; prop will include the data for &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; fields wherever &lt;code&gt;...Component_internUser&lt;/code&gt; is included, instead of Relay's normal behavior to mask those fields.</source>
          <target state="translated">以下の例では、リレーとは通常の動作ではなく、 &lt;code&gt;...Component_internUser&lt;/code&gt; が含まれている &lt;code&gt;user&lt;/code&gt; に、ユーザープロップに &lt;code&gt;id&lt;/code&gt; および &lt;code&gt;name&lt;/code&gt; フィールドのデータが含まれます。</target>
        </trans-unit>
        <trans-unit id="b3b357ad1aa217f6b814380c122b67ca81691203" translate="yes" xml:space="preserve">
          <source>In the future, advanced capabilities in Relay may be dependent on the network layer being able to support certain features.</source>
          <target state="translated">将来的には、Relayの高度な機能は、ネットワーク・レイヤーが特定の機能をサポートできるかどうかに依存する可能性があります。</target>
        </trans-unit>
        <trans-unit id="db9e71215ab64e7c01402f6a78301e1bc8b38923" translate="yes" xml:space="preserve">
          <source>In this article we'll explore what it means to build a GraphQL client framework and how this compares to clients for more traditional REST systems. Along the way we'll look at the design decisions behind Relay and see that it's not just a GraphQL client but also a framework for &lt;em&gt;declarative data-fetching&lt;/em&gt;. Let's start at the beginning and fetch some data!</source>
          <target state="translated">この記事では、GraphQLクライアントフレームワークを構築することの意味と、これを従来のRESTシステムのクライアントと比較する方法について説明します。途中で、Relayの背後にある設計上の決定を見て、それが単なるGraphQLクライアントであるだけでなく、&lt;em&gt;宣言的なデータフェッチの&lt;/em&gt;ためのフレームワークでもあることがわかります。最初から始めて、データをフェッチしてみましょう！</target>
        </trans-unit>
        <trans-unit id="88a02e183add9d1c24413aa47baf530897708969" translate="yes" xml:space="preserve">
          <source>In this example the Route should be initialized with a &lt;code&gt;userID&lt;/code&gt; which gets passed on to the query. That &lt;code&gt;userID&lt;/code&gt; variable will automatically be passed down to the top-level container and can be used there if needed. Further the top-level RelayContainer is expected to have a &lt;code&gt;user&lt;/code&gt; fragment with the fields to be queried.</source>
          <target state="translated">この例では、ルートはクエリに渡される &lt;code&gt;userID&lt;/code&gt; で初期化する必要があります。その &lt;code&gt;userID&lt;/code&gt; 変数は自動的に最上位のコンテナーに渡され、必要に応じてそこで使用できます。さらに、最上位のRelayContainerには、クエリ対象のフィールドを持つ &lt;code&gt;user&lt;/code&gt; フラグメントがあることが期待されます。</target>
        </trans-unit>
        <trans-unit id="8e65c0999502b8d880342481e43745e86b87bd15" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;profilePicture(size: 50)&lt;/code&gt; will be fetched for the intial render.</source>
          <target state="translated">この例では、 &lt;code&gt;profilePicture(size: 50)&lt;/code&gt; レンダリングのためにprofilePicture（size：50）がフェッチされます。</target>
        </trans-unit>
        <trans-unit id="b029685528e8da2f8ce2cf427c32ff8fbbf0ee00" translate="yes" xml:space="preserve">
          <source>In this example, create an inspector object based on the same source as passed into your &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt;. Later you can use this inspector object to inspect records. Inspector is only available in the development build.</source>
          <target state="translated">この例では、&lt;a href=&quot;relay-environment&quot;&gt;リレー環境に&lt;/a&gt;渡されたものと同じソースに基づいてインスペクターオブジェクトを作成します。後でこのインスペクタオブジェクトを使用してレコードを検査できます。インスペクターは開発ビルドでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="4e1907e8aedfd3075f12c9bb08511b6424b05151" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;width&lt;/code&gt; of the rendered image will always correspond to the &lt;code&gt;$size&lt;/code&gt; variable used to fetch the current version of &lt;code&gt;profilePicture.uri&lt;/code&gt;.</source>
          <target state="translated">この例では、レンダリングされた画像の &lt;code&gt;width&lt;/code&gt; は、常に現在のバージョンの &lt;code&gt;profilePicture.uri&lt;/code&gt; をフェッチするために使用される &lt;code&gt;$size&lt;/code&gt; 変数に対応します。</target>
        </trans-unit>
        <trans-unit id="86e6e74d266fdaa434ba59fe220a17114ef82453" translate="yes" xml:space="preserve">
          <source>In this example, the fields associated with the &lt;code&gt;ship&lt;/code&gt; fragment will be made available on &lt;code&gt;this.props.ship&lt;/code&gt;.</source>
          <target state="translated">この例では、 &lt;code&gt;ship&lt;/code&gt; フラグメントに関連付けられたフィールドが &lt;code&gt;this.props.ship&lt;/code&gt; で使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="85172d5db32fabb64291c47b382ebcc9097ed293" translate="yes" xml:space="preserve">
          <source>In this example, whenever &lt;code&gt;Parent&lt;/code&gt; is fetched, &lt;code&gt;Child&lt;/code&gt;'s fragment will also be fetched. When rendering, &lt;code&gt;&amp;lt;Parent&amp;gt;&lt;/code&gt; will only have access to the &lt;code&gt;props.foo.id&lt;/code&gt; field; data from the child fragment will be &lt;a href=&quot;http://facebook.github.io/relay/docs/thinking-in-relay.html#data-masking&quot;&gt;&lt;em&gt;masked&lt;/em&gt;&lt;/a&gt;. By default, &lt;code&gt;childFragment&lt;/code&gt; will use its corresponding initial variables. Relay will fetch &lt;code&gt;photo(size: 64)&lt;/code&gt;. When &lt;code&gt;&amp;lt;Child&amp;gt;&lt;/code&gt; is rendered it will also make the initial variables available as &lt;code&gt;props.relay.variables = {size: 64}&lt;/code&gt;.</source>
          <target state="translated">この例では、 &lt;code&gt;Parent&lt;/code&gt; がフェッチされるたびに、 &lt;code&gt;Child&lt;/code&gt; のフラグメントもフェッチされます。レンダリング時、 &lt;code&gt;&amp;lt;Parent&amp;gt;&lt;/code&gt; は &lt;code&gt;props.foo.id&lt;/code&gt; フィールドにのみアクセスできます。子フラグメントのデータは&lt;a href=&quot;http://facebook.github.io/relay/docs/thinking-in-relay.html#data-masking&quot;&gt;&lt;em&gt;マスクされ&lt;/em&gt;&lt;/a&gt;ます。デフォルトでは、 &lt;code&gt;childFragment&lt;/code&gt; は対応する初期変数を使用します。リレーは &lt;code&gt;photo(size: 64)&lt;/code&gt; をフェッチします。場合 &lt;code&gt;&amp;lt;Child&amp;gt;&lt;/code&gt; レンダリングされ、それはまた、初期変数が利用できるようになります &lt;code&gt;props.relay.variables = {size: 64}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79f26e8bd2ce0d98aed5c314fad80d4d64f729d8" translate="yes" xml:space="preserve">
          <source>In this example, whenever a picture with a new size is being loaded a spinner is displayed instead of the picture.</source>
          <target state="translated">この例では、新しいサイズの画像が読み込まれると、画像の代わりにスピナーが表示されます。</target>
        </trans-unit>
        <trans-unit id="11c9642bf0d68f60f8223631d67d9ed8e587f204" translate="yes" xml:space="preserve">
          <source>In this particular example, the only field that the &lt;code&gt;LikeButton&lt;/code&gt; cares about is &lt;code&gt;viewerDoesLike&lt;/code&gt;. That field will form part of the tracked query that Relay will intersect with the fat query of &lt;code&gt;LikeStoryMutation&lt;/code&gt; to determine what fields to request as part of the server's response payload for the mutation. Another component elsewhere in the application might be interested in the likers count, or the like sentence. Since those fields will automatically be added to Relay's tracked query, the &lt;code&gt;LikeButton&lt;/code&gt; need not worry about requesting them explicitly.</source>
          <target state="translated">この特定の例では、 &lt;code&gt;LikeButton&lt;/code&gt; が処理する唯一のフィールドは &lt;code&gt;viewerDoesLike&lt;/code&gt; です。そのフィールドは、リレーが &lt;code&gt;LikeStoryMutation&lt;/code&gt; のファットクエリと交差して、ミューテーションに対するサーバーの応答ペイロードの一部としてリクエストするフィールドを決定する追跡クエリの一部を形成します。アプリケーションの他の場所にある別のコンポーネントは、いいね！の数などの文に関心があるかもしれません。これらのフィールドは、Relayの追跡されたクエリに自動的に追加されるため、 &lt;code&gt;LikeButton&lt;/code&gt; は明示的に要求する必要はありません。</target>
        </trans-unit>
        <trans-unit id="877c9e959c13a50bd6cd2c0684ab7d5def3e1397" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will build a game using GraphQL mutations. The goal of the game is to find a hidden treasure in a grid of 9 squares. We will give players three tries to find the treasure. This should give us an end-to-end look at Relay &amp;ndash; from the GraphQL schema on the server, to the React application on the client.</source>
          <target state="translated">このチュートリアルでは、GraphQLミューテーションを使用してゲームを構築します。ゲームの目標は、9つの正方形のグリッドで隠された宝物を見つけることです。プレイヤーは宝物を見つけるために3回試行します。これにより、サーバー上のGraphQLスキーマからクライアント上のReactアプリケーションまで、Relayをエンドツーエンドで確認できるようになります。</target>
        </trans-unit>
        <trans-unit id="c1f61deb9bd75956e5146dd965f4efa1acf76ef5" translate="yes" xml:space="preserve">
          <source>Incrementally modernize your Relay Classic app in these steps:</source>
          <target state="translated">以下の手順でRelay Classicアプリを段階的に近代化します。</target>
        </trans-unit>
        <trans-unit id="0e8c879968a7b304e9792c15d95365ae89d2aa45" translate="yes" xml:space="preserve">
          <source>Injectable Custom Field Handlers</source>
          <target state="translated">注射可能なカスタムフィールドハンドラ</target>
        </trans-unit>
        <trans-unit id="e69c600fe29f0ed75880fd3b696888c254caf34f" translate="yes" xml:space="preserve">
          <source>Inline Fragments</source>
          <target state="translated">インラインフラグメント</target>
        </trans-unit>
        <trans-unit id="1889c37693175c0225de5e6837f2ed3f9f529fe3" translate="yes" xml:space="preserve">
          <source>Inline the value in the GraphQL query, potentially annotating with a GraphQL comment (i.e. &lt;code&gt;# PAGE_SIZE&lt;/code&gt;).</source>
          <target state="translated">潜在的に（すなわちGraphQLコメントと注釈を付ける、GraphQLクエリで値をインライン &lt;code&gt;# PAGE_SIZE&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0de09ec0beb82594d04ee09d8aeb812d06a3d58b" translate="yes" xml:space="preserve">
          <source>Install the latest version of Relay from the &lt;a href=&quot;relay-modern&quot;&gt;getting started guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;relay-modern&quot;&gt;スタートガイド&lt;/a&gt;から最新バージョンのリレーをインストールします。</target>
        </trans-unit>
        <trans-unit id="6603c8ba1e08fe9cd6b6dad35da64e9d939e1d23" translate="yes" xml:space="preserve">
          <source>Integration options are available for open-source routing libraries that can instead fetch data for nested routes in parallel. In many of these cases, using a batching network layer can bring additional benefits in avoiding sending multiple HTTP requests.</source>
          <target state="translated">オープンソースのルーティングライブラリでは、ネストされたルートのデータを並行してフェッチすることができる統合オプションが用意されています。これらのケースの多くでは、バッチングネットワークレイヤーを使用することで、複数の HTTP リクエストを送信しないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="ba3a36612e2c9eeb3ee746032e0c52004c3b84f8" translate="yes" xml:space="preserve">
          <source>Integration with Relay Classic for React Router v2 or v3 is available via &lt;a href=&quot;https://github.com/relay-tools/react-router-relay&quot;&gt;&lt;code&gt;react-router-relay&lt;/code&gt;&lt;/a&gt;, which will aggregate the queries for matched routes, and request data for all routes in parallel.</source>
          <target state="translated">React Router v2またはv3のRelay Classicとの統合は、&lt;a href=&quot;https://github.com/relay-tools/react-router-relay&quot;&gt; &lt;code&gt;react-router-relay&lt;/code&gt; &lt;/a&gt;を介して利用できます。これにより、一致したルートのクエリが集約され、すべてのルートのデータが並行してリクエストされます。</target>
        </trans-unit>
        <trans-unit id="ca6f57623e58b4619d24d2a4a11fc39e22aace3a" translate="yes" xml:space="preserve">
          <source>Introduction to Relay Modern</source>
          <target state="translated">現代のリレー入門</target>
        </trans-unit>
        <trans-unit id="cdaf67797686a7d4a210975b6064cb3ac3259374" translate="yes" xml:space="preserve">
          <source>It is also assumed that the reader is already familiar with &lt;a href=&quot;https://en.wikipedia.org/wiki/Star_Wars&quot;&gt;Star Wars&lt;/a&gt;; if not, the 1977 version of Star Wars is a good place to start, though the 1997 Special Edition will serve for the purposes of this document.</source>
          <target state="translated">また、読者はすでに&lt;a href=&quot;https://en.wikipedia.org/wiki/Star_Wars&quot;&gt;スターウォーズに&lt;/a&gt;精通していることを前提としています。そうでない場合は、1977年版のスターウォーズから始めるのが適切ですが、1997年の特別版はこのドキュメントの目的に役立ちます。</target>
        </trans-unit>
        <trans-unit id="df2797c242fbac686a5646e3f8d0990c4c69631c" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is already familiar with GraphQL; if not, the README for &lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;GraphQL.js&lt;/a&gt; is a good place to start.</source>
          <target state="translated">読者はすでにGraphQLに精通していることを前提としています。そうでない場合は、&lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;GraphQL.js&lt;/a&gt;のREADME から始めるとよいでしょう。</target>
        </trans-unit>
        <trans-unit id="efecd775937b634754af4f65cbef5c8b4a7d96ba" translate="yes" xml:space="preserve">
          <source>It returns a &lt;code&gt;Disposable&lt;/code&gt; on which you could call &lt;code&gt;dispose()&lt;/code&gt; to cancel the refetch.</source>
          <target state="translated">再フェッチをキャンセル &lt;code&gt;dispose()&lt;/code&gt; を呼び出すことができる &lt;code&gt;Disposable&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="196589ac6e2b21bbd604e37c3b6f49f22ed50655" translate="yes" xml:space="preserve">
          <source>JavaScript environment requirements</source>
          <target state="translated">JavaScript環境の要件</target>
        </trans-unit>
        <trans-unit id="0b490a2df160ed0c71b8320c42d90d77b3406679" translate="yes" xml:space="preserve">
          <source>JavaScript helpers for defining connections between data, and mutations, in a way that smoothly integrates with Relay.</source>
          <target state="translated">データ間の接続や突然変異を定義するためのJavaScriptヘルパーで、Relayとスムーズに統合できます。</target>
        </trans-unit>
        <trans-unit id="3763226e2b043a56c9ba7559341b0774c3ea862d" translate="yes" xml:space="preserve">
          <source>Keep in mind that it is typically considered an &lt;strong&gt;anti-pattern&lt;/strong&gt; to create a single fragment shared across many containers. Abusing this directive could result in over-fetching in your application.</source>
          <target state="translated">多くのコンテナで共有される単一のフラグメントを作成することは、一般的に&lt;strong&gt;アンチパターン&lt;/strong&gt;と見なされることに注意してください。このディレクティブを悪用すると、アプリケーションでオーバーフェッチが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="25fe5a3c2698d53807ead685c86822cf47cc3073" translate="yes" xml:space="preserve">
          <source>Learn how to use &lt;code&gt;onReadyStateChange&lt;/code&gt; in our next guide, &lt;a href=&quot;guides-ready-state&quot;&gt;Ready State&lt;/a&gt;.</source>
          <target state="translated">次のガイドである&lt;a href=&quot;guides-ready-state&quot;&gt;Ready Stateで&lt;/a&gt; &lt;code&gt;onReadyStateChange&lt;/code&gt; の使用方法を学んでください。</target>
        </trans-unit>
        <trans-unit id="4a4f4fc8ca8973cbce4f7744b6aee5bccdaab0f6" translate="yes" xml:space="preserve">
          <source>Let's associate the mutation we just created with the root mutation type:</source>
          <target state="translated">先ほど作成した突然変異をルートの突然変異型に関連付けてみましょう。</target>
        </trans-unit>
        <trans-unit id="f8acb98279c7a33b14354f6c3ef2bfe03f2deca1" translate="yes" xml:space="preserve">
          <source>Let's craft an optimistic response for the &lt;code&gt;LikeStoryMutation&lt;/code&gt; example above:</source>
          <target state="translated">上記の &lt;code&gt;LikeStoryMutation&lt;/code&gt; の例に対する楽観的な応答を作成してみましょう。</target>
        </trans-unit>
        <trans-unit id="ba32433c3c054db31c3adabcaef06296860fad94" translate="yes" xml:space="preserve">
          <source>Let's explore how this works via a &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; component that composes the &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; from above.</source>
          <target state="translated">上から &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; を構成する &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; コンポーネントを介して、これがどのように機能するかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="89835a8e4dc90be9c02f2fb3d5af523e7de7cee2" translate="yes" xml:space="preserve">
          <source>Let's explore how this works via a &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; component that composes the &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; from above.</source>
          <target state="translated">のは、見てみましょうどのように経由して、この作品 &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; 構成要素 &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; 上から。</target>
        </trans-unit>
        <trans-unit id="8eb1ff4062deba895e97692f949a6733e97ad5f6" translate="yes" xml:space="preserve">
          <source>Let's look at some product use-cases to understand how we incorporated these ideas into Relay. We'll assume a basic familiarity with React.</source>
          <target state="translated">これらのアイデアをどのようにしてReactに取り入れたかを理解するために、いくつかの製品のユースケースを見てみましょう。ここでは、Reactの基本的な知識を想定しています。</target>
        </trans-unit>
        <trans-unit id="839d4a2135069fbb40df14cc776556712d98fa6a" translate="yes" xml:space="preserve">
          <source>Let's open up the starter kit's schema, and replace the database imports with the ones we just created:</source>
          <target state="translated">スターターキットのスキーマを開き、データベースのインポートを先ほど作成したものに置き換えてみましょう。</target>
        </trans-unit>
        <trans-unit id="a72ca83abcd8602717039b5f64a5b5a2b89c81e1" translate="yes" xml:space="preserve">
          <source>Let's see this in action, and query for the ID of the rebels:</source>
          <target state="translated">これを実際に見て、反乱軍のIDを照会してみましょう。</target>
        </trans-unit>
        <trans-unit id="c673a2bcf682f78fa812bcbefa0360994ed37548" translate="yes" xml:space="preserve">
          <source>Let's start a project using the &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt; as a base.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;リレースターターキット&lt;/a&gt;をベースとしてプロジェクトを開始しましょう。</target>
        </trans-unit>
        <trans-unit id="a71dc4b410048806e0d1bbd75c4e909652f2f534" translate="yes" xml:space="preserve">
          <source>Let's take the rebels, and ask for their first ship:</source>
          <target state="translated">反乱軍を連れて最初の船を要求しよう</target>
        </trans-unit>
        <trans-unit id="510f4b78cd5f8fbd49c14a5834839d1ab18bb893" translate="yes" xml:space="preserve">
          <source>Let's tweak the file &lt;code&gt;./js/routes/AppHomeRoute.js&lt;/code&gt; to anchor our game to the &lt;code&gt;game&lt;/code&gt; root field of the schema:</source>
          <target state="translated">ファイル &lt;code&gt;./js/routes/AppHomeRoute.js&lt;/code&gt; を調整して、ゲームをスキーマの &lt;code&gt;game&lt;/code&gt; ルートフィールドに固定します。</target>
        </trans-unit>
        <trans-unit id="cc5b2a062f05dd148b4ef24c76639416ebcc59f3" translate="yes" xml:space="preserve">
          <source>Licensed under the BSD License.</source>
          <target state="translated">BSDライセンスの下でライセンスされています。</target>
        </trans-unit>
        <trans-unit id="8882f419c30a0460f51c5ec6edaf87949c2d7459" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;updater&lt;/code&gt;, there is no need to provide &lt;code&gt;optimisticUpdater&lt;/code&gt; for simple mutations (field change).</source>
          <target state="translated">&lt;code&gt;updater&lt;/code&gt; と同様に、単純なミューテーション（フィールド変更）に &lt;code&gt;optimisticUpdater&lt;/code&gt; を提供する必要はありません。</target>
        </trans-unit>
        <trans-unit id="35b9502f3f76f952801534521de9830a54b15a16" translate="yes" xml:space="preserve">
          <source>Like it can be done with &lt;a href=&quot;guides-containers&quot;&gt;Relay containers&lt;/a&gt;, we can prepare variables for use by our mutation's fragment builders, based on the previous variables and the runtime environment.</source>
          <target state="translated">&lt;a href=&quot;guides-containers&quot;&gt;リレーコンテナ&lt;/a&gt;で実行できるように、以前の変数とランタイム環境に基づいて、ミューテーションのフラグメントビルダーで使用する変数を準備できます。</target>
        </trans-unit>
        <trans-unit id="3715b94c23f4ec20e0da2f29449a3c4646b3d581" translate="yes" xml:space="preserve">
          <source>Like most of the Relay APIs, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; attempts to resolve data using the client store before sending a request to the server. If we instead wanted to force a server request even if data is available on the client, we could use the &lt;code&gt;forceFetch&lt;/code&gt; boolean prop.</source>
          <target state="translated">ほとんどのリレーAPIと同様に、&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;は、サーバーにリクエストを送信する前に、クライアントストアを使用してデータを解決しようとします。代わりに、クライアントでデータが利用できる場合でもサーバーリクエストを強制したい場合は、 &lt;code&gt;forceFetch&lt;/code&gt; ブールプロップを使用できます。</target>
        </trans-unit>
        <trans-unit id="f856144ecb9d05326c6d97badc1a9b834b075ac1" translate="yes" xml:space="preserve">
          <source>Like the GraphQL URI, the timeout and retry behavior can be configured:</source>
          <target state="translated">GraphQL URIと同様に、タイムアウトとリトライの動作を設定することができます。</target>
        </trans-unit>
        <trans-unit id="48a466fb1a66e2ac77ce3c14782794ae94365211" translate="yes" xml:space="preserve">
          <source>Managing asynchronous state transitions and coordinating concurrent requests.</source>
          <target state="translated">非同期の状態遷移を管理し、同時進行のリクエストを調整します。</target>
        </trans-unit>
        <trans-unit id="52b2066f0ecc6504fa0d1683e70c5884d55a8b13" translate="yes" xml:space="preserve">
          <source>Managing errors.</source>
          <target state="translated">エラーの管理。</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="9973640b391cb4b42f93e3afba3395c46f6a7823" translate="yes" xml:space="preserve">
          <source>Migrating a Relay Classic app to Relay Modern doesn't require rewriting from scratch. Instead, convert one component at a time to the Relay Modern API while continuing to have a working app. Once all components have been converted, the smaller and faster Relay Modern runtime can be used.</source>
          <target state="translated">Relay ClassicアプリをRelay Modernに移行する際に、一から書き直す必要はありません。代わりに、アプリを動作させたまま、1つずつコンポーネントをRelay Modern APIに変換してください。すべてのコンポーネントが変換されると、より小さくて高速なRelay Modernランタイムを使用することができます。</target>
        </trans-unit>
        <trans-unit id="a496d014360b49f4df7da034a0313b6a98aa03a1" translate="yes" xml:space="preserve">
          <source>Migrating a Relay Classic app to Relay Modern doesn't require rewriting from scratch. Instead, you can convert one component at a time to the Relay Modern API while continuing to have a working app. Once all components have been converted, the smaller and faster Relay Modern runtime can be used.</source>
          <target state="translated">Relay ClassicアプリをRelay Modernに移行する際に、一から書き直す必要はありません。その代わり、アプリを動作させたまま、1つずつコンポーネントをRelay Modern APIに変換することができます。すべてのコンポーネントが変換されると、より小さくて高速なRelay Modernランタイムを使用することができます。</target>
        </trans-unit>
        <trans-unit id="89ca9763c43ac3c5a6b549a8936812ce36f490d5" translate="yes" xml:space="preserve">
          <source>Migrating to Relay Modern</source>
          <target state="translated">Relay Modernへの移行</target>
        </trans-unit>
        <trans-unit id="a2d0fdbac2d058cc7df5b6a959221d8c7b0c5956" translate="yes" xml:space="preserve">
          <source>Modern &lt;code&gt;createRefetchContainer&lt;/code&gt;</source>
          <target state="translated">最新の &lt;code&gt;createRefetchContainer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04ddebd72b3485cb649586cd882bbc4a0abdd841" translate="yes" xml:space="preserve">
          <source>Modern &lt;code&gt;this.props.relay.loadMore(pageSize...)&lt;/code&gt; in a Pagination Container</source>
          <target state="translated">ページ &lt;code&gt;this.props.relay.loadMore(pageSize...)&lt;/code&gt; コンテナー内の最新のthis.props.relay.loadMore（pageSize ...）</target>
        </trans-unit>
        <trans-unit id="eb7d95f729e7a3975428e61ddb5eb7d7241b4fd9" translate="yes" xml:space="preserve">
          <source>Modern Component</source>
          <target state="translated">モダンなコンポーネント</target>
        </trans-unit>
        <trans-unit id="43dee33213cedaefc62f54e39a529109b27d00fd" translate="yes" xml:space="preserve">
          <source>Modern Mutation</source>
          <target state="translated">現代の突然変異</target>
        </trans-unit>
        <trans-unit id="f4c44d48df48d618739f0b3ad40791ec870c9181" translate="yes" xml:space="preserve">
          <source>Modern Runtime</source>
          <target state="translated">現代のランタイム</target>
        </trans-unit>
        <trans-unit id="d9c1afdc6ae257e230b98cd64d31e69e21611588" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;&amp;lt;QueryRenderer&amp;gt;&lt;/code&gt;</source>
          <target state="translated">最新： &lt;code&gt;&amp;lt;QueryRenderer&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a5e6e8b97a1927e12c72c467f5aebd11a8b3d28" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;commitMutation(this.props.relay.environment, {mutation...})&lt;/code&gt;</source>
          <target state="translated">モダン： &lt;code&gt;commitMutation(this.props.relay.environment, {mutation...})&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08b3c5d91eb7d6d9c801374dc1e47b603bba9b4b" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;createFragmentContainer&lt;/code&gt;</source>
          <target state="translated">モダン： &lt;code&gt;createFragmentContainer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f02b7506a9375f3a261dab66ee915f347b72fd85" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;createPaginationContainer&lt;/code&gt;</source>
          <target state="translated">モダン： &lt;code&gt;createPaginationContainer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c48a2a55168fdc7ce4613937fb203cff48a67840" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;this.props.relay.refetch({foo: bar}...&lt;/code&gt; in a Refetch Container</source>
          <target state="translated">現代： &lt;code&gt;this.props.relay.refetch({foo: bar}...&lt;/code&gt; 再フェッチコンテナで</target>
        </trans-unit>
        <trans-unit id="189e341013a3594080b144a6999f9577b74abee9" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;this.props.relay.refetchConnection(...)&lt;/code&gt; in a Pagination Container</source>
          <target state="translated">最新：ページ &lt;code&gt;this.props.relay.refetchConnection(...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b11a8c01d122a0561a2dbd1098a225c3e43e4308" translate="yes" xml:space="preserve">
          <source>Most applications will create a single Environment instance and use it throughout. In specific situations, however, you may want to create multiple environments for different purposes. For example, you may create a new environment instance whenever the user logs in or out in order to prevent data for different users being cached together. Similarly, a server rendered application may create a new environment instance per request, so that each request gets its own cache and user data does not overlap. Alternatively, you might have multiple products or features within a larger application, and you want each one to have product-specific network-handling or caching.</source>
          <target state="translated">ほとんどのアプリケーションでは、1つの環境インスタンスを作成し、それを全体的に使用します。しかし、特定の状況では、異なる目的のために複数の環境を作成したい場合があります。例えば、異なるユーザーのデータが一緒にキャッシュされるのを防ぐために、ユーザーがログインまたはログアウトするたびに新しい環境インスタンスを作成することができます。同様に、サーバーレンダリングされたアプリケーションは、リクエストごとに新しい環境インスタンスを作成して、各リクエストが独自のキャッシュを取得し、ユーザーデータが重複しないようにすることができます。あるいは、より大きなアプリケーション内に複数の製品や機能があり、それぞれに製品固有のネットワーク処理やキャッシュを持たせたい場合もあるでしょう。</target>
        </trans-unit>
        <trans-unit id="01c289d32b7203303850eb1c7dd2fdae6842ce3a" translate="yes" xml:space="preserve">
          <source>Must be a valid &lt;code&gt;RelayContainer&lt;/code&gt;. Relay will attempt to fulfill its data requirements before rendering it.</source>
          <target state="translated">有効な &lt;code&gt;RelayContainer&lt;/code&gt; である必要があります。リレーはレンダリングする前にデータ要件を満たそうとします。</target>
        </trans-unit>
        <trans-unit id="13bcc5c25bae00735d267b69807a37eb90d90472" translate="yes" xml:space="preserve">
          <source>Mutation</source>
          <target state="translated">Mutation</target>
        </trans-unit>
        <trans-unit id="c55f198bc8c7844e5e05f72964532f5dace071a0" translate="yes" xml:space="preserve">
          <source>Mutation props</source>
          <target state="translated">変異の小道具</target>
        </trans-unit>
        <trans-unit id="00a7fb731451c41a484b7591ece27f55c474ec0e" translate="yes" xml:space="preserve">
          <source>Mutations</source>
          <target state="translated">Mutations</target>
        </trans-unit>
        <trans-unit id="731fdeead88e01d93d0976eb789d77d6c8ba6428" translate="yes" xml:space="preserve">
          <source>Mutator configuration</source>
          <target state="translated">変異子の構成</target>
        </trans-unit>
        <trans-unit id="aeecae05e67a82b3d9ddc32f18bafb250167d7b8" translate="yes" xml:space="preserve">
          <source>NODE_DELETE</source>
          <target state="translated">NODE_DELETE</target>
        </trans-unit>
        <trans-unit id="bef32b44309c819256ef91505f3ce46153114806" translate="yes" xml:space="preserve">
          <source>Nested Routes</source>
          <target state="translated">入れ子になったルート</target>
        </trans-unit>
        <trans-unit id="67269d974acb388f118a96d5b0eb90541c783c5f" translate="yes" xml:space="preserve">
          <source>Nested routes with Relay data dependencies introduce an additional complication. While it's possible to render a &lt;code&gt;QueryRenderer&lt;/code&gt; per route, doing so will lead to request waterfalls in the general case where parent routes do not render their child routes until the data for those parent routes are available. This generally leads to an unnecessary additional delay in loading the data for the page, but may be acceptable for small applications or for applications with shallow route trees.</source>
          <target state="translated">リレーデータに依存するネストされたルートは、さらに複雑になります。ルートごとに &lt;code&gt;QueryRenderer&lt;/code&gt; をレンダリングすることは可能ですが、そうすることで、親ルートのデータが利用可能になるまで親ルートが子ルートをレンダリングしない一般的なケースで、リクエストウォーターフォールが発生します。これは一般に、ページのデータのロードで不必要な追加の遅延につながりますが、小さなアプリケーションや浅いルートツリーを使用するアプリケーションでは許容できる場合があります。</target>
        </trans-unit>
        <trans-unit id="72e403f095e27b7f00c62a3bd59aa377165b5a4c" translate="yes" xml:space="preserve">
          <source>Network Layer</source>
          <target state="translated">ネットワーク層</target>
        </trans-unit>
        <trans-unit id="87869155f5f3484fd0f094292d35a709172baa8a" translate="yes" xml:space="preserve">
          <source>Network layer</source>
          <target state="translated">ネットワーク層</target>
        </trans-unit>
        <trans-unit id="f41f095614dba0f32736c3af7fc6b7b54e8b4b7f" translate="yes" xml:space="preserve">
          <source>Never mutate &lt;code&gt;this.props.relay.variables&lt;/code&gt; directly as it will not trigger data to be fetched properly. Treat &lt;code&gt;this.props.relay.variables&lt;/code&gt; as if it were immutable, just like props.</source>
          <target state="translated">&lt;code&gt;this.props.relay.variables&lt;/code&gt; を直接変更しないでください。データが適切にフェッチされなくなります。 &lt;code&gt;this.props.relay.variables&lt;/code&gt; を、プロップのように不変であるかのように扱います。</target>
        </trans-unit>
        <trans-unit id="a945aa9cbd03a748373e539cadd72f60595b9951" translate="yes" xml:space="preserve">
          <source>New in Relay Modern</source>
          <target state="translated">リレーモダンの新作</target>
        </trans-unit>
        <trans-unit id="34d3ac7ad9c7ff0b33bb48c822077feedfac1008" translate="yes" xml:space="preserve">
          <source>Next, install the compiler (typically as a &lt;code&gt;devDependency&lt;/code&gt;):</source>
          <target state="translated">次に、コンパイラーをインストールします（通常は &lt;code&gt;devDependency&lt;/code&gt; として）。</target>
        </trans-unit>
        <trans-unit id="b11d6766a232735ae2588359ce0e697727bb4a84" translate="yes" xml:space="preserve">
          <source>Next, let's create a file in &lt;code&gt;./js/mutations/CheckHidingSpotForTreasureMutation.js&lt;/code&gt; and create subclass of &lt;code&gt;Relay.Mutation&lt;/code&gt; called &lt;code&gt;CheckHidingSpotForTreasureMutation&lt;/code&gt; to hold our mutation implementation:</source>
          <target state="translated">次に、。 &lt;code&gt;./js/mutations/CheckHidingSpotForTreasureMutation.js&lt;/code&gt; / mutations / CheckHidingSpotForTreasureMutation.jsにファイルを作成し、ミューテーション実装を保持するために、 &lt;code&gt;Relay.Mutation&lt;/code&gt; と呼ばれる &lt;code&gt;CheckHidingSpotForTreasureMutation&lt;/code&gt; サブクラスを作成します。</target>
        </trans-unit>
        <trans-unit id="8d0415201da41a689310dea9dfd9de53cb8630b3" translate="yes" xml:space="preserve">
          <source>Next, let's define a node interface and type. We only need to provide a way for Relay to map from an object to the GraphQL type associated with that object, and from a global ID to the object it points to:</source>
          <target state="translated">次に、ノードのインターフェイスと型を定義しましょう。必要なのは、オブジェクトからそのオブジェクトに関連付けられた GraphQL 型へのマッピングと、グローバル ID からそのオブジェクトが指すオブジェクトへのマッピングだけです。</target>
        </trans-unit>
        <trans-unit id="adc67eef09450d30c9ae37eeb2376e191eb49c0d" translate="yes" xml:space="preserve">
          <source>Next, let's define our game and hiding spot types, and the fields that are available on each.</source>
          <target state="translated">次に、ゲームと隠れ場所のタイプと、それぞれで利用できるフィールドを定義してみましょう。</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="5b3016b7b65c75156425ea4affe66b9292dbd049" translate="yes" xml:space="preserve">
          <source>No Routing</source>
          <target state="translated">ルーティングなし</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="ded70becacd440a8a5293ee572a86c4c58319833" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; will continue to be false.</source>
          <target state="translated">&lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; は引き続きfalseであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7c2002c29e0fca7efc2e3f32bc61fca5000503d9" translate="yes" xml:space="preserve">
          <source>Note that it is &lt;em&gt;highly&lt;/em&gt; recommended that &lt;code&gt;Relay.Container&lt;/code&gt;s define their own fragments and avoid sharing inline &lt;code&gt;var fragment = Relay.QL...&lt;/code&gt; values between containers or files. If you find yourself wanting to share inline fragments, it's likely a sign that it's time to refactor and introduce a new container.</source>
          <target state="translated">&lt;code&gt;Relay.Container&lt;/code&gt; が独自のフラグメントを定義し、コンテナーまたはファイル間でインライン &lt;code&gt;var fragment = Relay.QL...&lt;/code&gt; 値を共有しないようにすることを&lt;em&gt;強く&lt;/em&gt;お勧めします。インラインフラグメントを共有したい場合は、リファクタリングして新しいコンテナを導入する時期が来ている可能性があります。</target>
        </trans-unit>
        <trans-unit id="6251d7c444bd5ea65a8e620b067b7ace419f0985" translate="yes" xml:space="preserve">
          <source>Note that this approach requires &lt;em&gt;n+1&lt;/em&gt; requests to the server: 1 to fetch the list, and &lt;em&gt;n&lt;/em&gt; to fetch each item. With GraphQL we can fetch the same data in a single network request to the server (without creating a custom endpoint that we'd then have to maintain):</source>
          <target state="translated">このアプローチでは、サーバーへの&lt;em&gt;n + 1&lt;/em&gt;リクエストが必要であることに注意してください。リストをフェッチするには1、各アイテムをフェッチするには&lt;em&gt;n&lt;/em&gt;です。GraphQLを使用すると、サーバーへの単一のネットワーク要求で同じデータをフェッチできます（その後、維持する必要があるカスタムエンドポイントを作成する必要はありません）。</target>
        </trans-unit>
        <trans-unit id="41a9a091d399394a5944c5c0a394fb244440e004" translate="yes" xml:space="preserve">
          <source>Note that this is a basic example to help you get started. This example could be extended with additional features such as request/response caching (enabled e.g. when &lt;code&gt;cacheConfig.force&lt;/code&gt; is false) and uploading form data for mutations (the &lt;code&gt;uploadables&lt;/code&gt; parameter).</source>
          <target state="translated">これは、始めるのに役立つ基本的な例であることに注意してください。この例は、リクエスト/レスポンスキャッシング（たとえば &lt;code&gt;cacheConfig.force&lt;/code&gt; がfalseの場合に有効）やミューテーション用のフォームデータの &lt;code&gt;uploadables&lt;/code&gt; （uploadablesパラメーター）などの追加機能で拡張できます。</target>
        </trans-unit>
        <trans-unit id="18e979539b69c286787704dcc6ebc81753f2b6c9" translate="yes" xml:space="preserve">
          <source>Note that this normalized cache structure allows overlapping results to be cached without duplication. Each record is stored once regardless of how it is fetched. Let's return to the earlier example of inconsistent data and see how this cache helps in that scenario.</source>
          <target state="translated">この正規化されたキャッシュ構造により、重複する結果が重複せずにキャッシュされることに注意してください。各レコードは、どのようにフェッチされたかに関係なく一度だけ保存されます。先ほどの矛盾したデータの例に戻って、このキャッシュがそのシナリオでどのように役立つかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="6a3998469edc7ffa18da69953898b4c848c54481" translate="yes" xml:space="preserve">
          <source>Note that this solution will also work for &lt;em&gt;writes&lt;/em&gt;: any update to the cache will notify the affected views, and writes are just another thing that updates the cache.</source>
          <target state="translated">このソリューションは&lt;em&gt;書き込みで&lt;/em&gt;も機能することに注意してください。キャッシュを更新すると、影響を受けるビューに通知されます。書き込みは、キャッシュを更新するもう1つの方法です。</target>
        </trans-unit>
        <trans-unit id="ac8054c10594bdd95e89a5e8a8673034de9d793b" translate="yes" xml:space="preserve">
          <source>Note that when composing fragments, the type of the composed fragment must match the field on the parent in which it is embedded. For example, it wouldn't make sense to embed a fragment of type &lt;code&gt;Story&lt;/code&gt; into a parent's field of type &lt;code&gt;User&lt;/code&gt;. Relay and GraphQL will provide helpful error messages if you get this wrong (and if they aren't helpful, let us know!).</source>
          <target state="translated">フラグメントを作成する場合、作成されたフラグメントのタイプは、それが埋め込まれている親のフィールドと一致する必要があることに注意してください。たとえば、タイプ &lt;code&gt;Story&lt;/code&gt; のフラグメントをタイプ &lt;code&gt;User&lt;/code&gt; の親のフィールドに埋め込むことは意味がありません。RelayとGraphQLは、これを間違えた場合に役立つエラーメッセージを提供します（役に立たない場合はお知らせください！）。</target>
        </trans-unit>
        <trans-unit id="0cb3b8bd044c603524ff2409189dcccf98b3f39b" translate="yes" xml:space="preserve">
          <source>Note: Determining variable values at runtime</source>
          <target state="translated">注意:実行時の変数値の決定</target>
        </trans-unit>
        <trans-unit id="6eb6c807aac98e74096f64d7f8585ee557b93a39" translate="yes" xml:space="preserve">
          <source>Note: In most cases, it is possible to rely on the default singleton instance of the environment, which is exposed as &lt;code&gt;Relay.Store&lt;/code&gt;.</source>
          <target state="translated">注：ほとんどの場合、 &lt;code&gt;Relay.Store&lt;/code&gt; として公開されている環境のデフォルトのシングルトンインスタンスに依存することが可能です。</target>
        </trans-unit>
        <trans-unit id="06bd725e4a6c3e529d4b86297fa0d602b821e04c" translate="yes" xml:space="preserve">
          <source>Note: This method may only be called once per instance.</source>
          <target state="translated">注意:このメソッドは、インスタンスごとに一度しか呼び出すことができません。</target>
        </trans-unit>
        <trans-unit id="a0e48b33fadd08f907218ada431ccb61eb2d094e" translate="yes" xml:space="preserve">
          <source>Notice that it immediately executes the next task. Relay manages the order of tasks to ensure a proper order of operations - the scheduler can't skip or reorder tasks, only decide when to execute the next one.</source>
          <target state="translated">すぐに次のタスクを実行することに注目してください。スケジューラはタスクを飛ばしたり順番を変えたりすることはできず、次のタスクを実行するタイミングを決めるだけです。</target>
        </trans-unit>
        <trans-unit id="c79f05d35d0a7eb36506bd3ab33a1f2773cfa554" translate="yes" xml:space="preserve">
          <source>Notice that the cursor is a base64 string. That's the pattern from earlier: the server is reminding us that this is an opaque string. We can pass this string back to the server as the &lt;code&gt;after&lt;/code&gt; argument to the &lt;code&gt;ships&lt;/code&gt; field, which will let us ask for the next three ships after the last one in the previous result:</source>
          <target state="translated">カーソルがbase64文字列であることに注意してください。これは、以前のパターンです。サーバーは、これが不透明な文字列であることを通知しています。この文字列を、 &lt;code&gt;ships&lt;/code&gt; フィールドの &lt;code&gt;after&lt;/code&gt; 引数としてサーバーに返すことができます。これにより、前の結果の最後の1つに続く3つの発送を要求できます。</target>
        </trans-unit>
        <trans-unit id="3aca59c767d5ed557222dbb5b8557469ae3a4a7f" translate="yes" xml:space="preserve">
          <source>Notice that we're querying for data that &lt;em&gt;may&lt;/em&gt; have changed as a result of the mutation. An obvious question is: why can't the server just tell us what changed? The answer is: it's complicated. GraphQL abstracts over &lt;em&gt;any&lt;/em&gt; data storage layer (or an aggregation of multiple sources), and works with any programming language. Furthermore, the goal of GraphQL is to provide data in a form that is useful to product developers building a view.</source>
          <target state="translated">変更の結果として変更された&lt;em&gt;可能性のある&lt;/em&gt;データをクエリしていることに注意してください。明らかな質問です：なぜサーバーは何が変更されたかを私たちに伝えることができないのですか？答えは、複雑です。GraphQLは、&lt;em&gt;任意の&lt;/em&gt;データストレージレイヤー（または複数のソースの集約）を抽象化し、任意のプログラミング言語で動作します。さらに、GraphQLの目標は、ビューを構築する製品開発者に役立つ形式でデータを提供することです。</target>
        </trans-unit>
        <trans-unit id="056ee5771da852e979294339f6d61f3371dc9784" translate="yes" xml:space="preserve">
          <source>Now Relay will both fetch the larger photo size &lt;em&gt;and&lt;/em&gt;&lt;code&gt;Child&lt;/code&gt; will know to render it.</source>
          <target state="translated">これで、Relayは両方とも大きい写真サイズ&lt;em&gt;を&lt;/em&gt;フェッチし、 &lt;code&gt;Child&lt;/code&gt; はそれをレンダリングすることを認識します。</target>
        </trans-unit>
        <trans-unit id="359fab9a105cb172833a57b904a4f78ae21bf6b3" translate="yes" xml:space="preserve">
          <source>Now Relay will fetch the photo with size 128 - but the &lt;code&gt;Child&lt;/code&gt; container won't magically know about this variable. We have to tell it by passing the variable value as a prop:</source>
          <target state="translated">ここで、Relayはサイズ128の写真をフェッチしますが、 &lt;code&gt;Child&lt;/code&gt; コンテナはこの変数を魔法のように認識しません。変数値を小道具として渡すことでそれを伝える必要があります。</target>
        </trans-unit>
        <trans-unit id="8f4ea81858f10f7f357b3da216fb14eb06c577cc" translate="yes" xml:space="preserve">
          <source>Now let's associate these types with the root query type.</source>
          <target state="translated">それでは、これらの型をルートのクエリ型に関連付けてみましょう。</target>
        </trans-unit>
        <trans-unit id="ee5dbc563862c37bd2eddab0d2faa5a3c1303875" translate="yes" xml:space="preserve">
          <source>Now let's take a closer look at the &lt;code&gt;config&lt;/code&gt;:</source>
          <target state="translated">次に、 &lt;code&gt;config&lt;/code&gt; 詳しく見てみましょう。</target>
        </trans-unit>
        <trans-unit id="c63c75c8f04bcbaded3abd8323247dbc014c15ac" translate="yes" xml:space="preserve">
          <source>Now that we've gone through this tutorial, let's dive into what it means to build a GraphQL client framework and how this compares to clients for more traditional REST systems.</source>
          <target state="translated">ここまででチュートリアルを終えたので、GraphQL クライアントフレームワークを構築する意味と、従来の REST システムのクライアントと比較してみましょう。</target>
        </trans-unit>
        <trans-unit id="3c8e0a4e6791c0f1c68af7b94cb67e9dddbecd93" translate="yes" xml:space="preserve">
          <source>Now we can instantiate a &lt;code&gt;ProfileRoute&lt;/code&gt; that fetches data for user &lt;code&gt;123&lt;/code&gt;:</source>
          <target state="translated">これで、ユーザー &lt;code&gt;123&lt;/code&gt; のデータをフェッチする &lt;code&gt;ProfileRoute&lt;/code&gt; をインスタンス化できます。</target>
        </trans-unit>
        <trans-unit id="d3cbdecefa56176a7edca66548a54ce86a3ed688" translate="yes" xml:space="preserve">
          <source>Now, requests for previously cached data can be answered immediately without making a network request. This is a practical approach to improving the perceived performance of an application. However, this method of caching can cause problems with data consistency.</source>
          <target state="translated">今では、以前にキャッシュされたデータへのリクエストは、ネットワークリクエストを行うことなく、すぐに回答できるようになりました。これは、アプリケーションの知覚されたパフォーマンスを向上させるための実用的なアプローチです。しかし、この方法では、データの一貫性に問題が生じる可能性があります。</target>
        </trans-unit>
        <trans-unit id="c7d436121cc7de83cd8afcc9e5b08145f88e3d72" translate="yes" xml:space="preserve">
          <source>Object Identification</source>
          <target state="translated">オブジェクトの識別</target>
        </trans-unit>
        <trans-unit id="509d0e819f7363f119680482f06c06df5503cfc0" translate="yes" xml:space="preserve">
          <source>On the Relay Container the prop &lt;code&gt;bars&lt;/code&gt; will be an array instead of an object.</source>
          <target state="translated">リレーコンテナでは、プロップ &lt;code&gt;bars&lt;/code&gt; はオブジェクトではなく配列になります。</target>
        </trans-unit>
        <trans-unit id="258ab7d6dd3b683b7bd3f1f1a9e4c26dc064e05d" translate="yes" xml:space="preserve">
          <source>On the other hand, GraphQL &lt;strong&gt;fragments&lt;/strong&gt; declare fields that exist on any arbitrary type. For example, the following fragment fetches the profile picture URI for &lt;em&gt;some&lt;/em&gt;&lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">一方、GraphQL &lt;strong&gt;フラグメント&lt;/strong&gt;は、任意の型に存在するフィールドを宣言します。たとえば、次のフラグメントは、&lt;em&gt;一部の&lt;/em&gt; &lt;code&gt;User&lt;/code&gt; のプロフィール写真URIをフェッチします。</target>
        </trans-unit>
        <trans-unit id="e77ad76d86248c3f5b3430ab7a50cf954c824781" translate="yes" xml:space="preserve">
          <source>Once a few or all of your views are using &lt;code&gt;QueryRenderer&lt;/code&gt;, &lt;code&gt;Store&lt;/code&gt; from &lt;code&gt;'react-relay/classic'&lt;/code&gt; could be replaced with a &lt;code&gt;RelayModernEnvironment&lt;/code&gt;. Keep in mind that &lt;code&gt;RelayModernEnvironment&lt;/code&gt; and &lt;code&gt;Store&lt;/code&gt; do not share any data. You might want to hold off on this step until views that have significant data overlap can be switched over at the same time. This step is what unlocks the perf wins for your app. Apps using the &lt;code&gt;RelayModernEnvironment&lt;/code&gt; get to send persisted query IDs instead of the full query strings to the server, as well as much more optimized data normalizing and processing.</source>
          <target state="translated">いくつかまたはすべてのビューが使用されると &lt;code&gt;QueryRenderer&lt;/code&gt; 、 &lt;code&gt;Store&lt;/code&gt; から &lt;code&gt;'react-relay/classic'&lt;/code&gt; 置き換えることができ &lt;code&gt;RelayModernEnvironment&lt;/code&gt; 。 &lt;code&gt;RelayModernEnvironment&lt;/code&gt; と &lt;code&gt;Store&lt;/code&gt; はデータを共有しないことに注意してください。重要なデータのオーバーラップがあるビューを同時に切り替えることができるまで、このステップを保留することをお勧めします。このステップは、アプリのパフォーマンスを向上させるものです。 &lt;code&gt;RelayModernEnvironment&lt;/code&gt; を使用するアプリは、完全なクエリ文字列の代わりに永続化されたクエリIDをサーバーに送信し、さらに最適化されたデータの正規化と処理を行います。</target>
        </trans-unit>
        <trans-unit id="aa26441141ed7039f7d3b90dda06bb5985300871" translate="yes" xml:space="preserve">
          <source>Once all the components and mutations have been converted to use the Relay Modern APIs, convert to using &lt;code&gt;QueryRenderer&lt;/code&gt; instead of using &lt;code&gt;Relay.Renderer&lt;/code&gt; or &lt;code&gt;Relay.RootContainer&lt;/code&gt;. You may supply &lt;code&gt;Store&lt;/code&gt; from &lt;code&gt;'react-relay/classic'&lt;/code&gt; as the &lt;code&gt;environment&lt;/code&gt; for most cases.</source>
          <target state="translated">すべてのコンポーネントとミュー &lt;code&gt;QueryRenderer&lt;/code&gt; がRelay Modern APIを使用するように変換されたら、 &lt;code&gt;Relay.Renderer&lt;/code&gt; または &lt;code&gt;Relay.RootContainer&lt;/code&gt; を使用する代わりに、QueryRendererを使用するように変換します。ほとんどの場合、 &lt;code&gt;environment&lt;/code&gt; として &lt;code&gt;'react-relay/classic'&lt;/code&gt; から &lt;code&gt;Store&lt;/code&gt; を提供できます。</target>
        </trans-unit>
        <trans-unit id="526a2470452cfa759c69b07a4cdac3145513395b" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;error&lt;/code&gt; set to an &lt;code&gt;Error&lt;/code&gt; object.</source>
          <target state="translated">で一度 &lt;code&gt;error&lt;/code&gt; に設定 &lt;code&gt;Error&lt;/code&gt; オブジェクト。</target>
        </trans-unit>
        <trans-unit id="d30a28f0a20b5fda3d127c2ba900c1393a0c802c" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; set to true, but &lt;code&gt;stale&lt;/code&gt; set to false.</source>
          <target state="translated">一度、 &lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; をtrueに設定すると、 &lt;code&gt;stale&lt;/code&gt; はfalseに設定されます。</target>
        </trans-unit>
        <trans-unit id="c510443cbc7ffd35f869abc94218360943f66d9e" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; set to true.</source>
          <target state="translated">で一度 &lt;code&gt;ready&lt;/code&gt; と &lt;code&gt;done&lt;/code&gt; trueに設定します。</target>
        </trans-unit>
        <trans-unit id="9b048c01bc7fa82617b39cb08502f943e54b8d4a" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt; set to false.</source>
          <target state="translated">で一度 &lt;code&gt;ready&lt;/code&gt; falseに設定します。</target>
        </trans-unit>
        <trans-unit id="fe545c0159939d91c25a89db650c07bece33f470" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt;, &lt;code&gt;done&lt;/code&gt;, and &lt;code&gt;stale&lt;/code&gt; set to true.</source>
          <target state="translated">いったん &lt;code&gt;ready&lt;/code&gt; 、 &lt;code&gt;done&lt;/code&gt; 、 &lt;code&gt;stale&lt;/code&gt; がtrueに設定されると。</target>
        </trans-unit>
        <trans-unit id="c8f5f6a359004092335c67ac77552d54cac29a5a" translate="yes" xml:space="preserve">
          <source>Once you have an environment, you can pass it in to your &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt; instance, or into mutations via the &lt;code&gt;commitUpdate&lt;/code&gt; function (see &quot;&lt;a href=&quot;mutations&quot;&gt;Mutations&lt;/a&gt;&quot;).</source>
          <target state="translated">環境を作成したら、それを&lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt;インスタンスに渡すか、 &lt;code&gt;commitUpdate&lt;/code&gt; 関数を介して&lt;a href=&quot;mutations&quot;&gt;ミューテーションに&lt;/a&gt;渡すことができます（「ミューテーション」を参照）。</target>
        </trans-unit>
        <trans-unit id="3445237f2d0762c974ff895551ac18ecb7b0fd39" translate="yes" xml:space="preserve">
          <source>One of the big ideas behind the new API is that execution can be made a lot more efficient by moving work ahead-of-time: from the runtime of the app to the build-time. As such, changes to GraphQL fragments require a build step to regenerate a set of artifacts. More on &lt;a href=&quot;relay-compiler&quot;&gt;the Relay Compiler&lt;/a&gt;.</source>
          <target state="translated">新しいAPIの背後にある大きなアイデアの1つは、事前に作業を移動することで実行を大幅に効率化できることです。これは、アプリのランタイムからビルド時までです。そのため、GraphQLフラグメントを変更するには、一連のアーティファクトを再生成するためのビルドステップが必要です。&lt;a href=&quot;relay-compiler&quot;&gt;リレーコンパイラの&lt;/a&gt;詳細。</target>
        </trans-unit>
        <trans-unit id="ad501b8fa6c8a155c72db2494b37eb05a27af8e5" translate="yes" xml:space="preserve">
          <source>One solution is to have a root component fetch the data for all its children. However, this would introduce coupling: every change to a component would require changing &lt;em&gt;any&lt;/em&gt; root component that might render it, and often some components between it and the root. This coupling could mean a greater chance for bugs and slow the pace of development. Ultimately, this approach doesn't take advantage of React's component model. The natural place for specifying data-dependencies was in &lt;em&gt;components&lt;/em&gt;.</source>
          <target state="translated">1つの解決策は、ルートコンポーネントにすべての子のデータをフェッチさせることです。しかし、これはカップリングをご紹介します：コンポーネントへのすべての変更は、変更が必要となる&lt;em&gt;任意の&lt;/em&gt;それをレンダリングする可能性があるルート・コンポーネントを、それと根の間でしばしばいくつかのコンポーネント。この結合により、バグが発生する可能性が高まり、開発のペースが遅くなる可能性があります。結局のところ、このアプローチはReactのコンポーネントモデルを利用していません。データの依存関係を指定するための自然な場所は、&lt;em&gt;コンポーネント&lt;/em&gt;でした。</target>
        </trans-unit>
        <trans-unit id="6b5a7ba3ecdf80b9b9c9285e7c15e081d2c4cfd9" translate="yes" xml:space="preserve">
          <source>One thing is left in the example above &amp;mdash; implementing &lt;code&gt;setSize()&lt;/code&gt;, which should change the photo's size when the slider values changes. In addition to passing the results of each query to the component, Relay also provides a &lt;code&gt;relay&lt;/code&gt; prop that has Relay-specific methods and metadata. These include &lt;code&gt;variables&lt;/code&gt; &amp;mdash; the active variables used to fetch the current &lt;code&gt;props&lt;/code&gt; &amp;mdash; and &lt;code&gt;setVariables()&lt;/code&gt; &amp;mdash; a callback that can be used to request data for different variable values.</source>
          <target state="translated">上記の例には1つ残っています &lt;code&gt;setSize()&lt;/code&gt; 実装すると、スライダーの値が変化したときに写真のサイズが変化します。コンポーネントに各クエリの結果を渡すことに加えて、リレーも提供 &lt;code&gt;relay&lt;/code&gt; リレー特定の方法およびメタデータを有するプロペラを。これらには、 &lt;code&gt;variables&lt;/code&gt; &lt;code&gt;setVariables()&lt;/code&gt; 現在の &lt;code&gt;props&lt;/code&gt; をフェッチするために使用されるアクティブな変数）およびsetVariables（） &amp;mdash;さまざまな変数値のデータを要求するために使用できるコールバックが含まれます。</target>
        </trans-unit>
        <trans-unit id="43ec0f0f8cb785cd4021b95098b6011da01043b4" translate="yes" xml:space="preserve">
          <source>Only fields specified by these fragments will be populated in &lt;code&gt;this.props&lt;/code&gt; when the component is rendered. This ensures that there are no implicit dependencies from a component on its parent component or any child components.</source>
          <target state="translated">これらのフラグメントで指定されたフィールドのみが、コンポーネントのレンダリング時に &lt;code&gt;this.props&lt;/code&gt; に入力されます。これにより、親コンポーネントまたは子コンポーネント上のコンポーネントからの暗黙的な依存関係がなくなります。</target>
        </trans-unit>
        <trans-unit id="544901021486ff794813761281a30a85a9ea2561" translate="yes" xml:space="preserve">
          <source>Optimistic updates</source>
          <target state="translated">楽観的なアップデート</target>
        </trans-unit>
        <trans-unit id="75e97d82c2ab23fae3c5ae0de671aad8aaab254b" translate="yes" xml:space="preserve">
          <source>Optimistically updating the UI while waiting for the server to respond to mutations.</source>
          <target state="translated">サーバーが突然変異に反応するのを待っている間、楽観的にUIを更新します。</target>
        </trans-unit>
        <trans-unit id="a30573ebcc5462272b8ba6828cf0b15e88284677" translate="yes" xml:space="preserve">
          <source>Option 1: Re-fetch everything that the app has ever queried. Even though only a small subset of this data will actually change, we'll still have to wait for the server to execute the &lt;em&gt;entire&lt;/em&gt; query, wait to download the results, and wait to process them again. This is very inefficient.</source>
          <target state="translated">オプション1：アプリがこれまでにクエリしたすべてのものを再フェッチします。このデータの小さなサブセットのみが実際に変更される場合でも、サーバーがクエリ&lt;em&gt;全体&lt;/em&gt;を実行するのを待ち、結果をダウンロードして、再度処理するのを待つ必要があります。これは非常に非効率的です。</target>
        </trans-unit>
        <trans-unit id="7c7f0ed28de8faafd0afd103f17d025324ed7cc5" translate="yes" xml:space="preserve">
          <source>Option 2: Re-fetch only the queries required by actively rendered views. This is a slight improvement over option 1. However, cached data that &lt;em&gt;isn't&lt;/em&gt; currently being viewed won't be updated. Unless this data is somehow marked as stale or evicted from the cache subsequent queries will read outdated information.</source>
          <target state="translated">オプション2：アクティブにレンダリングされたビューで必要なクエリのみを再フェッチします。これは、オプション1に比べてわずかに改善されています。ただし、現在表示されてい&lt;em&gt;ない&lt;/em&gt;キャッシュデータ&lt;em&gt;は&lt;/em&gt;更新されません。このデータがなんらかの方法で失効としてマークされていないか、キャッシュから削除されていない限り、後続のクエリは古い情報を読み取ります。</target>
        </trans-unit>
        <trans-unit id="1fc54acb388aaf56464909787927f5c9cc6c305b" translate="yes" xml:space="preserve">
          <source>Option 3: Re-fetch a fixed list of fields that &lt;em&gt;may&lt;/em&gt; change after the mutation. We'll call this list a &lt;strong&gt;fat query&lt;/strong&gt;. We found this to also be inefficient because typical applications only render a subset of the fat query, but this approach would require fetching all of those fields.</source>
          <target state="translated">オプション3：変更後に変更される&lt;em&gt;可能性&lt;/em&gt;があるフィールドの固定リストを再フェッチします。このリストを&lt;strong&gt;ファットクエリ&lt;/strong&gt;と呼び&lt;strong&gt;ます&lt;/strong&gt;。通常のアプリケーションはファットクエリのサブセットのみをレンダリングするため、これも非効率的であることがわかりましたが、このアプローチではこれらのフィールドをすべてフェッチする必要があります。</target>
        </trans-unit>
        <trans-unit id="4be11d572e3b53b4fc22dae76efc2d670f4be4bb" translate="yes" xml:space="preserve">
          <source>Option 4 (Relay): Re-fetch the intersection of what may change (the fat query) and the data in the cache. In addition to the cache of data Relay also remembers the queries used to fetch each item. These are called &lt;strong&gt;tracked queries&lt;/strong&gt;. By intersecting the tracked and fat queries, Relay can query exactly the set of information the application needs to update and nothing more.</source>
          <target state="translated">オプション4（リレー）：変更される可能性のあるもの（ファットクエリ）とキャッシュ内のデータの共通部分を再フェッチします。データのキャッシュに加えて、Relayは各アイテムのフェッチに使用されたクエリも記憶しています。これらは&lt;strong&gt;追跡クエリ&lt;/strong&gt;と呼ば&lt;strong&gt;れ&lt;/strong&gt;ます。追跡されたクエリとファットクエリを交差させることで、Relayはアプリケーションが更新する必要がある一連の情報を正確にクエリできます。</target>
        </trans-unit>
        <trans-unit id="6718713de12ca02e84822e47bd7f3094f39d3c0a" translate="yes" xml:space="preserve">
          <source>Optionally install globally</source>
          <target state="translated">必要に応じてグローバルにインストール</target>
        </trans-unit>
        <trans-unit id="b30829da1c673e16f6adae2f5da589d2b2d65970" translate="yes" xml:space="preserve">
          <source>Optionally, follow up with a call to &lt;code&gt;commit()&lt;/code&gt; to send the mutation to the server.</source>
          <target state="translated">必要に応じて、 &lt;code&gt;commit()&lt;/code&gt; を呼び出してサーバーに変異を送信します。</target>
        </trans-unit>
        <trans-unit id="3a603142c92a8b820560fb3bf1b12553420c3f4e" translate="yes" xml:space="preserve">
          <source>Optionally, precede with a call to &lt;code&gt;applyOptimistic()&lt;/code&gt; to apply an update optimistically to the store.</source>
          <target state="translated">必要に応じて、 &lt;code&gt;applyOptimistic()&lt;/code&gt; を呼び出して、ストアに更新を楽観的に適用します。</target>
        </trans-unit>
        <trans-unit id="ae17e1897a8cc791f789d5b34d32406b1c727d64" translate="yes" xml:space="preserve">
          <source>Or this way, with the same results:</source>
          <target state="translated">あるいはこのようにして、同じ結果を得ることができます。</target>
        </trans-unit>
        <trans-unit id="50300a6866222e559def812f5df571c9176ba61e" translate="yes" xml:space="preserve">
          <source>Overrides the &lt;a href=&quot;#defaultnetworklayer-static-property&quot;&gt;DefaultNetworkLayer&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#defaultnetworklayer-static-property&quot;&gt;DefaultNetworkLayerを&lt;/a&gt;オーバーライドします。</target>
        </trans-unit>
        <trans-unit id="fd55d4fdc76dc273300987b3c56489168f507c74" translate="yes" xml:space="preserve">
          <source>Overriding Fragment Variables</source>
          <target state="translated">フラグメント変数のオーバーライド</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="100325b8d6de92dc6ff09cd2c078133755bf274f" translate="yes" xml:space="preserve">
          <source>Pagination</source>
          <target state="translated">Pagination</target>
        </trans-unit>
        <trans-unit id="1847eac49f0862bab8cf4f3614ad739655005e7f" translate="yes" xml:space="preserve">
          <source>Pagination Container</source>
          <target state="translated">ページネーションコンテナ</target>
        </trans-unit>
        <trans-unit id="66cd194918cca0919b19b5c19a6632d8edf7c051" translate="yes" xml:space="preserve">
          <source>PaginationContainer</source>
          <target state="translated">PaginationContainer</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="5a9a81786a3cd10e92834a3ac1d48bcd7f39e6e3" translate="yes" xml:space="preserve">
          <source>Please note that the &lt;code&gt;&quot;relay&quot;&lt;/code&gt; plugin should run before other plugins or presets to ensure the &lt;code&gt;graphql&lt;/code&gt; template literals are correctly transformed. See Babel's &lt;a href=&quot;https://babeljs.io/docs/plugins/#plugin-preset-ordering&quot;&gt;documentation on this topic&lt;/a&gt;.</source>
          <target state="translated">ことに注意してください &lt;code&gt;&quot;relay&quot;&lt;/code&gt; プラグインは他のプラグインやプリセットの前に実行する必要が確保する &lt;code&gt;graphql&lt;/code&gt; テンプレートリテラルが正しく変換されます。&lt;a href=&quot;https://babeljs.io/docs/plugins/#plugin-preset-ordering&quot;&gt;このトピックに関する&lt;/a&gt; Babelのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="02a0a62fe61678e8a433343395761ce593ca76c7" translate="yes" xml:space="preserve">
          <source>Please note that this replaces the &lt;a href=&quot;guides-babel-plugin&quot;&gt;older Babel Relay plugin&lt;/a&gt;. It is not necessary to include both plugins.</source>
          <target state="translated">これは、&lt;a href=&quot;guides-babel-plugin&quot;&gt;以前のBabel Relayプラグインに&lt;/a&gt;代わるものです。両方のプラグインを含める必要はありません。</target>
        </trans-unit>
        <trans-unit id="c6a15b9b600a39666d059f44d5e217d0eadd28f6" translate="yes" xml:space="preserve">
          <source>Populating The Cache</source>
          <target state="translated">キャッシュの配置</target>
        </trans-unit>
        <trans-unit id="9ef1894fd67a6660f9dc545b85fdd7563a957682" translate="yes" xml:space="preserve">
          <source>Populating the cache involves walking a hierarchical GraphQL response and creating or updating normalized cache records. At first it may seem that the response alone is sufficient to process the response, but in fact this is only true for very simple queries. Consider &lt;code&gt;user(id: &quot;456&quot;) { photo(size: 32) { uri } }&lt;/code&gt; &amp;mdash; how should we store &lt;code&gt;photo&lt;/code&gt;? Using &lt;code&gt;photo&lt;/code&gt; as the field name in the cache won't work because a different query might fetch the same field but with different argument values (e.g. &lt;code&gt;photo(size: 64) {...}&lt;/code&gt;). A similar issue occurs with pagination. If we fetch the 11th to 20th stories with &lt;code&gt;stories(first: 10, offset: 10)&lt;/code&gt;, these new results should be &lt;em&gt;appended&lt;/em&gt; to the existing list.</source>
          <target state="translated">キャッシュへのデータの取り込みには、階層的なGraphQL応答のウォーク、正規化されたキャッシュレコードの作成または更新が含まれます。最初は、応答だけで応答を処理するのに十分であるように見えるかもしれませんが、実際、これは非常に単純なクエリにのみ当てはまります。 &lt;code&gt;user(id: &quot;456&quot;) { photo(size: 32) { uri } }&lt;/code&gt; 検討します &amp;mdash; &lt;code&gt;photo&lt;/code&gt; をどのように保存すればよいですか？キャッシュ内のフィールド名として &lt;code&gt;photo&lt;/code&gt; を使用しても機能しません。別のクエリが同じフィールドをフェッチするが、引数値が異なる場合があるためです（例： &lt;code&gt;photo(size: 64) {...}&lt;/code&gt; ）。同様の問題がページネーションでも発生します。 &lt;code&gt;stories(first: 10, offset: 10)&lt;/code&gt; を使用して11番目から20番目のストーリーをフェッチする場合、これらの新しい結果は既存のリストに&lt;em&gt;追加さ&lt;/em&gt;れます。</target>
        </trans-unit>
        <trans-unit id="178213e972c712d32c9b754e0fae0660405a3262" translate="yes" xml:space="preserve">
          <source>Processing the schema</source>
          <target state="translated">スキーマの処理</target>
        </trans-unit>
        <trans-unit id="9fb705d5e8095ddb73ff47bd5a3af904d3ea97b5" translate="yes" xml:space="preserve">
          <source>PropTypes</source>
          <target state="translated">PropTypes</target>
        </trans-unit>
        <trans-unit id="bc6c88db2f0703a9e2461a4a8060ccf1cb881998" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Properties</target>
        </trans-unit>
        <trans-unit id="1100c030f3dc539b64e7700624cabb080430dd57" translate="yes" xml:space="preserve">
          <source>Properties and Methods</source>
          <target state="translated">プロパティとメソッド</target>
        </trans-unit>
        <trans-unit id="e5561bc237fb41709bb2e8b651d704c1664ae03e" translate="yes" xml:space="preserve">
          <source>Props</source>
          <target state="translated">Props</target>
        </trans-unit>
        <trans-unit id="32bb9f0eed56ead65c951dc161935d4389c8dfcc" translate="yes" xml:space="preserve">
          <source>QL</source>
          <target state="translated">QL</target>
        </trans-unit>
        <trans-unit id="0fa0f7a77beffe015e3dbe50d9707a0cef073bae" translate="yes" xml:space="preserve">
          <source>Queries vs. Fragments</source>
          <target state="translated">クエリーとフラグメント</target>
        </trans-unit>
        <trans-unit id="715a8fe94c1d42fc9dfbb4b5057bd51288856fd1" translate="yes" xml:space="preserve">
          <source>Query Naming Convention</source>
          <target state="translated">クエリの命名規則</target>
        </trans-unit>
        <trans-unit id="0f4abb2dc94c20672b1e17a54e1138df9766d152" translate="yes" xml:space="preserve">
          <source>Query Renderer</source>
          <target state="translated">クエリレンダラ</target>
        </trans-unit>
        <trans-unit id="64c6ced3f69ca25be02a6b4eb81804275f87ea3e" translate="yes" xml:space="preserve">
          <source>QueryConfig</source>
          <target state="translated">QueryConfig</target>
        </trans-unit>
        <trans-unit id="92ed502ab1f6d9e04d58803b1ef2281c76306e49" translate="yes" xml:space="preserve">
          <source>QueryRenderer</source>
          <target state="translated">QueryRenderer</target>
        </trans-unit>
        <trans-unit id="004b0b56745c5867ceb6c95eccae46bc9634eca6" translate="yes" xml:space="preserve">
          <source>Queuing mutations to avoid race conditions.</source>
          <target state="translated">レース条件を回避するためのキューイング変異。</target>
        </trans-unit>
        <trans-unit id="455083cac2ae96eabe3895762b6080aa09e6afa4" translate="yes" xml:space="preserve">
          <source>Quick Start</source>
          <target state="translated">クイックスタート</target>
        </trans-unit>
        <trans-unit id="c22fa04a8b6a77a7856984111524e39134e2d44d" translate="yes" xml:space="preserve">
          <source>RANGE_ADD</source>
          <target state="translated">RANGE_ADD</target>
        </trans-unit>
        <trans-unit id="a5c0b5daae0eddce515d43e69bbf8ebe6c085aa7" translate="yes" xml:space="preserve">
          <source>RANGE_DELETE</source>
          <target state="translated">RANGE_DELETE</target>
        </trans-unit>
        <trans-unit id="65b00e2a3b97ba71c6979a03111363ff814865c1" translate="yes" xml:space="preserve">
          <source>REQUIRED_CHILDREN</source>
          <target state="translated">REQUIRED_CHILDREN</target>
        </trans-unit>
        <trans-unit id="5ca02c4d8d1e211afacc19bb40a490a44ae66f21" translate="yes" xml:space="preserve">
          <source>React Native Configuration</source>
          <target state="translated">React Native の設定</target>
        </trans-unit>
        <trans-unit id="55a38b3edc3904e22c3fddf2b60febe07b47d508" translate="yes" xml:space="preserve">
          <source>React Router</source>
          <target state="translated">リアクトルータ</target>
        </trans-unit>
        <trans-unit id="6bb70948dc19f1bb32a259898fca2dfd714e7448" translate="yes" xml:space="preserve">
          <source>React and Relay support creating arbitrarily complex applications through &lt;em&gt;composition&lt;/em&gt;. Larger components can be created by composing smaller components, helping us to create modular, robust applications. There are two aspects to composing components in Relay:</source>
          <target state="translated">ReactおよびRelayは、&lt;em&gt;コンポジション&lt;/em&gt;を通じて任意に複雑なアプリケーションの作成をサポートします。小さなコンポーネントを組み合わせることで大きなコンポーネントを作成でき、モジュール式の堅牢なアプリケーションの作成に役立ちます。Relayでコンポーネントを構成するには、2つの側面があります。</target>
        </trans-unit>
        <trans-unit id="1b75cb8007be8e88622c14d5835273832c1645c5" translate="yes" xml:space="preserve">
          <source>React component classes may have methods, often accessed via &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;refs&lt;/a&gt;. Since Relay composes these component instances in a container, you need to use the &lt;code&gt;componentRef&lt;/code&gt; prop to access them:</source>
          <target state="translated">Reactコンポーネントクラスにはメソッドがあり、多くの場合&lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;refs&lt;/a&gt;を介してアクセスされます。リレーはこれらのコンポーネントインスタンスをコンテナで構成するので、 &lt;code&gt;componentRef&lt;/code&gt; プロップを使用してそれらにアクセスする必要があります。</target>
        </trans-unit>
        <trans-unit id="4414b37377cdce419545fa9b20f3ee40db7ae79f" translate="yes" xml:space="preserve">
          <source>Reading From Cache</source>
          <target state="translated">キャッシュからの読み込み</target>
        </trans-unit>
        <trans-unit id="65ef251f859a908e6a35bac8ecaf436651601f86" translate="yes" xml:space="preserve">
          <source>Reads the value of an attribute on a record by the field name and an object representing pre-defined argument values.</source>
          <target state="translated">レコード上の属性の値を、フィールド名とあらかじめ定義された引数の値を表すオブジェクトで読み込みます。</target>
        </trans-unit>
        <trans-unit id="e3c57930509c5101e93fa1b560decb910e955968" translate="yes" xml:space="preserve">
          <source>Ready State</source>
          <target state="translated">レディステート</target>
        </trans-unit>
        <trans-unit id="e276b1dc6fd5b2e2feab8b52644788511fadacad" translate="yes" xml:space="preserve">
          <source>Ready State Change</source>
          <target state="translated">準備状態の変更</target>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="a3c412dd10a0e8cb0c1899aa86989fec9f2b0413" translate="yes" xml:space="preserve">
          <source>RefetchContainer</source>
          <target state="translated">RefetchContainer</target>
        </trans-unit>
        <trans-unit id="638e5005315e0cabef699577f78933ca4cc7db6a" translate="yes" xml:space="preserve">
          <source>Refetching Data (aka &quot;See More&quot;)</source>
          <target state="translated">データのリフェッチ(別名「もっと見る</target>
        </trans-unit>
        <trans-unit id="47f437a4450523abebb9b8a6327af806c6dfe250" translate="yes" xml:space="preserve">
          <source>Related APIs</source>
          <target state="translated">関連API</target>
        </trans-unit>
        <trans-unit id="9f537f977fa2ecd1f91ff057ce1667e98ab04729" translate="yes" xml:space="preserve">
          <source>Relay</source>
          <target state="translated">Relay</target>
        </trans-unit>
        <trans-unit id="88dd507e8359bb2fd7a7702cfdc9ffaecb218c8a" translate="yes" xml:space="preserve">
          <source>Relay Classic API</source>
          <target state="translated">Relay Classic API</target>
        </trans-unit>
        <trans-unit id="d6764a98d68a0f585f067a880fb7f047e42e5295" translate="yes" xml:space="preserve">
          <source>Relay Classic Guides</source>
          <target state="translated">リレークラシックガイド</target>
        </trans-unit>
        <trans-unit id="aef721f4de8f071bed34bec165e9e8e9422d904c" translate="yes" xml:space="preserve">
          <source>Relay Classic Interfaces</source>
          <target state="translated">リレー・クラシック・インターフェイス</target>
        </trans-unit>
        <trans-unit id="8ee884f2695bfbad6a7a6dae4d48bf3348965934" translate="yes" xml:space="preserve">
          <source>Relay Compat</source>
          <target state="translated">リレーコンパット</target>
        </trans-unit>
        <trans-unit id="c546e3c1729605fb70a2db1deb7870608f3445c7" translate="yes" xml:space="preserve">
          <source>Relay Compat is part of &lt;code&gt;'react-relay'&lt;/code&gt; which allows you to do exactly this, providing an identical API to Relay Modern, while allowing interoperability with both runtimes.</source>
          <target state="translated">Relay Compatは &lt;code&gt;'react-relay'&lt;/code&gt; の一部であり、これにより正確にこれを行うことができ、Relay Modernと同じAPIを提供すると同時に、両方のランタイムとの相互運用を可能にします。</target>
        </trans-unit>
        <trans-unit id="ddef7758830f719ed90adce373f8f83b9acf721d" translate="yes" xml:space="preserve">
          <source>Relay Compiler</source>
          <target state="translated">リレーコンパイラ</target>
        </trans-unit>
        <trans-unit id="be2b89d58206687eafd6b5f1f94bb37fb0baa8fb" translate="yes" xml:space="preserve">
          <source>Relay Containers</source>
          <target state="translated">リレー容器</target>
        </trans-unit>
        <trans-unit id="e0d9a631ef93e7ccb54370c0af336f421599b386" translate="yes" xml:space="preserve">
          <source>Relay DevTools is tool designed to help developers inspect their Relay state and understand how store changes overtime. Relay DevTools ships in two ways:</source>
          <target state="translated">Relay DevToolsは、開発者がRelayの状態を検査し、ストアが時間の経過とともにどのように変化するかを理解するためのツールです。Relay DevToolsは2つの方法で出荷されます。</target>
        </trans-unit>
        <trans-unit id="426c398ee54f1b774dac3a903f0125ae20a5c9e6" translate="yes" xml:space="preserve">
          <source>Relay Documentation</source>
          <target state="translated">リレードキュメント</target>
        </trans-unit>
        <trans-unit id="1443cd7ff63d89730c443bd7786d90a6df7d1998" translate="yes" xml:space="preserve">
          <source>Relay Environment</source>
          <target state="translated">リレー環境</target>
        </trans-unit>
        <trans-unit id="d699ddf70a567d16a64d34cd746d0cc2172e4ec9" translate="yes" xml:space="preserve">
          <source>Relay Modern</source>
          <target state="translated">リレー現代</target>
        </trans-unit>
        <trans-unit id="125aa7abbb0a0bc142817f98c7e32cd828f1f474" translate="yes" xml:space="preserve">
          <source>Relay Modern comes with automatic Flow type generation for the fragments used in Relay containers based on the GraphQL schema. Using these Flow types can help make an application less error-prone, by ensuring all possible &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; cases are considered even if they don't happen frequently.</source>
          <target state="translated">Relay Modernには、GraphQLスキーマに基づくリレーコンテナーで使用されるフラグメント用の自動フロータイプ生成が付属しています。これらのフロータイプを使用すると、発生する可能性のある &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; ケースがすべて頻繁に発生しなくても確実に考慮されるため、アプリケーションのエラーが発生しにくくなります。</target>
        </trans-unit>
        <trans-unit id="fe351802f53838c0d3ff7ec944643ab9992b7020" translate="yes" xml:space="preserve">
          <source>Relay Modern containers combine standard React components with a description of their data requirements, expressed as one or more GraphQL fragments. Each container is itself a standard React component that can be rendered using the standard React API (e.g. &lt;code&gt;&amp;lt;YourComponent prop={...} /&amp;gt;&lt;/code&gt;). When rendered, a container will read the data for its fragment from the Relay cache. As the fragment data changes - for example due to a mutation, subscription, or updated query response - the container will automatically re-render the component.</source>
          <target state="translated">Relay Modernコンテナーは、標準のReactコンポーネントと、1つ以上のGraphQLフラグメントとして表現されたデータ要件の説明を組み合わせます。各コンテナは、それ自体が標準のReactコンポーネントであり、標準のReact APIを使用してレンダリングできます（例： &lt;code&gt;&amp;lt;YourComponent prop={...} /&amp;gt;&lt;/code&gt; ）。レンダリングされると、コンテナはリレーキャッシュからフラグメントのデータを読み取ります。たとえば、ミューテーション、サブスクリプション、または更新されたクエリ応答により、フラグメントデータが変更されると、コンテナはコンポーネントを自動的に再レン​​ダリングします。</target>
        </trans-unit>
        <trans-unit id="b783df53e509475b97db41df7f512b5cdf7adf0d" translate="yes" xml:space="preserve">
          <source>Relay Modern enables a variety of new features. Some are available via the Compat API, while others require upgrading fully to the Modern runtime. See &lt;a href=&quot;new-in-relay-modern&quot;&gt;what's new in Relay Modern&lt;/a&gt; for more details.</source>
          <target state="translated">Relay Modernは、さまざまな新機能を可能にします。Compat APIを介して利用できるものもあれば、Modernランタイムに完全にアップグレードする必要があるものもあります。詳細について&lt;a href=&quot;new-in-relay-modern&quot;&gt;は、Relay Modernの新機能&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="02ee7840306dae496dace1fe86750e32e8b8c807" translate="yes" xml:space="preserve">
          <source>Relay Modern is a new version of Relay designed from the ground up to be easier to use, more extensible and, most of all, able to improve performance on mobile devices. Relay Modern accomplishes this with static queries and ahead-of-time code generation.</source>
          <target state="translated">Relay Modernは、より使いやすく、より拡張性が高く、何よりもモバイルデバイスでのパフォーマンスを向上させることができるように一から設計されたRelayの新バージョンです。Relay Modernでは、静的クエリと事前のコード生成により、これを実現しています。</target>
        </trans-unit>
        <trans-unit id="451008aa294b51a951e1a6a9073f36b4296c782c" translate="yes" xml:space="preserve">
          <source>Relay Modern requires a Babel plugin to convert GraphQL to runtime artifacts:</source>
          <target state="translated">Relay Modernでは、GraphQLをランタイム・アーティファクトに変換するためのBabelプラグインが必要です。</target>
        </trans-unit>
        <trans-unit id="0d2944c329394a1cfc563059eabe3a8681e7e2bc" translate="yes" xml:space="preserve">
          <source>Relay Modern supports GraphQL Subscriptions, using the imperative update API to allow modifications to the store whenever a payload is received. It also features experimental support for GraphQL Live Queries via polling.</source>
          <target state="translated">Relay ModernはGraphQL Subscriptionをサポートしており、必須更新APIを使用して、ペイロードを受信するたびにストアを変更できるようにしています。また、ポーリングによる GraphQL ライブクエリも実験的にサポートしています。</target>
        </trans-unit>
        <trans-unit id="372f8f866ff79038477865a8b1e68cc2436d4212" translate="yes" xml:space="preserve">
          <source>Relay Modern supports the following directives</source>
          <target state="translated">Relay Modernは以下のディレクティブをサポートしています。</target>
        </trans-unit>
        <trans-unit id="4fcb24b9dcd43c8532db4d056e1af150670c742a" translate="yes" xml:space="preserve">
          <source>Relay Modern uses the Relay Compiler to convert &lt;code&gt;graphql&lt;/code&gt; literals into generated files that live alongside your source files.</source>
          <target state="translated">Relay Modernは、Relayコンパイラを使用して、 &lt;code&gt;graphql&lt;/code&gt; リテラルを、ソースファイルと共存する生成ファイルに変換します。</target>
        </trans-unit>
        <trans-unit id="604519e05335c47d085692b3d5c93c6c0cf24a81" translate="yes" xml:space="preserve">
          <source>Relay Modern's ahead-of-time compilation requires the new Relay Compiler:</source>
          <target state="translated">Relay Modernの先行コンパイルには、新しいRelay Compilerが必要です。</target>
        </trans-unit>
        <trans-unit id="d344ad7e0e46f9326c5126f3f06dc4800f23f6c8" translate="yes" xml:space="preserve">
          <source>Relay Modern's core is essentially an un-opinionated store for GraphQL data. It can be used independent of rendering views using React and can be extended to be used with other frameworks.</source>
          <target state="translated">Relay Modernのコアは、基本的にはGraphQLデータのための非オピニオンストアです。Reactを使ったビューのレンダリングとは独立して使用でき、他のフレームワークと組み合わせて拡張して使用することも可能です。</target>
        </trans-unit>
        <trans-unit id="881bc62d6225c769dfa7c14c7288aba40be25da2" translate="yes" xml:space="preserve">
          <source>Relay Specification</source>
          <target state="translated">リレー仕様</target>
        </trans-unit>
        <trans-unit id="48799f13f2ac51d5720b5a4e683e4a8844cdd877" translate="yes" xml:space="preserve">
          <source>Relay allows developers to annotate their React components with data dependencies by creating &lt;strong&gt;containers&lt;/strong&gt;. These are regular React components that wrap the originals. A key design constraint is that React components are meant to be reusable, so Relay containers must be too. For example, a &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; component might implement a view for rendering any &lt;code&gt;Story&lt;/code&gt; item. The actual story to render would be determined by the data passed to the component: &lt;code&gt;&amp;lt;Story story={ ... } /&amp;gt;&lt;/code&gt;. The equivalent in GraphQL are &lt;strong&gt;fragments&lt;/strong&gt;: named query snippets that specify what data to fetch &lt;em&gt;for an object of a given type&lt;/em&gt;. We might describe the data needed by &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; as follows:</source>
          <target state="translated">リレーを使用すると、開発者は&lt;strong&gt;コンテナ&lt;/strong&gt;を作成することにより、Reactコンポーネントにデータの依存関係を注釈できます。これらは、オリジナルをラップする通常のReactコンポーネントです。設計上の重要な制約は、Reactコンポーネントは再利用可能であることを意図しているため、リレーコンテナーもそうでなければならないということです。たとえば、 &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; コンポーネントは、 &lt;code&gt;Story&lt;/code&gt; アイテムをレンダリングするためのビューを実装する場合があります。レンダリングする実際のストーリーは、コンポーネントに渡されるデータ &lt;code&gt;&amp;lt;Story story={ ... } /&amp;gt;&lt;/code&gt; によって決定されます。 GraphQLでこれに相当するのは&lt;strong&gt;フラグメント&lt;/strong&gt;です。&lt;em&gt;指定されたタイプのオブジェクトについて&lt;/em&gt;フェッチ&lt;em&gt;する&lt;/em&gt;データを指定する名前付きクエリスニペットです。 &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; が必要とするデータは次のように記述できます。</target>
        </trans-unit>
        <trans-unit id="254c939fb761720339a3dd3ad863697bebf60c3f" translate="yes" xml:space="preserve">
          <source>Relay also goes further: it uses opaque identifiers on &lt;code&gt;props&lt;/code&gt; to validate that we've explicitly fetched the data for a component before rendering it. If &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; renders &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; but forgets to include its fragment, Relay will warn that the data for &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; is missing. In fact, Relay will warn &lt;em&gt;even if&lt;/em&gt; some other component happened to fetch the same data required by &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt;. This warning tells us that although things &lt;em&gt;might&lt;/em&gt; work now they're highly likely to break later.</source>
          <target state="translated">リレーもさらに進んでいます：レンダリングする前にコンポーネントのデータを明示的にフェッチしたことを検証するために、 &lt;code&gt;props&lt;/code&gt; に不透明な識別子を使用しています。 &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; が &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; &amp;gt;をレンダリングし、そのフラグメントを含めるのを忘れた場合、Relayは &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; のデータが欠落していることを警告します。実際、他のコンポーネントが &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; が必要とする同じデータをフェッチした&lt;em&gt;場合でも&lt;/em&gt;、Relayは警告します。この警告は、物事&lt;em&gt;は&lt;/em&gt;今&lt;em&gt;は&lt;/em&gt;うまくいく&lt;em&gt;かもしれない&lt;/em&gt;が、後で壊れる可能性が非常に高いことを示しています。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c212579d453e98cbd0a4dcbacffef8088e5ab28f" translate="yes" xml:space="preserve">
          <source>Relay also lets us completely replace the default network layer.</source>
          <target state="translated">Relayでは、デフォルトのネットワーク層を完全に置き換えることもできます。</target>
        </trans-unit>
        <trans-unit id="f200764a518868ca3b31ea98a1353b5d9f2dd1fc" translate="yes" xml:space="preserve">
          <source>Relay can be thought of as two parts which work together: an API for building data-driven components and a runtime which fetches and stores data from GraphQL to populate your app. Relay Modern brings both a new API and a new runtime.</source>
          <target state="translated">データ駆動型コンポーネントを構築するためのAPIと、アプリにデータを反映させるためにGraphQLからデータをフェッチして保存するランタイムです。Relay Modernには、新しいAPIと新しいランタイムの両方が搭載されています。</target>
        </trans-unit>
        <trans-unit id="edc443fe11fe9992f4eb82855f77153b4705147b" translate="yes" xml:space="preserve">
          <source>Relay containers are created using &lt;code&gt;Relay.createContainer&lt;/code&gt;.</source>
          <target state="translated">リレーコンテナーは、 &lt;code&gt;Relay.createContainer&lt;/code&gt; を使用して作成されます。</target>
        </trans-unit>
        <trans-unit id="2748ac007f286936a91fb67b3ca6e11462a7fe21" translate="yes" xml:space="preserve">
          <source>Relay containers are higher-order components &amp;mdash; &lt;code&gt;Relay.createContainer&lt;/code&gt; is a function that takes a React component as input and returns a new component as output. This means that the container can manage data fetching and resolution logic without interfering with the &lt;code&gt;state&lt;/code&gt; of the inner component.</source>
          <target state="translated">リレーコンテナーは高次コンポーネントです&amp;mdash; &lt;code&gt;Relay.createContainer&lt;/code&gt; は、Reactコンポーネントを入力として受け取り、新しいコンポーネントを出力として返す関数です。これは、コンテナーが内部コンポーネントの &lt;code&gt;state&lt;/code&gt; に干渉することなく、データのフェッチおよび解決ロジックを管理できることを意味します。</target>
        </trans-unit>
        <trans-unit id="1c357d13b1cce8a1c46ccc30afeeb5fd2f902c5a" translate="yes" xml:space="preserve">
          <source>Relay containers provide a static &lt;code&gt;getFragment()&lt;/code&gt; method that returns a reference to that component's fragment:</source>
          <target state="translated">リレーコンテナーは、そのコンポーネントのフラグメントへの参照を返す静的な &lt;code&gt;getFragment()&lt;/code&gt; メソッドを提供します。</target>
        </trans-unit>
        <trans-unit id="5a410cc37e6396592aa37827cec122428cb2d984" translate="yes" xml:space="preserve">
          <source>Relay couples React with GraphQL and develops the idea of encapsulation further. It allows components to specify what data they need and the Relay framework provides the data. This makes the data needs of inner components opaque and allows composition of those needs. Thinking about what data an app needs becomes localized to the component making it easier to reason about what fields are needed or no longer needed.</source>
          <target state="translated">RelayはReactとGraphQLを組み合わせ、カプセル化の考え方をさらに発展させています。コンポーネントが必要とするデータを指定し、Relay フレームワークがデータを提供します。これにより、内部コンポーネントのデータニーズが不透明になり、それらのニーズを組み合わせることが可能になります。アプリが必要とするデータを考えることで、コンポーネントにローカライズされ、どのフィールドが必要なのか、あるいは不要なのかを推論するのが容易になります。</target>
        </trans-unit>
        <trans-unit id="934fd827600b774b11b92dcf9269d690870fb9bb" translate="yes" xml:space="preserve">
          <source>Relay ensures that this data is available before the component is rendered.</source>
          <target state="translated">リレーは、コンポーネントがレンダリングされる前にこのデータが利用可能であることを保証します。</target>
        </trans-unit>
        <trans-unit id="b556a8542493c85c6ab714e7efdb1e48fb0c7ece" translate="yes" xml:space="preserve">
          <source>Relay exposes the following APIs to create subscriptions.</source>
          <target state="translated">Relayは、サブスクリプションを作成するために以下のAPIを公開しています。</target>
        </trans-unit>
        <trans-unit id="8076714ed2f663c62d9c70223ceef029bffc6fc4" translate="yes" xml:space="preserve">
          <source>Relay exposes the following APIs to perform mutations.</source>
          <target state="translated">Relayは突然変異を実行するために以下のAPIを公開しています。</target>
        </trans-unit>
        <trans-unit id="9a9f6b192104115130a465f5d1b347425625bd6d" translate="yes" xml:space="preserve">
          <source>Relay fragments, mutations, and queries must be specified using ES6 template literals tagged with &lt;code&gt;Relay.QL&lt;/code&gt;. For example:</source>
          <target state="translated">リレーフラグメント、ミュー &lt;code&gt;Relay.QL&lt;/code&gt; 、クエリは、Relay.QLでタグ付けされたES6テンプレートリテラルを使用して指定する必要があります。例えば：</target>
        </trans-unit>
        <trans-unit id="f94ab02e4b36f1c69a9b192786b3451a5578f530" translate="yes" xml:space="preserve">
          <source>Relay has a network layer abstraction that separates mutations and queries from the actual machinery that sends requests to the GraphQL server. This gives us the flexibility to configure or even completely replace the default network layer via injection.</source>
          <target state="translated">Relayにはネットワーク・レイヤーの抽象化が施されており、突然変異やクエリをGraphQLサーバにリクエストを送信する実際の機器とは分離されています。これにより、インジェクションによってデフォルトのネットワーク層を柔軟に設定したり、完全に置き換えたりすることができます。</target>
        </trans-unit>
        <trans-unit id="3e093a4c47e1f292b6f2a4693a9f28a6e839881f" translate="yes" xml:space="preserve">
          <source>Relay implements several variations of &lt;strong&gt;query traversal&lt;/strong&gt;: operations that walk a query alongside some other data such as the cache or a response payload. For example, when a query is fetched Relay performs a &quot;diff&quot; traversal to determine what fields are missing (much like React diffs virtual DOM trees). This can reduce the amount of data fetched in many common cases and even allow Relay to avoid network requests at all when queries are fully cached.</source>
          <target state="translated">リレーは、&lt;strong&gt;クエリトラバーサルの&lt;/strong&gt;いくつかのバリエーションを実装します。キャッシュや応答ペイロードなどの他のデータと一緒にクエリをウォークするオペレーションです。たとえば、クエリがフェッチされると、Relayは &quot;diff&quot;トラバーサルを実行して、欠落しているフィールドを特定します（React diffs仮想DOMツリーのように）。これにより、多くの一般的なケースでフェッチされるデータの量を減らすことができ、クエリが完全にキャッシュされている場合は、Relayでネットワーク要求をまったく回避することもできます。</target>
        </trans-unit>
        <trans-unit id="1f7225f6558a177e37be9ba84410fe63b32cde06" translate="yes" xml:space="preserve">
          <source>Relay introduces two new classes of objects: &lt;code&gt;RelayContainer&lt;/code&gt; and &lt;code&gt;Relay.Route&lt;/code&gt;. &lt;code&gt;Relay.PropTypes&lt;/code&gt; provides prop validators used to assert that props are of these types.</source>
          <target state="translated">Relayには、 &lt;code&gt;RelayContainer&lt;/code&gt; と &lt;code&gt;Relay.Route&lt;/code&gt; という 2つの新しいオブジェクトクラスが導入されています。 &lt;code&gt;Relay.PropTypes&lt;/code&gt; は、小道具がこれらのタイプであることを表明するために使用される小道具バリデーターを提供します。</target>
        </trans-unit>
        <trans-unit id="97f52c1bbd17e02a2c6367d7476a6ac21c258276" translate="yes" xml:space="preserve">
          <source>Relay is pre-configured to use a default network layer that works with &lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;express-graphql&lt;/a&gt;. This default network layer is exposed via &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt;.</source>
          <target state="translated">リレーは、&lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;express-graphql&lt;/a&gt;で動作するデフォルトのネットワークレイヤーを使用するように事前設定されています。このデフォルトのネットワーク層は、 &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt; を介して公開されます。</target>
        </trans-unit>
        <trans-unit id="54171fd2fa20a9c4bec1be11d3879a92bfa7df55" translate="yes" xml:space="preserve">
          <source>Relay makes use of GraphQL mutations; operations that enable us to mutate data on the client and server. To create a mutation for use in our app, we subclass &lt;code&gt;Relay.Mutation&lt;/code&gt; and implement, at minimum, the four abstract methods listed below.</source>
          <target state="translated">RelayはGraphQLミューテーションを利用します。クライアントとサーバー上のデータを変更できるようにする操作。アプリで使用するミューテーションを作成するには、 &lt;code&gt;Relay.Mutation&lt;/code&gt; をサブクラス化し、少なくとも以下に示す4つの抽象メソッドを実装します。</target>
        </trans-unit>
        <trans-unit id="8dd31c1805e052611332ba16c37162381a4a626a" translate="yes" xml:space="preserve">
          <source>Relay routes don't really implement any URL routing specific logic or work with History API. In the future we will maybe rename RelayRoute to be something more like RelayQueryRoots or RelayQueryConfig.</source>
          <target state="translated">RelayRouteはURLルーティングに特化したロジックを実装しているわけではありませんし、History APIと連携しているわけでもありません。将来的にはRelayRouteの名前をRelayQueryRootsやRelayQueryConfigのようなものに変更するかもしれません。</target>
        </trans-unit>
        <trans-unit id="589e99096a0b6781ff51073c2234321dc486a027" translate="yes" xml:space="preserve">
          <source>Relay routes don't really implement any URL routing specific logic or work with History API. In the future we will maybe rename RelayRoute to be something more like RelayQueryRoots or RelayQueryConfig. For more information around why Relay doesn't provide URL-routing features, and suggestions for such solutions, see &lt;a href=&quot;https://medium.com/@cpojer/relay-and-routing-36b5439bad9&quot;&gt;this post&lt;/a&gt;.</source>
          <target state="translated">リレールートは、URLルーティング固有のロジックを実際に実装したり、History APIと連携したりしません。将来的には、RelayRouteの名前をRelayQueryRootsやRelayQueryConfigなどに変更する予定です。RelayがURLルーティング機能を提供しない理由の詳細と、そのようなソリューションの提案については、&lt;a href=&quot;https://medium.com/@cpojer/relay-and-routing-36b5439bad9&quot;&gt;この投稿を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ef480060aa47ef1a958a5c003bdd30a4e3354405" translate="yes" xml:space="preserve">
          <source>Relay speaks to GraphQL servers through a network layer. The &lt;a href=&quot;guides-network-layer&quot;&gt;network layer&lt;/a&gt; that ships with Relay is compatible with express-graphql out of the box, and will continue to evolve as we add new features to the transport.</source>
          <target state="translated">リレーは、ネットワークレイヤーを介してGraphQLサーバーと通信します。&lt;a href=&quot;guides-network-layer&quot;&gt;ネットワーク層&lt;/a&gt;のリレーに付属の箱の特急-graphqlアウトと互換性があり、そして我々は、トランスポートに新しい機能を追加するよう進化し続けること。</target>
        </trans-unit>
        <trans-unit id="256546be326de4c5533a50332088277d259f1856" translate="yes" xml:space="preserve">
          <source>Relay updates the component whenever the underlying data has changed.</source>
          <target state="translated">Relayは、基礎となるデータが変更されるたびにコンポーネントを更新します。</target>
        </trans-unit>
        <trans-unit id="7f2f7458912547fdfa17a726b3bd42f898c10724" translate="yes" xml:space="preserve">
          <source>Relay uses a &lt;strong&gt;Babel&lt;/strong&gt; plugin to convert &lt;code&gt;graphql&lt;/code&gt; literals into requires of the code generated by Relay Compiler.</source>
          <target state="translated">リレーは、&lt;strong&gt;Babel&lt;/strong&gt;プラグインを使用して、 &lt;code&gt;graphql&lt;/code&gt; リテラルをリレーコンパイラによって生成されたコードの要求に変換します。</target>
        </trans-unit>
        <trans-unit id="9cbd2a4fac093602e7724812345c1426293f1cd9" translate="yes" xml:space="preserve">
          <source>Relay uses a &lt;strong&gt;babel&lt;/strong&gt; plugin to convert from &lt;code&gt;Relay.QL&lt;/code&gt; string templates to JavaScript code that describes each query and includes data from the GraphQL schema.</source>
          <target state="translated">リレーは使用&lt;strong&gt;バベル&lt;/strong&gt;から変換するには、プラグインを &lt;code&gt;Relay.QL&lt;/code&gt; の各クエリを記述し、GraphQLスキーマからのデータを含むJavaScriptコードに文字列テンプレート。</target>
        </trans-unit>
        <trans-unit id="5ab5569c1247a6342fa21f23bd4fe7b1d8d672c4" translate="yes" xml:space="preserve">
          <source>Relay uses a common pattern for mutations, where they are root fields on the mutation type with a single argument, &lt;code&gt;input&lt;/code&gt;, and where the input and output both contain a client mutation identifier used to reconcile requests and responses.</source>
          <target state="translated">リレーはミューテーションに共通のパターンを使用します。これらは単一の引数 &lt;code&gt;input&lt;/code&gt; を持つミューテーションタイプのルートフィールドであり、入力と出力の両方にリクエストとレスポンスの調整に使用されるクライアントミューテーション識別子が含まれます。</target>
        </trans-unit>
        <trans-unit id="dd4a65f25979a2d6ac22ff73e832b56882a6731f" translate="yes" xml:space="preserve">
          <source>Relay uses all of this functionality to build out abstractions around connections, to make these easy to work with efficiently without having to manually manage cursors on the client.</source>
          <target state="translated">Relayではこの機能をすべて使用して接続の抽象化を構築し、クライアント上でカーソルを手動で管理しなくても効率的に作業ができるようにしています。</target>
        </trans-unit>
        <trans-unit id="7215a332ba837f6189ba19038b406a179e835435" translate="yes" xml:space="preserve">
          <source>Relay uses routes to define entry points into a Relay application.</source>
          <target state="translated">Relayでは、Relayアプリケーションへのエントリーポイントを定義するためにルートを使用します。</target>
        </trans-unit>
        <trans-unit id="e84f12bb76c08fcf1ebc1d56caf39b1024a1f70b" translate="yes" xml:space="preserve">
          <source>Relay v1.0 introduces the Relay Modern API:</source>
          <target state="translated">Relay v1.0にはRelay Modern APIが導入されています。</target>
        </trans-unit>
        <trans-unit id="7c3c5e271e633d2cf5f26344b18759ea44b95380" translate="yes" xml:space="preserve">
          <source>Relay wraps its core processing functions inside lightweight tasks, which by default are executed immediately (i.e. synchronously). In order to customize &lt;em&gt;when&lt;/em&gt; these tasks are run - for example to avoid interrupting an animation during a touch gesture - applications can provide a custom scheduling function.</source>
          <target state="translated">リレーは、そのコア処理機能を軽量タスク内にラップします。軽量タスクは、デフォルトですぐに（つまり、同期的に）実行されます。これらのタスクを&lt;em&gt;いつ&lt;/em&gt;実行するかをカスタマイズ&lt;em&gt;する&lt;/em&gt;ために（たとえば、タッチジェスチャー中にアニメーションが中断されないようにするため）、アプリケーションはカスタムスケジューリング機能を提供できます。</target>
        </trans-unit>
        <trans-unit id="576baa5c970e0023c6b7f930fc5b22d07e80b876" translate="yes" xml:space="preserve">
          <source>Relay's approach to data-fetching is heavily inspired by our experience with React. In particular, React breaks complex interfaces into reusable &lt;strong&gt;components&lt;/strong&gt;, allowing developers to reason about discrete units of an application in isolation, and reducing the coupling between disparate parts of an application. Even more important is that these components are &lt;strong&gt;declarative&lt;/strong&gt;: they allow developers to specify &lt;em&gt;what&lt;/em&gt; the UI should look like for a given state, and not have to worry about &lt;em&gt;how&lt;/em&gt; to show that UI. Unlike previous approaches that used imperative commands to manipulate native views (e.g. the DOM), React uses a UI description to automatically determine the necessary commands.</source>
          <target state="translated">Relayのデータ取得へのアプローチは、Reactでの経験に強く影響を受けています。特に、Reactは複雑なインターフェースを再利用可能な&lt;strong&gt;コンポーネント&lt;/strong&gt;に分割し&lt;strong&gt;ます&lt;/strong&gt;。これにより、開発者はアプリケーションの個別のユニットを分離して推論でき、アプリケーションの異なる部分間の結合を減らします。さらに重要なことは、これらのコンポーネントが&lt;strong&gt;宣言的である&lt;/strong&gt;ということです。これにより、開発者は特定の状態でUIがどのように見える&lt;em&gt;か&lt;/em&gt;を指定でき、そのUIの表示&lt;em&gt;方法&lt;/em&gt;を気にする必要がありません。命令型コマンドを使用してネイティブビュー（DOMなど）を操作する以前のアプローチとは異なり、ReactはUI記述を使用して必要なコマンドを自動的に決定します。</target>
        </trans-unit>
        <trans-unit id="6b33d0db31f7976b67c0c833688c3f1a2f3ed1a7" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation</source>
          <target state="translated">Relay.GraphQLMutation</target>
        </trans-unit>
        <trans-unit id="1dd1eeecd4591e6fc51ed50ccec4372072ef5f58" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#applyOptimistic()</source>
          <target state="translated">Relay.GraphQLMutation#applyOptimistic()</target>
        </trans-unit>
        <trans-unit id="778c7e41e609c680486529c141869bd60529ad4f" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#commit()</source>
          <target state="translated">Relay.GraphQLMutation#commit()</target>
        </trans-unit>
        <trans-unit id="3dd83b3b4baca74ae215635dc8057361bd27c698" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#constructor()</source>
          <target state="translated">Relay.GraphQLMutation#constructor()</target>
        </trans-unit>
        <trans-unit id="c60b9c934ff71ffb2a3ed3d72c60871bbe0e468e" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#rollback()</source>
          <target state="translated">Relay.GraphQLMutation#rollback()</target>
        </trans-unit>
        <trans-unit id="3340870222c54d4e58da2c45216a0f9201d39a18" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation.create()</source>
          <target state="translated">Relay.GraphQLMutation.create()</target>
        </trans-unit>
        <trans-unit id="a23c2d405f689b19dfd1fd7c28df5c48a68add1e" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation.createWithFiles()</source>
          <target state="translated">Relay.GraphQLMutation.createWithFiles()</target>
        </trans-unit>
        <trans-unit id="03551f79ebf3cd05d7c2ceaa3bea55c92b64e6d0" translate="yes" xml:space="preserve">
          <source>Relay.Mutation</source>
          <target state="translated">Relay.Mutation</target>
        </trans-unit>
        <trans-unit id="3ba32adda774e85164beb595e60d2e216978176e" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#constructor()</source>
          <target state="translated">Relay.Mutation#constructor()</target>
        </trans-unit>
        <trans-unit id="04100c1f256b9742428fc3ccbb91ce26474f7916" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getCollisionKey()</source>
          <target state="translated">Relay.Mutation#getCollisionKey()</target>
        </trans-unit>
        <trans-unit id="6239b4b0c4bd148ddc88ff80a2414323538280f1" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getConfigs()</source>
          <target state="translated">Relay.Mutation#getConfigs()</target>
        </trans-unit>
        <trans-unit id="ef63d6cc19f0b592de123cd60ec1e1b1998d6f17" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getFatQuery()</source>
          <target state="translated">Relay.Mutation#getFatQuery()</target>
        </trans-unit>
        <trans-unit id="712207e70740181f3ab2120dc0f2bcc301c5f54e" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getFiles()</source>
          <target state="translated">Relay.Mutation#getFiles()</target>
        </trans-unit>
        <trans-unit id="e97a189b3ae9338d83696e14598b587f01455562" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getMutation()</source>
          <target state="translated">Relay.Mutation#getMutation()</target>
        </trans-unit>
        <trans-unit id="9ef4e47c4ce8d138fc8484b73b762f8325ab6d50" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getOptimisticConfigs()</source>
          <target state="translated">Relay.Mutation#getOptimisticConfigs()</target>
        </trans-unit>
        <trans-unit id="9c72c0ca95feabd409adccf873cc396f84f49fa7" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getOptimisticResponse()</source>
          <target state="translated">Relay.Mutation#getOptimisticResponse()</target>
        </trans-unit>
        <trans-unit id="0407ffada104593511af47973fbf4f161321629f" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getVariables()</source>
          <target state="translated">Relay.Mutation#getVariables()</target>
        </trans-unit>
        <trans-unit id="25241731d9b8a5e3bb893a8a7166ea0d07b29738" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.fragments</source>
          <target state="translated">Relay.Mutation.fragments</target>
        </trans-unit>
        <trans-unit id="b7852fe98838e6fc1d72feab70dfa349933b9a4f" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.getFragment()</source>
          <target state="translated">Relay.Mutation.getFragment()</target>
        </trans-unit>
        <trans-unit id="d9618c47616902c437879ab1fb98a8eb932feeeb" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.initialVariables</source>
          <target state="translated">Relay.Mutation.initialVariables</target>
        </trans-unit>
        <trans-unit id="88607afefb79afbc0a5c6c2204c3c59784086c6d" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.prepareVariables</source>
          <target state="translated">Relay.Mutation.prepareVariables</target>
        </trans-unit>
        <trans-unit id="15cdd01f7f3228bf705c67fcca4cc7376e38847b" translate="yes" xml:space="preserve">
          <source>Relay.PropTypes</source>
          <target state="translated">Relay.PropTypes</target>
        </trans-unit>
        <trans-unit id="0af8bcf2b06b250091c5a6a9f45a93a8ec335270" translate="yes" xml:space="preserve">
          <source>Relay.PropTypes.QueryConfig: ReactPropTypeValidator</source>
          <target state="translated">Relay.PropTypes.QueryConfig.ReactPropTypeValidator</target>
        </trans-unit>
        <trans-unit id="991536fff9faf615e80c1b42bfda61b3395074a1" translate="yes" xml:space="preserve">
          <source>Relay.QL</source>
          <target state="translated">Relay.QL</target>
        </trans-unit>
        <trans-unit id="e66127f684a064c2b23590835fd5fc4afce5e3bc" translate="yes" xml:space="preserve">
          <source>Relay.Renderer</source>
          <target state="translated">Relay.Renderer</target>
        </trans-unit>
        <trans-unit id="1e64d297283159c1fd5f3c0f4f7f2590f52aeaf0" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#Container</source>
          <target state="translated">Relay.Renderer#Container</target>
        </trans-unit>
        <trans-unit id="0f68d914b2de005998fdb01ba1b1095a495e227d" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#environment</source>
          <target state="translated">Relay.Renderer#environment</target>
        </trans-unit>
        <trans-unit id="8e4cc916528c14e528833e3f79df2da75fd53acb" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#forceFetch</source>
          <target state="translated">Relay.Renderer#forceFetch</target>
        </trans-unit>
        <trans-unit id="bf0a7bc1a436c9a32f0f42831033b65d5cfbaf43" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#onReadyStateChange</source>
          <target state="translated">Relay.Renderer#onReadyStateChange</target>
        </trans-unit>
        <trans-unit id="9c4d750f130c80ae940ddef73d72538928767978" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#queryConfig</source>
          <target state="translated">Relay.Renderer#queryConfig</target>
        </trans-unit>
        <trans-unit id="ff227ea702919a6f75cb559ade588c7d11c20c78" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#render</source>
          <target state="translated">Relay.Renderer#render</target>
        </trans-unit>
        <trans-unit id="2761fdabd570b4cb3fdee157bed2ad5cb9ae4930" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer</source>
          <target state="translated">Relay.RootContainer</target>
        </trans-unit>
        <trans-unit id="543cce18705fbddda91e09c015e6da78c821e550" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#Component</source>
          <target state="translated">Relay.RootContainer#Component</target>
        </trans-unit>
        <trans-unit id="4c1d8599b11aa80027feab65c33b5f34aece2fe8" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#forceFetch</source>
          <target state="translated">Relay.RootContainer#forceFetch</target>
        </trans-unit>
        <trans-unit id="69120820a45037f7a9e51a705842b61000d0ac96" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#onReadyStateChange</source>
          <target state="translated">Relay.RootContainer#onReadyStateChange</target>
        </trans-unit>
        <trans-unit id="0b9faeb15a496f220a6b405a981a20f8ef453965" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#renderFailure</source>
          <target state="translated">Relay.RootContainer#renderFailure</target>
        </trans-unit>
        <trans-unit id="7bd3ce353967f7aff355ff3522f40b703a8bd047" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#renderFetched</source>
          <target state="translated">Relay.RootContainer#renderFetched</target>
        </trans-unit>
        <trans-unit id="8e6dba1eefc9476de73a3eb76f6a4bb45f2d9827" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#renderLoading</source>
          <target state="translated">Relay.RootContainer#renderLoading</target>
        </trans-unit>
        <trans-unit id="a9647a1d13d1b00fb81a049cb69e0f50d9005610" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#route</source>
          <target state="translated">Relay.RootContainer#route</target>
        </trans-unit>
        <trans-unit id="2163890d6b8486ab713e8307739f1fc8ffdc4051" translate="yes" xml:space="preserve">
          <source>Relay.Route</source>
          <target state="translated">Relay.Route</target>
        </trans-unit>
        <trans-unit id="ec4ec0225d1b12f051db712106148d8b26db80c7" translate="yes" xml:space="preserve">
          <source>Relay.Route#constructor()</source>
          <target state="translated">Relay.Route#constructor()</target>
        </trans-unit>
        <trans-unit id="933d2afe910e8eed75954f1ef8511fc9c8104ede" translate="yes" xml:space="preserve">
          <source>Relay.Route.paramDefinitions</source>
          <target state="translated">Relay.Route.paramDefinitions</target>
        </trans-unit>
        <trans-unit id="be2c5425ec7dbd5886d4716f82a79360b73375a7" translate="yes" xml:space="preserve">
          <source>Relay.Route.prepareParams</source>
          <target state="translated">Relay.Route.prepareParams</target>
        </trans-unit>
        <trans-unit id="632587b7cd190cd1537600ee207e20b1ff9030d5" translate="yes" xml:space="preserve">
          <source>Relay.Route.queries</source>
          <target state="translated">Relay.Route.queries</target>
        </trans-unit>
        <trans-unit id="90af1f420232cc590b9eb96c3c9344d637dded41" translate="yes" xml:space="preserve">
          <source>Relay.Route.routeName</source>
          <target state="translated">Relay.Route.routeName</target>
        </trans-unit>
        <trans-unit id="596c88b6dd79bb8e709c7b945308e399ac2abc3a" translate="yes" xml:space="preserve">
          <source>Relay.Store</source>
          <target state="translated">Relay.Store</target>
        </trans-unit>
        <trans-unit id="1ca8451821663a9beeafb5041c9c0bfdf4aff046" translate="yes" xml:space="preserve">
          <source>Relay.Store.applyUpdate()</source>
          <target state="translated">Relay.Store.applyUpdate()</target>
        </trans-unit>
        <trans-unit id="23f95eef5a8ff15d45d59ef33e2757420f465ed8" translate="yes" xml:space="preserve">
          <source>Relay.Store.commitUpdate()</source>
          <target state="translated">Relay.Store.commitUpdate()</target>
        </trans-unit>
        <trans-unit id="5435b8d8380c04f42e516eb3bd9326e46359b1b6" translate="yes" xml:space="preserve">
          <source>Relay.createContainer()</source>
          <target state="translated">Relay.createContainer()</target>
        </trans-unit>
        <trans-unit id="12f5066f2601943d9aac424bb916a7d3e8a44732" translate="yes" xml:space="preserve">
          <source>Relay.injectNetworkLayer()</source>
          <target state="translated">Relay.injectNetworkLayer()</target>
        </trans-unit>
        <trans-unit id="1a735b56a61cab41febb27320e2f243ed493b94f" translate="yes" xml:space="preserve">
          <source>Relay.injectTaskScheduler()</source>
          <target state="translated">Relay.injectTaskScheduler()</target>
        </trans-unit>
        <trans-unit id="309387769d52bfb1d6f330d2a6e3ecd71ecb41e1" translate="yes" xml:space="preserve">
          <source>Relay.isContainer()</source>
          <target state="translated">Relay.isContainer()</target>
        </trans-unit>
        <trans-unit id="c772f86aadb639ca41aafc4ec6f52aaae43e0acf" translate="yes" xml:space="preserve">
          <source>RelayContainer</source>
          <target state="translated">RelayContainer</target>
        </trans-unit>
        <trans-unit id="76e743848043959a7f2bfa720b5616417bb798e1" translate="yes" xml:space="preserve">
          <source>RelayContainer implements a conservative default &lt;code&gt;shouldComponentUpdate&lt;/code&gt; that returns &lt;code&gt;false&lt;/code&gt; if no fragment props have changed and all other props are equal scalar values. This may block updates to components that receive data via context. To ensure an update in this case override the default behavior by specifying a &lt;code&gt;shouldComponentUpdate&lt;/code&gt; function.</source>
          <target state="translated">RelayContainerは、フラグメントの小道具が変更されておらず、他のすべての小道具が同じスカラー値である場合に &lt;code&gt;false&lt;/code&gt; を返す控えめなデフォルト &lt;code&gt;shouldComponentUpdate&lt;/code&gt; を実装しています。これにより、コンテキストを介してデータを受信するコンポーネントの更新がブロックされる可能性があります。この場合の更新を保証するには、 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 関数を指定してデフォルトの動作をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="83d048709f5073df975dc9c425226f037d2ced9a" translate="yes" xml:space="preserve">
          <source>RelayContainer#forceFetch()</source>
          <target state="translated">RelayContainer#forceFetch()</target>
        </trans-unit>
        <trans-unit id="12306a7598448404edb2c73ef03ebd3b1459df33" translate="yes" xml:space="preserve">
          <source>RelayContainer#fragments</source>
          <target state="translated">RelayContainer#fragments</target>
        </trans-unit>
        <trans-unit id="fa4bac3fc05c361b8142cf895c4dec7b9136e491" translate="yes" xml:space="preserve">
          <source>RelayContainer#getFragment()</source>
          <target state="translated">RelayContainer#getFragment()</target>
        </trans-unit>
        <trans-unit id="0f0d5c6a56d86ccbcf94f9197715dbb511dcccda" translate="yes" xml:space="preserve">
          <source>RelayContainer#getPendingTransactions()</source>
          <target state="translated">RelayContainer#getPendingTransactions()</target>
        </trans-unit>
        <trans-unit id="3583e47f56ed32f6527e40cae51e9cd4226d6b8a" translate="yes" xml:space="preserve">
          <source>RelayContainer#hasOptimisticUpdate()</source>
          <target state="translated">RelayContainer#hasOptimisticUpdate()</target>
        </trans-unit>
        <trans-unit id="f6baca904aa4a3f9af8b6cef6a7995ee09553ec3" translate="yes" xml:space="preserve">
          <source>RelayContainer#initialVariables</source>
          <target state="translated">RelayContainer#initialVariables</target>
        </trans-unit>
        <trans-unit id="67aea36b1c5b679f64f0d153f256c81a818ebe83" translate="yes" xml:space="preserve">
          <source>RelayContainer#pendingVariables</source>
          <target state="translated">RelayContainer#pendingVariables</target>
        </trans-unit>
        <trans-unit id="9cce83d93b864bd7fad1aa07826c61d9a6ef284e" translate="yes" xml:space="preserve">
          <source>RelayContainer#prepareVariables</source>
          <target state="translated">RelayContainer#prepareVariables</target>
        </trans-unit>
        <trans-unit id="ef93161b93af5f5e98d21bb920dbacc9ffd1f25e" translate="yes" xml:space="preserve">
          <source>RelayContainer#route</source>
          <target state="translated">RelayContainer#route</target>
        </trans-unit>
        <trans-unit id="707b6138cca39388519379f5f0473ddd29369f7f" translate="yes" xml:space="preserve">
          <source>RelayContainer#setVariables()</source>
          <target state="translated">RelayContainer#setVariables()</target>
        </trans-unit>
        <trans-unit id="13dc088a9a8f1b885a4b30d133ebfc79f65f8a56" translate="yes" xml:space="preserve">
          <source>RelayContainer#shouldComponentUpdate</source>
          <target state="translated">RelayContainer#shouldComponentUpdate</target>
        </trans-unit>
        <trans-unit id="562b0d971d42af3b685406a662899de6e23e0ff8" translate="yes" xml:space="preserve">
          <source>RelayContainer#variables</source>
          <target state="translated">RelayContainer#variables</target>
        </trans-unit>
        <trans-unit id="cf0a077ddadfb043fbdeb8a931f05f97f9dec4db" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest</source>
          <target state="translated">RelayMutationRequest</target>
        </trans-unit>
        <trans-unit id="459733a291121fc4443f52543c52bf1ba049dc6a" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getDebugName()</source>
          <target state="translated">RelayMutationRequest#getDebugName()</target>
        </trans-unit>
        <trans-unit id="e6aac4071918a71d5a4437bcf00846a0803cb431" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getFiles()</source>
          <target state="translated">RelayMutationRequest#getFiles()</target>
        </trans-unit>
        <trans-unit id="98f8235cb1f82e31b63e4abc739976992bfb5247" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getID()</source>
          <target state="translated">RelayMutationRequest#getID()</target>
        </trans-unit>
        <trans-unit id="aced70c9403a7f1d9071b6bdae3bf77f17f27954" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getQueryString()</source>
          <target state="translated">RelayMutationRequest#getQueryString()</target>
        </trans-unit>
        <trans-unit id="f6fd4f67bc834b8917c668afd31ee438a325f452" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getVariables()</source>
          <target state="translated">RelayMutationRequest#getVariables()</target>
        </trans-unit>
        <trans-unit id="20f8806483b79b8a279be2b49be8c750a67cdb41" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer</source>
          <target state="translated">RelayNetworkLayer</target>
        </trans-unit>
        <trans-unit id="7f0a8ef7b7a43a9933addcbaef565eff07884834" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer#sendMutation()</source>
          <target state="translated">RelayNetworkLayer#sendMutation()</target>
        </trans-unit>
        <trans-unit id="67d40797657bd24a84a171e652a9bea818a15d96" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer#sendQueries()</source>
          <target state="translated">RelayNetworkLayer#sendQueries()</target>
        </trans-unit>
        <trans-unit id="eacde2e3a9c41d29b2ee433848dfea8232a5d22a" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer#supports()</source>
          <target state="translated">RelayNetworkLayer#supports()</target>
        </trans-unit>
        <trans-unit id="5113dd07f144f50d7677810b044a345b89e66e0e" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest</source>
          <target state="translated">RelayQueryRequest</target>
        </trans-unit>
        <trans-unit id="4a9c272793946b8bdd3a09cdfbde6dc8574faf62" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getDebugName()</source>
          <target state="translated">RelayQueryRequest#getDebugName()</target>
        </trans-unit>
        <trans-unit id="481aa62146f5343b4ba1062802709201d6d4d7af" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getID()</source>
          <target state="translated">RelayQueryRequest#getID()</target>
        </trans-unit>
        <trans-unit id="0f467922406404a5eac2d6f11b736b9d66633025" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getQueryString()</source>
          <target state="translated">RelayQueryRequest#getQueryString()</target>
        </trans-unit>
        <trans-unit id="981023af3724c0e925cbc3f99f867f132178c714" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getVariables()</source>
          <target state="translated">RelayQueryRequest#getVariables()</target>
        </trans-unit>
        <trans-unit id="8324e4ecabe765d0034c56fc8f4c857ecfa3e2ae" translate="yes" xml:space="preserve">
          <source>RelayRecordProxy</source>
          <target state="translated">RelayRecordProxy</target>
        </trans-unit>
        <trans-unit id="69b9a9d8ad89e9af43d214607d3ff0018325568c" translate="yes" xml:space="preserve">
          <source>RelayRecordStore</source>
          <target state="translated">RelayRecordStore</target>
        </trans-unit>
        <trans-unit id="8aa27a7e83012be706218f33db1f656ebf3d0b47" translate="yes" xml:space="preserve">
          <source>Render Callbacks</source>
          <target state="translated">レンダーコールバック</target>
        </trans-unit>
        <trans-unit id="e066e80468f5234a1001137061731ae39a651ab5" translate="yes" xml:space="preserve">
          <source>Rendering</source>
          <target state="translated">Rendering</target>
        </trans-unit>
        <trans-unit id="db86b99e5c8c7fa5281608698558232d5c55e13b" translate="yes" xml:space="preserve">
          <source>Rendering Containers</source>
          <target state="translated">レンダリングコンテナ</target>
        </trans-unit>
        <trans-unit id="af597671c6dcfa1df34e2e38251238001351c84d" translate="yes" xml:space="preserve">
          <source>Repeatedly refetching information from the server can get quite slow. For example, navigating from the list of stories, to a list item, and back to the list of stories means we have to refetch the whole list. We'll solve this with the standard solution: &lt;em&gt;caching&lt;/em&gt;.</source>
          <target state="translated">サーバーから繰り返し情報を再フェッチすると、かなり遅くなる可能性があります。たとえば、ストーリーのリストからリストアイテムに移動し、ストーリーのリストに戻るには、リスト全体を再フェッチする必要があります。これを標準のソリューションである&lt;em&gt;キャッシングで&lt;/em&gt;解決します。</target>
        </trans-unit>
        <trans-unit id="3341adcc90aa2cf65b0ed4f78d46fafd5dfc9cd5" translate="yes" xml:space="preserve">
          <source>Requesting Different Data</source>
          <target state="translated">異なるデータを要求する</target>
        </trans-unit>
        <trans-unit id="b092a39c824d57357df89b0ece2eb1e4c9834cca" translate="yes" xml:space="preserve">
          <source>Require the Relay Compat API from &lt;code&gt;'react-relay/compat'&lt;/code&gt; and use it as you would Relay Modern. The components using Relay Compat can be referred to by both other Relay Modern and Relay Classic components.</source>
          <target state="translated">&lt;code&gt;'react-relay/compat'&lt;/code&gt; のRelay Compat APIを要求し、Relay Modernと同じように使用します。Relay Compatを使用するコンポーネントは、他のRelay ModernコンポーネントとRelay Classicコンポーネントの両方から参照できます。</target>
        </trans-unit>
        <trans-unit id="61ac8791c7043a10705ecb741c56abf9848abf0a" translate="yes" xml:space="preserve">
          <source>Resolving Data from the Client</source>
          <target state="translated">クライアントからのデータを解決する</target>
        </trans-unit>
        <trans-unit id="3281bf767244e09b6483581e4d93f748c54eb136" translate="yes" xml:space="preserve">
          <source>Response-caching can also be applied to GraphQL. A basic approach would work similarly to the REST version. The text of the query itself can be used as a cache key:</source>
          <target state="translated">レスポンスキャッシュは GraphQL にも適用できます。基本的なアプローチはREST版と同じように動作します。クエリのテキスト自体をキャッシュキーとして使用することができます。</target>
        </trans-unit>
        <trans-unit id="81554eb7c1007a0bac823cb3e3ca325777b63f97" translate="yes" xml:space="preserve">
          <source>Retrieves record(s) associated with the given record, transversing the source by field name and an object representing pre-defined argument values.</source>
          <target state="translated">指定されたレコードに関連付けられたレコードを、フィールド名と事前に定義された引数の値を表すオブジェクトによってソースを横切って取得します。</target>
        </trans-unit>
        <trans-unit id="e013c79a69f7fdde5c1472633a22316f0ef0ef72" translate="yes" xml:space="preserve">
          <source>Retrying failed requests.</source>
          <target state="translated">失敗したリクエストを再試行しています。</target>
        </trans-unit>
        <trans-unit id="56de3c3d136f4071d757cabe4b6ed2c52a5dad01" translate="yes" xml:space="preserve">
          <source>Returns a proxy class for manipulating records from a record source, for example a query, mutation, or the store.</source>
          <target state="translated">クエリや突然変異、ストアなどのレコードソースからレコードを操作するためのプロキシクラスを返します。</target>
        </trans-unit>
        <trans-unit id="91f8449d9fa8e9ef7aa99597a20ab0dcfe5b332a" translate="yes" xml:space="preserve">
          <source>Returns a read-only view of the store's internal RecordSource that holds all records.</source>
          <target state="translated">すべてのレコードを保持するストアの内部RecordSourceの読み取り専用ビューを返します。</target>
        </trans-unit>
        <trans-unit id="6a9d68c06d14e4ad8d6a81f1e355b118c27b1408" translate="yes" xml:space="preserve">
          <source>Returns the GraphQL type name for a given record.</source>
          <target state="translated">指定したレコードの GraphQL 型名を返します。</target>
        </trans-unit>
        <trans-unit id="384ac89b24069cf234b54ff56b3d6d5c565f33c7" translate="yes" xml:space="preserve">
          <source>Returns the globally unique identifier string for a record.</source>
          <target state="translated">レコードのグローバルに一意な識別子文字列を返します。</target>
        </trans-unit>
        <trans-unit id="7d0eb64e469d72e6ccf94d6d96498f73ad0e6f27" translate="yes" xml:space="preserve">
          <source>Reusable fragments to compose within the above use cases.</source>
          <target state="translated">上記のユースケース内で構成するための再利用可能なフラグメント。</target>
        </trans-unit>
        <trans-unit id="72e1985969f053f8609f492cf63340c5c4f7f3fc" translate="yes" xml:space="preserve">
          <source>Rolls back an optimistic mutation.</source>
          <target state="translated">楽観的な突然変異をロールバックする。</target>
        </trans-unit>
        <trans-unit id="0dfddbb0a122d3a2969eb11e085210ba893e7399" translate="yes" xml:space="preserve">
          <source>Root Container</source>
          <target state="translated">ルートコンテナ</target>
        </trans-unit>
        <trans-unit id="1bf5197778bc12b8d4edfe1a0c2de1ced169d30b" translate="yes" xml:space="preserve">
          <source>RootContainer</source>
          <target state="translated">RootContainer</target>
        </trans-unit>
        <trans-unit id="4999528efe0f94f8f66b1dc05aad8ebaaae7b2be" translate="yes" xml:space="preserve">
          <source>Route</source>
          <target state="translated">Route</target>
        </trans-unit>
        <trans-unit id="52c021a7e89ad4e72cef6096b3c6424e78876574" translate="yes" xml:space="preserve">
          <source>Route is useful in providing the context which a component is being rendered in. It includes information about the &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;params&lt;/code&gt;, and &lt;code&gt;queries&lt;/code&gt; of the current route.</source>
          <target state="translated">ルートは、コンポーネントがレンダリングされているコンテキストを提供するのに役立ちます。これには、現在のルートの &lt;code&gt;name&lt;/code&gt; 、 &lt;code&gt;params&lt;/code&gt; 、および &lt;code&gt;queries&lt;/code&gt; に関する情報が含まれます。</target>
        </trans-unit>
        <trans-unit id="03730e58401ef5d9e79d1f674df0a5f9cf756e33" translate="yes" xml:space="preserve">
          <source>Routes</source>
          <target state="translated">Routes</target>
        </trans-unit>
        <trans-unit id="0bd75f049435ac9bea4df8ce63749bdcfaaef9e4" translate="yes" xml:space="preserve">
          <source>Routes and Queries</source>
          <target state="translated">ルートとクエリ</target>
        </trans-unit>
        <trans-unit id="a476715db16204d7e6fb7743a314ee35337241d4" translate="yes" xml:space="preserve">
          <source>Routes are now optional: &lt;code&gt;QueryRenderer&lt;/code&gt; can be used without defining a route. More in the &lt;a href=&quot;routing&quot;&gt;routing guide&lt;/a&gt;.</source>
          <target state="translated">ルートはオプションになりました。ルートを定義せずに &lt;code&gt;QueryRenderer&lt;/code&gt; を使用できます。&lt;a href=&quot;routing&quot;&gt;ルーティングガイドの&lt;/a&gt;詳細。</target>
        </trans-unit>
        <trans-unit id="ca283153940483bc802b34b41123871d483749c7" translate="yes" xml:space="preserve">
          <source>Routes are objects that define a set of root queries and input parameters. Here is a simple route that might be used to render user &lt;code&gt;123&lt;/code&gt;'s profile:</source>
          <target state="translated">ルートは、ルートクエリと入力パラメーターのセットを定義するオブジェクトです。次に、ユーザー &lt;code&gt;123&lt;/code&gt; のプロファイルをレンダリングするために使用できる簡単なルートを示します。</target>
        </trans-unit>
        <trans-unit id="330b3e499c3450d42634b5702213e434b7a82a41" translate="yes" xml:space="preserve">
          <source>Routes are responsible for defining the entry points into a Relay application. But in order to understand why routes are necessary, we must first understand the difference between GraphQL queries and fragments.</source>
          <target state="translated">ルートは、Relayアプリケーションへのエントリーポイントを定義する役割を果たします。しかし、なぜルーティングが必要なのかを理解するためには、まず GraphQL クエリとフラグメントの違いを理解する必要があります。</target>
        </trans-unit>
        <trans-unit id="ae0f139d125aa65c3494e803bdab2bfc2845048a" translate="yes" xml:space="preserve">
          <source>Routes can declare a set of parameter names that are required to be supplied to the constructor. This is also a convenient place to document the set of valid parameters.</source>
          <target state="translated">ルートは、コンストラクタに供給する必要のあるパラメータ名のセットを宣言することができます。これは、有効なパラメータのセットを文書化するのにも便利な場所です。</target>
        </trans-unit>
        <trans-unit id="e5ec9f7b8ea16c97f062b9386937889c5390bd89" translate="yes" xml:space="preserve">
          <source>Routes can use &lt;code&gt;prepareParams&lt;/code&gt; to provide default parameters, or pass through, convert or suppress passed-in parameters.</source>
          <target state="translated">ルートは、 &lt;code&gt;prepareParams&lt;/code&gt; を使用してデフォルトのパラメーターを提供したり、渡されたパラメーターをパススルー、変換、または抑制したりできます。</target>
        </trans-unit>
        <trans-unit id="a04e20b09d66a6ec94b9fd8e8520062229d58d02" translate="yes" xml:space="preserve">
          <source>Routes must declare a set of query roots using &lt;code&gt;Relay.QL&lt;/code&gt;. These queries will automatically compose a matching fragment named &lt;code&gt;queryName&lt;/code&gt; on the Relay container used with this route on a &lt;strong&gt;Relay.RootContainer&lt;/strong&gt;.</source>
          <target state="translated">ルートは、 &lt;code&gt;Relay.QL&lt;/code&gt; を使用してクエリルートのセットを宣言する必要があります。これらのクエリは、&lt;strong&gt;Relay.RootContainerの&lt;/strong&gt;このルートで使用されるリレーコンテナー上に、 &lt;code&gt;queryName&lt;/code&gt; という名前の一致するフラグメントを自動的に作成します。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fd81fc06977ad2c7156abd14b5b9caa0f8c40fc2" translate="yes" xml:space="preserve">
          <source>Routes must define a string name.</source>
          <target state="translated">ルートは文字列名を定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="380338bdec53655cfe9114fa55d7fe1d8bdbb27d" translate="yes" xml:space="preserve">
          <source>Routes no longer need to know anything about the query root in Relay Modern. Relay components can be rendered anywhere wrapped in a &lt;code&gt;QueryRenderer&lt;/code&gt;. This should bring more flexibility around picking routing frameworks.</source>
          <target state="translated">ルートはRelay Modernのクエリルートについて何も知る必要がなくなりました。リレーコンポーネントは、 &lt;code&gt;QueryRenderer&lt;/code&gt; でラップされた任意の場所にレンダリングできます。これにより、ルーティングフレームワークの選択に関する柔軟性が高まります。</target>
        </trans-unit>
        <trans-unit id="7d15dd1bec2e055c5b177c9f869305ae6c54c9bb" translate="yes" xml:space="preserve">
          <source>Routing</source>
          <target state="translated">Routing</target>
        </trans-unit>
        <trans-unit id="15f12d3d79029156026af15a57e839303e093597" translate="yes" xml:space="preserve">
          <source>Run the Relay Compiler after making changes to any GraphQL in your Relay application. It may be helpful to add it as a &lt;code&gt;yarn script&lt;/code&gt;. Add an entry to &lt;code&gt;&quot;scripts&quot;&lt;/code&gt; in your package.json file.</source>
          <target state="translated">リレーアプリケーションでGraphQLを変更した後、リレーコンパイラを実行します。 &lt;code&gt;yarn script&lt;/code&gt; として追加すると便利です。package.jsonファイルの &lt;code&gt;&quot;scripts&quot;&lt;/code&gt; にエントリを追加します。</target>
        </trans-unit>
        <trans-unit id="b5230ecdf4e78f0dd162281a0a78c6cdc853cbe8" translate="yes" xml:space="preserve">
          <source>Schema</source>
          <target state="translated">Schema</target>
        </trans-unit>
        <trans-unit id="1f0e625b220c0a58aba2033abe91bfe01285293e" translate="yes" xml:space="preserve">
          <source>Schema JSON</source>
          <target state="translated">スキーマJSON</target>
        </trans-unit>
        <trans-unit id="3e32d234cf8a398d348341552d4472b71aa02309" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;interfaces-relay-mutation-request&quot;&gt;RelayMutationRequest&lt;/a&gt; for methods available on the argument object.</source>
          <target state="translated">引数オブジェクトで使用可能なメソッドについては、&lt;a href=&quot;interfaces-relay-mutation-request&quot;&gt;RelayMutationRequest&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="ba186dff4700bd97150240f3ab29c29fbc1b7fc5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;interfaces-relay-query-request&quot;&gt;RelayQueryRequest&lt;/a&gt; for methods available on the argument objects.</source>
          <target state="translated">引数オブジェクトで使用可能なメソッドについては、&lt;a href=&quot;interfaces-relay-query-request&quot;&gt;RelayQueryRequest&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">参照</target>
        </trans-unit>
        <trans-unit id="0ebcd737a1bf60dbd1447977c888467e35a467a0" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#constructor&quot;&gt;GraphQLMutation &amp;gt; Constructor&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#constructor&quot;&gt;GraphQLMutation&amp;gt;コンストラクタ&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb08c52e72850acd0139ed4cb2152c144c9e58eb" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#getconfigs-abstract-method&quot;&gt;Relay.Mutation::getConfigs()&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#getconfigs-abstract-method&quot;&gt;Relay.Mutation :: getConfigs（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="51b02cf1878520658c9b88fe67978bf776e01dd9" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;api-reference-relay-mutation#getcollisionkey&quot;&gt;Relay.Mutation::getCollisionKey()&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;api-reference-relay-mutation#getcollisionkey&quot;&gt;Relay.Mutation :: getCollisionKey（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8665daeb214113b0a6222a07deb324960005a817" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;api-reference-relay-mutation#getconfigs-abstract-method&quot;&gt;Relay.Mutation::getConfigs()&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;api-reference-relay-mutation#getconfigs-abstract-method&quot;&gt;Relay.Mutation :: getConfigs（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9701bc69d708978bae12176bd6d6b49b6310b158" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-containers#relay-containers&quot;&gt;Containers &amp;gt; Relay Containers&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;guides-containers#relay-containers&quot;&gt;コンテナ&amp;gt;リレーコンテナ&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f63708739a0519c20cb04d22aed0623da8910a3b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-containers#requesting-different-data&quot;&gt;Containers &amp;gt; Requesting Different Data&lt;/a&gt;, &lt;a href=&quot;guides-ready-state&quot;&gt;Ready State&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;guides-containers#requesting-different-data&quot;&gt;コンテナ&amp;gt;異なるデータのリクエスト&lt;/a&gt;、&lt;a href=&quot;guides-ready-state&quot;&gt;準備完了状態&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb81a25d0442cce928322c7171025b8b9f41ba2d" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;Mutations &amp;gt; Fragment variables&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;突然変異&amp;gt;フラグメント変数&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="252cc9e75017b1ba4bc6a1cab81814c7c5e7b9c1" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;Mutations &amp;gt; Fragment variables&lt;/a&gt; and &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutations &amp;gt; Optimistic updates&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;ミューテーション&amp;gt;フラグメント変数&lt;/a&gt;と&lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;ミューテーション&amp;gt;オプティミスティックアップデート&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c325d76133ada9407e339b00806d08a492686a72" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#mutator-configuration&quot;&gt;Mutations &amp;gt; Mutator configuration&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;guides-mutations#mutator-configuration&quot;&gt;Mutations&amp;gt; Mutator configuration&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec1a4ead3e670cf9b7225817b2d5536e60b9dfc8" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutations &amp;gt; Optimistic Updates&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;突然変異&amp;gt;楽観的更新&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f91e5359d2e437a1fabed213a7400919e36a4e8f" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutations &amp;gt; Optimistic updates&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;突然変異&amp;gt;楽観的な更新&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a14ec07edd61e594362c3ba2c69cd02521e8cd7" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#the-fat-query&quot;&gt;Mutations &amp;gt; The fat query&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;guides-mutations#the-fat-query&quot;&gt;ミューテーション&amp;gt;ファットクエリ&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3c9e106abf2efb7313ca2aef582895208bb3b4a9" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-ready-state&quot;&gt;Ready State&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;guides-ready-state&quot;&gt;準備完了状態&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d33a51e631c54521d230f0b77c33a0ffcb95a9e" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#component-and-route&quot;&gt;Root Container &amp;gt; Component and Route&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;guides-root-container#component-and-route&quot;&gt;ルートコンテナー&amp;gt;コンポーネントとルート&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6ba9c7676225015beb8fcd0dc8154429cc521b19" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#force-fetching&quot;&gt;Root Container &amp;gt; Force Fetching&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;guides-root-container#force-fetching&quot;&gt;ルートコンテナー&amp;gt;強制フェッチ&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2d475a6214b773e645b11e09318c20c3c31900a2" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#renderfailure&quot;&gt;Root Container &amp;gt; renderFailure&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;guides-root-container#renderfailure&quot;&gt;ルートコンテナ&amp;gt; renderFailure&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="592bf7ec077fdbfb9bb08cfe9e7520a4dc086e1c" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#renderfetched&quot;&gt;Root Container &amp;gt; renderFetched&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;guides-root-container#renderfetched&quot;&gt;ルートコンテナ&amp;gt; renderFetched&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a187f3307739f3f97bdae9d053fcff505ffdeb1" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#renderloading&quot;&gt;Root Container &amp;gt; renderLoading&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;guides-root-container#renderloading&quot;&gt;ルートコンテナ&amp;gt; renderLoading&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2fcf798559587d9befe424605fcb71c2af445685" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-routes&quot;&gt;Routes&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;guides-routes&quot;&gt;ルート&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ac40c2c295e0947fa5d231ce927c5f063044cb9e" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;api-reference-relay-proptypes&quot;&gt;PropTypes API reference&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;api-reference-relay-proptypes&quot;&gt;PropTypes APIリファレンスを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="db3136f0089c09e6cfa1ecac38be1bb1698a01e9" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;api-reference-relay-ql&quot;&gt;Relay.QL API reference&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;api-reference-relay-ql&quot;&gt;Relay.QL APIリファレンスを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="46ebdef898489cac49931005986e50860c184084" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;api-reference-relay-store&quot;&gt;Store API reference&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;api-reference-relay-store&quot;&gt;Store APIリファレンスを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="4011d8e185ce992ad373c12339d3c386a366a9d9" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-mutations&quot;&gt;Mutations Guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;guides-mutations&quot;&gt;突然変異ガイドを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="85e710dc6095fa7ec6992d17389697e3d05b22af" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-network-layer&quot;&gt;Network Layer Guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;guides-network-layer&quot;&gt;ネットワーク層ガイドを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f586115c09169458b9424f28db540ede9b2d7ddf" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-root-container&quot;&gt;RootContainer Guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;guides-root-container&quot;&gt;RootContainer Guideを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c7e49836605664cff515afd9b044294d9e1deeee" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-routes&quot;&gt;Routes Guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;guides-routes&quot;&gt;ルートガイドを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="076a9d109c3f1a2389e316e443efa40d8f78df54" translate="yes" xml:space="preserve">
          <source>Server Error</source>
          <target state="translated">サーバーエラー</target>
        </trans-unit>
        <trans-unit id="6b17482f3f882455ee584aa25321c5bdac980242" translate="yes" xml:space="preserve">
          <source>Set up babel-plugin-relay</source>
          <target state="translated">babel-plugin-relayの設定</target>
        </trans-unit>
        <trans-unit id="8a05cf798da4421d2bd58da023c7f3fb287cd45f" translate="yes" xml:space="preserve">
          <source>Set up relay-compiler</source>
          <target state="translated">リレーコンパイラの設定</target>
        </trans-unit>
        <trans-unit id="f72f8a571d6e8bf5eec6f1a2a44a50aeba5d7932" translate="yes" xml:space="preserve">
          <source>Setting up Relay Compiler</source>
          <target state="translated">リレーコンパイラの設定</target>
        </trans-unit>
        <trans-unit id="4d8e8804be8f7d9838f29acdb1972f43499e72bb" translate="yes" xml:space="preserve">
          <source>Setting up babel-plugin-relay</source>
          <target state="translated">babel-plugin-relayの設定</target>
        </trans-unit>
        <trans-unit id="abeed86f05bd23992570bff235c3a5eea268d38d" translate="yes" xml:space="preserve">
          <source>Show More</source>
          <target state="translated">もっと見る</target>
        </trans-unit>
        <trans-unit id="c0d8810501ac79b3d67791d7c14301a445bdcd5c" translate="yes" xml:space="preserve">
          <source>Similar to how a React component's &lt;code&gt;render&lt;/code&gt; method does not directly modify native views, Relay containers do not directly fetch data. Instead, containers declare a &lt;em&gt;specification&lt;/em&gt; of the data needed to render. Relay guarantees that this data is available &lt;em&gt;before&lt;/em&gt; rendering.</source>
          <target state="translated">Reactコンポーネントの &lt;code&gt;render&lt;/code&gt; メソッドがネイティブビューを直接変更しないのと同様に、Relayコンテナーはデータを直接フェッチしません。代わりに、コンテナはレンダリングに必要なデータの&lt;em&gt;仕様&lt;/em&gt;を宣言します。リレーは&lt;em&gt;、&lt;/em&gt;レンダリング&lt;em&gt;前に&lt;/em&gt;このデータが利用可能であることを保証します。</target>
        </trans-unit>
        <trans-unit id="88286b84c7253d721eb28be982c48ae3b8c8564f" translate="yes" xml:space="preserve">
          <source>Simpler Mutation API</source>
          <target state="translated">よりシンプルな突然変異API</target>
        </trans-unit>
        <trans-unit id="38b269b106dd0853215c15032c144a95de107505" translate="yes" xml:space="preserve">
          <source>Since Relay containers define fragments and not queries, they can be easily embedded in multiple contexts. Like React components, Relay containers are highly reusable.</source>
          <target state="translated">Relay コンテナはクエリではなくフラグメントを定義するため、複数のコンテキストに簡単に埋め込むことができます。Reactコンポーネントと同様に、Relayコンテナは再利用性が高いです。</target>
        </trans-unit>
        <trans-unit id="eed3231995e285304e7921a2b3b7268f678be407" translate="yes" xml:space="preserve">
          <source>Since one game can have many hiding spots, we need to create a connection that we can use to link them together.</source>
          <target state="translated">1つのゲームにはたくさんの隠れ場所があるので、それらをつなげるためのつながりを作る必要があります。</target>
        </trans-unit>
        <trans-unit id="1bc4c3be89589c1b9cbd3e1e89f801487097b78c" translate="yes" xml:space="preserve">
          <source>Smaller Bundle Size</source>
          <target state="translated">バンドルサイズを小さくする</target>
        </trans-unit>
        <trans-unit id="eae26374639c4e0cc2a093a378a0ac3891ecab5b" translate="yes" xml:space="preserve">
          <source>So far we looked at the lower-level aspects of data-fetching and saw how various familiar concepts translate to GraphQL. Next, let's step back and look at some higher-level concerns that product developers often face around data-fetching:</source>
          <target state="translated">ここまでは、データフェッチの低レベルの側面を見てきましたが、様々な身近な概念がどのようにGraphQLに変換されるかを見てきました。次に、一歩下がって、製品開発者がデータフェッチに関してよく直面する、より高いレベルの懸念事項を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="d0fc3a75755e472cad5df2903a8721c7c36d0bc7" translate="yes" xml:space="preserve">
          <source>So far we're just using GraphQL as a more efficient version of typical REST approaches. Note two important benefits in the GraphQL version:</source>
          <target state="translated">今のところ、典型的なRESTアプローチのより効率的なバージョンとしてGraphQLを使用しているに過ぎません。GraphQL版には、2つの重要な利点があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d2a06967c509756a257c5cfbc8a853322fb784a3" translate="yes" xml:space="preserve">
          <source>So far we've looked at the process of querying data and keeping views up to date, but we haven't looked at writes. In GraphQL, writes are called &lt;strong&gt;mutations&lt;/strong&gt;. We can think of them as queries with side effects. Here's an example of calling a mutation that might mark a given story as being liked by the current user:</source>
          <target state="translated">ここまでは、データのクエリとビューの更新のプロセスについて説明してきましたが、書き込みについては説明していません。GraphQLでは、書き込みは&lt;strong&gt;ミュー&lt;/strong&gt;テーションと呼ばれます。これらは、副作用のあるクエリと考えることができます。これは、特定のストーリーを現在のユーザーが高く評価しているとマークするミューテーションを呼び出す例です。</target>
        </trans-unit>
        <trans-unit id="5fb4c3d88d69385cf7a448a7c57e653bef0ce88f" translate="yes" xml:space="preserve">
          <source>So far, we've covered two pieces that each contribute to declaring data:</source>
          <target state="translated">これまでに、データの宣言に貢献する2つの部分を取り上げてきました。</target>
        </trans-unit>
        <trans-unit id="647475236d1bc60d884c2b35b08e1b42225bc0f4" translate="yes" xml:space="preserve">
          <source>So for our &lt;code&gt;introduceShip&lt;/code&gt; mutation, we create two types: &lt;code&gt;IntroduceShipInput&lt;/code&gt; and &lt;code&gt;IntroduceShipPayload&lt;/code&gt;:</source>
          <target state="translated">したがって、 &lt;code&gt;introduceShip&lt;/code&gt; ミューテーションでは、 &lt;code&gt;IntroduceShipInput&lt;/code&gt; と &lt;code&gt;IntroduceShipPayload&lt;/code&gt; の 2つのタイプを作成します。</target>
        </trans-unit>
        <trans-unit id="9b153876a947507c9e895bf7e190b67952746372" translate="yes" xml:space="preserve">
          <source>So how do we use this cache? Let's look at two operations: writing to the cache when a response is received, and reading from the cache to determine if a query can be fulfilled locally (the equivalent to &lt;code&gt;_cache.has(key)&lt;/code&gt; above, but for a graph).</source>
          <target state="translated">では、このキャッシュをどのように使用するのでしょうか。2つの操作を見てみましょう。応答を受け取ったときにキャッシュに書き込むことと、キャッシュから読み取ってクエリをローカルで実行できるかどうかを判断すること &lt;code&gt;_cache.has(key)&lt;/code&gt; 上記の_cache.has（key）と同等ですが、グラフの場合）。</target>
        </trans-unit>
        <trans-unit id="ecc4d54395356b7b485a16f80a383e1e01836248" translate="yes" xml:space="preserve">
          <source>So now we know the ID of the Rebels in our system. We can now refetch them:</source>
          <target state="translated">これでシステム内の反乱軍のIDが分かった これで再検査ができる</target>
        </trans-unit>
        <trans-unit id="6a920cd8724dc921d9d4f9bdbe2e23494f550470" translate="yes" xml:space="preserve">
          <source>So on the first query for ships, GraphQL told us there was a next page, but on the next one, it told us we'd reached the end of the connection.</source>
          <target state="translated">つまり、最初の船のクエリでは、GraphQLは次のページがあると教えてくれたのですが、次のクエリでは、接続が終了したと教えてくれたのです。</target>
        </trans-unit>
        <trans-unit id="7d3d5c6eef5a80a3513fea5675a4ae9df60ad431" translate="yes" xml:space="preserve">
          <source>Some fields - especially those for paginated data - can require post-processing on the client in order to merge previously fetched data with new information. Relay Modern supports custom field handlers that can be used to process these fields to work with various pagination patterns and other use cases.</source>
          <target state="translated">フィールドの中には、特にページ分割されたデータ用のものがありますが、以前に取得したデータを新しい情報にマージするために、クライアント側で後処理が必要になる場合があります。Relay Modernは、これらのフィールドを処理するために使用できるカスタムフィールドハンドラをサポートしており、さまざまなページ分割パターンやその他のユースケースに対応しています。</target>
        </trans-unit>
        <trans-unit id="adccc4f5e80b41c5617710fc459b4ed3934af747" translate="yes" xml:space="preserve">
          <source>Sometimes a parent needs to override the default variables of a child component. Imagine that we want to render &lt;code&gt;Child&lt;/code&gt; above with a photo size of 128 instead of the default 64. To do this, we have to ensure that both the fragment &lt;em&gt;and&lt;/em&gt; the container know about the custom variable. To set a custom variable in the &lt;em&gt;query&lt;/em&gt;, use the second argument to &lt;code&gt;getFragment&lt;/code&gt;:</source>
          <target state="translated">親が子コンポーネントのデフォルト変数をオーバーライドする必要がある場合があります。上記の &lt;code&gt;Child&lt;/code&gt; をデフォルトの64ではなく128の写真サイズでレンダリングするとします。これを行うには、フラグメント&lt;em&gt;と&lt;/em&gt;コンテナの両方がカスタム変数を認識していることを確認する必要があります。&lt;em&gt;クエリ&lt;/em&gt;でカスタム変数を設定するには、2番目の引数を &lt;code&gt;getFragment&lt;/code&gt; に使用し&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="e660d20bf684b576ae81f9c3a877a8d530b581ed" translate="yes" xml:space="preserve">
          <source>Source files</source>
          <target state="translated">ソースファイル</target>
        </trans-unit>
        <trans-unit id="2d309b4d42e0ad4602d00da88f45cac2d3d11a5e" translate="yes" xml:space="preserve">
          <source>Specify the data dependencies of a `Relay.Container` as GraphQL fragments.</source>
          <target state="translated">Relay.Container` のデータ依存関係を GraphQL のフラグメントとして指定する。</target>
        </trans-unit>
        <trans-unit id="21f0a8e08151b2997828c63fbaffbc197295bb3a" translate="yes" xml:space="preserve">
          <source>Specify the mutation field in a `Relay.Mutation`.</source>
          <target state="translated">リレー.Mutation`で突然変異フィールドを指定する。</target>
        </trans-unit>
        <trans-unit id="02293aef0bd0213bc1be111d67f416c9ddf1ebdf" translate="yes" xml:space="preserve">
          <source>Specify the queries of a `Relay.Route`.</source>
          <target state="translated">リレー.ルート`のクエリを指定する。</target>
        </trans-unit>
        <trans-unit id="8c5f40f02b986c2adaf7800c3005c0afdbaaab33" translate="yes" xml:space="preserve">
          <source>Start converting your components and mutations to use the Relay Modern APIs from the &lt;code&gt;'react-relay/compat'&lt;/code&gt; module (&lt;code&gt;createFragmentContainer&lt;/code&gt;, &lt;code&gt;createRefetchContainer&lt;/code&gt;, &lt;code&gt;createPaginationContainer&lt;/code&gt;, &lt;code&gt;commitMutation&lt;/code&gt;). It will be easier to go from the leaf components up. The &lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;conversion scripts&lt;/a&gt; should make this step less tedious.</source>
          <target state="translated">&lt;code&gt;'react-relay/compat'&lt;/code&gt; モジュール（ &lt;code&gt;createFragmentContainer&lt;/code&gt; 、 &lt;code&gt;createRefetchContainer&lt;/code&gt; 、 &lt;code&gt;createPaginationContainer&lt;/code&gt; 、 &lt;code&gt;commitMutation&lt;/code&gt; ）からRelay Modern APIを使用するようにコンポーネントとミューテーションを変換し始めます。リーフコンポーネントから上に行く方が簡単です。&lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;変換スクリプトは&lt;/a&gt;、このステップが少なく退屈にする必要があります。</target>
        </trans-unit>
        <trans-unit id="6a5813201a4580fe5f1fbb25f1a522d4d505bf2d" translate="yes" xml:space="preserve">
          <source>Static Methods</source>
          <target state="translated">静的メソッド</target>
        </trans-unit>
        <trans-unit id="49ff3956bbd054bfbc63e2eabd2a1088f21e282f" translate="yes" xml:space="preserve">
          <source>Step 0: Install Relay v1.0</source>
          <target state="translated">ステップ0:Relay v1.0のインストール</target>
        </trans-unit>
        <trans-unit id="95c2707d7e8702851af5473310f89fd4c5bfea2a" translate="yes" xml:space="preserve">
          <source>Step 1: Incrementally convert to Relay Compat</source>
          <target state="translated">ステップ1:リレー・コンパットへのインクリメンタル変換</target>
        </trans-unit>
        <trans-unit id="d071bae177457e9183feaf0fc474e9686b0260a4" translate="yes" xml:space="preserve">
          <source>Step 2: Introduce &amp;lt;QueryRenderer&amp;gt;</source>
          <target state="translated">ステップ2：&amp;lt;QueryRenderer&amp;gt;を導入する</target>
        </trans-unit>
        <trans-unit id="8176e519a1495162afbc0b02a0cc285793d9b9e6" translate="yes" xml:space="preserve">
          <source>Step 3: Introduce Relay Modern runtime</source>
          <target state="translated">ステップ3:リレーモダンのランタイムを導入</target>
        </trans-unit>
        <trans-unit id="5465ead3d787f346532f42480c386d4eba31fbae" translate="yes" xml:space="preserve">
          <source>Step 4: Clean up by replacing Relay Compat with Relay Modern.</source>
          <target state="translated">ステップ4:Relay CompatをRelay Modernに交換してきれいにする</target>
        </trans-unit>
        <trans-unit id="0d8a7046c8d39d9cbd86abcdfb704b161a601f9e" translate="yes" xml:space="preserve">
          <source>Store</source>
          <target state="translated">Store</target>
        </trans-unit>
        <trans-unit id="2e017d4c10eaa0f64c98ad2b1e9b9a9d85ad4822" translate="yes" xml:space="preserve">
          <source>Structure around mutations to make them predictable.</source>
          <target state="translated">突然変異を中心とした構造で予測可能にする</target>
        </trans-unit>
        <trans-unit id="5697fd85adbd13bf85f28712f9a136e80cc8067e" translate="yes" xml:space="preserve">
          <source>Subscriptions</source>
          <target state="translated">Subscriptions</target>
        </trans-unit>
        <trans-unit id="13a5b46568a2ea322aa7b25ac8f48a520783301a" translate="yes" xml:space="preserve">
          <source>Supported in both compat and modern mode. When using the pagination container, Relay expects the connection field to be annotated with &lt;code&gt;@connection&lt;/code&gt; directive, for more detailed information and example, please go to &lt;a href=&quot;pagination-container#connection-directive&quot;&gt;&lt;code&gt;PaginationContainer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">互換モードと最新モードの両方でサポートされています。ページネーションコンテナを使用する場合、Relayは接続フィールドに &lt;code&gt;@connection&lt;/code&gt; ディレクティブで注釈が付けられることを期待します。詳細と例については、&lt;a href=&quot;pagination-container#connection-directive&quot;&gt; &lt;code&gt;PaginationContainer&lt;/code&gt; に&lt;/a&gt;アクセスしてください。</target>
        </trans-unit>
        <trans-unit id="3ff1be67feaa88d4848ce4702f24046558ce5b24" translate="yes" xml:space="preserve">
          <source>Supported in classic, compat and modern mode. Detailed usage is explained in &lt;a href=&quot;api-reference-relay-ql#array-fields&quot;&gt;&lt;code&gt;Relay.QL&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">クラシックモード、互換モード、モダンモードでサポートされています。詳細な使用法は&lt;a href=&quot;api-reference-relay-ql#array-fields&quot;&gt; &lt;code&gt;Relay.QL&lt;/code&gt; &lt;/a&gt;で説明されています。</target>
        </trans-unit>
        <trans-unit id="65d6a8d5361414a2749b7b32500d3781b01e64c3" translate="yes" xml:space="preserve">
          <source>Sweet! Let's keep going and get the next four!</source>
          <target state="translated">いいね!このまま行って次の4つを手に入れよう!</target>
        </trans-unit>
        <trans-unit id="28e2c6a12e1af3dcd74179eb09b97b7b134beae3" translate="yes" xml:space="preserve">
          <source>Switch the &lt;code&gt;'react-relay/compat'&lt;/code&gt; references in your app to &lt;code&gt;'react-relay'&lt;/code&gt;. This is more of a clean-up step that prevents your app from pulling in unnecessary &lt;code&gt;'react-relay/classic'&lt;/code&gt; code.</source>
          <target state="translated">アプリの &lt;code&gt;'react-relay/compat'&lt;/code&gt; 参照を &lt;code&gt;'react-relay'&lt;/code&gt; 切り替えます。これは、アプリが不要な &lt;code&gt;'react-relay/classic'&lt;/code&gt; コードを引き込まないようにするためのクリーンアップ手順です。</target>
        </trans-unit>
        <trans-unit id="21d278837034557e7a9b46210d42d6e7b8075142" translate="yes" xml:space="preserve">
          <source>Terminology</source>
          <target state="translated">Terminology</target>
        </trans-unit>
        <trans-unit id="3965436aa1e25eb8c1a80de5c7180c888af16646" translate="yes" xml:space="preserve">
          <source>That input argument should contain a (string) &quot;clientMutationId&quot; property for the purposes of reconciling requests and responses (automatically added by the &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; API).</source>
          <target state="translated">その入力引数には、リクエストとレスポンスを調整するための（文字列） &quot;clientMutationId&quot;プロパティが含まれている必要があります（ &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; API によって自動的に追加されます）。</target>
        </trans-unit>
        <trans-unit id="56c0a2575be8f36ad7f5d4d04acffdd56aaaf9ea" translate="yes" xml:space="preserve">
          <source>That used the &lt;code&gt;first&lt;/code&gt; argument to &lt;code&gt;ships&lt;/code&gt; to slice the result set down to the first one. But what if we wanted to paginate through it? On each edge, a cursor will be exposed that we can use to paginate. Let's ask for the first two this time, and get the cursor as well:</source>
          <target state="translated">これは、結果セットを最初のものにスライスするために &lt;code&gt;ships&lt;/code&gt; する &lt;code&gt;first&lt;/code&gt; 引数を使用しました。しかし、それをページ分割したい場合はどうでしょうか。各エッジで、ページ付けに使用できるカーソルが表示されます。今回は最初の2つを要求して、カーソルも取得します。</target>
        </trans-unit>
        <trans-unit id="cdaffd6461c67e56056afce77a9bd307eee56aef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Node&lt;/code&gt; interface and &lt;code&gt;node&lt;/code&gt; field assume globally unique IDs for this refetching. A system without globally unique IDs can usually synthesize them by combining the type with the type-specific ID, which is what was done in this example.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; インタフェースと &lt;code&gt;node&lt;/code&gt; フィールドは、この再フェッチのグローバル一意のIDを前提としています。グローバルに一意のIDを持たないシステムは、通常、タイプをタイプ固有のIDと組み合わせることによってそれらを合成できます。これは、この例で行われたものです。</target>
        </trans-unit>
        <trans-unit id="4249e055d5de1ea8000faee39fa1425b4eb71404" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Node&lt;/code&gt; interface contains a single field, &lt;code&gt;id&lt;/code&gt;, which is a &lt;code&gt;ID!&lt;/code&gt;. The &lt;code&gt;node&lt;/code&gt; root field takes a single argument, a &lt;code&gt;ID!&lt;/code&gt;, and returns a &lt;code&gt;Node&lt;/code&gt;. These two work in concert to allow refetching; if we pass the &lt;code&gt;id&lt;/code&gt; returned in that field to the &lt;code&gt;node&lt;/code&gt; field, we get the object back.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; インタフェースは、単一のフィールドが含ま &lt;code&gt;id&lt;/code&gt; で、 &lt;code&gt;ID!&lt;/code&gt; 。 &lt;code&gt;node&lt;/code&gt; ルート・フィールドは、単一の引数、取り &lt;code&gt;ID!&lt;/code&gt; 、 &lt;code&gt;Node&lt;/code&gt; を返します。これら2つは協調して動作し、再フェッチを可能にします。そのフィールドで返された &lt;code&gt;id&lt;/code&gt; &lt;code&gt;node&lt;/code&gt; フィールドに渡すと、オブジェクトが返されます。</target>
        </trans-unit>
        <trans-unit id="69b82e1269cd3f5440edfdd8ab8e1cb4218f2a3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;applyUpdate&lt;/code&gt; adds a mutation just like &lt;code&gt;update&lt;/code&gt;, but does not commit it. It returns a &lt;code&gt;RelayMutationTransaction&lt;/code&gt; that can be committed or rollbacked.</source>
          <target state="translated">&lt;code&gt;applyUpdate&lt;/code&gt; は、同じように変異を追加 &lt;code&gt;update&lt;/code&gt; 、それをコミットしません。コミットまたはロールバックできる &lt;code&gt;RelayMutationTransaction&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="c8a27cee9d1d9abe2e77bcb0c575a4357ce66c14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;babel-relay-plugin&lt;/code&gt; must run before the &lt;code&gt;react-native&lt;/code&gt; Babel preset. Thus, in &lt;code&gt;.babelrc&lt;/code&gt;&lt;code&gt;&quot;react-native&quot;&lt;/code&gt; must come after &lt;code&gt;babelRelayPlugin&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;babel-relay-plugin&lt;/code&gt; 前に実行する必要があります &lt;code&gt;react-native&lt;/code&gt; バベルプリセット。したがって、 &lt;code&gt;.babelrc&lt;/code&gt; &lt;code&gt;&quot;react-native&quot;&lt;/code&gt; 、「react-native」は &lt;code&gt;babelRelayPlugin&lt;/code&gt; の後に来る必要があります。</target>
        </trans-unit>
        <trans-unit id="cf0346f82ced9502e9b07bb0b45a4c3bf97fc831" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;commitUpdate&lt;/code&gt; method is analogous to dispatching an action in Flux. Relay processes the mutation as follows:</source>
          <target state="translated">&lt;code&gt;commitUpdate&lt;/code&gt; 方法は、フラックス中にアクションをディスパッチに類似しています。リレーは次のように変異を処理します。</target>
        </trans-unit>
        <trans-unit id="5916376d8984ac32cb4ef4378494b52a513ccdde" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;react-relay&lt;/code&gt; npm module includes &lt;code&gt;react&lt;/code&gt; as a &lt;em&gt;peer dependency&lt;/em&gt;. Your app should specify React as a dependency explicitly.</source>
          <target state="translated">&lt;code&gt;react-relay&lt;/code&gt; NPMモジュールは、 &lt;code&gt;react&lt;/code&gt; ように&lt;em&gt;、ピア依存&lt;/em&gt;。アプリでは、Reactを依存関係として明示的に指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="687a2b2e72c0944702e22c85dfb54906ee9cc4a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;relay-compiler&lt;/code&gt; script requires both the directory which holds your source files as well as a path to your GraphQL schema in either a .json or .graphql schema file.</source>
          <target state="translated">&lt;code&gt;relay-compiler&lt;/code&gt; スクリプトは、ソースファイルを保持しているディレクトリだけでなく、.jsonまたは.graphqlスキーマファイルのいずれかでごGraphQLスキーマへのパスの両方が必要です。</target>
        </trans-unit>
        <trans-unit id="09a465866585d4ac0fa1f3ec8871e9ae5a93fc4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;renderFailure&lt;/code&gt; callback is called with two arguments: an &lt;code&gt;Error&lt;/code&gt; object and a function to retry the request. If the error was the result of a server error communicated in the server's response, the response payload is available for inspection on &lt;code&gt;error.source&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;renderFailure&lt;/code&gt; の：コールバックは2つの引数で呼び出される &lt;code&gt;Error&lt;/code&gt; オブジェクトと、要求を再試行する機能。エラーがサーバーの応答で伝えられたサーバーエラーの結果であった場合、応答ペイロードは &lt;code&gt;error.source&lt;/code&gt; で検査できます。</target>
        </trans-unit>
        <trans-unit id="3fec68a6615738a8b02b918d7e606ef06cece0ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;renderFetched&lt;/code&gt; callback is always called with a &lt;code&gt;data&lt;/code&gt; argument, which is an object mapping from &lt;code&gt;propName&lt;/code&gt; to query data. It is expected that the &lt;code&gt;renderFetched&lt;/code&gt; callback renders the supplied &lt;code&gt;Component&lt;/code&gt; with them (e.g. using the &lt;a href=&quot;https://facebook.github.io/react/docs/jsx-spread.html&quot;&gt;JSX spread attributes feature&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;renderFetched&lt;/code&gt; コールバックは常にと呼ばれている &lt;code&gt;data&lt;/code&gt; から、オブジェクトのマッピングである引数 &lt;code&gt;propName&lt;/code&gt; クエリデータへ。 &lt;code&gt;renderFetched&lt;/code&gt; コールバックは、指定された &lt;code&gt;Component&lt;/code&gt; をそれらとともにレンダリングすることが期待されます（たとえば、&lt;a href=&quot;https://facebook.github.io/react/docs/jsx-spread.html&quot;&gt;JSXスプレッド属性機能を使用&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="fc694dd64cc47d448a84516c45884dcebf08a20c" translate="yes" xml:space="preserve">
          <source>The API is overall simpler and more predictable.</source>
          <target state="translated">APIは全体的にシンプルで予測しやすいものになっています。</target>
        </trans-unit>
        <trans-unit id="a3270609e5596533f39e48f966bd5c2bc4660cc1" translate="yes" xml:space="preserve">
          <source>The DataID of the parent node that contains the connection. This argument is optional.</source>
          <target state="translated">接続を含む親ノードのDataID。この引数はオプションです。</target>
        </trans-unit>
        <trans-unit id="c4a8c9e60c4dd38c187162160297b7cec4fec7f9" translate="yes" xml:space="preserve">
          <source>The IDs we got back were base64 strings. IDs are designed to be opaque (the only thing that should be passed to the &lt;code&gt;id&lt;/code&gt; argument on &lt;code&gt;node&lt;/code&gt; is the unaltered result of querying &lt;code&gt;id&lt;/code&gt; on some object in the system), and base64ing a string is a useful convention in GraphQL to remind viewers that the string is an opaque identifier.</source>
          <target state="translated">返されたIDはbase64文字列でした。IDは不透明になるように設計されており（ &lt;code&gt;node&lt;/code&gt; の &lt;code&gt;id&lt;/code&gt; 引数に渡す必要があるのは、システム内のいくつかのオブジェクトの &lt;code&gt;id&lt;/code&gt; をクエリした結果が変更されないことだけです）、文字列をbase64化することは、GraphQLで便利な規則であり、 stringは不透明な識別子です。</target>
        </trans-unit>
        <trans-unit id="7450121d3a10cfde0d27fedec5e7487c759f4cef" translate="yes" xml:space="preserve">
          <source>The Relay &quot;Environment&quot;</source>
          <target state="translated">リレー &quot;環境&quot;</target>
        </trans-unit>
        <trans-unit id="29a5b8d00ca84a6ecf522b93deabead7921f8457" translate="yes" xml:space="preserve">
          <source>The Relay &quot;Environment&quot; bundles together the configuration, cache storage, and network-handling that Relay needs in order to operate.</source>
          <target state="translated">Relayの &quot;環境 &quot;には、Relayが動作するために必要な設定、キャッシュ・ストレージ、ネットワーク処理がまとめられています。</target>
        </trans-unit>
        <trans-unit id="04d65a89a2e8d48fa93bad9ecd0dc074fc69e421" translate="yes" xml:space="preserve">
          <source>The Relay &amp;quot;Environment&amp;quot;</source>
          <target state="translated">リレー「環境」</target>
        </trans-unit>
        <trans-unit id="ee388b82ec2168b63f7ecfa7840c723aabafb1e3" translate="yes" xml:space="preserve">
          <source>The Relay &lt;code&gt;Store&lt;/code&gt; provides an API for dispatching mutations to the server.</source>
          <target state="translated">リレー &lt;code&gt;Store&lt;/code&gt; は、サーバーにミューテーションをディスパッチするためのAPIを提供します。</target>
        </trans-unit>
        <trans-unit id="8f70d28e27ab15f03147076b8dda3030c0a0078e" translate="yes" xml:space="preserve">
          <source>The Relay Classic and Relay Compat modes produce generated content inline and may catch and log any detected GraphQL validation errors, leaving those errors to be thrown at runtime.</source>
          <target state="translated">Relay ClassicモードとRelay Compatモードでは、生成されたコンテンツをインラインで生成し、検出されたGraphQL検証エラーをキャッチしてログに記録します。</target>
        </trans-unit>
        <trans-unit id="b710564e5046fb16b4d54484e5bd00a02c1c71b3" translate="yes" xml:space="preserve">
          <source>The Relay Compiler is responsible for generating code as part of a build step which, at runtime, can be used statically. By building the query ahead of time, the client's JS runtime is not responsible for generating a query string, and fields that are duplicated in the query can be merged during the build step, to improve parsing efficiency. If you have the ability to persist queries to your server, the compiler's code generation process provides a convenient time to convert a query or mutation's text into a unique identifier, which greatly reduces the upload bytes required.</source>
          <target state="translated">Relayコンパイラは、ビルド・ステップの一部としてコードを生成し、実行時に静的に使用できるようにします。クエリを事前にビルドすることで、クライアントのJSランタイムがクエリ文字列の生成を担当しなくなり、クエリ内で重複しているフィールドをビルドステップ中にマージして解析効率を向上させることができます。サーバーにクエリを永続化する機能がある場合、コンパイラのコード生成プロセスは、クエリまたは突然変異のテキストを一意の識別子に変換するのに便利な時間を提供し、必要なアップロードバイトを大幅に削減します。</target>
        </trans-unit>
        <trans-unit id="63623a8a89bd3ad461c1fe2298a373e6892186d0" translate="yes" xml:space="preserve">
          <source>The Relay Modern Core adds support for client schema extensions. These allow Relay to conveniently store some extra information with data fetched from the server and be rendered like any other field fetched from the server. This should be able to replace some use cases that previously required a Flux/Redux store on the side.</source>
          <target state="translated">Relay Modern Coreでは、クライアントスキーマ拡張機能のサポートが追加されました。これにより、Relayはサーバーから取得したデータに追加情報を便利に保存し、サーバーから取得した他のフィールドと同じようにレンダリングすることができます。これにより、これまでFLUX/Reduxのサイドストアを必要としていたいくつかのユースケースを置き換えることができるようになります。</target>
        </trans-unit>
        <trans-unit id="d7d5ac1a62f052029edc67e6900f799b310cde67" translate="yes" xml:space="preserve">
          <source>The Relay Modern packages distributed on NPM use the widely-supported ES5 version of JavaScript to support as many browser environments as possible.</source>
          <target state="translated">NPMで配布されているRelay Modernパッケージは、広くサポートされているES5版のJavaScriptを使用しており、可能な限り多くのブラウザ環境に対応しています。</target>
        </trans-unit>
        <trans-unit id="3f35b4d76fe696a95341841f45e165e3b0c6aad8" translate="yes" xml:space="preserve">
          <source>The Relay Network Layer</source>
          <target state="translated">中継ネットワーク層</target>
        </trans-unit>
        <trans-unit id="d750d1085b7a107c9c036e90d472c451b5fb59af" translate="yes" xml:space="preserve">
          <source>The Relay runtime bundle is roughly 20% of the size of Relay Classic.</source>
          <target state="translated">Relayランタイムバンドルは、Relay Classicの約20%のサイズです。</target>
        </trans-unit>
        <trans-unit id="a2170027015b9ca88c5f922e040a93d95772d2c0" translate="yes" xml:space="preserve">
          <source>The Relay store can be mutated programatically in advanced edge cases when optimistic updates need more granular control. The following API methods are useful for mutating your connections and fragments.</source>
          <target state="translated">楽観的な更新でより詳細な制御が必要な場合、高度なエッジケースでは、Relayストアをプログラム的に変異させることができます。以下のAPIメソッドは、接続やフラグメントを変更するのに便利です。</target>
        </trans-unit>
        <trans-unit id="0adc8d247f24c64744fe2ba30ece6da8fd08a649" translate="yes" xml:space="preserve">
          <source>The author of this story also commented on it &amp;mdash; quite common. Now imagine that some other view fetches new information about the author, and her profile photo has changed to a new URI. Here's the &lt;em&gt;only&lt;/em&gt; part of our cached data that changes:</source>
          <target state="translated">この物語の作者もそれにコメントしました-非常に一般的です。ここで、他のビューが作成者に関する新しい情報をフェッチし、彼女のプロフィール写真が新しいURIに変更されたとします。ここだ&lt;em&gt;だけ&lt;/em&gt;変更し、当社のキャッシュされたデータの一部は：</target>
        </trans-unit>
        <trans-unit id="980a4b6788111d51d4fd5d3c6e5054ad267e5ae0" translate="yes" xml:space="preserve">
          <source>The best way to get started right now is to take a look at how these three parts come together to form a working example. The tutorial on the next page will lead you through an example application, using the &lt;a href=&quot;https://github.com/facebook/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt;, to give you an idea of how you can start using Relay on yours.</source>
          <target state="translated">今すぐ始めるための最良の方法は、これらの3つの部分がどのように組み合わさって実際の例を形成するかを確認することです。次のページのチュートリアルでは、&lt;a href=&quot;https://github.com/facebook/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt;を使用したサンプルアプリケーションを紹介し、Relayの使用を開始する方法を示します。</target>
        </trans-unit>
        <trans-unit id="5bc022d566f4b68dd38c73222756f331714be645" translate="yes" xml:space="preserve">
          <source>The client and server are decoupled: the client specifies the data needed instead of &lt;em&gt;relying on&lt;/em&gt; the server endpoint to return the correct data.</source>
          <target state="translated">クライアントとサーバーは分離されています。クライアントは、正しいデータを返すためにサーバーのエンドポイントに&lt;em&gt;依存するので&lt;/em&gt;はなく、必要なデータを指定します。</target>
        </trans-unit>
        <trans-unit id="00a902f03306b6ea1e1e2818025625742f4e212c" translate="yes" xml:space="preserve">
          <source>The component-based approach of React Router v4 does not readily allow for aggregating the data requirements for nested routes, and as such does not readily permit an approach that will avoid request waterfalls from nesting &lt;code&gt;QueryRenderer&lt;/code&gt; components.</source>
          <target state="translated">React Router v4のコンポーネントベースのアプローチでは、ネストされたルートのデータ要件を簡単に集約できません。そのため、リクエストウォーターフォールが &lt;code&gt;QueryRenderer&lt;/code&gt; コンポーネントをネストしないようにするアプローチは簡単には許可されません。</target>
        </trans-unit>
        <trans-unit id="7298679167473c58332d417e6d2bd4de9988163d" translate="yes" xml:space="preserve">
          <source>The container &amp;mdash; named &lt;code&gt;Relay(ProfilePicture)&lt;/code&gt; for debugging &amp;mdash; will retrieve the response for each GraphQL fragment from the local store.</source>
          <target state="translated">コンテナ &lt;code&gt;Relay(ProfilePicture)&lt;/code&gt; デバッグ用にRelay（ProfilePicture）という名前）は、ローカルストアから各GraphQLフラグメントの応答を取得します。</target>
        </trans-unit>
        <trans-unit id="d147ef4301d6fa557024d99f96f08a499bbc3a4a" translate="yes" xml:space="preserve">
          <source>The container passes the results of each fragment (along with the other props) to the &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; component.</source>
          <target state="translated">コンテナーは、各フラグメントの結果を（他のプロップと共に） &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; コンポーネントに渡します。</target>
        </trans-unit>
        <trans-unit id="268b06824cede0c427a01e0d80dbe18daf1354c3" translate="yes" xml:space="preserve">
          <source>The default implementation is as follows:</source>
          <target state="translated">デフォルトの実装は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="bf32b3124e1516fba4edb1784393b843530e0823" translate="yes" xml:space="preserve">
          <source>The defaults we specify here will become available to our fragment builders:</source>
          <target state="translated">ここで指定したデフォルト値は、フラグメントビルダーが利用できるようになります。</target>
        </trans-unit>
        <trans-unit id="fe89d1880c282b0f84f7ad747dcf711ed35e9199" translate="yes" xml:space="preserve">
          <source>The easiest way to get started for now is with the &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt; - this includes an example schema file and configures the &lt;a href=&quot;https://www.npmjs.com/package/babel-relay-plugin&quot;&gt;&lt;code&gt;babel-relay-plugin&lt;/code&gt;&lt;/a&gt; npm module to transpile queries.</source>
          <target state="translated">とりあえず開始する最も簡単な方法は、&lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt;を使用することです。これにはサンプルスキーマファイルが含まれ、クエリをトランスパイルするように&lt;a href=&quot;https://www.npmjs.com/package/babel-relay-plugin&quot;&gt; &lt;code&gt;babel-relay-plugin&lt;/code&gt; &lt;/a&gt; npmモジュールを構成します。</target>
        </trans-unit>
        <trans-unit id="ef9027831057a9dfdeaac970a51f94ff44007267" translate="yes" xml:space="preserve">
          <source>The example above did not configure a &lt;code&gt;handlerProvider&lt;/code&gt;, which means that a default one will be provided. Relay Modern comes with a couple of built-in handlers that augment the core with special functionality for handling connections (which is not a standard GraphQL feature, but a set of pagination conventions used at Facebook, specified in detail in the &lt;a href=&quot;graphql-connections&quot;&gt;Relay Cursor Connections Specification&lt;/a&gt;, and well-supported by Relay itself) and the &lt;code&gt;viewer&lt;/code&gt; field (again, not a standard GraphQL schema feature, but one which has been conventionally used extensively within Facebook).</source>
          <target state="translated">上記の例では、 &lt;code&gt;handlerProvider&lt;/code&gt; を構成していません。つまり、デフォルトのものが提供されます。 Relay Modernには、接続を処理するための特別な機能（標準のGraphQL機能ではなく、&lt;a href=&quot;graphql-connections&quot;&gt;Relay Cursor Connections Specification&lt;/a&gt;で詳細に指定されているFacebookで使用されるページ付け規則のセット）でコアを強化する2つの組み込みハンドラーが付属しています。そして、Relay自体によって十分にサポートされています）および &lt;code&gt;viewer&lt;/code&gt; フィールド（これも、標準のGraphQLスキーマ機能ではありませんが、従来Facebook内で広く使用されている機能です）。</target>
        </trans-unit>
        <trans-unit id="4657e52da9059d7f3c2e9423e8542337bf25d573" translate="yes" xml:space="preserve">
          <source>The example above is very similar to the classic container API, but in the modern API we can just pass the &lt;code&gt;graphql&lt;/code&gt; template literal directly as the second argument. Relay will infer the prop name from the fragment name according to the fragment naming convention &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt;. The example below is equivalent to the one above:</source>
          <target state="translated">上記の例は、クラシックコンテナーAPIによく似ていますが、最新のAPIでは、 &lt;code&gt;graphql&lt;/code&gt; テンプレートリテラルを2番目の引数として直接渡すことができます。リレーは、フラグメントの命名規則 &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; に従って、フラグメント名からプロップ名を推測します。以下の例は、上記の例と同等です。</target>
        </trans-unit>
        <trans-unit id="1d30073e8f5f3cb9668f92d3d480a82b915306f9" translate="yes" xml:space="preserve">
          <source>The fat query</source>
          <target state="translated">太ったクエリ</target>
        </trans-unit>
        <trans-unit id="9eb6dbc6b6ef5c5d8b4847ee0b1b967260b02889" translate="yes" xml:space="preserve">
          <source>The field name in the response that contains the DataID of the deleted node</source>
          <target state="translated">削除されたノードのDataIDを含むレスポンスのフィールド名</target>
        </trans-unit>
        <trans-unit id="3ca688eaa1e1f955641e421703e810ed047c2005" translate="yes" xml:space="preserve">
          <source>The field name in the response that contains the DataID of the removed node, or the path to the node removed from the connection</source>
          <target state="translated">レスポンス内のフィールド名で、削除されたノードのDataID、または接続から削除されたノードへのパスを含みます。</target>
        </trans-unit>
        <trans-unit id="ba191931e9ab489b27a9f33f746bef212888dc1a" translate="yes" xml:space="preserve">
          <source>The field name in the response that represents the connection</source>
          <target state="translated">接続を表すレスポンスのフィールド名</target>
        </trans-unit>
        <trans-unit id="a1b90e077151b889c8402ab5f53851a0ff440462" translate="yes" xml:space="preserve">
          <source>The field name in the response that represents the newly created edge</source>
          <target state="translated">新しく作成されたエッジを表すレスポンスのフィールド名</target>
        </trans-unit>
        <trans-unit id="f9886e317b707740faab57f9ea8a72831a041943" translate="yes" xml:space="preserve">
          <source>The field name in the response that represents the parent of the connection</source>
          <target state="translated">接続の親を表すレスポンスのフィールド名。</target>
        </trans-unit>
        <trans-unit id="9edac1a03bde2552ba82cb38e1a432234c65b349" translate="yes" xml:space="preserve">
          <source>The final data declaration is equivalent to the following plain GraphQL:</source>
          <target state="translated">最終的なデータ宣言は、以下のプレーンGraphQLと同等です。</target>
        </trans-unit>
        <trans-unit id="cfe19d046a9f42c5d948f0aa018690d7ab173c0c" translate="yes" xml:space="preserve">
          <source>The first query was for a list of stories:</source>
          <target state="translated">最初の問い合わせは、ネタの羅列でした。</target>
        </trans-unit>
        <trans-unit id="0d313c5be837c1f0e863c8d541edf651d250cb38" translate="yes" xml:space="preserve">
          <source>The initial set of variable values available to this component's fragments.</source>
          <target state="translated">このコンポーネントのフラグメントで利用可能な変数値の初期セット。</target>
        </trans-unit>
        <trans-unit id="f7e74d01f7e6ff80db2700d9894a53e56b4a4d76" translate="yes" xml:space="preserve">
          <source>The most-used function is &lt;a href=&quot;#createcontainer-static-method&quot;&gt;&lt;code&gt;createContainer()&lt;/code&gt;&lt;/a&gt; which wraps components with data declarations.</source>
          <target state="translated">最も使用される関数は、データ宣言でコンポーネントをラップする&lt;a href=&quot;#createcontainer-static-method&quot;&gt; &lt;code&gt;createContainer()&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="6618aeb6f5361bcac94a3181ad8b6a8339b0abc1" translate="yes" xml:space="preserve">
          <source>The mutation should take a single argument named &quot;input&quot;.</source>
          <target state="translated">突然変異は、&quot;input &quot;という名前の単一の引数を取らなければなりません。</target>
        </trans-unit>
        <trans-unit id="a3c29d0940ced0048c0feb3200ee57be78138845" translate="yes" xml:space="preserve">
          <source>The new Relay Modern core is more light-weight and significantly faster than the previous version. It is redesigned to work with static queries, which allow us to push more work to build/compilation time. The Modern core is much smaller as a result of removing a lot of the complex features required for dynamic queries. The new core is also an order of magnitude faster in processing the response with an optimized parsing instruction set that is generated at build time. We no longer keep around tracking information needed for dynamic query generation, which drastically reduces the memory overhead of using Relay. This means more memory is left for making the UI feel responsive. Relay Modern also supports persisted queries, reducing the upload size of the request from the full query text to a simple id.</source>
          <target state="translated">新しいRelay Modernコアは、前バージョンよりも軽量化され、大幅に高速化されています。静的なクエリで動作するように再設計されているため、より多くの作業をビルド/コンパイル時間に押し込めるようになっています。ダイナミッククエリに必要な複雑な機能の多くを削除した結果、Modernコアは大幅に小型化されました。新しいコアは、ビルド時に生成される最適化された解析命令セットを使用してレスポンスを処理する際にも、桁違いに速くなっています。動的クエリの生成に必要なトラッキング情報を保持しておく必要がなくなり、Relayを使用する際のメモリオーバーヘッドが大幅に削減されました。つまり、UIの応答性を向上させるために、より多くのメモリを確保できるということです。Relay Modernは永続クエリもサポートしており、リクエストのアップロードサイズを完全なクエリテキストからシンプルなidに削減しています。</target>
        </trans-unit>
        <trans-unit id="bfe2b2be8025972db06fd439006437e8dca5cc49" translate="yes" xml:space="preserve">
          <source>The next logical approach is to use &lt;code&gt;render()&lt;/code&gt; as the means of initiating data-fetching. We could simply render the application once, see what data it needed, fetch that data, and render again. This sounds great, but the problem is that &lt;em&gt;components use data to figure out what to render!&lt;/em&gt; In other words, this would force data-fetching to be staged: first render the root and see what data it needs, then render its children and see what they need, all the way down the tree. If each stage incurs network request, rendering would require slow, serial roundtrips. We needed a way to determine all the data needs up-front or &lt;em&gt;statically&lt;/em&gt;.</source>
          <target state="translated">次の論理的なアプローチは、データのフェッチを開始する手段として &lt;code&gt;render()&lt;/code&gt; を使用することです。アプリケーションを一度レンダリングして、必要なデータを確認し、そのデータをフェッチして、再度レンダリングするだけです。これはすばらしいように聞こえますが、問題は&lt;em&gt;コンポーネントがデータを使用して何をレンダリングするかを理解することです！&lt;/em&gt;言い換えると、これによりデータフェッチが強制的にステージングされます。最初にルートをレンダリングして必要なデータを確認し、次にその子をレンダリングして必要なものをツリー全体で確認します。各ステージでネットワーク要求が発生した場合、レンダリングには低速のシリアルラウンドトリップが必要になります。すべてのデータのニーズを&lt;em&gt;事前&lt;/em&gt;または&lt;em&gt;静的&lt;/em&gt;に判断する方法が必要でした。</target>
        </trans-unit>
        <trans-unit id="5b53cde5515b59c4d3a0131621b4782b7479a272" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;config&lt;/code&gt; parameter can be used to configure a &lt;code&gt;RANGE_ADD&lt;/code&gt; or other type of mutation, as per the &lt;code&gt;Relay.Mutation&lt;/code&gt; API. This tells Relay how to process the response.</source>
          <target state="translated">オプションの &lt;code&gt;config&lt;/code&gt; パラメータが設定するために使用することができます &lt;code&gt;RANGE_ADD&lt;/code&gt; あたりとして、または変異の他のタイプを &lt;code&gt;Relay.Mutation&lt;/code&gt; の API。これは、Relayに応答を処理する方法を伝えます。</target>
        </trans-unit>
        <trans-unit id="3043696978b404d79349bb97fe99dc6847323bfb" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;config&lt;/code&gt; parameter can be used to configure a &lt;code&gt;RANGE_ADD&lt;/code&gt; or other type of mutation, similar to the &lt;code&gt;Relay.Mutation&lt;/code&gt; API.</source>
          <target state="translated">オプションの &lt;code&gt;config&lt;/code&gt; パラメータを設定するために使用することができます &lt;code&gt;RANGE_ADD&lt;/code&gt; かに類似の変異の他のタイプ、 &lt;code&gt;Relay.Mutation&lt;/code&gt; の APIを。</target>
        </trans-unit>
        <trans-unit id="a65fc26cbbecf69c5a0fe03882c96f57450485e1" translate="yes" xml:space="preserve">
          <source>The options listed above are not exhaustive. If you are aware of other routing solutions that work well with Relay Modern, &lt;a href=&quot;https://github.com/facebook/relay/issues/new&quot;&gt;please let us know&lt;/a&gt;.</source>
          <target state="translated">上記のオプションは完全ではありません。Relay Modernで適切に機能する他のルーティングソリューションをご存知の場合は、&lt;a href=&quot;https://github.com/facebook/relay/issues/new&quot;&gt;お知らせください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e4e5487396fd07e7501191686f068ec10dba2a30" translate="yes" xml:space="preserve">
          <source>The pagination container expects the connection field to be annotated with a &lt;code&gt;@connection(key: ...)&lt;/code&gt; directive, where the &lt;code&gt;key&lt;/code&gt; is expected to be a unique identifier under the parent field type &lt;code&gt;User&lt;/code&gt;. A good practice could be &lt;code&gt;&amp;lt;ComponentName&amp;gt;_&amp;lt;fieldName | fieldAlias&amp;gt;&lt;/code&gt;. By default, Relay generates storage key based on the user-supplied &lt;code&gt;key&lt;/code&gt; and all non-filter variables of the field. Relay also provides an advanced feature &lt;code&gt;@connection(key: 'FriendsList_friends', filters:['orderBy', ...])&lt;/code&gt; that allows you to explicitly specify which variables should be used to generate the storage key. Particularly, if you write &lt;code&gt;@connection(key: ..., filters:[])&lt;/code&gt;, Relay will ignore all the variables.</source>
          <target state="translated">ページ設定コンテナは、接続フィールドに &lt;code&gt;@connection(key: ...)&lt;/code&gt; ディレクティブで注釈が付けられることを想定してい &lt;code&gt;key&lt;/code&gt; は、親フィールドタイプ &lt;code&gt;User&lt;/code&gt; の下の一意の識別子であることが想定されています。良い練習は可能性があり &lt;code&gt;&amp;lt;ComponentName&amp;gt;_&amp;lt;fieldName | fieldAlias&amp;gt;&lt;/code&gt; 。デフォルトでは、Relayはユーザー指定の &lt;code&gt;key&lt;/code&gt; とフィールドのすべての非フィルター変数に基づいてストレージキーを生成します。 Relay には、ストレージキーの生成に使用する変数を明示的に指定できる高度な機能 &lt;code&gt;@connection(key: 'FriendsList_friends', filters:['orderBy', ...])&lt;/code&gt; も用意されています。特に、 &lt;code&gt;@connection(key: ..., filters:[])&lt;/code&gt; と書いた場合、Relayはすべての変数を無視します。</target>
        </trans-unit>
        <trans-unit id="c30fe4d3ed3c530120fea7a2dc37c47a35768d8b" translate="yes" xml:space="preserve">
          <source>The plugin needs to understand your schema - &lt;code&gt;schemaData&lt;/code&gt; in the above snippet. There are two ways to get this information, depending on the GraphQL implementation.</source>
          <target state="translated">プラグインはスキーマを理解する必要があります- 上記のスニペットの &lt;code&gt;schemaData&lt;/code&gt; 。GraphQLの実装に応じて、この情報を取得する方法は2つあります。</target>
        </trans-unit>
        <trans-unit id="486acc4ff0b4938f682801c80ee8b2d7dd1df93e" translate="yes" xml:space="preserve">
          <source>The premise of the example is that we want to use GraphQL to query for information about ships and factions in the original Star Wars trilogy.</source>
          <target state="translated">この例の前提として、オリジナルのスター・ウォーズ3部作に登場する船や派閥に関する情報をGraphQLを使ってクエリしたいと考えています。</target>
        </trans-unit>
        <trans-unit id="1d83274a567a8154b4431388aa9d20ca339eaa3b" translate="yes" xml:space="preserve">
          <source>The primary way to declare data requirements is via &lt;code&gt;Relay.Container&lt;/code&gt; &amp;mdash; a higher-order React component that lets React components encode their data requirements.</source>
          <target state="translated">データ要件を宣言する主な方法は、 &lt;code&gt;Relay.Container&lt;/code&gt; &amp;mdash; Reactコンポーネントがデータ要件をエンコードできるようにする高次のReactコンポーネントを使用することです。</target>
        </trans-unit>
        <trans-unit id="808db6b1b18bc85b64f9d26f1bddf44bf5968046" translate="yes" xml:space="preserve">
          <source>The primary way to declare data requirements is via &lt;code&gt;createFragmentContainer&lt;/code&gt; &amp;mdash; a higher-order React component that lets React components encode their data requirements.</source>
          <target state="translated">データ要件を宣言する主な方法は、 &lt;code&gt;createFragmentContainer&lt;/code&gt; &amp;mdash; Reactコンポーネントがデータ要件をエンコードできるようにする高次のReactコンポーネントを使用することです。</target>
        </trans-unit>
        <trans-unit id="444774c5f652cc1826eed622e4a92e2c3f0e2e4b" translate="yes" xml:space="preserve">
          <source>The properties and methods listed below can be accessed on &lt;code&gt;this.props.relay&lt;/code&gt; from the wrapped React component.</source>
          <target state="translated">下記のプロパティとメソッドは、ラップされたReactコンポーネントから &lt;code&gt;this.props.relay&lt;/code&gt; でアクセスできます。</target>
        </trans-unit>
        <trans-unit id="595d44efe5adb2587c5aa09916b466fe64246e19" translate="yes" xml:space="preserve">
          <source>The query should request &quot;clientMutationId&quot; as a subselection.</source>
          <target state="translated">クエリは、サブセレクションとして &quot;clientMutationId &quot;を要求する必要があります。</target>
        </trans-unit>
        <trans-unit id="fcd6ab3548bb5d3b4f5a6f857ba30959f05237cb" translate="yes" xml:space="preserve">
          <source>The reasoning is that if &lt;code&gt;babel-plugin-relay&lt;/code&gt; does not run before the &lt;code&gt;es2015-template-literals&lt;/code&gt; transform, it will not transform the Relay.QL template literals correctly. Also in Babel 6, you can&amp;rsquo;t control plugin order. So in React Native, where plugins in &lt;code&gt;.babelrc&lt;/code&gt; are loaded before the projects &lt;code&gt;.babelrc&lt;/code&gt;, it&amp;rsquo;s impossible to use the Babel Relay Plugin without overriding the entire transform list.</source>
          <target state="translated">推論は、 &lt;code&gt;es2015-template-literals&lt;/code&gt; 変換の前に &lt;code&gt;babel-plugin-relay&lt;/code&gt; が実行されない場合、Relay.QLテンプレートリテラルを正しく変換しないためです。また、Babel 6ではプラグインの順序を制御できません。そのため、 &lt;code&gt;.babelrc&lt;/code&gt; のプラグインがプロジェクト &lt;code&gt;.babelrc&lt;/code&gt; の前にロードされるReact Nativeでは、変換リスト全体をオーバーライドしないとBabel Relayプラグインを使用できません。</target>
        </trans-unit>
        <trans-unit id="7803dad9067c5d50b3b4bf3ebacbfaade89ec277" translate="yes" xml:space="preserve">
          <source>The runtime automatically removes cached data that is no longer referenced, helping to reduce memory usage.</source>
          <target state="translated">ランタイムは、参照されなくなったキャッシュされたデータを自動的に削除し、メモリ使用量の削減に役立ちます。</target>
        </trans-unit>
        <trans-unit id="7502725bdbb2c17f80ff460d7924092be097b33c" translate="yes" xml:space="preserve">
          <source>The schema described below will be used to demonstrate the functionality that a GraphQL server used by Relay should implement. The two core types are a faction and a ship in the Star Wars universe, where a faction has many ships associated with it. The schema below is the output of the GraphQL.js &lt;a href=&quot;https://github.com/graphql/graphql-js/blob/master/src/utilities/schemaPrinter.js&quot;&gt;&lt;code&gt;schemaPrinter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">以下で説明するスキーマは、Relayで使用されるGraphQLサーバーが実装する機能を示すために使用されます。2つのコアタイプは、派閥とスターウォーズユニバースの船で、派閥には多数の船が関連付けられています。以下のスキーマは、GraphQL.js &lt;a href=&quot;https://github.com/graphql/graphql-js/blob/master/src/utilities/schemaPrinter.js&quot;&gt; &lt;code&gt;schemaPrinter&lt;/code&gt; の&lt;/a&gt;出力です。</target>
        </trans-unit>
        <trans-unit id="d1f4549e3c6f019d48ff8e76296ba821ef51f0c7" translate="yes" xml:space="preserve">
          <source>The second query refetched the information for one of those stories:</source>
          <target state="translated">2番目のクエリは、それらの物語の1つの情報を再設定しました。</target>
        </trans-unit>
        <trans-unit id="e1ce127879727af2e2de7fc1ce77bce3c4f43c30" translate="yes" xml:space="preserve">
          <source>The solution to caching GraphQL is to normalize the hierarchical response into a flat collection of &lt;strong&gt;records&lt;/strong&gt;. Relay implements this cache as a map from IDs to records. Each record is a map from field names to field values. Records may also link to other records (allowing it to describe a cyclic graph), and these links are stored as a special value type that references back into the top-level map. With this approach each server record is stored &lt;em&gt;once&lt;/em&gt; regardless of how it is fetched.</source>
          <target state="translated">GraphQLをキャッシュする解決策は、階層的な応答を&lt;strong&gt;レコードの&lt;/strong&gt;フラットなコレクションに正規化することです。Relayは、このキャッシュをIDからレコードへのマップとして実装します。各レコードは、フィールド名からフィールド値へのマップです。レコードは他のレコードにリンクすることもでき（循環グラフを記述できるようにします）、これらのリンクはトップレベルのマップを参照する特別な値タイプとして保存されます。このアプローチでは、フェッチ方法に関係なく、各サーバーレコードが&lt;em&gt;一度&lt;/em&gt;保存されます。</target>
        </trans-unit>
        <trans-unit id="2238db3c2972a72399f41299cdb2bb500270de90" translate="yes" xml:space="preserve">
          <source>The term &amp;lsquo;variables&amp;rsquo; here refers to the input to the server-side mutation, &lt;strong&gt;not&lt;/strong&gt; to the variables made available to this mutation's fragment builders.</source>
          <target state="translated">ここで「変数」という用語は、サーバーサイドミューテーションへの入力を指し、このミューテーションのフラグメントビルダーが利用できるようにする変数を指すのではあり&lt;strong&gt;ません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="595203acdb212fda1237b7e11b4700b733a663ad" translate="yes" xml:space="preserve">
          <source>The three core assumptions that Relay makes about a GraphQL server are that it provides:</source>
          <target state="translated">RelayがGraphQLサーバについての3つの核心的な前提として挙げているのは、「提供する」ということです。</target>
        </trans-unit>
        <trans-unit id="80a872fa92f56ed5c31e04d7d32ff502b8f3fab1" translate="yes" xml:space="preserve">
          <source>The two methods differ in that instead of sending a query that includes only fields missing from the client, &lt;code&gt;forceFetch&lt;/code&gt; sends a request to refetch each and every fragment. This ensures that the props for the component are freshly fetched from the server.</source>
          <target state="translated">2つのメソッドは、クライアントから欠落しているフィールドのみを含むクエリを送信する代わりに、 &lt;code&gt;forceFetch&lt;/code&gt; がすべてのフラグメントを再フェッチするリクエストを送信するという点で異なります。これにより、コンポーネントのプロパティがサーバーから新たにフェッチされます。</target>
        </trans-unit>
        <trans-unit id="1c4c5b50dcdfa847760bbbedcf52cb8e2ff536e6" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;photo&lt;/code&gt; field has changed; and therefore the record &lt;code&gt;2&lt;/code&gt; has also changed. And that's it. Nothing else in the &lt;em&gt;cache&lt;/em&gt; is affected. But clearly our &lt;em&gt;view&lt;/em&gt; needs to reflect the update: both instances of the author in the UI (as story author and comment author) need to show the new photo.</source>
          <target state="translated">&lt;code&gt;photo&lt;/code&gt; フィールドの値が変更されました。したがって、レコード &lt;code&gt;2&lt;/code&gt; も変更されています。以上です。&lt;em&gt;キャッシュ&lt;/em&gt;内の他のものは影響を受けません。ただし、&lt;em&gt;ビューに&lt;/em&gt;は更新を反映する必要があります。UI内の作成者の両方のインスタンス（ストーリー作成者およびコメント作成者として）は、新しい写真を表示する必要があります。</target>
        </trans-unit>
        <trans-unit id="1232b961ddf31ef587aaa3e408f8aa3d44030a8f" translate="yes" xml:space="preserve">
          <source>Then after making edits to your application files, just run &lt;code&gt;yarn run relay&lt;/code&gt; to generate new files, or &lt;code&gt;yarn run relay -- --watch&lt;/code&gt; to run the compiler as a long-lived process which automatically generates new files whenever you save.</source>
          <target state="translated">次に、アプリケーションファイルを編集した後、 &lt;code&gt;yarn run relay&lt;/code&gt; を実行して新しいファイルを生成するか、 &lt;code&gt;yarn run relay -- --watch&lt;/code&gt; を実行して、保存するたびに新しいファイルを自動的に生成する長期間有効なプロセスとしてコンパイラーを実行します。</target>
        </trans-unit>
        <trans-unit id="ef73d50cc222b2377dc0c600080db66496266f2f" translate="yes" xml:space="preserve">
          <source>Then after making edits to your application files, run &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql&lt;/code&gt; to generate new files, or &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql --watch&lt;/code&gt; to run the compiler as a long-lived process which automatically generates new files whenever you save.</source>
          <target state="translated">次に、アプリケーションファイルを編集した後、 &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql&lt;/code&gt; を実行して新しいファイルを生成するか、 &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql --watch&lt;/code&gt; は、保存するたびに新しいファイルを自動的に生成する長期間有効なプロセスとしてコンパイラを実行します。</target>
        </trans-unit>
        <trans-unit id="57a1f5033c269a68bc8794dc199b363a5c20cf8b" translate="yes" xml:space="preserve">
          <source>Then run &lt;code&gt;yarn run relay&lt;/code&gt; as set up before.</source>
          <target state="translated">次に、前に設定した &lt;code&gt;yarn run relay&lt;/code&gt; を実行します。</target>
        </trans-unit>
        <trans-unit id="45b952755c02df6dff5e78f4c86d5e7d04e71f78" translate="yes" xml:space="preserve">
          <source>Then, add &lt;code&gt;&quot;relay&quot;&lt;/code&gt; to the list of plugins in your .babelrc file. For example:</source>
          <target state="translated">次に、.babelrcファイルのプラグインのリストに &lt;code&gt;&quot;relay&quot;&lt;/code&gt; を追加します。例えば：</target>
        </trans-unit>
        <trans-unit id="fa043b2e7bb17a1863151534669a087d81a912d9" translate="yes" xml:space="preserve">
          <source>There are a variety of solutions for keeping views up to date with a flattened cache. The approach that Relay takes is to maintain a mapping from each UI view to the set of IDs it references. In this case, the story view would subscribe to updates on the story (&lt;code&gt;1&lt;/code&gt;), the author (&lt;code&gt;2&lt;/code&gt;), and the comments (&lt;code&gt;3&lt;/code&gt; and any others). When writing data into the cache, Relay tracks which IDs are affected and notifies &lt;em&gt;only&lt;/em&gt; the views that are subscribed to those IDs. The affected views re-render, and unaffected views opt-out of re-rendering for better performance (Relay provides a safe but effective default &lt;code&gt;shouldComponentUpdate&lt;/code&gt;). Without this strategy, every view would re-render for even the tiniest change.</source>
          <target state="translated">フラット化されたキャッシュを使用してビューを最新の状態に保つためのさまざまなソリューションがあります。 Relayが採用するアプローチは、各UIビューから参照する一連のIDへのマッピングを維持することです。この場合、ストーリービューは、ストーリー（ &lt;code&gt;1&lt;/code&gt; ）、作成者（ &lt;code&gt;2&lt;/code&gt; ）、コメント（ &lt;code&gt;3&lt;/code&gt; およびその他）の更新をサブスクライブします。キャッシュにデータを書き込むとき、Relayは影響を受けるIDを追跡し、それらのIDにサブスクライブしているビュー&lt;em&gt;のみ&lt;/em&gt;に通知します。影響を受けるビューは再レンダリングされ、影響を受けないビューはパフォーマンスを向上させるために再レンダリングをオプトアウトします（リレーは安全ですが効果的なデフォルトの &lt;code&gt;shouldComponentUpdate&lt;/code&gt; を提供します）。この戦略がなければ、すべてのビューがごくわずかな変化でも再レンダリングされます。</target>
        </trans-unit>
        <trans-unit id="19964f32b18bdaa18426e6241372ad8f6c37030a" translate="yes" xml:space="preserve">
          <source>There is currently only one supported way to set the initial value of a variable dynamically: using global variables defined on the query that includes the fragment (or via &lt;code&gt;variables&lt;/code&gt; on the &lt;code&gt;QueryRenderer&lt;/code&gt;).</source>
          <target state="translated">現在、変数の初期値を動的に設定するためにサポートされている方法は1つだけです。フラグメントを含むクエリで定義されたグローバル変数を使用する（または &lt;code&gt;QueryRenderer&lt;/code&gt; の &lt;code&gt;variables&lt;/code&gt; を使用する）。</target>
        </trans-unit>
        <trans-unit id="7009a3cd68807292f00dff361667a386bda72fff" translate="yes" xml:space="preserve">
          <source>Therefore, a normalized response cache for GraphQL requires processing payloads and queries in parallel. For example, the &lt;code&gt;photo&lt;/code&gt; field from above might be cached with a generated field name such as &lt;code&gt;photo_size(32)&lt;/code&gt; in order to uniquely identify the field and its argument values.</source>
          <target state="translated">したがって、GraphQLの正規化された応答キャッシュでは、ペイロードとクエリを並行して処理する必要があります。たとえば、上記の &lt;code&gt;photo&lt;/code&gt; フィールドは、フィールドとその引数値を一意に識別するために、 &lt;code&gt;photo_size(32)&lt;/code&gt; などの生成されたフィールド名でキャッシュされる場合があります。</target>
        </trans-unit>
        <trans-unit id="046164a952e067900ed0105204b38b9650fcea6c" translate="yes" xml:space="preserve">
          <source>These are the methods and properties that the container will provide as &lt;code&gt;this.props.relay&lt;/code&gt; in the plain React component.</source>
          <target state="translated">これらは、プレーンなReactコンポーネントの &lt;code&gt;this.props.relay&lt;/code&gt; としてコンテナーが提供するメソッドとプロパティです。</target>
        </trans-unit>
        <trans-unit id="5c8268547e740fb58d6875a6309af54d22de03e8" translate="yes" xml:space="preserve">
          <source>These features can be used in a couple of common scenarios: logging the client state for later inspection or interactively poking around the store from your browser's debugger.</source>
          <target state="translated">これらの機能はいくつかの一般的なシナリオで使用することができます:クライアントの状態を後で検査するためにログに記録したり、ブラウザのデバッガからインタラクティブにストアを覗いたりすることができます。</target>
        </trans-unit>
        <trans-unit id="1195afffc2435cbe5e7dac1ec74b6de7550b1719" translate="yes" xml:space="preserve">
          <source>Thinking In Relay</source>
          <target state="translated">リレーで考える</target>
        </trans-unit>
        <trans-unit id="9e48341865426d82a3f397c5e1d57bc38bb5c5ba" translate="yes" xml:space="preserve">
          <source>Thinking in GraphQL</source>
          <target state="translated">グラフQLで考える</target>
        </trans-unit>
        <trans-unit id="587e48e73d1fbcb3548410dad36aa1874f0eaaf5" translate="yes" xml:space="preserve">
          <source>This callback prop is called as the various events of data resolution occur.</source>
          <target state="translated">このコールバックプロップは、データ解決の様々なイベントが発生したときに呼び出されます。</target>
        </trans-unit>
        <trans-unit id="83089afd24bef13575f73fb96b2667f2399b79e8" translate="yes" xml:space="preserve">
          <source>This callback prop is called as the various events of data resolution occurs.</source>
          <target state="translated">このコールバックプロップは、データ解決の様々なイベントが発生した際に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="a79b5038ef8c2e765648d6ba19aa3760d3f3486d" translate="yes" xml:space="preserve">
          <source>This can be upgraded by conditionally rendering a &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt; which will load the data once it is rendered. The code overhead of doing this is dramatically reduced with the new API.</source>
          <target state="translated">これは、データがレンダリングされるとデータをロードする&lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt;を条件付きでレンダリングすることによってアップグレードできます。これを行うコードオーバーヘッドは、新しいAPIで劇的に削減されます。</target>
        </trans-unit>
        <trans-unit id="6aa6b4ce32c479ca8e376d46b66428bac2d82d69" translate="yes" xml:space="preserve">
          <source>This can be upgraded by using a &lt;a href=&quot;refetch-container&quot;&gt;&lt;code&gt;RefetchContainer&lt;/code&gt;&lt;/a&gt; which allows you to specify the exact query to use to fetch the new data.</source>
          <target state="translated">これは、新しいデータをフェッチするために使用する正確なクエリを指定できる&lt;a href=&quot;refetch-container&quot;&gt; &lt;code&gt;RefetchContainer&lt;/code&gt; &lt;/a&gt;を使用してアップグレードできます。</target>
        </trans-unit>
        <trans-unit id="0fa24150c2aafefe95a09ecc07832206180f13d5" translate="yes" xml:space="preserve">
          <source>This causes a generated file to appear in &lt;code&gt;./__generated__/MyComponent.graphql&lt;/code&gt;, with both runtime artifacts (which help to read and write from the Relay Store) and &lt;a href=&quot;https://flow.org/&quot;&gt;Flow types&lt;/a&gt; to help you write type-safe code.</source>
          <target state="translated">これにより、生成されたファイルが &lt;code&gt;./__generated__/MyComponent.graphql&lt;/code&gt; に表示され、ランタイムアーティファクト（リレーストアからの読み取りと書き込みに役立ちます）と&lt;a href=&quot;https://flow.org/&quot;&gt;フロータイプがタイプ&lt;/a&gt;セーフコードの記述に役立ちます。</target>
        </trans-unit>
        <trans-unit id="74dbf4caec721ba1ccc2a6b88d7ee594184d8bbc" translate="yes" xml:space="preserve">
          <source>This example demonstrates all three of these assumptions.</source>
          <target state="translated">この例では、これらの3つの前提条件をすべて示しています。</target>
        </trans-unit>
        <trans-unit id="9479e9ba5c11bcfea7c69c38843fdeb8dbbdfea5" translate="yes" xml:space="preserve">
          <source>This example is not comprehensive, but it is designed to quickly introduce these core assumptions, to provide some context before diving into the more detailed specification of the library.</source>
          <target state="translated">この例は包括的なものではありませんが、ライブラリのより詳細な仕様に飛び込む前に、これらのコアとなる仮定を素早く導入し、ある程度の文脈を提供するように設計されています。</target>
        </trans-unit>
        <trans-unit id="f185525936893aacea00cf71a3224c86985f3df6" translate="yes" xml:space="preserve">
          <source>This fat query looks like any other GraphQL query, with one important distinction. We know some of these fields to be non-scalar (like &lt;code&gt;friendEdge&lt;/code&gt; and &lt;code&gt;friends&lt;/code&gt;) but notice that we have not named any of their children by way of a subquery. In this way, we indicate to Relay that &lt;em&gt;anything&lt;/em&gt; under those non-scalar fields may change as a result of this mutation.</source>
          <target state="translated">このファットクエリは、他のGraphQLクエリと似ていますが、重要な違いが1つあります。これらのフィールドの一部は非スカラーであることはわかっていますが（ &lt;code&gt;friendEdge&lt;/code&gt; や &lt;code&gt;friends&lt;/code&gt; など）、サブクエリを使用してそれらの子に名前を付けていないことに注意してください。この方法で、これらの非スカラーフィールドの下にあるものは&lt;em&gt;すべて&lt;/em&gt;、この突然変異の結果として変更される可能性があることをリレーに示します。</target>
        </trans-unit>
        <trans-unit id="61564f3549d718187ddfeb22e3808eafa802c07e" translate="yes" xml:space="preserve">
          <source>This gets converted into a &quot;lazy&quot; require of a generated file:</source>
          <target state="translated">これは、生成されたファイルの「遅延」要求に変換されます。</target>
        </trans-unit>
        <trans-unit id="ea59f490525a696053dec758108ce2a68882aa64" translate="yes" xml:space="preserve">
          <source>This gets converted into an immediately-invoked function:</source>
          <target state="translated">これは即効性のある機能に変換されます。</target>
        </trans-unit>
        <trans-unit id="01abddd8ac86ef6eb75568464191008b4ca72daa" translate="yes" xml:space="preserve">
          <source>This installs the bin script &lt;code&gt;relay-compiler&lt;/code&gt; in your node_modules folder. It's recommended to run this from a yarn/npm script by adding a script to your &lt;code&gt;package.json&lt;/code&gt; file:</source>
          <target state="translated">これにより、binスクリプト &lt;code&gt;relay-compiler&lt;/code&gt; がnode_modulesフォルダーにインストールされます。 &lt;code&gt;package.json&lt;/code&gt; ファイルにスクリプトを追加して、yarn / npmスクリプトからこれを実行することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="11a6b3482924983de73327e990f1793b755a9291" translate="yes" xml:space="preserve">
          <source>This is a specialization of the general-purpose refetch container that is tailored for the common scenario of paginating through a collection of items by fetching successively more pages of data. See &lt;a href=&quot;pagination-container&quot;&gt;&lt;code&gt;createPaginationContainer&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">これは、より多くのページのデータを連続してフェッチすることによってアイテムのコレクションをページ分割するという一般的なシナリオに合わせて調整された、汎用の再フェッチコンテナーの特殊化です。詳細については、&lt;a href=&quot;pagination-container&quot;&gt; &lt;code&gt;createPaginationContainer&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d4db8c43d3a16c260f2c767a658dfa356471e9a7" translate="yes" xml:space="preserve">
          <source>This is an array of events received so far (see &lt;code&gt;ReadyStateEvent&lt;/code&gt; below).</source>
          <target state="translated">これは、これまでに受信したイベントの配列です（以下の &lt;code&gt;ReadyStateEvent&lt;/code&gt; を参照）。</target>
        </trans-unit>
        <trans-unit id="4d0129df19cfd202bd9745fb3f722df875299901" translate="yes" xml:space="preserve">
          <source>This is an instance of &lt;code&gt;Error&lt;/code&gt; if there is a failure. Otherwise, this is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">これは、 &lt;code&gt;Error&lt;/code&gt; が発生した場合のエラーのインスタンスです。それ以外の場合、これは &lt;code&gt;null&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="69752386ee76a26381a40e623b5c2ca8480c36c2" translate="yes" xml:space="preserve">
          <source>This is only a simple example: in reality the cache must handle one-to-many associations and pagination (among other things).</source>
          <target state="translated">これは単純な例に過ぎません:実際にはキャッシュは一対多の関連付けとページ分割を処理しなければなりません (他のものとの間で)。</target>
        </trans-unit>
        <trans-unit id="7b3c087bb51f2da841015c33dcb71977fe0212c4" translate="yes" xml:space="preserve">
          <source>This is the general constructor for creating &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; instances with optional &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;callbacks&lt;/code&gt; and &lt;code&gt;collisionKey&lt;/code&gt; arguments.</source>
          <target state="translated">これは、オプションの &lt;code&gt;files&lt;/code&gt; 、 &lt;code&gt;callbacks&lt;/code&gt; 、 &lt;code&gt;collisionKey&lt;/code&gt; 引数を使用して &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; インスタンスを作成するための一般的なコンストラクターです。</target>
        </trans-unit>
        <trans-unit id="ab97009210eccb9f3d5c90eae312fb3cfd66a060" translate="yes" xml:space="preserve">
          <source>This is the lowest level of abstraction at which product code may deal with mutations in Relay, and it corresponds to the mutation operation (&quot;a write followed by a fetch&quot;) described in &lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;the GraphQL Specification&lt;/a&gt;. You specify the mutation, the inputs, and the query.</source>
          <target state="translated">これは、製品コードがRelayのミュー&lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;テーションを&lt;/a&gt;処理できる最低レベルの抽象化であり、GraphQL仕様で説明されているミューテーション操作（「書き込みとそれに続くフェッチ」）に対応しています。ミューテーション、入力、クエリを指定します。</target>
        </trans-unit>
        <trans-unit id="71da35a87d2df91e0c17e3a05dce16632307fd68" translate="yes" xml:space="preserve">
          <source>This is true when &lt;em&gt;all&lt;/em&gt; data requirements are ready for rendering.</source>
          <target state="translated">これは、&lt;em&gt;すべての&lt;/em&gt;データ要件がレンダリングの準備ができている場合に当てはまります。</target>
        </trans-unit>
        <trans-unit id="bb078cd30db73d188c6edca1d054b3822d3838fd" translate="yes" xml:space="preserve">
          <source>This is true when the subset of data required for rendering is ready.</source>
          <target state="translated">これは、レンダリングに必要なデータのサブセットが準備できている場合に真です。</target>
        </trans-unit>
        <trans-unit id="40d6df25c7774cfef7c19fa68f7bcd72dbf71d40" translate="yes" xml:space="preserve">
          <source>This may be helpful to reduce redundant fragments when dealing with nested or recursive data within a single Component.</source>
          <target state="translated">これは、単一のコンポーネント内でネストされたデータや再帰的なデータを扱う際に、冗長なフラグメントを減らすのに役立つかもしれません。</target>
        </trans-unit>
        <trans-unit id="7d2596643eab3080985621c3e255ffe66dd1fb15" translate="yes" xml:space="preserve">
          <source>This method can optionally return a promise in order to facilitate proper error propagation.</source>
          <target state="translated">このメソッドは、適切なエラーの伝播を容易にするために、オプションでプロミスを返すことができます。</target>
        </trans-unit>
        <trans-unit id="a5a0085a036246ce072609380ef834dd25b9e599" translate="yes" xml:space="preserve">
          <source>This method is also called after the partial set of variables from &lt;code&gt;setVariables&lt;/code&gt; has been applied. The variables returned are used to populate the fragments.</source>
          <target state="translated">このメソッドは、 &lt;code&gt;setVariables&lt;/code&gt; からの変数の部分セットが適用された後にも呼び出されます。返された変数は、フラグメントを生成するために使用されます。</target>
        </trans-unit>
        <trans-unit id="0603bfcf101a33a1c1eed64335628df20ea3aa9c" translate="yes" xml:space="preserve">
          <source>This method receives an array of queries (instead of a single query) in order to facilitate batching queries to improve network efficiency.</source>
          <target state="translated">このメソッドは、ネットワーク効率を向上させるためにクエリのバッチ処理を容易にするために、(単一のクエリではなく)クエリの配列を受信します。</target>
        </trans-unit>
        <trans-unit id="a87ccc42db63f2f52eeae29ff4feceb34933d42f" translate="yes" xml:space="preserve">
          <source>This should be upgraded to use a &lt;a href=&quot;pagination-container&quot;&gt;&lt;code&gt;PaginationContainer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pagination-container&quot;&gt; &lt;code&gt;PaginationContainer&lt;/code&gt; &lt;/a&gt;を使用するには、これをアップグレードする必要があります。</target>
        </trans-unit>
        <trans-unit id="a7bf020a941d10f70ab32528d56d8597a05d0895" translate="yes" xml:space="preserve">
          <source>This snippet configures &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; to render &lt;code&gt;ProfilePicture&lt;/code&gt; within a &lt;code&gt;ScrollView&lt;/code&gt; component as soon as data is ready.</source>
          <target state="translated">このスニペットは、データの準備ができるとすぐに &lt;code&gt;ScrollView&lt;/code&gt; コンポーネント内で &lt;code&gt;ProfilePicture&lt;/code&gt; をレンダリングするように&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;を構成します。</target>
        </trans-unit>
        <trans-unit id="70500d59ecc10d7cea4a148a7386cb41d2c4d0f0" translate="yes" xml:space="preserve">
          <source>This snippet configures &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; to render the &quot;Loading...&quot; text whenever it needs to fetch data.</source>
          <target state="translated">このスニペットは、&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;がデータをフェッチする必要があるときに「Loading ...」テキストをレンダリングするように構成します。</target>
        </trans-unit>
        <trans-unit id="00b1b28bd3be2fa7e76055fd5d3f672dc5d7fda8" translate="yes" xml:space="preserve">
          <source>This will create a series of &lt;code&gt;__generated__&lt;/code&gt; directories that are co-located with the corresponding files containing &lt;code&gt;graphql&lt;/code&gt; tags.</source>
          <target state="translated">これにより、 &lt;code&gt;graphql&lt;/code&gt; タグを含む対応するファイルと同じ場所に配置される一連の &lt;code&gt;__generated__&lt;/code&gt; ディレクトリが作成されます。</target>
        </trans-unit>
        <trans-unit id="a737ccc7b583949623cef676beba937c7dc28a69" translate="yes" xml:space="preserve">
          <source>This will inform &lt;code&gt;Relay.QL&lt;/code&gt; that this particular field is an array. This will also allow you to use a plural name for the fragment (i.e. &lt;code&gt;bars&lt;/code&gt; instead of &lt;code&gt;bar&lt;/code&gt;).</source>
          <target state="translated">これにより、 &lt;code&gt;Relay.QL&lt;/code&gt; に、この特定のフィールドが配列であることを通知します。これはまた、フラグメントのために複数の名前（つまり、使用できるようになります &lt;code&gt;bars&lt;/code&gt; の代わりに、 &lt;code&gt;bar&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2dcccc952811069ad73564d196e2e6f3b0ec664d" translate="yes" xml:space="preserve">
          <source>This would produce three generated files, and two &lt;code&gt;__generated__&lt;/code&gt; directories:</source>
          <target state="translated">これにより、3つの生成ファイルと2つの &lt;code&gt;__generated__&lt;/code&gt; ディレクトリが生成されます。</target>
        </trans-unit>
        <trans-unit id="0e7c9a4f20eb8494e45f8c514abfa27440507df5" translate="yes" xml:space="preserve">
          <source>To add a new paginating relay container</source>
          <target state="translated">新しいページングリレーコンテナを追加するには</target>
        </trans-unit>
        <trans-unit id="4afe3d419de5a0a7685601e4998733289b1a991a" translate="yes" xml:space="preserve">
          <source>To add a new relay container</source>
          <target state="translated">新しいリレーコンテナを追加するには</target>
        </trans-unit>
        <trans-unit id="da88d2c6beb30dbb3f7e5c35d288e84155365752" translate="yes" xml:space="preserve">
          <source>To add a new relay container that has changing data requirements</source>
          <target state="translated">データ要件が変更された新しいリレーコンテナを追加するには</target>
        </trans-unit>
        <trans-unit id="b78283d8fe106afc67ec588e2762311c4df0a3bd" translate="yes" xml:space="preserve">
          <source>To add a new root for relay components</source>
          <target state="translated">リレー部品の新しいルートを追加するには</target>
        </trans-unit>
        <trans-unit id="2cb466b85716cc24434b2a68c68d7668bbaceabb" translate="yes" xml:space="preserve">
          <source>To call this method on the underlying component, first provide a &lt;code&gt;componentRef&lt;/code&gt; function to the Relay container. This differs from providing a &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/a&gt; function which would provide a reference to the Relay container itself, not the underlying React Component.</source>
          <target state="translated">基礎となるコンポーネントでこのメソッドを呼び出すには、最初に、relayコンテナに &lt;code&gt;componentRef&lt;/code&gt; 関数を提供します。これは、基になるReactコンポーネントではなく、リレーコンテナー自体への参照を提供する&lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt; &lt;code&gt;ref&lt;/code&gt; &lt;/a&gt;関数を提供することとは異なります。</target>
        </trans-unit>
        <trans-unit id="65aa58a75ec1e39e9166d34dcff5d186dbe23e3a" translate="yes" xml:space="preserve">
          <source>To commit a mutation</source>
          <target state="translated">突然変異をコミットするには</target>
        </trans-unit>
        <trans-unit id="89b06193bd6c9ce7d1f792c95362915c77c9675f" translate="yes" xml:space="preserve">
          <source>To create an environment instance in Relay Modern, use the &lt;code&gt;RelayModernEnvironment&lt;/code&gt; class:</source>
          <target state="translated">Relay Modernで環境インスタンスを作成するには、 &lt;code&gt;RelayModernEnvironment&lt;/code&gt; クラスを使用します。</target>
        </trans-unit>
        <trans-unit id="79a86851c1fad2bbe848185a0d8955e026baa0f4" translate="yes" xml:space="preserve">
          <source>To enable &lt;a href=&quot;relay-compat&quot;&gt;compatibility mode&lt;/a&gt;, &lt;code&gt;relay-compiler&lt;/code&gt; enforces a simple naming convention for your queries. Queries must be named as &lt;code&gt;&amp;lt;FileName&amp;gt;&amp;lt;OperationType&amp;gt;&lt;/code&gt;, where &quot;&amp;lt;OperationType&amp;gt;&quot; is one of &quot;Query&quot;, &quot;Mutation&quot;, or &quot;Subscription&quot;. The query above is named &lt;code&gt;ExampleQuery&lt;/code&gt; so should be placed in &lt;code&gt;Example.js&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;relay-compat&quot;&gt;互換モード&lt;/a&gt;を有効にするために、 &lt;code&gt;relay-compiler&lt;/code&gt; はクエリに単純な命名規則を適用します。クエリの名前は &lt;code&gt;&amp;lt;FileName&amp;gt;&amp;lt;OperationType&amp;gt;&lt;/code&gt; である必要があります。ここで、「&amp;lt;OperationType&amp;gt;」は「Query」、「Mutation」、または「Subscription」のいずれかです。上記のクエリは &lt;code&gt;ExampleQuery&lt;/code&gt; という名前なので、 &lt;code&gt;Example.js&lt;/code&gt; に配置する必要があります。</target>
        </trans-unit>
        <trans-unit id="03ec37246eca3b43ea7ac7f76a27cbf7c5cb3d8b" translate="yes" xml:space="preserve">
          <source>To execute this code, Relay needs access to the schema - which can be too large to bundle inside the application. Instead, these &lt;code&gt;Relay.QL&lt;/code&gt; template expressions are transpiled into JavaScript descriptions via the &lt;code&gt;babel-relay-plugin&lt;/code&gt;. This schema information allows Relay to understand things like the types of field arguments, which fields are connections or lists, and how to efficiently refetch records from the server.</source>
          <target state="translated">このコードを実行するには、Relayがスキーマにアクセスする必要があります。スキーマが大きすぎて、アプリケーション内にバンドルできない場合があります。代わりに、これらの &lt;code&gt;Relay.QL&lt;/code&gt; テンプレート式は、 &lt;code&gt;babel-relay-plugin&lt;/code&gt; を介してJavaScript記述に変換されます。このスキーマ情報により、Relayはフィールド引数のタイプ、接続またはリストであるフィールド、サーバーからレコードを効率的に再フェッチする方法などを理解できます。</target>
        </trans-unit>
        <trans-unit id="6be87ed7f838f24ecfdb363ea58800de8f9dfbc1" translate="yes" xml:space="preserve">
          <source>To force fetch a component</source>
          <target state="translated">コンポーネントを強制的に取得するには</target>
        </trans-unit>
        <trans-unit id="e7e54aa101836df2ce7d5415960a239df67598f0" translate="yes" xml:space="preserve">
          <source>To get started building Relay applications, you will need three things:</source>
          <target state="translated">Relayアプリケーションの構築を始めるには、以下の3つのものが必要です。</target>
        </trans-unit>
        <trans-unit id="2cf9a932987c095688d86461efe0eedbdc22d8b7" translate="yes" xml:space="preserve">
          <source>To improve perceived responsiveness, you may wish to perform an &quot;optimistic update&quot;, in which the client immediately updates to reflect the anticipated new value even before the response from the server has come back. We do this by providing an &lt;code&gt;optimisticResponse&lt;/code&gt; and adding it to the &lt;code&gt;config&lt;/code&gt; that we pass into &lt;code&gt;commitMutation&lt;/code&gt;:</source>
          <target state="translated">知覚される応答性を改善するために、サーバーからの応答が返ってくる前であっても、クライアントがすぐに更新して予期される新しい値を反映する「楽観的更新」を実行することができます。我々は提供することで、これを行う &lt;code&gt;optimisticResponse&lt;/code&gt; をし、それを追加 &lt;code&gt;config&lt;/code&gt; 、我々は中に入ることを &lt;code&gt;commitMutation&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bebfedde59ec9253c14e34d042772cb6d964fce0" translate="yes" xml:space="preserve">
          <source>To paginate through a connection</source>
          <target state="translated">接続を介してページングするには</target>
        </trans-unit>
        <trans-unit id="b6033100545414ff9dedc545a14635be362e73ed" translate="yes" xml:space="preserve">
          <source>To read from the cache we can walk a query and resolve each field. But wait: that sounds &lt;em&gt;exactly&lt;/em&gt; like what a GraphQL server does when it processes a query. And it is! Reading from the cache is a special case of an executor where a) there's no need for user-defined field functions because all results come from a fixed data structure and b) results are always synchronous &amp;mdash; we either have the data cached or we don't.</source>
          <target state="translated">キャッシュから読み取るには、クエリを実行して各フィールドを解決します。しかし、待ってください。それは、GraphQLサーバーがクエリを処理するときに行うことと&lt;em&gt;まったく同じ&lt;/em&gt;ように聞こえます。そしてそうです！キャッシュからの読み取りは、a）すべての結果が固定データ構造から取得されるためユーザー定義のフィールド関数が不要であり、b）結果が常に同期している、エグゼキューターの特殊なケースです。データは常にキャッシュされているか、キャッシュされているかt。</target>
        </trans-unit>
        <trans-unit id="e168ce7f96f9f96537f762eb07d59ca6c422e92d" translate="yes" xml:space="preserve">
          <source>To start, let's build the plain React version of a &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; component that displays the user's profile photo and a slider to adjust the photo's size.</source>
          <target state="translated">まず、ユーザーのプロフィール写真と写真のサイズを調整するためのスライダーを表示する &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; コンポーネントのプレーンなReactバージョンを作成してみましょう。</target>
        </trans-unit>
        <trans-unit id="fccbd6622bb8847d0929fc4851e9ea2b575ead73" translate="yes" xml:space="preserve">
          <source>To start, let's build the plain React version of a &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; component that displays the text and completion status of a &lt;code&gt;Todo&lt;/code&gt;.</source>
          <target state="translated">まず、 &lt;code&gt;Todo&lt;/code&gt; のテキストと完了ステータスを表示する &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; コンポーネントのプレーンなReactバージョンを作成しましょう。</target>
        </trans-unit>
        <trans-unit id="11ddeec9a3447606ae9ab043cf0ed78d26a53e7b" translate="yes" xml:space="preserve">
          <source>To update a variable for my component</source>
          <target state="translated">コンポーネントの変数を更新するには</target>
        </trans-unit>
        <trans-unit id="3f1189857789cd58adacaebeec728b8e0afcce44" translate="yes" xml:space="preserve">
          <source>To use the Relay Compiler, you need either a .graphql or .json GraphQL schema file, describing your GraphQL server's API. Typically these files are local representations of a server source of truth and are not edited directly. For example, we might have a &lt;code&gt;schema.graphql&lt;/code&gt; like:</source>
          <target state="translated">リレーコンパイラを使用するには、GraphQLサーバーのAPIを記述した.graphqlまたは.json GraphQLスキーマファイルが必要です。通常、これらのファイルはサーバーの真実のソースのローカル表現であり、直接編集されません。たとえば、 &lt;code&gt;schema.graphql&lt;/code&gt; ようなschema.graphqlがあるとします。</target>
        </trans-unit>
        <trans-unit id="9be854f285feec3a5f3620acb9820d1d2c32fbd0" translate="yes" xml:space="preserve">
          <source>To use these pieces to construct a full-fledged GraphQL query that we can send to the server to fetch data, we need to use the &lt;strong&gt;Relay.RootContainer&lt;/strong&gt;.</source>
          <target state="translated">これらの部分を使用して、サーバーに送信してデータをフェッチできる本格的なGraphQLクエリを作成するには、&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="f77a5658e80339ebafab29498f8ee4b43724b2e0" translate="yes" xml:space="preserve">
          <source>Typical Relay Classic code:</source>
          <target state="translated">典型的なリレー・クラシック・コード。</target>
        </trans-unit>
        <trans-unit id="95e39abda529007d77cea645d9c98a79ceba0779" translate="yes" xml:space="preserve">
          <source>Typical old code:</source>
          <target state="translated">典型的な古いコード。</target>
        </trans-unit>
        <trans-unit id="5ea4501b4b61baf5dd246de000e69cf2c83ec128" translate="yes" xml:space="preserve">
          <source>Typically you will not need to import your generated definitions. The &lt;a href=&quot;babel-plugin-relay&quot;&gt;Relay Babel plugin&lt;/a&gt; will convert the &lt;code&gt;graphql&lt;/code&gt; literals to &lt;code&gt;require()&lt;/code&gt; the generated files.</source>
          <target state="translated">通常、生成された定義をインポートする必要はありません。&lt;a href=&quot;babel-plugin-relay&quot;&gt;リレーバベルプラグインが&lt;/a&gt;変換されます &lt;code&gt;graphql&lt;/code&gt; リテラルがする &lt;code&gt;require()&lt;/code&gt; 生成されたファイルを。</target>
        </trans-unit>
        <trans-unit id="43a4e34531ca0764965880501d0f8c89a74d18d5" translate="yes" xml:space="preserve">
          <source>Underneath the hood, the default network layer uses &lt;code&gt;fetch&lt;/code&gt; (&lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;Living Standard&lt;/a&gt;). The constructor for &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt; takes an optional second argument that accepts any valid initialization property that &lt;code&gt;fetch&lt;/code&gt; accepts.</source>
          <target state="translated">内部では、デフォルトのネットワークレイヤーは &lt;code&gt;fetch&lt;/code&gt; （&lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;Living Standard&lt;/a&gt;）を使用します。コンストラクタ &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt; は、任意の有効な初期化プロパティ受け入れるオプションの第二引数取り &lt;code&gt;fetch&lt;/code&gt; 受け入れを。</target>
        </trans-unit>
        <trans-unit id="b2498fd787926326020b483e3523f960c30e4f9d" translate="yes" xml:space="preserve">
          <source>Unlike queries, failed requests for mutations are not automatically retried.</source>
          <target state="translated">クエリとは異なり、突然変異に対する失敗したリクエストは自動的に再試行されません。</target>
        </trans-unit>
        <trans-unit id="fa7f90794261c83159eb4a91e2dfe23661dee9e6" translate="yes" xml:space="preserve">
          <source>Up until this point we have only interacted with the GraphQL endpoint to perform queries that fetch data. In this guide, you will learn how to use Relay to perform mutations &amp;ndash; operations that consist of writes to the data store followed by a fetch of any changed fields.</source>
          <target state="translated">ここまでは、データをフェッチするクエリを実行するためにGraphQLエンドポイントとのみ対話しました。このガイドでは、Relayを使用して変更（データストアへの書き込みと、それに続く変更されたフィールドのフェッチで構成される操作）を実行する方法を学習します。</target>
        </trans-unit>
        <trans-unit id="f2d05363c2e81a266183ca6ef8b7bd0bdbd8b278" translate="yes" xml:space="preserve">
          <source>Updates the records associated with a mutable record, transversing the source by field name and an object representing pre-defined argument values.</source>
          <target state="translated">フィールド名と事前に定義された引数値を表すオブジェクトによってソースを横切って、変更可能なレコードに関連付けられたレコードを更新します。</target>
        </trans-unit>
        <trans-unit id="77357ed1c74dd26c490773b79c9c64db80714ee8" translate="yes" xml:space="preserve">
          <source>Updates the value of a mutable record's attribute given by the field name and an object representing pre-defined argument values.</source>
          <target state="translated">フィールド名とあらかじめ定義された引数の値を表すオブジェクトによって与えられたミュータブルレコードの属性の値を更新します。</target>
        </trans-unit>
        <trans-unit id="130a5ea1f38180314e9b7e8d2e0c0f8791af7800" translate="yes" xml:space="preserve">
          <source>Updating the client on each response</source>
          <target state="translated">各レスポンスのクライアントへの更新</target>
        </trans-unit>
        <trans-unit id="9c5f928161eaee0e6b37f9f04f9b99fffe3258b5" translate="yes" xml:space="preserve">
          <source>Updating the client optimistically</source>
          <target state="translated">クライアントを楽観的に更新する</target>
        </trans-unit>
        <trans-unit id="683610f0bd36453d03467df7a76f50661ef6f8ac" translate="yes" xml:space="preserve">
          <source>Updating the local cache after receiving query/mutation responses.</source>
          <target state="translated">クエリ/ミューテーション応答を受信した後、ローカルキャッシュを更新します。</target>
        </trans-unit>
        <trans-unit id="5cbc715352505bf09eed712fc8faa91711d9dd6f" translate="yes" xml:space="preserve">
          <source>Updating the store programatically (advanced)</source>
          <target state="translated">ストアをプログラム的に更新する (上級)</target>
        </trans-unit>
        <trans-unit id="b03854fc017532ee497460390d8d2a3a98701a8a" translate="yes" xml:space="preserve">
          <source>Upgrade to react-relay v1.0.0</source>
          <target state="translated">react-relay v1.0.0へのアップグレード</target>
        </trans-unit>
        <trans-unit id="6f683dd933be22f58cc623c7fb6049182ce19997" translate="yes" xml:space="preserve">
          <source>Upgrading setVariables</source>
          <target state="translated">setVariablesのアップグレード</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="855b7cdc9a7b7eedbbade3460ffda75d84c0215a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;introspectionQuery&lt;/code&gt; to generate a Schema JSON for the Babel Relay Plugin, and use &lt;code&gt;printSchema&lt;/code&gt; to generate a user readable type system shorthand:</source>
          <target state="translated">&lt;code&gt;introspectionQuery&lt;/code&gt; を使用してBabel RelayプラグインのスキーマJSON を生成し、 &lt;code&gt;printSchema&lt;/code&gt; を使用してユーザーが読み取り可能な型システムの省略表現を生成します。</target>
        </trans-unit>
        <trans-unit id="9c04ab0245abf53d950383b659bb519121fdf39c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;graphql&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;graphql&lt;/code&gt; の使用</target>
        </trans-unit>
        <trans-unit id="dc3790d0260968db930a9c68e2f92f666400ec99" translate="yes" xml:space="preserve">
          <source>Using Other GraphQL Implementations</source>
          <target state="translated">他の GraphQL 実装を使用する</target>
        </trans-unit>
        <trans-unit id="ce363e86e1227248ffe7c0ac61d5dfa9beb38f62" translate="yes" xml:space="preserve">
          <source>Using The Cache</source>
          <target state="translated">キャッシュの使用</target>
        </trans-unit>
        <trans-unit id="7cc52f33aee5330befcd51c2b80f9fac7ea6a7af" translate="yes" xml:space="preserve">
          <source>Using during conversion in &quot;&lt;a href=&quot;relay-compat&quot;&gt;compatibility mode&lt;/a&gt;&quot;</source>
          <target state="translated">「&lt;a href=&quot;relay-compat&quot;&gt;互換モード&lt;/a&gt;」で変換中に使用する</target>
        </trans-unit>
        <trans-unit id="4ca24372752ba964092860cbbff37a07dae71dd0" translate="yes" xml:space="preserve">
          <source>Using with Relay Classic</source>
          <target state="translated">リレークラシックとの併用</target>
        </trans-unit>
        <trans-unit id="f72b74b27018bdf2391222dafa0211db62f72ce0" translate="yes" xml:space="preserve">
          <source>View composition is &lt;em&gt;exactly&lt;/em&gt; what you're used to &amp;mdash; Relay containers are standard React components. Here's the &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">ビューの構成は、&lt;em&gt;慣れ親しん&lt;/em&gt;だものです&amp;mdash;リレーコンテナーは、標準のReactコンポーネントです。次に &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; コンポーネントを示します。</target>
        </trans-unit>
        <trans-unit id="ff6f9fbff154a814e972c078a22c3cc9628815cf" translate="yes" xml:space="preserve">
          <source>View composition is &lt;em&gt;exactly&lt;/em&gt; what you're used to &amp;mdash; Relay containers are standard React components. Here's the &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">ビューの構成は、&lt;em&gt;慣れ親しん&lt;/em&gt;だものです&amp;mdash;リレーコンテナーは、標準のReactコンポーネントです。ここだ &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; コンポーネント：</target>
        </trans-unit>
        <trans-unit id="1ebbd92b690622c06c90cfb9515becf2b5c48808" translate="yes" xml:space="preserve">
          <source>Warm up</source>
          <target state="translated">ウォームアップ</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="ee4e2bfd72b7c80e3c41f3483341254dd5afffff" translate="yes" xml:space="preserve">
          <source>We built a few scripts to help you with the conversion process. Check them out at &lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;https://github.com/relayjs/relay-codemod&lt;/a&gt;.</source>
          <target state="translated">変換プロセスに役立つスクリプトをいくつか作成しました。&lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;https://github.com/relayjs/relay-codemodで&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="5940197c590089a53a146cb165e633452c87b60e" translate="yes" xml:space="preserve">
          <source>We can change this behavior by supplying the &lt;code&gt;renderLoading&lt;/code&gt; prop:</source>
          <target state="translated">この動作を変更するには、 &lt;code&gt;renderLoading&lt;/code&gt; プロパティを指定します。</target>
        </trans-unit>
        <trans-unit id="0025d01a256751edcecba66775aa9098e4c29a78" translate="yes" xml:space="preserve">
          <source>We can give Relay instructions in the form of a config array on how to use the response from each mutation to update the client-side store. We do this by configuring the mutation with one or more of the following mutation types:</source>
          <target state="translated">各突然変異からのレスポンスを使ってクライアント側のストアを更新する方法について、コンフィグ配列の形でRelayに指示を出すことができます。これを行うには、以下のミューテーションタイプのうち1つ以上でミューテーションを設定します。</target>
        </trans-unit>
        <trans-unit id="8d988256976c56fbd9f26524c8c8f2411a181121" translate="yes" xml:space="preserve">
          <source>We declare our mutations' data dependencies here, just as we would with a container. This is particularly useful to ensure that a set of fields we might want to use in this mutation's optimistic response have been fetched.</source>
          <target state="translated">コンテナと同じように、ここでミューテーションのデータ依存性を宣言します。これは、このミューテーションの楽観的な応答で使用したいフィールドのセットがフェッチされていることを確認するのに特に便利です。</target>
        </trans-unit>
        <trans-unit id="b7466fdf0dcdc8961e68874158874a25c24afe7b" translate="yes" xml:space="preserve">
          <source>We need a place to hide our treasure, a way to check hiding spots for treasure, and a way to track our turns remaining. For the purposes of this tutorial, we'll hide these data in memory.</source>
          <target state="translated">宝具の隠し場所、宝具の隠し場所を確認する方法、残りターンを把握する方法が必要です。このチュートリアルでは、これらのデータをメモリに隠します。</target>
        </trans-unit>
        <trans-unit id="65874d3946f2b63af172cee5a5b310c785e00be9" translate="yes" xml:space="preserve">
          <source>We need to give Relay instructions on how to use the response payload from each mutation to update the client-side store. We do this by configuring the mutation with one or more of the following mutation types:</source>
          <target state="translated">各突然変異からのレスポンス・ペイロードを使用してクライアント側のストアを更新する方法をRelayに指示する必要があります。これを行うには、以下のミューテーションタイプのうち1つ以上でミューテーションを設定します。</target>
        </trans-unit>
        <trans-unit id="8cbe01efa489ff5ceee170b9e46b9663c23a0b77" translate="yes" xml:space="preserve">
          <source>We ultimately settled on static methods; components would effectively return a query-tree, separate from the view-tree, describing their data dependencies. Relay could then use this query-tree to fetch all the information needed in a single stage and use it to render the components. The problem was finding an appropriate mechanism to describe the query-tree, and a way to efficiently fetch it from the server (i.e. in a single network request). This is the perfect use-case for GraphQL because it provides a syntax for &lt;em&gt;describing data-dependencies as data&lt;/em&gt;, without dictating any particular API. Note that Promises and Observables are often suggested as alternatives, but they represent &lt;em&gt;opaque commands&lt;/em&gt; and preclude various optimizations such as query batching.</source>
          <target state="translated">私たちは最終的に静的メソッドに落ち着きました。コンポーネントは、ビューツリーとは別のクエリツリーを効果的に返し、データの依存関係を記述します。次に、Relayはこのクエリツリーを使用して、単一のステージで必要なすべての情報をフェッチし、それを使用してコンポーネントをレンダリングできます。問題は、クエリツリーを記述するための適切なメカニズムと、それをサーバーから（つまり、単一のネットワーク要求で）効率的にフェッチする方法を見つけることでした。これは、特定のAPIを指定することなく&lt;em&gt;、データ依存関係をdataとして記述&lt;/em&gt;するための構文を提供するため、GraphQLの完全なユースケースです。 PromiseとObservableは代替として提案されることが多いですが、これらは&lt;em&gt;不透明なコマンド&lt;/em&gt;を表し、クエリのバッチ処理などのさまざまな最適化を妨げます。</target>
        </trans-unit>
        <trans-unit id="69182ca2dfd5971872156968dd68015b5e288405" translate="yes" xml:space="preserve">
          <source>We'll now see different &lt;code&gt;likeCount&lt;/code&gt;s depending on how the story is accessed. A view that uses the first query will see an outdated count, while a view using the second query will see the updated count.</source>
          <target state="translated">ストーリーへのアクセス方法に応じて、さまざまな &lt;code&gt;likeCount&lt;/code&gt; が表示されます。最初のクエリを使用するビューには古いカウントが表示され、2番目のクエリを使用するビューには更新されたカウントが表示されます。</target>
        </trans-unit>
        <trans-unit id="4a34c41bd9be871dd6a4b7a07724bb519fe92e77" translate="yes" xml:space="preserve">
          <source>We're almost ready to let Relay fulfill the data requirements for these components and render them. However, there is one problem. In order to actually fetch data with GraphQL, we need a query root. For example, we need to ground the &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; fragment in a concrete node of type &lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">Relayがこれらのコンポーネントのデータ要件を満たし、レンダリングする準備がほぼ整いました。ただし、問題が1つあります。GraphQLを使用して実際にデータをフェッチするには、クエリルートが必要です。たとえば、 &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; フラグメントをタイプ &lt;code&gt;User&lt;/code&gt; の具象ノードに固定する必要があります。</target>
        </trans-unit>
        <trans-unit id="f379242619731bf12c214370913f902c9dc56b87" translate="yes" xml:space="preserve">
          <source>We've found that it's common for the GraphQL schema to differ slightly or even substantially from the form in which data is stored on disk. Put simply: there isn't always a 1:1 correspondence between data changes in your underlying &lt;em&gt;data storage&lt;/em&gt; (disk) and data changes in your &lt;em&gt;product-visible schema&lt;/em&gt; (GraphQL). The perfect example of this is privacy: returning a user-facing field such as &lt;code&gt;age&lt;/code&gt; might require accessing numerous records in our data-storage layer to determine if the active user is even allowed to &lt;em&gt;see&lt;/em&gt; that &lt;code&gt;age&lt;/code&gt; (Are we friends? Is my age shared? Did I block you? etc.).</source>
          <target state="translated">GraphQLスキーマは、データがディスクに格納されている形式とはわずかに、または大幅に異なることがよくあります。簡単に言うと、基礎となる&lt;em&gt;データストレージ&lt;/em&gt;（ディスク）でのデータ変更と&lt;em&gt;製品表示スキーマ&lt;/em&gt;（GraphQL）でのデータ変更の間には、常に1対1の対応があるわけではありません。これの完璧な例はプライバシーです。 &lt;code&gt;age&lt;/code&gt; などのユーザー向けフィールドを返すには、データストレージレイヤーの多数のレコードにアクセスして、アクティブユーザーがその &lt;code&gt;age&lt;/code&gt; を&lt;em&gt;見る&lt;/em&gt;ことが許可されているかどうかを判断する必要がある場合があります（私たちは友達ですか？私の年齢は共有されますか？ ？私はあなたをブロックしましたか？など）。</target>
        </trans-unit>
        <trans-unit id="908ef03db4345c18068bb287000ab8108652ad6f" translate="yes" xml:space="preserve">
          <source>We've found that typical approaches to data-fetching &amp;mdash; with imperative APIs &amp;mdash; force developers to deal with too much of this non-essential complexity. For example, consider &lt;em&gt;optimistic UI updates&lt;/em&gt;. This is a way of giving the user feedback while waiting for a server response. The logic of &lt;em&gt;what&lt;/em&gt; to do can be quite clear: when the user clicks &quot;like&quot;, mark the story as being liked and send the request to the server. But the implementation is often much more complex. Imperative approaches require us to implement all of those steps: reach into the UI and toggle the button, initiate a network request, retry it if necessary, show an error if it fails (and untoggle the button), etc. The same goes for data-fetching: specifying &lt;em&gt;what&lt;/em&gt; data we need often dictates &lt;em&gt;how&lt;/em&gt; and &lt;em&gt;when&lt;/em&gt; it is fetched. Next, we'll explore our approach to solving these concerns with &lt;strong&gt;Relay&lt;/strong&gt;.</source>
          <target state="translated">必須のAPIを使用したデータフェッチへの一般的なアプローチにより、開発者はこの本質的でない複雑さの多くに対処しなければならないことがわかりました。たとえば、&lt;em&gt;楽観的なUIの更新を&lt;/em&gt;検討&lt;em&gt;してください&lt;/em&gt;。これは、サーバーからの応答を待つ間にユーザーにフィードバックを提供する方法です。&lt;em&gt;何&lt;/em&gt;をすべき&lt;em&gt;か&lt;/em&gt;というロジックは非常に明確です。ユーザーが「いいね」をクリックしたときに、ストーリーに「いいね！」とマークを付け、リクエストをサーバーに送信します。しかし、多くの場合、実装ははるかに複雑です。命令型アプローチでは、これらすべての手順を実装する必要があります。UIにアクセスしてボタンを切り替え、ネットワークリクエストを開始し、必要に応じて再試行し、失敗した場合はエラーを表示します（ボタンの切り替えを解除します）など。データについても同様です。 -fetching：必要&lt;em&gt;な&lt;/em&gt;データを指定する&lt;em&gt;どのように&lt;/em&gt;して&lt;em&gt;たときに&lt;/em&gt;、それがフェッチされます。次に、&lt;strong&gt;Relayで&lt;/strong&gt;これらの問題を解決するためのアプローチを探ります。</target>
        </trans-unit>
        <trans-unit id="c57df462a7e454e5b5d9c9c3be330abf92758a69" translate="yes" xml:space="preserve">
          <source>We've seen that Relay containers ensure that GraphQL fragments are fetched &lt;em&gt;before&lt;/em&gt; the component is rendered. But containers also provide another benefit that isn't immediately obvious: &lt;strong&gt;data masking&lt;/strong&gt;. Relay only allows components to access data they specifically ask for in &lt;code&gt;fragments&lt;/code&gt; &amp;mdash; nothing more. So if one component queries for a Story's &lt;code&gt;text&lt;/code&gt;, and another for its &lt;code&gt;author&lt;/code&gt;, each can see &lt;em&gt;only&lt;/em&gt; the field that they asked for. In fact, components can't even see the data requested by their &lt;em&gt;children&lt;/em&gt;: that would also break encapsulation.</source>
          <target state="translated">リレーコンテナーは、コンポーネントがレンダリングされる&lt;em&gt;前に&lt;/em&gt; GraphQLフラグメントが確実にフェッチされることを確認しました。しかし、コンテナーには、すぐには明らかにならないもう1つの利点があります。それは、&lt;strong&gt;データマスキング&lt;/strong&gt;です。リレーは、コンポーネントが &lt;code&gt;fragments&lt;/code&gt; 具体的に要求するデータにアクセスすることのみを許可します。一つの成分ストーリーのためのクエリのであれば &lt;code&gt;text&lt;/code&gt; 、およびそのための別の &lt;code&gt;author&lt;/code&gt; 、それぞれが見ることができる&lt;em&gt;唯一の&lt;/em&gt;彼らが求めていることをフィールドに。実際、コンポーネントは&lt;em&gt;子から&lt;/em&gt;要求されたデータを見ることさえできません。それもカプセル化を壊します。</target>
        </trans-unit>
        <trans-unit id="deaef06798309bf42fff99bdd598051728c38f5a" translate="yes" xml:space="preserve">
          <source>What we have written here is a mock database interface. We can imagine hooking this up to a real database, but for now let's move on.</source>
          <target state="translated">ここに書いたのは、模擬データベースインターフェースです。これを実際のデータベースに接続することも想像できますが、今のところは先に進みましょう。</target>
        </trans-unit>
        <trans-unit id="73a39c3a3d88bd8125f710502d024ae93180062d" translate="yes" xml:space="preserve">
          <source>What works with what? Relay Compat (&lt;code&gt;'react-relay/compat'&lt;/code&gt;) is the most flexible. Compat components and mutations can be used by everything. Compat components can also have any kind of children.</source>
          <target state="translated">何が何に対応していますか？リレー互換（ &lt;code&gt;'react-relay/compat'&lt;/code&gt; ）が最も柔軟です。互換性のあるコンポーネントとミューテーションはすべてで使用できます。Compatコンポーネントは、あらゆる種類の子を持つこともできます。</target>
        </trans-unit>
        <trans-unit id="0a097138ac94d8bfbf69d6920577e2b751982a49" translate="yes" xml:space="preserve">
          <source>When &quot;force fetching&quot;, this is true if &lt;code&gt;ready&lt;/code&gt; is true as a result of data being available on the client before the server request has completed.</source>
          <target state="translated">「強制フェッチ」の場合、サーバー要求が完了する前にクライアントでデータが使用可能になった結果、 &lt;code&gt;ready&lt;/code&gt; がtrueであれば、これはtrueです。</target>
        </trans-unit>
        <trans-unit id="ec3ad126a1399587ee94fd174e76b0fbd442a34b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;forceFetch&lt;/code&gt; is true and &lt;code&gt;renderFetched&lt;/code&gt; is called as a result of available client data, &lt;code&gt;renderFetched&lt;/code&gt; is called with a second argument that has a &lt;code&gt;stale&lt;/code&gt; boolean property. The &lt;code&gt;stale&lt;/code&gt; property is true if &lt;code&gt;renderFetched&lt;/code&gt; is called before the forced server request completes.</source>
          <target state="translated">とき &lt;code&gt;forceFetch&lt;/code&gt; が真であると &lt;code&gt;renderFetched&lt;/code&gt; が可能なクライアントデータの結果として呼び出され、 &lt;code&gt;renderFetched&lt;/code&gt; を有する第2引数で呼び出された &lt;code&gt;stale&lt;/code&gt; ブール型プロパティを。 &lt;code&gt;stale&lt;/code&gt; 場合はプロパティがtrueで &lt;code&gt;renderFetched&lt;/code&gt; が強制サーバ要求が完了する前に呼ばれています。</target>
        </trans-unit>
        <trans-unit id="eb41ea6dee1bf1db385774c4f83f62a51389acc5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;forceFetch&lt;/code&gt; is true, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; will always send a request to the server. However, if all the data required to render is also available on the client, &lt;code&gt;renderFetched&lt;/code&gt; may still be called before the server request completes.</source>
          <target state="translated">とき &lt;code&gt;forceFetch&lt;/code&gt; が真である、&lt;strong&gt;Relay.RootContainerは&lt;/strong&gt;常にサーバにリクエストを送信します。ただし、レンダリングに必要なすべてのデータがクライアントでも利用できる場合、サーバーリクエストが完了する前に &lt;code&gt;renderFetched&lt;/code&gt; が呼び出される可能性があります。</target>
        </trans-unit>
        <trans-unit id="5e40c2b8419bc5119b554a06ad55e52a926e319f" translate="yes" xml:space="preserve">
          <source>When Relay fulfills data, the &lt;code&gt;onReadyStateChange&lt;/code&gt; callback is called one or more times with an object that describes the current &quot;ready state&quot;. This object has the following properties:</source>
          <target state="translated">Relayがデータを満たすと、 &lt;code&gt;onReadyStateChange&lt;/code&gt; コールバックが、現在の「準備完了状態」を表すオブジェクトを使用して1回以上呼び出されます。このオブジェクトには次のプロパティがあります。</target>
        </trans-unit>
        <trans-unit id="32bb09505d79ce543a4f26cb9022780cf39a8205" translate="yes" xml:space="preserve">
          <source>When all data necessary to render becomes available, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; will render the supplied &lt;code&gt;Component&lt;/code&gt; by default. However, we can change this behavior by supplying a callback to the &lt;code&gt;renderFetched&lt;/code&gt; prop:</source>
          <target state="translated">レンダリングに必要なすべてのデータが利用可能になると、&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;はデフォルトで提供された &lt;code&gt;Component&lt;/code&gt; をレンダリングします。ただし、 &lt;code&gt;renderFetched&lt;/code&gt; プロップにコールバックを提供することで、この動作を変更できます。</target>
        </trans-unit>
        <trans-unit id="e8c530641aad6dea0ce0a725ecb86984b969f2e6" translate="yes" xml:space="preserve">
          <source>When all data requirements are fulfilled, &lt;code&gt;renderFetched&lt;/code&gt; is called to render the view. This callback is expected to spread &lt;code&gt;data&lt;/code&gt; into the supplied &lt;code&gt;Container&lt;/code&gt; when rendering it.</source>
          <target state="translated">すべてのデータ要件が満たされると、ビューをレンダリングするために &lt;code&gt;renderFetched&lt;/code&gt; が呼び出されます。このコールバックは、レンダリング時に、提供された &lt;code&gt;Container&lt;/code&gt; に &lt;code&gt;data&lt;/code&gt; を分散することが期待されています。</target>
        </trans-unit>
        <trans-unit id="f5e881d6a25c5fe2f25b897803df81640312440a" translate="yes" xml:space="preserve">
          <source>When compiling code for production deployment, the plugin can be configured to immediately throw upon encountering a validation problem. The plugin can be further customized for different environments with the following options:</source>
          <target state="translated">本番環境でのデプロイ用にコードをコンパイルする際に、検証の問題が発生した場合に即座にスローするようにプラグインを設定することができます。プラグインは、以下のオプションを使用して、さまざまな環境に合わせてさらにカスタマイズすることができます。</target>
        </trans-unit>
        <trans-unit id="fef005c4b23cdf975a02dadd67a2264bb2944197" translate="yes" xml:space="preserve">
          <source>When data requirements failed to be fulfilled, &lt;code&gt;renderFailure&lt;/code&gt; is called to render the view.</source>
          <target state="translated">データ要件が満たされなかった場合、ビューをレンダリングするために &lt;code&gt;renderFailure&lt;/code&gt; が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="fe6cbba9204bbe45970c08910fca16574ce8a0cc" translate="yes" xml:space="preserve">
          <source>When data requirements have yet to be fulfilled, &lt;code&gt;renderLoading&lt;/code&gt; is called to render the view. If this returns &lt;code&gt;undefined&lt;/code&gt;, the previously rendered view (or nothing if there is no previous view) is rendered.</source>
          <target state="translated">データ要件がまだ満たされていないと、ビューをレンダリングするために &lt;code&gt;renderLoading&lt;/code&gt; が呼び出されます。これが &lt;code&gt;undefined&lt;/code&gt; を返す場合、以前にレンダリングされたビュー（または前のビューがない場合は何も）がレンダリングされます。</target>
        </trans-unit>
        <trans-unit id="48fe499e8a7f1e23dc6dcd982b4f071176b969ff" translate="yes" xml:space="preserve">
          <source>When designing a fat query, consider &lt;em&gt;all&lt;/em&gt; of the data that might change as a result of the mutation &amp;ndash; not just the data currently in use by your application. We don't need to worry about overfetching; this query is never executed without first intersecting it with a &amp;lsquo;tracked query&amp;rsquo; of the data our application actually needs. If we omit fields in the fat query, we might observe data inconsistencies in the future when we add views with new data dependencies, or add new data dependencies to existing views.</source>
          <target state="translated">ファットクエリを設計するときは、アプリケーションの現在使用中のデータだけでなく、変更の結果として変更される可能性のある&lt;em&gt;すべて&lt;/em&gt;のデータを考慮してください。オーバーフェッチについて心配する必要はありません。このクエリは、アプリケーションが実際に必要とするデータの「追跡されたクエリ」と最初に交差しない限り、決して実行されません。ファットクエリのフィールドを省略した場合、新しいデータ依存関係を持つビューを追加したり、既存のビューに新しいデータ依存関係を追加したりすると、将来的にデータの不整合が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="8d515b89284c6ce31950922a449ba18618a553f6" translate="yes" xml:space="preserve">
          <source>When incrementally converting a Relay Classic app to Relay Modern, &lt;code&gt;graphql&lt;/code&gt; literals can be translated to be usable by &lt;em&gt;both&lt;/em&gt; runtimes if configured to use compatibility mode:</source>
          <target state="translated">Relay ClassicアプリをRelay Modernに段階的に変換する場合、互換モードを使用するように構成されていれば、 &lt;code&gt;graphql&lt;/code&gt; リテラルを&lt;em&gt;両方の&lt;/em&gt;ランタイムで使用できるように変換できます。</target>
        </trans-unit>
        <trans-unit id="902c49b06415e9d418fef8488cdcaad88a9be3b5" translate="yes" xml:space="preserve">
          <source>When it sends queries, it will automatically fail requests after a 15 second timeout. Also, failed requests are automatically retried twice, with a 1 second delay and a 3 second delay, respectively.</source>
          <target state="translated">クエリを送信すると、15秒のタイムアウト後に自動的にリクエストが失敗します。また、失敗したリクエストは自動的に2回再試行され、それぞれ1秒の遅延と3秒の遅延が発生します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
