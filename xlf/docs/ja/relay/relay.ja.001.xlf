<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="relay">
    <body>
      <group id="relay">
        <trans-unit id="f9287b3fad8f092d74f4ec6aadb5a29cf9ba2e63" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2013&amp;ndash;present Facebook Inc.</source>
          <target state="translated">&amp;copy;2013&amp;ndash;present Facebook Inc.</target>
        </trans-unit>
        <trans-unit id="62a57a41103550669d926f2e0d40ca12b0b6a458" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2020&amp;ndash;present Facebook Inc.</source>
          <target state="translated">&amp;copy;2020&amp;ndash;現在のFacebook Inc.</target>
        </trans-unit>
        <trans-unit id="6c885f04e75b4bbf0d9edbb67f250e651d298c71" translate="yes" xml:space="preserve">
          <source>(subsequent sections explain how these types are used in practice):</source>
          <target state="translated">（以降のセクションでは、これらのタイプが実際にどのように使用されるかを説明します）：</target>
        </trans-unit>
        <trans-unit id="ac2bb4599b07dd7b4cea35d8e273b367c0b66305" translate="yes" xml:space="preserve">
          <source>* Modern API doesn't support mutation fragments. You might have to inline the mutation fragments from your legacy mutation in the fragment of the component.</source>
          <target state="translated">*最新のAPIは変異フラグメントをサポートしていません。コンポーネントのフラグメントにある従来のミューテーションのミューテーションフラグメントをインライン化する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="3c78bed46629a737d7ec7580861338032fb6f8d8" translate="yes" xml:space="preserve">
          <source>...which calls the callbacks for any &lt;code&gt;subscribe()&lt;/code&gt;-ers whose results have changed. Each subscription is checked as follows:</source>
          <target state="translated">...結果が変更された &lt;code&gt;subscribe()&lt;/code&gt; - ersのコールバックを呼び出します。各サブスクリプションは次のようにチェックされます。</target>
        </trans-unit>
        <trans-unit id="c225bfc176636425ea153120adefbee642d75cea" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;fragment-container&quot;&gt;&lt;code&gt;createFragmentContainer&lt;/code&gt;&lt;/a&gt; returns a basic container that cannot fetch additional data beyond what is declared in its fragment(s). Relay Modern also provides more advanced containers for dynamic use cases (which were previously handled in Relay Classic via &lt;code&gt;setVariables&lt;/code&gt;):</source>
          <target state="translated">&lt;a href=&quot;fragment-container&quot;&gt; &lt;code&gt;createFragmentContainer&lt;/code&gt; &lt;/a&gt;は、フラグメントで宣言されている以上の追加データをフェッチできない基本的なコンテナーを返します。Relay Modernは、動的なユースケース（以前はRelay Classicで &lt;code&gt;setVariables&lt;/code&gt; を介して処理されていました）のためのより高度なコンテナーも提供しています。</target>
        </trans-unit>
        <trans-unit id="77688ea0d1fdf22bab3df470e72bfe7de6cb4724" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://chrome.google.com/webstore/detail/relay-devtools/oppikflppfjfdpjimpdadhelffjpciba&quot;&gt;Chrome Extension&lt;/a&gt; creates a Relay tab in the developer tools interface for debugging apps in Chrome</source>
          <target state="translated">&lt;a href=&quot;https://chrome.google.com/webstore/detail/relay-devtools/oppikflppfjfdpjimpdadhelffjpciba&quot;&gt;Chrome拡張機能&lt;/a&gt;は、Chromeでアプリをデバッグするための開発者ツールインターフェイスにリレータブを作成します</target>
        </trans-unit>
        <trans-unit id="fad91719b9218a6ae11551221b84fc32086535ed" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; allows views to be defined as components where every component is responsible for rendering a part of the UI. Composing other components is how to build complex UIs. Each React component doesn't need to know the inner workings of the composed components.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt;では、ビューをコンポーネントとして定義でき、すべてのコンポーネントがUIの一部のレンダリングを担当します。他のコンポーネントの構成は、複雑なUIを構築する方法です。各Reactコンポーネントは、構成されたコンポーネントの内部動作を知る必要はありません。</target>
        </trans-unit>
        <trans-unit id="a1980b0d9659b15299523fce23afa9e64733250c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/relayjs/relay-debugger/tree/master/react-native-shell&quot;&gt;Electron App&lt;/a&gt; that connects to React Native apps running Relay</source>
          <target state="translated">&lt;a href=&quot;https://github.com/relayjs/relay-debugger/tree/master/react-native-shell&quot;&gt;&lt;/a&gt;Relayを実行するReact Nativeアプリに接続するElectronアプリ</target>
        </trans-unit>
        <trans-unit id="0f80ef8cc2241c7509e6613ced8779935dc25b6f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt; manages the execution of the GraphQL query. It sends the query with given variables, parses the response, saves the data to the internal cache, and finally renders the view.</source>
          <target state="translated">&lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt;は、GraphQLクエリの実行を管理します。指定された変数を使用してクエリを送信し、応答を解析して、データを内部キャッシュに保存し、最後にビューをレンダリングします。</target>
        </trans-unit>
        <trans-unit id="cfac86ab065f686a94d7eabf085884e964606374" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;refetch-container&quot;&gt;&lt;code&gt;createRefetchContainer&lt;/code&gt;&lt;/a&gt; is a variation of &lt;code&gt;createFragmentContainer&lt;/code&gt; that addresses the &quot;see more&quot; use case, where a subset of data is rendered initially and then additional data is fetched on demand. Refetch containers initially fetch data for their fragments just like fragment containers, but also offer a &lt;code&gt;refetch()&lt;/code&gt; method by which additional data can be fetched, or the container can be re-rendered to read data using different variables.</source>
          <target state="translated">&lt;a href=&quot;refetch-container&quot;&gt; &lt;code&gt;createRefetchContainer&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;createFragmentContainer&lt;/code&gt; のバリエーションであり、データのサブセットが最初にレンダリングされ、その後、追加のデータがオンデマンドでフェッチされる「もっと見る」ユースケースに対処します。再フェッチコンテナーは、最初はフラグメントコンテナーと同じようにフラグメントのデータをフェッチしますが、追加のデータをフェッチしたり、コンテナーを再レンダリングしてさまざまな変数を使用してデータを読み取ったりできる &lt;code&gt;refetch()&lt;/code&gt; メソッドも提供します。</target>
        </trans-unit>
        <trans-unit id="f6f0afa9606f188df5aa2880a96f0796da66589e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;relay-compat&quot;&gt;Compat mode&lt;/a&gt; allows the Relay Modern APIs to be incrementally adopted in an existing Relay app. This approach enables the following features compared to Relay Classic:</source>
          <target state="translated">&lt;a href=&quot;relay-compat&quot;&gt;互換モードで&lt;/a&gt;は、Relay Modern APIを既存のRelayアプリで段階的に採用できます。このアプローチでは、Relay Classicと比較して次の機能が有効になります。</target>
        </trans-unit>
        <trans-unit id="3cc7b1d6acf9a6a36373b7d2788a819c007a696a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; receives a &lt;code&gt;user&lt;/code&gt; prop with plain JavaScript data - objects, arrays, strings - and renders as usual.</source>
          <target state="translated">&lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; は、プレーンなJavaScriptデータ（オブジェクト、配列、文​​字列）を含む &lt;code&gt;user&lt;/code&gt; プロップを受け取り、通常どおりレンダリングします。</target>
        </trans-unit>
        <trans-unit id="540f04ea4575b6b8ef0b102ef7464ad435fbcfde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@argumentDefinitions&lt;/code&gt; is a directive used to specify arguments taken by a fragment. For example:</source>
          <target state="translated">&lt;code&gt;@argumentDefinitions&lt;/code&gt; は、フラグメントが取る引数を指定するために使用されるディレクティブです。例えば：</target>
        </trans-unit>
        <trans-unit id="8c1b1f1da3ceb037a205f174a8917520d0d4ffd9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@arguments&lt;/code&gt; is a directive used to pass arguments to a fragment that was defined using &lt;a href=&quot;#argumentdefinitions&quot;&gt;&lt;code&gt;@argumentDefinitions&lt;/code&gt;&lt;/a&gt;. For example:</source>
          <target state="translated">&lt;code&gt;@arguments&lt;/code&gt; は、@ argumentDefinitionsを使用して定義されたフラグメントに引数を渡すために使用されるディレクティブ&lt;a href=&quot;#argumentdefinitions&quot;&gt; &lt;code&gt;@argumentDefinitions&lt;/code&gt; &lt;/a&gt;。例えば：</target>
        </trans-unit>
        <trans-unit id="115b4c121f9af58bd42ac1ea726c7c948a8dafc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@connection&lt;/code&gt; directive</source>
          <target state="translated">&lt;code&gt;@connection&lt;/code&gt; ディレクティブ</target>
        </trans-unit>
        <trans-unit id="1bc35103d12ff175f274fc790197926805195584" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@relay(mask: false)&lt;/code&gt; can be used to prevent data masking; when including a fragment and annotating it with &lt;code&gt;@relay(mask: false)&lt;/code&gt;, its data will be available directly to the parent instead of being masked for a different container.</source>
          <target state="translated">&lt;code&gt;@relay(mask: false)&lt;/code&gt; を使用して、データのマスキングを防ぐことができます。フラグメントを含めて &lt;code&gt;@relay(mask: false)&lt;/code&gt; で注釈を付けると、そのデータは、別のコンテナーでマスクされるのではなく、親が直接利用できるようになります。</target>
        </trans-unit>
        <trans-unit id="b5d3bbc3f0308d432f9237679fd4198f106ffc51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COLLISION_COMMIT_FAILED&lt;/code&gt; &amp;mdash; Transaction was queued for commit but another transaction with the same collision key failed. All transactions in the collision queue, including this one, have been failed. Transaction can be recommitted or rolled back.</source>
          <target state="translated">&lt;code&gt;COLLISION_COMMIT_FAILED&lt;/code&gt; &amp;mdash;トランザクションはコミットのキューに入れられましたが、同じ衝突キーを持つ別のトランザクションが失敗しました。これを含む、衝突キュー内のすべてのトランザクションが失敗しました。トランザクションは再コミットまたはロールバックできます。</target>
        </trans-unit>
        <trans-unit id="8093d07e77e9be3790d54f76445c918f46849774" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COMMITTING&lt;/code&gt; &amp;mdash; Transaction is waiting for the server to respond.</source>
          <target state="translated">&lt;code&gt;COMMITTING&lt;/code&gt; &amp;mdash;トランザクションはサーバーの応答を待っています。</target>
        </trans-unit>
        <trans-unit id="72fc89ccfca88827066da906d579a404ab74ce01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COMMIT_FAILED&lt;/code&gt; &amp;mdash; Transaction was sent to the server for comitting but failed.</source>
          <target state="translated">&lt;code&gt;COMMIT_FAILED&lt;/code&gt; &amp;mdash; コミットのためにトランザクションがサーバーに送信されましたが、失敗しました。</target>
        </trans-unit>
        <trans-unit id="3ea90f9f79de8b7da5c3c317bc9a5b13f75106bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COMMIT_QUEUED&lt;/code&gt; &amp;mdash; Transaction was committed but another transaction with the same collision key is pending, so the transaction has been queued to send to the server.</source>
          <target state="translated">&lt;code&gt;COMMIT_QUEUED&lt;/code&gt; &amp;mdash;トランザクションはコミットされましたが、同じ衝突キーを持つ別のトランザクションが保留になっているため、トランザクションはサーバーに送信するためにキューに入れられました。</target>
        </trans-unit>
        <trans-unit id="d35b1de34e23cc42d8709b3e3b9f29da3640030e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CompilerContext&lt;/code&gt;: an immutable representation of a corpus of GraphQL documents. It contains the schema and a mapping of document names to document representations (as IR, see above).</source>
          <target state="translated">&lt;code&gt;CompilerContext&lt;/code&gt; ：GraphQLドキュメントのコーパスの不変の表現。これには、スキーマと、ドキュメント名からドキュメント表現へのマッピングが含まれています（IRとして、上記を参照）。</target>
        </trans-unit>
        <trans-unit id="1f3d026fc6b13bd99ef80b56496208f62a08c9dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Component&lt;/code&gt; Relay container that defines fragments and the view to render.</source>
          <target state="translated">&lt;code&gt;Component&lt;/code&gt; フラグメントとレンダリングするビューを定義するコンポーネントリレーコンテナー。</target>
        </trans-unit>
        <trans-unit id="7e0e496215e40a981e6b2de27c4b054fef09ee84" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ConnectionHandler&lt;/code&gt; is a utility module exposed by &lt;code&gt;relay-runtime&lt;/code&gt; that aids in the manipulation of connections. &lt;code&gt;ConnectionHandler&lt;/code&gt; exposes the following interface:</source>
          <target state="translated">&lt;code&gt;ConnectionHandler&lt;/code&gt; は、接続の操作を支援する &lt;code&gt;relay-runtime&lt;/code&gt; によって公開されるユーティリティモジュールです。 &lt;code&gt;ConnectionHandler&lt;/code&gt; は、次のインターフェイスを公開します。</target>
        </trans-unit>
        <trans-unit id="bfead01c2b218e3cb68f309d9651d5634bcc584a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Container&lt;/code&gt; Relay container that defines fragments and the view to render.</source>
          <target state="translated">&lt;code&gt;Container&lt;/code&gt; フラグメントとレンダリングするビューを定義するコンテナリレーコンテナ。</target>
        </trans-unit>
        <trans-unit id="6e013f788fda8dc5f1f6d2035114dc14dbf0b578" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DataID&lt;/code&gt; (type): A globally unique or client-generated identifier for a record, stored as a string.</source>
          <target state="translated">&lt;code&gt;DataID&lt;/code&gt; （タイプ）：文字列として格納された、レコードのグローバルに一意またはクライアント生成の識別子。</target>
        </trans-unit>
        <trans-unit id="ce201c06fa6c11d5f36ef9be515d40d9178e1a3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Environment&lt;/code&gt; (type): Represents an encapsulated environment combining a &lt;code&gt;Store&lt;/code&gt; and &lt;code&gt;Network&lt;/code&gt;, providing a high-level API for interacting with both. This is the main public API of &lt;code&gt;RelayRuntime&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Environment&lt;/code&gt; （タイプ）： &lt;code&gt;Store&lt;/code&gt; と &lt;code&gt;Network&lt;/code&gt; を組み合わせたカプセル化された環境を表し、両方と対話するための高レベルのAPIを提供します。これは &lt;code&gt;RelayRuntime&lt;/code&gt; のメインのパブリックAPIです。</target>
        </trans-unit>
        <trans-unit id="1e3ea2f8d9422eb5a55274a578df6f8f2c6bd0ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FlattenTransform&lt;/code&gt;: Reduces extraneous levels of indirection in a query, inlining fields from anonymous fragments wherever they match the parent type. This can be beneficial when generating code to read the results of a query or process query results, as it reduces duplicate field processing. For example:</source>
          <target state="translated">&lt;code&gt;FlattenTransform&lt;/code&gt; ：クエリ内の間接レベルの無関係なレベルを減らし、親タイプと一致する場所に匿名フラグメントからフィールドをインライン化します。これは、重複するフィールド処理を減らすため、クエリの結果を読み取ったり、クエリの結果を処理したりするコードを生成するときに役立ちます。例えば：</target>
        </trans-unit>
        <trans-unit id="e8491c1573884a469fe6759e485e0a2a6e275e8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GenerateRequisiteFieldTransform&lt;/code&gt;: This optional, Relay-specific transform inserts &lt;code&gt;id&lt;/code&gt; fields for globally identifiable objects and &lt;code&gt;__typename&lt;/code&gt; fields wherever the type cannot be statically determined (e.g. for unions).</source>
          <target state="translated">&lt;code&gt;GenerateRequisiteFieldTransform&lt;/code&gt; ：このオプションのリレー固有のトランスフォームは、グローバルに識別可能なオブジェクトの &lt;code&gt;id&lt;/code&gt; フィールドと、タイプを静的に判別できない場合（ユニオンなど）の &lt;code&gt;__typename&lt;/code&gt; フィールドを挿入します。</target>
        </trans-unit>
        <trans-unit id="cfa5e3950beed71919f93e9725e12ccd2524ec5d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IR&lt;/code&gt; (Intermediate Representation): an (effectively immutable) representation of a GraphQL document (query, fragment, field, etc) as a tree structure, including type information from a schema. Compared to the standard GraphQL AST (produced by e.g. &lt;code&gt;graphql-js&lt;/code&gt;) the main difference is that it encodes more of the semantics of GraphQL. For example, conditional branches (&lt;code&gt;@include&lt;/code&gt; and &lt;code&gt;@skip&lt;/code&gt;) are represented directly, making it easier to target optimizations for these directives (One such optimization is to merge sibling fields with the same condition, potentially reducing the number of conditionals that must be evaluated at runtime).</source>
          <target state="translated">&lt;code&gt;IR&lt;/code&gt; （中間表現）：スキーマからの型情報を含む、ツリー構造としてのGraphQLドキュメント（クエリ、フラグメント、フィールドなど）の（事実上不変の）表現。標準のGraphQLAST（たとえば &lt;code&gt;graphql-js&lt;/code&gt; によって生成される）と比較すると、主な違いは、GraphQLのセマンティクスをより多くエンコードすることです。たとえば、条件分岐（ &lt;code&gt;@include&lt;/code&gt; と &lt;code&gt;@skip&lt;/code&gt; ）は直接表されるため、これらのディレクティブの最適化をターゲットにするのが簡単になります（このような最適化の1つは、同じ条件の兄弟フィールドをマージすることで、で評価する必要のある条件の数を減らす可能性があります。ランタイム）。</target>
        </trans-unit>
        <trans-unit id="80030d53df3c7d765455bf7613659bf4eb278701" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Network&lt;/code&gt; (type): Provides methods for fetching query data from and executing mutations against an external data source.</source>
          <target state="translated">&lt;code&gt;Network&lt;/code&gt; （タイプ）：外部データソースからクエリデータをフェッチし、ミューテーションを実行するためのメソッドを提供します。</target>
        </trans-unit>
        <trans-unit id="d52ff52d23e6ad23c71ab30789b670011882899f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PaginationContainer&lt;/code&gt; is designed to simplify the workflow of loading more items in a list -- in many cases, we don't want to fetch all the data at once but lazily load more data. It relies on a GraphQL server exposing connections in a standardized way. For a detailed spec, please check out &lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;this page&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;PaginationContainer&lt;/code&gt; は、リスト内のより多くのアイテムをロードするワークフローを簡略化するように設計されています。多くの場合、一度にすべてのデータをフェッチするのではなく、より多くのデータを遅延ロードします。標準化された方法で接続を公開するGraphQLサーバーに依存しています。詳細な仕様については、&lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;こちらのページをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="36a682fa10b4ab6dd0259f5b624dca4803e8ff33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Parser&lt;/code&gt;: Converts a GraphQL schema and raw GraphQL text into typed IR objects.</source>
          <target state="translated">&lt;code&gt;Parser&lt;/code&gt; ：GraphQLスキーマと生のGraphQLテキストを型付きIRオブジェクトに変換します。</target>
        </trans-unit>
        <trans-unit id="2f603ad3da9b9bbbb0030816e3352c33635f9a1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Printer&lt;/code&gt;: a function that accepts IR and converts it to a GraphQL string.</source>
          <target state="translated">&lt;code&gt;Printer&lt;/code&gt; ：IRを受け入れ、それをGraphQL文字列に変換する関数。</target>
        </trans-unit>
        <trans-unit id="c5406da34447a5b22b7d56f6fce92e419b505424" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;QueryRenderer&lt;/code&gt; is the root of a Relay tree. It takes a query, fetches the data and calls the &lt;code&gt;render&lt;/code&gt; callback with the data.</source>
          <target state="translated">&lt;code&gt;QueryRenderer&lt;/code&gt; は、リレーツリーのルートです。クエリを受け取り、データをフェッチして、データを &lt;code&gt;render&lt;/code&gt; コールバックを呼び出します。</target>
        </trans-unit>
        <trans-unit id="593061a9841e95181922e32bf061e078ec44605a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;QueryRenderer&lt;/code&gt; supports rendering small amounts of data directly, instead of requiring a container to access data. &lt;a href=&quot;fragment-container&quot;&gt;Containers&lt;/a&gt; are optional and can be used as your application grows in size and complexity.</source>
          <target state="translated">&lt;code&gt;QueryRenderer&lt;/code&gt; は、コンテナーがデータにアクセスすることを要求する代わりに、少量のデータを直接レンダリングすることをサポートします。&lt;a href=&quot;fragment-container&quot;&gt;コンテナ&lt;/a&gt;はオプションであり、アプリケーションのサイズと複雑さが大きくなるにつれて使用できます。</target>
        </trans-unit>
        <trans-unit id="99e84e643c97bf62b99096002ffcdeabf9974b27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;QueryRenderer&lt;/code&gt; will then fetch the data and render &lt;code&gt;StoryContainer&lt;/code&gt; once the data is available. Just as React allows developers to render views without directly manipulating the underlying view, Relay removes the need to directly communicate with the network.</source>
          <target state="translated">&lt;code&gt;QueryRenderer&lt;/code&gt; はデータをフェッチし、データが利用可能になると &lt;code&gt;StoryContainer&lt;/code&gt; をレンダリングします。Reactで開発者が基になるビューを直接操作せずにビューをレンダリングできるように、Relayはネットワークと直接通信する必要をなくします。</target>
        </trans-unit>
        <trans-unit id="aa5389da6f3012b6c1290dfc4aabb66ac37a4a88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Record&lt;/code&gt; (type): A representation of a distinct data entity with an identity, type, and fields. Note that the actual runtime representation is opaque to the system: all accesses to &lt;code&gt;Record&lt;/code&gt; objects (including record creation) is mediated through the &lt;code&gt;RelayModernRecord&lt;/code&gt; module. This allows the representation itself to be changed in a single place (e.g. to use &lt;code&gt;Map&lt;/code&gt;s or a custom class). It is important that other code does not assume that &lt;code&gt;Record&lt;/code&gt;s will always be plain objects.</source>
          <target state="translated">&lt;code&gt;Record&lt;/code&gt; （タイプ）：ID、タイプ、およびフィールドを持つ個別のデータエンティティの表現。実際のランタイム表現はシステムに対して不透明であることに注意してください。 &lt;code&gt;Record&lt;/code&gt; オブジェクトへのすべてのアクセス（レコードの作成を含む）は、 &lt;code&gt;RelayModernRecord&lt;/code&gt; モジュールを介して仲介されます。これにより、表現自体を1か所で変更できます（たとえば、 &lt;code&gt;Map&lt;/code&gt; またはカスタムクラスを使用するため）。他のコードでは、 &lt;code&gt;Record&lt;/code&gt; が常にプレーンオブジェクトであると想定していないことが重要です。</target>
        </trans-unit>
        <trans-unit id="0c286a93f7d02b418c79e236a3f655909cd0828b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RecordSource&lt;/code&gt; (type): A collection of records keyed by their data ID, used both to represent the cache and updates to it. For example the store's record cache is a &lt;code&gt;RecordSource&lt;/code&gt; and the results of queries/mutations/subscriptions are normalized into &lt;code&gt;RecordSource&lt;/code&gt;s that are published to a store. Sources also define methods for asynchronously loading records in order to (eventually) support offline use-cases. Currently the only implementation of this interface is &lt;code&gt;RelayInMemoryRecordSource&lt;/code&gt;; future implementations may add support for loading records from disk.</source>
          <target state="translated">&lt;code&gt;RecordSource&lt;/code&gt; （type）：データIDでキー設定されたレコードのコレクションで、キャッシュとその更新の両方を表すために使用されます。たとえば、ストアのレコードキャッシュは &lt;code&gt;RecordSource&lt;/code&gt; であり、クエリ/ミューテーション/サブスクリプションの結果は、ストアに公開される &lt;code&gt;RecordSource&lt;/code&gt; に正規化されます。ソースは、オフラインのユースケースを（最終的に）サポートするために、レコードを非同期にロードするためのメソッドも定義します。現在、このインターフェースの唯一の実装は &lt;code&gt;RelayInMemoryRecordSource&lt;/code&gt; です。将来の実装では、ディスクからレコードをロードするためのサポートが追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="5dcadb6bea3b3b49c5e438342092e725abab0a3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; doesn't provide any bells and whistles such as fat queries or tracked queries (that is, automatic synthesis at runtime of the mutation query to be sent to the server), instead having the user define a static and explicit query. Restricting yourself to the low-level API is a useful preparatory step that will help you ready your codebase for migration to the new static Relay core. In the meantime, if you want those dynamic features, you can opt in to the higher-level &lt;code&gt;Relay.Mutation&lt;/code&gt; API.</source>
          <target state="translated">&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; は、ファットクエリや追跡されたクエリ（つまり、サーバーに送信されるミューテーションクエリの実行時に自動合成）などの機能を提供せず、ユーザーに静的で明示的なクエリを定義させます。低レベルAPIに制限することは、新しい静的リレーコアに移行するためのコードベースの準備に役立つ便利な準備手順です。それまでの間、これらの動的機能が必要な場合は、より高レベルの &lt;code&gt;Relay.Mutation&lt;/code&gt; APIをオプトインできます。</target>
        </trans-unit>
        <trans-unit id="b9dbe21f8c1dda099d24350958022ccc0bb3f410" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; is a low-level API for modeling a GraphQL mutation.</source>
          <target state="translated">&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; は、GraphQLミューテーションをモデリングするための低レベルAPIです。</target>
        </trans-unit>
        <trans-unit id="127b1aff45435298c344787323bda31e37d71df8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.QL&lt;/code&gt; objects are used by the following APIs:</source>
          <target state="translated">&lt;code&gt;Relay.QL&lt;/code&gt; オブジェクトは、次のAPIによって使用されます。</target>
        </trans-unit>
        <trans-unit id="7e9cc4a6100437d109392de9c4dd32579e5bef54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.Renderer&lt;/code&gt; can then orchestrate the fetching of the queries; diffing them against cached data, fetching any missing information, updating the cache, and finally rendering &lt;code&gt;StoryContainer&lt;/code&gt; once the data is available. The default is to render nothing while data is fetching, but the loading view can be customized via the &lt;code&gt;render&lt;/code&gt; prop. Just as React allows developers to render views without directly manipulating the underlying view, Relay and &lt;code&gt;Relay.Renderer&lt;/code&gt; remove the need to directly communicate with the network.</source>
          <target state="translated">&lt;code&gt;Relay.Renderer&lt;/code&gt; 次に、Relay.Rendererはクエリのフェッチを調整できます。それらをキャッシュされたデータと比較し、不足している情報をフェッチし、キャッシュを更新し、データが利用可能になると &lt;code&gt;StoryContainer&lt;/code&gt; をレンダリングします。デフォルトでは、データのフェッチ中は何もレンダリングされませんが、ローディングビューは &lt;code&gt;render&lt;/code&gt; プロップを介してカスタマイズできます。Reactにより、開発者が基になるビューを直接操作せずにビューをレンダリングできるように、Relayと &lt;code&gt;Relay.Renderer&lt;/code&gt; はネットワークと直接通信する必要をなくします。</target>
        </trans-unit>
        <trans-unit id="af18c48993c9562a944639b49a29f4455950bbaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay&lt;/code&gt; is the entry point to the Relay library. If you're using one of the prebuilt packages it's available as a global; if you're using CommonJS modules you can &lt;code&gt;require()&lt;/code&gt; it.</source>
          <target state="translated">&lt;code&gt;Relay&lt;/code&gt; は、リレーライブラリへのエントリポイントです。ビルド済みのパッケージのいずれかを使用している場合は、グローバルとして使用できます。CommonJSモジュールを使用している場合は、 &lt;code&gt;require()&lt;/code&gt; できます。</target>
        </trans-unit>
        <trans-unit id="5c66e5b2f381152669b034d6f6167ad8cf6ed012" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayContainer&lt;/code&gt; is a higher-order React component that lets a React component encode its data requirements.</source>
          <target state="translated">&lt;code&gt;RelayContainer&lt;/code&gt; は、Reactコンポーネントがデータ要件をエンコードできるようにする高次のReactコンポーネントです。</target>
        </trans-unit>
        <trans-unit id="df2d84ab4a50cd1673857a423e00806293940147" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayMutationRequest&lt;/code&gt; encapsulates a mutation that Relay needs to send to the server. They are made available to network layers via the &lt;code&gt;sendMutation&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;RelayMutationRequest&lt;/code&gt; は、Relayがサーバーに送信する必要がある変更をカプセル化します。これらは、 &lt;code&gt;sendMutation&lt;/code&gt; メソッドを介してネットワークレイヤーで利用できます。</target>
        </trans-unit>
        <trans-unit id="e4dc52a29a31a839078a5cad953c9628f74f0f0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayMutationTransaction.getStatus&lt;/code&gt; can return one of the following strings:</source>
          <target state="translated">&lt;code&gt;RelayMutationTransaction.getStatus&lt;/code&gt; は、次の文字列のいずれかを返します。</target>
        </trans-unit>
        <trans-unit id="242d9ea8a1f2fba8d773760a8233ecf37bf7b5f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayQueryRequest&lt;/code&gt; encapsulates a query that Relay needs to send to the server. They are made available to network layers via the &lt;code&gt;sendQueries&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;RelayQueryRequest&lt;/code&gt; は、Relayがサーバーに送信する必要があるクエリをカプセル化します。これらは、 &lt;code&gt;sendQueries&lt;/code&gt; メソッドを介してネットワークレイヤーで利用できます。</target>
        </trans-unit>
        <trans-unit id="fa983dda38587dddabcba1aaf5a70bd38e50d1c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Selector&lt;/code&gt; (type): A selector defines the starting point for a traversal into the graph for the purposes of targeting a subgraph, combining a GraphQL fragment, variables, and the Data ID for the root object from which traversal should progress. Intuitively, this &quot;selects&quot; a portion of the object graph.</source>
          <target state="translated">&lt;code&gt;Selector&lt;/code&gt; （タイプ）：セレクターは、サブグラフをターゲットにする目的で、グラフへのトラバーサルの開始点を定義し、GraphQLフラグメント、変数、およびトラバーサルが進行するルートオブジェクトのデータIDを組み合わせます。直感的に、これはオブジェクトグラフの一部を「選択」します。</target>
        </trans-unit>
        <trans-unit id="af3c71166345fc66296a2fcfde6e211df573f098" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SkipRedundantNodeTransform&lt;/code&gt;: A more advanced version of flattening, this eliminates more complex cases of field duplication such as when a field is fetched both unconditionally and conditionally, or is fetched by two different sub-fragments. For example:</source>
          <target state="translated">&lt;code&gt;SkipRedundantNodeTransform&lt;/code&gt; ：フラット化のより高度なバージョン。これにより、フィールドが無条件と条件付きの両方でフェッチされる場合や、2つの異なるサブフラグメントによってフェッチされる場合など、フィールド重複のより複雑なケースが排除されます。例えば：</target>
        </trans-unit>
        <trans-unit id="fba6d300e8d2beebd7043543022bbc6158c521d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Snapshot&lt;/code&gt; (type): The (immutable) results of executing a &lt;code&gt;Selector&lt;/code&gt; at a given point in time. This includes the selector itself, the results of executing it, and a list of the Data IDs from which data was retrieved (useful in determining when these results might change).</source>
          <target state="translated">&lt;code&gt;Snapshot&lt;/code&gt; （タイプ）：特定の時点で &lt;code&gt;Selector&lt;/code&gt; を実行した（不変の）結果。これには、セレクター自体、セレクターの実行結果、およびデータの取得元のデータIDのリストが含まれます（これらの結果がいつ変更されるかを判断するのに役立ちます）。</target>
        </trans-unit>
        <trans-unit id="bd6f9d1898c7f71f61996e47d31e4669e9f6ea00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Store&lt;/code&gt; (type): The source of truth for an instance of &lt;code&gt;RelayRuntime&lt;/code&gt;, holding the canonical set of records in the form of a &lt;code&gt;RecordSource&lt;/code&gt; (though this is not required). Currently the only implementation is &lt;code&gt;RelayModernStore&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Store&lt;/code&gt; （タイプ）： &lt;code&gt;RelayRuntime&lt;/code&gt; のインスタンスの信頼できる情報源であり、レコードの正規のセットを &lt;code&gt;RecordSource&lt;/code&gt; の形式で保持します（これは必須ではありません）。現在、唯一の実装は &lt;code&gt;RelayModernStore&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="6953a65cec76dd55ffb8686c4013c2fe83a10320" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Transform&lt;/code&gt;: a &quot;map&quot;-like function that accepts a &lt;code&gt;CompilerContext&lt;/code&gt; as input and returns a new, modified context as output. Examples below.</source>
          <target state="translated">&lt;code&gt;Transform&lt;/code&gt; ： &lt;code&gt;CompilerContext&lt;/code&gt; を入力として受け入れ、新しい変更されたコンテキストを出力として返す「マップ」のような関数。以下の例。</target>
        </trans-unit>
        <trans-unit id="df62ea345a45d0a5fabcd2fdbf901148c6e5a8b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNCOMMITTED&lt;/code&gt; &amp;mdash; Transaction hasn't yet been sent to the server. Transaction can be committed or rolled back.</source>
          <target state="translated">&lt;code&gt;UNCOMMITTED&lt;/code&gt; &amp;mdash;トランザクションはまだサーバーに送信されていません。トランザクションはコミットまたはロールバックできます。</target>
        </trans-unit>
        <trans-unit id="251d369c69abccbd72c957636015d12c5ab2df7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cacheConfig?&lt;/code&gt;: Optional object containing a set of cache configuration options</source>
          <target state="translated">&lt;code&gt;cacheConfig?&lt;/code&gt; ：キャッシュ構成オプションのセットを含むオプションのオブジェクト</target>
        </trans-unit>
        <trans-unit id="44015182f39e2d46ef207ac1787ea9eab09b8733" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cacheConfig?&lt;/code&gt;: Optional object containing a set of cache configuration options, i.e. &lt;code&gt;force: true&lt;/code&gt; requires the fetch to be issued regardless of the state of any configured response cache.</source>
          <target state="translated">&lt;code&gt;cacheConfig?&lt;/code&gt; ：キャッシュ構成オプションのセットを含むオプションのオブジェクト。つまり、 &lt;code&gt;force: true&lt;/code&gt; では、構成された応答キャッシュの状態に関係なく、フェッチを発行する必要があります。</target>
        </trans-unit>
        <trans-unit id="a1e2ffe769d943340c0e937aef710727a6236ec6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cacheConfig?&lt;/code&gt;: Optional object containing a set of cache configuration options, i.e. &lt;code&gt;force: true&lt;/code&gt; requires the fetch to be issued regardless of the state of any configured response cache. See &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/relay-runtime/lib/util/RelayRuntimeTypes.d.ts#L22-L35&quot;&gt;the types&lt;/a&gt; for more &lt;code&gt;cacheConfig&lt;/code&gt; options.</source>
          <target state="translated">&lt;code&gt;cacheConfig?&lt;/code&gt; ：キャッシュ構成オプションのセットを含むオプションのオブジェクト。つまり、 &lt;code&gt;force: true&lt;/code&gt; では、構成された応答キャッシュの状態に関係なく、フェッチを発行する必要があります。その他の &lt;code&gt;cacheConfig&lt;/code&gt; オプションについて&lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/relay-runtime/lib/util/RelayRuntimeTypes.d.ts#L22-L35&quot;&gt;は、タイプ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="90c165e6157296f7bcc1ff33984b3b1b9a2c82c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;callback&lt;/code&gt;: Function called when the new page has been fetched. If an error occurred during refetch, this function will receive that error as an argument.</source>
          <target state="translated">&lt;code&gt;callback&lt;/code&gt; ：新しいページがフェッチされたときに呼び出される関数。再フェッチ中にエラーが発生した場合、この関数はそのエラーを引数として受け取ります。</target>
        </trans-unit>
        <trans-unit id="5a549ab3ecb985d7c1e6a0bcdb2975890cf8213e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;callback&lt;/code&gt;: Function to be called after the refetch has completed. If an error occurred during refetch, this function will receive that error as an argument.</source>
          <target state="translated">&lt;code&gt;callback&lt;/code&gt; ：再フェッチの完了後に呼び出される関数。再フェッチ中にエラーが発生した場合、この関数はそのエラーを引数として受け取ります。</target>
        </trans-unit>
        <trans-unit id="6ddb9c091b2339b506a0b25d46c1b43d0aec3f3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;component&lt;/code&gt;: The React Component &lt;em&gt;class&lt;/em&gt; of the component requiring the fragment data.</source>
          <target state="translated">&lt;code&gt;component&lt;/code&gt; ：フラグメントデータを必要とするコンポーネントのReactComponent&lt;em&gt;クラス&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="d84b6d9b41c57662dbad63044ec256b7ffeb4679" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;config&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="06f15b2aa1dd0d5d58698483052939daa832e202" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configs&lt;/code&gt;: Array containing objects describing &lt;code&gt;optimisticUpdater&lt;/code&gt;/&lt;code&gt;updater&lt;/code&gt; configurations. &lt;code&gt;configs&lt;/code&gt; provides a convenient way to specify the &lt;code&gt;updater&lt;/code&gt; behavior without having to write an &lt;code&gt;updater&lt;/code&gt; function. See our section on &lt;a href=&quot;#updater-configs&quot;&gt;Updater Configs&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;configs&lt;/code&gt; ： &lt;code&gt;optimisticUpdater&lt;/code&gt; / &lt;code&gt;updater&lt;/code&gt; 構成を説明するオブジェクトを含む配列。 &lt;code&gt;configs&lt;/code&gt; は、 &lt;code&gt;updater&lt;/code&gt; 関数を記述せずに &lt;code&gt;updater&lt;/code&gt; 動作を指定する便利な方法を提供します。詳細については、&lt;a href=&quot;#updater-configs&quot;&gt;アップデータ構成&lt;/a&gt;に関するセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="50a52e374bfb1a67a3f6d2363ba22492f2e2e80d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configs&lt;/code&gt;: an array containing the different optimisticUpdater/updater configurations. It provides a convenient way to specify the &lt;code&gt;updater&lt;/code&gt; behavior.</source>
          <target state="translated">&lt;code&gt;configs&lt;/code&gt; ：さまざまなoptimisticUpdater / updater構成を含む配列。これは、 &lt;code&gt;updater&lt;/code&gt; 動作を指定する便利な方法を提供します。</target>
        </trans-unit>
        <trans-unit id="7cc60f97e29bfb6ea62a807eae2cc5e7a17f3eb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configs&lt;/code&gt;: an array containing the updater configurations. It is the same as &lt;a href=&quot;mutations#configs&quot;&gt;&lt;code&gt;configs&lt;/code&gt;&lt;/a&gt; in &lt;code&gt;commitMutation&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;configs&lt;/code&gt; ：アップデーター構成を含む配列。それは同じである&lt;a href=&quot;mutations#configs&quot;&gt; &lt;code&gt;configs&lt;/code&gt; &lt;/a&gt;で &lt;code&gt;commitMutation&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62ed1b32bc4ea099a4726b7185046d66828e634b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configs&lt;/code&gt;: an array containing the updater configurations. It is the same as &lt;a href=&quot;mutations#updater-configs&quot;&gt;&lt;code&gt;configs&lt;/code&gt;&lt;/a&gt; in &lt;code&gt;commitMutation&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;configs&lt;/code&gt; ：アップデーター構成を含む配列。それは同じである&lt;a href=&quot;mutations#updater-configs&quot;&gt; &lt;code&gt;configs&lt;/code&gt; &lt;/a&gt;で &lt;code&gt;commitMutation&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="007117b0cb1510ebdd6ccffcf08576a3c37cde5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connectionConfig&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;connectionConfig&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="9394dd3d6a30c68a04fbce9521aacc5342c5da92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connectionInfo: Array&amp;lt;{key: string, filters?: Variables, rangeBehavior:
string}&amp;gt;&lt;/code&gt;: An array of objects containing a connection key, an object containing optional filters, and a range behavior depending on what behavior we expect (append, prepend, or ignore).</source>
          <target state="translated">&lt;code&gt;connectionInfo: Array&amp;lt;{key: string, filters?: Variables, rangeBehavior: string}&amp;gt;&lt;/code&gt; ：接続キーを含むオブジェクトの配列、オプションのフィルターを含むオブジェクト、および予想される動作（追加、先頭に追加、追加、または無視）。</target>
        </trans-unit>
        <trans-unit id="43c66a2069ec0b2d4be35833e1ae8977d9b93edf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connectionKeys: Array&amp;lt;{key: string, filters?: Variables}&amp;gt;&lt;/code&gt;: An array of objects containing a connection key and optionally filters.</source>
          <target state="translated">&lt;code&gt;connectionKeys: Array&amp;lt;{key: string, filters?: Variables}&amp;gt;&lt;/code&gt; ：接続キーとオプションでフィルターを含むオブジェクトの配列。</target>
        </trans-unit>
        <trans-unit id="3d66112758b5fe7d9ec709917fc9645fa7ce2017" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;createFragmentContainer&lt;/code&gt; has the following signature:</source>
          <target state="translated">&lt;code&gt;createFragmentContainer&lt;/code&gt; には次の署名があります。</target>
        </trans-unit>
        <trans-unit id="38957bb815ee45a69777b60c1f154618685af8ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;createPaginationContainer&lt;/code&gt; has the following signature:</source>
          <target state="translated">&lt;code&gt;createPaginationContainer&lt;/code&gt; には次の署名があります。</target>
        </trans-unit>
        <trans-unit id="3466a399b65ec8fadadd39718cdbdde5b6b2fc57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;createRefetchContainer&lt;/code&gt; has the following signature:</source>
          <target state="translated">&lt;code&gt;createRefetchContainer&lt;/code&gt; には次の署名があります。</target>
        </trans-unit>
        <trans-unit id="d19b3e482db84864f686a4ee3759da01773329b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deletedIDFieldName: string | Array&amp;lt;string&amp;gt;&lt;/code&gt;: The field name in the response that contains the DataID of the removed node, or the path to the node removed from the connection</source>
          <target state="translated">&lt;code&gt;deletedIDFieldName: string | Array&amp;lt;string&amp;gt;&lt;/code&gt; ：削除されたノードのDataIDを含む応答内のフィールド名、または接続から削除されたノードへのパス</target>
        </trans-unit>
        <trans-unit id="876617472fa789679ebf9a0b7c9f1eb24f355aa8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deletedIDFieldName: string | Array&amp;lt;string&amp;gt;&lt;/code&gt;: The field name in the response that contains the DataID or DataIDs of the removed node or nodes, or the path to the node or nodes removed from the connection</source>
          <target state="translated">&lt;code&gt;deletedIDFieldName: string | Array&amp;lt;string&amp;gt;&lt;/code&gt; ：削除された1つまたは複数のノードのDataIDまたはDataID、または接続から削除された1つまたは複数のノードへのパスを含む応答のフィールド名</target>
        </trans-unit>
        <trans-unit id="e977f6b2b4f562aa7af31b00751819ad50d520ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deletedIDFieldName: string&lt;/code&gt;: The field name in the response that contains the DataID of the deleted node</source>
          <target state="translated">&lt;code&gt;deletedIDFieldName: string&lt;/code&gt; ：削除されたノードのDataIDを含む応答のフィールド名</target>
        </trans-unit>
        <trans-unit id="bf1fd5c8652f9301a307527a2205d4d2b4a75a34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deletedIDFieldName: string&lt;/code&gt;: The field name in the response that contains the DataID or DataIDs of the deleted node or nodes</source>
          <target state="translated">&lt;code&gt;deletedIDFieldName: string&lt;/code&gt; ：削除された1つまたは複数のノードの1つまたは複数のDataIDを含む応答のフィールド名</target>
        </trans-unit>
        <trans-unit id="999f3fdfc8dda2a0f3aa0796444cc77a3d69202e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;direction&lt;/code&gt;: Either &quot;forward&quot; to indicate forward pagination using after/first, or &quot;backward&quot; to indicate backwards pagination using before/last. If not provided, Relay will infer the direction based on the provided &lt;code&gt;@connection&lt;/code&gt; directive.</source>
          <target state="translated">&lt;code&gt;direction&lt;/code&gt; ：「前方」は後/最初を使用して前方のページ付けを示すか、「後方」は前/最後を使用して後方のページ付けを示します。指定されていない場合、Relayは指定された &lt;code&gt;@connection&lt;/code&gt; ディレクティブに基づいて方向を推測します。</target>
        </trans-unit>
        <trans-unit id="22bd764f98c24605fee21c6e86534a102d352d4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;edgeName: string&lt;/code&gt;: The field name in the response that represents the newly created edge</source>
          <target state="translated">&lt;code&gt;edgeName: string&lt;/code&gt; ：新しく作成されたエッジを表す応答のフィールド名</target>
        </trans-unit>
        <trans-unit id="b7ab967dc3d9dac41042965f33de5bbacae6b0e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;environment&lt;/code&gt; An instance of `Relay.Environment` or any object that implements the `RelayEnvironment` interface.</source>
          <target state="translated">&lt;code&gt;environment&lt;/code&gt; `Relay.Environment`のインスタンス、または` RelayEnvironment`インターフェースを実装するオブジェクト。</target>
        </trans-unit>
        <trans-unit id="934fc584b2cbd07fff4713741be349d8db57ed53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;environment&lt;/code&gt;: The &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;environment&lt;/code&gt; ：&lt;a href=&quot;relay-environment&quot;&gt;リレー環境&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c04830e6cd3cb5a81acacd5ef47ab3c8d851603a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;environment&lt;/code&gt;: The &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt;. &lt;strong&gt;Note:&lt;/strong&gt; To ensure the mutation is performed on the correct &lt;code&gt;environment&lt;/code&gt;, it's recommended to use the environment available within components (from &lt;code&gt;this.props.relay.environment&lt;/code&gt;), instead of referencing a global environment.</source>
          <target state="translated">&lt;code&gt;environment&lt;/code&gt; ：&lt;a href=&quot;relay-environment&quot;&gt;リレー環境&lt;/a&gt;。&lt;strong&gt;注：変更&lt;/strong&gt;が正しい &lt;code&gt;environment&lt;/code&gt; で実行されるようにするには、グローバル環境を参照するのではなく、コンポーネント内で使用可能な環境（ &lt;code&gt;this.props.relay.environment&lt;/code&gt; から）を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="c42e0b6673753c1ecd9043bed1858fc0974cabb9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;environment&lt;/code&gt;: The current &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;environment&lt;/code&gt; ：現在の&lt;a href=&quot;relay-environment&quot;&gt;リレー環境&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="516a6ee32a7083dc25663e4b1b51d53113bbfc43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;error&lt;/code&gt;: Error will be defined if an error has occurred while fetching the query.</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt; ：クエリのフェッチ中にエラーが発生した場合、エラーが定義されます。</target>
        </trans-unit>
        <trans-unit id="933f09a28ce1c93df86693d7ec2e3b4c3c2c539a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fetchPolicy&lt;/code&gt;: If the data is already present in the store, using the &lt;code&gt;'store-or-network'&lt;/code&gt; option will use that data without making an additional network request. Using the &lt;code&gt;'network-only'&lt;/code&gt; option, which is the default behavior, will ignore any data present in the store and make a network request.</source>
          <target state="translated">&lt;code&gt;fetchPolicy&lt;/code&gt; ：データがストアにすでに存在する場合、 &lt;code&gt;'store-or-network'&lt;/code&gt; オプションを使用すると、追加のネットワーク要求を行うことなくそのデータが使用されます。デフォルトの動作である &lt;code&gt;'network-only'&lt;/code&gt; オプションを使用すると、ストアに存在するすべてのデータが無視され、ネットワーク要求が行われます。</target>
        </trans-unit>
        <trans-unit id="094d53375b81243f7e2c05c1de339c8e282ff5d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fetchPolicy?&lt;/code&gt;: Optional prop to indicate if data already present in the store should be used to render immediately and updated from the network afterwards using the &lt;code&gt;store-and-network&lt;/code&gt; key. Using the &lt;code&gt;network-only&lt;/code&gt; key, which is the default behavior, ignores data already present in the store and waits for the network results to come back.</source>
          <target state="translated">&lt;code&gt;fetchPolicy?&lt;/code&gt; ：ストアにすでに存在するデータを使用してすぐにレンダリングし、後で &lt;code&gt;store-and-network&lt;/code&gt; キーを使用してネットワークから更新する必要があるかどうかを示すオプションの小道具。デフォルトの動作である &lt;code&gt;network-only&lt;/code&gt; キーを使用すると、ストアにすでに存在するデータが無視され、ネットワークの結果が返されるのを待ちます。</target>
        </trans-unit>
        <trans-unit id="a2b9d698f04dcb6c9b4de74dbaccc7db4327ebbe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filters&lt;/code&gt;: &lt;strong&gt;Optional&lt;/strong&gt; Array of strings that belong to the set of argument variables defined for the connection field (e.g. &lt;code&gt;orderBy&lt;/code&gt;, &lt;code&gt;searchTerm&lt;/code&gt;, etc). The values for the variables specified in this array will be used alongside the user-supplied &lt;code&gt;key&lt;/code&gt; to uniquely identify a connection. If &lt;code&gt;filters&lt;/code&gt; is not provided, by default Relay will use the set of all of the arguments the connection field takes, excluding pagination specific arguments (i.e. &lt;code&gt;first&lt;/code&gt;/&lt;code&gt;last&lt;/code&gt;, &lt;code&gt;after&lt;/code&gt;/&lt;code&gt;before&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;filters&lt;/code&gt; ：&lt;strong&gt;オプション&lt;/strong&gt;接続フィールドに定義された引数変数のセットに属する文字列の配列（例： &lt;code&gt;orderBy&lt;/code&gt; 、 &lt;code&gt;searchTerm&lt;/code&gt; など）。この配列で指定された変数の値は、接続を一意に識別するためにユーザー指定の &lt;code&gt;key&lt;/code&gt; と一緒に使用されます。場合は &lt;code&gt;filters&lt;/code&gt; 設けられておらず、デフォルトでリレー（すなわちページネーションの特定の引数を除いて、接続フィールドが取るすべての引数のセットを使用する &lt;code&gt;first&lt;/code&gt; / &lt;code&gt;last&lt;/code&gt; 、 &lt;code&gt;after&lt;/code&gt; / &lt;code&gt;before&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6a65d389a718020e07ebee40da7bdd44c16a4420" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filters&lt;/code&gt;: An object containing GraphQL calls e.g. &lt;code&gt;const filters = {'orderby': 'chronological'};&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;filters&lt;/code&gt; ：GraphQL呼び出しを含むオブジェクト。例： &lt;code&gt;const filters = {'orderby': 'chronological'};&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="499b17304b2bef431abd97d0542599af80ca0ff3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;force&lt;/code&gt;: If the &lt;a href=&quot;network-layer&quot;&gt;Network Layer&lt;/a&gt; has been configured with a cache, this option forces a refetch even if the data for this query and variables is already available in the cache.</source>
          <target state="translated">&lt;code&gt;force&lt;/code&gt; ：&lt;a href=&quot;network-layer&quot;&gt;ネットワーク層&lt;/a&gt;がキャッシュで構成されている場合、このオプションは、このクエリと変数のデータがすでにキャッシュで使用可能であっても、強制的に再フェッチします。</target>
        </trans-unit>
        <trans-unit id="41eb5ef20bb9fe4e11e5a7ba243c250838991a3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forceFetch&lt;/code&gt; Whether to send a server request regardless of data available on the client.</source>
          <target state="translated">&lt;code&gt;forceFetch&lt;/code&gt; クライアントで使用可能なデータに関係なく、サーバー要求を送信するかどうか。</target>
        </trans-unit>
        <trans-unit id="d556d0cc8a6f2287f3af67eacd90ec1629094411" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forceFetch&lt;/code&gt; can be called with an empty set of partial variables, meaning it can trigger a refresh of the currently rendered set of data.</source>
          <target state="translated">&lt;code&gt;forceFetch&lt;/code&gt; は、部分変数の空のセットで呼び出すことができます。つまり、現在レンダリングされているデータセットの更新をトリガーできます。</target>
        </trans-unit>
        <trans-unit id="7c4e5ec515c48d1d775f76f1e41f31d520e97786" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forceFetch&lt;/code&gt; is similar to &lt;code&gt;setVariables&lt;/code&gt; because it is also used to change the data requirements by altering &lt;code&gt;variables&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;forceFetch&lt;/code&gt; は、 &lt;code&gt;variables&lt;/code&gt; を変更してデータ要件を変更するためにも使用されるため、 &lt;code&gt;setVariables&lt;/code&gt; に似ています。</target>
        </trans-unit>
        <trans-unit id="690e2c556d1d75133f45a6c4a69283c5b06e6d4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fragmentSpec&lt;/code&gt;: Specifies the data requirements for the Component via a GraphQL fragment. It is expected that one of the fragments specified here will contain a &lt;a href=&quot;#connection&quot;&gt;&lt;code&gt;@connection&lt;/code&gt;&lt;/a&gt; for pagination. The required data will be available on the component as props that match the shape of the provided fragment. &lt;code&gt;fragmentSpec&lt;/code&gt; should be an object whose keys are prop names and values are &lt;code&gt;graphql&lt;/code&gt; tagged fragments. Each key specified in this object will correspond to a prop available to the resulting Component.</source>
          <target state="translated">&lt;code&gt;fragmentSpec&lt;/code&gt; ：GraphQLフラグメントを介してコンポーネントのデータ要件を指定します。ここで指定されたフラグメントの1&lt;a href=&quot;#connection&quot;&gt; &lt;code&gt;@connection&lt;/code&gt; &lt;/a&gt;、ページ付けのための@connectionが含まれていると予想されます。必要なデータは、提供されたフラグメントの形状に一致する小道具としてコンポーネントで利用できます。 &lt;code&gt;fragmentSpec&lt;/code&gt; は、キーが小道具名であり、値が &lt;code&gt;graphql&lt;/code&gt; タグ付きフラグメントであるオブジェクトである必要があります。このオブジェクトで指定された各キーは、結果のコンポーネントで使用可能な小道具に対応します。</target>
        </trans-unit>
        <trans-unit id="3ebe3bc29a0cf52244f436e5b9f683f8e5e726a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fragmentSpec&lt;/code&gt;: Specifies the data requirements for the Component via a GraphQL fragment. The required data will be available on the component as props that match the shape of the provided fragment. &lt;code&gt;fragmentSpec&lt;/code&gt; should be an object whose keys are prop names and values are &lt;code&gt;graphql&lt;/code&gt; tagged fragments. Each key specified in this object will correspond to a prop available to the resulting Component.</source>
          <target state="translated">&lt;code&gt;fragmentSpec&lt;/code&gt; ：GraphQLフラグメントを介してコンポーネントのデータ要件を指定します。必要なデータは、提供されたフラグメントの形状に一致する小道具としてコンポーネントで利用できます。 &lt;code&gt;fragmentSpec&lt;/code&gt; は、キーが小道具名であり、値が &lt;code&gt;graphql&lt;/code&gt; タグ付きフラグメントであるオブジェクトである必要があります。このオブジェクトで指定された各キーは、結果のコンポーネントで使用可能な小道具に対応します。</target>
        </trans-unit>
        <trans-unit id="78c6f70e52f47838301be68f3a7fc35ddbd14be0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fragments&lt;/code&gt; Declare the component's data requirements using fragments.</source>
          <target state="translated">&lt;code&gt;fragments&lt;/code&gt; を使用してコンポーネントのデータ要件を宣言します。</target>
        </trans-unit>
        <trans-unit id="f347d7322bb64c982a8914c374d1d9989d23caa9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getConnectionFromProps&lt;/code&gt;: Function that should indicate which connection to paginate over, given the fragment props (i.e. the props corresponding to the &lt;code&gt;fragmentSpec&lt;/code&gt;). This is necessary in most cases because the Relay can't automatically tell which connection you mean to paginate over (a container might fetch multiple fragments and connections, but can only paginate one of them). If not provided, Relay will try infer the correct connection to paginate over based on the provided &lt;code&gt;@connection&lt;/code&gt; directive. See our &lt;a href=&quot;#pagination-example&quot;&gt;example&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;getConnectionFromProps&lt;/code&gt; ：フラグメントの小道具（つまり、 &lt;code&gt;fragmentSpec&lt;/code&gt; に対応する小道具）を指定して、ページネーションする接続を示す必要がある関数。これが必要なのは、ほとんどの場合、リレーがページ付けする接続を自動的に判別できないためです（コンテナーは複数のフラグメントと接続をフェッチする場合がありますが、ページ付けできるのはそのうちの1つだけです）。指定されていない場合、Relayは、指定された &lt;code&gt;@connection&lt;/code&gt; ディレクティブに基づいて、ページネーションするための正しい接続を推測しようとします。詳細については、&lt;a href=&quot;#pagination-example&quot;&gt;例&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="ffcebb96656094f38726e63b34eb65150f50c9ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getFragment(name[, vars])&lt;/code&gt; Get a reference to a container fragment for inclusion in a parent fragment.</source>
          <target state="translated">&lt;code&gt;getFragment(name[, vars])&lt;/code&gt; 親フラグメントに含めるコンテナフラグメントへの参照を取得します。</target>
        </trans-unit>
        <trans-unit id="cff5af6182f7fb8ef3f8ecccc18f0ba0cbe50adf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getFragmentVariables&lt;/code&gt;: Function that should return the bag of variables to use for reading out the data from the store when re-rendering the component. This function takes the previous set of variables passed to the pagination &lt;code&gt;query&lt;/code&gt;, and the number of elements that have been fetched in total so far. Specifically, this indicates which variables to use when reading out the data from the local data store &lt;em&gt;after&lt;/em&gt; the new pagination &lt;code&gt;query&lt;/code&gt; has been fetched. If not specified, Relay will default to using all of the previous variables and using the total count for the &lt;code&gt;count&lt;/code&gt; variable. This option is analogous to &lt;a href=&quot;refetch-container#refetch&quot;&gt;&lt;code&gt;renderVariables&lt;/code&gt;&lt;/a&gt; in the Refetch Container. See our &lt;a href=&quot;#pagination-example&quot;&gt;example&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;getFragmentVariables&lt;/code&gt; ：コンポーネントを再レンダリングするときにストアからデータを読み取るために使用する変数のバッグを返す必要がある関数。この関数は、ページネーション &lt;code&gt;query&lt;/code&gt; 渡された以前の変数のセットと、これまでにフェッチされた要素の数を取得します。具体的には、これは、新しいページネーション &lt;code&gt;query&lt;/code&gt; がフェッチされた&lt;em&gt;後に&lt;/em&gt;ローカルデータストアからデータを読み取るときに使用する変数を示します。指定しない場合、Relayはデフォルトで前のすべての変数を使用し、 &lt;code&gt;count&lt;/code&gt; 変数に合計カウントを使用します。このオプションは、リフェッチコンテナの&lt;a href=&quot;refetch-container#refetch&quot;&gt; &lt;code&gt;renderVariables&lt;/code&gt; &lt;/a&gt;に類似しています。&lt;a href=&quot;#pagination-example&quot;&gt;例を&lt;/a&gt;参照してください 詳細については。</target>
        </trans-unit>
        <trans-unit id="626651fb7fc8a336ea351887a559499388854ca0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getVariables&lt;/code&gt;: Function that should return the variables to pass to the pagination &lt;code&gt;query&lt;/code&gt; when fetching it from the server, given the current &lt;code&gt;props&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;cursor&lt;/code&gt;. You may set whatever variables here, as well as modify the defaults to use for after/first/before/last arguments. See our &lt;a href=&quot;#pagination-example&quot;&gt;example&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;getVariables&lt;/code&gt; ：現在の &lt;code&gt;props&lt;/code&gt; 、 &lt;code&gt;count&lt;/code&gt; 、 &lt;code&gt;cursor&lt;/code&gt; 指定して、サーバーからページネーション &lt;code&gt;query&lt;/code&gt; をフェッチするときに渡す変数を返す必要がある関数。ここで任意の変数を設定したり、after / first / before / last引数に使用するデフォルトを変更したりできます。詳細については、&lt;a href=&quot;#pagination-example&quot;&gt;例&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3a5a41dfd716e53597f64c88977873298358ac32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hasMore&lt;/code&gt; is a function available on the &lt;code&gt;relay&lt;/code&gt;&lt;a href=&quot;#available-props&quot;&gt;prop&lt;/a&gt;. This function indicates whether there are more pages to fetch from the server or not.</source>
          <target state="translated">&lt;code&gt;hasMore&lt;/code&gt; は、 &lt;code&gt;relay&lt;/code&gt; &lt;a href=&quot;#available-props&quot;&gt;プロップで&lt;/a&gt;使用できる機能です。この関数は、サーバーからフェッチするページがまだあるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="1035c3f8ef8bea7423860896c5ab932f003bfcca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hasMore&lt;/code&gt;: See &lt;code&gt;hasMore&lt;/code&gt;&lt;a href=&quot;#hasmore&quot;&gt;docs&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;hasMore&lt;/code&gt; ： &lt;code&gt;hasMore&lt;/code&gt; &lt;a href=&quot;#hasmore&quot;&gt;ドキュメントを&lt;/a&gt;参照してください</target>
        </trans-unit>
        <trans-unit id="4d2af946a8f787de1546269d02d1783ad16d7ce4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;initialVariables&lt;/code&gt; The initial set of variable values available to this component's fragments.</source>
          <target state="translated">&lt;code&gt;initialVariables&lt;/code&gt; このコンポーネントのフラグメントで使用できる変数値の初期セット。</target>
        </trans-unit>
        <trans-unit id="b0b6cb762b7bc1dde73e00ccfd867874ca46a854" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isLoading&lt;/code&gt; is a function available on the &lt;code&gt;relay&lt;/code&gt;&lt;a href=&quot;#available-props&quot;&gt;prop&lt;/a&gt;. This function indicates if a previous call to &lt;a href=&quot;#loadmore&quot;&gt;&lt;code&gt;loadMore()&lt;/code&gt;&lt;/a&gt; is still pending. This is convenient for avoiding duplicate load calls.</source>
          <target state="translated">&lt;code&gt;isLoading&lt;/code&gt; は、 &lt;code&gt;relay&lt;/code&gt; &lt;a href=&quot;#available-props&quot;&gt;プロップで&lt;/a&gt;使用できる関数です。この関数は、&lt;a href=&quot;#loadmore&quot;&gt; &lt;code&gt;loadMore()&lt;/code&gt; &lt;/a&gt;への以前の呼び出しがまだ保留中であるかどうかを示します。これは、重複するロード呼び出しを回避するのに便利です。</target>
        </trans-unit>
        <trans-unit id="c3cf1633778c794a6d5137a6fc7ee91e9dc015a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isLoading&lt;/code&gt;: See &lt;code&gt;isLoading&lt;/code&gt;&lt;a href=&quot;#isloading&quot;&gt;docs&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;isLoading&lt;/code&gt; ： &lt;code&gt;isLoading&lt;/code&gt; の&lt;a href=&quot;#isloading&quot;&gt;ドキュメントを&lt;/a&gt;参照してください</target>
        </trans-unit>
        <trans-unit id="f96bf65801e1e45617b0b7293698801c726cb5a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key&lt;/code&gt;: &lt;strong&gt;Required&lt;/strong&gt; String that serves as a unique identifier for the connection under the parent field type. A good practice could be &lt;code&gt;&amp;lt;ComponentName&amp;gt;_&amp;lt;fieldName | fieldAlias&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; ：親フィールドタイプでの接続の一意の識別子として機能する&lt;strong&gt;必須の&lt;/strong&gt;文字列。良い練習は可能性があり &lt;code&gt;&amp;lt;ComponentName&amp;gt;_&amp;lt;fieldName | fieldAlias&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="699706e765e60007f25a7dad7551d2b11ce95c76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loadMore&lt;/code&gt; is a function available on the &lt;code&gt;relay&lt;/code&gt;&lt;a href=&quot;#available-props&quot;&gt;prop&lt;/a&gt;. You can call &lt;code&gt;loadMore()&lt;/code&gt; to fetch more items from the server based on the &lt;code&gt;connectionConfig&lt;/code&gt; provided to the container. This will return null if there are no more items to fetch, otherwise it will fetch more items and return a Disposable that can be used to cancel the fetch.</source>
          <target state="translated">&lt;code&gt;loadMore&lt;/code&gt; は、 &lt;code&gt;relay&lt;/code&gt; &lt;a href=&quot;#available-props&quot;&gt;プロップで&lt;/a&gt;使用できる機能です。 &lt;code&gt;loadMore()&lt;/code&gt; を呼び出して、コンテナーに提供された &lt;code&gt;connectionConfig&lt;/code&gt; に基づいてサーバーからさらにアイテムをフェッチできます。フェッチするアイテムがこれ以上ない場合はnullを返します。それ以外の場合は、さらにアイテムをフェッチし、フェッチをキャンセルするために使用できるDisposableを返します。</target>
        </trans-unit>
        <trans-unit id="9fe3cacb8f804fae55fb785b3fe1234cd03400a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loadMore&lt;/code&gt;: See &lt;code&gt;loadMore&lt;/code&gt;&lt;a href=&quot;#loadmore&quot;&gt;docs&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;loadMore&lt;/code&gt; ： &lt;code&gt;loadMore&lt;/code&gt; &lt;a href=&quot;#loadmore&quot;&gt;ドキュメントを&lt;/a&gt;参照してください</target>
        </trans-unit>
        <trans-unit id="76264748ee4f7e2b85f5ec429b655faa6e2afb7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lookup(selector: Selector): Snapshot&lt;/code&gt;: Reads the results of a selector from the store, returning the value given the data currently in the store.</source>
          <target state="translated">&lt;code&gt;lookup(selector: Selector): Snapshot&lt;/code&gt; ：ストアからセレクターの結果を読み取り、現在ストアにあるデータを指定して値を返します。</target>
        </trans-unit>
        <trans-unit id="40b36321c1572c121ad403c4633eda3e50781805" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutation&lt;/code&gt;: The &lt;code&gt;graphql&lt;/code&gt; tagged mutation query.</source>
          <target state="translated">&lt;code&gt;mutation&lt;/code&gt; &lt;code&gt;graphql&lt;/code&gt; ：graphqlタグ付きミューテーションクエリ。</target>
        </trans-unit>
        <trans-unit id="563c728f73a72af11f9bfebcd489b1605c4ad5b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutation&lt;/code&gt;: the &lt;code&gt;graphql&lt;/code&gt; tagged mutation query.</source>
          <target state="translated">&lt;code&gt;mutation&lt;/code&gt; ： &lt;code&gt;graphql&lt;/code&gt; タグ付き突然変異クエリ。</target>
        </trans-unit>
        <trans-unit id="8757e61c041c5769ac4b56cae5108d1ce8243f0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notify(): void&lt;/code&gt;: Calls any &lt;code&gt;subscribe()&lt;/code&gt;-ers whose results have changed due to intervening &lt;code&gt;publish()&lt;/code&gt;-es. Separating &lt;code&gt;publish()&lt;/code&gt; and &lt;code&gt;notify()&lt;/code&gt; allows for multiple payloads to be published before performing any downstream update logic (such as rendering).</source>
          <target state="translated">&lt;code&gt;notify(): void&lt;/code&gt; ：任意の呼び出し &lt;code&gt;subscribe()&lt;/code&gt; その結果による介入に変更されました-ers &lt;code&gt;publish()&lt;/code&gt; -esを。 &lt;code&gt;publish()&lt;/code&gt; と &lt;code&gt;notify()&lt;/code&gt; を分離すると、ダウンストリームの更新ロジック（レンダリングなど）を実行する前に、複数のペイロードを公開できます。</target>
        </trans-unit>
        <trans-unit id="9bfa68e762b718f3167374497af4ce681b706e47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onCompleted&lt;/code&gt;: Callback function executed when the request is completed and the in-memory Relay store is updated with the &lt;code&gt;updater&lt;/code&gt; function. Takes a &lt;code&gt;response&lt;/code&gt; object, which is the updated response from the store, and &lt;code&gt;errors&lt;/code&gt;, an array containing any errors from the server.</source>
          <target state="translated">&lt;code&gt;onCompleted&lt;/code&gt; ：リクエストが完了し、メモリ内のリレーストアが &lt;code&gt;updater&lt;/code&gt; 関数で更新されたときに実行されるコールバック関数。かかる &lt;code&gt;response&lt;/code&gt; ストア、およびから更新応答であるオブジェクト、 &lt;code&gt;errors&lt;/code&gt; 、サーバからエラーを含む配列を。</target>
        </trans-unit>
        <trans-unit id="b6a934fa0ef96a565381122a89d9aee1a4fba9dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onCompleted&lt;/code&gt;: a callback function executed when the subscription is closed by the peer without error.</source>
          <target state="translated">&lt;code&gt;onCompleted&lt;/code&gt; ：サブスクリプションがピアによってエラーなしで閉じられたときに実行されるコールバック関数。</target>
        </trans-unit>
        <trans-unit id="a715680a7bcdc7a8e18cff64218bee6c4c5f714a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onCompleted&lt;/code&gt;: a callback function executed with the 'raw' response and errors from the server after the in-memory Relay store is updated with the &lt;code&gt;updater&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;onCompleted&lt;/code&gt; ：インメモリリレーストアが &lt;code&gt;updater&lt;/code&gt; 更新された後、サーバーからの「生の」応答とエラーで実行されるコールバック関数。</target>
        </trans-unit>
        <trans-unit id="6c178dbfaff171f363cbc5ee015a82adb2c39a56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onError&lt;/code&gt;: Callback function executed if Relay encounters an error during the request.</source>
          <target state="translated">&lt;code&gt;onError&lt;/code&gt; ：リレーがリクエスト中にエラーを検出した場合に実行されるコールバック関数。</target>
        </trans-unit>
        <trans-unit id="7e17c27700518dd0a0d9e3907f0ead05f610d8e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onError&lt;/code&gt;: a callback function executed when Relay encounters an error.</source>
          <target state="translated">&lt;code&gt;onError&lt;/code&gt; ：Relayでエラーが発生したときに実行されるコールバック関数。</target>
        </trans-unit>
        <trans-unit id="5632405e91380cb8466949662b4346c6b8f63bac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onError&lt;/code&gt;: a callback function executed when Relay or the server encounters an error processing the subscription.</source>
          <target state="translated">&lt;code&gt;onError&lt;/code&gt; ：リレーまたはサーバーがサブスクリプションの処理中にエラーを検出したときに実行されるコールバック関数。</target>
        </trans-unit>
        <trans-unit id="13f38fe85bb18ed69b3110347c91c063ca63f296" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onFailure&lt;/code&gt; is called if the mutation failed.</source>
          <target state="translated">&lt;code&gt;onFailure&lt;/code&gt; は、変更が失敗した場合に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="34b282489eb2fc659bf8f182ecccfa58a4f98bbf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onNext&lt;/code&gt;: a callback function executed each time a response is received from the server, with the raw GraphQL response payload.</source>
          <target state="translated">&lt;code&gt;onNext&lt;/code&gt; ：生のGraphQL応答ペイロードを使用して、サーバーから応答を受信するたびに実行されるコールバック関数。</target>
        </trans-unit>
        <trans-unit id="b0c18e8b6186d7338bef8b15b59ec6ca63cd0225" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onSuccess&lt;/code&gt; is called if the mutation succeeded.</source>
          <target state="translated">&lt;code&gt;onSuccess&lt;/code&gt; 突然変異が成功した場合、onSuccessが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="f106ec445789577b27b8a00bf7ea0a1de269df16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optimisticResponse&lt;/code&gt;: Object containing the data to optimistically update the local in-memory store, i.e. immediately, before the mutation request has completed. This object must have the same shape as the mutation's response type, as defined by the GraphQL schema. If provided, Relay will use the &lt;code&gt;optimisticResponse&lt;/code&gt; data to update the fields on the relevant records in the local data store, &lt;em&gt;before&lt;/em&gt;&lt;code&gt;optimisticUpdater&lt;/code&gt; is executed. If an error occurs during the mutation request, the optimistic update will be rolled back.</source>
          <target state="translated">&lt;code&gt;optimisticResponse&lt;/code&gt; ：ローカルのメモリ内ストアを楽観的に更新するためのデータを含むオブジェクト。つまり、ミューテーション要求が完了する直前。このオブジェクトは、GraphQLスキーマで定義されているように、ミューテーションの応答タイプと同じ形状である必要があります。提供されている場合、Relayは、 &lt;code&gt;optimisticUpdater&lt;/code&gt; が実行される&lt;em&gt;前に&lt;/em&gt;、 &lt;code&gt;optimisticResponse&lt;/code&gt; データを使用してローカルデータストア内の関連レコードのフィールドを更新します。ミューテーションリクエスト中にエラーが発生した場合、楽観的な更新はロールバックされます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5a1dc36be8e9a3f9069b3ce5c93735b18dee1d9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optimisticResponse&lt;/code&gt;: an object conforming to the mutation's response type definition. If provided, the optimistic response will be normalized to the proxy store before &lt;code&gt;optimisticUpdater&lt;/code&gt; is executed. We suggest you provide an &lt;code&gt;optimisticResponse&lt;/code&gt; for two benefits:</source>
          <target state="translated">&lt;code&gt;optimisticResponse&lt;/code&gt; ：ミューテーションのレスポンスタイプ定義に準拠するオブジェクト。提供された場合、 &lt;code&gt;optimisticUpdater&lt;/code&gt; が実行される前に、オプティミスティックレスポンスがプロキシストアに正規化されます。次の2つのメリットについて、 &lt;code&gt;optimisticResponse&lt;/code&gt; を提供することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="bbad0ba283ad50214764ae5e67837a37a21bb012" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optimisticUpdater&lt;/code&gt;: Function used to optimistically update the local in-memory store, i.e. immediately, before the mutation request has completed. If an error occurs during the mutation request, the optimistic update will be rolled back. This function takes a &lt;code&gt;store&lt;/code&gt;, which is a proxy of the in-memory &lt;a href=&quot;relay-store&quot;&gt;Relay Store&lt;/a&gt;. In this function, the client defines 'how to' update the local data via the &lt;code&gt;store&lt;/code&gt; instance. For details on how to use the &lt;code&gt;store&lt;/code&gt;, please refer to our &lt;a href=&quot;relay-store&quot;&gt;Relay Store API Reference&lt;/a&gt;. &lt;strong&gt;Please note:&lt;/strong&gt;</source>
          <target state="translated">&lt;code&gt;optimisticUpdater&lt;/code&gt; ：ローカルのメモリ内ストアを楽観的に更新するために使用される関数。つまり、ミューテーション要求が完了する直前。ミューテーションリクエスト中にエラーが発生した場合、楽観的な更新はロールバックされます。この機能は、かかる &lt;code&gt;store&lt;/code&gt; 、メモリ内のプロキシで、&lt;a href=&quot;relay-store&quot;&gt;リレーストア&lt;/a&gt;。この関数では、クライアントは &lt;code&gt;store&lt;/code&gt; インスタンスを介してローカルデータを更新する方法を定義します。 &lt;code&gt;store&lt;/code&gt; 使用方法の詳細については、&lt;a href=&quot;relay-store&quot;&gt;Relay StoreAPIリファレンス&lt;/a&gt;を参照してください。&lt;strong&gt;ご注意ください：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ace8dc4f2ade074a4518666a5d5ce3fc892c20c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optimisticUpdater&lt;/code&gt;: a function that takes in a proxy of the in-memory Relay store. In this function, the client defines 'how to' update the store through the proxy in an imperative way.</source>
          <target state="translated">&lt;code&gt;optimisticUpdater&lt;/code&gt; ：インメモリリレーストアのプロキシを取り込む関数。この関数では、クライアントは、命令型の方法でプロキシを介してストアを更新する「方法」を定義します。</target>
        </trans-unit>
        <trans-unit id="5c56eae08c5039c703ead5297dcb43b136ebc215" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options&lt;/code&gt;: Optional object containing set of options.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; ：オプションのセットを含むオプションのオブジェクト。</target>
        </trans-unit>
        <trans-unit id="6f1ee884cdcbedfd5023f2b423e04d3d21c8d4a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pageSize&lt;/code&gt;: The number of &lt;strong&gt;additional&lt;/strong&gt; items to fetch (not the total).</source>
          <target state="translated">&lt;code&gt;pageSize&lt;/code&gt; ：フェッチする&lt;strong&gt;追加&lt;/strong&gt;アイテムの数（合計ではありません）。</target>
        </trans-unit>
        <trans-unit id="b45ed0f29925a557b65dfee5d20499e8f93783ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parentID: string&lt;/code&gt;: The DataID of the parent node that contains the connection.</source>
          <target state="translated">&lt;code&gt;parentID: string&lt;/code&gt; ：接続を含む親ノードのDataID。</target>
        </trans-unit>
        <trans-unit id="90d6f234e369d7056e4a4a384ce4d56b75c66508" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pathToConnection: Array&amp;lt;string&amp;gt;&lt;/code&gt;: An array containing the field names between the parent and the connection, including the parent and the connection.</source>
          <target state="translated">&lt;code&gt;pathToConnection: Array&amp;lt;string&amp;gt;&lt;/code&gt; ：親と接続を含む、親と接続の間のフィールド名を含む配列。</target>
        </trans-unit>
        <trans-unit id="ca3a99f863b6d6006d89f122d91acd2466426ca1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pendingVariables&lt;/code&gt; contains the set of variables that are being used to fetch the new props, i.e. when &lt;code&gt;this.props.relay.setVariables()&lt;/code&gt; or &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt; are called and the corresponding request is in flight.</source>
          <target state="translated">&lt;code&gt;pendingVariables&lt;/code&gt; には、新しいプロップをフェッチするために使用されている変数のセットが含まれています。つまり、 &lt;code&gt;this.props.relay.setVariables()&lt;/code&gt; または &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt; が呼び出され、対応するリクエストが実行中である場合です。</target>
        </trans-unit>
        <trans-unit id="5294d02523abdadc7890c4089fd2d771e0103adf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prepareVariables&lt;/code&gt; A method to modify the variables based on the runtime environment or previous variable values.</source>
          <target state="translated">&lt;code&gt;prepareVariables&lt;/code&gt; ランタイム環境または以前の変数値に基づいて変数を変更するメソッド。</target>
        </trans-unit>
        <trans-unit id="27da47c52c7e5a8a5a90e5286ef17b4aff5e91dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;props&lt;/code&gt;: Object containing data obtained from the query; the shape of this object will match the shape of the query. If this object is not defined, it means that the data is still being fetched.</source>
          <target state="translated">&lt;code&gt;props&lt;/code&gt; ：クエリから取得したデータを含むオブジェクト。このオブジェクトの形状は、クエリの形状と一致します。このオブジェクトが定義されていない場合は、データがまだフェッチされていることを意味します。</target>
        </trans-unit>
        <trans-unit id="8d5f419565d76e695cd1691d3b10750a870140ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;publish(source: RecordSource): void&lt;/code&gt;: Update the store with new information. All updates to the store are expressed in this form, including the results of queries/mutation/subscriptions as well as optimistic mutation updates. All of those operations internally create a new &lt;code&gt;RecordSource&lt;/code&gt; instance and ultimately publish it to the store. Note that &lt;code&gt;publish()&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; immediately update any &lt;code&gt;subscribe()&lt;/code&gt;-ers. Internally, the store compares the new &lt;code&gt;RecordSource&lt;/code&gt; with its internal source, updating it as necessary:</source>
          <target state="translated">&lt;code&gt;publish(source: RecordSource): void&lt;/code&gt; ：ストアを新しい情報で更新します。ストアへのすべての更新は、クエリ/ミューテーション/サブスクリプションの結果や楽観的なミューテーションの更新を含め、この形式で表されます。これらの操作はすべて、内部で新しい &lt;code&gt;RecordSource&lt;/code&gt; インスタンスを作成し、最終的にそれをストアに公開します。 &lt;code&gt;publish()&lt;/code&gt; は &lt;code&gt;subscribe()&lt;/code&gt; - ersをすぐには更新し&lt;em&gt;ない&lt;/em&gt;ことに注意してください。内部的に、ストアは新しい &lt;code&gt;RecordSource&lt;/code&gt; を内部ソースと比較し、必要に応じて更新します。</target>
        </trans-unit>
        <trans-unit id="dddbd60d4182ffffea94bf3a02f0ae852dd10463" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;query&lt;/code&gt;: A &lt;code&gt;graphql&lt;/code&gt; tagged query to be used as the pagination query to fetch more data upon calling &lt;a href=&quot;#loadmore&quot;&gt;&lt;code&gt;loadMore&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;query&lt;/code&gt; ：A &lt;code&gt;graphql&lt;/code&gt; タグ付けされたクエリを呼び出すときに、より多くのデータをフェッチするためにページネーションクエリとして使用する&lt;a href=&quot;#loadmore&quot;&gt; &lt;code&gt;loadMore&lt;/code&gt; を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7736ddcb416c3d04d04b11455e591b874d6eeb31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;query&lt;/code&gt;: The &lt;code&gt;graphql&lt;/code&gt; tagged query. &lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;relay-compiler&lt;/code&gt; enforces the query to be named as &lt;code&gt;&amp;lt;FileName&amp;gt;Query&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;query&lt;/code&gt; ： &lt;code&gt;graphql&lt;/code&gt; タグ付きクエリ。&lt;strong&gt;注：&lt;/strong&gt; &lt;code&gt;relay-compiler&lt;/code&gt; は、クエリに &lt;code&gt;&amp;lt;FileName&amp;gt;Query&lt;/code&gt; という名前を付けるように強制します。</target>
        </trans-unit>
        <trans-unit id="676a2960bbec143afaff222f0801213498fb3f55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;query&lt;/code&gt;: The &lt;code&gt;graphql&lt;/code&gt; tagged query. &lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;relay-compiler&lt;/code&gt; enforces the query to be named as &lt;code&gt;&amp;lt;FileName&amp;gt;Query&lt;/code&gt;. Optional, if not provided, an empty &lt;code&gt;props&lt;/code&gt; object is passed to the &lt;code&gt;render&lt;/code&gt; callback.</source>
          <target state="translated">&lt;code&gt;query&lt;/code&gt; ： &lt;code&gt;graphql&lt;/code&gt; タグ付きクエリ。&lt;strong&gt;注：&lt;/strong&gt; &lt;code&gt;relay-compiler&lt;/code&gt; は、クエリに &lt;code&gt;&amp;lt;FileName&amp;gt;Query&lt;/code&gt; という名前を付けるように強制します。オプションで、指定されていない場合、空の &lt;code&gt;props&lt;/code&gt; オブジェクトが &lt;code&gt;render&lt;/code&gt; コールバックに渡されます。</target>
        </trans-unit>
        <trans-unit id="85e836212ec7a6f4cf39b03986865be121a0bbd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;queryConfig&lt;/code&gt; `QueryConfig` or `Relay.Route` that defines the query roots.</source>
          <target state="translated">&lt;code&gt;queryConfig&lt;/code&gt; クエリのルートを定義するqueryConfig `QueryConfig`または` Relay.Route`。</target>
        </trans-unit>
        <trans-unit id="660ec684b77a45a8bf1e84dae51a6cda4f520d7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetch&lt;/code&gt; has the following signature:</source>
          <target state="translated">&lt;code&gt;refetch&lt;/code&gt; には次の署名があります。</target>
        </trans-unit>
        <trans-unit id="58466669d85d4a95720a5f7d66d78440d31839cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetch&lt;/code&gt; is a function available on the &lt;code&gt;relay&lt;/code&gt;&lt;a href=&quot;#available-props&quot;&gt;prop&lt;/a&gt; which can be used to execute the &lt;code&gt;refetchQuery&lt;/code&gt; and potentially re-render the component with the newly fetched data. Specifically, upon fetching the &lt;code&gt;refetchQuery&lt;/code&gt;, its result will be normalized into the store, and any relevant subscriptions associated with the changed records will be fired, causing relevant components to re-render.</source>
          <target state="translated">&lt;code&gt;refetch&lt;/code&gt; 上で利用可能な機能である &lt;code&gt;relay&lt;/code&gt; &lt;a href=&quot;#available-props&quot;&gt;プロップ&lt;/a&gt;実行するために使用することができる &lt;code&gt;refetchQuery&lt;/code&gt; を、潜在的に新たにフェッチされたデータを持つコンポーネントを再レンダリングします。具体的には、 &lt;code&gt;refetchQuery&lt;/code&gt; をフェッチすると、その結果がストアに正規化され、変更されたレコードに関連付けられている関連するサブスクリプションが起動され、関連するコンポーネントが再レンダリングされます。</target>
        </trans-unit>
        <trans-unit id="ac65c56250fa7ff709fdc7de7fca9f97dfd96bfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetch&lt;/code&gt;: See &lt;code&gt;refetch&lt;/code&gt;&lt;a href=&quot;#refetch&quot;&gt;docs&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;refetch&lt;/code&gt; ：再 &lt;code&gt;refetch&lt;/code&gt; &lt;a href=&quot;#refetch&quot;&gt;ドキュメントを&lt;/a&gt;参照してください</target>
        </trans-unit>
        <trans-unit id="76ca6f4f7119df5fafa685e8fb3699107703e078" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetchConnection&lt;/code&gt; is a function available on the &lt;code&gt;relay&lt;/code&gt;&lt;a href=&quot;#available-props&quot;&gt;prop&lt;/a&gt;. You can call &lt;code&gt;refetchConnection&lt;/code&gt; to restart pagination on a connection from scratch, with optionally a completely new set of variables to pass to the pagination &lt;code&gt;query&lt;/code&gt;. This is useful for example if you are paginating over a collection based on a userID and the userID changes, you'd want to start paginating over the new collection for the new user.</source>
          <target state="translated">&lt;code&gt;refetchConnection&lt;/code&gt; は、上で利用できる機能です &lt;code&gt;relay&lt;/code&gt; &lt;a href=&quot;#available-props&quot;&gt;小道具&lt;/a&gt;。 &lt;code&gt;refetchConnection&lt;/code&gt; を呼び出して、接続のページネーションを最初から再開でき &lt;code&gt;query&lt;/code&gt; 。オプションで、ページネーションクエリに渡す完全に新しい変数のセットを使用できます。これは、たとえば、userIDに基づいてコレクションのページ付けを行っていて、userIDが変更された場合に、新しいユーザーの新しいコレクションのページ付けを開始する場合に便利です。</target>
        </trans-unit>
        <trans-unit id="7ef81b21678260e29c69b60a2bcfd25a86847861" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetchConnection&lt;/code&gt;: See &lt;code&gt;refetchConnection&lt;/code&gt;&lt;a href=&quot;#refetchconnection&quot;&gt;docs&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;refetchConnection&lt;/code&gt; ： &lt;code&gt;refetchConnection&lt;/code&gt; の&lt;a href=&quot;#refetchconnection&quot;&gt;ドキュメントを&lt;/a&gt;参照してください</target>
        </trans-unit>
        <trans-unit id="10676cecd666f761ab642682bd7775c74b16d502" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetchQuery&lt;/code&gt;: A &lt;code&gt;graphql&lt;/code&gt; tagged query to be fetched upon calling &lt;a href=&quot;#refetch&quot;&gt;&lt;code&gt;props.relay.refetch&lt;/code&gt;&lt;/a&gt;. As with any query, upon fetching this query, its result will be normalized into the store, any relevant subscriptions associated with the changed records will be fired, and subscribed components will re-render.</source>
          <target state="translated">&lt;code&gt;refetchQuery&lt;/code&gt; ：A &lt;code&gt;graphql&lt;/code&gt; タグ付けされたクエリを呼び出すときにフェッチされる&lt;a href=&quot;#refetch&quot;&gt; &lt;code&gt;props.relay.refetch&lt;/code&gt; を&lt;/a&gt;。他のクエリと同様に、このクエリをフェッチすると、その結果はストアに正規化され、変更されたレコードに関連付けられている関連するサブスクリプションが発生し、サブスクライブされたコンポーネントが再レンダリングされます。</target>
        </trans-unit>
        <trans-unit id="32d83449d21fcdf971b3e1c1d76474fe6f62d3af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetchVariables&lt;/code&gt; is either a bag of variables or a function that takes in the previous fragment variables and returns new variables.</source>
          <target state="translated">&lt;code&gt;refetchVariables&lt;/code&gt; は、変数のバッグ、または前のフラグメント変数を取り込んで新しい変数を返す関数のいずれかです。</target>
        </trans-unit>
        <trans-unit id="d29742cf5cf442b9264eba2a1008fd847c52bb3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetchVariables&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;refetchVariables&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="82c4436a668f413322c65f8837cdeba1c55ebf58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetchVariables&lt;/code&gt;: A potentially new bag of variables to pass to the pagination &lt;code&gt;query&lt;/code&gt; when fetching it from the server.</source>
          <target state="translated">&lt;code&gt;refetchVariables&lt;/code&gt; ：サーバーからフェッチするときにページネーション &lt;code&gt;query&lt;/code&gt; に渡す可能性のある新しい変数のバッグ。</target>
        </trans-unit>
        <trans-unit id="eccac01b26009021b9b8585de4682fa623cd62b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;relay&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;relay&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="4ae4f5a5447be2154beefea2867a35b518a781d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;render&lt;/code&gt; Called to render when data requirements are being fulfilled.</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; データ要件が満たされているときにレンダリングするために呼び出されます。</target>
        </trans-unit>
        <trans-unit id="3a3d4b8d0af15655fd443916c3671fd28e5c8260" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;render&lt;/code&gt;: Function of type &lt;code&gt;({error, props, retry}) =&amp;gt; React.Node&lt;/code&gt;. The output of this function will be rendered by the &lt;code&gt;QueryRenderer&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; ：タイプの関数 &lt;code&gt;({error, props, retry}) =&amp;gt; React.Node&lt;/code&gt; 。この関数の出力は、 &lt;code&gt;QueryRenderer&lt;/code&gt; によってレンダリングされます。</target>
        </trans-unit>
        <trans-unit id="55e1260e99e337d383bed6b4b9c2df2228a1e749" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderFailure&lt;/code&gt; Called to render when data failed to be fulfilled.</source>
          <target state="translated">&lt;code&gt;renderFailure&lt;/code&gt; データの実行に失敗したときにレンダリングするために呼び出されます。</target>
        </trans-unit>
        <trans-unit id="a6131b3d70611a404b4ea7dd80f5758c5105f7c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderFetched&lt;/code&gt; Called to render when data requirements are fulfilled.</source>
          <target state="translated">&lt;code&gt;renderFetched&lt;/code&gt; データ要件が満たされたときにレンダリングするために呼び出されます。</target>
        </trans-unit>
        <trans-unit id="1901f50529efd372e2c626214284f332709348a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderLoading&lt;/code&gt; Called to render when data requirements are being fulfilled.</source>
          <target state="translated">&lt;code&gt;renderLoading&lt;/code&gt; データ要件が満たされているときにレンダリングするために呼び出されます。</target>
        </trans-unit>
        <trans-unit id="b0fe2435dec450eee6998923c41267267d40d7d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderVariables&lt;/code&gt; is an optional param that tells Relay which variables to use at when the component is re-rendered after fetching. Without this, the &lt;code&gt;refetchVariables&lt;/code&gt; will be used. You might use this for more advanced usage, for example, to implement pagination, where you would fetch an additional page with variables like &lt;code&gt;{first: 5, after: '...'}&lt;/code&gt;, but you would then render the full collection with &lt;code&gt;{first: 10}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;renderVariables&lt;/code&gt; は、フェッチ後にコンポーネントが再レンダリングされるときに使用する変数をRelayに指示するオプションのパラメーターです。これがない場合、 &lt;code&gt;refetchVariables&lt;/code&gt; が使用されます。これを使用して、たとえば、ページ付けを実装するためのより高度な使用法があります。ここでは、 &lt;code&gt;{first: 5, after: '...'}&lt;/code&gt; ような変数を含む追加のページをフェッチしますが、その後、 &lt;code&gt;{first: 10}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d435346ad63d7a3c79570642e3436876c685e77c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderVariables&lt;/code&gt;: Optional bag of variables that indicate which variables to use for reading out the data from the store when re-rendering the component. Specifically, this indicates which variables to use when querying the data from the local data store &lt;em&gt;after&lt;/em&gt; the new query has been fetched. If not specified, the &lt;code&gt;refetchVariables&lt;/code&gt; will be used. This is useful when the data you need to render in your component doesn't necessarily match the data you queried the server for. For example, to implement pagination, you would fetch a page with variables like &lt;code&gt;{first: 5, after: '&amp;lt;cursor&amp;gt;'}&lt;/code&gt;, but you might want to render the full collection with &lt;code&gt;{first: 10}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;renderVariables&lt;/code&gt; ：コンポーネントを再レンダリングするときにストアからデータを読み取るために使用する変数を示すオプションの変数バッグ。具体的には、これは、新しいクエリがフェッチされた&lt;em&gt;後に&lt;/em&gt;ローカルデータストアからデータをクエリするときに使用する変数を示します。指定しない場合、 &lt;code&gt;refetchVariables&lt;/code&gt; が使用されます。これは、コンポーネントでレンダリングする必要のあるデータが、サーバーに照会したデータと必ずしも一致しない場合に役立ちます。たとえば、ページネーションを実装するには、 &lt;code&gt;{first: 5, after: '&amp;lt;cursor&amp;gt;'}&lt;/code&gt; ような変数でページをフェッチしますが、コレクション全体を &lt;code&gt;{first: 10}&lt;/code&gt; レンダリングしたい場合があります。</target>
        </trans-unit>
        <trans-unit id="e8a7275c94b7363157c7bfb49920e6d9a95cf6ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retain(selector: Selector): Disposable&lt;/code&gt;: Ensure that all the records necessary to fulfill the given selector are retained in-memory. The records will not be eligible for garbage collection until the returned reference is disposed.</source>
          <target state="translated">&lt;code&gt;retain(selector: Selector): Disposable&lt;/code&gt; ：指定されたセレクターを満たすために必要なすべてのレコードがメモリ内に保持されていることを確認します。返された参照が破棄されるまで、レコードはガベージコレクションの対象にはなりません。</target>
        </trans-unit>
        <trans-unit id="d6d78182a7d6ce562110f2264694e37c53c96b2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retry&lt;/code&gt;: Reload the data. It is null if &lt;code&gt;query&lt;/code&gt; was not provided.</source>
          <target state="translated">&lt;code&gt;retry&lt;/code&gt; ：データをリロードします。 &lt;code&gt;query&lt;/code&gt; が提供されなかった場合はnullです。</target>
        </trans-unit>
        <trans-unit id="0cef4511de2692e7e2831022f07230dabf3496cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;route&lt;/code&gt; Route that defines the query roots.</source>
          <target state="translated">&lt;code&gt;route&lt;/code&gt; クエリルートを定義するルート。</target>
        </trans-unit>
        <trans-unit id="de20a20a67577265acad0e1c8760490f6ae7d671" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setVariables&lt;/code&gt; does not immediately mutate &lt;code&gt;variables&lt;/code&gt;, but creates a pending state transition. &lt;code&gt;variables&lt;/code&gt; will continue returning the previous values until &lt;code&gt;this.props&lt;/code&gt; has been populated with data that fulfills the new variable values.</source>
          <target state="translated">&lt;code&gt;setVariables&lt;/code&gt; は &lt;code&gt;variables&lt;/code&gt; すぐには変更しませんが、保留中の状態遷移を作成します。 &lt;code&gt;this.props&lt;/code&gt; に新しい変数値を満たすデータが入力されるまで、 &lt;code&gt;variables&lt;/code&gt; は以前の値を返し続けます。</target>
        </trans-unit>
        <trans-unit id="943d019e3b13e343df13a6484ab6136c7156b4e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shouldComponentUpdate&lt;/code&gt; Optionally override RelayContainer's default implementation of `shouldComponentUpdate`.</source>
          <target state="translated">&lt;code&gt;shouldComponentUpdate&lt;/code&gt; オプションで、RelayContainerの `shouldComponentUpdate`のデフォルト実装をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="c12be4a70a038cd4741cb2b9e30195491469abee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static Container: ReactPropTypeValidator&lt;/code&gt; A prop type validator asserting that a prop is a valid Relay container.</source>
          <target state="translated">&lt;code&gt;static Container: ReactPropTypeValidator&lt;/code&gt; プロップが有効なリレーコンテナーであることを表明するプロップタイプバリデーター。</target>
        </trans-unit>
        <trans-unit id="3b4467abcecc2f5f6147438c2f223473973407a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static QueryConfig: ReactPropTypeValidator&lt;/code&gt; A prop type validator asserting that a prop is a valid route.</source>
          <target state="translated">&lt;code&gt;static QueryConfig: ReactPropTypeValidator&lt;/code&gt; プロップが有効なルートであることを表明するプロップタイプバリデーター。</target>
        </trans-unit>
        <trans-unit id="40e983f1da84aaeb0774f71c8242e17b35be1f2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static applyUpdate(mutation, callbacks)&lt;/code&gt; Adds a MutationTransaction to the queue without committing it.</source>
          <target state="translated">&lt;code&gt;static applyUpdate(mutation, callbacks)&lt;/code&gt; MutationTransactionをコミットせずにキューに追加します。</target>
        </trans-unit>
        <trans-unit id="b4d03961b864a4ab573535d598407abfc411cce4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static commitUpdate(mutation, callbacks)&lt;/code&gt; Initiate processing of a mutation.</source>
          <target state="translated">&lt;code&gt;static commitUpdate(mutation, callbacks)&lt;/code&gt; 処理を開始します。</target>
        </trans-unit>
        <trans-unit id="9eebf1a07ed283d2bbed2b968ffb38df36fad9ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static create(mutation, variables, environment)&lt;/code&gt; Create a static mutation</source>
          <target state="translated">&lt;code&gt;static create(mutation, variables, environment)&lt;/code&gt; 静的ミューテーションを作成します</target>
        </trans-unit>
        <trans-unit id="658d18c4b39964f6d9e02a8d4f13d6ca5179a919" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static createContainer(Component, ContainerConfig)&lt;/code&gt; Creates a Relay Container.</source>
          <target state="translated">&lt;code&gt;static createContainer(Component, ContainerConfig)&lt;/code&gt; リレーコンテナを作成します。</target>
        </trans-unit>
        <trans-unit id="ac50a770322cba5b662ec0bbf60235d57453db96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static createWithFiles(mutation, variables, files, environment)&lt;/code&gt; Create a static mutation that accepts a &quot;files&quot; object</source>
          <target state="translated">&lt;code&gt;static createWithFiles(mutation, variables, files, environment)&lt;/code&gt; 「ファイル」オブジェクトを受け入れる静的ミューテーションを作成します</target>
        </trans-unit>
        <trans-unit id="a985a4f33765191da82de5eb97d6c665b299a3b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static fragments&lt;/code&gt; Declare this mutation's data dependencies here</source>
          <target state="translated">&lt;code&gt;static fragments&lt;/code&gt; ここでこのミューテーションのデータ依存関係を宣言します</target>
        </trans-unit>
        <trans-unit id="a1697fb2f2da73763242483e979b5b34e6797e53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static initialVariables&lt;/code&gt; A default set of variables to make available to this mutation's fragment builders</source>
          <target state="translated">&lt;code&gt;static initialVariables&lt;/code&gt; このミューテーションのフラグメントビルダーで使用できるようにするデフォルトの変数セット</target>
        </trans-unit>
        <trans-unit id="9ac61312fa144b893336d3bbdf88826d0034494e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static injectNetworkLayer(networkLayer)&lt;/code&gt; Customize how queries and mutations are sent to the server.</source>
          <target state="translated">&lt;code&gt;static injectNetworkLayer(networkLayer)&lt;/code&gt; クエリとミューテーションをサーバーに送信する方法をカスタマイズします。</target>
        </trans-unit>
        <trans-unit id="49b31e2fd0ee618819eb9668ad9fab057dc448c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static injectTaskScheduler(scheduler)&lt;/code&gt; Configure when Relay processing occurs.</source>
          <target state="translated">&lt;code&gt;static injectTaskScheduler(scheduler)&lt;/code&gt; リレー処理が発生するタイミングを構成します。</target>
        </trans-unit>
        <trans-unit id="3e8afe33d507124df2cb20b712a24c4d395ceeb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static isContainer(Component)&lt;/code&gt; Determine if a given object is a Relay.Container.</source>
          <target state="translated">&lt;code&gt;static isContainer(Component)&lt;/code&gt; 指定されたオブジェクトがRelay.Containerかどうかを判断します。</target>
        </trans-unit>
        <trans-unit id="7938dae1f9d2455348151916c16933ea1c4109f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static paramDefinitions&lt;/code&gt; Declare the expected parameters.</source>
          <target state="translated">&lt;code&gt;static paramDefinitions&lt;/code&gt; 必要なパラメーターを宣言します。</target>
        </trans-unit>
        <trans-unit id="047db3ec3d910088d59dd144e9064188d5d64b54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static prepareParams&lt;/code&gt; Declare additional parameters or conversion for parameters.</source>
          <target state="translated">&lt;code&gt;static prepareParams&lt;/code&gt; 追加のパラメーターまたはパラメーターの変換を宣言します。</target>
        </trans-unit>
        <trans-unit id="4b2b9762a4218dc52cee63114d0eee0ed5d04c5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static prepareVariables&lt;/code&gt; A method to modify the variables based on the runtime environment, previous variables, or the meta route</source>
          <target state="translated">&lt;code&gt;static prepareVariables&lt;/code&gt; ランタイム環境、以前の変数、またはメタルートに基づいて変数を変更するメソッド</target>
        </trans-unit>
        <trans-unit id="2b49e3d2f4dae0d69deb0f6c24085a44cc8a3c5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static queries&lt;/code&gt; Declare the set of query roots.</source>
          <target state="translated">&lt;code&gt;static queries&lt;/code&gt; クエリルートのセットを宣言します。</target>
        </trans-unit>
        <trans-unit id="0c43ab95deb00b1e6ba46964ae86ac05d717b874" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static routeName&lt;/code&gt; Declare the name of this route class.</source>
          <target state="translated">&lt;code&gt;static routeName&lt;/code&gt; このルートクラスの名前を宣言します。</target>
        </trans-unit>
        <trans-unit id="4d2883724190fe655277a940ee21fbf4028c5557" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subscribe(snapshot: Snapshot, callback: (snapshot: Snapshot) =&amp;gt; void): Disposable&lt;/code&gt;: Subscribe to changes to the results of a selector. The callback is called when data has been published to the store that would cause the results of the snapshot's selector to change.</source>
          <target state="translated">&lt;code&gt;subscribe(snapshot: Snapshot, callback: (snapshot: Snapshot) =&amp;gt; void): Disposable&lt;/code&gt; ：セレクターの結果への変更をサブスクライブします。コールバックは、スナップショットのセレクターの結果を変更するデータがストアに公開されたときに呼び出されます。</target>
        </trans-unit>
        <trans-unit id="91acf728df7357ed2ba9977f2e4aae1aa271198d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subscription&lt;/code&gt;: the &lt;code&gt;graphql&lt;/code&gt; tagged subscription query.</source>
          <target state="translated">&lt;code&gt;subscription&lt;/code&gt; ： &lt;code&gt;graphql&lt;/code&gt; タグ付きサブスクリプションクエリ。</target>
        </trans-unit>
        <trans-unit id="12ff8bacf233237929ba38ec484648a655ad7959" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.relay.setVariables&lt;/code&gt; can be called to update a subset or all of the variables at the same time. In return, Relay will use the new variables to attempt to fulfill the new fragment. This may involve sending a request to the server if data is not already available on the client.</source>
          <target state="translated">&lt;code&gt;this.props.relay.setVariables&lt;/code&gt; を呼び出して、サブセットまたはすべての変数を同時に更新できます。代わりに、Relayは新しい変数を使用して、新しいフラグメントの実行を試みます。データがクライアントでまだ利用できない場合、これにはサーバーへのリクエストの送信が含まれる場合があります。</target>
        </trans-unit>
        <trans-unit id="c005f6461f75206bcbc927906f1de20a4cf2e450" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.relay&lt;/code&gt; exports the following API to execute the refetch query:</source>
          <target state="translated">&lt;code&gt;this.props.relay&lt;/code&gt; は、次のAPIをエクスポートして、再フェッチクエリを実行します。</target>
        </trans-unit>
        <trans-unit id="7d9577972a7c4a8c614b22a037eaeff82248e3f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.relay&lt;/code&gt; exposes the following APIs:</source>
          <target state="translated">&lt;code&gt;this.props.relay&lt;/code&gt; は、次のAPIを公開します。</target>
        </trans-unit>
        <trans-unit id="3d07b37e84a778ceb1461d9bbc1f056984d50a27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.setVariables&lt;/code&gt; from the old API does not have a direct equivalent in the new API. A big reason for this change is that the new core no longer tracks how to refetch any specific sub-tree from the query. This makes the new core a lot faster, but requires explicit queries for how to fetch new data. Check out these four different scenarios:</source>
          <target state="translated">&lt;code&gt;this.props.setVariables&lt;/code&gt; 古いAPIのthis.props.setVariablesには、新しいAPIに直接対応するものはありません。この変更の大きな理由は、新しいコアがクエリから特定のサブツリーを再フェッチする方法を追跡しなくなったことです。これにより、新しいコアが大幅に高速化されますが、新しいデータをフェッチする方法を明示的に照会する必要があります。次の4つの異なるシナリオを確認してください。</target>
        </trans-unit>
        <trans-unit id="63392efb72105686affa5267c72c15150a57d7b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;totalCount&lt;/code&gt;: The total number of elements to fetch</source>
          <target state="translated">&lt;code&gt;totalCount&lt;/code&gt; ：フェッチする要素の総数</target>
        </trans-unit>
        <trans-unit id="a3ba6c9e4640fb1b2e64f085573522ecee404aff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updater&lt;/code&gt; and &lt;code&gt;optimisticUpdater&lt;/code&gt; are functions that you can pass to a &lt;code&gt;commitMutation&lt;/code&gt; call when you need full control over how to update the local data store, either optimistically, or based on a server response. Often times, both of these can be the same function.</source>
          <target state="translated">&lt;code&gt;updater&lt;/code&gt; と &lt;code&gt;optimisticUpdater&lt;/code&gt; はあなたに渡すことができる機能です &lt;code&gt;commitMutation&lt;/code&gt; のローカルデータストアを更新する方法を完全に制御する必要がある場合のいずれか楽観的、またはサーバの応答に基づいて、コール。多くの場合、これらの両方が同じ機能である可能性があります。</target>
        </trans-unit>
        <trans-unit id="259e28d5505528a6b53e6871c75fe6204e8b732e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updater&lt;/code&gt;: Function used to update the local in-memory store based on the &lt;strong&gt;real&lt;/strong&gt; server response from the mutation. If &lt;code&gt;updater&lt;/code&gt; is not provided, by default, Relay will know to automatically update the fields on the records referenced in the mutation response; however, you should pass an &lt;code&gt;updater&lt;/code&gt; if you need to make more complicated updates than just updating fields (e.g. deleting records or adding items to collections). When the server response comes back, Relay first reverts any changes introduced by &lt;code&gt;optimisticUpdater&lt;/code&gt; or &lt;code&gt;optimisticResponse&lt;/code&gt; and will then execute &lt;code&gt;updater&lt;/code&gt;. This function takes a &lt;code&gt;store&lt;/code&gt;, which is a proxy of the in-memory &lt;a href=&quot;relay-store&quot;&gt;Relay Store&lt;/a&gt;. In this function, the client defines 'how to' update the local data based on the server response via the &lt;code&gt;store&lt;/code&gt; instance. For details on how to use the &lt;code&gt;store&lt;/code&gt;, please refer to our &lt;a href=&quot;relay-store&quot;&gt;Relay Store API Reference&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;updater&lt;/code&gt; ：ミューテーションからの&lt;strong&gt;実&lt;/strong&gt;サーバーの応答に基づいてローカルのメモリ内ストアを更新するために使用される関数。場合は &lt;code&gt;updater&lt;/code&gt; 提供されていない、デフォルトでは、リレーは自動的に突然変異応答の中で参照、レコードのフィールドを更新するために知っているだろう。ただし、フィールドの更新（レコードの削除やコレクションへのアイテムの追加など）よりも複雑な更新を行う必要がある場合は、 &lt;code&gt;updater&lt;/code&gt; を渡す必要があります。サーバーの応答が返されると、Relayは最初に &lt;code&gt;optimisticUpdater&lt;/code&gt; または &lt;code&gt;optimisticResponse&lt;/code&gt; によって導入された変更を元に戻し、次に &lt;code&gt;updater&lt;/code&gt; を実行します。この関数は、メモリ内のプロキシである &lt;code&gt;store&lt;/code&gt; 取得します&lt;a href=&quot;relay-store&quot;&gt;リレーストア&lt;/a&gt;。この関数では、クライアントは、 &lt;code&gt;store&lt;/code&gt; インスタンスを介したサーバーの応答に基づいてローカルデータを更新する方法を定義します。 &lt;code&gt;store&lt;/code&gt; 使用方法の詳細については、&lt;a href=&quot;relay-store&quot;&gt;Relay StoreAPIリファレンス&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="25ab1a5db284767b82e6bbe83b1d6bb7782d76cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updater&lt;/code&gt;: a function that updates the in-memory Relay store based on the &lt;strong&gt;real&lt;/strong&gt; server response. When the server response comes back, Relay first reverts any changes introduced by &lt;code&gt;optimisticUpdater&lt;/code&gt; or &lt;code&gt;optimisticResponse&lt;/code&gt; and then applies the &lt;code&gt;updater&lt;/code&gt; to the store.</source>
          <target state="translated">&lt;code&gt;updater&lt;/code&gt; ：&lt;strong&gt;実&lt;/strong&gt;サーバーの応答に基づいてインメモリリレーストアを更新する関数。サーバーの応答が返されると、Relayは最初に &lt;code&gt;optimisticUpdater&lt;/code&gt; または &lt;code&gt;optimisticResponse&lt;/code&gt; によって導入された変更を元に戻し、次に &lt;code&gt;updater&lt;/code&gt; をストアに適用します。</target>
        </trans-unit>
        <trans-unit id="9e752995a456f07b23c9c5955036c90c0eaa7d48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updater&lt;/code&gt;: an optional function that can supply custom logic for updating the in-memory Relay store based on the server response.</source>
          <target state="translated">&lt;code&gt;updater&lt;/code&gt; ：サーバーの応答に基づいてインメモリリレーストアを更新するためのカスタムロジックを提供できるオプションの関数。</target>
        </trans-unit>
        <trans-unit id="ed67a9853586c7a825bf549e62d6668d890318cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt; contains the set of variables that was used to fetch the current set of props.</source>
          <target state="translated">&lt;code&gt;variables&lt;/code&gt; には、現在の小道具のセットを取得するために使用された変数のセットが含まれています。</target>
        </trans-unit>
        <trans-unit id="90132fff5a43a587dfddbf62f547768d85225cbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt;: Object containing set of variables to pass to the GraphQL query, i.e. a mapping from variable name to value.</source>
          <target state="translated">&lt;code&gt;variables&lt;/code&gt; ：GraphQLクエリに渡す変数のセットを含むオブジェクト。つまり、変数名から値へのマッピング。</target>
        </trans-unit>
        <trans-unit id="9b2d4dca964b4002488e5ba0931c7fdd0e1843a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt;: Object containing set of variables to pass to the GraphQL query, i.e. a mapping from variable name to value. &lt;strong&gt;Note:&lt;/strong&gt; If a new set of variables is passed, the &lt;code&gt;QueryRenderer&lt;/code&gt; will re-fetch the query.</source>
          <target state="translated">&lt;code&gt;variables&lt;/code&gt; ：GraphQLクエリに渡す変数のセットを含むオブジェクト。つまり、変数名から値へのマッピング。&lt;strong&gt;注：&lt;/strong&gt;新しい変数のセットが渡されると、 &lt;code&gt;QueryRenderer&lt;/code&gt; はクエリを再フェッチします。</target>
        </trans-unit>
        <trans-unit id="0475335b0b11da8a5bdf97828dbf873aa0e03035" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt;: Object containing the variables needed for the mutation. For example, if the mutation defines an &lt;code&gt;$input&lt;/code&gt; variable, this object should contain an &lt;code&gt;input&lt;/code&gt; key, whose shape must match the shape of the data expected by the mutation as defined by the GraphQL schema.</source>
          <target state="translated">&lt;code&gt;variables&lt;/code&gt; ：突然変異に必要な変数を含むオブジェクト。たとえば、ミューテーションが &lt;code&gt;$input&lt;/code&gt; 変数を定義する場合、このオブジェクトには &lt;code&gt;input&lt;/code&gt; キーが含まれている必要があります。このキーの形状は、GraphQLスキーマで定義されているミューテーションで予期されるデータの形状と一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="7e388933696fbe367df975da86d5ab73799cb8d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt;: an object that contains the variables needed for the mutation.</source>
          <target state="translated">&lt;code&gt;variables&lt;/code&gt; ：ミューテーションに必要な変数を含むオブジェクト。</target>
        </trans-unit>
        <trans-unit id="6e219c17510eb13b16577519ca778d9468c7499a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt;: an object that contains the variables needed for the subscription.</source>
          <target state="translated">&lt;code&gt;variables&lt;/code&gt; ：サブスクリプションに必要な変数を含むオブジェクト。</target>
        </trans-unit>
        <trans-unit id="a3d9fd11099be9837becddb07ecac412bfe16922" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;code&gt;babel-relay-plugin&lt;/code&gt; is deprecated. Use &lt;a href=&quot;babel-plugin-relay#using-with-relay-classic&quot;&gt;&lt;code&gt;babel-plugin-relay&lt;/code&gt;&lt;/a&gt; with Relay Classic.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;babel-relay-plugin&lt;/code&gt; は非推奨です。Relay Classicで&lt;a href=&quot;babel-plugin-relay#using-with-relay-classic&quot;&gt; &lt;code&gt;babel-plugin-relay&lt;/code&gt; &lt;/a&gt;を使用します。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="885b12f18c1ce790e1ceb37bdac14666bf969046" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Container Specification&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;コンテナ仕様&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2dc48bdb0f1a664344b42c6cc9f80bf54c93c0af" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Methods&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Methods&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="372322cdb4339a090833f173c5459433d9f3a2a3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Properties and Methods&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;プロパティとメソッド&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2e24a7da3b4c78d1c9bb8ad4a5672d259fcf1c7d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Properties&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Properties&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b288f7cf5165d63b23f3a477f7c62696473947e3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Props&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Props&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c13abeef99d46d6cc5a5891d80bde92ef26cfbac" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Static Methods&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;静的メソッド&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f0677ff5e5e4c313a098291e00353714c69a25eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphcool/graphql-up&quot;&gt;graphql-up&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/graphql-up&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphcool/graphql-up&quot;&gt;graphqlアップ&lt;/a&gt;&lt;/strong&gt;の&lt;a href=&quot;https://www.npmjs.com/package/graphql-up&quot;&gt; NPM&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a854faa5d5c2fb2a3f2a62f519c3dae0ea44c47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;express-graphql&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/express-graphql&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;急行-graphql&lt;/a&gt;&lt;/strong&gt;上の&lt;a href=&quot;https://www.npmjs.com/package/express-graphql&quot;&gt; NPM&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6882e7b1150b43a134cd9463ab13037397e9d8a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;graphql-js&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/graphql&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;graphql-jsから&lt;/a&gt;&lt;/strong&gt;の&lt;a href=&quot;https://www.npmjs.com/package/graphql&quot;&gt; NPM&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4615a7abdf175713f1dd713a45e9b36b49db0dd8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;graphql-relay-js&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/graphql-relay&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;graphqlリレー-jsから&lt;/a&gt;&lt;/strong&gt;の&lt;a href=&quot;https://www.npmjs.com/package/graphql-relay&quot;&gt; NPM&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0cf00569ac1dc01caeaaea97e38c45c13b4f2663" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/relay-tools/react-relay-network-modern&quot;&gt;react-relay-network-modern&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/react-relay-network-modern&quot;&gt;npm&lt;/a&gt; - is a Network Layer for Relay Modern which has built-in highly customizable middlewares for commonly used scenarios: batching query requests, caching, authentication, request retrying, logging. Moreover, you may write your own middlewares with custom logic.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/relay-tools/react-relay-network-modern&quot;&gt;react-relay-network-modern&lt;/a&gt;&lt;/strong&gt; on&lt;a href=&quot;https://www.npmjs.com/package/react-relay-network-modern&quot;&gt; npm-&lt;/a&gt;は、Relay Modernのネットワーク層であり、クエリリクエストのバッチ処理、キャッシュ、認証、リクエストの再試行、ロギングなど、一般的に使用されるシナリオ向けに高度にカスタマイズ可能なミドルウェアが組み込まれています。さらに、カスタムロジックを使用して独自のミドルウェアを作成することもできます。</target>
        </trans-unit>
        <trans-unit id="57698c2dcaa9317f5b6564784890d536ca0db31a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://www.graph.cool/&quot;&gt;Graphcool&lt;/a&gt;&lt;/strong&gt; (&lt;a href=&quot;https://www.graph.cool/docs/quickstart/&quot;&gt;Quickstart tutorial&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://www.graph.cool/&quot;&gt;Graphcool&lt;/a&gt;&lt;/strong&gt;（&lt;a href=&quot;https://www.graph.cool/docs/quickstart/&quot;&gt;クイックスタートチュートリアル&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="3ff63fe8231293f18f4614046a48a3f375957330" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; An optimistic update may only be applied once.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;楽観的な更新は1回のみ適用できます。</target>
        </trans-unit>
        <trans-unit id="5a6c17b257e2cfbdb037b374e043ded0a3a0687b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Equivalent &lt;code&gt;applyUpdate&lt;/code&gt; and &lt;code&gt;commitUpdate&lt;/code&gt; methods are also provided on the &lt;code&gt;this.props.relay&lt;/code&gt; prop that is passed to components by &lt;code&gt;Relay.Container&lt;/code&gt;. These dispatch mutations in the context of the currently active &lt;code&gt;Relay.Environment&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;同等の &lt;code&gt;applyUpdate&lt;/code&gt; および &lt;code&gt;commitUpdate&lt;/code&gt; メソッドも、 &lt;code&gt;this.props.relay&lt;/code&gt; によってコンポーネントに渡されるthis.props.relayプロップで提供され &lt;code&gt;Relay.Container&lt;/code&gt; 。これらは、現在アクティブな &lt;code&gt;Relay.Environment&lt;/code&gt; のコンテキストでミューテーションをディスパッチします。</target>
        </trans-unit>
        <trans-unit id="9ddd68157613fe72f3a31d973424adc5689fd03d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The relay-compiler will maintain any directives supported by your server (such as &lt;code&gt;@include&lt;/code&gt; or &lt;code&gt;@skip&lt;/code&gt;) so they remain part of the request to the GraphQL server and won't alter generated runtime artifacts.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt; relay-compilerは、サーバーでサポートされているディレクティブ（ &lt;code&gt;@include&lt;/code&gt; や &lt;code&gt;@skip&lt;/code&gt; など）を維持するため、それらはGraphQLサーバーへの要求の一部のままであり、生成されたランタイムアーティファクトを変更しません。</target>
        </trans-unit>
        <trans-unit id="9339553ac0cb3d1045417a0b2b8896e539d03c5a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;refetch&lt;/code&gt; is meant to be used for changing variables in the component's fragment. Specifically, in order for &lt;em&gt;this&lt;/em&gt; component to re-render, it must be subscribed to changes in the records affected by this query. If the fragment for the component doesn't use variables, the component won't be subscribed to changes to new records that might be fetched by this query. A common example of this is using &lt;code&gt;refetch&lt;/code&gt; to fetch a new node and re-render the component with the data for the new node; in this case the fragment needs to use a variable for the node's id, otherwise the component won't pick up the changes for the new node.</source>
          <target state="translated">&lt;strong&gt;注：再&lt;/strong&gt; &lt;code&gt;refetch&lt;/code&gt; は、コンポーネントのフラグメント内の変数を変更するために使用することを目的としています。具体的には、&lt;em&gt;この&lt;/em&gt;コンポーネントを再レンダリングするには、このクエリの影響を受けるレコードの変更をサブスクライブする必要があります。コンポーネントのフラグメントが変数を使用しない場合、コンポーネントは、このクエリによってフェッチされる可能性のある新しいレコードへの変更にサブスクライブされません。この一般的な例を使用して &lt;code&gt;refetch&lt;/code&gt; 新しいノードをフェッチし、新しいノードのデータを持つコンポーネントを再レンダリング。この場合、フラグメントはノードのIDに変数を使用する必要があります。そうしないと、コンポーネントは新しいノードの変更を取得しません。</target>
        </trans-unit>
        <trans-unit id="fce6daad416ee7ed28c950cdb80e05140a6ea38d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;relay-compiler&lt;/code&gt; enforces fragments to be named as &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt; &lt;code&gt;relay-compiler&lt;/code&gt; は、フラグメントに &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; という名前を付けるように強制します。</target>
        </trans-unit>
        <trans-unit id="1cab013d8e57c0158f4b400d4d762529e18b3a5a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this will not remove it from any connection it might be in. If you want to remove a node from a connection, take a look at &lt;a href=&quot;#RANGE_DELETE&quot;&gt;RANGE_DELETE&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：これにより、接続されている可能性のある接続からノードが削除されることはありません。接続からノードを削除する場合は、&lt;a href=&quot;#RANGE_DELETE&quot;&gt;RANGE_DELETEを&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="c0b283c8b5fe80a6754d48027d166c1b33cf5b5d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;React/Relay:&lt;/strong&gt; A high-level &lt;em&gt;product API&lt;/em&gt; that integrates the Relay Runtime with React. This is the primary public interface to Relay for most product developers, featuring APIs to fetch the data for a query or define data dependencies for reusable components (aka containers).</source>
          <target state="translated">&lt;strong&gt;React / Relay：&lt;/strong&gt;リレーランタイムをReactと統合する高レベルの&lt;em&gt;製品API&lt;/em&gt;。これは、ほとんどの製品開発者にとって、Relayへの主要なパブリックインターフェイスであり、クエリのデータをフェッチしたり、再利用可能なコンポーネント（別名コンテナ）のデータ依存関係を定義したりするAPIを備えています。</target>
        </trans-unit>
        <trans-unit id="efdd8302b44cc971aea46ff3458176ce0281a174" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay Compiler:&lt;/strong&gt; A GraphQL to GraphQL optimizing &lt;em&gt;compiler&lt;/em&gt;, providing general utilities for transforming and optimizing queries as well as generating build artifacts. A novel feature of the compiler is that it facilitates experimentation with new GraphQL features - in the form of custom directives - by making it easy to translate code using these directives into standard, spec-compliant GraphQL.</source>
          <target state="translated">&lt;strong&gt;リレーコンパイラ：&lt;/strong&gt; GraphQLからGraphQLへの最適化&lt;em&gt;コンパイラ&lt;/em&gt;。クエリの変換と最適化、およびビルドアーティファクトの生成のための一般的なユーティリティを提供します。コンパイラーの新しい機能は、これらのディレクティブを使用してコードを標準の仕様準拠のGraphQLに簡単に変換できるようにすることで、新しいGraphQL機能（カスタムディレクティブの形式）の実験を容易にすることです。</target>
        </trans-unit>
        <trans-unit id="c4b7a80e6d04a3ccce4e25ffec6090751cc2e7f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay Runtime:&lt;/strong&gt; A full-featured, high-performance GraphQL &lt;em&gt;runtime&lt;/em&gt; that can be used to build higher-level client APIs. The runtime features a normalized object cache, optimized &quot;write&quot; and &quot;read&quot; operations, a generic abstraction for incrementally fetching field data (such as for pagination), garbage collection for removing unreferenced cache entries, optimistic mutations with arbitrary logic, support for building subscriptions and live queries, and more.</source>
          <target state="translated">&lt;strong&gt;リレーランタイム：&lt;/strong&gt;高レベルのクライアントAPIを構築するために使用できるフル機能の高性能GraphQL&lt;em&gt;ランタイム&lt;/em&gt;。ランタイムは、正規化されたオブジェクトキャッシュ、最適化された「書き込み」および「読み取り」操作、フィールドデータを段階的にフェッチするための一般的な抽象化（ページ付けなど）、参照されていないキャッシュエントリを削除するためのガベージコレクション、任意のロジックによる楽観的な変更、ビルドのサポートを備えていますサブスクリプションやライブクエリなど。</target>
        </trans-unit>
        <trans-unit id="3d08f9d41d143a0795971f924c815549c54cd145" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.Container&lt;/strong&gt; lets components declare fragments.</source>
          <target state="translated">&lt;strong&gt;Relay.Containerを&lt;/strong&gt;使用すると、コンポーネントでフラグメントを宣言できます。</target>
        </trans-unit>
        <trans-unit id="90f9832c4e0fd7965e487450fd253cb3d30e8335" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.Renderer&lt;/strong&gt; is a replacement for &lt;code&gt;Relay.RootContainer&lt;/code&gt; that composes a &lt;code&gt;Relay.ReadyStateRenderer&lt;/code&gt; and performs data fetching for a given &lt;code&gt;queryConfig&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Relay.Rendererで&lt;/strong&gt;の置き換えである &lt;code&gt;Relay.RootContainer&lt;/code&gt; 構成 &lt;code&gt;Relay.ReadyStateRenderer&lt;/code&gt; 所与のためのフェッチと実行データ &lt;code&gt;queryConfig&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="4e196f3c49ca550a94a96a6bd405ee5ae569ab33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; accepts three optional callbacks as props that give us more fine-grained control over the render behavior.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;は、3つのオプションのコールバックを小道具として受け入れ、レンダリング動作をより細かく制御できるようにします。</target>
        </trans-unit>
        <trans-unit id="39c403bfc5a5ae739fbb717b4e88e8b5cb484d46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; also supports the &lt;code&gt;onReadyStateChange&lt;/code&gt; prop which lets us receive fine-grained events as they occur while fulfilling the data requirements.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;は &lt;code&gt;onReadyStateChange&lt;/code&gt; プロップもサポートします。これにより、データ要件を満たしている間に発生した細かいイベントを受け取ることができます。</target>
        </trans-unit>
        <trans-unit id="3d6f9d2435421026549fceef7e0844d153a49bfa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; is a React component that attempts to fulfill the data required in order to render an instance of &lt;code&gt;Component&lt;/code&gt; for a given &lt;code&gt;route&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;は、指定された &lt;code&gt;route&lt;/code&gt; &lt;code&gt;Component&lt;/code&gt; のインスタンスをレンダリングするために必要なデータを&lt;strong&gt;満たそう&lt;/strong&gt;とするReactコンポーネントです。</target>
        </trans-unit>
        <trans-unit id="a2469cd762b58409f3e67b96bf307621bbbfad9c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; is a React component that, given a &lt;code&gt;Component&lt;/code&gt; and a &lt;code&gt;route&lt;/code&gt;, attempts to fulfill the data required in order to render an instance of &lt;code&gt;Component&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;はReactコンポーネントであり、 &lt;code&gt;Component&lt;/code&gt; と &lt;code&gt;route&lt;/code&gt; 指定すると、 &lt;code&gt;Component&lt;/code&gt; のインスタンスをレンダリングするために必要なデータを&lt;strong&gt;満たそ&lt;/strong&gt;うとします。</target>
        </trans-unit>
        <trans-unit id="a3a1abc25b49b43dce645669aa17f103661474d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; renders the loading state whenever it cannot immediately fulfill data needed to render. This often happens on the initial render, but it can also happen if either &lt;code&gt;Component&lt;/code&gt; or &lt;code&gt;route&lt;/code&gt; changes.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;は、レンダリングに必要なデータをすぐに満たすことができない場合は常に、読み込み状態をレンダリングします。これは多くの場合、最初のレンダリングで発生しますが、 &lt;code&gt;Component&lt;/code&gt; または &lt;code&gt;route&lt;/code&gt; が変更された場合にも発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="81df685053c0d0bd1d2397325ab50c0f55f7ca06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.Route&lt;/strong&gt; lets us declare query roots.</source>
          <target state="translated">&lt;strong&gt;Relay.Routeを&lt;/strong&gt;使用すると、クエリのルートを宣言できます。</target>
        </trans-unit>
        <trans-unit id="c9948e83f56c83dcc4c3f5e36e015ebfe88bc455" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;QueryRenderer&lt;/code&gt; is a React Component at the root of a Relay component tree. It takes a query, fetches the given query, and uses the &lt;code&gt;render&lt;/code&gt; prop to render the resulting data.</source>
          <target state="translated">A &lt;code&gt;QueryRenderer&lt;/code&gt; は、リレーコンポーネントツリーのルートにコンポーネントを反応させています。これは、クエリをとる特定のクエリを取得し、使用して &lt;code&gt;render&lt;/code&gt; 結果のデータをレンダリングするために小道具を。</target>
        </trans-unit>
        <trans-unit id="d333726339af1440c557b36d8dd062e5747d248a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;QueryRenderer&lt;/code&gt; is a React component, so it can be rendered anywhere that a React component can be rendered, not just at the top level. A &lt;code&gt;QueryRenderer&lt;/code&gt; can be rendered &lt;em&gt;within&lt;/em&gt; other Relay components, for example to lazily fetch additional data for a popover. However, a &lt;code&gt;QueryRenderer&lt;/code&gt; will not start loading its data until it is mounted, so nested &lt;code&gt;QueryRenderer&lt;/code&gt; components can lead to avoidable request waterfalls if used unnecessarily.</source>
          <target state="translated">A &lt;code&gt;QueryRenderer&lt;/code&gt; は、最上位レベルでだけでなく、レンダリングすることができる成分に反応することどこにレンダリングすることができるように、コンポーネント反応させています。 A &lt;code&gt;QueryRenderer&lt;/code&gt; をレンダリングすることができる&lt;em&gt;内&lt;/em&gt;レイジーポップオーバーのための追加データをフェッチするために、例えば、他のリレー部品。ただし、 &lt;code&gt;QueryRenderer&lt;/code&gt; はデータがマウントされるまでデータの読み込みを開始しないため、ネストされた &lt;code&gt;QueryRenderer&lt;/code&gt; コンポーネントは、不必要に使用された場合、回避可能なリクエストウォーターフォールにつながる可能性があります。</target>
        </trans-unit>
        <trans-unit id="27c70649f28d5c13e5a545686407c1d433b45c24" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; config is used to append additional children to the mutation query. You may need to use this, for example, to fetch fields on a new object created by the mutation (and which Relay would normally not attempt to fetch because it has not previously fetched anything for that object).</source>
          <target state="translated">A &lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; configが突然変異クエリに追加子供を付加するために使用されます。たとえば、ミューテーションによって作成された新しいオブジェクトのフィールドをフェッチするためにこれを使用する必要がある場合があります（そのオブジェクトの何も以前にフェッチしていないため、通常、Relayはフェッチを試みません）。</target>
        </trans-unit>
        <trans-unit id="b0405a3f3745cc21b6e57c41715133d0cedd35b4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;RefetchContainer&lt;/code&gt; first renders like a regular &lt;a href=&quot;fragment-container&quot;&gt;&lt;code&gt;FragmentContainer&lt;/code&gt;&lt;/a&gt;, but has the option to execute a new query with different variables and render the response of that query instead when the request comes back.</source>
          <target state="translated">A &lt;code&gt;RefetchContainer&lt;/code&gt; は、最初の正規のようにレンダリングさ&lt;a href=&quot;fragment-container&quot;&gt; &lt;code&gt;FragmentContainer&lt;/code&gt; &lt;/a&gt;が、異なる変数を使用して新しいクエリを実行し、要求が戻ってきたときに、代わりにそのクエリの応答をレンダリングするためのオプションがあります。</target>
        </trans-unit>
        <trans-unit id="0b6b1500d0098058dc174f969740040bdd6fdf14" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;renderLoading&lt;/code&gt; callback can simulate the default behavior by returning &lt;code&gt;undefined&lt;/code&gt;. Notice that this is different from a &lt;code&gt;renderLoading&lt;/code&gt; callback that returns &lt;code&gt;null&lt;/code&gt;, which would render nothing whenever data is loading, even if there was a previous view rendered.</source>
          <target state="translated">&lt;code&gt;renderLoading&lt;/code&gt; のコールバックを返すことにより、デフォルトの動作をシミュレートすることができ &lt;code&gt;undefined&lt;/code&gt; 。これは、 &lt;code&gt;null&lt;/code&gt; を返す &lt;code&gt;renderLoading&lt;/code&gt; コールバックとは異なることに注意してください。これは、前のビューがレンダリングされていても、データのロード中は何もレンダリングしません。</target>
        </trans-unit>
        <trans-unit id="59bd5b6c5b1f4d50bad57e4bae0c86bf7e63ff03" translate="yes" xml:space="preserve">
          <source>A Complete Example</source>
          <target state="translated">完全な例</target>
        </trans-unit>
        <trans-unit id="961bc4600b75e68461ede605310ceced00dd4863" translate="yes" xml:space="preserve">
          <source>A Fragment Container is a &lt;a href=&quot;https://reactjs.org/docs/higher-order-components.html&quot;&gt;higher-order component&lt;/a&gt; that allows components to specify their data requirements. A container does not directly fetch data, but instead declares a &lt;em&gt;specification&lt;/em&gt; of the data needed for rendering, and then Relay will guarantee that this data is available &lt;em&gt;before&lt;/em&gt; rendering occurs.</source>
          <target state="translated">フラグメントコンテナは、&lt;a href=&quot;https://reactjs.org/docs/higher-order-components.html&quot;&gt;コンポーネント&lt;/a&gt;がデータ要件を指定できるようにする高次コンポーネントです。コンテナはデータを直接フェッチしませんが、代わりにレンダリングに必要なデータの&lt;em&gt;仕様&lt;/em&gt;を宣言します。その後、Relayは、レンダリングが行わ&lt;em&gt;れる前に&lt;/em&gt;このデータが利用可能であることを保証します。</target>
        </trans-unit>
        <trans-unit id="584bb673c7430dcef36b698acb079dd72be2262f" translate="yes" xml:space="preserve">
          <source>A GraphQL Schema</source>
          <target state="translated">グラフQLスキーム</target>
        </trans-unit>
        <trans-unit id="b1a1d3fc840a0a6e5e8ca2b278d7769c45a98c33" translate="yes" xml:space="preserve">
          <source>A GraphQL Server</source>
          <target state="translated">グラフQLサーバー</target>
        </trans-unit>
        <trans-unit id="a7ee882612fb64b227df291f19a923de85574e53" translate="yes" xml:space="preserve">
          <source>A GraphQL schema describes your data model, and provides a GraphQL server with an associated set of resolve methods that know how to fetch data. We will use &lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;graphql-js&lt;/a&gt; and &lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;graphql-relay-js&lt;/a&gt; to build our schema.</source>
          <target state="translated">GraphQLスキーマはデータモデルを記述し、GraphQLサーバーに、データのフェッチ方法を認識している関連する一連のresolveメソッドを提供します。私たちは、使用する&lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;graphql-JS&lt;/a&gt;と&lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;graphqlリレー-jsのを&lt;/a&gt;私たちのスキーマを構築します。</target>
        </trans-unit>
        <trans-unit id="48b78b689c15abba06f0159436cde03009fad264" translate="yes" xml:space="preserve">
          <source>A Refetch Container is also a &lt;a href=&quot;https://reactjs.org/docs/higher-order-components.html&quot;&gt;higher-order component&lt;/a&gt; that works like a regular &lt;a href=&quot;fragment-container&quot;&gt;Fragment Container&lt;/a&gt;, but provides the additional ability to fetch a new GraphQL query with different variables and re-render the component with the new result.</source>
          <target state="translated">再フェッチコンテナも、通常の&lt;a href=&quot;fragment-container&quot;&gt;フラグメントコンテナの&lt;/a&gt;ように機能&lt;a href=&quot;https://reactjs.org/docs/higher-order-components.html&quot;&gt;する高次のコンポーネントです&lt;/a&gt;が、さまざまな変数を使用して新しいGraphQLクエリをフェッチし、新しい結果でコンポーネントを再レンダリングする追加機能を提供します。</target>
        </trans-unit>
        <trans-unit id="bc6cdf397779ac0008665fa5d7d262a02b419170" translate="yes" xml:space="preserve">
          <source>A bag of variables to pass to the &lt;code&gt;refetchQuery&lt;/code&gt; when fetching it from the server.</source>
          <target state="translated">サーバーからフェッチするときに &lt;code&gt;refetchQuery&lt;/code&gt; に渡す変数のバッグ。</target>
        </trans-unit>
        <trans-unit id="5f6d86fdd10ea1168eecc22cdc48b9e22a21ad2d" translate="yes" xml:space="preserve">
          <source>A complete example</source>
          <target state="translated">完全な例</target>
        </trans-unit>
        <trans-unit id="1b0ee223956194b51488ec093f18ce49cf32ed77" translate="yes" xml:space="preserve">
          <source>A description of how to page through connections.</source>
          <target state="translated">接続を介してページングする方法を説明しています。</target>
        </trans-unit>
        <trans-unit id="97b03c635c48a56b721c11e955de7b0b12f2ab52" translate="yes" xml:space="preserve">
          <source>A description of your data model with an associated set of resolve methods that know how to fetch any data your application could ever need.</source>
          <target state="translated">アプリケーションが必要とするあらゆるデータを取得する方法を知っている解決メソッドの関連セットを持つデータモデルの説明。</target>
        </trans-unit>
        <trans-unit id="cab997b4cd24ec902e4b83aaf3bf43dce9ec7836" translate="yes" xml:space="preserve">
          <source>A faction has many ships in the Star Wars universe. Relay contains functionality to make manipulating one-to-many relationships easy, using a standardized way of expressing these one-to-many relationships. This standard connection model offers ways of slicing and paginating through the connection.</source>
          <target state="translated">スター・ウォーズの宇宙では、派閥には多くの船があります。Relayには、これらの一対多の関係を標準化された方法で表現することで、一対多の関係を簡単に操作できるようにする機能が含まれています。この標準的な接続モデルでは、接続をスライスしたりページ分割したりする方法を提供しています。</target>
        </trans-unit>
        <trans-unit id="af85210772abecb804d78217a7325698b05fe83e" translate="yes" xml:space="preserve">
          <source>A generic mechanism for intercepting data prior to publishing it to the cache and either synthesizing new data or merging new and existing data together (which among other things enables the creation of a variety of pagination schemes).</source>
          <target state="translated">キャッシュにデータを公開する前にデータを傍受し、新しいデータを合成したり、新しいデータと既存のデータをマージしたりするための一般的なメカニズムです(これにより、様々なページ分割スキームの作成が可能になります)。</target>
        </trans-unit>
        <trans-unit id="ac6dbe38242ad9f607665dc6e4fa2db4283cdd16" translate="yes" xml:space="preserve">
          <source>A map between a &lt;code&gt;fieldName&lt;/code&gt; in the response and one or more DataIDs in the store.</source>
          <target state="translated">応答内の &lt;code&gt;fieldName&lt;/code&gt; とストア内の1つ以上のDataIDの間のマップ。</target>
        </trans-unit>
        <trans-unit id="6d94fea08321dcd17e29b42a404746fc50da107f" translate="yes" xml:space="preserve">
          <source>A map between printed, dot-separated GraphQL calls &lt;em&gt;in alphabetical order&lt;/em&gt; and the behavior we want Relay to exhibit when adding the new edge to connections under the influence of those calls or a function accepting an array of connection arguments, returning that behavior.</source>
          <target state="translated">&lt;em&gt;アルファベット順に&lt;/em&gt;印刷されたドット区切りのGraphQL呼び出しと、それらの呼び出しまたは接続引数の配列を受け入れる関数の影響下で新しいエッジを接続に追加するときにRelayが示す動作との間のマップで、その動作を返します。</target>
        </trans-unit>
        <trans-unit id="df6534fbc976a915dd2ab9e7fdb121c13f0a1f35" translate="yes" xml:space="preserve">
          <source>A mechanism for reading data from the cache and subscribing for updates when these results change due to a mutation, subscription update, etc.</source>
          <target state="translated">突然変異やサブスクリプション更新などで結果が変化した場合に、キャッシュからデータを読み込み、更新のためにサブスクライブする仕組み。</target>
        </trans-unit>
        <trans-unit id="1cccdfbe7fde630bea189ab2f8f17ca043aff9a4" translate="yes" xml:space="preserve">
          <source>A mechanism for refetching an object.</source>
          <target state="translated">オブジェクトをリフェッチするためのメカニズム。</target>
        </trans-unit>
        <trans-unit id="dd1a050f9a41554bdba5570ef7cbd29c8928f1fa" translate="yes" xml:space="preserve">
          <source>A naming convention of &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; for fragments is advised. This restriction is required while migrating from classic to modern APIs to allow for cross-compatibility.</source>
          <target state="translated">フラグメントの &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; の命名規則をお勧めします。この制限は、クラシックAPIからモダンAPIに移行するときに相互互換性を確保するために必要です。</target>
        </trans-unit>
        <trans-unit id="b4223851fbff0df13ddb07d4c23c59818ab413eb" translate="yes" xml:space="preserve">
          <source>A normalized cache ensures that the &lt;em&gt;cache&lt;/em&gt; is consistent. But what about our views? Ideally, our React views would always reflect the current information from the cache.</source>
          <target state="translated">正規化された&lt;em&gt;キャッシュ&lt;/em&gt;は、&lt;em&gt;キャッシュの&lt;/em&gt;一貫性を保証します。しかし、私たちの見解はどうですか？理想的には、Reactビューは常にキャッシュからの現在の情報を反映します。</target>
        </trans-unit>
        <trans-unit id="ae22c4f42331ba6c74de6dc551bc9f18b6a1ae62" translate="yes" xml:space="preserve">
          <source>A normalized, in-memory object graph/cache.</source>
          <target state="translated">正規化された、メモリ内のオブジェクトグラフ/キャッシュ。</target>
        </trans-unit>
        <trans-unit id="921546babe023949163725db08488e51b22729dc" translate="yes" xml:space="preserve">
          <source>A number of more detailed usage examples can be found &lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/react-relay/classic/mutation/__tests__/RelayGraphQLMutation-test.js&quot;&gt;in the test suite&lt;/a&gt;.</source>
          <target state="translated">より詳細な使用例の多く&lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/react-relay/classic/mutation/__tests__/RelayGraphQLMutation-test.js&quot;&gt;は、テストスイートにあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7bf37966659d061a8f053bad6bab73f29aaece2b" translate="yes" xml:space="preserve">
          <source>A parent component will pass in a reference to some &lt;code&gt;User&lt;/code&gt; &quot;record&quot;.</source>
          <target state="translated">親コンポーネントは、一部の &lt;code&gt;User&lt;/code&gt; 「レコード」への参照を渡します。</target>
        </trans-unit>
        <trans-unit id="3024b82cc133bf6a9ef4feda5d9be663e786bae2" translate="yes" xml:space="preserve">
          <source>A polyfilled environment for Relay using &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; to support older browsers might look like:</source>
          <target state="translated">古いブラウザをサポートするために&lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt;を使用するRelayのポリフィル環境は次のようになります。</target>
        </trans-unit>
        <trans-unit id="d9c2b7e55915b27a1958903b288baadab9b9ebc4" translate="yes" xml:space="preserve">
          <source>A query like the following:</source>
          <target state="translated">以下のようなクエリです。</target>
        </trans-unit>
        <trans-unit id="61d2ab53d28c9ffa3a83c917db0c7132ab0ec11a" translate="yes" xml:space="preserve">
          <source>A reference for translating between the Relay Classic and Relay Modern APIs.</source>
          <target state="translated">Relay Classic APIとRelay Modern APIの間での翻訳のためのリファレンスです。</target>
        </trans-unit>
        <trans-unit id="0b8683fbbd3c98251a45756a2f2f8175837a100c" translate="yes" xml:space="preserve">
          <source>A simple database</source>
          <target state="translated">シンプルなデータベース</target>
        </trans-unit>
        <trans-unit id="40cf8919ea34c404a49fa4a02115691af647ed4f" translate="yes" xml:space="preserve">
          <source>A simple example</source>
          <target state="translated">簡単な例</target>
        </trans-unit>
        <trans-unit id="dd8ebc46434f8d14a177b5c72d5934bab414bb47" translate="yes" xml:space="preserve">
          <source>A simpler, more predictable mutation API. The restrictions on mutation queries from Relay Classic are also removed: mutation queries are static, fields can be arbitrarily nested, and may use arbitrary arguments.</source>
          <target state="translated">よりシンプルで予測可能なミューテーションAPI。Relay Classic からのミューテーションクエリの制限も取り除かれました。ミューテーションクエリは静的で、フィールドは任意のネストが可能で、任意の引数を使用することができます。</target>
        </trans-unit>
        <trans-unit id="789d37a7cd03e8b6bdc2af935f5617d2f61be663" translate="yes" xml:space="preserve">
          <source>A standard response is to &quot;just use immutable data structures&quot; &amp;mdash; but let's see what would happen if we did:</source>
          <target state="translated">標準的な応答は、「不変のデータ構造を使用する」というものですが、そうするとどうなるか見てみましょう。</target>
        </trans-unit>
        <trans-unit id="e5e4cf2d26ffa89b62883fa16b09362f316c9090" translate="yes" xml:space="preserve">
          <source>A summary of the improvements and new features in Relay Modern.</source>
          <target state="translated">Relay Modernの改良点と新機能のまとめ。</target>
        </trans-unit>
        <trans-unit id="95da6cd41846ca1d215d52c18cb18c520fe5b668" translate="yes" xml:space="preserve">
          <source>A working copy of the treasure hunt can be found in the &lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;relay-examples&lt;/a&gt; repository.</source>
          <target state="translated">宝探しの作業用コピーは、&lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;relay-examples&lt;/a&gt;リポジトリにあります。</target>
        </trans-unit>
        <trans-unit id="1aec4806edaa35984901f978cbb068b50698edb4" translate="yes" xml:space="preserve">
          <source>API Cheatsheet</source>
          <target state="translated">APIチートシート</target>
        </trans-unit>
        <trans-unit id="2c3de2092b0a547759dcfed154c12293c6bfa562" translate="yes" xml:space="preserve">
          <source>API and Runtime</source>
          <target state="translated">APIとランタイム</target>
        </trans-unit>
        <trans-unit id="30decd745bda6efb9c328a25620c92f31665d9ed" translate="yes" xml:space="preserve">
          <source>Accessing a plain connection field like this is the same as other regular field:</source>
          <target state="translated">このようなプレーンな接続フィールドへのアクセスは、他の通常のフィールドと同じです。</target>
        </trans-unit>
        <trans-unit id="42949c00e99b70b6ffba23e406246cfa31564e49" translate="yes" xml:space="preserve">
          <source>Achieving View Consistency</source>
          <target state="translated">ビューの一貫性を実現する</target>
        </trans-unit>
        <trans-unit id="81f2d6f8bacd029d8646faa85a14672311eb28b5" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;&quot;relay&quot;&lt;/code&gt; to the list of plugins your .babelrc file. See &lt;a href=&quot;babel-plugin-relay&quot;&gt;the docs&lt;/a&gt; if upgrading an existing Relay app.</source>
          <target state="translated">.babelrcファイルのプラグインのリストに &lt;code&gt;&quot;relay&quot;&lt;/code&gt; を追加します。既存のリレーアプリをアップグレードする場合は&lt;a href=&quot;babel-plugin-relay&quot;&gt;、ドキュメントを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0a60bf5aa8ddfd89ba31ac71650847ae24721ce0" translate="yes" xml:space="preserve">
          <source>Add the variable to the queries that use the fragment and pass it in when fetching the query. For this it can be useful to have a module with a collection of variables for your product.</source>
          <target state="translated">フラグメントを使用するクエリに変数を追加し、クエリを取得する際にそれを渡します。このためには、製品用の変数のコレクションを持つモジュールがあると便利です。</target>
        </trans-unit>
        <trans-unit id="0a4d555b6a81430095f4070dee6163a543de304b" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;handlerProvider&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;handlerProvider&lt;/code&gt; の追加</target>
        </trans-unit>
        <trans-unit id="c313de6babf318503fdf433e2471023cd78a727c" translate="yes" xml:space="preserve">
          <source>Additional Options</source>
          <target state="translated">追加オプション</target>
        </trans-unit>
        <trans-unit id="94c2eff0e92e7480eb248740c04ee58edd887616" translate="yes" xml:space="preserve">
          <source>Additionally, you need a directory containing &lt;code&gt;.js&lt;/code&gt; files that use the &lt;code&gt;graphql&lt;/code&gt; tag to describe GraphQL queries and fragments. Let's call this &lt;code&gt;./src&lt;/code&gt;.</source>
          <target state="translated">さらに、 &lt;code&gt;graphql&lt;/code&gt; タグを使用してGraphQLクエリとフラグメントを記述する &lt;code&gt;.js&lt;/code&gt; ファイルを含むディレクトリが必要です。これを &lt;code&gt;./src&lt;/code&gt; と呼びましょう。</target>
        </trans-unit>
        <trans-unit id="e7c13cb060f72ef8e06bc9f0779c54871d13ff35" translate="yes" xml:space="preserve">
          <source>Advanced Mutation Example</source>
          <target state="translated">高度な突然変異の例</target>
        </trans-unit>
        <trans-unit id="5126940d744a6dff391a643edf858b06f00785ed" translate="yes" xml:space="preserve">
          <source>Advanced usage</source>
          <target state="translated">高度な使い方</target>
        </trans-unit>
        <trans-unit id="65b03cca363991c35ae10c0088f588b27ac28625" translate="yes" xml:space="preserve">
          <source>After global invalidation, any query that is checked before refetching it will be considered stale:</source>
          <target state="translated">グローバルな無効化の後、リフェッチする前にチェックされたクエリはすべてスタールとみなされます。</target>
        </trans-unit>
        <trans-unit id="78bdcba5217f6a92239c4e8dde28377bb7815364" translate="yes" xml:space="preserve">
          <source>After initially fetching this story our cache might be as follows. Note that the story and comment both link to the same record as &lt;code&gt;author&lt;/code&gt;:</source>
          <target state="translated">このストーリーを最初にフェッチした後、キャッシュは次のようになる可能性があります。ストーリーとコメントの両方が &lt;code&gt;author&lt;/code&gt; と同じレコードにリンクしていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f2dd7e26249b6d8637a717ed4d6b92305ed4d8d7" translate="yes" xml:space="preserve">
          <source>After invalidating a record, any query that references the invalidated record and that is checked before refetching it will be considered stale:</source>
          <target state="translated">レコードを無効にした後、無効になったレコードを参照しているクエリと、それを再取得する前にチェックされたクエリは、古いものとみなされます。</target>
        </trans-unit>
        <trans-unit id="20d5e5845a458c2e48e4a1e3d9fcce05c093f36b" translate="yes" xml:space="preserve">
          <source>After the network comes back, if any optimistic update was applied, it will be rolled back.</source>
          <target state="translated">ネットワークが復活した後、楽天的なアップデートが適用されていた場合はロールバックされます。</target>
        </trans-unit>
        <trans-unit id="cefb28e5c89ebf89740e7f56f62c4e404d2462a6" translate="yes" xml:space="preserve">
          <source>All data is fetched in a single round trip.</source>
          <target state="translated">すべてのデータを1往復で取得します。</target>
        </trans-unit>
        <trans-unit id="40454335b535c042b908582ab2dd06293106ac63" translate="yes" xml:space="preserve">
          <source>All of the mutations we've performed so far have waited on a response from the server before updating the client-side store. Relay offers us a chance to craft an optimistic response of the same shape based on what we expect the server's response to be in the event of a successful mutation.</source>
          <target state="translated">これまでに実行した突然変異はすべて、クライアント側のストアを更新する前にサーバからの応答を待っていました。Relayでは、突然変異が成功した場合のサーバからのレスポンスの予想に基づいて、同じ形の楽観的なレスポンスを作成することができます。</target>
        </trans-unit>
        <trans-unit id="6e5ef228d93a867965453c9210e08a5fc6427932" translate="yes" xml:space="preserve">
          <source>Alternatively a &lt;a href=&quot;refetch-container&quot;&gt;&lt;code&gt;RefetchContainer&lt;/code&gt;&lt;/a&gt; can also be used.</source>
          <target state="translated">または、&lt;a href=&quot;refetch-container&quot;&gt; &lt;code&gt;RefetchContainer&lt;/code&gt; &lt;/a&gt;を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="3cb1f93043bd5b1e4766b2a5f1a916dfbf98f41c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can install &lt;code&gt;relay-compiler&lt;/code&gt; globally so you can access it directly:</source>
          <target state="translated">または、 &lt;code&gt;relay-compiler&lt;/code&gt; をグローバルにインストールして、直接アクセスできるようにすることもできます。</target>
        </trans-unit>
        <trans-unit id="4e7be8aae845923a0feac81e1f7b4b0b1b6931db" translate="yes" xml:space="preserve">
          <source>Although the response is hierarchical, we'll cache it by flattening all the records. Here is an example of how Relay would cache this query response:</source>
          <target state="translated">レスポンスは階層化されていますが、すべてのレコードをフラット化してキャッシュします。以下に、Relayがこのクエリレスポンスをキャッシュする例を示します。</target>
        </trans-unit>
        <trans-unit id="c6ec18663142d1b37b9759d8f91cf8ac740a2752" translate="yes" xml:space="preserve">
          <source>An area we've gotten a lot of questions on was mutations and their configs. Relay Modern introduces a new mutation API that allows records and fields to be updated in a more direct manner.</source>
          <target state="translated">これまで多くの質問を受けてきたのは、ミューテーションとその設定についてでした。Relay Modernでは、レコードやフィールドをより直接的な方法で更新できる新しいミューテーションAPIが導入されました。</target>
        </trans-unit>
        <trans-unit id="16a242bdcfab9509fa528a20336ea8be61d5d155" translate="yes" xml:space="preserve">
          <source>An array containing the field names between the parent and the connection, including the parent and the connection</source>
          <target state="translated">親と接続を含む親と接続の間のフィールド名を含む配列</target>
        </trans-unit>
        <trans-unit id="ab5c749afdc7ed704bf1427839cff1f6c54727ed" translate="yes" xml:space="preserve">
          <source>An example using &lt;code&gt;fetch&lt;/code&gt; looks like this:</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; を使用した例は次のようになります。</target>
        </trans-unit>
        <trans-unit id="ecb9a82e766e01fb5997898864c15b00f3207e54" translate="yes" xml:space="preserve">
          <source>An instance of a &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt; encapsulates an in-memory cache of GraphQL data and a network layer that provides access to your GraphQL server. The Environment object is typically not used by developers directly, instead it is passed to each &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt;, which uses the environment to access, modify, and fetch data. Within a container, the current environment can be accessed via &lt;code&gt;this.props.relay.environment&lt;/code&gt;. This is most commonly used to &lt;a href=&quot;mutations&quot;&gt;execute a mutation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;relay-environment&quot;&gt;リレー環境&lt;/a&gt;のインスタンスは、GraphQLデータのメモリ内キャッシュと、GraphQLサーバーへのアクセスを提供するネットワークレイヤーをカプセル化します。通常、Environmentオブジェクトは開発者が直接使用するのではなく、環境を使用してデータにアクセス、変更、フェッチする各&lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt;に渡されます。コンテナ内では、 &lt;code&gt;this.props.relay.environment&lt;/code&gt; を介して現在の環境にアクセスできます。これは&lt;a href=&quot;mutations&quot;&gt;、突然変異&lt;/a&gt;を実行するために最も一般的に使用されます。</target>
        </trans-unit>
        <trans-unit id="6dd9dc1929b158a9c5ea7752c056cc104664b1ef" translate="yes" xml:space="preserve">
          <source>An object that conforms to the &lt;code&gt;Relay.Environment&lt;/code&gt; interface, such as &lt;code&gt;Relay.Store&lt;/code&gt;.</source>
          <target state="translated">オブジェクトに準拠していること &lt;code&gt;Relay.Environment&lt;/code&gt; などのインターフェース、 &lt;code&gt;Relay.Store&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31091cd5447f1a5facd7ba679b86a188b803a23a" translate="yes" xml:space="preserve">
          <source>An optimized &quot;write&quot; operation for updating the cache with the results of queries/mutations/subscriptions.</source>
          <target state="translated">クエリ/ミューテーション/サブスクリプションの結果でキャッシュを更新するための最適化された「書き込み」操作。</target>
        </trans-unit>
        <trans-unit id="ac7cf5ea35aac5de7114e6afc02d20f82b3316f0" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;onReadyStateChange&lt;/code&gt; callback can be supplied to respond to the events involved with the data fulfillment.</source>
          <target state="translated">オプションの &lt;code&gt;onReadyStateChange&lt;/code&gt; コールバックを提供して、データフルフィルメントに関連するイベントに応答できます。</target>
        </trans-unit>
        <trans-unit id="7303f03f73c25d8e0d64d93962d92858e7741e4b" translate="yes" xml:space="preserve">
          <source>And here's a possible response:</source>
          <target state="translated">そして、考えられる対応がこちら。</target>
        </trans-unit>
        <trans-unit id="369fe458331664a040bf70efbb8b99da198958aa" translate="yes" xml:space="preserve">
          <source>And this fragment can then be used to define the Story container:</source>
          <target state="translated">そして、このフラグメントを使用して Story コンテナを定義することができます。</target>
        </trans-unit>
        <trans-unit id="4dfa35597a4d927f5cbf51a45486138efe15e61b" translate="yes" xml:space="preserve">
          <source>Another way to enable optimistic updates is via the &lt;code&gt;optimisticUpdater&lt;/code&gt;, which can be used for more complicated update scenarios. Using &lt;code&gt;optimisticUpdater&lt;/code&gt; is covered in the section &lt;a href=&quot;#using-updater-and-optimisticupdater&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">楽観的な更新を有効にする別の方法は、より複雑な更新シナリオに使用できる &lt;code&gt;optimisticUpdater&lt;/code&gt; を使用することです。 &lt;code&gt;optimisticUpdater&lt;/code&gt; の使用については、&lt;a href=&quot;#using-updater-and-optimisticupdater&quot;&gt;以下&lt;/a&gt;のセクションで説明します。</target>
        </trans-unit>
        <trans-unit id="880246192858f60438eac48b83d096fc7d5b0a5d" translate="yes" xml:space="preserve">
          <source>Any arguments defined inside &lt;code&gt;@argumentDefinitions&lt;/code&gt; will be local variables available inside the fragment's scope. However, a fragment can also reference global variables that were defined in the root query.</source>
          <target state="translated">&lt;code&gt;@argumentDefinitions&lt;/code&gt; 内で定義された引数はすべて、フラグメントのスコープ内で使用可能なローカル変数になります。ただし、フラグメントは、ルートクエリで定義されたグローバル変数を参照することもできます。</target>
        </trans-unit>
        <trans-unit id="605ea43af6ae69ff62a257b6fd0223b045c71edf" translate="yes" xml:space="preserve">
          <source>Any field in the payload that can be correlated by DataID with one or more records in the client-side store will be merged with the record(s) in the store.</source>
          <target state="translated">ペイロード内の任意のフィールドで、DataIDによってクライアント側ストア内の1つ以上のレコードと相関があるものは、ストア内のレコードとマージされます。</target>
        </trans-unit>
        <trans-unit id="0fefe11020485e10d8f3308edf7710a3715bb28f" translate="yes" xml:space="preserve">
          <source>Any fields specified in the client schema, can be fetched from the &lt;a href=&quot;relay-store&quot;&gt;Relay Store&lt;/a&gt;, by selecting it in a query or fragment.</source>
          <target state="translated">クライアントスキーマで指定されたすべてのフィールドは、からフェッチすることができ&lt;a href=&quot;relay-store&quot;&gt;リレーストア&lt;/a&gt;クエリまたはフラグメントでそれを選択することで、。</target>
        </trans-unit>
        <trans-unit id="cfe1cdd7971ecdf1250f379fc5280623f121ecd7" translate="yes" xml:space="preserve">
          <source>Any props that we pass to the constructor of a mutation will become available to its instance methods as &lt;code&gt;this.props&lt;/code&gt;. Like in components used within Relay containers, props for which a corresponding fragment has been defined will be populated by Relay with query data:</source>
          <target state="translated">ミュー &lt;code&gt;this.props&lt;/code&gt; のコンストラクターに渡す小道具は、this.propsとしてインスタンスメソッドで使用できるようになります。Relayコンテナー内で使用されるコンポーネントと同様に、対応するフラグメントが定義されているプロップには、Relayによってクエリデータが入力されます。</target>
        </trans-unit>
        <trans-unit id="2c3c3b69096651daf12db619c2e7045eb0884046" translate="yes" xml:space="preserve">
          <source>Any server can be taught to load a schema and speak GraphQL. Our &lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;examples&lt;/a&gt; use Express.</source>
          <target state="translated">どのサーバーでも、スキーマをロードしてGraphQLを話すように教えることができます。私たちの&lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;例では、&lt;/a&gt; Expressを使用しています。</target>
        </trans-unit>
        <trans-unit id="8a830514fbc11a8668a4369e6666ef8944337af6" translate="yes" xml:space="preserve">
          <source>Applications must supply a &lt;a href=&quot;network-layer&quot;&gt;Network Layer&lt;/a&gt; when creating an instance of a Relay Environment. The network layer is an object conforming to a simple interface through which Relay can execute queries, mutations, and subscriptions. Essentially, this object teaches Relay how to talk to your GraphQL server.</source>
          <target state="translated">リレー環境のインスタンスを作成するとき、アプリケーションは&lt;a href=&quot;network-layer&quot;&gt;ネットワーク層を&lt;/a&gt;提供する必要があります。ネットワークレイヤーは、Relayがクエリ、ミューテーション、サブスクリプションを実行できるシンプルなインターフェースに準拠したオブジェクトです。基本的に、このオブジェクトは、RelayにGraphQLサーバーと通信する方法を教えます。</target>
        </trans-unit>
        <trans-unit id="b73a641a18b041c9d0f67faadd8eeb909c673be7" translate="yes" xml:space="preserve">
          <source>Applied to a fragment definition, &lt;code&gt;@relay(mask: false)&lt;/code&gt; changes the generated Flow types to be better usable when the fragment is included with the same directive. The Flow types will no longer be exact objects and no longer contain internal marker fields.</source>
          <target state="translated">フラグメント定義に適用される &lt;code&gt;@relay(mask: false)&lt;/code&gt; は、生成されたフロータイプを変更して、フラグメントが同じディレクティブに含まれている場合に使いやすくします。フロータイプは正確なオブジェクトではなくなり、内部マーカーフィールドが含まれなくなります。</target>
        </trans-unit>
        <trans-unit id="77cbe978decf7e18ac53e8ff64911f09e83509bc" translate="yes" xml:space="preserve">
          <source>Architecture Overview</source>
          <target state="translated">アーキテクチャの概要</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="dd4d4251ad9eea93ba8b6656973531a29f150428" translate="yes" xml:space="preserve">
          <source>Array fields</source>
          <target state="translated">配列フィールド</target>
        </trans-unit>
        <trans-unit id="db828dbd3d02709c19e5c4f2577f94833837f6ee" translate="yes" xml:space="preserve">
          <source>As React components, &lt;code&gt;QueryRenderer&lt;/code&gt;s can be rendered anywhere that a React component can be rendered, i.e. not just at the top level but &lt;em&gt;within&lt;/em&gt; other components or containers; for example, to lazily fetch additional data for a popover.</source>
          <target state="translated">Reactコンポーネントとして、 &lt;code&gt;QueryRenderer&lt;/code&gt; は、Reactコンポーネントをレンダリングできる場所であればどこでもレンダリングできます。つまり、トップレベルだけでなく、他のコンポーネントやコンテナー&lt;em&gt;内&lt;/em&gt;でもレンダリングできます。たとえば、ポップオーバーの追加データを遅延フェッチする場合などです。</target>
        </trans-unit>
        <trans-unit id="f3aab73669ac6dc9de81f7b41eeb64591c4e0ee7" translate="yes" xml:space="preserve">
          <source>As an example, we can log each mutation that is sent to the server as follows:</source>
          <target state="translated">例として、以下のようにサーバに送信された各突然変異をログに記録することができます。</target>
        </trans-unit>
        <trans-unit id="93df315a58852563161dbb62a33b18e1c4b63051" translate="yes" xml:space="preserve">
          <source>As we've learned, Relay containers declare data requirements as GraphQL fragments. This means that, for example, &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; can be embedded not only in &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt;, but any container that fetches a field of type &lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">これまでに学んだように、リレーコンテナはデータ要件をGraphQLフラグメントとして宣言します。これは、たとえば、 &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; を &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; だけでなく、 &lt;code&gt;User&lt;/code&gt; 型のフィールドをフェッチする任意のコンテナに埋め込むことができることを意味します。</target>
        </trans-unit>
        <trans-unit id="923622cbd0c4bbb9c49d319a01f53817606d02a1" translate="yes" xml:space="preserve">
          <source>As we've learned, Relay fragment containers declare data requirements as GraphQL fragments. We're almost ready to let Relay fulfill the data requirements for these components and render them. However, there is one problem. In order to actually fetch data with GraphQL, we need a query root. For example, we need to ground the &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; fragment in a GraphQL query.</source>
          <target state="translated">これまでに学んだように、リレーフラグメントコンテナーはデータ要件をGraphQLフラグメントとして宣言します。Relayがこれらのコンポーネントのデータ要件を満たし、レンダリングする準備がほぼ整いました。ただし、問題が1つあります。GraphQLを使用して実際にデータをフェッチするには、クエリルートが必要です。たとえば、GraphQLクエリで &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; フラグメントを固定する必要があります。</target>
        </trans-unit>
        <trans-unit id="aca9c86fb3d13923d8fed77382029e60cce8b3f9" translate="yes" xml:space="preserve">
          <source>As we've learned, Relay fragment containers only declare data requirements as GraphQL fragments. In order to actually fetch and render the specified data, we need to use a &lt;code&gt;QueryRenderer&lt;/code&gt; component to render a root query and any fragment containers included within. Please refer to our &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt; docs for more details.</source>
          <target state="translated">私たちが学んだように、Relayフラグメントコンテナーはデータ要件をGraphQLフラグメントとしてのみ宣言します。指定されたデータを実際にフェッチしてレンダリングするには、 &lt;code&gt;QueryRenderer&lt;/code&gt; コンポーネントを使用して、ルートクエリとそれに含まれるフラグメントコンテナをレンダリングする必要があります。詳細については、&lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; の&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="6a71de49f031297e07457bef14ae0f8572e55b44" translate="yes" xml:space="preserve">
          <source>At this point, you can delete everything up until &lt;code&gt;queryType&lt;/code&gt; in &lt;code&gt;./data/schema.js&lt;/code&gt;.</source>
          <target state="translated">この時点で、あなたはまですべてを削除することができます &lt;code&gt;queryType&lt;/code&gt; で &lt;code&gt;./data/schema.js&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="207aae1b1d93e0ae663b416c543d4e3848a98ef0" translate="yes" xml:space="preserve">
          <source>Authoring a schema</source>
          <target state="translated">スキーマのオーサリング</target>
        </trans-unit>
        <trans-unit id="f959176d994ae939a23354811509dadf3863fa24" translate="yes" xml:space="preserve">
          <source>Available Props</source>
          <target state="translated">利用可能な小道具</target>
        </trans-unit>
        <trans-unit id="3eb220f88ae787a8eafb5d737da557d0ab6ff6ca" translate="yes" xml:space="preserve">
          <source>Babel Relay Plugin</source>
          <target state="translated">バベルリレープラグイン</target>
        </trans-unit>
        <trans-unit id="0351d5a9ef82b115e9ed00101cebdddfe0dbad30" translate="yes" xml:space="preserve">
          <source>Base React Component</source>
          <target state="translated">ベースのReactコンポーネント</target>
        </trans-unit>
        <trans-unit id="a6551059bdb95efc2dfbc4b7c2ce6ccc9fcd0365" translate="yes" xml:space="preserve">
          <source>Before going any further, we need to serialize our executable schema to JSON for use by the Relay.QL transpiler, then start up the server. From the command line:</source>
          <target state="translated">先に進む前に、実行可能なスキーマをJSONにシリアライズして、Relay.QLトランスパイラで使用する必要があります。コマンドラインから</target>
        </trans-unit>
        <trans-unit id="97cecb9e6bdc8256a26df17eef65a9b41e163cee" translate="yes" xml:space="preserve">
          <source>Before taking a deep dive into the mutations API, let's look at a complete example. Here, we subclass &lt;code&gt;Relay.Mutation&lt;/code&gt; to create a custom mutation that we can use to like a story.</source>
          <target state="translated">ミューテーションAPIについて詳しく説明する前に、完全な例を見てみましょう。ここでは、 &lt;code&gt;Relay.Mutation&lt;/code&gt; をサブクラス化して、ストーリーを好きになるために使用できるカスタム変異を作成します。</target>
        </trans-unit>
        <trans-unit id="949c7a85f6d836f247f0195b7eaa99f0c336e992" translate="yes" xml:space="preserve">
          <source>Behaviors can be one of &lt;code&gt;'append'&lt;/code&gt;, &lt;code&gt;'ignore'&lt;/code&gt;, &lt;code&gt;'prepend'&lt;/code&gt;, &lt;code&gt;'refetch'&lt;/code&gt;, or &lt;code&gt;'remove'&lt;/code&gt;.</source>
          <target state="translated">動作は、 &lt;code&gt;'append'&lt;/code&gt; 、 &lt;code&gt;'ignore'&lt;/code&gt; 、 &lt;code&gt;'prepend'&lt;/code&gt; 、 &lt;code&gt;'refetch'&lt;/code&gt; 、または &lt;code&gt;'remove'&lt;/code&gt; のいずれかです。</target>
        </trans-unit>
        <trans-unit id="a13e0d17d14c44107ca60ab513e5d71d5662c000" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;Faction&lt;/code&gt; and &lt;code&gt;Ship&lt;/code&gt; have identifiers that we can use to refetch them. We expose this capability to Relay through the &lt;code&gt;Node&lt;/code&gt; interface and the &lt;code&gt;node&lt;/code&gt; field on the root query type.</source>
          <target state="translated">&lt;code&gt;Faction&lt;/code&gt; と &lt;code&gt;Ship&lt;/code&gt; の両方には、それらを再フェッチするために使用できる識別子があります。この機能は、 &lt;code&gt;Node&lt;/code&gt; インターフェースとルートクエリタイプの &lt;code&gt;node&lt;/code&gt; フィールドを介してリレーするために公開します。</target>
        </trans-unit>
        <trans-unit id="3148373f94223f76742328ea5464dd9f30817fe7" translate="yes" xml:space="preserve">
          <source>But now, we can also create routes for arbitrary user IDs. For example, if we wanted to construct a route that fetched data for a user defined by the &lt;code&gt;userID&lt;/code&gt; query parameter, we might use:</source>
          <target state="translated">しかし今では、任意のユーザーIDのルートを作成することもできます。たとえば、 &lt;code&gt;userID&lt;/code&gt; クエリパラメータで定義されたユーザーのデータをフェッチするルートを作成する場合は、次のように使用します。</target>
        </trans-unit>
        <trans-unit id="1862f3355eff810374142f7e656f80df21c55213" translate="yes" xml:space="preserve">
          <source>By convention, mutations are named as verbs, their inputs are the name with &quot;Input&quot; appended at the end, and they return an object that is the name with &quot;Payload&quot; appended.</source>
          <target state="translated">慣例では、突然変異は動詞として名前が付けられ、その入力は最後に &quot;Input &quot;が付加された名前になり、&quot;Payload &quot;が付加された名前のオブジェクトが返されます。</target>
        </trans-unit>
        <trans-unit id="178b930518b904dbc5bd0f441c18fc870aac28c3" translate="yes" xml:space="preserve">
          <source>By default, Relay assumes that GraphQL is served at &lt;code&gt;/graphql&lt;/code&gt; relative to the origin where our application is served. This can be re-configured by injecting a custom instantiation of the default network layer.</source>
          <target state="translated">デフォルトでは、RelayはGraphQLが、アプリケーションが提供されているオリジンに対して &lt;code&gt;/graphql&lt;/code&gt; で提供されていると想定しています。これは、デフォルトのネットワーク層のカスタムインスタンスを挿入することで再構成できます。</target>
        </trans-unit>
        <trans-unit id="cb2b20c497e96eb4a4f4f36c0d7cc25608d4e73c" translate="yes" xml:space="preserve">
          <source>By default, Relay will only expose the data for fields explicitly requested by a &lt;a href=&quot;fragment-container#createfragmentcontainer&quot;&gt;component's fragment&lt;/a&gt;, which is known as &lt;a href=&quot;thinking-in-relay#data-masking&quot;&gt;data masking&lt;/a&gt;. Fragment data is unmasked for use in React components by &lt;code&gt;createFragmentContainer&lt;/code&gt;. However, you may want to use fragment data in non-React functions that are called from React.</source>
          <target state="translated">デフォルトでは、Relayは、&lt;a href=&quot;fragment-container#createfragmentcontainer&quot;&gt;コンポーネントのフラグメント&lt;/a&gt;によって明示的に要求されたフィールドのデータのみを公開します。これは、&lt;a href=&quot;thinking-in-relay#data-masking&quot;&gt;データマスキング&lt;/a&gt;と呼ばれます。フラグメントデータは、 &lt;code&gt;createFragmentContainer&lt;/code&gt; によってReactコンポーネントで使用するためにマスク解除されます。ただし、Reactから呼び出される非React関数でフラグメントデータを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="c01482f7fe504d2a5e3cc944236d88811dd8d351" translate="yes" xml:space="preserve">
          <source>By default, nothing is rendered while loading data for the initial render. If a previous set of &lt;code&gt;Component&lt;/code&gt; and &lt;code&gt;route&lt;/code&gt; were fulfilled and rendered, the default behavior is to continue rendering the previous view.</source>
          <target state="translated">デフォルトでは、初期レンダリング用のデータをロードしている間は何もレンダリングされません。 &lt;code&gt;Component&lt;/code&gt; と &lt;code&gt;route&lt;/code&gt; 以前のセットが満たされ、レンダリングされた場合、デフォルトの動作では、前のビューのレンダリングが続行されます。</target>
        </trans-unit>
        <trans-unit id="4375c1481c81a0b6d8e08ac19523704d5d4da90b" translate="yes" xml:space="preserve">
          <source>Cache Consistency</source>
          <target state="translated">キャッシュの一貫性</target>
        </trans-unit>
        <trans-unit id="14776554d5693e023c3ac7a5a65e4a5058537dfe" translate="yes" xml:space="preserve">
          <source>Cache Updates</source>
          <target state="translated">キャッシュ更新</target>
        </trans-unit>
        <trans-unit id="60790f7c84170a8b87051d7e857118ffeb0465ee" translate="yes" xml:space="preserve">
          <source>Caching</source>
          <target state="translated">Caching</target>
        </trans-unit>
        <trans-unit id="eed1812845bba88a7ea96dc0731ed87a6365fcc0" translate="yes" xml:space="preserve">
          <source>Caching A Graph</source>
          <target state="translated">グラフのキャッシング</target>
        </trans-unit>
        <trans-unit id="c3fbd240479228aa26381115ef997022e9773856" translate="yes" xml:space="preserve">
          <source>Call this to optimistically apply an update to the store.</source>
          <target state="translated">これを呼び出して楽観的にストアにアップデートを適用します。</target>
        </trans-unit>
        <trans-unit id="ef28016b715246d53e3c0aef32bef448a5df1961" translate="yes" xml:space="preserve">
          <source>Call this to send the mutation to the server.</source>
          <target state="translated">これを呼び出すと、突然変異をサーバーに送信します。</target>
        </trans-unit>
        <trans-unit id="36653c1ff08edcb50e3d0e9893272cf6219ebfe7" translate="yes" xml:space="preserve">
          <source>Callers must provide an appropriate &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;variables&lt;/code&gt;. As per the GraphQL Relay Specification:</source>
          <target state="translated">呼び出し元は、適切な &lt;code&gt;query&lt;/code&gt; と &lt;code&gt;variables&lt;/code&gt; 提供する必要があります。GraphQLリレー仕様に従って：</target>
        </trans-unit>
        <trans-unit id="ec585c24a23bd7001c34d954b9fe9b0796cec5f2" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;hasOptimisticUpdate&lt;/code&gt; with a record from &lt;code&gt;this.props&lt;/code&gt; will return whether that given record is affected by an optimistic mutation. It allows the component to render local optimistic changes differently from data that has successfully synchronized with the server.</source>
          <target state="translated">&lt;code&gt;hasOptimisticUpdate&lt;/code&gt; のレコードを使用してhasOptimisticUpdateを呼び出すと、指定されたレコードが楽観的ミュー &lt;code&gt;this.props&lt;/code&gt; 影響を受けるかどうかが返されます。これにより、コンポーネントは、サーバーと正常に同期したデータとは異なり、ローカルの楽観的な変更をレンダリングできます。</target>
        </trans-unit>
        <trans-unit id="7e92933047a9a8b8023050178520d6236fd1d0bd" translate="yes" xml:space="preserve">
          <source>Calling Component Instance Methods</source>
          <target state="translated">コンポーネント インスタンス メソッドの呼び出し</target>
        </trans-unit>
        <trans-unit id="539001ff0ade75c366a1d2f2ae990718f2b4bd9b" translate="yes" xml:space="preserve">
          <source>Can QueryRenderer using Classic Environment (&lt;code&gt;Store&lt;/code&gt; in &lt;code&gt;react-relay/classic&lt;/code&gt;) use:</source>
          <target state="translated">Classic環境を使用して缶QueryRenderer（ &lt;code&gt;Store&lt;/code&gt; で &lt;code&gt;react-relay/classic&lt;/code&gt; 使用）：</target>
        </trans-unit>
        <trans-unit id="4aacaa8308c0d89cb19bc6280f172bcb3027eef8" translate="yes" xml:space="preserve">
          <source>Can QueryRenderer using Modern Environment use:</source>
          <target state="translated">現代環境を利用した QueryRenderer は使用できますか?</target>
        </trans-unit>
        <trans-unit id="1003218887eb40c1f0a58bc7b7505d15f23175bf" translate="yes" xml:space="preserve">
          <source>Can React Classic Component use:</source>
          <target state="translated">React Classic Componentを使用することができます。</target>
        </trans-unit>
        <trans-unit id="84238b1b418a17b213190530f83d669483ad4f99" translate="yes" xml:space="preserve">
          <source>Can React Compat Component use:</source>
          <target state="translated">React Compat Componentを使用することができます。</target>
        </trans-unit>
        <trans-unit id="1c53c8d6a82f41f51bcb44a951f6d42bbd674773" translate="yes" xml:space="preserve">
          <source>Can React Modern Component use:</source>
          <target state="translated">React Modern Componentを使用することができます。</target>
        </trans-unit>
        <trans-unit id="ce811e756a396388182f7a8551a77979cea636ea" translate="yes" xml:space="preserve">
          <source>Can RelayRootContainer use:</source>
          <target state="translated">RelayRootContainerを使用することができます。</target>
        </trans-unit>
        <trans-unit id="918e312c8dc15e096c8aa60a584cd24fb9b592cd" translate="yes" xml:space="preserve">
          <source>Changing Arguments</source>
          <target state="translated">引数の変更</target>
        </trans-unit>
        <trans-unit id="51cdd39226322d9d0efb448c0d03eb64cb6c777d" translate="yes" xml:space="preserve">
          <source>Changing one thing in a system can have a ripple effect that causes other things to change in turn. Imagine a mutation that we can use to accept a friend request. This can have wide implications:</source>
          <target state="translated">システムの中で一つのことを変更すると、他のことを順番に変更させる波及効果を持つことができます。友達のリクエストを受け入れるための突然変異を想像してみてください。これは幅広い意味合いを持つ可能性があります。</target>
        </trans-unit>
        <trans-unit id="bb73c6b849ccfd7df64b939d3890bbba8b94e10a" translate="yes" xml:space="preserve">
          <source>Classic Component</source>
          <target state="translated">クラシックコンポーネント</target>
        </trans-unit>
        <trans-unit id="9e402ea82ec577f1a7b994361d91b4f9ac1cf510" translate="yes" xml:space="preserve">
          <source>Classic Mutation</source>
          <target state="translated">古典的な突然変異</target>
        </trans-unit>
        <trans-unit id="76be385c076bd3cf6a0e76bbefee914b22199f01" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;&amp;lt;RelayRootContainer&amp;gt;&lt;/code&gt;</source>
          <target state="translated">クラシック： &lt;code&gt;&amp;lt;RelayRootContainer&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9450d4893299b4475b958954ce614f6339c011c9" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;Relay.createContainer&lt;/code&gt;</source>
          <target state="translated">クラシック： &lt;code&gt;Relay.createContainer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdacd86df881f947250264b6f74153f74ca2e17b" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.commitUpdate(mutation...)&lt;/code&gt;</source>
          <target state="translated">クラシック： &lt;code&gt;this.props.relay.commitUpdate(mutation...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4496ce0ff60c519ddb23c737b94a8c3d0f8fae44" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt;</source>
          <target state="translated">クラシック： &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4718307cda6ad09eb778eec75ee2c5f20cd45961" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.setVariable({count: prevCount + pageSize}...)&lt;/code&gt;</source>
          <target state="translated">クラシック： &lt;code&gt;this.props.relay.setVariable({count: prevCount + pageSize}...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a88cd760542eea1905cd9d8225750e276c483cde" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.setVariable({foo: bar}...)&lt;/code&gt;</source>
          <target state="translated">クラシック： &lt;code&gt;this.props.relay.setVariable({foo: bar}...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6f5633b3ae0188027fabbde415e0f3fcc71e6c3" translate="yes" xml:space="preserve">
          <source>Client Caching</source>
          <target state="translated">クライアントキャッシング</target>
        </trans-unit>
        <trans-unit id="d4d64d5c478ea7fd0df7b8579f158dc6ea90455b" translate="yes" xml:space="preserve">
          <source>Client Schema Extensions (Experimental)</source>
          <target state="translated">クライアントスキーマ拡張 (実験)</target>
        </trans-unit>
        <trans-unit id="825764a68e0dc6e933619f703142c815e2415444" translate="yes" xml:space="preserve">
          <source>Client schema extensions</source>
          <target state="translated">クライアントスキーマ拡張機能</target>
        </trans-unit>
        <trans-unit id="37d72336fa3d155eac5f2b8f6e5f8d2e326546c2" translate="yes" xml:space="preserve">
          <source>Committing Local Updates</source>
          <target state="translated">ローカル更新のコミット</target>
        </trans-unit>
        <trans-unit id="a359c7ebffb6706034dbf0f013aa73bcc550292c" translate="yes" xml:space="preserve">
          <source>Comparing Relay Classic and Relay Modern</source>
          <target state="translated">Relay ClassicとRelay Modernを比較</target>
        </trans-unit>
        <trans-unit id="fb10d488b2ce3717647b6821e5a1c02381aeca3a" translate="yes" xml:space="preserve">
          <source>Comparison to Classic Relay</source>
          <target state="translated">クラシックリレーとの比較</target>
        </trans-unit>
        <trans-unit id="c54dbbae41b051460dcc8e3c9aa6f310af3f2775" translate="yes" xml:space="preserve">
          <source>Compat Component</source>
          <target state="translated">コンパットコンポーネント</target>
        </trans-unit>
        <trans-unit id="2171ca54b3db409d7e88bfa689ea2ab5583955c6" translate="yes" xml:space="preserve">
          <source>Compat Mode</source>
          <target state="translated">コンパットモード</target>
        </trans-unit>
        <trans-unit id="ef1a53514cc801546fdbf4bd01e2b4b764618f78" translate="yes" xml:space="preserve">
          <source>Compat Mutation</source>
          <target state="translated">コンパットの突然変異</target>
        </trans-unit>
        <trans-unit id="7ae7318a99d95f75927a3ae6b936e04d175cc04e" translate="yes" xml:space="preserve">
          <source>Compatibility Cheatsheet</source>
          <target state="translated">互換性チェックシート</target>
        </trans-unit>
        <trans-unit id="6d9f235cb9c7c65f0cf0b1b0814cadde6d86abcb" translate="yes" xml:space="preserve">
          <source>Compatibility Mode</source>
          <target state="translated">互換性モード</target>
        </trans-unit>
        <trans-unit id="e2e7a6441928ea51ba685ebeb68d5198d58d0008" translate="yes" xml:space="preserve">
          <source>Compiler Architecture</source>
          <target state="translated">コンパイラアーキテクチャ</target>
        </trans-unit>
        <trans-unit id="89e9d1be17321688f8d0501eb1a3bf2c6ca26c3e" translate="yes" xml:space="preserve">
          <source>Complete details on how the server should behave are available in the &lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;GraphQL Cursor Connections&lt;/a&gt; spec.</source>
          <target state="translated">サーバーの動作に関する詳細は、&lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;GraphQL Cursor Connections&lt;/a&gt;仕様に記載されています。</target>
        </trans-unit>
        <trans-unit id="29619ae00dc1b1f13f0d8573c5ca62184c0a6a94" translate="yes" xml:space="preserve">
          <source>Complete details on how the server should behave are available in the &lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;GraphQL Input Object Mutations&lt;/a&gt; spec.</source>
          <target state="translated">サーバーの動作の詳細については、&lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;GraphQL入力オブジェクト変更&lt;/a&gt;仕様をご覧ください。</target>
        </trans-unit>
        <trans-unit id="dd80bd3e0728573910ceff942d6bf05bb7333573" translate="yes" xml:space="preserve">
          <source>Complete details on how the server should behave are available in the &lt;a href=&quot;https://facebook.github.io/relay/graphql/objectidentification.htm&quot;&gt;GraphQL Object Identification&lt;/a&gt; spec.</source>
          <target state="translated">サーバーの動作の詳細については、&lt;a href=&quot;https://facebook.github.io/relay/graphql/objectidentification.htm&quot;&gt;GraphQLオブジェクト識別&lt;/a&gt;仕様を参照してください。</target>
        </trans-unit>
        <trans-unit id="c92c529e0731c57efd7550480196484040b33c3e" translate="yes" xml:space="preserve">
          <source>Component</source>
          <target state="translated">Component</target>
        </trans-unit>
        <trans-unit id="725a4ffad64df11f9defa669f85ec107f9dc492d" translate="yes" xml:space="preserve">
          <source>Component and Route</source>
          <target state="translated">コンポーネントとルート</target>
        </trans-unit>
        <trans-unit id="94c5c072cfb48e6d9ea12f613a057a202a5c287b" translate="yes" xml:space="preserve">
          <source>Components can change their data requirements by using &lt;code&gt;setVariables&lt;/code&gt; to request an update to the current set of &lt;code&gt;variables&lt;/code&gt;.</source>
          <target state="translated">コンポーネントは、 &lt;code&gt;setVariables&lt;/code&gt; を使用して現在の &lt;code&gt;variables&lt;/code&gt; セットの更新を要求することにより、データ要件を変更できます。</target>
        </trans-unit>
        <trans-unit id="31ae8b82fb482703d4497f95cafdbd464174a12e" translate="yes" xml:space="preserve">
          <source>Components can inspect pending mutations on any record (i.e. data made available in props with a corresponding fragment). Calling &lt;code&gt;getPendingTransactions&lt;/code&gt; with a record will return a list of the pending mutation transactions that affect that particular record.</source>
          <target state="translated">コンポーネントは、任意のレコード（つまり、対応するフラグメントを持つ小道具で使用可能にされたデータ）で保留中の変異を検査できます。レコードを &lt;code&gt;getPendingTransactions&lt;/code&gt; してgetPendingTransactionsを呼び出すと、その特定のレコードに影響する保留中のミューテーショントランザクションのリストが返されます。</target>
        </trans-unit>
        <trans-unit id="deee480cd52fae7c121c1d7b8b86ecda66617156" translate="yes" xml:space="preserve">
          <source>Composing Fragments</source>
          <target state="translated">フラグメントの構成</target>
        </trans-unit>
        <trans-unit id="0c70e5846878a796dcb7c94e3f0ca5de9a047eee" translate="yes" xml:space="preserve">
          <source>Composing Views</source>
          <target state="translated">ビューの構成</target>
        </trans-unit>
        <trans-unit id="2a321a9ac4f3111d95368aba4e87b1917d75348e" translate="yes" xml:space="preserve">
          <source>Composing Views - It's Plain React</source>
          <target state="translated">ビューを構成する-シンプルなReact</target>
        </trans-unit>
        <trans-unit id="723e2c15fe85b32b7d864e21eb29e93116b04e14" translate="yes" xml:space="preserve">
          <source>Composing child component fragments in a parent fragment.</source>
          <target state="translated">親フラグメントに子コンポーネントフラグメントを合成する。</target>
        </trans-unit>
        <trans-unit id="f82641d3cbab73b5e585b20db3196f350cb839d5" translate="yes" xml:space="preserve">
          <source>Composing fragments defined as local variables.</source>
          <target state="translated">ローカル変数として定義されたフラグメントを構成します。</target>
        </trans-unit>
        <trans-unit id="114b9abd3f0b27b8a9b5084318c5af838acdb163" translate="yes" xml:space="preserve">
          <source>Composing the data descriptions.</source>
          <target state="translated">データの記述を構成する。</target>
        </trans-unit>
        <trans-unit id="59d6b2067a223146a5ead92a4c5fe072d43c9a1e" translate="yes" xml:space="preserve">
          <source>Composing the fragments of child components is discussed in detail in the &lt;a href=&quot;guides-containers&quot;&gt;Containers Guide&lt;/a&gt;, but here's a quick example:</source>
          <target state="translated">子コンポーネントのフラグメントの作成については、&lt;a href=&quot;guides-containers&quot;&gt;コンテナガイド&lt;/a&gt;で詳しく説明していますが、簡単な例を次に示します。</target>
        </trans-unit>
        <trans-unit id="a7b041783bd841c2982c635611a14b9b0478fc32" translate="yes" xml:space="preserve">
          <source>Composing the view logic, and</source>
          <target state="translated">ビューロジックを構成し</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="9d60520748b88da0348eeb8f6543f6f98cdbd262" translate="yes" xml:space="preserve">
          <source>Conditional fields</source>
          <target state="translated">条件付きフィールド</target>
        </trans-unit>
        <trans-unit id="6355cff1e61b5cd688cec493b080516655b2ac6a" translate="yes" xml:space="preserve">
          <source>Configs</source>
          <target state="translated">Configs</target>
        </trans-unit>
        <trans-unit id="2de632b51a33bf8e3ed45599633fb58061f6d4dc" translate="yes" xml:space="preserve">
          <source>Configure Network</source>
          <target state="translated">ネットワークの設定</target>
        </trans-unit>
        <trans-unit id="6512ee1541e9a6c52d5bf7cf465332e8df25ea3c" translate="yes" xml:space="preserve">
          <source>Connection</source>
          <target state="translated">Connection</target>
        </trans-unit>
        <trans-unit id="2d3d0c339708a6485641055e4d0d9e905ec021cc" translate="yes" xml:space="preserve">
          <source>ConnectionHandler</source>
          <target state="translated">ConnectionHandler</target>
        </trans-unit>
        <trans-unit id="81ea0a30d213381b26e05bce9c491003535b147a" translate="yes" xml:space="preserve">
          <source>Consider an input with a server-defined placeholder text and an imperative method to focus the input node:</source>
          <target state="translated">サーバー定義のプレースホルダテキストを持つ入力と、入力ノードにフォーカスを当てるための命令的な方法を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="1956d506ca97255f5713770475161b61eb6cde73" translate="yes" xml:space="preserve">
          <source>Consider rendering the text and comments of a story along with the corresponding author names and photos. Here's the GraphQL query:</source>
          <target state="translated">ストーリーのテキストとコメントを、対応する著者名と写真とともにレンダリングすることを考えてみましょう。これがGraphQLクエリです。</target>
        </trans-unit>
        <trans-unit id="e6443af99d2f470f50affd5057bf48db2d09dae4" translate="yes" xml:space="preserve">
          <source>Container</source>
          <target state="translated">Container</target>
        </trans-unit>
        <trans-unit id="0d5a8d03518c194626d6e3e124e7de20c17a7fe5" translate="yes" xml:space="preserve">
          <source>Container Composition</source>
          <target state="translated">コンテナの構成</target>
        </trans-unit>
        <trans-unit id="b625b62c69e181700306e0871c20a6c94eaa2510" translate="yes" xml:space="preserve">
          <source>Container Specification</source>
          <target state="translated">コンテナ仕様</target>
        </trans-unit>
        <trans-unit id="dfe33c87ae0783b9497dae2f22418a5e90385aa4" translate="yes" xml:space="preserve">
          <source>Container.getFragment()</source>
          <target state="translated">Container.getFragment()</target>
        </trans-unit>
        <trans-unit id="e040a458f46532a90ec69fa0b4bfc33ba151c98b" translate="yes" xml:space="preserve">
          <source>Containers</source>
          <target state="translated">Containers</target>
        </trans-unit>
        <trans-unit id="4b51306faf49817c8299a221a2777da9319cb8d3" translate="yes" xml:space="preserve">
          <source>Containers are Higher-Order Components</source>
          <target state="translated">コンテナは高次部品</target>
        </trans-unit>
        <trans-unit id="46e795775ec1e8e3e71a6a5641d35b084e19a5a9" translate="yes" xml:space="preserve">
          <source>Containers can define a &lt;code&gt;prepareVariables&lt;/code&gt; method which provides the opportunity to modify the variables that are available to fragments. The new variables can be generated based on the previous variables (or the &lt;code&gt;initialVariables&lt;/code&gt; if no previous ones exist) in addition to the runtime environment.</source>
          <target state="translated">コンテナーは、フラグメントで使用可能な変数を変更する機会を提供する &lt;code&gt;prepareVariables&lt;/code&gt; メソッドを定義できます。新しい変数は、ランタイム環境に加えて、以前の変数（または、以前の変数が存在しない場合は &lt;code&gt;initialVariables&lt;/code&gt; ）に基づいて生成できます。</target>
        </trans-unit>
        <trans-unit id="ad0eb4a22e44d99ae045c52ec3f202dc664a29f9" translate="yes" xml:space="preserve">
          <source>Containers declare data requirements on &lt;code&gt;fragments&lt;/code&gt; using GraphQL fragments.</source>
          <target state="translated">コンテナは、GraphQLフラグメントを使用して &lt;code&gt;fragments&lt;/code&gt; データ要件を宣言します。</target>
        </trans-unit>
        <trans-unit id="8928f5de2a918d60f1bbb5d72e6a68cb7502e86a" translate="yes" xml:space="preserve">
          <source>Convenience method that wraps the constructor, passing some default parameters and returning an instance.</source>
          <target state="translated">コンストラクタをラップし、いくつかのデフォルトパラメータを渡してインスタンスを返す便利なメソッドです。</target>
        </trans-unit>
        <trans-unit id="dd226f43ba5c8ff842931a3ca2796d7c444510a9" translate="yes" xml:space="preserve">
          <source>Conversion Playbook</source>
          <target state="translated">コンバージョンプレイブック</target>
        </trans-unit>
        <trans-unit id="aca075e23eed144339279d097d6fa88dc0718ec3" translate="yes" xml:space="preserve">
          <source>Conversion Scripts</source>
          <target state="translated">変換スクリプト</target>
        </trans-unit>
        <trans-unit id="bc6e3a410aa372c2487ec123aa51c13c61ba9355" translate="yes" xml:space="preserve">
          <source>Core Modules</source>
          <target state="translated">コアモジュール</target>
        </trans-unit>
        <trans-unit id="06ee6cde901e483137128dd1aaa541e9ba1b4f92" translate="yes" xml:space="preserve">
          <source>Core primitives for building offline/persisted caching.</source>
          <target state="translated">オフライン/パーステッドキャッシングを構築するためのコアプリミティブ。</target>
        </trans-unit>
        <trans-unit id="7b3852c7992c04bd7a1c305779c938fba2763c16" translate="yes" xml:space="preserve">
          <source>Core primitives to enable subscriptions.</source>
          <target state="translated">サブスクリプションを有効にするためのコアプリミティブ。</target>
        </trans-unit>
        <trans-unit id="e93c185376ad3e3749d528694597be4eb780596d" translate="yes" xml:space="preserve">
          <source>Create a mutation instance using the &lt;code&gt;new&lt;/code&gt; keyword, optionally passing it some props. Note that &lt;code&gt;this.props&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; available inside the constructor function, but are set for all the methods mentioned below (&lt;code&gt;getCollisionKey&lt;/code&gt;, &lt;code&gt;getOptimisticResponse&lt;/code&gt;, etc). This restriction is due to the fact that mutation props may depend on data from the RelayEnvironment, which isn't known until the mutation is applied with &lt;code&gt;applyUpdate&lt;/code&gt; or &lt;code&gt;commitUpdate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; キーワードを使用してミューテーションインスタンスを作成し、必要に応じて小道具を渡します。 &lt;code&gt;this.props&lt;/code&gt; はコンストラクター関数内で&lt;em&gt;は&lt;/em&gt;使用でき&lt;em&gt;ませ&lt;/em&gt;んが、以下で説明するすべてのメソッド（ &lt;code&gt;getCollisionKey&lt;/code&gt; 、 &lt;code&gt;getOptimisticResponse&lt;/code&gt; など）に対して設定されることに注意してください。この制限は、変異の小道具がRelayEnvironmentからのデータに依存する可能性があるという事実によるものです。これは、変異が &lt;code&gt;applyUpdate&lt;/code&gt; または &lt;code&gt;commitUpdate&lt;/code&gt; で適用されるまで不明です。</target>
        </trans-unit>
        <trans-unit id="70fb5b0ec1a182be6e0a0d9950900f7bbb367668" translate="yes" xml:space="preserve">
          <source>Create a route instance using the &lt;code&gt;new&lt;/code&gt; keyword, optionally passing it some params.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; キーワードを使用してルートインスタンスを作成し、オプションでいくつかのパラメータを渡します。</target>
        </trans-unit>
        <trans-unit id="22330ce575ca322006e65a1cba21c0878bcce956" translate="yes" xml:space="preserve">
          <source>Creates a new Relay Container - see the &lt;a href=&quot;guides-containers&quot;&gt;Container Guide&lt;/a&gt; for more details and examples.</source>
          <target state="translated">新しいリレーコンテナーを作成します- 詳細と例については、&lt;a href=&quot;guides-containers&quot;&gt;コンテナーガイド&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="59d477c173081caca582f697a308e90dad49d280" translate="yes" xml:space="preserve">
          <source>Creates a new record in the store given a &lt;code&gt;dataID&lt;/code&gt; and the &lt;code&gt;typeName&lt;/code&gt; as defined by the GraphQL schema. Returns a &lt;a href=&quot;#recordproxy&quot;&gt;&lt;code&gt;RecordProxy&lt;/code&gt;&lt;/a&gt; which serves as an interface to mutate the newly created record.</source>
          <target state="translated">GraphQLスキーマで定義されている &lt;code&gt;dataID&lt;/code&gt; と &lt;code&gt;typeName&lt;/code&gt; を指定して、ストアに新しいレコードを作成します。新しく作成されたレコードを変更するためのインターフェイスとして機能する&lt;a href=&quot;#recordproxy&quot;&gt; &lt;code&gt;RecordProxy&lt;/code&gt; &lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="21efb0843ee16f4a18b237b51a057d09100b1064" translate="yes" xml:space="preserve">
          <source>Creates an edge given a &lt;a href=&quot;#recordsourceselectorproxy&quot;&gt;&lt;code&gt;store&lt;/code&gt;&lt;/a&gt;, a connection, the edge type, and a record that holds that connection.</source>
          <target state="translated">&lt;a href=&quot;#recordsourceselectorproxy&quot;&gt; &lt;code&gt;store&lt;/code&gt; &lt;/a&gt;、接続、エッジタイプ、およびその接続を保持するレコードを指定してエッジを作成します。</target>
        </trans-unit>
        <trans-unit id="cc084a8dfcc6a7bce1de7aefac278e961edc50ea" translate="yes" xml:space="preserve">
          <source>Currently the easiest way to create a network layer is via a helper from the &lt;code&gt;relay-runtime&lt;/code&gt; package:</source>
          <target state="translated">現在、ネットワーク層を作成する最も簡単な方法は、 &lt;code&gt;relay-runtime&lt;/code&gt; パッケージのヘルパーを使用することです。</target>
        </trans-unit>
        <trans-unit id="461be9b9f59ebf2cd3bfe288b44d41bb20a992dc" translate="yes" xml:space="preserve">
          <source>Custom HTTP headers can be configured by providing a &lt;code&gt;headers&lt;/code&gt; object:</source>
          <target state="translated">カスタムHTTPヘッダーは、 &lt;code&gt;headers&lt;/code&gt; オブジェクトを提供することで構成できます。</target>
        </trans-unit>
        <trans-unit id="e441c87bb7618c55b15a3915a29a65fc20c0d1cd" translate="yes" xml:space="preserve">
          <source>Custom Network Layers</source>
          <target state="translated">カスタムネットワークレイヤー</target>
        </trans-unit>
        <trans-unit id="c604943e72b71d4741cddde2419706b8dc35d372" translate="yes" xml:space="preserve">
          <source>Custom Routing and More</source>
          <target state="translated">カスタムルーティングとその他</target>
        </trans-unit>
        <trans-unit id="3fe80ac6912200b4e6e928a52d6c87fd5c777197" translate="yes" xml:space="preserve">
          <source>Custom network layers must conform to the following &lt;a href=&quot;interfaces-relay-network-layer&quot;&gt;RelayNetworkLayer&lt;/a&gt; interface. Although the default network layer is an instantiable class that accepts some configuration, this is not a requirement of an injected network layer.</source>
          <target state="translated">カスタムネットワークレイヤーは、次の&lt;a href=&quot;interfaces-relay-network-layer&quot;&gt;RelayNetworkLayer&lt;/a&gt;インターフェイスに準拠する必要があります。デフォルトのネットワーク層は、いくつかの構成を受け入れるインスタンス化可能なクラスですが、これは注入されたネットワーク層の要件ではありません。</target>
        </trans-unit>
        <trans-unit id="342f49485ae8bc8e1ade62ea93e337457051f472" translate="yes" xml:space="preserve">
          <source>Custom network layers that must conform to the &lt;code&gt;RelayNetworkLayer&lt;/code&gt; interface.</source>
          <target state="translated">&lt;code&gt;RelayNetworkLayer&lt;/code&gt; インターフェイスに準拠する必要があるカスタムネットワークレイヤー。</target>
        </trans-unit>
        <trans-unit id="8e195dc960c4de2f5938ab244ca476e61a3b512b" translate="yes" xml:space="preserve">
          <source>Custom open-source implementations</source>
          <target state="translated">オープンソースのカスタム実装</target>
        </trans-unit>
        <trans-unit id="74c9c9c8ea99084415bd2064a41ac8fc43148678" translate="yes" xml:space="preserve">
          <source>Data Components aka Containers</source>
          <target state="translated">データ コンポーネント(別名:コンテナ</target>
        </trans-unit>
        <trans-unit id="682fde2c24e47bc1edbae33948606de2438e015b" translate="yes" xml:space="preserve">
          <source>Data Dependencies With GraphQL</source>
          <target state="translated">GraphQLによるデータの依存関係</target>
        </trans-unit>
        <trans-unit id="d3ef9a304a148420eba3a55c129f2235b1f9e1ec" translate="yes" xml:space="preserve">
          <source>Data Flow</source>
          <target state="translated">データの流れ</target>
        </trans-unit>
        <trans-unit id="b8344c50bb3999d69b17cd5abd2f78e4f029419a" translate="yes" xml:space="preserve">
          <source>Data Masking</source>
          <target state="translated">データマスキング</target>
        </trans-unit>
        <trans-unit id="9f570bdcfd6b031f335934a6700ab99601783168" translate="yes" xml:space="preserve">
          <source>Data Model</source>
          <target state="translated">データモデル</target>
        </trans-unit>
        <trans-unit id="c18842877f84be9bb3ae10673c4e60242f22c160" translate="yes" xml:space="preserve">
          <source>Data Types</source>
          <target state="translated">データ型</target>
        </trans-unit>
        <trans-unit id="f1e75bbe26916d6856acc894895802461b7a14ea" translate="yes" xml:space="preserve">
          <source>Data Types &amp;amp; Modules</source>
          <target state="translated">データ型とモジュール</target>
        </trans-unit>
        <trans-unit id="7054bcb2316977418a434163d17919c53dc34953" translate="yes" xml:space="preserve">
          <source>Data fetched as a result of a &lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; config is not written into the client store, but you can add code that processes it in the &lt;code&gt;onSuccess&lt;/code&gt; callback that you pass into &lt;code&gt;commitUpdate()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; 構成の結果としてフェッチされたデータはクライアントストアに書き込まれませんが、 &lt;code&gt;commitUpdate()&lt;/code&gt; に渡す &lt;code&gt;onSuccess&lt;/code&gt; コールバックにそれを処理するコードを追加できます。</target>
        </trans-unit>
        <trans-unit id="af0a7349a2e7fc64dce9051e92bfe24510a15ba4" translate="yes" xml:space="preserve">
          <source>Data-Fetching APIs</source>
          <target state="translated">データフェッチ API</target>
        </trans-unit>
        <trans-unit id="303a7cb486f5bdd65204f79dab8db7f52fcbe4b2" translate="yes" xml:space="preserve">
          <source>Data/View Consistency</source>
          <target state="translated">データ/ビューの一貫性</target>
        </trans-unit>
        <trans-unit id="895b27c88016513d278a0ce3dc0663fae3829d58" translate="yes" xml:space="preserve">
          <source>Debugging</source>
          <target state="translated">Debugging</target>
        </trans-unit>
        <trans-unit id="ed85a15e615bc7cc2aa9ef71ae94ad5fcb7456cf" translate="yes" xml:space="preserve">
          <source>Debugging Programmatically</source>
          <target state="translated">プログラムによるデバッグ</target>
        </trans-unit>
        <trans-unit id="45cae91f4ddfa0491f43cb639f9ed34ee522658d" translate="yes" xml:space="preserve">
          <source>Debugging Visually</source>
          <target state="translated">視覚的なデバッグ</target>
        </trans-unit>
        <trans-unit id="f33d59090001ed2c388b4cc1db43054af86f06dd" translate="yes" xml:space="preserve">
          <source>Default Network Layer</source>
          <target state="translated">デフォルトのネットワークレイヤ</target>
        </trans-unit>
        <trans-unit id="20f0fc44b4326d9865c55f56d274d841f7d0587e" translate="yes" xml:space="preserve">
          <source>DefaultNetworkLayer (static property)</source>
          <target state="translated">DefaultNetworkLayer(静的プロパティ</target>
        </trans-unit>
        <trans-unit id="cc401fba47cbe2915424897d3b03537f262c5e09" translate="yes" xml:space="preserve">
          <source>Defining Containers</source>
          <target state="translated">コンテナの定義</target>
        </trans-unit>
        <trans-unit id="c761cb3b3af168784bb525eb6cc8bdda8deb1143" translate="yes" xml:space="preserve">
          <source>Deletes a record from the store given its &lt;code&gt;dataID&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dataID&lt;/code&gt; を指定してストアからレコードを削除します。</target>
        </trans-unit>
        <trans-unit id="af5bf36afc63e00856e220e9305692ac4cae2b78" translate="yes" xml:space="preserve">
          <source>Design a fat query that covers every possible field that could change:</source>
          <target state="translated">変更される可能性のあるすべてのフィールドをカバーするように、太いクエリを設計します。</target>
        </trans-unit>
        <trans-unit id="28c82071e940360118b0611d5c912a71c32a0100" translate="yes" xml:space="preserve">
          <source>Directives</source>
          <target state="translated">Directives</target>
        </trans-unit>
        <trans-unit id="ef7942184e9ad574a626b6cd3619cdb041e9c029" translate="yes" xml:space="preserve">
          <source>During this migration, use the &lt;a href=&quot;relay-compat&quot;&gt;Relay Compat&lt;/a&gt; tools and APIs to work with both Relay Classic and Relay Modern.</source>
          <target state="translated">この移行中に、&lt;a href=&quot;relay-compat&quot;&gt;Relay Compat&lt;/a&gt;ツールとAPIを使用して、Relay ClassicとRelay Modernの両方を操作します。</target>
        </trans-unit>
        <trans-unit id="7c5b3fea8b3510ceda05e64bba7877572b147261" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;RelayMutationTransaction&lt;/code&gt; has methods to check the status of the mutation and provide ways to rollback or resend the mutation as needed.</source>
          <target state="translated">各 &lt;code&gt;RelayMutationTransaction&lt;/code&gt; には、ミューテーションのステータスを確認し、必要に応じてミューテーションをロールバックまたは再送信する方法を提供するメソッドがあります。</target>
        </trans-unit>
        <trans-unit id="fbce231c1e8a474ca4ecbc6efb0b7e9a89704719" translate="yes" xml:space="preserve">
          <source>Edge creation and insertion</source>
          <target state="translated">エッジの作成と挿入</target>
        </trans-unit>
        <trans-unit id="bd362bb1462055d845230a17457c0b8e8d86a3b8" translate="yes" xml:space="preserve">
          <source>Either an instance of &lt;code&gt;Relay.Route&lt;/code&gt; or an object with the &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;queries&lt;/code&gt;, and optionally the &lt;code&gt;params&lt;/code&gt; properties.</source>
          <target state="translated">&lt;code&gt;Relay.Route&lt;/code&gt; のインスタンス、または &lt;code&gt;name&lt;/code&gt; 、 &lt;code&gt;queries&lt;/code&gt; 、およびオプションで &lt;code&gt;params&lt;/code&gt; プロパティを持つオブジェクトのいずれか。</target>
        </trans-unit>
        <trans-unit id="d443a1185575c125d61e0af393b044d7b06ef572" translate="yes" xml:space="preserve">
          <source>Environment</source>
          <target state="translated">Environment</target>
        </trans-unit>
        <trans-unit id="b887632c87cffc81f6686f76c25016e576fb2182" translate="yes" xml:space="preserve">
          <source>Even though we have access to the &lt;code&gt;data&lt;/code&gt; object in &lt;code&gt;renderFetched&lt;/code&gt;, the actual data is intentionally opaque. This prevents the &lt;code&gt;renderFetched&lt;/code&gt; from creating an implicit dependency on the fragments declared by &lt;code&gt;Component&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;renderFetched&lt;/code&gt; で &lt;code&gt;data&lt;/code&gt; オブジェクトにアクセスできる場合でも、実際のデータは意図的に不透明です。これにより、 &lt;code&gt;renderFetched&lt;/code&gt; が &lt;code&gt;Component&lt;/code&gt; によって宣言されたフラグメントに暗黙的な依存関係を作成するのを防ぎます。</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="ee6ee8c5dded943d0aabd760c567c92f2ee1cb72" translate="yes" xml:space="preserve">
          <source>Example Data Flow: Fetching Query Data</source>
          <target state="translated">データフロー例:クエリデータの取得</target>
        </trans-unit>
        <trans-unit id="54a85f686c00fd7f5967d3cbaebf03180ef14d5b" translate="yes" xml:space="preserve">
          <source>Example Data Flow: Reading and Observing the Store</source>
          <target state="translated">データの流れの例。ストアの読み取りと観察</target>
        </trans-unit>
        <trans-unit id="0b92abde2e68af5a3c565dacca8e8cfd97caced5" translate="yes" xml:space="preserve">
          <source>Example of a simple mutation:</source>
          <target state="translated">単純な突然変異の例。</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="47edfe63fdfee7ee20d0d17ccd2198d126f5e61d" translate="yes" xml:space="preserve">
          <source>Examples on how to migrate &lt;code&gt;this.props.setVariables&lt;/code&gt; calls from the old API.</source>
          <target state="translated">&lt;code&gt;this.props.setVariables&lt;/code&gt; 呼び出しを古いAPIから移行する方法の例。</target>
        </trans-unit>
        <trans-unit id="dba94b198da2fb33fd23ea18f305f3d0a3ec1059" translate="yes" xml:space="preserve">
          <source>Extensible Core</source>
          <target state="translated">拡張可能コア</target>
        </trans-unit>
        <trans-unit id="2dd50f5706aa755699729587eac1b10f1cff5f0e" translate="yes" xml:space="preserve">
          <source>FIELDS_CHANGE</source>
          <target state="translated">FIELDS_CHANGE</target>
        </trans-unit>
        <trans-unit id="48bf3bbfe2cde9b89a0197b2bfecef97b15ae5d4" translate="yes" xml:space="preserve">
          <source>Fetching Data</source>
          <target state="translated">データの取得</target>
        </trans-unit>
        <trans-unit id="9fa4dbe72754c9ca8a7a48295981890f655e2aba" translate="yes" xml:space="preserve">
          <source>Fetching Data For a View</source>
          <target state="translated">ビューのデータ取得</target>
        </trans-unit>
        <trans-unit id="ec6417097316a1a14f3a999d488c8c77877598bd" translate="yes" xml:space="preserve">
          <source>Fetching Data from the Server</source>
          <target state="translated">サーバーからのデータの取得</target>
        </trans-unit>
        <trans-unit id="a342eda81c049d657e5bd1f80671b4b62b62acba" translate="yes" xml:space="preserve">
          <source>Fetching all the data for a view hierarchy.</source>
          <target state="translated">ビュー階層のすべてのデータを取得します。</target>
        </trans-unit>
        <trans-unit id="448b955ee10782eac37b116fa4e7872f8363dbf4" translate="yes" xml:space="preserve">
          <source>Fewer Requirements around Routing</source>
          <target state="translated">ルーティングに関する要件が少ない</target>
        </trans-unit>
        <trans-unit id="90c0db66830e63b9ba0686e057e6915aaf66921d" translate="yes" xml:space="preserve">
          <source>Finally, GraphQL is printed (e.g. to files, saved to a database, etc) and any artifacts are generated.</source>
          <target state="translated">最後に、GraphQLが印刷され(ファイルへの出力、データベースへの保存など)、任意の成果物が生成されます。</target>
        </trans-unit>
        <trans-unit id="6c0e1cc40fccace9c870f52b415d915d429a858c" translate="yes" xml:space="preserve">
          <source>Finally, let's tie it all together in &lt;code&gt;./js/components/App.js&lt;/code&gt;:</source>
          <target state="translated">最後に、すべてを &lt;code&gt;./js/components/App.js&lt;/code&gt; にまとめます。</target>
        </trans-unit>
        <trans-unit id="81320abd4244f533456ecdb31fa9235954b4c027" translate="yes" xml:space="preserve">
          <source>Finally, subscriptions whose data actually changed are notified via their callback.</source>
          <target state="translated">最後に、実際にデータが変更されたサブスクリプションは、コールバックで通知されます。</target>
        </trans-unit>
        <trans-unit id="794475575e8e8e88251415839f49042175570f60" translate="yes" xml:space="preserve">
          <source>Finally, we construct our schema (whose starting query type is the query type we defined above) and export it.</source>
          <target state="translated">最後に、スキーマを構築し(その開始クエリ型は上で定義したクエリ型です)、エクスポートします。</target>
        </trans-unit>
        <trans-unit id="f5d8e52e096ba49348c23c94d52fb5128a53fc82" translate="yes" xml:space="preserve">
          <source>Finds or creates a single record associated with a mutable record. This is a shortcut to &lt;code&gt;RelayRecordProxy.getLinkedRecord&lt;/code&gt; with &lt;code&gt;RelayRecordProxy.setLinkedRecord&lt;/code&gt; should the associated record be non-existant.</source>
          <target state="translated">変更可能なレコードに関連付けられた単一のレコードを検索または作成します。これは、関連するレコードが存在しない場合に、 &lt;code&gt;RelayRecordProxy.getLinkedRecord&lt;/code&gt; 持つ &lt;code&gt;RelayRecordProxy.setLinkedRecord&lt;/code&gt; へのショートカットです。</target>
        </trans-unit>
        <trans-unit id="d4726e1215a3598f0b285dcd1fdabf31356a5b5b" translate="yes" xml:space="preserve">
          <source>First, install the plugin (typically as a &lt;code&gt;devDependency&lt;/code&gt;):</source>
          <target state="translated">まず、プラグインをインストールします（通常は &lt;code&gt;devDependency&lt;/code&gt; として）。</target>
        </trans-unit>
        <trans-unit id="37434c70c94c9bba372cffd8d1a31c930d66efb8" translate="yes" xml:space="preserve">
          <source>First, let's take a look at a plain connection:</source>
          <target state="translated">まずは、素のつながりを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="9ee7304a030b3188f69053199e1aa24d2c7e6c40" translate="yes" xml:space="preserve">
          <source>First, let's take a look at the &lt;code&gt;environment&lt;/code&gt; input. To perform the mutation on the correct &lt;code&gt;environment&lt;/code&gt; with the relevant data, it's a good idea to use the &lt;code&gt;environment&lt;/code&gt; used to render the components. It's accessible at &lt;code&gt;this.props.relay.environment&lt;/code&gt; from the component.</source>
          <target state="translated">まず、 &lt;code&gt;environment&lt;/code&gt; 入力を見てみましょう。関連するデータを使用して正しい &lt;code&gt;environment&lt;/code&gt; で変更を実行するには、コンポーネントのレンダリングに使用される &lt;code&gt;environment&lt;/code&gt; 使用することをお勧めします。 &lt;code&gt;this.props.relay.environment&lt;/code&gt; からコンポーネントにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="c30bc0a2078d4d797890b53dd71501499ca6f601" translate="yes" xml:space="preserve">
          <source>First, the list of data IDs that have changed since the last &lt;code&gt;notify()&lt;/code&gt; is compared against data IDs listed in the subscription's latest &lt;code&gt;Snapshot&lt;/code&gt;. If there is no overlap, the subscription's results cannot possibly have changed (if you imagine the graph visually, there is no overlap between the part of the graph that changed and the part that is selected). In this case the subscription is ignored, otherwise processing continues.</source>
          <target state="translated">最初に、最後の &lt;code&gt;notify()&lt;/code&gt; 以降に変更されたデータIDのリストが、サブスクリプションの最新の &lt;code&gt;Snapshot&lt;/code&gt; リストされているデータIDと比較されます。重複がない場合、サブスクリプションの結果は変更されていない可能性があります（グラフを視覚的に想像すると、変更されたグラフの部分と選択された部分の間に重複はありません）。この場合、サブスクリプションは無視されます。それ以外の場合、処理は続行されます。</target>
        </trans-unit>
        <trans-unit id="a3aab624101e00feee75c13777205ffcca8d11b0" translate="yes" xml:space="preserve">
          <source>First, you need &lt;a href=&quot;https://facebook.github.io/watchman&quot;&gt;watchman&lt;/a&gt; installed:</source>
          <target state="translated">まず、&lt;a href=&quot;https://facebook.github.io/watchman&quot;&gt;watchmanを&lt;/a&gt;インストールする必要があります。</target>
        </trans-unit>
        <trans-unit id="0a54de1cc9f2aff2bed1cf76593938b1ded20fcf" translate="yes" xml:space="preserve">
          <source>Flat Routes</source>
          <target state="translated">フラットルート</target>
        </trans-unit>
        <trans-unit id="995180ea866af99054ca25768d4bd2ff5d5c8968" translate="yes" xml:space="preserve">
          <source>Flow Type Generation</source>
          <target state="translated">フロータイプ生成</target>
        </trans-unit>
        <trans-unit id="6d01829e4505f8d6171af1d3b3cae8dab5a6ee84" translate="yes" xml:space="preserve">
          <source>Following our &lt;code&gt;TodoList_list&lt;/code&gt; example, we would pass arguments to the fragment like so:</source>
          <target state="translated">&lt;code&gt;TodoList_list&lt;/code&gt; の例に従って、次のようにフラグメントに引数を渡します。</target>
        </trans-unit>
        <trans-unit id="c46edacfc204a583603ecb9b72b53c55f60dbc6a" translate="yes" xml:space="preserve">
          <source>For a complete example of how to load a &lt;code&gt;schema.js&lt;/code&gt; file, run the introspection query to get schema information, and save it to a JSON file, check out the &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit/blob/master/scripts/updateSchema.js&quot;&gt;starter kit&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;schema.js&lt;/code&gt; ファイルを読み込む方法の完全な例については、イントロスペクションクエリを実行してスキーマ情報を取得し、それをJSONファイルに保存して、&lt;a href=&quot;https://github.com/relayjs/relay-starter-kit/blob/master/scripts/updateSchema.js&quot;&gt;スターターキットを&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="cfe4ba012b2b664f6e8a52e5430ca8b838d37291" translate="yes" xml:space="preserve">
          <source>For a simple application that's already a nice improvement.</source>
          <target state="translated">シンプルなアプリにしては、すでにいい感じに改善されています。</target>
        </trans-unit>
        <trans-unit id="c72ede783eff4e07fb8b68b24df1f1f2ee6802eb" translate="yes" xml:space="preserve">
          <source>For connections like the above, &lt;code&gt;ConnectionHandler&lt;/code&gt; helps us find the record:</source>
          <target state="translated">上記のような接続の場合、 &lt;code&gt;ConnectionHandler&lt;/code&gt; はレコードを見つけるのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="889156520813e19bcd7a5e0e8e569875e2029955" translate="yes" xml:space="preserve">
          <source>For details on how to interact with the Relay Store, please refer to our Relay Store &lt;a href=&quot;relay-store&quot;&gt;docs&lt;/a&gt;.</source>
          <target state="translated">リレーストアとのやり取りの方法の詳細については、リレーストアの&lt;a href=&quot;relay-store&quot;&gt;ドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="96c534ed5280cce92d6b2b0550da3496f193200e" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;rangeBehaviors&lt;/code&gt; could be written this way:</source>
          <target state="translated">たとえば、 &lt;code&gt;rangeBehaviors&lt;/code&gt; は次のように記述できます。</target>
        </trans-unit>
        <trans-unit id="4999f2258aff41aa7c828698a3d72fe291b86eb2" translate="yes" xml:space="preserve">
          <source>For example, a network layer can be a simple object that conforms to the interface:</source>
          <target state="translated">例えば、ネットワーク層は、インターフェースに準拠した単純なオブジェクトであってもよい。</target>
        </trans-unit>
        <trans-unit id="2aa5827894bb94d499f20a1d29faefe22d07cad1" translate="yes" xml:space="preserve">
          <source>For example, a user and their address might be represented as follows:</source>
          <target state="translated">例えば、ユーザとそのアドレスは次のように表されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="5650972e3a1efbfc7e79658033f2f192552c13cb" translate="yes" xml:space="preserve">
          <source>For example, assuming the server schema &lt;code&gt;./schema.graphql&lt;/code&gt;:</source>
          <target state="translated">たとえば、サーバースキーマ &lt;code&gt;./schema.graphql&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8ffcdf17f2ad817cd3da93a900284bc63c193056" translate="yes" xml:space="preserve">
          <source>For example, given the two files:</source>
          <target state="translated">例えば、2つのファイルがあるとします。</target>
        </trans-unit>
        <trans-unit id="12bad1fdad02e0f5d5569bcccc232e7c8357d9c5" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;currentDate&lt;/code&gt; is set in &lt;code&gt;QueryRenderer&lt;/code&gt;&lt;code&gt;variables&lt;/code&gt;, then $currentDate may be referenced in any fragment included in the &lt;code&gt;QueryRenderer&lt;/code&gt;&lt;code&gt;query&lt;/code&gt;.</source>
          <target state="translated">たとえば、 &lt;code&gt;currentDate&lt;/code&gt; が &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;code&gt;variables&lt;/code&gt; で設定されている場合、$ currentDateは &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;code&gt;query&lt;/code&gt; 含まれている任意のフラグメントで参照できます。</target>
        </trans-unit>
        <trans-unit id="384dd94e051eb1541d94fe85b1aa65cfc4b8720e" translate="yes" xml:space="preserve">
          <source>For example, let's redefine our &lt;code&gt;TodoList_list&lt;/code&gt; fragment to take some arguments using &lt;code&gt;@argumentDefinitions&lt;/code&gt;:</source>
          <target state="translated">例えば、当社の再定義しましょう &lt;code&gt;TodoList_list&lt;/code&gt; のフラグメントが使用していくつかの引数を取るように &lt;code&gt;@argumentDefinitions&lt;/code&gt; を：</target>
        </trans-unit>
        <trans-unit id="1178c99ccfd9629da7c347f69a733ccb2674242f" translate="yes" xml:space="preserve">
          <source>For examples of more complex optimistic updates, including adding and removing from a list, see the &lt;a href=&quot;https://github.com/relayjs/relay-examples/tree/master/todo&quot;&gt;Relay Modern Todo example app&lt;/a&gt;.</source>
          <target state="translated">リストへの追加やリストからの削除など、より複雑な楽観的な更新の例については、&lt;a href=&quot;https://github.com/relayjs/relay-examples/tree/master/todo&quot;&gt;Relay Modern Todoサンプルアプリを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="a82abfdd90416cbeaffe64d3e50d78377188efce" translate="yes" xml:space="preserve">
          <source>For more complex use-cases, you may wish to perform custom logic to update Relay's in-memory cache when each subscription response is received. To do so, pass an &lt;code&gt;updater&lt;/code&gt; function:</source>
          <target state="translated">より複雑なユースケースでは、カスタムロジックを実行して、各サブスクリプション応答を受信したときにRelayのメモリ内キャッシュを更新することができます。これを行うには、 &lt;code&gt;updater&lt;/code&gt; 関数を渡します。</target>
        </trans-unit>
        <trans-unit id="2ac9b5543bc0f49df0cfb3a851760d47fc555d44" translate="yes" xml:space="preserve">
          <source>For more complicated mutations, &lt;code&gt;optimisticUpdater&lt;/code&gt; and &lt;code&gt;updater&lt;/code&gt; can be the same function.</source>
          <target state="translated">より複雑なミュー &lt;code&gt;updater&lt;/code&gt; 場合、 &lt;code&gt;optimisticUpdater&lt;/code&gt; とupdaterを同じ関数にすることができます。</target>
        </trans-unit>
        <trans-unit id="1137480158b92303f1522341248742d418f8a480" translate="yes" xml:space="preserve">
          <source>For more details on creating a Network, see the &lt;a href=&quot;network-layer&quot;&gt;NetworkLayer guide&lt;/a&gt;.</source>
          <target state="translated">ネットワーク作成の詳細については、&lt;a href=&quot;network-layer&quot;&gt;NetworkLayerガイドを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="6a8624a85744c6bfa958d4ffba2ebcba068cf3d0" translate="yes" xml:space="preserve">
          <source>For more details, refer to the &lt;a href=&quot;local-state-management&quot;&gt;Local state management section&lt;/a&gt;.</source>
          <target state="translated">詳細については、&lt;a href=&quot;local-state-management&quot;&gt;ローカル状態管理のセクションを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f1d4a5435c3cb6cdfd5a8c58ab671072ab888ff3" translate="yes" xml:space="preserve">
          <source>For more details, refer to the &lt;a href=&quot;persisted-queries&quot;&gt;Persisted Queries section&lt;/a&gt;.</source>
          <target state="translated">詳細については、「&lt;a href=&quot;persisted-queries&quot;&gt;永続クエリ」セクションを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="cf88bc6b3b6a4c187092ec351a5b1077c1d26272" translate="yes" xml:space="preserve">
          <source>For new Relay apps or existing apps that have been fully converted to the Compat API, the Relay Modern runtime can be enabled to activate even more features. In addition to those described above, this includes:</source>
          <target state="translated">新規のRelayアプリやCompat APIに完全に変換された既存のアプリでは、Relay Modernランタイムを有効にすることで、さらに多くの機能を有効にすることができます。これには、上記で説明したものに加えて、以下のようなものが含まれます。</target>
        </trans-unit>
        <trans-unit id="d800dc29a67ae0f7e1c89e3fa88acf537112a2a4" translate="yes" xml:space="preserve">
          <source>For users of classic Relay, note that the runtime makes as few assumptions as possible about GraphQL. Compared to earlier versions of Relay there is no concept of routes, there are no limitations on mutation input arguments or side-effects, arbitrary root fields just work, etc. At present, the main restriction from classic Relay that remains is the use of the &lt;code&gt;Node&lt;/code&gt; interface and &lt;code&gt;id&lt;/code&gt; field for object identification. However there is no fundamental reason that this restriction can't be relaxed (there is a single place in the codebase where object identity is determined), and we welcome feedback from the community about ways to support customizable object identity without negatively impacting performance.</source>
          <target state="translated">従来のRelayのユーザーの場合、ランタイムはGraphQLについて可能な限り少ない仮定を行うことに注意してください。以前のバージョンのRelayと比較すると、ルートの概念はなく、ミューテーション入力引数や副作用に制限はなく、任意のルートフィールドが機能するなどです。現在、残っている従来のRelayの主な制限は、オブジェクト識別用の &lt;code&gt;Node&lt;/code&gt; インターフェイスと &lt;code&gt;id&lt;/code&gt; フィールド。ただし、この制限を緩和できない根本的な理由はありません（コードベースには、オブジェクトIDが決定される場所が1つあります）。パフォーマンスに悪影響を与えることなく、カスタマイズ可能なオブジェクトIDをサポートする方法に関するコミュニティからのフィードバックを歓迎します。</target>
        </trans-unit>
        <trans-unit id="18fbf073a81951774f334f655935c2dac6e6377a" translate="yes" xml:space="preserve">
          <source>Force Fetching</source>
          <target state="translated">強制取得</target>
        </trans-unit>
        <trans-unit id="96bbe9b850cec5fbab27d61fde4b1fa63d06e24d" translate="yes" xml:space="preserve">
          <source>Force Fetching with Data from the Client</source>
          <target state="translated">クライアントからのデータを使って強制的にフェッチする</target>
        </trans-unit>
        <trans-unit id="bbba84135de6b052c2210e74e0cc5b2a9d359ddb" translate="yes" xml:space="preserve">
          <source>Found</source>
          <target state="translated">Found</target>
        </trans-unit>
        <trans-unit id="365b08de44008517ff803d0c36a644ac290dba44" translate="yes" xml:space="preserve">
          <source>Found offers integration with Relay Modern and Relay Classic via &lt;a href=&quot;https://github.com/4Catalyzer/found-relay&quot;&gt;Found Relay&lt;/a&gt;. Found Relay runs queries for matched routes in parallel, and supports fetching Relay data in parallel with downloading async bundles from code splitting when using Relay Modern.</source>
          <target state="translated">Foundは、&lt;a href=&quot;https://github.com/4Catalyzer/found-relay&quot;&gt;Found Relay&lt;/a&gt;を介してRelay ModernおよびRelay Classicとの統合を提供します。Found Relayは、一致するルートのクエリを並列で実行し、Relay Modernを使用する場合、コード分割から非同期バンドルをダウンロードすることと並行して、Relayデータをフェッチすることをサポートします。</target>
        </trans-unit>
        <trans-unit id="e58abca7c5abd6b02071e05687c03305e61f7adb" translate="yes" xml:space="preserve">
          <source>Fragment Composition</source>
          <target state="translated">フラグメントの構成</target>
        </trans-unit>
        <trans-unit id="44548256a4fe02219452b999f31774df4d7788f3" translate="yes" xml:space="preserve">
          <source>Fragment Container</source>
          <target state="translated">フラグメントコンテナ</target>
        </trans-unit>
        <trans-unit id="4c9b8ee7dc2184d0aab89be194eb15b57be40cef" translate="yes" xml:space="preserve">
          <source>Fragment composition is achieved via ES6 template string interpolation and &lt;code&gt;getFragment&lt;/code&gt;:</source>
          <target state="translated">フラグメントの構成は、ES6テンプレートの文字列補間と &lt;code&gt;getFragment&lt;/code&gt; によって実現されます。</target>
        </trans-unit>
        <trans-unit id="99eb0c4810611d5c803d75a7ca10220fd2d2cfea" translate="yes" xml:space="preserve">
          <source>Fragment composition works similarly &amp;mdash; a parent container's fragment composes the fragment for each of its children. In this case, &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; needs to fetch information about the &lt;code&gt;User&lt;/code&gt; that is required by &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">フラグメント構成は同様に機能します&amp;mdash;親コンテナのフラグメントは、それぞれの子のフラグメントを構成します。この場合、 &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; は、 &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; で必要な &lt;code&gt;User&lt;/code&gt; に関する情報をフェッチする必要があります。</target>
        </trans-unit>
        <trans-unit id="c2f68d40663d52153573dd0abe042e691b281b53" translate="yes" xml:space="preserve">
          <source>Fragment composition works similarly &amp;mdash; a parent container's fragment composes the fragment for each of its children. In this case, &lt;code&gt;&amp;lt;TodoList /&amp;gt;&lt;/code&gt; needs to fetch information about the &lt;code&gt;Todo&lt;/code&gt;s that are required by &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">フラグメントの構成も同様に機能します。親コンテナのフラグメントは、その子ごとにフラグメントを構成します。この場合、 &lt;code&gt;&amp;lt;TodoList /&amp;gt;&lt;/code&gt; に関する情報の取得に必要 &lt;code&gt;Todo&lt;/code&gt; によって必要とされるS &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="f4c1ec38ec0f0411751ca1a7fa59d2e3f75e878a" translate="yes" xml:space="preserve">
          <source>Fragment composition works similarly &amp;mdash; a parent container's fragment composes the fragment for each of its children. In this case, &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; needs to fetch information about the &lt;code&gt;Todo&lt;/code&gt;s that are required by &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">フラグメント構成は同様に機能します&amp;mdash;親コンテナのフラグメントは、それぞれの子のフラグメントを構成します。この場合、 &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; についての情報を取得する必要がある &lt;code&gt;Todo&lt;/code&gt; によって必要とされるS &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a7eb65ef2204b222cba330bf9518e103ffff4a9" translate="yes" xml:space="preserve">
          <source>Fragment variables</source>
          <target state="translated">フラグメント変数</target>
        </trans-unit>
        <trans-unit id="6c4797fcf380c1ad929a06c044c27ce633b8a89b" translate="yes" xml:space="preserve">
          <source>FragmentContainer</source>
          <target state="translated">FragmentContainer</target>
        </trans-unit>
        <trans-unit id="e8e4adae3ec551af9e8edf80d04fd880f87f33b9" translate="yes" xml:space="preserve">
          <source>Fragments can be composed in one of two ways:</source>
          <target state="translated">フラグメントは2つの方法のいずれかで構成することができます。</target>
        </trans-unit>
        <trans-unit id="1ec5c60b97bf9a572f6951db4d37f812151af82e" translate="yes" xml:space="preserve">
          <source>Fragments can be embedded within other fragments or queries. For example, the above fragment could be used to fetch user &lt;code&gt;123&lt;/code&gt;'s profile photo:</source>
          <target state="translated">フラグメントは、他のフラグメントまたはクエリ内に埋め込むことができます。たとえば、上記のフラグメントは、ユーザー &lt;code&gt;123&lt;/code&gt; のプロフィール写真を取得するために使用できます。</target>
        </trans-unit>
        <trans-unit id="5749ddc88402f36f29ad8ff8b7fc5a5626b02527" translate="yes" xml:space="preserve">
          <source>Fragments may also compose other fragments that are assigned to local variables:</source>
          <target state="translated">フラグメントは、ローカル変数に代入された他のフラグメントを構成してもよい。</target>
        </trans-unit>
        <trans-unit id="5b32b8542e4c8854b05455c0b114c2bdced713ad" translate="yes" xml:space="preserve">
          <source>Garbage Collection</source>
          <target state="translated">ゴミの収集</target>
        </trans-unit>
        <trans-unit id="202728ddee5584ce607f4aab869a3630ba743b82" translate="yes" xml:space="preserve">
          <source>Garbage collection to evict entries from the cache when they can no longer be referenced by any view.</source>
          <target state="translated">どのビューからも参照できなくなったときに、キャッシュからエントリを退避させるためのガベージコレクション。</target>
        </trans-unit>
        <trans-unit id="13e8bde6a75cc8bafc18233096a72b0f6248985e" translate="yes" xml:space="preserve">
          <source>General-purpose tools for building a GraphQL schema using JavaScript</source>
          <target state="translated">JavaScriptを使ったGraphQLスキーマ構築のための汎用ツール</target>
        </trans-unit>
        <trans-unit id="2b67d1eb9affe329c622f0576365f0ee268cf097" translate="yes" xml:space="preserve">
          <source>Gets a fragment reference for use in a parent's query fragment.</source>
          <target state="translated">親のクエリフラグメントで使用するためのフラグメント参照を取得します。</target>
        </trans-unit>
        <trans-unit id="efadaa65e42a5128618d6d70d6e5f16a32ea9213" translate="yes" xml:space="preserve">
          <source>Gets a reference to a child container's fragment for inclusion in a parent fragment.</source>
          <target state="translated">親フラグメントに含めるための子コンテナのフラグメントへの参照を取得します。</target>
        </trans-unit>
        <trans-unit id="bab08a8b8e5697e21edf5ba8471a6d2976e052d5" translate="yes" xml:space="preserve">
          <source>Gets a string name used to refer to this request for printing debug output.</source>
          <target state="translated">デバッグ出力を印刷するためのこのリクエストを参照するための文字列名を取得します。</target>
        </trans-unit>
        <trans-unit id="c66f9fff87afddb71ece32a2129c20b745b3303d" translate="yes" xml:space="preserve">
          <source>Gets a string representation of the GraphQL mutation.</source>
          <target state="translated">GraphQL の突然変異の文字列表現を取得します。</target>
        </trans-unit>
        <trans-unit id="f2fb6164e4d92fdf7bb9de20c1488df58f14ec49" translate="yes" xml:space="preserve">
          <source>Gets a string representation of the GraphQL query.</source>
          <target state="translated">GraphQL クエリの文字列表現を取得します。</target>
        </trans-unit>
        <trans-unit id="abe1bcf50d4649b6cc620e50d25b565688c7d9a1" translate="yes" xml:space="preserve">
          <source>Gets a unique identifier for this mutation. These identifiers are useful for assigning response payloads to their corresponding mutations when sent in a single GraphQL request.</source>
          <target state="translated">このミューテーションの一意の識別子を取得します。これらの識別子は、単一の GraphQL リクエストで送信されたときに、対応する変異に応答ペイロードを割り当てるのに便利です。</target>
        </trans-unit>
        <trans-unit id="96e072f6fa8b2d20b9da83302dbda948494674bf" translate="yes" xml:space="preserve">
          <source>Gets a unique identifier for this query. These identifiers are useful for assigning response payloads to their corresponding queries when sent in a single GraphQL request.</source>
          <target state="translated">このクエリの一意の識別子を取得します。これらの識別子は、単一の GraphQL リクエストで送信された場合に、対応するクエリにレスポンスペイロードを割り当てるのに便利です。</target>
        </trans-unit>
        <trans-unit id="5406c8eaf62c01411092558cd572b43c5b89bfa6" translate="yes" xml:space="preserve">
          <source>Gets an optional map from name to File objects.</source>
          <target state="translated">name から File オブジェクトへのオプションのマップを取得します。</target>
        </trans-unit>
        <trans-unit id="1daf2e35612607247d326239b96ef7bd4c0deb13" translate="yes" xml:space="preserve">
          <source>Gets the type of the current record, as defined by the GraphQL schema.</source>
          <target state="translated">GraphQL スキーマで定義されている現在のレコードの型を取得します。</target>
        </trans-unit>
        <trans-unit id="0ee3ecb0267703f60ff46d5ccfae9291bc39b826" translate="yes" xml:space="preserve">
          <source>Gets the value of a field in the current record given the field name.</source>
          <target state="translated">フィールド名が指定された現在のレコードのフィールドの値を取得します。</target>
        </trans-unit>
        <trans-unit id="118b9b0bfba623072bfed30c4a7c6d4b769ead2a" translate="yes" xml:space="preserve">
          <source>Gets the variables used by the mutation. These variables should be serialized and send in the GraphQL request.</source>
          <target state="translated">突然変異で使用される変数を取得します。これらの変数はシリアライズされ、GraphQLリクエストで送信されなければなりません。</target>
        </trans-unit>
        <trans-unit id="5f68839c1e374f581aaccfdd2584db85f5d5531a" translate="yes" xml:space="preserve">
          <source>Gets the variables used by the query. These variables should be serialized and sent in the GraphQL request.</source>
          <target state="translated">クエリで使用される変数を取得します。これらの変数はシリアライズされ、GraphQLリクエストで送信されなければなりません。</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">はじめに</target>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="translated">始めるには</target>
        </trans-unit>
        <trans-unit id="c50a651b10d01a7deafc80b4e09d60a50246f2f1" translate="yes" xml:space="preserve">
          <source>Given a &lt;code&gt;deletedIDFieldName&lt;/code&gt;, Relay will remove the node(s) from the store.</source>
          <target state="translated">所与 &lt;code&gt;deletedIDFieldName&lt;/code&gt; 、リレーストアからノードを削除します。</target>
        </trans-unit>
        <trans-unit id="d609f05a6d3bf2ce92708edc4808c22e3566e07f" translate="yes" xml:space="preserve">
          <source>Given a connection, deletes any edges whose id matches the given id.</source>
          <target state="translated">接続が与えられた場合、id が指定された id と一致するエッジを削除します。</target>
        </trans-unit>
        <trans-unit id="d379af210d311a7a256db3fa6fe039dcbf2cbd54" translate="yes" xml:space="preserve">
          <source>Given a connection, inserts the edge at the beginning of the connection, or before the specified &lt;code&gt;cursor&lt;/code&gt;.</source>
          <target state="translated">接続を指定すると、接続の先頭、または指定した &lt;code&gt;cursor&lt;/code&gt; 前にエッジを挿入します。</target>
        </trans-unit>
        <trans-unit id="4bffc05ebf924c05ffda3d323c9605a38ad10f80" translate="yes" xml:space="preserve">
          <source>Given a connection, inserts the edge at the end of the connection, or after the specified &lt;code&gt;cursor&lt;/code&gt;.</source>
          <target state="translated">接続を指定すると、接続の最後、または指定した &lt;code&gt;cursor&lt;/code&gt; 後にエッジを挿入します。</target>
        </trans-unit>
        <trans-unit id="8b19260759d77673b9a877795f157d4044253944" translate="yes" xml:space="preserve">
          <source>Given a connection, one or more DataIDs in the response payload, and a path between the parent and the connection, Relay will remove the node(s) from the connection but leave the associated record(s) in the store.</source>
          <target state="translated">接続、レスポンス・ペイロードに含まれる1つ以上のDataID、および親と接続の間のパスが与えられると、Relayは接続からノードを削除しますが、関連するレコードはストアに残します。</target>
        </trans-unit>
        <trans-unit id="e48271c6488ce169319e6996a17416ab8db56489" translate="yes" xml:space="preserve">
          <source>Given a deletedIDFieldName, Relay will remove the node(s) from the connection.</source>
          <target state="translated">deletedIDFieldNameを指定すると、Relayは接続からノードを削除します。</target>
        </trans-unit>
        <trans-unit id="720b1124168e2fcea493421f01efb6519477f619" translate="yes" xml:space="preserve">
          <source>Given a parent, &lt;code&gt;connectionKeys&lt;/code&gt;, one or more DataIDs in the response payload, and a path between the parent and the connection, Relay will remove the node(s) from the connection but leave the associated record(s) in the store.</source>
          <target state="translated">親、 &lt;code&gt;connectionKeys&lt;/code&gt; 、応答ペイロード内の1つ以上のDataID、および親と接続の間のパスが与えられると、Relayは接続からノードを削除しますが、関連するレコードはストアに残します。</target>
        </trans-unit>
        <trans-unit id="47de81551f168ce6aed9196d0adf126b977177b6" translate="yes" xml:space="preserve">
          <source>Given a parent, a connection, and one or more DataIDs in the response payload, Relay will remove the node(s) from the connection and delete the associated record(s) from the store.</source>
          <target state="translated">親、接続、およびレスポンス・ペイロードに含まれる1つ以上のDataIDを指定すると、Relayは接続からノードを削除し、ストアから関連するレコードを削除します。</target>
        </trans-unit>
        <trans-unit id="a51dc0bfb8bd3ee42a7194ed76f6218686158817" translate="yes" xml:space="preserve">
          <source>Given a parent, a connection, and the name of the newly created edge in the response payload Relay will add the node to the store and attach it to the connection according to the range behavior specified.</source>
          <target state="translated">親、接続、およびレスポンス・ペイロードに新しく作成されたエッジの名前が指定されると、Relayは指定された範囲の動作に従ってノードをストアに追加し、接続にアタッチします。</target>
        </trans-unit>
        <trans-unit id="524a22d3cb952e409df0e138141726ed755fe115" translate="yes" xml:space="preserve">
          <source>Given a parent, connectionKeys, one or more DataIDs in the response payload, and a path between the parent and the connection, Relay will remove the node(s) from the connection but leave the associated record(s) in the store.</source>
          <target state="translated">親、connectionKeys、レスポンス・ペイロードに含まれる1つ以上のDataID、および親と接続の間のパスが与えられると、Relayは接続からノードを削除しますが、関連するレコードはストアに残します。</target>
        </trans-unit>
        <trans-unit id="6c8602a6c8072fdb24f4522613cbc2f7cfcca2ed" translate="yes" xml:space="preserve">
          <source>Given a parent, information about the connection, and the name of the newly created edge in the response payload Relay will add the node to the store and attach it to the connection according to the range behavior(s) specified in the connectionInfo.</source>
          <target state="translated">親、接続に関する情報、およびレスポンス・ペイロードで新しく作成されたエッジの名前が与えられると、Relayはノードをストアに追加し、connectionInfoで指定された範囲の動作に従って接続にアタッチします。</target>
        </trans-unit>
        <trans-unit id="a9b1b0a91341253151fdb0d5e41db14af5ba2ef3" translate="yes" xml:space="preserve">
          <source>Given a record and a connection key, and optionally a set of filters, &lt;code&gt;getConnection&lt;/code&gt; retrieves a &lt;a href=&quot;#recordproxy&quot;&gt;&lt;code&gt;RecordProxy&lt;/code&gt;&lt;/a&gt; that represents a connection that was annotated with a &lt;code&gt;@connection&lt;/code&gt; directive.</source>
          <target state="translated">レコードと接続キー、およびオプションでフィルターのセットを指定すると、 &lt;code&gt;getConnection&lt;/code&gt; は、&lt;a href=&quot;#recordproxy&quot;&gt; &lt;code&gt;RecordProxy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;@connection&lt;/code&gt; ディレクティブでアノテーションが付けられた接続を表すRecordProxyを取得します。</target>
        </trans-unit>
        <trans-unit id="5933a7dc46c436f13a884a4a3f5f844894c6ee04" translate="yes" xml:space="preserve">
          <source>Given the GraphQL document:</source>
          <target state="translated">GraphQL ドキュメントが与えられています。</target>
        </trans-unit>
        <trans-unit id="1d0fa81ee1013085b7d63ff166408f30527ff41a" translate="yes" xml:space="preserve">
          <source>Given the plain React component and a GraphQL fragment, we can now define a &lt;code&gt;Container&lt;/code&gt; to tell Relay about this component's data requirements. Let's look at the code first and then see what's happening:</source>
          <target state="translated">プレーンなReactコンポーネントとGraphQLフラグメントが与えられたら、このコンポーネントのデータ要件をリレーに伝える &lt;code&gt;Container&lt;/code&gt; を定義できます。まずコードを見てから、何が起こっているのかを見てみましょう：</target>
        </trans-unit>
        <trans-unit id="78d8c89827c5602fc6d1d40331d005ddbc42de59" translate="yes" xml:space="preserve">
          <source>Given the plain React component and a GraphQL fragment, we can now define a Fragment Container to specify this component's data requirements. Let's look at the code first and then see what's happening:</source>
          <target state="translated">プレーンなReactコンポーネントとGraphQLフラグメントがあれば、このコンポーネントのデータ要件を指定するためにFragment Containerを定義することができます。まずはコードを見て、何が起こっているのかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="3e96a8e96d952292ce981325cfa1fcff52e52c7e" translate="yes" xml:space="preserve">
          <source>Given these real-world constraints, the approach in GraphQL is for clients to query for things that may change after a mutation. But what exactly do we put in that query? During the development of Relay we explored several ideas &amp;mdash; let's look at them briefly in order to understand why Relay uses the approach that it does:</source>
          <target state="translated">これらの実際の制約を前提として、GraphQLのアプローチは、クライアントが変更後に変更される可能性があるものをクエリすることです。しかし、そのクエリには正確に何を入れますか？Relayの開発中に、いくつかのアイデアを検討しました。Relayが行うアプローチを使用する理由を理解するために、それらを簡単に見てみましょう。</target>
        </trans-unit>
        <trans-unit id="5c41e44eb6db12a7dd58862cf6f3cc1584c314eb" translate="yes" xml:space="preserve">
          <source>Globally invalidates the Relay store. This will cause any data that was written to the store before invalidation occurred to be considered stale, and will be considered to require refetch the next time a query is checked with &lt;code&gt;environment.check()&lt;/code&gt;.</source>
          <target state="translated">リレーストアをグローバルに無効にします。これにより、無効化が発生する前にストアに書き込まれたデータはすべて失効していると見なされ、次に &lt;code&gt;environment.check()&lt;/code&gt; でクエリがチェックされたときに再フェッチが必要であると見なされます。</target>
        </trans-unit>
        <trans-unit id="e4eb1ab683c392399fa825b2dea3b7e5f8189912" translate="yes" xml:space="preserve">
          <source>GraphQL</source>
          <target state="translated">GraphQL</target>
        </trans-unit>
        <trans-unit id="d1104d2d1c77df98433b7b7cb498cfbba782bab4" translate="yes" xml:space="preserve">
          <source>GraphQL Relay Specification</source>
          <target state="translated">グラフQLリレー仕様</target>
        </trans-unit>
        <trans-unit id="2462160d86cfb1c5d092d0aa517b3b680333ccb3" translate="yes" xml:space="preserve">
          <source>GraphQL Schema</source>
          <target state="translated">グラフQLスキーム</target>
        </trans-unit>
        <trans-unit id="37f3b6a18cf42e1932e52d60a342d388f522602a" translate="yes" xml:space="preserve">
          <source>GraphQL Subscriptions &amp;amp; Live Queries</source>
          <target state="translated">GraphQLサブスクリプションとライブクエリ</target>
        </trans-unit>
        <trans-unit id="55705029d139bf2fb4343a8dd5d01c514bb24b08" translate="yes" xml:space="preserve">
          <source>GraphQL in Relay</source>
          <target state="translated">リレーのグラフQL</target>
        </trans-unit>
        <trans-unit id="6884fbda0403c3eb6a361b276df83698590e1779" translate="yes" xml:space="preserve">
          <source>GraphQL is designed to support a wide range of data access patterns. In order to understand the structure of an application's data, Relay requires that you follow certain conventions when defining your schema. These are documented in the &lt;a href=&quot;graphql-relay-specification&quot;&gt;GraphQL Relay Specification&lt;/a&gt;.</source>
          <target state="translated">GraphQLは、幅広いデータアクセスパターンをサポートするように設計されています。アプリケーションのデータの構造を理解するために、Relayでは、スキーマを定義するときに特定の規則に従う必要があります。これらは&lt;a href=&quot;graphql-relay-specification&quot;&gt;GraphQLリレー仕様に&lt;/a&gt;記載されています。</target>
        </trans-unit>
        <trans-unit id="55711b09c6616aea30b39a64a358b0d9490999c3" translate="yes" xml:space="preserve">
          <source>GraphQL presents new ways for clients to fetch data by focusing on the needs of product developers and client applications. It provides a way for developers to specify the precise data needed for a view and enables a client to fetch that data in a single network request. Compared to traditional approaches such as REST, GraphQL helps applications to fetch data more efficiently (compared to resource-oriented REST approaches) and avoid duplication of server logic (which can occur with custom endpoints). Furthermore, GraphQL helps developers to decouple product code and server logic. For example, a product can fetch more or less information without requiring a change to every relevant server endpoint. It's a great way to fetch data.</source>
          <target state="translated">GraphQLは、製品開発者とクライアントアプリケーションのニーズに焦点を当て、クライアントがデータを取得するための新しい方法を提供します。GraphQLは、開発者がビューに必要な正確なデータを指定する方法を提供し、クライアントが単一のネットワークリクエストでそのデータを取得することを可能にします。GraphQLは、RESTのような従来のアプローチと比較して、アプリケーションがより効率的にデータを取得し(リソース指向のRESTアプローチと比較して)、サーバーロジックの重複(カスタムエンドポイントで発生する可能性がある)を回避するのに役立ちます。さらに、開発者は GraphQL を使用することで、製品コードとサーバーロジックを分離することができます。たとえば、製品は、関連するサーバーのエンドポイントをすべて変更することなく、より多くの情報を取得したり、より少ない情報を取得したりすることができます。これは、データを取得するための素晴らしい方法です。</target>
        </trans-unit>
        <trans-unit id="cd5d1ec7247a2826222f29ae64e2e192abb30c33" translate="yes" xml:space="preserve">
          <source>GraphQL provides a powerful tool for building efficient, decoupled client applications. Relay builds on this functionality to provide a framework for &lt;strong&gt;declarative data-fetching&lt;/strong&gt;. By separating &lt;em&gt;what&lt;/em&gt; data to fetch from &lt;em&gt;how&lt;/em&gt; it is fetched, Relay helps developers build applications that are robust, transparent, and performant by default. It's a great complement to the component-centric way of thinking championed by React. While each of these technologies &amp;mdash; React, Relay, and GraphQL &amp;mdash; are powerful on their own, the combination is a &lt;strong&gt;UI platform&lt;/strong&gt; that allows us to &lt;em&gt;move fast&lt;/em&gt; and &lt;em&gt;ship high-quality apps at scale&lt;/em&gt;.</source>
          <target state="translated">GraphQLは、効率的で分離されたクライアントアプリケーションを構築するための強力なツールを提供します。 Relayはこの機能に基づいて構築されており、&lt;strong&gt;宣言的なデータフェッチの&lt;/strong&gt;フレームワークを提供します。取得&lt;em&gt;する&lt;/em&gt;データと取得&lt;em&gt;方法&lt;/em&gt;を分離&lt;em&gt;する&lt;/em&gt;ことで、Relayは開発者がデフォルトで堅牢で透過的でパフォーマンスの高いアプリケーションを構築できるようにします。これは、Reactが推進するコンポーネント中心の考え方を補完するものです。これらの各テクノロジー（React、Relay、GraphQL）はそれ自体が強力ですが、この組み合わせは&lt;strong&gt;UIプラットフォーム&lt;/strong&gt;であり、&lt;em&gt;高速&lt;/em&gt;で&lt;em&gt;移動して&lt;/em&gt;&lt;em&gt;高品質のアプリを大規模に出荷&lt;/em&gt;できます。</target>
        </trans-unit>
        <trans-unit id="fe79f455fe739b1f1e04461fc0dc38be9fbb5f79" translate="yes" xml:space="preserve">
          <source>GraphQL text is extracted from source files and &quot;parsed&quot; into an intermediate representation (IR) using information from the schema.</source>
          <target state="translated">GraphQLのテキストはソースファイルから抽出され、スキーマからの情報を使用して中間表現(IR)に「解析」されます。</target>
        </trans-unit>
        <trans-unit id="e541828d19d4a8e98d359b78f14f53ce50019b3d" translate="yes" xml:space="preserve">
          <source>Here are a few examples of some of the included transforms:</source>
          <target state="translated">ここでは、含まれている変換のいくつかの例を紹介します。</target>
        </trans-unit>
        <trans-unit id="4de18940b97877b6ff77ae9e81b1c868cf154cdc" translate="yes" xml:space="preserve">
          <source>Here are a quick example of adding a todo item to a Todo list using this &lt;a href=&quot;https://github.com/relayjs/relay-examples/blob/master/todo/data/schema.graphql#L36&quot;&gt;example schema&lt;/a&gt;:</source>
          <target state="translated">この&lt;a href=&quot;https://github.com/relayjs/relay-examples/blob/master/todo/data/schema.graphql#L36&quot;&gt;スキーマ例&lt;/a&gt;を使用して、TodoリストにTodoアイテムを追加する簡単な例を次に示します。</target>
        </trans-unit>
        <trans-unit id="1745637b6e7ac2208886e0fe73413f315dc1d52e" translate="yes" xml:space="preserve">
          <source>Here's a basic implementation of &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; that ignores styling in order to highlight the functionality:</source>
          <target state="translated">次に、機能を強調するためにスタイリングを無視する &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; の基本的な実装を示します。</target>
        </trans-unit>
        <trans-unit id="622275495084316cce6011efe3c5533f0b505dd1" translate="yes" xml:space="preserve">
          <source>Here's a basic implementation of &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt; that ignores styling in order to highlight the functionality:</source>
          <target state="translated">機能を強調するためにスタイリングを無視する &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt; の基本的な実装は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="c7acba2d971e69e956adf8a6ecc2371b0bf96df3" translate="yes" xml:space="preserve">
          <source>Here's a basic implementation of &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; that ignores styling in order to highlight the functionality:</source>
          <target state="translated">以下は、機能を強調するためにスタイル設定を無視する &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; の基本的な実装です。</target>
        </trans-unit>
        <trans-unit id="dbbbbf44b31cd11738f96ef61375f12e9722988b" translate="yes" xml:space="preserve">
          <source>Here's an example of this mutation in use by a &lt;code&gt;LikeButton&lt;/code&gt; component:</source>
          <target state="translated">&lt;code&gt;LikeButton&lt;/code&gt; コンポーネントで使用されているこのミューテーションの例を次に示します。</target>
        </trans-unit>
        <trans-unit id="385d7c0cfbb336e0125f7ea51dde1cd3078887da" translate="yes" xml:space="preserve">
          <source>Here's an example query that fetches a story's text and its author's name:</source>
          <target state="translated">以下は、ストーリーのテキストと著者名を取得するクエリの例です。</target>
        </trans-unit>
        <trans-unit id="0694e515f41dabfcc348f2df0677999ef99af1ea" translate="yes" xml:space="preserve">
          <source>Here's what happens when the container is rendered:</source>
          <target state="translated">コンテナがレンダリングされるとどうなるかを説明します。</target>
        </trans-unit>
        <trans-unit id="2284d040f5091f510de37a154536196310f9c02d" translate="yes" xml:space="preserve">
          <source>Hint</source>
          <target state="translated">Hint</target>
        </trans-unit>
        <trans-unit id="05531ed7907681dd3a6ac4e94e82348c1af49264" translate="yes" xml:space="preserve">
          <source>Historically, Relay started out internally at Facebook as a routing framework. However, Relay no longer makes any assumptions about routing, and works with a variety of routing options.</source>
          <target state="translated">歴史的に、RelayはFacebookの社内でルーティングフレームワークとしてスタートしました。しかし、Relayはもはやルーティングを前提としたものではなく、さまざまなルーティングオプションを使って動作します。</target>
        </trans-unit>
        <trans-unit id="f96c9aa85d59b7983b33495b149e7fee5f7bf418" translate="yes" xml:space="preserve">
          <source>Hm. There were no more ships; guess there were only five in the system for the rebels. It would have been nice to know that we'd reached the end of the connection, without having to do another round trip in order to verify that. The connection model exposes this capability with a type called &lt;code&gt;PageInfo&lt;/code&gt;. So let's issue the two queries that got us ships again, but this time ask for &lt;code&gt;hasNextPage&lt;/code&gt;:</source>
          <target state="translated">うーん。船はもうありませんでした。反乱軍のシステムには5人しかいなかったと思います。それを確認するために別のラウンドトリップを実行する必要なしに、接続の最後に到達したことを知っていれば、良かったでしょう。接続モデルは、この機能を &lt;code&gt;PageInfo&lt;/code&gt; というタイプで公開します。それでは、再度出荷した2つのクエリを発行してみましょう。ただし、今回は &lt;code&gt;hasNextPage&lt;/code&gt; を要求します。</target>
        </trans-unit>
        <trans-unit id="c2d977e2354e1f199b20eba8fe4202828b60baf5" translate="yes" xml:space="preserve">
          <source>However components using the Relay Modern API (&lt;code&gt;'react-relay'&lt;/code&gt;) and the Relay Classic API (&lt;code&gt;'react-relay/classic'&lt;/code&gt;) cannot be used with each other.</source>
          <target state="translated">ただし、Relay Modern API（ &lt;code&gt;'react-relay'&lt;/code&gt; ）とRelay Classic API（ &lt;code&gt;'react-relay/classic'&lt;/code&gt; ）を使用するコンポーネントは、相互に使用できません。</target>
        </trans-unit>
        <trans-unit id="502eeb0d2871522e994df777d19577771dfe2094" translate="yes" xml:space="preserve">
          <source>However the Relay Compiler also automatically generates &lt;a href=&quot;https://flow.org&quot;&gt;Flow&lt;/a&gt; types as &lt;a href=&quot;https://flow.org/en/docs/types/comments/&quot;&gt;type comments&lt;/a&gt;. For example, you can import the generated Flow types like so:</source>
          <target state="translated">ただし、リレーコンパイラは、&lt;a href=&quot;https://flow.org&quot;&gt;フロー&lt;/a&gt;タイプを&lt;a href=&quot;https://flow.org/en/docs/types/comments/&quot;&gt;タイプコメント&lt;/a&gt;として自動的に生成します。たとえば、次のように生成されたフロータイプをインポートできます。</target>
        </trans-unit>
        <trans-unit id="8f6bd5564a2d8d3eed39f5285b27795de9e86379" translate="yes" xml:space="preserve">
          <source>However the Relay Compiler also automatically generates flow types, as &lt;a href=&quot;https://flow.org/en/docs/types/comments/&quot;&gt;type comments&lt;/a&gt;. To import the types:</source>
          <target state="translated">ただし、Relay Compilerは、&lt;a href=&quot;https://flow.org/en/docs/types/comments/&quot;&gt;タイプコメント&lt;/a&gt;としてフロータイプも自動的に生成します。タイプをインポートするには：</target>
        </trans-unit>
        <trans-unit id="10b177310affbe7aa4dd35d3f040c504f1597c28" translate="yes" xml:space="preserve">
          <source>However, Relay Modern expects modern JavaScript global types (&lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Promise&lt;/code&gt;, &lt;code&gt;Object.assign&lt;/code&gt;) to be defined. If you support older browsers and devices which may not yet provide these natively, consider including a global polyfill in your bundled application, such as &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/docs/usage/polyfill/&quot;&gt;babel-polyfill&lt;/a&gt;.</source>
          <target state="translated">ただし、Relay Modernは、最新のJavaScriptグローバルタイプ（ &lt;code&gt;Map&lt;/code&gt; 、 &lt;code&gt;Set&lt;/code&gt; 、 &lt;code&gt;Promise&lt;/code&gt; 、 &lt;code&gt;Object.assign&lt;/code&gt; ）が定義されることを期待しています。これらをネイティブで提供していない可能性のある古いブラウザーやデバイスをサポートしている場合は、&lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt;や&lt;a href=&quot;https://babeljs.io/docs/usage/polyfill/&quot;&gt;babel-polyfill&lt;/a&gt;などのバンドルアプリケーションにグローバルポリフィルを含めることを検討してください。</target>
        </trans-unit>
        <trans-unit id="e508d49142051371922e56dda4689dd05e8567d5" translate="yes" xml:space="preserve">
          <source>However, a &lt;code&gt;QueryRenderer&lt;/code&gt; will not start loading its data until it is mounted, so nested &lt;code&gt;QueryRenderer&lt;/code&gt; components can lead to request waterfalls if used unnecessarily.</source>
          <target state="translated">ただし、 &lt;code&gt;QueryRenderer&lt;/code&gt; はマウントされるまでデータのロードを開始しないため、ネストされた &lt;code&gt;QueryRenderer&lt;/code&gt; コンポーネントは、不必要に使用された場合にウォーターフォールを要求する可能性があります。</target>
        </trans-unit>
        <trans-unit id="44a07f8e11c88d99ebfa0ba8926d9d2bf8daec90" translate="yes" xml:space="preserve">
          <source>However, the fragment could also fetch each of user &lt;code&gt;123&lt;/code&gt;'s friends' profile photos:</source>
          <target state="translated">ただし、このフラグメントは、ユーザー &lt;code&gt;123&lt;/code&gt; の友達のプロフィール写真をそれぞれフェッチすることもできます。</target>
        </trans-unit>
        <trans-unit id="a72518acd301cccb79e4d618aa2b5df43d443663" translate="yes" xml:space="preserve">
          <source>However, when &lt;a href=&quot;#createpaginationcontainer&quot;&gt;specifying connection fragments&lt;/a&gt; for a Pagination Container, it is expected that at least one of the fragments contains a &lt;a href=&quot;https://relay.dev/graphql/connections.htm&quot;&gt;GraphQL connection&lt;/a&gt; to paginate over, and that the connection field is annotated with a &lt;code&gt;@connection&lt;/code&gt; directive.</source>
          <target state="translated">ただし、ページネーションコンテナーの&lt;a href=&quot;#createpaginationcontainer&quot;&gt;接続フラグメント&lt;/a&gt;を指定する場合、フラグメントの少なくとも1つにページネーションを行うための&lt;a href=&quot;https://relay.dev/graphql/connections.htm&quot;&gt;GraphQL接続&lt;/a&gt;が含まれ、接続フィールドに &lt;code&gt;@connection&lt;/code&gt; ディレクティブの注釈が付けられていることが期待されます。</target>
        </trans-unit>
        <trans-unit id="bd69a4732fe12702d5ff5838852eb29e4a9e2e02" translate="yes" xml:space="preserve">
          <source>Idea</source>
          <target state="translated">Idea</target>
        </trans-unit>
        <trans-unit id="0daab153956ffb0745c3d2cf4823ed87bf8cdc9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;optimisticResponse&lt;/code&gt; is provided, Relay will use it to update the fields under the records as specified by the ids in the &lt;code&gt;optimisticResponse&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;optimisticResponse&lt;/code&gt; が提供されている場合、Relayはそれを使用して、 &lt;code&gt;optimisticResponse&lt;/code&gt; のIDで指定されているレコードの下のフィールドを更新します。</target>
        </trans-unit>
        <trans-unit id="1e63eef54ae07ad9832be86ae57e57b86e1543dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;optimisticUpdater&lt;/code&gt; is provided, Relay will execute it and update the store accordingly.</source>
          <target state="translated">&lt;code&gt;optimisticUpdater&lt;/code&gt; が提供されている場合、Relayはそれを実行し、それに応じてストアを更新します。</target>
        </trans-unit>
        <trans-unit id="3bd280c6059870c93a4668954d90f25f6c6ff4e2" translate="yes" xml:space="preserve">
          <source>If a &quot;force fetch&quot; occurs and there is insufficient data on the client, the same behavior as &lt;strong&gt;Fetching Data from the Server&lt;/strong&gt; can be expected. However, if a &quot;force fetch&quot; occurs and there &lt;em&gt;is&lt;/em&gt; sufficient data on the client to render, we can expect the following behavior:</source>
          <target state="translated">「強制フェッチ」が発生し、クライアントに十分なデータがない場合&lt;strong&gt;、サーバーからのデータのフェッチ&lt;/strong&gt;と同じ動作が期待できます。「力フェッチ」が発生し、そこただし、&lt;em&gt;ある&lt;/em&gt;クライアント上の十分なデータがレンダリングするために、我々は次のような動作を期待することができます。</target>
        </trans-unit>
        <trans-unit id="7ed138709fbda62e44a180d5f323c654e6cc766a" translate="yes" xml:space="preserve">
          <source>If a fragment uses variables that are determined at runtime, &lt;a href=&quot;#note-determining-variable-values-at-runtime&quot;&gt;see below&lt;/a&gt;.</source>
          <target state="translated">フラグメントが実行時に決定される変数を使用する場合は、&lt;a href=&quot;#note-determining-variable-values-at-runtime&quot;&gt;以下を参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c5dc5ba510b8cc7e8340243c616a8461f6de45a" translate="yes" xml:space="preserve">
          <source>If a server request results in a failure to load data, we can expect the following behavior:</source>
          <target state="translated">サーバリクエストの結果、データの読み込みに失敗した場合、以下のような動作が予想されます。</target>
        </trans-unit>
        <trans-unit id="c11a40394f41454ad18de679c37d7363316ff63c" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;updater&lt;/code&gt; was provided, Relay will execute it and update the store accordingly. The server payload will be available to the &lt;code&gt;updater&lt;/code&gt; as a root field in the store.</source>
          <target state="translated">場合は &lt;code&gt;updater&lt;/code&gt; 提供された、リレーはそれを実行し、それに応じストアを更新します。サーバーペイロードは、ストアのルートフィールドとして &lt;code&gt;updater&lt;/code&gt; で使用できます。</target>
        </trans-unit>
        <trans-unit id="500f13b73830f97ef3d0785c40a8e9be8e6865fb" translate="yes" xml:space="preserve">
          <source>If an error occurs that prevents &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; from fetching the data required for rendering &lt;code&gt;Component&lt;/code&gt;, nothing will be rendered by default. Error handling behavior can be configured by supplying a callback to the &lt;code&gt;renderFailure&lt;/code&gt; prop:</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;が &lt;code&gt;Component&lt;/code&gt; のレンダリングに必要なデータを取得できないエラーが発生した場合、デフォルトでは何もレンダリングされません。エラー処理の動作は、 &lt;code&gt;renderFailure&lt;/code&gt; プロップにコールバックを提供することで構成できます。</target>
        </trans-unit>
        <trans-unit id="e4eb5b8214d4c82b80af57f3c1c0471dea0d3c7b" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;Component&lt;/code&gt; or &lt;code&gt;route&lt;/code&gt; ever changes, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; will immediately start attempting to fulfill the new data requirements.</source>
          <target state="translated">&lt;code&gt;Component&lt;/code&gt; または &lt;code&gt;route&lt;/code&gt; いずれかが変更されると、&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;はすぐに新しいデータ要件を&lt;strong&gt;満たそ&lt;/strong&gt;うとします。</target>
        </trans-unit>
        <trans-unit id="e7c4473f87af75e4695d24734fbf44e9808a4049" translate="yes" xml:space="preserve">
          <source>If insufficient data on the client leads Relay to send a server request for more data, we can expect the following behavior:</source>
          <target state="translated">クライアントのデータが不足しているために、Relayがさらにデータを要求するサーバ・リクエストを送信した場合、以下のような動作が予想されます。</target>
        </trans-unit>
        <trans-unit id="e7125117da9f12ab4891151c4ede73bbfc431ad0" translate="yes" xml:space="preserve">
          <source>If no request is in flight pendingVariables is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">リクエストが処理中でない場合、pendingVariablesは &lt;code&gt;null&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e94ccf62b4c7fbeeff1884ed8210524c0aaf3f8f" translate="yes" xml:space="preserve">
          <source>If not supplied, a unique collision key is derived (meaning that the created mutation will be independent and not collide with any other).</source>
          <target state="translated">指定しない場合は、一意の衝突キーが導出されます(作成された突然変異は独立しており、他のものと衝突しないことを意味します)。</target>
        </trans-unit>
        <trans-unit id="9f1093c79885887f1a46e11c2dbc9de6bfd2239c" translate="yes" xml:space="preserve">
          <source>If sufficient data is available on the client such that Relay does not need to send a server request, we can expect the following behavior:</source>
          <target state="translated">Relayがサーバ・リクエストを送信する必要がないような十分なデータがクライアントにある場合、以下のような動作が期待できます。</target>
        </trans-unit>
        <trans-unit id="1753e3219d9e6a6f6bf62bc19a7f313caa79226f" translate="yes" xml:space="preserve">
          <source>If supplied and set to true, a request for data will always be made to the server regardless of whether data on the client is available already.</source>
          <target state="translated">これを指定して true に設定すると、クライアント上のデータが既に利用可能かどうかに関わらず、常にサーバへのデータの要求が行われます。</target>
        </trans-unit>
        <trans-unit id="b8cb57719ab0a4774595aab7b466840e3a324de3" translate="yes" xml:space="preserve">
          <source>If supplied and set to true, a request for data will always be made to the server regardless of whether data on the client is available to immediately fulfill the data requirements.</source>
          <target state="translated">これを指定して true に設定すると、クライアント上のデータがすぐにデータ要件を満たすことができるかどうかにかかわらず、常にデータの要求がサーバに行われます。</target>
        </trans-unit>
        <trans-unit id="9652265c2b29a20de6e20099f7748481a1d4b122" translate="yes" xml:space="preserve">
          <source>If the Relay part of an application is some widget or single view as part of a larger application, you don't need any routing. You can just render a &lt;code&gt;QueryRenderer&lt;/code&gt; somewhere on the page to fetch and render the data you need there. This option is simple and should be used when sufficient.</source>
          <target state="translated">アプリケーションのリレー部分が、より大きなアプリケーションの一部としてのウィジェットまたは単一のビューである場合、ルーティングは必要ありません。 &lt;code&gt;QueryRenderer&lt;/code&gt; をページのどこかにレンダリングするだけで、そこに必要なデータをフェッチしてレンダリングできます。このオプションは単純なので、十分な場合に使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="9c687f957f6123e9a6702a53723c6fbcdd75a426" translate="yes" xml:space="preserve">
          <source>If the callback returns &lt;code&gt;undefined&lt;/code&gt;, the previously rendered view (or nothing if there is no previous view) is rendered (e.g. when transitioning from one &lt;code&gt;queryConfig&lt;/code&gt; to another).</source>
          <target state="translated">コールバックが &lt;code&gt;undefined&lt;/code&gt; を返す場合、以前にレンダリングされたビュー（または、以前のビューがない場合は何も）がレンダリングされます（たとえば、ある &lt;code&gt;queryConfig&lt;/code&gt; から別のqueryConfigに移行するとき）。</target>
        </trans-unit>
        <trans-unit id="fa97f983a844f15bf5a18032a6bd22f04fd47eea" translate="yes" xml:space="preserve">
          <source>If the component doesn't actually use &lt;code&gt;setVariables()&lt;/code&gt;, and just uses &lt;code&gt;initialVariables&lt;/code&gt; to share values between JS and GraphQL, there are two alternative approaches:</source>
          <target state="translated">コンポーネントが実際に &lt;code&gt;setVariables()&lt;/code&gt; を使用せず、 &lt;code&gt;initialVariables&lt;/code&gt; を使用してJSとGraphQLの間で値を共有する場合、2つの代替アプローチがあります。</target>
        </trans-unit>
        <trans-unit id="6f707589cc2da01315091844b3b383efdccb634c" translate="yes" xml:space="preserve">
          <source>If the mutation defines an optimistic payload - a set of data to apply locally while waiting for the server response - Relay applies this change and updates any affected React components (note that optimistic updates do not overwrite known server data in the cache).</source>
          <target state="translated">突然変異が楽観的ペイロード(サーバのレスポンスを待つ間にローカルで適用するデータセット)を定義している場合、Relayはこの変更を適用し、影響を受けるReactコンポーネントを更新します(楽観的な更新はキャッシュ内の既知のサーバデータを上書きしないことに注意してください)。</target>
        </trans-unit>
        <trans-unit id="9d815af768aaeea304d01b0f060f4bcc34f6f6e5" translate="yes" xml:space="preserve">
          <source>If the mutation would not 'collide' (overlap) with other pending mutations - as specified by its &lt;code&gt;getCollisionKey&lt;/code&gt; implementation - it is sent to the server. If it would conflict, it is enqueued until conflicting mutations have completed.</source>
          <target state="translated">ミューテーションが他の保留中のミューテーションと「衝突」（オーバーラップ）しない場合（その &lt;code&gt;getCollisionKey&lt;/code&gt; 実装で指定されているとおり）、ミューテーションはサーバーに送信されます。競合する場合は、競合するミューテーションが完了するまでキューに入れられます。</target>
        </trans-unit>
        <trans-unit id="e86698a9dbbdbb49974d25aeca449ae1fbb9e654" translate="yes" xml:space="preserve">
          <source>If the render callback is not supplied, the default behavior is to render the container if data is available, the existing view if one exists, or nothing.</source>
          <target state="translated">レンダーコールバックが指定されていない場合のデフォルトの動作は、データが利用可能な場合はコンテナをレンダリングし、既存のビューが存在する場合は既存のビューをレンダリングします。</target>
        </trans-unit>
        <trans-unit id="1a73cc6d4c2d46fb79932c374ed9da299d065e97" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; suffix, the &lt;code&gt;data&lt;/code&gt; prop name will be used:</source>
          <target state="translated">&lt;code&gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; サフィックスがない場合、 &lt;code&gt;data&lt;/code&gt; プロップ名が使用されます。</target>
        </trans-unit>
        <trans-unit id="62768ad0f3d9c4db4330d79d61d8599e64fd7a9c" translate="yes" xml:space="preserve">
          <source>If we do the same thing with the Empire, we'll find that it returns a different ID, and we can refetch it as well:</source>
          <target state="translated">帝国と同じことをすると違うIDが返ってくるので、それもリフェッチすることができます。</target>
        </trans-unit>
        <trans-unit id="62f00a1501647642fb670b9befaa1fb2d5b19d8f" translate="yes" xml:space="preserve">
          <source>If we provide to a mutation a method that conforms to the signature described above, it will be given the opportunity to modify the fragment builders' variables, based on the previous variables (or the &lt;code&gt;initialVariables&lt;/code&gt; if no previous ones exist), the meta route, and the runtime environment. Whatever variables this method returns will become available to this mutation's fragment builders.</source>
          <target state="translated">上記のシグネチャに準拠するメソッドをミューテーションに提供すると、前の変数（または前の変数が存在しない場合は &lt;code&gt;initialVariables&lt;/code&gt; ）、メタルートに基づいて、フラグメントビルダーの変数を変更する機会が与えられます。そしてランタイム環境。このメソッドが返す変数が何であれ、このミューテーションのフラグメントビルダーが利用できるようになります。</target>
        </trans-unit>
        <trans-unit id="29d042cd073944a1316b1c84fe494fc214ee7caa" translate="yes" xml:space="preserve">
          <source>If we replace &lt;code&gt;2&lt;/code&gt; with a new immutable record, we'll also get a new immutable instance of the cache object. However, records &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; are untouched. Because the data is normalized, we can't tell that &lt;code&gt;story&lt;/code&gt;'s contents have changed just by looking at the &lt;code&gt;story&lt;/code&gt; record alone.</source>
          <target state="translated">&lt;code&gt;2&lt;/code&gt; を新しい不変のレコードに置き換えると、キャッシュオブジェクトの新しい不変のインスタンスも取得されます。ただし、レコード &lt;code&gt;1&lt;/code&gt; と &lt;code&gt;3&lt;/code&gt; は変更されません。データは正規化されているので、我々はその言うことができない &lt;code&gt;story&lt;/code&gt; の内容はちょうどを見て、変更した &lt;code&gt;story&lt;/code&gt; だけではレコードを。</target>
        </trans-unit>
        <trans-unit id="3442e671845ad2d6f63d621dcbdd2a0032b009d1" translate="yes" xml:space="preserve">
          <source>If we wanted to create an instance of this route for arbitrary users, we can subclass the &lt;code&gt;Relay.Route&lt;/code&gt; abstract class. &lt;code&gt;Relay.Route&lt;/code&gt; makes it easy to define a set of queries and required parameters to be re-used multiple times:</source>
          <target state="translated">このルートのインスタンスを任意のユーザー用に作成したい場合は、 &lt;code&gt;Relay.Route&lt;/code&gt; 抽象クラスをサブクラス化できます。 &lt;code&gt;Relay.Route&lt;/code&gt; を使用すると、クエリのセットと複数回再利用する必要なパラメーターを簡単に定義できます。</target>
        </trans-unit>
        <trans-unit id="1e290d52905763c30ab6c18d70c7f5a099e17ab8" translate="yes" xml:space="preserve">
          <source>If you do decide to use an &lt;code&gt;optimisticUpdater&lt;/code&gt;, often times it can be the same function as &lt;code&gt;updater&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;optimisticUpdater&lt;/code&gt; を使用することにした場合、多くの場合、それは &lt;code&gt;updater&lt;/code&gt; と同じ関数になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="bf233e85c6ba7e3a45e4100d4c2cae37e5ec06e0" translate="yes" xml:space="preserve">
          <source>If you find you need to do something unique (like generate types that conform to an older version of Flow, or to parse non-javascript source files), you can build your own version of the Compiler by swapping in your own &lt;code&gt;FileWriter&lt;/code&gt; and &lt;code&gt;ASTCache&lt;/code&gt;, or by adding on an additional &lt;code&gt;IRTransform&lt;/code&gt;. Note, the internal APIs of the &lt;code&gt;RelayCompiler&lt;/code&gt; are under constant iteration, so rolling your own version may lead to incompatibilities with future releases.</source>
          <target state="translated">独自の処理（古いバージョンのFlowに準拠する型の生成、JavaScript以外のソースファイルの解析など）が必要な場合は、独自の &lt;code&gt;FileWriter&lt;/code&gt; と &lt;code&gt;ASTCache&lt;/code&gt; を交換することで、独自のバージョンのコンパイラを構築できます。または、追加の &lt;code&gt;IRTransform&lt;/code&gt; を追加します。 &lt;code&gt;RelayCompiler&lt;/code&gt; の内部APIは常に反復されているため、独自のバージョンをローリングすると、将来のリリースとの非互換性が生じる可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4b62113e72e08231a01f5d4a07e448ee27964d21" translate="yes" xml:space="preserve">
          <source>If you find you need to do something unique (like generate types that conform to an older version of flow, or to parse non-javascript source files), you can build your own version of the Compiler by swapping in your own &lt;code&gt;FileWriter&lt;/code&gt; and &lt;code&gt;ASTCache&lt;/code&gt;, or by adding on an additional &lt;code&gt;IRTransform&lt;/code&gt;. Note, the internal APIs of the &lt;code&gt;RelayCompiler&lt;/code&gt; are under constant iteration, so rolling your own version may lead to incompatibilities with future releases.</source>
          <target state="translated">独自の処理を行う必要がある場合（古いバージョンのフローに準拠するタイプを生成する、JavaScript以外のソースファイルを解析するなど）、独自の &lt;code&gt;FileWriter&lt;/code&gt; と &lt;code&gt;ASTCache&lt;/code&gt; を入れ替えて、独自のバージョンのコンパイラを構築できます。または、追加の &lt;code&gt;IRTransform&lt;/code&gt; を追加します。 &lt;code&gt;RelayCompiler&lt;/code&gt; の内部APIは常に反復されているため、独自のバージョンをロールすると、将来のリリースとの互換性が失われる可能性があります。</target>
        </trans-unit>
        <trans-unit id="7224441b6f15886cd449f3742b23181788ee9b99" translate="yes" xml:space="preserve">
          <source>If you wish to provide your own &lt;code&gt;handlerProvider&lt;/code&gt;, you can do so:</source>
          <target state="translated">独自の &lt;code&gt;handlerProvider&lt;/code&gt; を提供する場合は、次のようにできます。</target>
        </trans-unit>
        <trans-unit id="49a21b30f5b3a1b121343f35b747fe542d51dbf3" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;createRefetchContainer&lt;/code&gt; then your &lt;code&gt;refetch&lt;/code&gt; method may also update these variables to render with new values.</source>
          <target state="translated">&lt;code&gt;createRefetchContainer&lt;/code&gt; を使用している場合、 &lt;code&gt;refetch&lt;/code&gt; メソッドはこれらの変数を更新して、新しい値でレンダリングすることもできます。</target>
        </trans-unit>
        <trans-unit id="0ccc0940cec44b44c366f2d98c395662eb2f306c" translate="yes" xml:space="preserve">
          <source>If you're using a different GraphQL server implementation, we recommend adapting the above example to load the schema from your GraphQL server (e.g. via an HTTP request) and then save the result as JSON.</source>
          <target state="translated">別の GraphQL サーバーの実装を使用している場合は、上記の例を適用して、お使いの GraphQL サーバーからスキーマをロードし(HTTP リクエストなどで)、その結果を JSON として保存することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="2e76567f0db1f25cdaed090474feff64180bb110" translate="yes" xml:space="preserve">
          <source>Imagine we have a simple application that fetches a list of stories, and some details about each one. Here's how that might look in resource-oriented REST:</source>
          <target state="translated">ストーリーのリストと、それぞれの詳細を取得するシンプルなアプリケーションを想像してみてください。以下は、リソース指向の REST でどのように見えるかを示しています。</target>
        </trans-unit>
        <trans-unit id="448e3d99f5bde0fa9efac34be83b204ae98c345a" translate="yes" xml:space="preserve">
          <source>Implement this method in cases where the mutator configuration needed to handle the optimistic response needs to be different than the one that handles the server response.</source>
          <target state="translated">このメソッドは、楽観的な応答を処理するために必要なミューテータの設定が、サーバの応答を処理するものとは異なる必要がある場合に実装されます。</target>
        </trans-unit>
        <trans-unit id="62181f13d4fff5bed161f01ef77d8db655301bec" translate="yes" xml:space="preserve">
          <source>Implement this method to craft an optimistic response having the same shape as the server response payload. This optimistic response will be used to preemptively update the client cache before the server returns, giving the impression that the mutation completed instantaneously.</source>
          <target state="translated">このメソッドを実装して、サーバの応答ペイロードと同じ形状の楽観的な応答を作成します。この楽観的なレスポンスは、サーバが戻ってくる前にクライアントキャッシュを先取りして更新するために使用され、突然変異が瞬時に完了したかのような印象を与えます。</target>
        </trans-unit>
        <trans-unit id="24bc32f306fba32d2cbf91f2cd1999f36a16435a" translate="yes" xml:space="preserve">
          <source>Implement this method to return a collision key. Relay will send any mutations having the same collision key to the server serially and in-order.</source>
          <target state="translated">衝突キーを返すためにこのメソッドを実装します。Relay は、同じコリジョンキーを持つ突然変異をサーバにシリアルに順番に送信します。</target>
        </trans-unit>
        <trans-unit id="1e3fee95e387e2e4175f4c37de616bb736c7491c" translate="yes" xml:space="preserve">
          <source>Implement this method to return a map of &lt;code&gt;File&lt;/code&gt; objects to upload as part of a mutation.</source>
          <target state="translated">このメソッドを実装して、ミューテーションの一部としてアップロードする &lt;code&gt;File&lt;/code&gt; オブジェクトのマップを返します。</target>
        </trans-unit>
        <trans-unit id="48d0a56a8bcb298a554f5516aac54d6f77d81acd" translate="yes" xml:space="preserve">
          <source>Implement this method to return true when the supplied options are supported by this network layer. This is used to declare which features the network layer supports.</source>
          <target state="translated">このメソッドを実装すると、指定されたオプションがこのネットワーク・レイヤーでサポートされている場合に true を返すようになります。これは、ネットワークレイヤがどの機能をサポートしているかを宣言するために使用されます。</target>
        </trans-unit>
        <trans-unit id="b153e451079dd8470ac1e1681b4c8e4668b52b86" translate="yes" xml:space="preserve">
          <source>Implement this method to send mutations to the server. When the server response is obtained, this method must either call &lt;code&gt;mutationRequest.resolve&lt;/code&gt; with the response data, or &lt;code&gt;mutationRequest.reject&lt;/code&gt; with an &lt;code&gt;Error&lt;/code&gt; object.</source>
          <target state="translated">このメソッドを実装して、サーバーに変更を送信します。サーバーの応答が得られた場合、このメソッドは、いずれかを呼び出す必要があり &lt;code&gt;mutationRequest.resolve&lt;/code&gt; を応答データに、または &lt;code&gt;mutationRequest.reject&lt;/code&gt; で &lt;code&gt;Error&lt;/code&gt; オブジェクト。</target>
        </trans-unit>
        <trans-unit id="1d31efc29644775c604543b99db2b73a14120012" translate="yes" xml:space="preserve">
          <source>Implement this method to send queries to the server. For each query request, when the server response is received, this method must either call &lt;code&gt;resolve&lt;/code&gt; with the response data, or &lt;code&gt;reject&lt;/code&gt; with an &lt;code&gt;Error&lt;/code&gt; object.</source>
          <target state="translated">このメソッドを実装して、クエリをサーバーに送信します。クエリ要求ごとに、サーバーの応答が受信されると、このメソッドは応答データで &lt;code&gt;resolve&lt;/code&gt; を呼び出すか、 &lt;code&gt;Error&lt;/code&gt; オブジェクトで &lt;code&gt;reject&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="1774e52d0e556763970083c582a2823556fad1d9" translate="yes" xml:space="preserve">
          <source>Implement this required method to design a &amp;lsquo;fat query&amp;rsquo; &amp;ndash; one that represents every field in your data model that could change as a result of this mutation.</source>
          <target state="translated">この必要なメソッドを実装して「ファットクエリ」を設計します。これは、この変更の結果として変更される可能性があるデータモデルのすべてのフィールドを表します。</target>
        </trans-unit>
        <trans-unit id="55c82c1ede81ef7c75eb0f5ad805b7c8131bec8a" translate="yes" xml:space="preserve">
          <source>Implement this required method to give Relay instructions on how to use the response payload from each mutation to update the client-side store.</source>
          <target state="translated">各突然変異からの応答ペイロードを使用してクライアント側ストアを更新する方法をRelayに指示するために、この必須メソッドを実装します。</target>
        </trans-unit>
        <trans-unit id="17378e1f66fb4d758998ffc792b8f969174e1a87" translate="yes" xml:space="preserve">
          <source>Implement this required method to prepare variables to be used as input to the mutation.</source>
          <target state="translated">突然変異の入力として使用される変数を準備するために、この必須メソッドを実装します。</target>
        </trans-unit>
        <trans-unit id="e0d5783849893b65928056a3e01f878a4ebb371a" translate="yes" xml:space="preserve">
          <source>Implement this required method to return a GraphQL mutation operation that represents the mutation to be performed.</source>
          <target state="translated">この必須メソッドを実装して、実行する変異を表す GraphQL 変異操作を返すようにします。</target>
        </trans-unit>
        <trans-unit id="d8c789b0ff99a369ebb08eda75d64a2002a8918e" translate="yes" xml:space="preserve">
          <source>Importing generated definitions</source>
          <target state="translated">生成された定義のインポート</target>
        </trans-unit>
        <trans-unit id="a8c0b4ec0c84b678651530ba2d81f9beb98a2561" translate="yes" xml:space="preserve">
          <source>In GraphQL, &lt;strong&gt;queries&lt;/strong&gt; declare fields that exist on the root query type. For example, the following query might fetch the name of the user with an &lt;code&gt;id&lt;/code&gt; of &lt;code&gt;123&lt;/code&gt;:</source>
          <target state="translated">GraphQLでは、&lt;strong&gt;クエリ&lt;/strong&gt;はルートクエリタイプに存在するフィールドを宣言します。たとえば、次のクエリは、 &lt;code&gt;123&lt;/code&gt; の &lt;code&gt;id&lt;/code&gt; を持つユーザーの名前をフェッチします。</target>
        </trans-unit>
        <trans-unit id="42cc08262fb0bb543ca0770499256c848ef63cb2" translate="yes" xml:space="preserve">
          <source>In React Native, we can schedule Relay processing so as to avoid interrupting touch gestures as follows:</source>
          <target state="translated">React Nativeでは、以下のようにタッチジェスチャーが途切れないようにRelay処理をスケジュールすることができます。</target>
        </trans-unit>
        <trans-unit id="8ebfcf2d8faf5ad639fc9d0514f8f7159330d866" translate="yes" xml:space="preserve">
          <source>In React, rendering a view requires two inputs: the &lt;em&gt;component&lt;/em&gt; to render, and a &lt;em&gt;root&lt;/em&gt; DOM (UI) node to render into. Rendering Relay containers is similar: we need a &lt;em&gt;container&lt;/em&gt; to render, and a &lt;em&gt;root&lt;/em&gt; in the graph from which to start our query. We also must ensure that the queries for the container are executed and may want to show a loading indicator while data is being fetched. Similar to &lt;code&gt;ReactDOM.render(component, domNode)&lt;/code&gt;, Relay provides &lt;code&gt;&amp;lt;QueryRenderer query={...} variables={...} render={...}&amp;gt;&lt;/code&gt; for this purpose. The &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;variables&lt;/code&gt; define what data to fetch and &lt;code&gt;render&lt;/code&gt; defines what to render. Here's how we might render &lt;code&gt;&amp;lt;StoryContainer&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Reactでは、ビューをレンダリングするには、レンダリングする&lt;em&gt;コンポーネント&lt;/em&gt;と、レンダリングする&lt;em&gt;ルート&lt;/em&gt;DOM（UI）ノードの2つの入力が必要です。リレーコンテナのレンダリングも同様です。レンダリングする&lt;em&gt;コンテナ&lt;/em&gt;と、クエリを開始するグラフの&lt;em&gt;ルート&lt;/em&gt;が必要です。また、コンテナのクエリが実行されていることを確認する必要があり、データのフェッチ中に読み込みインジケータを表示したい場合があります。 &lt;code&gt;ReactDOM.render(component, domNode)&lt;/code&gt; と同様に、Relayはこの目的のために &lt;code&gt;&amp;lt;QueryRenderer query={...} variables={...} render={...}&amp;gt;&lt;/code&gt; を提供します。 &lt;code&gt;query&lt;/code&gt; および &lt;code&gt;variables&lt;/code&gt; データをフェッチとするものを定義する &lt;code&gt;render&lt;/code&gt; 何をレンダリングするかを定義します。 &lt;code&gt;&amp;lt;StoryContainer&amp;gt;&lt;/code&gt; をレンダリングする方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a5187bfb626e29a7807af4b6499d8505f13e32b2" translate="yes" xml:space="preserve">
          <source>In React, rendering a view requires two inputs: the &lt;em&gt;component&lt;/em&gt; to render, and a &lt;em&gt;root&lt;/em&gt; DOM (UI) node to render into. Rendering Relay containers is similar: we need a &lt;em&gt;container&lt;/em&gt; to render, and a &lt;em&gt;root&lt;/em&gt; in the graph from which to start our query. We also must ensure that the queries for the container are executed and may want to show a loading indicator while data is being fetched. Similar to &lt;code&gt;ReactDOM.render(component, domNode)&lt;/code&gt;, Relay provides &lt;code&gt;&amp;lt;Relay.Renderer Container={...} queryConfig={...}&amp;gt;&lt;/code&gt; for this purpose. The container is the item to render, and the queryConfig provides queries that specify &lt;em&gt;which&lt;/em&gt; item to fetch. Here's how we might render &lt;code&gt;&amp;lt;StoryContainer&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Reactでは、ビューのレンダリングには、レンダリングする&lt;em&gt;コンポーネント&lt;/em&gt;と、レンダリング先の&lt;em&gt;ルート&lt;/em&gt; DOM（UI）ノードの2つの入力が必要です。リレーコンテナーのレンダリングも同様です。レンダリングする&lt;em&gt;コンテナー&lt;/em&gt;と、クエリを開始するグラフの&lt;em&gt;ルート&lt;/em&gt;が必要です。また、コンテナーのクエリが実行されていることを確認する必要があります。また、データのフェッチ中に読み込みインジケーターを表示したい場合もあります。 &lt;code&gt;ReactDOM.render(component, domNode)&lt;/code&gt; と同様に、Relayはこの目的で &lt;code&gt;&amp;lt;Relay.Renderer Container={...} queryConfig={...}&amp;gt;&lt;/code&gt; を提供します。コンテナはレンダリングするアイテムであり、queryConfigはフェッチ&lt;em&gt;する&lt;/em&gt;アイテムを指定するクエリを提供します。これがレンダリングの方法です &lt;code&gt;&amp;lt;StoryContainer&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4f9d43e8de662b43a98bf53a133be5a295724798" translate="yes" xml:space="preserve">
          <source>In Relay, data dependencies are described using &lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt;. For &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt;, the dependency can be expressed as follows. Note that this exactly matches the shape that the component expected for the &lt;code&gt;user&lt;/code&gt; prop.</source>
          <target state="translated">リレーでは、データの依存関係は&lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt;を使用して記述されます。ため &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; 次のように、依存関係を表現することができます。これは、コンポーネントが &lt;code&gt;user&lt;/code&gt; プロップに期待する形状と正確に一致することに注意してください。</target>
        </trans-unit>
        <trans-unit id="eba544839f5e404d357e1b726ac9db4aa7980297" translate="yes" xml:space="preserve">
          <source>In Relay, data dependencies are described using &lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt;. For &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt;, the dependency can be expressed as follows. Note that this exactly matches the shape that the component expected for the &lt;code&gt;item&lt;/code&gt; prop.</source>
          <target state="translated">Relayでは、データの依存関係は&lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt;を使用して記述されます。ため &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt; 次のように、依存関係を表現することができます。これは、コンポーネントが &lt;code&gt;item&lt;/code&gt; 支柱に期待する形状と正確に一致することに注意してください。</target>
        </trans-unit>
        <trans-unit id="1084307d05023abf80689279ae0f77b70f810919" translate="yes" xml:space="preserve">
          <source>In Relay, data dependencies are described using &lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt;. For &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt;, the dependency can be expressed as follows. Note that this exactly matches the shape that the component expected for the &lt;code&gt;item&lt;/code&gt; prop.</source>
          <target state="translated">リレーでは、データの依存関係は&lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt;を使用して記述されます。ため &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; 次のように、依存関係を表現することができます。これは、コンポーネントが &lt;code&gt;item&lt;/code&gt; 小道具に期待する形状と正確に一致することに注意してください。</target>
        </trans-unit>
        <trans-unit id="8218e7619ef161652f44088010026d35f36055e0" translate="yes" xml:space="preserve">
          <source>In Relay, the root of a query is defined by a &lt;strong&gt;QueryRenderer&lt;/strong&gt; so check out that section for more details.</source>
          <target state="translated">Relayでは、クエリのルートは&lt;strong&gt;QueryRenderer&lt;/strong&gt;によって定義されるため、詳細についてはそのセクションを確認してください。</target>
        </trans-unit>
        <trans-unit id="30d65c55146011871e1262a4566a24588803dc0d" translate="yes" xml:space="preserve">
          <source>In Relay, the root of a query is defined by a &lt;strong&gt;Route&lt;/strong&gt;. Continue to learn about Relay routes.</source>
          <target state="translated">リレーでは、クエリのルートは&lt;strong&gt;Route&lt;/strong&gt;によって定義されます。リレールートについて学習を続けます。</target>
        </trans-unit>
        <trans-unit id="8403870f1b9487ea70facda9683cbaadf51f154c" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;pagination-container&quot;&gt;pagination container&lt;/a&gt;, we usually annotate the actual connection field with &lt;code&gt;@connection&lt;/code&gt; to tell Relay which part needs to be paginated:</source>
          <target state="translated">では&lt;a href=&quot;pagination-container&quot;&gt;ページネーションコンテナ&lt;/a&gt;、我々は通常と実際の接続フィールドに注釈を付ける &lt;code&gt;@connection&lt;/code&gt; ページ分割されるようにどの部分ニーズリレーを伝えるために：</target>
        </trans-unit>
        <trans-unit id="c21389450ed39ca7f4877ce1712aa3326324e6a9" translate="yes" xml:space="preserve">
          <source>In a resource-oriented REST system, we can maintain a &lt;strong&gt;response cache&lt;/strong&gt; based on URIs:</source>
          <target state="translated">リソース指向のRESTシステムでは、URIに基づいて&lt;strong&gt;応答キャッシュ&lt;/strong&gt;を維持できます。</target>
        </trans-unit>
        <trans-unit id="ddc4813b133487bd46b76268444d4db66fd4598c" translate="yes" xml:space="preserve">
          <source>In a simple mutation, you only need &lt;code&gt;mutation&lt;/code&gt; and &lt;code&gt;variables&lt;/code&gt;:</source>
          <target state="translated">単純なミューテーションでは、 &lt;code&gt;mutation&lt;/code&gt; と &lt;code&gt;variables&lt;/code&gt; のみが必要です。</target>
        </trans-unit>
        <trans-unit id="753db9b3fed6b02e90a81f5ecfd3b20ecf1201c5" translate="yes" xml:space="preserve">
          <source>In a simple subscription, you only need &lt;code&gt;subscription&lt;/code&gt; and &lt;code&gt;variables&lt;/code&gt;. This is appropriate when you are only changing the properties of existing records that can be identified by their &lt;code&gt;id&lt;/code&gt;:</source>
          <target state="translated">単純なサブスクリプションでは、 &lt;code&gt;subscription&lt;/code&gt; と &lt;code&gt;variables&lt;/code&gt; のみが必要です。これは、 &lt;code&gt;id&lt;/code&gt; で識別できる既存のレコードのプロパティのみを変更する場合に適しています。</target>
        </trans-unit>
        <trans-unit id="2d35beb84697160944c091bfc4ea7475ddba8bba" translate="yes" xml:space="preserve">
          <source>In addition to the bin script, the &lt;code&gt;relay-compiler&lt;/code&gt; package also &lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/relay-compiler/RelayCompilerPublic.js&quot;&gt;exports library code&lt;/a&gt; which you may use to create more complex configurations for the compiler, or to extend the compiler with your own custom output.</source>
          <target state="translated">binスクリプトに加えて、 &lt;code&gt;relay-compiler&lt;/code&gt; パッケージは、コンパイラーのより複雑な構成を作成したり、独自のカスタム出力でコンパイラーを拡張したりするために使用できる&lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/relay-compiler/RelayCompilerPublic.js&quot;&gt;ライブラリコード&lt;/a&gt;もエクスポートします。</target>
        </trans-unit>
        <trans-unit id="d61a016e90e92a84f22e5f4a46d1a7c70ba615d3" translate="yes" xml:space="preserve">
          <source>In addition to the bin script, the &lt;code&gt;relay-compiler&lt;/code&gt; package also &lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/relay-compiler/index.js&quot;&gt;exports library code&lt;/a&gt; which you may use to create more complex configurations for the compiler, or to extend the compiler with your own custom output.</source>
          <target state="translated">binスクリプトに加えて、 &lt;code&gt;relay-compiler&lt;/code&gt; パッケージは、コンパイラーのより複雑な構成を作成したり、独自のカスタム出力でコンパイラーを拡張したりするために使用できる&lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/relay-compiler/index.js&quot;&gt;ライブラリー・コード&lt;/a&gt;もエクスポートします。</target>
        </trans-unit>
        <trans-unit id="1ee7cb663ba30043049419a3987f32bf98b8e3b6" translate="yes" xml:space="preserve">
          <source>In order to incrementally convert an existing codebase, we will need to use the Relay Modern API while continuing to use the Relay Classic runtime until all components are converted.</source>
          <target state="translated">既存のコードベースをインクリメンタルに変換するには、Relay Modern APIを使用する必要がありますが、すべてのコンポーネントが変換されるまでRelay Classicランタイムを使用し続ける必要があります。</target>
        </trans-unit>
        <trans-unit id="b06055f46a51395cce09c8715fc83f412863f99f" translate="yes" xml:space="preserve">
          <source>In order to know how to access your GraphQL server, Relay Modern requires developers to provide an object implementing the &lt;code&gt;NetworkLayer&lt;/code&gt; interface when creating an instance of a &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt;. The environment uses this network layer to execute queries, mutations, and (if your server supports them) subscriptions. This allows developers to use whatever transport (HTTP, WebSockets, etc) and authentication is most appropriate for their application, decoupling the environment from the particulars of each application's network configuration.</source>
          <target state="translated">Relay Modernは、GraphQLサーバーにアクセスする方法を知るために、&lt;a href=&quot;relay-environment&quot;&gt;リレー環境の&lt;/a&gt;インスタンスを作成するときに、 &lt;code&gt;NetworkLayer&lt;/code&gt; インターフェイスを実装するオブジェクトを提供するよう開発者に要求します。環境はこのネットワークレイヤーを使用して、クエリ、ミューテーション、および（サーバーでサポートされている場合は）サブスクリプションを実行します。これにより、開発者はトランスポート（HTTP、WebSocketsなど）を使用でき、認証はアプリケーションに最も適しており、環境を各アプリケーションのネットワーク構成の詳細から切り離します。</target>
        </trans-unit>
        <trans-unit id="9751687b059f090db3539850209951869b6090c4" translate="yes" xml:space="preserve">
          <source>In order to pass arguments to a fragment that has &lt;code&gt;@argumentDefinitions&lt;/code&gt;, you need to use the &lt;a href=&quot;graphql-in-relay#arguments&quot;&gt;&lt;code&gt;@arguments&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="translated">&lt;code&gt;@argumentDefinitions&lt;/code&gt; を持つフラグメントに引数を渡すには、&lt;a href=&quot;graphql-in-relay#arguments&quot;&gt; &lt;code&gt;@arguments&lt;/code&gt; &lt;/a&gt;ディレクティブを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="3a7aba64216b1cd4d2d2e3ad530a1f3188fad50d" translate="yes" xml:space="preserve">
          <source>In order to resolve a fragment into an array of objects you have to use the &lt;code&gt;@relay(plural: true)&lt;/code&gt; directive.</source>
          <target state="translated">フラグメントをオブジェクトの配列に解決するには、 &lt;code&gt;@relay(plural: true)&lt;/code&gt; ディレクティブを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="e6f38813eb9d2dd5b73b9500e984665cfcbc9419" translate="yes" xml:space="preserve">
          <source>In our experience, the overwhelming majority of products want one specific behavior: fetch &lt;em&gt;all&lt;/em&gt; the data for a view hierarchy while displaying a loading indicator, and then render the &lt;em&gt;entire&lt;/em&gt; view once the data is ready.</source>
          <target state="translated">私たちの経験では、圧倒的多数の製品で特定の動作が1つ必要です。ロードインジケーターを表示しながらビュー階層の&lt;em&gt;すべて&lt;/em&gt;のデータをフェッチ&lt;em&gt;し&lt;/em&gt;、データの準備ができたらビュー&lt;em&gt;全体を&lt;/em&gt;レンダリングします。</target>
        </trans-unit>
        <trans-unit id="6a8da0b71c4c64aea6ae6834a91b9401918c3e7e" translate="yes" xml:space="preserve">
          <source>In that last example, think of &lt;code&gt;$format&lt;/code&gt; and &lt;code&gt;variables.format&lt;/code&gt; as the same value.</source>
          <target state="translated">最後の例では、 &lt;code&gt;$format&lt;/code&gt; と &lt;code&gt;variables.format&lt;/code&gt; を同じ値と考えてください。</target>
        </trans-unit>
        <trans-unit id="3888fb491d2876bafea276807002a772ce2740fc" translate="yes" xml:space="preserve">
          <source>In the diagram above:</source>
          <target state="translated">上の図では</target>
        </trans-unit>
        <trans-unit id="fafabc5dfb7d6fbb341fd52614abab0575f4bf79" translate="yes" xml:space="preserve">
          <source>In the example below, the &lt;code&gt;user&lt;/code&gt; prop will include the data for &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; fields wherever &lt;code&gt;...Component_internUser&lt;/code&gt; is included, instead of Relay's normal behavior to mask those fields.</source>
          <target state="translated">以下の例では、リレーとは通常の動作ではなく、 &lt;code&gt;...Component_internUser&lt;/code&gt; が含まれている &lt;code&gt;user&lt;/code&gt; に、ユーザープロップに &lt;code&gt;id&lt;/code&gt; および &lt;code&gt;name&lt;/code&gt; フィールドのデータが含まれます。</target>
        </trans-unit>
        <trans-unit id="ec241670d9655070dff253ce613242b187214f42" translate="yes" xml:space="preserve">
          <source>In the example below, the &lt;code&gt;user&lt;/code&gt; prop will include the data for &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; fields wherever &lt;code&gt;...Component_internUser&lt;/code&gt; is included, instead of Relay's normal behavior to mask those fields:</source>
          <target state="translated">以下の例では、 &lt;code&gt;...Component_internUser&lt;/code&gt; が含まれている &lt;code&gt;user&lt;/code&gt; 常に、ユーザープロパティに &lt;code&gt;id&lt;/code&gt; フィールドと &lt;code&gt;name&lt;/code&gt; フィールドのデータが含まれます。これらのフィールドをマスクするRelayの通常の動作ではありません。</target>
        </trans-unit>
        <trans-unit id="d4294ed53c4279bdd7158ab4d044dda1b52e51b3" translate="yes" xml:space="preserve">
          <source>In the example below, the function &lt;code&gt;processItemData&lt;/code&gt; is called from a React component. It requires an item object with a specific set of fields. All React components that use this function should spread the &lt;code&gt;processItemData_item&lt;/code&gt; fragment to ensure all of the correct item data is loaded for this function.</source>
          <target state="translated">以下の例では、関数 &lt;code&gt;processItemData&lt;/code&gt; がReactコンポーネントから呼び出されています。特定のフィールドセットを持つアイテムオブジェクトが必要です。この関数を使用するすべてのReactコンポーネントは、 &lt;code&gt;processItemData_item&lt;/code&gt; フラグメントを拡散して、この関数のすべての正しいアイテムデータが確実に読み込まれるようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="b3b357ad1aa217f6b814380c122b67ca81691203" translate="yes" xml:space="preserve">
          <source>In the future, advanced capabilities in Relay may be dependent on the network layer being able to support certain features.</source>
          <target state="translated">将来的には、Relayの高度な機能は、ネットワーク・レイヤーが特定の機能をサポートできるかどうかに依存する可能性があります。</target>
        </trans-unit>
        <trans-unit id="db9e71215ab64e7c01402f6a78301e1bc8b38923" translate="yes" xml:space="preserve">
          <source>In this article we'll explore what it means to build a GraphQL client framework and how this compares to clients for more traditional REST systems. Along the way we'll look at the design decisions behind Relay and see that it's not just a GraphQL client but also a framework for &lt;em&gt;declarative data-fetching&lt;/em&gt;. Let's start at the beginning and fetch some data!</source>
          <target state="translated">この記事では、GraphQLクライアントフレームワークを構築することの意味と、これを従来のRESTシステムのクライアントと比較する方法について説明します。途中で、Relayの背後にある設計上の決定を見て、それが単なるGraphQLクライアントであるだけでなく、&lt;em&gt;宣言的なデータフェッチの&lt;/em&gt;ためのフレームワークでもあることがわかります。最初から始めて、データをフェッチしてみましょう！</target>
        </trans-unit>
        <trans-unit id="88a02e183add9d1c24413aa47baf530897708969" translate="yes" xml:space="preserve">
          <source>In this example the Route should be initialized with a &lt;code&gt;userID&lt;/code&gt; which gets passed on to the query. That &lt;code&gt;userID&lt;/code&gt; variable will automatically be passed down to the top-level container and can be used there if needed. Further the top-level RelayContainer is expected to have a &lt;code&gt;user&lt;/code&gt; fragment with the fields to be queried.</source>
          <target state="translated">この例では、ルートはクエリに渡される &lt;code&gt;userID&lt;/code&gt; で初期化する必要があります。その &lt;code&gt;userID&lt;/code&gt; 変数は自動的に最上位のコンテナーに渡され、必要に応じてそこで使用できます。さらに、最上位のRelayContainerには、クエリ対象のフィールドを持つ &lt;code&gt;user&lt;/code&gt; フラグメントがあることが期待されます。</target>
        </trans-unit>
        <trans-unit id="fc3d9a2430b8dd6fdd1855b01aae967a1a86922c" translate="yes" xml:space="preserve">
          <source>In this example we are using a Refetch Container to fetch more stories in a story feed component.</source>
          <target state="translated">この例では、ストーリー フィード コンポーネントでより多くのストーリーを取得するためにリフェッチ コンテナを使用しています。</target>
        </trans-unit>
        <trans-unit id="8e65c0999502b8d880342481e43745e86b87bd15" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;profilePicture(size: 50)&lt;/code&gt; will be fetched for the intial render.</source>
          <target state="translated">この例では、 &lt;code&gt;profilePicture(size: 50)&lt;/code&gt; レンダリングのためにprofilePicture（size：50）がフェッチされます。</target>
        </trans-unit>
        <trans-unit id="b029685528e8da2f8ce2cf427c32ff8fbbf0ee00" translate="yes" xml:space="preserve">
          <source>In this example, create an inspector object based on the same source as passed into your &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt;. Later you can use this inspector object to inspect records. Inspector is only available in the development build.</source>
          <target state="translated">この例では、&lt;a href=&quot;relay-environment&quot;&gt;リレー環境に&lt;/a&gt;渡されたものと同じソースに基づいてインスペクターオブジェクトを作成します。後でこのインスペクタオブジェクトを使用してレコードを検査できます。インスペクターは開発ビルドでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="4e1907e8aedfd3075f12c9bb08511b6424b05151" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;width&lt;/code&gt; of the rendered image will always correspond to the &lt;code&gt;$size&lt;/code&gt; variable used to fetch the current version of &lt;code&gt;profilePicture.uri&lt;/code&gt;.</source>
          <target state="translated">この例では、レンダリングされた画像の &lt;code&gt;width&lt;/code&gt; は、常に現在のバージョンの &lt;code&gt;profilePicture.uri&lt;/code&gt; をフェッチするために使用される &lt;code&gt;$size&lt;/code&gt; 変数に対応します。</target>
        </trans-unit>
        <trans-unit id="86e6e74d266fdaa434ba59fe220a17114ef82453" translate="yes" xml:space="preserve">
          <source>In this example, the fields associated with the &lt;code&gt;ship&lt;/code&gt; fragment will be made available on &lt;code&gt;this.props.ship&lt;/code&gt;.</source>
          <target state="translated">この例では、 &lt;code&gt;ship&lt;/code&gt; フラグメントに関連付けられたフィールドが &lt;code&gt;this.props.ship&lt;/code&gt; で使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="85172d5db32fabb64291c47b382ebcc9097ed293" translate="yes" xml:space="preserve">
          <source>In this example, whenever &lt;code&gt;Parent&lt;/code&gt; is fetched, &lt;code&gt;Child&lt;/code&gt;'s fragment will also be fetched. When rendering, &lt;code&gt;&amp;lt;Parent&amp;gt;&lt;/code&gt; will only have access to the &lt;code&gt;props.foo.id&lt;/code&gt; field; data from the child fragment will be &lt;a href=&quot;http://facebook.github.io/relay/docs/thinking-in-relay.html#data-masking&quot;&gt;&lt;em&gt;masked&lt;/em&gt;&lt;/a&gt;. By default, &lt;code&gt;childFragment&lt;/code&gt; will use its corresponding initial variables. Relay will fetch &lt;code&gt;photo(size: 64)&lt;/code&gt;. When &lt;code&gt;&amp;lt;Child&amp;gt;&lt;/code&gt; is rendered it will also make the initial variables available as &lt;code&gt;props.relay.variables = {size: 64}&lt;/code&gt;.</source>
          <target state="translated">この例では、 &lt;code&gt;Parent&lt;/code&gt; がフェッチされるたびに、 &lt;code&gt;Child&lt;/code&gt; のフラグメントもフェッチされます。レンダリング時、 &lt;code&gt;&amp;lt;Parent&amp;gt;&lt;/code&gt; は &lt;code&gt;props.foo.id&lt;/code&gt; フィールドにのみアクセスできます。子フラグメントのデータは&lt;a href=&quot;http://facebook.github.io/relay/docs/thinking-in-relay.html#data-masking&quot;&gt;&lt;em&gt;マスクされ&lt;/em&gt;&lt;/a&gt;ます。デフォルトでは、 &lt;code&gt;childFragment&lt;/code&gt; は対応する初期変数を使用します。リレーは &lt;code&gt;photo(size: 64)&lt;/code&gt; をフェッチします。場合 &lt;code&gt;&amp;lt;Child&amp;gt;&lt;/code&gt; レンダリングされ、それはまた、初期変数が利用できるようになります &lt;code&gt;props.relay.variables = {size: 64}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79f26e8bd2ce0d98aed5c314fad80d4d64f729d8" translate="yes" xml:space="preserve">
          <source>In this example, whenever a picture with a new size is being loaded a spinner is displayed instead of the picture.</source>
          <target state="translated">この例では、新しいサイズの画像が読み込まれると、画像の代わりにスピナーが表示されます。</target>
        </trans-unit>
        <trans-unit id="11c9642bf0d68f60f8223631d67d9ed8e587f204" translate="yes" xml:space="preserve">
          <source>In this particular example, the only field that the &lt;code&gt;LikeButton&lt;/code&gt; cares about is &lt;code&gt;viewerDoesLike&lt;/code&gt;. That field will form part of the tracked query that Relay will intersect with the fat query of &lt;code&gt;LikeStoryMutation&lt;/code&gt; to determine what fields to request as part of the server's response payload for the mutation. Another component elsewhere in the application might be interested in the likers count, or the like sentence. Since those fields will automatically be added to Relay's tracked query, the &lt;code&gt;LikeButton&lt;/code&gt; need not worry about requesting them explicitly.</source>
          <target state="translated">この特定の例では、 &lt;code&gt;LikeButton&lt;/code&gt; が処理する唯一のフィールドは &lt;code&gt;viewerDoesLike&lt;/code&gt; です。そのフィールドは、リレーが &lt;code&gt;LikeStoryMutation&lt;/code&gt; のファットクエリと交差して、ミューテーションに対するサーバーの応答ペイロードの一部としてリクエストするフィールドを決定する追跡クエリの一部を形成します。アプリケーションの他の場所にある別のコンポーネントは、いいね！の数などの文に関心があるかもしれません。これらのフィールドは、Relayの追跡されたクエリに自動的に追加されるため、 &lt;code&gt;LikeButton&lt;/code&gt; は明示的に要求する必要はありません。</target>
        </trans-unit>
        <trans-unit id="73de0e214eb1fe6fc2a92866867bd0a77a34d53e" translate="yes" xml:space="preserve">
          <source>In this simple example, let's assume we want to fetch the latest data for a &lt;code&gt;TodoItem&lt;/code&gt; from the server:</source>
          <target state="translated">この簡単な例では、サーバーから &lt;code&gt;TodoItem&lt;/code&gt; の最新データをフェッチするとします。</target>
        </trans-unit>
        <trans-unit id="877c9e959c13a50bd6cd2c0684ab7d5def3e1397" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will build a game using GraphQL mutations. The goal of the game is to find a hidden treasure in a grid of 9 squares. We will give players three tries to find the treasure. This should give us an end-to-end look at Relay &amp;ndash; from the GraphQL schema on the server, to the React application on the client.</source>
          <target state="translated">このチュートリアルでは、GraphQLミューテーションを使用してゲームを構築します。ゲームの目標は、9つの正方形のグリッドで隠された宝物を見つけることです。プレイヤーは宝物を見つけるために3回試行します。これにより、サーバー上のGraphQLスキーマからクライアント上のReactアプリケーションまで、Relayをエンドツーエンドで確認できるようになります。</target>
        </trans-unit>
        <trans-unit id="c1f61deb9bd75956e5146dd965f4efa1acf76ef5" translate="yes" xml:space="preserve">
          <source>Incrementally modernize your Relay Classic app in these steps:</source>
          <target state="translated">以下の手順でRelay Classicアプリを段階的に近代化します。</target>
        </trans-unit>
        <trans-unit id="0e8c879968a7b304e9792c15d95365ae89d2aa45" translate="yes" xml:space="preserve">
          <source>Injectable Custom Field Handlers</source>
          <target state="translated">注射可能なカスタムフィールドハンドラ</target>
        </trans-unit>
        <trans-unit id="e69c600fe29f0ed75880fd3b696888c254caf34f" translate="yes" xml:space="preserve">
          <source>Inline Fragments</source>
          <target state="translated">インラインフラグメント</target>
        </trans-unit>
        <trans-unit id="1889c37693175c0225de5e6837f2ed3f9f529fe3" translate="yes" xml:space="preserve">
          <source>Inline the value in the GraphQL query, potentially annotating with a GraphQL comment (i.e. &lt;code&gt;# PAGE_SIZE&lt;/code&gt;).</source>
          <target state="translated">潜在的に（すなわちGraphQLコメントと注釈を付ける、GraphQLクエリで値をインライン &lt;code&gt;# PAGE_SIZE&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0de09ec0beb82594d04ee09d8aeb812d06a3d58b" translate="yes" xml:space="preserve">
          <source>Install the latest version of Relay from the &lt;a href=&quot;relay-modern&quot;&gt;getting started guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;relay-modern&quot;&gt;スタートガイド&lt;/a&gt;から最新バージョンのリレーをインストールします。</target>
        </trans-unit>
        <trans-unit id="6603c8ba1e08fe9cd6b6dad35da64e9d939e1d23" translate="yes" xml:space="preserve">
          <source>Integration options are available for open-source routing libraries that can instead fetch data for nested routes in parallel. In many of these cases, using a batching network layer can bring additional benefits in avoiding sending multiple HTTP requests.</source>
          <target state="translated">オープンソースのルーティングライブラリでは、ネストされたルートのデータを並行してフェッチすることができる統合オプションが用意されています。これらのケースの多くでは、バッチングネットワークレイヤーを使用することで、複数の HTTP リクエストを送信しないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="ba3a36612e2c9eeb3ee746032e0c52004c3b84f8" translate="yes" xml:space="preserve">
          <source>Integration with Relay Classic for React Router v2 or v3 is available via &lt;a href=&quot;https://github.com/relay-tools/react-router-relay&quot;&gt;&lt;code&gt;react-router-relay&lt;/code&gt;&lt;/a&gt;, which will aggregate the queries for matched routes, and request data for all routes in parallel.</source>
          <target state="translated">React Router v2またはv3のRelay Classicとの統合は、&lt;a href=&quot;https://github.com/relay-tools/react-router-relay&quot;&gt; &lt;code&gt;react-router-relay&lt;/code&gt; &lt;/a&gt;を介して利用できます。これにより、一致したルートのクエリが集約され、すべてのルートのデータが並行してリクエストされます。</target>
        </trans-unit>
        <trans-unit id="5681686d7dd00f9ec2ed83d86065fe5a9aa47328" translate="yes" xml:space="preserve">
          <source>Introduction to Relay</source>
          <target state="translated">リレーの紹介</target>
        </trans-unit>
        <trans-unit id="ca6f57623e58b4619d24d2a4a11fc39e22aace3a" translate="yes" xml:space="preserve">
          <source>Introduction to Relay Modern</source>
          <target state="translated">現代のリレー入門</target>
        </trans-unit>
        <trans-unit id="ede0b81585211d6b9897a8c1877bb4add0712d66" translate="yes" xml:space="preserve">
          <source>Invalidates the record. This will cause any query that references this record to be considered stale until the next time it is refetched, and will be considered to require a refetch the next time such a query is checked with &lt;code&gt;environment.check()&lt;/code&gt;.</source>
          <target state="translated">レコードを無効にします。これにより、このレコードを参照するクエリは、次に再フェッチされるまで失効していると見なされ、次にそのようなクエリが &lt;code&gt;environment.check()&lt;/code&gt; でチェックされるときに再フェッチが必要であると見なされます。</target>
        </trans-unit>
        <trans-unit id="cdaf67797686a7d4a210975b6064cb3ac3259374" translate="yes" xml:space="preserve">
          <source>It is also assumed that the reader is already familiar with &lt;a href=&quot;https://en.wikipedia.org/wiki/Star_Wars&quot;&gt;Star Wars&lt;/a&gt;; if not, the 1977 version of Star Wars is a good place to start, though the 1997 Special Edition will serve for the purposes of this document.</source>
          <target state="translated">また、読者はすでに&lt;a href=&quot;https://en.wikipedia.org/wiki/Star_Wars&quot;&gt;スターウォーズに&lt;/a&gt;精通していることを前提としています。そうでない場合は、1977年版のスターウォーズから始めるのが適切ですが、1997年の特別版はこのドキュメントの目的に役立ちます。</target>
        </trans-unit>
        <trans-unit id="df2797c242fbac686a5646e3f8d0990c4c69631c" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is already familiar with GraphQL; if not, the README for &lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;GraphQL.js&lt;/a&gt; is a good place to start.</source>
          <target state="translated">読者はすでにGraphQLに精通していることを前提としています。そうでない場合は、&lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;GraphQL.js&lt;/a&gt;のREADME から始めるとよいでしょう。</target>
        </trans-unit>
        <trans-unit id="1c307b4b2396ebcfc67f090b9356192c30ee3e15" translate="yes" xml:space="preserve">
          <source>It is not recommended to use &lt;code&gt;@relay(mask: false)&lt;/code&gt;. Please instead consider using the &lt;code&gt;@inline&lt;/code&gt; fragment.</source>
          <target state="translated">&lt;code&gt;@relay(mask: false)&lt;/code&gt; 使用はお勧めしません。代わりに、 &lt;code&gt;@inline&lt;/code&gt; フラグメントの使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="00f22d6b7169a71e14f872d1e3e6975d4ba68fa7" translate="yes" xml:space="preserve">
          <source>It is usually preferable to just pass an &lt;code&gt;optimisticResponse&lt;/code&gt; option instead of an &lt;code&gt;optimisticUpdater&lt;/code&gt;, unless you need to perform updates on the local records that are more complicated than just updating fields (e.g. deleting records or adding items to collections).</source>
          <target state="translated">それだけで合格することが通常望ましい &lt;code&gt;optimisticResponse&lt;/code&gt; の代わりのオプション &lt;code&gt;optimisticUpdater&lt;/code&gt; を使用すると、ローカル、レコードの更新を実行する必要がない限り、単なる更新フィールドよりも複雑されていること、（例えば削除レコードまたはコレクションに項目を追加します）。</target>
        </trans-unit>
        <trans-unit id="efecd775937b634754af4f65cbef5c8b4a7d96ba" translate="yes" xml:space="preserve">
          <source>It returns a &lt;code&gt;Disposable&lt;/code&gt; on which you could call &lt;code&gt;dispose()&lt;/code&gt; to cancel the refetch.</source>
          <target state="translated">再フェッチをキャンセル &lt;code&gt;dispose()&lt;/code&gt; を呼び出すことができる &lt;code&gt;Disposable&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="196589ac6e2b21bbd604e37c3b6f49f22ed50655" translate="yes" xml:space="preserve">
          <source>JavaScript environment requirements</source>
          <target state="translated">JavaScript環境の要件</target>
        </trans-unit>
        <trans-unit id="0b490a2df160ed0c71b8320c42d90d77b3406679" translate="yes" xml:space="preserve">
          <source>JavaScript helpers for defining connections between data, and mutations, in a way that smoothly integrates with Relay.</source>
          <target state="translated">データ間の接続や突然変異を定義するためのJavaScriptヘルパーで、Relayとスムーズに統合できます。</target>
        </trans-unit>
        <trans-unit id="3763226e2b043a56c9ba7559341b0774c3ea862d" translate="yes" xml:space="preserve">
          <source>Keep in mind that it is typically considered an &lt;strong&gt;anti-pattern&lt;/strong&gt; to create a single fragment shared across many containers. Abusing this directive could result in over-fetching in your application.</source>
          <target state="translated">多くのコンテナで共有される単一のフラグメントを作成することは、一般的に&lt;strong&gt;アンチパターン&lt;/strong&gt;と見なされることに注意してください。このディレクティブを悪用すると、アプリケーションでオーバーフェッチが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="25fe5a3c2698d53807ead685c86822cf47cc3073" translate="yes" xml:space="preserve">
          <source>Learn how to use &lt;code&gt;onReadyStateChange&lt;/code&gt; in our next guide, &lt;a href=&quot;guides-ready-state&quot;&gt;Ready State&lt;/a&gt;.</source>
          <target state="translated">次のガイドである&lt;a href=&quot;guides-ready-state&quot;&gt;Ready Stateで&lt;/a&gt; &lt;code&gt;onReadyStateChange&lt;/code&gt; の使用方法を学んでください。</target>
        </trans-unit>
        <trans-unit id="4a4f4fc8ca8973cbce4f7744b6aee5bccdaab0f6" translate="yes" xml:space="preserve">
          <source>Let's associate the mutation we just created with the root mutation type:</source>
          <target state="translated">先ほど作成した突然変異をルートの突然変異型に関連付けてみましょう。</target>
        </trans-unit>
        <trans-unit id="f8acb98279c7a33b14354f6c3ef2bfe03f2deca1" translate="yes" xml:space="preserve">
          <source>Let's craft an optimistic response for the &lt;code&gt;LikeStoryMutation&lt;/code&gt; example above:</source>
          <target state="translated">上記の &lt;code&gt;LikeStoryMutation&lt;/code&gt; の例に対する楽観的な応答を作成してみましょう。</target>
        </trans-unit>
        <trans-unit id="ba32433c3c054db31c3adabcaef06296860fad94" translate="yes" xml:space="preserve">
          <source>Let's explore how this works via a &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; component that composes the &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; from above.</source>
          <target state="translated">上から &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; を構成する &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; コンポーネントを介して、これがどのように機能するかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="25a086b22a4ba22a2ce589d6573f5857d3b2c109" translate="yes" xml:space="preserve">
          <source>Let's explore how this works via a &lt;code&gt;&amp;lt;TodoList /&amp;gt;&lt;/code&gt; component that composes the &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt; we defined above.</source>
          <target state="translated">のは、見てみましょうどのように経由して、この作品 &lt;code&gt;&amp;lt;TodoList /&amp;gt;&lt;/code&gt; 構成要素 &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt; 私たちは上記で定義されました。</target>
        </trans-unit>
        <trans-unit id="89835a8e4dc90be9c02f2fb3d5af523e7de7cee2" translate="yes" xml:space="preserve">
          <source>Let's explore how this works via a &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; component that composes the &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; from above.</source>
          <target state="translated">のは、見てみましょうどのように経由して、この作品 &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; 構成要素 &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; 上から。</target>
        </trans-unit>
        <trans-unit id="8eb1ff4062deba895e97692f949a6733e97ad5f6" translate="yes" xml:space="preserve">
          <source>Let's look at some product use-cases to understand how we incorporated these ideas into Relay. We'll assume a basic familiarity with React.</source>
          <target state="translated">これらのアイデアをどのようにしてReactに取り入れたかを理解するために、いくつかの製品のユースケースを見てみましょう。ここでは、Reactの基本的な知識を想定しています。</target>
        </trans-unit>
        <trans-unit id="839d4a2135069fbb40df14cc776556712d98fa6a" translate="yes" xml:space="preserve">
          <source>Let's open up the starter kit's schema, and replace the database imports with the ones we just created:</source>
          <target state="translated">スターターキットのスキーマを開き、データベースのインポートを先ほど作成したものに置き換えてみましょう。</target>
        </trans-unit>
        <trans-unit id="a72ca83abcd8602717039b5f64a5b5a2b89c81e1" translate="yes" xml:space="preserve">
          <source>Let's see this in action, and query for the ID of the rebels:</source>
          <target state="translated">これを実際に見て、反乱軍のIDを照会してみましょう。</target>
        </trans-unit>
        <trans-unit id="c673a2bcf682f78fa812bcbefa0360994ed37548" translate="yes" xml:space="preserve">
          <source>Let's start a project using the &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt; as a base.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;リレースターターキット&lt;/a&gt;をベースとしてプロジェクトを開始しましょう。</target>
        </trans-unit>
        <trans-unit id="a71dc4b410048806e0d1bbd75c4e909652f2f534" translate="yes" xml:space="preserve">
          <source>Let's take the rebels, and ask for their first ship:</source>
          <target state="translated">反乱軍を連れて最初の船を要求しよう</target>
        </trans-unit>
        <trans-unit id="510f4b78cd5f8fbd49c14a5834839d1ab18bb893" translate="yes" xml:space="preserve">
          <source>Let's tweak the file &lt;code&gt;./js/routes/AppHomeRoute.js&lt;/code&gt; to anchor our game to the &lt;code&gt;game&lt;/code&gt; root field of the schema:</source>
          <target state="translated">ファイル &lt;code&gt;./js/routes/AppHomeRoute.js&lt;/code&gt; を調整して、ゲームをスキーマの &lt;code&gt;game&lt;/code&gt; ルートフィールドに固定します。</target>
        </trans-unit>
        <trans-unit id="cc5b2a062f05dd148b4ef24c76639416ebcc59f3" translate="yes" xml:space="preserve">
          <source>Licensed under the BSD License.</source>
          <target state="translated">BSDライセンスの下でライセンスされています。</target>
        </trans-unit>
        <trans-unit id="8882f419c30a0460f51c5ec6edaf87949c2d7459" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;updater&lt;/code&gt;, there is no need to provide &lt;code&gt;optimisticUpdater&lt;/code&gt; for simple mutations (field change).</source>
          <target state="translated">&lt;code&gt;updater&lt;/code&gt; と同様に、単純なミューテーション（フィールド変更）に &lt;code&gt;optimisticUpdater&lt;/code&gt; を提供する必要はありません。</target>
        </trans-unit>
        <trans-unit id="35b9502f3f76f952801534521de9830a54b15a16" translate="yes" xml:space="preserve">
          <source>Like it can be done with &lt;a href=&quot;guides-containers&quot;&gt;Relay containers&lt;/a&gt;, we can prepare variables for use by our mutation's fragment builders, based on the previous variables and the runtime environment.</source>
          <target state="translated">&lt;a href=&quot;guides-containers&quot;&gt;リレーコンテナ&lt;/a&gt;で実行できるように、以前の変数とランタイム環境に基づいて、ミューテーションのフラグメントビルダーで使用する変数を準備できます。</target>
        </trans-unit>
        <trans-unit id="3715b94c23f4ec20e0da2f29449a3c4646b3d581" translate="yes" xml:space="preserve">
          <source>Like most of the Relay APIs, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; attempts to resolve data using the client store before sending a request to the server. If we instead wanted to force a server request even if data is available on the client, we could use the &lt;code&gt;forceFetch&lt;/code&gt; boolean prop.</source>
          <target state="translated">ほとんどのリレーAPIと同様に、&lt;strong&gt;Relay.RootContainer&lt;/strong&gt;は、サーバーにリクエストを送信する前に、クライアントストアを使用してデータを解決しようとします。代わりに、クライアントでデータが利用できる場合でもサーバーリクエストを強制したい場合は、 &lt;code&gt;forceFetch&lt;/code&gt; ブールプロップを使用できます。</target>
        </trans-unit>
        <trans-unit id="f856144ecb9d05326c6d97badc1a9b834b075ac1" translate="yes" xml:space="preserve">
          <source>Like the GraphQL URI, the timeout and retry behavior can be configured:</source>
          <target state="translated">GraphQL URIと同様に、タイムアウトとリトライの動作を設定することができます。</target>
        </trans-unit>
        <trans-unit id="4bcca57dadd610f8dfd235a855de5feef290f38a" translate="yes" xml:space="preserve">
          <source>Loading more data</source>
          <target state="translated">より多くのデータを読み込む</target>
        </trans-unit>
        <trans-unit id="48a466fb1a66e2ac77ce3c14782794ae94365211" translate="yes" xml:space="preserve">
          <source>Managing asynchronous state transitions and coordinating concurrent requests.</source>
          <target state="translated">非同期の状態遷移を管理し、同時進行のリクエストを調整します。</target>
        </trans-unit>
        <trans-unit id="52b2066f0ecc6504fa0d1683e70c5884d55a8b13" translate="yes" xml:space="preserve">
          <source>Managing errors.</source>
          <target state="translated">エラーの管理。</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="9973640b391cb4b42f93e3afba3395c46f6a7823" translate="yes" xml:space="preserve">
          <source>Migrating a Relay Classic app to Relay Modern doesn't require rewriting from scratch. Instead, convert one component at a time to the Relay Modern API while continuing to have a working app. Once all components have been converted, the smaller and faster Relay Modern runtime can be used.</source>
          <target state="translated">Relay ClassicアプリをRelay Modernに移行する際に、一から書き直す必要はありません。代わりに、アプリを動作させたまま、1つずつコンポーネントをRelay Modern APIに変換してください。すべてのコンポーネントが変換されると、より小さくて高速なRelay Modernランタイムを使用することができます。</target>
        </trans-unit>
        <trans-unit id="a496d014360b49f4df7da034a0313b6a98aa03a1" translate="yes" xml:space="preserve">
          <source>Migrating a Relay Classic app to Relay Modern doesn't require rewriting from scratch. Instead, you can convert one component at a time to the Relay Modern API while continuing to have a working app. Once all components have been converted, the smaller and faster Relay Modern runtime can be used.</source>
          <target state="translated">Relay ClassicアプリをRelay Modernに移行する際に、一から書き直す必要はありません。その代わり、アプリを動作させたまま、1つずつコンポーネントをRelay Modern APIに変換することができます。すべてのコンポーネントが変換されると、より小さくて高速なRelay Modernランタイムを使用することができます。</target>
        </trans-unit>
        <trans-unit id="89ca9763c43ac3c5a6b549a8936812ce36f490d5" translate="yes" xml:space="preserve">
          <source>Migrating to Relay Modern</source>
          <target state="translated">Relay Modernへの移行</target>
        </trans-unit>
        <trans-unit id="a2d0fdbac2d058cc7df5b6a959221d8c7b0c5956" translate="yes" xml:space="preserve">
          <source>Modern &lt;code&gt;createRefetchContainer&lt;/code&gt;</source>
          <target state="translated">最新の &lt;code&gt;createRefetchContainer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04ddebd72b3485cb649586cd882bbc4a0abdd841" translate="yes" xml:space="preserve">
          <source>Modern &lt;code&gt;this.props.relay.loadMore(pageSize...)&lt;/code&gt; in a Pagination Container</source>
          <target state="translated">ページ &lt;code&gt;this.props.relay.loadMore(pageSize...)&lt;/code&gt; コンテナー内の最新のthis.props.relay.loadMore（pageSize ...）</target>
        </trans-unit>
        <trans-unit id="eb7d95f729e7a3975428e61ddb5eb7d7241b4fd9" translate="yes" xml:space="preserve">
          <source>Modern Component</source>
          <target state="translated">モダンなコンポーネント</target>
        </trans-unit>
        <trans-unit id="43dee33213cedaefc62f54e39a529109b27d00fd" translate="yes" xml:space="preserve">
          <source>Modern Mutation</source>
          <target state="translated">現代の突然変異</target>
        </trans-unit>
        <trans-unit id="f4c44d48df48d618739f0b3ad40791ec870c9181" translate="yes" xml:space="preserve">
          <source>Modern Runtime</source>
          <target state="translated">現代のランタイム</target>
        </trans-unit>
        <trans-unit id="d9c1afdc6ae257e230b98cd64d31e69e21611588" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;&amp;lt;QueryRenderer&amp;gt;&lt;/code&gt;</source>
          <target state="translated">最新： &lt;code&gt;&amp;lt;QueryRenderer&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a5e6e8b97a1927e12c72c467f5aebd11a8b3d28" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;commitMutation(this.props.relay.environment, {mutation...})&lt;/code&gt;</source>
          <target state="translated">モダン： &lt;code&gt;commitMutation(this.props.relay.environment, {mutation...})&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08b3c5d91eb7d6d9c801374dc1e47b603bba9b4b" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;createFragmentContainer&lt;/code&gt;</source>
          <target state="translated">モダン： &lt;code&gt;createFragmentContainer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f02b7506a9375f3a261dab66ee915f347b72fd85" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;createPaginationContainer&lt;/code&gt;</source>
          <target state="translated">モダン： &lt;code&gt;createPaginationContainer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c48a2a55168fdc7ce4613937fb203cff48a67840" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;this.props.relay.refetch({foo: bar}...&lt;/code&gt; in a Refetch Container</source>
          <target state="translated">現代： &lt;code&gt;this.props.relay.refetch({foo: bar}...&lt;/code&gt; 再フェッチコンテナで</target>
        </trans-unit>
        <trans-unit id="189e341013a3594080b144a6999f9577b74abee9" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;this.props.relay.refetchConnection(...)&lt;/code&gt; in a Pagination Container</source>
          <target state="translated">最新：ページ &lt;code&gt;this.props.relay.refetchConnection(...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b11a8c01d122a0561a2dbd1098a225c3e43e4308" translate="yes" xml:space="preserve">
          <source>Most applications will create a single Environment instance and use it throughout. In specific situations, however, you may want to create multiple environments for different purposes. For example, you may create a new environment instance whenever the user logs in or out in order to prevent data for different users being cached together. Similarly, a server rendered application may create a new environment instance per request, so that each request gets its own cache and user data does not overlap. Alternatively, you might have multiple products or features within a larger application, and you want each one to have product-specific network-handling or caching.</source>
          <target state="translated">ほとんどのアプリケーションでは、1つの環境インスタンスを作成し、それを全体的に使用します。しかし、特定の状況では、異なる目的のために複数の環境を作成したい場合があります。例えば、異なるユーザーのデータが一緒にキャッシュされるのを防ぐために、ユーザーがログインまたはログアウトするたびに新しい環境インスタンスを作成することができます。同様に、サーバーレンダリングされたアプリケーションは、リクエストごとに新しい環境インスタンスを作成して、各リクエストが独自のキャッシュを取得し、ユーザーデータが重複しないようにすることができます。あるいは、より大きなアプリケーション内に複数の製品や機能があり、それぞれに製品固有のネットワーク処理やキャッシュを持たせたい場合もあるでしょう。</target>
        </trans-unit>
        <trans-unit id="01c289d32b7203303850eb1c7dd2fdae6842ce3a" translate="yes" xml:space="preserve">
          <source>Must be a valid &lt;code&gt;RelayContainer&lt;/code&gt;. Relay will attempt to fulfill its data requirements before rendering it.</source>
          <target state="translated">有効な &lt;code&gt;RelayContainer&lt;/code&gt; である必要があります。リレーはレンダリングする前にデータ要件を満たそうとします。</target>
        </trans-unit>
        <trans-unit id="7b7385bcbd1923e030dad3540db44e565ab25b47" translate="yes" xml:space="preserve">
          <source>Mutates the current record by copying the fields over from the passed in record &lt;code&gt;sourceRecord&lt;/code&gt;.</source>
          <target state="translated">渡されたレコード &lt;code&gt;sourceRecord&lt;/code&gt; からフィールドをコピーして、現在のレコードを変更します。</target>
        </trans-unit>
        <trans-unit id="b750075e624836051694833f9672b6324629ee12" translate="yes" xml:space="preserve">
          <source>Mutates the current record by setting a new linked record on the given the field name.</source>
          <target state="translated">与えられたフィールド名に新しいリンクレコードを設定することで、現在のレコードを変異させます。</target>
        </trans-unit>
        <trans-unit id="eadad1577753ee37f1c2b694617c261c6134b034" translate="yes" xml:space="preserve">
          <source>Mutates the current record by setting a new set of linked records on the given the field name.</source>
          <target state="translated">与えられたフィールド名にリンクされたレコードの新しいセットを設定することで、現在のレコードを変異させます。</target>
        </trans-unit>
        <trans-unit id="e494f6c0a48343de5c18f2dbf8649d300cc34c93" translate="yes" xml:space="preserve">
          <source>Mutates the current record by setting a new value on the specified field. Returns the mutated record.</source>
          <target state="translated">指定したフィールドに新しい値を設定することで、現在のレコードを変異させます。変異したレコードを返します。</target>
        </trans-unit>
        <trans-unit id="13bcc5c25bae00735d267b69807a37eb90d90472" translate="yes" xml:space="preserve">
          <source>Mutation</source>
          <target state="translated">Mutation</target>
        </trans-unit>
        <trans-unit id="c55f198bc8c7844e5e05f72964532f5dace071a0" translate="yes" xml:space="preserve">
          <source>Mutation props</source>
          <target state="translated">変異の小道具</target>
        </trans-unit>
        <trans-unit id="00a7fb731451c41a484b7591ece27f55c474ec0e" translate="yes" xml:space="preserve">
          <source>Mutations</source>
          <target state="translated">Mutations</target>
        </trans-unit>
        <trans-unit id="9d2e9b27d80bdf1627930a58bb10705ab9b7d295" translate="yes" xml:space="preserve">
          <source>Mutations with optimistic updates and the ability to update the cache with arbitrary logic.</source>
          <target state="translated">楽観的な更新と、任意のロジックでキャッシュを更新する能力を持つ突然変異。</target>
        </trans-unit>
        <trans-unit id="731fdeead88e01d93d0976eb789d77d6c8ba6428" translate="yes" xml:space="preserve">
          <source>Mutator configuration</source>
          <target state="translated">変異子の構成</target>
        </trans-unit>
        <trans-unit id="aeecae05e67a82b3d9ddc32f18bafb250167d7b8" translate="yes" xml:space="preserve">
          <source>NODE_DELETE</source>
          <target state="translated">NODE_DELETE</target>
        </trans-unit>
        <trans-unit id="bef32b44309c819256ef91505f3ce46153114806" translate="yes" xml:space="preserve">
          <source>Nested Routes</source>
          <target state="translated">入れ子になったルート</target>
        </trans-unit>
        <trans-unit id="67269d974acb388f118a96d5b0eb90541c783c5f" translate="yes" xml:space="preserve">
          <source>Nested routes with Relay data dependencies introduce an additional complication. While it's possible to render a &lt;code&gt;QueryRenderer&lt;/code&gt; per route, doing so will lead to request waterfalls in the general case where parent routes do not render their child routes until the data for those parent routes are available. This generally leads to an unnecessary additional delay in loading the data for the page, but may be acceptable for small applications or for applications with shallow route trees.</source>
          <target state="translated">リレーデータに依存するネストされたルートは、さらに複雑になります。ルートごとに &lt;code&gt;QueryRenderer&lt;/code&gt; をレンダリングすることは可能ですが、そうすることで、親ルートのデータが利用可能になるまで親ルートが子ルートをレンダリングしない一般的なケースで、リクエストウォーターフォールが発生します。これは一般に、ページのデータのロードで不必要な追加の遅延につながりますが、小さなアプリケーションや浅いルートツリーを使用するアプリケーションでは許容できる場合があります。</target>
        </trans-unit>
        <trans-unit id="72e403f095e27b7f00c62a3bd59aa377165b5a4c" translate="yes" xml:space="preserve">
          <source>Network Layer</source>
          <target state="translated">ネットワーク層</target>
        </trans-unit>
        <trans-unit id="87869155f5f3484fd0f094292d35a709172baa8a" translate="yes" xml:space="preserve">
          <source>Network layer</source>
          <target state="translated">ネットワーク層</target>
        </trans-unit>
        <trans-unit id="f41f095614dba0f32736c3af7fc6b7b54e8b4b7f" translate="yes" xml:space="preserve">
          <source>Never mutate &lt;code&gt;this.props.relay.variables&lt;/code&gt; directly as it will not trigger data to be fetched properly. Treat &lt;code&gt;this.props.relay.variables&lt;/code&gt; as if it were immutable, just like props.</source>
          <target state="translated">&lt;code&gt;this.props.relay.variables&lt;/code&gt; を直接変更しないでください。データが適切にフェッチされなくなります。 &lt;code&gt;this.props.relay.variables&lt;/code&gt; を、プロップのように不変であるかのように扱います。</target>
        </trans-unit>
        <trans-unit id="a945aa9cbd03a748373e539cadd72f60595b9951" translate="yes" xml:space="preserve">
          <source>New in Relay Modern</source>
          <target state="translated">リレーモダンの新作</target>
        </trans-unit>
        <trans-unit id="34d3ac7ad9c7ff0b33bb48c822077feedfac1008" translate="yes" xml:space="preserve">
          <source>Next, install the compiler (typically as a &lt;code&gt;devDependency&lt;/code&gt;):</source>
          <target state="translated">次に、コンパイラーをインストールします（通常は &lt;code&gt;devDependency&lt;/code&gt; として）。</target>
        </trans-unit>
        <trans-unit id="0a3100d6aa2ad29924f0f56bdda1c226229ea566" translate="yes" xml:space="preserve">
          <source>Next, it will &lt;code&gt;subscribe()&lt;/code&gt; using this snapshot in order to be notified of any changes - see the above diagram for &lt;code&gt;publish()&lt;/code&gt; and &lt;code&gt;notify()&lt;/code&gt;.</source>
          <target state="translated">次に、変更が通知されるように、このスナップショットを使用して &lt;code&gt;subscribe()&lt;/code&gt; します。publish &lt;code&gt;publish()&lt;/code&gt; と &lt;code&gt;notify()&lt;/code&gt; については上の図を参照してください。</target>
        </trans-unit>
        <trans-unit id="b11d6766a232735ae2588359ce0e697727bb4a84" translate="yes" xml:space="preserve">
          <source>Next, let's create a file in &lt;code&gt;./js/mutations/CheckHidingSpotForTreasureMutation.js&lt;/code&gt; and create subclass of &lt;code&gt;Relay.Mutation&lt;/code&gt; called &lt;code&gt;CheckHidingSpotForTreasureMutation&lt;/code&gt; to hold our mutation implementation:</source>
          <target state="translated">次に、。 &lt;code&gt;./js/mutations/CheckHidingSpotForTreasureMutation.js&lt;/code&gt; / mutations / CheckHidingSpotForTreasureMutation.jsにファイルを作成し、ミューテーション実装を保持するために、 &lt;code&gt;Relay.Mutation&lt;/code&gt; と呼ばれる &lt;code&gt;CheckHidingSpotForTreasureMutation&lt;/code&gt; サブクラスを作成します。</target>
        </trans-unit>
        <trans-unit id="8d0415201da41a689310dea9dfd9de53cb8630b3" translate="yes" xml:space="preserve">
          <source>Next, let's define a node interface and type. We only need to provide a way for Relay to map from an object to the GraphQL type associated with that object, and from a global ID to the object it points to:</source>
          <target state="translated">次に、ノードのインターフェイスと型を定義しましょう。必要なのは、オブジェクトからそのオブジェクトに関連付けられた GraphQL 型へのマッピングと、グローバル ID からそのオブジェクトが指すオブジェクトへのマッピングだけです。</target>
        </trans-unit>
        <trans-unit id="adc67eef09450d30c9ae37eeb2376e191eb49c0d" translate="yes" xml:space="preserve">
          <source>Next, let's define our game and hiding spot types, and the fields that are available on each.</source>
          <target state="translated">次に、ゲームと隠れ場所のタイプと、それぞれで利用できるフィールドを定義してみましょう。</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="5b3016b7b65c75156425ea4affe66b9292dbd049" translate="yes" xml:space="preserve">
          <source>No Routing</source>
          <target state="translated">ルーティングなし</target>
        </trans-unit>
        <trans-unit id="2daa1a58378d3c4f7ceb9d6531c197c5be4d948b" translate="yes" xml:space="preserve">
          <source>Non-React functions can also take advantage of data masking. A fragment can be defined with the &lt;code&gt;@inline&lt;/code&gt; directive and stored in a local variable. The non-React function can then &quot;unmask&quot; the data using the &lt;code&gt;readInlineData&lt;/code&gt; function.</source>
          <target state="translated">Non-React関数もデータマスキングを利用できます。フラグメントは &lt;code&gt;@inline&lt;/code&gt; ディレクティブで定義し、ローカル変数に格納できます。非React関数は、 &lt;code&gt;readInlineData&lt;/code&gt; 関数を使用してデータを「マスク解除」できます。</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="8591e7ed2e6e97908da94c56b629b41aa4eb0746" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;graphql&lt;/code&gt; template tags are &lt;strong&gt;never executed at runtime&lt;/strong&gt;. Instead, they are compiled ahead of time by the &lt;a href=&quot;#relay-compiler&quot;&gt;Relay Compiler&lt;/a&gt; into generated artifacts that live alongside your source code, and which Relay requires to operate at runtime. The &lt;a href=&quot;installation-and-setup#setup-babel-plugin-relay&quot;&gt;Relay Babel plugin&lt;/a&gt; will then convert the &lt;code&gt;graphql&lt;/code&gt; literals in your code into &lt;code&gt;require()&lt;/code&gt; calls for the generated files.</source>
          <target state="translated">&lt;code&gt;graphql&lt;/code&gt; テンプレートタグは&lt;strong&gt;実行時に実行されないことに&lt;/strong&gt;注意してください。代わりに、&lt;a href=&quot;#relay-compiler&quot;&gt;Relayコンパイラ&lt;/a&gt;によって事前にコンパイルされて、ソースコードと一緒に存在し、Relayが実行時に動作する必要がある生成されたアーティファクトになります。次に、&lt;a href=&quot;installation-and-setup#setup-babel-plugin-relay&quot;&gt;Relay Babelプラグイン&lt;/a&gt;は、コード内の &lt;code&gt;graphql&lt;/code&gt; リテラルを、生成されたファイルの &lt;code&gt;require()&lt;/code&gt; 呼び出しに変換します。</target>
        </trans-unit>
        <trans-unit id="ded70becacd440a8a5293ee572a86c4c58319833" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; will continue to be false.</source>
          <target state="translated">&lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; は引き続きfalseであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7c2002c29e0fca7efc2e3f32bc61fca5000503d9" translate="yes" xml:space="preserve">
          <source>Note that it is &lt;em&gt;highly&lt;/em&gt; recommended that &lt;code&gt;Relay.Container&lt;/code&gt;s define their own fragments and avoid sharing inline &lt;code&gt;var fragment = Relay.QL...&lt;/code&gt; values between containers or files. If you find yourself wanting to share inline fragments, it's likely a sign that it's time to refactor and introduce a new container.</source>
          <target state="translated">&lt;code&gt;Relay.Container&lt;/code&gt; が独自のフラグメントを定義し、コンテナーまたはファイル間でインライン &lt;code&gt;var fragment = Relay.QL...&lt;/code&gt; 値を共有しないようにすることを&lt;em&gt;強く&lt;/em&gt;お勧めします。インラインフラグメントを共有したい場合は、リファクタリングして新しいコンテナを導入する時期が来ている可能性があります。</target>
        </trans-unit>
        <trans-unit id="0e023c69475bbeb6872432af3864e74233382b71" translate="yes" xml:space="preserve">
          <source>Note that these modules are &lt;em&gt;loosely coupled&lt;/em&gt;. For example, the compiler emits representations of queries in a well-defined format that the runtime consumes (the &quot;Concrete&quot; node interfaces in &lt;code&gt;RelayConcreteNode&lt;/code&gt;), such that the compiler implementation can be swapped out if desired. React/Relay relies only on the well-documented public interface of the runtime, such that the actual implementation can be swapped out (in fact, we've upgraded the classic Relay core to also implement this same API). We hope that this loose coupling will allow the community to explore new use-cases such as the development of specialized product APIs using the Relay runtime or integrations of the runtime with view libraries other than React.</source>
          <target state="translated">これらのモジュールは&lt;em&gt;疎結合で&lt;/em&gt;あることに注意してください。たとえば、コンパイラは、ランタイムが消費する明確に定義された形式（ &lt;code&gt;RelayConcreteNode&lt;/code&gt; の「Concrete」ノードインターフェイス）でクエリの表現を出力するため、必要に応じてコンパイラの実装をスワップアウトできます。 React / Relayは、ランタイムの十分に文書化されたパブリックインターフェイスのみに依存しているため、実際の実装をスワップアウトできます（実際、これと同じAPIを実装するように従来のRelayコアをアップグレードしました）。この疎結合により、コミュニティが、Relayランタイムを使用した特殊な製品APIの開発や、ランタイムとReact以外のビューライブラリとの統合などの新しいユースケースを探求できるようになることを願っています。</target>
        </trans-unit>
        <trans-unit id="6251d7c444bd5ea65a8e620b067b7ace419f0985" translate="yes" xml:space="preserve">
          <source>Note that this approach requires &lt;em&gt;n+1&lt;/em&gt; requests to the server: 1 to fetch the list, and &lt;em&gt;n&lt;/em&gt; to fetch each item. With GraphQL we can fetch the same data in a single network request to the server (without creating a custom endpoint that we'd then have to maintain):</source>
          <target state="translated">このアプローチでは、サーバーへの&lt;em&gt;n + 1&lt;/em&gt;リクエストが必要であることに注意してください。リストをフェッチするには1、各アイテムをフェッチするには&lt;em&gt;n&lt;/em&gt;です。GraphQLを使用すると、サーバーへの単一のネットワーク要求で同じデータをフェッチできます（その後、維持する必要があるカスタムエンドポイントを作成する必要はありません）。</target>
        </trans-unit>
        <trans-unit id="41a9a091d399394a5944c5c0a394fb244440e004" translate="yes" xml:space="preserve">
          <source>Note that this is a basic example to help you get started. This example could be extended with additional features such as request/response caching (enabled e.g. when &lt;code&gt;cacheConfig.force&lt;/code&gt; is false) and uploading form data for mutations (the &lt;code&gt;uploadables&lt;/code&gt; parameter).</source>
          <target state="translated">これは、始めるのに役立つ基本的な例であることに注意してください。この例は、リクエスト/レスポンスキャッシング（たとえば &lt;code&gt;cacheConfig.force&lt;/code&gt; がfalseの場合に有効）やミューテーション用のフォームデータの &lt;code&gt;uploadables&lt;/code&gt; （uploadablesパラメーター）などの追加機能で拡張できます。</target>
        </trans-unit>
        <trans-unit id="18e979539b69c286787704dcc6ebc81753f2b6c9" translate="yes" xml:space="preserve">
          <source>Note that this normalized cache structure allows overlapping results to be cached without duplication. Each record is stored once regardless of how it is fetched. Let's return to the earlier example of inconsistent data and see how this cache helps in that scenario.</source>
          <target state="translated">この正規化されたキャッシュ構造により、重複する結果が重複せずにキャッシュされることに注意してください。各レコードは、どのようにフェッチされたかに関係なく一度だけ保存されます。先ほどの矛盾したデータの例に戻って、このキャッシュがそのシナリオでどのように役立つかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="6a3998469edc7ffa18da69953898b4c848c54481" translate="yes" xml:space="preserve">
          <source>Note that this solution will also work for &lt;em&gt;writes&lt;/em&gt;: any update to the cache will notify the affected views, and writes are just another thing that updates the cache.</source>
          <target state="translated">このソリューションは&lt;em&gt;書き込みで&lt;/em&gt;も機能することに注意してください。キャッシュを更新すると、影響を受けるビューに通知されます。書き込みは、キャッシュを更新するもう1つの方法です。</target>
        </trans-unit>
        <trans-unit id="ac8054c10594bdd95e89a5e8a8673034de9d793b" translate="yes" xml:space="preserve">
          <source>Note that when composing fragments, the type of the composed fragment must match the field on the parent in which it is embedded. For example, it wouldn't make sense to embed a fragment of type &lt;code&gt;Story&lt;/code&gt; into a parent's field of type &lt;code&gt;User&lt;/code&gt;. Relay and GraphQL will provide helpful error messages if you get this wrong (and if they aren't helpful, let us know!).</source>
          <target state="translated">フラグメントを作成する場合、作成されたフラグメントのタイプは、それが埋め込まれている親のフィールドと一致する必要があることに注意してください。たとえば、タイプ &lt;code&gt;Story&lt;/code&gt; のフラグメントをタイプ &lt;code&gt;User&lt;/code&gt; の親のフィールドに埋め込むことは意味がありません。RelayとGraphQLは、これを間違えた場合に役立つエラーメッセージを提供します（役に立たない場合はお知らせください！）。</target>
        </trans-unit>
        <trans-unit id="0cb3b8bd044c603524ff2409189dcccf98b3f39b" translate="yes" xml:space="preserve">
          <source>Note: Determining variable values at runtime</source>
          <target state="translated">注意:実行時の変数値の決定</target>
        </trans-unit>
        <trans-unit id="6eb6c807aac98e74096f64d7f8585ee557b93a39" translate="yes" xml:space="preserve">
          <source>Note: In most cases, it is possible to rely on the default singleton instance of the environment, which is exposed as &lt;code&gt;Relay.Store&lt;/code&gt;.</source>
          <target state="translated">注：ほとんどの場合、 &lt;code&gt;Relay.Store&lt;/code&gt; として公開されている環境のデフォルトのシングルトンインスタンスに依存することが可能です。</target>
        </trans-unit>
        <trans-unit id="06bd725e4a6c3e529d4b86297fa0d602b821e04c" translate="yes" xml:space="preserve">
          <source>Note: This method may only be called once per instance.</source>
          <target state="translated">注意:このメソッドは、インスタンスごとに一度しか呼び出すことができません。</target>
        </trans-unit>
        <trans-unit id="a0e48b33fadd08f907218ada431ccb61eb2d094e" translate="yes" xml:space="preserve">
          <source>Notice that it immediately executes the next task. Relay manages the order of tasks to ensure a proper order of operations - the scheduler can't skip or reorder tasks, only decide when to execute the next one.</source>
          <target state="translated">すぐに次のタスクを実行することに注目してください。スケジューラはタスクを飛ばしたり順番を変えたりすることはできず、次のタスクを実行するタイミングを決めるだけです。</target>
        </trans-unit>
        <trans-unit id="c79f05d35d0a7eb36506bd3ab33a1f2773cfa554" translate="yes" xml:space="preserve">
          <source>Notice that the cursor is a base64 string. That's the pattern from earlier: the server is reminding us that this is an opaque string. We can pass this string back to the server as the &lt;code&gt;after&lt;/code&gt; argument to the &lt;code&gt;ships&lt;/code&gt; field, which will let us ask for the next three ships after the last one in the previous result:</source>
          <target state="translated">カーソルがbase64文字列であることに注意してください。これは、以前のパターンです。サーバーは、これが不透明な文字列であることを通知しています。この文字列を、 &lt;code&gt;ships&lt;/code&gt; フィールドの &lt;code&gt;after&lt;/code&gt; 引数としてサーバーに返すことができます。これにより、前の結果の最後の1つに続く3つの発送を要求できます。</target>
        </trans-unit>
        <trans-unit id="3aca59c767d5ed557222dbb5b8557469ae3a4a7f" translate="yes" xml:space="preserve">
          <source>Notice that we're querying for data that &lt;em&gt;may&lt;/em&gt; have changed as a result of the mutation. An obvious question is: why can't the server just tell us what changed? The answer is: it's complicated. GraphQL abstracts over &lt;em&gt;any&lt;/em&gt; data storage layer (or an aggregation of multiple sources), and works with any programming language. Furthermore, the goal of GraphQL is to provide data in a form that is useful to product developers building a view.</source>
          <target state="translated">変更の結果として変更された&lt;em&gt;可能性のある&lt;/em&gt;データをクエリしていることに注意してください。明らかな質問です：なぜサーバーは何が変更されたかを私たちに伝えることができないのですか？答えは、複雑です。GraphQLは、&lt;em&gt;任意の&lt;/em&gt;データストレージレイヤー（または複数のソースの集約）を抽象化し、任意のプログラミング言語で動作します。さらに、GraphQLの目標は、ビューを構築する製品開発者に役立つ形式でデータを提供することです。</target>
        </trans-unit>
        <trans-unit id="056ee5771da852e979294339f6d61f3371dc9784" translate="yes" xml:space="preserve">
          <source>Now Relay will both fetch the larger photo size &lt;em&gt;and&lt;/em&gt;&lt;code&gt;Child&lt;/code&gt; will know to render it.</source>
          <target state="translated">これで、Relayは両方とも大きい写真サイズ&lt;em&gt;を&lt;/em&gt;フェッチし、 &lt;code&gt;Child&lt;/code&gt; はそれをレンダリングすることを認識します。</target>
        </trans-unit>
        <trans-unit id="359fab9a105cb172833a57b904a4f78ae21bf6b3" translate="yes" xml:space="preserve">
          <source>Now Relay will fetch the photo with size 128 - but the &lt;code&gt;Child&lt;/code&gt; container won't magically know about this variable. We have to tell it by passing the variable value as a prop:</source>
          <target state="translated">ここで、Relayはサイズ128の写真をフェッチしますが、 &lt;code&gt;Child&lt;/code&gt; コンテナはこの変数を魔法のように認識しません。変数値を小道具として渡すことでそれを伝える必要があります。</target>
        </trans-unit>
        <trans-unit id="8f4ea81858f10f7f357b3da216fb14eb06c577cc" translate="yes" xml:space="preserve">
          <source>Now let's associate these types with the root query type.</source>
          <target state="translated">それでは、これらの型をルートのクエリ型に関連付けてみましょう。</target>
        </trans-unit>
        <trans-unit id="ee5dbc563862c37bd2eddab0d2faa5a3c1303875" translate="yes" xml:space="preserve">
          <source>Now let's take a closer look at the &lt;code&gt;config&lt;/code&gt;:</source>
          <target state="translated">次に、 &lt;code&gt;config&lt;/code&gt; 詳しく見てみましょう。</target>
        </trans-unit>
        <trans-unit id="c63c75c8f04bcbaded3abd8323247dbc014c15ac" translate="yes" xml:space="preserve">
          <source>Now that we've gone through this tutorial, let's dive into what it means to build a GraphQL client framework and how this compares to clients for more traditional REST systems.</source>
          <target state="translated">ここまででチュートリアルを終えたので、GraphQL クライアントフレームワークを構築する意味と、従来の REST システムのクライアントと比較してみましょう。</target>
        </trans-unit>
        <trans-unit id="3c8e0a4e6791c0f1c68af7b94cb67e9dddbecd93" translate="yes" xml:space="preserve">
          <source>Now we can instantiate a &lt;code&gt;ProfileRoute&lt;/code&gt; that fetches data for user &lt;code&gt;123&lt;/code&gt;:</source>
          <target state="translated">これで、ユーザー &lt;code&gt;123&lt;/code&gt; のデータをフェッチする &lt;code&gt;ProfileRoute&lt;/code&gt; をインスタンス化できます。</target>
        </trans-unit>
        <trans-unit id="d3cbdecefa56176a7edca66548a54ce86a3ed688" translate="yes" xml:space="preserve">
          <source>Now, requests for previously cached data can be answered immediately without making a network request. This is a practical approach to improving the perceived performance of an application. However, this method of caching can cause problems with data consistency.</source>
          <target state="translated">今では、以前にキャッシュされたデータへのリクエストは、ネットワークリクエストを行うことなく、すぐに回答できるようになりました。これは、アプリケーションの知覚されたパフォーマンスを向上させるための実用的なアプローチです。しかし、この方法では、データの一貫性に問題が生じる可能性があります。</target>
        </trans-unit>
        <trans-unit id="c7d436121cc7de83cd8afcc9e5b08145f88e3d72" translate="yes" xml:space="preserve">
          <source>Object Identification</source>
          <target state="translated">オブジェクトの識別</target>
        </trans-unit>
        <trans-unit id="509d0e819f7363f119680482f06c06df5503cfc0" translate="yes" xml:space="preserve">
          <source>On the Relay Container the prop &lt;code&gt;bars&lt;/code&gt; will be an array instead of an object.</source>
          <target state="translated">リレーコンテナでは、プロップ &lt;code&gt;bars&lt;/code&gt; はオブジェクトではなく配列になります。</target>
        </trans-unit>
        <trans-unit id="258ab7d6dd3b683b7bd3f1f1a9e4c26dc064e05d" translate="yes" xml:space="preserve">
          <source>On the other hand, GraphQL &lt;strong&gt;fragments&lt;/strong&gt; declare fields that exist on any arbitrary type. For example, the following fragment fetches the profile picture URI for &lt;em&gt;some&lt;/em&gt;&lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">一方、GraphQL &lt;strong&gt;フラグメント&lt;/strong&gt;は、任意の型に存在するフィールドを宣言します。たとえば、次のフラグメントは、&lt;em&gt;一部の&lt;/em&gt; &lt;code&gt;User&lt;/code&gt; のプロフィール写真URIをフェッチします。</target>
        </trans-unit>
        <trans-unit id="e77ad76d86248c3f5b3430ab7a50cf954c824781" translate="yes" xml:space="preserve">
          <source>Once a few or all of your views are using &lt;code&gt;QueryRenderer&lt;/code&gt;, &lt;code&gt;Store&lt;/code&gt; from &lt;code&gt;'react-relay/classic'&lt;/code&gt; could be replaced with a &lt;code&gt;RelayModernEnvironment&lt;/code&gt;. Keep in mind that &lt;code&gt;RelayModernEnvironment&lt;/code&gt; and &lt;code&gt;Store&lt;/code&gt; do not share any data. You might want to hold off on this step until views that have significant data overlap can be switched over at the same time. This step is what unlocks the perf wins for your app. Apps using the &lt;code&gt;RelayModernEnvironment&lt;/code&gt; get to send persisted query IDs instead of the full query strings to the server, as well as much more optimized data normalizing and processing.</source>
          <target state="translated">いくつかまたはすべてのビューが使用されると &lt;code&gt;QueryRenderer&lt;/code&gt; 、 &lt;code&gt;Store&lt;/code&gt; から &lt;code&gt;'react-relay/classic'&lt;/code&gt; 置き換えることができ &lt;code&gt;RelayModernEnvironment&lt;/code&gt; 。 &lt;code&gt;RelayModernEnvironment&lt;/code&gt; と &lt;code&gt;Store&lt;/code&gt; はデータを共有しないことに注意してください。重要なデータのオーバーラップがあるビューを同時に切り替えることができるまで、このステップを保留することをお勧めします。このステップは、アプリのパフォーマンスを向上させるものです。 &lt;code&gt;RelayModernEnvironment&lt;/code&gt; を使用するアプリは、完全なクエリ文字列の代わりに永続化されたクエリIDをサーバーに送信し、さらに最適化されたデータの正規化と処理を行います。</target>
        </trans-unit>
        <trans-unit id="aa26441141ed7039f7d3b90dda06bb5985300871" translate="yes" xml:space="preserve">
          <source>Once all the components and mutations have been converted to use the Relay Modern APIs, convert to using &lt;code&gt;QueryRenderer&lt;/code&gt; instead of using &lt;code&gt;Relay.Renderer&lt;/code&gt; or &lt;code&gt;Relay.RootContainer&lt;/code&gt;. You may supply &lt;code&gt;Store&lt;/code&gt; from &lt;code&gt;'react-relay/classic'&lt;/code&gt; as the &lt;code&gt;environment&lt;/code&gt; for most cases.</source>
          <target state="translated">すべてのコンポーネントとミュー &lt;code&gt;QueryRenderer&lt;/code&gt; がRelay Modern APIを使用するように変換されたら、 &lt;code&gt;Relay.Renderer&lt;/code&gt; または &lt;code&gt;Relay.RootContainer&lt;/code&gt; を使用する代わりに、QueryRendererを使用するように変換します。ほとんどの場合、 &lt;code&gt;environment&lt;/code&gt; として &lt;code&gt;'react-relay/classic'&lt;/code&gt; から &lt;code&gt;Store&lt;/code&gt; を提供できます。</target>
        </trans-unit>
        <trans-unit id="526a2470452cfa759c69b07a4cdac3145513395b" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;error&lt;/code&gt; set to an &lt;code&gt;Error&lt;/code&gt; object.</source>
          <target state="translated">で一度 &lt;code&gt;error&lt;/code&gt; に設定 &lt;code&gt;Error&lt;/code&gt; オブジェクト。</target>
        </trans-unit>
        <trans-unit id="d30a28f0a20b5fda3d127c2ba900c1393a0c802c" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; set to true, but &lt;code&gt;stale&lt;/code&gt; set to false.</source>
          <target state="translated">一度、 &lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; をtrueに設定すると、 &lt;code&gt;stale&lt;/code&gt; はfalseに設定されます。</target>
        </trans-unit>
        <trans-unit id="c510443cbc7ffd35f869abc94218360943f66d9e" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; set to true.</source>
          <target state="translated">で一度 &lt;code&gt;ready&lt;/code&gt; と &lt;code&gt;done&lt;/code&gt; trueに設定します。</target>
        </trans-unit>
        <trans-unit id="9b048c01bc7fa82617b39cb08502f943e54b8d4a" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt; set to false.</source>
          <target state="translated">で一度 &lt;code&gt;ready&lt;/code&gt; falseに設定します。</target>
        </trans-unit>
        <trans-unit id="fe545c0159939d91c25a89db650c07bece33f470" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt;, &lt;code&gt;done&lt;/code&gt;, and &lt;code&gt;stale&lt;/code&gt; set to true.</source>
          <target state="translated">いったん &lt;code&gt;ready&lt;/code&gt; 、 &lt;code&gt;done&lt;/code&gt; 、 &lt;code&gt;stale&lt;/code&gt; がtrueに設定されると。</target>
        </trans-unit>
        <trans-unit id="c8f5f6a359004092335c67ac77552d54cac29a5a" translate="yes" xml:space="preserve">
          <source>Once you have an environment, you can pass it in to your &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt; instance, or into mutations via the &lt;code&gt;commitUpdate&lt;/code&gt; function (see &quot;&lt;a href=&quot;mutations&quot;&gt;Mutations&lt;/a&gt;&quot;).</source>
          <target state="translated">環境を作成したら、それを&lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt;インスタンスに渡すか、 &lt;code&gt;commitUpdate&lt;/code&gt; 関数を介して&lt;a href=&quot;mutations&quot;&gt;ミューテーションに&lt;/a&gt;渡すことができます（「ミューテーション」を参照）。</target>
        </trans-unit>
        <trans-unit id="3445237f2d0762c974ff895551ac18ecb7b0fd39" translate="yes" xml:space="preserve">
          <source>One of the big ideas behind the new API is that execution can be made a lot more efficient by moving work ahead-of-time: from the runtime of the app to the build-time. As such, changes to GraphQL fragments require a build step to regenerate a set of artifacts. More on &lt;a href=&quot;relay-compiler&quot;&gt;the Relay Compiler&lt;/a&gt;.</source>
          <target state="translated">新しいAPIの背後にある大きなアイデアの1つは、事前に作業を移動することで実行を大幅に効率化できることです。これは、アプリのランタイムからビルド時までです。そのため、GraphQLフラグメントを変更するには、一連のアーティファクトを再生成するためのビルドステップが必要です。&lt;a href=&quot;relay-compiler&quot;&gt;リレーコンパイラの&lt;/a&gt;詳細。</target>
        </trans-unit>
        <trans-unit id="e9e3088ad7030f31124174e1ea72f79d6e9860c5" translate="yes" xml:space="preserve">
          <source>One of the main goals of the compiler is to provide a consistent platform for writing tools that transform or optimize GraphQL. This includes the ability to experiment with new directives by transforming them away at compile time. Transform functions should typically perform a single type of modification - it's expected that an app will have multiple transforms configured in the compiler instance.</source>
          <target state="translated">コンパイラの主な目的の一つは、GraphQLを変換したり最適化したりするツールを書くための一貫したプラットフォームを提供することです。これには、コンパイル時に変換して新しいディレクティブを試す機能も含まれます。トランスフォーム関数は通常、単一のタイプの変更を実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="ad501b8fa6c8a155c72db2494b37eb05a27af8e5" translate="yes" xml:space="preserve">
          <source>One solution is to have a root component fetch the data for all its children. However, this would introduce coupling: every change to a component would require changing &lt;em&gt;any&lt;/em&gt; root component that might render it, and often some components between it and the root. This coupling could mean a greater chance for bugs and slow the pace of development. Ultimately, this approach doesn't take advantage of React's component model. The natural place for specifying data-dependencies was in &lt;em&gt;components&lt;/em&gt;.</source>
          <target state="translated">1つの解決策は、ルートコンポーネントにすべての子のデータをフェッチさせることです。しかし、これはカップリングをご紹介します：コンポーネントへのすべての変更は、変更が必要となる&lt;em&gt;任意の&lt;/em&gt;それをレンダリングする可能性があるルート・コンポーネントを、それと根の間でしばしばいくつかのコンポーネント。この結合により、バグが発生する可能性が高まり、開発のペースが遅くなる可能性があります。結局のところ、このアプローチはReactのコンポーネントモデルを利用していません。データの依存関係を指定するための自然な場所は、&lt;em&gt;コンポーネント&lt;/em&gt;でした。</target>
        </trans-unit>
        <trans-unit id="6b5a7ba3ecdf80b9b9c9285e7c15e081d2c4cfd9" translate="yes" xml:space="preserve">
          <source>One thing is left in the example above &amp;mdash; implementing &lt;code&gt;setSize()&lt;/code&gt;, which should change the photo's size when the slider values changes. In addition to passing the results of each query to the component, Relay also provides a &lt;code&gt;relay&lt;/code&gt; prop that has Relay-specific methods and metadata. These include &lt;code&gt;variables&lt;/code&gt; &amp;mdash; the active variables used to fetch the current &lt;code&gt;props&lt;/code&gt; &amp;mdash; and &lt;code&gt;setVariables()&lt;/code&gt; &amp;mdash; a callback that can be used to request data for different variable values.</source>
          <target state="translated">上記の例には1つ残っています &lt;code&gt;setSize()&lt;/code&gt; 実装すると、スライダーの値が変化したときに写真のサイズが変化します。コンポーネントに各クエリの結果を渡すことに加えて、リレーも提供 &lt;code&gt;relay&lt;/code&gt; リレー特定の方法およびメタデータを有するプロペラを。これらには、 &lt;code&gt;variables&lt;/code&gt; &lt;code&gt;setVariables()&lt;/code&gt; 現在の &lt;code&gt;props&lt;/code&gt; をフェッチするために使用されるアクティブな変数）およびsetVariables（） &amp;mdash;さまざまな変数値のデータを要求するために使用できるコールバックが含まれます。</target>
        </trans-unit>
        <trans-unit id="43ec0f0f8cb785cd4021b95098b6011da01043b4" translate="yes" xml:space="preserve">
          <source>Only fields specified by these fragments will be populated in &lt;code&gt;this.props&lt;/code&gt; when the component is rendered. This ensures that there are no implicit dependencies from a component on its parent component or any child components.</source>
          <target state="translated">これらのフラグメントで指定されたフィールドのみが、コンポーネントのレンダリング時に &lt;code&gt;this.props&lt;/code&gt; に入力されます。これにより、親コンポーネントまたは子コンポーネント上のコンポーネントからの暗黙的な依存関係がなくなります。</target>
        </trans-unit>
        <trans-unit id="cda4387bc6920d739a4c52a2c0a31c33103f5562" translate="yes" xml:space="preserve">
          <source>Optimistic Updates</source>
          <target state="translated">楽観的なアップデート</target>
        </trans-unit>
        <trans-unit id="544901021486ff794813761281a30a85a9ea2561" translate="yes" xml:space="preserve">
          <source>Optimistic updates</source>
          <target state="translated">楽観的なアップデート</target>
        </trans-unit>
        <trans-unit id="75e97d82c2ab23fae3c5ae0de671aad8aaab254b" translate="yes" xml:space="preserve">
          <source>Optimistically updating the UI while waiting for the server to respond to mutations.</source>
          <target state="translated">サーバーが突然変異に反応するのを待っている間、楽観的にUIを更新します。</target>
        </trans-unit>
        <trans-unit id="a30573ebcc5462272b8ba6828cf0b15e88284677" translate="yes" xml:space="preserve">
          <source>Option 1: Re-fetch everything that the app has ever queried. Even though only a small subset of this data will actually change, we'll still have to wait for the server to execute the &lt;em&gt;entire&lt;/em&gt; query, wait to download the results, and wait to process them again. This is very inefficient.</source>
          <target state="translated">オプション1：アプリがこれまでにクエリしたすべてのものを再フェッチします。このデータの小さなサブセットのみが実際に変更される場合でも、サーバーがクエリ&lt;em&gt;全体&lt;/em&gt;を実行するのを待ち、結果をダウンロードして、再度処理するのを待つ必要があります。これは非常に非効率的です。</target>
        </trans-unit>
        <trans-unit id="7c7f0ed28de8faafd0afd103f17d025324ed7cc5" translate="yes" xml:space="preserve">
          <source>Option 2: Re-fetch only the queries required by actively rendered views. This is a slight improvement over option 1. However, cached data that &lt;em&gt;isn't&lt;/em&gt; currently being viewed won't be updated. Unless this data is somehow marked as stale or evicted from the cache subsequent queries will read outdated information.</source>
          <target state="translated">オプション2：アクティブにレンダリングされたビューで必要なクエリのみを再フェッチします。これは、オプション1に比べてわずかに改善されています。ただし、現在表示されてい&lt;em&gt;ない&lt;/em&gt;キャッシュデータ&lt;em&gt;は&lt;/em&gt;更新されません。このデータがなんらかの方法で失効としてマークされていないか、キャッシュから削除されていない限り、後続のクエリは古い情報を読み取ります。</target>
        </trans-unit>
        <trans-unit id="1fc54acb388aaf56464909787927f5c9cc6c305b" translate="yes" xml:space="preserve">
          <source>Option 3: Re-fetch a fixed list of fields that &lt;em&gt;may&lt;/em&gt; change after the mutation. We'll call this list a &lt;strong&gt;fat query&lt;/strong&gt;. We found this to also be inefficient because typical applications only render a subset of the fat query, but this approach would require fetching all of those fields.</source>
          <target state="translated">オプション3：変更後に変更される&lt;em&gt;可能性&lt;/em&gt;があるフィールドの固定リストを再フェッチします。このリストを&lt;strong&gt;ファットクエリ&lt;/strong&gt;と呼び&lt;strong&gt;ます&lt;/strong&gt;。通常のアプリケーションはファットクエリのサブセットのみをレンダリングするため、これも非効率的であることがわかりましたが、このアプローチではこれらのフィールドをすべてフェッチする必要があります。</target>
        </trans-unit>
        <trans-unit id="4be11d572e3b53b4fc22dae76efc2d670f4be4bb" translate="yes" xml:space="preserve">
          <source>Option 4 (Relay): Re-fetch the intersection of what may change (the fat query) and the data in the cache. In addition to the cache of data Relay also remembers the queries used to fetch each item. These are called &lt;strong&gt;tracked queries&lt;/strong&gt;. By intersecting the tracked and fat queries, Relay can query exactly the set of information the application needs to update and nothing more.</source>
          <target state="translated">オプション4（リレー）：変更される可能性のあるもの（ファットクエリ）とキャッシュ内のデータの共通部分を再フェッチします。データのキャッシュに加えて、Relayは各アイテムのフェッチに使用されたクエリも記憶しています。これらは&lt;strong&gt;追跡クエリ&lt;/strong&gt;と呼ば&lt;strong&gt;れ&lt;/strong&gt;ます。追跡されたクエリとファットクエリを交差させることで、Relayはアプリケーションが更新する必要がある一連の情報を正確にクエリできます。</target>
        </trans-unit>
        <trans-unit id="6718713de12ca02e84822e47bd7f3094f39d3c0a" translate="yes" xml:space="preserve">
          <source>Optionally install globally</source>
          <target state="translated">必要に応じてグローバルにインストール</target>
        </trans-unit>
        <trans-unit id="b30829da1c673e16f6adae2f5da589d2b2d65970" translate="yes" xml:space="preserve">
          <source>Optionally, follow up with a call to &lt;code&gt;commit()&lt;/code&gt; to send the mutation to the server.</source>
          <target state="translated">必要に応じて、 &lt;code&gt;commit()&lt;/code&gt; を呼び出してサーバーに変異を送信します。</target>
        </trans-unit>
        <trans-unit id="2495cf5d8b7fcd84a593bb8a6590867f01c41c54" translate="yes" xml:space="preserve">
          <source>Optionally, if the field takes arguments, you can pass a bag of &lt;code&gt;variables&lt;/code&gt;.</source>
          <target state="translated">オプションで、フィールドが引数を取る場合は、 &lt;code&gt;variables&lt;/code&gt; バッグを渡すことができます。</target>
        </trans-unit>
        <trans-unit id="59edbb8c9de82b3a53b356bdf14020ccb99fbd8d" translate="yes" xml:space="preserve">
          <source>Optionally, if the linked record takes arguments, you can pass a bag of &lt;code&gt;variables&lt;/code&gt; as well.</source>
          <target state="translated">オプションで、リンクされたレコードが引数を取る場合は、 &lt;code&gt;variables&lt;/code&gt; バッグを渡すこともできます。</target>
        </trans-unit>
        <trans-unit id="3a603142c92a8b820560fb3bf1b12553420c3f4e" translate="yes" xml:space="preserve">
          <source>Optionally, precede with a call to &lt;code&gt;applyOptimistic()&lt;/code&gt; to apply an update optimistically to the store.</source>
          <target state="translated">必要に応じて、 &lt;code&gt;applyOptimistic()&lt;/code&gt; を呼び出して、ストアに更新を楽観的に適用します。</target>
        </trans-unit>
        <trans-unit id="ae17e1897a8cc791f789d5b34d32406b1c727d64" translate="yes" xml:space="preserve">
          <source>Or this way, with the same results:</source>
          <target state="translated">あるいはこのようにして、同じ結果を得ることができます。</target>
        </trans-unit>
        <trans-unit id="fb12379af7dcaf01e91c059811ab5e2548a2134c" translate="yes" xml:space="preserve">
          <source>Or, a function that receives the previous set of variables used to query the data, and returns a new set of variables to pass to the &lt;code&gt;refetchQuery&lt;/code&gt; when fetching it from the server.</source>
          <target state="translated">または、データのクエリに使用された以前の変数のセットを受け取り、サーバーから &lt;code&gt;refetchQuery&lt;/code&gt; をフェッチするときにrefetchQueryに渡す新しい変数のセットを返す関数。</target>
        </trans-unit>
        <trans-unit id="50300a6866222e559def812f5df571c9176ba61e" translate="yes" xml:space="preserve">
          <source>Overrides the &lt;a href=&quot;#defaultnetworklayer-static-property&quot;&gt;DefaultNetworkLayer&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#defaultnetworklayer-static-property&quot;&gt;DefaultNetworkLayerを&lt;/a&gt;オーバーライドします。</target>
        </trans-unit>
        <trans-unit id="fd55d4fdc76dc273300987b3c56489168f507c74" translate="yes" xml:space="preserve">
          <source>Overriding Fragment Variables</source>
          <target state="translated">フラグメント変数のオーバーライド</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="100325b8d6de92dc6ff09cd2c078133755bf274f" translate="yes" xml:space="preserve">
          <source>Pagination</source>
          <target state="translated">Pagination</target>
        </trans-unit>
        <trans-unit id="1847eac49f0862bab8cf4f3614ad739655005e7f" translate="yes" xml:space="preserve">
          <source>Pagination Container</source>
          <target state="translated">ページネーションコンテナ</target>
        </trans-unit>
        <trans-unit id="0ca043a41b0b3d0ddc8649acdd7e8b58bdcfa73a" translate="yes" xml:space="preserve">
          <source>Pagination Container is also a &lt;a href=&quot;https://reactjs.org/docs/higher-order-components.html&quot;&gt;higher-order component&lt;/a&gt;, similar to a &lt;a href=&quot;fragment-container&quot;&gt;Fragment Container&lt;/a&gt;, that is designed to simplify the workflow of loading more items in a list &amp;mdash; in many cases, we don't want to fetch all the data at once but lazily load more data. It relies on a GraphQL server exposing connections in a standardized way. For a detailed spec, please check out &lt;a href=&quot;https://relay.dev/graphql/connections.htm&quot;&gt;this page&lt;/a&gt;.</source>
          <target state="translated">Pagination Containerも、&lt;a href=&quot;fragment-container&quot;&gt;Fragment Container&lt;/a&gt;と同様に&lt;a href=&quot;https://reactjs.org/docs/higher-order-components.html&quot;&gt;高次のコンポーネント&lt;/a&gt;であり、リスト内のより多くのアイテムをロードするワークフローを簡素化するように設計されています。多くの場合、一度にすべてのデータをフェッチするのではなく、遅延ロードします。より多くのデータ。これは、標準化された方法で接続を公開するGraphQLサーバーに依存しています。詳細な仕様については、&lt;a href=&quot;https://relay.dev/graphql/connections.htm&quot;&gt;こちらのページをご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b747c351b01284c892ae1864f74451400f8ded9b" translate="yes" xml:space="preserve">
          <source>Pagination Container works in a very similar way to the &lt;a href=&quot;fragment-container&quot;&gt;Fragment Container&lt;/a&gt; in that you also specify the data requirements for a component via GraphQL fragments in the &lt;code&gt;fragmentSpec&lt;/code&gt;.</source>
          <target state="translated">ページネーションコンテナは、 &lt;code&gt;fragmentSpec&lt;/code&gt; のGraphQLフラグメントを介してコンポーネントのデータ要件を指定するという点で、&lt;a href=&quot;fragment-container&quot;&gt;フラグメントコンテナ&lt;/a&gt;と非常によく似た方法で機能します。</target>
        </trans-unit>
        <trans-unit id="41bdd858e1fe37bddb1f310d8bfca6222b7c844d" translate="yes" xml:space="preserve">
          <source>Pagination Example</source>
          <target state="translated">ページネーションの例</target>
        </trans-unit>
        <trans-unit id="66cd194918cca0919b19b5c19a6632d8edf7c051" translate="yes" xml:space="preserve">
          <source>PaginationContainer</source>
          <target state="translated">PaginationContainer</target>
        </trans-unit>
        <trans-unit id="aede896343f70495123a4970ce699b9a49ceb28f" translate="yes" xml:space="preserve">
          <source>Passing Arguments to a Fragment</source>
          <target state="translated">フラグメントへの引数の渡し方</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="1037cd9d1a4502e08db2f7acc00d0bfad2fb05f5" translate="yes" xml:space="preserve">
          <source>Persisted queries can be enabled by instructing Relay Compiler to emit metadata about each query, mutation, and subscription into a JSON file. The generated file will contain a mapping of query identifiers to query text, which you can then save to your server. To enable persisted queries, use the &lt;code&gt;--persist-output&lt;/code&gt; flag to the compiler:</source>
          <target state="translated">永続クエリは、各クエリ、ミューテーション、サブスクリプションに関するメタデータをJSONファイルに出力するようにRelayCompilerに指示することで有効にできます。生成されたファイルには、クエリ識別子からクエリテキストへのマッピングが含まれ、サーバーに保存できます。永続クエリを有効にするには、コンパイラに対して &lt;code&gt;--persist-output&lt;/code&gt; フラグを使用します。</target>
        </trans-unit>
        <trans-unit id="c55665b87f33041af7083942a79f605ac2526995" translate="yes" xml:space="preserve">
          <source>Persisting queries</source>
          <target state="translated">クエリの永続化</target>
        </trans-unit>
        <trans-unit id="5a9a81786a3cd10e92834a3ac1d48bcd7f39e6e3" translate="yes" xml:space="preserve">
          <source>Please note that the &lt;code&gt;&quot;relay&quot;&lt;/code&gt; plugin should run before other plugins or presets to ensure the &lt;code&gt;graphql&lt;/code&gt; template literals are correctly transformed. See Babel's &lt;a href=&quot;https://babeljs.io/docs/plugins/#plugin-preset-ordering&quot;&gt;documentation on this topic&lt;/a&gt;.</source>
          <target state="translated">ことに注意してください &lt;code&gt;&quot;relay&quot;&lt;/code&gt; プラグインは他のプラグインやプリセットの前に実行する必要が確保する &lt;code&gt;graphql&lt;/code&gt; テンプレートリテラルが正しく変換されます。&lt;a href=&quot;https://babeljs.io/docs/plugins/#plugin-preset-ordering&quot;&gt;このトピックに関する&lt;/a&gt; Babelのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="02a0a62fe61678e8a433343395761ce593ca76c7" translate="yes" xml:space="preserve">
          <source>Please note that this replaces the &lt;a href=&quot;guides-babel-plugin&quot;&gt;older Babel Relay plugin&lt;/a&gt;. It is not necessary to include both plugins.</source>
          <target state="translated">これは、&lt;a href=&quot;guides-babel-plugin&quot;&gt;以前のBabel Relayプラグインに&lt;/a&gt;代わるものです。両方のプラグインを含める必要はありません。</target>
        </trans-unit>
        <trans-unit id="c6a15b9b600a39666d059f44d5e217d0eadd28f6" translate="yes" xml:space="preserve">
          <source>Populating The Cache</source>
          <target state="translated">キャッシュの配置</target>
        </trans-unit>
        <trans-unit id="9ef1894fd67a6660f9dc545b85fdd7563a957682" translate="yes" xml:space="preserve">
          <source>Populating the cache involves walking a hierarchical GraphQL response and creating or updating normalized cache records. At first it may seem that the response alone is sufficient to process the response, but in fact this is only true for very simple queries. Consider &lt;code&gt;user(id: &quot;456&quot;) { photo(size: 32) { uri } }&lt;/code&gt; &amp;mdash; how should we store &lt;code&gt;photo&lt;/code&gt;? Using &lt;code&gt;photo&lt;/code&gt; as the field name in the cache won't work because a different query might fetch the same field but with different argument values (e.g. &lt;code&gt;photo(size: 64) {...}&lt;/code&gt;). A similar issue occurs with pagination. If we fetch the 11th to 20th stories with &lt;code&gt;stories(first: 10, offset: 10)&lt;/code&gt;, these new results should be &lt;em&gt;appended&lt;/em&gt; to the existing list.</source>
          <target state="translated">キャッシュへのデータの取り込みには、階層的なGraphQL応答のウォーク、正規化されたキャッシュレコードの作成または更新が含まれます。最初は、応答だけで応答を処理するのに十分であるように見えるかもしれませんが、実際、これは非常に単純なクエリにのみ当てはまります。 &lt;code&gt;user(id: &quot;456&quot;) { photo(size: 32) { uri } }&lt;/code&gt; 検討します &amp;mdash; &lt;code&gt;photo&lt;/code&gt; をどのように保存すればよいですか？キャッシュ内のフィールド名として &lt;code&gt;photo&lt;/code&gt; を使用しても機能しません。別のクエリが同じフィールドをフェッチするが、引数値が異なる場合があるためです（例： &lt;code&gt;photo(size: 64) {...}&lt;/code&gt; ）。同様の問題がページネーションでも発生します。 &lt;code&gt;stories(first: 10, offset: 10)&lt;/code&gt; を使用して11番目から20番目のストーリーをフェッチする場合、これらの新しい結果は既存のリストに&lt;em&gt;追加さ&lt;/em&gt;れます。</target>
        </trans-unit>
        <trans-unit id="178213e972c712d32c9b754e0fae0660405a3262" translate="yes" xml:space="preserve">
          <source>Processing the schema</source>
          <target state="translated">スキーマの処理</target>
        </trans-unit>
        <trans-unit id="2765c8e15a74b74082d61d103e52529812b42ae8" translate="yes" xml:space="preserve">
          <source>Products access the store primarily via &lt;code&gt;lookup()&lt;/code&gt; and &lt;code&gt;subscribe()&lt;/code&gt;. Lookup reads the initial results of a fragment, and subscribe observes that result for any changes. Note that the output of &lt;code&gt;lookup()&lt;/code&gt; - a &lt;code&gt;Snapshot&lt;/code&gt; - is the input to &lt;code&gt;subscribe()&lt;/code&gt;. This is important because the snapshot contains important information that can be used to optimize the subscription - if &lt;code&gt;subscribe()&lt;/code&gt; accepted only a &lt;code&gt;Selector&lt;/code&gt;, it would have to re-read the results in order to know what to subscribe to, which is less efficient.</source>
          <target state="translated">製品は主に &lt;code&gt;lookup()&lt;/code&gt; と &lt;code&gt;subscribe()&lt;/code&gt; を介してストアにアクセスします。ルックアップはフラグメントの初期結果を読み取り、サブスクライブは変更がないかその結果を監視します。出力ことに注意 &lt;code&gt;lookup()&lt;/code&gt; - &lt;code&gt;Snapshot&lt;/code&gt; -に入力される &lt;code&gt;subscribe()&lt;/code&gt; 。スナップショットにはサブスクリプションの最適化に使用できる重要な情報が含まれているため、これは重要です &lt;code&gt;subscribe()&lt;/code&gt; が &lt;code&gt;Selector&lt;/code&gt; のみを受け入れた場合、サブスクライブする対象を知るために結果を再読み取りする必要があり、効率が低下します。</target>
        </trans-unit>
        <trans-unit id="9fb705d5e8095ddb73ff47bd5a3af904d3ea97b5" translate="yes" xml:space="preserve">
          <source>PropTypes</source>
          <target state="translated">PropTypes</target>
        </trans-unit>
        <trans-unit id="bc6c88db2f0703a9e2461a4a8060ccf1cb881998" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Properties</target>
        </trans-unit>
        <trans-unit id="1100c030f3dc539b64e7700624cabb080430dd57" translate="yes" xml:space="preserve">
          <source>Properties and Methods</source>
          <target state="translated">プロパティとメソッド</target>
        </trans-unit>
        <trans-unit id="e5561bc237fb41709bb2e8b651d704c1664ae03e" translate="yes" xml:space="preserve">
          <source>Props</source>
          <target state="translated">Props</target>
        </trans-unit>
        <trans-unit id="f626c322addc21ad81e099b4b257742e4b44fa03" translate="yes" xml:space="preserve">
          <source>Publishing the results updates the store but does &lt;em&gt;not&lt;/em&gt; immediately notify any subscribers. This is accomplished by calling &lt;code&gt;notify()&lt;/code&gt;...</source>
          <target state="translated">結果を公開するとストアが更新されますが、サブスクライバーに&lt;em&gt;は&lt;/em&gt;すぐには通知されませ&lt;em&gt;ん&lt;/em&gt;。これは、 &lt;code&gt;notify()&lt;/code&gt; を呼び出すことによって実現されます...</target>
        </trans-unit>
        <trans-unit id="32bb9f0eed56ead65c951dc161935d4389c8dfcc" translate="yes" xml:space="preserve">
          <source>QL</source>
          <target state="translated">QL</target>
        </trans-unit>
        <trans-unit id="0fa0f7a77beffe015e3dbe50d9707a0cef073bae" translate="yes" xml:space="preserve">
          <source>Queries vs. Fragments</source>
          <target state="translated">クエリーとフラグメント</target>
        </trans-unit>
        <trans-unit id="715a8fe94c1d42fc9dfbb4b5057bd51288856fd1" translate="yes" xml:space="preserve">
          <source>Query Naming Convention</source>
          <target state="translated">クエリの命名規則</target>
        </trans-unit>
        <trans-unit id="0f4abb2dc94c20672b1e17a54e1138df9766d152" translate="yes" xml:space="preserve">
          <source>Query Renderer</source>
          <target state="translated">クエリレンダラ</target>
        </trans-unit>
        <trans-unit id="64c6ced3f69ca25be02a6b4eb81804275f87ea3e" translate="yes" xml:space="preserve">
          <source>QueryConfig</source>
          <target state="translated">QueryConfig</target>
        </trans-unit>
        <trans-unit id="92ed502ab1f6d9e04d58803b1ef2281c76306e49" translate="yes" xml:space="preserve">
          <source>QueryRenderer</source>
          <target state="translated">QueryRenderer</target>
        </trans-unit>
        <trans-unit id="004b0b56745c5867ceb6c95eccae46bc9634eca6" translate="yes" xml:space="preserve">
          <source>Queuing mutations to avoid race conditions.</source>
          <target state="translated">レース条件を回避するためのキューイング変異。</target>
        </trans-unit>
        <trans-unit id="455083cac2ae96eabe3895762b6080aa09e6afa4" translate="yes" xml:space="preserve">
          <source>Quick Start</source>
          <target state="translated">クイックスタート</target>
        </trans-unit>
        <trans-unit id="c22fa04a8b6a77a7856984111524e39134e2d44d" translate="yes" xml:space="preserve">
          <source>RANGE_ADD</source>
          <target state="translated">RANGE_ADD</target>
        </trans-unit>
        <trans-unit id="a5c0b5daae0eddce515d43e69bbf8ebe6c085aa7" translate="yes" xml:space="preserve">
          <source>RANGE_DELETE</source>
          <target state="translated">RANGE_DELETE</target>
        </trans-unit>
        <trans-unit id="65b00e2a3b97ba71c6979a03111363ff814865c1" translate="yes" xml:space="preserve">
          <source>REQUIRED_CHILDREN</source>
          <target state="translated">REQUIRED_CHILDREN</target>
        </trans-unit>
        <trans-unit id="dd3cac660da0ea89c0136a235305fc5bdb24dcc3" translate="yes" xml:space="preserve">
          <source>React Component</source>
          <target state="translated">Reactコンポーネント</target>
        </trans-unit>
        <trans-unit id="5ca02c4d8d1e211afacc19bb40a490a44ae66f21" translate="yes" xml:space="preserve">
          <source>React Native Configuration</source>
          <target state="translated">React Native の設定</target>
        </trans-unit>
        <trans-unit id="55a38b3edc3904e22c3fddf2b60febe07b47d508" translate="yes" xml:space="preserve">
          <source>React Router</source>
          <target state="translated">リアクトルータ</target>
        </trans-unit>
        <trans-unit id="0d4f22b3a7ca96ed45a6ce530b418585fac69067" translate="yes" xml:space="preserve">
          <source>React and Relay support creating arbitrarily complex applications through &lt;em&gt;composition&lt;/em&gt;. Larger components can be created by composing smaller components, helping us to create modular, robust applications.</source>
          <target state="translated">ReactとRelayは、&lt;em&gt;構成&lt;/em&gt;を通じて任意の複雑なアプリケーションの作成をサポートします。小さなコンポーネントを構成することで大きなコンポーネントを作成できるため、モジュール式の堅牢なアプリケーションを作成できます。</target>
        </trans-unit>
        <trans-unit id="6bb70948dc19f1bb32a259898fca2dfd714e7448" translate="yes" xml:space="preserve">
          <source>React and Relay support creating arbitrarily complex applications through &lt;em&gt;composition&lt;/em&gt;. Larger components can be created by composing smaller components, helping us to create modular, robust applications. There are two aspects to composing components in Relay:</source>
          <target state="translated">ReactおよびRelayは、&lt;em&gt;コンポジション&lt;/em&gt;を通じて任意に複雑なアプリケーションの作成をサポートします。小さなコンポーネントを組み合わせることで大きなコンポーネントを作成でき、モジュール式の堅牢なアプリケーションの作成に役立ちます。Relayでコンポーネントを構成するには、2つの側面があります。</target>
        </trans-unit>
        <trans-unit id="1b75cb8007be8e88622c14d5835273832c1645c5" translate="yes" xml:space="preserve">
          <source>React component classes may have methods, often accessed via &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;refs&lt;/a&gt;. Since Relay composes these component instances in a container, you need to use the &lt;code&gt;componentRef&lt;/code&gt; prop to access them:</source>
          <target state="translated">Reactコンポーネントクラスにはメソッドがあり、多くの場合&lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;refs&lt;/a&gt;を介してアクセスされます。リレーはこれらのコンポーネントインスタンスをコンテナで構成するので、 &lt;code&gt;componentRef&lt;/code&gt; プロップを使用してそれらにアクセスする必要があります。</target>
        </trans-unit>
        <trans-unit id="4414b37377cdce419545fa9b20f3ee40db7ae79f" translate="yes" xml:space="preserve">
          <source>Reading From Cache</source>
          <target state="translated">キャッシュからの読み込み</target>
        </trans-unit>
        <trans-unit id="65ef251f859a908e6a35bac8ecaf436651601f86" translate="yes" xml:space="preserve">
          <source>Reads the value of an attribute on a record by the field name and an object representing pre-defined argument values.</source>
          <target state="translated">レコード上の属性の値を、フィールド名とあらかじめ定義された引数の値を表すオブジェクトで読み込みます。</target>
        </trans-unit>
        <trans-unit id="e3c57930509c5101e93fa1b560decb910e955968" translate="yes" xml:space="preserve">
          <source>Ready State</source>
          <target state="translated">レディステート</target>
        </trans-unit>
        <trans-unit id="e276b1dc6fd5b2e2feab8b52644788511fadacad" translate="yes" xml:space="preserve">
          <source>Ready State Change</source>
          <target state="translated">準備状態の変更</target>
        </trans-unit>
        <trans-unit id="e61f9d2b516c40c24af8003c73bb3ff7c6a828c5" translate="yes" xml:space="preserve">
          <source>RecordProxy</source>
          <target state="translated">RecordProxy</target>
        </trans-unit>
        <trans-unit id="240b0ea75b5e63f3dae5e35c084b7cb6df230fd2" translate="yes" xml:space="preserve">
          <source>RecordSourceSelectorProxy</source>
          <target state="translated">RecordSourceSelectorProxy</target>
        </trans-unit>
        <trans-unit id="8d339e7dedea41faa4ebfe2fcdc6d599b8f484b5" translate="yes" xml:space="preserve">
          <source>Records that are null in the published source are deleted (set to null) in the store.</source>
          <target state="translated">公開されたソースでNULLになっているレコードは、ストアで削除(NULLに設定)されます。</target>
        </trans-unit>
        <trans-unit id="4b363b61849ee47f18ae2be0f0d65a8808b2dfa9" translate="yes" xml:space="preserve">
          <source>Records that exist in both are merged into a new record (inputs unchanged), with the result added to the store.</source>
          <target state="translated">両方に存在するレコードは新しいレコードにマージされ(入力は変更されません)、結果はストアに追加されます。</target>
        </trans-unit>
        <trans-unit id="48b512c3d477cc494940cbc3511367f3bc8c1733" translate="yes" xml:space="preserve">
          <source>Records that exist only in the published source are added to the store.</source>
          <target state="translated">公開されているソースにしか存在しないレコードがストアに追加されます。</target>
        </trans-unit>
        <trans-unit id="2ff3c14aded3e6ad067ba4f314fd7efd64ebd5df" translate="yes" xml:space="preserve">
          <source>Records with a special sentinel value are removed from the store. This supports un-publishing optimistically created records.</source>
          <target state="translated">特別なセンチネル値を持つレコードはストアから削除されます。これは、楽観的に作成されたレコードの公開解除をサポートします。</target>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="5e8ed94444d1cf7d3d3d0307cd8aaf8c3d6040fc" translate="yes" xml:space="preserve">
          <source>Refetch Container</source>
          <target state="translated">リフェッチコンテナ</target>
        </trans-unit>
        <trans-unit id="a3c412dd10a0e8cb0c1899aa86989fec9f2b0413" translate="yes" xml:space="preserve">
          <source>RefetchContainer</source>
          <target state="translated">RefetchContainer</target>
        </trans-unit>
        <trans-unit id="638e5005315e0cabef699577f78933ca4cc7db6a" translate="yes" xml:space="preserve">
          <source>Refetching Data (aka &quot;See More&quot;)</source>
          <target state="translated">データのリフェッチ(別名「もっと見る</target>
        </trans-unit>
        <trans-unit id="c9bb21f0d54fefc21f3fe3cd21ff7bc0b0847f63" translate="yes" xml:space="preserve">
          <source>Refetching latest data</source>
          <target state="translated">最新データのリフェッチ</target>
        </trans-unit>
        <trans-unit id="47f437a4450523abebb9b8a6327af806c6dfe250" translate="yes" xml:space="preserve">
          <source>Related APIs</source>
          <target state="translated">関連API</target>
        </trans-unit>
        <trans-unit id="9f537f977fa2ecd1f91ff057ce1667e98ab04729" translate="yes" xml:space="preserve">
          <source>Relay</source>
          <target state="translated">Relay</target>
        </trans-unit>
        <trans-unit id="88dd507e8359bb2fd7a7702cfdc9ffaecb218c8a" translate="yes" xml:space="preserve">
          <source>Relay Classic API</source>
          <target state="translated">Relay Classic API</target>
        </trans-unit>
        <trans-unit id="d6764a98d68a0f585f067a880fb7f047e42e5295" translate="yes" xml:space="preserve">
          <source>Relay Classic Guides</source>
          <target state="translated">リレークラシックガイド</target>
        </trans-unit>
        <trans-unit id="aef721f4de8f071bed34bec165e9e8e9422d904c" translate="yes" xml:space="preserve">
          <source>Relay Classic Interfaces</source>
          <target state="translated">リレー・クラシック・インターフェイス</target>
        </trans-unit>
        <trans-unit id="8ee884f2695bfbad6a7a6dae4d48bf3348965934" translate="yes" xml:space="preserve">
          <source>Relay Compat</source>
          <target state="translated">リレーコンパット</target>
        </trans-unit>
        <trans-unit id="c546e3c1729605fb70a2db1deb7870608f3445c7" translate="yes" xml:space="preserve">
          <source>Relay Compat is part of &lt;code&gt;'react-relay'&lt;/code&gt; which allows you to do exactly this, providing an identical API to Relay Modern, while allowing interoperability with both runtimes.</source>
          <target state="translated">Relay Compatは &lt;code&gt;'react-relay'&lt;/code&gt; の一部であり、これにより正確にこれを行うことができ、Relay Modernと同じAPIを提供すると同時に、両方のランタイムとの相互運用を可能にします。</target>
        </trans-unit>
        <trans-unit id="ddef7758830f719ed90adce373f8f83b9acf721d" translate="yes" xml:space="preserve">
          <source>Relay Compiler</source>
          <target state="translated">リレーコンパイラ</target>
        </trans-unit>
        <trans-unit id="9e9a58b9be4e5093877d58bb37e46ff2f5998988" translate="yes" xml:space="preserve">
          <source>Relay Compiler supports the use of &lt;strong&gt;persisted queries&lt;/strong&gt;, in which each version of a query is associated to a unique ID on the server and the runtime uploads only the persisted ID instead of the full query text. This has several benefits: it can significantly reduce the time to send a query (and the upload bytes) and enables &lt;em&gt;whitelisting&lt;/em&gt; of queries. For example, you may choose to disallow queries in text form and only allow queries that have been persisted (and that presumably have passed your internal code review process).</source>
          <target state="translated">リレーコンパイラは、&lt;strong&gt;永続クエリ&lt;/strong&gt;の使用をサポートします。この場合、&lt;strong&gt;クエリの&lt;/strong&gt;各バージョンはサーバー上の一意のIDに関連付けられ、ランタイムは完全なクエリテキストではなく永続IDのみをアップロードします。これにはいくつかの利点があります。クエリの送信時間（およびアップロードバイト）を大幅に短縮し、クエリの&lt;em&gt;ホワイトリストへの登録&lt;/em&gt;を可能にします。たとえば、テキスト形式のクエリを禁止し、永続化された（そしておそらく内部コードレビュープロセスに合格した）クエリのみを許可することを選択できます。</target>
        </trans-unit>
        <trans-unit id="3c34dd9f9f2001d5f2a7c52af35f1be4b138b177" translate="yes" xml:space="preserve">
          <source>Relay Compiler will then create the id =&amp;gt; query text mapping in the path you specify. You can then use this complete json file in your server side to map query ids to operation text.</source>
          <target state="translated">リレーコンパイラは、指定したパスにid =&amp;gt;クエリテキストマッピングを作成します。次に、サーバー側でこの完全なjsonファイルを使用して、クエリIDを操作テキストにマップできます。</target>
        </trans-unit>
        <trans-unit id="be2b89d58206687eafd6b5f1f94bb37fb0baa8fb" translate="yes" xml:space="preserve">
          <source>Relay Containers</source>
          <target state="translated">リレー容器</target>
        </trans-unit>
        <trans-unit id="e0d9a631ef93e7ccb54370c0af336f421599b386" translate="yes" xml:space="preserve">
          <source>Relay DevTools is tool designed to help developers inspect their Relay state and understand how store changes overtime. Relay DevTools ships in two ways:</source>
          <target state="translated">Relay DevToolsは、開発者がRelayの状態を検査し、ストアが時間の経過とともにどのように変化するかを理解するためのツールです。Relay DevToolsは2つの方法で出荷されます。</target>
        </trans-unit>
        <trans-unit id="426c398ee54f1b774dac3a903f0125ae20a5c9e6" translate="yes" xml:space="preserve">
          <source>Relay Documentation</source>
          <target state="translated">リレードキュメント</target>
        </trans-unit>
        <trans-unit id="1443cd7ff63d89730c443bd7786d90a6df7d1998" translate="yes" xml:space="preserve">
          <source>Relay Environment</source>
          <target state="translated">リレー環境</target>
        </trans-unit>
        <trans-unit id="d699ddf70a567d16a64d34cd746d0cc2172e4ec9" translate="yes" xml:space="preserve">
          <source>Relay Modern</source>
          <target state="translated">リレー現代</target>
        </trans-unit>
        <trans-unit id="125aa7abbb0a0bc142817f98c7e32cd828f1f474" translate="yes" xml:space="preserve">
          <source>Relay Modern comes with automatic Flow type generation for the fragments used in Relay containers based on the GraphQL schema. Using these Flow types can help make an application less error-prone, by ensuring all possible &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; cases are considered even if they don't happen frequently.</source>
          <target state="translated">Relay Modernには、GraphQLスキーマに基づくリレーコンテナーで使用されるフラグメント用の自動フロータイプ生成が付属しています。これらのフロータイプを使用すると、発生する可能性のある &lt;code&gt;null&lt;/code&gt; または &lt;code&gt;undefined&lt;/code&gt; ケースがすべて頻繁に発生しなくても確実に考慮されるため、アプリケーションのエラーが発生しにくくなります。</target>
        </trans-unit>
        <trans-unit id="fe351802f53838c0d3ff7ec944643ab9992b7020" translate="yes" xml:space="preserve">
          <source>Relay Modern containers combine standard React components with a description of their data requirements, expressed as one or more GraphQL fragments. Each container is itself a standard React component that can be rendered using the standard React API (e.g. &lt;code&gt;&amp;lt;YourComponent prop={...} /&amp;gt;&lt;/code&gt;). When rendered, a container will read the data for its fragment from the Relay cache. As the fragment data changes - for example due to a mutation, subscription, or updated query response - the container will automatically re-render the component.</source>
          <target state="translated">Relay Modernコンテナーは、標準のReactコンポーネントと、1つ以上のGraphQLフラグメントとして表現されたデータ要件の説明を組み合わせます。各コンテナは、それ自体が標準のReactコンポーネントであり、標準のReact APIを使用してレンダリングできます（例： &lt;code&gt;&amp;lt;YourComponent prop={...} /&amp;gt;&lt;/code&gt; ）。レンダリングされると、コンテナはリレーキャッシュからフラグメントのデータを読み取ります。たとえば、ミューテーション、サブスクリプション、または更新されたクエリ応答により、フラグメントデータが変更されると、コンテナはコンポーネントを自動的に再レン​​ダリングします。</target>
        </trans-unit>
        <trans-unit id="b783df53e509475b97db41df7f512b5cdf7adf0d" translate="yes" xml:space="preserve">
          <source>Relay Modern enables a variety of new features. Some are available via the Compat API, while others require upgrading fully to the Modern runtime. See &lt;a href=&quot;new-in-relay-modern&quot;&gt;what's new in Relay Modern&lt;/a&gt; for more details.</source>
          <target state="translated">Relay Modernは、さまざまな新機能を可能にします。Compat APIを介して利用できるものもあれば、Modernランタイムに完全にアップグレードする必要があるものもあります。詳細について&lt;a href=&quot;new-in-relay-modern&quot;&gt;は、Relay Modernの新機能&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="02ee7840306dae496dace1fe86750e32e8b8c807" translate="yes" xml:space="preserve">
          <source>Relay Modern is a new version of Relay designed from the ground up to be easier to use, more extensible and, most of all, able to improve performance on mobile devices. Relay Modern accomplishes this with static queries and ahead-of-time code generation.</source>
          <target state="translated">Relay Modernは、より使いやすく、より拡張性が高く、何よりもモバイルデバイスでのパフォーマンスを向上させることができるように一から設計されたRelayの新バージョンです。Relay Modernでは、静的クエリと事前のコード生成により、これを実現しています。</target>
        </trans-unit>
        <trans-unit id="45d888a1b92fa795f57aa8cf7b25c2d182f14c5c" translate="yes" xml:space="preserve">
          <source>Relay Modern is composed of three core modules:</source>
          <target state="translated">Relay Modernは3つのコアモジュールで構成されています。</target>
        </trans-unit>
        <trans-unit id="451008aa294b51a951e1a6a9073f36b4296c782c" translate="yes" xml:space="preserve">
          <source>Relay Modern requires a Babel plugin to convert GraphQL to runtime artifacts:</source>
          <target state="translated">Relay Modernでは、GraphQLをランタイム・アーティファクトに変換するためのBabelプラグインが必要です。</target>
        </trans-unit>
        <trans-unit id="0d2944c329394a1cfc563059eabe3a8681e7e2bc" translate="yes" xml:space="preserve">
          <source>Relay Modern supports GraphQL Subscriptions, using the imperative update API to allow modifications to the store whenever a payload is received. It also features experimental support for GraphQL Live Queries via polling.</source>
          <target state="translated">Relay ModernはGraphQL Subscriptionをサポートしており、必須更新APIを使用して、ペイロードを受信するたびにストアを変更できるようにしています。また、ポーリングによる GraphQL ライブクエリも実験的にサポートしています。</target>
        </trans-unit>
        <trans-unit id="372f8f866ff79038477865a8b1e68cc2436d4212" translate="yes" xml:space="preserve">
          <source>Relay Modern supports the following directives</source>
          <target state="translated">Relay Modernは以下のディレクティブをサポートしています。</target>
        </trans-unit>
        <trans-unit id="4fcb24b9dcd43c8532db4d056e1af150670c742a" translate="yes" xml:space="preserve">
          <source>Relay Modern uses the Relay Compiler to convert &lt;code&gt;graphql&lt;/code&gt; literals into generated files that live alongside your source files.</source>
          <target state="translated">Relay Modernは、Relayコンパイラを使用して、 &lt;code&gt;graphql&lt;/code&gt; リテラルを、ソースファイルと共存する生成ファイルに変換します。</target>
        </trans-unit>
        <trans-unit id="604519e05335c47d085692b3d5c93c6c0cf24a81" translate="yes" xml:space="preserve">
          <source>Relay Modern's ahead-of-time compilation requires the new Relay Compiler:</source>
          <target state="translated">Relay Modernの先行コンパイルには、新しいRelay Compilerが必要です。</target>
        </trans-unit>
        <trans-unit id="d344ad7e0e46f9326c5126f3f06dc4800f23f6c8" translate="yes" xml:space="preserve">
          <source>Relay Modern's core is essentially an un-opinionated store for GraphQL data. It can be used independent of rendering views using React and can be extended to be used with other frameworks.</source>
          <target state="translated">Relay Modernのコアは、基本的にはGraphQLデータのための非オピニオンストアです。Reactを使ったビューのレンダリングとは独立して使用でき、他のフレームワークと組み合わせて拡張して使用することも可能です。</target>
        </trans-unit>
        <trans-unit id="e31b26fed868774cce2fc303006fb272761f29e5" translate="yes" xml:space="preserve">
          <source>Relay Runtime is designed for use with GraphQL schemas that describe &lt;strong&gt;object graphs&lt;/strong&gt; in which objects have a type, an identity, and a set of fields with values. Objects may reference each other, which is represented by fields whose values are one or more other objects in the graph [1]. To distinguish from JavaScript &lt;code&gt;Object&lt;/code&gt;s, these units of data are referred to as &lt;code&gt;Record&lt;/code&gt;s. Relay represents both its internal cache as well as query/mutation/etc results as a mapping of &lt;strong&gt;data ID&lt;/strong&gt;s to &lt;strong&gt;records&lt;/strong&gt;. The data ID is the unique (with respect to the cache) identifier for a record - it may be the value of an actual &lt;code&gt;id&lt;/code&gt; field or based on the path to the record from the nearest object with an &lt;code&gt;id&lt;/code&gt; (such path-based ids are called &lt;strong&gt;client ids&lt;/strong&gt;). Each &lt;code&gt;Record&lt;/code&gt; stores its data ID, type, and any fields that have been fetched. Multiple records are stored together as a &lt;code&gt;RecordSource&lt;/code&gt;: a mapping of data IDs to &lt;code&gt;Record&lt;/code&gt; instances.</source>
          <target state="translated">リレーランタイムは、オブジェクトがタイプ、ID、および値を持つフィールドのセットを持つ&lt;strong&gt;オブジェクトグラフ&lt;/strong&gt;を記述するGraphQLスキーマで使用するように設計されています。オブジェクトは相互に参照できます。これは、グラフ内の他の1つ以上のオブジェクトの値を持つフィールドで表されます[1]。 JavaScript &lt;code&gt;Object&lt;/code&gt; と区別するために、これらのデータ単位は &lt;code&gt;Record&lt;/code&gt; と呼ばれます。リレーは、内部キャッシュとクエリ/ミューテーションなどの結果の両方を、&lt;strong&gt;データID&lt;/strong&gt;の&lt;strong&gt;レコード&lt;/strong&gt;へのマッピングとして表します。データIDは、レコードの一意の（キャッシュに関して）識別子です。実際の &lt;code&gt;id&lt;/code&gt; フィールドの値であるか、最も近いオブジェクトからレコードへのパスに基づいている可能性があります。 &lt;code&gt;id&lt;/code&gt; （このようなパスベースのIDは&lt;strong&gt;クライアントID&lt;/strong&gt;と呼ばれ&lt;strong&gt;ます&lt;/strong&gt;）。各 &lt;code&gt;Record&lt;/code&gt; は、データID、タイプ、およびフェッチされたフィールドが格納されます。複数のレコードが &lt;code&gt;RecordSource&lt;/code&gt; として一緒に保存されます：データIDの &lt;code&gt;Record&lt;/code&gt; インスタンスへのマッピング。</target>
        </trans-unit>
        <trans-unit id="881bc62d6225c769dfa7c14c7288aba40be25da2" translate="yes" xml:space="preserve">
          <source>Relay Specification</source>
          <target state="translated">リレー仕様</target>
        </trans-unit>
        <trans-unit id="5d0eda024fc816c22ea59a24e3cd5865e39cffa0" translate="yes" xml:space="preserve">
          <source>Relay Store</source>
          <target state="translated">中継店</target>
        </trans-unit>
        <trans-unit id="fd195ecee5d7e7a6df1ecbbf4a909cee95b601b9" translate="yes" xml:space="preserve">
          <source>Relay allows developers to annotate their React components with data dependencies by creating &lt;strong&gt;containers&lt;/strong&gt;. These are regular React components that wrap the originals. A key design constraint is that React components are meant to be reusable, so Relay containers must be too. For example, a &lt;code&gt;&amp;lt;Story /&amp;gt;&lt;/code&gt; component might implement a view for rendering any &lt;code&gt;Story&lt;/code&gt; item. The actual story to render would be determined by the data passed to the component: &lt;code&gt;&amp;lt;Story story={ ... } /&amp;gt;&lt;/code&gt;. The equivalent in GraphQL are &lt;strong&gt;fragments&lt;/strong&gt;: named query snippets that specify what data to fetch &lt;em&gt;for an object of a given type&lt;/em&gt;. We might describe the data needed by &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; as follows:</source>
          <target state="translated">リレーを使用すると、開発者は&lt;strong&gt;コンテナ&lt;/strong&gt;を作成することで、Reactコンポーネントにデータの依存関係で注釈を付けることができます。これらは、オリジナルをラップする通常のReactコンポーネントです。重要な設計上の制約は、Reactコンポーネントは再利用可能であることを意図しているため、Relayコンテナーも再利用可能でなければならないということです。たとえば、 &lt;code&gt;&amp;lt;Story /&amp;gt;&lt;/code&gt; コンポーネントは、 &lt;code&gt;Story&lt;/code&gt; アイテムをレンダリングするためのビューを実装する場合があります。レンダリングする実際のストーリーは、コンポーネントに渡されるデータによって決定されます： &lt;code&gt;&amp;lt;Story story={ ... } /&amp;gt;&lt;/code&gt; 。 GraphQLで同等のものは、&lt;strong&gt;フラグメント&lt;/strong&gt;です。&lt;em&gt;特定のタイプのオブジェクト&lt;/em&gt;に対してフェッチ&lt;em&gt;する&lt;/em&gt;データを指定する名前付きクエリスニペットです。 &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; に必要なデータは次のように説明できます。</target>
        </trans-unit>
        <trans-unit id="48799f13f2ac51d5720b5a4e683e4a8844cdd877" translate="yes" xml:space="preserve">
          <source>Relay allows developers to annotate their React components with data dependencies by creating &lt;strong&gt;containers&lt;/strong&gt;. These are regular React components that wrap the originals. A key design constraint is that React components are meant to be reusable, so Relay containers must be too. For example, a &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; component might implement a view for rendering any &lt;code&gt;Story&lt;/code&gt; item. The actual story to render would be determined by the data passed to the component: &lt;code&gt;&amp;lt;Story story={ ... } /&amp;gt;&lt;/code&gt;. The equivalent in GraphQL are &lt;strong&gt;fragments&lt;/strong&gt;: named query snippets that specify what data to fetch &lt;em&gt;for an object of a given type&lt;/em&gt;. We might describe the data needed by &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; as follows:</source>
          <target state="translated">リレーを使用すると、開発者は&lt;strong&gt;コンテナ&lt;/strong&gt;を作成することにより、Reactコンポーネントにデータの依存関係を注釈できます。これらは、オリジナルをラップする通常のReactコンポーネントです。設計上の重要な制約は、Reactコンポーネントは再利用可能であることを意図しているため、リレーコンテナーもそうでなければならないということです。たとえば、 &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; コンポーネントは、 &lt;code&gt;Story&lt;/code&gt; アイテムをレンダリングするためのビューを実装する場合があります。レンダリングする実際のストーリーは、コンポーネントに渡されるデータ &lt;code&gt;&amp;lt;Story story={ ... } /&amp;gt;&lt;/code&gt; によって決定されます。 GraphQLでこれに相当するのは&lt;strong&gt;フラグメント&lt;/strong&gt;です。&lt;em&gt;指定されたタイプのオブジェクトについて&lt;/em&gt;フェッチ&lt;em&gt;する&lt;/em&gt;データを指定する名前付きクエリスニペットです。 &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; が必要とするデータは次のように記述できます。</target>
        </trans-unit>
        <trans-unit id="76c99c886cf994dd48c328f17b234bd016edf810" translate="yes" xml:space="preserve">
          <source>Relay also goes further: it uses opaque identifiers on &lt;code&gt;props&lt;/code&gt; to validate that we've explicitly fetched the data for a component before rendering it. If &lt;code&gt;&amp;lt;Story /&amp;gt;&lt;/code&gt; renders &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt; but forgets to include its fragment, Relay will warn that the data for &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt; is missing. In fact, Relay will warn &lt;em&gt;even if&lt;/em&gt; some other component happened to fetch the same data required by &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt;. This warning tells us that although things &lt;em&gt;might&lt;/em&gt; work now they're highly likely to break later.</source>
          <target state="translated">リレーもさらに進んでいます。 &lt;code&gt;props&lt;/code&gt; 不透明な識別子を使用して、コンポーネントのデータをレンダリングする前に明示的にフェッチしたことを検証します。場合 &lt;code&gt;&amp;lt;Story /&amp;gt;&lt;/code&gt; レンダリング &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt; そのフラグメントを含めることが、忘れを、リレー用のデータという警告が表示されます &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt; 欠落しています。実際、他のコンポーネントが &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt; に必要な同じデータをフェッチした&lt;em&gt;場合でも&lt;/em&gt;、Relayは警告を発します。この警告は、現在は機能している&lt;em&gt;かもしれません&lt;/em&gt;が、後で壊れてしまう可能性が高いことを示しています。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="254c939fb761720339a3dd3ad863697bebf60c3f" translate="yes" xml:space="preserve">
          <source>Relay also goes further: it uses opaque identifiers on &lt;code&gt;props&lt;/code&gt; to validate that we've explicitly fetched the data for a component before rendering it. If &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; renders &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; but forgets to include its fragment, Relay will warn that the data for &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; is missing. In fact, Relay will warn &lt;em&gt;even if&lt;/em&gt; some other component happened to fetch the same data required by &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt;. This warning tells us that although things &lt;em&gt;might&lt;/em&gt; work now they're highly likely to break later.</source>
          <target state="translated">リレーもさらに進んでいます：レンダリングする前にコンポーネントのデータを明示的にフェッチしたことを検証するために、 &lt;code&gt;props&lt;/code&gt; に不透明な識別子を使用しています。 &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; が &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; &amp;gt;をレンダリングし、そのフラグメントを含めるのを忘れた場合、Relayは &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; のデータが欠落していることを警告します。実際、他のコンポーネントが &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; が必要とする同じデータをフェッチした&lt;em&gt;場合でも&lt;/em&gt;、Relayは警告します。この警告は、物事&lt;em&gt;は&lt;/em&gt;今&lt;em&gt;は&lt;/em&gt;うまくいく&lt;em&gt;かもしれない&lt;/em&gt;が、後で壊れる可能性が非常に高いことを示しています。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c212579d453e98cbd0a4dcbacffef8088e5ab28f" translate="yes" xml:space="preserve">
          <source>Relay also lets us completely replace the default network layer.</source>
          <target state="translated">Relayでは、デフォルトのネットワーク層を完全に置き換えることもできます。</target>
        </trans-unit>
        <trans-unit id="f200764a518868ca3b31ea98a1353b5d9f2dd1fc" translate="yes" xml:space="preserve">
          <source>Relay can be thought of as two parts which work together: an API for building data-driven components and a runtime which fetches and stores data from GraphQL to populate your app. Relay Modern brings both a new API and a new runtime.</source>
          <target state="translated">データ駆動型コンポーネントを構築するためのAPIと、アプリにデータを反映させるためにGraphQLからデータをフェッチして保存するランタイムです。Relay Modernには、新しいAPIと新しいランタイムの両方が搭載されています。</target>
        </trans-unit>
        <trans-unit id="edc443fe11fe9992f4eb82855f77153b4705147b" translate="yes" xml:space="preserve">
          <source>Relay containers are created using &lt;code&gt;Relay.createContainer&lt;/code&gt;.</source>
          <target state="translated">リレーコンテナーは、 &lt;code&gt;Relay.createContainer&lt;/code&gt; を使用して作成されます。</target>
        </trans-unit>
        <trans-unit id="2748ac007f286936a91fb67b3ca6e11462a7fe21" translate="yes" xml:space="preserve">
          <source>Relay containers are higher-order components &amp;mdash; &lt;code&gt;Relay.createContainer&lt;/code&gt; is a function that takes a React component as input and returns a new component as output. This means that the container can manage data fetching and resolution logic without interfering with the &lt;code&gt;state&lt;/code&gt; of the inner component.</source>
          <target state="translated">リレーコンテナーは高次コンポーネントです&amp;mdash; &lt;code&gt;Relay.createContainer&lt;/code&gt; は、Reactコンポーネントを入力として受け取り、新しいコンポーネントを出力として返す関数です。これは、コンテナーが内部コンポーネントの &lt;code&gt;state&lt;/code&gt; に干渉することなく、データのフェッチおよび解決ロジックを管理できることを意味します。</target>
        </trans-unit>
        <trans-unit id="1c357d13b1cce8a1c46ccc30afeeb5fd2f902c5a" translate="yes" xml:space="preserve">
          <source>Relay containers provide a static &lt;code&gt;getFragment()&lt;/code&gt; method that returns a reference to that component's fragment:</source>
          <target state="translated">リレーコンテナーは、そのコンポーネントのフラグメントへの参照を返す静的な &lt;code&gt;getFragment()&lt;/code&gt; メソッドを提供します。</target>
        </trans-unit>
        <trans-unit id="5a410cc37e6396592aa37827cec122428cb2d984" translate="yes" xml:space="preserve">
          <source>Relay couples React with GraphQL and develops the idea of encapsulation further. It allows components to specify what data they need and the Relay framework provides the data. This makes the data needs of inner components opaque and allows composition of those needs. Thinking about what data an app needs becomes localized to the component making it easier to reason about what fields are needed or no longer needed.</source>
          <target state="translated">RelayはReactとGraphQLを組み合わせ、カプセル化の考え方をさらに発展させています。コンポーネントが必要とするデータを指定し、Relay フレームワークがデータを提供します。これにより、内部コンポーネントのデータニーズが不透明になり、それらのニーズを組み合わせることが可能になります。アプリが必要とするデータを考えることで、コンポーネントにローカライズされ、どのフィールドが必要なのか、あるいは不要なのかを推論するのが容易になります。</target>
        </trans-unit>
        <trans-unit id="934fd827600b774b11b92dcf9269d690870fb9bb" translate="yes" xml:space="preserve">
          <source>Relay ensures that this data is available before the component is rendered.</source>
          <target state="translated">リレーは、コンポーネントがレンダリングされる前にこのデータが利用可能であることを保証します。</target>
        </trans-unit>
        <trans-unit id="b556a8542493c85c6ab714e7efdb1e48fb0c7ece" translate="yes" xml:space="preserve">
          <source>Relay exposes the following APIs to create subscriptions.</source>
          <target state="translated">Relayは、サブスクリプションを作成するために以下のAPIを公開しています。</target>
        </trans-unit>
        <trans-unit id="8076714ed2f663c62d9c70223ceef029bffc6fc4" translate="yes" xml:space="preserve">
          <source>Relay exposes the following APIs to perform mutations.</source>
          <target state="translated">Relayは突然変異を実行するために以下のAPIを公開しています。</target>
        </trans-unit>
        <trans-unit id="9a9f6b192104115130a465f5d1b347425625bd6d" translate="yes" xml:space="preserve">
          <source>Relay fragments, mutations, and queries must be specified using ES6 template literals tagged with &lt;code&gt;Relay.QL&lt;/code&gt;. For example:</source>
          <target state="translated">リレーフラグメント、ミュー &lt;code&gt;Relay.QL&lt;/code&gt; 、クエリは、Relay.QLでタグ付けされたES6テンプレートリテラルを使用して指定する必要があります。例えば：</target>
        </trans-unit>
        <trans-unit id="f94ab02e4b36f1c69a9b192786b3451a5578f530" translate="yes" xml:space="preserve">
          <source>Relay has a network layer abstraction that separates mutations and queries from the actual machinery that sends requests to the GraphQL server. This gives us the flexibility to configure or even completely replace the default network layer via injection.</source>
          <target state="translated">Relayにはネットワーク・レイヤーの抽象化が施されており、突然変異やクエリをGraphQLサーバにリクエストを送信する実際の機器とは分離されています。これにより、インジェクションによってデフォルトのネットワーク層を柔軟に設定したり、完全に置き換えたりすることができます。</target>
        </trans-unit>
        <trans-unit id="3e093a4c47e1f292b6f2a4693a9f28a6e839881f" translate="yes" xml:space="preserve">
          <source>Relay implements several variations of &lt;strong&gt;query traversal&lt;/strong&gt;: operations that walk a query alongside some other data such as the cache or a response payload. For example, when a query is fetched Relay performs a &quot;diff&quot; traversal to determine what fields are missing (much like React diffs virtual DOM trees). This can reduce the amount of data fetched in many common cases and even allow Relay to avoid network requests at all when queries are fully cached.</source>
          <target state="translated">リレーは、&lt;strong&gt;クエリトラバーサルの&lt;/strong&gt;いくつかのバリエーションを実装します。キャッシュや応答ペイロードなどの他のデータと一緒にクエリをウォークするオペレーションです。たとえば、クエリがフェッチされると、Relayは &quot;diff&quot;トラバーサルを実行して、欠落しているフィールドを特定します（React diffs仮想DOMツリーのように）。これにより、多くの一般的なケースでフェッチされるデータの量を減らすことができ、クエリが完全にキャッシュされている場合は、Relayでネットワーク要求をまったく回避することもできます。</target>
        </trans-unit>
        <trans-unit id="1f7225f6558a177e37be9ba84410fe63b32cde06" translate="yes" xml:space="preserve">
          <source>Relay introduces two new classes of objects: &lt;code&gt;RelayContainer&lt;/code&gt; and &lt;code&gt;Relay.Route&lt;/code&gt;. &lt;code&gt;Relay.PropTypes&lt;/code&gt; provides prop validators used to assert that props are of these types.</source>
          <target state="translated">Relayには、 &lt;code&gt;RelayContainer&lt;/code&gt; と &lt;code&gt;Relay.Route&lt;/code&gt; という 2つの新しいオブジェクトクラスが導入されています。 &lt;code&gt;Relay.PropTypes&lt;/code&gt; は、小道具がこれらのタイプであることを表明するために使用される小道具バリデーターを提供します。</target>
        </trans-unit>
        <trans-unit id="2948c3c748b1764a34a269ea9919759693eaf027" translate="yes" xml:space="preserve">
          <source>Relay is a JavaScript framework for building data-driven React applications powered by GraphQL, designed from the ground up to be easy to use, extensible and, most of all, performant. Relay accomplishes this with static queries and ahead-of-time code generation.</source>
          <target state="translated">Relayは、GraphQLを利用したデータ駆動型のReactアプリケーションを構築するためのJavaScriptフレームワークで、使いやすさ、拡張性、そして何よりもパフォーマンスを重視して設計されています。Relay は、静的クエリと事前のコード生成により、これを実現しています。</target>
        </trans-unit>
        <trans-unit id="97f52c1bbd17e02a2c6367d7476a6ac21c258276" translate="yes" xml:space="preserve">
          <source>Relay is pre-configured to use a default network layer that works with &lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;express-graphql&lt;/a&gt;. This default network layer is exposed via &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt;.</source>
          <target state="translated">リレーは、&lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;express-graphql&lt;/a&gt;で動作するデフォルトのネットワークレイヤーを使用するように事前設定されています。このデフォルトのネットワーク層は、 &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt; を介して公開されます。</target>
        </trans-unit>
        <trans-unit id="54171fd2fa20a9c4bec1be11d3879a92bfa7df55" translate="yes" xml:space="preserve">
          <source>Relay makes use of GraphQL mutations; operations that enable us to mutate data on the client and server. To create a mutation for use in our app, we subclass &lt;code&gt;Relay.Mutation&lt;/code&gt; and implement, at minimum, the four abstract methods listed below.</source>
          <target state="translated">RelayはGraphQLミューテーションを利用します。クライアントとサーバー上のデータを変更できるようにする操作。アプリで使用するミューテーションを作成するには、 &lt;code&gt;Relay.Mutation&lt;/code&gt; をサブクラス化し、少なくとも以下に示す4つの抽象メソッドを実装します。</target>
        </trans-unit>
        <trans-unit id="973d2e671c894478b465827d5c3826264541eadd" translate="yes" xml:space="preserve">
          <source>Relay modern makes no assumptions about what to cache and will garbage collect any data that is no longer referenced.</source>
          <target state="translated">Relay modernは、何をキャッシュするかについて何の仮定もせず、参照されなくなったデータをゴミとして収集します。</target>
        </trans-unit>
        <trans-unit id="8dd31c1805e052611332ba16c37162381a4a626a" translate="yes" xml:space="preserve">
          <source>Relay routes don't really implement any URL routing specific logic or work with History API. In the future we will maybe rename RelayRoute to be something more like RelayQueryRoots or RelayQueryConfig.</source>
          <target state="translated">RelayRouteはURLルーティングに特化したロジックを実装しているわけではありませんし、History APIと連携しているわけでもありません。将来的にはRelayRouteの名前をRelayQueryRootsやRelayQueryConfigのようなものに変更するかもしれません。</target>
        </trans-unit>
        <trans-unit id="589e99096a0b6781ff51073c2234321dc486a027" translate="yes" xml:space="preserve">
          <source>Relay routes don't really implement any URL routing specific logic or work with History API. In the future we will maybe rename RelayRoute to be something more like RelayQueryRoots or RelayQueryConfig. For more information around why Relay doesn't provide URL-routing features, and suggestions for such solutions, see &lt;a href=&quot;https://medium.com/@cpojer/relay-and-routing-36b5439bad9&quot;&gt;this post&lt;/a&gt;.</source>
          <target state="translated">リレールートは、URLルーティング固有のロジックを実際に実装したり、History APIと連携したりしません。将来的には、RelayRouteの名前をRelayQueryRootsやRelayQueryConfigなどに変更する予定です。RelayがURLルーティング機能を提供しない理由の詳細と、そのようなソリューションの提案については、&lt;a href=&quot;https://medium.com/@cpojer/relay-and-routing-36b5439bad9&quot;&gt;この投稿を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ef480060aa47ef1a958a5c003bdd30a4e3354405" translate="yes" xml:space="preserve">
          <source>Relay speaks to GraphQL servers through a network layer. The &lt;a href=&quot;guides-network-layer&quot;&gt;network layer&lt;/a&gt; that ships with Relay is compatible with express-graphql out of the box, and will continue to evolve as we add new features to the transport.</source>
          <target state="translated">リレーは、ネットワークレイヤーを介してGraphQLサーバーと通信します。&lt;a href=&quot;guides-network-layer&quot;&gt;ネットワーク層&lt;/a&gt;のリレーに付属の箱の特急-graphqlアウトと互換性があり、そして我々は、トランスポートに新しい機能を追加するよう進化し続けること。</target>
        </trans-unit>
        <trans-unit id="256546be326de4c5533a50332088277d259f1856" translate="yes" xml:space="preserve">
          <source>Relay updates the component whenever the underlying data has changed.</source>
          <target state="translated">Relayは、基礎となるデータが変更されるたびにコンポーネントを更新します。</target>
        </trans-unit>
        <trans-unit id="7f2f7458912547fdfa17a726b3bd42f898c10724" translate="yes" xml:space="preserve">
          <source>Relay uses a &lt;strong&gt;Babel&lt;/strong&gt; plugin to convert &lt;code&gt;graphql&lt;/code&gt; literals into requires of the code generated by Relay Compiler.</source>
          <target state="translated">リレーは、&lt;strong&gt;Babel&lt;/strong&gt;プラグインを使用して、 &lt;code&gt;graphql&lt;/code&gt; リテラルをリレーコンパイラによって生成されたコードの要求に変換します。</target>
        </trans-unit>
        <trans-unit id="9cbd2a4fac093602e7724812345c1426293f1cd9" translate="yes" xml:space="preserve">
          <source>Relay uses a &lt;strong&gt;babel&lt;/strong&gt; plugin to convert from &lt;code&gt;Relay.QL&lt;/code&gt; string templates to JavaScript code that describes each query and includes data from the GraphQL schema.</source>
          <target state="translated">リレーは使用&lt;strong&gt;バベル&lt;/strong&gt;から変換するには、プラグインを &lt;code&gt;Relay.QL&lt;/code&gt; の各クエリを記述し、GraphQLスキーマからのデータを含むJavaScriptコードに文字列テンプレート。</target>
        </trans-unit>
        <trans-unit id="5ab5569c1247a6342fa21f23bd4fe7b1d8d672c4" translate="yes" xml:space="preserve">
          <source>Relay uses a common pattern for mutations, where they are root fields on the mutation type with a single argument, &lt;code&gt;input&lt;/code&gt;, and where the input and output both contain a client mutation identifier used to reconcile requests and responses.</source>
          <target state="translated">リレーはミューテーションに共通のパターンを使用します。これらは単一の引数 &lt;code&gt;input&lt;/code&gt; を持つミューテーションタイプのルートフィールドであり、入力と出力の両方にリクエストとレスポンスの調整に使用されるクライアントミューテーション識別子が含まれます。</target>
        </trans-unit>
        <trans-unit id="dd4a65f25979a2d6ac22ff73e832b56882a6731f" translate="yes" xml:space="preserve">
          <source>Relay uses all of this functionality to build out abstractions around connections, to make these easy to work with efficiently without having to manually manage cursors on the client.</source>
          <target state="translated">Relayではこの機能をすべて使用して接続の抽象化を構築し、クライアント上でカーソルを手動で管理しなくても効率的に作業ができるようにしています。</target>
        </trans-unit>
        <trans-unit id="3dc783e9ac2c6bb867e37e0f714a2ddf7651506d" translate="yes" xml:space="preserve">
          <source>Relay uses directives to add additional information to GraphQL documents, which are used by the &lt;a href=&quot;#relay-compiler&quot;&gt;Relay Compiler&lt;/a&gt; to generate the appropriate runtime artifacts. These directives only appear in your application code and are removed from requests sent to your GraphQL server.</source>
          <target state="translated">リレーで使用されているGraphQL文書に情報を追加するためのディレクティブを使用して&lt;a href=&quot;#relay-compiler&quot;&gt;リレーコンパイラ&lt;/a&gt;、適切なランタイム成果物を生成します。これらのディレクティブはアプリケーションコードにのみ表示され、GraphQLサーバーに送信されるリクエストから削除されます。</target>
        </trans-unit>
        <trans-unit id="7215a332ba837f6189ba19038b406a179e835435" translate="yes" xml:space="preserve">
          <source>Relay uses routes to define entry points into a Relay application.</source>
          <target state="translated">Relayでは、Relayアプリケーションへのエントリーポイントを定義するためにルートを使用します。</target>
        </trans-unit>
        <trans-unit id="c47cadca2b04900115d6a0cc7ce416c63eeb2c11" translate="yes" xml:space="preserve">
          <source>Relay uses the Relay Compiler to convert &lt;a href=&quot;#graphql&quot;&gt;&lt;code&gt;graphql&lt;/code&gt;&lt;/a&gt; literals into generated files that live alongside your source files.</source>
          <target state="translated">Relayは、Relayコンパイラーを使用して、&lt;a href=&quot;#graphql&quot;&gt; &lt;code&gt;graphql&lt;/code&gt; &lt;/a&gt;リテラルを、ソースファイルと一緒に存在する生成ファイルに変換します。</target>
        </trans-unit>
        <trans-unit id="e84f12bb76c08fcf1ebc1d56caf39b1024a1f70b" translate="yes" xml:space="preserve">
          <source>Relay v1.0 introduces the Relay Modern API:</source>
          <target state="translated">Relay v1.0にはRelay Modern APIが導入されています。</target>
        </trans-unit>
        <trans-unit id="59061b6874678f961da16dff064bafb7cf4ff327" translate="yes" xml:space="preserve">
          <source>Relay will then automatically update the fields under the record corresponding to the ids in the response payload.</source>
          <target state="translated">その後、Relayはレスポンス・ペイロードのidに対応するレコードの下のフィールドを自動的に更新します。</target>
        </trans-unit>
        <trans-unit id="7c3c5e271e633d2cf5f26344b18759ea44b95380" translate="yes" xml:space="preserve">
          <source>Relay wraps its core processing functions inside lightweight tasks, which by default are executed immediately (i.e. synchronously). In order to customize &lt;em&gt;when&lt;/em&gt; these tasks are run - for example to avoid interrupting an animation during a touch gesture - applications can provide a custom scheduling function.</source>
          <target state="translated">リレーは、そのコア処理機能を軽量タスク内にラップします。軽量タスクは、デフォルトですぐに（つまり、同期的に）実行されます。これらのタスクを&lt;em&gt;いつ&lt;/em&gt;実行するかをカスタマイズ&lt;em&gt;する&lt;/em&gt;ために（たとえば、タッチジェスチャー中にアニメーションが中断されないようにするため）、アプリケーションはカスタムスケジューリング機能を提供できます。</target>
        </trans-unit>
        <trans-unit id="576baa5c970e0023c6b7f930fc5b22d07e80b876" translate="yes" xml:space="preserve">
          <source>Relay's approach to data-fetching is heavily inspired by our experience with React. In particular, React breaks complex interfaces into reusable &lt;strong&gt;components&lt;/strong&gt;, allowing developers to reason about discrete units of an application in isolation, and reducing the coupling between disparate parts of an application. Even more important is that these components are &lt;strong&gt;declarative&lt;/strong&gt;: they allow developers to specify &lt;em&gt;what&lt;/em&gt; the UI should look like for a given state, and not have to worry about &lt;em&gt;how&lt;/em&gt; to show that UI. Unlike previous approaches that used imperative commands to manipulate native views (e.g. the DOM), React uses a UI description to automatically determine the necessary commands.</source>
          <target state="translated">Relayのデータ取得へのアプローチは、Reactでの経験に強く影響を受けています。特に、Reactは複雑なインターフェースを再利用可能な&lt;strong&gt;コンポーネント&lt;/strong&gt;に分割し&lt;strong&gt;ます&lt;/strong&gt;。これにより、開発者はアプリケーションの個別のユニットを分離して推論でき、アプリケーションの異なる部分間の結合を減らします。さらに重要なことは、これらのコンポーネントが&lt;strong&gt;宣言的である&lt;/strong&gt;ということです。これにより、開発者は特定の状態でUIがどのように見える&lt;em&gt;か&lt;/em&gt;を指定でき、そのUIの表示&lt;em&gt;方法&lt;/em&gt;を気にする必要がありません。命令型コマンドを使用してネイティブビュー（DOMなど）を操作する以前のアプローチとは異なり、ReactはUI記述を使用して必要なコマンドを自動的に決定します。</target>
        </trans-unit>
        <trans-unit id="6b33d0db31f7976b67c0c833688c3f1a2f3ed1a7" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation</source>
          <target state="translated">Relay.GraphQLMutation</target>
        </trans-unit>
        <trans-unit id="1dd1eeecd4591e6fc51ed50ccec4372072ef5f58" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#applyOptimistic()</source>
          <target state="translated">Relay.GraphQLMutation#applyOptimistic()</target>
        </trans-unit>
        <trans-unit id="778c7e41e609c680486529c141869bd60529ad4f" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#commit()</source>
          <target state="translated">Relay.GraphQLMutation#commit()</target>
        </trans-unit>
        <trans-unit id="3dd83b3b4baca74ae215635dc8057361bd27c698" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#constructor()</source>
          <target state="translated">Relay.GraphQLMutation#constructor()</target>
        </trans-unit>
        <trans-unit id="c60b9c934ff71ffb2a3ed3d72c60871bbe0e468e" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#rollback()</source>
          <target state="translated">Relay.GraphQLMutation#rollback()</target>
        </trans-unit>
        <trans-unit id="3340870222c54d4e58da2c45216a0f9201d39a18" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation.create()</source>
          <target state="translated">Relay.GraphQLMutation.create()</target>
        </trans-unit>
        <trans-unit id="a23c2d405f689b19dfd1fd7c28df5c48a68add1e" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation.createWithFiles()</source>
          <target state="translated">Relay.GraphQLMutation.createWithFiles()</target>
        </trans-unit>
        <trans-unit id="03551f79ebf3cd05d7c2ceaa3bea55c92b64e6d0" translate="yes" xml:space="preserve">
          <source>Relay.Mutation</source>
          <target state="translated">Relay.Mutation</target>
        </trans-unit>
        <trans-unit id="3ba32adda774e85164beb595e60d2e216978176e" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#constructor()</source>
          <target state="translated">Relay.Mutation#constructor()</target>
        </trans-unit>
        <trans-unit id="04100c1f256b9742428fc3ccbb91ce26474f7916" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getCollisionKey()</source>
          <target state="translated">Relay.Mutation#getCollisionKey()</target>
        </trans-unit>
        <trans-unit id="6239b4b0c4bd148ddc88ff80a2414323538280f1" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getConfigs()</source>
          <target state="translated">Relay.Mutation#getConfigs()</target>
        </trans-unit>
        <trans-unit id="ef63d6cc19f0b592de123cd60ec1e1b1998d6f17" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getFatQuery()</source>
          <target state="translated">Relay.Mutation#getFatQuery()</target>
        </trans-unit>
        <trans-unit id="712207e70740181f3ab2120dc0f2bcc301c5f54e" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getFiles()</source>
          <target state="translated">Relay.Mutation#getFiles()</target>
        </trans-unit>
        <trans-unit id="e97a189b3ae9338d83696e14598b587f01455562" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getMutation()</source>
          <target state="translated">Relay.Mutation#getMutation()</target>
        </trans-unit>
        <trans-unit id="9ef4e47c4ce8d138fc8484b73b762f8325ab6d50" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getOptimisticConfigs()</source>
          <target state="translated">Relay.Mutation#getOptimisticConfigs()</target>
        </trans-unit>
        <trans-unit id="9c72c0ca95feabd409adccf873cc396f84f49fa7" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getOptimisticResponse()</source>
          <target state="translated">Relay.Mutation#getOptimisticResponse()</target>
        </trans-unit>
        <trans-unit id="0407ffada104593511af47973fbf4f161321629f" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getVariables()</source>
          <target state="translated">Relay.Mutation#getVariables()</target>
        </trans-unit>
        <trans-unit id="25241731d9b8a5e3bb893a8a7166ea0d07b29738" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.fragments</source>
          <target state="translated">Relay.Mutation.fragments</target>
        </trans-unit>
        <trans-unit id="b7852fe98838e6fc1d72feab70dfa349933b9a4f" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.getFragment()</source>
          <target state="translated">Relay.Mutation.getFragment()</target>
        </trans-unit>
        <trans-unit id="d9618c47616902c437879ab1fb98a8eb932feeeb" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.initialVariables</source>
          <target state="translated">Relay.Mutation.initialVariables</target>
        </trans-unit>
        <trans-unit id="88607afefb79afbc0a5c6c2204c3c59784086c6d" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.prepareVariables</source>
          <target state="translated">Relay.Mutation.prepareVariables</target>
        </trans-unit>
        <trans-unit id="15cdd01f7f3228bf705c67fcca4cc7376e38847b" translate="yes" xml:space="preserve">
          <source>Relay.PropTypes</source>
          <target state="translated">Relay.PropTypes</target>
        </trans-unit>
        <trans-unit id="0af8bcf2b06b250091c5a6a9f45a93a8ec335270" translate="yes" xml:space="preserve">
          <source>Relay.PropTypes.QueryConfig: ReactPropTypeValidator</source>
          <target state="translated">Relay.PropTypes.QueryConfig.ReactPropTypeValidator</target>
        </trans-unit>
        <trans-unit id="991536fff9faf615e80c1b42bfda61b3395074a1" translate="yes" xml:space="preserve">
          <source>Relay.QL</source>
          <target state="translated">Relay.QL</target>
        </trans-unit>
        <trans-unit id="e66127f684a064c2b23590835fd5fc4afce5e3bc" translate="yes" xml:space="preserve">
          <source>Relay.Renderer</source>
          <target state="translated">Relay.Renderer</target>
        </trans-unit>
        <trans-unit id="1e64d297283159c1fd5f3c0f4f7f2590f52aeaf0" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#Container</source>
          <target state="translated">Relay.Renderer#Container</target>
        </trans-unit>
        <trans-unit id="0f68d914b2de005998fdb01ba1b1095a495e227d" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#environment</source>
          <target state="translated">Relay.Renderer#environment</target>
        </trans-unit>
        <trans-unit id="8e4cc916528c14e528833e3f79df2da75fd53acb" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#forceFetch</source>
          <target state="translated">Relay.Renderer#forceFetch</target>
        </trans-unit>
        <trans-unit id="bf0a7bc1a436c9a32f0f42831033b65d5cfbaf43" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#onReadyStateChange</source>
          <target state="translated">Relay.Renderer#onReadyStateChange</target>
        </trans-unit>
        <trans-unit id="9c4d750f130c80ae940ddef73d72538928767978" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#queryConfig</source>
          <target state="translated">Relay.Renderer#queryConfig</target>
        </trans-unit>
        <trans-unit id="ff227ea702919a6f75cb559ade588c7d11c20c78" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#render</source>
          <target state="translated">Relay.Renderer#render</target>
        </trans-unit>
        <trans-unit id="2761fdabd570b4cb3fdee157bed2ad5cb9ae4930" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer</source>
          <target state="translated">Relay.RootContainer</target>
        </trans-unit>
        <trans-unit id="543cce18705fbddda91e09c015e6da78c821e550" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#Component</source>
          <target state="translated">Relay.RootContainer#Component</target>
        </trans-unit>
        <trans-unit id="4c1d8599b11aa80027feab65c33b5f34aece2fe8" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#forceFetch</source>
          <target state="translated">Relay.RootContainer#forceFetch</target>
        </trans-unit>
        <trans-unit id="69120820a45037f7a9e51a705842b61000d0ac96" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#onReadyStateChange</source>
          <target state="translated">Relay.RootContainer#onReadyStateChange</target>
        </trans-unit>
        <trans-unit id="0b9faeb15a496f220a6b405a981a20f8ef453965" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#renderFailure</source>
          <target state="translated">Relay.RootContainer#renderFailure</target>
        </trans-unit>
        <trans-unit id="7bd3ce353967f7aff355ff3522f40b703a8bd047" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#renderFetched</source>
          <target state="translated">Relay.RootContainer#renderFetched</target>
        </trans-unit>
        <trans-unit id="8e6dba1eefc9476de73a3eb76f6a4bb45f2d9827" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#renderLoading</source>
          <target state="translated">Relay.RootContainer#renderLoading</target>
        </trans-unit>
        <trans-unit id="a9647a1d13d1b00fb81a049cb69e0f50d9005610" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#route</source>
          <target state="translated">Relay.RootContainer#route</target>
        </trans-unit>
        <trans-unit id="2163890d6b8486ab713e8307739f1fc8ffdc4051" translate="yes" xml:space="preserve">
          <source>Relay.Route</source>
          <target state="translated">Relay.Route</target>
        </trans-unit>
        <trans-unit id="ec4ec0225d1b12f051db712106148d8b26db80c7" translate="yes" xml:space="preserve">
          <source>Relay.Route#constructor()</source>
          <target state="translated">Relay.Route#constructor()</target>
        </trans-unit>
        <trans-unit id="933d2afe910e8eed75954f1ef8511fc9c8104ede" translate="yes" xml:space="preserve">
          <source>Relay.Route.paramDefinitions</source>
          <target state="translated">Relay.Route.paramDefinitions</target>
        </trans-unit>
        <trans-unit id="be2c5425ec7dbd5886d4716f82a79360b73375a7" translate="yes" xml:space="preserve">
          <source>Relay.Route.prepareParams</source>
          <target state="translated">Relay.Route.prepareParams</target>
        </trans-unit>
        <trans-unit id="632587b7cd190cd1537600ee207e20b1ff9030d5" translate="yes" xml:space="preserve">
          <source>Relay.Route.queries</source>
          <target state="translated">Relay.Route.queries</target>
        </trans-unit>
        <trans-unit id="90af1f420232cc590b9eb96c3c9344d637dded41" translate="yes" xml:space="preserve">
          <source>Relay.Route.routeName</source>
          <target state="translated">Relay.Route.routeName</target>
        </trans-unit>
        <trans-unit id="596c88b6dd79bb8e709c7b945308e399ac2abc3a" translate="yes" xml:space="preserve">
          <source>Relay.Store</source>
          <target state="translated">Relay.Store</target>
        </trans-unit>
        <trans-unit id="1ca8451821663a9beeafb5041c9c0bfdf4aff046" translate="yes" xml:space="preserve">
          <source>Relay.Store.applyUpdate()</source>
          <target state="translated">Relay.Store.applyUpdate()</target>
        </trans-unit>
        <trans-unit id="23f95eef5a8ff15d45d59ef33e2757420f465ed8" translate="yes" xml:space="preserve">
          <source>Relay.Store.commitUpdate()</source>
          <target state="translated">Relay.Store.commitUpdate()</target>
        </trans-unit>
        <trans-unit id="5435b8d8380c04f42e516eb3bd9326e46359b1b6" translate="yes" xml:space="preserve">
          <source>Relay.createContainer()</source>
          <target state="translated">Relay.createContainer()</target>
        </trans-unit>
        <trans-unit id="12f5066f2601943d9aac424bb916a7d3e8a44732" translate="yes" xml:space="preserve">
          <source>Relay.injectNetworkLayer()</source>
          <target state="translated">Relay.injectNetworkLayer()</target>
        </trans-unit>
        <trans-unit id="1a735b56a61cab41febb27320e2f243ed493b94f" translate="yes" xml:space="preserve">
          <source>Relay.injectTaskScheduler()</source>
          <target state="translated">Relay.injectTaskScheduler()</target>
        </trans-unit>
        <trans-unit id="309387769d52bfb1d6f330d2a6e3ecd71ecb41e1" translate="yes" xml:space="preserve">
          <source>Relay.isContainer()</source>
          <target state="translated">Relay.isContainer()</target>
        </trans-unit>
        <trans-unit id="c772f86aadb639ca41aafc4ec6f52aaae43e0acf" translate="yes" xml:space="preserve">
          <source>RelayContainer</source>
          <target state="translated">RelayContainer</target>
        </trans-unit>
        <trans-unit id="76e743848043959a7f2bfa720b5616417bb798e1" translate="yes" xml:space="preserve">
          <source>RelayContainer implements a conservative default &lt;code&gt;shouldComponentUpdate&lt;/code&gt; that returns &lt;code&gt;false&lt;/code&gt; if no fragment props have changed and all other props are equal scalar values. This may block updates to components that receive data via context. To ensure an update in this case override the default behavior by specifying a &lt;code&gt;shouldComponentUpdate&lt;/code&gt; function.</source>
          <target state="translated">RelayContainerは、フラグメントの小道具が変更されておらず、他のすべての小道具が同じスカラー値である場合に &lt;code&gt;false&lt;/code&gt; を返す控えめなデフォルト &lt;code&gt;shouldComponentUpdate&lt;/code&gt; を実装しています。これにより、コンテキストを介してデータを受信するコンポーネントの更新がブロックされる可能性があります。この場合の更新を保証するには、 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 関数を指定してデフォルトの動作をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="83d048709f5073df975dc9c425226f037d2ced9a" translate="yes" xml:space="preserve">
          <source>RelayContainer#forceFetch()</source>
          <target state="translated">RelayContainer#forceFetch()</target>
        </trans-unit>
        <trans-unit id="12306a7598448404edb2c73ef03ebd3b1459df33" translate="yes" xml:space="preserve">
          <source>RelayContainer#fragments</source>
          <target state="translated">RelayContainer#fragments</target>
        </trans-unit>
        <trans-unit id="fa4bac3fc05c361b8142cf895c4dec7b9136e491" translate="yes" xml:space="preserve">
          <source>RelayContainer#getFragment()</source>
          <target state="translated">RelayContainer#getFragment()</target>
        </trans-unit>
        <trans-unit id="0f0d5c6a56d86ccbcf94f9197715dbb511dcccda" translate="yes" xml:space="preserve">
          <source>RelayContainer#getPendingTransactions()</source>
          <target state="translated">RelayContainer#getPendingTransactions()</target>
        </trans-unit>
        <trans-unit id="3583e47f56ed32f6527e40cae51e9cd4226d6b8a" translate="yes" xml:space="preserve">
          <source>RelayContainer#hasOptimisticUpdate()</source>
          <target state="translated">RelayContainer#hasOptimisticUpdate()</target>
        </trans-unit>
        <trans-unit id="f6baca904aa4a3f9af8b6cef6a7995ee09553ec3" translate="yes" xml:space="preserve">
          <source>RelayContainer#initialVariables</source>
          <target state="translated">RelayContainer#initialVariables</target>
        </trans-unit>
        <trans-unit id="67aea36b1c5b679f64f0d153f256c81a818ebe83" translate="yes" xml:space="preserve">
          <source>RelayContainer#pendingVariables</source>
          <target state="translated">RelayContainer#pendingVariables</target>
        </trans-unit>
        <trans-unit id="9cce83d93b864bd7fad1aa07826c61d9a6ef284e" translate="yes" xml:space="preserve">
          <source>RelayContainer#prepareVariables</source>
          <target state="translated">RelayContainer#prepareVariables</target>
        </trans-unit>
        <trans-unit id="ef93161b93af5f5e98d21bb920dbacc9ffd1f25e" translate="yes" xml:space="preserve">
          <source>RelayContainer#route</source>
          <target state="translated">RelayContainer#route</target>
        </trans-unit>
        <trans-unit id="707b6138cca39388519379f5f0473ddd29369f7f" translate="yes" xml:space="preserve">
          <source>RelayContainer#setVariables()</source>
          <target state="translated">RelayContainer#setVariables()</target>
        </trans-unit>
        <trans-unit id="13dc088a9a8f1b885a4b30d133ebfc79f65f8a56" translate="yes" xml:space="preserve">
          <source>RelayContainer#shouldComponentUpdate</source>
          <target state="translated">RelayContainer#shouldComponentUpdate</target>
        </trans-unit>
        <trans-unit id="562b0d971d42af3b685406a662899de6e23e0ff8" translate="yes" xml:space="preserve">
          <source>RelayContainer#variables</source>
          <target state="translated">RelayContainer#variables</target>
        </trans-unit>
        <trans-unit id="cf0a077ddadfb043fbdeb8a931f05f97f9dec4db" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest</source>
          <target state="translated">RelayMutationRequest</target>
        </trans-unit>
        <trans-unit id="459733a291121fc4443f52543c52bf1ba049dc6a" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getDebugName()</source>
          <target state="translated">RelayMutationRequest#getDebugName()</target>
        </trans-unit>
        <trans-unit id="e6aac4071918a71d5a4437bcf00846a0803cb431" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getFiles()</source>
          <target state="translated">RelayMutationRequest#getFiles()</target>
        </trans-unit>
        <trans-unit id="98f8235cb1f82e31b63e4abc739976992bfb5247" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getID()</source>
          <target state="translated">RelayMutationRequest#getID()</target>
        </trans-unit>
        <trans-unit id="aced70c9403a7f1d9071b6bdae3bf77f17f27954" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getQueryString()</source>
          <target state="translated">RelayMutationRequest#getQueryString()</target>
        </trans-unit>
        <trans-unit id="f6fd4f67bc834b8917c668afd31ee438a325f452" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getVariables()</source>
          <target state="translated">RelayMutationRequest#getVariables()</target>
        </trans-unit>
        <trans-unit id="20f8806483b79b8a279be2b49be8c750a67cdb41" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer</source>
          <target state="translated">RelayNetworkLayer</target>
        </trans-unit>
        <trans-unit id="7f0a8ef7b7a43a9933addcbaef565eff07884834" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer#sendMutation()</source>
          <target state="translated">RelayNetworkLayer#sendMutation()</target>
        </trans-unit>
        <trans-unit id="67d40797657bd24a84a171e652a9bea818a15d96" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer#sendQueries()</source>
          <target state="translated">RelayNetworkLayer#sendQueries()</target>
        </trans-unit>
        <trans-unit id="eacde2e3a9c41d29b2ee433848dfea8232a5d22a" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer#supports()</source>
          <target state="translated">RelayNetworkLayer#supports()</target>
        </trans-unit>
        <trans-unit id="5113dd07f144f50d7677810b044a345b89e66e0e" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest</source>
          <target state="translated">RelayQueryRequest</target>
        </trans-unit>
        <trans-unit id="4a9c272793946b8bdd3a09cdfbde6dc8574faf62" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getDebugName()</source>
          <target state="translated">RelayQueryRequest#getDebugName()</target>
        </trans-unit>
        <trans-unit id="481aa62146f5343b4ba1062802709201d6d4d7af" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getID()</source>
          <target state="translated">RelayQueryRequest#getID()</target>
        </trans-unit>
        <trans-unit id="0f467922406404a5eac2d6f11b736b9d66633025" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getQueryString()</source>
          <target state="translated">RelayQueryRequest#getQueryString()</target>
        </trans-unit>
        <trans-unit id="981023af3724c0e925cbc3f99f867f132178c714" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getVariables()</source>
          <target state="translated">RelayQueryRequest#getVariables()</target>
        </trans-unit>
        <trans-unit id="8324e4ecabe765d0034c56fc8f4c857ecfa3e2ae" translate="yes" xml:space="preserve">
          <source>RelayRecordProxy</source>
          <target state="translated">RelayRecordProxy</target>
        </trans-unit>
        <trans-unit id="69b9a9d8ad89e9af43d214607d3ff0018325568c" translate="yes" xml:space="preserve">
          <source>RelayRecordStore</source>
          <target state="translated">RelayRecordStore</target>
        </trans-unit>
        <trans-unit id="8aa27a7e83012be706218f33db1f656ebf3d0b47" translate="yes" xml:space="preserve">
          <source>Render Callbacks</source>
          <target state="translated">レンダーコールバック</target>
        </trans-unit>
        <trans-unit id="e066e80468f5234a1001137061731ae39a651ab5" translate="yes" xml:space="preserve">
          <source>Rendering</source>
          <target state="translated">Rendering</target>
        </trans-unit>
        <trans-unit id="db86b99e5c8c7fa5281608698558232d5c55e13b" translate="yes" xml:space="preserve">
          <source>Rendering Containers</source>
          <target state="translated">レンダリングコンテナ</target>
        </trans-unit>
        <trans-unit id="af597671c6dcfa1df34e2e38251238001351c84d" translate="yes" xml:space="preserve">
          <source>Repeatedly refetching information from the server can get quite slow. For example, navigating from the list of stories, to a list item, and back to the list of stories means we have to refetch the whole list. We'll solve this with the standard solution: &lt;em&gt;caching&lt;/em&gt;.</source>
          <target state="translated">サーバーから繰り返し情報を再フェッチすると、かなり遅くなる可能性があります。たとえば、ストーリーのリストからリストアイテムに移動し、ストーリーのリストに戻るには、リスト全体を再フェッチする必要があります。これを標準のソリューションである&lt;em&gt;キャッシングで&lt;/em&gt;解決します。</target>
        </trans-unit>
        <trans-unit id="3341adcc90aa2cf65b0ed4f78d46fafd5dfc9cd5" translate="yes" xml:space="preserve">
          <source>Requesting Different Data</source>
          <target state="translated">異なるデータを要求する</target>
        </trans-unit>
        <trans-unit id="b092a39c824d57357df89b0ece2eb1e4c9834cca" translate="yes" xml:space="preserve">
          <source>Require the Relay Compat API from &lt;code&gt;'react-relay/compat'&lt;/code&gt; and use it as you would Relay Modern. The components using Relay Compat can be referred to by both other Relay Modern and Relay Classic components.</source>
          <target state="translated">&lt;code&gt;'react-relay/compat'&lt;/code&gt; のRelay Compat APIを要求し、Relay Modernと同じように使用します。Relay Compatを使用するコンポーネントは、他のRelay ModernコンポーネントとRelay Classicコンポーネントの両方から参照できます。</target>
        </trans-unit>
        <trans-unit id="61ac8791c7043a10705ecb741c56abf9848abf0a" translate="yes" xml:space="preserve">
          <source>Resolving Data from the Client</source>
          <target state="translated">クライアントからのデータを解決する</target>
        </trans-unit>
        <trans-unit id="3281bf767244e09b6483581e4d93f748c54eb136" translate="yes" xml:space="preserve">
          <source>Response-caching can also be applied to GraphQL. A basic approach would work similarly to the REST version. The text of the query itself can be used as a cache key:</source>
          <target state="translated">レスポンスキャッシュは GraphQL にも適用できます。基本的なアプローチはREST版と同じように動作します。クエリのテキスト自体をキャッシュキーとして使用することができます。</target>
        </trans-unit>
        <trans-unit id="1daed2e622c367b716a7da87b2e2edd04d8d8e79" translate="yes" xml:space="preserve">
          <source>Retrieves a record associated with the current record given the field name, as defined by the GraphQL document. Returns a &lt;code&gt;RecordProxy&lt;/code&gt;.</source>
          <target state="translated">GraphQLドキュメントで定義されているように、フィールド名を指定して現在のレコードに関連付けられているレコードを取得します。 &lt;code&gt;RecordProxy&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="a06b7b5f5bbad1dc68e21eaac11574c07de428a8" translate="yes" xml:space="preserve">
          <source>Retrieves a record from the store given its &lt;code&gt;dataID&lt;/code&gt;. Returns a &lt;a href=&quot;#recordproxy&quot;&gt;&lt;code&gt;RecordProxy&lt;/code&gt;&lt;/a&gt; which serves as an interface to mutate the record.</source>
          <target state="translated">&lt;code&gt;dataID&lt;/code&gt; を指定してストアからレコードを取得します。&lt;a href=&quot;#recordproxy&quot;&gt; &lt;code&gt;RecordProxy&lt;/code&gt; &lt;/a&gt;を変更するためのインターフェイスとして機能するRecordProxyを返します。</target>
        </trans-unit>
        <trans-unit id="12402592aaf37a5d3ace23c3d09e0cda3355dad6" translate="yes" xml:space="preserve">
          <source>Retrieves a root field from the store given the &lt;code&gt;fieldName&lt;/code&gt;, as defined by the GraphQL document. Returns a &lt;a href=&quot;#recordproxy&quot;&gt;&lt;code&gt;RecordProxy&lt;/code&gt;&lt;/a&gt; which serves as an interface to mutate the record.</source>
          <target state="translated">GraphQLドキュメントで定義されているように、 &lt;code&gt;fieldName&lt;/code&gt; を指定してストアからルートフィールドを取得します。&lt;a href=&quot;#recordproxy&quot;&gt; &lt;code&gt;RecordProxy&lt;/code&gt; &lt;/a&gt;を変更するためのインターフェイスとして機能するRecordProxyを返します。</target>
        </trans-unit>
        <trans-unit id="17061c12897cde333bc27d9d3b5b4885efbba0b0" translate="yes" xml:space="preserve">
          <source>Retrieves a root field that represents a collection from the store given the &lt;code&gt;fieldName&lt;/code&gt;, as defined by the GraphQL document. Returns an array of &lt;a href=&quot;#recordproxy&quot;&gt;&lt;code&gt;RecordProxies&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GraphQLドキュメントで定義されているように、 &lt;code&gt;fieldName&lt;/code&gt; を指定してストアからコレクションを表すルートフィールドを取得します。&lt;a href=&quot;#recordproxy&quot;&gt; &lt;code&gt;RecordProxies&lt;/code&gt; の&lt;/a&gt;配列を返します。</target>
        </trans-unit>
        <trans-unit id="81554eb7c1007a0bac823cb3e3ca325777b63f97" translate="yes" xml:space="preserve">
          <source>Retrieves record(s) associated with the given record, transversing the source by field name and an object representing pre-defined argument values.</source>
          <target state="translated">指定されたレコードに関連付けられたレコードを、フィールド名と事前に定義された引数の値を表すオブジェクトによってソースを横切って取得します。</target>
        </trans-unit>
        <trans-unit id="0df40cacc16f0f75e7289c7b00fb27121dcf4af7" translate="yes" xml:space="preserve">
          <source>Retrieves the a record associated with the current record given the field name, as defined by the GraphQL document. If the linked record does not exist, it will be created given the type name. Returns a &lt;code&gt;RecordProxy&lt;/code&gt;.</source>
          <target state="translated">GraphQLドキュメントで定義されているように、フィールド名を指定して現在のレコードに関連付けられているレコードを取得します。リンクされたレコードが存在しない場合は、タイプ名を付けて作成されます。 &lt;code&gt;RecordProxy&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="379be92d54161c2f80dceac4cdce0230264cb208" translate="yes" xml:space="preserve">
          <source>Retrieves the set of records associated with the current record given the field name, as defined by the GraphQL document. Returns an array of &lt;code&gt;RecordProxies&lt;/code&gt;.</source>
          <target state="translated">GraphQLドキュメントで定義されているように、フィールド名を指定して現在のレコードに関連付けられているレコードのセットを取得します。 &lt;code&gt;RecordProxies&lt;/code&gt; の配列を返します。</target>
        </trans-unit>
        <trans-unit id="e013c79a69f7fdde5c1472633a22316f0ef0ef72" translate="yes" xml:space="preserve">
          <source>Retrying failed requests.</source>
          <target state="translated">失敗したリクエストを再試行しています。</target>
        </trans-unit>
        <trans-unit id="4ed1a51e3c7c6cf43a3633b3e58f69e74b9dd263" translate="yes" xml:space="preserve">
          <source>Return Value</source>
          <target state="translated">戻り値</target>
        </trans-unit>
        <trans-unit id="6e358acbbc41f30837ea01e45fb712ceb42c930a" translate="yes" xml:space="preserve">
          <source>Returns a &lt;code&gt;Disposable&lt;/code&gt; on which you could call &lt;code&gt;dispose()&lt;/code&gt; to cancel the refetch.</source>
          <target state="translated">&lt;code&gt;dispose()&lt;/code&gt; を呼び出して再フェッチをキャンセルできる &lt;code&gt;Disposable&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="56de3c3d136f4071d757cabe4b6ed2c52a5dad01" translate="yes" xml:space="preserve">
          <source>Returns a proxy class for manipulating records from a record source, for example a query, mutation, or the store.</source>
          <target state="translated">クエリや突然変異、ストアなどのレコードソースからレコードを操作するためのプロキシクラスを返します。</target>
        </trans-unit>
        <trans-unit id="91f8449d9fa8e9ef7aa99597a20ab0dcfe5b332a" translate="yes" xml:space="preserve">
          <source>Returns a read-only view of the store's internal RecordSource that holds all records.</source>
          <target state="translated">すべてのレコードを保持するストアの内部RecordSourceの読み取り専用ビューを返します。</target>
        </trans-unit>
        <trans-unit id="ddc37b98bab248dd41f22f1276390ce274609bd3" translate="yes" xml:space="preserve">
          <source>Returns the &lt;a href=&quot;#recordproxy&quot;&gt;&lt;code&gt;RecordProxy&lt;/code&gt;&lt;/a&gt; representing the root of the GraphQL document.</source>
          <target state="translated">GraphQLドキュメントのルートを表す&lt;a href=&quot;#recordproxy&quot;&gt; &lt;code&gt;RecordProxy&lt;/code&gt; &lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="6a9d68c06d14e4ad8d6a81f1e355b118c27b1408" translate="yes" xml:space="preserve">
          <source>Returns the GraphQL type name for a given record.</source>
          <target state="translated">指定したレコードの GraphQL 型名を返します。</target>
        </trans-unit>
        <trans-unit id="d43e7555e127344d4f989c546065e0799ff790bb" translate="yes" xml:space="preserve">
          <source>Returns the dataID of the current record.</source>
          <target state="translated">現在のレコードのdataIDを返します。</target>
        </trans-unit>
        <trans-unit id="384ac89b24069cf234b54ff56b3d6d5c565f33c7" translate="yes" xml:space="preserve">
          <source>Returns the globally unique identifier string for a record.</source>
          <target state="translated">レコードのグローバルに一意な識別子文字列を返します。</target>
        </trans-unit>
        <trans-unit id="7d0eb64e469d72e6ccf94d6d96498f73ad0e6f27" translate="yes" xml:space="preserve">
          <source>Reusable fragments to compose within the above use cases.</source>
          <target state="translated">上記のユースケース内で構成するための再利用可能なフラグメント。</target>
        </trans-unit>
        <trans-unit id="72e1985969f053f8609f492cf63340c5c4f7f3fc" translate="yes" xml:space="preserve">
          <source>Rolls back an optimistic mutation.</source>
          <target state="translated">楽観的な突然変異をロールバックする。</target>
        </trans-unit>
        <trans-unit id="0dfddbb0a122d3a2969eb11e085210ba893e7399" translate="yes" xml:space="preserve">
          <source>Root Container</source>
          <target state="translated">ルートコンテナ</target>
        </trans-unit>
        <trans-unit id="1bf5197778bc12b8d4edfe1a0c2de1ced169d30b" translate="yes" xml:space="preserve">
          <source>RootContainer</source>
          <target state="translated">RootContainer</target>
        </trans-unit>
        <trans-unit id="4999528efe0f94f8f66b1dc05aad8ebaaae7b2be" translate="yes" xml:space="preserve">
          <source>Route</source>
          <target state="translated">Route</target>
        </trans-unit>
        <trans-unit id="52c021a7e89ad4e72cef6096b3c6424e78876574" translate="yes" xml:space="preserve">
          <source>Route is useful in providing the context which a component is being rendered in. It includes information about the &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;params&lt;/code&gt;, and &lt;code&gt;queries&lt;/code&gt; of the current route.</source>
          <target state="translated">ルートは、コンポーネントがレンダリングされているコンテキストを提供するのに役立ちます。これには、現在のルートの &lt;code&gt;name&lt;/code&gt; 、 &lt;code&gt;params&lt;/code&gt; 、および &lt;code&gt;queries&lt;/code&gt; に関する情報が含まれます。</target>
        </trans-unit>
        <trans-unit id="03730e58401ef5d9e79d1f674df0a5f9cf756e33" translate="yes" xml:space="preserve">
          <source>Routes</source>
          <target state="translated">Routes</target>
        </trans-unit>
        <trans-unit id="0bd75f049435ac9bea4df8ce63749bdcfaaef9e4" translate="yes" xml:space="preserve">
          <source>Routes and Queries</source>
          <target state="translated">ルートとクエリ</target>
        </trans-unit>
        <trans-unit id="a476715db16204d7e6fb7743a314ee35337241d4" translate="yes" xml:space="preserve">
          <source>Routes are now optional: &lt;code&gt;QueryRenderer&lt;/code&gt; can be used without defining a route. More in the &lt;a href=&quot;routing&quot;&gt;routing guide&lt;/a&gt;.</source>
          <target state="translated">ルートはオプションになりました。ルートを定義せずに &lt;code&gt;QueryRenderer&lt;/code&gt; を使用できます。&lt;a href=&quot;routing&quot;&gt;ルーティングガイドの&lt;/a&gt;詳細。</target>
        </trans-unit>
        <trans-unit id="ca283153940483bc802b34b41123871d483749c7" translate="yes" xml:space="preserve">
          <source>Routes are objects that define a set of root queries and input parameters. Here is a simple route that might be used to render user &lt;code&gt;123&lt;/code&gt;'s profile:</source>
          <target state="translated">ルートは、ルートクエリと入力パラメーターのセットを定義するオブジェクトです。次に、ユーザー &lt;code&gt;123&lt;/code&gt; のプロファイルをレンダリングするために使用できる簡単なルートを示します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
