<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="48563266c944d99d9eaba5e60d33852a238c2d45" translate="yes" xml:space="preserve">
          <source>Weak reference objects, which do not prevent their referents from being made finalizable, finalized, and then reclaimed. Weak references are most often used to implement canonicalizing mappings.</source>
          <target state="translated">弱い参照オブジェクトは、その参照が確定可能な状態にされ、確定された後に再取得されることを妨げない。弱い参照は、正準化マッピングを実装するために最もよく使用されます。</target>
        </trans-unit>
        <trans-unit id="03229c3ce0e1d4a5dea21e64ed5a7a21dd50346b" translate="yes" xml:space="preserve">
          <source>WeakHashMap</source>
          <target state="translated">WeakHashMap</target>
        </trans-unit>
        <trans-unit id="9f578a1ece44744875548c14accd3ab118f52f96" translate="yes" xml:space="preserve">
          <source>WeakHashMap.clear()</source>
          <target state="translated">WeakHashMap.clear()</target>
        </trans-unit>
        <trans-unit id="cac8951d07963c9661fb7627c7267795d5e7a4f2" translate="yes" xml:space="preserve">
          <source>WeakHashMap.containsKey()</source>
          <target state="translated">WeakHashMap.containsKey()</target>
        </trans-unit>
        <trans-unit id="356e80282ac519184e65c488908383906447f348" translate="yes" xml:space="preserve">
          <source>WeakHashMap.containsValue()</source>
          <target state="translated">WeakHashMap.containsValue()</target>
        </trans-unit>
        <trans-unit id="60be0515876f006e6ca1cd3d7d552af9ccd01ffe" translate="yes" xml:space="preserve">
          <source>WeakHashMap.entrySet()</source>
          <target state="translated">WeakHashMap.entrySet()</target>
        </trans-unit>
        <trans-unit id="e49f5cd6e00c4432b7ebd63f64c70d97e2bfbb24" translate="yes" xml:space="preserve">
          <source>WeakHashMap.forEach()</source>
          <target state="translated">WeakHashMap.forEach()</target>
        </trans-unit>
        <trans-unit id="19b9a321a4f1bd958cc8610a953bd1ee99035128" translate="yes" xml:space="preserve">
          <source>WeakHashMap.get()</source>
          <target state="translated">WeakHashMap.get()</target>
        </trans-unit>
        <trans-unit id="a5a9ba4e04afb8fcdfc19b61079a8ebd40110696" translate="yes" xml:space="preserve">
          <source>WeakHashMap.isEmpty()</source>
          <target state="translated">WeakHashMap.isEmpty()</target>
        </trans-unit>
        <trans-unit id="7bd691f3c04552e56d59d519f1a4666a626cae68" translate="yes" xml:space="preserve">
          <source>WeakHashMap.keySet()</source>
          <target state="translated">WeakHashMap.keySet()</target>
        </trans-unit>
        <trans-unit id="3e34f391baf109443d3eca81db8e406c21247e08" translate="yes" xml:space="preserve">
          <source>WeakHashMap.put()</source>
          <target state="translated">WeakHashMap.put()</target>
        </trans-unit>
        <trans-unit id="b834ab3cef7770bc9b59513aef17274348ef63ed" translate="yes" xml:space="preserve">
          <source>WeakHashMap.putAll()</source>
          <target state="translated">WeakHashMap.putAll()</target>
        </trans-unit>
        <trans-unit id="51c4de9f87dd1095d9471573ff074fdefaf0db3e" translate="yes" xml:space="preserve">
          <source>WeakHashMap.remove()</source>
          <target state="translated">WeakHashMap.remove()</target>
        </trans-unit>
        <trans-unit id="77d99b79dc28fd6bd9db3b97d88184d2de438fd0" translate="yes" xml:space="preserve">
          <source>WeakHashMap.replaceAll()</source>
          <target state="translated">WeakHashMap.replaceAll()</target>
        </trans-unit>
        <trans-unit id="42ea52208a3ce498ea844af7690268dde31e784f" translate="yes" xml:space="preserve">
          <source>WeakHashMap.size()</source>
          <target state="translated">WeakHashMap.size()</target>
        </trans-unit>
        <trans-unit id="8bc55d91cb214228db71f61c09b537092b4bec12" translate="yes" xml:space="preserve">
          <source>WeakHashMap.values()</source>
          <target state="translated">WeakHashMap.values()</target>
        </trans-unit>
        <trans-unit id="5ea903ebda4f9f28f642d78e916dc09051395c95" translate="yes" xml:space="preserve">
          <source>WeakReference</source>
          <target state="translated">WeakReference</target>
        </trans-unit>
        <trans-unit id="bf85b22fdda959fc428f30bfb2a0f068edc191bf" translate="yes" xml:space="preserve">
          <source>WebRowSet</source>
          <target state="translated">WebRowSet</target>
        </trans-unit>
        <trans-unit id="fd2fe2179b44fad347e37ec201d26ab520f15318" translate="yes" xml:space="preserve">
          <source>WebSocket</source>
          <target state="translated">WebSocket</target>
        </trans-unit>
        <trans-unit id="8d50debedf657789eb83e5bb579d738443688767" translate="yes" xml:space="preserve">
          <source>WebSocket has an input and an output side. These sides are independent from each other. A side can either be open or closed. Once closed, the side remains closed. WebSocket messages are sent through a &lt;code&gt;WebSocket&lt;/code&gt; and received through a &lt;code&gt;WebSocket.Listener&lt;/code&gt; associated with it. Messages can be sent until the WebSocket's output is closed, and received until the WebSocket's input is closed.</source>
          <target state="translated">WebSocketには入力側と出力側があります。これらの側は互いに独立しています。側面は開いていても閉じていてもかまいません。閉じられると、側面は閉じたままになります。WebSocketメッセージは、 &lt;code&gt;WebSocket&lt;/code&gt; を介して送信され、それに関連付けられた &lt;code&gt;WebSocket.Listener&lt;/code&gt; を介して受信されます。メッセージは、WebSocketの出力が閉じられるまで送信でき、WebSocketの入力が閉じられるまで受信できます。</target>
        </trans-unit>
        <trans-unit id="9e7c0e37606b1f794c1372d83eddadb351ac3d9c" translate="yes" xml:space="preserve">
          <source>WebSocket.Builder</source>
          <target state="translated">WebSocket.Builder</target>
        </trans-unit>
        <trans-unit id="0de0866691e65f5871dab18f5e7b17347cdabb10" translate="yes" xml:space="preserve">
          <source>WebSocket.Listener</source>
          <target state="translated">WebSocket.Listener</target>
        </trans-unit>
        <trans-unit id="e5ae2288a1ae365d9dae39add24416582095231c" translate="yes" xml:space="preserve">
          <source>WebSocketHandshakeException</source>
          <target state="translated">WebSocketHandshakeException</target>
        </trans-unit>
        <trans-unit id="5656b9b79b0316fc611a9c30d2ffac25228b8371" translate="yes" xml:space="preserve">
          <source>Wednesday</source>
          <target state="translated">Wednesday</target>
        </trans-unit>
        <trans-unit id="10b774684253b67ed6046c62d38b42b91e852330" translate="yes" xml:space="preserve">
          <source>Week 0 of January 2009</source>
          <target state="translated">2009年1月の第0週</target>
        </trans-unit>
        <trans-unit id="7b27856c3025a48dfd145f75086cda19de2ee70e" translate="yes" xml:space="preserve">
          <source>Week 1 of 2009</source>
          <target state="translated">2009年1週目</target>
        </trans-unit>
        <trans-unit id="e0b134e5cd0d67c325ab9181f61674f7eb847f4f" translate="yes" xml:space="preserve">
          <source>Week 1 of January 2009</source>
          <target state="translated">2009年1月1週目</target>
        </trans-unit>
        <trans-unit id="0273a235d369407f5bc0d09e86dc0804188d2c3d" translate="yes" xml:space="preserve">
          <source>Week 1 of week-based-year 2009</source>
          <target state="translated">週ベースの年2009年第1週</target>
        </trans-unit>
        <trans-unit id="61c045f9f24b3b90a55c9f64fb89b4cf33f3dbdd" translate="yes" xml:space="preserve">
          <source>Week 2 of 2009</source>
          <target state="translated">2009年2週目</target>
        </trans-unit>
        <trans-unit id="16159932e1ca3544ef8dd1d77e4cd53b696ac5c6" translate="yes" xml:space="preserve">
          <source>Week 2 of January 2009</source>
          <target state="translated">2009年1月の2週目</target>
        </trans-unit>
        <trans-unit id="651b78362b5aaa1728d942efc5ee0ee574ce4c00" translate="yes" xml:space="preserve">
          <source>Week 2 of week-based-year 2009</source>
          <target state="translated">週ベースの年2009年第2週</target>
        </trans-unit>
        <trans-unit id="fc5ccf6381813c151159e75357417f783c0aec41" translate="yes" xml:space="preserve">
          <source>Week 5 of December 2008</source>
          <target state="translated">2008年12月第5週</target>
        </trans-unit>
        <trans-unit id="a6c2f210f4569dac04f3823e9662a42bc6ce2da1" translate="yes" xml:space="preserve">
          <source>Week 52 of week-based-year 2008</source>
          <target state="translated">週ベースの年2008年第52週</target>
        </trans-unit>
        <trans-unit id="de9cd5103d931eb33add540394a1f571fcdcca10" translate="yes" xml:space="preserve">
          <source>Week 53 of 2008</source>
          <target state="translated">2008年53週目</target>
        </trans-unit>
        <trans-unit id="6c46029aa17fb600a21cad6bd08e77301e063307" translate="yes" xml:space="preserve">
          <source>Week Based Year</source>
          <target state="translated">週ベースの年</target>
        </trans-unit>
        <trans-unit id="0fcbe34401d64884bb36657832164bedeaa60659" translate="yes" xml:space="preserve">
          <source>Week Of Month</source>
          <target state="translated">月の週</target>
        </trans-unit>
        <trans-unit id="f295af822500a48f0431b7b363da9a13a414b828" translate="yes" xml:space="preserve">
          <source>Week Of Year and Week Year</source>
          <target state="translated">年の週と年の週</target>
        </trans-unit>
        <trans-unit id="cf20b17dedbd2fa061bb084e6e427c23883b04dc" translate="yes" xml:space="preserve">
          <source>Week based years</source>
          <target state="translated">週ベースの年</target>
        </trans-unit>
        <trans-unit id="89443bf2616153b1df032a1eb1df761e955b11a3" translate="yes" xml:space="preserve">
          <source>Week in month</source>
          <target state="translated">月の週</target>
        </trans-unit>
        <trans-unit id="cadc38e9abe6dd9dd6fcc84c98869fbd77cea946" translate="yes" xml:space="preserve">
          <source>Week in year</source>
          <target state="translated">年の週</target>
        </trans-unit>
        <trans-unit id="66de1cb2f3c93d7fd3d3a0a272c173e1b5c911b9" translate="yes" xml:space="preserve">
          <source>Week of Month</source>
          <target state="translated">月の週</target>
        </trans-unit>
        <trans-unit id="d6c62cdc6501a8ecf111466d9a326e871d8b8b6e" translate="yes" xml:space="preserve">
          <source>Week of Year</source>
          <target state="translated">年の週</target>
        </trans-unit>
        <trans-unit id="c19474894e0551ed2105ef8e4012a429b6bad40c" translate="yes" xml:space="preserve">
          <source>Week one (1) is the week starting on the &lt;a href=&quot;#getFirstDayOfWeek()&quot;&gt;&lt;code&gt;getFirstDayOfWeek()&lt;/code&gt;&lt;/a&gt; where there are at least &lt;a href=&quot;#getMinimalDaysInFirstWeek()&quot;&gt;&lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt;&lt;/a&gt; days in the month. Thus, week one may start up to &lt;code&gt;minDays&lt;/code&gt; days before the start of the month. If the first week starts after the start of the month then the period before is week zero (0).</source>
          <target state="translated">1週目は、&lt;a href=&quot;#getFirstDayOfWeek()&quot;&gt; &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; &lt;/a&gt;で始まる週であり、その月には少なくとも&lt;a href=&quot;#getMinimalDaysInFirstWeek()&quot;&gt; &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; &lt;/a&gt;日があります。したがって、第1週は、月の開始の &lt;code&gt;minDays&lt;/code&gt; 日前まで開始できます。最初の週が月の開始後に開始する場合、その前の期間は第0週（0）です。</target>
        </trans-unit>
        <trans-unit id="74d6db712bf03a49e67556ff1aec1f683642d8c2" translate="yes" xml:space="preserve">
          <source>Week one (1) is the week starting on the &lt;a href=&quot;weekfields#getFirstDayOfWeek--&quot;&gt;&lt;code&gt;getFirstDayOfWeek()&lt;/code&gt;&lt;/a&gt; where there are at least &lt;a href=&quot;weekfields#getMinimalDaysInFirstWeek--&quot;&gt;&lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt;&lt;/a&gt; days in the month. Thus, week one may start up to &lt;code&gt;minDays&lt;/code&gt; days before the start of the month. If the first week starts after the start of the month then the period before is week zero (0).</source>
          <target state="translated">週1（1）は&lt;a href=&quot;weekfields#getFirstDayOfWeek--&quot;&gt; &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; &lt;/a&gt;から始まる週で、その月には少なくとも&lt;a href=&quot;weekfields#getMinimalDaysInFirstWeek--&quot;&gt; &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; &lt;/a&gt;日があります。したがって、第1週は月の初めの &lt;code&gt;minDays&lt;/code&gt; 日まで開始できます。最初の週が月の始まりの後で始まる場合、その前の期間はゼロ週（0）です。</target>
        </trans-unit>
        <trans-unit id="12d77cb8838ad5fb792309f27517ce73b66b3ed1" translate="yes" xml:space="preserve">
          <source>Week one(1) is the week starting on the &lt;a href=&quot;#getFirstDayOfWeek()&quot;&gt;&lt;code&gt;getFirstDayOfWeek()&lt;/code&gt;&lt;/a&gt; where there are at least &lt;a href=&quot;#getMinimalDaysInFirstWeek()&quot;&gt;&lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt;&lt;/a&gt; days in the year. If the first week starts after the start of the year then the period before is in the last week of the previous year.</source>
          <target state="translated">第1週（1）は、&lt;a href=&quot;#getFirstDayOfWeek()&quot;&gt; &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; &lt;/a&gt;で始まる週であり、その年には少なくとも&lt;a href=&quot;#getMinimalDaysInFirstWeek()&quot;&gt; &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; &lt;/a&gt;日があります。最初の週が年の初めの後に始まる場合、前の期間は前年の最後の週になります。</target>
        </trans-unit>
        <trans-unit id="ceffe96a6e332c6dd3063a343f6124a6b5ee6477" translate="yes" xml:space="preserve">
          <source>Week one(1) is the week starting on the &lt;a href=&quot;#getFirstDayOfWeek()&quot;&gt;&lt;code&gt;getFirstDayOfWeek()&lt;/code&gt;&lt;/a&gt; where there are at least &lt;a href=&quot;#getMinimalDaysInFirstWeek()&quot;&gt;&lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt;&lt;/a&gt; days in the year. Thus, week one may start before the start of the year. If the first week starts after the start of the year then the period before is in the last week of the previous year.</source>
          <target state="translated">第1週（1）は、&lt;a href=&quot;#getFirstDayOfWeek()&quot;&gt; &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; &lt;/a&gt;で始まる週であり、その年には少なくとも&lt;a href=&quot;#getMinimalDaysInFirstWeek()&quot;&gt; &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; &lt;/a&gt;日があります。したがって、第1週は、年の初めより前に開始できます。最初の週が年の初めの後に始まる場合、前の期間は前年の最後の週になります。</target>
        </trans-unit>
        <trans-unit id="4f6f45d858ed4016de445396b12998ca4b8aad27" translate="yes" xml:space="preserve">
          <source>Week one(1) is the week starting on the &lt;a href=&quot;#getFirstDayOfWeek()&quot;&gt;&lt;code&gt;getFirstDayOfWeek()&lt;/code&gt;&lt;/a&gt; where there are at least &lt;a href=&quot;#getMinimalDaysInFirstWeek()&quot;&gt;&lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt;&lt;/a&gt; days in the year. Thus, week one may start up to &lt;code&gt;minDays&lt;/code&gt; days before the start of the year. If the first week starts after the start of the year then the period before is week zero (0).</source>
          <target state="translated">第1週（1）は、&lt;a href=&quot;#getFirstDayOfWeek()&quot;&gt; &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; &lt;/a&gt;で始まる週であり、その年には少なくとも&lt;a href=&quot;#getMinimalDaysInFirstWeek()&quot;&gt; &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; &lt;/a&gt;日があります。したがって、第1週は、年の開始の &lt;code&gt;minDays&lt;/code&gt; 日前まで開始できます。最初の週が年の開始後に開始する場合、その前の期間は第0週（0）です。</target>
        </trans-unit>
        <trans-unit id="44f1f99446cb5330dbad01f12f044f5a225971e2" translate="yes" xml:space="preserve">
          <source>Week one(1) is the week starting on the &lt;a href=&quot;weekfields#getFirstDayOfWeek--&quot;&gt;&lt;code&gt;getFirstDayOfWeek()&lt;/code&gt;&lt;/a&gt; where there are at least &lt;a href=&quot;weekfields#getMinimalDaysInFirstWeek--&quot;&gt;&lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt;&lt;/a&gt; days in the year. If the first week starts after the start of the year then the period before is in the last week of the previous year.</source>
          <target state="translated">週1（1）は、&lt;a href=&quot;weekfields#getFirstDayOfWeek--&quot;&gt; &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; &lt;/a&gt;から始まる週で、年に少なくとも&lt;a href=&quot;weekfields#getMinimalDaysInFirstWeek--&quot;&gt; &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; &lt;/a&gt;日があります。最初の週が年の初めから始まった場合、その前の期間は前年の最後の週になります。</target>
        </trans-unit>
        <trans-unit id="59d424ddfaa661a922cb86607e9a3548d6b3e08f" translate="yes" xml:space="preserve">
          <source>Week one(1) is the week starting on the &lt;a href=&quot;weekfields#getFirstDayOfWeek--&quot;&gt;&lt;code&gt;getFirstDayOfWeek()&lt;/code&gt;&lt;/a&gt; where there are at least &lt;a href=&quot;weekfields#getMinimalDaysInFirstWeek--&quot;&gt;&lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt;&lt;/a&gt; days in the year. Thus, week one may start before the start of the year. If the first week starts after the start of the year then the period before is in the last week of the previous year.</source>
          <target state="translated">週1（1）は、&lt;a href=&quot;weekfields#getFirstDayOfWeek--&quot;&gt; &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; &lt;/a&gt;から始まる週で、年に少なくとも&lt;a href=&quot;weekfields#getMinimalDaysInFirstWeek--&quot;&gt; &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; &lt;/a&gt;日があります。したがって、第1週は年の初めより前に始まることがあります。最初の週が年の初めから始まった場合、その前の期間は前年の最後の週になります。</target>
        </trans-unit>
        <trans-unit id="edf457af9ac86c639d6fa25a82d99903848d2cc3" translate="yes" xml:space="preserve">
          <source>Week one(1) is the week starting on the &lt;a href=&quot;weekfields#getFirstDayOfWeek--&quot;&gt;&lt;code&gt;getFirstDayOfWeek()&lt;/code&gt;&lt;/a&gt; where there are at least &lt;a href=&quot;weekfields#getMinimalDaysInFirstWeek--&quot;&gt;&lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt;&lt;/a&gt; days in the year. Thus, week one may start up to &lt;code&gt;minDays&lt;/code&gt; days before the start of the year. If the first week starts after the start of the year then the period before is week zero (0).</source>
          <target state="translated">週1（1）は、&lt;a href=&quot;weekfields#getFirstDayOfWeek--&quot;&gt; &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; &lt;/a&gt;から始まる週で、年に少なくとも&lt;a href=&quot;weekfields#getMinimalDaysInFirstWeek--&quot;&gt; &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; &lt;/a&gt;日があります。したがって、第1週は、年の初めの &lt;code&gt;minDays&lt;/code&gt; 日まで開始できます。最初の週が年の初めから始まる場合、その前の期間はゼロ週（0）です。</target>
        </trans-unit>
        <trans-unit id="21523175d42396f1b83a7d224bcef6c78db04431" translate="yes" xml:space="preserve">
          <source>Week year</source>
          <target state="translated">週年</target>
        </trans-unit>
        <trans-unit id="0f3cd7a23e2be7e3002b8bffb3ed9ec37177e7b2" translate="yes" xml:space="preserve">
          <source>WeekFields</source>
          <target state="translated">WeekFields</target>
        </trans-unit>
        <trans-unit id="22700d348b3e11d9fd6613090889ec190de727aa" translate="yes" xml:space="preserve">
          <source>WeekFields instances are singletons; for each unique combination of &lt;code&gt;firstDayOfWeek&lt;/code&gt; and &lt;code&gt;minimalDaysInFirstWeek&lt;/code&gt; the same instance will be returned.</source>
          <target state="translated">WeekFieldsインスタンスはシングルトンです。 &lt;code&gt;firstDayOfWeek&lt;/code&gt; と &lt;code&gt;minimalDaysInFirstWeek&lt;/code&gt; の一意の組み合わせごとに、同じインスタンスが返されます。</target>
        </trans-unit>
        <trans-unit id="718dae35ec7f29671d329f016891913ac6dd0953" translate="yes" xml:space="preserve">
          <source>WeekFields instances are singletons; for each unique combination of &lt;code&gt;firstDayOfWeek&lt;/code&gt; and &lt;code&gt;minimalDaysInFirstWeek&lt;/code&gt; the the same instance will be returned.</source>
          <target state="translated">WeekFieldsインスタンスはシングルトンです。 &lt;code&gt;firstDayOfWeek&lt;/code&gt; と &lt;code&gt;minimalDaysInFirstWeek&lt;/code&gt; の一意の組み合わせごとに、同じインスタンスが返されます。</target>
        </trans-unit>
        <trans-unit id="44d5d3a1e1dee13721fd9eb305d4686b3f9e55b7" translate="yes" xml:space="preserve">
          <source>WeekFields provides five fields, &lt;a href=&quot;#dayOfWeek()&quot;&gt;&lt;code&gt;dayOfWeek()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#weekOfMonth()&quot;&gt;&lt;code&gt;weekOfMonth()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#weekOfYear()&quot;&gt;&lt;code&gt;weekOfYear()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#weekOfWeekBasedYear()&quot;&gt;&lt;code&gt;weekOfWeekBasedYear()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#weekBasedYear()&quot;&gt;&lt;code&gt;weekBasedYear()&lt;/code&gt;&lt;/a&gt; that provide access to the values from any &lt;a href=&quot;temporal&quot;&gt;temporal object&lt;/a&gt;.</source>
          <target state="translated">WeekFieldsは、&lt;a href=&quot;#dayOfWeek()&quot;&gt; &lt;code&gt;dayOfWeek()&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#weekOfMonth()&quot;&gt; &lt;code&gt;weekOfMonth()&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#weekOfYear()&quot;&gt; &lt;code&gt;weekOfYear()&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#weekOfWeekBasedYear()&quot;&gt; &lt;code&gt;weekOfWeekBasedYear()&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;#weekBasedYear()&quot;&gt; &lt;code&gt;weekBasedYear()&lt;/code&gt; の&lt;/a&gt;5つのフィールドを提供し、任意の&lt;a href=&quot;temporal&quot;&gt;時間オブジェクト&lt;/a&gt;からの値へのアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="89a2292f88acbc8f0e38aee8edbc776ed1156087" translate="yes" xml:space="preserve">
          <source>WeekFields provides five fields, &lt;a href=&quot;weekfields#dayOfWeek--&quot;&gt;&lt;code&gt;dayOfWeek()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;weekfields#weekOfMonth--&quot;&gt;&lt;code&gt;weekOfMonth()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;weekfields#weekOfYear--&quot;&gt;&lt;code&gt;weekOfYear()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;weekfields#weekOfWeekBasedYear--&quot;&gt;&lt;code&gt;weekOfWeekBasedYear()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;weekfields#weekBasedYear--&quot;&gt;&lt;code&gt;weekBasedYear()&lt;/code&gt;&lt;/a&gt; that provide access to the values from any &lt;a href=&quot;temporal&quot;&gt;temporal object&lt;/a&gt;.</source>
          <target state="translated">WeekFieldsには、&lt;a href=&quot;weekfields#dayOfWeek--&quot;&gt; &lt;code&gt;dayOfWeek()&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;weekfields#weekOfMonth--&quot;&gt; &lt;code&gt;weekOfMonth()&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;weekfields#weekOfYear--&quot;&gt; &lt;code&gt;weekOfYear()&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;weekfields#weekOfWeekBasedYear--&quot;&gt; &lt;code&gt;weekOfWeekBasedYear()&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;weekfields#weekBasedYear--&quot;&gt; &lt;code&gt;weekBasedYear()&lt;/code&gt; の&lt;/a&gt; 5つのフィールドがあり、任意の&lt;a href=&quot;temporal&quot;&gt;時間オブジェクト&lt;/a&gt;からの値にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="6cb3080d6ff8341db52a2cdfe428e6fe7cfdc77d" translate="yes" xml:space="preserve">
          <source>WeekFields.dayOfWeek()</source>
          <target state="translated">WeekFields.dayOfWeek()</target>
        </trans-unit>
        <trans-unit id="63de50e0e26b59f3d9fe368fff1375c932f6dc68" translate="yes" xml:space="preserve">
          <source>WeekFields.equals()</source>
          <target state="translated">WeekFields.equals()</target>
        </trans-unit>
        <trans-unit id="307be796ddd4af18d3ea219c21738d280f71a9f6" translate="yes" xml:space="preserve">
          <source>WeekFields.getFirstDayOfWeek()</source>
          <target state="translated">WeekFields.getFirstDayOfWeek()</target>
        </trans-unit>
        <trans-unit id="9eb1a32786064c34464f305adb94564c93fc3d6a" translate="yes" xml:space="preserve">
          <source>WeekFields.getMinimalDaysInFirstWeek()</source>
          <target state="translated">WeekFields.getMinimalDaysInFirstWeek()</target>
        </trans-unit>
        <trans-unit id="0f4344dbb38df7c1dd4475092ee3cc1b31b7a1dc" translate="yes" xml:space="preserve">
          <source>WeekFields.hashCode()</source>
          <target state="translated">WeekFields.hashCode()</target>
        </trans-unit>
        <trans-unit id="f5a7902f43adfba0ce22ee041b83a1d8e9b00d05" translate="yes" xml:space="preserve">
          <source>WeekFields.of()</source>
          <target state="translated">WeekFields.of()</target>
        </trans-unit>
        <trans-unit id="0d111eab407e09a34fda6c1f334ea981ad02f8d3" translate="yes" xml:space="preserve">
          <source>WeekFields.toString()</source>
          <target state="translated">WeekFields.toString()</target>
        </trans-unit>
        <trans-unit id="f7d24644a2eae9dfbf214b9d12aa277c6a89292c" translate="yes" xml:space="preserve">
          <source>WeekFields.weekBasedYear()</source>
          <target state="translated">WeekFields.weekBasedYear()</target>
        </trans-unit>
        <trans-unit id="6ed8a499946db10836e56570eaad12d34de1b1e4" translate="yes" xml:space="preserve">
          <source>WeekFields.weekOfMonth()</source>
          <target state="translated">WeekFields.weekOfMonth()</target>
        </trans-unit>
        <trans-unit id="f94cf8e74a33d036b43c60e0a361b7ab911bc24a" translate="yes" xml:space="preserve">
          <source>WeekFields.weekOfWeekBasedYear()</source>
          <target state="translated">WeekFields.weekOfWeekBasedYear()</target>
        </trans-unit>
        <trans-unit id="2788abb8d6fe59a50dbde8e26f797c0be24e8bc7" translate="yes" xml:space="preserve">
          <source>WeekFields.weekOfYear()</source>
          <target state="translated">WeekFields.weekOfYear()</target>
        </trans-unit>
        <trans-unit id="7d75266a53b99ce4d80d337862ea1edd8ba1b1a1" translate="yes" xml:space="preserve">
          <source>Weeks</source>
          <target state="translated">Weeks</target>
        </trans-unit>
        <trans-unit id="8df986efff37f1cf0680e8b945fdb0be0bb07b78" translate="yes" xml:space="preserve">
          <source>Weight is the overall 'weight' of the glyph in the line. Generally it is proportional to the size of the font. Glyphs with larger weight are allocated a correspondingly larger amount of the change in space.</source>
          <target state="translated">Weight は、行内のグリフの全体的な「重さ」です。一般的にはフォントの大きさに比例する。重みの大きいグリフは、それに応じてスペースの変化量も大きく割り当てられます。</target>
        </trans-unit>
        <trans-unit id="20ac2f25a966eb781339ca5e0fe0f7f875b9cfc8" translate="yes" xml:space="preserve">
          <source>Well known port for registry.</source>
          <target state="translated">レジストリのためのよく知られたポート。</target>
        </trans-unit>
        <trans-unit id="b5ceaaaab5693bd089df6a3f31655e313dce3989" translate="yes" xml:space="preserve">
          <source>Well-formed country/region values have the form &lt;code&gt;[a-zA-Z]{2} | [0-9]{3}&lt;/code&gt;</source>
          <target state="translated">整形式の国/地域の値の形式は &lt;code&gt;[a-zA-Z]{2} | [0-9]{3}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0fe9a9ddb38f6c4d512e9dbb79376b8ca30e2bf0" translate="yes" xml:space="preserve">
          <source>Well-formed keys are single characters from the set &lt;code&gt;[0-9a-zA-Z]&lt;/code&gt;. Well-formed values have the form &lt;code&gt;SUBTAG ('-' SUBTAG)*&lt;/code&gt; where for the key 'x' &lt;code&gt;SUBTAG = [0-9a-zA-Z]{1,8}&lt;/code&gt; and for other keys &lt;code&gt;SUBTAG = [0-9a-zA-Z]{2,8}&lt;/code&gt; (that is, 'x' allows single-character subtags).</source>
          <target state="translated">&lt;code&gt;[0-9a-zA-Z]&lt;/code&gt; キーは、セット[0-9a-zA-Z]の単一の文字です。 &lt;code&gt;SUBTAG ('-' SUBTAG)*&lt;/code&gt; 値の形式はSUBTAG（ '-' SUBTAG）*です。ここで、キー 'x'の場合 &lt;code&gt;SUBTAG = [0-9a-zA-Z]{1,8}&lt;/code&gt; で、その他のキーの場合は &lt;code&gt;SUBTAG = [0-9a-zA-Z]{2,8}&lt;/code&gt; （つまり、「x」は単一文字のサブタグを許可します）。</target>
        </trans-unit>
        <trans-unit id="6162cb572cd0fa07269f9f853edbaab78da2fbaa" translate="yes" xml:space="preserve">
          <source>Well-formed language values have the form &lt;code&gt;[a-zA-Z]{2,8}&lt;/code&gt;. Note that this is not the full BCP47 language production, since it excludes extlang. They are not needed since modern three-letter language codes replace them.</source>
          <target state="translated">整形式の言語値の形式は &lt;code&gt;[a-zA-Z]{2,8}&lt;/code&gt; です。extlangが除外されているため、これは完全なBCP47言語の生成ではないことに注意してください。最新の3文字の言語コードがそれらに取って代わるため、これらは必要ありません。</target>
        </trans-unit>
        <trans-unit id="a50506c60f4a43fce22721c5603adee4e842c36f" translate="yes" xml:space="preserve">
          <source>Well-formed language values have the form &lt;code&gt;[a-zA-Z]{2,8}&lt;/code&gt;. Note that this is not the the full BCP47 language production, since it excludes extlang. They are not needed since modern three-letter language codes replace them.</source>
          <target state="translated">整形式の言語値の形式は &lt;code&gt;[a-zA-Z]{2,8}&lt;/code&gt; です。extlangが除外されているため、これは完全なBCP47言語の生成ではないことに注意してください。最新の3文字の言語コードで置き換えられるため、これらは必要ありません。</target>
        </trans-unit>
        <trans-unit id="858fa2509ca423136e7cf31f512c6eefb90eeb81" translate="yes" xml:space="preserve">
          <source>Well-formed script values have the form &lt;code&gt;[a-zA-Z]{4}&lt;/code&gt;</source>
          <target state="translated">整形式のスクリプト値の形式は &lt;code&gt;[a-zA-Z]{4}&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="f4d5d35b51d9cbb55387c8e6d28bc1a22d820b0a" translate="yes" xml:space="preserve">
          <source>Well-formed variant values have the form &lt;code&gt;SUBTAG
   (('_'|'-') SUBTAG)*&lt;/code&gt; where &lt;code&gt;SUBTAG =
   [0-9][0-9a-zA-Z]{3} | [0-9a-zA-Z]{5,8}&lt;/code&gt;. (Note: BCP 47 only uses hyphen ('-') as a delimiter, this is more lenient).</source>
          <target state="translated">十分に形成されたバリアントの値は、フォーム有する &lt;code&gt;SUBTAG (('_'|'-') SUBTAG)*&lt;/code&gt; &lt;code&gt;SUBTAG = [0-9][0-9a-zA-Z]{3} | [0-9a-zA-Z]{5,8}&lt;/code&gt; 。（注：BCP 47は区切り文字としてハイフン（ '-'）のみを使用します。これはより寛大です）。</target>
        </trans-unit>
        <trans-unit id="ce95843c87158992b2858d825f7a237360e6b63f" translate="yes" xml:space="preserve">
          <source>West pane</source>
          <target state="translated">西側のペイン</target>
        </trans-unit>
        <trans-unit id="c9e4b6efb7854b9fa304410f366631e4c9b775f3" translate="yes" xml:space="preserve">
          <source>What is an Attribute?</source>
          <target state="translated">属性とは何ですか?</target>
        </trans-unit>
        <trans-unit id="301ddf4fd686c9921c42e78bd43366e889d8837c" translate="yes" xml:space="preserve">
          <source>What is the offset along the minor axis</source>
          <target state="translated">小軸に沿ったオフセットは?</target>
        </trans-unit>
        <trans-unit id="c587c6fc95a9107db0097d9b15fd1d5ffc2e7330" translate="yes" xml:space="preserve">
          <source>What is the span along the major axis.</source>
          <target state="translated">長軸に沿ったスパンは?</target>
        </trans-unit>
        <trans-unit id="8dbf8f4ff843b6789ff963d498444a2edfc85fed" translate="yes" xml:space="preserve">
          <source>What is the span along the minor axis.</source>
          <target state="translated">脇軸に沿ったスパンは?</target>
        </trans-unit>
        <trans-unit id="e1253f057c65c5140688cb6f74eaff535608ffb8" translate="yes" xml:space="preserve">
          <source>What operation was being attempted when a conflict occurred</source>
          <target state="translated">紛争が発生したとき、どのような作戦が試みられていたか</target>
        </trans-unit>
        <trans-unit id="3dc6bced115a4ebb63076f833d6f3f46734f7360" translate="yes" xml:space="preserve">
          <source>What the &lt;code&gt;java.sql&lt;/code&gt; Package Contains</source>
          <target state="translated">何 &lt;code&gt;java.sql&lt;/code&gt; パッケージに含ま</target>
        </trans-unit>
        <trans-unit id="dae0b4b4d87d6d1381813d3114a08a7d3cf1d6f4" translate="yes" xml:space="preserve">
          <source>What the JDBC&amp;trade; 4.3 API Includes</source>
          <target state="translated">JDBC&amp;trade;4.3APIに含まれるもの</target>
        </trans-unit>
        <trans-unit id="f523aaaa18b102076687e4244d4e07bb6f436a11" translate="yes" xml:space="preserve">
          <source>What the Permission Allows</source>
          <target state="translated">許可の内容</target>
        </trans-unit>
        <trans-unit id="373c94003a259747dc5ca0b92f838b2b5acf5d59" translate="yes" xml:space="preserve">
          <source>What this means is that the ClassLoader may be wrapped in another ClassLoader for security or other reasons.</source>
          <target state="translated">これが意味するのは、セキュリティやその他の理由でClassLoaderが別のClassLoaderでラップされている可能性があるということです。</target>
        </trans-unit>
        <trans-unit id="ca20440fd173e3537d3dbdf1472c311d148f0f89" translate="yes" xml:space="preserve">
          <source>What's returned by &lt;code&gt;AccessibleJEditorPaneHTML.getAccessibleText&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;AccessibleJEditorPaneHTML.getAccessibleText&lt;/code&gt; によって返されるもの。</target>
        </trans-unit>
        <trans-unit id="caf5d2a20376b8ede2618bea6b71d51812f11949" translate="yes" xml:space="preserve">
          <source>What's returned by &lt;code&gt;AccessibleJEditorPaneHTML.getAccessibleText&lt;/code&gt;. Provides support for &lt;code&gt;AccessibleHypertext&lt;/code&gt; in case there is an HTML document being displayed in this &lt;code&gt;JEditorPane&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;AccessibleJEditorPaneHTML.getAccessibleText&lt;/code&gt; によって返されるもの。この &lt;code&gt;JEditorPane&lt;/code&gt; HTMLドキュメントが表示されている場合に &lt;code&gt;AccessibleHypertext&lt;/code&gt; をサポートします。</target>
        </trans-unit>
        <trans-unit id="2c62f541df771dc9c17e6db7806198f01ce3df87" translate="yes" xml:space="preserve">
          <source>Whatever the</source>
          <target state="translated">どんなものでも</target>
        </trans-unit>
        <trans-unit id="89357495a0b5512bbc9f5bc66b16ee57716aba68" translate="yes" xml:space="preserve">
          <source>Whatever the &lt;a href=&quot;#groupname&quot;&gt;named-capturing group&lt;/a&gt; &quot;name&quot; matched</source>
          <target state="translated">どのような&lt;a href=&quot;#groupname&quot;&gt;名前付きキャプチャグループ&lt;/a&gt;「名前」一致</target>
        </trans-unit>
        <trans-unit id="183f14f8a35d4f7ed23e203448b1fd0af728304e" translate="yes" xml:space="preserve">
          <source>When 'value' is no longer valid then the getter method is invoked for the attribute. The 'lastUpdatedTimeStamp' field and `value' fields are updated.</source>
          <target state="translated">value' が有効でなくなった場合、ゲッターメソッドが呼び出されます。lastUpdatedTimeStamp' フィールドと `value' フィールドが更新されます。</target>
        </trans-unit>
        <trans-unit id="c20d6596c0516c20ee93280ced0b8c1583308051" translate="yes" xml:space="preserve">
          <source>When 'value' is no longer valid then the operation method is invoked. The 'lastUpdatedTimeStamp' field and `value' fields are updated.</source>
          <target state="translated">value' が有効でなくなった場合、その操作メソッドが呼び出される。lastUpdatedTimeStamp' フィールドと `value' フィールドが更新される。</target>
        </trans-unit>
        <trans-unit id="7ad7cf61a538ac9682cd9c38c51af1051f6daf5e" translate="yes" xml:space="preserve">
          <source>When 'value' is valid, 'value' is returned.</source>
          <target state="translated">'value' が有効な場合は 'value' を返します。</target>
        </trans-unit>
        <trans-unit id="7333d8d0058642dce5b6ba018287a61a8e12ae52" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#sendNotification(javax.management.Notification)&quot;&gt;&lt;code&gt;sendNotification&lt;/code&gt;&lt;/a&gt; is called, a listener is selected if it was added with a null &lt;a href=&quot;notificationfilter&quot;&gt;&lt;code&gt;NotificationFilter&lt;/code&gt;&lt;/a&gt;, or if &lt;a href=&quot;notificationfilter#isNotificationEnabled(javax.management.Notification)&quot;&gt;&lt;code&gt;isNotificationEnabled&lt;/code&gt;&lt;/a&gt; returns true for the notification being sent. The call to &lt;code&gt;NotificationFilter.isNotificationEnabled&lt;/code&gt; takes place in the thread that called &lt;code&gt;sendNotification&lt;/code&gt;. Then, for each selected listener, &lt;a href=&quot;../../../java.base/java/util/concurrent/executor#execute(java.lang.Runnable)&quot;&gt;&lt;code&gt;executor.execute&lt;/code&gt;&lt;/a&gt; is called with a command that calls the &lt;code&gt;handleNotification&lt;/code&gt; method.</source>
          <target state="translated">場合&lt;a href=&quot;#sendNotification(javax.management.Notification)&quot;&gt; &lt;code&gt;sendNotification&lt;/code&gt; をが&lt;/a&gt;呼び出され、リスナーは、それがヌルで添加した場合に選択される&lt;a href=&quot;notificationfilter&quot;&gt; &lt;code&gt;NotificationFilter&lt;/code&gt; を&lt;/a&gt;、又は場合&lt;a href=&quot;notificationfilter#isNotificationEnabled(javax.management.Notification)&quot;&gt; &lt;code&gt;isNotificationEnabled&lt;/code&gt; &lt;/a&gt;通知が送信されるための真戻ります。 &lt;code&gt;NotificationFilter.isNotificationEnabled&lt;/code&gt; の呼び出しは、 &lt;code&gt;sendNotification&lt;/code&gt; を呼び出したスレッドで行われます。次に、選択したリスナーごとに、 &lt;code&gt;handleNotification&lt;/code&gt; メソッドを呼び出すコマンドを使用して&lt;a href=&quot;../../../java.base/java/util/concurrent/executor#execute(java.lang.Runnable)&quot;&gt; &lt;code&gt;executor.execute&lt;/code&gt; &lt;/a&gt;が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="720701165d46b861473379cd54f2570d2c747f20" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#value-field&quot;&gt;value&lt;/a&gt; was set.</source>
          <target state="translated">&lt;a href=&quot;#value-field&quot;&gt;値&lt;/a&gt;が設定されたとき。</target>
        </trans-unit>
        <trans-unit id="2787518abc9792a673e362e95dc630f0312e2d2c" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#waitFor()&quot;&gt;&lt;code&gt;waitFor()&lt;/code&gt;&lt;/a&gt; returns successfully the CompletableFuture is &lt;a href=&quot;../util/concurrent/completablefuture#complete(T)&quot;&gt;completed&lt;/a&gt; regardless of the exit status of the process. This implementation may consume a lot of memory for thread stacks if a large number of processes are waited for concurrently.</source>
          <target state="translated">場合&lt;a href=&quot;#waitFor()&quot;&gt; &lt;code&gt;waitFor()&lt;/code&gt; &lt;/a&gt;正常に戻りCompletableFutureは、&lt;a href=&quot;../util/concurrent/completablefuture#complete(T)&quot;&gt;完了&lt;/a&gt;にかかわらず、プロセスの終了ステータスの。この実装では、多数のプロセスが同時に待機している場合、スレッドスタック用に大量のメモリを消費する可能性があります。</target>
        </trans-unit>
        <trans-unit id="0b41c0f3ed6f8adeecdcc86bb85da400ea38c18d" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../../../org/xml/sax/contenthandler#startElement(java.lang.String,java.lang.String,java.lang.String,org.xml.sax.Attributes)&quot;&gt;&lt;code&gt;ContentHandler.startElement(String, String, String, Attributes)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../../org/xml/sax/contenthandler#endElement(java.lang.String,java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;ContentHandler.endElement(String, String, String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../../org/xml/sax/contenthandler#startDocument()&quot;&gt;&lt;code&gt;ContentHandler.startDocument()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../../../org/xml/sax/contenthandler#endDocument()&quot;&gt;&lt;code&gt;ContentHandler.endDocument()&lt;/code&gt;&lt;/a&gt; are invoked on a &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt;, the same method on the user-specified &lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt;&lt;code&gt;ContentHandler&lt;/code&gt;&lt;/a&gt; must be invoked for the same event before the callback returns.</source>
          <target state="translated">場合&lt;a href=&quot;../../../org/xml/sax/contenthandler#startElement(java.lang.String,java.lang.String,java.lang.String,org.xml.sax.Attributes)&quot;&gt; &lt;code&gt;ContentHandler.startElement(String, String, String, Attributes)&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../../org/xml/sax/contenthandler#endElement(java.lang.String,java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;ContentHandler.endElement(String, String, String)&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../../org/xml/sax/contenthandler#startDocument()&quot;&gt; &lt;code&gt;ContentHandler.startDocument()&lt;/code&gt; &lt;/a&gt;、または&lt;a href=&quot;../../../org/xml/sax/contenthandler#endDocument()&quot;&gt; &lt;code&gt;ContentHandler.endDocument()&lt;/code&gt; &lt;/a&gt;に呼び出される&lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; &lt;/a&gt;、USER-に同じ方法指定された&lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt; &lt;code&gt;ContentHandler&lt;/code&gt; &lt;/a&gt;は、コールバックが戻る前に同じイベントに対して呼び出される必要があります。</target>
        </trans-unit>
        <trans-unit id="eb0c4944d21938573c8de12446d041f26931fa10" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;notificationbroadcastersupport#sendNotification-javax.management.Notification-&quot;&gt;&lt;code&gt;sendNotification&lt;/code&gt;&lt;/a&gt; is called, a listener is selected if it was added with a null &lt;a href=&quot;notificationfilter&quot;&gt;&lt;code&gt;NotificationFilter&lt;/code&gt;&lt;/a&gt;, or if &lt;a href=&quot;notificationfilter#isNotificationEnabled-javax.management.Notification-&quot;&gt;&lt;code&gt;isNotificationEnabled&lt;/code&gt;&lt;/a&gt; returns true for the notification being sent. The call to &lt;code&gt;NotificationFilter.isNotificationEnabled&lt;/code&gt; takes place in the thread that called &lt;code&gt;sendNotification&lt;/code&gt;. Then, for each selected listener, &lt;a href=&quot;../../java/util/concurrent/executor#execute-java.lang.Runnable-&quot;&gt;&lt;code&gt;executor.execute&lt;/code&gt;&lt;/a&gt; is called with a command that calls the &lt;code&gt;handleNotification&lt;/code&gt; method.</source>
          <target state="translated">場合&lt;a href=&quot;notificationbroadcastersupport#sendNotification-javax.management.Notification-&quot;&gt; &lt;code&gt;sendNotification&lt;/code&gt; をが&lt;/a&gt;呼び出され、リスナーは、それがヌルで添加した場合に選択される&lt;a href=&quot;notificationfilter&quot;&gt; &lt;code&gt;NotificationFilter&lt;/code&gt; を&lt;/a&gt;、又は場合&lt;a href=&quot;notificationfilter#isNotificationEnabled-javax.management.Notification-&quot;&gt; &lt;code&gt;isNotificationEnabled&lt;/code&gt; &lt;/a&gt;通知が送信されるための真戻ります。 &lt;code&gt;NotificationFilter.isNotificationEnabled&lt;/code&gt; の呼び出しは、 &lt;code&gt;sendNotification&lt;/code&gt; を呼び出したスレッドで行われます。次に、選択したリスナーごとに、 &lt;code&gt;handleNotification&lt;/code&gt; メソッドを呼び出すコマンドで&lt;a href=&quot;../../java/util/concurrent/executor#execute-java.lang.Runnable-&quot;&gt; &lt;code&gt;executor.execute&lt;/code&gt; &lt;/a&gt;が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="ca53de9dd5a05f67d73beacc0a06e218c4b8b4f7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;FRACTIONALMETRICS&lt;/code&gt; are enabled, the true font design metrics are scaled by the point size and used for layout with sub-pixel accuracy. The average density of glyphs and total length of a long string of characters will therefore more closely match the theoretical design of the font, but readability may be affected since individual pairs of characters may not always appear to be consistent distances apart depending on how the sub-pixel accumulation of the glyph origins meshes with the device pixel grid. Enabling this hint may be desirable when text layout is being performed that must be consistent across a wide variety of output resolutions. Specifically, this hint may be desirable in situations where the layout of text is being previewed on a low resolution device like a screen for output that will eventually be rendered on a high resolution printer or typesetting device.</source>
          <target state="translated">&lt;code&gt;FRACTIONALMETRICS&lt;/code&gt; の場合が有効になっている場合、真のフォントデザインメトリックはポイントサイズによってスケーリングされ、サブピクセル精度のレイアウトに使用されます。したがって、グリフの平均密度と長い文字列の全長は、フォントの理論的なデザインにより近く一致しますが、文字の個々のペアは、サブピクセルの方法によっては常に一定の距離に見えるとは限らないため、読みやすさに影響する可能性があります。 -グリフの原点のピクセル蓄積は、デバイスのピクセルグリッドと噛み合います。このヒントを有効にすると、さまざまな出力解像度で一貫している必要があるテキストレイアウトが実行されている場合に望ましいことがあります。具体的には、このヒントは、テキストのレイアウトが出力用の画面などの低解像度デバイスでプレビューされ、最終的に高解像度プリンターまたは植字デバイスでレンダリングされる状況で望ましい場合があります。</target>
        </trans-unit>
        <trans-unit id="3907f83b19a6bc999820d92454ce9500f2d86571" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;SSLSocket&lt;/code&gt;s are first created, no handshaking is done so that applications may first set their communication preferences: what cipher suites to use, whether the socket should be in client or server mode, etc. However, security is always provided by the time that application data is sent over the connection.</source>
          <target state="translated">とき &lt;code&gt;SSLSocket&lt;/code&gt; ソケットがクライアントまたはサーバモードにする必要があるかどうかを使用することに何の暗号スイート、などしかし、セキュリティは常に時間であることが提供されます。■を最初に作成され、何のハンドシェイクは、アプリケーションが最初に自分の通信プリファレンスを設定することができそうということで行われていませんアプリケーションデータは接続を介して送信されます。</target>
        </trans-unit>
        <trans-unit id="2865b5a1279039e3aa9655c29d186fd9156ffb33" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;SecurityManager&lt;/code&gt; is installed, the invoking thread must be granted this permission in order to replace the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt;. If permission is not granted, a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown.</source>
          <target state="translated">&lt;code&gt;SecurityManager&lt;/code&gt; がインストールされている場合、現在の &lt;code&gt;KeyboardFocusManager&lt;/code&gt; を置き換えるには、呼び出し元のスレッドにこのアクセス許可を付与する必要があります。許可が与えられていない場合、 &lt;code&gt;SecurityException&lt;/code&gt; がスローされます。</target>
        </trans-unit>
        <trans-unit id="aec348ffd93df939ed7064797ce4b1223e7792d9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;T&lt;/code&gt; attempts to install the newly computed value, if the state is still at &lt;code&gt;2N&lt;/code&gt;, the class value will be initialized with the computed value, advancing it to state &lt;code&gt;2N+1&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;T&lt;/code&gt; の試みが新たに計算された値をインストールする状態のままである場合、 &lt;code&gt;2N&lt;/code&gt; 、クラス値は、状態にそれを前進、計算された値で初期化される &lt;code&gt;2N+1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f789b0022722a1185a4c15638dba2438089f1c62" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;jdk.io.permissionsUseCanonicalPath&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, an invalid &lt;code&gt;FilePermission&lt;/code&gt; does not equal to any object except for itself, even if they are created using the same invalid path.</source>
          <target state="translated">とき &lt;code&gt;jdk.io.permissionsUseCanonicalPath&lt;/code&gt; がある &lt;code&gt;false&lt;/code&gt; 、不正な &lt;code&gt;FilePermission&lt;/code&gt; には、それらが同じ無効なパスを使用して作成されていても、自分自身以外の任意のオブジェクトに等しくありません。</target>
        </trans-unit>
        <trans-unit id="586cdea8cb0e9df3dba6780f86611e27368352ca" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;myButton&lt;/code&gt; is pressed, the statement &lt;code&gt;frame.toFront()&lt;/code&gt; will be executed. One could get the same effect, with some additional compile-time type safety, by defining a new implementation of the &lt;code&gt;ActionListener&lt;/code&gt; interface and adding an instance of it to the button:</source>
          <target state="translated">とき &lt;code&gt;myButton&lt;/code&gt; のが押されると、声明 &lt;code&gt;frame.toFront()&lt;/code&gt; が実行されます。 &lt;code&gt;ActionListener&lt;/code&gt; インターフェースの新しい実装を定義し、そのインスタンスをボタンに追加することにより、コンパイル時のタイプセーフを追加して、同じ効果を得ることができます。</target>
        </trans-unit>
        <trans-unit id="c0904a47635f2e7b7777a12e80e944727838b0aa" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;remove&lt;/code&gt; or &lt;code&gt;insertString&lt;/code&gt; is invoked on the &lt;code&gt;DocumentFilter&lt;/code&gt;, the &lt;code&gt;DocumentFilter&lt;/code&gt; may callback into the &lt;code&gt;FilterBypass&lt;/code&gt; multiple times, or for different regions, but it should not callback into the &lt;code&gt;FilterBypass&lt;/code&gt; after returning from the &lt;code&gt;remove&lt;/code&gt; or &lt;code&gt;insertString&lt;/code&gt; method.</source>
          <target state="translated">場合 &lt;code&gt;remove&lt;/code&gt; または &lt;code&gt;insertString&lt;/code&gt; が呼び出された &lt;code&gt;DocumentFilter&lt;/code&gt; 、 &lt;code&gt;DocumentFilter&lt;/code&gt; はにコールバックすることができる &lt;code&gt;FilterBypass&lt;/code&gt; を複数回、または異なる領域のために、それはコールバックにはならない &lt;code&gt;FilterBypass&lt;/code&gt; を復帰後 &lt;code&gt;remove&lt;/code&gt; または &lt;code&gt;insertString&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="b7b9af0e4285748c91632c575b592ae96d9c9970" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;setAutoCreateRowSorter(true)&lt;/code&gt; is invoked, a &lt;code&gt;
 TableRowSorter&lt;/code&gt; is immediately created and installed on the table. While the &lt;code&gt;autoCreateRowSorter&lt;/code&gt; property remains &lt;code&gt;true&lt;/code&gt;, every time the model is changed, a new &lt;code&gt;
 TableRowSorter&lt;/code&gt; is created and set as the table's row sorter. The default value for the &lt;code&gt;autoCreateRowSorter&lt;/code&gt; property is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">とき &lt;code&gt;setAutoCreateRowSorter(true)&lt;/code&gt; 呼び出され、 &lt;code&gt; TableRowSorter&lt;/code&gt; はをすぐに作成し、テーブルの上に設置されています。一方で &lt;code&gt;autoCreateRowSorter&lt;/code&gt; のプロパティが残っている &lt;code&gt;true&lt;/code&gt; 、モデルが変更されるたびに、新しい &lt;code&gt; TableRowSorter&lt;/code&gt; はを作成し、テーブルの行ソーターとして設定されています。 &lt;code&gt;autoCreateRowSorter&lt;/code&gt; プロパティのデフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="fcc753ccd7f4f147341d78ae6bbdfd159682020f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;setMaximum&lt;/code&gt; is called, the maximum value is changed, and other values (including the minimum, the visible amount, and the current scroll bar value) are changed to be consistent with the new maximum.</source>
          <target state="translated">場合 &lt;code&gt;setMaximum&lt;/code&gt; 呼び出され、最大値が変更され、そして（最小、可視量、および現在のスクロールバーの値を含む）他の値は、新しい最大と一致するように変更されています。</target>
        </trans-unit>
        <trans-unit id="634dff626ecd014481529c2d6290cf015b2f06a2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;setMinimum&lt;/code&gt; is called, the minimum value is changed, and other values (including the maximum, the visible amount, and the current scroll bar value) are changed to be consistent with the new minimum.</source>
          <target state="translated">場合 &lt;code&gt;setMinimum&lt;/code&gt; が呼び出され、最小値が変更され、そして（最大、可視量、および現在のスクロールバーの値を含む）他の値は新しい最小と一致するように変更されています。</target>
        </trans-unit>
        <trans-unit id="6366d90e5b77dc1a2fecffb2e332c4bd6f6dd999" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;setValue&lt;/code&gt; is called on the sum spring, &lt;code&gt;s3&lt;/code&gt;, the strain in &lt;code&gt;s3&lt;/code&gt; is calculated using one of the formulas above. Once the strain of the sum is known, the &lt;em&gt;value&lt;/em&gt;s of &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; are then set so that they are have a strain equal to that of the sum. The formulas are evaluated so as to take rounding errors into account and ensure that the sum of the &lt;em&gt;value&lt;/em&gt;s of &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; is exactly equal to the &lt;em&gt;value&lt;/em&gt; of &lt;code&gt;s3&lt;/code&gt;.</source>
          <target state="translated">とき &lt;code&gt;setValue&lt;/code&gt; 和春、上と呼ばれ &lt;code&gt;s3&lt;/code&gt; 、の歪み &lt;code&gt;s3&lt;/code&gt; 上記の式のいずれかを使用して計算されます。合計のひずみがわかると、 &lt;code&gt;s1&lt;/code&gt; と &lt;code&gt;s2&lt;/code&gt; の&lt;em&gt;値&lt;/em&gt;sが設定され、合計のひずみと等しくなります。式は、丸め誤差を考慮に入れて評価され、 &lt;code&gt;s1&lt;/code&gt; と &lt;code&gt;s2&lt;/code&gt; の&lt;em&gt;値&lt;/em&gt;sの合計が &lt;code&gt;s3&lt;/code&gt; の&lt;em&gt;値&lt;/em&gt;と正確に等しいことを確認し&lt;em&gt;ます&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="56200bf85aca75288ef457ae1d31ce485573f186" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;targetSize&lt;/code&gt; is outside the [MIN, MAX] range, the algorithm sets all sizes to their appropriate limiting value (maximum or minimum).</source>
          <target state="translated">&lt;code&gt;targetSize&lt;/code&gt; が[MIN、MAX]の範囲外の場合、アルゴリズムはすべてのサイズを適切な制限値（最大または最小）に設定します。</target>
        </trans-unit>
        <trans-unit id="1dab6c6877815ac1b0667bd54ac4119d91348f67" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;this&lt;/code&gt; instance has an undefined field, this conversion relies on the &lt;code&gt;java.util.GregorianCalendar&lt;/code&gt; default for its corresponding field. A notable difference between XML Schema 1.0 date/time datatypes and &lt;code&gt;java.util.GregorianCalendar&lt;/code&gt; is that Timezone value is optional for date/time datatypes and it is a required field for &lt;code&gt;java.util.GregorianCalendar&lt;/code&gt;. See javadoc for &lt;code&gt;java.util.TimeZone.getDefault()&lt;/code&gt; on how the default is determined. To explicitly specify the &lt;code&gt;TimeZone&lt;/code&gt; instance, see &lt;a href=&quot;#toGregorianCalendar(java.util.TimeZone,java.util.Locale,javax.xml.datatype.XMLGregorianCalendar)&quot;&gt;&lt;code&gt;toGregorianCalendar(TimeZone, Locale, XMLGregorianCalendar)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ときに &lt;code&gt;this&lt;/code&gt; インスタンスが未定義のフィールドがあり、この変換は、に依存している &lt;code&gt;java.util.GregorianCalendar&lt;/code&gt; のその対応するフィールドのデフォルト。 XML Schema 1.0の日付/時刻データ型と &lt;code&gt;java.util.GregorianCalendar&lt;/code&gt; の注目すべき違いは、タイムゾーン値が日付/時刻データ型ではオプションであり、 &lt;code&gt;java.util.GregorianCalendar&lt;/code&gt; の必須フィールドであるということです。デフォルトの決定方法については、 &lt;code&gt;java.util.TimeZone.getDefault()&lt;/code&gt; についてjavadocを参照してください。 &lt;code&gt;TimeZone&lt;/code&gt; インスタンスを明示的に指定するには、&lt;a href=&quot;#toGregorianCalendar(java.util.TimeZone,java.util.Locale,javax.xml.datatype.XMLGregorianCalendar)&quot;&gt; &lt;code&gt;toGregorianCalendar(TimeZone, Locale, XMLGregorianCalendar)&lt;/code&gt; &lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="df87c54daa5b6b22cd03fdfcb4a354ce9aff9581" translate="yes" xml:space="preserve">
          <source>When FEATURE_SECURE_PROCESSING is enabled, it is recommended that implementations restrict external connections by default, though this may cause problems for applications that process XML/XSD/XSL with external references.</source>
          <target state="translated">FEATURE_SECURE_PROCESSINGが有効な場合、デフォルトで外部接続を制限することが推奨されます。</target>
        </trans-unit>
        <trans-unit id="1fe0e12bc1e4fbc587d188553680ac3198949110" translate="yes" xml:space="preserve">
          <source>When FLAG_SERIALIZABLE is set in &lt;code&gt;flags&lt;/code&gt;, the function objects will implement &lt;code&gt;Serializable&lt;/code&gt;, and will have a &lt;code&gt;writeReplace&lt;/code&gt; method that returns an appropriate &lt;a href=&quot;serializedlambda&quot;&gt;&lt;code&gt;SerializedLambda&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;caller&lt;/code&gt; class must have an appropriate &lt;code&gt;$deserializeLambda$&lt;/code&gt; method, as described in &lt;a href=&quot;serializedlambda&quot;&gt;&lt;code&gt;SerializedLambda&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; に FLAG_SERIALIZABLEが設定されている場合、関数オブジェクトは &lt;code&gt;Serializable&lt;/code&gt; を実装し、適切な&lt;a href=&quot;serializedlambda&quot;&gt; &lt;code&gt;SerializedLambda&lt;/code&gt; &lt;/a&gt;を返す &lt;code&gt;writeReplace&lt;/code&gt; メソッドを持ちます。 &lt;code&gt;caller&lt;/code&gt; クラスには、適切な持っている必要があります &lt;code&gt;$deserializeLambda$&lt;/code&gt; で説明したように、方法を&lt;a href=&quot;serializedlambda&quot;&gt; &lt;code&gt;SerializedLambda&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c646c0ac257bca0396e71fe9d4cc99c62c09c803" translate="yes" xml:space="preserve">
          <source>When JNDI constructs an initial context, the context's environment is initialized with properties defined in the environment parameter passed to the constructor, the system properties, and the application resource files. See &lt;a href=&quot;initialcontext#ENVIRONMENT&quot;&gt;&lt;code&gt;InitialContext&lt;/code&gt;&lt;/a&gt; for details. This initial environment is then inherited by other context instances.</source>
          <target state="translated">JNDIが初期コンテキストを構築するとき、コンテキストの環境は、コンストラクターに渡される環境パラメーターで定義されたプロパティー、システム・プロパティー、およびアプリケーション・リソース・ファイルで初期化されます。詳細については、&lt;a href=&quot;initialcontext#ENVIRONMENT&quot;&gt; &lt;code&gt;InitialContext&lt;/code&gt; &lt;/a&gt;を参照してください。この初期環境は、他のコンテキストインスタンスに継承されます。</target>
        </trans-unit>
        <trans-unit id="78166e3e3d24c054685e7318d257481464f62c87" translate="yes" xml:space="preserve">
          <source>When JNDI constructs an initial context, the context's environment is initialized with properties defined in the environment parameter passed to the constructor, the system properties, the applet parameters, and the application resource files. See &lt;a href=&quot;initialcontext#ENVIRONMENT&quot;&gt;&lt;code&gt;InitialContext&lt;/code&gt;&lt;/a&gt; for details. This initial environment is then inherited by other context instances.</source>
          <target state="translated">JNDIが初期コンテキストを構築すると、コンテキストの環境は、コンストラクターに渡された環境パラメーター、システムプロパティ、アプレットパラメーター、およびアプリケーションリソースファイルで定義されたプロパティで初期化されます。詳細については、&lt;a href=&quot;initialcontext#ENVIRONMENT&quot;&gt; &lt;code&gt;InitialContext&lt;/code&gt; &lt;/a&gt;を参照してください。この初期環境は、他のコンテキストインスタンスによって継承されます。</target>
        </trans-unit>
        <trans-unit id="bcf229951ee0f52a0b20411c8b8db39b24c97b2e" translate="yes" xml:space="preserve">
          <source>When Java Sound is used to handle system exclusive data that is being received using MIDI wire protocol, it should place the data in one or more &lt;code&gt;SysexMessages&lt;/code&gt;. In this case, the length of the system exclusive data is not known in advance; the end of the system exclusive data is marked by an end-of-exclusive flag (0xF7) in the MIDI wire byte stream.</source>
          <target state="translated">Java Soundを使用して、MIDIワイヤプロトコルを使用して受信されているシステムエクスクルーシブデータを処理する場合は、そのデータを1つ以上の &lt;code&gt;SysexMessages&lt;/code&gt; に配置する必要があります。この場合、システムエクスクルーシブデータの長さは事前にわかりません。システムエクスクルーシブデータの終わりは、MIDIワイヤーバイトストリームのエンドオブエクスクルーシブフラグ（0xF7）でマークされます。</target>
        </trans-unit>
        <trans-unit id="3dab1f00d125a2ba1bd6dc4a77821fdb53b85de1" translate="yes" xml:space="preserve">
          <source>When LoginContext uses a caller-specified Configuration, the caller does not require any createLoginContext AuthPermission. The LoginContext saves the &lt;code&gt;AccessControlContext&lt;/code&gt; for the caller, and invokes the configured modules from within an &lt;code&gt;AccessController.doPrivileged&lt;/code&gt; call constrained by that context. This means the caller context (stored when the LoginContext was created) must have sufficient permissions to perform any security-sensitive tasks that the modules may perform.</source>
          <target state="translated">LoginContextが呼び出し元指定の構成を使用する場合、呼び出し元はcreateLoginContext AuthPermissionを必要としません。 LoginContext は、呼び出し元の &lt;code&gt;AccessControlContext&lt;/code&gt; を保存し、そのコンテキストによって制約された &lt;code&gt;AccessController.doPrivileged&lt;/code&gt; 呼び出し内から構成済みモジュールを呼び出します。つまり、LoginContextの作成時に保存された呼び出し側コンテキストには、モジュールが実行する可能性のあるセキュリティ上重要なタスクを実行するための十分な権限が必要です。</target>
        </trans-unit>
        <trans-unit id="cb8e6ccdc860924e083cd3b27c25e020271479ff" translate="yes" xml:space="preserve">
          <source>When LoginContext uses the installed Configuration, the caller requires the createLoginContext.&lt;em&gt;name&lt;/em&gt; and possibly createLoginContext.other AuthPermissions. Furthermore, the LoginContext will invoke configured modules from within an &lt;code&gt;AccessController.doPrivileged&lt;/code&gt; call so that modules that perform security-sensitive tasks (such as connecting to remote hosts, and updating the Subject) will require the respective permissions, but the callers of the LoginContext will not require those permissions.</source>
          <target state="translated">LoginContextがインストール済みの構成を使用する場合、呼び出し元はcreateLoginContextを必要とします。&lt;em&gt;名前&lt;/em&gt;と、場合によってはcreateLoginContext.other AuthPermissions。さらに、LoginContextは、 &lt;code&gt;AccessController.doPrivileged&lt;/code&gt; 呼び出し内から構成済みモジュールを呼び出すため、セキュリティが重要なタスク（リモートホストへの接続やサブジェクトの更新など）を実行するモジュールにはそれぞれの権限が必要ですが、LoginContextの呼び出し元はこれらの権限は必要ありません。</target>
        </trans-unit>
        <trans-unit id="b505aae2a5e2bff9bbd6708f806b82cbadb154a8" translate="yes" xml:space="preserve">
          <source>When W3C XML Schema validation is being performed, in the case where an element has a union type, the &lt;a href=&quot;../../../org/w3c/dom/typeinfo&quot;&gt;&lt;code&gt;TypeInfo&lt;/code&gt;&lt;/a&gt; returned by a call to &lt;code&gt;getElementTypeInfo()&lt;/code&gt; from the startElement event will be the union type. The &lt;code&gt;TypeInfo&lt;/code&gt; returned by a call from the endElement event will be the actual member type used to validate the element.</source>
          <target state="translated">W3C XMLスキーマの検証が実行されているとき、要素に共用体タイプがある場合、startElementイベントから &lt;code&gt;getElementTypeInfo()&lt;/code&gt; の呼び出しによって返される&lt;a href=&quot;../../../org/w3c/dom/typeinfo&quot;&gt; &lt;code&gt;TypeInfo&lt;/code&gt; &lt;/a&gt;は共用体タイプになります。 &lt;code&gt;TypeInfo&lt;/code&gt; は、要素を検証するために使用される実際のメンバー型になりendElementイベントのからの呼び出しによって返されます。</target>
        </trans-unit>
        <trans-unit id="815b4cfc283610afe0ea69050a522abe02ee7ab9" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt;&lt;code&gt;ContentHandler&lt;/code&gt;&lt;/a&gt; is specified, a &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt; will work as a filter and basically copy the incoming events to the specified &lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt;&lt;code&gt;ContentHandler&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">とき&lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt; &lt;code&gt;ContentHandler&lt;/code&gt; &lt;/a&gt;指定されている、&lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; &lt;/a&gt;フィルタとして機能し、基本的に指定する着信イベントをコピーします&lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt; &lt;code&gt;ContentHandler&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed0149faee2af012851081107e6df3815ec1f855" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;../validation/schema&quot;&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/a&gt; is non-null, a parser will use a validator created from it to validate documents before it passes information down to the application.</source>
          <target state="translated">&lt;a href=&quot;../validation/schema&quot;&gt; &lt;code&gt;Schema&lt;/code&gt; &lt;/a&gt;がnull以外の場合、パーサーは、スキーマから作成されたバリデーターを使用して、情報をアプリケーションに渡す前にドキュメントを検証します。</target>
        </trans-unit>
        <trans-unit id="0c5f84dadcd17bdac77318bfd9b493ef7c34d713" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;Boolean&lt;/code&gt; return type is requested, &lt;code&gt;Boolean.TRUE&lt;/code&gt; is returned if one or more nodes were selected; otherwise, &lt;code&gt;Boolean.FALSE&lt;/code&gt; is returned.</source>
          <target state="translated">とき &lt;code&gt;Boolean&lt;/code&gt; 戻り値の型が要求され、 &lt;code&gt;Boolean.TRUE&lt;/code&gt; 1つ以上のノードが選択された場合に返されます。それ以外の場合は、 &lt;code&gt;Boolean.FALSE&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="e2dfe78f2ad4f3813f1c14b93d0ec0c6be233cf4" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;Calendar&lt;/code&gt; is in non-lenient mode, it throws an exception if there is any inconsistency in its calendar fields. For example, a &lt;code&gt;GregorianCalendar&lt;/code&gt; always produces &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; values between 1 and the length of the month. A non-lenient &lt;code&gt;GregorianCalendar&lt;/code&gt; throws an exception upon calculating its time or calendar field values if any out-of-range field value has been set.</source>
          <target state="translated">&lt;code&gt;Calendar&lt;/code&gt; が非寛容モードの場合、Calendarフィールドに不整合があると例外がスローされます。たとえば、 &lt;code&gt;GregorianCalendar&lt;/code&gt; は常に1から月の長さまでの &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; 値を生成します。範囲外のフィールド値が設定されている場合、寛大でない &lt;code&gt;GregorianCalendar&lt;/code&gt; は、時間またはカレンダーフィールドの値を計算すると例外をスローします。</target>
        </trans-unit>
        <trans-unit id="42293990f57bc3f88207c3a41721f4ff5a428cf3" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;CompletionStage&lt;/code&gt; returned from &lt;a href=&quot;websocket.listener#onClose(java.net.http.WebSocket,int,java.lang.String)&quot;&gt;&lt;code&gt;Listener.onClose&lt;/code&gt;&lt;/a&gt; completes, the &lt;code&gt;WebSocket&lt;/code&gt; will send a Close message that has the same code the received message has and an empty reason.</source>
          <target state="translated">&lt;a href=&quot;websocket.listener#onClose(java.net.http.WebSocket,int,java.lang.String)&quot;&gt; &lt;code&gt;Listener.onClose&lt;/code&gt; &lt;/a&gt;から返された &lt;code&gt;CompletionStage&lt;/code&gt; が完了すると、 &lt;code&gt;WebSocket&lt;/code&gt; は、受信したメッセージと同じコードと空の理由を持つCloseメッセージを送信します。</target>
        </trans-unit>
        <trans-unit id="a356f25179772d20743b3c684279064beb377fbf" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;DatagramSocket&lt;/code&gt; is created the initial setting of &lt;code&gt;SO_REUSEADDR&lt;/code&gt; is disabled.</source>
          <target state="translated">とき &lt;code&gt;DatagramSocket&lt;/code&gt; 作成されるの初期設定 &lt;code&gt;SO_REUSEADDR&lt;/code&gt; が無効になっています。</target>
        </trans-unit>
        <trans-unit id="43ae46b786a991e294be5fd4ff96fd7edcdce9c4" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;Descriptor&lt;/code&gt; is used, the fields of interest are these:</source>
          <target state="translated">&lt;code&gt;Descriptor&lt;/code&gt; を使用する場合、対象となるフィールドは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="8380d9c546aba4d2b7dbbdb71fb24b8c1ed97298" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;DocumentFragment&lt;/code&gt; is inserted into a &lt;code&gt;Document&lt;/code&gt; (or indeed any other &lt;code&gt;Node&lt;/code&gt; that may take children) the children of the &lt;code&gt;DocumentFragment&lt;/code&gt; and not the &lt;code&gt;DocumentFragment&lt;/code&gt; itself are inserted into the &lt;code&gt;Node&lt;/code&gt;. This makes the &lt;code&gt;DocumentFragment&lt;/code&gt; very useful when the user wishes to create nodes that are siblings; the &lt;code&gt;DocumentFragment&lt;/code&gt; acts as the parent of these nodes so that the user can use the standard methods from the &lt;code&gt;Node&lt;/code&gt; interface, such as &lt;code&gt;Node.insertBefore&lt;/code&gt; and &lt;code&gt;Node.appendChild&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;DocumentFragment&lt;/code&gt; 中に挿入された &lt;code&gt;Document&lt;/code&gt; （実際又は他 &lt;code&gt;Node&lt;/code&gt; の子供を取ることができる）の子 &lt;code&gt;DocumentFragment&lt;/code&gt; なく、 &lt;code&gt;DocumentFragment&lt;/code&gt; 自身が挿入されている &lt;code&gt;Node&lt;/code&gt; 。これにより、ユーザーが兄弟であるノードを作成したい場合に &lt;code&gt;DocumentFragment&lt;/code&gt; が非常に役立ちます。 &lt;code&gt;DocumentFragment&lt;/code&gt; ユーザから標準的な方法を使用できるように、これらのノードの親として機能する &lt;code&gt;Node&lt;/code&gt; などのインターフェース、 &lt;code&gt;Node.insertBefore&lt;/code&gt; と &lt;code&gt;Node.appendChild&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="f9b7e8c421f422ce7ad6e056801a9b14403ef2ba" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;JoinRowSet&lt;/code&gt; object is created, it is empty. The first &lt;code&gt;RowSet&lt;/code&gt; object to be added becomes the basis for the &lt;code&gt;JOIN&lt;/code&gt; relationship. Applications must determine which column in each of the &lt;code&gt;RowSet&lt;/code&gt; objects to be added to the &lt;code&gt;JoinRowSet&lt;/code&gt; object should be the match column. All of the &lt;code&gt;RowSet&lt;/code&gt; objects must contain a match column, and the values in each match column must be ones that can be compared to values in the other match columns. The columns do not have to have the same name, though they often do, and they do not have to store the exact same data type as long as the data types can be compared.</source>
          <target state="translated">とき &lt;code&gt;JoinRowSet&lt;/code&gt; オブジェクトが作成され、それが空です。追加される最初の &lt;code&gt;RowSet&lt;/code&gt; オブジェクトは、 &lt;code&gt;JOIN&lt;/code&gt; 関係の基礎になります。アプリケーションは、 &lt;code&gt;JoinRowSet&lt;/code&gt; オブジェクトに追加される各 &lt;code&gt;RowSet&lt;/code&gt; オブジェクトのどの列を一致列にするかを決定する必要があります。すべての &lt;code&gt;RowSet&lt;/code&gt; オブジェクトには一致列が含まれている必要があり、各一致列の値は、他の一致列の値と比較できる値である必要があります。多くの場合、列の名前は同じである必要はありません。また、データ型を比較できる限り、まったく同じデータ型を格納する必要はありません。</target>
        </trans-unit>
        <trans-unit id="1ecb2985dc99729b931217f288615f118958b74e" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;LookAndFeel&lt;/code&gt; is installed the &lt;code&gt;UIManager&lt;/code&gt; does not check that an entry exists for all ui class ids. As such, random exceptions will occur if the current look and feel has not provided a value for a particular ui class id and an instance of the &lt;code&gt;JComponent&lt;/code&gt; subclass is created.</source>
          <target state="translated">&lt;code&gt;LookAndFeel&lt;/code&gt; がインストールされている場合、 &lt;code&gt;UIManager&lt;/code&gt; はすべてのUIクラスIDのエントリが存在することを確認しません。そのため、現在のルックアンドフィールが特定のUIクラスIDの値を提供しておらず、 &lt;code&gt;JComponent&lt;/code&gt; サブクラスのインスタンスが作成されている場合、ランダムな例外が発生します。</target>
        </trans-unit>
        <trans-unit id="db057955ab30883a5287d3d1d0441c5297d96c2f" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;MathContext&lt;/code&gt; object is supplied with a precision setting of 0 (for example, &lt;a href=&quot;mathcontext#UNLIMITED&quot;&gt;&lt;code&gt;MathContext.UNLIMITED&lt;/code&gt;&lt;/a&gt;), arithmetic operations are exact, as are the arithmetic methods which take no &lt;code&gt;MathContext&lt;/code&gt; object. (This is the only behavior that was supported in releases prior to 5.) As a corollary of computing the exact result, the rounding mode setting of a &lt;code&gt;MathContext&lt;/code&gt; object with a precision setting of 0 is not used and thus irrelevant. In the case of divide, the exact quotient could have an infinitely long decimal expansion; for example, 1 divided by 3. If the quotient has a nonterminating decimal expansion and the operation is specified to return an exact result, an &lt;code&gt;ArithmeticException&lt;/code&gt; is thrown. Otherwise, the exact result of the division is returned, as done for other operations.</source>
          <target state="translated">&lt;code&gt;MathContext&lt;/code&gt; オブジェクトに精度設定0が指定されている場合（たとえば、&lt;a href=&quot;mathcontext#UNLIMITED&quot;&gt; &lt;code&gt;MathContext.UNLIMITED&lt;/code&gt; &lt;/a&gt;）、 &lt;code&gt;MathContext&lt;/code&gt; オブジェクトを使用しない算術メソッドと同様に、算術演算は正確です。 （これは、5より前のリリースでサポートされていた唯一の動作です。）正確な結果を計算する結果として、精度設定が0の &lt;code&gt;MathContext&lt;/code&gt; オブジェクトの丸めモード設定は使用されないため、無関係です。除算の場合、正確な商は無限に長い10進展開を持つ可能性があります。たとえば、1を3で割った値。商に非終了の10進展開があり、演算が正確な結果を返すように指定されている場合、 &lt;code&gt;ArithmeticException&lt;/code&gt; スローされます。それ以外の場合は、他の演算と同様に、除算の正確な結果が返されます。</target>
        </trans-unit>
        <trans-unit id="0cea0471bcac1fec9656ca87e5e77807a3aadf7c" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;Node&lt;/code&gt; is copied using the &lt;code&gt;cloneNode&lt;/code&gt; method the &lt;code&gt;EventListener&lt;/code&gt;s attached to the source &lt;code&gt;Node&lt;/code&gt; are not attached to the copied &lt;code&gt;Node&lt;/code&gt;. If the user wishes the same &lt;code&gt;EventListener&lt;/code&gt;s to be added to the newly created copy the user must add them manually.</source>
          <target state="translated">ときに &lt;code&gt;Node&lt;/code&gt; 使用してコピーされる &lt;code&gt;cloneNode&lt;/code&gt; をする方法を &lt;code&gt;EventListener&lt;/code&gt; のソースに取り付けられた &lt;code&gt;Node&lt;/code&gt; コピーに取り付けられていない &lt;code&gt;Node&lt;/code&gt; 。ユーザーが同じ &lt;code&gt;EventListener&lt;/code&gt; を新しく作成されたコピーに追加することを希望する場合、ユーザーはそれらを手動で追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="8c8fb24cbf878544c9fafb9bba4f04c53ebcb063" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;PKIXParameters&lt;/code&gt; object is created, this flag is set to true. This setting reflects the most common (and simplest) strategy for processing policy qualifiers. Applications that want to use a more sophisticated policy must set this flag to false.</source>
          <target state="translated">とき &lt;code&gt;PKIXParameters&lt;/code&gt; オブジェクトが作成され、このフラグがtrueに設定されています。この設定は、ポリシー修飾子を処理するための最も一般的な（そして最も単純な）戦略を反映しています。より高度なポリシーを使用するアプリケーションは、このフラグをfalseに設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="1fecae07ed08389b98c0a767668b060b64f63995" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;PKIXParameters&lt;/code&gt; object is created, this flag is set to true. This setting reflects the most common strategy for checking revocation, since each service provider must support revocation checking to be PKIX compliant. Sophisticated applications should set this flag to false when it is not practical to use a PKIX service provider's default revocation checking mechanism or when an alternative revocation checking mechanism is to be substituted (by also calling the &lt;a href=&quot;#addCertPathChecker(java.security.cert.PKIXCertPathChecker)&quot;&gt;&lt;code&gt;addCertPathChecker&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#setCertPathCheckers(java.util.List)&quot;&gt;&lt;code&gt;setCertPathCheckers&lt;/code&gt;&lt;/a&gt; methods).</source>
          <target state="translated">とき &lt;code&gt;PKIXParameters&lt;/code&gt; オブジェクトが作成され、このフラグがtrueに設定されています。各サービスプロバイダーはPKIXに準拠するために失効チェックをサポートする必要があるため、この設定は失効をチェックするための最も一般的な戦略を反映しています。高度なアプリケーションでは、PKIXサービスプロバイダーのデフォルトの失効チェックメカニズムを使用することが現実的でない場合、または代替の失効チェックメカニズムを代用する場合（&lt;a href=&quot;#addCertPathChecker(java.security.cert.PKIXCertPathChecker)&quot;&gt; &lt;code&gt;addCertPathChecker&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#setCertPathCheckers(java.util.List)&quot;&gt; &lt;code&gt;setCertPathCheckers&lt;/code&gt; &lt;/a&gt;メソッドも呼び出す）、このフラグをfalseに設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="e2e645d09fe7ffd9051e432a2e16d92d9eb058b1" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;PKIXParameters&lt;/code&gt; object is created, this flag is set to true. This setting reflects the most common strategy for checking revocation, since each service provider must support revocation checking to be PKIX compliant. Sophisticated applications should set this flag to false when it is not practical to use a PKIX service provider's default revocation checking mechanism or when an alternative revocation checking mechanism is to be substituted (by also calling the &lt;a href=&quot;pkixparameters#addCertPathChecker-java.security.cert.PKIXCertPathChecker-&quot;&gt;&lt;code&gt;addCertPathChecker&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;pkixparameters#setCertPathCheckers-java.util.List-&quot;&gt;&lt;code&gt;setCertPathCheckers&lt;/code&gt;&lt;/a&gt; methods).</source>
          <target state="translated">とき &lt;code&gt;PKIXParameters&lt;/code&gt; オブジェクトが作成され、このフラグがtrueに設定されています。各サービスプロバイダーは失効チェックをサポートしてPKIXに準拠する必要があるため、この設定は失効チェックの最も一般的な戦略を反映しています。 PKIXサービスプロバイダーのデフォルトの失効確認メカニズムを使用することが実用的でない場合、または代替の失効確認メカニズムが（&lt;a href=&quot;pkixparameters#addCertPathChecker-java.security.cert.PKIXCertPathChecker-&quot;&gt; &lt;code&gt;addCertPathChecker&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;pkixparameters#setCertPathCheckers-java.util.List-&quot;&gt; &lt;code&gt;setCertPathCheckers&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことによって）置き換えられる場合は、高度なアプリケーションでこのフラグをfalseに設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="e1bdbad97a0491d45ccc56940a6c55eb21cbca0d" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;ResourceBundle&lt;/code&gt; was inherited or specified through the &lt;a href=&quot;#setResourceBundle(java.util.ResourceBundle)&quot;&gt;&lt;code&gt;setResourceBundle&lt;/code&gt;&lt;/a&gt; method, then that &lt;code&gt;ResourceBundle&lt;/code&gt; will be used. Otherwise if the logger only has or inherited a resource bundle name, then that resource bundle name will be mapped to a &lt;code&gt;ResourceBundle&lt;/code&gt; object, using the default Locale at the time of logging.</source>
          <target state="translated">&lt;code&gt;ResourceBundle&lt;/code&gt; が&lt;a href=&quot;#setResourceBundle(java.util.ResourceBundle)&quot;&gt; &lt;code&gt;setResourceBundle&lt;/code&gt; &lt;/a&gt;メソッドを介して継承または指定された場合、その &lt;code&gt;ResourceBundle&lt;/code&gt; が使用されます。それ以外の場合、ロガーがリソースバンドル名のみを持っているか継承している場合、そのリソースバンドル名は、ロギング時にデフォルトのロケールを使用して &lt;code&gt;ResourceBundle&lt;/code&gt; オブジェクトにマップされます。</target>
        </trans-unit>
        <trans-unit id="c511cae88643a751f32e0d10e8a985db173ad353" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;ResourceBundle&lt;/code&gt; was inherited or specified through the &lt;a href=&quot;logger#setResourceBundle-java.util.ResourceBundle-&quot;&gt;&lt;code&gt;setResourceBundle&lt;/code&gt;&lt;/a&gt; method, then that &lt;code&gt;ResourceBundle&lt;/code&gt; will be used. Otherwise if the logger only has or inherited a resource bundle name, then that resource bundle name will be mapped to a &lt;code&gt;ResourceBundle&lt;/code&gt; object, using the default Locale at the time of logging.</source>
          <target state="translated">&lt;code&gt;ResourceBundle&lt;/code&gt; が継承されるか、&lt;a href=&quot;logger#setResourceBundle-java.util.ResourceBundle-&quot;&gt; &lt;code&gt;setResourceBundle&lt;/code&gt; &lt;/a&gt;メソッドを介して指定された場合、その &lt;code&gt;ResourceBundle&lt;/code&gt; が使用されます。それ以外の場合、ロガーがリソースバンドル名のみを持っているか、継承した場合、そのリソースバンドル名は、ロギング時にデフォルトのロケールを使用して、 &lt;code&gt;ResourceBundle&lt;/code&gt; オブジェクトにマップされます。</target>
        </trans-unit>
        <trans-unit id="b7a5a177904b96f015c06307ad10fbc63f60c2f8" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;ResultSet&lt;/code&gt; is closed, any &lt;code&gt;ResultSetMetaData&lt;/code&gt; instances that were created by calling the &lt;code&gt;getMetaData&lt;/code&gt; method remain accessible.</source>
          <target state="translated">とき &lt;code&gt;ResultSet&lt;/code&gt; 閉じて、任意の &lt;code&gt;ResultSetMetaData&lt;/code&gt; 呼び出すことによって作成されたインスタンス &lt;code&gt;getMetaData&lt;/code&gt; 方法がアクセス可能なまま。</target>
        </trans-unit>
        <trans-unit id="b33e9674235e0636be1c47ce12e9e34568e5c11d" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;Scanner&lt;/code&gt; is closed, it will close its input source if the source implements the &lt;a href=&quot;../io/closeable&quot;&gt;&lt;code&gt;Closeable&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">&lt;code&gt;Scanner&lt;/code&gt; が閉じているとき、ソースが&lt;a href=&quot;../io/closeable&quot;&gt; &lt;code&gt;Closeable&lt;/code&gt; &lt;/a&gt;インターフェースを実装している場合、スキャナーは入力ソースを閉じます。</target>
        </trans-unit>
        <trans-unit id="af91e23da41d9929e2e507d4f86a71d5504d82ff" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;ServerSocket&lt;/code&gt; is created the initial setting of &lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt;&lt;code&gt;SO_REUSEADDR&lt;/code&gt;&lt;/a&gt; is not defined. Applications can use &lt;a href=&quot;#getReuseAddress()&quot;&gt;&lt;code&gt;getReuseAddress()&lt;/code&gt;&lt;/a&gt; to determine the initial setting of &lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt;&lt;code&gt;SO_REUSEADDR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ServerSocket&lt;/code&gt; が作成されるとき、&lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt; &lt;code&gt;SO_REUSEADDR&lt;/code&gt; &lt;/a&gt;の初期設定は定義されていません。アプリケーションは、使用することができます&lt;a href=&quot;#getReuseAddress()&quot;&gt; &lt;code&gt;getReuseAddress()&lt;/code&gt; &lt;/a&gt;の初期設定を決定するために&lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt; &lt;code&gt;SO_REUSEADDR&lt;/code&gt; を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d0ea93fe34d0cbcc920144a03e28605555397e46" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;ServerSocket&lt;/code&gt; is created the initial setting of &lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt;&lt;code&gt;SO_REUSEADDR&lt;/code&gt;&lt;/a&gt; is not defined. Applications can use &lt;a href=&quot;serversocket#getReuseAddress--&quot;&gt;&lt;code&gt;getReuseAddress()&lt;/code&gt;&lt;/a&gt; to determine the initial setting of &lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt;&lt;code&gt;SO_REUSEADDR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ServerSocket&lt;/code&gt; が作成されるとき、&lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt; &lt;code&gt;SO_REUSEADDR&lt;/code&gt; &lt;/a&gt;の初期設定は定義されていません。アプリケーションは、使用することができます&lt;a href=&quot;serversocket#getReuseAddress--&quot;&gt; &lt;code&gt;getReuseAddress()&lt;/code&gt; &lt;/a&gt;の初期設定を決定するために&lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt; &lt;code&gt;SO_REUSEADDR&lt;/code&gt; を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f0455bab8e7854f1380ef3d296a0c738fc6d405a" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;Socket&lt;/code&gt; is created the initial setting of &lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt;&lt;code&gt;SO_REUSEADDR&lt;/code&gt;&lt;/a&gt; is disabled.</source>
          <target state="translated">ときに &lt;code&gt;Socket&lt;/code&gt; 作成されるの初期設定&lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt; &lt;code&gt;SO_REUSEADDR&lt;/code&gt; が&lt;/a&gt;無効になっています。</target>
        </trans-unit>
        <trans-unit id="2fee0877683a4237d7d04165c6386560ed02539f" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;double&lt;/code&gt; must be used as a source for a &lt;code&gt;BigDecimal&lt;/code&gt;, note that this constructor provides an exact conversion; it does not give the same result as converting the &lt;code&gt;double&lt;/code&gt; to a &lt;code&gt;String&lt;/code&gt; using the &lt;a href=&quot;../lang/double#toString(double)&quot;&gt;&lt;code&gt;Double.toString(double)&lt;/code&gt;&lt;/a&gt; method and then using the &lt;a href=&quot;#%3Cinit%3E(java.lang.String)&quot;&gt;&lt;code&gt;BigDecimal(String)&lt;/code&gt;&lt;/a&gt; constructor. To get that result, use the &lt;code&gt;static&lt;/code&gt;&lt;a href=&quot;#valueOf(double)&quot;&gt;&lt;code&gt;valueOf(double)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt; を &lt;code&gt;BigDecimal&lt;/code&gt; のソースとして使用する必要がある場合、このコンストラクターは正確な変換を提供することに注意してください。&lt;a href=&quot;../lang/double#toString(double)&quot;&gt; &lt;code&gt;Double.toString(double)&lt;/code&gt; &lt;/a&gt;メソッドを使用して &lt;code&gt;double&lt;/code&gt; を &lt;code&gt;String&lt;/code&gt; に変換してから、&lt;a href=&quot;#%3Cinit%3E(java.lang.String)&quot;&gt; &lt;code&gt;BigDecimal(String)&lt;/code&gt; &lt;/a&gt;コンストラクターを使用した場合と同じ結果は得られません。その結果を得るには、 &lt;code&gt;static&lt;/code&gt; &lt;a href=&quot;#valueOf(double)&quot;&gt; &lt;code&gt;valueOf(double)&lt;/code&gt; &lt;/a&gt;メソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="1a039e1d49f70a273c394bc527a427829f3c4985" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;double&lt;/code&gt; must be used as a source for a &lt;code&gt;BigDecimal&lt;/code&gt;, note that this constructor provides an exact conversion; it does not give the same result as converting the &lt;code&gt;double&lt;/code&gt; to a &lt;code&gt;String&lt;/code&gt; using the &lt;a href=&quot;../lang/double#toString-double-&quot;&gt;&lt;code&gt;Double.toString(double)&lt;/code&gt;&lt;/a&gt; method and then using the &lt;a href=&quot;bigdecimal#BigDecimal-java.lang.String-&quot;&gt;&lt;code&gt;BigDecimal(String)&lt;/code&gt;&lt;/a&gt; constructor. To get that result, use the &lt;code&gt;static&lt;/code&gt;&lt;a href=&quot;bigdecimal#valueOf-double-&quot;&gt;&lt;code&gt;valueOf(double)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt; を &lt;code&gt;BigDecimal&lt;/code&gt; のソースとして使用する必要がある場合、このコンストラクターは正確な変換を提供することに注意してください。&lt;a href=&quot;../lang/double#toString-double-&quot;&gt; &lt;code&gt;Double.toString(double)&lt;/code&gt; &lt;/a&gt;メソッドを使用して &lt;code&gt;double&lt;/code&gt; を &lt;code&gt;String&lt;/code&gt; に変換してから&lt;a href=&quot;bigdecimal#BigDecimal-java.lang.String-&quot;&gt; &lt;code&gt;BigDecimal(String)&lt;/code&gt; &lt;/a&gt;コンストラクターを使用するのと同じ結果は得られません。その結果を取得するには、 &lt;code&gt;static&lt;/code&gt; &lt;a href=&quot;bigdecimal#valueOf-double-&quot;&gt; &lt;code&gt;valueOf(double)&lt;/code&gt; &lt;/a&gt;メソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="6527806b79e3b486f23af62691038fe376e23d6f" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;java.lang.Error&lt;/code&gt; occurs in the agent it should be caught and re-thrown as a &lt;code&gt;RuntimeErrorException&lt;/code&gt;.</source>
          <target state="translated">とき &lt;code&gt;java.lang.Error&lt;/code&gt; エージェントで発生し、それがキャッチとして再スローする必要があります &lt;code&gt;RuntimeErrorException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a1362f6628b563d356e949983f03f9000a84379" translate="yes" xml:space="preserve">
          <source>When a BoundedRange model is used with a scrollbar the extent defines the length of the scrollbar knob (aka the &quot;thumb&quot; or &quot;elevator&quot;). The extent usually represents how much of the object being scrolled is visible. When used with a slider, the extent determines how much the value can &quot;jump&quot;, for example when the user presses PgUp or PgDn.</source>
          <target state="translated">BoundedRangeモデルがスクロールバーと共に使用される場合、エクステントはスクロールバーのノブ(別名「サム」または「エレベータ」)の長さを定義します。通常、エクステントは、スクロールされるオブジェクトの可視範囲を表します。スライダと一緒に使用する場合、エクステントは、ユーザーが PgUp または PgDn を押したときなど、値がどの程度「ジャンプ」するかを決定します。</target>
        </trans-unit>
        <trans-unit id="9c90ea452e81ba4569ae99ffac2958ce33a2a19f" translate="yes" xml:space="preserve">
          <source>When a BoundedRange model is used with a scrollbar the value specifies the origin of the scrollbar knob (aka the &quot;thumb&quot; or &quot;elevator&quot;). The value usually represents the origin of the visible part of the object being scrolled.</source>
          <target state="translated">BoundedRangeモデルがスクロールバーと共に使用されている場合、値はスクロールバーのノブ(別名「サム」または「エレベータ」)の原点を指定します。この値は通常、スクロールされるオブジェクトの可視部分の原点を表します。</target>
        </trans-unit>
        <trans-unit id="2a2d8c26085a986f69098405e00452247f97fcb7" translate="yes" xml:space="preserve">
          <source>When a Driver class is loaded, it should create an instance of itself and register it with the DriverManager. This means that a user can load and register a driver by calling:</source>
          <target state="translated">Driver クラスがロードされると、それ自体のインスタンスを作成し、DriverManager に登録する必要があります。つまり、ユーザが呼び出すことでドライバをロードして登録することができます。</target>
        </trans-unit>
        <trans-unit id="ac2232cc133cdbf38b6f9aa25e3da077f2459d69" translate="yes" xml:space="preserve">
          <source>When a JVM is launched in a way that indicates an agent class. In that case an &lt;code&gt;Instrumentation&lt;/code&gt; instance is passed to the &lt;code&gt;premain&lt;/code&gt; method of the agent class.</source>
          <target state="translated">JVMがエージェントクラスを示す方法で起動されたとき。その場合、 &lt;code&gt;Instrumentation&lt;/code&gt; インスタンスがエージェントクラスの &lt;code&gt;premain&lt;/code&gt; メソッドに渡されます。</target>
        </trans-unit>
        <trans-unit id="bc6710d50791c1a74ebb5f190790f0fa28c0deca" translate="yes" xml:space="preserve">
          <source>When a JVM provides a mechanism to start agents sometime after the JVM is launched. In that case an &lt;code&gt;Instrumentation&lt;/code&gt; instance is passed to the &lt;code&gt;agentmain&lt;/code&gt; method of the agent code.</source>
          <target state="translated">JVMの起動後、JVMがエージェントを起動するメカニズムを提供する場合。その場合、 &lt;code&gt;Instrumentation&lt;/code&gt; インスタンスがエージェントコードの &lt;code&gt;agentmain&lt;/code&gt; メソッドに渡されます。</target>
        </trans-unit>
        <trans-unit id="fe6f53c2c934674a6688b208d3ae4e419bb93e41" translate="yes" xml:space="preserve">
          <source>When a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named &lt;code&gt;main&lt;/code&gt; of some designated class). The Java Virtual Machine continues to execute threads until either of the following occurs:</source>
          <target state="translated">Java Virtual Machineが起動すると、通常、1つの非デーモンスレッドが存在します（これは通常、指定されたクラスの &lt;code&gt;main&lt;/code&gt; という名前のメソッドを呼び出します）。Java仮想マシンは、次のいずれかが発生するまでスレッドを実行し続けます。</target>
        </trans-unit>
        <trans-unit id="679be8f92ef7e9ad73d5185ae525f63b8b428a90" translate="yes" xml:space="preserve">
          <source>When a Java program runs, a large number of &lt;code&gt;Graphics&lt;/code&gt; objects can be created within a short time frame. Although the finalization process of the garbage collector also disposes of the same system resources, it is preferable to manually free the associated resources by calling this method rather than to rely on a finalization process which may not run to completion for a long period of time.</source>
          <target state="translated">Javaプログラムを実行すると、短い時間枠内に多数の &lt;code&gt;Graphics&lt;/code&gt; オブジェクトを作成できます。ガベージコレクタのファイナライズプロセスでも同じシステムリソースが破棄されますが、長期間実行されない可能性のあるファイナライズプロセスに依存するよりも、このメソッドを呼び出して関連するリソースを手動で解放することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="591e6c34b6ba8d6f3eeb6796c729752f095528e6" translate="yes" xml:space="preserve">
          <source>When a LogRecord is passed into the logging framework it logically belongs to the framework and should no longer be used or updated by the client application.</source>
          <target state="translated">LogRecord がロギングフレームワークに渡されるとき、それは論理的にフレームワークに属し、クライアントアプリケーションによって使用されたり更新されたりすることはありません。</target>
        </trans-unit>
        <trans-unit id="760cbf62cac395bf976d73378ca4ebfb39c0855a" translate="yes" xml:space="preserve">
          <source>When a MenuElement receives an event from a KeyListener, it should never process the event directly.</source>
          <target state="translated">MenuElementがKeyListenerからイベントを受信した場合、そのイベントを直接処理してはいけません。</target>
        </trans-unit>
        <trans-unit id="f3e01acb00e3633472670e98ba3b82778f6c5de9" translate="yes" xml:space="preserve">
          <source>When a MenuElement receives an event from a KeyListener, it should never process the event directly. Instead all MenuElements should call this method with the event.</source>
          <target state="translated">MenuElement が KeyListener からイベントを受け取った場合、そのイベントを直接処理してはいけません。その代わりに、すべての MenuElements は、イベントと共にこのメソッドを呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="3a264f4f3f88ff6f8c7f2e0d665633e1f71e9b05" translate="yes" xml:space="preserve">
          <source>When a MenuElement receives an event from a MouseListener, it should never process the event directly.</source>
          <target state="translated">MenuElementがMouseListenerからイベントを受信した場合、そのイベントを直接処理してはいけません。</target>
        </trans-unit>
        <trans-unit id="4d11ed3673e1ba2ba2cacee39f6b7d24eb7ebca6" translate="yes" xml:space="preserve">
          <source>When a MenuElement receives an event from a MouseListener, it should never process the event directly. Instead all MenuElements should call this method with the event.</source>
          <target state="translated">MenuElementがMouseListenerからイベントを受け取った場合、そのイベントを直接処理してはいけません。その代わりに、すべてのMenuElementsは、イベントと共にこのメソッドを呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="b38b56c9df7506bfe3ea2ad2db230dd732a913c0" translate="yes" xml:space="preserve">
          <source>When a SAX2 driver is providing these events, all other events must be properly nested within start/end entity events. There is no additional requirement that events from &lt;a href=&quot;declhandler&quot;&gt;&lt;code&gt;DeclHandler&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../dtdhandler&quot;&gt;&lt;code&gt;DTDHandler&lt;/code&gt;&lt;/a&gt; be properly ordered.</source>
          <target state="translated">SAX2ドライバーがこれらのイベントを提供している場合、他のすべてのイベントは、開始/終了エンティティイベント内に適切にネストされている必要があります。&lt;a href=&quot;declhandler&quot;&gt; &lt;code&gt;DeclHandler&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../dtdhandler&quot;&gt; &lt;code&gt;DTDHandler&lt;/code&gt; &lt;/a&gt;からのイベントを適切に順序付ける必要はありません。</target>
        </trans-unit>
        <trans-unit id="ca65f59c344aab5c1b12d68027c6ad5c16f0ae24" translate="yes" xml:space="preserve">
          <source>When a Standard MBean is made from the &lt;code&gt;CacheControlMBean&lt;/code&gt;, the usual rules mean that it will have an attribute called &lt;code&gt;CacheSize&lt;/code&gt; of type &lt;code&gt;long&lt;/code&gt;. The &lt;code&gt;@Units&lt;/code&gt; annotation, given the above definition, will ensure that the &lt;a href=&quot;mbeanattributeinfo&quot;&gt;&lt;code&gt;MBeanAttributeInfo&lt;/code&gt;&lt;/a&gt; for this attribute will have a &lt;code&gt;Descriptor&lt;/code&gt; that has a field called &lt;code&gt;units&lt;/code&gt; with corresponding value &lt;code&gt;bytes&lt;/code&gt;.</source>
          <target state="translated">標準MBeanが &lt;code&gt;CacheControlMBean&lt;/code&gt; から作成される場合、通常の規則は、それが &lt;code&gt;long&lt;/code&gt; 型の &lt;code&gt;CacheSize&lt;/code&gt; と呼ばれる属性を持つことを意味します。 &lt;code&gt;@Units&lt;/code&gt; 上記の定義指定された注釈は、ことを保証する&lt;a href=&quot;mbeanattributeinfo&quot;&gt; &lt;code&gt;MBeanAttributeInfo&lt;/code&gt; &lt;/a&gt;この属性が持つ &lt;code&gt;Descriptor&lt;/code&gt; と呼ばれるフィールド有する &lt;code&gt;units&lt;/code&gt; 値の対応する &lt;code&gt;bytes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cbdb2811ada49ec4e07a613aa3a52601e1be6d55" translate="yes" xml:space="preserve">
          <source>When a TCP connection is closed the connection may remain in a timeout state for a period of time after the connection is closed (typically known as the &lt;code&gt;TIME_WAIT&lt;/code&gt; state or &lt;code&gt;2MSL&lt;/code&gt; wait state). For applications using a well known socket address or port it may not be possible to bind a socket to the required &lt;code&gt;SocketAddress&lt;/code&gt; if there is a connection in the timeout state involving the socket address or port.</source>
          <target state="translated">TCP接続が閉じられると、接続が閉じられた後、接続はしばらくタイムアウト状態のままになることがあります（通常、 &lt;code&gt;TIME_WAIT&lt;/code&gt; 状態または &lt;code&gt;2MSL&lt;/code&gt; 待機状態として知られています）。よく知られているソケットアドレスまたはポートを使用するアプリケーションの場合、ソケットアドレスまたはポートに関連するタイムアウト状態の接続があると、ソケットを必要な &lt;code&gt;SocketAddress&lt;/code&gt; にバインドできない場合があります。</target>
        </trans-unit>
        <trans-unit id="35d883e644cee8d8bc00892c83d14b9e68a7c0d4" translate="yes" xml:space="preserve">
          <source>When a TemplatesHandler object is used as a ContentHandler for the parsing of transformation instructions, it creates a Templates object, which the caller can get once the SAX events have been completed.</source>
          <target state="translated">TemplatesHandler オブジェクトが変換命令の解析のための ContentHandler として使用される場合、Templates オブジェクトが作成され、SAX イベントが完了すると呼び出し元が取得できるようになります。</target>
        </trans-unit>
        <trans-unit id="a41e85f29028d8394c11ed11faa2b621db688b13" translate="yes" xml:space="preserve">
          <source>When a URL string (a &lt;code&gt;String&lt;/code&gt; of the form &lt;em&gt;scheme_id:rest_of_name&lt;/em&gt;) is passed as a name parameter to any method, a URL context factory for handling that scheme is located and used to resolve the URL. If no such factory is found, the initial context specified by &lt;code&gt;&quot;java.naming.factory.initial&quot;&lt;/code&gt; is used. Similarly, when a &lt;code&gt;CompositeName&lt;/code&gt; object whose first component is a URL string is passed as a name parameter to any method, a URL context factory is located and used to resolve the first name component. See &lt;a href=&quot;spi/namingmanager#getURLContext(java.lang.String,java.util.Hashtable)&quot;&gt;&lt;code&gt;NamingManager.getURLContext()&lt;/code&gt;&lt;/a&gt; for a description of how URL context factories are located.</source>
          <target state="translated">場合は、URL文字列（ &lt;code&gt;String&lt;/code&gt; の形式のが&lt;em&gt;scheme_id：rest_of_nameを&lt;/em&gt;）任意のメソッドに名前のパラメータとして渡され、そのスキームを処理するためのURLコンテキストファクトリは位置しており、URLを解決するために使用されます。そのようなファクトリが見つからない場合は、 &lt;code&gt;&quot;java.naming.factory.initial&quot;&lt;/code&gt; 指定された初期コンテキストが使用されます。同様に、最初のコンポーネントがURL文字列である &lt;code&gt;CompositeName&lt;/code&gt; オブジェクトが名前パラメーターとして任意のメソッドに渡されると、URLコンテキストファクトリが検索され、名前コンポーネントを解決するために使用されます。URLコンテキストファクトリの配置方法の説明については、&lt;a href=&quot;spi/namingmanager#getURLContext(java.lang.String,java.util.Hashtable)&quot;&gt; &lt;code&gt;NamingManager.getURLContext()&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="2f10e21dabecf61050cfb5e9bd4dbd4d574ca5d4" translate="yes" xml:space="preserve">
          <source>When a URL string (a &lt;code&gt;String&lt;/code&gt; of the form &lt;em&gt;scheme_id:rest_of_name&lt;/em&gt;) is passed as a name parameter to any method, a URL context factory for handling that scheme is located and used to resolve the URL. If no such factory is found, the initial context specified by &lt;code&gt;&quot;java.naming.factory.initial&quot;&lt;/code&gt; is used. Similarly, when a &lt;code&gt;CompositeName&lt;/code&gt; object whose first component is a URL string is passed as a name parameter to any method, a URL context factory is located and used to resolve the first name component. See &lt;a href=&quot;spi/namingmanager#getURLContext-java.lang.String-java.util.Hashtable-&quot;&gt;&lt;code&gt;&lt;code&gt;NamingManager.getURLContext()&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; for a description of how URL context factories are located.</source>
          <target state="translated">場合は、URL文字列（ &lt;code&gt;String&lt;/code&gt; の形式のが&lt;em&gt;scheme_id：rest_of_nameを&lt;/em&gt;）任意のメソッドに名前のパラメータとして渡され、そのスキームを処理するためのURLコンテキストファクトリは位置しており、URLを解決するために使用されます。そのようなファクトリが見つからない場合、 &lt;code&gt;&quot;java.naming.factory.initial&quot;&lt;/code&gt; 指定された初期コンテキストが使用されます。同様に、最初のコンポーネントがURL文字列である &lt;code&gt;CompositeName&lt;/code&gt; オブジェクトが名前パラメーターとして任意のメソッドに渡されると、URLコンテキストファクトリが検索され、最初の名前のコンポーネントを解決するために使用されます。URLコンテキストファクトリの配置方法については、&lt;a href=&quot;spi/namingmanager#getURLContext-java.lang.String-java.util.Hashtable-&quot;&gt; &lt;code&gt;&lt;code&gt;NamingManager.getURLContext()&lt;/code&gt;&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="429dc27d49480e2ab4eab569d5adf4cd4c7c135e" translate="yes" xml:space="preserve">
          <source>When a VolatileImage object is created, limited system resources such as video memory (VRAM) may be allocated in order to support the image. When a VolatileImage object is no longer used, it may be garbage-collected and those system resources will be returned, but this process does not happen at guaranteed times. Applications that create many VolatileImage objects (for example, a resizing window may force recreation of its back buffer as the size changes) may run out of optimal system resources for new VolatileImage objects simply because the old objects have not yet been removed from the system. (New VolatileImage objects may still be created, but they may not perform as well as those created in accelerated memory). The flush method may be called at any time to proactively release the resources used by a VolatileImage so that it does not prevent subsequent VolatileImage objects from being accelerated. In this way, applications can have more control over the state of the resources taken up by obsolete VolatileImage objects.</source>
          <target state="translated">VolatileImageオブジェクトが作成されると、イメージをサポートするためにビデオメモリ(VRAM)などの限られたシステムリソースが割り当てられることがあります。VolatileImage オブジェクトが使用されなくなると、そのオブジェクトはゴミ箱に回収され、システムリソースが返却されますが、この処理は保証されたタイミングで行われるわけではありません。多くのVolatileImageオブジェクトを作成するアプリケーション(例えば、サイズ変更に伴ってウィンドウのサイズが変更されると、そのバックバッファが再作成されることがあります)では、古いオブジェクトがシステムから削除されていないだけで、新しいVolatileImageオブジェクトに最適なシステムリソースが不足してしまうことがあります。(新しいVolatileImageオブジェクトの作成は可能ですが、加速メモリで作成されたものほどのパフォーマンスは得られないかもしれません)。flushメソッドは、後続のVolatileImageオブジェクトの加速化を妨げないように、VolatileImageによって使用されているリソースを積極的に解放するためにいつでも呼び出すことができます。このようにして、アプリケーションは、廃止されたVolatileImageオブジェクトが使用しているリソースの状態をよりコントロールすることができます。</target>
        </trans-unit>
        <trans-unit id="432971c4a856cab249165ae9a9e506665b76935a" translate="yes" xml:space="preserve">
          <source>When a button is pressed and released, AWT sends an instance of &lt;code&gt;ActionEvent&lt;/code&gt; to the button, by calling &lt;code&gt;processEvent&lt;/code&gt; on the button. The button's &lt;code&gt;processEvent&lt;/code&gt; method receives all events for the button; it passes an action event along by calling its own &lt;code&gt;processActionEvent&lt;/code&gt; method. The latter method passes the action event on to any action listeners that have registered an interest in action events generated by this button.</source>
          <target state="translated">ボタンが押されて離されると、AWTはボタンで &lt;code&gt;processEvent&lt;/code&gt; を呼び出すことにより、 &lt;code&gt;ActionEvent&lt;/code&gt; のインスタンスをボタンに送信します。ボタンの &lt;code&gt;processEvent&lt;/code&gt; メソッドは、ボタンのすべてのイベントを受け取ります。独自の &lt;code&gt;processActionEvent&lt;/code&gt; メソッドを呼び出すことにより、アクションイベントを渡します。後者の方法は、このボタンによって生成されたアクションイベントへの関心を登録したアクションリスナーにアクションイベントを渡します。</target>
        </trans-unit>
        <trans-unit id="2dffdc7e8d88a4030ccf25d0b91c9d8a92081e9c" translate="yes" xml:space="preserve">
          <source>When a call to the &lt;code&gt;next&lt;/code&gt; method returns &lt;code&gt;false&lt;/code&gt;, the cursor is positioned after the last row. Any invocation of a &lt;code&gt;ResultSet&lt;/code&gt; method which requires a current row will result in a &lt;code&gt;SQLException&lt;/code&gt; being thrown. If the result set type is &lt;code&gt;TYPE_FORWARD_ONLY&lt;/code&gt;, it is vendor specified whether their JDBC driver implementation will return &lt;code&gt;false&lt;/code&gt; or throw an &lt;code&gt;SQLException&lt;/code&gt; on a subsequent call to &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;next&lt;/code&gt; メソッドの呼び出しが &lt;code&gt;false&lt;/code&gt; を返す場合、カーソルは最後の行の後に配置されます。現在の行を必要とする &lt;code&gt;ResultSet&lt;/code&gt; メソッドを呼び出すと、 &lt;code&gt;SQLException&lt;/code&gt; がスローされます。結果セットのタイプが &lt;code&gt;TYPE_FORWARD_ONLY&lt;/code&gt; の場合、JDBCドライバーの実装が &lt;code&gt;false&lt;/code&gt; を返すか、 &lt;code&gt;next&lt;/code&gt; への後続の呼び出しで &lt;code&gt;SQLException&lt;/code&gt; をスローするかはベンダーが指定します。</target>
        </trans-unit>
        <trans-unit id="dcde7f6440e70bd0233d9ec912e740d889f8535e" translate="yes" xml:space="preserve">
          <source>When a call to the &lt;code&gt;previous&lt;/code&gt; method returns &lt;code&gt;false&lt;/code&gt;, the cursor is positioned before the first row. Any invocation of a &lt;code&gt;ResultSet&lt;/code&gt; method which requires a current row will result in a &lt;code&gt;SQLException&lt;/code&gt; being thrown.</source>
          <target state="translated">&lt;code&gt;previous&lt;/code&gt; メソッドの呼び出しが &lt;code&gt;false&lt;/code&gt; を返す場合、カーソルは最初の行の前に置かれます。現在の行を必要とする &lt;code&gt;ResultSet&lt;/code&gt; メソッドを呼び出すと、 &lt;code&gt;SQLException&lt;/code&gt; がスローされます。</target>
        </trans-unit>
        <trans-unit id="8a83c0113229dd8663248a6bb840a6358d3593d9" translate="yes" xml:space="preserve">
          <source>When a callback method on the specified &lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt;&lt;code&gt;ContentHandler&lt;/code&gt;&lt;/a&gt; throws an exception, the same exception object must be thrown from the &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt; should not be notified of such an exception.</source>
          <target state="translated">指定された&lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt; &lt;code&gt;ContentHandler&lt;/code&gt; の&lt;/a&gt;コールバックメソッドが例外をスローする場合、同じ例外オブジェクトを&lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; &lt;/a&gt;からスローする必要があります。&lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; のは&lt;/a&gt;、このような例外を通知すべきではありません。</target>
        </trans-unit>
        <trans-unit id="084f36ff7f74614b43cbed478a2f7b49522f6609" translate="yes" xml:space="preserve">
          <source>When a check box menu item is selected, AWT sends an item event to the item. Since the event is an instance of &lt;code&gt;ItemEvent&lt;/code&gt;, the &lt;code&gt;processEvent&lt;/code&gt; method examines the event and passes it along to &lt;code&gt;processItemEvent&lt;/code&gt;. The latter method redirects the event to any &lt;code&gt;ItemListener&lt;/code&gt; objects that have registered an interest in item events generated by this menu item.</source>
          <target state="translated">チェックボックスメニュー項目が選択されると、AWTは項目イベントを項目に送信します。イベントは &lt;code&gt;ItemEvent&lt;/code&gt; のインスタンスであるため、 &lt;code&gt;processEvent&lt;/code&gt; メソッドはイベントを調べて &lt;code&gt;processItemEvent&lt;/code&gt; に渡します。後者のメソッドは、このメニュー項目によって生成された項目イベントへの関心を登録したすべての &lt;code&gt;ItemListener&lt;/code&gt; オブジェクトにイベントをリダイレクトします。</target>
        </trans-unit>
        <trans-unit id="d040f2e41b4f688b6bbac9b4fc04238f264f901c" translate="yes" xml:space="preserve">
          <source>When a client application is designed to remotely access MXBeans for a running virtual machine whose version is different than the version on which the application is running, it should prepare to catch &lt;a href=&quot;../../../../java.base/java/io/invalidobjectexception&quot;&gt;&lt;code&gt;InvalidObjectException&lt;/code&gt;&lt;/a&gt; which is thrown when an MXBean proxy receives a name of an enum constant which is missing in the enum class loaded in the client application. If thrown, &lt;a href=&quot;../../../../java.base/java/io/invalidobjectexception&quot;&gt;&lt;code&gt;InvalidObjectException&lt;/code&gt;&lt;/a&gt; will be wrappped in &lt;a href=&quot;../../../../java.base/java/lang/reflect/undeclaredthrowableexception&quot;&gt;&lt;code&gt;UndeclaredThrowableException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">クライアントアプリケーションが、アプリケーションが実行されているバージョンとは異なるバージョンの実行中の仮想マシンのMXBeanにリモートアクセスするように設計されている場合、MXBeanプロキシが列挙型定数の名前を受け取ったときにスローされる&lt;a href=&quot;../../../../java.base/java/io/invalidobjectexception&quot;&gt; &lt;code&gt;InvalidObjectException&lt;/code&gt; &lt;/a&gt;をキャッチする準備をする必要があります。クライアントアプリケーションにロードされた列挙型クラスにありません。スローされた場合、&lt;a href=&quot;../../../../java.base/java/io/invalidobjectexception&quot;&gt; &lt;code&gt;InvalidObjectException&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;../../../../java.base/java/lang/reflect/undeclaredthrowableexception&quot;&gt; &lt;code&gt;UndeclaredThrowableException&lt;/code&gt; &lt;/a&gt;にラップされます。</target>
        </trans-unit>
        <trans-unit id="902b9d017a9bed0402d7a996f72e41d3f25ab7ec" translate="yes" xml:space="preserve">
          <source>When a client application is designed to remotely access MXBeans for a running virtual machine whose version is different than the version on which the application is running, it should prepare to catch &lt;a href=&quot;../../io/invalidobjectexception&quot;&gt;&lt;code&gt;InvalidObjectException&lt;/code&gt;&lt;/a&gt; which is thrown when an MXBean proxy receives a name of an enum constant which is missing in the enum class loaded in the client application.</source>
          <target state="translated">クライアントアプリケーションが、アプリケーションが実行されているバージョンとは異なるバージョンの実行中の仮想マシンのMXBeanにリモートでアクセスするように設計されている場合、MXBeanプロキシが列挙定数の名前を受け取ったときにスローされる&lt;a href=&quot;../../io/invalidobjectexception&quot;&gt; &lt;code&gt;InvalidObjectException&lt;/code&gt; &lt;/a&gt;をキャッチする準備をする必要があります。クライアントアプリケーションにロードされた列挙型クラスに欠落しています。</target>
        </trans-unit>
        <trans-unit id="7205693021c9fb69b57353ca24035c13ecb1c484" translate="yes" xml:space="preserve">
          <source>When a client connects to a server using the JMX Remote API, it is possible that they do not have the same version of the JMX specification. The version of the JMX specification described here is version 1.4. Previous versions were 1.0, 1.1, and 1.2. (There was no 1.3.) The standard JMX Remote API is defined to work with version 1.2 onwards, so in standards-based deployment the only interoperability questions that arise concern version 1.2 onwards.</source>
          <target state="translated">クライアントがJMX Remote APIを使用してサーバに接続した場合、JMX仕様のバージョンが異なっている可能性があります。ここで説明するJMX仕様のバージョンは、バージョン1.4です。それ以前のバージョンは1.0、1.1、1.2でした。標準の JMX Remote API はバージョン 1.2 以降で動作するように定義されているため、標準ベースのデプロイメントではバージョン 1.2 以降の相互運用性の問題だけが発生します。</target>
        </trans-unit>
        <trans-unit id="9ecf260d1def47441248c5413c0dd40de5045eac" translate="yes" xml:space="preserve">
          <source>When a client needs to print a job using the client's desired resolution exactly (no more, no less), the client specifies an instance of class &lt;code&gt;PrinterResolution&lt;/code&gt; as an attribute of the Print Job. This will fail if the Print Job doesn't support that exact resolution, and &lt;code&gt;Fidelity&lt;/code&gt; is set to true.</source>
          <target state="translated">クライアントがクライアントの希望する解像度を使用してジョブを正確に（それ以上でもそれ以下でも）印刷する必要がある場合、クライアントは印刷ジョブの属性としてクラス &lt;code&gt;PrinterResolution&lt;/code&gt; のインスタンスを指定します。印刷ジョブがその正確な解像度をサポートしておらず、 &lt;code&gt;Fidelity&lt;/code&gt; がtrueに設定されている場合、これは失敗します。</target>
        </trans-unit>
        <trans-unit id="c8a48941832ba5a4328e80c08b8ffedc13963178" translate="yes" xml:space="preserve">
          <source>When a client needs to print a job using the client's desired resolution exactly (no more, no less), the client specifies an instance of class PrinterResolution as an attribute of the Print Job. This will fail if the Print Job doesn't support that exact resolution, and Fidelity is set to true.</source>
          <target state="translated">クライアントが,クライアントの希望する解像度を正確に(それ以上でもそれ以下でもない)使用してジョブを印刷する必要がある場合,クライアントは,印刷ジョブの属性としてクラスPrinterResolutionのインスタンスを指定します。印刷ジョブがその正確な解像度をサポートしておらず,Fidelityがtrueに設定されている場合,これは失敗します。</target>
        </trans-unit>
        <trans-unit id="a335dacd4eaf5c3bce2ba4fb08c4775392c61b2f" translate="yes" xml:space="preserve">
          <source>When a client searches looking for a printer that supports the client's desired resolution exactly (no more, no less), the client specifies an instance of class &lt;code&gt;PrinterResolution&lt;/code&gt; indicating the exact resolution the client wants. Only printers supporting that exact resolution will match the search.</source>
          <target state="translated">クライアントがクライアントの希望する解像度を正確に（それ以上でもそれ以下でも）サポートするプリンターを検索するとき、クライアントは、クライアントが希望する正確な解像度を示すクラス &lt;code&gt;PrinterResolution&lt;/code&gt; のインスタンスを指定します。その正確な解像度をサポートするプリンターのみが検索に一致します。</target>
        </trans-unit>
        <trans-unit id="7de20097d88ff779f4bae860f8ac5bfcc78b886f" translate="yes" xml:space="preserve">
          <source>When a client searches looking for a printer that supports the client's desired resolution exactly (no more, no less), the client specifies an instance of class PrinterResolution indicating the exact resolution the client wants. Only printers supporting that exact resolution will match the search.</source>
          <target state="translated">クライアントが,クライアントの希望する解像度を正確に(それ以上でもそれ以下でもない)サポートするプリンタを検索するとき,クライアントは,クライアントが望む正確な解像度を示すクラスPrinterResolutionのインスタンスを指定します。その正確な解像度をサポートするプリンタのみが,検索にマッチします.</target>
        </trans-unit>
        <trans-unit id="af75d22b50227d1fb5318634310fcd020e5b369c" translate="yes" xml:space="preserve">
          <source>When a coded character set is used exclusively with a single character-encoding scheme then the corresponding charset is usually named for the coded character set; otherwise a charset is usually named for the encoding scheme and, possibly, the locale of the coded character sets that it supports. Hence &lt;code&gt;US-ASCII&lt;/code&gt; is both the name of a coded character set and of the charset that encodes it, while &lt;code&gt;EUC-JP&lt;/code&gt; is the name of the charset that encodes the JIS X 0201, JIS X 0208, and JIS X 0212 coded character sets for the Japanese language.</source>
          <target state="translated">コード化文字セットが単一の文字エンコード方式で排他的に使用される場合、対応する文字セットは通常、コード化文字セットの名前になります。それ以外の場合、文字セットは通常、コード化スキーム、および場合によってはそれがサポートするコード化文字セットのロケールに基づいて命名されます。したがって、 &lt;code&gt;US-ASCII&lt;/code&gt; はコード化文字セットとそれをエンコードする文字セットの名前であり、 &lt;code&gt;EUC-JP&lt;/code&gt; はJIS X 0201、JIS X 0208、およびJIS X 0212のコード化文字セットをエンコードする文字セットの名前です。日本語。</target>
        </trans-unit>
        <trans-unit id="359074a92233f14fabd3c8c60b9f6a18661913d1" translate="yes" xml:space="preserve">
          <source>When a column is adjusted in the UI, adjust the next column the opposite way.</source>
          <target state="translated">UIで列を調整したら、次の列を逆に調整します。</target>
        </trans-unit>
        <trans-unit id="abc368889970e1798a7b82782b317df91eb75a92" translate="yes" xml:space="preserve">
          <source>When a concrete &lt;code&gt;DragGestureRecognizer&lt;/code&gt; instance detects a drag initiating gesture on the &lt;code&gt;Component&lt;/code&gt; it is associated with, it fires a &lt;a href=&quot;draggestureevent&quot;&gt;&lt;code&gt;DragGestureEvent&lt;/code&gt;&lt;/a&gt; to the &lt;code&gt;DragGestureListener&lt;/code&gt; registered on its unicast event source for &lt;code&gt;DragGestureListener&lt;/code&gt; events. This &lt;code&gt;DragGestureListener&lt;/code&gt; is responsible for causing the associated &lt;code&gt;DragSource&lt;/code&gt; to start the Drag and Drop operation (if appropriate).</source>
          <target state="translated">コンクリートとき &lt;code&gt;DragGestureRecognizer&lt;/code&gt; インスタンスがジェスチャを開始するドラッグ検出 &lt;code&gt;Component&lt;/code&gt; 、それが関連付けられているが、それが発火&lt;a href=&quot;draggestureevent&quot;&gt; &lt;code&gt;DragGestureEvent&lt;/code&gt; &lt;/a&gt;に &lt;code&gt;DragGestureListener&lt;/code&gt; のためにユニキャストイベントソースに登録 &lt;code&gt;DragGestureListener&lt;/code&gt; イベントを。この &lt;code&gt;DragGestureListener&lt;/code&gt; は、関連する &lt;code&gt;DragSource&lt;/code&gt; にドラッグアンドドロップ操作を開始させる役割を果たします（適切な場合）。</target>
        </trans-unit>
        <trans-unit id="53280a61faf78dcb3ec848c2e2ddbf8b1f48355d" translate="yes" xml:space="preserve">
          <source>When a constructor or getter method that takes a &lt;code&gt;Map&lt;/code&gt; object is called, the JDBC driver calls the method &lt;code&gt;SQLData.getSQLType&lt;/code&gt; to determine the SQL type of the UDT being custom mapped. The driver creates an instance of &lt;code&gt;SQLInputImpl&lt;/code&gt;, populating it with the attributes of the UDT. The driver then passes the input stream to the method &lt;code&gt;SQLData.readSQL&lt;/code&gt;, which in turn calls the &lt;code&gt;SQLInputImpl&lt;/code&gt; methods to read the attributes from the input stream.</source>
          <target state="translated">&lt;code&gt;Map&lt;/code&gt; オブジェクトを &lt;code&gt;SQLData.getSQLType&lt;/code&gt; コンストラクターまたはgetterメソッドが呼び出されると、JDBCドライバーはメソッドSQLData.getSQLTypeを呼び出して、カスタムマップされるUDTのSQLタイプを判別します。ドライバーは &lt;code&gt;SQLInputImpl&lt;/code&gt; のインスタンスを作成し、UDTの属性を入力します。次に、ドライバーは入力ストリームをメソッド &lt;code&gt;SQLData.readSQL&lt;/code&gt; に渡します。このメソッドは、 &lt;code&gt;SQLInputImpl&lt;/code&gt; メソッドを呼び出して、入力ストリームから属性を読み取ります。</target>
        </trans-unit>
        <trans-unit id="5046ecec5b32705f3cc717979a666d129f7eb365" translate="yes" xml:space="preserve">
          <source>When a context method that may return response controls is invoked, response controls from the previous method invocation are cleared. &lt;code&gt;getResponseControls()&lt;/code&gt; returns all of the response controls generated by LDAP operations used by the context method in the order received from the LDAP server. Invoking &lt;code&gt;getResponseControls()&lt;/code&gt; does not clear the response controls. You can call it many times (and get back the same controls) until the next context method that may return controls is invoked.</source>
          <target state="translated">応答コントロールを返す可能性のあるコンテキストメソッドが呼び出されると、前のメソッド呼び出しからの応答コントロールがクリアされます。 &lt;code&gt;getResponseControls()&lt;/code&gt; は、LDAPサーバーから受信した順序で、コンテキストメソッドによって使用されるLDAP操作によって生成されたすべての応答コントロールを返します。 &lt;code&gt;getResponseControls()&lt;/code&gt; を呼び出しても、応答コントロールはクリアされません。コントロールを返す可能性のある次のコンテキストメソッドが呼び出されるまで、何度も呼び出すことができます（同じコントロールを取得できます）。</target>
        </trans-unit>
        <trans-unit id="5d82dfd1d5fb556b3eaa04ee5dbf7ee49fcca1a9" translate="yes" xml:space="preserve">
          <source>When a directory is registered for this event then the &lt;a href=&quot;watchkey&quot;&gt;&lt;code&gt;WatchKey&lt;/code&gt;&lt;/a&gt; is queued when it is observed that an entry in the directory has been modified. The event &lt;a href=&quot;watchevent#count()&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; for this event is &lt;code&gt;1&lt;/code&gt; or greater.</source>
          <target state="translated">ディレクトリがこのイベントに登録されると、ディレクトリ内のエントリが変更されたことが確認されると、&lt;a href=&quot;watchkey&quot;&gt; &lt;code&gt;WatchKey&lt;/code&gt; &lt;/a&gt;がキューに入れられます。このイベントのイベント&lt;a href=&quot;watchevent#count()&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;1&lt;/code&gt; 以上です。</target>
        </trans-unit>
        <trans-unit id="451ee1cb627eed78bb98b62c3c2b734285d519cd" translate="yes" xml:space="preserve">
          <source>When a directory is registered for this event then the &lt;a href=&quot;watchkey&quot;&gt;&lt;code&gt;WatchKey&lt;/code&gt;&lt;/a&gt; is queued when it is observed that an entry in the directory has been modified. The event &lt;a href=&quot;watchevent#count--&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; for this event is &lt;code&gt;1&lt;/code&gt; or greater.</source>
          <target state="translated">このイベントにディレクトリが登録されると、ディレクトリのエントリが変更されたことが確認されると、&lt;a href=&quot;watchkey&quot;&gt; &lt;code&gt;WatchKey&lt;/code&gt; &lt;/a&gt;がキューに入れられます。このイベントのイベント&lt;a href=&quot;watchevent#count--&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;1&lt;/code&gt; 以上です。</target>
        </trans-unit>
        <trans-unit id="54c77a330dd41951e46e4b4a1e88cbe19100d080" translate="yes" xml:space="preserve">
          <source>When a directory is registered for this event then the &lt;a href=&quot;watchkey&quot;&gt;&lt;code&gt;WatchKey&lt;/code&gt;&lt;/a&gt; is queued when it is observed that an entry is created in the directory or renamed into the directory. The event &lt;a href=&quot;watchevent#count()&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; for this event is always &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">このイベントにディレクトリが登録されると、ディレクトリにエントリが作成されたか、ディレクトリの名前が変更されたことが確認されると、&lt;a href=&quot;watchkey&quot;&gt; &lt;code&gt;WatchKey&lt;/code&gt; &lt;/a&gt;がキューに入れられます。このイベントのイベント&lt;a href=&quot;watchevent#count()&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt;は常に &lt;code&gt;1&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="acde6e0c9e549621383ae5222820b57635b1abdb" translate="yes" xml:space="preserve">
          <source>When a directory is registered for this event then the &lt;a href=&quot;watchkey&quot;&gt;&lt;code&gt;WatchKey&lt;/code&gt;&lt;/a&gt; is queued when it is observed that an entry is created in the directory or renamed into the directory. The event &lt;a href=&quot;watchevent#count--&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; for this event is always &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">このイベントに対してディレクトリが登録されると、ディレクトリ内にエントリが作成されるか、ディレクトリに名前が変更されることが確認されると、&lt;a href=&quot;watchkey&quot;&gt; &lt;code&gt;WatchKey&lt;/code&gt; &lt;/a&gt;がキューに入れられます。このイベントのイベント&lt;a href=&quot;watchevent#count--&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt;は常に &lt;code&gt;1&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a027f021c399f6f07c85633b797d323c94d4cfee" translate="yes" xml:space="preserve">
          <source>When a directory is registered for this event then the &lt;a href=&quot;watchkey&quot;&gt;&lt;code&gt;WatchKey&lt;/code&gt;&lt;/a&gt; is queued when it is observed that an entry is deleted or renamed out of the directory. The event &lt;a href=&quot;watchevent#count()&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; for this event is always &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">このイベントにディレクトリが登録されると、ディレクトリからエントリが削除または名前変更されたことが確認されると、&lt;a href=&quot;watchkey&quot;&gt; &lt;code&gt;WatchKey&lt;/code&gt; &lt;/a&gt;がキューに入れられます。このイベントのイベント&lt;a href=&quot;watchevent#count()&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt;は常に &lt;code&gt;1&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="4aa389d8c3635d68f9942230af80f43edbcdf866" translate="yes" xml:space="preserve">
          <source>When a directory is registered for this event then the &lt;a href=&quot;watchkey&quot;&gt;&lt;code&gt;WatchKey&lt;/code&gt;&lt;/a&gt; is queued when it is observed that an entry is deleted or renamed out of the directory. The event &lt;a href=&quot;watchevent#count--&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; for this event is always &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">このイベントにディレクトリが登録されると、ディレクトリからエントリが削除されたり名前が変更されたりしたことが確認されると、&lt;a href=&quot;watchkey&quot;&gt; &lt;code&gt;WatchKey&lt;/code&gt; &lt;/a&gt;がキューに入れられます。このイベントのイベント&lt;a href=&quot;watchevent#count--&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt;は常に &lt;code&gt;1&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="134eb2244461f191f7d57bf1761d699a4a619aa5" translate="yes" xml:space="preserve">
          <source>When a document is first made available via the DOM, there is only one &lt;code&gt;Text&lt;/code&gt; node for each block of text. Users may create adjacent &lt;code&gt;Text&lt;/code&gt; nodes that represent the contents of a given element without any intervening markup, but should be aware that there is no way to represent the separations between these nodes in XML or HTML, so they will not (in general) persist between DOM editing sessions. The &lt;code&gt;Node.normalize()&lt;/code&gt; method merges any such adjacent &lt;code&gt;Text&lt;/code&gt; objects into a single node for each block of text.</source>
          <target state="translated">ドキュメントが最初にDOMを介して利用可能になったとき、テキストのブロックごとに1つの &lt;code&gt;Text&lt;/code&gt; ノードしかありません。ユーザーは、マークアップを介さずに特定の要素のコンテンツを表す隣接する &lt;code&gt;Text&lt;/code&gt; ノードを作成できますが、XMLまたはHTMLでこれらのノード間の分離を表す方法がないため、（一般に）それらの間で永続化されないことに注意してください。 DOM編集セッション。 &lt;code&gt;Node.normalize()&lt;/code&gt; メソッドは、そのような隣接マージ &lt;code&gt;Text&lt;/code&gt; テキストの各ブロックのための単一のノードにオブジェクトを。</target>
        </trans-unit>
        <trans-unit id="b4da85dd003901db71000007023e7612e6748206" translate="yes" xml:space="preserve">
          <source>When a drag gesture occurs, the &lt;code&gt;DragSource&lt;/code&gt;'s startDrag() method shall be invoked in order to cause processing of the user's navigational gestures and delivery of Drag and Drop protocol notifications. A &lt;code&gt;DragSource&lt;/code&gt; shall only permit a single Drag and Drop operation to be current at any one time, and shall reject any further startDrag() requests by throwing an &lt;code&gt;IllegalDnDOperationException&lt;/code&gt; until such time as the extant operation is complete.</source>
          <target state="translated">ドラッグジェスチャが発生すると、 &lt;code&gt;DragSource&lt;/code&gt; のstartDrag（）メソッドが呼び出されて、ユーザーのナビゲーションジェスチャが処理され、ドラッグアンドドロッププロトコル通知が配信されます。A &lt;code&gt;DragSource&lt;/code&gt; 任意の一時点での電流であるために、単一のドラッグアンドドロップ操作を許可しなければならない、と投げてさらなるのstartDrag（）要求を拒否しなければならない &lt;code&gt;IllegalDnDOperationException&lt;/code&gt; を現存操作が完了するような時間まで。</target>
        </trans-unit>
        <trans-unit id="c6e54cb2e2ced5f516b5c3c711efdeb13fed62ee" translate="yes" xml:space="preserve">
          <source>When a file system is constructed to access the contents of a file as a file system then it is highly implementation specific if the returned URI represents the given path in the file system or it represents a &lt;em&gt;compound&lt;/em&gt; URI that encodes the URI of the enclosing file system. A format for compound URIs is not defined in this release; such a scheme may be added in a future release.</source>
          <target state="translated">ファイルシステムがファイルシステムとしてファイルのコンテンツにアクセスするように構築されている場合、返されたURIがファイルシステム内の指定されたパスを表すか、それを含むファイルシステムのURIをエンコードする&lt;em&gt;複合&lt;/em&gt; URIを表すかは、実装固有です。。このリリースでは、複合URIの形式は定義されていません。このようなスキームは、将来のリリースで追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="920d75d308d8cfd3c9e9c09baeeb65ab14384dc3" translate="yes" xml:space="preserve">
          <source>When a file system provides access to a set of &lt;a href=&quot;../filestore&quot;&gt;&lt;code&gt;file-systems&lt;/code&gt;&lt;/a&gt; that are not homogeneous then only some of the file systems may support ACLs. The &lt;a href=&quot;../filestore#supportsFileAttributeView(java.lang.Class)&quot;&gt;&lt;code&gt;supportsFileAttributeView&lt;/code&gt;&lt;/a&gt; method can be used to test if a file system supports ACLs.</source>
          <target state="translated">ファイルシステムが同種ではない&lt;a href=&quot;../filestore&quot;&gt; &lt;code&gt;file-systems&lt;/code&gt; &lt;/a&gt;セットへのアクセスを提供する場合、一部のファイルシステムのみがACLをサポートする可能性があります。&lt;a href=&quot;../filestore#supportsFileAttributeView(java.lang.Class)&quot;&gt; &lt;code&gt;supportsFileAttributeView&lt;/code&gt; の&lt;/a&gt;ファイルシステムがACLをサポートしている場合方法は、試験に使用することができます。</target>
        </trans-unit>
        <trans-unit id="5f8424e3622daa52db1d5d000f4c2d226449bfeb" translate="yes" xml:space="preserve">
          <source>When a file system provides access to a set of &lt;a href=&quot;../filestore&quot;&gt;&lt;code&gt;file-systems&lt;/code&gt;&lt;/a&gt; that are not homogeneous then only some of the file systems may support ACLs. The &lt;a href=&quot;../filestore#supportsFileAttributeView-java.lang.Class-&quot;&gt;&lt;code&gt;supportsFileAttributeView&lt;/code&gt;&lt;/a&gt; method can be used to test if a file system supports ACLs.</source>
          <target state="translated">ファイルシステムが同種ではない一連の&lt;a href=&quot;../filestore&quot;&gt; &lt;code&gt;file-systems&lt;/code&gt; &lt;/a&gt;へのアクセスを提供する場合、一部のファイルシステムのみがACLをサポートできます。&lt;a href=&quot;../filestore#supportsFileAttributeView-java.lang.Class-&quot;&gt; &lt;code&gt;supportsFileAttributeView&lt;/code&gt; の&lt;/a&gt;ファイルシステムがACLをサポートしている場合方法は、試験に使用することができます。</target>
        </trans-unit>
        <trans-unit id="2513b009af422c9e2dc954b7cd7076a8523df7e6" translate="yes" xml:space="preserve">
          <source>When a filter is provided, the implementation will call out to the filter as it is constructing the DOM tree structure.</source>
          <target state="translated">フィルタが提供されると、実装は DOM ツリー構造を構築する際にフィルタを呼び出します。</target>
        </trans-unit>
        <trans-unit id="b140beb62778d75da1fe8212e3da055f629c25ea" translate="yes" xml:space="preserve">
          <source>When a filter is provided, the implementation will call out to the filter as it is constructing the DOM tree structure. The filter can choose to remove elements from the document being constructed, or to terminate the parsing early.</source>
          <target state="translated">フィルタが提供されると、実装は DOM ツリー構造を構築しているときにフィルタを呼び出します。フィルタは、構築中のドキュメントから要素を削除するか、 解析を早期に終了するかを選択することができます。</target>
        </trans-unit>
        <trans-unit id="563c181caf51bc9ca81a53828adbe47768c2b0e3" translate="yes" xml:space="preserve">
          <source>When a flush occurs on a newly created node, it is made persistent, as are any ancestors (and descendants) that have yet to be made persistent. Note however that any preference value changes in ancestors are</source>
          <target state="translated">新しく作成されたノードでフラッシュが発生すると、そのノードは永続化され、まだ永続化されていない祖先(および子孫)も永続化されます。ただし、先祖のプリファレンス値の変更はすべて</target>
        </trans-unit>
        <trans-unit id="1d4a0847838b4b0259eb6a3663209d9fef15018e" translate="yes" xml:space="preserve">
          <source>When a frame is in maximized state the system supplies some defaults bounds. This method allows some or all of those system supplied values to be overridden.</source>
          <target state="translated">フレームが最大化状態にあるとき、システムはいくつかのデフォルト境界を提供します。このメソッドでは、システムから供給された値の一部またはすべてを上書きすることができます。</target>
        </trans-unit>
        <trans-unit id="14b01570d43320be8d365211a70fea5fddceea53" translate="yes" xml:space="preserve">
          <source>When a guarded delegator is created from a guarded pair, the pair is wrapped in a new method handle &lt;code&gt;M&lt;/code&gt;, which is permanently associated with the switch point that created it. Each pair consists of a target &lt;code&gt;T&lt;/code&gt; and a fallback &lt;code&gt;F&lt;/code&gt;. While the switch point is valid, invocations to &lt;code&gt;M&lt;/code&gt; are delegated to &lt;code&gt;T&lt;/code&gt;. After it is invalidated, invocations are delegated to &lt;code&gt;F&lt;/code&gt;.</source>
          <target state="translated">保護されたデリゲーターが保護されたペアから作成されると、ペアは、それを作成したスイッチポイントに永続的に関連付けられた新しいメソッドハンドル &lt;code&gt;M&lt;/code&gt; でラップされます。各ペアは、ターゲット &lt;code&gt;T&lt;/code&gt; とフォールバック &lt;code&gt;F&lt;/code&gt; で構成されます。スイッチポイントは有効ですが、 &lt;code&gt;M&lt;/code&gt; への呼び出しは &lt;code&gt;T&lt;/code&gt; に委任されます。無効化された後、呼び出しは &lt;code&gt;F&lt;/code&gt; に委任されます。</target>
        </trans-unit>
        <trans-unit id="4e4ff9b2bc60835e3eb9b787ed7b76295168a994" translate="yes" xml:space="preserve">
          <source>When a listener instance invokes &lt;code&gt;NamingEvent.getEventContext()&lt;/code&gt;, it must take into account the possibility that other threads will be working with that context concurrently. Likewise, when a listener is registered via &lt;code&gt;addNamingListener()&lt;/code&gt;, the registering thread must take into account the likely possibility that the service provider will later invoke the listeners in newly-created threads. As &lt;code&gt;Context&lt;/code&gt; instances are not guaranteed to be thread-safe in general, all context operations must be synchronized as needed.</source>
          <target state="translated">リスナーインスタンスが &lt;code&gt;NamingEvent.getEventContext()&lt;/code&gt; を呼び出すとき、他のスレッドがそのコンテキストで同時に動作する可能性を考慮に入れる必要があります。同様に、リスナーが &lt;code&gt;addNamingListener()&lt;/code&gt; を介して登録される場合、登録スレッドは、サービスプロバイダーが後で新しく作成されたスレッドでリスナーを呼び出す可能性を考慮する必要があります。 &lt;code&gt;Context&lt;/code&gt; インスタンスは、一般的にはスレッドセーフであることが保証されていない、必要に応じて、すべてのコンテキスト操作を同期させる必要があります。</target>
        </trans-unit>
        <trans-unit id="bf04634d7ff1db386d9b9db0fb748a111b1c6a04" translate="yes" xml:space="preserve">
          <source>When a listener registers for events with a context, the context might need to do some internal processing in order to collect information required to generate the events. The context, for example, might need to make a request to the server to register interest in changes on the server that will eventually be translated into events. If an exception occurs that prevents information about the events from being collected, the listener will never be notified of the events. When such an exception occurs, a &lt;code&gt;NamingExceptionEvent&lt;/code&gt; is fired to notify the listener. The listener's &lt;code&gt;namingExceptionThrown()&lt;/code&gt; method is invoked, as shown in the sample code above, and the listener is automatically deregistered.</source>
          <target state="translated">リスナーがコンテキストを使用してイベントを登録するとき、イベントの生成に必要な情報を収集するために、コンテキストが内部処理を行う必要がある場合があります。たとえば、コンテキストは、最終的にイベントに変換されるサーバー上の変更への関心を登録するために、サーバーに要求を行う必要がある場合があります。イベントに関する情報の収集を妨げる例外が発生した場合、リスナーにはイベントが通知されません。このような例外が発生すると、 &lt;code&gt;NamingExceptionEvent&lt;/code&gt; が発生してリスナーに通知します。上記のサンプルコードに示すように、リスナーの &lt;code&gt;namingExceptionThrown()&lt;/code&gt; メソッドが呼び出され、リスナーは自動的に登録解除されます。</target>
        </trans-unit>
        <trans-unit id="88240763f016e704f50f91eea618ff29da324203" translate="yes" xml:space="preserve">
          <source>When a menu item is selected, AWT sends an action event to the menu item. Since the event is an instance of &lt;code&gt;ActionEvent&lt;/code&gt;, the &lt;code&gt;processEvent&lt;/code&gt; method examines the event and passes it along to &lt;code&gt;processActionEvent&lt;/code&gt;. The latter method redirects the event to any &lt;code&gt;ActionListener&lt;/code&gt; objects that have registered an interest in action events generated by this menu item.</source>
          <target state="translated">メニュー項目が選択されると、AWTはアクションイベントをメニュー項目に送信します。イベントは &lt;code&gt;ActionEvent&lt;/code&gt; のインスタンスであるため、 &lt;code&gt;processEvent&lt;/code&gt; メソッドはイベントを調べて、 &lt;code&gt;processActionEvent&lt;/code&gt; に渡します。後者のメソッドは、このメニュー項目によって生成されたアクションイベントへの関心を登録した &lt;code&gt;ActionListener&lt;/code&gt; オブジェクトにイベントをリダイレクトします。</target>
        </trans-unit>
        <trans-unit id="90dd254c09d1c776ecf5c2349e720c462b943059" translate="yes" xml:space="preserve">
          <source>When a method handle is obtained by executing an &lt;code&gt;ldc&lt;/code&gt; instruction of a &lt;code&gt;CONSTANT_MethodHandle&lt;/code&gt; constant, and the target method is marked as a variable arity method (with the modifier bit &lt;code&gt;0x0080&lt;/code&gt;), the method handle will accept multiple arities, as if the method handle constant were created by means of a call to &lt;code&gt;asVarargsCollector&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CONSTANT_MethodHandle&lt;/code&gt; 定数の &lt;code&gt;ldc&lt;/code&gt; 命令を実行してメソッドハンドルを取得し、ターゲットメソッドが可変アリティメソッドとしてマークされている場合（修飾子ビット &lt;code&gt;0x0080&lt;/code&gt; を使用）、メソッドハンドルは複数のアリティを受け入れます。 &lt;code&gt;asVarargsCollector&lt;/code&gt; の呼び出しによって作成されます。</target>
        </trans-unit>
        <trans-unit id="dc59d96f42634aad08455afa57812c0140efcb78" translate="yes" xml:space="preserve">
          <source>When a method handle to a virtual method is invoked, the method is always looked up in the receiver (that is, the first argument).</source>
          <target state="translated">仮想メソッドへのメソッドハンドルが呼び出されると、そのメソッドは常にレシーバーで検索されます (つまり第一引数)。</target>
        </trans-unit>
        <trans-unit id="ac3ed4c5aa8581e47e6e1d20592079740b067ad7" translate="yes" xml:space="preserve">
          <source>When a method such as list(), listBindings(), or search() returns a NamingEnumeration, any exceptions encountered are reserved until all results have been returned. At the end of the enumeration, the exception is thrown (by hasMore());</source>
          <target state="translated">list()、listBindings()、search()などのメソッドが NamingEnumeration を返すときに発生した例外は、すべての結果が返されるまで予約されます。列挙の最後に例外がスローされます (hasMore()によって)。</target>
        </trans-unit>
        <trans-unit id="c77f58a997936db72fbff2f59c022214ac8f5bcc" translate="yes" xml:space="preserve">
          <source>When a module declares that the provider class is created by a provider factory then this method returns the return type of its public static &quot;&lt;code&gt;provider()&lt;/code&gt;&quot; method.</source>
          <target state="translated">モジュールがプロバイダークラスがプロバイダーファクトリによって作成されたことを宣言すると、このメソッドはそのパブリック静的「 &lt;code&gt;provider()&lt;/code&gt; 」メソッドの戻り値の型を返します。</target>
        </trans-unit>
        <trans-unit id="98cbaeab94a8ea21799291ebebb2b9e8ca8b5128" translate="yes" xml:space="preserve">
          <source>When a module is deprecated, the use of that module in &lt;code&gt;
 requires&lt;/code&gt;, but not in &lt;code&gt;exports&lt;/code&gt; or &lt;code&gt;opens&lt;/code&gt; clauses causes a warning to be issued. A module being deprecated does &lt;em&gt;not&lt;/em&gt; cause warnings to be issued for uses of types within the module.</source>
          <target state="translated">モジュールが非推奨になった場合、そのモジュールを &lt;code&gt; requires&lt;/code&gt; で使用しますが、 &lt;code&gt;exports&lt;/code&gt; または &lt;code&gt;opens&lt;/code&gt; 句では使用しないと、警告が発行されます。非推奨のモジュールでは、モジュール内でタイプを使用しても警告は発行されませ&lt;em&gt;ん&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="d555a5a6abfd38f83f82a291e707b2b58a5605e9" translate="yes" xml:space="preserve">
          <source>When a mouse button is clicked, events are generated and sent to the registered &lt;code&gt;MouseListener&lt;/code&gt;s. The state of modal keys can be retrieved using &lt;a href=&quot;inputevent#getModifiers()&quot;&gt;&lt;code&gt;InputEvent.getModifiers()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;inputevent#getModifiersEx()&quot;&gt;&lt;code&gt;InputEvent.getModifiersEx()&lt;/code&gt;&lt;/a&gt;. The button mask returned by &lt;a href=&quot;inputevent#getModifiers()&quot;&gt;&lt;code&gt;InputEvent.getModifiers()&lt;/code&gt;&lt;/a&gt; reflects only the button that changed state, not the current state of all buttons. (Note: Due to overlap in the values of ALT_MASK/BUTTON2_MASK and META_MASK/BUTTON3_MASK, this is not always true for mouse events involving modifier keys). To get the state of all buttons and modifier keys, use &lt;a href=&quot;inputevent#getModifiersEx()&quot;&gt;&lt;code&gt;InputEvent.getModifiersEx()&lt;/code&gt;&lt;/a&gt;. The button which has changed state is returned by &lt;a href=&quot;#getButton()&quot;&gt;&lt;code&gt;getButton()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">マウスボタンがクリックされると、イベントが生成され、登録された &lt;code&gt;MouseListener&lt;/code&gt; に送信されます。モーダルキーの状態は、&lt;a href=&quot;inputevent#getModifiers()&quot;&gt; &lt;code&gt;InputEvent.getModifiers()&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;inputevent#getModifiersEx()&quot;&gt; &lt;code&gt;InputEvent.getModifiersEx()&lt;/code&gt; &lt;/a&gt;を使用して取得できます。&lt;a href=&quot;inputevent#getModifiers()&quot;&gt; &lt;code&gt;InputEvent.getModifiers()&lt;/code&gt; &lt;/a&gt;によって返されるボタンマスクは、すべてのボタンの現在の状態ではなく、状態を変更したボタンのみを反映します。 （注：ALT_MASK / BUTTON2_MASKとMETA_MASK / BUTTON3_MASKの値が重複しているため、これは修飾キーを含むマウスイベントに常に当てはまるとは限りません）。すべてのボタンと修飾キーの状態を取得するには、&lt;a href=&quot;inputevent#getModifiersEx()&quot;&gt; &lt;code&gt;InputEvent.getModifiersEx()&lt;/code&gt; を&lt;/a&gt;使用します。状態が変わったボタンは&lt;a href=&quot;#getButton()&quot;&gt; &lt;code&gt;getButton()&lt;/code&gt; で&lt;/a&gt;返されます</target>
        </trans-unit>
        <trans-unit id="00112656e542a277ccbb970384f5707477b0e0b9" translate="yes" xml:space="preserve">
          <source>When a new &lt;a href=&quot;schemafactory&quot;&gt;&lt;code&gt;SchemaFactory&lt;/code&gt;&lt;/a&gt; object is created, initially this field is set to null. This field will &lt;em&gt;NOT&lt;/em&gt; be inherited to &lt;a href=&quot;schema&quot;&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/a&gt;s, &lt;a href=&quot;validator&quot;&gt;&lt;code&gt;Validator&lt;/code&gt;&lt;/a&gt;s, or &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt;s that are created from this &lt;a href=&quot;schemafactory&quot;&gt;&lt;code&gt;SchemaFactory&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">新しい&lt;a href=&quot;schemafactory&quot;&gt; &lt;code&gt;SchemaFactory&lt;/code&gt; &lt;/a&gt;オブジェクトが作成されると、最初はこのフィールドはnullに設定されます。このフィールドは、この&lt;a href=&quot;schemafactory&quot;&gt; &lt;code&gt;SchemaFactory&lt;/code&gt; &lt;/a&gt;から作成された&lt;a href=&quot;schema&quot;&gt; &lt;code&gt;Schema&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;validator&quot;&gt; &lt;code&gt;Validator&lt;/code&gt; &lt;/a&gt;、または&lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; には&lt;/a&gt;継承され&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="3e086a8e7068102271cf7d6fcc1d6a613e3a6593" translate="yes" xml:space="preserve">
          <source>When a new &lt;a href=&quot;validator&quot;&gt;&lt;code&gt;Validator&lt;/code&gt;&lt;/a&gt; object is created, initially this field is set to null.</source>
          <target state="translated">新しい&lt;a href=&quot;validator&quot;&gt; &lt;code&gt;Validator&lt;/code&gt; &lt;/a&gt;オブジェクトが作成されると、最初はこのフィールドはnullに設定されます。</target>
        </trans-unit>
        <trans-unit id="55a52e9d9430d2238010dc383d8d5a916e167cd6" translate="yes" xml:space="preserve">
          <source>When a new &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt; object is created, initially this field is set to null.</source>
          <target state="translated">新しい&lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; &lt;/a&gt;オブジェクトが作成されると、最初はこのフィールドはnullに設定されます。</target>
        </trans-unit>
        <trans-unit id="a16476348451a202ec7241c549e271abf68b5efa" translate="yes" xml:space="preserve">
          <source>When a new connection is accepted then the resulting &lt;code&gt;
 AsynchronousSocketChannel&lt;/code&gt; will be bound to the same &lt;a href=&quot;asynchronouschannelgroup&quot;&gt;&lt;code&gt;AsynchronousChannelGroup&lt;/code&gt;&lt;/a&gt; as this channel. If the group is &lt;a href=&quot;asynchronouschannelgroup#isShutdown()&quot;&gt;&lt;code&gt;shutdown&lt;/code&gt;&lt;/a&gt; and a connection is accepted, then the connection is closed, and the operation completes with an &lt;code&gt;
 IOException&lt;/code&gt; and cause &lt;a href=&quot;shutdownchannelgroupexception&quot;&gt;&lt;code&gt;ShutdownChannelGroupException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">新しい接続が受け入れられると、結果の &lt;code&gt; AsynchronousSocketChannel&lt;/code&gt; は、このチャネルと同じ&lt;a href=&quot;asynchronouschannelgroup&quot;&gt; &lt;code&gt;AsynchronousChannelGroup&lt;/code&gt; に&lt;/a&gt;バインドされます。グループが&lt;a href=&quot;asynchronouschannelgroup#isShutdown()&quot;&gt; &lt;code&gt;shutdown&lt;/code&gt; &lt;/a&gt;れ、接続が受け入れられると、接続が閉じられ、操作は &lt;code&gt; IOException&lt;/code&gt; で完了し、&lt;a href=&quot;shutdownchannelgroupexception&quot;&gt; &lt;code&gt;ShutdownChannelGroupException&lt;/code&gt; が&lt;/a&gt;発生します。</target>
        </trans-unit>
        <trans-unit id="eaa5aba63dd9f02bc423da3760cc790334dde37c" translate="yes" xml:space="preserve">
          <source>When a new connection is accepted then the resulting &lt;code&gt;AsynchronousSocketChannel&lt;/code&gt; will be bound to the same &lt;a href=&quot;asynchronouschannelgroup&quot;&gt;&lt;code&gt;AsynchronousChannelGroup&lt;/code&gt;&lt;/a&gt; as this channel. If the group is &lt;a href=&quot;asynchronouschannelgroup#isShutdown--&quot;&gt;&lt;code&gt;shutdown&lt;/code&gt;&lt;/a&gt; and a connection is accepted, then the connection is closed, and the operation completes with an &lt;code&gt;IOException&lt;/code&gt; and cause &lt;a href=&quot;shutdownchannelgroupexception&quot;&gt;&lt;code&gt;ShutdownChannelGroupException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">新しい接続が受け入れられると、結果の &lt;code&gt;AsynchronousSocketChannel&lt;/code&gt; はこのチャネルと同じ&lt;a href=&quot;asynchronouschannelgroup&quot;&gt; &lt;code&gt;AsynchronousChannelGroup&lt;/code&gt; に&lt;/a&gt;バインドされます。グループが&lt;a href=&quot;asynchronouschannelgroup#isShutdown--&quot;&gt; &lt;code&gt;shutdown&lt;/code&gt; &lt;/a&gt;れ、接続が受け入れられると、接続は閉じられ、操作は &lt;code&gt;IOException&lt;/code&gt; で完了し、&lt;a href=&quot;shutdownchannelgroupexception&quot;&gt; &lt;code&gt;ShutdownChannelGroupException&lt;/code&gt; が&lt;/a&gt;発生します。</target>
        </trans-unit>
        <trans-unit id="b6d8a70cca16fc1a092f3e5b3fb7136e528d4e86" translate="yes" xml:space="preserve">
          <source>When a numeric shaper is defined, the text is first processed by the shaper before any other analysis of the text is performed.</source>
          <target state="translated">数値シェーパが定義されている場合、テキストの他の解析が実行される前に、まずテキストがシェーパによって処理されます。</target>
        </trans-unit>
        <trans-unit id="f20b7bb9a7a0ed971069cd4bd43c35163e0303e3" translate="yes" xml:space="preserve">
          <source>When a printer controls more than one output device, this reason indicates that one or more output devices are stopped.</source>
          <target state="translated">プリンタが複数の出力装置を制御している場合、この理由は、1つ以上の出力装置が停止していることを示している。</target>
        </trans-unit>
        <trans-unit id="57b0000a9696b1c366c87328582e275d001b7acb" translate="yes" xml:space="preserve">
          <source>When a printer controls more than one output device, this reason indicates that one or more output devices are stopped. If the reason's severity is a report, fewer than half of the output devices are stopped. If the reason's severity is a warning, half or more but fewer than all of the output devices are stopped.</source>
          <target state="translated">プリンタが複数の出力装置を制御している場合、この理由は1つ以上の出力装置が停止していることを示している。理由の重大性が報告である場合、出力デバイスの半分以下が停止している。理由の深刻度が警告の場合、半分以上の出力デバイスが停止しているが、すべての出力デバイスよりは少ない。</target>
        </trans-unit>
        <trans-unit id="ccb21bbf1cfa3412cab733738537427c4a4c474e" translate="yes" xml:space="preserve">
          <source>When a proxy selector is registered, for instance, a subclass of URLConnection class should call the &lt;a href=&quot;#select(java.net.URI)&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; method for each URL request so that the proxy selector can decide if a direct, or proxied connection should be used. The &lt;a href=&quot;#select(java.net.URI)&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; method returns an iterator over a collection with the preferred connection approach.</source>
          <target state="translated">たとえば、プロキシセレクタが登録されている場合、URLConnectionクラスのサブクラスは、URL要求ごとに&lt;a href=&quot;#select(java.net.URI)&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt;メソッドを呼び出して、プロキシセレクタが直接接続とプロキシ接続のどちらを使用するかを決定できるようにする必要があります。&lt;a href=&quot;#select(java.net.URI)&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt;方法は、好適な接続手法を用いてコレクションの反復子を返します。</target>
        </trans-unit>
        <trans-unit id="48145dbd368db04ca5f1dc84946f81ac044581d7" translate="yes" xml:space="preserve">
          <source>When a proxy selector is registered, for instance, a subclass of URLConnection class should call the &lt;a href=&quot;proxyselector#select-java.net.URI-&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; method for each URL request so that the proxy selector can decide if a direct, or proxied connection should be used. The &lt;a href=&quot;proxyselector#select-java.net.URI-&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; method returns an iterator over a collection with the preferred connection approach.</source>
          <target state="translated">たとえば、プロキシセレクターが登録されている場合、URLConnectionクラスのサブクラスは、URLリクエストごとに&lt;a href=&quot;proxyselector#select-java.net.URI-&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt;メソッドを呼び出して、プロキシーセレクターが直接接続とプロキシ接続のどちらを使用するかを決定できるようにする必要があります。&lt;a href=&quot;proxyselector#select-java.net.URI-&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt;方法は、好適な接続手法を用いてコレクションの反復子を返します。</target>
        </trans-unit>
        <trans-unit id="d0d0a0a75e5df0269d9b48018fdf0251b8588033" translate="yes" xml:space="preserve">
          <source>When a rendering or image manipulation operation produces a color value that must be stored into a destination, it must first convert that color into a form suitable for storing into the destination image or surface. Minimally, the color components must be converted to bit representations and ordered in the correct order or an index into a color lookup table must be chosen before the data can be stored into the destination memory. Without this minimal conversion, the data in the destination would likely represent random, incorrect or possibly even unsupported values. Algorithms to quickly convert the results of rendering operations into the color format of most common destinations are well known and fairly optimal to execute.</source>
          <target state="translated">レンダリングや画像操作で、デスティネーションに格納しなければならないカラー値を生成する場合、まず、そのカラーをデスティネーションの画像やサーフェイスに格納するのに適した形式に変換しなければなりません。最低限、色成分をビット表現に変換し、正しい順序で並べるか、または、データをデスティネーションメモリに格納する前に、色ルックアップテーブルへのインデックスを選択しなければならない。この最小限の変換を行わないと、保存先のデータはランダムで不正確な値、あるいはサポートされていない値を表す可能性があります。レンダリング操作の結果を、最も一般的なデスティネーションのカラーフォーマットに素早く変換するアルゴリズムはよく知られており、実行にはかなり最適です。</target>
        </trans-unit>
        <trans-unit id="7a3bf5e738a9141b4b95997a3f1e19dc1b7157d4" translate="yes" xml:space="preserve">
          <source>When a rowset gets its data from a relational database, it executes a command (a query) that produces a &lt;code&gt;ResultSet&lt;/code&gt; object. This query is the command that is set for the &lt;code&gt;RowSet&lt;/code&gt; object's command property. The rowset populates itself with data by reading the data from the &lt;code&gt;ResultSet&lt;/code&gt; object into itself. If the query contains placeholders for values to be set, the &lt;code&gt;BaseRowSet&lt;/code&gt; setter methods are used to set these values. All setter methods allow these values to be set to &lt;code&gt;null&lt;/code&gt; if required.</source>
          <target state="translated">行セットは、リレーショナルデータベースからデータを取得するときに、 &lt;code&gt;ResultSet&lt;/code&gt; オブジェクトを生成するコマンド（クエリ）を実行します。このクエリは、 &lt;code&gt;RowSet&lt;/code&gt; オブジェクトのコマンドプロパティに設定されるコマンドです。行セットは、 &lt;code&gt;ResultSet&lt;/code&gt; オブジェクトからそれ自体にデータを読み取ることにより、それ自体にデータを入力します。クエリに設定する値のプレースホルダーが含まれている場合、 &lt;code&gt;BaseRowSet&lt;/code&gt; セッターメソッドを使用してこれらの値を設定します。すべてのsetterメソッドでは、必要に応じてこれらの値を &lt;code&gt;null&lt;/code&gt; に設定できます。</target>
        </trans-unit>
        <trans-unit id="758869419d156f27990d997e0fa9fce2a685beea" translate="yes" xml:space="preserve">
          <source>When a scanner throws an &lt;a href=&quot;inputmismatchexception&quot;&gt;&lt;code&gt;InputMismatchException&lt;/code&gt;&lt;/a&gt;, the scanner will not pass the token that caused the exception, so that it may be retrieved or skipped via some other method.</source>
          <target state="translated">スキャナーが&lt;a href=&quot;inputmismatchexception&quot;&gt; &lt;code&gt;InputMismatchException&lt;/code&gt; を&lt;/a&gt;スローした場合、スキャナーは例外を引き起こしたトークンを渡さないため、他の方法で取得またはスキップできます。</target>
        </trans-unit>
        <trans-unit id="817af58e7bcbe10748b284737a339517287e3c10" translate="yes" xml:space="preserve">
          <source>When a scroll bar is used to select a range of values, the visible amount is used to represent the range of values that are currently visible. The size of the scroll bar's bubble (also called a thumb or scroll box), usually gives a visual representation of the relationship of the visible amount to the range of the scroll bar. Note that depending on platform, the value of the visible amount property may not be visually indicated by the size of the bubble.</source>
          <target state="translated">スクロールバーが値の範囲を選択するために使用される場合、現在表示されている値の範囲を表すために、表示されている量が使用されます。スクロールバーのバブル(親指やスクロールボックスとも呼ばれる)のサイズは、通常、スクロールバーの範囲に対する可視量の関係を視覚的に表現します。プラットフォームによっては、可視量プロパティの値がバブルのサイズによって視覚的に表示されない場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a853e62233343e776fbd44333e92601acc2febbe" translate="yes" xml:space="preserve">
          <source>When a security manager is installed and it denies access to a file (or directory), then it is ignored and not included in the stream.</source>
          <target state="translated">セキュリティマネージャがインストールされていて、それがファイル(またはディレクトリ)へのアクセスを拒否した場合、それは無視され、ストリームには含まれません。</target>
        </trans-unit>
        <trans-unit id="e74c73e1d683b9fecd0a717afa160e6920257abc" translate="yes" xml:space="preserve">
          <source>When a security manager is installed and it denies access to a file (or directory), then it is ignored and the visitor is not invoked for that file (or directory).</source>
          <target state="translated">セキュリティマネージャがインストールされていて、ファイル(またはディレクトリ)へのアクセスを拒否すると、そのファイル(またはディレクトリ)は無視され、そのファイル(またはディレクトリ)に対して訪問者が呼び出されません。</target>
        </trans-unit>
        <trans-unit id="61d88ca5288dc5b3be9b25739812ea67777f1b62" translate="yes" xml:space="preserve">
          <source>When a security manager is installed, it is invoked to check access to the each root directory. If denied, the root directory is not returned by the iterator. In the case of the default provider, the &lt;a href=&quot;../../lang/securitymanager#checkRead(java.lang.String)&quot;&gt;&lt;code&gt;SecurityManager.checkRead(String)&lt;/code&gt;&lt;/a&gt; method is invoked to check read access to each root directory. It is system dependent if the permission checks are done when the iterator is obtained or during iteration.</source>
          <target state="translated">セキュリティマネージャがインストールされると、各ルートディレクトリへのアクセスをチェックするために呼び出されます。拒否された場合、ルートディレクトリはイテレータによって返されません。デフォルトのプロバイダーの場合、&lt;a href=&quot;../../lang/securitymanager#checkRead(java.lang.String)&quot;&gt; &lt;code&gt;SecurityManager.checkRead(String)&lt;/code&gt; &lt;/a&gt;メソッドが呼び出され、各ルートディレクトリへの読み取りアクセスがチェックされます。イテレータの取得時または反復中に権限チェックが実行されるかどうかは、システムに依存します。</target>
        </trans-unit>
        <trans-unit id="3b16d1c9ade5f68deff8b6a72ad86abd212f522b" translate="yes" xml:space="preserve">
          <source>When a security manager is installed, it is invoked to check access to the each root directory. If denied, the root directory is not returned by the iterator. In the case of the default provider, the &lt;a href=&quot;../../lang/securitymanager#checkRead-java.lang.String-&quot;&gt;&lt;code&gt;SecurityManager.checkRead(String)&lt;/code&gt;&lt;/a&gt; method is invoked to check read access to each root directory. It is system dependent if the permission checks are done when the iterator is obtained or during iteration.</source>
          <target state="translated">セキュリティマネージャがインストールされると、各ルートディレクトリへのアクセスをチェックするために呼び出されます。拒否された場合、ルートディレクトリはイテレータから返されません。デフォルトのプロバイダーの場合、&lt;a href=&quot;../../lang/securitymanager#checkRead-java.lang.String-&quot;&gt; &lt;code&gt;SecurityManager.checkRead(String)&lt;/code&gt; &lt;/a&gt;メソッドが呼び出されて、各ルートディレクトリへの読み取りアクセスがチェックされます。イテレーターを取得するとき、または反復中に許可検査が行われるかどうかは、システムに依存します。</target>
        </trans-unit>
        <trans-unit id="bd8e3e90bc0a4ad1eaf1fe672cd6021d8ff59c73" translate="yes" xml:space="preserve">
          <source>When a service provider needs to determine the value of a property, it will generally take that value directly from the environment. A service provider may define provider-specific properties to be placed in its own provider resource file. In that case it should merge values as described in the previous paragraph.</source>
          <target state="translated">サービス・プロバイダがプロパティの値を決定する必要がある場合、通常は環境から直接その値を取得します。サービス・プロバイダは、プロバイダ固有のプロパティを定義して、独自のプロバイダ・リソース・ファイルに配置することができます。その場合は、前の段落で説明したように値をマージする必要があります。</target>
        </trans-unit>
        <trans-unit id="7807fd2cea76f3e1ce4a83a545e5b3a3ae40080e" translate="yes" xml:space="preserve">
          <source>When a service provider receives a response control, it uses control factories to return the specific/appropriate control class implementation.</source>
          <target state="translated">サービスプロバイダが応答制御を受信すると、制御工場を使用して特定/適切な制御クラスの実装を返します。</target>
        </trans-unit>
        <trans-unit id="3ade58d0e25bc018ea163c0cdad7f4b776c6ab39" translate="yes" xml:space="preserve">
          <source>When a service provider receives response controls, it uses the &lt;code&gt;ControlFactory&lt;/code&gt; class to produce specific classes that implement the &lt;code&gt;Control&lt;/code&gt; interface.</source>
          <target state="translated">サービスプロバイダーは、応答コントロールを受信すると、 &lt;code&gt;ControlFactory&lt;/code&gt; クラスを使用して、 &lt;code&gt;Control&lt;/code&gt; インターフェイスを実装する特定のクラスを生成します。</target>
        </trans-unit>
        <trans-unit id="3d30b140cad70a65f78e1eb56376dbfbaf7a9533" translate="yes" xml:space="preserve">
          <source>When a single argument is parsed more than once in the string, the last match will be the final result of the parsing. For example,</source>
          <target state="translated">単一の引数が文字列の中で複数回解析された場合、最後にマッチしたものが解析の最終結果となります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="058e1674f7a000873c2028dd6c1dc5cce20b5b83" translate="yes" xml:space="preserve">
          <source>When a socket is connected, &lt;a href=&quot;#receive(java.net.DatagramPacket)&quot;&gt;&lt;code&gt;receive&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#send(java.net.DatagramPacket)&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt;&lt;b&gt;will not perform any security checks&lt;/b&gt; on incoming and outgoing packets, other than matching the packet's and the socket's address and port. On a send operation, if the packet's address is set and the packet's address and the socket's address do not match, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown. A socket connected to a multicast address may only be used to send packets.</source>
          <target state="translated">ソケットが接続されている場合、&lt;a href=&quot;#receive(java.net.DatagramPacket)&quot;&gt; &lt;code&gt;receive&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#send(java.net.DatagramPacket)&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;&lt;b&gt;は&lt;/b&gt;、パケットとソケットのアドレスとポートを照合する以外に、着信パケットと発信パケットの&lt;b&gt;セキュリティチェック&lt;/b&gt;を&lt;b&gt;実行しません&lt;/b&gt;。送信操作で、パケットのアドレスが設定されていて、パケットのアドレスとソケットのアドレスが一致しない場合、 &lt;code&gt;IllegalArgumentException&lt;/code&gt; がスローされます。マルチキャストアドレスに接続されたソケットは、パケットの送信にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="b152721196e9350030fbce80cc3060686ce54e33" translate="yes" xml:space="preserve">
          <source>When a socket is connected, &lt;a href=&quot;datagramsocket#receive-java.net.DatagramPacket-&quot;&gt;&lt;code&gt;receive&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;datagramsocket#send-java.net.DatagramPacket-&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt;&lt;b&gt;will not perform any security checks&lt;/b&gt; on incoming and outgoing packets, other than matching the packet's and the socket's address and port. On a send operation, if the packet's address is set and the packet's address and the socket's address do not match, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown. A socket connected to a multicast address may only be used to send packets.</source>
          <target state="translated">ソケットが接続されている場合、&lt;a href=&quot;datagramsocket#receive-java.net.DatagramPacket-&quot;&gt; &lt;code&gt;receive&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;datagramsocket#send-java.net.DatagramPacket-&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;&lt;b&gt;は&lt;/b&gt;、パケットとソケットのアドレスおよびポートを照合することを除いて、着信パケットと発信パケットの&lt;b&gt;セキュリティチェック&lt;/b&gt;を&lt;b&gt;実行しません&lt;/b&gt;。送信操作で、パケットのアドレスが設定されていて、パケットのアドレスとソケットのアドレスが一致しない場合、 &lt;code&gt;IllegalArgumentException&lt;/code&gt; がスローされます。マルチキャストアドレスに接続されたソケットは、パケットの送信にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="a75cd6f6c3582a34b8ac5dfdb077e4af32675c83" translate="yes" xml:space="preserve">
          <source>When a socket subscribes to a multicast group/port, it receives datagrams sent by other hosts to the group/port, as do all other members of the group and port. A socket relinquishes membership in a group by the leaveGroup(InetAddress addr) method. &lt;b&gt; Multiple MulticastSocket's&lt;/b&gt; may subscribe to a multicast group and port concurrently, and they will all receive group datagrams.</source>
          <target state="translated">ソケットがマルチキャストグループ/ポートにサブスクライブすると、グループとポートの他のすべてのメンバーと同様に、他のホストからグループ/ポートに送信されたデータグラムを受信します。ソケットは、leaveGroup（InetAddress addr）メソッドによってグループのメンバーシップを放棄します。&lt;b&gt;複数のMulticastSocket&lt;/b&gt;がマルチキャストグループとポートに同時にサブスクライブする場合があり、それらはすべてグループデータグラムを受信します。</target>
        </trans-unit>
        <trans-unit id="1542ee008a8e9f826667c4f42290447523aa89a6" translate="yes" xml:space="preserve">
          <source>When a stack is first created, it contains no items.</source>
          <target state="translated">スタックが最初に作成されたとき、そのスタックにはアイテムが含まれていません。</target>
        </trans-unit>
        <trans-unit id="58680ac2a710c1c3ec572a26747c8ac4bf37321d" translate="yes" xml:space="preserve">
          <source>When a subclass is replacing objects it must insure that either a complementary substitution must be made during deserialization or that the substituted object is compatible with every field where the reference will be stored. Objects whose type is not a subclass of the type of the field or array element abort the serialization by raising an exception and the object is not be stored.</source>
          <target state="translated">サブクラスがオブジェクトを置換する場合、シリアル化の間に補完的な置換を行うか、置換されたオブジェクトが参照が格納されるすべてのフィールドと互換性があることを保証しなければなりません。型がフィールドや配列要素の型のサブクラスではないオブジェクトは、例外を発生させてシリアライズを中止し、オブジェクトは格納されません。</target>
        </trans-unit>
        <trans-unit id="4af4456165693adbeda480b45292ea0c955ff233" translate="yes" xml:space="preserve">
          <source>When a subclass is replacing objects it must insure that the substituted object is compatible with every field where the reference will be stored. Objects whose type is not a subclass of the type of the field or array element abort the serialization by raising an exception and the object is not be stored.</source>
          <target state="translated">サブクラスがオブジェクトを置換するとき、置換されたオブジェクトが参照が格納されるすべてのフィールドと互換性があることを保証しなければなりません。型がフィールドや配列要素の型のサブクラスではないオブジェクトは、例外を発生させてシリアライズを中止し、オブジェクトは格納されません。</target>
        </trans-unit>
        <trans-unit id="e26d84240a67b35d599a0931c437428256b549e1" translate="yes" xml:space="preserve">
          <source>When a subclass overrides a &lt;code&gt;visit&lt;i&gt;XYZ&lt;/i&gt;&lt;/code&gt; method, the new method can cause the enclosed elements to be scanned in the default way by calling &lt;code&gt;super.visit&lt;i&gt;XYZ&lt;/i&gt;&lt;/code&gt;. In this fashion, the concrete visitor can control the ordering of traversal over the component elements with respect to the additional processing; for example, consistently calling &lt;code&gt;super.visit&lt;i&gt;XYZ&lt;/i&gt;&lt;/code&gt; at the start of the overridden methods will yield a preorder traversal, etc. If the component elements should be traversed in some other order, instead of calling &lt;code&gt;super.visit&lt;i&gt;XYZ&lt;/i&gt;&lt;/code&gt;, an overriding visit method should call &lt;code&gt;scan&lt;/code&gt; with the elements in the desired order.</source>
          <target state="translated">サブクラス &lt;code&gt;visit&lt;i&gt;XYZ&lt;/i&gt;&lt;/code&gt; 訪問メソッドをオーバーライドすると、新しいメソッドは、 &lt;code&gt;super.visit&lt;i&gt;XYZ&lt;/i&gt;&lt;/code&gt; 呼び出すことにより、囲まれた要素をデフォルトの方法でスキャンさせることができます。このようにして、具体的なビジターは、追加の処理に関するコンポーネント要素のトラバーサルの順序を制御できます。たとえば、オーバーライドされたメソッドの開始時に一貫して &lt;code&gt;super.visit&lt;i&gt;XYZ&lt;/i&gt;&lt;/code&gt; を呼び出すと、前順トラバーサルが発生します。コンポーネント要素を他の順序でトラバースする必要がある場合は、 &lt;code&gt;super.visit&lt;i&gt;XYZ&lt;/i&gt;&lt;/code&gt; を呼び出す代わりに、オーバーライドするvisitメソッドを呼び出す必要があります。目的の順序で要素を &lt;code&gt;scan&lt;/code&gt; します。</target>
        </trans-unit>
        <trans-unit id="1982004121a817c184d129a04a27e56f1d2b9c31" translate="yes" xml:space="preserve">
          <source>When a subclass overrides a &lt;code&gt;visit&lt;i&gt;Xyz&lt;/i&gt;&lt;/code&gt; method, the new method can cause the enclosed elements to be scanned in the default way by calling &lt;code&gt;super.visit&lt;i&gt;Xyz&lt;/i&gt;&lt;/code&gt;. In this fashion, the concrete visitor can control the ordering of traversal over the component elements with respect to the additional processing; for example, consistently calling &lt;code&gt;super.visit&lt;i&gt;Xyz&lt;/i&gt;&lt;/code&gt; at the start of the overridden methods will yield a preorder traversal, etc. If the component elements should be traversed in some other order, instead of calling &lt;code&gt;super.visit&lt;i&gt;Xyz&lt;/i&gt;&lt;/code&gt;, an overriding visit method should call &lt;code&gt;scan&lt;/code&gt; with the elements in the desired order.</source>
          <target state="translated">サブクラス &lt;code&gt;visit&lt;i&gt;Xyz&lt;/i&gt;&lt;/code&gt; メソッドをオーバーライドする場合、新しいメソッドは、 &lt;code&gt;super.visit&lt;i&gt;Xyz&lt;/i&gt;&lt;/code&gt; 呼び出すことにより、囲まれた要素をデフォルトの方法でスキャンさせることができます。このようにして、具体的な訪問者は、追加の処理に関して、構成要素上のトラバーサルの順序を制御できます。たとえば、一貫して呼び出し &lt;code&gt;super.visit&lt;i&gt;Xyz&lt;/i&gt;&lt;/code&gt; 構成要素の代わりに呼び出す、いくつかの他の順序でトラバースする必要がある場合等、先行順走査をもたらすオーバーライドされたメソッドの開始時 &lt;code&gt;super.visit&lt;i&gt;Xyz&lt;/i&gt;&lt;/code&gt; 、オーバーライド訪問方法が呼び出す必要希望する順序で要素を &lt;code&gt;scan&lt;/code&gt; します。</target>
        </trans-unit>
        <trans-unit id="9929247187f11924a98b560a646e45a4e67ae3c7" translate="yes" xml:space="preserve">
          <source>When a submitted task is cancelled before it is run, execution is suppressed. By default, such a cancelled task is not automatically removed from the work queue until its delay elapses. While this enables further inspection and monitoring, it may also cause unbounded retention of cancelled tasks. To avoid this, set &lt;a href=&quot;scheduledthreadpoolexecutor#setRemoveOnCancelPolicy-boolean-&quot;&gt;&lt;code&gt;setRemoveOnCancelPolicy(boolean)&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;true&lt;/code&gt;, which causes tasks to be immediately removed from the work queue at time of cancellation.</source>
          <target state="translated">送信されたタスクが実行前にキャンセルされると、実行が抑制されます。デフォルトでは、そのようなキャンセルされたタスクは、その遅延が経過するまで自動的にワークキューから削除されません。これにより、詳細な検査と監視が可能になりますが、キャンセルされたタスクが際限なく保持される可能性もあります。これを回避するには、&lt;a href=&quot;scheduledthreadpoolexecutor#setRemoveOnCancelPolicy-boolean-&quot;&gt; &lt;code&gt;setRemoveOnCancelPolicy(boolean)&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;true&lt;/code&gt; に設定します。これにより、キャンセル時にタスクがワークキューから即座に削除されます。</target>
        </trans-unit>
        <trans-unit id="b44cdb1f4c54b9f9c38dd96a59f19c9b972ead75" translate="yes" xml:space="preserve">
          <source>When a submitted task is cancelled before it is run, execution is suppressed. By default, such a cancelled task is not automatically removed from the work queue until its delay elapses. While this enables further inspection and monitoring, it may also cause unbounded retention of cancelled tasks. To avoid this, use &lt;a href=&quot;#setRemoveOnCancelPolicy(boolean)&quot;&gt;&lt;code&gt;setRemoveOnCancelPolicy(boolean)&lt;/code&gt;&lt;/a&gt; to cause tasks to be immediately removed from the work queue at time of cancellation.</source>
          <target state="translated">送信されたタスクが実行前にキャンセルされると、実行が抑制されます。デフォルトでは、このようなキャンセルされたタスクは、遅延が経過するまでワークキューから自動的に削除されません。これにより、さらに検査と監視が可能になりますが、キャンセルされたタスクが無制限に保持される可能性もあります。これを回避するには、&lt;a href=&quot;#setRemoveOnCancelPolicy(boolean)&quot;&gt; &lt;code&gt;setRemoveOnCancelPolicy(boolean)&lt;/code&gt; &lt;/a&gt;を使用して、キャンセル時にタスクがワークキューからすぐに削除されるようにします。</target>
        </trans-unit>
        <trans-unit id="10b74fcebd08424b7bb7bf29fe6e5a17d846f581" translate="yes" xml:space="preserve">
          <source>When a system exclusive message is read from a MIDI file, it always has a defined length. Data from a system exclusive message from a MIDI file should be stored in the data array of a &lt;code&gt;SysexMessage&lt;/code&gt; as follows: the system exclusive message status byte (0xF0 or 0xF7), all message data bytes, and finally the end-of-exclusive flag (0xF7). The length reported by the &lt;code&gt;SysexMessage&lt;/code&gt; object is therefore the length of the system exclusive data plus two: one byte for the status byte and one for the end-of-exclusive flag.</source>
          <target state="translated">システムエクスクルーシブメッセージがMIDIファイルから読み取られる場合、そのメッセージの長さは常に定義されています。MIDIファイルのシステムエクスクルーシブメッセージのデータは、 &lt;code&gt;SysexMessage&lt;/code&gt; のデータ配列に次のように保存する必要があります。システムエクスクルーシブメッセージステータスバイト（0xF0または0xF7）、すべてのメッセージデータバイト、最後にエクスクルーシブ終了フラグ（ 0xF7）。したがって、 &lt;code&gt;SysexMessage&lt;/code&gt; オブジェクトによって報告される長さは、システムエクスクルーシブデータの長さに2を加えた長さになります。1バイトはステータスバイト用で、もう1バイトは排他終了フラグ用です。</target>
        </trans-unit>
        <trans-unit id="89b880bb7b0e20e4a94653fd28147b76b402fbeb" translate="yes" xml:space="preserve">
          <source>When a thread &lt;code&gt;T&lt;/code&gt; queries a class value in state &lt;code&gt;2N&lt;/code&gt;, the thread first attempts to initialize the class value to state &lt;code&gt;2N+1&lt;/code&gt; by invoking &lt;code&gt;computeValue&lt;/code&gt; and installing the resulting value.</source>
          <target state="translated">スレッド &lt;code&gt;T&lt;/code&gt; が状態 &lt;code&gt;2N&lt;/code&gt; のクラス値を照会すると、スレッドはまず、 &lt;code&gt;computeValue&lt;/code&gt; を呼び出して結果の値をインストールすることにより、クラス値を状態 &lt;code&gt;2N+1&lt;/code&gt; に初期化しようとします。</target>
        </trans-unit>
        <trans-unit id="d0bb71d68a413b1e3688231ebd3a0fe5821666fc" translate="yes" xml:space="preserve">
          <source>When a thread &lt;code&gt;T&lt;/code&gt; removes a class value in state &lt;code&gt;2N&lt;/code&gt;, nothing happens, since the class value is already uninitialized. Otherwise, the state is advanced atomically to &lt;code&gt;2N+1&lt;/code&gt;.</source>
          <target state="translated">スレッド &lt;code&gt;T&lt;/code&gt; が状態 &lt;code&gt;2N&lt;/code&gt; のクラス値を削除しても、クラス値はすでに初期化されていないため、何も起こりません。それ以外の場合、状態はアトミックに &lt;code&gt;2N+1&lt;/code&gt; に進みます。</target>
        </trans-unit>
        <trans-unit id="5f150b9d52841cfe078b29c41afb5606285d9203" translate="yes" xml:space="preserve">
          <source>When a thread is about to terminate due to an uncaught exception the Java Virtual Machine will query the thread for its &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; using &lt;a href=&quot;thread#getUncaughtExceptionHandler()&quot;&gt;&lt;code&gt;Thread.getUncaughtExceptionHandler()&lt;/code&gt;&lt;/a&gt; and will invoke the handler's &lt;code&gt;uncaughtException&lt;/code&gt; method, passing the thread and the exception as arguments. If a thread has not had its &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; explicitly set, then its &lt;code&gt;ThreadGroup&lt;/code&gt; object acts as its &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt;. If the &lt;code&gt;ThreadGroup&lt;/code&gt; object has no special requirements for dealing with the exception, it can forward the invocation to the &lt;a href=&quot;thread#getDefaultUncaughtExceptionHandler()&quot;&gt;default uncaught exception handler&lt;/a&gt;.</source>
          <target state="translated">キャッチされなかった例外が原因でスレッドが終了しようとすると、Java仮想マシンは&lt;a href=&quot;thread#getUncaughtExceptionHandler()&quot;&gt; &lt;code&gt;Thread.getUncaughtExceptionHandler()&lt;/code&gt; &lt;/a&gt;を使用してスレッドに &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; を照会し、ハンドラーの &lt;code&gt;uncaughtException&lt;/code&gt; メソッドを呼び出して、スレッドと例外を引数として渡します。スレッドに &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; が明示的に設定されていない場合、その &lt;code&gt;ThreadGroup&lt;/code&gt; オブジェクトは &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; として機能します。 &lt;code&gt;ThreadGroup&lt;/code&gt; オブジェクトに例外を処理するための特別な要件がない場合は、呼び出しを&lt;a href=&quot;thread#getDefaultUncaughtExceptionHandler()&quot;&gt;デフォルトのキャッチさ&lt;/a&gt;れていない例外ハンドラーに転送できます。</target>
        </trans-unit>
        <trans-unit id="77fe3f278ecb8fc0ec8c3db5bded17a3ac83c0e0" translate="yes" xml:space="preserve">
          <source>When a thread is about to terminate due to an uncaught exception the Java Virtual Machine will query the thread for its &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; using &lt;a href=&quot;thread#getUncaughtExceptionHandler--&quot;&gt;&lt;code&gt;Thread.getUncaughtExceptionHandler()&lt;/code&gt;&lt;/a&gt; and will invoke the handler's &lt;code&gt;uncaughtException&lt;/code&gt; method, passing the thread and the exception as arguments. If a thread has not had its &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; explicitly set, then its &lt;code&gt;ThreadGroup&lt;/code&gt; object acts as its &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt;. If the &lt;code&gt;ThreadGroup&lt;/code&gt; object has no special requirements for dealing with the exception, it can forward the invocation to the &lt;a href=&quot;thread#getDefaultUncaughtExceptionHandler--&quot;&gt;default uncaught exception handler&lt;/a&gt;.</source>
          <target state="translated">キャッチされない例外が原因でスレッドが終了しようとすると、Java仮想マシンは&lt;a href=&quot;thread#getUncaughtExceptionHandler--&quot;&gt; &lt;code&gt;Thread.getUncaughtExceptionHandler()&lt;/code&gt; &lt;/a&gt;を使用してスレッドに &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; を照会し、ハンドラーの &lt;code&gt;uncaughtException&lt;/code&gt; メソッドを呼び出して、スレッドと例外を引数として渡します。スレッドの &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; が明示的に設定されていない場合、その &lt;code&gt;ThreadGroup&lt;/code&gt; オブジェクトはその &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; として機能します。 &lt;code&gt;ThreadGroup&lt;/code&gt; オブジェクトに例外を処理するための特別な要件がない場合は、呼び出しを&lt;a href=&quot;thread#getDefaultUncaughtExceptionHandler--&quot;&gt;デフォルトのキャッチされない例外ハンドラーに&lt;/a&gt;転送できます。</target>
        </trans-unit>
        <trans-unit id="895317443968ac47f3f92d75cb96a37c77319964" translate="yes" xml:space="preserve">
          <source>When a three part address is specified, the last part is interpreted as a 16-bit quantity and placed in the right most two bytes of the network address. This makes the three part address format convenient for specifying Class B net- work addresses as 128.net.host.</source>
          <target state="translated">3 つのパートのアドレスが指定された場合、最後のパートは 16 ビットの量として解釈され、ネットワーク・アドレスの右端 2 バイトに配置されます。これにより、クラス B のネット ワークアドレスを 128.net.host のように指定するのに便利な 3 つのパートアドレス形式になります。</target>
        </trans-unit>
        <trans-unit id="55c955456f3e00fb19bba01a0a16d6dc85d4343f" translate="yes" xml:space="preserve">
          <source>When a toolkit-modal dialog is shown from an applet, it blocks all other applets in the browser. When launching applications from Java Web Start, its windows (such as the security dialog) may also be blocked by toolkit-modal dialogs, shown from these applications.</source>
          <target state="translated">ツールキット・モーダル・ダイアログがアプレットから表示されると、ブラウザ内の他のすべてのアプレットがブロックされます。Java Web Start からアプリケーションを起動すると、そのウィンドウ(セキュリティ ダイアログなど)も、これらのアプリケーションから表示されるツールキット モーダル ダイアログによってブロックされることがあります。</target>
        </trans-unit>
        <trans-unit id="29a6c60ea1ad71509b0284da02c6071f09ce9c45" translate="yes" xml:space="preserve">
          <source>When a two part address is supplied, the last part is interpreted as a 24-bit quantity and placed in the right most three bytes of the network address. This makes the two part address format convenient for specifying Class A network addresses as net.host.</source>
          <target state="translated">2 つのパート・アドレスが与えられると、最後のパートは 24 ビットの量として解釈され、ネットワーク・アドレスの右端の 3 バイトに配置されます。これにより、2 つのパート・アドレス・フォーマットは、クラス A ネットワーク・アドレスを net.host として指定するのに便利になります。</target>
        </trans-unit>
        <trans-unit id="50fa67634b29d9a508bc8a6003503fb30f4c5d33" translate="yes" xml:space="preserve">
          <source>When a type map with an entry for the base type is supplied to the methods &lt;code&gt;getArray&lt;/code&gt; and &lt;code&gt;getResultSet&lt;/code&gt;, the mapping it contains will be used to map the elements of the &lt;code&gt;ARRAY&lt;/code&gt; value. If no type map is supplied, which would typically be the case, the connection's type map is used by default. If the connection's type map or a type map supplied to a method has no entry for the base type, the elements are mapped according to the standard mapping.</source>
          <target state="translated">基本型のエントリを持つ型マップがメソッド &lt;code&gt;getArray&lt;/code&gt; および &lt;code&gt;getResultSet&lt;/code&gt; に提供されると、それに含まれるマッピングを使用して &lt;code&gt;ARRAY&lt;/code&gt; 値の要素がマップされます。タイプマップが指定されていない場合（通常はそうです）、接続のタイプマップがデフォルトで使用されます。接続のタイプマップまたはメソッドに提供されたタイプマップに基本タイプのエントリがない場合、要素は標準マッピングに従ってマッピングされます。</target>
        </trans-unit>
        <trans-unit id="6aa8db231eb18f002bb271b220e13400b3ee853b" translate="yes" xml:space="preserve">
          <source>When a variable &lt;code&gt;{i}&lt;/code&gt; appears in a search filter, it indicates that the filter argument &lt;code&gt;filterArgs[i]&lt;/code&gt; is to be used in that place. Such variables may be used wherever an &lt;em&gt;attr&lt;/em&gt;, &lt;em&gt;value&lt;/em&gt;, or &lt;em&gt;matchingrule&lt;/em&gt; production appears in the filter grammar of RFC 2254, section 4. When a string-valued filter argument is substituted for a variable, the filter is interpreted as if the string were given in place of the variable, with any characters having special significance within filters (such as &lt;code&gt;'*'&lt;/code&gt;) having been escaped according to the rules of RFC 2254.</source>
          <target state="translated">変数 &lt;code&gt;{i}&lt;/code&gt; が検索フィルターに現れる場合、フィルター引数 &lt;code&gt;filterArgs[i]&lt;/code&gt; がその場所で使用されることを示しています。このような変数は、&lt;em&gt;attr&lt;/em&gt;、&lt;em&gt;value&lt;/em&gt;、または&lt;em&gt;matchingruleの&lt;/em&gt;生成がRFC 2254のフィルター文法のセクション4にある場合に使用できます。文字列値のフィルター引数が変数に置き換えられると、フィルターは文字列が変数の場所。フィルター内で特別な意味を持つ文字（ &lt;code&gt;'*'&lt;/code&gt; など）は、RFC 2254のルールに従ってエスケープされています。</target>
        </trans-unit>
        <trans-unit id="a223dab9f441fba936619f7975da0a97a57c63a7" translate="yes" xml:space="preserve">
          <source>When a very large ASCII value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt; parameter, it may be more practical to send it via a &lt;code&gt;java.io.InputStream&lt;/code&gt; object. A JDBC technology-enabled driver will read the data from the stream as needed until it reaches end-of-file. The driver will do any necessary conversion from ASCII to the database &lt;code&gt;CHAR&lt;/code&gt; format.</source>
          <target state="translated">非常に大きなASCII値が &lt;code&gt;LONGVARCHAR&lt;/code&gt; パラメータに入力される場合、 &lt;code&gt;java.io.InputStream&lt;/code&gt; オブジェクトを介して送信する方が実用的な場合があります。 JDBCテクノロジ対応のドライバは、ファイルの終わりに達するまで、必要に応じてストリームからデータを読み取ります。ドライバは、ASCIIからデータベースの &lt;code&gt;CHAR&lt;/code&gt; 形式への必要な変換を行います。</target>
        </trans-unit>
        <trans-unit id="fcd897e7054adc322a89f61811e83785269eb890" translate="yes" xml:space="preserve">
          <source>When a very large Unicode value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt; parameter, it may be more practical to send it via a &lt;code&gt;Reader&lt;/code&gt; object. A JDBC technology-enabled driver will read the data from the stream as needed until it reaches end-of-file. The driver will do any necessary conversion from Unicode to the database &lt;code&gt;CHAR&lt;/code&gt; format. The byte format of the Unicode stream must be Java UTF-8, as defined in the Java Virtual Machine Specification.</source>
          <target state="translated">非常に大きなUnicode値が &lt;code&gt;LONGVARCHAR&lt;/code&gt; パラメータに入力された場合、 &lt;code&gt;Reader&lt;/code&gt; オブジェクトを介して送信する方が実用的な場合があります。 JDBCテクノロジ対応のドライバは、ファイルの終わりに達するまで、必要に応じてストリームからデータを読み取ります。ドライバは、Unicodeからデータベースの &lt;code&gt;CHAR&lt;/code&gt; 形式への必要な変換を行います。 Unicodeストリームのバイト形式は、Java仮想マシン仕様で定義されているようにJavaUTF-8である必要があります。</target>
        </trans-unit>
        <trans-unit id="1e04bc4facdf8d539c4270ddd0aa73a722158aa2" translate="yes" xml:space="preserve">
          <source>When a very large Unicode value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt; parameter, it may be more practical to send it via a &lt;code&gt;java.io.InputStream&lt;/code&gt; object. A JDBC technology-enabled driver will read the data from the stream as needed, until it reaches end-of-file. The driver will do any necessary conversion from Unicode to the database &lt;code&gt;CHAR&lt;/code&gt; format. The byte format of the Unicode stream must be Java UTF-8, as defined in the Java Virtual Machine Specification.</source>
          <target state="translated">非常に大きなUnicode値が &lt;code&gt;LONGVARCHAR&lt;/code&gt; パラメーターに入力される場合、 &lt;code&gt;java.io.InputStream&lt;/code&gt; オブジェクトを介して送信する方が実用的かもしれません。JDBCテクノロジ対応のドライバは、ファイルの終わりに達するまで、必要に応じてストリームからデータを読み取ります。ドライバは、Unicodeからデータベースの &lt;code&gt;CHAR&lt;/code&gt; 形式への必要な変換を行います。Unicodeストリームのバイト形式は、Java仮想マシン仕様で定義されているようにJavaUTF-8である必要があります。</target>
        </trans-unit>
        <trans-unit id="adc578dc87370a608ed5a2be5460fe895888ac7d" translate="yes" xml:space="preserve">
          <source>When a very large binary value is input to a &lt;code&gt;LONGVARBINARY&lt;/code&gt; parameter, it may be more practical to send it via a &lt;code&gt;java.io.InputStream&lt;/code&gt; object. A JDBC technology-enabled driver will read the data from the stream as needed until it reaches end-of-file.</source>
          <target state="translated">非常に大きなバイナリ値が &lt;code&gt;LONGVARBINARY&lt;/code&gt; パラメータに入力される場合、 &lt;code&gt;java.io.InputStream&lt;/code&gt; オブジェクトを介して送信する方が実用的な場合があります。JDBCテクノロジ対応のドライバは、ファイルの終わりに達するまで、必要に応じてストリームからデータを読み取ります。</target>
        </trans-unit>
        <trans-unit id="e2c2469b19a3494bf3f5739b9534978d0c5455a7" translate="yes" xml:space="preserve">
          <source>When adding providers to the cache, the &lt;a href=&quot;serviceloader#iterator--&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; processes resources in the order that the &lt;a href=&quot;../lang/classloader#getResources-java.lang.String-&quot;&gt;&lt;code&gt;ClassLoader.getResources(String)&lt;/code&gt;&lt;/a&gt; method finds the service configuration files.</source>
          <target state="translated">キャッシュにプロバイダーを追加すると、&lt;a href=&quot;serviceloader#iterator--&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;../lang/classloader#getResources-java.lang.String-&quot;&gt; &lt;code&gt;ClassLoader.getResources(String)&lt;/code&gt; &lt;/a&gt;メソッドがサービス構成ファイルを見つける順序でリソースを処理します。</target>
        </trans-unit>
        <trans-unit id="a3a63ad56f11301a43466ccd3853e7b3ff64e5a3" translate="yes" xml:space="preserve">
          <source>When all modules have been enumerated then a readability graph is computed, and in conjunction with the module exports and service use, checked for consistency.</source>
          <target state="translated">すべてのモジュールが列挙されると、可読性グラフが計算され、モジュールのエクスポートとサービスの使用に関連して、一貫性があるかどうかがチェックされます。</target>
        </trans-unit>
        <trans-unit id="bcd60d3bee845f9fdd7a82c5e0d643e282800575" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt; is set, the callee will report all the errors found in sources to the handler. If the handler throws an exception, it will abort the schema compilation and the same exception will be thrown from this method. Also, after an error is reported to a handler, the callee is allowed to abort the further processing by throwing it. If an error handler is not set, the callee will throw the first error it finds in the sources.</source>
          <target state="translated">とき&lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; &lt;/a&gt;設定され、呼び出し先は、ハンドラへのソースで見つかったすべてのエラーを報告します。ハンドラーが例外をスローすると、スキーマのコンパイルが中止され、このメソッドから同じ例外がスローされます。また、エラーがハンドラーに報告された後、呼び出し先はそれをスローすることによってそれ以上の処理を中止することができます。エラーハンドラが設定されていない場合、呼び出し先はソースで最初に検出したエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="bb2dce23419118f6b8331bfb0b7c1d8142491745" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;../inputsource&quot;&gt;&lt;code&gt;InputSource&lt;/code&gt;&lt;/a&gt; is used to provide an entity's character stream, this method returns the encoding provided in that input stream.</source>
          <target state="translated">&lt;a href=&quot;../inputsource&quot;&gt; &lt;code&gt;InputSource&lt;/code&gt; &lt;/a&gt;を使用してエンティティの文字ストリームを提供する場合、このメソッドはその入力ストリームで提供されたエンコーディングを返します。</target>
        </trans-unit>
        <trans-unit id="4e81b728c5aff55890dffac2c0a02554a169937e" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;SSLSocket&lt;/code&gt; is first created, no handshaking is done so that applications may first set their communication preferences: what cipher suites to use, whether the socket should be in client or server mode, etc. However, security is always provided by the time that application data is sent over the connection.</source>
          <target state="translated">&lt;code&gt;SSLSocket&lt;/code&gt; が最初に作成されるとき、アプリケーションが最初に通信設定（使用する暗号スイート、ソケットをクライアントモードにするかサーバーモードにするかなど）を設定できるように、ハンドシェイクは行われません。ただし、セキュリティは常にその時点までに提供されます。アプリケーションデータは接続を介して送信されます。</target>
        </trans-unit>
        <trans-unit id="5c164b99953c48a40b73ea8b2b0ca7202f7ca056" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;XMLSignature&lt;/code&gt; containing this reference is generated, the specified &lt;code&gt;transforms&lt;/code&gt; (if non-null) are applied to the specified &lt;code&gt;result&lt;/code&gt;. The &lt;code&gt;Transforms&lt;/code&gt; element of the resulting &lt;code&gt;Reference&lt;/code&gt; element is set to the concatenation of the &lt;code&gt;appliedTransforms&lt;/code&gt; and &lt;code&gt;transforms&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;XMLSignature&lt;/code&gt; この参照を含むが生成され、指定された &lt;code&gt;transforms&lt;/code&gt; （null以外の場合）指定に適用され &lt;code&gt;result&lt;/code&gt; 。結果の &lt;code&gt;Reference&lt;/code&gt; 要素の &lt;code&gt;Transforms&lt;/code&gt; 要素は、 &lt;code&gt;appliedTransforms&lt;/code&gt; と &lt;code&gt;transforms&lt;/code&gt; の連結に設定されます。</target>
        </trans-unit>
        <trans-unit id="bcaddb468356d4ee2035b39f238ba71251cf9ad5" translate="yes" xml:space="preserve">
          <source>When an Externalizable object is reconstructed, an instance is created using the public no-arg constructor, then the readExternal method called. Serializable objects are restored by reading them from an ObjectInputStream.</source>
          <target state="translated">Externalizable オブジェクトが再構築されると、public no-arg コンストラクタを使用してインスタンスが作成され、その後 readExternal メソッドが呼び出されます。シリアライズ可能なオブジェクトは、ObjectInputStream から読み込むことでリストアされます。</target>
        </trans-unit>
        <trans-unit id="fb8f935efcf55f08e7d5d19a4cd9f7c5f2edf11a" translate="yes" xml:space="preserve">
          <source>When an MBean emits a notification, it considers each listener that has been added with &lt;a href=&quot;#addNotificationListener(javax.management.NotificationListener,javax.management.NotificationFilter,java.lang.Object)&quot;&gt;&lt;code&gt;addNotificationListener&lt;/code&gt;&lt;/a&gt; and not subsequently removed with &lt;a href=&quot;#removeNotificationListener(javax.management.NotificationListener)&quot;&gt;&lt;code&gt;removeNotificationListener&lt;/code&gt;&lt;/a&gt;. If a filter was provided with that listener, and if the filter's &lt;a href=&quot;notificationfilter#isNotificationEnabled(javax.management.Notification)&quot;&gt;&lt;code&gt;isNotificationEnabled&lt;/code&gt;&lt;/a&gt; method returns false, the listener is ignored. Otherwise, the listener's &lt;a href=&quot;notificationlistener#handleNotification(javax.management.Notification,java.lang.Object)&quot;&gt;&lt;code&gt;handleNotification&lt;/code&gt;&lt;/a&gt; method is called with the notification, as well as the handback object that was provided to &lt;code&gt;addNotificationListener&lt;/code&gt;.</source>
          <target state="translated">MBeanが通知を&lt;a href=&quot;#addNotificationListener(javax.management.NotificationListener,javax.management.NotificationFilter,java.lang.Object)&quot;&gt; &lt;code&gt;addNotificationListener&lt;/code&gt; &lt;/a&gt;と、addNotificationListenerで追加され、その後&lt;a href=&quot;#removeNotificationListener(javax.management.NotificationListener)&quot;&gt; &lt;code&gt;removeNotificationListener&lt;/code&gt; &lt;/a&gt;で削除されなかった各リスナーが考慮されます。そのリスナーにフィルターが提供されていて、フィルターの&lt;a href=&quot;notificationfilter#isNotificationEnabled(javax.management.Notification)&quot;&gt; &lt;code&gt;isNotificationEnabled&lt;/code&gt; &lt;/a&gt;メソッドがfalseを返した場合、リスナーは無視されます。それ以外の場合は、リスナーの&lt;a href=&quot;notificationlistener#handleNotification(javax.management.Notification,java.lang.Object)&quot;&gt; &lt;code&gt;handleNotification&lt;/code&gt; &lt;/a&gt;メソッドが通知とともに呼び出され、 &lt;code&gt;addNotificationListener&lt;/code&gt; に提供されたハンドバックオブジェクトも呼び出されます。</target>
        </trans-unit>
        <trans-unit id="fa3ea13008a777f73a92e7a4bb586fabfda6d863" translate="yes" xml:space="preserve">
          <source>When an MBean emits a notification, it considers each listener that has been added with &lt;a href=&quot;notificationbroadcaster#addNotificationListener(javax.management.NotificationListener,javax.management.NotificationFilter,java.lang.Object)&quot;&gt;&lt;code&gt;addNotificationListener&lt;/code&gt;&lt;/a&gt; and not subsequently removed with &lt;a href=&quot;#removeNotificationListener(javax.management.NotificationListener,javax.management.NotificationFilter,java.lang.Object)&quot;&gt;&lt;code&gt;removeNotificationListener&lt;/code&gt;&lt;/a&gt;. If a filter was provided with that listener, and if the filter's &lt;a href=&quot;notificationfilter#isNotificationEnabled(javax.management.Notification)&quot;&gt;&lt;code&gt;isNotificationEnabled&lt;/code&gt;&lt;/a&gt; method returns false, the listener is ignored. Otherwise, the listener's &lt;a href=&quot;notificationlistener#handleNotification(javax.management.Notification,java.lang.Object)&quot;&gt;&lt;code&gt;handleNotification&lt;/code&gt;&lt;/a&gt; method is called with the notification, as well as the handback object that was provided to &lt;code&gt;addNotificationListener&lt;/code&gt;.</source>
          <target state="translated">MBeanが通知を&lt;a href=&quot;notificationbroadcaster#addNotificationListener(javax.management.NotificationListener,javax.management.NotificationFilter,java.lang.Object)&quot;&gt; &lt;code&gt;addNotificationListener&lt;/code&gt; &lt;/a&gt;と、addNotificationListenerで追加され、その後&lt;a href=&quot;#removeNotificationListener(javax.management.NotificationListener,javax.management.NotificationFilter,java.lang.Object)&quot;&gt; &lt;code&gt;removeNotificationListener&lt;/code&gt; &lt;/a&gt;で削除されなかった各リスナーが考慮されます。そのリスナーにフィルターが提供されていて、フィルターの&lt;a href=&quot;notificationfilter#isNotificationEnabled(javax.management.Notification)&quot;&gt; &lt;code&gt;isNotificationEnabled&lt;/code&gt; &lt;/a&gt;メソッドがfalseを返した場合、リスナーは無視されます。それ以外の場合は、リスナーの&lt;a href=&quot;notificationlistener#handleNotification(javax.management.Notification,java.lang.Object)&quot;&gt; &lt;code&gt;handleNotification&lt;/code&gt; &lt;/a&gt;メソッドが通知とともに呼び出され、 &lt;code&gt;addNotificationListener&lt;/code&gt; に提供されたハンドバックオブジェクトも呼び出されます。</target>
        </trans-unit>
        <trans-unit id="45b4eddc256c7dd0ed23de01764919b7450154dc" translate="yes" xml:space="preserve">
          <source>When an MBean emits a notification, it considers each listener that has been added with &lt;a href=&quot;notificationbroadcaster#addNotificationListener-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt;&lt;code&gt;addNotificationListener&lt;/code&gt;&lt;/a&gt; and not subsequently removed with &lt;a href=&quot;notificationbroadcaster#removeNotificationListener-javax.management.NotificationListener-&quot;&gt;&lt;code&gt;removeNotificationListener&lt;/code&gt;&lt;/a&gt;. If a filter was provided with that listener, and if the filter's &lt;a href=&quot;notificationfilter#isNotificationEnabled-javax.management.Notification-&quot;&gt;&lt;code&gt;isNotificationEnabled&lt;/code&gt;&lt;/a&gt; method returns false, the listener is ignored. Otherwise, the listener's &lt;a href=&quot;notificationlistener#handleNotification-javax.management.Notification-java.lang.Object-&quot;&gt;&lt;code&gt;handleNotification&lt;/code&gt;&lt;/a&gt; method is called with the notification, as well as the handback object that was provided to &lt;code&gt;addNotificationListener&lt;/code&gt;.</source>
          <target state="translated">MBeanが通知を送信するとき、MBeanは&lt;a href=&quot;notificationbroadcaster#addNotificationListener-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt; &lt;code&gt;addNotificationListener&lt;/code&gt; &lt;/a&gt;で追加され、その後&lt;a href=&quot;notificationbroadcaster#removeNotificationListener-javax.management.NotificationListener-&quot;&gt; &lt;code&gt;removeNotificationListener&lt;/code&gt; &lt;/a&gt;で削除されていない各リスナーを考慮します。フィルターがそのリスナーで提供されていて、フィルターの&lt;a href=&quot;notificationfilter#isNotificationEnabled-javax.management.Notification-&quot;&gt; &lt;code&gt;isNotificationEnabled&lt;/code&gt; &lt;/a&gt;メソッドがfalseを返した場合、リスナーは無視されます。それ以外の場合、リスナーの&lt;a href=&quot;notificationlistener#handleNotification-javax.management.Notification-java.lang.Object-&quot;&gt; &lt;code&gt;handleNotification&lt;/code&gt; &lt;/a&gt;メソッドは、通知と &lt;code&gt;addNotificationListener&lt;/code&gt; に提供されたハンドバックオブジェクトとともに呼び出されます。</target>
        </trans-unit>
        <trans-unit id="b71b50e0adb800b8bc569793e796446befc75eb6" translate="yes" xml:space="preserve">
          <source>When an MBean emits a notification, it considers each listener that has been added with &lt;a href=&quot;notificationbroadcaster#addNotificationListener-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt;&lt;code&gt;addNotificationListener&lt;/code&gt;&lt;/a&gt; and not subsequently removed with &lt;a href=&quot;notificationemitter#removeNotificationListener-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt;&lt;code&gt;removeNotificationListener&lt;/code&gt;&lt;/a&gt;. If a filter was provided with that listener, and if the filter's &lt;a href=&quot;notificationfilter#isNotificationEnabled-javax.management.Notification-&quot;&gt;&lt;code&gt;isNotificationEnabled&lt;/code&gt;&lt;/a&gt; method returns false, the listener is ignored. Otherwise, the listener's &lt;a href=&quot;notificationlistener#handleNotification-javax.management.Notification-java.lang.Object-&quot;&gt;&lt;code&gt;handleNotification&lt;/code&gt;&lt;/a&gt; method is called with the notification, as well as the handback object that was provided to &lt;code&gt;addNotificationListener&lt;/code&gt;.</source>
          <target state="translated">MBeanが通知を送信するとき、MBeanは&lt;a href=&quot;notificationbroadcaster#addNotificationListener-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt; &lt;code&gt;addNotificationListener&lt;/code&gt; &lt;/a&gt;で追加され、その後&lt;a href=&quot;notificationemitter#removeNotificationListener-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt; &lt;code&gt;removeNotificationListener&lt;/code&gt; &lt;/a&gt;で削除されていない各リスナーを考慮します。フィルターがそのリスナーで提供されていて、フィルターの&lt;a href=&quot;notificationfilter#isNotificationEnabled-javax.management.Notification-&quot;&gt; &lt;code&gt;isNotificationEnabled&lt;/code&gt; &lt;/a&gt;メソッドがfalseを返した場合、リスナーは無視されます。それ以外の場合、リスナーの&lt;a href=&quot;notificationlistener#handleNotification-javax.management.Notification-java.lang.Object-&quot;&gt; &lt;code&gt;handleNotification&lt;/code&gt; &lt;/a&gt;メソッドは、通知と &lt;code&gt;addNotificationListener&lt;/code&gt; に提供されたハンドバックオブジェクトとともに呼び出されます。</target>
        </trans-unit>
        <trans-unit id="4a7fc36f9fbd29ea8d2c562e9942118b86a45c61" translate="yes" xml:space="preserve">
          <source>When an MBean is registered in an MBean Server, if it is of a subclass of &lt;a href=&quot;../../../../java.base/java/lang/classloader&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt;&lt;/a&gt; and if it does not implement the interface &lt;a href=&quot;privateclassloader&quot;&gt;&lt;code&gt;PrivateClassLoader&lt;/code&gt;&lt;/a&gt;, it is added to the end of the MBean Server's &lt;code&gt;ClassLoaderRepository&lt;/code&gt;. If it is subsequently unregistered from the MBean Server, it is removed from the &lt;code&gt;ClassLoaderRepository&lt;/code&gt;.</source>
          <target state="translated">MBeanがMBeanサーバーに登録されている場合、それが&lt;a href=&quot;../../../../java.base/java/lang/classloader&quot;&gt; &lt;code&gt;ClassLoader&lt;/code&gt; の&lt;/a&gt;サブクラスであり、インターフェイス&lt;a href=&quot;privateclassloader&quot;&gt; &lt;code&gt;PrivateClassLoader&lt;/code&gt; を&lt;/a&gt;実装していない場合は、MBeanサーバーの &lt;code&gt;ClassLoaderRepository&lt;/code&gt; の最後に追加されます。その後、MBeanサーバーから登録解除されると、 &lt;code&gt;ClassLoaderRepository&lt;/code&gt; から削除されます。</target>
        </trans-unit>
        <trans-unit id="fc7e40c74e30e9bdda780e2f49b9064de3f28184" translate="yes" xml:space="preserve">
          <source>When an MBean is registered in an MBean Server, if it is of a subclass of &lt;a href=&quot;../../../java/lang/classloader&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt;&lt;/a&gt; and if it does not implement the interface &lt;a href=&quot;privateclassloader&quot;&gt;&lt;code&gt;PrivateClassLoader&lt;/code&gt;&lt;/a&gt;, it is added to the end of the MBean Server's &lt;code&gt;ClassLoaderRepository&lt;/code&gt;. If it is subsequently unregistered from the MBean Server, it is removed from the &lt;code&gt;ClassLoaderRepository&lt;/code&gt;.</source>
          <target state="translated">MBeanがMBeanサーバーに登録されている場合、それが&lt;a href=&quot;../../../java/lang/classloader&quot;&gt; &lt;code&gt;ClassLoader&lt;/code&gt; の&lt;/a&gt;サブクラスであり、それがインターフェース&lt;a href=&quot;privateclassloader&quot;&gt; &lt;code&gt;PrivateClassLoader&lt;/code&gt; を&lt;/a&gt;実装していない場合、MBeanサーバーの &lt;code&gt;ClassLoaderRepository&lt;/code&gt; の最後に追加されます。その後MBeanサーバーから登録解除されると、 &lt;code&gt;ClassLoaderRepository&lt;/code&gt; から削除されます。</target>
        </trans-unit>
        <trans-unit id="196aa3134ab9e8ce892612894f6293eb271a9ead" translate="yes" xml:space="preserve">
          <source>When an MBean is registered or unregistered in the MBean server a &lt;a href=&quot;mbeanservernotification&quot;&gt;&lt;code&gt;MBeanServerNotification&lt;/code&gt;&lt;/a&gt; Notification is emitted. To register an object as listener to MBeanServerNotifications you should call the MBean server method &lt;a href=&quot;#addNotificationListener(javax.management.ObjectName,javax.management.NotificationListener,javax.management.NotificationFilter,java.lang.Object)&quot;&gt;&lt;code&gt;addNotificationListener&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;ObjectName&lt;/code&gt; the &lt;code&gt;ObjectName&lt;/code&gt; of the &lt;a href=&quot;mbeanserverdelegate&quot;&gt;&lt;code&gt;MBeanServerDelegate&lt;/code&gt;&lt;/a&gt;. This &lt;code&gt;ObjectName&lt;/code&gt; is:</source>
          <target state="translated">MBeanがMBeanサーバーに登録または登録解除されると、&lt;a href=&quot;mbeanservernotification&quot;&gt; &lt;code&gt;MBeanServerNotification&lt;/code&gt; &lt;/a&gt;通知が発行されます。MBeanServerNotificationsにリスナーとしてオブジェクトを登録するには、MBeanサーバーメソッドを呼び出す必要があり&lt;a href=&quot;#addNotificationListener(javax.management.ObjectName,javax.management.NotificationListener,javax.management.NotificationFilter,java.lang.Object)&quot;&gt; &lt;code&gt;addNotificationListener&lt;/code&gt; &lt;/a&gt;と &lt;code&gt;ObjectName&lt;/code&gt; &lt;code&gt;ObjectName&lt;/code&gt; の&lt;a href=&quot;mbeanserverdelegate&quot;&gt; &lt;code&gt;MBeanServerDelegate&lt;/code&gt; のを&lt;/a&gt;。この &lt;code&gt;ObjectName&lt;/code&gt; は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="6757f09ba74310403e9527263bc5d5dd7e032018" translate="yes" xml:space="preserve">
          <source>When an MBean is registered or unregistered in the MBean server a &lt;a href=&quot;mbeanservernotification&quot;&gt;&lt;code&gt;MBeanServerNotification&lt;/code&gt;&lt;/a&gt; Notification is emitted. To register an object as listener to MBeanServerNotifications you should call the MBean server method &lt;a href=&quot;mbeanserver#addNotificationListener-javax.management.ObjectName-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt;&lt;code&gt;addNotificationListener&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;ObjectName&lt;/code&gt; the &lt;code&gt;ObjectName&lt;/code&gt; of the &lt;a href=&quot;mbeanserverdelegate&quot;&gt;&lt;code&gt;MBeanServerDelegate&lt;/code&gt;&lt;/a&gt;. This &lt;code&gt;ObjectName&lt;/code&gt; is:</source>
          <target state="translated">MBeanがMBeanサーバーに登録または登録解除されると、&lt;a href=&quot;mbeanservernotification&quot;&gt; &lt;code&gt;MBeanServerNotification&lt;/code&gt; &lt;/a&gt;通知が発行されます。MBeanServerNotificationsにリスナーとしてオブジェクトを登録するには、MBeanサーバーメソッドを呼び出す必要があり&lt;a href=&quot;mbeanserver#addNotificationListener-javax.management.ObjectName-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt; &lt;code&gt;addNotificationListener&lt;/code&gt; &lt;/a&gt;と &lt;code&gt;ObjectName&lt;/code&gt; &lt;code&gt;ObjectName&lt;/code&gt; の&lt;a href=&quot;mbeanserverdelegate&quot;&gt; &lt;code&gt;MBeanServerDelegate&lt;/code&gt; のを&lt;/a&gt;。この &lt;code&gt;ObjectName&lt;/code&gt; は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="182378d05279b361f0377c3dd82675fe9375ff7d" translate="yes" xml:space="preserve">
          <source>When an SSL handshake completes, new security parameters will have been established. Those parameters always include the security keys used to protect messages. They may also include parameters associated with a new &lt;em&gt;session&lt;/em&gt; such as authenticated peer identity and a new SSL cipher suite.</source>
          <target state="translated">SSLハンドシェイクが完了すると、新しいセキュリティパラメータが確立されます。これらのパラメータには、メッセージの保護に使用されるセキュリティキーが常に含まれています。また、認証されたピアIDや新しいSSL暗号スイートなど、新しい&lt;em&gt;セッションに&lt;/em&gt;関連付けられたパラメーターを含めることもできます。</target>
        </trans-unit>
        <trans-unit id="8ab2123a1562813d9a5533055c9f0e64f556bdbf" translate="yes" xml:space="preserve">
          <source>When an action is performed, editing is ended.</source>
          <target state="translated">アクションを行うと、編集を終了します。</target>
        </trans-unit>
        <trans-unit id="86ee98b1741c7d393fb679867d1afb4d7f15770b" translate="yes" xml:space="preserve">
          <source>When an agent is specified at JVM launch time this attribute specifies the agent class. That is, the class containing the &lt;code&gt;premain&lt;/code&gt; method. When an agent is specified at JVM launch time this attribute is required. If the attribute is not present the JVM will abort. Note: this is a class name, not a file name or path.</source>
          <target state="translated">JVM起動時にエージェントが指定されている場合、この属性はエージェントクラスを指定します。つまり、 &lt;code&gt;premain&lt;/code&gt; メソッドを含むクラスです。JVMの起動時にエージェントが指定されている場合、この属性は必須です。属性が存在しない場合、JVMは中止されます。注：これはクラス名であり、ファイル名やパスではありません。</target>
        </trans-unit>
        <trans-unit id="f644b84769be94f27ad2e7583fcb5ad584a687f8" translate="yes" xml:space="preserve">
          <source>When an applet is first created, an applet stub is attached to it using the applet's &lt;code&gt;setStub&lt;/code&gt; method. This stub serves as the interface between the applet and the browser environment or applet viewer environment in which the application is running.</source>
          <target state="translated">アプレットが最初に作成されると、アプレットの &lt;code&gt;setStub&lt;/code&gt; メソッドを使用してアプレットスタブがアタッチされます。このスタブは、アプレットと、アプリケーションが実行されているブラウザ環境またはアプレットビューア環境との間のインターフェイスとして機能します。</target>
        </trans-unit>
        <trans-unit id="bc9d555379c259dbd7e0e693ef8d791db7a25111" translate="yes" xml:space="preserve">
          <source>When an application adds two or more &lt;code&gt;RowSet&lt;/code&gt; objects to a &lt;code&gt;JoinRowSet&lt;/code&gt; object, the order of the indexes in the array is particularly important. Each index of the array maps directly to the corresponding index of the previously added &lt;code&gt;RowSet&lt;/code&gt; object. If overlap or underlap occurs, the match column data is maintained in the event an additional &lt;code&gt;Joinable&lt;/code&gt; RowSet is added and needs to relate to the match column data. Therefore, applications can set multiple match columns in any order, but this order has a direct effect on the outcome of the &lt;code&gt;SQL&lt;/code&gt; JOIN.</source>
          <target state="translated">アプリケーションが2つ以上の &lt;code&gt;RowSet&lt;/code&gt; オブジェクトを &lt;code&gt;JoinRowSet&lt;/code&gt; オブジェクトに追加する場合、配列内のインデックスの順序は特に重要です。配列の各インデックスは、以前に追加された &lt;code&gt;RowSet&lt;/code&gt; オブジェクトの対応するインデックスに直接マップされます。オーバーラップまたはアンダーラップが発生した場合、 &lt;code&gt;Joinable&lt;/code&gt; RowSetが追加され、一致列データに関連付ける必要がある場合に備えて、一致列データが維持されます。したがって、アプリケーションは複数の一致列を任意の順序で設定できますが、この順序はSQLJOINの結果に直接影響し &lt;code&gt;SQL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6004d4830cb9cc2c843dbf654b352672ce73e9de" translate="yes" xml:space="preserve">
          <source>When an application asks to place a character at the position (</source>
          <target state="translated">アプリケーションが位置に文字を配置するように要求してきた場合(</target>
        </trans-unit>
        <trans-unit id="9e03b89ff80e4bbb4d4255c8faad4eca56a28340" translate="yes" xml:space="preserve">
          <source>When an application calls a method that changes a row, such as the &lt;code&gt;CachedRowSet&lt;/code&gt; methods &lt;code&gt;insertRow&lt;/code&gt;, &lt;code&gt;updateRow&lt;/code&gt;, or &lt;code&gt;deleteRow&lt;/code&gt;, that method calls &lt;code&gt;notifyRowChanged&lt;/code&gt; internally. An application &lt;b&gt;should&lt;/b&gt; never invoke this method directly.</source>
          <target state="translated">アプリケーションが、 &lt;code&gt;CachedRowSet&lt;/code&gt; メソッドの &lt;code&gt;insertRow&lt;/code&gt; 、 &lt;code&gt;updateRow&lt;/code&gt; 、または &lt;code&gt;deleteRow&lt;/code&gt; などの行を変更するメソッドを呼び出すと、そのメソッドは &lt;code&gt;notifyRowChanged&lt;/code&gt; を内部的に呼び出します。アプリケーション&lt;b&gt;は、&lt;/b&gt;このメソッドを直接呼び出さないで&lt;b&gt;ください&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="c0cfa980c0a07be7b7ee79a3cef57eca20e01cc7" translate="yes" xml:space="preserve">
          <source>When an application calls a method to move the cursor, that method moves the cursor and then calls this method internally. An application &lt;b&gt;should&lt;/b&gt; never invoke this method directly.</source>
          <target state="translated">アプリケーションがメソッドを呼び出してカーソルを移動すると、そのメソッドはカーソルを移動してから、このメソッドを内部的に呼び出します。アプリケーション&lt;b&gt;は、&lt;/b&gt;このメソッドを直接呼び出さないで&lt;b&gt;ください&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="d78e161e7c07f3b2a15255e1f4967a9555bee575" translate="yes" xml:space="preserve">
          <source>When an application calls methods that change the entire contents of the &lt;code&gt;RowSet&lt;/code&gt; object, such as the &lt;code&gt;CachedRowSet&lt;/code&gt; methods &lt;code&gt;execute&lt;/code&gt;, &lt;code&gt;populate&lt;/code&gt;, &lt;code&gt;restoreOriginal&lt;/code&gt;, or &lt;code&gt;release&lt;/code&gt;, that method calls &lt;code&gt;notifyRowSetChanged&lt;/code&gt; internally (either directly or indirectly). An application &lt;b&gt;should&lt;/b&gt; never invoke this method directly.</source>
          <target state="translated">&lt;code&gt;CachedRowSet&lt;/code&gt; メソッドの &lt;code&gt;execute&lt;/code&gt; 、 &lt;code&gt;populate&lt;/code&gt; 、 &lt;code&gt;restoreOriginal&lt;/code&gt; 、 &lt;code&gt;release&lt;/code&gt; など、 &lt;code&gt;RowSet&lt;/code&gt; オブジェクトのコンテンツ全体を変更するメソッドをアプリケーションが呼び出すと、そのメソッドは &lt;code&gt;notifyRowSetChanged&lt;/code&gt; を内部的に（直接的または間接的に）呼び出します。アプリケーション&lt;b&gt;は、&lt;/b&gt;このメソッドを直接呼び出さないで&lt;b&gt;ください&lt;/b&gt;。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a36226b3193ab064f255bcf6893a6f62f93d1f4e" translate="yes" xml:space="preserve">
          <source>When an application calls the method &lt;code&gt;DataSource.getConnection&lt;/code&gt;, it gets back a &lt;code&gt;Connection&lt;/code&gt; object. If connection pooling is being done, that &lt;code&gt;Connection&lt;/code&gt; object is actually a handle to a &lt;code&gt;PooledConnection&lt;/code&gt; object, which is a physical connection.</source>
          <target state="translated">アプリケーションがメソッド &lt;code&gt;DataSource.getConnection&lt;/code&gt; を呼び出すと、 &lt;code&gt;Connection&lt;/code&gt; オブジェクトが返されます。接続プーリングが実行されている場合、その &lt;code&gt;Connection&lt;/code&gt; オブジェクトは、実際には物理接続である &lt;code&gt;PooledConnection&lt;/code&gt; オブジェクトへのハンドルです。</target>
        </trans-unit>
        <trans-unit id="7d4d70ec9b9f3f954ef0f33460a4d65e403bee71" translate="yes" xml:space="preserve">
          <source>When an application calls the method &lt;code&gt;PreparedStatement.setObject&lt;/code&gt;, the driver checks to see whether the value to be written is a UDT with a custom mapping. If it is, there will be an entry in a type map containing the &lt;code&gt;Class&lt;/code&gt; object for the class that implements &lt;code&gt;SQLData&lt;/code&gt; for this UDT. If the value to be written is an instance of &lt;code&gt;SQLData&lt;/code&gt;, the driver will create an instance of &lt;code&gt;SQLOutputImpl&lt;/code&gt; and pass it to the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt;. The method &lt;code&gt;writeSQL&lt;/code&gt; in turn calls the appropriate &lt;code&gt;SQLOutputImpl.writeXXX&lt;/code&gt; methods to write data from the &lt;code&gt;SQLData&lt;/code&gt; object to the &lt;code&gt;SQLOutputImpl&lt;/code&gt; output stream as the representation of an SQL user-defined type.</source>
          <target state="translated">アプリケーションがメソッド &lt;code&gt;PreparedStatement.setObject&lt;/code&gt; を呼び出すと、ドライバーは、書き込まれる値がカスタムマッピングを使用したUDTであるかどうかを確認します。そうである &lt;code&gt;SQLData&lt;/code&gt; 、このUDTのSQLDataを実装するクラスの &lt;code&gt;Class&lt;/code&gt; オブジェクトを含むエントリがタイプマップにあります。書き込まれる値が &lt;code&gt;SQLData&lt;/code&gt; のインスタンスである場合、ドライバーは &lt;code&gt;SQLOutputImpl&lt;/code&gt; のインスタンスを作成し、それをメソッド &lt;code&gt;SQLData.writeSQL&lt;/code&gt; に渡します。次に、メソッド &lt;code&gt;writeSQL&lt;/code&gt; は、適切な &lt;code&gt;SQLOutputImpl.writeXXX&lt;/code&gt; メソッドを呼び出して、 &lt;code&gt;SQLData&lt;/code&gt; オブジェクトから &lt;code&gt;SQLOutputImpl&lt;/code&gt; にデータを書き込みます。 SQLユーザー定義型の表現としての出力ストリーム。</target>
        </trans-unit>
        <trans-unit id="b7f5bb0538901d5f24c63eabe24a7b4f807abe0b" translate="yes" xml:space="preserve">
          <source>When an application calls the method &lt;code&gt;PreparedStatement.setObject&lt;/code&gt;, the driver checks to see whether the value to be written is a UDT with a custom mapping. If it is, there will be an entry in a type map containing the Class object for the class that implements &lt;code&gt;SQLData&lt;/code&gt; for this UDT. If the value to be written is an instance of &lt;code&gt;SQLData&lt;/code&gt;, the driver will create an instance of &lt;code&gt;SQLOutputImpl&lt;/code&gt; and pass it to the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt;. The method &lt;code&gt;writeSQL&lt;/code&gt; in turn calls the appropriate &lt;code&gt;SQLOutputImpl&lt;/code&gt; writer methods to write data from the &lt;code&gt;SQLData&lt;/code&gt; object to the &lt;code&gt;SQLOutputImpl&lt;/code&gt; output stream as the representation of an SQL user-defined type.</source>
          <target state="translated">アプリケーションがメソッド &lt;code&gt;PreparedStatement.setObject&lt;/code&gt; を呼び出すと、ドライバーは、書き込まれる値がカスタムマッピングを使用したUDTであるかどうかを確認します。そうである &lt;code&gt;SQLData&lt;/code&gt; 、このUDTのSQLDataを実装するクラスのClassオブジェクトを含むエントリがタイプマップにあります。書き込まれる値が &lt;code&gt;SQLData&lt;/code&gt; のインスタンスである場合、ドライバーは &lt;code&gt;SQLOutputImpl&lt;/code&gt; のインスタンスを作成し、それをメソッド &lt;code&gt;SQLData.writeSQL&lt;/code&gt; に渡します。次に、メソッド &lt;code&gt;writeSQL&lt;/code&gt; は、適切な &lt;code&gt;SQLOutputImpl&lt;/code&gt; ライターメソッドを呼び出して、 &lt;code&gt;SQLData&lt;/code&gt; オブジェクトから &lt;code&gt;SQLOutputImpl&lt;/code&gt; にデータを書き込みます。 SQLユーザー定義型の表現としての出力ストリーム。</target>
        </trans-unit>
        <trans-unit id="547bc639ed55a09b200965d2bc5a9106a8333ba6" translate="yes" xml:space="preserve">
          <source>When an application closes a connection, it calls the &lt;code&gt;Connection&lt;/code&gt; method &lt;code&gt;close&lt;/code&gt;. When connection pooling is being done, the connection pool manager is notified because it has registered itself as a &lt;code&gt;ConnectionEventListener&lt;/code&gt; object using the &lt;code&gt;ConnectionPool&lt;/code&gt; method &lt;code&gt;addConnectionEventListener&lt;/code&gt;. The connection pool manager deactivates the handle to the &lt;code&gt;PooledConnection&lt;/code&gt; object and returns the &lt;code&gt;PooledConnection&lt;/code&gt; object to the pool of connections so that it can be used again. Thus, when an application closes its connection, the underlying physical connection is recycled rather than being closed.</source>
          <target state="translated">アプリケーションが接続を閉じると、 &lt;code&gt;Connection&lt;/code&gt; メソッド &lt;code&gt;close&lt;/code&gt; を呼び出します。接続プーリングが行われているときのように自分自身を登録しているので、接続プールマネージャが通知される &lt;code&gt;ConnectionEventListener&lt;/code&gt; 使用してオブジェクト &lt;code&gt;ConnectionPool&lt;/code&gt; 方法 &lt;code&gt;addConnectionEventListener&lt;/code&gt; を。接続プールマネージャは、 &lt;code&gt;PooledConnection&lt;/code&gt; オブジェクトへのハンドルを非アクティブ化し、 &lt;code&gt;PooledConnection&lt;/code&gt; オブジェクトを接続のプールに返して、再度使用できるようにします。したがって、アプリケーションが接続を閉じると、基になる物理接続は閉じられるのではなくリサイクルされます。</target>
        </trans-unit>
        <trans-unit id="a52c11dc01aed368f150065ba6a405d66f8451bf" translate="yes" xml:space="preserve">
          <source>When an application creates a new client socket, the socket implementation factory's &lt;code&gt;createSocketImpl&lt;/code&gt; method is called to create the actual socket implementation.</source>
          <target state="translated">アプリケーションが新しいクライアントソケットを作成すると、ソケット実装ファクトリの &lt;code&gt;createSocketImpl&lt;/code&gt; メソッドが呼び出され、実際のソケット実装が作成されます。</target>
        </trans-unit>
        <trans-unit id="5070d5027d76071608fcfd8560f9541c493b061d" translate="yes" xml:space="preserve">
          <source>When an application creates a new datagram socket, the socket implementation factory's &lt;code&gt;createDatagramSocketImpl&lt;/code&gt; method is called to create the actual datagram socket implementation.</source>
          <target state="translated">アプリケーションが新しいデータグラムソケットを作成すると、ソケット実装ファクトリの &lt;code&gt;createDatagramSocketImpl&lt;/code&gt; メソッドが呼び出され、実際のデータグラムソケット実装が作成されます。</target>
        </trans-unit>
        <trans-unit id="53f882e0daa369f43672720af27805bcd63f9c59" translate="yes" xml:space="preserve">
          <source>When an application creates a new server socket, the socket implementation factory's &lt;code&gt;createSocketImpl&lt;/code&gt; method is called to create the actual socket implementation.</source>
          <target state="translated">アプリケーションが新しいサーバーソケットを作成すると、ソケット実装ファクトリの &lt;code&gt;createSocketImpl&lt;/code&gt; メソッドが呼び出され、実際のソケット実装が作成されます。</target>
        </trans-unit>
        <trans-unit id="d3c0e2a071e7ad4e860991ae113034c7a8699231" translate="yes" xml:space="preserve">
          <source>When an application is deployed, it will generally have several codebase directories and JARs in its classpath. JNDI locates (using &lt;a href=&quot;../../../java.base/java/lang/classloader#getResources(java.lang.String)&quot;&gt;&lt;code&gt;ClassLoader.getResources()&lt;/code&gt;&lt;/a&gt;) all &lt;em&gt;application resource files&lt;/em&gt; named &lt;code&gt;jndi.properties&lt;/code&gt; in the classpath. In addition, if the Java installation directory contains a built-in properties file, typically &lt;code&gt;conf/jndi.properties&lt;/code&gt;, JNDI treats it as an additional application resource file. All of the properties contained in these files are placed into the environment of the initial context. This environment is then inherited by other contexts.</source>
          <target state="translated">アプリケーションがデプロイされると、通常、クラスパスに複数のコードベースディレクトリとJARが含まれます。 JNDIは、（&lt;a href=&quot;../../../java.base/java/lang/classloader#getResources(java.lang.String)&quot;&gt; &lt;code&gt;ClassLoader.getResources()&lt;/code&gt; &lt;/a&gt;を使用して）クラスパス内の &lt;code&gt;jndi.properties&lt;/code&gt; という名前のすべての&lt;em&gt;アプリケーションリソースファイル&lt;/em&gt;を検索します。さらに、Javaインストールディレクトリに組み込みのプロパティファイル（通常は &lt;code&gt;conf/jndi.properties&lt;/code&gt; ）が含まれている場合、JNDIはそれを追加のアプリケーションリソースファイルとして扱います。これらのファイルに含まれるすべてのプロパティは、初期コンテキストの環境に配置されます。この環境は、他のコンテキストに継承されます。</target>
        </trans-unit>
        <trans-unit id="6192da6041396e436b94b26592fc040462f804dd" translate="yes" xml:space="preserve">
          <source>When an application is deployed, it will generally have several codebase directories and JARs in its classpath. Similarly, when an applet is deployed, it will have a codebase and archives specifying where to find the applet's classes. JNDI locates (using &lt;a href=&quot;../../java/lang/classloader#getResources-java.lang.String-&quot;&gt;&lt;code&gt;&lt;code&gt;ClassLoader.getResources()&lt;/code&gt;&lt;/code&gt;&lt;/a&gt;) all &lt;em&gt;application resource files&lt;/em&gt; named &lt;code&gt;jndi.properties&lt;/code&gt; in the classpath. In addition, if the file</source>
          <target state="translated">アプリケーションがデプロイされると、通常、クラスパスにいくつかのコードベースディレクトリとJARが含まれます。同様に、アプレットが配備されると、アプレットのクラスを見つける場所を指定するコードベースとアーカイブが含まれます。 JNDIは（&lt;a href=&quot;../../java/lang/classloader#getResources-java.lang.String-&quot;&gt; &lt;code&gt;&lt;code&gt;ClassLoader.getResources()&lt;/code&gt;&lt;/code&gt; &lt;/a&gt;を使用して）クラスパスで &lt;code&gt;jndi.properties&lt;/code&gt; という名前のすべての&lt;em&gt;アプリケーションリソースファイル&lt;/em&gt;を見つけます。さらに、ファイル</target>
        </trans-unit>
        <trans-unit id="ca3e625936706dd988b4e97b8710fc50248f15ec" translate="yes" xml:space="preserve">
          <source>When an attribute list is supplied as part of a &lt;a href=&quot;documenthandler#startElement(java.lang.String,org.xml.sax.AttributeList)&quot;&gt;&lt;code&gt;startElement&lt;/code&gt;&lt;/a&gt; event, the list will return valid results only during the scope of the event; once the event handler returns control to the parser, the attribute list is invalid. To save a persistent copy of the attribute list, use the SAX1 &lt;a href=&quot;helpers/attributelistimpl&quot;&gt;&lt;code&gt;AttributeListImpl&lt;/code&gt;&lt;/a&gt; helper class.</source>
          <target state="translated">属性リストが&lt;a href=&quot;documenthandler#startElement(java.lang.String,org.xml.sax.AttributeList)&quot;&gt; &lt;code&gt;startElement&lt;/code&gt; &lt;/a&gt;イベントの一部として提供される場合、リストはイベントのスコープ中にのみ有効な結果を返します。イベントハンドラーが制御をパーサーに戻すと、属性リストは無効になります。属性リストの持続的なコピーを保存するには、SAX1使用&lt;a href=&quot;helpers/attributelistimpl&quot;&gt; &lt;code&gt;AttributeListImpl&lt;/code&gt; &lt;/a&gt;ヘルパークラスを。</target>
        </trans-unit>
        <trans-unit id="5ff3262456581061805ec48c0da1d47a0d84ee27" translate="yes" xml:space="preserve">
          <source>When an event is dispatched to a listener, the listener method (such as &lt;code&gt;objectChanged()&lt;/code&gt;) may be executed in a thread other than the one in which the call to &lt;code&gt;addNamingListener()&lt;/code&gt; was executed. The choice of which thread to use is made by the service provider. When an event is dispatched to multiple listeners, the service provider may choose (and is generally encouraged) to execute the listener methods concurrently in separate threads.</source>
          <target state="translated">イベントがリスナーにディスパッチされたときに、（例えば、リスナー方法 &lt;code&gt;objectChanged()&lt;/code&gt; ）をコールしたもの以外のスレッドで実行されてもよい &lt;code&gt;addNamingListener()&lt;/code&gt; 実行されました。使用するスレッドの選択は、サービスプロバイダーが行います。イベントが複数のリスナーにディスパッチされる場合、サービスプロバイダーは、リスナーメソッドを別々のスレッドで同時に実行することを選択できます（一般的に推奨されます）。</target>
        </trans-unit>
        <trans-unit id="c246ece3865225c2043f5d0d8ebe7428a4313f31" translate="yes" xml:space="preserve">
          <source>When an event is reported to indicate that a file in a watched directory has been modified then there is no guarantee that the program (or programs) that have modified the file have completed. Care should be taken to coordinate access with other programs that may be updating the file. The &lt;a href=&quot;../channels/filechannel&quot;&gt;&lt;code&gt;FileChannel&lt;/code&gt;&lt;/a&gt; class defines methods to lock regions of a file against access by other programs.</source>
          <target state="translated">監視対象ディレクトリ内のファイルが変更されたことを示すイベントが報告された場合、ファイルを変更した1つまたは複数のプログラムが完了した保証はありません。ファイルを更新している可能性のある他のプログラムとのアクセスを調整するように注意する必要があります。&lt;a href=&quot;../channels/filechannel&quot;&gt; &lt;code&gt;FileChannel&lt;/code&gt; &lt;/a&gt;クラスは、他のプログラムによるアクセスに対してファイルのロック領域にメソッドを定義します。</target>
        </trans-unit>
        <trans-unit id="bf730b9455534606824acbf9cbbe082f2399a34d" translate="yes" xml:space="preserve">
          <source>When an event occurs on a &lt;code&gt;RowSet&lt;/code&gt; object, one of the &lt;code&gt;RowSetListener&lt;/code&gt; methods will be sent to all registered listeners to notify them of the event. An &lt;code&gt;Event&lt;/code&gt; object is supplied to the &lt;code&gt;RowSetListener&lt;/code&gt; method so that the listener can use it to find out which &lt;code&gt;RowSet&lt;/code&gt; object is the source of the event.</source>
          <target state="translated">&lt;code&gt;RowSet&lt;/code&gt; オブジェクトでイベントが発生すると、 &lt;code&gt;RowSetListener&lt;/code&gt; メソッドの1つが、登録されているすべてのリスナーに送信され、イベントが通知されます。 &lt;code&gt;Event&lt;/code&gt; オブジェクトはに供給される &lt;code&gt;RowSetListener&lt;/code&gt; のリスナーがいるかを見つけるためにそれを使用できるようにする方法 &lt;code&gt;RowSet&lt;/code&gt; オブジェクトがイベントのソースです。</target>
        </trans-unit>
        <trans-unit id="46c3263910b048a89e5d5d0939bdd2c5ae531805" translate="yes" xml:space="preserve">
          <source>When an exception is thrown by a factory, the exception is passed on to the caller of &lt;code&gt;DirectoryManager.getStateToBind()&lt;/code&gt;. The search for other factories that may produce a non-null answer is halted. A factory should only throw an exception if it is sure that it is the only intended factory and that no other factories should be tried. If this factory cannot create an object using the arguments supplied, it should return null.</source>
          <target state="translated">ファクトリによって例外がスローされると、例外は &lt;code&gt;DirectoryManager.getStateToBind()&lt;/code&gt; の呼び出し元に渡されます。 null以外の回答を生成する可能性のある他のファクトリの検索は中止されます。ファクトリは、それが唯一の意図されたファクトリであり、他のファクトリを試してはならないことが確実な場合にのみ、例外をスローする必要があります。このファクトリが提供された引数を使用してオブジェクトを作成できない場合は、nullを返す必要があります。</target>
        </trans-unit>
        <trans-unit id="86e9ee1cb6edb165bdea53c864741fcfebb100c1" translate="yes" xml:space="preserve">
          <source>When an exception is thrown by a factory, the exception is passed on to the caller of &lt;code&gt;NamingManager.getStateToBind()&lt;/code&gt; and &lt;code&gt;DirectoryManager.getStateToBind()&lt;/code&gt;. The search for other factories that may produce a non-null answer is halted. A factory should only throw an exception if it is sure that it is the only intended factory and that no other factories should be tried. If this factory cannot create an object using the arguments supplied, it should return null.</source>
          <target state="translated">ファクトリによって例外がスローされると、例外は &lt;code&gt;NamingManager.getStateToBind()&lt;/code&gt; および &lt;code&gt;DirectoryManager.getStateToBind()&lt;/code&gt; の呼び出し元に渡されます。 null以外の回答を生成する可能性のある他のファクトリの検索は中止されます。ファクトリは、それが唯一の意図されたファクトリであり、他のファクトリを試してはならないことが確実な場合にのみ、例外をスローする必要があります。このファクトリが提供された引数を使用してオブジェクトを作成できない場合は、nullを返す必要があります。</target>
        </trans-unit>
        <trans-unit id="f619bd42e631fde289b18b2557593f0674f15c8e" translate="yes" xml:space="preserve">
          <source>When an exception is thrown by an object factory, the exception is passed on to the caller of &lt;code&gt;DirectoryManager.getObjectInstance()&lt;/code&gt;. The search for other factories that may produce a non-null answer is halted. An object factory should only throw an exception if it is sure that it is the only intended factory and that no other object factories should be tried. If this factory cannot create an object using the arguments supplied, it should return null.</source>
          <target state="translated">オブジェクトファクトリによって例外がスローされると、例外は &lt;code&gt;DirectoryManager.getObjectInstance()&lt;/code&gt; の呼び出し元に渡されます。null以外の回答を生成する可能性のある他のファクトリの検索は中止されます。オブジェクトファクトリは、それが唯一の意図されたファクトリであり、他のオブジェクトファクトリを試してはならないことが確実な場合にのみ、例外をスローする必要があります。このファクトリが提供された引数を使用してオブジェクトを作成できない場合は、nullを返す必要があります。</target>
        </trans-unit>
        <trans-unit id="92d645b31af0488c8796e3e157fa1f6cd126e2c8" translate="yes" xml:space="preserve">
          <source>When an implementation supports operations on entries in the directory that execute in a race-free manner then the returned directory stream is a &lt;a href=&quot;securedirectorystream&quot;&gt;&lt;code&gt;SecureDirectoryStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">実装が競合のない方法で実行されるディレクトリのエントリに対する操作をサポートする場合、返されるディレクトリストリームは&lt;a href=&quot;securedirectorystream&quot;&gt; &lt;code&gt;SecureDirectoryStream&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="2052382560398859691564bf3c293b964fc894ad" translate="yes" xml:space="preserve">
          <source>When an input source is set (using the &lt;code&gt;setInput&lt;/code&gt; method), it may be marked as &quot;seek forward only&quot;. This setting means that images contained within the input source will only be read in order, possibly allowing the reader to avoid caching portions of the input containing data associated with images that have been read previously.</source>
          <target state="translated">入力ソースが（ &lt;code&gt;setInput&lt;/code&gt; メソッドを使用して）設定されると、「シークフォワードのみ」としてマークされる場合があります。この設定は、入力ソース内に含まれる画像が順番に読み取られるだけであることを意味し、リーダーは、以前に読み取られた画像に関連付けられたデータを含む入力の部分をキャッシュしないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="7d2fac9efec8951293a4b9ad29501c8bcc43c755" translate="yes" xml:space="preserve">
          <source>When an instance of this class is used as a delegate for the implementation of the BeanContext protocols (and its subprotocols) there exists a 'chicken and egg' problem during deserialization</source>
          <target state="translated">このクラスのインスタンスがBeanContextプロトコル(およびそのサブプロトコル)の実装のためのデリゲートとして使用される場合,デシリアライゼーションの間に「鶏と卵」の問題が存在します.</target>
        </trans-unit>
        <trans-unit id="f93de7fe2101ac2a970987b76df77b95b8fe1afa" translate="yes" xml:space="preserve">
          <source>When an interior node in the namespace tree has been renamed, the topmost node which is part of the listener's scope should used to generate a rename event. The extent to which this can be supported is provider-specific. For example, a service might generate rename notifications for all descendants of the changed interior node and the corresponding provider might not be able to prevent those notifications from being propagated to the listeners.</source>
          <target state="translated">名前空間ツリーの内部ノードがリネームされた場合、リスナーのスコープに含まれる最上位のノードを使用してリネームイベントを生成する必要があります。これをどこまでサポートできるかはプロバイダごとに異なります。例えば、サービスは変更された内部ノードのすべての子孫に対してリネーム通知を生成し、対応するプロバイダはそれらの通知がリスナーに伝搬するのを防ぐことができないかもしれません。</target>
        </trans-unit>
        <trans-unit id="fd4237ea9c386be63cd7b4f69745e762d3518611" translate="yes" xml:space="preserve">
          <source>When an item is selected or deselected by the user, AWT sends an instance of &lt;code&gt;ItemEvent&lt;/code&gt; to the list. When the user double-clicks on an item in a scrolling list, AWT sends an instance of &lt;code&gt;ActionEvent&lt;/code&gt; to the list following the item event. AWT also generates an action event when the user presses the return key while an item in the list is selected.</source>
          <target state="translated">ユーザーがアイテムを選択または選択解除すると、AWTは &lt;code&gt;ItemEvent&lt;/code&gt; のインスタンスをリストに送信します。ユーザーがスクロールリスト内のアイテムをダブルクリックすると、AWTはアイテムイベントに続いて &lt;code&gt;ActionEvent&lt;/code&gt; のインスタンスをリストに送信します。 AWTは、リスト内の項目が選択されているときにユーザーがReturnキーを押すと、アクションイベントも生成します。</target>
        </trans-unit>
        <trans-unit id="e732ae7cab683d25453439abc7257c33de065d2b" translate="yes" xml:space="preserve">
          <source>When an item's state changes, editing is ended.</source>
          <target state="translated">アイテムの状態が変わると編集を終了します。</target>
        </trans-unit>
        <trans-unit id="fbb2b60ef4c108dabfab274ea6d643ccbd813a96" translate="yes" xml:space="preserve">
          <source>When an m-let text file is loaded, an instance of each MBean specified in the file is created and registered.</source>
          <target state="translated">m-let テキストファイルを読み込むと、そのファイルで指定された MBean のインスタンスが生成され、登録されます。</target>
        </trans-unit>
        <trans-unit id="a6d8aaee8e31c5a9c8176090117cbab7f1fb2776" translate="yes" xml:space="preserve">
          <source>When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used to create a thread, starting the thread causes the object's &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing thread.</source>
          <target state="translated">オブジェクト実装インターフェースの &lt;code&gt;Runnable&lt;/code&gt; を使用してスレッドを作成する場合、スレッドを開始すると、オブジェクトの &lt;code&gt;run&lt;/code&gt; メソッドがその個別に実行されているスレッドで呼び出されます。</target>
        </trans-unit>
        <trans-unit id="d44aeda78b237a6dbd1402c72d9234eba39323f7" translate="yes" xml:space="preserve">
          <source>When an object is registered in the MBean Server using the &lt;code&gt;registerMBean&lt;/code&gt; or &lt;code&gt;createMBean&lt;/code&gt; methods of the &lt;a href=&quot;mbeanserver&quot;&gt;&lt;code&gt;MBeanServer&lt;/code&gt;&lt;/a&gt; interface, the object's class is examined to determine what type of MBean it is:</source>
          <target state="translated">&lt;a href=&quot;mbeanserver&quot;&gt; &lt;code&gt;MBeanServer&lt;/code&gt; &lt;/a&gt;インターフェースの &lt;code&gt;registerMBean&lt;/code&gt; メソッドまたは &lt;code&gt;createMBean&lt;/code&gt; メソッドを使用してオブジェクトがMBeanサーバーに登録されると、オブジェクトのクラスが調べられ、MBeanのタイプが判別されます。</target>
        </trans-unit>
        <trans-unit id="c2972251c7a28b4528fe63074ce4c9c1bf8739a3" translate="yes" xml:space="preserve">
          <source>When an object named &quot;x/y&quot; is subsequently deleted, the corresponding &lt;code&gt;NamingEvent&lt;/code&gt; (&lt;code&gt;evt&lt;/code&gt;) must contain:</source>
          <target state="translated">「x / y」という名前のオブジェクトが後で削除される場合、対応する &lt;code&gt;NamingEvent&lt;/code&gt; （ &lt;code&gt;evt&lt;/code&gt; ）には以下が含まれている必要があります。</target>
        </trans-unit>
        <trans-unit id="4d30c71c9ef35dac87516151638b387d22978a40" translate="yes" xml:space="preserve">
          <source>When an object of a class implementing the interface &lt;code&gt;SQLData&lt;/code&gt; is passed as an argument to an SQL statement, the JDBC driver calls the method &lt;code&gt;SQLData.getSQLType&lt;/code&gt; to determine the kind of SQL datum being passed to the database. The driver then creates an instance of &lt;code&gt;SQLOutput&lt;/code&gt; and passes it to the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt;. The method &lt;code&gt;writeSQL&lt;/code&gt; in turn calls the appropriate &lt;code&gt;SQLOutput&lt;/code&gt;</source>
          <target state="translated">インターフェイス &lt;code&gt;SQLData&lt;/code&gt; を実装するクラスのオブジェクトが引数としてSQLステートメントに渡されると、JDBCドライバーはメソッド &lt;code&gt;SQLData.getSQLType&lt;/code&gt; を呼び出して、データベースに渡されるSQLデータの種類を判別します。次に、ドライバーは &lt;code&gt;SQLOutput&lt;/code&gt; のインスタンスを作成し、それをメソッド &lt;code&gt;SQLData.writeSQL&lt;/code&gt; に渡します。次に、 &lt;code&gt;writeSQL&lt;/code&gt; メソッドは適切な &lt;code&gt;SQLOutput&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="918b1ed8da41a8cca49ec39767c9d3ef9075b75b" translate="yes" xml:space="preserve">
          <source>When an observable object is newly created, its set of observers is empty. Two observers are considered the same if and only if the &lt;code&gt;equals&lt;/code&gt; method returns true for them.</source>
          <target state="translated">監視可能なオブジェクトが新しく作成されると、そのオブザーバーのセットは空になります。 &lt;code&gt;equals&lt;/code&gt; メソッドがtrueを返す場合に限り、2人のオブザーバーは同じと見なされます。</target>
        </trans-unit>
        <trans-unit id="784d4ec1dda97713a3424a2f8d9aa99d1febb449" translate="yes" xml:space="preserve">
          <source>When an observed attribute crosses the high threshold, if the &lt;em&gt;notify high&lt;/em&gt; flag is true, then a notification is sent. Subsequent crossings of the high threshold value will not trigger further notifications until the gauge value becomes less than or equal to the low threshold.</source>
          <target state="translated">監視対象の属性が上限しきい値を超えたときに、上限&lt;em&gt;通知&lt;/em&gt;フラグがtrueの場合、通知が送信されます。その後、高しきい値を超えても、ゲージ値が低しきい値以下になるまで、通知はトリガーされません。</target>
        </trans-unit>
        <trans-unit id="1f5d6ec3eb5a523cc7305bf106145613183ee461" translate="yes" xml:space="preserve">
          <source>When an observed attribute crosses the low threshold, if the &lt;em&gt;notify low&lt;/em&gt; flag is true, then a notification is sent. Subsequent crossings of the low threshold value will not trigger further notifications until the gauge value becomes greater than or equal to the high threshold.</source>
          <target state="translated">監視対象の属性が下限しきい値を超えたときに、下限&lt;em&gt;通知&lt;/em&gt;フラグがtrueの場合、通知が送信されます。その後、下限しきい値を超えても、ゲージ値が上限しきい値以上になるまで、通知はトリガーされません。</target>
        </trans-unit>
        <trans-unit id="8376d748bc3d8b953550a26d5a316d63742f727e" translate="yes" xml:space="preserve">
          <source>When an output device is stopped, the device usually indicates its condition in human readable form locally at the device. A client can obtain more complete device status remotely by querying the printer's &lt;a href=&quot;printerstate&quot;&gt;&lt;code&gt;PrinterState&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;printerstatereasons&quot;&gt;&lt;code&gt;PrinterStateReasons&lt;/code&gt;&lt;/a&gt; attributes.</source>
          <target state="translated">出力デバイスが停止すると、デバイスは通常、その状態を人間が読める形式でデバイスのローカルに示します。クライアントは、プリンターの&lt;a href=&quot;printerstate&quot;&gt; &lt;code&gt;PrinterState&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;printerstatereasons&quot;&gt; &lt;code&gt;PrinterStateReasons&lt;/code&gt; &lt;/a&gt;属性を照会することにより、リモートでより完全なデバイスステータスを取得できます。</target>
        </trans-unit>
        <trans-unit id="147224cc677f556536d5eca49857d3c86cec24ef" translate="yes" xml:space="preserve">
          <source>When associating an object to a key on a node using &lt;code&gt;Node.setUserData()&lt;/code&gt; the application can provide a handler that gets called when the node the object is associated to is being cloned, imported, or renamed.</source>
          <target state="translated">&lt;code&gt;Node.setUserData()&lt;/code&gt; を使用してオブジェクトをノード上のキーに関連付ける場合、アプリケーションは、オブジェクトが関連付けられているノードが複製、インポート、または名前変更されているときに呼び出されるハンドラーを提供できます。</target>
        </trans-unit>
        <trans-unit id="2d8993fa1903e158d7bbd09f3a46e487c5d7d23f" translate="yes" xml:space="preserve">
          <source>When associating an object to a key on a node using &lt;code&gt;Node.setUserData()&lt;/code&gt; the application can provide a handler that gets called when the node the object is associated to is being cloned, imported, or renamed. This can be used by the application to implement various behaviors regarding the data it associates to the DOM nodes. This interface defines that handler.</source>
          <target state="translated">&lt;code&gt;Node.setUserData()&lt;/code&gt; を使用してオブジェクトをノード上のキーに関連付ける場合、アプリケーションは、オブジェクトが関連付けられているノードが複製、インポート、または名前変更されているときに呼び出されるハンドラーを提供できます。これは、アプリケーションがDOMノードに関連付けるデータに関するさまざまな動作を実装するために使用できます。このインターフェースはそのハンドラーを定義します。</target>
        </trans-unit>
        <trans-unit id="18f4b7b2881c180a5a41a1bfe21bf07fe45c228a" translate="yes" xml:space="preserve">
          <source>When automatic drag handling is enabled, most look and feels begin a drag-and-drop operation when the user presses the mouse button over the preview panel. Some look and feels might not support automatic drag and drop; they will ignore this property. You can work around such look and feels by modifying the component to directly call the &lt;code&gt;exportAsDrag&lt;/code&gt; method of a &lt;code&gt;TransferHandler&lt;/code&gt;.</source>
          <target state="translated">自動ドラッグ処理が有効になっている場合、ほとんどのルックアンドフィールは、ユーザーがプレビューパネル上でマウスボタンを押すとドラッグアンドドロップ操作を開始します。一部のルックアンドフィールは、自動ドラッグアンドドロップをサポートしていない場合があります。彼らはこのプロパティを無視します。 &lt;code&gt;TransferHandler&lt;/code&gt; の &lt;code&gt;exportAsDrag&lt;/code&gt; メソッドを直接呼び出すようにコンポーネントを変更することで、このようなルックアンドフィールを回避できます。</target>
        </trans-unit>
        <trans-unit id="8a5f68a5a8fdb6dc2c715dafb047525f1aa4d5b6" translate="yes" xml:space="preserve">
          <source>When automatic drag handling is enabled, most look and feels begin a drag-and-drop operation whenever the user presses the mouse button over an item and then moves the mouse a few pixels. Setting this property to &lt;code&gt;true&lt;/code&gt; can therefore have a subtle effect on how selections behave.</source>
          <target state="translated">自動ドラッグ処理が有効になっている場合、ほとんどのルックアンドフィールは、ユーザーがアイテム上でマウスボタンを押してからマウスを数ピクセル動かすたびに、ドラッグアンドドロップ操作を開始します。したがって、このプロパティを &lt;code&gt;true&lt;/code&gt; に設定すると、選択の動作に微妙な影響を与える可能性があります。</target>
        </trans-unit>
        <trans-unit id="8eb0988bb2d24757a9d15f5c99e1e1f5bc8136ae" translate="yes" xml:space="preserve">
          <source>When automatic redirection occurs, the request method of the redirected request may be modified depending on the specific &lt;code&gt;30X&lt;/code&gt; status code, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt; RFC 7231&lt;/a&gt;. In addition, the &lt;code&gt;301&lt;/code&gt; and &lt;code&gt;302&lt;/code&gt; status codes cause a &lt;code&gt;POST&lt;/code&gt; request to be converted to a &lt;code&gt;GET&lt;/code&gt; in the redirected request.</source>
          <target state="translated">自動リダイレクトが発生すると、&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231で&lt;/a&gt;指定されているように、リダイレクトされた要求の要求方法が特定の &lt;code&gt;30X&lt;/code&gt; ステータスコードに応じて変更される場合があります。さらに、 &lt;code&gt;301&lt;/code&gt; および &lt;code&gt;302&lt;/code&gt; ステータスコードにより、 &lt;code&gt;POST&lt;/code&gt; リクエストはリダイレクトされたリクエストで &lt;code&gt;GET&lt;/code&gt; に変換されます。</target>
        </trans-unit>
        <trans-unit id="cf1414265b010571580fbf696282e71d50cfa5f8" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;lockedMonitors&lt;/code&gt; and &lt;code&gt;lockedSynchronizers&lt;/code&gt; parameters are &lt;code&gt;false&lt;/code&gt;, it is equivalent to calling:</source>
          <target state="translated">&lt;code&gt;lockedSynchronizers&lt;/code&gt; パラメータとlockedSynchronizersパラメータの両方が &lt;code&gt;false&lt;/code&gt; の場合、 &lt;code&gt;lockedMonitors&lt;/code&gt; 呼び出しと同等です。</target>
        </trans-unit>
        <trans-unit id="b0e8b092db7bbf9a9c972f6aa3306da587cceac0" translate="yes" xml:space="preserve">
          <source>When both the number of rows and the number of columns have been set to non-zero values, either by a constructor or by the &lt;code&gt;setRows&lt;/code&gt; and &lt;code&gt;setColumns&lt;/code&gt; methods, the number of columns specified is ignored. Instead, the number of columns is determined from the specified number of rows and the total number of components in the layout. So, for example, if three rows and two columns have been specified and nine components are added to the layout, they will be displayed as three rows of three columns. Specifying the number of columns affects the layout only when the number of rows is set to zero.</source>
          <target state="translated">行数と列の数の両方が、コンストラクタによって、またはいずれかによって、非ゼロの値に設定されている場合 &lt;code&gt;setRows&lt;/code&gt; と &lt;code&gt;setColumns&lt;/code&gt; 方法、指定された列の数は無視されます。代わりに、列の数は、指定された行数とレイアウト内のコンポーネントの総数から決定されます。したがって、たとえば、3行2列が指定され、9つのコンポーネントがレイアウトに追加された場合、それらは3列3行として表示されます。列数の指定は、行数がゼロに設定されている場合にのみレイアウトに影響します。</target>
        </trans-unit>
        <trans-unit id="3bb6d7fddd6b84f1b1c496762483d19e659acc05" translate="yes" xml:space="preserve">
          <source>When cached value was set.</source>
          <target state="translated">キャッシュされた値が設定されていた場合</target>
        </trans-unit>
        <trans-unit id="045851de97f115ee864c6b5dbe8a118c8574969c" translate="yes" xml:space="preserve">
          <source>When called by the printing system the &lt;code&gt;Printable&lt;/code&gt; must inspect and honour the supplied PageFormat parameter as well as the page index. The format of the page to be drawn is specified by the supplied PageFormat. The size, orientation and imageable area of the page is therefore already determined and rendering must be within this imageable area. This is key to correct printing behaviour, and it has the implication that the client has the responsibility of tracking what content belongs on the specified page.</source>
          <target state="translated">印刷システムによって呼び出された場合、 &lt;code&gt;Printable&lt;/code&gt; は、提供されたPageFormatパラメータとページインデックスを検査して尊重する必要があります。描画されるページのフォーマットは、提供されたPageFormatによって指定されます。したがって、ページのサイズ、向き、および画像化可能な領域はすでに決定されており、レンダリングはこの画像化可能な領域内にある必要があります。これは、印刷動作​​を修正するための鍵であり、指定されたページに属するコンテンツをクライアントが追跡する責任があることを意味します。</target>
        </trans-unit>
        <trans-unit id="ce13d27b64835af608fbc58b333cc41ac2796b65" translate="yes" xml:space="preserve">
          <source>When called off the</source>
          <target state="translated">呼び捨てにした場合</target>
        </trans-unit>
        <trans-unit id="866ffa00bf7dcbeb92203e393cd8afd478ae5220" translate="yes" xml:space="preserve">
          <source>When called with &lt;a href=&quot;#invokeExact(java.lang.Object...)&quot;&gt;&lt;code&gt;invokeExact&lt;/code&gt;&lt;/a&gt;, the adapter invokes the target with no argument changes. (&lt;em&gt;Note:&lt;/em&gt; This behavior is different from a &lt;a href=&quot;#asCollector(java.lang.Class,int)&quot;&gt;fixed arity collector&lt;/a&gt;, since it accepts a whole array of indeterminate length, rather than a fixed number of arguments.)</source>
          <target state="translated">&lt;a href=&quot;#invokeExact(java.lang.Object...)&quot;&gt; &lt;code&gt;invokeExact&lt;/code&gt; &lt;/a&gt;を使用して呼び出されると、アダプターは引数を変更せずにターゲットを呼び出します。（&lt;em&gt;注：&lt;/em&gt;この動作は、固定数の引数ではなく、不確定な長さの配列全体を受け入れるため、&lt;a href=&quot;#asCollector(java.lang.Class,int)&quot;&gt;固定アリティコレクター&lt;/a&gt;とは異なります。）</target>
        </trans-unit>
        <trans-unit id="b53c0fffa0b51e47d71e7136baf9352bd22f9aa3" translate="yes" xml:space="preserve">
          <source>When called with &lt;a href=&quot;methodhandle#invokeExact-java.lang.Object...-&quot;&gt;&lt;code&gt;invokeExact&lt;/code&gt;&lt;/a&gt;, the adapter invokes the target with no argument changes. (&lt;em&gt;Note:&lt;/em&gt; This behavior is different from a &lt;a href=&quot;methodhandle#asCollector-java.lang.Class-int-&quot;&gt;fixed arity collector&lt;/a&gt;, since it accepts a whole array of indeterminate length, rather than a fixed number of arguments.)</source>
          <target state="translated">&lt;a href=&quot;methodhandle#invokeExact-java.lang.Object...-&quot;&gt; &lt;code&gt;invokeExact&lt;/code&gt; &lt;/a&gt;で呼び出されると、アダプターは引数を変更せずにターゲットを呼び出します。（&lt;em&gt;注：&lt;/em&gt;この動作は、固定数の引数ではなく、長さが不定の配列全体を受け入れるため、&lt;a href=&quot;methodhandle#asCollector-java.lang.Class-int-&quot;&gt;固定アリティコレクター&lt;/a&gt;とは異なります。）</target>
        </trans-unit>
        <trans-unit id="31883d2c4cae1cb71309d37302c9eb9553a801df" translate="yes" xml:space="preserve">
          <source>When called with plain, inexact &lt;a href=&quot;#invoke(java.lang.Object...)&quot;&gt;&lt;code&gt;invoke&lt;/code&gt;&lt;/a&gt;, if the caller type is the same as the adapter, the adapter invokes the target as with &lt;code&gt;invokeExact&lt;/code&gt;. (This is the normal behavior for &lt;code&gt;invoke&lt;/code&gt; when types match.)</source>
          <target state="translated">プレーンで不正確な&lt;a href=&quot;#invoke(java.lang.Object...)&quot;&gt; &lt;code&gt;invoke&lt;/code&gt; を使用して&lt;/a&gt;呼び出された場合、呼び出し元のタイプがアダプターと同じである場合、アダプターは、 &lt;code&gt;invokeExact&lt;/code&gt; の場合と同様にターゲットを呼び出します。（これは、タイプが一致する場合の &lt;code&gt;invoke&lt;/code&gt; の通常の動作です。）</target>
        </trans-unit>
        <trans-unit id="4a0161ca009c0dbbc06ce2b6680929152732b54d" translate="yes" xml:space="preserve">
          <source>When called with plain, inexact &lt;a href=&quot;methodhandle#invoke-java.lang.Object...-&quot;&gt;&lt;code&gt;invoke&lt;/code&gt;&lt;/a&gt;, if the caller type is the same as the adapter, the adapter invokes the target as with &lt;code&gt;invokeExact&lt;/code&gt;. (This is the normal behavior for &lt;code&gt;invoke&lt;/code&gt; when types match.)</source>
          <target state="translated">単純な不正確な&lt;a href=&quot;methodhandle#invoke-java.lang.Object...-&quot;&gt; &lt;code&gt;invoke&lt;/code&gt; &lt;/a&gt;で呼び出された場合、呼び出し元のタイプがアダプターと同じである場合、アダプターは &lt;code&gt;invokeExact&lt;/code&gt; と同様にターゲットを呼び出します。（これは、タイプが一致する場合の &lt;code&gt;invoke&lt;/code&gt; の通常の動作です。）</target>
        </trans-unit>
        <trans-unit id="d2f5017e66f8dea9b28eb6f14ce79dfd0d322eb3" translate="yes" xml:space="preserve">
          <source>When called, indicates that compression should end with the current contents of the input buffer.</source>
          <target state="translated">呼び出された場合、圧縮は入力バッファの現在の内容で終了することを示します。</target>
        </trans-unit>
        <trans-unit id="f8858e1ea3fd1c36363ba040b10db093a73798d1" translate="yes" xml:space="preserve">
          <source>When called, the adapter replaces a trailing array argument by the array's elements, each as its own argument to the target. (The order of the arguments is preserved.) They are converted pairwise by casting and/or unboxing to the types of the trailing parameters of the target. Finally the target is called. What the target eventually returns is returned unchanged by the adapter.</source>
          <target state="translated">このアダプタがコールされると、アダプタは、末尾の配列の引数を配列の要素で置き換えます (引数の順序は保持されます)。(引数の順番は保持されます。)これらの要素は、ターゲットの末尾のパラメータの型にキャストおよび/またはアンボックス化することで、 ペアワイズ変換されます。最後にターゲットが呼び出されます。ターゲットが最終的に返すものは、アダプタによって変更されずに返されます。</target>
        </trans-unit>
        <trans-unit id="32698ba91a41a47b1415719cfb3ee4d88be1ebde" translate="yes" xml:space="preserve">
          <source>When called, the adapter replaces its trailing &lt;code&gt;arrayLength&lt;/code&gt; arguments by a single new array of type &lt;code&gt;arrayType&lt;/code&gt;, whose elements comprise (in order) the replaced arguments. Finally the target is called. What the target eventually returns is returned unchanged by the adapter.</source>
          <target state="translated">呼び出されると、アダプターは末尾の &lt;code&gt;arrayLength&lt;/code&gt; 引数をタイプが &lt;code&gt;arrayType&lt;/code&gt; の単一の新しい配列に置き換えます。最後に、ターゲットが呼び出されます。ターゲットが最終的に返すものは、アダプターによって変更されずに返されます。</target>
        </trans-unit>
        <trans-unit id="1d41427d5f2ba9b4f876eb45c993fa83acbb6861" translate="yes" xml:space="preserve">
          <source>When called, the bound handle inserts the given value &lt;code&gt;x&lt;/code&gt; as a new leading argument to the target. The other arguments are also passed unchanged. What the target eventually returns is returned unchanged by the bound handle.</source>
          <target state="translated">バインドされたハンドルが呼び出されると、指定された値 &lt;code&gt;x&lt;/code&gt; がターゲットの新しい先行引数として挿入されます。他の引数も変更されずに渡されます。ターゲットが最終的に返すものは、バインドされたハンドルによって変更されずに返されます。</target>
        </trans-unit>
        <trans-unit id="07e47dd6263746d4e6b3656f67f0733f7b685387" translate="yes" xml:space="preserve">
          <source>When called, the handle will treat the first argument as a receiver and dispatch on the receiver's type to determine which method implementation to enter. (The dispatching action is identical with that performed by an &lt;code&gt;invokevirtual&lt;/code&gt; or &lt;code&gt;invokeinterface&lt;/code&gt; instruction.)</source>
          <target state="translated">呼び出されると、ハンドルは最初の引数をレシーバーとして扱い、レシーバーのタイプにディスパッチして、どのメソッド実装に入るかを決定します。（ディスパッチアクションは、 &lt;code&gt;invokevirtual&lt;/code&gt; または &lt;code&gt;invokeinterface&lt;/code&gt; 命令によって実行されるアクションと同じです。）</target>
        </trans-unit>
        <trans-unit id="84c71118f0cab56f92d54fd7df74c2d3e7d46279" translate="yes" xml:space="preserve">
          <source>When called, the handle will treat the first argument as a receiver and, for non-private methods, dispatch on the receiver's type to determine which method implementation to enter. For private methods the named method in &lt;code&gt;refc&lt;/code&gt; will be invoked on the receiver. (The dispatching action is identical with that performed by an &lt;code&gt;invokevirtual&lt;/code&gt; or &lt;code&gt;invokeinterface&lt;/code&gt; instruction.)</source>
          <target state="translated">呼び出されると、ハンドルは最初の引数をレシーバーとして扱い、非プライベートメソッドの場合は、レシーバーの型をディスパッチして、入力するメソッド実装を決定します。プライベートメソッドの場合、 &lt;code&gt;refc&lt;/code&gt; の名前付きメソッドがレシーバーで呼び出されます。 （ディスパッチアクションは、 &lt;code&gt;invokevirtual&lt;/code&gt; または &lt;code&gt;invokeinterface&lt;/code&gt; 命令によって実行されるアクションと同じです。）</target>
        </trans-unit>
        <trans-unit id="ddf5901ed93495490773362c9912bfbbd03d6639" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;parseWithContext&lt;/code&gt;, the values of the following configuration parameters will be ignored and their default values will always be used instead: &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-validate&quot;&gt;validate&lt;/a&gt;&quot;, &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-validate-if-schema&quot;&gt;validate-if-schema&lt;/a&gt;&quot;, and &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-element-content-whitespace&quot;&gt;element-content-whitespace&lt;/a&gt;&quot;. Other parameters will be treated normally, and the parser is expected to call the &lt;code&gt;LSParserFilter&lt;/code&gt; just as if a whole document was parsed.</source>
          <target state="translated">&lt;code&gt;parseWithContext&lt;/code&gt; を呼び出すと、次の構成パラメーターの値は無視され、代わりに常にデフォルト値が使用されます：「&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-validate&quot;&gt;validate&lt;/a&gt;」、「&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-validate-if-schema&quot;&gt;validate-if-schema&lt;/a&gt;」、および「&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-element-content-whitespace&quot;&gt;element-content-whitespace&lt;/a&gt;」。他のパラメーターは通常どおり処理され、パーサーは、ドキュメント全体が解析されたかのように &lt;code&gt;LSParserFilter&lt;/code&gt; を呼び出すことが期待されます。</target>
        </trans-unit>
        <trans-unit id="2391920a3b69011b129eed441073582d616d0af6" translate="yes" xml:space="preserve">
          <source>When changes are made to this &lt;code&gt;DirContext&lt;/code&gt;, the effect on enumerations returned by prior calls to this method is undefined.</source>
          <target state="translated">この &lt;code&gt;DirContext&lt;/code&gt; に変更が加えられた場合、このメソッドへの以前の呼び出しによって返された列挙への影響は未定義です。</target>
        </trans-unit>
        <trans-unit id="903b7e48a00f4b84896728035808586f9ae200f1" translate="yes" xml:space="preserve">
          <source>When color data is stored in an image of this type, the closest color in the colormap is determined by the &lt;code&gt;IndexColorModel&lt;/code&gt; and the resulting index is stored. Approximation and loss of alpha or color components can result, depending on the colors in the &lt;code&gt;IndexColorModel&lt;/code&gt; colormap.</source>
          <target state="translated">このタイプの画像にカラーデータが保存されている場合、カラーマップで最も近い色が &lt;code&gt;IndexColorModel&lt;/code&gt; によって決定され、結果のインデックスが保存されます。 &lt;code&gt;IndexColorModel&lt;/code&gt; カラーマップの色によっては、アルファまたはカラーコンポーネントの近似と損失が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="596a1e26a91b27916ea68a39d5613c909fc17bd2" translate="yes" xml:space="preserve">
          <source>When comparing corresponding components of two URIs, if one component is undefined but the other is defined then the first is considered to be less than the second. Unless otherwise noted, string components are ordered according to their natural, case-sensitive ordering as defined by the &lt;a href=&quot;../lang/comparable#compareTo(T)&quot;&gt;&lt;code&gt;String.compareTo&lt;/code&gt;&lt;/a&gt; method. String components that are subject to encoding are compared by comparing their raw forms rather than their encoded forms.</source>
          <target state="translated">2つのURIの対応するコンポーネントを比較するときに、一方のコンポーネントが未定義で、もう一方が定義されている場合、最初のコンポーネントは2番目のコンポーネントよりも小さいと見なされます。特に明記されていない限り、文字列コンポーネントは、&lt;a href=&quot;../lang/comparable#compareTo(T)&quot;&gt; &lt;code&gt;String.compareTo&lt;/code&gt; &lt;/a&gt;メソッドで定義されている、大文字と小文字を区別する自然な順序に従って順序付けられます。エンコードの対象となる文字列コンポーネントは、エンコードされた形式ではなく、生の形式を比較することによって比較されます。</target>
        </trans-unit>
        <trans-unit id="a1a9496b1bc6bdad32600169e992ba4825384491" translate="yes" xml:space="preserve">
          <source>When comparing corresponding components of two URIs, if one component is undefined but the other is defined then the first is considered to be less than the second. Unless otherwise noted, string components are ordered according to their natural, case-sensitive ordering as defined by the &lt;a href=&quot;../lang/comparable#compareTo-T-&quot;&gt;&lt;code&gt;String.compareTo&lt;/code&gt;&lt;/a&gt; method. String components that are subject to encoding are compared by comparing their raw forms rather than their encoded forms.</source>
          <target state="translated">2つのURIの対応するコンポーネントを比較するときに、一方のコンポーネントが未定義で、もう一方が定義されている場合、最初のコンポーネントは2番目のコンポーネントよりも小さいと見なされます。特に明記しない限り、文字列コンポーネントは、&lt;a href=&quot;../lang/comparable#compareTo-T-&quot;&gt; &lt;code&gt;String.compareTo&lt;/code&gt; &lt;/a&gt;メソッドで定義されている、大文字と小文字が区別される自然な順序に従って並べられます。エンコードの対象となる文字列コンポーネントは、エンコードされた形式ではなく生の形式を比較することによって比較されます。</target>
        </trans-unit>
        <trans-unit id="3f5a301cfb1a53cc09533b6df9b74c243edd2ccf" translate="yes" xml:space="preserve">
          <source>When comparing two version strings, the elements of their corresponding components are compared in pointwise fashion. If one component is longer than the other, but otherwise equal to it, then the first component is considered the greater of the two; otherwise, if two corresponding elements are integers then they are compared as such; otherwise, at least one of the elements is a string, so the other is converted into a string if it is an integer and the two are compared lexicographically. Trailing integer elements with the value zero are ignored.</source>
          <target state="translated">2つのバージョン文字列を比較する際には、対応する構成要素の要素がポイントワイズで比較されます。一方の要素が他方の要素よりも長く、それ以外の場合は等しい場合、最初の要素は2つの要素のうち大きい方とみなされます。そうでない場合、2つの対応する要素が整数である場合、そのように比較されます。値がゼロの後続の整数要素は無視されます。</target>
        </trans-unit>
        <trans-unit id="766794f1dde5c4c93fc09600ddd1b32f8b44bbe1" translate="yes" xml:space="preserve">
          <source>When comparing two version strings, the value of &lt;code&gt;$OPT&lt;/code&gt;, if present, may or may not be significant depending on the chosen comparison method. The comparison methods &lt;a href=&quot;#compareTo(java.lang.Runtime.Version)&quot;&gt;&lt;code&gt;compareTo()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#compareToIgnoreOptional(java.lang.Runtime.Version)&quot;&gt;&lt;code&gt;compareToIgnoreOptional()&lt;/code&gt;&lt;/a&gt; should be used consistently with the corresponding methods &lt;a href=&quot;#equals(java.lang.Object)&quot;&gt;&lt;code&gt;equals()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#equalsIgnoreOptional(java.lang.Object)&quot;&gt;&lt;code&gt;equalsIgnoreOptional()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">2つのバージョン文字列を比較する場合、 &lt;code&gt;$OPT&lt;/code&gt; の値が存在する場合は、選択した比較方法に応じて重要な場合と重要でない場合があります。比較メソッド&lt;a href=&quot;#compareTo(java.lang.Runtime.Version)&quot;&gt; &lt;code&gt;compareTo()&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#compareToIgnoreOptional(java.lang.Runtime.Version)&quot;&gt; &lt;code&gt;compareToIgnoreOptional()&lt;/code&gt; &lt;/a&gt;は、対応するメソッド&lt;a href=&quot;#equals(java.lang.Object)&quot;&gt; &lt;code&gt;equals()&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;#equalsIgnoreOptional(java.lang.Object)&quot;&gt; &lt;code&gt;equalsIgnoreOptional()&lt;/code&gt; &lt;/a&gt;と一貫して使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="2103fe1187cedfb38f65d7ce9c0819c612ec17eb" translate="yes" xml:space="preserve">
          <source>When computing a date and time from the calendar fields, there may be insufficient information for the computation (such as only year and month with no day of month), or there may be inconsistent information (such as Tuesday, July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). &lt;code&gt;Calendar&lt;/code&gt; will resolve calendar field values to determine the date and time in the following way.</source>
          <target state="translated">カレンダーフィールドから日付と時刻を計算する場合、計算に十分な情報がない（年と月だけで月の日付がないなど）か、情報に一貫性がない可能性があります（1996年7月15日火曜日など）（Gregorian ）-1996年7月15日は実際には月曜日です）。 &lt;code&gt;Calendar&lt;/code&gt; は、以下の方法で日付と時刻を決定するためにカレンダーフィールド値を解決します。</target>
        </trans-unit>
        <trans-unit id="0dcc686243f0157dc4e782a735e5dde3570a33bc" translate="yes" xml:space="preserve">
          <source>When concatenated with a class attribute name, indicates the format of that attribute, using the layout language specified in the JSR 200 specification.</source>
          <target state="translated">クラス属性名と連結した場合、JSR200 仕様で規定されているレイアウト言語を用いて、その属性の形式を示す。</target>
        </trans-unit>
        <trans-unit id="bb74f60e238e6eeac7b5d4c50c88953481c44a68" translate="yes" xml:space="preserve">
          <source>When concatenated with a code attribute name, indicates the format of that attribute.</source>
          <target state="translated">コード属性名と連結すると、その属性の形式を示す。</target>
        </trans-unit>
        <trans-unit id="1e9e7edd39470beed21937a91c20e5bb29b65a00" translate="yes" xml:space="preserve">
          <source>When concatenated with a code attribute name, indicates the format of that attribute. For example, the effect of this option is built in: &lt;code&gt;pack.code.attribute.LocalVariableTable=NH[PHOHRUHRSHH]&lt;/code&gt;. The special strings &lt;a href=&quot;#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; are also allowed.</source>
          <target state="translated">コード属性名と連結すると、その属性の形式を示します。たとえば、このオプションの効果は次のように組み込まれています： &lt;code&gt;pack.code.attribute.LocalVariableTable=NH[PHOHRUHRSHH]&lt;/code&gt; 。特別な文字列&lt;a href=&quot;#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt;も許可されます。</target>
        </trans-unit>
        <trans-unit id="6c481650236192705c8984496664400b25ae4018" translate="yes" xml:space="preserve">
          <source>When concatenated with a code attribute name, indicates the format of that attribute. For example, the effect of this option is built in: &lt;code&gt;pack.code.attribute.LocalVariableTable=NH[PHOHRUHRSHH]&lt;/code&gt;. The special strings &lt;a href=&quot;pack200.packer#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;pack200.packer#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;pack200.packer#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; are also allowed.</source>
          <target state="translated">コード属性名と連結される場合、その属性の形式を示します。たとえば、このオプションの効果は、 &lt;code&gt;pack.code.attribute.LocalVariableTable=NH[PHOHRUHRSHH]&lt;/code&gt; 。特別な文字列&lt;a href=&quot;pack200.packer#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;pack200.packer#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;pack200.packer#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt;も使用できます。</target>
        </trans-unit>
        <trans-unit id="ceb1ddea1eb879c6878c1a1d7674d5ebeef2e985" translate="yes" xml:space="preserve">
          <source>When concatenated with a field attribute name, indicates the format of that attribute.</source>
          <target state="translated">フィールド属性名と連結すると、その属性のフォーマットを示します。</target>
        </trans-unit>
        <trans-unit id="47883ebf03b00718b34fcc759408570310a33897" translate="yes" xml:space="preserve">
          <source>When concatenated with a field attribute name, indicates the format of that attribute. For example, the effect of this option is built in: &lt;code&gt;pack.field.attribute.Deprecated=&lt;/code&gt;. The special strings &lt;a href=&quot;#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; are also allowed.</source>
          <target state="translated">フィールド属性名と連結すると、その属性の形式を示します。たとえば、このオプションの効果は次のように組み込まれています： &lt;code&gt;pack.field.attribute.Deprecated=&lt;/code&gt; 。特別な文字列&lt;a href=&quot;#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt;も許可されます。</target>
        </trans-unit>
        <trans-unit id="69b68d3b1ed8dc49253990c27eccbd09190abb43" translate="yes" xml:space="preserve">
          <source>When concatenated with a field attribute name, indicates the format of that attribute. For example, the effect of this option is built in: &lt;code&gt;pack.field.attribute.Deprecated=&lt;/code&gt;. The special strings &lt;a href=&quot;pack200.packer#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;pack200.packer#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;pack200.packer#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; are also allowed.</source>
          <target state="translated">フィールド属性名と連結される場合、その属性の形式を示します。たとえば、このオプションの効果は &lt;code&gt;pack.field.attribute.Deprecated=&lt;/code&gt; 組み込まれています。特別な文字列&lt;a href=&quot;pack200.packer#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;pack200.packer#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;pack200.packer#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt;も使用できます。</target>
        </trans-unit>
        <trans-unit id="33a1709395545b56f118dfdd106e7258d9b8f06b" translate="yes" xml:space="preserve">
          <source>When concatenated with a method attribute name, indicates the format of that attribute.</source>
          <target state="translated">メソッド属性名と連結すると、その属性の形式を示します。</target>
        </trans-unit>
        <trans-unit id="c8da13828fde7c93e320323d44f6b62e3d17a27c" translate="yes" xml:space="preserve">
          <source>When concatenated with a method attribute name, indicates the format of that attribute. For example, the effect of this option is built in: &lt;code&gt;pack.method.attribute.Exceptions=NH[RCH]&lt;/code&gt;. The special strings &lt;a href=&quot;#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; are also allowed.</source>
          <target state="translated">メソッド属性名と連結すると、その属性の形式を示します。たとえば、このオプションの効果は、 &lt;code&gt;pack.method.attribute.Exceptions=NH[RCH]&lt;/code&gt; 組み込まれています。特別な文字列&lt;a href=&quot;#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt;も許可されます。</target>
        </trans-unit>
        <trans-unit id="b1b39538a51627baa398137ae5124f3674a47944" translate="yes" xml:space="preserve">
          <source>When concatenated with a method attribute name, indicates the format of that attribute. For example, the effect of this option is built in: &lt;code&gt;pack.method.attribute.Exceptions=NH[RCH]&lt;/code&gt;. The special strings &lt;a href=&quot;pack200.packer#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;pack200.packer#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;pack200.packer#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; are also allowed.</source>
          <target state="translated">メソッド属性名と連結される場合、その属性の形式を示します。たとえば、このオプションの効果は &lt;code&gt;pack.method.attribute.Exceptions=NH[RCH]&lt;/code&gt; 組み込まれています。特別な文字列&lt;a href=&quot;pack200.packer#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;pack200.packer#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;pack200.packer#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt;も使用できます。</target>
        </trans-unit>
        <trans-unit id="715e1e84dcaa0489832f5e6cede42eba32b7afd9" translate="yes" xml:space="preserve">
          <source>When constructed as fair, threads contend for entry using an approximately arrival-order policy. When the currently held lock is released, either the longest-waiting single writer thread will be assigned the write lock, or if there is a group of reader threads waiting longer than all waiting writer threads, that group will be assigned the read lock.</source>
          <target state="translated">フェアとして構築されている場合、スレッドはほぼ到着順のポリシーを使用してエントリを競います。現在保持しているロックが解放されると、最も長く待っている単一のライタースレッドに書き込みロックが割り当てられるか、すべてのライタースレッドよりも長く待っているリーダースレッドのグループがある場合は、そのグループに読み取りロックが割り当てられます。</target>
        </trans-unit>
        <trans-unit id="61fbad8d5157fa12e2924a0b101d7488fca8edd0" translate="yes" xml:space="preserve">
          <source>When constructed as non-fair (the default), the order of entry to the read and write lock is unspecified, subject to reentrancy constraints. A nonfair lock that is continuously contended may indefinitely postpone one or more reader or writer threads, but will normally have higher throughput than a fair lock.</source>
          <target state="translated">非フェア(デフォルト)として構築されている場合、リードロックとライトロックへのエントリの順序は、リエントランシー制約の影響を受けて不特定です。継続的に競合するノンフェアロックは、1 つ以上のリーダまたはライタースレッドを無期限に延期する可能性がありますが、通常はフェアロックよりも高いスループットが得られます。</target>
        </trans-unit>
        <trans-unit id="0e952a0329782ab3d664a78b3d191c4eda125051" translate="yes" xml:space="preserve">
          <source>When constructing a JAR url via &lt;code&gt;new URL(context, spec)&lt;/code&gt;, the following rules apply:</source>
          <target state="translated">&lt;code&gt;new URL(context, spec)&lt;/code&gt; を介してJAR urlを構築する場合、次の規則が適用されます。</target>
        </trans-unit>
        <trans-unit id="41c8b69db960d9e4b36a2e8b2f092f79ddba9a4f" translate="yes" xml:space="preserve">
          <source>When constructing new JavaFileObjects, the file manager must determine where to create them. For example, if a file manager manages regular files on a file system, it would most likely have a current/working directory to use as default location when creating or finding files. A number of hints can be provided to a file manager as to where to create files. Any file manager might choose to ignore these hints.</source>
          <target state="translated">新しいJavaFileObjectを構築するとき、ファイル・マネージャは、それらをどこに作成するかを決定しなければなりません。たとえば、ファイル・マネージャがファイル・システム上で通常のファイルを管理している場合、ほとんどの場合、ファイルを作成したり見つけたりするときのデフォルトの場所として使用するカレント/ワーキング・ディレクトリがあるでしょう。ファイルをどこに作成するかについては、多くのヒントをファイルマネージャに提供することができます。どのファイルマネージャも、これらのヒントを無視することを選択するかもしれません。</target>
        </trans-unit>
        <trans-unit id="a964eaa3b3cf4ad1eed4195c0e00287e21036db6" translate="yes" xml:space="preserve">
          <source>When converting back to &lt;code&gt;ZonedDateTime&lt;/code&gt;, if the local date-time is in an overlap, then the offset will be retained if possible, otherwise the earlier offset will be used. If in a gap, the local date-time will be adjusted forward by the length of the gap.</source>
          <target state="translated">&lt;code&gt;ZonedDateTime&lt;/code&gt; に変換し直すときに、ローカルの日付と時刻が重複している場合、可能であればオフセットが保持されます。それ以外の場合は、以前のオフセットが使用されます。ギャップがある場合、ローカルの日時はギャップの長さだけ前方に調整されます。</target>
        </trans-unit>
        <trans-unit id="da70171e9e306ca307ebacfcf0e847c01479df72" translate="yes" xml:space="preserve">
          <source>When copy of the object is retrieved (via the &lt;code&gt;get&lt;/code&gt; method), if the class is not available locally, it will be loaded from the appropriate location (specified the URL annotated with the class descriptor when the class was serialized.</source>
          <target state="translated">オブジェクトのコピーが（ &lt;code&gt;get&lt;/code&gt; メソッドを介して）取得されるときに、クラスがローカルで使用できない場合は、適切な場所（クラスがシリアル化されたときにクラス記述子で注釈が付けられたURLを指定）からロードされます。</target>
        </trans-unit>
        <trans-unit id="335335544c2a50cfd694c3a55d6ae8a94af447f1" translate="yes" xml:space="preserve">
          <source>When copying a float or double source to an integral type destination, each source sample is cast to the destination type. When copying an integral type source to a float or double destination, the source is first converted to a 32-bit int (if necessary), using the above rules for integral types, and then the int is cast to float or double.</source>
          <target state="translated">float または double のソースを積分型のデスティネーションにコピーする場合、各ソース・サンプルはデスティネーションの型にキャストされます。積分型のソースを float または double のデスティネーションにコピーする場合は、上記の積分型のルールを使用して、まずソースを 32 ビットの int(必要に応じて)に変換してから、その int を float または double にキャストします。</target>
        </trans-unit>
        <trans-unit id="3ade72b52f46fe9735881965253dded0d6c147b2" translate="yes" xml:space="preserve">
          <source>When created, the default implementation of &lt;code&gt;ActivationGroup&lt;/code&gt; will override the system properties with the properties requested when its &lt;code&gt;ActivationGroupDesc&lt;/code&gt; was created, and will set a &lt;a href=&quot;../../../../java.base/java/lang/securitymanager&quot;&gt;&lt;code&gt;SecurityManager&lt;/code&gt;&lt;/a&gt; as the default system security manager. If your application requires specific properties to be set when objects are activated in the group, the application should create a special &lt;code&gt;Properties&lt;/code&gt; object containing these properties, then create an &lt;code&gt;ActivationGroupDesc&lt;/code&gt; with the &lt;code&gt;Properties&lt;/code&gt; object, and use &lt;code&gt;ActivationGroup.createGroup&lt;/code&gt; before creating any &lt;code&gt;ActivationDesc&lt;/code&gt;s (before the default &lt;code&gt;ActivationGroupDesc&lt;/code&gt; is created). If your application requires the use of a security manager other than &lt;a href=&quot;../../../../java.base/java/lang/securitymanager&quot;&gt;&lt;code&gt;SecurityManager&lt;/code&gt;&lt;/a&gt;, in the ActivativationGroupDescriptor properties list you can set &lt;code&gt;java.security.manager&lt;/code&gt; property to the name of the security manager you would like to install.</source>
          <target state="translated">作成された場合には、デフォルトの実装で &lt;code&gt;ActivationGroup&lt;/code&gt; プロパティを持つシステムプロパティをオーバーライドしますが、その際、要求 &lt;code&gt;ActivationGroupDesc&lt;/code&gt; 作成し、設定します&lt;a href=&quot;../../../../java.base/java/lang/securitymanager&quot;&gt; &lt;code&gt;SecurityManager&lt;/code&gt; &lt;/a&gt;デフォルトのシステムのセキュリティマネージャとして。アプリケーションがオブジェクトをグループで稼動しているときに設定されるように特定のプロパティを必要とする場合、アプリケーションは特別作成する必要がある &lt;code&gt;Properties&lt;/code&gt; これらのプロパティを含むオブジェクトは、作成 &lt;code&gt;ActivationGroupDesc&lt;/code&gt; して &lt;code&gt;Properties&lt;/code&gt; 、オブジェクト、および使用 &lt;code&gt;ActivationGroup.createGroup&lt;/code&gt; 任意の作成する前 &lt;code&gt;ActivationDesc&lt;/code&gt; 秒（前デフォルトの &lt;code&gt;ActivationGroupDesc&lt;/code&gt; 創造された）。アプリケーションで&lt;a href=&quot;../../../../java.base/java/lang/securitymanager&quot;&gt; &lt;code&gt;SecurityManager&lt;/code&gt; &lt;/a&gt;以外のセキュリティマネージャーを使用する必要がある場合は、ActivativationGroupDescriptorプロパティリストで、 &lt;code&gt;java.security.manager&lt;/code&gt; プロパティをインストールするセキュリティマネージャーの名前に設定できます。</target>
        </trans-unit>
        <trans-unit id="330033318b9b32fd36ddd46bb1ced3469157a8be" translate="yes" xml:space="preserve">
          <source>When creating a &lt;code&gt;ChoiceFormat&lt;/code&gt;, you must specify an array of formats and an array of limits. The length of these arrays must be the same. For example,</source>
          <target state="translated">&lt;code&gt;ChoiceFormat&lt;/code&gt; を作成するときは、フォーマットの配列と制限の配列を指定する必要があります。これらの配列の長さは同じでなければなりません。例えば、</target>
        </trans-unit>
        <trans-unit id="09c8af312b3d6fd01641b9e7028cc827b52cff1d" translate="yes" xml:space="preserve">
          <source>When creating a &lt;code&gt;Graphics2D&lt;/code&gt; object, the &lt;code&gt;GraphicsConfiguration&lt;/code&gt; specifies the &lt;a id=&quot;deftransform&quot;&gt;default transform&lt;/a&gt; for the target of the &lt;code&gt;Graphics2D&lt;/code&gt; (a &lt;a href=&quot;component&quot;&gt;&lt;code&gt;Component&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;image&quot;&gt;&lt;code&gt;Image&lt;/code&gt;&lt;/a&gt;). This default transform maps the user space coordinate system to screen and printer device coordinates such that the origin maps to the upper left hand corner of the target region of the device with increasing X coordinates extending to the right and increasing Y coordinates extending downward. The scaling of the default transform is set to identity for those devices that are close to 72 dpi, such as screen devices. The scaling of the default transform is set to approximately 72 user space coordinates per square inch for high resolution devices, such as printers. For image buffers, the default transform is the &lt;code&gt;Identity&lt;/code&gt; transform.</source>
          <target state="translated">作成する際 &lt;code&gt;Graphics2D&lt;/code&gt; オブジェクトを、 &lt;code&gt;GraphicsConfiguration&lt;/code&gt; には、指定&lt;a id=&quot;deftransform&quot;&gt;のデフォルト変換&lt;/a&gt;のターゲットのため &lt;code&gt;Graphics2D&lt;/code&gt; （&lt;a href=&quot;component&quot;&gt; &lt;code&gt;Component&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;image&quot;&gt; &lt;code&gt;Image&lt;/code&gt; &lt;/a&gt;）。このデフォルトの変換では、ユーザー空間の座標系を画面とプリンターデバイスの座標にマッピングし、原点がデバイスのターゲット領域の左上隅にマッピングされ、X座標が右に伸び、Y座標が下に伸びます。デフォルトの変換のスケーリングは、画面デバイスなど、72dpiに近いデバイスのIDに設定されます。デフォルトの変換のスケーリングは、プリンターなどの高解像度デバイスの場合、1平方インチあたり約72のユーザー空間座標に設定されます。画像バッファの場合、デフォルトの変換は &lt;code&gt;Identity&lt;/code&gt; 変換です。</target>
        </trans-unit>
        <trans-unit id="8c146d0b369274554520e962246ecbdade5c4558" translate="yes" xml:space="preserve">
          <source>When creating a &lt;code&gt;KerberosKey&lt;/code&gt; using the &lt;a href=&quot;#%3Cinit%3E(javax.security.auth.kerberos.KerberosPrincipal,char%5B%5D,java.lang.String)&quot;&gt;&lt;code&gt;KerberosKey(KerberosPrincipal, char[], String)&lt;/code&gt;&lt;/a&gt; constructor, an implementation may accept non-IANA algorithm names (For example, &quot;ArcFourMac&quot; for &quot;rc4-hmac&quot;), but the &lt;a href=&quot;#getAlgorithm()&quot;&gt;&lt;code&gt;getAlgorithm()&lt;/code&gt;&lt;/a&gt; method must always return the IANA algorithm name.</source>
          <target state="translated">&lt;a href=&quot;#%3Cinit%3E(javax.security.auth.kerberos.KerberosPrincipal,char%5B%5D,java.lang.String)&quot;&gt; &lt;code&gt;KerberosKey(KerberosPrincipal, char[], String)&lt;/code&gt; &lt;/a&gt;コンストラクターを使用して &lt;code&gt;KerberosKey&lt;/code&gt; を作成する場合、実装は非IANAアルゴリズム名（たとえば、「rc4-hmac」の「ArcFourMac」）を&lt;a href=&quot;#getAlgorithm()&quot;&gt; &lt;code&gt;getAlgorithm()&lt;/code&gt; &lt;/a&gt;場合がありますが、getAlgorithm（）メソッドは常にIANAアルゴリズム名を返します。</target>
        </trans-unit>
        <trans-unit id="9b38bad41028682d65ecb4198fe6abc7015b87c2" translate="yes" xml:space="preserve">
          <source>When creating a &lt;code&gt;Paper&lt;/code&gt; object, it is the application's responsibility to ensure that the paper size and the imageable area are compatible. For example, if the paper size is changed from 11 x 17 to 8.5 x 11, the application might need to reduce the imageable area so that whatever is printed fits on the page.</source>
          <target state="translated">&lt;code&gt;Paper&lt;/code&gt; オブジェクトを作成するときは、用紙サイズと画像化可能な領域に互換性があることを確認するのはアプリケーションの責任です。たとえば、用紙サイズが11 x17から8.5x 11に変更された場合、アプリケーションは、印刷されたものがページに収まるように、画像化可能な領域を縮小する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="f380ad1809365a52c2f779b295ad176ba7cee1fe" translate="yes" xml:space="preserve">
          <source>When creating a &lt;code&gt;TimeZone&lt;/code&gt;, the specified custom time zone ID is normalized in the following syntax:</source>
          <target state="translated">&lt;code&gt;TimeZone&lt;/code&gt; を作成するとき、指定されたカスタムタイムゾーンIDは次の構文で正規化されます。</target>
        </trans-unit>
        <trans-unit id="105221734ccfc8a498e02b002ab64f6bd84a44d9" translate="yes" xml:space="preserve">
          <source>When creating a connector client or server, it is possible to supply an object of type &lt;a href=&quot;../../../../java.base/java/util/map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; that defines additional parameters. Each entry in this Map has a key that is a string and an associated value whose type is appropriate for that key. The standard keys defined by the JMX Remote API all begin with the string &quot;&lt;code&gt;jmx.remote.&lt;/code&gt;&quot;. The document &lt;em&gt;JMX Remote API&lt;/em&gt; lists these standard keys.</source>
          <target state="translated">コネクタクライアントまたはサーバーを作成するときに、追加のパラメータを定義するタイプ&lt;a href=&quot;../../../../java.base/java/util/map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; の&lt;/a&gt;オブジェクトを提供することができます。このマップの各エントリには、文字列であるキーと、そのキーに適したタイプの関連する値があります。 JMX Remote APIで定義されている標準キーはすべて、文字列「 &lt;code&gt;jmx.remote.&lt;/code&gt; 」で始まります。ドキュメント&lt;em&gt;JMXRemote APIに&lt;/em&gt;は、これらの標準キーがリストされています。</target>
        </trans-unit>
        <trans-unit id="b9ab1915b79f38ba00b3dd084c59f43fd7b1a097" translate="yes" xml:space="preserve">
          <source>When creating a connector client or server, it is possible to supply an object of type &lt;a href=&quot;../../../java/util/map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; that defines additional parameters. Each entry in this Map has a key that is a string and an associated value whose type is appropriate for that key. The standard keys defined by the JMX Remote API all begin with the string &quot;&lt;code&gt;jmx.remote.&lt;/code&gt;&quot;. The document &lt;em&gt;JMX Remote API&lt;/em&gt; lists these standard keys.</source>
          <target state="translated">コネクタクライアントまたはサーバーを作成するときに、追加のパラメーターを定義するタイプ&lt;a href=&quot;../../../java/util/map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; の&lt;/a&gt;オブジェクトを提供することができます。このマップの各エントリには、文字列であるキーと、そのキーに適したタイプの値が関連付けられています。JMX Remote APIによって定義された標準キーはすべて、文字列 &quot; &lt;code&gt;jmx.remote.&lt;/code&gt; &quot;で始まります。ドキュメント&lt;em&gt;JMX Remote APIに&lt;/em&gt;は、これらの標準キーがリストされています。</target>
        </trans-unit>
        <trans-unit id="96d5bb0b77a90195ba6f2cbc3333bf0e862753f3" translate="yes" xml:space="preserve">
          <source>When creating a new file this option is a &lt;em&gt;hint&lt;/em&gt; that the new file will be sparse. This option is ignored when not creating a new file.</source>
          <target state="translated">新しいファイルを作成するとき、このオプションは新しいファイルがまばらになるという&lt;em&gt;ヒント&lt;/em&gt;になります。新しいファイルを作成しない場合、このオプションは無視されます。</target>
        </trans-unit>
        <trans-unit id="c39abb2d7aabb3ded864546db651700da7057721" translate="yes" xml:space="preserve">
          <source>When creating a subclass of InitialContext, use this method as follows. Define a new method that uses this method to get an initial context of the desired subclass.</source>
          <target state="translated">InitialContextのサブクラスを作成する際には、以下のようにこのメソッドを使用します。このメソッドを使用して、目的のサブクラスの初期コンテキストを取得する新しいメソッドを定義します。</target>
        </trans-unit>
        <trans-unit id="d46d936e93bb8a599591119f0d596c9ab0f11f7e" translate="yes" xml:space="preserve">
          <source>When data has been received, the &lt;code&gt;WebSocket&lt;/code&gt; invokes a receive method. Methods &lt;code&gt;onText&lt;/code&gt;, &lt;code&gt;onBinary&lt;/code&gt;, &lt;code&gt;onPing&lt;/code&gt; and &lt;code&gt;onPong&lt;/code&gt; must return a &lt;code&gt;CompletionStage&lt;/code&gt; that completes once the message has been received by the listener. If a listener's method returns &lt;code&gt;null&lt;/code&gt; rather than a &lt;code&gt;CompletionStage&lt;/code&gt;, &lt;code&gt;WebSocket&lt;/code&gt; will behave as if the listener returned a &lt;code&gt;CompletionStage&lt;/code&gt; that is already completed normally.</source>
          <target state="translated">データが受信されると、 &lt;code&gt;WebSocket&lt;/code&gt; はreceiveメソッドを呼び出します。メソッド &lt;code&gt;onText&lt;/code&gt; 、 &lt;code&gt;onBinary&lt;/code&gt; 、 &lt;code&gt;onPing&lt;/code&gt; 、および &lt;code&gt;onPong&lt;/code&gt; は、メッセージがリスナーによって受信されると完了する &lt;code&gt;CompletionStage&lt;/code&gt; を返す必要があります。リスナーのメソッドが &lt;code&gt;CompletionStage&lt;/code&gt; ではなく &lt;code&gt;null&lt;/code&gt; を返す場合、 &lt;code&gt;WebSocket&lt;/code&gt; は、リスナーがすでに正常に &lt;code&gt;CompletionStage&lt;/code&gt; ているCompletionStageを返したかのように動作します。</target>
        </trans-unit>
        <trans-unit id="020fc5ad194f669ea119d61b8cd7bdd1712118d0" translate="yes" xml:space="preserve">
          <source>When data is being transported using MIDI wire protocol, a &lt;a href=&quot;shortmessage&quot;&gt;&lt;code&gt;ShortMessage&lt;/code&gt;&lt;/a&gt; with the status value &lt;code&gt;0xFF&lt;/code&gt; represents a system reset message. In MIDI files, this same status value denotes a &lt;code&gt;MetaMessage&lt;/code&gt;. The types of meta-message are distinguished from each other by the first byte that follows the status byte &lt;code&gt;0xFF&lt;/code&gt;. The subsequent bytes are data bytes. As with system exclusive messages, there are an arbitrary number of data bytes, depending on the type of &lt;code&gt;MetaMessage&lt;/code&gt;.</source>
          <target state="translated">データがMIDIワイヤープロトコルを使用して転送されている場合、ステータス値 &lt;code&gt;0xFF&lt;/code&gt; の&lt;a href=&quot;shortmessage&quot;&gt; &lt;code&gt;ShortMessage&lt;/code&gt; &lt;/a&gt;はシステムリセットメッセージを表します。 MIDIファイルでは、この同じステータス値は &lt;code&gt;MetaMessage&lt;/code&gt; を示します。メタメッセージのタイプは、ステータスバイト &lt;code&gt;0xFF&lt;/code&gt; に続く最初のバイトによって互いに区別されます。後続のバイトはデータバイトです。システム専用メッセージと同様に、 &lt;code&gt;MetaMessage&lt;/code&gt; のタイプに応じて、任意の数のデータバイトがあります。</target>
        </trans-unit>
        <trans-unit id="61fdfc98284714085a633464250d1ada20371927" translate="yes" xml:space="preserve">
          <source>When data is being transported using MIDI wire protocol, a &lt;code&gt;&lt;a href=&quot;shortmessage&quot;&gt;&lt;code&gt;ShortMessage&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; with the status value &lt;code&gt;0xFF&lt;/code&gt; represents a system reset message. In MIDI files, this same status value denotes a &lt;code&gt;MetaMessage&lt;/code&gt;. The types of meta-message are distinguished from each other by the first byte that follows the status byte &lt;code&gt;0xFF&lt;/code&gt;. The subsequent bytes are data bytes. As with system exclusive messages, there are an arbitrary number of data bytes, depending on the type of &lt;code&gt;MetaMessage&lt;/code&gt;.</source>
          <target state="translated">MIDIワイヤプロトコルを使用してデータが転送されている場合、ステータス値 &lt;code&gt;0xFF&lt;/code&gt; の &lt;code&gt;&lt;a href=&quot;shortmessage&quot;&gt;&lt;code&gt;ShortMessage&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; はシステムリセットメッセージを表します。 MIDIファイルでは、この同じステータス値は &lt;code&gt;MetaMessage&lt;/code&gt; を示します。メタメッセージのタイプは、ステータスバイト &lt;code&gt;0xFF&lt;/code&gt; に続く最初のバイトによって互いに区別されます。後続のバイトはデータバイトです。システムエクスクルーシブメッセージと同様に、 &lt;code&gt;MetaMessage&lt;/code&gt; のタイプに応じて、任意の数のデータバイトがあります。</target>
        </trans-unit>
        <trans-unit id="538871f766ab351c2d645502820fda06341f2446" translate="yes" xml:space="preserve">
          <source>When decoding, the &lt;code&gt;UTF-16&lt;/code&gt; charset interprets the byte-order mark at the beginning of the input stream to indicate the byte-order of the stream but defaults to big-endian if there is no byte-order mark; when encoding, it uses big-endian byte order and writes a big-endian byte-order mark.</source>
          <target state="translated">デコード時に、 &lt;code&gt;UTF-16&lt;/code&gt; 文字セットは入力ストリームの先頭のバイト順マークを解釈してストリームのバイト順を示しますが、バイト順マークがない場合はデフォルトでビッグエンディアンになります。エンコード時には、ビッグエンディアンのバイトオーダーを使用し、ビッグエンディアンのバイトオーダーマークを書き込みます。</target>
        </trans-unit>
        <trans-unit id="5d918b0ea7fbe3a38f352e3c01e13aa510f07228" translate="yes" xml:space="preserve">
          <source>When decoding, the &lt;code&gt;UTF-16BE&lt;/code&gt; and &lt;code&gt;UTF-16LE&lt;/code&gt; charsets interpret the initial byte-order marks as a &lt;small&gt;ZERO-WIDTH NON-BREAKING SPACE&lt;/small&gt;; when encoding, they do not write byte-order marks.</source>
          <target state="translated">デコード時に、 &lt;code&gt;UTF-16BE&lt;/code&gt; および &lt;code&gt;UTF-16LE&lt;/code&gt; 文字セットは、最初のバイト順マークを&lt;small&gt;ZERO-WIDTH NON-BREAKING SPACE&lt;/small&gt;として解釈します。エンコード時には、バイト順マークは書き込まれません。</target>
        </trans-unit>
        <trans-unit id="e1bbaedc1e7a3af98446547c47a00777304dd4bc" translate="yes" xml:space="preserve">
          <source>When designing applications that use the &lt;code&gt;JTable&lt;/code&gt; it is worth paying close attention to the data structures that will represent the table's data. The &lt;code&gt;DefaultTableModel&lt;/code&gt; is a model implementation that uses a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Vector&lt;/code&gt;s of &lt;code&gt;Object&lt;/code&gt;s to store the cell values. As well as copying the data from an application into the &lt;code&gt;DefaultTableModel&lt;/code&gt;, it is also possible to wrap the data in the methods of the &lt;code&gt;TableModel&lt;/code&gt; interface so that the data can be passed to the &lt;code&gt;JTable&lt;/code&gt; directly, as in the example above. This often results in more efficient applications because the model is free to choose the internal representation that best suits the data. A good rule of thumb for deciding whether to use the &lt;code&gt;AbstractTableModel&lt;/code&gt; or the &lt;code&gt;DefaultTableModel&lt;/code&gt; is to use the &lt;code&gt;AbstractTableModel&lt;/code&gt; as the base class for creating subclasses and the &lt;code&gt;DefaultTableModel&lt;/code&gt; when subclassing is not required.</source>
          <target state="translated">&lt;code&gt;JTable&lt;/code&gt; を使用するアプリケーションを設計するときは、テーブルのデータを表すデータ構造に細心の注意を払う価値があります。 &lt;code&gt;DefaultTableModel&lt;/code&gt; では、使用するモデルの実装である &lt;code&gt;Vector&lt;/code&gt; の &lt;code&gt;Vector&lt;/code&gt; Sの &lt;code&gt;Object&lt;/code&gt; セルの値を格納するのを。アプリケーションから &lt;code&gt;DefaultTableModel&lt;/code&gt; にデータをコピーするだけでなく、 &lt;code&gt;TableModel&lt;/code&gt; インターフェイスのメソッドでデータをラップして、データを &lt;code&gt;JTable&lt;/code&gt; に渡すこともできます。上記の例のように、直接。モデルはデータに最適な内部表現を自由に選択できるため、これにより多くの場合、より効率的なアプリケーションが実現します。 &lt;code&gt;AbstractTableModel&lt;/code&gt; と &lt;code&gt;DefaultTableModel&lt;/code&gt; のどちらを使用するかを決定するための大まかな目安は、サブクラスを作成するための基本クラスとして &lt;code&gt;AbstractTableModel&lt;/code&gt; を使用し、サブクラス化が不要な場合は &lt;code&gt;DefaultTableModel&lt;/code&gt; を使用することです。</target>
        </trans-unit>
        <trans-unit id="59dd531cc5c7b8c2c34d67569898edd73dd7c276" translate="yes" xml:space="preserve">
          <source>When developing your bean, you can implement the bean features required for your application task omitting the rest of the &lt;code&gt;BeanInfo&lt;/code&gt; features. They will be obtained through the automatic analysis by using the low-level reflection of the bean methods and applying standard design patterns. You have an opportunity to provide additional bean information through various descriptor classes.</source>
          <target state="translated">Beanを開発する場合、アプリケーションタスクに必要なBean機能を実装して、残りの &lt;code&gt;BeanInfo&lt;/code&gt; 機能を省略できます。それらは、Beanメソッドの低レベルの反映を使用し、標準の設計パターンを適用することによる自動分析を通じて取得されます。さまざまな記述子クラスを通じて追加のBean情報を提供する機会があります。</target>
        </trans-unit>
        <trans-unit id="3e298bb1eb347b2cc28bf3c3db8299caa60036f9" translate="yes" xml:space="preserve">
          <source>When disabled, the scaled design metrics are rounded or adjusted to integer distances for layout. The distances between any specific pair of glyphs will be more uniform on the device, but the density and total length of long strings may no longer match the theoretical intentions of the font designer. Disabling this hint will typically produce more readable results on low resolution devices like computer monitors.</source>
          <target state="translated">無効にすると、スケーリングされたデザインメトリクスは丸められたり、レイアウトのために整数の距離に調整されたりします。特定のグリフの対の間の距離はデバイス上でより均一になりますが、長い文字列の密度と全長はもはやフォント設計者の理論的意図と一致しないかもしれません。こ のヒントを無効にする と 、 通常、 コ ン ピ ュ ー タ モ ニ タ ーの よ う な低解像度のデバ イ スでは読みやすい結果が得 ら れます。</target>
        </trans-unit>
        <trans-unit id="984d0d26836dd3f7be2af922a5a2560cc3df5fe1" translate="yes" xml:space="preserve">
          <source>When displaying the &lt;code&gt;JToolTip&lt;/code&gt;, the &lt;code&gt;ToolTipManager&lt;/code&gt; chooses to use a lightweight &lt;code&gt;JPanel&lt;/code&gt; if it fits.</source>
          <target state="translated">&lt;code&gt;JToolTip&lt;/code&gt; を表示するとき、 &lt;code&gt;ToolTipManager&lt;/code&gt; は、適切な場合は軽量の &lt;code&gt;JPanel&lt;/code&gt; を使用することを選択します。</target>
        </trans-unit>
        <trans-unit id="6d1107a71bf9e4fe0583e9859fa2adb2225f96b2" translate="yes" xml:space="preserve">
          <source>When displaying the &lt;code&gt;JToolTip&lt;/code&gt;, the &lt;code&gt;ToolTipManager&lt;/code&gt; chooses to use a lightweight &lt;code&gt;JPanel&lt;/code&gt; if it fits. This method allows you to disable this feature. You have to do disable it if your application mixes light weight and heavy weights components.</source>
          <target state="translated">&lt;code&gt;JToolTip&lt;/code&gt; を表示するとき、 &lt;code&gt;ToolTipManager&lt;/code&gt; は、適切な場合は軽量の &lt;code&gt;JPanel&lt;/code&gt; を使用することを選択します。この方法では、この機能を無効にすることができます。アプリケーションで軽量コンポーネントと重量コンポーネントが混在している場合は、無効にする必要があります。</target>
        </trans-unit>
        <trans-unit id="4c8c9e94fef6a9d661fc4f926a9c52a00769d2e8" translate="yes" xml:space="preserve">
          <source>When dragging a component, reassigning it to the drag layer ensures that it is positioned over every other component in the container. When finished dragging, it can be reassigned to its normal layer.</source>
          <target state="translated">コンポーネントをドラッグする際、ドラッグレイヤーに再割り当てすることで、コンテナ内の他のすべてのコンポーネントの上にコンポーネントが配置されます。ドラッグが終了したら、通常のレイヤーに再割り当てすることができます。</target>
        </trans-unit>
        <trans-unit id="509eab7dc545a495647c552331312cb067390e94" translate="yes" xml:space="preserve">
          <source>When drawing operations are performed, pixels which are the current color are changed to the specified color, and vice versa.</source>
          <target state="translated">描画操作を行うと、現在の色である画素が指定された色に変更され、逆に現在の色である画素が指定された色に変更されます。</target>
        </trans-unit>
        <trans-unit id="f7dc328ec17b4ced8684c2b7e2f146a6ba17ed33" translate="yes" xml:space="preserve">
          <source>When editing, this will be the Component that is doing the actual editing.</source>
          <target state="translated">編集時には、実際に編集を行っているコンポーネントになります。</target>
        </trans-unit>
        <trans-unit id="1145f6b1027e817559c57cddc450ec5598c076bb" translate="yes" xml:space="preserve">
          <source>When elements are specified individually, this method provides a convenient way to add a few elements to an existing collection:</source>
          <target state="translated">要素が個別に指定されている場合、このメソッドは既存のコレクションにいくつかの要素を追加する便利な方法を提供します。</target>
        </trans-unit>
        <trans-unit id="f0547e7d1fe9e7682b31c5b8e679a8b7cf7cdac7" translate="yes" xml:space="preserve">
          <source>When encoding a String, the following rules apply:</source>
          <target state="translated">文字列をエンコードする場合は、以下のルールが適用されます。</target>
        </trans-unit>
        <trans-unit id="2886df50730aa358b631dfc37a5f87ecf532d285" translate="yes" xml:space="preserve">
          <source>When entering full-screen mode, all the translucency effects are reset for the window. Its shape is set to &lt;code&gt;null&lt;/code&gt;, the opacity value is set to 1.0f, and the background color alpha is set to 255 (completely opaque). These values are not restored when returning to windowed mode.</source>
          <target state="translated">フルスクリーンモードに入ると、ウィンドウのすべての半透明効果がリセットされます。その形状は &lt;code&gt;null&lt;/code&gt; に設定され、不透明度の値は1.0fに設定され、背景色のアルファは255（完全に不透明）に設定されます。これらの値は、ウィンドウモードに戻っても復元されません。</target>
        </trans-unit>
        <trans-unit id="80c01c7c80e86af37db5c501ac99fcd713939de9" translate="yes" xml:space="preserve">
          <source>When entering full-screen mode, if the window to be used as a full-screen window is not visible, this method will make it visible. It will remain visible when returning to windowed mode.</source>
          <target state="translated">全画面モードに入ったときに、全画面ウィンドウとして使用するウィンドウが表示されていない場合は、この方法で表示させます。ウィンドウモードに戻るときには、表示されたままになります。</target>
        </trans-unit>
        <trans-unit id="5f295f2bcf4f51adce71cb39e573a72525869fe4" translate="yes" xml:space="preserve">
          <source>When errors are found by the validator, the parser is responsible to report them to the user-specified &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt; (or if the error handler is not set, ignore them or throw them), just like any other errors found by the parser itself. In other words, if the user-specified &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt; is set, it must receive those errors, and if not, they must be treated according to the implementation specific default error handling rules.</source>
          <target state="translated">バリデーターによってエラーが検出された場合、パーサーは、パーサー自体によって検出された他のエラーと同様に、ユーザー指定の&lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; &lt;/a&gt;にエラーを報告します（または、エラーハンドラーが設定されていない場合は、無視するか、スローします）。つまり、ユーザー指定の&lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; &lt;/a&gt;が設定されている場合は、それらのエラーを受信する必要があり、そうでない場合は、実装固有のデフォルトのエラー処理ルールに従って処理する必要があります。</target>
        </trans-unit>
        <trans-unit id="519e81f7ec22f984619e01262e1e5c7f97e82d8a" translate="yes" xml:space="preserve">
          <source>When executed in parallel, multiple intermediate results may be instantiated, populated, and merged so as to maintain isolation of mutable data structures. Therefore, even when executed in parallel with non-thread-safe data structures (such as &lt;code&gt;ArrayList&lt;/code&gt;), no additional synchronization is needed for a parallel reduction.</source>
          <target state="translated">並列実行すると、可変データ構造の分離を維持するために、複数の中間結果がインスタンス化、入力、およびマージされます。したがって、スレッドセーフではないデータ構造（ &lt;code&gt;ArrayList&lt;/code&gt; など）と並行して実行された場合でも、並行縮小のために追加の同期は必要ありません。</target>
        </trans-unit>
        <trans-unit id="e56182ec56b64aac2076f02ce7d0f6f5838a88a0" translate="yes" xml:space="preserve">
          <source>When expanding the services that a module uses or provides then the onus is on the agent to ensure that the service type will be accessible at each instrumentation site where the service type is used. This method does not check if the service type is a member of the module or in a package exported to the module by another module that it reads.</source>
          <target state="translated">モジュールが使用または提供するサービスを拡張するとき、サービス・タイプが使用される各計装サイトでサービス・タイプがアクセス可能であることを確実にするために、エージェントに責任があります。このメソッドは、サービス・タイプがモジュールのメンバであるか、またはモジュールが読み取る別のモジュールによってモジュールにエクスポートされたパッケージ内にあるかどうかをチェックしません。</target>
        </trans-unit>
        <trans-unit id="7f0b5af857f1afde8bd6a1ceed3f08040c8b1571" translate="yes" xml:space="preserve">
          <source>When factor is, for example, 0.5f the result represents 'the mid-point' of its input - an operation that is useful for centering components in a container.</source>
          <target state="translated">factorが例えば0.5fの場合、結果は入力の「中点」を表します。</target>
        </trans-unit>
        <trans-unit id="d7ba7db81667141a1f9fae4de090c1beacde1d2f" translate="yes" xml:space="preserve">
          <source>When first constructed, an &lt;code&gt;X509CRLSelector&lt;/code&gt; has no criteria enabled and each of the &lt;code&gt;get&lt;/code&gt; methods return a default value (&lt;code&gt;null&lt;/code&gt;). Therefore, the &lt;a href=&quot;#match(java.security.cert.CRL)&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; method would return &lt;code&gt;true&lt;/code&gt; for any &lt;code&gt;X509CRL&lt;/code&gt;. Typically, several criteria are enabled (by calling &lt;a href=&quot;#setIssuers(java.util.Collection)&quot;&gt;&lt;code&gt;setIssuers&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#setDateAndTime(java.util.Date)&quot;&gt;&lt;code&gt;setDateAndTime&lt;/code&gt;&lt;/a&gt;, for instance) and then the &lt;code&gt;X509CRLSelector&lt;/code&gt; is passed to &lt;a href=&quot;certstore#getCRLs(java.security.cert.CRLSelector)&quot;&gt;&lt;code&gt;CertStore.getCRLs&lt;/code&gt;&lt;/a&gt; or some similar method.</source>
          <target state="translated">&lt;code&gt;X509CRLSelector&lt;/code&gt; が最初に構築されたとき、基準は有効になっておらず、各 &lt;code&gt;get&lt;/code&gt; メソッドはデフォルト値（ &lt;code&gt;null&lt;/code&gt; ）を返します。したがって、&lt;a href=&quot;#match(java.security.cert.CRL)&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt;メソッドはすべての &lt;code&gt;X509CRL&lt;/code&gt; に対して &lt;code&gt;true&lt;/code&gt; を返します。通常、いくつかの基準が有効になり（&lt;a href=&quot;#setDateAndTime(java.util.Date)&quot;&gt; &lt;code&gt;setDateAndTime&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#setIssuers(java.util.Collection)&quot;&gt; &lt;code&gt;setIssuers&lt;/code&gt; &lt;/a&gt;またはsetDateAndTimeを呼び出すことによって）、 &lt;code&gt;X509CRLSelector&lt;/code&gt; が&lt;a href=&quot;certstore#getCRLs(java.security.cert.CRLSelector)&quot;&gt; &lt;code&gt;CertStore.getCRLs&lt;/code&gt; &lt;/a&gt;または同様のメソッドに渡されます。</target>
        </trans-unit>
        <trans-unit id="9649a12169ece945cbfdacee36bb86668bdc338e" translate="yes" xml:space="preserve">
          <source>When first constructed, an &lt;code&gt;X509CRLSelector&lt;/code&gt; has no criteria enabled and each of the &lt;code&gt;get&lt;/code&gt; methods return a default value (&lt;code&gt;null&lt;/code&gt;). Therefore, the &lt;a href=&quot;x509crlselector#match-java.security.cert.CRL-&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; method would return &lt;code&gt;true&lt;/code&gt; for any &lt;code&gt;X509CRL&lt;/code&gt;. Typically, several criteria are enabled (by calling &lt;a href=&quot;x509crlselector#setIssuers-java.util.Collection-&quot;&gt;&lt;code&gt;setIssuers&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;x509crlselector#setDateAndTime-java.util.Date-&quot;&gt;&lt;code&gt;setDateAndTime&lt;/code&gt;&lt;/a&gt;, for instance) and then the &lt;code&gt;X509CRLSelector&lt;/code&gt; is passed to &lt;a href=&quot;certstore#getCRLs-java.security.cert.CRLSelector-&quot;&gt;&lt;code&gt;CertStore.getCRLs&lt;/code&gt;&lt;/a&gt; or some similar method.</source>
          <target state="translated">最初に構築されたとき、 &lt;code&gt;X509CRLSelector&lt;/code&gt; には有効化された基準がなく、各 &lt;code&gt;get&lt;/code&gt; メソッドはデフォルト値（ &lt;code&gt;null&lt;/code&gt; ）を返します。したがって、&lt;a href=&quot;x509crlselector#match-java.security.cert.CRL-&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt;メソッドは &lt;code&gt;X509CRL&lt;/code&gt; に対して &lt;code&gt;true&lt;/code&gt; を返します。通常、いくつかの基準が有効になり（&lt;a href=&quot;x509crlselector#setDateAndTime-java.util.Date-&quot;&gt; &lt;code&gt;setDateAndTime&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;x509crlselector#setIssuers-java.util.Collection-&quot;&gt; &lt;code&gt;setIssuers&lt;/code&gt; &lt;/a&gt;またはsetDateAndTimeを呼び出すことにより）、 &lt;code&gt;X509CRLSelector&lt;/code&gt; が&lt;a href=&quot;certstore#getCRLs-java.security.cert.CRLSelector-&quot;&gt; &lt;code&gt;CertStore.getCRLs&lt;/code&gt; &lt;/a&gt;または同様のメソッドに渡されます。</target>
        </trans-unit>
        <trans-unit id="20860ac3af47ff5e6527ceeb9db68080e38b9d93" translate="yes" xml:space="preserve">
          <source>When first constructed, an &lt;code&gt;X509CertSelector&lt;/code&gt; has no criteria enabled and each of the &lt;code&gt;get&lt;/code&gt; methods return a default value (&lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;-1&lt;/code&gt; for the &lt;a href=&quot;#getBasicConstraints()&quot;&gt;&lt;code&gt;getBasicConstraints&lt;/code&gt;&lt;/a&gt; method). Therefore, the &lt;a href=&quot;#match(java.security.cert.Certificate)&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; method would return &lt;code&gt;true&lt;/code&gt; for any &lt;code&gt;X509Certificate&lt;/code&gt;. Typically, several criteria are enabled (by calling &lt;a href=&quot;#setIssuer(javax.security.auth.x500.X500Principal)&quot;&gt;&lt;code&gt;setIssuer&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#setKeyUsage(boolean%5B%5D)&quot;&gt;&lt;code&gt;setKeyUsage&lt;/code&gt;&lt;/a&gt;, for instance) and then the &lt;code&gt;X509CertSelector&lt;/code&gt; is passed to &lt;a href=&quot;certstore#getCertificates(java.security.cert.CertSelector)&quot;&gt;&lt;code&gt;CertStore.getCertificates&lt;/code&gt;&lt;/a&gt; or some similar method.</source>
          <target state="translated">最初に構成するとき、 &lt;code&gt;X509CertSelector&lt;/code&gt; のは全く基準が有効いないとのそれぞれ &lt;code&gt;get&lt;/code&gt; メソッドは、（デフォルトの値を返す &lt;code&gt;null&lt;/code&gt; 、または &lt;code&gt;-1&lt;/code&gt; ため&lt;a href=&quot;#getBasicConstraints()&quot;&gt; &lt;code&gt;getBasicConstraints&lt;/code&gt; の&lt;/a&gt;方法）。したがって、&lt;a href=&quot;#match(java.security.cert.Certificate)&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt;メソッドはすべての &lt;code&gt;X509Certificate&lt;/code&gt; に対して &lt;code&gt;true&lt;/code&gt; を返します。通常、いくつかの基準が有効になり（&lt;a href=&quot;#setKeyUsage(boolean%5B%5D)&quot;&gt; &lt;code&gt;setKeyUsage&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#setIssuer(javax.security.auth.x500.X500Principal)&quot;&gt; &lt;code&gt;setIssuer&lt;/code&gt; &lt;/a&gt;またはsetKeyUsageを呼び出すことにより）、 &lt;code&gt;X509CertSelector&lt;/code&gt; が&lt;a href=&quot;certstore#getCertificates(java.security.cert.CertSelector)&quot;&gt; &lt;code&gt;CertStore.getCertificates&lt;/code&gt; &lt;/a&gt;または同様のメソッドに渡されます。</target>
        </trans-unit>
        <trans-unit id="d650c98b41df8d2991fdd69b36d1bd6550c57b66" translate="yes" xml:space="preserve">
          <source>When first constructed, an &lt;code&gt;X509CertSelector&lt;/code&gt; has no criteria enabled and each of the &lt;code&gt;get&lt;/code&gt; methods return a default value (&lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;-1&lt;/code&gt; for the &lt;a href=&quot;x509certselector#getBasicConstraints--&quot;&gt;&lt;code&gt;getBasicConstraints&lt;/code&gt;&lt;/a&gt; method). Therefore, the &lt;a href=&quot;x509certselector#match-java.security.cert.Certificate-&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; method would return &lt;code&gt;true&lt;/code&gt; for any &lt;code&gt;X509Certificate&lt;/code&gt;. Typically, several criteria are enabled (by calling &lt;a href=&quot;x509certselector#setIssuer-javax.security.auth.x500.X500Principal-&quot;&gt;&lt;code&gt;setIssuer&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;x509certselector#setKeyUsage-boolean:A-&quot;&gt;&lt;code&gt;setKeyUsage&lt;/code&gt;&lt;/a&gt;, for instance) and then the &lt;code&gt;X509CertSelector&lt;/code&gt; is passed to &lt;a href=&quot;certstore#getCertificates-java.security.cert.CertSelector-&quot;&gt;&lt;code&gt;CertStore.getCertificates&lt;/code&gt;&lt;/a&gt; or some similar method.</source>
          <target state="translated">最初に構成するとき、 &lt;code&gt;X509CertSelector&lt;/code&gt; のは全く基準が有効いないとのそれぞれ &lt;code&gt;get&lt;/code&gt; メソッドは、（デフォルトの値を返す &lt;code&gt;null&lt;/code&gt; 、または &lt;code&gt;-1&lt;/code&gt; ため&lt;a href=&quot;x509certselector#getBasicConstraints--&quot;&gt; &lt;code&gt;getBasicConstraints&lt;/code&gt; の&lt;/a&gt;方法）。したがって、すべての &lt;code&gt;X509Certificate&lt;/code&gt; で&lt;a href=&quot;x509certselector#match-java.security.cert.Certificate-&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt;メソッドは &lt;code&gt;true&lt;/code&gt; を返します。通常、いくつかの基準が有効になり（&lt;a href=&quot;x509certselector#setKeyUsage-boolean:A-&quot;&gt; &lt;code&gt;setKeyUsage&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;x509certselector#setIssuer-javax.security.auth.x500.X500Principal-&quot;&gt; &lt;code&gt;setIssuer&lt;/code&gt; &lt;/a&gt;またはsetKeyUsageを呼び出すことにより）、 &lt;code&gt;X509CertSelector&lt;/code&gt; が&lt;a href=&quot;certstore#getCertificates-java.security.cert.CertSelector-&quot;&gt; &lt;code&gt;CertStore.getCertificates&lt;/code&gt; &lt;/a&gt;または同様のメソッドに渡されます。</target>
        </trans-unit>
        <trans-unit id="6bdbc4072fa0aa2a890b6aafd2d77f59bcdf8288" translate="yes" xml:space="preserve">
          <source>When flip contents are &lt;code&gt;BACKGROUND&lt;/code&gt;, the contents of the back buffer are cleared with the background color after flipping.</source>
          <target state="translated">フリップの内容が &lt;code&gt;BACKGROUND&lt;/code&gt; の場合、フリップ後にバックバッファの内容が背景色でクリアされます。</target>
        </trans-unit>
        <trans-unit id="63cdfb20b747808fb558b523ddbdc11e871de470" translate="yes" xml:space="preserve">
          <source>When flip contents are &lt;code&gt;COPIED&lt;/code&gt;, the contents of the back buffer are copied to the front buffer when flipping.</source>
          <target state="translated">フリップの内容が &lt;code&gt;COPIED&lt;/code&gt; の場合、フリップ時にバックバッファの内容がフロントバッファにコピーされます。</target>
        </trans-unit>
        <trans-unit id="b82198f8743b3ee395f98263a6da347029744bd3" translate="yes" xml:space="preserve">
          <source>When flip contents are &lt;code&gt;PRIOR&lt;/code&gt;, the contents of the back buffer are the prior contents of the front buffer (a true page flip).</source>
          <target state="translated">フリップの内容が &lt;code&gt;PRIOR&lt;/code&gt; の場合、バックバッファの内容はフロントバッファの以前の内容になります（真のページフリップ）。</target>
        </trans-unit>
        <trans-unit id="6e1e2b99b6522b5b56f0b7775f1acd75a21bc115" translate="yes" xml:space="preserve">
          <source>When flip contents are &lt;code&gt;UNDEFINED&lt;/code&gt;, the contents of the back buffer are undefined after flipping.</source>
          <target state="translated">フリップ内容がある場合 &lt;code&gt;UNDEFINED&lt;/code&gt; 、バックバッファの内容が反転した後不定です。</target>
        </trans-unit>
        <trans-unit id="0ff93d04cdedfee3d54c1d406cb192a14d80e305" translate="yes" xml:space="preserve">
          <source>When formatting, if the temporal object contains a date, then it will be converted to a date in the override chronology. Whether the temporal contains a date is determined by querying the &lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;EPOCH_DAY&lt;/code&gt;&lt;/a&gt; field. Any time or zone will be retained unaltered unless overridden.</source>
          <target state="translated">書式設定時に、一時オブジェクトに日付が含まれている場合、それはオーバーライド年表で日付に変換されます。テンポラルに日付が含まれているかどうかは、&lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;EPOCH_DAY&lt;/code&gt; &lt;/a&gt;フィールドをクエリすることによって決定されます。オーバーライドしない限り、時間またはゾーンは変更されずに保持されます。</target>
        </trans-unit>
        <trans-unit id="c46c21d901a51405a6408d147e04ecbd8a3f7e31" translate="yes" xml:space="preserve">
          <source>When formatting, if the temporal object contains an instant, then it will be converted to a zoned date-time using the override zone. Whether the temporal is an instant is determined by querying the &lt;a href=&quot;../temporal/chronofield#INSTANT_SECONDS&quot;&gt;&lt;code&gt;INSTANT_SECONDS&lt;/code&gt;&lt;/a&gt; field. If the input has a chronology then it will be retained unless overridden. If the input does not have a chronology, such as &lt;code&gt;Instant&lt;/code&gt;, then the ISO chronology will be used.</source>
          <target state="translated">書式設定時に、一時オブジェクトにインスタントが含まれている場合、オーバーライドゾーンを使用してゾーン化された日時に変換されます。テンポラルがインスタントかどうかは、&lt;a href=&quot;../temporal/chronofield#INSTANT_SECONDS&quot;&gt; &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; &lt;/a&gt;フィールドを照会することによって決定されます。入力に年表がある場合、上書きされない限り保持されます。入力に &lt;code&gt;Instant&lt;/code&gt; などの年表がない場合は、ISO年表が使用されます。</target>
        </trans-unit>
        <trans-unit id="e3ccef18e16794ea6e4ca8f3deb0092f315cf23d" translate="yes" xml:space="preserve">
          <source>When four parts are specified, each is interpreted as a byte of data and assigned, from left to right, to the four bytes of an IPv4 address.</source>
          <target state="translated">4 つのパーツを指定した場合、それぞれを 1 バイトのデータとして解釈し、左から右へ IPv4 アドレスの 4 バイトに割り当てます。</target>
        </trans-unit>
        <trans-unit id="774dda26093b2a90cd6b2fb725005764df15f2fa" translate="yes" xml:space="preserve">
          <source>When getting a run with no explicit attributes specified (i.e., calling &lt;a href=&quot;#getRunStart()&quot;&gt;&lt;code&gt;getRunStart()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#getRunLimit()&quot;&gt;&lt;code&gt;getRunLimit()&lt;/code&gt;&lt;/a&gt;), any contiguous text segments having the same attributes (the same set of attribute/value pairs) are treated as separate runs if the attributes have been given to those text segments separately.</source>
          <target state="translated">明示的な属性が指定されていない実行を取得する場合（つまり、&lt;a href=&quot;#getRunStart()&quot;&gt; &lt;code&gt;getRunStart()&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#getRunLimit()&quot;&gt; &lt;code&gt;getRunLimit()&lt;/code&gt; を&lt;/a&gt;呼び出す場合）、同じ属性（同じ属性/値のペアのセット）を持つ連続するテキストセグメントは、属性が指定されている場合は個別の実行として扱われます。それらのテキストセグメントに個別に与えられます。</target>
        </trans-unit>
        <trans-unit id="1ae85906e6fddb6d1dc408436e61d763b88ac485" translate="yes" xml:space="preserve">
          <source>When getting a run with no explicit attributes specified (i.e., calling &lt;a href=&quot;attributedcharacteriterator#getRunStart--&quot;&gt;&lt;code&gt;getRunStart()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;attributedcharacteriterator#getRunLimit--&quot;&gt;&lt;code&gt;getRunLimit()&lt;/code&gt;&lt;/a&gt;), any contiguous text segments having the same attributes (the same set of attribute/value pairs) are treated as separate runs if the attributes have been given to those text segments separately.</source>
          <target state="translated">明示的な属性が指定されていない実行を取得する（つまり、&lt;a href=&quot;attributedcharacteriterator#getRunStart--&quot;&gt; &lt;code&gt;getRunStart()&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;attributedcharacteriterator#getRunLimit--&quot;&gt; &lt;code&gt;getRunLimit()&lt;/code&gt; を&lt;/a&gt;呼び出す）と、同じ属性（同じ属性/値のペアのセット）を持つ連続したテキストセグメントは、属性が別の実行として扱われます。それらのテキストセグメントに個別に与えられます。</target>
        </trans-unit>
        <trans-unit id="b5ba05bc071c59eee04254d6fa68df75d14578d6" translate="yes" xml:space="preserve">
          <source>When initially formatting a value if the length of the string is less than the length of the mask, two things can happen. Either the placeholder string will be used, or the placeholder character will be used. Precedence is given to the placeholder string. For example:</source>
          <target state="translated">文字列の長さがマスクの長さよりも小さい場合に値を最初にフォーマットすると、2つのことが起こります。プレースホルダ文字列が使用されるか、プレースホルダ文字が使用されます。プレースホルダ文字列が優先されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="8dd1bcbc018d3b4bb41eefe5512da3834ff920d7" translate="yes" xml:space="preserve">
          <source>When invoked on an &lt;code&gt;ArrayType&lt;/code&gt; instance, the &lt;a href=&quot;opentype#getClassName()&quot;&gt;&lt;code&gt;getClassName&lt;/code&gt;&lt;/a&gt; method returns the class name of the array instances it describes (following the rules defined by the &lt;a href=&quot;../../../../java.base/java/lang/class#getName()&quot;&gt;&lt;code&gt;getName&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;java.lang.Class&lt;/code&gt;), not the class name of the array elements (which is returned by a call to &lt;code&gt;getElementOpenType().getClassName()&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;ArrayType&lt;/code&gt; インスタンスで呼び出されると、&lt;a href=&quot;opentype#getClassName()&quot;&gt; &lt;code&gt;getClassName&lt;/code&gt; &lt;/a&gt;メソッドは、配列要素のクラス名（によって返される）ではなく、記述されている配列インスタンスのクラス名を返します（ &lt;code&gt;java.lang.Class&lt;/code&gt; の&lt;a href=&quot;../../../../java.base/java/lang/class#getName()&quot;&gt; &lt;code&gt;getName&lt;/code&gt; &lt;/a&gt;メソッドによって定義されたルールに従います）。 &lt;code&gt;getElementOpenType().getClassName()&lt;/code&gt; 呼び出し）。</target>
        </trans-unit>
        <trans-unit id="302acd17292bb6cb5b2e63e5ea447c50cffa715c" translate="yes" xml:space="preserve">
          <source>When invoked on an &lt;code&gt;ArrayType&lt;/code&gt; instance, the &lt;a href=&quot;opentype#getClassName--&quot;&gt;&lt;code&gt;getClassName&lt;/code&gt;&lt;/a&gt; method returns the class name of the array instances it describes (following the rules defined by the &lt;a href=&quot;../../../java/lang/class#getName--&quot;&gt;&lt;code&gt;getName&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;java.lang.Class&lt;/code&gt;), not the class name of the array elements (which is returned by a call to &lt;code&gt;getElementOpenType().getClassName()&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;ArrayType&lt;/code&gt; インスタンスで呼び出されると、&lt;a href=&quot;opentype#getClassName--&quot;&gt; &lt;code&gt;getClassName&lt;/code&gt; &lt;/a&gt;メソッドは、（ &lt;code&gt;java.lang.Class&lt;/code&gt; の&lt;a href=&quot;../../../java/lang/class#getName--&quot;&gt; &lt;code&gt;getName&lt;/code&gt; &lt;/a&gt;メソッドで定義された規則に従って）配列要素のクラス名（これは、 &lt;code&gt;getElementOpenType().getClassName()&lt;/code&gt; への呼び出し）。</target>
        </trans-unit>
        <trans-unit id="580b70b0aa9940a4d315897412a3c8e6a50c10fb" translate="yes" xml:space="preserve">
          <source>When it is desirable to group together a number of Permission objects of the same type, the &lt;code&gt;newPermissionCollection&lt;/code&gt; method on that particular type of Permission object should first be called. The default behavior (from the Permission class) is to simply return null. Subclasses of class Permission override the method if they need to store their permissions in a particular PermissionCollection object in order to provide the correct semantics when the &lt;code&gt;PermissionCollection.implies&lt;/code&gt; method is called. If a non-null value is returned, that PermissionCollection must be used. If null is returned, then the caller of &lt;code&gt;newPermissionCollection&lt;/code&gt; is free to store permissions of the given type in any PermissionCollection they choose (one that uses a Hashtable, one that uses a Vector, etc).</source>
          <target state="translated">同じタイプの複数のPermissionオブジェクトをグループ化することが望ましい場合は、その特定のタイプのPermissionオブジェクトの &lt;code&gt;newPermissionCollection&lt;/code&gt; メソッドを最初に呼び出す必要があります。（Permissionクラスの）デフォルトの動作は、単にnullを返すことです。 &lt;code&gt;PermissionCollection.implies&lt;/code&gt; メソッドが呼び出されたときに正しいセマンティクスを提供するために特定のPermissionCollectionオブジェクトに権限を格納する必要がある場合、クラスPermissionのサブクラスはメソッドをオーバーライドします。null以外の値が返される場合は、そのPermissionCollectionを使用する必要があります。nullが返された場合、 &lt;code&gt;newPermissionCollection&lt;/code&gt; の呼び出し元 選択した任意のPermissionCollection（Hashtableを使用するもの、Vectorを使用するものなど）に、特定のタイプの権限を自由に格納できます。</target>
        </trans-unit>
        <trans-unit id="ce33c85f5d00ceaaf151e94b617d0fd035ff89e8" translate="yes" xml:space="preserve">
          <source>When leaf Views (such as LabelView) are rendering they should call into this method.</source>
          <target state="translated">リーフビュー (LabelView など)がレンダリングされているときは、このメソッドを呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="bf1e959633bde681b0bed5cc3b7b643970517499" translate="yes" xml:space="preserve">
          <source>When leaf Views (such as LabelView) are rendering they should call into this method. If a highlight is in the given region it will be drawn immediately.</source>
          <target state="translated">リーフビュー (LabelView など)がレンダリングされているときは、このメソッドを呼び出す必要があります。もしハイライトが指定された領域にある場合は、すぐに描画されます。</target>
        </trans-unit>
        <trans-unit id="174a6496db7aea116f5760d2cbbff2da29431d36" translate="yes" xml:space="preserve">
          <source>When loading or instantiating a service provider in a module, &lt;code&gt;
 ServiceConfigurationError&lt;/code&gt; can be thrown for the following reasons:</source>
          <target state="translated">モジュールでサービスプロバイダーをロードまたはインスタンス化する場合、次の理由で &lt;code&gt; ServiceConfigurationError&lt;/code&gt; がスローされる可能性があります。</target>
        </trans-unit>
        <trans-unit id="4328d60614b67a469dcc46dc7b40428e7a16ab80" translate="yes" xml:space="preserve">
          <source>When locating modules then any exceptions or errors thrown by the &lt;code&gt;find&lt;/code&gt; or &lt;code&gt;findAll&lt;/code&gt; methods of the underlying module finders will be propagated to the caller of the resulting module finder's &lt;code&gt;find&lt;/code&gt; or &lt;code&gt;findAll&lt;/code&gt; methods.</source>
          <target state="translated">モジュールを見つけるとき、基礎となるモジュールファインダーの &lt;code&gt;find&lt;/code&gt; または &lt;code&gt;findAll&lt;/code&gt; メソッドによってスローされた例外またはエラーは、結果のモジュールファインダーの &lt;code&gt;find&lt;/code&gt; または &lt;code&gt;findAll&lt;/code&gt; メソッドの呼び出し元に伝播されます。</target>
        </trans-unit>
        <trans-unit id="16ba2f01e5d521afc7a1d8765c061f6962009acc" translate="yes" xml:space="preserve">
          <source>When locking and unlocking occur in different scopes, care must be taken to ensure that all code that is executed while the lock is held is protected by try-finally or try-catch to ensure that the lock is released when necessary.</source>
          <target state="translated">ロックとアンロックが異なるスコープで発生する場合、ロックが保持されている間に実行されるすべてのコードがtry-finallyまたはtry-catchで保護され、必要なときにロックが解除されるように注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="d0d60a7362268503ac5f29c4e995b665bfa49ca4" translate="yes" xml:space="preserve">
          <source>When logging is enabled for the given level, the default implementation for this method calls &lt;code&gt;this.log(level, (ResourceBundle)null, msgSupplier.get(), (Object[])null);&lt;/code&gt;</source>
          <target state="translated">指定されたレベルでロギングが有効になっている場合、このメソッドのデフォルトの実装は &lt;code&gt;this.log(level, (ResourceBundle)null, msgSupplier.get(), (Object[])null);&lt;/code&gt; 呼び出します。</target>
        </trans-unit>
        <trans-unit id="4b48d582b593f5a0b71b33ebfba543a2007aa703" translate="yes" xml:space="preserve">
          <source>When logging is enabled for the given level, the default implementation for this method calls &lt;code&gt;this.log(level, (ResourceBundle)null, msgSupplier.get(), thrown);&lt;/code&gt;</source>
          <target state="translated">指定されたレベルでロギングが有効になっている場合、このメソッドのデフォルトの実装は &lt;code&gt;this.log(level, (ResourceBundle)null, msgSupplier.get(), thrown);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1dd8bd9ca02efdcd9732b7cf62a3e53ee34a950" translate="yes" xml:space="preserve">
          <source>When logging is enabled for the given level, the default implementation for this method calls &lt;code&gt;this.log(level, (ResourceBundle)null, obj.toString(), (Object[])null);&lt;/code&gt;</source>
          <target state="translated">指定されたレベルでロギングが有効になっている場合、このメソッドのデフォルトの実装は &lt;code&gt;this.log(level, (ResourceBundle)null, obj.toString(), (Object[])null);&lt;/code&gt; 呼び出します。</target>
        </trans-unit>
        <trans-unit id="b6e7f5643792532437bd221471efc47beceaab52" translate="yes" xml:space="preserve">
          <source>When looking for a &lt;code&gt;ResourceBundle&lt;/code&gt;, the logger will first look at whether a bundle was specified using &lt;a href=&quot;#setResourceBundle(java.util.ResourceBundle)&quot;&gt;&lt;code&gt;setResourceBundle&lt;/code&gt;&lt;/a&gt;, and then only whether a resource bundle name was specified through the &lt;a href=&quot;#getLogger(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;getLogger&lt;/code&gt;&lt;/a&gt; factory method. If no &lt;code&gt;ResourceBundle&lt;/code&gt; or no resource bundle name is found, then it will use the nearest &lt;code&gt;ResourceBundle&lt;/code&gt; or resource bundle name inherited from its parent tree.</source>
          <target state="translated">&lt;code&gt;ResourceBundle&lt;/code&gt; を探すとき、ロガーは最初に&lt;a href=&quot;#setResourceBundle(java.util.ResourceBundle)&quot;&gt; &lt;code&gt;setResourceBundle&lt;/code&gt; &lt;/a&gt;を使用してバンドルが指定されているかどうかを確認し、次に&lt;a href=&quot;#getLogger(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;getLogger&lt;/code&gt; &lt;/a&gt;ファクトリメソッドを使用してリソースバンドル名が指定されているかどうかのみを確認します。 &lt;code&gt;ResourceBundle&lt;/code&gt; またはリソースバンドル名が見つからない場合は、親ツリーから継承された最も近い &lt;code&gt;ResourceBundle&lt;/code&gt; またはリソースバンドル名が使用されます。</target>
        </trans-unit>
        <trans-unit id="1a0408130f81738a723c33c438670c4461590e47" translate="yes" xml:space="preserve">
          <source>When looking for a &lt;code&gt;ResourceBundle&lt;/code&gt;, the logger will first look at whether a bundle was specified using &lt;a href=&quot;logger#setResourceBundle-java.util.ResourceBundle-&quot;&gt;&lt;code&gt;setResourceBundle&lt;/code&gt;&lt;/a&gt;, and then only whether a resource bundle name was specified through the &lt;a href=&quot;logger#getLogger-java.lang.String-java.lang.String-&quot;&gt;&lt;code&gt;getLogger&lt;/code&gt;&lt;/a&gt; factory method. If no &lt;code&gt;ResourceBundle&lt;/code&gt; or no resource bundle name is found, then it will use the nearest &lt;code&gt;ResourceBundle&lt;/code&gt; or resource bundle name inherited from its parent tree.</source>
          <target state="translated">&lt;code&gt;ResourceBundle&lt;/code&gt; を探すとき、ロガーは最初に&lt;a href=&quot;logger#setResourceBundle-java.util.ResourceBundle-&quot;&gt; &lt;code&gt;setResourceBundle&lt;/code&gt; &lt;/a&gt;を使用してバンドルが指定されているかどうかを調べ、次に&lt;a href=&quot;logger#getLogger-java.lang.String-java.lang.String-&quot;&gt; &lt;code&gt;getLogger&lt;/code&gt; &lt;/a&gt;ファクトリメソッドを介してリソースバンドル名が指定されているかどうかだけを調べます。 &lt;code&gt;ResourceBundle&lt;/code&gt; またはリソースバンドル名が見つからない場合、親ツリーから継承された最も近い &lt;code&gt;ResourceBundle&lt;/code&gt; またはリソースバンドル名が使用されます。</target>
        </trans-unit>
        <trans-unit id="0a8e75474aa9a3fb3f0db3e2785307495315a60e" translate="yes" xml:space="preserve">
          <source>When looking up a time zone name, the &lt;a href=&quot;resourcebundle.control#getCandidateLocales(java.lang.String,java.util.Locale)&quot;&gt;default &lt;code&gt;Locale&lt;/code&gt;search path of &lt;code&gt;ResourceBundle&lt;/code&gt;&lt;/a&gt; derived from the specified &lt;code&gt;locale&lt;/code&gt; is used. (No &lt;a href=&quot;resourcebundle.control#getFallbackLocale(java.lang.String,java.util.Locale)&quot;&gt;fallback &lt;code&gt;Locale&lt;/code&gt;&lt;/a&gt; search is performed.) If a time zone name in any &lt;code&gt;Locale&lt;/code&gt; of the search path, including &lt;a href=&quot;locale#ROOT&quot;&gt;&lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/a&gt;, is found, the name is returned. Otherwise, a string in the &lt;a href=&quot;#NormalizedCustomID&quot;&gt;normalized custom ID format&lt;/a&gt; is returned.</source>
          <target state="translated">タイムゾーン名を&lt;a href=&quot;resourcebundle.control#getCandidateLocales(java.lang.String,java.util.Locale)&quot;&gt;検索&lt;/a&gt;するときは、指定された &lt;code&gt;locale&lt;/code&gt; から派生した &lt;code&gt;ResourceBundle&lt;/code&gt; のデフォルトの &lt;code&gt;Locale&lt;/code&gt; 検索パスが使用されます。 （&lt;a href=&quot;resourcebundle.control#getFallbackLocale(java.lang.String,java.util.Locale)&quot;&gt;フォールバック &lt;code&gt;Locale&lt;/code&gt; &lt;/a&gt;検索は実行されません。）&lt;a href=&quot;locale#ROOT&quot;&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt; &lt;/a&gt;を含む、検索パスのいずれかの &lt;code&gt;Locale&lt;/code&gt; でタイムゾーン名が見つかった場合、その名前が返されます。それ以外の場合は、&lt;a href=&quot;#NormalizedCustomID&quot;&gt;正規化されたカスタムID形式の&lt;/a&gt;文字列が返されます。</target>
        </trans-unit>
        <trans-unit id="b9993ef66f72f6a538299eeaaa5c894846a8a38b" translate="yes" xml:space="preserve">
          <source>When looking up a time zone name, the &lt;a href=&quot;resourcebundle.control#getCandidateLocales-java.lang.String-java.util.Locale-&quot;&gt;default &lt;code&gt;Locale&lt;/code&gt; search path of &lt;code&gt;ResourceBundle&lt;/code&gt;&lt;/a&gt; derived from the specified &lt;code&gt;locale&lt;/code&gt; is used. (No &lt;a href=&quot;resourcebundle.control#getFallbackLocale-java.lang.String-java.util.Locale-&quot;&gt;fallback &lt;code&gt;Locale&lt;/code&gt;&lt;/a&gt; search is performed.) If a time zone name in any &lt;code&gt;Locale&lt;/code&gt; of the search path, including &lt;a href=&quot;locale#ROOT&quot;&gt;&lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/a&gt;, is found, the name is returned. Otherwise, a string in the &lt;a href=&quot;#NormalizedCustomID&quot;&gt;normalized custom ID format&lt;/a&gt; is returned.</source>
          <target state="translated">タイムゾーン名を&lt;a href=&quot;resourcebundle.control#getCandidateLocales-java.lang.String-java.util.Locale-&quot;&gt;検索&lt;/a&gt;する場合 &lt;code&gt;Locale&lt;/code&gt; &lt;code&gt;ResourceBundle&lt;/code&gt; 、指定された &lt;code&gt;locale&lt;/code&gt; から派生したResourceBundleのデフォルトのロケール検索パスが使用されます。 （&lt;a href=&quot;resourcebundle.control#getFallbackLocale-java.lang.String-java.util.Locale-&quot;&gt;フォールバック &lt;code&gt;Locale&lt;/code&gt; &lt;/a&gt;検索は実行されません。）&lt;a href=&quot;locale#ROOT&quot;&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt; &lt;/a&gt;を含む、検索パスのいずれかの &lt;code&gt;Locale&lt;/code&gt; でタイムゾーン名が見つかった場合、その名前が返されます。それ以外の場合は、&lt;a href=&quot;#NormalizedCustomID&quot;&gt;正規化されたカスタムID形式の&lt;/a&gt;文字列が返されます。</target>
        </trans-unit>
        <trans-unit id="82f732f406e110c12eb9e6c2262a006ddaeaa4e2" translate="yes" xml:space="preserve">
          <source>When mapping resource bundle names to &lt;code&gt;ResourceBundle&lt;/code&gt; objects, the logger will first try to use the Thread's &lt;a href=&quot;../../../../java.base/java/lang/thread#getContextClassLoader()&quot;&gt;context class loader&lt;/a&gt; to map the given resource bundle name to a &lt;code&gt;ResourceBundle&lt;/code&gt;. If the thread context class loader is &lt;code&gt;null&lt;/code&gt;, it will try the &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt;system class loader&lt;/a&gt; instead. If the &lt;code&gt;ResourceBundle&lt;/code&gt; is still not found, it will use the class loader of the first caller of the &lt;a href=&quot;#getLogger(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;getLogger&lt;/code&gt;&lt;/a&gt; factory method.</source>
          <target state="translated">リソースバンドル名を &lt;code&gt;ResourceBundle&lt;/code&gt; オブジェクトにマッピングする場合、ロガーは最初にスレッドの&lt;a href=&quot;../../../../java.base/java/lang/thread#getContextClassLoader()&quot;&gt;コンテキストクラスローダー&lt;/a&gt;を使用して、指定されたリソースバンドル名を &lt;code&gt;ResourceBundle&lt;/code&gt; にマッピングしようとします。スレッドコンテキストクラスローダーが &lt;code&gt;null&lt;/code&gt; の場合、代わりに&lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt;システムクラスローダー&lt;/a&gt;が試行されます。それでも &lt;code&gt;ResourceBundle&lt;/code&gt; が見つからない場合は、&lt;a href=&quot;#getLogger(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;getLogger&lt;/code&gt; &lt;/a&gt;ファクトリメソッドの最初の呼び出し元のクラスローダーが使用されます。</target>
        </trans-unit>
        <trans-unit id="be5fb3253fce93d08c0e8b8dd053dbdf2da012a3" translate="yes" xml:space="preserve">
          <source>When mapping resource bundle names to &lt;code&gt;ResourceBundle&lt;/code&gt; objects, the logger will first try to use the Thread's &lt;a href=&quot;../../lang/thread#getContextClassLoader--&quot;&gt;context class loader&lt;/a&gt; to map the given resource bundle name to a &lt;code&gt;ResourceBundle&lt;/code&gt;. If the thread context class loader is &lt;code&gt;null&lt;/code&gt;, it will try the &lt;a href=&quot;../../lang/classloader#getSystemClassLoader--&quot;&gt;system class loader&lt;/a&gt; instead. If the &lt;code&gt;ResourceBundle&lt;/code&gt; is still not found, it will use the class loader of the first caller of the &lt;a href=&quot;logger#getLogger-java.lang.String-java.lang.String-&quot;&gt;&lt;code&gt;getLogger&lt;/code&gt;&lt;/a&gt; factory method.</source>
          <target state="translated">リソースバンドル名を &lt;code&gt;ResourceBundle&lt;/code&gt; オブジェクトにマッピングする場合、ロガーは最初にスレッドの&lt;a href=&quot;../../lang/thread#getContextClassLoader--&quot;&gt;コンテキストクラスローダー&lt;/a&gt;を使用して、指定されたリソースバンドル名を &lt;code&gt;ResourceBundle&lt;/code&gt; にマッピングしようとします。スレッドコンテキストクラスローダーが &lt;code&gt;null&lt;/code&gt; の場合、代わりに&lt;a href=&quot;../../lang/classloader#getSystemClassLoader--&quot;&gt;システムクラスローダー&lt;/a&gt;を試行します。それでも &lt;code&gt;ResourceBundle&lt;/code&gt; が見つからない場合は、&lt;a href=&quot;logger#getLogger-java.lang.String-java.lang.String-&quot;&gt; &lt;code&gt;getLogger&lt;/code&gt; &lt;/a&gt;ファクトリメソッドの最初の呼び出し元のクラスローダーを使用します。</target>
        </trans-unit>
        <trans-unit id="5817dccb8a24dc56e1279e061808065c8af108b0" translate="yes" xml:space="preserve">
          <source>When multiple certificates are available for use in a handshake, the implementation chooses what it considers the &quot;best&quot; certificate chain available, and transmits that to the other side. This method allows the caller to know which certificate chain was actually sent.</source>
          <target state="translated">ハンドシェイクで複数の証明書が利用可能な場合、実装は、利用可能な「最良の」証明書チェインを選択し、それを相手側に送信する。このメソッドにより、呼び出し元はどの証明書チェーンが実際に送信されたのかを知ることができます。</target>
        </trans-unit>
        <trans-unit id="e3c423c16dcc60cd6b3423d29ca5549e570d4cde" translate="yes" xml:space="preserve">
          <source>When multiple certificates are available for use in a handshake, the implementation chooses what it considers the &quot;best&quot; certificate chain available, and transmits that to the other side. This method allows the caller to know which certificate chain was actually used.</source>
          <target state="translated">ハンドシェイクで複数の証明書が利用可能な場合、実装は、利用可能な「最良の」証明書チェインを選択し、それを相手側に送信する。このメソッドにより、呼び出し元はどの証明書チェーンが実際に使用されたかを知ることができる。</target>
        </trans-unit>
        <trans-unit id="e850be999ec8886286adca7b7397c7e98dbc4504" translate="yes" xml:space="preserve">
          <source>When multiple mouse buttons are pressed, each press, release, and click results in a separate event.</source>
          <target state="translated">複数のマウスボタンが押された場合、押す、離す、クリックするごとに別々のイベントが発生します。</target>
        </trans-unit>
        <trans-unit id="b583a6caec2f5a60ad8b2a97fc56411186997e09" translate="yes" xml:space="preserve">
          <source>When multiple threads attempt updates, map operations and the remapping function may be called multiple times.</source>
          <target state="translated">複数のスレッドが更新を試みる場合、マップ操作とリマップ関数が複数回呼び出されることがあります。</target>
        </trans-unit>
        <trans-unit id="421a63f8d081ab15313773fe4ca2f494ee90642e" translate="yes" xml:space="preserve">
          <source>When names are tested for equality, attribute types, both binary and string values, are case-insensitive. String values with different but equivalent usage of quoting, escaping, or UTF8-hex-encoding are considered equal. The order of components in multi-valued RDNs (such as &quot;ou=Sales+cn=Bob&quot;) is not significant.</source>
          <target state="translated">名前が等しいかどうかがテストされるとき、属性型はバイナリ値と文字列値の両方で大文字小文字を区別しません。クォーティング、エスケープ、または UTF8-hex-encoding の使用法が異なるが同等の文字列値は、等しいとみなされます。多値RDNの構成要素の順序は重要ではありません(&quot;ou=Sales+cn=Bob &quot;など)。</target>
        </trans-unit>
        <trans-unit id="6883b8562675f0154aa3d30123f4e8a85ff6259b" translate="yes" xml:space="preserve">
          <source>When not already closed, the &lt;code&gt;close&lt;/code&gt; method of &lt;code&gt;
 FilterOutputStream&lt;/code&gt; calls its &lt;code&gt;flush&lt;/code&gt; method, and then calls the &lt;code&gt;close&lt;/code&gt; method of its underlying output stream.</source>
          <target state="translated">&lt;code&gt; FilterOutputStream&lt;/code&gt; の &lt;code&gt;close&lt;/code&gt; メソッドは、まだ閉じられていない場合、その &lt;code&gt;flush&lt;/code&gt; メソッドを呼び出してから、基になる出力ストリームの &lt;code&gt;close&lt;/code&gt; メソッドを呼び出します。</target>
        </trans-unit>
        <trans-unit id="4a545d4bb404c11d8dba04dd5da469b88f7c0cfb" translate="yes" xml:space="preserve">
          <source>When not using the try-with-resources construct, then directory stream's &lt;code&gt;close&lt;/code&gt; method should be invoked after iteration is completed so as to free any resources held for the open directory.</source>
          <target state="translated">try-with-resourcesコンストラクトを使用しない場合、反復が完了した後にディレクトリストリームの &lt;code&gt;close&lt;/code&gt; メソッドを呼び出して、開いているディレクトリ用に保持されているリソースを解放する必要があります。</target>
        </trans-unit>
        <trans-unit id="f0eff43acb661f5302995be06d4dfab4083a1196" translate="yes" xml:space="preserve">
          <source>When one of the &lt;code&gt;showXxxDialog&lt;/code&gt; methods returns an integer, the possible values are:</source>
          <target state="translated">&lt;code&gt;showXxxDialog&lt;/code&gt; メソッドの1つが整数を返す場合、可能な値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="08da4f2fc44fc2ee4201a796e38c5af9ee0a82e4" translate="yes" xml:space="preserve">
          <source>When one of those methods is invoked, its behavior is to delegate to a corresponding method on an instance of this class. The details of how each method delegates to the provider instance is described in the documentation for each particular method. See the documentation for &lt;a href=&quot;rmiclassloader&quot;&gt;&lt;code&gt;RMIClassLoader&lt;/code&gt;&lt;/a&gt; for a description of how a provider instance is chosen.</source>
          <target state="translated">これらのメソッドの1つが呼び出されると、その動作は、このクラスのインスタンスの対応するメソッドに委任することです。各メソッドがプロバイダーインスタンスに委任する方法の詳細は、特定の各メソッドのドキュメントに記載されています。プロバイダーインスタンスの選択方法の説明については、&lt;a href=&quot;rmiclassloader&quot;&gt; &lt;code&gt;RMIClassLoader&lt;/code&gt; &lt;/a&gt;のドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="61d8ce27b955b14a389038bf014cbe85cc67752c" translate="yes" xml:space="preserve">
          <source>When one sends a message to a multicast group, &lt;b&gt;all&lt;/b&gt; subscribing recipients to that host and port receive the message (within the time-to-live range of the packet, see below). The socket needn't be a member of the multicast group to send messages to it.</source>
          <target state="translated">マルチキャストグループにメッセージを送信すると、そのホストとポートにサブスクライブしている&lt;b&gt;すべての&lt;/b&gt;受信者がメッセージを受信します（パケットの存続可能時間の範囲内。以下を参照）。ソケットは、メッセージを送信するためにマルチキャストグループのメンバーである必要はありません。</target>
        </trans-unit>
        <trans-unit id="2c665e1ac4c57d3ccf2437d891eb0ae431f77c0f" translate="yes" xml:space="preserve">
          <source>When only one part is given, the value is stored directly in the network address without any byte rearrangement.</source>
          <target state="translated">1 つの部分だけが与えられた場合、値はバイトの再配置なしにネットワークアドレスに直接格納されます。</target>
        </trans-unit>
        <trans-unit id="1875b9065ed910ca6ec4ee04408f7621f55c467c" translate="yes" xml:space="preserve">
          <source>When opening an existing file, the file is first truncated to a size of 0 bytes. This option is ignored when the file is opened only for reading.</source>
          <target state="translated">既存のファイルを開くとき、そのファイルは最初に 0 バイトのサイズに切り捨てられます。このオプションは、ファイルを読み込むためだけに開いている場合は無視されます。</target>
        </trans-unit>
        <trans-unit id="55ad5bbbd836b22033fccd6daca4b9d44a123e8e" translate="yes" xml:space="preserve">
          <source>When output streaming is enabled, authentication and redirection cannot be handled automatically. A &lt;a href=&quot;httpretryexception&quot;&gt;HttpRetryException&lt;/a&gt; will be thrown when reading the response if authentication or redirection are required. This exception can be queried for the details of the error.</source>
          <target state="translated">出力ストリーミングが有効になっている場合、認証とリダイレクトは自動的に処理できません。&lt;a href=&quot;httpretryexception&quot;&gt;HttpRetryExceptionは、&lt;/a&gt;認証またはリダイレクションが必要とされている場合の応答を読み取る際にスローされます。この例外は、エラーの詳細を照会することができます。</target>
        </trans-unit>
        <trans-unit id="0a1daf55edfb1251014f98d686349fc2cf29836a" translate="yes" xml:space="preserve">
          <source>When output streaming is enabled, authentication and redirection cannot be handled automatically. A HttpRetryException will be thrown when reading the response if authentication or redirection are required. This exception can be queried for the details of the error.</source>
          <target state="translated">出力ストリーミングが有効な場合、認証やリダイレクトを自動的に処理することはできません。認証またはリダイレクトが必要な場合は、応答を読み取る際に HttpRetryException がスローされます。この例外は、エラーの詳細について問い合わせることができます。</target>
        </trans-unit>
        <trans-unit id="70789a8a89c99dae4c53ce0b0096f13062e5be96" translate="yes" xml:space="preserve">
          <source>When output to a ZIP file or ZIP file formatted output stream the last modification time set by this method will be stored into zip file entry's &lt;code&gt;date and time fields&lt;/code&gt; in &lt;code&gt;standard
 MS-DOS date and time format&lt;/code&gt;), and the extended timestamp fields in &lt;code&gt;optional extra data&lt;/code&gt; in UTC time.</source>
          <target state="translated">ZIPファイルまたはZIPファイル形式の出力ストリームに出力する場合、このメソッドで設定された最終変更時刻は、 &lt;code&gt;standard MS-DOS date and time format&lt;/code&gt; zipファイルエントリの &lt;code&gt;date and time fields&lt;/code&gt; に格納され、拡張タイムスタンプフィールドは &lt;code&gt;optional extra data&lt;/code&gt; れます。 UTC時間でのデータ。</target>
        </trans-unit>
        <trans-unit id="fc606ceb2f424146aad8bdb4fde4bd8dd7c5761f" translate="yes" xml:space="preserve">
          <source>When overriding this method it is recommended that an implementation ensures that any delegation is consistent with the &lt;a href=&quot;#getResource(java.lang.String)&quot;&gt;&lt;code&gt;getResource(String)&lt;/code&gt;&lt;/a&gt; method. This should ensure that the first element returned by the stream is the same resource that the &lt;code&gt;getResource(String)&lt;/code&gt; method would return.</source>
          <target state="translated">このメソッドをオーバーライドするときは、実装によって、委任が&lt;a href=&quot;#getResource(java.lang.String)&quot;&gt; &lt;code&gt;getResource(String)&lt;/code&gt; &lt;/a&gt;メソッドと一致していることを確認することをお勧めします。これにより、ストリームによって返される最初の要素が、 &lt;code&gt;getResource(String)&lt;/code&gt; メソッドが返すのと同じリソースであることが保証されます。</target>
        </trans-unit>
        <trans-unit id="33b67f1448d9e46c92a5dd8ca3e0c7d32d1730ae" translate="yes" xml:space="preserve">
          <source>When overriding this method it is recommended that an implementation ensures that any delegation is consistent with the &lt;a href=&quot;classloader#getResource-java.lang.String-&quot;&gt;&lt;code&gt;getResource(String)&lt;/code&gt;&lt;/a&gt; method. This should ensure that the first element returned by the Enumeration's &lt;code&gt;nextElement&lt;/code&gt; method is the same resource that the &lt;code&gt;getResource(String)&lt;/code&gt; method would return.</source>
          <target state="translated">このメソッドをオーバーライドする場合は、実装で、委譲が&lt;a href=&quot;classloader#getResource-java.lang.String-&quot;&gt; &lt;code&gt;getResource(String)&lt;/code&gt; &lt;/a&gt;メソッドと一貫していることを確認することをお勧めします。これにより、Enumerationの &lt;code&gt;nextElement&lt;/code&gt; メソッドによって返される最初の要素が、 &lt;code&gt;getResource(String)&lt;/code&gt; メソッドが返すのと同じリソースであることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="059fdccbaa1b79359a5fe3e6137c458d9b8b9713" translate="yes" xml:space="preserve">
          <source>When overriding this method it is recommended that an implementation ensures that any delegation is consistent with the &lt;a href=&quot;classloader#getResources-java.lang.String-&quot;&gt;&lt;code&gt;getResources(String)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">このメソッドをオーバーライドする場合は、実装で、委譲が&lt;a href=&quot;classloader#getResources-java.lang.String-&quot;&gt; &lt;code&gt;getResources(String)&lt;/code&gt; &lt;/a&gt;メソッドと一貫していることを確認することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="bc58d21adb8af8af625121a5b2b080c75e23b139" translate="yes" xml:space="preserve">
          <source>When parsing in lenient mode, only the hours are mandatory - minutes and seconds are optional. The colons are required if the specified pattern contains a colon. If the specified pattern is &quot;+HH&quot;, the presence of colons is determined by whether the character after the hour digits is a colon or not. If the offset cannot be parsed then an exception is thrown unless the section of the formatter is optional.</source>
          <target state="translated">lenient モードで解析する場合は時間のみが必須で、分と秒はオプションです。コロンは、指定されたパターンにコロンが含まれている場合に必須です。指定されたパターンが &quot;+HH&quot; の場合、コロンの有無は、時の数字の後の文字がコロンかどうかで判断されます。オフセットが解析できない場合は、フォーマッタのセクションがオプションでない限り、例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="4bcac0e3e99ade4d27a61abe4610e8ad6c3973f0" translate="yes" xml:space="preserve">
          <source>When parsing in strict mode, the input must contain the mandatory and optional elements are defined by the specified pattern. If the offset cannot be parsed then an exception is thrown unless the section of the formatter is optional.</source>
          <target state="translated">厳密モードで解析する場合、入力は必須要素とオプション要素を含む必要があり、指定されたパターンで定義されます。オフセットが解析できない場合は、フォーマッタのセクションがオプションでない限り例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="631f29a71edc58dfc93bdc965a349f3c402f1d37" translate="yes" xml:space="preserve">
          <source>When parsing in strict mode, the number of parsed digits must be between the minimum and maximum width. In strict mode, if the minimum and maximum widths are equal and there is no decimal point then the parser will participate in adjacent value parsing, see &lt;a href=&quot;#appendValue(java.time.temporal.TemporalField,int)&quot;&gt;&lt;code&gt;appendValue(java.time.temporal.TemporalField,int)&lt;/code&gt;&lt;/a&gt;. When parsing in lenient mode, the minimum width is considered to be zero and the maximum is nine.</source>
          <target state="translated">ストリクトモードで解析する場合、解析される桁数は最小幅と最大幅の間にある必要があります。厳密モードでは、最小幅と最大幅が等しく、小数点がない場合、パーサーは隣接する値の解析に参加します&lt;a href=&quot;#appendValue(java.time.temporal.TemporalField,int)&quot;&gt; &lt;code&gt;appendValue(java.time.temporal.TemporalField,int)&lt;/code&gt; &lt;/a&gt;参照してください。寛大なモードで解析する場合、最小幅はゼロと見なされ、最大幅は9です。</target>
        </trans-unit>
        <trans-unit id="88186acbb81a8c14eb592e644ed27a9e055dc197" translate="yes" xml:space="preserve">
          <source>When parsing in strict mode, the number of parsed digits must be between the minimum and maximum width. When parsing in lenient mode, the minimum width is considered to be zero and the maximum is nine.</source>
          <target state="translated">厳密なモードで解析する場合、解析される桁数は最小幅と最大幅の間にある必要があります。lenient モードで解析する場合、最小幅は 0、最大幅は 9 と見なされます。</target>
        </trans-unit>
        <trans-unit id="d50f0289d83049487a7e415ef71230bcec841f7c" translate="yes" xml:space="preserve">
          <source>When parsing in strict mode, the number of parsed digits must match the fractional digits. When parsing in lenient mode, any number of fractional digits from zero to nine are accepted.</source>
          <target state="translated">厳密なモードで解析する場合、解析される桁数は端数桁と一致している必要があります。lenient モードで解析する場合は、0 から 9 までの任意の端数桁数が受け入れられます。</target>
        </trans-unit>
        <trans-unit id="398b9ccde24d723bc63ead376818c485f7b9a32f" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated from 0 to 1 in strict and smart mode. In lenient mode the value is not validated. It is combined with &lt;code&gt;HOUR_OF_AMPM&lt;/code&gt; to form &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; by multiplying the {AMPM_OF_DAY} value by 12.</source>
          <target state="translated">このフィールドを解析すると、次のように動作します。厳密なスマートモードで、値が0から1まで検証されます。寛容モードでは、値は検証されません。それと組み合わされる &lt;code&gt;HOUR_OF_AMPM&lt;/code&gt; 形成する &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; を 12 {AMPM_OF_DAY}値を乗算することによって。</target>
        </trans-unit>
        <trans-unit id="fc167eb2f61a597fa4fcdf11893ccfde6bdc0602" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated from 0 to 11 in strict and smart mode. In lenient mode the value is not validated. It is combined with &lt;code&gt;AMPM_OF_DAY&lt;/code&gt; to form &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; by multiplying the {AMPM_OF_DAY} value by 12.</source>
          <target state="translated">このフィールドを解析する場合、次のように動作します。厳密モードとスマートモードで、値が0から11まで検証されます。寛容モードでは、値は検証されません。 &lt;code&gt;AMPM_OF_DAY&lt;/code&gt; と組み合わせて、{AMPM_OF_DAY}の値に12を掛けて &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; を形成します。</target>
        </trans-unit>
        <trans-unit id="957785487bc5a171742676f4c57e468f23bbf945" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated from 1 to 12 in strict mode and from 0 to 12 in smart mode. In lenient mode the value is not validated. The field is converted to an &lt;code&gt;HOUR_OF_AMPM&lt;/code&gt; with the same value, unless the value is 12, in which case it is converted to 0.</source>
          <target state="translated">このフィールドを解析する場合、次のように動作します。値は、厳密モードでは1から12まで、スマートモードでは0から12まで検証されます。寛容モードでは、値は検証されません。値が12でない限り、フィールドは同じ値の &lt;code&gt;HOUR_OF_AMPM&lt;/code&gt; に変換されます。値が12の場合は0に変換されます。</target>
        </trans-unit>
        <trans-unit id="392153078b1342cc9b804c5665b0c975ca3bc7c5" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated from 1 to 24 in strict mode and from 0 to 24 in smart mode. In lenient mode the value is not validated. The field is converted to an &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; with the same value, unless the value is 24, in which case it is converted to 0.</source>
          <target state="translated">このフィールドを解析するときの動作は次のとおりです。値は、厳密モードでは1から24まで、スマートモードでは0から24まで検証されます。寛容モードでは、値は検証されません。値が24でない限り、フィールドは同じ値の &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; に変換されます。値が24の場合は0に変換されます。</target>
        </trans-unit>
        <trans-unit id="99eb9e50057d1c711aa0384492b14a1cc96c9df7" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode.</source>
          <target state="translated">このフィールドを解析すると、以下のようになります。値は strict および smart モードでは検証されますが、lenient モードでは検証されません。</target>
        </trans-unit>
        <trans-unit id="1fc9716f73232473fc7fb6cbb3857d50c0ce6738" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode. The field is combined with &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt;, &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt; and &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; to produce a &lt;code&gt;LocalTime&lt;/code&gt;. In lenient mode, any excess days are added to the parsed date, or made available via &lt;a href=&quot;../format/datetimeformatter#parsedExcessDays()&quot;&gt;&lt;code&gt;DateTimeFormatter.parsedExcessDays()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このフィールドを解析すると、次のように動作します。値はstrictモードとsmartモードで検証されますが、lenientモードでは検証されません。このフィールドは、 &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; 、 &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt; 、および &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; と組み合わされて、 &lt;code&gt;LocalTime&lt;/code&gt; を生成します。寛大なモードでは、余分な日数は解析された日付に追加されるか、&lt;a href=&quot;../format/datetimeformatter#parsedExcessDays()&quot;&gt; &lt;code&gt;DateTimeFormatter.parsedExcessDays()&lt;/code&gt; を&lt;/a&gt;介して利用可能になります。</target>
        </trans-unit>
        <trans-unit id="2ddaf4c446a794e052910439758bc7ef035eeef6" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode. The field is combined with &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt;, &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt; and &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; to produce a &lt;code&gt;LocalTime&lt;/code&gt;. In lenient mode, any excess days are added to the parsed date, or made available via &lt;a href=&quot;../format/datetimeformatter#parsedExcessDays--&quot;&gt;&lt;code&gt;DateTimeFormatter.parsedExcessDays()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このフィールドを解析する場合、次のように動作します。値は厳密モードおよびスマートモードで検証されますが、緩やかなモードでは検証されません。このフィールドは &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; 、 &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt; および &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; と組み合わせてLocalTimeを生成し &lt;code&gt;LocalTime&lt;/code&gt; 。緩やかなモードでは、超過日数が解析された日付に追加されるか、&lt;a href=&quot;../format/datetimeformatter#parsedExcessDays--&quot;&gt; &lt;code&gt;DateTimeFormatter.parsedExcessDays()&lt;/code&gt; を&lt;/a&gt;介して利用可能になります。</target>
        </trans-unit>
        <trans-unit id="3ae9bc249b42914740d59028697394c29456af8c" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode. The field is resolved in combination with &lt;code&gt;MICRO_OF_SECOND&lt;/code&gt; to produce &lt;code&gt;NANO_OF_SECOND&lt;/code&gt;.</source>
          <target state="translated">このフィールドを解析する場合、次のように動作します。値は厳密モードおよびスマートモードで検証されますが、緩やかなモードでは検証されません。フィールドは &lt;code&gt;MICRO_OF_SECOND&lt;/code&gt; と組み合わせて解決され、NANO_OF_SECONDが生成され &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a924c762f617440d33adf98834b01ed6f029b945" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode. The field is resolved in combination with &lt;code&gt;MILLI_OF_SECOND&lt;/code&gt; and &lt;code&gt;MICRO_OF_SECOND&lt;/code&gt;.</source>
          <target state="translated">このフィールドを解析する場合、次のように動作します。値は厳密モードおよびスマートモードで検証されますが、緩やかなモードでは検証されません。フィールドは &lt;code&gt;MILLI_OF_SECOND&lt;/code&gt; および &lt;code&gt;MICRO_OF_SECOND&lt;/code&gt; と組み合わせて解決されます。</target>
        </trans-unit>
        <trans-unit id="a8dbf53e5aefb77318b4486598a6313d9b941472" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode. The field is resolved in combination with &lt;code&gt;MILLI_OF_SECOND&lt;/code&gt; to produce &lt;code&gt;NANO_OF_SECOND&lt;/code&gt;.</source>
          <target state="translated">このフィールドを解析する場合、次のように動作します。値は厳密モードおよびスマートモードで検証されますが、緩やかなモードでは検証されません。フィールドは &lt;code&gt;MILLI_OF_SECOND&lt;/code&gt; と組み合わせて解決され、NANO_OF_SECONDが生成され &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c800d57db7922ab39c14b13ae86f803dc109a26b" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode. The value is split to form &lt;code&gt;MICRO_OF_SECOND&lt;/code&gt;, &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt;, &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; and &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; fields.</source>
          <target state="translated">このフィールドを解析する場合、次のように動作します。値は厳密モードおよびスマートモードで検証されますが、緩やかなモードでは検証されません。値は分割されて、 &lt;code&gt;MICRO_OF_SECOND&lt;/code&gt; 、 &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt; 、 &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; および &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; フィールドが形成されます。</target>
        </trans-unit>
        <trans-unit id="c294e00d68fa9137c919614e2026adac17298586" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode. The value is split to form &lt;code&gt;MILLI_OF_SECOND&lt;/code&gt;, &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt;, &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; and &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; fields.</source>
          <target state="translated">このフィールドを解析する場合、次のように動作します。値は厳密モードおよびスマートモードで検証されますが、緩やかなモードでは検証されません。値は &lt;code&gt;MILLI_OF_SECOND&lt;/code&gt; 、 &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt; 、 &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; および &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; フィールドを形成するように分割されます。</target>
        </trans-unit>
        <trans-unit id="f645cbf7fae3ea37f1aeb723d42fd638100f86e8" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode. The value is split to form &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; and &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; fields.</source>
          <target state="translated">このフィールドを解析する場合、次のように動作します。値は厳密モードおよびスマートモードで検証されますが、緩やかなモードでは検証されません。値は分割されて、 &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; および &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; フィールドが形成されます。</target>
        </trans-unit>
        <trans-unit id="1be57e4bffee0d932e9b78c3b2c86a25070821da" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode. The value is split to form &lt;code&gt;NANO_OF_SECOND&lt;/code&gt;, &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt;, &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; and &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; fields.</source>
          <target state="translated">このフィールドを解析する場合、次のように動作します。値は厳密モードおよびスマートモードで検証されますが、緩やかなモードでは検証されません。値は &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; 、 &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt; 、 &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; および &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; フィールドを形成するように分割されます。</target>
        </trans-unit>
        <trans-unit id="375544438a835cc62e84a73073301cc45d0d9edd" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode. The value is split to form &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt;, &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; and &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; fields.</source>
          <target state="translated">このフィールドを解析する場合、次のように動作します。値は厳密モードおよびスマートモードで検証されますが、緩やかなモードでは検証されません。値は &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt; 、 &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; および &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; フィールドに分割されます。</target>
        </trans-unit>
        <trans-unit id="4cd8446097afcf131ca40bba9bd5d77aaa9438f7" translate="yes" xml:space="preserve">
          <source>When parsing, there are two distinct cases to consider. If a chronology has been parsed directly from the text, perhaps because &lt;a href=&quot;datetimeformatterbuilder#appendChronologyId()&quot;&gt;&lt;code&gt;DateTimeFormatterBuilder.appendChronologyId()&lt;/code&gt;&lt;/a&gt; was used, then this override chronology has no effect. If no zone has been parsed, then this override chronology will be used to interpret the &lt;code&gt;ChronoField&lt;/code&gt; values into a date according to the date resolving rules of the chronology.</source>
          <target state="translated">解析する場合、考慮すべき2つの異なるケースがあります。おそらく&lt;a href=&quot;datetimeformatterbuilder#appendChronologyId()&quot;&gt; &lt;code&gt;DateTimeFormatterBuilder.appendChronologyId()&lt;/code&gt; &lt;/a&gt;が使用されたために、年表がテキストから直接解析された場合、このオーバーライド年表は効果がありません。ゾーンが解析されていない場合、このオーバーライドクロノロジーは、 &lt;code&gt;ChronoField&lt;/code&gt; の日付解決ルールに従ってChronoField値を日付に解釈するために使用されます。</target>
        </trans-unit>
        <trans-unit id="f28daa7170bb1fcc870df5a101d2c5b9ccdbc619" translate="yes" xml:space="preserve">
          <source>When parsing, there are two distinct cases to consider. If a chronology has been parsed directly from the text, perhaps because &lt;a href=&quot;datetimeformatterbuilder#appendChronologyId--&quot;&gt;&lt;code&gt;DateTimeFormatterBuilder.appendChronologyId()&lt;/code&gt;&lt;/a&gt; was used, then this override chronology has no effect. If no zone has been parsed, then this override chronology will be used to interpret the &lt;code&gt;ChronoField&lt;/code&gt; values into a date according to the date resolving rules of the chronology.</source>
          <target state="translated">解析する場合、考慮すべき2つの異なるケースがあります。年表がテキストから直接解析された場合、おそらく&lt;a href=&quot;datetimeformatterbuilder#appendChronologyId--&quot;&gt; &lt;code&gt;DateTimeFormatterBuilder.appendChronologyId()&lt;/code&gt; &lt;/a&gt;が使用されたため、このオーバーライド年表は効果がありません。ゾーンが解析されていない場合、このオーバーライドの年表を使用して、年表の日付解決ルールに従って &lt;code&gt;ChronoField&lt;/code&gt; の値を日付に解釈します。</target>
        </trans-unit>
        <trans-unit id="be3406dfdd119662bd0b600c9668e269a43af897" translate="yes" xml:space="preserve">
          <source>When parsing, there are two distinct cases to consider. If a zone has been parsed directly from the text, perhaps because &lt;a href=&quot;datetimeformatterbuilder#appendZoneId()&quot;&gt;&lt;code&gt;DateTimeFormatterBuilder.appendZoneId()&lt;/code&gt;&lt;/a&gt; was used, then this override zone has no effect. If no zone has been parsed, then this override zone will be included in the result of the parse where it can be used to build instants and date-times.</source>
          <target state="translated">解析する場合、考慮すべき2つの異なるケースがあります。おそらく&lt;a href=&quot;datetimeformatterbuilder#appendZoneId()&quot;&gt; &lt;code&gt;DateTimeFormatterBuilder.appendZoneId()&lt;/code&gt; &lt;/a&gt;が使用されたために、ゾーンがテキストから直接解析された場合、このオーバーライドゾーンは効果がありません。ゾーンが解析されていない場合、このオーバーライドゾーンは解析の結果に含まれ、インスタントと日時の作成に使用できます。</target>
        </trans-unit>
        <trans-unit id="a965e09e870a4e87e4a218aed3653bd2efbce188" translate="yes" xml:space="preserve">
          <source>When parsing, there are two distinct cases to consider. If a zone has been parsed directly from the text, perhaps because &lt;a href=&quot;datetimeformatterbuilder#appendZoneId--&quot;&gt;&lt;code&gt;DateTimeFormatterBuilder.appendZoneId()&lt;/code&gt;&lt;/a&gt; was used, then this override zone has no effect. If no zone has been parsed, then this override zone will be included in the result of the parse where it can be used to build instants and date-times.</source>
          <target state="translated">解析する場合、考慮すべき2つの異なるケースがあります。おそらく&lt;a href=&quot;datetimeformatterbuilder#appendZoneId--&quot;&gt; &lt;code&gt;DateTimeFormatterBuilder.appendZoneId()&lt;/code&gt; &lt;/a&gt;が使用されたために、ゾーンがテキストから直接解析された場合、このオーバーライドゾーンは効果がありません。ゾーンが解析されていない場合、このオーバーライドゾーンは解析の結果に含まれ、インスタントと日時の作成に使用できます。</target>
        </trans-unit>
        <trans-unit id="6cf15c2cadbf1d2f9101df44d9400a393f3cd777" translate="yes" xml:space="preserve">
          <source>When passing information to a Java subprocess, &lt;a href=&quot;#EnvironmentVSSystemProperties&quot;&gt;system properties&lt;/a&gt; are generally preferred over environment variables.</source>
          <target state="translated">Javaサブプロセスに情報を渡す場合、&lt;a href=&quot;#EnvironmentVSSystemProperties&quot;&gt;システムプロパティ&lt;/a&gt;は通常、環境変数よりも優先されます。</target>
        </trans-unit>
        <trans-unit id="678a637edd80c217c54e61b9e25c8439ebfa7bf7" translate="yes" xml:space="preserve">
          <source>When passing information to a Java subprocess, &lt;a href=&quot;system#EnvironmentVSSystemProperties&quot;&gt;system properties&lt;/a&gt; are generally preferred over environment variables.</source>
          <target state="translated">Javaサブプロセスに情報を渡す場合、&lt;a href=&quot;system#EnvironmentVSSystemProperties&quot;&gt;システムプロパティ&lt;/a&gt;は通常、環境変数よりも優先されます。</target>
        </trans-unit>
        <trans-unit id="468a7461c40962d54c04cec0adab0486b4f75193" translate="yes" xml:space="preserve">
          <source>When pending counts can be precomputed, they can be established in the constructor:</source>
          <target state="translated">保留カウントを事前に計算できる場合は、コンストラクタで確立することができます。</target>
        </trans-unit>
        <trans-unit id="ee906d2367a93c8434f7349879af51a79dadb0c5" translate="yes" xml:space="preserve">
          <source>When possible this simply changes the name of the given node, otherwise this creates a new node with the specified name and replaces the existing node with the new node as described below.</source>
          <target state="translated">可能な場合、これは単に指定されたノードの名前を変更します。そうでない場合は、指定された名前の新しいノードを作成し、以下に説明するように既存のノードを新しいノードに置き換えます。</target>
        </trans-unit>
        <trans-unit id="1d9df05f42f191fd30f4013d3bc48c1dc951d2b7" translate="yes" xml:space="preserve">
          <source>When processing logging output, if a Handler encounters problems then rather than throwing an Exception back to the issuer of the logging call (who is unlikely to be interested) the Handler should call its associated ErrorManager.</source>
          <target state="translated">ロギング出力を処理する際に、ハンドラーが問題に遭遇した場合、ロギングコールの発行者 (興味を持ちそうにない人)に Exception を投げ返すのではなく、ハンドラーは関連する ErrorManager を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="3e179726ee6a6f7644de1db6d67bff96f348bf5e" translate="yes" xml:space="preserve">
          <source>When providing implementations for the new methods in the subclass, use this newly defined method to get the initial context.</source>
          <target state="translated">サブクラス内の新しいメソッドの実装を提供する際には、この新しく定義されたメソッドを使用して初期コンテキストを取得します。</target>
        </trans-unit>
        <trans-unit id="ac5bba685209949c2cc3f67e3cab5d31b729dde6" translate="yes" xml:space="preserve">
          <source>When reading a document if a CRLF is encountered a property with this name is added and the value will be &quot;\r\n&quot;.</source>
          <target state="translated">文書を読むとき、もしCRLFが遭遇したら、この名前のプロパティが追加され、値は&quot;\rrn &quot;になります。</target>
        </trans-unit>
        <trans-unit id="093663f9827304bad79b038495f5092c12dadca2" translate="yes" xml:space="preserve">
          <source>When reading a provider-configuration file, or loading or instantiating a provider class named in a provider-configuration file, then &lt;code&gt;
 ServiceConfigurationError&lt;/code&gt; can be thrown for the following reasons:</source>
          <target state="translated">プロバイダー構成ファイルを読み取るとき、またはプロバイダー構成ファイルで指定されたプロバイダークラスをロードまたはインスタンス化するとき、次の理由で &lt;code&gt; ServiceConfigurationError&lt;/code&gt; がスローされる可能性があります。</target>
        </trans-unit>
        <trans-unit id="ff2175fd5a0c9824ca3682906ca8e8c785a2e2f5" translate="yes" xml:space="preserve">
          <source>When reading an image, its per-stream and per-image metadata is made available as an &lt;code&gt;IIOMetadata&lt;/code&gt; object. The internals of this object are specific to the plug-in that created it. Its contents may be accessed in the form of an XML &lt;code&gt;Document&lt;/code&gt;, which is implemented as a tree of &lt;code&gt;IIOMetadataNode&lt;/code&gt; objects.</source>
          <target state="translated">画像を読み取るとき、ストリームごとおよび画像ごとのメタデータが &lt;code&gt;IIOMetadata&lt;/code&gt; オブジェクトとして利用可能になります。このオブジェクトの内部は、それを作成したプラグインに固有です。そのコンテンツには、XML &lt;code&gt;Document&lt;/code&gt; 形式でアクセスできます。これは、 &lt;code&gt;IIOMetadataNode&lt;/code&gt; オブジェクトのツリーとして実装されます。</target>
        </trans-unit>
        <trans-unit id="c064a445936071cf19ecbcb598a24cd0f5fcf1e9" translate="yes" xml:space="preserve">
          <source>When reading from a standard &lt;code&gt;InputStream&lt;/code&gt;, it may be necessary to save previously read information in a cache since the underlying stream does not allow data to be re-read. Similarly, when writing to a standard &lt;code&gt;OutputStream&lt;/code&gt;, a cache may be used to allow a previously written value to be changed before flushing it to the final destination.</source>
          <target state="translated">標準の &lt;code&gt;InputStream&lt;/code&gt; から読み取る場合、基礎となるストリームではデータを再度読み取ることができないため、以前に読み取った情報をキャッシュに保存する必要がある場合があります。同様に、標準の &lt;code&gt;OutputStream&lt;/code&gt; に書き込む場合、キャッシュを使用して、以前に書き込まれた値を変更してから、最終的な宛先にフラッシュすることができます。</target>
        </trans-unit>
        <trans-unit id="967c7f2fd4e6ef5e74644bcb7e0d2a8f5a951bbd" translate="yes" xml:space="preserve">
          <source>When reading, a &lt;code&gt;TIFFDirectory&lt;/code&gt; may be created by passing the value returned by &lt;a href=&quot;../../imagereader#getImageMetadata(int)&quot;&gt;&lt;code&gt;ImageReader.getImageMetadata()&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;#createFromMetadata(javax.imageio.metadata.IIOMetadata)&quot;&gt;&lt;code&gt;createFromMetadata()&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;tifffield&quot;&gt;&lt;code&gt;TIFFField&lt;/code&gt;&lt;/a&gt;s in the directory may then be obtained using the accessor methods provided in this class.</source>
          <target state="translated">読み取るときに、&lt;a href=&quot;../../imagereader#getImageMetadata(int)&quot;&gt; &lt;code&gt;ImageReader.getImageMetadata()&lt;/code&gt; &lt;/a&gt;によって返された値を&lt;a href=&quot;#createFromMetadata(javax.imageio.metadata.IIOMetadata)&quot;&gt; &lt;code&gt;createFromMetadata()&lt;/code&gt; に&lt;/a&gt;渡すことにより、 &lt;code&gt;TIFFDirectory&lt;/code&gt; を作成できます。ディレクトリ内の&lt;a href=&quot;tifffield&quot;&gt; &lt;code&gt;TIFFField&lt;/code&gt; &lt;/a&gt;は、このクラスで提供されるアクセサメソッドを使用して取得できます。</target>
        </trans-unit>
        <trans-unit id="1d63913965696a9f9c40e306e81ce84323b71ddc" translate="yes" xml:space="preserve">
          <source>When reading, if the layout of the destination has been set using this method, each call to an &lt;code&gt;ImageReader&lt;/code&gt;&lt;code&gt;read&lt;/code&gt; method will return a new &lt;code&gt;BufferedImage&lt;/code&gt; using the format specified by the supplied type specifier. As a side effect, any destination &lt;code&gt;BufferedImage&lt;/code&gt; set by &lt;code&gt;ImageReadParam.setDestination(BufferedImage)&lt;/code&gt; will no longer be set as the destination. In other words, this method may be thought of as calling &lt;code&gt;setDestination((BufferedImage)null)&lt;/code&gt;.</source>
          <target state="translated">読み取り時に、このメソッドを使用して宛先のレイアウトが設定されている場合、 &lt;code&gt;ImageReader&lt;/code&gt; &lt;code&gt;read&lt;/code&gt; メソッドを呼び出すたびに、提供された型指定子で指定された形式を使用して新しい &lt;code&gt;BufferedImage&lt;/code&gt; が返されます。副作用として、 &lt;code&gt;ImageReadParam.setDestination(BufferedImage)&lt;/code&gt; によって設定された宛先 &lt;code&gt;BufferedImage&lt;/code&gt; は、宛先として設定されなくなります。つまり、このメソッドは &lt;code&gt;setDestination((BufferedImage)null)&lt;/code&gt; を呼び出すと考えることができます。</target>
        </trans-unit>
        <trans-unit id="a5b68a7995942b34e6fb81c415ca17f384da8a72" translate="yes" xml:space="preserve">
          <source>When reading, the region to be written within the destination &lt;code&gt;BufferedImage&lt;/code&gt; will start at this offset and have a width and height determined by the source region of interest, the subsampling parameters, and the destination bounds.</source>
          <target state="translated">読み取り時、宛先の &lt;code&gt;BufferedImage&lt;/code&gt; 内に書き込まれる領域はこのオフセットから始まり、対象のソース領域、サブサンプリングパラメーター、および宛先の境界によって決定される幅と高さを持ちます。</target>
        </trans-unit>
        <trans-unit id="948c72e84f23a6d80190a196cfc3c27ca22ecf53" translate="yes" xml:space="preserve">
          <source>When replacing a leaf this will attempt to make sure there is a newline present if one is needed. This may result in an additional element being inserted. Consider, if you were to replace a character element that contained a newline with &amp;lt;img&amp;gt; this would create two elements, one for the image, and one for the newline.</source>
          <target state="translated">リーフを交換するとき、必要に応じて改行が存在することを確認しようとします。これにより、追加の要素が挿入される可能性があります。改行を含む文字要素を&amp;lt;img&amp;gt;に置き換えると、画像用と改行用の2つの要素が作成されることを考慮してください。</target>
        </trans-unit>
        <trans-unit id="e4073d7c2224019b5107064c858d7e912ce2c1aa" translate="yes" xml:space="preserve">
          <source>When requested by setting the parameter &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-normalize-characters&quot;&gt;normalize-characters&lt;/a&gt;&quot; on &lt;code&gt;LSSerializer&lt;/code&gt; to true, character normalization is performed according to the definition of &lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml11-20040204/#dt-fullnorm&quot;&gt;fully normalized&lt;/a&gt; characters included in appendix E of [&lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml11-20040204/&quot;&gt;XML 1.1&lt;/a&gt;] on all data to be serialized, both markup and character data. The character normalization process affects only the data as it is being written; it does not alter the DOM's view of the document after serialization has completed.</source>
          <target state="translated">&lt;code&gt;LSSerializer&lt;/code&gt; のパラメータ「&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-normalize-characters&quot;&gt;normalize-characters&lt;/a&gt;」をtrueに設定して要求されると、文字の正規化は、マークアップと文字データの両方のシリアル化されるすべてのデータで[ &lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml11-20040204/&quot;&gt;XML1.1&lt;/a&gt; ]の付録Eに含まれる&lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml11-20040204/#dt-fullnorm&quot;&gt;完全に正規化された&lt;/a&gt;文字の定義に従って実行されます。文字の正規化プロセスは、書き込まれているデータにのみ影響します。シリアル化が完了した後、ドキュメントのDOMのビューは変更されません。</target>
        </trans-unit>
        <trans-unit id="9829ac48f456c01c997a54312f4d28ae239840e5" translate="yes" xml:space="preserve">
          <source>When requesting a Namespace URI by prefix, the following table describes the returned Namespace URI value for all possible prefix values:</source>
          <target state="translated">プレフィックスで Namespace URI を要求する場合、以下の表は、すべての可能なプレフィックス値について返される Namespace URI の値を示しています。</target>
        </trans-unit>
        <trans-unit id="8c473adada2bf0879238d13edc56b7303e5f6472" translate="yes" xml:space="preserve">
          <source>When requesting a prefix by Namespace URI, the following table describes the returned prefix value for all Namespace URI values:</source>
          <target state="translated">Namespace URI でプレフィックスを要求する場合、以下の表では、すべての Namespace URI の値に対して返されるプレフィックスの値を説明します。</target>
        </trans-unit>
        <trans-unit id="4469f523c26a6a607eb001a67af246e496c67ea8" translate="yes" xml:space="preserve">
          <source>When requesting prefixes by Namespace URI, the following table describes the returned prefixes value for all Namespace URI values:</source>
          <target state="translated">Namespace URIで接頭辞を要求する場合、以下の表はすべてのNamespace URIの値に対して返される接頭辞の値を記述しています。</target>
        </trans-unit>
        <trans-unit id="47eff58ddedc0bc2eb7327683e454ec2dfb1f6d0" translate="yes" xml:space="preserve">
          <source>When resolving time fields, the map will be altered and null returned. When resolving date fields, the date is normally returned from the method, with the map altered to remove the resolved fields. However, it would also be acceptable for the date fields to be resolved into other &lt;code&gt;ChronoField&lt;/code&gt; instances that can produce a date, such as &lt;code&gt;EPOCH_DAY&lt;/code&gt;.</source>
          <target state="translated">時間フィールドを解決すると、マップが変更され、nullが返されます。日付フィールドを解決する場合、通常はメソッドから日付が返され、解決されたフィールドを削除するようにマップが変更されます。しかし、それはまた、他に解決すべき日付フィールドのために許容されるであろう &lt;code&gt;ChronoField&lt;/code&gt; のような日付を生成することができるインスタンス、 &lt;code&gt;EPOCH_DAY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d8cf7bc5f7e0ab67c20394ce506b32ad70404b7" translate="yes" xml:space="preserve">
          <source>When returning to windowed mode from an exclusive full-screen window, any display changes made by calling &lt;code&gt;setDisplayMode&lt;/code&gt; are automatically restored to their original state.</source>
          <target state="translated">専用のフルスクリーンウィンドウからウィンドウモードに戻ると、 &lt;code&gt;setDisplayMode&lt;/code&gt; を呼び出して表示を変更すると、自動的に元の状態に戻ります。</target>
        </trans-unit>
        <trans-unit id="ed495f5df0234ba9158fa7c63e4629f640c9c226" translate="yes" xml:space="preserve">
          <source>When run the following is produced.</source>
          <target state="translated">実行すると以下のように生成されます。</target>
        </trans-unit>
        <trans-unit id="71220676e6e26c91102efdd4c23b78003dc6007b" translate="yes" xml:space="preserve">
          <source>When running in an environment which supports modules, processors are encouraged to include the module prefix when describing their supported annotation types. The method &lt;a href=&quot;abstractprocessor#getSupportedAnnotationTypes()&quot;&gt;&lt;code&gt;AbstractProcessor.getSupportedAnnotationTypes&lt;/code&gt;&lt;/a&gt; provides support for stripping off the module prefix when running in an environment without modules.</source>
          <target state="translated">モジュールをサポートする環境で実行する場合、プロセッサは、サポートされる注釈タイプを記述するときにモジュールプレフィックスを含めることをお勧めします。メソッド&lt;a href=&quot;abstractprocessor#getSupportedAnnotationTypes()&quot;&gt; &lt;code&gt;AbstractProcessor.getSupportedAnnotationTypes&lt;/code&gt; &lt;/a&gt;は、モジュールのない環境で実行するときにモジュールプレフィックスを取り除くためのサポートを提供します。</target>
        </trans-unit>
        <trans-unit id="b2e3a16dad606054ad91ef38f6e33de06fd97381" translate="yes" xml:space="preserve">
          <source>When sending a request that contains a body, the HTTP Client subscribes to the request's &lt;code&gt;BodyPublisher&lt;/code&gt; in order to receive the flow of outgoing request body data. The normal semantics of &lt;a href=&quot;../../../../java.base/java/util/concurrent/flow.subscriber&quot;&gt;&lt;code&gt;Flow.Subscriber&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../../../java.base/java/util/concurrent/flow.publisher&quot;&gt;&lt;code&gt;Flow.Publisher&lt;/code&gt;&lt;/a&gt; are implemented by the HTTP Client and are expected from &lt;code&gt;BodyPublisher&lt;/code&gt; implementations. Each outgoing request results in one HTTP Client &lt;code&gt;Subscriber&lt;/code&gt; subscribing to the &lt;code&gt;BodyPublisher&lt;/code&gt; in order to provide the sequence of byte buffers containing the request body. Instances of &lt;code&gt;
 ByteBuffer&lt;/code&gt; published by the publisher must be allocated by the publisher, and must not be accessed after being published to the HTTP Client. These subscriptions complete normally when the request body is fully sent, and can be canceled or terminated early through error. If a request needs to be resent for any reason, then a new subscription is created which is expected to generate the same data as before.</source>
          <target state="translated">本文を含むリクエストを送信する場合、HTTPクライアントは、送信リクエストの本文データのフローを受信するために、リクエストの &lt;code&gt;BodyPublisher&lt;/code&gt; にサブスクライブします。&lt;a href=&quot;../../../../java.base/java/util/concurrent/flow.subscriber&quot;&gt; &lt;code&gt;Flow.Subscriber&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../../../java.base/java/util/concurrent/flow.publisher&quot;&gt; &lt;code&gt;Flow.Publisher&lt;/code&gt; &lt;/a&gt;の通常のセマンティクスは、HTTPクライアントによって実装され、 &lt;code&gt;BodyPublisher&lt;/code&gt; の実装から期待されます。送信リクエストごとに、リクエスト本文を含むバイトバッファーのシーケンスを提供するために、1つのHTTPクライアント &lt;code&gt;Subscriber&lt;/code&gt; スクライバーが &lt;code&gt;BodyPublisher&lt;/code&gt; にサブスクライブします。 &lt;code&gt; ByteBuffer&lt;/code&gt; のインスタンスパブリッシャーによって公開されたものは、パブリッシャーによって割り当てられる必要があり、HTTPクライアントに公開された後にアクセスしてはなりません。これらのサブスクリプションは、リクエスト本文が完全に送信されると正常に完了し、エラーによって早期にキャンセルまたは終了することができます。何らかの理由でリクエストを再送信する必要がある場合は、以前と同じデータを生成することが期待される新しいサブスクリプションが作成されます。</target>
        </trans-unit>
        <trans-unit id="76363a09529976afbe0f0801c413175b6a84dc98" translate="yes" xml:space="preserve">
          <source>When sending timer notifications, the timer updates the notification sequence number irrespective of the notification type.</source>
          <target state="translated">タイマー通知を送信する際には、通知の種類に関係なく通知シーケンス番号を更新します。</target>
        </trans-unit>
        <trans-unit id="e95bdd8162adf9968f7adc4afbf013d6f5093728" translate="yes" xml:space="preserve">
          <source>When serializing an &lt;code&gt;Element&lt;/code&gt;, the element is passed to the filter before any of its attributes are passed to the filter. Namespace declaration attributes, and default attributes (except in the case when &quot; discard-default-content&quot; is set to &lt;code&gt;false&lt;/code&gt;), are never passed to the filter.</source>
          <target state="translated">&lt;code&gt;Element&lt;/code&gt; シリアル化する場合、その属性のいずれかがフィルターに渡される前に、要素がフィルターに渡されます。名前空間宣言属性とデフォルト属性（「discard-default-content」が &lt;code&gt;false&lt;/code&gt; に設定されている場合を除く）は、フィルターに渡されることはありません。</target>
        </trans-unit>
        <trans-unit id="016bd53a30e369ac9500dd916cae37c51e43c195" translate="yes" xml:space="preserve">
          <source>When setting or getting the &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt; or &lt;code&gt;WEEK_OF_YEAR&lt;/code&gt; fields, &lt;code&gt;Calendar&lt;/code&gt; must determine the first week of the month or year as a reference point. The first week of a month or year is defined as the earliest seven day period beginning on &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; and containing at least &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; days of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks numbered 2, 3,... follow it. Note that the normalized numbering returned by &lt;code&gt;get()&lt;/code&gt; may be different. For example, a specific &lt;code&gt;Calendar&lt;/code&gt; subclass may designate the week before week 1 of a year as week &lt;code&gt;&lt;i&gt;n&lt;/i&gt;&lt;/code&gt; of the previous year.</source>
          <target state="translated">&lt;code&gt;WEEK_OF_MONTH&lt;/code&gt; または &lt;code&gt;WEEK_OF_YEAR&lt;/code&gt; フィールドを設定または取得する場合、 &lt;code&gt;Calendar&lt;/code&gt; は月または年の最初の週を基準点として決定する必要があります。月または年の最初の週は、 &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; で始まり、その月または年の少なくとも &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; 日を含む最も早い7日間として定義されます。週番号は...、-1、0は最初の週の前。週は2、3、...と続きます。 &lt;code&gt;get()&lt;/code&gt; によって返される正規化された番号付けは異なる場合があることに注意してください。たとえば、特定の &lt;code&gt;Calendar&lt;/code&gt; サブクラスは、年の第1週の前の週を前年の第 &lt;code&gt;&lt;i&gt;n&lt;/i&gt;&lt;/code&gt; 週として指定する場合があります。</target>
        </trans-unit>
        <trans-unit id="d95cdd09e08dbf61e5dd1557a78ec0a6f3ed5062" translate="yes" xml:space="preserve">
          <source>When setting the filter, it should be stateless and idempotent, reporting the same result when passed the same arguments.</source>
          <target state="translated">フィルタを設定する際には、同じ引数を渡しても同じ結果を報告するように、ステートレスでアイドエンプテントでなければなりません。</target>
        </trans-unit>
        <trans-unit id="6a17a22214c7c2e160d3cfa1f6db1fc4e32a144d" translate="yes" xml:space="preserve">
          <source>When setting this field, the value is allowed to be partially lenient, taking any value from 1 to 92. If the quarter has less than 92 days, then day 92, and potentially day 91, is in the following quarter.</source>
          <target state="translated">このフィールドを設定する場合、値は1から92までの任意の値を取り、部分的に寛大にすることができます。四半期の日数が92日未満の場合、92日目、および潜在的に91日目が次の四半期にあることになります。</target>
        </trans-unit>
        <trans-unit id="669b10bb52f2a514a970d8c5edffcfcd75525b6b" translate="yes" xml:space="preserve">
          <source>When setting up a print job, a client specifies two things: &lt;b&gt;print data&lt;/b&gt; and &lt;b&gt;processing instructions.&lt;/b&gt; The print data is the actual content to be printed. The processing instructions tell the printer how to print the print data, such as: what media to use, how many copies to print, and whether to print on one or both sides of a sheet. The client specifies these processing instructions with the attribute definitions of the Java Print Service API.</source>
          <target state="translated">印刷ジョブを設定するとき、クライアントは2つのことを指定します。&lt;b&gt;印刷データ&lt;/b&gt;と&lt;b&gt;処理命令です。&lt;/b&gt;印刷データは、実際に印刷される内容です。処理命令は、使用するメディア、印刷するコピー数、シートの片面または両面のどちらに印刷するかなど、印刷データの印刷方法をプリンターに指示します。クライアントは、Java Print Service APIの属性定義を使用してこれらの処理命令を指定します。</target>
        </trans-unit>
        <trans-unit id="992deb8ce4de81a3a8e6eef7b845fb57e8e29bfe" translate="yes" xml:space="preserve">
          <source>When specified at the doc level, an attribute applies just to that one doc. When specified at the Print Request level, an attribute applies to the whole job, including all the docs in the job. However, an attribute specified at the doc level overrides an attribute in the same category specified at the Print Request level.</source>
          <target state="translated">doc レベルで指定された場合、属性はその 1 つの doc にのみ適用されます。印刷要求レベルで指定された場合、属性はジョブ内のすべてのdocを含むジョブ全体に適用されます。ただし、docレベルで指定された属性は、印刷要求レベルで指定された同じカテゴリの属性よりも優先されます。</target>
        </trans-unit>
        <trans-unit id="812c36aefe75f1f01b1e22e1de7ca89fc2466e0d" translate="yes" xml:space="preserve">
          <source>When submitting a print job to a printer, the client provides the attributes describing the characteristics of the print data, such as the document name, and how the print data should be printed, such as double-sided, five copies. If a print job consists of multiple pieces of print data, different pieces might have different processing instructions, such as 8 x 11 inch media for the first document, and 11 x 17 inch media for another document.</source>
          <target state="translated">印刷ジョブをプリンタに送信する際に、クライアントは、印刷データの特性を記述した属性、例えば文書名や、印刷データがどのように印刷されるべきかを記述した属性、例えば両面印刷、5部印刷などを提供する。印刷ジョブが複数の印刷データから構成されている場合には、最初の文書には8×11インチのメディアを使用し、別の文書には11×17インチのメディアを使用するといったように、別の文書ごとに異なる処理指示がなされる場合がある。</target>
        </trans-unit>
        <trans-unit id="8e9ff7cc584e16b6ab10015ab9bcdd0ba01476c5" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;#visitUnknown(javax.lang.model.element.AnnotationValue,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract annotation value visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">このような新しいvisitメソッドが追加されると、このクラスのデフォルトの実装は、&lt;a href=&quot;#visitUnknown(javax.lang.model.element.AnnotationValue,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことです。新しい言語レベルに対応するために、新しい抽象注釈値ビジタークラスも導入されます。この訪問者は、問題の訪問方法に対して異なるデフォルトの動作をします。新しいビジターが導入されると、このビジターの全部または一部が非推奨になる場合があります。</target>
        </trans-unit>
        <trans-unit id="7cee9708c809ea2c5706271d9f5de6094df8928a" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract element visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">このような新しいvisitメソッドが追加されると、このクラスのデフォルトの実装は、&lt;a href=&quot;#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことです。新しい言語レベルに対応するために、新しい抽象要素ビジタークラスも導入されます。この訪問者は、問題の訪問方法に対して異なるデフォルトの動作をします。新しいビジターが導入されると、このビジターの全部または一部が非推奨になる場合があります。</target>
        </trans-unit>
        <trans-unit id="103e345f76c16d48cafc8a85f69a007ae6fc9260" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;#visitUnknown(javax.lang.model.type.TypeMirror,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract type visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">このような新しいvisitメソッドが追加されると、このクラスのデフォルトの実装は、&lt;a href=&quot;#visitUnknown(javax.lang.model.type.TypeMirror,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことです。新しい言語レベルに対応するために、新しい抽象型ビジタークラスも導入されます。この訪問者は、問題の訪問方法に対して異なるデフォルトの動作をします。新しいビジターが導入されると、このビジターの全部または一部が非推奨になる場合があります。</target>
        </trans-unit>
        <trans-unit id="f0634269e692a9a236845f34b129b30b4ad1d950" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractannotationvaluevisitor6#visitUnknown(javax.lang.model.element.AnnotationValue,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract annotation value visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">このような新しいvisitメソッドが追加されると、このクラスのデフォルトの実装は、&lt;a href=&quot;abstractannotationvaluevisitor6#visitUnknown(javax.lang.model.element.AnnotationValue,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことです。新しい言語レベルに対応するために、新しい抽象注釈値ビジタークラスも導入されます。この訪問者は、問題の訪問方法に対して異なるデフォルトの動作をします。新しいビジターが導入されると、このビジターの全部または一部が非推奨になる場合があります。</target>
        </trans-unit>
        <trans-unit id="5bd8fde8037f05021ae5406815b06bfefd44e332" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractannotationvaluevisitor6#visitUnknown(javax.lang.model.element.AnnotationValue,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new simple annotation value visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">このような新しいvisitメソッドが追加されると、このクラスのデフォルトの実装は、&lt;a href=&quot;abstractannotationvaluevisitor6#visitUnknown(javax.lang.model.element.AnnotationValue,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことです。新しい言語レベルに対応するために、新しい単純な注釈値ビジタークラスも導入されます。この訪問者は、問題の訪問方法に対して異なるデフォルトの動作をします。新しいビジターが導入されると、このビジターの全部または一部が非推奨になる場合があります。</target>
        </trans-unit>
        <trans-unit id="03ec6c25b6d376081732b85e415911f8c6ec0d3e" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractannotationvaluevisitor6#visitUnknown-javax.lang.model.element.AnnotationValue-P-&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract annotation value visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">このような新しいvisitメソッドが追加されると、このクラスのデフォルトの実装は&lt;a href=&quot;abstractannotationvaluevisitor6#visitUnknown-javax.lang.model.element.AnnotationValue-P-&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことになります。新しい言語レベルに対応する新しい抽象アノテーション値ビジタークラスも導入されます。この訪問者は、問題の訪問メソッドのデフォルトの動作が異なります。新しいビジターが導入されると、このビジターのすべてまたは一部が廃止される可能性があります。</target>
        </trans-unit>
        <trans-unit id="05ff925b46ec11d08257cdc7e971c5f6bf2e8675" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractannotationvaluevisitor6#visitUnknown-javax.lang.model.element.AnnotationValue-P-&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new simple annotation value visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">このような新しいvisitメソッドが追加されると、このクラスのデフォルトの実装は&lt;a href=&quot;abstractannotationvaluevisitor6#visitUnknown-javax.lang.model.element.AnnotationValue-P-&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことになります。新しい単純なアノテーション値ビジタークラスも、新しい言語レベルに対応するために導入されます。この訪問者は、問題の訪問メソッドのデフォルトの動作が異なります。新しいビジターが導入されると、このビジターのすべてまたは一部が廃止される可能性があります。</target>
        </trans-unit>
        <trans-unit id="27c4228447106a355af0159031dee75cd1cf6476" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractelementvisitor6#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract element kind visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">このような新しいvisitメソッドが追加されると、このクラスのデフォルトの実装は、&lt;a href=&quot;abstractelementvisitor6#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことです。新しい言語レベルに対応するために、新しい抽象要素の種類のビジタークラスも導入されます。この訪問者は、問題の訪問方法に対して異なるデフォルトの動作をします。新しいビジターが導入されると、このビジターの全部または一部が非推奨になる場合があります。</target>
        </trans-unit>
        <trans-unit id="6211be69d40865a23b57629a99ebded376b30392" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractelementvisitor6#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract element visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">このような新しいvisitメソッドが追加されると、このクラスのデフォルトの実装は、&lt;a href=&quot;abstractelementvisitor6#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことです。新しい言語レベルに対応するために、新しい抽象要素ビジタークラスも導入されます。この訪問者は、問題の訪問方法に対して異なるデフォルトの動作をします。新しいビジターが導入されると、このビジターの全部または一部が非推奨になる場合があります。</target>
        </trans-unit>
        <trans-unit id="6c6e97c8e268ce1819909e688b39f6199c9409ae" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractelementvisitor6#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new element scanner visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">このような新しいvisitメソッドが追加されると、このクラスのデフォルトの実装は、&lt;a href=&quot;abstractelementvisitor6#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことです。新しい言語レベルに対応するために、新しい要素スキャナービジタークラスも導入されます。この訪問者は、問題の訪問方法に対して異なるデフォルトの動作をします。新しいビジターが導入されると、このビジターの全部または一部が非推奨になる場合があります。</target>
        </trans-unit>
        <trans-unit id="86581670b2bf6977794da9d077dabee784e08b42" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractelementvisitor6#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new simple element visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">このような新しいvisitメソッドが追加されると、このクラスのデフォルトの実装は、&lt;a href=&quot;abstractelementvisitor6#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことです。新しい言語レベルに対応するために、新しい単純な要素のビジタークラスも導入されます。この訪問者は、問題の訪問方法に対して異なるデフォルトの動作をします。新しいビジターが導入されると、このビジターの全部または一部が非推奨になる場合があります。</target>
        </trans-unit>
        <trans-unit id="044c236c1377724dc963f7b253a1633adebf4edd" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractelementvisitor6#visitUnknown-javax.lang.model.element.Element-P-&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract element kind visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">このような新しいvisitメソッドが追加されると、このクラスのデフォルトの実装は&lt;a href=&quot;abstractelementvisitor6#visitUnknown-javax.lang.model.element.Element-P-&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことになります。新しい抽象要素の種類のビジタークラスも、新しい言語レベルに対応するために導入されます。この訪問者は、問題の訪問メソッドのデフォルトの動作が異なります。新しいビジターが導入されると、このビジターのすべてまたは一部が廃止される可能性があります。</target>
        </trans-unit>
        <trans-unit id="710e79e570a5917821dfd7344c3f17284d9a4964" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractelementvisitor6#visitUnknown-javax.lang.model.element.Element-P-&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract element visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">このような新しいvisitメソッドが追加されると、このクラスのデフォルトの実装は&lt;a href=&quot;abstractelementvisitor6#visitUnknown-javax.lang.model.element.Element-P-&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことになります。新しい抽象要素ビジタークラスも、新しい言語レベルに対応するために導入されます。この訪問者は、問題の訪問メソッドのデフォルトの動作が異なります。新しいビジターが導入されると、このビジターのすべてまたは一部が廃止される可能性があります。</target>
        </trans-unit>
        <trans-unit id="bf2a73437432866576d26e93ec38ac98756a0ab7" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractelementvisitor6#visitUnknown-javax.lang.model.element.Element-P-&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new element scanner visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">このような新しいvisitメソッドが追加されると、このクラスのデフォルトの実装は&lt;a href=&quot;abstractelementvisitor6#visitUnknown-javax.lang.model.element.Element-P-&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことになります。新しい要素スキャナービジタークラスも、新しい言語レベルに対応するために導入されます。この訪問者は、問題の訪問メソッドのデフォルトの動作が異なります。新しいビジターが導入されると、このビジターのすべてまたは一部が廃止される可能性があります。</target>
        </trans-unit>
        <trans-unit id="d632be78f99f513b8aa8e1b7f5cb5683a59ff22f" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractelementvisitor6#visitUnknown-javax.lang.model.element.Element-P-&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new simple element visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">このような新しいvisitメソッドが追加されると、このクラスのデフォルトの実装は&lt;a href=&quot;abstractelementvisitor6#visitUnknown-javax.lang.model.element.Element-P-&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことになります。新しい言語レベルに対応するために、新しい単純な要素ビジタークラスも導入されます。この訪問者は、問題の訪問メソッドのデフォルトの動作が異なります。新しいビジターが導入されると、このビジターのすべてまたは一部が廃止される可能性があります。</target>
        </trans-unit>
        <trans-unit id="425c228d797e1d155d3a9aacad4b65a7e3cd8fc7" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstracttypevisitor6#visitUnknown(javax.lang.model.type.TypeMirror,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract type visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">このような新しいvisitメソッドが追加されると、このクラスのデフォルトの実装は、&lt;a href=&quot;abstracttypevisitor6#visitUnknown(javax.lang.model.type.TypeMirror,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことです。新しい言語レベルに対応するために、新しい抽象型ビジタークラスも導入されます。この訪問者は、問題の訪問方法に対して異なるデフォルトの動作をします。新しいビジターが導入されると、このビジターの全部または一部が非推奨になる場合があります。</target>
        </trans-unit>
        <trans-unit id="ca02dde6bf89fc22036125452b0233a9a4bb4fe0" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstracttypevisitor6#visitUnknown(javax.lang.model.type.TypeMirror,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new simple type visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">このような新しいvisitメソッドが追加されると、このクラスのデフォルトの実装は、&lt;a href=&quot;abstracttypevisitor6#visitUnknown(javax.lang.model.type.TypeMirror,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことです。新しい言語レベルに対応するために、新しいシンプルタイプのビジタークラスも導入されます。この訪問者は、問題の訪問方法に対して異なるデフォルトの動作をします。新しいビジターが導入されると、このビジターの全部または一部が非推奨になる場合があります。</target>
        </trans-unit>
        <trans-unit id="06a03ed21f6890e3698866751eba23ff67280af0" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstracttypevisitor6#visitUnknown(javax.lang.model.type.TypeMirror,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new type kind visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">このような新しいvisitメソッドが追加されると、このクラスのデフォルトの実装は、&lt;a href=&quot;abstracttypevisitor6#visitUnknown(javax.lang.model.type.TypeMirror,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことです。新しい言語レベルに対応するために、新しいタイプの親切なビジタークラスも導入されます。この訪問者は、問題の訪問方法に対して異なるデフォルトの動作をします。新しいビジターが導入されると、このビジターの全部または一部が非推奨になる場合があります。</target>
        </trans-unit>
        <trans-unit id="31a71bf88455082c4bc48a8526d303b8ca6d7ee4" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstracttypevisitor6#visitUnknown-javax.lang.model.type.TypeMirror-P-&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract type visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">このような新しいvisitメソッドが追加されると、このクラスのデフォルトの実装は&lt;a href=&quot;abstracttypevisitor6#visitUnknown-javax.lang.model.type.TypeMirror-P-&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことになります。新しい言語レベルに対応する新しい抽象型ビジタークラスも導入されます。この訪問者は、問題の訪問メソッドのデフォルトの動作が異なります。新しいビジターが導入されると、このビジターのすべてまたは一部が廃止される可能性があります。</target>
        </trans-unit>
        <trans-unit id="b0bd9887b4dede673a8a857fd6f562d2e6651e7c" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstracttypevisitor6#visitUnknown-javax.lang.model.type.TypeMirror-P-&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new simple type visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">このような新しいvisitメソッドが追加されると、このクラスのデフォルトの実装は&lt;a href=&quot;abstracttypevisitor6#visitUnknown-javax.lang.model.type.TypeMirror-P-&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことになります。新しい言語レベルに対応するために、新しい単純型ビジタークラスも導入されます。この訪問者は、問題の訪問メソッドのデフォルトの動作が異なります。新しいビジターが導入されると、このビジターのすべてまたは一部が廃止される可能性があります。</target>
        </trans-unit>
        <trans-unit id="c5e7913304df13157eca5adf23774332e392edc0" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstracttypevisitor6#visitUnknown-javax.lang.model.type.TypeMirror-P-&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new type kind visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">このような新しいvisitメソッドが追加されると、このクラスのデフォルトの実装は&lt;a href=&quot;abstracttypevisitor6#visitUnknown-javax.lang.model.type.TypeMirror-P-&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことになります。新しいタイプのビジタークラスも、新しい言語レベルに対応するために導入されます。この訪問者は、問題の訪問メソッドのデフォルトの動作が異なります。新しいビジターが導入されると、このビジターのすべてまたは一部が廃止される可能性があります。</target>
        </trans-unit>
        <trans-unit id="7169edd82e18117207c8b43effbe612c3734164e" translate="yes" xml:space="preserve">
          <source>When symbolic links are supported, then whether the resulting path, when resolved against this path, yields a path that can be used to locate the &lt;a href=&quot;files#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt;&lt;code&gt;same&lt;/code&gt;&lt;/a&gt; file as &lt;code&gt;other&lt;/code&gt; is implementation dependent. For example, if this path is &lt;code&gt;&quot;/a/b&quot;&lt;/code&gt; and the given path is &lt;code&gt;&quot;/a/x&quot;&lt;/code&gt; then the resulting relative path may be &lt;code&gt;
 &quot;../x&quot;&lt;/code&gt;. If &lt;code&gt;&quot;b&quot;&lt;/code&gt; is a symbolic link then is implementation dependent if &lt;code&gt;&quot;a/b/../x&quot;&lt;/code&gt; would locate the same file as &lt;code&gt;&quot;/a/x&quot;&lt;/code&gt;.</source>
          <target state="translated">シンボリックリンクがサポートされている場合、次いで得られたパスかどうかを、このパスに対して解決するとき、特定するために使用することができる経路が得られる&lt;a href=&quot;files#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt; &lt;code&gt;same&lt;/code&gt; &lt;/a&gt;のファイルを &lt;code&gt;other&lt;/code&gt; 実装に依存しています。たとえば、このパスが &lt;code&gt;&quot;/a/b&quot;&lt;/code&gt; で、指定されたパスが &lt;code&gt;&quot;/a/x&quot;&lt;/code&gt; 場合、結果の相対パスは &lt;code&gt; &quot;../x&quot;&lt;/code&gt; ます。場合は &lt;code&gt;&quot;b&quot;&lt;/code&gt; シンボリックリンクであるその後、実装依存である場合 &lt;code&gt;&quot;a/b/../x&quot;&lt;/code&gt; と同じファイルを見つけます &lt;code&gt;&quot;/a/x&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21130ee63b47bcee22d5206a3b440986ec034278" translate="yes" xml:space="preserve">
          <source>When symbolic links are supported, then whether the resulting path, when resolved against this path, yields a path that can be used to locate the &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt;&lt;code&gt;same&lt;/code&gt;&lt;/a&gt; file as &lt;code&gt;other&lt;/code&gt; is implementation dependent. For example, if this path is &lt;code&gt;&quot;/a/b&quot;&lt;/code&gt; and the given path is &lt;code&gt;&quot;/a/x&quot;&lt;/code&gt; then the resulting relative path may be &lt;code&gt;&quot;../x&quot;&lt;/code&gt;. If &lt;code&gt;&quot;b&quot;&lt;/code&gt; is a symbolic link then is implementation dependent if &lt;code&gt;&quot;a/b/../x&quot;&lt;/code&gt; would locate the same file as &lt;code&gt;&quot;/a/x&quot;&lt;/code&gt;.</source>
          <target state="translated">シンボリックリンクがサポートされている場合、結果のパスがこのパスに対して解決されるかどうかによって、 &lt;code&gt;other&lt;/code&gt; ファイルと&lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt; &lt;code&gt;same&lt;/code&gt; &lt;/a&gt;ファイルを見つけるために使用できるパスが実装に依存します。たとえば、このパスが &lt;code&gt;&quot;/a/b&quot;&lt;/code&gt; で、指定されたパスが &lt;code&gt;&quot;/a/x&quot;&lt;/code&gt; の場合、結果の相対パスは &lt;code&gt;&quot;../x&quot;&lt;/code&gt; になります。場合は &lt;code&gt;&quot;b&quot;&lt;/code&gt; シンボリックリンクであるその後、実装依存である場合 &lt;code&gt;&quot;a/b/../x&quot;&lt;/code&gt; と同じファイルを見つけます &lt;code&gt;&quot;/a/x&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9201aa7cc9fa88f4813925552674c147d8b25ef5" translate="yes" xml:space="preserve">
          <source>When testing the user-information, path, query, fragment, authority, or scheme-specific parts of two URIs for equality, the raw forms rather than the encoded forms of these components are compared and the hexadecimal digits of escaped octets are compared without regard to case.</source>
          <target state="translated">2つのURIのユーザー情報、パス、クエリ、フラグメント、権限、またはスキー ム固有の部分をテストするとき、これらの構成要素のエンコードされた形式ではなく生の形式が比較され、 エスケープされたオクテットの16進数桁が大文字小文字に関係なく比較される。</target>
        </trans-unit>
        <trans-unit id="2cb5a2d45e0a1e497d3635ca731bd3fec76abfbe" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;#enter()&quot;&gt;&lt;code&gt;enter()&lt;/code&gt;&lt;/a&gt; method is called, the current thread is blocked until the loop is terminated by the &lt;a href=&quot;#exit()&quot;&gt;&lt;code&gt;exit()&lt;/code&gt;&lt;/a&gt; method. Also, a new event loop is started on the event dispatch thread, which may or may not be the current thread. The loop can be terminated on any thread by calling its &lt;a href=&quot;#exit()&quot;&gt;&lt;code&gt;exit()&lt;/code&gt;&lt;/a&gt; method. After the loop is terminated, the &lt;code&gt;SecondaryLoop&lt;/code&gt; object can be reused to run a new nested event loop.</source>
          <target state="translated">場合&lt;a href=&quot;#enter()&quot;&gt; &lt;code&gt;enter()&lt;/code&gt; &lt;/a&gt;メソッドが呼び出されるループをすることによって終了するまで、現在のスレッドがブロックされている&lt;a href=&quot;#exit()&quot;&gt; &lt;code&gt;exit()&lt;/code&gt; &lt;/a&gt;メソッド。また、新しいイベントループがイベントディスパッチスレッドで開始されます。これは、現在のスレッドである場合とそうでない場合があります。ループは、&lt;a href=&quot;#exit()&quot;&gt; &lt;code&gt;exit()&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことにより、任意のスレッドで終了できます。ループが終了した後、 &lt;code&gt;SecondaryLoop&lt;/code&gt; オブジェクトを再利用して、新しいネストされたイベントループを実行できます。</target>
        </trans-unit>
        <trans-unit id="93c5bf1f5d3d11b7b3d1d812715baf3c9fe0fecb" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt;&lt;code&gt;LSResourceResolver&lt;/code&gt;&lt;/a&gt; is null, the implementation will behave as if the following &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt;&lt;code&gt;LSResourceResolver&lt;/code&gt;&lt;/a&gt; is set:</source>
          <target state="translated">とき&lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt; &lt;code&gt;LSResourceResolver&lt;/code&gt; &lt;/a&gt;nullでは、実装は次のようかのように動作します&lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt; &lt;code&gt;LSResourceResolver&lt;/code&gt; &lt;/a&gt;設定されています。</target>
        </trans-unit>
        <trans-unit id="9c71a117a0d78807772c45691dff3b7188404bd9" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt; is null, the implementation will behave as if the following &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt; is set:</source>
          <target state="translated">とき&lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; &lt;/a&gt;nullの場合、以下の場合と同様に、実装が動作します&lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; &lt;/a&gt;セットです。</target>
        </trans-unit>
        <trans-unit id="349843d9371dc6f3aced62d1709febefa1cdc8d8" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;objectinputfilter#checkInput(java.io.ObjectInputFilter.FilterInfo)&quot;&gt;&lt;code&gt;checkInput&lt;/code&gt;&lt;/a&gt; method is invoked it is given access to the current class, the array length, the current number of references already read from the stream, the depth of nested calls to &lt;a href=&quot;#readObject()&quot;&gt;&lt;code&gt;readObject&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#readUnshared()&quot;&gt;&lt;code&gt;readUnshared&lt;/code&gt;&lt;/a&gt;, and the implementation dependent number of bytes consumed from the input stream.</source>
          <target state="translated">場合&lt;a href=&quot;objectinputfilter#checkInput(java.io.ObjectInputFilter.FilterInfo)&quot;&gt; &lt;code&gt;checkInput&lt;/code&gt; の&lt;/a&gt;メソッドが呼び出され、それは現在のクラス、配列の長さへのアクセスを与えられ、既にストリームにネストされた呼び出しの深さから読み出し参照の現在の数&lt;a href=&quot;#readObject()&quot;&gt; &lt;code&gt;readObject&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#readUnshared()&quot;&gt; &lt;code&gt;readUnshared&lt;/code&gt; &lt;/a&gt;、およびバイトの実装に依存数から消費しました入力ストリーム。</target>
        </trans-unit>
        <trans-unit id="ab0a44a62ffe84a96b19e3bf378964ba73e0fcca" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;CachedRowSet&lt;/code&gt; method &lt;code&gt;acceptChanges&lt;/code&gt; is called, it delegates to the &lt;code&gt;RowSet&lt;/code&gt; object's &lt;code&gt;SyncProvider&lt;/code&gt; object. How the writer provided by that &lt;code&gt;SyncProvider&lt;/code&gt; object is implemented determines what level (grade) of checking for conflicts will be done. After all checking for conflicts is completed and one or more conflicts has been found, the method &lt;code&gt;acceptChanges&lt;/code&gt; throws a &lt;code&gt;SyncProviderException&lt;/code&gt; object. The application can catch the exception and use it to obtain a &lt;code&gt;SyncResolver&lt;/code&gt; object.</source>
          <target state="translated">とき &lt;code&gt;CachedRowSet&lt;/code&gt; のメソッド &lt;code&gt;acceptChanges&lt;/code&gt; ではに、それの代表と呼ばれ &lt;code&gt;RowSet&lt;/code&gt; オブジェクトの &lt;code&gt;SyncProvider&lt;/code&gt; オブジェクト。その &lt;code&gt;SyncProvider&lt;/code&gt; オブジェクトによって提供されるライターがどのように実装されるかによって、競合のチェックのレベル（グレード）が決まります。競合のすべてのチェックが完了し、1つ以上の競合が見つかった後、メソッド &lt;code&gt;acceptChanges&lt;/code&gt; は &lt;code&gt;SyncProviderException&lt;/code&gt; オブジェクトをスローします。アプリケーションは例外をキャッチし、それを使用して &lt;code&gt;SyncResolver&lt;/code&gt; オブジェクトを取得できます。</target>
        </trans-unit>
        <trans-unit id="72afefcfd2d2b20f95a8bc304631fb4c64f7b278" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;HttpResponse&lt;/code&gt; object is returned, the body has been completely written to the byte array.</source>
          <target state="translated">とき &lt;code&gt;HttpResponse&lt;/code&gt; オブジェクトが返され、体が完全にバイト配列に書き込まれています。</target>
        </trans-unit>
        <trans-unit id="0d9e780897f9f330f634a20683b4c50779ddf071" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;HttpResponse&lt;/code&gt; object is returned, the body has been completely written to the consumer.</source>
          <target state="translated">とき &lt;code&gt;HttpResponse&lt;/code&gt; オブジェクトが返され、体が完全に消費者に書き込まれています。</target>
        </trans-unit>
        <trans-unit id="ba9826c0dffb73820d59d4df3c02f81a55a41d8a" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;HttpResponse&lt;/code&gt; object is returned, the body has been completely written to the file and &lt;a href=&quot;httpresponse#body()&quot;&gt;&lt;code&gt;HttpResponse.body()&lt;/code&gt;&lt;/a&gt; returns a &lt;code&gt;Path&lt;/code&gt; object for the file. The returned &lt;code&gt;Path&lt;/code&gt; is the combination of the supplied directory name and the file name supplied by the server. If the destination directory does not exist or cannot be written to, then the response will fail with an &lt;a href=&quot;../../../../java.base/java/io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">とき &lt;code&gt;HttpResponse&lt;/code&gt; オブジェクトが返され、体が完全にファイルに書き込まれてきた&lt;a href=&quot;httpresponse#body()&quot;&gt; &lt;code&gt;HttpResponse.body()&lt;/code&gt; &lt;/a&gt;を返す &lt;code&gt;Path&lt;/code&gt; ファイルのオブジェクトを。返される &lt;code&gt;Path&lt;/code&gt; は、指定されたディレクトリ名とサーバーによって指定されたファイル名の組み合わせです。宛先ディレクトリが存在しないか、&lt;a href=&quot;../../../../java.base/java/io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt;ができない場合、応答はIOExceptionで失敗します。</target>
        </trans-unit>
        <trans-unit id="ae8fe4cf9af58eae2641375733a0acff7ecc038a" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;HttpResponse&lt;/code&gt; object is returned, the body has been completely written to the file, and &lt;a href=&quot;httpresponse#body()&quot;&gt;&lt;code&gt;HttpResponse.body()&lt;/code&gt;&lt;/a&gt; returns a reference to its &lt;a href=&quot;../../../../java.base/java/nio/file/path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">場合 &lt;code&gt;HttpResponse&lt;/code&gt; オブジェクトが返され、本体が完全にファイルに書き込まれたものであり、&lt;a href=&quot;httpresponse#body()&quot;&gt; &lt;code&gt;HttpResponse.body()&lt;/code&gt; &lt;/a&gt;それへの参照戻り&lt;a href=&quot;../../../../java.base/java/nio/file/path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7f8b7f93bc4b770c2f3611214ea9f4ae4a8f5b0d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;HttpResponse&lt;/code&gt; object is returned, the body has been completely written to the string.</source>
          <target state="translated">とき &lt;code&gt;HttpResponse&lt;/code&gt; オブジェクトが返され、体が完全に文字列に書き込まれています。</target>
        </trans-unit>
        <trans-unit id="d434402a35c684d119251a82bd168ecbc741dd91" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;HttpResponse&lt;/code&gt; object is returned, the body may not have been completely received.</source>
          <target state="translated">とき &lt;code&gt;HttpResponse&lt;/code&gt; オブジェクトが返され、体が完全に受信されていないかもしれません。</target>
        </trans-unit>
        <trans-unit id="3e5ca13755a6bfd06a017657997d9818861116f6" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;HttpResponse&lt;/code&gt; object is returned, the response headers will have been completely read, but the body may not have been fully received yet. The &lt;a href=&quot;httpresponse#body()&quot;&gt;&lt;code&gt;HttpResponse.body()&lt;/code&gt;&lt;/a&gt; method returns a &lt;a href=&quot;../../../../java.base/java/util/concurrent/flow.publisher&quot;&gt;&lt;code&gt;Publisher&lt;list&gt;&amp;gt;&lt;/list&gt;&lt;/code&gt;&lt;/a&gt; from which the body response bytes can be obtained as they are received. The publisher can and must be subscribed to only once.</source>
          <target state="translated">とき &lt;code&gt;HttpResponse&lt;/code&gt; オブジェクトが返され、レスポンスヘッダは完全に読まれているでしょうが、体は完全にまだ受信されていない可能性があります。&lt;a href=&quot;httpresponse#body()&quot;&gt; &lt;code&gt;HttpResponse.body()&lt;/code&gt; &lt;/a&gt;メソッドを返し&lt;a href=&quot;../../../../java.base/java/util/concurrent/flow.publisher&quot;&gt; &lt;code&gt;Publisher&lt;list&gt;&amp;gt;&lt;/list&gt;&lt;/code&gt; &lt;/a&gt;ボディ応答バイトは、受信時に取得できます。出版社は一度だけ購読することができ、購読しなければなりません。</target>
        </trans-unit>
        <trans-unit id="9b1d642a866048552e189045dd9a35591fae905b" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;HttpResponse&lt;/code&gt; object is returned, the response headers will have been completely read, but the body may not have been fully received yet. The &lt;a href=&quot;httpresponse#body()&quot;&gt;&lt;code&gt;HttpResponse.body()&lt;/code&gt;&lt;/a&gt; method returns an &lt;a href=&quot;../../../../java.base/java/io/inputstream&quot;&gt;&lt;code&gt;InputStream&lt;/code&gt;&lt;/a&gt; from which the body can be read as it is received.</source>
          <target state="translated">とき &lt;code&gt;HttpResponse&lt;/code&gt; オブジェクトが返され、レスポンスヘッダは完全に読まれているでしょうが、体は完全にまだ受信されていない可能性があります。&lt;a href=&quot;httpresponse#body()&quot;&gt; &lt;code&gt;HttpResponse.body()&lt;/code&gt; &lt;/a&gt;メソッドを返し&lt;a href=&quot;../../../../java.base/java/io/inputstream&quot;&gt; &lt;code&gt;InputStream&lt;/code&gt; &lt;/a&gt;が受信されると本体が読み取ることができるからです。</target>
        </trans-unit>
        <trans-unit id="1ee08c821ac6ffd8d690cbbc08d004846b4f65e3" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;Printable&lt;/code&gt; is obtained from a client-supplied &lt;code&gt;Pageable&lt;/code&gt; then the client may provide different PageFormats for each page index. Calculations of page breaks must account for this.</source>
          <target state="translated">場合 &lt;code&gt;Printable&lt;/code&gt; クライアント供給から得られる &lt;code&gt;Pageable&lt;/code&gt; その後、クライアントは、各ページのインデックスの異なるPageFormatsを提供することができます。改ページの計算では、これを考慮する必要があります。</target>
        </trans-unit>
        <trans-unit id="8da723286e46b5dcc04253d5d4b818f47a7e075f" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;RowSet&lt;/code&gt; object changes one of its rows, changes all of it rows, or moves its cursor, it also notifies each listener that is registered with it. The listener reacts by carrying out its implementation of the notification method called on it.</source>
          <target state="translated">場合 &lt;code&gt;RowSet&lt;/code&gt; オブジェクトは、その行の1つを変更し、それのすべての行を変更し、またはそのカーソルを移動させ、それはまた、それに登録されている各リスナーに通知します。リスナーは、呼び出された通知メソッドの実装を実行することによって反応します。</target>
        </trans-unit>
        <trans-unit id="ee7ac132993577ecd59468c3647a9e567b53ac77" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;add&lt;/code&gt; method is called to add a Permission, the Permission is stored in the appropriate PermissionCollection. If no such collection exists yet, the Permission object's class is determined and the &lt;code&gt;newPermissionCollection&lt;/code&gt; method is called on that class to create the PermissionCollection and add it to the Permissions object. If &lt;code&gt;newPermissionCollection&lt;/code&gt; returns null, then a default PermissionCollection that uses a hashtable will be created and used. Each hashtable entry stores a Permission object as both the key and the value.</source>
          <target state="translated">場合 &lt;code&gt;add&lt;/code&gt; 方法はアクセス許可を追加するために呼び出され、アクセス許可が適切なのPermissionCollectionに格納されています。そのようなコレクションがまだ存在しない場合、Permissionオブジェクトのクラスが決定され、そのクラスで &lt;code&gt;newPermissionCollection&lt;/code&gt; メソッドが呼び出されてPermissionCollectionが作成され、Permissionオブジェクトに追加されます。 &lt;code&gt;newPermissionCollection&lt;/code&gt; がnullを返す場合、ハッシュテーブルを使用するデフォルトのPermissionCollectionが作成され、使用されます。各ハッシュテーブルエントリは、キーと値の両方としてPermissionオブジェクトを格納します。</target>
        </trans-unit>
        <trans-unit id="b88d575b7afc2c5eb726273e486f2105b12c75a9" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;cellRenderer&lt;/code&gt; or &lt;code&gt;cellEditor&lt;/code&gt; parameter is &lt;code&gt;null&lt;/code&gt;, a default value provided by the &lt;code&gt;JTable&lt;/code&gt;&lt;code&gt;getDefaultRenderer&lt;/code&gt; or &lt;code&gt;getDefaultEditor&lt;/code&gt; method, respectively, is used to provide defaults based on the type of the data in this column. This column-centric rendering strategy can be circumvented by overriding the &lt;code&gt;getCellRenderer&lt;/code&gt; methods in &lt;code&gt;JTable&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;cellRenderer&lt;/code&gt; または &lt;code&gt;cellEditor&lt;/code&gt; をパラメータは &lt;code&gt;null&lt;/code&gt; 、によって提供されるデフォルト値 &lt;code&gt;JTable&lt;/code&gt; &lt;code&gt;getDefaultRenderer&lt;/code&gt; 又は &lt;code&gt;getDefaultEditor&lt;/code&gt; の方法であって、それぞれ、この列のデータの種類に基づいて、デフォルト値を提供するために使用されます。この列中心のレンダリング戦略は、 &lt;code&gt;JTable&lt;/code&gt; の &lt;code&gt;getCellRenderer&lt;/code&gt; メソッドをオーバーライドすることで回避できます。</target>
        </trans-unit>
        <trans-unit id="7bda165d83525f9548659c3eec7e03d20271f7a7" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;getCallerClass&lt;/code&gt; method is called from a method that is the bottom most frame on the stack, for example, &lt;code&gt;static public void main&lt;/code&gt; method launched by the &lt;code&gt;java&lt;/code&gt; launcher, or a method invoked from a JNI attached thread, &lt;code&gt;IllegalCallerException&lt;/code&gt; is thrown.</source>
          <target state="translated">When the &lt;code&gt;getCallerClass&lt;/code&gt; method is called from a method that is the bottom most frame on the stack, for example, &lt;code&gt;static public void main&lt;/code&gt; method launched by the &lt;code&gt;java&lt;/code&gt; launcher, or a method invoked from a JNI attached thread, &lt;code&gt;IllegalCallerException&lt;/code&gt; is thrown.</target>
        </trans-unit>
        <trans-unit id="5d8cbad25caa72fa532ed2521b7fd96e96a6b5fa" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;invokevirtual&lt;/code&gt; is executed after linking, the receiving VarHandle's access mode type is first checked by the JVM to ensure that it matches the symbolic type descriptor. If the type match fails, it means that the access mode method which the caller is invoking is not present on the individual VarHandle being invoked.</source>
          <target state="translated">When the &lt;code&gt;invokevirtual&lt;/code&gt; is executed after linking, the receiving VarHandle's access mode type is first checked by the JVM to ensure that it matches the symbolic type descriptor. If the type match fails, it means that the access mode method which the caller is invoking is not present on the individual VarHandle being invoked.</target>
        </trans-unit>
        <trans-unit id="d4ff583386f934e25bcb252a53631116c45f985a" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;invokevirtual&lt;/code&gt; is executed after linking, the receiving method handle's type is first checked by the JVM to ensure that it matches the symbolic type descriptor. If the type match fails, it means that the method which the caller is invoking is not present on the individual method handle being invoked.</source>
          <target state="translated">とき &lt;code&gt;invokevirtual&lt;/code&gt; リンク後に実行され、受信方法ハンドルの型は最初、それがシンボリック型記述子と一致していることを保証するために、JVMによってチェックされます。タイプの一致が失敗した場合は、呼び出し元が呼び出しているメソッドが、呼び出されている個々のメソッドハンドルに存在しないことを意味します。</target>
        </trans-unit>
        <trans-unit id="8226f6246b0d0b9cfb2a7ab0e96a44673f4a1c3a" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;keyIdentifier&lt;/code&gt; field of &lt;code&gt;AuthorityKeyIdentifier&lt;/code&gt; is populated, the value is usually taken from the &lt;code&gt;SubjectKeyIdentifier&lt;/code&gt; extension in the issuer's certificate. Note, however, that the result of &lt;code&gt;X509Certificate.getExtensionValue(&amp;lt;SubjectKeyIdentifier Object
 Identifier&amp;gt;)&lt;/code&gt; on the issuer's certificate may NOT be used directly as the input to &lt;code&gt;setAuthorityKeyIdentifier&lt;/code&gt;. This is because the SubjectKeyIdentifier contains only a KeyIdentifier OCTET STRING, and not a SEQUENCE of KeyIdentifier, GeneralNames, and CertificateSerialNumber. In order to use the extension value of the issuer certificate's &lt;code&gt;SubjectKeyIdentifier&lt;/code&gt; extension, it will be necessary to extract the value of the embedded &lt;code&gt;KeyIdentifier&lt;/code&gt; OCTET STRING, then DER encode this OCTET STRING inside a SEQUENCE. For more details on SubjectKeyIdentifier, see &lt;a href=&quot;#setSubjectKeyIdentifier(byte%5B%5D)&quot;&gt;&lt;code&gt;setSubjectKeyIdentifier(byte[] subjectKeyID)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">When the &lt;code&gt;keyIdentifier&lt;/code&gt; field of &lt;code&gt;AuthorityKeyIdentifier&lt;/code&gt; is populated, the value is usually taken from the &lt;code&gt;SubjectKeyIdentifier&lt;/code&gt; extension in the issuer's certificate. Note, however, that the result of &lt;code&gt;X509Certificate.getExtensionValue(&amp;lt;SubjectKeyIdentifier Object Identifier&amp;gt;)&lt;/code&gt; on the issuer's certificate may NOT be used directly as the input to &lt;code&gt;setAuthorityKeyIdentifier&lt;/code&gt; . This is because the SubjectKeyIdentifier contains only a KeyIdentifier OCTET STRING, and not a SEQUENCE of KeyIdentifier, GeneralNames, and CertificateSerialNumber. In order to use the extension value of the issuer certificate's &lt;code&gt;SubjectKeyIdentifier&lt;/code&gt; extension, it will be necessary to extract the value of the embedded &lt;code&gt;KeyIdentifier&lt;/code&gt; OCTET STRING, then DER encode this OCTET STRING inside a SEQUENCE. For more details on SubjectKeyIdentifier, see &lt;a href=&quot;#setSubjectKeyIdentifier(byte%5B%5D)&quot;&gt; &lt;code&gt;setSubjectKeyIdentifier(byte[] subjectKeyID)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="834601037ab0662f3396b5a79222cc36559945fd" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;keyIdentifier&lt;/code&gt; field of &lt;code&gt;AuthorityKeyIdentifier&lt;/code&gt; is populated, the value is usually taken from the &lt;code&gt;SubjectKeyIdentifier&lt;/code&gt; extension in the issuer's certificate. Note, however, that the result of &lt;code&gt;X509Certificate.getExtensionValue(&amp;lt;SubjectKeyIdentifier Object
 Identifier&amp;gt;)&lt;/code&gt; on the issuer's certificate may NOT be used directly as the input to &lt;code&gt;setAuthorityKeyIdentifier&lt;/code&gt;. This is because the SubjectKeyIdentifier contains only a KeyIdentifier OCTET STRING, and not a SEQUENCE of KeyIdentifier, GeneralNames, and CertificateSerialNumber. In order to use the extension value of the issuer certificate's &lt;code&gt;SubjectKeyIdentifier&lt;/code&gt; extension, it will be necessary to extract the value of the embedded &lt;code&gt;KeyIdentifier&lt;/code&gt; OCTET STRING, then DER encode this OCTET STRING inside a SEQUENCE. For more details on SubjectKeyIdentifier, see &lt;a href=&quot;x509certselector#setSubjectKeyIdentifier-byte:A-&quot;&gt;&lt;code&gt;setSubjectKeyIdentifier(byte[] subjectKeyID)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;AuthorityKeyIdentifier&lt;/code&gt; の &lt;code&gt;keyIdentifier&lt;/code&gt; フィールドに値が入力されると、通常、値は発行者の証明書の &lt;code&gt;SubjectKeyIdentifier&lt;/code&gt; 拡張から取得されます。ただし、発行者の証明書に対する &lt;code&gt;X509Certificate.getExtensionValue(&amp;lt;SubjectKeyIdentifier Object Identifier&amp;gt;)&lt;/code&gt; の結果は、 &lt;code&gt;setAuthorityKeyIdentifier&lt;/code&gt; への入力として直接使用できない場合があることに注意してください。これは、SubjectKeyIdentifierにはKeyIdentifier OCTET STRINGのみが含まれ、KeyIdentifier、GeneralNames、およびCertificateSerialNumberのシーケンスは含まれないためです。発行者証明書の &lt;code&gt;SubjectKeyIdentifier&lt;/code&gt; 拡張の拡張値を使用するには、埋め込まれた値を抽出する必要があります。 &lt;code&gt;KeyIdentifier&lt;/code&gt; OCTET STRING、次にDERはこのOCTET STRINGをSEQUENCE内にエンコードします。SubjectKeyIdentifierの詳細については、&lt;a href=&quot;x509certselector#setSubjectKeyIdentifier-byte:A-&quot;&gt; &lt;code&gt;setSubjectKeyIdentifier(byte[] subjectKeyID)&lt;/code&gt; &lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a8d5a455eaa9bae77e2400ec125089de5958ee67" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;nextToken&lt;/code&gt; method encounters a string constant, the &lt;code&gt;ttype&lt;/code&gt; field is set to the string delimiter and the &lt;code&gt;sval&lt;/code&gt; field is set to the body of the string.</source>
          <target state="translated">場合 &lt;code&gt;nextToken&lt;/code&gt; 方法は、文字列定数に遭遇し、 &lt;code&gt;ttype&lt;/code&gt; フィールドは、文字列の区切りに設定され、 &lt;code&gt;sval&lt;/code&gt; フィールドは、文字列の本体に設定されています。</target>
        </trans-unit>
        <trans-unit id="479c547e4f51a87c5259ae916511976a07f64d0b" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;object&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method writes an SQL &lt;code&gt;NULL&lt;/code&gt; to the stream.</source>
          <target state="translated">When the &lt;code&gt;object&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; , this method writes an SQL &lt;code&gt;NULL&lt;/code&gt; to the stream.</target>
        </trans-unit>
        <trans-unit id="a7c8af093f9042d418aa0a04feb575a30082784d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;registerApplicationClasspathSpis&lt;/code&gt; method is called, additional service provider instances will be discovered using &lt;a href=&quot;../../../../java.base/java/util/serviceloader&quot;&gt;&lt;code&gt;ServiceLoader&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">When the &lt;code&gt;registerApplicationClasspathSpis&lt;/code&gt; method is called, additional service provider instances will be discovered using &lt;a href=&quot;../../../../java.base/java/util/serviceloader&quot;&gt; &lt;code&gt;ServiceLoader&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="fad260ae6f20782961df5b3d238d1f3fbcb7ca36" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;registerApplicationClasspathSpis&lt;/code&gt; method is called, service provider instances declared in the meta-information section of JAR files on the application class path are loaded. To declare a service provider, a &lt;code&gt;services&lt;/code&gt; subdirectory is placed within the &lt;code&gt;META-INF&lt;/code&gt; directory that is present in every JAR file. This directory contains a file for each service provider interface that has one or more implementation classes present in the JAR file. For example, if the JAR file contained a class named &lt;code&gt;com.mycompany.imageio.MyFormatReaderSpi&lt;/code&gt; which implements the &lt;code&gt;ImageReaderSpi&lt;/code&gt; interface, the JAR file would contain a file named:</source>
          <target state="translated">とき &lt;code&gt;registerApplicationClasspathSpis&lt;/code&gt; のメソッドが呼び出され、アプリケーションのクラスパス上のJARファイルのメタ情報セクションで宣言されたサービスプロバイダインスタンスがロードされます。サービスプロバイダーを宣言するために、すべてのJARファイルにある &lt;code&gt;META-INF&lt;/code&gt; ディレクトリ内に &lt;code&gt;services&lt;/code&gt; サブディレクトリが配置されます。このディレクトリには、JARファイルに1つ以上の実装クラスが存在する各サービスプロバイダーインターフェースのファイルが含まれています。たとえば、JARファイルに &lt;code&gt;ImageReaderSpi&lt;/code&gt; インターフェースを実装する &lt;code&gt;com.mycompany.imageio.MyFormatReaderSpi&lt;/code&gt; という名前のクラスが含まれている場合、JARファイルには次の名前のファイルが含まれます。</target>
        </trans-unit>
        <trans-unit id="800a8722fdd5697538b5f0c521ac05a66ca1b2c2" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;value&lt;/code&gt; property changes, &lt;code&gt;ChangeListeners&lt;/code&gt; are notified. &lt;code&gt;SpinnerModel&lt;/code&gt; may choose to notify the &lt;code&gt;ChangeListeners&lt;/code&gt; under other circumstances.</source>
          <target state="translated">When the &lt;code&gt;value&lt;/code&gt; property changes, &lt;code&gt;ChangeListeners&lt;/code&gt; are notified. &lt;code&gt;SpinnerModel&lt;/code&gt; may choose to notify the &lt;code&gt;ChangeListeners&lt;/code&gt; under other circumstances.</target>
        </trans-unit>
        <trans-unit id="515adaec2191bebc2d2c17a699cb4b4c2d2e4592" translate="yes" xml:space="preserve">
          <source>When the BasicAttributes class needs to create an Attribute, it uses BasicAttribute. There is no other dependency on BasicAttribute.</source>
          <target state="translated">BasicAttributes クラスが Attribute を作成する必要がある場合、BasicAttribute を使用します。BasicAttributeには他に依存するものはありません。</target>
        </trans-unit>
        <trans-unit id="3ec9901f8b0995c7d238dee247f5bc92ba92c9c8" translate="yes" xml:space="preserve">
          <source>When the DBMS does not store time zone information, the driver will use the given &lt;code&gt;Calendar&lt;/code&gt; object to construct the SQL &lt;code&gt;TIME&lt;/code&gt; value to send to the database. With a &lt;code&gt;Calendar&lt;/code&gt; object, the driver can calculate the date taking into account a custom time zone. If no &lt;code&gt;Calendar&lt;/code&gt; object is specified, the driver uses the time zone of the Virtual Machine that is running the application.</source>
          <target state="translated">When the DBMS does not store time zone information, the driver will use the given &lt;code&gt;Calendar&lt;/code&gt; object to construct the SQL &lt;code&gt;TIME&lt;/code&gt; value to send to the database. With a &lt;code&gt;Calendar&lt;/code&gt; object, the driver can calculate the date taking into account a custom time zone. If no &lt;code&gt;Calendar&lt;/code&gt; object is specified, the driver uses the time zone of the Virtual Machine that is running the application.</target>
        </trans-unit>
        <trans-unit id="45a7b9314633389caa68b45c357b57d0f9fe579c" translate="yes" xml:space="preserve">
          <source>When the DBMS does not store time zone information, the driver will use the given &lt;code&gt;Calendar&lt;/code&gt; object to construct the SQL &lt;code&gt;TIMESTAMP&lt;/code&gt; value to send to the database. With a &lt;code&gt;Calendar&lt;/code&gt; object, the driver can calculate the timestamp taking into account a custom time zone. If no &lt;code&gt;Calendar&lt;/code&gt; object is specified, the driver uses the time zone of the Virtual Machine that is running the application.</source>
          <target state="translated">When the DBMS does not store time zone information, the driver will use the given &lt;code&gt;Calendar&lt;/code&gt; object to construct the SQL &lt;code&gt;TIMESTAMP&lt;/code&gt; value to send to the database. With a &lt;code&gt;Calendar&lt;/code&gt; object, the driver can calculate the timestamp taking into account a custom time zone. If no &lt;code&gt;Calendar&lt;/code&gt; object is specified, the driver uses the time zone of the Virtual Machine that is running the application.</target>
        </trans-unit>
        <trans-unit id="e2b0cfb7cdca209b8227f0135c9ead5e644da49f" translate="yes" xml:space="preserve">
          <source>When the JNDI class library needs to determine the value of a property, it does so by merging the values from the following two sources, in order:</source>
          <target state="translated">JNDI クラス・ライブラリがプロパティの値を決定する必要がある場合、以下の 2 つのソースから順番に値をマージすることでそれを行います。</target>
        </trans-unit>
        <trans-unit id="8ff307d52b74a9d5a00fe0eeed0ad2b6f63f945d" translate="yes" xml:space="preserve">
          <source>When the JVM materializes a &lt;code&gt;MethodType&lt;/code&gt; from a descriptor string, all classes named in the descriptor must be accessible, and will be loaded. (But the classes need not be initialized, as is the case with a &lt;code&gt;CONSTANT_Class&lt;/code&gt;.) This loading may occur at any time before the &lt;code&gt;MethodType&lt;/code&gt; object is first derived.</source>
          <target state="translated">JVM が記述子文字列から &lt;code&gt;MethodType&lt;/code&gt; を具体化するとき、記述子で指定されたすべてのクラスはアクセス可能でなければならず、ロードされます。 （ただし、 &lt;code&gt;CONSTANT_Class&lt;/code&gt; の場合のように、クラスを初期化する必要はありません。）この読み込みは、 &lt;code&gt;MethodType&lt;/code&gt; オブジェクトが最初に派生する前であればいつでも発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="242f542a50d3a5d71e04513db113467fef250729" translate="yes" xml:space="preserve">
          <source>When the JVM processes bytecode containing signature polymorphic calls, it will successfully link any such call, regardless of its symbolic type descriptor. (In order to retain type safety, the JVM will guard such calls with suitable dynamic type checks, as described elsewhere.)</source>
          <target state="translated">JVMがシグネチャ・ポリモーフィック呼び出しを含むバイトコードを処理する場合、JVMは、そのシンボリック・タイプ記述子に関係なく、そのような呼び出しを正常にリンクします。(型の安全性を保持するために、JVMは、別の場所で説明されているように、適切な動的型チェックでそのような呼び出しを保護します)。</target>
        </trans-unit>
        <trans-unit id="2193c7a9c7d458a9821bb858408d7793d0ae7d86" translate="yes" xml:space="preserve">
          <source>When the Java Virtual Machine first starts, it determines if the system property &lt;code&gt;java.compiler&lt;/code&gt; exists. (System properties are accessible through &lt;a href=&quot;system#getProperty-java.lang.String-&quot;&gt;&lt;code&gt;System.getProperty(String)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;system#getProperty-java.lang.String-java.lang.String-&quot;&gt;&lt;code&gt;System.getProperty(String, String)&lt;/code&gt;&lt;/a&gt;. If so, it is assumed to be the name of a library (with a platform-dependent exact location and type); &lt;a href=&quot;system#loadLibrary-java.lang.String-&quot;&gt;&lt;code&gt;System.loadLibrary(java.lang.String)&lt;/code&gt;&lt;/a&gt; is called to load that library. If this loading succeeds, the function named &lt;code&gt;java_lang_Compiler_start()&lt;/code&gt; in that library is called.</source>
          <target state="translated">Java仮想マシンは、最初の起動時に、システムプロパティ &lt;code&gt;java.compiler&lt;/code&gt; が存在するかどうかを判断します。（システムプロパティは&lt;a href=&quot;system#getProperty-java.lang.String-&quot;&gt; &lt;code&gt;System.getProperty(String)&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;system#getProperty-java.lang.String-java.lang.String-&quot;&gt; &lt;code&gt;System.getProperty(String, String)&lt;/code&gt; &lt;/a&gt;を介してアクセスできます。アクセスできる場合は、ライブラリの名前であると想定されます（プラットフォームに依存する正確な場所とタイプ））; &lt;a href=&quot;system#loadLibrary-java.lang.String-&quot;&gt; &lt;code&gt;System.loadLibrary(java.lang.String)&lt;/code&gt; &lt;/a&gt;が呼び出され、そのライブラリがロードされます。このロードが成功すると、そのライブラリ内の &lt;code&gt;java_lang_Compiler_start()&lt;/code&gt; という名前の関数が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="ddddab91c8fcafe94a4c994027d61bf864bf4c44" translate="yes" xml:space="preserve">
          <source>When the Java virtual machine has no stack trace information about a thread or &lt;code&gt;maxDepth == 0&lt;/code&gt;, the stack trace in the &lt;code&gt;ThreadInfo&lt;/code&gt; object will be an empty array of &lt;code&gt;StackTraceElement&lt;/code&gt;.</source>
          <target state="translated">Java仮想マシンにスレッドまたは &lt;code&gt;maxDepth == 0&lt;/code&gt; に関するスタックトレース情報がない場合、 &lt;code&gt;ThreadInfo&lt;/code&gt; オブジェクトのスタックトレースは &lt;code&gt;StackTraceElement&lt;/code&gt; の空の配列になります。</target>
        </trans-unit>
        <trans-unit id="38db82049f33225d933e0b41a46907899f2d6c86" translate="yes" xml:space="preserve">
          <source>When the LoginContext uses the installed Configuration (instead of a caller-specified Configuration, see above), then this LoginContext must wrap any caller-specified or default CallbackHandler implementation in a new CallbackHandler implementation whose &lt;code&gt;handle&lt;/code&gt; method implementation invokes the specified CallbackHandler's &lt;code&gt;handle&lt;/code&gt; method in a &lt;code&gt;java.security.AccessController.doPrivileged&lt;/code&gt; call constrained by the caller's current &lt;code&gt;AccessControlContext&lt;/code&gt;.</source>
          <target state="translated">LoginContextが、（呼び出し元が指定した構成ではなく、上記を参照）インストール済みの構成を使用する場合、このLoginContextは、呼び出し元が指定した、またはデフォルトのCallbackHandler実装を、 &lt;code&gt;handle&lt;/code&gt; メソッドの実装が指定されたCallbackHandlerの &lt;code&gt;handle&lt;/code&gt; メソッドを呼び出す新しいCallbackHandler実装にラップする必要があります。呼び出し元の現在の &lt;code&gt;AccessControlContext&lt;/code&gt; によって制約された &lt;code&gt;java.security.AccessController.doPrivileged&lt;/code&gt; 呼び出し。</target>
        </trans-unit>
        <trans-unit id="5cf48683ff79ab19b22e2f40ce14d8b39cb8a4f9" translate="yes" xml:space="preserve">
          <source>When the MAX and MIN bounds are hit</source>
          <target state="translated">MAXとMINの境界線がヒットした場合</target>
        </trans-unit>
        <trans-unit id="d4284eca7ac5f100fd0fbfcaaa47ff80683f124b" translate="yes" xml:space="preserve">
          <source>When the OOBINLINE option is set, any TCP urgent data received on the socket will be received through the socket input stream.</source>
          <target state="translated">OOBINLINE オプションが設定されている場合、ソケットで受信した TCP 緊急データは、ソケット入力ストリームを介して受信されます。</target>
        </trans-unit>
        <trans-unit id="59ad08ab5cdf3a4c4f05c736af38894997dad527" translate="yes" xml:space="preserve">
          <source>When the OOBINLINE option is set, any TCP urgent data received on the socket will be received through the socket input stream. When the option is disabled (which is the default) urgent data is silently discarded.</source>
          <target state="translated">OOBINLINE オプションが設定されている場合、ソケットで受信した TCP 緊急データは、ソケット入力ストリームを介して受信されます。このオプションが無効(デフォルト)に設定されている場合、緊急データは静かに破棄されます。</target>
        </trans-unit>
        <trans-unit id="9833dcc09e733a827020ccf648bcb6cd4665e7ef" translate="yes" xml:space="preserve">
          <source>When the Open Type is &lt;code&gt;CompositeType&lt;/code&gt;, the corresponding mapped Java type (&lt;em&gt;opendata(J)&lt;/em&gt;) is &lt;a href=&quot;openmbean/compositedata&quot;&gt;&lt;code&gt;CompositeData&lt;/code&gt;&lt;/a&gt;. The mapping from an instance of &lt;em&gt;J&lt;/em&gt; to a &lt;code&gt;CompositeData&lt;/code&gt; corresponding to the &lt;code&gt;CompositeType&lt;/code&gt; just described is done as follows. First, if &lt;em&gt;J&lt;/em&gt; implements the interface &lt;a href=&quot;openmbean/compositedataview&quot;&gt;&lt;code&gt;CompositeDataView&lt;/code&gt;&lt;/a&gt;, then that interface's &lt;a href=&quot;openmbean/compositedataview#toCompositeData(javax.management.openmbean.CompositeType)&quot;&gt;&lt;code&gt;toCompositeData&lt;/code&gt;&lt;/a&gt; method is called to do the conversion. Otherwise, the &lt;code&gt;CompositeData&lt;/code&gt; is constructed by calling the getter for each item and converting it to the corresponding Open Data type. Thus, a getter such as</source>
          <target state="translated">When the Open Type is &lt;code&gt;CompositeType&lt;/code&gt; , the corresponding mapped Java type (&lt;em&gt;opendata(J)&lt;/em&gt;) is &lt;a href=&quot;openmbean/compositedata&quot;&gt; &lt;code&gt;CompositeData&lt;/code&gt; &lt;/a&gt;. The mapping from an instance of &lt;em&gt;J&lt;/em&gt; to a &lt;code&gt;CompositeData&lt;/code&gt; corresponding to the &lt;code&gt;CompositeType&lt;/code&gt; just described is done as follows. First, if &lt;em&gt;J&lt;/em&gt; implements the interface &lt;a href=&quot;openmbean/compositedataview&quot;&gt; &lt;code&gt;CompositeDataView&lt;/code&gt; &lt;/a&gt;, then that interface's &lt;a href=&quot;openmbean/compositedataview#toCompositeData(javax.management.openmbean.CompositeType)&quot;&gt; &lt;code&gt;toCompositeData&lt;/code&gt; &lt;/a&gt; method is called to do the conversion. Otherwise, the &lt;code&gt;CompositeData&lt;/code&gt; is constructed by calling the getter for each item and converting it to the corresponding Open Data type. Thus, a getter such as</target>
        </trans-unit>
        <trans-unit id="dabf2aef104d7b63f254f09d8ef274526085868a" translate="yes" xml:space="preserve">
          <source>When the Open Type is &lt;code&gt;CompositeType&lt;/code&gt;, the corresponding mapped Java type (&lt;em&gt;opendata(J)&lt;/em&gt;) is &lt;a href=&quot;openmbean/compositedata&quot;&gt;&lt;code&gt;CompositeData&lt;/code&gt;&lt;/a&gt;. The mapping from an instance of &lt;em&gt;J&lt;/em&gt; to a &lt;code&gt;CompositeData&lt;/code&gt; corresponding to the &lt;code&gt;CompositeType&lt;/code&gt; just described is done as follows. First, if &lt;em&gt;J&lt;/em&gt; implements the interface &lt;a href=&quot;openmbean/compositedataview&quot;&gt;&lt;code&gt;CompositeDataView&lt;/code&gt;&lt;/a&gt;, then that interface's &lt;a href=&quot;openmbean/compositedataview#toCompositeData-javax.management.openmbean.CompositeType-&quot;&gt;&lt;code&gt;toCompositeData&lt;/code&gt;&lt;/a&gt; method is called to do the conversion. Otherwise, the &lt;code&gt;CompositeData&lt;/code&gt; is constructed by calling the getter for each item and converting it to the corresponding Open Data type. Thus, a getter such as</source>
          <target state="translated">Open Typeが &lt;code&gt;CompositeType&lt;/code&gt; の場合、対応するマップされたJavaタイプ（&lt;em&gt;opendata（J）&lt;/em&gt;）は&lt;a href=&quot;openmbean/compositedata&quot;&gt; &lt;code&gt;CompositeData&lt;/code&gt; &lt;/a&gt;です。インスタンスからマッピング&lt;em&gt;J&lt;/em&gt;へ &lt;code&gt;CompositeData&lt;/code&gt; に対応 &lt;code&gt;CompositeType&lt;/code&gt; 次のように今説明が行われます。最初に、&lt;em&gt;J&lt;/em&gt;がインターフェース&lt;a href=&quot;openmbean/compositedataview&quot;&gt; &lt;code&gt;CompositeDataView&lt;/code&gt; を&lt;/a&gt;実装する場合、そのインターフェースの&lt;a href=&quot;openmbean/compositedataview#toCompositeData-javax.management.openmbean.CompositeType-&quot;&gt; &lt;code&gt;toCompositeData&lt;/code&gt; &lt;/a&gt;メソッドが呼び出されて変換が行われます。それ以外の場合、 &lt;code&gt;CompositeData&lt;/code&gt; は、各アイテムのゲッターを呼び出し、それを対応するオープンデータ型に変換することによって構築されます。したがって、次のようなゲッター</target>
        </trans-unit>
        <trans-unit id="6807cd6ed53e44e911717bb50e25ffb553b8f9ce" translate="yes" xml:space="preserve">
          <source>When the access permissions are set at file creation time then the actual value of the permissions may differ that the value of the attribute object. The reasons for this are implementation specific. On UNIX systems, for example, a process has a &lt;em&gt;umask&lt;/em&gt; that impacts the permission bits of newly created files. Where an implementation supports the setting of the access permissions, and the underlying file system supports access permissions, then it is required that the value of the actual access permissions will be equal or less than the value of the attribute provided to the &lt;a href=&quot;../files#createFile(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt;&lt;code&gt;createFile&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../files#createDirectory(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt;&lt;code&gt;createDirectory&lt;/code&gt;&lt;/a&gt; methods. In other words, the file may be more secure than requested.</source>
          <target state="translated">When the access permissions are set at file creation time then the actual value of the permissions may differ that the value of the attribute object. The reasons for this are implementation specific. On UNIX systems, for example, a process has a &lt;em&gt;umask&lt;/em&gt; that impacts the permission bits of newly created files. Where an implementation supports the setting of the access permissions, and the underlying file system supports access permissions, then it is required that the value of the actual access permissions will be equal or less than the value of the attribute provided to the &lt;a href=&quot;../files#createFile(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt; &lt;code&gt;createFile&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;../files#createDirectory(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt; &lt;code&gt;createDirectory&lt;/code&gt; &lt;/a&gt; methods. In other words, the file may be more secure than requested.</target>
        </trans-unit>
        <trans-unit id="5cc6a806fe924f827c1be349c2dda336ff41691d" translate="yes" xml:space="preserve">
          <source>When the access permissions are set at file creation time then the actual value of the permissions may differ that the value of the attribute object. The reasons for this are implementation specific. On UNIX systems, for example, a process has a &lt;em&gt;umask&lt;/em&gt; that impacts the permission bits of newly created files. Where an implementation supports the setting of the access permissions, and the underlying file system supports access permissions, then it is required that the value of the actual access permissions will be equal or less than the value of the attribute provided to the &lt;a href=&quot;../files#createFile-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-&quot;&gt;&lt;code&gt;createFile&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../files#createDirectory-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-&quot;&gt;&lt;code&gt;createDirectory&lt;/code&gt;&lt;/a&gt; methods. In other words, the file may be more secure than requested.</source>
          <target state="translated">ファイル作成時にアクセス許可が設定されている場合、実際の許可の値は属性オブジェクトの値と異なる場合があります。この理由は実装固有です。たとえば、UNIXシステムでは、プロセスには&lt;em&gt;umask&lt;/em&gt;があり、新しく作成されたファイルの許可ビットに影響を与えます。実装は、アクセス権限の設定、および基礎となるファイル・システム・サポートのアクセス許可をサポートする場合、実際のアクセス権の値が提供される属性の値と等しいか、それ以下になることが要求される&lt;a href=&quot;../files#createFile-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-&quot;&gt; &lt;code&gt;createFile&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../files#createDirectory-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-&quot;&gt; &lt;code&gt;createDirectory&lt;/code&gt; &lt;/a&gt;方法。つまり、ファイルは要求されたよりも安全である可能性があります。</target>
        </trans-unit>
        <trans-unit id="69569ad21e8363df8daeddf8b551ab74285ca4d0" translate="yes" xml:space="preserve">
          <source>When the adapter is called, the length of the supplied &lt;code&gt;array&lt;/code&gt; argument is queried as if by &lt;code&gt;array.length&lt;/code&gt; or &lt;code&gt;arraylength&lt;/code&gt; bytecode. If the adapter accepts a zero-length trailing array argument, the supplied &lt;code&gt;array&lt;/code&gt; argument can either be a zero-length array or &lt;code&gt;null&lt;/code&gt;; otherwise, the adapter will throw a &lt;code&gt;NullPointerException&lt;/code&gt; if the array is &lt;code&gt;null&lt;/code&gt; and throw an &lt;a href=&quot;../illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; if the array does not have the correct number of elements.</source>
          <target state="translated">When the adapter is called, the length of the supplied &lt;code&gt;array&lt;/code&gt; argument is queried as if by &lt;code&gt;array.length&lt;/code&gt; or &lt;code&gt;arraylength&lt;/code&gt; bytecode. If the adapter accepts a zero-length trailing array argument, the supplied &lt;code&gt;array&lt;/code&gt; argument can either be a zero-length array or &lt;code&gt;null&lt;/code&gt; ; otherwise, the adapter will throw a &lt;code&gt;NullPointerException&lt;/code&gt; if the array is &lt;code&gt;null&lt;/code&gt; and throw an &lt;a href=&quot;../illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt; if the array does not have the correct number of elements.</target>
        </trans-unit>
        <trans-unit id="f27103f429183890d7b676c4e6d53958062dc5b7" translate="yes" xml:space="preserve">
          <source>When the application provides a filter, the serializer will call out to the filter before serializing each Node.</source>
          <target state="translated">アプリケーションがフィルタを提供する場合、シリアライザは各ノードをシリアライズする前にフィルタを呼び出します。</target>
        </trans-unit>
        <trans-unit id="eafdeecdd692ae88f791f406318133fd82c05cf0" translate="yes" xml:space="preserve">
          <source>When the application provides a filter, the serializer will call out to the filter before serializing each Node. The filter implementation can choose to remove the node from the stream or to terminate the serialization early.</source>
          <target state="translated">アプリケーションがフィルタを提供する場合、シリアライザは各ノードをシリアライズする前にフィルタを呼び出します。フィルタの実装は、ストリームからノードを削除するか、シリアライズを早期に終了するかを選択することができます。</target>
        </trans-unit>
        <trans-unit id="b18b14612d284db82e4ae58a49b67bd2c4968f17" translate="yes" xml:space="preserve">
          <source>When the attribute at the head of the stream is an SQL &lt;code&gt;NULL&lt;/code&gt; the method returns &lt;code&gt;null&lt;/code&gt;. If the attribute is an SQL structured or distinct type, it determines the SQL type of the attribute at the head of the stream. If the stream's type map has an entry for that SQL type, the driver constructs an object of the appropriate class and calls the method &lt;code&gt;SQLData.readSQL&lt;/code&gt; on that object, which reads additional data from the stream, using the protocol described for that method.</source>
          <target state="translated">When the attribute at the head of the stream is an SQL &lt;code&gt;NULL&lt;/code&gt; the method returns &lt;code&gt;null&lt;/code&gt; . If the attribute is an SQL structured or distinct type, it determines the SQL type of the attribute at the head of the stream. If the stream's type map has an entry for that SQL type, the driver constructs an object of the appropriate class and calls the method &lt;code&gt;SQLData.readSQL&lt;/code&gt; on that object, which reads additional data from the stream, using the protocol described for that method.</target>
        </trans-unit>
        <trans-unit id="67e1e670368e0408444ca57de73d1a38a08a71cb" translate="yes" xml:space="preserve">
          <source>When the client is running a later version than the server, certain newer features may not be available, as detailed in the next sections. The client can determine the server's version by examining the &lt;a href=&quot;mbeanserverdelegatembean#getSpecificationVersion()&quot;&gt;&lt;code&gt;SpecificationVersion&lt;/code&gt;&lt;/a&gt; attribute of the &lt;code&gt;
        MBeanServerDelegate&lt;/code&gt;.</source>
          <target state="translated">When the client is running a later version than the server, certain newer features may not be available, as detailed in the next sections. The client can determine the server's version by examining the &lt;a href=&quot;mbeanserverdelegatembean#getSpecificationVersion()&quot;&gt; &lt;code&gt;SpecificationVersion&lt;/code&gt; &lt;/a&gt; attribute of the &lt;code&gt; MBeanServerDelegate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3dd6047101821af20c03ece3438348c43a2a0666" translate="yes" xml:space="preserve">
          <source>When the client is running a later version than the server, certain newer features may not be available, as detailed in the next sections. The client can determine the server's version by examining the &lt;a href=&quot;mbeanserverdelegatembean#getSpecificationVersion--&quot;&gt;&lt;code&gt;SpecificationVersion&lt;/code&gt;&lt;/a&gt; attribute of the &lt;code&gt;MBeanServerDelegate&lt;/code&gt;.</source>
          <target state="translated">クライアントがサーバーより新しいバージョンを実行している場合、次のセクションで説明するように、特定の新しい機能が使用できない場合があります。クライアントは、 &lt;code&gt;MBeanServerDelegate&lt;/code&gt; の&lt;a href=&quot;mbeanserverdelegatembean#getSpecificationVersion--&quot;&gt; &lt;code&gt;SpecificationVersion&lt;/code&gt; &lt;/a&gt;属性を調べることにより、サーバーのバージョンを判別できます。</target>
        </trans-unit>
        <trans-unit id="5656bb0d523a39fd577359655a0712dc9a981a5c" translate="yes" xml:space="preserve">
          <source>When the condition &lt;a href=&quot;condition#await()&quot;&gt;waiting&lt;/a&gt; methods are called the lock is released and, before they return, the lock is reacquired and the lock hold count restored to what it was when the method was called.</source>
          <target state="translated">When the condition &lt;a href=&quot;condition#await()&quot;&gt;waiting&lt;/a&gt; methods are called the lock is released and, before they return, the lock is reacquired and the lock hold count restored to what it was when the method was called.</target>
        </trans-unit>
        <trans-unit id="d87e1d90469eb807a66798a3412565993b14ba79" translate="yes" xml:space="preserve">
          <source>When the condition &lt;a href=&quot;condition#await()&quot;&gt;waiting&lt;/a&gt; methods are called the write lock is released and, before they return, the write lock is reacquired and the lock hold count restored to what it was when the method was called.</source>
          <target state="translated">When the condition &lt;a href=&quot;condition#await()&quot;&gt;waiting&lt;/a&gt; methods are called the write lock is released and, before they return, the write lock is reacquired and the lock hold count restored to what it was when the method was called.</target>
        </trans-unit>
        <trans-unit id="5b2259ec0cf9dd1eabb68562ba1068a405b4ffb3" translate="yes" xml:space="preserve">
          <source>When the condition &lt;a href=&quot;condition#await--&quot;&gt;waiting&lt;/a&gt; methods are called the lock is released and, before they return, the lock is reacquired and the lock hold count restored to what it was when the method was called.</source>
          <target state="translated">条件&lt;a href=&quot;condition#await--&quot;&gt;待機&lt;/a&gt;メソッドが呼び出されるとロックが解放され、ロックが戻る前にロックが再取得され、ロック保持カウントがメソッドが呼び出されたときの状態に戻ります。</target>
        </trans-unit>
        <trans-unit id="79dff109a2169a02dd1a4794f9a2ae88690f5d47" translate="yes" xml:space="preserve">
          <source>When the condition &lt;a href=&quot;condition#await--&quot;&gt;waiting&lt;/a&gt; methods are called the write lock is released and, before they return, the write lock is reacquired and the lock hold count restored to what it was when the method was called.</source>
          <target state="translated">条件&lt;a href=&quot;condition#await--&quot;&gt;待機&lt;/a&gt;メソッドが呼び出されると、書き込みロックが解放され、戻る前に、書き込みロックが再取得され、ロック保持カウントがメソッドが呼び出されたときの状態に復元されます。</target>
        </trans-unit>
        <trans-unit id="16423c8ea158b78447a1469fc88d081d49349aa7" translate="yes" xml:space="preserve">
          <source>When the connection is no longer needed, the client and server applications should each close both sides of their respective connection. For &lt;code&gt;SSLSocket&lt;/code&gt; objects, for example, an application can call &lt;a href=&quot;../../../java/net/socket#shutdownOutput()&quot;&gt;&lt;code&gt;Socket.shutdownOutput()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../java/io/outputstream#close()&quot;&gt;&lt;code&gt;OutputStream.close()&lt;/code&gt;&lt;/a&gt; for output strean close and call &lt;a href=&quot;../../../java/net/socket#shutdownInput()&quot;&gt;&lt;code&gt;Socket.shutdownInput()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../java/io/inputstream#close()&quot;&gt;&lt;code&gt;InputStream.close()&lt;/code&gt;&lt;/a&gt; for input stream close. Note that in some cases, closing the input stream may depend on the peer's output stream being closed first. If the connection is not closed in an orderly manner (for example &lt;a href=&quot;../../../java/net/socket#shutdownInput()&quot;&gt;&lt;code&gt;Socket.shutdownInput()&lt;/code&gt;&lt;/a&gt; is called before the peer's write closure notification has been received), exceptions may be raised to indicate that an error has occurred. Once an &lt;code&gt;SSLSocket&lt;/code&gt; is closed, it is not reusable: a new &lt;code&gt;SSLSocket&lt;/code&gt; must be created.</source>
          <target state="translated">When the connection is no longer needed, the client and server applications should each close both sides of their respective connection. For &lt;code&gt;SSLSocket&lt;/code&gt; objects, for example, an application can call &lt;a href=&quot;../../../java/net/socket#shutdownOutput()&quot;&gt; &lt;code&gt;Socket.shutdownOutput()&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;../../../java/io/outputstream#close()&quot;&gt; &lt;code&gt;OutputStream.close()&lt;/code&gt; &lt;/a&gt; for output strean close and call &lt;a href=&quot;../../../java/net/socket#shutdownInput()&quot;&gt; &lt;code&gt;Socket.shutdownInput()&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;../../../java/io/inputstream#close()&quot;&gt; &lt;code&gt;InputStream.close()&lt;/code&gt; &lt;/a&gt; for input stream close. Note that in some cases, closing the input stream may depend on the peer's output stream being closed first. If the connection is not closed in an orderly manner (for example &lt;a href=&quot;../../../java/net/socket#shutdownInput()&quot;&gt; &lt;code&gt;Socket.shutdownInput()&lt;/code&gt; &lt;/a&gt; is called before the peer's write closure notification has been received), exceptions may be raised to indicate that an error has occurred. Once an &lt;code&gt;SSLSocket&lt;/code&gt; is closed, it is not reusable: a new &lt;code&gt;SSLSocket&lt;/code&gt; must be created.</target>
        </trans-unit>
        <trans-unit id="a0cd6246ef32e2e28cb6a34b88aea8b151567df6" translate="yes" xml:space="preserve">
          <source>When the context is no longer needed, the application should call &lt;a href=&quot;#dispose()&quot;&gt;&lt;code&gt;dispose&lt;/code&gt;&lt;/a&gt; to release any system resources the context may be using.</source>
          <target state="translated">When the context is no longer needed, the application should call &lt;a href=&quot;#dispose()&quot;&gt; &lt;code&gt;dispose&lt;/code&gt; &lt;/a&gt; to release any system resources the context may be using.</target>
        </trans-unit>
        <trans-unit id="1c9937e2f6e05020b636f955f2f392f42a8a5be9" translate="yes" xml:space="preserve">
          <source>When the datum at the head of the stream is an SQL &lt;code&gt;NULL&lt;/code&gt;, the method returns &lt;code&gt;null&lt;/code&gt;. If the datum is an SQL structured or distinct type, it determines the SQL type of the datum at the head of the stream. If the stream's type map has an entry for that SQL type, the driver constructs an object of the appropriate class and calls the method &lt;code&gt;SQLData.readSQL&lt;/code&gt; on that object, which reads additional data from the stream, using the protocol described for that method.</source>
          <target state="translated">When the datum at the head of the stream is an SQL &lt;code&gt;NULL&lt;/code&gt; , the method returns &lt;code&gt;null&lt;/code&gt; . If the datum is an SQL structured or distinct type, it determines the SQL type of the datum at the head of the stream. If the stream's type map has an entry for that SQL type, the driver constructs an object of the appropriate class and calls the method &lt;code&gt;SQLData.readSQL&lt;/code&gt; on that object, which reads additional data from the stream, using the protocol described for that method.</target>
        </trans-unit>
        <trans-unit id="1c57fa8db99fc971d583cc8742f486aed25eac72" translate="yes" xml:space="preserve">
          <source>When the datum at the head of the stream is an SQL &lt;code&gt;NULL&lt;/code&gt;, this method returns &lt;code&gt;null&lt;/code&gt;. If the datum is an SQL structured or distinct type with a custom mapping, this method determines the SQL type of the datum at the head of the stream, constructs an object of the appropriate class, and calls the method &lt;code&gt;SQLData.readSQL&lt;/code&gt; on that object. The &lt;code&gt;readSQL&lt;/code&gt; method then calls the appropriate &lt;code&gt;SQLInputImpl.readXXX&lt;/code&gt; methods to retrieve the attribute values from the stream.</source>
          <target state="translated">When the datum at the head of the stream is an SQL &lt;code&gt;NULL&lt;/code&gt; , this method returns &lt;code&gt;null&lt;/code&gt; . If the datum is an SQL structured or distinct type with a custom mapping, this method determines the SQL type of the datum at the head of the stream, constructs an object of the appropriate class, and calls the method &lt;code&gt;SQLData.readSQL&lt;/code&gt; on that object. The &lt;code&gt;readSQL&lt;/code&gt; method then calls the appropriate &lt;code&gt;SQLInputImpl.readXXX&lt;/code&gt; methods to retrieve the attribute values from the stream.</target>
        </trans-unit>
        <trans-unit id="0207ee2dfd538e974d952ff6af0b2a657d033d63" translate="yes" xml:space="preserve">
          <source>When the dialog is shown, the specified file is selected. The kind of selection depends on the file existence, the dialog type, and the native platform. E.g., the file could be highlighted in the file list, or a file name editbox could be populated with the file name.</source>
          <target state="translated">ダイアログが表示されると、指定されたファイルが選択されます。選択の種類は、ファイルの存在、ダイアログの種類、ネイティブプラットフォームに依存します。例えば、ファイルリストの中でファイルが強調表示されたり、 ファイル名エディットボックスにファイル名を入力したりすることができます。</target>
        </trans-unit>
        <trans-unit id="c397667a78f1a660562462490477701fa7482ccb" translate="yes" xml:space="preserve">
          <source>When the driver determines that the &lt;code&gt;setNetworkTimeout&lt;/code&gt; timeout value has expired, the JDBC driver marks the connection closed and releases any resources held by the connection.</source>
          <target state="translated">When the driver determines that the &lt;code&gt;setNetworkTimeout&lt;/code&gt; timeout value has expired, the JDBC driver marks the connection closed and releases any resources held by the connection.</target>
        </trans-unit>
        <trans-unit id="4cd824f5c7e1568ccbcd115d44b4eb96a3accf69" translate="yes" xml:space="preserve">
          <source>When the environment property &quot;java.naming.factory.initial&quot; is non-null, the InitialContext constructor will attempt to create the initial context specified therein. At that time, the initial context factory involved might throw an exception if a problem is encountered. However, it is provider implementation-dependent when it verifies and indicates to the users of the initial context any environment property- or connection- related problems. It can do so lazily--delaying until an operation is performed on the context, or eagerly, at the time the context is constructed.</source>
          <target state="translated">環境プロパティ &quot;java.naming.factory.initial&quot; が非 null の場合、InitialContext コンストラクタはそこに指定された初期コンテキストを作成しようとします。その際、問題が発生した場合、関与する初期コンテキストファクトリは例外を投げるかもしれない。しかし、環境プロパティや接続に関連する問題が発生した場合には、それを検証して初期コンテキストの利用者に知らせるのはプロバイダの実装に依存します。これは、コンテキストに対して操作が実行されるまで遅延させるか、あるいはコンテキストが構築された時点で熱心に行うか、というように、怠惰に行うことができます。</target>
        </trans-unit>
        <trans-unit id="5e1fbcb7e24cac03595809d83a43116184df4d35" translate="yes" xml:space="preserve">
          <source>When the feature is &lt;code&gt;false&lt;/code&gt;, the implementation will processing XML according to the XML specifications without regard to possible implementation limits.</source>
          <target state="translated">When the feature is &lt;code&gt;false&lt;/code&gt; , the implementation will processing XML according to the XML specifications without regard to possible implementation limits.</target>
        </trans-unit>
        <trans-unit id="09c83d44797e06cf825594da62f38b3618a765cb" translate="yes" xml:space="preserve">
          <source>When the file system uses an ACL model that differs from the NFSv4 defined ACL model, then this method returns an ACL that is the translation of the ACL to the NFSv4 ACL model.</source>
          <target state="translated">ファイルシステムが NFSv4 で定義された ACL モデルとは異なる ACL モデルを使用している場合、このメソッドは ACL を NFSv4 ACL モデルに変換した ACL を返します。</target>
        </trans-unit>
        <trans-unit id="34c8ca9cd568392c4eb67ef03c9038a10b794d59" translate="yes" xml:space="preserve">
          <source>When the initial context is constructed, its environment is initialized with properties defined in the environment parameter passed to the constructor, and in any &lt;a href=&quot;context#RESOURCEFILES&quot; id=&quot;ENVIRONMENT&quot;&gt;application resource files&lt;/a&gt;. In addition, a small number of standard JNDI properties may be specified as system properties or as applet parameters (through the use of &lt;a href=&quot;context#APPLET&quot;&gt;&lt;code&gt;Context.APPLET&lt;/code&gt;&lt;/a&gt;). These special properties are listed in the field detail sections of the &lt;a href=&quot;context#field_detail&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ldap/ldapcontext#field_detail&quot;&gt;&lt;code&gt;LdapContext&lt;/code&gt;&lt;/a&gt; interface documentation.</source>
          <target state="translated">初期コンテキストが構築されると、その環境は、コンストラクターに渡された環境パラメーターと&lt;a href=&quot;context#RESOURCEFILES&quot; id=&quot;ENVIRONMENT&quot;&gt;アプリケーションリソースファイルで&lt;/a&gt;定義されたプロパティで初期化されます。さらに、少数の標準JNDIプロパティを、システムプロパティまたはアプレットパラメータとして（&lt;a href=&quot;context#APPLET&quot;&gt; &lt;code&gt;Context.APPLET&lt;/code&gt; を&lt;/a&gt;使用して）指定できます。これらの特別なプロパティは、&lt;a href=&quot;context#field_detail&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;ldap/ldapcontext#field_detail&quot;&gt; &lt;code&gt;LdapContext&lt;/code&gt; &lt;/a&gt;インターフェイスドキュメントのフィールド詳細セクションにリストされています。</target>
        </trans-unit>
        <trans-unit id="9f2e2ab8bd29748019ef4bf990564b30618f21a2" translate="yes" xml:space="preserve">
          <source>When the initial context is constructed, its environment is initialized with properties defined in the environment parameter passed to the constructor, and in any &lt;a href=&quot;context#RESOURCEFILES&quot;&gt;application resource files&lt;/a&gt;.</source>
          <target state="translated">When the initial context is constructed, its environment is initialized with properties defined in the environment parameter passed to the constructor, and in any &lt;a href=&quot;context#RESOURCEFILES&quot;&gt;application resource files&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="696a039c384cd3258c09a0ffb67d7220e4c8e54b" translate="yes" xml:space="preserve">
          <source>When the intern method is invoked, if the pool already contains a string equal to this &lt;code&gt;String&lt;/code&gt; object as determined by the &lt;a href=&quot;#equals(java.lang.Object)&quot;&gt;&lt;code&gt;equals(Object)&lt;/code&gt;&lt;/a&gt; method, then the string from the pool is returned. Otherwise, this &lt;code&gt;String&lt;/code&gt; object is added to the pool and a reference to this &lt;code&gt;String&lt;/code&gt; object is returned.</source>
          <target state="translated">When the intern method is invoked, if the pool already contains a string equal to this &lt;code&gt;String&lt;/code&gt; object as determined by the &lt;a href=&quot;#equals(java.lang.Object)&quot;&gt; &lt;code&gt;equals(Object)&lt;/code&gt; &lt;/a&gt; method, then the string from the pool is returned. Otherwise, this &lt;code&gt;String&lt;/code&gt; object is added to the pool and a reference to this &lt;code&gt;String&lt;/code&gt; object is returned.</target>
        </trans-unit>
        <trans-unit id="3af901ecd46db6d3c503ad63c889dcb1df5223cb" translate="yes" xml:space="preserve">
          <source>When the intern method is invoked, if the pool already contains a string equal to this &lt;code&gt;String&lt;/code&gt; object as determined by the &lt;a href=&quot;string#equals-java.lang.Object-&quot;&gt;&lt;code&gt;equals(Object)&lt;/code&gt;&lt;/a&gt; method, then the string from the pool is returned. Otherwise, this &lt;code&gt;String&lt;/code&gt; object is added to the pool and a reference to this &lt;code&gt;String&lt;/code&gt; object is returned.</source>
          <target state="translated">internメソッドが呼び出されたときに、&lt;a href=&quot;string#equals-java.lang.Object-&quot;&gt; &lt;code&gt;equals(Object)&lt;/code&gt; &lt;/a&gt;メソッドによって決定されたこの &lt;code&gt;String&lt;/code&gt; オブジェクトに等しい文字列がプールにすでに含まれている場合、プールからの文字列が返されます。それ以外の場合、この &lt;code&gt;String&lt;/code&gt; オブジェクトはプールに追加され、この &lt;code&gt;String&lt;/code&gt; オブジェクトへの参照が返されます。</target>
        </trans-unit>
        <trans-unit id="f8bbc3f973b7168a4616c7de9f75c0600151427a" translate="yes" xml:space="preserve">
          <source>When the job is in the &lt;code&gt;PROCESSING&lt;/code&gt; state, the entire job state includes the detailed status represented in the printer's &lt;a href=&quot;printerstate&quot;&gt;&lt;code&gt;PrinterState&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;printerstatereasons&quot;&gt;&lt;code&gt;PrinterStateReasons&lt;/code&gt;&lt;/a&gt; attributes.</source>
          <target state="translated">When the job is in the &lt;code&gt;PROCESSING&lt;/code&gt; state, the entire job state includes the detailed status represented in the printer's &lt;a href=&quot;printerstate&quot;&gt; &lt;code&gt;PrinterState&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;printerstatereasons&quot;&gt; &lt;code&gt;PrinterStateReasons&lt;/code&gt; &lt;/a&gt; attributes.</target>
        </trans-unit>
        <trans-unit id="1a58835a2387f608fd8e7fa6effa626edf3d2325" translate="yes" xml:space="preserve">
          <source>When the job is in the PROCESSING state, the entire job state includes the detailed status represented in the printer's &lt;a href=&quot;printerstate&quot;&gt;&lt;code&gt;PrinterState&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;printerstatereasons&quot;&gt;&lt;code&gt;PrinterStateReasons&lt;/code&gt;&lt;/a&gt; attributes.</source>
          <target state="translated">ジョブがPROCESSING状態の場合、ジョブ全体の状態には、プリンターの&lt;a href=&quot;printerstate&quot;&gt; &lt;code&gt;PrinterState&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;printerstatereasons&quot;&gt; &lt;code&gt;PrinterStateReasons&lt;/code&gt; &lt;/a&gt;属性で表される詳細なステータスが含まれます。</target>
        </trans-unit>
        <trans-unit id="66a9921b5b8623505ad852c1a7dd9d532fe13cfc" translate="yes" xml:space="preserve">
          <source>When the keepalive option is set for a TCP socket and no data has been exchanged across the socket in either direction for 2 hours (NOTE: the actual value is implementation dependent), TCP automatically sends a keepalive probe to the peer.</source>
          <target state="translated">TCP ソケットに keepalive オプションが設定されていて、ソケット間で 2 時間以上データが交換されていない場合(注意:実際の値は実装に依存します)、TCP は自動的に相手に keepalive プローブを送信します。</target>
        </trans-unit>
        <trans-unit id="bb6061dea9059e4de3096353b5e5aab377ef19b3" translate="yes" xml:space="preserve">
          <source>When the keepalive option is set for a TCP socket and no data has been exchanged across the socket in either direction for 2 hours (NOTE: the actual value is implementation dependent), TCP automatically sends a keepalive probe to the peer. This probe is a TCP segment to which the peer must respond. One of three responses is expected: 1. The peer responds with the expected ACK. The application is not notified (since everything is OK). TCP will send another probe following another 2 hours of inactivity. 2. The peer responds with an RST, which tells the local TCP that the peer host has crashed and rebooted. The socket is closed. 3. There is no response from the peer. The socket is closed. The purpose of this option is to detect if the peer host crashes. Valid only for TCP socket: SocketImpl</source>
          <target state="translated">TCP ソケットに keepalive オプションが設定されていて、2 時間以上ソケット間でデータが交換されていない場合(注意:実際の値は実装に依存します)、TCP は自動的に相手に keepalive プローブを送信します。このプローブは、ピアが応答しなければならないTCPセグメントである。1.ピアは期待される ACK で応答する。アプリケーションには通知されない(すべてがOKなので)。TCP は、さらに 2 時間の非アクティブ状態が続くと、別のプローブを送信します。2.2.ピアは RST で応答し、ローカル TCP にピアホストがクラッシュして再起動したことを通知する。ソケットは閉じられる。3.3.相手からの応答がない。ソケットは閉じられます。このオプションの目的は、ピアホストがクラッシュしたかどうかを検出することです。TCP ソケットでのみ有効です。SocketImpl</target>
        </trans-unit>
        <trans-unit id="866732f7e1f1ba8888b09a311866448987c8a922" translate="yes" xml:space="preserve">
          <source>When the languageTag argument contains an extlang subtag, the first such subtag is used as the language, and the primary language subtag and other extlang subtags are ignored:</source>
          <target state="translated">languageTag引数にextlangサブタグが含まれている場合、最初のサブタグが言語として使われ、主言語サブタグと他のextlangサブタグは無視されます。</target>
        </trans-unit>
        <trans-unit id="ed36ba14c7223ab42eda132f49f243999c7fe2b2" translate="yes" xml:space="preserve">
          <source>When the listener is notified of an event, the listener may in invoked in a thread other than the one in which &lt;code&gt;addNamingListener()&lt;/code&gt; is executed. Care must be taken when multiple threads are accessing the same &lt;code&gt;EventContext&lt;/code&gt; concurrently. See the &lt;a href=&quot;package-summary#THREADING&quot;&gt;package description&lt;/a&gt; for more information on threading issues.</source>
          <target state="translated">リスナーにイベントが通知されると、リスナーは &lt;code&gt;addNamingListener()&lt;/code&gt; が実行されるスレッド以外のスレッドで呼び出される場合があります。複数のスレッドが同じ &lt;code&gt;EventContext&lt;/code&gt; に同時にアクセスする場合は注意が必要です。スレッドの問題の詳細については、&lt;a href=&quot;package-summary#THREADING&quot;&gt;パッケージの説明&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="0d9cde70e42ddbed9e83b6ac5078af513cb772df" translate="yes" xml:space="preserve">
          <source>When the locale has neither script nor extensions, the result is the same as in Java 6 and prior.</source>
          <target state="translated">ロケールにスクリプトも拡張子もない場合、結果はJava 6以前と同じです。</target>
        </trans-unit>
        <trans-unit id="1b1fe4c6f5b74a16eccbbff7c89d6b2a2b6653a7" translate="yes" xml:space="preserve">
          <source>When the look and feel is changed, &lt;code&gt;UIManager&lt;/code&gt; alters only the look and feel defaults; the developer and system defaults are not altered by the &lt;code&gt;UIManager&lt;/code&gt; in any way.</source>
          <target state="translated">When the look and feel is changed, &lt;code&gt;UIManager&lt;/code&gt; alters only the look and feel defaults; the developer and system defaults are not altered by the &lt;code&gt;UIManager&lt;/code&gt; in any way.</target>
        </trans-unit>
        <trans-unit id="93d0b3309dfdbd682000d72cebceb5604b73431a" translate="yes" xml:space="preserve">
          <source>When the loop is called, the loop input values are saved in locals, to be passed to every clause function. These locals are loop invariant.</source>
          <target state="translated">ループが呼び出されると、ループの入力値はローカルに保存され、すべての節関数に渡されます。これらのローカルはループ不変です。</target>
        </trans-unit>
        <trans-unit id="007b0e1775e7a297cd0ad9889941a2a02fa5ed07" translate="yes" xml:space="preserve">
          <source>When the method &lt;code&gt;acceptChanges&lt;/code&gt; encounters conflicts, the &lt;code&gt;SyncProvider&lt;/code&gt; object creates a &lt;code&gt;SyncProviderException&lt;/code&gt; object and sets it with the new &lt;code&gt;SyncResolver&lt;/code&gt; object. The method &lt;code&gt;acceptChanges&lt;/code&gt; will throw this exception, which the application can then catch and use to retrieve the &lt;code&gt;SyncResolver&lt;/code&gt; object it contains. The following code snippet uses the &lt;code&gt;SyncProviderException&lt;/code&gt; method &lt;code&gt;getSyncResolver&lt;/code&gt; to get the &lt;code&gt;SyncResolver&lt;/code&gt; object</source>
          <target state="translated">When the method &lt;code&gt;acceptChanges&lt;/code&gt; encounters conflicts, the &lt;code&gt;SyncProvider&lt;/code&gt; object creates a &lt;code&gt;SyncProviderException&lt;/code&gt; object and sets it with the new &lt;code&gt;SyncResolver&lt;/code&gt; object. The method &lt;code&gt;acceptChanges&lt;/code&gt; will throw this exception, which the application can then catch and use to retrieve the &lt;code&gt;SyncResolver&lt;/code&gt; object it contains. The following code snippet uses the &lt;code&gt;SyncProviderException&lt;/code&gt; method &lt;code&gt;getSyncResolver&lt;/code&gt; to get the &lt;code&gt;SyncResolver&lt;/code&gt; object</target>
        </trans-unit>
        <trans-unit id="761ffe43252810926439462ad9f307e7fa5b5d7e" translate="yes" xml:space="preserve">
          <source>When the method &lt;code&gt;acceptChanges&lt;/code&gt; executes successfully, in addition to writing changes to the data source, it makes the values in the current row be the values in the original row.</source>
          <target state="translated">When the method &lt;code&gt;acceptChanges&lt;/code&gt; executes successfully, in addition to writing changes to the data source, it makes the values in the current row be the values in the original row.</target>
        </trans-unit>
        <trans-unit id="eacefaf622ae1cba296aa64de13b41c77b34ebc2" translate="yes" xml:space="preserve">
          <source>When the method &lt;code&gt;acceptChanges&lt;/code&gt; is executed, the &lt;code&gt;CachedRowSet&lt;/code&gt; object's writer, a &lt;code&gt;RowSetWriterImpl&lt;/code&gt; object, is called behind the scenes to write the changes made to the rowset to the underlying data source. The writer is implemented to make a connection to the data source and write updates to it.</source>
          <target state="translated">When the method &lt;code&gt;acceptChanges&lt;/code&gt; is executed, the &lt;code&gt;CachedRowSet&lt;/code&gt; object's writer, a &lt;code&gt;RowSetWriterImpl&lt;/code&gt; object, is called behind the scenes to write the changes made to the rowset to the underlying data source. The writer is implemented to make a connection to the data source and write updates to it.</target>
        </trans-unit>
        <trans-unit id="f0a87c8c83eb227ae747569302b9215bbb8f49c6" translate="yes" xml:space="preserve">
          <source>When the method &lt;code&gt;getConnection&lt;/code&gt; is called, the &lt;code&gt;DriverManager&lt;/code&gt; will attempt to locate a suitable driver from amongst those loaded at initialization and those loaded explicitly using the same class loader as the current application.</source>
          <target state="translated">When the method &lt;code&gt;getConnection&lt;/code&gt; is called, the &lt;code&gt;DriverManager&lt;/code&gt; will attempt to locate a suitable driver from amongst those loaded at initialization and those loaded explicitly using the same class loader as the current application.</target>
        </trans-unit>
        <trans-unit id="64b1a414ef040f7d4a015e56bd76285cd50c4d87" translate="yes" xml:space="preserve">
          <source>When the method &lt;code&gt;getObject&lt;/code&gt; is called with an object of a class implementing the interface &lt;code&gt;SQLData&lt;/code&gt;, the JDBC driver calls the method &lt;code&gt;SQLData.getSQLType&lt;/code&gt; to determine the SQL type of the UDT being custom mapped. The driver creates an instance of &lt;code&gt;SQLInputImpl&lt;/code&gt;, populating it with the attributes of the UDT. The driver then passes the input stream to the method &lt;code&gt;SQLData.readSQL&lt;/code&gt;, which in turn calls the &lt;code&gt;SQLInputImpl&lt;/code&gt; reader methods to read the attributes from the input stream.</source>
          <target state="translated">When the method &lt;code&gt;getObject&lt;/code&gt; is called with an object of a class implementing the interface &lt;code&gt;SQLData&lt;/code&gt; , the JDBC driver calls the method &lt;code&gt;SQLData.getSQLType&lt;/code&gt; to determine the SQL type of the UDT being custom mapped. The driver creates an instance of &lt;code&gt;SQLInputImpl&lt;/code&gt; , populating it with the attributes of the UDT. The driver then passes the input stream to the method &lt;code&gt;SQLData.readSQL&lt;/code&gt; , which in turn calls the &lt;code&gt;SQLInputImpl&lt;/code&gt; reader methods to read the attributes from the input stream.</target>
        </trans-unit>
        <trans-unit id="fc2f4707a729deed0932994b739ae33c7d74de2f" translate="yes" xml:space="preserve">
          <source>When the method &lt;code&gt;getObject&lt;/code&gt; is called with an object of a class implementing the interface &lt;code&gt;SQLData&lt;/code&gt;, the JDBC driver calls the method &lt;code&gt;SQLData.getSQLType&lt;/code&gt; to determine the SQL type of the user-defined type (UDT) being custom mapped. The driver creates an instance of &lt;code&gt;SQLInput&lt;/code&gt;, populating it with the attributes of the UDT. The driver then passes the input stream to the method &lt;code&gt;SQLData.readSQL&lt;/code&gt;, which in turn calls the &lt;code&gt;SQLInput&lt;/code&gt; reader methods in its implementation for reading the attributes from the input stream.</source>
          <target state="translated">When the method &lt;code&gt;getObject&lt;/code&gt; is called with an object of a class implementing the interface &lt;code&gt;SQLData&lt;/code&gt; , the JDBC driver calls the method &lt;code&gt;SQLData.getSQLType&lt;/code&gt; to determine the SQL type of the user-defined type (UDT) being custom mapped. The driver creates an instance of &lt;code&gt;SQLInput&lt;/code&gt; , populating it with the attributes of the UDT. The driver then passes the input stream to the method &lt;code&gt;SQLData.readSQL&lt;/code&gt; , which in turn calls the &lt;code&gt;SQLInput&lt;/code&gt; reader methods in its implementation for reading the attributes from the input stream.</target>
        </trans-unit>
        <trans-unit id="a7076acb7964a150cbcde4cd84fa0a6df2b7d477" translate="yes" xml:space="preserve">
          <source>When the node being renamed is an &lt;code&gt;Attr&lt;/code&gt; that is attached to an &lt;code&gt;Element&lt;/code&gt;, the node is first removed from the &lt;code&gt;Element&lt;/code&gt; attributes map. Then, once renamed, either by modifying the existing node or creating a new one as described above, it is put back.</source>
          <target state="translated">When the node being renamed is an &lt;code&gt;Attr&lt;/code&gt; that is attached to an &lt;code&gt;Element&lt;/code&gt; , the node is first removed from the &lt;code&gt;Element&lt;/code&gt; attributes map. Then, once renamed, either by modifying the existing node or creating a new one as described above, it is put back.</target>
        </trans-unit>
        <trans-unit id="c89febf12ab0e3c4977c50a6e144102ca2b758a1" translate="yes" xml:space="preserve">
          <source>When the node being renamed is an &lt;code&gt;Element&lt;/code&gt; only the specified attributes are moved, default attributes originated from the DTD are updated according to the new element name. In addition, the implementation may update default attributes from other schemas. Applications should use &lt;code&gt;Document.normalizeDocument()&lt;/code&gt; to guarantee these attributes are up-to-date.</source>
          <target state="translated">When the node being renamed is an &lt;code&gt;Element&lt;/code&gt; only the specified attributes are moved, default attributes originated from the DTD are updated according to the new element name. In addition, the implementation may update default attributes from other schemas. Applications should use &lt;code&gt;Document.normalizeDocument()&lt;/code&gt; to guarantee these attributes are up-to-date.</target>
        </trans-unit>
        <trans-unit id="b3f2c7cd9cb9265342d2a6fc6218dfca1e62cee5" translate="yes" xml:space="preserve">
          <source>When the output method is &quot;xml&quot;, the version value specifies the version of XML to be used for outputting the result tree. The default value for the xml output method is 1.0. When the output method is &quot;html&quot;, the version value indicates the version of the HTML. The default value for the xml output method is 4.0, which specifies that the result should be output as HTML conforming to the HTML 4.0 Recommendation [HTML]. If the output method is &quot;text&quot;, the version property is ignored.</source>
          <target state="translated">出力方法が &quot;xml &quot;の場合、バージョン値には、結果ツリーの出力に使用するXMLのバージョンを指定します。xml出力方式のデフォルト値は1.0です。出力方法が &quot;html &quot;の場合、バージョン値にはHTMLのバージョンを指定します。xml出力方式のデフォルト値は4.0であり、HTML4.0勧告[HTML]に準拠したHTMLとして出力することを指定します。出力方法が &quot;text &quot;の場合、versionプロパティは無視されます。</target>
        </trans-unit>
        <trans-unit id="f8a5f29e1d264a025ea5669456267893f0f08fec" translate="yes" xml:space="preserve">
          <source>When the parse fails, use ParsePosition.getErrorIndex() to find out where in the string the parsing failed. The returned error index is the starting offset of the sub-patterns that the string is comparing with. For example, if the parsing string &quot;AAA {0} BBB&quot; is comparing against the pattern &quot;AAD {0} BBB&quot;, the error index is 0. When an error occurs, the call to this method will return null. If the source is null, return an empty array.</source>
          <target state="translated">パースに失敗した場合は、ParsePosition.getErrorIndex()を使用して、文字列のどこでパースに失敗したかを調べます。返されるエラーインデックスは、文字列と比較しているサブパターンの開始オフセットです。例えば、解析文字列 &quot;AAA {0}BBB&quot; がパターン &quot;AAD {0}BBB&quot; と比較している場合、エラーインデックスは 0 です。 エラーが発生した場合、このメソッドの呼び出しは null を返します。ソースがNULLの場合は、空の配列を返します。</target>
        </trans-unit>
        <trans-unit id="72cc5d6ed97f5b594ccc044348c9065ad0416c01" translate="yes" xml:space="preserve">
          <source>When the parser encounters a word token that has the format of a double precision floating-point number, it treats the token as a number rather than a word, by setting the &lt;code&gt;ttype&lt;/code&gt; field to the value &lt;code&gt;TT_NUMBER&lt;/code&gt; and putting the numeric value of the token into the &lt;code&gt;nval&lt;/code&gt; field.</source>
          <target state="translated">パーサーは、倍精度浮動小数点数の形式の単語トークンを検出すると、 &lt;code&gt;ttype&lt;/code&gt; フィールドを値 &lt;code&gt;TT_NUMBER&lt;/code&gt; に設定し、トークンの数値を入力することにより、トークンを単語ではなく数値として扱います &lt;code&gt;nval&lt;/code&gt; フィールド。</target>
        </trans-unit>
        <trans-unit id="78bae3a9fd2477af6b829cef33248071afc46dc2" translate="yes" xml:space="preserve">
          <source>When the peer was not able to identify itself (for example; no certificate, the particular cipher suite being used does not support authentication, or no peer authentication was established during SSL handshaking) this exception is thrown.</source>
          <target state="translated">ピアが自分自身を識別できなかった場合 (例えば、証明書がない、使用されている特定の暗号スイートが認証をサポートしていない、SSL ハンドシェイク中にピア認証が確立されなかったなど)、この例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="e0488e20002eb573a021336f9689d0df5866d2de" translate="yes" xml:space="preserve">
          <source>When the precision setting is not 0, the rules of &lt;code&gt;BigDecimal&lt;/code&gt; arithmetic are broadly compatible with selected modes of operation of the arithmetic defined in ANSI X3.274-1996 and ANSI X3.274-1996/AM 1-2000 (section 7.4). Unlike those standards, &lt;code&gt;BigDecimal&lt;/code&gt; includes many rounding modes, which were mandatory for division in &lt;code&gt;BigDecimal&lt;/code&gt; releases prior to 5. Any conflicts between these ANSI standards and the &lt;code&gt;BigDecimal&lt;/code&gt; specification are resolved in favor of &lt;code&gt;BigDecimal&lt;/code&gt;.</source>
          <target state="translated">精度設定が0でない場合、 &lt;code&gt;BigDecimal&lt;/code&gt; 演算の規則は、ANSI X3.274-1996およびANSI X3.274-1996 / AM 1-2000（セクション7.4）で定義されている演算の選択された演算モードと広く互換性があります。これらの規格とは異なり、 &lt;code&gt;BigDecimal&lt;/code&gt; のはで除算に必須だった多くの丸めモード、含み &lt;code&gt;BigDecimal&lt;/code&gt; これらのANSI規格との間で以前の5のリリースを任意の競合 &lt;code&gt;BigDecimal&lt;/code&gt; 仕様はを優先して解決さ &lt;code&gt;BigDecimal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5843d706baf770064c5e4bf338f1a63714ad7a1d" translate="yes" xml:space="preserve">
          <source>When the representation class is a URL, the print service itself accesses and downloads the document directly from its URL address, without involving the client. The service may be some form of network print service which is executing in a different environment. This means you should not use a URL print data flavor to print a document at a restricted URL that the client can see but the printer cannot see. This also means you should not use a URL print data flavor to print a document stored in a local file that is not available at a URL accessible independently of the client. For example, a file that is not served up by an HTTP server or FTP server. To print such documents, let the client open an input stream on the URL or file and use an input stream data flavor.</source>
          <target state="translated">表現クラスがURLである場合、印刷サービス自体は、クライアントを介さずに、そのURLアドレスから直接文書にアクセスしてダウンロードします。このサービスは、別の環境で実行されているネットワークプリントサービスの何らかの形態である可能性があります。つまり、クライアントは見ることができても、プリンタは見ることができない制限されたURLで文書を印刷するために、URL印刷データフレーバーを使用すべきではないということです。また、クライアントから独立してアクセス可能なURLで利用できないローカルファイルに格納された文書を印刷するために、URL印刷データフレーバーを使用してはならないことを意味する。例えば、HTTPサーバやFTPサーバからサービスアップされていないファイルなどです。このような文書を印刷するには、クライアントにURLまたはファイル上で入力ストリームを開かせ、入力ストリームデータフレーバーを使用する。</target>
        </trans-unit>
        <trans-unit id="c50fdf0c297e395312b19932d6d698d6fe9410ab" translate="yes" xml:space="preserve">
          <source>When the returned &lt;code&gt;VarHandle&lt;/code&gt; is invoked, the array reference and array index are checked. A &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown if the array reference is &lt;code&gt;null&lt;/code&gt; and an &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; will be thrown if the index is negative or if it is greater than or equal to the length of the array.</source>
          <target state="translated">When the returned &lt;code&gt;VarHandle&lt;/code&gt; is invoked, the array reference and array index are checked. A &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown if the array reference is &lt;code&gt;null&lt;/code&gt; and an &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; will be thrown if the index is negative or if it is greater than or equal to the length of the array.</target>
        </trans-unit>
        <trans-unit id="f2890f46cc50adad6b16a722b172030e24df5540" translate="yes" xml:space="preserve">
          <source>When the returned method handle is invoked, the array reference and array index are checked. A &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown if the array reference is &lt;code&gt;null&lt;/code&gt; and an &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; will be thrown if the index is negative or if it is greater than or equal to the length of the array.</source>
          <target state="translated">When the returned method handle is invoked, the array reference and array index are checked. A &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown if the array reference is &lt;code&gt;null&lt;/code&gt; and an &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; will be thrown if the index is negative or if it is greater than or equal to the length of the array.</target>
        </trans-unit>
        <trans-unit id="65a8d19d4c40ff2e75d5423b676fb0c582abe879" translate="yes" xml:space="preserve">
          <source>When the selection is changed, &lt;code&gt;setValue&lt;/code&gt; is invoked, which generates a &lt;code&gt;PropertyChangeEvent&lt;/code&gt;.</source>
          <target state="translated">When the selection is changed, &lt;code&gt;setValue&lt;/code&gt; is invoked, which generates a &lt;code&gt;PropertyChangeEvent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="750413507a9e50e7dd4ee48691a0e0e569f733c7" translate="yes" xml:space="preserve">
          <source>When the socket is created the &lt;a href=&quot;datagramsocket#setReuseAddress(boolean)&quot;&gt;&lt;code&gt;DatagramSocket.setReuseAddress(boolean)&lt;/code&gt;&lt;/a&gt; method is called to enable the SO_REUSEADDR socket option.</source>
          <target state="translated">When the socket is created the &lt;a href=&quot;datagramsocket#setReuseAddress(boolean)&quot;&gt; &lt;code&gt;DatagramSocket.setReuseAddress(boolean)&lt;/code&gt; &lt;/a&gt; method is called to enable the SO_REUSEADDR socket option.</target>
        </trans-unit>
        <trans-unit id="c97f96f2fd46091c0f2026852faa74a91e5bd86f" translate="yes" xml:space="preserve">
          <source>When the socket is created the &lt;a href=&quot;datagramsocket#setReuseAddress-boolean-&quot;&gt;&lt;code&gt;DatagramSocket.setReuseAddress(boolean)&lt;/code&gt;&lt;/a&gt; method is called to enable the SO_REUSEADDR socket option.</source>
          <target state="translated">ソケットが作成されると、&lt;a href=&quot;datagramsocket#setReuseAddress-boolean-&quot;&gt; &lt;code&gt;DatagramSocket.setReuseAddress(boolean)&lt;/code&gt; &lt;/a&gt;メソッドが呼び出され、SO_REUSEADDRソケットオプションが有効になります。</target>
        </trans-unit>
        <trans-unit id="23d0fb38ca6d6e11edcf3b7e63aa87f6a871583e" translate="yes" xml:space="preserve">
          <source>When the specified date-time arrives, the printer must remove the &lt;a href=&quot;jobstatereason&quot;&gt;&lt;code&gt;JobStateReason&lt;/code&gt;&lt;/a&gt; value of &lt;code&gt;JOB_HOLD_UNTIL_SPECIFIED&lt;/code&gt; from the job's &lt;a href=&quot;jobstatereasons&quot;&gt;&lt;code&gt;JobStateReasons&lt;/code&gt;&lt;/a&gt; attribute, if present. If there are no other job state reasons that keep the job in the &lt;code&gt;PENDING_HELD&lt;/code&gt; state, the printer must consider the job as a candidate for processing by moving the job to the PENDING state.</source>
          <target state="translated">When the specified date-time arrives, the printer must remove the &lt;a href=&quot;jobstatereason&quot;&gt; &lt;code&gt;JobStateReason&lt;/code&gt; &lt;/a&gt; value of &lt;code&gt;JOB_HOLD_UNTIL_SPECIFIED&lt;/code&gt; from the job's &lt;a href=&quot;jobstatereasons&quot;&gt; &lt;code&gt;JobStateReasons&lt;/code&gt; &lt;/a&gt; attribute, if present. If there are no other job state reasons that keep the job in the &lt;code&gt;PENDING_HELD&lt;/code&gt; state, the printer must consider the job as a candidate for processing by moving the job to the PENDING state.</target>
        </trans-unit>
        <trans-unit id="5705af97d2330caf062737553687cb90dd63be9e" translate="yes" xml:space="preserve">
          <source>When the specified date-time arrives, the printer must remove the &lt;a href=&quot;jobstatereason&quot;&gt;&lt;code&gt;JobStateReason&lt;/code&gt;&lt;/a&gt; value of JOB_HOLD_UNTIL_SPECIFIED from the job's &lt;a href=&quot;jobstatereasons&quot;&gt;&lt;code&gt;JobStateReasons&lt;/code&gt;&lt;/a&gt; attribute, if present. If there are no other job state reasons that keep the job in the PENDING_HELD state, the printer must consider the job as a candidate for processing by moving the job to the PENDING state.</source>
          <target state="translated">指定された日時になると、プリンタはJOB_HOLD_UNTIL_SPECIFIED の&lt;a href=&quot;jobstatereason&quot;&gt; &lt;code&gt;JobStateReason&lt;/code&gt; &lt;/a&gt;値を、存在する&lt;a href=&quot;jobstatereasons&quot;&gt; &lt;code&gt;JobStateReasons&lt;/code&gt; &lt;/a&gt;はジョブのJobStateReasons属性から削除する必要があります。ジョブをPENDING_HELD状態に保つ他のジョブ状態理由がない場合、プリンターはジョブをPENDING状態に移行することにより、ジョブを処理の候補と見なす必要があります。</target>
        </trans-unit>
        <trans-unit id="88645d98095c743d1978459bbe537d54c96def54" translate="yes" xml:space="preserve">
          <source>When the specified provider is removed, all providers located at a position greater than where the specified provider was are shifted down one position (towards the head of the list of installed providers).</source>
          <target state="translated">指定されたプロバイダが削除されると、指定されたプロバイダがあった位置よりも大きい位置にあるすべてのプロバイダは、1つ下の位置(インストールされているプロバイダのリストの先頭に向かって)に移動します。</target>
        </trans-unit>
        <trans-unit id="a42df38aa359f6593f2ef17a8352c58477850724" translate="yes" xml:space="preserve">
          <source>When the syntax is &quot;&lt;code&gt;glob&lt;/code&gt;&quot; then the &lt;code&gt;String&lt;/code&gt; representation of the path is matched using a limited pattern language that resembles regular expressions but with a simpler syntax. For example:</source>
          <target state="translated">構文が &quot; &lt;code&gt;glob&lt;/code&gt; &quot;の場合、パスの &lt;code&gt;String&lt;/code&gt; 表現は、正規表現に似ているがより単純な構文を持つ限定パターン言語を使用して照合されます。例えば：</target>
        </trans-unit>
        <trans-unit id="a34d7bcd42ea49862772510bb9b109c7b63aa486" translate="yes" xml:space="preserve">
          <source>When the syntax is &quot;&lt;code&gt;regex&lt;/code&gt;&quot; then the pattern component is a regular expression as defined by the &lt;a href=&quot;../../util/regex/pattern&quot;&gt;&lt;code&gt;Pattern&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">構文が &quot; &lt;code&gt;regex&lt;/code&gt; &quot;の場合、パターンコンポーネントは、&lt;a href=&quot;../../util/regex/pattern&quot;&gt; &lt;code&gt;Pattern&lt;/code&gt; &lt;/a&gt;クラスで定義されている正規表現です。</target>
        </trans-unit>
        <trans-unit id="846a62fdfe658618e67bb6666bfc83ef7036c188" translate="yes" xml:space="preserve">
          <source>When the target of the &lt;code&gt;CallSite&lt;/code&gt; returned from this method is invoked, it returns the result of String concatenation, taking all function arguments and constants passed to the linkage method as inputs for concatenation. The target signature is given by &lt;code&gt;concatType&lt;/code&gt;, and does not include constants. For a target accepting:</source>
          <target state="translated">When the target of the &lt;code&gt;CallSite&lt;/code&gt; returned from this method is invoked, it returns the result of String concatenation, taking all function arguments and constants passed to the linkage method as inputs for concatenation. The target signature is given by &lt;code&gt;concatType&lt;/code&gt; , and does not include constants. For a target accepting:</target>
        </trans-unit>
        <trans-unit id="d29230ce7aa0f83e52a9d0b8aae6ea61d3af4a88" translate="yes" xml:space="preserve">
          <source>When the target of the &lt;code&gt;CallSite&lt;/code&gt; returned from this method is invoked, it returns the result of String concatenation, taking all function arguments passed to the linkage method as inputs for concatenation. The target signature is given by &lt;code&gt;concatType&lt;/code&gt;. For a target accepting:</source>
          <target state="translated">When the target of the &lt;code&gt;CallSite&lt;/code&gt; returned from this method is invoked, it returns the result of String concatenation, taking all function arguments passed to the linkage method as inputs for concatenation. The target signature is given by &lt;code&gt;concatType&lt;/code&gt; . For a target accepting:</target>
        </trans-unit>
        <trans-unit id="d7d520f5e0468b072c681c7152b26b75810e8caf" translate="yes" xml:space="preserve">
          <source>When the target of the &lt;code&gt;CallSite&lt;/code&gt; returned from this method is invoked, the resulting function objects are instances of a class which implements the interface named by the return type of &lt;code&gt;invokedType&lt;/code&gt;, declares a method with the name given by &lt;code&gt;invokedName&lt;/code&gt; and the signature given by &lt;code&gt;samMethodType&lt;/code&gt;. It may also override additional methods from &lt;code&gt;Object&lt;/code&gt;.</source>
          <target state="translated">標的場合 &lt;code&gt;CallSite&lt;/code&gt; このメソッドから返さ呼び出され、結果として得られる関数オブジェクトはの戻り型によって指定インターフェースを実装するクラスのインスタンスである &lt;code&gt;invokedType&lt;/code&gt; を、によって与えられた名前のメソッドを宣言し &lt;code&gt;invokedName&lt;/code&gt; によって与えられた署名 &lt;code&gt;samMethodType&lt;/code&gt; 。また、 &lt;code&gt;Object&lt;/code&gt; の追加のメソッドをオーバーライドする場合もあります。</target>
        </trans-unit>
        <trans-unit id="935f09a1ca1fda156388d4a2ee040efb3dfa7c02" translate="yes" xml:space="preserve">
          <source>When the target of the &lt;code&gt;CallSite&lt;/code&gt; returned from this method is invoked, the resulting function objects are instances of a class with the following properties:</source>
          <target state="translated">このメソッドから返された &lt;code&gt;CallSite&lt;/code&gt; のターゲットが呼び出されると、結果の関数オブジェクトは次のプロパティを持つクラスのインスタンスになります。</target>
        </trans-unit>
        <trans-unit id="6d07b79c3fe52992e2c96caa5963c279054fc29d" translate="yes" xml:space="preserve">
          <source>When the user changes the value of the scroll bar, the scroll bar receives an instance of &lt;code&gt;AdjustmentEvent&lt;/code&gt;. The scroll bar processes this event, passing it along to any registered listeners.</source>
          <target state="translated">When the user changes the value of the scroll bar, the scroll bar receives an instance of &lt;code&gt;AdjustmentEvent&lt;/code&gt; . The scroll bar processes this event, passing it along to any registered listeners.</target>
        </trans-unit>
        <trans-unit id="16eee6e04be75731d2c23d0789dd273c70555ca5" translate="yes" xml:space="preserve">
          <source>When the user is resizing the &lt;code&gt;Component&lt;/code&gt;s the minimum size of the &lt;code&gt;Components&lt;/code&gt; is used to determine the maximum/minimum position the &lt;code&gt;Component&lt;/code&gt;s can be set to. If the minimum size of the two components is greater than the size of the split pane the divider will not allow you to resize it. To alter the minimum size of a &lt;code&gt;JComponent&lt;/code&gt;, see &lt;a href=&quot;jcomponent#setMinimumSize(java.awt.Dimension)&quot;&gt;&lt;code&gt;JComponent.setMinimumSize(java.awt.Dimension)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">When the user is resizing the &lt;code&gt;Component&lt;/code&gt; s the minimum size of the &lt;code&gt;Components&lt;/code&gt; is used to determine the maximum/minimum position the &lt;code&gt;Component&lt;/code&gt; s can be set to. If the minimum size of the two components is greater than the size of the split pane the divider will not allow you to resize it. To alter the minimum size of a &lt;code&gt;JComponent&lt;/code&gt; , see &lt;a href=&quot;jcomponent#setMinimumSize(java.awt.Dimension)&quot;&gt; &lt;code&gt;JComponent.setMinimumSize(java.awt.Dimension)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="955102ac80658721d1f432faef28beba4c5e0ef3" translate="yes" xml:space="preserve">
          <source>When the user resizes the split pane the new space is distributed between the two components based on the &lt;code&gt;resizeWeight&lt;/code&gt; property. A value of 0, the default, indicates the right/bottom component gets all the space, where as a value of 1 indicates the left/top component gets all the space.</source>
          <target state="translated">When the user resizes the split pane the new space is distributed between the two components based on the &lt;code&gt;resizeWeight&lt;/code&gt; property. A value of 0, the default, indicates the right/bottom component gets all the space, where as a value of 1 indicates the left/top component gets all the space.</target>
        </trans-unit>
        <trans-unit id="c90b9a5fd33f3cd980097a956b05ef5be63c5895" translate="yes" xml:space="preserve">
          <source>When the user terminates the drag operation, normally resulting in a successful Drop, both the &lt;code&gt;DragSource&lt;/code&gt; and &lt;code&gt;DropTarget&lt;/code&gt; receive notifications that include, and result in the type negotiation and transfer of, the information associated with the &lt;code&gt;DragSource&lt;/code&gt; via a &lt;code&gt;Transferable&lt;/code&gt; object.</source>
          <target state="translated">When the user terminates the drag operation, normally resulting in a successful Drop, both the &lt;code&gt;DragSource&lt;/code&gt; and &lt;code&gt;DropTarget&lt;/code&gt; receive notifications that include, and result in the type negotiation and transfer of, the information associated with the &lt;code&gt;DragSource&lt;/code&gt; via a &lt;code&gt;Transferable&lt;/code&gt; object.</target>
        </trans-unit>
        <trans-unit id="1b69617c3d426ae0b52b14cd7b31c80e8f2ff7cf" translate="yes" xml:space="preserve">
          <source>When the virtual machine's built-in class loader, known as the &quot;bootstrap class loader&quot;, unsuccessfully searches for a class, the entries in the &lt;a href=&quot;../../../../java.base/java/util/jar/jarfile&quot;&gt;&lt;code&gt;JAR file&lt;/code&gt;&lt;/a&gt; will be searched as well.</source>
          <target state="translated">When the virtual machine's built-in class loader, known as the &quot;bootstrap class loader&quot;, unsuccessfully searches for a class, the entries in the &lt;a href=&quot;../../../../java.base/java/util/jar/jarfile&quot;&gt; &lt;code&gt;JAR file&lt;/code&gt; &lt;/a&gt; will be searched as well.</target>
        </trans-unit>
        <trans-unit id="3845d46c4ef86f663a835d134902a3051dd1ea04" translate="yes" xml:space="preserve">
          <source>When the virtual machine's built-in class loader, known as the &quot;bootstrap class loader&quot;, unsuccessfully searches for a class, the entries in the &lt;a href=&quot;../../util/jar/jarfile&quot;&gt;&lt;code&gt;JAR file&lt;/code&gt;&lt;/a&gt; will be searched as well.</source>
          <target state="translated">「ブートストラップクラスローダー」として知られる仮想マシンの組み込みクラスローダーがクラスの検索に失敗すると、&lt;a href=&quot;../../util/jar/jarfile&quot;&gt; &lt;code&gt;JAR file&lt;/code&gt; &lt;/a&gt;エントリも検索されます。</target>
        </trans-unit>
        <trans-unit id="9f5936d0319917d0904a3bc84216aec8fd20dcb1" translate="yes" xml:space="preserve">
          <source>When the window is per-pixel translucent, the drawing sub-system respects the alpha value of each individual pixel. If a pixel gets painted with the alpha color component equal to zero, it becomes visually transparent. If the alpha of the pixel is equal to 1.0f, the pixel is fully opaque. Interim values of the alpha color component make the pixel semi-transparent. In this mode, the background of the window gets painted with the alpha value of the given background color. If the alpha value of the argument of this method is equal to &lt;code&gt;0&lt;/code&gt;, the background is not painted at all.</source>
          <target state="translated">When the window is per-pixel translucent, the drawing sub-system respects the alpha value of each individual pixel. If a pixel gets painted with the alpha color component equal to zero, it becomes visually transparent. If the alpha of the pixel is equal to 1.0f, the pixel is fully opaque. Interim values of the alpha color component make the pixel semi-transparent. In this mode, the background of the window gets painted with the alpha value of the given background color. If the alpha value of the argument of this method is equal to &lt;code&gt;0&lt;/code&gt; , the background is not painted at all.</target>
        </trans-unit>
        <trans-unit id="78301597bc29e04c67c4b5e8569630b44e2a80b1" translate="yes" xml:space="preserve">
          <source>When there are no more tokens, the last value found in the child-cache or returned by &lt;code&gt;childSpi&lt;/code&gt; is returned by this method. If during the traversal, two &lt;code&gt;&quot;/&quot;&lt;/code&gt; tokens occur consecutively, or the final token is &lt;code&gt;&quot;/&quot;&lt;/code&gt; (rather than a name), an appropriate &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">トークンがなくなると、子キャッシュで見つかった、または &lt;code&gt;childSpi&lt;/code&gt; から返された最後の値がこのメソッドによって返されます。トラバーサル中に2つの &lt;code&gt;&quot;/&quot;&lt;/code&gt; トークンが連続して発生する場合、または最後のトークンが（名前ではなく） &lt;code&gt;&quot;/&quot;&lt;/code&gt; である場合は、適切な &lt;code&gt;IllegalArgumentException&lt;/code&gt; がスローされます。</target>
        </trans-unit>
        <trans-unit id="dd91b0658c6cf431015b14f6a00de46f9c97ac60" translate="yes" xml:space="preserve">
          <source>When there is a positive-width match at the beginning of the input sequence then an empty leading substring is included at the beginning of the resulting array. A zero-width match at the beginning however never produces such empty leading substring.</source>
          <target state="translated">入力シーケンスの先頭に正の幅のマッチがあった場合、結果として得られる配列の先頭には空の部分文字列が含まれます。しかし、先頭にゼロ幅のマッチがあった場合、そのような空の先頭部分文字列は生成されません。</target>
        </trans-unit>
        <trans-unit id="ab6bcee9543d79d3bbe811e0f20b9a8c6356f175" translate="yes" xml:space="preserve">
          <source>When there is a positive-width match at the beginning of the input sequence then an empty leading substring is included at the beginning of the stream. A zero-width match at the beginning however never produces such empty leading substring.</source>
          <target state="translated">入力シーケンスの先頭に正の幅のマッチがあった場合、 空の先頭部分文字列がストリームの先頭に含まれます。しかし、先頭にゼロ幅のマッチがあった場合は、そのような空の先頭部分文字列は生成されません。</target>
        </trans-unit>
        <trans-unit id="735c807118b30a042caeeea37d2a0653aefeb1e0" translate="yes" xml:space="preserve">
          <source>When there is a positive-width match at the beginning of this string then an empty leading substring is included at the beginning of the resulting array. A zero-width match at the beginning however never produces such empty leading substring.</source>
          <target state="translated">この文字列の先頭に正の幅のマッチがあった場合、結果として得られる配列の先頭には空の部分文字列が含まれます。しかし、先頭にゼロ幅のマッチがあった場合、このような空の先頭部分文字列は生成されません。</target>
        </trans-unit>
        <trans-unit id="9a4d1a71ed66693f31054772316c85b0392b49d2" translate="yes" xml:space="preserve">
          <source>When these are in place for a UDT, calling the methods &lt;code&gt;ResultSet.getObject&lt;/code&gt; or &lt;code&gt;CallableStatement.getObject&lt;/code&gt; on that UDT will automatically retrieve the custom mapping for it. Also, the &lt;code&gt;PreparedStatement.setObject&lt;/code&gt; method will automatically map the object back to its SQL type to store it in the data source.</source>
          <target state="translated">When these are in place for a UDT, calling the methods &lt;code&gt;ResultSet.getObject&lt;/code&gt; or &lt;code&gt;CallableStatement.getObject&lt;/code&gt; on that UDT will automatically retrieve the custom mapping for it. Also, the &lt;code&gt;PreparedStatement.setObject&lt;/code&gt; method will automatically map the object back to its SQL type to store it in the data source.</target>
        </trans-unit>
        <trans-unit id="59b930f7ddff7332085ec26d6fac4974e8e12b10" translate="yes" xml:space="preserve">
          <source>When this code runs,</source>
          <target state="translated">このコードが実行されると</target>
        </trans-unit>
        <trans-unit id="cbcf2b7b42302b4ba4fae27e923d6a973f224d28" translate="yes" xml:space="preserve">
          <source>When this fails, the resolution will be retried with the specified prefix deleted from the implementation name, yielding the correct resolution:</source>
          <target state="translated">これが失敗した場合は、指定されたプレフィックスを実装名から削除して解決を再試行し、正しい解決を行います。</target>
        </trans-unit>
        <trans-unit id="ff9da4b4449f564bcf08ecf5f687a2592cebde98" translate="yes" xml:space="preserve">
          <source>When this fails, the resolution will be retried with the specified prefix prepended to the method name, yielding the correct resolution:</source>
          <target state="translated">これが失敗した場合は、メソッド名の前に指定された接頭辞を付加した解決策が再試行され、正しい解決策が得られます。</target>
        </trans-unit>
        <trans-unit id="75154f3aadedea422fd3c7633a9889ca79a529a3" translate="yes" xml:space="preserve">
          <source>When this field is used for setting a value, it should behave in the same way as setting &lt;a href=&quot;#NANO_OF_DAY&quot;&gt;&lt;code&gt;NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; with the value multiplied by 1,000,000.</source>
          <target state="translated">When this field is used for setting a value, it should behave in the same way as setting &lt;a href=&quot;#NANO_OF_DAY&quot;&gt; &lt;code&gt;NANO_OF_DAY&lt;/code&gt; &lt;/a&gt; with the value multiplied by 1,000,000.</target>
        </trans-unit>
        <trans-unit id="15ccb1c283c4e094f90353b08299e4e2a2ecb732" translate="yes" xml:space="preserve">
          <source>When this field is used for setting a value, it should behave in the same way as setting &lt;a href=&quot;#NANO_OF_DAY&quot;&gt;&lt;code&gt;NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; with the value multiplied by 1,000.</source>
          <target state="translated">When this field is used for setting a value, it should behave in the same way as setting &lt;a href=&quot;#NANO_OF_DAY&quot;&gt; &lt;code&gt;NANO_OF_DAY&lt;/code&gt; &lt;/a&gt; with the value multiplied by 1,000.</target>
        </trans-unit>
        <trans-unit id="53f8544461b05bbe464ff7823a230bfc4bf04760" translate="yes" xml:space="preserve">
          <source>When this field is used for setting a value, it should behave in the same way as setting &lt;a href=&quot;#NANO_OF_SECOND&quot;&gt;&lt;code&gt;NANO_OF_SECOND&lt;/code&gt;&lt;/a&gt; with the value multiplied by 1,000,000.</source>
          <target state="translated">When this field is used for setting a value, it should behave in the same way as setting &lt;a href=&quot;#NANO_OF_SECOND&quot;&gt; &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; &lt;/a&gt; with the value multiplied by 1,000,000.</target>
        </trans-unit>
        <trans-unit id="f8f0fa54e907e8e2466eda8f3397fead3f7ec0b2" translate="yes" xml:space="preserve">
          <source>When this field is used for setting a value, it should behave in the same way as setting &lt;a href=&quot;#NANO_OF_SECOND&quot;&gt;&lt;code&gt;NANO_OF_SECOND&lt;/code&gt;&lt;/a&gt; with the value multiplied by 1,000.</source>
          <target state="translated">When this field is used for setting a value, it should behave in the same way as setting &lt;a href=&quot;#NANO_OF_SECOND&quot;&gt; &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; &lt;/a&gt; with the value multiplied by 1,000.</target>
        </trans-unit>
        <trans-unit id="eaab9ca0b04a7049f2a9f2eca0230f3f4e33a263" translate="yes" xml:space="preserve">
          <source>When this field is used for setting a value, it should behave in the same way as setting &lt;a href=&quot;chronofield#NANO_OF_DAY&quot;&gt;&lt;code&gt;NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; with the value multiplied by 1,000,000.</source>
          <target state="translated">このフィールドを使用して値を設定する場合、値に1,000,000を掛けた&lt;a href=&quot;chronofield#NANO_OF_DAY&quot;&gt; &lt;code&gt;NANO_OF_DAY&lt;/code&gt; &lt;/a&gt;を設定するのと同じように動作します。</target>
        </trans-unit>
        <trans-unit id="db9acfde62bdc912d95eb549ddc180babc48a672" translate="yes" xml:space="preserve">
          <source>When this field is used for setting a value, it should behave in the same way as setting &lt;a href=&quot;chronofield#NANO_OF_DAY&quot;&gt;&lt;code&gt;NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; with the value multiplied by 1,000.</source>
          <target state="translated">このフィールドを使用して値を設定する場合、値に1,000を掛けた&lt;a href=&quot;chronofield#NANO_OF_DAY&quot;&gt; &lt;code&gt;NANO_OF_DAY&lt;/code&gt; &lt;/a&gt;を設定するのと同じように動作します。</target>
        </trans-unit>
        <trans-unit id="b434d16d4beadd3f769e9c367e4be1fa9657e587" translate="yes" xml:space="preserve">
          <source>When this field is used for setting a value, it should behave in the same way as setting &lt;a href=&quot;chronofield#NANO_OF_SECOND&quot;&gt;&lt;code&gt;NANO_OF_SECOND&lt;/code&gt;&lt;/a&gt; with the value multiplied by 1,000,000.</source>
          <target state="translated">このフィールドを値の設定に使用する場合、&lt;a href=&quot;chronofield#NANO_OF_SECOND&quot;&gt; &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; &lt;/a&gt;を1,000,000倍した値で設定するのと同じように動作します。</target>
        </trans-unit>
        <trans-unit id="4dce2d6953f5a46462f20dc8f01aaa03fa0ee37c" translate="yes" xml:space="preserve">
          <source>When this field is used for setting a value, it should behave in the same way as setting &lt;a href=&quot;chronofield#NANO_OF_SECOND&quot;&gt;&lt;code&gt;NANO_OF_SECOND&lt;/code&gt;&lt;/a&gt; with the value multiplied by 1,000.</source>
          <target state="translated">このフィールドを使用して値を設定する場合、値に1,000を掛けた&lt;a href=&quot;chronofield#NANO_OF_SECOND&quot;&gt; &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; &lt;/a&gt;を設定するのと同じように動作します。</target>
        </trans-unit>
        <trans-unit id="7f48a54b9eb38bdd2ccfe0a591106ec4e77d4089" translate="yes" xml:space="preserve">
          <source>When this field is used for setting a value, it should set as much precision as the object stores, using integer division to remove excess precision. For example, if the &lt;code&gt;TemporalAccessor&lt;/code&gt; stores time to millisecond precision, then the nano-of-second must be divided by 1,000,000 before replacing the milli-of-second.</source>
          <target state="translated">このフィールドを使用して値を設定する場合、整数の除算を使用して余分な精度を削除し、オブジェクトが格納するのと同じ精度を設定する必要があります。たとえば、 &lt;code&gt;TemporalAccessor&lt;/code&gt; が時間をミリ秒の精度で格納する場合、ミリ秒を置き換える前に、ナノ秒を1,000,000で除算する必要があります。</target>
        </trans-unit>
        <trans-unit id="e2e89c6cff8f954a3f0ea54f5e7b16399bcbf000" translate="yes" xml:space="preserve">
          <source>When this flag is specified then case-insensitive matching, when enabled by the &lt;a href=&quot;#CASE_INSENSITIVE&quot;&gt;&lt;code&gt;CASE_INSENSITIVE&lt;/code&gt;&lt;/a&gt; flag, is done in a manner consistent with the Unicode Standard. By default, case-insensitive matching assumes that only characters in the US-ASCII charset are being matched.</source>
          <target state="translated">When this flag is specified then case-insensitive matching, when enabled by the &lt;a href=&quot;#CASE_INSENSITIVE&quot;&gt; &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; &lt;/a&gt; flag, is done in a manner consistent with the Unicode Standard. By default, case-insensitive matching assumes that only characters in the US-ASCII charset are being matched.</target>
        </trans-unit>
        <trans-unit id="7586fee8208377dc85e8eeb7ce578740e81e481a" translate="yes" xml:space="preserve">
          <source>When this flag is specified then case-insensitive matching, when enabled by the &lt;a href=&quot;pattern#CASE_INSENSITIVE&quot;&gt;&lt;code&gt;CASE_INSENSITIVE&lt;/code&gt;&lt;/a&gt; flag, is done in a manner consistent with the Unicode Standard. By default, case-insensitive matching assumes that only characters in the US-ASCII charset are being matched.</source>
          <target state="translated">このフラグが指定されている場合、&lt;a href=&quot;pattern#CASE_INSENSITIVE&quot;&gt; &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; &lt;/a&gt;フラグで有効にすると、Unicode規格に準拠した方法で大文字と小文字を区別しない照合が行われます。デフォルトでは、大文字と小文字を区別しないマッチングでは、US-ASCII文字セットの文字のみがマッチングされると想定されています。</target>
        </trans-unit>
        <trans-unit id="14b51aaf8931fe8814ff8bce6f0f7714b23eea9c" translate="yes" xml:space="preserve">
          <source>When this flag is specified then the (US-ASCII only)</source>
          <target state="translated">このフラグが指定されると、(US-ASCIIのみ)</target>
        </trans-unit>
        <trans-unit id="a5a64aeef21bfe24b3dc25f14183010379e48ae2" translate="yes" xml:space="preserve">
          <source>When this flag is specified then the input string that specifies the pattern is treated as a sequence of literal characters. Metacharacters or escape sequences in the input sequence will be given no special meaning.</source>
          <target state="translated">このフラグが指定されると、パターンを指定する入力文字列はリテラル文字のシーケンスとして扱われます。入力シーケンス中のメタキャラクタやエスケープシーケンスは特別な意味を持ちません。</target>
        </trans-unit>
        <trans-unit id="21f1033522929794d630209592d380a1564d3a0e" translate="yes" xml:space="preserve">
          <source>When this flag is specified then two characters will be considered to match if, and only if, their full canonical decompositions match. The expression &lt;code&gt;&quot;a\u030A&quot;&lt;/code&gt;, for example, will match the string &lt;code&gt;&quot;\u00E5&quot;&lt;/code&gt; when this flag is specified. By default, matching does not take canonical equivalence into account.</source>
          <target state="translated">このフラグが指定されている場合、2つの文字は、完全な正規分解が一致する場合にのみ一致すると見なされます。たとえば、式 &lt;code&gt;&quot;a\u030A&quot;&lt;/code&gt; 、このフラグが指定されている場合、文字列 &lt;code&gt;&quot;\u00E5&quot;&lt;/code&gt; と一致します。デフォルトでは、マッチングでは正規等価性は考慮されません。</target>
        </trans-unit>
        <trans-unit id="2eb07b710886c04bce981e5cfa33253d986b6149" translate="yes" xml:space="preserve">
          <source>When this method is called from a named module and the given loader is the class loader of the caller module, this is equivalent to calling:</source>
          <target state="translated">このメソッドが名前付きモジュールから呼び出され、与えられたローダが呼び出し元モジュールのクラスローダである場合、これは呼び出すことと同等です。</target>
        </trans-unit>
        <trans-unit id="97ec7609c528b9efd3de6f2bb7f5796b603e2fd8" translate="yes" xml:space="preserve">
          <source>When this method is called on a window with a value of &lt;code&gt;false&lt;/code&gt; the always-on-top state is set to normal. It may also cause an unspecified, platform-dependent change in the z-order of top-level windows, but other always-on-top windows will remain in top-most position. Calling this method with a value of &lt;code&gt;false&lt;/code&gt; on a window that has a normal state has no effect.</source>
          <target state="translated">When this method is called on a window with a value of &lt;code&gt;false&lt;/code&gt; the always-on-top state is set to normal. It may also cause an unspecified, platform-dependent change in the z-order of top-level windows, but other always-on-top windows will remain in top-most position. Calling this method with a value of &lt;code&gt;false&lt;/code&gt; on a window that has a normal state has no effect.</target>
        </trans-unit>
        <trans-unit id="35fc6a39f3e8a32dd792f6a29a5416db989863ad" translate="yes" xml:space="preserve">
          <source>When this method is called on a window with a value of &lt;code&gt;true&lt;/code&gt;, and the window is visible and the platform supports always-on-top for this window, the window is immediately brought forward, &quot;sticking&quot; it in the top-most position. If the window isn`t currently visible, this method sets the always-on-top state to &lt;code&gt;true&lt;/code&gt; but does not bring the window forward. When the window is later shown, it will be always-on-top.</source>
          <target state="translated">When this method is called on a window with a value of &lt;code&gt;true&lt;/code&gt; , and the window is visible and the platform supports always-on-top for this window, the window is immediately brought forward, &quot;sticking&quot; it in the top-most position. If the window isn`t currently visible, this method sets the always-on-top state to &lt;code&gt;true&lt;/code&gt; but does not bring the window forward. When the window is later shown, it will be always-on-top.</target>
        </trans-unit>
        <trans-unit id="34681f8822dac6f93802ce310f175da3ecf86017" translate="yes" xml:space="preserve">
          <source>When this method is called, a &lt;code&gt;CachedRowSet&lt;/code&gt; implementation must ensure that all updates, inserts, and deletes to the current rowset instance are replaced by the previous values. In addition, the cursor should be reset to the first row and a &lt;code&gt;rowSetChanged&lt;/code&gt; event should be fired to notify all registered listeners.</source>
          <target state="translated">When this method is called, a &lt;code&gt;CachedRowSet&lt;/code&gt; implementation must ensure that all updates, inserts, and deletes to the current rowset instance are replaced by the previous values. In addition, the cursor should be reset to the first row and a &lt;code&gt;rowSetChanged&lt;/code&gt; event should be fired to notify all registered listeners.</target>
        </trans-unit>
        <trans-unit id="c46ec6437cd48feaac1a48bb7981ed49d818cc15" translate="yes" xml:space="preserve">
          <source>When this method is first called, it creates a single new pseudorandom-number generator, exactly as if by the expression</source>
          <target state="translated">このメソッドが最初に呼ばれたとき、このメソッドは新しい擬似乱数生成器を作成します。</target>
        </trans-unit>
        <trans-unit id="8017fa479dbb420d64cc0450b94e2122cd6d705f" translate="yes" xml:space="preserve">
          <source>When this method is observed via the Core Reflection API, it will appear as a single native method, taking an object array and returning an object. If this native method is invoked directly via &lt;a href=&quot;../reflect/method#invoke(java.lang.Object,java.lang.Object...)&quot;&gt;&lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt;&lt;/a&gt;, via JNI, or indirectly via &lt;a href=&quot;methodhandles.lookup#unreflect(java.lang.reflect.Method)&quot;&gt;&lt;code&gt;Lookup.unreflect&lt;/code&gt;&lt;/a&gt;, it will throw an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</source>
          <target state="translated">When this method is observed via the Core Reflection API, it will appear as a single native method, taking an object array and returning an object. If this native method is invoked directly via &lt;a href=&quot;../reflect/method#invoke(java.lang.Object,java.lang.Object...)&quot;&gt; &lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt; &lt;/a&gt;, via JNI, or indirectly via &lt;a href=&quot;methodhandles.lookup#unreflect(java.lang.reflect.Method)&quot;&gt; &lt;code&gt;Lookup.unreflect&lt;/code&gt; &lt;/a&gt;, it will throw an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52757c7befe8d92c9dd6861f446c19ec7ae3c908" translate="yes" xml:space="preserve">
          <source>When this method is observed via the Core Reflection API, it will appear as a single native method, taking an object array and returning an object. If this native method is invoked directly via &lt;a href=&quot;../reflect/method#invoke-java.lang.Object-java.lang.Object...-&quot;&gt;&lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt;&lt;/a&gt;, via JNI, or indirectly via &lt;a href=&quot;methodhandles.lookup#unreflect-java.lang.reflect.Method-&quot;&gt;&lt;code&gt;Lookup.unreflect&lt;/code&gt;&lt;/a&gt;, it will throw an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</source>
          <target state="translated">このメソッドがCore Reflection APIを介して監視されると、単一のネイティブメソッドとして表示され、オブジェクト配列を取得してオブジェクトを返します。このネイティブメソッドが&lt;a href=&quot;../reflect/method#invoke-java.lang.Object-java.lang.Object...-&quot;&gt; &lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt; &lt;/a&gt;を介して直接、JNIを介して、または&lt;a href=&quot;methodhandles.lookup#unreflect-java.lang.reflect.Method-&quot;&gt; &lt;code&gt;Lookup.unreflect&lt;/code&gt; &lt;/a&gt;を介して間接的に呼び出されると、 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; がスローされます。</target>
        </trans-unit>
        <trans-unit id="a38dc9de2e7e26b0458b9e11ee50544cbc7608fa" translate="yes" xml:space="preserve">
          <source>When this method returns both the input and the output will have been closed. Any pending send operations will fail with &lt;code&gt;IOException&lt;/code&gt;. Subsequent invocations of &lt;code&gt;abort&lt;/code&gt; will have no effect.</source>
          <target state="translated">When this method returns both the input and the output will have been closed. Any pending send operations will fail with &lt;code&gt;IOException&lt;/code&gt; . Subsequent invocations of &lt;code&gt;abort&lt;/code&gt; will have no effect.</target>
        </trans-unit>
        <trans-unit id="3ee3ff5f0b0cb85ef35aeb00902b551ab3ba4149" translate="yes" xml:space="preserve">
          <source>When this method returns true, then it is possible that more input would have changed the result of the last search.</source>
          <target state="translated">このメソッドが真を返す場合、より多くの入力が最後の検索結果を変更した可能性があります。</target>
        </trans-unit>
        <trans-unit id="6509e5735d2c1c6ef7c6f2ecc98960052393fc92" translate="yes" xml:space="preserve">
          <source>When this object is passed to a &lt;code&gt;SecureRandom.getInstance()&lt;/code&gt; call, it is the requested minimum capability. When it's returned from &lt;code&gt;SecureRandom.getParameters()&lt;/code&gt;, it is the effective capability.</source>
          <target state="translated">When this object is passed to a &lt;code&gt;SecureRandom.getInstance()&lt;/code&gt; call, it is the requested minimum capability. When it's returned from &lt;code&gt;SecureRandom.getParameters()&lt;/code&gt; , it is the effective capability.</target>
        </trans-unit>
        <trans-unit id="1b6f8486c17688cf0a3d019c7be76ba42109c755" translate="yes" xml:space="preserve">
          <source>When this option is present then the implementation makes a &lt;em&gt;best effort&lt;/em&gt; attempt to delete the file when closed by the &lt;a href=&quot;../channels/channel#close()&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method. If the &lt;code&gt;close&lt;/code&gt; method is not invoked then a &lt;em&gt;best effort&lt;/em&gt; attempt is made to delete the file when the Java virtual machine terminates.</source>
          <target state="translated">When this option is present then the implementation makes a &lt;em&gt;best effort&lt;/em&gt; attempt to delete the file when closed by the &lt;a href=&quot;../channels/channel#close()&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; method. If the &lt;code&gt;close&lt;/code&gt; method is not invoked then a &lt;em&gt;best effort&lt;/em&gt; attempt is made to delete the file when the Java virtual machine terminates.</target>
        </trans-unit>
        <trans-unit id="c3d23117d12579aaf94e4afd1d23df8d2a8c9c22" translate="yes" xml:space="preserve">
          <source>When this option is present then the implementation makes a &lt;em&gt;best effort&lt;/em&gt; attempt to delete the file when closed by the &lt;a href=&quot;../channels/channel#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method. If the &lt;code&gt;close&lt;/code&gt; method is not invoked then a &lt;em&gt;best effort&lt;/em&gt; attempt is made to delete the file when the Java virtual machine terminates.</source>
          <target state="translated">このオプションが存在する場合、実装は、&lt;a href=&quot;../channels/channel#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;メソッドによって閉じられたときにファイルを削除&lt;em&gt;しよ&lt;/em&gt;うと&lt;em&gt;最善を尽くし&lt;/em&gt;ます。場合 &lt;code&gt;close&lt;/code&gt; 方法は、その後に呼び出されていない&lt;em&gt;ベストエフォート型&lt;/em&gt;の試みは、いつJava仮想マシンを終了するファイルを削除するように作られています。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="154a44d02d610434ad7eb55b13886c24f76c0303" translate="yes" xml:space="preserve">
          <source>When this option is present then the implementation makes a &lt;em&gt;best effort&lt;/em&gt; attempt to delete the file when closed by the &lt;a href=&quot;asynchronouschannel#close()&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method. If the &lt;code&gt;close&lt;/code&gt; method is not invoked then a &lt;em&gt;best effort&lt;/em&gt; attempt is made to delete the file when the Java virtual machine terminates.</source>
          <target state="translated">When this option is present then the implementation makes a &lt;em&gt;best effort&lt;/em&gt; attempt to delete the file when closed by the &lt;a href=&quot;asynchronouschannel#close()&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; method. If the &lt;code&gt;close&lt;/code&gt; method is not invoked then a &lt;em&gt;best effort&lt;/em&gt; attempt is made to delete the file when the Java virtual machine terminates.</target>
        </trans-unit>
        <trans-unit id="f56b2fb23d344e1a50af4c3e2e123c61d288eb20" translate="yes" xml:space="preserve">
          <source>When this option is present then the implementation makes a &lt;em&gt;best effort&lt;/em&gt; attempt to delete the file when closed by the &lt;a href=&quot;spi/abstractinterruptiblechannel#close()&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method. If the &lt;code&gt;close&lt;/code&gt; method is not invoked then a &lt;em&gt;best effort&lt;/em&gt; attempt is made to delete the file when the Java virtual machine terminates.</source>
          <target state="translated">When this option is present then the implementation makes a &lt;em&gt;best effort&lt;/em&gt; attempt to delete the file when closed by the &lt;a href=&quot;spi/abstractinterruptiblechannel#close()&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; method. If the &lt;code&gt;close&lt;/code&gt; method is not invoked then a &lt;em&gt;best effort&lt;/em&gt; attempt is made to delete the file when the Java virtual machine terminates.</target>
        </trans-unit>
        <trans-unit id="b452042a8719f181a9d60ae51034b9bcd166e197" translate="yes" xml:space="preserve">
          <source>When this option is present then the implementation makes a &lt;em&gt;best effort&lt;/em&gt; attempt to delete the file when closed by the the &lt;a href=&quot;asynchronouschannel#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method. If the &lt;code&gt;close&lt;/code&gt; method is not invoked then a &lt;em&gt;best effort&lt;/em&gt; attempt is made to delete the file when the Java virtual machine terminates.</source>
          <target state="translated">このオプションが存在する場合、&lt;a href=&quot;asynchronouschannel#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;メソッドによって閉じられたときに、実装はファイルを削除&lt;em&gt;しよ&lt;/em&gt;うと&lt;em&gt;最善を尽くし&lt;/em&gt;ます。場合 &lt;code&gt;close&lt;/code&gt; 方法は、その後に呼び出されていない&lt;em&gt;ベストエフォート型&lt;/em&gt;の試みは、いつJava仮想マシンを終了するファイルを削除するように作られています。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0f88517540cae38f29035447f8bcd48cdb8f163b" translate="yes" xml:space="preserve">
          <source>When this option is present then the implementation makes a &lt;em&gt;best effort&lt;/em&gt; attempt to delete the file when closed by the the &lt;a href=&quot;spi/abstractinterruptiblechannel#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method. If the &lt;code&gt;close&lt;/code&gt; method is not invoked then a &lt;em&gt;best effort&lt;/em&gt; attempt is made to delete the file when the Java virtual machine terminates.</source>
          <target state="translated">このオプションが存在する場合、&lt;a href=&quot;spi/abstractinterruptiblechannel#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;メソッドによって閉じられたときに、実装はファイルを削除&lt;em&gt;しよ&lt;/em&gt;うと&lt;em&gt;最善を尽くし&lt;/em&gt;ます。場合 &lt;code&gt;close&lt;/code&gt; 方法は、その後に呼び出されていない&lt;em&gt;ベストエフォート型&lt;/em&gt;の試みは、いつJava仮想マシンを終了するファイルを削除するように作られています。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a7cc18013b4812cde5f7d9912f2b87d319240ca6" translate="yes" xml:space="preserve">
          <source>When this property changes, a property change event with name &quot;dropLocation&quot; is fired by the component.</source>
          <target state="translated">このプロパティが変更されると、コンポーネントから &quot;dropLocation &quot;という名前のプロパティ変更イベントが発生します。</target>
        </trans-unit>
        <trans-unit id="038f87151a058e2199fb9c59c3147f43fabc5ee1" translate="yes" xml:space="preserve">
          <source>When this stage completes normally, the given function is invoked with this stage's result as the argument, returning another CompletionStage. When that stage completes normally, the CompletionStage returned by this method is completed with the same value.</source>
          <target state="translated">このステージが正常に終了すると、このステージの結果を引数として与えられた関数が呼び出され、別のCompletionStageが返されます。そのステージが正常に完了した場合、このメソッドが返すCompletionStageは同じ値で完了します。</target>
        </trans-unit>
        <trans-unit id="939cadcf27e2f0c5c29ad269b174f1448284da61" translate="yes" xml:space="preserve">
          <source>When this stage is complete, the given action is invoked with the result (or &lt;code&gt;null&lt;/code&gt; if none) and the exception (or &lt;code&gt;null&lt;/code&gt; if none) of this stage as arguments. The returned stage is completed when the action returns.</source>
          <target state="translated">When this stage is complete, the given action is invoked with the result (or &lt;code&gt;null&lt;/code&gt; if none) and the exception (or &lt;code&gt;null&lt;/code&gt; if none) of this stage as arguments. The returned stage is completed when the action returns.</target>
        </trans-unit>
        <trans-unit id="aaf41e965e28c5483c92f84aed2e73228dbc1a97" translate="yes" xml:space="preserve">
          <source>When this stage is complete, the given action is invoked with the result (or &lt;code&gt;null&lt;/code&gt; if none) and the exception (or &lt;code&gt;null&lt;/code&gt; if none) of this stage as arguments. The returned stage is completed when the action returns. If the supplied action itself encounters an exception, then the returned stage exceptionally completes with this exception unless this stage also completed exceptionally.</source>
          <target state="translated">このステージが完了すると、引数としてこのステージの結果（ない場合は &lt;code&gt;null&lt;/code&gt; ）と例外（ない場合は &lt;code&gt;null&lt;/code&gt; ）を指定して、指定されたアクションが呼び出されます。アクションが戻ると、返されたステージが完了します。指定されたアクション自体が例外に遭遇した場合、返されたステージは、このステージも例外的に完了しない限り、この例外で例外的に完了します。</target>
        </trans-unit>
        <trans-unit id="3f6f82cd6d0f4507ceec2cd68bde83c6bb558834" translate="yes" xml:space="preserve">
          <source>When this stage is complete, the given function is invoked with the result (or &lt;code&gt;null&lt;/code&gt; if none) and the exception (or &lt;code&gt;null&lt;/code&gt; if none) of this stage as arguments, and the function's result is used to complete the returned stage.</source>
          <target state="translated">このステージが完了すると、引数としてこのステージの結果（ない場合は &lt;code&gt;null&lt;/code&gt; ）と例外（ない場合は &lt;code&gt;null&lt;/code&gt; ）を指定して指定の関数が呼び出され、関数の結果を使用して返されたステージが完了します。</target>
        </trans-unit>
        <trans-unit id="bac49680cb60a5ee049452f6e78185889fe92438" translate="yes" xml:space="preserve">
          <source>When this stream reaches end of stream, further invocations of this method will return an empty byte array.</source>
          <target state="translated">このストリームがストリームの終端に達すると、このメソッドをそれ以上呼び出すと、空のバイト配列が返されます。</target>
        </trans-unit>
        <trans-unit id="48eb95265e7d021d7c0bcfe7d5877c9bf2e00f35" translate="yes" xml:space="preserve">
          <source>When to implement</source>
          <target state="translated">実施時期</target>
        </trans-unit>
        <trans-unit id="b19e6fec33654d65225b5a683c7ddc3223d7ead2" translate="yes" xml:space="preserve">
          <source>When to use this interface</source>
          <target state="translated">このインターフェイスを使用する場合</target>
        </trans-unit>
        <trans-unit id="2987413b1ccabfe41476e5c2416ebf03f5549889" translate="yes" xml:space="preserve">
          <source>When traversing a graph, an object may be encountered that does not support the Serializable interface. In this case the NotSerializableException will be thrown and will identify the class of the non-serializable object.</source>
          <target state="translated">グラフを走査していると、Serializable インターフェースをサポートしていないオブジェクトに遭遇することがあります。この場合は NotSerializableException がスローされ、シリアル化できないオブジェクトのクラスが特定されます。</target>
        </trans-unit>
        <trans-unit id="72491fa06ce4e80db58d269ec31cc9c29821a7b3" translate="yes" xml:space="preserve">
          <source>When two composite names are compared, the case of the characters is significant.</source>
          <target state="translated">2つの複合名を比較した場合、文字の大文字と小文字の区別が重要になります。</target>
        </trans-unit>
        <trans-unit id="d39ea45a6268a67c061975b6eb4abdceccee5c88" translate="yes" xml:space="preserve">
          <source>When two or more interfaces of a proxy class contain a method with the same name and parameter signature, the order of the proxy class's interfaces becomes significant. When such a</source>
          <target state="translated">プロキシクラスの二つ以上のインタフェースが同じ名前とパラメータシグネチャを持つメソッドを 含むとき、プロキシクラスのインタフェースの順序は重要になります。そのような</target>
        </trans-unit>
        <trans-unit id="824dd2ec1443a6d10bed31844958381a75362daa" translate="yes" xml:space="preserve">
          <source>When two or more proxy interfaces contain a method with the same name and parameter signature, the order of the proxy class's interfaces becomes significant. When such a</source>
          <target state="translated">二つ以上のプロキシインタフェースが同じ名前とパラメータシグネチャを持つメソッドを含む場合、 プロキシクラスのインタフェースの順序は重要になります。そのような</target>
        </trans-unit>
        <trans-unit id="f1f676950e16294bc9c468cad050677459c84e82" translate="yes" xml:space="preserve">
          <source>When two or more threads attempt to &lt;a href=&quot;#complete(T)&quot;&gt;&lt;code&gt;complete&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#completeExceptionally(java.lang.Throwable)&quot;&gt;&lt;code&gt;completeExceptionally&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#cancel(boolean)&quot;&gt;&lt;code&gt;cancel&lt;/code&gt;&lt;/a&gt; a CompletableFuture, only one of them succeeds.</source>
          <target state="translated">When two or more threads attempt to &lt;a href=&quot;#complete(T)&quot;&gt; &lt;code&gt;complete&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#completeExceptionally(java.lang.Throwable)&quot;&gt; &lt;code&gt;completeExceptionally&lt;/code&gt; &lt;/a&gt;, or &lt;a href=&quot;#cancel(boolean)&quot;&gt; &lt;code&gt;cancel&lt;/code&gt; &lt;/a&gt; a CompletableFuture, only one of them succeeds.</target>
        </trans-unit>
        <trans-unit id="e2cbb5b6ffa96f013fd73efb6c2acd02f012d948" translate="yes" xml:space="preserve">
          <source>When two or more threads attempt to &lt;a href=&quot;completablefuture#complete-T-&quot;&gt;&lt;code&gt;complete&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;completablefuture#completeExceptionally-java.lang.Throwable-&quot;&gt;&lt;code&gt;completeExceptionally&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;completablefuture#cancel-boolean-&quot;&gt;&lt;code&gt;cancel&lt;/code&gt;&lt;/a&gt; a CompletableFuture, only one of them succeeds.</source>
          <target state="translated">2つ以上のスレッドがCompletableFutureを&lt;a href=&quot;completablefuture#completeExceptionally-java.lang.Throwable-&quot;&gt; &lt;code&gt;completeExceptionally&lt;/code&gt; &lt;/a&gt;、CompleteExceptionally、または&lt;a href=&quot;completablefuture#cancel-boolean-&quot;&gt; &lt;code&gt;cancel&lt;/code&gt; &lt;/a&gt;しようと&lt;a href=&quot;completablefuture#complete-T-&quot;&gt; &lt;code&gt;complete&lt;/code&gt; &lt;/a&gt;、そのうちの1つだけが成功します。</target>
        </trans-unit>
        <trans-unit id="58e55e5b4a52749f3a8f688b451a56c8f51e84a5" translate="yes" xml:space="preserve">
          <source>When used in &lt;a href=&quot;securerandom#getInstance(java.lang.String,java.security.SecureRandomParameters)&quot;&gt;&lt;code&gt;SecureRandom.getInstance(String, SecureRandomParameters)&lt;/code&gt;&lt;/a&gt; or one of the other similar &lt;code&gt;getInstance&lt;/code&gt; calls that take a &lt;code&gt;SecureRandomParameters&lt;/code&gt; parameter, it means the requested instantiate parameters the newly created &lt;code&gt;SecureRandom&lt;/code&gt; object must minimally support. When used as the return value of the &lt;a href=&quot;securerandom#getParameters()&quot;&gt;&lt;code&gt;SecureRandom.getParameters()&lt;/code&gt;&lt;/a&gt; method, it means the effective instantiate parameters of the &lt;code&gt;SecureRandom&lt;/code&gt; object.</source>
          <target state="translated">When used in &lt;a href=&quot;securerandom#getInstance(java.lang.String,java.security.SecureRandomParameters)&quot;&gt; &lt;code&gt;SecureRandom.getInstance(String, SecureRandomParameters)&lt;/code&gt; &lt;/a&gt; or one of the other similar &lt;code&gt;getInstance&lt;/code&gt; calls that take a &lt;code&gt;SecureRandomParameters&lt;/code&gt; parameter, it means the requested instantiate parameters the newly created &lt;code&gt;SecureRandom&lt;/code&gt; object must minimally support. When used as the return value of the &lt;a href=&quot;securerandom#getParameters()&quot;&gt; &lt;code&gt;SecureRandom.getParameters()&lt;/code&gt; &lt;/a&gt; method, it means the effective instantiate parameters of the &lt;code&gt;SecureRandom&lt;/code&gt; object.</target>
        </trans-unit>
        <trans-unit id="43ffb4ecf968163232f09f73384f19b3a01bf3e9" translate="yes" xml:space="preserve">
          <source>When used in conjunction with the &lt;a href=&quot;formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt;, the above class produces the following output for various format strings.</source>
          <target state="translated">When used in conjunction with the &lt;a href=&quot;formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt;, the above class produces the following output for various format strings.</target>
        </trans-unit>
        <trans-unit id="7e3a4f8ce8f2ce779cc7d5b71b65b0b477e564ce" translate="yes" xml:space="preserve">
          <source>When used in conjunction with the &lt;a href=&quot;formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt;, the above class produces the following output for various format strings. &lt;code&gt;Formatter fmt = new Formatter();
   StockName sn = new StockName(&quot;HUGE&quot;, &quot;Huge Fruit, Inc.&quot;,
                                &quot;Fruit Titanesque, Inc.&quot;);
   fmt.format(&quot;%s&quot;, sn);                   //   -&amp;gt; &quot;Huge Fruit, Inc.&quot;
   fmt.format(&quot;%s&quot;, sn.toString());        //   -&amp;gt; &quot;HUGE - Huge Fruit, Inc.&quot;
   fmt.format(&quot;%#s&quot;, sn);                  //   -&amp;gt; &quot;HUGE&quot;
   fmt.format(&quot;%-10.8s&quot;, sn);              //   -&amp;gt; &quot;HUGE      &quot;
   fmt.format(&quot;%.12s&quot;, sn);                //   -&amp;gt; &quot;Huge Fruit,*&quot;
   fmt.format(Locale.FRANCE, &quot;%25s&quot;, sn);  //   -&amp;gt; &quot;   Fruit Titanesque, Inc.&quot;
 &lt;/code&gt;</source>
          <target state="translated">上記のクラスを&lt;a href=&quot;formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt;と組み合わせて使用​​すると、さまざまなフォーマット文字列に対して次の出力が生成されます。 &lt;code&gt;Formatter fmt = new Formatter(); StockName sn = new StockName(&quot;HUGE&quot;, &quot;Huge Fruit, Inc.&quot;, &quot;Fruit Titanesque, Inc.&quot;); fmt.format(&quot;%s&quot;, sn); // -&amp;gt; &quot;Huge Fruit, Inc.&quot; fmt.format(&quot;%s&quot;, sn.toString()); // -&amp;gt; &quot;HUGE - Huge Fruit, Inc.&quot; fmt.format(&quot;%#s&quot;, sn); // -&amp;gt; &quot;HUGE&quot; fmt.format(&quot;%-10.8s&quot;, sn); // -&amp;gt; &quot;HUGE &quot; fmt.format(&quot;%.12s&quot;, sn); // -&amp;gt; &quot;Huge Fruit,*&quot; fmt.format(Locale.FRANCE, &quot;%25s&quot;, sn); // -&amp;gt; &quot; Fruit Titanesque, Inc.&quot; &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="35a55ec2987f39f2327b6b1dee7f6dda3600a7d1" translate="yes" xml:space="preserve">
          <source>When used in the context of annotation processing, an accurate model of the element being represented must be returned. As this is a language model, the source code provides the fiducial (reference) representation of the construct in question rather than a representation in an executable output like a class file. Executable output may serve as the basis for creating a modeling element. However, the process of translating source code to executable output may not permit recovering some aspects of the source code representation. For example, annotations with &lt;a href=&quot;../../../../../java.base/java/lang/annotation/retentionpolicy#SOURCE&quot;&gt;source&lt;/a&gt;&lt;a href=&quot;../../../../../java.base/java/lang/annotation/retention&quot;&gt;retention&lt;/a&gt; cannot be recovered from class files and class files might not be able to provide source position information. Names of parameters may not be recoverable from class files. The &lt;a href=&quot;modifier&quot;&gt;modifiers&lt;/a&gt; on an element created from a class file may differ in some cases from an element for the same declaration created from a source file including:</source>
          <target state="translated">When used in the context of annotation processing, an accurate model of the element being represented must be returned. As this is a language model, the source code provides the fiducial (reference) representation of the construct in question rather than a representation in an executable output like a class file. Executable output may serve as the basis for creating a modeling element. However, the process of translating source code to executable output may not permit recovering some aspects of the source code representation. For example, annotations with &lt;a href=&quot;../../../../../java.base/java/lang/annotation/retentionpolicy#SOURCE&quot;&gt;source&lt;/a&gt;&lt;a href=&quot;../../../../../java.base/java/lang/annotation/retention&quot;&gt;retention&lt;/a&gt; cannot be recovered from class files and class files might not be able to provide source position information. Names of parameters may not be recoverable from class files. The &lt;a href=&quot;modifier&quot;&gt;modifiers&lt;/a&gt; on an element created from a class file may differ in some cases from an element for the same declaration created from a source file including:</target>
        </trans-unit>
        <trans-unit id="ece0b7fb1ed791cbe7da72a2d53b96e1e02fbd42" translate="yes" xml:space="preserve">
          <source>When used in the context of annotation processing, an accurate model of the element being represented must be returned. As this is a language model, the source code provides the fiducial (reference) representation of the construct in question rather than a representation in an executable output like a class file. Executable output may serve as the basis for creating a modeling element. However, the process of translating source code to executable output may not permit recovering some aspects of the source code representation. For example, annotations with &lt;a href=&quot;../../../../java/lang/annotation/retentionpolicy#SOURCE&quot;&gt;source&lt;/a&gt;&lt;a href=&quot;../../../../java/lang/annotation/retention&quot;&gt;retention&lt;/a&gt; cannot be recovered from class files and class files might not be able to provide source position information. Names of parameters may not be recoverable from class files. The &lt;a href=&quot;modifier&quot;&gt;modifiers&lt;/a&gt; on an element may differ in some cases including:</source>
          <target state="translated">注釈処理のコンテキストで使用する場合、表現される要素の正確なモデルを返す必要があります。これは言語モデルであるため、ソースコードは、クラスファイルのような実行可能な出力の表現ではなく、問題の構成の基準（参照）表現を提供します。実行可能な出力は、モデリング要素を作成するための基礎として役立ちます。ただし、ソースコードを実行可能な出力に変換するプロセスでは、ソースコード表現の一部の側面を回復できない場合があります。たとえば、&lt;a href=&quot;../../../../java/lang/annotation/retentionpolicy#SOURCE&quot;&gt;ソース&lt;/a&gt;&lt;a href=&quot;../../../../java/lang/annotation/retention&quot;&gt;保持のある&lt;/a&gt;アノテーションはクラスファイルから復元できず、クラスファイルはソース位置情報を提供できない場合があります。パラメータの名前は、クラスファイルから回復できない場合があります。&lt;a href=&quot;modifier&quot;&gt;修飾子&lt;/a&gt; 要素の場合、次のような場合に異なります。</target>
        </trans-unit>
        <trans-unit id="6ecb08ff72bf2beff0f22f91d00d7f8a358093b0" translate="yes" xml:space="preserve">
          <source>When used with other calendar systems it must correspond to an integral number of days and is normally an integral number of years.</source>
          <target state="translated">他のカレンダーシステムと併用する場合、それは整数の日数に対応していなければならず、通常は整数の年数である。</target>
        </trans-unit>
        <trans-unit id="f21fcfe8b96da09eeaeaa464fe8fd54f0f415d2c" translate="yes" xml:space="preserve">
          <source>When used with other calendar systems it must correspond to an integral number of days or months roughly equal to a year defined by the passage of the Earth around the Sun.</source>
          <target state="translated">他の暦で使用する場合は、太陽の周りを地球が通過することによって定義される1年にほぼ等しい日数または月数の積分に対応していなければならない。</target>
        </trans-unit>
        <trans-unit id="a27413589719b5a8253a0b8d9af0f9739bd28a5f" translate="yes" xml:space="preserve">
          <source>When used with other calendar systems it must correspond to an integral number of days.</source>
          <target state="translated">他のカレンダーシステムと併用する場合は、積分日数に対応している必要があります。</target>
        </trans-unit>
        <trans-unit id="9efada4e2737579f4bfde83c300d21f0a7943686" translate="yes" xml:space="preserve">
          <source>When used with other calendar systems it must correspond to the day defined by the rising and setting of the Sun on Earth. It is not required that days begin at midnight - when converting between calendar systems, the date should be equivalent at midday.</source>
          <target state="translated">他のカレンダーシステムと併用する場合は、地球上の太陽の日の出と日の入りで定義された日に対応している必要があります。日の始まりが真夜中であることは必須ではありません。</target>
        </trans-unit>
        <trans-unit id="62385eeb0c56551d6fa61230b23e3cea9e372c16" translate="yes" xml:space="preserve">
          <source>When used with other calendar systems there are no restrictions on the unit.</source>
          <target state="translated">他のカレンダーシステムと併用する場合は、本体に制限はありません。</target>
        </trans-unit>
        <trans-unit id="62abbe6041a1324368c7391f51baabfb09713986" translate="yes" xml:space="preserve">
          <source>When used with the GSSContext interface's wrap and getMIC methods, an instance of this class is used to indicate the desired Quality-of-Protection (QOP) and to request if confidentiality services are to be applied to caller supplied data (wrap only). To request default QOP, the value of 0 should be used for QOP.</source>
          <target state="translated">GSSContext インターフェースの wrap および getMIC メソッドと共に使用される場合、このクラスのインスタンスを使用して QOP (Quality-of-Protection)を指定し、発信者から提供されたデータに機密サービスが適用されるかどうかを要求します (wrap のみ)。デフォルトの QOP を要求するには、QOP に 0 を指定します。</target>
        </trans-unit>
        <trans-unit id="313c2c16bb6b15d1f21bba9cb9b9b5bc5566a742" translate="yes" xml:space="preserve">
          <source>When used with the unwrap and verifyMIC methods of the GSSContext interface, an instance of this class will be used to indicate the applied QOP and confidentiality services over the supplied message. In the case of verifyMIC, the confidentiality state will always be &lt;code&gt;false&lt;/code&gt;. Upon return from these methods, this object will also contain any supplementary status values applicable to the processed token. The supplementary status values can indicate old tokens, out of sequence tokens, gap tokens or duplicate tokens.</source>
          <target state="translated">When used with the unwrap and verifyMIC methods of the GSSContext interface, an instance of this class will be used to indicate the applied QOP and confidentiality services over the supplied message. In the case of verifyMIC, the confidentiality state will always be &lt;code&gt;false&lt;/code&gt; . Upon return from these methods, this object will also contain any supplementary status values applicable to the processed token. The supplementary status values can indicate old tokens, out of sequence tokens, gap tokens or duplicate tokens.</target>
        </trans-unit>
        <trans-unit id="9e6a51ecf8fcb17dbda43fef7e1c274e8aff30af" translate="yes" xml:space="preserve">
          <source>When used, this method changes the parsing to be lenient from this point onwards. The change will remain in force until the end of the formatter that is eventually constructed or until &lt;code&gt;parseStrict&lt;/code&gt; is called.</source>
          <target state="translated">このメソッドを使用すると、この時点以降、解析が緩やかになるように変更されます。変更は、最終的に構築されるフォーマッターの最後まで、または &lt;code&gt;parseStrict&lt;/code&gt; が呼び出されるまで有効です。</target>
        </trans-unit>
        <trans-unit id="ff556f1f879598b7bb76a699a0aec5ddb4224db2" translate="yes" xml:space="preserve">
          <source>When used, this method changes the parsing to be strict from this point onwards. As strict is the default, this is normally only needed after calling &lt;a href=&quot;#parseLenient()&quot;&gt;&lt;code&gt;parseLenient()&lt;/code&gt;&lt;/a&gt;. The change will remain in force until the end of the formatter that is eventually constructed or until &lt;code&gt;parseLenient&lt;/code&gt; is called.</source>
          <target state="translated">When used, this method changes the parsing to be strict from this point onwards. As strict is the default, this is normally only needed after calling &lt;a href=&quot;#parseLenient()&quot;&gt; &lt;code&gt;parseLenient()&lt;/code&gt; &lt;/a&gt;. The change will remain in force until the end of the formatter that is eventually constructed or until &lt;code&gt;parseLenient&lt;/code&gt; is called.</target>
        </trans-unit>
        <trans-unit id="5af032fc78d26434042d41d26faa4d468835b7bf" translate="yes" xml:space="preserve">
          <source>When used, this method changes the parsing to be strict from this point onwards. As strict is the default, this is normally only needed after calling &lt;a href=&quot;datetimeformatterbuilder#parseLenient--&quot;&gt;&lt;code&gt;parseLenient()&lt;/code&gt;&lt;/a&gt;. The change will remain in force until the end of the formatter that is eventually constructed or until &lt;code&gt;parseLenient&lt;/code&gt; is called.</source>
          <target state="translated">このメソッドを使用すると、この時点から厳密に解析が変更されます。strictがデフォルトなので、これは通常&lt;a href=&quot;datetimeformatterbuilder#parseLenient--&quot;&gt; &lt;code&gt;parseLenient()&lt;/code&gt; を&lt;/a&gt;呼び出した後にのみ必要です。変更は、最終的に構築されるフォーマッターの最後まで、または &lt;code&gt;parseLenient&lt;/code&gt; が呼び出されるまで有効です。</target>
        </trans-unit>
        <trans-unit id="3bea6a91a61ac47b8bd9736fff1365a319fd7ad0" translate="yes" xml:space="preserve">
          <source>When using a capacity-restricted deque, it is generally preferable to call &lt;a href=&quot;#offer(E)&quot;&gt;&lt;code&gt;offer&lt;/code&gt;&lt;/a&gt; separately on each element.</source>
          <target state="translated">When using a capacity-restricted deque, it is generally preferable to call &lt;a href=&quot;#offer(E)&quot;&gt; &lt;code&gt;offer&lt;/code&gt; &lt;/a&gt; separately on each element.</target>
        </trans-unit>
        <trans-unit id="da316a4cc51c1899088ef95b5f213463772f58cf" translate="yes" xml:space="preserve">
          <source>When using a loader's &lt;a href=&quot;serviceloader#stream()&quot;&gt;&lt;code&gt;stream()&lt;/code&gt;&lt;/a&gt; method then the elements are of type &lt;code&gt;Provider&lt;/code&gt;. This allows processing to select or filter on the provider class without instantiating the provider.</source>
          <target state="translated">When using a loader's &lt;a href=&quot;serviceloader#stream()&quot;&gt; &lt;code&gt;stream()&lt;/code&gt; &lt;/a&gt; method then the elements are of type &lt;code&gt;Provider&lt;/code&gt; . This allows processing to select or filter on the provider class without instantiating the provider.</target>
        </trans-unit>
        <trans-unit id="31ca175d1f09c132ed4a2c9c0157e1e350eb6ede" translate="yes" xml:space="preserve">
          <source>When using the IIOP transport, the client and server can specify what ORB to use with the attribute &lt;code&gt;java.naming.corba.orb&lt;/code&gt;. Connection to the ORB happens at &lt;a href=&quot;rmiconnectorserver#start--&quot;&gt;&lt;code&gt;start&lt;/code&gt;&lt;/a&gt; time for the connector server, and at &lt;a href=&quot;rmiconnector#connect-java.util.Map-&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt; time for the connector client. If the &lt;code&gt;java.naming.corba.orb&lt;/code&gt; attribute is contained in the environment Map, then its value (an &lt;a href=&quot;/openjdk~8_web/org/omg/corba/orb&quot;&gt;&lt;code&gt;ORB&lt;/code&gt;&lt;/a&gt;), is used to connect the IIOP Stubs. Otherwise, a new org.omg.CORBA.ORB is created by calling &lt;a href=&quot;/openjdk~8_web/org/omg/corba/orb&quot;&gt;&lt;code&gt;org.omg.CORBA.ORB.init((String[])null,(Properties)null)&lt;/code&gt;&lt;/a&gt;. A later RMI connector client or server in the same JVM can reuse this ORB, or it can create another one in the same way.</source>
          <target state="translated">IIOPトランスポートを使用する場合、クライアントとサーバーは、属性 &lt;code&gt;java.naming.corba.orb&lt;/code&gt; で使用するORBを指定できます。 ORBへの接続は、コネクター・サーバーの&lt;a href=&quot;rmiconnectorserver#start--&quot;&gt; &lt;code&gt;start&lt;/code&gt; &lt;/a&gt;時、およびコネクター・クライアントの&lt;a href=&quot;rmiconnector#connect-java.util.Map-&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt;時に行われます。場合 &lt;code&gt;java.naming.corba.orb&lt;/code&gt; の属性が環境Mapに格納され、その値（&lt;a href=&quot;/openjdk~8_web/org/omg/corba/orb&quot;&gt; &lt;code&gt;ORB&lt;/code&gt; が&lt;/a&gt;）、IIOPスタブを接続するために使用されます。それ以外の場合は、&lt;a href=&quot;/openjdk~8_web/org/omg/corba/orb&quot;&gt; &lt;code&gt;org.omg.CORBA.ORB.init((String[])null,(Properties)null)&lt;/code&gt; &lt;/a&gt;呼び出すことによって、新しいorg.omg.CORBA.ORBが作成されます。同じJVM内の新しいRMIコネクタクライアントまたはサーバーは、このORBを再利用するか、同じ方法で別のORBを作成できます。</target>
        </trans-unit>
        <trans-unit id="1094d843de7943a57b50e6ec3d12297784b464f6" translate="yes" xml:space="preserve">
          <source>When using the beanName as a serialized object name we convert the given beanName to a resource pathname and add a trailing &quot;.ser&quot; suffix. We then try to load a serialized object from that resource.</source>
          <target state="translated">シリアライズされたオブジェクト名としてbeanNameを使用する場合、与えられたbeanNameをリソースパス名に変換し、最後に&quot;.ser &quot;という接尾辞を追加します。そして、そのリソースからシリアライズされたオブジェクトをロードしようとします。</target>
        </trans-unit>
        <trans-unit id="a40a619f30648218521f9a9f35ae6461ea88f8ec" translate="yes" xml:space="preserve">
          <source>When using the default JRMP transport, RMI socket factories can be specified using the attributes &lt;code&gt;jmx.remote.rmi.client.socket.factory&lt;/code&gt; and &lt;code&gt;jmx.remote.rmi.server.socket.factory&lt;/code&gt; in the &lt;code&gt;environment&lt;/code&gt; given to the &lt;code&gt;RMIConnectorServer&lt;/code&gt; constructor. The values of these attributes must be of type &lt;a href=&quot;../../../../../java.rmi/java/rmi/server/rmiclientsocketfactory&quot;&gt;&lt;code&gt;RMIClientSocketFactory&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../../../../java.rmi/java/rmi/server/rmiserversocketfactory&quot;&gt;&lt;code&gt;RMIServerSocketFactory&lt;/code&gt;&lt;/a&gt;, respectively. These factories are used when creating the RMI objects associated with the connector.</source>
          <target state="translated">When using the default JRMP transport, RMI socket factories can be specified using the attributes &lt;code&gt;jmx.remote.rmi.client.socket.factory&lt;/code&gt; and &lt;code&gt;jmx.remote.rmi.server.socket.factory&lt;/code&gt; in the &lt;code&gt;environment&lt;/code&gt; given to the &lt;code&gt;RMIConnectorServer&lt;/code&gt; constructor. The values of these attributes must be of type &lt;a href=&quot;../../../../../java.rmi/java/rmi/server/rmiclientsocketfactory&quot;&gt; &lt;code&gt;RMIClientSocketFactory&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;../../../../../java.rmi/java/rmi/server/rmiserversocketfactory&quot;&gt; &lt;code&gt;RMIServerSocketFactory&lt;/code&gt; &lt;/a&gt;, respectively. These factories are used when creating the RMI objects associated with the connector.</target>
        </trans-unit>
        <trans-unit id="9b289c10690d3b720cf943c114f2a703d731c855" translate="yes" xml:space="preserve">
          <source>When using the default JRMP transport, RMI socket factories can be specified using the attributes &lt;code&gt;jmx.remote.rmi.client.socket.factory&lt;/code&gt; and &lt;code&gt;jmx.remote.rmi.server.socket.factory&lt;/code&gt; in the &lt;code&gt;environment&lt;/code&gt; given to the &lt;code&gt;RMIConnectorServer&lt;/code&gt; constructor. The values of these attributes must be of type &lt;a href=&quot;/openjdk~8_web/java/rmi/server/rmiclientsocketfactory&quot;&gt;&lt;code&gt;RMIClientSocketFactory&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;/openjdk~8_web/java/rmi/server/rmiserversocketfactory&quot;&gt;&lt;code&gt;RMIServerSocketFactory&lt;/code&gt;&lt;/a&gt;, respectively. These factories are used when creating the RMI objects associated with the connector.</source>
          <target state="translated">デフォルトのJRMPトランスポートを使用する場合、 &lt;code&gt;RMIConnectorServer&lt;/code&gt; コンストラクターに指定された &lt;code&gt;environment&lt;/code&gt; で属性 &lt;code&gt;jmx.remote.rmi.client.socket.factory&lt;/code&gt; および &lt;code&gt;jmx.remote.rmi.server.socket.factory&lt;/code&gt; を使用して、RMIソケットファクトリを指定できます。これらの属性の値は、それぞれ&lt;a href=&quot;/openjdk~8_web/java/rmi/server/rmiclientsocketfactory&quot;&gt; &lt;code&gt;RMIClientSocketFactory&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;/openjdk~8_web/java/rmi/server/rmiserversocketfactory&quot;&gt; &lt;code&gt;RMIServerSocketFactory&lt;/code&gt; &lt;/a&gt;タイプである必要があります。これらのファクトリーは、コネクターに関連付けられたRMIオブジェクトを作成するときに使用されます。</target>
        </trans-unit>
        <trans-unit id="5e657ee77256cf44030f873d13206c74a10610ec" translate="yes" xml:space="preserve">
          <source>When using the service loader's &lt;code&gt;iterator&lt;/code&gt;, the &lt;a href=&quot;iterator#hasNext()&quot;&gt;&lt;code&gt;hasNext&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;iterator#next()&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; methods will fail with &lt;a href=&quot;serviceconfigurationerror&quot;&gt;&lt;code&gt;ServiceConfigurationError&lt;/code&gt;&lt;/a&gt; if an error occurs locating, loading or instantiating a service provider. When processing the service loader's stream then &lt;code&gt;ServiceConfigurationError&lt;/code&gt; may be thrown by any method that causes a service provider to be located or loaded.</source>
          <target state="translated">When using the service loader's &lt;code&gt;iterator&lt;/code&gt; , the &lt;a href=&quot;iterator#hasNext()&quot;&gt; &lt;code&gt;hasNext&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;iterator#next()&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; methods will fail with &lt;a href=&quot;serviceconfigurationerror&quot;&gt; &lt;code&gt;ServiceConfigurationError&lt;/code&gt; &lt;/a&gt; if an error occurs locating, loading or instantiating a service provider. When processing the service loader's stream then &lt;code&gt;ServiceConfigurationError&lt;/code&gt; may be thrown by any method that causes a service provider to be located or loaded.</target>
        </trans-unit>
        <trans-unit id="ba566ef2656d9a242d602964e496b4d893948bab" translate="yes" xml:space="preserve">
          <source>When using this constructor, the Namespace URI is set to &lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt;&lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt;&lt;/a&gt; and the prefix is set to &lt;a href=&quot;../xmlconstants#DEFAULT_NS_PREFIX&quot;&gt;&lt;code&gt;XMLConstants.DEFAULT_NS_PREFIX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">When using this constructor, the Namespace URI is set to &lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt; &lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt; &lt;/a&gt; and the prefix is set to &lt;a href=&quot;../xmlconstants#DEFAULT_NS_PREFIX&quot;&gt; &lt;code&gt;XMLConstants.DEFAULT_NS_PREFIX&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="96c5642595e980fed49cb21924a5425817039bc3" translate="yes" xml:space="preserve">
          <source>When using this constructor, the prefix is set to &lt;a href=&quot;../xmlconstants#DEFAULT_NS_PREFIX&quot;&gt;&lt;code&gt;XMLConstants.DEFAULT_NS_PREFIX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">When using this constructor, the prefix is set to &lt;a href=&quot;../xmlconstants#DEFAULT_NS_PREFIX&quot;&gt; &lt;code&gt;XMLConstants.DEFAULT_NS_PREFIX&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="e87d4e305eeee8d02bfe9d7476f259cac952cdb2" translate="yes" xml:space="preserve">
          <source>When viewed as a character sequence, the length of a character buffer is simply the number of characters between the position (inclusive) and the limit (exclusive); that is, it is equivalent to &lt;code&gt;remaining()&lt;/code&gt;.</source>
          <target state="translated">文字シーケンスとして見た場合、文字バッファーの長さは、位置（両端を含む）と制限（両端を含まない）の間の文字数です。つまり、 &lt;code&gt;remaining()&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="b74b06615a3effa44bf4fa9888e60a5a1492ac50" translate="yes" xml:space="preserve">
          <source>When viewed as a member of a third type &lt;code&gt;C&lt;/code&gt;, however, the method in &lt;code&gt;A&lt;/code&gt; does override the one in &lt;code&gt;B&lt;/code&gt;:</source>
          <target state="translated">第三のタイプのメンバーとして見たときに &lt;code&gt;C&lt;/code&gt; 、しかしながら、方法 &lt;code&gt;A&lt;/code&gt; は、の一方をオーバーライドし &lt;code&gt;B&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="70641d46fc36740d8882e1912ac1db22e717a0cd" translate="yes" xml:space="preserve">
          <source>When waiting upon a &lt;code&gt;Condition&lt;/code&gt;, a &quot;&lt;em&gt;spurious wakeup&lt;/em&gt;&quot; is permitted to occur, in general, as a concession to the underlying platform semantics. This has little practical impact on most application programs as a &lt;code&gt;Condition&lt;/code&gt; should always be waited upon in a loop, testing the state predicate that is being waited for. An implementation is free to remove the possibility of spurious wakeups but it is recommended that applications programmers always assume that they can occur and so always wait in a loop.</source>
          <target state="translated">&lt;code&gt;Condition&lt;/code&gt; を待機しているとき、一般に、基になるプラットフォームのセマンティクスへの譲歩として、「&lt;em&gt;偽のウェイクアップ&lt;/em&gt;」が発生することが許可されています。 &lt;code&gt;Condition&lt;/code&gt; は常にループで待機し、待機している状態述語をテストする必要があるため、これはほとんどのアプリケーションプログラムに実際的な影響はほとんどありません。実装は偽のウェイクアップの可能性を自由に取り除くことができますが、アプリケーションプログラマーは常にそれが発生する可能性があると想定し、常にループで待機することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="4246b2cc19c9676bfe631da16932f916fd42e34e" translate="yes" xml:space="preserve">
          <source>When warnings/errors/fatal errors are found by the validator, the parser must handle them as if those errors were found by the parser itself. In other words, if the user-specified &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt; is set, it must receive those errors, and if not, they must be treated according to the implementation specific default error handling rules.</source>
          <target state="translated">When warnings/errors/fatal errors are found by the validator, the parser must handle them as if those errors were found by the parser itself. In other words, if the user-specified &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; &lt;/a&gt; is set, it must receive those errors, and if not, they must be treated according to the implementation specific default error handling rules.</target>
        </trans-unit>
        <trans-unit id="4b65ea9216658615a74fbadc89129a9320a6d2b4" translate="yes" xml:space="preserve">
          <source>When writing a multi-threaded application using Swing, there are two constraints to keep in mind: (refer to &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt; Concurrency in Swing &lt;/a&gt; for more details):</source>
          <target state="translated">When writing a multi-threaded application using Swing, there are two constraints to keep in mind: (refer to &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt; Concurrency in Swing &lt;/a&gt; for more details):</target>
        </trans-unit>
        <trans-unit id="50097f566388737a84366cf10ac13d1ccd775d2d" translate="yes" xml:space="preserve">
          <source>When writing an image, its metadata may be set by defining or modifying an &lt;code&gt;IIOMetadata&lt;/code&gt; object. Such an object may be obtained from an &lt;code&gt;ImageWriter&lt;/code&gt; or &lt;code&gt;ImageTranscoder&lt;/code&gt; (from the &lt;code&gt;javax.imageio&lt;/code&gt; package). Once such an object has been obtained, its contents may be set of modified via a &lt;code&gt;Document&lt;/code&gt; consisting of &lt;code&gt;IIOMetadataNode&lt;/code&gt;s. The document format may optionally be described using an &lt;code&gt;IIOMetadataFormat&lt;/code&gt; object.</source>
          <target state="translated">画像を書き込むとき、そのメタデータは &lt;code&gt;IIOMetadata&lt;/code&gt; オブジェクトを定義または変更することによって設定できます。このようなオブジェクトは、 &lt;code&gt;ImageWriter&lt;/code&gt; または &lt;code&gt;ImageTranscoder&lt;/code&gt; から（ &lt;code&gt;javax.imageio&lt;/code&gt; パッケージから）取得できます。このようなオブジェクトが取得されると、そのコンテンツは &lt;code&gt;IIOMetadataNode&lt;/code&gt; で構成される &lt;code&gt;Document&lt;/code&gt; を介して変更のセットになります。ドキュメント形式は、オプションで &lt;code&gt;IIOMetadataFormat&lt;/code&gt; オブジェクトを使用して記述できます。</target>
        </trans-unit>
        <trans-unit id="44b4a60f0d785ceae4f2f44785b50fadd22e0a67" translate="yes" xml:space="preserve">
          <source>When writing to a &lt;code&gt;LSOutput&lt;/code&gt;, the encoding is found by looking at the encoding information that is reachable through the &lt;code&gt;LSOutput&lt;/code&gt; and the item to be written (or its owner document) in this order:</source>
          <target state="translated">When writing to a &lt;code&gt;LSOutput&lt;/code&gt; , the encoding is found by looking at the encoding information that is reachable through the &lt;code&gt;LSOutput&lt;/code&gt; and the item to be written (or its owner document) in this order:</target>
        </trans-unit>
        <trans-unit id="d2afab89366cad1e703d500543bdeff2a26cf52f" translate="yes" xml:space="preserve">
          <source>When writing to a HTTP URI, a HTTP PUT is performed. When writing to other types of URIs, the mechanism for writing the data to the URI is implementation dependent.</source>
          <target state="translated">HTTP URIへの書き込み時には、HTTP PUTが実行される。他のタイプのURIに書き込む場合、データをURIに書き込むメカニズムは実装に依存する。</target>
        </trans-unit>
        <trans-unit id="da3859e404597e0949c5fd1f7d9550737c714ec5" translate="yes" xml:space="preserve">
          <source>When writing, an &lt;a href=&quot;../../metadata/iiometadata&quot;&gt;&lt;code&gt;IIOMetadata&lt;/code&gt;&lt;/a&gt; object for use by one of the &lt;code&gt;write()&lt;/code&gt; methods of &lt;a href=&quot;../../imagewriter&quot;&gt;&lt;code&gt;ImageWriter&lt;/code&gt;&lt;/a&gt; may be created from a &lt;code&gt;TIFFDirectory&lt;/code&gt; by &lt;a href=&quot;#getAsMetadata()&quot;&gt;&lt;code&gt;getAsMetadata()&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;TIFFDirectory&lt;/code&gt; itself may be created by construction or from the &lt;code&gt;IIOMetadata&lt;/code&gt; object returned by &lt;a href=&quot;../../imagewriter#getDefaultImageMetadata(javax.imageio.ImageTypeSpecifier,javax.imageio.ImageWriteParam)&quot;&gt;&lt;code&gt;ImageWriter.getDefaultImageMetadata()&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;TIFFField&lt;/code&gt;s in the directory may be set using the mutator methods provided in this class.</source>
          <target state="translated">When writing, an &lt;a href=&quot;../../metadata/iiometadata&quot;&gt; &lt;code&gt;IIOMetadata&lt;/code&gt; &lt;/a&gt; object for use by one of the &lt;code&gt;write()&lt;/code&gt; methods of &lt;a href=&quot;../../imagewriter&quot;&gt; &lt;code&gt;ImageWriter&lt;/code&gt; &lt;/a&gt; may be created from a &lt;code&gt;TIFFDirectory&lt;/code&gt; by &lt;a href=&quot;#getAsMetadata()&quot;&gt; &lt;code&gt;getAsMetadata()&lt;/code&gt; &lt;/a&gt;. The &lt;code&gt;TIFFDirectory&lt;/code&gt; itself may be created by construction or from the &lt;code&gt;IIOMetadata&lt;/code&gt; object returned by &lt;a href=&quot;../../imagewriter#getDefaultImageMetadata(javax.imageio.ImageTypeSpecifier,javax.imageio.ImageWriteParam)&quot;&gt; &lt;code&gt;ImageWriter.getDefaultImageMetadata()&lt;/code&gt; &lt;/a&gt;. The &lt;code&gt;TIFFField&lt;/code&gt; s in the directory may be set using the mutator methods provided in this class.</target>
        </trans-unit>
        <trans-unit id="eea2b78361ef1f62a351050fb4d8e084b0419681" translate="yes" xml:space="preserve">
          <source>When writing, the destination type maybe used to determine the color type of the image. The &lt;code&gt;SampleModel&lt;/code&gt; information will be ignored, and may be &lt;code&gt;null&lt;/code&gt;. For example, a 4-banded image could represent either CMYK or RGBA data. If a destination type is set, its &lt;code&gt;ColorModel&lt;/code&gt; will override any &lt;code&gt;ColorModel&lt;/code&gt; on the image itself. This is crucial when &lt;code&gt;setSourceBands&lt;/code&gt; is used since the image's &lt;code&gt;ColorModel&lt;/code&gt; will refer to the entire image rather than to the subset of bands being written.</source>
          <target state="translated">書き込み時には、宛先タイプを使用して、画像のカラータイプを決定できます。 &lt;code&gt;SampleModel&lt;/code&gt; のの情報は無視されます、そしてかもしれ &lt;code&gt;null&lt;/code&gt; 。たとえば、4バンドのイメージは、CMYKまたはRGBAデータを表すことができます。宛先タイプが設定されている場合、その &lt;code&gt;ColorModel&lt;/code&gt; 、任意のオーバーライドされます &lt;code&gt;ColorModel&lt;/code&gt; 画像自体に。画像の &lt;code&gt;ColorModel&lt;/code&gt; は、書き込まれているバンドのサブセットではなく画像全体を参照するため、 &lt;code&gt;setSourceBands&lt;/code&gt; を使用する場合、これは重要です。</target>
        </trans-unit>
        <trans-unit id="9a6b169cf5cbb999580ca1588fd37eab8e71b189" translate="yes" xml:space="preserve">
          <source>When you create an initial context (&lt;code&gt;InitialLdapContext&lt;/code&gt;), you can specify a list of request controls. These controls will be used as the request controls for any implicit LDAP &quot;bind&quot; operation performed by the context or contexts derived from the context. These are called &lt;em&gt;connection request controls&lt;/em&gt;. Use &lt;code&gt;getConnectControls()&lt;/code&gt; to get a context's connection request controls.</source>
          <target state="translated">初期コンテキスト（ &lt;code&gt;InitialLdapContext&lt;/code&gt; ）を作成するときに、リクエストコントロールのリストを指定できます。これらのコントロールは、コンテキストまたはコンテキストから派生したコンテキストによって実行されるすべての暗黙的なLDAP「バインド」操作の要求コントロールとして使用されます。これらは、&lt;em&gt;接続要求コントロール&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。 &lt;code&gt;getConnectControls()&lt;/code&gt; を使用して、コンテキストの接続要求コントロールを取得します。</target>
        </trans-unit>
        <trans-unit id="7a55210ed8a9bbd91ed99904496d79d9e437e1c1" translate="yes" xml:space="preserve">
          <source>When you request this property, &lt;code&gt;LabelView&lt;/code&gt; re-syncs its state with the properties of the &lt;code&gt;Element&lt;/code&gt;'s &lt;code&gt;AttributeSet&lt;/code&gt;. If &lt;code&gt;Element&lt;/code&gt;'s &lt;code&gt;AttributeSet&lt;/code&gt; does not have this property set, it will revert to false.</source>
          <target state="translated">When you request this property, &lt;code&gt;LabelView&lt;/code&gt; re-syncs its state with the properties of the &lt;code&gt;Element&lt;/code&gt; 's &lt;code&gt;AttributeSet&lt;/code&gt; . If &lt;code&gt;Element&lt;/code&gt; 's &lt;code&gt;AttributeSet&lt;/code&gt; does not have this property set, it will revert to false.</target>
        </trans-unit>
        <trans-unit id="76c291d7ec2e2a61da9c355ee091458c7391b573" translate="yes" xml:space="preserve">
          <source>When you want the &lt;code&gt;SwingWorker&lt;/code&gt; to block on the</source>
          <target state="translated">When you want the &lt;code&gt;SwingWorker&lt;/code&gt; to block on the</target>
        </trans-unit>
        <trans-unit id="221e0f97f37cb411d57af917bcf79190807898c6" translate="yes" xml:space="preserve">
          <source>When your program needs a locale-specific object, it loads the &lt;code&gt;ResourceBundle&lt;/code&gt; class using the &lt;a href=&quot;#getBundle(java.lang.String,java.util.Locale)&quot;&gt;&lt;code&gt;getBundle&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">When your program needs a locale-specific object, it loads the &lt;code&gt;ResourceBundle&lt;/code&gt; class using the &lt;a href=&quot;#getBundle(java.lang.String,java.util.Locale)&quot;&gt; &lt;code&gt;getBundle&lt;/code&gt; &lt;/a&gt; method:</target>
        </trans-unit>
        <trans-unit id="f5d6850ccbdf18f11fe78451acaa45891ec324a4" translate="yes" xml:space="preserve">
          <source>When your program needs a locale-specific object, it loads the &lt;code&gt;ResourceBundle&lt;/code&gt; class using the &lt;a href=&quot;resourcebundle#getBundle-java.lang.String-java.util.Locale-&quot;&gt;&lt;code&gt;getBundle&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">プログラムがロケール固有のオブジェクトを必要とする場合、&lt;a href=&quot;resourcebundle#getBundle-java.lang.String-java.util.Locale-&quot;&gt; &lt;code&gt;getBundle&lt;/code&gt; &lt;/a&gt;メソッドを使用して &lt;code&gt;ResourceBundle&lt;/code&gt; クラスをロードします。</target>
        </trans-unit>
        <trans-unit id="294687126fefbc03d977b1180723b4fd8063c95a" translate="yes" xml:space="preserve">
          <source>Whenever a permission is added to a heterogeneous PermissionCollection such as Permissions, and the PermissionCollection doesn't yet contain a PermissionCollection of the specified permission's type, the PermissionCollection should call the &lt;code&gt;newPermissionCollection&lt;/code&gt; method on the permission's class to see if it requires a special PermissionCollection. If &lt;code&gt;newPermissionCollection&lt;/code&gt; returns null, the PermissionCollection is free to store the permission in any type of PermissionCollection it desires (one using a Hashtable, one using a Vector, etc.). For example, the Permissions object uses a default PermissionCollection implementation that stores the permission objects in a Hashtable.</source>
          <target state="translated">アクセス許可がアクセス許可などの異種のPermissionCollectionに追加され、PermissionCollectionに指定されたアクセス許可の種類のPermissionCollectionがまだ含まれていない場合、PermissionCollectionは、アクセス許可のクラスで &lt;code&gt;newPermissionCollection&lt;/code&gt; メソッドを呼び出して、特別なPermissionCollectionが必要かどうかを確認する必要があります。 &lt;code&gt;newPermissionCollection&lt;/code&gt; がnullを返す場合、PermissionCollectionは、必要な任意のタイプのPermissionCollection（Hashtableを使用するもの、Vectorを使用するものなど）に自由にアクセス許可を格納できます。たとえば、Permissionsオブジェクトは、Hashtableに権限オブジェクトを格納するデフォルトのPermissionCollection実装を使用します。</target>
        </trans-unit>
        <trans-unit id="657dbd1f56168fcdb6c057d84ffab8877f436bb8" translate="yes" xml:space="preserve">
          <source>Whenever an operation occurs involving a source sequence (such as appending or inserting from a source sequence), this class synchronizes only on the string buffer performing the operation, not on the source. Note that while &lt;code&gt;StringBuffer&lt;/code&gt; is designed to be safe to use concurrently from multiple threads, if the constructor or the &lt;code&gt;append&lt;/code&gt; or &lt;code&gt;insert&lt;/code&gt; operation is passed a source sequence that is shared across threads, the calling code must ensure that the operation has a consistent and unchanging view of the source sequence for the duration of the operation. This could be satisfied by the caller holding a lock during the operation's call, by using an immutable source sequence, or by not sharing the source sequence across threads.</source>
          <target state="translated">ソースシーケンスに関係する操作（ソースシーケンスからの追加や挿入など）が発生すると、このクラスは、ソースではなく、操作を実行する文字列バッファーでのみ同期します。ながら、そのノート &lt;code&gt;StringBuffer&lt;/code&gt; コンストラクタ場合や、複数のスレッドから同時に使用しても安全であるように設計されている &lt;code&gt;append&lt;/code&gt; または &lt;code&gt;insert&lt;/code&gt; 操作がスレッド間で共有されたソースシーケンスが渡され、呼び出し元のコードは動作が一貫して不変のビューを持っていることを確認する必要があります操作中のソースシーケンスの。これは、操作の呼び出し中にロックを保持している呼び出し元が不変のソースシーケンスを使用するか、スレッド間でソースシーケンスを共有しないことで満たすことができます。</target>
        </trans-unit>
        <trans-unit id="431790292384e64efc177cdca9b3ed328240fae3" translate="yes" xml:space="preserve">
          <source>Whenever it is invoked on the same Permission object more than once during an execution of a Java application, the &lt;code&gt;hashCode&lt;/code&gt; method must consistently return the same integer. This integer need not remain consistent from one execution of an application to another execution of the same application.</source>
          <target state="translated">Javaアプリケーションの実行中に同じPermissionオブジェクトで複数回呼び出された場合、 &lt;code&gt;hashCode&lt;/code&gt; メソッドは常に同じ整数を返す必要があります。この整数は、アプリケーションのある実行から同じアプリケーションの別の実行まで一貫性を保つ必要はありません。</target>
        </trans-unit>
        <trans-unit id="588f7fe1bed2c7e664ebaf61ee198d0177166e9e" translate="yes" xml:space="preserve">
          <source>Whenever it is invoked on the same object more than once during an execution of a Java application, the &lt;code&gt;hashCode&lt;/code&gt; method must consistently return the same integer, provided no information used in &lt;code&gt;equals&lt;/code&gt; comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.</source>
          <target state="translated">Javaアプリケーションの実行中に同じオブジェクトで2回以上呼び出される &lt;code&gt;equals&lt;/code&gt; 、オブジェクトの等値比較で使用される情報が変更されていなければ、 &lt;code&gt;hashCode&lt;/code&gt; メソッドは常に同じ整数を返す必要があります。この整数は、アプリケーションのある実行から同じアプリケーションの別の実行まで一貫性を保つ必要はありません。</target>
        </trans-unit>
        <trans-unit id="ffc62db80b67ec0b4098632184a3dc10efde0cdb" translate="yes" xml:space="preserve">
          <source>Whenever it succeeds, it calls the previously instantiated resource bundle's &lt;a href=&quot;#setParent(java.util.ResourceBundle)&quot;&gt;&lt;code&gt;setParent&lt;/code&gt;&lt;/a&gt; method with the new resource bundle. This continues until the list of names is exhausted or the current bundle already has a non-null parent.</source>
          <target state="translated">Whenever it succeeds, it calls the previously instantiated resource bundle's &lt;a href=&quot;#setParent(java.util.ResourceBundle)&quot;&gt; &lt;code&gt;setParent&lt;/code&gt; &lt;/a&gt; method with the new resource bundle. This continues until the list of names is exhausted or the current bundle already has a non-null parent.</target>
        </trans-unit>
        <trans-unit id="e5ded5fcd7a735ce98c847740a18c44d83d66cc2" translate="yes" xml:space="preserve">
          <source>Whenever it succeeds, it calls the previously instantiated resource bundle's &lt;a href=&quot;resourcebundle#setParent-java.util.ResourceBundle-&quot;&gt;&lt;code&gt;setParent&lt;/code&gt;&lt;/a&gt; method with the new resource bundle. This continues until the list of names is exhausted or the current bundle already has a non-null parent.</source>
          <target state="translated">成功するたびに、以前にインスタンス化されたリソースバンドルの&lt;a href=&quot;resourcebundle#setParent-java.util.ResourceBundle-&quot;&gt; &lt;code&gt;setParent&lt;/code&gt; &lt;/a&gt;メソッドを新しいリソースバンドルで呼び出します。これは、名前のリストがなくなるか、現在のバンドルにnull以外の親がすでにあるまで続きます。</target>
        </trans-unit>
        <trans-unit id="f6905fb07fa47d960a6cc1c5c35a7ad900455a52" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;foo&lt;/code&gt; becomes a wrapper for the actual native method with the appended prefix &quot;wrapped_&quot;. Note that &quot;wrapped_&quot; would be a poor choice of prefix since it might conceivably form the name of an existing method thus something like &quot;$$$MyAgentWrapped$$$_&quot; would be better but would make these examples less readable.</source>
          <target state="translated">ここで、 &lt;code&gt;foo&lt;/code&gt; は、接頭辞「wrapped_」が付加された実際のネイティブメソッドのラッパーになります。「wrapped_」は既存のメソッドの名前を形成すると考えられるため、「$$$ MyAgentWrapped $$$ _」のような方が適切ですが、これらの例は読みにくくなります。</target>
        </trans-unit>
        <trans-unit id="9fff88ed5ff71cb64ca036661748f73a8e3a0800" translate="yes" xml:space="preserve">
          <source>Where a file is registered with a watch service by means of a symbolic link then it is implementation specific if the watch continues to depend on the existence of the symbolic link after it is registered.</source>
          <target state="translated">ファイルがシンボリックリンクによってウォッチサービスに登録されている場合、ウォッチが登録された後もシンボリックリンクの存在に依存し続けるのであれば、それは実装に依存します。</target>
        </trans-unit>
        <trans-unit id="d790f6a28291e56f379a271ae7232a655fb1d865" translate="yes" xml:space="preserve">
          <source>Where a membership key is not source-specific and the underlying operation system supports source filtering, then the &lt;a href=&quot;#block(java.net.InetAddress)&quot;&gt;&lt;code&gt;block&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unblock(java.net.InetAddress)&quot;&gt;&lt;code&gt;unblock&lt;/code&gt;&lt;/a&gt; methods can be used to block or unblock multicast datagrams from particular source addresses.</source>
          <target state="translated">Where a membership key is not source-specific and the underlying operation system supports source filtering, then the &lt;a href=&quot;#block(java.net.InetAddress)&quot;&gt; &lt;code&gt;block&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;#unblock(java.net.InetAddress)&quot;&gt; &lt;code&gt;unblock&lt;/code&gt; &lt;/a&gt; methods can be used to block or unblock multicast datagrams from particular source addresses.</target>
        </trans-unit>
        <trans-unit id="b4eef4e93d3c18e96b9b78253a20017e48bb542d" translate="yes" xml:space="preserve">
          <source>Where a membership key is not source-specific and the underlying operation system supports source filtering, then the &lt;a href=&quot;membershipkey#block-java.net.InetAddress-&quot;&gt;&lt;code&gt;block&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;membershipkey#unblock-java.net.InetAddress-&quot;&gt;&lt;code&gt;unblock&lt;/code&gt;&lt;/a&gt; methods can be used to block or unblock multicast datagrams from particular source addresses.</source>
          <target state="translated">メンバーシップキーがソース固有ではなく、基盤となるオペレーティングシステムがソースフィルタリングをサポートしている場合、&lt;a href=&quot;membershipkey#block-java.net.InetAddress-&quot;&gt; &lt;code&gt;block&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;membershipkey#unblock-java.net.InetAddress-&quot;&gt; &lt;code&gt;unblock&lt;/code&gt; &lt;/a&gt;メソッドを使用して、特定のソースアドレスからのマルチキャストデータグラムをブロックまたはブロック解除できます。</target>
        </trans-unit>
        <trans-unit id="ef0ae8bbc1659706ac95235ca1ce689fe57f64b3" translate="yes" xml:space="preserve">
          <source>Where an I/O operation completes immediately, and the initiating thread is one of the pooled threads in the group then the completion handler may be invoked directly by the initiating thread. To avoid stack overflow, an implementation may impose a limit as to the number of activations on the thread stack. Some I/O operations may prohibit invoking the completion handler directly by the initiating thread (see &lt;a href=&quot;asynchronousserversocketchannel#accept(A,java.nio.channels.CompletionHandler)&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Where an I/O operation completes immediately, and the initiating thread is one of the pooled threads in the group then the completion handler may be invoked directly by the initiating thread. To avoid stack overflow, an implementation may impose a limit as to the number of activations on the thread stack. Some I/O operations may prohibit invoking the completion handler directly by the initiating thread (see &lt;a href=&quot;asynchronousserversocketchannel#accept(A,java.nio.channels.CompletionHandler)&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="8898ed0b51f593284e7f77a4f867cd2fc2e666cb" translate="yes" xml:space="preserve">
          <source>Where an I/O operation completes immediately, and the initiating thread is one of the pooled threads in the group then the completion handler may be invoked directly by the initiating thread. To avoid stack overflow, an implementation may impose a limit as to the number of activations on the thread stack. Some I/O operations may prohibit invoking the completion handler directly by the initiating thread (see &lt;a href=&quot;asynchronousserversocketchannel#accept-A-java.nio.channels.CompletionHandler-&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">I / O操作がすぐに完了し、開始スレッドがグループ内のプールされたスレッドの1つである場合、完了ハンドラーは開始スレッドによって直接呼び出すことができます。スタックオーバーフローを回避するために、実装はスレッドスタックのアクティブ化の数に関して制限を課す場合があります。一部のI / O操作では、開始スレッドによる完了ハンドラの直接の呼び出しが禁止される場合があります（&lt;a href=&quot;asynchronousserversocketchannel#accept-A-java.nio.channels.CompletionHandler-&quot;&gt; &lt;code&gt;accept&lt;/code&gt; を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="66ce7e87d0492095ddc6703b1b7f0c7420f96474" translate="yes" xml:space="preserve">
          <source>Where an implementation does not support any notion of group then this method always throws &lt;a href=&quot;userprincipalnotfoundexception&quot;&gt;&lt;code&gt;UserPrincipalNotFoundException&lt;/code&gt;&lt;/a&gt;. Where the namespace for user accounts and groups is the same, then this method is identical to invoking &lt;a href=&quot;#lookupPrincipalByName(java.lang.String)&quot;&gt;&lt;code&gt;lookupPrincipalByName&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">実装がグループの概念をサポートしていない場合、このメソッドは常に&lt;a href=&quot;userprincipalnotfoundexception&quot;&gt; &lt;code&gt;UserPrincipalNotFoundException&lt;/code&gt; を&lt;/a&gt;スローします。ユーザーアカウントとグループの名前空間が同じである場合、このメソッドは&lt;a href=&quot;#lookupPrincipalByName(java.lang.String)&quot;&gt; &lt;code&gt;lookupPrincipalByName&lt;/code&gt; &lt;/a&gt;を呼び出すのと同じです。</target>
        </trans-unit>
        <trans-unit id="f2bcdaf392a0bc8b6a2ade4e800476f90476c33e" translate="yes" xml:space="preserve">
          <source>Where an implementation does not support any notion of group then this method always throws &lt;a href=&quot;userprincipalnotfoundexception&quot;&gt;&lt;code&gt;UserPrincipalNotFoundException&lt;/code&gt;&lt;/a&gt;. Where the namespace for user accounts and groups is the same, then this method is identical to invoking &lt;a href=&quot;userprincipallookupservice#lookupPrincipalByName-java.lang.String-&quot;&gt;&lt;code&gt;lookupPrincipalByName&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">実装がグループの概念をサポートしていない場合、このメソッドは常に&lt;a href=&quot;userprincipalnotfoundexception&quot;&gt; &lt;code&gt;UserPrincipalNotFoundException&lt;/code&gt; を&lt;/a&gt;スローします。ユーザーアカウントとグループの名前空間が同じ場合、このメソッドは&lt;a href=&quot;userprincipallookupservice#lookupPrincipalByName-java.lang.String-&quot;&gt; &lt;code&gt;lookupPrincipalByName&lt;/code&gt; &lt;/a&gt;を呼び出すのと同じです。</target>
        </trans-unit>
        <trans-unit id="cb723c111014ba92d8f87833b389ec9ea6719988" translate="yes" xml:space="preserve">
          <source>Where an implementation provides a means to start agents from the command-line interface, an agent is started by adding the following option to the command-line:</source>
          <target state="translated">実装がコマンドラインインタフェースからエージェントを起動する手段を提供する場合、エージェントは、コマンドラインに以下のオプションを追加することによって起動される。</target>
        </trans-unit>
        <trans-unit id="c9f90c3240707b3d864205080111e67313bf0eee" translate="yes" xml:space="preserve">
          <source>Where an implementation supports an ACL model that differs from the NFSv4 defined ACL model then setting the initial ACL when creating the file must translate the ACL to the model supported by the file system. Methods that create a file should reject (by throwing &lt;a href=&quot;../../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt;) any attempt to create a file that would be less secure as a result of the translation.</source>
          <target state="translated">実装がNFSv4定義のACLモデルとは異なるACLモデルをサポートしている場合、ファイルの作成時に初期ACLを設定すると、ACLがファイルシステムでサポートされているモデルに変換される必要があります。ファイルを作成するメソッドは、変換の結果として安全性の低いファイルを作成しようとする試みを（&lt;a href=&quot;../../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt;をスローすることによって）拒否する必要があります。</target>
        </trans-unit>
        <trans-unit id="8b05be389f68d5924db16624428d14d236ca56aa" translate="yes" xml:space="preserve">
          <source>Where desired, &lt;a href=&quot;processbuilder#redirect-input&quot;&gt; process I/O can also be redirected&lt;/a&gt; using methods of the &lt;a href=&quot;processbuilder&quot;&gt;&lt;code&gt;ProcessBuilder&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">必要に応じて、&lt;a href=&quot;processbuilder&quot;&gt; &lt;code&gt;ProcessBuilder&lt;/code&gt; &lt;/a&gt;クラスのメソッドを使用して&lt;a href=&quot;processbuilder#redirect-input&quot;&gt;プロセスI / Oをリダイレクト&lt;/a&gt;することもできます。</target>
        </trans-unit>
        <trans-unit id="3907849eb829645989d02022a9256583b35ccf13" translate="yes" xml:space="preserve">
          <source>Where desired, &lt;a href=&quot;processbuilder#redirect-input&quot;&gt; subprocess I/O can also be redirected&lt;/a&gt; using methods of the &lt;a href=&quot;processbuilder&quot;&gt;&lt;code&gt;ProcessBuilder&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">必要に応じて、&lt;a href=&quot;processbuilder&quot;&gt; &lt;code&gt;ProcessBuilder&lt;/code&gt; &lt;/a&gt;クラスのメソッドを使用して&lt;a href=&quot;processbuilder#redirect-input&quot;&gt;サブプロセスI / Oをリダイレクト&lt;/a&gt;することもできます。</target>
        </trans-unit>
        <trans-unit id="d8cf0baa75731ca6a5102a9d1799ad35f096def7" translate="yes" xml:space="preserve">
          <source>Where dynamic access to file attributes is required, the &lt;a href=&quot;../files#getAttribute(java.nio.file.Path,java.lang.String,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;getAttribute&lt;/code&gt;&lt;/a&gt; method may be used to read the attribute value. The attribute value is returned as a byte array (byte[]). The &lt;a href=&quot;../files#setAttribute(java.nio.file.Path,java.lang.String,java.lang.Object,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;setAttribute&lt;/code&gt;&lt;/a&gt; method may be used to write the value of a user-defined attribute from a buffer (as if by invoking the &lt;a href=&quot;#write(java.lang.String,java.nio.ByteBuffer)&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; method), or byte array (byte[]).</source>
          <target state="translated">ファイル属性への動的アクセスが必要な場合は、&lt;a href=&quot;../files#getAttribute(java.nio.file.Path,java.lang.String,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;getAttribute&lt;/code&gt; &lt;/a&gt;メソッドを使用して属性値を読み取ることができます。属性値はバイト配列（byte []）として返されます。&lt;a href=&quot;../files#setAttribute(java.nio.file.Path,java.lang.String,java.lang.Object,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;setAttribute&lt;/code&gt; メソッドの&lt;/a&gt;方法は、（あたかも呼び出すことによって、バッファからユーザ定義の属性の値を書き込むために使用することができる&lt;a href=&quot;#write(java.lang.String,java.nio.ByteBuffer)&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;法）、またはバイト配列（バイト[]）。</target>
        </trans-unit>
        <trans-unit id="0fbeca4a7ecd10802c77529dde8b082e44d0dd19" translate="yes" xml:space="preserve">
          <source>Where dynamic access to file attributes is required, the &lt;a href=&quot;../files#getAttribute-java.nio.file.Path-java.lang.String-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;getAttribute&lt;/code&gt;&lt;/a&gt; method may be used to read the attribute value. The attribute value is returned as a byte array (byte[]). The &lt;a href=&quot;../files#setAttribute-java.nio.file.Path-java.lang.String-java.lang.Object-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;setAttribute&lt;/code&gt;&lt;/a&gt; method may be used to write the value of a user-defined attribute from a buffer (as if by invoking the &lt;a href=&quot;userdefinedfileattributeview#write-java.lang.String-java.nio.ByteBuffer-&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; method), or byte array (byte[]).</source>
          <target state="translated">ファイル属性への動的アクセスが必要な場合は、&lt;a href=&quot;../files#getAttribute-java.nio.file.Path-java.lang.String-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;getAttribute&lt;/code&gt; &lt;/a&gt;メソッドを使用して属性値を読み取ることができます。属性値はバイト配列（byte []）として返されます。&lt;a href=&quot;../files#setAttribute-java.nio.file.Path-java.lang.String-java.lang.Object-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;setAttribute&lt;/code&gt; メソッドの&lt;/a&gt;方法は、（あたかも呼び出すことによって、バッファからユーザ定義の属性の値を書き込むために使用することができる&lt;a href=&quot;userdefinedfileattributeview#write-java.lang.String-java.nio.ByteBuffer-&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;法）、またはバイト配列（バイト[]）。</target>
        </trans-unit>
        <trans-unit id="ebb78ae3ef6ed103a9eb1696cdee777cab788dee" translate="yes" xml:space="preserve">
          <source>Where dynamic access to file attributes is required, the attributes supported by this attribute view are as defined by &lt;a href=&quot;basicfileattributeview&quot;&gt;&lt;code&gt;BasicFileAttributeView&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fileownerattributeview&quot;&gt;&lt;code&gt;FileOwnerAttributeView&lt;/code&gt;&lt;/a&gt;, and in addition, the following attributes are supported:</source>
          <target state="translated">ファイル属性への動的アクセスが必要な場合、この属性ビューでサポートされる属性は&lt;a href=&quot;basicfileattributeview&quot;&gt; &lt;code&gt;BasicFileAttributeView&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;fileownerattributeview&quot;&gt; &lt;code&gt;FileOwnerAttributeView&lt;/code&gt; &lt;/a&gt;で定義されているとおりであり、さらに次の属性がサポートされています。</target>
        </trans-unit>
        <trans-unit id="4e8ebe996cadf7a3b2a8cb30caf8f69a0b7ddda3" translate="yes" xml:space="preserve">
          <source>Where dynamic access to file attributes is required, the attributes supported by this attribute view are as defined by &lt;code&gt;
 BasicFileAttributeView&lt;/code&gt;, and in addition, the following attributes are supported:</source>
          <target state="translated">ファイル属性への動的アクセスが必要な場合、この属性ビューでサポートされる属性は、 &lt;code&gt; BasicFileAttributeView&lt;/code&gt; で定義されているとおりであり、さらに、次の属性がサポートされます。</target>
        </trans-unit>
        <trans-unit id="277ea500a19bef26e680e53fb1654aac09fa83bc" translate="yes" xml:space="preserve">
          <source>Where dynamic access to file attributes is required, the attributes supported by this attribute view are as defined by &lt;code&gt;BasicFileAttributeView&lt;/code&gt;, and in addition, the following attributes are supported:</source>
          <target state="translated">ファイル属性への動的アクセスが必要な場合、この属性ビューでサポートされる属性は &lt;code&gt;BasicFileAttributeView&lt;/code&gt; で定義されているとおりです。さらに、次の属性がサポートされています。</target>
        </trans-unit>
        <trans-unit id="cf674cc8cdf6492af75c97ec90cc9a040aea0c29" translate="yes" xml:space="preserve">
          <source>Where dynamic access to file attributes is required, the attributes supported by this attribute view are as follows:</source>
          <target state="translated">ファイル属性への動的アクセスが必要な場合、この属性ビューでサポートされる属性は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="8d820fbab2fe6e4127e50646c4e71b92a8792a22" translate="yes" xml:space="preserve">
          <source>Where dynamic access to file attributes is required, the attributes supported by this attribute view have the following names and types:</source>
          <target state="translated">ファイル属性への動的アクセスが必要な場合、この属性ビューでサポートされる属性には、以下の名前とタイプがあります。</target>
        </trans-unit>
        <trans-unit id="1a3a8b24e5fea76a61408fffd2a003c38a23b39a" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that &lt;code&gt;0L&lt;/code&gt; is returned, or where several attributes of the same file are required at the same time, then the &lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used.</source>
          <target state="translated">I / O例外を &lt;code&gt;0L&lt;/code&gt; が返される場合と区別する必要がある場合、または同じファイルの複数の属性が同時に必要な場合は、&lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt;メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="43d91b56e88fa1a42f8c6d2adc7c084514e56e79" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that &lt;code&gt;0L&lt;/code&gt; is returned, or where several attributes of the same file are required at the same time, then the &lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used.</source>
          <target state="translated">I / O例外を &lt;code&gt;0L&lt;/code&gt; が返される場合と区別する必要がある場合、または同じファイルの複数の属性が同時に必要な場合は、&lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt;メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="7de0392e6d47b4862228ebe6d2a818b846d1aedb" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a directory then the file attributes can be read with the &lt;a href=&quot;#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;readAttributes&lt;/code&gt;&lt;/a&gt; method and the file type tested with the &lt;a href=&quot;attribute/basicfileattributes#isDirectory()&quot;&gt;&lt;code&gt;BasicFileAttributes.isDirectory()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">I / O例外をファイルがディレクトリでない場合と区別する必要がある場合は、ファイル属性を&lt;a href=&quot;#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;readAttributes&lt;/code&gt; &lt;/a&gt;メソッドで読み取ることができ、ファイルタイプを&lt;a href=&quot;attribute/basicfileattributes#isDirectory()&quot;&gt; &lt;code&gt;BasicFileAttributes.isDirectory()&lt;/code&gt; &lt;/a&gt;メソッドでテストできます。</target>
        </trans-unit>
        <trans-unit id="005cb3d94ffb0d26668ec1404f37b73b1ba29dc4" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a directory then the file attributes can be read with the &lt;a href=&quot;files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;readAttributes&lt;/code&gt;&lt;/a&gt; method and the file type tested with the &lt;a href=&quot;attribute/basicfileattributes#isDirectory--&quot;&gt;&lt;code&gt;BasicFileAttributes.isDirectory()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">ファイルがディレクトリではない場合とI / O例外を区別する必要がある場合は、ファイル属性を&lt;a href=&quot;files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;readAttributes&lt;/code&gt; &lt;/a&gt;メソッドで読み取り、ファイルタイプを&lt;a href=&quot;attribute/basicfileattributes#isDirectory--&quot;&gt; &lt;code&gt;BasicFileAttributes.isDirectory()&lt;/code&gt; &lt;/a&gt;メソッドでテストできます。</target>
        </trans-unit>
        <trans-unit id="007567199ff26eceed4a5f4b5e1dc57ccb4d5705" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a directory, or where several attributes of the same file are required at the same time, then the &lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used.</source>
          <target state="translated">I / O例外を、ファイルがディレクトリではない場合と区別する必要がある場合、または同じファイルの複数の属性が同時に必要な場合は、&lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt;メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="2bbbcba21c28c4d8c2c4924803def9e4ddb35ba8" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a directory, or where several attributes of the same file are required at the same time, then the &lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used.</source>
          <target state="translated">ファイルがディレクトリではない場合とI / O例外を区別する必要がある場合、または同じファイルの複数の属性が同時に必要な場合は、&lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt;メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="74b9eef79be9b70ff82dc87b633ac874427f7ef1" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a normal file, or where several attributes of the same file are required at the same time, then the &lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used.</source>
          <target state="translated">I / O例外を、ファイルが通常のファイルではない場合と区別する必要がある場合、または同じファイルの複数の属性が同時に必要な場合は、&lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt;メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="298b25c773a1934ae542e41dcabec7d24973199b" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a normal file, or where several attributes of the same file are required at the same time, then the &lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used.</source>
          <target state="translated">ファイルが通常のファイルではない場合とI / O例外を区別する必要がある場合、または同じファイルの複数の属性が同時に必要な場合は、&lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt;メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="21258737e247b6c14994cdb209414cffbf2cb58c" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a regular file then the file attributes can be read with the &lt;a href=&quot;#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;readAttributes&lt;/code&gt;&lt;/a&gt; method and the file type tested with the &lt;a href=&quot;attribute/basicfileattributes#isRegularFile()&quot;&gt;&lt;code&gt;BasicFileAttributes.isRegularFile()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">I / O例外を、ファイルが通常のファイルではない場合と区別する必要がある場合、ファイル属性は&lt;a href=&quot;#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;readAttributes&lt;/code&gt; &lt;/a&gt;メソッドで読み取ることができ、ファイルタイプは&lt;a href=&quot;attribute/basicfileattributes#isRegularFile()&quot;&gt; &lt;code&gt;BasicFileAttributes.isRegularFile()&lt;/code&gt; &lt;/a&gt;メソッドでテストできます。</target>
        </trans-unit>
        <trans-unit id="02f695b12ef8bb76e6aea55a25eeab17ff1669ac" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a regular file then the file attributes can be read with the &lt;a href=&quot;files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;readAttributes&lt;/code&gt;&lt;/a&gt; method and the file type tested with the &lt;a href=&quot;attribute/basicfileattributes#isRegularFile--&quot;&gt;&lt;code&gt;BasicFileAttributes.isRegularFile()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">ファイルが通常のファイルではない場合とI / O例外を区別する必要がある場合は、&lt;a href=&quot;files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;readAttributes&lt;/code&gt; &lt;/a&gt;メソッドでファイル属性を読み取り、&lt;a href=&quot;attribute/basicfileattributes#isRegularFile--&quot;&gt; &lt;code&gt;BasicFileAttributes.isRegularFile()&lt;/code&gt; &lt;/a&gt;メソッドでファイルタイプをテストできます。</target>
        </trans-unit>
        <trans-unit id="b73ecca6efa6b0c0122ee193aadbfbbac0725868" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a symbolic link then the file attributes can be read with the &lt;a href=&quot;#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;readAttributes&lt;/code&gt;&lt;/a&gt; method and the file type tested with the &lt;a href=&quot;attribute/basicfileattributes#isSymbolicLink()&quot;&gt;&lt;code&gt;BasicFileAttributes.isSymbolicLink()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">I / O例外を、ファイルがシンボリックリンクではない場合と区別する必要がある場合は、ファイル属性を&lt;a href=&quot;#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;readAttributes&lt;/code&gt; &lt;/a&gt;メソッドで読み取り、ファイルタイプを&lt;a href=&quot;attribute/basicfileattributes#isSymbolicLink()&quot;&gt; &lt;code&gt;BasicFileAttributes.isSymbolicLink()&lt;/code&gt; &lt;/a&gt;メソッドでテストできます。</target>
        </trans-unit>
        <trans-unit id="3b99909cf143f334a41da20c3faff5347727a01c" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a symbolic link then the file attributes can be read with the &lt;a href=&quot;files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;readAttributes&lt;/code&gt;&lt;/a&gt; method and the file type tested with the &lt;a href=&quot;attribute/basicfileattributes#isSymbolicLink--&quot;&gt;&lt;code&gt;BasicFileAttributes.isSymbolicLink()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">I / O例外をファイルがシンボリックリンクではない場合と区別する必要がある場合、ファイル属性は&lt;a href=&quot;files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;readAttributes&lt;/code&gt; &lt;/a&gt;メソッドで読み取ることができ、ファイルタイプは&lt;a href=&quot;attribute/basicfileattributes#isSymbolicLink--&quot;&gt; &lt;code&gt;BasicFileAttributes.isSymbolicLink()&lt;/code&gt; &lt;/a&gt;メソッドでテストできます。</target>
        </trans-unit>
        <trans-unit id="0a3da2048af042507ba49cb66f0ec70eb628b60c" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case where &lt;code&gt;0L&lt;/code&gt; is returned, or where several attributes of the same file are required at the same time, or where the time of last access or the creation time are required, then the &lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used. If however only the time of last modification is required, then the &lt;a href=&quot;../nio/file/files#getLastModifiedTime(java.nio.file.Path,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;Files.getLastModifiedTime&lt;/code&gt;&lt;/a&gt; method may be used instead.</source>
          <target state="translated">I / O例外を、 &lt;code&gt;0L&lt;/code&gt; が返される場合と区別する必要がある場合、同じファイルの複数の属性が同時に必要な場合、または最終アクセス時刻または作成時刻が必要な場合は、&lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt;メソッドを使用できます。ただし、最後の変更の時刻のみが必要な場合は、代わりに&lt;a href=&quot;../nio/file/files#getLastModifiedTime(java.nio.file.Path,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;Files.getLastModifiedTime&lt;/code&gt; &lt;/a&gt;メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="acaa3530ad31cc461c41f4ed0c962b27b0124c2a" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case where &lt;code&gt;0L&lt;/code&gt; is returned, or where several attributes of the same file are required at the same time, or where the time of last access or the creation time are required, then the &lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used.</source>
          <target state="translated">I / O例外を &lt;code&gt;0L&lt;/code&gt; が返される場合と区別する必要がある場合、または同じファイルの複数の属性が同時に必要な場合、または最後にアクセスした時刻または作成時刻が必要な場合は、&lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt;メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="15c805f474acebca2530400cb8d6a021d50edd5e" translate="yes" xml:space="preserve">
          <source>Where possible, a newly constructed &lt;code&gt;DatagramSocket&lt;/code&gt; has the &lt;a href=&quot;socketoptions#SO_BROADCAST&quot;&gt;&lt;code&gt;SO_BROADCAST&lt;/code&gt;&lt;/a&gt; socket option enabled so as to allow the transmission of broadcast datagrams. In order to receive broadcast packets a DatagramSocket should be bound to the wildcard address. In some implementations, broadcast packets may also be received when a DatagramSocket is bound to a more specific address.</source>
          <target state="translated">可能な場合、新しく構築された &lt;code&gt;DatagramSocket&lt;/code&gt; は&lt;a href=&quot;socketoptions#SO_BROADCAST&quot;&gt; &lt;code&gt;SO_BROADCAST&lt;/code&gt; &lt;/a&gt;ソケットオプションを有効にして、ブロードキャストデータグラムの送信を可能にします。ブロードキャストパケットを受信するには、DatagramSocketをワイルドカードアドレスにバインドする必要があります。一部の実装では、DatagramSocketがより特定のアドレスにバインドされている場合、ブロードキャストパケットも受信される場合があります。</target>
        </trans-unit>
        <trans-unit id="ae2251eb2bdde2077099e46a23fa2296253a4452" translate="yes" xml:space="preserve">
          <source>Where possible, applications should use &lt;code&gt;LocalDate&lt;/code&gt;, &lt;code&gt;LocalTime&lt;/code&gt; and &lt;code&gt;LocalDateTime&lt;/code&gt; to better model the domain. For example, a birthday should be stored in a code &lt;code&gt;LocalDate&lt;/code&gt;. Bear in mind that any use of a &lt;a href=&quot;zoneid&quot;&gt;time-zone&lt;/a&gt;, such as 'Europe/Paris', adds considerable complexity to a calculation. Many applications can be written only using &lt;code&gt;LocalDate&lt;/code&gt;, &lt;code&gt;LocalTime&lt;/code&gt; and &lt;code&gt;Instant&lt;/code&gt;, with the time-zone added at the user interface (UI) layer.</source>
          <target state="translated">可能であれば、アプリケーションは &lt;code&gt;LocalDate&lt;/code&gt; 、 &lt;code&gt;LocalTime&lt;/code&gt; 、および &lt;code&gt;LocalDateTime&lt;/code&gt; を使用してドメインをより適切にモデル化する必要があります。たとえば、誕生日はコード &lt;code&gt;LocalDate&lt;/code&gt; に格納する必要があります。「ヨーロッパ/パリ」などの&lt;a href=&quot;zoneid&quot;&gt;タイムゾーンを&lt;/a&gt;使用すると、計算がかなり複雑になることに注意してください。多くのアプリケーションは &lt;code&gt;LocalDate&lt;/code&gt; 、 &lt;code&gt;LocalTime&lt;/code&gt; 、および &lt;code&gt;Instant&lt;/code&gt; を使用してのみ記述でき、タイムゾーンはユーザーインターフェイス（UI）レイヤーで追加されます。</target>
        </trans-unit>
        <trans-unit id="91b2e2e10f69ab09824cf8a20764fb8ed9c2bb88" translate="yes" xml:space="preserve">
          <source>Where several modules are defined to the same class loader, and where more than one module contains a resource with the given name, then the ordering is not specified and may be very unpredictable. When overriding this method it is recommended that an implementation ensures that any delegation is consistent with the &lt;a href=&quot;#getResource(java.lang.String)&quot;&gt;&lt;code&gt;getResource(String)&lt;/code&gt;&lt;/a&gt; method. This should ensure that the first element returned by the Enumeration's &lt;code&gt;nextElement&lt;/code&gt; method is the same resource that the &lt;code&gt;getResource(String)&lt;/code&gt; method would return.</source>
          <target state="translated">複数のモジュールが同じクラスローダーに定義されており、複数のモジュールに指定された名前のリソースが含まれている場合、順序は指定されておらず、非常に予測できない可能性があります。このメソッドをオーバーライドするときは、実装によって、委任が&lt;a href=&quot;#getResource(java.lang.String)&quot;&gt; &lt;code&gt;getResource(String)&lt;/code&gt; &lt;/a&gt;メソッドと一致していることを確認することをお勧めします。これにより、Enumerationの &lt;code&gt;nextElement&lt;/code&gt; メソッドによって返される最初の要素が、 &lt;code&gt;getResource(String)&lt;/code&gt; メソッドが返すのと同じリソースであることが保証されます。</target>
        </trans-unit>
        <trans-unit id="30feb1a1deb63d86d797b59fc10ebf6c8ef8b081" translate="yes" xml:space="preserve">
          <source>Where several modules are defined to the same class loader, and where more than one module contains a resource with the given name, then the ordering that modules are searched is not specified and may be very unpredictable. When overriding this method it is recommended that an implementation ensures that any delegation is consistent with the &lt;a href=&quot;#getResources(java.lang.String)&quot;&gt;&lt;code&gt;getResources(String)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">複数のモジュールが同じクラスローダーに定義されており、複数のモジュールに指定された名前のリソースが含まれている場合、モジュールが検索される順序は指定されておらず、非常に予測できない可能性があります。このメソッドをオーバーライドするときは、実装によって、委任が&lt;a href=&quot;#getResources(java.lang.String)&quot;&gt; &lt;code&gt;getResources(String)&lt;/code&gt; &lt;/a&gt;メソッドと一致していることを確認することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="87e0bb7fc901d05afac4326d164f35bed3f81996" translate="yes" xml:space="preserve">
          <source>Where symbolic links are supported, but the underlying &lt;a href=&quot;filestore&quot;&gt;&lt;code&gt;FileStore&lt;/code&gt;&lt;/a&gt; does not support symbolic links, then this may fail with an &lt;a href=&quot;../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt;. Additionally, some operating systems may require that the Java virtual machine be started with implementation specific privileges to create symbolic links, in which case this method may throw &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">シンボリックリンクがサポートされているが、基になる&lt;a href=&quot;filestore&quot;&gt; &lt;code&gt;FileStore&lt;/code&gt; &lt;/a&gt;がシンボリックリンクをサポートしていない場合、これは&lt;a href=&quot;../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; で&lt;/a&gt;失敗することがあります。さらに、一部のオペレーティングシステムでは、シンボリックリンクを作成するために実装固有の権限でJava仮想マシンを起動する必要がある場合があります。その場合、このメソッドは &lt;code&gt;IOException&lt;/code&gt; をスローすることがあります。</target>
        </trans-unit>
        <trans-unit id="aff3ccdb832b941a77362ca0a3153b1ed7d1a9da" translate="yes" xml:space="preserve">
          <source>Where syntactically malformed entries are encountered, the entry is ignored and the remainder of entries in file are processed. For instances where duplicate country code entries exist, the behavior of the Currency information for that &lt;code&gt;Currency&lt;/code&gt; is undefined and the remainder of entries in file are processed.</source>
          <target state="translated">構文的に不正なエントリが見つかった場合、そのエントリは無視され、ファイル内の残りのエントリが処理されます。重複した国コードのエントリが存在するインスタンスの場合は、そのための通貨情報の振る舞い &lt;code&gt;Currency&lt;/code&gt; 未定義であり、ファイル内のエントリの残りの部分が処理されます。</target>
        </trans-unit>
        <trans-unit id="645bad2c04254cc2a6d121dc714e9825c14fd591" translate="yes" xml:space="preserve">
          <source>Where the &lt;a href=&quot;../../util/concurrent/future#cancel(boolean)&quot;&gt;&lt;code&gt;cancel&lt;/code&gt;&lt;/a&gt; method is invoked with the &lt;code&gt;
 mayInterruptIfRunning&lt;/code&gt; parameter set to &lt;code&gt;true&lt;/code&gt; then the I/O operation may be interrupted by closing the channel. In that case all threads waiting on the result of the I/O operation throw &lt;code&gt;CancellationException&lt;/code&gt; and any other I/O operations outstanding on the channel complete with the exception &lt;a href=&quot;asynchronouscloseexception&quot;&gt;&lt;code&gt;AsynchronousCloseException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt; mayInterruptIfRunning&lt;/code&gt; パラメータを &lt;code&gt;true&lt;/code&gt; に設定して&lt;a href=&quot;../../util/concurrent/future#cancel(boolean)&quot;&gt; &lt;code&gt;cancel&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すと、チャネルを閉じることでI / O操作が中断される場合があります。その場合、I / O操作の結果を待機しているすべてのスレッドは、 &lt;code&gt;CancellationException&lt;/code&gt; をスローし、チャネルで未処理の他のI / O操作は、例外&lt;a href=&quot;asynchronouscloseexception&quot;&gt; &lt;code&gt;AsynchronousCloseException&lt;/code&gt; を&lt;/a&gt;除いて完了します。</target>
        </trans-unit>
        <trans-unit id="c0bfb8c567532e837621aeea501dc3f1ddcd12e2" translate="yes" xml:space="preserve">
          <source>Where the &lt;a href=&quot;../../util/concurrent/future#cancel-boolean-&quot;&gt;&lt;code&gt;cancel&lt;/code&gt;&lt;/a&gt; method is invoked with the &lt;code&gt;mayInterruptIfRunning&lt;/code&gt; parameter set to &lt;code&gt;true&lt;/code&gt; then the I/O operation may be interrupted by closing the channel. In that case all threads waiting on the result of the I/O operation throw &lt;code&gt;CancellationException&lt;/code&gt; and any other I/O operations outstanding on the channel complete with the exception &lt;a href=&quot;asynchronouscloseexception&quot;&gt;&lt;code&gt;AsynchronousCloseException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;mayInterruptIfRunning&lt;/code&gt; パラメータを &lt;code&gt;true&lt;/code&gt; に設定して&lt;a href=&quot;../../util/concurrent/future#cancel-boolean-&quot;&gt; &lt;code&gt;cancel&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すと、チャネルを閉じることによってI / O操作が中断される場合があります。その場合、I / O操作の結果を待機しているすべてのスレッドが &lt;code&gt;CancellationException&lt;/code&gt; をスローし、チャネル上で未処理の他のすべてのI / O操作が例外&lt;a href=&quot;asynchronouscloseexception&quot;&gt; &lt;code&gt;AsynchronousCloseException&lt;/code&gt; で&lt;/a&gt;完了します。</target>
        </trans-unit>
        <trans-unit id="c6c5daf70ef6f15c107a25281f6a04621e811b36" translate="yes" xml:space="preserve">
          <source>Where the &lt;code&gt;cancel&lt;/code&gt; method is invoked to cancel read or write operations then it is recommended that all buffers used in the I/O operations be discarded or care taken to ensure that the buffers are not accessed while the channel remains open.</source>
          <target state="translated">読み取りまたは書き込み操作をキャンセルするために &lt;code&gt;cancel&lt;/code&gt; メソッドが呼び出された場合、I / O操作で使用されるすべてのバッファーを破棄するか、チャネルが開いたままの状態でバッファーにアクセスしないように注意することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="9d8305902030508a453b89974c5e0784154948cf" translate="yes" xml:space="preserve">
          <source>Where the &lt;code&gt;modified_package_name&lt;/code&gt; is the package name of this object with &lt;code&gt;'/'&lt;/code&gt; substituted for &lt;code&gt;'.'&lt;/code&gt; (&lt;code&gt;'\u002e'&lt;/code&gt;).</source>
          <target state="translated">ここで、 &lt;code&gt;modified_package_name&lt;/code&gt; は、 &lt;code&gt;'/'&lt;/code&gt; が &lt;code&gt;'.'&lt;/code&gt; 置き換えられたこのオブジェクトのパッケージ名です。（ &lt;code&gt;'\u002e'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="20aa13f386a65b9aa665ab0dd65397813225275a" translate="yes" xml:space="preserve">
          <source>Where the channel is &lt;a href=&quot;#bind(java.net.SocketAddress)&quot;&gt;&lt;code&gt;bound&lt;/code&gt;&lt;/a&gt; to an Internet Protocol socket address then the return value from this method is of type &lt;a href=&quot;../../net/inetsocketaddress&quot;&gt;&lt;code&gt;InetSocketAddress&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">チャネルがインターネットプロトコルソケットアドレスに&lt;a href=&quot;#bind(java.net.SocketAddress)&quot;&gt; &lt;code&gt;bound&lt;/code&gt; &lt;/a&gt;れている場合、このメソッドからの戻り値は&lt;a href=&quot;../../net/inetsocketaddress&quot;&gt; &lt;code&gt;InetSocketAddress&lt;/code&gt; &lt;/a&gt;タイプです。</target>
        </trans-unit>
        <trans-unit id="4b1d4e9876a115d289cc3d3d89044c6ff716cd4b" translate="yes" xml:space="preserve">
          <source>Where the channel is &lt;a href=&quot;networkchannel#bind(java.net.SocketAddress)&quot;&gt;&lt;code&gt;bound&lt;/code&gt;&lt;/a&gt; to an Internet Protocol socket address then the return value from this method is of type &lt;a href=&quot;../../net/inetsocketaddress&quot;&gt;&lt;code&gt;InetSocketAddress&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">チャネルがインターネットプロトコルソケットアドレスに&lt;a href=&quot;networkchannel#bind(java.net.SocketAddress)&quot;&gt; &lt;code&gt;bound&lt;/code&gt; &lt;/a&gt;れている場合、このメソッドからの戻り値は&lt;a href=&quot;../../net/inetsocketaddress&quot;&gt; &lt;code&gt;InetSocketAddress&lt;/code&gt; &lt;/a&gt;タイプです。</target>
        </trans-unit>
        <trans-unit id="5776a8c2e2eb012135f9b2f791b325011a696da1" translate="yes" xml:space="preserve">
          <source>Where the channel is &lt;a href=&quot;networkchannel#bind-java.net.SocketAddress-&quot;&gt;&lt;code&gt;bound&lt;/code&gt;&lt;/a&gt; to an Internet Protocol socket address then the return value from this method is of type &lt;a href=&quot;../../net/inetsocketaddress&quot;&gt;&lt;code&gt;InetSocketAddress&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">チャネルがインターネットプロトコルソケットアドレスに&lt;a href=&quot;networkchannel#bind-java.net.SocketAddress-&quot;&gt; &lt;code&gt;bound&lt;/code&gt; &lt;/a&gt;れている場合、このメソッドからの戻り値は&lt;a href=&quot;../../net/inetsocketaddress&quot;&gt; &lt;code&gt;InetSocketAddress&lt;/code&gt; &lt;/a&gt;型です。</target>
        </trans-unit>
        <trans-unit id="2b5a252c98def07c02e37f2ec2055c98d16f0a55" translate="yes" xml:space="preserve">
          <source>Where the channel is bound and connected to an Internet Protocol socket address then the return value from this method is of type &lt;a href=&quot;../../net/inetsocketaddress&quot;&gt;&lt;code&gt;InetSocketAddress&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">チャネルがバインドされ、インターネットプロトコルソケットアドレスに接続されている場合、このメソッドからの戻り値は&lt;a href=&quot;../../net/inetsocketaddress&quot;&gt; &lt;code&gt;InetSocketAddress&lt;/code&gt; &lt;/a&gt;型です。</target>
        </trans-unit>
        <trans-unit id="f3d56641ee7619e7defb7d614564f85e1460565f" translate="yes" xml:space="preserve">
          <source>Where the directory is opened successfully, then the entries in the directory, and their &lt;em&gt;descendants&lt;/em&gt; are visited. When all entries have been visited, or an I/O error occurs during iteration of the directory, then the directory is closed and the visitor's &lt;a href=&quot;filevisitor#postVisitDirectory(T,java.io.IOException)&quot;&gt;&lt;code&gt;postVisitDirectory&lt;/code&gt;&lt;/a&gt; method is invoked. The file tree walk then continues, by default, at the next &lt;em&gt;sibling&lt;/em&gt; of the directory.</source>
          <target state="translated">ディレクトリが正常に開かれると、ディレクトリ内のエントリとその&lt;em&gt;子孫&lt;/em&gt;にアクセスします。すべてのエントリにアクセスした場合、またはディレクトリの反復中にI / Oエラーが発生した場合、ディレクトリが閉じられ、訪問者の&lt;a href=&quot;filevisitor#postVisitDirectory(T,java.io.IOException)&quot;&gt; &lt;code&gt;postVisitDirectory&lt;/code&gt; &lt;/a&gt;メソッドが呼び出されます。その後、ファイルツリーウォークは、デフォルトで、ディレクトリの次の&lt;em&gt;兄弟&lt;/em&gt;で続行されます。</target>
        </trans-unit>
        <trans-unit id="ddadcdbdf7fecb97856976200f59b9dff77b97ca" translate="yes" xml:space="preserve">
          <source>Where the directory is opened successfully, then the entries in the directory, and their &lt;em&gt;descendants&lt;/em&gt; are visited. When all entries have been visited, or an I/O error occurs during iteration of the directory, then the directory is closed and the visitor's &lt;a href=&quot;filevisitor#postVisitDirectory-T-java.io.IOException-&quot;&gt;&lt;code&gt;postVisitDirectory&lt;/code&gt;&lt;/a&gt; method is invoked. The file tree walk then continues, by default, at the next &lt;em&gt;sibling&lt;/em&gt; of the directory.</source>
          <target state="translated">ディレクトリが正常に開かれると、ディレクトリ内のエントリとその&lt;em&gt;子孫&lt;/em&gt;が訪問されます。すべてのエントリにアクセスした場合、またはディレクトリの反復中にI / Oエラーが発生した場合、ディレクトリは閉じられ、訪問者の&lt;a href=&quot;filevisitor#postVisitDirectory-T-java.io.IOException-&quot;&gt; &lt;code&gt;postVisitDirectory&lt;/code&gt; &lt;/a&gt;メソッドが呼び出されます。ファイルツリーウォークは、デフォルトでは、ディレクトリの次の&lt;em&gt;兄弟&lt;/em&gt;で続行されます。</target>
        </trans-unit>
        <trans-unit id="f20fbb77d5a28e0705439af43dcf961b9abb6e04" translate="yes" xml:space="preserve">
          <source>Where the file is a directory, and the directory could not be opened, then the &lt;code&gt;visitFileFailed&lt;/code&gt; method is invoked with the I/O exception, after which, the file tree walk continues, by default, at the next &lt;em&gt;sibling&lt;/em&gt; of the directory.</source>
          <target state="translated">ファイルがディレクトリであり、ディレクトリを開くことができなかった場合、 &lt;code&gt;visitFileFailed&lt;/code&gt; メソッドがI / O例外を伴って呼び出されます。その後、デフォルトでは、ディレクトリの次の&lt;em&gt;兄弟&lt;/em&gt;でファイルツリーウォークが続行されます。</target>
        </trans-unit>
        <trans-unit id="813178800981aaf7228102a5aacbe600959c9826" translate="yes" xml:space="preserve">
          <source>Where the file system supports Access Control Lists, and it uses an ACL model that differs from the NFSv4 defined ACL model, then this method must translate the ACL to the model supported by the file system. This method should reject (by throwing &lt;a href=&quot;../../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt;) any attempt to write an ACL that would appear to make the file more secure than would be the case if the ACL were updated. Where an implementation does not support a mapping of &lt;a href=&quot;aclentrytype#AUDIT&quot;&gt;&lt;code&gt;AclEntryType.AUDIT&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;aclentrytype#ALARM&quot;&gt;&lt;code&gt;AclEntryType.ALARM&lt;/code&gt;&lt;/a&gt; entries, then this method ignores these entries when writing the ACL.</source>
          <target state="translated">ファイルシステムがアクセス制御リストをサポートし、NFSv4定義のACLモデルとは異なるACLモデルを使用している場合、このメソッドはACLをファイルシステムでサポートされているモデルに変換する必要があります。このメソッドは、ACLが更新された場合よりもファイルをより安全にするように見えるACLを書き込もうとする試みを（&lt;a href=&quot;../../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt;をスローすることにより）拒否する必要があります。実装が&lt;a href=&quot;aclentrytype#AUDIT&quot;&gt; &lt;code&gt;AclEntryType.AUDIT&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;aclentrytype#ALARM&quot;&gt; &lt;code&gt;AclEntryType.ALARM&lt;/code&gt; &lt;/a&gt;エントリのマッピングをサポートしていない場合、このメソッドはACLの書き込み時にこれらのエントリを無視します。</target>
        </trans-unit>
        <trans-unit id="1bf3aa721e02b8abb961e05d45c9ccdfa7286d66" translate="yes" xml:space="preserve">
          <source>Where the filter terminates due to an uncaught error or runtime exception then it is propagated to the &lt;a href=&quot;../../util/iterator#hasNext()&quot;&gt;&lt;code&gt;hasNext&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../util/iterator#next()&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; method. Where an &lt;code&gt;
 IOException&lt;/code&gt; is thrown, it results in the &lt;code&gt;hasNext&lt;/code&gt; or &lt;code&gt;
 next&lt;/code&gt; method throwing a &lt;a href=&quot;directoryiteratorexception&quot;&gt;&lt;code&gt;DirectoryIteratorException&lt;/code&gt;&lt;/a&gt; with the &lt;code&gt;IOException&lt;/code&gt; as the cause.</source>
          <target state="translated">キャッチされなかったエラーまたはランタイム例外が原因でフィルターが終了した場合、フィルターは&lt;a href=&quot;../../util/iterator#hasNext()&quot;&gt; &lt;code&gt;hasNext&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../../util/iterator#next()&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;メソッドに伝搬されます。どこ &lt;code&gt; IOException&lt;/code&gt; スローされ、それは、その結果 &lt;code&gt;hasNext&lt;/code&gt; または &lt;code&gt; next&lt;/code&gt; 方法投げ&lt;a href=&quot;directoryiteratorexception&quot;&gt; &lt;code&gt;DirectoryIteratorException&lt;/code&gt; を&lt;/a&gt;して &lt;code&gt;IOException&lt;/code&gt; を原因として。</target>
        </trans-unit>
        <trans-unit id="8251e33247a11466c53d88af669cedf9a7c9b244" translate="yes" xml:space="preserve">
          <source>Where the filter terminates due to an uncaught error or runtime exception then it is propagated to the &lt;a href=&quot;../../util/iterator#hasNext--&quot;&gt;&lt;code&gt;hasNext&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../util/iterator#next--&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; method. Where an &lt;code&gt;IOException&lt;/code&gt; is thrown, it results in the &lt;code&gt;hasNext&lt;/code&gt; or &lt;code&gt;next&lt;/code&gt; method throwing a &lt;a href=&quot;directoryiteratorexception&quot;&gt;&lt;code&gt;DirectoryIteratorException&lt;/code&gt;&lt;/a&gt; with the &lt;code&gt;IOException&lt;/code&gt; as the cause.</source>
          <target state="translated">キャッチされないエラーまたはランタイム例外が原因でフィルターが終了した場合、&lt;a href=&quot;../../util/iterator#hasNext--&quot;&gt; &lt;code&gt;hasNext&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../../util/iterator#next--&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;メソッドに伝搬されます。 &lt;code&gt;IOException&lt;/code&gt; がスローされる場合、 &lt;code&gt;hasNext&lt;/code&gt; または &lt;code&gt;next&lt;/code&gt; メソッドが原因として &lt;code&gt;IOException&lt;/code&gt; を含む&lt;a href=&quot;directoryiteratorexception&quot;&gt; &lt;code&gt;DirectoryIteratorException&lt;/code&gt; &lt;/a&gt;をスローします。</target>
        </trans-unit>
        <trans-unit id="6af0ee5404f0be6ffe44935c032e92267f7c81e1" translate="yes" xml:space="preserve">
          <source>Where the impact lies, however, is in constructing and showing a Swing application. Calls to an application's &lt;code&gt;main&lt;/code&gt; method, or methods in &lt;code&gt;Applet&lt;/code&gt;, are not invoked on the event dispatching thread. As such, care must be taken to transfer control to the event dispatching thread when constructing and showing an application or applet. The preferred way to transfer control and begin working with Swing is to use &lt;code&gt;invokeLater&lt;/code&gt;. The &lt;code&gt;invokeLater&lt;/code&gt; method schedules a &lt;code&gt;Runnable&lt;/code&gt; to be processed on the event dispatching thread. The following two examples work equally well for transferring control and starting up a Swing application:</source>
          <target state="translated">ただし、影響が及ぶのは、Swingアプリケーションの構築と表示です。アプリケーションの &lt;code&gt;main&lt;/code&gt; メソッド、または &lt;code&gt;Applet&lt;/code&gt; メソッドへの呼び出しは、イベントディスパッチスレッドでは呼び出されません。そのため、アプリケーションまたはアプレットを作成して表示するときは、イベントディスパッチスレッドに制御を移すように注意する必要があります。制御を転送してSwingの操作を開始するための推奨される方法は、 &lt;code&gt;invokeLater&lt;/code&gt; を使用することです。 &lt;code&gt;invokeLater&lt;/code&gt; の方法スケジュール &lt;code&gt;Runnable&lt;/code&gt; イベントディスパッチスレッド上で処理されます。次の2つの例は、制御の転送とSwingアプリケーションの起動に同様に機能します。</target>
        </trans-unit>
        <trans-unit id="c51f5961597e3abbd7cbd8e36154eb7f8ad2d5be" translate="yes" xml:space="preserve">
          <source>Where the nodes to be removed are read-only descendants of an &lt;code&gt;EntityReference&lt;/code&gt;, the &lt;code&gt;EntityReference&lt;/code&gt; must be removed instead of the read-only nodes. If any &lt;code&gt;EntityReference&lt;/code&gt; to be removed has descendants that are not &lt;code&gt;EntityReference&lt;/code&gt;, &lt;code&gt;Text&lt;/code&gt;, or &lt;code&gt;CDATASection&lt;/code&gt; nodes, the &lt;code&gt;replaceWholeText&lt;/code&gt; method must fail before performing any modification of the document, raising a &lt;code&gt;DOMException&lt;/code&gt; with the code &lt;code&gt;NO_MODIFICATION_ALLOWED_ERR&lt;/code&gt;.</source>
          <target state="translated">ノードは読み取り専用の子孫を除去する場合 &lt;code&gt;EntityReference&lt;/code&gt; 、 &lt;code&gt;EntityReference&lt;/code&gt; 代わりに読み出し専用ノードから除去されなければなりません。いずれの場合 &lt;code&gt;EntityReference&lt;/code&gt; 削除するではない子孫持ち &lt;code&gt;EntityReference&lt;/code&gt; 、 &lt;code&gt;Text&lt;/code&gt; 、または &lt;code&gt;CDATASection&lt;/code&gt; ノードを、 &lt;code&gt;replaceWholeText&lt;/code&gt; の方法が上げ、文書の任意の変更を行う前に、失敗しなければならない &lt;code&gt;DOMException&lt;/code&gt; コードで &lt;code&gt;NO_MODIFICATION_ALLOWED_ERR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9e95719d37b90a01bb50bb0f34cef6a4524dc4a" translate="yes" xml:space="preserve">
          <source>Where the tabs are placed.</source>
          <target state="translated">タブが配置されている場所</target>
        </trans-unit>
        <trans-unit id="312f35b21c5541d25fef137d0c9ff3c37934f56a" translate="yes" xml:space="preserve">
          <source>Where there is insufficient space to store the attribute, or the attribute name or value exceed an implementation specific maximum size then an &lt;code&gt;IOException&lt;/code&gt; is thrown.</source>
          <target state="translated">属性を格納するための十分なスペースがない場合、または属性の名前または値が実装固有の最大サイズを超える &lt;code&gt;IOException&lt;/code&gt; は、IOExceptionがスローされます。</target>
        </trans-unit>
        <trans-unit id="78177395926d156536f0c1ac9740391b9dc6422e" translate="yes" xml:space="preserve">
          <source>Where this method returns &lt;code&gt;true&lt;/code&gt;, then the associated thread pool has also &lt;a href=&quot;../../util/concurrent/executorservice#isTerminated()&quot;&gt;&lt;code&gt;terminated&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このメソッドが &lt;code&gt;true&lt;/code&gt; を返す場合、関連するスレッドプールも&lt;a href=&quot;../../util/concurrent/executorservice#isTerminated()&quot;&gt; &lt;code&gt;terminated&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e3596c9771db04fbff45896ebd877c1d02f0912e" translate="yes" xml:space="preserve">
          <source>Where this method returns &lt;code&gt;true&lt;/code&gt;, then the associated thread pool has also &lt;a href=&quot;../../util/concurrent/executorservice#isTerminated--&quot;&gt;&lt;code&gt;terminated&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このメソッドが &lt;code&gt;true&lt;/code&gt; を返す場合、関連するスレッドプールも&lt;a href=&quot;../../util/concurrent/executorservice#isTerminated--&quot;&gt; &lt;code&gt;terminated&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ca7c18078eeeb8440182461deea920927988a9b5" translate="yes" xml:space="preserve">
          <source>Where two scroll bars meet, the row header meets the column header, or a scroll bar meets one of the headers, both components stop short of the corner, leaving a rectangular space which is, by default, empty. These spaces can potentially exist in any number of the four corners. In the previous diagram, the top right space is present and identified by the label &quot;corner component&quot;.</source>
          <target state="translated">2本のスクロールバーが出会う場所、行ヘッダが列ヘッダに出会う場所、またはスクロールバーがヘッダの1つに出会う場所では、両方のコンポーネントがコーナーのすぐ近くで止まり、長方形のスペースが残ります(デフォルトでは空)。これらのスペースは、4つのコーナーのうち、いくつでも存在する可能性があります。前の図では、右上のスペースが存在し、「コーナー・コンポーネント」というラベルで識別されています。</target>
        </trans-unit>
        <trans-unit id="f85fba4d6258a50067fbdc6fb4924687e3519a29" translate="yes" xml:space="preserve">
          <source>Where value limitations are given, any value outside of that set is reserved for future use; the value will be treated as the default.</source>
          <target state="translated">値の制限が与えられている場合、そのセット外の値は将来の使用のために予約されています。</target>
        </trans-unit>
        <trans-unit id="b93b49aca4151b6c139adc0aa283a778340da4f0" translate="yes" xml:space="preserve">
          <source>Where, in this case, the method handle is bound to the VarHandle instance.</source>
          <target state="translated">ここで、この場合、メソッド・ハンドルは VarHandle インスタンスにバインドされます。</target>
        </trans-unit>
        <trans-unit id="70c9d617c105e0ab6aed38dbb10fa98dbb5056d6" translate="yes" xml:space="preserve">
          <source>Whereas a &lt;code&gt;PrintService&lt;/code&gt; connected to a physical printer can be reused, a &lt;code&gt;StreamPrintService&lt;/code&gt; connected to a stream cannot. The underlying &lt;code&gt;StreamPrintService&lt;/code&gt; may be disposed by the print system with the &lt;a href=&quot;streamprintservice#dispose()&quot;&gt;&lt;code&gt;dispose&lt;/code&gt;&lt;/a&gt; method before returning from the &lt;a href=&quot;docprintjob#print(javax.print.Doc,javax.print.attribute.PrintRequestAttributeSet)&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;DocPrintJob&lt;/code&gt; so that the print system knows this printer is no longer usable. This is equivalent to a physical printer going offline - permanently. Applications may supply a &lt;code&gt;null&lt;/code&gt; print stream to create a queryable service. It is not valid to create a &lt;code&gt;PrintJob&lt;/code&gt; for such a stream. Implementations which allocate resources on construction should examine the stream and may wish to only allocate resources if the stream is &lt;code&gt;non-null&lt;/code&gt;.</source>
          <target state="translated">物理プリンターに接続された &lt;code&gt;PrintService&lt;/code&gt; は再利用できますが、ストリームに接続された &lt;code&gt;StreamPrintService&lt;/code&gt; は再利用できません。基になる &lt;code&gt;StreamPrintService&lt;/code&gt; は、 &lt;code&gt;DocPrintJob&lt;/code&gt; の&lt;a href=&quot;docprintjob#print(javax.print.Doc,javax.print.attribute.PrintRequestAttributeSet)&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt;メソッドから戻る前に、&lt;a href=&quot;streamprintservice#dispose()&quot;&gt; &lt;code&gt;dispose&lt;/code&gt; &lt;/a&gt;メソッドを使用して印刷システムによって破棄されるため、印刷システムはこのプリンターが使用できなくなったことを認識します。これは、物理プリンターが永続的にオフラインになるのと同じです。アプリケーションは、クエリ可能なサービスを作成するために &lt;code&gt;null&lt;/code&gt; 印刷ストリームを提供する場合があります。 &lt;code&gt;PrintJob&lt;/code&gt; を作成することは無効ですそのようなストリームのために。構築時にリソースを割り当てる実装は、ストリームを調べる必要があり、ストリームが &lt;code&gt;non-null&lt;/code&gt; 場合にのみリソースを割り当てたい場合があります。</target>
        </trans-unit>
        <trans-unit id="7b6a9723c6d2f9343f85c6d8af60801d7b7682ec" translate="yes" xml:space="preserve">
          <source>Whereas a &lt;code&gt;PrintService&lt;/code&gt; connected to a physical printer can be reused, a &lt;code&gt;StreamPrintService&lt;/code&gt; connected to a stream cannot. The underlying &lt;code&gt;StreamPrintService&lt;/code&gt; may be disposed by the print system with the &lt;a href=&quot;streamprintservice#dispose--&quot;&gt;&lt;code&gt;dispose&lt;/code&gt;&lt;/a&gt; method before returning from the &lt;a href=&quot;docprintjob#print-javax.print.Doc-javax.print.attribute.PrintRequestAttributeSet-&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;DocPrintJob&lt;/code&gt; so that the print system knows this printer is no longer usable. This is equivalent to a physical printer going offline - permanently. Applications may supply a null print stream to create a queryable service. It is not valid to create a PrintJob for such a stream. Implementations which allocate resources on construction should examine the stream and may wish to only allocate resources if the stream is non-null.</source>
          <target state="translated">物理プリンターに接続された &lt;code&gt;PrintService&lt;/code&gt; は再利用できますが、ストリームに接続された &lt;code&gt;StreamPrintService&lt;/code&gt; は再利用できません。 &lt;code&gt;DocPrintJob&lt;/code&gt; の&lt;a href=&quot;docprintjob#print-javax.print.Doc-javax.print.attribute.PrintRequestAttributeSet-&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt;メソッドから戻る前に、基になる &lt;code&gt;StreamPrintService&lt;/code&gt; が&lt;a href=&quot;streamprintservice#dispose--&quot;&gt; &lt;code&gt;dispose&lt;/code&gt; &lt;/a&gt;メソッドを使用して印刷システムによって破棄されるため、印刷システムはこのプリンターが使用できなくなっていることを認識できます。これは、オフラインになっている物理的なプリンタに相当します-永久に。アプリケーションは、クエリ可能なサービスを作成するためにnull印刷ストリームを提供する場合があります。そのようなストリームに対してPrintJobを作成することは無効です。構築時にリソースを割り当てる実装はストリームを検査する必要があり、ストリームがnullでない場合にのみリソースを割り当てたい場合があります。</target>
        </trans-unit>
        <trans-unit id="68dfcf4573839943af330771499a40761c894968" translate="yes" xml:space="preserve">
          <source>Whereas these are not (reason in parentheses):</source>
          <target state="translated">一方、これらは(カッコの中の理由)ではありません。</target>
        </trans-unit>
        <trans-unit id="034389c570341c477b986ed7aab5d2ac27118931" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;waitForIdle&lt;/code&gt; is automatically called</source>
          <target state="translated">&lt;code&gt;waitForIdle&lt;/code&gt; が自動的に呼び出されるかどうか</target>
        </trans-unit>
        <trans-unit id="0787c7934fdfd663c379d9463c168a4a31331bbd" translate="yes" xml:space="preserve">
          <source>Whether C++-style comments are to be recognized and skipped.</source>
          <target state="translated">C++スタイルのコメントを認識してスキップするかどうか。</target>
        </trans-unit>
        <trans-unit id="e0848da24388d28c1afb73d61f7a7588fee7e498" translate="yes" xml:space="preserve">
          <source>Whether C-style comments are to be recognized and skipped.</source>
          <target state="translated">Cスタイルのコメントを認識してスキップするかどうか。</target>
        </trans-unit>
        <trans-unit id="3ce96c4b92120512de6ee705be9cc10faccd0e37" translate="yes" xml:space="preserve">
          <source>Whether a &lt;a href=&quot;tifftag&quot;&gt;&lt;code&gt;TIFFTag&lt;/code&gt;&lt;/a&gt; with tag number equal to &lt;code&gt;tagNumber&lt;/code&gt; is present in this &lt;code&gt;TIFFDirectory&lt;/code&gt;.</source>
          <target state="translated">かどうかを&lt;a href=&quot;tifftag&quot;&gt; &lt;code&gt;TIFFTag&lt;/code&gt; &lt;/a&gt;タグ番号とが等しい &lt;code&gt;tagNumber&lt;/code&gt; この中に存在する &lt;code&gt;TIFFDirectory&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="368fda18947ddfae823fba3ad12c0006e725b91a" translate="yes" xml:space="preserve">
          <source>Whether a byte buffer is direct or non-direct may be determined by invoking its &lt;a href=&quot;#isDirect()&quot;&gt;&lt;code&gt;isDirect&lt;/code&gt;&lt;/a&gt; method. This method is provided so that explicit buffer management can be done in performance-critical code.</source>
          <target state="translated">バイトバッファが直接か非直接かは、&lt;a href=&quot;#isDirect()&quot;&gt; &lt;code&gt;isDirect&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことで判断できます。このメソッドは、パフォーマンスが重要なコードで明示的なバッファー管理を実行できるようにするために提供されています。</target>
        </trans-unit>
        <trans-unit id="51a1385dc9a39d4da44928c4400ff21a87209713" translate="yes" xml:space="preserve">
          <source>Whether a byte buffer is direct or non-direct may be determined by invoking its &lt;a href=&quot;bytebuffer#isDirect--&quot;&gt;&lt;code&gt;isDirect&lt;/code&gt;&lt;/a&gt; method. This method is provided so that explicit buffer management can be done in performance-critical code.</source>
          <target state="translated">バイトバッファーが直接か非直接かは、その&lt;a href=&quot;bytebuffer#isDirect--&quot;&gt; &lt;code&gt;isDirect&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことで判断できます。このメソッドは、明示的なバッファ管理をパフォーマンス重視のコードで実行できるようにするために提供されています。</target>
        </trans-unit>
        <trans-unit id="76ac3d7ca9570e219636389efe4d99114c39fbb9" translate="yes" xml:space="preserve">
          <source>Whether a lock is exclusive or shared may be determined by invoking its &lt;a href=&quot;#isShared()&quot;&gt;&lt;code&gt;isShared&lt;/code&gt;&lt;/a&gt; method. Some platforms do not support shared locks, in which case a request for a shared lock is automatically converted into a request for an exclusive lock.</source>
          <target state="translated">ロックが排他的であるか共有であるかは、&lt;a href=&quot;#isShared()&quot;&gt; &lt;code&gt;isShared&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことで判断できます。一部のプラットフォームは共有ロックをサポートしていません。その場合、共有ロックの要求は自動的に排他ロックの要求に変換されます。</target>
        </trans-unit>
        <trans-unit id="059d74aa74a1f70698c412f2b1b1fb68c363877d" translate="yes" xml:space="preserve">
          <source>Whether a lock is exclusive or shared may be determined by invoking its &lt;a href=&quot;filelock#isShared--&quot;&gt;&lt;code&gt;isShared&lt;/code&gt;&lt;/a&gt; method. Some platforms do not support shared locks, in which case a request for a shared lock is automatically converted into a request for an exclusive lock.</source>
          <target state="translated">ロックが排他的であるか共有であるかは、その&lt;a href=&quot;filelock#isShared--&quot;&gt; &lt;code&gt;isShared&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことによって決定できます。一部のプラットフォームは共有ロックをサポートしていません。その場合、共有ロックのリクエストは自動的に排他ロックのリクエストに変換されます。</target>
        </trans-unit>
        <trans-unit id="ca6533c544c3a0529e57beea5f901c658d036545" translate="yes" xml:space="preserve">
          <source>Whether a particular component is or is not defined in an instance depends upon the type of the URI being represented. An absolute URI has a scheme component. An opaque URI has a scheme, a scheme-specific part, and possibly a fragment, but has no other components. A hierarchical URI always has a path (though it may be empty) and a scheme-specific-part (which at least contains the path), and may have any of the other components. If the authority component is present and is server-based then the host component will be defined and the user-information and port components may be defined.</source>
          <target state="translated">特定のコンポーネントがインスタンスで定義されているか、定義されていないかは、表現されるURIの型に依存します。絶対 URI はスキームコンポーネントを持つ。不透明なURIは、スキーム、スキーム固有の部分、そしておそらくフラグメントを持ちますが、他のコンポーネントを持ちません。階層型URIは常にパス(空であるかもしれないが)とスキー ム固有の部分(少なくともパスを含む)を持ち、他のコンポーネントのいずれかを持っていてもよい。authorityコンポーネントが存在し、サーバベースであれば、hostコンポーネントが定義され、 user-informationコンポーネントとportコンポーネントが定義されるかもしれない。</target>
        </trans-unit>
        <trans-unit id="b7b45add21d97d6f92bb3c58b9dd4adb30ed79cd" translate="yes" xml:space="preserve">
          <source>Whether a thread is a daemon thread</source>
          <target state="translated">スレッドがデーモンスレッドかどうか</target>
        </trans-unit>
        <trans-unit id="d404f71e4894750c15b6981c1f6ed118e11a813d" translate="yes" xml:space="preserve">
          <source>Whether a virtual machine has a console is dependent upon the underlying platform and also upon the manner in which the virtual machine is invoked. If the virtual machine is started from an interactive command line without redirecting the standard input and output streams then its console will exist and will typically be connected to the keyboard and display from which the virtual machine was launched. If the virtual machine is started automatically, for example by a background job scheduler, then it will typically not have a console.</source>
          <target state="translated">仮想マシンにコンソールがあるかどうかは、基盤となるプラットフォームと仮想マシンの起動方法に依存します。仮想マシンが標準の入力と出力ストリームをリダイレクトせずにインタラクティブなコマンドラインから起動された場合、そのコンソールは存在し、通常は仮想マシンが起動されたキーボードとディスプレイに接続されています。仮想マシンがバックグラウンドジョブスケジューラなどで自動的に起動された場合は、通常はコンソールはありません。</target>
        </trans-unit>
        <trans-unit id="7b2f8d65d541d32da6ac4db35fde558abe5bba9b" translate="yes" xml:space="preserve">
          <source>Whether aliases are case sensitive is implementation dependent. In order to avoid problems, it is recommended not to use aliases in a KeyStore that only differ in case.</source>
          <target state="translated">エイリアスが大文字小文字を区別するかどうかは実装に依存します。問題を避けるために、KeyStoreでは大文字と小文字の違いだけのエイリアスは使用しないことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="e459ddcf8add7fb4f45be0659b059f816d4f3a8a" translate="yes" xml:space="preserve">
          <source>Whether keystores are persistent, and the mechanisms used by the keystore if it is persistent, are not specified here. This allows use of a variety of techniques for protecting sensitive (e.g., private or secret) keys. Smart cards or other integrated cryptographic engines (SafeKeyper) are one option, and simpler mechanisms such as files may also be used (in a variety of formats).</source>
          <target state="translated">鍵ストアが永続的であるかどうか、および永続的である場合に鍵ストアが使用するメカニズムについては、ここでは指定しない。これにより、機密鍵(秘密鍵や秘密鍵など)を保護するための様々な技術を使用することができます。スマートカードや他の統合された暗号化エンジン(SafeKeyper)も選択肢の一つであり、ファイルのようなより単純なメカニズムも(様々な形式で)使用できる。</target>
        </trans-unit>
        <trans-unit id="839575dd0da2dbc62283eccad2a293850044e605" translate="yes" xml:space="preserve">
          <source>Whether line terminators are to be returned as tokens or treated as white space that merely separates tokens.</source>
          <target state="translated">ラインターミネータをトークンとして返すか、トークンを区切るだけのホワイトスペースとして扱うか。</target>
        </trans-unit>
        <trans-unit id="64009d2c9b3c4d0e007e474d4b10457e969ea24e" translate="yes" xml:space="preserve">
          <source>Whether new values can be written to the attribute.</source>
          <target state="translated">新しい値を属性に書き込めるかどうか。</target>
        </trans-unit>
        <trans-unit id="b03220d01de6d75c311d805bed01816711949222" translate="yes" xml:space="preserve">
          <source>Whether or not a channel is registered with one or more selectors may be determined by invoking the &lt;a href=&quot;#isRegistered()&quot;&gt;&lt;code&gt;isRegistered&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">チャネルが1つ以上のセレクターに登録されているかどうかは、&lt;a href=&quot;#isRegistered()&quot;&gt; &lt;code&gt;isRegistered&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことによって判別できます。</target>
        </trans-unit>
        <trans-unit id="ed0c61cf2fb7a55d68d476b3cbe4799a77c242a1" translate="yes" xml:space="preserve">
          <source>Whether or not a channel is registered with one or more selectors may be determined by invoking the &lt;a href=&quot;selectablechannel#isRegistered--&quot;&gt;&lt;code&gt;isRegistered&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">チャネルが1つ以上のセレクターに登録されているかどうかは、&lt;a href=&quot;selectablechannel#isRegistered--&quot;&gt; &lt;code&gt;isRegistered&lt;/code&gt; &lt;/a&gt;メソッドを呼び出すことで判断できます。</target>
        </trans-unit>
        <trans-unit id="0d4e0c74b1ca2cffb49ee764de91039c786dd2b9" translate="yes" xml:space="preserve">
          <source>Whether or not a file is available or may be created depends upon the underlying platform. Some platforms, in particular, allow a file to be opened for writing by only one &lt;code&gt;FileWriter&lt;/code&gt; (or other file-writing object) at a time. In such situations the constructors in this class will fail if the file involved is already open.</source>
          <target state="translated">ファイルが利用可能であるか、または作成できるかどうかは、基盤となるプラットフォームによって異なります。特に、一部のプラットフォームでは、一度に1つの &lt;code&gt;FileWriter&lt;/code&gt; （または他のファイル書き込みオブジェクト）のみが書き込み用にファイルを開くことができます。このような状況では、関連するファイルがすでに開いている場合、このクラスのコンストラクターは失敗します。</target>
        </trans-unit>
        <trans-unit id="ea35fdbb197a6d4bef3ff403fa57d76ec3b52a58" translate="yes" xml:space="preserve">
          <source>Whether or not a lock actually prevents another program from accessing the content of the locked region is system-dependent and therefore unspecified. The native file-locking facilities of some systems are merely</source>
          <target state="translated">ロックが実際に他のプログラムがロックされた領域のコンテンツにアクセスできないようにするかどうかは、システムに依存するため特定できません。いくつかのシステムのネイティブなファイルロック機能は、単に</target>
        </trans-unit>
        <trans-unit id="5484541c29643b9a5f36af7eafe3c332aef64933" translate="yes" xml:space="preserve">
          <source>Whether or not a read-write lock will improve performance over the use of a mutual exclusion lock depends on the frequency that the data is read compared to being modified, the duration of the read and write operations, and the contention for the data - that is, the number of threads that will try to read or write the data at the same time. For example, a collection that is initially populated with data and thereafter infrequently modified, while being frequently searched (such as a directory of some kind) is an ideal candidate for the use of a read-write lock. However, if updates become frequent then the data spends most of its time being exclusively locked and there is little, if any increase in concurrency. Further, if the read operations are too short the overhead of the read-write lock implementation (which is inherently more complex than a mutual exclusion lock) can dominate the execution cost, particularly as many read-write lock implementations still serialize all threads through a small section of code. Ultimately, only profiling and measurement will establish whether the use of a read-write lock is suitable for your application.</source>
          <target state="translated">読み書きロックが相互除外ロックを使用するよりもパフォーマンスを向上させるかどうかは、データが変更されるのと比較して読み込まれる頻度、読み書き操作の持続時間、データの競合、つまり同時にデータを読み書きしようとするスレッドの数に依存します。例えば、最初はデータで埋め尽くされていて、その後変更されることはほとんどなく、頻繁に検索されているコレクション(ある種のディレクトリなど)は、読み書きロックの使用には理想的な候補です。しかし、更新が頻繁に行われるようになると、データはほとんどの時間を排他的にロックされたままになり、同時実行性はほとんど向上しません。さらに、読み取り操作が短すぎる場合は、読み書きロック実装のオーバーヘッド(相互排除ロックよりも本質的に複雑です)が実行コストを支配する可能性があり、特に多くの読み書きロック実装ではコードの小さなセクションを通してすべてのスレッドをシリアル化しています。最終的には、読み書きロックの使用がアプリケーションに適しているかどうかは、プロファイリングと測定によってのみ判断できます。</target>
        </trans-unit>
        <trans-unit id="ab8f019130320385026e5dab14b4180991ab8cbe" translate="yes" xml:space="preserve">
          <source>Whether or not a selection operation blocks to wait for one or more channels to become ready, and if so for how long, is the only essential difference between the three selection methods.</source>
          <target state="translated">選択操作が 1 つ以上のチャンネルの準備が整うのを待つかどうかと、その場合はどのくらいの時間待つかが、3 つの選択方法の唯一の本質的な違いです。</target>
        </trans-unit>
        <trans-unit id="41ee46a746e75b2c44835c6bb604f840669e2531" translate="yes" xml:space="preserve">
          <source>Whether or not a thread writing bytes to a pipe will block until another thread reads those bytes, or some previously-written bytes, from the pipe is system-dependent and therefore unspecified. Many pipe implementations will buffer up to a certain number of bytes between the sink and source channels, but such buffering should not be assumed.</source>
          <target state="translated">パイプにバイトを書き込んだスレッドが、別のスレッドがそのバイトや以前に書き込んだバイトをパイプから読み出すまでブロックするかどうかは、システムに依存しているため特定されていません。多くのパイプ実装では、シンクチャンネルとソースチャンネルの間で一定数のバイト数までバッファリングを行いますが、そのようなバッファリングは想定すべきではありません。</target>
        </trans-unit>
        <trans-unit id="f1753321a954e7b513350ab852758250afb77bcc" translate="yes" xml:space="preserve">
          <source>Whether or not the border has rounded corners.</source>
          <target state="translated">ボーダーの角が丸くなっているかどうか。</target>
        </trans-unit>
        <trans-unit id="fefaa51af10ff6b34610a73fe360a147bd71b1e4" translate="yes" xml:space="preserve">
          <source>Whether or not the drawing buffer has been recently restored from a lost state.</source>
          <target state="translated">描画バッファが失われた状態から最近復旧したかどうか。</target>
        </trans-unit>
        <trans-unit id="4d74f9e48a7c981d657e06b3f4e62aa762abfdf7" translate="yes" xml:space="preserve">
          <source>Whether or not the drawing buffer was lost since the last call to &lt;code&gt;getDrawGraphics&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;getDrawGraphics&lt;/code&gt; の最後の呼び出し以降に描画バッファが失われたかどうか。</target>
        </trans-unit>
        <trans-unit id="b46af6682380966e3f1a4318992d86f116b4966b" translate="yes" xml:space="preserve">
          <source>Whether or not the drawing buffer was restored since the last call to &lt;code&gt;getDrawGraphics&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;getDrawGraphics&lt;/code&gt; の最後の呼び出し以降に描画バッファが復元されたかどうか。</target>
        </trans-unit>
        <trans-unit id="dfcdb3967632f01437df753633766fd60adb3757" translate="yes" xml:space="preserve">
          <source>Whether or not the lead anchor notification is enabled.</source>
          <target state="translated">リードアンカー通知が有効になっているかどうか。</target>
        </trans-unit>
        <trans-unit id="b67aae029276f7596e2d6a2c6bdefef7f78062c8" translate="yes" xml:space="preserve">
          <source>Whether or not the returned key is trusted and the mechanisms used to determine that is implementation-specific.</source>
          <target state="translated">返された鍵が信頼されているかどうかと、それを判断するために使用されるメカニズムは、実装固有のものです。</target>
        </trans-unit>
        <trans-unit id="882147ddaf8db0c13715bcfc2446b83df5e1174d" translate="yes" xml:space="preserve">
          <source>Whether or not the root component of this path starts with the root component of the given path is file system specific. If this path does not have a root component and the given path has a root component then this path does not start with the given path.</source>
          <target state="translated">このパスのルートコンポーネントが、与えられたパスのルートコンポーネントで始まるかどうかは、ファイルシステム固有のものです。このパスがルートコンポーネントを持たず、与えられたパスがルートコンポーネントを持つ場合、このパスは与えられたパスでは始まらない。</target>
        </trans-unit>
        <trans-unit id="5561b885c61970439f8e8ab1f7452ebbd54f6012" translate="yes" xml:space="preserve">
          <source>Whether or not the views are continuously redisplayed while resizing.</source>
          <target state="translated">リサイズ中にビューが連続して再表示されるかどうか。</target>
        </trans-unit>
        <trans-unit id="8d8dadabe9f784b22272f65c7af34baa4ecf3fe7" translate="yes" xml:space="preserve">
          <source>Whether or not this is equal to the argument.</source>
          <target state="translated">これが議論に等しいかどうか。</target>
        </trans-unit>
        <trans-unit id="2c8782dc43c139a892cf9eca05fb5d76826e3adf" translate="yes" xml:space="preserve">
          <source>Whether or not two path are equal depends on the file system implementation. In some cases the paths are compared without regard to case, and others are case sensitive. This method does not access the file system and the file is not required to exist. Where required, the &lt;a href=&quot;files#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt;&lt;code&gt;isSameFile&lt;/code&gt;&lt;/a&gt; method may be used to check if two paths locate the same file.</source>
          <target state="translated">2つのパスが等しいかどうかは、ファイルシステムの実装によって異なります。大文字と小文字を区別せずにパスが比較される場合もあれば、大文字と小文字が区別される場合もあります。このメソッドはファイルシステムにアクセスせず、ファイルが存在する必要はありません。必要に応じて、&lt;a href=&quot;files#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt; &lt;code&gt;isSameFile&lt;/code&gt; &lt;/a&gt;メソッドを使用して、2つのパスが同じファイルを見つけているかどうかを確認できます。</target>
        </trans-unit>
        <trans-unit id="8370dbb2c98105665a87fe7a4451e4d08277efed" translate="yes" xml:space="preserve">
          <source>Whether or not two path are equal depends on the file system implementation. In some cases the paths are compared without regard to case, and others are case sensitive. This method does not access the file system and the file is not required to exist. Where required, the &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt;&lt;code&gt;isSameFile&lt;/code&gt;&lt;/a&gt; method may be used to check if two paths locate the same file.</source>
          <target state="translated">2つのパスが等しいかどうかは、ファイルシステムの実装によって異なります。パスは大文字と小文字を区別せずに比較される場合と、大文字と小文字を区別する場合があります。このメソッドはファイルシステムにアクセスせず、ファイルが存在する必要はありません。必要な場合は、&lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt; &lt;code&gt;isSameFile&lt;/code&gt; &lt;/a&gt;メソッドを使用して、2つのパスが同じファイルを見つけるかどうかを確認できます。</target>
        </trans-unit>
        <trans-unit id="8284d3a1a8d812ad6669b46283821c095c0da402" translate="yes" xml:space="preserve">
          <source>Whether the characters of identifiers are converted to lowercase.</source>
          <target state="translated">識別子の文字を小文字に変換するかどうか。</target>
        </trans-unit>
        <trans-unit id="8cb35ed334e6abf3cc5d46cfafbdff505f970f2b" translate="yes" xml:space="preserve">
          <source>Whether the checks for Java language access control can be suppressed (and thus, whether access can be enabled) depends on whether the reflected object corresponds to a member in an exported or open package (see &lt;a href=&quot;#setAccessible(boolean)&quot;&gt;&lt;code&gt;setAccessible(boolean)&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Java言語のアクセス制御のチェックを抑制できるかどうか（したがって、アクセスを有効にできるかどうか）は、反映されたオブジェクトがエクスポートされたパッケージまたは開いているパッケージのメンバーに対応するかどうかによって異なります（&lt;a href=&quot;#setAccessible(boolean)&quot;&gt; &lt;code&gt;setAccessible(boolean)&lt;/code&gt; を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="abed7ebf656d855109885e2ad219cda0e430ff8f" translate="yes" xml:space="preserve">
          <source>Whether the directory is traversable or not.</source>
          <target state="translated">ディレクトリがトラバース可能かどうか。</target>
        </trans-unit>
        <trans-unit id="9f7b655899be35706a060ba063ac17985c822863" translate="yes" xml:space="preserve">
          <source>Whether the directory is traversable or not. This might be useful, for example, if you want a directory to represent a compound document and don't want the user to descend into it.</source>
          <target state="translated">ディレクトリがトラバース可能かどうか。これは、例えば、複合文書を表すディレクトリを作成したいが、ユーザがそこに降りてこないようにしたい場合などに便利かもしれません。</target>
        </trans-unit>
        <trans-unit id="72bdf44965cf1882a7b82e577ba831bb4aa3aad8" translate="yes" xml:space="preserve">
          <source>Whether the effect of sheet collation is achieved by placing copies of a document in multiple output bins or in the same output bin with implementation defined document separation is implementation dependent. Also whether it is achieved by making multiple passes over the job or by using an output sorter is implementation dependent.</source>
          <target state="translated">シート照合の効果が、複数の出力ビンに文書のコピーを配置することによって達成されるか、あるいは実装で定義された文書分離を用いて同じ出力ビンに配置することによって達成されるかは、実装に依存する。また、ジョブを複数回通過させることによって達成されるか、出力ソータを使用することによって達成されるかは、実装に依存します。</target>
        </trans-unit>
        <trans-unit id="80415a2402a1eeb4d1614afdc0790cc2cd751eb2" translate="yes" xml:space="preserve">
          <source>Whether the field type is integral.</source>
          <target state="translated">フィールドタイプが積分型であるかどうか。</target>
        </trans-unit>
        <trans-unit id="0d0d9b917bd4457293707b233fdfaf38f800ca2f" translate="yes" xml:space="preserve">
          <source>Whether the given file is accepted by this filter.</source>
          <target state="translated">与えられたファイルがこのフィルタに受け入れられるかどうか。</target>
        </trans-unit>
        <trans-unit id="0b221a5fcef637ecf18d19b895618107e0ec7d34" translate="yes" xml:space="preserve">
          <source>Whether the progress bar is horizontal or vertical.</source>
          <target state="translated">プログレスバーが水平か垂直か</target>
        </trans-unit>
        <trans-unit id="a6d6a865c13d64eec6f0217eba676663f0999299" translate="yes" xml:space="preserve">
          <source>Whether the progress bar is horizontal or vertical. The default is &lt;code&gt;HORIZONTAL&lt;/code&gt;.</source>
          <target state="translated">プログレスバーが水平か垂直か。デフォルトは &lt;code&gt;HORIZONTAL&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d07e8763f02114da7e0c71037a504961880c1abb" translate="yes" xml:space="preserve">
          <source>Whether the slider is horizontal or vertical The default is horizontal.</source>
          <target state="translated">スライダーが水平か垂直か デフォルトは水平です。</target>
        </trans-unit>
        <trans-unit id="b500b42f712219c24a8bd54914f1fa1b4e445284" translate="yes" xml:space="preserve">
          <source>Whether the value of the attribute can be read.</source>
          <target state="translated">属性の値を読み込めるかどうか。</target>
        </trans-unit>
        <trans-unit id="d7db98311d27050f8bbb866412a5ea00983c801f" translate="yes" xml:space="preserve">
          <source>Whether to display a border around the progress bar.</source>
          <target state="translated">プログレスバーの周りにボーダーを表示するかどうか。</target>
        </trans-unit>
        <trans-unit id="0d7eb02de3d8787df6eadd74e0b934899bf8467f" translate="yes" xml:space="preserve">
          <source>Whether to display a border around the progress bar. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">プログレスバーの周囲に境界線を表示するかどうか。デフォルトは &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="7bb449420de50b1f70b9cf8aa6735bcb426d5e7f" translate="yes" xml:space="preserve">
          <source>Whether to display a string of text on the progress bar.</source>
          <target state="translated">プログレスバーに文字列を表示するかどうか。</target>
        </trans-unit>
        <trans-unit id="6ce38cd557d077996b81c259fa55fc8d873bb920" translate="yes" xml:space="preserve">
          <source>Whether to display a string of text on the progress bar. The default is &lt;code&gt;false&lt;/code&gt;. Setting this to &lt;code&gt;true&lt;/code&gt; causes a textual display of the progress to be rendered on the progress bar. If the &lt;code&gt;progressString&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the percentage of completion is displayed on the progress bar. Otherwise, the &lt;code&gt;progressString&lt;/code&gt; is rendered on the progress bar.</source>
          <target state="translated">プログレスバーにテキストの文字列を表示するかどうか。デフォルトは &lt;code&gt;false&lt;/code&gt; です。これを &lt;code&gt;true&lt;/code&gt; に設定すると、進行状況のテキスト表示が進行状況バーに表示されます。 &lt;code&gt;progressString&lt;/code&gt; が &lt;code&gt;null&lt;/code&gt; の場合、完了率が進行状況バーに表示されます。それ以外の場合、 &lt;code&gt;progressString&lt;/code&gt; はプログレスバーに表示されます。</target>
        </trans-unit>
        <trans-unit id="49449561f235eb64ebabd8dfba321eb0bf01fd39" translate="yes" xml:space="preserve">
          <source>Whether to read fields of unrecognized tags</source>
          <target state="translated">認識されていないタグのフィールドを読み込むかどうか</target>
        </trans-unit>
        <trans-unit id="2f2f17106f12b2db4361609c9dfa05eb46f32c85" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;CompositeView&lt;/code&gt; does not impose a layout policy on its child &lt;code&gt;View&lt;/code&gt;s, it does allow for inseting the child &lt;code&gt;View&lt;/code&gt;s it will contain. The insets can be set by either &lt;a href=&quot;#setInsets(short,short,short,short)&quot;&gt;&lt;code&gt;setInsets(short, short, short, short)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#setParagraphInsets(javax.swing.text.AttributeSet)&quot;&gt;&lt;code&gt;setParagraphInsets(javax.swing.text.AttributeSet)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一方で &lt;code&gt;CompositeView&lt;/code&gt; のは、その子の上にレイアウトポリシーを課していない &lt;code&gt;View&lt;/code&gt; の、それは子供insetingも認めていません &lt;code&gt;View&lt;/code&gt; は、それが含まれていますよと。インセットは、&lt;a href=&quot;#setInsets(short,short,short,short)&quot;&gt; &lt;code&gt;setInsets(short, short, short, short)&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#setParagraphInsets(javax.swing.text.AttributeSet)&quot;&gt; &lt;code&gt;setParagraphInsets(javax.swing.text.AttributeSet)&lt;/code&gt; の&lt;/a&gt;いずれかで設定できます。</target>
        </trans-unit>
        <trans-unit id="1c42976582ea88cec97c24e4c0d10841777ac466" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;Deque&lt;/code&gt; implementations are not strictly required to prohibit the insertion of null elements, they are strongly encouraged to do so. Users of any &lt;code&gt;Deque&lt;/code&gt; implementations that do allow null elements are strongly encouraged</source>
          <target state="translated">一方で &lt;code&gt;Deque&lt;/code&gt; 実装は厳密にはnull要素の挿入を禁止する必要はありません、彼らは強くそうするよう奨励されています。null要素を許可する &lt;code&gt;Deque&lt;/code&gt; 実装のユーザーは強く推奨されます</target>
        </trans-unit>
        <trans-unit id="3d6ef8f821513dcce4a530375fb519e3029c0687" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;TreePath&lt;/code&gt; is serializable, a &lt;code&gt;
 NotSerializableException&lt;/code&gt; is thrown if any elements of the path are not serializable.</source>
          <target state="translated">ながら &lt;code&gt;TreePath&lt;/code&gt; 直列化可能である、 &lt;code&gt; NotSerializableException&lt;/code&gt; パスのいずれかの要素が直列化可能でない場合にスローされます。</target>
        </trans-unit>
        <trans-unit id="51c173ac8703a05aa36fea05d64c73f4930ea483" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;dropWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt;&lt;code&gt;generate(DoubleSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">一方で &lt;code&gt;dropWhile()&lt;/code&gt; は、一般的に順次ストリームパイプライン上の安い操作であり、それは操作がないだけで任意の有効な接頭辞が、出会いのための要素の最長プレフィックスを返すように制約されているので、注文した並列パイプラインには非常に高価になることができます。順序付けされていないストリームソース（&lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt; &lt;code&gt;generate(DoubleSupplier)&lt;/code&gt; など&lt;/a&gt;）を使用するか、&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; で&lt;/a&gt;順序付け制約を削除すると、状況のセマンティクスが許せば、並列パイプラインで &lt;code&gt;dropWhile()&lt;/code&gt; が大幅に高速化される可能性があります。遭遇順序との一貫性が必要であり、並列パイプラインで &lt;code&gt;dropWhile()&lt;/code&gt; を使用するとパフォーマンスやメモリ使用率が低下する場合は、次のコマンドを使用して順次実行に切り替えます。&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;は、パフォーマンスを向上させる可能性があります。</target>
        </trans-unit>
        <trans-unit id="dd08eb3b81d66f20546d1029c826ea0fbe16bd34" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;dropWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt;&lt;code&gt;generate(IntSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">一方で &lt;code&gt;dropWhile()&lt;/code&gt; は、一般的に順次ストリームパイプライン上の安い操作であり、それは操作がないだけで任意の有効な接頭辞が、出会いのための要素の最長プレフィックスを返すように制約されているので、注文した並列パイプラインには非常に高価になることができます。順序付けされていないストリームソース（&lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt; &lt;code&gt;generate(IntSupplier)&lt;/code&gt; など&lt;/a&gt;）を使用するか、&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; で&lt;/a&gt;順序付け制約を削除すると、状況のセマンティクスが許せば、並列パイプラインで &lt;code&gt;dropWhile()&lt;/code&gt; が大幅に高速化される可能性があります。遭遇順序との一貫性が必要であり、並列パイプラインで &lt;code&gt;dropWhile()&lt;/code&gt; を使用するとパフォーマンスやメモリ使用率が低下する場合は、次のコマンドを使用して順次実行に切り替えます。&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;は、パフォーマンスを向上させる可能性があります。</target>
        </trans-unit>
        <trans-unit id="58a60decffcb60cd8818f4e94cb70dfd3ab19008" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;dropWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt;&lt;code&gt;generate(LongSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">一方で &lt;code&gt;dropWhile()&lt;/code&gt; は、一般的に順次ストリームパイプライン上の安い操作であり、それは操作がないだけで任意の有効な接頭辞が、出会いのための要素の最長プレフィックスを返すように制約されているので、注文した並列パイプラインには非常に高価になることができます。順序付けされていないストリームソース（&lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt; &lt;code&gt;generate(LongSupplier)&lt;/code&gt; など&lt;/a&gt;）を使用するか、&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; で&lt;/a&gt;順序付け制約を削除すると、状況のセマンティクスが許せば、並列パイプラインで &lt;code&gt;dropWhile()&lt;/code&gt; が大幅に高速化される可能性があります。遭遇順序との一貫性が必要であり、並列パイプラインで &lt;code&gt;dropWhile()&lt;/code&gt; を使用するとパフォーマンスやメモリ使用率が低下する場合は、次のコマンドを使用して順次実行に切り替えます。&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;は、パフォーマンスを向上させる可能性があります。</target>
        </trans-unit>
        <trans-unit id="15a29b609ce06935cf71396d9bc3de52f946081d" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;dropWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt;&lt;code&gt;generate(Supplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">一方で &lt;code&gt;dropWhile()&lt;/code&gt; は、一般的に順次ストリームパイプライン上の安い操作であり、それは操作がないだけで任意の有効な接頭辞が、出会いのための要素の最長プレフィックスを返すように制約されているので、注文した並列パイプラインには非常に高価になることができます。順序付けされていないストリームソース（&lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt; &lt;code&gt;generate(Supplier)&lt;/code&gt; など&lt;/a&gt;）を使用するか、&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; で&lt;/a&gt;順序付け制約を削除すると、状況のセマンティクスが許せば、並列パイプラインで &lt;code&gt;dropWhile()&lt;/code&gt; が大幅に高速化される可能性があります。遭遇順序との一貫性が必要であり、並列パイプラインで &lt;code&gt;dropWhile()&lt;/code&gt; を使用するとパフォーマンスやメモリ使用率が低下する場合は、次のコマンドを使用して順次実行に切り替えます。&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;は、パフォーマンスを向上させる可能性があります。</target>
        </trans-unit>
        <trans-unit id="f8bebbe990bf762b2089ef58b873ffcb3559acbd" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt;&lt;code&gt;generate(DoubleSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">ながら &lt;code&gt;limit()&lt;/code&gt; 、一般的にシーケンシャルストリームパイプラインに安価操作である、それは特に大きな値に対して、順序付けられた並列パイプラインに非常に高価であることができる &lt;code&gt;maxSize&lt;/code&gt; のため、 &lt;code&gt;limit(n)&lt;/code&gt; ないだけ任意返すように制約される&lt;em&gt;n個の&lt;/em&gt;要素が、&lt;em&gt;最初のn個&lt;/em&gt;遭遇順序の要素。順序付けされていないストリームソース（&lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt; &lt;code&gt;generate(DoubleSupplier)&lt;/code&gt; など&lt;/a&gt;）を使用するか、&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; で&lt;/a&gt;順序付け制約を削除すると、limit（）が大幅に高速化される場合があり &lt;code&gt;limit()&lt;/code&gt; 状況のセマンティクスが許せば、並列パイプラインで。遭遇順序との整合性が必要であり、並列パイプラインで &lt;code&gt;limit()&lt;/code&gt; を使用するとパフォーマンスが低下したり、メモリ使用率が低下したりする場合は、&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;を使用して順次実行に切り替えるとパフォーマンスが向上する可能性があります。</target>
        </trans-unit>
        <trans-unit id="fae011e82778ef6bc326d638878e4e4eb7c86dc3" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt;&lt;code&gt;generate(IntSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">ながら &lt;code&gt;limit()&lt;/code&gt; 、一般的にシーケンシャルストリームパイプラインに安価操作である、それは特に大きな値に対して、順序付けられた並列パイプラインに非常に高価であることができる &lt;code&gt;maxSize&lt;/code&gt; のため、 &lt;code&gt;limit(n)&lt;/code&gt; ないだけ任意返すように制約される&lt;em&gt;n個の&lt;/em&gt;要素が、&lt;em&gt;最初のn個&lt;/em&gt;遭遇順序の要素。順序付けされていないストリームソース（&lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt; &lt;code&gt;generate(IntSupplier)&lt;/code&gt; など&lt;/a&gt;）を使用するか、&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; で&lt;/a&gt;順序付け制約を削除すると、limit（）が大幅に高速化される場合があり &lt;code&gt;limit()&lt;/code&gt; 状況のセマンティクスが許せば、並列パイプラインで。遭遇順序との整合性が必要であり、並列パイプラインで &lt;code&gt;limit()&lt;/code&gt; を使用するとパフォーマンスが低下したり、メモリ使用率が低下したりする場合は、&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;を使用して順次実行に切り替えるとパフォーマンスが向上する可能性があります。</target>
        </trans-unit>
        <trans-unit id="52357540a609522f143b04a6d7f5344f0cb8965b" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt;&lt;code&gt;generate(LongSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">ながら &lt;code&gt;limit()&lt;/code&gt; 、一般的にシーケンシャルストリームパイプラインに安価操作である、それは特に大きな値に対して、順序付けられた並列パイプラインに非常に高価であることができる &lt;code&gt;maxSize&lt;/code&gt; のため、 &lt;code&gt;limit(n)&lt;/code&gt; ないだけ任意返すように制約される&lt;em&gt;n個の&lt;/em&gt;要素が、&lt;em&gt;最初のn個&lt;/em&gt;遭遇順序の要素。順序付けされていないストリームソース（&lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt; &lt;code&gt;generate(LongSupplier)&lt;/code&gt; など&lt;/a&gt;）を使用するか、&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; で&lt;/a&gt;順序付け制約を削除すると、limit（）が大幅に高速化される場合があり &lt;code&gt;limit()&lt;/code&gt; 状況のセマンティクスが許せば、並列パイプラインで。遭遇順序との整合性が必要であり、並列パイプラインで &lt;code&gt;limit()&lt;/code&gt; を使用するとパフォーマンスが低下したり、メモリ使用率が低下したりする場合は、&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;を使用して順次実行に切り替えるとパフォーマンスが向上する可能性があります。</target>
        </trans-unit>
        <trans-unit id="5292e16f7d0f56673e81e44acea4610d6162687f" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt;&lt;code&gt;generate(Supplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">ながら &lt;code&gt;limit()&lt;/code&gt; 、一般的にシーケンシャルストリームパイプラインに安価操作である、それは特に大きな値に対して、順序付けられた並列パイプラインに非常に高価であることができる &lt;code&gt;maxSize&lt;/code&gt; のため、 &lt;code&gt;limit(n)&lt;/code&gt; ないだけ任意返すように制約される&lt;em&gt;n個の&lt;/em&gt;要素が、&lt;em&gt;最初のn個&lt;/em&gt;遭遇順序の要素。順序付けされていないストリームソース（&lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt; &lt;code&gt;generate(Supplier)&lt;/code&gt; など&lt;/a&gt;）を使用するか、&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; で&lt;/a&gt;順序付け制約を削除すると、limit（）が大幅に高速化される場合があり &lt;code&gt;limit()&lt;/code&gt; 状況のセマンティクスが許せば、並列パイプラインで。遭遇順序との整合性が必要であり、並列パイプラインで &lt;code&gt;limit()&lt;/code&gt; を使用するとパフォーマンスが低下したり、メモリ使用率が低下したりする場合は、&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;を使用して順次実行に切り替えるとパフォーマンスが向上する可能性があります。</target>
        </trans-unit>
        <trans-unit id="c116ddf414b394a7666553a5a6b566a1451776ab" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;doublestream#generate-java.util.function.DoubleSupplier-&quot;&gt;&lt;code&gt;generate(DoubleSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;doublestream#sequential--&quot;&gt;&lt;code&gt;sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">ながら &lt;code&gt;limit()&lt;/code&gt; 、一般的にシーケンシャルストリームパイプラインに安価操作である、それは特に大きな値に対して、順序付けられた並列パイプラインに非常に高価であることができる &lt;code&gt;maxSize&lt;/code&gt; のため、 &lt;code&gt;limit(n)&lt;/code&gt; ないだけ任意返すように制約される&lt;em&gt;n個の&lt;/em&gt;要素が、&lt;em&gt;最初のn個&lt;/em&gt;遭遇順序の要素。順序付けされていないストリームソース（&lt;a href=&quot;doublestream#generate-java.util.function.DoubleSupplier-&quot;&gt; &lt;code&gt;generate(DoubleSupplier)&lt;/code&gt; など&lt;/a&gt;）を使用するか、&lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; で&lt;/a&gt;順序付けの制約を削除すると、limit（）が大幅に高速化する可能性があり &lt;code&gt;limit()&lt;/code&gt; 状況のセマンティクスが許せば、並列パイプラインで。遭遇順序との整合性が必要であり、並列パイプラインで &lt;code&gt;limit()&lt;/code&gt; を使用してパフォーマンスまたはメモリ使用率が低下している場合、&lt;a href=&quot;doublestream#sequential--&quot;&gt; &lt;code&gt;sequential()&lt;/code&gt; を使用&lt;/a&gt;して順次実行に切り替えると、パフォーマンスが向上する場合があります。</target>
        </trans-unit>
        <trans-unit id="07ed1f5d7e24e0c78296347da906a9d60feefd38" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;intstream#generate-java.util.function.IntSupplier-&quot;&gt;&lt;code&gt;generate(IntSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;intstream#sequential--&quot;&gt;&lt;code&gt;sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">ながら &lt;code&gt;limit()&lt;/code&gt; 、一般的にシーケンシャルストリームパイプラインに安価操作である、それは特に大きな値に対して、順序付けられた並列パイプラインに非常に高価であることができる &lt;code&gt;maxSize&lt;/code&gt; のため、 &lt;code&gt;limit(n)&lt;/code&gt; ないだけ任意返すように制約される&lt;em&gt;n個の&lt;/em&gt;要素が、&lt;em&gt;最初のn個&lt;/em&gt;遭遇順序の要素。順序付けされていないストリームソース（&lt;a href=&quot;intstream#generate-java.util.function.IntSupplier-&quot;&gt; &lt;code&gt;generate(IntSupplier)&lt;/code&gt; など&lt;/a&gt;）を使用するか、&lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; で&lt;/a&gt;順序付けの制約を削除すると、limit（）が大幅に高速化する可能性があり &lt;code&gt;limit()&lt;/code&gt; 状況のセマンティクスが許せば、並列パイプラインで。遭遇順序との整合性が必要であり、並列パイプラインで &lt;code&gt;limit()&lt;/code&gt; を使用してパフォーマンスまたはメモリ使用率が低下している場合、&lt;a href=&quot;intstream#sequential--&quot;&gt; &lt;code&gt;sequential()&lt;/code&gt; を使用&lt;/a&gt;して順次実行に切り替えると、パフォーマンスが向上する場合があります。</target>
        </trans-unit>
        <trans-unit id="50f1dd72f901eaef160af7e84d23600d1ebf7971" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;longstream#generate-java.util.function.LongSupplier-&quot;&gt;&lt;code&gt;generate(LongSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;longstream#sequential--&quot;&gt;&lt;code&gt;sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">ながら &lt;code&gt;limit()&lt;/code&gt; 、一般的にシーケンシャルストリームパイプラインに安価操作である、それは特に大きな値に対して、順序付けられた並列パイプラインに非常に高価であることができる &lt;code&gt;maxSize&lt;/code&gt; のため、 &lt;code&gt;limit(n)&lt;/code&gt; ないだけ任意返すように制約される&lt;em&gt;n個の&lt;/em&gt;要素が、&lt;em&gt;最初のn個&lt;/em&gt;遭遇順序の要素。順序付けされていないストリームソース（&lt;a href=&quot;longstream#generate-java.util.function.LongSupplier-&quot;&gt; &lt;code&gt;generate(LongSupplier)&lt;/code&gt; など&lt;/a&gt;）を使用するか、&lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; で&lt;/a&gt;順序付け制約を削除すると、limit（）が大幅に高速化される可能性があり &lt;code&gt;limit()&lt;/code&gt; 状況のセマンティクスが許せば、並列パイプラインで。遭遇順序との整合性が必要であり、並列パイプラインで &lt;code&gt;limit()&lt;/code&gt; を使用してパフォーマンスまたはメモリ使用率が低下している場合、&lt;a href=&quot;longstream#sequential--&quot;&gt; &lt;code&gt;sequential()&lt;/code&gt; を使用&lt;/a&gt;して順次実行に切り替えると、パフォーマンスが向上する場合があります。</target>
        </trans-unit>
        <trans-unit id="e7b022b1174615a655ebcf28b81dbf48a9f1556b" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;stream#generate-java.util.function.Supplier-&quot;&gt;&lt;code&gt;generate(Supplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential--&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">ながら &lt;code&gt;limit()&lt;/code&gt; 、一般的にシーケンシャルストリームパイプラインに安価操作である、それは特に大きな値に対して、順序付けられた並列パイプラインに非常に高価であることができる &lt;code&gt;maxSize&lt;/code&gt; のため、 &lt;code&gt;limit(n)&lt;/code&gt; ないだけ任意返すように制約される&lt;em&gt;n個の&lt;/em&gt;要素が、&lt;em&gt;最初のn個&lt;/em&gt;遭遇順序の要素。順序付けされていないストリームソース（&lt;a href=&quot;stream#generate-java.util.function.Supplier-&quot;&gt; &lt;code&gt;generate(Supplier)&lt;/code&gt; など&lt;/a&gt;）を使用するか、&lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; で&lt;/a&gt;順序付け制約を削除すると、limit（）が大幅に高速化される場合があり &lt;code&gt;limit()&lt;/code&gt; 状況のセマンティクスが許せば、並列パイプラインで。遭遇順序との一貫性が必要で、並列パイプラインで &lt;code&gt;limit()&lt;/code&gt; を使用するとパフォーマンスまたはメモリ使用率が低下する場合は、&lt;a href=&quot;basestream#sequential--&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; で&lt;/a&gt;順次実行に切り替えるとパフォーマンスが向上する場合があります。</target>
        </trans-unit>
        <trans-unit id="7b87dc7fad8d14aab16d4ddc4f41ded925891b0e" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt;&lt;code&gt;generate(DoubleSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">しながら、 &lt;code&gt;skip()&lt;/code&gt; シーケンシャルストリームパイプラインに安い操作は、一般的に、これは特に大きな値のため、順序付けられた並列パイプラインに非常に高価であることができる &lt;code&gt;n&lt;/code&gt; ので、 &lt;code&gt;skip(n)&lt;/code&gt; ないだけ任意スキップするように制約される&lt;em&gt;n個の&lt;/em&gt;要素が、&lt;em&gt;最初のnは&lt;/em&gt;遭遇順序の要素。順序付けされていないストリームソース（&lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt; &lt;code&gt;generate(DoubleSupplier)&lt;/code&gt; など&lt;/a&gt;）を使用するか、&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; で&lt;/a&gt;順序付け制約を削除すると、状況のセマンティクスが許せば、並列パイプラインで &lt;code&gt;skip()&lt;/code&gt; が大幅に高速化される可能性があります。遭遇順序との整合性が必要であり、パフォーマンスまたはメモリ使用率が低下している場合 &lt;code&gt;skip()&lt;/code&gt; 並列パイプラインのskip（）で、&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;を使用して順次実行に切り替えると、パフォーマンスが向上する場合があります。</target>
        </trans-unit>
        <trans-unit id="fd851600c5d344782f73398b78b6e28503994a09" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt;&lt;code&gt;generate(IntSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">しながら、 &lt;code&gt;skip()&lt;/code&gt; シーケンシャルストリームパイプラインに安い操作は、一般的に、これは特に大きな値のため、順序付けられた並列パイプラインに非常に高価であることができる &lt;code&gt;n&lt;/code&gt; ので、 &lt;code&gt;skip(n)&lt;/code&gt; ないだけ任意スキップするように制約される&lt;em&gt;n個の&lt;/em&gt;要素が、&lt;em&gt;最初のnは&lt;/em&gt;遭遇順序の要素。順序付けされていないストリームソース（&lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt; &lt;code&gt;generate(IntSupplier)&lt;/code&gt; など&lt;/a&gt;）を使用するか、&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; で&lt;/a&gt;順序付け制約を削除すると、状況のセマンティクスが許せば、並列パイプラインで &lt;code&gt;skip()&lt;/code&gt; が大幅に高速化される可能性があります。遭遇順序との整合性が必要であり、パフォーマンスまたはメモリ使用率が低下している場合 &lt;code&gt;skip()&lt;/code&gt; 並列パイプラインのskip（）で、&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;を使用して順次実行に切り替えると、パフォーマンスが向上する場合があります。</target>
        </trans-unit>
        <trans-unit id="a33a9aba4905d83925c9ee06f4fa960c35c02c78" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt;&lt;code&gt;generate(LongSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">しながら、 &lt;code&gt;skip()&lt;/code&gt; シーケンシャルストリームパイプラインに安い操作は、一般的に、これは特に大きな値のため、順序付けられた並列パイプラインに非常に高価であることができる &lt;code&gt;n&lt;/code&gt; ので、 &lt;code&gt;skip(n)&lt;/code&gt; ないだけ任意スキップするように制約される&lt;em&gt;n個の&lt;/em&gt;要素が、&lt;em&gt;最初のnは&lt;/em&gt;遭遇順序の要素。順序付けされていないストリームソース（&lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt; &lt;code&gt;generate(LongSupplier)&lt;/code&gt; など&lt;/a&gt;）を使用するか、&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; で&lt;/a&gt;順序付け制約を削除すると、状況のセマンティクスが許せば、並列パイプラインで &lt;code&gt;skip()&lt;/code&gt; が大幅に高速化される可能性があります。遭遇順序との整合性が必要であり、パフォーマンスまたはメモリ使用率が低下している場合 &lt;code&gt;skip()&lt;/code&gt; 並列パイプラインのskip（）で、&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;を使用して順次実行に切り替えると、パフォーマンスが向上する場合があります。</target>
        </trans-unit>
        <trans-unit id="2b0b2ed9d6a481a9b272dda6c65ea3e9ae7c5297" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt;&lt;code&gt;generate(Supplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">しながら、 &lt;code&gt;skip()&lt;/code&gt; シーケンシャルストリームパイプラインに安い操作は、一般的に、これは特に大きな値のため、順序付けられた並列パイプラインに非常に高価であることができる &lt;code&gt;n&lt;/code&gt; ので、 &lt;code&gt;skip(n)&lt;/code&gt; ないだけ任意スキップするように制約される&lt;em&gt;n個の&lt;/em&gt;要素が、&lt;em&gt;最初のnは&lt;/em&gt;遭遇順序の要素。順序付けされていないストリームソース（&lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt; &lt;code&gt;generate(Supplier)&lt;/code&gt; など&lt;/a&gt;）を使用するか、&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; で&lt;/a&gt;順序付け制約を削除すると、状況のセマンティクスが許せば、並列パイプラインで &lt;code&gt;skip()&lt;/code&gt; が大幅に高速化される可能性があります。遭遇順序との整合性が必要であり、パフォーマンスまたはメモリ使用率が低下している場合 &lt;code&gt;skip()&lt;/code&gt; 並列パイプラインのskip（）で、&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;を使用して順次実行に切り替えると、パフォーマンスが向上する場合があります。</target>
        </trans-unit>
        <trans-unit id="74d731aa21902009fd224b6c3c7d21287ffacde8" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;doublestream#generate-java.util.function.DoubleSupplier-&quot;&gt;&lt;code&gt;generate(DoubleSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;doublestream#sequential--&quot;&gt;&lt;code&gt;sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">しながら、 &lt;code&gt;skip()&lt;/code&gt; シーケンシャルストリームパイプラインに安い操作は、一般的に、これは特に大きな値のため、順序付けられた並列パイプラインに非常に高価であることができる &lt;code&gt;n&lt;/code&gt; ので、 &lt;code&gt;skip(n)&lt;/code&gt; ないだけ任意スキップするように制約される&lt;em&gt;n個の&lt;/em&gt;要素が、&lt;em&gt;最初のnは&lt;/em&gt;遭遇順序の要素。順序付けられていないストリームソース（&lt;a href=&quot;doublestream#generate-java.util.function.DoubleSupplier-&quot;&gt; &lt;code&gt;generate(DoubleSupplier)&lt;/code&gt; など&lt;/a&gt;）を使用するか、&lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; で&lt;/a&gt;順序付けの制約を削除すると、状況のセマンティクスが許す場合、並列パイプラインで &lt;code&gt;skip()&lt;/code&gt; が大幅に高速化される可能性があります。エンカウンター順序との一貫性が必要で、パフォーマンスやメモリ使用率が低下している場合 &lt;code&gt;skip()&lt;/code&gt; 並列パイプラインでskip（）を使用し、&lt;a href=&quot;doublestream#sequential--&quot;&gt; &lt;code&gt;sequential()&lt;/code&gt; で&lt;/a&gt;順次実行に切り替えると、パフォーマンスが向上する場合があります。</target>
        </trans-unit>
        <trans-unit id="8b6aed4201bbc532174a6b1ac759cb47bf878a52" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;intstream#generate-java.util.function.IntSupplier-&quot;&gt;&lt;code&gt;generate(IntSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;intstream#sequential--&quot;&gt;&lt;code&gt;sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">しながら、 &lt;code&gt;skip()&lt;/code&gt; シーケンシャルストリームパイプラインに安い操作は、一般的に、これは特に大きな値のため、順序付けられた並列パイプラインに非常に高価であることができる &lt;code&gt;n&lt;/code&gt; ので、 &lt;code&gt;skip(n)&lt;/code&gt; ないだけ任意スキップするように制約される&lt;em&gt;n個の&lt;/em&gt;要素が、&lt;em&gt;最初のnは&lt;/em&gt;遭遇順序の要素。順序付けされていないストリームソース（&lt;a href=&quot;intstream#generate-java.util.function.IntSupplier-&quot;&gt; &lt;code&gt;generate(IntSupplier)&lt;/code&gt; など&lt;/a&gt;）を使用するか、&lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; で&lt;/a&gt;順序付け制約を削除すると、状況のセマンティクスが許す場合、並列パイプラインで &lt;code&gt;skip()&lt;/code&gt; が大幅に高速化される可能性があります。エンカウンター順序との一貫性が必要で、パフォーマンスやメモリ使用率が低下している場合 &lt;code&gt;skip()&lt;/code&gt; 並列パイプラインでskip（）を使用し、&lt;a href=&quot;intstream#sequential--&quot;&gt; &lt;code&gt;sequential()&lt;/code&gt; で&lt;/a&gt;順次実行に切り替えると、パフォーマンスが向上する場合があります。</target>
        </trans-unit>
        <trans-unit id="08e49b292a5f6675c12e6e8084622cb9a1123c41" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;longstream#generate-java.util.function.LongSupplier-&quot;&gt;&lt;code&gt;generate(LongSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;longstream#sequential--&quot;&gt;&lt;code&gt;sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">しながら、 &lt;code&gt;skip()&lt;/code&gt; シーケンシャルストリームパイプラインに安い操作は、一般的に、これは特に大きな値のため、順序付けられた並列パイプラインに非常に高価であることができる &lt;code&gt;n&lt;/code&gt; ので、 &lt;code&gt;skip(n)&lt;/code&gt; ないだけ任意スキップするように制約される&lt;em&gt;n個の&lt;/em&gt;要素が、&lt;em&gt;最初のnは&lt;/em&gt;遭遇順序の要素。順序付けされていないストリームソース（&lt;a href=&quot;longstream#generate-java.util.function.LongSupplier-&quot;&gt; &lt;code&gt;generate(LongSupplier)&lt;/code&gt; など&lt;/a&gt;）を使用するか、&lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; で&lt;/a&gt;順序付け制約を削除すると、状況のセマンティクスが許す場合、並列パイプラインで &lt;code&gt;skip()&lt;/code&gt; が大幅に高速化される可能性があります。エンカウンター順序との一貫性が必要で、パフォーマンスやメモリ使用率が低下している場合 &lt;code&gt;skip()&lt;/code&gt; 並列パイプラインでskip（）を使用し、&lt;a href=&quot;longstream#sequential--&quot;&gt; &lt;code&gt;sequential()&lt;/code&gt; で&lt;/a&gt;順次実行に切り替えると、パフォーマンスが向上する場合があります。</target>
        </trans-unit>
        <trans-unit id="e1b922a638d8b7b0bf464d0b07da3f9937acce8a" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;stream#generate-java.util.function.Supplier-&quot;&gt;&lt;code&gt;generate(Supplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential--&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">しながら、 &lt;code&gt;skip()&lt;/code&gt; シーケンシャルストリームパイプラインに安い操作は、一般的に、これは特に大きな値のため、順序付けられた並列パイプラインに非常に高価であることができる &lt;code&gt;n&lt;/code&gt; ので、 &lt;code&gt;skip(n)&lt;/code&gt; ないだけ任意スキップするように制約される&lt;em&gt;n個の&lt;/em&gt;要素が、&lt;em&gt;最初のnは&lt;/em&gt;遭遇順序の要素。順序付けされていないストリームソース（&lt;a href=&quot;stream#generate-java.util.function.Supplier-&quot;&gt; &lt;code&gt;generate(Supplier)&lt;/code&gt; など&lt;/a&gt;）を使用するか、&lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; で&lt;/a&gt;順序付け制約を削除すると、状況のセマンティクスが許す場合、並列パイプラインで &lt;code&gt;skip()&lt;/code&gt; が大幅に高速化される可能性があります。エンカウンター順序との一貫性が必要で、パフォーマンスやメモリ使用率が低下している場合 &lt;code&gt;skip()&lt;/code&gt; 並列パイプラインでskip（）を使用し、&lt;a href=&quot;basestream#sequential--&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; で&lt;/a&gt;順次実行に切り替えると、パフォーマンスが向上する場合があります。</target>
        </trans-unit>
        <trans-unit id="f11e1ce2eaeeb9a61aafb14bbaaa04b134c253c4" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;takeWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt;&lt;code&gt;generate(DoubleSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">一方で &lt;code&gt;takeWhile()&lt;/code&gt; は、一般的に順次ストリームパイプライン上の安い操作であり、それは操作がないだけで任意の有効な接頭辞が、出会いのための要素の最長プレフィックスを返すように制約されているので、注文した並列パイプラインには非常に高価になることができます。順序付けされていないストリームソース（&lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt; &lt;code&gt;generate(DoubleSupplier)&lt;/code&gt; など&lt;/a&gt;）を使用するか、&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; で&lt;/a&gt;順序付け制約を削除すると、状況のセマンティクスが許せば、並列パイプラインで &lt;code&gt;takeWhile()&lt;/code&gt; が大幅に高速化される可能性があります。遭遇順序との一貫性が必要であり、並列パイプラインの &lt;code&gt;takeWhile()&lt;/code&gt; でパフォーマンスまたはメモリ使用率が低下している場合は、次のコマンドを使用して順次実行に切り替えます。&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;は、パフォーマンスを向上させる可能性があります。</target>
        </trans-unit>
        <trans-unit id="536720f4d6e048e3bfc2daf23b8be0d5f28b62ff" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;takeWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt;&lt;code&gt;generate(IntSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">一方で &lt;code&gt;takeWhile()&lt;/code&gt; は、一般的に順次ストリームパイプライン上の安い操作であり、それは操作がないだけで任意の有効な接頭辞が、出会いのための要素の最長プレフィックスを返すように制約されているので、注文した並列パイプラインには非常に高価になることができます。順序付けされていないストリームソース（&lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt; &lt;code&gt;generate(IntSupplier)&lt;/code&gt; など&lt;/a&gt;）を使用するか、&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; で&lt;/a&gt;順序付け制約を削除すると、状況のセマンティクスが許せば、並列パイプラインで &lt;code&gt;takeWhile()&lt;/code&gt; が大幅に高速化される可能性があります。遭遇順序との一貫性が必要であり、並列パイプラインの &lt;code&gt;takeWhile()&lt;/code&gt; でパフォーマンスまたはメモリ使用率が低下している場合は、次のコマンドを使用して順次実行に切り替えます。&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;は、パフォーマンスを向上させる可能性があります。</target>
        </trans-unit>
        <trans-unit id="996949649b893c1211f1e5529c0828c15fa967ef" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;takeWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt;&lt;code&gt;generate(LongSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">一方で &lt;code&gt;takeWhile()&lt;/code&gt; は、一般的に順次ストリームパイプライン上の安い操作であり、それは操作がないだけで任意の有効な接頭辞が、出会いのための要素の最長プレフィックスを返すように制約されているので、注文した並列パイプラインには非常に高価になることができます。順序付けされていないストリームソース（&lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt; &lt;code&gt;generate(LongSupplier)&lt;/code&gt; など&lt;/a&gt;）を使用するか、&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; で&lt;/a&gt;順序付け制約を削除すると、状況のセマンティクスが許せば、並列パイプラインで &lt;code&gt;takeWhile()&lt;/code&gt; が大幅に高速化される可能性があります。遭遇順序との一貫性が必要であり、並列パイプラインの &lt;code&gt;takeWhile()&lt;/code&gt; でパフォーマンスまたはメモリ使用率が低下している場合は、次のコマンドを使用して順次実行に切り替えます。&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;は、パフォーマンスを向上させる可能性があります。</target>
        </trans-unit>
        <trans-unit id="6e8939e26489616f38385fb9a8f6b0914d6faecc" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;takeWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt;&lt;code&gt;generate(Supplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">一方で &lt;code&gt;takeWhile()&lt;/code&gt; は、一般的に順次ストリームパイプライン上の安い操作であり、それは操作がないだけで任意の有効な接頭辞が、出会いのための要素の最長プレフィックスを返すように制約されているので、注文した並列パイプラインには非常に高価になることができます。順序付けされていないストリームソース（&lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt; &lt;code&gt;generate(Supplier)&lt;/code&gt; など&lt;/a&gt;）を使用するか、&lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; で&lt;/a&gt;順序付け制約を削除すると、状況のセマンティクスが許せば、並列パイプラインで &lt;code&gt;takeWhile()&lt;/code&gt; が大幅に高速化される可能性があります。遭遇順序との一貫性が必要であり、並列パイプラインの &lt;code&gt;takeWhile()&lt;/code&gt; でパフォーマンスまたはメモリ使用率が低下している場合は、次のコマンドを使用して順次実行に切り替えます。&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt;は、パフォーマンスを向上させる可能性があります。</target>
        </trans-unit>
        <trans-unit id="f44ebb750484feed7acd90b248717e6c6a220783" translate="yes" xml:space="preserve">
          <source>While DefaultMutableTreeNode implements the MutableTreeNode interface and will allow you to add in any implementation of MutableTreeNode not all of the methods in DefaultMutableTreeNode will be applicable to all MutableTreeNodes implementations. Especially with some of the enumerations that are provided, using some of these methods assumes the DefaultMutableTreeNode contains only DefaultMutableNode instances. All of the TreeNode/MutableTreeNode methods will behave as defined no matter what implementations are added.</source>
          <target state="translated">DefaultMutableTreeNode は MutableTreeNode インターフェイスを実装しており、任意の MutableTreeNode の実装を追加することができますが、 DefaultMutableTreeNode のメソッドのすべてがすべての MutableTreeNode の実装に適用できるわけではありません。特に、いくつかの列挙が提供されていますが、これらのメソッドの中には DefaultMutableTreeNode が DefaultMutableNode インスタンスのみを含んでいることを前提としているものもあります。TreeNode/MutableTreeNode のすべてのメソッドは、どのようなインプリメンテーションが追加されても定義通りに動作します。</target>
        </trans-unit>
        <trans-unit id="4167a99521bae55a855564642cb10cb92285c449" translate="yes" xml:space="preserve">
          <source>While JAXP supports validation as a feature of an XML parser, represented by either a &lt;a href=&quot;../parsers/saxparser&quot;&gt;&lt;code&gt;SAXParser&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../parsers/documentbuilder&quot;&gt;&lt;code&gt;DocumentBuilder&lt;/code&gt;&lt;/a&gt; instance, the &lt;code&gt;Validation&lt;/code&gt; API is preferred.</source>
          <target state="translated">JAXPは、&lt;a href=&quot;../parsers/saxparser&quot;&gt; &lt;code&gt;SAXParser&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../parsers/documentbuilder&quot;&gt; &lt;code&gt;DocumentBuilder&lt;/code&gt; &lt;/a&gt;インスタンスのいずれかで表されるXMLパーサーの機能として検証をサポートしますが、 &lt;code&gt;Validation&lt;/code&gt; APIが推奨されます。</target>
        </trans-unit>
        <trans-unit id="a21ea13fd41327eba1978d9dc59ed4e742694b36" translate="yes" xml:space="preserve">
          <source>While XPath expressions select nodes in the XML document, the XPath API allows the selected nodes to be coalesced into one of the following data types:</source>
          <target state="translated">XPath 式は XML ドキュメント内のノードを選択しますが、XPath API では、選択したノードを次のデータ型のいずれかに合体させることができます。</target>
        </trans-unit>
        <trans-unit id="d1c1d5877bbdead7eaf0421be72e2ef20db6441f" translate="yes" xml:space="preserve">
          <source>While a &lt;code id=&quot;ELEM_VS_TYPE&quot;&gt;TypeElement&lt;/code&gt; represents a class or interface</source>
          <target state="translated">ながら &lt;code id=&quot;ELEM_VS_TYPE&quot;&gt;TypeElement&lt;/code&gt; はクラスまたはインタフェースを表します。</target>
        </trans-unit>
        <trans-unit id="9231d9bdcc9f4e1959e5ee9d3a56a9d2a170bb99" translate="yes" xml:space="preserve">
          <source>While a &lt;code&gt;CachedRowSet&lt;/code&gt; object is disconnected, it can be much leaner than a &lt;code&gt;ResultSet&lt;/code&gt; object with the same data. As a result, it can be especially suitable for sending data to a thin client such as a PDA, where it would be inappropriate to use a JDBC driver due to resource limitations or security considerations. Thus, a &lt;code&gt;CachedRowSet&lt;/code&gt; object provides a means to &quot;get rows in&quot; without the need to implement the full JDBC API.</source>
          <target state="translated">一方で &lt;code&gt;CachedRowSet&lt;/code&gt; オブジェクトが切断され、それはよりもはるかに希薄なことができ &lt;code&gt;ResultSet&lt;/code&gt; 同じデータを持つオブジェクト。その結果、PDAなどのシンクライアントにデータを送信する場合に特に適しています。この場合、リソースの制限やセキュリティ上の考慮事項のためにJDBCドライバーを使用することは不適切です。したがって、 &lt;code&gt;CachedRowSet&lt;/code&gt; オブジェクトは、完全なJDBCAPIを実装する必要なしに「行を取り込む」手段を提供します。</target>
        </trans-unit>
        <trans-unit id="30e4f165db1002fe6fbf12ff195d30f7e4cff77b" translate="yes" xml:space="preserve">
          <source>While a &lt;code&gt;Chronology&lt;/code&gt; object typically uses &lt;code&gt;ChronoField&lt;/code&gt; and is based on an era, year-of-era, month-of-year, day-of-month model of a date, this is not required. A &lt;code&gt;Chronology&lt;/code&gt; instance may represent a totally different kind of calendar system, such as the Mayan.</source>
          <target state="translated">一方で &lt;code&gt;Chronology&lt;/code&gt; オブジェクトは、一般的に使用さ &lt;code&gt;ChronoField&lt;/code&gt; を、日付の時代、年の時代、月-の年、日のヶ月のモデルに基づいており、これは必須ではありません。 &lt;code&gt;Chronology&lt;/code&gt; インスタンスは、マヤのように、カレンダーシステムの全く異なる種類を表すことができます。</target>
        </trans-unit>
        <trans-unit id="9784eeccfaf1f4a4f0da131846253a9ef6b0027f" translate="yes" xml:space="preserve">
          <source>While a &lt;code&gt;TypeElement&lt;/code&gt; represents a class or interface</source>
          <target state="translated">ながら &lt;code&gt;TypeElement&lt;/code&gt; はクラスまたはインタフェースを表します。</target>
        </trans-unit>
        <trans-unit id="b1518d4c45f16c46674f0f206ccd4613201a8ad4" translate="yes" xml:space="preserve">
          <source>While all three of the &lt;code&gt;prototypeCellValue&lt;/code&gt;, &lt;code&gt;fixedCellHeight&lt;/code&gt;, and &lt;code&gt;fixedCellWidth&lt;/code&gt; properties may be modified by this method, &lt;code&gt;PropertyChangeEvent&lt;/code&gt; notifications are only sent when the &lt;code&gt;prototypeCellValue&lt;/code&gt; property changes.</source>
          <target state="translated">3つのすべてのながら &lt;code&gt;prototypeCellValue&lt;/code&gt; 、 &lt;code&gt;fixedCellHeight&lt;/code&gt; プロパティ、および &lt;code&gt;fixedCellWidth&lt;/code&gt; の特性はこの方法によって改変することができる、 &lt;code&gt;PropertyChangeEvent&lt;/code&gt; 通知がときにのみ送信され &lt;code&gt;prototypeCellValue&lt;/code&gt; のプロパティの変更を。</target>
        </trans-unit>
        <trans-unit id="3b017d1c42ec1554655bf855dc44af27a7a96ca5" translate="yes" xml:space="preserve">
          <source>While applications write to the &lt;code&gt;LoginContext&lt;/code&gt; API, authentication technology providers implement the &lt;code&gt;LoginModule&lt;/code&gt; interface. A &lt;code&gt;Configuration&lt;/code&gt; specifies the LoginModule(s) to be used with a particular login application. Therefore different LoginModules can be plugged in under the application without requiring any modifications to the application itself.</source>
          <target state="translated">アプリケーションが &lt;code&gt;LoginContext&lt;/code&gt; APIに書き込む間、認証技術プロバイダーは &lt;code&gt;LoginModule&lt;/code&gt; インターフェイスを実装します。A &lt;code&gt;Configuration&lt;/code&gt; 、特定のログインアプリケーションで使用するLoginModuleを指定します。したがって、アプリケーション自体に変更を加えることなく、さまざまなLoginModuleをアプリケーションの下にプラグインできます。</target>
        </trans-unit>
        <trans-unit id="2406ab2abac29e951c9626f9ef877429a290fa9c" translate="yes" xml:space="preserve">
          <source>While building the MBeanInfo, this method calls the customization hooks that make it possible for subclasses to supply their custom descriptions, parameter names, etc...</source>
          <target state="translated">MBeanInfo を構築している間、このメソッドはサブクラスがカスタム記述やパラメータ名などを提供できるようにするカスタマイズフックを呼び出します。</target>
        </trans-unit>
        <trans-unit id="73b5f4ac2141a2818394c1e963ca8d4434b78746" translate="yes" xml:space="preserve">
          <source>While callers may invoke &lt;code&gt;login&lt;/code&gt; directly, the provider may also invoke &lt;code&gt;login&lt;/code&gt; on behalf of callers if it determines that a login must be performed prior to certain operations.</source>
          <target state="translated">呼び出し元は &lt;code&gt;login&lt;/code&gt; 直接呼び出すことができますが、プロバイダーは、特定の操作の前にログインを実行する必要があると判断した場合、呼び出し元に代わって &lt;code&gt;login&lt;/code&gt; を呼び出すこともできます。</target>
        </trans-unit>
        <trans-unit id="498a5c4d7f0598c6bbc42679f4696f06bbc47c30" translate="yes" xml:space="preserve">
          <source>While for case 2, it defines 4 URI Entries:</source>
          <target state="translated">一方、ケース2では4つのURIエントリを定義しています。</target>
        </trans-unit>
        <trans-unit id="868ad264cb55aef3c8dd9f1593aca303b1f31c60" translate="yes" xml:space="preserve">
          <source>While iterating through the &lt;code&gt;Set&lt;/code&gt;, a &lt;code&gt;SecurityException&lt;/code&gt; is thrown if a security manager is installed and the caller does not have a &lt;a href=&quot;privatecredentialpermission&quot;&gt;&lt;code&gt;PrivateCredentialPermission&lt;/code&gt;&lt;/a&gt; to access a particular Credential. The &lt;code&gt;Iterator&lt;/code&gt; is nevertheless advanced to the next element in the &lt;code&gt;Set&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Set&lt;/code&gt; を反復処理しているときに、セキュリティマネージャがインストールされていて、呼び出し元に特定の資格情報にアクセスするための&lt;a href=&quot;privatecredentialpermission&quot;&gt; &lt;code&gt;PrivateCredentialPermission&lt;/code&gt; &lt;/a&gt;がない場合、 &lt;code&gt;SecurityException&lt;/code&gt; がスローされます。それでも、 &lt;code&gt;Iterator&lt;/code&gt; は &lt;code&gt;Set&lt;/code&gt; 内の次の要素に進みます。</target>
        </trans-unit>
        <trans-unit id="6354a2a3180a9378c7eb02538eb193186e5effba" translate="yes" xml:space="preserve">
          <source>While iterating through the &lt;code&gt;Set&lt;/code&gt;, a &lt;code&gt;SecurityException&lt;/code&gt; is thrown if the caller does not have permission to access a particular Credential. The &lt;code&gt;Iterator&lt;/code&gt; is nevertheless advanced to next element in the &lt;code&gt;Set&lt;/code&gt;.</source>
          <target state="translated">反復しながら &lt;code&gt;Set&lt;/code&gt; 、 &lt;code&gt;SecurityException&lt;/code&gt; が、発信者が特定の資格情報にアクセスする権限を持っていない場合にスローされます。それにもかかわらず、 &lt;code&gt;Iterator&lt;/code&gt; は &lt;code&gt;Set&lt;/code&gt; の次の要素に進みます。</target>
        </trans-unit>
        <trans-unit id="0fa2ee2232311c188a194a08d7481eaf402f451e" translate="yes" xml:space="preserve">
          <source>While parsing an input source, errors are reported to the application through the error handler (&lt;code&gt;LSParser.domConfig&lt;/code&gt;'s &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-error-handler&quot;&gt;error-handler&lt;/a&gt;&quot; parameter). This specification does in no way try to define all possible errors that can occur while parsing XML, or any other markup, but some common error cases are defined. The types (&lt;code&gt;DOMError.type&lt;/code&gt;) of errors and warnings defined by this specification are:</source>
          <target state="translated">入力ソースの解析中に、エラーはエラーハンドラー（ &lt;code&gt;LSParser.domConfig&lt;/code&gt; の「&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-error-handler&quot;&gt;error-handler&lt;/a&gt;」パラメーター）を介してアプリケーションに報告されます。この仕様は、XMLまたはその他のマークアップの解析中に発生する可能性のあるすべてのエラーを定義しようとするものではありませんが、いくつかの一般的なエラーケースが定義されています。この仕様で定義されているエラーと警告のタイプ（ &lt;code&gt;DOMError.type&lt;/code&gt; ）は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="86165e5f29fc9b9137f2a5569a7128b787a2ddbb" translate="yes" xml:space="preserve">
          <source>While serializing a document, the parameter &quot;discard-default-content&quot; controls whether or not non-specified data is serialized.</source>
          <target state="translated">文書をシリアライズする際、パラメータ「discard-default-content」は、指定されていないデータをシリアライズするかどうかを制御します。</target>
        </trans-unit>
        <trans-unit id="cf4536abd5f3f04b1e2ed476be040c60ab02acb7" translate="yes" xml:space="preserve">
          <source>While serializing, errors and warnings are reported to the application through the error handler (&lt;code&gt;LSSerializer.domConfig&lt;/code&gt;'s &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-error-handler&quot;&gt;error-handler&lt;/a&gt;&quot; parameter). This specification does in no way try to define all possible errors and warnings that can occur while serializing a DOM node, but some common error and warning cases are defined. The types ( &lt;code&gt;DOMError.type&lt;/code&gt;) of errors and warnings defined by this specification are:</source>
          <target state="translated">シリアル化中、エラーと警告はエラーハンドラー（ &lt;code&gt;LSSerializer.domConfig&lt;/code&gt; の「&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-error-handler&quot;&gt;error-handler&lt;/a&gt;」パラメーター）を介してアプリケーションに報告されます。この仕様では、DOMノードのシリアル化中に発生する可能性のあるすべてのエラーと警告を定義しようとはしていませんが、いくつかの一般的なエラーと警告のケースが定義されています。この仕様で定義されているエラーと警告のタイプ（ &lt;code&gt;DOMError.type&lt;/code&gt; ）は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="c239e1b59a3047897d29f5e117079370e9edd962" translate="yes" xml:space="preserve">
          <source>While tables for abbreviated streams are often obtained by first reading another abbreviated stream containing only the tables, in some applications the tables are fixed ahead of time. This class allows the tables to be specified directly from client code. If no tables are specified either in the stream or in a &lt;code&gt;JPEGImageReadParam&lt;/code&gt;, then the stream is presumed to use the &quot;standard&quot; visually lossless tables. See &lt;a href=&quot;jpegqtable&quot;&gt;&lt;code&gt;JPEGQTable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;jpeghuffmantable&quot;&gt;&lt;code&gt;JPEGHuffmanTable&lt;/code&gt;&lt;/a&gt; for more information on the default tables.</source>
          <target state="translated">多くの場合、省略されたストリームのテーブルは、最初にテーブルのみを含む別の省略されたストリームを読み取ることによって取得されますが、一部のアプリケーションでは、テーブルは事前に固定されています。このクラスを使用すると、クライアントコードから直接テーブルを指定できます。ストリームまたは &lt;code&gt;JPEGImageReadParam&lt;/code&gt; のどちらにもテーブルが指定されていない場合、ストリームは「標準の」視覚的に損失のないテーブルを使用すると推定されます。デフォルトのテーブルの詳細については、&lt;a href=&quot;jpegqtable&quot;&gt; &lt;code&gt;JPEGQTable&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;jpeghuffmantable&quot;&gt; &lt;code&gt;JPEGHuffmanTable&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="1b216501bc1079107fcb46b023f11ebfbbaf13fc" translate="yes" xml:space="preserve">
          <source>While tables for abbreviated streams are often specified by first writing an abbreviated stream containing only the tables, in some applications the tables are fixed ahead of time. This class allows the tables to be specified directly from client code.</source>
          <target state="translated">短縮ストリームのテーブルは、テーブルだけを含む短縮ストリームを最初に書くことで指定されることが多いですが、アプリケーションによってはテーブルが先に固定されていることもあります。このクラスでは、クライアントコードから直接テーブルを指定することができます。</target>
        </trans-unit>
        <trans-unit id="f55e7baa234a92f09d11651aeeb34c78f17b723e" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;Collection&lt;/code&gt; interface adds no stipulations to the general contract for the &lt;code&gt;Object.equals&lt;/code&gt;, programmers who implement the &lt;code&gt;Collection&lt;/code&gt; interface &quot;directly&quot; (in other words, create a class that is a &lt;code&gt;Collection&lt;/code&gt; but is not a &lt;code&gt;Set&lt;/code&gt; or a &lt;code&gt;List&lt;/code&gt;) must exercise care if they choose to override the &lt;code&gt;Object.equals&lt;/code&gt;. It is not necessary to do so, and the simplest course of action is to rely on &lt;code&gt;Object&lt;/code&gt;'s implementation, but the implementor may wish to implement a &quot;value comparison&quot; in place of the default &quot;reference comparison.&quot; (The &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt; interfaces mandate such value comparisons.)</source>
          <target state="translated">一方で &lt;code&gt;Collection&lt;/code&gt; インターフェイスはのための一般規約に条項を追加しません &lt;code&gt;Object.equals&lt;/code&gt; 、実装するプログラマ &lt;code&gt;Collection&lt;/code&gt; 「直接」（言い換えれば、あるクラスの作成インターフェイスを &lt;code&gt;Collection&lt;/code&gt; ではなく、ある &lt;code&gt;Set&lt;/code&gt; または &lt;code&gt;List&lt;/code&gt; ）注意を払わなければなりません &lt;code&gt;Object.equals&lt;/code&gt; をオーバーライドすることを選択した場合。これを行う必要はなく、最も簡単な方法は &lt;code&gt;Object&lt;/code&gt; の実装に依存することですが、実装者はデフォルトの「参照比較」の代わりに「値比較」を実装したい場合があります。 （ &lt;code&gt;List&lt;/code&gt; および &lt;code&gt;Set&lt;/code&gt; インターフェースは、このような値の比較を義務付けています。）</target>
        </trans-unit>
        <trans-unit id="d9b34ed17b895b7570e58dbe128c1061764f2836" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;JOptionPane&lt;/code&gt; class may appear complex because of the large number of methods, almost all uses of this class are one-line calls to one of the static &lt;code&gt;showXxxDialog&lt;/code&gt; methods shown below:</source>
          <target state="translated">ながら &lt;code&gt;JOptionPane&lt;/code&gt; クラスが原因方法の多数の複雑な表示されることがあり、このクラスのほとんどすべての用途は静的のいずれかに一ラインコールである &lt;code&gt;showXxxDialog&lt;/code&gt; 下記に示す方法。</target>
        </trans-unit>
        <trans-unit id="f05e95138eee0f8263aaeecdb23d34bbf507f801" translate="yes" xml:space="preserve">
          <source>While the child view is being accessed a read lock is acquired on the associated document so that the model is stable while being accessed.</source>
          <target state="translated">子ビューがアクセスされている間は、関連するドキュメントにリードロックが取得され、アクセスされている間はモデルが安定しています。</target>
        </trans-unit>
        <trans-unit id="18005f1749c0380a1dd553fb852a3af3b6131165" translate="yes" xml:space="preserve">
          <source>While the drag and drop implementation calls &lt;code&gt;canImport&lt;/code&gt; to determine the suitability of a transfer before calling this method, the implementation of paste does not. As such, it cannot be assumed that the transfer is acceptable upon a call to this method for paste. It is recommended that &lt;code&gt;canImport&lt;/code&gt; be explicitly called to cover this case.</source>
          <target state="translated">ドラッグアンドドロップの実装は &lt;code&gt;canImport&lt;/code&gt; を呼び出して、このメソッドを呼び出す前に転送の適合性を判断しますが、貼り付けの実装はそうではありません。そのため、この貼り付けメソッドを呼び出したときに転送が受け入れられるとは限りません。このケースをカバーするために、 &lt;code&gt;canImport&lt;/code&gt; を明示的に呼び出すことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="4efe8fc428299599c701c1333f6be7122c0cee74" translate="yes" xml:space="preserve">
          <source>While the hook is being called, the new &lt;code&gt;ConstantCallSite&lt;/code&gt; object is in a partially constructed state. In this state, a call to &lt;code&gt;getTarget&lt;/code&gt;, or any other attempt to use the target, will result in an &lt;code&gt;IllegalStateException&lt;/code&gt;. It is legal at all times to obtain the call site's type using the &lt;code&gt;type&lt;/code&gt; method.</source>
          <target state="translated">フックが呼び出されている間、新しい &lt;code&gt;ConstantCallSite&lt;/code&gt; オブジェクトは部分的に構成された状態です。この状態では、 &lt;code&gt;getTarget&lt;/code&gt; への呼び出し、またはターゲットを使用するその他の試みにより、 &lt;code&gt;IllegalStateException&lt;/code&gt; が発生します。 &lt;code&gt;type&lt;/code&gt; メソッドを使用して呼び出しサイトのタイプを取得することは常に合法です。</target>
        </trans-unit>
        <trans-unit id="e64de2c787d87b6255db69fb316860954d89cac4" translate="yes" xml:space="preserve">
          <source>While the scoping mechanism for &lt;code&gt;synchronized&lt;/code&gt; methods and statements makes it much easier to program with monitor locks, and helps avoid many common programming errors involving locks, there are occasions where you need to work with locks in a more flexible way. For example, some algorithms for traversing concurrently accessed data structures require the use of &quot;hand-over-hand&quot; or &quot;chain locking&quot;: you acquire the lock of node A, then node B, then release A and acquire C, then release B and acquire D and so on. Implementations of the &lt;code&gt;Lock&lt;/code&gt; interface enable the use of such techniques by allowing a lock to be acquired and released in different scopes, and allowing multiple locks to be acquired and released in any order.</source>
          <target state="translated">&lt;code&gt;synchronized&lt;/code&gt; メソッドとステートメントのスコープメカニズムにより、モニターロックを使用したプログラミングがはるかに容易になり、ロックに関連する多くの一般的なプログラミングエラーを回避できますが、より柔軟な方法でロックを操作する必要がある場合があります。たとえば、同時にアクセスされるデータ構造をトラバースするための一部のアルゴリズムでは、「ハンドオーバー」または「チェーンロック」を使用する必要があります。ノードAのロックを取得してからノードBを取得し、次にAを解放してからCを取得してからBを解放します。 Dなどを取得します。 &lt;code&gt;Lock&lt;/code&gt; インターフェースの実装は、異なるスコープでロックを取得および解放できるようにし、複数のロックを任意の順序で取得および解放できるようにすることで、このような手法の使用を可能にします。</target>
        </trans-unit>
        <trans-unit id="e4da0d73a5a72455f5512b34b17d391abf383ff0" translate="yes" xml:space="preserve">
          <source>While the specification of this method in the &lt;a href=&quot;writer#write(java.lang.String,int,int)&quot;&gt;superclass&lt;/a&gt; recommends that an &lt;a href=&quot;../lang/indexoutofboundsexception&quot;&gt;&lt;code&gt;IndexOutOfBoundsException&lt;/code&gt;&lt;/a&gt; be thrown if &lt;code&gt;len&lt;/code&gt; is negative or &lt;code&gt;off + len&lt;/code&gt; is negative, the implementation in this class does not throw such an exception in these cases but instead simply writes no characters.</source>
          <target state="translated">&lt;a href=&quot;writer#write(java.lang.String,int,int)&quot;&gt;スーパークラス&lt;/a&gt;でのこのメソッドの仕様では、 &lt;code&gt;len&lt;/code&gt; が負または &lt;code&gt;off + len&lt;/code&gt; が負の場合に&lt;a href=&quot;../lang/indexoutofboundsexception&quot;&gt; &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; をスローする&lt;/a&gt;ことを推奨していますが、このクラスの実装はこれらの場合にそのような例外をスローせず、代わりに文字を書き込みません。</target>
        </trans-unit>
        <trans-unit id="2fa594a26798c1bce1231654fe91cf1056a98394" translate="yes" xml:space="preserve">
          <source>While the stream is open, the &lt;code&gt;append(char)&lt;/code&gt;, &lt;code&gt;
 append(CharSequence)&lt;/code&gt;, &lt;code&gt;append(CharSequence, int, int)&lt;/code&gt;, &lt;code&gt;flush()&lt;/code&gt;, &lt;code&gt;write(int)&lt;/code&gt;, &lt;code&gt;write(char[])&lt;/code&gt;, and &lt;code&gt;write(char[], int, int)&lt;/code&gt; methods do nothing. After the stream has been closed, these methods all throw &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">ストリームが開いている間、 &lt;code&gt;append(char)&lt;/code&gt; 、 &lt;code&gt; append(CharSequence)&lt;/code&gt; 、 &lt;code&gt;append(CharSequence, int, int)&lt;/code&gt; 、 &lt;code&gt;flush()&lt;/code&gt; 、 &lt;code&gt;write(int)&lt;/code&gt; 、 &lt;code&gt;write(char[])&lt;/code&gt; 、および &lt;code&gt;write(char[], int, int)&lt;/code&gt; メソッドは何もしません。ストリームが閉じられた後、これらのメソッドはすべて &lt;code&gt;IOException&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="9f27c207d45817eb6f9a257c7c530eb9bfcf4665" translate="yes" xml:space="preserve">
          <source>While the stream is open, the &lt;code&gt;available()&lt;/code&gt;, &lt;code&gt;read()&lt;/code&gt;, &lt;code&gt;read(byte[])&lt;/code&gt;, &lt;code&gt;read(byte[], int, int)&lt;/code&gt;, &lt;code&gt;readAllBytes()&lt;/code&gt;, &lt;code&gt;readNBytes(byte[], int, int)&lt;/code&gt;, &lt;code&gt;readNBytes(int)&lt;/code&gt;, &lt;code&gt;skip(long)&lt;/code&gt;, and &lt;code&gt;transferTo()&lt;/code&gt; methods all behave as if end of stream has been reached. After the stream has been closed, these methods all throw &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">ストリームが開いている間、 &lt;code&gt;available()&lt;/code&gt; 、 &lt;code&gt;read()&lt;/code&gt; 、 &lt;code&gt;read(byte[])&lt;/code&gt; 、 &lt;code&gt;read(byte[], int, int)&lt;/code&gt; 、 &lt;code&gt;readAllBytes()&lt;/code&gt; 、 &lt;code&gt;readNBytes(byte[], int, int)&lt;/code&gt; 、 &lt;code&gt;readNBytes(int)&lt;/code&gt; 、 &lt;code&gt;skip(long)&lt;/code&gt; 、および &lt;code&gt;transferTo()&lt;/code&gt; メソッドはすべて、ストリームの終わりに到達したかのように動作します。ストリームが閉じられた後、これらのメソッドはすべて &lt;code&gt;IOException&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="354a3e678c0afc6d9c995cad19836af2c60e94bf" translate="yes" xml:space="preserve">
          <source>While the stream is open, the &lt;code&gt;read()&lt;/code&gt;, &lt;code&gt;read(char[])&lt;/code&gt;, &lt;code&gt;read(char[], int, int)&lt;/code&gt;, &lt;code&gt;read(Charbuffer)&lt;/code&gt;, &lt;code&gt;
 ready()&lt;/code&gt;, &lt;code&gt;skip(long)&lt;/code&gt;, and &lt;code&gt;transferTo()&lt;/code&gt; methods all behave as if end of stream has been reached. After the stream has been closed, these methods all throw &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">ストリームが開いている間、 &lt;code&gt;read()&lt;/code&gt; 、 &lt;code&gt;read(char[])&lt;/code&gt; 、 &lt;code&gt;read(char[], int, int)&lt;/code&gt; 、 &lt;code&gt;read(Charbuffer)&lt;/code&gt; 、 &lt;code&gt; ready()&lt;/code&gt; 、 &lt;code&gt;skip(long)&lt;/code&gt; 、および &lt;code&gt;transferTo()&lt;/code&gt; メソッドはすべて動作します。ストリームの終わりに到達したかのように。ストリームが閉じられた後、これらのメソッドはすべて &lt;code&gt;IOException&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="38e5439eae991a55c97ddfd38870798ef229cbcd" translate="yes" xml:space="preserve">
          <source>While the stream is open, the &lt;code&gt;write(int)&lt;/code&gt;, &lt;code&gt;
 write(byte[])&lt;/code&gt;, and &lt;code&gt;write(byte[], int, int)&lt;/code&gt; methods do nothing. After the stream has been closed, these methods all throw &lt;code&gt;
 IOException&lt;/code&gt;.</source>
          <target state="translated">ストリームが開いている間、 &lt;code&gt;write(int)&lt;/code&gt; 、 &lt;code&gt; write(byte[])&lt;/code&gt; 、および &lt;code&gt;write(byte[], int, int)&lt;/code&gt; メソッドは何もしません。ストリームが閉じられた後、これらのメソッドはすべて &lt;code&gt; IOException&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="dc1904d24dfdb2dc325b56134c9dce9b4ddaba55" translate="yes" xml:space="preserve">
          <source>While the unit of time of the return value is milliseconds, the granularity of the value depends on the underlying file system and may be larger. For example, some file systems use time stamps in units of seconds.</source>
          <target state="translated">戻り値の時間の単位はミリ秒ですが、値の粒度は基礎となるファイルシステムに依存しており、より大きくなる場合があります。例えば、いくつかのファイルシステムでは、秒単位のタイムスタンプを使用しています。</target>
        </trans-unit>
        <trans-unit id="71a236fbeded33e61e30714b2af91dd5dfd1beff" translate="yes" xml:space="preserve">
          <source>While this class has been part of swing for a while now, it is public as of 1.4.</source>
          <target state="translated">このクラスはしばらく前からスイングの一部でしたが、1.4では公開されています。</target>
        </trans-unit>
        <trans-unit id="6ebba50ef7f7692c7039eeb694af9a571417cf59" translate="yes" xml:space="preserve">
          <source>While this class inherits from &lt;a href=&quot;threadpoolexecutor&quot;&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;&lt;/a&gt;, a few of the inherited tuning methods are not useful for it. In particular, because it acts as a fixed-sized pool using &lt;code&gt;corePoolSize&lt;/code&gt; threads and an unbounded queue, adjustments to &lt;code&gt;maximumPoolSize&lt;/code&gt; have no useful effect. Additionally, it is almost never a good idea to set &lt;code&gt;corePoolSize&lt;/code&gt; to zero or use &lt;code&gt;allowCoreThreadTimeOut&lt;/code&gt; because this may leave the pool without threads to handle tasks once they become eligible to run.</source>
          <target state="translated">このクラスは&lt;a href=&quot;threadpoolexecutor&quot;&gt; &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; &lt;/a&gt;から継承しますが、継承されたチューニングメソッドのいくつかはこのクラスには役立ちません。特に、 &lt;code&gt;corePoolSize&lt;/code&gt; スレッドと無制限のキューを使用して固定サイズのプールとして機能するため、 &lt;code&gt;maximumPoolSize&lt;/code&gt; を調整しても効果はありません。また、 &lt;code&gt;corePoolSize&lt;/code&gt; をゼロに設定したり、 &lt;code&gt;allowCoreThreadTimeOut&lt;/code&gt; を使用したりすることはほとんどありません。これにより、プールが実行可能になったときにタスクを処理するスレッドがなくなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="37f43590d9884fbad9cdec8f02f0705df36bced7" translate="yes" xml:space="preserve">
          <source>While this interface method is declared to throw &lt;code&gt;
 Exception&lt;/code&gt;, implementers are &lt;em&gt;strongly&lt;/em&gt; encouraged to declare concrete implementations of the &lt;code&gt;close&lt;/code&gt; method to throw more specific exceptions, or to throw no exception at all if the close operation cannot fail.</source>
          <target state="translated">このインタフェースのメソッドがスローするように宣言されている一方で &lt;code&gt; Exception&lt;/code&gt; 、実装はされている&lt;em&gt;強力&lt;/em&gt;の具象実装を宣言することを奨励 &lt;code&gt;close&lt;/code&gt; 、より具体的な例外をスローする、または閉じる操作が失敗することはできません場合は、すべての例外をスローしないようにする方法を。</target>
        </trans-unit>
        <trans-unit id="1c294c7b4d4f86f3493751e198f59f458ef4183c" translate="yes" xml:space="preserve">
          <source>While this interface method is declared to throw &lt;code&gt;Exception&lt;/code&gt;, implementers are &lt;em&gt;strongly&lt;/em&gt; encouraged to declare concrete implementations of the &lt;code&gt;close&lt;/code&gt; method to throw more specific exceptions, or to throw no exception at all if the close operation cannot fail.</source>
          <target state="translated">このインタフェースのメソッドがスローするように宣言されている一方で &lt;code&gt;Exception&lt;/code&gt; 、実装はされている&lt;em&gt;強力&lt;/em&gt;の具象実装を宣言することを奨励 &lt;code&gt;close&lt;/code&gt; 、より具体的な例外をスローする、または閉じる操作が失敗することはできません場合は、すべての例外をスローしないようにする方法を。</target>
        </trans-unit>
        <trans-unit id="5aafec2ecc872a5e693872afd5344f871ab06e7e" translate="yes" xml:space="preserve">
          <source>While this is a public method, this is typically only useful for subclassers of &lt;code&gt;JFormattedTextField&lt;/code&gt;. &lt;code&gt;JFormattedTextField&lt;/code&gt; will invoke this method at the appropriate times when the value changes, or its internal state changes.</source>
          <target state="translated">これはパブリックメソッドですが、これは通常、 &lt;code&gt;JFormattedTextField&lt;/code&gt; のサブクラスにのみ役立ちます。 &lt;code&gt;JFormattedTextField&lt;/code&gt; は、値が変更されたとき、またはその内部状態が変更されたときに、このメソッドを呼び出します。</target>
        </trans-unit>
        <trans-unit id="79111a912067f71a2c429865902e2e2dfdb6357a" translate="yes" xml:space="preserve">
          <source>While this is a public method, this is typically only useful for subclassers of &lt;code&gt;JFormattedTextField&lt;/code&gt;. &lt;code&gt;JFormattedTextField&lt;/code&gt; will invoke this method at the appropriate times when the value changes, or its internal state changes. You will only need to invoke this yourself if you are subclassing &lt;code&gt;JFormattedTextField&lt;/code&gt; and installing/uninstalling &lt;code&gt;AbstractFormatter&lt;/code&gt; at a different time than &lt;code&gt;JFormattedTextField&lt;/code&gt; does.</source>
          <target state="translated">これはパブリックメソッドですが、これは通常、 &lt;code&gt;JFormattedTextField&lt;/code&gt; のサブクラスにのみ役立ちます。 &lt;code&gt;JFormattedTextField&lt;/code&gt; は、値が変更されたとき、またはその内部状態が変更されたときに、このメソッドを呼び出します。 &lt;code&gt;JFormattedTextField&lt;/code&gt; をサブクラス &lt;code&gt;AbstractFormatter&lt;/code&gt; し、 &lt;code&gt;JFormattedTextField&lt;/code&gt; とは異なる時間にAbstractFormatterをインストール/アンインストールする場合にのみ、これを自分で呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="a8962e33fe4ae692b6f0669c0b0060997d23406a" translate="yes" xml:space="preserve">
          <source>While this may seem a more roundabout way to perform an aggregation compared to simply mutating a running total in a loop, reduction operations parallelize more gracefully, without needing additional synchronization and with greatly reduced risk of data races.</source>
          <target state="translated">これは、ループ内で実行中の合計を単に突然変異させるのに比べれば、集計を実行するための方法としては、より丸い方法に見えるかもしれませんが、削減操作はより優雅に並列化され、追加の同期を必要とせず、データ競合のリスクを大幅に減らすことができます。</target>
        </trans-unit>
        <trans-unit id="a47a2652b0c502dd1c763501db1290a29367490b" translate="yes" xml:space="preserve">
          <source>While this method is public, it should only be invoked by the &lt;code&gt;UIManager&lt;/code&gt; when the look and feel is set as the current look and feel and after &lt;code&gt;initialize&lt;/code&gt; has been invoked.</source>
          <target state="translated">このメソッドはパブリック &lt;code&gt;UIManager&lt;/code&gt; が、ルックアンドフィールが現在のルックアンドフィールとして設定されている場合、および &lt;code&gt;initialize&lt;/code&gt; が呼び出された後にのみ、UIManagerによって呼び出される必要があります。</target>
        </trans-unit>
        <trans-unit id="c581298e75ef5bf15df9b06bf2c664ea73c5c346" translate="yes" xml:space="preserve">
          <source>While writing an object via writeUnshared does not in itself guarantee a unique reference to the object when it is deserialized, it allows a single object to be defined multiple times in a stream, so that multiple calls to readUnshared by the receiver will not conflict. Note that the rules described above only apply to the base-level object written with writeUnshared, and not to any transitively referenced sub-objects in the object graph to be serialized.</source>
          <target state="translated">writeUnshared を使ってオブジェクトを書き込んでも、それ自体はデシリアライズされたときのオブジェクトへの一意の参照を保証するものではありませんが、単一のオブジェクトをストリーム内で複数回定義することができ、レシーバによる readUnshared への複数回の呼び出しが衝突しないようにします。上記のルールは writeUnshared で書かれたベースレベルのオブジェクトにのみ適用され、シリアライズされるオブジェクトグラフ内のトランジット的に参照されるサブオブジェクトには適用されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="5da2d68669a03b947051233558b6ce56e6780f0a" translate="yes" xml:space="preserve">
          <source>White_Space</source>
          <target state="translated">White_Space</target>
        </trans-unit>
        <trans-unit id="325016380fb9842b99430cbb0b7cb06becabcdfe" translate="yes" xml:space="preserve">
          <source>Whitespace is allowed on either side of ',', ';', '=', and '+'. Such whitespace is accepted but not generated by this code, and is ignored when comparing names.</source>
          <target state="translated">','、',';'、'='、および '+' の両側には空白が許されています。このような空白は受け入れられますが、このコードでは生成されず、名前を比較する際には無視されます。</target>
        </trans-unit>
        <trans-unit id="3ef5e18e6403c342fcf6ad4db4c278abb2cb9d38" translate="yes" xml:space="preserve">
          <source>Whitespace is not significant in the above regular expressions.</source>
          <target state="translated">上記の正規表現では、空白は重要ではありません。</target>
        </trans-unit>
        <trans-unit id="6d620fb7a85a0616f4a4e6e9dda029e04472a323" translate="yes" xml:space="preserve">
          <source>Wide Area Information Server (WAIS) protocol.</source>
          <target state="translated">広域情報サーバー(WAIS)プロトコル。</target>
        </trans-unit>
        <trans-unit id="4088f5317f57ea6f119849410abea3f8143240d0" translate="yes" xml:space="preserve">
          <source>Widget for user to</source>
          <target state="translated">ユーザーのためのウィジェット</target>
        </trans-unit>
        <trans-unit id="a58ddf50c5ea5c03802da919dd5953bbf82ebd74" translate="yes" xml:space="preserve">
          <source>Width</source>
          <target state="translated">Width</target>
        </trans-unit>
        <trans-unit id="969d00f2cb9efe3539d44d8c60c74f5ad9d4d231" translate="yes" xml:space="preserve">
          <source>Width in pixels of the region of image data that this SampleModel describes.</source>
          <target state="translated">この SampleModel が記述する画像データの領域の幅をピクセル単位で指定します。</target>
        </trans-unit>
        <trans-unit id="ad438ebb7fecc02d85771ba7a5e164704291d2aa" translate="yes" xml:space="preserve">
          <source>Width margin between each column</source>
          <target state="translated">各列間の幅のマージン</target>
        </trans-unit>
        <trans-unit id="50794f4688ae96bdb4341321c3ffa61a405c19eb" translate="yes" xml:space="preserve">
          <source>Width of the back buffers</source>
          <target state="translated">バックバッファの幅</target>
        </trans-unit>
        <trans-unit id="9c249f6d47c523ac145af2ace67f2b7577b5b942" translate="yes" xml:space="preserve">
          <source>Width or height of the divider based on orientation &lt;code&gt;BasicSplitPaneUI&lt;/code&gt; adds two to this.</source>
          <target state="translated">方向 &lt;code&gt;BasicSplitPaneUI&lt;/code&gt; に基づく仕切りの幅または高さは、これに2を追加します。</target>
        </trans-unit>
        <trans-unit id="d5208bbe059aa1046c3f08361ea1e178ca24d291" translate="yes" xml:space="preserve">
          <source>WildcardType</source>
          <target state="translated">WildcardType</target>
        </trans-unit>
        <trans-unit id="66c44a9ca081e2d89075ec9d49d2689c74584a8a" translate="yes" xml:space="preserve">
          <source>WildcardType represents a wildcard type expression, such as &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;? extends Number&lt;/code&gt;, or &lt;code&gt;? super Integer&lt;/code&gt;.</source>
          <target state="translated">WildcardTypeは、 &lt;code&gt;?&lt;/code&gt; などのワイルドカードタイプの式を表します。、 &lt;code&gt;? extends Number&lt;/code&gt; 、または &lt;code&gt;? super Integer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce867c4c796e6dbe1d3e38766feb789822009ee1" translate="yes" xml:space="preserve">
          <source>WildcardType.getExtendsBound()</source>
          <target state="translated">WildcardType.getExtendsBound()</target>
        </trans-unit>
        <trans-unit id="330bde92db69c2198109194787e6c21b7478f2c0" translate="yes" xml:space="preserve">
          <source>WildcardType.getLowerBounds()</source>
          <target state="translated">WildcardType.getLowerBounds()</target>
        </trans-unit>
        <trans-unit id="f81da7284909bf43711682454467244f68db18a0" translate="yes" xml:space="preserve">
          <source>WildcardType.getSuperBound()</source>
          <target state="translated">WildcardType.getSuperBound()</target>
        </trans-unit>
        <trans-unit id="97172c5abf520854245e039ae23bd4e64bc5422f" translate="yes" xml:space="preserve">
          <source>WildcardType.getUpperBounds()</source>
          <target state="translated">WildcardType.getUpperBounds()</target>
        </trans-unit>
        <trans-unit id="521d06dd779ba79ee4cea678dbe14d70dbe38387" translate="yes" xml:space="preserve">
          <source>Will be &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;java.awt.Image&lt;/code&gt; is not visible, the &lt;code&gt;java.desktop&lt;/code&gt; module is not loaded, or the &lt;code&gt;java.desktop&lt;/code&gt; module is not in the run-time image.</source>
          <target state="translated">&lt;code&gt;java.awt.Image&lt;/code&gt; が表示されていない場合、 &lt;code&gt;java.desktop&lt;/code&gt; モジュールがロードされていない場合、または &lt;code&gt;java.desktop&lt;/code&gt; モジュールがランタイムイメージにない場合は、 &lt;code&gt;null&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="d33509e2ec308e6546857b8da6aba57cee35ab90" translate="yes" xml:space="preserve">
          <source>Will be called to see whether or not this cookie should be accepted.</source>
          <target state="translated">このクッキーを受け入れるべきかどうかを確認するために呼び出されます。</target>
        </trans-unit>
        <trans-unit id="37fa7a262702fe582d3a1dccfa6ad0f9944b59d4" translate="yes" xml:space="preserve">
          <source>Will check the role according to its corresponding role definition provided in relation's relation type</source>
          <target state="translated">リレーションのリレーションタイプで提供されている対応するロール定義に従ってロールをチェックします。</target>
        </trans-unit>
        <trans-unit id="6ccf06bf2935ecc384eb6df2769fb29a28f7bd2b" translate="yes" xml:space="preserve">
          <source>Will not always find a match (or the correct match) if some part of the parse is ambiguous. For example, if the pattern &quot;{1},{2}&quot; is used with the string arguments {&quot;a,b&quot;, &quot;c&quot;}, it will format as &quot;a,b,c&quot;. When the result is parsed, it will return {&quot;a&quot;, &quot;b,c&quot;}.</source>
          <target state="translated">パースの一部が曖昧な場合、常に一致する(または正しい)とは限りません。例えば、パターン &quot;{1},{2}&quot; が文字列引数 {&quot;a,b&quot;,&quot;c&quot;}と共に使用されている場合、&quot;a,b,c&quot; という形式になります。結果が解析されると、{&quot;a&quot;,&quot;b,c&quot;}が返されます。</target>
        </trans-unit>
        <trans-unit id="c58deb92d1c5c729de051dba7b43a35ac3101b21" translate="yes" xml:space="preserve">
          <source>Will not see uncommitted data (make &quot;dirty&quot; reads).</source>
          <target state="translated">コミットされていないデータは表示されません(&quot;ダーティ &quot;な読み取りを行います)。</target>
        </trans-unit>
        <trans-unit id="d669a272be58163914a204bccea56c09fa69e531" translate="yes" xml:space="preserve">
          <source>Will send a notification (RelationNotification with type RELATION_BASIC_UPDATE or RELATION_MBEAN_UPDATE, depending if the relation is a MBean or not).</source>
          <target state="translated">通知(リレーションがMBeanであるかどうかに応じて、RELATION_BASIC_UPDATEまたはRELATION_MBEAN_UPDATE型のRelationNotification)を送信します。</target>
        </trans-unit>
        <trans-unit id="c456f440fcf296338c58bf917ef98c5c5d7bac84" translate="yes" xml:space="preserve">
          <source>Will send one notification (RelationNotification with type RELATION_BASIC_UPDATE or RELATION_MBEAN_UPDATE, depending if the relation is a MBean or not) per updated role.</source>
          <target state="translated">更新されたロールごとに1つの通知(RELATION_BASIC_UPDATEまたはRELATION_MBEAN_UPDATEタイプのRelationNotification)を送信します。</target>
        </trans-unit>
        <trans-unit id="af60309eed9f0f92d76603dc55ac020d8599207d" translate="yes" xml:space="preserve">
          <source>Will start editing for node if there is a &lt;code&gt;cellEditor&lt;/code&gt; and &lt;code&gt;shouldSelectCell&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cellEditor&lt;/code&gt; があり、 &lt;code&gt;shouldSelectCell&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; を返す場合、ノードの編集を開始します。</target>
        </trans-unit>
        <trans-unit id="c95d75c28c35065fc1c57b0e876887193f122021" translate="yes" xml:space="preserve">
          <source>WinListener</source>
          <target state="translated">WinListener</target>
        </trans-unit>
        <trans-unit id="41dfc0a6c92707948578891c51d98c6443be63cc" translate="yes" xml:space="preserve">
          <source>Window</source>
          <target state="translated">Window</target>
        </trans-unit>
        <trans-unit id="5084a061070a3f1aa4d1ecab3a00df323a3b610e" translate="yes" xml:space="preserve">
          <source>Window events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;</source>
          <target state="translated">ウィンドウイベントは &lt;code&gt;enableEvents&lt;/code&gt; を介して有効になります</target>
        </trans-unit>
        <trans-unit id="652b21379200b4ccc460b4492fe0d5374614171a" translate="yes" xml:space="preserve">
          <source>Window focus events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;</source>
          <target state="translated">ウィンドウフォーカスイベントは、 &lt;code&gt;enableEvents&lt;/code&gt; を介して有効になります</target>
        </trans-unit>
        <trans-unit id="8ac26c71e069b6eaa7e969b40aec9f9b5620310d" translate="yes" xml:space="preserve">
          <source>Window.AccessibleAWTWindow</source>
          <target state="translated">Window.AccessibleAWTWindow</target>
        </trans-unit>
        <trans-unit id="507611730a02b402edd6e7ba76a6fcebba9f788e" translate="yes" xml:space="preserve">
          <source>Window.Type</source>
          <target state="translated">Window.Type</target>
        </trans-unit>
        <trans-unit id="5dca9b99152803aee06162ae5e180ed80d355a7c" translate="yes" xml:space="preserve">
          <source>WindowAdapter</source>
          <target state="translated">WindowAdapter</target>
        </trans-unit>
        <trans-unit id="d30877c43152fe36a3fd859538a40a5cdaf9bfe2" translate="yes" xml:space="preserve">
          <source>WindowConstants</source>
          <target state="translated">WindowConstants</target>
        </trans-unit>
        <trans-unit id="506bdfc6c0c9e73aacc009ccc59240f421dee55e" translate="yes" xml:space="preserve">
          <source>WindowEvent</source>
          <target state="translated">WindowEvent</target>
        </trans-unit>
        <trans-unit id="389aeec541bb01caf058a1c61a1a55c203773d3c" translate="yes" xml:space="preserve">
          <source>WindowFocusListener</source>
          <target state="translated">WindowFocusListener</target>
        </trans-unit>
        <trans-unit id="d1e4bbe2f756a9e07443c61cb2a25527b3f01627" translate="yes" xml:space="preserve">
          <source>WindowListener</source>
          <target state="translated">WindowListener</target>
        </trans-unit>
        <trans-unit id="36d800c05ccdf96a77f664405b24b1d515a7dcaa" translate="yes" xml:space="preserve">
          <source>WindowStateListener</source>
          <target state="translated">WindowStateListener</target>
        </trans-unit>
        <trans-unit id="a4ec586bd67aec6c5c53fd30fb990d116b2bc3ae" translate="yes" xml:space="preserve">
          <source>Windows are capable of generating the following WindowEvents: WindowOpened, WindowClosed, WindowGainedFocus, WindowLostFocus.</source>
          <target state="translated">Windows は以下の WindowEvents を生成することができます。WindowOpened、WindowClosed、WindowGainedFocus、WindowLostFocus。</target>
        </trans-unit>
        <trans-unit id="e736d7e9cd07fdd5619eb22e9d6ea04daf0e51ae" translate="yes" xml:space="preserve">
          <source>Windows cannot overlap the full-screen window. All other application windows will always appear beneath the full-screen window in the Z-order.</source>
          <target state="translated">ウィンドウはフルスクリーンウィンドウと重なることはできません。他のすべてのアプリケーションウィンドウは、常にフルスクリーンウィンドウの下にZ順に表示されます。</target>
        </trans-unit>
        <trans-unit id="593ac35fa2bd24a666d120e3789447fbf9c25e2a" translate="yes" xml:space="preserve">
          <source>WindowsNT/x86/4.0/lib/stat.dll</source>
          <target state="translated">WindowsNT/x86/4.0/lib/stat.dll</target>
        </trans-unit>
        <trans-unit id="564f8c6e76fbd512be2e38dabdfdd61550d0c3cc" translate="yes" xml:space="preserve">
          <source>With</source>
          <target state="translated">With</target>
        </trans-unit>
        <trans-unit id="de916a95a394d60b5970c72c8e49b95595c376f5" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;SEPARATE_DOCUMENTS_UNCOLLATED_COPIES&lt;/code&gt; and &lt;code&gt;SEPARATE_DOCUMENTS_COLLATED_COPIES&lt;/code&gt;, documents &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are stapled separately.</source>
          <target state="translated">&lt;code&gt;SEPARATE_DOCUMENTS_UNCOLLATED_COPIES&lt;/code&gt; と &lt;code&gt;SEPARATE_DOCUMENTS_COLLATED_COPIES&lt;/code&gt; 、書類及び &lt;code&gt;b&lt;/code&gt; 、別々に綴じられます。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ce065a2774362ea1c0b4b2a9c6d578002c87fa95" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;SINGLE_DOCUMENT&lt;/code&gt;, documents &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are stapled together as a single document with no regard to new sheets.</source>
          <target state="translated">&lt;code&gt;SINGLE_DOCUMENT&lt;/code&gt; 、書類及び &lt;code&gt;b&lt;/code&gt; 、新しいシートに関わらず、単一のドキュメントとして一緒に綴じられます。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="000a0d000df5c6984649ddbd1ee6d53891ba7395" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;SINGLE_DOCUMENT_NEW_SHEET&lt;/code&gt;, documents &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are stapled together as a single document, but document &lt;code&gt;b&lt;/code&gt; starts on a new sheet.</source>
          <target state="translated">&lt;code&gt;SINGLE_DOCUMENT_NEW_SHEET&lt;/code&gt; 、書類及び &lt;code&gt;b&lt;/code&gt; 、単一の文書として一緒にホチキス止めされているが、文書の &lt;code&gt;b&lt;/code&gt; が新しいシートに開始されます。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="702bb02b91946be2e7d1e7c71af340e7112b4fc2" translate="yes" xml:space="preserve">
          <source>With SEPARATE_DOCUMENTS_UNCOLLATED_COPIES and SEPARATE_DOCUMENTS_COLLATED_COPIES, documents &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are stapled separately.</source>
          <target state="translated">SEPARATE_DOCUMENTS_UNCOLLATED_COPIESおよびSEPARATE_DOCUMENTS_COLLATED_COPIESを使用 &lt;code&gt;a&lt;/code&gt; と、ドキュメントaと &lt;code&gt;b&lt;/code&gt; は別々にホチキス止めされます。</target>
        </trans-unit>
        <trans-unit id="c6940d372bef23c372a894b2611764845d087573" translate="yes" xml:space="preserve">
          <source>With SINGLE_DOCUMENT, documents &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are stapled together as a single document with no regard to new sheets.</source>
          <target state="translated">SINGLE_DOCUMENTを使用 &lt;code&gt;a&lt;/code&gt; と、ドキュメントaと &lt;code&gt;b&lt;/code&gt; が新しいシートに関係なく1つのドキュメントとしてステープルされます。</target>
        </trans-unit>
        <trans-unit id="6aea5edd4595a1343229324f4788e3637ab7593b" translate="yes" xml:space="preserve">
          <source>With SINGLE_DOCUMENT_NEW_SHEET, documents &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are stapled together as a single document, but document &lt;code&gt;b&lt;/code&gt; starts on a new sheet.</source>
          <target state="translated">SINGLE_DOCUMENT_NEW_SHEETを使用 &lt;code&gt;a&lt;/code&gt; と、ドキュメントaと &lt;code&gt;b&lt;/code&gt; が1つのドキュメントとしてステープルされますが、ドキュメント &lt;code&gt;b&lt;/code&gt; は新しいシートから始まります。</target>
        </trans-unit>
        <trans-unit id="7a7f0a9b6a27b5ea272b2faa2111b50312da5684" translate="yes" xml:space="preserve">
          <source>With Version 0 cookies, values should not contain white space, brackets, parentheses, equals signs, commas, double quotes, slashes, question marks, at signs, colons, and semicolons. Empty values may not behave the same way on all browsers.</source>
          <target state="translated">バージョン0のクッキーでは、値に空白文字、括弧、括弧、等号、カンマ、二重引用符、スラッシュ、疑問符、アットサイン、コロン、セミコロンを含めてはいけません。空の値は、すべてのブラウザで同じように動作するとは限りません。</target>
        </trans-unit>
        <trans-unit id="bf66f17ae2780078f9fea48695737926c268f057" translate="yes" xml:space="preserve">
          <source>With a PermissionCollection, you can:</source>
          <target state="translated">PermissionCollectionでは、以下のことができます。</target>
        </trans-unit>
        <trans-unit id="ddf292b706b0ea961ebe157c83d2d5ff0fdfda77" translate="yes" xml:space="preserve">
          <source>With a reference to the &lt;code&gt;&amp;lt;widget&amp;gt;&lt;/code&gt; element, a relative XPath expression can be written to select the &lt;code&gt;&amp;lt;manufacturer&amp;gt;&lt;/code&gt; child element:</source>
          <target state="translated">&lt;code&gt;&amp;lt;widget&amp;gt;&lt;/code&gt; 要素を参照すると、相対XPath式を記述して、 &lt;code&gt;&amp;lt;manufacturer&amp;gt;&lt;/code&gt; 子要素を選択できます。</target>
        </trans-unit>
        <trans-unit id="7921a6a2bd87af6e70cb7478096f1f706c0eed48" translate="yes" xml:space="preserve">
          <source>With attribute type synonyms, a directory can assign multiple names to the same attribute. For example, &quot;cn&quot; and &quot;commonName&quot; might both refer to the same attribute. Asking for &quot;cn&quot; might return the &quot;commonName&quot; attribute.</source>
          <target state="translated">属性タイプの同義語を使うと、ディレクトリは同じ属性に複数の名前を割り当てることができます。例えば、&quot;cn&quot; と &quot;commonName&quot; は両方とも同じ属性を参照しているかもしれません。cn&quot; を求めると、&quot;commonName&quot; 属性が返ってくるかもしれません。</target>
        </trans-unit>
        <trans-unit id="342174bb35309e577ba49df9b6a0136aab3a5327" translate="yes" xml:space="preserve">
          <source>With both intervals and &lt;code&gt;Spring&lt;/code&gt;s we can define &quot;-&quot; and &lt;em&gt;min&lt;/em&gt; in terms of negation:</source>
          <target state="translated">間隔と &lt;code&gt;Spring&lt;/code&gt; の両方を使用して、否定の観点から「-」と&lt;em&gt;minを&lt;/em&gt;定義できます。</target>
        </trans-unit>
        <trans-unit id="4b146947ce59686776207df75fa9d667325f9863" translate="yes" xml:space="preserve">
          <source>With most look and feels, the user can drag out a tool bar into a separate window (unless the &lt;code&gt;floatable&lt;/code&gt; property is set to &lt;code&gt;false&lt;/code&gt;). For drag-out to work correctly, it is recommended that you add &lt;code&gt;JToolBar&lt;/code&gt; instances to one of the four &quot;sides&quot; of a container whose layout manager is a &lt;code&gt;BorderLayout&lt;/code&gt;, and do not add children to any of the other four &quot;sides&quot;.</source>
          <target state="translated">ほとんどのルックアンドフィールでは、ユーザーはツールバーを別のウィンドウにドラッグできます（ &lt;code&gt;floatable&lt;/code&gt; プロパティが &lt;code&gt;false&lt;/code&gt; に設定されている場合を除く）。ドラッグアウトを正しく機能させるには、レイアウトマネージャーが &lt;code&gt;BorderLayout&lt;/code&gt; であるコンテナーの4つの「サイド」の1つに &lt;code&gt;JToolBar&lt;/code&gt; インスタンスを追加し、他の4つの「サイド」のいずれにも子を追加しないことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="0aee19fea36c937253e601d256a319bb86142c5d" translate="yes" xml:space="preserve">
          <source>With some complex reduction operations, for example a &lt;code&gt;collect()&lt;/code&gt; that produces a &lt;code&gt;Map&lt;/code&gt;, such as:</source>
          <target state="translated">次のような &lt;code&gt;Map&lt;/code&gt; を生成する &lt;code&gt;collect()&lt;/code&gt; など、いくつかの複雑なリダクション操作を使用します。</target>
        </trans-unit>
        <trans-unit id="5e5f811ed587d929e889b7d29ba9d4370ee0e985" translate="yes" xml:space="preserve">
          <source>With the above code, the health status is collected unnecessarily even when the log level FINER is disabled. With the Supplier-accepting version as below, the status will only be collected when the log level FINER is enabled.</source>
          <target state="translated">上記のコードでは、ログレベルFINERを無効にしても不必要に健康状態が収集されてしまいます。以下のようなサプライヤ受け入れバージョンでは、ログレベルFINERが有効な場合にのみステータスが収集されます。</target>
        </trans-unit>
        <trans-unit id="dc2156a4e2b3c1c33c618ec6f586c7ea7f4199d8" translate="yes" xml:space="preserve">
          <source>With the exception of re-imaging an entire document for multiple collated copies, the increasing page index order means that when page N is requested if a client needs to calculate page break position, it may safely discard any state related to pages &amp;lt; N, and make current that for page N. &quot;State&quot; usually is just the calculated position in the document that corresponds to the start of the page.</source>
          <target state="translated">複数の照合コピー用にドキュメント全体を再イメージングすることを除いて、ページインデックスの順序が増えるということは、クライアントが改ページ位置を計算する必要がある場合にページNが要求されたときに、ページ&amp;lt;Nに関連する状態を安全に破棄できることを意味します。 Nページの現在の状態にします。「状態」は通常、ページの開始に対応するドキュメント内の計算された位置です。</target>
        </trans-unit>
        <trans-unit id="2024497e2bf2f02b354dda9dd14a083e17ac2ff2" translate="yes" xml:space="preserve">
          <source>With the exception of selected printer, the PrinterJob state is not updated to reflect the user's changes. For the selections to affect a printer job, the attributes must be specified in the call to the &lt;code&gt;print(PrintRequestAttributeSet)&lt;/code&gt; method. If using the Pageable interface, clients which intend to use media selected by the user must create a PageFormat derived from the user's selections. If the user cancels the dialog, the attributes will not reflect any changes made by the user.</source>
          <target state="translated">選択したプリンターを除いて、PrinterJobの状態はユーザーの変更を反映するように更新されません。選択がプリンタージョブに影響を与えるには、 &lt;code&gt;print(PrintRequestAttributeSet)&lt;/code&gt; メソッドの呼び出しで属性を指定する必要があります。 Pageableインターフェイスを使用する場合、ユーザーが選択したメディアを使用する予定のクライアントは、ユーザーの選択から派生したPageFormatを作成する必要があります。ユーザーがダイアログをキャンセルした場合、属性にはユーザーが行った変更は反映されません。</target>
        </trans-unit>
        <trans-unit id="e344a6ab10b8325512c520c0690b8d3e445352c1" translate="yes" xml:space="preserve">
          <source>With the following HTML content:</source>
          <target state="translated">以下のようなHTMLの内容で</target>
        </trans-unit>
        <trans-unit id="618b01eeb003ee4b1ffdf3f6106417f6de534070" translate="yes" xml:space="preserve">
          <source>With the information retrieved from the methods &lt;code&gt;getStatus&lt;/code&gt; and &lt;code&gt;getConflictValue&lt;/code&gt;, the application may make a determination as to which value should be persisted in the data source. The application then calls the &lt;code&gt;SyncResolver&lt;/code&gt; method &lt;code&gt;setResolvedValue&lt;/code&gt;, which sets the value to be persisted in the &lt;code&gt;RowSet&lt;/code&gt; object and also in the data source.</source>
          <target state="translated">&lt;code&gt;getStatus&lt;/code&gt; メソッドと &lt;code&gt;getConflictValue&lt;/code&gt; メソッドから取得した情報を使用して、アプリケーションは、データソースに永続化する値を決定できます。次に、アプリケーションは &lt;code&gt;SyncResolver&lt;/code&gt; メソッド &lt;code&gt;setResolvedValue&lt;/code&gt; を呼び出します。このメソッドは、 &lt;code&gt;RowSet&lt;/code&gt; オブジェクトとデータソースに永続化される値を設定します。</target>
        </trans-unit>
        <trans-unit id="e8ff6037d8867d2b3d47892d80515cedec13ebae" translate="yes" xml:space="preserve">
          <source>With this increased flexibility comes additional responsibility. The absence of block-structured locking removes the automatic release of locks that occurs with &lt;code&gt;synchronized&lt;/code&gt; methods and statements. In most cases, the following idiom should be used:</source>
          <target state="translated">この柔軟性の向上により、追加の責任が生じます。ブロック構造のロックがないため、 &lt;code&gt;synchronized&lt;/code&gt; メソッドとステートメントで発生するロックの自動解放が削除されます。ほとんどの場合、次のイディオムを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="d3c389bbd15c03f9dd881098991d518ed6f3894d" translate="yes" xml:space="preserve">
          <source>Within a</source>
          <target state="translated">以内に</target>
        </trans-unit>
        <trans-unit id="eaa46bf4774a02d445fea7fa33dbb744f6506eaa" translate="yes" xml:space="preserve">
          <source>Within a &lt;code&gt;Document&lt;/code&gt;, &lt;code&gt;DocumentFragment&lt;/code&gt;, or &lt;code&gt;Entity&lt;/code&gt; being serialized, &lt;code&gt;Nodes&lt;/code&gt; are processed as follows</source>
          <target state="translated">シリアル化される &lt;code&gt;Document&lt;/code&gt; 、 &lt;code&gt;DocumentFragment&lt;/code&gt; 、または &lt;code&gt;Entity&lt;/code&gt; 内では、 &lt;code&gt;Nodes&lt;/code&gt; は次のように処理されます。</target>
        </trans-unit>
        <trans-unit id="0d2a1649d264fff3b41ff1e86e92590c9426695c" translate="yes" xml:space="preserve">
          <source>Within a bracket expression the &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;\&lt;/code&gt; characters match themselves. The (&lt;code&gt;-&lt;/code&gt;) character matches itself if it is the first character within the brackets, or the first character after the &lt;code&gt;!&lt;/code&gt; if negating.</source>
          <target state="translated">ブラケット表現の中で &lt;code&gt;*&lt;/code&gt; 、 &lt;code&gt;?&lt;/code&gt; および &lt;code&gt;\&lt;/code&gt; 文字はそれ自体と一致します。（ &lt;code&gt;-&lt;/code&gt; ）文字は、括弧内の最初の文字、または &lt;code&gt;!&lt;/code&gt; の後の最初の文字である場合、それ自体と一致します。否定する場合。</target>
        </trans-unit>
        <trans-unit id="83d916c5bbfc33ee16ea209e9686d45596a9c2ac" translate="yes" xml:space="preserve">
          <source>Within each &lt;code&gt;ClassLoader&lt;/code&gt; instance all classes from the same java package have the same Package object. The static methods allow a package to be found by name or the set of all packages known to the current class loader to be found.</source>
          <target state="translated">各 &lt;code&gt;ClassLoader&lt;/code&gt; インスタンス内では、同じJavaパッケージのすべてのクラスが同じPackageオブジェクトを持っています。静的メソッドを使用すると、パッケージを名前で検索したり、現在のクラスローダーが認識しているすべてのパッケージのセットを検索したりできます。</target>
        </trans-unit>
        <trans-unit id="0668371fa9b725d274f510f8d695c661c8f6c217" translate="yes" xml:space="preserve">
          <source>Within each such subset only the most specific methods are selected. Let method M be a method from a set of methods with same VM signature (return type, name, parameter types). M is most specific if there is no such method N != M from the same set, such that N is more specific than M. N is more specific than M if:</source>
          <target state="translated">このような各サブセット内では、最も特定のメソッドのみが選択されます。メソッド M を、同じ VM シグネチャ (戻り値の型、名前、パラメータの型)を持つメソッドの集合からのメソッドとします。同じセットの中に N !=M のようなメソッドが存在しない場合、N は M よりも特異的です。</target>
        </trans-unit>
        <trans-unit id="ed5391ea4c2aede0070693a361a2994f5e4a6a05" translate="yes" xml:space="preserve">
          <source>Within each such subset only the most specific methods are selected. Let method M be a method from a set of methods with same signature and return type. M is most specific if there is no such method N != M from the same set, such that N is more specific than M. N is more specific than M if:</source>
          <target state="translated">このような各サブセット内では、最も特定のメソッドのみが選択されます。メソッド M を、同じシグネチャと戻り値の型を持つメソッドの集合からのメソッドとします。N が M よりも特異的であるように、同じセットからそのようなメソッド N !=M が存在しない場合、M は最も特異的です。</target>
        </trans-unit>
        <trans-unit id="8f444b6815c4d0578f6ec1b24cacc82f1de3a985" translate="yes" xml:space="preserve">
          <source>Within markup, but outside of attributes, any occurrence of a character that cannot be represented in the output character encoding is reported as a &lt;code&gt;DOMError&lt;/code&gt; fatal error. An example would be serializing the element &amp;lt;LaCa&amp;ntilde;ada/&amp;gt; with &lt;code&gt;encoding=&quot;us-ascii&quot;&lt;/code&gt;. This will result with a generation of a &lt;code&gt;DOMError&lt;/code&gt; &quot;wf-invalid-character-in-node-name&quot; (as proposed in &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-well-formed&quot;&gt;well-formed&lt;/a&gt;&quot;).</source>
          <target state="translated">マークアップ内、ただし属性外では、出力文字エンコードで表現できない文字が発生すると、 &lt;code&gt;DOMError&lt;/code&gt; の致命的なエラーとして報告されます。例としては、要素&amp;lt;LaCa&amp;ntilde;ada/&amp;gt;を &lt;code&gt;encoding=&quot;us-ascii&quot;&lt;/code&gt; でシリアル化する場合があります。これにより、 &lt;code&gt;DOMError&lt;/code&gt; 「wf-invalid-character-in-node-name」が&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-well-formed&quot;&gt;生成されます&lt;/a&gt;（「整形式」で提案されているとおり）。</target>
        </trans-unit>
        <trans-unit id="e65be46b0d82a65208f681b65c6b6af3ea153929" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;activate&lt;/code&gt; method, a controller obtains initial values by querying the &lt;code&gt;IIOMetadata&lt;/code&gt; object's settings, either using the XML DOM tree or a plug-in specific interface, modifies values by whatever means, then modifies the &lt;code&gt;IIOMetadata&lt;/code&gt; object's settings, using either the &lt;code&gt;setFromTree&lt;/code&gt; or &lt;code&gt;mergeTree&lt;/code&gt; methods, or a plug-in specific interface. In general, applications may expect that when the &lt;code&gt;activate&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;IIOMetadata&lt;/code&gt; object is ready for use in a write operation.</source>
          <target state="translated">&lt;code&gt;activate&lt;/code&gt; メソッド内で、コントローラーは、XML DOMツリーまたはプラグイン固有のインターフェースを使用して &lt;code&gt;IIOMetadata&lt;/code&gt; オブジェクトの設定をクエリすることで初期値を取得し、何らかの方法で値を変更してから、 &lt;code&gt;setFromTree&lt;/code&gt; または &lt;code&gt;mergeTree&lt;/code&gt; を使用して &lt;code&gt;IIOMetadata&lt;/code&gt; オブジェクトの設定を変更します。メソッド、またはプラグイン固有のインターフェース。一般に、アプリケーションは、 &lt;code&gt;activate&lt;/code&gt; メソッドが &lt;code&gt;true&lt;/code&gt; を返すと、 &lt;code&gt;IIOMetadata&lt;/code&gt; オブジェクトが書き込み操作で使用できるようになることを期待できます。</target>
        </trans-unit>
        <trans-unit id="83029e44e09a5ba0623249885430579f4267be4f" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;activate&lt;/code&gt; method, a controller obtains initial values by querying the &lt;code&gt;IIOParam&lt;/code&gt; object's &lt;code&gt;get&lt;/code&gt; methods, modifies values by whatever means, then invokes the &lt;code&gt;IIOParam&lt;/code&gt; object's &lt;code&gt;set&lt;/code&gt; methods to modify the appropriate settings. Normally, these &lt;code&gt;set&lt;/code&gt; methods will be invoked all at once at a final commit in order that a cancel operation not disturb existing values. In general, applications may expect that when the &lt;code&gt;activate&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;IIOParam&lt;/code&gt; object is ready for use in a read or write operation.</source>
          <target state="translated">&lt;code&gt;activate&lt;/code&gt; メソッド内で、コントローラーは &lt;code&gt;IIOParam&lt;/code&gt; オブジェクトの &lt;code&gt;get&lt;/code&gt; メソッドにクエリを実行して初期値を取得し、何らかの方法で値を変更してから、 &lt;code&gt;IIOParam&lt;/code&gt; オブジェクトの &lt;code&gt;set&lt;/code&gt; メソッドを呼び出して適切な設定を変更します。通常、これらの &lt;code&gt;set&lt;/code&gt; メソッドは、キャンセル操作が既存の値に影響を与えないように、最終コミット時に一度に呼び出されます。一般に、アプリケーションは、 &lt;code&gt;activate&lt;/code&gt; メソッドが &lt;code&gt;true&lt;/code&gt; を返すと、 &lt;code&gt;IIOParam&lt;/code&gt; オブジェクトが読み取りまたは書き込み操作で使用できるようになることを期待できます。</target>
        </trans-unit>
        <trans-unit id="76c301b37038720275724c001f96646390680990" translate="yes" xml:space="preserve">
          <source>Within the character data of a document (outside of markup), any characters that cannot be represented directly are replaced with character references. Occurrences of '&amp;lt;' and '&amp;amp;' are replaced by the predefined entities &amp;amp;lt; and &amp;amp;amp;. The other predefined entities (&amp;amp;gt;, &amp;amp;apos;, and &amp;amp;quot;) might not be used, except where needed (e.g. using &amp;amp;gt; in cases such as ']]&amp;gt;'). Any characters that cannot be represented directly in the output character encoding are serialized as numeric character references (and since character encoding standards commonly use hexadecimal representations of characters, using the hexadecimal representation when serializing character references is encouraged).</source>
          <target state="translated">ドキュメントの文字データ内（マークアップ以外）では、直接表現できない文字は文字参照に置き換えられます。 '&amp;lt;'および '＆'の出現は、事前定義されたエンティティ＆lt;に置き換えられます。および＆amp;。他の事前定義されたエンティティ（＆gt;、＆apos ;、および＆quot;）は、必要な場合を除いて使用されない場合があります（たとえば、 ']]&amp;gt;'などの場合は＆gt;を使用します。出力文字エンコードで直接表現できない文字は、数値文字参照としてシリアル化されます（文字エンコード標準では通常、文字の16進表現が使用されるため、文字参照をシリアル化するときに16進表現を使用することをお勧めします）。</target>
        </trans-unit>
        <trans-unit id="1759a0ebe8a5e5c04ff2fdb42ee3e41043aa418f" translate="yes" xml:space="preserve">
          <source>Without anchoring bounds, the boundaries of this matcher's region will not match anchors such as ^ and $.</source>
          <target state="translated">アンカリング境界がないと、このマッチャーの領域の境界は ^ や $ のようなアンカーとは一致しません。</target>
        </trans-unit>
        <trans-unit id="d683f7eface7d10e82e3f102080ec5410bd6835c" translate="yes" xml:space="preserve">
          <source>Without this warning, an applet may pop up windows without the user knowing that they belong to an applet. Since users may make security-sensitive decisions based on whether or not the window belongs to an applet (entering a username and password into a dialog box, for example), disabling this warning banner may allow applets to trick the user into entering such information.</source>
          <target state="translated">この警告がない場合、アプレットはユーザーがアプレットに属していることを知らずにウィンドウをポップアップさせることがあります。ユーザーは、ウィンドウがアプレットに属するかどうかに基づいてセキュリティ上の重要な決定を行う可能性があるため(例えば、ダイアログボックスにユーザー名とパスワードを入力するなど)、この警告バナーを無効にすると、アプレットがユーザーを騙してそのような情報を入力させてしまう可能性があります。</target>
        </trans-unit>
        <trans-unit id="6fd52a68c735f034b00232a476c8c2e710db36a9" translate="yes" xml:space="preserve">
          <source>Word boundary analysis is used by search and replace functions, as well as within text editing applications that allow the user to select words with a double click. Word selection provides correct interpretation of punctuation marks within and following words. Characters that are not part of a word, such as symbols or punctuation marks, have word-breaks on both sides.</source>
          <target state="translated">単語境界分析は、検索や置換機能や、ダブルクリックで単語を選択できるテキスト編集アプリケーションで使用されています。単語の選択では、単語内や単語に続く句読点を正しく解釈することができます。記号や句読点など、単語の一部ではない文字には、両側に改行があります。</target>
        </trans-unit>
        <trans-unit id="99edd8c8e615e373739d2cdd38a8942b8a573113" translate="yes" xml:space="preserve">
          <source>Worker</source>
          <target state="translated">Worker</target>
        </trans-unit>
        <trans-unit id="6e99a8e4272c2db9e95f06a1f314a0f285a61837" translate="yes" xml:space="preserve">
          <source>Would result in the string '123-____'. If &lt;code&gt;setPlaceholder(&quot;555-1212&quot;)&lt;/code&gt; was invoked '123-1212' would result. The placeholder String is only used on the initial format, on subsequent formats only the placeholder character will be used.</source>
          <target state="translated">文字列「123 -____」になります。場合 &lt;code&gt;setPlaceholder(&quot;555-1212&quot;)&lt;/code&gt; 呼び出された「123から1212には、」結果となります。プレースホルダー文字列は初期フォーマットでのみ使用され、後続のフォーマットではプレースホルダー文字のみが使用されます。</target>
        </trans-unit>
        <trans-unit id="642d596b44e19ab47c9e267aa3cf4a6030e0380b" translate="yes" xml:space="preserve">
          <source>Wrap a key.</source>
          <target state="translated">鍵を包む。</target>
        </trans-unit>
        <trans-unit id="3bcf468a4c3b40978bdee293e80fc65249f9482b" translate="yes" xml:space="preserve">
          <source>Wrap an existing exception in a SAXParseException.</source>
          <target state="translated">既存の例外をSAXParseExceptionでラップします。</target>
        </trans-unit>
        <trans-unit id="b0b650cb303bad45cc633704145a571455dd7664" translate="yes" xml:space="preserve">
          <source>Wrap an existing exception in a TransformerConfigurationException.</source>
          <target state="translated">既存の例外を TransformerConfigurationException でラップします。</target>
        </trans-unit>
        <trans-unit id="9b39d6715671bdb2580af79800238414d13f1fd7" translate="yes" xml:space="preserve">
          <source>Wrap an existing exception in a TransformerException.</source>
          <target state="translated">既存の例外を TransformerException でラップします。</target>
        </trans-unit>
        <trans-unit id="0c3ecd9442f9e1b1059ee6690619be457c11839a" translate="yes" xml:space="preserve">
          <source>Wrapped value (&lt;code&gt;Integer.valueOf(5)&lt;/code&gt;, &lt;code&gt;Boolean.FALSE&lt;/code&gt;, etc)</source>
          <target state="translated">ラップされた値（ &lt;code&gt;Integer.valueOf(5)&lt;/code&gt; 、 &lt;code&gt;Boolean.FALSE&lt;/code&gt; など）</target>
        </trans-unit>
        <trans-unit id="adbbb2fc6c4f8e1a93cb3431a12402bc3b7237ec" translate="yes" xml:space="preserve">
          <source>WrappedPlainView</source>
          <target state="translated">WrappedPlainView</target>
        </trans-unit>
        <trans-unit id="a9ebad9ce612c251b607a54c6d2d4842c89b63b2" translate="yes" xml:space="preserve">
          <source>Wrapper</source>
          <target state="translated">Wrapper</target>
        </trans-unit>
        <trans-unit id="2dbad62d494925b0cc5a9b12acb2cba9f5175ae5" translate="yes" xml:space="preserve">
          <source>Wrapper for primitive graphics calls.</source>
          <target state="translated">プリミティブグラフィックスコールのラッパー。</target>
        </trans-unit>
        <trans-unit id="92704fc2036355b575a4c4fbf65bd7b09813a44e" translate="yes" xml:space="preserve">
          <source>Wrapping the attribute value into an Annotation object guarantees that adjacent text runs don't get merged even if the attribute values are equal, and indicates to text containers that the attribute should be discarded if the underlying text is modified.</source>
          <target state="translated">属性値をアノテーションオブジェクトにラッピングすることで、属性値が同じであっても隣接するテキストの実行がマージされないことを保証し、テキストコンテナに対して、基礎となるテキストが変更された場合にはその属性を破棄すべきであることを示します。</target>
        </trans-unit>
        <trans-unit id="cca5fcd7b5b7c14fbea5ee4fc3296a93d35e1da8" translate="yes" xml:space="preserve">
          <source>Wraps a byte array into a buffer.</source>
          <target state="translated">バイト配列をバッファにラップします。</target>
        </trans-unit>
        <trans-unit id="3e43b98c51021b6537868fda39974c26611122c5" translate="yes" xml:space="preserve">
          <source>Wraps a byte array to be sent to the client.</source>
          <target state="translated">クライアントに送信するバイト配列をラップします。</target>
        </trans-unit>
        <trans-unit id="64cfb840ede8be7ea7901c7dfd0a6e52d56476fa" translate="yes" xml:space="preserve">
          <source>Wraps a byte array to be sent to the client. This method can be called only after the authentication exchange has completed (i.e., when &lt;code&gt;isComplete()&lt;/code&gt; returns true) and only if the authentication exchange has negotiated integrity and/or privacy as the quality of protection; otherwise, a &lt;code&gt;SaslException&lt;/code&gt; is thrown.</source>
          <target state="translated">クライアントに送信されるバイト配列をラップします。このメソッドは、認証交換が完了した後（つまり、 &lt;code&gt;isComplete()&lt;/code&gt; がtrueを返したとき）にのみ、認証交換が整合性やプライバシーを保護の品質としてネゴシエートした場合にのみ呼び出すことができます。それ以外の場合は、 &lt;code&gt;SaslException&lt;/code&gt; がスローされます。</target>
        </trans-unit>
        <trans-unit id="b1be73d2494fd5ecf63ee8bc9278f31e2926d14e" translate="yes" xml:space="preserve">
          <source>Wraps a byte array to be sent to the server.</source>
          <target state="translated">サーバに送信するバイト配列をラップします。</target>
        </trans-unit>
        <trans-unit id="c58ede29ff7ee729e1131d3a1d2647f530332ea4" translate="yes" xml:space="preserve">
          <source>Wraps a byte array to be sent to the server. This method can be called only after the authentication exchange has completed (i.e., when &lt;code&gt;isComplete()&lt;/code&gt; returns true) and only if the authentication exchange has negotiated integrity and/or privacy as the quality of protection; otherwise, an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.</source>
          <target state="translated">サーバーに送信されるバイト配列をラップします。このメソッドは、認証交換が完了した後（つまり、 &lt;code&gt;isComplete()&lt;/code&gt; がtrueを返したとき）にのみ、認証交換が整合性やプライバシーを保護の品質としてネゴシエートした場合にのみ呼び出すことができます。それ以外の場合は、 &lt;code&gt;IllegalStateException&lt;/code&gt; がスローされます。</target>
        </trans-unit>
        <trans-unit id="67b1374ef549a7e954a05b9ec7009fb8bc41734f" translate="yes" xml:space="preserve">
          <source>Wraps a char array into a buffer.</source>
          <target state="translated">char配列をバッファにラップします。</target>
        </trans-unit>
        <trans-unit id="f7b95771a9ecdaf8c4f0c45b0a3050463bc0fb11" translate="yes" xml:space="preserve">
          <source>Wraps a character sequence into a buffer.</source>
          <target state="translated">文字列をバッファにラップします。</target>
        </trans-unit>
        <trans-unit id="9cf8f103948e6b6d2a2e2dcbd8e83ddda5dcdf8e" translate="yes" xml:space="preserve">
          <source>Wraps a double array into a buffer.</source>
          <target state="translated">ダブル配列をバッファにラップします.</target>
        </trans-unit>
        <trans-unit id="7c38a95681b8bf75718f777dc7681e478936ebe7" translate="yes" xml:space="preserve">
          <source>Wraps a float array into a buffer.</source>
          <target state="translated">float配列をバッファにラップします。</target>
        </trans-unit>
        <trans-unit id="e875d8d4d7f1a26ef5338640a04b767dbb14b0fd" translate="yes" xml:space="preserve">
          <source>Wraps a long array into a buffer.</source>
          <target state="translated">長い配列をバッファにラップします.</target>
        </trans-unit>
        <trans-unit id="7a45b9eefe39a4cdc4f096f2050c4639eeae92e4" translate="yes" xml:space="preserve">
          <source>Wraps a short array into a buffer.</source>
          <target state="translated">短い配列をバッファにラップします。</target>
        </trans-unit>
        <trans-unit id="35438f1499f1a894d95345e3941ad2b29de6319a" translate="yes" xml:space="preserve">
          <source>Wraps an &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; if the MBeanInfo passed in parameter is null.</source>
          <target state="translated">パラメータで渡されたMBeanInfoがnullの場合、&lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; を&lt;/a&gt;ラップします。</target>
        </trans-unit>
        <trans-unit id="c1d32f710973f4fd61bdd696efd70daf69bd5b7d" translate="yes" xml:space="preserve">
          <source>Wraps an &lt;a href=&quot;../../../../java.base/java/lang/illegalstateexception&quot;&gt;&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/a&gt; if the ModelMBean is currently registered in the MBeanServer.</source>
          <target state="translated">ModelMBeanが現在MBeanServerに登録されている場合、&lt;a href=&quot;../../../../java.base/java/lang/illegalstateexception&quot;&gt; &lt;code&gt;IllegalStateException&lt;/code&gt; を&lt;/a&gt;ラップします。</target>
        </trans-unit>
        <trans-unit id="526e84458ea6e6f011221fcab33932da84f5ba1d" translate="yes" xml:space="preserve">
          <source>Wraps an &lt;a href=&quot;../../../java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; if the MBeanInfo passed in parameter is null.</source>
          <target state="translated">パラメータで渡されたMBeanInfoがnullの場合、&lt;a href=&quot;../../../java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; を&lt;/a&gt;ラップします。</target>
        </trans-unit>
        <trans-unit id="5b976fffcdb3184f30e314babf43e006ea0f5ad5" translate="yes" xml:space="preserve">
          <source>Wraps an &lt;a href=&quot;../../../java/lang/illegalstateexception&quot;&gt;&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/a&gt; if the ModelMBean is currently registered in the MBeanServer.</source>
          <target state="translated">ModelMBeanが現在MBeanServerに登録されている場合、&lt;a href=&quot;../../../java/lang/illegalstateexception&quot;&gt; &lt;code&gt;IllegalStateException&lt;/code&gt; を&lt;/a&gt;ラップします。</target>
        </trans-unit>
        <trans-unit id="0edf81e480b4a49c11c2dbafe5b84b7869d1aa13" translate="yes" xml:space="preserve">
          <source>Wraps an &lt;a href=&quot;ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; with an unchecked exception.</source>
          <target state="translated">未チェックの例外で&lt;a href=&quot;ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt;をラップします。</target>
        </trans-unit>
        <trans-unit id="6afb0fee856f2866c314288124d5fc7949a1696a" translate="yes" xml:space="preserve">
          <source>Wraps an int array into a buffer.</source>
          <target state="translated">int配列をバッファにラップします。</target>
        </trans-unit>
        <trans-unit id="f46c77a2dce440c1be651d2cef94b153c69cfdb1" translate="yes" xml:space="preserve">
          <source>Wraps an output stream for encoding byte data using the &lt;a href=&quot;base64&quot;&gt;&lt;code&gt;Base64&lt;/code&gt;&lt;/a&gt; encoding scheme.</source>
          <target state="translated">&lt;a href=&quot;base64&quot;&gt; &lt;code&gt;Base64&lt;/code&gt; &lt;/a&gt;エンコードスキームを使用してバイトデータをエンコードするための出力ストリームをラップします。</target>
        </trans-unit>
        <trans-unit id="12b5eee30743d96f3a2465542a9df99878df7b23" translate="yes" xml:space="preserve">
          <source>Wraps exceptions thrown by the preRegister(), preDeregister() methods of the &lt;code&gt;MBeanRegistration&lt;/code&gt; interface.</source>
          <target state="translated">&lt;code&gt;MBeanRegistration&lt;/code&gt; インターフェースのpreRegister（）、preDeregister（）メソッドによってスローされた例外をラップします。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
