<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="0137a1cc90b7f7f164b60d3e6a0abb13294403cf" translate="yes" xml:space="preserve">
          <source>The functionality provided by the fts4aux module is now provided by &lt;a href=&quot;fts5#the_fts5vocab_virtual_table_module&quot;&gt;fts5vocab&lt;/a&gt;. The schema of these two tables is slightly different.</source>
          <target state="translated">fts4auxモジュールによって提供される機能は、fts5vocabによって提供されるように&lt;a href=&quot;fts5#the_fts5vocab_virtual_table_module&quot;&gt;なりました&lt;/a&gt;。これら2つのテーブルのスキーマは少し異なります。</target>
        </trans-unit>
        <trans-unit id="82f4a608941f31ed6516bc837d2ee3e175fc4792" translate="yes" xml:space="preserve">
          <source>The functionality required of each of the above functions is described in comments in sqlite3async.c.</source>
          <target state="translated">上記の各関数に必要な機能はsqlite3async.cのコメントに記載されています。</target>
        </trans-unit>
        <trans-unit id="a3e3ee73e4504a9b18df3710202691563a7ae8e5" translate="yes" xml:space="preserve">
          <source>The general purpose memory allocator is the most difficult memory pool to manage because it supports allocations of varying sizes. Since &lt;b&gt;n&lt;/b&gt; is a multiplier on &lt;b&gt;M&lt;/b&gt; we want to keep &lt;b&gt;n&lt;/b&gt; as small as possible. This argues for keeping the minimum allocation size for &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; as large as possible. In most applications, the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; is able to handle small allocations. So it is reasonable to set the minimum allocation size for &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; to 2, 4 or even 8 times the maximum size of a lookaside allocation. A minimum allocation size of 512 is a reasonable setting.</source>
          <target state="translated">汎用メモリアロケータは、さまざまなサイズの割り当てをサポートするため、管理が最も難しいメモリプールです。以来&lt;b&gt;、nは&lt;/b&gt;上の乗数である&lt;b&gt;Mは、&lt;/b&gt;我々は維持したい&lt;b&gt;nは&lt;/b&gt;できるだけ小さいです。これは、&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5の&lt;/a&gt;最小割り当てサイズをできるだけ大きく保つことを主張しています。ほとんどのアプリケーションでは、&lt;a href=&quot;malloc#lookaside&quot;&gt;lookasideメモリアロケータ&lt;/a&gt;は小さな割り当てを処理できます。したがって、&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5の&lt;/a&gt;最小割り当てサイズを、lookaside割り当ての最大サイズの2、4、または8倍に設定するのが妥当です。512の最小割り当てサイズが妥当な設定です。</target>
        </trans-unit>
        <trans-unit id="30bdbd95e17bffd329d217ead465e3fe28cd023c" translate="yes" xml:space="preserve">
          <source>The general rule is that indexes are only useful if there are WHERE-clause constraints on the left-most columns of the index. However, in some cases, SQLite is able to use an index even if the first few columns of the index are omitted from the WHERE clause but later columns are included.</source>
          <target state="translated">一般的なルールとしては、インデックスの左端の列に WHERE 句の制約がある場合にのみインデックスが有用であるということです。しかし、場合によっては、インデックスの最初の数列がWHERE句から省略されていても、それ以降の列が含まれている場合でも、SQLiteはインデックスを使用することができます。</target>
        </trans-unit>
        <trans-unit id="084577b6dd782fa1eb4651ff451c238f84ef2391" translate="yes" xml:space="preserve">
          <source>The general-purpose memory allocator (&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;).</source>
          <target state="translated">汎用メモリアロケータ（&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="21a012c95267cb8d2b8d45dbbd928793f6616b70" translate="yes" xml:space="preserve">
          <source>The generate_series Table-Valued Function</source>
          <target state="translated">generate_series テーブル値関数</target>
        </trans-unit>
        <trans-unit id="476dfd7c8482f7d1208e7bd9537292c089264e39" translate="yes" xml:space="preserve">
          <source>The generate_series table can be simulated using a &lt;a href=&quot;lang_with#recursivecte&quot;&gt;recursive common table expression&lt;/a&gt;. If the three parameters are $start, $end, and $step, then the equivalent common table expression is:</source>
          <target state="translated">generate_seriesテーブルは、&lt;a href=&quot;lang_with#recursivecte&quot;&gt;再帰的な共通テーブル式&lt;/a&gt;を使用してシミュレートできます。3つのパラメーターが$ start、$ end、および$ stepの場合、同等の共通テーブル式は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="4e3c394ee97ca6ac89b21ae3983e2fd5668b4aa8" translate="yes" xml:space="preserve">
          <source>The generate_series(START,END,STEP) &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; included in the SQLite source tree, and compiled into the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;. The generate_series() table has a single result column named &quot;value&quot; holding integer values and a number of rows determined by the parameters START, END, and STEP. The first row of the table has a value of START. Subsequent rows increase by STEP up to END.</source>
          <target state="translated">generate_series（START、END、STEP）&lt;a href=&quot;vtab#tabfunc2&quot;&gt;テーブル値関数&lt;/a&gt;は、SQLiteソースツリーに含まれる&lt;a href=&quot;loadext&quot;&gt;ロード可能な拡張&lt;/a&gt;機能であり、&lt;a href=&quot;cli&quot;&gt;コマンドラインシェルに&lt;/a&gt;コンパイルされます。generate_series（）テーブルには、整数値を保持する &quot;value&quot;という名前の単一の結果列と、パラメーターSTART、END、およびSTEPによって決定される行数があります。テーブルの最初の行の値はSTARTです。後続の行はSTEPからENDまで増加します。</target>
        </trans-unit>
        <trans-unit id="3f2ed0d414c19e451dbd160a6e3115271ef19a02" translate="yes" xml:space="preserve">
          <source>The geopoly module defines several new SQL functions that are useful for dealing with polygons. All polygon arguments to these functions can be either the GeoJSON format or the internal binary format.</source>
          <target state="translated">geopolyモジュールは、ポリゴンを扱うのに便利ないくつかの新しいSQL関数を定義しています。これらの関数へのすべてのポリゴンの引数は、GeoJSON フォーマットまたは内部バイナリフォーマットのいずれかになります。</target>
        </trans-unit>
        <trans-unit id="8d993a3d44bf40860242bebc1265b2783cf9c63f" translate="yes" xml:space="preserve">
          <source>The geopoly module is an extension to the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;. Geopoly uses the same underlying logic and shadow tables as the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;. Geopoly merely presents a different interface, and provides some extra logic to compute polygon decoding, overlap, and containment.</source>
          <target state="translated">geopolyモジュールは、&lt;a href=&quot;rtree&quot;&gt;Rツリー拡張の拡張&lt;/a&gt;です。Geopolyは、&lt;a href=&quot;rtree&quot;&gt;Rツリー拡張&lt;/a&gt;と同じ基本的なロジックとシャドウテーブルを使用します。Geopolyは単に異なるインターフェイスを提供し、ポリゴンのデコード、オーバーラップ、および包含を計算するためのいくつかの追加ロジックを提供します。</target>
        </trans-unit>
        <trans-unit id="acb138b945d23f00cd83af917d94b141700de307" translate="yes" xml:space="preserve">
          <source>The geopoly module is built on top of the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; and uses the same underlying shadow tables and algorithms. For indexing purposes, each polygon is represented in the shadow tables as a rectangular bounding box. The underlying R-Tree implementation uses bounding boxes to limit the search space. Then the geoploy_overlap() and/or geopoly_within() routines further refine the search to the exact answer.</source>
          <target state="translated">geopolyモジュールは、&lt;a href=&quot;rtree&quot;&gt;Rツリー拡張の&lt;/a&gt;上に構築され、同じ基礎となるシャドウテーブルとアルゴリズムを使用します。インデックス作成のために、各ポリゴンはシャドウテーブルで長方形の境界ボックスとして表されます。基になるRツリー実装は、境界ボックスを使用して検索スペースを制限します。次に、geoploy_overlap（）および/またはgeopoly_within（）ルーチンが検索をさらに正確な答えに絞り込みます。</target>
        </trans-unit>
        <trans-unit id="fdb9ae6360ea866b8222993691854e31ea695989" translate="yes" xml:space="preserve">
          <source>The geopoly_ccw(J) function returns the polygon J with counter-clockwise (CCW) rotation.</source>
          <target state="translated">geopoly_ccw(J)関数は、反時計回り(CCW)回転の多角形 J を返します。</target>
        </trans-unit>
        <trans-unit id="58be5b36690d1c8a61ca619684c9087df6d3c79c" translate="yes" xml:space="preserve">
          <source>The geopoly_group_bbox(P) function is an aggregate version of geopoly_bbox(P). The geopoly_group_bbox(P) function returns the smallest rectangle that will enclose all P values seen during aggregation.</source>
          <target state="translated">geopoly_group_bbox(P)関数は、 geopoly_bbox(P)の集約版です。geopoly_group_bbox(P)関数は、 集約中に見られるすべてのPの値を囲む最小の矩形を返します。</target>
        </trans-unit>
        <trans-unit id="7aa31a665e34b0f93544b760a7bd5d5549c54d97" translate="yes" xml:space="preserve">
          <source>The geopoly_overlap(P1,P2) function is special in that the geopoly virtual table knows how to use R*Tree indexes to optimize queries in which the WHERE clause uses geopoly_overlap() as a boolean function. Only the geopoly_overlap(P1,P2) and geopoly_within(P1,P2) functions have this capability.</source>
          <target state="translated">geopoly_overlap(P1,P2)関数は、 geopoly仮想テーブルがR*Treeインデックスを使用して、 WHERE句がgeopoly_overlap()をブール関数として使用するクエリを最適化する方法を知っているという点で特別です。geopoly_overlap(P1,P2)とgeopoly_within(P1,P2)関数だけがこの機能を持っています。</target>
        </trans-unit>
        <trans-unit id="4552cf5a5f2e459423714152983f2ca48f86f169" translate="yes" xml:space="preserve">
          <source>The geopoly_regular(X,Y,R,N) function returns a convex, simple, regular, equilateral, equiangular polygon with N sides, centered at X,Y, and with a circumradius of R. Or, if R is negative or if N is less than 3, the function returns NULL. The N value is capped at 1000 so that the routine will never render a polygon with more than 1000 sides even if the N value is larger than 1000.</source>
          <target state="translated">geopoly_regular(X,Y,R,N)関数は、X,Yを中心としたN辺、円周率Rを持つ、凸で単純な正三角形、正三角形、正三角形の多角形を返します。N の値は 1000 が上限で、N の値が 1000 より大きい場合でも、1000 を超える辺を持つ多角形を描画することはありません。</target>
        </trans-unit>
        <trans-unit id="01eba492c4ddd36076bba0e9fe7c2f9d9c526116" translate="yes" xml:space="preserve">
          <source>The geopoly_within(P1,P2) function is special in that the geopoly virtual table knows how to use R*Tree indexes to optimize queries in which the WHERE clause uses geopoly_within() as a boolean function. Only the geopoly_within(P1,P2) and geopoly_overlap(P1,P2) functions have this capability.</source>
          <target state="translated">geopoly_within(P1,P2)関数は、geopoly仮想テーブルがR*Treeインデックスを使用して、 WHERE句がgeopoly_within()をブール関数として使用するクエリを最適化する方法を知っているという点で特別なものです。geopoly_within(P1,P2)とgeopoly_overlap(P1,P2)関数だけがこの機能を持っています。</target>
        </trans-unit>
        <trans-unit id="45313c37ef01af04ca79cf8e508d2efcd3ced709" translate="yes" xml:space="preserve">
          <source>The geopoly_xform(P,A,B,C,D,E,F) function returns a new polygon that is an affine transformation of the polygon P and where the transformation is defined by values A,B,C,D,E,F. If P is not a valid polygon, this routine returns NULL.</source>
          <target state="translated">geopoly_xform(P,A,B,C,D,E,F)関数は、多角形 P のアフィン変換であり、変換が A,B,C,D,E,F で定義されている新しい多角形を返します。P が有効な多角形でない場合、このルーチンは NULL を返します。</target>
        </trans-unit>
        <trans-unit id="8a7538a75bac0dc91c968f2f943ef8c77b915108" translate="yes" xml:space="preserve">
          <source>The glob(X,Y) function is equivalent to the expression &quot;&lt;b&gt;Y GLOB X&lt;/b&gt;&quot;. Note that the X and Y arguments are reversed in the glob() function relative to the infix &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator. Y is the string and X is the pattern. So, for example, the following expressions are equivalent:</source>
          <target state="translated">glob（X、Y）関数は、式 &quot; &lt;b&gt;Y GLOB X&lt;/b&gt; &quot; と同等です。XとYの引数は、infix &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;演算子に対してglob（）関数では逆になっていることに注意してください。Yは文字列、Xはパターンです。したがって、たとえば、次の式は同等です。</target>
        </trans-unit>
        <trans-unit id="57af892941202e82d82f19e609a84ccb0531eaad" translate="yes" xml:space="preserve">
          <source>The goal is to make SQLite handle NULLs in a standards-compliant way. But the descriptions in the SQL standards on how to handle NULLs seem ambiguous. It is not clear from the standards documents exactly how NULLs should be handled in all circumstances.</source>
          <target state="translated">目的は、SQLiteが標準に準拠した方法でNULLを扱えるようにすることです。しかし、SQL標準ではNULLをどのように扱うかについての記述が曖昧なようです。標準SQL文書では、あらゆる状況下でNULLをどのように扱うべきかが明確になっていません。</target>
        </trans-unit>
        <trans-unit id="2ba0147df5ada0e089bdabaebc1a5094f5e9a20f" translate="yes" xml:space="preserve">
          <source>The goal of this query is to compute some value for the five most recent entries in the table. But in the query above, the &quot;expensive_function()&quot; is invoked prior to the sort and thus is invoked on every row of the table, even rows that are ultimately omitted due to the LIMIT clause. A co-routine can be used to work around this:</source>
          <target state="translated">このクエリの目的は、テーブル内の直近の5つのエントリに対して何らかの値を計算することです。しかし、上のクエリでは、&quot;expensive_function()&quot;はソートの前に呼び出されるため、テーブルのすべての行で呼び出され、最終的にLIMIT句によって省略された行でさえも呼び出されます。これを回避するために、コ・ルーティンを使用することができます。</target>
        </trans-unit>
        <trans-unit id="27130ed911ba5b72cf5d70b6f38c66e3447f97b9" translate="yes" xml:space="preserve">
          <source>The grammar syntax is less error prone - using symbolic names for semantic values rather that the &quot;$1&quot;-style positional notation of Yacc.</source>
          <target state="translated">文法構文は、Yaccの&quot;$1 &quot;スタイルの位置表記ではなく、意味値にシンボリック名を使用しているため、エラーが発生しにくくなっています。</target>
        </trans-unit>
        <trans-unit id="8288ae8eb06e54b34a1335f8c6fbfb99327b7542" translate="yes" xml:space="preserve">
          <source>The graph below shows the number of CPU cycles used by SQLite on a standard workload, for versions of SQLite going back about 10 years. Recent versions of SQLite use about one third as many the CPU cycles compared to older versions.</source>
          <target state="translated">下のグラフは、約10年前のバージョンのSQLiteについて、標準的なワークロードでSQLiteが使用したCPUサイクル数を示しています。最近のバージョンのSQLiteは、古いバージョンに比べて約3分の1のCPUサイクルを使用しています。</target>
        </trans-unit>
        <trans-unit id="ea3dfc83e3fad7e5da84aa92171fa1f2ebb6adae" translate="yes" xml:space="preserve">
          <source>The group_concat() function returns a string which is the concatenation of all non-NULL values of</source>
          <target state="translated">関数 group_concat()は</target>
        </trans-unit>
        <trans-unit id="998c879f2d9a4a324ed589705e44b7743eed8ace" translate="yes" xml:space="preserve">
          <source>The group_concat(x,'') SQL function returns NULL instead of an empty string when all inputs are empty strings. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/55746f9e65f85&quot;&gt;55746f9e65&lt;/a&gt;</source>
          <target state="translated">group_concat（x、 ''）SQL関数は、すべての入力が空の文字列の場合、空の文字列ではなくNULLを返します。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/55746f9e65f85&quot;&gt;55746f9e65&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3cc69e429ade6ced467dc065c3703a231254bc0f" translate="yes" xml:space="preserve">
          <source>The handling of IN and NOT IN operators that contain a NULL on their right-hand side expression is brought into compliance with the SQL standard and with other SQL database engines. This is a bug fix, but as it has the potential to break legacy applications that depend on the older buggy behavior, we mark that as a *** Potentially incompatible change ***</source>
          <target state="translated">右辺の式にNULLを含むINおよびNOT IN演算子の取り扱いが、SQL標準および他のSQLデータベースエンジンに準拠するようになりました。これはバグフィックスですが、古いバグのある動作に依存しているレガシーアプリケーションを壊す可能性があるため、***互換性のない変更***としてマークしています。</target>
        </trans-unit>
        <trans-unit id="d0efc6030fa81d141b43a701523b55c7bcf660fd" translate="yes" xml:space="preserve">
          <source>The hash tables in the shm file are designed to answer the following question quickly:</source>
          <target state="translated">shmファイルのハッシュ表は、以下の質問にすぐに答えられるようになっています。</target>
        </trans-unit>
        <trans-unit id="2856b370cad55dc7412b44b6f210c8cf053331d6" translate="yes" xml:space="preserve">
          <source>The hashes that identify check-ins and files on the Git mirror are different from the hashes in Fossil. There are many reasons for this, chief among them that Fossil uses a SHA3-256 hash whereas Git uses a SHA1 hash. During export, the original Fossil hash for each check-in is added as a footer to check-in comments. To avoid confusion, always use the original Fossil hash, not the Git hash, when referring to SQLite check-ins.</source>
          <target state="translated">Git ミラー上のチェックインやファイルを識別するハッシュは、Fossil のハッシュとは異なります。これには多くの理由がありますが、中でもFossilはSHA3-256ハッシュを使用しているのに対し、GitはSHA1ハッシュを使用していることが主な理由です。エクスポート時には、各チェックインのオリジナルのFossilハッシュがチェックインコメントのフッターとして追加されます。混乱を避けるため、SQLiteのチェックインを参照する際は、Gitのハッシュではなく、必ずオリジナルのFossilのハッシュを使用してください。</target>
        </trans-unit>
        <trans-unit id="e115da518074674c7bed9606a1f3c39c1334b0dc" translate="yes" xml:space="preserve">
          <source>The header of the rollback journal can be overwritten with invalid header text (for example, all zeros).</source>
          <target state="translated">ロールバックジャーナルのヘッダは、無効なヘッダテキスト(例えば、すべてのゼロ)で上書きすることができます。</target>
        </trans-unit>
        <trans-unit id="328251bbc9b91a18ef755ecd2993b4b5eb3cf221" translate="yes" xml:space="preserve">
          <source>The header of the rollback journal is well-formed and in particular has not been zeroed out.</source>
          <target state="translated">ロールバックジャーナルのヘッダは整形されており、特にゼロアウトされていません。</target>
        </trans-unit>
        <trans-unit id="8908758df6621b583f7634e3a00bc808f16a9ffb" translate="yes" xml:space="preserve">
          <source>The header size varint and serial type varints will usually consist of a single byte. The serial type varints for large strings and BLOBs might extend to two or three byte varints, but that is the exception rather than the rule. The varint format is very efficient at coding the record header.</source>
          <target state="translated">ヘッダサイズの varint とシリアル型の varint は通常 1 バイトで構成されています。大きな文字列や BLOB のためのシリアル型の varint は 2 バイトか 3 バイトの varint に拡張されるかもしれませんが、これは規則というよりはむしろ例外です。varint 形式はレコードヘッダのコーディングにおいて非常に効率的です。</target>
        </trans-unit>
        <trans-unit id="6a561080aa600994c95f7609f8c9a76e07664cc1" translate="yes" xml:space="preserve">
          <source>The header string: &quot;SQLite format 3\000&quot;</source>
          <target state="translated">ヘッダー文字列 &quot;SQLite format 3\000&quot;</target>
        </trans-unit>
        <trans-unit id="9618d06778e016225462d5681eb6b291f7c80aa5" translate="yes" xml:space="preserve">
          <source>The heap limits are not enforced in the current implementation if one or more of following conditions are true:</source>
          <target state="translated">現在の実装では、以下の条件のうち1つ以上が真の場合、ヒープ制限が適用されません。</target>
        </trans-unit>
        <trans-unit id="95f9212fdc8a88cf98b4e1490976ec2f7354c6a2" translate="yes" xml:space="preserve">
          <source>The heavy wrapper employed by &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; is intended for use only during testing, analysis, and debugging of SQLite. The heavy wrapper has a significant performance and memory overhead and probably should not be used in production.</source>
          <target state="translated">&lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt;で使用される重いラッパーは、SQLiteのテスト、分析、およびデバッグ中にのみ使用することを目的としています。重いラッパーはパフォーマンスとメモリのオーバーヘッドが大きいため、本番環境では使用しないでください。</target>
        </trans-unit>
        <trans-unit id="eb4610f1226d8f274f85d7debe217f5d65427f90" translate="yes" xml:space="preserve">
          <source>The heavy wrapper that is used when &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; is set also makes sure each new allocation is filled with nonsense data prior to returning the allocation to the caller. And as soon as an allocation is free, it is again filled with nonsense data. These two actions help to ensure that the SQLite core does not make assumptions about the state of newly allocated memory and that memory allocations are not used after they have been freed.</source>
          <target state="translated">&lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt;が設定されているときに使用される重いラッパーは、割り当てを呼び出し元に返す前に、それぞれの新しい割り当てが無意味なデータで満たされるようにします。そして、割り当てが解放されるとすぐに、それは再び意味のないデータで満たされます。これらの2つのアクションは、SQLiteコアが新しく割り当てられたメモリの状態を想定せず、解放後にメモリ割り当てが使用されないようにするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="a33b86543e89aa7fc91f1c01c079a10eabc5b26c" translate="yes" xml:space="preserve">
          <source>The hex() function interprets its argument as a BLOB and returns a string which is the upper-case hexadecimal rendering of the content of that blob.</source>
          <target state="translated">hex()関数は、その引数を BLOB として解釈し、その BLOB の内容を大文字の 16 進数で表現した文字列を返します。</target>
        </trans-unit>
        <trans-unit id="47e9ec1a2ca9f6468b5d5ea9dca27a7ef3e3db0a" translate="yes" xml:space="preserve">
          <source>The high repeatability of cachegrind allows the SQLite developers to implement and measure &quot;microoptimizations&quot;. A microoptimization is a change to the code that results in a very small performance increase. Typical micro-optimizations reduce the number of CPU cycles by 0.1% or 0.05% or even less. Such improvements are impossible to measure with real-world timings. But hundreds or thousands of microoptimizations add up, resulting in measurable real-world performance gains.</source>
          <target state="translated">cachegrind の高い再現性により、SQLite の開発者は「マイクロ最適化」を実装して測定することができます。微小最適化とは、コードの変更により、非常に小さなパフォーマンスの向上をもたらすことです。典型的なマイクロ最適化は、CPUサイクル数を0.1%もしくは0.05%もしくはそれ以下に減少させます。このような改善は、実世界のタイミングで測定することは不可能です。しかし、何百、何千ものマイクロ最適化が積み重なり、結果的に実世界で測定可能なパフォーマンスの向上をもたらします。</target>
        </trans-unit>
        <trans-unit id="8ccb63c8eb8186df2591985e1dd0399f9de8ed53" translate="yes" xml:space="preserve">
          <source>The high-reliability of SQLite is proven in practice. SQLite has been used without problems in multiple billions of smart-phones, IoT devices, and desktop applications, around the world, and for almost two decades.</source>
          <target state="translated">SQLiteの高い信頼性は、実際に証明されています。SQLiteは、世界中の数十億台のスマートフォン、IoTデバイス、デスクトップアプリケーションで問題なく使用されており、約20年前から使用されています。</target>
        </trans-unit>
        <trans-unit id="8285d1c1b74bc88c5caec05770baddba5bd483b5" translate="yes" xml:space="preserve">
          <source>The high-reliability of SQLite is proven in practice. SQLite has been used without problems in multiple billions of smart-phones, IoT devices, and desktop applications, around the world, and for over a decade.</source>
          <target state="translated">SQLiteの高い信頼性は実際に証明されています。SQLiteは、世界中の何十億ものスマートフォン、IoTデバイス、デスクトップアプリケーションで、10年以上にわたって問題なく使用されています。</target>
        </trans-unit>
        <trans-unit id="f6fadaee687e9cfda1c93f7fa51b5ba3b3240bd6" translate="yes" xml:space="preserve">
          <source>The highlight() function returns a copy of the text from a specified column of the current row with extra markup text inserted to mark the start and end of phrase matches.</source>
          <target state="translated">highlight()関数は、現在の行の指定した列のテキストのコピーを返します。</target>
        </trans-unit>
        <trans-unit id="e43753ce0913d39afca1c9c249ea51ebaf6b6f06" translate="yes" xml:space="preserve">
          <source>The highlight() must be invoked with exactly three arguments following the table name. To be interpreted as follows:</source>
          <target state="translated">highlight()は、テーブル名の後に正確に 3 つの引数をつけて呼び出す必要があります。次のように解釈すること。</target>
        </trans-unit>
        <trans-unit id="bb9d506afb5b0054b66298f3975841775d6d258d" translate="yes" xml:space="preserve">
          <source>The histogram data is only useful if the right-hand side of the constraint is a simple compile-time constant or &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; and not an expression.</source>
          <target state="translated">ヒストグラムデータは、制約の右側が単純なコンパイル時の定数または&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメーター&lt;/a&gt;であり、式ではない場合にのみ役立ちます。</target>
        </trans-unit>
        <trans-unit id="754b3dec45709dc037212c7449e27878498a6122" translate="yes" xml:space="preserve">
          <source>The historical behavior of SQLite is incorrect according to the SQL:1999 standard and it is inconsistent with the behavior of MySQL and PostgreSQL. Version 3.6.0 changes the behavior of the IN and NOT IN operators to conform to the standard and to give the same results as other SQL database engines.</source>
          <target state="translated">SQLiteの歴史的な挙動は、SQL:1999標準によると正しくなく、MySQLやPostgreSQLの挙動と矛盾しています。バージョン3.6.0では、標準に準拠し、他のSQLデータベースエンジンと同じ結果が得られるように、INおよびNOT IN演算子の動作が変更されました。</target>
        </trans-unit>
        <trans-unit id="3be31364c3c06e62038927597ca88135a8ca4d7a" translate="yes" xml:space="preserve">
          <source>The iCost column is the numeric cost of transforming cFrom into cTo. This value should be a non-negative integer, and should probably be less than 100. The default single-character insertion and deletion costs are 100 and the default single-character to single-character substitution cost is 150. A cost of 10000 or more is considered &quot;infinite&quot; and causes the rule to be ignored.</source>
          <target state="translated">iCost列は、cFromをcToに変換する際のコストを表す数値です。この値は非負の整数である必要があり、おそらく100未満であるべきです。デフォルトの1文字挿入・削除コストは100で、デフォルトの1文字から1文字への置換コストは150です。10000以上のコストは「無限」とみなされ、ルールは無視されます。</target>
        </trans-unit>
        <trans-unit id="d0b9d0aa5d29da45f0b93b40de44e2f95388c2e0" translate="yes" xml:space="preserve">
          <source>The iLang column is a non-negative integer that identifies a set of costs appropriate for a particular language. The editdist3 function will only use a single iLang value for any given edit-distance computation. The default value is 0. It is recommended that applications that only need to use a single language always use iLang==0 for all entries.</source>
          <target state="translated">iLang列は、特定の言語に適したコストのセットを識別する非負の整数です。editdist3関数は、与えられた編集距離の計算に単一のiLang値のみを使用します。デフォルト値は0です。 単一の言語のみを使用する必要があるアプリケーションでは、すべてのエントリに常にiLang==0を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="5013f8a1a10fac4a872743ceb29c353308c4297d" translate="yes" xml:space="preserve">
          <source>The iVersion field of &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; is provided as insurance against future enhancements. The iVersion value should always be 1 for SQLite version 3.5.</source>
          <target state="translated">IVERSIONフィールド&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methodsは、&lt;/a&gt;将来の拡張に対する保険として提供されます。SQLiteバージョン3.5では、iVersion値は常に1である必要があります。</target>
        </trans-unit>
        <trans-unit id="8b61610ddf9130372f875adae334c360bf359102" translate="yes" xml:space="preserve">
          <source>The iVersion field of &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; should be 1 for SQLite version 3.5.0. This number may increase in future versions of SQLite if we have to modify the VFS object in some way. We hope that this never happens, but the provision is made in case it does.</source>
          <target state="translated">SQLiteバージョン3.5.0の場合、&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;のiVersionフィールドは1である必要があります。この数は、何らかの方法でVFSオブジェクトを変更する必要がある場合、SQLiteの将来のバージョンで増加する可能性があります。これが起こらないことを願っていますが、万が一の場合に備えて提供されています。</target>
        </trans-unit>
        <trans-unit id="ea830f2d673441ec5d80e9c5eb8623ea5999e87b" translate="yes" xml:space="preserve">
          <source>The idea behind a reserved lock is that it signals that a process intends to modify the database file in the near future but has not yet started to make the modifications. And because the modifications have not yet started, other processes can continue to read from the database. However, no other process should also begin trying to write to the database.</source>
          <target state="translated">予約ロックの背後にある考え方は、あるプロセスが近い将来にデータベースファイルを変更しようとしているが、まだ変更を開始していないことを示すものです。そして、まだ変更が開始されていないので、他のプロセスはデータベースからの読み込みを続けることができます。しかし、他のプロセスがデータベースへの書き込みを開始してはいけません。</target>
        </trans-unit>
        <trans-unit id="b86c36b3766e07cfb666e3625925c99f4017f8b5" translate="yes" xml:space="preserve">
          <source>The idxNum and idxPtr values are recorded and passed into the &lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method. &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; is used to free idxPtr if and only if needToFreeIdxPtr is true.</source>
          <target state="translated">idxNumおよびidxPtrの値が記録され、&lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;メソッドに渡されます。&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;は、needToFreeIdxPtrがtrueの場合にのみidxPtrを解放するために使用されます。</target>
        </trans-unit>
        <trans-unit id="357574f6e5fd171b87a29904a513e7015690c872" translate="yes" xml:space="preserve">
          <source>The idxNum and idxPtr values are recorded and passed into the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method. &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; is used to free idxPtr if and only if needToFreeIdxPtr is true.</source>
          <target state="translated">idxNumおよびidxPtrの値が記録され、&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;メソッドに渡されます。&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;は、needToFreeIdxPtrがtrueの場合にのみidxPtrを解放するために使用されます。</target>
        </trans-unit>
        <trans-unit id="013b479832be35dd0d8a4395d938100b93b10f74" translate="yes" xml:space="preserve">
          <source>The idxStr value may be a string obtained from an SQLite memory allocation function such as &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt;. If this is the case, then the needToFreeIdxStr flag must be set to true so that the SQLite core will know to call &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; on that string when it has finished with it, and thus avoid a memory leak. The idxStr value may also be a static constant string, in which case the needToFreeIdxStr boolean should remain false.</source>
          <target state="translated">idxStr値は、&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;などのSQLiteメモリ割り当て関数から取得した文字列である場合があります。その場合は、SQLiteコアがその文字列の処理を終えたときにその文字列で&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;を呼び出し、メモリリークを回避できるように、needToFreeIdxStrフラグをtrueに設定する必要があります。idxStr値は静的定数文字列でもかまいません。その場合、needToFreeIdxStrブール値はfalseのままにする必要があります。</target>
        </trans-unit>
        <trans-unit id="4d5a7e8bc386f87dedf4ba3978aa31bcde8d6916" translate="yes" xml:space="preserve">
          <source>The ifnull() function returns a copy of its first non-NULL argument, or NULL if both arguments are NULL. Ifnull() must have exactly 2 arguments. The ifnull() function is equivalent to &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt; with two arguments.</source>
          <target state="translated">ifnull（）関数は、最初の非NULL引数のコピーを返します。両方の引数がNULLの場合はNULLを返します。ifnull（）には2つの引数が必要です。ifnull（）関数は、2つの引数を持つ&lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce（）&lt;/a&gt;と同等です。</target>
        </trans-unit>
        <trans-unit id="003c977ed53ddacaa1a12c60c49d228fced8878c" translate="yes" xml:space="preserve">
          <source>The iif(X,Y,Z) function returns the value Y if X is true, and Z otherwise. The iif(X,Y,Z) function is logically equivalent to and generates the same &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; as the &lt;a href=&quot;lang_expr#case&quot;&gt;CASE expression&lt;/a&gt; &quot;CASE WHEN X THEN Y ELSE Z END&quot;.</source>
          <target state="translated">iif（X、Y、Z）関数は、Xがtrueの場合は値Yを返し、それ以外の場合はZを返します。iif（X、Y、Z）関数は、&lt;a href=&quot;lang_expr#case&quot;&gt;CASE式&lt;/a&gt;「CASEWHEN X THEN Y ELSE Z END」と論理的に同等であり、同じ&lt;a href=&quot;opcode&quot;&gt;バイトコード&lt;/a&gt;を生成します。</target>
        </trans-unit>
        <trans-unit id="46220a05919fd727bb5192ff33d2f0412a4a1656" translate="yes" xml:space="preserve">
          <source>The immutable query parameter is a boolean that signals to SQLite that the underlying database file is held on read-only media and cannot be modified, even by another process with elevated privileges. SQLite always opens immutable database files read-only and it skips all file locking and change detection on immutable database files. If these query parameter (or the &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_IMMUTABLE&lt;/a&gt; bit in xDeviceCharacteristics) asserts that a database file is immutable and that file changes anyhow, then SQLite might return incorrect query results and/or &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; errors.</source>
          <target state="translated">不変のクエリパラメータはブール値であり、基になるデータベースファイルが読み取り専用メディアに保持されており、昇格された特権を持つ別のプロセスによっても変更できないことをSQLiteに通知します。 SQLiteは常に不変データベースファイルを読み取り専用で開き、不変データベースファイルに対するすべてのファイルロックと変更検出をスキップします。これらのクエリパラメーター（または&lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;xDeviceCharacteristicsのSQLITE_IOCAP_IMMUTABLE&lt;/a&gt;ビット）がデータベースファイルが不変であり、そのファイルが何らかの方法で変更されていると断定した場合、SQLiteは不正なクエリ結果や&lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt;エラーを返す可能性があります。</target>
        </trans-unit>
        <trans-unit id="a6b9b8cf3a7d94e9575aa22c08feee5317ab9464" translate="yes" xml:space="preserve">
          <source>The implementation for the spellfix1 virtual table is held in the SQLite source tree in the miscellaneous extensions folder and in particular in the file &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=ext/misc/spellfix.c&quot;&gt;ext/misc/spellfix1.c&lt;/a&gt;. The spellfix1 virtual table is not included in the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; and is not a part of any standard SQLite build. It is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;.</source>
          <target state="translated">spellfix1仮想テーブルの実装は、その他の拡張機能フォルダーのSQLiteソースツリー、特に&lt;a href=&quot;http://www.sqlite.org/src/finfo?name=ext/misc/spellfix.c&quot;&gt;ext / misc / spellfix1.c&lt;/a&gt;ファイルに保持されます。spellfix1仮想テーブルは、SQLiteの&lt;a href=&quot;amalgamation&quot;&gt;統合&lt;/a&gt;には含まれておらず、標準のSQLiteビルドの一部ではありません。これは、ある&lt;a href=&quot;loadext&quot;&gt;ロード可能な拡張&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8eb5688bafc7d4405d9e0ef667e71e04726e76e8" translate="yes" xml:space="preserve">
          <source>The implementation is not required to provide versions of these routines that actually work. If the implementation does not provide working versions of these routines, it should at least provide stubs that always return true so that one does not get spurious assertion failures.</source>
          <target state="translated">実装は、これらのルーチンが実際に動作するバージョンを提供する必要はありません。実装がこれらのルーチンの動作するバージョンを提供していない場合は、少なくとも常に真を返すスタブを提供して、偽のアサーション失敗を起こさないようにすべきです。</target>
        </trans-unit>
        <trans-unit id="8b40a9e730bef66c422bb631b44b6863716defa7" translate="yes" xml:space="preserve">
          <source>The implementation is registered with the FTS5 module by calling the xCreateFunction() method of the fts5_api object. If there is already an auxiliary function with the same name, it is replaced by the new function. If a non-NULL xDestroy parameter is passed to xCreateFunction(), it is invoked with a copy of the pContext pointer passed as the only argument when the database handle is closed or when the registered auxiliary function is replaced.</source>
          <target state="translated">fts5_apiオブジェクトのxCreateFunction()メソッドを呼び出すことで実装をFTS5モジュールに登録します。既に同名の補助関数が存在する場合は、新しい関数に置き換えられます。xCreateFunction()に NULL でない xDestroy パラメータが渡された場合、データベースハンドルが閉じられたとき、または登録された補助関数が置換されたときに、唯一の引数として渡された pContext ポインタのコピーを使用して呼び出されます。</target>
        </trans-unit>
        <trans-unit id="bbe3105d33c8a4906448b08f8925bf436af3dd67" translate="yes" xml:space="preserve">
          <source>The implementation is registered with the FTS5 module by calling the xCreateTokenizer() method of the fts5_api object. If there is already a tokenizer with the same name, it is replaced. If a non-NULL xDestroy parameter is passed to xCreateTokenizer(), it is invoked with a copy of the pContext pointer passed as the only argument when the database handle is closed or when the tokenizer is replaced.</source>
          <target state="translated">fts5_apiオブジェクトのxCreateTokenizer()メソッドを呼び出すことで、実装をFTS5モジュールに登録します。既に同名のトーケナイザーが存在する場合は、それを置き換えます。xCreateTokenizer()に NULL でない xDestroy パラメータが渡された場合、データベースハンドルが閉じられたとき、またはトークンサイザが置き換えられたときに、唯一の引数として渡された pContext ポインタのコピーを使用して呼び出されます。</target>
        </trans-unit>
        <trans-unit id="8b89a513d4c178ab8d213508b88c8e5c09e3c7a1" translate="yes" xml:space="preserve">
          <source>The implementation language for the example code is &lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;TCL&lt;/a&gt;, though you can easily do the same thing in another programming language. Remember that the code here is a demonstration of the technique, not a drop-in module that will automatically do everything for you. The demonstration code shown below is derived from actual code in production use. But you will need to make changes to tailor it to your application.</source>
          <target state="translated">サンプルコードの実装言語は&lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;TCL&lt;/a&gt;ですが、別のプログラミング言語で同じことを簡単に行うことができます。ここのコードはテクニックのデモンストレーションであり、自動的にすべてを実行するドロップインモジュールではないことに注意してください。以下に示すデモコードは、実稼働での実際のコードから派生しています。ただし、アプリケーションに合わせて変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="1c7602fe1bd4486f649d10efe941c63ad9ebc01d" translate="yes" xml:space="preserve">
          <source>The implementation of this function could be enhanced in at least two ways:</source>
          <target state="translated">この機能の実装は、少なくとも2つの方法で強化することができます。</target>
        </trans-unit>
        <trans-unit id="fb654149d36243346cb33110dabec3f86ec0e93a" translate="yes" xml:space="preserve">
          <source>The important parts of the output (the parts that the developers pay the most attention to) are shown in red. Basically, the developers want to know the size of the compiled SQLite library and how many CPU cycles were needed to run the performance test.</source>
          <target state="translated">出力の重要な部分(開発者が最も注意を払う部分)は赤で示されています。基本的に開発者が知りたいのは、コンパイルされたSQLiteライブラリのサイズと、パフォーマンステストを実行するのに必要なCPUサイクル数です。</target>
        </trans-unit>
        <trans-unit id="98a68810edc43f0319b74cd65a4602d55569695b" translate="yes" xml:space="preserve">
          <source>The imposter table mechanism is a power analysis and debugging tool for SQLite. But as with all sharp tools, it can also be dangerous and can result in corrupt database files if misused. Do not attempt to use imposter tables in an application. Imposter tables are intended for use in the laboratory by experts.</source>
          <target state="translated">インポスターテーブルメカニズムは、SQLiteのための強力な解析およびデバッグツールです。しかし、他の鋭利なツールと同様に、誤った使い方をすると危険なこともあり、データベースファイルを破損させる結果になることもあります。アプリケーションでインポスターテーブルを使用しようとしないでください。インポスターテーブルは、専門家による研究室での使用を目的としています。</target>
        </trans-unit>
        <trans-unit id="f137c1fa92f06c6d9054e4f6699dd72be9e8aeef" translate="yes" xml:space="preserve">
          <source>The in-header database size is only considered to be valid if it is non-zero and if the 4-byte &lt;a href=&quot;fileformat2#chngctr&quot;&gt;change counter&lt;/a&gt; at offset 24 exactly matches the 4-byte &lt;a href=&quot;fileformat2#validfor&quot;&gt;version-valid-for number&lt;/a&gt; at offset 92. The in-header database size is always valid when the database is only modified using recent versions of SQLite, versions 3.7.0 (2010-07-21) and later. If a legacy version of SQLite writes to the database, it will not know to update the in-header database size and so the in-header database size could be incorrect. But legacy versions of SQLite will also leave the version-valid-for number at offset 92 unchanged so it will not match the change-counter. Hence, invalid in-header database sizes can be detected (and ignored) by observing when the change-counter does not match the version-valid-for number.</source>
          <target state="translated">ヘッダー内のデータベースサイズは、それがゼロ以外で、オフセット24 の4バイトの&lt;a href=&quot;fileformat2#chngctr&quot;&gt;変更カウンターが&lt;/a&gt;オフセット92の4バイトの&lt;a href=&quot;fileformat2#validfor&quot;&gt;version-valid-for番号&lt;/a&gt;と完全に一致する場合にのみ有効であると見なされます。インヘッダーデータベースSQLiteの最新バージョン、バージョン3.7.0（2010-07-21）以降を使用してデータベースが変更された場合、サイズは常に有効です。 SQLiteのレガシーバージョンがデータベースに書き込む場合、ヘッダー内のデータベースサイズを更新する必要がないため、ヘッダー内のデータベースサイズが正しくない可能性があります。ただし、SQLiteのレガシーバージョンでは、オフセット92のversion-valid-for番号も変更されないため、変更カウンターと一致しません。したがって、change-counterがversion-valid-for番号と一致しない場合を観察することで、無効なヘッダー内データベースサイズを検出（および無視）できます。</target>
        </trans-unit>
        <trans-unit id="856311d50a8fd5f75cd3339835ec40132b3ad9e1" translate="yes" xml:space="preserve">
          <source>The incremental_vacuum pragma causes up to</source>
          <target state="translated">incremental_vacuumプラグマは最大でも</target>
        </trans-unit>
        <trans-unit id="2dd53e3930b5b852ae3198064e374d5480957b02" translate="yes" xml:space="preserve">
          <source>The index is not usable at all because the left-most column of the index (column &quot;a&quot;) is not constrained. Assuming there are no other indices, the query above would result in a full table scan.</source>
          <target state="translated">インデックスの左端の列(列 &quot;a&quot;)が拘束されていないため、インデックスは全く使用できません。他にインデックスがないと仮定すると、上記のクエリはテーブルのフルスキャンになります。</target>
        </trans-unit>
        <trans-unit id="af8e63da60690ffa41a028a8c03b3a46553b1974" translate="yes" xml:space="preserve">
          <source>The index is not usable because the WHERE clause terms are connected by OR instead of AND. This query would result in a full table scan. However, if three additional indices where added that contained columns b, c, and d as their left-most columns, then the &lt;a href=&quot;#or_opt&quot;&gt;OR-clause optimization&lt;/a&gt; might apply.</source>
          <target state="translated">WHERE句の用語がANDではなくORで接続されているため、インデックスは使用できません。このクエリの結果、テーブル全体がスキャンされます。ただし、列b、c、およびdを左端の列として含む3つの追加のインデックスが追加された場合、&lt;a href=&quot;#or_opt&quot;&gt;OR句の最適化&lt;/a&gt;が適用される可能性があります。</target>
        </trans-unit>
        <trans-unit id="672cc6d4ea8af33a329ad85f582fc436091b60cb" translate="yes" xml:space="preserve">
          <source>The index of the term instance within its column. Terms are numbered in order of occurrence starting from 0.</source>
          <target state="translated">その列内の用語インスタンスのインデックス。タームは、0から始まる出現順に番号が付けられます。</target>
        </trans-unit>
        <trans-unit id="9be4bc1fc0e600b05c5d496186036ea84f9ef15d" translate="yes" xml:space="preserve">
          <source>The indexed documents are not stored within the SQLite database at all (a &quot;contentless&quot; FTS4 table), or</source>
          <target state="translated">インデックス化されたドキュメントは、SQLiteデータベース内には全く格納されていない(&quot;内容のない &quot;FTS4テーブル)、または</target>
        </trans-unit>
        <trans-unit id="e1d425e949e65fa344c6b8fb0277d12b499d6fc9" translate="yes" xml:space="preserve">
          <source>The indexed documents are stored in a database table created and managed by the user (an &quot;external content&quot; FTS4 table).</source>
          <target state="translated">インデックス化された文書は、ユーザが作成して管理するデータベーステーブル(「外部コンテンツ」FTS4テーブル)に格納される。</target>
        </trans-unit>
        <trans-unit id="4aef068b1a0d56e1caa7dcf9dfa167672f1599ff" translate="yes" xml:space="preserve">
          <source>The infix LIKE operator is implemented by calling the application-defined SQL functions &lt;a href=&quot;lang_corefunc#like&quot;&gt;like(&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;X&lt;/i&gt;)&lt;/a&gt; or &lt;a href=&quot;lang_corefunc#like&quot;&gt;like(&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;X&lt;/i&gt;,&lt;i&gt;Z&lt;/i&gt;)&lt;/a&gt;.</source>
          <target state="translated">中置LIKE演算子は、アプリケーション定義のSQL関数&lt;a href=&quot;lang_corefunc#like&quot;&gt;like（&lt;i&gt;Y&lt;/i&gt;、&lt;i&gt;X&lt;/i&gt;）&lt;/a&gt;または&lt;a href=&quot;lang_corefunc#like&quot;&gt;like（&lt;i&gt;Y&lt;/i&gt;、&lt;i&gt;X&lt;/i&gt;、&lt;i&gt;Z&lt;/i&gt;）を&lt;/a&gt;呼び出すことによって実装されます。</target>
        </trans-unit>
        <trans-unit id="88a733d117cd4f0a7921fa6f2a987e25c2eb02d1" translate="yes" xml:space="preserve">
          <source>The information above can be recast into a table format as follows:</source>
          <target state="translated">上記の情報は、以下のように表形式に再キャストすることができます。</target>
        </trans-unit>
        <trans-unit id="7c260215b8c7aaba3e0315515668088d0bdaae79" translate="yes" xml:space="preserve">
          <source>The information accessed using this API and its companion xPhraseFirstColumn() may also be obtained using xPhraseFirst/xPhraseNext (or xInst/xInstCount). The chief advantage of this API is that it is significantly more efficient than those alternatives when used with &quot;detail=column&quot; tables.</source>
          <target state="translated">このAPIとそれに付随するxPhraseFirstColumn()を使用してアクセスされる情報は、xPhraseFirst/xPhraseNext(またはxInst/xInstCount)を使用して取得することもできます。このAPIの主な利点は、&quot;detail=column &quot;テーブルで使用する場合、これらの代替手段よりも大幅に効率的であるということです。</target>
        </trans-unit>
        <trans-unit id="e6d1054c7b3f35c96345a991890c1e40578c9e8c" translate="yes" xml:space="preserve">
          <source>The information in the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure is ephemeral and may be overwritten or deallocated as soon as the xBestIndex method returns. If the xBestIndex method needs to remember any part of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure, it should make a copy. Care must be take to store the copy in a place where it will be deallocated, such as in the idxStr field with needToFreeIdxStr set to 1.</source>
          <target state="translated">&lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;構造体の情報は一時的なものであり、xBestIndexメソッドが戻るとすぐに上書きまたは割り当て解除される可能性があります。 xBestIndexメソッドが&lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;構造の一部を覚えておく必要がある場合は、コピーを作成する必要があります。コピーが割り当て解除される場所（needToFreeIdxStrが1に設定されているidxStrフィールドなど）に保管するように注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="32cf05e222bbae76e66c5abe0ecf2fd84a3a7c70" translate="yes" xml:space="preserve">
          <source>The information in this article applies only when SQLite is operating in &quot;rollback mode&quot;, or in other words when SQLite is not using a &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt;. SQLite still supports atomic commit when write-ahead logging is enabled, but it accomplishes atomic commit by a different mechanism from the one described in this article. See the &lt;a href=&quot;wal&quot;&gt;write-ahead log documentation&lt;/a&gt; for additional information on how SQLite supports atomic commit in that context.</source>
          <target state="translated">この記事の情報は、SQLiteが「ロールバックモード」で動作している場合、つまりSQLiteが&lt;a href=&quot;wal&quot;&gt;先行書き込みログ&lt;/a&gt;を使用していない場合にのみ適用されます。SQLiteは、先行書き込みロギングが有効な場合でもアトミックコミットをサポートしますが、この記事で説明したメカニズムとは異なるメカニズムによってアトミックコミットを実現します。SQLiteがそのコンテキストでアトミックコミットをサポートする方法の詳細については、&lt;a href=&quot;wal&quot;&gt;先行書き込みログのドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="f9342562e97e372cf7348a184a4d34dd086f3cc5" translate="yes" xml:space="preserve">
          <source>The initial &quot;INSERT&quot; keyword can be replaced by &quot;REPLACE&quot; or &quot;INSERT OR</source>
          <target state="translated">最初の &quot;INSERT &quot;キーワードは、&quot;REPLACE &quot;または &quot;INSERT OR &quot;で置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="d2a90ccaf25a62976be28829cc53054a6feb5a8b" translate="yes" xml:space="preserve">
          <source>The initial content is UTF-16 text and sqlite3_column_bytes() or sqlite3_column_text() is called. The content must be converted to UTF-8.</source>
          <target state="translated">初期内容はUTF-16テキストで、sqlite3_column_bytes()またはsqlite3_column_text()を呼び出します。内容はUTF-8に変換する必要があります。</target>
        </trans-unit>
        <trans-unit id="f5abf60cee620000168958a8b5acfa6d74016d3a" translate="yes" xml:space="preserve">
          <source>The initial content is UTF-8 text and sqlite3_column_bytes16() or sqlite3_column_text16() is called. The content must be converted to UTF-16.</source>
          <target state="translated">初期内容はUTF-8テキストで、sqlite3_column_bytes16()またはsqlite3_column_text16()が呼び出されます。内容をUTF-16に変換する必要があります。</target>
        </trans-unit>
        <trans-unit id="16a79a9ef866be9ddb29420482c978bd29b5a111" translate="yes" xml:space="preserve">
          <source>The initial content is a BLOB and sqlite3_column_text() or sqlite3_column_text16() is called. A zero-terminator might need to be added to the string.</source>
          <target state="translated">初期内容はBLOBで、sqlite3_column_text()またはsqlite3_column_text16()が呼び出されます。文字列にゼロターミネータを追加する必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="e8f78c0547aa09c0045543ed5c95b2ff19b12417" translate="yes" xml:space="preserve">
          <source>The initial implementation of NGQP chooses N=1 for simple queries, N=5 for two-way joins and N=10 for all joins with three or more tables. This formula for selecting N might change in subsequent releases.</source>
          <target state="translated">NGQPの初期実装では、単純なクエリの場合はN=1、双方向結合の場合はN=5、3つ以上のテーブルを持つすべての結合の場合はN=10を選択しています。このNの選択式は、その後のリリースで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="433c6a25716e7b035366d6fcddc3266fd3d25e85" translate="yes" xml:space="preserve">
          <source>The initial portion of the payload that does not spill to overflow pages.</source>
          <target state="translated">オーバーフローページにこぼれないペイロードの初期部分。</target>
        </trans-unit>
        <trans-unit id="a60a09b4b0f1a33259942d5b4f17c8bccd4a335d" translate="yes" xml:space="preserve">
          <source>The inner SELECT statement is implemented by instructions 1 through 10. All this code does is make an entry in the temporary table for each row of the examp2 table with a non-NULL value for the &quot;three&quot; column. The key for each temporary table entry is the &quot;three&quot; column of examp2 and the data is an empty string since it is never used.</source>
          <target state="translated">内部のSELECT文は命令1から10によって実装されています。このコードが行うのは、examp2テーブルの各行の &quot;3 &quot;列にNULLでない値を指定して一時テーブルにエントリを作成することだけです。各テンポラリテーブルのエントリのキーはexamp2の &quot;three &quot;カラムであり、データは決して使用されないので空の文字列となります。</target>
        </trans-unit>
        <trans-unit id="059bc1f5d258819deb1954aaf03c0ff2e66225d4" translate="yes" xml:space="preserve">
          <source>The input data used by a simple SELECT query is a set of</source>
          <target state="translated">単純なSELECTクエリで使用される入力データは</target>
        </trans-unit>
        <trans-unit id="6894645090ea407676b9f33e59a0dad3066f4727" translate="yes" xml:space="preserve">
          <source>The input to &lt;a href=&quot;#sqlite3_complete&quot;&gt;sqlite3_complete()&lt;/a&gt; must be a zero-terminated UTF-8 string.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_complete&quot;&gt;sqlite3_complete（）&lt;/a&gt;への入力は、ゼロで終了するUTF-8文字列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="4d7419b960ffd32c455a130a0e74d0adde2f9624" translate="yes" xml:space="preserve">
          <source>The input to &lt;a href=&quot;#sqlite3_complete&quot;&gt;sqlite3_complete16()&lt;/a&gt; must be a zero-terminated UTF-16 string in native byte order.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_complete&quot;&gt;sqlite3_complete16（）&lt;/a&gt;への入力は、ネイティブバイトオーダーのゼロで終了するUTF-16文字列である必要があります。</target>
        </trans-unit>
        <trans-unit id="4b672bd7f0a1d030d51edf7b207eec2b4f3ae087" translate="yes" xml:space="preserve">
          <source>The input to &lt;a href=&quot;complete&quot;&gt;sqlite3_complete()&lt;/a&gt; must be a zero-terminated UTF-8 string.</source>
          <target state="translated">&lt;a href=&quot;complete&quot;&gt;sqlite3_complete（）&lt;/a&gt;への入力は、ゼロで終了するUTF-8文字列でなければなりません。</target>
        </trans-unit>
        <trans-unit id="cfd5dd711daa7423070d67fd7c844d95a0e5c24f" translate="yes" xml:space="preserve">
          <source>The input to &lt;a href=&quot;complete&quot;&gt;sqlite3_complete16()&lt;/a&gt; must be a zero-terminated UTF-16 string in native byte order.</source>
          <target state="translated">&lt;a href=&quot;complete&quot;&gt;sqlite3_complete16（）&lt;/a&gt;への入力は、ネイティブバイトオーダーのゼロで終了するUTF-16文字列である必要があります。</target>
        </trans-unit>
        <trans-unit id="2d24c8f818c9e23a7423d1fe6a231842fef7a551" translate="yes" xml:space="preserve">
          <source>The inputs to TH3 are test modules written in C or SQL and small configuration files that determine how to initialize SQLite. The TH3 package includes 1,444 test modules and more than 47 configurations (as of 2018-05-19). New modules and configurations can be added to customize TH3 for specialized applications. Each time TH3 is run, it reads a subset of the available test modules and configuration files to generate a custom C program that performs all of the specified tests under all specified configurations. A complete test of SQLite normally involves running TH3 multiple times to generate multiple test programs covering different aspects of SQLite's operation, then linking all test programs against a common SQLite library and running them separately on the target platform.</source>
          <target state="translated">TH3への入力は、C言語またはSQLで書かれたテストモジュールと、SQLiteの初期化方法を決定する小さな設定ファイルです。TH3パッケージには、1,444個のテストモジュールと47個以上の設定ファイルが含まれています(2018-05-19現在)。新しいモジュールや構成を追加して、特殊なアプリケーション用にTH3をカスタマイズすることができます。TH3 を実行するたびに、利用可能なテストモジュールと構成ファイルのサブセットを読み込んで、すべての指定された構成の下で指定されたすべてのテストを実行するカスタム C プログラムを生成します。SQLite の完全なテストを行うには、通常、TH3 を複数回実行して、SQLite の動作の異なる側面をカバーする複数のテストプログラムを生成し、共通の SQLite ライブラリに対してすべてのテストプログラムをリンクして、ターゲットプラットフォーム上で個別に実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="bb4e6367e51d64e49b708aca20c83e616d792f73" translate="yes" xml:space="preserve">
          <source>The inspiration for this document is &lt;a href=&quot;https://en.wikipedia.org/wiki/DO-178B&quot;&gt;DO-178B&lt;/a&gt;. Among quality standards, DO-178B seems to have the highest usefulness to paperwork ratio. Even so, the amount of documentation needed for a full-up DO-178B implementation is vast. SQLite strives to be nimble and low-ceremony, and to that end, much of the required DO-178B documentation is omitted. We retain only those parts that genuinely improve quality for a open-source software project such as SQLite.</source>
          <target state="translated">このドキュメントの発想は&lt;a href=&quot;https://en.wikipedia.org/wiki/DO-178B&quot;&gt;DO-178B&lt;/a&gt;です。品質基準のなかで、DO-178Bは、事務処理比率に対して最も有用性が高いようです。それでも、完全なDO-178B実装に必要なドキュメントの量は膨大です。SQLiteは機敏で控えめなものになるよう努めており、そのために必要なDO-178Bドキュメントの多くは省略されています。SQLiteなどのオープンソースソフトウェアプロジェクトの品質を本当に向上させる部分のみを保持します。</target>
        </trans-unit>
        <trans-unit id="eeb6f7cf85fc1473abd39059a6c5676d36ad32d5" translate="yes" xml:space="preserve">
          <source>The instr(X,Y) function finds the first occurrence of string Y within string X and returns the number of prior characters plus 1, or 0 if Y is nowhere found within X. Or, if X and Y are both BLOBs, then instr(X,Y) returns one more than the number bytes prior to the first occurrence of Y, or 0 if Y does not occur anywhere within X. If both arguments X and Y to instr(X,Y) are non-NULL and are not BLOBs then both are interpreted as strings. If either X or Y are NULL in instr(X,Y) then the result is NULL.</source>
          <target state="translated">instr(X,Y)関数は、文字列 X の中から文字列 Y の最初の出現を見つけ、その前の文字数に 1 を加えたものを返します。また、X と Y が両方とも BLOB である場合は、 instr(X,Y)は Y の最初の出現よりも前のバイト数を 1 つ多く返し、Y が X の中のどこにも出現しない場合は 0 を返します。instr(X,Y)で X または Y のどちらかが NULL の場合、結果は NULL となります。</target>
        </trans-unit>
        <trans-unit id="a78743c67ceb66f35152669e19fad52bf271ff90" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Close&quot;&gt;Close&lt;/a&gt; closes a cursor previously opened as P1 (0, the only open cursor). If P1 is not currently open, this instruction is a no-op.</source>
          <target state="translated">&lt;a href=&quot;opcode#Close&quot;&gt;Close&lt;/a&gt;命令は、以前にP1として開いたカーソル（0、唯一開いているカーソル）を閉じます。P1が現在開いていない場合、この命令は何もしません。</target>
        </trans-unit>
        <trans-unit id="e8c5c65cb041570fcd5ae40ccc7306b738bb99f4" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Commit&quot;&gt;Commit&lt;/a&gt; causes all modifications to the database that have been made since the last Transaction to actually take effect. No additional modifications are allowed until another transaction is started. The Commit instruction deletes the journal file and releases the write lock on the database. A read lock continues to be held if there are still cursors open.</source>
          <target state="translated">&lt;a href=&quot;opcode#Commit&quot;&gt;コミット&lt;/a&gt;命令は、最後のトランザクション以降に行われたデータベースへのすべての変更を実際に有効にします。別のトランザクションが開始されるまで、追加の変更は許可されません。 Commit命令は、ジャーナルファイルを削除し、データベースの書き込みロックを解放します。カーソルがまだ開いている場合、読み取りロックは引き続き保持されます。</target>
        </trans-unit>
        <trans-unit id="71d724f14f1b112c6a8977fb693b84af3a6cb813" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; causes the VDBE engine to exit immediately. All open cursors, Lists, Sorts, etc are closed automatically. P1 is the result code returned by sqlite_exec(). For a normal halt, this should be SQLITE_OK (0). For errors, it can be some other value. The operand P2 is only used when there is an error. There is an implied &quot;Halt 0 0 0&quot; instruction at the end of every program, which the VDBE appends when it prepares a program to run.</source>
          <target state="translated">命令&lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt;はVDBEエンジンをすぐに終了させます。開いているカーソル、リスト、ソートなどはすべて自動的に閉じられます。 P1は、sqlite_exec（）によって返される結果コードです。通常の停止の場合、これはSQLITE_OK（0）になります。エラーの場合、他の値になる可能性があります。オペランドP2は、エラーが発生した場合にのみ使用されます。 VDBEがプログラムを実行する準備をするときにVDBEが追加する暗黙の「Halt 0 0 0 &quot;命令がすべてのプログラムの終わりにあります。</target>
        </trans-unit>
        <trans-unit id="4a2e93cc788564162251660dae046bf0362122e8" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#IdxRecno&quot;&gt;IdxRecno&lt;/a&gt; at 13 pushes onto the stack the table record number from the index. The following MoveTo pops it and moves the table cursor to that row. The next 3 instructions select the column data the same way as in the non- indexed case. The Column instructions fetch the column data and the callback function is invoked. The final Next instruction advances the index cursor, not the table cursor, to the next row, and then branches back to the start of the loop if there are any index records left.</source>
          <target state="translated">13の&lt;a href=&quot;opcode#IdxRecno&quot;&gt;IdxRecno&lt;/a&gt;命令は、インデックスからテーブルレコード番号をスタックにプッシュします。次のMoveToはそれをポップし、テーブルカーソルをその行に移動します。次の3つの命令は、インデックス付けされていない場合と同じ方法で列データを選択します。Column命令は列データをフェッチし、コールバック関数が呼び出されます。最後のNext命令は、テーブルカーソルではなくインデックスカーソルを次の行に進め、インデックスレコードが残っている場合は、ループの先頭に戻ります。</target>
        </trans-unit>
        <trans-unit id="89a91a29199817279a977a2ce4541fd6e7fee24a" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Integer&quot;&gt;Integer&lt;/a&gt; pushes its P1 operand (99) onto the stack. Afterwards the stack looks like this:</source>
          <target state="translated">命令&lt;a href=&quot;opcode#Integer&quot;&gt;Integerは&lt;/a&gt;、そのP1オペランド（99）をスタックにプッシュします。その後、スタックは次のようになります。</target>
        </trans-unit>
        <trans-unit id="15f722b882a29ac5b03a20e923af0ef9dcb502b1" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Integer&quot;&gt;Integer&lt;/a&gt; pushes the integer value P1 (0) onto the stack. Here 0 is the number of the database to use in the following OpenWrite instruction. If P3 is not NULL then it is a string representation of the same integer. Afterwards the stack looks like this:</source>
          <target state="translated">命令&lt;a href=&quot;opcode#Integer&quot;&gt;Integer&lt;/a&gt;は、整数値P1（0）をスタックにプッシュします。ここで0は、次のOpenWrite命令で使用するデータベースの番号です。P3がNULLでない場合、それは同じ整数の文字列表現です。その後、スタックは次のようになります。</target>
        </trans-unit>
        <trans-unit id="d1df5b7ac8ac4ed32e40d9d958d1c725defad872" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; pops the top P1 elements off the stack (2 in this case) and converts them into the binary format used for storing records in a database file. (See the &lt;a href=&quot;fileformat&quot;&gt;file format&lt;/a&gt; description for details.) The new record generated by the MakeRecord instruction is pushed back onto the stack. Afterwards the stack looks like this:</source>
          <target state="translated">&lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;命令は、スタックから上位のP1要素（この場合は2）をポップし、それらをデータベースファイルにレコードを格納するために使用されるバイナリ形式に変換します。（詳細については、&lt;a href=&quot;fileformat&quot;&gt;ファイル形式の&lt;/a&gt;説明を参照してください。）MakeRecord命令によって生成された新しいレコードは、スタックにプッシュバックされます。その後、スタックは次のようになります。</target>
        </trans-unit>
        <trans-unit id="21bb54c4787b5b030612c3d381e1ba9b4bb1f341" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#NewRecno&quot;&gt;NewRecno&lt;/a&gt; creates a new integer record number for the table pointed to by cursor P1. The record number is one not currently used as a key in the table. The new record number is pushed onto the stack. Afterwards the stack looks like this:</source>
          <target state="translated">&lt;a href=&quot;opcode#NewRecno&quot;&gt;NewRecno&lt;/a&gt;命令は、カーソルP1が指すテーブルの新しい整数レコード番号を作成します。レコード番号は、現在テーブルでキーとして使用されていない番号です。新しいレコード番号がスタックにプッシュされます。その後、スタックは次のようになります。</target>
        </trans-unit>
        <trans-unit id="213073395c8927a399e8bb754b1febc0fe16eb95" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#OpenWrite&quot;&gt;OpenWrite&lt;/a&gt; opens a new read/write cursor with handle P1 (0 in this case) on table &quot;examp&quot;, whose root page is P2 (3, in this database file). Cursor handles can be any non-negative integer. But the VDBE allocates cursors in an array with the size of the array being one more than the largest cursor. So to conserve memory, it is best to use handles beginning with zero and working upward consecutively. Here P3 (&quot;examp&quot;) is the name of the table being opened, but this is unused, and only generated to make the code easier to read. This instruction pops the database number to use (0, the main database) from the top of the stack, so afterwards the stack is empty again.</source>
          <target state="translated">&lt;a href=&quot;opcode#OpenWrite&quot;&gt;OpenWrite&lt;/a&gt;命令は、ルートページがP2（このデータベースファイルでは3）であるテーブル &quot;examp&quot;のハンドルP1（この場合は0）で新しい読み取り/書き込みカーソルを開きます。カーソルハンドルは、負でない整数にすることができます。ただし、VDBEは、配列のサイズが最大のカーソルよりも1つ大きい配列にカーソルを割り当てます。したがって、メモリを節約するために、ゼロから始まり、上に向かって連続的に処理するハンドルを使用するのが最善です。ここでP3（ &quot;examp&quot;）は開かれているテーブルの名前ですが、これは未使用であり、コードを読みやすくするためにのみ生成されます。この命令は、使用するデータベース番号（0、メインデータベース）をスタックの一番上からポップするため、その後スタックは再び空になります。</target>
        </trans-unit>
        <trans-unit id="98bb30ff1b874474319c63eb890c40ec0fb09de2" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#PutIntKey&quot;&gt;PutIntKey&lt;/a&gt; uses the top 2 stack entries to write an entry into the table pointed to by cursor P1. A new entry is created if it doesn't already exist or the data for an existing entry is overwritten. The record data is the top stack entry, and the key is the next entry down. The stack is popped twice by this instruction. Because operand P2 is 1 the row change count is incremented and the rowid is stored for subsequent return by the sqlite_last_insert_rowid() function. If P2 is 0 the row change count is unmodified. This instruction is where the insert actually occurs.</source>
          <target state="translated">&lt;a href=&quot;opcode#PutIntKey&quot;&gt;PutIntKey&lt;/a&gt;命令は、上位2つのスタックエントリを使用して、カーソルP1が指すテーブルにエントリを書き込みます。エントリが存在しない場合、または既存のエントリのデータが上書きされた場合は、新しいエントリが作成されます。レコードデータは一番上のスタックエントリで、キーは次のエントリです。この命令により、スタックが2回ポップされます。オペランドP2が1であるため、行変更カウントが増分され、sqlid_last_insert_rowid（）関数による後続の戻りのために行IDが格納されます。P2が0の場合、行変更カウントは変更されません。この命令は、実際に挿入が行われる場所です。</target>
        </trans-unit>
        <trans-unit id="0b320ec6225176f371f5c1f951d40976365b4443" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; pushes its P3 operand onto the stack. Afterwards the stack looks like this:</source>
          <target state="translated">命令&lt;a href=&quot;opcode#String&quot;&gt;ストリングは&lt;/a&gt;、そのP3オペランドをスタックにプッシュします。その後、スタックは次のようになります。</target>
        </trans-unit>
        <trans-unit id="d914ce420de942b21ca6d5eb303d1b4bdd87f483" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#Transaction&quot;&gt;Transaction&lt;/a&gt; begins a transaction. The transaction ends when a Commit or Rollback opcode is encountered. P1 is the index of the database file on which the transaction is started. Index 0 is the main database file. A write lock is obtained on the database file when a transaction is started. No other process can read or write the file while the transaction is underway. Starting a transaction also creates a rollback journal. A transaction must be started before any changes can be made to the database.</source>
          <target state="translated">命令&lt;a href=&quot;opcode#Transaction&quot;&gt;Transaction&lt;/a&gt;はトランザクションを開始します。トランザクションは、コミットまたはロールバックのオペコードが検出されると終了します。 P1は、トランザクションが開始されるデータベースファイルのインデックスです。インデックス0はメインデータベースファイルです。トランザクションが開始されると、データベースファイルの書き込みロックが取得されます。トランザクションの進行中は、他のプロセスはファイルを読み書きできません。トランザクションを開始すると、ロールバックジャーナルも作成されます。データベースに変更を加える前に、トランザクションを開始する必要があります。</target>
        </trans-unit>
        <trans-unit id="766fac627c726045a9f4c4dcb9828d544fcadbb2" translate="yes" xml:space="preserve">
          <source>The instruction &lt;a href=&quot;opcode#VerifyCookie&quot;&gt;VerifyCookie&lt;/a&gt; checks cookie 0 (the database schema version) to make sure it is equal to P2 (the value obtained when the database schema was last read). P1 is the database number (0 for the main database). This is done to make sure the database schema hasn't been changed by another thread, in which case it has to be reread.</source>
          <target state="translated">&lt;a href=&quot;opcode#VerifyCookie&quot;&gt;VerifyCookie&lt;/a&gt;命令は、cookie 0（データベーススキーマのバージョン）をチェックして、それがP2（データベーススキーマが最後に読み取られたときに取得された値）と等しいことを確認します。 P1はデータベース番号です（メインデータベースの場合は0）。これは、データベーススキーマが別のスレッドによって変更されていないことを確認するために行われます。この場合、再度読み取る必要があります。</target>
        </trans-unit>
        <trans-unit id="1541b9a811a194a4f9e80a336055e479ef3f480e" translate="yes" xml:space="preserve">
          <source>The instruction at address 9 implements the branching part of the loop. Together with the Rewind at address 5 it forms the loop logic. This is a key concept that you should pay close attention to. The &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; instruction advances the cursor P1 to the next record. If the cursor advance was successful, then jump immediately to P2 (6, the beginning of the loop body). If the cursor was at the end, then fall through to the following instruction, which ends the loop.</source>
          <target state="translated">アドレス9の命令は、ループの分岐部分を実装します。アドレス5の巻き戻しとともにループロジックを形成します。これは、注意が必要な重要な概念です。&lt;a href=&quot;opcode#Next&quot;&gt;次&lt;/a&gt;の命令は、次のレコードにカーソルP1を進めます。カーソルの移動が成功した場合は、すぐにP2（6、ループ本体の先頭）にジャンプします。カーソルが最後にあった場合は、次の命令に進み、ループを終了します。</target>
        </trans-unit>
        <trans-unit id="14da6ae11560ca2b2c31ae75e094431766a4621e" translate="yes" xml:space="preserve">
          <source>The instruction at the address in register P1 is a &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt;. &lt;a href=&quot;opcode#Jump&quot;&gt;Jump&lt;/a&gt; to the P2 parameter of that &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt;. After the jump, register P1 becomes undefined.</source>
          <target state="translated">レジスタP1のアドレスにある命令は&lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt;です。その&lt;a href=&quot;opcode#Yield&quot;&gt;Yieldの&lt;/a&gt; P2パラメータに&lt;a href=&quot;opcode#Jump&quot;&gt;ジャンプ&lt;/a&gt;します。ジャンプ後、レジスタP1は不定になります。</target>
        </trans-unit>
        <trans-unit id="cd201e480371afb73e8686f10704843996fccd91" translate="yes" xml:space="preserve">
          <source>The instructions 6 through 8 form the body of the loop that will execute once for each record in the database file. The &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; instructions at addresses 6 and 7 each take the P2-th column from the P1-th cursor and push it onto the stack. In this example, the first Column instruction is pushing the value for the column &quot;one&quot; onto the stack and the second Column instruction is pushing the value for column &quot;two&quot;. The &lt;a href=&quot;opcode#Callback&quot;&gt;Callback&lt;/a&gt; instruction at address 8 invokes the callback() function. The P1 operand to Callback becomes the value for &lt;b&gt;nColumn&lt;/b&gt;. The Callback instruction pops P1 values from the stack and uses them to fill the &lt;b&gt;azData[]&lt;/b&gt; array.</source>
          <target state="translated">命令6〜8は、データベースファイルの各レコードに対して1回実行されるループの本体を形成します。アドレス6と7 の&lt;a href=&quot;opcode#Column&quot;&gt;列&lt;/a&gt;命令は、それぞれP1番目のカーソルからP2番目の列を取り出し、それをスタックにプッシュします。この例では、最初の列命令が列「1」の値をスタックにプッシュし、2番目の列命令が列「2」の値をプッシュしています。アドレス8 の&lt;a href=&quot;opcode#Callback&quot;&gt;Callback&lt;/a&gt;命令は、callback（）関数を呼び出します。 CallbackのP1オペランドが&lt;b&gt;nColumn&lt;/b&gt;の値に&lt;b&gt;なり&lt;/b&gt;ます。コールバック命令は、スタックからP1値をポップし、それらを使用して&lt;b&gt;azData []&lt;/b&gt;配列を埋めます。</target>
        </trans-unit>
        <trans-unit id="c46964020db9e221e22ce0203153f52f7c4afbe0" translate="yes" xml:space="preserve">
          <source>The integer values returned by two invocations of &quot;PRAGMA data_version&quot; from the same connection will be different if changes were committed to the database by any other connection in the interim. The &quot;PRAGMA data_version&quot; value is unchanged for commits made on the same database connection. The behavior of &quot;PRAGMA data_version&quot; is the same for all database connections, including database connections in separate processes and &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; database connections.</source>
          <target state="translated">同じ接続から &quot;PRAGMA data_version&quot;を2回呼び出して返された整数値は、変更が途中で他の接続によってデータベースにコミットされた場合は異なります。 「PRAGMA data_version」の値は、同じデータベース接続で行われたコミットでは変更されません。 「PRAGMA data_version」の動作は、個別のプロセスでのデータベース接続や&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュ&lt;/a&gt;データベース接続を含む、すべてのデータベース接続で同じです。</target>
        </trans-unit>
        <trans-unit id="4e05f2b57d17a355c0ea1387908101e6bd52b31e" translate="yes" xml:space="preserve">
          <source>The integer values to xLock() and xUnlock() are one of</source>
          <target state="translated">xLock()および xUnlock()への整数値は、次のいずれかの値です。</target>
        </trans-unit>
        <trans-unit id="3a9652af526f0c1e8a87ab92c4d5d7f777a76ac5" translate="yes" xml:space="preserve">
          <source>The integrity-check command is invoked by inserting the text value 'integrity-check' into the special column with the same name as the FTS5 table. For example:</source>
          <target state="translated">integrity-checkコマンドは、FTS5テーブルと同じ名前の特別な列にテキスト値'integrity-check'を挿入することで起動されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="8b9cbbc162055ec87304da9b44deb92f428d9750" translate="yes" xml:space="preserve">
          <source>The intended use of this pragma is only for testing and validation of SQLite. This pragma is subject to change without notice and is not recommended for use by application programs.</source>
          <target state="translated">このプラグマの使用目的は、SQLiteのテストと検証のみです。このプラグマは予告なく変更されることがあり、アプリケーションプログラムでの使用は推奨されません。</target>
        </trans-unit>
        <trans-unit id="ff65b14ad46243e5d5f2ba9708d0bfaa67d238c4" translate="yes" xml:space="preserve">
          <source>The intent of the developers is to support SQLite through the year 2050.</source>
          <target state="translated">開発者の意図は、2050年までSQLiteをサポートすることです。</target>
        </trans-unit>
        <trans-unit id="b8c5c15fb8411770e1f2302c0a93c745cb58106c" translate="yes" xml:space="preserve">
          <source>The intent of these enhancements to the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; and &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; commands is to ensure that they cannot be used to create a database that contains foreign key violations, at least while foreign key constraints are enabled. There is one exception to this rule though. If a parent key is not subject to a PRIMARY KEY or UNIQUE constraint created as part of the parent table definition, but is subject to a UNIQUE constraint by virtue of an index created using the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; command, then the child table may be populated without causing a &quot;foreign key mismatch&quot; error. If the UNIQUE index is dropped from the database schema, then the parent table itself is dropped, no error will be reported. However the database may be left in a state where the child table of the foreign key constraint contains rows that do not refer to any parent table row. This case can be avoided if all parent keys in the database schema are constrained by PRIMARY KEY or UNIQUE constraints added as part of the parent table definition, not by external UNIQUE indexes.</source>
          <target state="translated">&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;および&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;コマンドに対するこれらの機能強化の目的は、少なくとも外部キー制約が有効になっている間は、これらを使用して外部キー違反を含むデータベースを作成できないようにすることです。ただし、このルールには例外が1つあります。親キーが、親テーブル定義の一部として作成されたPRIMARY KEYまたはUNIQUE制約の対象ではないが、&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;を使用して作成されたインデックスによってUNIQUE制約の対象である場合コマンドを実行すると、「外部キーの不一致」エラーを発生させることなく、子テーブルにデータが入力されます。UNIQUEインデックスがデータベーススキーマから削除されると、親テーブル自体も削除され、エラーは報告されません。ただし、データベースは、外部キー制約の子テーブルに、親テーブルの行を参照しない行が含まれている状態のままになる場合があります。このケースは、データベーススキーマのすべての親キーが、外部UNIQUEインデックスではなく、親テーブル定義の一部として追加されたPRIMARY KEYまたはUNIQUE制約によって制約されている場合に回避できます。</target>
        </trans-unit>
        <trans-unit id="f25fb84e751737880254b9bbae4d5bcd681d4573" translate="yes" xml:space="preserve">
          <source>The interface between the VDBE and B-Tree layer is enhanced such that the VDBE provides hints to the B-Tree layer letting the B-Tree layer know when it is safe to use hashing instead of B-Trees for transient tables.</source>
          <target state="translated">VDBE と B-Tree 層の間のインタフェースが強化され、VDBE が B-Tree 層にヒントを提供し、B-Tree 層が過渡的なテーブルに B-Tree の代わりにハッシュを使用しても安全なときを知らせるようになりました。</target>
        </trans-unit>
        <trans-unit id="8f6df7d6e95fb6e2e2d0cc834a6496c76dd46264" translate="yes" xml:space="preserve">
          <source>The interface to the B-tree subsystem and the rest of the SQLite library is defined by the header file &lt;a href=&quot;https://sqlite.org/src/file/src/btree.h&quot;&gt;btree.h&lt;/a&gt;.</source>
          <target state="translated">Bツリーサブシステムと残りのSQLiteライブラリへのインターフェイスは、ヘッダーファイル&lt;a href=&quot;https://sqlite.org/src/file/src/btree.h&quot;&gt;btree.h&lt;/a&gt;によって定義されます。</target>
        </trans-unit>
        <trans-unit id="b91796ad2d511be2d8979f83ba1c6fb0431a4019" translate="yes" xml:space="preserve">
          <source>The interface to the SQLite library consists of single tcl command named &lt;b&gt;sqlite3&lt;/b&gt; Because there is only this one command, the interface is not placed in a separate namespace.</source>
          <target state="translated">SQLiteライブラリへのインターフェイスは、&lt;b&gt;sqlite3&lt;/b&gt;という名前の単一のtclコマンドで構成されています。このコマンドは1つしかないため、インターフェイスは別の名前空間に配置されません。</target>
        </trans-unit>
        <trans-unit id="3c849c0d323b0ad6135a0bb1621f8f7a986a9fa1" translate="yes" xml:space="preserve">
          <source>The interface to the SQLite library consists of three core functions, one opaque data structure, and some constants used as return values. The core interface is as follows:</source>
          <target state="translated">SQLite ライブラリへのインターフェイスは、3 つのコア関数、1 つの不透明なデータ構造、戻り値として使用されるいくつかの定数で構成されています。コアとなるインターフェイスは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="da5910db62046423c913e2518dadca7a36c2bb7d" translate="yes" xml:space="preserve">
          <source>The interface used by the implementation of the aforementioned functions to retrieve the collation sequence set by this opcode is not available publicly. Only built-in functions have access to this feature.</source>
          <target state="translated">このオペコードによって設定された照合順序を取得するために前記関数の実装によって使用されるインタフェースは公開されていない。組込み関数のみがこの機能にアクセスできる。</target>
        </trans-unit>
        <trans-unit id="1824212549f384e7aed12eb3886c9cf696af6dde" translate="yes" xml:space="preserve">
          <source>The interfaces necessary to construct a function that is sometimes deterministic and sometimes non-deterministic depending on their inputs, such as the built-in date/time functions, are not published. Generic &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; must be always deterministic or always non-deterministic.</source>
          <target state="translated">組み込みの日付/時刻関数など、入力に応じて決定論的である場合と非決定論的である場合がある関数を構築するために必要なインターフェイスは公開されていません。一般的な&lt;a href=&quot;appfunc&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;は、常に決定論的または常に非決定論的である必要があります。</target>
        </trans-unit>
        <trans-unit id="82c461e3315f13aa8457935ffce58f8ac7ef7cd3" translate="yes" xml:space="preserve">
          <source>The interfaces necessary to construct a function that is sometimes deterministic and sometimes non-deterministic depending on their inputs, such as the built-in date/time functions, are not published. Generic &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; must be always deterministic or always non-deterministic.</source>
          <target state="translated">組み込みの日付/時刻関数など、入力に応じて時々決定的または非決定的である関数を構築するために必要なインターフェースは公開されていません。一般的な&lt;a href=&quot;c3ref/create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;は、常に確定的であるか、常に非確定的でなければなりません。</target>
        </trans-unit>
        <trans-unit id="15015bc60e3376a39ca9d7ebc27d602beffae1d0" translate="yes" xml:space="preserve">
          <source>The internal Mem object stores the value for a single register. The abstract &lt;a href=&quot;c3ref/value&quot;&gt;sqlite3_value&lt;/a&gt; object that is exposed in the API is really just a Mem object or register.</source>
          <target state="translated">内部のMemオブジェクトは、単一のレジスタの値を格納します。APIで公開される抽象的な&lt;a href=&quot;c3ref/value&quot;&gt;sqlite3_value&lt;/a&gt;オブジェクトは、実際には単なるMemオブジェクトまたはレジスタです。</target>
        </trans-unit>
        <trans-unit id="e1059fa5a511cb460ad6acfc6dbdaaa7898a9f5d" translate="yes" xml:space="preserve">
          <source>The internal organization of the SQLite library can be viewed as the stack of modules shown to the right. The Tokenizer, Parser, and Code Generator components are used to process SQL statements and convert them into executable programs in a virtual machine language or byte code. Roughly speaking, these top three layers implement &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;. The byte code generated by the top three layers is a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt;. The Virtual Machine module is responsible for running the SQL statement byte code. The B-Tree module organizes a database file into multiple key/value stores with ordered keys and logarithmic performance. The Pager module is responsible for loading pages of the database file into memory, for implementing and controlling transactions, and for creating and maintaining the journal files that prevent database corruption following a crash or power failure. The OS Interface is a thin abstraction that provides a common set of routines for adapting SQLite to run on different operating systems. Roughly speaking, the bottom four layers implement &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;.</source>
          <target state="translated">SQLiteライブラリの内部構成は、右に示すモジュールのスタックと見なすことができます。 Tokenizer、Parser、およびCode Generatorコンポーネントは、SQLステートメントを処理し、それらを仮想マシン言語またはバイトコードの実行可能プログラムに変換するために使用されます。大まかに言えば、これらの上位3つの層は&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）を&lt;/a&gt;実装します。上位3つの層によって生成されたバイトコードは、&lt;a href=&quot;c3ref/stmt&quot;&gt;準備されたステートメントです。&lt;/a&gt;。仮想マシンモジュールは、SQLステートメントのバイトコードを実行します。Bツリーモジュールは、データベースファイルを複数のキー/値ストアに編成し、順序付けられたキーと対数パフォーマンスを備えています。Pagerモジュールは、データベースファイルのページのメモリへのロード、トランザクションの実装と制御、およびクラッシュや停電後のデータベースの破損を防ぐジャーナルファイルの作成と維持を担当します。OSインターフェースは、SQLiteをさまざまなオペレーティングシステムで実行できるように適合させるための共通のルーチンセットを提供する薄い抽象概念です。おおまかに言って、下の4つのレイヤーは&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）を&lt;/a&gt;実装しています。</target>
        </trans-unit>
        <trans-unit id="b82fe06906efdf8da65bc9a3b09aabf0c14e629e" translate="yes" xml:space="preserve">
          <source>The internet is an increasingly hostile place. These day, developers should assume that attackers will find a way to execute arbitrary SQL in an application. Applications should be designed to prevent the execution of arbitrary SQL from escalating into a more severe exploit.</source>
          <target state="translated">インターネットはますます敵対的な場所となっています。今日、開発者は、攻撃者がアプリケーションで任意の SQL を実行する方法を見つけることを想定しなければなりません。アプリケーションは、任意の SQL の実行がより深刻な悪用へとエスカレートするのを防ぐように設計されなければなりません。</target>
        </trans-unit>
        <trans-unit id="541368df6be3b3211d485998b29f10dd5bcba535" translate="yes" xml:space="preserve">
          <source>The interpretation of the final column, if it is present, is &lt;a href=&quot;swarmvtab#component_table_context_values&quot;&gt;described here&lt;/a&gt;.</source>
          <target state="translated">最終列が存在する場合の解釈&lt;a href=&quot;swarmvtab#component_table_context_values&quot;&gt;について&lt;/a&gt;は、ここで説明します。</target>
        </trans-unit>
        <trans-unit id="ecf9411adae8ae3787bf4274e751f3717d6110f0" translate="yes" xml:space="preserve">
          <source>The ioctl on Mac OS X to control syncing to disk is F_FULLFSYNC, not F_FULLSYNC. The previous release had it wrong.</source>
          <target state="translated">Mac OS X でディスクへの同期を制御するための ioctl は F_FULLSYNC ではなく F_FULLFSYNC です。以前のリリースでは間違っていました。</target>
        </trans-unit>
        <trans-unit id="d9c0a5f06c6830c793bad013d5441e96d45f8af0" translate="yes" xml:space="preserve">
          <source>The job of the eval method is to execute the SQL statement or statements given in the second argument. For example, to create a new table in a database, you can do this:</source>
          <target state="translated">evalメソッドの仕事は、第2引数で与えられたSQL文またはステートメントを実行することです。例えば、データベースに新しいテーブルを作成するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="ce55e90a07de980cc86c5f2dfac419a865729e47" translate="yes" xml:space="preserve">
          <source>The job of this method is to construct the new virtual table object (an &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; object) and return a pointer to it in *ppVTab.</source>
          <target state="translated">このメソッドの仕事は、新しい仮想テーブルオブジェクト（&lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt;オブジェクト）を作成し、* ppVTabにそのポインターを返すことです。</target>
        </trans-unit>
        <trans-unit id="82b29f2835b0336ce594d7095e779f9ce1307885" translate="yes" xml:space="preserve">
          <source>The journal header is non-zero and well-formed, and</source>
          <target state="translated">ジャーナルヘッダはゼロではなく、整形されています。</target>
        </trans-unit>
        <trans-unit id="3978774f2c0624ee0736d9f40af64bca3b94a2e0" translate="yes" xml:space="preserve">
          <source>The journal tests are an additional double-check over and above the crash tests to make sure that SQLite transactions will be atomic across system crashes and power failures.</source>
          <target state="translated">ジャーナルテストは、システムのクラッシュや停電時に SQLite トランザクションがアトミックになることを確認するための、クラッシュテスト以上の追加のダブルチェックです。</target>
        </trans-unit>
        <trans-unit id="eadea62ca220c75cf3d8b7ee7d22ba8de7aa3934" translate="yes" xml:space="preserve">
          <source>The journal_mode pragma returns a string which is the new journal mode. On success, the pragma will return the string &quot;&lt;code&gt;wal&lt;/code&gt;&quot;. If the conversion to WAL could not be completed (for example, if the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; does not support the necessary shared-memory primitives) then the journaling mode will be unchanged and the string returned from the primitive will be the prior journaling mode (for example &quot;&lt;code&gt;delete&lt;/code&gt;&quot;).</source>
          <target state="translated">journal_modeプラグマは、新しいジャーナルモードである文字列を返します。成功すると、プラグマは文字列「 &lt;code&gt;wal&lt;/code&gt; 」を返します。WALへの変換を完了できなかった場合（たとえば、&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;が必要な共有メモリプリミティブをサポートしていない場合）、ジャーナリングモードは変更されず、プリミティブから返された文字列は以前のジャーナリングモードになります（たとえば「「」を &lt;code&gt;delete&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="cf12bc7373958f09d761ed0f9bf5075e87444a0e" translate="yes" xml:space="preserve">
          <source>The journal_size_limit pragma may be used to limit the size of rollback-journal and WAL files left in the file-system after transactions or checkpoints. Each time a transaction is committed or a WAL file resets, SQLite compares the size of the rollback journal file or WAL file left in the file-system to the size limit set by this pragma and if the journal or WAL file is larger it is truncated to the limit.</source>
          <target state="translated">journal_size_limit pragma を使用して、トランザクションやチェックポイントの後にファイルシステムに残されたロールバックジャーナルファイルや WAL ファイルのサイズを制限することができます。トランザクションがコミットされたり、WAL ファイルがリセットされたりするたびに、SQLite はファイルシステムに残っているロールバックジャーナルファイルや WAL ファイルのサイズをこのプラグマで設定されたサイズ制限値と比較し、ジャーナルファイルや WAL ファイルの方が大きい場合は制限値まで切り捨てられます。</target>
        </trans-unit>
        <trans-unit id="e4ee7815366ce998637e6c73fab93997f9ad3bf9" translate="yes" xml:space="preserve">
          <source>The json(X) function verifies that its argument X is a valid JSON string and returns a minified version of that JSON string (with all unnecessary whitespace removed). If X is not a well-formed JSON string, then this routine throws an error.</source>
          <target state="translated">json(X)関数は、引数 X が有効な JSON 文字列であることを検証し、その JSON 文字列の最小化されたバージョンを返します (不要な空白はすべて削除されています)。X が整形された JSON 文字列でない場合、このルーチンはエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="b38a8f8844d02f721e88e8305af9dc835b4312f1" translate="yes" xml:space="preserve">
          <source>The json1 extension (currently) stores JSON as ordinary text.</source>
          <target state="translated">json1 拡張機能(現在)は、JSON を普通のテキストとして保存します。</target>
        </trans-unit>
        <trans-unit id="600cff3bfb9b2a0fb597c7fc0f7fa3f65076ca7b" translate="yes" xml:space="preserve">
          <source>The json1 extension does not (currently) support a binary encoding of JSON. Experiments have been unable to find a binary encoding that is significantly smaller or faster than a plain text encoding. (The present implementation parses JSON text at over 1 GB/s.) All json1 functions currently throw an error if any of their arguments are BLOBs because BLOBs are reserved for a future enhancement in which BLOBs will store the binary encoding for JSON.</source>
          <target state="translated">json1 拡張モジュールは (現在のところ)JSON のバイナリエンコーディングをサポートしていません。実験では、プレインテキストのエンコーディングよりも著しく小さいか高速なバイナリエンコーディングを見つけることができませんでした。(現在の実装では、1GB/s以上の速度でJSONテキストを解析します。)すべてのjson1関数は現在、引数のいずれかがBLOBである場合にエラーをスローしますが、これはBLOBがJSONのバイナリエンコーディングを保存する将来の拡張機能のために予約されているからです。</target>
        </trans-unit>
        <trans-unit id="50447979a47d38485f569438ae4849e4fe11a47d" translate="yes" xml:space="preserve">
          <source>The json1 extension uses the &lt;a href=&quot;c3ref/value_subtype&quot;&gt;sqlite3_value_subtype()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; interfaces that were introduced with SQLite version 3.9.0 (2015-10-14) The json1 extension will not work in earlier versions of SQLite.</source>
          <target state="translated">json1拡張機能は、SQLiteバージョン3.9.0（2015-10-14）で導入された&lt;a href=&quot;c3ref/value_subtype&quot;&gt;sqlite3_value_subtype（）&lt;/a&gt;および&lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype（）&lt;/a&gt;インターフェースを使用します。json1拡張機能は、以前のバージョンのSQLiteでは機能しません。</target>
        </trans-unit>
        <trans-unit id="96336d37aaa994d4a790a5daf6a1eabf939e9f47" translate="yes" xml:space="preserve">
          <source>The json1 source code is included with the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, though it is disabled by default. Add the &lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt; compile-time option to enable the json1 extension that is built into the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. The standard makefiles include -DSQLITE_ENABLE_JSON1 when building the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; and some of the test utilities so this extension is normally available in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">json1ソースコードはSQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamationに&lt;/a&gt;含まれていますが、デフォルトでは無効になっています。&lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt;コンパイル時オプションを追加して、&lt;a href=&quot;amalgamation&quot;&gt;統合に&lt;/a&gt;組み込まれているjson1拡張機能を有効にします。&lt;a href=&quot;cli&quot;&gt;コマンドラインシェル&lt;/a&gt;と一部のテストユーティリティをビルドする場合、標準のメイクファイルには-DSQLITE_ENABLE_JSON1が含まれているため、この拡張機能は通常、&lt;a href=&quot;cli&quot;&gt;コマンドラインシェルで&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="bb08cc12ccf8da2d3e2af52ece257a447253b7e8" translate="yes" xml:space="preserve">
          <source>The json_array() SQL function accepts zero or more arguments and returns a well-formed JSON array that is composed from those arguments. If any argument to json_array() is a BLOB then an error is thrown.</source>
          <target state="translated">json_array()SQL 関数は、0 個以上の引数を受け取り、それらの引数から構成される整形された JSON 配列を返します。json_array()への引数のいずれかが BLOB である場合は、エラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="9521182f315a0d302eb912198a80302f20c295c7" translate="yes" xml:space="preserve">
          <source>The json_array_length(X) function returns the number of elements in the JSON array X, or 0 if X is some kind of JSON value other than an array. The json_array_length(X,P) locates the array at path P within X and returns the length of that array, or 0 if path P locates an element or X other than a JSON array, and NULL if path P does not locate any element of X. Errors are thrown if either X is not well-formed JSON or if P is not a well-formed path.</source>
          <target state="translated">json_array_length(X)関数は、JSON配列Xの要素数を返し、Xが配列以外のJSON値の場合は0を返します。json_array_length(X,P)は X の中のパス P で配列を探し、その配列の長さを返します。パス P が JSON 配列以外の要素や X を見つけた場合は 0、パス P が X の要素を見つけなかった場合は NULL を返します。</target>
        </trans-unit>
        <trans-unit id="a38155ffebbf6577ab0909bd9445bf04a40481a5" translate="yes" xml:space="preserve">
          <source>The json_each(X) and json_tree(X) &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; walk the JSON value provided as their first argument and return one row for each element. The json_each(X) function only walks the immediate children of the top-level array or object or or just the top-level element itself if the top-level element is a primitive value. The json_tree(X) function recursively walks through the JSON substructure starting with the top-level element.</source>
          <target state="translated">json_each（X）およびjson_tree（X）&lt;a href=&quot;vtab#tabfunc2&quot;&gt;テーブル値関数&lt;/a&gt;は、最初の引数として提供されたJSON値をたどり、要素ごとに1行を返します。json_each（X）関数は、最上位の配列またはオブジェクトの直接の子、または最上位の要素がプリミティブ値の場合は最上位の要素自体のみをウォークします。json_tree（X）関数は、最上位要素から始まるJSONサブ構造を再帰的にウォークスルーします。</target>
        </trans-unit>
        <trans-unit id="41fff21b05289cb2b0be52b887077b0fcae3db31" translate="yes" xml:space="preserve">
          <source>The json_each(X,P) and json_tree(X,P) functions work just like their one-argument counterparts except that they treat the element identified by path P as the top-level element.</source>
          <target state="translated">json_each(X,P)と json_tree(X,P)関数は、パス P で識別される要素をトップレベルの要素として扱うという点を除いては、1引数の場合と同じように動作します。</target>
        </trans-unit>
        <trans-unit id="c2ff80179397d0e306699ce5e6f1d0c9aff0af74" translate="yes" xml:space="preserve">
          <source>The json_extract(X,P1,P2,...) extracts and returns one or more values from the well-formed JSON at X. If only a single path P1 is provided, then the SQL datatype of the result is NULL for a JSON null, INTEGER or REAL for a JSON numeric value, an INTEGER zero for a JSON false value, an INTEGER one for a JSON true value, the dequoted text for a JSON string value, and a text representation for JSON object and array values. If there are multiple path arguments (P1, P2, and so forth) then this routine returns SQLite text which is a well-formed JSON array holding the various values.</source>
          <target state="translated">json_extract(X,P1,P2,...)は、Xの整形されたJSONから1つ以上の値を抽出して返します。単一のパスP1のみが提供されている場合、結果のSQLデータ型は、JSON NULLの場合はNULL、JSON数値の場合はINTEGERまたはREAL、JSON偽値の場合はINTEGER 0、JSON真値の場合はINTEGER 1、JSON文字列値の場合は引用符で囲まれたテキスト、JSONオブジェクトおよび配列値の場合はテキスト表現となります。複数のパス引数(P1、P2など)がある場合、このルーチンは様々な値を保持する整形されたJSON配列であるSQLiteテキストを返します。</target>
        </trans-unit>
        <trans-unit id="0f1627c2753898c7b2ebba7d223fce4a18da0c11" translate="yes" xml:space="preserve">
          <source>The json_group_array(X) function is an &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate SQL function&lt;/a&gt; that returns a JSON array comprised of all X values in the aggregation. Similarly, the json_group_object(NAME,VALUE) function returns a JSON object comprised of all NAME/VALUE pairs in the aggregation.</source>
          <target state="translated">json_group_array（X）関数は、&lt;a href=&quot;lang_aggfunc&quot;&gt;集計&lt;/a&gt;のすべてのX値で構成されるJSON配列を返す集計SQL関数です。同様に、json_group_object（NAME、VALUE）関数は、集計内のすべてのNAME / VALUEペアで構成されるJSONオブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="08b54ec339ea85bd242a6d5ab159f649d0636c35" translate="yes" xml:space="preserve">
          <source>The json_insert(), json_replace(), and json_set() functions always take an odd number of arguments. The first argument is always the original JSON to be edited. Subsequent arguments occur in pairs with the first element of each pair being a path and the second element being the value to insert or replace or set on that path.</source>
          <target state="translated">json_insert()、json_replace()、およびjson_set()関数は常に奇数の引数を取ります。最初の引数は常に編集する元のJSONです。それ以降の引数はペアになっていて、それぞれのペアの最初の要素がパスで、2番目の要素がそのパスに挿入、置換、設定する値となります。</target>
        </trans-unit>
        <trans-unit id="cc677da89c2d6a3534f49f58dca0325fe7275ac0" translate="yes" xml:space="preserve">
          <source>The json_insert(), json_replace, and json_set() functions all take a single JSON value as their first argument followed by zero or more pairs of path and value arguments, and return a new JSON string formed by updating the input JSON by the path/value pairs. The functions differ only in how they deal with creating new values and overwriting preexisting values.</source>
          <target state="translated">json_insert()、json_replace、および json_set()関数はすべて、最初の引数として単一の JSON 値を受け取り、その後に 0 個以上のパスと値のペアの引数をとり、入力 JSON をパスと値のペアで更新することで形成される新しい JSON 文字列を返します。これらの関数の違いは、新しい値を作成したり既存の値を上書きしたりする方法だけです。</target>
        </trans-unit>
        <trans-unit id="a89fe09131a222458243e59c86a47b9418f5cefc" translate="yes" xml:space="preserve">
          <source>The json_object() SQL function accepts zero or more pairs of arguments and returns a well-formed JSON object that is composed from those arguments. The first argument of each pair is the label and the second argument of each pair is the value. If any argument to json_object() is a BLOB then an error is thrown.</source>
          <target state="translated">json_object()SQL 関数は、0 個以上の引数のペアを受け取り、それらの引数から構成される整形された JSON オブジェクトを返します。各ペアの第一引数はラベルで、各ペアの第二引数は値です。json_object()への引数のいずれかが BLOB である場合は、エラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="2288fffe16f420052bb17e5c8958c3ccdbc841f2" translate="yes" xml:space="preserve">
          <source>The json_object() function currently allows duplicate labels without complaint, though this might change in a future enhancement.</source>
          <target state="translated">json_object()関数は現在のところ文句なしにラベルの重複を許可していますが、これは将来の拡張機能で変更されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="5e496b884466eb1ac12c106e9502f3cd98163883" translate="yes" xml:space="preserve">
          <source>The json_patch(T,P) SQL function runs the &lt;a href=&quot;https://tools.ietf.org/html/rfc7396&quot;&gt;RFC-7396&lt;/a&gt; MergePatch algorithm to apply patch P against input T. The patched copy of T is returned.</source>
          <target state="translated">json_patch（T、P）SQL関数は&lt;a href=&quot;https://tools.ietf.org/html/rfc7396&quot;&gt;RFC-7396&lt;/a&gt; MergePatchアルゴリズムを実行して、入力Tに対してパッチPを適用します。Tのパッチされたコピーが返されます。</target>
        </trans-unit>
        <trans-unit id="d843d41461d41ce71296d2cc16a75e0d0ddb050b" translate="yes" xml:space="preserve">
          <source>The json_quote(X) function converts the SQL value X (a number or a string) into its corresponding JSON representation.</source>
          <target state="translated">json_quote(X)関数は、SQL 値 X (数値または文字列)を対応する JSON 表現に変換します。</target>
        </trans-unit>
        <trans-unit id="076810db69b99bc12f8c66592e6373c496370f8e" translate="yes" xml:space="preserve">
          <source>The json_remove() function throws an error if the first argument is not well-formed JSON or if any later argument is not a well-formed path, or if any argument is a BLOB.</source>
          <target state="translated">json_remove()関数は、最初の引数が整形JSONではない場合、または後の引数が整形パスではない場合、または引数のいずれかがBLOBである場合にエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="07c228732927cc33b2fd2172e7d852ff75280285" translate="yes" xml:space="preserve">
          <source>The json_remove(X,P,...) function takes a single JSON value as its first argument followed by zero or more path arguments. The json_remove(X,P,...) function returns a new JSON value that is the X with all the elements identified by path arguments removed. Paths that select elements not found in X are silently ignored.</source>
          <target state="translated">json_remove(X,P,...)関数は、最初の引数として単一の JSON 値を受け取り、その後に 0 個以上のパス引数が続きます。json_remove(X,P,...)関数は、パス引数によって識別されるすべての要素が削除された X である新しい JSON 値を返します。X で見つからない要素を選択するパスは静かに無視されます。</target>
        </trans-unit>
        <trans-unit id="dc2a43381f4cc4dcc4e70977bde02a9d9d1a46e8" translate="yes" xml:space="preserve">
          <source>The json_type() function throws an error if any of its arguments are not well-formed or is a BLOB.</source>
          <target state="translated">json_type()関数は、引数のいずれかが整形されていないか、または BLOB である場合にエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="4607298214330613e115639247f1a2af460f4cfe" translate="yes" xml:space="preserve">
          <source>The json_type(X) function returns the &quot;type&quot; of the outermost element of X. The json_type(X,P) function returns the &quot;type&quot; of the element in X that is selected by path P. The &quot;type&quot; returned by json_type() is on of the following an SQL text values: 'null', 'true', 'false', 'integer', 'real', 'text', 'array', or 'object'. If the path P in json_type(X,P) selects an element that does not exist in X, then this function returns NULL.</source>
          <target state="translated">json_type(X)関数はXの一番外側の要素の &quot;型 &quot;を返し、json_type(X,P)関数はパスPで選択されたXの要素の &quot;型 &quot;を返します。null'、'true'、'false'、'integer'、'real'、'text'、'array'、または'object'。json_type(X,P)のパス P が X に存在しない要素を選択した場合、この関数は NULL を返します。</target>
        </trans-unit>
        <trans-unit id="719a758ba2801754e03a7b8fe39124f85c9b0d1b" translate="yes" xml:space="preserve">
          <source>The json_type(X) function returns the &quot;type&quot; of the outermost element of X. The json_type(X,P) function returns the &quot;type&quot; of the element in X that is selected by path P. The &quot;type&quot; returned by json_type() is one of the following an SQL text values: 'null', 'true', 'false', 'integer', 'real', 'text', 'array', or 'object'. If the path P in json_type(X,P) selects an element that does not exist in X, then this function returns NULL.</source>
          <target state="translated">json_type(X)関数は、Xの一番外側の要素の &quot;型 &quot;を返し、json_type(X,P)関数は、パスPで選択されたXの中の要素の &quot;型 &quot;を返します。null'、'true'、'false'、'integer'、'real'、'text'、'array'、または'object'のいずれかです。json_type(X,P)のパス P が X に存在しない要素を選択した場合、この関数は NULL を返します。</target>
        </trans-unit>
        <trans-unit id="98bb00412965806c0f2fa0e24dcf65a44105fd64" translate="yes" xml:space="preserve">
          <source>The json_valid(X) function return 1 if the argument X is well-formed JSON and return 0 if the argument X is not well-formed JSON.</source>
          <target state="translated">json_valid(X)関数は、引数Xが整形JSONであれば1を返し、引数Xが整形JSONでなければ0を返します。</target>
        </trans-unit>
        <trans-unit id="b554cbe69a3700d4f56fb5609be0488decea2e7b" translate="yes" xml:space="preserve">
          <source>The key element of a</source>
          <target state="translated">の重要な要素である</target>
        </trans-unit>
        <trans-unit id="1f79347fd256f18500712ca620e7ffb89d509d9e" translate="yes" xml:space="preserve">
          <source>The key point is that SQLite is very forgiving of the type of data that you put into the database. For example, if a column has a datatype of &quot;INTEGER&quot; and the application inserts a text string into that column, SQLite will first try to convert the text string into an integer, just like every other SQL database engine. Thus, if one inserts &lt;b&gt;'1234'&lt;/b&gt; into an INTEGER column, that value is converted into an integer 1234 and stored. But, if you insert a non-numeric string like &lt;b&gt;'wxyz'&lt;/b&gt; into an INTEGER column, unlike other SQL databases, SQLite does not throw an error. Instead, SQLite stores the actual string value in the column.</source>
          <target state="translated">重要な点は、SQLiteはデータベースに入力するデータのタイプを非常に許容できるということです。たとえば、列のデータ型が「INTEGER」であり、アプリケーションがその列にテキスト文字列を挿入した場合、SQLiteは、他のすべてのSQLデータベースエンジンと同様に、最初にテキスト文字列を整数に変換しようとします。したがって、&lt;b&gt;「1234」&lt;/b&gt;をINTEGER列に挿入すると、その値は整数1234に変換されて格納されます。ただし、他のSQLデータベースとは異なり、&lt;b&gt;'wxyz'&lt;/b&gt;など&lt;b&gt;の&lt;/b&gt;非数値文字列をINTEGER列に挿入しても、SQLiteはエラーをスローしません。代わりに、SQLiteは実際の文字列値を列に格納します。</target>
        </trans-unit>
        <trans-unit id="3e290f56c0ef256cb5bbb18b2ba0fb09ea68db61" translate="yes" xml:space="preserve">
          <source>The key point is this: Building the CLI consists of compiling together two C-language files. The &lt;b&gt;shell.c&lt;/b&gt; file contains the definition of the entry point and the user input loop and the SQLite amalgamation &lt;b&gt;sqlite3.c&lt;/b&gt; contains the complete implementation of the SQLite library.</source>
          <target state="translated">重要なポイントは次のとおりです。CLIの構築は、2つのC言語ファイルを一緒にコンパイルすることで構成されます。&lt;b&gt;shell.cの&lt;/b&gt;ファイルには、エントリポイントの定義が含まれており、ユーザの入力ループとSQLiteの合併&lt;b&gt;sqlite3.cは、&lt;/b&gt; SQLiteのライブラリの完全な実装が含まれています。</target>
        </trans-unit>
        <trans-unit id="bb2fbeab5253f75ff8183f69852d5cbb7ab2bba6" translate="yes" xml:space="preserve">
          <source>The key points of the previous example were the use of the Callback instruction to invoke the callback function, and the use of the Next instruction to implement a loop over all records of the database file. This example attempts to drive home those ideas by demonstrating a slightly more complex query that involves more columns of output, some of which are computed values, and a WHERE clause that limits which records actually make it to the callback function. Consider this query:</source>
          <target state="translated">前の例では、Callback 命令を使用してコールバック関数を呼び出し、Next 命令を使用してデータベース・ファイルのすべてのレコードをループさせることがポイントでした。この例では、出力のカラム数が増え、その中には計算値も含まれ、WHERE句によって実際にコールバック関数に到達するレコードが制限されている、少し複雑なクエリを使用して、これらのアイデアを実証します。このクエリを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="986f899677204f1290b417dd64fe3fcaa05f7c30" translate="yes" xml:space="preserve">
          <source>The keys used by each segment b-tree are terms (words). As well as the key, each segment b-tree entry has an associated &quot;doclist&quot; (document list). A doclist consists of zero or more entries, where each entry consists of:</source>
          <target state="translated">各セグメント b-tree で使用されるキーは、用語 (単語)です。キーと同様に、各セグメント b-tree エントリには、関連する &quot;doclist&quot; (ドキュメントリスト)があります。doclist は 0 個以上のエントリで構成され、各エントリは次のように構成されます。</target>
        </trans-unit>
        <trans-unit id="a93934848f28a5d1e280c92cac942b828e6dc7e9" translate="yes" xml:space="preserve">
          <source>The keyword &quot;INSERT&quot;, &quot;UPDATE&quot;, or &quot;DELETE&quot;, as appropriate</source>
          <target state="translated">キーワード「INSERT」「UPDATE」「DELETE」のいずれかを適宜指定してください。</target>
        </trans-unit>
        <trans-unit id="799f75f9fa5e2cb1d9335f9637de442233918b1a" translate="yes" xml:space="preserve">
          <source>The kvtest program is compiled and run on Android as follows. First install the Android SDK and NDK. Then prepare a script named &quot;android-gcc&quot; that looks approximately like this:</source>
          <target state="translated">kvtestプログラムをコンパイルし、以下のようにAndroid上で実行します。まず、Android SDKとNDKをインストールします。そして、大体こんな感じの「android-gcc」というスクリプトを用意します。</target>
        </trans-unit>
        <trans-unit id="a518e69633f247201841ea47eb51e547b9e7d52f" translate="yes" xml:space="preserve">
          <source>The label to the right of an AS in the column list of a SELECT can now be used as part of an expression in the WHERE, ORDER BY, GROUP BY, and/or HAVING clauses.</source>
          <target state="translated">SELECTの列リストのASの右側にあるラベルは、WHERE句、ORDER BY句、GROUP BY句、HAVING句の式の一部として使用できるようになりました。</target>
        </trans-unit>
        <trans-unit id="5d78c31e6fd49e38e9a6929f67e573c2fcc27d5f" translate="yes" xml:space="preserve">
          <source>The language id for this entry.</source>
          <target state="translated">このエントリの言語ID。</target>
        </trans-unit>
        <trans-unit id="e80fa2a23c99c4e0919bc332ef910ec1f3215c2c" translate="yes" xml:space="preserve">
          <source>The languageid option causes the FTS4 table to have an additional hidden integer column that identifies the language of the text contained in each row. The use of the languageid option allows the same FTS4 table to hold text in multiple languages or scripts, each with different tokenizer rules, and to query each language independently of the others.</source>
          <target state="translated">languageid オプシ ョ ンは、FTS4 テーブルに、各行に含まれるテキス ト の言語を識別するための隠された整数列を追加させます。languageidオプションを使用すると、同じFTS4テーブルで複数の言語やスクリプトのテキストを保持することができ、それぞれが異なるトークン化ルールを持ち、それぞれの言語を他の言語から独立して問い合わせることができます。</target>
        </trans-unit>
        <trans-unit id="333c7dbdc428cf52a63d6a76d33660a2004630b2" translate="yes" xml:space="preserve">
          <source>The largest payload found anywhere in the current page or btree.</source>
          <target state="translated">現在のページやbtreeのどこにでもある最大のペイロード。</target>
        </trans-unit>
        <trans-unit id="3a93c8c9ebe55117d8275a20a3a64f1279cc0414" translate="yes" xml:space="preserve">
          <source>The largest possible setting for SQLITE_MAX_PAGE_COUNT is 2147483646. When used with the maximum page size of 65536, this gives a maximum SQLite database size of about 140 terabytes.</source>
          <target state="translated">SQLITE_MAX_PAGE_COUNT の最大設定は 2147483646 です。これを最大ページサイズ 65536 で使用すると、SQLite データベースの最大サイズは約 140 テラバイトになります。</target>
        </trans-unit>
        <trans-unit id="4e80216c90c51ba3170a6cfbdb6ff5453a279861" translate="yes" xml:space="preserve">
          <source>The largest possible setting for SQLITE_MAX_PAGE_COUNT is 4294967294. When used with the maximum page size of 65536, this gives a maximum SQLite database size of about 281 terabytes.</source>
          <target state="translated">SQLITE_MAX_PAGE_COUNT の最大設定は 4294967294 です。最大ページサイズ65536と一緒に使用すると、これは最大で約281テラバイトのSQLiteデータベースのサイズになります。</target>
        </trans-unit>
        <trans-unit id="d0fabb1072d1e3ea604e33e251741f22426c0f61" translate="yes" xml:space="preserve">
          <source>The last (fourth) bullet above merits additional comment. When SQLite creates a journal file on Unix, it opens the directory that contains that file and calls fsync() on the directory, in an effort to push the directory information to disk. But suppose some other process is adding or removing unrelated files to the directory that contains the database and journal at the moment of a power failure. The supposedly unrelated actions of this other process might result in the journal file being dropped from the directory and moved into &quot;lost+found&quot;. This is an unlikely scenario, but it could happen. The best defenses are to use a journaling filesystem or to keep the database and journal in a directory by themselves.</source>
          <target state="translated">上の最後の(4番目の)箇条書きは追加のコメントに値するものです。SQLite が Unix 上でジャーナルファイルを作成するとき、SQLite はそのファイルを含むディレクトリを開き、ディレクトリの情報をディスクにプッシュするためにディレクトリ上で fsync()を呼び出します。しかし、停電の瞬間に他のプロセスがデータベースとジャーナルを含むディレクトリに無関係なファイルを追加したり削除したりしていたとします。この他のプロセスの無関係と思われる動作により、ジャーナルファイルがディレクトリから削除され、&quot;lost+found &quot;に移動してしまうかもしれません。これはありそうもないシナリオですが、起こりうることです。最良の防御策は、ジャーナリングファイルシステムを使用するか、データベースとジャーナルを単独でディレクトリに保存することです。</target>
        </trans-unit>
        <trans-unit id="0d792644cd574497ddbf62ba435f6dbc99253564" translate="yes" xml:space="preserve">
          <source>The last bullet above is illustrated by the following:</source>
          <target state="translated">上の最後の箇条書きで説明すると、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="6fcee6d642fa1ca93fa14337ac4410163d2a9df9" translate="yes" xml:space="preserve">
          <source>The last output mode is &quot;html&quot;. In this mode, sqlite3 writes the results of the query as an XHTML table. The beginning &amp;lt;TABLE&amp;gt; and the ending &amp;lt;/TABLE&amp;gt; are not written, but all of the intervening &amp;lt;TR&amp;gt;s, &amp;lt;TH&amp;gt;s, and &amp;lt;TD&amp;gt;s are. The html output mode is envisioned as being useful for CGI.</source>
          <target state="translated">最後の出力モードは「html」です。このモードでは、sqlite3はクエリの結果をXHTMLテーブルとして書き込みます。最初の&amp;lt;TABLE&amp;gt;と最後の&amp;lt;/ TABLE&amp;gt;は書き込まれませんが、間にあるすべての&amp;lt;TR&amp;gt;、&amp;lt;TH&amp;gt;、および&amp;lt;TD&amp;gt;は書き込まれます。html出力モードは、CGIに役立つものとして想定されています。</target>
        </trans-unit>
        <trans-unit id="a123c1f8dadbf6bb9cc227ef0871a1fb2cbe0f9d" translate="yes" xml:space="preserve">
          <source>The last parameter to the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; routines is a pointer to a procedure used to dispose of the P pointer once SQLite has finished with it. This pointer can be NULL, in which case no destructor is called.</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;および&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;ルーチンへの最後のパラメーターは、SQLiteがPポインターを使い終わったら、Pポインターを破棄するために使用されるプロシージャへのポインターです。このポインタはNULLにすることができます。その場合、デストラクタは呼び出されません。</target>
        </trans-unit>
        <trans-unit id="d52a179000f827088051359c744fec0210401d8f" translate="yes" xml:space="preserve">
          <source>The last step in the commit process is to release the exclusive lock so that other processes can once again start accessing the database file.</source>
          <target state="translated">コミットプロセスの最後のステップは、排他的なロックを解除して、他のプロセスが再びデータベースファイルへのアクセスを開始できるようにすることです。</target>
        </trans-unit>
        <trans-unit id="56b9bbac0263da28aef9dee3010ecc1e8725f669" translate="yes" xml:space="preserve">
          <source>The last transaction started will be the first transaction committed or rolled back.</source>
          <target state="translated">最後に開始されたトランザクションは、最初にコミットされたトランザクションまたはロールバックされたトランザクションになります。</target>
        </trans-unit>
        <trans-unit id="c2015d5e4ba733546bdea54c6daefbab27ed0b3f" translate="yes" xml:space="preserve">
          <source>The last two allocations can be controlled and/or eliminated by configuring the &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt;, and &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; appropriately, as described above. The storage space required for &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; objects depends to some extent on the length of the filename of the database file, but rarely exceeds 2KB on 32-bit systems. (More space is required on 64-bit systems due to the increased size of pointers.) Each parser object uses about 1.6KB of memory. Thus, elements 3 through 7 above can easily be controlled to keep the maximum memory allocation size below 2KB.</source>
          <target state="translated">最後の2つの割り当ては、&lt;a href=&quot;malloc#pagecache&quot;&gt;上記の&lt;/a&gt;ように、ページキャッシュメモリアロケータと&lt;a href=&quot;malloc#lookaside&quot;&gt;メモリアロケータを&lt;/a&gt;適切に構成することで、制御または削除できます。&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;オブジェクトに必要なストレージ領域は、データベースファイルのファイル名の長さにある程度依存しますが、32ビットシステムでは2KBを超えることはめったにありません。 （ポインターのサイズが大きくなるため、64ビットシステムではより多くのスペースが必要になります。）各パーサーオブジェクトは、約1.6KBのメモリを使用します。したがって、上記の要素3〜7は、最大メモリ割り当てサイズを2KB未満に保つように簡単に制御できます。</target>
        </trans-unit>
        <trans-unit id="dd770eea393f2ccabe1cb964e8f446d8577e90ba" translate="yes" xml:space="preserve">
          <source>The last two queries take the same amount of time, in our example. So which index, Idx1 or Idx2, will SQLite choose? If the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command has been run on the database, so that SQLite has had an opportunity to gather statistics about the available indices, then SQLite will know that the Idx1 index usually narrows the search down to a single item (our example of fruit='Orange' is the exception to this rule) whereas the Idx2 index will normally only narrow the search down to two rows. So, if all else is equal, SQLite will choose Idx1 with the hope of narrowing the search to as small a number of rows as possible. This choice is only possible because of the statistics provided by &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;. If &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; has not been run then the choice of which index to use is arbitrary.</source>
          <target state="translated">この例では、最後の2つのクエリにかかる時間は同じです。それで、SQLiteはIdx1またはIdx2のどちらのインデックスを選択しますか？場合&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;コマンドは、データベース上で実行されているので、SQLiteのは、利用できるインデックスに関する統計を収集する機会があったことが、その後、SQLiteのはIDX1インデックスは通常、単一の項目（果実の我々の例にダウン検索狭まることを知っているだろう=」 Orange 'はこのルールの例外です）が、Idx2インデックスは通常、検索を2行に絞り込むだけです。そのため、他のすべてが等しい場合、SQLiteはIdx1を選択して、検索をできるだけ少ない行数に絞り込みます。この選択は、&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;によって提供される統計のためにのみ可能です。&lt;a href=&quot;lang_analyze&quot;&gt;分析する&lt;/a&gt;場合 実行されていない場合、使用するインデックスの選択は任意です。</target>
        </trans-unit>
        <trans-unit id="0271db818028a9ffb097a09e837d0647ab050705" translate="yes" xml:space="preserve">
          <source>The last_insert_rowid() function returns the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; of the last row insert from the database connection which invoked the function. The last_insert_rowid() SQL function is a wrapper around the &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; C/C++ interface function.</source>
          <target state="translated">last_insert_rowid（）関数は、関数を呼び出したデータベース接続からの最後の行挿入の&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;を返します。last_insert_rowid（）SQL関数は、&lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）&lt;/a&gt; C / C ++インターフェース関数のラッパーです。</target>
        </trans-unit>
        <trans-unit id="dc54cc3b765595ad1e2bcb9ada53a0d0dfaa1af8" translate="yes" xml:space="preserve">
          <source>The latest checklists contain approximately 200 items that are individually verified for each release. Some checklist items only take a few seconds to verify and mark off. Others involve test suites that run for many hours.</source>
          <target state="translated">最新のチェックリストには、リリースごとに個別に検証した約200項目が収録されています。チェックリストの項目の中には、検証とマークオフに数秒しかかからないものもあります。また、何時間もかけて実行されるテストスイートもあります。</target>
        </trans-unit>
        <trans-unit id="972ae3a81fba75ac7b1cb927798468eb94557f5e" translate="yes" xml:space="preserve">
          <source>The latter query can not use the partial index because there might be rows in the table with b=456 and where c is NULL. But those rows would not be in the partial index.</source>
          <target state="translated">後者のクエリでは部分インデックスを使用することはできません。 なぜなら、テーブル内にb=456でcがNULLの行があるかもしれないからです。しかし、それらの行は部分インデックスには含まれません。</target>
        </trans-unit>
        <trans-unit id="5d0da56ef4fd6dfbe12fe3015e9d0a6d277654f6" translate="yes" xml:space="preserve">
          <source>The leftmost column of the &quot;%_content&quot; table is an INTEGER PRIMARY KEY field named &quot;docid&quot;. Following this is one column for each column of the FTS virtual table as declared by the user, named by prepending the column name supplied by the user with &quot;c</source>
          <target state="translated">テーブル &quot;%_content&quot; の左端の列は、&quot;docid&quot; という名前の INTEGER PRIMARY KEY フィールドです。これに続くのは、ユーザによって宣言された FTS 仮想テーブルの各列に 1 つの列で、ユーザによって提供された列名の前に &quot;c</target>
        </trans-unit>
        <trans-unit id="3fe10f10852f3ac1156d75127fc7c938a298af76" translate="yes" xml:space="preserve">
          <source>The legacy &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; compile-time option is now a no-op.</source>
          <target state="translated">従来の&lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt;コンパイル時オプションは何もしなくなりました。</target>
        </trans-unit>
        <trans-unit id="19d5e9050bddb7e40ed3e17c750502a0acf23cf7" translate="yes" xml:space="preserve">
          <source>The legacy alter table behavior can also be toggled on and off using the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglegacyaltertable&quot;&gt;SQLITE_DBCONFIG_LEGACY_ALTER_TABLE&lt;/a&gt; option to the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface.</source>
          <target state="translated">レガシー変更テーブルの動作は、&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;インターフェースに&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglegacyaltertable&quot;&gt;SQLITE_DBCONFIG_LEGACY_ALTER_TABLE&lt;/a&gt;オプションを使用してオンとオフを切り替えることもできます。</target>
        </trans-unit>
        <trans-unit id="41fd664aa5a45cba5ac773955a3426725e8decb9" translate="yes" xml:space="preserve">
          <source>The legacy alter table behavior is a per-connection setting. Turning this features on or off affects all attached database files within the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. The setting does not persist. Changing this setting in one connection does not affect any other connections.</source>
          <target state="translated">従来のALTERTABLEの動作は、接続ごとの設定です。この機能をオンまたはオフにすると、&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;内の接続されているすべてのデータベースファイルに影響します。設定は保持されません。1つの接続でこの設定を変更しても、他の接続には影響しません。</target>
        </trans-unit>
        <trans-unit id="e0281c5597d6458d92c064f8c4ce4817fe25c10e" translate="yes" xml:space="preserve">
          <source>The legacy xGeom callback is invoked with four arguments. The first argument is a pointer to an sqlite3_rtree_geometry structure which provides information about how the SQL function was invoked. The second argument is the number of coordinates in each r-tree entry, and is always the same for any given R*Tree. The number of coordinates is 2 for a 1-dimensional R*Tree, 4 for a 2-dimensional R*Tree, 6 for a 3-dimensional R*Tree, and so forth. The third argument, aCoord[], is an array of nCoord coordinates that defines a bounding box to be tested. The last argument is a pointer into which the callback result should be written. The result is zero if the bounding-box defined by aCoord[] is completely outside the region defined by the xGeom callback and the result is non-zero if the bounding-box is inside or overlaps with the xGeom region. The xGeom callback should normally return SQLITE_OK. If xGeom returns anything other than SQLITE_OK, then the r-tree query will abort with an error.</source>
          <target state="translated">レガシーのxGeomコールバックは4つの引数で呼び出されます。最初の引数はsqlite3_rtree_geometry構造体へのポインタで、SQL関数がどのように呼び出されたかの情報を提供します。2番目の引数は各r-treeエントリの座標数で、与えられたR*Treeに対して常に同じです。座標数は、1次元のR*Treeの場合は2、2次元のR*Treeの場合は4、3次元のR*Treeの場合は6などです。第3引数のaCoord[]は、テスト対象のバウンディングボックスを定義するnCoord座標の配列です。最後の引数は、コールバックの結果を書き込むためのポインタです。aCoord[]によって定義された外接箱がxGeomコールバックによって定義された領域の外側にある場合、結果は0となり、外接箱がxGeom領域の内側にあるか重なっている場合は0ではありません。xGeom コールバックは通常 SQLITE_OK を返すはずです。xGeomがSQLITE_OK以外の値を返した場合、r-treeクエリはエラーで終了します。</target>
        </trans-unit>
        <trans-unit id="c26ac59b1bddfababdeff98e88ee3a4d181edb8a" translate="yes" xml:space="preserve">
          <source>The legacy_file_format pragma is initialized to OFF when an existing database in the newer file format is first opened.</source>
          <target state="translated">legacy_file_format pragmaは、新しいファイル形式の既存のデータベースを最初に開くときにOFFに初期化されます。</target>
        </trans-unit>
        <trans-unit id="5c416af28ee6cf9f448dc251869a118022ef5870" translate="yes" xml:space="preserve">
          <source>The length of a function name may not exceed 255 characters. Any attempt to create a function whose name exceeds 255 characters in length will result in an error.</source>
          <target state="translated">関数名の長さは255文字を超えてはいけません。名前の長さが 255 文字を超える関数を作成しようとすると、エラーになります。</target>
        </trans-unit>
        <trans-unit id="64a58fb27f585f3af736420c55a5c7aba354a480" translate="yes" xml:space="preserve">
          <source>The length of the argument value can be specified by one or more letters that occur just prior to the substitution type letter. In SQLite, the length only matter for integer types. The length is ignored for the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt; which always uses 64-bit values. The following table shows the length specifiers allowed by SQLite:</source>
          <target state="translated">引数値の長さは、置換タイプ文字の直前にある1つ以上の文字で指定できます。 SQLiteでは、長さは整数型に対してのみ重要です。常に64ビット値を使用する&lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf（）SQL関数&lt;/a&gt;では、長さは無視されます。次の表は、SQLiteで許可されている長さ指定子を示しています。</target>
        </trans-unit>
        <trans-unit id="835ff0a5a3c1f19c6461eba222151b4907f96047" translate="yes" xml:space="preserve">
          <source>The letter &quot;j&quot; pronounced like &quot;h&quot; in Spanish: LaJolla</source>
          <target state="translated">j」はスペイン語で「h」と発音します。ラジョラ</target>
        </trans-unit>
        <trans-unit id="ee9eb5ebb3823c5e0db14477052af2948a8b37ee" translate="yes" xml:space="preserve">
          <source>The library now assumes data is stored as UTF-8 if the --enable-utf8 option is given to configure. The default behavior is to assume iso8859-x, as it has always done. This only makes a difference for LIKE and GLOB operators and the LENGTH and SUBSTR functions.</source>
          <target state="translated">configure に --enable-utf8 オプションが与えられた場合、ライブラリはデータが UTF-8 で保存されると仮定するようになりました。デフォルトの動作は、これまでと同様に iso8859-x を想定しています。これは、LIKEとGLOB演算子とLENGTHとSUBSTR関数の違いだけを意味します。</target>
        </trans-unit>
        <trans-unit id="2b11a2ab2af2c4ff66c5a4f077ed6909c7421f85" translate="yes" xml:space="preserve">
          <source>The life-cycle of a prepared statement object usually goes like this:</source>
          <target state="translated">準備されたステートメントオブジェクトのライフサイクルは通常次のようになります。</target>
        </trans-unit>
        <trans-unit id="610e163977a4d438d498cc7745085654d18422e2" translate="yes" xml:space="preserve">
          <source>The lifecycle of an sqlite3_str object is as follows:</source>
          <target state="translated">sqlite3_strオブジェクトのライフサイクルは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="e1c985dd036afafc48409f9dec76735bbf115b4e" translate="yes" xml:space="preserve">
          <source>The like() function is used to implement the &quot;&lt;b&gt;Y LIKE X [ESCAPE Z]&lt;/b&gt;&quot; expression. If the optional ESCAPE clause is present, then the like() function is invoked with three arguments. Otherwise, it is invoked with two arguments only. Note that the X and Y parameters are reversed in the like() function relative to the infix &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator. X is the pattern and Y is the string to match against that pattern. Hence, the following expressions are equivalent:</source>
          <target state="translated">like（）関数は、「&lt;b&gt;Y LIKE X [ESCAPE Z]&lt;/b&gt;」式を実装するために使用されます。オプションのESCAPE句が存在する場合、like（）関数は3つの引数で呼び出されます。それ以外の場合は、2つの引数のみで呼び出されます。 XおよびYパラメータは、infix &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;演算子に関連するlike（）関数では逆になっていることに注意してください。 Xはパターン、Yはそのパターンと照合する文字列です。したがって、次の式は同等です。</target>
        </trans-unit>
        <trans-unit id="1725d5bdba0b7e8833554a2371c0c343ab2395e2" translate="yes" xml:space="preserve">
          <source>The likelihood(X,Y) function returns argument X unchanged. The value Y in likelihood(X,Y) must be a floating point constant between 0.0 and 1.0, inclusive. The likelihood(X) function is a no-op that the code generator optimizes away so that it consumes no CPU cycles during run-time (that is, during calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;). The purpose of the likelihood(X,Y) function is to provide a hint to the query planner that the argument X is a boolean that is true with a probability of approximately Y. The &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely(X)&lt;/a&gt; function is short-hand for likelihood(X,0.0625). The &lt;a href=&quot;lang_corefunc#likely&quot;&gt;likely(X)&lt;/a&gt; function is short-hand for likelihood(X,0.9375).</source>
          <target state="translated">尤度（X、Y）関数は、引数Xを変更せずに返します。尤度（X、Y）の値Yは、0.0以上1.0以下の浮動小数点定数でなければなりません。尤度（X）関数は、コードジェネレーターが実行時に（つまり、&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）の&lt;/a&gt;呼び出し中に） CPUサイクルを消費しないように最適化する何もしません。尤度（X、Y）関数の目的は、引数Xがブール値であり、ほぼYの確率で真であるというヒントをクエリプランナーに提供することです&lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;。likelyly（X）&lt;/a&gt;関数は、尤度（ X、0.0625）。&lt;a href=&quot;lang_corefunc#likely&quot;&gt;可能性（X）&lt;/a&gt;関数は、尤度（X、0.9375）のための短い手です。</target>
        </trans-unit>
        <trans-unit id="047f4505a74dbe546931a88238b570dcea0e5906" translate="yes" xml:space="preserve">
          <source>The likely(X) function returns the argument X unchanged. The likely(X) function is a no-op that the code generator optimizes away so that it consumes no CPU cycles at run-time (that is, during calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;). The purpose of the likely(X) function is to provide a hint to the query planner that the argument X is a boolean value that is usually true. The likely(X) function is equivalent to &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood&lt;/a&gt;(X,0.9375). See also: &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely(X)&lt;/a&gt;.</source>
          <target state="translated">Like（X）関数は、引数Xを変更せずに返します。&lt;a href=&quot;c3ref/step&quot;&gt;Like&lt;/a&gt;（X）関数は、実行時に（つまり、sqlite3_step（）への呼び出し中に） CPUサイクルを消費しないようにコードジェネレーターが最適化しない操作です。 Like（X）関数の目的は、引数Xが通常は真であるブール値であるというヒントをクエリプランナーに提供することです。Like （X）関数は、&lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;尤度&lt;/a&gt;（X、0.9375）と同等です。次も参照してください：&lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;likelyly（X）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="604c341d9009d83169d386485e03d9e7bc04c662" translate="yes" xml:space="preserve">
          <source>The limit value is set to zero.</source>
          <target state="translated">限界値はゼロに設定されています。</target>
        </trans-unit>
        <trans-unit id="7008986405b40055720891f4830c40ce21496380" translate="yes" xml:space="preserve">
          <source>The line &quot;.once</source>
          <target state="translated">行「.once</target>
        </trans-unit>
        <trans-unit id="d0c3acc92dc701e819ac94a0c8098f2db90a205c" translate="yes" xml:space="preserve">
          <source>The list below is not exhaustive. Other virtual table implementation exist in the SQLite source tree and elsewhere. The list below tries to capture the more interesting virtual table implementations.</source>
          <target state="translated">以下のリストは網羅的ではありません。他の仮想テーブルの実装はSQLiteのソースツリーや他の場所にも存在します。以下のリストは、より興味深い仮想テーブルの実装を捕捉しようとしています。</target>
        </trans-unit>
        <trans-unit id="d3b78caa21f35e034eafcfa346ed07394d0ca6e0" translate="yes" xml:space="preserve">
          <source>The list below shows all possible keywords used by any build of SQLite regardless of &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt;. Most reasonable configurations use most or all of these keywords, but some keywords may be omitted when SQL language features are disabled. Applications can use the &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_count()&lt;/a&gt;, &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_name()&lt;/a&gt;, and &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_check()&lt;/a&gt; interfaces to determine the keywords recognized by SQLite at run-time. Regardless of the compile-time configuration, any identifier that is not on the following 143 element list is not a keyword to the SQL parser in SQLite:</source>
          <target state="translated">以下のリストは、&lt;a href=&quot;compile&quot;&gt;コンパイル時のオプションに&lt;/a&gt;関係なく、SQLiteのビルドで使用されるすべての可能なキーワードを示しています。最も合理的な構成では、これらのキーワードのほとんどまたはすべてを使用しますが、SQL言語機能が無効になっている場合、一部のキーワードは省略される場合があります。アプリケーションは&lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_count（）&lt;/a&gt;、&lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_name（）&lt;/a&gt;、および&lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_check（）&lt;/a&gt;インターフェースを使用して、実行時にSQLiteによって認識されるキーワードを決定できます。コンパイル時の構成に関係なく、次の143要素リストにない識別子は、SQLiteのSQLパーサーのキーワードではありません。</target>
        </trans-unit>
        <trans-unit id="0180a1bb67bb5f33291414ccd4cfdc93226599e9" translate="yes" xml:space="preserve">
          <source>The list below shows all possible keywords used by any build of SQLite regardless of &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt;. Most reasonable configurations use most or all of these keywords, but some keywords may be omitted when SQL language features are disabled. Applications can use the &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_count()&lt;/a&gt;, &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_name()&lt;/a&gt;, and &lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_check()&lt;/a&gt; interfaces to determine the keywords recognized by SQLite at run-time. Regardless of the compile-time configuration, any identifier that is not on the following 145 element list is not a keyword to the SQL parser in SQLite:</source>
          <target state="translated">以下のリストは、&lt;a href=&quot;compile&quot;&gt;コンパイル時のオプションに&lt;/a&gt;関係なく、SQLiteのビルドで使用される可能性のあるすべてのキーワードを示しています。最も妥当な構成では、これらのキーワードのほとんどまたはすべてを使用しますが、SQL言語機能が無効になっている場合、一部のキーワードが省略される場合があります。アプリケーションは、&lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_count（）&lt;/a&gt;、&lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_name（）&lt;/a&gt;、および&lt;a href=&quot;c3ref/keyword_check&quot;&gt;sqlite3_keyword_check（）&lt;/a&gt;インターフェースを使用して、実行時にSQLiteによって認識されるキーワードを判別できます。コンパイル時の構成に関係なく、次の145要素リストにない識別子はSQLiteのSQLパーサーのキーワードではありません。</target>
        </trans-unit>
        <trans-unit id="281c02e8bf5d35129f9e1be609bd2e9295d15355" translate="yes" xml:space="preserve">
          <source>The list of coordinates in the binary format contains no redundancy. The last coordinate is not a repeat of the first as it is with GeoJSON. Hence, there is always one fewer coordinate pair in the binary representation of a polygon compared to the GeoJSON representation.</source>
          <target state="translated">バイナリ形式の座標のリストには冗長性がありません。GeoJSONの場合のように、最後の座標は最初の座標の繰り返しではありません。したがって、多角形のバイナリ表現では、GeoJSON 表現と比較して、常に 1 つ少ない座標ペアが存在します。</target>
        </trans-unit>
        <trans-unit id="31509dccb06d1116de02483b9bec949662404996" translate="yes" xml:space="preserve">
          <source>The list of expressions between the SELECT and FROM keywords is known as the result expression list. If a result expression is the special expression &quot;*&quot; then all columns in the input data are substituted for that one expression. If the expression is the alias of a table or subquery in the FROM clause followed by &quot;.*&quot; then all columns from the named table or subquery are substituted for the single expression. It is an error to use a &quot;*&quot; or &quot;alias.*&quot; expression in any context other than a result expression list. It is also an error to use a &quot;*&quot; or &quot;alias.*&quot; expression in a simple SELECT query that does not have a FROM clause.</source>
          <target state="translated">SELECTキーワードとFROMキーワードの間にある式のリストは、結果式リストとして知られています。結果式が特殊な式 &quot;*&quot;である場合、入力データ内のすべての列がその式に置き換えられます。式がFROM句のテーブルまたは副問い合わせのエイリアスで、&quot;.*&quot;が続く場合、名前のついたテーブルまたは副問い合わせからのすべての列が単一の式に置き換えられます。結果式リスト以外のコンテキストで &quot;*&quot;または &quot;alias.*&quot;式を使用するのはエラーです。また、FROM句を持たない単純なSELECTクエリで &quot;*&quot;または &quot;alias.*&quot;式を使用することもエラーです。</target>
        </trans-unit>
        <trans-unit id="aff07670c95df2683c32cdb3b9c35bd30fecbe25" translate="yes" xml:space="preserve">
          <source>The list of integers in the stat column can optionally be followed by arguments, each of which is a sequence of non-space characters. All arguments are preceded by a single space. Unrecognized arguments are silently ignored.</source>
          <target state="translated">stat列の整数のリストの後には、オプションで引数を付けることができます。すべての引数の前にはスペースが1つ付きます。認識されない引数は静かに無視されます。</target>
        </trans-unit>
        <trans-unit id="5c584c3300424511e57cf7c45771316447fd9008" translate="yes" xml:space="preserve">
          <source>The load_extension() function will fail if the extension attempts to modify or delete an SQL function or collating sequence. The extension can add new functions or collating sequences, but cannot modify or delete existing functions or collating sequences because those functions and/or collating sequences might be used elsewhere in the currently running SQL statement. To load an extension that changes or deletes functions or collating sequences, use the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; C-language API.</source>
          <target state="translated">拡張機能がSQL関数または照合シーケンスを変更または削除しようとすると、load_extension（）関数は失敗します。拡張機能は、新しい関数または照合シーケンスを追加できますが、既存の関数または照合シーケンスは、現在実行中のSQLステートメントの他の場所で使用される可能性があるため、変更または削除できません。関数または照合シーケンスを変更または削除する拡張機能をロードするには、&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt; C言語APIを使用します。</target>
        </trans-unit>
        <trans-unit id="349abdc2376164ceeb049d0fdce3e4218d275600" translate="yes" xml:space="preserve">
          <source>The load_extension(X,Y) function loads &lt;a href=&quot;loadext&quot;&gt;SQLite extensions&lt;/a&gt; out of the shared library file named X using the entry point Y. The result of load_extension() is always a NULL. If Y is omitted then the default entry point name is used. The load_extension() function raises an exception if the extension fails to load or initialize correctly.</source>
          <target state="translated">load_extension（X、Y）関数は、エントリポイントYを使用して、Xという名前の共有ライブラリファイルから&lt;a href=&quot;loadext&quot;&gt;SQLite拡張&lt;/a&gt;機能をロードします。load_extension（）の結果は常にNULLです。 Yを省略すると、デフォルトのエントリポイント名が使用されます。 load_extension（）関数は、拡張機能が正しくロードまたは初期化できない場合に例外を発生させます。</target>
        </trans-unit>
        <trans-unit id="3c476d76e8d35e3c5addfedd0889c28cfa2868c0" translate="yes" xml:space="preserve">
          <source>The local copy of the remote head</source>
          <target state="translated">リモートヘッドのローカルコピー</target>
        </trans-unit>
        <trans-unit id="9c687c8acb9d37e788292221df58e5cc9d9b9e4e" translate="yes" xml:space="preserve">
          <source>The local head</source>
          <target state="translated">現地のトップ</target>
        </trans-unit>
        <trans-unit id="ef999d9e04e59df040c534586df9501decb45621" translate="yes" xml:space="preserve">
          <source>The lock-byte page</source>
          <target state="translated">ロックバイトページ</target>
        </trans-unit>
        <trans-unit id="5c06094b5494afcc6bc0546930a2d751ec1db7b7" translate="yes" xml:space="preserve">
          <source>The lock-byte page arose from the need to support Win95 which was the predominant operating system when this file format was designed and which only supported mandatory file locking. All modern operating systems that we know of support advisory file locking, and so the lock-byte page is not really needed any more, but is retained for backwards compatibility.</source>
          <target state="translated">ロックバイトページは、このファイルフォーマットが設計された当時の主流のオペレーティング・システムであり、必須のファイルロックしかサポートしていなかったWin95をサポートする必要性から生まれました。私たちが知っている最新のオペレーティングシステムはすべて勧告的なファイルロックをサポートしているので、ロックバイトページはもう本当に必要とされていませんが、下位互換性のために保持されています。</target>
        </trans-unit>
        <trans-unit id="4bd512e93ea74564dff8bf82d8627bae1ed3c48e" translate="yes" xml:space="preserve">
          <source>The lock-byte page is set aside for use by the operating-system specific &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementation in implementing the database file locking primitives. SQLite does not use the lock-byte page. The SQLite core will never read or write the lock-byte page, though operating-system specific &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations may choose to read or write bytes on the lock-byte page according to the needs and proclivities of the underlying system. The unix and win32 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations that come built into SQLite do not write to the lock-byte page, but third-party VFS implementations for other operating systems might.</source>
          <target state="translated">ロックバイトページは、データベースファイルロックプリミティブを実装する際に、オペレーティングシステム固有の&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;実装で使用するために確保されています。 SQLiteはロックバイトページを使用しません。 SQLiteコアはロックバイトページの読み取りまたは書き込みを行いませんが、オペレーティングシステム固有の&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;実装は、基盤となるシステムのニーズと傾向に応じて、ロックバイトページのバイトの読み取りまたは書き込みを選択できます。SQLiteに組み込まれているunixおよびwin32 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;実装はロックバイトページに書き込みませんが、他のオペレーティングシステム用のサードパーティVFS実装は書き込む可能性があります。</target>
        </trans-unit>
        <trans-unit id="df185932a5473981e68a610e19ea95a4f593a072" translate="yes" xml:space="preserve">
          <source>The lock-byte page is the single page of the database file that contains the bytes at offsets between 1073741824 and 1073742335, inclusive. A database file that is less than or equal to 1073741824 bytes in size contains no lock-byte page. A database file larger than 1073741824 contains exactly one lock-byte page.</source>
          <target state="translated">ロック・バイト・ページとは、1073741824 から 1073742335 までのオフセットにあるバイトを含むデータベース・ファイルの単一ページのことです。サイズが 1073741824 バイト以下のデータベース・ファイルには、ロック・バイト・ページは含まれません。1073741824 バイトより大きいデータベース・ファイルには、ロック・バイト・ページが正確に 1 つ含まれています。</target>
        </trans-unit>
        <trans-unit id="dda6a9ed2d568f9a7c6dc08407b442fb82119304" translate="yes" xml:space="preserve">
          <source>The logic is summarized like this:</source>
          <target state="translated">論理をまとめるとこんな感じです。</target>
        </trans-unit>
        <trans-unit id="355578bfd3a4498b2a633a6f3c4ff7c7b09de69f" translate="yes" xml:space="preserve">
          <source>The logical database size is now stored in the database header so that bytes can be appended to the end of the database file without corrupting it and so that SQLite will work correctly on systems that lack support for ftruncate().</source>
          <target state="translated">これにより、データベースファイルを破損させることなく、データベースファイルの最後にバイトを追加することができます。</target>
        </trans-unit>
        <trans-unit id="e93186cc2b2b96f693bcff5f9715523649b95afa" translate="yes" xml:space="preserve">
          <source>The lookaside configuration can only be changed while there are no outstanding lookaside allocations for the database connection. Hence, the configuration should be set immediately after creating the database connection using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; (or equivalent) and before evaluating any SQL statements on the connection.</source>
          <target state="translated">ルックアサイド構成は、データベース接続に未処理のルックアサイド割り当てがない場合にのみ変更できます。したがって、&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;（または同等のもの）を使用してデータベース接続を作成した直後で、接続のSQLステートメントを評価する前に、構成を設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="98de1d7e1c308aef9eeb240a9c0c48340d7aa4c3" translate="yes" xml:space="preserve">
          <source>The lookaside memory allocator is really intended as performance optimization, not as a method for assuring breakdown-free memory allocation, so it is not unreasonable to completely disable the lookaside memory allocator for safety-critical operations.</source>
          <target state="translated">ルックサイドメモリアロケータは性能の最適化を目的としたものであり、故障のないメモリ割り当てを保証するための方法ではないので、安全上重要な操作のためにルックサイドメモリアロケータを完全に無効にすることは不合理ではない。</target>
        </trans-unit>
        <trans-unit id="02f0ada4fc69e2b3f3d2c6c843b91333faf8b563" translate="yes" xml:space="preserve">
          <source>The lookaside pool can be changed for an individual &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; &quot;db&quot; using this call:</source>
          <target state="translated">ルックアサイドプールは、次の呼び出しを使用して、個々の&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;「db」に対して変更できます。</target>
        </trans-unit>
        <trans-unit id="31d19ac91c3d68e4ec2f5534877ee0ca68a0efec" translate="yes" xml:space="preserve">
          <source>The loop begins with the &lt;a href=&quot;opcode#MemLoad&quot;&gt;MemLoad&lt;/a&gt; instruction at 11 which pushes a copy of the index key back onto the stack. The instruction &lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt; at 12 compares the key to the key in the current index record pointed to by cursor P1. If the index key at the current cursor location is greater than the index we are looking for, then jump out of the loop.</source>
          <target state="translated">ループは、インデックスキーのコピーをスタックに戻す11 の&lt;a href=&quot;opcode#MemLoad&quot;&gt;MemLoad&lt;/a&gt;命令で始まります。12の&lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt;命令は、キーをカーソルP1が指す現在のインデックスレコード内のキーと比較します。現在のカーソル位置のインデックスキーが、探しているインデックスよりも大きい場合は、ループを抜けます。</target>
        </trans-unit>
        <trans-unit id="9b4e40524d32f647817434932fe77ea61e285d86" translate="yes" xml:space="preserve">
          <source>The lower(X) function returns a copy of string X with all ASCII characters converted to lower case. The default built-in lower() function works for ASCII characters only. To do case conversions on non-ASCII characters, load the ICU extension.</source>
          <target state="translated">lower(X)関数は、すべての ASCII 文字を小文字に変換した文字列 X のコピーを返します。デフォルトの組み込みの lower()関数は ASCII 文字に対してのみ動作します。非 ASCII 文字の大文字小文字変換を行うには、ICU 拡張モジュールをロードしてください。</target>
        </trans-unit>
        <trans-unit id="84e26bc0d335ef0f3f91dcbee9450cd939575e9d" translate="yes" xml:space="preserve">
          <source>The ltrim(X,Y) function returns a string formed by removing any and all characters that appear in Y from the left side of X. If the Y argument is omitted, ltrim(X) removes spaces from the left side of X.</source>
          <target state="translated">ltrim(X,Y)関数は、Xの左側からYに登場する文字をすべて削除した文字列を返します。</target>
        </trans-unit>
        <trans-unit id="fdcc55ab3a12db83d0fd351a3149fb5d3844b7fd" translate="yes" xml:space="preserve">
          <source>The macros in this section do not require values. The following compilation switches all have the same effect:</source>
          <target state="translated">このセクションのマクロは値を必要としません。以下のコンパイルスイッチはすべて同じ効果を持ちます。</target>
        </trans-unit>
        <trans-unit id="9225c9e6b4935393e2d3171b186997ddaa13f218" translate="yes" xml:space="preserve">
          <source>The main database file consists of one or more pages. The size of a page is a power of two between 512 and 65536 inclusive. All pages within the same database are the same size. The page size for a database file is determined by the 2-byte integer located at an offset of 16 bytes from the beginning of the database file.</source>
          <target state="translated">メインデータベースファイルは、1つ以上のページで構成されています。ページのサイズは 512 から 65536 までの 2 の累乗です。同じデータベース内のすべてのページは同じサイズです。データベースファイルのページサイズは、データベースファイルの先頭から16バイトのオフセットに位置する2バイトの整数によって決定されます。</target>
        </trans-unit>
        <trans-unit id="7d6f37716756d458f806be1f0cab62c9c7d22175" translate="yes" xml:space="preserve">
          <source>The main database file with an arbitrary name &quot;X&quot;.</source>
          <target state="translated">任意の名前「X」のメインデータベースファイル。</target>
        </trans-unit>
        <trans-unit id="f6b3e874976f8a865414a00bc3a0b52995dae0f9" translate="yes" xml:space="preserve">
          <source>The main expression bubble diagram above shows a single syntax for all function invocations. But this is merely to simplify the expression bubble diagram. In reality, each type of function has a slightly different syntax, shown below. The function invocation syntax shown in the main expression bubble diagram is the union of the three syntaxes shown here:</source>
          <target state="translated">上の主な式バブル図は、すべての関数呼び出しに対して単一の構文を示しています。しかし、これは単に式バブル図を単純化するためのものです。実際には、以下に示すように、各タイプの関数はわずかに異なる構文を持っています。メインの式バブル図に示されている関数呼び出し構文は、ここに示されている3つの構文の合体です。</target>
        </trans-unit>
        <trans-unit id="408e5f03d044dab233873eb64f906cb6ccb49b90" translate="yes" xml:space="preserve">
          <source>The main machine in Dallas &lt;a href=&quot;https://www.sqlite.org/&quot;&gt;https://www.sqlite.org/&lt;/a&gt; is the primary server and the one that most people use. The other two are considered backups.</source>
          <target state="translated">ダラスのメインマシン&lt;a href=&quot;https://www.sqlite.org/&quot;&gt;https://www.sqlite.org/&lt;/a&gt;はプライマリサーバーであり、ほとんどの人が使用します。他の2つはバックアップと見なされます。</target>
        </trans-unit>
        <trans-unit id="1d698f91852ce738e8b0efe94402ad56dc5b35ee" translate="yes" xml:space="preserve">
          <source>The main result from &lt;b&gt;sqlite_get_table&lt;/b&gt; is an array of pointers to strings. There is one element in this array for each column of each row in the result. NULL results are represented by a NULL pointer. In addition to the regular data, there is an added row at the beginning of the array that contains the name of each column of the result.</source>
          <target state="translated">&lt;b&gt;sqlite_get_table&lt;/b&gt;の主な結果は、文字列へのポインタの配列です。この配列には、結果の各行の各列に対して1つの要素があります。NULLの結果は、NULLポインターによって表されます。通常のデータに加えて、結果の各列の名前を含む追加の行が配列の先頭にあります。</target>
        </trans-unit>
        <trans-unit id="2fb1295c928ccfed10f4bea85ec6d057bdb858da" translate="yes" xml:space="preserve">
          <source>The main thing that the SQLite core is trying to communicate to the virtual table is the constraints that are available to limit the number of rows that need to be searched. The aConstraint[] array contains one entry for each constraint. There will be exactly nConstraint entries in that array.</source>
          <target state="translated">SQLite コアが仮想テーブルに伝えようとしている主なものは、検索する必要のある行の数を制限するために利用可能な制約です。aConstraint[]配列には、各制約に対して1つのエントリが含まれます。その配列には、正確には nConstraint エントリが存在します。</target>
        </trans-unit>
        <trans-unit id="c00fa1abbc4e41f8e98c7516bdb7add3970ff677" translate="yes" xml:space="preserve">
          <source>The makefiles and scripts used to generate the documentation gather text from baseline documents in the documentation source repository. Additional text is extracted from comments in the SQLite source code. Requirements coverage information is extract from special comments in the &lt;a href=&quot;testing#tcl&quot;&gt;TCL test suite&lt;/a&gt; which is part of the source repository, and from comments in the &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; test suite which is a separate private repository.</source>
          <target state="translated">ドキュメントの生成に使用されるメイクファイルとスクリプトは、ドキュメントソースリポジトリ内のベースラインドキュメントからテキストを収集します。追加のテキストは、SQLiteソースコードのコメントから抽出されます。要件カバレッジ情報は、ソースリポジトリの一部である&lt;a href=&quot;testing#tcl&quot;&gt;TCLテストスイートの&lt;/a&gt;特別なコメントと、個別のプライベートリポジトリである&lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt;テストスイートのコメントから抽出されます。</target>
        </trans-unit>
        <trans-unit id="42a78601e6da24d033fc5c1c1ee7512e6c89f88c" translate="yes" xml:space="preserve">
          <source>The makefiles for SQLite have an &quot;sqlite3.c&quot; target for building the file we call &quot;the amalgamation&quot;. The amalgamation is a single C code file, named &quot;sqlite3.c&quot;, that contains all C code for the core SQLite library and the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;, &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;, &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;, &lt;a href=&quot;dbstat&quot;&gt;DBSTAT&lt;/a&gt;, &lt;a href=&quot;json1&quot;&gt;JSON1&lt;/a&gt;, and &lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt; extensions. This file contains about 184K lines of code (113K if you omit blank lines and comments) and is over 6.4 megabytes in size. Though the various extensions are included in the &quot;sqlite3.c&quot; amalgamation file, they are disabled using #ifdef statements. Activate the extensions using &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; like:</source>
          <target state="translated">SQLiteのmakefileには、「アマルガム」と呼ばれるファイルを構築するための「sqlite3.c」ターゲットがあります。統合は、「sqlite3.c」という名前の単一のCコードファイルであり、コアSQLiteライブラリのすべてのCコードと、&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;、&lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;、&lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;、&lt;a href=&quot;dbstat&quot;&gt;DBSTAT&lt;/a&gt;、&lt;a href=&quot;json1&quot;&gt;JSON1&lt;/a&gt;、および&lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt;拡張機能が含まれています。このファイルには約184K行のコード（空白行とコメントを省略した場合は113K行）が含まれ、サイズは6.4Mバイトを超えます。さまざまな拡張機能が「sqlite3.c」統合ファイルに含まれていますが、＃ifdefステートメントを使用して無効になっています。次のような&lt;a href=&quot;compile&quot;&gt;コンパイル時オプション&lt;/a&gt;を使用して、拡張機能をアクティブにします。</target>
        </trans-unit>
        <trans-unit id="0980756624132b6830b479bc71ea60b90272891a" translate="yes" xml:space="preserve">
          <source>The manner in which SQLite uses temporary files is not considered part of the contract that SQLite makes with applications. The information in this document is a correct description of how SQLite operates at the time that this document was written or last updated. But there is no guarantee that future versions of SQLite will use temporary files in the same way. New kinds of temporary files might be employed and some of the current temporary file uses might be discontinued in future releases of SQLite.</source>
          <target state="translated">SQLite が一時ファイルを使用する方法は、SQLite がアプリケーションと交わす契約の一部とは考えられていません。このドキュメントに記載されている情報は、このドキュメントが作成された時点、または最終更新された時点でのSQLiteの動作についての正しい説明です。しかし、将来のバージョンのSQLiteが同じように一時ファイルを使用することを保証するものではありません。新しい種類のテンポラリファイルが採用されるかもしれませんし、現在のテンポラリファイルの使用方法の一部は将来のSQLiteのリリースで廃止されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="3c2b798d423398f0b8335bc4cb33aea4b3800944" translate="yes" xml:space="preserve">
          <source>The mapping from character to affinity is given by the SQLITE_AFF_ macros defined in sqliteInt.h.</source>
          <target state="translated">文字からアフィニティへのマッピングはsqliteInt.hで定義されているSQLITE_AFF_マクロによって与えられます。</target>
        </trans-unit>
        <trans-unit id="e5801820a892b25589a4f5acb0cdb08d7136d42b" translate="yes" xml:space="preserve">
          <source>The master journal file is only created for &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; operations that involve multiple database files where at least two of the databases meet all of the following requirements:</source>
          <target state="translated">マスタージャーナルファイルは、少なくとも2つのデータベースが次のすべての要件を満たしている複数のデータベースファイルが関係する&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;操作に対してのみ作成されます。</target>
        </trans-unit>
        <trans-unit id="31da1199925e2ef2121e09ef393e19f883001204" translate="yes" xml:space="preserve">
          <source>The master journal file is used as part of the atomic commit process when a single transaction makes changes to multiple databases that have been added to a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. The master journal file is always located in the same directory as the main database file (the main database file is the database that is identified in the original &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; call that created the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;) with a randomized suffix. The master journal file contains the names of all of the various attached auxiliary databases that were changed during the transaction. The multi-database transaction commits when the master journal file is deleted. See the documentation titled &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit In SQLite&lt;/a&gt; for additional detail.</source>
          <target state="translated">マスタージャーナルファイルは、単一のトランザクションが&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;ステートメント&lt;a href=&quot;c3ref/sqlite3&quot;&gt;を&lt;/a&gt;使用して単一のデータベース接続に追加された複数のデータベースに変更を加えるときに、アトミックコミットプロセスの一部として使用されます。マスタージャーナルファイルは常にメインデータベースファイルと同じディレクトリにあります（メインデータベースファイルは、&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;を作成した元の&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;、&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt;、または&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;呼び出しで識別されるデータベースです））ランダムなサフィックスを付けます。マスタージャーナルファイルには、トランザクション中に変更された、接続されているさまざまな補助データベースすべての名前が含まれています。マスタージャーナルファイルが削除されると、マルチデータベーストランザクションがコミットされます。詳細については、&lt;a href=&quot;atomiccommit&quot;&gt;SQLiteのAtomic Commit&lt;/a&gt;というタイトルのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="772c6b302e1774e25495c91e9341c8308af64569" translate="yes" xml:space="preserve">
          <source>The matchinfo 'b' flag provides similar information to the &lt;a href=&quot;fts3#matchinfo-y&quot; id=&quot;matchinfo-b&quot;&gt;matchinfo 'y' flag&lt;/a&gt;, but in a more compact form. Instead of the precise number of hits, 'b' provides a single boolean flag for each phrase/column combination. If the phrase is present in the column at least once (i.e. if the corresponding integer output of 'y' would be non-zero), the corresponding flag is set. Otherwise cleared.</source>
          <target state="translated">matchinfo 'b'フラグは、&lt;a href=&quot;fts3#matchinfo-y&quot; id=&quot;matchinfo-b&quot;&gt;matchinfo 'y'フラグ&lt;/a&gt;と同様の情報を提供しますが、よりコンパクトな形式です。正確なヒット数の代わりに、「b」は各フレーズ/列の組み合わせに対して単一のブールフラグを提供します。フレーズが列に少なくとも1回存在する場合（つまり、「y」の対応する整数出力がゼロ以外になる場合）、対応するフラグが設定されます。それ以外の場合はクリアされます。</target>
        </trans-unit>
        <trans-unit id="0e92769ac2bedb9028e89c1796d219b3c41ebfd0" translate="yes" xml:space="preserve">
          <source>The matchinfo function is called with either one or two arguments. As for all auxiliary functions, the first argument must be the special &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt;. The second argument, if it is specified, must be a text value comprised only of the characters 'p', 'c', 'n', 'a', 'l', 's', 'x', 'y' and 'b'. If no second argument is explicitly supplied, it defaults to &quot;pcx&quot;. The second argument is referred to as the &quot;format string&quot; below.</source>
          <target state="translated">matchinfo関数は、1つまたは2つの引数で呼び出されます。すべての補助関数と同様に、最初の引数は特別な&lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS非表示列である&lt;/a&gt;必要があります。 2番目の引数を指定する場合は、「p」、「c」、「n」、「a」、「l」、「s」、「x」、「y」の文字のみで構成されるテキスト値である必要がありますおよび「b」。 2番目の引数が明示的に指定されていない場合、デフォルトで「pcx」になります。 2番目の引数は、以下の「フォーマット文字列」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="d7687da8f246deec886a3154fb495c0792554c7d" translate="yes" xml:space="preserve">
          <source>The matchinfo function is much faster than either the snippet or offsets functions. This is because the implementation of both snippet and offsets is required to retrieve the documents being analyzed from disk, whereas all data required by matchinfo is available as part of the same portions of the full-text index that are required to implement the full-text query itself. This means that of the following two queries, the first may be an order of magnitude faster than the second:</source>
          <target state="translated">matchinfo 関数は、 snippet 関数や offsets 関数よりもはるかに高速です。これは、分析対象の文書をディスクから取得するためにスニペットとオフセットの両方の実装が必要なのに対し、matchinfoで必要なデータはすべて、フルテキストクエリ自体を実装するために必要なフルテキストインデックスの同じ部分の一部として利用可能だからです。つまり、以下の2つのクエリのうち、1つ目のクエリの方が2つ目のクエリよりも桁違いに高速である可能性があるということです。</target>
        </trans-unit>
        <trans-unit id="c65df31b33c2a6ca0926acfdea9fd52aa875638d" translate="yes" xml:space="preserve">
          <source>The matchinfo function provides all the information required to calculate probabilistic &quot;bag-of-words&quot; relevancy scores such as &lt;a href=&quot;http://en.wikipedia.org/wiki/Okapi_BM25&quot;&gt;Okapi BM25/BM25F&lt;/a&gt; that may be used to order results in a full-text search application. Appendix A of this document, &quot;&lt;a href=&quot;fts3#appendix_a&quot;&gt;search application tips&lt;/a&gt;&quot;, contains an example of using the matchinfo() function efficiently.</source>
          <target state="translated">matchinfo関数は、全文検索アプリケーションで結果を注文するために使用できる&lt;a href=&quot;http://en.wikipedia.org/wiki/Okapi_BM25&quot;&gt;Okapi BM25 / BM25F&lt;/a&gt;などの確率的「単語のバッグ」関連性スコアの計算に必要なすべての情報を提供します。このドキュメントの付録A「&lt;a href=&quot;fts3#appendix_a&quot;&gt;検索アプリケーションのヒント&lt;/a&gt;」には、matchinfo（）関数を効率的に使用する例が含まれています。</target>
        </trans-unit>
        <trans-unit id="e90549847387fb18f595713064d87ed6f095e05c" translate="yes" xml:space="preserve">
          <source>The matchinfo function returns a blob value. If it is used within a query that does not use the full-text index (a &quot;query by rowid&quot; or &quot;linear scan&quot;), then the blob is zero bytes in size. Otherwise, the blob consists of zero or more 32-bit unsigned integers in machine byte-order. The exact number of integers in the returned array depends on both the query and the value of the second argument (if any) passed to the matchinfo function.</source>
          <target state="translated">matchinfo 関数は、ブロブ値を返します。フルテキストインデックスを使用しないクエリ(「行番号によるクエリ」または「リニアスキャン」)の中で使用された場合、ブロブのサイズは0バイトです。そうでない場合、ブロブは、マシン・バイト順のゼロ以上の32ビット符号なし整数で構成されます。返される配列内の正確な整数数は、クエリと matchinfo 関数に渡された第 2 引数の値(もしあれば)の両方に依存します。</target>
        </trans-unit>
        <trans-unit id="5fd973e0c684054ad3dbbf4a32a2b97ce84282bb" translate="yes" xml:space="preserve">
          <source>The matchinfo option may only be set to the value &quot;fts3&quot;. Attempting to set matchinfo to anything other than &quot;fts3&quot; is an error. If this option is specified, then some of the extra information stored by FTS4 is omitted. This reduces the amount of disk space consumed by an FTS4 table until it is almost the same as the amount that would be used by the equivalent FTS3 table, but also means that the data accessed by passing the 'l' flag to the &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; function is not available.</source>
          <target state="translated">matchinfoオプションは、値「fts3」にのみ設定できます。 matchinfoを &quot;fts3&quot;以外に設定しようとするとエラーになります。このオプションが指定されている場合、FTS4によって格納される追加情報の一部が省略されます。これにより、同等のFTS3テーブルで使用される量とほぼ同じになるまで、FTS4テーブルで消費されるディスク領域の量が減少しますが、&lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo（）に&lt;/a&gt;「l」フラグを渡してデータにアクセスすることも意味します機能は利用できません。</target>
        </trans-unit>
        <trans-unit id="30566a971375718efb83d0535cdd7975a1033a22" translate="yes" xml:space="preserve">
          <source>The matrix below shows the time needed to read BLOBs stored in separate files divided by the time needed to read BLOBs stored entirely in the database. Hence, for numbers larger than 1.0, it is faster to store the BLOBs directly in the database. For numbers smaller than 1.0, it is faster to store the BLOBs in separate files.</source>
          <target state="translated">以下の行列は、別々のファイルに保存された BLOB を読み込むのに必要な時間を、データベース全体に保存された BLOB を読み込むのに必要な時間で割ったものです。したがって、1.0よりも大きい数値では、BLOBを直接データベースに格納した方が高速です。1.0よりも小さい数については、BLOBを別のファイルに保存した方が高速です。</target>
        </trans-unit>
        <trans-unit id="4c2fbc6111561deb5f89baa2a61ac965889a611a" translate="yes" xml:space="preserve">
          <source>The max() aggregate function returns the maximum value of all values in the group. The maximum value is the value that would be returned last in an ORDER BY on the same column. Aggregate max() returns NULL if and only if there are no non-NULL values in the group.</source>
          <target state="translated">max()集約関数は、グループ内のすべての値の最大値を返します。最大値は、同じ列の ORDER BY で最後に返される値となります。集約関数 max()は、グループ内に NULL 以外の値が存在しない場合にのみ NULL を返します。</target>
        </trans-unit>
        <trans-unit id="259079b25b4ee53dd3af62dccf64b88cf7401fe7" translate="yes" xml:space="preserve">
          <source>The maximum allowed value for the 'automerge' parameter is 16. The default value is 4. Setting the 'automerge' parameter to 0 disables the automatic incremental merging of b-trees altogether.</source>
          <target state="translated">automerge' パラメータの最大値は 16 です。automerge' パラメータを 0 に設定すると、b-木の自動増分マージが完全に無効になります。</target>
        </trans-unit>
        <trans-unit id="99bed95a8c8918c9ad675486624a0ec50cca0b55" translate="yes" xml:space="preserve">
          <source>The maximum amount of general-purpose memory needed by the application is determined by such factors as how many simultaneous open &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; objects the application uses, and on the complexity of the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt;. For any given application, these factors are normally fixed and can be determined experimentally using &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;. A typical application might only use about 40KB of general-purpose memory. This gives a value of &lt;b&gt;N&lt;/b&gt; of around 100KB.</source>
          <target state="translated">アプリケーションが必要とする汎用メモリの最大量は、アプリケーションが使用する同時オープン&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;と&lt;a href=&quot;c3ref/stmt&quot;&gt;準備済みステートメント&lt;/a&gt;オブジェクトの数、&lt;a href=&quot;c3ref/stmt&quot;&gt;準備済みステートメントの&lt;/a&gt;複雑さなどの要因によって決まります。特定のアプリケーションでは、これらの要因は通常は固定されており、&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;を使用して実験的に決定できます。一般的なアプリケーションでは、約40KBの汎用メモリしか使用しない場合があります。これにより、&lt;b&gt;N&lt;/b&gt;の値は約100KBになります。</target>
        </trans-unit>
        <trans-unit id="a9b767b87a835989935611d9f91af0a49ef22427" translate="yes" xml:space="preserve">
          <source>The maximum and minimum embedded payload fractions and the leaf payload fraction values must be 64, 32, and 32. These values were originally intended to be tunable parameters that could be used to modify the storage format of the b-tree algorithm. However, that functionality is not supported and there are no current plans to add support in the future. Hence, these three bytes are fixed at the values specified.</source>
          <target state="translated">埋め込みペイロードフラクションの最大値と最小値、およびリーフペイロードフラクションの値は、64、32、32でなければなりません。これらの値は元々、b-tree アルゴリズムの保存形式を変更するために使用できる調整可能なパラメータであることを意図していましたが、その機能はサポートされておらず、将来的にサポートを追加する予定はありません。しかし、その機能はサポートされておらず、将来的にサポートを追加する予定はありません。したがって、これら3つのバイトは指定された値に固定されています。</target>
        </trans-unit>
        <trans-unit id="3b75dd01c336dd48a91229fb4fe465cfca0656d8" translate="yes" xml:space="preserve">
          <source>The maximum depth of an expression tree can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitexprdepth&quot;&gt;SQLITE_LIMIT_EXPR_DEPTH&lt;/a&gt;,size) interface if the SQLITE_MAX_EXPR_DEPTH is initially positive. In other words, the maximum expression depth can be lowered at run-time if there is already a compile-time limit on the expression depth. If SQLITE_MAX_EXPR_DEPTH is set to 0 at compile time (if the depth of expressions is unlimited) then the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitexprdepth&quot;&gt;SQLITE_LIMIT_EXPR_DEPTH&lt;/a&gt;,size) is a no-op.</source>
          <target state="translated">式ツリーの最大深さを使用して実行時に低下させることができる&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（DB、&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitexprdepth&quot;&gt;SQLITE_LIMIT_EXPR_DEPTH&lt;/a&gt; SQLITE_MAX_EXPR_DEPTHが最初に正の場合、サイズ）インタフェースを。言い換えると、式の深さにコンパイル時の制限がすでにある場合、実行時に最大の式の深さを下げることができます。SQLITE_MAX_EXPR_DEPTHがコンパイル時に0に設定されている場合（式の深さが無制限の場合）、&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitexprdepth&quot;&gt;SQLITE_LIMIT_EXPR_DEPTH&lt;/a&gt;、size）は何もしません。</target>
        </trans-unit>
        <trans-unit id="7601f568790af4a666771d9637268d8679fb90bb" translate="yes" xml:space="preserve">
          <source>The maximum depth of recursion for triggers.</source>
          <target state="translated">トリガーの再帰の最大深度。</target>
        </trans-unit>
        <trans-unit id="f7ca88d6870cff0eca30922b0b5339bd065f10ca" translate="yes" xml:space="preserve">
          <source>The maximum depth of the parse tree on any expression.</source>
          <target state="translated">任意の式の解析木の最大深度を指定します。</target>
        </trans-unit>
        <trans-unit id="2e6bbb757edd69dcf67031bc6d4f260f516ed8d0" translate="yes" xml:space="preserve">
          <source>The maximum host parameter number can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt;,size) interface.</source>
          <target state="translated">ホストパラメータの最大数は、&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt;、size）インターフェースを使用して実行時に下げることができます。</target>
        </trans-unit>
        <trans-unit id="b3e774d908522cebf9bd7f7f3469b3fb31276410" translate="yes" xml:space="preserve">
          <source>The maximum index number of any &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; in an SQL statement.</source>
          <target state="translated">SQLステートメント内の任意の&lt;a href=&quot;../lang_expr#varparam&quot;&gt;パラメーター&lt;/a&gt;の最大インデックス番号。</target>
        </trans-unit>
        <trans-unit id="32a6d72e37d636464c2192cbf409c3425887feb6" translate="yes" xml:space="preserve">
          <source>The maximum index number of any &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; in an SQL statement.</source>
          <target state="translated">SQLステートメント内の任意の&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメーター&lt;/a&gt;の最大インデックス番号。</target>
        </trans-unit>
        <trans-unit id="ab2a11cb65d0770d55a8b43b094028bd3c341a46" translate="yes" xml:space="preserve">
          <source>The maximum length of a LIKE or GLOB pattern can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlikepatternlength&quot;&gt;SQLITE_LIMIT_LIKE_PATTERN_LENGTH&lt;/a&gt;,size) interface.</source>
          <target state="translated">LIKEまたはGLOBパターンの最大長は、&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlikepatternlength&quot;&gt;SQLITE_LIMIT_LIKE_PATTERN_LENGTH&lt;/a&gt;、size）インターフェースを使用して実行時に下げることができます。</target>
        </trans-unit>
        <trans-unit id="d765036961e5dc86e0ba5117af47c297fab27c55" translate="yes" xml:space="preserve">
          <source>The maximum length of an SQL statement can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitsqllength&quot;&gt;SQLITE_LIMIT_SQL_LENGTH&lt;/a&gt;,size) interface.</source>
          <target state="translated">SQLステートメントの最大長は、実行時に&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitsqllength&quot;&gt;SQLITE_LIMIT_SQL_LENGTH&lt;/a&gt;、size）インターフェースを使用して下げることができます。</target>
        </trans-unit>
        <trans-unit id="d303fbf5ebde80b928a0a149ac1d360f8b2d9beb" translate="yes" xml:space="preserve">
          <source>The maximum length of an SQL statement, in bytes.</source>
          <target state="translated">SQL 文の最大長をバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="c8feb93491c3d188a9985624d09a15796f2e0e57" translate="yes" xml:space="preserve">
          <source>The maximum length of the pattern argument to the &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operators.</source>
          <target state="translated">&lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt;または&lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;演算子へのパターン引数の最大長。</target>
        </trans-unit>
        <trans-unit id="1ee02be23a19dec285dd5109a44c64362161f0e7" translate="yes" xml:space="preserve">
          <source>The maximum length of the pattern argument to the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operators.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;または&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;演算子へのパターン引数の最大長。</target>
        </trans-unit>
        <trans-unit id="b23da6f4323ba72ffe46e74c0191923768cdb864" translate="yes" xml:space="preserve">
          <source>The maximum number of &lt;a href=&quot;../lang_attach&quot;&gt;attached databases&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../lang_attach&quot;&gt;接続されているデータベース&lt;/a&gt;の最大数。</target>
        </trans-unit>
        <trans-unit id="b544569d59df80608bd6a41e19a745bdff4577b6" translate="yes" xml:space="preserve">
          <source>The maximum number of &lt;a href=&quot;lang_attach&quot;&gt;attached databases&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_attach&quot;&gt;接続されているデータベース&lt;/a&gt;の最大数。</target>
        </trans-unit>
        <trans-unit id="471b9bc71d47534b60a1c278c46d4cee7c9664ba" translate="yes" xml:space="preserve">
          <source>The maximum number of arguments in a function can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;,size) interface.</source>
          <target state="translated">関数の引数の最大数は、&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;、size）インターフェースを使用して実行時に下げることができます。</target>
        </trans-unit>
        <trans-unit id="00eff3b06f801e572f28af21289c2619b46c2f08" translate="yes" xml:space="preserve">
          <source>The maximum number of arguments on a function.</source>
          <target state="translated">関数の最大引数数。</target>
        </trans-unit>
        <trans-unit id="b6c416e24701b8851e7053c0bb7cd7dd6b331315" translate="yes" xml:space="preserve">
          <source>The maximum number of attached databases can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitattached&quot;&gt;SQLITE_LIMIT_ATTACHED&lt;/a&gt;,size) interface.</source>
          <target state="translated">接続されているデータベースの最大数は、&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitattached&quot;&gt;SQLITE_LIMIT_ATTACHED&lt;/a&gt;、size）インターフェースを使用して実行時に下げることができます。</target>
        </trans-unit>
        <trans-unit id="0b6c3c6cf8605d1353c6caeac57deb9da3ed0c6e" translate="yes" xml:space="preserve">
          <source>The maximum number of auxiliary worker threads that a single &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; may start.</source>
          <target state="translated">単一の&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備済みステートメント&lt;/a&gt;が開始できる補助ワーカースレッドの最大数。</target>
        </trans-unit>
        <trans-unit id="66f8c3a081d879e272abf19945402c6cac2a7ecc" translate="yes" xml:space="preserve">
          <source>The maximum number of auxiliary worker threads that a single &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; may start.</source>
          <target state="translated">単一の&lt;a href=&quot;stmt&quot;&gt;準備済みステートメント&lt;/a&gt;が開始できる補助ワーカースレッドの最大数。</target>
        </trans-unit>
        <trans-unit id="bbb454e2483711c9ac94945a0c80d3f47e450874" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes in a string or BLOB in SQLite is defined by the preprocessor macro SQLITE_MAX_LENGTH. The default value of this macro is 1 billion (1 thousand million or 1,000,000,000). You can raise or lower this value at compile-time using a command-line option like this:</source>
          <target state="translated">SQLite の文字列または BLOB の最大バイト数は、プリプロセッサ マクロ SQLITE_MAX_LENGTH によって定義されます。このマクロの既定値は 10 億 (1,000,000,000,000 または 1,000,000,000)です。コンパイル時にこの値を上げたり下げたりするには、次のようなコマンドラインオプションを使用します。</target>
        </trans-unit>
        <trans-unit id="da1ee68dd77283238b55af162c380f02592134ee" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes in the text of an SQL statement is limited to SQLITE_MAX_SQL_LENGTH which defaults to 1000000. You can redefine this limit to be as large as the smaller of SQLITE_MAX_LENGTH and 1073741824.</source>
          <target state="translated">SQL 文のテキスト内の最大バイト数は、SQLITE_MAX_SQL_LENGTH に制限されています。この制限を SQLITE_MAX_LENGTH と 1073741824 のいずれか小さい方のサイズに再定義することができます。</target>
        </trans-unit>
        <trans-unit id="6345ddabb514350f3e36f681af647ea84308cf28" translate="yes" xml:space="preserve">
          <source>The maximum number of columns can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcolumn&quot;&gt;SQLITE_LIMIT_COLUMN&lt;/a&gt;,size) interface.</source>
          <target state="translated">列の最大数は、&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcolumn&quot;&gt;SQLITE_LIMIT_COLUMN&lt;/a&gt;、size）インターフェースを使用して実行時に下げることができます。</target>
        </trans-unit>
        <trans-unit id="1c620a336050426a95c894972afda47b3aee66a2" translate="yes" xml:space="preserve">
          <source>The maximum number of columns in a table definition or in the result set of a &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; or the maximum number of columns in an index or in an ORDER BY or GROUP BY clause.</source>
          <target state="translated">テーブル定義または&lt;a href=&quot;../lang_select&quot;&gt;SELECTの&lt;/a&gt;結果セット内の列の最大数、またはインデックス内またはORDER BY句またはGROUP BY句内の列の最大数。</target>
        </trans-unit>
        <trans-unit id="355eec7f9bb7446523a2374f005ae8119aa229d8" translate="yes" xml:space="preserve">
          <source>The maximum number of columns in a table definition or in the result set of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; or the maximum number of columns in an index or in an ORDER BY or GROUP BY clause.</source>
          <target state="translated">テーブル定義または&lt;a href=&quot;lang_select&quot;&gt;SELECTの&lt;/a&gt;結果セット内の列の最大数、またはインデックス内またはORDER BY句またはGROUP BY句内の列の最大数。</target>
        </trans-unit>
        <trans-unit id="8374b8e68f54521ffc214c5ed7e8c2d7fd95f1b7" translate="yes" xml:space="preserve">
          <source>The maximum number of compound SELECT terms can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcompoundselect&quot;&gt;SQLITE_LIMIT_COMPOUND_SELECT&lt;/a&gt;,size) interface.</source>
          <target state="translated">複合SELECT用語の最大数は、&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcompoundselect&quot;&gt;SQLITE_LIMIT_COMPOUND_SELECT&lt;/a&gt;、size）インターフェースを使用して実行時に下げることができます。</target>
        </trans-unit>
        <trans-unit id="63cbc7c9607d5bbb2a5e8441eb06e668604fc05c" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions in a virtual machine program used to implement an SQL statement. If &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or the equivalent tries to allocate space for more than this many opcodes in a single prepared statement, an SQLITE_NOMEM error is returned.</source>
          <target state="translated">SQLステートメントの実装に使用される仮想マシンプログラムの命令の最大数。場合&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;または同等の試みは、単一のプリペアドステートメントでは、この多くのオペコードより多くのスペースを割り当てるために、SQLITE_NOMEMエラーが返されます。</target>
        </trans-unit>
        <trans-unit id="3914cdf98f328c74ff19ff41972588f848a7b49e" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions in a virtual machine program used to implement an SQL statement. If &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or the equivalent tries to allocate space for more than this many opcodes in a single prepared statement, an SQLITE_NOMEM error is returned.</source>
          <target state="translated">SQLステートメントの実装に使用される仮想マシンプログラムの命令の最大数。場合&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;または同等の試みは、単一のプリペアドステートメントでは、この多くのオペコードより多くのスペースを割り当てるために、SQLITE_NOMEMエラーが返されます。</target>
        </trans-unit>
        <trans-unit id="7c57be7916f18cb9fd931235954ed49b10f67a38" translate="yes" xml:space="preserve">
          <source>The maximum number of terms in a compound SELECT statement.</source>
          <target state="translated">複合SELECT文の最大項数。</target>
        </trans-unit>
        <trans-unit id="6409e263b558e4fc8032ff274ccb7661be29c559" translate="yes" xml:space="preserve">
          <source>The maximum number of tokens in the returned text. This must be greater than zero and equal to or less than 64.</source>
          <target state="translated">返されるテキスト内のトークンの最大数。これはゼロより大きく、64以下でなければなりません。</target>
        </trans-unit>
        <trans-unit id="970d6e67d87a8bc5f32df0c8fe5b2ab66eff4335" translate="yes" xml:space="preserve">
          <source>The maximum parameter number is set at compile-time by the &lt;a href=&quot;limits#max_variable_number&quot;&gt;SQLITE_MAX_VARIABLE_NUMBER&lt;/a&gt; macro. An individual &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; D can reduce its maximum parameter number below the compile-time maximum using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(D, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt;,...) interface.</source>
          <target state="translated">最大パラメーター数は、コンパイル時に&lt;a href=&quot;limits#max_variable_number&quot;&gt;SQLITE_MAX_VARIABLE_NUMBER&lt;/a&gt;マクロによって設定されます。個々の&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt; Dは、&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（D、&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt;、...）インターフェースを使用して、最大パラメーター数をコンパイル時の最大数より少なくすることができます。</target>
        </trans-unit>
        <trans-unit id="eeb9b32b1bfb4a0ced4bb9bc2aaa054c3abdfc92" translate="yes" xml:space="preserve">
          <source>The maximum size of any string or BLOB or table row, in bytes.</source>
          <target state="translated">文字列、BLOB、テーブル行の最大サイズをバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="c7f288d6ab417ac4a35975a5356fac79645319c2" translate="yes" xml:space="preserve">
          <source>The maximum string or BLOB length can be lowered at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;,size) interface.</source>
          <target state="translated">文字列またはBLOBの最大長は、&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;、size）インターフェースを使用して実行時に下げることができます。</target>
        </trans-unit>
        <trans-unit id="770a09ba0039805fb6c3142551082e18eaaafe07" translate="yes" xml:space="preserve">
          <source>The meaning of P5 depends on whether or not the SQLITE_ENABLE_NULL_TRIM compile-time option is enabled:</source>
          <target state="translated">P5 の意味は、コンパイル時の SQLITE_ENABLE_NULL_TRIM オプションが有効になっているかどうかに依存します。</target>
        </trans-unit>
        <trans-unit id="5cc8ccfaed1025b2039c6bdfd6b0a5399eacb5ca" translate="yes" xml:space="preserve">
          <source>The meanings for all $nResCode result code values are shown below, in numeric order.</source>
          <target state="translated">すべての$nResCode結果コード値の意味は、数値順に以下に示されています。</target>
        </trans-unit>
        <trans-unit id="4cad3638dbf4cc08ff40caa02c71d9ae2dc2cc12" translate="yes" xml:space="preserve">
          <source>The meanings for all 92 result code values are shown below, in numeric order.</source>
          <target state="translated">すべての92の結果コード値の意味を数値順に以下に示します。</target>
        </trans-unit>
        <trans-unit id="acfaa39aa41d2de54931d409a9de16ab158bc08a" translate="yes" xml:space="preserve">
          <source>The meanings of these various return values are as follows:</source>
          <target state="translated">これらの様々な戻り値の意味は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="3594f845ca8155469ebf0d3a1db0993f4bb9cbd1" translate="yes" xml:space="preserve">
          <source>The measurements in this article were made during the week of 2017-06-05 using a version of SQLite in between 3.19.2 and 3.20.0. You may expect future versions of SQLite to perform even better.</source>
          <target state="translated">この記事の測定は、2017-06-05の週に、3.19.2から3.20.0の間のバージョンのSQLiteを使用して行われました。将来のバージョンの SQLite がさらに良いパフォーマンスを発揮することを期待してもいいかもしれません。</target>
        </trans-unit>
        <trans-unit id="f2809fd545c907ef31fca4768c017467b4928225" translate="yes" xml:space="preserve">
          <source>The memory allocation limits can also be adjusted using &lt;a href=&quot;pragma#pragma_soft_heap_limit&quot;&gt;PRAGMA soft_heap_limit&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_hard_heap_limit&quot;&gt;PRAGMA hard_heap_limit&lt;/a&gt;.</source>
          <target state="translated">メモリ割り当ての制限も使用して調整することができる&lt;a href=&quot;pragma#pragma_soft_heap_limit&quot;&gt;プラグマsoft_heap_limit&lt;/a&gt;と&lt;a href=&quot;pragma#pragma_hard_heap_limit&quot;&gt;プラグマhard_heap_limitを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e788358e2ac74022367111d33deb5ddc9a976282" translate="yes" xml:space="preserve">
          <source>The memory corruption problem becomes more acute when using &lt;a href=&quot;mmap&quot;&gt;memory-mapped I/O&lt;/a&gt;. When all or part of the database file is mapped into the application's address space, then a stray pointer that overwrites any part of that mapped space will immediately corrupt the database file, without requiring the application to do a subsequent write() system call.</source>
          <target state="translated">メモリ&lt;a href=&quot;mmap&quot;&gt;マップI / O&lt;/a&gt;を使用すると、メモリ破損の問題がさらに深刻になります。データベースファイルのすべてまたは一部がアプリケーションのアドレススペースにマップされると、そのマップされたスペースの一部を上書きする浮遊ポインタは、アプリケーションに後続のwrite（）システムコールを実行させることなく、データベースファイルをただちに破壊します。</target>
        </trans-unit>
        <trans-unit id="1f25753cb6dacb02b829c0a340f5d35891b7f9cb" translate="yes" xml:space="preserve">
          <source>The memory footprint of the application can be dramatically reduced by only loading content that is relevant to the current display and keeping the bulk of the content on disk. The fast query capability of SQLite make this a viable alternative to keeping all content in memory at all times. And when applications use less memory, it makes the entire computer more responsive, further enhancing the user experience.</source>
          <target state="translated">現在の表示に関連するコンテンツのみをロードし、コンテンツの大部分をディスク上に保持することで、アプリケーションのメモリフットプリントを劇的に削減することができます。SQLite の高速なクエリ機能により、これはすべてのコンテンツを常にメモリに保持する代わりに実行可能な代替手段となります。また、アプリケーションのメモリ使用量が減れば、コンピュータ全体の応答性が向上し、ユーザー体験をさらに向上させることができます。</target>
        </trans-unit>
        <trans-unit id="9d3e4b06e9105ca7c88a4e1edabcb69936b1841b" translate="yes" xml:space="preserve">
          <source>The memory high-water mark is reset to the current value of &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; if and only if the parameter to &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; is true. The value returned by &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater(1)&lt;/a&gt; is the high-water mark prior to the reset.</source>
          <target state="translated">メモリハイウォーターマークの現在の値にリセットされ&lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;（）sqlite3_memory_used&lt;/a&gt;場合とにパラメータ場合のみ&lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater（）は&lt;/a&gt;真です。&lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater（1）&lt;/a&gt;が返す値は、リセット前の最高水準点です。</target>
        </trans-unit>
        <trans-unit id="cd5593ab95a8d1e1ac6cc8d242678782f1a535e8" translate="yes" xml:space="preserve">
          <source>The memory high-water mark is reset to the current value of &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; if and only if the parameter to &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; is true. The value returned by &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater(1)&lt;/a&gt; is the high-water mark prior to the reset.</source>
          <target state="translated">メモリハイウォーターマークの現在の値にリセットされ&lt;a href=&quot;memory_highwater&quot;&gt;（）sqlite3_memory_used&lt;/a&gt;場合とにパラメータ場合のみ&lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater（）は&lt;/a&gt;真です。&lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater（1）&lt;/a&gt;が返す値は、リセット前の最高水準点です。</target>
        </trans-unit>
        <trans-unit id="a98788d1208d8031c1910803fa2f1051d600b111" translate="yes" xml:space="preserve">
          <source>The memory pointed to by the character pointers returned for the declaration type and collation sequence is valid until the next call to any SQLite API function.</source>
          <target state="translated">宣言型と照合順序のために返された文字ポインタが指すメモリは、次に任意の SQLite API 関数を呼び出すまで有効です。</target>
        </trans-unit>
        <trans-unit id="523aa17230ae599153575b20eede454c13803757" translate="yes" xml:space="preserve">
          <source>The memory returned by sqlite3_malloc(), sqlite3_realloc(), sqlite3_malloc64(), and sqlite3_realloc64() is always aligned to at least an 8 byte boundary, or to a 4 byte boundary if the &lt;a href=&quot;../compile#4_byte_aligned_malloc&quot;&gt;SQLITE_4_BYTE_ALIGNED_MALLOC&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">sqlite3_malloc（）、sqlite3_realloc（）、sqlite3_malloc64（）、およびsqlite3_realloc64（）によって返されるメモリは、常に少なくとも8バイトの境界、または&lt;a href=&quot;../compile#4_byte_aligned_malloc&quot;&gt;SQLITE_4_BYTE_ALIGNED_MALLOC&lt;/a&gt;コンパイル時オプションが使用されている場合は4バイトの境界に揃えられます。</target>
        </trans-unit>
        <trans-unit id="0b4a85ec728749e1396a0209dbea3173ce995dba" translate="yes" xml:space="preserve">
          <source>The memory returned by sqlite3_malloc(), sqlite3_realloc(), sqlite3_malloc64(), and sqlite3_realloc64() is always aligned to at least an 8 byte boundary, or to a 4 byte boundary if the &lt;a href=&quot;compile#4_byte_aligned_malloc&quot;&gt;SQLITE_4_BYTE_ALIGNED_MALLOC&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">sqlite3_malloc（）、sqlite3_realloc（）、sqlite3_malloc64（）、およびsqlite3_realloc64（）によって返されるメモリは、常に少なくとも8バイトの境界、または&lt;a href=&quot;compile#4_byte_aligned_malloc&quot;&gt;SQLITE_4_BYTE_ALIGNED_MALLOC&lt;/a&gt;コンパイル時オプションが使用されている場合は4バイトの境界に揃えられます。</target>
        </trans-unit>
        <trans-unit id="d4065cde811c203e3d250a3f54d5601da517866b" translate="yes" xml:space="preserve">
          <source>The memsys5 allocator is designed for use on embedded systems, though there is nothing to prevent its use on workstations. The szBuf is typically between a few hundred kilobytes up to a few dozen megabytes, depending on system requirements and memory budget.</source>
          <target state="translated">memsys5 アロケータは組み込みシステム用に設計されていますが、ワークステーションでの使用を妨げるものは何もありません。szBuf は、システム要件とメモリ予算に応じて、通常数百キロバイトから数十メガバイトの間です。</target>
        </trans-unit>
        <trans-unit id="15e755d3b15a2797fc8e730750dc9e96957bcf11" translate="yes" xml:space="preserve">
          <source>The min() aggregate function returns the minimum non-NULL value of all values in the group. The minimum value is the first non-NULL value that would appear in an ORDER BY of the column. Aggregate min() returns NULL if and only if there are no non-NULL values in the group.</source>
          <target state="translated">min()集約関数は、グループ内のすべての値のうち、最小の非NULL値を返します。最小値は、列の ORDER BY に現れる最初の非 NULL 値となります。集約関数 min()は、グループ内に non-NULL 値が存在しない場合にのみ NULL を返します。</target>
        </trans-unit>
        <trans-unit id="114a5a7dbd98c187abf7e68d111172546895bf6d" translate="yes" xml:space="preserve">
          <source>The min/max-value pair columns are stored as 32-bit floating point values for &quot;rtree&quot; virtual tables or as 32-bit signed integers in &quot;rtree_i32&quot; virtual tables. Unlike regular SQLite tables which can store data in a variety of datatypes and formats, the R*Tree rigidly enforce these storage types. If any other type of value is inserted into such a column, the r-tree module silently converts it to the required type before writing the new record to the database.</source>
          <target state="translated">min/max-valueペアのカラムは、&quot;rtree &quot;仮想テーブルでは32ビット浮動小数点値として、&quot;rtree_i32 &quot;仮想テーブルでは32ビット符号付き整数として格納されます。様々なデータ型や形式でデータを格納できる通常のSQLiteテーブルとは異なり、R*Treeではこれらの格納型を厳密に強制しています。他のタイプの値がそのような列に挿入された場合、r-treeモジュールは、新しいレコードをデータベースに書き込む前に、それを必要なタイプに静かに変換します。</target>
        </trans-unit>
        <trans-unit id="697dd64d2ba004e05302a199cbf94ae930397047" translate="yes" xml:space="preserve">
          <source>The minimum &quot;three+four&quot; value</source>
          <target state="translated">3+4」の最小値</target>
        </trans-unit>
        <trans-unit id="4344744cb5e4e7fe1c07e4d9e9f4f1a35db07ca5" translate="yes" xml:space="preserve">
          <source>The minimum size of an SQLite database is one page for each table and each index. With a larger page size, the size of an empty database for a given schema will grow by a factor of four, therefore. However, once the database begins to fill with content the size of the older 1024-byte page databases and the newer 4096-byte page databases will quickly converge. Due to relaxed bin-packing constraints, the 4096-byte page size might actually result in a smaller file, once substantial content is added.</source>
          <target state="translated">SQLite データベースの最小サイズは、各テーブルと各インデックスに対して 1 ページです。ページサイズが大きくなると、与えられたスキーマの空のデータベースのサイズは4倍になります。しかし、データベースがコンテンツで満たされ始めると、1024バイトの古いページデータベースと4096バイトの新しいページデータベースのサイズはすぐに収束します。ビンパッキングの制約が緩和されているため、4096バイトのページサイズは、実質的なコンテンツが追加されると、実際にはより小さなファイルになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="e5d2ce57cb5bfbf79b3c98a499658be04c3e7756" translate="yes" xml:space="preserve">
          <source>The minor version number Y was historically incremented for new features and/or new interfaces that did not significantly change the structure of the code. The addition of &lt;a href=&quot;lang_with&quot;&gt;common table expressions&lt;/a&gt;, &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;, and &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt; are all examples of &quot;minor&quot; changes. Again, the distinction between &quot;major&quot; and &quot;minor&quot; is subjective.</source>
          <target state="translated">マイナーバージョン番号Yは、コードの構造を大幅に変更しなかった新しい機能や新しいインターフェイス、あるいはその両方のために歴史的に増加しました。追加&lt;a href=&quot;lang_with&quot;&gt;共通テーブル式&lt;/a&gt;、&lt;a href=&quot;partialindex&quot;&gt;部分インデックス&lt;/a&gt;、および&lt;a href=&quot;expridx&quot;&gt;式のインデックスは&lt;/a&gt;「マイナー」の変更のすべての例です。ここでも、「メジャー」と「マイナー」の区別は主観的です。</target>
        </trans-unit>
        <trans-unit id="daac53b800202886e5a1bc16ab5a5eb44a3f8d4d" translate="yes" xml:space="preserve">
          <source>The mirror is an incremental export of the &lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;canonical Fossil repository&lt;/a&gt; for SQLite. A cron-job updates the GitHub repository once an hour. This is a one-way, read-only code mirror. No pull requests or changes are accepted via GitHub. The GitHub repository merely copies the content from the Fossil repository. All changes are input via Fossil.</source>
          <target state="translated">ミラーは、SQLiteの&lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;正規化されたFossilリポジトリの&lt;/a&gt;増分エクスポートです。 cronジョブは、GitHubリポジトリを1時間に1回更新します。これは、一方向の読み取り専用コードミラーです。 GitHubを介したプルリクエストや変更は受け付けられません。 GitHubリポジトリは、Fossilリポジトリからコンテンツをコピーするだけです。すべての変更はFossilを介して入力されます。</target>
        </trans-unit>
        <trans-unit id="8699fa6e48270c38aaec7f72b7768d7c856e3da2" translate="yes" xml:space="preserve">
          <source>The mmap_size is set separately for each database file using the &quot;&lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;&quot; statement. The usual default mmap_size is zero, meaning that memory mapped I/O is disabled by default. However, the default mmap_size can be increased either at compile-time using the &lt;a href=&quot;compile#default_mmap_size&quot;&gt;SQLITE_DEFAULT_MMAP_SIZE&lt;/a&gt; macro or at start-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;,...) interface.</source>
          <target state="translated">mmap_sizeは、「&lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;」ステートメントを使用して、データベースファイルごとに個別に設定されます。通常のデフォルトmmap_sizeはゼロです。つまり、メモリマップI / Oはデフォルトで無効になっています。ただし、デフォルトのmmap_sizeは、コンパイル時に&lt;a href=&quot;compile#default_mmap_size&quot;&gt;SQLITE_DEFAULT_MMAP_SIZE&lt;/a&gt;マクロを使用して、または開始時に&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;、...）インターフェースを使用して増やすことができます。</target>
        </trans-unit>
        <trans-unit id="bc3aa8081ad975eaa64522ee2647fdff6a383213" translate="yes" xml:space="preserve">
          <source>The mode query parameter determines if the new database is opened read-only, read-write, read-write and created if it does not exist, or that the database is a pure in-memory database that never interacts with disk, respectively.</source>
          <target state="translated">モードクエリパラメータは、新しいデータベースがオープンされているかどうか、存在しない場合はリードオンリー、リードライト、リードライト、作成されているかどうか、あるいは、データベースがディスクとは決して相互作用しない純粋なインメモリデータベースであるかどうかをそれぞれ決定します。</target>
        </trans-unit>
        <trans-unit id="f2526ac46e681fb29c61b97dfb71933e5d3d8f00" translate="yes" xml:space="preserve">
          <source>The modifications made to each row affected by an UPDATE statement are determined by the list of assignments following the SET keyword. Each assignment specifies a column-name to the left of the equals sign and a scalar expression to the right. For each affected row, the named columns are set to the values found by evaluating the corresponding scalar expressions. If a single column-name appears more than once in the list of assignment expressions, all but the rightmost occurrence is ignored. Columns that do not appear in the list of assignments are left unmodified. The scalar expressions may refer to columns of the row being updated. In this case all scalar expressions are evaluated before any assignments are made.</source>
          <target state="translated">UPDATE 文によって影響を受ける各行に加えられる変更は、SET キーワードに続く代入のリストによって決定されます。各代入は、等号の左側に列名、右側にスカラ式を指定します。影響を受ける各行について、指定された列は、対応するスカラー式を評価して得られた値に設定されます。1つの列名が代入式のリストに複数回現れた場合、一番右端の列名以外は無視されます。代入式のリストに現れない列は変更されないままになります。スカラー式は更新される行の列を参照している場合があります。この場合、すべてのスカラー式は代入が行われる前に評価されます。</target>
        </trans-unit>
        <trans-unit id="c57c56215c73a95bddb16c7f419303a4f511dbe2" translate="yes" xml:space="preserve">
          <source>The module name is registered on the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; specified by the first parameter. The name of the module is given by the second parameter. The third parameter is a pointer to the implementation of the &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt;. The fourth parameter is an arbitrary client data pointer that is passed through into the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of the virtual table module when a new virtual table is be being created or reinitialized.</source>
          <target state="translated">モジュール名は、最初のパラメーターで指定された&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続に&lt;/a&gt;登録されます。モジュールの名前は2番目のパラメーターで指定されます。 3番目のパラメータは、&lt;a href=&quot;#sqlite3_module&quot;&gt;仮想テーブルモジュールの&lt;/a&gt;実装へのポインタです。 4番目のパラメーターは、新しい仮想テーブルが作成または再初期化されるときに仮想テーブルモジュールの&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;および&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;メソッドに渡される任意のクライアントデータポインターです。</target>
        </trans-unit>
        <trans-unit id="f7d008fdf7032ca8558d613dfe5b4ba03ec8869a" translate="yes" xml:space="preserve">
          <source>The module name is registered on the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; specified by the first parameter. The name of the module is given by the second parameter. The third parameter is a pointer to the implementation of the &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt;. The fourth parameter is an arbitrary client data pointer that is passed through into the &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of the virtual table module when a new virtual table is be being created or reinitialized.</source>
          <target state="translated">モジュール名は、最初のパラメーターで指定された&lt;a href=&quot;sqlite3&quot;&gt;データベース接続に&lt;/a&gt;登録されます。モジュールの名前は2番目のパラメーターで指定されます。 3番目のパラメータは、&lt;a href=&quot;module&quot;&gt;仮想テーブルモジュールの&lt;/a&gt;実装へのポインタです。 4番目のパラメーターは、新しい仮想テーブルが作成または再初期化されるときに仮想テーブルモジュールの&lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;および&lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;メソッドに渡される任意のクライアントデータポインターです。</target>
        </trans-unit>
        <trans-unit id="c29884604bb765a8ff66e73918a8eec45479c155" translate="yes" xml:space="preserve">
          <source>The module name must be changed from &quot;fts3&quot; or &quot;fts4&quot; to &quot;fts5&quot;.</source>
          <target state="translated">モジュール名を &quot;fts3 &quot;または &quot;fts4 &quot;から &quot;fts5 &quot;に変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="ea30bfabecd455dc9fb80bfe26599d0bf2066398" translate="yes" xml:space="preserve">
          <source>The module structure contains methods that are invoked by SQLite to perform various actions on the virtual table such as creating new instances of a virtual table or destroying old ones, reading and writing data, searching for and deleting, updating, or inserting rows. The module structure is explained in more detail below.</source>
          <target state="translated">モジュール構造には、仮想テーブルの新規インスタンスの作成や古いインスタンスの破棄、データの読み書き、行の検索や削除、更新、挿入など、仮想テーブル上で様々なアクションを実行するためにSQLiteによって呼び出されるメソッドが含まれています。モジュールの構造については、以下で詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="e7e8ce1834b0e39b1a04f1ee58c27c3761f545ea" translate="yes" xml:space="preserve">
          <source>The module structure defines all of the methods for each virtual table object. The module structure also contains the iVersion field which defines the particular edition of the module table structure. Currently, iVersion is always 3 or less, but in future releases of SQLite the module structure definition might be extended with additional methods and in that case the maximum iVersion value will be increased.</source>
          <target state="translated">モジュール構造は、各仮想テーブルオブジェクトのすべてのメソッドを定義します。モジュール構造には、モジュール・テーブル構造の特定のエディションを定義する iVersion フィールドも含まれています。現在のところ、iVersion は常に 3 以下ですが、SQLite の将来のリリースでは、モジュール構造の定義がメソッドを追加して拡張される可能性があり、その場合は iVersion の最大値が増加します。</target>
        </trans-unit>
        <trans-unit id="f82636212897757718a1a7712ed9f6ebe7472ac1" translate="yes" xml:space="preserve">
          <source>The module-name is the name of an object that implements the virtual table. The module-name must be registered with the SQLite database connection using &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; or &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; prior to issuing the CREATE VIRTUAL TABLE statement. The module takes zero or more comma-separated arguments. The arguments can be just about any text as long as it has balanced parentheses. The argument syntax is sufficiently general that the arguments can be made to appear as &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;column definitions&lt;/a&gt; in a traditional &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. SQLite passes the module arguments directly to the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of the module implementation without any interpretation. It is the responsibility of the module implementation to parse and interpret its own arguments.</source>
          <target state="translated">module-nameは、仮想テーブルを実装するオブジェクトの名前です。 module-nameは、CREATE VIRTUAL TABLEステートメントを発行する前に、&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module（）&lt;/a&gt;または&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2（）&lt;/a&gt;を使用してSQLiteデータベース接続に登録する必要があります。モジュールは、0個以上のコンマ区切りの引数を取ります。引数は、括弧のバランスがとれている限り、どのようなテキストでもかまいません。引数の構文は十分に一般的であり、引数を従来の&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;ステートメントの&lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;列定義&lt;/a&gt;として表示することができます。 SQLiteはモジュール引数を&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;および&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnectに&lt;/a&gt;直接渡します解釈なしのモジュール実装のメソッド。独自の引数を解析および解釈するのは、モジュール実装の責任です。</target>
        </trans-unit>
        <trans-unit id="44619ca32ea56419710789f2ec6fc9766c59ac70" translate="yes" xml:space="preserve">
          <source>The most common reason an attempt to obtain a</source>
          <target state="translated">を取得しようとする試みが最も一般的な理由は</target>
        </trans-unit>
        <trans-unit id="b4677e9c54155902987749f94de50b511a297fed" translate="yes" xml:space="preserve">
          <source>The most common way to force an SQLite database to exist purely in memory is to open the database using the special filename &quot;&lt;b&gt;:memory:&lt;/b&gt;&quot;. In other words, instead of passing the name of a real disk file into one of the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; functions, pass in the string &quot;:memory:&quot;. For example:</source>
          <target state="translated">SQLiteデータベースをメモリ内のみに存在させる最も一般的な方法は、特別なファイル名 &quot; &lt;b&gt;：memory：&lt;/b&gt; &quot; を使用してデータベースを開くことです。つまり、実際のディスクファイルの名前を&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;、&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt;、または&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;関数のいずれかに渡す代わりに、文字列 &quot;：memory：&quot;を渡します。例えば：</target>
        </trans-unit>
        <trans-unit id="03a7919d9a36d839fb3e6c8676819056867ece77" translate="yes" xml:space="preserve">
          <source>The most efficient way to apply changes to a B-Tree (the data structure that SQLite uses to store each table and index on disk) is to make the changes in key order. But if an SQL table has one or more indexes, the key order for each index may be different from the main table and the other auxiliary indexes. As a result, when executing a series of &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements it is not generally possible to order the operations so that all b-trees are updated in key order. The RBU update process works around this by applying all changes to the main table in one pass, then applying changes to each index in separate passes, ensuring each B-Tree is updated optimally. For a large database file (one that does not fit in the OS disk cache) this procedure can result in two orders of magnitude faster updates.</source>
          <target state="translated">Bツリー（SQLiteが各テーブルとインデックスをディスクに格納するために使用するデータ構造）に変更を適用する最も効率的な方法は、キーの順序で変更を加えることです。ただし、SQLテーブルに1つ以上のインデックスがある場合、各インデックスのキーの順序は、メインテーブルや他の補助インデックスとは異なる場合があります。その結果、一連の&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;、&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;および&lt;a href=&quot;lang_delete&quot;&gt;DELETEを&lt;/a&gt;実行するとステートメントでは、通常、すべてのBツリーがキーの順序で更新されるように操作を順序付けることはできません。 RBU更新プロセスでは、1回のパスでメインテーブルにすべての変更を適用し、次に別のパスで各インデックスに変更を適用することで、この問題を回避し、各Bツリーが最適に更新されるようにします。大きなデータベースファイル（OSディスクキャッシュに収まらないファイル）の場合、この手順を実行すると、更新が2桁速くなります。</target>
        </trans-unit>
        <trans-unit id="0aab584bc04ad9506143fb4e57b11f24aeb68952" translate="yes" xml:space="preserve">
          <source>The most useful</source>
          <target state="translated">最も便利な</target>
        </trans-unit>
        <trans-unit id="672a287b758e4f6545eeda0d335349088507b997" translate="yes" xml:space="preserve">
          <source>The most useful thing about FTS tables is the queries that may be performed using the built-in full-text index. Full-text queries are performed by specifying a clause of the form &quot;&amp;lt;column&amp;gt; MATCH &amp;lt;full-text query expression&amp;gt;&quot; as part of the WHERE clause of a SELECT statement that reads data from an FTS table. &lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;Simple FTS queries&lt;/a&gt; that return all documents that contain a given term are described above. In that discussion the right-hand operand of the MATCH operator was assumed to be a string consisting of a single term. This section describes the more complex query types supported by FTS tables, and how they may be utilized by specifying a more complex query expression as the right-hand operand of a MATCH operator.</source>
          <target state="translated">FTSテーブルで最も役立つのは、組み込みのフルテキストインデックスを使用して実行できるクエリです。フルテキストクエリは、FTSテーブルからデータを読み取るSELECTステートメントのWHERE句の一部として &quot;&amp;lt;column&amp;gt; MATCH &amp;lt;フルテキストクエリ式&amp;gt;&quot;という形式の句を指定することによって実行されます。特定の用語を含むすべてのドキュメントを返す&lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;単純なFTSクエリ&lt;/a&gt;については、上記で説明しています。その説明では、MATCH演算子の右側のオペランドは、単一の用語で構成される文字列であると想定されていました。このセクションでは、FTSテーブルでサポートされるより複雑なクエリタイプと、より複雑なクエリ式をMATCH演算子の右側のオペランドとして指定することで、それらをどのように利用できるかについて説明します。</target>
        </trans-unit>
        <trans-unit id="b952b720a1c68c621b96fa1e29a1ec3a3e91db58" translate="yes" xml:space="preserve">
          <source>The multi-argument max() function returns the argument with the maximum value, or return NULL if any argument is NULL. The multi-argument max() function searches its arguments from left to right for an argument that defines a collating function and uses that collating function for all string comparisons. If none of the arguments to max() define a collating function, then the BINARY collating function is used. Note that &lt;b&gt;max()&lt;/b&gt; is a simple function when it has 2 or more arguments but operates as an &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;aggregate function&lt;/a&gt; if given only a single argument.</source>
          <target state="translated">複数引数のmax（）関数は、最大値を持つ引数を返すか、引数がNULLの場合はNULLを返します。複数引数のmax（）関数は、照合関数を定義する引数を左から右に検索し、すべての文字列比較にその照合関数を使用します。 max（）の引数が照合関数を定義していない場合、BINARY照合関数が使用されます。なお、&lt;b&gt;最大（）は&lt;/b&gt;、それが2つの以上の引数を持っていますが、として動作する場合、単純な機能で&lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;集計機能&lt;/a&gt;のみの単一の引数を与えた場合。</target>
        </trans-unit>
        <trans-unit id="4978bfa5c1668418de3cae9f58ae0236b3a923fa" translate="yes" xml:space="preserve">
          <source>The multi-argument min() function returns the argument with the minimum value. The multi-argument min() function searches its arguments from left to right for an argument that defines a collating function and uses that collating function for all string comparisons. If none of the arguments to min() define a collating function, then the BINARY collating function is used. Note that &lt;b&gt;min()&lt;/b&gt; is a simple function when it has 2 or more arguments but operates as an &lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;aggregate function&lt;/a&gt; if given only a single argument.</source>
          <target state="translated">複数引数のmin（）関数は、最小値の引数を返します。複数引数のmin（）関数は、引数を左から右に検索して、照合関数を定義する引数を探し、その照合関数をすべての文字列比較に使用します。min（）の引数が照合関数を定義していない場合は、BINARY照合関数が使用されます。なお、&lt;b&gt;分（）&lt;/b&gt;が2つの以上の引数を有するが、として動作する場合の単純な関数で&lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;集計機能&lt;/a&gt;のみの単一引数与えられた場合。</target>
        </trans-unit>
        <trans-unit id="78c0cf060a6f9ee3d1106d60ebe5e6c21511776f" translate="yes" xml:space="preserve">
          <source>The multiply operator now correctly detects 64-bit integer overflow and promotes to floating point in all corner-cases. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/1ec41379c9c1e400&quot;&gt;1ec41379c9c1e400&lt;/a&gt;.</source>
          <target state="translated">乗算演算子が64ビット整数のオーバーフローを正しく検出し、すべてのコーナーケースで浮動小数点に昇格するようになりました。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/1ec41379c9c1e400&quot;&gt;1ec41379c9c1e400の&lt;/a&gt;修正。</target>
        </trans-unit>
        <trans-unit id="ee9132cb0f48417f8650cad9e27fe43d03b0618b" translate="yes" xml:space="preserve">
          <source>The mutation-test.tcl script takes care of all of the details for running a mutation test:</source>
          <target state="translated">mutation-test.tclスクリプトは、突然変異テストを実行するためのすべての詳細を処理します。</target>
        </trans-unit>
        <trans-unit id="2945579c517aa1d3b8ba9d11b0bc3f91de1e9921" translate="yes" xml:space="preserve">
          <source>The mutex module within SQLite defines &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; to be an abstract type for a mutex object. The SQLite core never looks at the internal representation of an &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;. It only deals with pointers to the &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; object.</source>
          <target state="translated">SQLite内のmutexモジュールは、&lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;をmutexオブジェクトの抽象型として定義します。SQLiteコアは、&lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutexの&lt;/a&gt;内部表現を見ることはありません。&lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;オブジェクトへのポインタのみを扱います。</target>
        </trans-unit>
        <trans-unit id="d0e09c593f6493d406d9e4e9dcac2eadda30e574" translate="yes" xml:space="preserve">
          <source>The mutex module within SQLite defines &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; to be an abstract type for a mutex object. The SQLite core never looks at the internal representation of an &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;. It only deals with pointers to the &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; object.</source>
          <target state="translated">SQLite内のmutexモジュールは、&lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;をmutexオブジェクトの抽象型として定義します。SQLiteコアは、&lt;a href=&quot;mutex&quot;&gt;sqlite3_mutexの&lt;/a&gt;内部表現を見ることはありません。&lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt;オブジェクトへのポインタのみを扱います。</target>
        </trans-unit>
        <trans-unit id="2683feab4dd898006f40d9a775532ccca7b7b569" translate="yes" xml:space="preserve">
          <source>The mxFrame value is always greater than or equal to both &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt; and nBackfillAttempted.</source>
          <target state="translated">mxFrameの値は、常に&lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt;とnBackfillAttemptedの両方以上です。</target>
        </trans-unit>
        <trans-unit id="ab3c5c72a969cacdc78a3e4dd0229038bdf0e320" translate="yes" xml:space="preserve">
          <source>The mxPathname field is the maximum length of a file pathname that this VFS can use. SQLite sometimes has to preallocate buffers of this size, so it should be as small as reasonably possible. Some filesystems permit huge pathnames, but in practice pathnames rarely extend beyond 100 bytes or so. You do not have to put the longest pathname that the underlying filesystem can handle here. You only have to put the longest pathname that you want SQLite to be able to handle. A few hundred is a good value in most cases.</source>
          <target state="translated">mxPathname フィールドは、この VFS で使用できるファイルパス名の最大長です。SQLite はこのサイズのバッファを事前に確保しなければならないことがあるので、可能な限り小さくしなければなりません。ファイルシステムによっては巨大なパス名を許可しているものもありますが、実際にはパス名が100バイト程度を超えることはほとんどありません。ここには、基礎となるファイルシステムが扱える最長のパス名を指定する必要はありません。SQLiteが扱えるようにしたい最長のパス名を指定すればよいのです。ほとんどの場合、数百程度が良い値となります。</target>
        </trans-unit>
        <trans-unit id="cb1334872e71aa02626433d46e5f9130af9a0bfd" translate="yes" xml:space="preserve">
          <source>The nArg parameter specifies the number of arguments to the function. A value of 0 indicates that any number of arguments is allowed. The eTextRep parameter specifies what representation text values are expected to be in for arguments to this function. The value of this parameter should be one of the parameters defined above. SQLite version 3 allows multiple implementations of the same function using different text representations. The database engine chooses the function that minimization the number of text conversions required.</source>
          <target state="translated">nArgパラメータは、関数の引数の数を指定します。0の値は、任意の数の引数が許可されていることを示します。eTextRepパラメータは、この関数への引数に期待される表現テキスト値を指定します。このパラメータの値は、上記で定義したパラメータのいずれかでなければなりません。SQLite バージョン 3 では、異なるテキスト表現を使用して同じ関数を複数実装することができます。データベースエンジンは、必要なテキスト変換の数を最小化する関数を選択します。</target>
        </trans-unit>
        <trans-unit id="15067be8341cb3e5ea308646b0092b9f585804c8" translate="yes" xml:space="preserve">
          <source>The nBackfill can only be increased while holding the WAL_CKPT_LOCK. However, nBackfill is changed to zero during a &lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL reset&lt;/a&gt;, and this happens while holding the WAL_WRITE_LOCK.</source>
          <target state="translated">nBackfillは、WAL_CKPT_LOCKを押している間だけ増やすことができます。ただし、nBackfillは&lt;a href=&quot;fileformat2#walreset&quot;&gt;WALリセット&lt;/a&gt;中にゼロに変更され、これはWAL_WRITE_LOCKを保持している間に発生します。</target>
        </trans-unit>
        <trans-unit id="99673f4f335d79523c7b7494142bf07ba1cd84e2" translate="yes" xml:space="preserve">
          <source>The nBackfill number is never greater than &lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt;. When nBackfill equals &lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt;, that means that the WAL content has been completely written back into the database and it is ok to &lt;a href=&quot;fileformat2#walreset&quot;&gt;reset the WAL&lt;/a&gt; if there are no locks held on any of WAL_READ_LOCK(N) for N&amp;gt;0.</source>
          <target state="translated">nBackfill番号がより大きくなることはありません&lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt;。nBackfillが&lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt;と等しい場合は、WALコンテンツがデータベースに完全に書き戻されており、N&amp;gt; 0のWAL_READ_LOCK（N）のいずれかでロックが保持されていない場合は&lt;a href=&quot;fileformat2#walreset&quot;&gt;、WAL&lt;/a&gt;をリセットしても問題ありません。</target>
        </trans-unit>
        <trans-unit id="58aea584e25c7551e85c617c6b8537adc3f19238" translate="yes" xml:space="preserve">
          <source>The name &quot;memsys5&quot; used for the zero-malloc memory allocator implies that there are several additional memory allocators available, and indeed there are. The default memory allocator is &quot;memsys1&quot;. The debugging memory allocator is &quot;memsys2&quot;. Those have already been covered.</source>
          <target state="translated">ゼロマロクメモリアロケータに使用される「memsys5」という名前は、利用可能なメモリアロケータがいくつか追加されていることを暗示していますが、実際にはいくつかあります。デフォルトのメモリアロケータは「memsys1」である。デバッグ用のメモリアロケータは &quot;memsys2&quot; です。これらについてはすでに説明しています。</target>
        </trans-unit>
        <trans-unit id="e00b973d0e23f6d37321209e23fc2917cf32700a" translate="yes" xml:space="preserve">
          <source>The name &quot;sqlite_schema&quot; does not appear anywhere in the file format. That name is just a convention used by the database implementation. Due to historical and operational considerations, the &quot;sqlite_schema&quot; table can also sometimes be called by one of the following aliases:</source>
          <target state="translated">sqlite_schema &quot;という名前はファイルフォーマットのどこにも出てきません。この名前はデータベースの実装で使用されている規約に過ぎません。歴史的、運用上の配慮から、&quot;sqlite_schema &quot;テーブルは、以下のエイリアスのいずれかで呼ばれることもあります。</target>
        </trans-unit>
        <trans-unit id="5db0afbba9901c1e9e8534384d38571355c85857" translate="yes" xml:space="preserve">
          <source>The name for the &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; used to compare values in the index-column.</source>
          <target state="translated">インデックス列の値を比較するために使用される&lt;a href=&quot;datatype3#collation&quot;&gt;照合シーケンス&lt;/a&gt;の名前。</target>
        </trans-unit>
        <trans-unit id="d0a42cf139ce30315511c41a36a93d913d4ae81d" translate="yes" xml:space="preserve">
          <source>The name of a result column is the value of the &quot;AS&quot; clause for that column, if there is an AS clause. If there is no AS clause then the name of the column is unspecified and may change from one release of SQLite to the next.</source>
          <target state="translated">結果カラムの名前は、AS節がある場合はそのカラムの &quot;AS &quot;節の値となります。AS 句がない場合は、カラムの名前は指定されておらず、SQLite のあるリリースから次のリリースへと変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="a57f858acf3d2e5077979e3afa2c8309985a2b90" translate="yes" xml:space="preserve">
          <source>The name of an SQLite database is the name of a file that will contain the database. If the file does not exist, SQLite attempts to create and initialize it. If the file is read-only (due to permission bits or because it is located on read-only media like a CD-ROM) then SQLite opens the database for reading only. The entire SQL database is stored in a single file on the disk. But additional temporary files may be created during the execution of an SQL command in order to store the database rollback journal or temporary and intermediate results of a query.</source>
          <target state="translated">SQLite データベースの名前は、データベースを格納するファイルの名前です。ファイルが存在しない場合、SQLite はファイルの作成と初期化を試みます。ファイルが読み取り専用の場合(パーミッションビットのためか、CD-ROMのような読み取り専用メディアにあるため)、SQLiteはデータベースを読み取り専用に開きます。SQL データベース全体はディスク上の単一のファイルに格納されます。しかし、データベースのロールバックジャーナルやクエリの一時的な結果や中間的な結果を保存するために、SQLコマンドの実行中に追加のテンポラリファイルが作成されることがあります。</target>
        </trans-unit>
        <trans-unit id="2e5f7637f527bcb85ea83184153ee4c57e5bbfca" translate="yes" xml:space="preserve">
          <source>The name of each column in the table.</source>
          <target state="translated">テーブルの各列の名前。</target>
        </trans-unit>
        <trans-unit id="e1e64668404efe0d041f261ba3d958b47753bba4" translate="yes" xml:space="preserve">
          <source>The name of the FTS5 table column that contains the term.</source>
          <target state="translated">用語を含むFTS5テーブル列の名前。</target>
        </trans-unit>
        <trans-unit id="fb2519166ef6466d94c575e04a046d25ae02cbef" translate="yes" xml:space="preserve">
          <source>The name of the collation is a UTF-8 string for sqlite3_create_collation() and sqlite3_create_collation_v2() and a UTF-16 string in native byte order for sqlite3_create_collation16(). Collation names that compare equal according to &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; are considered to be the same name.</source>
          <target state="translated">照合の名前は、sqlite3_create_collat​​ion（）およびsqlite3_create_collat​​ion_v2（）のUTF-8文字列と、sqlite3_create_collat​​ion16（）のネイティブバイトオーダーのUTF-16文字列です。&lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp（）&lt;/a&gt;に従って等しいと比較される照合順序名は、同じ名前と見なされます。</target>
        </trans-unit>
        <trans-unit id="7df8bfa2bb01af5c880a238a6167d3b3a1623f37" translate="yes" xml:space="preserve">
          <source>The name of the collation is a UTF-8 string for sqlite3_create_collation() and sqlite3_create_collation_v2() and a UTF-16 string in native byte order for sqlite3_create_collation16(). Collation names that compare equal according to &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; are considered to be the same name.</source>
          <target state="translated">照合の名前は、sqlite3_create_collat​​ion（）およびsqlite3_create_collat​​ion_v2（）のUTF-8文字列と、sqlite3_create_collat​​ion16（）のネイティブバイトオーダーのUTF-16文字列です。&lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp（）&lt;/a&gt;に従って等しいと比較される照合順序名は、同じ名前と見なされます。</target>
        </trans-unit>
        <trans-unit id="60f9c38a5b1707739850b72dfb67adc25dbc2069" translate="yes" xml:space="preserve">
          <source>The name of the column being indexed, or NULL if the index-column is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the table being indexed or an &lt;a href=&quot;expridx&quot;&gt;expression&lt;/a&gt;.</source>
          <target state="translated">インデックスを付ける列の名前、またはindex-columnがインデックスを付けるテーブルの行&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ID&lt;/a&gt;または&lt;a href=&quot;expridx&quot;&gt;式の&lt;/a&gt;場合はNULL 。</target>
        </trans-unit>
        <trans-unit id="a2c4a68aabf0cd9d6847a72cb797a421605fdb66" translate="yes" xml:space="preserve">
          <source>The name of the column being indexed. This columns is NULL if the column is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; or an &lt;a href=&quot;expridx&quot;&gt;expression&lt;/a&gt;.</source>
          <target state="translated">インデックスを付ける列の名前。列が&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;または&lt;a href=&quot;expridx&quot;&gt;式の&lt;/a&gt;場合、この列はNULLです。</target>
        </trans-unit>
        <trans-unit id="2755fad1da17fab976d4effee601e3a0ced598c2" translate="yes" xml:space="preserve">
          <source>The name of the column that contains the term instance.</source>
          <target state="translated">用語のインスタンスを含む列の名前。</target>
        </trans-unit>
        <trans-unit id="d4c672f643ac02f7fa3683763e45ddf698d1be4b" translate="yes" xml:space="preserve">
          <source>The name of the database is usually just the name of a disk file in which the database is stored. If the name of the database is the special name &quot;&lt;a href=&quot;inmemorydb&quot;&gt;:memory:&lt;/a&gt;&quot; then a new database is created in memory. If the name of the database is an empty string, then the database is created in an empty file that is automatically deleted when the database connection closes. &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; can be used if the &quot;&lt;b&gt;-uri yes&lt;/b&gt;&quot; option is supplied on the &lt;b&gt;sqlite3&lt;/b&gt; command.</source>
          <target state="translated">データベースの名前は通常、データベースが格納されているディスクファイルの名前です。データベースの名前が特別な名前 &quot; &lt;a href=&quot;inmemorydb&quot;&gt;：memory：&lt;/a&gt; &quot;の場合、新しいデータベースがメモリ内に作成されます。データベースの名前が空の文字列の場合、データベースは空のファイルに作成され、データベース接続が閉じたときに自動的に削除されます。&lt;b&gt;sqlite3&lt;/b&gt;コマンドで&quot; &lt;b&gt;-uri yes&lt;/b&gt; &quot;オプションが指定されている場合、&lt;a href=&quot;uri&quot;&gt;URIファイル名&lt;/a&gt;を使用できます。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="638ad72e8f8e6b978d1b5c7a5434bac446aa668c" translate="yes" xml:space="preserve">
          <source>The name of the database on which the transaction was committed</source>
          <target state="translated">トランザクションがコミットされたデータベースの名前</target>
        </trans-unit>
        <trans-unit id="b53c39aeaa16a31f4a835cb5ee0c4ef2cb1c4ca7" translate="yes" xml:space="preserve">
          <source>The name of the database table,</source>
          <target state="translated">データベーステーブルの名前です。</target>
        </trans-unit>
        <trans-unit id="1389d8d4ecdcdbedac7a4549e6a07ae7ad0ad26c" translate="yes" xml:space="preserve">
          <source>The name of the database which is being changed</source>
          <target state="translated">変更されるデータベースの名前</target>
        </trans-unit>
        <trans-unit id="fc047e5a2c9d6a845176aac031ed03d6a1b50ee2" translate="yes" xml:space="preserve">
          <source>The name of the desired tokenizer should be substituted in place of 'porter' in the example, of course. If the tokenizer requires one or more arguments, they should be separated by commas in the fts3tokenize declaration (even though they are separated by spaces in declarations of regular fts4 tables). The following creates fts4 and fts3tokenize tables that use the same tokenizer:</source>
          <target state="translated">もちろん、この例では 'PORTER' の代わりに、目的のトークナイザーの名前を代入する必要があります。トークン化器が1つ以上の引数を必要とする場合は、fts3tokenize宣言ではカンマで区切らなければなりません(通常のfts4テーブルの宣言ではスペースで区切られていますが)。以下は、同じトークナイザーを使用する fts4 と fts3tokenize テーブルを作成します。</target>
        </trans-unit>
        <trans-unit id="9a63a9136665984fc122cf635a36ad0166ead67d" translate="yes" xml:space="preserve">
          <source>The name of the index.</source>
          <target state="translated">インデックスの名前。</target>
        </trans-unit>
        <trans-unit id="c2412b63f15e8dfde7222fa76ad9e5504c06aea1" translate="yes" xml:space="preserve">
          <source>The name of the new table.</source>
          <target state="translated">新しいテーブルの名前。</target>
        </trans-unit>
        <trans-unit id="a12d264e140fa64a7adf3172f5ec27d60bbcedb0" translate="yes" xml:space="preserve">
          <source>The name of the result column is a combination of the source table and source column name: TABLE.COLUMN</source>
          <target state="translated">結果カラムの名前は、ソーステーブルとソースカラム名を組み合わせたものです:TABLE.COLUMN</target>
        </trans-unit>
        <trans-unit id="85777de7d38bf8fc5dfa8258c31af44f8a1c7698" translate="yes" xml:space="preserve">
          <source>The name of the table contains one or more &quot;_&quot; characters.</source>
          <target state="translated">テーブル名には、1つ以上の&quot;_&quot;文字が含まれています。</target>
        </trans-unit>
        <trans-unit id="d14fb34ff4c810e0436eba6520cbeda0158f9e95" translate="yes" xml:space="preserve">
          <source>The name of the table data is read from.</source>
          <target state="translated">読み込んだテーブルデータの名前です。</target>
        </trans-unit>
        <trans-unit id="a43b536a14c1d7b3d8b50ac0e9b44a83e9c467f9" translate="yes" xml:space="preserve">
          <source>The name of the table in which the xColumnSize values are stored (unless columnsize=0 is specified) is &quot;&amp;lt;name&amp;gt;_docsize&quot;, where &amp;lt;name&amp;gt; is the name of the FTS5 table itself. The &lt;a href=&quot;https://www.sqlite.org/download.html&quot;&gt;sqlite3_analyzer&lt;/a&gt; tool may be used on an existing database in order to determine how much space might be saved by recreating an FTS5 table using columnsize=0.</source>
          <target state="translated">xColumnSize値が格納されているテーブルの名前（columnsize = 0が指定されていない場合）は &quot;&amp;lt;name&amp;gt; _docsize&quot;です。ここで、&amp;lt;name&amp;gt;はFTS5テーブル自体の名前です。&lt;a href=&quot;https://www.sqlite.org/download.html&quot;&gt;sqlite3_analyzerの&lt;/a&gt;ツールは、ColumnSizeが= 0を使用してFTS5テーブルを再作成することによって保存される可能性がありますどのくらいのスペースを決定するために、既存のデータベースで使用することができます。</target>
        </trans-unit>
        <trans-unit id="ba455f33d978f1db1e5e1561024b5ab7e0845678" translate="yes" xml:space="preserve">
          <source>The name of the table or index that is implemented by the btree of the current row</source>
          <target state="translated">現在の行の btree で実装されているテーブルまたはインデックスの名前。</target>
        </trans-unit>
        <trans-unit id="b9dba3fb9b44494b1bade858ebafe1459aa85475" translate="yes" xml:space="preserve">
          <source>The name of the table to be modified in an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, or &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statement must be an unqualified table name. In other words, one must use just &quot;</source>
          <target state="translated">&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;、&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;、または&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;ステートメントで変更されるテーブルの名前は、修飾されていないテーブル名でなければなりません。つまり、「</target>
        </trans-unit>
        <trans-unit id="6e32ef9d959d1305ba25656ee3bbcec3b526eef2" translate="yes" xml:space="preserve">
          <source>The name that occurs after the AS keyword is the name of the database used internally by SQLite. The schema-names 'main' and 'temp' refer to the main database and the database used for temporary tables. The main and temp databases cannot be attached or detached.</source>
          <target state="translated">AS キーワードの後に来る名前は、SQLite が内部的に使用するデータベースの名前です。スキーマ名「main」と「temp」は、メイン・データベースと一時テーブルに使用されるデータベースを参照します。main データベースと temp データベースは、アタッチしたり、切り離したりすることはできません。</target>
        </trans-unit>
        <trans-unit id="c7f1793be68e4540903171531d569a4a7be0fbfa" translate="yes" xml:space="preserve">
          <source>The names and numeric values for existing result codes are fixed and unchanging. However, new result codes, and especially new extended result codes, might appear in future releases of SQLite.</source>
          <target state="translated">既存の結果コードの名前と数値は固定されており、変更はありません。しかし、新しい結果コード、特に新しい拡張された結果コードは、将来のSQLiteのリリースで現れるかもしれません。</target>
        </trans-unit>
        <trans-unit id="6c186656572f2bf1670bbd5a3b99aeadd51bedda" translate="yes" xml:space="preserve">
          <source>The names of the columns are contained in first</source>
          <target state="translated">カラムの名前は、最初の</target>
        </trans-unit>
        <trans-unit id="6e42a281800acf1a1a711bf3baf9388c4ecfa00b" translate="yes" xml:space="preserve">
          <source>The names returned are the original un-aliased names of the database, table, and column.</source>
          <target state="translated">返される名前は、データベース、テーブル、およびカラムの元のエイリアスされていない名前です。</target>
        </trans-unit>
        <trans-unit id="9d972c129d1db380a40044755e84ee7d9ba4bda3" translate="yes" xml:space="preserve">
          <source>The new &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface allows an application to customize the behavior of SQLite at run-time. Customizations possible using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; include the following:</source>
          <target state="translated">新しい&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;インターフェイスにより、アプリケーションは実行時にSQLiteの動作をカスタマイズできます。&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;を使用して可能なカスタマイズは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="3df658c177f1eac56b80fa5f85864ebd817426dc" translate="yes" xml:space="preserve">
          <source>The new &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status()&lt;/a&gt; interface allows an application to query the performance status of SQLite at runtime.</source>
          <target state="translated">新しい&lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status（）&lt;/a&gt;インターフェイスにより、アプリケーションは実行時にSQLiteのパフォーマンスステータスをクエリできます。</target>
        </trans-unit>
        <trans-unit id="a8d3b04d8482aa6bd5d923ab36f6fdfe7a6ac1b9" translate="yes" xml:space="preserve">
          <source>The new API for SQLite 3.0 contains routines that accept text as both UTF-8 and UTF-16 in the native byte order of the host machine. Each database file manages text as either UTF-8, UTF-16BE (big-endian), or UTF-16LE (little-endian). Internally and in the disk file, the same text representation is used everywhere. If the text representation specified by the database file (in the file header) does not match the text representation required by the interface routines, then text is converted on-the-fly. Constantly converting text from one representation to another can be computationally expensive, so it is suggested that programmers choose a single representation and stick with it throughout their application.</source>
          <target state="translated">SQLite 3.0 の新しい API には、ホストマシンのネイティブバイト順でテキストを UTF-8 と UTF-16 の両方で受け付けるルーチンが含まれています。各データベースファイルは、テキストを UTF-8、UTF-16BE(ビッグエンディアン)、UTF-16LE(リトルエンディアン)のいずれかで管理します。内部的にもディスクファイル内でも、どこでも同じテキスト表現が使用されます。データベースファイル(ファイルヘッダ内)で指定されたテキスト表現が、インターフェイスルーチンで必要とされるテキスト表現と一致しない場合、テキストはその場で変換されます。常にテキストをある表現から別の表現に変換するのは計算コストがかかりますので、プログラマーは一つの表現を選択して、アプリケーション全体を通してそれを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="30af4368149bbc60ce20946b58b7cfd9adb8ff97" translate="yes" xml:space="preserve">
          <source>The new OS interface for SQLite is built around an object named &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;. The &quot;vfs&quot; stands for &quot;Virtual File System&quot;. The sqlite3_vfs object is basically a structure containing pointers to functions that implement the primitive disk I/O operations that SQLite needs to perform in order to read and write databases. In this article, we will often refer to an sqlite3_vfs objects as a &quot;VFS&quot;.</source>
          <target state="translated">SQLiteの新しいOSインターフェイスは、&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;という名前のオブジェクトを中心に構築されています。「vfs」は「仮想ファイルシステム」の略です。sqlite3_vfsオブジェクトは基本的に、データベースの読み取りと書き込みを行うためにSQLiteが実行する必要があるプリミティブディスクI / O操作を実装する関数へのポインターを含む構造です。この記事では、sqlite3_vfsオブジェクトを「VFS」と呼ぶことがよくあります。</target>
        </trans-unit>
        <trans-unit id="6c9ac7112282c02c3ac370e4792bfc347f1711f1" translate="yes" xml:space="preserve">
          <source>The new change is ignored. This case does not occur if the new changeset was recorded immediately after the changesets already added to the changegroup.</source>
          <target state="translated">新しい変更は無視されます。このケースは、既に changegroup に追加されたチェンジセットの直後に新しいチェンジセットが記録された場合には発生しません。</target>
        </trans-unit>
        <trans-unit id="7b39e9d3e42d3852cda66bb7e7297a2f31d0e706" translate="yes" xml:space="preserve">
          <source>The new database connection will use the &quot;multi-thread&quot; &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt;. This means that separate threads are allowed to use SQLite at the same time, as long as each thread is using a different &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">新しいデータベース接続は、「マルチスレッド」&lt;a href=&quot;../threadsafe&quot;&gt;スレッドモード&lt;/a&gt;を使用します。これは、各スレッドが異なる&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;を使用している限り、別々のスレッドが同時にSQLiteを使用できることを意味します。</target>
        </trans-unit>
        <trans-unit id="67ff5fb06e02cb095d4456f9e428328e41689b42" translate="yes" xml:space="preserve">
          <source>The new database connection will use the &quot;multi-thread&quot; &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt;. This means that separate threads are allowed to use SQLite at the same time, as long as each thread is using a different &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">新しいデータベース接続は、「マルチスレッド」&lt;a href=&quot;threadsafe&quot;&gt;スレッドモード&lt;/a&gt;を使用します。これは、各スレッドが異なる&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;を使用している限り、別々のスレッドが同時にSQLiteを使用できることを意味します。</target>
        </trans-unit>
        <trans-unit id="2ed188f9846a7395326bff47f2223ddc25ac3eab" translate="yes" xml:space="preserve">
          <source>The new database connection will use the &quot;serialized&quot; &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt;. This means the multiple threads can safely attempt to use the same database connection at the same time. (Mutexes will block any actual concurrency, but in this mode there is no harm in trying.)</source>
          <target state="translated">新しいデータベース接続は、「シリアル化された」&lt;a href=&quot;../threadsafe&quot;&gt;スレッドモード&lt;/a&gt;を使用します。これは、複数のスレッドが同時に同じデータベース接続を安全に使用できることを意味します。（ミューテックスは実際の同時実行をブロックしますが、このモードでは試行しても害はありません。）</target>
        </trans-unit>
        <trans-unit id="f2075b8f3b4c50de265f00054b0d87b23e094598" translate="yes" xml:space="preserve">
          <source>The new database connection will use the &quot;serialized&quot; &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt;. This means the multiple threads can safely attempt to use the same database connection at the same time. (Mutexes will block any actual concurrency, but in this mode there is no harm in trying.)</source>
          <target state="translated">新しいデータベース接続は、「シリアル化された」&lt;a href=&quot;threadsafe&quot;&gt;スレッドモード&lt;/a&gt;を使用します。これは、複数のスレッドが同時に同じデータベース接続を安全に使用できることを意味します。（ミューテックスは実際の同時実行をブロックしますが、このモードでは試行しても害はありません。）</target>
        </trans-unit>
        <trans-unit id="81ae31ac06c9efe8e8edfec9e13527250faad45f" translate="yes" xml:space="preserve">
          <source>The new database file format uses B+trees for tables. In a B+tree, all data is stored in the leaves of the tree instead of in both the leaves and the intermediate branch nodes. The use of B+trees for tables allows for better scalability and the storage of larger data fields without the use of overflow pages. Traditional B-trees are still used for indices.</source>
          <target state="translated">新しいデータベースファイルフォーマットでは、テーブルにB+木を使用します。B+木では、すべてのデータは、葉と中間枝ノードの両方に格納されるのではなく、木の葉に格納されます。テーブルにB+木を使用することで、スケーラビリティが向上し、オーバーフローページを使用せずに大きなデータフィールドを保存することができます。従来のB木は、インデックスには今でも使用されています。</target>
        </trans-unit>
        <trans-unit id="31e91eb6ebd1ae009dff2061b0ed5da69f5f04a8" translate="yes" xml:space="preserve">
          <source>The new file format also supports variable pages sizes between 512 and 65536 bytes. The size of a page is stored in the file header so the same library can read databases with different pages sizes, in theory, though this feature has not yet been implemented in practice.</source>
          <target state="translated">新しいファイルフォーマットでは、512バイトから65536バイトまでの可変ページサイズもサポートしています。ページのサイズはファイルヘッダに格納されるので、理論的には、この機能は実際にはまだ実装されていませんが、同じライブラリが異なるページサイズのデータベースを読むことができます。</target>
        </trans-unit>
        <trans-unit id="b7b98e36d84deeda55906998dc0425a8e896c821" translate="yes" xml:space="preserve">
          <source>The new file format omits unused fields from its disk images. For example, indices use only the key part of a B-tree record and not the data. So for indices, the field that records the length of the data is omitted. Integer values such as the length of key and data are stored using a variable-length encoding so that only one or two bytes are required to store the most common cases but up to 64-bits of information can be encoded if needed. Integer and floating point data is stored on the disk in binary rather than being converted into ASCII as in SQLite version 2.8. These changes taken together result in database files that are typically 25% to 35% smaller than the equivalent files in SQLite version 2.8.</source>
          <target state="translated">新しいファイルフォーマットでは、ディスクイメージから未使用のフィールドが省略されます。例えば、インデックスはB-treeレコードのキー部分のみを使用し、データは使用しません。そのため、インデックスの場合、データの長さを記録するフィールドは省略されます。キーの長さやデータの長さなどの整数値は可変長エンコーディングを用いて格納されるため、最も一般的なケースでは1バイトか2バイトで済みますが、必要に応じて64ビットまでの情報をエンコーディングして格納することができます。整数と浮動小数点データは、SQLite バージョン 2.8 のように ASCII に変換されるのではなく、バイナリでディスクに格納されます。これらの変更を合わせると、データベースファイルは SQLite バージョン 2.8 の同等のファイルよりも通常 25% から 35% 小さくなります。</target>
        </trans-unit>
        <trans-unit id="5a8ddfc73fc040315222214bdfe8a3558fe0da52" translate="yes" xml:space="preserve">
          <source>The new interface uses three separate functions to replace the single &lt;b&gt;sqlite_exec&lt;/b&gt; function.</source>
          <target state="translated">新しいインターフェースは、3つの別個の関数を使用して、単一の&lt;b&gt;sqlite_exec&lt;/b&gt;関数を置き換えます。</target>
        </trans-unit>
        <trans-unit id="601cb56433c850ed70120e223ec644602fc957a5" translate="yes" xml:space="preserve">
          <source>The new object is configured with the rebase buffer obtained from sqlite3changeset_apply_v2() by calling sqlite3rebaser_configure(). If the local changeset is to be rebased against multiple remote changesets, then sqlite3rebaser_configure() should be called multiple times, in the same order that the multiple sqlite3changeset_apply_v2() calls were made.</source>
          <target state="translated">新しいオブジェクトは、sqlite3rebaser_configure()を呼び出すことで、sqlite3changeset_apply_v2()から取得したリベースバッファで設定されます。ローカルのチェンジセットが複数のリモートのチェンジセットに対してリベースされる場合、sqlite3rebaser_configure()は、複数のsqlite3changeset_apply_v2()の呼び出しが行われたのと同じ順番で複数回呼び出されるべきです。</target>
        </trans-unit>
        <trans-unit id="a80319826820a0baa113ed82a7da25195888339a" translate="yes" xml:space="preserve">
          <source>The new row must meet the same criteria as for &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; - it must exist and there must be either a blob or text value stored in the nominated column. If the new row is not present in the table, or if it does not contain a blob or text value, or if another error occurs, an SQLite error code is returned and the blob handle is considered aborted. All subsequent calls to &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; on an aborted blob handle immediately return SQLITE_ABORT. Calling &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; on an aborted blob handle always returns zero.</source>
          <target state="translated">新しい行は、&lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open（）の&lt;/a&gt;場合と同じ基準を満たす必要があります。この行は存在している必要があり、指定された列にBLOBまたはテキスト値が格納されている必要があります。新しい行がテーブルに存在しない場合、またはBLOBやテキスト値が含まれていない場合、または別のエラーが発生した場合、SQLiteエラーコードが返され、BLOBハンドルは中止されたと見なされます。後続のすべての呼び出し&lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read（） &lt;/a&gt;、&lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;または&lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen（）&lt;/a&gt;中断されたブロブハンドルには、直ちにSQLITE_ABORTを返します。中止されたblobハンドルで&lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;を呼び出すと、常にゼロが返されます。</target>
        </trans-unit>
        <trans-unit id="1fc9db87ef5146974ffc63aaf19ef4d76ed16ccc" translate="yes" xml:space="preserve">
          <source>The new row must meet the same criteria as for &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; - it must exist and there must be either a blob or text value stored in the nominated column. If the new row is not present in the table, or if it does not contain a blob or text value, or if another error occurs, an SQLite error code is returned and the blob handle is considered aborted. All subsequent calls to &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; or &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; on an aborted blob handle immediately return SQLITE_ABORT. Calling &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; on an aborted blob handle always returns zero.</source>
          <target state="translated">新しい行は、&lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open（）の&lt;/a&gt;場合と同じ基準を満たす必要があります。この行は存在している必要があり、指定された列にBLOBまたはテキスト値が格納されている必要があります。新しい行がテーブルに存在しない場合、またはBLOBやテキスト値が含まれていない場合、または別のエラーが発生した場合、SQLiteエラーコードが返され、BLOBハンドルは中止されたと見なされます。後続のすべての呼び出し&lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read（） &lt;/a&gt;、&lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;または&lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen（）&lt;/a&gt;中断されたブロブハンドルには、直ちにSQLITE_ABORTを返します。中止されたblobハンドルで&lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;を呼び出すと、常にゼロが返されます。</target>
        </trans-unit>
        <trans-unit id="477dc8c1b42a8f1f1f9e215976276669879cbe40" translate="yes" xml:space="preserve">
          <source>The new values for each modified field of the row, and</source>
          <target state="translated">行の各変更されたフィールドの新しい値と</target>
        </trans-unit>
        <trans-unit id="9ca11824ed5a21754d9f34df6fca6bca218bd35f" translate="yes" xml:space="preserve">
          <source>The new window definition must not include a PARTITION BY clause. The PARTITION BY clause, if there is one, must be supplied by the base window specification.</source>
          <target state="translated">新しいウィンドウ定義には、PARTITION BY句を含んではならない。PARTITION BY句がある場合は、基本ウィンドウ仕様で与えられなければなりません。</target>
        </trans-unit>
        <trans-unit id="f3a9a1d6f9268d0f1362c9fb457875a7fb250370" translate="yes" xml:space="preserve">
          <source>The newer &quot;.eqp trace&quot; command does everything that &quot;.eqp full&quot; does and also turns on &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;VDBE tracing&lt;/a&gt;.</source>
          <target state="translated">新しい「.eqp trace」コマンドは、「。eqp full」が実行するすべてのことを実行し、また&lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;VDBEトレース&lt;/a&gt;をオンにします。</target>
        </trans-unit>
        <trans-unit id="fd8ed5a57b50230eec8d4ec2e3e5c1e149c55cc8" translate="yes" xml:space="preserve">
          <source>The newer xQueryFunc callback receives more information from the r-tree query engine on each call, and it sends more information back to the query engine before it returns. To help keep the interface manageable, the xQueryFunc callback sends and receives information from the query engine as fields in the sqlite3_rtree_query_info structure:</source>
          <target state="translated">新しいxQueryFuncコールバックは、呼び出しごとにr-treeクエリエンジンからより多くの情報を受け取り、返す前にクエリエンジンに情報を送り返します。インターフェイスを管理しやすくするために、xQueryFuncコールバックはクエリエンジンからの情報をsqlite3_rtree_query_info構造体のフィールドとして送受信します。</target>
        </trans-unit>
        <trans-unit id="03223a32a94905afaa2e599c575bdc7c618a776e" translate="yes" xml:space="preserve">
          <source>The next &quot;.mode&quot; command will reset the &quot;.separator&quot; back to its default. So you will need repeat the &quot;.separator&quot; command whenever you change modes if you want to continue using a non-standard separator.</source>
          <target state="translated">次の &quot;.mode&quot; コマンドは &quot;.separator&quot; をデフォルトに戻します。そのため、非標準のセパレータを使い続けたい場合は、モードを変更するたびに &quot;.separator&quot; コマンドを繰り返す必要があります。</target>
        </trans-unit>
        <trans-unit id="9bff369a4e5022b3604d755cd856a8cb8591c715" translate="yes" xml:space="preserve">
          <source>The next block contains an example rank function that uses matchinfo data implemented in C. Instead of a single weight, it allows a weight to be externally assigned to each column of each document. It may be registered with SQLite like any other user function using &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function&lt;/a&gt;.</source>
          <target state="translated">次のブロックには、Cで実装されたmatchinfoデータを使用するサンプルのランク関数が含まれています。単一の重みの代わりに、各ドキュメントの各列に外部から重みを割り当てることができます。&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function&lt;/a&gt;を使用して、他のユーザー関数と同様にSQLiteに登録できます。</target>
        </trans-unit>
        <trans-unit id="5e308fd7498285ea1f61e243e9d3f001701f643f" translate="yes" xml:space="preserve">
          <source>The next block of SQL enhances the query with solutions to two other problems that may arise in developing search applications using FTS:</source>
          <target state="translated">SQLの次のブロックでは、FTSを使用した検索アプリケーションを開発する際に発生する可能性のある他の2つの問題を解決することで、クエリを強化しています。</target>
        </trans-unit>
        <trans-unit id="acd253e5152192f86ab636fd16bb5196034aa10b" translate="yes" xml:space="preserve">
          <source>The next chart compares SQLite database updates in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; against raw direct-to-disk overwrites of separate files on disk. The &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; setting is NORMAL. All database writes are in a single transaction. The timer for the database writes is stopped after the transaction commits, but before a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; is run. Note that the SQLite writes, unlike the direct-to-disk writes, are &lt;a href=&quot;transactional&quot;&gt;transactional&lt;/a&gt; and &lt;a href=&quot;transactional&quot;&gt;power-safe&lt;/a&gt;, though because the synchronous setting is NORMAL instead of FULL, the transactions are not durable.</source>
          <target state="translated">次のグラフは、&lt;a href=&quot;wal&quot;&gt;WALモード&lt;/a&gt;でのSQLiteデータベースの更新と、ディスク上の個別のファイルの直接ディスクへの直接の上書きを比較しています。&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同期&lt;/a&gt;設定はNORMALです。すべてのデータベース書き込みは、単一のトランザクションで行われます。データベース書き込みのタイマーは、トランザクションがコミットされた後、&lt;a href=&quot;wal#ckpt&quot;&gt;チェックポイント&lt;/a&gt;が実行される前に停止されます。 SQLiteへの書き込みは、ディスクへの直接書き込みとは異なり、&lt;a href=&quot;transactional&quot;&gt;トランザクションに対応&lt;/a&gt;していて&lt;a href=&quot;transactional&quot;&gt;電源が安全&lt;/a&gt;ですが、同期設定がFULLではなくNORMALであるため、トランザクションは永続的ではありません。</target>
        </trans-unit>
        <trans-unit id="0aae132ea98563594c1fa5eb1b5277ade35e9e0f" translate="yes" xml:space="preserve">
          <source>The next chart shows the performance of SQLite versus direct-to-disk when transactions are disabled (&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=OFF&lt;/a&gt;) and &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; is set to OFF. These settings put SQLite on an equal footing with direct-to-disk writes, which is to say they make the data prone to corruption due to system crashes and power failures.</source>
          <target state="translated">次のグラフは、トランザクションが無効で（&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = OFF&lt;/a&gt;）、&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同期&lt;/a&gt;がOFFに設定されている場合のSQLiteとディスクへの直接のパフォーマンスを示しています。これらの設定により、SQLiteはディスクへの直接書き込みと同等の立場に置かれます。つまり、システムクラッシュや電源障害が原因でデータが破損しやすくなります。</target>
        </trans-unit>
        <trans-unit id="a36fc6db6d371099515d1fcc0740a7c0b2437b14" translate="yes" xml:space="preserve">
          <source>The next example demonstrates lag(), lead(), first_value(), last_value() and nth_value(). The frame-spec is ignored by both lag() and lead(), but respected by first_value(), last_value() and nth_value().</source>
          <target state="translated">次の例では、 lag()・ lead()・ first_value()・ last_value()・ nth_value()の例を示しています。フレーム仕様は lag()と lead()の両方で無視されますが、 first_value()と last_value()と nth_value()では尊重されます。</target>
        </trans-unit>
        <trans-unit id="edb143346c38b864be88a8c33e46d2997195abb0" translate="yes" xml:space="preserve">
          <source>The next example uses two common table expressions in a single WITH clause. The following table records a family tree:</source>
          <target state="translated">次の例では、単一のWITH句で2つの一般的なテーブル式を使用しています。次のテーブルは家系図を記録しています。</target>
        </trans-unit>
        <trans-unit id="1e6dfc599524aaa9c044c52fd99b0a8ed104813e" translate="yes" xml:space="preserve">
          <source>The next interface routine to SQLite is a convenience function used to test whether or not a string forms a complete SQL statement. If the &lt;b&gt;sqlite_complete&lt;/b&gt; function returns true when its input is a string, then the argument forms a complete SQL statement. There are no guarantees that the syntax of that statement is correct, but we at least know the statement is complete. If &lt;b&gt;sqlite_complete&lt;/b&gt; returns false, then more text is required to complete the SQL statement.</source>
          <target state="translated">SQLiteへの次のインターフェースルーチンは、文字列が完全なSQLステートメントを形成するかどうかをテストするために使用される便利な関数です。場合&lt;b&gt;sqlite_complete&lt;/b&gt;その入力が文字列であるときに関数がtrueを返し、引数は、完全なSQL文を形成しています。そのステートメントの構文が正しいことを保証するものではありませんが、少なくともステートメントが完全であることはわかっています。&lt;b&gt;sqlite_complete&lt;/b&gt;がfalseを返す場合、SQLステートメントを完了するにはさらにテキストが必要です。</target>
        </trans-unit>
        <trans-unit id="c0fe3b1ebf5cdcafa2a519a22d91d50cf98645d3" translate="yes" xml:space="preserve">
          <source>The next step in a multi-file commit is the creation of a &quot;master journal&quot; file. The name of the master journal file is the same name as the original database filename (the database that was opened using the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; interface, not one of the &lt;a href=&quot;lang_attach&quot;&gt;ATTACHed&lt;/a&gt; auxiliary databases) with the text &quot;&lt;b&gt;-mj&lt;/b&gt;</source>
          <target state="translated">マルチファイルコミットの次のステップは、「マスタージャーナル」ファイルの作成です。マスタージャーナルファイルの名前は、元のデータベースファイル名（&lt;a href=&quot;lang_attach&quot;&gt;アタッチされた&lt;/a&gt;補助データベースの1つではなく、&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;インターフェイスを使用して開かれたデータベース）と同じ名前で、テキスト &quot; &lt;b&gt;-mj&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0cd61740e94e70cec25ceb66f34763d5696dff28" translate="yes" xml:space="preserve">
          <source>The next step in a multi-file commit is the creation of a &quot;super-journal&quot; file. The name of the super-journal file is the same name as the original database filename (the database that was opened using the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; interface, not one of the &lt;a href=&quot;lang_attach&quot;&gt;ATTACHed&lt;/a&gt; auxiliary databases) with the text &quot;&lt;b&gt;-mj&lt;/b&gt;</source>
          <target state="translated">マルチファイルコミットの次のステップは、「スーパージャーナル」ファイルの作成です。スーパージャーナルファイルの名前は、元のデータベースファイル名（&lt;a href=&quot;lang_attach&quot;&gt;ATTACHされた&lt;/a&gt;補助データベースの1つではなく、&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;インターフェイスを使用して開かれたデータベース）と同じ名前で、テキストは「&lt;b&gt;-mj&lt;/b&gt;」&lt;b&gt;です。&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3da089b39e9e2681938268cb3d32b250cde300bb" translate="yes" xml:space="preserve">
          <source>The next step is to delete the master journal file. This is the point where the multi-file transaction commits. This step corresponds to &lt;a href=&quot;#section_3_11&quot;&gt;step 3.11&lt;/a&gt; in the single-file commit scenario where the rollback journal is deleted.</source>
          <target state="translated">次のステップは、マスタージャーナルファイルを削除することです。これは、マルチファイルトランザクションがコミットするポイントです。このステップは、ロールバックジャーナルが削除される単一ファイルコミットシナリオの&lt;a href=&quot;#section_3_11&quot;&gt;ステップ3.11&lt;/a&gt;に対応します。</target>
        </trans-unit>
        <trans-unit id="8eca8d6f0301fd62dd1a522a60a7179d3923b8b3" translate="yes" xml:space="preserve">
          <source>The next step is to delete the super-journal file. This is the point where the multi-file transaction commits. This step corresponds to &lt;a href=&quot;#section_3_11&quot;&gt;step 3.11&lt;/a&gt; in the single-file commit scenario where the rollback journal is deleted.</source>
          <target state="translated">次のステップは、スーパージャーナルファイルを削除することです。これは、マルチファイルトランザクションがコミットするポイントです。このステップは、ロールバックジャーナルが削除される単一ファイルコミットシナリオの&lt;a href=&quot;#section_3_11&quot;&gt;ステップ3.11&lt;/a&gt;に対応します。</target>
        </trans-unit>
        <trans-unit id="0f8a36a95656f30638f07c12cb9da14410f8f263" translate="yes" xml:space="preserve">
          <source>The next step is to flush the content of the rollback journal file to nonvolatile storage. As we will see later, this is a critical step in insuring that the database can survive an unexpected power loss. This step also takes a lot of time, since writing to nonvolatile storage is normally a slow operation.</source>
          <target state="translated">次のステップは、ロールバック・ジャーナル・ファイルの内容を不揮発性ストレージにフラッシュすることです。後述するように、これはデータベースが予期せぬ停電にも耐えられるようにするための重要なステップです。不揮発性ストレージへの書き込みは通常は遅い操作なので、このステップにも多くの時間がかかります。</target>
        </trans-unit>
        <trans-unit id="2d76b37ca4cb1c2c8f635e9aaada12e5312b553c" translate="yes" xml:space="preserve">
          <source>The next step is to move the changes in the public branch over into the private branch. In other words, we want to create circle (5) in the diagram above. Begin by changing to the private branch using &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot;. Then type this command:</source>
          <target state="translated">次のステップは、パブリックブランチの変更をプライベートブランチに移動することです。つまり、上の図の円（5）を作成します。「 &lt;code&gt;fossil update private&lt;/code&gt; 」を使用してプライベートブランチに変更することから始めます。次に、次のコマンドを入力します。</target>
        </trans-unit>
        <trans-unit id="7e4259fddae0dc878cdf5dde573b08c0dee99991" translate="yes" xml:space="preserve">
          <source>The next step is to record the full pathname of the master journal file in the header of every rollback journal. Space to hold the master journal filename was reserved at the beginning of each rollback journal as the rollback journals were created.</source>
          <target state="translated">次のステップは、各ロールバックジャーナルのヘッダにマスタージャーナルファイルのフルパス名を記録することです。マスタージャーナルファイル名を保持するスペースは、ロールバックジャーナルの作成時に各ロールバックジャーナルの先頭に確保しました。</target>
        </trans-unit>
        <trans-unit id="75cf4af1420a93693d3db893fcca12c3f40102cd" translate="yes" xml:space="preserve">
          <source>The next step is to record the full pathname of the super-journal file in the header of every rollback journal. Space to hold the super-journal filename was reserved at the beginning of each rollback journal as the rollback journals were created.</source>
          <target state="translated">次に、各ロールバックジャーナルのヘッダにスーパージャーナルファイルのフルパス名を記録します。スーパージャーナルファイル名を保持するスペースは、ロールバックジャーナルの作成時に各ロールバックジャーナルの先頭に確保されていました。</target>
        </trans-unit>
        <trans-unit id="10799d0f2a52185a80b7f98059fdd7fef8ba0412" translate="yes" xml:space="preserve">
          <source>The next three bytes in the header record the number of vertexes in the polygon as a big-endian integer. Thus there is an upper bound of about 16 million vertexes per polygon.</source>
          <target state="translated">ヘッダの次の3バイトは、ポリゴン内の頂点数をビッグエンディアン整数として記録します。したがって、ポリゴンあたりの頂点数の上限は約1600万個です。</target>
        </trans-unit>
        <trans-unit id="a4532dd188d90322b7de7cb35c04fd5fcf2e6593" translate="yes" xml:space="preserve">
          <source>The next use of the &lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt; or &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; or &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; instruction for P1 will refer to the first entry in the database table or index. If the table or index is empty, jump immediately to P2. If the table or index is not empty, fall through to the following instruction.</source>
          <target state="translated">&lt;a href=&quot;opcode#Next&quot;&gt;次に&lt;/a&gt; P1 の&lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt;または&lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt;またはNext命令を使用すると、データベーステーブルまたはインデックスの最初のエントリが参照されます。テーブルまたはインデックスが空の場合は、すぐにP2にジャンプします。テーブルまたはインデックスが空でない場合は、次の手順に進んでください。</target>
        </trans-unit>
        <trans-unit id="db275badbcaa5bbb5c1ecd5830883705763b811b" translate="yes" xml:space="preserve">
          <source>The next use of the &lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt; or &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; or &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; instruction for P1 will refer to the last entry in the database table or index. If the table or index is empty and P2&amp;gt;0, then jump immediately to P2. If P2 is 0 or if the table or index is not empty, fall through to the following instruction.</source>
          <target state="translated">次にP1 の&lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt;、&lt;a href=&quot;opcode#Column&quot;&gt;Column、&lt;/a&gt;または&lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt;命令を使用すると、データベーステーブルまたはインデックスの最後のエントリが参照されます。テーブルまたはインデックスが空で、P2&amp;gt; 0の場合、すぐにP2にジャンプします。 P2が0の場合、またはテーブルまたはインデックスが空でない場合は、次の手順に進んでください。</target>
        </trans-unit>
        <trans-unit id="971bdad47f863dca0857c6853816fdb36613779f" translate="yes" xml:space="preserve">
          <source>The no-op memory allocator is not useful by itself. It exists only as a placeholder so that SQLite has a memory allocator to link against on systems that may not have malloc(), free(), or realloc() in their standard library. An application that is compiled with &lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC&lt;/a&gt; will need to use &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; together with &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; or &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt; to specify a new alternative memory allocator before beginning to use SQLite.</source>
          <target state="translated">no-opメモリアロケータは、それ自体では役に立ちません。これはプレースホルダーとしてのみ存在するため、標準ライブラリにmalloc（）、free（）、またはrealloc（）がないシステムでリンクするメモリアロケーターがSQLiteにあります。&lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC&lt;/a&gt;でコンパイルされたアプリケーションは、SQLiteの使用を開始する前に、&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;または&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;と共に&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;を使用して、新しい代替メモリアロケータを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="fa03e3271f78c25f5482177efc3b575ee4cb93ab" translate="yes" xml:space="preserve">
          <source>The nolock query parameter is a boolean that disables all calls to the xLock, xUnlock, and xCheckReservedLock methods of the VFS when true. The nolock query parameter might be used, for example, when trying to access a file on a filesystem that does not support file locking. Caution: If two or more &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; try to interact with the same SQLite database and one or more of those connections has enabled &quot;nolock&quot;, then database corruption can result. The &quot;nolock&quot; query parameter should only be used if the application can guarantee that writes to the database are serialized.</source>
          <target state="translated">nolockクエリパラメータは、trueの場合、VFSのxLock、xUnlock、およびxCheckReservedLockメソッドへのすべての呼び出しを無効にするブール値です。nolockクエリパラメータは、たとえば、ファイルロックをサポートしていないファイルシステム上のファイルにアクセスしようとするときに使用されます。注意：2つ以上の&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;が同じSQLiteデータベースと対話しようとし、それらの接続の1つ以上で「nolock」が有効になっている場合、データベースが破損する可能性があります。&quot;nolock&quot;クエリパラメータは、アプリケーションがデータベースへの書き込みのシリアル化を保証できる場合にのみ使用してください。</target>
        </trans-unit>
        <trans-unit id="b327cb7b48d6db3fd953f98055ad0798aba25bf9" translate="yes" xml:space="preserve">
          <source>The normal ROWID selection algorithm described above will generate monotonically increasing unique ROWIDs as long as you never use the maximum ROWID value and you never delete the entry in the table with the largest ROWID. If you ever delete rows or if you ever create a row with the maximum possible ROWID, then ROWIDs from previously deleted rows might be reused when creating new rows and newly created ROWIDs might not be in strictly ascending order.</source>
          <target state="translated">上で説明した通常のROWID選択アルゴリズムは、ROWIDの最大値を使用せず、最大のROWIDを持つテーブル内のエントリを削除しない限り、単調に増加する一意のROWIDを生成します。行を削除したり、可能な限り最大のROWIDを持つ行を作成したりすると、新しい行を作成する際に以前に削除された行のROWIDが再利用され、新たに作成されたROWIDは厳密には昇順ではないかもしれません。</target>
        </trans-unit>
        <trans-unit id="dd6fdcceb1d1ed51baa294f01d457a9007d5dbff" translate="yes" xml:space="preserve">
          <source>The notindexed= option is not available. Adding &lt;a href=&quot;fts5#the_unindexed_column_option&quot;&gt;UNINDEXED&lt;/a&gt; to the column definition is equivalent.</source>
          <target state="translated">notindexed =オプションは使用できません。&lt;a href=&quot;fts5#the_unindexed_column_option&quot;&gt;UNINDEXED&lt;/a&gt;を列定義に追加することは同等です。</target>
        </trans-unit>
        <trans-unit id="e15aca005b3d3fc4e0be53d1a5e363f5a459da35" translate="yes" xml:space="preserve">
          <source>The nullif(X,Y) function returns its first argument if the arguments are different and NULL if the arguments are the same. The nullif(X,Y) function searches its arguments from left to right for an argument that defines a collating function and uses that collating function for all string comparisons. If neither argument to nullif() defines a collating function then the BINARY is used.</source>
          <target state="translated">nullif(X,Y)関数は、引数が異なる場合は第1引数を返し、引数が同じ場合はNULLを返します。nullif(X,Y)関数は、照合関数を定義している引数を左から右へ検索し、すべての文字列比較にその照合関数を使用します。nullif()のどちらの引数も照合関数を定義していない場合は BINARY が使用されます。</target>
        </trans-unit>
        <trans-unit id="0d33dbf967cc9fffb2bcf5f7dd0e676a56e0fe27" translate="yes" xml:space="preserve">
          <source>The number of arguments to a function is sometimes stored in a signed character. So there is a hard upper bound on SQLITE_MAX_FUNCTION_ARG of 127.</source>
          <target state="translated">関数の引数の数は符号付きの文字で格納されることがあります。そのため、SQLITE_MAX_FUNCTION_ARGには127のハードな上限があります。</target>
        </trans-unit>
        <trans-unit id="22855456991124f9a63a13f70b4de30a07b1a44f" translate="yes" xml:space="preserve">
          <source>The number of characters in cFrom and cTo do not need to be the same. The rule above says that &quot;ss&quot; on user input will match &quot;&amp;szlig;&quot; with a penalty of 8.</source>
          <target state="translated">cFromとcToの文字数は同じである必要はありません。上記のルールは、ユーザー入力の「ss」がペナルティ8の「&amp;szlig;」と一致することを示しています。</target>
        </trans-unit>
        <trans-unit id="1dc8b6de1e412ad3d4600fff75a5432b18cfae89" translate="yes" xml:space="preserve">
          <source>The number of columns in a table</source>
          <target state="translated">テーブルの列数</target>
        </trans-unit>
        <trans-unit id="c449227bed7d73e21c9772a435303abb6080e61e" translate="yes" xml:space="preserve">
          <source>The number of columns in a table is limited by the &lt;a href=&quot;limits#max_column&quot;&gt;SQLITE_MAX_COLUMN&lt;/a&gt; compile-time parameter. A single row of a table cannot store more than &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; bytes of data. Both of these limits can be lowered at runtime using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; C/C++ interface.</source>
          <target state="translated">テーブルの列の数は、&lt;a href=&quot;limits#max_column&quot;&gt;SQLITE_MAX_COLUMN&lt;/a&gt;コンパイル時パラメーターによって制限されます。テーブルの単一の行に&lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;バイトを超えるデータを格納することはできません。これらの制限はどちらも、&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit（）&lt;/a&gt; C / C ++インターフェイスを使用して実行時に下げることができます。</target>
        </trans-unit>
        <trans-unit id="8a6392262a1b2aadeab5c7954067326f2acb3a1d" translate="yes" xml:space="preserve">
          <source>The number of columns in a view</source>
          <target state="translated">ビューのカラム数</target>
        </trans-unit>
        <trans-unit id="7da1c90b5d954b64a1a4a566749d8c554741462e" translate="yes" xml:space="preserve">
          <source>The number of columns in an index</source>
          <target state="translated">インデックスの列数</target>
        </trans-unit>
        <trans-unit id="155a4bbdc3161555e0a5db3b049b1a9960793a80" translate="yes" xml:space="preserve">
          <source>The number of columns in each row returned by the SELECT statement (if any) and the specific values returned have no effect on the results of the EXISTS operator. In particular, rows containing NULL values are not handled any differently from rows without NULL values.</source>
          <target state="translated">SELECT文によって返された各行のカラム数(もしあれば)と、返された特定の値は、EXISTS演算子の結果に影響を与えません。特に、NULL 値を含む行は、NULL 値を持たない行と何ら変わりなく扱われます。</target>
        </trans-unit>
        <trans-unit id="b33773d9bb8fcd548b7aa9142e9dd252802d3ebf" translate="yes" xml:space="preserve">
          <source>The number of columns in the result set of a SELECT statement</source>
          <target state="translated">SELECT文の結果セットのカラム数</target>
        </trans-unit>
        <trans-unit id="5962dbc1c4fa716686ee3f9c370159a83fff2488" translate="yes" xml:space="preserve">
          <source>The number of columns in the rows returned by a simple SELECT statement is equal to the number of expressions in the result expression list after substitution of * and alias.* expressions. Each result row is calculated by evaluating the expressions in the result expression list with respect to a single row of input data or, for aggregate queries, with respect to a group of rows.</source>
          <target state="translated">単純なSELECT文によって返される行の列の数は、*式とalias.*式を置換した後の結果式リストの式の数に等しい。各結果行は、結果式リスト内の式を入力データの1行、または集約クエリの場合は行のグループを基準にして評価することで計算されます。</target>
        </trans-unit>
        <trans-unit id="efcaef0127aaba4759abf4c43138ceabba69a62b" translate="yes" xml:space="preserve">
          <source>The number of columns in the table, and</source>
          <target state="translated">テーブルのカラム数と</target>
        </trans-unit>
        <trans-unit id="ec4b9441464f8df5d1135d79fc696ff2d27c10ef" translate="yes" xml:space="preserve">
          <source>The number of columns the table has, and</source>
          <target state="translated">テーブルが持つカラムの数と</target>
        </trans-unit>
        <trans-unit id="f71fcd9bd24f5e705202e8ea9d15f75d827b7073" translate="yes" xml:space="preserve">
          <source>The number of entries in the write-ahead log (WAL) file for that database</source>
          <target state="translated">そのデータベースのWAL(write-ahead log)ファイルのエントリ数。</target>
        </trans-unit>
        <trans-unit id="146718a82c006ef871da6bc05817a225f7435b26" translate="yes" xml:space="preserve">
          <source>The number of fields in this row.</source>
          <target state="translated">この行のフィールド数。</target>
        </trans-unit>
        <trans-unit id="049187119aa733be135d042e46c0767e81dbbd57" translate="yes" xml:space="preserve">
          <source>The number of freelist pages is stored as a 4-byte big-endian integer in the database header at an offset of 36 from the beginning of the file. The database header also stores the page number of the first freelist trunk page as a 4-byte big-endian integer at an offset of 32 from the beginning of the file.</source>
          <target state="translated">フリーリストのページ数は、ファイルの先頭から36のオフセットで4バイトのビッグエンディアン整数としてデータベースヘッダーに格納される。また、データベース・ヘッダには、最初のフリーリスト・トランク・ページのページ番号が、ファイルの先頭から32のオフセットで4バイトのビッグエンディアン整数として格納されます。</target>
        </trans-unit>
        <trans-unit id="297412af9b640397abb6b05573031f719033bedb" translate="yes" xml:space="preserve">
          <source>The number of matchable phrases in the query.</source>
          <target state="translated">クエリ内の一致するフレーズの数。</target>
        </trans-unit>
        <trans-unit id="96242742547a237955f6f616dd7a1536e46de1dc" translate="yes" xml:space="preserve">
          <source>The number of open read-transactions on the shared-cache drops to zero.</source>
          <target state="translated">共有キャッシュ上のオープンリードトランザクションの数がゼロになります。</target>
        </trans-unit>
        <trans-unit id="140866849ab31e765e1dcf46dadf93357615ced1" translate="yes" xml:space="preserve">
          <source>The number of registers in a single prepared statement is fixed at compile-time. The content of all registers is cleared when a prepared statement is &lt;a href=&quot;c3ref/reset&quot;&gt;reset&lt;/a&gt; or &lt;a href=&quot;c3ref/finalize&quot;&gt;finalized&lt;/a&gt;.</source>
          <target state="translated">単一の準備済みステートメント内のレジスターの数は、コンパイル時に固定されます。すべてのレジスタの内容は、準備されたステートメントが&lt;a href=&quot;c3ref/reset&quot;&gt;リセット&lt;/a&gt;または&lt;a href=&quot;c3ref/finalize&quot;&gt;ファイナライズ&lt;/a&gt;されるとクリアされます。</target>
        </trans-unit>
        <trans-unit id="4967dccc017338cead0491dfe60a2adb347e1af4" translate="yes" xml:space="preserve">
          <source>The number of rows in a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES clause&lt;/a&gt; is no longer limited by &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcompoundselect&quot;&gt;SQLITE_LIMIT_COMPOUND_SELECT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_select#values&quot;&gt;VALUES句&lt;/a&gt;の行数は&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcompoundselect&quot;&gt;SQLITE_LIMIT_COMPOUND_SELECT&lt;/a&gt;によって制限されなくなりました。</target>
        </trans-unit>
        <trans-unit id="36747c7623716448e27a5f87c9f1a06587b9fa71" translate="yes" xml:space="preserve">
          <source>The number of rows in the FTS4 table. This value is only available when querying FTS4 tables, not FTS3.</source>
          <target state="translated">FTS4 テーブルの行数。この値は、FTS3ではなく、FTS4テーブルにクエリを実行する場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="e61b9ea13ff6553c9d51a6610c8145f4cf2adbcc" translate="yes" xml:space="preserve">
          <source>The number of rows in the FTS5 table for which column $col contains at least one instance of the term.</source>
          <target state="translated">FTS5 テーブル内で、列 $col に用語のインスタンスが少なくとも 1 つ含まれている行の数。</target>
        </trans-unit>
        <trans-unit id="05c84b067bb80eadabe7075383b96e16df1c5aad" translate="yes" xml:space="preserve">
          <source>The number of rows that contain at least one instance of the term.</source>
          <target state="translated">用語の少なくとも1つのインスタンスを含む行の数。</target>
        </trans-unit>
        <trans-unit id="32422ea0ce2f612eaf439b2072fddd2d97242e6b" translate="yes" xml:space="preserve">
          <source>The number of system calls for filesystem operations is reduced, possibly resulting in a small performance increase.</source>
          <target state="translated">ファイルシステム操作のためのシステムコールの数が減るため、パフォーマンスが若干向上する可能性があります。</target>
        </trans-unit>
        <trans-unit id="e6551507f016b4d4b5fee98e7304b5666b04c04e" translate="yes" xml:space="preserve">
          <source>The number of terms in a GROUP BY or ORDER BY clause</source>
          <target state="translated">GROUP BYまたはORDER BY句の項数。</target>
        </trans-unit>
        <trans-unit id="1c91b565cbe9942030a8129bf45c560b0a7de90f" translate="yes" xml:space="preserve">
          <source>The number of terms in the SET clause of an UPDATE statement</source>
          <target state="translated">UPDATE文のSET句の項数。</target>
        </trans-unit>
        <trans-unit id="70c8732a507183c03eb179514303045a0317c738" translate="yes" xml:space="preserve">
          <source>The number of the current row's peer group within its partition - the rank of the current row without gaps. Partitions are numbered starting from 1 in the order defined by the ORDER BY clause in the window definition. If there is no ORDER BY clause, then all rows are considered peers and this function always returns 1.</source>
          <target state="translated">パーティション内の現在の行のピアグループの数-現在の行のギャップのないランク。パーティションは、ウィンドウ定義の ORDER BY 節で定義された順番で 1 から順に番号が付けられます。ORDER BY 句がない場合は、すべての行がピアとみなされ、この関数は常に 1 を返します。</target>
        </trans-unit>
        <trans-unit id="19450a48e3be402fdbd06d100d558662cd52a063" translate="yes" xml:space="preserve">
          <source>The number of the row within the current partition. Rows are numbered starting from 1 in the order defined by the ORDER BY clause in the window definition, or in arbitrary order otherwise.</source>
          <target state="translated">現在のパーティション内の行の番号。行の番号は、ウィンドウ定義の ORDER BY 節で定義された順番で 1 から始まり、それ以外の場合は任意の順番になります。</target>
        </trans-unit>
        <trans-unit id="4dd0d77e2a923847446dbf60b3f48736890bd6ba" translate="yes" xml:space="preserve">
          <source>The number of user defined columns in the FTS table (i.e. not including the docid or the &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt;).</source>
          <target state="translated">FTSテーブルのユーザー定義列の数（つまり、docidまたは&lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS非表示列&lt;/a&gt;は含まれません）。</target>
        </trans-unit>
        <trans-unit id="ec04163c2280ea8f1f3a4d1db55ac34599bd6c09" translate="yes" xml:space="preserve">
          <source>The number of values in an INSERT statement</source>
          <target state="translated">INSERT文の値の数</target>
        </trans-unit>
        <trans-unit id="0c5896381d0db64fdbbf15f25aac8c07347171d8" translate="yes" xml:space="preserve">
          <source>The numbered list above notes that the data for the first page of the database file, if it exists and is not already loaded into the</source>
          <target state="translated">上記の番号付きリストは、データベースファイルの最初のページのデータが存在していて、それがすでに</target>
        </trans-unit>
        <trans-unit id="57671fab77edd8c578d7c9204ffe057965cc804a" translate="yes" xml:space="preserve">
          <source>The numbers here have become meaningless. This page has been retained only as an historical artifact.</source>
          <target state="translated">ここでの数字は無意味になってしまいました。このページは歴史的遺物としてのみ保存されています。</target>
        </trans-unit>
        <trans-unit id="dde5b38271f3bab6f5848df944b4001a9705e033" translate="yes" xml:space="preserve">
          <source>The numbers on the left are the CPU cycle counts for that line of code, of course.</source>
          <target state="translated">左側の数字は、もちろんその行のCPUサイクル数です。</target>
        </trans-unit>
        <trans-unit id="a08476269382d9cd02770e2cab87ae0ab5a527b0" translate="yes" xml:space="preserve">
          <source>The object is deleted using a call to sqlite3changegroup_delete().</source>
          <target state="translated">オブジェクトはsqlite3changegroup_delete()を呼び出して削除されます。</target>
        </trans-unit>
        <trans-unit id="5ae7075075a940fc9e83c06d49e89ed478d0bf99" translate="yes" xml:space="preserve">
          <source>The one-byte flag at offset 0 indicating the b-tree page type.</source>
          <target state="translated">b-tree ページタイプを示すオフセット 0 の半角フラグ。</target>
        </trans-unit>
        <trans-unit id="8ef8e17609c1f629f28fe60dfd6c0e8997843e40" translate="yes" xml:space="preserve">
          <source>The one-byte integer at offset 7 gives the number of fragmented free bytes within the cell content area.</source>
          <target state="translated">オフセット7の半角整数は、セルコンテンツ領域内の断片化されたフリーバイト数を与える。</target>
        </trans-unit>
        <trans-unit id="729502a2e01c1766734981063a90830e318512ca" translate="yes" xml:space="preserve">
          <source>The online backup API is &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;documented here&lt;/a&gt;. The remainder of this page contains two C language examples illustrating common uses of the API and discussions thereof. Reading these examples is no substitute for reading the API documentation!</source>
          <target state="translated">オンラインバックアップAPIについては、&lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;こちらをご覧ください&lt;/a&gt;。このページの残りの部分には、APIの一般的な使用法とその説明を示す2つのC言語の例が含まれています。これらの例を読むことは、APIドキュメントを読むことに代わるものではありません。</target>
        </trans-unit>
        <trans-unit id="0ca3b9f46f696e6082e6b7a829be81ef745b8e77" translate="yes" xml:space="preserve">
          <source>The only SQLite compile-time option used was &lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5&lt;/a&gt;. The optional &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; memory allocator is used for performance testing because it gives results that are more repeatable than the library-supplied malloc()/free() on Ubuntu.</source>
          <target state="translated">使用された唯一のSQLiteコンパイル時オプションは&lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5でした&lt;/a&gt;。オプションの&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;メモリアロケータは、Ubuntuでライブラリが提供するmalloc（）/ free（）よりも再現性の高い結果を提供するため、パフォーマンステストに使用されます。</target>
        </trans-unit>
        <trans-unit id="89c13a55d3d11964427a1a5b2d10d0b78ec66565" translate="yes" xml:space="preserve">
          <source>The only compression algorithm supported is &lt;a href=&quot;https://zlib.net&quot;&gt;&quot;deflate&quot;&lt;/a&gt;.</source>
          <target state="translated">サポートされている唯一の圧縮アルゴリズムは&lt;a href=&quot;https://zlib.net&quot;&gt;&quot;deflate&quot;&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="ecb1124fca00e2a69914563c0d3a9baa08011926" translate="yes" xml:space="preserve">
          <source>The only difference between the following two CASE expressions is that the</source>
          <target state="translated">次の2つのcase表現の違いは</target>
        </trans-unit>
        <trans-unit id="f71f4a9db1fb88c54de0203ce462454fe4edc774" translate="yes" xml:space="preserve">
          <source>The only difference is that the public sqlite3_XXX functions enumerated above silently ignore any invocations that pass a NULL pointer instead of a valid mutex handle. The implementations of the methods defined by this structure are not required to handle this case, the results of passing a NULL pointer instead of a valid mutex handle are undefined (i.e. it is acceptable to provide an implementation that segfaults if it is passed a NULL pointer).</source>
          <target state="translated">唯一の違いは、上で列挙したpublic sqlite3_XXX関数が有効なミューテックスハンドルの代わりにNULLポインタを渡す呼び出しを黙って無視することです。この構造体で定義されたメソッドの実装はこのケースを処理する必要はなく、有効なミューテックスハンドルの代わりにNULLポインタを渡した結果は未定義です(つまり、NULLポインタを渡した場合にセグフェイルする実装を提供しても構いません)。</target>
        </trans-unit>
        <trans-unit id="9650a6c44a89db8ce8453af489933161fa10a223" translate="yes" xml:space="preserve">
          <source>The only difference is that the public sqlite3_XXX functions enumerated above silently ignore any invocations that pass a NULL pointer instead of a valid mutex handle. The implementations of the methods defined by this structure are not required to handle this case. The results of passing a NULL pointer instead of a valid mutex handle are undefined (i.e. it is acceptable to provide an implementation that segfaults if it is passed a NULL pointer).</source>
          <target state="translated">唯一の違いは、上で列挙したpublic sqlite3_XXX関数が有効なミューテックスハンドルの代わりにNULLポインタを渡す呼び出しを黙って無視することです。この構造体で定義されたメソッドの実装はこのケースを処理する必要はありません。有効なミューテックスハンドルの代わりにNULLポインタを渡した結果は未定義です(つまり、NULLポインタを渡した場合にセグメンテーションフォールトする実装を提供しても構いません)。</target>
        </trans-unit>
        <trans-unit id="927a15e9b9c9c5a21e0cad33a99f89864994a2c1" translate="yes" xml:space="preserve">
          <source>The only really hard part is step 1. You might want to start with an existing virtual table implementation and modify it to suit your needs. The &lt;a href=&quot;https://sqlite.org/src/dir?ci=trunk&amp;amp;type=tree&quot;&gt;SQLite source tree&lt;/a&gt; contains many virtual table implementations that are suitable for copying, including:</source>
          <target state="translated">本当に難しい部分はステップ1だけです。既存の仮想テーブルの実装から始めて、ニーズに合わせて変更することをお勧めします。&lt;a href=&quot;https://sqlite.org/src/dir?ci=trunk&amp;amp;type=tree&quot;&gt;SQLiteのソースツリーには&lt;/a&gt;、コピーなどのために適している多くの仮想テーブルの実装が含まれています。</target>
        </trans-unit>
        <trans-unit id="b216563d4489c23da5dd8ef7bbce7ce15447a023" translate="yes" xml:space="preserve">
          <source>The only really hard part is step 1. You might want to start with an existing virtual table implementation and modify it to suit your needs. There are several virtual table implementations in the SQLite source tree (for testing purposes). You might use one of those as a guide. Locate these test virtual table implementations by searching for &quot;sqlite3_create_module&quot;.</source>
          <target state="translated">本当に難しいのはステップ1だけです。既存の仮想テーブルの実装から始めて、必要に応じて変更するのが良いでしょう。SQLiteのソースツリーには(テスト用に)いくつかの仮想テーブルの実装があります。それらのうちの1つをガイドとして使用するとよいでしょう。sqlite3_create_module &quot;を検索して、これらのテスト用仮想テーブル実装を見つけてください。</target>
        </trans-unit>
        <trans-unit id="6a54b4d13a6de9bd96883cd76ca40e5bd7dd1a4b" translate="yes" xml:space="preserve">
          <source>The only reasons for providing functions other than strftime() is for convenience and for efficiency.</source>
          <target state="translated">strftime()以外の関数を提供する理由は、利便性と効率化のためだけです。</target>
        </trans-unit>
        <trans-unit id="c64051b826835db581e8535aa4a8fb802f2e8d26" translate="yes" xml:space="preserve">
          <source>The only schema altering commands directly supported by SQLite are the &quot;&lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;rename table&lt;/a&gt;&quot;, &quot;&lt;a href=&quot;lang_altertable#altertabmvcol&quot;&gt;rename column&lt;/a&gt;&quot;, and &quot;&lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;add column&lt;/a&gt;&quot; commands shown above. However, applications can make other arbitrary changes to the format of a table using a simple sequence of operations. The steps to make arbitrary changes to the schema design of some table X are as follows:</source>
          <target state="translated">SQLiteが直接サポートする唯一のスキーマ変更コマンドは、上記の「&lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;テーブルの名前変更&lt;/a&gt;」、「&lt;a href=&quot;lang_altertable#altertabmvcol&quot;&gt;列の名前変更&lt;/a&gt;」、および「&lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;列の追加&lt;/a&gt;」コマンドです。ただし、アプリケーションは、単純な一連の操作を使用して、テーブルの形式に他の任意の変更を加えることができます。一部のテーブルXのスキーマ設計に任意の変更を加える手順は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a93c45a553bd489c541613e587314033dbb5442e" translate="yes" xml:space="preserve">
          <source>The only significant design decision that developers need to make is whether to use -Os (optimize for size) or -O6 (optimize for speed). The -O6 setting makes binaries that run about 2% or 3% faster, but which are also 66% larger. The performance here is measured by counting CPU cycles using cachegrind. I-cache misses are not considered in the analysis. If I-cache misses are considered, builds with -O6 might not be any faster than builds with -Os.</source>
          <target state="translated">開発者が行う必要がある唯一の重要な設計上の決定は、-Os (サイズの最適化)と -O6 (速度の最適化)のどちらを使用するかということです。O6 の設定では、バイナリの実行速度は約 2%、3% 速くなりますが、バイナリのサイズは 66% 大きくなります。ここでのパフォーマンスは、cachegrind を使って CPU サイクルをカウントすることで測定されます。I-キャッシュミスは解析では考慮されません。I-cache miss を考慮した場合、-O6 を使用したビルドは -Os を使用したビルドよりも速くならないかもしれません。</target>
        </trans-unit>
        <trans-unit id="67fcf151555c1f1738044349d853d4cc0820a67f" translate="yes" xml:space="preserve">
          <source>The only thing that is really new about the current example is the WHERE clause which is implemented by instructions at addresses 7 through 10. Instructions at address 7 and 8 push onto the stack the value of the &quot;one&quot; column from the table and the literal string &quot;H%&quot;. The &lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt; instruction at address 9 pops these two values from the stack and pushes the result of the LIKE() function back onto the stack. The &lt;a href=&quot;opcode#IfNot&quot;&gt;IfNot&lt;/a&gt; instruction pops the top stack value and causes an immediate jump forward to the Next instruction if the top value was false (&lt;em&gt;not&lt;/em&gt; not like the literal string &quot;H%&quot;). Taking this jump effectively skips the callback, which is the whole point of the WHERE clause. If the result of the comparison is true, the jump is not taken and control falls through to the Callback instruction below.</source>
          <target state="translated">現在の例で本当に新しいのは、アドレス7〜10の命令によって実装されるWHERE句だけです。アドレス7および8の命令は、テーブルとリテラルから「1」列の値をスタックにプッシュします。文字列「H％」。アドレス9 の&lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt;命令は、これらの2つの値をスタックからポップし、LIKE（）関数の結果をスタックにプッシュします。&lt;a href=&quot;opcode#IfNot&quot;&gt;IFNOTの&lt;/a&gt;命令は、トップスタックの値をポップし、トップ値は（偽だった場合は、次の命令を楽しみにすぐにジャンプしません&lt;em&gt;&lt;/em&gt;リテラル文字列「H％」とは異なります）。このジャンプを行うと、コールバックがスキップされます。これは、WHERE句の要点です。比較の結果が真の場合、ジャンプは行われず、制御は以下のコールバック命令に移ります。</target>
        </trans-unit>
        <trans-unit id="7db0a106b3cc6051a669fd3768b87982a2f1bf0d" translate="yes" xml:space="preserve">
          <source>The only time this would ever be an issue is when you have a program using version 2.8.0 or later that crashes with an incomplete transaction, then you try to examine the database using version 2.7.6 or earlier. The 2.7.6 code will not be able to read the journal file and thus will not be able to rollback the incomplete transaction to restore the database.</source>
          <target state="translated">これが問題になるのは、バージョン2.8.0以降を使用しているプログラムが不完全なトランザクションでクラッシュした後、バージョン2.7.6以前を使用してデータベースを調べようとした場合だけです。2.7.6のコードはジャーナルファイルを読むことができないので、データベースを復元するために不完全なトランザクションをロールバックすることができません。</target>
        </trans-unit>
        <trans-unit id="3427e2677eb5693de36c8d23ded03f405a1417be" translate="yes" xml:space="preserve">
          <source>The only way that SQLite can know that the left-most columns of an index have many duplicate is if the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command has been run on the database. Without the results of ANALYZE, SQLite has to guess at the &quot;shape&quot; of the data in the table, and the default guess is that there are an average of 10 duplicates for every value in the left-most column of the index. But skip-scan only becomes profitable (it only gets to be faster than a full table scan) when the number of duplicates is about 18 or more. Hence, a skip-scan is never used on a database that has not been analyzed.</source>
          <target state="translated">SQLiteがインデックスの左端の列に多くの重複があることを知る唯一の方法は、&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;コマンドがデータベースで実行されている場合です。ANALYZEの結果がない場合、SQLiteはテーブル内のデータの「形状」を推測する必要があり、デフォルトの推測では、インデックスの左端の列のすべての値に対して平均10の重複があります。しかし、スキップスキャンは、重複の数が約18以上の場合にのみ有益になります（全テーブルスキャンよりも高速になります）。したがって、スキップスキャンは、分析されていないデータベースでは使用されません。</target>
        </trans-unit>
        <trans-unit id="4470bf44a4ab413995e0a4a3db8d3df4a465f540" translate="yes" xml:space="preserve">
          <source>The opening and/or creating of the database file is deferred until the file is actually needed. This allows options and parameters, such as the native text representation and default page size, to be set using PRAGMA statements.</source>
          <target state="translated">データベースファイルのオープンおよび/または作成は、ファイルが実際に必要とされるまで延期されます。これにより、ネイティブテキスト表現やデフォルトページサイズなどのオプションやパラメータをPRAGMA文を使って設定することができます。</target>
        </trans-unit>
        <trans-unit id="0fff8fde33861bc909ec1bcff7cb77c490217d5b" translate="yes" xml:space="preserve">
          <source>The operating system interface layer understands and tracks all five locking states described above. The pager module only tracks four of the five locking states. A PENDING lock is always just a temporary stepping stone on the path to an EXCLUSIVE lock and so the pager module does not track PENDING locks.</source>
          <target state="translated">オペレーティング・システム・インターフェース層は、上述の5つのロック状態をすべて理解し、追跡します。ポケベルモジュールは、5 つのロック状態のうち 4 つだけを追跡します。PENDING ロックは常に、EXCLUSIVE ロックへのパス上の一時的な飛び石に過ぎないので、ページャーモジュールは PENDING ロックを追跡しません。</target>
        </trans-unit>
        <trans-unit id="6f69f5f3efa82abf10e6a8b25aaa02ea47607f29" translate="yes" xml:space="preserve">
          <source>The operating system must have a unified buffer cache in order for the memory-mapped I/O extension to work correctly, especially in situations where two processes are accessing the same database file and one process is using memory-mapped I/O while the other is not. Not all operating systems have a unified buffer cache. In some operating systems that claim to have a unified buffer cache, the implementation is buggy and can lead to corrupt databases.</source>
          <target state="translated">特に、2つのプロセスが同じデータベースファイルにアクセスしていて、1つのプロセスがメモリマップドI/Oを使用していて、もう1つのプロセスが使用していないような状況では、メモリマップドI/O拡張機能を正しく動作させるためには、オペレーティングシステムが統一されたバッファキャッシュを持っている必要があります。すべてのオペレーティングシステムが統一されたバッファキャッシュを持っているわけではありません。統合されたバッファキャッシュを持っていると主張するオペレーティングシステムの中には、実装がバグだらけで、データベースを破損させる可能性があります。</target>
        </trans-unit>
        <trans-unit id="2fef3a1777aac58cd8a21d6d8b1475aa38c4964a" translate="yes" xml:space="preserve">
          <source>The operations above can potentially cause vast changes the raw database file, and hence cause very different SHA1 hashes at the file level. But since the content represented in the database file is unchanged by these operations, the hash computed by dbhash is also unchanged.</source>
          <target state="translated">上記の操作は、生のデータベースファイルに大きな変更を与える可能性があり、ファイルレベルでは非常に異なるSHA1ハッシュを発生させる可能性があります。しかし、データベースファイルで表現されている内容はこれらの操作によって変更されないので、dbhashによって計算されたハッシュも変更されません。</target>
        </trans-unit>
        <trans-unit id="fa365bc2db1bf185a92f2d5ef6ff8250e55de644" translate="yes" xml:space="preserve">
          <source>The optimization that uses an index to quickly compute an aggregate min() or max() is extended to work with &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;.</source>
          <target state="translated">インデックスを使用して集約min（）またはmax（）をすばやく計算する最適化は、式のインデックスを操作するように拡張されてい&lt;a href=&quot;expridx&quot;&gt;ます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0ff09fb1c0cc730867c7410dca6d8522dc6581b" translate="yes" xml:space="preserve">
          <source>The optimizer automatically inverts terms of the form &quot;expr OP column&quot; and makes other simplifications to the WHERE clause in an attempt to get as many WHERE clause terms into the form shown above as possible. The aConstraint[] array only reports WHERE clause terms that are relevant to the particular virtual table being queried.</source>
          <target state="translated">オプティマイザは、&quot;expr OP column&quot; という形式の用語を自動的に反転させ、可能な限り多くの WHERE 句を上記の形式にするために、WHERE 句にその他の簡略化を行います。aConstraint[]配列は、問い合わせ先の特定の仮想テーブルに関連する WHERE 句のみをレポートします。</target>
        </trans-unit>
        <trans-unit id="3a8fb11a2c37159ec0832c94b1217f4e3525fc9f" translate="yes" xml:space="preserve">
          <source>The optimizer has more freedom to reorder tables in the FROM clause even in there are LEFT joins.</source>
          <target state="translated">オプティマイザは、LEFT結合があってもFROM句でテーブルを並べ替える自由度が高くなりました。</target>
        </trans-unit>
        <trans-unit id="ed82314b13b2ea2beac78e23a61e927cbc2a784b" translate="yes" xml:space="preserve">
          <source>The optimizer will now scan tables in the reverse if doing so will satisfy an ORDER BY ... DESC clause.</source>
          <target state="translated">オプティマイザは、ORDER BY ...DESC句を満たす場合、テーブルを逆にスキャンするようになりました。DESC句を満たしていれば、オプティマイザはテーブルを逆スキャンするようになります。</target>
        </trans-unit>
        <trans-unit id="8d9594a87362ce1971b7a9efe4bfc116ba95e426" translate="yes" xml:space="preserve">
          <source>The option</source>
          <target state="translated">オプション</target>
        </trans-unit>
        <trans-unit id="a17a0a84a2d535101cac8aa7214d0ca78303a13a" translate="yes" xml:space="preserve">
          <source>The option causes SQLite to omit its built-in operating system interfaces for Unix, Windows, and OS/2. The resulting library will have no default &lt;a href=&quot;c3ref/vfs&quot;&gt;operating system interface&lt;/a&gt;. Applications must use &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; to register an appropriate interface before using SQLite. Applications must also supply implementations for the &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt; and &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_end()&lt;/a&gt; interfaces. The usual practice is for the supplied &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt; to invoke &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;. SQLite will automatically invoke &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt; when it initializes.</source>
          <target state="translated">このオプションにより、SQLiteは、Unix、Windows、およびOS / 2の組み込みオペレーティングシステムインターフェイスを省略します。結果のライブラリには、デフォルトの&lt;a href=&quot;c3ref/vfs&quot;&gt;オペレーティングシステムインターフェイス&lt;/a&gt;はありません。アプリケーションは、SQLiteを使用する前に、&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;を使用して適切なインターフェースを登録する必要があります。アプリケーションは、&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init（）&lt;/a&gt;および&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_end（）&lt;/a&gt;インターフェースの実装も提供する必要があります。通常の練習は、供給されるためである&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init（）&lt;/a&gt;呼び出すことが&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（） &lt;/a&gt;。SQLiteは、初期化時に&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init（）&lt;/a&gt;を自動的に呼び出します。</target>
        </trans-unit>
        <trans-unit id="18b9f1ce4c729b2ded7edcf5db48cd7ab36a842d" translate="yes" xml:space="preserve">
          <source>The optional</source>
          <target state="translated">オプションの</target>
        </trans-unit>
        <trans-unit id="e154860c714282a196150a8b230c6746d885f55b" translate="yes" xml:space="preserve">
          <source>The optional &quot;</source>
          <target state="translated">オプションの&quot;</target>
        </trans-unit>
        <trans-unit id="44528aeaa99ba557a8ba7b80ef11d6c589ba4953" translate="yes" xml:space="preserve">
          <source>The optional &quot;AS alias&quot; phrase provides an alternative name for the table into which content is being inserted. The alias name can be used within WHERE and SET clauses of the &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt;. If there is no &lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;, then the alias is pointless, but also harmless.</source>
          <target state="translated">オプションの「ASエイリアス」句は、コンテンツが挿入されるテーブルの代替名を提供します。エイリアス名は、&lt;a href=&quot;lang_upsert&quot;&gt;UPSERTの&lt;/a&gt; WHEREおよびSET句内で使用できます。&lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;がない場合、エイリアスは無意味ですが無害でもあります。</target>
        </trans-unit>
        <trans-unit id="af3a99778493ef21555e9c9fa86a7e91b06e70d3" translate="yes" xml:space="preserve">
          <source>The optional &quot;OR</source>
          <target state="translated">オプションの「OR</target>
        </trans-unit>
        <trans-unit id="20d5db3386f7bebafe75fa5cbd335d930edd4888" translate="yes" xml:space="preserve">
          <source>The optional EXCLUDE clause may take any of the following four forms:</source>
          <target state="translated">オプションのEXCLUDE句は、以下の4つの形式のいずれかを取ることができます。</target>
        </trans-unit>
        <trans-unit id="f5dad0eb12cbe81d01819ac36d3268610ba8edac" translate="yes" xml:space="preserve">
          <source>The optional IF EXISTS clause suppresses the error that would normally result if the table does not exist.</source>
          <target state="translated">オプションのIF EXISTS句は、テーブルが存在しない場合に通常発生するエラーを抑制します。</target>
        </trans-unit>
        <trans-unit id="5cb5d652a77ff38b54b62cd30fd9ed282bedd94d" translate="yes" xml:space="preserve">
          <source>The optional MASK argument is a bitmask of optimizations to perform:</source>
          <target state="translated">オプションのMASK引数は、実行する最適化のビットマスクです。</target>
        </trans-unit>
        <trans-unit id="6a52a350b8227e3f2c9ade5a4eb34242d4d7eced" translate="yes" xml:space="preserve">
          <source>The optional argument is the name of the schema or database to be serialized. The default value is &quot;main&quot;.</source>
          <target state="translated">オプションの引数には、シリアライズするスキーマまたはデータベースの名前を指定します。デフォルト値は &quot;main &quot;です。</target>
        </trans-unit>
        <trans-unit id="38da3cf28a52f4f6d620faa6e6cb2361f1cf4901" translate="yes" xml:space="preserve">
          <source>The optional expression that occurs in between the CASE keyword and the first WHEN keyword is called the &quot;base&quot; expression. There are two basic forms of the CASE expression: those with a base expression and those without.</source>
          <target state="translated">CASE キーワードと最初の WHEN キーワードの間に発生するオプション式は、「ベース」式と呼ばれます。CASE 式には、ベース式を持つものと持たないものの 2 つの基本的な形式があります。</target>
        </trans-unit>
        <trans-unit id="4916a24a4905c950af19989b67424175234963da" translate="yes" xml:space="preserve">
          <source>The optional expression that occurs in between the CASE keyword and the first WHEN keyword is called the &quot;base&quot; expression. There are two fundamental forms of the CASE expression: those with a base expression and those without.</source>
          <target state="translated">CASE キーワードと最初の WHEN キーワードの間に発生するオプション式は、「ベース」式と呼ばれます。CASE 式には、基本的にベース式を持つものと持たないものの 2 つの形式があります。</target>
        </trans-unit>
        <trans-unit id="b46109c9ae9c950c43fe7007d16547e58baf09ab" translate="yes" xml:space="preserve">
          <source>The optional shared cache and memory management features that were introduced in version 3.3.0 can now be used across multiple threads within the same process. Formerly, these extensions only applied to database connections operating within a single thread.</source>
          <target state="translated">バージョン3.3.0で導入されたオプションの共有キャッシュとメモリ管理機能は、同じプロセス内の複数のスレッドで使用できるようになりました。以前は、これらの拡張機能は単一のスレッド内で動作するデータベース接続にのみ適用されていました。</target>
        </trans-unit>
        <trans-unit id="095e758e6c75bd1010500f9c5cbf1c0112ebeaf1" translate="yes" xml:space="preserve">
          <source>The order of evaluation of function arguments.</source>
          <target state="translated">関数の引数の評価順序。</target>
        </trans-unit>
        <trans-unit id="671d3f63e428cbeb09358473179412be4940924b" translate="yes" xml:space="preserve">
          <source>The order of keys in an index b-tree is determined by the sort order of the records that the keys represent. Record comparison progresses column by column. Columns of a record are examined from left to right. The first pair of columns that are not equal determines the relative order of the two records. The sort order of individual columns is as follows:</source>
          <target state="translated">インデックス b-tree のキーの順序は、キーが表すレコードのソート順によって決定されます。レコードの比較は、カラムごとに進行する。レコードの列は、左から右へと検査されます。等しくない列の最初のペアが、2 つのレコードの相対的な順序を決定します。個々のカラムのソート順は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="2b489797ae43740676c30370f9b2ea776aa65877" translate="yes" xml:space="preserve">
          <source>The order of tables in a join is adjusted automatically to make better use of indices</source>
          <target state="translated">結合のテーブルの順序は、インデックスをよりよく利用するために自動的に調整されます。</target>
        </trans-unit>
        <trans-unit id="140f29de259bdc1e34708f12946df0112e292cdd" translate="yes" xml:space="preserve">
          <source>The order of the buffer pointer and buffer size parameters in the built-in snprintf() implementation is reversed from the order used in standard-library implementations.</source>
          <target state="translated">組み込みの snprintf()の実装におけるバッファポインタとバッファサイズパラメータの順序は、標準ライブラリの実装で使用されている順序とは逆になります。</target>
        </trans-unit>
        <trans-unit id="5e9268cc64b3aabab9ece14a89f94084ddd4b3cc" translate="yes" xml:space="preserve">
          <source>The order of the columns in the data_% table does not matter.</source>
          <target state="translated">data_%テーブルのカラムの順番は関係ありません。</target>
        </trans-unit>
        <trans-unit id="b1b615b19c9501777b15d4388be1e80320f4db76" translate="yes" xml:space="preserve">
          <source>The order of the entries indicates the nesting order. In this case, the scan of table t1 using index i2 is the outer loop (since it appears first) and the full-table scan of table t2 is the inner loop (since it appears last). In the following example, the positions of t1 and t2 in the FROM clause of the SELECT are reversed. The query strategy remains the same. The output from EXPLAIN QUERY PLAN shows how the query is actually evaluated, not how it is specified in the SQL statement.</source>
          <target state="translated">エントリの順序は入れ子の順序を示す。この場合、インデックスi2を使用したテーブルt1のスキャンは外側のループ(最初に現れるので)であり、テーブルt2のフルテーブルスキャンは内側のループ(最後に現れるので)です。次の例では、SELECTのFROM句のt1とt2の位置が逆になっています。クエリ戦略は変わりません。EXPLAIN QUERY PLANからの出力は、SQL文で指定された方法ではなく、実際にクエリがどのように評価されるかを示しています。</target>
        </trans-unit>
        <trans-unit id="70ac1e5ab36762649806ee198f0345318ef8e4bd" translate="yes" xml:space="preserve">
          <source>The orderByConsumed means that output from &lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;/&lt;a href=&quot;../vtab#xnext&quot;&gt;xNext&lt;/a&gt; will occur in the correct order to satisfy the ORDER BY clause so that no separate sorting step is required.</source>
          <target state="translated">orderByConsumedは、&lt;a href=&quot;../vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; / &lt;a href=&quot;../vtab#xnext&quot;&gt;xNext&lt;/a&gt;からの出力が正しい順序で発生し、ORDER BY句を満たすため、個別の並べ替え手順が不要になることを意味します。</target>
        </trans-unit>
        <trans-unit id="a4ee366293d58487c3c181ee97d4fddeec053e83" translate="yes" xml:space="preserve">
          <source>The orderByConsumed means that output from &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;/&lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; will occur in the correct order to satisfy the ORDER BY clause so that no separate sorting step is required.</source>
          <target state="translated">orderByConsumedは、&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; / &lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt;からの出力が正しい順序で発生し、ORDER BY句を満たすため、個別の並べ替え手順が不要になることを意味します。</target>
        </trans-unit>
        <trans-unit id="361a689885e1ba1224dc1550da95ae3bd8151f01" translate="yes" xml:space="preserve">
          <source>The original UTF8 text of the vocabulary word</source>
          <target state="translated">単語の元のUTF8テキスト</target>
        </trans-unit>
        <trans-unit id="8f218b03066661856e3cf8a761cc5ae4bbd68ed0" translate="yes" xml:space="preserve">
          <source>The original document we put here was more of a &lt;a href=&quot;codeofethics&quot;&gt;Code of Ethics of the Project Founder&lt;/a&gt;. While we stand by those principles, they are not in line with the modern technical meaning of a Code of Conduct and have hence been renamed.</source>
          <target state="translated">ここに置いた元の文書は&lt;a href=&quot;codeofethics&quot;&gt;、プロジェクト創設者の倫理規定&lt;/a&gt;に近いものでした。私たちはそれらの原則を支持していますが、それらは行動規範の現代の技術的な意味と一致していないため、名前が変更されました。</target>
        </trans-unit>
        <trans-unit id="c32bb1620d101b8c498092185971e74a9cc27eb4" translate="yes" xml:space="preserve">
          <source>The original implementation of SQLite sought to follow &lt;a href=&quot;https://en.wikipedia.org/wiki/Robustness_principle&quot;&gt;Postel's Law&lt;/a&gt; which states in part &quot;Be liberal in what you accept&quot;. This used to be considered good design - that a system would accept dodgy inputs and try to do the best it could without complaining too much. But lately, people have come to realize that it is sometimes better to be strict in what you accept, so as to more easily find errors in the input.</source>
          <target state="translated">SQLiteの最初の実装は、「受け入れるものを自由にする」ことを部分的に述べる&lt;a href=&quot;https://en.wikipedia.org/wiki/Robustness_principle&quot;&gt;Postelの法則&lt;/a&gt;に従うことを目指していました。これは以前は優れた設計と見なされていました。システムは危険な入力を受け入れ、あまり文句を言わずに最善を尽くそうとするものでした。しかし、最近では、入力のエラーをより簡単に見つけるために、受け入れる内容を厳密にするほうがよい場合があることに気づくようになりました。</target>
        </trans-unit>
        <trans-unit id="faed9cec852456e57ebf990afb4cf1cac2f27e57" translate="yes" xml:space="preserve">
          <source>The original values for each modified field of the row.</source>
          <target state="translated">行の各変更されたフィールドの元の値。</target>
        </trans-unit>
        <trans-unit id="2a41f1df0018eecb7b908d40c9986e3b87989e32" translate="yes" xml:space="preserve">
          <source>The original values of any modified fields are omitted from UPDATE records.</source>
          <target state="translated">変更されたフィールドの元の値は、UPDATEレコードからは省略されます。</target>
        </trans-unit>
        <trans-unit id="f1449473437f390f79738378e7abd93ce9be7fe0" translate="yes" xml:space="preserve">
          <source>The other advantage to using SQLite in place of ZIP is that the document can now be updated incrementally, without risk of corrupting the document if a power loss or other crash occurs in the middle of the update. (Remember that writes to &lt;a href=&quot;atomiccommit&quot;&gt;SQLite databases are atomic&lt;/a&gt;.) True, all the content is still kept in a single big XML file (&quot;content.xml&quot;) which must be completely rewritten if so much as a single character changes. But with SQLite, only that one file needs to change. The other 77 files in the repository can remain unaltered. They do not all have to be rewritten, which in turn makes &quot;File/Save&quot; run much faster and saves wear on SSDs.</source>
          <target state="translated">ZIPの代わりにSQLiteを使用するもう1つの利点は、更新中に電源喪失やその他のクラッシュが発生した場合にドキュメントを破損するリスクなしに、ドキュメントを段階的に更新できることです。 （&lt;a href=&quot;atomiccommit&quot;&gt;SQLiteデータベース&lt;/a&gt;への書き込みはアトミックであることを忘れないでください。）確かに、すべてのコンテンツは、単一の大きなXMLファイル（ &quot;content.xml&quot;）に保持され、単一の文字が変更された場合は完全に再書き込みする必要があります。しかし、SQLiteでは、その1つのファイルだけを変更する必要があります。リポジトリ内の他の77ファイルは変更されないままでかまいません。すべてを書き換える必要はありません。これにより、「ファイル/保存」の実行速度が大幅に向上し、SSDの消耗が抑えられます。</target>
        </trans-unit>
        <trans-unit id="ff8ed48a831b734ff6e1604276150ac99b9ac0e1" translate="yes" xml:space="preserve">
          <source>The other allowed parameters to sqlite3_mutex_alloc() (anything other than SQLITE_MUTEX_FAST and SQLITE_MUTEX_RECURSIVE) each return a pointer to a static preexisting mutex. Nine static mutexes are used by the current version of SQLite. Future versions of SQLite may add additional static mutexes. Static mutexes are for internal use by SQLite only. Applications that use SQLite mutexes should use only the dynamic mutexes returned by SQLITE_MUTEX_FAST or SQLITE_MUTEX_RECURSIVE.</source>
          <target state="translated">sqlite3_mutex_alloc()に許可されている他のパラメータ(SQLITE_MUTEX_FASTとSQLITE_MUTEX_RECURSIVE以外のもの)は、それぞれ既存の静的なミューテックスへのポインタを返します。現在のバージョンの SQLite では 9 個の静的なミューテックスが使用されています。将来のバージョンの SQLite では、さらに静的ミューテックスが追加される可能性があります。静的ミューテックスはSQLiteの内部でのみ使用されます。SQLite のミューテックスを使用するアプリケーションは、SQLITE_MUTEX_FAST または SQLITE_MUTEX_RECURSIVE で返される動的ミューテックスのみを使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="e68942fbbde7b9568017891360f3a9246030e2a2" translate="yes" xml:space="preserve">
          <source>The other file, &quot;fts5.h&quot;, is not required to compile the FTS5 extension. It is used by applications that implement &lt;a href=&quot;fts5#extending_fts5&quot;&gt;custom FTS5 tokenizers or auxiliary functions&lt;/a&gt;.</source>
          <target state="translated">他のファイル「fts5.h」は、FTS5拡張機能をコンパイルするために必要ではありません。これは、&lt;a href=&quot;fts5#extending_fts5&quot;&gt;カスタムFTS5トークナイザーまたは補助関数&lt;/a&gt;を実装するアプリケーションによって使用されます。</target>
        </trans-unit>
        <trans-unit id="f74c4fa3b3502ec3d363778205dc40519edfac8e" translate="yes" xml:space="preserve">
          <source>The other information required to create a changeset or patchset is read from the database file when &lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; or &lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset()&lt;/a&gt; is called. Specifically,</source>
          <target state="translated">変更セットまたはパッチセットの作成に必要なその他の情報は、&lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset（）&lt;/a&gt;または&lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset（）&lt;/a&gt;が呼び出されたときにデータベースファイルから読み取られます。具体的には</target>
        </trans-unit>
        <trans-unit id="4ceb7a7a69cfd1205ea5e7612f272fc9e42d8423" translate="yes" xml:space="preserve">
          <source>The outer SELECT is implemented by instructions 11 through 25. In particular, the WHERE clause containing the IN operator is implemented by instructions at 16, 17, and 20. Instruction 16 pushes the value of the &quot;two&quot; column for the current row onto the stack and instruction 17 checks to see that it is non-NULL. If this is successful, execution jumps to 20, where it tests to see if top of the stack matches any key in the temporary table. The rest of the code is the same as what has been shown before.</source>
          <target state="translated">外側のSELECTは、命令11〜25によって実装される。特に、IN演算子を含むWHERE句は、命令16、17、および20によって実装される。命令16は現在の行の「2」列の値をスタックにプッシュし、命令17はそれがNULLでないことを確認します。これが成功した場合、実行は 20 にジャンプし、スタックの先頭が一時テーブルのキーと一致するかどうかをテストします。残りのコードは以前に示したものと同じです。</target>
        </trans-unit>
        <trans-unit id="636166e4ba0668356d630c0a9cb37eba4fcc8c00" translate="yes" xml:space="preserve">
          <source>The outer SELECT is implemented by instructions 14 through 25. In particular, the WHERE clause that contains the nested select is implemented by instructions 19 through 21. You can see that the result of the inner select is loaded onto the stack by instruction 20 and used by the conditional jump at 21.</source>
          <target state="translated">外側のSELECTは、命令14〜25によって実装される。特に、入れ子になったSELECTを含むWHERE句は、命令19から21までによって実装されています。内側のSELECTの結果は、命令20によってスタックにロードされ、21での条件ジャンプによって使用されることがわかります。</target>
        </trans-unit>
        <trans-unit id="fcdaf6e60b18b913fe64114ea32692d007183ab8" translate="yes" xml:space="preserve">
          <source>The outer loop over table examp is implement by instructions 7 through 23. The inner loop is instructions 13 through 22. Notice that the &quot;two&amp;lt;50&quot; term of the WHERE expression involves only columns from the first table and can be factored out of the inner loop. SQLite does this and implements the &quot;two&amp;lt;50&quot; test in instructions 10 through 12. The &quot;four==two&quot; test is implement by instructions 14 through 16 in the inner loop.</source>
          <target state="translated">テーブル試験の外側のループは、命令7〜23によって実装されます。内側のループは、命令13〜22です。WHERE式の「two &amp;lt;50」項には、最初のテーブルの列のみが含まれ、内部ループ。 SQLiteはこれを行い、命令10から12で「two &amp;lt;50」テストを実装します。「four == two」テストは、内部ループの命令14から16で実装されます。</target>
        </trans-unit>
        <trans-unit id="0e7b99d6dfc2b5d85e34f55e3ea4da579b189034" translate="yes" xml:space="preserve">
          <source>The output begins with a report of the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; (cross-checked again &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt;) for the SQLite under test and the compile-time options used as reported by &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get()&lt;/a&gt;. The output concludes with a summary of the test results and a repeat of the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;. If any errors are detected, additional lines detail the problem. The error reporting lines always begin with a single space character so that they can be quickly extracted from large output files using:</source>
          <target state="translated">出力のレポートから始まる&lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;（クロスチェック再び&lt;a href=&quot;c3ref/libversion&quot;&gt;（sqlite3_sourceid）&lt;/a&gt;試験下SQLiteのための）によって報告されたように使用されるコンパイル時オプション&lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get（） &lt;/a&gt;。出力は、テスト結果の要約と&lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_IDの&lt;/a&gt;繰り返しで終わります。エラーが検出された場合、追加の行に問題の詳細が示されます。エラー報告行は常に単一のスペース文字で始まるため、次のコマンドを使用して大きな出力ファイルからすばやく抽出できます。</target>
        </trans-unit>
        <trans-unit id="b2295d00e027ddb605dbb2cc9b7646825272b788" translate="yes" xml:space="preserve">
          <source>The output from EXPLAIN and EXPLAIN QUERY PLAN is intended for interactive analysis and troubleshooting only. The details of the output format are subject to change from one release of SQLite to the next. Applications should not use EXPLAIN or EXPLAIN QUERY PLAN since their exact behavior is variable and only partially documented.</source>
          <target state="translated">EXPLAINおよびEXPLAIN QUERY PLANからの出力は、対話的な分析およびトラブルシューティングのみを目的としています。出力形式の詳細は、SQLiteのあるリリースから次のリリースへと変更される可能性があります。アプリケーションは、EXPLAINやEXPLAIN QUERY PLANの正確な動作は可変であり、部分的にしか文書化されていないため、EXPLAINやEXPLAIN QUERY PLANを使用しないでください。</target>
        </trans-unit>
        <trans-unit id="235163a8fba9aa1445cd051f01c741ea66911c96" translate="yes" xml:space="preserve">
          <source>The output from the &lt;a href=&quot;https://sqlite.org/src/file/tool/cg_anno.tcl&quot;&gt;cg_anno.tcl&lt;/a&gt; script shows the number of CPU cycles spent on each line of code. The report is approximately 80,000 lines long. The following is a brief snippet taken from the middle of the report to show what it looks like:</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/tool/cg_anno.tcl&quot;&gt;cg_anno.tcl&lt;/a&gt;スクリプトからの出力は、コードの各行に費やされたCPUサイクルの数を示しています。レポートの長さは約80,000行です。以下は、レポートの中央から抜粋した短いスニペットで、その外観を示しています。</target>
        </trans-unit>
        <trans-unit id="4c55fd24704ccac9a200bb25fe01e36a7bd6347b" translate="yes" xml:space="preserve">
          <source>The output from the mkth3.tcl script is a C program that contains everything needed to run the tests - everything that is except for the SQLite library itself. The generated test program contains implementations for all of the support interfaces used by the test modules and it contains the &lt;code&gt;main()&lt;/code&gt; routine that drives the tests. To convert the test program into a working executable, simply compile it against SQLite:</source>
          <target state="translated">mkth3.tclスクリプトからの出力は、テストの実行に必要なすべてのもの（SQLiteライブラリ自体を除くすべて）を含むCプログラムです。生成されたテストプログラムには、テストモジュールで使用されるすべてのサポートインターフェイスの実装が含まれ、テストを実行する &lt;code&gt;main()&lt;/code&gt; ルーチンが含まれます。テストプログラムを実行可能な実行可能ファイルに変換するには、SQLiteに対してコンパイルするだけです。</target>
        </trans-unit>
        <trans-unit id="abe6a29295e5add598505fe98eb212b9e3e6e910" translate="yes" xml:space="preserve">
          <source>The output is a human-readable ASCII text report that provides information on the space utilization of the database file. The report is intended to be self-explanatory, though there is some &lt;a href=&quot;sqlanalyze#defs&quot;&gt;additional explanation&lt;/a&gt; of the various parameters reported toward the end of the report.</source>
          <target state="translated">出力は、データベースファイルのスペース使用率に関する情報を提供する、人間が読めるASCIIテキストレポートです。レポートの説明はわかりやすいように意図されていますが、レポートの終わりに向けて報告されたさまざまなパラメーターの&lt;a href=&quot;sqlanalyze#defs&quot;&gt;説明&lt;/a&gt;がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="89607a5138078e5c86fca97ee25682b106679c11" translate="yes" xml:space="preserve">
          <source>The output is also valid SQL. Most of the report text is contained within a header comment, with various SQL statements that create and initialize a database at the &lt;a href=&quot;sqlanalyze#sqlx&quot;&gt;end of the report&lt;/a&gt;. The constructed database contains the raw data from which the report was extracted. Hence the original report can be read into an instance of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; and then the raw data can be queried to dig deeper into the space utilization of a particular database file.</source>
          <target state="translated">出力も有効なSQLです。ほとんどのレポートテキストは、レポートの&lt;a href=&quot;sqlanalyze#sqlx&quot;&gt;最後に&lt;/a&gt;データベースを作成および初期化するさまざまなSQLステートメントとともに、ヘッダーコメント内に含まれています。構築されたデータベースには、レポートが抽出された元のデータが含まれています。したがって、元のレポートを&lt;a href=&quot;cli&quot;&gt;コマンドラインシェルの&lt;/a&gt;インスタンスに読み込んでから、生データをクエリして、特定のデータベースファイルのスペース使用率をさらに詳しく調べることができます。</target>
        </trans-unit>
        <trans-unit id="bcfd95781cb98e2851bb0886cd3f1a588c682428" translate="yes" xml:space="preserve">
          <source>The output of &lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; now shows each individual SQL statement run within a trigger.</source>
          <target state="translated">&lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;の出力に、トリガー内で実行された個々のSQLステートメントが表示されるようになりました。</target>
        </trans-unit>
        <trans-unit id="2d09f331aa1d428bbd3337e80bd418ed5659e816" translate="yes" xml:space="preserve">
          <source>The output of this revised query is:</source>
          <target state="translated">この修正されたクエリの出力は</target>
        </trans-unit>
        <trans-unit id="e3541aa5b140ee88f1e6bb5e89e08e8618d880af" translate="yes" xml:space="preserve">
          <source>The outputs s0 and s1 are both weighted checksums using Fibonacci weights in reverse order. (The largest Fibonacci weight occurs on the first element of the sequence being summed.) The s1 value spans all 32-bit integer terms of the sequence whereas s0 omits the final term.</source>
          <target state="translated">出力 s0 と s1 は、逆順にフィボナッチ重みを使用した重み付きチェックサムです。(最大のフィボナッチ重みは、合計されるシーケンスの最初の要素で発生します)。s1の値はシーケンスのすべての32ビット整数項に及びますが、s0は最終項を省略しています。</target>
        </trans-unit>
        <trans-unit id="2d1abc65d901f9a5d25ea3d57ab5dd49e8f85287" translate="yes" xml:space="preserve">
          <source>The overflow thresholds are designed to give a minimum fanout of 4 for index b-trees and to make sure enough of the payload is on the b-tree page that the record header can usually be accessed without consulting an overflow page. In hindsight, the designer of the SQLite b-tree logic realized that these thresholds could have been made much simpler. However, the computations cannot be changed without resulting in an incompatible file format. And the current computations work well, even if they are a little complex.</source>
          <target state="translated">オーバーフローしきい値は、インデックス b-tree の最小ファンアウトが 4 になるように設計されており、ペイロードが b-tree ページに十分にあることを確認して、通常はオーバーフローページを参照せずにレコードヘッダーにアクセスできるようになっています。今にして思えば、SQLite の b-tree ロジックの設計者は、これらのしきい値をもっとシンプルにできたかもしれないことに気づきました。しかし、互換性のないファイル形式になることなく計算を変更することはできません。そして、現在の計算は、多少複雑であってもうまく機能しています。</target>
        </trans-unit>
        <trans-unit id="ac70d959175f460608260178c8989bd26b78e65e" translate="yes" xml:space="preserve">
          <source>The pAppData pointer is unused by the SQLite core. The pointer is available to store auxiliary information that a VFS information might want to carry around.</source>
          <target state="translated">pAppData ポインタは SQLite コアでは使用されません。このポインタは、VFS 情報が持ち歩きたいと思うような補助情報を格納するために使用できます。</target>
        </trans-unit>
        <trans-unit id="18730b00ae23b4c106f1118f96d5a509058fa368" translate="yes" xml:space="preserve">
          <source>The pBuf parameter is a pointer to a contiguous range of bytes that SQLite will use for page-cache memory allocations. The buffer must be at least sz*N bytes in size. The &quot;sz&quot; parameter is the size of each page-cache allocation. N is the maximum number of available allocations.</source>
          <target state="translated">pBuf パラメータは、SQLite がページキャッシュメモリの割り当てに使用する連続したバイト数の範囲へのポインタです。バッファのサイズは最低でも sz*N バイトでなければなりません。sz&quot; パラメータは、各ページキャッシュの割り当てのサイズです。N は利用可能な割り当ての最大数です。</target>
        </trans-unit>
        <trans-unit id="ac154834d9f47915a3416a80860f0b58cefd5585" translate="yes" xml:space="preserve">
          <source>The pContext member of the sqlite3_rtree_geometry structure is always set to a copy of the pContext argument passed to sqlite3_rtree_geometry_callback() when the callback is registered. The aParam[] array (size nParam) contains the parameter values passed to the SQL function on the right-hand side of the MATCH operator. In the example &quot;circle&quot; query above, nParam would be set to 3 and the aParam[] array would contain the three values 45.3, 22.9 and 5.0.</source>
          <target state="translated">sqlite3_rtree_geometry構造体のpContextメンバには、コールバックが登録されているときは常にsqlite3_rtree_geometry_callback()に渡されたpContext引数のコピーが設定されています。aParam[]配列(サイズnParam)には、MATCH演算子の右側にあるSQL関数に渡されたパラメータ値が含まれています。上の例の &quot;circle &quot;クエリでは、nParamは3に設定され、aParam[]配列には45.3、22.9、5.0の3つの値が含まれています。</target>
        </trans-unit>
        <trans-unit id="e127dc3dcbbc20bee3b0cdc450a4bea7c1e6776f" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;. If this is not the case, this function returns &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;.</source>
          <target state="translated">この関数に渡されるpIter引数は、&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt;によって競合ハンドラに渡されるイテレータ、または&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;によって作成されるイテレータのいずれかです。後者の場合には、最も最近の呼び出し&lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）が&lt;/a&gt;返されている必要があります&lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROWを&lt;/a&gt;。そうでない場合、この関数は&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSEを&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="135aebf5a9dd2b851dadacfebf43a14b9409aa81" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned SQLITE_ROW. Furthermore, it may only be called if the type of change that the iterator currently points to is either &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;. Otherwise, this function returns &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; and sets *ppValue to NULL.</source>
          <target state="translated">この関数に渡されるpIter引数は、&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt;によって競合ハンドラに渡されるイテレータ、または&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;によって作成されるイテレータのいずれかです。後者の場合、&lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）&lt;/a&gt;への最新の呼び出しでSQLITE_ROWが返されているはずです。さらに、イテレータが現在指している変更のタイプが&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;または&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATEの&lt;/a&gt;いずれかである場合にのみ呼び出されます。それ以外の場合、この関数は&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;を返し、* ppValueをNULLに設定します。</target>
        </trans-unit>
        <trans-unit id="47ae6763d58288a12e6ca470cf923677f0731f46" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned SQLITE_ROW. Furthermore, it may only be called if the type of change that the iterator currently points to is either &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;. Otherwise, this function returns &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; and sets *ppValue to NULL.</source>
          <target state="translated">この関数に渡されるpIter引数は、&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt;によって競合ハンドラに渡されるイテレータ、または&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;によって作成されるイテレータのいずれかです。後者の場合、&lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）&lt;/a&gt;への最新の呼び出しでSQLITE_ROWが返されているはずです。さらに、イテレータが現在ポイントしている変更のタイプが&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;または&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_INSERTの&lt;/a&gt;いずれかである場合にのみ呼び出されます。それ以外の場合、この関数は&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;を返し、* ppValueをNULLに設定します。</target>
        </trans-unit>
        <trans-unit id="5f4815a3e637ae9700d2b5b8cf01f7df97a164dc" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;. If this is not the case, this function returns &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;.</source>
          <target state="translated">この関数に渡されるpIter引数は、&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt;によって競合ハンドラに渡されるイテレータ、または&lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;によって作成されるイテレータのいずれかです。後者の場合には、最も最近の呼び出し&lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）が&lt;/a&gt;返されている必要があります&lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROWを&lt;/a&gt;。そうでない場合、この関数は&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSEを&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="5cb49779aa9657ac4af96a2c62fd60bce7011cad" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned SQLITE_ROW. Furthermore, it may only be called if the type of change that the iterator currently points to is either &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; or &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;. Otherwise, this function returns &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; and sets *ppValue to NULL.</source>
          <target state="translated">この関数に渡されるpIter引数は、&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt;によって競合ハンドラに渡されるイテレータ、または&lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;によって作成されるイテレータのいずれかです。後者の場合、&lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）&lt;/a&gt;への最新の呼び出しでSQLITE_ROWが返されているはずです。さらに、イテレータが現在指している変更のタイプが&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;または&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATEの&lt;/a&gt;いずれかである場合にのみ呼び出されます。それ以外の場合、この関数は&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;を返し、* ppValueをNULLに設定します。</target>
        </trans-unit>
        <trans-unit id="836812d109e0eaaadd1e45a40c1311bde5cb7d98" translate="yes" xml:space="preserve">
          <source>The pIter argument passed to this function may either be an iterator passed to a conflict-handler by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, or an iterator created by &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. In the latter case, the most recent call to &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; must have returned SQLITE_ROW. Furthermore, it may only be called if the type of change that the iterator currently points to is either &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; or &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;. Otherwise, this function returns &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; and sets *ppValue to NULL.</source>
          <target state="translated">この関数に渡されるpIter引数は、&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt;によって競合ハンドラに渡されるイテレータ、または&lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;によって作成されるイテレータのいずれかです。後者の場合、&lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）&lt;/a&gt;への最新の呼び出しでSQLITE_ROWが返されているはずです。さらに、イテレータが現在ポイントしている変更のタイプが&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;または&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_INSERTの&lt;/a&gt;いずれかである場合にのみ呼び出されます。それ以外の場合、この関数は&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;を返し、* ppValueをNULLに設定します。</target>
        </trans-unit>
        <trans-unit id="87ffccb080e4ff9265c31827b97ddd2621e463bc" translate="yes" xml:space="preserve">
          <source>The pNext field is the only field in the sqlite3_vfs structure that SQLite will ever modify. SQLite will only access or modify this field while holding a particular static mutex. The application should never modify anything within the sqlite3_vfs object once the object has been registered.</source>
          <target state="translated">pNextフィールドはsqlite3_vfs構造体の中でSQLiteが変更する唯一のフィールドです。SQLiteは特定の静的ミューテックスを保持している間だけこのフィールドにアクセスしたり、変更したりします。オブジェクトが登録された後は、アプリケーションはsqlite3_vfsオブジェクト内の何かを変更してはいけません。</target>
        </trans-unit>
        <trans-unit id="754388a17b97b997745df633f79a8efeaffaaacb" translate="yes" xml:space="preserve">
          <source>The pNext field is used internally by SQLite. Specifically, SQLite uses this field to form a linked list of registered VFSes.</source>
          <target state="translated">pNext フィールドは、SQLite によって内部的に使用されます。具体的には、SQLite はこのフィールドを使用して、登録された VFS のリンクされたリストを形成します。</target>
        </trans-unit>
        <trans-unit id="ed269faa072ea0bc301321c2683b96864943c28b" translate="yes" xml:space="preserve">
          <source>The pUser and xDelUser members of the sqlite3_rtree_geometry structure are initially set to NULL. The pUser variable may be set by the callback implementation to any arbitrary value that may be useful to subsequent invocations of the callback within the same query (for example, a pointer to a complicated data structure used to test for region intersection). If the xDelUser variable is set to a non-NULL value, then after the query has finished running SQLite automatically invokes it with the value of the pUser variable as the only argument. In other words, xDelUser may be set to a destructor function for the pUser value.</source>
          <target state="translated">sqlite3_rtree_geometry構造体のpUserとxDelUserメンバは初期状態ではNULLに設定されます。pUser変数は、コールバックの実装によって任意の値に設定することができ、同じクエリ内でコールバックを呼び出す際に役立ちます(例えば、領域の交差をテストするために使用される複雑なデータ構造へのポインタなど)。xDelUser変数にNULLではない値が設定されている場合、クエリの実行が終了すると、SQLiteは自動的にpUser変数の値を唯一の引数としてコールバックを呼び出します。言い換えれば、xDelUser は pUser の値に対してデストラクタ関数に設定されている可能性があります。</target>
        </trans-unit>
        <trans-unit id="17b3e72d28371d5d2ffa9ec67e0ffe035454e59f" translate="yes" xml:space="preserve">
          <source>The page cache allocates from its own memory pool supplied by &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;,...) rather than from the heap.</source>
          <target state="translated">ページキャッシュは、ヒープからではなく、&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;、...）によって提供される独自のメモリプールから割り当てます。</target>
        </trans-unit>
        <trans-unit id="c49923490f20015de5b3c1344ee709093d18e9ac" translate="yes" xml:space="preserve">
          <source>The page cache allocates from its own memory pool supplied by &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;,...) rather than from the heap.</source>
          <target state="translated">ページキャッシュは、ヒープからではなく、&lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;、...）によって提供される独自のメモリプールから割り当てます。</target>
        </trans-unit>
        <trans-unit id="a302370f325aa6580998e916c1cd813d2e0b53c6" translate="yes" xml:space="preserve">
          <source>The page number in the database file</source>
          <target state="translated">データベースファイルのページ番号</target>
        </trans-unit>
        <trans-unit id="cb3defd1f8ac1da0588e9ad79d27848df6931c39" translate="yes" xml:space="preserve">
          <source>The page number of the database page associated with this</source>
          <target state="translated">この</target>
        </trans-unit>
        <trans-unit id="0780190de9ffbf4345610e2662e0abd5cdf52be0" translate="yes" xml:space="preserve">
          <source>The page number of the database page for the current row</source>
          <target state="translated">現在の行のデータベースページのページ番号</target>
        </trans-unit>
        <trans-unit id="5d2ed89da4b6a6d4a6521b481ff6c43d5bdf9213" translate="yes" xml:space="preserve">
          <source>The page number of the largest root b-tree page when in auto-vacuum or incremental-vacuum modes, or zero otherwise.</source>
          <target state="translated">自動バキュームモードまたはインクリメンタルバキュームモードの場合は最大のルートb-treeページのページ番号、そうでない場合は0です。</target>
        </trans-unit>
        <trans-unit id="9a28509eee63401403c2ae3763725cac2ca99893" translate="yes" xml:space="preserve">
          <source>The page number of the page on which this row was found.</source>
          <target state="translated">この行が発見されたページのページ番号です。</target>
        </trans-unit>
        <trans-unit id="41b015c66ddae0dbc3440c640484bd01738dbaf6" translate="yes" xml:space="preserve">
          <source>The page size and cache size can also be set or changed at run-time using the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size pragma&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size pragma&lt;/a&gt;, respectively.</source>
          <target state="translated">ページサイズとキャッシュサイズは、それぞれ&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_sizeプラグマ&lt;/a&gt;と&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_sizeプラグマ&lt;/a&gt;を使用して、実行時に設定または変更することもできます。</target>
        </trans-unit>
        <trans-unit id="0105846f7fbf6f81d53292a1128d1e82d5804983" translate="yes" xml:space="preserve">
          <source>The page to be fetched is determined by the key. The minimum key value is 1. After it has been retrieved using xFetch, the page is considered to be &quot;pinned&quot;.</source>
          <target state="translated">フェッチされるページは、キーによって決定されます。キーの最小値は1で、xFetchで取得された後、そのページは &quot;ピン留めされている &quot;とみなされます。</target>
        </trans-unit>
        <trans-unit id="ae6ce89a0e7b046f1218400c05d873074d2788d0" translate="yes" xml:space="preserve">
          <source>The page-cache memory allocator is disabled by default. An application can enable it at start-time as follows:</source>
          <target state="translated">ページキャッシュメモリアロケータはデフォルトでは無効になっています。アプリケーションは、以下のように起動時に有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="79944cfbe90583fe884c628acc92c56b549b69ab" translate="yes" xml:space="preserve">
          <source>The pager and btree subsystems added back. They are now the only available backend.</source>
          <target state="translated">ページャーとbtreeサブシステムが追加されました。これらは現在、唯一の利用可能なバックエンドとなっています。</target>
        </trans-unit>
        <trans-unit id="177ac3877a5c726efa0192a81b9a621bfc8aa28e" translate="yes" xml:space="preserve">
          <source>The pager is unconcerned with the details of B-Trees, text encodings, indices, and so forth. From the point of view of the pager the database consists of a single file of uniform-sized blocks. Each block is called a &quot;page&quot; and is usually 1024 bytes in size. The pages are numbered beginning with 1. So the first 1024 bytes of the database are called &quot;page 1&quot; and the second 1024 bytes are call &quot;page 2&quot; and so forth. All other encoding details are handled by higher layers of the library. The pager communicates with the operating system using one of several modules (Examples: &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/os_unix.c&quot;&gt; os_unix.c&lt;/a&gt;, &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/os_win.c&quot;&gt; os_win.c&lt;/a&gt;) that provides a uniform abstraction for operating system services.</source>
          <target state="translated">ページャーは、Bツリー、テキストエンコーディング、インデックスなどの詳細に関心がありません。ページャーの観点から見ると、データベースは均一サイズのブロックの単一ファイルで構成されています。各ブロックは「ページ」と呼ばれ、通常サイズは1024バイトです。ページには1から始まる番号が付けられています。したがって、データベースの最初の1024バイトは「ページ1」と呼ばれ、2番目の1024バイトは「ページ2」と呼ばれます。他のすべてのエンコーディングの詳細は、ライブラリの上位層で処理されます。ページャーは、オペレーティングシステムサービスに統一された抽象化を提供するいくつかのモジュール（例：&lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt;、&lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/os_win.c&quot;&gt;os_win.c&lt;/a&gt;）の1つを使用して、オペレーティングシステムと通信します。</target>
        </trans-unit>
        <trans-unit id="5acaa405b470e4fb9ef36344daf0f015a3d5bf69" translate="yes" xml:space="preserve">
          <source>The pager module effectively controls access for separate threads, or separate processes, or both. Throughout this document whenever the word &quot;process&quot; is written you may substitute the word &quot;thread&quot; without changing the truth of the statement.</source>
          <target state="translated">ページャーモジュールは、別々のスレッド、あるいは別々のプロセス、あるいはその両方へのアクセスを効果的に制御します。この文書中では、&quot;process&quot; という単語が書かれているときはいつでも、文の真偽を変えることなく &quot;thread&quot; という単語で代用することができます。</target>
        </trans-unit>
        <trans-unit id="3fbaa9934c130eb17f7eada7403c9132c86bbc58" translate="yes" xml:space="preserve">
          <source>The pager module is very robust but it can be subverted. This section attempts to identify and explain the risks. (See also the &lt;a href=&quot;atomiccommit#sect_9_0&quot;&gt;Things That Can Go Wrong&lt;/a&gt; section of the article on &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit&lt;/a&gt;.</source>
          <target state="translated">ページャーモジュールは非常に堅牢ですが、破壊される可能性があります。このセクションでは、リスクの特定と説明を試みます。（&lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit&lt;/a&gt;に関する記事の&lt;a href=&quot;atomiccommit#sect_9_0&quot;&gt;間違っている可能性のある&lt;/a&gt;セクションも参照してください。</target>
        </trans-unit>
        <trans-unit id="0f15cdebe573fd03148e855390c11255190632e7" translate="yes" xml:space="preserve">
          <source>The paragraph above notes that a MATCH operator with a simple term as the right-hand operand evaluates to true for all documents that contain the specified term. In this context, the &quot;document&quot; may refer to either the data stored in a single column of a row of an FTS table, or to the contents of all columns in a single row, depending on the identifier used as the left-hand operand to the MATCH operator. If the identifier specified as the left-hand operand of the MATCH operator is an FTS table column name, then the document that the search term must be contained in is the value stored in the specified column. However, if the identifier is the name of the FTS</source>
          <target state="translated">上の段落では、右手のオペランドとして単純な用語を持つMATCH演算子は、指定された用語を含むすべての文書に対して真として評価されることに注意してください。この文脈では、「文書」は、MATCH演算子への左手オペランドとして使用される識別子に応じて、FTSテーブルの行の単一の列に格納されたデータ、または単一の行のすべての列の内容のいずれかを参照することができる。MATCH演算子の左側のオペランドとして指定された識別子がFTSテーブルの列名である場合、検索語が含まれなければならない文書は、指定された列に格納されている値である。ただし、識別子がFTS</target>
        </trans-unit>
        <trans-unit id="15582287ef68bc76059b207ebd8e45ad35a9f199" translate="yes" xml:space="preserve">
          <source>The parameter P is passed through as the only parameter to the callback function X. The parameter N is the approximate number of &lt;a href=&quot;../opcode&quot;&gt;virtual machine instructions&lt;/a&gt; that are evaluated between successive invocations of the callback X. If N is less than one then the progress handler is disabled.</source>
          <target state="translated">パラメーターPは、コールバック関数Xへの唯一のパラメーターとして渡されます。パラメーターNは、コールバックXの連続した呼び出し間で評価される&lt;a href=&quot;../opcode&quot;&gt;仮想マシン命令の&lt;/a&gt;おおよその数です。Nが1未満の場合、進行状況ハンドラーは無効になります。</target>
        </trans-unit>
        <trans-unit id="de8aa7c163a7cfc0e81022005dde253ed27f9cea" translate="yes" xml:space="preserve">
          <source>The parameter P is passed through as the only parameter to the callback function X. The parameter N is the approximate number of &lt;a href=&quot;opcode&quot;&gt;virtual machine instructions&lt;/a&gt; that are evaluated between successive invocations of the callback X. If N is less than one then the progress handler is disabled.</source>
          <target state="translated">パラメーターPは、コールバック関数Xへの唯一のパラメーターとして渡されます。パラメーターNは、コールバックXの連続した呼び出し間で評価される&lt;a href=&quot;opcode&quot;&gt;仮想マシン命令の&lt;/a&gt;おおよその数です。Nが1未満の場合、進行状況ハンドラーは無効になります。</target>
        </trans-unit>
        <trans-unit id="b6a1b97180e82088f349d801a8feb225d5ea8536" translate="yes" xml:space="preserve">
          <source>The parameters to the callback are the pArg value, the amount of memory currently in use, and the size of the allocation that provoked the callback. The callback will presumably invoke &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; to free up memory space. The callback may invoke &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc()&lt;/a&gt; but if it does, no additional callbacks will be invoked by the recursive calls.</source>
          <target state="translated">コールバックのパラメーターは、pArg値、現在使用中のメモリの量、およびコールバックを引き起こした割り当てのサイズです。コールバックはおそらく&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;を呼び出してメモリ空間を解放します。コールバックは&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;または&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc（）を&lt;/a&gt;呼び出すことができますが、呼び出す場合、再帰呼び出しによって追加のコールバックは呼び出されません。</target>
        </trans-unit>
        <trans-unit id="a0635b4b828516772af2e4a5c5f8f7c2b0b83854" translate="yes" xml:space="preserve">
          <source>The parent and sub-query may contain WHERE clauses. Subject to rules (11), (12) and (13), they may also contain ORDER BY, LIMIT and OFFSET clauses.</source>
          <target state="translated">親問い合わせおよび副問い合わせはWHERE句を含むことができます。規則(11)、(12)および(13)に従って、それらはORDER BY、LIMITおよびOFFSET句を含むことができます。</target>
        </trans-unit>
        <trans-unit id="6d5030cd0c93ffa44cd5f784ea6b109c2ce36ffc" translate="yes" xml:space="preserve">
          <source>The parent key columns named in the foreign key constraint are not the primary key of the parent table and are not subject to a unique constraint using collating sequence specified in the CREATE TABLE, or</source>
          <target state="translated">外部キー制約で指定された親キー列は、親テーブルの主キーではなく、CREATE TABLEで指定された照合順序を使用した一意の制約の対象ではない、または</target>
        </trans-unit>
        <trans-unit id="0feae637448fae26652f631fd44b61bcd440968a" translate="yes" xml:space="preserve">
          <source>The parent key columns named in the foreign key constraint do not exist, or</source>
          <target state="translated">外部キー制約で指定された親キー・カラムが存在しないか、または</target>
        </trans-unit>
        <trans-unit id="ba132dacfac52109e850c048192c0d768817957a" translate="yes" xml:space="preserve">
          <source>The parent table does not exist, or</source>
          <target state="translated">親テーブルが存在しないか</target>
        </trans-unit>
        <trans-unit id="cfb0e652f64b7c831f470e25c9ae00145b03ba52" translate="yes" xml:space="preserve">
          <source>The parser assigns meaning to tokens based on their context. The parser for SQLite is generated using the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt;. Lemon does the same job as YACC/BISON, but it uses a different input syntax which is less error-prone. Lemon also generates a parser which is reentrant and thread-safe. And Lemon defines the concept of a non-terminal destructor so that it does not leak memory when syntax errors are encountered. The grammar file that drives Lemon and that defines the SQL language that SQLite understands is found in &lt;a href=&quot;https://sqlite.org/src/file/src/parse.y&quot;&gt;parse.y&lt;/a&gt;.</source>
          <target state="translated">パーサーは、コンテキストに基づいてトークンに意味を割り当てます。 SQLiteのパーサーは、&lt;a href=&quot;lemon&quot;&gt;レモンパーサージェネレーター&lt;/a&gt;を使用して生成されます。レモンはYACC / BISONと同じ働きをしますが、エラーが発生しにくい異なる入力構文を使用します。 Lemonは、再入可能でスレッドセーフなパーサーも生成します。また、Lemonは非構文のデストラクタの概念を定義しているため、構文エラーが発生したときにメモリをリークしません。レモンを駆動し、SQLiteが理解するSQL言語を定義する文法ファイルは、&lt;a href=&quot;https://sqlite.org/src/file/src/parse.y&quot;&gt;parse.yにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="bba39e24b4502de9e348487cd65024dc8a8b4825" translate="yes" xml:space="preserve">
          <source>The parser now insists on seeing a semicolon or the end of input before executing a statement. This avoids an accidental disaster if the WHERE keyword is misspelled in an UPDATE or DELETE statement.</source>
          <target state="translated">パーサは、文を実行する前にセミコロンまたは入力の末尾を確認するようになりました。これにより、UPDATE 文や DELETE 文で WHERE キーワードのスペルが間違っていた場合の偶発的な災害を回避することができます。</target>
        </trans-unit>
        <trans-unit id="276468011b3fce8fd043bc0ac6f52f8e374eb1fe" translate="yes" xml:space="preserve">
          <source>The parser used by SQLite is forgiving. It is often possible to use a keyword as an identifier as long as such use does not result in a parsing ambiguity. For example, the statement &quot;CREATE TABLE BEGIN(REPLACE,PRAGMA,END);&quot; is accepted by SQLite, and creates a new table named &quot;BEGIN&quot; with three columns named &quot;REPLACE&quot;, &quot;PRAGMA&quot;, and &quot;END&quot;. Nevertheless, best practice is to avoid using keywords as identifiers. Common techniques used to avoid keyword name collisions include:</source>
          <target state="translated">SQLite が使用するパーサは寛容です。キーワードを識別子として使用することは、そのような使用が解析の曖昧さをもたらさない限り、しばしば可能です。例えば、&quot;CREATE TABLE BEGIN(REPLACE,PRAGMA,END);&quot;という文はSQLiteに受け入れられ、&quot;REPLACE&quot;、&quot;PRAGMA&quot;、&quot;END &quot;という3つのカラムを持つ &quot;BEGIN &quot;という名前の新しいテーブルを作成します。それにもかかわらず、識別子としてキーワードを使用しないようにするのが最善の方法です。キーワード名の衝突を避けるために使用される一般的なテクニックには、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="cf399069b7a65af0b661c7a78ceab3a98b1156db" translate="yes" xml:space="preserve">
          <source>The parser's stack was overflowing on a very long UPDATE statement. This is now fixed.</source>
          <target state="translated">非常に長いUPDATE文でパーサのスタックがオーバーフローしていました。これは修正されました。</target>
        </trans-unit>
        <trans-unit id="a5c83958bfdec6a8c2fd0d74498090055bde1a94" translate="yes" xml:space="preserve">
          <source>The parsing of SQL statements is a significant consumer of CPU cycles in any SQL database engine. On-going efforts to optimize SQLite have caused the developers to spend a lot of time tweaking Lemon to generate faster parsers. These efforts have benefited all users of the Lemon parser generator, not just SQLite. But if Lemon had been a separately maintained tool, it would have been more difficulty to make coordinated changes to both SQLite and Lemon, and as a result not as much optimization would have been accomplished. Hence, the fact that the parser generator tool is included in the source tree for SQLite has turned out to be a net benefit for both the tool itself and for SQLite.</source>
          <target state="translated">SQL文の解析は、どのSQLデータベースエンジンにおいてもCPUサイクルの重要な消費者です。SQLiteを最適化するための継続的な努力により、開発者は、より高速なパーサを生成するためにLemonを調整することに多くの時間を費やしてきました。これらの努力は、SQLiteだけでなく、Lemonパーサジェネレータのすべてのユーザに利益をもたらしました。しかし、もし Lemon が個別にメンテナンスされたツールであったならば、SQLite と Lemon の両方に調整された変更を行うのはより困難であり、その結果、多くの最適化が達成されなかったでしょう。したがって、パーサジェネレータツールがSQLiteのソースツリーに含まれているという事実は、ツール自体とSQLiteの両方に純利益をもたらすことが判明しました。</target>
        </trans-unit>
        <trans-unit id="7d2ca17144abc28a05044c4d5d55dce18e17a921" translate="yes" xml:space="preserve">
          <source>The part of the name prior to the last &quot;_&quot; exactly matches the name of a virtual table that was created using &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;. (Shadow tables are not recognized for &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual tables&lt;/a&gt; and &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt;.)</source>
          <target state="translated">最後の「_」より前の名前の部分は、&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;を使用して作成された仮想テーブルの名前と完全に一致します。 （シャドウテーブルは、&lt;a href=&quot;vtab#epovtab&quot;&gt;代名詞の仮想テーブル&lt;/a&gt;および&lt;a href=&quot;vtab#tabfunc2&quot;&gt;テーブル値関数で&lt;/a&gt;は認識されません。）</target>
        </trans-unit>
        <trans-unit id="042a9e73444095c51cd83e16473e75bf7e45a5e4" translate="yes" xml:space="preserve">
          <source>The patch level Z was historically only used for bug-fix releases that changed only a small number of code lines.</source>
          <target state="translated">パッチレベルZは歴史的にバグフィックスリリースにのみ使用されていたもので、コード行数の少ないものしか変更されていませんでした。</target>
        </trans-unit>
        <trans-unit id="274dfc20017243c18164f876bdd5c3980ade92fe" translate="yes" xml:space="preserve">
          <source>The path component of the URI specifies the disk file that is the SQLite database to be opened. If the path component is omitted, then the database is stored in a temporary file that will be automatically deleted when the database connection closes. If the authority section is present, then the path is always an absolute pathname. If the authority section is omitted, then the path is an absolute pathname if it begins with the &quot;/&quot; character (ASCII code 0x2f) and is a relative pathname otherwise. On windows, if the absolute path begins with &quot;&lt;b&gt;/&lt;i&gt;X&lt;/i&gt;:/&lt;/b&gt;&quot; where &lt;b&gt;&lt;i&gt;X&lt;/i&gt;&lt;/b&gt; is any single ASCII alphabetic character (&quot;a&quot; through &quot;z&quot; or &quot;A&quot; through &quot;Z&quot;) then the &quot;&lt;b&gt;&lt;i&gt;X:&lt;/i&gt;&lt;/b&gt;&quot; is understood to be the drive letter of the volume containing the file, not the toplevel directory.</source>
          <target state="translated">URIのパスコンポーネントは、開かれるSQLiteデータベースであるディスクファイルを指定します。パスコンポーネントを省略した場合、データベースは一時ファイルに保存され、データベース接続が閉じたときに自動的に削除されます。権限セクションが存在する場合、パスは常に絶対パス名です。権限セクションが省略されている場合、パスは、「/」文字（ASCIIコード0x2f）で始まる場合は絶対パス名で、それ以外の場合は相対パス名です。 Windowsでは、絶対パスが &quot; &lt;b&gt;/ &lt;i&gt;X&lt;/i&gt;：/&lt;/b&gt; &quot;で始まる場合、&lt;b&gt;&lt;i&gt;X&lt;/i&gt;&lt;/b&gt;は任意の単一のASCIIアルファベット文字（ &quot;a&quot;から &quot;z&quot;または &quot;A&quot;から &quot;Z&quot;）であり、 &quot; &lt;b&gt;&lt;i&gt;X：&lt;/i&gt;&lt;/b&gt;&quot;は、トップレベルディレクトリではなく、ファイルを含むボリュームのドライブ文字であると理解されます。</target>
        </trans-unit>
        <trans-unit id="f3532ac83d22ad95431b31438dce70e426b9f355" translate="yes" xml:space="preserve">
          <source>The path is optional if the authority is present. If the authority is omitted then the path is required.</source>
          <target state="translated">権限があればパスは任意です。権限が省略された場合はパスが必須となります。</target>
        </trans-unit>
        <trans-unit id="5dd0cabb7668cbee80844078c73a695152a285b7" translate="yes" xml:space="preserve">
          <source>The pattern matching algorithm used in the default &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; and &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; implementation of SQLite can exhibit O(N&amp;amp;sup2) performance (where N is the number of characters in the pattern) for certain pathological cases. To avoid denial-of-service attacks from miscreants who are able to specify their own LIKE or GLOB patterns, the length of the LIKE or GLOB pattern is limited to SQLITE_MAX_LIKE_PATTERN_LENGTH bytes. The default value of this limit is 50000. A modern workstation can evaluate even a pathological LIKE or GLOB pattern of 50000 bytes relatively quickly. The denial of service problem only comes into play when the pattern length gets into millions of bytes. Nevertheless, since most useful LIKE or GLOB patterns are at most a few dozen bytes in length, paranoid application developers may want to reduce this parameter to something in the range of a few hundred if they know that external users are able to generate arbitrary patterns.</source>
          <target state="translated">デフォルトの&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;および&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOBで&lt;/a&gt;使用されるパターンマッチングアルゴリズムSQLiteの実装は、特定の病的ケースに対してO（N＆sup2）パフォーマンス（Nはパターン内の文字数）を発揮できます。独自のLIKEまたはGLOBパターンを指定できる悪意のあるユーザーによるサービス拒否攻撃を回避するために、LIKEまたはGLOBパターンの長さはSQLITE_MAX_LIKE_PATTERN_LENGTHバイトに制限されています。この制限のデフォルト値は50000です。最近のワークステーションは、50000バイトの病理学的なLIKEまたはGLOBパターンでも比較的迅速に評価できます。サービス拒否の問題は、パターンの長さが数百万バイトに達したときにのみ発生します。それにもかかわらず、最も有用なLIKEまたはGLOBパターンは最大で数十バイトの長さなので、偏執狂的なアプリケーション開発者は、外部ユーザーが任意のパターンを生成できることを知っている場合、このパラメーターを数百の範囲に減らすことを望むかもしれません。</target>
        </trans-unit>
        <trans-unit id="d6c16218a9785941384e3fbed5d84494c8c3a3ec" translate="yes" xml:space="preserve">
          <source>The pattern matching algorithm used in the default &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; and &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; implementation of SQLite can exhibit O(N&amp;sup2;) performance (where N is the number of characters in the pattern) for certain pathological cases. To avoid denial-of-service attacks from miscreants who are able to specify their own LIKE or GLOB patterns, the length of the LIKE or GLOB pattern is limited to SQLITE_MAX_LIKE_PATTERN_LENGTH bytes. The default value of this limit is 50000. A modern workstation can evaluate even a pathological LIKE or GLOB pattern of 50000 bytes relatively quickly. The denial of service problem only comes into play when the pattern length gets into millions of bytes. Nevertheless, since most useful LIKE or GLOB patterns are at most a few dozen bytes in length, paranoid application developers may want to reduce this parameter to something in the range of a few hundred if they know that external users are able to generate arbitrary patterns.</source>
          <target state="translated">デフォルトの&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;および&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOBで&lt;/a&gt;使用されるパターンマッチングアルゴリズムSQLiteの実装は、特定の病的なケースでO（N&amp;sup2;）パフォーマンス（Nはパターン内の文字数）を示すことがあります。独自のLIKEまたはGLOBパターンを指定できる悪意のあるユーザーからのサービス拒否攻撃を回避するために、LIKEまたはGLOBパターンの長さはSQLITE_MAX_LIKE_PATTERN_LENGTHバイトに制限されています。この制限のデフォルト値は50000です。最新のワークステーションは、50000バイトの病的なLIKEまたはGLOBパターンでさえ比較的迅速に評価できます。サービス拒否の問題は、パターンの長さが数百万バイトに達した場合にのみ発生します。それにもかかわらず、最も有用なLIKEまたはGLOBパターンは、最大で数十バイトの長さであるため、妄想的なアプリケーション開発者は、外部ユーザーが任意のパターンを生成できることを知っている場合、このパラメーターを数百の範囲に減らしたいと思うかもしれません。</target>
        </trans-unit>
        <trans-unit id="202855d0443faeb5dfa8c360619529b04d6a4b20" translate="yes" xml:space="preserve">
          <source>The people table has one entry for each person in a large organization. Each person is either a &quot;student&quot; or a &quot;teacher&quot;, as determined by the &quot;role&quot; field. And we record the height in centimeters of each person. The role and height are indexed. Notice that the left-most column of the index is not very selective - it only contains two possible values.</source>
          <target state="translated">人物表には、大きな組織内の各人物のために1つのエントリがあります。各人は「役割」の欄で決められた「生徒」か「教師」のどちらかです。そして、各人の身長をセンチメートル単位で記録します。役割と身長がインデックス化されています。インデックスの左端の列はあまり選択性が高くないことに注意してください-2つの可能な値しか含まれていません。</target>
        </trans-unit>
        <trans-unit id="92b29d0fa9a5e447b11571a63811cd4169611d21" translate="yes" xml:space="preserve">
          <source>The per-connection statistics do not use global variables and hence do not require mutexes to update or access. Consequently the per-connection statistics continue to function even if &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; is turned off.</source>
          <target state="translated">接続ごとの統計はグローバル変数を使用しないため、更新またはアクセスするためにミューテックスを必要としません。その結果、&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;がオフになっていても、接続ごとの統計は機能し続けます。</target>
        </trans-unit>
        <trans-unit id="50dbff919de02c3f0e66d4c1de101521648ed2d5" translate="yes" xml:space="preserve">
          <source>The performance can be improved slightly by bypassing the SQL layer and reading the blob content directly using the &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; interface, as shown in the next chart:</source>
          <target state="translated">次のグラフに示すように、SQLレイヤーをバイパスし、&lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;インターフェースを使用してblobコンテンツを直接読み取ることで、パフォーマンスをわずかに改善できます。</target>
        </trans-unit>
        <trans-unit id="095c3d78e34e00649d5524d5d46327c65695f40f" translate="yes" xml:space="preserve">
          <source>The performance difference arises (we believe) because when working from an SQLite database, the open() and close() system calls are invoked only once, whereas open() and close() are invoked once for each blob when using blobs stored in individual files. It appears that the overhead of calling open() and close() is greater than the overhead of using the database. The size reduction arises from the fact that individual files are padded out to the next multiple of the filesystem block size, whereas the blobs are packed more tightly into an SQLite database.</source>
          <target state="translated">このパフォーマンスの違いは、SQLite データベースから作業を行う場合、open()と close()のシステムコールは一度だけ呼び出されるのに対し、個々のファイルに格納された blob を使用する場合は、各 blob に対して open()と close()が一度だけ呼び出されるために生じると考えられます (私たちは考えています)。open()とclose()を呼び出すオーバーヘッドは、データベースを使用するオーバーヘッドよりも大きいようです。サイズが小さくなるのは、個々のファイルがファイルシステムのブロックサイズの次の倍数までパディングされるのに対し、ブロブはSQLiteデータベースの中によりタイトに詰め込まれているためです。</target>
        </trans-unit>
        <trans-unit id="2a5a29c317c697ba64096b7f2c68033b4565ac42" translate="yes" xml:space="preserve">
          <source>The permutation is only valid until the next &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; that has the OPFLAG_PERMUTE bit set in P5. Typically the &lt;a href=&quot;opcode#Permutation&quot;&gt;Permutation&lt;/a&gt; should occur immediately prior to the &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt;.</source>
          <target state="translated">順列は、P5でOPFLAG_PERMUTEビットが設定されている次の&lt;a href=&quot;opcode#Compare&quot;&gt;比較&lt;/a&gt;までのみ有効です。通常、&lt;a href=&quot;opcode#Permutation&quot;&gt;置換&lt;/a&gt;は&lt;a href=&quot;opcode#Compare&quot;&gt;比較の&lt;/a&gt;直前に行われる必要があります。</target>
        </trans-unit>
        <trans-unit id="645402751e5b5ab0dd0504759786ac3f99e9f97b" translate="yes" xml:space="preserve">
          <source>The persistence of WAL mode means that applications can be converted to using SQLite in WAL mode without making any changes to the application itself. One has merely to run &quot;&lt;code&gt;PRAGMA journal_mode=WAL;&lt;/code&gt;&quot; on the database file(s) using the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; or other utility, then restart the application.</source>
          <target state="translated">WALモードの永続性は、アプリケーション自体に変更を加えることなく、アプリケーションをSQLiteをWALモードで使用するように変換できることを意味します。&lt;a href=&quot;cli&quot;&gt;コマンドラインシェル&lt;/a&gt;またはその他のユーティリティを使用してデータベースファイルで&quot; &lt;code&gt;PRAGMA journal_mode=WAL;&lt;/code&gt; &quot; を実行し、アプリケーションを再起動するだけです。</target>
        </trans-unit>
        <trans-unit id="37f0ea5f181b03035443f3a918ec838d5bf0f5c4" translate="yes" xml:space="preserve">
          <source>The phrase &quot;VALUES(</source>
          <target state="translated">VALUES(</target>
        </trans-unit>
        <trans-unit id="afda55d9895c016a5496f6b600205dbf8fbc7d06" translate="yes" xml:space="preserve">
          <source>The planner avoids query plans that use indexes with unknown collating functions.</source>
          <target state="translated">プランナは、未知の照合関数を持つインデックスを使用するクエリプランを回避します。</target>
        </trans-unit>
        <trans-unit id="926646f3fb08c1ad8acc73155c7f0bcd303e689e" translate="yes" xml:space="preserve">
          <source>The planner omits unused LEFT JOINs even if they are not the right-most joins of a query.</source>
          <target state="translated">プランナは、未使用のLEFT JOINがクエリの右端の結合でなくても、省略します。</target>
        </trans-unit>
        <trans-unit id="5852e8af03eff264841e6547e952b8e08ad085dc" translate="yes" xml:space="preserve">
          <source>The platform used for these tests is a 1.6GHz Athlon with 1GB or memory and an IDE disk drive. The operating system is RedHat Linux 7.2 with a stock kernel.</source>
          <target state="translated">これらのテストに使用したプラットフォームは、1.6GHzのAthlonで、1GB以上のメモリを搭載し、IDEディスクドライブを搭載しています。オペレーティングシステムはRedHat Linux 7.2で、純正カーネルを使用しています。</target>
        </trans-unit>
        <trans-unit id="e614d538ab4445c07af270ecdc6677ad39ccfb17" translate="yes" xml:space="preserve">
          <source>The point is this: an SQL database schema almost always does a far better job of defining and organizing the tables and data structures and their relationships. And having clear, concise, and well-defined representation almost always results in an application that performs better, has fewer problems, and is easier to develop and maintain.</source>
          <target state="translated">重要なのは、SQLデータベースのスキーマは、ほとんどの場合、テーブルとデータ構造、およびそれらの関係を定義し、整理するのにはるかに優れた仕事をしているということです。そして、明確で簡潔、かつ明確に定義された表現を持つことで、ほとんどの場合、アプリケーションのパフォーマンスが向上し、問題が少なく、開発と保守が容易になるという結果が得られます。</target>
        </trans-unit>
        <trans-unit id="1249a327a44d56131079defe491a7680b8885a62" translate="yes" xml:space="preserve">
          <source>The pointer arguments to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt; must be either NULL or else pointers obtained from a prior invocation of &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt; that have not yet been released.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;と&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;へのポインター引数は、NULL、またはまだ解放されていない&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;または&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc（）の&lt;/a&gt;以前の呼び出しから取得したポインターでなければなりません。</target>
        </trans-unit>
        <trans-unit id="70d5983c94ca6fdbfd5d05e2d8f25d536fa0e2f9" translate="yes" xml:space="preserve">
          <source>The pointer arguments to &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; and &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt; must be either NULL or else pointers obtained from a prior invocation of &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt; that have not yet been released.</source>
          <target state="translated">&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;と&lt;a href=&quot;free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;へのポインター引数は、NULL、またはまだ解放されていない&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;または&lt;a href=&quot;free&quot;&gt;sqlite3_realloc（）の&lt;/a&gt;以前の呼び出しから取得したポインターでなければなりません。</target>
        </trans-unit>
        <trans-unit id="19e21383ec674e61332285628bf7a07277fe3452" translate="yes" xml:space="preserve">
          <source>The pointer type is not intended to be flexible and dynamic. The pointer type is intended to be a design-time constant. Applications should not synthesize pointer type strings at run-time. Providing support for dynamic pointer type strings would lead developers to misuse the pointer-passing interfaces by creating run-time synthesized pointer type strings. Requiring the pointer type strings to be static encourages developers to do the right thing by choosing fixed pointer type names at design-time and encoding those names as constant strings.</source>
          <target state="translated">ポインタ型は柔軟で動的なものを意図したものではありません。ポインタ型は設計時の定数として意図されている。アプリケーションは実行時にポインタ型文字列を合成してはならない。動的なポインタ型文字列のサポートを提供すると、開発者がランタイム合成されたポインタ型文字列を作成することでポインタ通過インタフェースを誤用することになる。ポインタ型文字列が静的であることを要求することは、設計時に固定ポインタ型名を選択し、それらの名前を定数文字列としてエンコードすることで正しいことをするよう開発者に促す。</target>
        </trans-unit>
        <trans-unit id="0a50e253ab7c267f33ad3d5a3deec486738946df" translate="yes" xml:space="preserve">
          <source>The pointers returned are valid until a type conversion occurs as described above, or until &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; is called. The memory space used to hold strings and BLOBs is freed automatically. Do not pass the pointers returned from &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_blob()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;, etc. into &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">返されるポインターは、上記のように型変換が発生するか、&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;または&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;または&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;が呼び出されるまで有効です。文字列とBLOBを保持するために使用されるメモリ空間は自動的に解放されます。返されたポインタ渡してはいけません&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_blobを（） &lt;/a&gt;、&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text（）&lt;/a&gt;の中になど、&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3551cf33afa7b1894cdea20e6326c2bf8dcf19de" translate="yes" xml:space="preserve">
          <source>The pointers returned are valid until a type conversion occurs as described above, or until &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; is called. The memory space used to hold strings and BLOBs is freed automatically. Do not pass the pointers returned from &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_blob()&lt;/a&gt;, &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;, etc. into &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">返されるポインターは、上記のように型変換が発生するか、&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;または&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;または&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;が呼び出されるまで有効です。文字列とBLOBを保持するために使用されるメモリ空間は自動的に解放されます。返されたポインタ渡してはいけません&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_blobを（） &lt;/a&gt;、&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text（）&lt;/a&gt;の中になど、&lt;a href=&quot;free&quot;&gt;sqlite3_free（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9edff31b2dc071eb66ab4aa44d22adfef6b1aa3c" translate="yes" xml:space="preserve">
          <source>The pointers that piggy-back on SQL NULL values using the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt;, and &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; interface are transient and ephemeral. The pointers are never written into the database. The pointers will not survive sorting. The latter fact is why there is no sqlite3_column_pointer() interface, since it is impossible to predict whether or not the query planner will insert a sort operation prior to returning a value from a query, so it would be impossible to know if a pointer value inserted into a query by &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; or &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; would survive through to the result set.</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;、&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;、および&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer（）&lt;/a&gt;インターフェースを使用してSQL NULL値に便乗するポインターは、一時的で一時的なものです。ポインターがデータベースに書き込まれることはありません。ポインタは並べ替え後も存続しません。後者の事実は、sqlite3_column_pointer（）インターフェースがない理由です。クエリから値を返す前にクエリプランナーがソート操作を挿入するかどうかを予測することは不可能であるため、ポインター値かどうかを知ることは不可能です。&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;または&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;によってクエリに挿入されると、結果セットまで存続します。</target>
        </trans-unit>
        <trans-unit id="41025b56b1d99416ab106417d2e02a42b25af90e" translate="yes" xml:space="preserve">
          <source>The porter tokenizer is a wrapper tokenizer. It takes the output of some other tokenizer and applies the &lt;a href=&quot;http://tartarus.org/martin/PorterStemmer/&quot;&gt;porter stemming algorithm&lt;/a&gt; to each token before it returns it to FTS5. This allows search terms like &quot;correction&quot; to match similar words such as &quot;corrected&quot; or &quot;correcting&quot;. The porter stemmer algorithm is designed for use with English language terms only - using it with other languages may or may not improve search utility.</source>
          <target state="translated">ポータートークナイザーはラッパートークナイザーです。他のトークナイザーの出力を受け取り、&lt;a href=&quot;http://tartarus.org/martin/PorterStemmer/&quot;&gt;ポーターステミングアルゴリズム&lt;/a&gt;を各トークンに適用してから、トークンをFTS5に返します。これにより、「correction」などの検索語句を「corrected」や「correcting」などの類似した単語と一致させることができます。ポーターステマーアルゴリズムは、英語の用語でのみ使用するように設計されています。他の言語で使用すると、検索ユーティリティが改善される場合と改善されない場合があります。</target>
        </trans-unit>
        <trans-unit id="8db274801095c26d088720201acb1bad2d40d917" translate="yes" xml:space="preserve">
          <source>The power of an SQLite database could, in theory, be achieved using a custom file format. But any custom file format that is as expressive as a relational database would likely require an enormous design specification and many tens or hundreds of thousands of lines of code to implement. And the end result would be an &quot;opaque blob&quot; that is inaccessible without specialized tools.</source>
          <target state="translated">SQLiteデータベースのパワーは、理論的には、カスタムファイルフォーマットを使用して実現することができます。しかし、リレーショナルデータベースのような表現力を持つカスタムファイルフォーマットは、膨大な設計仕様と、実装するための何万、何十万行ものコードを必要とする可能性があります。そして最終的には、専門的なツールがないとアクセスできない「不透明なブロブ」になってしまいます。</target>
        </trans-unit>
        <trans-unit id="4938c1fbe50ea261772ee32f2ec000b4cb6af37b" translate="yes" xml:space="preserve">
          <source>The powersafe overwrite property for individual databases can be specified as the database is opened using the &quot;psow&quot; query parameter with a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;. For example, to always assume powersafe overwrite for a file (perhaps to ensure maximum write performance), open it as</source>
          <target state="translated">個々のデータベースのpowersafe overwriteプロパティは、&lt;a href=&quot;uri&quot;&gt;URI filenameを&lt;/a&gt;指定した「psow」クエリパラメータを使用してデータベースを開くときに指定できます。たとえば、ファイルのパワーセーフ上書きを常に想定するには（おそらく、最大の書き込みパフォーマンスを保証するため）、次のように開きます。</target>
        </trans-unit>
        <trans-unit id="67790abdb6b576eda27fab78ba503267f5a114fa" translate="yes" xml:space="preserve">
          <source>The powersafe overwrite property says nothing about the state of the bytes that were written. Those bytes might contain their old values, their new values, random values, or some combination of these. The powersafe overwrite property merely states that writes cannot change bytes outside of the range of bytes written.</source>
          <target state="translated">powersafe overwrite プロパティは、書き込まれたバイトの状態については何も言わない。これらのバイトには、古い値、新しい値、ランダムな値、またはこれらの組み合わせが含まれているかもしれません。powersafe overwrite プロパティは、書き込みが書き込まれたバイトの範囲外のバイトを変更できないことを示すだけです。</target>
        </trans-unit>
        <trans-unit id="1389e8d5f9998cc48b0c99ae215e31d8f358ccd0" translate="yes" xml:space="preserve">
          <source>The pragma command is specific to SQLite and is not compatible with any other SQL database engine.</source>
          <target state="translated">pragmaコマンドはSQLiteに特化したもので、他のSQLデータベースエンジンとは互換性がありません。</target>
        </trans-unit>
        <trans-unit id="f45ce9f6459acccc6664213a9c9d236d0392b096" translate="yes" xml:space="preserve">
          <source>The pragma is like &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check&lt;/a&gt; except that it does not verify UNIQUE constraints and does not verify that index content matches table content. By skipping UNIQUE and index consistency checks, quick_check is able to run faster. PRAGMA quick_check runs in O(N) time whereas &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; requires O(NlogN) time where N is the total number of rows in the database. Otherwise the two pragmas are the same.</source>
          <target state="translated">プラグマは、UNIQUE制約を検証せず、インデックスの内容がテーブルの内容と一致することを検証しないことを除いて、&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_checkに&lt;/a&gt;似ています。UNIQUEおよびインデックスの整合性チェックをスキップすることにより、quick_checkをより高速に実行できます。PRAGMA quick_checkはO（N）時間で実行され&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;ます&lt;/a&gt;が、PRAGMA Integrity_checkにはO（NlogN）時間が必要です。ここで、Nはデータベース内の行の総数です。それ以外の場合、2つのプラグマは同じです。</target>
        </trans-unit>
        <trans-unit id="5b9cdfdccce2f8d840c93537988a1d96c50df274" translate="yes" xml:space="preserve">
          <source>The pragma is like &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check&lt;/a&gt; except that it does not verify UNIQUE constraints and does not verify that index content matches table content. By skipping UNIQUE and index consistency checks, quick_check is able to run much faster than integrity_check. Otherwise the two pragmas are the same.</source>
          <target state="translated">プラグマは、UNIQUE制約を検証せず、インデックスの内容がテーブルの内容と一致することを検証しないことを除いて、&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_checkに&lt;/a&gt;似ています。UNIQUEおよびインデックスの整合性チェックをスキップすることにより、quick_checkは、integrity_checkよりもはるかに高速に実行できます。それ以外の場合、2つのプラグマは同じです。</target>
        </trans-unit>
        <trans-unit id="da60401a603e537afbb64f9be897b6e57271b0ee" translate="yes" xml:space="preserve">
          <source>The pre-update hook</source>
          <target state="translated">更新前のフック</target>
        </trans-unit>
        <trans-unit id="77a94c0ef3120048af1c78a5031b2bc8f51341cf" translate="yes" xml:space="preserve">
          <source>The pre-update hook.</source>
          <target state="translated">アップデート前のフック。</target>
        </trans-unit>
        <trans-unit id="464d49040a7350ab38dd3a440629e97d8425be1c" translate="yes" xml:space="preserve">
          <source>The precautions above are not required in order to use SQLite safely with potentially hostile inputs. However, they do provide an extra layer of defense against zero-day exploits and are encouraged for applications that pass data from untrusted sources into SQLite.</source>
          <target state="translated">上記の注意事項は、潜在的に敵対的な入力に対して安全に SQLite を使用するために必要なものではありません。しかし、ゼロデイエクスプロイトに対する防御のための余分な層を提供し、信頼されていないソースからSQLiteにデータを渡すアプリケーションには推奨されています。</target>
        </trans-unit>
        <trans-unit id="05bf811875969018cb62c264a6781abc17b442f0" translate="yes" xml:space="preserve">
          <source>The precedence order for ON CONFLICT clauses was changed so that ON CONFLICT clauses on BEGIN statements have a higher precedence than ON CONFLICT clauses on constraints.</source>
          <target state="translated">ON CONFLICT句の優先順位が変更され、BEGIN文のON CONFLICT句の方が制約のON CONFLICT句よりも優先されるようになりました。</target>
        </trans-unit>
        <trans-unit id="122c8023ebc9769b59f3a1882e33d76b3169c9fd" translate="yes" xml:space="preserve">
          <source>The preceding paragraphs contain a lot of information. To ease the task of constructing a new VFS for SQLite we offer the following implementation checklist:</source>
          <target state="translated">前の段落には多くの情報が含まれています。SQLite 用の新しい VFS を構築する作業を容易にするために、以下の実装チェックリストを提供します。</target>
        </trans-unit>
        <trans-unit id="661723ea54e783ccd80036c290bfdccff5b43478" translate="yes" xml:space="preserve">
          <source>The precision field, if it is present, must follow the width separated by a single &quot;.&quot; character. If there is no width, then the &quot;.&quot; that introduces the precision immediately follows either the flags (if there are any) or the initial &quot;%&quot;.</source>
          <target state="translated">精度フィールドが存在する場合は、1つの「.」文字で区切られた幅の後に続けなければならない。幅がない場合、精度を導入する&quot;.&quot;は、フラグ(あれば)か最初の&quot;%&quot;のいずれかの直後に続きます。</target>
        </trans-unit>
        <trans-unit id="274c336721e63c209854a5c06e41f1f163132ddd" translate="yes" xml:space="preserve">
          <source>The preferred routine to use is &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface is legacy and should be avoided. &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; has an extra &quot;prepFlags&quot; option that is used for special purposes.</source>
          <target state="translated">使用する推奨ルーチンは&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;です。&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;インターフェースは、レガシーあり、避けるべきです。&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3（）に&lt;/a&gt;は、特別な目的で使用される追加の「prepFlags」オプションがあります。</target>
        </trans-unit>
        <trans-unit id="2a1d33401c2095551ef53ebdb2c936c2ab4e7f75" translate="yes" xml:space="preserve">
          <source>The preferred routine to use is &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;. The &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface is legacy and should be avoided. &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; has an extra &quot;prepFlags&quot; option that is used for special purposes.</source>
          <target state="translated">使用する推奨ルーチンは&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;です。&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;インターフェースは、レガシーあり、避けるべきです。&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3（）に&lt;/a&gt;は、特別な目的で使用される追加の「prepFlags」オプションがあります。</target>
        </trans-unit>
        <trans-unit id="e5802699120466acd022e1fa07d198c436289856" translate="yes" xml:space="preserve">
          <source>The prefix on temporary filenames on Windows is changed from &quot;sqlite&quot; to &quot;etilqs&quot;.</source>
          <target state="translated">Windowsのテンポラリファイル名のプレフィックスを &quot;sqlite &quot;から &quot;etilqs &quot;に変更した。</target>
        </trans-unit>
        <trans-unit id="f3230410aa1ec23cdd51b1c85ef3e6e8a5bf6364" translate="yes" xml:space="preserve">
          <source>The presence of a busy handler does not guarantee that it will be invoked when there is lock contention. If SQLite determines that invoking the busy handler could result in a deadlock, it will go ahead and return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; to the application instead of invoking the busy handler. Consider a scenario where one process is holding a read lock that it is trying to promote to a reserved lock and a second process is holding a reserved lock that it is trying to promote to an exclusive lock. The first process cannot proceed because it is blocked by the second and the second process cannot proceed because it is blocked by the first. If both processes invoke the busy handlers, neither will make any progress. Therefore, SQLite returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; for the first process, hoping that this will induce the first process to release its read lock and allow the second process to proceed.</source>
          <target state="translated">ビジーハンドラーの存在は、ロックの競合がある場合に呼び出されることを保証するものではありません。 SQLiteは、ビジーハンドラーを呼び出すとデッドロックが発生する可能性があると判断した場合、ビジーハンドラーを呼び出す代わりに&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;をアプリケーションに返します。 1つのプロセスが予約ロックに昇格しようとしている読み取りロックを保持しており、2番目のプロセスが排他ロックに昇格しようとしている予約ロックを保持しているシナリオを考えてみます。最初のプロセスは2番目のプロセスによってブロックされているため続行できません。2番目のプロセスは最初のプロセスによってブロックされているため続行できません。両方のプロセスがビジーハンドラーを呼び出す場合、どちらも進行しません。したがって、SQLiteは&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSYを&lt;/a&gt;返します最初のプロセスの場合、これにより、最初のプロセスが読み取りロックを解放し、2番目のプロセスを続行できるようになることを期待しています。</target>
        </trans-unit>
        <trans-unit id="f52f9d0c779543db7a531d457708b0c4e1e3b230" translate="yes" xml:space="preserve">
          <source>The presence of a busy handler does not guarantee that it will be invoked when there is lock contention. If SQLite determines that invoking the busy handler could result in a deadlock, it will go ahead and return &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; to the application instead of invoking the busy handler. Consider a scenario where one process is holding a read lock that it is trying to promote to a reserved lock and a second process is holding a reserved lock that it is trying to promote to an exclusive lock. The first process cannot proceed because it is blocked by the second and the second process cannot proceed because it is blocked by the first. If both processes invoke the busy handlers, neither will make any progress. Therefore, SQLite returns &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; for the first process, hoping that this will induce the first process to release its read lock and allow the second process to proceed.</source>
          <target state="translated">ビジーハンドラーの存在は、ロックの競合がある場合に呼び出されることを保証するものではありません。 SQLiteは、ビジーハンドラーを呼び出すとデッドロックが発生する可能性があると判断した場合、ビジーハンドラーを呼び出す代わりに&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;をアプリケーションに返します。 1つのプロセスが予約ロックに昇格しようとしている読み取りロックを保持しており、2番目のプロセスが排他ロックに昇格しようとしている予約ロックを保持しているシナリオを考えてみます。最初のプロセスは2番目のプロセスによってブロックされているため続行できません。2番目のプロセスは最初のプロセスによってブロックされているため続行できません。両方のプロセスがビジーハンドラーを呼び出す場合、どちらも進行しません。したがって、SQLiteは&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSYを&lt;/a&gt;返します最初のプロセスの場合、これにより、最初のプロセスが読み取りロックを解放し、2番目のプロセスを続行できるようになることを期待しています。</target>
        </trans-unit>
        <trans-unit id="b2efda84ef1340b69a62f5b61118269d4141c529" translate="yes" xml:space="preserve">
          <source>The presence of a hot journal is our indication that a previous process was trying to commit a transaction but it aborted for some reason prior to the completion of the commit. A hot journal means that the database file is in an inconsistent state and needs to be repaired (by rollback) prior to being used.</source>
          <target state="translated">ホットジャーナルの存在は、前のプロセスがトランザクションをコミットしようとしていたが、コミットが完了する前に何らかの理由で中断したことを示しています。ホットジャーナルは、データベースファイルが矛盾した状態にあり、使用する前に(ロールバックによって)修復する必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="53e2bd6dac9cbbc9b06c74e123d964800e4d3352" translate="yes" xml:space="preserve">
          <source>The presence of the &quot;noskipscan&quot; token on the sqlite_stat1.stat field of an index prevents that index from being used with the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt;.</source>
          <target state="translated">インデックスのsqlite_stat1.statフィールドに「noskipscan」トークンが存在すると、そのインデックスが&lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan最適化&lt;/a&gt;で使用されなくなります。</target>
        </trans-unit>
        <trans-unit id="a01f573624c54e96d01f0d23d0ba8b3593807a0a" translate="yes" xml:space="preserve">
          <source>The presentation of the query planner problem above is a simplification. The costs are estimates. We cannot know what the true cost of running a loop is until we actually run the loop. SQLite makes guesses for the cost of running a loop based on the availability of indexes and constraints found in the WHERE clause. These guesses are usually pretty good, but they can sometimes be off. Using the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command to collect additional statistical information about the database can sometimes enable SQLite to make better guesses about the cost.</source>
          <target state="translated">上記のクエリプランナーの問題の提示は単純化です。費用は概算です。実際にループを実行するまで、ループを実行することの本当のコストを知ることはできません。SQLiteは、WHERE句にあるインデックスと制約の可用性に基づいて、ループの実行コストを推測します。これらの推測は通常かなり良いですが、時々オフになることがあります。&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;コマンドを使用してデータベースに関する追加の統計情報を収集すると、SQLiteがコストをより正確に推測できる場合があります。</target>
        </trans-unit>
        <trans-unit id="1c32ea8c1623df88595d5e28c3a4322ef70e185f" translate="yes" xml:space="preserve">
          <source>The preupdate hook interfaces were originally added to support the &lt;a href=&quot;sessionintro&quot;&gt;session&lt;/a&gt; extension.</source>
          <target state="translated">preupdateフックインターフェイスは、&lt;a href=&quot;sessionintro&quot;&gt;セッション&lt;/a&gt;拡張をサポートするために最初に追加されました。</target>
        </trans-unit>
        <trans-unit id="54aaab8c82da084a0f8a9658f2bc76535e494e38" translate="yes" xml:space="preserve">
          <source>The preupdate hook only fires for changes to real database tables; the preupdate hook is not invoked for changes to &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; or to system tables like sqlite_master or sqlite_stat1.</source>
          <target state="translated">preupdateフックは、実際のデータベーステーブルへの変更に対してのみ起動します。&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;またはsqlite_masterやsqlite_stat1などのシステムテーブルへの変更に対しては、preupdateフックは呼び出されません。</target>
        </trans-unit>
        <trans-unit id="56711536eb144f6abbe43b67b69a4f340bd68f45" translate="yes" xml:space="preserve">
          <source>The preupdate hook only fires for changes to real database tables; the preupdate hook is not invoked for changes to &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; or to system tables like sqlite_sequence or sqlite_stat1.</source>
          <target state="translated">preupdateフックは、実際のデータベーステーブルへの変更に対してのみ起動します。preupdateフックは、&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;またはsqlite_sequenceやsqlite_stat1などのシステムテーブルへの変更に対しては呼び出されません。</target>
        </trans-unit>
        <trans-unit id="f619ca19c48dc2cd5df5d0de6abefa9c15ce6509" translate="yes" xml:space="preserve">
          <source>The preupdate hook only fires for changes to real database tables; the preupdate hook is not invoked for changes to &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; or to system tables like sqlite_master or sqlite_stat1.</source>
          <target state="translated">preupdateフックは、実際のデータベーステーブルへの変更に対してのみ起動します。&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;またはsqlite_masterやsqlite_stat1などのシステムテーブルへの変更に対しては、preupdateフックは呼び出されません。</target>
        </trans-unit>
        <trans-unit id="f6985f034f86292cf6702a3b24e4e0140c1d7b08" translate="yes" xml:space="preserve">
          <source>The preupdate hook only fires for changes to real database tables; the preupdate hook is not invoked for changes to &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; or to system tables like sqlite_sequence or sqlite_stat1.</source>
          <target state="translated">preupdateフックは、実際のデータベーステーブルへの変更に対してのみ起動します。preupdateフックは、&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;またはsqlite_sequenceやsqlite_stat1などのシステムテーブルへの変更に対しては呼び出されません。</target>
        </trans-unit>
        <trans-unit id="548d335209dbce4d25a40d42ac27b0b5a00affc4" translate="yes" xml:space="preserve">
          <source>The previous discussion has treated searching and sorting as separate topics. But in practice, it is often the case that one wants to search and sort at the same time. Fortunately, it is possible to do this using a single index.</source>
          <target state="translated">これまでの議論では、検索とソートを別の話題として扱ってきました。しかし、実際には、検索とソートを同時に行いたい場合がよくあります。幸いなことに、単一のインデックスを使ってこれを行うことができます。</target>
        </trans-unit>
        <trans-unit id="5a894252915223aa28176cd8caebb845eabbbe5b" translate="yes" xml:space="preserve">
          <source>The previous example is a specific case of a more general problem: The state of an SQLite database is controlled by both the database file and the journal file. In a quiescent state, the journal file does not exist and only the database file matters. But if the journal file does exist, it must be kept together with the database to avoid corruption. The following actions are all likely to lead to corruption:</source>
          <target state="translated">SQLiteデータベースの状態は、データベースファイルとジャーナルファイルの両方によって制御されています。静止状態では、ジャーナルファイルは存在せず、データベースファイルだけが問題となります。しかし、ジャーナルファイルが存在する場合は、破損を避けるためにデータベースと一緒に保管しなければなりません。以下のアクションはすべて破損につながる可能性が高い。</target>
        </trans-unit>
        <trans-unit id="96495b049cd011fd87b80d69ae6b3a8f79a60e9a" translate="yes" xml:space="preserve">
          <source>The previous example will return every row for which the _shape overlaps the polygon in the $query_polygon parameter. The geopoly_within() function works similarly, but only returns rows for which the _shape is completely contained within $query_polygon.</source>
          <target state="translated">前の例では、_shapeが$query_polygonパラメータのポリゴンと重なっているすべての行を返します。geopoly_within()関数も同様に動作しますが、_shapeが完全に$query_polygon内に含まれている行のみを返します。</target>
        </trans-unit>
        <trans-unit id="493e14ba39e9f9ab43ab64d3b6be4b87292ba69a" translate="yes" xml:space="preserve">
          <source>The previous example, SQLite uses index &quot;i1&quot; to optimize a WHERE clause term of the form (a=?) - in this case &quot;a=1&quot;. The previous example could not use a &lt;a href=&quot;queryplanner#covidx&quot;&gt;covering index&lt;/a&gt;, but the following example can, and that fact is reflected in the output:</source>
          <target state="translated">前の例では、SQLiteはインデックス &quot;i1&quot;を使用して、フォーム（a =？）のWHERE句の用語を最適化します。この場合は &quot;a = 1&quot;です。前の例では&lt;a href=&quot;queryplanner#covidx&quot;&gt;カバリングインデックスを&lt;/a&gt;使用できませんでしたが、次の例では使用でき、その事実は出力に反映されています。</target>
        </trans-unit>
        <trans-unit id="69c7b95e4071269d47577736bbe07ea0a083b117" translate="yes" xml:space="preserve">
          <source>The previous fix was not quite right. This one seems to work better.</source>
          <target state="translated">以前の修正ではうまくいきませんでした。こちらの方がうまくいくようです。</target>
        </trans-unit>
        <trans-unit id="fdab229cc2f18edd4b33bcf4f2dc07383013038b" translate="yes" xml:space="preserve">
          <source>The previous paragraph describes what happens when the synchronous pragma setting is &quot;full&quot;.</source>
          <target state="translated">前の段落では、同期プラグマの設定が「フル」の場合に何が起こるかを説明しています。</target>
        </trans-unit>
        <trans-unit id="af577bd70a120b3a01a3ee4e9c639a65b514f294" translate="yes" xml:space="preserve">
          <source>The previous paragraph is also true (separate database connections are isolated from one another) in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; as long as the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; remains turned off. The &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; is off by default and so if the application does nothing to turn it on, it will remain off. Hence, unless the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; is used to change the default behavior, changes made by one database connection are invisible to readers on a different database connection sharing the same cache until the writer commits its transaction.</source>
          <target state="translated">前の段落は、&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommittedプラグマ&lt;/a&gt;がオフのままである限り、&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュモード&lt;/a&gt;でも当てはまります（個別のデータベース接続は互いに分離されています）。&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;READ_UNCOMMITTEDプラグマは&lt;/a&gt;、デフォルトではオフになっていると、アプリケーションがそれをオンにする何もしないのであれば、それはオフのままになります。したがって、&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommittedプラグマ&lt;/a&gt;を使用してデフォルトの動作を変更しない限り、あるデータベース接続によって行われた変更は、ライターがトランザクションをコミットするまで、同じキャッシュを共有する別のデータベース接続上のリーダーには見えません。</target>
        </trans-unit>
        <trans-unit id="4443bdbe2499eab3d6d488e897e8d552fc707661" translate="yes" xml:space="preserve">
          <source>The previous paragraph states that SQLite does not assume that sector writes are atomic. This is true by default. But as of SQLite version 3.5.0, there is a new interface called the Virtual File System (&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;) interface. The &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; is the only means by which SQLite communicates to the underlying filesystem. The code comes with default VFS implementations for Unix and Windows and there is a mechanism for creating new custom VFS implementations at runtime. In this new VFS interface there is a method called xDeviceCharacteristics. This method interrogates the underlying filesystem to discover various properties and behaviors that the filesystem may or may not exhibit. The xDeviceCharacteristics method might indicate that sector writes are atomic, and if it does so indicate, SQLite will try to take advantage of that fact. But the default xDeviceCharacteristics method for both Unix and Windows does not indicate atomic sector writes and so these optimizations are normally omitted.</source>
          <target state="translated">前の段落では、SQLiteはセクター書き込みがアトミックであるとは想定していないと述べています。これはデフォルトで当てはまります。しかし、SQLiteバージョン3.5.0以降、仮想ファイルシステム（&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;）インターフェースと呼ばれる新しいインターフェースがあります。&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;SQLiteが基礎となるファイルシステムと通信する唯一の手段です。コードには、UnixおよびWindowsのデフォルトのVFS実装が付属しており、実行時に新しいカスタムVFS実装を作成するためのメカニズムがあります。この新しいVFSインターフェイスには、xDeviceCharacteristicsと呼ばれるメソッドがあります。このメソッドは、基礎となるファイルシステムに問い合わせて、ファイルシステムが示す場合と示さない場合があるさまざまなプロパティと動作を検出します。 xDeviceCharacteristicsメソッドは、セクターの書き込みがアトミックであることを示す場合があり、その場合、SQLiteはその事実を利用しようとします。ただし、UnixとWindowsの両方のデフォルトのxDeviceCharacteristicsメソッドは、アトミックセクターの書き込みを示さないため、これらの最適化は通常省略されます。</target>
        </trans-unit>
        <trans-unit id="342bf4dfcd7ddbf3e5538a244e6458410341ab97" translate="yes" xml:space="preserve">
          <source>The previous paragraphs describe the behavior of temporary databases under the default SQLite configuration. An application can use the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; and the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter to force temporary databases to behave as pure in-memory databases, if desired.</source>
          <target state="translated">前の段落では、デフォルトのSQLite構成での一時データベースの動作について説明しました。アプリケーションは、&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_storeプラグマ&lt;/a&gt;と&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;コンパイル時パラメーターを使用して、必要に応じて一時データベースを強制的に純粋なメモリ内データベースとして動作させることができます。</target>
        </trans-unit>
        <trans-unit id="6e1f293bab97b2b5f7895a766acf571a1f59dca9" translate="yes" xml:space="preserve">
          <source>The previous query is equivalent to the following:</source>
          <target state="translated">前のクエリは次のように等価です。</target>
        </trans-unit>
        <trans-unit id="2a8f5ff04cf0666d4b31c9cd45d0419954ccab05" translate="yes" xml:space="preserve">
          <source>The previous step created circle (1) in the diagram above. This step will create circle (2). Run the following command:</source>
          <target state="translated">前のステップでは、上図の円(1)を作成しました。このステップでは、円(2)を作成します。以下のコマンドを実行します。</target>
        </trans-unit>
        <trans-unit id="73d4cf9a53d1a814d3d61247ac59a2dcf02d4a89" translate="yes" xml:space="preserve">
          <source>The primary page cache implementation is in the &lt;a href=&quot;https://sqlite.org/src/file/src/pager.c&quot;&gt;pager.c&lt;/a&gt; file. &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; logic is in the separate &lt;a href=&quot;https://sqlite.org/src/file/src/wal.c&quot;&gt;wal.c&lt;/a&gt;. In-memory caching is implemented by the &lt;a href=&quot;https://sqlite.org/src/file/src/pcache.c&quot;&gt;pcache.c&lt;/a&gt; and &lt;a href=&quot;https://sqlite.org/src/file/src/pcache1.c&quot;&gt;pcache1.c&lt;/a&gt; files. The interface between page cache subsystem and the rest of SQLite is defined by the header file &lt;a href=&quot;https://sqlite.org/src/file/src/pager.h&quot;&gt;pager.h&lt;/a&gt;.</source>
          <target state="translated">プライマリページキャッシュの実装は、&lt;a href=&quot;https://sqlite.org/src/file/src/pager.c&quot;&gt;pager.c&lt;/a&gt;ファイルにあります。&lt;a href=&quot;wal&quot;&gt;WALモードの&lt;/a&gt;ロジックは別の&lt;a href=&quot;https://sqlite.org/src/file/src/wal.c&quot;&gt;wal.cにあり&lt;/a&gt;ます。インメモリキャッシングは、&lt;a href=&quot;https://sqlite.org/src/file/src/pcache.c&quot;&gt;pcache.c&lt;/a&gt;および&lt;a href=&quot;https://sqlite.org/src/file/src/pcache1.c&quot;&gt;pcache1.c&lt;/a&gt;ファイルによって実装されます。ページキャッシュサブシステムと残りのSQLiteの間のインターフェイスは、ヘッダーファイル&lt;a href=&quot;https://sqlite.org/src/file/src/pager.h&quot;&gt;pager.h&lt;/a&gt;によって定義されます。</target>
        </trans-unit>
        <trans-unit id="01bd1fccd0eb574f8649d147f7495318ef2ed3aa" translate="yes" xml:space="preserve">
          <source>The primary use of Lemon is to create the SQL language parser. A grammar file (&lt;a href=&quot;https://sqlite.org/src/file/src/parse.y&quot;&gt;parse.y&lt;/a&gt;) is compiled by Lemon into parse.c and parse.h. The parse.c file is incorporated into the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; without further modification.</source>
          <target state="translated">レモンの主な用途は、SQL言語パーサーを作成することです。文法ファイル（&lt;a href=&quot;https://sqlite.org/src/file/src/parse.y&quot;&gt;parse.y&lt;/a&gt;）は、レモンによってparse.cとparse.hにコンパイルされます。parse.cファイルは、さらに変更することなく、&lt;a href=&quot;amalgamation&quot;&gt;統合に&lt;/a&gt;組み込まれます。</target>
        </trans-unit>
        <trans-unit id="c694d6e20cc8030ef2cf2b05c8cbbbe628062074" translate="yes" xml:space="preserve">
          <source>The principal task of an SQL database engine is to evaluate SQL statements of SQL. To accomplish this, the developer needs two objects:</source>
          <target state="translated">SQLデータベースエンジンの主なタスクは、SQLのSQL文を評価することです。これを達成するために、開発者は2つのオブジェクトを必要とします。</target>
        </trans-unit>
        <trans-unit id="cfcb012162b1a505da1f19d8786ad1f42bcacc75" translate="yes" xml:space="preserve">
          <source>The principle difference between FTS3/4 and FTS5 is that in FTS3/4, each instance-list is stored as a single large database record, whereas in FTS5 large instance-lists are divided between multiple database records. This has the following implications for dealing with large databases that contain large lists:</source>
          <target state="translated">FTS3/4とFTS5の原理的な違いは、FTS3/4では各インスタンスリストが1つの大規模データベースレコードとして格納されるのに対し、FTS5では大規模インスタンスリストが複数のデータベースレコードの間で分割されて格納されることです。このことは、大規模なリストを含む大規模なデータベースを扱う上で、次のような意味合いを持ちます。</target>
        </trans-unit>
        <trans-unit id="d7231b054e5abc6f0cfc5cc85f7e3279373f74d4" translate="yes" xml:space="preserve">
          <source>The printf() in SQLite supports new non-standard substitution types (&lt;a href=&quot;printf#percentq&quot;&gt;%q&lt;/a&gt;, &lt;a href=&quot;printf#percentq&quot;&gt;%Q&lt;/a&gt;, &lt;a href=&quot;printf#percentw&quot;&gt;%w&lt;/a&gt;, and &lt;a href=&quot;printf#percentz&quot;&gt;%z&lt;/a&gt;) that are useful both internally to SQLite and to applications using SQLite. Standard library printf()s cannot normally be extended in this way.</source>
          <target state="translated">SQLiteのprintf（）は、SQLite とSQLiteを使用するアプリケーションの両方で内部的に役立つ新しい非標準の置換タイプ（&lt;a href=&quot;printf#percentq&quot;&gt;％q&lt;/a&gt;、&lt;a href=&quot;printf#percentq&quot;&gt;％Q&lt;/a&gt;、&lt;a href=&quot;printf#percentw&quot;&gt;％w&lt;/a&gt;、および&lt;a href=&quot;printf#percentz&quot;&gt;％z&lt;/a&gt;）をサポートします。標準ライブラリのprintf（）は通常、この方法で拡張できません。</target>
        </trans-unit>
        <trans-unit id="0592c94ffabf868a1145cae373098959875b4ffd" translate="yes" xml:space="preserve">
          <source>The printf(FORMAT,...) SQL function works like the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; C-language function and the printf() function from the standard C library. The first argument is a format string that specifies how to construct the output string using values taken from subsequent arguments. If the FORMAT argument is missing or NULL then the result is NULL. The %n format is silently ignored and does not consume an argument. The %p format is an alias for %X. The %z format is interchangeable with %s. If there are too few arguments in the argument list, missing arguments are assumed to have a NULL value, which is translated into 0 or 0.0 for numeric formats or an empty string for %s. See the &lt;a href=&quot;printf&quot;&gt;built-in printf()&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">printf（FORMAT、...）SQL関数は、&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt; C言語関数および標準Cライブラリのprintf（）関数と同様に機能します。最初の引数は、後続の引数から取得した値を使用して出力文字列を作成する方法を指定するフォーマット文字列です。 FORMAT引数がないかNULLの場合、結果はNULLになります。 ％n形式は暗黙のうちに無視され、引数を消費しません。 ％p形式は％Xのエイリアスです。 ％z形式は％sと交換可能です。引数リストの引数が少なすぎる場合、欠落している引数はNULL値であると見なされ、数値形式では0または0.0に変換され、％sでは空の文字列に変換されます。詳細については、&lt;a href=&quot;printf&quot;&gt;組み込みのprintf（）の&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="f7aa000e854fa1e51d2a8e3276f08d834816bb0a" translate="yes" xml:space="preserve">
          <source>The private memory cell is initialized to NULL by the first two instructions. Instructions 2 through 13 implement the inner SELECT statement against the examp2 table. Notice that instead of sending the result to a callback or storing the result on a sorter, the result of the query is pushed into the memory cell by instruction 10 and the loop is abandoned by the jump at instruction 11. The jump at instruction at 11 is vestigial and never executes.</source>
          <target state="translated">プライベート・メモリ・セルは、最初の2つの命令でNULLに初期化されます。命令2から13はexamp2テーブルに対する内部SELECT文を実装します。結果をコールバックに送信したり、結果をソータに格納したりする代わりに、問い合わせの結果は命令10によってメモリセルにプッシュされ、命令11でのジャンプによってループが放棄されることに注意してください。命令11でのジャンプは実行されることはありません。</target>
        </trans-unit>
        <trans-unit id="576c1ad7241fb816002c325b35c536b5acba643f" translate="yes" xml:space="preserve">
          <source>The problem is that the indexes are not of equal quality. A check-in is likely to only have one child. So the first field of PLINK_I1 will usually narrow down the search to just a single row. But there are thousands and thousands check-ins tagged with &quot;trunk&quot;, so the first field of TAGXREF_I1 will be of little help in narrowing down the search.</source>
          <target state="translated">問題は、インデックスの質が同じではないことです。チェックインは1つの子だけの可能性が高い。そのため、PLINK_I1の最初のフィールドは、通常は1行だけに絞り込んで検索します。しかし、&quot;trunk &quot;でタグ付けされたチェックインは何千、何千もあるので、tagxref_i1の最初のフィールドは、検索を絞り込む上でほとんど役に立たないでしょう。</target>
        </trans-unit>
        <trans-unit id="4910b74e848d7f84054aa8b42c2da7951eb8cf1a" translate="yes" xml:space="preserve">
          <source>The problem of dynamic memory allocation, and specifically the problem of a memory allocator breakdown, has been studied by J. M. Robson and the results published as:</source>
          <target state="translated">動的メモリ割り当ての問題、具体的にはメモリアロケータの故障の問題は、J.M.Robsonによって研究され、その結果が公開されています。</target>
        </trans-unit>
        <trans-unit id="c0e48a1c7e6fc766c0233c83a22616959f0ed84b" translate="yes" xml:space="preserve">
          <source>The problem of finding the best query plan is equivalent to finding a minimum-cost path through the graph that visits each node exactly once.</source>
          <target state="translated">最良の問い合わせプランを見つける問題は、グラフを通る最小コストのパスを見つけることと同等であり、各ノードを正確に一度だけ訪れることができます。</target>
        </trans-unit>
        <trans-unit id="0f52798620170b176ff3d3af06fd50b65930b59c" translate="yes" xml:space="preserve">
          <source>The problem was fixed on 2011-02-20. The fix first appears in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;version 3.7.6&lt;/a&gt; (2011-04-12).</source>
          <target state="translated">この問題は2011-02-20に修正されました。修正はSQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;バージョン3.7.6&lt;/a&gt;（2011-04-12）で最初に表示されます。</target>
        </trans-unit>
        <trans-unit id="0a9231ded77785fbf75b111ccef695ba60c384a1" translate="yes" xml:space="preserve">
          <source>The problem with looking up information by rowid is that you probably do not care what the price of &quot;item 4&quot; is - you want to know the price of peaches. And so a rowid lookup is not helpful.</source>
          <target state="translated">rowidで情報を調べる場合の問題点は、おそらく「アイテム4」の価格は気にしないということでしょう-あなたは桃の価格を知りたいのです。そのため、rowidによる検索は役に立ちません。</target>
        </trans-unit>
        <trans-unit id="5ca928318271d59121bcae8c1e00c91157b277dc" translate="yes" xml:space="preserve">
          <source>The problem with this latter query is that it must apply the contained_in() function to millions of entries in the demo_data table. The use of the R*Tree in the penultimate query reduces the number of calls to contained_in() function to a small subset of the entire table. The R*Tree index did not find the exact answer itself, it merely limited the search space.</source>
          <target state="translated">後者のクエリの問題点は,demo_dataテーブル内の何百万ものエントリに対して contained_in()関数を適用しなければならないことです.最後のクエリでR*Treeを使用することで、 contained_in()関数の呼び出し回数をテーブル全体の小さなサブセットに減らすことができます。R*Treeインデックスは、正確な答えそのものを見つけるのではなく、単に検索スペースを制限しただけです。</target>
        </trans-unit>
        <trans-unit id="4d80ba47d569d0e4a2a3e8f3108543e7f76afec3" translate="yes" xml:space="preserve">
          <source>The procedure used to detect a</source>
          <target state="translated">を検出するために使用される手順は</target>
        </trans-unit>
        <trans-unit id="7c5ac2fd9c78337a35d0c9980fe79b8e26f93a08" translate="yes" xml:space="preserve">
          <source>The process is explained at &lt;a href=&quot;http://wiki.tcl-lang.org/21708&quot;&gt;http://wiki.tcl-lang.org/21708&lt;/a&gt;.</source>
          <target state="translated">プロセスは&lt;a href=&quot;http://wiki.tcl-lang.org/21708&quot;&gt;http://wiki.tcl-lang.org/21708&lt;/a&gt;で説明されています。</target>
        </trans-unit>
        <trans-unit id="6eeaa105f7c556f91bf9c6156b767ca4d840a8c0" translate="yes" xml:space="preserve">
          <source>The progress callback can be used to display the status of a lengthy query or to process GUI events during a lengthy query.</source>
          <target state="translated">プログレスコールバックは、長いクエリのステータスを表示したり、長いクエリ中にGUIイベントを処理したりするために使用できます。</target>
        </trans-unit>
        <trans-unit id="c69ceeecbdd66434afc39e336822e8ab81198858" translate="yes" xml:space="preserve">
          <source>The progress handler callback must not do anything that will modify the database connection that invoked the progress handler. Note that &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">進捗ハンドラーコールバックは、進捗ハンドラーを呼び出したデータベース接続を変更するようなことをしてはなりません。&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;と&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）は&lt;/a&gt;どちらも、この段落の「変更」の意味でデータベース接続を変更することに注意してください。</target>
        </trans-unit>
        <trans-unit id="cfdeee9bdc15af91672d8ad9f38656051ea8a13d" translate="yes" xml:space="preserve">
          <source>The progress handler callback must not do anything that will modify the database connection that invoked the progress handler. Note that &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">進捗ハンドラーコールバックは、進捗ハンドラーを呼び出したデータベース接続を変更するようなことをしてはなりません。&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;と&lt;a href=&quot;step&quot;&gt;sqlite3_step（）は&lt;/a&gt;どちらも、この段落の「変更」の意味でデータベース接続を変更することに注意してください。</target>
        </trans-unit>
        <trans-unit id="d0b8dc8c8f3e20ba03797e52e7e128023b09d0a3" translate="yes" xml:space="preserve">
          <source>The properties of the &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; and &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; commands described above only apply if foreign keys are enabled. If the user considers them undesirable, then the workaround is to use &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; to disable foreign key constraints before executing the DROP or ALTER TABLE command. Of course, while foreign key constraints are disabled, there is nothing to stop the user from violating foreign key constraints and thus creating an internally inconsistent database.</source>
          <target state="translated">上記の&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;コマンドと&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;コマンドのプロパティは、外部キーが有効な場合にのみ適用されます。ユーザーがそれらを望ましくないと考える場合の回避策は、&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;DRAG&lt;/a&gt;またはALTER TABLEコマンドを実行する前に、PRAGMA foreign_keysを使用して外部キー制約を無効にすることです。もちろん、外部キー制約は無効になっていますが、ユーザーが外部キー制約に違反して内部的に一貫性のないデータベースを作成するのを阻止するものは何もありません。</target>
        </trans-unit>
        <trans-unit id="12341c72ae5851f82e7e9d06ed859f6acb79d027" translate="yes" xml:space="preserve">
          <source>The prover that determines whether any column of the right-hand table of a LEFT JOIN must be non-NULL in the WHERE clause is imperfect. It sometimes returns a false negative. In other words, it sometimes fails to reduce the strength of a LEFT JOIN when doing so was in fact possible. For example, the prover does not know the &lt;a href=&quot;lang_datefunc&quot;&gt;datetime() SQL function&lt;/a&gt; will always return NULL if its first argument is NULL, and so it will not recognize that the LEFT JOIN in the following query could be strength-reduced:</source>
          <target state="translated">WHERE句でLEFT JOINの右側のテーブルの列がNULL以外でなければならないかどうかを決定する証明者は不完全です。それは時々偽陰性を返します。つまり、実際には可能であったとしても、LEFT JOINの強度を下げることができない場合があります。たとえば、最初の引数がNULLの場合、証明者は&lt;a href=&quot;lang_datefunc&quot;&gt;datetime（）SQL関数&lt;/a&gt;が常にNULLを返すことを認識していないため、次のクエリのLEFT JOINが強度削減される可能性があることを認識しません。</target>
        </trans-unit>
        <trans-unit id="48a058bacf71fa48c37c493961b3f8857c5bcde0" translate="yes" xml:space="preserve">
          <source>The psow query parameter overrides the &lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt; property of the database file being opened. The psow query parameter works with the default windows and unix &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; but might be a no-op for other proprietary or non-standard VFSes.</source>
          <target state="translated">psowクエリパラメータは、開かれるデータベースファイルの&lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt;プロパティを上書きします。psowクエリパラメータは、デフォルトのウィンドウとUNIX &lt;a href=&quot;vfs&quot;&gt;VFSで&lt;/a&gt;機能しますが、他の独自仕様または非標準のVFSでは何もしない場合があります。</target>
        </trans-unit>
        <trans-unit id="ffe108cd06e0c16c268bec90ba5007639fcc32ef" translate="yes" xml:space="preserve">
          <source>The pthreads interface provides the pthread_cond_wait() function. This function allows the caller to simultaneously release a mutex and start waiting for an asynchronous signal. Using this function, a &quot;fired&quot; flag and a mutex, the race-condition described above may be eliminated as follows:</source>
          <target state="translated">pthreads インターフェースは pthread_cond_wait()関数を提供します。この関数を使用すると、呼び出し元はミューテックスを解放すると同時に非同期信号の待ちを開始することができます。この関数、&quot;fired &quot;フラグ、ミューテックスを使用すると、以下のように上述の競合状態を解消することができます。</target>
        </trans-unit>
        <trans-unit id="5730c4be2fce644af4a3a0b4f7bf8a21afa9d144" translate="yes" xml:space="preserve">
          <source>The pthreads library is needed to make SQLite threadsafe. But since the CLI is single threaded, we could instruct SQLite to build in a non-threadsafe mode and thereby omit the pthreads library:</source>
          <target state="translated">pthreads ライブラリは、SQLite をスレッドセーフにするために必要です。しかし、CLIはシングルスレッドなので、SQLiteにスレッドセーフではないモードでビルドするように指示し、それによってpthreadsライブラリを省略することができます。</target>
        </trans-unit>
        <trans-unit id="ead084e5ac51c3a25e7e77f7295b3ad410aff0a2" translate="yes" xml:space="preserve">
          <source>The purpose of the master journal is to ensure that multi-file transactions are atomic across a power-loss. But if the database files have other settings that compromise integrity across a power-loss event (such as &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; or &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=MEMORY&lt;/a&gt;) then the creation of the master journal is omitted, as an optimization.</source>
          <target state="translated">マスタージャーナルの目的は、マルチファイルトランザクションが停電時にアトミックであることを保証することです。ただし、データベースファイルに停電時の整合性を損なう他の設定（&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同期= OFF&lt;/a&gt;または&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = MEMORYなど&lt;/a&gt;）がある場合、最適化のためにマスタージャーナルの作成は省略されます。</target>
        </trans-unit>
        <trans-unit id="80a4c796df15be02f28a9491edc718e0a6ad327d" translate="yes" xml:space="preserve">
          <source>The purpose of the other files and folders is presently unknown to the author but is probably not difficult to figure out.</source>
          <target state="translated">その他のファイルやフォルダの目的は、現在のところ作者には不明ですが、おそらく把握するのは難しいことではないでしょう。</target>
        </trans-unit>
        <trans-unit id="f221997932c715d1cdc1bd2a990d3e44e81c153a" translate="yes" xml:space="preserve">
          <source>The purpose of the super-journal is to ensure that multi-file transactions are atomic across a power-loss. But if the database files have other settings that compromise integrity across a power-loss event (such as &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; or &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=MEMORY&lt;/a&gt;) then the creation of the super-journal is omitted, as an optimization.</source>
          <target state="translated">スーパージャーナルの目的は、マルチファイルトランザクションが電力損失全体でアトミックであることを保証することです。ただし、データベースファイルに、電力損失イベント全体の整合性を損なう他の設定（&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA Synchronous = OFF&lt;/a&gt;や&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMAjournal_mode = MEMORYなど&lt;/a&gt;）がある場合、最適化としてスーパージャーナルの作成は省略されます。</target>
        </trans-unit>
        <trans-unit id="6ad934bb2af516663297a114c16808bb7efaf019" translate="yes" xml:space="preserve">
          <source>The purpose of the wal-index is to answer this question quickly:</source>
          <target state="translated">ウォルインデックスの目的は、この質問に素早く答えることです。</target>
        </trans-unit>
        <trans-unit id="138e57468a79af5c77be9bf617137e42c028e084" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to argue in favor of a fourth new category of application file format: An SQLite database file.</source>
          <target state="translated">この文書の目的は、4つ目の新しいカテゴリのアプリケーションファイル形式を支持することを主張することである。SQLite データベースファイルです。</target>
        </trans-unit>
        <trans-unit id="a73682c963786c3512a8e2606835fb2fa3f30921" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to brief the reader on how SQLite development team functions on a daily basis, as they continuously enhance the SQLite software and work to improve its already high reliability. The document achieves its purpose if a competent developer can be assimilated into the development team quickly after perusing this document.</source>
          <target state="translated">この文書の目的は、SQLite開発チームがSQLiteソフトウェアを継続的に改良し、すでに高い信頼性を実現しているSQLite開発チームが日常的にどのように機能しているのかを読者に説明することにあります。この文書を熟読した後、有能な開発者が開発チームに速やかに溶け込むことができれば、この文書はその目的を達成することができます。</target>
        </trans-unit>
        <trans-unit id="634e9e567d1f1f2dd99eda8c5536d500fa1e6e07" translate="yes" xml:space="preserve">
          <source>The push-down optimization cannot always be used. For example, if the subquery contains a LIMIT, then pushing down any part of the WHERE clause from the outer query could change the result of the inner query. There are other restrictions, explained in a comment in the source code on the pushDownWhereTerms() routine that implements this optimization.</source>
          <target state="translated">プッシュダウン最適化は常に使用できるわけではありません。例えば、副問い合わせに LIMIT が含まれている場合、外側の問い合わせから WHERE 句の任意の部分をプッシュダウンすると、内側の問い合わせの結果が変更される可能性があります。他にも制限事項がありますが、この最適化を実装する pushDownWhereTerms()ルーチンのソース・コードのコメントで説明されています。</target>
        </trans-unit>
        <trans-unit id="95403298754cba937ffb2896cd7e77d09dc82fdd" translate="yes" xml:space="preserve">
          <source>The quality management plan was originally composed by going through the description of outputs in section 11 of DO-178B (pages 48 through 56) and writing down those elements that seemed relevant to SQLite. The text will be subsequent revised to track enhancements to the SQLite quality process.</source>
          <target state="translated">品質管理計画は当初、DO-178Bの第11節(48~56ページ)のアウトプットの記述に目を通し、SQLiteに関連すると思われる要素を書き留めることで構成されていました。このテキストは、SQLite品質プロセスの強化を追跡するために、その後改訂されます。</target>
        </trans-unit>
        <trans-unit id="06064891cfb2016593d8db9b131661701e81d4c1" translate="yes" xml:space="preserve">
          <source>The query above could be made to run faster by using the FTS &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo&lt;/a&gt; function to determine the number of query term instances that appear in each result. The matchinfo function is much more efficient than the offsets function. Furthermore, the matchinfo function provides extra information regarding the overall number of occurrences of each query term in the entire document set (not just the current row) and the number of documents in which each query term appears. This may be used (for example) to attach a higher weight to less common terms which may increase the overall computed relevancy of those results the user considers more interesting.</source>
          <target state="translated">上記のクエリは、FTSの&lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo&lt;/a&gt;関数を使用して各結果に表示されるクエリ用語インスタンスの数を決定することで、より高速に実行できます。 matchinfo関数は、offsets関数よりもはるかに効率的です。さらに、matchinfo関数は、ドキュメントセット全体（現在の行だけでなく）での各クエリ用語の出現回数と、各クエリ用語が出現するドキュメントの数に関する追加情報を提供します。これは、たとえば、あまり一般的でない用語に高い重みを付けるために使用され、ユーザーがより興味深いと考える結果の全体的な計算された関連性を高める可能性があります。</target>
        </trans-unit>
        <trans-unit id="418f38a31900c8102303fe91cea3cb03a0bfc91a" translate="yes" xml:space="preserve">
          <source>The query above could be rewritten as a join and without the use of row values:</source>
          <target state="translated">上記のクエリは、行の値を使わずに結合として書き換えることができます。</target>
        </trans-unit>
        <trans-unit id="8505932c272eacf13a6ac016c3034294904230a0" translate="yes" xml:space="preserve">
          <source>The query above will return suggestions for the whole input word that begins with $prefix. The $wholeline parameter is all text from the beginning of the line up to the insertion point. The $wholeline parameter is used for context.</source>
          <target state="translated">上のクエリは、$prefixで始まる入力単語全体の候補を返します。wholeline パラメータは、行頭から挿入ポイントまでのすべてのテキストです。wholeline パラメータは、コンテキストのために使用されます。</target>
        </trans-unit>
        <trans-unit id="f9921b4f3858e29c8d8f50be7ccdabc32d452e7c" translate="yes" xml:space="preserve">
          <source>The query above will use the po_parent index to help find the answer, since the po_parent index contains entries for all rows of interest. Note that since po_parent is smaller than a full index, the query will likely run faster too.</source>
          <target state="translated">上のクエリは、答えを見つけるためにpo_parentインデックスを使用します。po_parentは完全なインデックスよりも小さいので、クエリの実行速度も速くなることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0190a12968e1ccf51186372beeb26ae3012cb0b9" translate="yes" xml:space="preserve">
          <source>The query above would very quickly locate the id of 1 even if the R*Tree contained millions of entries. The previous is an example of a &quot;contained-within&quot; query. The R*Tree also supports &quot;overlapping&quot; queries. For example, to find all bounding boxes that overlap the Charlotte area:</source>
          <target state="translated">上のクエリは、R*Treeに何百万ものエントリが含まれていたとしても、1のidを素早く見つけることができます。上の例は、&quot;included-within &quot;クエリの例です。R*Treeは「重複」クエリもサポートしています。例えば、シャーロット地域に重なるすべてのバウンディングボックスを見つけるには、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="94364d8100096142da610b0a18f63efa10ad070a" translate="yes" xml:space="preserve">
          <source>The query component of a URI may contain parameters that are interpreted either by SQLite itself, or by a &lt;a href=&quot;../vfs&quot; id=&quot;coreuriqueryparameters&quot;&gt;custom VFS implementation&lt;/a&gt;. SQLite and its built-in &lt;a href=&quot;../vfs&quot;&gt;VFSes&lt;/a&gt; interpret the following query parameters:</source>
          <target state="translated">URIのクエリコンポーネントには、SQLite自体または&lt;a href=&quot;../vfs&quot; id=&quot;coreuriqueryparameters&quot;&gt;カスタムVFS実装&lt;/a&gt;によって解釈されるパラメータが含まれている場合があります。SQLiteとその組み込み&lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt;は、次のクエリパラメータを解釈します。</target>
        </trans-unit>
        <trans-unit id="86e91a7c9e388f3708828edd53ce0492e58dcf0d" translate="yes" xml:space="preserve">
          <source>The query component of a URI may contain parameters that are interpreted either by SQLite itself, or by a &lt;a href=&quot;vfs&quot; id=&quot;coreuriqueryparameters&quot;&gt;custom VFS implementation&lt;/a&gt;. SQLite and its built-in &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; interpret the following query parameters:</source>
          <target state="translated">URIのクエリコンポーネントには、SQLite自体または&lt;a href=&quot;vfs&quot; id=&quot;coreuriqueryparameters&quot;&gt;カスタムVFS実装&lt;/a&gt;によって解釈されるパラメータが含まれている場合があります。SQLiteとその組み込み&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;は、次のクエリパラメータを解釈します。</target>
        </trans-unit>
        <trans-unit id="f6f2f3df836d46d9540098c193cbe7de6978b27d" translate="yes" xml:space="preserve">
          <source>The query contains both a search restriction in the WHERE clause and a sort order in the ORDER BY clause. Both the search and the sort can be accomplished at the same time using the two-column index Idx3.</source>
          <target state="translated">クエリには、WHERE句での検索制限とORDER BY句でのソート順の両方が含まれています。検索とソートは、2カラムインデックスIdx3を使用して同時に行うことができます。</target>
        </trans-unit>
        <trans-unit id="bb441cf385ae38b5e50765b319372e3b2d5a50b2" translate="yes" xml:space="preserve">
          <source>The query does a binary search on the index to find the subset of rows that have fruit='Orange'. (Because the fruit column is the left-most column of the index and the rows of the index are in sorted order, all such rows will be adjacent.) Then it scans the matching index rows from top to bottom to get the rowids for the original table, and for each rowid does a binary search on the original table to find the price.</source>
          <target state="translated">このクエリは、fruit='Orange'を持つ行のサブセットを見つけるためにインデックスのバイナリ検索を行います。(フルーツの列はインデックスの左端の列であり、インデックスの行はソート順になっているため、そのような行はすべて隣接しています)。次に、一致するインデックスの行を上から下へスキャンして元のテーブルの行IDを取得し、各行IDについて元のテーブルのバイナリ検索を行い、価格を見つけます。</target>
        </trans-unit>
        <trans-unit id="0da70d4a5a91c3bdacf749b9198a4a57a477e008" translate="yes" xml:space="preserve">
          <source>The query is not an aggregate</source>
          <target state="translated">クエリは集約ではありません。</target>
        </trans-unit>
        <trans-unit id="d5463ef5a6e2ace12b54dcf259b0837fe48d0c3a" translate="yes" xml:space="preserve">
          <source>The query loop is built from instructions 5 through 13. Instructions 6 through 8 build a record that contains the azData[] values for a single invocation of the callback. A sort key is generated by instructions 9 through 11. Instruction 12 combines the invocation record and the sort key into a single entry and puts that entry on the sort list.</source>
          <target state="translated">クエリループは、命令 5 から 13 で構築されます。命令6から命令8は、コールバックの1回の呼び出しのためのazData[]の値を含むレコードを構築します。ソートキーは命令9から11によって生成されます。命令12は、呼び出しレコードとソートキーを1つのエントリに結合し、そのエントリをソートリストに配置します。</target>
        </trans-unit>
        <trans-unit id="b89b1eb2c0211443a7be50a77507c951f5a3834f" translate="yes" xml:space="preserve">
          <source>The query loop is implemented by instructions 8 through 22. The aggregate key specified by the GROUP BY clause is computed by instructions 9 and 10. Instruction 11 causes the appropriate bucket to come into focus. If a bucket with the given key does not already exists, a new bucket is created and control falls through to instructions 12 and 13 which initialize the bucket. If the bucket does already exist, then a jump is made to instruction 14. The values of aggregate functions are updated by the instructions between 11 and 21. Instructions 14 through 18 update memory slot 1 to hold the next value &quot;min(three+four)&quot;. Then the sum of the &quot;four&quot; column is updated by instructions 19 through 21.</source>
          <target state="translated">クエリ・ループは命令8から22によって実装されます。GROUP BY句で指定された集約キーは、命令9と10によって計算されます。命令11は、適切なバケットに注目させます。与えられたキーを持つバケットがまだ存在しない場合、新しいバケットが作成され、制御はバケットを初期化する命令12と13に委ねられます。バケットが既に存在する場合は、命令14にジャンプします。集約関数の値は、11から21までの命令によって更新されます。命令14〜18は、次の値「min(3+4)」を保持するようにメモリスロット1を更新する。その後、命令19〜21により、「4」列の合計値が更新される。</target>
        </trans-unit>
        <trans-unit id="a6ac9b746a0ebf6db3c5dac60c7fc4d3c527912f" translate="yes" xml:space="preserve">
          <source>The query optimizer might translate this into three separate constraints:</source>
          <target state="translated">クエリ・オプティマイザは、これを3つの別々の制約に変換することができます。</target>
        </trans-unit>
        <trans-unit id="ca7f72fc82a7c6f8223569dbd345a23847f45a71" translate="yes" xml:space="preserve">
          <source>The query optimizer now attempts to implement the ORDER BY clause using an index. Sorting is still used if not suitable index is available.</source>
          <target state="translated">クエリオプティマイザは、インデックスを使用してORDER BY句を実装しようとするようになりました。適切なインデックスが利用できない場合でも、ソートが使用されます。</target>
        </trans-unit>
        <trans-unit id="074dd395e411c2a7564e05c9a803ff7d91501e5c" translate="yes" xml:space="preserve">
          <source>The query planner considers the LIMIT clause when estimating the cost of ORDER BY.</source>
          <target state="translated">クエリプランナは、ORDER BYのコストを見積もる際にLIMIT句を考慮します。</target>
        </trans-unit>
        <trans-unit id="efb22d31da7b95dc237d9b06fed089e63b961bd2" translate="yes" xml:space="preserve">
          <source>The query planner examines the values of bound parameters to help determine if a partial index is usable.</source>
          <target state="translated">クエリプランナはバインドパラメータの値を調べて、部分インデックスが使用可能かどうかを判断します。</target>
        </trans-unit>
        <trans-unit id="e51e3ffe015829441eac83092590224609d07ba7" translate="yes" xml:space="preserve">
          <source>The query planner in SQLite normally does a terrific job of selecting fast algorithms for running your SQL statements. This is true of the legacy query planner and even more true of the new NGQP. There may be an occasional situation where, due to incomplete information, the query planner selects a suboptimal plan. This will happen less often with the NGQP than with the legacy query planner, but it might still happen. Only in those rare cases do application developers need to get involved and help the query planner to do the right thing. In the common case, the NGQP is just a new enhancement to SQLite that makes the application run a little faster and which requires no new developer thought or action.</source>
          <target state="translated">SQLite のクエリプランナは通常、SQL 文を実行するための高速なアルゴリズムを選択するという素晴らしい仕事をしています。これは従来のクエリプランナにも当てはまりますが、新しいNGQPではさらに当てはまります。不完全な情報のために、クエリプランナーが最適ではないプランを選択してしまうという状況が時々発生するかもしれません。NGQPでは、従来のクエリプランナーよりも頻度は低くなりますが、それでも起こる可能性はあります。アプリケーション開発者が関与し、クエリプランナが正しいことを行うように支援する必要があるのは、このようなごくまれなケースだけです。一般的なケースでは、NGQPはアプリケーションの実行を少し速くするSQLiteの新しい機能強化に過ぎず、開発者が新たに考えたり、行動したりする必要はありません。</target>
        </trans-unit>
        <trans-unit id="7056feb20ef72b761795635d81c08e5ed2af62a2" translate="yes" xml:space="preserve">
          <source>The query planner in future versions of SQLite might grow smart enough to make transformations such as the above automatically, in both directions. That is to say, future versions of SQLite might transform queries of the first form into the second, or queries written the second way into the first. As of SQLite version 3.22.0 (2018-01-22), the query planner will flatten the subquery if the outer query does not make use of any user-defined functions or subqueries in its result set. For the examples shown above, however, SQLite implements each of the queries as written.</source>
          <target state="translated">将来のバージョンのSQLiteのクエリプランナは、上記のような変換を双方向で自動的に行うことができるように賢くなるかもしれません。つまり、将来のバージョンのSQLiteでは、第1の形式のクエリを第2の形式に変換したり、第2の方法で書かれたクエリを第1の形式に変換したりするかもしれません。SQLite バージョン 3.22.0 (2018-01-22)の時点では、クエリプランナは、外側のクエリが結果セットの中でユーザー定義の関数やサブクエリを利用していない場合、サブクエリを平坦化します。ただし、上記の例では、SQLite はそれぞれのクエリを記述された通りに実装しています。</target>
        </trans-unit>
        <trans-unit id="f9ae7f14e38f472239e8cbf47519f9f962bf6c41" translate="yes" xml:space="preserve">
          <source>The query planner is able to optimize IN operators on &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; even if the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method does not set the sqlite3_index_constraint_usage.omit flag of the virtual table column to the left of the IN operator.</source>
          <target state="translated">&lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;メソッドが仮想テーブル列のsqlite3_index_constraint_usage.omitフラグをIN演算子の左側に設定していない場合でも、クエリプランナーは&lt;a href=&quot;vtab&quot;&gt;仮想テーブルの&lt;/a&gt; IN演算子を最適化できます。</target>
        </trans-unit>
        <trans-unit id="4b67d5103aec179badd00d13df4b687ed31a2fd8" translate="yes" xml:space="preserve">
          <source>The query planner is more aggressive about using &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexes&lt;/a&gt; for views and subqueries for which it is not possible to create a persistent index.</source>
          <target state="translated">クエリプランナーは、永続的なインデックスを作成できないビューとサブクエリに&lt;a href=&quot;optoverview#autoindex&quot;&gt;自動インデックス&lt;/a&gt;を使用することについてより積極的です。</target>
        </trans-unit>
        <trans-unit id="0ff80f93923c8ea0ed391da80428d773af3f58c7" translate="yes" xml:space="preserve">
          <source>The query planner is now able to use &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt; that contain AND-connected terms in the WHERE clause.</source>
          <target state="translated">クエリプランナーは、WHERE句でAND接続された用語を含む&lt;a href=&quot;partialindex&quot;&gt;部分インデックス&lt;/a&gt;を使用できるようになりました。</target>
        </trans-unit>
        <trans-unit id="f1bf26dc5394aa893fb29edbb88f7b0f3c1a3bf4" translate="yes" xml:space="preserve">
          <source>The query planner loads the content of the statistics tables into memory when the schema is read. Hence, when an application changes the statistics tables directly, SQLite will not immediately notice the changes. An application can force the query planner to reread the statistics tables by running &lt;b&gt;ANALYZE sqlite_master&lt;/b&gt;.</source>
          <target state="translated">クエリプランナーは、スキーマの読み取り時に統計テーブルの内容をメモリに読み込みます。したがって、アプリケーションが統計テーブルを直接変更しても、SQLiteはすぐには変更に気付きません。アプリケーションは&lt;b&gt;ANALYZE sqlite_masterを&lt;/b&gt;実行することにより、クエリプランナーに統計テーブルを強制的に再読み込みさせることができます。</target>
        </trans-unit>
        <trans-unit id="b54043d2a3881a0e42bb93d2a4b188d8e3b927bd" translate="yes" xml:space="preserve">
          <source>The query planner loads the content of the statistics tables into memory when the schema is read. Hence, when an application changes the statistics tables directly, SQLite will not immediately notice the changes. An application can force the query planner to reread the statistics tables by running &lt;b&gt;ANALYZE sqlite_schema&lt;/b&gt;.</source>
          <target state="translated">クエリプランナーは、スキーマが読み取られるときに統計テーブルのコンテンツをメモリにロードします。したがって、アプリケーションが統計テーブルを直接変更しても、SQLiteはすぐに変更に気付くことはありません。アプリケーションは、&lt;b&gt;ANALYZE sqlite_schemaを&lt;/b&gt;実行することにより、クエリプランナーに統計テーブルの再&lt;b&gt;読み取りを強制でき&lt;/b&gt;ます。</target>
        </trans-unit>
        <trans-unit id="764ebb928a21a2403e7ad4384e4177e72689b2ef" translate="yes" xml:space="preserve">
          <source>The query planner must decide between many possible implementations of this query, but two plans in particular are of note:</source>
          <target state="translated">クエリプランナは、このクエリの多くの可能性のある実装の中から決定しなければなりませんが、特に2つのプランに注目してください。</target>
        </trans-unit>
        <trans-unit id="35937457496b4c465e761e374d83f1c328cfb649" translate="yes" xml:space="preserve">
          <source>The query planner now does a better job of optimizing &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; accesses in a 3-way or higher join where constraints on the virtual table are split across two or more other tables of the join.</source>
          <target state="translated">クエリプランナーは、&lt;a href=&quot;vtab&quot;&gt;仮想テーブルの&lt;/a&gt;制約が結合の他の2つ以上のテーブルに分割されている3ウェイ以上の結合で、仮想テーブルアクセスを最適化するという優れた機能を実行します。</target>
        </trans-unit>
        <trans-unit id="ecefb9cd6e1de2d9ed81b2814e874ca9b432f553" translate="yes" xml:space="preserve">
          <source>The query planner now prefers to implement FROM-clause subqueries using &lt;a href=&quot;optoverview#coroutines&quot;&gt;co-routines&lt;/a&gt; rather using the &lt;a href=&quot;optoverview#flattening&quot;&gt;query flattener&lt;/a&gt; optimization. Support for the use of co-routines for subqueries may no longer be disabled.</source>
          <target state="translated">問い合わせプランナは現在、使用してFROM句のサブクエリを実装することを好む&lt;a href=&quot;optoverview#coroutines&quot;&gt;コルーチン&lt;/a&gt;ではなく使用して&lt;a href=&quot;optoverview#flattening&quot;&gt;、クエリの分割・統合&lt;/a&gt;の最適化を。サブクエリのコルーチンの使用のサポートが無効にされなくなった可能性があります。</target>
        </trans-unit>
        <trans-unit id="39ca8ebd42e9f170c8e29a8cb05c453c4287996d" translate="yes" xml:space="preserve">
          <source>The query planner now recognizes that any column in the right-hand table of a LEFT JOIN can be NULL, even if that column has a NOT NULL constraint. Avoid trying to optimize out NULL tests in those cases. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/6f2222d550f5b0ee7ed&quot;&gt;6f2222d550f5b0ee7ed&lt;/a&gt;.</source>
          <target state="translated">クエリプランナーは、その列にNOT NULL制約がある場合でも、LEFT JOINの右側のテーブルの列がNULLになる可能性があることを認識します。このような場合は、NULLテストを最適化しないでください。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/6f2222d550f5b0ee7ed&quot;&gt;6f2222d550f5b0ee7edの&lt;/a&gt;修正。</target>
        </trans-unit>
        <trans-unit id="ec8769590db8f2b5c877d645663be729be900155" translate="yes" xml:space="preserve">
          <source>The query planner now uses &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; information (created by &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;) to help determine if the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt; is appropriate.</source>
          <target state="translated">クエリプランナーは、（&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;によって作成された）&lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt;情報を使用して、&lt;a href=&quot;optoverview#skipscan&quot;&gt;スキップスキャン最適化&lt;/a&gt;が適切かどうかを判断するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="c31a7ce3fe100e3f0ec40a06c5c355aa9ab9699f" translate="yes" xml:space="preserve">
          <source>The query planner used &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt;-style statistics for one or more indexes of the table at some point during the lifetime of the current connection.</source>
          <target state="translated">クエリプランナーは、現在の接続の存続期間中のある時点で、テーブルの1つ以上のインデックスに対して&lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt;スタイルの統計を使用しました。</target>
        </trans-unit>
        <trans-unit id="a97e7a7c05ace47af23f942a5bb054692500ea21" translate="yes" xml:space="preserve">
          <source>The query planner uses a full scan of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; instead of a full scan of the main table, in cases where that makes sense.</source>
          <target state="translated">クエリプランナーは、メインテーブルのフルスキャンの代わりに、&lt;a href=&quot;partialindex&quot;&gt;部分インデックスの&lt;/a&gt;フルスキャンを使用します。</target>
        </trans-unit>
        <trans-unit id="5c0c2991e6f563d6716af52b8b617039da1f2fdd" translate="yes" xml:space="preserve">
          <source>The query starts by doing a binary search on the Idx1 index for entries that have fruit='Peach'. SQLite can do this binary search on the Idx1 index but not on the original FruitsForSale table because the rows in Idx1 are sorted by the &quot;fruit&quot; column. Having found a row in the Idx1 index that has fruit='Peach', the database engine can extract the rowid for that row. Then the database engines does a second binary search on the original FruitsForSale table to find the original row that contains fruit='Peach'. From the row in the FruitsForSale table, SQLite can then extract the value of the price column. This procedure is illustrated by &lt;a href=&quot;#fig5&quot;&gt;figure 5&lt;/a&gt;.</source>
          <target state="translated">クエリは、frx = 'Peach'を持つエントリのIdx1インデックスでバイナリ検索を実行することから始まります。 SQLiteは、Idx1の行が「fruit」列でソートされているため、Idx1インデックスでこのバイナリ検索を実行できますが、元のFruitsForSaleテーブルでは実行できません。 Fruit = 'Peach'を持つIdx1インデックス内の行を検出すると、データベースエンジンはその行のROWIDを抽出できます。次に、データベースエンジンは、元のFruitsForSaleテーブルで2番目のバイナリ検索を実行して、fruit = 'Peach'を含む元の行を見つけます。 SQLiteは、FruitsForSaleテーブルの行から、price列の値を抽出できます。この手順を&lt;a href=&quot;#fig5&quot;&gt;図5に&lt;/a&gt;示します。</target>
        </trans-unit>
        <trans-unit id="7d2f0fdfeb4c2c835aff8667a9df0a76c56f4c48" translate="yes" xml:space="preserve">
          <source>The query string is optional. If the query string is present, then all query parameters are passed through into the xOpen method of the underlying &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;.</source>
          <target state="translated">クエリ文字列はオプションです。クエリ文字列が存在する場合、すべてのクエリパラメータが基になる&lt;a href=&quot;vfs&quot;&gt;VFSの&lt;/a&gt; xOpenメソッドに渡されます。</target>
        </trans-unit>
        <trans-unit id="85170b302d04cae08fe65e554bbdfb1393e9fe62" translate="yes" xml:space="preserve">
          <source>The query syntax has been revised where necessary to remove ambiguities and to make it possible to escape special characters in query terms.</source>
          <target state="translated">クエリ構文は、曖昧さを取り除き、クエリ用語の中の特殊文字をエスケープできるようにするために、必要に応じて改訂されました。</target>
        </trans-unit>
        <trans-unit id="6a08992b107064a2b4d32992f6db718c41160975" translate="yes" xml:space="preserve">
          <source>The query_only pragma prevents all changes to database files when enabled.</source>
          <target state="translated">query_only pragmaが有効な場合、データベースファイルへのすべての変更を防止します。</target>
        </trans-unit>
        <trans-unit id="c227c47e0d2b0279a9dff3f8b02f840ecf77eb68" translate="yes" xml:space="preserve">
          <source>The quote(X) function returns the text of an SQL literal which is the value of its argument suitable for inclusion into an SQL statement. Strings are surrounded by single-quotes with escapes on interior quotes as needed. BLOBs are encoded as hexadecimal literals. Strings with embedded NUL characters cannot be represented as string literals in SQL and hence the returned string literal is truncated prior to the first NUL.</source>
          <target state="translated">quote(X)関数は、SQL文に含めるのに適したSQLリテラルのテキストを返します。文字列はシングルクォートで囲まれ、必要に応じて内部引用符にはエスケープが入ります。BLOBは16進リテラルとしてエンコードされます。NUL文字が埋め込まれた文字列はSQLでは文字列リテラルとして表現できないため、返される文字列リテラルは最初のNUL文字より前に切り捨てられます。</target>
        </trans-unit>
        <trans-unit id="9f63b25a5004d971fa73a7b89854797c36e88a71" translate="yes" xml:space="preserve">
          <source>The random() function provides 64 bits of randomness instead of only 32 bits.</source>
          <target state="translated">random()関数は、32 ビットだけではなく 64 ビットのランダム性を提供します。</target>
        </trans-unit>
        <trans-unit id="db5db9919e511217ef7da4b79216c59c757f004b" translate="yes" xml:space="preserve">
          <source>The random() function returns a pseudo-random integer between -9223372036854775808 and +9223372036854775807.</source>
          <target state="translated">random()関数は、-9223372036854775808から+9223372036854775807の間の擬似乱数を返します。</target>
        </trans-unit>
        <trans-unit id="dc66046ce33b1a2430fa7d3f10cb359cc80fae20" translate="yes" xml:space="preserve">
          <source>The randomblob(N) function return an N-byte blob containing pseudo-random bytes. If N is less than 1 then a 1-byte random blob is returned.</source>
          <target state="translated">randlob(N)関数は疑似ランダムバイトを含む N バイトの blob を返します。N が 1 より小さい場合は、1 バイトのランダムブロブが返されます。</target>
        </trans-unit>
        <trans-unit id="c291d5ba33f13d62c916974b77fcaf954ce3ff7e" translate="yes" xml:space="preserve">
          <source>The rank of the column within the index. (0 means left-most. Key columns come before auxiliary columns.)</source>
          <target state="translated">インデックス内の列のランク。(0は左端を意味し、キーカラムは補助カラムの前に来る)。</target>
        </trans-unit>
        <trans-unit id="0b2bd6ab8a45c757d36fc0179def745c6a1bbb66" translate="yes" xml:space="preserve">
          <source>The rank of the column within the index. (0 means left-most.)</source>
          <target state="translated">インデックス内のカラムのランク。(0は左端を意味する)</target>
        </trans-unit>
        <trans-unit id="463c4210effd7ad2a8dada3187acf9269beea08a" translate="yes" xml:space="preserve">
          <source>The rank of the column within the table being indexed, or -1 if the index-column is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the table being indexed and -2 if the &lt;a href=&quot;expridx&quot;&gt;index is on an expression&lt;/a&gt;.</source>
          <target state="translated">インデックスが作成されるテーブル内の列のランク&lt;a href=&quot;lang_createtable#rowid&quot;&gt;。index&lt;/a&gt; -columnがインデックスが作成されるテーブルのROWIDの場合は-1 、&lt;a href=&quot;expridx&quot;&gt;インデックスが式にある&lt;/a&gt;場合は-2 。</target>
        </trans-unit>
        <trans-unit id="84413b7d19914c0bede4000ce3b0ffb8491410c6" translate="yes" xml:space="preserve">
          <source>The rank of the column within the table being indexed. A value of -1 means &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; and a value of -2 means that an &lt;a href=&quot;expridx&quot;&gt;expression&lt;/a&gt; is being used.</source>
          <target state="translated">インデックスが作成されるテーブル内の列のランク。値-1は&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;を意味し、値-2は&lt;a href=&quot;expridx&quot;&gt;式&lt;/a&gt;が使用されていることを意味します。</target>
        </trans-unit>
        <trans-unit id="8754b3bec73ba7fde29d928b708ca495c5b77ae4" translate="yes" xml:space="preserve">
          <source>The rank of word.</source>
          <target state="translated">言葉のランク。</target>
        </trans-unit>
        <trans-unit id="2dd609ed9718452c7fad1b16788c833004253127" translate="yes" xml:space="preserve">
          <source>The rank option is used to change the default auxiliary function mapping for the rank column. The option should be set to a text value in the same format as described for &lt;a href=&quot;fts5#sorting_by_auxiliary_function_results&quot;&gt;&quot;rank MATCH ?&quot;&lt;/a&gt; terms above. For example:</source>
          <target state="translated">ランクオプションを使用して、ランク列のデフォルトの補助関数マッピングを変更します。このオプションは、&lt;a href=&quot;fts5#sorting_by_auxiliary_function_results&quot;&gt;「ランクマッチ？」で&lt;/a&gt;説明したのと同じ形式のテキスト値に設定する必要があります。上記の条件。例えば：</target>
        </trans-unit>
        <trans-unit id="3e012920d09c510ffee894f9967688d5537ade9a" translate="yes" xml:space="preserve">
          <source>The rate of enhancement for SQLite over the previous five years (2010-2015) is approximately 6 increments of Y per year. The numbering format used by for &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; and &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; allows versions up to 3.999.999, which is more than enough for the planned end-of-support date for SQLite in 2050. However, the current tarball naming conventions only reserve two digits for the Y and so the naming format for downloads will need to be revised in about 2030.</source>
          <target state="translated">SQLiteの過去5年間（2010-2015）の強化率は、年間で約6増分です。が&lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;および&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number（）に&lt;/a&gt;使用する番号付け形式では、最大3.999.999のバージョンを使用できます。これは、2050年のSQLiteのサポート終了予定日には十分です。ただし、現在のtarball命名規則では、 Yなど、ダウンロードの命名形式は2030年頃に修正する必要があります。</target>
        </trans-unit>
        <trans-unit id="e8a5095befc118ca6a6fec21354c920d6bd315d2" translate="yes" xml:space="preserve">
          <source>The reader algorithm in the previous paragraphs works correctly, but because frames for page P can appear anywhere within the WAL, the reader has to scan the entire WAL looking for page P frames. If the WAL is large (multiple megabytes is typical) that scan can be slow, and read performance suffers. To overcome this problem, a separate data structure called the wal-index is maintained to expedite the search for frames of a particular page.</source>
          <target state="translated">前の段落のリーダーアルゴリズムは正しく動作しますが、ページPのフレームはWAL内のどこにでも現れる可能性があるため、リーダーはページPのフレームを探してWAL全体をスキャンしなければなりません。WALが大きい場合(数メガバイトが一般的です)、スキャンに時間がかかり、読み取り性能が低下します。この問題を克服するために、特定のページのフレームの検索を迅速化するために、wal-indexと呼ばれる別個のデータ構造が維持されています。</target>
        </trans-unit>
        <trans-unit id="3e2fc6a74baa30b6fadb3fd43bce3110d90f198d" translate="yes" xml:space="preserve">
          <source>The readfile(X) SQL function reads the entire content of the file named X and returns that content as a BLOB. This can be used to load content into a table. For example:</source>
          <target state="translated">readfile(X)SQL 関数は、X という名前のファイルの内容全体を読み込み、その内容を BLOB として返します。これは、テーブルにコンテンツをロードするために使用することができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="f5d4c0c9266d8eca05dca08f98a5cbf6d922d36a" translate="yes" xml:space="preserve">
          <source>The realization that an aggregate query is really two consecutive loops makes it much easier to understand the difference between a WHERE clause and a HAVING clause in SQL query statement. The WHERE clause is a restriction on the first loop and the HAVING clause is a restriction on the second loop. You can see this by adding both a WHERE and a HAVING clause to our example query:</source>
          <target state="translated">集計クエリは実際には2つの連続したループであるということを理解することで、SQLクエリ文のWHERE句とHAVING句の違いを理解するのが非常に簡単になります。WHERE 句は最初のループに対する制限であり、HAVING 句は 2 番目のループに対する制限です。この例のクエリに WHERE 句と HAVING 句の両方を追加すると、このことがわかります。</target>
        </trans-unit>
        <trans-unit id="4a5758542d7b569e5728a8a94a0c5f527ec1ddfe" translate="yes" xml:space="preserve">
          <source>The reallocarray() interface is a recent innovation (circa 2014) from the OpenBSD community that grow out of efforts to prevent the next &lt;a href=&quot;http://heartbleed.com&quot;&gt;&quot;heartbleed&quot; bug&lt;/a&gt; by avoiding 32-bit integer arithmetic overflow on memory allocation size computations. The reallocarray() function has both unit-size and count parameters. To allocate memory sufficient to hold an array of N elements each X-bytes in size, one calls &quot;reallocarray(0,X,N)&quot;. This is preferred over the traditional technique of invoking &quot;malloc(X*N)&quot; as reallocarray() eliminates the risk that the X*N multiplication will overflow and cause malloc() to return a buffer that is a different size from what the application expected.</source>
          <target state="translated">reallocarray（）インターフェースはOpenBSDコミュニティによる最近の革新（2014年頃）であり、メモリ割り当てサイズの計算で32ビット整数の算術オーバーフローを回避することにより、次の&lt;a href=&quot;http://heartbleed.com&quot;&gt;「ハートブリード」バグ&lt;/a&gt;を防ぐための努力から成長しました。 reallocarray（）関数には、ユニットサイズとカウントの両方のパラメーターがあります。サイズがそれぞれXバイトのN要素の配列を保持するのに十分なメモリを割り当てるには、「reallocarray（0、X、N）」を呼び出します。 reallocarray（）はX * N乗算がオーバーフローし、malloc（）がアプリケーションとは異なるサイズのバッファーを返すリスクを排除するため、これは「malloc（X * N）」を呼び出す従来の手法よりも推奨されます。期待された。</target>
        </trans-unit>
        <trans-unit id="a25a89f7da0624003a3e075ec1d5437a5611f942" translate="yes" xml:space="preserve">
          <source>The reason for attempting to read the</source>
          <target state="translated">を読もうとした理由は</target>
        </trans-unit>
        <trans-unit id="61ed3e5eacc7786aa96400e0606560d6b0c2919c" translate="yes" xml:space="preserve">
          <source>The reason for this is easy to understand: When a document is inserted into the FTS5 table, an entry is added to the full-text index to record the position of each token within the new document. When a document is removed, the original data is required in order to determine the set of entries that need to be removed from the full-text index. So if the data supplied to FTS5 when a row is deleted using this command is different from that used to determine the set of token instances when it was inserted, some full-text index entries may not be correctly deleted, or FTS5 may try to remove index entries that do not exist. This can leave the full-text index in an unpredictable state, making future query results unreliable.</source>
          <target state="translated">その理由は簡単に理解できます。文書がFTS5テーブルに挿入されると、新しい文書内の各トークンの位置を記録するためのエントリが全文インデックスに追加される。文書が削除されると、全文インデックスから削除する必要のあるエントリのセットを決定するために、元のデータが必要となります。そのため、このコマンドを使用して行が削除されたときに FTS5 に供給されたデータが、それが挿入されたときのトークンインスタンスのセットを決定するために使用されたものと異なる場合、一部のフルテキストインデックスエントリが正しく削除されなかったり、FTS5 が存在しないインデックスエントリを削除しようとしたりする可能性があります。これにより、全文インデックスが予測不可能な状態になってしまい、将来の問い合わせ結果が信頼できなくなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="aaf49440241f0d03e40af262860c9b5798f65bc8" translate="yes" xml:space="preserve">
          <source>The reason that the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; has its buffer pointer and buffer size arguments reversed from what is found in the standard library snprintf() routine is because there was no snprintf() routine in the standard C library when Hipp was first implementing his version, and he chose a different order than the designers of the standard C library.</source>
          <target state="translated">その理由という&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintfは、（） &lt;/a&gt;（）ヒップが最初に彼のバージョンを実装した標準Cライブラリにはのsnprintf（）ルーチンがなかったので、ルーチンはそのバッファポインタを持っており、標準ライブラリのsnprintfで発見されたものとは逆のサイズ引数をバッファリングし、そして彼は、標準Cライブラリの設計者とは異なる順序を選択しました。</target>
        </trans-unit>
        <trans-unit id="791eaa4dd6fb2ae12ed4b869340107d40b780f17" translate="yes" xml:space="preserve">
          <source>The reasons why C is the best language to implement SQLite include:</source>
          <target state="translated">SQLiteを実装するのにC言語が最適な理由には、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="570c3cd1b218e89b5e9796c1a0c8bf3041d5fcd8" translate="yes" xml:space="preserve">
          <source>The recommended fix for this problem is to select a different filesystem. These days, there is a huge selection of high-performance, reliable, patent-free filesystems that support long filenames. Where possible, it is recommended that embedded devices use one of these other filesystems. This will avoid compatibility issues and the danger of &lt;a href=&quot;shortnames#db83corrupt&quot;&gt;database corruption caused by inconsistent use of 8+3 filenames&lt;/a&gt;.</source>
          <target state="translated">この問題に対して推奨される修正は、別のファイルシステムを選択することです。最近では、長いファイル名をサポートする、高性能で信頼性が高く、特許を取得していないファイルシステムが数多くあります。可能な場合は、組み込みデバイスでこれらの他のファイルシステムのいずれかを使用することをお勧めします。これにより、互換性の問題と、&lt;a href=&quot;shortnames#db83corrupt&quot;&gt;8 + 3のファイル名の一貫性のない使用によって引き起こされるデータベースの破損&lt;/a&gt;の危険が回避されます。</target>
        </trans-unit>
        <trans-unit id="25181bcaf1df8e046a1c955d3b9df90abb750621" translate="yes" xml:space="preserve">
          <source>The recommended setting is 0, meaning that double-quoted strings are disallowed in all contexts. However, the default setting is 3 for maximum compatibility with legacy applications.</source>
          <target state="translated">推奨される設定は 0 で、すべてのコンテキストで二重引用符で囲まれた文字列は禁止されています。しかし、レガシーアプリケーションとの互換性を最大化するために、デフォルトの設定は3です。</target>
        </trans-unit>
        <trans-unit id="932d02d128af056f356f5d45448ef957094cec8a" translate="yes" xml:space="preserve">
          <source>The recommended usage pattern for the &lt;a href=&quot;pragma#pragma_analysis_limit&quot;&gt;analysis_limit&lt;/a&gt; pragma is like this:</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_analysis_limit&quot;&gt;analysis_limit&lt;/a&gt;プラグマの推奨される使用パターンは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="f9e4e6885559253d0ddfdbd8cf19b8d22821af1f" translate="yes" xml:space="preserve">
          <source>The recommended way of creating, updating, listing, and extracting an SQLite Archive is to use the &lt;a href=&quot;cli&quot;&gt;sqlite3.exe command-line shell&lt;/a&gt; for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_23_0.html&quot;&gt;version 3.23.0&lt;/a&gt; (2018-04-02) or later. This CLI supports the -A command-line option that allows easy management of SQLite Archives. The CLI for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;version 3.22.0&lt;/a&gt; (2018-01-22) has the &lt;a href=&quot;cli#sqlar&quot;&gt;.archive command&lt;/a&gt; for managing SQLite Archives, but that requires interacting with the shell.</source>
          <target state="translated">SQLiteアーカイブの作成、更新、一覧表示、および抽出の推奨される方法は、SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_23_0.html&quot;&gt;バージョン3.23.0&lt;/a&gt;（2018-04-02）以降で&lt;a href=&quot;cli&quot;&gt;sqlite3.exeコマンドラインシェル&lt;/a&gt;を使用することです。このCLIは、SQLiteアーカイブの管理を容易にする-Aコマンドラインオプションをサポートしています。SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;バージョン3.22.0&lt;/a&gt;（2018-01-22）のCLIには、SQLiteアーカイブを管理するための&lt;a href=&quot;cli#sqlar&quot;&gt;.archiveコマンド&lt;/a&gt;がありますが、これにはシェルとの対話が必要です。</target>
        </trans-unit>
        <trans-unit id="4601afd19c62f4d6f4dd6a59905680482f9f3f16" translate="yes" xml:space="preserve">
          <source>The record format makes extensive use of the &lt;a href=&quot;fileformat2#varint&quot;&gt;variable-length integer&lt;/a&gt; or &lt;a href=&quot;fileformat2#varint&quot;&gt;varint&lt;/a&gt; representation of 64-bit signed integers defined above.</source>
          <target state="translated">レコード形式は、上記で定義された64ビット符号付き整数の&lt;a href=&quot;fileformat2#varint&quot;&gt;可変長整数&lt;/a&gt;または&lt;a href=&quot;fileformat2#varint&quot;&gt;可変長&lt;/a&gt;表現を広範囲に使用します。</target>
        </trans-unit>
        <trans-unit id="6f45dfeab7c8fdea2c19dfb3263b7e954261008d" translate="yes" xml:space="preserve">
          <source>The register P3 contains one less than the maximum number of allowed errors. At most reg(P3) errors will be reported. In other words, the analysis stops as soon as reg(P1) errors are seen. Reg(P1) is updated with the number of errors remaining.</source>
          <target state="translated">レジスタP3には、許容される最大エラー数よりも1つ少ないエラーが含まれています。最大でもreg(P3)エラーが報告されます。つまり、reg(P1)エラーが見られるとすぐに解析が停止します。reg(P1)は、残りのエラー数で更新される。</target>
        </trans-unit>
        <trans-unit id="b0a0f881a2de041dc76deecadc2825d6252c40fe" translate="yes" xml:space="preserve">
          <source>The registers P1 through P1+P2-1 contain a single row of results. This opcode causes the sqlite3_step() call to terminate with an SQLITE_ROW return code and it sets up the sqlite3_stmt structure to provide access to the r(P1)..r(P1+P2-1) values as the result row.</source>
          <target state="translated">レジスタP1からP1+P2-1は結果の1行を含んでいます。このオペコードはsqlite3_step()呼び出しをSQLITE_ROWリターンコードで終了させ、結果行としてr(P1)...r(P1+P2-1)値へのアクセスを提供するためにsqlite3_stmt構造体をセットアップします。</target>
        </trans-unit>
        <trans-unit id="3af4c8adff2c9c78e4e3d405284a88188dcbb490" translate="yes" xml:space="preserve">
          <source>The registers released will be the P2 registers starting at P1, except if bit ii of P3 set, then do not release register P1+ii. In other words, P3 is a mask of registers to preserve.</source>
          <target state="translated">解放されるレジスタはP1から始まるP2レジスタとなり、P3のビットiiがセットされている場合はレジスタP1+iiを解放しない。つまり、P3は保存するレジスタのマスクである。</target>
        </trans-unit>
        <trans-unit id="3ad008f7525662f6767cf59c0a5ffbf397455036" translate="yes" xml:space="preserve">
          <source>The relative precedence of the set operations is different. In particular, using the standard query syntax the &quot;OR&quot; operator has a higher precedence than &quot;AND&quot;. The precedence of operators when using the standard query syntax is:</source>
          <target state="translated">集合演算の相対的な優先順位は異なります。特に、標準的なクエリ構文では、&quot;OR &quot;演算子の方が &quot;AND &quot;演算子よりも優先順位が高くなります。標準のクエリ構文を使用した場合の演算子の優先順位は</target>
        </trans-unit>
        <trans-unit id="4055a7e54aa1eb8dd8ef4889c3d207a5659a2b35" translate="yes" xml:space="preserve">
          <source>The release build is used to validate the generated machine code.</source>
          <target state="translated">リリースビルドは、生成されたマシンコードを検証するために使用されます。</target>
        </trans-unit>
        <trans-unit id="4fe1d3a13dd63ed4836e434d893dc270763cfe84" translate="yes" xml:space="preserve">
          <source>The release checklist is continuously evolving. As new problems or potential problems are discovered, new checklist items are added to make sure those problems do not appear in subsequent releases. The release checklist has proven to be an invaluable tool in helping to ensure that nothing is overlooked during the release process.</source>
          <target state="translated">リリースチェックリストは継続的に進化しています。新しい問題や潜在的な問題が発見されるたびに、新しいチェックリスト項目が追加され、後続のリリースでそれらの問題が発生しないようになっています。リリースチェックリストは、リリースプロセス中に見落とされることがないようにするための貴重なツールであることが証明されています。</target>
        </trans-unit>
        <trans-unit id="54fb9bcb3273ff541df78c3b4ae7a5c1d95caf43" translate="yes" xml:space="preserve">
          <source>The release checklist is not automated: developers run each item on the checklist manually. We find that it is important to keep a human in the loop. Sometimes problems are found while running a checklist item even though the test itself passed. It is important to have a human reviewing the test output at the highest level, and constantly asking &quot;Is this really right?&quot;</source>
          <target state="translated">リリースチェックリストは自動化されていません:開発者はチェックリストの各項目を手動で実行します。人間をループの中に入れておくことが重要であることがわかります。テスト自体は合格しているのに、チェックリストの項目を実行している間に問題が見つかることがあります。人間がテスト出力を最高レベルでレビューし、常に &quot;これは本当に正しいのか?&quot;と質問することが重要です。</target>
        </trans-unit>
        <trans-unit id="2c9d643524e4e559789769fa0d9c05fd5ba6364a" translate="yes" xml:space="preserve">
          <source>The relevancy of a document may depend on something other than just the data available in the return value of matchinfo. For example each document in the database may be assigned a static weight based on factors unrelated to its content (origin, author, age, number of references etc.). These values can be stored by the application in a separate table that can be joined against the documents table in the sub-query so that the rank function may access them.</source>
          <target state="translated">文書の関連性は、 matchinfo の戻り値で得られるデータ以外にも依存する場合があります。例えば、データベース内の各ドキュメントは、その内容とは無関係な要素(出典、著者、年齢、参照数など)に基づいて静的な重みを割り当てることができます。これらの値はアプリケーションによって別のテーブルに格納され、副問い合わせのdocumentsテーブルに対して結合され、ランク関数がアクセスできるようにすることができます。</target>
        </trans-unit>
        <trans-unit id="d03714ee4fa95f4e8679f472e2f3c59cc9a47883" translate="yes" xml:space="preserve">
          <source>The reliability and robustness of SQLite is achieved in part by thorough and careful testing.</source>
          <target state="translated">SQLiteの信頼性と堅牢性は、徹底した慎重なテストによって部分的に達成されています。</target>
        </trans-unit>
        <trans-unit id="7a3157bd64ab9a637ba9a36bada2711bd2147294" translate="yes" xml:space="preserve">
          <source>The remainder of this document will guide the reader through the steps needed to maintain a private branch. The general idea is the same as outlined above. This section merely provides more detail.</source>
          <target state="translated">ここでは、個人経営の支店を維持するために必要な手順を説明します。一般的な考え方は、上記で説明した通りです。このセクションでは、より詳細な説明をしています。</target>
        </trans-unit>
        <trans-unit id="30a538553e382aa8cfb9498b6fd827480cf2d80b" translate="yes" xml:space="preserve">
          <source>The remaining fields of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object all store pointers to functions that implement primitive operations. We call these &quot;methods&quot;. The first method, xOpen, is used to open files on the underlying storage media. The result is an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object. There are additional methods, defined by the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object itself that are used to read and write and close the file. The additional methods are detailed below. The filename is in UTF-8. SQLite will guarantee that the zFilename string passed to xOpen() is a full pathname as generated by xFullPathname() and that the string will be valid and unchanged until xClose() is called. So the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; can store a pointer to the filename if it needs to remember the filename for some reason. The flags argument to xOpen() is a copy of the flags argument to sqlite3_open_v2(). If sqlite3_open() or sqlite3_open16() is used, then flags is &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;. If xOpen() opens a file read-only then it sets *pOutFlags to include &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;. Other bits in *pOutFlags may be set. SQLite will also add one of the following flags to the xOpen() call, depending on the object being opened:</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトの残りのフィールドはすべて、プリミティブ操作を実装する関数へのポインターを格納します。これらを「方法」と呼びます。最初の方法であるxOpenは、基になるストレージメディア上のファイルを開くために使用されます。結果は&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;オブジェクトです。&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;オブジェクト自体によって定義される追加のメソッドがあり、ファイルの読み取りと書き込み、およびファイルのクローズに使用されます。追加の方法は以下に詳述されています。ファイル名はUTF-8です。 SQLiteは、xOpen（）に渡されるzFilename文字列がxFullPathname（）によって生成される完全パス名であること、およびxClose（）が呼び出されるまで文字列が有効で変更されないことを保証します。したがって、&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;何らかの理由でファイル名を記憶する必要がある場合は、ファイル名へのポインタを保存できます。 xOpen（）のflags引数は、sqlite3_open_v2（）のflags引数のコピーです。 sqlite3_open（）またはsqlite3_open16（）を使用する場合、フラグは&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | です。&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;。 xOpen（）がファイルを読み取り専用で開く場合は、* pOutFlagsを設定してSQLITE_OPEN_READONLYを含め&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;ます&lt;/a&gt;。 * pOutFlagsの他のビットが設定される場合があります。 SQLiteは、開かれているオブジェクトに応じて、xOpen（）呼び出しに次のフラグのいずれかを追加します。</target>
        </trans-unit>
        <trans-unit id="75ee3ed9cd8aa1cdca7e660d366395ab9cdd104b" translate="yes" xml:space="preserve">
          <source>The remaining seven methods defined by this structure (xMutexAlloc, xMutexFree, xMutexEnter, xMutexTry, xMutexLeave, xMutexHeld and xMutexNotheld) implement the following interfaces (respectively):</source>
          <target state="translated">この構造体によって定義された残りの7つのメソッド(xMutexAlloc、xMutexFree、xMutexEnter、xMutexTry、xMutexLeave、xMutexHeld、およびxMutexNotheld)は、それぞれ以下のインタフェースを実装しています(それぞれ)。</target>
        </trans-unit>
        <trans-unit id="01d5ccb02fb58f9483b8bb4a6c89788e5e99328d" translate="yes" xml:space="preserve">
          <source>The remove_diacritics option is not supported.</source>
          <target state="translated">remove_diacritics オプションはサポートされていません。</target>
        </trans-unit>
        <trans-unit id="5dc3bfc4e2330eb1c8eb7d47b9e9b34b4b7effb1" translate="yes" xml:space="preserve">
          <source>The remove_diacritics option may be set to &quot;0&quot;, &quot;1&quot; or &quot;2&quot;. The default value is &quot;1&quot;. If it is set to &quot;1&quot; or &quot;2&quot;, then diacritics are removed from Latin script characters as described above. However, if it is set to &quot;1&quot;, then diacritics are not removed in the fairly uncommon case where a single unicode codepoint is used to represent a character with more that one diacritic. For example, diacritics are not removed from codepoint 0x1ED9 (&quot;LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW&quot;). This is technically a bug, but cannot be fixed without creating backwards compatibility problems. If this option is set to &quot;2&quot;, then diacritics are correctly removed from all Latin characters.</source>
          <target state="translated">remove_diacriticsオプションは、&quot;0&quot;、&quot;1&quot;、または &quot;2 &quot;を設定することができます。デフォルト値は &quot;1 &quot;です。1&quot; または &quot;2&quot; に設定されている場合、上述したように、ラテンスクリプトの文字の中からダイアクリティックが削除されます。しかし、&quot;1 &quot;に設定されている場合は、単一のユニコードコードのコードポイントを使用して複数のダイアクリティックを持つ文字を表現するというかなり珍しいケースでは、ダイアクリティックは削除されません。例えば、コードポイント 0x1ED9 (&quot;LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW&quot;)の場合、ダイアクリティカルは削除されません。これは技術的にはバグですが、下位互換性の問題を生まずに修正することはできません。このオプションが &quot;2&quot; に設定されている場合、すべてのラテン文字からダイアクリティカルが正しく削除されます。</target>
        </trans-unit>
        <trans-unit id="e878b1555960f1149f69c44e721edf9e3c3726dd" translate="yes" xml:space="preserve">
          <source>The replace(X,Y,Z) function returns a string formed by substituting string Z for every occurrence of string Y in string X. The &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt; collating sequence is used for comparisons. If Y is an empty string then return X unchanged. If Z is not initially a string, it is cast to a UTF-8 string prior to processing.</source>
          <target state="translated">replace（X、Y、Z）関数は、文字列Xで文字列Yが出現するたびに文字列Zを代入して形成される文字列を返します。比較には&lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt;照合シーケンスが使用されます。Yが空の文字列の場合、Xを変更せずに返します。Zが最初に文字列でない場合、処理の前にUTF-8文字列にキャストされます。</target>
        </trans-unit>
        <trans-unit id="7d84cb3d97dd720ff83b043f47169f048a42ed9d" translate="yes" xml:space="preserve">
          <source>The repository created in the previous step is initially empty. The next step is to load the baseline SQLite release - circle (1) in the diagram above.</source>
          <target state="translated">前のステップで作成したリポジトリは初期状態では空です。次のステップでは、ベースラインのSQLiteリリースをロードします-上図の○印(1)を付けます。</target>
        </trans-unit>
        <trans-unit id="10c2d611bbd1154503c3d2f589b7893620f36217" translate="yes" xml:space="preserve">
          <source>The reserved region is an area of unused space at the end of every page (except the locking page) that extensions can use to hold per-page information. The size of the reserved region is determined by the one-byte unsigned integer found at an offset of 20 into the database file header. The size of the reserved region is usually zero.</source>
          <target state="translated">予約領域は、拡張機能がページごとの情報を保持するために使用できる、すべてのページ(ロックページを除く)の最後にある未使用の領域です。予約領域のサイズは、データベース ファイル ヘッダーの 20 のオフセットにある 1 バイト符号なし整数によって決定されます。予約領域のサイズは通常ゼロです。</target>
        </trans-unit>
        <trans-unit id="5406b5dfde9f00d0738ba2c75a1507fa33caf617" translate="yes" xml:space="preserve">
          <source>The reserved region.</source>
          <target state="translated">予約地域です。</target>
        </trans-unit>
        <trans-unit id="aad9068a01cab0c1ed6f0408e5a3ca43105c9476" translate="yes" xml:space="preserve">
          <source>The response of SQLite to out-of-memory (OOM) errors is tested using a specialized memory allocator overlay that can simulate memory failures. The overlay is a layer that is inserted in between the memory allocator and the rest of SQLite. The overlay passes most memory allocation requests straight through to the underlying allocator and passes the results back up to the requester. But the overlay can be set to cause the Nth memory allocation to fail. To run an OOM test, the overlay is first set to fail on the first allocation attempt. Then some test script is run and verification that the allocation was correctly caught and handled is made. Then the overlay is set to fail on the second allocation and the test repeats. The failure point continues to advance one allocation at a time until the entire test procedure runs to completion without hitting a memory allocation error. This whole test sequence run twice. On the first pass, the overlay is set to fail only the Nth allocation. On the second pass, the overlay is set to fail the Nth and all subsequent allocations.</source>
          <target state="translated">メモリ不足(OOM)エラーに対する SQLite の応答は、メモリ障害をシミュレートできる特殊なメモリ・アロケータ・オーバーレイを使用してテストされています。オーバーレイは、メモリアロケータとSQLiteの残りの部分の間に挿入されるレイヤーです。オーバーレイは、ほとんどのメモリ割り当て要求を直接基礎となるアロケータに渡し、その結果を要求元に戻します。しかし、オーバーレイは N 番目のメモリ割り当てに失敗するように設定することができます。OOM テストを実行するには、まず最初のアロケーションの試行で失敗するようにオーバーレイを設定します。その後、テストスクリプトが実行され、アロケーションが正しくキャッチされて処理されたかどうかが検証されます。その後、2 回目のアロケーションでオーバーレイが失敗するように設定され、テストが繰り返されます。失敗ポイントは、テスト手順全体がメモリアロケーションエラーにヒットせずに完了するまで、一度に1つのアロケーションを進め続けます。このテストシーケンスは2回実行されます。最初のパスでは、オーバーレイはN番目のアロケーションのみ失敗するように設定されています。2回目の実行では、N番目のアロケーションとそれ以降のすべてのアロケーションで失敗するように設定されています。</target>
        </trans-unit>
        <trans-unit id="12691a5bbec67aa65e24fe31d2477402bd3c4199" translate="yes" xml:space="preserve">
          <source>The rest of the module structure consists of methods used to implement various features of the virtual table. Details on what each of these methods do are provided in the sequel.</source>
          <target state="translated">モジュール構造の残りの部分は、仮想テーブルの様々な機能を実装するために使用されるメソッドで構成されています。これらのメソッドが何をするのかについての詳細は、 続編で説明します。</target>
        </trans-unit>
        <trans-unit id="4c062c28bf53cd1153a7f659fc941fb25e4394ee" translate="yes" xml:space="preserve">
          <source>The result column names generated for compound subqueries have been simplified to show only the name of the column of the original table and omit the table name. This makes SQLite operate more like other SQL database engines.</source>
          <target state="translated">複合副問い合わせで生成される結果カラム名は、元のテーブルのカラム名のみを表示し、テーブル名を省略するように簡略化されました。これにより、SQLite は他の SQL データベースエンジンと同様に動作するようになりました。</target>
        </trans-unit>
        <trans-unit id="8fba3a08c8f1c5c3b4c188d84f260675274f7bae" translate="yes" xml:space="preserve">
          <source>The result of &quot;(1,2,3)=(1,NULL,3)&quot; is NULL because the result might be true if we replaced NULL&amp;rarr;2 or false if we replaced NULL&amp;rarr;9. The result of &quot;(1,2,3)=(1,NULL,4)&quot; is not NULL because there is no substitutions of the constituent NULL that will make the expression true, since 3 will never equal 4 in the third column.</source>
          <target state="translated">&quot;（1,2,3）=（1、NULL、3）&quot;の結果はNULLです。これは、NULL&amp;rarr;2を置き換えた場合はtrue、NULL&amp;rarr;9を置き換えた場合はfalseになる可能性があるためです。「（1,2,3）=（1、NULL、4）」の結果はNULLではありません。これは、3番目の列で3が4に等しくなることはないため、式を真にする構成NULLの置換がないためです。</target>
        </trans-unit>
        <trans-unit id="8f8beef2187bafe894f67b36f4b351c6bf0083c2" translate="yes" xml:space="preserve">
          <source>The result of an IN or NOT IN operator is determined by the following matrix:</source>
          <target state="translated">INまたはNOT IN演算子の結果は、以下の行列で決定されます。</target>
        </trans-unit>
        <trans-unit id="61365ffa3c163a280c658c5edf1eb2a5c12ca346" translate="yes" xml:space="preserve">
          <source>The result of any binary operator is either a numeric value or NULL, except for the</source>
          <target state="translated">を除いて、任意のバイナリ演算子の結果は数値か NULL のいずれかです。</target>
        </trans-unit>
        <trans-unit id="efe84f22635d66f10495dd8d63c09814ab5f5a9a" translate="yes" xml:space="preserve">
          <source>The result of combining all input changesets together is obtained by the application via a call to sqlite3changegroup_output().</source>
          <target state="translated">すべての入力チェンジセットを結合した結果は、アプリケーションがsqlite3changegroup_output()を呼び出すことで得られます。</target>
        </trans-unit>
        <trans-unit id="bf374835b6b23f4254068862fbe80fd36859e25a" translate="yes" xml:space="preserve">
          <source>The result of opening a file is an instance of an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object. The &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object is an abstract base class defined as follows:</source>
          <target state="translated">ファイルを開いた結果は、&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;オブジェクトのインスタンスです。&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_fileを&lt;/a&gt;次のようにオブジェクトが定義された抽象基底クラスです。</target>
        </trans-unit>
        <trans-unit id="8384d1099fcb8eaa40cfc52c9ccfbf281fc795df" translate="yes" xml:space="preserve">
          <source>The result of the compound select is sent to the callback routine by the loop at instructions 22 through 25. There is nothing new or remarkable about this loop, except for the fact that the Column instruction at 23 will be extracting a column out of the record key rather than the record data.</source>
          <target state="translated">複合セレクトの結果は、命令22から25のループによってコールバック・ルーチンに送られます。このループについては、23番のColumn命令がレコードデータではなくレコードキーからカラムを抽出するという事実を除けば、何も目新しいことも注目すべきこともありません。</target>
        </trans-unit>
        <trans-unit id="a2285b0635d880f7a2485fe902caef319bce2b4f" translate="yes" xml:space="preserve">
          <source>The result of this last example should be every unique value of the &quot;two&quot; column in the examp table, except any value that is in the &quot;four&quot; column of examp2 is removed. The code to implement this query is as follows:</source>
          <target state="translated">この最後の例の結果は、examp2の &quot;4 &quot;列にある値を除いて、exampテーブルの &quot;2 &quot;列にあるすべての一意の値が削除されているはずです。このクエリを実装するコードは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="ccf7a73ae578c847fadf3966512c178de5c0acda" translate="yes" xml:space="preserve">
          <source>The result of total() is always a floating point value. The result of sum() is an integer value if all non-NULL inputs are integers. If any input to sum() is neither an integer or a NULL then sum() returns a floating point value which might be an approximation to the true sum.</source>
          <target state="translated">total()の結果は常に浮動小数点値です。sum()の結果は、NULL 以外の入力がすべて整数の場合は整数値となります。sum()への入力が整数でも NULL でもない場合は、 sum()は浮動小数点値を返します。</target>
        </trans-unit>
        <trans-unit id="0a6fa042949920d8ab9a65592e82f3922c405d35" translate="yes" xml:space="preserve">
          <source>The resulting &quot;sqlite3.c&quot; amalgamation code file (and its associated header file &quot;sqlite3.h&quot;) can then be moved to a non-unix platform for final compilation using a native compiler.</source>
          <target state="translated">結果として得られた &quot;sqlite3.c &quot;アマルガムコードファイル(とそれに関連するヘッダファイル &quot;sqlite3.h&quot;)は、ネイティブコンパイラを使って最終的にコンパイルするためにunix以外のプラットフォームに移動することができます。</target>
        </trans-unit>
        <trans-unit id="e2d2e1926aa6ddaac2f60d9749f53fb11268ec2a" translate="yes" xml:space="preserve">
          <source>The results of a comparison depend on the storage classes of the operands, according to the following rules:</source>
          <target state="translated">比較の結果は、以下のルールに従って、オペランドのストレージ・クラスに依存します。</target>
        </trans-unit>
        <trans-unit id="32d9d0342a63956078e67d37802198109f0decfd" translate="yes" xml:space="preserve">
          <source>The results presented here come with the following caveats:</source>
          <target state="translated">ここで提示された結果には、以下のような注意点があります。</target>
        </trans-unit>
        <trans-unit id="0aa6d6ab54b80d454b7163f11aaed1a126d7a246" translate="yes" xml:space="preserve">
          <source>The return value from both sqlite3_soft_heap_limit64() and sqlite3_hard_heap_limit64() is the size of the heap limit prior to the call, or negative in the case of an error. If the argument N is negative then no change is made to the heap limit. Hence, the current size of heap limits can be determined by invoking sqlite3_soft_heap_limit64(-1) or sqlite3_hard_heap_limit(-1).</source>
          <target state="translated">sqlite3_soft_heap_limit64()とsqlite3_hard_heap_limit64()の両方からの戻り値は、呼び出し前のヒープ制限のサイズか、エラーの場合は負の値です。引数Nが負の場合、ヒープ制限は変更されません。したがって、現在のヒープ制限のサイズはsqlite3_soft_heap_limit64(-1)またはsqlite3_hard_heap_limit(-1)を呼び出すことで知ることができます。</target>
        </trans-unit>
        <trans-unit id="a9310ef8309cce9fab8d7528f6f21efe5cbb34c7" translate="yes" xml:space="preserve">
          <source>The return value from sqlite3_soft_heap_limit64() is the size of the soft heap limit prior to the call, or negative in the case of an error. If the argument N is negative then no change is made to the soft heap limit. Hence, the current size of the soft heap limit can be determined by invoking sqlite3_soft_heap_limit64() with a negative argument.</source>
          <target state="translated">sqlite3_soft_heap_limit64()の戻り値は、コール前のソフトヒープ制限のサイズ、エラーの場合は負の値です。引数Nが負の場合、ソフトヒープ制限は変更されません。したがって、現在のソフトヒープ制限のサイズは負の引数でsqlite3_soft_heap_limit64()を呼び出すことで決定することができます。</target>
        </trans-unit>
        <trans-unit id="b9ca53c6554299d5eae8ef584802645a6046ae33" translate="yes" xml:space="preserve">
          <source>The return value indicates the final state of the indirect flag: 0 if it is clear, or 1 if it is set.</source>
          <target state="translated">戻り値は、間接フラグの最終的な状態を示します。</target>
        </trans-unit>
        <trans-unit id="7ce2179f1a4d84a59cb420b693cc86ea07338afc" translate="yes" xml:space="preserve">
          <source>The return value indicates the final state of the session object: 0 if the session is disabled, or 1 if it is enabled.</source>
          <target state="translated">戻り値は、セッションオブジェクトの最終的な状態を示します。</target>
        </trans-unit>
        <trans-unit id="cae4bd57ed056db33a88f07df4b39cc7f3ccb51d" translate="yes" xml:space="preserve">
          <source>The return value of the &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; interface is determined by the compile-time threading mode selection. If single-thread mode is selected at compile-time, then &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returns false. If either the multi-thread or serialized modes are selected, then &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returns true. The &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; interface predates the multi-thread mode and start-time and run-time mode selection and so is unable to distinguish between multi-thread and serialized mode nor is it able to report start-time or run-time mode changes.</source>
          <target state="translated">&lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe（）&lt;/a&gt;インターフェースの戻り値は、コンパイル時のスレッド化モードの選択によって決まります。コンパイル時にシングルスレッドモードが選択されている場合、&lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe（）&lt;/a&gt;はfalseを返します。マルチスレッドモードまたはシリアル化モードのいずれかが選択されている場合、&lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe（）&lt;/a&gt;はtrueを返します。&lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe（）&lt;/a&gt;インターフェースは、起動時または実行時モードの変更を報告することができるマルチスレッドモードに先行し、開始時間および実行時モードの選択をので、マルチスレッドおよびシリアライズモードも区別することができません。</target>
        </trans-unit>
        <trans-unit id="39d80cd93bcac1fdb374e9a2b5c0dd95b400a1d6" translate="yes" xml:space="preserve">
          <source>The return value of the &lt;b&gt;sqlite_open&lt;/b&gt; function is a pointer to an opaque &lt;b&gt;sqlite&lt;/b&gt; structure. This pointer will be the first argument to all subsequent SQLite function calls that deal with the same database. NULL is returned if the open fails for any reason.</source>
          <target state="translated">&lt;b&gt;sqlite_open&lt;/b&gt;関数の戻り値は、不透明な&lt;b&gt;sqlite&lt;/b&gt;構造体へのポインターです。このポインタは、同じデータベースを処理する後続のすべてのSQLite関数呼び出しの最初の引数になります。何らかの理由でオープンが失敗した場合は、NULLが返されます。</target>
        </trans-unit>
        <trans-unit id="6ab6c5924ac478fb10f4cbca37723d1a21ffdbb3" translate="yes" xml:space="preserve">
          <source>The returned string pointer is valid until either the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed by &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the next call to sqlite3_column_name() or sqlite3_column_name16() on the same column.</source>
          <target state="translated">返された文字列ポインタは、&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備されたステートメント&lt;/a&gt;が&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;によって破棄されるまで、または特定の実行のための&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;への最初の呼び出しによってステートメントが自動的に再準備されるまで、または次のsqlite3_column_name（）またはsqlite3_column_name16（）の呼び出しまで有効です同じ列。</target>
        </trans-unit>
        <trans-unit id="b378f46326a64f9ce7b892670372ed936b24e5cc" translate="yes" xml:space="preserve">
          <source>The returned string pointer is valid until either the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed by &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the next call to sqlite3_column_name() or sqlite3_column_name16() on the same column.</source>
          <target state="translated">返された文字列ポインタは、&lt;a href=&quot;stmt&quot;&gt;準備されたステートメント&lt;/a&gt;が&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;によって破棄されるまで、または特定の実行のための&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;への最初の呼び出しによってステートメントが自動的に再準備されるまで、または次のsqlite3_column_name（）またはsqlite3_column_name16（）の呼び出しまで有効です同じ列。</target>
        </trans-unit>
        <trans-unit id="bee83cce7953088554432a61ef6e85ee98f1b384" translate="yes" xml:space="preserve">
          <source>The rewritten expression above is conceptual; WHERE clauses containing OR are not really rewritten this way. The actual implementation of the OR clause uses a mechanism that is more efficient and that works even for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables or tables in which the &quot;rowid&quot; is inaccessible. But the essence of the implementation is captured by the statement above: Separate indices are used to find candidate result rows from each OR clause term and the final result is the union of those rows.</source>
          <target state="translated">上記の書き換えられた式は概念的なものです。ORを含むWHERE句は、実際にはこのように書き換えられません。OR句の実際の実装では、より効率的で、&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルまたは「ROWID」にアクセスできないテーブルでも機能するメカニズムを使用します。ただし、実装の本質は上記のステートメントによって捕捉されます。各OR句の用語から候補の結果行を見つけるために個別のインデックスが使用され、最終結果はそれらの行の結合です。</target>
        </trans-unit>
        <trans-unit id="1bd2a272126ae7fe0bcc8e6d37c8017e55bcc2f1" translate="yes" xml:space="preserve">
          <source>The rewritten term then might go on to constrain an index using the normal rules for *IN* operators. Note that</source>
          <target state="translated">その後、書き換えられた項は、*IN*演算子のための通常の規則を使用してインデックスを制約するために進むかもしれません。以下のことに注意してください。</target>
        </trans-unit>
        <trans-unit id="d0930df338a07de9990756603662657ba4f08d89" translate="yes" xml:space="preserve">
          <source>The right-hand operand of an IN or NOT IN operator has no affinity if the operand is a list and has the same affinity as the affinity of the result set expression if the operand is a SELECT.</source>
          <target state="translated">INまたはNOT IN演算子の右辺のオペランドは、オペランドがリストの場合は親和性がなく、オペランドがSELECTの場合は結果集合式の親和性と同じ親和性を持っています。</target>
        </trans-unit>
        <trans-unit id="066626c86d12ae463e5bc63db194f29a635a8420" translate="yes" xml:space="preserve">
          <source>The right-hand side of the IN operator can now be a list of expressions instead of just a list of constants</source>
          <target state="translated">IN 演算子の右辺が、単なる定数のリストではなく式のリストになるようになりました。</target>
        </trans-unit>
        <trans-unit id="5c40f29b907e12e70ce95f7046453c736453580d" translate="yes" xml:space="preserve">
          <source>The right-hand side of the LIKE or GLOB must be either a string literal or a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; bound to a string literal that does not begin with a wildcard character.</source>
          <target state="translated">LIKEまたはGLOBの右側は、文字列リテラルか、ワイルドカード文字で始まらない文字列リテラルにバインドされた&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメーターで&lt;/a&gt;なければなりません。</target>
        </trans-unit>
        <trans-unit id="b4246dd614eb68d70df4434b2497d819d23353bb" translate="yes" xml:space="preserve">
          <source>The right-hand table of the LEFT JOIN is not be used anywhere in the query outside of its own USING or ON clause.</source>
          <target state="translated">LEFT JOINの右辺のテーブルは、それ自身のUSING句またはON句以外では、クエリのどこにも使用されません。</target>
        </trans-unit>
        <trans-unit id="fc3dd2572b5bfa090299b30f5d81e58803cff0cb" translate="yes" xml:space="preserve">
          <source>The right-hand-side of the MATCH or = operator must be a constant expression that evaluates to a string consisting of the auxiliary function to invoke, followed by zero or more comma separated arguments within parenthesis. Arguments must be SQL literals. For example:</source>
          <target state="translated">MATCH または=演算子の右側には、呼び出す補助関数からなる文字列を評価する定数式と、括弧内のゼロ個以上のカンマ区切りの引数を指定する必要があります。引数はSQLリテラルでなければなりません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="60bf6a0aa9c141c91d3c15f81e63af1fbe6058ec" translate="yes" xml:space="preserve">
          <source>The right-most SELECT of the compound select must not make use of &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate&lt;/a&gt; or &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt;.</source>
          <target state="translated">複合選択の右端のSELECTでは、&lt;a href=&quot;lang_aggfunc&quot;&gt;集計&lt;/a&gt;&lt;a href=&quot;windowfunctions&quot;&gt;関数&lt;/a&gt;やウィンドウ関数を使用しないでください。</target>
        </trans-unit>
        <trans-unit id="7b1ae3c5986255800fb2859410b2b4acb04d2122" translate="yes" xml:space="preserve">
          <source>The rollback journal contains a small header (shown in green in the diagram) that records the original size of the database file. So if a change causes the database file to grow, we will still know the original size of the database. The page number is stored together with each database page that is written into the rollback journal.</source>
          <target state="translated">ロールバックジャーナルには、データベースファイルの元のサイズを記録する小さなヘッダ(図では緑で示しています)が含まれています。そのため、変更によってデータベースファイルが大きくなっても、データベースの元のサイズを知ることができます。ページ番号は、ロールバックジャーナルに書き込まれた各データベースページと一緒に保存されます。</target>
        </trans-unit>
        <trans-unit id="1c053ab6c700ac534ac79f62078cfd2e255f73f2" translate="yes" xml:space="preserve">
          <source>The rollback journal does not contain the name of a master journal file (see &lt;a href=&quot;#section_5_5&quot;&gt;section 5.5&lt;/a&gt; below) or if does contain the name of a master journal, then that master journal file exists.</source>
          <target state="translated">ロールバックジャーナルにマスタージャーナルファイルの名前が含まれていない（&lt;a href=&quot;#section_5_5&quot;&gt;セクション5.5を&lt;/a&gt;参照）か、マスタージャーナルの名前が含まれている場合は、そのマスタージャーナルファイルが存在します。</target>
        </trans-unit>
        <trans-unit id="070c8fccacf99462797ddd5845e4bd8960ffcf17" translate="yes" xml:space="preserve">
          <source>The rollback journal does not contain the name of a super-journal file (see &lt;a href=&quot;#section_5_5&quot;&gt;section 5.5&lt;/a&gt; below) or if does contain the name of a super-journal, then that super-journal file exists.</source>
          <target state="translated">ロールバックジャーナルにスーパージャーナルファイルの名前が含まれていないか（以下の&lt;a href=&quot;#section_5_5&quot;&gt;セクション5.5を&lt;/a&gt;参照）、スーパージャーナルの名前が含まれている場合は、そのスーパージャーナルファイルが存在します。</target>
        </trans-unit>
        <trans-unit id="6e312e9592f38c1d0abcf1823ca656ae6dc24729" translate="yes" xml:space="preserve">
          <source>The rollback journal exists.</source>
          <target state="translated">ロールバックジャーナルが存在します。</target>
        </trans-unit>
        <trans-unit id="a6a9ff12c8273f443fb56b2bd7d0ab6853333cef" translate="yes" xml:space="preserve">
          <source>The rollback journal file can be deleted,</source>
          <target state="translated">ロールバックジャーナルファイルを削除することができます。</target>
        </trans-unit>
        <trans-unit id="841baedc01f54f9ab6f694a5b23bcc695e5f21f1" translate="yes" xml:space="preserve">
          <source>The rollback journal file can be truncated to zero length, or</source>
          <target state="translated">ロールバック・ジャーナル・ファイルの長さをゼロに切り詰めることができます。</target>
        </trans-unit>
        <trans-unit id="31415ebe9f384149b021a50dd2fb2ee645763262" translate="yes" xml:space="preserve">
          <source>The rollback journal is</source>
          <target state="translated">ロールバックジャーナルは</target>
        </trans-unit>
        <trans-unit id="08afad671df0d2c575466e5f9fe1a518b69a6c6b" translate="yes" xml:space="preserve">
          <source>The rollback journal is a file associated with each SQLite database file that holds information used to restore the database file to its initial state during the course of a transaction. The rollback journal file is always located in the same directory as the database file and has the same name as the database file but with the string &quot;&lt;code&gt;-journal&lt;/code&gt;&quot; appended. There can only be a single rollback journal associated with a give database and hence there can only be one write transaction open against a single database at one time.</source>
          <target state="translated">ロールバックジャーナルは、トランザクションの過程でデータベースファイルを初期状態に復元するために使用される情報を保持する、各SQLiteデータベースファイルに関連付けられたファイルです。ロールバックジャーナルファイルは常にデータベースファイルと同じディレクトリにあり、データベースファイルと同じ名前ですが、文字列 &quot; &lt;code&gt;-journal&lt;/code&gt; &quot;が追加されています。特定のデータベースに関連付けられているロールバックジャーナルは1つだけなので、一度に1つのデータベースに対して1つの書き込みトランザクションしか開くことができません。</target>
        </trans-unit>
        <trans-unit id="8a29cd2d15ece2c4c624bfe95a88741dea324ccf" translate="yes" xml:space="preserve">
          <source>The rollback journal is complete and intact on disk when the power is restored. This is a key point. The reason for the flush operation in &lt;a href=&quot;#section_3_7&quot;&gt;step 3.7&lt;/a&gt; is to make absolutely sure that all of the rollback journal is safely on nonvolatile storage prior to making any changes to the database file itself.</source>
          <target state="translated">電源が回復したとき、ロールバックジャーナルは完全であり、ディスク上にそのまま残ります。これがポイントです。&lt;a href=&quot;#section_3_7&quot;&gt;ステップ3.7で&lt;/a&gt;フラッシュ操作を行う理由は、データベースファイル自体に変更を加える前に、すべてのロールバックジャーナルが不揮発性ストレージに安全にあることを確実に確認するためです。</target>
        </trans-unit>
        <trans-unit id="5d1b7832cc643f77f52a69083206bb3b5fc3e74c" translate="yes" xml:space="preserve">
          <source>The rollback journal is not an empty file.</source>
          <target state="translated">ロールバックジャーナルは空のファイルではありません。</target>
        </trans-unit>
        <trans-unit id="194c559058723739212e12d7c3749019f8df5f55" translate="yes" xml:space="preserve">
          <source>The root page numbers of all tables in the database are integers stored in P4_INTARRAY argument.</source>
          <target state="translated">データベース内のすべてのテーブルのルートページ番号は、引数P4_INTARRAYに格納されている整数です。</target>
        </trans-unit>
        <trans-unit id="a973ad8403210b9b222fd26c2aef5b8f2808389c" translate="yes" xml:space="preserve">
          <source>The round(X,Y) function returns a floating-point value X rounded to Y digits to the right of the decimal point. If the Y argument is omitted, it is assumed to be 0.</source>
          <target state="translated">round(X,Y)関数は、浮動小数点の値Xを小数点以下のY桁に丸めて返します。Y引数を省略した場合は0とします。</target>
        </trans-unit>
        <trans-unit id="5fa12ab6f93c055083bc1a95b917e71f9cff725b" translate="yes" xml:space="preserve">
          <source>The routines &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;, &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, and &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; accept an SQL statement list (sql-stmt-list) which is a semicolon-separated list of statements.</source>
          <target state="translated">ルーチン&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16（）&lt;/a&gt;、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;、&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;、&lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table（）&lt;/a&gt;は、セミコロンで区切られたSQLステートメントリスト（sql-stmt-list）を受け入れます。</target>
        </trans-unit>
        <trans-unit id="94230b7f00353328063595629d48ef7be9fce389" translate="yes" xml:space="preserve">
          <source>The row-value notation is useful for updating two or more columns of a table from the result of a single query. An example of this is in the full-text search feature of the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil version control system&lt;/a&gt;.</source>
          <target state="translated">行と値の表記は、単一のクエリの結果からテーブルの2つ以上の列を更新するのに役立ちます。この例は、&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossilバージョン管理システムの&lt;/a&gt;全文検索機能です。</target>
        </trans-unit>
        <trans-unit id="12b6af8126e4e3b962d71bf35b72e9a66ab6fcba" translate="yes" xml:space="preserve">
          <source>The row_number() of the first peer in each group - the rank of the current row with gaps. If there is no ORDER BY clause, then all rows are considered peers and this function always returns 1.</source>
          <target state="translated">各グループの最初のピアの row_number()-ギャップのある現在の行のランク。ORDER BY 節がない場合は、すべての行がピアとみなされ、この関数は常に 1 を返します。</target>
        </trans-unit>
        <trans-unit id="d3978e13ae998834400769bcf87213e9a57acdbe" translate="yes" xml:space="preserve">
          <source>The row_number() window function assigns consecutive integers to each row in order of the &quot;ORDER BY&quot; clause within the window-defn (in this case &quot;ORDER BY y&quot;). Note that this does not affect the order in which results are returned from the overall query. The order of the final output is still governed by the ORDER BY clause attached to the SELECT statement (in this case &quot;ORDER BY x&quot;).</source>
          <target state="translated">row_number()ウィンドウ関数は、ウィンドウ-defn 内の &quot;ORDER BY&quot; 節 (この場合は &quot;ORDER BY y&quot; です)の順に各行に連続した整数を割り当てます。これは、クエリ全体から返される結果の順番には影響しないことに注意してください。最終的な出力の順序は、SELECT文に付随するORDER BY句(この場合は &quot;ORDER BY x&quot;)によって支配されます。</target>
        </trans-unit>
        <trans-unit id="97fcd9de22c4efb0eb648cf609eba1ee3fdf411d" translate="yes" xml:space="preserve">
          <source>The rowid (and &quot;oid&quot; and &quot;_rowid_&quot;) is omitted in &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. WITHOUT ROWID tables are only available in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06) and later. A table that lacks the WITHOUT ROWID clause is called a &quot;rowid table&quot;.</source>
          <target state="translated">ROWID（および「oid」と「_rowid_」）は、&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルでは省略されます。WITHOUT ROWIDテーブルは、SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;バージョン3.8.2&lt;/a&gt;（2013-12-06）以降でのみ使用できます。WITHOUT ROWID句がないテーブルは、「ROWIDテーブル」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="a4a453c67097537d0d10c4b81190fd5d03a4b9dd" translate="yes" xml:space="preserve">
          <source>The rowid column is not accessible on a WITHOUT ROWID virtual table (of course).</source>
          <target state="translated">rowid列は、without rowid仮想テーブルではアクセスできません(当然ですが)。</target>
        </trans-unit>
        <trans-unit id="101d05f0746854eb07065f446e80313cdc7692a7" translate="yes" xml:space="preserve">
          <source>The rowid of the document that contains the term instance.</source>
          <target state="translated">用語のインスタンスを含むドキュメントの rowid。</target>
        </trans-unit>
        <trans-unit id="21037157130833680d029f7ec56534a7a85bda67" translate="yes" xml:space="preserve">
          <source>The rowid of the row in the table being changed</source>
          <target state="translated">変更されるテーブルの行の rowid</target>
        </trans-unit>
        <trans-unit id="4967842a66478a8da76fb91a725d0ca4385c40a8" translate="yes" xml:space="preserve">
          <source>The rtreecheck() function performs the following checks:</source>
          <target state="translated">rtreecheck()関数は、以下のチェックを行います。</target>
        </trans-unit>
        <trans-unit id="93e10cfe1c883491ee9016750849300312683ba1" translate="yes" xml:space="preserve">
          <source>The rtrim(X,Y) function returns a string formed by removing any and all characters that appear in Y from the right side of X. If the Y argument is omitted, rtrim(X) removes spaces from the right side of X.</source>
          <target state="translated">rtrim(X,Y)関数は、Xの右辺からYに出現するすべての文字を削除した文字列を返します。 Yの引数が省略された場合、rtrim(X)はXの右辺からスペースを削除します。</target>
        </trans-unit>
        <trans-unit id="46ff031bad92aa35bcef2484317fc2661aa2d589" translate="yes" xml:space="preserve">
          <source>The rule above says that the letter &quot;a&quot; in user input can be matched against the letter &quot;&amp;auml;&quot; in the dictionary with a penalty of 5.</source>
          <target state="translated">上記のルールは、ユーザー入力の文字「a」はディクショナリの文字「&amp;auml;」とペナルティ5で一致する可能性があることを示しています。</target>
        </trans-unit>
        <trans-unit id="ed3a2c883d263a1e9abd7d6661fda464d09422b3" translate="yes" xml:space="preserve">
          <source>The rules for determining which collating function to use for a binary comparison operator (=, &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=, !=, IS, and IS NOT) are as follows:</source>
          <target state="translated">バイナリ比較演算子（=、&amp;lt;、&amp;gt;、&amp;lt;=、&amp;gt; =、！=、IS、およびIS NOT）に使用する照合関数を決定するための規則は、次のとおりです。</target>
        </trans-unit>
        <trans-unit id="27705c6545cd7b92f01b98bd6ebfb1aa891406e9" translate="yes" xml:space="preserve">
          <source>The rules for when tables are analyzed are likely to change in future releases.</source>
          <target state="translated">テーブルが分析された場合のルールは、今後のリリースで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="819c15849a2758e415f2520702095eeff7ea13a5" translate="yes" xml:space="preserve">
          <source>The safest and easiest to remember policy is this: assume that any result from</source>
          <target state="translated">最も安全で覚えやすいポリシーはこれです。</target>
        </trans-unit>
        <trans-unit id="9bfc94ce3f6dbf06df6c899612d318253dda6014" translate="yes" xml:space="preserve">
          <source>The safest policy is to invoke these routines in one of the following ways:</source>
          <target state="translated">最も安全なポリシーは、以下のいずれかの方法でこれらのルーチンを呼び出すことです。</target>
        </trans-unit>
        <trans-unit id="376b573ee029dd7d9463b27b130e605260069a93" translate="yes" xml:space="preserve">
          <source>The salt-1 and salt-2 values in the frame-header match salt values in the wal-header</source>
          <target state="translated">フレームヘッダの salt-1 と salt-2 の値は、ウォールヘッダの salt の値と一致します。</target>
        </trans-unit>
        <trans-unit id="b0647dc001e4e971c816ce4a73a18b5c698aa62d" translate="yes" xml:space="preserve">
          <source>The same SQL statement will fail on every other SQL implementation that we know of due to the use of keywords &quot;union&quot;, &quot;true&quot;, and &quot;with&quot; as identifiers.</source>
          <target state="translated">同じSQL文は、&quot;union&quot;、&quot;true&quot;、&quot;with &quot;というキーワードを識別子として使用しているため、私たちが知っている他のすべてのSQL実装で失敗します。</target>
        </trans-unit>
        <trans-unit id="67d39480596a16c7c11f0309e84be58f71d89746" translate="yes" xml:space="preserve">
          <source>The same basic B-Tree format is used but the details of the index keys were changed in order to provide better query optimization opportunities. Some of the headers were also changed in order to increase the maximum size of a row from 64KB to 24MB.</source>
          <target state="translated">基本的なB-Treeフォーマットは同じですが、クエリの最適化の機会を提供するためにインデックスキーの詳細が変更されました。また、1行の最大サイズを64KBから24MBに増やすために、ヘッダの一部も変更されました。</target>
        </trans-unit>
        <trans-unit id="8827fbb3b64d8c27595464e7777bbb4e772df118" translate="yes" xml:space="preserve">
          <source>The same basic algorithm is followed, except this time the matching rows of the index are scanned from bottom to top instead of from top to bottom, so that the states will appear in descending order.</source>
          <target state="translated">基本的なアルゴリズムは同じですが、今回はインデックスの一致する行が上から下ではなく下から上にスキャンされるので、状態が降順に表示されます。</target>
        </trans-unit>
        <trans-unit id="8ef4bb6f50ee96f372f99fa9088d7b9c16950c07" translate="yes" xml:space="preserve">
          <source>The same core string formatter is also used internally by SQLite.</source>
          <target state="translated">同じコア文字列フォーマッタが SQLite の内部でも使用されています。</target>
        </trans-unit>
        <trans-unit id="c76359de67616f16a26e96d68504c135072ade53" translate="yes" xml:space="preserve">
          <source>The same database connection may now be used simultaneously by separate threads.</source>
          <target state="translated">同じデータベース接続を別々のスレッドで同時に使用することができるようになりました。</target>
        </trans-unit>
        <trans-unit id="3bfa6cdc7cb80687d83044e6ab3337ab8d5595b5" translate="yes" xml:space="preserve">
          <source>The same indices are used to speed up every loop in both implementation options. The only difference in these two query plans is the order in which the loops are nested.</source>
          <target state="translated">両方の実装オプションでは、すべてのループを高速化するために同じインデックスが使用されます。これら2つのクエリプランの唯一の違いは、ループが入れ子になっている順序です。</target>
        </trans-unit>
        <trans-unit id="d1cd4608c87b02b3bc5ed6c81e7bb9ae9c4b8e13" translate="yes" xml:space="preserve">
          <source>The same technique ensures that an SQLite database file cannot be corrupted by a system failure that occurs at an inopportune moment. If a system failure does occur before SQLite has had a chance to execute sufficient</source>
          <target state="translated">同じ手法により、SQLite データベースファイルが不都合なタイミングで発生したシステム障害によって破損することはありません。SQLite が十分に</target>
        </trans-unit>
        <trans-unit id="40cbe38c06ce85b1c49ad0c8414f8f89ac5525ac" translate="yes" xml:space="preserve">
          <source>The same thing can be done with an enterprise client/server database, of course. The advantage of SQLite is that it is easier to install and use and the resulting database is a single file that can be written to a USB memory stick or emailed to a colleague.</source>
          <target state="translated">もちろん、エンタープライズ・クライアント/サーバー・データベースでも同じことができます。SQLiteの利点は、インストールと使用が簡単で、結果として得られるデータベースは1つのファイルで、USBメモリに書き込んだり、同僚に電子メールで送ったりすることができます。</target>
        </trans-unit>
        <trans-unit id="d9e7d4c0bf312ba2ed4d788d1d81806125454441" translate="yes" xml:space="preserve">
          <source>The scalar SQL function rtreecheck(R) or rtreecheck(S,R) runs an integrity check on the rtree table named R contained within database S. The function returns a human-language description of any problems found, or the string 'ok' if everything is ok. Running rtreecheck() on an R*Tree virtual table is similar to running &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; on a database.</source>
          <target state="translated">スカラーSQL関数rtreecheck（R）またはrtreecheck（S、R）は、データベースSに含まれているRという名前のrtreeテーブルに対して整合性チェックを実行します。この関数は、見つかった問題の人間言語の説明を返します。全て大丈夫。 R * Tree仮想テーブルでrtreecheck（）を実行する&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;こと&lt;/a&gt;は、データベースでPRAGMA integer_checkを実行することに似ています。</target>
        </trans-unit>
        <trans-unit id="181bcf0e796a132dd22a68144a4e494726dfbf32" translate="yes" xml:space="preserve">
          <source>The scenario above sounds far-fetched. But the SQLite developers are aware of at least one commercial product that was released with exactly this bug. The vendor came to the SQLite developers seeking help in tracking down some infrequent database corruption issues they were seeing on Linux and Mac. The problem was eventually traced to the fact that the application was linking against two separate copies of SQLite. The solution was to change the application build procedures to link against just one copy of SQLite instead of two.</source>
          <target state="translated">上記のシナリオは、あまりにも現実離れしたものに聞こえます。しかし、SQLite の開発者は、少なくとも一つの商用製品がまさにこのバグを持ってリリースされたことを知っています。そのベンダーはSQLiteの開発者に、LinuxやMacで頻繁に見られるデータベース破損の問題を解決するために助けを求めてきました。この問題は最終的に、アプリケーションがSQLiteの2つの別々のコピーに対してリンクしているという事実にたどり着きました。解決策は、アプリケーションのビルドプロシージャを変更して、SQLiteのコピーを2つではなく1つだけにリンクするようにしました。</target>
        </trans-unit>
        <trans-unit id="7cf33abd12fd2e97d31a441b54d245ec800fc490" translate="yes" xml:space="preserve">
          <source>The schema above defines a directed graph with the ability to store a name at each node. Now consider a query against this schema:</source>
          <target state="translated">上のスキーマは、各ノードに名前を格納する機能を持つ有向グラフを定義しています。では、このスキーマに対するクエリを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="d37b6e6570fc572ab09d9f50bc38138c9b41b0ec" translate="yes" xml:space="preserve">
          <source>The schema cookie is a 4-byte big-endian integer at offset 40 that is incremented whenever the database schema changes. A prepared statement is compiled against a specific version of the database schema. When the database schema changes, the statement must be reprepared. When a prepared statement runs, it first checks the schema cookie to ensure the value is the same as when the statement was prepared and if the schema cookie has changed, the statement either automatically reprepares and reruns or it aborts with an &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; error.</source>
          <target state="translated">スキーマCookieはオフセット40の4バイトのビッグエンディアン整数で、データベーススキーマが変更されるたびに増分されます。準備されたステートメントは、データベーススキーマの特定のバージョンに対してコンパイルされます。データベーススキーマが変更されると、ステートメントを再準備する必要があります。準備されたステートメントが実行されると、最初にスキーマCookieをチェックして、値がステートメントが準備されたときと同じであることを確認します。スキーマCookieが変更された場合、ステートメントは自動的に再準備および再実行されるか、&lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt;エラーで中止されます。</target>
        </trans-unit>
        <trans-unit id="1ab0e540f94c93f90585f3869aa649d5881cec37" translate="yes" xml:space="preserve">
          <source>The schema cookie.</source>
          <target state="translated">スキーマクッキー。</target>
        </trans-unit>
        <trans-unit id="4488aa59b7580b3c4da5952eb56f99b2cde228a2" translate="yes" xml:space="preserve">
          <source>The schema depicted above is not designed to store the full-text index directly. Instead, it is used to store one or more b-tree structures. There is one b-tree for each row in the %_segdir table. The %_segdir table row contains the root node and various meta-data associated with the b-tree structure, and the %_segments table contains all other (non-root) b-tree nodes. Each b-tree is referred to as a &quot;segment&quot;. Once it has been created, a segment b-tree is never updated (although it may be deleted altogether).</source>
          <target state="translated">上に描かれているスキーマは、全文インデックスを直接格納するようには設計されていません。代わりに、1 つ以上の b-tree 構造を格納するために使用されます。segdir テーブルの各行には 1 つの b-tree があります。segdir テーブルの行には、ルート・ノードと b-tree 構造に関連付けられたさまざまなメタデータが格納され、%_segments テーブルには、他の (ルートではない)すべての b-tree ノードが格納されます。各 b-tree は &quot;セグメント&quot; と呼ばれます。一度作成されたセグメント b-tree は更新されません (完全に削除されることはありますが)。</target>
        </trans-unit>
        <trans-unit id="2b92ee620ed7f83eb29e5266f914917afed4620a" translate="yes" xml:space="preserve">
          <source>The schema for the DBSTAT virtual table looks like this:</source>
          <target state="translated">DBSTAT仮想テーブルのスキーマは次のようになります。</target>
        </trans-unit>
        <trans-unit id="0fd02dc53052cb07a4282595789654910705302c" translate="yes" xml:space="preserve">
          <source>The schema for the dbstat virtual table is this:</source>
          <target state="translated">dbstat仮想テーブルのスキーマは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="2252a25e95423355b1edc92e550e314acf60ad89" translate="yes" xml:space="preserve">
          <source>The schema for the table returned by json_each() and json_tree() is as follows:</source>
          <target state="translated">json_each()とjson_tree()が返すテーブルのスキーマは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="7f20e4cd592c03cab97adad3d2182916294f862d" translate="yes" xml:space="preserve">
          <source>The schema format number for a new database can be set at runtime using the &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;PRAGMA legacy_file_format&lt;/a&gt; command.</source>
          <target state="translated">新しいデータベースのスキーマ形式番号は、&lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;PRAGMA legacy_file_format&lt;/a&gt;コマンドを使用して実行時に設定できます。</target>
        </trans-unit>
        <trans-unit id="933a80ece41d7c4fe3169e373964e2826ef1d8f7" translate="yes" xml:space="preserve">
          <source>The schema format number is a 4-byte big-endian integer at offset 44. The schema format number is similar to the file format read and write version numbers at offsets 18 and 19 except that the schema format number refers to the high-level SQL formatting rather than the low-level b-tree formatting. Four schema format numbers are currently defined:</source>
          <target state="translated">スキーマフォーマット番号はオフセット44の4バイトのビッグエンディアン整数です。スキーマフォーマット番号は、スキーマフォーマット番号が低レベルのb-treeフォーマットではなく、高レベルのSQLフォーマットを参照することを除いては、オフセット18と19のファイルフォーマットの読み書きバージョン番号と似ています。現在、4つのスキーマフォーマット番号が定義されています。</target>
        </trans-unit>
        <trans-unit id="62a7a887a20a821d1b69e9b449caf90b4200d958" translate="yes" xml:space="preserve">
          <source>The schema format number. Supported schema formats are 1, 2, 3, and 4.</source>
          <target state="translated">スキーマフォーマット番号。サポートされるスキーマフォーマットは 1、2、3、および 4 です。</target>
        </trans-unit>
        <trans-unit id="c07d56a869023707575ade10738a217ecfcee4af" translate="yes" xml:space="preserve">
          <source>The schema of an SQL database is able to represent information more directly and succinctly than a key/value database such as a ZIP archive. This makes the document content more accessible to third-party applications and scripts and facilitates advanced features such as built-in document versioning, and incremental saving of work in progress for recovery after a crash.</source>
          <target state="translated">SQL データベースのスキーマは、ZIP アーカイブのようなキー/値データベースよりも、情報をより直接的かつ簡潔に表現することができます。これにより、サードパーティ製のアプリケーションやスクリプトからドキュメントの内容にアクセスしやすくなり、ビルトインドキュメントのバージョン管理や、クラッシュ後のリカバリのための進行中の作業の増分保存などの高度な機能が容易になります。</target>
        </trans-unit>
        <trans-unit id="70d31e0ed54ade1f01f5803b76d2ee1ab0a7fa16" translate="yes" xml:space="preserve">
          <source>The schema_version pragma will get or set the value of the schema-version integer at offset 40 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;.</source>
          <target state="translated">schema_versionプラグマは、&lt;a href=&quot;fileformat2#database_header&quot;&gt;データベースヘッダーの&lt;/a&gt;オフセット40にあるschema-version整数の値を取得または設定します。</target>
        </trans-unit>
        <trans-unit id="87cc88d5b4a5e95bb023c0790cc28378b9e2bd05" translate="yes" xml:space="preserve">
          <source>The schema_version pragma will to get or set the value of the schema-version integer at offset 40 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;.</source>
          <target state="translated">schema_versionプラグマは、&lt;a href=&quot;fileformat2#database_header&quot;&gt;データベースヘッダーの&lt;/a&gt;オフセット40にあるschema-version整数の値を取得または設定します。</target>
        </trans-unit>
        <trans-unit id="077341a10c528ac1588a1408b9034c9f8021b705" translate="yes" xml:space="preserve">
          <source>The scheme of the URI must be &quot;&lt;code&gt;file:&lt;/code&gt;&quot;. Any other scheme results in the input being treated as an ordinary filename.</source>
          <target state="translated">URIのスキームは &quot; &lt;code&gt;file:&lt;/code&gt; &quot;でなければなりません。他のスキームでは、入力は通常のファイル名として扱われます。</target>
        </trans-unit>
        <trans-unit id="08d91918dffee8fc87a94df6946790f6caab8817" translate="yes" xml:space="preserve">
          <source>The score is a combination of rank and distance. The idea is that a lower score is better. The virtual table attempts to find words with the lowest score and by default (unless overridden by ORDER BY) returns results in order of increasing score.</source>
          <target state="translated">スコアはランクと距離の組み合わせです。スコアが低いほど良いという考え方です。仮想テーブルは、スコアが最も低い単語を見つけようとし、デフォルトでは (ORDER BY で上書きされない限り)スコアの高い順に結果を返します。</target>
        </trans-unit>
        <trans-unit id="61fd3b441b127465c680d5c3514e6d464720698f" translate="yes" xml:space="preserve">
          <source>The script compiles the TH3 test harness into machine code (&quot;th3.o&quot;) if necessary.</source>
          <target state="translated">スクリプトは必要に応じてTH3テストハーネスをマシンコード(&quot;th3.o&quot;)にコンパイルします。</target>
        </trans-unit>
        <trans-unit id="9f405708716b43bff0ad67cd4c7d9fb92e6afc28" translate="yes" xml:space="preserve">
          <source>The script compiles the sqlite3.c source file into assembly language (&quot;sqlite3.s&quot;) if necessary.</source>
          <target state="translated">スクリプトは必要に応じてsqlite3.cのソースファイルをアセンブリ言語(&quot;sqlite3.s&quot;)にコンパイルします。</target>
        </trans-unit>
        <trans-unit id="9bf1fc92f793f60b433b7ebac87847be7a48eb60" translate="yes" xml:space="preserve">
          <source>The script loops through instructions in the assembly language file to locate branch operations.</source>
          <target state="translated">スクリプトは、アセンブリ言語ファイル内の命令をループして分岐操作を見つけます。</target>
        </trans-unit>
        <trans-unit id="576c62795ba33247bec0c331da3dd87f14e7a748" translate="yes" xml:space="preserve">
          <source>The script makes a copy of the original sqlite3.s file.</source>
          <target state="translated">スクリプトは元のsqlite3.sファイルのコピーを作成します。</target>
        </trans-unit>
        <trans-unit id="fbefc60f4848710280b3f195980be93ae6fb0731" translate="yes" xml:space="preserve">
          <source>The script shows progress for each cycle of the previous step then displays a summary of &quot;survivors&quot; at the end. A &quot;survivor&quot; is a mutation that was not detected by TH3.</source>
          <target state="translated">スクリプトは前のステップの各サイクルの進行状況を表示し、最後に「生存者」のサマリーを表示します。サバイバー」とは、TH3で検出されなかった突然変異のことです。</target>
        </trans-unit>
        <trans-unit id="4a731425cd1bb86844c78ad068a724419eca7459" translate="yes" xml:space="preserve">
          <source>The search for these strings in the type declaration is case insensitive, of course. If any of the above strings occur anywhere in the type declaration, then the datatype of the column is text. Notice that the type &quot;VARCHAR&quot; contains &quot;CHAR&quot; as a substring so it is considered text.</source>
          <target state="translated">型宣言におけるこれらの文字列の検索は、もちろん大文字小文字を区別しません。もし上記の文字列が型宣言のどこかにあった場合、そのカラムのデータ型はtextとなります。VARCHAR &quot;型には部分文字列として &quot;CHAR &quot;が含まれているので、テキストとみなされることに注意してください。</target>
        </trans-unit>
        <trans-unit id="201735a6137bd8c721345300624cc86e3645ba64" translate="yes" xml:space="preserve">
          <source>The second &lt;a href=&quot;opcode#Transaction&quot;&gt;Transaction&lt;/a&gt; instruction begins a transaction and starts a rollback journal for database 1, the database used for temporary tables.</source>
          <target state="translated">2番目の&lt;a href=&quot;opcode#Transaction&quot;&gt;Transaction&lt;/a&gt;命令はトランザクションを開始し、一時テーブルに使用されるデータベース1のロールバックジャーナルを開始します。</target>
        </trans-unit>
        <trans-unit id="541464126fdf47682a89498dd2c1f59037e5c50b" translate="yes" xml:space="preserve">
          <source>The second SELECT is implemented by instructions 14 through 19. Instruction 14 initializes the loop by rewinding its cursor. A new result row is created from the &quot;four&quot; column of table &quot;examp2&quot; by instructions 15 and 16. But instead of using PutStrKey to write this new row into the temporary table, we instead call Delete to remove it from the temporary table if it exists.</source>
          <target state="translated">第2のSELECTは、命令14〜19によって実装される。命令14は、カーソルを巻き戻すことによりループを初期化する。命令15と16によって、テーブル &quot;examp2 &quot;の &quot;4 &quot;列から新しい結果行が作成される。しかし、この新しい行を一時テーブルに書き込むためにPutStrKeyを使用する代わりに、一時テーブルが存在する場合にはDeleteを呼び出して一時テーブルから削除します。</target>
        </trans-unit>
        <trans-unit id="b382925f3a88c50c566963d5ae8b2f2a69bce488" translate="yes" xml:space="preserve">
          <source>The second advantage the SQLite printf routines have over &lt;b&gt;sprintf&lt;/b&gt; are two new formatting options specifically designed to support string literals in SQL. Within the format string, the %q formatting option works very much like %s in that it reads a null-terminated string from the argument list and inserts it into the result. But %q translates the inserted string by making two copies of every single-quote (') character in the substituted string. This has the effect of escaping the end-of-string meaning of single-quote within a string literal. The %Q formatting option works similar; it translates the single-quotes like %q and additionally encloses the resulting string in single-quotes. If the argument for the %Q formatting options is a NULL pointer, the resulting string is NULL without single quotes.</source>
          <target state="translated">SQLiteのprintfルーチンが&lt;b&gt;sprintfより&lt;/b&gt;も優れている2番目の利点は、SQLで文字列リテラルをサポートするように特別に設計された2つの新しいフォーマットオプションです。フォーマット文字列内で、％qフォーマットオプションは、引数リストからnullで終了する文字列を読み取り、結果に挿入するという点で、％sと非常によく似ています。ただし、％qは、置換された文字列内のすべての単一引用符（ '）文字の2つのコピーを作成することにより、挿入された文字列を変換します。これは、文字列リテラル内の単一引用符の文字列の終わりの意味をエスケープする効果があります。 ％Qフォーマットオプションは同様に機能します。 ％qのように単一引用符を変換し、さらに結果の文字列を単一引用符で囲みます。 ％Q書式設定オプションの引数がNULLポインターの場合、結果の文字列は単一引用符なしのNULLです。</target>
        </trans-unit>
        <trans-unit id="24bd2add8c4054117cbe09f659537f282404edb5" translate="yes" xml:space="preserve">
          <source>The second and all subsequent 32768-byte units of the shm file are like this:</source>
          <target state="translated">shmファイルの2つ目以降の32768バイト単位はこのようになります。</target>
        </trans-unit>
        <trans-unit id="2f88dda8423c5371c7ad74eb85809481a6d1addf" translate="yes" xml:space="preserve">
          <source>The second and third forms return the computed edit distance between strings 'string1' and &quot;string2'. In the second form, a language id of 0 is used. The language id is specified in the third form.</source>
          <target state="translated">2番目と3番目の形式は、文字列'string1'と'string2'の間の計算された編集距離を返します。2番目の形式では、0の言語IDが使用される。第3の形式では言語IDが指定される。</target>
        </trans-unit>
        <trans-unit id="bab5b375ff048a5d63f1a3b4cc3d343effcaa9c1" translate="yes" xml:space="preserve">
          <source>The second argument (xFilter) is the &quot;filter callback&quot;. For changes to rows in tables that are not attached to the Session object, the filter is called to determine whether changes to the table's rows should be tracked or not. If xFilter returns 0, changes are not tracked. Note that once a table is attached, xFilter will not be called again.</source>
          <target state="translated">2 番目の引数 (xFilter)は、&quot;フィルタのコールバック&quot; です。Session オブジェクトにアタッチされていないテーブルの行への変更に対して、テーブルの行への変更を追跡すべきかどうかを決定するためにフィルタが呼び出されます。xFilter が 0 を返した場合、変更は追跡されません。一度テーブルがアタッチされると、xFilter は二度と呼ばれないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="a3a47f0193da66fdda72484a51d350d2076b5681" translate="yes" xml:space="preserve">
          <source>The second argument (xFilter) is the &quot;filter callback&quot;. For changes to rows in tables that are not attached to the Session object, the filter is called to determine whether changes to the table's rows should be tracked or not. If xFilter returns 0, changes is not tracked. Note that once a table is attached, xFilter will not be called again.</source>
          <target state="translated">2 番目の引数 (xFilter)は、&quot;フィルタのコールバック&quot; です。Session オブジェクトにアタッチされていないテーブルの行への変更に対して、テーブルの行への変更を追跡すべきかどうかを決定するためにフィルタが呼び出されます。xFilter が 0 を返した場合、変更は追跡されません。一度テーブルがアタッチされると、xFilter は二度と呼ばれないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="718f90fed591046439ad14f60ea06810377e7e83" translate="yes" xml:space="preserve">
          <source>The second argument indicates the reason that FTS5 is requesting tokenization of the supplied text. This is always one of the following four values:</source>
          <target state="translated">第2引数は、FTS5が供給されたテキストのトークン化を要求している理由を示す。これは常に以下の4つの値のうちの1つです。</target>
        </trans-unit>
        <trans-unit id="1b37e9b1846948d626696aade4d54493fddd03d8" translate="yes" xml:space="preserve">
          <source>The second argument is a pointer to the function to invoke when a row is updated, inserted or deleted in a rowid table. The first argument to the callback is a copy of the third argument to sqlite3_update_hook(). The second callback argument is one of &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the operation that caused the callback to be invoked. The third and fourth arguments to the callback contain pointers to the database and table name containing the affected row. The final callback parameter is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the row. In the case of an update, this is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; after the update takes place.</source>
          <target state="translated">2番目の引数は、ROWIDテーブルで行が更新、挿入、または削除されたときに呼び出す関数へのポインターです。コールバックの最初の引数は、sqlite3_update_hook（）の3番目の引数のコピーです。 2番目のコールバック引数は、コールバックが呼び出される原因となった操作に応じて、&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt;、&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt;、または&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATEの&lt;/a&gt;いずれかです。コールバックの3番目と4番目の引数には、影響を受ける行を含むデータベースとテーブル名へのポインターが含まれます。最後のコールバックパラメータは、行の&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;です。更新の場合、これは更新が行われた後の&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="f6eef977cb1db09c38e32ceda39f74ec952be8d2" translate="yes" xml:space="preserve">
          <source>The second argument is a pointer to the function to invoke when a row is updated, inserted or deleted in a rowid table. The first argument to the callback is a copy of the third argument to sqlite3_update_hook(). The second callback argument is one of &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the operation that caused the callback to be invoked. The third and fourth arguments to the callback contain pointers to the database and table name containing the affected row. The final callback parameter is the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the row. In the case of an update, this is the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; after the update takes place.</source>
          <target state="translated">2番目の引数は、ROWIDテーブルで行が更新、挿入、または削除されたときに呼び出す関数へのポインターです。コールバックの最初の引数は、sqlite3_update_hook（）の3番目の引数のコピーです。 2番目のコールバック引数は、コールバックが呼び出される原因となった操作に応じて、&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;、&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;、または&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATEの&lt;/a&gt;いずれかです。コールバックの3番目と4番目の引数には、影響を受ける行を含むデータベースとテーブル名へのポインターが含まれます。最後のコールバックパラメータは、行の&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;です。更新の場合、これは更新が行われた後の&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="724bd11ad92d936922e1ead7d8425d39851a3038" translate="yes" xml:space="preserve">
          <source>The second argument is the index of the SQL parameter to be set. The leftmost SQL parameter has an index of 1. When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence. The index for named parameters can be looked up using the &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; API if desired. The index for &quot;?NNN&quot; parameters is the value of NNN. The NNN value must be between 1 and the &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit()&lt;/a&gt; parameter &lt;a href=&quot;#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (default value: 32766).</source>
          <target state="translated">2番目の引数は、設定するSQLパラメーターのインデックスです。左端のSQLパラメーターのインデックスは1です。同じ名前のSQLパラメーターが複数回使用されると、2番目以降のオカレンスのインデックスは最初のオカレンスと同じになります。名前付きパラメーターのインデックスは、必要に応じて&lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index（）&lt;/a&gt; APIを使用して検索できます。 「？NNN」パラメータのインデックスはNNNの値です。 NNN値は、1から&lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;パラメーター&lt;a href=&quot;#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt;（デフォルト値：32766）の間でなければなりません。</target>
        </trans-unit>
        <trans-unit id="d4e308f3aa98b17590b5e994747b662ab58b2433" translate="yes" xml:space="preserve">
          <source>The second argument is the index of the SQL parameter to be set. The leftmost SQL parameter has an index of 1. When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence. The index for named parameters can be looked up using the &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; API if desired. The index for &quot;?NNN&quot; parameters is the value of NNN. The NNN value must be between 1 and the &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit()&lt;/a&gt; parameter &lt;a href=&quot;#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (default value: 999).</source>
          <target state="translated">2番目の引数は、設定するSQLパラメータのインデックスです。左端のSQLパラメーターのインデックスは1です。同じ名前のSQLパラメーターが2回以上使用される場合、2番目以降のオカレンスには最初のオカレンスと同じインデックスが付けられます。名前付きパラメーターのインデックスは、必要に応じて&lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index（）&lt;/a&gt; API を使用して検索できます。 「？NNN」パラメーターのインデックスは、NNNの値です。 NNN値は、1と&lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;パラメータ&lt;a href=&quot;#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBERの&lt;/a&gt;間でなければなりません（デフォルト値：999）。</target>
        </trans-unit>
        <trans-unit id="ff965dc4a3884d50d8419508e30018f226ac3b0d" translate="yes" xml:space="preserve">
          <source>The second argument is the index of the SQL parameter to be set. The leftmost SQL parameter has an index of 1. When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence. The index for named parameters can be looked up using the &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; API if desired. The index for &quot;?NNN&quot; parameters is the value of NNN. The NNN value must be between 1 and the &lt;a href=&quot;limit&quot;&gt;sqlite3_limit()&lt;/a&gt; parameter &lt;a href=&quot;c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (default value: 32766).</source>
          <target state="translated">2番目の引数は、設定するSQLパラメーターのインデックスです。左端のSQLパラメーターのインデックスは1です。同じ名前のSQLパラメーターが複数回使用されると、2番目以降のオカレンスのインデックスは最初のオカレンスと同じになります。名前付きパラメーターのインデックスは、必要に応じて&lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index（）&lt;/a&gt; APIを使用して検索できます。 「？NNN」パラメータのインデックスはNNNの値です。 NNN値は、1から&lt;a href=&quot;limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;パラメーター&lt;a href=&quot;c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt;（デフォルト値：32766）の間でなければなりません。</target>
        </trans-unit>
        <trans-unit id="a3f014790ea15d84ae5efd1a40e8d6440e64de4e" translate="yes" xml:space="preserve">
          <source>The second argument is the index of the SQL parameter to be set. The leftmost SQL parameter has an index of 1. When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence. The index for named parameters can be looked up using the &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; API if desired. The index for &quot;?NNN&quot; parameters is the value of NNN. The NNN value must be between 1 and the &lt;a href=&quot;limit&quot;&gt;sqlite3_limit()&lt;/a&gt; parameter &lt;a href=&quot;c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (default value: 999).</source>
          <target state="translated">2番目の引数は、設定するSQLパラメータのインデックスです。左端のSQLパラメーターのインデックスは1です。同じ名前のSQLパラメーターが2回以上使用される場合、2番目以降のオカレンスには最初のオカレンスと同じインデックスが付けられます。名前付きパラメーターのインデックスは、必要に応じて&lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index（）&lt;/a&gt; API を使用して検索できます。 「？NNN」パラメーターのインデックスは、NNNの値です。 NNN値は、1と&lt;a href=&quot;limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;パラメータ&lt;a href=&quot;c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBERの&lt;/a&gt;間でなければなりません（デフォルト値：999）。</target>
        </trans-unit>
        <trans-unit id="2fb1bff691f79072fe4cf1aa2d31d1bd3832725a" translate="yes" xml:space="preserve">
          <source>The second argument passed to the xToken() callback (&quot;tflags&quot;) should normally be set to 0. The exception is if the tokenizer supports synonyms. In this case see the discussion below for details.</source>
          <target state="translated">xToken()コールバックに渡される第二引数 (&quot;tflags&quot;)には通常 0 を設定しなければなりません。 トークン化ツールが同義語をサポートしている場合は例外となります。この場合の詳細は以下の説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="ca943db57529952ad5f76d4c9a47b52221a6d6e3" translate="yes" xml:space="preserve">
          <source>The second argument to sqlite3_db_config(D,V,...) is the &lt;a href=&quot;#sqlitedbconfiglookaside&quot;&gt;configuration verb&lt;/a&gt; - an integer code that indicates what aspect of the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is being configured. Subsequent arguments vary depending on the configuration verb.</source>
          <target state="translated">sqlite3_db_config（D、V、...）の2番目の引数は、&lt;a href=&quot;#sqlitedbconfiglookaside&quot;&gt;構成動詞です&lt;/a&gt; - &lt;a href=&quot;#sqlite3&quot;&gt;データベース接続の&lt;/a&gt;どの側面が構成されているかを示す整数コードです。後続の引数は、構成動詞によって異なります。</target>
        </trans-unit>
        <trans-unit id="a7845e3bb7f88361055af36d05adde4b952592f9" translate="yes" xml:space="preserve">
          <source>The second argument to sqlite3_db_config(D,V,...) is the &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;configuration verb&lt;/a&gt; - an integer code that indicates what aspect of the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is being configured. Subsequent arguments vary depending on the configuration verb.</source>
          <target state="translated">sqlite3_db_config（D、V、...）の2番目の引数は、&lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;構成動詞です&lt;/a&gt; - &lt;a href=&quot;sqlite3&quot;&gt;データベース接続の&lt;/a&gt;どの側面が構成されているかを示す整数コードです。後続の引数は、構成動詞によって異なります。</target>
        </trans-unit>
        <trans-unit id="7ca88f23336b34513d2d790b7c87ef9c5d8d0e67" translate="yes" xml:space="preserve">
          <source>The second argument to the error logger callback is an integer &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt;. The third argument to the error logger is the text of the error message. The error message text is stored in a fixed-length stack buffer in the calling function and so will only be valid for the duration of the error logger callback function. The error logger should make a copy of this message into persistent storage if retention of the message is needed.</source>
          <target state="translated">エラーロガーコールバックの2番目の引数は、整数の&lt;a href=&quot;rescode#extrc&quot;&gt;拡張エラーコード&lt;/a&gt;です。エラーロガーの3番目の引数は、エラーメッセージのテキストです。エラーメッセージテキストは、呼び出し元の関数の固定長スタックバッファーに格納されるため、エラーロガーコールバック関数の実行中のみ有効です。メッセージの保持が必要な場合、エラーロガーはこのメッセージのコピーを永続ストレージに作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="a2a47b21d6064e4d10a2f6d6161c0f1dce1664a1" translate="yes" xml:space="preserve">
          <source>The second argument, &quot;zSql&quot;, is the statement to be compiled, encoded as either UTF-8 or UTF-16. The sqlite3_prepare(), sqlite3_prepare_v2(), and sqlite3_prepare_v3() interfaces use UTF-8, and sqlite3_prepare16(), sqlite3_prepare16_v2(), and sqlite3_prepare16_v3() use UTF-16.</source>
          <target state="translated">2番目の引数である &quot;zSql &quot;は、コンパイルされる文で、UTF-8またはUTF-16でエンコードされています。sqlite3_prepare()、sqlite3_prepare_v2()、およびsqlite3_prepare_v3()インタフェースはUTF-8を使用し、sqlite3_prepare16()、sqlite3_prepare16_v2()、およびsqlite3_prepare16_v3()インタフェースはUTF-16を使用します。</target>
        </trans-unit>
        <trans-unit id="f2e250c2ef383dec7dc31067a07b23d0da95c91b" translate="yes" xml:space="preserve">
          <source>The second beta release for SQLite 3.0.</source>
          <target state="translated">SQLite 3.0の第2回目のベータリリース。</target>
        </trans-unit>
        <trans-unit id="771287a1de97a728b2134cd9c420c1c39a0f52c6" translate="yes" xml:space="preserve">
          <source>The second column is the name of the table.</source>
          <target state="translated">2列目はテーブルの名前です。</target>
        </trans-unit>
        <trans-unit id="68511a08109abd7af5a81fce815eeb4f023584c9" translate="yes" xml:space="preserve">
          <source>The second form changes the journaling mode for &quot;</source>
          <target state="translated">第2のフォームでは、&quot;の仕訳モードを変更します。</target>
        </trans-unit>
        <trans-unit id="2f272c30ebac8ce92b2f903964b40a07bad463d7" translate="yes" xml:space="preserve">
          <source>The second form of the INSERT statement contains a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement instead of a VALUES clause. A new entry is inserted into the table for each row of data returned by executing the SELECT statement. If a column-list is specified, the number of columns in the result of the SELECT must be the same as the number of items in the column-list. Otherwise, if no column-list is specified, the number of columns in the result of the SELECT must be the same as the number of columns in the table. Any SELECT statement, including &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECTs&lt;/a&gt; and SELECT statements with &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; and/or &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; clauses, may be used in an INSERT statement of this form.</source>
          <target state="translated">INSERTステートメントの2番目の形式には、VALUES句の代わりに&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントが含まれています。 SELECTステートメントを実行して返されたデータの各行について、新しいエントリがテーブルに挿入されます。 column-listが指定されている場合、SELECTの結果の列の数は、column-listの項目の数と同じでなければなりません。それ以外の場合、column-listが指定されていなければ、SELECTの結果の列の数は、テーブルの列の数と同じでなければなりません。この形式のINSERTステートメントでは、&lt;a href=&quot;lang_select#compound&quot;&gt;複合SELECT&lt;/a&gt;および&lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt;句や&lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt;句（あるいはその両方）を含むSELECTステートメントを含む、すべてのSELECTステートメントを使用できます。</target>
        </trans-unit>
        <trans-unit id="ec9aa9593798c759bbdf9a6cf2b73541eab87efe" translate="yes" xml:space="preserve">
          <source>The second form of the command is this:</source>
          <target state="translated">コマンドの第二形態はこれです。</target>
        </trans-unit>
        <trans-unit id="fa9b557c755fe5c619c7e5fc0af0adff81ce48ad" translate="yes" xml:space="preserve">
          <source>The second form of the pragma listed above is used to set a new limit in bytes for the specified database. A negative number implies no limit. To always truncate rollback journals and WAL files to their minimum size, set the journal_size_limit to zero. Both the first and second forms of the pragma listed above return a single result row containing a single integer column - the value of the journal size limit in bytes. The default journal size limit is -1 (no limit). The &lt;a href=&quot;compile#default_journal_size_limit&quot;&gt;SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT&lt;/a&gt; preprocessor macro can be used to change the default journal size limit at compile-time.</source>
          <target state="translated">上記のプラグマの2番目の形式は、指定されたデータベースの新しい制限をバイト単位で設定するために使用されます。負の数は制限がないことを意味します。ロールバックジャーナルとWALファイルを常に最小サイズに切り捨てるには、journal_size_limitをゼロに設定します。上記のプラグマの最初の形式と2番目の形式の両方で、単一の整数列（バイト単位のジャーナルサイズ制限の値）を含む単一の結果行が返されます。デフォルトのジャーナルサイズ制限は-1（制限なし）です。&lt;a href=&quot;compile#default_journal_size_limit&quot;&gt;SQLITE_DEFAULT_JOURNAL_SIZE_LIMITの&lt;/a&gt;プリプロセッサマクロはコンパイル時にデフォルトのジャーナルのサイズ制限を変更するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="4008980ca9a9274111928748bc06de4b907efa68" translate="yes" xml:space="preserve">
          <source>The second integer, if it is present, is the aggregate size of all data stored on leaf pages in bytes. If the value is negative, then the segment is the output of an unfinished incremental-merge operation, and the absolute value is current size in bytes.</source>
          <target state="translated">2 番目の整数が存在する場合は、リーフページに格納されているすべてのデータの総和サイズをバイト単位で表します。値が負の場合、そのセグメントは未完了のインクリメンタルマージ操作の出力であり、絶対値は現在のサイズをバイト単位で表します。</target>
        </trans-unit>
        <trans-unit id="211c21970b7cdeb91101e574bc29708c2cdfae64" translate="yes" xml:space="preserve">
          <source>The second line above creates a virtual table named &quot;t1&quot; that reads the content of the file named in the argument. The number and names of the columns is determined automatically by reading the first line of content. Other options to the CSV virtual table provide the ability to take the CSV content from a string rather than a separate file, and give the programmer more control over the number and names of the columns. The options are detailed below. The CSV virtual table is usually created as a TEMP table so that it exists only for the current database connection and does not become a permanent part of the database schema. Note that there is no &quot;CREATE TEMP VIRTUAL TABLE&quot; command in SQLite. Instead, prepend the &quot;temp.&quot; schema prefix to the name of the virtual table.</source>
          <target state="translated">上の2行目では、引数で指定したファイルの内容を読み込む「t1」という名前の仮想テーブルを作成しています。列の数と名前は、1行目の内容を読み込むことで自動的に決定されます。CSV仮想テーブルの他のオプションでは、CSVの内容を別のファイルではなく文字列から読み込むことができ、列の数と名前をより制御できるようになります。オプションの詳細は以下の通りです。CSV仮想テーブルは通常TEMPテーブルとして作成され、現在のデータベース接続のためだけに存在し、データベーススキーマの恒久的な部分にはなりません。SQLiteには「CREATE TEMP VIRTUAL TABLE」コマンドはないことに注意してください。代わりに、仮想テーブルの名前の前に &quot;temp.&quot; スキーマ接頭辞を付加します。</target>
        </trans-unit>
        <trans-unit id="c3933495d9788c26f88ba69fbabb317f1e83064e" translate="yes" xml:space="preserve">
          <source>The second line of the file contains 211792 characters of impenetrable XML. Yes, 211792 characters all on one line. This file is a good stress-test for a text editor. Thankfully, the file is not some obscure binary format, but in terms of accessibility, it might as well be written in Klingon.</source>
          <target state="translated">ファイルの2行目には211792文字の不可解なXMLが含まれています。そう、1行に211792文字が全部入っているのです。このファイルはテキストエディタのストレステストに最適です。ありがたいことに、このファイルは曖昧なバイナリ形式ではありませんが、アクセシビリティの観点からは、クリンゴン語で書かれているのと同じかもしれません。</target>
        </trans-unit>
        <trans-unit id="5c1d27adf7a874de9fb599be39fb1d27d63c3092" translate="yes" xml:space="preserve">
          <source>The second number Y is incremented for any change that breaks forward compatibility by adding new features. Most future SQLite releases are expected to increment the second number Y. The Z is reset to zero whenever Y is increased.</source>
          <target state="translated">2 番目の数字 Y は、新しい機能を追加することで前方互換性を壊すような変更があった場合にインクリメントされます。ほとんどの将来の SQLite リリースでは、2 番目の数字 Y がインクリメントされることが予想されます。</target>
        </trans-unit>
        <trans-unit id="50b9dd44fd65466aa651f4fce7056da00ed7e13a" translate="yes" xml:space="preserve">
          <source>The second parameter (argc) and the fourth parameter (columnNames) are still valid and can be used to determine the number and names of the result columns if there had been a result. The default behavior is not to invoke the callback at all if the result set is empty.</source>
          <target state="translated">2 番目のパラメータ (argc)と 4 番目のパラメータ (columnNames)はまだ有効で、結果があった場合に結果のカラムの数と名前を決定するために使用できます。デフォルトでは、結果セットが空の場合はコールバックを呼び出さないようになっています。</target>
        </trans-unit>
        <trans-unit id="682054ab4ce2cb4dfe2528dcad7556d5d406ca5f" translate="yes" xml:space="preserve">
          <source>The second parameter is the name of the SQL function to be created or redefined. The length of the name is limited to 255 bytes in a UTF-8 representation, exclusive of the zero-terminator. Note that the name length limit is in UTF-8 bytes, not characters nor UTF-16 bytes. Any attempt to create a function with a longer name will result in &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt; being returned.</source>
          <target state="translated">2番目のパラメーターは、作成または再定義するSQL関数の名前です。名前の長さは、ゼロ終端文字を除いて、UTF-8表現で255バイトに制限されています。名前の長さの制限はUTF-8バイトであり、文字やUTF-16バイトではないことに注意してください。これより長い名前の関数を作成しようとすると、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="266b83f6439ab5e88dcd3928741ef542cdbb6626" translate="yes" xml:space="preserve">
          <source>The second parameter is the name of the SQL function to be created or redefined. The length of the name is limited to 255 bytes in a UTF-8 representation, exclusive of the zero-terminator. Note that the name length limit is in UTF-8 bytes, not characters nor UTF-16 bytes. Any attempt to create a function with a longer name will result in &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; being returned.</source>
          <target state="translated">2番目のパラメーターは、作成または再定義するSQL関数の名前です。名前の長さは、ゼロ終端文字を除いて、UTF-8表現で255バイトに制限されています。名前の長さの制限はUTF-8バイトであり、文字やUTF-16バイトではないことに注意してください。これより長い名前の関数を作成しようとすると、&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="560b989b803d6b51bde79f3db2c1500c44cc5751" translate="yes" xml:space="preserve">
          <source>The second parameter to the preupdate callback is a pointer to the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that registered the preupdate hook. The third parameter to the preupdate callback is one of the constants &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATE&lt;/a&gt; to identify the kind of update operation that is about to occur. The fourth parameter to the preupdate callback is the name of the database within the database connection that is being modified. This will be &quot;main&quot; for the main database or &quot;temp&quot; for TEMP tables or the name given after the AS keyword in the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for attached databases. The fifth parameter to the preupdate callback is the name of the table that is being modified.</source>
          <target state="translated">preupdateコールバックの2番目のパラメーターは、preupdateフックを登録した&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;へのポインターです。 preupdateコールバックの3番目のパラメーターは、発生する更新操作の種類を識別するための定数&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt;、&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt;、または&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATEの&lt;/a&gt;いずれかです。 preupdateコールバックの4番目のパラメーターは、変更中のデータベース接続内のデータベースの名前です。これは、メインデータベースの場合は「main」、TEMPテーブルの場合は「temp」、または接続されたデータベースの&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;ステートメントのASキーワードの後に​​指定された名前になります。 preupdateコールバックの5番目のパラメーターは、変更されるテーブルの名前です。</target>
        </trans-unit>
        <trans-unit id="097d5db1a651bbf810ec3be53362ed0414cfc3f9" translate="yes" xml:space="preserve">
          <source>The second parameter to the preupdate callback is a pointer to the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that registered the preupdate hook. The third parameter to the preupdate callback is one of the constants &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; to identify the kind of update operation that is about to occur. The fourth parameter to the preupdate callback is the name of the database within the database connection that is being modified. This will be &quot;main&quot; for the main database or &quot;temp&quot; for TEMP tables or the name given after the AS keyword in the &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for attached databases. The fifth parameter to the preupdate callback is the name of the table that is being modified.</source>
          <target state="translated">preupdateコールバックの2番目のパラメーターは、preupdateフックを登録した&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;へのポインターです。 preupdateコールバックの3番目のパラメーターは、発生する更新操作の種類を識別するための定数&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;、&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;、または&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATEの&lt;/a&gt;いずれかです。 preupdateコールバックの4番目のパラメーターは、変更中のデータベース接続内のデータベースの名前です。これは、メインデータベースの場合は「main」、TEMPテーブルの場合は「temp」、または接続されたデータベースの&lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt;ステートメントのASキーワードの後に​​指定された名前になります。 preupdateコールバックの5番目のパラメーターは、変更されるテーブルの名前です。</target>
        </trans-unit>
        <trans-unit id="f5ad56c8e6b709d2294efc15c0b9ac27fea8d776" translate="yes" xml:space="preserve">
          <source>The second step finds the four shortest paths to visit two nodes beginning with one of the four paths from the previous step. In the case where two or more paths are equivalent (they have the same set of visited nodes, though possibly in a different order) only the first and lowest-cost path is retained. We have:</source>
          <target state="translated">第2ステップでは,前のステップで得られた4つのパスのうちの1つから始まる2つのノードを訪問するための4つの最短パスを見つけます.2つ以上のパスが同等の場合(訪問するノードのセットが同じであるが,順序は異なる可能性がある),最初のパスと最もコストの低いパスのみが保持されます.以下のようになります。</target>
        </trans-unit>
        <trans-unit id="73fbb8fcf9b3b6fa8277785714e82cfa142507c2" translate="yes" xml:space="preserve">
          <source>The second through fifth forms of this pragma set the encoding that the main database will be created with if it is created by this session. The string 'UTF-16' is interpreted as &quot;UTF-16 encoding using native machine byte-ordering&quot;. It is not possible to change the text encoding of a database after it has been created and any attempt to do so will be silently ignored.</source>
          <target state="translated">このプラグマの2番目から5番目の形式は、このセッションによってメインデータベースが作成された場合に、メインデータベースが作成されるエンコーディングを設定します。文字列 'UTF-16' は「ネイティブマシンのバイトオーダーを使用した UTF-16 エンコーディング」と解釈されます。データベースが作成された後で、データベースのテキストエンコーディングを変更することはできません。</target>
        </trans-unit>
        <trans-unit id="5882943850506b5e4c2358f26a0aca06e4d009ac" translate="yes" xml:space="preserve">
          <source>The secure_delete setting causes deleted content to be overwritten with zeros. There is a small performance penalty since additional I/O must occur. On the other hand, secure_delete can prevent fragments of sensitive information from lingering in unused parts of the database file after it has been deleted. See the documentation on the &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;secure_delete pragma&lt;/a&gt; for additional information.</source>
          <target state="translated">secure_delete設定により、削除されたコンテンツはゼロで上書きされます。追加のI / Oが発生する必要があるため、パフォーマンスが多少低下します。一方、secure_deleteを使用すると、削除されたデータベースファイルの未使用部分に機密情報の断片が残るのを防ぐことができます。詳細については、&lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;secure_deleteプラグマの&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="5b04afcfc3f7fd09080833015b31410c518c0339" translate="yes" xml:space="preserve">
          <source>The separate &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; description provides details on the structure of a database file and of the write-head log file used in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. But details of the locking protocol and of the format of the WAL-index are deliberately omitted since those details are left to discretion of individual &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations. This document fills in those missing details for the unix and windows &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;.</source>
          <target state="translated">個別の&lt;a href=&quot;fileformat2&quot;&gt;ファイル形式の&lt;/a&gt;説明では、データベースファイルと、&lt;a href=&quot;wal&quot;&gt;WALモードで&lt;/a&gt;使用される書き込みヘッドログファイルの構造について詳しく説明しています。ただし、ロックプロトコルとWALインデックスの形式の詳細は、個々の&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;実装の裁量に委ねられているため、意図的に省略されています。このドキュメントでは、UNIXとWindowsの&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;に関する欠落している詳細について説明します。</target>
        </trans-unit>
        <trans-unit id="92103d1dd017d8e08e89604f71cfaaa913bec164" translate="yes" xml:space="preserve">
          <source>The session extension facilitates this by recording all changes to both Alice's and Bob's databases and writing those changes into changeset or patchset files. At the end of the day, Alice can send her changeset to Bob and Bob can &quot;apply&quot; it to his database. The result (assuming there are no conflicts) is that Bob's database then contains both his changes and Alice's changes. Likewise, Bob can send a changeset of his work over to Alice and she can apply his changes to her database.</source>
          <target state="translated">セッション拡張機能は、アリスとボブの両方のデータベースへのすべての変更を記録し、それらの変更をチェンジセットファイルやパッチセットファイルに書き出すことで、これを容易にします。一日の終わりに、Aliceは自分のチェンジセットをBobに送り、Bobはそれを自分のデータベースに「適用」することができます。その結果(競合がないと仮定して)、Bobのデータベースには彼の変更とAliceの変更の両方が含まれることになります。同様に、ボブは自分の仕事のチェンジセットをアリスに送ることができ、アリスは彼の変更を自分のデータベースに適用することができます。</target>
        </trans-unit>
        <trans-unit id="1c8659fbbef014d7697d1ea170e739bed552acd5" translate="yes" xml:space="preserve">
          <source>The session extension only works with tables that have a declared PRIMARY KEY. The PRIMARY KEY of a table may be an INTEGER PRIMARY KEY (rowid alias) or an external PRIMARY KEY.</source>
          <target state="translated">セッション拡張機能は、宣言されたPRIMARY KEYを持つテーブルでのみ動作します。テーブルの PRIMARY KEY は INTEGER PRIMARY KEY (rowid のエイリアス)あるいは外部 PRIMARY KEY となります。</target>
        </trans-unit>
        <trans-unit id="8619b8eb0bb510e39b3c8622337b2bb7b6549aba" translate="yes" xml:space="preserve">
          <source>The session extension provide a mechanism for recording changes to some or all of the &lt;a href=&quot;rowidtable&quot;&gt;rowid tables&lt;/a&gt; in an SQLite database, and packaging those changes into a &quot;changeset&quot; or &quot;patchset&quot; file that can later be used to apply the same set of changes to another database with the same schema and compatible starting data. A &quot;changeset&quot; may also be inverted and used to &quot;undo&quot; a session.</source>
          <target state="translated">セッション拡張機能は、SQLiteデータベース内の一部またはすべての&lt;a href=&quot;rowidtable&quot;&gt;ROWIDテーブル&lt;/a&gt;への変更を記録し、それらの変更を「変更セット」または「パッチセット」ファイルにパッケージ化して、後で同じ変更セットを別のセットに適用するために使用できるメカニズムを提供します同じスキーマと互換性のある開始データを持つデータベース。「チェンジセット」を逆にして、セッションを「元に戻す」ために使用することもできます。</target>
        </trans-unit>
        <trans-unit id="0b97f5ba300285bc33992abb7779519b897b7aa7" translate="yes" xml:space="preserve">
          <source>The session object &quot;indirect&quot; flag is set when the change is made, or</source>
          <target state="translated">セッションオブジェクトの「間接」フラグは、変更が行われたときに設定されるか</target>
        </trans-unit>
        <trans-unit id="ffcb76dee8dc3b4cb20fe29908bbbe2ff2230909" translate="yes" xml:space="preserve">
          <source>The session object is configured with a set of tables to monitor changes on.</source>
          <target state="translated">セッションオブジェクトは、変更を監視するテーブルのセットで構成されています。</target>
        </trans-unit>
        <trans-unit id="0c67ff7ccfd533851dea34da8187939bbeae8841" translate="yes" xml:space="preserve">
          <source>The session object is deleted using a call to the &lt;a href=&quot;session/sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt; API function.</source>
          <target state="translated">セッションオブジェクトは、&lt;a href=&quot;session/sqlite3session_delete&quot;&gt;sqlite3session_delete（）&lt;/a&gt; API関数の呼び出しを使用して削除されます。</target>
        </trans-unit>
        <trans-unit id="b41c2d1dd25f0b9daf0304c7870c3eb7ae78b919" translate="yes" xml:space="preserve">
          <source>The session object therefore accumulates two types of records - those that consist of primary key values only (created when the user inserts a new record) and those that consist of the primary key values and the original values of other table columns (created when the users deletes or updates a record).</source>
          <target state="translated">したがって、セッション・オブジェクトは、主キー値のみで構成されるレコード(ユーザーが新しいレコードを挿入したときに作成される)と、主キー値と他のテーブル・カラムの元の値で構成されるレコード(ユーザーがレコードを削除または更新したときに作成される)の2つのタイプのレコードを蓄積します。</target>
        </trans-unit>
        <trans-unit id="67b4d05a6aa852ba851b95d39158470c33cead0c" translate="yes" xml:space="preserve">
          <source>The session object will be used to create changesets for tables in database zDb, where zDb is either &quot;main&quot;, or &quot;temp&quot;, or the name of an attached database. It is not an error if database zDb is not attached to the database when the session object is created.</source>
          <target state="translated">セッションオブジェクトは、データベースzDbのテーブルの変更セットを作成するために使用され、ここでzDbは &quot;main&quot;、&quot;temp&quot;、またはアタッチされたデータベースの名前です。セッションオブジェクトが作成されたときに、データベースzDbがデータベースにアタッチされていなくてもエラーにはなりません。</target>
        </trans-unit>
        <trans-unit id="45a8679117c7936fefc29c4e8b252b099d09917b" translate="yes" xml:space="preserve">
          <source>The sessions module never invokes an xOutput callback with the third parameter set to a value less than or equal to zero. Other than this, no guarantees are made as to the size of the chunks of data returned.</source>
          <target state="translated">sessionsモジュールは、3番目のパラメータにゼロ以下の値を設定してxOutputコールバックを呼び出すことはありません。これ以外にも、返されるデータのチャンクのサイズは保証されていません。</target>
        </trans-unit>
        <trans-unit id="a218d47a709906affb4f3ae717da9de3077b519d" translate="yes" xml:space="preserve">
          <source>The sessions module revolves around creating and manipulating changesets. A changeset is a blob of data that encodes a series of changes to a database. Each change in a changeset is one of the following:</source>
          <target state="translated">セッションモジュールは、チェンジセットの作成と操作を中心に展開します。チェンジセットは、データベースへの一連の変更をコード化したデータの塊です。チェンジセットの各変更は、以下のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="d639d6bbcd88a2f2cd5339240f5d5c5de8f80432" translate="yes" xml:space="preserve">
          <source>The set X contains the index in aPgno of every entry in the current 32768-byte unit of the shm file that might possible be a solution to the FindFrame(P,M) function. Each of these entries must be checked separately to ensure that the aPgno value is P and that the frame number does not exceed M. The largest frame number that passes those two tests is the answer.</source>
          <target state="translated">セットXには、shmファイルの現在の32768バイト単位の各エントリのaPgnoのインデックスが含まれており、FindFrame(P,M)関数の解答となる可能性があります。これらの各エントリは、aPgnoの値がPであり、フレーム番号がMを超えないことを確認するために、個別にチェックされなければなりません。</target>
        </trans-unit>
        <trans-unit id="daeab809359987c0f17f57c78f38704f62041f7b" translate="yes" xml:space="preserve">
          <source>The set of</source>
          <target state="translated">のセットです。</target>
        </trans-unit>
        <trans-unit id="df619f50e7143055665ccf4d69e938c1340f4737" translate="yes" xml:space="preserve">
          <source>The set of built-in auxiliary functions provided by FTS5 may be improved upon in the future.</source>
          <target state="translated">FTS5が提供する内蔵補助機能のセットは、将来的に改良される可能性があります。</target>
        </trans-unit>
        <trans-unit id="a49341beec33b485301f8bafe6ae6c61c6f39915" translate="yes" xml:space="preserve">
          <source>The set of checklist items for release checklist is potentially updated for each release. The content and complete history of each release checklist are retained for the historical record.</source>
          <target state="translated">リリースチェックリストのチェックリスト項目のセットは、リリースごとに潜在的に更新されます。各リリースチェックリストの内容と完全な履歴は、履歴記録のために保持されます。</target>
        </trans-unit>
        <trans-unit id="0f5a66644e1d1f4b0f41c960d4f2f7a794b20868" translate="yes" xml:space="preserve">
          <source>The set of static mutexes may change from one SQLite release to the next. Applications that override the built-in mutex logic must be prepared to accommodate additional static mutexes.</source>
          <target state="translated">静的ミューテックスのセットは、SQLite のリリースごとに変更される可能性があります。組み込みのミューテックスロジックをオーバーライドするアプリケーションは、追加の静的ミューテックスに対応できるように準備しておく必要があります。</target>
        </trans-unit>
        <trans-unit id="9b60f1982b5c4164ca917a617479f0aacfe46294" translate="yes" xml:space="preserve">
          <source>The shadow tables are ordinary SQLite data tables. You can query them directly if you like, though this unlikely to reveal anything particularly useful. And you can &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; or even &lt;a href=&quot;lang_droptable&quot;&gt;DROP&lt;/a&gt; the shadow tables, though doing so will corrupt your R*Tree index. So it is best to simply ignore the shadow tables. Recognize that they hold your R*Tree index information and let it go as that.</source>
          <target state="translated">シャドウテーブルは、通常のSQLiteデータテーブルです。必要に応じて直接クエリすることもできますが、これが特に有用なものを明らかにすることはほとんどありません。また、シャドウテーブルを&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;、&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;、&lt;a href=&quot;lang_insert&quot;&gt;INSERT、&lt;/a&gt;または&lt;a href=&quot;lang_droptable&quot;&gt;DROP&lt;/a&gt;することもできますが、そうするとR * Treeインデックスが破損します。したがって、シャドウテーブルは単に無視するのが最善です。それらがR * Treeインデックス情報を保持していることを認識し、それをそのままにします。</target>
        </trans-unit>
        <trans-unit id="7b89e4e1261efca1d668789aecafeceb06cf0045" translate="yes" xml:space="preserve">
          <source>The shared library filename passed to &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; may omit the filename suffix, and an appropriate architecture-dependent suffix (&quot;.so&quot;, &quot;.dylib&quot;, or &quot;.dll&quot;) will be added automatically.</source>
          <target state="translated">&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）に&lt;/a&gt;渡される共有ライブラリのファイル名では、ファイル名のサフィックスが省略される場合があり、適切なアーキテクチャ依存のサフィックス（ &quot;.so&quot;、 &quot;。dylib&quot;、または &quot;.dll&quot;）が自動的に追加されます。</target>
        </trans-unit>
        <trans-unit id="683712ddb2de169a205df89a5ffe29d5c006c2b5" translate="yes" xml:space="preserve">
          <source>The shared-memory file contains no persistent content. The only purpose of the shared-memory file is to provide a block of shared memory for use by multiple processes all accessing the same database in WAL mode. If the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; is able to provide an alternative method for accessing shared memory, then that alternative method might be used rather than the shared-memory file. For example, if &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;PRAGMA locking_mode&lt;/a&gt; is set to EXCLUSIVE (meaning that only one process is able to access the database file) then the shared memory will be allocated from heap rather than out of the shared-memory file, and the shared-memory file will never be created.</source>
          <target state="translated">共有メモリファイルには永続的なコンテンツが含まれていません。共有メモリ・ファイルの唯一の目的は、すべてのWALモードで同じデータベースにアクセスする複数のプロセスによる使用のために共有メモリのブロックを提供することです。場合&lt;a href=&quot;vfs&quot;&gt;VFSは、&lt;/a&gt;共有メモリにアクセスするための代替方法を提供することができる、その別の方法ではなく、共有メモリのファイルよりも使用される可能性があります。たとえば、&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;PRAGMA Locking_mode&lt;/a&gt;がEXCLUSIVEに設定されている場合（1つのプロセスのみがデータベースファイルにアクセスできることを意味します）、共有メモリは共有メモリファイルからではなくヒープから割り当てられ、共有メモリファイルは作成されることはありません。</target>
        </trans-unit>
        <trans-unit id="d84d71db4e9c7a1a18a467e4bbe2be0320c053f2" translate="yes" xml:space="preserve">
          <source>The shared-memory file has the same lifetime as its associated WAL file. The shared-memory file is created when the WAL file is created and is deleted when the WAL file is deleted. During WAL file recovery, the shared memory file is recreated from scratch based on the contents of the WAL file being recovered.</source>
          <target state="translated">共有メモリファイルは、関連するWALファイルと同じ有効期間を持ちます。共有メモリファイルは、WALファイルが作成されたときに作成され、WALファイルが削除されたときに削除されます。WALファイルの復元中に、共有メモリファイルは、復元されるWALファイルの内容に基づいてゼロから再作成されます。</target>
        </trans-unit>
        <trans-unit id="c6175d074e784d9fffd662056186d3e1dc1f4cc9" translate="yes" xml:space="preserve">
          <source>The shm does not contain any database content and is not required to recover the database following a crash. For that reason, the first client to connect to a quiescent database will normally truncate the shm file if it exists. Since the content of the shm file does not need to be preserved across a crash, the shm file is never fsync()-ed to disk. In fact, if there were a mechanism by which SQLite could tell the operating system to never persist the shm file to disk but always hold it in cache memory, SQLite would use that mechanism to avoid any unnecessary disk I/O associated with the shm file. However, no such mechanism exists in standard posix.</source>
          <target state="translated">shmにはデータベースの内容は含まれておらず、クラッシュ後にデータベースを復旧するために必要なものではありません。そのため、静止状態のデータベースに最初に接続したクライアントは、通常、shmファイルが存在する場合には、shmファイルを切り捨てます。shmファイルの内容はクラッシュしても保存される必要がないので、shmファイルは決してfsync()してディスクに保存されません。実際、もし SQLite が shm ファイルをディスクに永続化せず、常にキャッシュメモリに保持するように OS に指示できるメカニズムがあれば、SQLite は shm ファイルに関連した不要なディスク I/O を避けるためにそのメカニズムを使用するでしょう。しかし、標準の posix にはそのようなメカニズムは存在しません。</target>
        </trans-unit>
        <trans-unit id="2ce5842569cd9ae6cb873fe122d925e98dfd9e57" translate="yes" xml:space="preserve">
          <source>The shm file consists of one or more hash tables, where each hash table is 32768 bytes in size. Except, a 136-byte header is carved out of the front of the very first hash table, so the first hash table is only 32632 bytes in size. The total size of the shm file is always a multiple of 32768. In most cases, the total size of the shm file is exactly 32768 bytes. The shm file only needs to grow beyond a single hash table if when the wal file grows very large (more than 4079 frames). Since the default &lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;automatic checkpoint threshold&lt;/a&gt; is 1000, WAL files rare reach the 4079 threshold needed to make the shm file grow.</source>
          <target state="translated">shmファイルは1つ以上のハッシュテーブルで構成され、各ハッシュテーブルのサイズは32768バイトです。ただし、136バイトのヘッダーは最初のハッシュテーブルの前面から切り出されるため、最初のハッシュテーブルのサイズは32632バイトにすぎません。 shmファイルの合計サイズは常に32768の倍数です。ほとんどの場合、shmファイルの合計サイズはちょうど32768バイトです。 wmファイルが非常に大きくなる（4079フレームを超える）場合、shmファイルは単一のハッシュテーブルを超えて大きくする必要があります。デフォルトの&lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;自動チェックポイントしきい値&lt;/a&gt;は1000であるため、WALファイルがshmファイルを拡張するために必要な4079しきい値に達することはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="0d8774149ef596e36906cd1fe56afff10a697841" translate="yes" xml:space="preserve">
          <source>The signature of the xAccess method has been modified to return an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; and to store its output into an integer pointed to by a parameter, rather than returning the output directly. This change allows the xAccess() method to report failures. In association with this signature change, a new extended error code &lt;a href=&quot;rescode#ioerr_access&quot;&gt;SQLITE_IOERR_ACCESS&lt;/a&gt; has been added.</source>
          <target state="translated">xAccessメソッドのシグネチャが変更され、&lt;a href=&quot;rescode&quot;&gt;エラーコード&lt;/a&gt;を返し、その出力を、直接出力を返すのではなく、パラメーターが指す整数に格納するようになりました。この変更により、xAccess（）メソッドは失敗を報告できます。このシグネチャの変更に関連して、新しい拡張エラーコード&lt;a href=&quot;rescode#ioerr_access&quot;&gt;SQLITE_IOERR_ACCESS&lt;/a&gt;が追加されました。</target>
        </trans-unit>
        <trans-unit id="73da15d1378e7e4cecf6c05a9921a5f1b3117f3b" translate="yes" xml:space="preserve">
          <source>The signature of the xCheckReservedLock method on &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; has been modified so that it returns an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; and stores its boolean result into an integer pointed to by a parameter. In association with this change, a new extended error code &lt;a href=&quot;rescode#ioerr_checkreservedlock&quot;&gt;SQLITE_IOERR_CHECKRESERVEDLOCK&lt;/a&gt; has been added.</source>
          <target state="translated">上xCheckReservedLockメソッドのシグネチャ&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methodsは、&lt;/a&gt;それが返すように修正された&lt;a href=&quot;rescode&quot;&gt;エラーコードを&lt;/a&gt;整数にし、そのブール結果を記憶するパラメータによって指されます。この変更に関連して、新しい拡張エラーコード&lt;a href=&quot;rescode#ioerr_checkreservedlock&quot;&gt;SQLITE_IOERR_CHECKRESERVEDLOCK&lt;/a&gt;が追加されました。</target>
        </trans-unit>
        <trans-unit id="23da313c5318bbaf1e11638c6787139e74ceff62" translate="yes" xml:space="preserve">
          <source>The simple, modular design of SQLite makes it a good platform for prototyping new, experimental database language features or ideas.</source>
          <target state="translated">シンプルなモジュール設計のSQLiteは、新しい実験的なデータベース言語の機能やアイデアをプロトタイピングするのに適したプラットフォームとなっています。</target>
        </trans-unit>
        <trans-unit id="2d0de7ad7a0838db1beb185b37e3f4659d20a947" translate="yes" xml:space="preserve">
          <source>The single row of result-set data created by evaluating the aggregate and non-aggregate expressions in the result-set forms the result of an aggregate query without a GROUP BY clause. An aggregate query without a GROUP BY clause always returns exactly one row of data, even if there are zero rows of input data.</source>
          <target state="translated">結果セット内の集約式と非集約式を評価して作成された結果セットデータの1行は、GROUP BY句を使用しない集約クエリの結果となります。GROUP BY句のない集約クエリは、入力データの行が0行であっても、常に正確に1行のデータを返します。</target>
        </trans-unit>
        <trans-unit id="fee8fe6df1809775fcd62fdf9f110bcf759d94a6" translate="yes" xml:space="preserve">
          <source>The six streaming API xxx_strm() functions serve similar purposes to the corresponding non-streaming API functions:</source>
          <target state="translated">6 つのストリーミング API xxx_strm()関数は、対応する非ストリーミング API 関数と同様の目的を果たします。</target>
        </trans-unit>
        <trans-unit id="af903c0dcc364c9d11abbe191c3960a1c5d014f5" translate="yes" xml:space="preserve">
          <source>The sixth argument to sqlite3_bind_text64() must be one of &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; to specify the encoding of the text in the third parameter. If the sixth argument to sqlite3_bind_text64() is not one of the allowed values shown above, or if the text encoding is different from the encoding specified by the sixth parameter, then the behavior is undefined.</source>
          <target state="translated">sqlite3_bind_text64（）の6番目の引数は、3番目のパラメーターでテキストのエンコードを指定するために、&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;、&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;、&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;、または&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LEの&lt;/a&gt;いずれかでなければなりません。 sqlite3_bind_text64（）の6番目の引数が上記の許容値の1つでない場合、またはテキストエンコーディングが6番目のパラメータで指定されたエンコーディングと異なる場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="3a920902ff183846916ffe84129516653c512659" translate="yes" xml:space="preserve">
          <source>The sixth argument to sqlite3_bind_text64() must be one of &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; to specify the encoding of the text in the third parameter. If the sixth argument to sqlite3_bind_text64() is not one of the allowed values shown above, or if the text encoding is different from the encoding specified by the sixth parameter, then the behavior is undefined.</source>
          <target state="translated">sqlite3_bind_text64（）の6番目の引数は、3番目のパラメーターでテキストのエンコードを指定するために、&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;、&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;、&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;、または&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LEの&lt;/a&gt;いずれかでなければなりません。 sqlite3_bind_text64（）の6番目の引数が上記の許容値の1つでない場合、またはテキストエンコーディングが6番目のパラメータで指定されたエンコーディングと異なる場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="e8b06ccbdc8c379a9a470f7c185a0247a80f8e2b" translate="yes" xml:space="preserve">
          <source>The sixth, seventh and eighth parameters passed to the three &quot;sqlite3_create_function*&quot; functions, xFunc, xStep and xFinal, are pointers to C-language functions that implement the SQL function or aggregate. A scalar SQL function requires an implementation of the xFunc callback only; NULL pointers must be passed as the xStep and xFinal parameters. An aggregate SQL function requires an implementation of xStep and xFinal and NULL pointer must be passed for xFunc. To delete an existing SQL function or aggregate, pass NULL pointers for all three function callbacks.</source>
          <target state="translated">3つの &quot;sqlite3_create_function*&quot;関数xFunc、xStep、xFinalに渡される6番目、7番目、8番目のパラメータは、SQL関数や集約を実装するC言語関数へのポインタです。スカラーSQL関数はxFuncコールバックの実装のみを必要とします。集約SQL関数はxStepとxFinalの実装を必要とし、xFuncにはNULLポインタを渡さなければなりません。既存のSQL関数や集合体を削除するには、3つの関数のコールバックすべてにNULLポインタを渡します。</target>
        </trans-unit>
        <trans-unit id="5a1e0ca7d22b49ccdf57dfbe9e13e610f7e7488a" translate="yes" xml:space="preserve">
          <source>The sixth, seventh, eighth and ninth parameters (xStep, xFinal, xValue and xInverse) passed to sqlite3_create_window_function are pointers to C-language callbacks that implement the new function. xStep and xFinal must both be non-NULL. xValue and xInverse may either both be NULL, in which case a regular aggregate function is created, or must both be non-NULL, in which case the new function may be used as either an aggregate or aggregate window function. More details regarding the implementation of aggregate window functions are &lt;a href=&quot;../windowfunctions#udfwinfunc&quot;&gt;available here&lt;/a&gt;.</source>
          <target state="translated">sqlite3_create_window_functionに渡される6番目、7番目、8番目、9番目のパラメーター（xStep、xFinal、xValue、xInverse）は、新しい関数を実装するC言語のコールバックへのポインターです。 xStepとxFinalはどちらも非NULLでなければなりません。 xValueとxInverseはどちらもNULLである場合があります（その場合は通常の集計関数が作成されます）、または両方が非NULLである必要があります。その場合、新しい関数は集計関数または集計ウィンドウ関数として使用できます。集約ウィンドウ関数の実装に関する詳細は、&lt;a href=&quot;../windowfunctions#udfwinfunc&quot;&gt;こちらから入手できます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9f70d86715eabcca8a7d61d2f6e68b2fc4d6a57e" translate="yes" xml:space="preserve">
          <source>The sixth, seventh, eighth and ninth parameters (xStep, xFinal, xValue and xInverse) passed to sqlite3_create_window_function are pointers to C-language callbacks that implement the new function. xStep and xFinal must both be non-NULL. xValue and xInverse may either both be NULL, in which case a regular aggregate function is created, or must both be non-NULL, in which case the new function may be used as either an aggregate or aggregate window function. More details regarding the implementation of aggregate window functions are &lt;a href=&quot;windowfunctions#udfwinfunc&quot;&gt;available here&lt;/a&gt;.</source>
          <target state="translated">sqlite3_create_window_functionに渡される6番目、7番目、8番目、9番目のパラメーター（xStep、xFinal、xValue、xInverse）は、新しい関数を実装するC言語のコールバックへのポインターです。 xStepとxFinalはどちらも非NULLでなければなりません。 xValueとxInverseはどちらもNULLである場合があります（その場合は通常の集計関数が作成されます）、または両方が非NULLである必要があります。その場合、新しい関数は集計関数または集計ウィンドウ関数として使用できます。集約ウィンドウ関数の実装に関する詳細は、&lt;a href=&quot;windowfunctions#udfwinfunc&quot;&gt;こちらから入手できます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="650196bb22cf5bf05d1563df9b31bf781c3e9a6d" translate="yes" xml:space="preserve">
          <source>The size of the blobs in the test data affects performance. The filesystem will generally be faster for larger blobs, since the overhead of open() and close() is amortized over more bytes of I/O, whereas the database will be more efficient in both speed and space as the average blob size decreases.</source>
          <target state="translated">テストデータのブロブのサイズはパフォーマンスに影響します。open()とclose()のオーバーヘッドはより多くのバイト数のI/Oで償却されるため、ファイルシステムは一般的にブロブが大きいほど高速になります。</target>
        </trans-unit>
        <trans-unit id="71ba6b5b378d657456a5945d2ff20a780b1b14d4" translate="yes" xml:space="preserve">
          <source>The size of the lookaside memory pool has a global default value but can also be configured on a connection-by-connection basis. To change the default size of the lookaside memory pool at compile-time, use the &lt;a href=&quot;compile#default_lookaside&quot;&gt;-DSQLITE_DEFAULT_LOOKASIDE=&lt;i&gt;SZ,N&lt;/i&gt;&lt;/a&gt; option. To change the default size of the lookaside memory pool at start-time, use the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface:</source>
          <target state="translated">ルックアサイドメモリプールのサイズにはグローバルなデフォルト値がありますが、接続ごとに構成することもできます。コンパイル時にルックアサイドメモリプールのデフォルトサイズを変更するには、&lt;a href=&quot;compile#default_lookaside&quot;&gt;-DSQLITE_DEFAULT_LOOKASIDE = &lt;i&gt;SZ、N&lt;/i&gt;&lt;/a&gt;オプションを使用します。開始時にルックアサイドメモリプールのデフォルトサイズを変更するには、&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;インターフェイスを使用します。</target>
        </trans-unit>
        <trans-unit id="7032e0044fe8cbf0ccd0392512f38ee2b17ffc25" translate="yes" xml:space="preserve">
          <source>The size of the matching term in bytes.</source>
          <target state="translated">マッチング項のサイズをバイト単位で指定します。</target>
        </trans-unit>
        <trans-unit id="481f99d28cac0daa50062e9ad3a05601840366c0" translate="yes" xml:space="preserve">
          <source>The size of the memory-mapped I/O region cannot be changed while the memory-mapped I/O region is in active use, to avoid unmapping memory out from under running SQL statements. For this reason, the mmap_size pragma may be a no-op if the prior mmap_size is non-zero and there are other SQL statements running concurrently on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">メモリマップI / O領域のサイズは、メモリマップI / O領域がアクティブに使用されている間は変更できません。これにより、実行中のSQLステートメントからメモリがアンマップされないようにします。このため、前のmmap_sizeがゼロ以外で、同じ&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;上で同時に実行されている他のSQLステートメントがある場合、mmap_sizeプラグマは何もしない場合があります。</target>
        </trans-unit>
        <trans-unit id="19c67c781984d7843a725bf421c45281605af01e" translate="yes" xml:space="preserve">
          <source>The snippet function first attempts to find a fragment of text consisting of</source>
          <target state="translated">スニペット関数は、まず、以下の要素からなるテキストの断片を見つけようとします。</target>
        </trans-unit>
        <trans-unit id="54b3f9fdd628ef57cd97424e1a01116d0ba15ccd" translate="yes" xml:space="preserve">
          <source>The snippet function is used to create formatted fragments of document text for display as part of a full-text query results report. The snippet function may be passed between one and six arguments, as follows:</source>
          <target state="translated">snippet関数は、フルテキストのクエリ結果レポートの一部として表示するために、 フォーマットされたドキュメントテキストの断片を作成するために使用されます。スニペット関数には、以下のように 1 つから 6 つの引数を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="25ab90403f978d997e2573cced370b12d71d602c" translate="yes" xml:space="preserve">
          <source>The snippet() function is similar to highlight(), except that instead of returning entire column values, it automatically selects and extracts a short fragment of document text to process and return. The snippet() function must be passed five parameters following the table name argument:</source>
          <target state="translated">snippet()関数は highlight()に似ていますが、列全体の値を返すのではなく、 ドキュメントテキストの短い断片を自動的に選択・抽出して処理して返す点が異なります。snippet()関数には、テーブル名の引数の後に 5 つのパラメータを渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="650db23255aac8aa4103c6f6d9992ba8c2854051" translate="yes" xml:space="preserve">
          <source>The soft heap limit is &quot;soft&quot; in this sense: If SQLite is not able to free up enough auxiliary memory to stay below the limit, it goes ahead and allocates the extra memory and exceeds its limit. This occurs under the theory that it is better to use additional memory than to fail outright.</source>
          <target state="translated">ソフトヒープ制限はこの意味で「ソフト」です。これは、完全に失敗するよりも追加のメモリを使用した方が良いという理論の下で発生します。</target>
        </trans-unit>
        <trans-unit id="f259c7b18142819d8b2454c94e82cad365d3cfbd" translate="yes" xml:space="preserve">
          <source>The soft heap limit is not enforced in the current implementation if one or more of following conditions are true:</source>
          <target state="translated">現在の実装では、以下の条件のうち1つ以上が真の場合、ソフトヒープ制限は適用されません。</target>
        </trans-unit>
        <trans-unit id="62f643dbe59889b37bb6ee27203ce861b75e4df1" translate="yes" xml:space="preserve">
          <source>The soft heap limit is set to zero.</source>
          <target state="translated">ソフトヒープの制限はゼロに設定されています。</target>
        </trans-unit>
        <trans-unit id="1e9f9417ca080fbcc56641af6510e79f88f545c2" translate="yes" xml:space="preserve">
          <source>The soft heap limit may not be greater than the hard heap limit. If the hard heap limit is enabled and if sqlite3_soft_heap_limit(N) is invoked with a value of N that is greater than the hard heap limit, the the soft heap limit is set to the value of the hard heap limit. The soft heap limit is automatically enabled whenever the hard heap limit is enabled. When sqlite3_hard_heap_limit64(N) is invoked and the soft heap limit is outside the range of 1..N, then the soft heap limit is set to N. Invoking sqlite3_soft_heap_limit64(0) when the hard heap limit is enabled makes the soft heap limit equal to the hard heap limit.</source>
          <target state="translated">ソフトヒープ制限はハードヒープ制限を超えてはいけません。ハードヒープ制限が有効な場合、ハードヒープ制限よりも大きいNの値でsqlite3_soft_heap_limit(N)が呼び出された場合、ソフトヒープ制限はハードヒープ制限の値に設定されます。ソフトヒープ制限はハードヒープ制限が有効になると自動的に有効になります。ハードヒープ制限が有効なときにsqlite3_hard_heap_limit64(N)を呼び出すと、ソフトヒープ制限はハードヒープ制限と等しくなります。</target>
        </trans-unit>
        <trans-unit id="84963983acb45095ae249428915953ba1875b5f1" translate="yes" xml:space="preserve">
          <source>The solution was computed in less than 300 milliseconds on a modern workstation.</source>
          <target state="translated">この解は、最新のワークステーションで300ミリ秒以内に計算されました。</target>
        </trans-unit>
        <trans-unit id="d8fc439428a4b57b8a635dfdc3bc6c9e9458a598" translate="yes" xml:space="preserve">
          <source>The solver works by adding new entries to the &quot;x&quot; recursive table. Given prior entries, the recursive-select tries to fill in a single new position with all values between 1 and 9 that actually work in that position. The complicated &quot;NOT EXISTS&quot; subquery is the magic that figures out whether or not each candidate &quot;s&quot; string is a valid sudoku puzzle or not.</source>
          <target state="translated">ソルバーは、&quot;x &quot;再帰テーブルに新しいエントリを追加することで動作する。前のエントリが与えられると、再帰的選択は、1から9の間のすべての値がその位置で実際に動作するように、1つの新しい位置を埋めようとする。複雑な &quot;NOT EXISTS &quot;副問い合わせは、各候補の &quot;s &quot;文字列が有効な数独パズルであるかどうかを判断する魔法のようなものです。</target>
        </trans-unit>
        <trans-unit id="a81e5007b5735cbaaaf41fe92b085a6bb28859ca" translate="yes" xml:space="preserve">
          <source>The sorter can use auxiliary helper threads to increase real-time response. This feature is off by default and may be enabled using the &lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; command or the &lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt; compile-time option.</source>
          <target state="translated">ソーターは、補助ヘルパースレッドを使用して、リアルタイムの応答を向上させることができます。この機能はデフォルトでオフになっており、&lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMAスレッド&lt;/a&gt;コマンドまたは&lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt;コンパイル時オプションを使用して有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="f3082f533e58c712999cbf940673f567d8a29017" translate="yes" xml:space="preserve">
          <source>The soundex(X) function returns a string that is the soundex encoding of the string X. The string &quot;?000&quot; is returned if the argument is NULL or contains no ASCII alphabetic characters. This function is omitted from SQLite by default. It is only available if the &lt;a href=&quot;compile#soundex&quot;&gt;SQLITE_SOUNDEX&lt;/a&gt; compile-time option is used when SQLite is built.</source>
          <target state="translated">soundex（X）関数は、文字列Xのsoundexエンコーディングである文字列を返します。引数がNULLであるか、ASCIIアルファベット文字が含まれていない場合、文字列 &quot;？000&quot;が返されます。この関数は、デフォルトでSQLiteから省略されています。SQLiteのビルド時に&lt;a href=&quot;compile#soundex&quot;&gt;SQLITE_SOUNDEX&lt;/a&gt;コンパイル時オプションが使用されている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="9611e60fec986c004f40bb3986af444fd02497aa" translate="yes" xml:space="preserve">
          <source>The source &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; may be used by the application for other purposes while a backup operation is underway or being initialized. If SQLite is compiled and configured to support threadsafe database connections, then the source database connection may be used concurrently from within other threads.</source>
          <target state="translated">ソース&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;は、バックアップ操作の実行中または初期化中に、アプリケーションによって他の目的で使用される場合があります。SQLiteがコンパイルされ、スレッドセーフデータベース接続をサポートするように構成されている場合、ソースデータベース接続は他のスレッド内から同時に使用できます。</target>
        </trans-unit>
        <trans-unit id="d46770cf519d64fb4869e93bb4ebad2a0d214ebb" translate="yes" xml:space="preserve">
          <source>The source &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; may be used by the application for other purposes while a backup operation is underway or being initialized. If SQLite is compiled and configured to support threadsafe database connections, then the source database connection may be used concurrently from within other threads.</source>
          <target state="translated">ソース&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;は、バックアップ操作の実行中または初期化中に、アプリケーションによって他の目的で使用される場合があります。SQLiteがコンパイルされ、スレッドセーフデータベース接続をサポートするように構成されている場合、ソースデータベース接続は他のスレッド内から同時に使用できます。</target>
        </trans-unit>
        <trans-unit id="cb98bce78cf336a453aacfd68f1f2a70ccf1bb9e" translate="yes" xml:space="preserve">
          <source>The source code files for other SQL database engines typically begin with a comment describing your legal rights to view and copy that file. The SQLite source code contains no license since it is not governed by copyright. Instead of a license, the SQLite source code offers a blessing:</source>
          <target state="translated">他の SQL データベースエンジンのソースコードファイルは、通常、そのファイルを表示したりコピーしたりするための法的権利を記述したコメントで始まります。SQLite のソースコードは著作権によって管理されていないため、ライセンスが含まれていません。ライセンスの代わりに、SQLite のソースコードは祝福を提供します。</target>
        </trans-unit>
        <trans-unit id="b230daf41ab11e7921fa2a959263c09c6fe7e609" translate="yes" xml:space="preserve">
          <source>The source code for Geopoly is included in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; but is not included in the library unless the &lt;a href=&quot;compile#enable_geopoly&quot;&gt;-DSQLITE_ENABLE_GEOPOLY&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">Geopolyのソースコードが含まれている&lt;a href=&quot;amalgamation&quot;&gt;合併&lt;/a&gt;ますがない限り、ライブラリに含まれていません&lt;a href=&quot;compile#enable_geopoly&quot;&gt;-DSQLITE_ENABLE_GEOPOLY&lt;/a&gt;コンパイル時のオプションが使用されています。</target>
        </trans-unit>
        <trans-unit id="9ce563d47e369284dcc9eb90d209f5fe50c9d87d" translate="yes" xml:space="preserve">
          <source>The source code for SQLite is in the public domain. No claim of copyright is made on any part of the core source code. (The documentation and test code is a different matter - some sections of documentation and test logic are governed by open-source licenses.) All contributors to the SQLite core software have signed affidavits specifically disavowing any copyright interest in the code. This means that anybody is able to legally do anything they want with the SQLite source code.</source>
          <target state="translated">SQLiteのソースコードはパブリックドメインです。コアとなるソースコードのいかなる部分にも著作権は主張されていません。(ドキュメントとテストコードは別問題です-ドキュメントとテストロジックのいくつかのセクションはオープンソースのライセンスで管理されています)。SQLiteコアソフトウェアへの貢献者は全員、そのコードの著作権に関する一切の利害関係を否定する宣誓供述書に署名しています。これは、誰もがSQLiteのソースコードを合法的に何でもできるということを意味します。</target>
        </trans-unit>
        <trans-unit id="1cfec4458134c689073b56a3f124a05cfee319a4" translate="yes" xml:space="preserve">
          <source>The source code in public SQLite releases uses unix line endings (ASCII code 10: &quot;newline&quot; only, NL) and spaces instead of tabs. If you will be changing the line ending to windows-style line endings (ASCII codes 13, 10: &quot;carriage-return&quot; and &quot;newline&quot;; CR-NL) or if you will be changing space indents into tab indents, &lt;b&gt;make that change now&lt;/b&gt; before you check in the baseline. The merging process will only work well if the differences between the public and the private branches are minimal. If every single line of the source file is changed in the private branch because you changed from NL to CR-NL line endings, then the merge steps will not work correctly.</source>
          <target state="translated">パブリックSQLiteリリースのソースコードでは、タブの代わりにUNIXの行末（ASCIIコード10：「改行」のみ、NL）とスペースを使用しています。行末をWindowsスタイルの行末に変更する場合（ASCIIコード13、10：「復帰」と「改行」、CR-NL）、またはスペースインデントをタブインデントに変更する場合は、&lt;b&gt;その変更を行います。今、&lt;/b&gt;あなたは、ベースラインをチェックインする前に。マージプロセスは、パブリックブランチとプライベートブランチの違いが最小限の場合にのみうまく機能します。 NLからCR-NLの行末に変更したためにソースファイルのすべての1行がプライベートブランチで変更された場合、マージ手順は正しく機能しません。</target>
        </trans-unit>
        <trans-unit id="c71fe30151d8d1ffe822e83fe610e421f8822069" translate="yes" xml:space="preserve">
          <source>The source code module that implements the spellfix1 virtual table also implements several SQL functions that might be useful to applications that employ spellfix1 or for testing or diagnostic work while developing applications that use spellfix1. The following auxiliary functions are available:</source>
          <target state="translated">spellfix1 仮想テーブルを実装したソースコードモジュールには、spellfix1 を使用したアプリケーションや、spellfix1 を使用したアプリケーションを開発する際のテストや診断作業に役立つと思われる SQL 関数もいくつか実装されています。以下の補助関数が利用可能です。</target>
        </trans-unit>
        <trans-unit id="06e0d7a5506cbf178b35ec85914ad01a3f38017c" translate="yes" xml:space="preserve">
          <source>The source code to SQLite is designed to be readable and accessible to the average programmer. All procedures and data structures and many automatic variables are carefully commented with useful information about what they do. Boilerplate commenting is omitted.</source>
          <target state="translated">SQLite のソースコードは、一般的なプログラマーが読みやすく、アクセスしやすいように設計されています。すべてのプロシージャとデータ構造、および多くの自動変数は、それらが何をするのかについての有用な情報とともに慎重にコメントされています。ボイラープレートのコメントは省略されています。</target>
        </trans-unit>
        <trans-unit id="042c70a1cba19758906aae3ec84cad7dc8c53383" translate="yes" xml:space="preserve">
          <source>The source code to the SQLite R*Tree module is included as part of the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; but is disabled by default. To enable the R*Tree module, simply compile with the &lt;a href=&quot;compile#enable_rtree&quot;&gt;SQLITE_ENABLE_RTREE&lt;/a&gt; C-preprocessor macro defined. With many compilers, this is accomplished by adding the option &quot;-DSQLITE_ENABLE_RTREE=1&quot; to the compiler command-line.</source>
          <target state="translated">SQLite R * Treeモジュールのソースコードは、&lt;a href=&quot;amalgamation&quot;&gt;統合の&lt;/a&gt;一部として含まれていますが、デフォルトでは無効になっています。R * Treeモジュールを有効にするには、&lt;a href=&quot;compile#enable_rtree&quot;&gt;SQLITE_ENABLE_RTREE&lt;/a&gt; Cプリプロセッサマクロを定義してコンパイルするだけです。多くのコンパイラでは、これはオプション「-DSQLITE_ENABLE_RTREE = 1」をコンパイラのコマンドラインに追加することで実現されます。</target>
        </trans-unit>
        <trans-unit id="a40cbeb8ac52569bca99e948856ab4db846ed02b" translate="yes" xml:space="preserve">
          <source>The source code to the bytecode engine is in the &lt;a href=&quot;http://www.sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c&lt;/a&gt; source file. The &lt;a href=&quot;opcode#codes&quot;&gt;opcode definitions&lt;/a&gt; in this document are derived from comments in that source file. The source code comments are the canonical source of information about the bytecode engine. When in doubt, refer to the source code.</source>
          <target state="translated">バイトコードエンジンのソースコードは、&lt;a href=&quot;http://www.sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c&lt;/a&gt;ソースファイルにあります。このドキュメントの&lt;a href=&quot;opcode#codes&quot;&gt;オペコード定義&lt;/a&gt;は、そのソースファイルのコメントから派生しています。ソースコードのコメントは、バイトコードエンジンに関する正規の情報源です。疑問がある場合は、ソースコードを参照してください。</target>
        </trans-unit>
        <trans-unit id="013177e363c21284dd8426d7c41bb413bf325a0a" translate="yes" xml:space="preserve">
          <source>The source code to the software that runs the checklists is stored in its own Fossil repository at &lt;a href=&quot;https://www.sqlite.org/checklistapp&quot;&gt;https://www.sqlite.org/checklistapp&lt;/a&gt;.</source>
          <target state="translated">チェックリストを実行するソフトウェアのソースコードは、&lt;a href=&quot;https://www.sqlite.org/checklistapp&quot;&gt;https：//www.sqlite.org/checklistappにある&lt;/a&gt;独自のFossilリポジトリに格納されています。</target>
        </trans-unit>
        <trans-unit id="79b8e8d26e2fd4c36bb8b15bd366cedd02031771" translate="yes" xml:space="preserve">
          <source>The source code to the sqlite3 command line interface is in a single file named &quot;shell.c&quot;. The shell.c source file is generated from other sources, but most of the code for shell.c can be found in &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;src/shell.c.in&lt;/a&gt;. (Regenerate shell.c by typing &quot;make shell.c&quot; from the canonical source tree.) &lt;a href=&quot;howtocompile&quot;&gt;Compile&lt;/a&gt; the shell.c file (together with the &lt;a href=&quot;amalgamation&quot;&gt;sqlite3 library source code&lt;/a&gt;) to generate the executable. For example:</source>
          <target state="translated">sqlite3コマンドラインインターフェースのソースコードは、「shell.c」という名前の単一ファイルにあります。shell.cソースファイルは他のソースから生成されますが、shell.cのコードのほとんどは&lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;src / shell.c.inにあり&lt;/a&gt;ます。（正規のソースツリーから「make shell.c」と入力してshell.cを再生成します。）shell.cファイルを（&lt;a href=&quot;amalgamation&quot;&gt;sqlite3ライブラリのソースコード&lt;/a&gt;と共に）&lt;a href=&quot;howtocompile&quot;&gt;コンパイルし&lt;/a&gt;て、実行可能ファイルを生成します。例えば：</target>
        </trans-unit>
        <trans-unit id="3baebed042eebfba10dcbc501e7f4785bd1f6d07" translate="yes" xml:space="preserve">
          <source>The source file and entry point are named for &quot;unionvtab&quot; instead of &quot;swarmvtab&quot;. Unionvtab is a &lt;a href=&quot;unionvtab&quot;&gt;separately documented&lt;/a&gt; virtual table that is bundled with swarmvtab.</source>
          <target state="translated">ソースファイルとエントリポイントは、「swarmvtab」ではなく「unionvtab」という名前が付けられています。Unionvtabは、&lt;a href=&quot;unionvtab&quot;&gt;個別にドキュメント化された&lt;/a&gt;仮想テーブルであり、swarmvtabにバンドルされています。</target>
        </trans-unit>
        <trans-unit id="f3fba365763538ecbddb6c57bd7009fd058f9084" translate="yes" xml:space="preserve">
          <source>The special &quot;:memory:&quot; filename also works when using &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt;. For example:</source>
          <target state="translated">特別な &quot;：memory：&quot;ファイル名は、&lt;a href=&quot;uri&quot;&gt;URIファイル名&lt;/a&gt;を使用するときにも機能します。例えば：</target>
        </trans-unit>
        <trans-unit id="e94ff833d41c9d30c15767ac9e7aeb85daf442aa" translate="yes" xml:space="preserve">
          <source>The special UPSERT processing happens only for uniqueness constraint on the table that is receiving the INSERT. A &quot;uniqueness constraint&quot; is an explicit UNIQUE or PRIMARY KEY constraint within the CREATE TABLE statement, or a &lt;a href=&quot;lang_createindex#uniqueidx&quot;&gt;unique index&lt;/a&gt;. UPSERT does not intervene for failed NOT NULL or foreign key constraints or for constraints that are implemented using triggers.</source>
          <target state="translated">特別なUPSERT処理は、INSERTを受け取っているテーブルの一意性制約に対してのみ発生します。「一意性制約」は、CREATE TABLEステートメント内の明示的なUNIQUEまたはPRIMARY KEY制約、または&lt;a href=&quot;lang_createindex#uniqueidx&quot;&gt;一意のインデックス&lt;/a&gt;です。UPSERTは、失敗したNOT NULL制約、外部キー制約、またはトリガーを使用して実装された制約には介入しません。</target>
        </trans-unit>
        <trans-unit id="2e94e3f68bdf7fc07fc0dcd878c089797a3fe9a2" translate="yes" xml:space="preserve">
          <source>The special filename &quot;:memory:&quot; can be used anywhere that a database filename is permitted. For example, it can be used as the</source>
          <target state="translated">特別なファイル名 &quot;:memory:&quot; は、データベースのファイル名が許可されている場所であればどこでも使うことができます。例えば、これは</target>
        </trans-unit>
        <trans-unit id="dff68709141a31a267598fa549dc38cfbd61c946" translate="yes" xml:space="preserve">
          <source>The special processing for opening ZIP archives is a trick of the command-line shell, not the core SQLite library. So if you want to open a ZIP archive as a database in your application, you will need to activate the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; module then run an appropriate &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement.</source>
          <target state="translated">ZIPアーカイブを開くための特別な処理は、コアSQLiteライブラリではなく、コマンドラインシェルのトリックです。したがって、アプリケーションでデータベースとしてZIPアーカイブを開きたい場合は、&lt;a href=&quot;zipfile&quot;&gt;Zipfile仮想テーブル&lt;/a&gt;モジュールをアクティブ化してから、適切な&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE &lt;/a&gt;VIRTUALTABLEステートメントを実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="29bca994e11cb6f841a93aac5cdb8471376e38df" translate="yes" xml:space="preserve">
          <source>The specified column of row iRow contains a value that is not a TEXT or BLOB value,</source>
          <target state="translated">行 iRow の指定された列には、TEXT 値または BLOB 値以外の値が含まれています。</target>
        </trans-unit>
        <trans-unit id="06e48e6df6f51c35512fa45acc8a0e8a634c95f8" translate="yes" xml:space="preserve">
          <source>The speedtest1.c program is updated from time to time as the SQLite developers' understanding of what constitutes &quot;typical&quot; usage evolves.</source>
          <target state="translated">speedtest1.cプログラムは、SQLite開発者の「典型的な」使用法の理解が進むにつれて随時更新されます。</target>
        </trans-unit>
        <trans-unit id="5446f248e6916745d646dc3f5e88e893b3ad00cc" translate="yes" xml:space="preserve">
          <source>The speedtest1.c workload that is being measured tries to be representative of a wide range of typical uses of SQLite. But every application is different. The speedtest1.c workload might not be a good proxy for the kinds of activities performed by some applications. The SQLite developers are constantly working to improve the speedtest1.c program, to make it a better proxy for actual SQLite usage. Community feedback is welcomed.</source>
          <target state="translated">測定されている speedtest1.c のワークロードは、SQLite の典型的な使用法の広い範囲を代表するものにしようとしています。しかし、すべてのアプリケーションは異なります。speedtest1.cのワークロードは、アプリケーションによっては実行されるアクティビティの種類を表す良いプロキシではないかもしれません。SQLiteの開発者は、実際のSQLiteの使用状況をより良く表すために、speedtest1.cプログラムの改善に常に取り組んでいます。コミュニティからのフィードバックを歓迎します。</target>
        </trans-unit>
        <trans-unit id="92167de554e681259504f6e2f3edf942b7026bd6" translate="yes" xml:space="preserve">
          <source>The spellfix1 virtual table creates a single shadow table named &quot;%_vocab&quot; (where the % is replaced by the name of the virtual table; Ex: &quot;demo_vocab&quot; for the &quot;demo&quot; virtual table). the shadow table contains the following columns:</source>
          <target state="translated">spellfix1 仮想テーブルは &quot;%_vocab&quot; という名前のシャドウテーブルを作成します (ここでは % は仮想テーブル名に置き換えられます。例:&quot;demo&quot; 仮想テーブルの場合は &quot;demo_vocab&quot; となります)。</target>
        </trans-unit>
        <trans-unit id="f9097157fe13f14b48b89617ee87aed62da83c73" translate="yes" xml:space="preserve">
          <source>The spellfix1 virtual table uses editdist3 if the &quot;edit_cost_table=TABLE&quot; option is specified as an argument when the spellfix1 virtual table is created. But editdist3 can also be tested directly using the built-in &quot;editdist3()&quot; SQL function. The editdist3() SQL function has 3 forms:</source>
          <target state="translated">spellfix1の仮想テーブルを作成する際に、&quot;edit_cost_table=TABLE &quot;オプションを引数に指定すると、spellfix1の仮想テーブルはeditdist3を使用します。しかし、組み込みの SQL 関数 &quot;editdist3()&quot; を使って editdist3 を直接テストすることもできます。editdist3()SQL関数には3つの形式があります。</target>
        </trans-unit>
        <trans-unit id="e416e23f51996e4d87d84d45407db4bd482280e4" translate="yes" xml:space="preserve">
          <source>The sqlar_compress(X) function attempts to compress a copy of the string or blob X using the &lt;a href=&quot;https://zlib.net/&quot;&gt;Default&lt;/a&gt; algorithm and returns the result as a blob. If the input X is incompressible, then a copy of X is returned. This routine is used when inserting content into an SQLite Archive.</source>
          <target state="translated">sqlar_compress（X）関数は、&lt;a href=&quot;https://zlib.net/&quot;&gt;デフォルト&lt;/a&gt;アルゴリズムを使用して文字列またはblob Xのコピーを圧縮しようとし、結果をblobとして返します。入力Xが圧縮できない場合、Xのコピーが返されます。このルーチンは、SQLiteアーカイブにコンテンツを挿入するときに使用されます。</target>
        </trans-unit>
        <trans-unit id="0c132e268d7082089985d58b1716bee78c9b6c72" translate="yes" xml:space="preserve">
          <source>The sqlar_uncompress(Y,SZ) function will undo the compression accomplished by sqlar_compress(X). The Y parameter is the compressed content (the output from a prior call to sqlar_compress()) and SZ is the original uncompressed size of the input X that generated Y. If SZ is less than or equal to the size of Y, that indicates that no compression occurred, and so sqlar_uncompress(Y,SZ) returns a copy of Y. Otherwise, sqlar_uncompress(Y,SZ) runs the Inflate algorithm on Y to uncompress it and restore it to its original form and returns the uncompressed content. This routine is used when extracting content from an SQLite Archive.</source>
          <target state="translated">sqlar_uncompress(Y,SZ)関数は sqlar_compress(X)で行った圧縮を元に戻します。Y パラメータは圧縮された内容 (sqlar_compress()を呼び出す前の出力)であり、SZ は Y を生成した入力 X の元の圧縮されていないサイズです。 SZ が Y のサイズ以下の場合は圧縮が行われていないことを示しているので、sqlar_uncompress(Y,SZ)は Y のコピーを返します。このルーチンは、SQLite アーカイブからコンテンツを抽出する際に使用します。</target>
        </trans-unit>
        <trans-unit id="9894bd2027e1ec7fe1defc073eb794af8cfcddba" translate="yes" xml:space="preserve">
          <source>The sqldiff.exe utility does not (currently) display differences in &lt;a href=&quot;lang_createtrigger&quot;&gt;TRIGGERs&lt;/a&gt; or &lt;a href=&quot;lang_createview&quot;&gt;VIEWs&lt;/a&gt;.</source>
          <target state="translated">sqldiff.exeユーティリティは、（現在のところ）&lt;a href=&quot;lang_createtrigger&quot;&gt;TRIGGER&lt;/a&gt;または&lt;a href=&quot;lang_createview&quot;&gt;VIEWの&lt;/a&gt;違いを表示しません。</target>
        </trans-unit>
        <trans-unit id="1eec35831f2ddb18882fbe495fb78b6e88f27f70" translate="yes" xml:space="preserve">
          <source>The sqldiff.exe utility is unable to compute differences for rowid tables for which the rowid is inaccessible. An example of a table with an inaccessible rowid is:</source>
          <target state="translated">sqldiff.exeユーティリティーは、行番号がアクセスできない行番号テーブルの差分を計算できませんでした。rowidにアクセスできないテーブルの例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="199f0fae6d132ab01eeef495a83df7f5456338b1" translate="yes" xml:space="preserve">
          <source>The sqldiff.exe utility works by finding rows in the source and destination that are logical &quot;pairs&quot;. The default behavior is to treat two rows as pairs if they are in tables with the same name and they have the same &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;, or in the case of a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table if they have the same &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;. Any differences in the content of paired rows are output as UPDATEs. Rows in the source database that could not be paired are output as DELETEs. Rows in the destination database that could not be paired are output as INSERTs.</source>
          <target state="translated">sqldiff.exeユーティリティは、ソースと宛先で論理的な「ペア」である行を見つけることによって機能します。デフォルトの動作では、2つの行が同じ名前のテーブルにあり、それらの行&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ID&lt;/a&gt;が同じ場合は2つの行をペアとして扱い、&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルの場合は同じ&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;を持つ場合を扱います。ペアになった行の内容の違いは、UPDATEとして出力されます。ペアにできなかったソースデータベースの行は、DELETEとして出力されます。ペアリングできなかった宛先データベースの行は、INSERTとして出力されます。</target>
        </trans-unit>
        <trans-unit id="5a94a70315a765a01576195e900e88922987242a" translate="yes" xml:space="preserve">
          <source>The sqlite3 program is able to show the results of a query in 14 different formats:</source>
          <target state="translated">sqlite3プログラムは、クエリの結果を14の異なるフォーマットで表示することができます。</target>
        </trans-unit>
        <trans-unit id="8a33930cce71afaf2bac4391a7d92f2102fe6799" translate="yes" xml:space="preserve">
          <source>The sqlite3 program is able to show the results of a query in eight different formats: &quot;csv&quot;, &quot;column&quot;, &quot;html&quot;, &quot;insert&quot;, &quot;line&quot;, &quot;list&quot;, &quot;quote&quot;, &quot;tabs&quot;, and &quot;tcl&quot;. You can use the &quot;.mode&quot; dot command to switch between these output formats.</source>
          <target state="translated">sqlite3プログラムは、クエリの結果を8つの異なるフォーマットで表示することができます。&quot;csv&quot;、&quot;column&quot;、&quot;html&quot;、&quot;insert&quot;、&quot;line&quot;、&quot;list&quot;、&quot;quote&quot;、&quot;tabs&quot;、&quot;tcl &quot;です。これらの出力形式を切り替えるには、&quot;.mode&quot; ドットコマンドを使用することができます。</target>
        </trans-unit>
        <trans-unit id="c934dde95758c5fad9d43c84ef7f4c41bf3fe114" translate="yes" xml:space="preserve">
          <source>The sqlite3 program provides several convenience commands that are useful for looking at the schema of the database. There is nothing that these commands do that cannot be done by some other means. These commands are provided purely as a shortcut.</source>
          <target state="translated">sqlite3プログラムはデータベースのスキーマを見るのに便利なコマンドをいくつか提供しています。これらのコマンドは他の手段でできないことは何もありません。これらのコマンドは純粋にショートカットとして提供されています。</target>
        </trans-unit>
        <trans-unit id="d730ebfc68ed44661fe9aaa4784f842bff23a6ec" translate="yes" xml:space="preserve">
          <source>The sqlite3_aggregate_context(C,N) routine returns a NULL pointer when first called if N is less than or equal to zero or if a memory allocate error occurs.</source>
          <target state="translated">sqlite3_aggregate_context(C,N)ルーチンは、Nが0以下の場合やメモリ割り当てエラーが発生した場合に最初に呼び出されたときにNULLポインタを返します。</target>
        </trans-unit>
        <trans-unit id="a781b80076608933fb39f35323ee417edf53e9fb" translate="yes" xml:space="preserve">
          <source>The sqlite3_analyzer utility program is updated to provide better descriptions and to compute a more accurate estimate for &quot;Non-sequential pages&quot;</source>
          <target state="translated">sqlite3_analyzerユーティリティプログラムが更新され、より良い説明が提供され、&quot;連続しないページ &quot;のより正確な推定値が計算されるようになりました。</target>
        </trans-unit>
        <trans-unit id="cea6cec9b3cecf3cdb8b21b8c439ffacaf7e4757" translate="yes" xml:space="preserve">
          <source>The sqlite3_analyzer.exe Utility Program</source>
          <target state="translated">sqlite3_analyzer.exe ユーティリティプログラム</target>
        </trans-unit>
        <trans-unit id="08064e181ad262ed7b2155684ee88c71ec311b40" translate="yes" xml:space="preserve">
          <source>The sqlite3_analyzer.exe utility is updated to report the depth of each btree and to show the average fanout for indexes and WITHOUT ROWID tables.</source>
          <target state="translated">sqlite3_analyzer.exeユーティリティが更新され、各btreeの深さをレポートし、インデックスとWITHOUT ROWIDテーブルの平均ファンアウトを表示するようになりました。</target>
        </trans-unit>
        <trans-unit id="69ea749b99043a4585c42b36d581974b4510bba7" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup object records state information about an ongoing online backup operation. The sqlite3_backup object is created by a call to &lt;a href=&quot;#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt; and is destroyed by a call to &lt;a href=&quot;#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_backupオブジェクトは、進行中のオンラインバックアップ操作に関する状態情報を記録します。sqlite3_backupオブジェクトは、呼び出しによって作成され&lt;a href=&quot;#sqlite3backupinit&quot;&gt;sqlite3_backup_init（）&lt;/a&gt;との呼び出しによって破壊される&lt;a href=&quot;#sqlite3backupfinish&quot;&gt;）sqlite3_backup_finish（ &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ff5c92c4105199925092609d2d9f802d1fa55672" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup object records state information about an ongoing online backup operation. The sqlite3_backup object is created by a call to &lt;a href=&quot;backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt; and is destroyed by a call to &lt;a href=&quot;backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_backupオブジェクトは、進行中のオンラインバックアップ操作に関する状態情報を記録します。sqlite3_backupオブジェクトは、呼び出しによって作成され&lt;a href=&quot;backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init（）&lt;/a&gt;との呼び出しによって破壊される&lt;a href=&quot;backup_finish#sqlite3backupfinish&quot;&gt;）sqlite3_backup_finish（ &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db586a6cde9f4397b1aba32074e60460ba79310a" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_remaining() and sqlite3_backup_pagecount() APIs report values stored by the previous call to sqlite3_backup_step(), they do not actually inspect the source database file. This means that if the source database is written to by another thread or process after the call to sqlite3_backup_step() returns but before the values returned by sqlite3_backup_remaining() and sqlite3_backup_pagecount() are used, the values may be technically incorrect. This is not usually a problem.</source>
          <target state="translated">sqlite3_backup_remaining()とsqlite3_backup_pagecount()APIは前のsqlite3_backup_step()の呼び出しで格納された値を報告しますが、実際にはソースデータベースファイルを検査しません。つまり、sqlite3_backup_step()の呼び出しが返された後、sqlite3_backup_remaining()とsqlite3_backup_pagecount()によって返された値が使用される前に、別のスレッドやプロセスによってソースデータベースが書き込まれた場合、その値は技術的に間違っている可能性があります。これは通常は問題ではありません。</target>
        </trans-unit>
        <trans-unit id="ab13e83a5eec05a800456f808bd2ed14f96ad7d8" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_remaining() routine returns the number of pages still to be backed up at the conclusion of the most recent sqlite3_backup_step(). The sqlite3_backup_pagecount() routine returns the total number of pages in the source database at the conclusion of the most recent sqlite3_backup_step(). The values returned by these functions are only updated by sqlite3_backup_step(). If the source database is modified in a way that changes the size of the source database or the number of pages remaining, those changes are not reflected in the output of sqlite3_backup_pagecount() and sqlite3_backup_remaining() until after the next sqlite3_backup_step().</source>
          <target state="translated">sqlite3_backup_remaining()ルーチンは、直近のsqlite3_backup_step()の終了時に、まだバックアップされるページ数を返します。sqlite3_backup_pagecount()ルーチンは、最新のsqlite3_backup_step()の終了時にソース・データベース内のページの総数を返します。これらの関数によって返される値は、sqlite3_backup_step()によってのみ更新されます。ソースデータベースのサイズや残りページ数を変更するような方法でソースデータベースが変更された場合、その変更は次のsqlite3_backup_step()の後までsqlite3_backup_pagecount()とsqlite3_backup_remaining()の出力には反映されません。</target>
        </trans-unit>
        <trans-unit id="027c7809f8a158ea3a080d548eaba037441f7cc5" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_step() might return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt; if</source>
          <target state="translated">sqlite3_backup_step（）は、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLYを返す&lt;/a&gt;場合があります。</target>
        </trans-unit>
        <trans-unit id="44bfd22dba6c2a0335c1b72cfe8865a0ed15325c" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_step() might return &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt; if</source>
          <target state="translated">sqlite3_backup_step（）は、&lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLYを返す&lt;/a&gt;場合があります。</target>
        </trans-unit>
        <trans-unit id="a2f8db9336dd78e8265a2d46cc59a9e446011dc7" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_* routines return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success or an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if anything goes wrong. &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; might be returned if the size of a string or BLOB exceeds limits imposed by &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;) or &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;. &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_RANGE&lt;/a&gt; is returned if the parameter index is out of range. &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; is returned if malloc() fails.</source>
          <target state="translated">sqlite3_bind_ *ルーチンは、成功すると&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;を返し、何か問題が&lt;a href=&quot;rescode&quot;&gt;発生した&lt;/a&gt;場合はエラーコードを返します。文字列またはBLOBのサイズが&lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;（&lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;）または&lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;によって課された制限を超える場合、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_TOOBIG&lt;/a&gt;が返されることがあります。パラメータインデックスが範囲外の場合、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_RANGE&lt;/a&gt;が返されます。&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;は、malloc（）が失敗した場合に返されます。</target>
        </trans-unit>
        <trans-unit id="eb0da7fe06be85118ba3dab99ff46185b6777bbe" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_* routines return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success or an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if anything goes wrong. &lt;a href=&quot;../rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; might be returned if the size of a string or BLOB exceeds limits imposed by &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;) or &lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;. &lt;a href=&quot;../rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt; is returned if the parameter index is out of range. &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; is returned if malloc() fails.</source>
          <target state="translated">sqlite3_bind_ *ルーチンは、成功すると&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;を返し、何か問題が&lt;a href=&quot;../rescode&quot;&gt;発生した&lt;/a&gt;場合はエラーコードを返します。文字列またはBLOBのサイズが&lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;（&lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;）または&lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;によって課された制限を超える場合、&lt;a href=&quot;../rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt;が返されることがあります。パラメータインデックスが範囲外の場合、&lt;a href=&quot;../rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt;が返されます。&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;は、malloc（）が失敗した場合に返されます。</target>
        </trans-unit>
        <trans-unit id="6f71713542739e9593b1adb467245384ef671786" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_parameter_name(P,N) interface returns the name of the N-th &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQL parameter&lt;/a&gt; in the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P. SQL parameters of the form &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; have a name which is the string &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; respectively. In other words, the initial &quot;:&quot; or &quot;$&quot; or &quot;@&quot; or &quot;?&quot; is included as part of the name. Parameters of the form &quot;?&quot; without a following integer have no name and are referred to as &quot;nameless&quot; or &quot;anonymous parameters&quot;.</source>
          <target state="translated">sqlite3_bind_parameter_name（P、N）インタフェースはN番目の名前を返す&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQLパラメータを&lt;/a&gt;して&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備された文&lt;/a&gt;「？NNN」の形のP. SQLパラメータまたは「：AAA」または「@AAA」または「$ AAAは」持っています文字列 &quot;？NNN&quot;または &quot;：AAA&quot;または &quot;@AAA&quot;または &quot;$ AAA&quot;である名前。つまり、最初の「：」または「$」または「@」または「？」名前の一部として含まれています。 「？」形式のパラメータ次の整数がない場合は名前がなく、「無名」または「匿名パラメーター」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="8f7478b82c93544aa582bd52cdb8be854dddfaed" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_parameter_name(P,N) interface returns the name of the N-th &lt;a href=&quot;bind_blob&quot;&gt;SQL parameter&lt;/a&gt; in the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P. SQL parameters of the form &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; have a name which is the string &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; respectively. In other words, the initial &quot;:&quot; or &quot;$&quot; or &quot;@&quot; or &quot;?&quot; is included as part of the name. Parameters of the form &quot;?&quot; without a following integer have no name and are referred to as &quot;nameless&quot; or &quot;anonymous parameters&quot;.</source>
          <target state="translated">sqlite3_bind_parameter_name（P、N）インタフェースはN番目の名前を返す&lt;a href=&quot;bind_blob&quot;&gt;SQLパラメータを&lt;/a&gt;して&lt;a href=&quot;stmt&quot;&gt;準備された文&lt;/a&gt;「？NNN」の形のP. SQLパラメータまたは「：AAA」または「@AAA」または「$ AAAは」持っています文字列 &quot;？NNN&quot;または &quot;：AAA&quot;または &quot;@AAA&quot;または &quot;$ AAA&quot;である名前。つまり、最初の「：」または「$」または「@」または「？」名前の一部として含まれています。 「？」形式のパラメータ次の整数がない場合は名前がなく、「無名」または「匿名パラメーター」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="2f7ba9ace88be98840180479bfcb11ff0ebe16ce" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_pointer(S,I,P,T,D) routine causes the I-th parameter in &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S to have an SQL value of NULL, but to also be associated with the pointer P of type T. D is either a NULL pointer or a pointer to a destructor function for P. SQLite will invoke the destructor D with a single argument of P when it is finished using P. The T parameter should be a static string, preferably a string literal. The sqlite3_bind_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_bind_pointer（S、I、P、T、D）ルーチンは、&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備されたステートメント&lt;/a&gt; S のI番目のパラメーターのSQL値をNULLにしますが、T型のポインターPにも関連付けます。DはNULL Pのデストラクタ関数へのポインタまたはポインタ。SQLiteは、Pの使用が終了すると、単一の引数PでデストラクタDを呼び出します。Tパラメータは、静的文字列、できれば文字列リテラルである必要があります。 sqlite3_bind_pointer（）ルーチンは、SQLite 3.20.0に追加された&lt;a href=&quot;bindptr&quot;&gt;ポインター受け渡しインターフェースの&lt;/a&gt;一部です。</target>
        </trans-unit>
        <trans-unit id="658c91c6c69fa0e297b2600c0a7ae1e8d41b306a" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_pointer(S,I,P,T,D) routine causes the I-th parameter in &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S to have an SQL value of NULL, but to also be associated with the pointer P of type T. D is either a NULL pointer or a pointer to a destructor function for P. SQLite will invoke the destructor D with a single argument of P when it is finished using P. The T parameter should be a static string, preferably a string literal. The sqlite3_bind_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_bind_pointer（S、I、P、T、D）ルーチンは、&lt;a href=&quot;stmt&quot;&gt;準備されたステートメント&lt;/a&gt; S のI番目のパラメーターのSQL値をNULLにしますが、T型のポインターPにも関連付けます。DはNULL Pのデストラクタ関数へのポインタまたはポインタ。SQLiteは、Pの使用が終了すると、単一の引数PでデストラクタDを呼び出します。Tパラメータは、静的文字列、できれば文字列リテラルである必要があります。 sqlite3_bind_pointer（）ルーチンは、SQLite 3.20.0に追加された&lt;a href=&quot;../bindptr&quot;&gt;ポインター受け渡しインターフェースの&lt;/a&gt;一部です。</target>
        </trans-unit>
        <trans-unit id="6397a7b2569f0831356316d22abee5d260da2f56" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_zeroblob() routine binds a BLOB of length N that is filled with zeroes. A zeroblob uses a fixed amount of memory (just an integer to hold its size) while it is being processed. Zeroblobs are intended to serve as placeholders for BLOBs whose content is later written using &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt; routines. A negative value for the zeroblob results in a zero-length BLOB.</source>
          <target state="translated">sqlite3_bind_zeroblob（）ルーチンは、ゼロで埋められた長さNのBLOBをバインドします。zeroblobは、処理中に一定量のメモリ（サイズを保持するための整数）を使用します。Zeroblobsは、後で&lt;a href=&quot;#sqlite3_blob_open&quot;&gt;インクリメンタルBLOB I / O&lt;/a&gt;ルーチンを使用してコンテンツが書き込まれるBLOBのプレースホルダーとして機能することを目的としています。zeroblobの負の値は、長さがゼロのBLOBになります。</target>
        </trans-unit>
        <trans-unit id="c43ef2df76e0304e4b4beb3c8e7c5dbefc82b96b" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_zeroblob() routine binds a BLOB of length N that is filled with zeroes. A zeroblob uses a fixed amount of memory (just an integer to hold its size) while it is being processed. Zeroblobs are intended to serve as placeholders for BLOBs whose content is later written using &lt;a href=&quot;blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt; routines. A negative value for the zeroblob results in a zero-length BLOB.</source>
          <target state="translated">sqlite3_bind_zeroblob（）ルーチンは、ゼロで埋められた長さNのBLOBをバインドします。zeroblobは、処理中に一定量のメモリ（サイズを保持するための整数）を使用します。Zeroblobsは、後で&lt;a href=&quot;blob_open&quot;&gt;インクリメンタルBLOB I / O&lt;/a&gt;ルーチンを使用してコンテンツが書き込まれるBLOBのプレースホルダーとして機能することを目的としています。zeroblobの負の値は、長さがゼロのBLOBになります。</target>
        </trans-unit>
        <trans-unit id="3d2cce49ac08682bc109d88559efafcb5bc906c9" translate="yes" xml:space="preserve">
          <source>The sqlite3_busy_handler(D,X,P) routine sets a callback function X that might be invoked with argument P whenever an attempt is made to access a database table associated with &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D when another thread or process has the table locked. The sqlite3_busy_handler() interface is used to implement &lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;.</source>
          <target state="translated">sqlite3_busy_handler（D、X、P）ルーチンは、別のスレッドまたはプロセスでテーブルがロックされているときに、&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt; Dに関連付けられているデータベーステーブルにアクセスしようとすると、引数Pで呼び出されるコールバック関数Xを設定します。sqlite3_busy_handler（）インターフェースは&lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt;と&lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;を実装するために使用されます。</target>
        </trans-unit>
        <trans-unit id="d3363e5f93709d191e40f4d06f477acdab0e375e" translate="yes" xml:space="preserve">
          <source>The sqlite3_busy_handler(D,X,P) routine sets a callback function X that might be invoked with argument P whenever an attempt is made to access a database table associated with &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D when another thread or process has the table locked. The sqlite3_busy_handler() interface is used to implement &lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; and &lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;.</source>
          <target state="translated">sqlite3_busy_handler（D、X、P）ルーチンは、別のスレッドまたはプロセスでテーブルがロックされているときに、&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt; Dに関連付けられているデータベーステーブルにアクセスしようとすると、引数Pで呼び出されるコールバック関数Xを設定します。sqlite3_busy_handler（）インターフェースは&lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt;と&lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;を実装するために使用されます。</target>
        </trans-unit>
        <trans-unit id="e8d93853c1f8ff5d06942fd5a08d82650ba96772" translate="yes" xml:space="preserve">
          <source>The sqlite3_close() and sqlite3_close_v2() routines are destructors for the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object. Calls to sqlite3_close() and sqlite3_close_v2() return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is successfully destroyed and all associated resources are deallocated.</source>
          <target state="translated">sqlite3_close（）とsqlite3_close_v2（）ルーチンは、&lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt;オブジェクトのデストラクタです。 sqlite3_closeの呼び出し（）およびsqlite3_close_v2（）の戻り&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;場合は&lt;a href=&quot;#sqlite3&quot;&gt;sqlite3の&lt;/a&gt;オブジェクトが正常に破壊され、関連するすべてのリソースの割り当てが解除されています。</target>
        </trans-unit>
        <trans-unit id="c3b661e4a47ed928f3b7e88dd929f7831fe5385b" translate="yes" xml:space="preserve">
          <source>The sqlite3_close() and sqlite3_close_v2() routines are destructors for the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object. Calls to sqlite3_close() and sqlite3_close_v2() return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is successfully destroyed and all associated resources are deallocated.</source>
          <target state="translated">sqlite3_close（）とsqlite3_close_v2（）ルーチンは、&lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt;オブジェクトのデストラクタです。 sqlite3_closeの呼び出し（）およびsqlite3_close_v2（）の戻り&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;場合は&lt;a href=&quot;sqlite3&quot;&gt;sqlite3の&lt;/a&gt;オブジェクトが正常に破壊され、関連するすべてのリソースの割り当てが解除されています。</target>
        </trans-unit>
        <trans-unit id="2e35c3e04c8fe7269b95a0494cefdd5cde7acf02" translate="yes" xml:space="preserve">
          <source>The sqlite3_collation_needed() routine registers a callback which the database engine will invoke if it encounters an unknown collating sequence. The callback can lookup an appropriate comparison function and invoke sqlite_3_create_collation() as needed. The fourth parameter to the callback is the name of the collating sequence in UTF-8. For sqlite3_collation_need16() the callback sends the collating sequence name in UTF-16 host byte order.</source>
          <target state="translated">sqlite3_collation_needed()ルーチンは、未知の照合順序に遭遇した場合にデータベースエンジンが呼び出すコールバックを登録します。コールバックは適切な比較関数を検索し、必要に応じてsqlite_3_create_collation()を呼び出すことができます。コールバックの4番目のパラメータはUTF-8での照合シーケンスの名前です。sqlite3_collation_need16()では、コールバックは照合シーケンス名をUTF-16ホストバイト順で送信します。</target>
        </trans-unit>
        <trans-unit id="289668a545984e8fa7c4b426fa20f850363028a3" translate="yes" xml:space="preserve">
          <source>The sqlite3_column_decltype() routine returns text which is the declared type of the column in the CREATE TABLE statement. For an expression, the return type is an empty string. sqlite3_column_name() returns the name of the Nth column. sqlite3_column_bytes() returns the number of bytes in a column that has type BLOB or the number of bytes in a TEXT string with UTF-8 encoding. sqlite3_column_bytes16() returns the same value for BLOBs but for TEXT strings returns the number of bytes in a UTF-16 encoding. sqlite3_column_blob() return BLOB data. sqlite3_column_text() return TEXT data as UTF-8. sqlite3_column_text16() return TEXT data as UTF-16. sqlite3_column_int() return INTEGER data in the host machines native integer format. sqlite3_column_int64() returns 64-bit INTEGER data. Finally, sqlite3_column_double() return floating point data.</source>
          <target state="translated">sqlite3_column_decltype()ルーチンはCREATE TABLE文で宣言されたカラムの型であるテキストを返します。sqlite3_column_bytes()はBLOB型のカラムのバイト数、またはUTF-8エンコーディングのTEXT文字列のバイト数を返します。 sqlite3_column_bytes16()はBLOBに対しては同じ値を返しますが、TEXT文字列に対してはUTF-16エンコーディングのバイト数を返します。sqlite3_column_blob()BLOBデータを返します。 sqlite3_column_text()TEXTデータをUTF-8で返します。 sqlite3_column_text16()TEXTデータをUTF-16で返します。 sqlite3_column_int()INTEGERデータをホストマシンのネイティブ整数形式で返します。最後に、sqlite3_column_double()は浮動小数点データを返します。</target>
        </trans-unit>
        <trans-unit id="a9b38d21f857b4d104b01ccf828564edcab9302b" translate="yes" xml:space="preserve">
          <source>The sqlite3_column_type() routine returns the &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;datatype code&lt;/a&gt; for the initial data type of the result column. The returned value is one of &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULL&lt;/a&gt;. The return value of sqlite3_column_type() can be used to decide which of the first six interface should be used to extract the column value. The value returned by sqlite3_column_type() is only meaningful if no automatic type conversions have occurred for the value in question. After a type conversion, the result of calling sqlite3_column_type() is undefined, though harmless. Future versions of SQLite may change the behavior of sqlite3_column_type() following a type conversion.</source>
          <target state="translated">sqlite3_column_type（）ルーチンは、結果列の初期データ型のデータ型&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;コード&lt;/a&gt;を返します。戻り値は、&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt;、&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt;、&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt;、&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt;、または&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULLの&lt;/a&gt;いずれかです。 sqlite3_column_type（）の戻り値を使用して、最初の6つのインターフェースのどれを使用して列の値を抽出するかを決定できます。 sqlite3_column_type（）によって返される値は、問題の値の自動型変換が発生していない場合にのみ意味があります。型変換後のsqlite3_column_type（）の呼び出し結果は、害はありませんが未定義です。 SQLiteの将来のバージョンでは、型変換後にsqlite3_column_type（）の動作が変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="d87c623fe2ec1f08f5218d69ec07d1b6f1fe406e" translate="yes" xml:space="preserve">
          <source>The sqlite3_column_type() routine returns the &lt;a href=&quot;c_blob&quot;&gt;datatype code&lt;/a&gt; for the initial data type of the result column. The returned value is one of &lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULL&lt;/a&gt;. The return value of sqlite3_column_type() can be used to decide which of the first six interface should be used to extract the column value. The value returned by sqlite3_column_type() is only meaningful if no automatic type conversions have occurred for the value in question. After a type conversion, the result of calling sqlite3_column_type() is undefined, though harmless. Future versions of SQLite may change the behavior of sqlite3_column_type() following a type conversion.</source>
          <target state="translated">sqlite3_column_type（）ルーチンは、結果列の初期データ型のデータ型&lt;a href=&quot;c_blob&quot;&gt;コード&lt;/a&gt;を返します。戻り値は、&lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt;、&lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt;、&lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt;、&lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt;、または&lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULLの&lt;/a&gt;いずれかです。 sqlite3_column_type（）の戻り値を使用して、最初の6つのインターフェースのどれを使用して列の値を抽出するかを決定できます。 sqlite3_column_type（）によって返される値は、問題の値の自動型変換が発生していない場合にのみ意味があります。型変換後のsqlite3_column_type（）の呼び出し結果は、害はありませんが未定義です。 SQLiteの将来のバージョンでは、型変換後にsqlite3_column_type（）の動作が変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="80c9429e83e0f6600057106ffc072b05d6e8df14" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;../lang_transaction&quot;&gt;committed&lt;/a&gt;. Any callback set by a previous call to sqlite3_commit_hook() for the same database connection is overridden. The sqlite3_rollback_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;../lang_transaction&quot;&gt;rolled back&lt;/a&gt;. Any callback set by a previous call to sqlite3_rollback_hook() for the same database connection is overridden. The pArg argument is passed through to the callback. If the callback on a commit hook function returns non-zero, then the commit is converted into a rollback.</source>
          <target state="translated">sqlite3_commit_hook（）インターフェースは、トランザクションが&lt;a href=&quot;../lang_transaction&quot;&gt;コミット&lt;/a&gt;されるたびに呼び出されるコールバック関数を登録します。同じデータベース接続に対するsqlite3_commit_hook（）への以前の呼び出しによって設定されたコールバックはすべてオーバーライドされます。 sqlite3_rollback_hook（）インターフェースは、トランザクションが&lt;a href=&quot;../lang_transaction&quot;&gt;ロールバック&lt;/a&gt;されるたびに呼び出されるコールバック関数を登録します。同じデータベース接続のsqlite3_rollback_hook（）への以前の呼び出しによって設定されたコールバックは上書きされます。 pArg引数はコールバックに渡されます。コミットフック関数のコールバックがゼロ以外を返す場合、コミットはロールバックに変換されます。</target>
        </trans-unit>
        <trans-unit id="c831f98581f1e28276e947cc54e55e8093cff2bf" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;lang_transaction&quot;&gt;committed&lt;/a&gt;. Any callback set by a previous call to sqlite3_commit_hook() for the same database connection is overridden. The sqlite3_rollback_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;lang_transaction&quot;&gt;rolled back&lt;/a&gt;. Any callback set by a previous call to sqlite3_rollback_hook() for the same database connection is overridden. The pArg argument is passed through to the callback. If the callback on a commit hook function returns non-zero, then the commit is converted into a rollback.</source>
          <target state="translated">sqlite3_commit_hook（）インターフェースは、トランザクションが&lt;a href=&quot;lang_transaction&quot;&gt;コミット&lt;/a&gt;されるたびに呼び出されるコールバック関数を登録します。同じデータベース接続に対するsqlite3_commit_hook（）への以前の呼び出しによって設定されたコールバックはすべてオーバーライドされます。 sqlite3_rollback_hook（）インターフェースは、トランザクションが&lt;a href=&quot;lang_transaction&quot;&gt;ロールバック&lt;/a&gt;されるたびに呼び出されるコールバック関数を登録します。同じデータベース接続のsqlite3_rollback_hook（）への以前の呼び出しによって設定されたコールバックは上書きされます。 pArg引数はコールバックに渡されます。コミットフック関数のコールバックがゼロ以外を返す場合、コミットはロールバックに変換されます。</target>
        </trans-unit>
        <trans-unit id="8ed0ff1b29d3e198ebfc7c54c6d04128fb45e5b9" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook(D,C,P) and sqlite3_rollback_hook(D,C,P) functions return the P argument from the previous call of the same function on the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call for each function on D.</source>
          <target state="translated">sqlite3_commit_hook（D、C、P）およびsqlite3_rollback_hook（D、C、P）関数は、同じ&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt; D での同じ関数の前の呼び出しからのP引数、またはDの各関数の最初の呼び出しではNULLを返します。</target>
        </trans-unit>
        <trans-unit id="5c814d040fa0b2376c6a44e987d8d06f8d405641" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook(D,C,P) and sqlite3_rollback_hook(D,C,P) functions return the P argument from the previous call of the same function on the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call for each function on D.</source>
          <target state="translated">sqlite3_commit_hook（D、C、P）およびsqlite3_rollback_hook（D、C、P）関数は、同じ&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt; D での同じ関数の前の呼び出しからのP引数、またはDの各関数の最初の呼び出しではNULLを返します。</target>
        </trans-unit>
        <trans-unit id="a783ef29506da5187d0b6a8b529c5db8a199c982" translate="yes" xml:space="preserve">
          <source>The sqlite3_compileoption_get() function allows iterating over the list of options that were defined at compile time by returning the N-th compile time option string. If N is out of range, sqlite3_compileoption_get() returns a NULL pointer. The SQLITE_ prefix is omitted from any strings returned by sqlite3_compileoption_get().</source>
          <target state="translated">sqlite3_compileoption_get()関数は、N番目のコンパイル時オプション文字列を返すことで、コンパイル時に定義されたオプションのリストを反復処理することができます。Nが範囲外の場合、sqlite3_compileoption_get()はNULLポインタを返します。sqlite3_compileoption_get()が返す文字列からはSQLITE_接頭辞は省略されます。</target>
        </trans-unit>
        <trans-unit id="39c27e864f7c32b9ceed46ceee3feba79ed9e6fc" translate="yes" xml:space="preserve">
          <source>The sqlite3_compileoption_used() function returns 0 or 1 indicating whether the specified option was defined at compile time. The SQLITE_ prefix may be omitted from the option name passed to sqlite3_compileoption_used().</source>
          <target state="translated">sqlite3_compileoption_used()関数は、指定されたオプションがコンパイル時に定義されていたかどうかを示す0または1を返します。sqlite3_compileoption_used()に渡されるオプション名には、SQLITE_接頭辞を省略することができます。</target>
        </trans-unit>
        <trans-unit id="c2f7b71d769d28cabe75800e2f0fc786a0e3ca05" translate="yes" xml:space="preserve">
          <source>The sqlite3_config() interface is used to make global configuration changes to SQLite in order to tune SQLite to the specific needs of the application. The default configuration is recommended for most applications and so this routine is usually not necessary. It is provided to support rare applications with unusual needs.</source>
          <target state="translated">sqlite3_config()インターフェイスは、アプリケーションの特定のニーズに合わせてSQLiteを調整するために、SQLiteのグローバルな設定を変更するために使用されます。ほとんどのアプリケーションではデフォルトの設定が推奨されているので、このルーチンは通常必要ありません。これは、特別なニーズを持つ稀なアプリケーションをサポートするために提供されています。</target>
        </trans-unit>
        <trans-unit id="2a43551c13014713b84ff3176d603e20a0bb2d0e" translate="yes" xml:space="preserve">
          <source>The sqlite3_config() interface may only be invoked prior to library initialization using &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; or after shutdown by &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. If sqlite3_config() is called after &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; and before &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; then it will return SQLITE_MISUSE. Note, however, that sqlite3_config() can be called as part of the implementation of an application-defined &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_config（）インターフェースは、&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;を使用したライブラリの初期化前、または&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;によるシャットダウン後にのみ呼び出すことができます。sqlite3_config（）の後に呼び出された場合&lt;a href=&quot;#sqlite3_initialize&quot;&gt;（sqlite3_initialize）&lt;/a&gt;と前&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown（） &lt;/a&gt;、それはSQLITE_MISUSEを返します。ただし、sqlite3_config（）は、アプリケーション定義の&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_os_init（）の&lt;/a&gt;実装の一部として呼び出すことができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="950f596cd61399b38213d68d8e3371f1294cd97c" translate="yes" xml:space="preserve">
          <source>The sqlite3_config() interface may only be invoked prior to library initialization using &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; or after shutdown by &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. If sqlite3_config() is called after &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; and before &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; then it will return SQLITE_MISUSE. Note, however, that sqlite3_config() can be called as part of the implementation of an application-defined &lt;a href=&quot;initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_config（）インターフェースは、&lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;を使用したライブラリの初期化前、または&lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;によるシャットダウン後にのみ呼び出すことができます。sqlite3_config（）の後に呼び出された場合&lt;a href=&quot;initialize&quot;&gt;（sqlite3_initialize）&lt;/a&gt;と前&lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown（） &lt;/a&gt;、それはSQLITE_MISUSEを返します。ただし、sqlite3_config（）は、アプリケーション定義の&lt;a href=&quot;initialize&quot;&gt;sqlite3_os_init（）の&lt;/a&gt;実装の一部として呼び出すことができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f36e7397009cd60c7259be5a8cbdeb80264ff811" translate="yes" xml:space="preserve">
          <source>The sqlite3_context_db_handle() interface returns a copy of the pointer to the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; (the 1st parameter) of the &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">sqlite3_context_db_handle（）インターフェースは、最初にアプリケーションで定義された関数を登録した&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;と&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;ルーチンの&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;（1番目のパラメーター）へのポインターのコピーを返します。</target>
        </trans-unit>
        <trans-unit id="04b3afa93b5033ef2c02acd3a1ef18374b3a066e" translate="yes" xml:space="preserve">
          <source>The sqlite3_context_db_handle() interface returns a copy of the pointer to the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; (the 1st parameter) of the &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">sqlite3_context_db_handle（）インターフェースは、最初にアプリケーションで定義された関数を登録した&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;と&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;ルーチンの&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;（1番目のパラメーター）へのポインターのコピーを返します。</target>
        </trans-unit>
        <trans-unit id="0b0f49ec423453d8567eeff6ab2f843591a04245" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation() function honors the SQLITE_UTF16_ALIGNED flag.</source>
          <target state="translated">sqlite3_create_collation()関数はSQLITE_UTF16_ALIGNEDフラグを保持します。</target>
        </trans-unit>
        <trans-unit id="0e46987511170cbb4e8e90d14cfd9fe052087146" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation() function specifies a collating sequence name and a comparison function to implement that collating sequence. The comparison function is only used for comparing text values. The eTextRep parameter is one of SQLITE_UTF8, SQLITE_UTF16LE, SQLITE_UTF16BE, or SQLITE_ANY to specify which text representation the comparison function works with. Separate comparison functions can exist for the same collating sequence for each of the UTF-8, UTF-16LE and UTF-16BE text representations. The sqlite3_create_collation16() works like sqlite3_create_collation() except that the collation name is specified in UTF-16 host byte order instead of in UTF-8.</source>
          <target state="translated">sqlite3_create_collation()関数は照合順序名と、その照合順序を実装するための比較関数を指定します。比較関数はテキスト値の比較にのみ使用されます。eTextRepパラメータはSQLITE_UTF8、SQLITE_UTF16LE、SQLITE_UTF16BE、またはSQLITE_ANYのいずれかで、比較関数がどのテキスト表現で動作するかを指定します。UTF-8、UTF-16LE、UTF-16BEの各テキスト表現に対して、同じ照合順序に対して別々の比較関数が存在することができます。sqlite3_create_collation16()はsqlite3_create_collation()と同じように動作しますが、照合名がUTF-8ではなくUTF-16ホストバイト順で指定されます。</target>
        </trans-unit>
        <trans-unit id="3bb1bc030c0ecaf171e6e7837d4fc5ad509b9304" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation_v2() works like sqlite3_create_collation() with the addition that the xDestroy callback is invoked on pArg when the collating function is deleted. Collating functions are deleted when they are overridden by later calls to the collation creation functions or when the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is closed using &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_create_collat​​ion_v2（）はsqlite3_create_collat​​ion（）と同様に機能し、照合機能が削除されたときにxDestroyコールバックがpArgで呼び出される点が異なります。照合関数は、後で照合作成関数の呼び出しによってオーバーライドされたとき、または&lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close（）&lt;/a&gt;を使用して&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;が閉じられたときに削除されます。</target>
        </trans-unit>
        <trans-unit id="cce8a06023084f98541458166466b478b68c97fc" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation_v2() works like sqlite3_create_collation() with the addition that the xDestroy callback is invoked on pArg when the collating function is deleted. Collating functions are deleted when they are overridden by later calls to the collation creation functions or when the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is closed using &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_create_collat​​ion_v2（）はsqlite3_create_collat​​ion（）と同様に機能し、照合機能が削除されたときにxDestroyコールバックがpArgで呼び出される点が異なります。照合関数は、後で照合作成関数の呼び出しによってオーバーライドされたとき、または&lt;a href=&quot;close&quot;&gt;sqlite3_close（）&lt;/a&gt;を使用して&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;が閉じられたときに削除されます。</target>
        </trans-unit>
        <trans-unit id="35eaa1fdb7403d0bf2c872e0985b90cb08324f23" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_filename(D,J,W,N,P) allocates memory to hold a version of database filename D with corresponding journal file J and WAL file W and with N URI parameters key/values pairs in the array P. The result from sqlite3_create_filename(D,J,W,N,P) is a pointer to a database filename that is safe to pass to routines like:</source>
          <target state="translated">sqlite3_create_filename(D,J,W,N,P)は、対応するジャーナルファイルJとWALファイルWを持つデータベースファイル名Dのバージョンを保持するためのメモリを確保します。</target>
        </trans-unit>
        <trans-unit id="2321a78d45e7f791f5be9bd5eeeecdd73b61cbff" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_module_v2() interface has a fifth parameter which is a pointer to a destructor for the pClientData. SQLite will invoke the destructor function (if it is not NULL) when SQLite no longer needs the pClientData pointer. The destructor will also be invoked if the call to sqlite3_create_module_v2() fails. The sqlite3_create_module() interface is equivalent to sqlite3_create_module_v2() with a NULL destructor.</source>
          <target state="translated">sqlite3_create_module_v2()インタフェースには5番目のパラメータがあり、これはpClientDataのデストラクタへのポインタです。SQLiteは、SQLiteがpClientDataポインタを必要としなくなったときに、(NULLでなければ)デストラクタ関数を呼び出します。デストラクタは、sqlite3_create_module_v2()の呼び出しが失敗した場合にも呼び出されます。sqlite3_create_module()インターフェースは sqlite3_create_module_v2()と同じで、デストラクタは NULL です。</target>
        </trans-unit>
        <trans-unit id="ce43917c89192dc7d4a31aeaa86afac14bcedebc" translate="yes" xml:space="preserve">
          <source>The sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P. If prepared statement P does not have results ready to return (via calls to the &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; family of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;. The sqlite3_data_count(P) will return non-zero if previous call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;, except in the case of the &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; where it always returns zero since each step of that multi-step pragma returns 0 columns of data.</source>
          <target state="translated">sqlite3_data_count（P）インターフェースは、&lt;a href=&quot;#sqlite3_stmt&quot;&gt;プリペアドステートメント&lt;/a&gt;Pの結果セットの現在の行の列数を返します。プリペアドステートメントPに（&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column（）&lt;/a&gt;ファミリーのインターフェースの呼び出しを介して）返す準備ができている結果がない場合、sqlite3_data_count（ P）は0を返します。PがNULLポインターの場合、sqlite3_data_count（P）ルーチンも0を返します。 sqlite3_data_count（P）リターン0の前の呼び出し場合&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;（P）が返さ&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONEを&lt;/a&gt;。&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMAのincrement_vacuumの&lt;/a&gt;場合を除いて、&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;（P）への前回の呼び出しでSQLITE_ROWが返された場合、sqlite3_data_count（P）は&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;ゼロ&lt;/a&gt;以外を返します。ここで、そのマルチステッププラグマの各ステップは0列のデータを返すため、常にゼロを返します。</target>
        </trans-unit>
        <trans-unit id="b23578428cca6b0b7cc9f351266849d54d3f4ac7" translate="yes" xml:space="preserve">
          <source>The sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P. If prepared statement P does not have results ready to return (via calls to the &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_*()&lt;/a&gt; of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;. The sqlite3_data_count(P) will return non-zero if previous call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;, except in the case of the &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; where it always returns zero since each step of that multi-step pragma returns 0 columns of data.</source>
          <target state="translated">sqlite3_data_count（P）インターフェイスは、&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備されたステートメント&lt;/a&gt; Pの結果セットの現在の行の列数を返します。準備されたステートメントPが返す準備ができていない場合&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;（&lt;/a&gt;インターフェイスのsqlite3_column _ *（）を呼び出して）、sqlite3_data_count（ P）は0を返します。sqlite3_data_count（P）ルーチンは、PがNULLポインターの場合も0を返します。 sqlite3_data_count（P）リターン0の前の呼び出し場合&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;（P）が返さ&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONEを&lt;/a&gt;。&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuumの&lt;/a&gt;場合を除いて、&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;（P）への以前の呼び出しがSQLITE_ROWを返した場合、sqlite3_data_count（P）は&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;ゼロ&lt;/a&gt;以外を返します。このマルチステッププラグマの各ステップは0列のデータを返すため、常にゼロを返します。</target>
        </trans-unit>
        <trans-unit id="f5791b68b76b19a4a15dafbc0a31b6f189b8fc89" translate="yes" xml:space="preserve">
          <source>The sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P. If prepared statement P does not have results ready to return (via calls to the &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; family of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;. The sqlite3_data_count(P) will return non-zero if previous call to &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, except in the case of the &lt;a href=&quot;../pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; where it always returns zero since each step of that multi-step pragma returns 0 columns of data.</source>
          <target state="translated">sqlite3_data_count（P）インターフェースは、&lt;a href=&quot;stmt&quot;&gt;プリペアドステートメント&lt;/a&gt;Pの結果セットの現在の行の列数を返します。プリペアドステートメントPに（&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column（）&lt;/a&gt;ファミリーのインターフェースの呼び出しを介して）返す準備ができている結果がない場合、sqlite3_data_count（ P）は0を返します。PがNULLポインターの場合、sqlite3_data_count（P）ルーチンも0を返します。 sqlite3_data_count（P）リターン0の前の呼び出し場合&lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;（P）が返さ&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONEを&lt;/a&gt;。&lt;a href=&quot;../pragma#pragma_incremental_vacuum&quot;&gt;PRAGMAのincrement_vacuumの&lt;/a&gt;場合を除いて、&lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;（P）への前回の呼び出しでSQLITE_ROWが返された場合、sqlite3_data_count（P）は&lt;a href=&quot;../rescode#row&quot;&gt;ゼロ&lt;/a&gt;以外を返します。ここで、そのマルチステッププラグマの各ステップは0列のデータを返すため、常にゼロを返します。</target>
        </trans-unit>
        <trans-unit id="0331c5159620074031eabe2d2fffeb3879925815" translate="yes" xml:space="preserve">
          <source>The sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P. If prepared statement P does not have results ready to return (via calls to the &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_*()&lt;/a&gt; of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;. The sqlite3_data_count(P) will return non-zero if previous call to &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, except in the case of the &lt;a href=&quot;../pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; where it always returns zero since each step of that multi-step pragma returns 0 columns of data.</source>
          <target state="translated">sqlite3_data_count（P）インターフェイスは、&lt;a href=&quot;stmt&quot;&gt;準備されたステートメント&lt;/a&gt; Pの結果セットの現在の行の列数を返します。準備されたステートメントPが返す準備ができていない場合&lt;a href=&quot;column_blob&quot;&gt;（&lt;/a&gt;インターフェイスのsqlite3_column _ *（）を呼び出して）、sqlite3_data_count（ P）は0を返します。sqlite3_data_count（P）ルーチンは、PがNULLポインターの場合も0を返します。 sqlite3_data_count（P）リターン0の前の呼び出し場合&lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;（P）が返さ&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONEを&lt;/a&gt;。&lt;a href=&quot;../pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuumの&lt;/a&gt;場合を除いて、&lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;（P）への以前の呼び出しがSQLITE_ROWを返した場合、sqlite3_data_count（P）は&lt;a href=&quot;../rescode#row&quot;&gt;ゼロ&lt;/a&gt;以外を返します。このマルチステッププラグマの各ステップは0列のデータを返すため、常にゼロを返します。</target>
        </trans-unit>
        <trans-unit id="043836a9d52018cfd95036ef1de8601c0dd65b27" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_config() interface is used to make configuration changes to a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;. The interface is similar to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; except that the changes apply to a single &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; (specified in the first argument).</source>
          <target state="translated">sqlite3_db_config（）インターフェースは、&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続の&lt;/a&gt;構成を変更するために使用されます。インターフェイスは&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）に&lt;/a&gt;似ていますが、変更が単一の&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;（最初の引数で指定）に適用される点が異なります。</target>
        </trans-unit>
        <trans-unit id="cb382b8043f6bd41fb4e955562ae2dd8de8821a6" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_config() interface is used to make configuration changes to a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;. The interface is similar to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; except that the changes apply to a single &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; (specified in the first argument).</source>
          <target state="translated">sqlite3_db_config（）インターフェースは、&lt;a href=&quot;sqlite3&quot;&gt;データベース接続の&lt;/a&gt;構成を変更するために使用されます。インターフェイスは&lt;a href=&quot;config&quot;&gt;sqlite3_config（）に&lt;/a&gt;似ていますが、変更が単一の&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;（最初の引数で指定）に適用される点が異なります。</target>
        </trans-unit>
        <trans-unit id="d9890e9099b39efa9f23ed1209f98fc2abd695d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_filename(D,N) interface returns a pointer to a filename associated with database N of connection D. The main database file has the name &quot;main&quot;. If there is no attached database N on the database connection D, or if database N is a temporary or in-memory database, then this function will return either a NULL pointer or an empty string.</source>
          <target state="translated">sqlite3_db_filename(D,N)インタフェースは、接続DのデータベースNに関連付けられたファイル名へのポインタを返します。データベース接続DにアタッチされたデータベースNが存在しない場合、またはデータベースNが一時データベースまたはインメモリデータベースである場合、この関数はNULLポインタか空文字列を返します。</target>
        </trans-unit>
        <trans-unit id="6ce559d2134cd8f80b32424d9cafa088f3f1de6d" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_filename(D,N) interface returns a pointer to the filename associated with database N of connection D. If there is no attached database N on the database connection D, or if database N is a temporary or in-memory database, then this function will return either a NULL pointer or an empty string.</source>
          <target state="translated">sqlite3_db_filename(D,N)インタフェースは接続DのデータベースNに関連付けられたファイル名へのポインタを返します。 データベース接続D上にデータベースNが接続されていない場合、またはデータベースNが一時的またはインメモリデータベースの場合、この関数はNULLポインタか空の文字列を返します。</target>
        </trans-unit>
        <trans-unit id="7a0142f7765d452e556a6d1ade538189bbf023a1" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_handle interface returns the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; handle to which a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; belongs. The &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; returned by sqlite3_db_handle is the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that was the first argument to the &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; call (or its variants) that was used to create the statement in the first place.</source>
          <target state="translated">sqlite3_db_handleインターフェースは、&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備されたステートメントが&lt;/a&gt;属する&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;ハンドルを返します。&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt; sqlite3_db_handleで返さは同じである&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;の最初の引数た&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;最初の場所でのステートメントを作成するために使用されたコール（またはその変種）。</target>
        </trans-unit>
        <trans-unit id="0ed4944069eec7d7c0e7904b6909ffc71d6a37af" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_handle interface returns the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; handle to which a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; belongs. The &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; returned by sqlite3_db_handle is the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that was the first argument to the &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; call (or its variants) that was used to create the statement in the first place.</source>
          <target state="translated">sqlite3_db_handleインターフェースは、&lt;a href=&quot;stmt&quot;&gt;準備されたステートメントが&lt;/a&gt;属する&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;ハンドルを返します。&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt; sqlite3_db_handleで返さは同じである&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;の最初の引数た&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;最初の場所でのステートメントを作成するために使用されたコール（またはその変種）。</target>
        </trans-unit>
        <trans-unit id="f13e3d008759351c9d014a67b0c7d66c909c38ed" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_readonly(D,N) interface returns 1 if the database N of connection D is read-only, 0 if it is read/write, or -1 if N is not the name of a database on connection D.</source>
          <target state="translated">sqlite3_db_readonly(D,N)インタフェースは、接続DのデータベースNが読み取り専用であれば1を、読み取り/書き込みであれば0を、Nが接続Dのデータベース名でなければ-1を返します。</target>
        </trans-unit>
        <trans-unit id="7c54e0312a49676acc8e0fa5a98fa6c3ca389049" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_release_memory(D) interface attempts to free as much heap memory as possible from database connection D. Unlike the &lt;a href=&quot;#sqlite3_release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; interface, this interface is in effect even when the &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option is omitted.</source>
          <target state="translated">sqlite3_db_release_memory（D）インターフェイスは、データベース接続Dから可能な限り多くのヒープメモリを解放しようとします&lt;a href=&quot;#sqlite3_release_memory&quot;&gt;。sqlite3_release_memory（）&lt;/a&gt;インターフェイスとは異なり、このインターフェイスは、&lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;コンパイル時オプションが省略されている場合でも有効です。</target>
        </trans-unit>
        <trans-unit id="a4505b330dae36966abd878a7a5251bb10a809a6" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_release_memory(D) interface attempts to free as much heap memory as possible from database connection D. Unlike the &lt;a href=&quot;release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; interface, this interface is in effect even when the &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option is omitted.</source>
          <target state="translated">sqlite3_db_release_memory（D）インターフェイスは、データベース接続Dから可能な限り多くのヒープメモリを解放しようとします&lt;a href=&quot;release_memory&quot;&gt;。sqlite3_release_memory（）&lt;/a&gt;インターフェイスとは異なり、このインターフェイスは、&lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;コンパイル時オプションが省略されている場合でも有効です。</target>
        </trans-unit>
        <trans-unit id="83634ce6a2d174966fca0f07d2eb6e5e52439e9f" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_status() routine returns SQLITE_OK on success and a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">sqlite3_db_status（）ルーチンは、成功するとSQLITE_OKを返し、失敗するとゼロ以外の&lt;a href=&quot;../rescode&quot;&gt;エラーコード&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="7babdc84886f95b16b07a064461180aa8e231247" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_status() routine returns SQLITE_OK on success and a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">sqlite3_db_status（）ルーチンは、成功するとSQLITE_OKを返し、失敗するとゼロ以外の&lt;a href=&quot;rescode&quot;&gt;エラーコード&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="18d47ae58f8b29dbac7701bb014dc19e22eadf62" translate="yes" xml:space="preserve">
          <source>The sqlite3_deserialize() interface will fail with SQLITE_BUSY if the database is currently in a read transaction or is involved in a backup operation.</source>
          <target state="translated">sqlite3_deserialize()インターフェイスは、データベースが現在リードトランザクションにあるか、バックアップ操作に関与している場合、SQLITE_BUSYで失敗します。</target>
        </trans-unit>
        <trans-unit id="12340c8333dc6a82eca44a1f4c8bbf0434fac375" translate="yes" xml:space="preserve">
          <source>The sqlite3_deserialize(D,S,P,N,M,F) interface causes the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D to disconnect from database S and then reopen S as an in-memory database based on the serialization contained in P. The serialized database P is N bytes in size. M is the size of the buffer P, which might be larger than N. If M is larger than N, and the SQLITE_DESERIALIZE_READONLY bit is not set in F, then SQLite is permitted to add content to the in-memory database as long as the total size does not exceed M bytes.</source>
          <target state="translated">sqlite3_deserialize（D、S、P、N、M、F）インターフェイスは、&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt; DをデータベースSから切断し、Pに含まれるシリアル化に基づいてSをメモリ内データベースとして再度開きます。シリアル化されたデータベースPはNサイズのバイト。MはバッファPのサイズで、Nより大きくなる可能性があります。MがNより大きく、SQLITE_DESERIALIZE_READONLYビットがFに設定されていない場合、SQLiteは、メモリ内データベースにコンテンツを追加できます。合計サイズはMバイトを超えません。</target>
        </trans-unit>
        <trans-unit id="afac5ec67e0561a540471ae51b94788f3734ed79" translate="yes" xml:space="preserve">
          <source>The sqlite3_deserialize(D,S,P,N,M,F) interface causes the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D to disconnect from database S and then reopen S as an in-memory database based on the serialization contained in P. The serialized database P is N bytes in size. M is the size of the buffer P, which might be larger than N. If M is larger than N, and the SQLITE_DESERIALIZE_READONLY bit is not set in F, then SQLite is permitted to add content to the in-memory database as long as the total size does not exceed M bytes.</source>
          <target state="translated">sqlite3_deserialize（D、S、P、N、M、F）インターフェイスは、&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt; DをデータベースSから切断し、Pに含まれるシリアル化に基づいてSをメモリ内データベースとして再度開きます。シリアル化されたデータベースPはNサイズのバイト。MはバッファPのサイズで、Nより大きくなる可能性があります。MがNより大きく、SQLITE_DESERIALIZE_READONLYビットがFに設定されていない場合、SQLiteは、メモリ内データベースにコンテンツを追加できます。合計サイズはMバイトを超えません。</target>
        </trans-unit>
        <trans-unit id="6ae05681a8b59259daa468a1d8590729337a135a" translate="yes" xml:space="preserve">
          <source>The sqlite3_drop_modules(D,L) interface removes all virtual table modules from database connection D except those named on list L. The L parameter must be either NULL or a pointer to an array of pointers to strings where the array is terminated by a single NULL pointer. If the L parameter is NULL, then all virtual table modules are removed.</source>
          <target state="translated">sqlite3_drop_modules(D,L)インタフェースは、リストLで指定されたものを除く全ての仮想テーブルモジュールをデータベース接続Dから削除します。 LパラメータはNULLか文字列へのポインタの配列へのポインタでなければなりません。L パラメータが NULL の場合、すべての仮想テーブルモジュールが削除されます。</target>
        </trans-unit>
        <trans-unit id="cb17fe8b042f1bd6f76a39ed23dd1524edfc2345" translate="yes" xml:space="preserve">
          <source>The sqlite3_errcode() routine returns a result code for the most recent major API call. sqlite3_errmsg() returns an English-language text error message for the most recent error. The error message is represented in UTF-8 and will be ephemeral - it could disappear on the next call to any SQLite API function. sqlite3_errmsg16() works like sqlite3_errmsg() except that it returns the error message represented as UTF-16 in host native byte order.</source>
          <target state="translated">sqlite3_errrcode()ルーチンは、直近のメジャーAPIコールの結果コードを返します。 sqlite3_errmsg()は、直近のエラーに対する英語のテキストエラーメッセージを返します。sqlite3_errmsg16()はsqlite3_errmsg()と同じように動作しますが、ホストのネイティブバイト順でUTF-16で表現されたエラーメッセージを返します。</target>
        </trans-unit>
        <trans-unit id="5e0d9cf7c1277961ee0db98705525eacc5bb425f" translate="yes" xml:space="preserve">
          <source>The sqlite3_errmsg() and sqlite3_errmsg16() return English-language text that describes the error, as either UTF-8 or UTF-16 respectively. Memory to hold the error message string is managed internally. The application does not need to worry about freeing the result. However, the error string might be overwritten or deallocated by subsequent calls to other SQLite interface functions.</source>
          <target state="translated">sqlite3_errmsg()とsqlite3_errmsg16()は、エラーを記述する英語のテキストを、それぞれUTF-8またはUTF-16で返します。エラーメッセージ文字列を保持するメモリは内部で管理されます。アプリケーションは結果の解放を気にする必要はありません。ただし、エラー文字列は、後続の他の SQLite インターフェース関数の呼び出しによって上書きされたり、解放されたりする可能性があります。</target>
        </trans-unit>
        <trans-unit id="a3b2d05546afbeecb20b8fe87e3f3189bfedb642" translate="yes" xml:space="preserve">
          <source>The sqlite3_errstr() interface returns the English-language text that describes the &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt;, as UTF-8. Memory to hold the error message string is managed internally and must not be freed by the application.</source>
          <target state="translated">sqlite3_errstr（）インターフェースは、&lt;a href=&quot;../rescode&quot;&gt;結果コード&lt;/a&gt;を説明する英語のテキストをUTF-8として返します。エラーメッセージ文字列を保持するメモリは内部で管理されており、アプリケーションで解放してはなりません。</target>
        </trans-unit>
        <trans-unit id="3185f0fefecbff2d0db8b69bac9298083b70809e" translate="yes" xml:space="preserve">
          <source>The sqlite3_errstr() interface returns the English-language text that describes the &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt;, as UTF-8. Memory to hold the error message string is managed internally and must not be freed by the application.</source>
          <target state="translated">sqlite3_errstr（）インターフェースは、&lt;a href=&quot;rescode&quot;&gt;結果コード&lt;/a&gt;を説明する英語のテキストをUTF-8として返します。エラーメッセージ文字列を保持するメモリは内部で管理されており、アプリケーションで解放してはなりません。</target>
        </trans-unit>
        <trans-unit id="eec19de3d00e4cd6319cb02ddf72d5b612e30300" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface is a convenience wrapper around &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;, that allows an application to run multiple statements of SQL without having to use a lot of C code.</source>
          <target state="translated">sqlite3_exec（）インターフェースは約コンビニエンスラッパーである&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（） &lt;/a&gt;、&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（） &lt;/a&gt;、及び&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt; Cコードの多くを使用することなく、SQLの複数のステートメントを実行するアプリケーションを可能にします、。</target>
        </trans-unit>
        <trans-unit id="9a4e88bd32574fff7b2361feb6cf37710d7194a2" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface is a convenience wrapper around &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt;, and &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;, that allows an application to run multiple statements of SQL without having to use a lot of C code.</source>
          <target state="translated">sqlite3_exec（）インターフェースは約コンビニエンスラッパーである&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（） &lt;/a&gt;、&lt;a href=&quot;step&quot;&gt;sqlite3_step（） &lt;/a&gt;、及び&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt; Cコードの多くを使用することなく、SQLの複数のステートメントを実行するアプリケーションを可能にします、。</target>
        </trans-unit>
        <trans-unit id="5f6ecb5327784e2b3ab3076a060e42400e8e6e49" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface runs zero or more UTF-8 encoded, semicolon-separate SQL statements passed into its 2nd argument, in the context of the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; passed in as its 1st argument. If the callback function of the 3rd argument to sqlite3_exec() is not NULL, then it is invoked for each result row coming out of the evaluated SQL statements. The 4th argument to sqlite3_exec() is relayed through to the 1st argument of each callback invocation. If the callback pointer to sqlite3_exec() is NULL, then no callback is ever invoked and result rows are ignored.</source>
          <target state="translated">sqlite3_exec（）インターフェースは、1番目の引数として渡された&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続の&lt;/a&gt;コンテキストで、2番目の引数に渡されたゼロ以上のUTF-8エンコードのセミコロン区切りのSQLステートメントを実行します。sqlite3_exec（）の3番目の引数のコールバック関数がNULLでない場合、評価されたSQLステートメントからの結果行ごとに呼び出されます。sqlite3_exec（）の4番目の引数は、各コールバック呼び出しの1番目の引数に中継されます。sqlite3_exec（）へのコールバックポインターがNULLの場合、コールバックは呼び出されず、結果行は無視されます。</target>
        </trans-unit>
        <trans-unit id="7f2bf987e70ab4f6565417a4f7295b79e8706b9e" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface runs zero or more UTF-8 encoded, semicolon-separate SQL statements passed into its 2nd argument, in the context of the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; passed in as its 1st argument. If the callback function of the 3rd argument to sqlite3_exec() is not NULL, then it is invoked for each result row coming out of the evaluated SQL statements. The 4th argument to sqlite3_exec() is relayed through to the 1st argument of each callback invocation. If the callback pointer to sqlite3_exec() is NULL, then no callback is ever invoked and result rows are ignored.</source>
          <target state="translated">sqlite3_exec（）インターフェースは、1番目の引数として渡された&lt;a href=&quot;sqlite3&quot;&gt;データベース接続の&lt;/a&gt;コンテキストで、2番目の引数に渡されたゼロ以上のUTF-8エンコードのセミコロン区切りのSQLステートメントを実行します。sqlite3_exec（）の3番目の引数のコールバック関数がNULLでない場合、評価されたSQLステートメントからの結果行ごとに呼び出されます。sqlite3_exec（）の4番目の引数は、各コールバック呼び出しの1番目の引数に中継されます。sqlite3_exec（）へのコールバックポインターがNULLの場合、コールバックは呼び出されず、結果行は無視されます。</target>
        </trans-unit>
        <trans-unit id="fdc80de144729ab29ec768dc45f521935b24167a" translate="yes" xml:space="preserve">
          <source>The sqlite3_expanded_sql() interface returns NULL if insufficient memory is available to hold the result, or if the result would exceed the the maximum string length determined by the &lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;.</source>
          <target state="translated">結果を保持するのに十分なメモリがない場合、または結果が&lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;によって決定される最大文字列長を超える場合、sqlite3_expanded_sql（）インターフェースはNULLを返します。</target>
        </trans-unit>
        <trans-unit id="253eafa1da6e36def799917e15566e8c664899fe" translate="yes" xml:space="preserve">
          <source>The sqlite3_expanded_sql() interface returns NULL if insufficient memory is available to hold the result, or if the result would exceed the the maximum string length determined by the &lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;.</source>
          <target state="translated">結果を保持するのに十分なメモリがない場合、または結果が&lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;によって決定される最大文字列長を超える場合、sqlite3_expanded_sql（）インターフェースはNULLを返します。</target>
        </trans-unit>
        <trans-unit id="1d1fd4c0ad3995d89a0ef41f1f46affc2269eba4" translate="yes" xml:space="preserve">
          <source>The sqlite3_extended_result_codes() routine enables or disables the &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; feature of SQLite. The extended result codes are disabled by default for historical compatibility.</source>
          <target state="translated">sqlite3_extended_result_codes（）ルーチンは、SQLiteの&lt;a href=&quot;../rescode#extrc&quot;&gt;拡張結果コード&lt;/a&gt;機能を有効または無効にします。履歴互換性のために、拡張結果コードはデフォルトで無効になっています。</target>
        </trans-unit>
        <trans-unit id="904ab00e0ae19fa09117889888e1162471d32017" translate="yes" xml:space="preserve">
          <source>The sqlite3_extended_result_codes() routine enables or disables the &lt;a href=&quot;rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; feature of SQLite. The extended result codes are disabled by default for historical compatibility.</source>
          <target state="translated">sqlite3_extended_result_codes（）ルーチンは、SQLiteの&lt;a href=&quot;rescode#extrc&quot;&gt;拡張結果コード&lt;/a&gt;機能を有効または無効にします。履歴互換性のために、拡張結果コードはデフォルトで無効になっています。</target>
        </trans-unit>
        <trans-unit id="5daeea1eac71cd621bf8b80af259a724f2e831b8" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize() function is called to delete a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. If the most recent evaluation of the statement encountered no errors or if the statement is never been evaluated, then sqlite3_finalize() returns SQLITE_OK. If the most recent evaluation of statement S failed, then sqlite3_finalize(S) returns the appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; or &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt;.</source>
          <target state="translated">sqlite3_finalize（）関数は、&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備されたステートメント&lt;/a&gt;を削除するために呼び出されます。ステートメントの最新の評価でエラーが発生しなかった場合、またはステートメントが評価されなかった場合、sqlite3_finalize（）はSQLITE_OKを返します。ステートメントSの最新の評価が失敗した場合、sqlite3_finalize（S）は適切な&lt;a href=&quot;rescode&quot;&gt;エラーコード&lt;/a&gt;または&lt;a href=&quot;rescode#extrc&quot;&gt;拡張エラーコードを&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="74837217c620c1e41ee1e321a9ad17968e0d6486" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize() function is called to delete a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. If the most recent evaluation of the statement encountered no errors or if the statement is never been evaluated, then sqlite3_finalize() returns SQLITE_OK. If the most recent evaluation of statement S failed, then sqlite3_finalize(S) returns the appropriate &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; or &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error code&lt;/a&gt;.</source>
          <target state="translated">sqlite3_finalize（）関数は、&lt;a href=&quot;stmt&quot;&gt;準備されたステートメント&lt;/a&gt;を削除するために呼び出されます。ステートメントの最新の評価でエラーが発生しなかった場合、またはステートメントが評価されなかった場合、sqlite3_finalize（）はSQLITE_OKを返します。ステートメントSの最新の評価が失敗した場合、sqlite3_finalize（S）は適切な&lt;a href=&quot;../rescode&quot;&gt;エラーコード&lt;/a&gt;または&lt;a href=&quot;../rescode#extrc&quot;&gt;拡張エラーコードを&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="cfdc64000a1f68dd938d60f9bb70e02c947748fd" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize(S) routine can be called at any point during the life cycle of &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S: before statement S is ever evaluated, after one or more calls to &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, or after any call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; regardless of whether or not the statement has completed execution.</source>
          <target state="translated">sqlite3_finalize（S）ルーチンはのライフサイクル中の任意の時点で呼び出すことができ&lt;a href=&quot;#sqlite3_stmt&quot;&gt;、準備されたステートメントの&lt;/a&gt; S：文Sは、これまでに1回以上呼び出した後、評価される前に&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（） &lt;/a&gt;、またはのいずれかの呼び出し後&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;に関係なく、かどうかのステートメントは実行を完了していません。</target>
        </trans-unit>
        <trans-unit id="1dec5478469a2333006cfdfd3bbed8c6613161e2" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize(S) routine can be called at any point during the life cycle of &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S: before statement S is ever evaluated, after one or more calls to &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, or after any call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; regardless of whether or not the statement has completed execution.</source>
          <target state="translated">sqlite3_finalize（S）ルーチンはのライフサイクル中の任意の時点で呼び出すことができ&lt;a href=&quot;stmt&quot;&gt;、準備されたステートメントの&lt;/a&gt; S：文Sは、これまでに1回以上呼び出した後、評価される前に&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（） &lt;/a&gt;、またはのいずれかの呼び出し後&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;に関係なく、かどうかのステートメントは実行を完了していません。</target>
        </trans-unit>
        <trans-unit id="408796a34b26a6721118a4ab1b7c1f9baef90909" translate="yes" xml:space="preserve">
          <source>The sqlite3_free_filename(Y) routine releases a memory allocation previously obtained from sqlite3_create_filename(). Invoking sqlite3_free_filename(Y) where Y is a NULL pointer is a harmless no-op.</source>
          <target state="translated">sqlite3_free_filename(Y)ルーチンは、以前にsqlite3_create_filename()から取得したメモリ割り当てを解放します。YがNULLポインタである場合にsqlite3_free_filename(Y)を呼び出すことは無害なノーオペです。</target>
        </trans-unit>
        <trans-unit id="0a8a4dfedb4d5de550dae28093210eb5e1165c50" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_autocommit() interface returns non-zero or zero if the given database connection is or is not in autocommit mode, respectively. Autocommit mode is on by default. Autocommit mode is disabled by a &lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt; statement. Autocommit mode is re-enabled by a &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt; or &lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;.</source>
          <target state="translated">sqlite3_get_autocommit（）インターフェイスは、指定されたデータベース接続が自動コミットモードであるかどうかに関係なく、それぞれゼロ以外またはゼロを返します。自動コミットモードはデフォルトでオンになっています。自動コミットモードは、&lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt;ステートメントによって無効になります。自動コミットモードは、&lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt;または&lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;によって再び有効になります。</target>
        </trans-unit>
        <trans-unit id="c6407bbe024eecae19905f3987328770ebef955e" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_autocommit() interface returns non-zero or zero if the given database connection is or is not in autocommit mode, respectively. Autocommit mode is on by default. Autocommit mode is disabled by a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; statement. Autocommit mode is re-enabled by a &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; or &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;.</source>
          <target state="translated">sqlite3_get_autocommit（）インターフェイスは、指定されたデータベース接続が自動コミットモードであるかどうかに関係なく、それぞれゼロ以外またはゼロを返します。自動コミットモードはデフォルトでオンになっています。自動コミットモードは、&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;ステートメントによって無効になります。自動コミットモードは、&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;または&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;によって再び有効になります。</target>
        </trans-unit>
        <trans-unit id="c54753db8fb054877250927a699aaaed04734d2b" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_auxdata(C,N) interface returns a pointer to the metadata associated by the sqlite3_set_auxdata(C,N,P,X) function with the Nth argument value to the application-defined function. N is zero for the left-most function argument. If there is no metadata associated with the function argument, the sqlite3_get_auxdata(C,N) interface returns a NULL pointer.</source>
          <target state="translated">sqlite3_get_auxdata(C,N)インタフェースは、アプリケーション定義関数のN番目の引数の値を持つsqlite3_set_auxdata(C,N,P,X)関数によって関連付けられたメタデータへのポインタを返します。Nは左端の関数の引数の値は0です。関数の引数に関連付けられたメタデータがない場合、sqlite3_get_auxdata(C,N)インタフェースはNULLポインタを返します。</target>
        </trans-unit>
        <trans-unit id="35597daf57a6a6a4650eb220c2a29fa2c91a59d0" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_table() function evaluates one or more semicolon-separated SQL statements in the zero-terminated UTF-8 string of its 2nd parameter and returns a result table to the pointer given in its 3rd parameter.</source>
          <target state="translated">sqlite3_get_table()関数は、2番目のパラメータのゼロ終端のUTF-8文字列で1つ以上のセミコロンで区切られたSQL文を評価し、3番目のパラメータで与えられたポインタに結果テーブルを返します。</target>
        </trans-unit>
        <trans-unit id="acdf7ebaf34cc7cf8bdf020e8dc45c52df0d628c" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_table() interface is implemented as a wrapper around &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;. The sqlite3_get_table() routine does not have access to any internal data structures of SQLite. It uses only the public interface defined here. As a consequence, errors that occur in the wrapper layer outside of the internal &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt; call are not reflected in subsequent calls to &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_get_table（）インターフェースをラッパーとして実装されて&lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec（） &lt;/a&gt;。sqlite3_get_table（）ルーチンは、SQLiteの内部データ構造にアクセスできません。ここで定義されたパブリックインターフェイスのみを使用します。結果として、内部&lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;呼び出しの外側のラッパーレイヤーで発生したエラーは、&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;または&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;への後続の呼び出しには反映されません。</target>
        </trans-unit>
        <trans-unit id="566ec671a5bf78f09b92642b451438dd26c86350" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_table() interface is implemented as a wrapper around &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;. The sqlite3_get_table() routine does not have access to any internal data structures of SQLite. It uses only the public interface defined here. As a consequence, errors that occur in the wrapper layer outside of the internal &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt; call are not reflected in subsequent calls to &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; or &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_get_table（）インターフェースをラッパーとして実装されて&lt;a href=&quot;exec&quot;&gt;sqlite3_exec（） &lt;/a&gt;。sqlite3_get_table（）ルーチンは、SQLiteの内部データ構造にアクセスできません。ここで定義されたパブリックインターフェイスのみを使用します。結果として、内部&lt;a href=&quot;exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;呼び出しの外側のラッパーレイヤーで発生したエラーは、&lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;または&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;への後続の呼び出しには反映されません。</target>
        </trans-unit>
        <trans-unit id="b9b992cc0be7235d15c4a18cbb125e283656622e" translate="yes" xml:space="preserve">
          <source>The sqlite3_hard_heap_limit64(N) interface sets a hard upper bound of N bytes on the amount of memory that will be allocated. The sqlite3_hard_heap_limit64(N) interface is similar to sqlite3_soft_heap_limit64(N) except that memory allocations will fail when the hard heap limit is reached.</source>
          <target state="translated">sqlite3_hard_heap_limit64(N)インタフェースは、割り当てられるメモリ量にNバイトのハード上限を設定します。sqlite3_hard_heap_limit64(N)インタフェースはsqlite3_soft_heap_limit64(N)と似ています。</target>
        </trans-unit>
        <trans-unit id="5a1053b2bb267ced2e3415b8b71b02dc7bb0d976" translate="yes" xml:space="preserve">
          <source>The sqlite3_index_info structure and its substructures is used as part of the &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; interface to pass information into and receive the reply from the &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of a &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt;. The fields under **Inputs** are the inputs to xBestIndex and are read-only. xBestIndex inserts its results into the **Outputs** fields.</source>
          <target state="translated">sqlite3_index_info構造とそのサブ構造は、&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;インターフェイスの一部として使用され、&lt;a href=&quot;module&quot;&gt;仮想テーブルモジュールの&lt;/a&gt;&lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;メソッドに情報を渡したり、xBestIndexメソッドからの応答を受け取ったりします。**入力**の下のフィールドはxBestIndexへの入力であり、読み取り専用です。xBestIndexはその結果を**出力**フィールドに挿入します。</target>
        </trans-unit>
        <trans-unit id="779db7516101e2733ab83d988869d6422e837e26" translate="yes" xml:space="preserve">
          <source>The sqlite3_index_info structure and its substructures is used as part of the &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; interface to pass information into and receive the reply from the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of a &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt;. The fields under **Inputs** are the inputs to xBestIndex and are read-only. xBestIndex inserts its results into the **Outputs** fields.</source>
          <target state="translated">sqlite3_index_info構造とそのサブ構造は、&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;インターフェイスの一部として使用され、&lt;a href=&quot;#sqlite3_module&quot;&gt;仮想テーブルモジュールの&lt;/a&gt;&lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;メソッドに情報を渡したり、xBestIndexメソッドからの応答を受け取ったりします。**入力**の下のフィールドはxBestIndexへの入力であり、読み取り専用です。xBestIndexはその結果を**出力**フィールドに挿入します。</target>
        </trans-unit>
        <trans-unit id="f7b3a693ac538b125172c62d75cc7d377f31b955" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() interface is threadsafe, but sqlite3_shutdown() is not. The sqlite3_shutdown() interface must only be called from a single thread. All open &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; must be closed and all other SQLite resources must be deallocated prior to invoking sqlite3_shutdown().</source>
          <target state="translated">sqlite3_initialize（）インターフェースはスレッドセーフですが、sqlite3_shutdown（）はそうではありません。sqlite3_shutdown（）インターフェースは、単一のスレッドからのみ呼び出す必要があります。sqlite3_shutdown（）を呼び出す前に、開いているすべての&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続を&lt;/a&gt;閉じ、他のすべてのSQLiteリソースの割り当てを解除する必要があります。</target>
        </trans-unit>
        <trans-unit id="88e442978d61726b76c4c6bd7b1f8a87808c119b" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() interface is threadsafe, but sqlite3_shutdown() is not. The sqlite3_shutdown() interface must only be called from a single thread. All open &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; must be closed and all other SQLite resources must be deallocated prior to invoking sqlite3_shutdown().</source>
          <target state="translated">sqlite3_initialize（）インターフェースはスレッドセーフですが、sqlite3_shutdown（）はそうではありません。sqlite3_shutdown（）インターフェースは、単一のスレッドからのみ呼び出す必要があります。sqlite3_shutdown（）を呼び出す前に、開いているすべての&lt;a href=&quot;sqlite3&quot;&gt;データベース接続を&lt;/a&gt;閉じ、他のすべてのSQLiteリソースの割り当てを解除する必要があります。</target>
        </trans-unit>
        <trans-unit id="0e2957684efb0782443d87103a368a9305c21dfe" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine initializes the SQLite library. The sqlite3_shutdown() routine deallocates any resources that were allocated by sqlite3_initialize(). These routines are designed to aid in process initialization and shutdown on embedded systems. Workstation applications using SQLite normally do not need to invoke either of these routines.</source>
          <target state="translated">sqlite3_initialize()ルーチンはSQLiteライブラリを初期化します。sqlite3_shutdown()ルーチンは、sqlite3_initialize()によって割り当てられたリソースを解放します。これらのルーチンは、組み込みシステムでのプロセスの初期化とシャットダウンを支援するように設計されています。SQLiteを使用するワークステーション・アプリケーションは通常、これらのルーチンを呼び出す必要はありません。</target>
        </trans-unit>
        <trans-unit id="6344d658101e62a854952f62047632e568cb77e6" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine is called internally by many other SQLite interfaces so that an application usually does not need to invoke sqlite3_initialize() directly. For example, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt; calls sqlite3_initialize() so the SQLite library will be automatically initialized when &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt; is called if it has not be initialized already. However, if SQLite is compiled with the &lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; compile-time option, then the automatic calls to sqlite3_initialize() are omitted and the application must call sqlite3_initialize() directly prior to using any other SQLite interface. For maximum portability, it is recommended that applications always invoke sqlite3_initialize() directly prior to using any other SQLite interface. Future releases of SQLite may require this. In other words, the behavior exhibited when SQLite is compiled with &lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; might become the default behavior in some future release of SQLite.</source>
          <target state="translated">sqlite3_initialize（）ルーチンは、アプリケーションが通常sqlite3_initialize（）を直接呼び出す必要がないように、他の多くのSQLiteインターフェースによって内部的に呼び出されます。たとえば、&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;はsqlite3_initialize（）を呼び出すため、まだ初期化されていない場合、&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;が呼び出されるとSQLiteライブラリが自動的に初期化されます。ただし、SQLiteが&lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINITで&lt;/a&gt;コンパイルされている場合コンパイル時オプションでは、sqlite3_initialize（）への自動呼び出しは省略され、アプリケーションは他のSQLiteインターフェイスを使用する前に直接sqlite3_initialize（）を呼び出す必要があります。移植性を最大にするために、他のSQLiteインターフェースを使用する前に、アプリケーションが常にsqlite3_initialize（）を直接呼び出すことをお勧めします。 SQLiteの将来のリリースでは、これが必要になる可能性があります。言い換えると、SQLiteが&lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt;でコンパイルされたときに示される動作は、SQLiteの将来のリリースではデフォルトの動作になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="fcebb10283d6873f839e3d670ae393ff5c1368df" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine is called internally by many other SQLite interfaces so that an application usually does not need to invoke sqlite3_initialize() directly. For example, &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt; calls sqlite3_initialize() so the SQLite library will be automatically initialized when &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt; is called if it has not be initialized already. However, if SQLite is compiled with the &lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; compile-time option, then the automatic calls to sqlite3_initialize() are omitted and the application must call sqlite3_initialize() directly prior to using any other SQLite interface. For maximum portability, it is recommended that applications always invoke sqlite3_initialize() directly prior to using any other SQLite interface. Future releases of SQLite may require this. In other words, the behavior exhibited when SQLite is compiled with &lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; might become the default behavior in some future release of SQLite.</source>
          <target state="translated">sqlite3_initialize（）ルーチンは、アプリケーションが通常sqlite3_initialize（）を直接呼び出す必要がないように、他の多くのSQLiteインターフェースによって内部的に呼び出されます。たとえば、&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;はsqlite3_initialize（）を呼び出すため、まだ初期化されていない場合、&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;が呼び出されるとSQLiteライブラリが自動的に初期化されます。ただし、SQLiteが&lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINITで&lt;/a&gt;コンパイルされている場合コンパイル時オプションでは、sqlite3_initialize（）への自動呼び出しは省略され、アプリケーションは他のSQLiteインターフェイスを使用する前に直接sqlite3_initialize（）を呼び出す必要があります。移植性を最大にするために、他のSQLiteインターフェースを使用する前に、アプリケーションが常にsqlite3_initialize（）を直接呼び出すことをお勧めします。 SQLiteの将来のリリースでは、これが必要になる可能性があります。言い換えると、SQLiteが&lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt;でコンパイルされたときに示される動作は、SQLiteの将来のリリースではデフォルトの動作になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="ce2e2f5e58c3c92f466c0d1a9cbb3782ccb3ca7e" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success. If for some reason, sqlite3_initialize() is unable to initialize the library (perhaps it is unable to allocate a needed resource such as a mutex) it returns an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; other than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">sqlite3_initialize（）ルーチンは成功すると&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;を返します。何らかの理由でsqlite3_initialize（）がライブラリを初期化できない場合（おそらく、ミューテックスなどの必要なリソースを割り当てることができない場合）は、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;以外の&lt;a href=&quot;rescode&quot;&gt;エラーコードを&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="7cfd6fb2b2f9b6bef5dc2729044b616aa2e46340" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success. If for some reason, sqlite3_initialize() is unable to initialize the library (perhaps it is unable to allocate a needed resource such as a mutex) it returns an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; other than &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">sqlite3_initialize（）ルーチンは成功すると&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;を返します。何らかの理由でsqlite3_initialize（）がライブラリを初期化できない場合（おそらく、ミューテックスなどの必要なリソースを割り当てることができない場合）は、&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;以外の&lt;a href=&quot;../rescode&quot;&gt;エラーコードを&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="004164880e4716eb9f6522ffa56490d8e1026730" translate="yes" xml:space="preserve">
          <source>The sqlite3_int64 and sqlite3_uint64 are the preferred type definitions. The sqlite_int64 and sqlite_uint64 types are supported for backwards compatibility only.</source>
          <target state="translated">sqlite3_int64とsqlite3_uint64は好ましい型定義です。sqlite_int64とsqlite_uint64型は下位互換性のためだけにサポートされています。</target>
        </trans-unit>
        <trans-unit id="7d87f3d7209e128d2babe00e667401d22d9cc8a5" translate="yes" xml:space="preserve">
          <source>The sqlite3_int64 and sqlite_int64 types can store integer values between -9223372036854775808 and +9223372036854775807 inclusive. The sqlite3_uint64 and sqlite_uint64 types can store integer values between 0 and +18446744073709551615 inclusive.</source>
          <target state="translated">sqlite3_int64およびsqlite_int64型は、-9223372036854775808から+9223372036854775807までの整数値を格納できます。sqlite3_uint64とsqlite_uint64型は0から+18446744073709551615までの整数値を格納できます。</target>
        </trans-unit>
        <trans-unit id="d1945cfc4228bc66b1032ca0f61bc88893782d0c" translate="yes" xml:space="preserve">
          <source>The sqlite3_interrupt(D) call is in effect until all currently running SQL statements on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D complete. Any new SQL statements that are started after the sqlite3_interrupt() call and before the running statement count reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt() call. New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt(). A call to sqlite3_interrupt(D) that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt() call returns.</source>
          <target state="translated">sqlite3_interrupt（D）呼び出しは、&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;Dで現在実行されているすべてのSQLステートメントが完了するまで有効です。sqlite3_interrupt（）呼び出しの後、実行中のステートメント数がゼロに達する前に開始された新しいSQLステートメントは、sqlite3_interrupt（）呼び出しの前に実行されていたかのように中断されます。実行中のステートメント数がゼロに達した後に開始される新しいSQLステートメントは、sqlite3_interrupt（）の影響を受けません。実行中のSQLステートメントがないときに発生するsqlite3_interrupt（D）の呼び出しは、操作なしであり、sqlite3_interrupt（）呼び出しが戻った後に開始されるSQLステートメントには影響しません。</target>
        </trans-unit>
        <trans-unit id="7eba8c8e6f99b81a907173174c705f9ed98298ab" translate="yes" xml:space="preserve">
          <source>The sqlite3_interrupt(D) call is in effect until all currently running SQL statements on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D complete. Any new SQL statements that are started after the sqlite3_interrupt() call and before the running statements reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt() call. New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt(). A call to sqlite3_interrupt(D) that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt() call returns.</source>
          <target state="translated">sqlite3_interrupt（D）呼び出しは、&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt; Dで現在実行中のすべてのSQLステートメントが完了するまで有効です。 sqlite3_interrupt（）呼び出しの後、実行中のステートメントがゼロに達する前に開始された新しいSQLステートメントは、sqlite3_interrupt（）呼び出しの前に実行されたかのように中断されます。実行中のステートメントの数がゼロに達した後に開始される新しいSQLステートメントは、sqlite3_interrupt（）の影響を受けません。実行中のSQLステートメントがない場合に発生するsqlite3_interrupt（D）への呼び出しはノーオペレーションであり、sqlite3_interrupt（）呼び出しが戻った後に開始されるSQLステートメントには影響を与えません。</target>
        </trans-unit>
        <trans-unit id="397354330de52f0df08035b92ede80f0eda59fd9" translate="yes" xml:space="preserve">
          <source>The sqlite3_interrupt(D) call is in effect until all currently running SQL statements on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D complete. Any new SQL statements that are started after the sqlite3_interrupt() call and before the running statement count reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt() call. New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt(). A call to sqlite3_interrupt(D) that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt() call returns.</source>
          <target state="translated">sqlite3_interrupt（D）呼び出しは、&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;Dで現在実行されているすべてのSQLステートメントが完了するまで有効です。sqlite3_interrupt（）呼び出しの後、実行中のステートメント数がゼロに達する前に開始された新しいSQLステートメントは、sqlite3_interrupt（）呼び出しの前に実行されていたかのように中断されます。実行中のステートメント数がゼロに達した後に開始される新しいSQLステートメントは、sqlite3_interrupt（）の影響を受けません。実行中のSQLステートメントがないときに発生するsqlite3_interrupt（D）の呼び出しは、操作なしであり、sqlite3_interrupt（）呼び出しが戻った後に開始されるSQLステートメントには影響しません。</target>
        </trans-unit>
        <trans-unit id="a6b86af3fa8ce3c883af892e74e82bdad0554e41" translate="yes" xml:space="preserve">
          <source>The sqlite3_interrupt(D) call is in effect until all currently running SQL statements on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D complete. Any new SQL statements that are started after the sqlite3_interrupt() call and before the running statements reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt() call. New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt(). A call to sqlite3_interrupt(D) that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt() call returns.</source>
          <target state="translated">sqlite3_interrupt（D）呼び出しは、&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt; Dで現在実行中のすべてのSQLステートメントが完了するまで有効です。 sqlite3_interrupt（）呼び出しの後、実行中のステートメントがゼロに達する前に開始された新しいSQLステートメントは、sqlite3_interrupt（）呼び出しの前に実行されたかのように中断されます。実行中のステートメントの数がゼロに達した後に開始される新しいSQLステートメントは、sqlite3_interrupt（）の影響を受けません。実行中のSQLステートメントがない場合に発生するsqlite3_interrupt（D）への呼び出しはノーオペレーションであり、sqlite3_interrupt（）呼び出しが戻った後に開始されるSQLステートメントには影響を与えません。</target>
        </trans-unit>
        <trans-unit id="3bfe2e62ea9486a964b648fd6403e7edfa3b65f8" translate="yes" xml:space="preserve">
          <source>The sqlite3_keyword_check(Z,L) interface checks to see whether or not the L-byte UTF8 identifier that Z points to is a keyword, returning non-zero if it is and zero if not.</source>
          <target state="translated">sqlite3_keyword_check(Z,L)インタフェースは、Zが指すLバイトUTF8識別子がキーワードであるかどうかをチェックし、キーワードであれば0以外の値を、キーワードでなければ0を返します。</target>
        </trans-unit>
        <trans-unit id="d4d8092bdf6d249db5e6e39b2ccbee0c913272c1" translate="yes" xml:space="preserve">
          <source>The sqlite3_keyword_count() interface returns the number of distinct keywords understood by SQLite.</source>
          <target state="translated">sqlite3_keyword_count()インターフェイスは、SQLite で理解できる明確なキーワードの数を返します。</target>
        </trans-unit>
        <trans-unit id="dc0acf41ffb529d44b2ebca13529ac325b17bad2" translate="yes" xml:space="preserve">
          <source>The sqlite3_keyword_name(N,Z,L) interface finds the N-th keyword and makes *Z point to that keyword expressed as UTF8 and writes the number of bytes in the keyword into *L. The string that *Z points to is not zero-terminated. The sqlite3_keyword_name(N,Z,L) routine returns SQLITE_OK if N is within bounds and SQLITE_ERROR if not. If either Z or L are NULL or invalid pointers then calls to sqlite3_keyword_name(N,Z,L) result in undefined behavior.</source>
          <target state="translated">sqlite3_keyword_name(N,Z,L)インタフェースは、N番目のキーワードを見つけ、UTF8で表現されたキーワードを*Zが指すようにし、キーワードのバイト数を*Lに書き込みます。Zが指す文字列はゼロ終端ではありません。sqlite3_keyword_name(N,Z,L)ルーチンは、Nが範囲内ならばSQLITE_OKを、範囲外ならばSQLITE_ERRORを返します。ZまたはLがNULLまたは無効なポインタの場合、sqlite3_keyword_name(N,Z,L)の呼び出しは未定義の動作になります。</target>
        </trans-unit>
        <trans-unit id="0a1d77fc76c131dee5ee5dd030d6d5133cee00d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_last_insert_rowid(D) interface usually returns the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the most recent successful &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; into a rowid table or &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; on database connection D. Inserts into &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are not recorded. If no successful &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;s into rowid tables have ever occurred on the database connection D, then sqlite3_last_insert_rowid(D) returns zero.</source>
          <target state="translated">sqlite3_last_insert_rowid（D）インターフェースは、通常返し&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;最新の成功の&lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;行IDテーブルまたはに&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;にデータベース接続D.インサート上を&lt;a href=&quot;../withoutrowid&quot;&gt;ROWIDをなし&lt;/a&gt;テーブルが記録されません。ROWIDテーブルへの正常な&lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;がデータベース接続Dで発生したことがない場合、sqlite3_last_insert_rowid（D）はゼロを返します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
