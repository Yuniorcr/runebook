<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="59ef232ad2a9a13529bf5e89145da92a1a6319d6" translate="yes" xml:space="preserve">
          <source>Type affinity</source>
          <target state="translated">タイプの親和性</target>
        </trans-unit>
        <trans-unit id="38895187a3c7e29b6f02e06c184834c7180dd221" translate="yes" xml:space="preserve">
          <source>Typical output from a single TH3 test program run looks like this:</source>
          <target state="translated">1つのTH3テストプログラムの実行からの典型的な出力は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="8711d8537a2bf9829ad98f22b75b8b8dc119969c" translate="yes" xml:space="preserve">
          <source>UNBOUNDED</source>
          <target state="translated">UNBOUNDED</target>
        </trans-unit>
        <trans-unit id="363cb5cb9b015bf8fe75ee8f6f3ad675ca5618cc" translate="yes" xml:space="preserve">
          <source>UNION</source>
          <target state="translated">UNION</target>
        </trans-unit>
        <trans-unit id="e0f0a7115a4e0b11973725c719a99090b1a2caa7" translate="yes" xml:space="preserve">
          <source>UNION ALL ... UNION ALL SELECT</source>
          <target state="translated">UNION ALL ...UNION ALL SELECT</target>
        </trans-unit>
        <trans-unit id="2ef896dc8994d71c3776f028df0d2a89b61b4550" translate="yes" xml:space="preserve">
          <source>UNION, UNION ALL, INTERSECT, and EXCEPT</source>
          <target state="translated">ユニオン、ユニオンオール、インターコネクト、エクセプト</target>
        </trans-unit>
        <trans-unit id="c9e6a29d14f3f27cd2ee75b65407552ad50a3078" translate="yes" xml:space="preserve">
          <source>UNIQUE</source>
          <target state="translated">UNIQUE</target>
        </trans-unit>
        <trans-unit id="841c884fb288309550412babe47484ff0e3745f9" translate="yes" xml:space="preserve">
          <source>UNIQUE, CHECK, and NOT NULL constraint errors</source>
          <target state="translated">UNIQUE、CHECK、NOT NULL 制約エラー</target>
        </trans-unit>
        <trans-unit id="7ead37d8578ae9705f3d87c1d034addd810cd1ed" translate="yes" xml:space="preserve">
          <source>UNIX mode, as returned by stat(2) for the zip file record (an integer). This identifies the type of record (file, directory or symbolic link), and the associated user/group/all permissions.</source>
          <target state="translated">ZIP ファイルレコード (整数)の stat(2)によって返される UNIX モード。これはレコードの種類 (ファイル、ディレクトリ、シンボリックリンク)と、関連するユーザ/グループ/すべてのパーミッションを識別します。</target>
        </trans-unit>
        <trans-unit id="f6fee659655c0db9d5b27d3ee09d34358c974b03" translate="yes" xml:space="preserve">
          <source>UNLOCKED</source>
          <target state="translated">UNLOCKED</target>
        </trans-unit>
        <trans-unit id="d272346adafef58007de20094d2f682eb2fe1bd2" translate="yes" xml:space="preserve">
          <source>UNSIGNED BIG INT</source>
          <target state="translated">UNSIGNED BIG INT</target>
        </trans-unit>
        <trans-unit id="52c6c1812015585dc1092393a1f244f60d68c60a" translate="yes" xml:space="preserve">
          <source>UPDATE</source>
          <target state="translated">UPDATE</target>
        </trans-unit>
        <trans-unit id="688e558eee1d1bb512a94d0cc620288bf7d472f2" translate="yes" xml:space="preserve">
          <source>UPDATE And DELETE Statements</source>
          <target state="translated">UPDATE と DELETE ステートメント</target>
        </trans-unit>
        <trans-unit id="49a16f1602f22a2ff3d079003de17960196cd62b" translate="yes" xml:space="preserve">
          <source>UPDATE Changes</source>
          <target state="translated">UPDATEの変更点</target>
        </trans-unit>
        <trans-unit id="bf53a6aae01db9b5dad497a7e025817f66502008" translate="yes" xml:space="preserve">
          <source>UPDATE and DELETE statements work similarly.</source>
          <target state="translated">UPDATE文とDELETE文も同様に動作します。</target>
        </trans-unit>
        <trans-unit id="1c9d5c3eed910621fdbd8231e3b605e82a063d04" translate="yes" xml:space="preserve">
          <source>UPDATE statements work very much like DELETE statements except that instead of deleting the record they replace it with a new one. Consider this example:</source>
          <target state="translated">UPDATE文は、レコードを削除する代わりに新しいレコードに置き換えることを除いては、DELETE文と非常によく似た働きをします。この例を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="23f1f94678733621721dfbd9281a151e75fd39b3" translate="yes" xml:space="preserve">
          <source>UPDATE t1 SET b = 'v2' WHERE a=1;</source>
          <target state="translated">UPDATE t1 SET b='v2' WHERE a=1.</target>
        </trans-unit>
        <trans-unit id="9d1ad45a1d025bcccb63dad4f87235cf205b5b63" translate="yes" xml:space="preserve">
          <source>UPDATE t1 SET b=b*2 WHERE a&amp;gt;=0 AND a&amp;lt;10;</source>
          <target state="translated">UPDATE t1 SET b = b * 2 WHERE a&amp;gt; = 0 AND a &amp;lt;10;</target>
        </trans-unit>
        <trans-unit id="7bc4a22623437c880e8e4324cc657c00abd18be7" translate="yes" xml:space="preserve">
          <source>UPDATE t1 SET b=b*2 WHERE a&amp;gt;=10 AND a&amp;lt;20;</source>
          <target state="translated">UPDATE t1 SET b = b * 2 WHERE a&amp;gt; = 10 AND a &amp;lt;20;</target>
        </trans-unit>
        <trans-unit id="69fa4f2a787b8c6d32fe94ec05425d1fb170202e" translate="yes" xml:space="preserve">
          <source>UPDATE t1 SET b=b*2 WHERE a&amp;gt;=9980 AND a&amp;lt;9990;</source>
          <target state="translated">UPDATE t1 SET b = b * 2 WHERE a&amp;gt; = 9980 AND a &amp;lt;9990;</target>
        </trans-unit>
        <trans-unit id="bd6a359ea6d6ffa5fa77996361d46448cd59ce9f" translate="yes" xml:space="preserve">
          <source>UPDATE t1 SET b=b*2 WHERE a&amp;gt;=9990 AND a&amp;lt;10000;</source>
          <target state="translated">UPDATE t1 SET b = b * 2 WHERE a&amp;gt; = 9990 AND a &amp;lt;10000;</target>
        </trans-unit>
        <trans-unit id="0afa724368a197872d6c5ffb446fe74a06bc33c2" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET b=121928 WHERE a=2;</source>
          <target state="translated">UPDATE t2 SET b=121928 WHERE a=2.</target>
        </trans-unit>
        <trans-unit id="3526291b0bb67daddf75ff2b44713d0b345a7083" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET b=347393 WHERE a=25000;</source>
          <target state="translated">UPDATE t2 SET b=347393 WHERE a=25000.</target>
        </trans-unit>
        <trans-unit id="1e3a05f35bab1c3145c54848bb462d616f180f96" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET b=35065 WHERE a=24999;</source>
          <target state="translated">UPDATE t2 SET b=35065 WHERE a=24999.</target>
        </trans-unit>
        <trans-unit id="83da842c2149e8d92733fb66a7c52922e2a8bb02" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET b=468026 WHERE a=1;</source>
          <target state="translated">UPDATE t2 SET b=468026 WHERE a=1.</target>
        </trans-unit>
        <trans-unit id="abe0aeef0bc8c95cf7dba0b992e2c26051c0fbd4" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET c='one hundred forty eight thousand three hundred eighty two' WHERE a=1;</source>
          <target state="translated">UPDATE t2 SET c='1408,000 3,882' WHERE a=1.</target>
        </trans-unit>
        <trans-unit id="2e646600f6e7b2bb70471ce989105819d65503b9" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET c='three hundred eighty three thousand ninety nine' WHERE a=24999;</source>
          <target state="translated">UPDATE t2 SET c='three hundred eighty three thousand ninety nine' WHERE a=24999.</target>
        </trans-unit>
        <trans-unit id="24be2b2373e2e643ec5af7225d298b219c086994" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET c='three hundred sixty six thousand five hundred two' WHERE a=2;</source>
          <target state="translated">UPDATE t2 SET c='3,066,000,500,200' WHERE a=2.</target>
        </trans-unit>
        <trans-unit id="317adbaa4dc2a3c2843d99c6771359a7f0624c58" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET c='two hundred fifty six thousand eight hundred thirty' WHERE a=25000;</source>
          <target state="translated">UPDATE t2 SET c='towo hundred fifty six thousand eight hundred thirty' WHERE a=25000.</target>
        </trans-unit>
        <trans-unit id="c55112b254b71dd5f11927b24c53d183f3ed4118" translate="yes" xml:space="preserve">
          <source>UPSERT</source>
          <target state="translated">UPSERT</target>
        </trans-unit>
        <trans-unit id="6eee69d236c66ab4ffc25696fb830833cbb3fd3c" translate="yes" xml:space="preserve">
          <source>UPSERT does not currently work for &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">UPSERTは現在、&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;に対しては機能しません。</target>
        </trans-unit>
        <trans-unit id="1c2066bfe0e8babe467800cce0c33996ece301c4" translate="yes" xml:space="preserve">
          <source>UPSERT is a special syntax addition to &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; that causes the INSERT to behave as an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or a no-op if the INSERT would violate a uniqueness constraint. UPSERT is not standard SQL. UPSERT in SQLite follows the syntax established by PostgreSQL. UPSERT syntax was added to SQLite with version 3.24.0 (2018-06-04).</source>
          <target state="translated">UPSERTは&lt;a href=&quot;lang_insert&quot;&gt;INSERTに&lt;/a&gt;特別な構文を追加したもので、INSERTが一意性の制約に違反する場合、INSERTは&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;またはno-op として動作します。UPSERTは標準SQLではありません。SQLiteのUPSERTは、PostgreSQLによって確立された構文に従います。UPSERT構文がSQLiteにバージョン3.24.0（2018-06-04）で追加されました。</target>
        </trans-unit>
        <trans-unit id="095b20b5d88a77f400266be9db4f8fd23dca8121" translate="yes" xml:space="preserve">
          <source>URI Filenames</source>
          <target state="translated">URIファイル名</target>
        </trans-unit>
        <trans-unit id="6b3e19882ec7248890e4c5d13ea994d174863955" translate="yes" xml:space="preserve">
          <source>URI filename examples</source>
          <target state="translated">URI ファイル名の例</target>
        </trans-unit>
        <trans-unit id="5e847e5e42eefec738b40d802039de3c59cd0211" translate="yes" xml:space="preserve">
          <source>URI filenames</source>
          <target state="translated">URIファイル名</target>
        </trans-unit>
        <trans-unit id="bcc83fb4f795835fa81fea70c5b7f4ce3da5fb80" translate="yes" xml:space="preserve">
          <source>URI filenames are parsed according to RFC 3986. If the URI contains an authority, then it must be either an empty string or the string &quot;localhost&quot;. If the authority is not an empty string or &quot;localhost&quot;, an error is returned to the caller. The fragment component of a URI, if present, is ignored.</source>
          <target state="translated">URIファイル名はRFC 3986に従って解析される。URIが権限を含む場合、それは空文字列か文字列「localhost」でなければならない。権限が空文字列または「localhost」でない場合、エラーが呼び出し元に返される。URIのフラグメントコンポーネントが存在する場合は無視される。</target>
        </trans-unit>
        <trans-unit id="f52fa99533bd53d2651964895f6aead88e88448d" translate="yes" xml:space="preserve">
          <source>URI filenames in sqlite3_open()</source>
          <target state="translated">sqlite3_open()でのURIファイル名</target>
        </trans-unit>
        <trans-unit id="26ed4ff394970482b699209414b942167f2dd638" translate="yes" xml:space="preserve">
          <source>URI hexadecimal escape sequences (%HH) are supported within the path and query components of a URI. A hexadecimal escape sequence consists of a percent sign - &quot;%&quot; - followed by exactly two hexadecimal digits specifying an octet value. Before the path or query components of a URI filename are interpreted, they are encoded using UTF-8 and all hexadecimal escape sequences replaced by a single byte containing the corresponding octet. If this process generates an invalid UTF-8 encoding, the results are undefined.</source>
          <target state="translated">URIの16進数エスケープシーケンス(%HH)は、URIのパスおよびクエリコンポーネント内でサポートされています。16進数エスケープシーケンスは、パーセント記号「%」の後に、オクテット値を指定する正確に2つの16進数の数字が続く構成になっています。URIファイル名のパスまたはクエリ構成要素が解釈される前に、それらはUTF-8を用いてエンコードされ、すべての16進数のエスケープシーケンスは、対応するオクテットを含む1バイトに置き換えられます。この処理が無効な UTF-8 エンコーディングを生成した場合、結果は未定義である。</target>
        </trans-unit>
        <trans-unit id="40da99c368fe0d628f9b0dcc937070f1edfd1b1f" translate="yes" xml:space="preserve">
          <source>URIs are processed as UTF8 text. The filename argument sqlite3_open16() is converted from UTF16 native byte order into UTF8 prior to processing.</source>
          <target state="translated">URIはUTF8テキストとして処理されます。ファイル名の引数sqlite3_open16()は、処理に先立ち、UTF16ネイティブバイト順からUTF8に変換されます。</target>
        </trans-unit>
        <trans-unit id="41b3da30e1707f2b0bc331e3534b952825349eed" translate="yes" xml:space="preserve">
          <source>USB flash memory sticks seem to be especially pernicious liars regarding sync requests. One can easily see this by committing a large transaction to an SQLite database on a USB memory stick. The COMMIT command will return relatively quickly, indicating that the memory stick has told the operating system and the operating system has told SQLite that all content is safely in persistent storage, and yet the LED on the end of the memory stick will continue flashing for several more seconds. Pulling out the memory stick while the LED is still flashing will frequently result in database corruption.</source>
          <target state="translated">USB フラッシュメモリスティックは、同期要求に関しては特に悪質な嘘つきであるようです。これは、USBメモリスティック上のSQLiteデータベースに大規模なトランザクションをコミットすることで簡単に確認できます。COMMIT コマンドは比較的早く戻ってきます。これは、メモリスティックがオペレーティングシステムに伝え、オペレーティングシステムが SQLite にすべてのコンテンツが永続的ストレージに安全に保存されていることを伝えたことを示していますが、メモリスティックの端にある LED はさらに数秒間点滅し続けます。LEDが点滅している間にメモリースティックを引き抜くと、データベースが破損することがよくあります。</target>
        </trans-unit>
        <trans-unit id="b0138e4f9dc0aacc367a1f86d8e4506b943320e8" translate="yes" xml:space="preserve">
          <source>USING</source>
          <target state="translated">USING</target>
        </trans-unit>
        <trans-unit id="4a2b12a8f9db417e4cc5f36a3e1c2fec1469fe7f" translate="yes" xml:space="preserve">
          <source>UTC timestamp, in seconds since the UNIX epoch (an integer).</source>
          <target state="translated">UNIX エポックからの UTC タイムスタンプ (秒単位)(整数)。</target>
        </trans-unit>
        <trans-unit id="28ef7752ac0283beed8e66a2b5b204db183549fd" translate="yes" xml:space="preserve">
          <source>Unallocated space</source>
          <target state="translated">未割当スペース</target>
        </trans-unit>
        <trans-unit id="b0b4a5a01660223c1f1c6d19e4a89997fe5e3325" translate="yes" xml:space="preserve">
          <source>Unary &quot;-&quot;</source>
          <target state="translated">単項の「-」。</target>
        </trans-unit>
        <trans-unit id="6bfa68ac4d2f61f36caa0def08a4a0095686e16a" translate="yes" xml:space="preserve">
          <source>Undefined BEFORE trigger behavior</source>
          <target state="translated">未定義のBEFOREトリガ動作</target>
        </trans-unit>
        <trans-unit id="9e37e5dd8e036cac3e0f290adf0e16da58e3ffe8" translate="yes" xml:space="preserve">
          <source>Undefined behavior checks</source>
          <target state="translated">未定義の動作チェック</target>
        </trans-unit>
        <trans-unit id="79dfa4a9456d7e99f2303579887d4ea94c961a44" translate="yes" xml:space="preserve">
          <source>Under Unix, an &lt;b&gt;sqlite*&lt;/b&gt; pointer should not be carried across a &lt;b&gt;fork()&lt;/b&gt; system call into the child process. The child process should open its own copy of the database after the &lt;b&gt;fork()&lt;/b&gt;.</source>
          <target state="translated">Unixでは、&lt;b&gt;sqlite *&lt;/b&gt;ポインターを&lt;b&gt;fork（）&lt;/b&gt;システムコールを介して子プロセスに&lt;b&gt;渡す&lt;/b&gt;ことはできません。子プロセスは、&lt;b&gt;fork（）の&lt;/b&gt;後で独自のデータベースのコピーを開く必要があります。</target>
        </trans-unit>
        <trans-unit id="7887974e08825eb481696126029ce641dab388bf" translate="yes" xml:space="preserve">
          <source>Under Unix, you should not carry an open SQLite database across a fork() system call into the child process.</source>
          <target state="translated">Unix では、オープンな SQLite データベースを fork()システムコールを越えて子プロセスに持ち込むべきではありません。</target>
        </trans-unit>
        <trans-unit id="d2245919272810b035145426205e128fae32a19a" translate="yes" xml:space="preserve">
          <source>Under most circumstances, the original LIKE or GLOB operator is still tested against each input row even if the virtual terms are used to constrain an index. This is because we do not know what additional constraints may be imposed by characters to the right of the</source>
          <target state="translated">ほとんどの状況下では、仮想用語がインデックスを制約するために使用されている場合でも、元のLIKEまたはGLOB演算子は各入力行に対してテストされます。の右にある文字によってどのような追加の制約が課されるかわからないからです。</target>
        </trans-unit>
        <trans-unit id="0aafde4f0303b5c58e56ca1461baa83fd0408041" translate="yes" xml:space="preserve">
          <source>Unfortunately, SQLite contains many branch instructions that help the code run faster without changing the output. Such branches generate false-positives during mutation testing. As an example, consider the following &lt;a href=&quot;https://www.sqlite.org/src/artifact/55b5fb474?ln=55-62&quot;&gt;hash function&lt;/a&gt; used to accelerate table-name lookup:</source>
          <target state="translated">残念ながら、SQLiteには、出力を変更せずにコードをより高速に実行できるようにする多くの分岐命令が含まれています。このようなブランチは、変異テスト中に偽陽性を生成します。例として、テーブル名のルックアップを高速化&lt;a href=&quot;https://www.sqlite.org/src/artifact/55b5fb474?ln=55-62&quot;&gt;する&lt;/a&gt;ために使用される次のハッシュ関数を考えます。</target>
        </trans-unit>
        <trans-unit id="0c6793d3cab2ac8df02302e6322b00044082495f" translate="yes" xml:space="preserve">
          <source>Unfortunately, algorithm-2 is slower than algorithm-1 in this application.</source>
          <target state="translated">残念ながら、このアプリケーションでは、アルゴリズム2はアルゴリズム1よりも遅い。</target>
        </trans-unit>
        <trans-unit id="fcfb2377607479ca817d6a09b03610de66f64da2" translate="yes" xml:space="preserve">
          <source>Unfortunately, even though virtual tables are ignored by default, any &lt;a href=&quot;fts3#*shadowtab&quot;&gt;underlying database tables&lt;/a&gt; that they create in order to store data within the database are not, and &lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt; will include add these to any RBU database. For this reason, users attempting to use sqldiff to create RBU updates to apply to target databases with one or more virtual tables will likely have to run sqldiff using the --table option separately for each table to update in the target database.</source>
          <target state="translated">残念ながら、仮想テーブルはデフォルトで無視されますが、&lt;a href=&quot;fts3#*shadowtab&quot;&gt;データベース&lt;/a&gt;内にデータを格納するために仮想テーブルが作成する基になるデータベーステーブルは無視されません&lt;a href=&quot;sqldiff&quot;&gt;。sqldiff&lt;/a&gt;はこれらをRBUデータベースに追加します。このため、sqldiffを使用して1つ以上の仮想テーブルを持つターゲットデータベースに適用するRBU更新を作成しようとするユーザーは、ターゲットデータベースで更新するテーブルごとに--tableオプションを使用してsqldiffを実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="c58a4f6c2a537b213079cd1adcaa6b2001643e9a" translate="yes" xml:space="preserve">
          <source>Unfortunately, most consumer-grade mass storage devices lie about syncing. Disk drives will report that content is safely on persistent media as soon as it reaches the track buffer and before actually being written to oxide. This makes the disk drives seem to operate faster (which is vitally important to the manufacturer so that they can show good benchmark numbers in trade magazines). And in fairness, the lie normally causes no harm, as long as there is no power loss or hard reset prior to the track buffer actually being written to oxide. But if a power loss or hard reset does occur, and if that results in content that was written after a sync reaching oxide while content written before the sync is still in a track buffer, then database corruption can occur.</source>
          <target state="translated">残念ながら、ほとんどのコンシューマーグレードの大容量記憶装置は、同期について嘘をついています。ディスクドライブは、コンテンツがトラックバッファに到達するとすぐに、そして実際に酸化物に書き込まれる前に、コンテンツが永続的なメディアに安全に保存されていると報告します。これにより、ディスクドライブは高速に動作しているように見えます(これは、業界誌に良いベンチマーク数字を示すために、メーカーにとって極めて重要なことです)。公平に考えれば、トラックバッファが実際に酸化物に書き込まれる前に電源損失やハードリセットが発生しない限り、通常は嘘をついても害はありません。しかし、電源損失やハードリセットが発生し、その結果、同期前に書き込まれたコンテンツがトラックバッファに残っている間に、同期後に書き込まれたコンテンツがオキサイドに到達した場合、データベースの破損が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="af520d1880e5ee3cdc82e50d4d1525585fc7beb9" translate="yes" xml:space="preserve">
          <source>Unfortunately, the NGQP caused a performance regression in Fossil.</source>
          <target state="translated">残念ながらNGQPのせいでフォッシルのパフォーマンスが後退してしまいました。</target>
        </trans-unit>
        <trans-unit id="7536fed3548161a0855cd29750230303476e4484" translate="yes" xml:space="preserve">
          <source>Unfortunately, the no-limits policy has been shown to create problems. Because the upper bounds were not well defined, they were not tested, and bugs (including possible security exploits) were often found when pushing SQLite to extremes. For this reason, newer versions of SQLite have well-defined limits and those limits are tested as part of the &lt;a href=&quot;testing&quot;&gt;test suite&lt;/a&gt;.</source>
          <target state="translated">残念ながら、制限なしポリシーは問題を引き起こすことが示されています。上限は明確に定義されていないため、テストされておらず、SQLiteを極端に押し上げると、バグ（セキュリティの悪用の可能性を含む）が頻繁に見つかりました。このため、新しいバージョンのSQLiteには明確に定義された制限があり、それらの制限は&lt;a href=&quot;testing&quot;&gt;テストスイートの&lt;/a&gt;一部としてテストされます。</target>
        </trans-unit>
        <trans-unit id="154cee1be1782349508f9f52cb47759ac0528fca" translate="yes" xml:space="preserve">
          <source>Unfortunately, the no-limits policy has been shown to create problems. Because the upper bounds were not well defined, they were not tested, and bugs were often found when pushing SQLite to extremes. For this reason, versions of SQLite since about release 3.5.8 (2008-04-16) have well-defined limits, and those limits are tested as part of the &lt;a href=&quot;testing&quot;&gt;test suite&lt;/a&gt;.</source>
          <target state="translated">Unfortunately, the no-limits policy has been shown to create problems. Because the upper bounds were not well defined, they were not tested, and bugs were often found when pushing SQLite to extremes. For this reason, versions of SQLite since about release 3.5.8 (2008-04-16) have well-defined limits, and those limits are tested as part of the &lt;a href=&quot;testing&quot;&gt;test suite&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="9809fad4d13ccafd43c46a06696bc5f74c1752de" translate="yes" xml:space="preserve">
          <source>Unfortunately, the query plan computed by NN for TPC-H Q8 is not optimal. The plan computed using NN is R-N1-N2-S-C-O-L-P with a cost of 36.92. The notation in the previous sentence means that the R table is run in the outer loop, N1 is in the next inner loop, N2 is in the third loop, and so forth down to P which is in the inner-most loop. The shortest path through the graph (as found via exhaustive search) is P-L-O-C-N1-R-S-N2 with a cost of 27.38. The difference might not seem like much, but remember that the costs are logarithmic, so the shortest path is nearly 750 times faster than that path found using the NN heuristic.</source>
          <target state="translated">残念ながら、TPC-H Q8のためにNNで計算されたクエリプランは最適ではありません。NNを用いて計算されたプランはR-N1-N2-S-C-O-L-Pで、コストは36.92です。前の文の表記は、Rテーブルが外側のループで実行され、N1が次の内側のループで実行され、N2が3番目のループで実行され、そしてPが一番内側のループで実行されることを意味しています。グラフを通る最短のパスは(徹底的な探索によって発見された)P-L-O-C-N1-R-S-N2で、コストは27.38です。この差はそれほど大きくないように見えるかもしれませんが、コストは対数であることを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="12b20c37115e65b5f7d7e36cc94465f524bad30b" translate="yes" xml:space="preserve">
          <source>Uniform Resource Identifiers</source>
          <target state="translated">統一資源識別子</target>
        </trans-unit>
        <trans-unit id="77df08227da6ac685804effa87058e13d84c4065" translate="yes" xml:space="preserve">
          <source>Unique constraint</source>
          <target state="translated">ユニークな制約</target>
        </trans-unit>
        <trans-unit id="aa980d194e964e7fb7f97273f5336434b107da41" translate="yes" xml:space="preserve">
          <source>Unique index</source>
          <target state="translated">シングルインデックス</target>
        </trans-unit>
        <trans-unit id="7157e0defd66f64a5eef1f6b25ed305c7ea76e58" translate="yes" xml:space="preserve">
          <source>Unix builds come with multiple built-in VFSes. The default VFS for unix is called &quot;unix&quot; and is used in most applications. Other VFSes that might be found in unix (depending on compile-time options) include:</source>
          <target state="translated">Unixのビルドには、複数のビルトインVFSが付属しています。unix のデフォルト VFS は「unix」と呼ばれ、ほとんどのアプリケーションで使用されています。(コンパイル時のオプションにもよりますが)unix にある他の VFS には、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="fc9481ccc42310377001eaf4b65f0ba7f43291d9" translate="yes" xml:space="preserve">
          <source>Unless</source>
          <target state="translated">Unless</target>
        </trans-unit>
        <trans-unit id="e08358316619a161ecbcf33073f1d600c7a3d1d8" translate="yes" xml:space="preserve">
          <source>Unless SQLite is running in &quot;auto_vacuum=FULL&quot; mode, when a large amount of data is deleted from the database file it leaves behind empty space, or &quot;free&quot; database pages. This means the database file might be larger than strictly necessary. Running VACUUM to rebuild the database reclaims this space and reduces the size of the database file.</source>
          <target state="translated">SQLiteが &quot;auto_vacuum=FULL &quot;モードで実行されていない限り、データベースファイルから大量のデータが削除されると、空のスペース、つまり &quot;空き &quot;のデータベースページが残ってしまいます。これは、データベースファイルが厳密に必要以上に大きくなる可能性があることを意味します。データベースを再構築するためにVACUUMを実行すると、このスペースを取り戻し、データベースファイルのサイズを小さくすることができます。</target>
        </trans-unit>
        <trans-unit id="0e73f60b051af43064d6e0d8d691c92bf067b075" translate="yes" xml:space="preserve">
          <source>Unless a specific tokenizer is specified as part of the CREATE VIRTUAL TABLE statement used to create the FTS table, the default tokenizer, &quot;simple&quot;, is used. The simple tokenizer extracts tokens from a document or basic FTS full-text query according to the following rules:</source>
          <target state="translated">FTS テーブルを作成するために使用される CREATE VIRTUAL TABLE 文の一部として特定のトークナイザーが指定されていない限り、デフォルトのトークナイザーである &quot;simple&quot; が使用されます。simple トークンナイザは、以下のルールに従って、文書または基本的なFTSフルテキストクエリからトークンを抽出します。</target>
        </trans-unit>
        <trans-unit id="5fdc85037d052204b60739c85a692574cdca8812" translate="yes" xml:space="preserve">
          <source>Unless deadlock is detected (see below), sqlite3_unlock_notify() always returns SQLITE_OK.</source>
          <target state="translated">デッドロックが検出されない限り(以下を参照)、sqlite3_unlock_notify()は常にSQLITE_OKを返します。</target>
        </trans-unit>
        <trans-unit id="7c4feec28833f0a64ab53ef0f49205604d9d8edc" translate="yes" xml:space="preserve">
          <source>Unless it is a CREATE TABLE ... AS SELECT statement, a CREATE TABLE includes one or more &lt;a href=&quot;syntax/column-def&quot;&gt;column definitions&lt;/a&gt;, optionally followed by a list of &lt;a href=&quot;syntax/table-constraint&quot;&gt;table constraints&lt;/a&gt;. Each column definition consists of the name of the column, optionally followed by the declared type of the column, then one or more optional &lt;a href=&quot;syntax/column-constraint&quot;&gt;column constraints&lt;/a&gt;. Included in the definition of &quot;column constraints&quot; for the purposes of the previous statement are the COLLATE and DEFAULT clauses, even though these are not really constraints in the sense that they do not restrict the data that the table may contain. The other constraints - NOT NULL, CHECK, UNIQUE, PRIMARY KEY and FOREIGN KEY constraints - impose restrictions on the table data.</source>
          <target state="translated">Unless it is a CREATE TABLE ... AS SELECT statement, a CREATE TABLE includes one or more &lt;a href=&quot;syntax/column-def&quot;&gt;column definitions&lt;/a&gt;, optionally followed by a list of &lt;a href=&quot;syntax/table-constraint&quot;&gt;table constraints&lt;/a&gt;. Each column definition consists of the name of the column, optionally followed by the declared type of the column, then one or more optional &lt;a href=&quot;syntax/column-constraint&quot;&gt;column constraints&lt;/a&gt;. Included in the definition of &quot;column constraints&quot; for the purposes of the previous statement are the COLLATE and DEFAULT clauses, even though these are not really constraints in the sense that they do not restrict the data that the table may contain. The other constraints - NOT NULL, CHECK, UNIQUE, PRIMARY KEY and FOREIGN KEY constraints - impose restrictions on the table data.</target>
        </trans-unit>
        <trans-unit id="318eb4656e47b06b6ea5260cd43d217bcb29a47f" translate="yes" xml:space="preserve">
          <source>Unless it is a CREATE TABLE ... AS SELECT statement, a CREATE TABLE includes one or more &lt;a href=&quot;syntax/column-def&quot;&gt;column definitions&lt;/a&gt;, optionally followed by a list of &lt;a href=&quot;syntax/table-constraint&quot;&gt;table constraints&lt;/a&gt;. Each column definition consists of the name of the column, optionally followed by the declared type of the column, then one or more optional &lt;a href=&quot;syntax/column-constraint&quot;&gt;column constraints&lt;/a&gt;. Included in the definition of &quot;column constraints&quot; for the purposes of the previous statement are the COLLATE and DEFAULT clauses, even though these are not really constraints in the sense that they do not restrict the data that the table may contain. The other constraints - NOT NULL, CHECK, UNIQUE, PRIMARY KEY and FOREIGN KEY constraints - impose restrictions on the tables data, and are are described under &lt;a href=&quot;lang_createtable#constraints&quot;&gt;SQL Data Constraints&lt;/a&gt; below.</source>
          <target state="translated">CREATE TABLE ... AS SELECTステートメントでない限り、CREATE TABLEには1つ以上の&lt;a href=&quot;syntax/column-def&quot;&gt;列定義が&lt;/a&gt;含まれ、オプションで&lt;a href=&quot;syntax/table-constraint&quot;&gt;テーブル制約の&lt;/a&gt;リストが続きます。各列の定義は、列の名前で構成され、オプションで、列の宣言された型、オプションで1つ以上のオプションの&lt;a href=&quot;syntax/column-constraint&quot;&gt;列制約が&lt;/a&gt;続きます。前のステートメントの目的で「列制約」の定義に含まれているのは、COLLATE句とDEFAULT句ですが、テーブルに含まれるデータを制限しないという意味では実際には制約ではありません。その他の制約-NOT NULL、CHECK、UNIQUE、PRIMARY KEYおよびFOREIGN KEY制約-テーブルデータに制限を課し、&lt;a href=&quot;lang_createtable#constraints&quot;&gt;SQLデータ制約で&lt;/a&gt;説明されています 未満。</target>
        </trans-unit>
        <trans-unit id="1c00ba237aa117de710c9323f816c96f6ada7a01" translate="yes" xml:space="preserve">
          <source>Unless it returns SQLITE_MISUSE, the sqlite3_wal_checkpoint_v2() interface sets the error information that is queried by &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;.</source>
          <target state="translated">SQLITE_MISUSEを返さない限り、sqlite3_wal_checkpoint_v2（）インターフェースは&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;と&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;によってクエリされたエラー情報を設定します。</target>
        </trans-unit>
        <trans-unit id="4e06b73ee3affa8214cc1405f997b2bb6e5fc2af" translate="yes" xml:space="preserve">
          <source>Unless it returns SQLITE_MISUSE, the sqlite3_wal_checkpoint_v2() interface sets the error information that is queried by &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;.</source>
          <target state="translated">SQLITE_MISUSEを返さない限り、sqlite3_wal_checkpoint_v2（）インターフェースは&lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;と&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;によってクエリされたエラー情報を設定します。</target>
        </trans-unit>
        <trans-unit id="4591266e2017f729f7aff5d0aced794f6644a4c3" translate="yes" xml:space="preserve">
          <source>Unless it returns SQLITE_MISUSE, this function sets the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">SQLITE_MISUSEを返さない限り、この関数は、&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;と&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;および関連関数を介してアクセス可能な&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;エラーコードとメッセージを設定します。</target>
        </trans-unit>
        <trans-unit id="0e4971f6a57c5c65a9a1ae31e9cf2a3e92d4934e" translate="yes" xml:space="preserve">
          <source>Unless it returns SQLITE_MISUSE, this function sets the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">SQLITE_MISUSEを返さない限り、この関数は、&lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;と&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;および関連する関数を介してアクセス可能な&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;エラーコードとメッセージを設定します。</target>
        </trans-unit>
        <trans-unit id="b37e8216d0e44ec2efee716d4c9dd7d3e0183bf7" translate="yes" xml:space="preserve">
          <source>Unless the &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt; is applied, if a subquery appears in the FROM clause of a SELECT statement, SQLite can either run the subquery and stores the results in a temporary table, or it can run the subquery as a co-routine. The following query is an example of the latter. The subquery is run by a co-routine. The outer query blocks whenever it needs another row of input from the subquery. Control switches to the co-routine which produces the desired output row, then control switches back to the main routine which continues processing.</source>
          <target state="translated">&lt;a href=&quot;optoverview#flattening&quot;&gt;フラット化の最適化&lt;/a&gt;が適用されない限り、サブクエリがSELECTステートメントのFROM句にある場合、SQLiteはサブクエリを実行して結果を一時テーブルに格納するか、サブクエリをコルーチンとして実行できます。次のクエリは後者の例です。サブクエリはコルーチンによって実行されます。外側のクエリは、サブクエリからの別の入力行が必要な場合は常にブロックします。制御は、目的の出力行を生成するコルーチンに切り替え、次に制御は、処理を続けるメインルーチンに戻ります。</target>
        </trans-unit>
        <trans-unit id="6debb16b797e55251f765dccb022c7b2f7c44222" translate="yes" xml:space="preserve">
          <source>Unlike most SQL databases, SQLite does not restrict the type of data that may be inserted into a column based on the columns declared type. Instead, SQLite uses &lt;a href=&quot;datatype3&quot;&gt;dynamic typing&lt;/a&gt;. The declared type of a column is used to determine the &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt; of the column only.</source>
          <target state="translated">ほとんどのSQLデータベースとは異なり、SQLiteは、宣言された列の型に基づいて列に挿入できるデータの型を制限しません。代わりに、SQLiteは&lt;a href=&quot;datatype3&quot;&gt;動的型付けを&lt;/a&gt;使用します。列の宣言されたタイプは、列の&lt;a href=&quot;datatype3#affinity&quot;&gt;類似性&lt;/a&gt;のみを決定するために使用されます。</target>
        </trans-unit>
        <trans-unit id="8fc35fdda18e32589afbc6422311960ed986aa1d" translate="yes" xml:space="preserve">
          <source>Unlike most other SQL implementations, SQLite does not have a separate BOOLEAN data type. Instead, TRUE and FALSE are (normally) represented as integers 1 and 0, respectively. This does not seem to cause many problems, as we seldom get complaints about it. But it is important to recognize.</source>
          <target state="translated">他のほとんどの SQL 実装とは異なり、SQLite には個別の BOOLEAN データ型がありません。その代わりに、TRUEとFALSEは(通常は)それぞれ1と0の整数で表現されます。これについての苦情が出ることはほとんどないので、多くの問題を引き起こすことはないようです。しかし、認識することは重要です。</target>
        </trans-unit>
        <trans-unit id="19f905f254ee85ddda7a69f550a125cf0e71bdf9" translate="yes" xml:space="preserve">
          <source>Unlike option values and column names, SQL text literals intended as tokenizers must be quoted using single quote characters. For example:</source>
          <target state="translated">オプション値やカラム名とは異なり、トークナイザーとして使用するSQLテキストリテラルはシングルクォーテーション文字を使用しなければなりません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="4a575ebe60947d8ad09098452667c713c7ab1bb2" translate="yes" xml:space="preserve">
          <source>Unlike ordinary functions, window functions cannot use the DISTINCT keyword. Also, Window functions may only appear in the result set and in the ORDER BY clause of a SELECT statement.</source>
          <target state="translated">通常の関数とは異なり、ウィンドウ関数は DISTINCT キーワードを使用できません。また、ウィンドウ関数は、結果セットとSELECT文のORDER BY句にのみ現れることができます。</target>
        </trans-unit>
        <trans-unit id="2f67d962c33cac256671fd15a0b1070b30d60167" translate="yes" xml:space="preserve">
          <source>Unlike other OMIT options which make the SQLite library smaller, this option actually increases the size of SQLite and makes it run a little slower. Only use this option if SQLite is being built for an embedded target that does not support WSD.</source>
          <target state="translated">SQLite ライブラリを小さくする他の OMIT オプションとは異なり、このオプションは実際には SQLite のサイズを大きくし、動作を少し遅くします。SQLite が WSD をサポートしていない組み込みターゲット用にビルドされている場合にのみ、このオプションを使用してください。</target>
        </trans-unit>
        <trans-unit id="0fc95e0cae6fea6934c86fc94073155aecd6590f" translate="yes" xml:space="preserve">
          <source>Unlike the other journaling modes, &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=WAL&lt;/a&gt; is persistent. If a process sets WAL mode, then closes and reopens the database, the database will come back in WAL mode. In contrast, if a process sets (for example) PRAGMA journal_mode=TRUNCATE and then closes and reopens the database will come back up in the default rollback mode of DELETE rather than the previous TRUNCATE setting.</source>
          <target state="translated">他のジャーナリングモードとは異なり、&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = WAL&lt;/a&gt;は永続的です。プロセスがWALモードを設定してからデータベースを閉じて再度開くと、データベースはWALモードに戻ります。対照的に、プロセスが（たとえば）PRAGMA journal_mode = TRUNCATEを設定し、その後データベースを閉じて再度開くと、以前のTRUNCATE設定ではなく、DELETEのデフォルトのロールバックモードでバックアップが返されます。</target>
        </trans-unit>
        <trans-unit id="3542ed2ff90a29869b311f3e2e4680675b20b4a0" translate="yes" xml:space="preserve">
          <source>Unlike the rollback journals, the master journal does not contain any original database page content. Instead, the master journal contains the full pathnames for rollback journals for every database that is participating in the transaction.</source>
          <target state="translated">ロールバックジャーナルとは異なり、マスタージャーナルにはオリジナルのデータベースページコンテンツは含まれません。その代わり、マスタージャーナルには、トランザクションに参加しているすべてのデータベースのロールバックジャーナルのフルパス名が含まれています。</target>
        </trans-unit>
        <trans-unit id="3dcad4a4f47bac4601655442badbb882f7ce80cb" translate="yes" xml:space="preserve">
          <source>Unlike the rollback journals, the super-journal does not contain any original database page content. Instead, the super-journal contains the full pathnames for rollback journals for every database that is participating in the transaction.</source>
          <target state="translated">ロールバックジャーナルとは異なり、スーパージャーナルにはオリジナルのデータベースページコンテンツは含まれません。代わりに、スーパージャーナルには、トランザクションに参加しているすべてのデータベースのロールバックジャーナルの完全なパス名が含まれています。</target>
        </trans-unit>
        <trans-unit id="02b418069c25f685f24a747aa6e2e42a4b27661e" translate="yes" xml:space="preserve">
          <source>Unlike the xFilter argument, xConflict may not be passed NULL. The results of passing anything other than a valid function pointer as the xConflict argument are undefined.</source>
          <target state="translated">xFilter 引数とは異なり、xConflict は NULL を渡すことはできません。有効な関数ポインタ以外を xConflict 引数に渡した場合の結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="8cc38ff6e04932db1753dbe47e43a46b66cca7d3" translate="yes" xml:space="preserve">
          <source>Unlinked database files</source>
          <target state="translated">リンクされていないデータベースファイル</target>
        </trans-unit>
        <trans-unit id="2e66bd886206de5f2b17ce23c8df1ed8d25d65b5" translate="yes" xml:space="preserve">
          <source>Unlock Notification</source>
          <target state="translated">通知のロックを解除する</target>
        </trans-unit>
        <trans-unit id="1129dcb047456b603be7d9e26492484e1ef87d61" translate="yes" xml:space="preserve">
          <source>Unlock the btree to which cursor P1 is pointing so that it can be written by other cursors.</source>
          <target state="translated">カーソルP1が指しているbtreeのロックを解除して、他のカーソルで書き込めるようにします。</target>
        </trans-unit>
        <trans-unit id="dc88710cf7a309e590112924b4f0f18efd64749f" translate="yes" xml:space="preserve">
          <source>Unnecessary OP_IsNull, OP_Affinity, and OP_MustBeInt VDBE opcodes are suppressed</source>
          <target state="translated">不要なOP_IsNull、OP_Affinity、およびOP_MustBeInt VDBEオペコードは抑制されます。</target>
        </trans-unit>
        <trans-unit id="b028e3e382d48044cb8ac6852f58d5f9280df947" translate="yes" xml:space="preserve">
          <source>Unpinning a database page.</source>
          <target state="translated">データベースページのピン留めを解除します。</target>
        </trans-unit>
        <trans-unit id="4d158e591edd9ba39fa4326da9d09c5874218ca5" translate="yes" xml:space="preserve">
          <source>Unregister a VFS with the sqlite3_vfs_unregister() interface. If the default VFS is unregistered, another VFS is chosen as the default. The choice for the new VFS is arbitrary.</source>
          <target state="translated">sqlite3_vfs_unregister()インタフェースを使用してVFSの登録を解除します。デフォルトのVFSが登録されていない場合、別のVFSがデフォルトとして選択されます。新しいVFSの選択は任意です。</target>
        </trans-unit>
        <trans-unit id="ef3bbadff8cc850c1a14d5bac3c132d39dd7aef1" translate="yes" xml:space="preserve">
          <source>Unsigned integer counter, incremented with each transaction</source>
          <target state="translated">符号なし整数カウンタ、トランザクションごとにインクリメントされます。</target>
        </trans-unit>
        <trans-unit id="3c2ab651c10dcd781af9d81861dc05c7e00cd0e4" translate="yes" xml:space="preserve">
          <source>Unused bytes of on the current page or btree</source>
          <target state="translated">現在のページまたはbtreeの未使用バイト数</target>
        </trans-unit>
        <trans-unit id="3ae451c5b9e60f30746c607b23e33192b93fe52d" translate="yes" xml:space="preserve">
          <source>Unused padding space. Must be zero.</source>
          <target state="translated">未使用のパディングスペース。ゼロでなければなりません。</target>
        </trans-unit>
        <trans-unit id="e3a057d9b649ee6d00a614b6de91fb18fda426f0" translate="yes" xml:space="preserve">
          <source>Unused pages in the database file are stored on a freelist. The 4-byte big-endian integer at offset 32 stores the page number of the first page of the freelist, or zero if the freelist is empty. The 4-byte big-endian integer at offset 36 stores stores the total number of pages on the freelist.</source>
          <target state="translated">デー タ ベース フ ァ イ ル内の未使用ページはフリー リ ス ト に格納 さ れます。オフセット32の4バイトビッグエンディアン整数は、フリーリストの最初のページのページ番号を格納し、フリーリストが空の場合は0を格納する。オフセット36における4バイトのビッグエンディアン整数は、フリーリスト上のページの総数を格納する。</target>
        </trans-unit>
        <trans-unit id="533ec3a09a391d616af998c213244ec0a1e5a3cc" translate="yes" xml:space="preserve">
          <source>Unused space reserved for further expansion.</source>
          <target state="translated">さらなる拡張のために確保された未使用スペース。</target>
        </trans-unit>
        <trans-unit id="c494dd09b1047ff61f225fbdc40bf010e62739a8" translate="yes" xml:space="preserve">
          <source>Unused space set aside for 8 file locks.</source>
          <target state="translated">8つのファイルロック用の未使用スペースを確保。</target>
        </trans-unit>
        <trans-unit id="6ccb1ae240f52b5b4ac6a0a3624ae84ecc9e72d1" translate="yes" xml:space="preserve">
          <source>Up to 32K columns in a table and unlimited rows</source>
          <target state="translated">テーブル内の列数は最大32K、行数は無制限</target>
        </trans-unit>
        <trans-unit id="6b12c595d758d017b4f8b2df393f1e4bc59a0386" translate="yes" xml:space="preserve">
          <source>Up to 64-way joins</source>
          <target state="translated">最大64ウェイまで結合</target>
        </trans-unit>
        <trans-unit id="cb305c54c2dd32659178ffaaae86eb202de286b0" translate="yes" xml:space="preserve">
          <source>Upcoming maintenance releases announced on the sqlite-users and sqlite-dev &lt;a href=&quot;https://sqlite.org/support.html#mailinglists&quot;&gt;mailing lists&lt;/a&gt; about two weeks prior to the anticipated release. Approximately one week prior to release, the lead developer declares &quot;pencils down&quot; after which only bug-fix check-ins are allowed on trunk. A new &lt;a href=&quot;https://sqlite.org/checklists&quot;&gt;release checklist&lt;/a&gt; is created and updated as needed. As items of the checklist are verified, they are checked off and turn green. The release occurs when all elements of the checklist are green. That process normally takes about a week.</source>
          <target state="translated">予想されるリリースの約2週間前に、sqlite-usersおよびsqlite-dev &lt;a href=&quot;https://sqlite.org/support.html#mailinglists&quot;&gt;メーリングリストで&lt;/a&gt;発表される今後のメンテナンスリリース。リリースの約1週間前に、主要開発者が「鉛筆ダウン」を宣言します。その後、トランクではバグ修正チェックインのみが許可されます。新しい&lt;a href=&quot;https://sqlite.org/checklists&quot;&gt;リリースチェックリスト&lt;/a&gt;が作成され、必要に応じて更新されます。チェックリストの項目が確認されると、それらはオフになり、緑色になります。チェックリストのすべての要素が緑色の場合、リリースが発生します。通常、このプロセスには約1週間かかります。</target>
        </trans-unit>
        <trans-unit id="8621615ea5e13954070618a81964dc62abe12dff" translate="yes" xml:space="preserve">
          <source>Update 2003-07-13:</source>
          <target state="translated">2003-07-13を更新しました。</target>
        </trans-unit>
        <trans-unit id="e6d951c5abc007e402d1496a11b3024eba850b99" translate="yes" xml:space="preserve">
          <source>Update cygwin interfaces to omit deprecated API calls.</source>
          <target state="translated">非推奨のAPIコールを省略するためにcygwinインターフェースを更新しました。</target>
        </trans-unit>
        <trans-unit id="f8692a500a2140ecfbdf4ae0b2b2fa362f3e4d18" translate="yes" xml:space="preserve">
          <source>Update on 2018-11-24: This section was important when the NGQP was new. But five years have elapsed, the NGQP has been deployed successfully to billions of devices, and everyone has upgraded. The upgrade hazard has vanished. This section is retained for historical reference only. Modern reads can skip ahead to the &lt;a href=&quot;queryplanner-ng#howtofix&quot;&gt;query planner checklist&lt;/a&gt;.</source>
          <target state="translated">2018-11-24の更新：NGQPが新しい場合、このセクションは重要でした。しかし、5年が経過し、NGQPは数十億のデバイスに正常に展開され、全員がアップグレードしました。アップグレードの危険性はなくなりました。このセクションは、履歴参照のためにのみ保持されています。最新の読み取りは、&lt;a href=&quot;queryplanner-ng#howtofix&quot;&gt;クエリプランナーチェックリスト&lt;/a&gt;までスキップできます。</target>
        </trans-unit>
        <trans-unit id="f7a5f87f2cf88e6e7e5e6ca7b270c03397b5d3d9" translate="yes" xml:space="preserve">
          <source>Update or delete the row in the parent table,</source>
          <target state="translated">親テーブルの行を更新または削除します。</target>
        </trans-unit>
        <trans-unit id="eadf20cb1fcf64b516be4d0e9aca0f806ea0946c" translate="yes" xml:space="preserve">
          <source>Update the &quot;.import&quot; command in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; to support multi-line fields and correct RFC-4180 quoting and to issue warning and/or error messages if the input text is not strictly RFC-4180 compliant.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;コマンドラインシェル&lt;/a&gt;の「.import」コマンドを更新して、複数行フィールドをサポートし、RFC-4180の引用を修正し、入力テキストがRFC-4180に厳密に準拠していない場合に警告メッセージやエラーメッセージを発行します。</target>
        </trans-unit>
        <trans-unit id="95e555f2b3f8baa46d6d1c3fa11a385e51f02eb2" translate="yes" xml:space="preserve">
          <source>Update the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; to make use of the enhanced virtual table interface.</source>
          <target state="translated">拡張された仮想テーブルインターフェイスを使用するように&lt;a href=&quot;rtree&quot;&gt;Rツリー拡張&lt;/a&gt;を更新します。</target>
        </trans-unit>
        <trans-unit id="afd4ef5f9984771affe8a02ef21dc1f52c746e3a" translate="yes" xml:space="preserve">
          <source>Update the NULL-handling documentation.</source>
          <target state="translated">NULLハンドリングのドキュメントを更新しました。</target>
        </trans-unit>
        <trans-unit id="8eb7bca41bb60469d609f31a7c94a8af987dd0b7" translate="yes" xml:space="preserve">
          <source>Update the _FILE_OFFSET_BITS macro so that builds work again on QNX.</source>
          <target state="translated">マクロ _FILE_OFFSET_BITS を更新して、QNX でビルドが再び動作するようにしました。</target>
        </trans-unit>
        <trans-unit id="83db802c5575f2f5c375cb1b62089d3a370412c6" translate="yes" xml:space="preserve">
          <source>Update the banner on the command-line shell to alert novice users when they are using an ephemeral in-memory database.</source>
          <target state="translated">刹那的なインメモリデータベースを使用しているときに初心者ユーザーに警告するために、コマンドラインシェルのバナーを更新しました。</target>
        </trans-unit>
        <trans-unit id="5deccb253aff130770ec3068052cf362ce9ebe27" translate="yes" xml:space="preserve">
          <source>Update the built-in &lt;a href=&quot;fts3&quot;&gt;FTS3/FTS4&lt;/a&gt; and &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; virtual tables to support &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; clauses and &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt;.</source>
          <target state="translated">組み込みの&lt;a href=&quot;fts3&quot;&gt;FTS3 / FTS4&lt;/a&gt;および&lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;仮想テーブルを更新して、&lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;句と&lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt;をサポートします。</target>
        </trans-unit>
        <trans-unit id="b504122b8dfef94ab33eb2666fd1889d16053291" translate="yes" xml:space="preserve">
          <source>Update the text of error messages returned by &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; for some error codes.</source>
          <target state="translated">&lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg（）が&lt;/a&gt;返すエラーメッセージのテキストを、いくつかのエラーコードについて更新します。</target>
        </trans-unit>
        <trans-unit id="f19ef97f712dc9336cd9881c1cc678760d93cdf8" translate="yes" xml:space="preserve">
          <source>Update: As of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_29_0.html&quot;&gt;version 3.29.0&lt;/a&gt; (2019-07-10) the use of AFL has been superceded by the new &lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;dbsqlfuzz&lt;/a&gt; fuzzer described below.</source>
          <target state="translated">更新：SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_29_0.html&quot;&gt;バージョン3.29.0&lt;/a&gt;（2019-07-10）以降、AFLの使用は、以下で説明する新しい&lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;dbsqlfuzz&lt;/a&gt;ファザーに置き換えられました。</target>
        </trans-unit>
        <trans-unit id="c202e0c1d72e2322ab1803ee32b5877979d2de60" translate="yes" xml:space="preserve">
          <source>Update: New measurements for SQLite version 3.19.0 (2017-05-22) show that SQLite is about &lt;a href=&quot;fasterthanfs&quot;&gt;35% faster&lt;/a&gt; than direct disk I/O for both reads and writes of 10KB blobs.</source>
          <target state="translated">更新：SQLiteバージョン3.19.0（2017-05-22）の新しい測定値は、SQLite が10KB BLOBの読み取りと書き込みの両方で直接ディスクI / O &lt;a href=&quot;fasterthanfs&quot;&gt;より&lt;/a&gt;も約35％高速であることを示しています。</target>
        </trans-unit>
        <trans-unit id="a960dbfb2b124d6ed06bf7e934a25380bb894d60" translate="yes" xml:space="preserve">
          <source>Update: The &lt;a href=&quot;lang_vacuum#vacuuminto&quot;&gt;VACUUM INTO&lt;/a&gt; command introduced in SQLite version 3.27.0 (2019-02-07) can serve as an alternative to the backup API.</source>
          <target state="translated">更新：SQLiteバージョン3.27.0（2019-02-07）で導入された&lt;a href=&quot;lang_vacuum#vacuuminto&quot;&gt;VACUUM INTO&lt;/a&gt;コマンドは、バックアップAPIの代わりとして使用できます。</target>
        </trans-unit>
        <trans-unit id="ae9f91d2ff06391addf58fdcc8dd4af3777ab8ac" translate="yes" xml:space="preserve">
          <source>Updated the &quot;unix-dotfile&quot; &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to use locking directories with mkdir() and rmdir() instead of locking files with open() and unlink().</source>
          <target state="translated">open（）およびunlink（）でファイルをロックする代わりに、mkdir（）およびrmdir（）でロックディレクトリを使用するように「unix-dotfile」&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;を更新しました。</target>
        </trans-unit>
        <trans-unit id="9ecd4cacc54f9eb845eb05b8c1cec0b8deaabeb2" translate="yes" xml:space="preserve">
          <source>Updated the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; so that it can be built using &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt; and &lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;および&lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt;を使用して構築できるように&lt;a href=&quot;cli&quot;&gt;コマンドラインシェルを&lt;/a&gt;更新しました。</target>
        </trans-unit>
        <trans-unit id="ae68475963e11d8ffb9d1743f7f05f6343c16e81" translate="yes" xml:space="preserve">
          <source>Updated the &lt;a href=&quot;nulls&quot;&gt;NULL-handling document&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;nulls&quot;&gt;NULL処理ドキュメントを&lt;/a&gt;更新しました。</target>
        </trans-unit>
        <trans-unit id="2cc8e0782c7a9b456827f5ac2f3deff6afb93a61" translate="yes" xml:space="preserve">
          <source>Updated the documentation for due to the above change.</source>
          <target state="translated">上記の変更に伴い、ドキュメントを更新しました。</target>
        </trans-unit>
        <trans-unit id="e10ae62e4bb036329cb9ea0d831ba16069afdf6b" translate="yes" xml:space="preserve">
          <source>Updates to &lt;a href=&quot;c3ref/stmt_readonly&quot;&gt;sqlite3_stmt_readonly()&lt;/a&gt; so that its result is well-defined for all prepared statements and so that it works with &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/stmt_readonly&quot;&gt;sqlite3_stmt_readonly（）を&lt;/a&gt;更新して、その結果がすべての準備されたステートメントに対して明確になり、&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;で動作するようにします。</target>
        </trans-unit>
        <trans-unit id="611a149936e51e86e5dc517a30918e94113a5c96" translate="yes" xml:space="preserve">
          <source>Updates to comments and documentation.</source>
          <target state="translated">コメントとドキュメントを更新しました。</target>
        </trans-unit>
        <trans-unit id="5cd9f8d0a6523c89d101b12728ca830f506daa93" translate="yes" xml:space="preserve">
          <source>Updates to the FAQ</source>
          <target state="translated">FAQの更新</target>
        </trans-unit>
        <trans-unit id="225b3af8e67127ee3d34043567f27a4b206ed152" translate="yes" xml:space="preserve">
          <source>Updates to the co-hosted &lt;a href=&quot;lemon&quot;&gt;Lemon LALR(1) parser generator&lt;/a&gt;. (These updates did not affect SQLite.)</source>
          <target state="translated">共同ホストされた&lt;a href=&quot;lemon&quot;&gt;Lemon LALR（1）パーサージェネレーターの&lt;/a&gt;更新。（これらの更新はSQLiteに影響を与えませんでした。）</target>
        </trans-unit>
        <trans-unit id="5ff086f286850610a359720beb1814b02bde490c" translate="yes" xml:space="preserve">
          <source>Updates to the man page</source>
          <target state="translated">男性ページの更新情報</target>
        </trans-unit>
        <trans-unit id="0b579189066ad6233ab9a30e75015931b715153e" translate="yes" xml:space="preserve">
          <source>Upgrade to an</source>
          <target state="translated">アップグレード</target>
        </trans-unit>
        <trans-unit id="fa23bdbf593290f21c99984edfe7206d0b3f48ab" translate="yes" xml:space="preserve">
          <source>Upgraded the &lt;a href=&quot;c3ref/uri_boolean&quot;&gt;sqlite3_uri_parameter()&lt;/a&gt; function so that it works with the rollback journal or WAL filename in addition to the database filename.</source>
          <target state="translated">Upgraded the &lt;a href=&quot;c3ref/uri_boolean&quot;&gt;sqlite3_uri_parameter()&lt;/a&gt; function so that it works with the rollback journal or WAL filename in addition to the database filename.</target>
        </trans-unit>
        <trans-unit id="54e621618c30d2d51e0e7eb2f7c9980b70d460c6" translate="yes" xml:space="preserve">
          <source>Upgrading SQLite, Backwards Compatibility</source>
          <target state="translated">SQLiteのアップグレード、下位互換性</target>
        </trans-unit>
        <trans-unit id="f63424e9ccf9758aa115a08c1ca29da89505f175" translate="yes" xml:space="preserve">
          <source>Upgrading to an Exclusive Lock</source>
          <target state="translated">専用ロックへのアップグレード</target>
        </trans-unit>
        <trans-unit id="0b7b831bc0dc4db0969e61d108d5ed08e60a2a5a" translate="yes" xml:space="preserve">
          <source>Usable size</source>
          <target state="translated">使用可能サイズ</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="f7d660e7e185b02ed0b42d1ed9b98bb6209a9521" translate="yes" xml:space="preserve">
          <source>Use &quot;&lt;code&gt;#include &amp;lt;sqlite3ext.h&amp;gt;&lt;/code&gt;&quot; at the top of your source code files instead of &quot;&lt;code&gt;#include &amp;lt;sqlite3.h&amp;gt;&lt;/code&gt;&quot;.</source>
          <target state="translated">「 &lt;code&gt;#include &amp;lt;sqlite3ext.h&amp;gt;&lt;/code&gt; 」の代わりに、ソースコードファイルの先頭にある「 &lt;code&gt;#include &amp;lt;sqlite3.h&amp;gt;&lt;/code&gt; 」を使用します。</target>
        </trans-unit>
        <trans-unit id="62e753b43ef69616b1563515522f39fb45747e31" translate="yes" xml:space="preserve">
          <source>Use &quot;trunk&quot; for</source>
          <target state="translated">trunk」を使用して</target>
        </trans-unit>
        <trans-unit id="237aa140efed61c820a219860ca38adb64fb7ec3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;lang_corefunc#replace&quot;&gt;replace()&lt;/a&gt; instead of &lt;a href=&quot;lang_corefunc#char&quot;&gt;char()&lt;/a&gt; for escaping newline and carriage-return characters embedded in strings in the .dump output from the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;コマンドラインシェル&lt;/a&gt;からの.dump出力の文字列に埋め込まれた改行文字と復帰文字をエスケープするには、&lt;a href=&quot;lang_corefunc#char&quot;&gt;char &lt;/a&gt;&lt;a href=&quot;lang_corefunc#replace&quot;&gt;（）の&lt;/a&gt;代わりにreplace（）を使用します。</target>
        </trans-unit>
        <trans-unit id="c7a8d415f6b6311567858afd10504aff2606d36c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;, and &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; to reconstruct indexes, triggers, and views associated with table X. Perhaps use the old format of the triggers, indexes, and views saved from step 3 above as a guide, making changes as appropriate for the alteration.</source>
          <target state="translated">使用は、&lt;a href=&quot;lang_createindex&quot;&gt;INDEXの作成&lt;/a&gt;、&lt;a href=&quot;lang_createtrigger&quot;&gt;トリガーをCREATE&lt;/a&gt;、および&lt;a href=&quot;lang_createview&quot;&gt;表示、作成&lt;/a&gt;のための適切な変更を行う、おそらくガイドとして上記のステップ3で保存したトリガ、インデックス、およびビューの古い形式を使用し、表Xに関連付けられたインデックス、トリガ、およびビューを再構築するために変更。</target>
        </trans-unit>
        <trans-unit id="536befb3634409293843309bd592f3735064b803" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; to construct a new table &quot;new_X&quot; that is in the desired revised format of table X. Make sure that the name &quot;new_X&quot; does not collide with any existing table name, of course.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;を使用して、目的の改訂されたテーブルX形式の新しいテーブル「new_X」を作成します。「new_X」の名前が既存のテーブル名と衝突しないことを確認してください。</target>
        </trans-unit>
        <trans-unit id="4324752dc06a9ac4571627fdbc5052d079c7ceec" translate="yes" xml:space="preserve">
          <source>Use a &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement to create a new index on one or more expressions just like you would to create an index on columns. The only difference is that expressions are listed as the elements to be indexed rather than column names.</source>
          <target state="translated">列にインデックスを作成するのと同じように、&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;ステートメントを使用して、1つ以上の式に新しいインデックスを作成します。唯一の違いは、式が列名ではなく、インデックス付けされる要素としてリストされることです。</target>
        </trans-unit>
        <trans-unit id="7496f7181dc9302ddc248c78082db1a132361364" translate="yes" xml:space="preserve">
          <source>Use a negative column width for right-justified columns.</source>
          <target state="translated">右寄せの列には負の列幅を使用します。</target>
        </trans-unit>
        <trans-unit id="5ed5b81249d213d275afc651f4e6fd002e1e541a" translate="yes" xml:space="preserve">
          <source>Use a separate mutex on every inode in the unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;, rather than a single mutex shared among them all, for slightly better concurrency in multi-threaded environments.</source>
          <target state="translated">マルチスレッド環境での並行性をわずかに向上させるには、単一のミューテックスをすべてで共有するのではなく、UNIX &lt;a href=&quot;vfs&quot;&gt;VFSの&lt;/a&gt;すべてのiノードで個別のミューテックスを使用します。</target>
        </trans-unit>
        <trans-unit id="de146a75582fa0d61aaa74e50c8ce2d58d1921c8" translate="yes" xml:space="preserve">
          <source>Use an index to satisfy an IS NULL operator in the WHERE clause</source>
          <target state="translated">WHERE句でIS NULL演算子を満たすためにインデックスを使用します。</target>
        </trans-unit>
        <trans-unit id="6bdba762bb27236a6cb868fd917b885a3fb66243" translate="yes" xml:space="preserve">
          <source>Use compiler built-ins __builtin_sub_overflow(), __builtin_add_overflow(), and __builtin_mul_overflow() when available. (All compiler built-ins can be omitted with the &lt;a href=&quot;compile#disable_intrinsic&quot;&gt;SQLITE_DISABLE_INTRINSIC&lt;/a&gt; compile-time option.)</source>
          <target state="translated">利用可能な場合、コンパイラ組み込みの__builtin_sub_overflow（）、__ builtin_add_overflow（）、および__builtin_mul_overflow（）を使用します。（&lt;a href=&quot;compile#disable_intrinsic&quot;&gt;SQLITE_DISABLE_INTRINSIC&lt;/a&gt;コンパイル時オプションを使用すると、すべてのコンパイラ組み込み関数を省略できます。）</target>
        </trans-unit>
        <trans-unit id="137cf73aa42452fce0415a41813408b4501767a7" translate="yes" xml:space="preserve">
          <source>Use either disk or memory storage for temporary files as determined by the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter.</source>
          <target state="translated">&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;コンパイル時パラメーターで決定される一時ファイルには、ディスクまたはメモリストレージを使用します。</target>
        </trans-unit>
        <trans-unit id="2af669874066cde2346e922c573e9e835ac690a1" translate="yes" xml:space="preserve">
          <source>Use fdatasync() instead of fsync() where possible in order to speed up commits slightly</source>
          <target state="translated">可能であれば fsync()の代わりに fdatasync()を使用します。</target>
        </trans-unit>
        <trans-unit id="50f06d5432236287d8673fac9ba31c9f7a72e979" translate="yes" xml:space="preserve">
          <source>Use files by default but allow the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;PRAGMA temp_store&lt;/a&gt; command to override</source>
          <target state="translated">デフォルトでファイルを使用するが、&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;PRAGMA temp_store&lt;/a&gt;コマンドで上書きできるようにする</target>
        </trans-unit>
        <trans-unit id="263a25f617f6abfd3d532ea4693a64ebfdbddfbe" translate="yes" xml:space="preserve">
          <source>Use heap space instead of stack space for large buffers in the pager - useful on embedded platforms with stack-space limitations.</source>
          <target state="translated">ページャーの大きなバッファのためにスタックスペースの代わりにヒープスペースを使用する-スタックスペースが制限されている組み込みプラットフォームで有用。</target>
        </trans-unit>
        <trans-unit id="3a48cc9a1a2d824c57ec5e25aeb6cff31334d1e8" translate="yes" xml:space="preserve">
          <source>Use indices to help with GLOB expressions and LIKE expressions too when the case_sensitive_like pragma is enabled</source>
          <target state="translated">case_sensitive_like pragmaが有効な場合は、GLOB式やLIKE式にもインデックスを使用します。</target>
        </trans-unit>
        <trans-unit id="bc1fcae1e921cce9fd520fbec66677338b3c72ed" translate="yes" xml:space="preserve">
          <source>Use less memory by not remembering CHECK constraints on read-only database connections.</source>
          <target state="translated">読み取り専用データベース接続のCHECK制約を記憶しないことで、より少ないメモリを使用します。</target>
        </trans-unit>
        <trans-unit id="0f855b65765fc8c17befd3c681198b2b5b5c7616" translate="yes" xml:space="preserve">
          <source>Use memmove() instead of memcpy() when moving between memory regions that might overlap. Ticket #2334</source>
          <target state="translated">重複する可能性のあるメモリ領域間を移動するときは、memcpy()の代わりにmemmove()を使用してください。チケット #2334</target>
        </trans-unit>
        <trans-unit id="469854fc5e213a56cb9e96864bf70b794360aa2e" translate="yes" xml:space="preserve">
          <source>Use memory by default but allow the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;PRAGMA temp_store&lt;/a&gt; command to override</source>
          <target state="translated">デフォルトでメモリを使用するが、&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;PRAGMA temp_store&lt;/a&gt;コマンドで上書きできるようにする</target>
        </trans-unit>
        <trans-unit id="48a8e3645a8edde160a5adbd651d1d588f3d82af" translate="yes" xml:space="preserve">
          <source>Use of the CROSS keyword in a join turns off the table reordering optimization</source>
          <target state="translated">結合でCROSSキーワードを使用すると、テーブルの並び替えの最適化がオフになります。</target>
        </trans-unit>
        <trans-unit id="4efb979f35de88aa03beb8b52191a1054ccebd97" translate="yes" xml:space="preserve">
          <source>Use single-quotes, not double-quotes, around string literals in SQL. This is what the SQL standard requires. Your WHERE clause expression should read: &lt;code&gt;column1='column1'&lt;/code&gt;</source>
          <target state="translated">SQLでは、文字列リテラルを二重引用符ではなく単一引用符で囲んでください。これは、SQL標準に必要なものです。WHERE句の式は次のようになります &lt;code&gt;column1='column1'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc43b1a2c6a31ffdd8561f57d1fbf734126319be" translate="yes" xml:space="preserve">
          <source>Use sqlite3_mprintf() instead of strdup() to avoid libc dependencies</source>
          <target state="translated">libc への依存を避けるために strdup()の代わりに sqlite3_mprintf()を使用します。</target>
        </trans-unit>
        <trans-unit id="b154d5767d626fe947b811cbac8223761d775253" translate="yes" xml:space="preserve">
          <source>Use the &quot;.dump&quot; command to convert the entire contents of a database into a single ASCII text file. This file can be converted back into a database by piping it back into &lt;b&gt;sqlite3&lt;/b&gt;.</source>
          <target state="translated">「.dump」コマンドを使用して、データベースの内容全体を単一のASCIIテキストファイルに変換します。このファイルは、&lt;b&gt;sqlite3に&lt;/b&gt;パイプで戻すことにより、データベースに変換できます。</target>
        </trans-unit>
        <trans-unit id="031acdfcfcb7c6ac30666a1a6360f5fb4b5b9407" translate="yes" xml:space="preserve">
          <source>Use the &quot;.import&quot; command to import CSV (comma separated value) data into an SQLite table. The &quot;.import&quot; command takes two arguments which are the name of the disk file from which CSV data is to be read and the name of the SQLite table into which the CSV data is to be inserted.</source>
          <target state="translated">CSV(カンマ区切り値)データをSQLiteテーブルに読み込むには、「.import」コマンドを使用します。.import &quot;コマンドは、CSVデータを読み込むディスクファイル名と、CSVデータを挿入するSQLiteテーブル名の2つの引数を取ります。</target>
        </trans-unit>
        <trans-unit id="1514a3f709961a8c5a81dddff2a1805d46c2a271" translate="yes" xml:space="preserve">
          <source>Use the &quot;.separator&quot; dot command to change the separator. For example, to change the separator to a comma and a space, you could do this:</source>
          <target state="translated">.separator&quot; ドットコマンドを使用して、区切り文字を変更します。例えば、区切り文字をカンマとスペースに変更するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="7e3a1db63b5ffcfa0304033285d6169940ca5e9f" translate="yes" xml:space="preserve">
          <source>Use the &quot;&lt;code&gt;fossil ui&lt;/code&gt;&quot; command from within the ~/sqlite checkout to bring up a local copy of the website.</source>
          <target state="translated">〜/ sqliteチェックアウト内から「 &lt;code&gt;fossil ui&lt;/code&gt; 」コマンドを使用して、Webサイトのローカルコピーを表示します。</target>
        </trans-unit>
        <trans-unit id="2314ee65a646ac667a54b17ec0394586fd245f83" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface to determine the size of the opened blob. The size of a blob may not be changed by this interface. Use the &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; SQL command to change the size of a blob.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;インターフェイスを使用して、開いているblobのサイズを確認します。blobのサイズは、このインターフェイスでは変更できません。BLOBのサイズを変更するには、&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; SQLコマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="36f9cf35dec4a270350f0bd2263a94cc3699ef47" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface to determine the size of the opened blob. The size of a blob may not be changed by this interface. Use the &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt; SQL command to change the size of a blob.</source>
          <target state="translated">&lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;インターフェイスを使用して、開いているblobのサイズを確認します。blobのサイズは、このインターフェイスでは変更できません。BLOBのサイズを変更するには、&lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt; SQLコマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="bd4ed3d4650cd4e7bc264eb1acc9e459a702bd1f" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; compile-time parameter to selected the threading mode. If no &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; compile-time parameter is present, then serialized mode is used. This can be made explicit with &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=1&lt;/a&gt;. With &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=0&lt;/a&gt; the threading mode is single-thread. With &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=2&lt;/a&gt; the threading mode is multi-thread.</source>
          <target state="translated">&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt;コンパイル時パラメーターを使用して、スレッドモードを選択します。&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt;コンパイル時パラメーターが存在しない場合、シリアル化モードが使用されます。これは&lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE = 1で&lt;/a&gt;明示的にすることができます。&lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE = 0&lt;/a&gt;スレッドモードは、シングルスレッドです。&lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE = 2&lt;/a&gt;スレッドモードはマルチスレッドです。</target>
        </trans-unit>
        <trans-unit id="274f4747a1320d774731188d128cb3683b032794" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE optimization&lt;/a&gt; even if the right-hand side string contains no wildcards.</source>
          <target state="translated">右側の文字列にワイルドカードが含まれていない場合でも、&lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE最適化を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="1f4e51240cb42418de496e090c0f24ccbb024987" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema=OFF&lt;/a&gt; SQL statement to disable trusted schema. This has the same effect as the previous bullet, but does not require the use of C-code and hence can be performed in programs written in another programming language and that do not have access SQLite C-language APIs.</source>
          <target state="translated">使用&lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;プラグマtrusted_schema = OFF&lt;/a&gt; SQLステートメントが無効に信頼されたスキーマに。これは前の箇条書きと同じ効果がありますが、Cコードを使用する必要がないため、別のプログラミング言語で記述され、SQLiteC言語APIにアクセスできないプログラムで実行できます。</target>
        </trans-unit>
        <trans-unit id="5308e85c61acbd7495be650845b12311f9dc3964" translate="yes" xml:space="preserve">
          <source>Use the &lt;b&gt;sqlite_open&lt;/b&gt; function to open an existing SQLite database or to create a new SQLite database. The first argument is the database name. The second argument is intended to signal whether the database is going to be used for reading and writing or just for reading. But in the current implementation, the second argument to &lt;b&gt;sqlite_open&lt;/b&gt; is ignored. The third argument is a pointer to a string pointer. If the third argument is not NULL and an error occurs while trying to open the database, then an error message will be written to memory obtained from malloc() and *errmsg will be made to point to this error message. The calling function is responsible for freeing the memory when it has finished with it.</source>
          <target state="translated">&lt;b&gt;sqlite_open&lt;/b&gt;関数を使用して、既存のSQLiteデータベースを開くか、新しいSQLiteデータベースを作成します。最初の引数はデータベース名です。 2番目の引数は、データベースが読み取りと書き込みのどちらに使用されるのか、または単に読み取りに使用されるのかを示すためのものです。ただし、現在の実装では、&lt;b&gt;sqlite_open&lt;/b&gt;の2番目の引数は無視されます。 3番目の引数は、文字列ポインターへのポインターです。 3番目の引数がNULLではなく、データベースを開こうとしたときにエラーが発生した場合、エラーメッセージがmalloc（）から取得したメモリに書き込まれ、* errmsgがこのエラーメッセージを指すようになります。呼び出し元の関数は、メモリの使用が終了したときにメモリを解放する責任があります。</target>
        </trans-unit>
        <trans-unit id="c6d46e33d7807116ac9add91d72550fca2ffbf23" translate="yes" xml:space="preserve">
          <source>Use the WHERE clause to reduce the size of a materialized VIEW in an UPDATE or DELETE statement. (Optimization)</source>
          <target state="translated">WHERE 句を使用して、UPDATE 文または DELETE 文でマテリアライズされた VIEW のサイズを縮小します。(最適化)</target>
        </trans-unit>
        <trans-unit id="efe8cfb25313b8ffdcda22d1d22b3397432240d2" translate="yes" xml:space="preserve">
          <source>Use the correct affinity for columns of automatic indexes. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/7ffd1ca1d2ad4ec&quot;&gt;7ffd1ca1d2ad4ec&lt;/a&gt;.</source>
          <target state="translated">自動インデックスの列に正しいアフィニティを使用します。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/7ffd1ca1d2ad4ec&quot;&gt;7ffd1ca1d2ad4ec&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4d6f456699b36362dd68589f9f76baf09757ec2f" translate="yes" xml:space="preserve">
          <source>Use the decimal_cmp(A,B) to compare two decimal values. The result will be negative, zero, or positive if A is less than, equal to, or greater than B, respectively.</source>
          <target state="translated">2つの10進数の値を比較するには、 decimal_cmp(A,B)を使用します。結果は、AがBより小さいか、Bと等しいか、Bより大きい場合は、それぞれ負、ゼロ、正となります。</target>
        </trans-unit>
        <trans-unit id="f8484df7605c1331750609f898da67fe4dcaeabf" translate="yes" xml:space="preserve">
          <source>Use the macro SQLITE_PRIVATE (defaulting to &quot;static&quot;) on all internal functions in the amalgamation.</source>
          <target state="translated">マクロ SQLITE_PRIVATE (デフォルトは &quot;static&quot; です)をアマルガム内のすべての内部関数で使用します。</target>
        </trans-unit>
        <trans-unit id="bc78bf67fa7d6c1c485c06940843c7741c22f19b" translate="yes" xml:space="preserve">
          <source>Use the new &lt;a href=&quot;c3ref/blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; interface to improve the performance of FTS.</source>
          <target state="translated">新しい&lt;a href=&quot;c3ref/blob_reopen&quot;&gt;sqlite3_blob_reopen（）&lt;/a&gt;インターフェースを使用して、FTSのパフォーマンスを向上させます。</target>
        </trans-unit>
        <trans-unit id="3b2244da3774583cbb3fc1a48e72dfd44d3ab95d" translate="yes" xml:space="preserve">
          <source>Use the normal SQLite API to read and write to databases via the asynchronous IO VFS.</source>
          <target state="translated">通常のSQLite APIを使用して、非同期IO VFSを介してデータベースへの読み書きを行います。</target>
        </trans-unit>
        <trans-unit id="26f92b5c0905f544db1bb7d8ca5ebd0ed63e16d8" translate="yes" xml:space="preserve">
          <source>Use the resulting &quot;kvtest&quot; program to generate a test database with 100,000 random uncompressible blobs, each with a random size between 8,000 and 12,000 bytes using a command like this:</source>
          <target state="translated">結果として得られた &quot;kvtest&quot; プログラムを使用して、以下のようなコマンドを使用して、8,000 バイトから 12,000 バイトの間のランダムなサイズの 100,000 個のランダムな非圧縮ブロブを含むテストデータベースを生成します。</target>
        </trans-unit>
        <trans-unit id="7834abce7ece24f8701462e346703566e2de3e27" translate="yes" xml:space="preserve">
          <source>Use the schema-defined &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; instead of the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; to pair rows in the source and destination database. (See additional explanation below.)</source>
          <target state="translated">&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWIDの&lt;/a&gt;代わりにスキーマ定義の&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEYを&lt;/a&gt;使用して、ソースデータベースと宛先データベースの行をペアにします。（以下の追加説明を参照してください。）</target>
        </trans-unit>
        <trans-unit id="02df1e951c416cb903ab43afc2694bfdea186be2" translate="yes" xml:space="preserve">
          <source>Use the strcspn() C-library routine to speed up the LIKE and GLOB operators.</source>
          <target state="translated">C-library ルーチン strcspn()を使用して、LIKE および GLOB 演算子を高速化します。</target>
        </trans-unit>
        <trans-unit id="f1f443135d8d6987de124f0e64e3f9227d9a5c27" translate="yes" xml:space="preserve">
          <source>Use the transitive property to try to propagate constant values within the WHERE clause. For example, convert &quot;a=99 AND b=a&quot; into &quot;a=99 AND b=99&quot;.</source>
          <target state="translated">WHERE 節内で定数値を伝播させようとする場合は、transitive プロパティを使用します。例えば、&quot;a=99 AND b=a&quot; を &quot;a=99 AND b=99&quot; に変換します。</target>
        </trans-unit>
        <trans-unit id="0ea0700fa56071e98d4cc761a6e621b61eff1903" translate="yes" xml:space="preserve">
          <source>Use the unicode API in Windows</source>
          <target state="translated">Windows で unicode API を使用する</target>
        </trans-unit>
        <trans-unit id="97776a8d79289b0d1017fb264bc954bd7ad83946" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#aggregate-function-invocation&quot;&gt;aggregate-function-invocation&lt;/a&gt;&lt;a href=&quot;#attach-stmt&quot;&gt;attach-stmt&lt;/a&gt;&lt;a href=&quot;#column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;#compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;#create-index-stmt&quot;&gt;create-index-stmt&lt;/a&gt;&lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#filter-clause&quot;&gt;filter-clause&lt;/a&gt;&lt;a href=&quot;#frame-spec&quot;&gt;frame-spec&lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;indexed-column&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;#join-constraint&quot;&gt;join-constraint&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;#result-column&quot;&gt;result-column&lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#simple-function-invocation&quot;&gt;simple-function-invocation&lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;table-constraint&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;&lt;a href=&quot;#window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</source>
          <target state="translated">使用：&lt;a href=&quot;#aggregate-function-invocation&quot;&gt;aggregate-function-invocation &lt;/a&gt;&lt;a href=&quot;#attach-stmt&quot;&gt;attach-stmt &lt;/a&gt;&lt;a href=&quot;#column-constraint&quot;&gt;column-constraint &lt;/a&gt;&lt;a href=&quot;#compound-select-stmt&quot;&gt;compound-select-stmt &lt;/a&gt;&lt;a href=&quot;#create-index-stmt&quot;&gt;create-index-stmt &lt;/a&gt;&lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited &lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;factored &lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;-select-stmt &lt;/a&gt;&lt;a href=&quot;#filter-clause&quot;&gt;filter-clause &lt;/a&gt;&lt;a href=&quot;#frame-spec&quot;&gt;frame-spec &lt;/a&gt;indexed- column &lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;#join-constraint&quot;&gt;join-constraint &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term &lt;/a&gt;&lt;a href=&quot;#over-clause&quot;&gt;over-clause &lt;/a&gt;&lt;a href=&quot;#result-column&quot;&gt;result-column &lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#simple-function-invocation&quot;&gt;simple-function-invocation &lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt &lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;table-constraint &lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery &lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited &lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-節&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn &lt;/a&gt;&lt;a href=&quot;#window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f3cfe8ec4e623b595e4ac50171983c062621b492" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#aggregate-function-invocation&quot;&gt;aggregate-function-invocation&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#aggregate-function-invocation&quot;&gt;aggregate-function-invocation &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9fa16a928ddc1dc237caf8ee5a2f33829abb8c95" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#alter-table-stmt&quot;&gt;alter-table-stmt&lt;/a&gt;&lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#alter-table-stmt&quot;&gt;alter-table-stmt &lt;/a&gt;&lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7605fd600c574fecb47de09ab5decde53c108336" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#column-constraint&quot;&gt;column-constraint &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9d132b987e9571018a10419466ce9e4241f4144" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;#pragma-value&quot;&gt;pragma-value&lt;/a&gt;&lt;a href=&quot;#type-name&quot;&gt;type-name&lt;/a&gt;</source>
          <target state="translated">使用対象：&lt;a href=&quot;#column-constraint&quot;&gt;column-constraint &lt;/a&gt;&lt;a href=&quot;#pragma-value&quot;&gt;プラグマ値&lt;/a&gt;&lt;a href=&quot;#type-name&quot;&gt;型名&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6859f1dc44376fa95c8d38fdf3b6141e03d2c1ae" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;table-constraint&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#column-constraint&quot;&gt;column-constraint &lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;table-constraint&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a380af02d8c9c93f329808cab4b27595f6a4a3c5" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#column-def&quot;&gt;column-def&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#column-def&quot;&gt;column-def&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d289a73c451effafc4667d2bf1f3b0e030afac60" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#column-def&quot;&gt;column-def&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#column-def&quot;&gt;column-def &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a431a18a7738c53de3472c652954e2bc59958670" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;&lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;#create-view-stmt&quot;&gt;create-view-stmt&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">使用：&lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt &lt;/a&gt;&lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;#create-view-stmt&quot;&gt;create-view-stmt &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt &lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery &lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="224be4c1f3c548d22132987eb2bf278a86171468" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">Used by: &lt;a href=&quot;#compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="abb141b71ecdf70ef024445a846b6364ea02ee67" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">使用先：&lt;a href=&quot;#compound-select-stmt&quot;&gt;複合選択- &lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;削除削除-削除-制限&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;因数分解-選択- &lt;/a&gt;&lt;a href=&quot;#over-clause&quot;&gt;上書き節&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;選択&lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;-選択シンプル-選択- &lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;更新更新-制限- &lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;ウィンドウ&lt;/a&gt;制限</target>
        </trans-unit>
        <trans-unit id="ab6cea255f6025204d21b009964174b973b40cd6" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#compound-select-stmt&quot;&gt;Compound-select-stmt &lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c9a35f3e8899c13b9a454dc09b2554a9fc11894f" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#compound-select-stmt&quot;&gt;Compound-select-stmt &lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt &lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="56b558cf19b1f43efb09e7c3cf6f834bdf6f9e08" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#create-index-stmt&quot;&gt;create-index-stmt&lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;table-constraint&lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#create-index-stmt&quot;&gt;create-index-stmt &lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;table-constraint &lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3ed338e20414f7c9ffcbc59e0281f80cccd5a763" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6b50a14ac773fa0a58261d63783e57e4cbe15c68" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed0705dac87c2b47586b5a816bab059a80c3dff1" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited &lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fed14e0505bafc78d4d9d690a2b7426f9c8198b2" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited &lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a021ee5a9dccd79e0bc3acd62766c09cd9fb8cae" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="082ab3c78daf3f012c8a8cd5f4c53643a071209a" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09a6e3cc1f24c34ba4f2a0f20d3c51dbe35db3c3" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="97d8dfd0bb5c0f6552eb23078a3e1e860cc9a6c3" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed8783360dda42990afd13092353a2478b98c818" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">使用：&lt;a href=&quot;#join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c4cd678b8b993f3438c0117dedb1f0fd21e9e1b" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">Used by: &lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9af677aaf273d3f1f76df6b503b77ba2fd60bed2" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#over-clause&quot;&gt;over-clause &lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8079f3adf01a444617315e6ee69c27b2f0e4367b" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#pragma-stmt&quot;&gt;pragma-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#pragma-stmt&quot;&gt;pragma-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80938cb5970c9483ff312171cb2cce6f1c888a48" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#recursive-cte&quot;&gt;recursive-cte&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#recursive-cte&quot;&gt;recursive-cte &lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ae852a57048a30f81de513ccc896f0c0dd648fe" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3f7cbedd2f19d68e5c65e3a5494b079eb45e6d0" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="translated">使用：&lt;a href=&quot;#select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="589e0a5319c833b4b7bc5d107ed94b7fe1c7d8cd" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">Used by: &lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35ea943fa5a24500d0b2de81bfcae0c263e9c947" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</source>
          <target state="translated">使用：&lt;a href=&quot;#select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f6ef1477fa5df999acf552fb4e67164b37b0a48f" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b6d1945ca75963e8557621ed71f512d0d1f8a13e" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#sql-stmt-list&quot;&gt;sql-stmt-list&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#sql-stmt-list&quot;&gt;sql-stmt-list&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1042aa6c3f092cc75f0c8a676be3f2d32a0e48e0" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited &lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a1f1be8756f8f6e3850d5a9e7441499016850919" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;aggregate-function-invocation&quot;&gt;aggregate-function-invocation&lt;/a&gt;&lt;a href=&quot;attach-stmt&quot;&gt;attach-stmt&lt;/a&gt;&lt;a href=&quot;column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;create-index-stmt&quot;&gt;create-index-stmt&lt;/a&gt;&lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;filter-clause&quot;&gt;filter-clause&lt;/a&gt;&lt;a href=&quot;frame-spec&quot;&gt;frame-spec&lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;indexed-column&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;join-constraint&quot;&gt;join-constraint&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;result-column&quot;&gt;result-column&lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;simple-function-invocation&quot;&gt;simple-function-invocation&lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;table-constraint&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;&lt;a href=&quot;window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</source>
          <target state="translated">使用：&lt;a href=&quot;aggregate-function-invocation&quot;&gt;aggregate-function-invocation &lt;/a&gt;&lt;a href=&quot;attach-stmt&quot;&gt;attach-stmt &lt;/a&gt;&lt;a href=&quot;column-constraint&quot;&gt;column-constraint &lt;/a&gt;&lt;a href=&quot;compound-select-stmt&quot;&gt;compound-select-stmt &lt;/a&gt;&lt;a href=&quot;create-index-stmt&quot;&gt;create-index-stmt &lt;/a&gt;&lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited &lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;factored &lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;-select-stmt &lt;/a&gt;&lt;a href=&quot;filter-clause&quot;&gt;filter-clause &lt;/a&gt;&lt;a href=&quot;frame-spec&quot;&gt;frame-spec &lt;/a&gt;indexed- column &lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;join-constraint&quot;&gt;join-constraint &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term &lt;/a&gt;&lt;a href=&quot;over-clause&quot;&gt;over-clause &lt;/a&gt;&lt;a href=&quot;result-column&quot;&gt;result-column &lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;simple-function-invocation&quot;&gt;simple-function-invocation &lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt &lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;table-constraint &lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery &lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited &lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-節&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn &lt;/a&gt;&lt;a href=&quot;window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8dba34c5ead7ae94617f98c7cde1dd99c8cf20f1" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;aggregate-function-invocation&quot;&gt;aggregate-function-invocation&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;aggregate-function-invocation&quot;&gt;aggregate-function-invocation &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="307e140208125cd798472be7cbdee684ec27af23" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;alter-table-stmt&quot;&gt;alter-table-stmt&lt;/a&gt;&lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;alter-table-stmt&quot;&gt;alter-table-stmt &lt;/a&gt;&lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c5caeae659f486a37e2e78f0f36394d00574f259" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;column-constraint&quot;&gt;column-constraint &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a86521d0d079a24ae129812150a3753aecda3e41" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;pragma-value&quot;&gt;pragma-value&lt;/a&gt;&lt;a href=&quot;type-name&quot;&gt;type-name&lt;/a&gt;</source>
          <target state="translated">使用対象：&lt;a href=&quot;column-constraint&quot;&gt;column-constraint &lt;/a&gt;&lt;a href=&quot;pragma-value&quot;&gt;プラグマ値&lt;/a&gt;&lt;a href=&quot;type-name&quot;&gt;型名&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4797572b6c11d132a08e6eb97c1346965d8c3891" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;table-constraint&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;column-constraint&quot;&gt;column-constraint &lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;table-constraint&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="530c72cf587d62fa294e2381602271f96f0f96d7" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;column-def&quot;&gt;column-def&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;column-def&quot;&gt;column-def&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bae571e21875de9dbe7973158d01f4c614d8c361" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;column-def&quot;&gt;column-def&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;column-def&quot;&gt;column-def &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d621ef2d30a77aac0f67e4cb22f0496953330ae4" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;&lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;create-view-stmt&quot;&gt;create-view-stmt&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">使用：&lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt &lt;/a&gt;&lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;create-view-stmt&quot;&gt;create-view-stmt &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt &lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery &lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7999cb7cebc65a8fd79ca0339c4bb490ea515b01" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">Used by: &lt;a href=&quot;compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e0856e25a6da8ebb570311e60dcc92e62c9700b8" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">使用先：&lt;a href=&quot;compound-select-stmt&quot;&gt;複合選択- &lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;削除削除-削除-制限&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;因数分解-選択- &lt;/a&gt;&lt;a href=&quot;over-clause&quot;&gt;上書き句&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;選択&lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;-選択単純選択- &lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;更新更新-制限- &lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;ウィンドウ&lt;/a&gt;制限</target>
        </trans-unit>
        <trans-unit id="21f8541c9dc2a69fa16cf43b335b7b363315d397" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;compound-select-stmt&quot;&gt;Compound-select-stmt &lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4ab6ebc8f279a3034f0fdb604843d248415ee1bf" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;compound-select-stmt&quot;&gt;Compound-select-stmt &lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt &lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9b73b88651ef8bf860289b6de3757bded750bc5" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;create-index-stmt&quot;&gt;create-index-stmt&lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;table-constraint&lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;create-index-stmt&quot;&gt;create-index-stmt &lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;table-constraint &lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f17754185255593ea4e239b7777c291185f4d22a" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1250d862d07127e87b9840caf01bde3487514be4" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7ffe5f5730adb72eee0e8790e0d4f442453ca532" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited &lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b346b7bdc3d0ceef5715a064d5778a794c30fe18" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited &lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ecd461adaec5db6b876f0dff52c7be72090d1b14" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1d46198801b0b7bba9815dc12e4cdb3e29b72db5" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="79c1bf6cb1bf604130309cdb21b4f8fbff437aa3" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9892cdf8b7abbe2222939b3dd694fd626893c60f" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b8026c06ece9d695e8c405568f97c947f459d098" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">使用：&lt;a href=&quot;join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e21ce3a84da1747a72ee6509dcd2b66aa22588d4" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">Used by: &lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9280252176a18a8cad0168e3316dcfbe48390b81" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;over-clause&quot;&gt;over-clause &lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98a46233f40109c7b176062c4c3a604629e49ee7" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;pragma-stmt&quot;&gt;pragma-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;pragma-stmt&quot;&gt;pragma-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b50593211eada2909f681edc15211383687e61a9" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;recursive-cte&quot;&gt;recursive-cte&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;recursive-cte&quot;&gt;recursive-cte &lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="36f9352a3528ee1d344ab047f86be842bf862c8a" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7939044785ba0a8ca2c0b2b3b645bfec873f9c5c" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="translated">使用：&lt;a href=&quot;select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8113b13214eea91b3a3368ba7da6ad54a4268b3b" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">Used by: &lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bcd5b650bb8cb46f8defc106f0dfcc99d5b051cd" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</source>
          <target state="translated">使用：&lt;a href=&quot;select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4594a38d58964e1e237c00459543be8431bc246" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35b40c8cd50b969bfb81394dd732cd863e0cd4d1" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;sql-stmt-list&quot;&gt;sql-stmt-list&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;sql-stmt-list&quot;&gt;sql-stmt-list&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b23afd53b16f293ca94992760b0d75920c0db155" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</source>
          <target state="translated">使用者：&lt;a href=&quot;update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited &lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="83a28142d94277b9f824e8d439d35c64935809cf" translate="yes" xml:space="preserve">
          <source>User Data For Functions</source>
          <target state="translated">機能のユーザデータ</target>
        </trans-unit>
        <trans-unit id="f87f9bec30fa447642063fa0c8666b7e8eb0bcd7" translate="yes" xml:space="preserve">
          <source>User defined functions can be created using the following routine:</source>
          <target state="translated">ユーザー定義関数は、以下のルーチンを使用して作成することができます。</target>
        </trans-unit>
        <trans-unit id="444756f6f1895c936bb10bab307f679e2df66fa7" translate="yes" xml:space="preserve">
          <source>User-definable text collating sequences.</source>
          <target state="translated">ユーザー定義可能なテキスト照合シーケンス。</target>
        </trans-unit>
        <trans-unit id="41cabf87c0640a35632815a9c1c75379f4b103ed" translate="yes" xml:space="preserve">
          <source>User-defined Collating Sequences</source>
          <target state="translated">ユーザー定義の照合シーケンス</target>
        </trans-unit>
        <trans-unit id="679b4a0d57b60e54b747cb9aacd21774ca84d965" translate="yes" xml:space="preserve">
          <source>User-defined aggregate window functions may be created using the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_window_function&lt;/a&gt;() API. Implementing an aggregate window function is very similar to an ordinary aggregate function. Any user-defined aggregate window function may also be used as an ordinary aggregate. To implement a user-defined aggregate window function the application must supply four callback functions:</source>
          <target state="translated">ユーザー定義の集計ウィンドウ関数は、&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_window_function&lt;/a&gt;（）API を使用して作成できます。集計ウィンドウ関数の実装は、通常の集計関数と非常に似ています。ユーザー定義の集計ウィンドウ関数は、通常の集計としても使用できます。ユーザー定義の集計ウィンドウ関数を実装するには、アプリケーションが4つのコールバック関数を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="8cb5450ed96e61339c7346965130b897dcacb151" translate="yes" xml:space="preserve">
          <source>User-defined text collating sequences.</source>
          <target state="translated">ユーザー定義のテキスト照合シーケンス。</target>
        </trans-unit>
        <trans-unit id="e6d26b2d97c6ea4098987a42caa6c50e042619be" translate="yes" xml:space="preserve">
          <source>Uses 9% fewer CPU cycles. (See the &lt;a href=&quot;cpu&quot;&gt;CPU performance measurement&lt;/a&gt; report for details on how this performance increase was computed.)</source>
          <target state="translated">9％少ないCPUサイクルを使用します。（このパフォーマンス向上の計算方法の詳細については、&lt;a href=&quot;cpu&quot;&gt;CPUパフォーマンス測定&lt;/a&gt;レポートを参照してください。）</target>
        </trans-unit>
        <trans-unit id="d0301d0d4694000bac42286a893da835217aae2d" translate="yes" xml:space="preserve">
          <source>Uses compiler built-ins (ex: __builtin_bswap32() or _byteswap_ulong()) for byteswapping when available.</source>
          <target state="translated">コンパイラの組み込みイン (例:__builtin_bswap32()や _byteswap_ulong()など)を使用してバイトスワップを行います。</target>
        </trans-unit>
        <trans-unit id="f10225b09b2eddd2b69fc1125f1e8c1790100225" translate="yes" xml:space="preserve">
          <source>Uses the &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; key/value access object instead of SQL for pulling content out of R-Tree nodes</source>
          <target state="translated">用途&lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blobの&lt;/a&gt; R-ツリーノードのうち、コンテンツを引っ張るための代わりにSQLのキー/値のアクセスオブジェクトを</target>
        </trans-unit>
        <trans-unit id="bf6a8d8b0b161f49ba5a16ea51a640dcb0e4cfe4" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=OFF&lt;/a&gt; or &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=MEMORY&lt;/a&gt; and taking an application crash in the middle of a write transaction.</source>
          <target state="translated">使用&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;プラグマjournal_mode = OFF&lt;/a&gt;または&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = MEMORYを&lt;/a&gt;、書き込みトランザクションの途中でアプリケーションのクラッシュを取ります。</target>
        </trans-unit>
        <trans-unit id="1020c3daf5ee3d9c72ef57a803c58bd0586e47f7" translate="yes" xml:space="preserve">
          <source>Using CREATE or DROP to create or destroy a table or index is really the same as doing an INSERT or DELETE from the special &quot;sqlite_master&quot; table, at least from the point of view of the VDBE. The sqlite_master table is a special table that is automatically created for every SQLite database. It looks like this:</source>
          <target state="translated">CREATEやDROPを使ってテーブルやインデックスを作成したり破棄したりすることは、少なくともVDBEの観点からは、特別な &quot;sqlite_master &quot;テーブルからINSERTやDELETEを行うのと同じことです。sqlite_masterテーブルは、すべてのSQLiteデータベースに対して自動的に作成される特別なテーブルです。それは次のようになっています。</target>
        </trans-unit>
        <trans-unit id="4d2637c8d86cb85da8f8da94256a0cdc80d9b4c2" translate="yes" xml:space="preserve">
          <source>Using DDL or DML SQL statements, SQLite users may modify the contents and size of a database file. Exactly how changes to the logical database are translated to modifications to the database file is described in</source>
          <target state="translated">DDL または DML SQL 文を使用して、SQLite ユーザーはデータベースファイルの内容とサイズを変更することができます。論理データベースへの変更がデータベースファイルへの変更にどのように変換されるかは</target>
        </trans-unit>
        <trans-unit id="435c55e01cffb5570c6c79cda02f466b6061178b" translate="yes" xml:space="preserve">
          <source>Using Idx2 instead of Idx1 causes SQLite to examine a different set of rows, but it gets the same answer in the end (which is very important - remember that indices should never change the answer, only help SQLite to get to the answer more quickly) and it does the same amount of work. So the Idx2 index did not help performance in this case.</source>
          <target state="translated">Idx1 の代わりに Idx2 を使用すると、SQLite は異なる行のセットを調べますが、最終的には同じ答えを得ます (これは非常に重要なことです。インデックスは決して答えを変更してはならず、SQLite がより速く答えにたどり着くのを助けるだけであることを覚えておいてください)。この場合、Idx2インデックスはパフォーマンスを向上させることはできませんでした。</target>
        </trans-unit>
        <trans-unit id="c7fd16dcb5fbd84cb48400bd250b2f97394100cb" translate="yes" xml:space="preserve">
          <source>Using Indexes To Speed Searching</source>
          <target state="translated">インデックスを使用して検索を高速化する</target>
        </trans-unit>
        <trans-unit id="9f210fd1e7b63cdc7dd0138afd84809f14583a65" translate="yes" xml:space="preserve">
          <source>Using SELECT Statements As Terms In An Expression</source>
          <target state="translated">SELECT ステートメントを式の用語として使用する</target>
        </trans-unit>
        <trans-unit id="97437976ebeb573c52b13ddfd438d2c91bf1893b" translate="yes" xml:space="preserve">
          <source>Using SQLite In Multi-Threaded Applications</source>
          <target state="translated">マルチスレッドアプリケーションでのSQLiteの使用</target>
        </trans-unit>
        <trans-unit id="307f31c1c11aebab82631ac4f8b0ab54eca6e078" translate="yes" xml:space="preserve">
          <source>Using a MATCH operator in the WHERE clause of a SELECT statement, or</source>
          <target state="translated">SELECT 文の WHERE 節で MATCH 演算子を使用するか、または</target>
        </trans-unit>
        <trans-unit id="3e68860fe2d2ad5dc9651e317f240eed014363dc" translate="yes" xml:space="preserve">
          <source>Using a built-in printf() implementation means that SQLite has one fewer dependency on the host environment, making it more portable.</source>
          <target state="translated">組み込みの printf()実装を使用することで、SQLite のホスト環境への依存度が 1 つ減り、より移植性が高くなります。</target>
        </trans-unit>
        <trans-unit id="c90117e39221737f02ea3e7e44c49c43210beeb3" translate="yes" xml:space="preserve">
          <source>Using a database file with 8+3 filenames in some cases while in other cases using long filenames is equivalent to &lt;a href=&quot;howtocorrupt#delhotjrnl&quot;&gt;deleting a hot journal&lt;/a&gt;.</source>
          <target state="translated">8 + 3のファイル名を持つデータベースファイルを使用する場合と長いファイル名を使用する場合は&lt;a href=&quot;howtocorrupt#delhotjrnl&quot;&gt;、ホットジャーナル&lt;/a&gt;を削除するのと同じです。</target>
        </trans-unit>
        <trans-unit id="8fb331fbfc19c9ad94dbe708335967012f83cb31" translate="yes" xml:space="preserve">
          <source>Using a dataset of American place names (derived from &lt;a href=&quot;http://geonames.usgs.gov/domestic/download_data.htm&quot;&gt;http://geonames.usgs.gov/domestic/download_data.htm&lt;/a&gt;) the query above returns 20 results beginning with:</source>
          <target state="translated">アメリカの地名のデータセット（&lt;a href=&quot;http://geonames.usgs.gov/domestic/download_data.htm&quot;&gt;http://geonames.usgs.gov/domestic/download_data.htm&lt;/a&gt;から派生）を使用すると、上記のクエリは次で始まる20の結果を返します。</target>
        </trans-unit>
        <trans-unit id="cced5340290d93733d759f1a49ce8d467995399f" translate="yes" xml:space="preserve">
          <source>Using a single query such as the above, the application obtains a list of the slideIds for all slides in the presentation. The application then queries for the content of the first slide, and parses and displays that content, as before.</source>
          <target state="translated">上記のような単一のクエリを使用して、アプリケーションは、プレゼンテーション内のすべてのスライドのslideIdsのリストを取得します。次にアプリケーションは、最初のスライドの内容をクエリして、先ほどと同様にその内容を解析して表示します。</target>
        </trans-unit>
        <trans-unit id="7dd3bf0fc645009566609bccf3a14f62d35a3f59" translate="yes" xml:space="preserve">
          <source>Using an equals (&quot;=&quot;) operator in the WHERE clause of a SELECT statement, or</source>
          <target state="translated">SELECT文のWHERE句での等号(&quot;=&quot;)演算子の使用、または</target>
        </trans-unit>
        <trans-unit id="23bf7370fe569447da050d73459abb59d1093647" translate="yes" xml:space="preserve">
          <source>Using an ordinary disk file to provide shared memory has the disadvantage that it might actually do unnecessary disk I/O by writing the shared memory to disk. However, the developers do not think this is a major concern since the wal-index rarely exceeds 32 KiB in size and is never synced. Furthermore, the wal-index backing file is deleted when the last database connection disconnects, which often prevents any real disk I/O from ever happening.</source>
          <target state="translated">共有メモリを提供するために通常のディスクファイルを使用すると、実際には共有メモリをディスクに書き込むことで不必要なディスクI/Oを行う可能性があるという欠点があります。しかし、Wal-indexが32KiBを超えることはほとんどなく、同期されることもないため、開発者はこれが大きな懸念事項であるとは考えていません。さらに、wal-indexのバッキングファイルは、最後のデータベース接続が切断されると削除されるため、実際のディスクI/Oが発生しないことが多い。</target>
        </trans-unit>
        <trans-unit id="314bb9e64d758d2b63c2c5acc0e1727dc6e61abf" translate="yes" xml:space="preserve">
          <source>Using an unnamed subquery in a FROM clause would cause a segfault.</source>
          <target state="translated">FROM句で名前のない副問い合わせを使用するとセグメンテーションエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="9766cdfa57f62810ee226e9c3deec347064cc20b" translate="yes" xml:space="preserve">
          <source>Using gcov (or similar) to show that every branch instruction is taken at least once in both directions is good measure of test suite quality. But even better is showing that every branch instruction makes a difference in the output. In other words, we want to show not only that every branch instruction both jumps and falls through but also that every branch is doing useful work and that the test suite is able to detect and verify that work. When a branch is found that does not make a difference in the output, that suggests that the code associated the branch can be removed (reducing the size of the library and perhaps making it run faster) or that the test suite is inadequately testing the feature that the branch implements.</source>
          <target state="translated">gcov (または同様のもの)を使用して、すべての分岐命令が両方向に少なくとも一度は取られることを示すことは、テストスイートの品質の良い尺度となります。しかし、それ以上に優れているのは、すべての分岐命令が出力に違いをもたらすことを示すことです。言い換えれば、すべての分岐命令がジャンプしたり落ちたりするだけでなく、すべての分岐命令が有用な仕事をしていること、そしてテストスイートがその仕事を検出して検証できることを示したいのです。出力に違いがないブランチが見つかった場合、そのブランチに関連するコードを削除することができます (ライブラリのサイズを小さくして、おそらくより高速に動作させることができます)。</target>
        </trans-unit>
        <trans-unit id="db5729475276e1f07562cb2df1e724ad2371713c" translate="yes" xml:space="preserve">
          <source>Using one particular subset of the available TH3 test modules (the &quot;cov1&quot; tests) SQLite obtained &lt;a href=&quot;testing#coverage&quot;&gt;100% branch test coverage&lt;/a&gt; and 100% &lt;a href=&quot;testing#mcdc&quot;&gt;MC/DC&lt;/a&gt; as measured by &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcov&lt;/a&gt; on Linux x86 and x86_64 hardware. All releases of SQLite since &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;version 3.6.17&lt;/a&gt; (2009-08-10) have been tested to this standard. The SQLite developers are committed to maintaining 100% branch coverage and MC/DC for all future releases of SQLite.</source>
          <target state="translated">利用可能なTH3テストモジュール（「cov1」テスト）の特定のサブセットを使用して、SQLiteは、Linux x86およびx86_64ハードウェアの&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcov&lt;/a&gt;で測定した&lt;a href=&quot;testing#coverage&quot;&gt;100％ブランチテストカバレッジ&lt;/a&gt;と100％&lt;a href=&quot;testing#mcdc&quot;&gt;MC / DC&lt;/a&gt;を取得しました。&lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;バージョン3.6.17&lt;/a&gt;（2009-08-10）以降のSQLiteのすべてのリリースは、この規格でテストされています。SQLite開発者は、SQLiteの今後のすべてのリリースで100％のブランチカバレッジとMC / DCを維持することを約束します。</target>
        </trans-unit>
        <trans-unit id="9270ae0408b0c691c7bbd964a691a187fe62e891" translate="yes" xml:space="preserve">
          <source>Using subtypes to identify valid pointers prevented the WebSQL exploit. But it turned out to be an incomplete solution.</source>
          <target state="translated">有効なポインタを識別するためにサブタイプを使用することで、WebSQL の悪用を防ぐことができました。しかし、それは不完全な解決策であることが判明しました。</target>
        </trans-unit>
        <trans-unit id="4b795c9ed4e93bd126c1058e30a1d247be674aba" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;fts3#*fts4content&quot;&gt;FTS4 content option&lt;/a&gt; and failing to manually keep the content in sync with the FTS4 inverted indices.</source>
          <target state="translated">&lt;a href=&quot;fts3#*fts4content&quot;&gt;FTS4コンテンツオプション&lt;/a&gt;を使用し、コンテンツを手動でFTS4反転インデックスと同期し続けることに失敗した。</target>
        </trans-unit>
        <trans-unit id="c352b493b2f0901876aea8d20656c0d87ef6b6a9" translate="yes" xml:space="preserve">
          <source>Using the N+1 Query pattern in Fossil does not harm the application. But the N+1 Query pattern does have benefits. For one, the section of the code that creates the timeline query can be completely separate from the section that prepares each timeline entry for display. This provides a separation of responsibility that helps keep the code simple and easy to maintain. Secondly, the information needed for display, and the queries needed to extract that information, vary according to what type of objects to be shown. Check-ins need one set of queries. Tickets need another set of queries. Wiki pages need a different query. And so forth. By implementing these queries on-demand and in the part of the code dealing with the various entities, there is further separation of responsibility and simplification of the overall code base.</source>
          <target state="translated">FossilでN+1 Queryパターンを使用してもアプリケーションに害はありません。しかし、N+1 Query パターンには利点があります。一つは、Timeline クエリを作成するコードのセクションは、表示のために各Timeline エントリーを準備するセクションとは完全に分離されていることです。これはコードをシンプルでメンテナンスが簡単な状態に保つのに役立つ責任の分離を提供します。第二に、表示に必要な情報と、その情報を抽出するために必要なクエリは、表示されるオブジェクトのタイプによって異なります。チェックインには 1 組のクエリが必要です。チケットには別のクエリが必要です。Wikiページには別のクエリが必要です。といった具合です。これらのクエリをオンデマンドで、様々なエンティティを扱うコードの一部に実装することで、責任の分離と全体的なコードベースの簡素化がさらに進みます。</target>
        </trans-unit>
        <trans-unit id="ed8c795d039e297badfdb934d5dad24eb9711fc6" translate="yes" xml:space="preserve">
          <source>Using the SQLite Online Backup API</source>
          <target state="translated">SQLiteオンラインバックアップAPIの使用</target>
        </trans-unit>
        <trans-unit id="702c33598d91f7511e11baf351b09ecd585c68e7" translate="yes" xml:space="preserve">
          <source>Using the VFS xAccess() method, SQLite queries the file-system to see if the journal file associated with the database exists. If it does not, then there is no hot-journal file.</source>
          <target state="translated">VFS の xAccess()メソッドを使用して、SQLite はファイルシステムに問い合わせて、データベースに関連付けられたジャーナルファイルが存在するかどうかを確認します。存在しない場合は、ホットジャーナルファイルは存在しません。</target>
        </trans-unit>
        <trans-unit id="15a6ded3b6ea323ecf5d8ed10a9908901c0cf29c" translate="yes" xml:space="preserve">
          <source>Using the memcpy() function on overlapping buffers.</source>
          <target state="translated">バッファが重複している場合の memcpy()関数の使用。</target>
        </trans-unit>
        <trans-unit id="0ff71664481484af5340c1f4f2d1ad694ff3ab5e" translate="yes" xml:space="preserve">
          <source>Using the new Idx2 index on &quot;state&quot;, SQLite has another option for lookup up the price of California oranges: it can look up every row that contains fruit from California and filter out those rows that are not oranges.</source>
          <target state="translated">state&quot; の新しい Idx2 インデックスを使用すると、SQLite にはカリフォルニアのオレンジの価格を調べるための別のオプションが用意されています。</target>
        </trans-unit>
        <trans-unit id="fcde00cc70debec35832ff9273a06512f95fa039" translate="yes" xml:space="preserve">
          <source>Using the sqlite3_unlock_notify() API</source>
          <target state="translated">sqlite3_unlock_notify()APIの使用</target>
        </trans-unit>
        <trans-unit id="08fc370c39b7ca0e2248cedd981f211b8dabd8d8" translate="yes" xml:space="preserve">
          <source>Using the two routines above, it is simple for applications to insert new records into or extract existing records from an SQLite Archive. Insert a new into an SQLite Archive using code like this:</source>
          <target state="translated">上記の 2 つのルーチンを使用すると、アプリケーションは SQLite アーカイブに新しいレコードを挿入したり、既存のレコードを抽出したりすることが簡単にできます。このようなコードを使用して、SQLite アーカイブに新しいレコードを挿入します。</target>
        </trans-unit>
        <trans-unit id="5881634960ec51d660f927c3ca27237c1640f650" translate="yes" xml:space="preserve">
          <source>Using the virtual table interface, new entries may be added to a zip archive by inserting new rows into the virtual table. Entries may be removed by deleting rows or modified by updating them.</source>
          <target state="translated">仮想テーブルインターフェースを使用して、新しいエントリを仮想テーブルに新しい行を挿入することで、ZIP アーカイブに追加することができます。エントリは、行を削除することで削除したり、更新することで変更することができます。</target>
        </trans-unit>
        <trans-unit id="e7f12616ba6b09fc33431b9c20577f960596b4bb" translate="yes" xml:space="preserve">
          <source>Using the xFileSize() method of the file-handle opened on the database file, SQLite checks if the database file is 0 bytes in size. If it is, the journal file is not considered to be a</source>
          <target state="translated">データベース・ファイル上で開かれたファイル・ハンドルの xFileSize()メソッドを使用して、SQLite はデータベース・ファイルのサイズが 0 バイトであるかどうかをチェックします。もしそうであれば、そのジャーナル・ファイルは</target>
        </trans-unit>
        <trans-unit id="18744e7331495a3e5c139b339aa5a7dcf1c94f70" translate="yes" xml:space="preserve">
          <source>Usually (the exceptions are &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; tables and &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables) a PRIMARY KEY in an SQLite table is really the same as a UNIQUE constraint. Due to an historical oversight, the column values of such a PRIMARY KEY are allowed to be NULL. This is a bug, but by the time the problem was discovered there where so many databases in circulation that depended on the bug that the decision was made to support the bugging behavior moving forward.</source>
          <target state="translated">通常（例外は&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;テーブルと&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルです）SQLiteテーブルのPRIMARY KEYは実際にはUNIQUE制約と同じです。歴史的な見落としのため、そのような主キーの列値はNULLにすることができます。これはバグですが、問題が発見された時点で、バグに依存する非常に多くのデータベースが循環しているため、バグの動作をサポートすることが決定されました。</target>
        </trans-unit>
        <trans-unit id="f79481390537aded0fd54463773aac91edd4e79c" translate="yes" xml:space="preserve">
          <source>Usually only a subset of the pages in the database file are read. In this example we are showing three pages out of eight being read. In a typical application, a database will have thousands of pages and a query will normally only touch a small percentage of those pages.</source>
          <target state="translated">通常、データベースファイル内のページのサブセットのみが読み込まれます。この例では、8ページのうち3ページが読み込まれていることを示しています。典型的なアプリケーションでは、データベースには何千ものページがあり、クエリは通常、それらのページのごく一部にしか触れません。</target>
        </trans-unit>
        <trans-unit id="27499120d97c0cbd6ba1013d6ea9b6e679141d60" translate="yes" xml:space="preserve">
          <source>Usually the b-trees for tables and indexes are slightly different. A table b-tree contains a 64-bit integer key and arbitrary data. The 64-bit integer key is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;. Index b-trees contain an arbitrary binary key and no data. So table b-trees and index b-trees are not directly compatible.</source>
          <target state="translated">通常、テーブルとインデックスのBツリーは少し異なります。テーブルのbツリーには、64ビットの整数キーと任意のデータが含まれています。64ビット整数キーは&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;です。インデックスbツリーには、任意のバイナリキーが含まれ、データは含まれません。したがって、テーブルBツリーとインデックスBツリーは直接互換性がありません。</target>
        </trans-unit>
        <trans-unit id="63880029448f25d934c11aa39c24fad9c0bb97f6" translate="yes" xml:space="preserve">
          <source>Usually, a new</source>
          <target state="translated">通常は、新しい</target>
        </trans-unit>
        <trans-unit id="251e8707bded33b5cb244d2e22971c5ac18fc6ad" translate="yes" xml:space="preserve">
          <source>Usually, an &lt;a href=&quot;fts3&quot;&gt;FTS3 or FTS4&lt;/a&gt; table is an example of a virtual table with a rowid that works like a PRIMARY KEY. So, for the following FTS4 tables:</source>
          <target state="translated">通常、&lt;a href=&quot;fts3&quot;&gt;FTS3またはFTS4&lt;/a&gt;テーブルは、主キーのように機能するROWIDを持つ仮想テーブルの例です。したがって、次のFTS4テーブルの場合：</target>
        </trans-unit>
        <trans-unit id="016fa908ece58367a08159cc60971094eae348ed" translate="yes" xml:space="preserve">
          <source>Usually, it does not matter if the page-sizes of the source database and the destination database are different before the contents of the destination are overwritten. The page-size of the destination database is simply changed as part of the backup operation. The exception is if the destination database happens to be an in-memory database. In this case, if the page sizes are not the same at the start of the backup operation, then the operation fails with an SQLITE_READONLY error. Unfortunately, this could occur when loading a database image from a file into an in-memory database using function loadOrSaveDb().</source>
          <target state="translated">通常、コピー元データベースとコピー先データベースのページサイズが異なっていても、コピー先のコンテンツが上書きされる前には問題ありません。宛先データベースのページサイズは、単にバックアップ操作の一部として変更されます。例外は、宛先データベースがインメモリ データベースである場合です。この場合、バックアップ操作の開始時にページサイズが同じでない場合、操作はSQLITE_READONLYエラーで失敗します。残念ながら、これは関数 loadOrSaveDb()を使用してファイルからインメモリデータベースにデータベースイメージをロードする際に発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="6590aa5b903de1376b91e1364c96b7ab1602da04" translate="yes" xml:space="preserve">
          <source>Usually, no data is actually written to the database file until the user commits the active</source>
          <target state="translated">通常、ユーザーがアクティブな</target>
        </trans-unit>
        <trans-unit id="5bf501f181ccf2cf7d7e6317299b267cead1ee47" translate="yes" xml:space="preserve">
          <source>Usually, output parameter *piPhrase is set to the phrase number, *piCol to the column in which it occurs and *piOff the token offset of the first token of the phrase. Returns SQLITE_OK if successful, or an error code (i.e. SQLITE_NOMEM) if an error occurs.</source>
          <target state="translated">通常、出力パラメータ *piPhrase にはフレーズ番号、*piCol にはそのフレーズが発生したカラム、*piOff にはそのフレーズの最初のトークンのトークンオフセットが設定されます。成功した場合は SQLITE_OK を、エラーが発生した場合はエラーコード (すなわち SQLITE_NOMEM)を返します。</target>
        </trans-unit>
        <trans-unit id="4375ef1d6cde5037d03b8ccb25b702b95cd0734d" translate="yes" xml:space="preserve">
          <source>Usually, the default mutex implementations provided by SQLite are sufficient, however the application has the option of substituting a custom implementation for specialized deployments or systems for which SQLite does not provide a suitable implementation. In this case, the application creates and populates an instance of this structure to pass to sqlite3_config() along with the &lt;a href=&quot;#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; option. Additionally, an instance of this structure can be used as an output variable when querying the system for the current mutex implementation, using the &lt;a href=&quot;#sqliteconfiggetmutex&quot;&gt;SQLITE_CONFIG_GETMUTEX&lt;/a&gt; option.</source>
          <target state="translated">通常、SQLiteによって提供されるデフォルトのミューテックス実装で十分ですが、アプリケーションには、SQLiteが適切な実装を提供していない特殊なデプロイメントまたはシステムをカスタム実装で置き換えるオプションがあります。この場合、アプリケーションはこの構造のインスタンスを作成して&lt;a href=&quot;#sqliteconfigmutex&quot;&gt;データを設定&lt;/a&gt;し、SQLITE_CONFIG_MUTEXオプションとともにsqlite3_config（）に渡します。さらに、&lt;a href=&quot;#sqliteconfiggetmutex&quot;&gt;SQLITE_CONFIG_GETMUTEX&lt;/a&gt;オプションを使用して、現在のミューテックス実装についてシステムにクエリを実行するときに、この構造体のインスタンスを出力変数として使用できます。</target>
        </trans-unit>
        <trans-unit id="d9cb5f2ee721a0e054d3593ea56d06ca4f711a8d" translate="yes" xml:space="preserve">
          <source>Usually, the default mutex implementations provided by SQLite are sufficient, however the application has the option of substituting a custom implementation for specialized deployments or systems for which SQLite does not provide a suitable implementation. In this case, the application creates and populates an instance of this structure to pass to sqlite3_config() along with the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; option. Additionally, an instance of this structure can be used as an output variable when querying the system for the current mutex implementation, using the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiggetmutex&quot;&gt;SQLITE_CONFIG_GETMUTEX&lt;/a&gt; option.</source>
          <target state="translated">通常、SQLiteによって提供されるデフォルトのミューテックス実装で十分ですが、アプリケーションには、SQLiteが適切な実装を提供していない特殊なデプロイメントまたはシステムをカスタム実装で置き換えるオプションがあります。この場合、アプリケーションはこの構造のインスタンスを作成して&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;データを設定&lt;/a&gt;し、SQLITE_CONFIG_MUTEXオプションとともにsqlite3_config（）に渡します。さらに、&lt;a href=&quot;c_config_covering_index_scan#sqliteconfiggetmutex&quot;&gt;SQLITE_CONFIG_GETMUTEX&lt;/a&gt;オプションを使用して、現在のミューテックス実装についてシステムにクエリを実行するときに、この構造体のインスタンスを出力変数として使用できます。</target>
        </trans-unit>
        <trans-unit id="f67d8e98eea6d06da4e67ed9ebc795e5c21c27d3" translate="yes" xml:space="preserve">
          <source>Usually, the parent key of a foreign key constraint is the primary key of the parent table. If they are not the primary key, then the parent key columns must be collectively subject to a UNIQUE constraint or have a UNIQUE index. If the parent key columns have a UNIQUE index, then that index must use the collation sequences that are specified in the CREATE TABLE statement for the parent table. For example,</source>
          <target state="translated">通常、外部キー制約の親キーは、親テーブルの主キーである。それらが主キーでない場合、親キーの列はまとめてUNIQUE制約の対象となるか、UNIQUEインデックスを持たなければなりません。親キー列がUNIQUEインデックスを持つ場合、そのインデックスは親テーブルのCREATE TABLE文で指定された照合順序を使用しなければなりません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="6dab9ce5b9389cc793db1ee13d4fd8a8749eccd9" translate="yes" xml:space="preserve">
          <source>Usually, the sessions module encloses all operations performed by a single call to apply_v2() or apply_v2_strm() in a &lt;a href=&quot;../lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;. The SAVEPOINT is committed if the changeset or patchset is successfully applied, or rolled back if an error occurs. Specifying this flag causes the sessions module to omit this savepoint. In this case, if the caller has an open transaction or savepoint when apply_v2() is called, it may revert the partially applied changeset by rolling it back.</source>
          <target state="translated">通常、セッションモジュールは、apply_v2（）またはapply_v2_strm（）への1回の呼び出しで実行されるすべての操作を&lt;a href=&quot;../lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;で囲みます。 SAVEPOINTは、チェンジセットまたはパッチセットが正常に適用された場合はコミットされ、エラーが発生した場合はロールバックされます。このフラグを指定すると、セッションモジュールはこのセーブポイントを省略します。この場合、apply_v2（）が呼び出されたときに呼び出し元が開いているトランザクションまたはセーブポイントを持っている場合、部分的に適用された変更セットをロールバックして元に戻すことがあります。</target>
        </trans-unit>
        <trans-unit id="651dad2d1a7cdde77afe8c8f6efa3556819be19f" translate="yes" xml:space="preserve">
          <source>Usually, the sessions module encloses all operations performed by a single call to apply_v2() or apply_v2_strm() in a &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;. The SAVEPOINT is committed if the changeset or patchset is successfully applied, or rolled back if an error occurs. Specifying this flag causes the sessions module to omit this savepoint. In this case, if the caller has an open transaction or savepoint when apply_v2() is called, it may revert the partially applied changeset by rolling it back.</source>
          <target state="translated">通常、セッションモジュールは、apply_v2（）またはapply_v2_strm（）への1回の呼び出しで実行されるすべての操作を&lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;で囲みます。 SAVEPOINTは、チェンジセットまたはパッチセットが正常に適用された場合はコミットされ、エラーが発生した場合はロールバックされます。このフラグを指定すると、セッションモジュールはこのセーブポイントを省略します。この場合、apply_v2（）が呼び出されたときに呼び出し元が開いているトランザクションまたはセーブポイントを持っている場合、部分的に適用された変更セットをロールバックして元に戻すことがあります。</target>
        </trans-unit>
        <trans-unit id="a7c5b3a786dedb589ca7dfd4119dc946fad418cc" translate="yes" xml:space="preserve">
          <source>Usually, when a database in wal mode is closed or detached from a database handle, SQLite checks if this will mean that there are now no connections at all to the database. If so, it performs a checkpoint operation before closing the connection. This option may be used to override this behaviour. The first parameter passed to this operation is an integer - positive to disable checkpoints-on-close, or zero (the default) to enable them, and negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether checkpoints-on-close have been disabled - 0 if they are not disabled, 1 if they are.</source>
          <target state="translated">通常、walモードのデータベースが閉じられたり、データベースハンドルから切り離されたりすると、SQLiteはこれがデータベースへの接続が全くないことを意味するかどうかをチェックします。その場合、接続を閉じる前にチェックポイント操作を実行します。このオプションを使用すると、この動作をオーバーライドすることができます。この操作に渡される最初のパラメータは整数です。 正の値を指定するとチェックポイントオンクローズを無効にし、負の値を指定するとチェックポイントを有効にします (デフォルト)。2 番目のパラメータは整数へのポインタで、チェックポイント・オン・クローズが無効になったかどうかを示す 0 または 1 が書き込まれます-無効になっていない場合は 0、無効になっている場合は 1 です。</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="998ce99ff7bc11e5fda480fd5bfcbe7172fa1458" translate="yes" xml:space="preserve">
          <source>Utter only truth from heart and mouth.</source>
          <target state="translated">心と口から真実だけを語ること。</target>
        </trans-unit>
        <trans-unit id="0a83488e309bcd16565cc48e7357404309c680f8" translate="yes" xml:space="preserve">
          <source>VACUUM</source>
          <target state="translated">VACUUM</target>
        </trans-unit>
        <trans-unit id="338c2017b922c8c778a643c9a2bb9bb0d159e34d" translate="yes" xml:space="preserve">
          <source>VACUUM INTO</source>
          <target state="translated">バキュームイン</target>
        </trans-unit>
        <trans-unit id="204b6e5828ce2852bf6877318b1361fbae1e4020" translate="yes" xml:space="preserve">
          <source>VACUUM uses a temporary file in the official TEMP folder, not in the same directory as the original database</source>
          <target state="translated">VACUUMは、元のデータベースと同じディレクトリではなく、公式TEMPフォルダ内の一時ファイルを使用しています。</target>
        </trans-unit>
        <trans-unit id="eba0ca62d23c0aa5d1fd44639bb5b08cca16a456" translate="yes" xml:space="preserve">
          <source>VACUUM with an INTO clause</source>
          <target state="translated">INTO句付きVACUUM</target>
        </trans-unit>
        <trans-unit id="b3cba55338b3625665f9ea5a7e33ff9db26da1af" translate="yes" xml:space="preserve">
          <source>VALUES</source>
          <target state="translated">VALUES</target>
        </trans-unit>
        <trans-unit id="3893415f582da8528cfdc804ac3bee7e25a15ab1" translate="yes" xml:space="preserve">
          <source>VALUES clause</source>
          <target state="translated">VALUES句</target>
        </trans-unit>
        <trans-unit id="2010132ce9d7ecb7ffcd8583e46eb6830b5b89ee" translate="yes" xml:space="preserve">
          <source>VARCHAR(255)</source>
          <target state="translated">VARCHAR(255)</target>
        </trans-unit>
        <trans-unit id="8e2934685262dc368f8941746e5ac5ff58123235" translate="yes" xml:space="preserve">
          <source>VARYING CHARACTER(255)</source>
          <target state="translated">変化する文字(255)</target>
        </trans-unit>
        <trans-unit id="efde179e9b49292e75991e12678580f142a070e1" translate="yes" xml:space="preserve">
          <source>VBegin</source>
          <target state="translated">VBegin</target>
        </trans-unit>
        <trans-unit id="d0eedafb13c92d47b81b7b056def9e323b6e493c" translate="yes" xml:space="preserve">
          <source>VColumn</source>
          <target state="translated">VColumn</target>
        </trans-unit>
        <trans-unit id="f84b9b0948754b7d110e0815c9837bdc1fddebe7" translate="yes" xml:space="preserve">
          <source>VCreate</source>
          <target state="translated">VCreate</target>
        </trans-unit>
        <trans-unit id="91b564dbaa1169fe6e48962a34cffa4f703f0be0" translate="yes" xml:space="preserve">
          <source>VDestroy</source>
          <target state="translated">VDestroy</target>
        </trans-unit>
        <trans-unit id="b33892fbddeffc3368077b4904ad0b3d562a7312" translate="yes" xml:space="preserve">
          <source>VERSION</source>
          <target state="translated">VERSION</target>
        </trans-unit>
        <trans-unit id="9913e8aa2ef97f43053931ebe92afe906139c950" translate="yes" xml:space="preserve">
          <source>VFS</source>
          <target state="translated">VFS</target>
        </trans-unit>
        <trans-unit id="e0bba973b3126bd49629e5735098909a83c37fb8" translate="yes" xml:space="preserve">
          <source>VFS Adaptor Related Assumptions</source>
          <target state="translated">VFSアダプタ関連の前提条件</target>
        </trans-unit>
        <trans-unit id="0427fe52d1301f469be76b38e86110229024c26c" translate="yes" xml:space="preserve">
          <source>VFS shim</source>
          <target state="translated">VFSシム</target>
        </trans-unit>
        <trans-unit id="42c3d050c1ab4fc79ee66e794588a38879f87c59" translate="yes" xml:space="preserve">
          <source>VFilter</source>
          <target state="translated">VFilter</target>
        </trans-unit>
        <trans-unit id="0fa2ff5785952199b4086a34e015d691fb6f638e" translate="yes" xml:space="preserve">
          <source>VIEW</source>
          <target state="translated">VIEW</target>
        </trans-unit>
        <trans-unit id="d1ea68c099681d5006dd208d2e34db6600ee8c5a" translate="yes" xml:space="preserve">
          <source>VIEWs in SQLite are read-only. You may not execute a DELETE, INSERT, or UPDATE statement on a view. But you can create a trigger that fires on an attempt to DELETE, INSERT, or UPDATE a view and do what you need in the body of the trigger.</source>
          <target state="translated">SQLite の VIEW は読み取り専用です。ビュー上でDELETE、INSERT、UPDATE文を実行することはできません。しかし、ビューのDELETE、INSERT、UPDATEを実行した際に発生するトリガーを作成し、トリガーの本文で必要な処理を行うことができます。</target>
        </trans-unit>
        <trans-unit id="5fe4dd429e7ca82543f447d5b6e37edc0b0211f3" translate="yes" xml:space="preserve">
          <source>VIRTUAL</source>
          <target state="translated">VIRTUAL</target>
        </trans-unit>
        <trans-unit id="b9de5e41c6dc887dbc8f743605405fee0be8e279" translate="yes" xml:space="preserve">
          <source>VNext</source>
          <target state="translated">VNext</target>
        </trans-unit>
        <trans-unit id="348f1db286c8e9b47c43f2f013b0dd88171bf692" translate="yes" xml:space="preserve">
          <source>VOpen</source>
          <target state="translated">VOpen</target>
        </trans-unit>
        <trans-unit id="9741852a241ce6064f8f2d351b08520dd5847d98" translate="yes" xml:space="preserve">
          <source>VRename</source>
          <target state="translated">VRename</target>
        </trans-unit>
        <trans-unit id="4bce4ebd3cc132100d6cc36475c7b1294f94edb7" translate="yes" xml:space="preserve">
          <source>VUpdate</source>
          <target state="translated">VUpdate</target>
        </trans-unit>
        <trans-unit id="5fe15df2c7882707d49fdc0903788dfd022b02ca" translate="yes" xml:space="preserve">
          <source>Vacuum</source>
          <target state="translated">Vacuum</target>
        </trans-unit>
        <trans-unit id="27b07b92ebcc99b13cdafff029c3e3d22606bada" translate="yes" xml:space="preserve">
          <source>Vacuum the entire database P1. P1 is 0 for &quot;main&quot;, and 2 or more for an attached database. The &quot;temp&quot; database may not be vacuumed.</source>
          <target state="translated">データベースP1全体にバキュームをかける。P1は &quot;main &quot;の場合は0、アタッチされたデータベースの場合は2以上です。temp &quot;データベースはバキュームされない場合があります。</target>
        </trans-unit>
        <trans-unit id="0819f8114e772508968d8c091f0521044cadc7f0" translate="yes" xml:space="preserve">
          <source>Valgrind analysis</source>
          <target state="translated">ヴァルグラインド分析</target>
        </trans-unit>
        <trans-unit id="4869177d0c589735a7d4b9114f8982fe5d26f899" translate="yes" xml:space="preserve">
          <source>Value is a BLOB that is (N-12)/2 bytes in length.</source>
          <target state="translated">値は(N-12)/2バイトの長さのBLOBです。</target>
        </trans-unit>
        <trans-unit id="5d5aa2bdd2060b855e479d53c2581cc8223ca5a6" translate="yes" xml:space="preserve">
          <source>Value is a NULL.</source>
          <target state="translated">値はNULLです。</target>
        </trans-unit>
        <trans-unit id="c499129fd21c535eaa7f12c5970a992328cc9e08" translate="yes" xml:space="preserve">
          <source>Value is a big-endian 16-bit twos-complement integer.</source>
          <target state="translated">値はビッグエンディアン16ビットの2補数整数です。</target>
        </trans-unit>
        <trans-unit id="e70cb145efe11c54bff7a396cfac28a6df7474e8" translate="yes" xml:space="preserve">
          <source>Value is a big-endian 24-bit twos-complement integer.</source>
          <target state="translated">値は24ビットのビッグエンディアン24ビット2補数の整数です。</target>
        </trans-unit>
        <trans-unit id="5e8e5ccfe7344d0d3d0abc79f36a5fdb932a3b7c" translate="yes" xml:space="preserve">
          <source>Value is a big-endian 32-bit twos-complement integer.</source>
          <target state="translated">値はビッグエンディアン32ビット2補数の整数です。</target>
        </trans-unit>
        <trans-unit id="b3f234aeea73b3135246f413e61277eaccb53eb8" translate="yes" xml:space="preserve">
          <source>Value is a big-endian 48-bit twos-complement integer.</source>
          <target state="translated">値は48ビットのビッグエンディアン2補数の整数です。</target>
        </trans-unit>
        <trans-unit id="af2248db1aa0f6b54f70fbd4bad24187360977fd" translate="yes" xml:space="preserve">
          <source>Value is a big-endian 64-bit twos-complement integer.</source>
          <target state="translated">値は64ビットのビッグエンディアン2補数の整数です。</target>
        </trans-unit>
        <trans-unit id="ae871c1581e8a49ebac1c7419a009e8fb57a2d5e" translate="yes" xml:space="preserve">
          <source>Value is a big-endian IEEE 754-2008 64-bit floating point number.</source>
          <target state="translated">値はビッグエンディアンの IEEE 754-2008 64 ビット浮動小数点数です。</target>
        </trans-unit>
        <trans-unit id="02f41d10900d18e2f000b1b5a2e593cf69aeca4b" translate="yes" xml:space="preserve">
          <source>Value is a string in the &lt;a href=&quot;fileformat2#enc&quot;&gt;text encoding&lt;/a&gt; and (N-13)/2 bytes in length. The nul terminator is not stored.</source>
          <target state="translated">値は&lt;a href=&quot;fileformat2#enc&quot;&gt;テキストエンコーディングの&lt;/a&gt;文字列で、長さは（N-13）/ 2バイトです。NULターミネーターは保管されません。</target>
        </trans-unit>
        <trans-unit id="d4c71d03558220fa7cbe0d35d7582077b87759fd" translate="yes" xml:space="preserve">
          <source>Value is an 8-bit twos-complement integer.</source>
          <target state="translated">値は 8 ビットの 2 補数整数です。</target>
        </trans-unit>
        <trans-unit id="21a8bbbdb0477e77f764478e79099dc10eca1b5a" translate="yes" xml:space="preserve">
          <source>Value is the integer 0. (Only available for &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;schema format&lt;/a&gt; 4 and higher.)</source>
          <target state="translated">値は整数0です（&lt;a href=&quot;fileformat2#schemaformat&quot;&gt;スキーマフォーマット&lt;/a&gt; 4以上でのみ使用できます）。</target>
        </trans-unit>
        <trans-unit id="4b218cb556caba65180a69703c18a8657584030f" translate="yes" xml:space="preserve">
          <source>Value is the integer 1. (Only available for &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;schema format&lt;/a&gt; 4 and higher.)</source>
          <target state="translated">値は整数1です（&lt;a href=&quot;fileformat2#schemaformat&quot;&gt;スキーマフォーマット&lt;/a&gt; 4以降でのみ使用できます）。</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="b74a3f9a59a12c1f692032bcd73742874ff821bd" translate="yes" xml:space="preserve">
          <source>Values for sqlite3session_config()</source>
          <target state="translated">sqlite3session_config()の値</target>
        </trans-unit>
        <trans-unit id="bc12625ab4c97d74dcdc9d561aba55de6f3648e6" translate="yes" xml:space="preserve">
          <source>Values for sqlite3session_config().</source>
          <target state="translated">sqlite3session_config()の値。</target>
        </trans-unit>
        <trans-unit id="21fb70cd308e717f82d11db0a79a04443511207e" translate="yes" xml:space="preserve">
          <source>Values of N between 100 and 1000 are recommended. Or, to disable the analysis limit, causing ANALYZE to do a complete scan of each index, set the analysis limit to 0. The default value for the analysis limit is 0 for backwards compatibility.</source>
          <target state="translated">N の値は 100 ~ 1000 を推奨します。または、解析制限を無効にして、ANALYZEが各インデックスの完全スキャンを行うようにするには、解析制限を0に設定します。 解析制限のデフォルト値は、下位互換性のために0に設定されています。</target>
        </trans-unit>
        <trans-unit id="4b975fa21a49b294e75ba8fe14419189c4abab11" translate="yes" xml:space="preserve">
          <source>Values stored in unindexed columns are not eligible to match MATCH operators. They do not influence the results of the offsets() or matchinfo() auxiliary functions. Nor will the snippet() function ever return a snippet based on a value stored in an unindexed column.</source>
          <target state="translated">インデックス化されていない列に格納されている値は、MATCH演算子にマッチする資格がありません。これらの値は、offsets()や matchinfo()補助関数の結果に影響を与えません。また、 snippet()関数が、インデックスのない列に格納された値に基づくスニペットを返すことはありません。</target>
        </trans-unit>
        <trans-unit id="c15b50c2bdb6ec892f0c03794f814403120328ad" translate="yes" xml:space="preserve">
          <source>Values that may be passed as the second argument to a conflict-handler.</source>
          <target state="translated">コンフリクトハンドラの第二引数として渡される値。</target>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="translated">Variable</target>
        </trans-unit>
        <trans-unit id="51a317c7ddc79a1154219a293b13d3647c7088e1" translate="yes" xml:space="preserve">
          <source>Various bug fixes and documentation updates.</source>
          <target state="translated">様々なバグ修正とドキュメントの更新。</target>
        </trans-unit>
        <trans-unit id="d5f06a4766a5315e31c33eb58743a7e83afa9adb" translate="yes" xml:space="preserve">
          <source>Various bug fixes and optimizations</source>
          <target state="translated">様々なバグ修正と最適化</target>
        </trans-unit>
        <trans-unit id="85d7c8482bd4c4d0eab034cc91f2ea5f21b20d90" translate="yes" xml:space="preserve">
          <source>Various bug fixes in the &lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt; tool.</source>
          <target state="translated">&lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt;ツールのさまざまなバグ修正。</target>
        </trans-unit>
        <trans-unit id="ecec24b66500dbd17ba7725547d5521b2d6d2040" translate="yes" xml:space="preserve">
          <source>Various code refactorizations for performance</source>
          <target state="translated">パフォーマンスのための様々なコードリファクタリゼーション</target>
        </trans-unit>
        <trans-unit id="85976ded19739ce2942c54c82204b742186a7556" translate="yes" xml:space="preserve">
          <source>Various compiler compatibility fixes.</source>
          <target state="translated">様々なコンパイラの互換性を修正しました。</target>
        </trans-unit>
        <trans-unit id="ab65a12d6caf25bdc60a4edee517dc1ebef7b909" translate="yes" xml:space="preserve">
          <source>Various improvements in how the query planner uses &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; information to estimate plan costs.</source>
          <target state="translated">クエリプランナーが&lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt;情報を使用してプランのコストを見積もる方法のさまざまな改善。</target>
        </trans-unit>
        <trans-unit id="03823e5b502773a079a3bee8b39ca22cddaecb57" translate="yes" xml:space="preserve">
          <source>Various minor bug and documentation typo fixes and performance enhancements.</source>
          <target state="translated">様々なマイナーなバグとドキュメントのタイポの修正とパフォーマンスの向上。</target>
        </trans-unit>
        <trans-unit id="10b44287786294b34c89472b1d33c638e18576ac" translate="yes" xml:space="preserve">
          <source>Various minor bug fixes</source>
          <target state="translated">様々なマイナーバグの修正</target>
        </trans-unit>
        <trans-unit id="3f779a48c89979c93ac37abe87c5a7687464bc7d" translate="yes" xml:space="preserve">
          <source>Various minor bug fixes and documentation enhancements.</source>
          <target state="translated">様々なマイナーなバグフィックスとドキュメントの強化。</target>
        </trans-unit>
        <trans-unit id="4847f53fde0fb417d8d4a76ab68b44562fd9a573" translate="yes" xml:space="preserve">
          <source>Various minor bug fixes and performance enhancements.</source>
          <target state="translated">様々なマイナーバグの修正とパフォーマンスの向上。</target>
        </trans-unit>
        <trans-unit id="95ba96bcd2bbb545050ce738d48cb5ec939831b2" translate="yes" xml:space="preserve">
          <source>Various minor bug fixes including fixes for tickets &lt;a href=&quot;https://www.sqlite.org/src/info/8f157e8010b22af0&quot;&gt;8f157e8010b22af0&lt;/a&gt;, &lt;a href=&quot;https://www.sqlite.org/src/info/9fb26d37cefaba40&quot;&gt;9fb26d37cefaba40&lt;/a&gt;, &lt;a href=&quot;https://www.sqlite.org/src/info/e367f31901ea8700&quot;&gt;e367f31901ea8700&lt;/a&gt;, &lt;a href=&quot;https://www.sqlite.org/src/info/b706351ce2ecf59a&quot;&gt;b706351ce2ecf59a&lt;/a&gt;, &lt;a href=&quot;https://www.sqlite.org/src/info/7c6d876f84e6e7e2&quot;&gt;7c6d876f84e6e7e2&lt;/a&gt;, and &lt;a href=&quot;https://www.sqlite.org/src/info/c8d3b9f0a750a529&quot;&gt;c8d3b9f0a750a529&lt;/a&gt;.</source>
          <target state="translated">Various minor bug fixes including fixes for tickets &lt;a href=&quot;https://www.sqlite.org/src/info/8f157e8010b22af0&quot;&gt;8f157e8010b22af0&lt;/a&gt;, &lt;a href=&quot;https://www.sqlite.org/src/info/9fb26d37cefaba40&quot;&gt;9fb26d37cefaba40&lt;/a&gt;, &lt;a href=&quot;https://www.sqlite.org/src/info/e367f31901ea8700&quot;&gt;e367f31901ea8700&lt;/a&gt;, &lt;a href=&quot;https://www.sqlite.org/src/info/b706351ce2ecf59a&quot;&gt;b706351ce2ecf59a&lt;/a&gt;, &lt;a href=&quot;https://www.sqlite.org/src/info/7c6d876f84e6e7e2&quot;&gt;7c6d876f84e6e7e2&lt;/a&gt;, and &lt;a href=&quot;https://www.sqlite.org/src/info/c8d3b9f0a750a529&quot;&gt;c8d3b9f0a750a529&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="3d9299a31e992a8798950b9ee230e2efd3cac0b2" translate="yes" xml:space="preserve">
          <source>Various minor bug fixes.</source>
          <target state="translated">様々なマイナーなバグ修正。</target>
        </trans-unit>
        <trans-unit id="2514c8b40a668dc1475dfd0f9f137b0141e179e2" translate="yes" xml:space="preserve">
          <source>Various performance improvements.</source>
          <target state="translated">様々なパフォーマンスの向上。</target>
        </trans-unit>
        <trans-unit id="6342eea4c52b8714f01d87ea8795935f65636135" translate="yes" xml:space="preserve">
          <source>Verify that an Abort can happen. Assert if an Abort at this point might cause database corruption. This opcode only appears in debugging builds.</source>
          <target state="translated">アボートが起こる可能性があることを検証します。この時点でのアボートがデータベースの破損を引き起こす可能性があるかどうかをアサートします。このオペコードはデバッグビルドでのみ表示されます。</target>
        </trans-unit>
        <trans-unit id="0e121d547f14e098984e65cce93a4f32d31bdccc" translate="yes" xml:space="preserve">
          <source>Version 1.0.X of SQLite used the GDBM library as its backend interface to the disk. Beginning in version 2.0.0, GDBM was replaced by a custom B-Tree library written especially for SQLite. The new B-Tree backend is twice as fast as GDBM, supports atomic commits and rollback, and stores an entire database in a single disk file instead using a separate file for each table as GDBM does. The two file formats are not even remotely similar.</source>
          <target state="translated">SQLite のバージョン 1.0.X では、ディスクへのバックエンドインターフェースとして GDBM ライブラリが使用されていました。バージョン 2.0.0.0 以降、GDBM は SQLite 用に特別に書かれたカスタム B-Tree ライブラリに置き換えられました。新しい B-Tree バックエンドは GDBM の 2 倍の速度を持ち、アトミックコミットとロールバックをサポートし、GDBM のようにテーブルごとに個別のファイルを使用するのではなく、データベース全体を 1 つのディスクファイルに格納します。2つのファイル形式は、全く似ていません。</target>
        </trans-unit>
        <trans-unit id="15147c06759c9052778bf2211d35cc6a76e87f68" translate="yes" xml:space="preserve">
          <source>Version 2.2.0 and later of the library will automatically detect when it is reading a 2.1.x database and will disable the new INTEGER PRIMARY KEY feature. In other words, version 2.2.x is backwards compatible to version 2.1.x. But version 2.1.x is not forward compatible with version 2.2.x. If you try to open a 2.2.x database with an older 2.1.x library and that database contains an INTEGER PRIMARY KEY, you will likely get a coredump. If the database schema does not contain any INTEGER PRIMARY KEYs, then the version 2.1.x and version 2.2.x database files will be identical and completely interchangeable.</source>
          <target state="translated">バージョン2.2.0以降のライブラリは、2.1.xのデータベースを読んでいるときに自動的に検出し、新しいINTEGER PRIMARY KEY機能を無効にします。つまり、バージョン2.2.xはバージョン2.1.xと下位互換性がありますが、バージョン2.1.xはバージョン2.2.xと上位互換性がありません。データベーススキーマに INTEGER PRIMARY KEY が含まれていない場合、バージョン 2.1.x とバージョン 2.2.x のデータベースファイルは同一であり、完全に互換性があります。</target>
        </trans-unit>
        <trans-unit id="0117d508d1c578c143be74741c597fcb4aa7a934" translate="yes" xml:space="preserve">
          <source>Version 2.6.0 or later of the library cannot open read-only database files from version 2.5.6 or earlier, since read-only files cannot be upgraded to the new format.</source>
          <target state="translated">バージョン2.6.0以降のライブラリでは、バージョン2.5.6以前のデータベースファイルを開くことができません。</target>
        </trans-unit>
        <trans-unit id="b22eaca7a28d27b61c642146bfe60e035fc837b9" translate="yes" xml:space="preserve">
          <source>Version 2.8.0 introduces a change to the format of the rollback journal file. The main database file format is unchanged. Versions 2.7.6 and earlier can read and write 2.8.0 databases and vice versa. Version 2.8.0 can rollback a transaction that was started by version 2.7.6 and earlier. But version 2.7.6 and earlier cannot rollback a transaction started by version 2.8.0 or later.</source>
          <target state="translated">バージョン2.8.0では、ロールバックジャーナルファイルのフォーマットの変更が導入されています。メインデータベースのファイル形式は変更されません。バージョン2.7.6以前のバージョンでは、2.8.0データベースを読み書きすることができ、その逆も可能です。バージョン2.8.0では、バージョン2.7.6以前のバージョンで開始されたトランザクションをロールバックすることができます。しかし、バージョン2.7.6以前のバージョンでは、バージョン2.8.0以降で開始されたトランザクションをロールバックすることはできません。</target>
        </trans-unit>
        <trans-unit id="5ab1c612d2172f97ee17ccb094511130795e0e49" translate="yes" xml:space="preserve">
          <source>Version 3.0.0 is a major upgrade for SQLite that incorporates support for UTF-16, BLOBs, and a more compact encoding that results in database files that are typically 25% to 50% smaller. The new file format is very different and is completely incompatible with the version 2 file format.</source>
          <target state="translated">バージョン 3.0.0 は SQLite のメジャーアップグレードで、UTF-16、BLOB、よりコンパクトなエンコーディングのサポートが組み込まれており、データベースファイルのサイズは通常 25% から 50% 小さくなっています。新しいファイル形式は非常に異なっており、バージョン2のファイル形式とは完全に互換性がありません。</target>
        </trans-unit>
        <trans-unit id="560474f7906b0238187c7f7b7f4ee43ef0381a4c" translate="yes" xml:space="preserve">
          <source>Version 3.10.0 introduced a case-folding bug in the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator which is fixed by this patch release. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/80369eddd5c94&quot;&gt;80369eddd5c94&lt;/a&gt;.</source>
          <target state="translated">バージョン3.10.0では、&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;演算子に大文字と小文字を区別するバグが導入されており、このパッチリリースで修正されています。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/80369eddd5c94&quot;&gt;80369eddd5c94&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="09330c4007db255bbeea2ef8f69d34761c5d8efc" translate="yes" xml:space="preserve">
          <source>Version 3.5.0 of SQLite changes the behavior of a few APIs in ways that are technically incompatible. However, these APIs are seldom used and even when they are used it is difficult to imagine a scenario where the change might break something. The changes actually makes these interface much more useful and powerful.</source>
          <target state="translated">SQLite のバージョン 3.5.0 では、いくつかの API の動作が技術的に互換性のない方法で変更されています。しかし、これらのAPIは滅多に使用されることはなく、使用される場合でも、変更によって何かが壊れる可能性があるシナリオを想像するのは難しいです。この変更により、実際にはこれらのインターフェイスがより便利で強力なものになります。</target>
        </trans-unit>
        <trans-unit id="621e552e91497473887ee98c411a17ae0c22faad" translate="yes" xml:space="preserve">
          <source>Version Change</source>
          <target state="translated">バージョン変更</target>
        </trans-unit>
        <trans-unit id="57c774f0b39c0a5a2da04603c552cf0b2e97f635" translate="yes" xml:space="preserve">
          <source>Version Numbers in SQLite</source>
          <target state="translated">SQLite のバージョン番号</target>
        </trans-unit>
        <trans-unit id="92c5569b77b82f07b395294f1952d2ab591b5725" translate="yes" xml:space="preserve">
          <source>Version method</source>
          <target state="translated">バージョン方式</target>
        </trans-unit>
        <trans-unit id="12b0595bc53b8fdea788b66adfb5e6aeb225a99c" translate="yes" xml:space="preserve">
          <source>Versioning of the SQLite source code has transitioned from CVS to &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt;.</source>
          <target state="translated">SQLiteソースコードのバージョン管理は、CVSから&lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossilに&lt;/a&gt;移行しました。</target>
        </trans-unit>
        <trans-unit id="9b36ebe549ad7e57c9fee50024e4b91ba9111a84" translate="yes" xml:space="preserve">
          <source>Very few CVEs written about SQLite are real vulnerabilities in the sense that they do not give any new capabilities to an attacker. Consider:</source>
          <target state="translated">SQLite について書かれている CVE は、攻撃者に新しい機能を与えないという意味で、実際の脆弱性と言えるものはほとんどありません。考えてみてください。</target>
        </trans-unit>
        <trans-unit id="2a826473d10edb3f601f04f14066361f0f7573c3" translate="yes" xml:space="preserve">
          <source>Via the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; and &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_vmprintf()&lt;/a&gt; interfaces, the built-in printf() implementation supports the ability to render an arbitrary-length string into a memory buffer obtained from &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc64()&lt;/a&gt;. This is safer and less error prone than trying to precompute an upper size limit on the result string, allocate an appropriately sized buffer, and then calling snprintf().</source>
          <target state="translated">介し&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;と&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_vmprintf（）&lt;/a&gt;インターフェース、内蔵のprintf（）の実装は、メモリに任意の長さの文字列をレンダリングする能力から得られた緩衝サポート&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc64を（） &lt;/a&gt;。これは、結果文字列の上限サイズを事前計算して適切なサイズのバッファを割り当ててから、snprintf（）を呼び出すよりも安全でエラーが発生しにくくなります。</target>
        </trans-unit>
        <trans-unit id="7661d9e884510184f3115feaa61daa7fb90ab554" translate="yes" xml:space="preserve">
          <source>Virtual File System Objects</source>
          <target state="translated">仮想ファイルシステムオブジェクト</target>
        </trans-unit>
        <trans-unit id="0f4f4c40c9b657d040c9a5a3549b3c5d32fbc234" translate="yes" xml:space="preserve">
          <source>Virtual Table Configuration Options</source>
          <target state="translated">仮想テーブル構成オプション</target>
        </trans-unit>
        <trans-unit id="57189223b1eb8b14988a31c1f5a4ff48cc80e85d" translate="yes" xml:space="preserve">
          <source>Virtual Table Constraint Operator Codes</source>
          <target state="translated">仮想テーブル制約演算子コード</target>
        </trans-unit>
        <trans-unit id="d3cabefe217e8ae9513576669d0630c721003893" translate="yes" xml:space="preserve">
          <source>Virtual Table Cursor Object</source>
          <target state="translated">仮想テーブルカーソルオブジェクト</target>
        </trans-unit>
        <trans-unit id="02d05d9b66c15b554ca60cadbe6ddd8d5a77642f" translate="yes" xml:space="preserve">
          <source>Virtual Table Indexing Information</source>
          <target state="translated">仮想テーブルインデックス情報</target>
        </trans-unit>
        <trans-unit id="80548cb099ad243dfef606537d8cb425cbe7b21c" translate="yes" xml:space="preserve">
          <source>Virtual Table Instance Object</source>
          <target state="translated">仮想テーブルインスタンスオブジェクト</target>
        </trans-unit>
        <trans-unit id="681b6ef1224b6badb83f1618372bb0a3a5b7009a" translate="yes" xml:space="preserve">
          <source>Virtual Table Interface Configuration</source>
          <target state="translated">仮想テーブルインタフェース構成</target>
        </trans-unit>
        <trans-unit id="b4e32b4e8d0ccc9df7f37bef23928bcdb8c21a47" translate="yes" xml:space="preserve">
          <source>Virtual Table Mechanism</source>
          <target state="translated">バーチャルテーブルの仕組み</target>
        </trans-unit>
        <trans-unit id="c7613e2461269638f02a689a01bdfb20ef96932a" translate="yes" xml:space="preserve">
          <source>Virtual Table Object</source>
          <target state="translated">仮想テーブルオブジェクト</target>
        </trans-unit>
        <trans-unit id="6fb2f6d632c98f78eae8aef07afc99de73e44e98" translate="yes" xml:space="preserve">
          <source>Virtual Table Scan Flags</source>
          <target state="translated">仮想テーブルスキャンフラグ</target>
        </trans-unit>
        <trans-unit id="c6305adeaa93ffb40a0b3ae2ce131299d686cab8" translate="yes" xml:space="preserve">
          <source>Virtual machine stores 64-bit integer and floating point constants in binary instead of text for a performance boost.</source>
          <target state="translated">仮想マシンは、パフォーマンスを向上させるために、テキストではなくバイナリで64ビット整数と浮動小数点定数を格納します。</target>
        </trans-unit>
        <trans-unit id="a4369e3d1e48bcfd676b740e0d14b603ed7287ae" translate="yes" xml:space="preserve">
          <source>Virtual table implementations are allowed to set the &lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.idxFlags field to some combination of these bits.</source>
          <target state="translated">仮想テーブルの実装では、&lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; .idxFlagsフィールドをこれらのビットの組み合わせに設定できます。</target>
        </trans-unit>
        <trans-unit id="7e7d9ed7bcb125e908a8e59f746fb86a62ee768a" translate="yes" xml:space="preserve">
          <source>Virtual table implementations are allowed to set the &lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.idxFlags field to some combination of these bits.</source>
          <target state="translated">仮想テーブルの実装では、&lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; .idxFlagsフィールドをこれらのビットの組み合わせに設定できます。</target>
        </trans-unit>
        <trans-unit id="1e1224e431f5f3956505068b6d1ec8eea58f8cfc" translate="yes" xml:space="preserve">
          <source>Virtual table implementations that are required to handle OR REPLACE must do so within the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method. If a call to the &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; function indicates that the current ON CONFLICT policy is REPLACE, the virtual table implementation should silently replace the appropriate rows within the xUpdate callback and return SQLITE_OK. Or, if this is not possible, it may return SQLITE_CONSTRAINT, in which case SQLite falls back to OR ABORT constraint handling.</source>
          <target state="translated">OR REPLACEの処理に必要な仮想テーブルの実装は、&lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;メソッド内で行う必要があります。&lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict（）&lt;/a&gt;関数の呼び出しが、現在のON CONFLICTポリシーがREPLACEであることを示している場合、仮想テーブルの実装は、xUpdateコールバック内の適切な行を通知なしで置き換え、SQLITE_OKを返す必要があります。または、これが不可能な場合は、SQLITE_CONSTRAINTを返すことがあります。その場合、SQLiteはOR ABORT制約処理にフォールバックします。</target>
        </trans-unit>
        <trans-unit id="6fd2d8e7bee948b9df988a6ac379b263c059c2c5" translate="yes" xml:space="preserve">
          <source>Virtual table implementations that are required to handle OR REPLACE must do so within the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method. If a call to the &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; function indicates that the current ON CONFLICT policy is REPLACE, the virtual table implementation should silently replace the appropriate rows within the xUpdate callback and return SQLITE_OK. Or, if this is not possible, it may return SQLITE_CONSTRAINT, in which case SQLite falls back to OR ABORT constraint handling.</source>
          <target state="translated">OR REPLACEの処理に必要な仮想テーブルの実装は、&lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;メソッド内で行う必要があります。&lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict（）&lt;/a&gt;関数の呼び出しが、現在のON CONFLICTポリシーがREPLACEであることを示している場合、仮想テーブルの実装は、xUpdateコールバック内の適切な行を通知なしで置き換え、SQLITE_OKを返す必要があります。または、これが不可能な場合は、SQLITE_CONSTRAINTを返すことがあります。その場合、SQLiteはOR ABORT制約処理にフォールバックします。</target>
        </trans-unit>
        <trans-unit id="81aaad6c6dfb9299173befc645c959005f239f65" translate="yes" xml:space="preserve">
          <source>Virtual table implementations will normally subclass this structure to add additional private and implementation-specific fields. The nRef field is used internally by the SQLite core and should not be altered by the virtual table implementation. The virtual table implementation may pass error message text to the core by putting an error message string in zErrMsg. Space to hold this error message string must be obtained from an SQLite memory allocation function such as &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; or &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. Prior to assigning a new value to zErrMsg, the virtual table implementation must free any preexisting content of zErrMsg using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;. Failure to do this will result in a memory leak. The SQLite core will free and zero the content of zErrMsg when it delivers the error message text to the client application or when it destroys the virtual table. The virtual table implementation only needs to worry about freeing the zErrMsg content when it overwrites the content with a new, different error message.</source>
          <target state="translated">仮想テーブル実装は通常、この構造をサブクラス化して、プライベートフィールドと実装固有のフィールドを追加します。 nRefフィールドはSQLiteコアによって内部的に使用され、仮想テーブルの実装によって変更されるべきではありません。仮想テーブルの実装は、エラーメッセージ文字列をzErrMsgに配置することにより、エラーメッセージテキストをコアに渡す場合があります。このエラーメッセージ文字列を保持するスペースは、&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;や&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;などのSQLiteメモリ割り当て関数から取得する必要があります。新しい値をzErrMsgに割り当てる前に、仮想テーブルの実装は、&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;を使用してzErrMsgの既存のコンテンツを解放する必要があります。これを行わないと、メモリリークが発生します。SQLiteコアは、エラーメッセージテキストをクライアントアプリケーションに配信するとき、または仮想テーブルを破棄するときに、zErrMsgのコンテンツを解放してゼロにします。仮想テーブルの実装では、zErrMsgのコンテンツを新しい別のエラーメッセージで上書きするときに、コンテンツの解放について心配するだけで済みます。</target>
        </trans-unit>
        <trans-unit id="40dd4a6572104b0d97f5845a7aa00abca493ea5c" translate="yes" xml:space="preserve">
          <source>Virtual tables</source>
          <target state="translated">仮想テーブル</target>
        </trans-unit>
        <trans-unit id="9c69270878a43f4468e25b3717d6b2598ec3353a" translate="yes" xml:space="preserve">
          <source>Virtual tables are ignored by default by sqldiff. However, it is possible to explicitly create an RBU data_% table for a virtual table that features a rowid that functions like a primary key using a command such as:</source>
          <target state="translated">仮想テーブルはデフォルトではsqldiffによって無視されます。しかし、次のようなコマンドを使用して、主キーのように機能する rowid を特徴とする仮想テーブル用の RBU data_% テーブルを明示的に作成することができます。</target>
        </trans-unit>
        <trans-unit id="4cb343842b9377b7930027e69fe1b4b95ab0bc54" translate="yes" xml:space="preserve">
          <source>Virtual tables can provide alternative implementations of functions using the &lt;a href=&quot;../vtab#xfindfunction&quot;&gt;xFindFunction&lt;/a&gt; method of the &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt;. But global versions of those functions must exist in order to be overloaded.</source>
          <target state="translated">仮想テーブルは、&lt;a href=&quot;module&quot;&gt;仮想テーブルモジュールの&lt;/a&gt;&lt;a href=&quot;../vtab#xfindfunction&quot;&gt;xFindFunction&lt;/a&gt;メソッドを使用して、関数の代替実装を提供できます。ただし、オーバーロードされるためには、これらの関数のグローバルバージョンが存在している必要があります。</target>
        </trans-unit>
        <trans-unit id="ea35a0ae0128b32ea2712f75cfcca274a0e301d3" translate="yes" xml:space="preserve">
          <source>Virtual tables can provide alternative implementations of functions using the &lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction&lt;/a&gt; method of the &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt;. But global versions of those functions must exist in order to be overloaded.</source>
          <target state="translated">仮想テーブルは、&lt;a href=&quot;#sqlite3_module&quot;&gt;仮想テーブルモジュールの&lt;/a&gt;&lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction&lt;/a&gt;メソッドを使用して、関数の代替実装を提供できます。ただし、オーバーロードされるためには、これらの関数のグローバルバージョンが存在している必要があります。</target>
        </trans-unit>
        <trans-unit id="17882224a33603a1de5faab8a2a01eaa906c2eb6" translate="yes" xml:space="preserve">
          <source>Virtual tables for which the &quot;rowid&quot; column does not function like a primary key value cannot be updated using RBU.</source>
          <target state="translated">rowid &quot;列が主キー値のように機能しない仮想テーブルは、RBUを使用して更新することができません。</target>
        </trans-unit>
        <trans-unit id="d97bfa2f28319cd6ae1be60d2bddfa72a278a536" translate="yes" xml:space="preserve">
          <source>Virtual tables methods can set an error message by assigning a string obtained from &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; to zErrMsg. The method should take care that any prior string is freed by a call to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; prior to assigning a new string to zErrMsg. After the error message is delivered up to the client application, the string will be automatically freed by sqlite3_free() and the zErrMsg field will be zeroed.</source>
          <target state="translated">仮想テーブルメソッドは、&lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;から取得した文字列をzErrMsgに割り当てることにより、エラーメッセージを設定できます。このメソッドは、新しい文字列をzErrMsgに割り当てる前に、&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）の&lt;/a&gt;呼び出しによって以前の文字列が解放されるように注意する必要があります。エラーメッセージがクライアントアプリケーションに配信された後、文字列はsqlite3_free（）によって自動的に解放され、zErrMsgフィールドはゼロになります。</target>
        </trans-unit>
        <trans-unit id="f460e6a98df6a13dcf481c34d0a877733d497773" translate="yes" xml:space="preserve">
          <source>Virtual tables methods can set an error message by assigning a string obtained from &lt;a href=&quot;mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; to zErrMsg. The method should take care that any prior string is freed by a call to &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; prior to assigning a new string to zErrMsg. After the error message is delivered up to the client application, the string will be automatically freed by sqlite3_free() and the zErrMsg field will be zeroed.</source>
          <target state="translated">仮想テーブルメソッドは、&lt;a href=&quot;mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;から取得した文字列をzErrMsgに割り当てることにより、エラーメッセージを設定できます。このメソッドは、新しい文字列をzErrMsgに割り当てる前に、&lt;a href=&quot;free&quot;&gt;sqlite3_free（）の&lt;/a&gt;呼び出しによって以前の文字列が解放されるように注意する必要があります。エラーメッセージがクライアントアプリケーションに配信された後、文字列はsqlite3_free（）によって自動的に解放され、zErrMsgフィールドはゼロになります。</target>
        </trans-unit>
        <trans-unit id="8dd3e411a2cd1cd0400ed8b91a5e2884ea85bf05" translate="yes" xml:space="preserve">
          <source>Virtual terms are used for analysis only and do not cause any byte-code to be generated. If both virtual terms end up being used as constraints on an index, then the original BETWEEN term is omitted and the corresponding test is not performed on input rows. Thus if the BETWEEN term ends up being used as an index constraint no tests are ever performed on that term. On the other hand, the virtual terms themselves never causes tests to be performed on input rows. Thus if the BETWEEN term is not used as an index constraint and instead must be used to test input rows, the</source>
          <target state="translated">仮想項は解析のためだけに使用され、バイトコードが生成されることはありません。両方の仮想項がインデックスの制約として使用される場合、元のBETWEEN項は省略され、対応するテストは入力行に対して実行されません。したがって、BETWEEN項がインデックス制約として使用されて終わる場合、その項に対してテストは実行されません。一方、仮想項自体は、入力行でテストが実行されることはありません。したがって、BETWEEN項がインデックス制約として使用されず、代わりに入力行をテストするために使用されなければならない場合は</target>
        </trans-unit>
        <trans-unit id="69180499c91410d16271921874ed2a25a5b8ba2f" translate="yes" xml:space="preserve">
          <source>Visit the sick.</source>
          <target state="translated">病人を訪ねて</target>
        </trans-unit>
        <trans-unit id="c18668323ee175259b4d33e74c3e8421bb9608b5" translate="yes" xml:space="preserve">
          <source>Vulnerabilities</source>
          <target state="translated">Vulnerabilities</target>
        </trans-unit>
        <trans-unit id="63fbb3bb789b808aff0169713cbc7f0fe8b26b33" translate="yes" xml:space="preserve">
          <source>WAL Frame Header Format</source>
          <target state="translated">WALフレームヘッダフォーマット</target>
        </trans-unit>
        <trans-unit id="744e2e67c24aa24ef2724e0cca0702b0e396b77b" translate="yes" xml:space="preserve">
          <source>WAL Header Format</source>
          <target state="translated">WALヘッダー形式</target>
        </trans-unit>
        <trans-unit id="06c6d5627eae51ea8b07e45901c927d0fff1639e" translate="yes" xml:space="preserve">
          <source>WAL backwards compatibility</source>
          <target state="translated">WALの下位互換性</target>
        </trans-unit>
        <trans-unit id="7f3d7dac78ce17ee863e11b29dd77ba4c3b844b1" translate="yes" xml:space="preserve">
          <source>WAL checksum algorithm</source>
          <target state="translated">WALチェックサムアルゴリズム</target>
        </trans-unit>
        <trans-unit id="43394fc5704020bd91d68a3ea6cb25e34c7a31ef" translate="yes" xml:space="preserve">
          <source>WAL concurrency</source>
          <target state="translated">WALの同時実行</target>
        </trans-unit>
        <trans-unit id="52a8587a456d98f221f4f9bce63c226fcda62f9a" translate="yes" xml:space="preserve">
          <source>WAL file</source>
          <target state="translated">WALファイル</target>
        </trans-unit>
        <trans-unit id="50ce9ea412cfc1994dee0ce8829cf26ea47867fa" translate="yes" xml:space="preserve">
          <source>WAL format</source>
          <target state="translated">WAL形式</target>
        </trans-unit>
        <trans-unit id="2c59f37be8a8a85d4967e8d84ff245b823d2c3d3" translate="yes" xml:space="preserve">
          <source>WAL is significantly faster in most scenarios.</source>
          <target state="translated">ほとんどのシナリオではWALの方が圧倒的に速い。</target>
        </trans-unit>
        <trans-unit id="df48eb81aeb4b91265bedea157514a68984a16d8" translate="yes" xml:space="preserve">
          <source>WAL might be very slightly slower (perhaps 1% or 2% slower) than the traditional rollback-journal approach in applications that do mostly reads and seldom write.</source>
          <target state="translated">WALは、従来のロールバックジャーナルのアプローチよりも、ほとんど読み込んで書き込みをしないアプリケーションでは、非常にわずかに遅くなるかもしれません(おそらく1%か2%遅いでしょう)。</target>
        </trans-unit>
        <trans-unit id="4a97139b7e130c0c8a433bdf669136c84f9136b7" translate="yes" xml:space="preserve">
          <source>WAL mode permits simultaneous readers and writers. It can do this because changes do not overwrite the original database file, but rather go into the separate write-ahead log file. That means that readers can continue to read the old, original, unaltered content from the original database file at the same time that the writer is appending to the write-ahead log. In &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, SQLite exhibits &quot;snapshot isolation&quot;. When a read transaction starts, that reader continues to see an unchanging &quot;snapshot&quot; of the database file as it existed at the moment in time when the read transaction started. Any write transactions that commit while the read transaction is active are still invisible to the read transaction, because the reader is seeing a snapshot of database file from a prior moment in time.</source>
          <target state="translated">WALモードでは、リーダーとライターを同時に使用できます。これは、変更によって元のデータベースファイルが上書きされるのではなく、個別の先行書き込みログファイルに書き込まれるためです。つまり、リーダーは、ライターが先行書き込みログに追加すると同時に、元のデータベースファイルから古い、元の、変更されていないコンテンツを引き続き読み取ることができます。で&lt;a href=&quot;wal&quot;&gt;WALモード&lt;/a&gt;、SQLiteは「スナップショット・アイソレーション」を示します。読み取りトランザクションが開始すると、そのリーダーは、読み取りトランザクションが開始した時点で存在していたデータベースファイルの不変の「スナップショット」を引き続き表示します。読み取りトランザクションがアクティブなときにコミットする書き込みトランザクションは、読み取りトランザクションからは見えません。これは、リーダーが前の瞬間のデータベースファイルのスナップショットを参照しているためです。</target>
        </trans-unit>
        <trans-unit id="cd8ce3e93d7ff89ed9c8371ea6e45fd8f37cf883" translate="yes" xml:space="preserve">
          <source>WAL mode with synchronous NORMAL,</source>
          <target state="translated">同期のNORMALとのWALモード。</target>
        </trans-unit>
        <trans-unit id="02d4a388313bcdd7b2c200b7ae8c4e65a2674e7c" translate="yes" xml:space="preserve">
          <source>WAL normally requires that the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; support shared-memory primitives. (Exception: &lt;a href=&quot;wal#noshm&quot;&gt;WAL without shared memory&lt;/a&gt;) The built-in unix and windows VFSes support this but third-party extension VFSes for custom operating systems might not.</source>
          <target state="translated">WALでは通常、&lt;a href=&quot;vfs&quot;&gt;VFSが&lt;/a&gt;共有メモリプリミティブをサポートする必要があります。 （例外：&lt;a href=&quot;wal#noshm&quot;&gt;共有メモリなしのWAL&lt;/a&gt;）組み込みのUNIXおよびWindows VFSはこれをサポートしますが、カスタムオペレーティングシステムのサードパーティ拡張VFSはサポートしない場合があります。</target>
        </trans-unit>
        <trans-unit id="773f18c2587f00153abb58a02a9105f99addd056" translate="yes" xml:space="preserve">
          <source>WAL provides more concurrency as readers do not block writers and a writer does not block readers. Reading and writing can proceed concurrently.</source>
          <target state="translated">WALは、読み手が書き手をブロックせず、書き手が読み手をブロックしないため、より多くの同時実行性を提供します。読み取りと書き込みは同時に進行することができます。</target>
        </trans-unit>
        <trans-unit id="c92f6b05049160f00dd8c3ee0f71a3f765656c3a" translate="yes" xml:space="preserve">
          <source>WAL read algorithm</source>
          <target state="translated">WAL読取りアルゴリズム</target>
        </trans-unit>
        <trans-unit id="ea6e19418d259cb4081e953d6c25797fc3b82935" translate="yes" xml:space="preserve">
          <source>WAL reset</source>
          <target state="translated">WALリセット</target>
        </trans-unit>
        <trans-unit id="ba93da00cc71fcc3b4f076052eaeb32eb6b9800c" translate="yes" xml:space="preserve">
          <source>WAL uses many fewer fsync() operations and is thus less vulnerable to problems on systems where the fsync() system call is broken.</source>
          <target state="translated">WAL はより少ない数の fsync()操作を使用するので、fsync()システムコールが壊れているシステムでの問題に対する脆弱性が低くなります。</target>
        </trans-unit>
        <trans-unit id="935e3aae9a4d9f6fb670dd29df8a280f6a07053c" translate="yes" xml:space="preserve">
          <source>WAL without shared memory</source>
          <target state="translated">共有メモリなしのWAL</target>
        </trans-unit>
        <trans-unit id="c5c7bca44dc98aebaf5146b41dc5aa511b8a8aa6" translate="yes" xml:space="preserve">
          <source>WAL-Index Header Details</source>
          <target state="translated">WAL-indexヘッダーの詳細</target>
        </trans-unit>
        <trans-unit id="e370010e43949311e2b789c1fcb72213cd69886b" translate="yes" xml:space="preserve">
          <source>WAL-Index Header Divisions</source>
          <target state="translated">WAL-indexヘッダ部</target>
        </trans-unit>
        <trans-unit id="738cab6ddeb95b98c824e2fa6c01b30e9dcb5952" translate="yes" xml:space="preserve">
          <source>WAL-Index Locks Controlled By xShmLock()</source>
          <target state="translated">xShmLock()で制御される WAL-Index ロック</target>
        </trans-unit>
        <trans-unit id="f9538dc159e3d4ee9069c606e83b7a548fc2f640" translate="yes" xml:space="preserve">
          <source>WAL-index format</source>
          <target state="translated">WALインデックス形式</target>
        </trans-unit>
        <trans-unit id="bfa5d0e78b2dc4651911fcb18213d8d8bcf10c94" translate="yes" xml:space="preserve">
          <source>WAL-mode File Format</source>
          <target state="translated">WALモードファイルフォーマット</target>
        </trans-unit>
        <trans-unit id="de71e324c9bcbf886760fa79f3cdf3359f06f756" translate="yes" xml:space="preserve">
          <source>WAL-mode crash recovery</source>
          <target state="translated">WALモードクラッシュ回復</target>
        </trans-unit>
        <trans-unit id="f45f2752fdcaf800e0a1910433e500b6102d9c5c" translate="yes" xml:space="preserve">
          <source>WAL-mode locks</source>
          <target state="translated">WALモードロック</target>
        </trans-unit>
        <trans-unit id="0e94e9cb4190e9d9687693e4eaf1537e92418a3d" translate="yes" xml:space="preserve">
          <source>WAL-mode read blocking</source>
          <target state="translated">WALモード読取りブロッキング</target>
        </trans-unit>
        <trans-unit id="b20f2962509be83b4058f80a47d244e5b11196b8" translate="yes" xml:space="preserve">
          <source>WAL_CKPT_LOCK</source>
          <target state="translated">WAL_CKPT_LOCK</target>
        </trans-unit>
        <trans-unit id="7d8dca53c800f5b912f5029eb6c49020dba95f10" translate="yes" xml:space="preserve">
          <source>WAL_READ_LOCK(0)</source>
          <target state="translated">WAL_READ_LOCK(0)</target>
        </trans-unit>
        <trans-unit id="182225568ec6a131ef84113496e8619eaa0d74bc" translate="yes" xml:space="preserve">
          <source>WAL_READ_LOCK(1)</source>
          <target state="translated">WAL_READ_LOCK(1)</target>
        </trans-unit>
        <trans-unit id="e7da30047a308b88f352a994772f05755945376a" translate="yes" xml:space="preserve">
          <source>WAL_READ_LOCK(2)</source>
          <target state="translated">WAL_READ_LOCK(2)</target>
        </trans-unit>
        <trans-unit id="af1d79e6c2231524894cbc98a7822ed397be08ea" translate="yes" xml:space="preserve">
          <source>WAL_READ_LOCK(3)</source>
          <target state="translated">WAL_READ_LOCK(3)</target>
        </trans-unit>
        <trans-unit id="33fe625c4da68b4d223dd3cf41bf33912b01d2d2" translate="yes" xml:space="preserve">
          <source>WAL_READ_LOCK(4)</source>
          <target state="translated">WAL_READ_LOCK(4)</target>
        </trans-unit>
        <trans-unit id="5e15c21a39d31cebadee8ce801a0923d71efe684" translate="yes" xml:space="preserve">
          <source>WAL_RECOVER_LOCK</source>
          <target state="translated">WAL_RECOVER_LOCK</target>
        </trans-unit>
        <trans-unit id="97bb53df8b738f49899ec6f8612f4070a67257d9" translate="yes" xml:space="preserve">
          <source>WAL_WRITE_LOCK</source>
          <target state="translated">WAL_WRITE_LOCK</target>
        </trans-unit>
        <trans-unit id="962a5cebdb56ec36c6dbf4d84e53c7c677fcc3ab" translate="yes" xml:space="preserve">
          <source>WARNING/TODO: This function currently assumes that the input is a valid changeset. If it is not, the results are undefined.</source>
          <target state="translated">警告/TODO:この関数は現在、入力が有効なチェンジセットであることを前提としています。そうでない場合、結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="66428bb1d785a8e164fb6679f1dcee0c10acabb5" translate="yes" xml:space="preserve">
          <source>WARNING: If this macro is defined, it will not be possible to open a database for which the schema contains VIEW objects.</source>
          <target state="translated">警告:このマクロが定義されている場合、スキーマに VIEW オブジェクトが含まれているデータベースを開くことはできません。</target>
        </trans-unit>
        <trans-unit id="e3eafa40a094c805daed78cdb48c723e5b81b9a1" translate="yes" xml:space="preserve">
          <source>WHEN</source>
          <target state="translated">WHEN</target>
        </trans-unit>
        <trans-unit id="1c255b91e71a2fddc2e75f8455387053d412a4c1" translate="yes" xml:space="preserve">
          <source>WHERE</source>
          <target state="translated">WHERE</target>
        </trans-unit>
        <trans-unit id="cfda4d41a395db406982a11851ae2e1bfcf9956d" translate="yes" xml:space="preserve">
          <source>WHERE clause</source>
          <target state="translated">WHERE句</target>
        </trans-unit>
        <trans-unit id="f21acb9f8ec93625bf5c0906f54fc785624f93c0" translate="yes" xml:space="preserve">
          <source>WHERE clause constraints that are connected by OR instead of AND can be handled in two different ways. If a term consists of multiple subterms containing a common column name and separated by OR, like this:</source>
          <target state="translated">ANDの代わりにORで接続されるWHERE句制約は、2つの異なる方法で処理することができます。項が、以下のように、共通の列名を含む複数のサブタームで構成され、ORで区切られている場合。</target>
        </trans-unit>
        <trans-unit id="1e47856edce4197b9e0ea412ab9daf0c805ed99c" translate="yes" xml:space="preserve">
          <source>WHERE clause expressions using BETWEEN and OR are now candidates for optimization</source>
          <target state="translated">BETWEEN と OR を使用する WHERE 句式は、現在最適化の候補となっています。</target>
        </trans-unit>
        <trans-unit id="201f5bdde79034efdfb90c4b9a48c56dd51af9e1" translate="yes" xml:space="preserve">
          <source>WINDOW</source>
          <target state="translated">WINDOW</target>
        </trans-unit>
        <trans-unit id="7913945997a369e8ea6004dfc36b2844dceea418" translate="yes" xml:space="preserve">
          <source>WITH</source>
          <target state="translated">WITH</target>
        </trans-unit>
        <trans-unit id="9ced6ee9ff3324806557c62b472be54adbd37321" translate="yes" xml:space="preserve">
          <source>WITH clause</source>
          <target state="translated">ウィズ句</target>
        </trans-unit>
        <trans-unit id="56fbadc8d9764a70500cf87f645a8260e6c6c396" translate="yes" xml:space="preserve">
          <source>WITHOUT</source>
          <target state="translated">WITHOUT</target>
        </trans-unit>
        <trans-unit id="80ce6a3273f099b101fd71e15344b4ac7f67fb42" translate="yes" xml:space="preserve">
          <source>WITHOUT ROWID is found only in SQLite and is not compatible with any other SQL database engine, as far as we know. In an elegant system, all tables would behave as WITHOUT ROWID tables even without the WITHOUT ROWID keyword. However, when SQLite was first designed, it used only integer &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowids&lt;/a&gt; for row keys to simplify the implementation. This approach worked well for many years. But as the demands on SQLite grew, the need for tables in which the PRIMARY KEY really did correspond to the underlying row key grew more acute. The WITHOUT ROWID concept was added in order to meet that need without breaking backwards compatibility with the billions of SQLite databases already in use at the time (circa 2013).</source>
          <target state="translated">WITHOUT ROWIDはSQLiteにのみあり、他のSQLデータベースエンジンとは互換性がありません。エレガントなシステムでは、WITHOUT ROWIDキーワードがなくても、すべてのテーブルがWITHOUT ROWIDテーブルとして動作します。ただし、SQLiteが最初に設計されたときは、実装を簡略化するために行キーに整数&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;のみを使用していました。このアプローチは長年にわたってうまく機能していました。しかし、SQLiteに対する要求が高まるにつれ、PRIMARY KEYが基になる行キーに実際に対応するテーブルの必要性がさらに高まりました。 WITHOUT ROWIDの概念は、当時すでに使用されている数十億のSQLiteデータベースとの下位互換性を壊すことなくそのニーズを満たすために追加されました（2013年頃）。</target>
        </trans-unit>
        <trans-unit id="468208bc9196912bc7723c91a3fae9cc04615357" translate="yes" xml:space="preserve">
          <source>WITHOUT ROWID tables will work correctly (that is to say, they provide the correct answer) for tables with a single INTEGER PRIMARY KEY. However, ordinary rowid tables will run faster in that case. Hence, it is good design to avoid creating WITHOUT ROWID tables with single-column PRIMARY KEYs of type INTEGER.</source>
          <target state="translated">WITHOUT ROWIDテーブルは、単一のINTEGER PRIMARY KEYを持つテーブルに対して正しく動作します(つまり、正しい答えを提供します)。しかし、通常のROWIDテーブルはその場合より速く実行されます。したがって、INTEGER型の単一列PRIMARY KEYを持つWITHOUT ROWIDテーブルを作成しないようにするのが良い設計です。</target>
        </trans-unit>
        <trans-unit id="a47008723e245eb9b8569a96c7a79d51a50cb56f" translate="yes" xml:space="preserve">
          <source>WITHOUT ROWID tables work best when individual rows are not too large. A good rule-of-thumb is that the average size of a single row in a WITHOUT ROWID table should be less than about 1/20th the size of a database page. That means that rows should not contain more than about 50 bytes each for a 1KiB page size or about 200 bytes each for 4KiB page size. WITHOUT ROWID tables will work (in the sense that they get the correct answer) for arbitrarily large rows - up to 2GB in size - but traditional rowid tables tend to work faster for large row sizes. This is because rowid tables are implemented as &lt;a href=&quot;fileformat2#btree&quot;&gt;B*-Trees&lt;/a&gt; where all content is stored in the leaves of the tree, whereas WITHOUT ROWID tables are implemented using ordinary B-Trees with content stored on both leaves and intermediate nodes. Storing content in intermediate nodes mean that each intermediate node entry takes up more space on the page and thus reduces the fan-out, increasing the search cost.</source>
          <target state="translated">WITHOUT ROWIDテーブルは、個々の行が大きすぎない場合に最適に機能します。目安としては、WITHOUT ROWIDテーブルの単一行の平均サイズは、データベースページのサイズの約1/20未満にする必要があります。つまり、行には、1KiBのページサイズの場合は約50バイト、4KiBのページサイズの場合は約200バイトを超えることはできません。 ROWIDなしのテーブルは（正しい答えが得られるという意味で）任意の大きな行（サイズが2GBまで）でも機能しますが、従来のROWIDテーブルは、行のサイズが大きいほど速く機能する傾向があります。これは、ROWIDテーブルが&lt;a href=&quot;fileformat2#btree&quot;&gt;B *ツリー&lt;/a&gt;として実装されているためです。すべてのコンテンツはツリーのリーフに格納されますが、WITHOUT ROWIDテーブルは、リーフと中間ノードの両方にコンテンツが格納された通常のBツリーを使用して実装されます。中間ノードにコンテンツを保存すると、各中間ノードエントリがページ上のより多くのスペースを占めるため、ファンアウトが減少し、検索コストが増加します。</target>
        </trans-unit>
        <trans-unit id="88d3b9ec414c3ffacd30f5fa1e3b51d5e7c1696c" translate="yes" xml:space="preserve">
          <source>WITHOUT ROWID virtual table</source>
          <target state="translated">WITHOUT ROWID 仮想テーブル</target>
        </trans-unit>
        <trans-unit id="bff1c33df73d6a6c2b628488a2bcad9b0fe90c82" translate="yes" xml:space="preserve">
          <source>Wait for the rolled back changes to be written onto persistent storage. This protects the integrity of the database in case another power failure or crash occurs.</source>
          <target state="translated">ロールバックされた変更が永続的なストレージに書き込まれるのを待ちます。これは、別の停電やクラッシュが発生した場合に備えて、データベースの整合性を保護します。</target>
        </trans-unit>
        <trans-unit id="dd9635431d3610b419ecc620dedbc828ed50792c" translate="yes" xml:space="preserve">
          <source>Was generated by this script:</source>
          <target state="translated">このスクリプトで生成されました。</target>
        </trans-unit>
        <trans-unit id="637f65e1bae93912cb8bee734b406fd7ee161d5f" translate="yes" xml:space="preserve">
          <source>We also run SQLite using &lt;a href=&quot;http://valgrind.org&quot;&gt;Valgrind&lt;/a&gt; on Linux and verify that it detects no problems.</source>
          <target state="translated">Linuxで&lt;a href=&quot;http://valgrind.org&quot;&gt;Valgrind&lt;/a&gt;を使用してSQLiteを実行し、問題が検出されないことを確認します。</target>
        </trans-unit>
        <trans-unit id="2bac0ed4b37946dad20096d0b073432309bee989" translate="yes" xml:space="preserve">
          <source>We are aware of no other</source>
          <target state="translated">他にはありません。</target>
        </trans-unit>
        <trans-unit id="c52eb400cd855fce10ed2a5a6e3b50ba60a61275" translate="yes" xml:space="preserve">
          <source>We are told that in some flash memory controllers the wear-leveling logic can cause random filesystem damage if power is interrupted during a write. This can manifest, for example, as random changes in the middle of a file that was not even open at the time of the power loss. So, for example, a device would be writing content into an MP3 file in flash memory when a power loss occurs, and that could result in an SQLite database being corrupted even though the database was not even in use at the time of the power loss.</source>
          <target state="translated">フラッシュメモリコントローラの中には、書き込み中に電源が遮断されると、ウェアレベリングロジックがランダムにファイルシステムにダメージを与えるものがあると聞いています。これは、例えば、電源喪失時には開いていなかったファイルの途中でランダムに変化することがあります。例えば、電源喪失時にフラッシュメモリ内のMP3ファイルにコンテンツを書き込んでいた場合、電源喪失時にはデータベースが使用されていなかったにもかかわらず、SQLiteデータベースが破損してしまう可能性があります。</target>
        </trans-unit>
        <trans-unit id="3cba495c2a4fa9e3aad438fbdcf0294c4dcb9df3" translate="yes" xml:space="preserve">
          <source>We assume that disk is written in chunks which we call a &quot;sector&quot;. It is not possible to modify any part of the disk smaller than a sector. To change a part of the disk smaller than a sector, you have to read in the full sector that contains the part you want to change, make the change, then write back out the complete sector.</source>
          <target state="translated">ディスクは「セクタ」と呼ばれるチャンク単位で書かれていると仮定します。セクターよりも小さいディスクの一部を変更することはできません。セクタよりも小さいディスクの一部を変更するには、変更したい部分を含む完全なセクタを読み込んで変更を行い、完全なセクタを書き出さなければなりません。</target>
        </trans-unit>
        <trans-unit id="6dd2d15ae4f93de39a47cf41448e74b994733012" translate="yes" xml:space="preserve">
          <source>We begin with a problem that can be solved using a VDBE program that is only a few instructions long. Suppose we have an SQL table that was created like this:</source>
          <target state="translated">数命令しかないVDBEプログラムを使って解決できる問題から始める。このように作成されたSQLテーブルがあるとします。</target>
        </trans-unit>
        <trans-unit id="db9e6f9dd85fc9f8e31996438093b69f82ad2ed0" translate="yes" xml:space="preserve">
          <source>We begin with an overview of the steps SQLite takes in order to perform an atomic commit of a transaction against a single database file. The details of file formats used to guard against damage from power failures and techniques for performing an atomic commit across multiple databases are discussed in later sections.</source>
          <target state="translated">まず、SQLite が単一のデータベースファイルに対してトランザクションのアトミックコミットを実行するために行う手順の概要を説明します。停電による損傷を防ぐために使用されるファイル形式の詳細と、複数のデータベースに対してアトミックコミットを実行するための技術については、後のセクションで説明します。</target>
        </trans-unit>
        <trans-unit id="38bf89df215372375d066b70f4b36998e95fafff" translate="yes" xml:space="preserve">
          <source>We believe that most modern disk drives implement atomic sector writes. When power is lost, the drive uses energy stored in capacitors and/or the angular momentum of the disk platter to provide power to complete any operation in progress. Nevertheless, there are so many layers in between the write system call and the on-board disk drive electronics that we take the safe approach in both Unix and w32 VFS implementations and assume that sector writes are not atomic. On the other hand, device manufacturers with more control over their filesystems might want to consider enabling the atomic write property of xDeviceCharacteristics if their hardware really does do atomic writes.</source>
          <target state="translated">最新のディスクドライブのほとんどは、アトミックセクター書き込みを実装していると考えられます。電力が失われた場合、ドライブはキャパシタに蓄えられたエネルギーやディスクプラッタの角運動量を利用して、進行中の操作を完了させるために電力を供給します。とはいえ、書き込みシステムの呼び出しとオンボードのディスクドライブの電子機器の間には多くの層があるため、Unix と w32 VFS の実装では安全なアプローチをとり、セクタ書き込みはアトミックではないと仮定しています。一方、ファイルシステムをより制御できるデバイスメーカーは、ハードウェアが本当にアトミック書き込みを行うのであれば、xDeviceCharacteristics のアトミック書き込みプロパティを有効にすることを検討した方が良いかもしれません。</target>
        </trans-unit>
        <trans-unit id="586e6ff48cacbcb2ddee486b19c44489728dbf7f" translate="yes" xml:space="preserve">
          <source>We call custom modifications to the SQLite source code that are held for the use of a single application a &quot;private branch&quot;. When a private branch becomes necessary, the application developer must take on the task of keeping the private branch in synchronization with the public SQLite sources. This is tedious. It can also be tricky, since while the SQLite file format and published interfaces are very stable, the internal implementation of SQLite changes quite rapidly. Hundreds or thousands of lines of code might change for any given SQLite point release.</source>
          <target state="translated">私たちは、単一のアプリケーションの使用のために保持されている SQLite ソースコードへのカスタム変更を「プライベートブランチ」と呼んでいます。プライベートブランチが必要になった場合、アプリケーション開発者はプライベートブランチをパブリックSQLiteソースと同期させておく作業を引き受けなければなりません。これは面倒な作業です。また、SQLiteのファイル形式と公開されているインターフェイスは非常に安定していますが、SQLiteの内部実装は非常に急速に変化するため、これはトリッキーなことです。なぜなら、SQLite ファイル形式と公開インターフェースは非常に安定していますが、SQLite の内部実装は非常に急速に変更されているからです。</target>
        </trans-unit>
        <trans-unit id="2cfeb2a347fa38b180ceb6f0fe6a37a3de052a3a" translate="yes" xml:space="preserve">
          <source>We call this kind of index usage a &quot;skip-scan&quot; because the database engine is basically doing a full scan of the index but it optimizes the scan (making it less than &quot;full&quot;) by occasionally skipping ahead to the next candidate value.</source>
          <target state="translated">データベースエンジンは基本的にインデックスをフルスキャンしていますが、次の候補値にスキップすることでスキャンを最適化しています(「フル」よりも「フル」ではない状態にしています)。</target>
        </trans-unit>
        <trans-unit id="d8c54ecc5dbd9d71e35248692355648775c7c06a" translate="yes" xml:space="preserve">
          <source>We can see the VDBE program that SQLite uses to implement this INSERT using the &lt;b&gt;sqlite&lt;/b&gt; command-line utility. First start up &lt;b&gt;sqlite&lt;/b&gt; on a new, empty database, then create the table. Next change the output format of &lt;b&gt;sqlite&lt;/b&gt; to a form that is designed to work with VDBE program dumps by entering the &quot;.explain&quot; command. Finally, enter the [INSERT] statement shown above, but precede the [INSERT] with the special keyword [EXPLAIN]. The [EXPLAIN] keyword will cause &lt;b&gt;sqlite&lt;/b&gt; to print the VDBE program rather than execute it. We have:</source>
          <target state="translated">SQLiteが&lt;b&gt;sqlite&lt;/b&gt;コマンドラインユーティリティを使用してこのINSERTを実装するために使用するVDBEプログラムを確認できます。最初に新しい空のデータベースで&lt;b&gt;sqlite&lt;/b&gt;を起動し、次にテーブルを作成します。次に、「。explain」コマンドを入力して、&lt;b&gt;sqlite&lt;/b&gt;の出力形式をVDBEプログラムダンプで機能するように設計された形式に変更します。最後に、上記の[INSERT]ステートメントを入力しますが、[INSERT]の前に特別なキーワード[EXPLAIN]を付けます。 [EXPLAIN]キーワードを指定すると、&lt;b&gt;sqlite&lt;/b&gt;はVDBEプログラムを実行するのではなく出力します。我々は持っています：</target>
        </trans-unit>
        <trans-unit id="ec7be355019068bf92f7d741482fdf6ee1c56c3e" translate="yes" xml:space="preserve">
          <source>We can see the process in action in the following query:</source>
          <target state="translated">以下のクエリでプロセスを見ることができます。</target>
        </trans-unit>
        <trans-unit id="a73853b7ca854f99ebc56a8da7248062e4f92563" translate="yes" xml:space="preserve">
          <source>We deduce the following rules of thumb from the matrix above:</source>
          <target state="translated">上記の行列から以下の経験則を推理します。</target>
        </trans-unit>
        <trans-unit id="84f5304369a052a144aa55c526df651c94e44de3" translate="yes" xml:space="preserve">
          <source>We emphasis that most applications are well-served by the built-in default implementations of the SQLite interface subsystems. Developers are encouraged to use the default built-in implementations whenever possible and to build SQLite without any special compile-time options or parameters. However, some highly specialized applications may benefit from substituting or modifying one or more of these built-in SQLite interface subsystems. Or, if SQLite is used on an operating system other than Unix (Linux or Mac OS X), Windows (Win32 or WinCE), or OS/2 then none of the interface subsystems that come built into SQLite will work and the application will need to provide alternative implementations suitable for the target platform.</source>
          <target state="translated">私たちは、ほとんどのアプリケーションが SQLite インターフェースサブシステムの組み込みのデフォルト実装によって十分に機能することを強調しています。開発者は可能な限りデフォルトのビルトイン実装を使用し、特別なコンパイル時オプションやパラメータを使用せずにSQLiteを構築することをお勧めします。しかし、高度に専門化されたアプリケーションの中には、これらのビルトイン SQLite インターフェイスサブシステムの 1 つ以上を置き換えたり、変更したりすることで利益を得ることができるものもあります。あるいは、SQLite が Unix (Linux または Mac OS X)、Windows (Win32 または WinCE)、または OS/2 以外のオペレーティングシステムで使用されている場合、SQLite に組み込まれているインターフェイスサブシステムはどれも動作せず、アプリケーションはターゲットプラットフォームに適した代替の実装を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="6885829b70a7aa6d03abf4dbc376f359d84e8896" translate="yes" xml:space="preserve">
          <source>We emphasize again that these steps are not intended to be the only acceptable method for maintaining private branch. This approach is one of many. Use this document as a baseline for preparing project-specific procedures. Do not be afraid to experiment.</source>
          <target state="translated">これらのステップは、プライベートブランチを維持するための唯一の許容可能な方法であることを意図したものではないことを再度強調します。このアプローチは、多くの方法のうちの一つです。プロジェクト固有の手順を準備するためのベースラインとして、この文書を使用してください。実験することを恐れないでください。</target>
        </trans-unit>
        <trans-unit id="55e740e8153135385200d1c2a44c0a166232d431" translate="yes" xml:space="preserve">
          <source>We have received reports of implementations of both Windows network filesystems and NFS in which locking was subtly broken. We can not verify these reports, but as locking is difficult to get right on a network filesystem we have no reason to doubt them. You are advised to avoid using SQLite on a network filesystem in the first place, since performance will be slow. But if you must use a network filesystem to store SQLite database files, consider using a secondary locking mechanism to prevent simultaneous writes to the same database even if the native filesystem locking mechanism malfunctions.</source>
          <target state="translated">Windows ネットワークファイルシステムと NFS の両方でロックが微妙に壊れているという報告を受けています。これらの報告を検証することはできませんが、ネットワークファイルシステム上でロックを正しくかけるのは難しいので、それを疑う理由はありません。パフォーマンスが低下するので、ネットワークファイルシステム上での SQLite の使用は避けることをお勧めします。しかし、SQLiteデータベースファイルを保存するためにネットワークファイルシステムを使用しなければならない場合、ネイティブファイルシステムのロック機構が誤動作した場合でも、同じデータベースへの同時書き込みを防ぐために、セカンダリロック機構を使用することを検討してください。</target>
        </trans-unit>
        <trans-unit id="e3e45a07ed13dbd9549a67862a5bea3d84d72898" translate="yes" xml:space="preserve">
          <source>We have seen multiple cases where a file descriptor was open on a file, then that file descriptor was closed and reopened on an SQLite database. Later, some other thread continued to write into the old file descriptor, not realizing that the original file had been closed already. But because the file descriptor had been reopened by SQLite, the information that was intended to go into the original file ended up overwriting parts of the SQLite database, leading to corruption of the database.</source>
          <target state="translated">あるファイル上でファイルディスクリプタが開かれた後、そのファイルディスクリプタが閉じられ、SQLiteデータベース上で再び開かれるというケースを複数見てきました。その後、別のスレッドが、元のファイルがすでに閉じられていたことに気づかずに、古いファイル記述子に書き込みを続けていました。しかし、ファイルディスクリプタがSQLiteによって再オープンされていたため、元のファイルに入るはずだった情報がSQLiteデータベースの一部を上書きしてしまい、データベースの破損につながってしまいました。</target>
        </trans-unit>
        <trans-unit id="776084395b585bc0c28bd248aca15b6e574ec177" translate="yes" xml:space="preserve">
          <source>We here restate and amplify the previous sentence for emphasis: All changes within a single transaction in SQLite either occur completely or not at all, even if the act of writing the change out to the disk is interrupted by</source>
          <target state="translated">ここでは、強調のために前の文を再掲し、増幅します。SQLite の単一トランザクション内のすべての変更は、たとえ変更をディスクに書き出すという行為が</target>
        </trans-unit>
        <trans-unit id="285d3238c6a1bf77e9e62067e7f260bf0b08d8c7" translate="yes" xml:space="preserve">
          <source>We know of no way to use the standard library printf() C interface to implement the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt; feature of SQLite. The built-in printf() implementation can be easily adapted to that task, however.</source>
          <target state="translated">SQLiteの&lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf（）SQL関数機能&lt;/a&gt;を実装するために、標準ライブラリprintf（）Cインターフェイスを使用する方法はありません。ただし、組み込みのprintf（）実装は、そのタスクに簡単に適合させることができます。</target>
        </trans-unit>
        <trans-unit id="e3b0138457bb49851f251d195b698d479cac5033" translate="yes" xml:space="preserve">
          <source>We make a distinction between a &quot;file format&quot; and an &quot;application format&quot;. A file format is used to store a single object. So, for example, a GIF or JPEG file stores a single image, and an XHTML file stores text, so those are &quot;file formats&quot; and not &quot;application formats&quot;. An EPUB file, in contrast, stores both text and images (as contained XHTML and GIF/JPEG files) and so it is considered an &quot;application format&quot;. This article is about &quot;application formats&quot;.</source>
          <target state="translated">ここでは、「ファイル形式」と「アプリケーション形式」を区別しています。ファイルフォーマットは、一つのオブジェクトを格納するためのものです。だから、例えば、GIFやJPEGファイルは単一の画像を格納し、XHTMLファイルはテキストを格納するので、それらは &quot;ファイル形式 &quot;であり、 &quot;アプリケーションフォーマット &quot;ではありません。これに対して、EPUBファイルは、テキストと画像の両方を格納します(XHTMLファイルやGIF/JPEGファイルに含まれているように)ので、それは「アプリケーションフォーマット」と考えられています。この記事は「アプリケーションフォーマット」についての記事です。</target>
        </trans-unit>
        <trans-unit id="8909441e4d410050a1ceb2a957053ae17d1136a8" translate="yes" xml:space="preserve">
          <source>We propose to use the &lt;a href=&quot;http://www.fossil-scm.org&quot;&gt;fossil software configuration management&lt;/a&gt; system to set up two branches. One branch (the &quot;public branch&quot; or &quot;trunk&quot;) contains the published SQLite sources and the other branch is the private branch which contains the code that is customized for the project. Whenever a new public release of SQLite is made, that release is added to the public branch and then the changes are merged into the private branch.</source>
          <target state="translated">&lt;a href=&quot;http://www.fossil-scm.org&quot;&gt;化石ソフトウェア構成管理&lt;/a&gt;システムを使用して2つのブランチをセットアップすることを提案します。1つのブランチ（「パブリックブランチ」または「トランク」）には、公開されたSQLiteソースが含まれ、もう1つのブランチは、プロジェクト用にカスタマイズされたコードを含むプライベートブランチです。SQLiteの新しいパブリックリリースが作成されるたびに、そのリリースがパブリックブランチに追加され、変更がプライベートブランチにマージされます。</target>
        </trans-unit>
        <trans-unit id="cdfe5941cfa327faeee1a3aa77e06f6d937ec10c" translate="yes" xml:space="preserve">
          <source>We say that a system has the powersafe overwrite property if the following statement is true:</source>
          <target state="translated">以下の文が真であれば、システムはパワーズセーフの上書きプロパティを持っていると言うことになります。</target>
        </trans-unit>
        <trans-unit id="5b1e50114d6654d737309df661bca3d508073d97" translate="yes" xml:space="preserve">
          <source>We say that algorithm-1 is &quot;faster&quot;, but this is not strictly true. Algorithm-1 is faster in common repositories, but it is possible to construct a repository in which every check-in is on a different uniquely-named branch and all check-ins are children of the root check-in. In that case, TAGXREF_I1 would become more selective than PLINK_I1 and algorithm-2 really would be the faster choice. However such repositories are very unlikely to appear in practice and so hard-coding the loop nested order using the CROSS JOIN syntax is a reasonable solution to the problem in this case.</source>
          <target state="translated">アルゴリズム-1の方が「速い」と言いますが、厳密にはそうではありません。アルゴリズム-1は一般的なリポジトリではより高速ですが、すべてのチェックインが異なる一意に命名されたブランチ上にあり、すべてのチェックインがルートチェックインの子であるリポジトリを構築することは可能です。その場合、TAGXREF_I1はPLINK_I1よりも選択性が高くなり、アルゴリズム-2の方が本当に速い選択になるでしょう。しかし、そのようなリポジトリが実際に現れる可能性は非常に低く、CROSS JOIN構文を使用してループの入れ子順をハードコーディングすることが、この場合の問題に対する合理的な解決策となります。</target>
        </trans-unit>
        <trans-unit id="4ae339abf0ab672c65bdd6ccb60aabe5af32c503" translate="yes" xml:space="preserve">
          <source>We suspect that a common failure mode for SQLite recovery happens like this: A power failure occurs. After power is restored, a well-meaning user or system administrator begins looking around on the disk for damage. They see their database file named &quot;important.data&quot;. This file is perhaps familiar to them. But after the crash, there is also a hot journal named &quot;important.data-journal&quot;. The user then deletes the hot journal, thinking that they are helping to cleanup the system. We know of no way to prevent this other than user education.</source>
          <target state="translated">SQLite リカバリの一般的な障害モードは、次のようなことが起こるのではないかと考えています。停電が発生します。電源が復旧した後、良識あるユーザやシステム管理者が、ディスクに損傷がないか見て回ります。彼らは、&quot; important.data &quot;という名前のデータベースファイルを見ます。このファイルは、おそらく彼らにとっては見慣れたものでしょう。しかし、クラッシュの後には、&quot; important.data-journal &quot;という名前のホットジャーナルもあります。ユーザーは、システムのクリーンアップに貢献していると思って、ホットジャーナルを削除してしまいます。これを防ぐには、ユーザ教育以外に方法はありません。</target>
        </trans-unit>
        <trans-unit id="00a0dbc2ebcd051c964b8bf428dbc0b4e94c1fd5" translate="yes" xml:space="preserve">
          <source>We want to know the twenty most recent ancestors in time (out of the thousands and thousands of ancestors in the whole DAG) for checkin &quot;@BASELINE&quot;. (A query similar to this is used by the &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; VCS to show the N most recent ancestors of a check. For example: &lt;a href=&quot;http://www.sqlite.org/src/timeline?p=trunk&amp;amp;n=30&quot;&gt;http://www.sqlite.org/src/timeline?p=trunk&amp;amp;n=30&lt;/a&gt;.)</source>
          <target state="translated">チェックイン &quot;@BASELINE&quot;について、最新の20の祖先（DAG全体で数千および数千の祖先のうち）を知りたい。（&lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; VCS はこれに似たクエリを使用して、チェックの最新のN個の祖先を表示し&lt;a href=&quot;http://www.sqlite.org/src/timeline?p=trunk&amp;amp;n=30&quot;&gt;ます&lt;/a&gt;。例：http : //www.sqlite.org/src/timeline? p= trunk&amp;amp;n =30）</target>
        </trans-unit>
        <trans-unit id="351c0b2917fd27c07d1575c325d6c434bf485fe8" translate="yes" xml:space="preserve">
          <source>Website Keyword Index</source>
          <target state="translated">ウェブサイトキーワードインデックス</target>
        </trans-unit>
        <trans-unit id="856955a1acaac17d20fdfd7478c48b194daa4307" translate="yes" xml:space="preserve">
          <source>Well-commented source code with &lt;a href=&quot;testing#coverage&quot;&gt;100% branch test coverage&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;testing#coverage&quot;&gt;100％ブランチテストカバレッジを&lt;/a&gt;備えたコメント付きのソースコード。</target>
        </trans-unit>
        <trans-unit id="0fd93ad7c9151c213e1c81e636ad41e187dfdf3a" translate="yes" xml:space="preserve">
          <source>What If OpenDocument Used SQLite?</source>
          <target state="translated">OpenDocument が SQLite を使用していたら?</target>
        </trans-unit>
        <trans-unit id="d1c91decdb314d1f98700dd1bdf20618d03adb15" translate="yes" xml:space="preserve">
          <source>What Is An Application File Format?</source>
          <target state="translated">アプリケーションファイル形式とは何ですか?</target>
        </trans-unit>
        <trans-unit id="8eafc9293497bf8d5a3b149b033e2c04c50289e4" translate="yes" xml:space="preserve">
          <source>What datatypes does SQLite support?</source>
          <target state="translated">SQLite はどのようなデータ型をサポートしていますか?</target>
        </trans-unit>
        <trans-unit id="7ca20dfb510b956d12b7de007ce4f96db962811f" translate="yes" xml:space="preserve">
          <source>What harm could come of that, you ask? The SQLite developers (including this author) wondered the same thing. But then security researchers pointed out that knowledge of pointers can help attackers to circumvent address-space randomization defenses. This is called a &quot;pointer leak&quot;. A pointer leak is not itself a vulnerability, but it can aid an attacker in effectively exploiting other vulnerabilities.</source>
          <target state="translated">それが何の害になるのか、とお聞きになります。SQLite の開発者 (この筆者を含む)も同じことを考えていました。しかし、その後、セキュリティ研究者がポインタを知ることで、攻撃者がアドレス空間ランダム化の防御を回避するのに役立つことを指摘しました。これを「ポインタリーク」と呼ぶ。ポインタリークはそれ自体が脆弱性ではないが、他の脆弱性を効果的に悪用する攻撃者を助けることができる。</target>
        </trans-unit>
        <trans-unit id="09ddbcfffc504cb584adaf832caf679c81ed102d" translate="yes" xml:space="preserve">
          <source>What is an SQLITE_CORRUPT error? What does it mean for the database to be &quot;malformed&quot;? Why am I getting this error?</source>
          <target state="translated">SQLITE_CORRUPTエラーとは何ですか?データベースが「不正な形をしている」とはどういう意味ですか?なぜこのエラーが発生するのでしょうか?</target>
        </trans-unit>
        <trans-unit id="e5264a2f32d0c974ba717f0941d074614666d5ea" translate="yes" xml:space="preserve">
          <source>What is an SQLITE_SCHEMA error, and why am I getting one?</source>
          <target state="translated">SQLITE_SCHEMAエラーとは何ですか?</target>
        </trans-unit>
        <trans-unit id="cb018b89b59e298a68db86ff80fc9eea140ccdd3" translate="yes" xml:space="preserve">
          <source>What is the Export Control Classification Number (ECCN) for SQLite?</source>
          <target state="translated">SQLite の輸出管理分類番号(ECCN)とは何ですか?</target>
        </trans-unit>
        <trans-unit id="61fca1595cf614e3a194bfd194191403183b57e8" translate="yes" xml:space="preserve">
          <source>What is the maximum size of a VARCHAR in SQLite?</source>
          <target state="translated">SQLiteでのVARCHARの最大サイズは?</target>
        </trans-unit>
        <trans-unit id="e213b22ce22925686c52aad4a90dd069f0962434" translate="yes" xml:space="preserve">
          <source>What is the total size of all files in the archive whose names end in &quot;.h&quot; or &quot;.cpp&quot;?</source>
          <target state="translated">名前の末尾が&quot;.h &quot;または&quot;.cpp &quot;で終わるアーカイブ内のすべてのファイルの合計サイズは何ですか?</target>
        </trans-unit>
        <trans-unit id="3888afad2b88cfc56a74bc460d038e108bfb5e98" translate="yes" xml:space="preserve">
          <source>What others say about Fossil and Git</source>
          <target state="translated">フォッシルとGitについて他の人が言うこと</target>
        </trans-unit>
        <trans-unit id="f9f3ab382e9485e7278404c856bf161ccd6b2df4" translate="yes" xml:space="preserve">
          <source>What percentage of the files are compressed by less than 25%?</source>
          <target state="translated">25%以下で圧縮されているのは何%ですか?</target>
        </trans-unit>
        <trans-unit id="b5461625f1011b3e4b6508b082fdfa963ef833c0" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; is used to prepare a statement, the statement might be re-prepared during &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; due to a schema change. Hence, the application should ensure that the correct authorizer callback remains in place during the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;を使用してステートメントを準備する場合、スキーマの変更により、&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;中にステートメントが再準備される可能性があります。したがって、アプリケーションは、&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）の&lt;/a&gt;間、正しいオーソライザーコールバックが適切な場所に留まるようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="78fe376fe612030dba8e993e1e6346105acb51d4" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;PRAGMA locking_mode=EXCLUSIVE&lt;/a&gt; (exclusive locking mode) is set, only a single client is allowed to have the database open at one time. Since only a single client can use the database, the shm file is omitted. The single client uses a buffer in heap memory as a substitute for the memory-mapped shm file.</source>
          <target state="translated">場合&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;プラグマlocking_mode = EXCLUSIVE&lt;/a&gt;（排他的ロックモード）が設定されている、単一のクライアントが一度に開いているデータベースを持つことが許されます。単一のクライアントのみがデータベースを使用できるため、shmファイルは省略されます。単一のクライアントは、メモリマップされたshmファイルの代わりに、ヒープメモリ内のバッファを使用します。</target>
        </trans-unit>
        <trans-unit id="9abb811ba43f82c87eea517150f407f49b9906ac" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; is used to prepare a statement, the statement might be re-prepared during &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; due to a schema change. Hence, the application should ensure that the correct authorizer callback remains in place during the &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;を使用してステートメントを準備する場合、スキーマの変更により、&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;中にステートメントが再準備される可能性があります。したがって、アプリケーションは、&lt;a href=&quot;step&quot;&gt;sqlite3_step（）の&lt;/a&gt;間、正しいオーソライザーコールバックが適切な場所に留まるようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="c3c4a10f39f154fb9afe1cc905a05f1b736c3877" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; are used, the &quot;cache&quot; query parameter can be used to specify whether or not the database will use shared cache. Use &quot;cache=shared&quot; to enable shared cache and &quot;cache=private&quot; to disable shared cache. The ability to use URI query parameters to specify the cache sharing behavior of a database connection allows cache sharing to be controlled in &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statements. For example:</source>
          <target state="translated">とき&lt;a href=&quot;uri&quot;&gt;URIのファイル名が&lt;/a&gt;使用されている、「キャッシュ」クエリパラメータは、データベースが共有キャッシュを使用するかどうかを指定するために使用することができます。 「cache = shared」を使用して共有キャッシュを有効にし、「cache = private」を使用して共有キャッシュを無効にします。 URIクエリパラメータを使用してデータベース接続のキャッシュ共有動作を指定する機能により、キャッシュ共有を&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;ステートメントで制御できます。例えば：</target>
        </trans-unit>
        <trans-unit id="b0e9fc2254d872ac23aeae318057b6aa62d769dc" translate="yes" xml:space="preserve">
          <source>When &lt;b&gt;sqlite_step&lt;/b&gt; returns SQLITE_DONE or SQLITE_ERROR, the *pN and *pazColName values are set to the number of columns in the result set and to the names of the columns, just as they are for an SQLITE_ROW return. This allows the calling code to find the number of result columns and the column names and datatypes even if the result set is empty. The *pazValue parameter is always set to NULL when the return codes is SQLITE_DONE or SQLITE_ERROR. If the SQL being executed is a statement that does not return a result (such as an INSERT or an UPDATE) then *pN will be set to zero and *pazColName will be set to NULL.</source>
          <target state="translated">&lt;b&gt;sqlite_step&lt;/b&gt;がSQLITE_DONEまたは&lt;b&gt;SQLITE_ERRORを&lt;/b&gt;返す場合、* pNおよび* pazColNameの値は、&lt;b&gt;SQLITE_ROW&lt;/b&gt;が返す場合と&lt;b&gt;同様&lt;/b&gt;に、結果セットの列の数と列の名前に設定されます。これにより、呼び出しコードは、結果セットが空であっても、結果の列の数、列名、およびデータ型を見つけることができます。戻りコードがSQLITE_DONEまたはSQLITE_ERRORの場合、* pazValueパラメータは常にNULLに設定されます。実行中のSQLが結果を返さないステートメント（INSERTまたはUPDATEなど）の場合、* pNはゼロに設定され、* pazColNameはNULLに設定されます。</target>
        </trans-unit>
        <trans-unit id="a738765e6d76b084ca79459e28b3c9bfca412130" translate="yes" xml:space="preserve">
          <source>When I want to see what has been happening on SQLite (or any of about a dozen other projects that I work on) I visit the &lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;timeline&lt;/a&gt; and in a single screen I can see a quick summary of all the latest changes, on all branches. In a few clicks, I can drill down to see as much detail as I want. I can even do this from a phone.</source>
          <target state="translated">SQLite（または私が取り組んでいる他の約12のプロジェクトのいずれか）で何が起こっているのかを確認したいときは、&lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;タイムライン&lt;/a&gt;にアクセスし、1つの画面で、すべてのブランチで最新のすべての変更の概要をすばやく確認できます。数回クリックするだけで、ドリルダウンして必要な詳細を確認できます。電話からでもできます。</target>
        </trans-unit>
        <trans-unit id="3038431e6823ccdef12d1f539d0c61f30867d530" translate="yes" xml:space="preserve">
          <source>When RAISE(IGNORE) is called, the remainder of the current trigger program, the statement that caused the trigger program to execute and any subsequent trigger programs that would have been executed are abandoned. No database changes are rolled back. If the statement that caused the trigger program to execute is itself part of a trigger program, then that trigger program resumes execution at the beginning of the next step.</source>
          <target state="translated">RAISE(IGNORE)が呼び出されると、現在のトリガプログラムの残りの部分、トリガプログラムを実行する原因となったステートメント、および実行されていたであろうそれ以降のトリガプログラムは放棄されます。データベースの変更はロールバックされません。トリガプログラムの実行の原因となったステートメント自体がトリガプログラムの一部である場合、そのトリガプログラムは次のステップの開始時に実行を再開します。</target>
        </trans-unit>
        <trans-unit id="3b714e2ab0d85ccd85c4bb15bba20b0ece19aa26" translate="yes" xml:space="preserve">
          <source>When SQLITE_ENABLE_SORTER_REFERENCES is enabled, the records passed to the sorter often contain only a &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; value. Such records are much smaller. This means the sorter has much less &quot;payload&quot; to deal with and can run faster. After sorting has occurred, the ROWID is used to look up the output column values in the original table. That requires another search into the table, and could potentially result in a slowdown. Or, it might be a performance win, depending on how large the values are.</source>
          <target state="translated">SQLITE_ENABLE_SORTER_REFERENCESが有効になっている場合、ソーターに渡されるレコードには多くの場合、&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;値のみが含まれます。そのような記録はずっと小さいです。つまり、ソーターは処理する「ペイロード」がはるかに少なく、より高速に実行できます。ソートが行われた後、ROWIDを使用して、元のテーブルの出力列の値が検索されます。そのため、テーブルをもう一度検索する必要があり、速度が低下する可能性があります。または、値の大きさによっては、パフォーマンスが向上する場合があります。</target>
        </trans-unit>
        <trans-unit id="22e2481654b7e499f20f0d8a14ccb29b23b47522" translate="yes" xml:space="preserve">
          <source>When SQLite calls the xTruncate() method, the cache must discard all existing cache entries with page numbers (keys) greater than or equal to the value of the iLimit parameter passed to xTruncate(). If any of these pages are pinned, they are implicitly unpinned, meaning that they can be safely discarded.</source>
          <target state="translated">SQLite が xTruncate()メソッドを呼び出すと、キャッシュは xTruncate()に渡された iLimit パラメータの値以上のページ番号 (キー)を持つ既存のキャッシュエントリをすべて破棄しなければなりません。これらのページがピン留めされている場合は、暗黙のうちにピン留めされていないことになり、安全に破棄できることを意味します。</target>
        </trans-unit>
        <trans-unit id="35ff55b55b3144279fa7594a0e19885043618a48" translate="yes" xml:space="preserve">
          <source>When SQLite compares two strings, it uses a collating sequence or collating function (two words for the same thing) to determine which string is greater or if the two strings are equal. SQLite has three built-in collating functions: BINARY, NOCASE, and RTRIM.</source>
          <target state="translated">SQLite は 2 つの文字列を比較するとき、照合順序または照合関数 (同じものを表す 2 つの単語)を使用して、どちらの文字列が大きいか、または 2 つの文字列が等しいかを判断します。SQLiteには3つの照合関数が組み込まれています。BINARY、NOCASE、RTRIMです。</target>
        </trans-unit>
        <trans-unit id="df3602b4706fda192f1a7fee5a1fd5a14d6046e0" translate="yes" xml:space="preserve">
          <source>When SQLite has been compiled with SQLITE_THREADSAFE=1 or SQLITE_THREADSAFE=2 then the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; can be altered at run-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface together with one of these verbs:</source>
          <target state="translated">SQLiteがSQLITE_THREADSAFE = 1またはSQLITE_THREADSAFE = 2でコンパイルされている場合、次のいずれかの動詞と一緒に&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;インターフェースを使用して、実行時に&lt;a href=&quot;threadsafe&quot;&gt;スレッドモード&lt;/a&gt;を変更できます。</target>
        </trans-unit>
        <trans-unit id="447f302ea851392a6eb166989220e6263326e6b8" translate="yes" xml:space="preserve">
          <source>When SQLite invokes the xSync() method of an &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object it uses a combination of these integer values as the second argument.</source>
          <target state="translated">SQLiteが&lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;オブジェクトのxSync（）メソッドを呼び出すとき、これらの整数値の組み合わせを2番目の引数として使用します。</target>
        </trans-unit>
        <trans-unit id="68d87b5a5c9475d95e19a08651c92859f1a25fae" translate="yes" xml:space="preserve">
          <source>When SQLite invokes the xSync() method of an &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object it uses a combination of these integer values as the second argument.</source>
          <target state="translated">SQLiteが&lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;オブジェクトのxSync（）メソッドを呼び出すとき、これらの整数値の組み合わせを2番目の引数として使用します。</target>
        </trans-unit>
        <trans-unit id="d35292160ae7a274b67325cfcd829f7632f2415b" translate="yes" xml:space="preserve">
          <source>When SQLite is compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, extra &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; commands are available that are useful for debugging and for exploring the operation of the VDBE. For example the &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;vdbe_trace&lt;/a&gt; pragma can be enabled to cause a disassembly of each VDBE opcode to be printed on standard output as the opcode is executed. These debugging pragmas include:</source>
          <target state="translated">SQLiteを&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;コンパイル時オプションでコンパイルすると、デバッグやVDBEの操作の調査に役立つ追加の&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;コマンドを使用できます。たとえば、&lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;vdbe_trace&lt;/a&gt;プラグマを有効にして、オペコードの実行時に各VDBEオペコードの逆アセンブリを標準出力に出力できます。これらのデバッグプラグマは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="c9b995e894f1bbf11af15b50811aafd3b796ef85" translate="yes" xml:space="preserve">
          <source>When SQLite is compiled with the &lt;a href=&quot;compile#enable_memsys5&quot;&gt;SQLITE_ENABLE_MEMSYS5&lt;/a&gt; option, an alternative memory allocator that does not use malloc() is included in the build. The SQLite developers refer to this alternative memory allocator as &quot;memsys5&quot;. Even when it is included in the build, memsys5 is disabled by default. To enable memsys5, the application must invoke the following SQLite interface at start-time:</source>
          <target state="translated">SQLiteが&lt;a href=&quot;compile#enable_memsys5&quot;&gt;SQLITE_ENABLE_MEMSYS5&lt;/a&gt;オプションを使用してコンパイルされると、malloc（）を使用しない代替メモリアロケータがビルドに含まれます。SQLite開発者は、この代替メモリアロケータを「memsys5」と呼んでいます。ビルドに含まれている場合でも、memsys5はデフォルトで無効になっています。memsys5を有効にするには、アプリケーションは起動時に次のSQLiteインターフェイスを呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="84ef8ebae9f557b2e5ae28bc7ed5746f2af208db" translate="yes" xml:space="preserve">
          <source>When SQLite is compiled with the SQLITE_MUTEX_APPDEF=1 option, it completely omits the implementation of its &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;mutex primitive functions&lt;/a&gt;. But the SQLite library still attempts to call these functions where necessary, so the application must itself implement the &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;mutex primitive functions&lt;/a&gt; and link them together with SQLite.</source>
          <target state="translated">SQLiteがSQLITE_MUTEX_APPDEF = 1オプションでコンパイルされると、その&lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;ミューテックスプリミティブ関数の&lt;/a&gt;実装が完全に省略されます。ただし、SQLiteライブラリは必要に応じてこれらの関数を呼び出そうとするため、アプリケーション自体が&lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;ミューテックスプリミティブ関数&lt;/a&gt;を実装し、SQLiteとリンクする必要があります。</target>
        </trans-unit>
        <trans-unit id="7f137b8f0298a3c2c2e18d67228fddc4346fc04c" translate="yes" xml:space="preserve">
          <source>When SQLite is ported to new operating systems (operating systems other than Unix, Windows, and OS/2 for which ports are provided together with the core) two new functions, &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt; and &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_end()&lt;/a&gt;, must be provided as part of the port.</source>
          <target state="translated">SQLiteが新しいオペレーティングシステム（Unix、Windows、OS / 2以外のオペレーティングシステムであり、コアとともにポートが提供されている）に&lt;a href=&quot;c3ref/initialize&quot;&gt;移植される&lt;/a&gt;場合、2つの新しい関数sqlite3_os_init（）と&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_end（）&lt;/a&gt;が、港。</target>
        </trans-unit>
        <trans-unit id="07b5adba013870fc7dc891a2821a51ae6a59171f" translate="yes" xml:space="preserve">
          <source>When SQLite tries to access a file that is locked by another process, the default behavior is to return SQLITE_BUSY. You can adjust this behavior from C code using the &lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt; or &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; API functions.</source>
          <target state="translated">SQLiteが別のプロセスによってロックされているファイルにアクセスしようとすると、デフォルトの動作ではSQLITE_BUSYが返されます。&lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler（）&lt;/a&gt;または&lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt; API関数を使用して、Cコードからこの動作を調整できます。</target>
        </trans-unit>
        <trans-unit id="77327b5e49ebfcc1acf07f15eb4bc6a41abc04ea" translate="yes" xml:space="preserve">
          <source>When SQLite tries to open a database and finds that it is locked, it can optionally delay for a short while and try to open the file again. This process repeats until the query times out and SQLite returns a failure. The timeout is adjustable. It is set to 0 by default so that if the database is locked, the SQL statement fails immediately. But you can use the &quot;timeout&quot; method to change the timeout value to a positive number. For example:</source>
          <target state="translated">SQLite がデータベースを開こうとしたときに、それがロックされていることを発見した場合、オプションでしばらくの間遅延させてから再度ファイルを開こうとすることができます。この処理は、クエリがタイムアウトし、SQLite が失敗を返すまで繰り返されます。タイムアウトは調整可能です。デフォルトでは0に設定されているので、データベースがロックされている場合、SQL文はすぐに失敗します。しかし、&quot;timeout &quot;メソッドを使用して、タイムアウトの値を正の数に変更することができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="a804ec7f0a4b84d1b0a408e0b54447cf6ce4d1f8" translate="yes" xml:space="preserve">
          <source>When SQLite version 2.7.0 or later opens a 2.6.3 or earlier database, it assumes all columns of all tables have type &quot;numeric&quot;. For 2.7.0 and later databases, columns have type &quot;text&quot; if their datatype string contains the substrings &quot;char&quot; or &quot;clob&quot; or &quot;blob&quot; or &quot;text&quot;. Otherwise they are of type &quot;numeric&quot;.</source>
          <target state="translated">SQLite バージョン 2.7.0 以降で 2.6.3 以前のデータベースを開いた場合、すべてのテーブルのすべての列の型が &quot;numeric&quot; であると仮定します。2.7.0以降のデータベースでは、そのデータ型文字列に部分文字列 &quot;char&quot;、&quot;clob&quot;、&quot;blob&quot;、または &quot;text &quot;が含まれている場合、列の型は &quot;text &quot;となります。それ以外の場合は &quot;numeric &quot;型となります。</target>
        </trans-unit>
        <trans-unit id="a13408a2bfc81e3d04562db93d8a2fee6642da62" translate="yes" xml:space="preserve">
          <source>When SQLite was first being developed, Java was a young and immature language. C++ was older, but was undergoing such growing pains that it was difficult to find any two C++ compilers that worked the same way. So C was definitely a better choice back when SQLite was first being developed. The situation is less stark now, but there is little to no benefit in recoding SQLite at this point.</source>
          <target state="translated">SQLiteが開発された当初、Javaは若くて未熟な言語でした。C++は古い言語でしたが、成長の痛みを感じていたので、同じように動作する2つのC++コンパイラを見つけるのは困難でした。ですから、SQLiteが開発されたばかりの頃は、Cの方が間違いなく良い選択だったのです。今では状況はそれほど深刻ではありませんが、現時点ではSQLiteを再コード化するメリットはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="dd3d6234851cf7360a0faea15fc7c5c549469738" translate="yes" xml:space="preserve">
          <source>When a</source>
          <target state="translated">になったときに</target>
        </trans-unit>
        <trans-unit id="b177e9320f32426fce848e5e150f059f226858de" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraint violation occurs, the REPLACE algorithm deletes pre-existing rows that are causing the constraint violation prior to inserting or updating the current row and the command continues executing normally. If a &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt; constraint violation occurs, the REPLACE conflict resolution replaces the NULL value with the default value for that column, or if the column has no default value, then the ABORT algorithm is used. If a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt; or &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; violation occurs, the REPLACE conflict resolution algorithm works like ABORT.</source>
          <target state="translated">場合&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;または&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEYの&lt;/a&gt;制約違反が発生し、前現在の行を挿入または更新する制約違反を引き起こしているアルゴリズム削除プレ既存の行を置き換え、コマンドが正常に実行を継続します。場合は&lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULLの&lt;/a&gt;制約違反が発生し、REPLACE紛争解決は、その列のデフォルト値にNULL値を置き換え、または列にデフォルト値がない場合、ABORTアルゴリズムが使用されています。場合は&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK制約&lt;/a&gt;または&lt;a href=&quot;foreignkeys&quot;&gt;外部キー制約&lt;/a&gt;違反が発生し、REPLACE競合解決アルゴリズムはABORTのように動作します。</target>
        </trans-unit>
        <trans-unit id="e40cfe4f4a2672a463b5e9153a546fd55dd2ffa8" translate="yes" xml:space="preserve">
          <source>When a UNIQUE constraint violation occurs, the pre-existing row that caused the constraint violation is removed prior to inserting or updating the current row. Thus the insert or update always occurs. The command continues executing normally. No error is returned.</source>
          <target state="translated">UNIQUE制約違反が発生した場合、現在の行を挿入または更新する前に、制約違反の原因となった既存の行が削除されます。したがって、挿入または更新は常に行われます。コマンドは正常に実行され続けます。エラーは返されません。</target>
        </trans-unit>
        <trans-unit id="f0f8ec6207370b712331444906a15edac7bd9982" translate="yes" xml:space="preserve">
          <source>When a WAL mode database is in active use, all three of the above files usually exist. Except, the Wal-Index file is omitted if &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; is set.</source>
          <target state="translated">WALモードのデータベースがアクティブに使用されている場合、上記の3つのファイルはすべて存在します。ただし、&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;排他ロックモード&lt;/a&gt;が設定されている場合、Wal-Indexファイルは省略されます。</target>
        </trans-unit>
        <trans-unit id="88f7d29bc8b807cc4618404ebf6e68af0b14195c" translate="yes" xml:space="preserve">
          <source>When a blocking connection's transaction is concluded, there may be more than one blocked connection that has registered for an unlock-notify callback. If two or more such blocked connections have specified the same callback function, then instead of invoking the callback function multiple times, it is invoked once with the set of void* context pointers specified by the blocked connections bundled together into an array. This gives the application an opportunity to prioritize any actions related to the set of unblocked database connections.</source>
          <target state="translated">ブロッキングされた接続のトランザクションが終了すると、 unlock-notify コールバックに登録したブロックされた接続が複数存在する可能性があります。2 つ以上のブロック接続が同じコールバック関数を指定している場合、コールバック関数を複数回呼び出すのではなく、ブロック接続によって指定された void*コンテキストポインタのセットを配列に束ねて一度だけ呼び出されます。これにより、アプリケーションは、ブロックされていないデータベース接続のセットに関連するアクションに優先順位をつけることができます。</target>
        </trans-unit>
        <trans-unit id="eda8b145f23c6a0bb85ff0a12c0706d7475482c1" translate="yes" xml:space="preserve">
          <source>When a blocking connections transaction is concluded, there may be more than one blocked connection that has registered for an unlock-notify callback. If two or more such blocked connections have specified the same callback function, then instead of invoking the callback function multiple times, it is invoked once with the set of void* context pointers specified by the blocked connections bundled together into an array. This gives the application an opportunity to prioritize any actions related to the set of unblocked database connections.</source>
          <target state="translated">ブロック接続トランザクションが成立すると、 unlock-notifyコールバックに登録したブロック接続が複数存在する可能性があります。そのような複数のブロック接続が同じコールバック関数を指定している場合、コールバック関数を複数回呼び出すのではなく、ブロック接続によって指定された void*コンテキストポインタのセットを配列に束ねた状態でコールバック関数が一度だけ呼び出されます。これにより、アプリケーションは、ブロックされていないデータベース接続のセットに関連するアクションに優先順位をつけることができます。</target>
        </trans-unit>
        <trans-unit id="b1623124138a1a453c5d32a837bf66762d013ccd" translate="yes" xml:space="preserve">
          <source>When a call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; returns SQLITE_LOCKED, it is almost always appropriate to call sqlite3_unlock_notify(). There is however, one exception. When executing a &quot;DROP TABLE&quot; or &quot;DROP INDEX&quot; statement, SQLite checks if there are any currently executing SELECT statements that belong to the same connection. If there are, SQLITE_LOCKED is returned. In this case there is no &quot;blocking connection&quot;, so invoking sqlite3_unlock_notify() results in the unlock-notify callback being invoked immediately. If the application then re-attempts the &quot;DROP TABLE&quot; or &quot;DROP INDEX&quot; query, an infinite loop might be the result.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;への呼び出しがSQLITE_LOCKEDを返す場合、ほとんど常にsqlite3_unlock_notify（）を呼び出すことが適切です。ただし、例外が1つあります。 &quot;DROP TABLE&quot;または &quot;DROP INDEX&quot;ステートメントを実行すると、SQLiteは、同じ接続に属する現在実行中のSELECTステートメントがあるかどうかをチェックします。存在する場合、SQLITE_LOCKEDが返されます。この場合、「ブロッキング接続」がないため、sqlite3_unlock_notify（）を呼び出すと、すぐにロック解除通知コールバックが呼び出されます。その後、アプリケーションが「DROP TABLE」または「DROP INDEX」クエリを再試行すると、無限ループが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="96fd9fb18740d68a037d0a53dc8f7e543ce5815d" translate="yes" xml:space="preserve">
          <source>When a call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; returns SQLITE_LOCKED, it is almost always appropriate to call sqlite3_unlock_notify(). There is however, one exception. When executing a &quot;DROP TABLE&quot; or &quot;DROP INDEX&quot; statement, SQLite checks if there are any currently executing SELECT statements that belong to the same connection. If there are, SQLITE_LOCKED is returned. In this case there is no &quot;blocking connection&quot;, so invoking sqlite3_unlock_notify() results in the unlock-notify callback being invoked immediately. If the application then re-attempts the &quot;DROP TABLE&quot; or &quot;DROP INDEX&quot; query, an infinite loop might be the result.</source>
          <target state="translated">&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;への呼び出しがSQLITE_LOCKEDを返す場合、ほとんど常にsqlite3_unlock_notify（）を呼び出すことが適切です。ただし、例外が1つあります。 &quot;DROP TABLE&quot;または &quot;DROP INDEX&quot;ステートメントを実行すると、SQLiteは、同じ接続に属する現在実行中のSELECTステートメントがあるかどうかをチェックします。存在する場合、SQLITE_LOCKEDが返されます。この場合、「ブロッキング接続」がないため、sqlite3_unlock_notify（）を呼び出すと、すぐにロック解除通知コールバックが呼び出されます。その後、アプリケーションが「DROP TABLE」または「DROP INDEX」クエリを再試行すると、無限ループが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="4b27c6df7f370b95df53fb6af6deaef3ac0ea82c" translate="yes" xml:space="preserve">
          <source>When a changeset or patchset is applied to a database, an attempt is made to insert a new row for each INSERT change, remove a row for each DELETE change and modify a row for each UPDATE change. If the target database is in the same state as the original database that the changeset was recorded on, this is a simple matter. However, if the contents of the target database is not in exactly this state, conflicts can occur when applying the changeset or patchset.</source>
          <target state="translated">チェンジセットやパッチセットがデータベースに適用されると、INSERT変更ごとに新しい行を挿入し、DELETE変更ごとに行を削除し、UPDATE変更ごとに行を修正しようとします。ターゲット データベースがチェンジセットが記録された元のデータベースと同じ状態であれば、これは簡単なことです。しかし、ターゲットデータベースの内容が正確にこの状態でない場合、チェンジセットやパッチセットを適用する際に競合が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="af13c24a93516a02da3d5819b6d5ee382b394c0c" translate="yes" xml:space="preserve">
          <source>When a checkpoint runs, if it sees a lock on WAL_READ_LOCK(N), then it must not move WAL content into the main database for more than the first read-mark[N] frames. Were it to do so, it would overwrite content that the process holding the lock was expecting to be able to read out of the main database file. A consequence of if this is that f the WAL file contains more than read-mark[N] frames (if mxFrame&amp;gt;read-mark[N] for any read-mark for which WAL_READ_LOCK(N) is held by another process), then the checkpoint cannot run to completion.</source>
          <target state="translated">チェックポイントの実行時に、WAL_READ_LOCK（N）でロックが検出された場合、最初のread-mark [N]フレームを超えてWALコンテンツをメインデータベースに移動してはなりません。そうすると、ロックを保持しているプロセスがメインデータベースファイルから読み取ることができると予期していた内容が上書きされます。これが、WALファイルにread-mark [N]フレームより多く含まれている場合の結果（別のプロセスによってWAL_READ_LOCK（N）が保持されている読み取りマークのmxFrame&amp;gt; read-mark [N]の場合）、次にチェックポイントは最後まで実行できません。</target>
        </trans-unit>
        <trans-unit id="483ce2f4112b751479cd3313b5725fa8eedbb3fc" translate="yes" xml:space="preserve">
          <source>When a configuration option is set, sqlite3_config() returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;. If the option is unknown or SQLite is unable to set the option then this routine returns a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">設定オプションが設定されると、sqlite3_config（）は&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OKを&lt;/a&gt;返します。オプションが不明であるか、SQLiteがオプションを設定できない場合、このルーチンはゼロ以外の&lt;a href=&quot;rescode&quot;&gt;エラーコードを&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="42a829c41f1de7dff832e7bd4aea25619f81edf9" translate="yes" xml:space="preserve">
          <source>When a configuration option is set, sqlite3_config() returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;. If the option is unknown or SQLite is unable to set the option then this routine returns a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">設定オプションが設定されると、sqlite3_config（）は&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OKを&lt;/a&gt;返します。オプションが不明であるか、SQLiteがオプションを設定できない場合、このルーチンはゼロ以外の&lt;a href=&quot;../rescode&quot;&gt;エラーコードを&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="5ec6b6ac63fbc35d1df0b3e9fb9cdbeeef10333e" translate="yes" xml:space="preserve">
          <source>When a connection (known as the blocked connection) fails to obtain a shared-cache lock and SQLITE_LOCKED is returned to the caller, the identity of the database connection (the blocking connection) that has locked the required resource is stored internally. After an application receives an SQLITE_LOCKED error, it may call the sqlite3_unlock_notify() method with the blocked connection handle as the first argument to register for a callback that will be invoked when the blocking connections current transaction is concluded. The callback is invoked from within the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt; or &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close&lt;/a&gt; call that concludes the blocking connection's transaction.</source>
          <target state="translated">When a connection (known as the blocked connection) fails to obtain a shared-cache lock and SQLITE_LOCKED is returned to the caller, the identity of the database connection (the blocking connection) that has locked the required resource is stored internally. After an application receives an SQLITE_LOCKED error, it may call the sqlite3_unlock_notify() method with the blocked connection handle as the first argument to register for a callback that will be invoked when the blocking connections current transaction is concluded. The callback is invoked from within the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt; or &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close&lt;/a&gt; call that concludes the blocking connection's transaction.</target>
        </trans-unit>
        <trans-unit id="8a34b978574691e0c575f3f24ebbf266179b4d2f" translate="yes" xml:space="preserve">
          <source>When a connection (known as the blocked connection) fails to obtain a shared-cache lock and SQLITE_LOCKED is returned to the caller, the identity of the database connection (the blocking connection) that has locked the required resource is stored internally. After an application receives an SQLITE_LOCKED error, it may call the sqlite3_unlock_notify() method with the blocked connection handle as the first argument to register for a callback that will be invoked when the blocking connections current transaction is concluded. The callback is invoked from within the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt; or &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close&lt;/a&gt; call that concludes the blocking connections transaction.</source>
          <target state="translated">接続（ブロックされた接続と呼ばれます）が共有キャッシュロックの取得に失敗し、SQLITE_LOCKEDが呼び出し元に返されると、必要なリソースをロックしたデータベース接続（ブロックされた接続）のIDが内部に格納されます。アプリケーションがSQLITE_LOCKEDエラーを受け取った後、ブロックされた接続ハンドルが最初の引数としてsqlite3_unlock_notify（）メソッドを呼び出し、現在のトランザクションのブロック接続が終了したときに呼び出されるコールバックを登録します。コールバックは、ブロッキング接続トランザクションを終了する&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;または&lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close&lt;/a&gt;呼び出し内から呼び出されます。</target>
        </trans-unit>
        <trans-unit id="58820b450842a3b35138dd7706fb343d060de1de" translate="yes" xml:space="preserve">
          <source>When a connection (known as the blocked connection) fails to obtain a shared-cache lock and SQLITE_LOCKED is returned to the caller, the identity of the database connection (the blocking connection) that has locked the required resource is stored internally. After an application receives an SQLITE_LOCKED error, it may call the sqlite3_unlock_notify() method with the blocked connection handle as the first argument to register for a callback that will be invoked when the blocking connections current transaction is concluded. The callback is invoked from within the &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt; or &lt;a href=&quot;close&quot;&gt;sqlite3_close&lt;/a&gt; call that concludes the blocking connection's transaction.</source>
          <target state="translated">When a connection (known as the blocked connection) fails to obtain a shared-cache lock and SQLITE_LOCKED is returned to the caller, the identity of the database connection (the blocking connection) that has locked the required resource is stored internally. After an application receives an SQLITE_LOCKED error, it may call the sqlite3_unlock_notify() method with the blocked connection handle as the first argument to register for a callback that will be invoked when the blocking connections current transaction is concluded. The callback is invoked from within the &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt; or &lt;a href=&quot;close&quot;&gt;sqlite3_close&lt;/a&gt; call that concludes the blocking connection's transaction.</target>
        </trans-unit>
        <trans-unit id="b7b71c21ec59e3320b31da28e6f5087ad7dce22a" translate="yes" xml:space="preserve">
          <source>When a connection (known as the blocked connection) fails to obtain a shared-cache lock and SQLITE_LOCKED is returned to the caller, the identity of the database connection (the blocking connection) that has locked the required resource is stored internally. After an application receives an SQLITE_LOCKED error, it may call the sqlite3_unlock_notify() method with the blocked connection handle as the first argument to register for a callback that will be invoked when the blocking connections current transaction is concluded. The callback is invoked from within the &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt; or &lt;a href=&quot;close&quot;&gt;sqlite3_close&lt;/a&gt; call that concludes the blocking connections transaction.</source>
          <target state="translated">接続（ブロックされた接続と呼ばれます）が共有キャッシュロックの取得に失敗し、SQLITE_LOCKEDが呼び出し元に返されると、必要なリソースをロックしたデータベース接続（ブロックされた接続）のIDが内部に格納されます。アプリケーションがSQLITE_LOCKEDエラーを受け取った後、ブロックされた接続ハンドルが最初の引数としてsqlite3_unlock_notify（）メソッドを呼び出し、現在のトランザクションのブロック接続が終了したときに呼び出されるコールバックを登録します。コールバックは、ブロッキング接続トランザクションを終了する&lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;または&lt;a href=&quot;close&quot;&gt;sqlite3_close&lt;/a&gt;呼び出し内から呼び出されます。</target>
        </trans-unit>
        <trans-unit id="2d95de74c44ccc79daba549c33cfe91ac9ee60b3" translate="yes" xml:space="preserve">
          <source>When a connection holds a shared lock on WAL_READ_LOCK(N), that is a promise by the connection that it will use the WAL and not the database file for any database pages that are modified by the first read-mark[N] entries in the WAL. The read-mark[0] is always zero. If a connection holds a shared lock on WAL_READ_LOCK(0), that means the connection expects to be able to ignore the WAL and read any content it wants from the main database. If N&amp;gt;0 then the connection is free to use more of the WAL file beyond read-mark[N] if it wants to, up to the first mxFrame frames. But when a connection holds a shared lock on WAL_READ_LOCK(0), that is a promise that it will never read content from the WAL and will acquire all content directly from the main database.</source>
          <target state="translated">接続がWAL_READ_LOCK（N）の共有ロックを保持している場合、それは接続によるWALを使用するという約束であり、 WAL。 read-mark [0]は常にゼロです。接続がWAL_READ_LOCK（0）の共有ロックを保持している場合、その接続はWALを無視して、メインデータベースから必要なコンテンツを読み取ることができると想定しています。 N&amp;gt; 0の場合、接続は、必要に応じて、最初のmxFrameフレームまで、read-mark [N]を超えてWALファイルを自由に使用できます。しかし、接続がWAL_READ_LOCK（0）で共有ロックを保持している場合、これはWALからコンテンツを読み取らず、すべてのコンテンツをメインデータベースから直接取得することを約束します。</target>
        </trans-unit>
        <trans-unit id="e114c32681a6d0ab6fee9545fa50582f6c054845" translate="yes" xml:space="preserve">
          <source>When a connection is holding a SHARED lock on the main database, that will prevent any other connection from acquiring the EXCLUSIVE lock, which in turn prevents the WAL-index and WAL files from being deleted out from under other users, and prevents a transition out of WAL-mode while other users are accessing the database in WAL-mode.</source>
          <target state="translated">接続がメインデータベース上でSHAREDロックを保持している場合、他の接続がEXCLUSIVEロックを取得するのを防ぐことができ、その結果、WAL-indexとWALファイルが他のユーザーの下から削除されるのを防ぎ、他のユーザーがWALモードでデータベースにアクセスしている間、WALモードからの移行を防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="12c1255cc9a16f21fccefe2ac6a059ed783c7d20" translate="yes" xml:space="preserve">
          <source>When a connection using asynchronous IO begins a database transaction, the database is locked immediately. However the lock is not released until after all relevant operations in the write-queue have been flushed to disk. This means (for example) that the database may remain locked for some time after a &quot;&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;&quot; or &quot;&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;&quot; is issued.</source>
          <target state="translated">非同期IOを使用する接続がデータベーストランザクションを開始すると、データベースはすぐにロックされます。ただし、ロックは、書き込みキュー内の関連するすべての操作がディスクにフラッシュされるまで解放されません。これは、たとえば、「&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;」または「&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;」が発行された後、データベースがしばらくロックされたままになる可能性があることを意味します。</target>
        </trans-unit>
        <trans-unit id="ddb7b3f482852f424ece2e0896d73a04a9d957e4" translate="yes" xml:space="preserve">
          <source>When a constraint violation occurs, an immediate ROLLBACK occurs, thus ending the current transaction, and the command aborts with a return code of SQLITE_CONSTRAINT. If no transaction is active (other than the implied transaction that is created on every command) then this algorithm works the same as ABORT.</source>
          <target state="translated">制約違反が発生した場合、即座にROLLBACKが発生し、現在のトランザクションが終了し、コマンドはSQLITE_CONSTRAINTのリターンコードでアボートします。トランザクションがアクティブでない場合(すべてのコマンドで作成される暗黙のトランザクション以外)、このアルゴリズムはABORTと同じように動作します。</target>
        </trans-unit>
        <trans-unit id="933e3d0ae1663c35b2ff70117a98cacf0e4923d6" translate="yes" xml:space="preserve">
          <source>When a constraint violation occurs, the command aborts with a return code SQLITE_CONSTRAINT. But any changes to the database that the command made prior to encountering the constraint violation are preserved and are not backed out. For example, if an UPDATE statement encountered a constraint violation on the 100th row that it attempts to update, then the first 99 row changes are preserved but change to rows 100 and beyond never occur.</source>
          <target state="translated">制約違反が発生すると、コマンドはリターン・コード SQLITE_CONSTRAINT でアボートします。しかし、制約違反に遭遇する前にコマンドが行ったデータベースへの変更はすべて保存され、バックアウトされません。例えば、UPDATE文が更新しようとする100行目で制約違反に遭遇した場合、最初の99行目の変更は保存されますが、100行目以降の変更は発生しません。</target>
        </trans-unit>
        <trans-unit id="6397f8d4479c4b84e08676c10c54e0afd51f843f" translate="yes" xml:space="preserve">
          <source>When a constraint violation occurs, the command backs out any prior changes it might have made and aborts with a return code of SQLITE_CONSTRAINT. But no ROLLBACK is executed so changes from prior commands within the same transaction are preserved. This is the default behavior for SQLite.</source>
          <target state="translated">制約違反が発生した場合、コマンドはそれ以前に行った変更をすべてバックアウトし、SQLITE_CONSTRAINTのリターンコードでアボートします。しかし、ROLLBACKは実行されないので、同じトランザクション内のそれ以前のコマンドからの変更は保存されます。これが SQLite のデフォルトの動作です。</target>
        </trans-unit>
        <trans-unit id="39dcfeb5298d9a69a9dfd10b897e4e703da8e46b" translate="yes" xml:space="preserve">
          <source>When a constraint violation occurs, the one row that contains the constraint violation is not inserted or changed. But the command continues executing normally. Other rows before and after the row that contained the constraint violation continue to be inserted or updated normally. No error is returned.</source>
          <target state="translated">制約違反が発生した場合、制約違反を含む1つの行は挿入されず、変更されません。しかし、コマンドは正常に実行され続けます。制約違反を含む行の前後の他の行は、正常に挿入または更新され続けます。エラーは返されません。</target>
        </trans-unit>
        <trans-unit id="d77ac0a4b71596448d90ef0386a9797d90b3dad6" translate="yes" xml:space="preserve">
          <source>When a database connection closes (via &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; or &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close_v2()&lt;/a&gt;), an attempt is made to acquire SQLITE_LOCK_EXCLUSIVE. If this attempt is successful, that means the connection that is closing is the last connection to the database. In that case, it is desirable to clean up the WAL and WAL-index files, so the closing connection runs a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; (while holding SQLITE_LOCK_EXCLUSIVE) and the deletes both the WAL and WAL-index files. The SQLITE_LOCK_EXCLUSIVE is not released until after both the WAL and WAL-index files have been deleted.</source>
          <target state="translated">（&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close（）&lt;/a&gt;または&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close_v2（）&lt;/a&gt;を介して）データベース接続が閉じると、SQLITE_LOCK_EXCLUSIVEを取得しようとします。この試行が成功した場合は、閉じている接続がデータベースへの最後の接続であることを意味します。その場合、WALとWAL-indexファイルをクリーンアップして、接続を閉じると&lt;a href=&quot;wal#ckpt&quot;&gt;チェックポイント&lt;/a&gt;が実行され（SQLITE_LOCK_EXCLUSIVEを保持している間）、WALとWAL-indexファイルの両方が削除されます。 SQLITE_LOCK_EXCLUSIVEは、WALとWAL-indexファイルの両方が削除されるまで解放されません。</target>
        </trans-unit>
        <trans-unit id="20a6ff534ce9652a9eda05b6d0935e6cf08856e6" translate="yes" xml:space="preserve">
          <source>When a directory is inserted, if the &quot;name&quot; value does not end with a '/' character, the zipfile module appends one. This is necessary for compatibility with other programs (most notably &quot;info-zip&quot;) that manipulate zip archives.</source>
          <target state="translated">ディレクトリが挿入されたとき、&quot;name&quot; の値が '/' で終わらない場合、zipfile モジュールはそれを追加する。これは、zip アーカイブを操作する他のプログラム (特に &quot;info-zip&quot; といった)との互換性を保つために必要です。</target>
        </trans-unit>
        <trans-unit id="26801f7dad030d0d12374b8b8d55040830791b46" translate="yes" xml:space="preserve">
          <source>When a file-handle open on a database file is unlocked, if the</source>
          <target state="translated">データベースファイル上でファイルハンドルが開かれている場合、そのファイルハンドルがロックされていない場合は</target>
        </trans-unit>
        <trans-unit id="70b05b0c4ad89d4e7f94cf5e4dedf4b6997bc209" translate="yes" xml:space="preserve">
          <source>When a function uses a column from a virtual table as its first argument, this method is called to see if the virtual table would like to overload the function. The first three parameters are inputs: the virtual table, the number of arguments to the function, and the name of the function. If no overloading is desired, this method returns 0. To overload the function, this method writes the new function implementation into *pxFunc and writes user data into *ppArg and returns either 1 or a number between &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; and 255.</source>
          <target state="translated">関数が仮想テーブルの列を最初の引数として使用する場合、このメソッドが呼び出され、仮想テーブルが関数をオーバーロードするかどうかが確認されます。最初の3つのパラメーターは入力です。仮想テーブル、関数への引数の数、および関数の名前です。オーバーロードが不要な場合、このメソッドは0を返します。関数をオーバーロードするには、このメソッドは新しい関数実装を* pxFuncに書き込み、ユーザーデータを* ppArgに書き込み、1または&lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt;と255の間の数値を返します。</target>
        </trans-unit>
        <trans-unit id="8365620f1c717c4826d64a41ab8d38dd2fc7b98d" translate="yes" xml:space="preserve">
          <source>When a new</source>
          <target state="translated">新しいものが出てきたとき</target>
        </trans-unit>
        <trans-unit id="699fe2196c054a2761ad370d04849c2f40137718" translate="yes" xml:space="preserve">
          <source>When a new database is created, SQLite assigns a page size to the database based on platform and filesystem. For many years, the default page size was almost always 1024 bytes, but beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;version 3.12.0&lt;/a&gt; (2016-03-29), the default page size increased to 4096. The default page size is recommended for most applications.</source>
          <target state="translated">新しいデータベースが作成されると、SQLiteはプラットフォームとファイルシステムに基づいてページサイズをデータベースに割り当てます。長年、デフォルトのページサイズはほぼ常に1024バイトでしたが、SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;バージョン3.12.0&lt;/a&gt;（2016-03-29）以降、デフォルトのページサイズは4096に増加しました。デフォルトのページサイズは、ほとんどのアプリケーションに推奨されます。</target>
        </trans-unit>
        <trans-unit id="45fd9923f092fbfb6768ecc3efe603fb1851939b" translate="yes" xml:space="preserve">
          <source>When a new database page is appended to a database file, there is no requirement to add a record to the</source>
          <target state="translated">新しいデータベースページをデータベースファイルに追加する場合、レコードを</target>
        </trans-unit>
        <trans-unit id="b08473c5ea155814010ebff8331980504b3653e4" translate="yes" xml:space="preserve">
          <source>When a new file is created, most desktop operating systems (Windows, Linux, Mac OS X) will not actually write anything to disk. The new file is created in the operating systems disk cache only. The file is not created on mass storage until sometime later, when the operating system has a spare moment. This creates the impression to users that I/O is happening much faster than is possible when doing real disk I/O. We illustrate this idea in the diagram to the right by showing that the new rollback journal appears in the operating system disk cache only and not on the disk itself.</source>
          <target state="translated">新しいファイルが作成されると、ほとんどのデスクトップOS(Windows、Linux、Mac OS X)は実際にはディスクに何も書き込みません。新しいファイルはオペレーティングシステムのディスクキャッシュにのみ作成されます。大容量ストレージにファイルが作成されるのは、後になってオペレーティングシステムに余裕ができたときです。これにより、ユーザーには、実際のディスクI/Oを行うときよりもはるかに高速にI/Oが行われているという印象を与えます。右の図では、新しいロールバックジャーナルがオペレーティングシステムのディスクキャッシュのみに表示され、ディスク自体には表示されないことを示して、この考えを説明しています。</target>
        </trans-unit>
        <trans-unit id="0a07f6d8079bf577cb3fe5588a8b9770dc9fc5d1" translate="yes" xml:space="preserve">
          <source>When a new row is inserted into an SQLite table, the ROWID can either be specified as part of the INSERT statement or it can be assigned automatically by the database engine. To specify a ROWID manually, just include it in the list of values to be inserted. For example:</source>
          <target state="translated">SQLite テーブルに新しい行が挿入されるとき、ROWID は INSERT 文の一部として指定するか、データベース エンジンが自動的に割り当てることができます。ROWID を手動で指定するには、挿入する値のリストに含めるだけです。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="0f0ce235c557e884c10fe9cff8d86b46112c91c8" translate="yes" xml:space="preserve">
          <source>When a process wants to change a database file (and it is not in &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; mode), it first records the original unchanged database content in a &lt;em&gt;rollback journal&lt;/em&gt;. The rollback journal is an ordinary disk file that is always located in the same directory or folder as the database file and has the same name as the database file with the addition of a &lt;code&gt;-journal&lt;/code&gt; suffix. The rollback journal also records the initial size of the database so that if the database file grows it can be truncated back to its original size on a rollback.</source>
          <target state="translated">プロセスがデータベースファイルを変更する必要がある場合（&lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;モードではない場合）、プロセスは最初に元の変更されていないデータベースの内容を&lt;em&gt;ロールバックジャーナルに&lt;/em&gt;記録します。ロールバックジャーナルは通常のディスクファイルで、常にデータベースファイルと同じディレクトリまたはフォルダーにあり、データベースファイルと同じ名前に &lt;code&gt;-journal&lt;/code&gt; サフィックスが追加されています。ロールバックジャーナルはデータベースの初期サイズも記録するため、データベースファイルが大きくなった場合は、ロールバック時に元のサイズに切り捨てることができます。</target>
        </trans-unit>
        <trans-unit id="4bd80d03aa6d2b960c4978ddc8751bef460c3fb0" translate="yes" xml:space="preserve">
          <source>When a process wants to read from a database file, it followed the following sequence of steps:</source>
          <target state="translated">プロセスがデータベースファイルから読み込もうとすると、以下のような一連の手順に従っていました。</target>
        </trans-unit>
        <trans-unit id="577306227dff9ce8975b3fcaaa51b9a6b5656983" translate="yes" xml:space="preserve">
          <source>When a read operation begins on a WAL-mode database, it first remembers the location of the last valid commit record in the WAL. Call this point the &quot;end mark&quot;. Because the WAL can be growing and adding new commit records while various readers connect to the database, each reader can potentially have its own end mark. But for any particular reader, the end mark is unchanged for the duration of the transaction, thus ensuring that a single read transaction only sees the database content as it existed at a single point in time.</source>
          <target state="translated">WALモードのデータベースで読み込み操作が開始されると、最初にWAL内の最後の有効なコミットレコードの位置を記憶します。この点を「エンドマーク」と呼びます。様々なリーダがデータベースに接続している間、WALは成長し、新しいコミットレコードを追加することができるので、各リーダは潜在的に独自のエンドマークを持つことができます。しかし、どの特定のリーダーに対しても、エンドマークはトランザクションの間は変更されないので、単一の読み取りトランザクションでは、データベースのコンテンツがある時点で存在していたものとしてしか見られないことを確実にします。</target>
        </trans-unit>
        <trans-unit id="6c0dd2ac1af5d6880101af98898ac515a0c331fe" translate="yes" xml:space="preserve">
          <source>When a reader needs a page of content, it first checks the WAL to see if that page appears there, and if so it pulls in the last copy of the page that occurs in the WAL prior to the reader's end mark. If no copy of the page exists in the WAL prior to the reader's end mark, then the page is read from the original database file. Readers can exist in separate processes, so to avoid forcing every reader to scan the entire WAL looking for pages (the WAL file can grow to multiple megabytes, depending on how often checkpoints are run), a data structure called the &quot;wal-index&quot; is maintained in shared memory which helps readers locate pages in the WAL quickly and with a minimum of I/O. The wal-index greatly improves the performance of readers, but the use of shared memory means that all readers must exist on the same machine. This is why the write-ahead log implementation will not work on a network filesystem.</source>
          <target state="translated">読者がコンテンツのページを必要とするときは、まず WAL をチェックしてそのページがそこに現れるかどうかを確認し、現れた場合は、読者の終了マークより前に WAL に存在するページの最後のコピーを取り込みます。リーダの終了マークより前にWALにページのコピーが存在しない場合、そのページは元のデータベースファイルから読み取られます。リーダーは別々のプロセスに存在することができるので、すべてのリーダーがページを探すためにWAL全体をスキャンしなければならないことを避けるために(チェックポイントの実行頻度によっては、WALファイルは数メガバイトに膨れ上がることがあります)、「wal-index」と呼ばれるデータ構造が共有メモリに維持されており、これによってリーダーは最小限のI/OでWAL内のページを迅速に見つけることができます。wal-indexはリーダのパフォーマンスを大幅に向上させますが、共有メモリを使用するということは、すべてのリーダが同じマシン上に存在しなければならないということを意味します。これが、ネットワークファイルシステム上では書込み型ログの実装が動作しない理由です。</target>
        </trans-unit>
        <trans-unit id="730f5bd701321fbbb693ce5b184d905999894efe" translate="yes" xml:space="preserve">
          <source>When a row is deleted from an external content FTS4 table, FTS4 needs to retrieve the column values of the row being deleted from the content table. This is so that FTS4 can update the full-text index entries for each token that occurs within the deleted row to indicate that row has been deleted. If the content table row cannot be found, or if it contains values inconsistent with the contents of the FTS index, the results can be difficult to predict. The FTS index may be left containing entries corresponding to the deleted row, which can lead to seemingly nonsensical results being returned by subsequent SELECT queries. The same applies when a row is updated, as internally an UPDATE is the same as a DELETE followed by an INSERT.</source>
          <target state="translated">外部コンテンツFTS4テーブルから行が削除された場合、FTS4は、コンテンツテーブルから削除された行の列値を取得する必要がある。これは、FTS4が、削除された行内で発生する各トークンのフルテキストインデックスエントリを更新して、その行が削除されたことを示すことができるようにするためである。コンテンツテーブルの行が見つからない場合や、FTSインデックスの内容と矛盾する値を含む場合には、結果の予測が困難になることがある。FTSインデックスには削除された行に対応するエントリが残っている可能性があり、それ以降のSELECTクエリでは一見意味不明な結果が返される可能性があります。行が更新された場合も同様で、内部的にはUPDATEはDELETEに続いてINSERTが行われるのと同じです。</target>
        </trans-unit>
        <trans-unit id="c5bdbf38f9947ad2a93dddd10975fb895dc64e45" translate="yes" xml:space="preserve">
          <source>When a schema change occurs that requires a prepared statement to be reparsed and reprepared, that event is logged with the error code SQLITE_SCHEMA. The reparse and reprepare is normally automatic (assuming that &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; has been used to prepared the statements originally, which is recommended) and so these logging events are normally the only way to know that reprepares are taking place.</source>
          <target state="translated">準備されたステートメントを再解析して再準備する必要があるスキーマ変更が発生すると、そのイベントはエラーコードSQLITE_SCHEMAでログに記録されます。再解析と再準備は通常自動的に行われ（&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;が最初にステートメントを準備するために使用されたと想定しており、これが推奨されます）、したがって、これらのロギングイベントは通常、再準備が行われていることを知る唯一の方法です。</target>
        </trans-unit>
        <trans-unit id="19333c5294fb7ef73ead50d971608427e5e277b4" translate="yes" xml:space="preserve">
          <source>When a search request occurs and pending documents are indexed for the first time, the ftsdocs table must be updated by setting the idxed column to true and also filling in several other columns with information pertinent to the search. That other information is obtained from a join. The query is this:</source>
          <target state="translated">検索要求が発生し、保留中の文書が初めてインデックス化されたときには、idxedカラムをtrueに設定し、他のいくつかのカラムに検索に関連する情報を記入して、ftsdocsテーブルを更新しなければなりません。この他の情報は結合から得られます。クエリは次のようになります。</target>
        </trans-unit>
        <trans-unit id="5a34c7922c5247a2a858115497a487644ed495d8" translate="yes" xml:space="preserve">
          <source>When a session object is disabled (see the &lt;a href=&quot;#sqlite3session_enable&quot;&gt;sqlite3session_enable()&lt;/a&gt; API), it does not accumulate records when rows are inserted, updated or deleted. This may appear to have some counter-intuitive effects if a single row is written to more than once during a session. For example, if a row is inserted while a session object is enabled, then later deleted while the same session object is disabled, no INSERT record will appear in the changeset, even though the delete took place while the session was disabled. Or, if one field of a row is updated while a session is disabled, and another field of the same row is updated while the session is enabled, the resulting changeset will contain an UPDATE change that updates both fields.</source>
          <target state="translated">セッションオブジェクトが無効になっている場合（&lt;a href=&quot;#sqlite3session_enable&quot;&gt;sqlite3session_enable（）&lt;/a&gt; APIを参照）、行が挿入、更新、または削除されても、レコードは蓄積されません。セッション中に1つの行が複数回書き込まれると、直感に反する効果があるように見える場合があります。たとえば、セッションオブジェクトが有効になっているときに行が挿入され、その後同じセッションオブジェクトが無効になっているときに削除された場合、セッションが無効になっているときに削除が行われても、INSERTレコードはチェンジセットに表示されません。または、セッションが無効になっているときに行の1つのフィールドが更新され、セッションが有効になっているときに同じ行の別のフィールドが更新される場合、結果のチェンジセットには両方のフィールドを更新するUPDATE変更が含まれます。</target>
        </trans-unit>
        <trans-unit id="4f45d6d9d609e68af4097ec8d881bf58ab9f2d1b" translate="yes" xml:space="preserve">
          <source>When a session object is disabled (see the &lt;a href=&quot;sqlite3session_enable&quot;&gt;sqlite3session_enable()&lt;/a&gt; API), it does not accumulate records when rows are inserted, updated or deleted. This may appear to have some counter-intuitive effects if a single row is written to more than once during a session. For example, if a row is inserted while a session object is enabled, then later deleted while the same session object is disabled, no INSERT record will appear in the changeset, even though the delete took place while the session was disabled. Or, if one field of a row is updated while a session is disabled, and another field of the same row is updated while the session is enabled, the resulting changeset will contain an UPDATE change that updates both fields.</source>
          <target state="translated">セッションオブジェクトが無効になっている場合（&lt;a href=&quot;sqlite3session_enable&quot;&gt;sqlite3session_enable（）&lt;/a&gt; APIを参照）、行が挿入、更新、または削除されても、レコードは蓄積されません。セッション中に1つの行が複数回書き込まれると、直感に反する効果があるように見える場合があります。たとえば、セッションオブジェクトが有効になっているときに行が挿入され、その後同じセッションオブジェクトが無効になっているときに削除された場合、セッションが無効になっているときに削除が行われても、INSERTレコードはチェンジセットに表示されません。または、セッションが無効になっているときに行の1つのフィールドが更新され、セッションが有効になっているときに同じ行の別のフィールドが更新される場合、結果のチェンジセットには両方のフィールドを更新するUPDATE変更が含まれます。</target>
        </trans-unit>
        <trans-unit id="0c5e9130632720140f5680108f22eb0b1e949a18" translate="yes" xml:space="preserve">
          <source>When a string containing SQL statements is to be evaluated it is first sent to the tokenizer. The tokenizer breaks the SQL text into tokens and hands those tokens one by one to the parser. The tokenizer is hand-coded in the file</source>
          <target state="translated">SQL 文を含む文字列が評価される場合、最初にトークナイザーに送られます。トークナイザーは SQL テキストをトークンに分割し、それらのトークンを一つずつパーサーに渡します。トークナイザーは、ファイル</target>
        </trans-unit>
        <trans-unit id="784cd84ee25201af9adae4be302f69e70ce7fa77" translate="yes" xml:space="preserve">
          <source>When a subquery is implemented as a co-routine, byte-code is generated to implement the subquery as if it were a standalone query, except instead of returning rows of results back to the application, the co-routine yields control back to the caller after each row is computed. The caller can then use that one computed row as part of its computation, then invoke the co-routine again when it is ready for the next row.</source>
          <target state="translated">副問い合わせがコ・ルーチンとして実装されている場合、副問い合わせをスタンドアロンの問い合わせのように実装するためのバイトコードが生成されますが、結果の行をアプリケーションに返す代わりに、各行が計算された後にコ・ルーチンが呼び出し元に制御を返します。呼び出し元は計算された1つの行を計算の一部として使用し、次の行の準備ができたときに再びサブルーチンを呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="de44a27c9eba79e888eaebdda88d807698edb9ba" translate="yes" xml:space="preserve">
          <source>When a subquery occurs in the FROM clause of a SELECT, the simplest behavior is to evaluate the subquery into a transient table, then run the outer SELECT against the transient table. But such a plan can be suboptimal since the transient table will not have any indices and the outer query (which is likely a join) will be forced to do a full table scan on the transient table.</source>
          <target state="translated">SELECTのFROM句で副問い合わせが発生した場合、最も単純な動作は、副問い合わせを非定常テーブルに評価し、非定常テーブルに対して外部SELECTを実行することです。しかし、このような計画は最適ではありません。 なぜなら、過渡テーブルにはインデックスがなく、外部クエリ(これは結合である可能性が高い)は過渡テーブルに対して完全なテーブルスキャンを行わざるを得ないからです。</target>
        </trans-unit>
        <trans-unit id="e127ffb4e1dc5538bc1d8c98212bc64075d04dc4" translate="yes" xml:space="preserve">
          <source>When a users query on the FTS table requires a column value other than docid, FTS attempts to read the requested value from the corresponding column of the row in the content table with a rowid value equal to the current FTS docid. Only the subset of content-table columns duplicated in the FTS/34 table declaration can be queried for - to retrieve values from any other columns the content table must be queried directly. Or, if such a row cannot be found in the content table, a NULL value is used instead. For example:</source>
          <target state="translated">FTSテーブルに対するユーザからの問い合わせでdocid以外の列の値が要求された場合,FTSは,要求された値を,現在のFTSのdocidと等しいrowid値を持つコンテンツテーブル内の行の対応する列から読み出そうとします。FTS/34テーブル宣言で重複しているコンテンツテーブル列のサブセットだけを問い合わせることができます-他の列から値を取得するには、コンテンツテーブルを直接問い合わせる必要があります。あるいは、そのような行がコンテンツテーブルの中に見当たらない場合は、代わりに NULL 値が用いられます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="923cfb28292cf33d9bcc64415e1180bd974cc8fa" translate="yes" xml:space="preserve">
          <source>When a writer is ready to commit its changes, it executes the following steps:</source>
          <target state="translated">ライターが変更をコミットする準備ができたら、以下の手順を実行します。</target>
        </trans-unit>
        <trans-unit id="90c74b5a55e525d529484d187152a575e9bdd449" translate="yes" xml:space="preserve">
          <source>When a writer wants to &lt;a href=&quot;fileformat2#walreset&quot;&gt;reset the WAL&lt;/a&gt;, it must ensure that there are no locks on WAL_READ_LOCK(N) for N&amp;gt;0 because such locks indicate that some other connection is still using the current WAL file and a &lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL reset&lt;/a&gt; would delete content out from those other connections. It is ok for a &lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL reset&lt;/a&gt; to occur if other connections are holding WAL_READ_LOCK(0) because by holding WAL_READ_LOCK(0), those other connections are promising not to use any content from the WAL.</source>
          <target state="translated">ライターが&lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL&lt;/a&gt;をリセットする場合は、N&amp;gt; 0のWAL_READ_LOCK（N）にロックがないことを確認する必要があります。そのようなロックは、他の接続がまだ現在のWALファイルを使用しており、&lt;a href=&quot;fileformat2#walreset&quot;&gt;WALリセット&lt;/a&gt;によりコンテンツが削除されるためです。それらの他の接続。他の接続がWAL_READ_LOCK（0）を保持している場合、他の接続がWALのコンテンツを使用しないことを約束しているため、&lt;a href=&quot;fileformat2#walreset&quot;&gt;WALリセット&lt;/a&gt;が発生しても問題ありません。</target>
        </trans-unit>
        <trans-unit id="7d5748b3589eba141bc319d180f2ba5724a213ca" translate="yes" xml:space="preserve">
          <source>When all of the recommended compile-time options above are used, the SQLite library will be approximately 3% smaller and use about 5% fewer CPU cycles. So these options do not make a huge difference. But in some design situations, every little bit helps.</source>
          <target state="translated">上記の推奨されるコンパイル時オプションをすべて使用した場合、SQLite ライブラリは約 3% 小さくなり、使用する CPU サイクルは約 5% 少なくなります。そのため、これらのオプションを使用しても大きな違いはありません。しかし、設計の状況によっては、少しずつでも改善されていくことがあります。</target>
        </trans-unit>
        <trans-unit id="07429870ba57300bd363c85117e03fbff3fb9b62" translate="yes" xml:space="preserve">
          <source>When all processing is complete, &lt;b&gt;sqlite_step&lt;/b&gt; will return either SQLITE_DONE or SQLITE_ERROR. SQLITE_DONE indicates that the statement completed successfully and SQLITE_ERROR indicates that there was a run-time error. (The details of the error are obtained from &lt;b&gt;sqlite_finalize&lt;/b&gt;.) It is a misuse of the library to attempt to call &lt;b&gt;sqlite_step&lt;/b&gt; again after it has returned SQLITE_DONE or SQLITE_ERROR.</source>
          <target state="translated">すべての処理が完了すると、&lt;b&gt;sqlite_step&lt;/b&gt;はSQLITE_DONEまたはSQLITE_ERRORを返します。 SQLITE_DONEはステートメントが正常に完了したことを示し、SQLITE_ERRORは実行時エラーがあったことを示します。 （エラーの詳細は&lt;b&gt;sqlite_finalize&lt;/b&gt;から取得されます。）ライブラリがSQLITE_DONEまたはSQLITE_ERRORを返した後に&lt;b&gt;sqlite_stepを&lt;/b&gt;再度&lt;b&gt;呼び出そ&lt;/b&gt;うとするのは、ライブラリの誤用です。</target>
        </trans-unit>
        <trans-unit id="9464a70b807f00dabcb5c4da75acd44d0a619fea" translate="yes" xml:space="preserve">
          <source>When all the INSERTs are put in a transaction, SQLite no longer has to close and reopen the database or invalidate its cache between each statement. It also does not have to do any fsync()s until the very end. When unshackled in this way, SQLite is much faster than either PostgreSQL and MySQL.</source>
          <target state="translated">すべての INSERT がトランザクション内に配置されると、SQLite はデータベースを閉じて開き直したり、各ステートメント間でキャッシュを無効にしたりする必要がなくなります。また、最後までfsync()を行う必要もありません。このようにアンシャックルされている場合、SQLiteはPostgreSQLやMySQLよりもはるかに高速です。</target>
        </trans-unit>
        <trans-unit id="83a11d4701cb9320d2bf4587af27d26604be7f83" translate="yes" xml:space="preserve">
          <source>When an FTS table accumulates 16 b-tree segments at the same level, the next INSERT into that table will cause all 16 segments to be merged into a single b-tree segment at the next higher level. The effect of these level merges is that most INSERTs into an FTS table are very fast and take minimal memory, but an occasional INSERT is slow and generates a large transaction because of the need to do merging. This results in &quot;spiky&quot; performance of INSERTs.</source>
          <target state="translated">FTS テーブルが同じレベルで 16 個の b-tree セグメントを蓄積している場合、そのテーブルへの次の INSERT は、16 個のセグメントすべてを次の上位レベルの単一の b-tree セグメントにマージします。これらのレベルのマージの効果は、ほとんどのFTSテーブルへのINSERTは非常に高速で、最小限のメモリしか必要としませんが、時折発生するINSERTは遅く、マージを行う必要があるために大規模なトランザクションを生成します。この結果、INSERTの「トゲトゲした」パフォーマンスが発生します。</target>
        </trans-unit>
        <trans-unit id="c3b65790b6c542323caaa50e227caf3d370e16fb" translate="yes" xml:space="preserve">
          <source>When an FTS5 table uses the custom tokenizer, the FTS5 core calls xCreate() once to create a tokenizer, then xTokenize() zero or more times to tokenize strings, then xDelete() to free any resources allocated by xCreate(). More specifically:</source>
          <target state="translated">FTS5 のテーブルがカスタムトークナイザーを使用する場合、FTS5 コアは xCreate()を一度だけコールしてトークナイザーを作成し、次に xTokenize()を 0 回以上コールして文字列をトークン化し、次に xDelete()をコールして xCreate()で割り当てられたリソースを解放します。より具体的には</target>
        </trans-unit>
        <trans-unit id="09202e860e734da0abbd632a5204a2fbedb299ae" translate="yes" xml:space="preserve">
          <source>When an FTS5 virtual table is created in a database, between 3 and 5 real tables are created in the database. These are known as &quot;&lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt;&quot;, and are used by the virtual table module to store persistent data. They should not be accessed directly by the user. Many other virtual table modules, including &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; and &lt;a href=&quot;rtree&quot;&gt;rtree&lt;/a&gt;, also create and use shadow tables.</source>
          <target state="translated">FTS5仮想テーブルがデータベースに作成されると、3〜5個の実テーブルがデータベースに作成されます。これらは「&lt;a href=&quot;vtab#xshadowname&quot;&gt;シャドウテーブル&lt;/a&gt;」と呼ばれ、仮想テーブルモジュールが永続データを格納するために使用します。ユーザーが直接アクセスすることはできません。&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;や&lt;a href=&quot;rtree&quot;&gt;rtree&lt;/a&gt;など、他の多くの仮想テーブルモジュールもシャドウテーブルを作成して使用します。</target>
        </trans-unit>
        <trans-unit id="8a38c7dc316e7e37718537bdea61961f91a6e323" translate="yes" xml:space="preserve">
          <source>When an SQL program is submitted to SQLite, the first step is to split the source text into &quot;tokens&quot;. A token might be:</source>
          <target state="translated">SQLプログラムがSQLiteに送信されるとき、最初のステップはソーステキストを「トークン」に分割することです。トークンは次のようになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="b898f19b28eed6509a35351ba88f244733f8458f" translate="yes" xml:space="preserve">
          <source>When an applicable constraint violation occurs, the ABORT resolution algorithm aborts the current SQL statement with an SQLITE_CONSTRAINT error and backs out any changes made by the current SQL statement; but changes caused by prior SQL statements within the same transaction are preserved and the transaction remains active. This is the default behavior and the behavior specified by the SQL standard.</source>
          <target state="translated">適用可能な制約違反が発生した場合、ABORT解決アルゴリズムはSQLITE_CONSTRAINTエラーで現在のSQL文を中止し、現在のSQL文によって行われたすべての変更をバックアウトしますが、同じトランザクション内の以前のSQL文によって引き起こされた変更は保存され、トランザクションはアクティブなままです。これはデフォルトの動作であり、SQL標準で指定された動作です。</target>
        </trans-unit>
        <trans-unit id="58bad3c331711aff15946bd280d303d43eef796f" translate="yes" xml:space="preserve">
          <source>When an applicable constraint violation occurs, the FAIL resolution algorithm aborts the current SQL statement with an SQLITE_CONSTRAINT error. But the FAIL resolution does not back out prior changes of the SQL statement that failed nor does it end the transaction. For example, if an UPDATE statement encountered a constraint violation on the 100th row that it attempts to update, then the first 99 row changes are preserved but changes to rows 100 and beyond never occur.</source>
          <target state="translated">適用可能な制約違反が発生した場合、FAIL解決アルゴリズムはSQLITE_CONSTRAINTエラーで現在のSQL文を中止します。しかし、FAIL解決は、失敗したSQL文の以前の変更をバックアウトしたり、トランザクションを終了したりしません。例えば、UPDATE文が更新しようとする100行目で制約違反に遭遇した場合、最初の99行目の変更は保存されますが、100行目以降の変更は発生しません。</target>
        </trans-unit>
        <trans-unit id="1b4aa81c65115bc42996b729bd361c5c8fafeff0" translate="yes" xml:space="preserve">
          <source>When an applicable constraint violation occurs, the IGNORE resolution algorithm skips the one row that contains the constraint violation and continues processing subsequent rows of the SQL statement as if nothing went wrong. Other rows before and after the row that contained the constraint violation are inserted or updated normally. No error is returned for uniqueness, NOT NULL, and UNIQUE constraint errors when the IGNORE conflict resolution algorithm is used. However, the IGNORE conflict resolution algorithm works like ABORT for &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; errors.</source>
          <target state="translated">適用可能な制約違反が発生すると、IGNORE解決アルゴリズムは制約違反を含む1つの行をスキップし、SQLステートメントの後続の行の処理を、何も問題がなかったかのように続行します。制約違反を含む行の前後の他の行は、通常どおり挿入または更新されます。 IGNORE競合解決アルゴリズムが使用されている場合、一意性、NOT NULL、およびUNIQUE制約エラーに対してエラーは返されません。ただし、IGNORE競合解決アルゴリズムは、&lt;a href=&quot;foreignkeys&quot;&gt;外部キー制約&lt;/a&gt;エラーに対してABORTのように機能します。</target>
        </trans-unit>
        <trans-unit id="a5ad08c0ccf1a58d1c588bdc448e26465adfe8be" translate="yes" xml:space="preserve">
          <source>When an applicable constraint violation occurs, the ROLLBACK resolution algorithm aborts the current SQL statement with an SQLITE_CONSTRAINT error and rolls back the current transaction. If no transaction is active (other than the implied transaction that is created on every command) then the ROLLBACK resolution algorithm works the same as the ABORT algorithm.</source>
          <target state="translated">適用可能な制約違反が発生した場合、ROLLBACK解決アルゴリズムはSQLITE_CONSTRAINTエラーで現在のSQL文を中止し、現在のトランザクションをロールバックします。トランザクションがアクティブでない場合(すべてのコマンドで作成される暗黙のトランザクション以外)、ROLLBACK解決アルゴリズムはABORTアルゴリズムと同じように動作します。</target>
        </trans-unit>
        <trans-unit id="df9a570011a02f30ad10c7c02dfbae7f79c1d8bc" translate="yes" xml:space="preserve">
          <source>When an attempt is made to read the 100 byte</source>
          <target state="translated">100バイトの読み込みを試みた場合</target>
        </trans-unit>
        <trans-unit id="e571fd87d73f16df54e68558314d212f85e9756b" translate="yes" xml:space="preserve">
          <source>When an error occurs, &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; will return one of the detailed &lt;a href=&quot;rescode&quot;&gt;error codes&lt;/a&gt; or &lt;a href=&quot;rescode#extrc&quot;&gt;extended error codes&lt;/a&gt;. The legacy behavior was that &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; would only return a generic &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; result code and the application would have to make a second call to &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; in order to find the underlying cause of the problem. With the &quot;v2&quot; prepare interfaces, the underlying reason for the error is returned immediately.</source>
          <target state="translated">エラーが発生すると、&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;は詳細&lt;a href=&quot;rescode&quot;&gt;エラーコード&lt;/a&gt;または&lt;a href=&quot;rescode#extrc&quot;&gt;拡張エラーコードの&lt;/a&gt; 1つを返します。従来の動作では、&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;は一般的な&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;結果コードのみを返し、アプリケーションは問題の根本的な原因を見つけるために&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;を2回呼び出す必要がありました。「v2」準備インターフェースを使用すると、エラーの根本的な理由がすぐに返されます。</target>
        </trans-unit>
        <trans-unit id="ccab92f3619cb54ee4858ee94848a4ee81189c29" translate="yes" xml:space="preserve">
          <source>When an error occurs, &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; will return one of the detailed &lt;a href=&quot;../rescode&quot;&gt;error codes&lt;/a&gt; or &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error codes&lt;/a&gt;. The legacy behavior was that &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; would only return a generic &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; result code and the application would have to make a second call to &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; in order to find the underlying cause of the problem. With the &quot;v2&quot; prepare interfaces, the underlying reason for the error is returned immediately.</source>
          <target state="translated">エラーが発生すると、&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;は詳細&lt;a href=&quot;../rescode&quot;&gt;エラーコード&lt;/a&gt;または&lt;a href=&quot;../rescode#extrc&quot;&gt;拡張エラーコードの&lt;/a&gt; 1つを返します。従来の動作では、&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;は一般的な&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;結果コードのみを返し、アプリケーションは問題の根本的な原因を見つけるために&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;を2回呼び出す必要がありました。「v2」準備インターフェースを使用すると、エラーの根本的な理由がすぐに返されます。</target>
        </trans-unit>
        <trans-unit id="5d56e138a3f9cc682aa13f997335180c0fb3034f" translate="yes" xml:space="preserve">
          <source>When an expression is a simple reference to a column of a real table (not a &lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; or subquery) then the expression has the same affinity as the table column.</source>
          <target state="translated">式が実際のテーブルの列への単純な参照（&lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt;またはサブクエリではない）である場合、式はテーブル列と同じ親和性を持ちます。</target>
        </trans-unit>
        <trans-unit id="6e0bc34d56cd507e6524dea6d88364c2053501fb" translate="yes" xml:space="preserve">
          <source>When an in-memory database is named in this way, it will only share its cache with another connection that uses exactly the same name.</source>
          <target state="translated">インメモリデータベースにこのような名前が付けられている場合、全く同じ名前を使用している別の接続とだけキャッシュを共有します。</target>
        </trans-unit>
        <trans-unit id="a4bc24ec2391f7a4a80ebd40d7eacec7ec5836a6" translate="yes" xml:space="preserve">
          <source>When an index contains all of the data needed for a query and when the original table never needs to be consulted, we call that index a &quot;covering index&quot;.</source>
          <target state="translated">クエリに必要なすべてのデータを含むインデックスで、元のテーブルを参照する必要がない場合は、そのインデックスを「カバーリングインデックス」と呼びます。</target>
        </trans-unit>
        <trans-unit id="82ebd13a345482eaf43922980ab28662ac5f3021" translate="yes" xml:space="preserve">
          <source>When an unlock-notify callback is registered, the application provides a single void* pointer that is passed to the callback when it is invoked. However, the signature of the callback function allows SQLite to pass it an array of void* context pointers. The first argument passed to an unlock-notify callback is a pointer to an array of void* pointers, and the second is the number of entries in the array.</source>
          <target state="translated">unlock-notify コールバックが登録されている場合、アプリケーションはコールバックが呼び出されたときにコールバックに渡される単一の void*ポインタを提供します。しかし、コールバック関数のシグネチャにより、SQLite はコールバック関数に void*コンテキストポインタの配列を渡すことができます。unlock-notify コールバックに渡される第一引数は void*ポインタの配列へのポインタであり、第二引数は配列内のエントリ数です。</target>
        </trans-unit>
        <trans-unit id="52b75d8996a29266548750270878024301ed32e8" translate="yes" xml:space="preserve">
          <source>When attempting to open a file, the SQLITE_NOTADB error indicates that the file being opened does not appear to be an SQLite database file.</source>
          <target state="translated">ファイルを開こうとすると、SQLITE_NOTADB エラーは、開いているファイルが SQLite データベース ファイルではないように見えることを示しています。</target>
        </trans-unit>
        <trans-unit id="9105d0e8a7ab7b349bd2fbe878c8275b8882d52a" translate="yes" xml:space="preserve">
          <source>When both the SQLite core and the &lt;a href=&quot;cli&quot;&gt;Command Line Interface&lt;/a&gt; (CLI) are both compiled with this option, then the CLI provides an extra command named &quot;.iotrace&quot; that provides a low-level log of I/O activity. This option is experimental and may be discontinued in a future release.</source>
          <target state="translated">SQLiteコアと&lt;a href=&quot;cli&quot;&gt;コマンドラインインターフェース&lt;/a&gt;（CLI）の両方がこのオプションでコンパイルされている場合、CLIは「.iotrace」という名前の追加コマンドを提供し、I / Oアクティビティの低レベルのログを提供します。このオプションは実験的であり、将来のリリースで廃止される可能性があります。</target>
        </trans-unit>
        <trans-unit id="36f9015046bd06c8d94d98831683d6a650fd53ca" translate="yes" xml:space="preserve">
          <source>When building the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;, it is helpful, but not required, to have the following third-party libraries on hand:</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;CLIを&lt;/a&gt;構築する場合、次のサードパーティライブラリを用意しておくと便利ですが、必須ではありません。</target>
        </trans-unit>
        <trans-unit id="ba9eeb759b581addc9af410a4bf9f2616522ac5b" translate="yes" xml:space="preserve">
          <source>When building with MSVC on Windows systems, one can put the zlib source code in the compat/zlib subdirectory of the source tree and then add the USE_ZLIB=1 option to the nmake command to cause the The Makefile.msc to automatically build and use an appropriate zlib library implementation.</source>
          <target state="translated">Windows システム上で MSVC を使用してビルドする場合、zlib ソースコードをソースツリーの compat/zlib サブディレクトリに置き、USE_ZLIB=1 オプションを nmake コマンドに追加すると、Makefile.msc が自動的にビルドして適切な zlib ライブラリの実装を使用するようになります。</target>
        </trans-unit>
        <trans-unit id="e30f7cd9c75ce2c6c161c9108a391a6b6c55986e" translate="yes" xml:space="preserve">
          <source>When casting a BLOB value to INTEGER, the value is first converted to TEXT.</source>
          <target state="translated">BLOB値をINTEGERにキャストすると、最初にTEXTに変換されます。</target>
        </trans-unit>
        <trans-unit id="5c0c597294629f9542feb4df0871368a01531b6a" translate="yes" xml:space="preserve">
          <source>When casting a BLOB value to a REAL, the value is first converted to TEXT.</source>
          <target state="translated">BLOB値をREALにキャストすると、最初にTEXTに変換されます。</target>
        </trans-unit>
        <trans-unit id="5067d93cc1cb86aa6af9bcf672584d0b1585ff55" translate="yes" xml:space="preserve">
          <source>When casting a TEXT value to INTEGER, the longest possible prefix of the value that can be interpreted as an integer number is extracted from the TEXT value and the remainder ignored. Any leading spaces in the TEXT value when converting from TEXT to INTEGER are ignored. If there is no prefix that can be interpreted as an integer number, the result of the conversion is 0. If the prefix integer is greater than +9223372036854775807 then the result of the cast is exactly +9223372036854775807. Similarly, if the prefix integer is less than -9223372036854775808 then the result of the cast is exactly -9223372036854775808.</source>
          <target state="translated">TEXT値をINTEGERにキャストする際には、整数として解釈できる値の最長の接頭辞がTEXT値から抽出され、残りは無視されます。TEXTからINTEGERに変換する際のTEXT値の先頭のスペースは無視されます。整数として解釈できる接頭辞がない場合、変換結果は0となります。 接頭辞の整数が+9223372036854775807より大きい場合、キャストの結果は正確には+9223372036854775807となります。同様に、接頭語の整数が-9223372036854775808より小さい場合、キャストの結果は正確に-9223372036854775808になります。</target>
        </trans-unit>
        <trans-unit id="65da0fa3bb91d9ed81f980bbc2df26063662f53c" translate="yes" xml:space="preserve">
          <source>When casting a TEXT value to REAL, the longest possible prefix of the value that can be interpreted as a real number is extracted from the TEXT value and the remainder ignored. Any leading spaces in the TEXT value are ignored when converging from TEXT to REAL. If there is no prefix that can be interpreted as a real number, the result of the conversion is 0.0.</source>
          <target state="translated">TEXT値をREALにキャストする際には、実数として解釈できる値の最長の接頭辞がTEXT値から抽出され、残りは無視されます。TEXT値からREALへの変換時には、TEXT値の先頭のスペースは無視されます。実数として解釈できる接頭辞がない場合、変換結果は0.0となります。</target>
        </trans-unit>
        <trans-unit id="46e82821742f6cd2f96bd6126debacd8be0bdcfb" translate="yes" xml:space="preserve">
          <source>When casting to INTEGER, if the text looks like a floating point value with an exponent, the exponent will be ignored because it is no part of the integer prefix. For example, &quot;(CAST '123e+5' AS INTEGER)&quot; results in 123, not in 12300000.</source>
          <target state="translated">INTEGERにキャストする場合、テキストが指数を持つ浮動小数点値のように見える場合、指数は整数の接頭辞の一部ではないので無視されます。例えば、&quot;(CAST '123e+5' AS INTEGER)&quot;は123ではなく123になります。</target>
        </trans-unit>
        <trans-unit id="39d5e03e61b6bf8d9e7be24acbf923224eccdb8e" translate="yes" xml:space="preserve">
          <source>When checking for the WHERE-clause push-down optimization, verify that all terms of the compound inner SELECT are non-aggregate, not just the last term. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f7f8c97e97597&quot;&gt;f7f8c97e97597&lt;/a&gt;.</source>
          <target state="translated">WHERE句のプッシュダウン最適化をチェックするときは、複合内部SELECTのすべての用語が、最後の用語だけでなく、非集計であることを確認してください。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/f7f8c97e97597&quot;&gt;f7f8c97e97597の&lt;/a&gt;修正。</target>
        </trans-unit>
        <trans-unit id="95988d2f9a83f35536e66d62cf26515907b72996" translate="yes" xml:space="preserve">
          <source>When compared with SQLite's built-in VACUUM command, RBU Vacuum has the following limitations:</source>
          <target state="translated">SQLiteのビルトインVACUUMコマンドと比較した場合、RBU Vacuumには以下の制限があります。</target>
        </trans-unit>
        <trans-unit id="71ec8021f2a78c2f5787e61e104c092e2cf0b2cc" translate="yes" xml:space="preserve">
          <source>When comparing a base expression against a WHEN expression, the same collating sequence, affinity, and NULL-handling rules apply as if the base expression and WHEN expression are respectively the left- and right-hand operands of an</source>
          <target state="translated">基底式とWHEN式を比較する場合、基底式とWHEN式がそれぞれ</target>
        </trans-unit>
        <trans-unit id="8a8e8bf765d052cbbdbda4e8360051200aec0343" translate="yes" xml:space="preserve">
          <source>When comparing text values, the &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; associated with the parent key column is always used.</source>
          <target state="translated">テキスト値を比較する場合、親キー列に関連付けられた&lt;a href=&quot;datatype3#collation&quot;&gt;照合シーケンス&lt;/a&gt;が常に使用されます。</target>
        </trans-unit>
        <trans-unit id="8bd6464f68b9918a029c67f18300aa6bddf2bf88" translate="yes" xml:space="preserve">
          <source>When comparing values, if the parent key column has an &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt;, then that affinity is applied to the child key value before the comparison is performed.</source>
          <target state="translated">値を比較するときに、親キー列に&lt;a href=&quot;datatype3#affinity&quot;&gt;類似性がある&lt;/a&gt;場合、その類似性は比較が実行される前に子キー値に適用されます。</target>
        </trans-unit>
        <trans-unit id="8a8c1f258ce77d3b0b1a04487b470e53840cc8d0" translate="yes" xml:space="preserve">
          <source>When compiled with &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;, SQLite includes routines that will print out various internal parse tree structures as ASCII-art graphs. This can be very useful in a debugging in order to understand the variables that SQLite is working with.</source>
          <target state="translated">&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;でコンパイルすると、SQLiteには、さまざまな内部解析ツリー構造をASCIIアートグラフとして出力するルーチンが含まれます。これは、SQLiteが使用している変数を理解するためのデバッグに非常に役立ちます。</target>
        </trans-unit>
        <trans-unit id="b440573f54c675131665957f45fa09226296363a" translate="yes" xml:space="preserve">
          <source>When compiling with this option, it will normally be necessary to add a linker option to include the zlib library in the build. Normal this option is &quot;-lz&quot; but might be different on different systems.</source>
          <target state="translated">このオプションでコンパイルする場合、通常はリンカーオプションを追加してzlibライブラリをビルドに含める必要があります。通常このオプションは&quot;-lz &quot;ですが、システムによっては異なるかもしれません。</target>
        </trans-unit>
        <trans-unit id="c300eac9b0ba20d1c5f0548bea68bd1985408338" translate="yes" xml:space="preserve">
          <source>When computing the cost of the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt;, take into account the fact that multiple seeks are required.</source>
          <target state="translated">&lt;a href=&quot;optoverview#skipscan&quot;&gt;スキップスキャン最適化&lt;/a&gt;のコストを計算するときは、複数のシークが必要であることを考慮してください。</target>
        </trans-unit>
        <trans-unit id="0f31671e641184fdff6ce2920c28181e45773893" translate="yes" xml:space="preserve">
          <source>When confronted with OR-connected terms in a WHERE clause, SQLite examines each OR term separately and tries to use an index to find the rowids associated with each term. It then takes the union of the resulting rowid sets to find the end result. The following figure illustrates this process:</source>
          <target state="translated">WHERE 句で OR 接続された用語に直面した場合、SQLite は各 OR 用語を個別に調べ、インデックスを使用して各用語に関連付けられた行 ID を見つけようとします。そして、結果として得られた行 ID セットの和を取って最終結果を見つけます。次の図はこのプロセスを示しています。</target>
        </trans-unit>
        <trans-unit id="80acebb0e2681ada8eda5ed06d14fb5c6e654492" translate="yes" xml:space="preserve">
          <source>When content is deleted from an SQLite database, pages that are no longer used are added to a free list and are reused to hold content added by subsequent inserts. A bug in SQLite that was present in version 3.6.16 through 3.7.2 might cause pages to go missing out of the free list when &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; was used. This would not cause data loss. But it would result in the database file being larger than necessary. And it would cause the &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check pragma&lt;/a&gt; to report pages missing from the free list.</source>
          <target state="translated">SQLiteデータベースからコンテンツが削除されると、使用されなくなったページが空きリストに追加され、後続の挿入によって追加されたコンテンツを保持するために再利用されます。バージョン3.6.16から3.7.2に存在していたSQLiteのバグにより、&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt;が使用されたときに、ページがフリーリストから失われる可能性があります。これによりデータが失われることはありません。ただし、データベースファイルが必要以上に大きくなります。そして、&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_checkプラグマ&lt;/a&gt;は、フリーリストにないページを報告します。</target>
        </trans-unit>
        <trans-unit id="ec68acb5aee4ac70ffc0e427ed46e7978d7d9aaa" translate="yes" xml:space="preserve">
          <source>When content is deleted from an SQLite database, the content is not usually erased but rather the space used to hold the content is marked as being available for reuse. This can allow deleted content to be recovered by a hacker or by forensic analysis. Running VACUUM will clean the database of all traces of deleted content, thus preventing an adversary from recovering deleted content. Using VACUUM in this way is an alternative to setting &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;PRAGMA secure_delete=ON&lt;/a&gt;.</source>
          <target state="translated">コンテンツがSQLiteデータベースから削除されると、通常、コンテンツは消去されず、コンテンツを保持するために使用されるスペースが再利用可能としてマークされます。これにより、ハッカーまたは科学捜査による削除済みコンテンツの復元が可能になります。VACUUMを実行すると、削除されたコンテンツのすべての痕跡がデータベースから消去されるため、攻撃者が削除されたコンテンツを回復できなくなります。この方法でVACUUMを使用することは、&lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;PRAGMA secure_delete = ON&lt;/a&gt;を設定する代わりになります。</target>
        </trans-unit>
        <trans-unit id="3ef3b5e9abd6cdd13cd5d387ea4a3c929af66232" translate="yes" xml:space="preserve">
          <source>When converting BLOB to TEXT, use the text encoding of the main database. Ticket #2349</source>
          <target state="translated">BLOBをTEXTに変換する際、メインデータベースのテキストエンコーディングを使用する。チケット #2349</target>
        </trans-unit>
        <trans-unit id="114a59b6e420f398fe8acae2dbbd380f2c338748" translate="yes" xml:space="preserve">
          <source>When creating a new database file during &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; on unix systems, SQLite will try to set the permissions of the new database file to match the existing file &quot;</source>
          <target state="translated">UNIXシステムで&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）の&lt;/a&gt;実行中に新しいデータベースファイルを作成すると、SQLiteは既存のファイルと一致するように新しいデータベースファイルの権限を設定しようとします。</target>
        </trans-unit>
        <trans-unit id="bb5190d7ef1fca8d42df7043f112c5cb64984b8e" translate="yes" xml:space="preserve">
          <source>When creating new user-defined SQL functions and collating sequences, each function or collating sequence can specify if it works with UTF-8, UTF-16be, or UTF-16le. Separate implementations can be registered for each encoding. If an SQL function or collating sequence is required but a version for the current text encoding is not available, then the text is automatically converted. As before, this conversion takes computation time, so programmers are advised to pick a single encoding and stick with it in order to minimize the amount of unnecessary format juggling.</source>
          <target state="translated">新規にユーザー定義 SQL 関数や照合順序を作成する際に、各関数や照合順序は UTF-8、UTF-16be、UTF-16le のいずれで動作するかを指定することができます。エンコーディングごとに別々の実装を登録することができます。SQL関数や照合順序が必要で、現在のテキストエンコーディングに対応したバージョンがない場合は、自動的にテキストが変換されます。前と同様に、この変換には計算時間がかかりますので、プログラマーは、不必要なフォーマットのジャグリングを最小限に抑えるために、一つのエンコーディングを選んでそれに固執することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="6a02367c161ead06f619b074aecd9b89d2c0cc40" translate="yes" xml:space="preserve">
          <source>When data is appended to the end of the rollback journal, SQLite normally makes the pessimistic assumption that the file is first extended with invalid &quot;garbage&quot; data and that afterwards the correct data replaces the garbage. In other words, SQLite assumes that the file size is increased first and then afterwards the content is written into the file. If a power failure occurs after the file size has been increased but before the file content has been written, the rollback journal can be left containing garbage data. If after power is restored, another SQLite process sees the rollback journal containing the garbage data and tries to roll it back into the original database file, it might copy some of the garbage into the database file and thus corrupt the database file.</source>
          <target state="translated">ロールバック ジャーナルの末尾にデータを追加する場合、SQLite は通常、ファイルが最初に無効な &quot;ゴミ &quot;データで拡張され、その後に正しいデータがゴミに置き換わるという悲観的な仮定をします。つまり、SQLiteは、最初にファイルサイズが拡張され、その後にコンテンツがファイルに書き込まれると仮定しています。ファイルサイズが増加した後、ファイルの内容が書き込まれる前に停電が発生した場合、ロールバックジャーナルにはガベージデータが残っている可能性があります。電源が復旧した後、別のSQLiteプロセスがガベージデータを含むロールバックジャーナルを見て、元のデータベースファイルにロールバックしようとすると、ガベージの一部をデータベースファイルにコピーしてしまい、データベースファイルが破損してしまう可能性があります。</target>
        </trans-unit>
        <trans-unit id="6e1728b3880c31067245341a957998cb64468579" translate="yes" xml:space="preserve">
          <source>When database corruption is detected, an SQLITE_CORRUPT error logger callback is invoked. As with I/O errors, the error message text contains the line number in the original source code where the error was first detected.</source>
          <target state="translated">データベースの破損が検出されると、SQLITE_CORRUPT エラーロガーのコールバックが呼び出されます。I/O エラーと同様に、エラーメッセージのテキストには、エラーが最初に検出された元のソースコードの行番号が含まれています。</target>
        </trans-unit>
        <trans-unit id="5ec353b1e7bb6a3ecdd47f7ae7473e801761839f" translate="yes" xml:space="preserve">
          <source>When dates are stored this way, row value comparisons provide a convenient way to compare dates:</source>
          <target state="translated">日付がこのように保存されている場合、行値比較は日付を比較する便利な方法を提供します。</target>
        </trans-unit>
        <trans-unit id="db590fa9b88387884339466c341a1e3e6a784a7d" translate="yes" xml:space="preserve">
          <source>When debugging the &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; generator, it is often useful to know where a particular opcode is being generated. To find this easily, run the script in a debugger. Set a breakpoint on the &quot;test_addoptrace&quot; routine. Then run the &quot;PRAGMA vdbe_addoptrace=ON;&quot; followed by the SQL statement in question. Each opcode will be displayed as it is appended to the VDBE program, and the breakpoint will fire immediately thereafter. Step until reaching the opcode then look backwards in the stack to see where and how it was generated.</source>
          <target state="translated">&lt;a href=&quot;opcode&quot;&gt;バイトコード&lt;/a&gt;ジェネレーターをデバッグするとき、特定のオペコードがどこで生成されているかを知ることはしばしば役に立ちます。これを簡単に見つけるには、デバッガーでスクリプトを実行します。 「test_addoptrace」ルーチンにブレークポイントを設定します。次に、「PRAGMA vdbe_addoptrace = ON;」を実行します。問題のSQLステートメントが続きます。各オペコードはVDBEプログラムに追加されるときに表示され、その直後にブレークポイントが発生します。オペコードに到達するまでステップしてから、スタックを後方に見て、それがどこでどのように生成されたかを確認します。</target>
        </trans-unit>
        <trans-unit id="d36e8b2fe095f3dcf16b488533e2eea81261ce34" translate="yes" xml:space="preserve">
          <source>When deciding between two plans with the same estimated cost, bias the selection toward the one that does not use the sorter.</source>
          <target state="translated">同じ見積コストで2つのプランを決定する場合は、ソーターを使用しない方に選択を偏らせてください。</target>
        </trans-unit>
        <trans-unit id="bf93f718a16c4baf24f9f9cd0779c38e6d7918df" translate="yes" xml:space="preserve">
          <source>When defined, this C-preprocessor macro activates extra code that attempts to detect misuse of the SQLite API, such as passing in NULL pointers to required parameters or using objects after they have been destroyed.</source>
          <target state="translated">定義されている場合、この C プリプロセッサ マクロは、必要なパラメータに NULL ポインタを渡したり、オブジェクトが破棄された後にオブジェクトを使用したりするなど、SQLite API の不正使用を検出しようとする追加コードをアクティブにします。</target>
        </trans-unit>
        <trans-unit id="1548f1f2e91ad07dfb5ee921f08a77e6a373fb3e" translate="yes" xml:space="preserve">
          <source>When defining a TEMP trigger on a non-TEMP table, it is important to specify the database holding the non-TEMP table. For example, in the following statement, it is important to say &quot;main.tab1&quot; instead of just &quot;tab1&quot;:</source>
          <target state="translated">非TEMPテーブル上でTEMPトリガーを定義する場合、非TEMPテーブルを保持するデータベースを指定することが重要です。例えば、以下の文では、単に「tab1」ではなく「main.tab1」とすることが重要です。</target>
        </trans-unit>
        <trans-unit id="08cdbd4cf4d969a92be0666ae36716558d90ece0" translate="yes" xml:space="preserve">
          <source>When doing DELETE and UPDATE, the library used to write the record numbers of records to be deleted or updated into a temporary file. This is changed so that the record numbers are held in memory.</source>
          <target state="translated">DELETEやUPDATEを行う際に、ライブラリでは削除や更新を行うレコードのレコード番号を一時ファイルに書き込んでいました。これを変更して、レコード番号をメモリに保持するようにしました。</target>
        </trans-unit>
        <trans-unit id="3cda947ba0235d70ea9379c938638b6e342ed7b3" translate="yes" xml:space="preserve">
          <source>When doing an indexed lookup of a row, the usual procedure is to do a binary search on the index to find the index entry, then extract the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; from the index and use that &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; to do a binary search on the original table. Thus a typical indexed lookup involves two binary searches. If, however, all columns that were to be fetched from the table are already available in the index itself, SQLite will use the values contained in the index and will never look up the original table row. This saves one binary search for each row and can make many queries run twice as fast.</source>
          <target state="translated">行のインデックス付きルックアップを行う場合、通常の手順は、インデックスでバイナリ検索を実行してインデックスエントリを見つけ、インデックスから&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;を抽出し、その&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;を使用して元のテーブルでバイナリ検索を実行します。したがって、一般的なインデックス付きルックアップには、2つのバイナリ検索が含まれます。ただし、テーブルからフェッチされるすべての列がインデックス自体ですでに使用可能な場合、SQLiteはインデックスに含まれている値を使用し、元のテーブル行を検索することはありません。これにより、行ごとに1つのバイナリ検索が節約され、多くのクエリを2倍の速度で実行できます。</target>
        </trans-unit>
        <trans-unit id="9904bf6d42a19655ef67955a4a94073b0eae876b" translate="yes" xml:space="preserve">
          <source>When doing an insert without a rowid (argc&amp;gt;1, argv[1] is an SQL NULL), on a virtual table that uses ROWID (but not on a &lt;a href=&quot;vtab#worid&quot;&gt;WITHOUT ROWID virtual table&lt;/a&gt;), the implementation must set *pRowid to the rowid of the newly inserted row; this will become the value returned by the &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; function. Setting this value in all the other cases is a harmless no-op; the SQLite engine ignores the *pRowid return value if argc==1 or argv[1] is not an SQL NULL.</source>
          <target state="translated">ROWID（argc&amp;gt; 1、argv [1]はSQL NULL）なしで挿入を行う場合、ROWIDを使用する仮想テーブル（&lt;a href=&quot;vtab#worid&quot;&gt;WITHOUT ROWID仮想テーブル&lt;/a&gt;ではない）で、実装は* pRowidを新しく挿入された行。これは、&lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）&lt;/a&gt;関数によって返される値になります。他のすべての場合にこの値を設定しても、無害です。 argc == 1またはargv [1]がSQL NULLでない場合、SQLiteエンジンは* pRowidの戻り値を無視します。</target>
        </trans-unit>
        <trans-unit id="1c8dd9af0591131c94abbb3f55e35333a90c2bb5" translate="yes" xml:space="preserve">
          <source>When enabled, this PRAGMA causes many &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements without an ORDER BY clause to emit their results in the reverse order from what they normally would. This can help debug applications that are making invalid assumptions about the result order. The reverse_unordered_selects pragma works for most SELECT statements, however the query planner may sometimes choose an algorithm that is not easily reversed, in which case the output will appear in the same order regardless of the reverse_unordered_selects setting.</source>
          <target state="translated">このPRAGMAを有効にすると、ORDER BY句のない多くの&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントが、通常とは逆の順序で結果を出力します。これは、結果の順序について無効な仮定をしているアプリケーションのデバッグに役立ちます。reverse_unordered_selectsプラグマはほとんどのSELECTステートメントで機能しますが、クエリプランナーは逆に簡単にはできないアルゴリズムを選択する場合があります。その場合、reverse_unordered_selects設定に関係なく、出力は同じ順序で表示されます。</target>
        </trans-unit>
        <trans-unit id="17ef63392395a1e6663e404dcadfba942c11b299" translate="yes" xml:space="preserve">
          <source>When faced with a choice of two or more indices, SQLite tries to estimate the total amount of work needed to perform the query using each option. It then selects the option that gives the least estimated work.</source>
          <target state="translated">2つ以上のインデックスの選択に直面したとき、SQLiteはそれぞれのオプションを使用してクエリを実行するのに必要な総作業量を見積もろうとします。そして、見積もった作業量が最も少ないオプションを選択します。</target>
        </trans-unit>
        <trans-unit id="393ffe20ba1bb6822b853fbdd74f36cd0864d018" translate="yes" xml:space="preserve">
          <source>When files opened with the asynchronous VFS are read from (using the vfs xRead() method), the data is read from the file on disk and the write-queue, so that from the point of view of the vfs reader the xWrite() appears to have already completed.</source>
          <target state="translated">非同期VFSでオープンされたファイルを(vfsのxRead()メソッドを使用して)読み出すと、ディスク上のファイルと書き込みキューからデータが読み出されるので、vfsリーダーから見ればxWrite()は既に完了しているように見えます。</target>
        </trans-unit>
        <trans-unit id="c7d3d8950c12709e47c72758e22cf2a9146592d1" translate="yes" xml:space="preserve">
          <source>When generating individual loops for each ORed term of an OR scan, move any constant WHERE expressions outside of the loop, as is done for top-level loops.</source>
          <target state="translated">ORスキャンの各OR付き項のために個別のループを生成する場合、トップレベルのループで行われるように、定数のWHERE式をループの外に移動します。</target>
        </trans-unit>
        <trans-unit id="509726027c6ee1ed12b9f77062dac2b144897c56" translate="yes" xml:space="preserve">
          <source>When grouping values with the GROUP BY clause values with different storage classes are considered distinct, except for INTEGER and REAL values which are considered equal if they are numerically equal. No affinities are applied to any values as the result of a GROUP by clause.</source>
          <target state="translated">GROUP BY句を使用して値をグループ化する場合、異なるストレージ・クラスを持つ値は、数値的に等しい場合は等しいとみなされるINTEGER値とREAL値を除き、別個の値とみなされます。GROUP BY句の結果として、いかなる値にも親和性は適用されません。</target>
        </trans-unit>
        <trans-unit id="f5be44df47344688e11692055f71bde95bd3d10c" translate="yes" xml:space="preserve">
          <source>When implementing the compress and uncompress functions it is important to pay attention to data types. Specifically, when a user reads a value from a compressed FTS table, the value returned by FTS is exactly the same as the value returned by the uncompress function, including the data type. If that data type is not the same as the data type of the original value as passed to the compress function (for example if the uncompress function is returning BLOB when compress was originally passed TEXT), then the users query may not function as expected.</source>
          <target state="translated">圧縮・解凍関数を実装する際には、データ型に注意を払うことが重要です。具体的には、ユーザが圧縮されたFTSテーブルから値を読み出すと、FTSが返す値は、データ型を含めて、圧縮解除関数が返す値と全く同じになります。そのデータ型が、圧縮関数に渡された元の値のデータ型と同じでない場合(例えば、圧縮が元々TEXTを渡されていたときに、アン圧縮関数がBLOBを返していた場合など)、ユーザのクエリが期待通りに機能しない可能性があります。</target>
        </trans-unit>
        <trans-unit id="9aa85d5d53872aab853201ddf44e7a88440d444e" translate="yes" xml:space="preserve">
          <source>When in active use, the state of a WAL mode database is described by three separate files:</source>
          <target state="translated">アクティブに使用されているとき、WALモードのデータベースの状態は3つの別々のファイルで記述されます。</target>
        </trans-unit>
        <trans-unit id="2d85294d594836a84f09ae35993c5315f3443a88" translate="yes" xml:space="preserve">
          <source>When information is deleted from an SQLite database, the pages used to hold the deleted information are added to a &quot;&lt;a href=&quot;fileformat2#freelist&quot;&gt;freelist&lt;/a&gt;&quot;. Subsequent inserts will draw pages off of this freelist rather than expanding the database file.</source>
          <target state="translated">SQLiteデータベースから情報が削除されると、削除された情報を保持するために使用されるページが「&lt;a href=&quot;fileformat2#freelist&quot;&gt;フリーリスト&lt;/a&gt;」に追加されます。後続の挿入では、データベースファイルを拡張するのではなく、このフリーリストからページを描画します。</target>
        </trans-unit>
        <trans-unit id="e58c2028dd3a68f355f0f948fe1f1f5ac6f262b7" translate="yes" xml:space="preserve">
          <source>When initially opened, the cursor is in an undefined state. The SQLite core will invoke the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method on the cursor prior to any attempt to position or read from the cursor.</source>
          <target state="translated">最初に開いたとき、カーソルは未定義の状態です。SQLiteコアは、カーソルの配置または読み取りを試みる前に、カーソルで&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;メソッドを呼び出します。</target>
        </trans-unit>
        <trans-unit id="4ec1014aface212f1273d4c0983ab7820ffd9ca0" translate="yes" xml:space="preserve">
          <source>When inserting an explicit NULL into an INTEGER PRIMARY KEY, convert the NULL value into a unique key automatically.</source>
          <target state="translated">INTEGER PRIMARY KEY に明示的な NULL を挿入した場合、NULL 値を自動的に一意のキーに変換します。</target>
        </trans-unit>
        <trans-unit id="643f10feaaa38e7180b2d82bb59e6a7c32281c82" translate="yes" xml:space="preserve">
          <source>When looking for memory allocation problems (memory leaks, use-after-free errors, buffer overflows, etc) it is sometimes useful to disable the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; then run the test under valgrind or MSAN or some other heap memory debugging tool. The lookaside memory allocator can be disabled at start-time using the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglookaside&quot;&gt;SQLITE_CONFIG_LOOKASIDE&lt;/a&gt; interface. The &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; will use that interface to disable lookaside if it is started with the &quot;--lookaside 0 0&quot; command line option.</source>
          <target state="translated">メモリ割り当ての問題（メモリリーク、解放後使用エラー、バッファオーバーフローなど）を探す場合、&lt;a href=&quot;malloc#lookaside&quot;&gt;lookasideメモリアロケータ&lt;/a&gt;を無効にしてから、valgrindまたはMSANまたはその他のヒープメモリデバッグツールでテストを実行すると便利な場合があります。ルックアサイドメモリアロケータは、&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglookaside&quot;&gt;SQLITE_CONFIG_LOOKASIDE&lt;/a&gt;インターフェイスを使用して、起動時に無効にすることができます。&lt;a href=&quot;cli&quot;&gt;コマンドラインシェルは、&lt;/a&gt;それが「--lookaside 0 0」コマンドラインオプションで起動された場合は無効に索引にそのインタフェースを使用します。</target>
        </trans-unit>
        <trans-unit id="42fe685cb985a24b50ac506fdd29223838c245b8" translate="yes" xml:space="preserve">
          <source>When measuring test coverage, these macros are defined to be constant truth values so that they do not generate assembly language branch instructions, and hence do not come into play when calculating the branch coverage:</source>
          <target state="translated">テストカバレッジを測定する際、これらのマクロは、アセンブリ言語の分岐命令を生成しないように、一定の真理値として定義されているため、分岐カバレッジを計算する際には影響を受けません。</target>
        </trans-unit>
        <trans-unit id="37b8b518e60139042da23ec309a2db4382dae010" translate="yes" xml:space="preserve">
          <source>When more than two tables are joined together as part of a FROM clause, the join operations are processed in order from left to right. In other words, the FROM clause (A join-op-1 B join-op-2 C) is computed as ((A join-op-1 B) join-op-2 C).</source>
          <target state="translated">2つ以上のテーブルがFROM句の一部として結合されている場合、結合操作は左から順に処理されます。つまり、FROM句(A join-op-1 B join-op-2 C)は、((A join-op-1 B)join-op-2 C)のように計算されます。</target>
        </trans-unit>
        <trans-unit id="87981e247df4872c2958ce96479f7f548dab13e8" translate="yes" xml:space="preserve">
          <source>When multiple database connections share the same cache, changing the secure-delete flag on one database connection changes it for them all.</source>
          <target state="translated">複数のデータベース接続が同じキャッシュを共有している場合、1つのデータベース接続の secure-delete フラグを変更すると、すべてのデータベース接続の secure-delete フラグが変更されます。</target>
        </trans-unit>
        <trans-unit id="cff16baa2216647f9ba74dc7c006fb34b16c7df6" translate="yes" xml:space="preserve">
          <source>When multiple database files are involved in a transaction, each database has its own rollback journal and each database is locked separately. The diagram at the right shows a scenario where three different database files have been modified within one transaction. The situation at this step is analogous to the single-file transaction scenario at &lt;a href=&quot;#section_3_6&quot;&gt;step 3.6&lt;/a&gt;. Each database file has a reserved lock. For each database, the original content of pages that are being changed have been written into the rollback journal for that database, but the content of the journals have not yet been flushed to disk. No changes have been made to the database file itself yet, though presumably there are changes being held in user memory.</source>
          <target state="translated">トランザクションに複数のデータベースファイルが含まれる場合、各データベースには独自のロールバックジャーナルがあり、各データベースは個別にロックされます。右の図は、3つの異なるデータベースファイルが1つのトランザクション内で変更されたシナリオを示しています。このステップの状況は、&lt;a href=&quot;#section_3_6&quot;&gt;ステップ3.6の&lt;/a&gt;単一ファイルトランザクションシナリオに類似しています。各データベースファイルには、予約済みのロックがあります。各データベースについて、変更されるページの元のコンテンツはそのデータベースのロールバックジャーナルに書き込まれていますが、ジャーナルのコンテンツはまだディスクにフラッシュされていません。データベースファイル自体はまだ変更されていませんが、ユーザーメモリに保持されている変更があると考えられます。</target>
        </trans-unit>
        <trans-unit id="594f4bededce2bfb4a7467d0259050d544509cc0" translate="yes" xml:space="preserve">
          <source>When mxFrame field is zero, it indicates that the WAL is empty and that all content should be obtained directly from the database file.</source>
          <target state="translated">mxFrameフィールドが0の場合、WALが空であり、すべてのコンテンツがデータベースファイルから直接取得されるべきであることを示します。</target>
        </trans-unit>
        <trans-unit id="1e88c1e1b6e3eb28ff7f2a97dc557877c5de44f1" translate="yes" xml:space="preserve">
          <source>When mxFrame is equal to &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt;, that indicates that all content in the WAL has been written back into the database. In that case, all content can be read directly from the database. Furthermore, the next writer is free to &lt;a href=&quot;fileformat2#walreset&quot;&gt;reset the WAL&lt;/a&gt; if no other connections hold locks on WAL_READ_LOCK(N) for N&amp;gt;0.</source>
          <target state="translated">mxFrameに等しいとき&lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt;、それがWALのすべてのコンテンツをデータベースに書き戻されたことを示しています。その場合、すべてのコンテンツをデータベースから直接読み取ることができます。さらに、他の接続がN&amp;gt; 0のWAL_READ_LOCK（N）のロックを保持していない場合、次のライターは&lt;a href=&quot;fileformat2#walreset&quot;&gt;WALを&lt;/a&gt;自由にリセットできます。</target>
        </trans-unit>
        <trans-unit id="4d7dccde63e1547be27c7ca87cdd1931b0750828" translate="yes" xml:space="preserve">
          <source>When new tables are created using CREATE TABLE ... AS SELECT ... the datatype of the columns is the simplified SQLite datatype (TEXT, INT, REAL, NUMERIC, or BLOB) instead of a copy of the original datatype from the source table.</source>
          <target state="translated">CREATE TABLE ...AS SELECT ...を使用して新しいテーブルを作成した場合、列のデータ型は元のテーブルのデータ型のコピーではなく、SQLite の簡略化されたデータ型(TEXT、INT、REAL、NUMERIC、BLOB)となります。AS SELECT ...カラムのデータ型は、元のテーブルの元のデータ型のコピーではなく、SQLite の簡略化されたデータ型(TEXT、INT、REAL、NUMERIC、BLOB)となります。</target>
        </trans-unit>
        <trans-unit id="a55aa5700dcf1b282b21e4844d72874dc0872eb0" translate="yes" xml:space="preserve">
          <source>When no appropriate indices are available, a query with an ORDER BY clause must be sorted as a separate step. Consider this query:</source>
          <target state="translated">適切なインデックスがない場合は、ORDER BY句を持つクエリを別のステップとしてソートする必要があります。このクエリを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="390a0c90ac5f7c87fa004dbc08670c0d9227649a" translate="yes" xml:space="preserve">
          <source>When no indices are available to aid the evaluation of a query, SQLite might create an automatic index that lasts only for the duration of a single SQL statement. Since the cost of constructing the automatic index is O(NlogN) (where N is the number of entries in the table) and the cost of doing a full table scan is only O(N), an automatic index will only be created if SQLite expects that the lookup will be run more than logN times during the course of the SQL statement. Consider an example:</source>
          <target state="translated">クエリの評価を支援するためのインデックスが利用できない場合、SQLiteは単一のSQL文の間だけ持続する自動インデックスを作成することがあります。自動インデックスを作成するためのコストはO(NlogN)(ここでNはテーブル内のエントリ数)であり、テーブルのフルスキャンを行うためのコストはO(N)だけなので、自動インデックスはSQLiteがSQL文の実行中に検索がlogN回以上実行されると予想した場合にのみ作成されます。例を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="540aa517907a8d449dfe0e0b35e5509aa40924c4" translate="yes" xml:space="preserve">
          <source>When one of RAISE(ROLLBACK,...), RAISE(ABORT,...) or RAISE(FAIL,...) is called during trigger-program execution, the specified &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; processing is performed and the current query terminates. An error code of &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; is returned to the application, along with the specified error message.</source>
          <target state="translated">When one of RAISE(ROLLBACK,...), RAISE(ABORT,...) or RAISE(FAIL,...) is called during trigger-program execution, the specified &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; processing is performed and the current query terminates. An error code of &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; is returned to the application, along with the specified error message.</target>
        </trans-unit>
        <trans-unit id="4e54fe7f1e563760a880b88a508db483dfbb6a4e" translate="yes" xml:space="preserve">
          <source>When one of RAISE(ROLLBACK,...), RAISE(ABORT,...) or RAISE(FAIL,...) is called during trigger-program execution, the specified &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; processing is performed the current query terminates. An error code of &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; is returned to the application, along with the specified error message.</source>
          <target state="translated">トリガープログラムの実行中にRAISE（ROLLBACK、...）、RAISE（ABORT、...）、またはRAISE（FAIL、...）のいずれかが呼び出されると、指定された&lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;処理が実行され、現在のクエリが終了します。&lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;のエラーコードが、指定されたエラーメッセージと共にアプリケーションに返されます。</target>
        </trans-unit>
        <trans-unit id="01227fb935ccfc1f5f31820ba60592508e753c65" translate="yes" xml:space="preserve">
          <source>When opening a file, if the command-line client discovers that the file is ZIP archive instead of an SQLite database, it actually opens an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; and then in that in-memory database it creates an instance of the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; that is attached to the ZIP archive.</source>
          <target state="translated">When opening a file, if the command-line client discovers that the file is ZIP archive instead of an SQLite database, it actually opens an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; and then in that in-memory database it creates an instance of the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; that is attached to the ZIP archive.</target>
        </trans-unit>
        <trans-unit id="4362aeea9635659d5b4cd64a35ff28fb52ad1831" translate="yes" xml:space="preserve">
          <source>When operating in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, all SQLite database connections associated with the same database file need to share some memory that is used as an index for the WAL file. In most implementations, this shared memory is implemented by calling mmap() on a file created for this sole purpose: the shared-memory file. The shared-memory file, if it exists, is located in the same directory as the database file and has the same name as the database file except with the 4 characters &quot;&lt;b&gt;-shm&lt;/b&gt;&quot; appended. Shared memory files only exist while running in WAL mode.</source>
          <target state="translated">&lt;a href=&quot;wal&quot;&gt;WALモード&lt;/a&gt;で動作している場合、同じデータベースファイルに関連付けられているすべてのSQLiteデータベース接続は、WALファイルのインデックスとして使用されるメモリを共有する必要があります。ほとんどの実装では、この共有メモリは、この唯一の目的で作成されたファイル（共有メモリファイル）でmmap（）を呼び出すことによって実装されます。共有メモリファイルが存在する場合、データベースファイルと同じディレクトリにあり、4文字の「&lt;b&gt;-shm&lt;/b&gt;」が追加されていることを除いて、データベースファイルと同じ名前です。共有メモリファイルは、WALモードでの実行中にのみ存在します。</target>
        </trans-unit>
        <trans-unit id="6bb4007f1d52b792a142259284926e062c686eaf" translate="yes" xml:space="preserve">
          <source>When optimized for size, the whole SQLite library with everything enabled is &lt;a href=&quot;footprint&quot;&gt;less than 500KiB in size&lt;/a&gt; (as measured on an ix86 using the &quot;size&quot; utility from the GNU compiler suite.) Unneeded features can be disabled at compile-time to further reduce the size of the library to under 300KiB if desired.</source>
          <target state="translated">サイズを最適化すると、すべてが有効になっているSQLiteライブラリ全体のサイズ&lt;a href=&quot;footprint&quot;&gt;が500KiB未満になります&lt;/a&gt;（GNUコンパイラスイートの「サイズ」ユーティリティを使用したix86で測定）。コンパイル時に不要な機能を無効にして、必要に応じて、ライブラリのサイズを300KiB未満にします。</target>
        </trans-unit>
        <trans-unit id="36556333a18e7240b5e2f86d71ec1605e3df5074" translate="yes" xml:space="preserve">
          <source>When porting SQLite to a new operating system, it is usually necessary to completely replace the built-in mutex subsystem with an alternative built around the mutex primitives of the new operating system. This is accomplished by compiling SQLite with the following option:</source>
          <target state="translated">SQLiteを新しいオペレーティングシステムに移植する際には、通常、組み込みのミューテックスサブシステムを新しいオペレーティングシステムのミューテックスプリミティブを中心に構築された代替システムに完全に置き換える必要があります。これは、以下のオプションでSQLiteをコンパイルすることで実現できます。</target>
        </trans-unit>
        <trans-unit id="ef28302f8a0daea79bec53d89c73ea8d20c2af92" translate="yes" xml:space="preserve">
          <source>When processing a &lt;b&gt;DELETE&lt;/b&gt; change, the following conflicts may be detected:</source>
          <target state="translated">&lt;b&gt;DELETE&lt;/b&gt;変更を処理するときに、次の競合が検出される場合があります。</target>
        </trans-unit>
        <trans-unit id="feb3e5a5d3242cd110b456009cbca7b6fb677c07" translate="yes" xml:space="preserve">
          <source>When processing a SELECT (or other) statement, SQLite may retrieve data from database tables in a variety of ways. It may scan through all the records in a table (a full-table scan), scan a contiguous subset of the records in a table based on the rowid index, scan a contiguous subset of the entries in a database &lt;a href=&quot;lang_createtable&quot;&gt;index&lt;/a&gt;, or use a combination of the above strategies in a single scan. The various ways in which SQLite may retrieve data from a table or index are described in detail &lt;a href=&quot;queryplanner#searching&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">SELECT（またはその他の）ステートメントを処理するとき、SQLiteはさまざまな方法でデータベーステーブルからデータを取得します。テーブル内のすべてのレコードをスキャンする（フルテーブルスキャン）、ROWIDインデックスに基づいてテーブル内のレコードの連続するサブセットをスキャンする、データベース&lt;a href=&quot;lang_createtable&quot;&gt;インデックス&lt;/a&gt;内のエントリの連続するサブセットをスキャンする、または組み合わせを使用する上記の戦略の1回のスキャン。SQLiteがテーブルまたはインデックスからデータを取得するさまざまな方法について、&lt;a href=&quot;queryplanner#searching&quot;&gt;ここ&lt;/a&gt;で詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="1e6fe17803083dfa07e4b417bb2b4cf1a4c64242" translate="yes" xml:space="preserve">
          <source>When processing an &lt;b&gt;INSERT&lt;/b&gt; change, the following conflicts can occur:</source>
          <target state="translated">&lt;b&gt;INSERTの&lt;/b&gt;変更を処理するときに、次の競合が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="22eb80162f6ab8bb9c9904d675b35465735f18b1" translate="yes" xml:space="preserve">
          <source>When processing an &lt;b&gt;UPDATE&lt;/b&gt; change, the following conflicts may be detected:</source>
          <target state="translated">&lt;b&gt;UPDATEの&lt;/b&gt;変更を処理するときに、次の競合が検出される場合があります。</target>
        </trans-unit>
        <trans-unit id="96dc4d2d808bddd461eb35740cb2e242c1a91b3e" translate="yes" xml:space="preserve">
          <source>When processing queries that feature more than one token, FTS5 is sometimes able to determine that the query can be answered by inspecting a subset of a large instance-list. FTS3/4 almost always has to traverse entire instance-lists.</source>
          <target state="translated">複数のトークンを特徴とするクエリを処理する場合、FTS5は、大きなインスタンスリストのサブセットを検査することで、そのクエリが回答可能であると判断できることがあります。FTS3/4は、ほとんど常にインスタンスリスト全体をトラバースしなければならない。</target>
        </trans-unit>
        <trans-unit id="b4456c24b4cd85849eb2f816e79572b467a2fc07" translate="yes" xml:space="preserve">
          <source>When query results are sorted by an ORDER BY clause, values with storage class NULL come first, followed by INTEGER and REAL values interspersed in numeric order, followed by TEXT values in collating sequence order, and finally BLOB values in memcmp() order. No storage class conversions occur before the sort.</source>
          <target state="translated">クエリの結果が ORDER BY 節でソートされる場合、ストレージクラスが NULL の値が最初に来て、次に INTEGER および REAL の値が数値順に散在し、次に TEXT の値が照合順序で並び、最後に BLOB の値が memcmp()の順序で並び替えられます。ソートの前にストレージクラスの変換は行われません。</target>
        </trans-unit>
        <trans-unit id="e91e22fc8ff638a8787ffecd5d5f0df9da8787f3" translate="yes" xml:space="preserve">
          <source>When required to</source>
          <target state="translated">必要な場合</target>
        </trans-unit>
        <trans-unit id="78c613e6d682faec6496ee4d9048bbcfd6d7d464" translate="yes" xml:space="preserve">
          <source>When required to append a</source>
          <target state="translated">追加が必要な場合</target>
        </trans-unit>
        <trans-unit id="798519ed2b08664b52737ffba7c81753837b1259" translate="yes" xml:space="preserve">
          <source>When required to append a new database page to the database file, SQLite shall create a new</source>
          <target state="translated">データベースファイルに新しいデータベースページを追加する必要がある場合、SQLiteは新しい</target>
        </trans-unit>
        <trans-unit id="6dcc88fffc3fe69f52028c8e6091eebcfd48e874" translate="yes" xml:space="preserve">
          <source>When required to attempt to detect a</source>
          <target state="translated">を検出しようとすることが要求された場合</target>
        </trans-unit>
        <trans-unit id="82187b34c5d14ea3c6cc853ad766ba3268f5b299" translate="yes" xml:space="preserve">
          <source>When required to end a</source>
          <target state="translated">終了するために必要な場合</target>
        </trans-unit>
        <trans-unit id="baf01cea17946b2cb417992fd85480056f55712b" translate="yes" xml:space="preserve">
          <source>When required to modify the contents of an existing database page that existed and was not a</source>
          <target state="translated">存在していたデータベースページの内容を修正する必要がある場合</target>
        </trans-unit>
        <trans-unit id="ea12960936b78c03e66e4654443a0f13383a7001" translate="yes" xml:space="preserve">
          <source>When required to modify the contents of an existing database page, SQLite shall update the cached version of the database page content stored as part of the</source>
          <target state="translated">既存のデータベースページの内容を変更する必要がある場合、SQLiteは</target>
        </trans-unit>
        <trans-unit id="72b58d5840f56734164db642d70a3df517a5e160" translate="yes" xml:space="preserve">
          <source>When required to open a</source>
          <target state="translated">開く必要がある場合</target>
        </trans-unit>
        <trans-unit id="202f6940a3123823f29cdd85bae8600a952bce22" translate="yes" xml:space="preserve">
          <source>When required to perform</source>
          <target state="translated">必要とされる場合</target>
        </trans-unit>
        <trans-unit id="49e57edc72b2554b07e6deee46ce3f790b869e23" translate="yes" xml:space="preserve">
          <source>When required to purge a</source>
          <target state="translated">パージが必要な場合</target>
        </trans-unit>
        <trans-unit id="96b4b0dc1d589faf2e657c0bc5a3a75b7b82c7c8" translate="yes" xml:space="preserve">
          <source>When required to truncate (remove) a database page that existed and was not a</source>
          <target state="translated">存在していたデータベースページを切り捨てる(削除する)必要がある場合</target>
        </trans-unit>
        <trans-unit id="24c9b9293e0d1ee15b7fdaf8a59c9a8d10fd1c44" translate="yes" xml:space="preserve">
          <source>When required to truncate a database page from the end of the database file, SQLite shall discard the associated</source>
          <target state="translated">データベースファイルの最後からデータベースページを切り詰める必要がある場合、SQLiteは関連する</target>
        </trans-unit>
        <trans-unit id="150a8fe0ea2f86237f4f58257c9a767ee7e2a25a" translate="yes" xml:space="preserve">
          <source>When required to upgrade to an</source>
          <target state="translated">へのアップグレードが必要な場合</target>
        </trans-unit>
        <trans-unit id="fcba2e5b4c05a2548f809c299faee545560dd767" translate="yes" xml:space="preserve">
          <source>When running in shared-cache mode, a database operation may fail with an &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt; error if the required locks on the shared-cache or individual tables within the shared-cache cannot be obtained. See &lt;a href=&quot;sharedcache&quot;&gt;SQLite Shared-Cache Mode&lt;/a&gt; for a description of shared-cache locking. This API may be used to register a callback that SQLite will invoke when the connection currently holding the required lock relinquishes it. This API is only available if the library was compiled with the &lt;a href=&quot;compile#enable_unlock_notify&quot;&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/a&gt; C-preprocessor symbol defined.</source>
          <target state="translated">共有キャッシュモードで実行している場合、共有キャッシュまたは共有キャッシュ内の個々のテーブルに必要なロックを取得できないと、データベース操作が&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt;エラーで失敗することがあります。共有キャッシュロックの説明については、&lt;a href=&quot;sharedcache&quot;&gt;SQLite共有キャッシュモード&lt;/a&gt;を参照してください。このAPIは、必要なロックを現在保持している接続がそれを放棄したときにSQLiteが呼び出すコールバックを登録するために使用できます。このAPIは、ライブラリが&lt;a href=&quot;compile#enable_unlock_notify&quot;&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/a&gt; Cプリプロセッサシンボルを定義してコンパイルされている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="b02906105894d89f6847bc0868bb9a109b4e3e2a" translate="yes" xml:space="preserve">
          <source>When running in shared-cache mode, a database operation may fail with an &lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; error if the required locks on the shared-cache or individual tables within the shared-cache cannot be obtained. See &lt;a href=&quot;../sharedcache&quot;&gt;SQLite Shared-Cache Mode&lt;/a&gt; for a description of shared-cache locking. This API may be used to register a callback that SQLite will invoke when the connection currently holding the required lock relinquishes it. This API is only available if the library was compiled with the &lt;a href=&quot;../compile#enable_unlock_notify&quot;&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/a&gt; C-preprocessor symbol defined.</source>
          <target state="translated">共有キャッシュモードで実行している場合、共有キャッシュまたは共有キャッシュ内の個々のテーブルに必要なロックを取得できないと、データベース操作が&lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt;エラーで失敗することがあります。共有キャッシュロックの説明については、&lt;a href=&quot;../sharedcache&quot;&gt;SQLite共有キャッシュモード&lt;/a&gt;を参照してください。このAPIは、必要なロックを現在保持している接続がそれを放棄したときにSQLiteが呼び出すコールバックを登録するために使用できます。このAPIは、ライブラリが&lt;a href=&quot;../compile#enable_unlock_notify&quot;&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/a&gt; Cプリプロセッサシンボルを定義してコンパイルされている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="2af0cef1a0b15f9849e9b4a326164320a983e665" translate="yes" xml:space="preserve">
          <source>When running on QNX, it is recommended that &lt;a href=&quot;mmap&quot;&gt;memory-mapped I/O&lt;/a&gt; never be used. Furthermore, to use &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, it is recommended that applications employ the &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; in order to use &lt;a href=&quot;wal#noshm&quot;&gt;WAL without shared memory&lt;/a&gt;.</source>
          <target state="translated">QNXで実行する場合は、&lt;a href=&quot;mmap&quot;&gt;メモリマップI / Oを&lt;/a&gt;使用しないことをお勧めします。さらに、&lt;a href=&quot;wal&quot;&gt;WALモード&lt;/a&gt;を使用するには、&lt;a href=&quot;wal#noshm&quot;&gt;共有メモリなしでWAL&lt;/a&gt;を使用するために、アプリケーションで&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;排他ロックモードを&lt;/a&gt;使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="d6885131949093b9f2e26719d9e197b2addf166d" translate="yes" xml:space="preserve">
          <source>When safe append semantics are indicated for a filesystem, SQLite always stores the special value of -1 for the page count in the header of the rollback journal. The -1 page count value tells any process attempting to rollback the journal that the number of pages in the journal should be computed from the journal size. This -1 value is never changed. So that when a commit occurs, we save a single flush operation and a sector write of the first page of the journal file. Furthermore, when a cache spill occurs we no longer need to append a new journal header to the end of the journal; we can simply continue appending new pages to the end of the existing journal.</source>
          <target state="translated">ファイルシステムで安全な追加セマンティクスが指定されている場合、SQLite は常にロールバックジャーナルのヘッダにページ数を表す特別な値 -1 を格納します。ページカウント値 -1 は、ジャーナルをロールバックしようとするプロセスに対して、ジャーナルのページ数をジャーナルサイズから計算する必要があることを伝えます。この -1 の値は決して変更されません。そのため、コミットが発生したときには、単一のフラッシュ操作とジャーナルファイルの最初のページのセクタ書き込みを保存します。さらに、キャッシュこぼれが発生した場合、ジャーナルの最後に新しいジャーナルヘッダを追加する必要はありません。</target>
        </trans-unit>
        <trans-unit id="c52209ae5a29283cfe5cb3dad1ce0ecd4b45279f" translate="yes" xml:space="preserve">
          <source>When sector writes are atomic and the page size of a database is the same as a sector size, and when there is a database change that only touches a single database page, then SQLite skips the whole journaling and syncing process and simply writes the modified page directly into the database file. The change counter in the first page of the database file is modified separately since no harm is done if power is lost before the change counter can be updated.</source>
          <target state="translated">セクタ書き込みがアトミックで、データベースのページサイズがセクタサイズと同じで、データベースの変更が単一のデータベースページにしか触れない場合、SQLite はジャーナリングと同期のプロセスをすべてスキップして、変更されたページをデータベースファイルに直接書き込むだけで済むようになります。データベースファイルの最初のページの変更カウンタは、変更カウンタが更新される前に電力が失われても害はないので、別々に変更されます。</target>
        </trans-unit>
        <trans-unit id="340896b0a1241236bc1bf669ed9b704188faab52" translate="yes" xml:space="preserve">
          <source>When selecting the order of tables in a join, SQLite uses an efficient polynomial-time algorithm. Because of this, SQLite is able to plan queries with 50- or 60-way joins in a matter of microseconds</source>
          <target state="translated">結合のテーブルの順序を選択する際に、SQLite は効率的な多項式時間アルゴリズムを使用します。このため、SQLite は 50 回または 60 回の結合を用いたクエリを数マイクロ秒のうちに計画することができます。</target>
        </trans-unit>
        <trans-unit id="1aebe3c7de990f7af4ad0100f2e7e450c502bae1" translate="yes" xml:space="preserve">
          <source>When set to the value &quot;fts3&quot;, the matchinfo option reduces the amount of information stored by FTS4 with the consequence that the &quot;l&quot; option of &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; is no longer available.</source>
          <target state="translated">値「fts3」に設定すると、matchinfoオプションは、FTS4によって格納される情報の量を減らし、その結果、&lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo（）の&lt;/a&gt;「l」オプションは使用できなくなります。</target>
        </trans-unit>
        <trans-unit id="637783b2ffcae0b4a42a6035522c7dbcf1ec705e" translate="yes" xml:space="preserve">
          <source>When specifying insert mode, you have to give an extra argument which is the name of the table to be inserted into. For example:</source>
          <target state="translated">挿入モードを指定する際には、挿入するテーブルの名前を追加引数として指定しなければなりません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="1b258d1afb6dda622a0743a2a73308bdb7445718" translate="yes" xml:space="preserve">
          <source>When sqlite3_backup_step() has returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, or when the application wishes to abandon the backup operation, the application should destroy the &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; by passing it to sqlite3_backup_finish(). The sqlite3_backup_finish() interfaces releases all resources associated with the &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object. If sqlite3_backup_step() has not yet returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, then any active write-transaction on the destination database is rolled back. The &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object is invalid and may not be used following a call to sqlite3_backup_finish().</source>
          <target state="translated">sqlite3_backup_step（）が&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;を返した場合、またはアプリケーションがバックアップ操作を放棄したい場合、アプリケーションはsqlite3_backup_finish（）に渡して&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt;を破棄する必要があります。 sqlite3_backup_finish（）インターフェイスは、&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt;オブジェクトに関連付けられているすべてのリソースを解放します。 sqlite3_backup_step（）はまだ戻っていない場合は&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONEを&lt;/a&gt;、接続先データベース上の任意のアクティブライト・トランザクションがロールバックされます。&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt;オブジェクト）が無効であるとsqlite3_backup_finishの呼び出し（以下使用することはできません。</target>
        </trans-unit>
        <trans-unit id="ff3c33367e6881dcf5fe599ab4cc7d4d94774505" translate="yes" xml:space="preserve">
          <source>When sqlite3_backup_step() has returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, or when the application wishes to abandon the backup operation, the application should destroy the &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; by passing it to sqlite3_backup_finish(). The sqlite3_backup_finish() interfaces releases all resources associated with the &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object. If sqlite3_backup_step() has not yet returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, then any active write-transaction on the destination database is rolled back. The &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object is invalid and may not be used following a call to sqlite3_backup_finish().</source>
          <target state="translated">sqlite3_backup_step（）が&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;を返した場合、またはアプリケーションがバックアップ操作を放棄したい場合、アプリケーションはsqlite3_backup_finish（）に渡して&lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt;を破棄する必要があります。 sqlite3_backup_finish（）インターフェイスは、&lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt;オブジェクトに関連付けられているすべてのリソースを解放します。 sqlite3_backup_step（）はまだ戻っていない場合は&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONEを&lt;/a&gt;、接続先データベース上の任意のアクティブライト・トランザクションがロールバックされます。&lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt;オブジェクト）が無効であるとsqlite3_backup_finishの呼び出し（以下使用することはできません。</target>
        </trans-unit>
        <trans-unit id="f11c5f277ff9a9bea3d1538e42d008cd96e6371c" translate="yes" xml:space="preserve">
          <source>When synchronous is FULL (2), the SQLite database engine will use the xSync method of the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to ensure that all content is safely written to the disk surface prior to continuing. This ensures that an operating system crash or power failure will not corrupt the database. FULL synchronous is very safe, but it is also slower. FULL is the most commonly used synchronous setting when not in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">同期がFULL（2）の場合、SQLiteデータベースエンジンは&lt;a href=&quot;vfs&quot;&gt;VFSの&lt;/a&gt; xSyncメソッドを使用して、続行する前にすべてのコンテンツがディスクサーフェスに安全に書き込まれるようにします。これにより、オペレーティングシステムのクラッシュや停電によってデータベースが破損することがなくなります。完全同期は非常に安全ですが、速度も遅くなります。FULLは、&lt;a href=&quot;wal&quot;&gt;WALモードで&lt;/a&gt;ないときに最も一般的に使用される同期設定です。</target>
        </trans-unit>
        <trans-unit id="43aa9a49bc45ba6ec32647dc1c08a8d6748123c3" translate="yes" xml:space="preserve">
          <source>When synchronous is NORMAL (1), the SQLite database engine will still sync at the most critical moments, but less often than in FULL mode. There is a very small (though non-zero) chance that a power failure at just the wrong time could corrupt the database in &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt;=DELETE on an older filesystem. &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; is safe from corruption with synchronous=NORMAL, and probably DELETE mode is safe too on modern filesystems. WAL mode is always consistent with synchronous=NORMAL, but WAL mode does lose durability. A transaction committed in WAL mode with synchronous=NORMAL might roll back following a power loss or system crash. Transactions are durable across application crashes regardless of the synchronous setting or journal mode. The synchronous=NORMAL setting is a good choice for most applications running in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">同期がNORMAL（1）の場合でも、SQLiteデータベースエンジンは最も重要な瞬間に同期しますが、FULLモードの場合ほど頻度は低くなります。非常に小さい（ゼロではありません）可能性があり、誤った時間に電源障害が発生すると、古いファイルシステムの&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; = DELETEでデータベースが破損する可能性があります。&lt;a href=&quot;wal&quot;&gt;WALモード&lt;/a&gt;Synchronous = NORMALを使用すると、破損から安全に保護されます。また、現代のファイルシステムでは、おそらくDELETEモードも安全です。 WALモードは常にSynchronous = NORMALと一貫していますが、WALモードは持続性を失います。 Synchronous = NORMALを指定したWALモードでコミットされたトランザクションは、停電またはシステムクラッシュの後にロールバックする場合があります。トランザクションは、同期設定やジャーナルモードに関係なく、アプリケーションがクラッシュしても耐久性があります。 Synchronous = NORMAL設定は、&lt;a href=&quot;wal&quot;&gt;WALモードで&lt;/a&gt;実行されているほとんどのアプリケーションに適しています。</target>
        </trans-unit>
        <trans-unit id="1221ac9ca537e39eaf7a9c102f123b50e4ccafe2" translate="yes" xml:space="preserve">
          <source>When the &quot;write_version&quot; value of the database header is larger than what the library understands, make the database read-only instead of unreadable.</source>
          <target state="translated">データベースヘッダの &quot;write_version &quot;の値がライブラリが理解できる値よりも大きい場合、データベースを読めないのではなく、読み取り専用にする。</target>
        </trans-unit>
        <trans-unit id="14c5bdcdfec2d165a19969db87c59339f98d6d50" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;#eval&quot;&gt;eval method&lt;/a&gt; sees a named SQL parameter such as &quot;$abc&quot; or &quot;:def&quot; or &quot;@ghi&quot; in an SQL statement, it tries to look up a TCL variable with the same name, and it binds the value of that TCL variable to the SQL parameter. If no such TCL variable exists, the default behavior is to bind an SQL NULL value to the parameter. However, if a bind_fallback proc is specified, then that proc is invoked with the name of the SQL parameter and the return value from the proc is bound to the SQL parameter. Or if the proc returns an error, then the SQL statement aborts with that error. If the proc returns with some code other than TCL_OK or TCL_ERROR, then the SQL parameter is bound to NULL, as it would be by default.</source>
          <target state="translated">とき&lt;a href=&quot;#eval&quot;&gt;にevalメソッドは&lt;/a&gt;「：DEF」「$ ABC」やなどのパラメータ名前のSQLを見て、SQL文または「@ghi」、それは同じ名前のTCL変数を検索しようとし、その値をバインドTCL変数からSQLパラメータへ。そのようなTCL変数が存在しない場合、デフォルトの動作では、SQL NULL値がパラメーターにバインドされます。ただし、bind_fallbackプロシージャが指定されている場合、そのプロシージャはSQLパラメータの名前で呼び出され、プロシージャからの戻り値はSQLパラメータにバインドされます。または、プロシージャがエラーを返した場合、SQLステートメントはそのエラーで中止されます。プロシージャがTCL_OKまたはTCL_ERROR以外のコードで戻る場合、SQLパラメータはデフォルトのようにNULLにバインドされています。</target>
        </trans-unit>
        <trans-unit id="e9681f846afb85497f8c3e1e346505a1d05e091c" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;min()&lt;/a&gt; or &lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;max()&lt;/a&gt; aggregate functions are used in an aggregate query, all bare columns in the result set take values from the input row which also contains the minimum or maximum. So in the query above, the value of the &quot;b&quot; column in the output will be the value of the &quot;b&quot; column in the input row that has the largest &quot;c&quot; value. There is still an ambiguity if two or more of the input rows have the same minimum or maximum value or if the query contains more than one min() and/or max() aggregate function. Only the built-in &lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;min()&lt;/a&gt; and &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;max()&lt;/a&gt; functions work this way.</source>
          <target state="translated">とき&lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;分（）&lt;/a&gt;または&lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;MAX（）&lt;/a&gt;集計関数が集計クエリで使用され、また、最小値または最大値を含む入力行から結果セットテイク値内のすべての裸の列。したがって、上記のクエリでは、出力の「b」列の値は、最大の「c」値を持つ入力行の「b」列の値になります。 2つ以上の入力行の最小値または最大値が同じである場合、またはクエリに複数のmin（）やmax（）集約関数が含まれている場合でも、あいまいさが残ります。組み込みの&lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;min（）&lt;/a&gt;および&lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;max（）&lt;/a&gt;関数のみがこの方法で機能します。</target>
        </trans-unit>
        <trans-unit id="56141e1c0fb6b7c512062b7753a9277ae3973fa7" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statement to which the UPSERT is attached takes its values from a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement, there is a potential parsing ambiguity. The parser might not be able to tell if the &quot;ON&quot; keyword is introducing the UPSERT or if it is the ON clause of a join. To work around this, the SELECT statement should always include a WHERE clause, even if that WHERE clause is just &quot;WHERE true&quot;.</source>
          <target state="translated">UPSERTがアタッチされている&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;ステートメントがその値を&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントから取得する場合、解析のあいまいさが発生する可能性があります。パーサーは、「ON」キーワードがUPSERTを導入しているのか、それが結合のON句であるのかを判別できない場合があります。これを回避するには、たとえWHERE句が &quot;WHERE true&quot;であっても、SELECTステートメントには常にWHERE句を含める必要があります。</target>
        </trans-unit>
        <trans-unit id="9d27fd39dc19689d64d7d12f5a355d4c7bb83355" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement that implements a &lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; or FROM-clause subquery is a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt; then the affinity of each supposed column of the VIEW or subquery will be the affinity of the corresponding result column for one of the individual SELECT statements that make up the compound. However, it is indeterminate which of the SELECT statements will be used to determine affinity. Different constituent SELECT statements might be used to determine affinity at different times during query evaluation. Best practice is to avoid mixing affinities in a compound SELECT.</source>
          <target state="translated">とき&lt;a href=&quot;lang_select&quot;&gt;のSELECT&lt;/a&gt;文でその実装&lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt;またはFROM句のサブクエリである&lt;a href=&quot;lang_select#compound&quot;&gt;化合物は、SELECT&lt;/a&gt;、その後VIEWまたは副問合せの各はず列の親和性は、化合物を構成する個々のSELECTステートメントのいずれかに該当する結果列の親和性になります。ただし、どのSELECTステートメントを使用してアフィニティを決定するかは不確定です。クエリの評価中のさまざまな時点でアフィニティを決定するために、異なる構成SELECTステートメントが使用される場合があります。ベストプラクティスは、複合SELECTでアフィニティが混在しないようにすることです。</target>
        </trans-unit>
        <trans-unit id="06ddddedda26385f60e680a5388eae9aa1b1f989" translate="yes" xml:space="preserve">
          <source>When the D parameter is not NULL, that means that ownership of the pointer is being transferred to SQLite. SQLite will take responsibility for freeing resources associated with the pointer when it has finished using the pointer. If the D parameter is NULL, that means that ownership of the pointer remains with the caller and the caller is responsible for disposing of the pointer.</source>
          <target state="translated">DパラメータがNULLでない場合は、ポインタの所有権がSQLiteに移っていることを意味します。SQLite は、ポインタの使用が終了した後にポインタに関連付けられたリソースを解放する責任を負います。D パラメータが NULL の場合は、ポインタの所有権は呼び出し元にあり、ポインタを破棄する責任は呼び出し元にあることを意味します。</target>
        </trans-unit>
        <trans-unit id="821f9322e2541019ba56eda61e1f81487c5db2ed" translate="yes" xml:space="preserve">
          <source>When the EXPLAIN keyword appears by itself it causes the statement to behave as a query that returns the sequence of &lt;a href=&quot;opcode&quot;&gt;virtual machine instructions&lt;/a&gt; it would have used to execute the command had the EXPLAIN keyword not been present. When the EXPLAIN QUERY PLAN phrase appears, the statement returns high-level information regarding the query plan that would have been used.</source>
          <target state="translated">EXPLAINキーワードが単独で表示されると、ステートメントは、EXPLAINキーワードが存在しない場合にコマンドを実行するために使用した一連の&lt;a href=&quot;opcode&quot;&gt;仮想マシン命令&lt;/a&gt;を返すクエリとして動作します。EXPLAIN QUERY PLAN句が現れると、ステートメントは、使用されていたであろうクエリプランに関する高レベルの情報を返します。</target>
        </trans-unit>
        <trans-unit id="0322a186c7875e9599006050d189bbd4680c31ba" translate="yes" xml:space="preserve">
          <source>When the ORDER BY clause is omitted from the recursive-select, the queue behaves as a FIFO, which results in a breadth-first search.</source>
          <target state="translated">再帰的選択からORDER BY句が省略された場合、キューはFIFOのように振る舞い、その結果、幅優先の検索が行われます。</target>
        </trans-unit>
        <trans-unit id="6f6a426144bea68a6a8caf2439e46959412cc8bf" translate="yes" xml:space="preserve">
          <source>When the PRAGMA vdbe_trace=ON is set, correctly print the P3 operand value when it is a pointer to a structure rather than a pointer to a string.</source>
          <target state="translated">PRAGMA vdbe_trace=ONが設定されている場合、P3オペランドの値が文字列へのポインタではなく構造体へのポインタである場合に正しく表示するようにしました。</target>
        </trans-unit>
        <trans-unit id="de58aafb2b793ff0f7f439bee5ca0476571bc42c" translate="yes" xml:space="preserve">
          <source>When the Query Planner Stability Guarantee (QPSG) is enabled SQLite will always pick the same query plan for any given SQL statement as long as:</source>
          <target state="translated">クエリプランナー安定性保証 (QPSG)が有効になっている場合、SQLite は、与えられた SQL 文がある限り、常に同じクエリプランを選択します。</target>
        </trans-unit>
        <trans-unit id="ea89f7d473effa3c1f787520608ed6a1d3dd75bc" translate="yes" xml:space="preserve">
          <source>When the REPLACE conflict resolution strategy deletes rows in order to satisfy a constraint, &lt;a href=&quot;lang_createtrigger&quot;&gt;delete triggers&lt;/a&gt; fire if and only if &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;recursive triggers&lt;/a&gt; are enabled.</source>
          <target state="translated">REPLACE競合解決戦略が制約を満たすために行を&lt;a href=&quot;lang_createtrigger&quot;&gt;削除する&lt;/a&gt;場合、&lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;再帰トリガー&lt;/a&gt;が有効な場合にのみ、削除トリガーが起動します。</target>
        </trans-unit>
        <trans-unit id="4ca0d858dd9858ff95b9e784a094d5524fe9f00c" translate="yes" xml:space="preserve">
          <source>When the SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION compile-time option is activated, SQLite will suppress &quot;unknown function&quot; errors when running an &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; or &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;. Instead of throwing an error, SQLite will insert a substitute no-op function named &quot;unknown()&quot;. The substitution of &quot;unknown()&quot; in place of unrecognized functions only occurs on &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; and &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;, not on ordinary statements.</source>
          <target state="translated">SQLITE_ENABLE_UNKNOWN_SQL_FUNCTIONコンパイル時オプションがアクティブになっていると、SQLiteは&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;または&lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLANの&lt;/a&gt;実行時に「不明な関数」エラーを抑制します。エラーをスローする代わりに、SQLiteは「unknown（）」という名前の代替no-op関数を挿入します。認識されない関数の代わりの &quot;unknown（）&quot;の置換は、通常のステートメントではなく、&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;および&lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;でのみ発生します。</target>
        </trans-unit>
        <trans-unit id="18d1211c78f050ab2271d9386344a3bea2c6f673" translate="yes" xml:space="preserve">
          <source>When the SQLITE_SYNC_DATAONLY flag is used, it means that the sync operation only needs to flush data to mass storage. Inode information need not be flushed. If the lower four bits of the flag equal SQLITE_SYNC_NORMAL, that means to use normal fsync() semantics. If the lower four bits equal SQLITE_SYNC_FULL, that means to use Mac OS X style fullsync instead of fsync().</source>
          <target state="translated">SQLITE_SYNC_DATAONLY フラグが使用されている場合、同期操作はデータをマスストレージにフラッシュする必要があるだけであることを意味します。ノード情報はフラッシュされる必要はありません。フラグの下位 4 ビットが SQLITE_SYNC_NORMAL に等しい場合は、通常の fsync()セマンティクスを使用することを意味します。下位 4 ビットが SQLITE_SYNC_FULL に等しい場合は、fsync()の代わりに Mac OS X スタイルの fullsync を使用することを意味します。</target>
        </trans-unit>
        <trans-unit id="985e39e22f124ec3b4d15128274a9355a9afbb19" translate="yes" xml:space="preserve">
          <source>When the WHERE is omitted from a DELETE statement and the table being deleted has no triggers, SQLite uses an optimization to erase the entire table content without having to visit each row of the table individually. This &quot;truncate&quot; optimization makes the delete run much faster. Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_5.html&quot;&gt;version 3.6.5&lt;/a&gt; (2008-11-12), the truncate optimization also meant that the &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; and &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interfaces and the &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes pragma&lt;/a&gt; will not actually return the number of deleted rows. That problem has been fixed as of &lt;a href=&quot;https://sqlite.org/releaselog/3_6_5.html&quot;&gt;version 3.6.5&lt;/a&gt; (2008-11-12).</source>
          <target state="translated">DELETEステートメントからWHEREが省略され、削除されるテーブルにトリガーがない場合、SQLiteは最適化を使用して、テーブルの各行に個別にアクセスすることなくテーブルの内容全体を消去します。この「切り捨て」最適化により、削除の実行がはるかに速くなります。 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_5.html&quot;&gt;バージョン3.6.5&lt;/a&gt;（2008-11-12）より前では、トランケートの最適化により、&lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes（）&lt;/a&gt;および&lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt;インターフェースと&lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changesプラグマ&lt;/a&gt;は、実際には削除された行の数を返しませんでした。この問題は、&lt;a href=&quot;https://sqlite.org/releaselog/3_6_5.html&quot;&gt;バージョン3.6.5&lt;/a&gt;（2008-11-12）で修正されています。</target>
        </trans-unit>
        <trans-unit id="ed1319f0bc1a6521bcf2196280e7316235700141" translate="yes" xml:space="preserve">
          <source>When the above CREATE VIRTUAL TABLE statement is executed, swarmvtab binds the text value &quot;/home/user/app/databases/&quot; to the :dir parameter of the SQL statement before executing it.</source>
          <target state="translated">上記のCREATE VIRTUAL TABLE文が実行されると、swarmvtabはSQL文を実行する前にテキスト値「/home/user/app/databases/」をSQL文の:dirパラメータにバインドします。</target>
        </trans-unit>
        <trans-unit id="af84afd9d831ba7532e3be1008b7a2fa2d6de72c" translate="yes" xml:space="preserve">
          <source>When the auto-vacuum mode is 1 or &quot;full&quot;, the freelist pages are moved to the end of the database file and the database file is truncated to remove the freelist pages at every transaction commit. Note, however, that auto-vacuum only truncates the freelist pages from the file. Auto-vacuum does not defragment the database nor repack individual database pages the way that the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command does. In fact, because it moves pages around within the file, auto-vacuum can actually make fragmentation worse.</source>
          <target state="translated">自動バキュームモードが1または「フル」の場合、フリーリストページはデータベースファイルの最後に移動され、トランザクションのコミットごとにデータベースファイルがトランケートされてフリーリストページが削除されます。ただし、自動バキュームではファイルからフリーリストページのみが切り捨てられることに注意してください。自動バキュームは、データベースを最適化したり、&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;コマンドのように個々のデータベースページを再パックしたりしません。実際、ファイル内でページを移動するため、自動バキュームは実際に断片化を悪化させる可能性があります。</target>
        </trans-unit>
        <trans-unit id="ef4d832eb7039ef85ce7ded8003003dd3cc72641" translate="yes" xml:space="preserve">
          <source>When the auto_vacuum pragma is invoked with no arguments, it returns the current auto_vacuum mode.</source>
          <target state="translated">auto_vacuum pragmaが引数なしで呼び出された場合、現在のauto_vacuumモードを返します。</target>
        </trans-unit>
        <trans-unit id="f2ce457b213b80c33d7ab3d10e7347a9c292b2e3" translate="yes" xml:space="preserve">
          <source>When the callback is invoked, the first argument passed is a copy of the second argument to sqlite3_collation_needed() or sqlite3_collation_needed16(). The second argument is the database connection. The third argument is one of &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;, indicating the most desirable form of the collation sequence function required. The fourth parameter is the name of the required collation sequence.</source>
          <target state="translated">コールバックが呼び出されると、渡される最初の引数はsqlite3_collat​​ion_needed（）またはsqlite3_collat​​ion_needed16（）への2番目の引数のコピーです。2番目の引数はデータベース接続です。3番目の引数は、&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;、&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;、または&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LEの&lt;/a&gt;いずれかであり、必要な照合シーケンス関数の最も望ましい形式を示します。4番目のパラメーターは、必要な照合シーケンスの名前です。</target>
        </trans-unit>
        <trans-unit id="7ee3c7dd196b6cbe2c4c2e3d7d3e7a9d7a6a2b67" translate="yes" xml:space="preserve">
          <source>When the callback is invoked, the first argument passed is a copy of the second argument to sqlite3_collation_needed() or sqlite3_collation_needed16(). The second argument is the database connection. The third argument is one of &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;, indicating the most desirable form of the collation sequence function required. The fourth parameter is the name of the required collation sequence.</source>
          <target state="translated">コールバックが呼び出されると、渡される最初の引数はsqlite3_collat​​ion_needed（）またはsqlite3_collat​​ion_needed16（）への2番目の引数のコピーです。2番目の引数はデータベース接続です。3番目の引数は、&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;、&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;、または&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LEの&lt;/a&gt;いずれかであり、必要な照合シーケンス関数の最も望ましい形式を示します。4番目のパラメーターは、必要な照合シーケンスの名前です。</target>
        </trans-unit>
        <trans-unit id="f0027db967a591c65d48dbd0afc84a797aef3887" translate="yes" xml:space="preserve">
          <source>When the callback returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;, that means the operation requested is ok. When the callback returns &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_DENY&lt;/a&gt;, the &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or equivalent call that triggered the authorizer will fail with an error message explaining that access is denied.</source>
          <target state="translated">コールバックが&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OKを&lt;/a&gt;返すと、要求された操作は正常であることを意味します。コールバックが&lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_DENYを&lt;/a&gt;返すと、承認者をトリガーした&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;または同等の呼び出しが失敗し、アクセスが拒否されたことを説明するエラーメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="1bae5c6c86ffd7028029909efdc71f4e4f816633" translate="yes" xml:space="preserve">
          <source>When the callback returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;, that means the operation requested is ok. When the callback returns &lt;a href=&quot;c_deny&quot;&gt;SQLITE_DENY&lt;/a&gt;, the &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or equivalent call that triggered the authorizer will fail with an error message explaining that access is denied.</source>
          <target state="translated">コールバックが&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OKを&lt;/a&gt;返すと、要求された操作は正常であることを意味します。コールバックが&lt;a href=&quot;c_deny&quot;&gt;SQLITE_DENYを&lt;/a&gt;返すと、承認者をトリガーした&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;または同等の呼び出しが失敗し、アクセスが拒否されたことを説明するエラーメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="2fc4782b077cfef78fd1da131f206927c4488a10" translate="yes" xml:space="preserve">
          <source>When the command-line shell and the core SQLite library are both compiled with &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; and SQLITE_ENABLE_SELECTTRACE and SQLITE_ENABLE_WHERETRACE, then the shell has two commands used to turn on debugging facilities for the most intricate parts of the code generator - the logic dealing with SELECT statements and WHERE clauses, respectively. The &quot;.selecttrace&quot; and &quot;.wheretrace&quot; commands each take a numeric argument which can be expressed in hexadecimal. Each bit turns on various parts of debugging. Values of &quot;0xfff&quot; and &quot;0xff&quot; are commonly used. Use an argument of &quot;0&quot; to turn all tracing output back off.</source>
          <target state="translated">コマンドラインシェルとコアSQLiteライブラリの両方が&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;とSQLITE_ENABLE_SELECTTRACEおよびSQLITE_ENABLE_WHERETRACEでコンパイルされている場合、シェルには2つのコマンドがあり、コードジェネレーターの最も複雑な部分（SELECTステートメントを処理するロジックとそれぞれWHERE句。 「.selecttrace」および「.wheretrace」コマンドはそれぞれ、16​​進数で表すことができる数値引数を取ります。各ビットは、デバッグのさまざまな部分をオンにします。 「0xfff」と「0xff」の値は一般的に使用されます。引数「0」を使用して、すべてのトレース出力をオフに戻します。</target>
        </trans-unit>
        <trans-unit id="b723658445ef923fc3e6ed08d931b577b65bc748" translate="yes" xml:space="preserve">
          <source>When the commit hook callback routine returns zero, the &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt; operation is allowed to continue normally. If the commit hook returns non-zero, then the &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt; is converted into a &lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;. The rollback hook is invoked on a rollback that results from a commit hook returning non-zero, just as it would be with any other rollback.</source>
          <target state="translated">コミットフックコールバックルーチンがゼロを返すと、&lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt;操作は正常に続行できます。 commitフックがゼロ以外の値を返した場合、&lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt;は&lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACKに&lt;/a&gt;変換されます。ロールバックフックは、他のロールバックの場合と同様に、コミットフックがゼロ以外の値を返した結果のロールバックで呼び出されます。</target>
        </trans-unit>
        <trans-unit id="cc0bc375382d425cd0a289c0d31fef27fb453ac2" translate="yes" xml:space="preserve">
          <source>When the commit hook callback routine returns zero, the &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; operation is allowed to continue normally. If the commit hook returns non-zero, then the &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; is converted into a &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;. The rollback hook is invoked on a rollback that results from a commit hook returning non-zero, just as it would be with any other rollback.</source>
          <target state="translated">コミットフックコールバックルーチンがゼロを返すと、&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;操作は正常に続行できます。 commitフックがゼロ以外の値を返した場合、&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;は&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACKに&lt;/a&gt;変換されます。ロールバックフックは、他のロールバックの場合と同様に、コミットフックがゼロ以外の値を返した結果のロールバックで呼び出されます。</target>
        </trans-unit>
        <trans-unit id="ebd93d5d1aa49a1f19ce4e8d40b4dcf35920ce66" translate="yes" xml:space="preserve">
          <source>When the defer_foreign_keys &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; is on, enforcement of all &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt; is delayed until the outermost transaction is committed. The defer_foreign_keys pragma defaults to OFF so that foreign key constraints are only deferred if they are created as &quot;DEFERRABLE INITIALLY DEFERRED&quot;. The defer_foreign_keys pragma is automatically switched off at each COMMIT or ROLLBACK. Hence, the defer_foreign_keys pragma must be separately enabled for each transaction. This pragma is only meaningful if foreign key constraints are enabled, of course.</source>
          <target state="translated">defer_foreign_keys &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;がオンの場合、すべての&lt;a href=&quot;foreignkeys&quot;&gt;外部キー制約の適用&lt;/a&gt;は、最も外側のトランザクションがコミットされるまで遅延されます。 defer_foreign_keysプラグマのデフォルトはOFFなので、外部キー制約は、「DEFERRABLE INITIALLY DEFERRED」として作成された場合にのみ遅延されます。 defer_foreign_keysプラグマは、COMMITまたはROLLBACKのたびに自動的にオフになります。したがって、defer_foreign_keysプラグマは、トランザクションごとに個別に有効にする必要があります。もちろん、このプラグマは、外部キー制約が有効になっている場合にのみ意味があります。</target>
        </trans-unit>
        <trans-unit id="f4cc14d79785a0eab23a6d9f7db6c91e125bbb70" translate="yes" xml:space="preserve">
          <source>When the end-user executes a DML or DDL SQL statement to modify the database schema or content, SQLite is required to update the database file image to reflect the new database state. This involves modifying the content of, appending or truncating one of more database file pages. Instead of modifying the database file directly using the VFS interface, changes are first buffered within the</source>
          <target state="translated">エンドユーザーが DML または DDL SQL 文を実行してデータベースのスキーマやコンテンツを変更した場合、SQLite は新しいデータベースの状態を反映させるためにデータベースファイルイメージを更新する必要があります。これには、複数のデータベースファイルページの内容を変更したり、追加したり、切り詰めたりすることが含まれます。VFS インターフェイスを使用して直接データベースファイルを変更する代わりに、変更は最初に</target>
        </trans-unit>
        <trans-unit id="e72b791ecc5f4b31b8f87177039bb7c97a3857b6" translate="yes" xml:space="preserve">
          <source>When the languageid option is present, it specifies the name of another &lt;a href=&quot;vtab#hiddencol&quot;&gt;hidden column&lt;/a&gt; that is added to the FTS4 table and which is used to specify the language stored in each row of the FTS4 table. The name of the languageid hidden column must be distinct from all other column names in the FTS4 table. Example:</source>
          <target state="translated">languageidオプションが存在する場合、FTS4テーブルに追加され、FTS4テーブルの各行に格納されている言語を指定するために使用される別の&lt;a href=&quot;vtab#hiddencol&quot;&gt;非表示列の&lt;/a&gt;名前を指定します。languageid非表示列の名前は、FTS4テーブルの他のすべての列名とは異なる必要があります。例：</target>
        </trans-unit>
        <trans-unit id="b1e38f0c1dabd3714310eefb8d8a6cff4de89d44" translate="yes" xml:space="preserve">
          <source>When the languageid option is used, SQLite invokes the xLanguageid() on the sqlite3_tokenizer_module object immediately after the object is created in order to pass in the language id that the tokenizer should use. The xLanguageid() method will never be called more than once for any single tokenizer object. The fact that different languages might be tokenized differently is one reason why no single FTS query can return rows with different languageid values.</source>
          <target state="translated">languageidオプションが使用されている場合、SQLiteはオブジェクトが作成された直後にsqlite3_tokenizer_moduleオブジェクト上でxLanguageid()を呼び出し、トークン化に使用する言語IDを渡します。xLanguageid()メソッドは、一つのトークナイザーオブジェクトに対して複数回呼ばれることはありません。異なる言語が異なるトークン化されている可能性があるという事実は、 単一の FTS クエリが異なる言語 ID 値を持つ行を返すことができない理由の一つです。</target>
        </trans-unit>
        <trans-unit id="9aa0a1cde451597b6df45b6c556052ff5eb9c927" translate="yes" xml:space="preserve">
          <source>When the last connection to a particular database is closing, that connection will acquire an exclusive lock for a short time while it cleans up the WAL and shared-memory files. If a second database tries to open and query the database while the first connection is still in the middle of its cleanup process, the second connection might get an &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error.</source>
          <target state="translated">特定のデータベースへの最後の接続が閉じているとき、その接続は、WALと共有メモリファイルをクリーンアップする間、短時間排他ロックを取得します。最初の接続がクリーンアッププロセスの途中であるときに、2番目のデータベースがデータベースを開いてクエリしようとすると、2番目の接続で&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;エラーが発生する場合があります。</target>
        </trans-unit>
        <trans-unit id="721a001d639a4fa0bf082ab41646b624fe82e4a7" translate="yes" xml:space="preserve">
          <source>When the legacy_file_format pragma is issued with no argument, it returns the setting of the flag. This pragma does &lt;u&gt;not&lt;/u&gt; tell which file format the current database is using; it tells what format will be used by any newly created databases.</source>
          <target state="translated">引数なしでlegacy_file_formatプラグマを発行すると、フラグの設定が返されます。このプラグマは、現在のデータベースが使用しているファイル形式を通知しませ&lt;u&gt;ん&lt;/u&gt;。新しく作成されたデータベースで使用される形式を通知します。</target>
        </trans-unit>
        <trans-unit id="6a4f25a9dc00e5fa108cea204a933cd9b0d930ee" translate="yes" xml:space="preserve">
          <source>When the locking_mode pragma specifies a particular database, for example:</source>
          <target state="translated">locking_mode pragmaが特定のデータベースを指定している場合、例えば。</target>
        </trans-unit>
        <trans-unit id="65958bd909cd29c71d7062800a7ff7cb762631b5" translate="yes" xml:space="preserve">
          <source>When the name of the database file handed to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; or to &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; is an empty string, then a new temporary file is created to hold the database.</source>
          <target state="translated">&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;または&lt;a href=&quot;lang_attach&quot;&gt;ATTACHに&lt;/a&gt;渡されるデータベースファイルの名前が空の文字列である場合、データベースを保持するための新しい一時ファイルが作成されます。</target>
        </trans-unit>
        <trans-unit id="a5261e01bfb3de59bf05674e0d1d120422019175" translate="yes" xml:space="preserve">
          <source>When the original content of a database page is written into the rollback journal (as shown in &lt;a href=&quot;#section_3_5&quot;&gt;section 3.5&lt;/a&gt;), SQLite always writes a complete sector of data, even if the page size of the database is smaller than the sector size. Historically, the sector size in SQLite has been hard coded to 512 bytes and since the minimum page size is also 512 bytes, this has never been an issue. But beginning with SQLite version 3.3.14, it is possible for SQLite to use mass storage devices with a sector size larger than 512 bytes. So, beginning with version 3.3.14, whenever any page within a sector is written into the journal file, all pages in that same sector are stored with it.</source>
          <target state="translated">データベースページの元のコンテンツがロールバックジャーナルに書き込まれると（&lt;a href=&quot;#section_3_5&quot;&gt;セクション3.5に&lt;/a&gt;示すように）、データベースのページサイズがセクターサイズよりも小さい場合でも、SQLiteは常にデータの完全なセクターを書き込みます。歴史的に、SQLiteのセクターサイズは512バイトにハードコーディングされており、最小ページサイズも512バイトであるため、これが問題になることはありません。ただし、SQLiteバージョン3.3.14以降では、SQLiteは512バイトを超えるセクターサイズの大容量記憶装置を使用できます。したがって、バージョン3.3.14以降、セクター内のページがジャーナルファイルに書き込まれると、同じセクター内のすべてのページがジャーナルファイルと共に保存されます。</target>
        </trans-unit>
        <trans-unit id="24eb3cec7d166e89084624729f4f076ba57699a6" translate="yes" xml:space="preserve">
          <source>When the payload of a b-tree cell is too large for the b-tree page, the surplus is spilled onto overflow pages. Overflow pages form a linked list. The first four bytes of each overflow page are a big-endian integer which is the page number of the next page in the chain, or zero for the final page in the chain. The fifth byte through the last usable byte are used to hold overflow content.</source>
          <target state="translated">b-treeセルのペイロードがb-treeページに対して大きすぎる場合、余剰分はオーバーフローページにこぼれます。オーバーフローページはリンクされたリストを形成します。各オーバーフローページの最初の 4 バイトはビッグエンディアン整数で、これはチェーン内の次のページのページ番号、またはチェーン内の最後のページの場合はゼロになります。5 番目のバ イ ト か ら 最後の使用可能バ イ ト までが、 オーバーフ ロ ー内容を保持す る ために用い ら れます。</target>
        </trans-unit>
        <trans-unit id="7a9dfbcbb999703cb3d0ac4b512f0bf41cd8632a" translate="yes" xml:space="preserve">
          <source>When the private repository is created by cloning, incorporating new public SQLite releases becomes much easier too. To pull in all of the latest changes from the public SQLite repository, simply move into the open check-out and do:</source>
          <target state="translated">プライベートリポジトリをクローンして作成すると、パブリックSQLiteの新しいリリースを組み込むのも非常に簡単になります。公開されているSQLiteリポジトリから最新の変更点をすべて取り込むには、オープンチェックアウトに移動して行うだけです。</target>
        </trans-unit>
        <trans-unit id="5be9656f401ac8804b83b6da6efba9e4ec09be72" translate="yes" xml:space="preserve">
          <source>When the result of a sub-select is a scalar, a single private memory cell can be used, as shown in the previous example. But when the result of a sub-select is a vector, such as when the sub-select is the right-hand operand of IN or NOT IN, a different approach is needed. In this case, the result of the sub-select is stored in a transient table and the contents of that table are tested using the Found or NotFound operators. Consider this example:</source>
          <target state="translated">サブセレクトの結果がスカラである場合、先ほどの例のように、1つのプライベート・メモリ・セルを使用することができます。しかし、サブセレクトの結果がベクトルである場合、例えばサブセレクトがINやNOT INの右辺のオペランドである場合には、別のアプローチが必要になります。この場合、サブ選択の結果は過渡的なテーブルに格納され、そのテーブルの内容は Found または NotFound 演算子を使用してテストされます。この例を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="7f4bad19a801621b1eda251a27bffb8486beb1b2" translate="yes" xml:space="preserve">
          <source>When the serialized &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; is in use, it might be the case that a second error occurs on a separate thread in between the time of the first error and the call to these interfaces. When that happens, the second error will be reported since these interfaces always report the most recent result. To avoid this, each thread can obtain exclusive use of the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D by invoking &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_enter&lt;/a&gt;(&lt;a href=&quot;db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt;(D)) before beginning to use D and invoking &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_leave&lt;/a&gt;(&lt;a href=&quot;db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt;(D)) after all calls to the interfaces listed here are completed.</source>
          <target state="translated">シリアル&lt;a href=&quot;../threadsafe&quot;&gt;化&lt;/a&gt;されたスレッドモードが使用されている場合、最初のエラーが発生してからこれらのインターフェイスが呼び出されるまでの間に、別のスレッドで2番目のエラーが発生することがあります。その場合、これらのインターフェースは常に最新の結果を報告するため、2番目のエラーが報告されます。これを避けるために、各スレッドは専用得ることができ&lt;a href=&quot;sqlite3&quot;&gt;、データベース接続&lt;/a&gt;を呼び出すことによってD &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_enter&lt;/a&gt;（&lt;a href=&quot;db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt; Dを使用して始まり、呼び出す前に（D））を&lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_leave&lt;/a&gt;（&lt;a href=&quot;db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt;ここに記載されているインタフェースへのすべての呼び出しが完了した後（D））を。</target>
        </trans-unit>
        <trans-unit id="6ad35aaaabcdc79e64145d3f60787d98e09a5e23" translate="yes" xml:space="preserve">
          <source>When the serialized &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; is in use, it might be the case that a second error occurs on a separate thread in between the time of the first error and the call to these interfaces. When that happens, the second error will be reported since these interfaces always report the most recent result. To avoid this, each thread can obtain exclusive use of the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D by invoking &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_enter&lt;/a&gt;(&lt;a href=&quot;#sqlite3_db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt;(D)) before beginning to use D and invoking &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_leave&lt;/a&gt;(&lt;a href=&quot;#sqlite3_db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt;(D)) after all calls to the interfaces listed here are completed.</source>
          <target state="translated">シリアル&lt;a href=&quot;threadsafe&quot;&gt;化&lt;/a&gt;されたスレッドモードが使用されている場合、最初のエラーが発生してからこれらのインターフェイスが呼び出されるまでの間に、別のスレッドで2番目のエラーが発生することがあります。その場合、これらのインターフェースは常に最新の結果を報告するため、2番目のエラーが報告されます。これを避けるために、各スレッドは専用得ることができ&lt;a href=&quot;#sqlite3&quot;&gt;、データベース接続&lt;/a&gt;を呼び出すことによってD &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_enter&lt;/a&gt;（&lt;a href=&quot;#sqlite3_db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt; Dを使用して始まり、呼び出す前に（D））を&lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_leave&lt;/a&gt;（&lt;a href=&quot;#sqlite3_db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt;ここに記載されているインタフェースへのすべての呼び出しが完了した後（D））を。</target>
        </trans-unit>
        <trans-unit id="ae5d894865b3485bb3f0df9031d208d9c0c832c5" translate="yes" xml:space="preserve">
          <source>When the size of payload for a cell exceeds a certain threshold (to be defined later) then only the first few bytes of the payload are stored on the b-tree page and the balance is stored in a linked list of content overflow pages.</source>
          <target state="translated">セルのペイロードのサイズがある閾値を超えると(後に定義される)、ペイロードの最初の数バイトのみが b-tree ページに格納され、バランスはコンテンツオーバーフローページのリンク先リストに格納されます。</target>
        </trans-unit>
        <trans-unit id="959baafa9a7af49bb6654912e390fd8adf72f9f7" translate="yes" xml:space="preserve">
          <source>When the steps above are used, SQLite will shorten filename extensions by only using the last 3 characters of the extension. Thus, for example, a file that would normally be called &quot;&lt;code&gt;app.db-journal&lt;/code&gt;&quot; is shortened to just &quot;&lt;code&gt;app.nal&lt;/code&gt;&quot;. Similarly, &quot;&lt;code&gt;app.db-wal&lt;/code&gt;&quot; will become &quot;&lt;code&gt;app.wal&lt;/code&gt;&quot; and &quot;&lt;code&gt;app.db-shm&lt;/code&gt;&quot; becomes &quot;&lt;code&gt;app.shm&lt;/code&gt;&quot;.</source>
          <target state="translated">上記の手順を使用すると、SQLiteは拡張子の最後の3文字のみを使用してファイル名拡張子を短縮します。したがって、たとえば、通常「 &lt;code&gt;app.db-journal&lt;/code&gt; 」と呼ばれるファイルは、単に「 &lt;code&gt;app.nal&lt;/code&gt; 」に短縮されます。同様に、「 &lt;code&gt;app.db-wal&lt;/code&gt; 」は「 &lt;code&gt;app.wal&lt;/code&gt; 」になり、「 &lt;code&gt;app.db-shm&lt;/code&gt; 」は「 &lt;code&gt;app.shm&lt;/code&gt; 」になります。</target>
        </trans-unit>
        <trans-unit id="d643d5a9185e437164a5f2a6216624f98b3e6f19" translate="yes" xml:space="preserve">
          <source>When the temp_store_directory setting is changed, all existing temporary tables, indices, triggers, and viewers in the database connection that issued the pragma are immediately deleted. In practice, temp_store_directory should be set immediately after the first database connection for a process is opened. If the temp_store_directory is changed for one database connection while other database connections are open in the same process, then the behavior is undefined and probably undesirable.</source>
          <target state="translated">temp_store_directoryの設定が変更されると、プラグマを発行したデータベース接続内のすべての既存の一時テーブル、インデックス、トリガ、およびビューアは直ちに削除されます。実際には、プロセスの最初のデータベース接続がオープンされた直後に temp_store_directoryを設定する必要があります。他のデータベース接続が同じプロセスで開かれている間に、1つのデータベース接続に対してtemp_store_directoryが変更された場合、その動作は定義されておらず、おそらく望ましくありません。</target>
        </trans-unit>
        <trans-unit id="343b5a2825eceb4a3f5768433d668b582d6b47c5" translate="yes" xml:space="preserve">
          <source>When the unlock-notify callback is invoked, which may be before the thread that called &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; begins waiting for the asynchronous signal, it does the following:</source>
          <target state="translated">unlock-notifyコールバックが呼び出されると、&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;を呼び出したスレッドが非同期信号の待機を開始する前に、次の処理が行われます。</target>
        </trans-unit>
        <trans-unit id="b97add61bb2e4ac375ed3ff0cd6f248d8d0b370d" translate="yes" xml:space="preserve">
          <source>When the unlock-notify callback is issued, it is issued from within a call to sqlite3_step() (or sqlite3_close()) associated with the blocking connection. It is illegal to invoke any sqlite3_XXX() API functions from within an unlock-notify callback. The expected use is that the unlock-notify callback will signal some other waiting thread or schedule some action to take place later.</source>
          <target state="translated">unlock-notifyコールバックが発行された場合、ブロック接続に関連付けられたsqlite3_step()(またはsqlite3_close())の呼び出し内から発行されます。unlock-notifyコールバック内からsqlite3_XXX()API関数を呼び出すことは違法です。期待される使用法は、 unlock-notifyコールバックが他の待機中のスレッドにシグナルを送ったり、後で実行されるアクションをスケジュールしたりすることです。</target>
        </trans-unit>
        <trans-unit id="c2be91d4a681af8f031fb2096b9f2fe184670aea" translate="yes" xml:space="preserve">
          <source>When the user does a &quot;File/Save&quot;, instead of overwriting the modified slides, the application can now make new entries in the SLIDE table for just those slides that have been added or altered. Then it creates a new entry in the VERSION table containing the revised manifest.</source>
          <target state="translated">ユーザーが [ファイル/保存]を実行すると、変更されたスライドを上書きするのではなく、アプリケーションは、追加または変更されたスライドだけを SLIDE テーブルに新しいエントリを作成できるようになりました。その後、変更されたマニフェストを含む [バージョン]テーブルに新しいエントリが作成されます。</target>
        </trans-unit>
        <trans-unit id="f5e82ec54c65035c07f8ba3e1f179ebb03a74e94" translate="yes" xml:space="preserve">
          <source>When the user presses the Undo button, invoke undo::undo. Invoke undo::redo when the user presses the Redo button.</source>
          <target state="translated">ユーザがUndoボタンを押したときに、undo::undoを呼び出します。ユーザがやり直しボタンを押したときに undo::redo を呼び出します。</target>
        </trans-unit>
        <trans-unit id="1add060c475b241a7872da34e121430f601e3935" translate="yes" xml:space="preserve">
          <source>When the user scrolls down, the application needs to find the second set of 7 entries. One way to do this is to use the OFFSET clause:</source>
          <target state="translated">ユーザが下にスクロールするとき、アプリケーションは7つのエントリの2番目のセットを見つける必要があります。これを行う1つの方法は、OFFSET句を使用することです。</target>
        </trans-unit>
        <trans-unit id="591f64272639e3cef4d6af5b9d0166c866e319e8" translate="yes" xml:space="preserve">
          <source>When the value of auto-vacuum is 2 or &quot;incremental&quot; then the additional information needed to do auto-vacuuming is stored in the database file but auto-vacuuming does not occur automatically at each commit as it does with auto_vacuum=full. In incremental mode, the separate &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; pragma must be invoked to cause the auto-vacuum to occur.</source>
          <target state="translated">auto-vacuumの値が2または「増分」の場合、自動バキュームを実行するために必要な追加情報はデータベースファイルに格納されますが、自動バキュームは、auto_vacuum = fullの場合とは異なり、コミットごとに自動的に実行されません。増分モードでは、独立した&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt;プラグマを呼び出して、自動バキュームを発生させる必要があります。</target>
        </trans-unit>
        <trans-unit id="681fab88c0ae33e7ccdb7976051e9eb1cbf3ae58" translate="yes" xml:space="preserve">
          <source>When the value returned to V is a string, space to hold that string is managed by the prepared statement S and will be automatically freed when S is finalized.</source>
          <target state="translated">Vに返される値が文字列である場合、その文字列を保持するスペースは準備された文Sで管理され、Sが確定すると自動的に解放されます。</target>
        </trans-unit>
        <trans-unit id="676274b5ee061976c65b6934ef4f5a4fbd2b341f" translate="yes" xml:space="preserve">
          <source>When the wait_for_unlock_notify() thread is ready to begin waiting for the unlock-notify callback to arrive, it:</source>
          <target state="translated">wait_for_unlock_notify()スレッドが unlock-notify コールバックの到着を待ち始める準備ができたら、それを実行します。</target>
        </trans-unit>
        <trans-unit id="10e245699dbb244b04267cf604539f618d05ec7d" translate="yes" xml:space="preserve">
          <source>When there are &lt;a href=&quot;lang_attach&quot;&gt;attached databases&lt;/a&gt; and no database is specified in the pragma, all databases have their secure-delete setting altered. The secure-delete setting for newly attached databases is the setting of the main database at the time the ATTACH command is evaluated.</source>
          <target state="translated">&lt;a href=&quot;lang_attach&quot;&gt;接続&lt;/a&gt;されているデータベースがあり、プラグマでデータベースが指定されていない場合、すべてのデータベースのセキュア削除設定が変更されます。新しく接続されたデータベースのセキュア削除設定は、ATTACHコマンドが評価されたときのメインデータベースの設定です。</target>
        </trans-unit>
        <trans-unit id="0e9e3d42daf92400d82986bf5b6a37eceed3828b" translate="yes" xml:space="preserve">
          <source>When this C-preprocessor macro is defined, SQLite includes some additional APIs that provide convenient access to meta-data about tables and queries. The APIs that are enabled by this option are:</source>
          <target state="translated">この C プリプロセッサ マクロが定義されている場合、SQLite には、テーブルやクエリのメタデータに便利にアクセスできるいくつかの追加 API が含まれています。このオプションで有効になるAPIは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="80b17e344d3336c6d06fda5d24a646acabeba334" translate="yes" xml:space="preserve">
          <source>When this function is called, the requested changeset is created using both the accumulated records and the current contents of the database file. Specifically:</source>
          <target state="translated">この関数を呼び出すと、要求されたチェンジセットは、蓄積されたレコードとデータベース・ファイルの現在の内容の両方を使用して作成されます。具体的には</target>
        </trans-unit>
        <trans-unit id="bb6586ef4ac72fe83222f833701701fa936feb91" translate="yes" xml:space="preserve">
          <source>When this is defined, the library does not respect the special database name &quot;:memory:&quot; (normally used to create an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt;). If &quot;:memory:&quot; is passed to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, a file with this name will be opened or created.</source>
          <target state="translated">これが定義されている場合、ライブラリは特別なデータベース名 &quot;：memory：&quot;を考慮しません（通常&lt;a href=&quot;inmemorydb&quot;&gt;、インメモリデータベースの&lt;/a&gt;作成に使用されます）。&quot;：memory：&quot;が&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;、&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt;、または&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;に渡されると、この名前のファイルが開かれるか作成されます。</target>
        </trans-unit>
        <trans-unit id="9dadcf039e49017d2804dcadcaa92a2ed3ad29c4" translate="yes" xml:space="preserve">
          <source>When this is done, no disk file is opened. Instead, a new database is created purely in memory. The database ceases to exist as soon as the database connection is closed. Every :memory: database is distinct from every other. So, opening two database connections each with the filename &quot;:memory:&quot; will create two independent in-memory databases.</source>
          <target state="translated">これが行われると、ディスクファイルは開かれません。その代わりに、新しいデータベースが純粋にメモリ内に作成されます。データベース接続が閉じられるとすぐにデータベースは存在しなくなります。すべての :memory:データベースは他のデータベースとは区別されています。ですから、&quot;:memory:&quot;というファイル名で2つのデータベース接続を開くと、2つの独立したインメモリデータベースが作成されます。</target>
        </trans-unit>
        <trans-unit id="3c612857bb421bf9acf60c3aa66716a6889b3ef9" translate="yes" xml:space="preserve">
          <source>When this option is defined in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, the &lt;a href=&quot;geopoly&quot;&gt;Geopoly extension&lt;/a&gt; is included in the build.</source>
          <target state="translated">このオプションが&lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;で定義されている場合、&lt;a href=&quot;geopoly&quot;&gt;Geopolyエクステンション&lt;/a&gt;がビルドに含まれます。</target>
        </trans-unit>
        <trans-unit id="63b0e43097f54c25e3fe1c915efb4112c36433a7" translate="yes" xml:space="preserve">
          <source>When this option is defined in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, the &lt;a href=&quot;json1&quot;&gt;JSON SQL functions&lt;/a&gt; are added to the build automatically.</source>
          <target state="translated">このオプションが&lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;で定義されている場合、&lt;a href=&quot;json1&quot;&gt;JSON SQL関数&lt;/a&gt;がビルドに自動的に追加されます。</target>
        </trans-unit>
        <trans-unit id="e638c666c14acfed829f561f8cba0197feda3c02" translate="yes" xml:space="preserve">
          <source>When this option is defined in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, version 3 of the full-text search engine is added to the build automatically.</source>
          <target state="translated">このオプションが&lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;で定義されている場合、フルテキスト検索エンジンのバージョン3がビルドに自動的に追加されます。</target>
        </trans-unit>
        <trans-unit id="4a19c3b55092d529dbfec770d25a58e2ca349990" translate="yes" xml:space="preserve">
          <source>When this option is defined in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, versions 3 and 4 of the full-text search engine is added to the build automatically.</source>
          <target state="translated">このオプションが&lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;で定義されている場合、フルテキスト検索エンジンのバージョン3および4がビルドに自動的に追加されます。</target>
        </trans-unit>
        <trans-unit id="818c376822c0fec952ac59c4332327f0b7edf7db" translate="yes" xml:space="preserve">
          <source>When this option is defined in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, versions 5 of the full-text search engine (&lt;a href=&quot;fts5&quot;&gt;fts5&lt;/a&gt;) is added to the build automatically.</source>
          <target state="translated">このオプションが&lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;で定義されている場合、全文検索エンジンのバージョン5（&lt;a href=&quot;fts5&quot;&gt;fts5&lt;/a&gt;）がビルドに自動的に追加されます。</target>
        </trans-unit>
        <trans-unit id="6540ae2c93aba220c991dfe94132dd0f63e59810" translate="yes" xml:space="preserve">
          <source>When this option is defined, an optimization that accelerates counting all entries in a table (in other words, an optimization that helps &quot;SELECT count(*) FROM table&quot; run faster) is omitted.</source>
          <target state="translated">このオプションが定義されている場合、テーブル内のすべてのエントリのカウントを高速化する最適化(言い換えれば、&quot;SELECT count(*)FROM table&quot; を高速に実行するための最適化)は省略されます。</target>
        </trans-unit>
        <trans-unit id="53f492f476a20550a057a12a97c6de3049506d26" translate="yes" xml:space="preserve">
          <source>When this option is defined, it is not possible to specify a blob in an SQL statement using the X'ABCD' syntax.</source>
          <target state="translated">このオプションが定義されている場合、X'ABCD' 構文を使用して SQL 文で blob を指定することはできません。</target>
        </trans-unit>
        <trans-unit id="afad8ea069f34c202a3e893171214a5aee9a0bc0" translate="yes" xml:space="preserve">
          <source>When this option is defined, the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command is not included in the library. Executing an &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; statement causes a parse error.</source>
          <target state="translated">このオプションが定義されている場合、&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;コマンドはライブラリーに含まれません。&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;ステートメントを実行すると、解析エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="523431ac75b0212a06c55ac385d13beeedacb305" translate="yes" xml:space="preserve">
          <source>When this option is defined, the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command is omitted from the build.</source>
          <target state="translated">このオプションを定義すると、&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;コマンドはビルドから省略されます。</target>
        </trans-unit>
        <trans-unit id="594c7ba3832aba3180a92cd74c6f75ba44ce7aaf" translate="yes" xml:space="preserve">
          <source>When this option is defined, the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; and &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt; commands are omitted from the build.</source>
          <target state="translated">このオプションを定義すると、ビルドから&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;および&lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt;コマンドが省略されます。</target>
        </trans-unit>
        <trans-unit id="8c1b711bd5c9246457da19791ca7b6dcb97ca5d2" translate="yes" xml:space="preserve">
          <source>When this option is defined, the &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; command is not included in the library. Executing a &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; statement causes a parse error.</source>
          <target state="translated">このオプションが定義されている場合、&lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;コマンドはライブラリに含まれません。&lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;ステートメントを実行すると、解析エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="d2955f48905e9a8f58404484936cbf538b367034" translate="yes" xml:space="preserve">
          <source>When this option is defined, the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command is not included in the library. Executing a &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; statement causes a parse error.</source>
          <target state="translated">このオプションを定義すると、&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;コマンドはライブラリに含まれません。&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;ステートメントを実行すると、解析エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="f189302742f5abf29172e2258e929a776e965db1" translate="yes" xml:space="preserve">
          <source>When this option is present, content contained in &lt;a href=&quot;fileformat2#ovflpgs&quot;&gt;overflow pages&lt;/a&gt; of the database file is read directly from disk, bypassing the &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;page cache&lt;/a&gt;, during read transactions. In applications that do a lot of reads of large BLOBs, this option might improve read performance.</source>
          <target state="translated">このオプションが存在する場合、データベースファイルの&lt;a href=&quot;fileformat2#ovflpgs&quot;&gt;オーバーフローページ&lt;/a&gt;に含まれるコンテンツは、読み取りトランザクション中に、&lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;ページキャッシュを&lt;/a&gt;バイパスしてディスクから直接読み取られます。大きなBLOBを大量に読み取るアプリケーションでは、このオプションにより読み取りパフォーマンスが向上する場合があります。</target>
        </trans-unit>
        <trans-unit id="05b6e594e4163ec73c013e9bc0bd201fec26dfcd" translate="yes" xml:space="preserve">
          <source>When this pragma is on, and the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; flag is off, then the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; table can be changed using ordinary &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements. &lt;b&gt;Warning:&lt;/b&gt; misuse of this pragma can easily result in a &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;corrupt database file&lt;/a&gt;.</source>
          <target state="translated">このプラグマがオンで、&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt;フラグがオフの場合、通常の&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;、&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;、および&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;ステートメントを使用して&lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt;テーブルを変更できます。&lt;b&gt;警告：&lt;/b&gt;このプラグマを誤用すると、&lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;データベースファイル&lt;/a&gt;が破損する可能性があります。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="155915a2fa0e144a28d6f3909aae6b1d4f21b4e3" translate="yes" xml:space="preserve">
          <source>When this pragma is on, and the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; flag is off, then the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; table can be changed using ordinary &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements. &lt;b&gt;Warning:&lt;/b&gt; misuse of this pragma can easily result in a &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;corrupt database file&lt;/a&gt;.</source>
          <target state="translated">When this pragma is on, and the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; flag is off, then the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; table can be changed using ordinary &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements. &lt;b&gt;Warning:&lt;/b&gt; misuse of this pragma can easily result in a &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;corrupt database file&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="c24dad918c280682da96633e2cfedee92e2eb063" translate="yes" xml:space="preserve">
          <source>When three or more simple SELECTs are connected into a compound SELECT, they group from left to right. In other words, if &quot;A&quot;, &quot;B&quot; and &quot;C&quot; are all simple SELECT statements, (A op B op C) is processed as ((A op B) op C).</source>
          <target state="translated">3つ以上の単純なSELECT文を連結して複合SELECT文にすると、左から右にグループ化されます。つまり、&quot;A&quot;、&quot;B&quot;、&quot;C &quot;がすべて単純なSELECT文であれば、(A op B op C)は((A op B)op C)として処理されます。</target>
        </trans-unit>
        <trans-unit id="356d225c15feaa12023968822303a920dbc04787" translate="yes" xml:space="preserve">
          <source>When to use WITHOUT ROWID</source>
          <target state="translated">WITHOUT ROWIDを使用する場合</target>
        </trans-unit>
        <trans-unit id="dde1df06f3e28fa2c213af6dc7ee811081acdcc1" translate="yes" xml:space="preserve">
          <source>When two BLOB values are compared, the result is determined using memcmp().</source>
          <target state="translated">2つのBLOB値を比較した場合、結果はmemcmp()を使用して決定されます。</target>
        </trans-unit>
        <trans-unit id="3b7477ad4142a17a91342e502a66554eeeaf182c" translate="yes" xml:space="preserve">
          <source>When two or more connections access the same database in shared-cache mode, read and write (shared and exclusive) locks on individual tables are used to ensure that concurrently executing transactions are kept isolated. Before writing to a table, a write (exclusive) lock must be obtained on that table. Before reading, a read (shared) lock must be obtained. A connection releases all held table locks when it concludes its transaction. If a connection cannot obtain a required lock, then the call to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; returns SQLITE_LOCKED.</source>
          <target state="translated">2つ以上の接続が共有キャッシュモードで同じデータベースにアクセスする場合、個々のテーブルの読み取りおよび書き込み（共有および排他）ロックを使用して、同時に実行されるトランザクションを確実に分離します。テーブルに書き込む前に、そのテーブルで書き込み（排他）ロックを取得する必要があります。読み取る前に、読み取り（共有）ロックを取得する必要があります。接続は、トランザクションが完了すると、保持されているすべてのテーブルロックを解放します。接続が必要なロックを取得できない場合、&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;への呼び出しはSQLITE_LOCKEDを返します。</target>
        </trans-unit>
        <trans-unit id="384b14b240303a8eaa803ae4a95a246eb3eb3a95" translate="yes" xml:space="preserve">
          <source>When two or more connections use a shared-cache, locks are used to serialize concurrent access attempts on a per-table basis. Tables support two types of locks, &quot;read-locks&quot; and &quot;write-locks&quot;. Locks are granted to connections - at any one time, each database connection has either a read-lock, write-lock or no lock on each database table.</source>
          <target state="translated">2 つ以上の接続が共有キャッシュを使用する場合、ロックは、テーブルごとに同時アクセスの試行をシリアライズするために使用されます。テーブルは、&quot;読み取りロック &quot;と &quot;書き込みロック &quot;の2種類のロックをサポートしています。ロックは接続に付与されます。各データベース接続は常に、各データベース テーブルに対して読み取りロック、書き込みロック、またはロックなしのいずれかを持っています。</target>
        </trans-unit>
        <trans-unit id="9ef3f52e6658347244503cf695a84d552443a0f6" translate="yes" xml:space="preserve">
          <source>When unlocking, the same SHARED or EXCLUSIVE flag must be supplied as was given on the corresponding lock.</source>
          <target state="translated">アンロック時には、対応するロックに与えられたものと同じSHAREDまたはEXCLUSIVEフラグを与えなければなりません。</target>
        </trans-unit>
        <trans-unit id="c942e92dfd8f19ebf7cd74cbba74f891e087e57f" translate="yes" xml:space="preserve">
          <source>When updating the database file, SQLite always makes a copy of the page content into heap memory before modifying the page. This is necessary for two reasons. First, changes to the database are not supposed to be visible to other processes until after the transaction commits and so the changes must occur in private memory. Second, SQLite uses a read-only memory map to prevent stray pointers in the application from overwriting and corrupting the database file.</source>
          <target state="translated">データベースファイルを更新するとき、SQLite は常にページを修正する前にページの内容のコピーをヒープメモリに作成します。これは2つの理由から必要とされています。第一に、データベースへの変更は、トランザクションがコミットされるまで他のプロセスからは見えないようになっているため、変更はプライベートメモリ内で行われなければなりません。第二に、SQLite は読み取り専用のメモリマップを使用して、アプリケーション内の迷走ポインタがデータベースファイルを上書きしたり破損させたりするのを防ぎます。</target>
        </trans-unit>
        <trans-unit id="321ab4dcceec298b077cdbf468b4b448206d5be8" translate="yes" xml:space="preserve">
          <source>When used in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;, the SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION feature allows SQL text that contains application-defined functions to be pasted into the shell for analysis and debugging without having to create and load an extension that implements the application-defined functions.</source>
          <target state="translated">で使用された場合&lt;a href=&quot;cli&quot;&gt;、コマンドライン・シェル&lt;/a&gt;、SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION機能が拡張それは実装するアプリケーション定義関数を作成し、ロードすることなく、アプリケーションで定義された関数を含むSQL文を分析し、デバッグするためのシェルに貼り付けることを可能にします。</target>
        </trans-unit>
        <trans-unit id="4fb531d1e034498892c1e8ba5b02ac3bc138fb71" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;mmap&quot;&gt;memory-mapped I/O&lt;/a&gt; map the database file read-only so that stray pointers and/or array overruns in the application cannot accidentally modify the database file.</source>
          <target state="translated">&lt;a href=&quot;mmap&quot;&gt;メモリマップされたI / O&lt;/a&gt;マップを使用する場合は、データベースファイルを読み取り専用にして、アプリケーション内のストレイポインターや配列オーバーランが誤ってデータベースファイルを変更しないようにします。</target>
        </trans-unit>
        <trans-unit id="6bcae413d7ef24ed4791d379c4695938ecb30984" translate="yes" xml:space="preserve">
          <source>When using FTS4, specifying a column name that contains an &quot;=&quot; character and is not either a &quot;tokenize=*&quot; specification or a recognized FTS4 option is an error. With FTS3, the first token in the unrecognized directive is interpreted as a column name. Similarly, specifying multiple &quot;tokenize=*&quot; directives in a single table declaration is an error when using FTS4, whereas the second and subsequent &quot;tokenize=*&quot; directives are interpreted as column names by FTS3. For example:</source>
          <target state="translated">FTS4を使用する場合、&quot;=&quot;文字を含み、&quot;tokenize=*&quot;指定でも認識されたFTS4オプションでもないカラム名を指定するとエラーになります。FTS3では、認識されていないディレクティブの最初のトークンがカラム名として解釈されます。同様に、単一のテーブル宣言で複数の &quot;tokenize=*&quot;ディレクティブを指定することは、FTS4を使用している場合にはエラーとなりますが、2番目以降の &quot;tokenize=*&quot;ディレクティブは、FTS3では列名として解釈されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="a2854ef2a0e9879ca0973bfbdbeb94518a7782b5" translate="yes" xml:space="preserve">
          <source>When using SQLite as a shared library, an application can test to see whether or not mutexes have been disabled using the &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; API. Applications that link against SQLite at run-time and use SQLite from multiple threads should probably check this API to make sure they did not accidentally get linked against a version of the SQLite library that has its mutexes disabled. Single-threaded applications will, of course, work correctly regardless of whether or not SQLite is configured to be threadsafe, though they will be a little bit faster when using versions of SQLite with mutexes disabled.</source>
          <target state="translated">SQLiteを共有ライブラリとして使用する場合、アプリケーションは&lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe（）&lt;/a&gt; API を使用してミューテックスが無効になっているかどうかをテストして確認できます。実行時にSQLiteにリンクし、複数のスレッドからSQLiteを使用するアプリケーションは、このAPIをチェックして、ミューテックスが無効になっているSQLiteライブラリのバージョンに対して誤ってリンクされていないことを確認する必要があります。もちろん、シングルスレッドアプリケーションは、SQLiteがスレッドセーフに設定されているかどうかに関係なく正しく動作しますが、ミューテックスを無効にしたバージョンのSQLiteを使用する場合は少し高速になります。</target>
        </trans-unit>
        <trans-unit id="baabf02615564e01474304f4466f9fe87599218a" translate="yes" xml:space="preserve">
          <source>When using an index on an expression, try to use expression values already available in the index, rather than loading the original columns and recomputing the expression.</source>
          <target state="translated">式にインデックスを使用する場合は、元の列をロードして式を再計算するのではなく、インデックスで既に利用可能な式の値を使用するようにしてください。</target>
        </trans-unit>
        <trans-unit id="468b6859516cde0950db73781d0176e06ba0111f" translate="yes" xml:space="preserve">
          <source>When using methods (2) or (3), it is important that the tokenizer only provide synonyms when tokenizing document text (method (2)) or query text (method (3)), not both. Doing so will not cause any errors, but is inefficient.</source>
          <target state="translated">メソッド(2)や(3)を使用する場合、トークン化機能ではドキュメントテキスト(メソッド(2)やクエリテキスト(メソッド(3))をトークン化する際に同義語のみを提供し、両方を提供しないことが重要です。そうすることでエラーは発生しませんが、効率が悪くなります。</target>
        </trans-unit>
        <trans-unit id="88fac7db3e9db07076df4610515cb23f9340b834" translate="yes" xml:space="preserve">
          <source>When using the enhanced query syntax, parenthesis may be used to override the default precedence of the various operators. For example:</source>
          <target state="translated">強化されたクエリ構文を使用する場合、括弧を使用してさまざまな演算子のデフォルトの優先順位を上書きすることができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="1505c3324cb54c87924929ab65d11580dc89a0fd" translate="yes" xml:space="preserve">
          <source>When wrongful thoughts come into your heart, dash them against Christ immediately.</source>
          <target state="translated">間違った考えが心に浮かんできたら、すぐにキリストに向かってそれを打ち砕きなさい。</target>
        </trans-unit>
        <trans-unit id="5d95aef3b20c2c80bafbf5f8ecbb1090e555f684" translate="yes" xml:space="preserve">
          <source>When xSavepoint(X,N) is invoked, that is a signal to the virtual table X that it should save its current state as savepoint N. A subsequent call to xRollbackTo(X,R) means that the state of the virtual table should return to what it was when xSavepoint(X,R) was last called. The call to xRollbackTo(X,R) will invalidate all savepoints with N&amp;gt;R; none of the invalided savepoints will be rolled back or released without first being reinitialized by a call to xSavepoint(). A call to xRelease(X,M) invalidates all savepoints where N&amp;gt;=M.</source>
          <target state="translated">xSavepoint（X、N）が呼び出されると、それは仮想テーブルXへのシグナルであり、現在の状態をセーブポイントNとして保存する必要があります。その後のxRollbackTo（X、R）の呼び出しは、仮想テーブルの状態がxSavepoint（X、R）が最後に呼び出されたときの状態に戻ります。 xRollbackTo（X、R）を呼び出すと、N&amp;gt; Rのすべてのセーブポイントが無効になります。 xSavepoint（）の呼び出しによって最初に再初期化されることなく、無効なセーブポイントがロールバックまたは解放されることはありません。 xRelease（X、M）を呼び出すと、N&amp;gt; = Mのすべてのセーブポイントが無効になります。</target>
        </trans-unit>
        <trans-unit id="d7bf837f933ca19d45d60aebd942c6f51001215f" translate="yes" xml:space="preserve">
          <source>When you change the cache size using the cache_size pragma, the change only endures for the current session. The cache size reverts to the default value when the database is closed and reopened.</source>
          <target state="translated">cache_size pragmaを使用してキャッシュサイズを変更した場合、変更は現在のセッションでのみ有効です。キャッシュサイズは、データベースが閉じられて再開されるとデフォルト値に戻ります。</target>
        </trans-unit>
        <trans-unit id="b0e87a05754f1ec62d9fdd0b9342f0b467aa6d5b" translate="yes" xml:space="preserve">
          <source>When you do an insert into a table that does not have an INTEGER PRIMARY KEY column, or if the table does have an INTEGER PRIMARY KEY but the value for that column is not specified in the VALUES clause of the insert, then the key is automatically generated. You can find the value of the key for the most recent INSERT statement using the &lt;b&gt;sqlite_last_insert_rowid&lt;/b&gt; API function.</source>
          <target state="translated">INTEGER PRIMARY KEY列のないテーブルに挿入を行う場合、またはテーブルにINTEGER PRIMARY KEYがあるが、その列の値が挿入のVALUES句で指定されていない場合、キーは自動的に生成されました。&lt;b&gt;sqlite_last_insert_rowid&lt;/b&gt; API関数を使用して、最新のINSERTステートメントのキーの値を見つけることができます。</target>
        </trans-unit>
        <trans-unit id="4e2ed89fd7ed9aabab05210ebf19395404532e3b" translate="yes" xml:space="preserve">
          <source>When you have a SQL script that you are debugging or trying to understand, it is often useful to run it in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; with the &quot;.eqp full&quot; setting. When &quot;.eqp&quot; is set to FULL, the shell automatically shows the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; and &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; output for each command prior to actually running that command.</source>
          <target state="translated">デバッグまたは理解しようとしているSQLスクリプトがある場合、&lt;a href=&quot;cli&quot;&gt;コマンドラインシェル&lt;/a&gt;で &quot;.eqp full&quot;設定を使用して実行すると便利な場合があります。&quot;.eqp&quot;がFULLに設定されている場合、シェルは実際にそのコマンドを実行する前に、各コマンドの&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;および&lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;出力を自動的に表示します。</target>
        </trans-unit>
        <trans-unit id="9a469065895a09048073186621e6fa156f1d430f" translate="yes" xml:space="preserve">
          <source>Whenever a &lt;a href=&quot;../pragma#syntax&quot; id=&quot;sqlitefcntlpragma&quot;&gt;PRAGMA&lt;/a&gt; statement is parsed, an &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control is sent to the open &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object corresponding to the database file to which the pragma statement refers. The argument to the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control is an array of pointers to strings (char**) in which the second element of the array is the name of the pragma and the third element is the argument to the pragma or NULL if the pragma has no argument. The handler for an &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control can optionally make the first element of the char** argument point to a string obtained from &lt;a href=&quot;mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; or the equivalent and that string will become the result of the pragma or the error message if the pragma fails. If the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control returns &lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;, then normal &lt;a href=&quot;../pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; processing continues. If the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;, then the parser assumes that the VFS has handled the PRAGMA itself and the parser generates a no-op prepared statement if result string is NULL, or that returns a copy of the result string if the string is non-NULL. If the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control returns any result code other than &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; or &lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;, that means that the VFS encountered an error while handling the &lt;a href=&quot;../pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; and the compilation of the PRAGMA fails with an error. The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control occurs at the beginning of pragma statement analysis and so it is able to override built-in &lt;a href=&quot;../pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements.</source>
          <target state="translated">&lt;a href=&quot;../pragma#syntax&quot; id=&quot;sqlitefcntlpragma&quot;&gt;PRAGMA&lt;/a&gt;ステートメントが解析されるときはいつでも、&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;ファイルコントロールが、プラグマステートメントが参照するデータベースファイルに対応する開いている&lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt;オブジェクトに送信されます。&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;ファイルコントロールへの引数は、文字列（char **）へのポインターの配列で、配列の2番目の要素はプラグマの名前、3番目の要素はプラグマの引数、またはプラグマにNULLがない場合はNULLです。引数。&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;ファイルコントロールのハンドラーは、char **引数の最初の要素が&lt;a href=&quot;mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;から取得した文字列を指すようにすることもできます。または同等のものであり、その文字列は、プラグマが失敗した場合に、プラグマまたはエラーメッセージの結果になります。&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;ファイルコントロールが&lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUNDを&lt;/a&gt;返す場合、通常の&lt;a href=&quot;../pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;処理が続行されます。&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;ファイルコントロールが&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OKを&lt;/a&gt;返す場合、パーサーはVFSがPRAGMA自体を処理したと想定し、結果の文字列がNULLの場合、パーサーは何もしない準備済みステートメントを生成します。 -ヌル。場合&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMAの&lt;/a&gt;ファイル制御は、以外の結果コードを返し&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;または&lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUNDを&lt;/a&gt;つまり、&lt;a href=&quot;../pragma#syntax&quot;&gt;PRAGMAの&lt;/a&gt;処理中にVFSでエラーが発生し、PRAGMAのコンパイルがエラーで失敗しました。&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMAの&lt;/a&gt;ファイル制御は、プラグマ文解析の初めに、ビルトイン上書きすることができますので、発生した&lt;a href=&quot;../pragma#syntax&quot;&gt;プラグマ&lt;/a&gt;文。</target>
        </trans-unit>
        <trans-unit id="4f29909c26f83db47f3f77fe2f91d6b21b9cfb6d" translate="yes" xml:space="preserve">
          <source>Whenever a &lt;a href=&quot;pragma#syntax&quot; id=&quot;sqlitefcntlpragma&quot;&gt;PRAGMA&lt;/a&gt; statement is parsed, an &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control is sent to the open &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object corresponding to the database file to which the pragma statement refers. The argument to the &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control is an array of pointers to strings (char**) in which the second element of the array is the name of the pragma and the third element is the argument to the pragma or NULL if the pragma has no argument. The handler for an &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control can optionally make the first element of the char** argument point to a string obtained from &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; or the equivalent and that string will become the result of the pragma or the error message if the pragma fails. If the &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;, then normal &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; processing continues. If the &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;, then the parser assumes that the VFS has handled the PRAGMA itself and the parser generates a no-op prepared statement if result string is NULL, or that returns a copy of the result string if the string is non-NULL. If the &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control returns any result code other than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;, that means that the VFS encountered an error while handling the &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; and the compilation of the PRAGMA fails with an error. The &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control occurs at the beginning of pragma statement analysis and so it is able to override built-in &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements.</source>
          <target state="translated">&lt;a href=&quot;pragma#syntax&quot; id=&quot;sqlitefcntlpragma&quot;&gt;PRAGMA&lt;/a&gt;ステートメントが解析されるときはいつでも、&lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;ファイルコントロールが、プラグマステートメントが参照するデータベースファイルに対応する開いている&lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt;オブジェクトに送信されます。&lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;ファイルコントロールへの引数は、文字列（char **）へのポインターの配列で、配列の2番目の要素はプラグマの名前、3番目の要素はプラグマの引数、またはプラグマにNULLがない場合はNULLです。引数。&lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;ファイルコントロールのハンドラーは、char **引数の最初の要素が&lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;から取得した文字列を指すようにすることもできます。または同等のものであり、その文字列は、プラグマが失敗した場合に、プラグマまたはエラーメッセージの結果になります。&lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;ファイルコントロールが&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUNDを&lt;/a&gt;返す場合、通常の&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;処理が続行されます。&lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;ファイルコントロールが&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OKを&lt;/a&gt;返す場合、パーサーはVFSがPRAGMA自体を処理したと想定し、結果の文字列がNULLの場合、パーサーは何もしない準備済みステートメントを生成します。 -ヌル。場合&lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMAの&lt;/a&gt;ファイル制御は、以外の結果コードを返し&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;または&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUNDを&lt;/a&gt;つまり、&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMAの&lt;/a&gt;処理中にVFSでエラーが発生し、PRAGMAのコンパイルがエラーで失敗しました。&lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMAの&lt;/a&gt;ファイル制御は、プラグマ文解析の初めに、ビルトイン上書きすることができますので、発生した&lt;a href=&quot;pragma#syntax&quot;&gt;プラグマ&lt;/a&gt;文。</target>
        </trans-unit>
        <trans-unit id="7da0d908dd494a51e46851fa8be237351c85f11a" translate="yes" xml:space="preserve">
          <source>Whenever a bug is reported against SQLite, that bug is not considered fixed until new test cases that would exhibit the bug have been added to either the TCL or TH3 test suites. Over the years, this has resulted in thousands and thousands of new tests. These regression tests ensure that bugs that have been fixed in the past are not reintroduced into future versions of SQLite.</source>
          <target state="translated">SQLite に対してバグが報告された場合はいつでも、そのバグを示す新しいテストケースが TCL または TH3 テストスイートに追加されるまでは、そのバグは修正されたとはみなされません。何年にもわたって、何千も何千もの新しいテストが行われてきました。これらのリグレッションテストは、過去に修正されたバグが将来のバージョンの SQLite に再導入されないようにするためのものです。</target>
        </trans-unit>
        <trans-unit id="33e01584f09cbc3030c7fddae4886376aff67c9e" translate="yes" xml:space="preserve">
          <source>Whenever a database is opened, the entire schema is scanned and parsed and a parse tree for the schema is held in memory. That means that database connection startup time and initial memory usage is proportional to the size of the schema.</source>
          <target state="translated">データベースを開くたびに、スキーマ全体をスキャンして解析し、スキーマの解析ツリーをメモリに保持します。つまり、データベース接続の起動時間と初期メモリ使用量は、スキーマのサイズに比例します。</target>
        </trans-unit>
        <trans-unit id="497ecda91e171119dde556e568de3183a8cb8f6e" translate="yes" xml:space="preserve">
          <source>Whenever a row in the parent table of a foreign key constraint is deleted, or when the values stored in the parent key column or columns are modified, the logical sequence of events is:</source>
          <target state="translated">外部キー制約の親テーブルの行が削除されたり、親キー列や列に格納されている値が変更されたりするたびに、論理的な順序でイベントが発生します。</target>
        </trans-unit>
        <trans-unit id="0a37cacf0c7e51e3db57f63b99d51f003b150071" translate="yes" xml:space="preserve">
          <source>Whenever a write operation occurs, the writer checks how much progress the checkpointer has made, and if the entire WAL has been transferred into the database and synced and if no readers are making use of the WAL, then the writer will rewind the WAL back to the beginning and start putting new transactions at the beginning of the WAL. This mechanism prevents a WAL file from growing without bound.</source>
          <target state="translated">書き込み操作が発生するたびに、ライターはチェックポインタがどれだけ進んだかをチェックし、WAL全体がデータベースに転送されて同期され、WALを利用している読者がいなければ、ライターはWALを最初に巻き戻し、WALの先頭に新しいトランザクションを入れ始めます。この仕組みにより、WALファイルがバインドされずに成長するのを防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="343d6f171b30e5570b4ea710189ea4bcc234b168" translate="yes" xml:space="preserve">
          <source>Whenever another row of result data is available, &lt;b&gt;sqlite_step&lt;/b&gt; will return SQLITE_ROW. The row data is stored in an array of pointers to strings and the 2nd parameter is made to point to this array.</source>
          <target state="translated">結果データの別の行が利用可能な場合は常に、&lt;b&gt;sqlite_step&lt;/b&gt;は&lt;b&gt;SQLITE_ROW&lt;/b&gt;を返します。行データは文字列へのポインタの配列に格納され、2番目のパラメータはこの配列を指すように作成されます。</target>
        </trans-unit>
        <trans-unit id="be09d2acec84e8312793d7710565bb42fe503a39" translate="yes" xml:space="preserve">
          <source>Whenever comparing SQLite to other SQL database engines like SQL Server, PostgreSQL, MySQL, or Oracle, it is important first of all to realize that SQLite is not intended as a replacement or competitor to any of those systems. SQLite is &lt;a href=&quot;serverless&quot;&gt;serverless&lt;/a&gt;. There is no separate server process that manages the database. An application interacts with the database engine using function calls, not by sending messages to a separate process or thread.</source>
          <target state="translated">SQLiteを他のSQLデータベースエンジン（SQL Server、PostgreSQL、MySQL、Oracleなど）と比較するときは常に、SQLiteがこれらのシステムの代替または競合製品として意図されていないことを理解することが重要です。SQLiteは&lt;a href=&quot;serverless&quot;&gt;サーバーレス&lt;/a&gt;です。データベースを管理する個別のサーバープロセスはありません。アプリケーションは、個別のプロセスまたはスレッドにメッセージを送信するのではなく、関数呼び出しを使用してデータベースエンジンと対話します。</target>
        </trans-unit>
        <trans-unit id="17a11b6e3fb65c86a99e26ed1e561497e95a4bf4" translate="yes" xml:space="preserve">
          <source>Whenever the database schema changes, prepared statements are automatically reprepared to accommodate the new schema. There is a race condition here in that if one thread is constantly changing the schema, another thread might spin on reparses and repreparations of a prepared statement and never get any real work done. This parameter prevents an infinite loop by forcing the spinning thread to give up after a fixed number of attempts at recompiling the prepared statement. The default setting is 50 which is more than adequate for most applications.</source>
          <target state="translated">データベースのスキーマが変更されるたびに、新しいスキーマに対応するために準備された文が自動的に再準備されます。ここでは、あるスレッドが常にスキーマを変更している場合、別のスレッドが準備された文のリパーズや再準備を行っても、実際の作業が行われない可能性があるというレース条件があります。このパラメータは、準備された文の再コンパイルを一定回数試みた後、回転しているスレッドを強制的に放棄させることで、無限ループを防ぎます。デフォルトの設定は50で、ほとんどのアプリケーションではこれで十分です。</target>
        </trans-unit>
        <trans-unit id="5bd2a09557636d477221b6346f70a36e1b45532a" translate="yes" xml:space="preserve">
          <source>Where &quot;column&quot; is a column in the virtual table, OP is an operator like &quot;=&quot; or &quot;&amp;lt;&quot;, and EXPR is an arbitrary expression. So, for example, if the WHERE clause contained a term like this:</source>
          <target state="translated">「column」が仮想テーブルの列である場合、OPは「=」や「&amp;lt;」などの演算子であり、EXPRは任意の式です。したがって、たとえば、WHERE句に次のような用語が含まれているとします。</target>
        </trans-unit>
        <trans-unit id="43f8cd7ec518821d99337a406b14b6ad25458172" translate="yes" xml:space="preserve">
          <source>Where &amp;lt;tokenizer-name&amp;gt; is &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; to which a string is bound using &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_text()&lt;/a&gt; where the string identifies the tokenizer and &amp;lt;sqlite3_tokenizer_module ptr&amp;gt; is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; to which a BLOB is bound using &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_blob()&lt;/a&gt; where the value of the BLOB is a pointer to an sqlite3_tokenizer_module structure. If the second argument is present, it is registered as tokenizer &amp;lt;tokenizer-name&amp;gt; and a copy of it returned. If only one argument is passed, a pointer to the tokenizer implementation currently registered as &amp;lt;tokenizer-name&amp;gt; is returned, encoded as a blob. Or, if no such tokenizer exists, an SQL exception (error) is raised.</source>
          <target state="translated">ここで、&amp;lt;tokenizer-name&amp;gt;は、&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_text（）&lt;/a&gt;を使用して文字列がバインドされる&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメーター&lt;/a&gt;です。ここで、文字列はトークナイザーを識別し、&amp;lt;sqlite3_tokenizer_module ptr&amp;gt;は、BLOB の値がaである&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_blob（）&lt;/a&gt;を使用してBLOBがバインドされる&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメーター&lt;/a&gt;です。 sqlite3_tokenizer_module構造体へのポインター。 2番目の引数が存在する場合は、トークナイザー&amp;lt;tokenizer-name&amp;gt;として登録され、そのコピーが返されます。引数が1つだけ渡された場合、現在&amp;lt;tokenizer-name&amp;gt;として登録されているトークナイザー実装へのポインターが返され、blobとしてエンコードされます。または、そのようなトークナイザーが存在しない場合、SQL例外（エラー）が発生します。</target>
        </trans-unit>
        <trans-unit id="fe664b79065efef56eb19d94f1c82054f533c78c" translate="yes" xml:space="preserve">
          <source>Where VERSION can be a branch name (like &quot;trunk&quot; or &quot;session&quot;) to get the latest check-in on a specific branch, or VERSION can be a SHA1 hash or a prefix of a SHA1 hash for a specific check-in, or VERSION can be a tag such as &quot;version-3.8.8&quot;. Every time you run &quot;fossil update&quot; it will automatically reach out to the original repository at http://www.sqlite.org/cgi/src to obtain new check-ins that might have been made by others since your previous update.</source>
          <target state="translated">VERSIONは特定のブランチの最新のチェックインを取得するためのブランチ名(&quot;trunk &quot;や &quot;session &quot;など)、VERSIONは特定のチェックインのためのSHA1ハッシュまたはSHA1ハッシュの接頭辞、VERSIONは &quot;version-3.8.8 &quot;のようなタグを指定することができます。fossil update &quot;を実行するたびに、自動的に元のリポジトリ(http://www.sqlite.org/cgi/src)にアクセスして、前回のアップデート以降に他の人が作成した可能性のある新しいチェックインを取得します。</target>
        </trans-unit>
        <trans-unit id="62f2d871248b60ca56135b923987b70f9385647b" translate="yes" xml:space="preserve">
          <source>Where this ends up causing problems is when developers do some initial coding work using SQLite and get their application working, but then try to convert to another database like PostgreSQL or SQL Server for deployment. If the application is initially taking advantage of SQLite's flexible typing, then it will fail when moved to another database that uses a more rigid and unforgiving type enforcement policy.</source>
          <target state="translated">これが問題を引き起こしてしまうのは、開発者がSQLiteを使用して初期コーディング作業を行い、アプリケーションを動作させた後、PostgreSQLやSQL Serverのような別のデータベースに変換してデプロイしようとした場合です。アプリケーションが最初にSQLiteの柔軟な型付けを利用している場合、より厳格で容赦のない型付けポリシーを使用している別のデータベースに移動したときに失敗します。</target>
        </trans-unit>
        <trans-unit id="c5d4b5d864c31b29da8aa7f64d89028ed5c76cfd" translate="yes" xml:space="preserve">
          <source>Whether it is parsing document or query text, any call to xToken that specifies a</source>
          <target state="translated">ドキュメントの解析でもクエリテキストの解析でも、xToken を呼び出して</target>
        </trans-unit>
        <trans-unit id="79b58773d42ad0674454e81345e3b00864854d60" translate="yes" xml:space="preserve">
          <source>Whether or not &quot;char&quot; variables are signed or unsigned.</source>
          <target state="translated">char &quot;変数が符号付きか符号なしか。</target>
        </trans-unit>
        <trans-unit id="927824fe8759e5b1e1a630b01c62f6b1e890e24a" translate="yes" xml:space="preserve">
          <source>Whether or not an error occurs when it is opened, resources associated with the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; handle should be released by passing it to &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt; when it is no longer required.</source>
          <target state="translated">開いたときにエラーが発生するかどうかに関係なく、&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;ハンドルに関連付けられているリソースは、不要になったときに&lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close（）&lt;/a&gt;に渡して解放する必要があります。</target>
        </trans-unit>
        <trans-unit id="568677ded3b331843b99c68cc439cfb12004ddef" translate="yes" xml:space="preserve">
          <source>Whether or not an error occurs when it is opened, resources associated with the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; handle should be released by passing it to &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt; when it is no longer required.</source>
          <target state="translated">開いたときにエラーが発生するかどうかに関係なく、&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;ハンドルに関連付けられているリソースは、不要になったときに&lt;a href=&quot;close&quot;&gt;sqlite3_close（）&lt;/a&gt;に渡して解放する必要があります。</target>
        </trans-unit>
        <trans-unit id="bb05885439d11af94b4bcc3db20e0753f97a131e" translate="yes" xml:space="preserve">
          <source>Whether or not an index or &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic index&lt;/a&gt; is used.</source>
          <target state="translated">インデックスまたは&lt;a href=&quot;optoverview#autoindex&quot;&gt;自動インデックス&lt;/a&gt;を使用するかどうか。</target>
        </trans-unit>
        <trans-unit id="35e3585051eb4909e3fe069dd52d9c306b089c84" translate="yes" xml:space="preserve">
          <source>Whether or not the &lt;a href=&quot;queryplanner#covidx&quot;&gt;covering index&lt;/a&gt; optimization applies.</source>
          <target state="translated">&lt;a href=&quot;queryplanner#covidx&quot;&gt;カバリングインデックスの&lt;/a&gt;最適化が適用されるかどうか。</target>
        </trans-unit>
        <trans-unit id="3f452c9d36fa06b25992734adfdfc328c0c7c82f" translate="yes" xml:space="preserve">
          <source>Whether or not the backup process is restarted as a result of writes to the source database mid-backup, the user can be sure that when the backup operation is completed the backup database contains a consistent and up-to-date snapshot of the original. However:</source>
          <target state="translated">バックアップの途中でソース データベースへの書き込みの結果としてバックアップ プロセスが再起動されるかどうかにかかわらず、ユーザーはバックアップ操作が完了したときに、バックアップ データベースにはオリジナルの一貫した最新のスナップショットが含まれていることを確認することができます。しかし</target>
        </trans-unit>
        <trans-unit id="805314d6ba3c8452666efff3bc4e2e9c11e54c17" translate="yes" xml:space="preserve">
          <source>Whether the table is a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table.</source>
          <target state="translated">テーブルが&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルかどうか。</target>
        </trans-unit>
        <trans-unit id="15cc066f01fd0a8910ef52b96a08c5f23129c75a" translate="yes" xml:space="preserve">
          <source>Which module, FTS3 or FTS4, should you use in your application? FTS4 is sometimes significantly faster than FTS3, even orders of magnitude faster depending on the query, though in the common case the performance of the two modules is similar. FTS4 also offers the enhanced &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; outputs which can be useful in ranking the results of a &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;MATCH&lt;/a&gt; operation. On the other hand, in the absence of a &lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;matchinfo=fts3&lt;/a&gt; directive FTS4 requires a little more disk space than FTS3, though only a percent of two in most cases.</source>
          <target state="translated">アプリケーションで使用する必要があるのは、FTS3またはFTS4のどのモジュールですか？ FTS4はFTS3よりも大幅に高速になる場合があり、クエリによっては桁違いに高速になることもありますが、2つのモジュールのパフォーマンスは同じです。 FTS4 は、&lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;MATCH&lt;/a&gt;操作の結果のランク付けに役立つ拡張された&lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo（）&lt;/a&gt;出力も提供します。一方、&lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;matchinfo = fts3&lt;/a&gt;ディレクティブがない場合、FTS4はFTS3よりも少し多くのディスク領域を必要としますが、ほとんどの場合2％です。</target>
        </trans-unit>
        <trans-unit id="1eaf1dfe15540108a1d6bb4cc98824a6bb754fe0" translate="yes" xml:space="preserve">
          <source>Which of those columns are PRIMARY KEY columns.</source>
          <target state="translated">どのカラムがPRIMARY KEYカラムなのか。</target>
        </trans-unit>
        <trans-unit id="2bf977231fee9d5a01c1d56cb42302f6abc78241" translate="yes" xml:space="preserve">
          <source>Which of those columns make up the tables PRIMARY KEY.</source>
          <target state="translated">どの列がテーブルのPRIMARY KEYを構成しているか。</target>
        </trans-unit>
        <trans-unit id="65190c6c06c3156a5ce50576cd97088b8788cba3" translate="yes" xml:space="preserve">
          <source>Which terms of the WHERE clause are used for indexing.</source>
          <target state="translated">WHERE句のどの語句がインデックスに使われているか。</target>
        </trans-unit>
        <trans-unit id="7d607a9e2bbeeff588fac8037da7b126ad5bde90" translate="yes" xml:space="preserve">
          <source>Which works out to be:</source>
          <target state="translated">どっちがいいのかな?</target>
        </trans-unit>
        <trans-unit id="5778f90619b883572d8c026a15fd3403dfe6662c" translate="yes" xml:space="preserve">
          <source>While SQL is a programming language, it is different from other programming languages like C, Javascript, Python, or Go in that SQL is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Declarative_programming&quot;&gt;declarative language&lt;/a&gt; where the others are &lt;a href=&quot;https://en.wikipedia.org/wiki/Imperative_programming&quot;&gt;imperative languages&lt;/a&gt;. This is an important difference that has implications for the design of the compiler used to translate program source text into an executable format. However, those details should not detract from the fact that SQL is really just another programming language.</source>
          <target state="translated">SQLはプログラミング言語ですが、C、Javascript、Python、Goなどの他のプログラミング言語とは異なり、SQLは&lt;a href=&quot;https://en.wikipedia.org/wiki/Declarative_programming&quot;&gt;宣言型言語&lt;/a&gt;であり、他の&lt;a href=&quot;https://en.wikipedia.org/wiki/Imperative_programming&quot;&gt;言語&lt;/a&gt;は命令型言語です。これは、プログラムのソーステキストを実行可能形式に変換するために使用されるコンパイラの設計に影響を与える重要な違いです。ただし、これらの詳細は、SQLが実際には単なる別のプログラミング言語であるという事実を損なうものであってはなりません。</target>
        </trans-unit>
        <trans-unit id="2ada2cef428bad4df299c966d8cc7b1305373853" translate="yes" xml:space="preserve">
          <source>While a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is open on a WAL-mode database, SQLite maintains an extra journal file called a &quot;Write Ahead Log&quot; or &quot;WAL File&quot;. The name of this file on disk is usually the name of the database file with an extra &quot;&lt;code&gt;-wal&lt;/code&gt;&quot; suffix, though different naming rules may apply if SQLite is compiled with &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES&lt;/a&gt;.</source>
          <target state="translated">一方で&lt;a href=&quot;c3ref/sqlite3&quot;&gt;、データベース接続が&lt;/a&gt; WALモードのデータベースで開いて、SQLiteは、「ログ先行書き込み」または「WALファイル」と呼ばれる追加のジャーナル・ファイルを保持します。ディスク上のこのファイルの名前は、通常、追加の「 &lt;code&gt;-wal&lt;/code&gt; 」サフィックスが付いたデータベースファイルの名前ですが、SQLiteが&lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES&lt;/a&gt;でコンパイルされている場合は、異なる命名規則が適用される場合があります。</target>
        </trans-unit>
        <trans-unit id="d7e2ba9f3191758fdb3ad9b114fa10eb9a4ed3b0" translate="yes" xml:space="preserve">
          <source>While a read transaction is active, any changes to the database that are implemented by separate database connections will not be seen by the database connection that started the read transaction. If database connection X is holding a read transaction, it is possible that some other database connection Y might change the content of the database while X's transaction is still open, however X will not be able to see those changes until after the transaction ends. While its read transaction is active, X will continue to see an historic snapshot of the database prior to the changes implemented by Y.</source>
          <target state="translated">読み取りトランザクションがアクティブな間は、別々のデータベース接続によって実装されたデータベースへの変更は、 読み取りトランザクションを開始したデータベース接続によっては見られません。データベース接続Xが読み取りトランザクションを保持している場合、Xのトランザクションがまだ開いている間に他のデータベース接続Yがデータベースのコンテンツを変更する可能性がありますが、Xはトランザクションが終了するまでそれらの変更を見ることができません。その読み取りトランザクションがアクティブである間、XはYによって実装された変更前のデータベースの歴史的なスナップショットを見続ける。</target>
        </trans-unit>
        <trans-unit id="5ffdc80fe0f26846179a6aaa2eb484325f365e70" translate="yes" xml:space="preserve">
          <source>While a read transaction is active, any changes to the database that are implemented by separate database connections will not be seen by the database connection that started the read transaction. If database connection X is holding a read transaction, it is possible that some other database connection Y might change the content of the database while X's transaction is still open, however X will not be able to see those changes until after the transaction ends. While its read transaction is active, X will continue to see an historic snapshot the database prior to the changes implemented by Y.</source>
          <target state="translated">読み取りトランザクションがアクティブな間は、別々のデータベース接続によって実装されたデータベースへの変更は、 読み取りトランザクションを開始したデータベース接続によっては見られません。データベース接続Xが読み取りトランザクションを保持している場合、Xのトランザクションがまだ開いている間に他のデータベース接続Yがデータベースのコンテンツを変更する可能性がありますが、Xはトランザクションが終了するまでそれらの変更を見ることができません。その読み取りトランザクションがアクティブな間、XはYによって実装された変更前のデータベースの履歴スナップショットを見続ける。</target>
        </trans-unit>
        <trans-unit id="3fc81a6b9eff77dec03d524ff1a744befb138ec8" translate="yes" xml:space="preserve">
          <source>While compiling a single SQL query, the SQLite core might call xBestIndex multiple times with different settings in &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;. The SQLite core will then select the combination that appears to give the best performance.</source>
          <target state="translated">単一のSQLクエリのコンパイル中に、SQLiteコアはsqlite3_index_infoの異なる設定で&lt;a href=&quot;c3ref/index_info&quot;&gt;xBestIndexを&lt;/a&gt;複数回呼び出す場合があります。SQLiteコアは、最高のパフォーマンスを提供するように見える組み合わせを選択します。</target>
        </trans-unit>
        <trans-unit id="d6f8e366ea836d249425f55c0048ab7dd0869350" translate="yes" xml:space="preserve">
          <source>While fuzz testing and 100% MC/DC testing are in tension, they are not completely at cross-purposes. The fact that the SQlite test suite does test to 100% MC/DC means that when fuzzers do find problems, those problems can be fixed quickly and with little risk of introducing new errors.</source>
          <target state="translated">ファズテストと100%MC/DCテストは緊張していますが、完全に対立しているわけではありません。SQliteテスト・スイートが100%MC/DCテストを行うという事実は、ファザーが問題を見つけたときに、新しいエラーを導入するリスクを最小限に抑えて、問題を素早く修正することができることを意味します。</target>
        </trans-unit>
        <trans-unit id="84aa771f4f176659ae1924e0a87ff5ad8203b073" translate="yes" xml:space="preserve">
          <source>While opening a</source>
          <target state="translated">を開きながら</target>
        </trans-unit>
        <trans-unit id="9b36f93bab56bb7da15a9179ec0943945f846c1b" translate="yes" xml:space="preserve">
          <source>While performing</source>
          <target state="translated">演奏中</target>
        </trans-unit>
        <trans-unit id="96921c80759d36f4a04b6a82e193c5ddf054ac5c" translate="yes" xml:space="preserve">
          <source>While the original idea being CVEs is sound, the current processes for creating and managing CVEs are inadequate. There are countless grey-hat hackers running fuzzers against a wide-variety of open-source software products (SQLite as well as many others) and writing up CVEs against any problems they find. The grey-hats are rewarded, sometimes with prestige and sometimes financially, by the number and severity of the CVEs they write. This incentive results in a proliferation of CVEs which are often not well-vetted and which can have exaggerated impact claims. The quality-control procedures for CVEs are unable to cope with this flood of inputs, making it difficult to correct exaggerated, misleading, omitted, or inaccurate claims.</source>
          <target state="translated">CVEという当初の考えは健全ですが、現在のCVEの作成と管理のプロセスは不十分です。グレーハットのハッカーが無数に存在し、様々なオープンソースのソフトウェア製品(SQLiteだけでなく他の多くの製品も)に対してファザーを実行し、発見した問題に対してCVEを書き上げています。グレーハットハッカーは、彼らが書いたCVEの数と深刻さによって、時には名声を得て、時には金銭的な報酬を得ます。このようなインセンティブの結果、よく吟味されていないことが多く、影響度の主張が誇張されている可能性のある CVE が増殖することになる。CVE の品質管理手順は、このような大量の入力に対応できず、誇張された、誤解を招く、省略された、または不正確なクレームを修正することが困難になっている。</target>
        </trans-unit>
        <trans-unit id="3a93a15284084502a7f86f4c9b90c793ee720848" translate="yes" xml:space="preserve">
          <source>While the queue is not empty:</source>
          <target state="translated">キューが空でない間は</target>
        </trans-unit>
        <trans-unit id="31d87d7be7b237cc74cece1001ddf141c8c0c304" translate="yes" xml:space="preserve">
          <source>Whitespace and comment tokens are discarded. All other tokens are fed into an &lt;a href=&quot;https://en.wikipedia.org/wiki/LALR_parser&quot;&gt;LALR(1) Parser&lt;/a&gt; that analysis the structure of the input program and generates an &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;Abstract Syntax Tree (AST)&lt;/a&gt; for the input program.</source>
          <target state="translated">空白とコメントトークンは破棄されます。他のすべてのトークンは、入力プログラムの構造を分析し、入力プログラムの&lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;抽象構文木（AST）&lt;/a&gt;を生成する&lt;a href=&quot;https://en.wikipedia.org/wiki/LALR_parser&quot;&gt;LALR（1）パーサーに&lt;/a&gt;送られます。</target>
        </trans-unit>
        <trans-unit id="b875e5298cf6263e72c1bc4d0e00a3e4a13f0a5d" translate="yes" xml:space="preserve">
          <source>Whitespace or comments.</source>
          <target state="translated">空白またはコメント。</target>
        </trans-unit>
        <trans-unit id="4d2467596fdde02a218277dc3baed1d04b31fd9e" translate="yes" xml:space="preserve">
          <source>Why ALTER TABLE is so difficult</source>
          <target state="translated">ALTER TABLEが難しい理由</target>
        </trans-unit>
        <trans-unit id="a66e4df98a00d586d77ff8cbda05b1bb33741627" translate="yes" xml:space="preserve">
          <source>Why ALTER TABLE is such a problem for SQLite</source>
          <target state="translated">ALTER TABLEがSQLiteで問題になる理由</target>
        </trans-unit>
        <trans-unit id="51671cd80abfeae9d7b51e113f2b9ee1f5d2c38e" translate="yes" xml:space="preserve">
          <source>Why Is SQLite Coded In C</source>
          <target state="translated">なぜSQLiteはC言語でコード化されているのか</target>
        </trans-unit>
        <trans-unit id="a50fb31b169e8e4d9b4a6643f7f8608e036bc60b" translate="yes" xml:space="preserve">
          <source>Why SQLite Does Not Use Git</source>
          <target state="translated">SQLiteがGitを使わない理由</target>
        </trans-unit>
        <trans-unit id="cf48c0996bab18f4950cd87af9617143917f12a9" translate="yes" xml:space="preserve">
          <source>Why didn't the legacy query planner choose algorithm-2? Easy: because the NN algorithm never even considered algorithm-2. Graphs of the planning problem look like this:</source>
          <target state="translated">なぜレガシーのクエリプランナーはアルゴリズム2を選択しなかったのでしょうか?それは簡単です:NNアルゴリズムがアルゴリズム2を考慮していなかったからです。計画問題のグラフは次のようになります</target>
        </trans-unit>
        <trans-unit id="f9ddc1f9321acc62d313f21bd009fd732a7ca677" translate="yes" xml:space="preserve">
          <source>Why does ROUND(9.95,1) return 9.9 instead of 10.0? Shouldn't 9.95 round up?</source>
          <target state="translated">ROUND(9.95,1)が10.0ではなく9.9を返すのはなぜですか?9.95は丸めてはいけないのでしょうか?</target>
        </trans-unit>
        <trans-unit id="cf08e93e3998487d5a4514d0ec927b65fe1810fa" translate="yes" xml:space="preserve">
          <source>Why does SQLite have its own private built-in printf() implementation? Why not use the printf() implementation from the standard C library? Several reasons:</source>
          <target state="translated">なぜ SQLite は独自のプライベートな組み込みの printf()実装を持っているのですか?なぜ標準の C ライブラリの printf()の実装を使わないのでしょうか?いくつかの理由があります。</target>
        </trans-unit>
        <trans-unit id="1ec9acf7734149243e8c44660fc685f0eb23a630" translate="yes" xml:space="preserve">
          <source>Why doesn't SQLite allow me to use '0' and '0.0' as the primary key on two different rows of the same table?</source>
          <target state="translated">なぜSQLiteでは、同じテーブルの2つの異なる行で'0'と'0.0'を主キーとして使用できないのですか?</target>
        </trans-unit>
        <trans-unit id="02275b1d64f346b7ea26ca7a800967bbade4e5f6" translate="yes" xml:space="preserve">
          <source>Win32 Directory Types</source>
          <target state="translated">Win32ディレクトリの種類</target>
        </trans-unit>
        <trans-unit id="0463d1ccc9613d5098c42774fc7e43131ce95d1e" translate="yes" xml:space="preserve">
          <source>Win32 Specific Interface</source>
          <target state="translated">ウィン32固有インタフェース</target>
        </trans-unit>
        <trans-unit id="f8b7523500f54721211a692b3d6b968bab3101a5" translate="yes" xml:space="preserve">
          <source>Win32 native memory allocator</source>
          <target state="translated">ウィン32ネイティブメモリアロケータ</target>
        </trans-unit>
        <trans-unit id="68fe8f958724479a101c0326f7607d389d321758" translate="yes" xml:space="preserve">
          <source>Window Functions</source>
          <target state="translated">ウィンドウ機能</target>
        </trans-unit>
        <trans-unit id="7973e6ebbc857b7bb0de6b349ffa9e99bc62f773" translate="yes" xml:space="preserve">
          <source>Window chaining</source>
          <target state="translated">ウィンドウチェーン</target>
        </trans-unit>
        <trans-unit id="99565b4d7904c206a1623d09463276b2f7b9b151" translate="yes" xml:space="preserve">
          <source>Window chaining is a shorthand that allows one window to be defined in terms of another. Specifically, the shorthand allows the new window to implicitly copy the PARTITION BY and optionally ORDER BY clauses of the base window. For example, in the following:</source>
          <target state="translated">ウィンドウチェーニングとは、あるウィンドウを別のウィンドウで定義することを可能にする略記法です。具体的には、この短縮記法により、新しいウィンドウがベースのウィンドウのPARTITION BY句と任意でORDER BY句を暗黙的にコピーすることが可能になります。例えば、次のようになります。</target>
        </trans-unit>
        <trans-unit id="34aa1477a928d2146e07a6620c66855ebe78ae81" translate="yes" xml:space="preserve">
          <source>Window function support was first added to SQLite with release &lt;a href=&quot;https://sqlite.org/releaselog/3_25_0.html&quot;&gt;version 3.25.0&lt;/a&gt; (2018-09-15). The SQLite developers used the &lt;a href=&quot;http://www.postgresql.org&quot;&gt;PostgreSQL&lt;/a&gt; window function documentation as their primary reference for how window functions ought to behave. Many test cases have been run against PostgreSQL to ensure that window functions operate the same way in both SQLite and PostgreSQL.</source>
          <target state="translated">ウィンドウ関数のサポートは、最初にリリース&lt;a href=&quot;https://sqlite.org/releaselog/3_25_0.html&quot;&gt;バージョン3.25.0&lt;/a&gt;（2018-09-15）でSQLiteに追加されました。 SQLiteの開発者は、ウィンドウ関数の動作に関する主要なリファレンスとして、&lt;a href=&quot;http://www.postgresql.org&quot;&gt;PostgreSQL&lt;/a&gt;ウィンドウ関数のドキュメントを使用しました。ウィンドウ関数がSQLiteとPostgreSQLの両方で同じように動作することを確認するために、PostgreSQLに対して多くのテストケースが実行されています。</target>
        </trans-unit>
        <trans-unit id="cec65d78532248828b5443e4752a3df7fc4931aa" translate="yes" xml:space="preserve">
          <source>Window functions</source>
          <target state="translated">ウィンドウ機能</target>
        </trans-unit>
        <trans-unit id="b37157f249f48370ca58b2cacca1806dc4feec9b" translate="yes" xml:space="preserve">
          <source>Window functions are distinguished from other SQL functions by the presence of an OVER clause. If a function has an OVER clause, then it is a window function. If it lacks an OVER clause, then it is an ordinary aggregate or scalar function. Window functions might also have a FILTER clause in between the function and the OVER clause.</source>
          <target state="translated">ウィンドウ関数は、OVER句の存在によって他のSQL関数と区別されます。関数にOVER句がある場合、それはウィンドウ関数です。もしOVER句がない場合は、それは通常の集約関数またはスカラ関数です。ウィンドウ関数は、関数とOVER句の間にFILTER句を持つこともあります。</target>
        </trans-unit>
        <trans-unit id="768669bfb2a31bdc0b9e7999f08750dacabe9b82" translate="yes" xml:space="preserve">
          <source>Window functions come in two varieties: &lt;a href=&quot;windowfunctions#aggwinfunc&quot;&gt;aggregate window functions&lt;/a&gt; and &lt;a href=&quot;windowfunctions#builtins&quot;&gt;built-in window functions&lt;/a&gt;. Every aggregate window function can also work as a ordinary aggregate function, simply by omitting the OVER and FILTER clauses. Furthermore, all of the built-in &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate functions&lt;/a&gt; of SQLite can be used as an aggregate window function by adding an appropriate OVER clause. Applications can register new aggregate window functions using the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_window_function()&lt;/a&gt; interface. The built-in window functions, however, require special-case handling in the query planner and hence new window functions that exhibit the exceptional properties found in the built-in window functions cannot be added by the application.</source>
          <target state="translated">ウィンドウ関数には、&lt;a href=&quot;windowfunctions#aggwinfunc&quot;&gt;集約ウィンドウ関数&lt;/a&gt;と&lt;a href=&quot;windowfunctions#builtins&quot;&gt;組み込み&lt;/a&gt;ウィンドウ関数の 2種類があります。すべての集計ウィンドウ関数は、単にOVER句とFILTER句を省略するだけで、通常の集計関数としても機能します。さらに、適切なOVER句を追加することで、SQLiteのすべての組み込み&lt;a href=&quot;lang_aggfunc&quot;&gt;集計関数&lt;/a&gt;を集計ウィンドウ関数として使用できます。アプリケーションは、&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_window_function（）&lt;/a&gt;インターフェイスを使用して、新しい集計ウィンドウ関数を登録できます。ただし、組み込みのウ​​ィンドウ関数は、クエリプランナーでの特殊なケースの処理を必要とするため、組み込みのウ​​ィンドウ関数にある例外的なプロパティを示す新しいウィンドウ関数をアプリケーションで追加することはできません。</target>
        </trans-unit>
        <trans-unit id="b69a0cc5bc93433662122b7ab877cc01de2fc8c1" translate="yes" xml:space="preserve">
          <source>Windows DLL exports symbols Tclsqlite_Init and Sqlite_Init</source>
          <target state="translated">Windows DLLはシンボルTclsqlite_InitとSqlite_Initをエクスポートします。</target>
        </trans-unit>
        <trans-unit id="a3320dd4ff96aeb28c32b1c618d2fdc870a0f410" translate="yes" xml:space="preserve">
          <source>Windows builds also come with multiple built-in VFSes. The default Windows VFS is called &quot;win32&quot; and is used in most applications. Other VFSes that might be found on windows builds include:</source>
          <target state="translated">Windows ビルドには、複数の内蔵 VFS も付属しています。デフォルトの Windows VFS は「win32」と呼ばれ、ほとんどのアプリケーションで使用されています。Windows ビルドで見られる他の VFS には、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="84eca34acba80a1cc2933e50280e69e2f20b7bbc" translate="yes" xml:space="preserve">
          <source>Windows is unable to truncate a memory-mapped file. Hence, on Windows, if an operation such as &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; or &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; tries to reduce the size of a memory-mapped database file, the size reduction attempt will silently fail, leaving unused space at the end of the database file. No data is lost due to this problem, and the unused space will be reused again the next time the database grows. However if a version of SQLite prior to 3.7.0 runs &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; on such a database, it will (incorrectly) report database corruption due to the unused space at the end. Or if a version of SQLite prior to 3.7.0 writes to the database while it still has unused space at the end, it may make that unused space inaccessible and unavailable for reuse until after the next &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;.</source>
          <target state="translated">Windowsは、メモリマップファイルを切り捨てることができません。したがって、Windowsでは、&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;や&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt;などの操作がメモリマップされたデータベースファイルのサイズを縮小しようとすると、サイズ縮小の試行が失敗し、データベースファイルの末尾に未使用のスペースが残ります。この問題が原因でデータが失われることはありません。未使用のスペースは、次にデータベースが大きくなったときに再利用されます。ただし、3.7.0より前のバージョンのSQLite がそのようなデータベースで&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA&lt;/a&gt; integer_checkを実行すると、最後に未使用のスペースが原因でデータベースの破損が（誤って）レポートされます。または、3.7.0より前のバージョンのSQLiteが最後に未使用のスペースを持っている間にデータベースに書き込みを行うと、その未使用のスペースにアクセスできなくなり、次のスペースまで再利用できなくなります。&lt;a href=&quot;lang_vacuum&quot;&gt;真空&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3b7712d1cb131a2adfefe7d588175fadb48dafa7" translate="yes" xml:space="preserve">
          <source>Windows only: Open the file &quot;data.db&quot; on fred's desktop on drive C:. Note that the %20 escaping in this example is not strictly necessary - space characters can be used literally in URI filenames.</source>
          <target state="translated">Windowsのみ。Windows のみ:fred のデスクトップ上のドライブ C:にあるファイル &quot;data.db&quot; を開きます。この例の %20 エスケープは厳密には必要ではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="31aeba611599f329aa343c65bc0c86921ffe7f9d" translate="yes" xml:space="preserve">
          <source>Windows users can double-click on the &lt;b&gt;sqlite3.exe&lt;/b&gt; icon to cause the command-line shell to pop-up a terminal window running SQLite. However, because double-clicking starts the sqlite3.exe without command-line arguments, no database file will have been specified, so SQLite will use a temporary database that is deleted when the session exits. To use a persistent disk file as the database, enter the &quot;.open&quot; command immediately after the terminal window starts up:</source>
          <target state="translated">Windowsユーザーは、&lt;b&gt;sqlite3.exe&lt;/b&gt;アイコンをダブルクリックして、コマンドラインシェルにSQLiteを実行しているターミナルウィンドウをポップアップさせることができます。ただし、ダブルクリックするとコマンドライン引数なしでsqlite3.exeが開始されるため、データベースファイルは指定されていないため、SQLiteはセッションの終了時に削除される一時データベースを使用します。永続ディスクファイルをデータベースとして使用するには、ターミナルウィンドウの起動直後に「.open」コマンドを入力します。</target>
        </trans-unit>
        <trans-unit id="46ae0e9a494aaadddce1ec0fa75065f4b23d237d" translate="yes" xml:space="preserve">
          <source>With SQLite (but not any other SQL implementation that we know of) if an aggregate query contains a single min() or max() function, then the values of columns used in the output are taken from the row where the min() or max() value was achieved. If two or more rows have the same min() or max() value, then the columns values will be chosen arbitrarily from one of those rows.</source>
          <target state="translated">SQLite (私たちが知っている他の SQL 実装ではありません)では、集約クエリが単一の min()あるいは max()関数を含んでいる場合、出力で使用されるカラムの値は、 min()あるいは max()の値が達成された行から取得されます。同じ min()あるいは max()値を持つ行が 2 つ以上ある場合、カラムの値はそれらの行のうちの 1 つから任意に選択されます。</target>
        </trans-unit>
        <trans-unit id="72d650183743377687d259d65b2b0b1477f3b0e4" translate="yes" xml:space="preserve">
          <source>With a covering index, SQLite can simply walk the index from one end to the other and deliver the output in time proportional to N and without having allocate a large buffer to hold the result set.</source>
          <target state="translated">カバーリングインデックスを使用すると、SQLiteはインデックスを端から端まで単純にウォークさせて、Nに比例した時間で出力することができ、結果セットを保持するための大規模なバッファを割り当てる必要がありません。</target>
        </trans-unit>
        <trans-unit id="ffbb132debbaa76f4f42bce9a72aacb1ba449100" translate="yes" xml:space="preserve">
          <source>With a single allocation size, the &lt;b&gt;n&lt;/b&gt; parameter in the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt; is 1, and the total memory space required by the allocator (&lt;b&gt;N&lt;/b&gt;) is exactly equal to maximum memory used (&lt;b&gt;M&lt;/b&gt;). No additional memory is required to cover fragmentation overhead, thus reducing memory requirements. This is particularly important for the page cache memory since the page cache constitutes the largest component of the memory needs of SQLite.</source>
          <target state="translated">単一の割り当てサイズの場合、&lt;a href=&quot;malloc#nofrag&quot;&gt;ロブソン証明の&lt;/a&gt;&lt;b&gt;n&lt;/b&gt;パラメーターは1であり、アロケーターが必要とする合計メモリスペース（&lt;b&gt;N&lt;/b&gt;）は、使用される最大メモリ（&lt;b&gt;M&lt;/b&gt;）とまったく同じです。断片化のオーバーヘッドをカバーするために追加のメモリは必要ないため、メモリ要件が軽減されます。ページキャッシュはSQLiteのメモリニーズの最大のコンポーネントを構成するため、これはページキャッシュメモリにとって特に重要です。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a552e4d61e6c98e72a1a99aa574976a695fc5369" translate="yes" xml:space="preserve">
          <source>With asynchronous I/O, write requests are handled by a separate thread running in the background. This means that the thread that initiates a database write does not have to wait for (sometimes slow) disk I/O to occur. The write seems to happen very quickly, though in reality it is happening at its usual slow pace in the background.</source>
          <target state="translated">非同期I/Oでは、書き込み要求はバックグラウンドで動作する別のスレッドによって処理されます。これは、データベースへの書き込みを開始するスレッドは、ディスクI/Oが発生するまで(時には遅い)待つ必要がないことを意味します。書き込みは非常に速く行われているように見えますが、実際にはバックグラウンドで通常のスローペースで行われています。</target>
        </trans-unit>
        <trans-unit id="ab9e7dc76b3ad69724eb79aea2faff0ba6d5b557" translate="yes" xml:space="preserve">
          <source>With client/server databases like PostgreSQL or Oracle, users and developers tend to think of the database as a service or a &quot;node&quot;, not as an object. This is because the database content is spread out across multiple files on the server, or possibly across multiple servers in a service cluster. One cannot point to a single file or even a single directory and say &quot;this is the database&quot;.</source>
          <target state="translated">PostgreSQLやOracleのようなクライアント/サーバ型データベースでは、ユーザや開発者はデータベースをオブジェクトとしてではなく、サービスや「ノード」として考える傾向があります。これは、データベースの内容がサーバ上の複数のファイルに分散していたり、サービスクラスタ内の複数のサーバに分散していたりするからです。一つのファイルや一つのディレクトリを指して「これがデータベースです」と言うことはできません。</target>
        </trans-unit>
        <trans-unit id="9f913fbcf0e843248e92480f5555045919a3653f" translate="yes" xml:space="preserve">
          <source>With one exception noted below, if a rowid table has a primary key that consists of a single column and the declared type of that column is &quot;INTEGER&quot; in any mixture of upper and lower case, then the column becomes an alias for the rowid. Such a column is usually referred to as an &quot;integer primary key&quot;. A PRIMARY KEY column only becomes an integer primary key if the declared type name is exactly &quot;INTEGER&quot;. Other integer type names like &quot;INT&quot; or &quot;BIGINT&quot; or &quot;SHORT INTEGER&quot; or &quot;UNSIGNED INTEGER&quot; causes the primary key column to behave as an ordinary table column with integer &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt; and a unique index, not as an alias for the rowid.</source>
          <target state="translated">以下に示す1つの例外を除き、ROWIDテーブルに単一の列で構成される主キーがあり、その列の宣言された型が大文字と小文字が混在する「INTEGER」である場合、列はROWIDのエイリアスになります。このような列は通常、「整数主キー」と呼ばれます。 PRIMARY KEY列は、宣言された型名が正確に「INTEGER」である場合にのみ、整数の主キーになります。 「INT」、「BIGINT」、「SHORT INTEGER」、「UNSIGNED INTEGER」などの他の整数型名は、主キー列が、ROWIDのエイリアスとしてではなく、整数&lt;a href=&quot;datatype3#affinity&quot;&gt;親和性&lt;/a&gt;と一意のインデックスを持つ通常のテーブル列として動作します。</target>
        </trans-unit>
        <trans-unit id="6d08bbd760872d68db33d3c86cf4e679c7a2ebc9" translate="yes" xml:space="preserve">
          <source>With release 3.8.0 (2013-08-26), the SQLite query planner was reimplemented as the &lt;a href=&quot;queryplanner-ng&quot;&gt;Next Generation Query Planner&lt;/a&gt; or &quot;NGQP&quot;. All of the features, techniques, and algorithms described in this document are applicable to both the pre-3.8.0 legacy query planner and to the NGQP. For further information on how the NGQP differs from the legacy query planner, see the &lt;a href=&quot;queryplanner-ng&quot;&gt;detailed description of the NGQP&lt;/a&gt;.</source>
          <target state="translated">リリース3.8.0（2013-08-26）では、SQLiteクエリプランナーが&lt;a href=&quot;queryplanner-ng&quot;&gt;次世代クエリプランナー&lt;/a&gt;または「NGQP」として再実装されました。このドキュメントで説明されているすべての機能、手法、アルゴリズムは、3.8.0より前のレガシークエリプランナーとNGQPの両方に適用できます。 NGQPがレガシークエリプランナーとどのように異なるかについての&lt;a href=&quot;queryplanner-ng&quot;&gt;詳細は、NGQPの詳細な説明を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d1d01005af669e498a6d79c05e376c2142afd701" translate="yes" xml:space="preserve">
          <source>With some (arbitrary) data, such a table might be logically stored on disk as shown in figure 1:</source>
          <target state="translated">ある種の(任意の)データでは、そのようなテーブルは、図1に示すように、論理的にディスクに格納されるかもしれない。</target>
        </trans-unit>
        <trans-unit id="fd1021b066f8f1badfb5950e8af5b888b38dc724" translate="yes" xml:space="preserve">
          <source>With source code files in the working directory, a DLL can be generated using MSVC with the following command:</source>
          <target state="translated">作業ディレクトリにソースコードファイルがあれば、以下のコマンドでMSVCを使用してDLLを生成することができます。</target>
        </trans-unit>
        <trans-unit id="0f39e53b1be71b4fb78a20a47e590c12ddf0bcbb" translate="yes" xml:space="preserve">
          <source>With such a schema, the application would no longer need to make periodic backups of the unsaved changes to a separate file to avoid lost work in the event of a crash. Instead, a special &quot;pending&quot; version could be allocated and unsaved changes could be written into the pending version. Because only changes would need to be written, not the entire document, saving the pending changes would only involve writing a few kilobytes of content, not multiple megabytes, and would take milliseconds instead of seconds, and so it could be done frequently and silently in the background. Then when a crash occurs and the user reboots, all (or almost all) of their work is retained. If the user decides to discard unsaved changes, they simply go back to the previous version.</source>
          <target state="translated">このようなスキーマがあれば、アプリケーションは、クラッシュ時に作業が失われるのを避けるために、保存されていない変更を別のファイルに定期的にバックアップする必要がなくなります。その代わりに、特別な「保留中」のバージョンを割り当てて、保存されていない変更を保留中のバージョンに書き込むことができます。ドキュメント全体ではなく、変更のみを書き込む必要があるため、保留中の変更を保存するには、複数のメガバイトではなく数キロバイトのコンテンツを書き込むだけで済み、数秒ではなくミリ秒で済むため、頻繁にバックグラウンドで静かに行うことができます。その後、クラッシュが発生してユーザーが再起動すると、すべての(またはほぼすべての)作業が保持されます。ユーザーが保存されていない変更を破棄する場合は、単に前のバージョンに戻るだけです。</target>
        </trans-unit>
        <trans-unit id="1152f09445e7a27bd0f86b5f6b1e7dc6ef22ecb9" translate="yes" xml:space="preserve">
          <source>With synchronous OFF (0), SQLite continues without syncing as soon as it has handed data off to the operating system. If the application running SQLite crashes, the data will be safe, but the database &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;might become corrupted&lt;/a&gt; if the operating system crashes or the computer loses power before that data has been written to the disk surface. On the other hand, commits can be orders of magnitude faster with synchronous OFF.</source>
          <target state="translated">同期がオフ（0）の場合、SQLiteは、オペレーティングシステムにデータを渡すとすぐに同期せずに続行します。 SQLiteを実行しているアプリケーションがクラッシュした場合、データは安全ですが、オペレーティングシステムがクラッシュしたり、データがディスク表面に書き込まれる前にコンピューターが電源を失ったりする&lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;と&lt;/a&gt;、データベースが破損する可能性があります。一方、同期は同期オフの方が桁違いに速くなります。</target>
        </trans-unit>
        <trans-unit id="6e05518cdffbac366023e6a7a1a6316fad89e6a6" translate="yes" xml:space="preserve">
          <source>With the Idx3 index on both columns that are constrained by the WHERE clause, SQLite can do a single binary search against Idx3 to find the one rowid for California oranges, then do a single binary search to find the price for that item in the original table. There are no dead-ends and no wasted binary searches. This is a more efficient query.</source>
          <target state="translated">WHERE 節で制約されている両方の列の Idx3 インデックスを使用すると、SQLite は Idx3 に対して単一のバイナリ検索を行い、California oranges の行 ID を見つけ、その後、元のテーブルでそのアイテムの価格を見つけるために単一のバイナリ検索を行うことができます。デッドエンドや無駄なバイナリ検索はありません。これは、より効率的なクエリです。</target>
        </trans-unit>
        <trans-unit id="d0ccef83367809507d68fd8adf10ab43756d4053" translate="yes" xml:space="preserve">
          <source>With the following provisos, each series of tokens in the FTS table that matches one of the matchable phrases in the query expression is known as a &quot;phrase match&quot;:</source>
          <target state="translated">以下の証明書により、FTSテーブル内のトークンの各シリーズは、クエリ式の中のマッチ可能な フレーズの1つにマッチし、「フレーズマッチ」として知られています。</target>
        </trans-unit>
        <trans-unit id="6be83cc240990bde696822c8c968c954935effd4" translate="yes" xml:space="preserve">
          <source>With the schema above, a statement of the form:</source>
          <target state="translated">上記のスキーマでは、形式のステートメント。</target>
        </trans-unit>
        <trans-unit id="ce7e1668aa6ca5e4002b24e2ec5db69485e9af33" translate="yes" xml:space="preserve">
          <source>With this pattern, the overall system is still client/server: clients send requests to the server and get back replies over the network. But instead of sending generic SQL and getting back raw table content, the client requests and server responses are high-level and application-specific. The server translates requests into multiple SQL queries, gathers the results, does post-processing, filtering, and analysis, then constructs a high-level reply containing only the essential information.</source>
          <target state="translated">このパターンでは、全体的なシステムはクライアント/サーバーのままで、クライアントがサーバーにリクエストを送信し、ネットワーク経由で応答を返します。しかし、一般的なSQLを送信して生のテーブルコンテンツを返すのではなく、クライアントのリクエストとサーバのレスポンスは高レベルでアプリケーションに特化したものになります。サーバはリクエストを複数の SQL クエリに変換し、結果を収集し、後処理、フィルタリング、分析を行い、必要な情報のみを含む高レベルの応答を作成します。</target>
        </trans-unit>
        <trans-unit id="a6cde545c87cfe9cdf5083a11aa7253d12946e88" translate="yes" xml:space="preserve">
          <source>With this table, the statement</source>
          <target state="translated">このテーブルでは、ステートメント</target>
        </trans-unit>
        <trans-unit id="e3d30043cb29ededf7f5c7d45d7c85af41b7ac41" translate="yes" xml:space="preserve">
          <source>With this trigger installed, executing the statement:</source>
          <target state="translated">このトリガーがインストールされている状態で、ステートメントを実行します。</target>
        </trans-unit>
        <trans-unit id="b738f8fb3971eaf9d8b4464f7e01335910aa51fd" translate="yes" xml:space="preserve">
          <source>With tracing mode on, the VDBE prints each instruction prior to executing it. After the instruction is executed, the top few entries in the stack are displayed. The stack display is omitted if the stack is empty.</source>
          <target state="translated">トレーシング・モードがオンの場合、VDBEは各命令を実行する前に印刷する。命令が実行された後、スタックの上位数エントリが表示される。スタックが空の場合はスタック表示は省略されます。</target>
        </trans-unit>
        <trans-unit id="bdf14e9c4b4688dcd43209a6bc661b4142ea27d9" translate="yes" xml:space="preserve">
          <source>With two exceptions, a</source>
          <target state="translated">2つの例外を除いて</target>
        </trans-unit>
        <trans-unit id="bb5693991e33e1156b62932972a48bb594da454a" translate="yes" xml:space="preserve">
          <source>Within a changeset generated by this function, all changes related to a single table are grouped together. In other words, when iterating through a changeset or when applying a changeset to a database, all changes related to a single table are processed before moving on to the next table. Tables are sorted in the same order in which they were attached (or auto-attached) to the sqlite3_session object. The order in which the changes related to a single table are stored is undefined.</source>
          <target state="translated">この関数によって生成されたチェンジセット内では、単一のテーブルに関連するすべての変更がグループ化されます。言い換えれば、チェンジセットを反復処理するとき、またはデータベースにチェンジセットを適用するとき、1つのテーブルに関連するすべての変更は次のテーブルに移動する前に処理されます。テーブルは、sqlite3_sessionオブジェクトにアタッチされた(または自動アタッチされた)順序でソートされます。1つのテーブルに関連する変更が保存される順序は定義されていません。</target>
        </trans-unit>
        <trans-unit id="e69d76786ab7b8d267ef6f99888893212d52b234" translate="yes" xml:space="preserve">
          <source>Within a single database connection X, a SELECT statement always sees all changes to the database that are completed prior to the start of the SELECT statement, whether committed or uncommitted. And the SELECT statement obviously does not see any changes that occur after the SELECT statement completes. But what about changes that occur while the SELECT statement is running? What if a SELECT statement is started and the &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface steps through roughly half of its output, then some &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statements are run by the application that modify the table that the SELECT statement is reading, then more calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; are made to finish out the SELECT statement? Will the later steps of the SELECT statement see the changes made by the UPDATE or not? The answer is that this behavior is undefined. In particular, whether or not the SELECT statement sees the concurrent changes depends on which release of SQLite is running, the schema of the database file, whether or not &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; has been run, and the details of the query. In some cases, it might depend on the content of the database file, too. There is no good way to know whether or not a SELECT statement will see changes that were made to the database by the same database connection after the SELECT statement was started. And hence, developers should diligently avoid writing applications that make assumptions about what will occur in that circumstance.</source>
          <target state="translated">単一のデータベース接続X内では、SELECTステートメントは、コミットされているかどうかにかかわらず、SELECTステートメントの開始前に完了したデータベースへのすべての変更を常に確認します。また、SELECTステートメントでは、SELECTステートメントの完了後に発生する変更は明らかにわかりません。しかし、SELECTステートメントの実行中に発生する変更についてはどうでしょうか。 SELECTステートメントが開始され、&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;インターフェースがその出力の約半分をステップスルーすると、SELECTステートメントが読み取っているテーブルを変更するアプリケーションによっていくつかの&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;ステートメントが実行され、その後、&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;への呼び出しが増えます。SELECTステートメントを完了するために作られていますか？ SELECTステートメントの後のステップで、UPDATEによって行われた変更を確認できますか？答えは、この動作は未定義であるということです。特に、SELECTステートメントが同時変更を認識するかどうかは、SQLiteのどのリリースが実行されているか、データベースファイルのスキーマ、&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;が実行されているかどうか、およびクエリの詳細によって異なります。場合によっては、データベースファイルの内容にも依存することがあります。 SELECTステートメントが開始された後、同じデータベース接続によってデータベースに加えられた変更がSELECTステートメントに表示されるかどうかを確認する適切な方法はありません。したがって、開発者はその状況で何が発生するかを想定したアプリケーションを作成することを熱心に避ける必要があります。</target>
        </trans-unit>
        <trans-unit id="f64c1e27b35be2c65501356f86b040f4e01382a8" translate="yes" xml:space="preserve">
          <source>Within a trigger program each INSERT, UPDATE and DELETE statement sets the value returned by sqlite3_changes() upon completion as normal. Of course, this value will not include any changes performed by sub-triggers, as the sqlite3_changes() value will be saved and restored after each sub-trigger has run.</source>
          <target state="translated">トリガプログラム内で、各INSERT、UPDATE、DELETE文は、通常のように完了時にsqlite3_changes()によって返される値を設定します。もちろん、この値は、サブトリガーによって実行された変更を含まないので、sqlite3_changes()の値は保存され、各サブトリガーが実行された後に復元されます。</target>
        </trans-unit>
        <trans-unit id="a4a4a7b77632610d5c03098170087135a035d198" translate="yes" xml:space="preserve">
          <source>Within an FTS expression a &lt;b&gt;string&lt;/b&gt; may be specified in one of two ways:</source>
          <target state="translated">FTS式内では、&lt;b&gt;文字列&lt;/b&gt;は次の2つの方法のいずれかで指定できます。</target>
        </trans-unit>
        <trans-unit id="b69cb3df5f10a8834e6c84cc69fe995f5e513c1e" translate="yes" xml:space="preserve">
          <source>Within an interior b-tree page, each key and the pointer to its immediate left are combined into a structure called a &quot;cell&quot;. The right-most pointer is held separately. A leaf b-tree page has no pointers, but it still uses the cell structure to hold keys for index b-trees or keys and content for table b-trees. Data is also contained in the cell.</source>
          <target state="translated">内部のb-treeページ内では、各キーとそのすぐ左へのポインタは「セル」と呼ばれる構造体に結合されます。右端のポインタは別々に保持されます。リーフ b-tree ページにはポインタはありませんが、インデックス b-tree のキーやテーブル b-tree のキーやコンテンツを保持するためにセル構造を使用しています。データもセルに含まれている。</target>
        </trans-unit>
        <trans-unit id="e7e979d6674438107ff98232bc172bfe9db221b4" translate="yes" xml:space="preserve">
          <source>Within the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;, the sqlite3_value_nochange(X) interface returns true if and only if the column corresponding to X is unchanged by the UPDATE operation that the xUpdate method call was invoked to implement and if and the prior &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method call that was invoked to extracted the value for that column returned without setting a result (probably because it queried &lt;a href=&quot;vtab_nochange&quot;&gt;sqlite3_vtab_nochange()&lt;/a&gt; and found that the column was unchanging). Within an &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method, any value for which sqlite3_value_nochange(X) is true will in all other respects appear to be a NULL value. If sqlite3_value_nochange(X) is invoked anywhere other than within an &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method call for an UPDATE statement, then the return value is arbitrary and meaningless.</source>
          <target state="translated">内&lt;a href=&quot;../vtab#xupdate&quot;&gt;のXUpdate&lt;/a&gt;の方法&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;、sqlite3_value_nochange（X）インターフェイスが真とXに対応する列は、のXUpdateメソッド呼び出しを実装するために呼び出されたことをUPDATE操作によって変更されない場合のみとIF前&lt;a href=&quot;../vtab#xcolumn&quot;&gt;Xcolumnには&lt;/a&gt;、そのメソッド呼び出し結果を設定せずに返されたその列の値を抽出するために呼び出されました（おそらく&lt;a href=&quot;vtab_nochange&quot;&gt;sqlite3_vtab_nochange（）&lt;/a&gt;を照会し、列が変更されていないことが判明したためです）。&lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;メソッド内で、sqlite3_value_nochange（X）がtrueである値は、他のすべての点でNULL値のように見えます。 sqlite3_value_nochange（X）が&lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;内以外の場所で呼び出された場合UPDATEステートメントのメソッド呼び出しの場合、戻り値は任意で無意味です。</target>
        </trans-unit>
        <trans-unit id="6789b1bae7cd2bb76c0159019d7d9fbb4d93f85d" translate="yes" xml:space="preserve">
          <source>Within the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;, the sqlite3_value_nochange(X) interface returns true if and only if the column corresponding to X is unchanged by the UPDATE operation that the xUpdate method call was invoked to implement and if and the prior &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method call that was invoked to extracted the value for that column returned without setting a result (probably because it queried &lt;a href=&quot;#sqlite3_vtab_nochange&quot;&gt;sqlite3_vtab_nochange()&lt;/a&gt; and found that the column was unchanging). Within an &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method, any value for which sqlite3_value_nochange(X) is true will in all other respects appear to be a NULL value. If sqlite3_value_nochange(X) is invoked anywhere other than within an &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method call for an UPDATE statement, then the return value is arbitrary and meaningless.</source>
          <target state="translated">内&lt;a href=&quot;vtab#xupdate&quot;&gt;のXUpdate&lt;/a&gt;の方法&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;、sqlite3_value_nochange（X）インターフェイスが真とXに対応する列は、のXUpdateメソッド呼び出しを実装するために呼び出されたことをUPDATE操作によって変更されない場合のみとIF前&lt;a href=&quot;vtab#xcolumn&quot;&gt;Xcolumnには&lt;/a&gt;、そのメソッド呼び出し結果を設定せずに返されたその列の値を抽出するために呼び出されました（おそらく&lt;a href=&quot;#sqlite3_vtab_nochange&quot;&gt;sqlite3_vtab_nochange（）&lt;/a&gt;を照会し、列が変更されていないことが判明したためです）。&lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;メソッド内で、sqlite3_value_nochange（X）がtrueである値は、他のすべての点でNULL値のように見えます。 sqlite3_value_nochange（X）が&lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;内以外の場所で呼び出された場合UPDATEステートメントのメソッド呼び出しの場合、戻り値は任意で無意味です。</target>
        </trans-unit>
        <trans-unit id="51af27804794d9726418547af1ae4968a5ef7a8d" translate="yes" xml:space="preserve">
          <source>Within this document, the term</source>
          <target state="translated">本文書では、以下の用語を使用しています。</target>
        </trans-unit>
        <trans-unit id="2abd7cfa8c19071145244fc329440378e98735a8" translate="yes" xml:space="preserve">
          <source>Within this document, the term &lt;b&gt;&lt;i&gt;non-writable dirty page&lt;/i&gt;&lt;/b&gt; is used specifically to refer to a</source>
          <target state="translated">このドキュメントでは、&lt;b&gt;&lt;i&gt;書き込み不可のダーティページ&lt;/i&gt;&lt;/b&gt;という用語は、特に</target>
        </trans-unit>
        <trans-unit id="9c7aa2ef11bbb00024927734567cd7e8fb651be6" translate="yes" xml:space="preserve">
          <source>Within your application, call the procedure implemented in the last step above as part of your initialization process before any database connections are opened.</source>
          <target state="translated">アプリケーション内では、データベース接続が開かれる前の初期化プロセスの一部として、上記の最後のステップで実装されたプロシージャを呼び出します。</target>
        </trans-unit>
        <trans-unit id="d2b321aabd394218d6d71b6b8d179118941b9c02" translate="yes" xml:space="preserve">
          <source>Without the master journal, the transaction commit on a multi-database transaction would be atomic for each database individually, but it would not be atomic across all databases. In other words, if the commit were interrupted in the middle by a crash or power loss, then the changes to one of the databases might complete while the changes to another database might roll back. The master journal causes all changes in all databases to either rollback or commit together.</source>
          <target state="translated">マスター・ジャーナルがない場合、マルチデータベース・トランザクションのトランザクション・コミットは各データベースに対して個別にアトミックになりますが、すべてのデータベースに対してアトミックになるわけではありません。言い換えれば、クラッシュや停電によってコミットが途中で中断された場合、データベースの1つへの変更が完了し、別のデータベースへの変更がロールバックされる可能性があります。マスタージャーナルは、すべてのデータベースのすべての変更をロールバックまたはコミットのどちらかにまとめて行わせます。</target>
        </trans-unit>
        <trans-unit id="7c3fafa3b408ed62c81a7e1dcfba262f7d167cb3" translate="yes" xml:space="preserve">
          <source>Without the super-journal, the transaction commit on a multi-database transaction would be atomic for each database individually, but it would not be atomic across all databases. In other words, if the commit were interrupted in the middle by a crash or power loss, then the changes to one of the databases might complete while the changes to another database might roll back. The super-journal causes all changes in all databases to either rollback or commit together.</source>
          <target state="translated">スーパージャーナルがなければ、マルチデータベース・トランザクションのトランザクション・コミットは各データベースに対して個別にアトミックになりますが、すべてのデータベースに対してアトミックになるわけではありません。言い換えれば、クラッシュや停電によってコミットが途中で中断された場合、あるデータベースへの変更は完了し、別のデータベースへの変更はロールバックする可能性があります。スーパージャーナルは、すべてのデータベースのすべての変更をロールバックするか、一緒にコミットするかのどちらかにします。</target>
        </trans-unit>
        <trans-unit id="d6dd78a3d415f93746301f9a57f0de1998136848" translate="yes" xml:space="preserve">
          <source>Words beginning with &quot;wr&quot; versus &quot;r&quot;: write vs. rite</source>
          <target state="translated">wr」対「r」で始まる言葉:write vs rite</target>
        </trans-unit>
        <trans-unit id="87bffc88b4c4749365cee3251faa81be81f0ebe9" translate="yes" xml:space="preserve">
          <source>Work around a C-preprocessor macro conflict that breaks the build for some configurations with Microsoft Visual Studio.</source>
          <target state="translated">Microsoft Visual Studio を使用した一部の構成でビルドが中断される C プリプロセッサマクロの競合を回避します。</target>
        </trans-unit>
        <trans-unit id="50aee533edd4e21305ef90f99451cd9467951df2" translate="yes" xml:space="preserve">
          <source>Work around a GCC optimizer bug (for gcc 4.2.1 on MacOS 10.7) that caused the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; to compute incorrect results when compiled with -O3.</source>
          <target state="translated">-O3でコンパイルしたときに&lt;a href=&quot;rtree&quot;&gt;Rツリー拡張&lt;/a&gt;が誤った結果を計算する原因となったGCCオプティマイザーのバグ（MacOS 10.7のgcc 4.2.1の場合）を回避します。</target>
        </trans-unit>
        <trans-unit id="dfd059bf7f3cb496ecc6f63b39e721653d7d6b6d" translate="yes" xml:space="preserve">
          <source>Work around a bug in the optimizer in the VisualStudio-2012 compiler that causes invalid code to be generated when compiling SQLite on ARM.</source>
          <target state="translated">VisualStudio-2012 コンパイラのオプティマイザで、ARM 上で SQLite をコンパイルする際に無効なコードが生成されるバグを修正しました。</target>
        </trans-unit>
        <trans-unit id="05fe4e3a69bacc20ca972b8ceb1bc5a0e767ed20" translate="yes" xml:space="preserve">
          <source>Work around a sign-extension bug in the optimizer of the HP C compiler on HP/UX. &lt;a href=&quot;https://www.sqlite.org/src/fdiff?sbs=1&amp;amp;v1=869c95b0fc73026d&amp;amp;v2=232c242a0ccb3d67&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">HP / UX上のHP Cコンパイラのオプティマイザの符号拡張バグを回避します。&lt;a href=&quot;https://www.sqlite.org/src/fdiff?sbs=1&amp;amp;v1=869c95b0fc73026d&amp;amp;v2=232c242a0ccb3d67&quot;&gt;（詳細）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0f7e0b96e4d5af469559bc4b5418e841b0585e67" translate="yes" xml:space="preserve">
          <source>Work around a win2k problem so that SQLite can use single-character database file names</source>
          <target state="translated">win2k の問題を回避し、SQLite が 1 文字のデータベースファイル名を使用できるようにしました。</target>
        </trans-unit>
        <trans-unit id="620ea823b219e2193e9c0c9d76d068c0c91681bb" translate="yes" xml:space="preserve">
          <source>Work around an optimizer bug in the MSVC compiler when targeting ARM.</source>
          <target state="translated">ARMをターゲットにした場合のMSVCコンパイラのオプティマイザのバグを回避しました。</target>
        </trans-unit>
        <trans-unit id="c7a3e9e586b4abc65bd66b99ca41670f3c121bb4" translate="yes" xml:space="preserve">
          <source>Work-around for &lt;a href=&quot;http://gcc.gnu.org/bugzilla/show_bug.cgi?id=32575&quot;&gt;GCC bug 32575&lt;/a&gt;.</source>
          <target state="translated">回避策のための&lt;a href=&quot;http://gcc.gnu.org/bugzilla/show_bug.cgi?id=32575&quot;&gt;GCCのバグ32575&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cebdf47773b9831e663aaa2b137f8c46c76becbf" translate="yes" xml:space="preserve">
          <source>Would be rewritten using query flattening as:</source>
          <target state="translated">クエリのフラット化を利用して書き換えられます。</target>
        </trans-unit>
        <trans-unit id="adefeee85f8390b904f622c9dadd9084253d11b9" translate="yes" xml:space="preserve">
          <source>Wrap SQL output in a single large transaction</source>
          <target state="translated">SQL出力を単一の大規模なトランザクションでラップ</target>
        </trans-unit>
        <trans-unit id="a38083e109d2e7a4d69cbaa3489444f640acbb5f" translate="yes" xml:space="preserve">
          <source>Write Data Into A BLOB Incrementally</source>
          <target state="translated">増分的にBLOBにデータを書き込む</target>
        </trans-unit>
        <trans-unit id="d7f59c7d18e98edd2a33e30c67d681015a12865e" translate="yes" xml:space="preserve">
          <source>Write P4 on the statement trace output if statement tracing is enabled.</source>
          <target state="translated">ステートメントトレースが有効な場合は、ステートメントトレース出力にP4を書き込みます。</target>
        </trans-unit>
        <trans-unit id="01ecf2ccbe2bc061336d1857718a14b0b49fee20" translate="yes" xml:space="preserve">
          <source>Write Programs That Use SQLite</source>
          <target state="translated">SQLiteを使用するプログラムを書く</target>
        </trans-unit>
        <trans-unit id="57477c30051b84c96ed41136ab16ff89bef76c1e" translate="yes" xml:space="preserve">
          <source>Write Transactions</source>
          <target state="translated">取引を書く</target>
        </trans-unit>
        <trans-unit id="7792ea49e68a0636ee3df8abc86c43dc971f4500" translate="yes" xml:space="preserve">
          <source>Write a NULL into registers P2. If P3 greater than P2, then also write NULL into register P3 and every register in between P2 and P3. If P3 is less than P2 (typically P3 is zero) then only register P2 is set to NULL.</source>
          <target state="translated">レジスタP2にNULLを書き込む。P3がP2より大きい場合は、レジスタP3とP2とP3の間のすべてのレジスタにもNULLを書き込みます。P3がP2より小さい場合(通常P3は0)、レジスタP2のみがNULLに設定されます。</target>
        </trans-unit>
        <trans-unit id="4b067f7f133cef5bf8ac788b6955ee101e88869d" translate="yes" xml:space="preserve">
          <source>Write a string containing the final journal-mode to register P2.</source>
          <target state="translated">レジスタP2に最終的なジャーナルモードを含む文字列を書き込む。</target>
        </trans-unit>
        <trans-unit id="b758b03a1915378a4790dfdd86b8e50a7bacf82d" translate="yes" xml:space="preserve">
          <source>Write all necessary methods.</source>
          <target state="translated">必要な方法をすべて書く。</target>
        </trans-unit>
        <trans-unit id="96dcd721393f2668fc3f8e665d514a96620cfebb" translate="yes" xml:space="preserve">
          <source>Write all page modifications currently held in memory out to the original database disk file.</source>
          <target state="translated">現在メモリに保持されているすべてのページの変更を、元のデータベースのディスクファイルに書き出します。</target>
        </trans-unit>
        <trans-unit id="1687a8d3ed30cb7eb791ed33a931d8ace68eaab0" translate="yes" xml:space="preserve">
          <source>Write an entry into the table of cursor P1. A new entry is created if it doesn't already exist or the data for an existing entry is overwritten. The data is the value MEM_Blob stored in register number P2. The key is stored in register P3. The key must be a MEM_Int.</source>
          <target state="translated">カーソルP1のテーブルにエントリを書き込む。既に存在しない場合や、既存のエントリのデータが上書きされている場合は新規エントリを作成します。データはレジスタ番号P2に格納されている値MEM_Blobです。キーはレジスタP3に格納されています。キーはMEM_Intでなければなりません。</target>
        </trans-unit>
        <trans-unit id="d5c23fb528e11a09e4afc8b5a2e279f79a841784" translate="yes" xml:space="preserve">
          <source>Write into register P2 an integer which is the last entry in the record at the end of the index key pointed to by cursor P1. This integer should be the rowid of the table entry to which this index entry points.</source>
          <target state="translated">カーソルP1が指し示すインデックスキーの最後のレコードの最後のエントリである整数をレジスタP2に書き込みます。この整数は、このインデックスエントリが指すテーブルエントリの行IDでなければなりません。</target>
        </trans-unit>
        <trans-unit id="845ccbd564d152c911058efd13330cea72170f39" translate="yes" xml:space="preserve">
          <source>Write into register P2 the complete row content for the row at which cursor P1 is currently pointing. There is no interpretation of the data. It is just copied onto the P2 register exactly as it is found in the database file.</source>
          <target state="translated">カーソルP1が現在指している行の完全な行内容をレジスタP2に書き込む。データの解釈はありません。データベースファイルにある通りにP2レジスタにコピーされるだけです。</target>
        </trans-unit>
        <trans-unit id="d4da38aa74dee90d46d653efba3b56536b2cc5d2" translate="yes" xml:space="preserve">
          <source>Write into register P2 the current sorter data for sorter cursor P1. Then clear the column header cache on cursor P3.</source>
          <target state="translated">ソータカーソルP1の現在のソータデータをレジスタP2に書き込む。そして、カーソルP3のカラムヘッダキャッシュをクリアする。</target>
        </trans-unit>
        <trans-unit id="4e60b462188e6078fccee2b0f7f0c97876c061b9" translate="yes" xml:space="preserve">
          <source>Write performance measurements were made by replacing (overwriting) an entire blob with a different blob. All of the blobs in these experiment are random and incompressible. Because writes are so much slower than reads, only 10,000 of the 100,000 blobs in the database are replaced. The blobs to be replaced are selected at random and are in no particular order.</source>
          <target state="translated">書き込み性能の測定は、ブロブ全体を別のブロブに置き換える(上書きする)ことで行われました。これらの実験のブロブはすべてランダムで非圧縮性のものです。書き込みは読み取りよりも非常に遅いため、データベース内の10万個のブロブのうち1万個だけが置き換えられます。置き換えられるブロブはランダムに選択されており、順番は特にありません。</target>
        </trans-unit>
        <trans-unit id="97d379c9ca883f0cc777a01b05087d4f85759f23" translate="yes" xml:space="preserve">
          <source>Write the current address onto register P1 and then jump to address P2.</source>
          <target state="translated">現在のアドレスをレジスタP1に書き込み、アドレスP2にジャンプします。</target>
        </trans-unit>
        <trans-unit id="b9ace1191ba47c3313a30683407724719ddd8866" translate="yes" xml:space="preserve">
          <source>Write the current number of pages in database P1 to memory cell P2.</source>
          <target state="translated">データベースP1の現在のページ数をメモリセルP2に書き込む。</target>
        </trans-unit>
        <trans-unit id="91954b8458d0e00b292061c02fc82b69cf42b6c1" translate="yes" xml:space="preserve">
          <source>Write the integer value P3 into cookie number P2 of database P1. P2==1 is the schema version. P2==2 is the database format. P2==3 is the recommended pager cache size, and so forth. P1==0 is the main database file and P1==1 is the database file used to store temporary tables.</source>
          <target state="translated">データベースP1のクッキー番号P2に整数値P3を書き込む。P2==1はスキーマのバージョンです。P2==2はデータベースのフォーマットです。P2==3は推奨ページャーキャッシュサイズなどです。P1==0はメインデータベースファイル、P1==1は一時テーブルを格納するためのデータベースファイルです。</target>
        </trans-unit>
        <trans-unit id="4f557ab176f965a00361710b6f978bd703c87e93" translate="yes" xml:space="preserve">
          <source>Write the name of the master journal into all individual journals (in space set aside for that purpose in the headers of the individual journals) and flush the contents of the individual journals to disk and wait for those changes to reach the disk surface.</source>
          <target state="translated">マスタージャーナルの名前をすべての個々のジャーナルに書き込み(個々のジャーナルのヘッダにその目的のために設定されたスペースに)、個々のジャーナルの内容をディスクにフラッシュして、それらの変更がディスク表面に到達するのを待ちます。</target>
        </trans-unit>
        <trans-unit id="461c6fd84d21b2e1e58564d3f66dc64dc514f582" translate="yes" xml:space="preserve">
          <source>Write the name of the super-journal into all individual journals (in space set aside for that purpose in the headers of the individual journals) and flush the contents of the individual journals to disk and wait for those changes to reach the disk surface.</source>
          <target state="translated">スーパージャーナルの名前をすべての個々のジャーナルに書き込み(個々のジャーナルのヘッダーにその目的のために設定されたスペースに)、個々のジャーナルの内容をディスクにフラッシュし、それらの変更がディスク表面に到達するのを待ちます。</target>
        </trans-unit>
        <trans-unit id="d7664f788d5d10d956cebf109c73130c0a103849" translate="yes" xml:space="preserve">
          <source>Write transactions are very fast since they only involve writing the content once (versus twice for rollback-journal transactions) and because the writes are all sequential. Further, syncing the content to the disk is not required, as long as the application is willing to sacrifice durability following a power loss or hard reboot. (Writers sync the WAL on every transaction commit if &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; is set to FULL but omit this sync if &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; is set to NORMAL.)</source>
          <target state="translated">書き込みトランザクションは、コンテンツの書き込みが1回のみ（ロールバックジャーナルトランザクションの場合は2回）であり、書き込みがすべて順次であるため、非常に高速です。さらに、アプリケーションが停電やハードリブート後に耐久性を犠牲にしても構わない限り、コンテンツをディスクに同期する必要はありません。（ライターは、&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同期&lt;/a&gt;がFULLに設定されている場合はトランザクションコミットごとにWALを同期しますが、&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同期&lt;/a&gt;がNORMALに設定されている場合はこの同期を省略します。）</target>
        </trans-unit>
        <trans-unit id="9df19c54f436b6a77ec7817a689a3cb7a8863393" translate="yes" xml:space="preserve">
          <source>Write-Ahead Log Commit Hook</source>
          <target state="translated">ライトアヘッドログコミットフック</target>
        </trans-unit>
        <trans-unit id="7012a3c8e49b82c45441c8c9cad604aa604cafd1" translate="yes" xml:space="preserve">
          <source>Write-Ahead Logging</source>
          <target state="translated">ライトアヘッドロギング</target>
        </trans-unit>
        <trans-unit id="0e7776631ee4a8b853c6c06ce06a6006cefcda96" translate="yes" xml:space="preserve">
          <source>Write-ahead Log (WAL) files</source>
          <target state="translated">ライトアヘッドログ(WAL)ファイル</target>
        </trans-unit>
        <trans-unit id="e1b6c7d9217381e4c29658c4e3841e70686fb388" translate="yes" xml:space="preserve">
          <source>Writer starvation</source>
          <target state="translated">作家の飢餓</target>
        </trans-unit>
        <trans-unit id="e447e06606fdc13a8e426bfdd192c63a84795c86" translate="yes" xml:space="preserve">
          <source>Writers merely append new content to the end of the WAL file. Because writers do nothing that would interfere with the actions of readers, writers and readers can run at the same time. However, since there is only one WAL file, there can only be one writer at a time.</source>
          <target state="translated">ライターは、単にWALファイルの末尾に新しいコンテンツを追加するだけである。ライターは読者の動作を妨げるようなことは何もしないので、ライターと読者は同時に実行することができます。しかし、WALファイルは1つしかないので、一度に1つのライターしか存在できません。</target>
        </trans-unit>
        <trans-unit id="51a81481b69a429427cf443afa9b0e120124c1b5" translate="yes" xml:space="preserve">
          <source>Writes are slower. On all systems, using both direct I/O and SQLite, write performance is between 5 and 15 times slower than reads.</source>
          <target state="translated">書き込みの方が遅い。すべてのシステムで、直接I/OとSQLiteの両方を使用した場合、書き込みのパフォーマンスは読み取りの5倍から15倍遅くなります。</target>
        </trans-unit>
        <trans-unit id="a90f9ae1890da2882ef529c18fb80a5589473876" translate="yes" xml:space="preserve">
          <source>Writes to an in-memory source database, or writes to a file-based source database by an external process or thread using a database connection other than pDb are significantly more expensive than writes made to a file-based source database using pDb (as the entire backup operation must be restarted in the former two cases).</source>
          <target state="translated">メモリ内ソースデータベースへの書き込みや、pDb以外のデータベース接続を使用した外部プロセスやスレッドによるファイルベースのソースデータベースへの書き込みは、pDbを使用したファイルベースのソースデータベースへの書き込みよりも大幅にコストがかかります(前者2つのケースでは、バックアップ操作全体を再起動する必要があるため)。</target>
        </trans-unit>
        <trans-unit id="347af0bc198470df77e05081b38d5bcb19f95263" translate="yes" xml:space="preserve">
          <source>Writes to the &lt;a href=&quot;../dbpage&quot;&gt;sqlite_dbpage&lt;/a&gt; virtual table.</source>
          <target state="translated">&lt;a href=&quot;../dbpage&quot;&gt;sqlite_dbpage&lt;/a&gt;仮想テーブルに書き込みます。</target>
        </trans-unit>
        <trans-unit id="caebec0b3978142dd7d784c5a70a27f827c0fc87" translate="yes" xml:space="preserve">
          <source>Writes to the &lt;a href=&quot;dbpage&quot;&gt;sqlite_dbpage&lt;/a&gt; virtual table.</source>
          <target state="translated">&lt;a href=&quot;dbpage&quot;&gt;sqlite_dbpage&lt;/a&gt;仮想テーブルに書き込みます。</target>
        </trans-unit>
        <trans-unit id="9e632869f49afb8aba3986c578bc41023c0edd69" translate="yes" xml:space="preserve">
          <source>Writing Data</source>
          <target state="translated">データの書き込み</target>
        </trans-unit>
        <trans-unit id="46bd9ed0bb52c21d70902da8961ddf970beec522" translate="yes" xml:space="preserve">
          <source>Writing a Journal Header</source>
          <target state="translated">ジャーナルヘッダーの書き方</target>
        </trans-unit>
        <trans-unit id="563ef87c29c874b30c909b9cb710bc0c375b3734" translate="yes" xml:space="preserve">
          <source>Writing a good query planner is more art than science. The query planner must work with incomplete information. It cannot determine how long any particular plan will take without actually running that plan. So when comparing two or more plans to figure out which is &quot;best&quot;, the query planner has to make some guesses and assumptions and those guesses and assumptions will sometimes be wrong. A good query planner is one that will find the correct solution often enough that application programmers rarely need to get involved.</source>
          <target state="translated">良い問い合わせプランナーを書くことは、科学よりも芸術です。クエリプランナーは、不完全な情報を使って作業しなければなりません。実際にそのプランを実行してみないと、特定のプランがどれくらいの時間を要するかを判断することはできません。そのため、2つ以上のプランを比較してどれが「ベスト」かを判断する際には、クエリプランナーはいくつかの推測や仮定をしなければならず、それらの推測や仮定が間違っていることもあります。優れたクエリプランナとは、アプリケーションプログラマがほとんど関与する必要がないほど、正しい解決策を頻繁に見つけることができるプランナのことです。</target>
        </trans-unit>
        <trans-unit id="0cde81e7d9009da11d97881af257b1563f71fbed" translate="yes" xml:space="preserve">
          <source>Writing the code for a new VFS involves constructing a subclass for the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object and then registering that VFS object using a call to &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;. The VFS implementation also provides subclasses for &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; and &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; but those objects are not registered directly with SQLite. Instead, the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object is returned from the xOpen method of &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; and the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object points to an instance of the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">新しいVFSのコードを作成するには、&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトのサブクラスを作成し、次に&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）の&lt;/a&gt;呼び出しを使用してそのVFSオブジェクトを登録します。VFS実装は&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;および&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methodsの&lt;/a&gt;サブクラスも提供しますが、これらのオブジェクトはSQLiteに直接登録されません。代わりに、&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_fileの&lt;/a&gt;オブジェクトはXOPENメソッドから返され&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;と&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;のインスタンスにオブジェクト点&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methodsの&lt;/a&gt;オブジェクト。</target>
        </trans-unit>
        <trans-unit id="7fdb521941b3e5056a81c587e69b7f19860828e9" translate="yes" xml:space="preserve">
          <source>Written in ANSI-C. &lt;a href=&quot;tclsqlite&quot;&gt;TCL bindings&lt;/a&gt; included. Bindings for dozens of other languages available separately.</source>
          <target state="translated">ANSI-Cで記述されています。&lt;a href=&quot;tclsqlite&quot;&gt;TCLバインディングが&lt;/a&gt;含まれています。個別に利用可能な数十の他の言語のバインディング。</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="ab87b9a32f29182878ebb3a6891a6c4a1092d9ec" translate="yes" xml:space="preserve">
          <source>X is U-35 for table btree leaf pages or ((U-12)*64/255)-23 for index pages.</source>
          <target state="translated">XはテーブルツリーのリーフページはU-35、インデックスページは((U-12)*64/255)-23です。</target>
        </trans-unit>
        <trans-unit id="a43e2726d178277e17345f240dc4baecfd6ece05" translate="yes" xml:space="preserve">
          <source>XLS - Microsoft Excel Spreadsheet</source>
          <target state="translated">XLS-Microsoft Excelスプレッドシート</target>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="translated">Y</target>
        </trans-unit>
        <trans-unit id="d3f8f7b810c4b08f0b4ac4e47fdf8d265a10d869" translate="yes" xml:space="preserve">
          <source>YYYY-MM-DD</source>
          <target state="translated">YYYY-MM-DD</target>
        </trans-unit>
        <trans-unit id="52249b595b705e3022543f7da9fd802190e92e98" translate="yes" xml:space="preserve">
          <source>YYYY-MM-DD HH:MM</source>
          <target state="translated">YYYY-MM-DD HH:MM</target>
        </trans-unit>
        <trans-unit id="5d7d8fa1d70072dde246c61070188c4587305f0a" translate="yes" xml:space="preserve">
          <source>YYYY-MM-DD HH:MM:SS</source>
          <target state="translated">YYYYY-MM-DD HH:MM:SS</target>
        </trans-unit>
        <trans-unit id="c73c8c3ce69182be88dad37758ba32a3fc0f8563" translate="yes" xml:space="preserve">
          <source>YYYY-MM-DD HH:MM:SS.SSS</source>
          <target state="translated">YYYYY-MM-DD HH:MM:SS.SSS</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="5374d3a8e418edba680d4a07da2c6ab36a4e8962" translate="yes" xml:space="preserve">
          <source>Yes. SQLite is in the &lt;a href=&quot;https://sqlite.org/copyright.html&quot;&gt;public domain&lt;/a&gt;. No claim of ownership is made to any part of the code. You can do anything you want with it.</source>
          <target state="translated">はい。SQLiteは&lt;a href=&quot;https://sqlite.org/copyright.html&quot;&gt;パブリックドメイン&lt;/a&gt;です。コードのいかなる部分についても所有権の主張は行われません。あなたはそれでやりたいことが何でもできます。</target>
        </trans-unit>
        <trans-unit id="33b0fd0f74faa27daf44c1c690d408e467aa0dd1" translate="yes" xml:space="preserve">
          <source>Yield</source>
          <target state="translated">Yield</target>
        </trans-unit>
        <trans-unit id="84033aeb092c1214f0c2cb3aece38e6ba6958175" translate="yes" xml:space="preserve">
          <source>Yields 20 results beginning with:</source>
          <target state="translated">で始まる20の結果が得られます。</target>
        </trans-unit>
        <trans-unit id="0e3a778de9e9a5f44253370ab8c9e4efcbf47122" translate="yes" xml:space="preserve">
          <source>You can access the ROWID of an SQLite table using one of the special column names ROWID, _ROWID_, or OID. Except if you declare an ordinary table column to use one of those special names, then the use of that name will refer to the declared column not to the internal ROWID.</source>
          <target state="translated">SQLite テーブルの ROWID にアクセスするには、特別なカラム名である ROWID、_ROWID_、または OID のいずれかを使用します。通常のテーブルのカラムにこれらの特別な名前のいずれかを使用するように宣言した場合を除き、その名前の使用は内部の ROWID ではなく宣言されたカラムを参照することになります。</target>
        </trans-unit>
        <trans-unit id="f9617c865e05039ea284590d342ff395b566aa5e" translate="yes" xml:space="preserve">
          <source>You can add new custom &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;, &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt;, &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;, and &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; to the command-line shell at run-time using the &quot;.load&quot; command. First, convert the extension in to a DLL or shared library (as described in the &lt;a href=&quot;loadext&quot;&gt;Run-Time Loadable Extensions&lt;/a&gt; document) then type:</source>
          <target state="translated">You can add new custom &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;, &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt;, &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;, and &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; to the command-line shell at run-time using the &quot;.load&quot; command. First, convert the extension in to a DLL or shared library (as described in the &lt;a href=&quot;loadext&quot;&gt;Run-Time Loadable Extensions&lt;/a&gt; document) then type:</target>
        </trans-unit>
        <trans-unit id="766fd041e7449721a800b8d56d1a550c8e84e175" translate="yes" xml:space="preserve">
          <source>You can add new custom &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;, &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt;, &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;, and &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; to the command-line shell at run-time using the &quot;.load&quot; command. First, convert the extension in to a DLL or shared library (as described in the &lt;a href=&quot;loadext&quot;&gt;Run-Time Loadable Extensions&lt;/a&gt; document) then type:</source>
          <target state="translated">&quot;.load&quot;コマンドを使用して、実行時に新しいカスタム&lt;a href=&quot;c3ref/create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;、&lt;a href=&quot;datatype3#collation&quot;&gt;照合シーケンス&lt;/a&gt;、&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;、および&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;をコマンドラインシェルに追加できます。まず、拡張機能をDLLまたは共有ライブラリに変換し（&lt;a href=&quot;loadext&quot;&gt;ランタイムロード可能拡張機能の&lt;/a&gt;ドキュメントに記載されているとおり）、次のように入力します。</target>
        </trans-unit>
        <trans-unit id="f503e6243f11ce8864a2a2815733bb53ffb62dce" translate="yes" xml:space="preserve">
          <source>You can also process the results of a query one row at a time by specifying the name of an array variable and a script following the SQL code. For each row of the query result, the values of all columns will be inserted into the array variable and the script will be executed. For instance:</source>
          <target state="translated">また、配列変数の名前を指定して、SQLコードに沿ってスクリプトを実行することで、クエリの結果を1行ずつ処理することもできます。クエリ結果の各行について、すべての列の値が配列変数に挿入され、スクリプトが実行されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="cff814001d9391d1134a9599b4429c6538fee547" translate="yes" xml:space="preserve">
          <source>You can also provide the virtual table with a &quot;rank&quot; for each word. The &quot;rank&quot; is an estimate of how common the word is. Larger numbers mean the word is more common. If you omit the rank when populating the table, then a rank of 1 is assumed. But if you have rank information, you can supply it and the virtual table will show a slight preference for selecting more commonly used terms. To populate the rank from an fts4aux table &quot;search_aux&quot; do something like this:</source>
          <target state="translated">また、各単語の「ランク」を仮想テーブルに提供することもできます。ランク」は、その単語がどれくらい一般的なのかを示すものです。数字が大きいほど、その単語がより一般的であることを意味します。テーブルを作成する際にランクを省略した場合、ランクは 1 と見なされます。しかし、ランク情報がある場合は、それを提供することができ、仮想テーブルは、より一般的に使用されている用語を選択するための若干の優先順位を表示します。fts4auxテーブル &quot;search_aux &quot;からランクを入力するには、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="adf32fc901d0b3c9c4d8f663c01fbe75c182af0b" translate="yes" xml:space="preserve">
          <source>You can also request a reverse-order sort like this:</source>
          <target state="translated">このように逆順ソートを依頼することもできます。</target>
        </trans-unit>
        <trans-unit id="6faf0acbd59c9b880e0b1c9b8cab39235a6257e9" translate="yes" xml:space="preserve">
          <source>You can call your project anything you like. The &quot;&lt;code&gt;.fossil&lt;/code&gt;&quot; suffix is optional. For this document, we will continue to call the project &quot;&lt;code&gt;private-project.fossil&lt;/code&gt;&quot;. Note that &lt;code&gt;private-project.fossil&lt;/code&gt; is an ordinary disk file (actually an SQLite database) that will contain your complete project history. You can make a backup of the project simply by making a copy of that one file.</source>
          <target state="translated">プロジェクトは自由に呼び出すことができます。「 &lt;code&gt;.fossil&lt;/code&gt; 」サフィックスはオプションです。このドキュメントでは、引き続きプロジェクトを「 &lt;code&gt;private-project.fossil&lt;/code&gt; 」と呼びます。 &lt;code&gt;private-project.fossil&lt;/code&gt; は、完全なプロジェクト履歴が含まれる通常のディスクファイル（実際にはSQLiteデータベース）であることに注意してください。その1つのファイルのコピーを作成するだけで、プロジェクトのバックアップを作成できます。</target>
        </trans-unit>
        <trans-unit id="a7e393b006953ea5c66642b8797a473726aa00ab" translate="yes" xml:space="preserve">
          <source>You can have multiple checkouts of the same project if you want. And you can &quot;clone&quot; the repository to different machines so that multiple developers can use it. See the fossil website for further information.</source>
          <target state="translated">必要であれば、同じプロジェクトを複数チェックアウトすることができます。また、リポジトリを別のマシンに &quot;クローン &quot;して、複数の開発者が使えるようにすることもできます。詳しくはfossilのサイトを参照してください。</target>
        </trans-unit>
        <trans-unit id="0eaaecfbb43e45dd392f3506c8da0516ce5d97d1" translate="yes" xml:space="preserve">
          <source>You can run the &quot;info&quot; command again to verify that you are on the private branch. To go back to the public branch, type:</source>
          <target state="translated">再度 &quot;info&quot; コマンドを実行して、プライベートブランチにいることを確認してください。パブリックブランチに戻るには、次のように入力します。</target>
        </trans-unit>
        <trans-unit id="445e03eebf2a496b04ef2b41a7e5575686b7c24c" translate="yes" xml:space="preserve">
          <source>You can see how SQLite constructs nested loops in the following example:</source>
          <target state="translated">以下の例で、SQLite がどのように入れ子になったループを構築するかを見ることができます。</target>
        </trans-unit>
        <trans-unit id="64e589fcb69790fd074e7b79362cd1b733d9786f" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; to do a thorough but time intensive test of the database integrity.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integer_check&lt;/a&gt;を使用して、データベースの整合性を徹底的かつ時間のかかるテストを実行できます。</target>
        </trans-unit>
        <trans-unit id="89132b9f9cffd74c2cdc7fb086ca8110533325a1" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt; to do a faster but less thorough test of the database integrity.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt;を使用して、データベースの整合性のテストをより迅速に実行できますが、完全ではありません。</target>
        </trans-unit>
        <trans-unit id="322edc4ffe1c2dcc35efd77efa0d7e1857777962" translate="yes" xml:space="preserve">
          <source>You can use the &quot;.mode&quot; dot command to switch between these output formats. &amp;gt;The default output mode is &quot;list&quot;. In list mode, each row of a query result is written on one line of output and each column within that row is separated by a specific separator string. The default separator is a pipe symbol (&quot;|&quot;). List mode is especially useful when you are going to send the output of a query to another program (such as AWK) for additional processing.</source>
          <target state="translated">You can use the &quot;.mode&quot; dot command to switch between these output formats. &amp;gt;The default output mode is &quot;list&quot;. In list mode, each row of a query result is written on one line of output and each column within that row is separated by a specific separator string. The default separator is a pipe symbol (&quot;|&quot;). List mode is especially useful when you are going to send the output of a query to another program (such as AWK) for additional processing.</target>
        </trans-unit>
        <trans-unit id="e92aed886574f82b46aed1073eadf0a43514f93b" translate="yes" xml:space="preserve">
          <source>You cannot &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, or &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; a view. Views are read-only in SQLite. However, in many cases you can use an &lt;a href=&quot;lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF trigger&lt;/a&gt; on the view to accomplish the same thing. Views are removed with the &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt; command.</source>
          <target state="translated">ビューを&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;、&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;、または&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;することはできません。SQLiteではビューは読み取り専用です。ただし、多くの場合、ビューで&lt;a href=&quot;lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OFトリガー&lt;/a&gt;を使用して同じことを実行できます。ビューは&lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt;コマンドで削除されます。</target>
        </trans-unit>
        <trans-unit id="e3029ec6343085341759c5984c721d08ac8eda9c" translate="yes" xml:space="preserve">
          <source>You lose Durability with asynchronous I/O, but you still retain the other parts of ACID: Atomic, Consistent, and Isolated. Many applications get along fine without the Durability.</source>
          <target state="translated">非同期I/Oでは耐久性は失われますが、ACIDの他の部分であるAtomic、Consistent、Isolatedは保持されます。多くのアプリケーションでは、耐久性がなくても問題ありません。</target>
        </trans-unit>
        <trans-unit id="2edf5e92e2eb8b4ae5fa4b416e11d2c19ee0f6b2" translate="yes" xml:space="preserve">
          <source>You may want to add additional compiler options, of course, according to the needs of your project.</source>
          <target state="translated">もちろん、プロジェクトのニーズに応じてコンパイラのオプションを追加することもできます。</target>
        </trans-unit>
        <trans-unit id="4dd05146b6c50e8243d5d884c39ba78d8eacc3ab" translate="yes" xml:space="preserve">
          <source>You might also want to implement your new virtual table as a &lt;a href=&quot;c3ref/load_extension&quot;&gt;loadable extension&lt;/a&gt;.</source>
          <target state="translated">新しい仮想テーブルを&lt;a href=&quot;c3ref/load_extension&quot;&gt;ロード可能な拡張&lt;/a&gt;として実装することもできます。</target>
        </trans-unit>
        <trans-unit id="5967e28677480dfa358973a1823f7ea8ef646b1f" translate="yes" xml:space="preserve">
          <source>You might also want to implement your new virtual table as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;.</source>
          <target state="translated">You might also want to implement your new virtual table as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="af0efe31561de911c0e8b4a9d062c5a0f356df3b" translate="yes" xml:space="preserve">
          <source>You should not assume that a CVE about SQLite contains authoritative information. CVEs often contain inaccuracies. The SQLite developers have attempted to add clarifications and corrections to CVEs about SQLite, but without success.</source>
          <target state="translated">SQLite に関する CVE が権威ある情報を含んでいると仮定してはいけません。CVEはしばしば不正確な情報を含んでいます。SQLite の開発者は、SQLite に関する CVE に明確化と修正を加えようと試みましたが、成功しませんでした。</target>
        </trans-unit>
        <trans-unit id="bedd0d05da99d3f3471d33a570e1e743621d6387" translate="yes" xml:space="preserve">
          <source>You will be prompted for a check-in comment. Say whatever you like. After the commit completes, your baseline will be part of the repository. The following command, if you like, to see this on the &quot;timeline&quot;:</source>
          <target state="translated">チェックインのコメントを求められます。好きなことを言ってください。コミットが完了すると、あなたのベースラインはリポジトリの一部になります。これを「タイムライン」で確認するには、よろしければ以下のコマンドを実行してください。</target>
        </trans-unit>
        <trans-unit id="fd47b0381210b18fb651f05af57837f2ec742bdf" translate="yes" xml:space="preserve">
          <source>You will be prompted once again to enter a commit describing your changes. Then the commit will occur. The commit creates a new checkin in the repository that corresponds to circle (3) in the diagram above.</source>
          <target state="translated">もう一度、変更内容を記述したコミットを入力するように促されます。すると、コミットが発生します。コミットにより、上図の円(3)に対応するリポジトリに新しいチェックインが作成されます。</target>
        </trans-unit>
        <trans-unit id="d5cd5e33edb7ba1f8da45a2c106b29f5d941a815" translate="yes" xml:space="preserve">
          <source>You will do well to customize the name of your entry point to correspond to the name of the shared library you will be generating, rather than using the generic &quot;sqlite3_extension_init&quot; name. Giving your extension a custom entry point name will enable you to statically link two or more extensions into the same program without a linker conflict, if you later decide to use static linking rather than run-time linking. If your shared library ends up being named &quot;YourCode.so&quot; or &quot;YourCode.dll&quot; or &quot;YourCode.dylib&quot; as shown in the compiler examples above, then the correct entry point name would be &quot;sqlite3_yourcode_init&quot;.</source>
          <target state="translated">一般的な &quot;sqlite3_extension_init &quot;という名前を使うのではなく、生成する共有ライブラリの名前に対応するようにエントリーポイントの名前をカスタマイズすると良いでしょう。拡張機能にカスタムのエントリポイント名を与えることで、後でランタイムリンクではなくスタティックリンクを使うことにしても、リンカの競合なしに2つ以上の拡張機能を同じプログラムにスタティックにリンクすることができます。上記のコンパイラの例で示されているように、共有ライブラリが &quot;YourCode.so &quot;または &quot;YourCode.dll &quot;または &quot;YourCode.dylib &quot;という名前で終わる場合、正しいエントリーポイント名は &quot;sqlite3_yourcode_init &quot;になります。</target>
        </trans-unit>
        <trans-unit id="7ea7cb4b66409b042916564a60165ee172534600" translate="yes" xml:space="preserve">
          <source>You will notice that there is no &quot;sort&quot; box anywhere in the above diagram. The ORDER BY clause of the query has become a no-op. No sorting has to be done here because the output order is by the state column and the state column also happens to be the first column after the fruit column in the index. So, if we scan entries of the index that have the same value for the fruit column from top to bottom, those index entries are guaranteed to be ordered by the state column.</source>
          <target state="translated">上図のどこにも「ソート」ボックスがないことにお気づきでしょう。クエリのORDER BY句はノーオペとなっています。なぜなら、出力順序は状態カラムによるものであり、状態カラムはインデックスの果実カラムの後の最初のカラムでもあるからです。つまり、フルーツカラムの値が同じであるインデックスのエントリを上から下までスキャンすると、それらのインデックスのエントリは、ステートカラムによる順序が保証されます。</target>
        </trans-unit>
        <trans-unit id="909f99a779adb66a76fc53ab56c7dd1caf35d0fd" translate="yes" xml:space="preserve">
          <source>Z</source>
          <target state="translated">Z</target>
        </trans-unit>
        <trans-unit id="de7c952ac8080a02c7ac9ceb0a498a6696e8a4ba" translate="yes" xml:space="preserve">
          <source>ZIP Archive (using &lt;a href=&quot;zipfile&quot;&gt;zipfile&lt;/a&gt;)</source>
          <target state="translated">ZIPアーカイブ（&lt;a href=&quot;zipfile&quot;&gt;zipfile&lt;/a&gt;を使用）</target>
        </trans-unit>
        <trans-unit id="aed9db86a6be4caef2cf6fe06f1642f420130c81" translate="yes" xml:space="preserve">
          <source>ZIP Archive (using Info-ZIP 3.0)</source>
          <target state="translated">ZIPアーカイブ(Info-ZIP 3.0使用)</target>
        </trans-unit>
        <trans-unit id="02df620236f2819dde38ac784010df88429081e2" translate="yes" xml:space="preserve">
          <source>Zero Scan-Status Counters</source>
          <target state="translated">ゼロスキャン状態カウンタ</target>
        </trans-unit>
        <trans-unit id="1c76cf24ab11047f65399e2ad41b068487b4d36e" translate="yes" xml:space="preserve">
          <source>Zero all &lt;a href=&quot;#sqlite3_stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus()&lt;/a&gt; related event counters.</source>
          <target state="translated">すべての&lt;a href=&quot;#sqlite3_stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus（）&lt;/a&gt;関連のイベントカウンターをゼロにします。</target>
        </trans-unit>
        <trans-unit id="0189ea1500b8f88a4d451f2fe03811a0d2084600" translate="yes" xml:space="preserve">
          <source>Zero all &lt;a href=&quot;stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus()&lt;/a&gt; related event counters.</source>
          <target state="translated">すべての&lt;a href=&quot;stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus（）&lt;/a&gt;関連のイベントカウンターをゼロにします。</target>
        </trans-unit>
        <trans-unit id="3ab2b2e76dc0457f3573e771bc76b7e1dc6d462e" translate="yes" xml:space="preserve">
          <source>Zero or more changesets (or patchsets) are added to the object by calling sqlite3changegroup_add().</source>
          <target state="translated">sqlite3changegroup_add()を呼び出すことで、0個以上のチェンジセット(またはパッチセット)がオブジェクトに追加されます。</target>
        </trans-unit>
        <trans-unit id="ec69186fcac6fdc7aea5f5bb931cc915fc4d16f5" translate="yes" xml:space="preserve">
          <source>Zero or more escape sequences of the form &quot;&lt;b&gt;%&lt;i&gt;HH&lt;/i&gt;&lt;/b&gt;&quot; (where &lt;b&gt;&lt;i&gt;H&lt;/i&gt;&lt;/b&gt; represents any hexadecimal digit) can occur in the path, query string, or fragment.</source>
          <target state="translated">&quot; &lt;b&gt;％&lt;i&gt;HH&lt;/i&gt;&lt;/b&gt; &quot;（&lt;b&gt;&lt;i&gt;H&lt;/i&gt;&lt;/b&gt;は任意の16進数を表す）という形式のゼロ以上のエスケープシーケンスは、パス、クエリ文字列、またはフラグメントで発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="de6b47760256c38c352e812a03525532f246ee01" translate="yes" xml:space="preserve">
          <source>Zero or more of the following constants can be OR-ed together for the F argument to &lt;a href=&quot;#sqlite3_serialize&quot;&gt;sqlite3_serialize(D,S,P,F)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_serialize&quot;&gt;sqlite3_serialize（D、S、P、F）&lt;/a&gt;のF引数には、次の定数の0個以上をORで結合できます。</target>
        </trans-unit>
        <trans-unit id="9f8269aa118af918f1a488e66741b01a907d6b33" translate="yes" xml:space="preserve">
          <source>Zero or more of the following constants can be OR-ed together for the F argument to &lt;a href=&quot;serialize&quot;&gt;sqlite3_serialize(D,S,P,F)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;serialize&quot;&gt;sqlite3_serialize（D、S、P、F）&lt;/a&gt;のF引数には、次の定数の0個以上をORで結合できます。</target>
        </trans-unit>
        <trans-unit id="38a2e2f1db1e01b0a7b783b044e5fd65c8987a39" translate="yes" xml:space="preserve">
          <source>Zero or more term-offset lists. A term-offset list is present for each column of the FTS virtual table that contains the term. A term-offset list consists of the following:</source>
          <target state="translated">ゼロ個以上のターム・オフセット・リスト。条件オフセットリストは、条件を含む FTS 仮想テーブルの各列に存在します。条件オフセットリストは以下のもので構成されます。</target>
        </trans-unit>
        <trans-unit id="2515b49203ae7509e436f1b0d49f1c8ee6f4b1c9" translate="yes" xml:space="preserve">
          <source>Zero-Configuration</source>
          <target state="translated">Zero-Configuration</target>
        </trans-unit>
        <trans-unit id="eb706c03a671590ecb5597ee5876c02079a3bb36" translate="yes" xml:space="preserve">
          <source>Zipfile is included in most builds of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">Zipfileは、&lt;a href=&quot;cli&quot;&gt;コマンドラインシェルの&lt;/a&gt;ほとんどのビルドに含まれています。</target>
        </trans-unit>
        <trans-unit id="17013934d72000f10774f09cdfd9e948aabb0622" translate="yes" xml:space="preserve">
          <source>[+-]HH:MM</source>
          <target state="translated">[+-]HH:MM</target>
        </trans-unit>
        <trans-unit id="41cd6acf1ea38a1aa799ac385ce472b7a37c5a7c" translate="yes" xml:space="preserve">
          <source>[Top]</source>
          <target state="translated">[Top]</target>
        </trans-unit>
        <trans-unit id="6eb6de05767c9dc240cdb86a107e8527d6654c55" translate="yes" xml:space="preserve">
          <source>]&quot;.</source>
          <target state="translated">]&quot;.</target>
        </trans-unit>
        <trans-unit id="86f7e437faa5a7fce15d1ddcb9eaeaea377667b8" translate="yes" xml:space="preserve">
          <source>a</source>
          <target state="translated">a</target>
        </trans-unit>
        <trans-unit id="c8cfbdcc11a659b37fda2e901e339fc12d9d6f46" translate="yes" xml:space="preserve">
          <source>a file causes all modifications to the file up until that point to be committed to persistent storage.</source>
          <target state="translated">を実行すると、それまでのすべての変更が永続的なストレージにコミットされます。</target>
        </trans-unit>
        <trans-unit id="99cb3c351b6439359c3dacbec2f049764ce3028c" translate="yes" xml:space="preserve">
          <source>a journal file may contain. Following the</source>
          <target state="translated">ジャーナルファイルに含まれている可能性があります。に続いて</target>
        </trans-unit>
        <trans-unit id="5cc80862da2aa33790fc037208b79509f1c557d6" translate="yes" xml:space="preserve">
          <source>a power failure.</source>
          <target state="translated">停電。</target>
        </trans-unit>
        <trans-unit id="2d1a9beeff6f7710a34b3c2405a0c15a35e9231d" translate="yes" xml:space="preserve">
          <source>a program crash,</source>
          <target state="translated">プログラムのクラッシュ。</target>
        </trans-unit>
        <trans-unit id="044751c5b1c31e8b348678fdf3c4db6f20debbf5" translate="yes" xml:space="preserve">
          <source>a working VFS implementation.</source>
          <target state="translated">動作するVFSの実装を提供します。</target>
        </trans-unit>
        <trans-unit id="b66efa612eeb7d14f8d4f699c7f42ef4efb2b728" translate="yes" xml:space="preserve">
          <source>a working memory allocation subsystem (assuming it lacks malloc() in its standard library), and</source>
          <target state="translated">(標準ライブラリの malloc()を欠いていると仮定して)動作するメモリ割り当てサブシステムと</target>
        </trans-unit>
        <trans-unit id="f0125a8f48ac7cbf3a0fa6f9e607bcb1e7c92c25" translate="yes" xml:space="preserve">
          <source>a working mutex subsystem (but only if it is multithreaded),</source>
          <target state="translated">動作するミューテックスサブシステム(ただし、マルチスレッドの場合のみ)。</target>
        </trans-unit>
        <trans-unit id="2708db21dcd7430a52e6469ee28e1cfe107f6d3c" translate="yes" xml:space="preserve">
          <source>a&amp;gt;b &amp;amp;&amp;amp; c!=25</source>
          <target state="translated">a&amp;gt; b &amp;amp;&amp;amp; c！= 25</target>
        </trans-unit>
        <trans-unit id="4df530c1726c0c2dee72ae091abc6bd6366e8d88" translate="yes" xml:space="preserve">
          <source>a&amp;gt;b &amp;amp;&amp;amp; c==25</source>
          <target state="translated">a&amp;gt;b &amp;amp;&amp;amp; c==25</target>
        </trans-unit>
        <trans-unit id="c52869f9771a308e55286d56b7765c30b708737a" translate="yes" xml:space="preserve">
          <source>a&amp;gt;b &amp;amp;&amp;amp; c==25 =b&amp;gt;</source>
          <target state="translated">a&amp;gt; b &amp;amp;&amp;amp; c == 25 = b&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5ba16853ba475b847e9429658486a0e661f3bc0e" translate="yes" xml:space="preserve">
          <source>a&amp;lt;=b</source>
          <target state="translated">a&amp;lt;=b</target>
        </trans-unit>
        <trans-unit id="9e998d733fc47f01798c218ccb15b1375f8ca7c0" translate="yes" xml:space="preserve">
          <source>aAtomically releases the mutex and begins waiting for the asynchronous signal. When the signal arrives, continue.</source>
          <target state="translated">aミューテックスを解放し、非同期信号の待機を開始します。シグナルが到着したら、続行します。</target>
        </trans-unit>
        <trans-unit id="d068232ae7c98b60d3a07f78329a8f8cd2f26cec" translate="yes" xml:space="preserve">
          <source>aCksum</source>
          <target state="translated">aCksum</target>
        </trans-unit>
        <trans-unit id="a28254579c1920fcb23f28e750841b8ea01ece0f" translate="yes" xml:space="preserve">
          <source>aFrameCksum</source>
          <target state="translated">aFrameCksum</target>
        </trans-unit>
        <trans-unit id="8c9e7345f56d0515bc5b2a5a870c41d7b20d851a" translate="yes" xml:space="preserve">
          <source>aSalt</source>
          <target state="translated">aSalt</target>
        </trans-unit>
        <trans-unit id="b61646f016483b318b49a910668a966b6ce09ede" translate="yes" xml:space="preserve">
          <source>abort</source>
          <target state="translated">abort</target>
        </trans-unit>
        <trans-unit id="3e0d398e9ad5183bd74b0f22b3607f6d2d47ead6" translate="yes" xml:space="preserve">
          <source>abort() if X is false</source>
          <target state="translated">X が偽の場合は abort()</target>
        </trans-unit>
        <trans-unit id="c9f50c848be6913a38840cd508defd4c03582b92" translate="yes" xml:space="preserve">
          <source>abort() if X is true</source>
          <target state="translated">X が真ならば abort()</target>
        </trans-unit>
        <trans-unit id="f486f320564a8de306d258d39e1ac70a94dc6b0b" translate="yes" xml:space="preserve">
          <source>abs()</source>
          <target state="translated">abs()</target>
        </trans-unit>
        <trans-unit id="175250e2ace0eb1ce52a755c70fb5f1e848bdc1d" translate="yes" xml:space="preserve">
          <source>abs(X)</source>
          <target state="translated">abs(X)</target>
        </trans-unit>
        <trans-unit id="34eb4c4ef005207e8b8f916b9f1fffacccd6945e" translate="yes" xml:space="preserve">
          <source>action</source>
          <target state="translated">action</target>
        </trans-unit>
        <trans-unit id="e026c9e0723fb491279a1eff3c805402a81d6cd2" translate="yes" xml:space="preserve">
          <source>ad hoc</source>
          <target state="translated">その場限り</target>
        </trans-unit>
        <trans-unit id="3cfcd3a79bc61923da5dfbb696d2409e4b2955e4" translate="yes" xml:space="preserve">
          <source>added to the journal file since the header was written.</source>
          <target state="translated">ヘッダが書き込まれてからジャーナルファイルに追加されました。</target>
        </trans-unit>
        <trans-unit id="e62854369199d65b6a66cd90fe8203ac4d5be26c" translate="yes" xml:space="preserve">
          <source>advanced</source>
          <target state="translated">advanced</target>
        </trans-unit>
        <trans-unit id="9fca44c2ac1801310ef43bc3ad99ef04caf5190c" translate="yes" xml:space="preserve">
          <source>against the next row in the partition. Or, if there is no next row (because the current row is the last), NULL.</source>
          <target state="translated">をパーティションの次の行と比較します。または、次の行がない場合(現在の行が最後の行なので)はNULL。</target>
        </trans-unit>
        <trans-unit id="fc7e290f7ebb032393569e65485ec8d9e70de97a" translate="yes" xml:space="preserve">
          <source>against the previous row in the partition. Or, if there is no previous row (because the current row is the first), NULL.</source>
          <target state="translated">をパーティション内の前の行と比較します。または、前の行がない場合(現在の行が最初の行なので)はNULL。</target>
        </trans-unit>
        <trans-unit id="deb7d98201c161da24f10c309ec91b3c307e1924" translate="yes" xml:space="preserve">
          <source>against the row</source>
          <target state="translated">列に反して</target>
        </trans-unit>
        <trans-unit id="bccf7370fc6bc7e65ebb00bcd447b407dc6e3ec1" translate="yes" xml:space="preserve">
          <source>aggregate functions</source>
          <target state="translated">集計機能</target>
        </trans-unit>
        <trans-unit id="c0b3f3a802faf343304cca8929b77fc1f241297f" translate="yes" xml:space="preserve">
          <source>aggregate-function-invocation</source>
          <target state="translated">aggregate-function-invocation</target>
        </trans-unit>
        <trans-unit id="17422272e67559a3f7043ba681f79c857b96e811" translate="yes" xml:space="preserve">
          <source>aggregate-function-invocation:</source>
          <target state="translated">aggregate-function-invocation:</target>
        </trans-unit>
        <trans-unit id="0ce6198cbd869f28abe7f6b1573ce0dca8a6170f" translate="yes" xml:space="preserve">
          <source>aligned offset. If the</source>
          <target state="translated">整列されたオフセット。になっている場合には</target>
        </trans-unit>
        <trans-unit id="82f012d8e89e96e64b5b43b4004cf3ddd68b00da" translate="yes" xml:space="preserve">
          <source>aligned offset. To achieve this, unused space may be left between the start of the second and subsequent</source>
          <target state="translated">整列されたオフセット。これを達成するために、第2の開始とその後の</target>
        </trans-unit>
        <trans-unit id="d87c448044defb778f33158d8ccf94a20531d600" translate="yes" xml:space="preserve">
          <source>all</source>
          <target state="translated">all</target>
        </trans-unit>
        <trans-unit id="e5a003eeac959723c3ac098ade590d12e2399fce" translate="yes" xml:space="preserve">
          <source>all compound operators must be UNION ALL, and</source>
          <target state="translated">すべての複合演算子はUNION ALLでなければなりません。</target>
        </trans-unit>
        <trans-unit id="00c64f4edd51735ee4805d2cd8ebddb9e26e5786" translate="yes" xml:space="preserve">
          <source>along with a check-sum and some well known values that allow the</source>
          <target state="translated">を可能にするチェックサムといくつかのよく知られた値と一緒に</target>
        </trans-unit>
        <trans-unit id="4279d9254704eb29ea44fb0e50a8ddb988cb2a74" translate="yes" xml:space="preserve">
          <source>alter-table-stmt</source>
          <target state="translated">alter-table-stmt</target>
        </trans-unit>
        <trans-unit id="c11a9c425781e80397705cfadef04d01cc8571d9" translate="yes" xml:space="preserve">
          <source>alter-table-stmt:</source>
          <target state="translated">alter-table-stmt:</target>
        </trans-unit>
        <trans-unit id="c3869211fefbf6b6e81eafcd0da03d8e0475ead7" translate="yes" xml:space="preserve">
          <source>always contain NULL values. For detail=none FTS5 tables, there is one row in the fts5vocab table for each unique term/doc combination.</source>
          <target state="translated">は常にNULL値を含みます。detail=none FTS5テーブルの場合、fts5vocabテーブルには、それぞれのユニークな用語/docの組み合わせに対して1つの行が存在します。</target>
        </trans-unit>
        <trans-unit id="78cf975130f01cdd3fb405501316e890ca5febeb" translate="yes" xml:space="preserve">
          <source>always false</source>
          <target state="translated">虚々実々</target>
        </trans-unit>
        <trans-unit id="6cef04a132263fde51363b40fa3650c95beaa2e8" translate="yes" xml:space="preserve">
          <source>always occurs immediately after</source>
          <target state="translated">直後に必ず</target>
        </trans-unit>
        <trans-unit id="8d366ac66fb75ef6f601b4c82844cb7dabd40b61" translate="yes" xml:space="preserve">
          <source>always true</source>
          <target state="translated">常日頃から</target>
        </trans-unit>
        <trans-unit id="99d26625ec46b669549bed203aadeeb8e64a4713" translate="yes" xml:space="preserve">
          <source>an operating system crash, or</source>
          <target state="translated">オペレーティングシステムのクラッシュ</target>
        </trans-unit>
        <trans-unit id="e8db58b357be34c74707754f9ca1081a83143c52" translate="yes" xml:space="preserve">
          <source>analysis_limit</source>
          <target state="translated">analysis_limit</target>
        </trans-unit>
        <trans-unit id="1350a1a764c20c868eadef7c58ee7702c2de5903" translate="yes" xml:space="preserve">
          <source>analyze-stmt</source>
          <target state="translated">analyze-stmt</target>
        </trans-unit>
        <trans-unit id="09eeed07e3a7b9306cc98d6241ef6473440a058c" translate="yes" xml:space="preserve">
          <source>analyze-stmt:</source>
          <target state="translated">analyze-stmt:</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="c6138c4ccbaf04ec977b0820c3026e263f957c37" translate="yes" xml:space="preserve">
          <source>and close the file handle opened on the</source>
          <target state="translated">で開いたファイルハンドルを閉じて</target>
        </trans-unit>
        <trans-unit id="6a33f8ae1b5e041f1c572480c32c63e5cf451da7" translate="yes" xml:space="preserve">
          <source>and delete the</source>
          <target state="translated">を削除して</target>
        </trans-unit>
        <trans-unit id="b548e44c6b3e17d130e04633195b82b65a7a2d94" translate="yes" xml:space="preserve">
          <source>and must not be rolled back.</source>
          <target state="translated">とロールバックしてはいけません。</target>
        </trans-unit>
        <trans-unit id="9daed09ae8efcee7e50da2fbe84487fe3eebb5b9" translate="yes" xml:space="preserve">
          <source>and optionally a</source>
          <target state="translated">と、オプションで</target>
        </trans-unit>
        <trans-unit id="52d79db62a2014940054db6b52cb55b0ffc7318b" translate="yes" xml:space="preserve">
          <source>and query</source>
          <target state="translated">とクエリ</target>
        </trans-unit>
        <trans-unit id="95a8e5d9020987b9a76b684159376ad45fec7409" translate="yes" xml:space="preserve">
          <source>and read data from a database file.</source>
          <target state="translated">を使用して、データベースファイルからデータを読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="8b160fc621bf3b69e2326873b90cc01b0f9a0064" translate="yes" xml:space="preserve">
          <source>and so on. There is no limit to the number of</source>
          <target state="translated">といった具合に。の数に制限はありません。</target>
        </trans-unit>
        <trans-unit id="38d402cb5ba5ced669d83f33b900f232ec58d72a" translate="yes" xml:space="preserve">
          <source>and the</source>
          <target state="translated">そして、その</target>
        </trans-unit>
        <trans-unit id="52b8b92104263669b82872f84cf196bc98a98eb5" translate="yes" xml:space="preserve">
          <source>and the UPDATE statement has an ORDER BY clause, then all rows that would be updated in the absence of the LIMIT clause are sorted according to the ORDER BY and the first</source>
          <target state="translated">で、UPDATE文にORDER BY句がある場合、LIMIT句がない場合に更新されるすべての行は、ORDER BYに従ってソートされ、最初の</target>
        </trans-unit>
        <trans-unit id="05afb116d83a9696122e3d48be2ae0cf378a78fa" translate="yes" xml:space="preserve">
          <source>and the attempt to gain the</source>
          <target state="translated">を得ようとする試みと</target>
        </trans-unit>
        <trans-unit id="968ca042b5e705040bbdcde637032bd9d2191fa8" translate="yes" xml:space="preserve">
          <source>and the conflict resolution is REPLACE, then the INSERT change is removed from the local changeset (it was overridden). Or, if the conflict resolution was &quot;OMIT&quot;, then the local changeset is modified to instead contain:</source>
          <target state="translated">で、競合解決が REPLACE であった場合、INSERT 変更はローカルのチェンジセットから削除されます (オーバーライドされました)。または、競合解決が &quot;OMIT &quot;であった場合、ローカルのチェンジセットが変更され、代わりに含まれるようになります。</target>
        </trans-unit>
        <trans-unit id="46ef05dae314b8dc0b295ce6a15936ec49d9c864" translate="yes" xml:space="preserve">
          <source>and the document:</source>
          <target state="translated">と文書に記載されています。</target>
        </trans-unit>
        <trans-unit id="774d2fc3c7699ba3973db3b85b93a125fa1ced04" translate="yes" xml:space="preserve">
          <source>and the end of the</source>
          <target state="translated">と終わりの</target>
        </trans-unit>
        <trans-unit id="fb25e092bff28e2eaa8cec1baf32904bb2e25d70" translate="yes" xml:space="preserve">
          <source>and the following statement to be compiled:</source>
          <target state="translated">と、以下の文をコンパイルします。</target>
        </trans-unit>
        <trans-unit id="0fc5d26e62acc1fc0ed886776026281e0524d63b" translate="yes" xml:space="preserve">
          <source>and the start of the</source>
          <target state="translated">の始まりと</target>
        </trans-unit>
        <trans-unit id="27af5c77771c98d19d67acedd038a87f8e2d9d7c" translate="yes" xml:space="preserve">
          <source>and the user queries the swarmvtab table for the row with rowid value 25. The swarmvtab table will open database file &quot;test.db3&quot; and read the data to return from table &quot;t1&quot; (as 25 falls within the range of rowids assigned to table &quot;t1&quot; in &quot;test.db3&quot;).</source>
          <target state="translated">と表示され、ユーザは行 ID 値 25 の行について swarmvtab テーブルにクエリを実行します。swarmvtab テーブルはデータベースファイル &quot;test.db3&quot; を開き、テーブル &quot;t1&quot; から返すデータを読み込みます (25 は &quot;test.db3&quot; のテーブル &quot;t1&quot; に割り当てられた行 ID の範囲内にあるため)。</target>
        </trans-unit>
        <trans-unit id="de0be95e333d30a19f869ffbb56d16bebe7fe727" translate="yes" xml:space="preserve">
          <source>and the value of every 200th byte of page data interpreted as an 8-bit unsigned integer, starting with the (</source>
          <target state="translated">で始まる8ビットの符号なし整数として解釈されたページデータの200バイト目の各バイトの値です。</target>
        </trans-unit>
        <trans-unit id="16e461131871bd88245e8305df882aa6184b6089" translate="yes" xml:space="preserve">
          <source>and their accompanying sets of</source>
          <target state="translated">とそれに付随する</target>
        </trans-unit>
        <trans-unit id="f26fbdb7a04f5b991f74b3d08c9ab8e827a0dee5" translate="yes" xml:space="preserve">
          <source>and write data to a database file.</source>
          <target state="translated">を使用して、データベースファイルにデータを書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="b766070cd38845876a6730a003cdf53665805c86" translate="yes" xml:space="preserve">
          <source>any file within the file system flushes all write operations on all files (not just the</source>
          <target state="translated">ファイルシステム内の任意のファイルは、すべてのファイルに対するすべての書き込み操作をフラッシュします (</target>
        </trans-unit>
        <trans-unit id="86ebc97823e01049b3c5c82c964e3321c30d3460" translate="yes" xml:space="preserve">
          <source>any terms that begin with a specified prefix,</source>
          <target state="translated">指定された接頭辞で始まるすべての用語を指定します。</target>
        </trans-unit>
        <trans-unit id="20446ce193d349d88c1cb603fe2bfda6dd0fed46" translate="yes" xml:space="preserve">
          <source>appears to be an atomic event.</source>
          <target state="translated">が原子的なイベントに見える。</target>
        </trans-unit>
        <trans-unit id="c0fabcb2564734cccb39fbb1003542faa693274f" translate="yes" xml:space="preserve">
          <source>append a new database page to the database file image, or</source>
          <target state="translated">データベースファイルのイメージに新しいデータベースページを追加するか</target>
        </trans-unit>
        <trans-unit id="569e0c3e863ebdf5f2408ee1670ad397e2af3c31" translate="yes" xml:space="preserve">
          <source>application_id</source>
          <target state="translated">application_id</target>
        </trans-unit>
        <trans-unit id="bc7b492ad938673fdc3f7dd2d39d9a5b1a1313c5" translate="yes" xml:space="preserve">
          <source>are &lt;b&gt;atomic&lt;/b&gt; is the most complex task required of the system. In this case,</source>
          <target state="translated">ある&lt;b&gt;原子&lt;/b&gt;システムの要求される最も複雑な作業です。この場合、</target>
        </trans-unit>
        <trans-unit id="1657250024276d885f227f57c87321ab8a021f1e" translate="yes" xml:space="preserve">
          <source>are &lt;b&gt;durable&lt;/b&gt; in the face of a system failure, SQLite executes a</source>
          <target state="translated">SQLiteは、システム障害が発生しても&lt;b&gt;耐久性&lt;/b&gt;が&lt;b&gt;ある&lt;/b&gt;ため、</target>
        </trans-unit>
        <trans-unit id="97b47e4a3bed52672d52be489b68d62ee41fad83" translate="yes" xml:space="preserve">
          <source>are &lt;b&gt;isolated&lt;/b&gt;, before beginning to modify the contents of the database file to reflect the results of a</source>
          <target state="translated">されている&lt;b&gt;孤立&lt;/b&gt; Aの結果を反映するために、データベース・ファイルの内容を変更するために開始する前に、</target>
        </trans-unit>
        <trans-unit id="d8439b6ce689a8c1e42407d9870989374b7c1510" translate="yes" xml:space="preserve">
          <source>are all fine. The foreign key declared as part of table</source>
          <target state="translated">はすべて問題ありません。テーブルの一部として宣言された外部キー</target>
        </trans-unit>
        <trans-unit id="1e602c1c2b5b75b949e9cd5732b604bdf14a97ae" translate="yes" xml:space="preserve">
          <source>are applied.</source>
          <target state="translated">が適用されます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
