<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="96cc17a506c60ac9000086a1e0105e51d535d45e" translate="yes" xml:space="preserve">
          <source>The sqlite3_last_insert_rowid(D) interface usually returns the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the most recent successful &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; into a rowid table or &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; on database connection D. Inserts into &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are not recorded. If no successful &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;s into rowid tables have ever occurred on the database connection D, then sqlite3_last_insert_rowid(D) returns zero.</source>
          <target state="translated">sqlite3_last_insert_rowid（D）インターフェースは、通常返し&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;最新の成功の&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;行IDテーブルまたはに&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;にデータベース接続D.インサート上を&lt;a href=&quot;withoutrowid&quot;&gt;ROWIDをなし&lt;/a&gt;テーブルが記録されません。ROWIDテーブルへの正常な&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;がデータベース接続Dで発生したことがない場合、sqlite3_last_insert_rowid（D）はゼロを返します。</target>
        </trans-unit>
        <trans-unit id="97d28d93a8572fd39455b44f97795fb1531500e9" translate="yes" xml:space="preserve">
          <source>The sqlite3_load_extension() interface attempts to load an &lt;a href=&quot;../loadext&quot;&gt;SQLite extension&lt;/a&gt; library contained in the file zFile. If the file cannot be loaded directly, attempts are made to load with various operating-system specific extensions added. So for example, if &quot;samplelib&quot; cannot be loaded, then names like &quot;samplelib.so&quot; or &quot;samplelib.dylib&quot; or &quot;samplelib.dll&quot; might be tried also.</source>
          <target state="translated">sqlite3_load_extension（）インターフェースは、ファイルzFileに含まれる&lt;a href=&quot;../loadext&quot;&gt;SQLite拡張&lt;/a&gt;ライブラリをロードしようとします。ファイルを直接ロードできない場合は、オペレーティングシステム固有のさまざまな拡張機能を追加してロードが試行されます。たとえば、「samplelib」をロードできない場合、「samplelib.so」、「samplelib.dylib」、「samplelib.dll」などの名前も試される可能性があります。</target>
        </trans-unit>
        <trans-unit id="29a1d12e678745f57cc139b953c6116a8408aff6" translate="yes" xml:space="preserve">
          <source>The sqlite3_load_extension() interface attempts to load an &lt;a href=&quot;loadext&quot;&gt;SQLite extension&lt;/a&gt; library contained in the file zFile. If the file cannot be loaded directly, attempts are made to load with various operating-system specific extensions added. So for example, if &quot;samplelib&quot; cannot be loaded, then names like &quot;samplelib.so&quot; or &quot;samplelib.dylib&quot; or &quot;samplelib.dll&quot; might be tried also.</source>
          <target state="translated">sqlite3_load_extension（）インターフェースは、ファイルzFileに含まれる&lt;a href=&quot;loadext&quot;&gt;SQLite拡張&lt;/a&gt;ライブラリをロードしようとします。ファイルを直接ロードできない場合は、オペレーティングシステム固有のさまざまな拡張機能を追加してロードが試行されます。たとえば、「samplelib」をロードできない場合、「samplelib.so」、「samplelib.dylib」、「samplelib.dll」などの名前も試される可能性があります。</target>
        </trans-unit>
        <trans-unit id="653b87892cb27376af041bf3731e3304fd208799" translate="yes" xml:space="preserve">
          <source>The sqlite3_log() interface is intended for use by extensions such as virtual tables, collating functions, and SQL functions. While there is nothing to prevent an application from calling sqlite3_log(), doing so is considered bad form.</source>
          <target state="translated">sqlite3_log()インタフェースは、仮想テーブル、照合関数、SQL関数などの拡張機能での使用を意図しています。アプリケーションがsqlite3_log()を呼び出すことを妨げるものは何もありませんが、そうすることは悪いことだと考えられています。</target>
        </trans-unit>
        <trans-unit id="c4ad2aeb0d9be1f2327ef6d534ab004f6a2b8dc6" translate="yes" xml:space="preserve">
          <source>The sqlite3_malloc() routine returns a pointer to a block of memory at least N bytes in length, where N is the parameter. If sqlite3_malloc() is unable to obtain sufficient free memory, it returns a NULL pointer. If the parameter N to sqlite3_malloc() is zero or negative then sqlite3_malloc() returns a NULL pointer.</source>
          <target state="translated">sqlite3_malloc()ルーチンはNバイト以上のメモリブロックへのポインタを返します。sqlite3_malloc()が十分な空きメモリを取得できなかった場合、NULLポインタを返します。sqlite3_malloc()へのパラメータNが0か負の場合、sqlite3_malloc()はNULLポインタを返します。</target>
        </trans-unit>
        <trans-unit id="a4e65f99f4accbf5db989c9154cb81e75b9ee8ed" translate="yes" xml:space="preserve">
          <source>The sqlite3_malloc64(N) routine works just like sqlite3_malloc(N) except that N is an unsigned 64-bit integer instead of a signed 32-bit integer.</source>
          <target state="translated">sqlite3_malloc64(N)ルーチンはsqlite3_malloc(N)と同じように動作しますが、Nが符号付き32ビット整数ではなく符号なし64ビット整数であることを除きます。</target>
        </trans-unit>
        <trans-unit id="6aa420d40670b164a1cce9b427bd49e7d1c5fd88" translate="yes" xml:space="preserve">
          <source>The sqlite3_mprintf() and sqlite3_vmprintf() routines write their results into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt;. The strings returned by these two routines should be released by &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;. Both routines return a NULL pointer if &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; is unable to allocate enough memory to hold the resulting string.</source>
          <target state="translated">sqlite3_mprintf（）およびsqlite3_vmprintf（）ルーチンは、&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;から取得したメモリに結果を書き込みます。これら2つのルーチンによって返される文字列は、&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;によって解放される必要があります。&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;が結果の文字列を保持するのに十分なメモリを割り当てることができない場合、両方のルーチンはNULLポインタを返します。</target>
        </trans-unit>
        <trans-unit id="aeca10a8c44ac57eac0c9c7f71ba952063b68cc0" translate="yes" xml:space="preserve">
          <source>The sqlite3_mprintf() and sqlite3_vmprintf() routines write their results into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt;. The strings returned by these two routines should be released by &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;. Both routines return a NULL pointer if &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; is unable to allocate enough memory to hold the resulting string.</source>
          <target state="translated">sqlite3_mprintf（）およびsqlite3_vmprintf（）ルーチンは、&lt;a href=&quot;free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;から取得したメモリに結果を書き込みます。これら2つのルーチンによって返される文字列は、&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;によって解放される必要があります。&lt;a href=&quot;free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;が結果の文字列を保持するのに十分なメモリを割り当てることができない場合、両方のルーチンはNULLポインタを返します。</target>
        </trans-unit>
        <trans-unit id="f0bcf6e7726b974822789eb5eaa08500974adb52" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_alloc() routine allocates a new mutex and returns a pointer to it. The sqlite3_mutex_alloc() routine returns NULL if it is unable to allocate the requested mutex. The argument to sqlite3_mutex_alloc() must one of these integer constants:</source>
          <target state="translated">sqlite3_mutex_alloc()ルーチンは新しいミューテックスを確保し、そのポインタを返します。sqlite3_mutex_alloc()ルーチンは要求されたミューテックスを確保できなかった場合はNULLを返します。sqlite3_mutex_alloc()の引数はこれらの整数定数のいずれかでなければなりません。</target>
        </trans-unit>
        <trans-unit id="2d81df454ad810426381d8f39e8b57e0d9de3e46" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt to enter a mutex. If another thread is already within the mutex, sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return SQLITE_BUSY. The sqlite3_mutex_try() interface returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; upon successful entry. Mutexes created using SQLITE_MUTEX_RECURSIVE can be entered multiple times by the same thread. In such cases, the mutex must be exited an equal number of times before another thread can enter. If the same thread tries to enter any mutex other than an SQLITE_MUTEX_RECURSIVE more than once, the behavior is undefined.</source>
          <target state="translated">sqlite3_mutex_enter（）とsqlite3_mutex_try（）ルーチンは、ミューテックスに入ろうとします。別のスレッドがすでにミューテックス内にある場合、sqlite3_mutex_enter（）はブロックし、sqlite3_mutex_try（）はSQLITE_BUSYを返します。 sqlite3_mutex_try（）インターフェースは、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;エントリ&lt;/a&gt;が成功するとSQLITE_OKを返します。 SQLITE_MUTEX_RECURSIVEを使用して作成されたミューテックスは、同じスレッドで複数回入力できます。このような場合、別のスレッドが入る前に、ミューテックスは同じ回数終了する必要があります。同じスレッドがSQLITE_MUTEX_RECURSIVE以外のmutexに2回以上入ろうとした場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="3b45ebc24527ab0f89738f7016be66d43d5251ac" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt to enter a mutex. If another thread is already within the mutex, sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return SQLITE_BUSY. The sqlite3_mutex_try() interface returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; upon successful entry. Mutexes created using SQLITE_MUTEX_RECURSIVE can be entered multiple times by the same thread. In such cases, the mutex must be exited an equal number of times before another thread can enter. If the same thread tries to enter any mutex other than an SQLITE_MUTEX_RECURSIVE more than once, the behavior is undefined.</source>
          <target state="translated">sqlite3_mutex_enter（）とsqlite3_mutex_try（）ルーチンは、ミューテックスに入ろうとします。別のスレッドがすでにミューテックス内にある場合、sqlite3_mutex_enter（）はブロックし、sqlite3_mutex_try（）はSQLITE_BUSYを返します。 sqlite3_mutex_try（）インターフェースは、&lt;a href=&quot;../rescode#ok&quot;&gt;エントリ&lt;/a&gt;が成功するとSQLITE_OKを返します。 SQLITE_MUTEX_RECURSIVEを使用して作成されたミューテックスは、同じスレッドで複数回入力できます。このような場合、別のスレッドが入る前に、ミューテックスは同じ回数終了する必要があります。同じスレッドがSQLITE_MUTEX_RECURSIVE以外のmutexに2回以上入ろうとした場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="a9c3683cf3483b6e604960673d2e4ca248bc41dc" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_free() routine deallocates a previously allocated dynamic mutex. Attempting to deallocate a static mutex results in undefined behavior.</source>
          <target state="translated">sqlite3_mutex_free()ルーチンは以前に割り当てられた動的ミューテックスを解放します。静的ミューテックスを解放しようとすると、未定義の動作になります。</target>
        </trans-unit>
        <trans-unit id="c54fa9a704452135b01172d66edadf344257a173" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_held() and sqlite3_mutex_notheld() routines are intended for use inside assert() statements. The SQLite core never uses these routines except inside an assert() and applications are advised to follow the lead of the core. The SQLite core only provides implementations for these routines when it is compiled with the SQLITE_DEBUG flag. External mutex implementations are only required to provide these routines if SQLITE_DEBUG is defined and if NDEBUG is not defined.</source>
          <target state="translated">sqlite3_mutex_held()とsqlite3_mutex_notheld()ルーチンはassert()文の中で使用することを意図しています。SQLiteコアはこれらのルーチンをassert()の中以外で使用することはなく、アプリケーションはコアの指示に従うことをお勧めします。SQLite コアがこれらのルーチンの実装を提供するのは、SQLITE_DEBUG フラグを付けてコンパイルされた場合のみです。外部のミューテックス実装は、SQLITE_DEBUGが定義されていてNDEBUGが定義されていない場合にのみ、これらのルーチンを提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="93534cd54fb671abd29d988fdeee0858c44767d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_leave() routine exits a mutex that was previously entered by the same thread. The behavior is undefined if the mutex is not currently entered by the calling thread or is not currently allocated.</source>
          <target state="translated">sqlite3_mutex_leave()ルーチンは、以前に同じスレッドによって入力されたミューテックスを終了します。呼び出し元のスレッドが現在ミューテックスを入力していないか、または現在割り当てられていない場合の動作は定義されていません。</target>
        </trans-unit>
        <trans-unit id="fb745ae4bf7930e6464af0ad23559d80e7f2b3bc" translate="yes" xml:space="preserve">
          <source>The sqlite3_open() routine returns an integer error code rather than a pointer to the sqlite3 structure as the version 2 interface did. The difference between sqlite3_open() and sqlite3_open16() is that sqlite3_open16() takes UTF-16 (in host native byte order) for the name of the database file. If a new database file needs to be created, then sqlite3_open16() sets the internal text representation to UTF-16 whereas sqlite3_open() sets the text representation to UTF-8.</source>
          <target state="translated">sqlite3_open()ルーチンは、バージョン2インタフェースのようにsqlite3構造体へのポインタではなく、整数のエラーコードを返します。sqlite3_open()とsqlite3_open16()の違いは、sqlite3_open16()がデータベースファイルの名前にUTF-16(ホストネイティブのバイトオーダー)を取ることです。新しいデータベースファイルを作成する必要がある場合、sqlite3_open16()は内部のテキスト表現をUTF-16に設定し、sqlite3_open()はテキスト表現をUTF-8に設定します。</target>
        </trans-unit>
        <trans-unit id="49cca3441049c31bbff034c5494130978bd29358" translate="yes" xml:space="preserve">
          <source>The sqlite3_open_v2() interface works like sqlite3_open() except that it accepts two additional parameters for additional control over the new database connection. The flags parameter to sqlite3_open_v2() can take one of the following three values, optionally combined with the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;, &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;, &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;, and/or &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flags:</source>
          <target state="translated">sqlite3_open_v2（）インターフェースはsqlite3_open（）と同様に機能しますが、新しいデータベース接続をさらに制御するために2つの追加パラメーターを受け入れる点が異なります。 sqlite3_open_v2（）へのフラグパラメータは、次の3つの値のいずれかを取り、オプションで&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;、&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;、&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;、&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;、または&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;フラグと組み合わせることができます。</target>
        </trans-unit>
        <trans-unit id="e598ece82e5f2beb42f8604c9b91c3f1054b0c31" translate="yes" xml:space="preserve">
          <source>The sqlite3_open_v2() interface works like sqlite3_open() except that it accepts two additional parameters for additional control over the new database connection. The flags parameter to sqlite3_open_v2() can take one of the following three values, optionally combined with the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;, &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;, &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;, &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;, and/or &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flags:</source>
          <target state="translated">sqlite3_open_v2（）インターフェースはsqlite3_open（）と同様に機能しますが、新しいデータベース接続をさらに制御するために2つの追加パラメーターを受け入れる点が異なります。 sqlite3_open_v2（）へのフラグパラメータは、次の3つの値のいずれかを取り、オプションで&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;、&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;、&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;、&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;、または&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;フラグと組み合わせることができます。</target>
        </trans-unit>
        <trans-unit id="5a0142d09a66478c971c322bbffc0dda8bf83c4b" translate="yes" xml:space="preserve">
          <source>The sqlite3_open_v2() interface works like sqlite3_open() except that it accepts two additional parameters for additional control over the new database connection. The flags parameter to sqlite3_open_v2() must include, at a minimum, one of the following three flag combinations:</source>
          <target state="translated">sqlite3_open_v2()インタフェースはsqlite3_open()と同じように動作しますが、新しいデータベース接続を追加で制御するために2つの追加パラメータを受け付けることを除いては、sqlite3_open()と同じように動作します。sqlite3_open_v2()のフラグ・パラメータは、以下の3つのフラグの組み合わせのうちの1つを最低でも含めなければなりません。</target>
        </trans-unit>
        <trans-unit id="6e55b10d2fb69bf6bea01941ab944f29f8bde45c" translate="yes" xml:space="preserve">
          <source>The sqlite3_os_init() routine does operating-system specific initialization of the SQLite library. The sqlite3_os_end() routine undoes the effect of sqlite3_os_init(). Typical tasks performed by these routines include allocation or deallocation of static resources, initialization of global variables, setting up a default &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; module, or setting up a default configuration using &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_os_init（）ルーチンは、SQLiteライブラリのオペレーティングシステム固有の初期化を行います。sqlite3_os_end（）ルーチンは、sqlite3_os_init（）の効果を取り消します。これらのルーチンによって実行される典型的なタスクには、静的リソースの割り当てまたは割り当て解除、グローバル変数の初期化、デフォルトの&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;モジュールのセットアップ、または&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;を使用したデフォルト構成のセットアップが含まれます。</target>
        </trans-unit>
        <trans-unit id="ea78da5df45c282e78d4b89a318af0ce437587df" translate="yes" xml:space="preserve">
          <source>The sqlite3_os_init() routine does operating-system specific initialization of the SQLite library. The sqlite3_os_end() routine undoes the effect of sqlite3_os_init(). Typical tasks performed by these routines include allocation or deallocation of static resources, initialization of global variables, setting up a default &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; module, or setting up a default configuration using &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_os_init（）ルーチンは、SQLiteライブラリのオペレーティングシステム固有の初期化を行います。sqlite3_os_end（）ルーチンは、sqlite3_os_init（）の効果を取り消します。これらのルーチンによって実行される典型的なタスクには、静的リソースの割り当てまたは割り当て解除、グローバル変数の初期化、デフォルトの&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;モジュールのセットアップ、または&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;を使用したデフォルト構成のセットアップが含まれます。</target>
        </trans-unit>
        <trans-unit id="3bd4022600e005736b49c1c51ead1422ec8da9c9" translate="yes" xml:space="preserve">
          <source>The sqlite3_pcache type is opaque. It is implemented by the pluggable module. The SQLite core has no knowledge of its size or internal structure and never deals with the sqlite3_pcache object except by holding and passing pointers to the object.</source>
          <target state="translated">sqlite3_pcache型は不透明です。pluggableモジュールによって実装されています。SQLiteコアはそのサイズや内部構造を知らず、オブジェクトへのポインタを保持したり渡したりする以外、sqlite3_pcacheオブジェクトを扱うことはありません。</target>
        </trans-unit>
        <trans-unit id="07293c189451b8c181f77d9379a0238420ee3f47" translate="yes" xml:space="preserve">
          <source>The sqlite3_pcache_methods structure and the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache&quot;&gt;SQLITE_CONFIG_PCACHE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache&quot;&gt;SQLITE_CONFIG_GETPCACHE&lt;/a&gt; configuration parameters are deprecated. They are replaced by a new &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; structure and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache2&quot;&gt;SQLITE_CONFIG_GETPCACHE2&lt;/a&gt; configuration parameters.</source>
          <target state="translated">sqlite3_pcache_methods構造体、&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache&quot;&gt;SQLITE_CONFIG_PCACHE&lt;/a&gt;および&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache&quot;&gt;SQLITE_CONFIG_GETPCACHE&lt;/a&gt;構成パラメーターは非推奨になりました。これらは、新しい&lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt;構造と、&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;および&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache2&quot;&gt;SQLITE_CONFIG_GETPCACHE2&lt;/a&gt;構成パラメーターに置き換えられます。</target>
        </trans-unit>
        <trans-unit id="445aa02fd749c19bfbd930e14dfefb0c0e11a4d3" translate="yes" xml:space="preserve">
          <source>The sqlite3_pcache_page object represents a single page in the page cache. The page cache will allocate instances of this object. Various methods of the page cache use pointers to instances of this object as parameters or as their return value.</source>
          <target state="translated">sqlite3_pcache_pageオブジェクトは、ページキャッシュ内の1つのページを表します。ページキャッシュはこのオブジェクトのインスタンスを割り当てます。ページキャッシュの様々なメソッドはパラメータや戻り値としてこのオブジェクトのインスタンスへのポインタを使用します。</target>
        </trans-unit>
        <trans-unit id="7bf15591143e8308e465ab8ab773665acb5da577" translate="yes" xml:space="preserve">
          <source>The sqlite3_prepare interface compiles a single SQL statement into byte code for later execution. This interface is now the preferred way of accessing the database.</source>
          <target state="translated">sqlite3_prepareインタフェースは、後で実行するために単一のSQL文をバイトコードにコンパイルします。このインターフェイスは、現在ではデータベースにアクセスするための好ましい方法となっています。</target>
        </trans-unit>
        <trans-unit id="63425e76fcf41641f3bb3043a50f94b90abaff47" translate="yes" xml:space="preserve">
          <source>The sqlite3_prepare_v2(), sqlite3_prepare_v3(), sqlite3_prepare16_v2(), and sqlite3_prepare16_v3() interfaces are recommended for all new programs. The older interfaces (sqlite3_prepare() and sqlite3_prepare16()) are retained for backwards compatibility, but their use is discouraged. In the &quot;vX&quot; interfaces, the prepared statement that is returned (the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object) contains a copy of the original SQL text. This causes the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; interface to behave differently in three ways:</source>
          <target state="translated">sqlite3_prepare_v2（）、sqlite3_prepare_v3（）、sqlite3_prepare16_v2（）、およびsqlite3_prepare16_v3（）インターフェイスは、すべての新しいプログラムに推奨されます。古いインターフェース（sqlite3_prepare（）およびsqlite3_prepare16（））は、下位互換性のために保持されていますが、それらの使用はお勧めしません。 「vX」インターフェースでは、返される準備済みステートメント（&lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;オブジェクト）に元のSQLテキストのコピーが含まれています。これにより、&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;インターフェースの動作が3つ異なります。</target>
        </trans-unit>
        <trans-unit id="31c4a31d37db839c6c488798a5abc3fd1e42192d" translate="yes" xml:space="preserve">
          <source>The sqlite3_prepare_v2(), sqlite3_prepare_v3(), sqlite3_prepare16_v2(), and sqlite3_prepare16_v3() interfaces are recommended for all new programs. The older interfaces (sqlite3_prepare() and sqlite3_prepare16()) are retained for backwards compatibility, but their use is discouraged. In the &quot;vX&quot; interfaces, the prepared statement that is returned (the &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object) contains a copy of the original SQL text. This causes the &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; interface to behave differently in three ways:</source>
          <target state="translated">sqlite3_prepare_v2（）、sqlite3_prepare_v3（）、sqlite3_prepare16_v2（）、およびsqlite3_prepare16_v3（）インターフェイスは、すべての新しいプログラムに推奨されます。古いインターフェース（sqlite3_prepare（）およびsqlite3_prepare16（））は、下位互換性のために保持されていますが、それらの使用はお勧めしません。 「vX」インターフェースでは、返される準備済みステートメント（&lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;オブジェクト）に元のSQLテキストのコピーが含まれています。これにより、&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;インターフェースの動作が3つ異なります。</target>
        </trans-unit>
        <trans-unit id="1133258b4a9a31b0c0513ddc50dd402acde6047e" translate="yes" xml:space="preserve">
          <source>The sqlite3_progress_handler(D,N,X,P) interface causes the callback function X to be invoked periodically during long running calls to &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; for database connection D. An example use for this interface is to keep a GUI updated during a large query.</source>
          <target state="translated">sqlite3_progress_handler（D、N、X、P）インターフェースコールバック関数Xが長いへの呼び出しを実行中に定期的に起動させる&lt;a href=&quot;#sqlite3_exec&quot;&gt;）（sqlite3_exec&lt;/a&gt;、&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;と&lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_get_table（）&lt;/a&gt;このインタフェースのデータベース接続D.アンの使用例であるため大規模なクエリ中にGUIを更新し続けます。</target>
        </trans-unit>
        <trans-unit id="6ede9775015331a2dade498d028dbb0b1a89b661" translate="yes" xml:space="preserve">
          <source>The sqlite3_progress_handler(D,N,X,P) interface causes the callback function X to be invoked periodically during long running calls to &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; and &lt;a href=&quot;free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; for database connection D. An example use for this interface is to keep a GUI updated during a large query.</source>
          <target state="translated">sqlite3_progress_handler（D、N、X、P）インターフェースコールバック関数Xが長いへの呼び出しを実行中に定期的に起動させる&lt;a href=&quot;exec&quot;&gt;）（sqlite3_exec&lt;/a&gt;、&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;と&lt;a href=&quot;free_table&quot;&gt;sqlite3_get_table（）&lt;/a&gt;このインタフェースのデータベース接続D.アンの使用例であるため大規模なクエリ中にGUIを更新し続けます。</target>
        </trans-unit>
        <trans-unit id="92b3414b60e6ff01e63206d0ac8d5d46b8bec0e5" translate="yes" xml:space="preserve">
          <source>The sqlite3_realloc(X,N) interface attempts to resize a prior memory allocation X to be at least N bytes. If the X parameter to sqlite3_realloc(X,N) is a NULL pointer then its behavior is identical to calling sqlite3_malloc(N). If the N parameter to sqlite3_realloc(X,N) is zero or negative then the behavior is exactly the same as calling sqlite3_free(X). sqlite3_realloc(X,N) returns a pointer to a memory allocation of at least N bytes in size or NULL if insufficient memory is available. If M is the size of the prior allocation, then min(N,M) bytes of the prior allocation are copied into the beginning of buffer returned by sqlite3_realloc(X,N) and the prior allocation is freed. If sqlite3_realloc(X,N) returns NULL and N is positive, then the prior allocation is not freed.</source>
          <target state="translated">sqlite3_realloc(X,N)インタフェースは前のメモリ割り当てXを少なくともNバイトにリサイズしようとします。sqlite3_realloc(X,N)のXパラメータがNULLポインタの場合、その動作はsqlite3_malloc(N)の呼び出しと同じです。sqlite3_realloc(X,N)のNパラメータが0か負の場合はsqlite3_free(X)を呼び出すのと全く同じです。 sqlite3_realloc(X,N)は少なくともNバイトのメモリ割り当てへのポインタを返します。Mが前のアロケーションのサイズならば、前のアロケーションのmin(N,M)バイトがsqlite3_realloc(X,N)によって返されたバッファの先頭にコピーされ、前のアロケーションは解放されます。sqlite3_realloc(X,N)がNULLを返し、Nが正の場合、先行アロケーションは解放されません。</target>
        </trans-unit>
        <trans-unit id="e95adede07a7a66375653b101c394b5d26a89fcd" translate="yes" xml:space="preserve">
          <source>The sqlite3_realloc64(X,N) interfaces works the same as sqlite3_realloc(X,N) except that N is a 64-bit unsigned integer instead of a 32-bit signed integer.</source>
          <target state="translated">sqlite3_realloc64(X,N)インタフェースはsqlite3_realloc(X,N)と同じように動作しますが、Nが32ビット符号付き整数ではなく64ビット符号なし整数であることを除いては、sqlite3_realloc(X,N)と同じです。</target>
        </trans-unit>
        <trans-unit id="c45df4cf90bd7042631d9142c52fed7adb90361e" translate="yes" xml:space="preserve">
          <source>The sqlite3_rebaser object is deleted by calling sqlite3rebaser_delete().</source>
          <target state="translated">sqlite3_rebaserオブジェクトはsqlite3rebaser_delete()を呼び出すことで削除されます。</target>
        </trans-unit>
        <trans-unit id="4a286ff8214a968ca30b48466d6f539d2ffd723c" translate="yes" xml:space="preserve">
          <source>The sqlite3_release_memory() interface attempts to free N bytes of heap memory by deallocating non-essential memory allocations held by the database library. Memory used to cache database pages to improve performance is an example of non-essential memory. sqlite3_release_memory() returns the number of bytes actually freed, which might be more or less than the amount requested. The sqlite3_release_memory() routine is a no-op returning zero if SQLite is not compiled with &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;.</source>
          <target state="translated">sqlite3_release_memory（）インターフェイスは、データベースライブラリが保持している非必須メモリ割り当ての割り当てを解除することにより、Nバイトのヒープメモリを解放しようとします。パフォーマンスを向上させるためにデータベースページをキャッシュするために使用されるメモリは、非必須メモリの例です。 sqlite3_release_memory（）は、実際に解放されたバイト数を返します。これは、要求された量より多い場合も少ない場合もあります。 SQLiteが&lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENTで&lt;/a&gt;コンパイルされていない場合、sqlite3_release_memory（）ルーチンは何もしないでゼロを返します。</target>
        </trans-unit>
        <trans-unit id="e641eb92f089a94b694e1eb10428491e684eab1f" translate="yes" xml:space="preserve">
          <source>The sqlite3_release_memory() interface attempts to free N bytes of heap memory by deallocating non-essential memory allocations held by the database library. Memory used to cache database pages to improve performance is an example of non-essential memory. sqlite3_release_memory() returns the number of bytes actually freed, which might be more or less than the amount requested. The sqlite3_release_memory() routine is a no-op returning zero if SQLite is not compiled with &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;.</source>
          <target state="translated">sqlite3_release_memory（）インターフェイスは、データベースライブラリが保持している非必須メモリ割り当ての割り当てを解除することにより、Nバイトのヒープメモリを解放しようとします。パフォーマンスを向上させるためにデータベースページをキャッシュするために使用されるメモリは、非必須メモリの例です。 sqlite3_release_memory（）は、実際に解放されたバイト数を返します。これは、要求された量より多い場合も少ない場合もあります。 SQLiteが&lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENTで&lt;/a&gt;コンパイルされていない場合、sqlite3_release_memory（）ルーチンは何もしないでゼロを返します。</target>
        </trans-unit>
        <trans-unit id="54ae89d5ac2183e89297de25b936056b80fa288f" translate="yes" xml:space="preserve">
          <source>The sqlite3_reset() function is called to reset a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; object back to its initial state, ready to be re-executed. Any SQL statement variables that had values bound to them using the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_*() API&lt;/a&gt; retain their values. Use &lt;a href=&quot;#sqlite3_clear_bindings&quot;&gt;sqlite3_clear_bindings()&lt;/a&gt; to reset the bindings.</source>
          <target state="translated">sqlite3_reset（）関数が呼び出され、&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備されたステートメント&lt;/a&gt;オブジェクトが初期状態にリセットされ、再実行できるようになります。&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind _ *（）API&lt;/a&gt;を使用して値がバインドされたSQLステートメント変数は、その値を保持します。&lt;a href=&quot;#sqlite3_clear_bindings&quot;&gt;sqlite3_clear_bindings（）&lt;/a&gt;を使用してバインディングをリセットします。</target>
        </trans-unit>
        <trans-unit id="55cabea2592a4db5b69eb055b74aa3254a909a13" translate="yes" xml:space="preserve">
          <source>The sqlite3_reset() function is called to reset a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; object back to its initial state, ready to be re-executed. Any SQL statement variables that had values bound to them using the &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_*() API&lt;/a&gt; retain their values. Use &lt;a href=&quot;clear_bindings&quot;&gt;sqlite3_clear_bindings()&lt;/a&gt; to reset the bindings.</source>
          <target state="translated">sqlite3_reset（）関数が呼び出され、&lt;a href=&quot;stmt&quot;&gt;準備されたステートメント&lt;/a&gt;オブジェクトが初期状態にリセットされ、再実行できるようになります。&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind _ *（）API&lt;/a&gt;を使用して値がバインドされたSQLステートメント変数は、その値を保持します。&lt;a href=&quot;clear_bindings&quot;&gt;sqlite3_clear_bindings（）&lt;/a&gt;を使用してバインディングをリセットします。</target>
        </trans-unit>
        <trans-unit id="ee8a502aaf09ac296b4bb201f29d8a4e68054a04" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_blob() interface sets the result from an application-defined function to be the BLOB whose content is pointed to by the second parameter and which is N bytes long where N is the third parameter.</source>
          <target state="translated">sqlite3_result_blob()インタフェースは、アプリケーション定義関数の結果を、2番目のパラメータで指定された内容がNバイト長で、Nが3番目のパラメータであるBLOBに設定します。</target>
        </trans-unit>
        <trans-unit id="b7904572bea3279794f2bcc9179991e08e12d408" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_double() interface sets the result from an application-defined function to be a floating point value specified by its 2nd argument.</source>
          <target state="translated">sqlite3_result_double()インタフェースは、アプリケーション定義関数の結果を第2引数で指定された浮動小数点値に設定します。</target>
        </trans-unit>
        <trans-unit id="ea6209b4564a5f3773fd6febf3293c65522a4bc0" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error() and sqlite3_result_error16() functions cause the implemented SQL function to throw an exception. SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error() or sqlite3_result_error16() as the text of an error message. SQLite interprets the error message string from sqlite3_result_error() as UTF-8. SQLite interprets the string from sqlite3_result_error16() as UTF-16 in native byte order. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is negative then SQLite takes as the error message all text up through the first zero character. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is non-negative then SQLite takes that many bytes (not characters) from the 2nd parameter as the error message. The sqlite3_result_error() and sqlite3_result_error16() routines make a private copy of the error message text before they return. Hence, the calling function can deallocate or modify the text after they return without harm. The sqlite3_result_error_code() function changes the error code returned by SQLite as a result of an error in a function. By default, the error code is SQLITE_ERROR. A subsequent call to sqlite3_result_error() or sqlite3_result_error16() resets the error code to SQLITE_ERROR.</source>
          <target state="translated">sqlite3_result_error()関数とsqlite3_result_error16()関数は実装されたSQL関数に例外を発生させます。SQLiteは、sqlite3_result_error()またはsqlite3_result_error16()の2番目のパラメータが指す文字列をエラーメッセージのテキストとして使用します。SQLiteはsqlite3_result_error()からのエラーメッセージ文字列をUTF-8として解釈します。SQLiteはsqlite3_result_error16()からの文字列をネイティブバイト順でUTF-16として解釈します。sqlite3_result_error()またはsqlite3_result_error16()の3番目のパラメータが負の場合、SQLiteは最初の0文字までの全てのテキストをエラーメッセージとして受け取ります。sqlite3_result_error()またはsqlite3_result_error16()の3番目のパラメータが負でない場合、SQLiteは2番目のパラメータのバイト数(文字ではなく)をエラーメッセージとして受け取ります。sqlite3_result_error()とsqlite3_result_error16()ルーチンは返す前にエラーメッセージテキストのプライベートコピーを作成します。したがって、呼び出した関数は、それらが戻ってきた後でも害を与えることなくテキストを解放したり変更したりすることができます。sqlite3_result_error_code()関数は、関数内のエラーの結果としてSQLiteが返すエラーコードを変更します。デフォルトでは、エラーコードはSQLITE_ERRORです。sqlite3_result_error()またはsqlite3_result_error16()を呼び出すと、エラーコードはSQLITE_ERRORにリセットされます。</target>
        </trans-unit>
        <trans-unit id="29f28f42596987edc9ab24a265ebb7acbdeb19a7" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error() and sqlite3_result_error16() functions cause the implemented SQL function to throw an exception. SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error() or sqlite3_result_error16() as the text of an error message. SQLite interprets the error message string from sqlite3_result_error() as UTF-8. SQLite interprets the string from sqlite3_result_error16() as UTF-16 using the same &lt;a href=&quot;#byteorderdeterminationrules&quot;&gt;byte-order determination rules&lt;/a&gt; as &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_text16()&lt;/a&gt;. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is negative then SQLite takes as the error message all text up through the first zero character. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is non-negative then SQLite takes that many bytes (not characters) from the 2nd parameter as the error message. The sqlite3_result_error() and sqlite3_result_error16() routines make a private copy of the error message text before they return. Hence, the calling function can deallocate or modify the text after they return without harm. The sqlite3_result_error_code() function changes the error code returned by SQLite as a result of an error in a function. By default, the error code is SQLITE_ERROR. A subsequent call to sqlite3_result_error() or sqlite3_result_error16() resets the error code to SQLITE_ERROR.</source>
          <target state="translated">sqlite3_result_error（）およびsqlite3_result_error16（）関数により、実装されたSQL関数は例外をスローします。 SQLiteは、sqlite3_result_error（）またはsqlite3_result_error16（）の2番目のパラメーターが指す文字列をエラーメッセージのテキストとして使用します。 SQLiteは、sqlite3_result_error（）からのエラーメッセージ文字列をUTF-8として解釈します。 SQLiteは同じ使用UTF-16として）（sqlite3_result_error16から文字列を解釈する&lt;a href=&quot;#byteorderdeterminationrules&quot;&gt;バイト順決意ルールの&lt;/a&gt;ように&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;（sqlite3_bind_text16）&lt;/a&gt;。 sqlite3_result_error（）またはsqlite3_result_error16（）の3番目のパラメーターが負の場合、SQLiteは最初のゼロ文字までのすべてのテキストをエラーメッセージとして受け取ります。 sqlite3_result_error（）またはsqlite3_result_error16（）の3番目のパラメーターが負でない場合、SQLiteは2番目のパラメーターからその数のバイト（文字ではない）をエラーメッセージとして受け取ります。 sqlite3_result_error（）およびsqlite3_result_error16（）ルーチンは、返される前にエラーメッセージテキストのプライベートコピーを作成します。したがって、呼び出し元の関数は、テキストが戻った後、害を及ぼすことなく、テキストの割り当てを解除または変更できます。 sqlite3_result_error_code（）関数は、関数のエラーの結果としてSQLiteによって返されるエラーコードを変更します。デフォルトでは、エラーコードはSQLITE_ERRORです。その後のsqlite3_result_error（）またはsqlite3_result_error16（）の呼び出しにより、エラーコードがSQLITE_ERRORにリセットされます。</target>
        </trans-unit>
        <trans-unit id="c5a0bd3f253d68fda2502decfe5e0f0d13527f91" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error() and sqlite3_result_error16() functions cause the implemented SQL function to throw an exception. SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error() or sqlite3_result_error16() as the text of an error message. SQLite interprets the error message string from sqlite3_result_error() as UTF-8. SQLite interprets the string from sqlite3_result_error16() as UTF-16 using the same &lt;a href=&quot;bind_blob#byteorderdeterminationrules&quot;&gt;byte-order determination rules&lt;/a&gt; as &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_text16()&lt;/a&gt;. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is negative then SQLite takes as the error message all text up through the first zero character. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is non-negative then SQLite takes that many bytes (not characters) from the 2nd parameter as the error message. The sqlite3_result_error() and sqlite3_result_error16() routines make a private copy of the error message text before they return. Hence, the calling function can deallocate or modify the text after they return without harm. The sqlite3_result_error_code() function changes the error code returned by SQLite as a result of an error in a function. By default, the error code is SQLITE_ERROR. A subsequent call to sqlite3_result_error() or sqlite3_result_error16() resets the error code to SQLITE_ERROR.</source>
          <target state="translated">sqlite3_result_error（）およびsqlite3_result_error16（）関数により、実装されたSQL関数は例外をスローします。 SQLiteは、sqlite3_result_error（）またはsqlite3_result_error16（）の2番目のパラメーターが指す文字列をエラーメッセージのテキストとして使用します。 SQLiteは、sqlite3_result_error（）からのエラーメッセージ文字列をUTF-8として解釈します。 SQLiteは同じ使用UTF-16として）（sqlite3_result_error16から文字列を解釈する&lt;a href=&quot;bind_blob#byteorderdeterminationrules&quot;&gt;バイト順決意ルールの&lt;/a&gt;ように&lt;a href=&quot;bind_blob&quot;&gt;（sqlite3_bind_text16）&lt;/a&gt;。 sqlite3_result_error（）またはsqlite3_result_error16（）の3番目のパラメーターが負の場合、SQLiteは最初のゼロ文字までのすべてのテキストをエラーメッセージとして受け取ります。 sqlite3_result_error（）またはsqlite3_result_error16（）の3番目のパラメーターが負でない場合、SQLiteは2番目のパラメーターからその数のバイト（文字ではない）をエラーメッセージとして受け取ります。 sqlite3_result_error（）およびsqlite3_result_error16（）ルーチンは、返される前にエラーメッセージテキストのプライベートコピーを作成します。したがって、呼び出し元の関数は、テキストが戻った後、害を及ぼすことなく、テキストの割り当てを解除または変更できます。 sqlite3_result_error_code（）関数は、関数のエラーの結果としてSQLiteによって返されるエラーコードを変更します。デフォルトでは、エラーコードはSQLITE_ERRORです。その後のsqlite3_result_error（）またはsqlite3_result_error16（）の呼び出しにより、エラーコードがSQLITE_ERRORにリセットされます。</target>
        </trans-unit>
        <trans-unit id="9161e1bf262f2df329446fa1f6bc65f20e7794e5" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error_nomem() interface causes SQLite to throw an error indicating that a memory allocation failed.</source>
          <target state="translated">sqlite3_result_error_nomem()インターフェイスは、メモリ割り当てに失敗したことを示すエラーを SQLite にスローさせます。</target>
        </trans-unit>
        <trans-unit id="9e5d46d0dedea736182a8b4b5fc9e97d872ed801" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error_toobig() interface causes SQLite to throw an error indicating that a string or BLOB is too long to represent.</source>
          <target state="translated">sqlite3_result_error_toobig()インターフェースは、文字列やBLOBが長すぎて表現できないことを示すエラーをSQLiteにスローさせます。</target>
        </trans-unit>
        <trans-unit id="f6cfb870f85ac1c6d72052f09d1c9de9769820e3" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_int() interface sets the return value of the application-defined function to be the 32-bit signed integer value given in the 2nd argument. The sqlite3_result_int64() interface sets the return value of the application-defined function to be the 64-bit signed integer value given in the 2nd argument.</source>
          <target state="translated">sqlite3_result_int()インタフェースは、アプリケーション定義関数の戻り値を第2引数で与えられた32ビット符号付き整数値に設定します。sqlite3_result_int64()インタフェースは、アプリケーション定義関数の戻り値を第2引数で与えられた64ビット符号付き整数値に設定します。</target>
        </trans-unit>
        <trans-unit id="6279fe7ee925bdc0e3f640e0b50cfa7f6bf20e52" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_null() interface sets the return value of the application-defined function to be NULL.</source>
          <target state="translated">sqlite3_result_null()インタフェースは、アプリケーション定義関数の戻り値をNULLに設定します。</target>
        </trans-unit>
        <trans-unit id="16d6bb7320a3240a335aa7ac5ed9b9a1d6945bef" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_result_pointer（C、P、T、D）インターフェースは&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_null（C）&lt;/a&gt;と同様に結果をSQL NULL値に設定しますが、ホスト言語のポインターPまたはタイプTをそのNULL値に関連付け、そのポインターが&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_pointer（）&lt;/a&gt;を使用して、&lt;a href=&quot;#sqlite3_create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;内で取得できます。 DパラメータがNULLでない場合、それはPパラメータのデストラクタへのポインタです。 SQLiteは、SQLiteがPで終了したときに、唯一の引数としてPを使用してDを呼び出します。Tパラメータは静的文字列であり、文字列リテラルであることが望ましいです。 sqlite3_result_pointer（）ルーチンは、SQLite 3.20.0に追加された&lt;a href=&quot;bindptr&quot;&gt;ポインター受け渡しインターフェイスの&lt;/a&gt;一部です。</target>
        </trans-unit>
        <trans-unit id="2141ed898fc1d1e35a1c686aae779faa61d104a5" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_result_pointer（C、P、T、D）インターフェイスは、&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_null（C）&lt;/a&gt;と同様に、結果をSQL NULL値に設定しますが、ホスト言語ポインターPまたはタイプTをそのNULL値に関連付けて、ポインターが&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_pointer（）&lt;/a&gt;を使用して、&lt;a href=&quot;appfunc&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;内で取得できます。 DパラメーターがNULLでない場合、それはPパラメーターのデストラクタへのポインターです。 SQLiteがPで終了すると、SQLiteはPを唯一の引数としてDを呼び出します。Tパラメータは静的文字列である必要があり、できれば文字列リテラルである必要があります。 sqlite3_result_pointer（）ルーチンは、SQLite3.20.0用に追加された&lt;a href=&quot;bindptr&quot;&gt;ポインター受け渡しインターフェースの&lt;/a&gt;一部です。</target>
        </trans-unit>
        <trans-unit id="abeb9a4e536ac73c7793be889cbe18ade4a8329e" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_result_pointer（C、P、T、D）インターフェイスは、&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_null（C）&lt;/a&gt;と同様に、結果をSQL NULL値に設定しますが、ホスト言語ポインターPまたはタイプTをそのNULL値に関連付けて、ポインターが&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_pointer（）&lt;/a&gt;を使用して、&lt;a href=&quot;../appfunc&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;内で取得できます。 DパラメーターがNULLでない場合、それはPパラメーターのデストラクタへのポインターです。 SQLiteがPで終了すると、SQLiteはPを唯一の引数としてDを呼び出します。Tパラメータは静的文字列である必要があり、できれば文字列リテラルである必要があります。 sqlite3_result_pointer（）ルーチンは、SQLite3.20.0用に追加された&lt;a href=&quot;../bindptr&quot;&gt;ポインター受け渡しインターフェースの&lt;/a&gt;一部です。</target>
        </trans-unit>
        <trans-unit id="870667722e41d2c1c37c185e96c88c88778eea77" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;create_function&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_result_pointer（C、P、T、D）インターフェースは&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_null（C）&lt;/a&gt;と同様に結果をSQL NULL値に設定しますが、ホスト言語のポインターPまたはタイプTをそのNULL値に関連付け、そのポインターが&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_pointer（）&lt;/a&gt;を使用して、&lt;a href=&quot;create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;内で取得できます。 DパラメータがNULLでない場合、それはPパラメータのデストラクタへのポインタです。 SQLiteは、SQLiteがPで終了したときに、唯一の引数としてPを使用してDを呼び出します。Tパラメータは静的文字列であり、文字列リテラルであることが望ましいです。 sqlite3_result_pointer（）ルーチンは、SQLite 3.20.0に追加された&lt;a href=&quot;../bindptr&quot;&gt;ポインター受け渡しインターフェイスの&lt;/a&gt;一部です。</target>
        </trans-unit>
        <trans-unit id="a4e926904c44e1c10338c3ed629ffd93dee056e2" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="translated">sqlite3_result_subtype（C、T）関数は、&lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; Cを持つ&lt;a href=&quot;#sqlite3_create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;からの結果のサブタイプを値Tにします。SQLiteの現在のバージョンでは、サブタイプTの下位8ビットのみが保持されます。上位ビットは破棄されます。 SQLiteによって保持されるサブタイプのバイト数は、SQLiteの将来のリリースで増加する可能性があります。</target>
        </trans-unit>
        <trans-unit id="14b620485a8968d2bc78129bd173a352a06dd552" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="translated">sqlite3_result_subtype（C、T）関数からの結果のサブタイプせる&lt;a href=&quot;../appfunc&quot;&gt;アプリケーション定義SQL関数を&lt;/a&gt;用いて&lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt;のみサブタイプTの下位8ビットは、SQLiteの現在のバージョンで保存されている値TであることC。上位ビットは破棄されます。 SQLiteによって保持されるサブタイプバイトの数は、SQLiteの将来のリリースで増加する可能性があります。</target>
        </trans-unit>
        <trans-unit id="b466179681aeddfbf231a03d679d2648006d92dc" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="translated">sqlite3_result_subtype（C、T）関数からの結果のサブタイプせる&lt;a href=&quot;appfunc&quot;&gt;アプリケーション定義SQL関数を&lt;/a&gt;用いて&lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt;のみサブタイプTの下位8ビットは、SQLiteの現在のバージョンで保存されている値TであることC。上位ビットは破棄されます。 SQLiteによって保持されるサブタイプバイトの数は、SQLiteの将来のリリースで増加する可能性があります。</target>
        </trans-unit>
        <trans-unit id="d462f96f6d4a97e8d351d18ac7f1c494815765c7" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;create_function&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="translated">sqlite3_result_subtype（C、T）関数は、&lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; Cを持つ&lt;a href=&quot;create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;からの結果のサブタイプを値Tにします。SQLiteの現在のバージョンでは、サブタイプTの下位8ビットのみが保持されます。上位ビットは破棄されます。 SQLiteによって保持されるサブタイプのバイト数は、SQLiteの将来のリリースで増加する可能性があります。</target>
        </trans-unit>
        <trans-unit id="8fc6882e24d42f347f5ab25fb2f2b1c639f2f020" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_text(), sqlite3_result_text16(), sqlite3_result_text16le(), and sqlite3_result_text16be() interfaces set the return value of the application-defined function to be a text string which is represented as UTF-8, UTF-16 native byte order, UTF-16 little endian, or UTF-16 big endian, respectively. The sqlite3_result_text64() interface sets the return value of an application-defined function to be a text string in an encoding specified by the fifth (and last) parameter, which must be one of &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;. SQLite takes the text result from the application from the 2nd parameter of the sqlite3_result_text* interfaces. If the 3rd parameter to the sqlite3_result_text* interfaces is negative, then SQLite takes result text from the 2nd parameter through the first zero character. If the 3rd parameter to the sqlite3_result_text* interfaces is non-negative, then as many bytes (not characters) of the text pointed to by the 2nd parameter are taken as the application-defined function result. If the 3rd parameter is non-negative, then it must be the byte offset into the string where the NUL terminator would appear if the string where NUL terminated. If any NUL characters occur in the string at a byte offset that is less than the value of the 3rd parameter, then the resulting string will contain embedded NULs and the result of expressions operating on strings with embedded NULs is undefined. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that function as the destructor on the text or BLOB result when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or to sqlite3_result_blob is the special constant SQLITE_STATIC, then SQLite assumes that the text or BLOB result is in constant space and does not copy the content of the parameter nor call a destructor on the content when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is the special constant SQLITE_TRANSIENT then SQLite makes a copy of the result into space obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; before it returns.</source>
          <target state="translated">sqlite3_result_text（）、sqlite3_result_text16（）、sqlite3_result_text16le（）、およびsqlite3_result_text16be（）インターフェースは、アプリケーション定義関数の戻り値を、UTF-8、UTF-16ネイティブバイトオーダー、UTF-として表されるテキスト文字列に設定しますそれぞれ16リトルエンディアン、またはUTF-16ビッグエンディアン。 sqlite3_result_text64（）インターフェースは、アプリケーション定義関数の戻り値を、5番目（および最後）のパラメーターで指定されたエンコードのテキスト文字列に設定します。これは、&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;、&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;、&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;、または&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LEの&lt;/a&gt;いずれかである必要があります。 SQLiteはアプリケーションからのテキスト結果をsqlite3_result_text *インターフェースの2番目のパラメーターから取得します。 sqlite3_result_text *インターフェースの3番目のパラメーターが負の場合、SQLiteは2番目のパラメーターから最初のゼロ文字までの結果テキストを取得します。 sqlite3_result_text *インターフェースの3番目のパラメーターが負でない場合、2番目のパラメーターが指すテキストのバイト数（文字数ではない）がアプリケーション定義の関数の結果と見なされます。 3番目のパラメーターが負でない場合は、NULが終了した文字列がNULターミネーターで表示される文字列へのバイトオフセットでなければなりません。文字列の3番目のパラメータの値よりも小さいバイトオフセットでNUL文字が発生する場合、結果の文字列には埋め込みNULが含まれ、NULが埋め込まれた文字列を操作する式の結果は未定義です。 sqlite3_result_text *インターフェースまたはsqlite3_result_blobの4番目のパラメーターがNULL以外のポインターである場合、SQLiteは、その結果の使用を終了したときに、テキストまたはBLOB結果のデストラクタとしてその関数を呼び出します。 sqlite3_result_text *インターフェースまたはsqlite3_result_blobへの4番目のパラメーターが特別な定数SQLITE_STATICである場合、SQLiteはテキストまたはBLOBの結果が定数スペースにあると想定し、パラメーターのコンテンツをコピーせず、コンテンツのデストラクターを呼び出しませんその結果を使用して終了しました。sqlite3_result_text *インターフェースまたはsqlite3_result_blobの4番目のパラメーターが特別な定数SQLITE_TRANSIENTである場合、SQLiteは結果のコピーを&lt;a href=&quot;#sqlite3_free&quot;&gt;&lt;/a&gt;戻る前のsqlite3_malloc（）。</target>
        </trans-unit>
        <trans-unit id="ffc0515c64350de79930cdbbfae27bfbd23133bf" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_text(), sqlite3_result_text16(), sqlite3_result_text16le(), and sqlite3_result_text16be() interfaces set the return value of the application-defined function to be a text string which is represented as UTF-8, UTF-16 native byte order, UTF-16 little endian, or UTF-16 big endian, respectively. The sqlite3_result_text64() interface sets the return value of an application-defined function to be a text string in an encoding specified by the fifth (and last) parameter, which must be one of &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;. SQLite takes the text result from the application from the 2nd parameter of the sqlite3_result_text* interfaces. If the 3rd parameter to the sqlite3_result_text* interfaces is negative, then SQLite takes result text from the 2nd parameter through the first zero character. If the 3rd parameter to the sqlite3_result_text* interfaces is non-negative, then as many bytes (not characters) of the text pointed to by the 2nd parameter are taken as the application-defined function result. If the 3rd parameter is non-negative, then it must be the byte offset into the string where the NUL terminator would appear if the string where NUL terminated. If any NUL characters occur in the string at a byte offset that is less than the value of the 3rd parameter, then the resulting string will contain embedded NULs and the result of expressions operating on strings with embedded NULs is undefined. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that function as the destructor on the text or BLOB result when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or to sqlite3_result_blob is the special constant SQLITE_STATIC, then SQLite assumes that the text or BLOB result is in constant space and does not copy the content of the parameter nor call a destructor on the content when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is the special constant SQLITE_TRANSIENT then SQLite makes a copy of the result into space obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; before it returns.</source>
          <target state="translated">sqlite3_result_text（）、sqlite3_result_text16（）、sqlite3_result_text16le（）、およびsqlite3_result_text16be（）インターフェースは、アプリケーション定義関数の戻り値を、UTF-8、UTF-16ネイティブバイトオーダー、UTF-として表されるテキスト文字列に設定しますそれぞれ16リトルエンディアン、またはUTF-16ビッグエンディアン。 sqlite3_result_text64（）インターフェースは、アプリケーション定義関数の戻り値を、5番目（および最後）のパラメーターで指定されたエンコードのテキスト文字列に設定します。これは、&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;、&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;、&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;、または&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LEの&lt;/a&gt;いずれかである必要があります。 SQLiteはアプリケーションからのテキスト結果をsqlite3_result_text *インターフェースの2番目のパラメーターから取得します。 sqlite3_result_text *インターフェースの3番目のパラメーターが負の場合、SQLiteは2番目のパラメーターから最初のゼロ文字までの結果テキストを取得します。 sqlite3_result_text *インターフェースの3番目のパラメーターが負でない場合、2番目のパラメーターが指すテキストのバイト数（文字数ではない）がアプリケーション定義の関数の結果と見なされます。 3番目のパラメーターが負でない場合は、NULが終了した文字列がNULターミネーターで表示される文字列へのバイトオフセットでなければなりません。文字列の3番目のパラメータの値よりも小さいバイトオフセットでNUL文字が発生する場合、結果の文字列には埋め込みNULが含まれ、NULが埋め込まれた文字列を操作する式の結果は未定義です。 sqlite3_result_text *インターフェースまたはsqlite3_result_blobの4番目のパラメーターがNULL以外のポインターである場合、SQLiteは、その結果の使用を終了したときに、テキストまたはBLOB結果のデストラクタとしてその関数を呼び出します。 sqlite3_result_text *インターフェースまたはsqlite3_result_blobへの4番目のパラメーターが特別な定数SQLITE_STATICである場合、SQLiteはテキストまたはBLOBの結果が定数スペースにあると想定し、パラメーターのコンテンツをコピーせず、コンテンツのデストラクターを呼び出しませんその結果を使用して終了しました。sqlite3_result_text *インターフェースまたはsqlite3_result_blobの4番目のパラメーターが特別な定数SQLITE_TRANSIENTである場合、SQLiteは結果のコピーを&lt;a href=&quot;free&quot;&gt;&lt;/a&gt;戻る前のsqlite3_malloc（）。</target>
        </trans-unit>
        <trans-unit id="66d19148a84e04f07a639f83744f212454fd9d54" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_value() interface sets the result of the application-defined function to be a copy of the &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object specified by the 2nd parameter. The sqlite3_result_value() interface makes a copy of the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; so that the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; specified in the parameter may change or be deallocated after sqlite3_result_value() returns without harm. A &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; object may always be used where an &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object is required, so either kind of &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object can be used with this interface.</source>
          <target state="translated">sqlite3_result_value（）インターフェースは、アプリケーション定義関数の結果を、2番目のパラメーターで指定された&lt;a href=&quot;#sqlite3_value&quot;&gt;保護&lt;/a&gt;されていないsqlite3_valueオブジェクトのコピーに設定します。sqlite3_result_value（）インターフェースは&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_valueの&lt;/a&gt;コピーを作成するので、パラメーターで指定された&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;は、sqlite3_result_value（）が問題なく復帰した後に変更または割り当て解除できます。&lt;a href=&quot;#sqlite3_value&quot;&gt;保護sqlite3_value&lt;/a&gt;オブジェクトは、常にここで使用することができる&lt;a href=&quot;#sqlite3_value&quot;&gt;保護されていないsqlite3_value&lt;/a&gt;オブジェクトが要求されるので、いずれかの種類の&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;物体このインタフェースと共に使用することができます。</target>
        </trans-unit>
        <trans-unit id="9c611bb0b94d5204b93fd73ea02598841b3b449f" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_value() interface sets the result of the application-defined function to be a copy of the &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object specified by the 2nd parameter. The sqlite3_result_value() interface makes a copy of the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; so that the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; specified in the parameter may change or be deallocated after sqlite3_result_value() returns without harm. A &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; object may always be used where an &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object is required, so either kind of &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object can be used with this interface.</source>
          <target state="translated">sqlite3_result_value（）インターフェースは、アプリケーション定義関数の結果を、2番目のパラメーターで指定された&lt;a href=&quot;value&quot;&gt;保護&lt;/a&gt;されていないsqlite3_valueオブジェクトのコピーに設定します。sqlite3_result_value（）インターフェースは&lt;a href=&quot;value&quot;&gt;sqlite3_valueの&lt;/a&gt;コピーを作成するので、パラメーターで指定された&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;は、sqlite3_result_value（）が問題なく復帰した後に変更または割り当て解除できます。&lt;a href=&quot;value&quot;&gt;保護sqlite3_value&lt;/a&gt;オブジェクトは、常にここで使用することができる&lt;a href=&quot;value&quot;&gt;保護されていないsqlite3_value&lt;/a&gt;オブジェクトが要求されるので、いずれかの種類の&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;物体このインタフェースと共に使用することができます。</target>
        </trans-unit>
        <trans-unit id="3b2bde2ed5663531d681bf21defe3755de5aa926" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_zeroblob(C,N) and sqlite3_result_zeroblob64(C,N) interfaces set the result of the application-defined function to be a BLOB containing all zero bytes and N bytes in size.</source>
          <target state="translated">sqlite3_result_zeroblob(C,N)とsqlite3_result_zeroblob64(C,N)インタフェースは、アプリケーション定義関数の結果を、すべてのゼロバイトとNバイトのサイズを含むBLOBに設定します。</target>
        </trans-unit>
        <trans-unit id="38bbbf7ab9a0945b32615ce5c77fecc3dda2b8bb" translate="yes" xml:space="preserve">
          <source>The sqlite3_rtree_geometry structure that the first argument to the xGeom callback points to has a structure shown below. The exact same sqlite3_rtree_geometry structure is used for every callback for same MATCH operator in the same query. The contents of the sqlite3_rtree_geometry structure are initialized by SQLite but are not subsequently modified. The callback is free to make changes to the pUser and xDelUser elements of the structure if desired.</source>
          <target state="translated">xGeomコールバックの第一引数が指すsqlite3_rtree_geometry構造体は以下のような構造体です。全く同じsqlite3_rtree_geometry構造体が、同じクエリ内の同じMATCH演算子のコールバックで使用されます。sqlite3_rtree_geometry構造体の内容はSQLiteによって初期化されますが、その後変更されることはありません。コールバックは、必要に応じて構造体のpUserとxDelUser要素を自由に変更することができます。</target>
        </trans-unit>
        <trans-unit id="23ca7c4bc54ebb3192ebcd695698caa11c607135" translate="yes" xml:space="preserve">
          <source>The sqlite3_rtree_query_callback() became available with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_5.html&quot;&gt;version 3.8.5&lt;/a&gt; (2014-06-04) and is the preferred interface. The sqlite3_rtree_geometry_callback() is an older and less flexible interface that is supported for backwards compatibility.</source>
          <target state="translated">sqlite3_rtree_query_callback（）はSQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_5.html&quot;&gt;バージョン3.8.5&lt;/a&gt;（2014-06-04）で使用可能になり、推奨されるインターフェースです。sqlite3_rtree_geometry_callback（）は、下位互換性のためにサポートされている古くて柔軟性の低いインターフェースです。</target>
        </trans-unit>
        <trans-unit id="a4141688a761802a4dde7063e989412b5ba08576" translate="yes" xml:space="preserve">
          <source>The sqlite3_serialize(D,S,P,F) interface returns a pointer to memory that is a serialization of the S database on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D. If P is not a NULL pointer, then the size of the database in bytes is written into *P.</source>
          <target state="translated">sqlite3_serialize（D、S、P、F）インターフェイスは、&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt; D 上のSデータベースのシリアル化であるメモリへのポインターを返します。PがNULLポインターでない場合、データベースのサイズ（バイト単位）が*に書き込まれます。 P</target>
        </trans-unit>
        <trans-unit id="fd8828a508df0b7bef3d1d62a2ae33a5520d58f6" translate="yes" xml:space="preserve">
          <source>The sqlite3_serialize(D,S,P,F) interface returns a pointer to memory that is a serialization of the S database on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D. If P is not a NULL pointer, then the size of the database in bytes is written into *P.</source>
          <target state="translated">sqlite3_serialize（D、S、P、F）インターフェイスは、&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt; D 上のSデータベースのシリアル化であるメモリへのポインターを返します。PがNULLポインターでない場合、データベースのサイズ（バイト単位）が*に書き込まれます。 P</target>
        </trans-unit>
        <trans-unit id="d9311ad5ed8e88f0e0e396fbe1a059c5d4e870f6" translate="yes" xml:space="preserve">
          <source>The sqlite3_set_auxdata(C,N,P,X) interface saves P as metadata for the N-th argument of the application-defined function. Subsequent calls to sqlite3_get_auxdata(C,N) return P from the most recent sqlite3_set_auxdata(C,N,P,X) call if the metadata is still valid or NULL if the metadata has been discarded. After each call to sqlite3_set_auxdata(C,N,P,X) where X is not NULL, SQLite will invoke the destructor function X with parameter P exactly once, when the metadata is discarded. SQLite is free to discard the metadata at any time, including:</source>
          <target state="translated">sqlite3_set_auxdata(C,N,P,X)インタフェースは、アプリケーション定義関数のN番目の引数のメタデータとしてPを保存します。sqlite3_get_auxdata(C,N)のそれ以降の呼び出しは、メタデータがまだ有効な場合は最新のsqlite3_set_auxdata(C,N,P,X)呼び出しのPを返し、メタデータが破棄された場合はNULLを返します。XがNULLではない場合はsqlite3_set_auxdata(C,N,P,X)を呼び出すたびに、メタデータが破棄されると、SQLiteはパラメータPを持つデストラクタ関数Xを一度だけ呼び出します。SQLiteはメタデータをいつでも自由に破棄することができます。</target>
        </trans-unit>
        <trans-unit id="ce7e4094de25df6c5d0672255fe4f34354822777" translate="yes" xml:space="preserve">
          <source>The sqlite3_set_last_insert_rowid(D, R) method allows the application to set the value returned by calling sqlite3_last_insert_rowid(D) to R without inserting a row into the database.</source>
          <target state="translated">sqlite3_set_last_insert_rowid(D,R)メソッドは、アプリケーションがsqlite3_last_insert_rowid(D)を呼び出して返された値をデータベースに行を挿入せずにRに設定することを可能にします。</target>
        </trans-unit>
        <trans-unit id="e1bb92256471e00d9337dbe91acedaceec62010e" translate="yes" xml:space="preserve">
          <source>The sqlite3_sleep() function causes the current thread to suspend execution for at least a number of milliseconds specified in its parameter.</source>
          <target state="translated">sqlite3_sleep()関数は、現在のスレッドに、そのパラメータで指定されたミリ秒数以上の間、実行を中断させます。</target>
        </trans-unit>
        <trans-unit id="932dc970d1649bf3cbe1cd6e521c5a774af59735" translate="yes" xml:space="preserve">
          <source>The sqlite3_snapshot object records state information about an historical version of the database file so that it is possible to later open a new read transaction that sees that historical version of the database rather than the most recent version.</source>
          <target state="translated">sqlite3_snapshotオブジェクトはデータベースファイルの履歴バージョンの状態情報を記録します。これにより、後で最新バージョンではなく履歴バージョンのデータベースを見る新しい読み込みトランザクションを開くことができます。</target>
        </trans-unit>
        <trans-unit id="242ec5992913a3f34748a4cb2f4099b50b723004" translate="yes" xml:space="preserve">
          <source>The sqlite3_snapshot_cmp(P1, P2) interface is used to compare the ages of two valid snapshot handles.</source>
          <target state="translated">sqlite3_snapshot_cmp(P1,P2)インターフェースは、2つの有効なスナップショットハンドルの年齢を比較するために使用されます。</target>
        </trans-unit>
        <trans-unit id="01e7a2ddf509d560437f8041b7f083cd66113cd5" translate="yes" xml:space="preserve">
          <source>The sqlite3_snprintf() routine is similar to &quot;snprintf()&quot; from the standard C library. The result is written into the buffer supplied as the second parameter whose size is given by the first parameter. Note that the order of the first two parameters is reversed from snprintf(). This is an historical accident that cannot be fixed without breaking backwards compatibility. Note also that sqlite3_snprintf() returns a pointer to its buffer instead of the number of characters actually written into the buffer. We admit that the number of characters written would be a more useful return value but we cannot change the implementation of sqlite3_snprintf() now without breaking compatibility.</source>
          <target state="translated">sqlite3_snprintf()ルーチンは標準Cライブラリのsnprintf()に似ています。結果は2番目のパラメータとして与えられたバッファに書き込まれ、そのバッファのサイズは1番目のパラメータで与えられます。最初の 2 つのパラメータの順序が snprintf()とは逆になっていることに注意してください。これは歴史的な事故であり、下位互換性を壊さずに修正することはできません。また、sqlite3_snprintf()は実際にバッファに書き込まれた文字数ではなく、バッファへのポインタを返すことにも注意してください。書き込まれた文字数の方がより有用な戻り値であることは認めますが、互換性を壊さずにsqlite3_snprintf()の実装を変更することはできません。</target>
        </trans-unit>
        <trans-unit id="a1e7c63d0192b11455ed615eabf6f8b339d7c44c" translate="yes" xml:space="preserve">
          <source>The sqlite3_soft_heap_limit64() interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite. SQLite strives to keep heap memory utilization below the soft heap limit by reducing the number of pages held in the page cache as heap memory usages approaches the limit. The soft heap limit is &quot;soft&quot; because even though SQLite strives to stay below the limit, it will exceed the limit rather than generate an &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; error. In other words, the soft heap limit is advisory only.</source>
          <target state="translated">sqlite3_soft_heap_limit64（）インターフェースは、SQLiteによって割り当てられる可能性のあるヒープメモリ量のソフト制限を設定または照会します。 SQLiteは、ヒープメモリの使用量が制限に近づくと、ページキャッシュに保持されるページ数を減らすことにより、ヒープメモリの使用率をソフトヒープ制限未満に保つよう努めます。ソフトヒープ制限は「ソフト」です。なぜなら、SQLiteが制限を下回らないように努めても、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;エラーを生成するのではなく、制限を超えてしまうからです。言い換えると、ソフトヒープ制限は推奨のみです。</target>
        </trans-unit>
        <trans-unit id="d5aefe7f58cf6098f950ef6aaad46d0524e32f68" translate="yes" xml:space="preserve">
          <source>The sqlite3_soft_heap_limit64() interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite. SQLite strives to keep heap memory utilization below the soft heap limit by reducing the number of pages held in the page cache as heap memory usages approaches the limit. The soft heap limit is &quot;soft&quot; because even though SQLite strives to stay below the limit, it will exceed the limit rather than generate an &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; error. In other words, the soft heap limit is advisory only.</source>
          <target state="translated">sqlite3_soft_heap_limit64（）インターフェースは、SQLiteによって割り当てられる可能性のあるヒープメモリ量のソフト制限を設定または照会します。 SQLiteは、ヒープメモリの使用量が制限に近づくと、ページキャッシュに保持されるページ数を減らすことにより、ヒープメモリの使用率をソフトヒープ制限未満に保つよう努めます。ソフトヒープ制限は「ソフト」です。なぜなら、SQLiteが制限を下回らないように努めても、&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;エラーを生成するのではなく、制限を超えてしまうからです。言い換えると、ソフトヒープ制限は推奨のみです。</target>
        </trans-unit>
        <trans-unit id="b94ad72c9e1e61f387a8b9571668f6ee1d93f6d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_sql(P) interface returns a pointer to a copy of the UTF-8 SQL text used to create &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P if P was created by &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;. The sqlite3_expanded_sql(P) interface returns a pointer to a UTF-8 string containing the SQL text of prepared statement P with &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; expanded. The sqlite3_normalized_sql(P) interface returns a pointer to a UTF-8 string containing the normalized SQL text of prepared statement P. The semantics used to normalize a SQL statement are unspecified and subject to change. At a minimum, literal values will be replaced with suitable placeholders.</source>
          <target state="translated">Pが&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;、または&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;によって作成された場合、sqlite3_sql（P）インターフェイスは、&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備済みステートメント&lt;/a&gt; Pの作成に使用されるUTF-8 SQLテキストのコピーへのポインターを返します。 sqlite3_expanded_sql（P）インターフェースは、&lt;a href=&quot;lang_expr#varparam&quot;&gt;バインドされたパラメーターが&lt;/a&gt;展開された準備済みステートメントPのSQLテキストを含むUTF-8文字列へのポインターを返します。 sqlite3_normalized_sql（P）インターフェースは、準備されたステートメントPの正規化されたSQLテキストを含むUTF-8文字列へのポインターを返します。SQLステートメントの正規化に使用されるセマンティクスは指定されておらず、変更される可能性があります。少なくとも、リテラル値は適切なプレースホルダーに置き換えられます。</target>
        </trans-unit>
        <trans-unit id="45ba0cce80e217739aee37fc8f257b9f4497c286" translate="yes" xml:space="preserve">
          <source>The sqlite3_sql(P) interface returns a pointer to a copy of the UTF-8 SQL text used to create &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P if P was created by &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;. The sqlite3_expanded_sql(P) interface returns a pointer to a UTF-8 string containing the SQL text of prepared statement P with &lt;a href=&quot;../lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; expanded. The sqlite3_normalized_sql(P) interface returns a pointer to a UTF-8 string containing the normalized SQL text of prepared statement P. The semantics used to normalize a SQL statement are unspecified and subject to change. At a minimum, literal values will be replaced with suitable placeholders.</source>
          <target state="translated">Pが&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;、&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;、&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;、または&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;によって作成された場合、sqlite3_sql（P）インターフェイスは、&lt;a href=&quot;stmt&quot;&gt;準備済みステートメント&lt;/a&gt; Pの作成に使用されるUTF-8 SQLテキストのコピーへのポインターを返します。 sqlite3_expanded_sql（P）インターフェースは、&lt;a href=&quot;../lang_expr#varparam&quot;&gt;バインドされたパラメーターが&lt;/a&gt;展開された準備済みステートメントPのSQLテキストを含むUTF-8文字列へのポインターを返します。 sqlite3_normalized_sql（P）インターフェースは、準備されたステートメントPの正規化されたSQLテキストを含むUTF-8文字列へのポインターを返します。SQLステートメントの正規化に使用されるセマンティクスは指定されておらず、変更される可能性があります。少なくとも、リテラル値は適切なプレースホルダーに置き換えられます。</target>
        </trans-unit>
        <trans-unit id="e775091a2d75ef8eec628ca58240bb3a4c44f41a" translate="yes" xml:space="preserve">
          <source>The sqlite3_status() and sqlite3_status64() routines return SQLITE_OK on success and a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">sqlite3_status（）とsqlite3_status64（）ルーチンは、成功するとSQLITE_OKを返し、失敗するとゼロ以外の&lt;a href=&quot;../rescode&quot;&gt;エラーコード&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="08017cba5dea56fb38bd261f36812b68e5da595b" translate="yes" xml:space="preserve">
          <source>The sqlite3_status() and sqlite3_status64() routines return SQLITE_OK on success and a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">sqlite3_status（）とsqlite3_status64（）ルーチンは、成功するとSQLITE_OKを返し、失敗するとゼロ以外の&lt;a href=&quot;rescode&quot;&gt;エラーコード&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="8844a5c0b1eb32242054752c1e25f36f36feae1a" translate="yes" xml:space="preserve">
          <source>The sqlite3_step() interface returns SQLITE_BUSY if it is unable to commit a change because of a lock</source>
          <target state="translated">sqlite3_step()インタフェースは、ロックのために変更をコミットできない場合、SQLITE_BUSYを返します。</target>
        </trans-unit>
        <trans-unit id="aadfbac7c6cbfe9d27468ec7c9a622af76c3660e" translate="yes" xml:space="preserve">
          <source>The sqlite3_step() routine return SQLITE_ROW if it is returning a single row of the result set, or SQLITE_DONE if execution has completed, either normally or due to an error. It might also return SQLITE_BUSY if it is unable to open the database file. If the return value is SQLITE_ROW, then the following routines can be used to extract information about that row of the result set:</source>
          <target state="translated">sqlite3_step()ルーチンは、結果セットの1行を返している場合はSQLITE_ROWを、実行が正常かエラーのために完了した場合はSQLITE_DONEを返します。また、データベースファイルを開くことができない場合は SQLITE_BUSY を返すかもしれません。返り値がSQLITE_ROWの場合、以下のルーチンを使用して結果セットのその行に関する情報を抽出することができます。</target>
        </trans-unit>
        <trans-unit id="68ecf4c95ec171ac99c79d0f7b7218a0a2a7996e" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_busy(S) interface returns true (non-zero) if the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S has been stepped at least once using &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt; but has neither run to completion (returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; from &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt;) nor been reset using &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt;. The sqlite3_stmt_busy(S) interface returns false if S is a NULL pointer. If S is not a NULL pointer and is not a pointer to a valid &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; object, then the behavior is undefined and probably undesirable.</source>
          <target state="translated">（非ゼロ）sqlite3_stmt_busy（S）インタフェースを返すtrueの場合&lt;a href=&quot;#sqlite3_stmt&quot;&gt;、準備されたステートメント&lt;/a&gt; Sは、少なくとも使用して一度強化された&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（S）の&lt;/a&gt;が、完了するまでもないラン（返されてい&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;から&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（S）を&lt;/a&gt;使用してリセット）もあった&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_resetを（ S）&lt;/a&gt;。SがNULLポインターの場合、sqlite3_stmt_busy（S）インターフェイスはfalseを返します。SがNULLポインターではなく、有効な&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備済みステートメント&lt;/a&gt;オブジェクトへのポインターでない場合、動作は未定義であり、おそらく望ましくありません。</target>
        </trans-unit>
        <trans-unit id="30e9a2351b8f1f389c8c1f5ed3bb5643292d6719" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_busy(S) interface returns true (non-zero) if the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S has been stepped at least once using &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt; but has neither run to completion (returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; from &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt;) nor been reset using &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt;. The sqlite3_stmt_busy(S) interface returns false if S is a NULL pointer. If S is not a NULL pointer and is not a pointer to a valid &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; object, then the behavior is undefined and probably undesirable.</source>
          <target state="translated">（非ゼロ）sqlite3_stmt_busy（S）インタフェースを返すtrueの場合&lt;a href=&quot;stmt&quot;&gt;、準備されたステートメント&lt;/a&gt; Sは、少なくとも使用して一度強化された&lt;a href=&quot;step&quot;&gt;sqlite3_step（S）の&lt;/a&gt;が、完了するまでもないラン（返されてい&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;から&lt;a href=&quot;step&quot;&gt;sqlite3_step（S）を&lt;/a&gt;使用してリセット）もあった&lt;a href=&quot;reset&quot;&gt;sqlite3_resetを（ S）&lt;/a&gt;。SがNULLポインターの場合、sqlite3_stmt_busy（S）インターフェイスはfalseを返します。SがNULLポインターではなく、有効な&lt;a href=&quot;stmt&quot;&gt;準備済みステートメント&lt;/a&gt;オブジェクトへのポインターでない場合、動作は未定義であり、おそらく望ましくありません。</target>
        </trans-unit>
        <trans-unit id="90793b88a180a777be3c4f2d53caba9bba6af112" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_isexplain(S) interface returns 1 if the prepared statement S is an EXPLAIN statement, or 2 if the statement S is an EXPLAIN QUERY PLAN. The sqlite3_stmt_isexplain(S) interface returns 0 if S is an ordinary statement or a NULL pointer.</source>
          <target state="translated">sqlite3_stmt_isexplain(S)インタフェースは、準備された文SがEXPLAIN文であれば1を返し、文SがEXPLAIN QUERY PLANであれば2を返します。sqlite3_stmt_isexplain(S)インタフェースは、Sが通常の文かNULLポインタであれば0を返します。</target>
        </trans-unit>
        <trans-unit id="959c0941832b79e09f96d36c140b66399c0579af" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_readonly(X) interface returns true (non-zero) if and only if the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; X makes no direct changes to the content of the database file.</source>
          <target state="translated">sqlite3_stmt_readonly（X）インターフェイスは、&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備されたステートメント&lt;/a&gt; Xがデータベースファイルの内容を直接変更しない場合にのみ、true（ゼロ以外）を返します。</target>
        </trans-unit>
        <trans-unit id="ac5964bf97c9886f6e336072767ae1979506a3cb" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_readonly(X) interface returns true (non-zero) if and only if the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; X makes no direct changes to the content of the database file.</source>
          <target state="translated">sqlite3_stmt_readonly（X）インターフェイスは、&lt;a href=&quot;stmt&quot;&gt;準備されたステートメント&lt;/a&gt; Xがデータベースファイルの内容を直接変更しない場合にのみ、true（ゼロ以外）を返します。</target>
        </trans-unit>
        <trans-unit id="46d5fb0793437180a07e66953d44f2fda8b50c88" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is created using &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_strオブジェクトは&lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new（）&lt;/a&gt;を使用して作成されます。</target>
        </trans-unit>
        <trans-unit id="58bd138876e3ab72759402d62d6773f8d1b76c11" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is created using &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_strオブジェクトは&lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new（）&lt;/a&gt;を使用して作成されます。</target>
        </trans-unit>
        <trans-unit id="709d2526ae98679c1dec5db36348e5bd59a7a2cf" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is destroyed and the string it created is returned using the &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish()&lt;/a&gt; interface.</source>
          <target state="translated">sqlite3_strオブジェクトは破棄され、作成された文字列は&lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish（）&lt;/a&gt;インターフェースを使用して返されます。</target>
        </trans-unit>
        <trans-unit id="17671bb4cfc45e29421b502c0583cd6458abaa8b" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is destroyed and the string it created is returned using the &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish()&lt;/a&gt; interface.</source>
          <target state="translated">sqlite3_strオブジェクトは破棄され、作成された文字列は&lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish（）&lt;/a&gt;インターフェースを使用して返されます。</target>
        </trans-unit>
        <trans-unit id="9c1806bb938001e1be73835ffc5a99f71985fc2b" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR and if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="translated">sqlite3_table_column_metadata（X、D、T、C、....）ルーチンは、&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt; XのデータベースDにあるテーブルTの列Cに関する情報を返します。sqlite3_table_column_metadata（）インターフェースはSQLITE_OKを返し、非NULLポインターを指定された列が存在する場合、適切な値を持つ最後の5つの引数。 sqlite3_table_column_metadata（）インターフェースはSQLITE_ERRORを返し、指定された列が存在しない場合に返ります。 sqlite3_table_column_metadata（）のcolumn-nameパラメータがNULLポインタの場合、このルーチンはテーブルの存在を確認し、テーブルが存在する場合はSQLITE_OKを、存在しない場合はSQLITE_ERRORを返します。 sqlite3_table_column_metadata（X、D、T、C、...）への呼び出しのテーブル名パラメーターTがNULLの場合、結果は未定義の動作です。</target>
        </trans-unit>
        <trans-unit id="1a9220a600a9fb3a4c23d26f17dc0f839445989b" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="translated">sqlite3_table_column_metadata（X、D、T、C、....）ルーチンは、&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;XのデータベースDのテーブルTの列Cに関する情報を返します。sqlite3_table_column_metadata（）インターフェイスはSQLITE_OKを返し、NULL以外のポインターを入力します。指定された列が存在する場合は、適切な値を持つ最後の5つの引数。指定された列が存在しない場合、sqlite3_table_column_metadata（）インターフェイスはSQLITE_ERRORを返します。 sqlite3_table_column_metadata（）へのcolumn-nameパラメーターがNULLポインターの場合、このルーチンは単にテーブルの存在をチェックし、テーブルが存在する場合はSQLITE_OKを返し、存在しない場合はSQLITE_ERRORを返します。 sqlite3_table_column_metadata（X、D、T、C、...）の呼び出しでテーブル名パラメーターTがNULLの場合、結果は未定義の動作になります。</target>
        </trans-unit>
        <trans-unit id="14811f3f6309b7a46fb7b07e8c86e4e522dd9f2d" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR and if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="translated">sqlite3_table_column_metadata（X、D、T、C、....）ルーチンは、&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt; XのデータベースDにあるテーブルTの列Cに関する情報を返します。sqlite3_table_column_metadata（）インターフェースはSQLITE_OKを返し、非NULLポインターを指定された列が存在する場合、適切な値を持つ最後の5つの引数。 sqlite3_table_column_metadata（）インターフェースはSQLITE_ERRORを返し、指定された列が存在しない場合に返ります。 sqlite3_table_column_metadata（）のcolumn-nameパラメータがNULLポインタの場合、このルーチンはテーブルの存在を確認し、テーブルが存在する場合はSQLITE_OKを、存在しない場合はSQLITE_ERRORを返します。 sqlite3_table_column_metadata（X、D、T、C、...）への呼び出しのテーブル名パラメーターTがNULLの場合、結果は未定義の動作です。</target>
        </trans-unit>
        <trans-unit id="1c11863e106d03a5d69e9f5e41b5782d50d0ba8d" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="translated">sqlite3_table_column_metadata（X、D、T、C、....）ルーチンは、&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;XのデータベースDのテーブルTの列Cに関する情報を返します。sqlite3_table_column_metadata（）インターフェイスはSQLITE_OKを返し、NULL以外のポインターを入力します。指定された列が存在する場合は、適切な値を持つ最後の5つの引数。指定された列が存在しない場合、sqlite3_table_column_metadata（）インターフェイスはSQLITE_ERRORを返します。 sqlite3_table_column_metadata（）へのcolumn-nameパラメーターがNULLポインターの場合、このルーチンは単にテーブルの存在をチェックし、テーブルが存在する場合はSQLITE_OKを返し、存在しない場合はSQLITE_ERRORを返します。 sqlite3_table_column_metadata（X、D、T、C、...）の呼び出しでテーブル名パラメーターTがNULLの場合、結果は未定義の動作になります。</target>
        </trans-unit>
        <trans-unit id="b6f71c56bc991c72ab07825bab1be2b2926a3b41" translate="yes" xml:space="preserve">
          <source>The sqlite3_test_control() interface is used to read out internal state of SQLite and to inject faults into SQLite for testing purposes. The first parameter is an operation code that determines the number, meaning, and operation of all subsequent parameters.</source>
          <target state="translated">sqlite3_test_control()インターフェイスは、SQLiteの内部状態を読み出し、テスト目的でSQLiteにフォルトを注入するために使用されます。最初のパラメータは操作コードで、それ以降のすべてのパラメータの数、意味、操作を決定します。</target>
        </trans-unit>
        <trans-unit id="5082c0760e0921243970779b3672c52191342376" translate="yes" xml:space="preserve">
          <source>The sqlite3_threadsafe() function returns zero if and only if SQLite was compiled with mutexing code omitted due to the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; compile-time option being set to 0.</source>
          <target state="translated">sqlite3_threadsafe（）関数は、&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt;コンパイル時オプションが0に設定されているためにSQLiteがミューテックスコードを省略してコンパイルされた場合にのみ、ゼロを返します。</target>
        </trans-unit>
        <trans-unit id="a21f6ed50c99e2696e83c890474c76bf238b4d0d" translate="yes" xml:space="preserve">
          <source>The sqlite3_threadsafe() function returns zero if and only if SQLite was compiled with mutexing code omitted due to the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; compile-time option being set to 0.</source>
          <target state="translated">sqlite3_threadsafe（）関数は、&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt;コンパイル時オプションが0に設定されているためにSQLiteがミューテックスコードを省略してコンパイルされた場合にのみ、ゼロを返します。</target>
        </trans-unit>
        <trans-unit id="bda43267162a3774849f8ead3ae62d9dfab76a35" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace() callbacks occur before each statement is executed, not when the statement is compiled.</source>
          <target state="translated">sqlite3_trace()のコールバックは、各ステートメントが実行される前に発生し、ステートメントがコンパイルされたときに発生するのではありません。</target>
        </trans-unit>
        <trans-unit id="1ffc76f2d02a8dff2313298df0260161ca209b9b" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2() interface is intended to replace the legacy interfaces &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_profile()&lt;/a&gt;, both of which are deprecated.</source>
          <target state="translated">sqlite3_trace_v2（）インターフェースは、古いインターフェース&lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace（）&lt;/a&gt;と&lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_profile（）&lt;/a&gt;を置き換えることを目的としています。どちらも非推奨です。</target>
        </trans-unit>
        <trans-unit id="377ad2a0a4bd528d9de5514af64376270faee9cf" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2() interface is intended to replace the legacy interfaces &lt;a href=&quot;profile&quot;&gt;sqlite3_trace()&lt;/a&gt; and &lt;a href=&quot;profile&quot;&gt;sqlite3_profile()&lt;/a&gt;, both of which are deprecated.</source>
          <target state="translated">sqlite3_trace_v2（）インターフェースは、古いインターフェース&lt;a href=&quot;profile&quot;&gt;sqlite3_trace（）&lt;/a&gt;と&lt;a href=&quot;profile&quot;&gt;sqlite3_profile（）&lt;/a&gt;を置き換えることを目的としています。どちらも非推奨です。</target>
        </trans-unit>
        <trans-unit id="423d6e23fa8d1a2ce23d8999f3685bde80941a45" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2(D,M,X,P) interface registers a trace callback function X against &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D, using property mask M and context pointer P. If the X callback is NULL or if the M mask is zero, then tracing is disabled. The M argument should be the bitwise OR-ed combination of zero or more &lt;a href=&quot;#SQLITE_TRACE&quot;&gt;SQLITE_TRACE&lt;/a&gt; constants.</source>
          <target state="translated">sqlite3_trace_v2（D、M、X、P）インターフェイスは、プロパティマスクMとコンテキストポインターPを使用して、&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt; D に対してトレースコールバック関数Xを登録します。XコールバックがNULLの場合、またはMマスクがゼロの場合、トレースは無効になります。 。M引数は、ゼロ以上の&lt;a href=&quot;#SQLITE_TRACE&quot;&gt;SQLITE_TRACE&lt;/a&gt;定数のビット単位のOR結合された組み合わせである必要があります。</target>
        </trans-unit>
        <trans-unit id="c43af05001b13bd414732905f7825bbbb97dce0a" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2(D,M,X,P) interface registers a trace callback function X against &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D, using property mask M and context pointer P. If the X callback is NULL or if the M mask is zero, then tracing is disabled. The M argument should be the bitwise OR-ed combination of zero or more &lt;a href=&quot;c_trace&quot;&gt;SQLITE_TRACE&lt;/a&gt; constants.</source>
          <target state="translated">sqlite3_trace_v2（D、M、X、P）インターフェイスは、プロパティマスクMとコンテキストポインターPを使用して、&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt; D に対してトレースコールバック関数Xを登録します。XコールバックがNULLの場合、またはMマスクがゼロの場合、トレースは無効になります。 。M引数は、ゼロ以上の&lt;a href=&quot;c_trace&quot;&gt;SQLITE_TRACE&lt;/a&gt;定数のビット単位のOR結合された組み合わせである必要があります。</target>
        </trans-unit>
        <trans-unit id="99807c4e04d2f72ca0bf7cd79e0b0ccb8d1cdec6" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook() interface registers a callback function with the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; identified by the first argument to be invoked whenever a row is updated, inserted or deleted in a &lt;a href=&quot;rowidtable&quot;&gt;rowid table&lt;/a&gt;. Any callback set by a previous call to this function for the same database connection is overridden.</source>
          <target state="translated">sqlite3_update_hook（）インターフェースは、&lt;a href=&quot;rowidtable&quot;&gt;ROWIDテーブル&lt;/a&gt;で行が更新、挿入、または削除されるたびに呼び出される最初の引数で識別される&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続に&lt;/a&gt;コールバック関数を登録します。同じデータベース接続に対するこの関数への以前の呼び出しによって設定されたコールバックは上書きされます。</target>
        </trans-unit>
        <trans-unit id="f13c4b8c3d5b462597549f85fa26ca8898f02c2a" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook() interface registers a callback function with the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; identified by the first argument to be invoked whenever a row is updated, inserted or deleted in a &lt;a href=&quot;../rowidtable&quot;&gt;rowid table&lt;/a&gt;. Any callback set by a previous call to this function for the same database connection is overridden.</source>
          <target state="translated">sqlite3_update_hook（）インターフェースは、&lt;a href=&quot;../rowidtable&quot;&gt;ROWIDテーブル&lt;/a&gt;で行が更新、挿入、または削除されるたびに呼び出される最初の引数で識別される&lt;a href=&quot;sqlite3&quot;&gt;データベース接続に&lt;/a&gt;コールバック関数を登録します。同じデータベース接続に対するこの関数への以前の呼び出しによって設定されたコールバックは上書きされます。</target>
        </trans-unit>
        <trans-unit id="299c5d8dbf8312233913ebdfb7abe735c08c4d12" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook(D,C,P) function returns the P argument from the previous call on the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call on D.</source>
          <target state="translated">sqlite3_update_hook（D、C、P）関数は、同じ&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt; Dでの前の呼び出しからのP引数、またはDでの最初の呼び出しではNULLを返します。</target>
        </trans-unit>
        <trans-unit id="b7813b4170b9b916299f8d86a0cb2ffbf096aaa5" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook(D,C,P) function returns the P argument from the previous call on the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call on D.</source>
          <target state="translated">sqlite3_update_hook（D、C、P）関数は、同じ&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt; Dでの前の呼び出しからのP引数、またはDでの最初の呼び出しではNULLを返します。</target>
        </trans-unit>
        <trans-unit id="9e5c2049439d88f4f1e900d8863f9c93f3ca0ab3" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_boolean(F,P,B) routine assumes that P is a boolean parameter and returns true (1) or false (0) according to the value of P. The sqlite3_uri_boolean(F,P,B) routine returns true (1) if the value of query parameter P is one of &quot;yes&quot;, &quot;true&quot;, or &quot;on&quot; in any case or if the value begins with a non-zero number. The sqlite3_uri_boolean(F,P,B) routines returns false (0) if the value of query parameter P is one of &quot;no&quot;, &quot;false&quot;, or &quot;off&quot; in any case or if the value begins with a numeric zero. If P is not a query parameter on F or if the value of P does not match any of the above, then sqlite3_uri_boolean(F,P,B) returns (B!=0).</source>
          <target state="translated">sqlite3_uri_boolean(F,P,B)ルーチンは、Pがブール値のパラメータであると仮定し、Pの値に応じて真(1)または偽(0)を返します。sqlite3_uri_boolean(F,P,B)ルーチンは、問い合わせパラメータPの値が &quot;no&quot;、&quot;false&quot;、&quot;off &quot;のいずれかである場合、または値がゼロから始まる数値である場合、false(0)を返します。PがFのクエリパラメータではない場合、またはPの値が上記のいずれにも一致しない場合、sqlite3_uri_boolean(F,P,B)は(B!=0)を返します。</target>
        </trans-unit>
        <trans-unit id="07d5885fa75b35071ed61bef7a0d72dc8a43c3b7" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_boolean(F,P,B) routine assumes that P is a boolean parameter and returns true (1) or false (0) according to the value of P. The sqlite3_uri_boolean(F,P,B) routine returns true (1) if the value of query parameter P is one of &quot;yes&quot;, &quot;true&quot;, or &quot;on&quot; in any case or if the value begins with a non-zero number. The sqlite3_uri_boolean(F,P,B) routines returns false (0) if the value of query parameter P is one of &quot;no&quot;, &quot;false&quot;, or &quot;off&quot; in any case or if the value begins with a numeric zero. If P is not a query parameter on F or if the value of P is does not match any of the above, then sqlite3_uri_boolean(F,P,B) returns (B!=0).</source>
          <target state="translated">sqlite3_uri_boolean(F,P,B)ルーチンは、Pがブール値のパラメータであると仮定し、Pの値に応じて真(1)または偽(0)を返します。sqlite3_uri_boolean(F,P,B)ルーチンは、問い合わせパラメータPの値が &quot;no&quot;、&quot;false&quot;、&quot;off &quot;のいずれかである場合、または値がゼロから始まる数値である場合、false(0)を返します。PがFのクエリパラメータではない場合、またはPの値が上記のいずれにも一致しない場合、sqlite3_uri_boolean(F,P,B)は(B!=0)を返します。</target>
        </trans-unit>
        <trans-unit id="d8465d3a607ae26cbee19418630adba78c7f16b3" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_int64(F,P,D) routine converts the value of P into a 64-bit signed integer and returns that integer, or D if P does not exist. If the value of P is something other than an integer, then zero is returned.</source>
          <target state="translated">sqlite3_uri_int64(F,P,D)ルーチンはPの値を64ビット符号付き整数に変換し、その整数を返します。Pの値が整数以外の場合、0が返されます。</target>
        </trans-unit>
        <trans-unit id="00f6b921b58342af7827ee6740ce3bd7da1204bf" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_key(F,N) returns a pointer to the name (not the value) of the N-th query parameter for filename F, or a NULL pointer if N is less than zero or greater than the number of query parameters minus 1. The N value is zero-based so N should be 0 to obtain the name of the first query parameter, 1 for the second parameter, and so forth.</source>
          <target state="translated">sqlite3_uri_key(F,N)はファイル名FのN番目の問い合わせパラメータの名前(値ではありません)へのポインタを返します。N の値はゼロベースなので、1 番目のクエリパラメータの名前を取得するには N を 0 にし、2 番目のパラメータの名前を取得するには 1 にしなければなりません。</target>
        </trans-unit>
        <trans-unit id="4924027328fd6dc74b1360ec20381b3f6724812a" translate="yes" xml:space="preserve">
          <source>The sqlite3_user_data() interface returns a copy of the pointer that was the pUserData parameter (the 5th parameter) of the &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">sqlite3_user_data（）インターフェイスは、アプリケーション定義関数を最初に登録した&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;および&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;ルーチンのpUserDataパラメーター（5番目のパラメーター）であったポインターのコピーを返します。</target>
        </trans-unit>
        <trans-unit id="bf548778e52386bbdaeeb7ac3a4e8320cb6164f6" translate="yes" xml:space="preserve">
          <source>The sqlite3_user_data() interface returns a copy of the pointer that was the pUserData parameter (the 5th parameter) of the &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">sqlite3_user_data（）インターフェイスは、アプリケーション定義関数を最初に登録した&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;および&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;ルーチンのpUserDataパラメーター（5番目のパラメーター）であったポインターのコピーを返します。</target>
        </trans-unit>
        <trans-unit id="ea63e7ca04dfc54c7a9a4dfd28964eb4fb6446f1" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_create_function&quot;&gt;アプリケーション定義のSQL関数の&lt;/a&gt;実装にパラメーターとして渡されるsqlite3_valueオブジェクトは保護されています。&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value（）&lt;/a&gt;によって返されるsqlite3_valueオブジェクトは保護されていません。保護されていないsqlite3_valueオブジェクトは、&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value（）&lt;/a&gt;、および&lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup（）&lt;/a&gt;への引数としてのみ使用できます。&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_type（）&lt;/a&gt;インターフェースのファミリーはsqlite3_valueオブジェクト保護を必要とします。</target>
        </trans-unit>
        <trans-unit id="878c26369032034cf1577de94a30701d2b72bfbf" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="translated">&lt;a href=&quot;../appfunc&quot;&gt;アプリケーション定義のSQL関数の&lt;/a&gt;実装にパラメーターとして渡されるsqlite3_valueオブジェクトは保護されます。&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value（）&lt;/a&gt;によって返されるsqlite3_valueオブジェクトは保護されていません。保護されていないsqlite3_valueオブジェクトは、&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value（）&lt;/a&gt;、&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value（）&lt;/a&gt;、および&lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup（）&lt;/a&gt;への引数としてのみ使用できます。インターフェイスの&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_type（）&lt;/a&gt;ファミリには、保護されたsqlite3_valueオブジェクトが必要です。</target>
        </trans-unit>
        <trans-unit id="5d8545cde1bbfc4f37da956f6919362a532aef6b" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="translated">&lt;a href=&quot;appfunc&quot;&gt;アプリケーション定義のSQL関数の&lt;/a&gt;実装にパラメーターとして渡されるsqlite3_valueオブジェクトは保護されます。&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value（）&lt;/a&gt;によって返されるsqlite3_valueオブジェクトは保護されていません。保護されていないsqlite3_valueオブジェクトは、&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value（）&lt;/a&gt;、および&lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup（）&lt;/a&gt;への引数としてのみ使用できます。インターフェイスの&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_type（）&lt;/a&gt;ファミリには、保護されたsqlite3_valueオブジェクトが必要です。</target>
        </trans-unit>
        <trans-unit id="d38041b5ccb2d09a369551e816f131ddba2abad9" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="translated">&lt;a href=&quot;create_function&quot;&gt;アプリケーション定義のSQL関数の&lt;/a&gt;実装にパラメーターとして渡されるsqlite3_valueオブジェクトは保護されています。&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value（）&lt;/a&gt;によって返されるsqlite3_valueオブジェクトは保護されていません。保護されていないsqlite3_valueオブジェクトは、&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value（）&lt;/a&gt;、&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value（）&lt;/a&gt;、および&lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup（）&lt;/a&gt;への引数としてのみ使用できます。&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_type（）&lt;/a&gt;インターフェースのファミリーはsqlite3_valueオブジェクト保護を必要とします。</target>
        </trans-unit>
        <trans-unit id="a0129b60c59e08fad26659c0f3fdb0270cff463d" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_dup(V) interface makes a copy of the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object D and returns a pointer to that copy. The &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; returned is a &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; object even if the input is not. The sqlite3_value_dup(V) interface returns NULL if V is NULL or if a memory allocation fails.</source>
          <target state="translated">sqlite3_value_dup（V）インターフェースは&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;オブジェクトDのコピーを作成し、そのコピーへのポインターを返します。&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;返さは、&lt;a href=&quot;#sqlite3_value&quot;&gt;保護されたsqlite3_value&lt;/a&gt;入力がない場合でも、オブジェクト。sqlite3_value_dup（V）インターフェイスは、VがNULLの場合、またはメモリ割り当てが失敗した場合にNULLを返します。</target>
        </trans-unit>
        <trans-unit id="0aa98b18c314b7d86c75837f6de77eb6d3e0637d" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_dup(V) interface makes a copy of the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object D and returns a pointer to that copy. The &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; returned is a &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; object even if the input is not. The sqlite3_value_dup(V) interface returns NULL if V is NULL or if a memory allocation fails.</source>
          <target state="translated">sqlite3_value_dup（V）インターフェースは&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;オブジェクトDのコピーを作成し、そのコピーへのポインターを返します。&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;返さは、&lt;a href=&quot;value&quot;&gt;保護されたsqlite3_value&lt;/a&gt;入力がない場合でも、オブジェクト。sqlite3_value_dup（V）インターフェイスは、VがNULLの場合、またはメモリ割り当てが失敗した場合にNULLを返します。</target>
        </trans-unit>
        <trans-unit id="e0414ddee749e340e753046c8b57c08bdec5a9dc" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_free(V) interface frees an &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object previously obtained from &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. If V is a NULL pointer then sqlite3_value_free(V) is a harmless no-op.</source>
          <target state="translated">sqlite3_value_free（V）インターフェースは、以前に&lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup（）&lt;/a&gt;から取得した&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;オブジェクトを解放します。VがNULLポインターの場合、sqlite3_value_free（V）は無害な何もしません。</target>
        </trans-unit>
        <trans-unit id="e1cbff52a059b27e36ab50ec612e0a1c2d7433c2" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_free(V) interface frees an &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object previously obtained from &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. If V is a NULL pointer then sqlite3_value_free(V) is a harmless no-op.</source>
          <target state="translated">sqlite3_value_free（V）インターフェースは、以前に&lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup（）&lt;/a&gt;から取得した&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;オブジェクトを解放します。VがNULLポインターの場合、sqlite3_value_free（V）は無害な何もしません。</target>
        </trans-unit>
        <trans-unit id="7d48e35fde2b5031a0a61511df13116d92432d3c" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, and expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="translated">値Xが&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind（）&lt;/a&gt;インターフェイスの1つから発生した場合、sqlite3_value_frombind（X）インターフェイスはゼロ以外を返します。XがSQLリテラル値、またはテーブルの列と式に由来する場合、sqlite3_value_frombind（X）はゼロを返します。</target>
        </trans-unit>
        <trans-unit id="80d4668ad9e2d92c3db76ff20be74213c969d9ff" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, or an expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="translated">値Xが&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind（）&lt;/a&gt;インターフェースの1つから発生した場合、sqlite3_value_frombind（X）インターフェースはゼロ以外を返します。XがSQLリテラル値、テーブル列、または式に由来する場合、sqlite3_value_frombind（X）はゼロを返します。</target>
        </trans-unit>
        <trans-unit id="4099e909bffc50f671788cefdd0e00a496608c5a" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, and expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="translated">値Xが&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind（）&lt;/a&gt;インターフェイスの1つから発生した場合、sqlite3_value_frombind（X）インターフェイスはゼロ以外を返します。XがSQLリテラル値、またはテーブルの列と式に由来する場合、sqlite3_value_frombind（X）はゼロを返します。</target>
        </trans-unit>
        <trans-unit id="d098066d168e6b39abb688284c2a26c07f3bcf76" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, or an expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="translated">値Xが&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind（）&lt;/a&gt;インターフェースの1つから発生した場合、sqlite3_value_frombind（X）インターフェースはゼロ以外を返します。XがSQLリテラル値、テーブル列、または式に由来する場合、sqlite3_value_frombind（X）はゼロを返します。</target>
        </trans-unit>
        <trans-unit id="e4ba714b8f0c8b8a0a85eade6cc85a5f85674f5b" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_numeric_type() interface attempts to apply numeric affinity to the value. This means that an attempt is made to convert the value to an integer or floating point. If such a conversion is possible without loss of information (in other words, if the value is a string that looks like a number) then the conversion is performed. Otherwise no conversion occurs. The &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;datatype&lt;/a&gt; after conversion is returned.</source>
          <target state="translated">sqlite3_value_numeric_type（）インターフェースは、数値に類似性を値に適用しようとします。つまり、値を整数または浮動小数点に変換する試みが行われます。情報を失うことなくそのような変換が可能な場合（つまり、値が数値のように見える文字列である場合）、変換が実行されます。それ以外の場合、変換は行われません。変換後の&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;データ型&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="d57e13a61eeb32fc6ccab4def9ab890b09fb83b8" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_numeric_type() interface attempts to apply numeric affinity to the value. This means that an attempt is made to convert the value to an integer or floating point. If such a conversion is possible without loss of information (in other words, if the value is a string that looks like a number) then the conversion is performed. Otherwise no conversion occurs. The &lt;a href=&quot;c_blob&quot;&gt;datatype&lt;/a&gt; after conversion is returned.</source>
          <target state="translated">sqlite3_value_numeric_type（）インターフェースは、数値に類似性を値に適用しようとします。つまり、値を整数または浮動小数点に変換する試みが行われます。情報を失うことなくそのような変換が可能な場合（つまり、値が数値のように見える文字列である場合）、変換が実行されます。それ以外の場合、変換は行われません。変換後の&lt;a href=&quot;c_blob&quot;&gt;データ型&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="4ec72e1543814b021a25a90d5cb860b5227da9f5" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;#sqlite3_result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="translated">sqlite3_value_subtype（V）関数は、&lt;a href=&quot;#sqlite3_create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;引数Vのサブタイプを返します。サブタイプ情報を使用して、あるSQL関数から別のSQL関数に限られた量のコンテキストを渡すことができます。&lt;a href=&quot;#sqlite3_result_subtype&quot;&gt;sqlite3_result_subtype（）&lt;/a&gt;ルーチンを使用して、SQL関数の戻り値のサブタイプを設定します。</target>
        </trans-unit>
        <trans-unit id="ac784313e8a1c8814ecb1722aed4c17998bb6a84" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="translated">sqlite3_value_subtype（V）関数は、&lt;a href=&quot;../appfunc&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;引数Vのサブタイプを返します。サブタイプ情報を使用して、あるSQL関数から別のSQL関数に限られた量のコンテキストを渡すことができます。&lt;a href=&quot;result_subtype&quot;&gt;sqlite3_result_subtype（）&lt;/a&gt;ルーチンを使用して、SQL関数の戻り値のサブタイプを設定します。</target>
        </trans-unit>
        <trans-unit id="b9482d5c89729cab0c852ef903cf3adcd7fd134d" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;#sqlite3_result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="translated">sqlite3_value_subtype（V）関数は、&lt;a href=&quot;appfunc&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;引数Vのサブタイプを返します。サブタイプ情報を使用して、あるSQL関数から別のSQL関数に限られた量のコンテキストを渡すことができます。&lt;a href=&quot;#sqlite3_result_subtype&quot;&gt;sqlite3_result_subtype（）&lt;/a&gt;ルーチンを使用して、SQL関数の戻り値のサブタイプを設定します。</target>
        </trans-unit>
        <trans-unit id="ff11a55e63d67f21f428483b7880706f081aadf2" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;create_function&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="translated">sqlite3_value_subtype（V）関数は、&lt;a href=&quot;create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;引数Vのサブタイプを返します。サブタイプ情報を使用して、あるSQL関数から別のSQL関数に限られた量のコンテキストを渡すことができます。&lt;a href=&quot;result_subtype&quot;&gt;sqlite3_result_subtype（）&lt;/a&gt;ルーチンを使用して、SQL関数の戻り値のサブタイプを設定します。</target>
        </trans-unit>
        <trans-unit id="b0e636524c92f0e1651fb00be6db5e8d57af0255" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_text16() interface extracts a UTF-16 string in the native byte-order of the host machine. The sqlite3_value_text16be() and sqlite3_value_text16le() interfaces extract UTF-16 strings as big-endian and little-endian respectively.</source>
          <target state="translated">sqlite3_value_text16()インタフェースは、ホストマシンのネイティブバイト順でUTF-16文字列を抽出します。sqlite3_value_text16be()とsqlite3_value_text16le()は、UTF-16文字列をそれぞれビッグエンディアンとリトルエンディアンで抽出します。</target>
        </trans-unit>
        <trans-unit id="abd8dcf49d86f46dedd1a279c57c33b107030fa7" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_type(V) interface returns the &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;datatype code&lt;/a&gt; for the initial datatype of the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object V. The returned value is one of &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULL&lt;/a&gt;. Other interfaces might change the datatype for an sqlite3_value object. For example, if the datatype is initially SQLITE_INTEGER and sqlite3_value_text(V) is called to extract a text value for that integer, then subsequent calls to sqlite3_value_type(V) might return SQLITE_TEXT. Whether or not a persistent internal datatype conversion occurs is undefined and may change from one release of SQLite to the next.</source>
          <target state="translated">sqlite3_value_type（V）インターフェイスは、&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;オブジェクトVの初期データ&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;型のデータ型コード&lt;/a&gt;を返します。戻り値は、&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt;、&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt;、&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt;、&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt;、または&lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULLの&lt;/a&gt;いずれかです。他のインターフェースはsqlite3_valueオブジェクトのデータ型を変更するかもしれません。たとえば、データ型が最初にSQLITE_INTEGERであり、sqlite3_value_text（V）がその整数のテキスト値を抽出するために呼び出された場合、sqlite3_value_type（V）への後続の呼び出しはSQLITE_TEXTを返す可能性があります。永続的な内部データ型変換が発生するかどうかは定義されておらず、SQLiteのリリースごとに変わる可能性があります。</target>
        </trans-unit>
        <trans-unit id="9cdf3c345651dd059fa86a01b992ffdfc67b3546" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_type(V) interface returns the &lt;a href=&quot;c_blob&quot;&gt;datatype code&lt;/a&gt; for the initial datatype of the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object V. The returned value is one of &lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULL&lt;/a&gt;. Other interfaces might change the datatype for an sqlite3_value object. For example, if the datatype is initially SQLITE_INTEGER and sqlite3_value_text(V) is called to extract a text value for that integer, then subsequent calls to sqlite3_value_type(V) might return SQLITE_TEXT. Whether or not a persistent internal datatype conversion occurs is undefined and may change from one release of SQLite to the next.</source>
          <target state="translated">sqlite3_value_type（V）インターフェイスは、&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;オブジェクトVの初期データ&lt;a href=&quot;c_blob&quot;&gt;型のデータ型コード&lt;/a&gt;を返します。戻り値は、&lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt;、&lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt;、&lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt;、&lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt;、または&lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULLの&lt;/a&gt;いずれかです。他のインターフェースはsqlite3_valueオブジェクトのデータ型を変更するかもしれません。たとえば、データ型が最初にSQLITE_INTEGERであり、sqlite3_value_text（V）がその整数のテキスト値を抽出するために呼び出された場合、sqlite3_value_type（V）への後続の呼び出しはSQLITE_TEXTを返す可能性があります。永続的な内部データ型変換が発生するかどうかは定義されておらず、SQLiteのリリースごとに変わる可能性があります。</target>
        </trans-unit>
        <trans-unit id="9fd8993db96d6be0a53b95ff8fe5c5a06191a2c2" translate="yes" xml:space="preserve">
          <source>The sqlite3_version[] string constant contains the text of &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; macro. The sqlite3_libversion() function returns a pointer to the to the sqlite3_version[] string constant. The sqlite3_libversion() function is provided for use in DLLs since DLL users usually do not have direct access to string constants within the DLL. The sqlite3_libversion_number() function returns an integer equal to &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;. The sqlite3_sourceid() function returns a pointer to a string constant whose value is the same as the &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macro. Except if SQLite is built using an edited copy of &lt;a href=&quot;amalgamation&quot;&gt;the amalgamation&lt;/a&gt;, then the last four characters of the hash might be different from &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;.</source>
          <target state="translated">sqlite3_version []文字列定数には、&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt;マクロのテキストが含まれています。 sqlite3_libversion（）関数は、sqlite3_version []文字列定数へのポインターを返します。 DLLユーザーは通常、DLL内の文字列定数に直接アクセスできないため、sqlite3_libversion（）関数はDLLで使用するために提供されています。 sqlite3_libversion_number（）関数は&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBERに&lt;/a&gt;等しい整数を返します。 sqlite3_sourceid（）関数は、&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; Cプリプロセッサマクロと同じ値を持つ文字列定数へのポインタを返します。&lt;a href=&quot;amalgamation&quot;&gt;統合の&lt;/a&gt;編集されたコピーを使用してSQLiteが構築されている場合を除き、ハッシュの最後の4文字は&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;と異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="a807d081504ff9864c4a0f322dee10127ba34ee0" translate="yes" xml:space="preserve">
          <source>The sqlite3_version[] string constant contains the text of &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt; macro. The sqlite3_libversion() function returns a pointer to the to the sqlite3_version[] string constant. The sqlite3_libversion() function is provided for use in DLLs since DLL users usually do not have direct access to string constants within the DLL. The sqlite3_libversion_number() function returns an integer equal to &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;. The sqlite3_sourceid() function returns a pointer to a string constant whose value is the same as the &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macro. Except if SQLite is built using an edited copy of &lt;a href=&quot;../amalgamation&quot;&gt;the amalgamation&lt;/a&gt;, then the last four characters of the hash might be different from &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;.</source>
          <target state="translated">sqlite3_version []文字列定数には、&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt;マクロのテキストが含まれています。 sqlite3_libversion（）関数は、sqlite3_version []文字列定数へのポインターを返します。 DLLユーザーは通常、DLL内の文字列定数に直接アクセスできないため、sqlite3_libversion（）関数はDLLで使用するために提供されています。 sqlite3_libversion_number（）関数は&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBERに&lt;/a&gt;等しい整数を返します。 sqlite3_sourceid（）関数は、&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; Cプリプロセッサマクロと同じ値を持つ文字列定数へのポインタを返します。&lt;a href=&quot;../amalgamation&quot;&gt;統合の&lt;/a&gt;編集されたコピーを使用してSQLiteが構築されている場合を除き、ハッシュの最後の4文字は&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;と異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="b7f0635e95ae6f97edbc2a13b7ebfc89ee7bf9a3" translate="yes" xml:space="preserve">
          <source>The sqlite3_vfs_find() interface returns a pointer to a VFS given its name. Names are case sensitive. Names are zero-terminated UTF-8 strings. If there is no match, a NULL pointer is returned. If zVfsName is NULL then the default VFS is returned.</source>
          <target state="translated">sqlite3_vfs_find()インタフェースは、名前が与えられたVFSへのポインタを返します。名前は大文字小文字を区別します。名前はゼロ終端のUTF-8文字列です。一致するものがない場合は NULL ポインタが返されます。zVfsName が NULL の場合は、 デフォル ト の VFS が返されます。</target>
        </trans-unit>
        <trans-unit id="88892501427d74185f6b1bff1e11e202173ae158" translate="yes" xml:space="preserve">
          <source>The sqlite3_vsnprintf() routine is a varargs version of sqlite3_snprintf().</source>
          <target state="translated">sqlite3_vsnprintf()ルーチンは sqlite3_snprintf()の varargs 版です。</target>
        </trans-unit>
        <trans-unit id="bfe11fb394a04090848d426f27d7f821bd426298" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint(D,X) is equivalent to &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt;(D,X,&lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt;,0,0).</source>
          <target state="translated">sqlite3_wal_checkpoint（D、X）は&lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt;（D、X、&lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt;、0,0）と同等です。</target>
        </trans-unit>
        <trans-unit id="a5b2980a50de42ca24a7d3c803dbeadfa7a488ca" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint(D,X) is equivalent to &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt;(D,X,&lt;a href=&quot;c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt;,0,0).</source>
          <target state="translated">sqlite3_wal_checkpoint（D、X）は&lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt;（D、X、&lt;a href=&quot;c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt;、0,0）と同等です。</target>
        </trans-unit>
        <trans-unit id="7f281b26d80df2d4297decb3bb5684de63641309" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint_v2(D,X,M,L,C) interface runs a checkpoint operation on database X of &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D in mode M. Status information is written back into integers pointed to by L and C. The M parameter must be a valid &lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;checkpoint mode&lt;/a&gt;:</source>
          <target state="translated">sqlite3_wal_checkpoint_v2（D、X、M、L、C）インターフェイスは、モードMの&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt; DのデータベースXでチェックポイント操作を実行します。ステータス情報は、LおよびCが指す整数に書き戻されます。Mパラメータは有効である必要があります&lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;チェックポイントモード&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="4f16d84b1dffbf24b61871d0a39f458136f5ce78" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint_v2(D,X,M,L,C) interface runs a checkpoint operation on database X of &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D in mode M. Status information is written back into integers pointed to by L and C. The M parameter must be a valid &lt;a href=&quot;c_checkpoint_full&quot;&gt;checkpoint mode&lt;/a&gt;:</source>
          <target state="translated">sqlite3_wal_checkpoint_v2（D、X、M、L、C）インターフェイスは、モードMの&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt; DのデータベースXでチェックポイント操作を実行します。ステータス情報は、LおよびCが指す整数に書き戻されます。Mパラメータは有効である必要があります&lt;a href=&quot;c_checkpoint_full&quot;&gt;チェックポイントモード&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="121e4ad510585a0237e3a007626cc2d427159cf6" translate="yes" xml:space="preserve">
          <source>The sqlite3changeset_apply() function automatically converts the zero-length blob back to a NULL value when updating the sqlite_stat1 table. However, if the application calls sqlite3changeset_new(), sqlite3changeset_old() or sqlite3changeset_conflict on a changeset iterator directly (including on a changeset iterator passed to a conflict-handler callback) then the X'' value is returned. The application must translate X'' to NULL itself if required.</source>
          <target state="translated">sqlite3changeset_apply()関数は、sqlite_stat1テーブルを更新する際に、長さ0のブロブを自動的にNULL値に変換します。しかし、アプリケーションが直接(コンフリクトハンドラコールバックに渡されたチェンジセットイテレータを含む)チェンジセットイテレータ上でsqlite3changeset_new()、sqlite3changeset_old()、sqlite3changeset_conflictを呼び出した場合、X''値が返されます。必要であれば、アプリケーションはX''を自身でNULLに変換しなければなりません。</target>
        </trans-unit>
        <trans-unit id="ab7530db4d4c9fc320d8eb6c02294cea75207425" translate="yes" xml:space="preserve">
          <source>The sqlite3rbu_open(T,A,S) function returns a pointer to an &quot;sqlite3rbu&quot; object, which is then passed into the subsequent interfaces.</source>
          <target state="translated">sqlite3rbu_open(T,A,S)関数は &quot;sqlite3rbu &quot;オブジェクトへのポインタを返します。</target>
        </trans-unit>
        <trans-unit id="bcc8971708ade277f3f9ba38012f5db2060092ea" translate="yes" xml:space="preserve">
          <source>The sqlite3session_config() interface is not threadsafe. If it is invoked while any other thread is inside any other sessions method then the results are undefined. Furthermore, if it is invoked after any sessions related objects have been created, the results are also undefined.</source>
          <target state="translated">sqlite3session_config()インタフェースはスレッドセーフではありません。他のスレッドが他のsessionメソッド内にある間に呼び出された場合、結果は未定義です。さらに、セッションに関連するオブジェクトが作成された後に呼び出された場合も、結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="ed3502dd7610ba7f06fbfad0a9a6bcb2eec2c983" translate="yes" xml:space="preserve">
          <source>The sqlite3session_config() interface is used to make global configuration changes to the sessions module in order to tune it to the specific needs of the application.</source>
          <target state="translated">sqlite3session_config()インターフェースは、アプリケーションの特定のニーズに合わせて調整するために、セッションモジュールにグローバルな設定変更を行うために使用されます。</target>
        </trans-unit>
        <trans-unit id="517ed7f5443765d182eb47f3b8b955f48af65e6e" translate="yes" xml:space="preserve">
          <source>The sqlite_compileoption_get() SQL function is a wrapper around the &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get()&lt;/a&gt; C/C++ function. This routine returns the N-th compile-time option used to build SQLite or NULL if N is out of range. See also the &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt;.</source>
          <target state="translated">sqlite_compileoption_get（）SQL関数は、&lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get（）&lt;/a&gt; C / C ++関数のラッパーです。このルーチンは、SQLiteのビルドに使用されるN番目のコンパイル時オプションを返すか、Nが範囲外の場合はNULLを返します。&lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_optionsプラグマ&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="62942f05e5a1956f6b33c8235e025eeea5e49332" translate="yes" xml:space="preserve">
          <source>The sqlite_compileoption_used() SQL function is a wrapper around the &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used()&lt;/a&gt; C/C++ function. When the argument X to sqlite_compileoption_used(X) is a string which is the name of a compile-time option, this routine returns true (1) or false (0) depending on whether or not that option was used during the build.</source>
          <target state="translated">sqlite_compileoption_used（）SQL関数は、&lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used（）&lt;/a&gt; C / C ++関数のラッパーです。sqlite_compileoption_used（X）の引数Xがコンパイル時オプションの名前である文字列である場合、このルーチンは、ビルド中にそのオプションが使用されたかどうかに応じて、true（1）またはfalse（0）を返します。</target>
        </trans-unit>
        <trans-unit id="029c047f81979126902e66d7c2206be9ceebe6ff" translate="yes" xml:space="preserve">
          <source>The sqlite_master table contains one row for each table, index, view, and trigger (collectively &quot;objects&quot;) in the database schema, except there is no entry for the sqlite_master table itself. The sqlite_master table contains entries for &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal schema objects&lt;/a&gt; in addition to application- and programmer-defined objects.</source>
          <target state="translated">sqlite_masterテーブル自体のエントリがない場合を除き、sqlite_masterテーブルには、データベーススキーマのテーブル、インデックス、ビュー、トリガー（まとめて「オブジェクト」）ごとに1つの行が含まれます。sqlite_masterテーブルには、アプリケーション定義およびプログラマー定義のオブジェクトに加えて、&lt;a href=&quot;fileformat2#intschema&quot;&gt;内部スキーマオブジェクトの&lt;/a&gt;エントリが含まれています。</target>
        </trans-unit>
        <trans-unit id="9e701356a8021b4fb9727300fa9f7200eddb250b" translate="yes" xml:space="preserve">
          <source>The sqlite_master.name column will hold the name of the object. &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on tables cause SQLite to create &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; with names of the form &quot;sqlite_autoindex_TABLE_N&quot; where TABLE is replaced by the name of the table that contains the constraint and N is an integer beginning with 1 and increasing by one with each constraint seen in the table definition. In a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, there is no sqlite_master entry for the PRIMARY KEY, but the &quot;sqlite_autoindex_TABLE_N&quot; name is set aside for the PRIMARY KEY as if the sqlite_master entry did exist. This will affect the numbering of subsequent UNIQUE constraints. The &quot;sqlite_autoindex_TABLE_N&quot; name is never allocated for an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, either in rowid tables or WITHOUT ROWID tables.</source>
          <target state="translated">sqlite_master.nameカラムはオブジェクトの名前を保持します。テーブルの&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;および&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;制約により、SQLite は &quot;sqlite_autoindex_TABLE_N&quot;という形式の名前で&lt;a href=&quot;fileformat2#intschema&quot;&gt;内部インデックス&lt;/a&gt;を作成します。ここで、TABLEは制約を含むテーブルの名前に置き換えられ、Nは1で始まり、各制約で1ずつ増える整数です。テーブル定義に表示されます。では&lt;a href=&quot;withoutrowid&quot;&gt;ROWID WITHOUT&lt;/a&gt;テーブル、PRIMARY KEYにはsqlite_masterエントリが存在しませんが、sqlite_masterエントリが存在しなかったかのように「sqlite_autoindex_TABLE_N」名前はPRIMARY KEYのために確保されています。これは、後続のUNIQUE制約の番号付けに影響します。 「sqlite_autoindex_TABLE_N」&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEYに名前が割り当てられることはありません&lt;/a&gt;、ROWID表またはWITHOUT ROWID表のいずれか。</target>
        </trans-unit>
        <trans-unit id="3bae42f70521e9e8cd4db2168d1d1babca7ff5fa" translate="yes" xml:space="preserve">
          <source>The sqlite_master.rootpage column stores the page number of the root b-tree page for tables and indexes. For rows that define views, triggers, and virtual tables, the rootpage column is 0 or NULL.</source>
          <target state="translated">sqlite_master.rootpageカラムは、テーブルとインデックスのルートb-treeページのページ番号を格納します。ビュー、トリガ、仮想テーブルを定義する行の場合、rootpageカラムは0またはNULLです。</target>
        </trans-unit>
        <trans-unit id="ccb922e59255362de7628494ea2946015486eb28" translate="yes" xml:space="preserve">
          <source>The sqlite_master.sql column stores SQL text that describes the object. This SQL text is a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;, or &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement that if evaluated against the database file when it is the main database of a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; would recreate the object. The text is usually a copy of the original statement used to create the object but with normalizations applied so that the text conforms to the following rules:</source>
          <target state="translated">sqlite_master.sql列には、オブジェクトを説明するSQLテキストが格納されます。このSQLテキストは&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;、&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;、&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;、&lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;、または&lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;ステートメントであり、&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続の&lt;/a&gt;メインデータベースであるときにデータベースファイルに対して評価されると、オブジェクトが再作成されます。テキストは通常​​、オブジェクトの作成に使用された元のステートメントのコピーですが、テキストが次の規則に準拠するように正規化が適用されています。</target>
        </trans-unit>
        <trans-unit id="8ef76cce54ac5ead8c9ecfb2e98b71a272278d61" translate="yes" xml:space="preserve">
          <source>The sqlite_master.tbl_name column holds the name of a table or view that the object is associated with. For a table or view, the tbl_name column is a copy of the name column. For an index, the tbl_name is the name of the table that is indexed. For a trigger, the tbl_name column stores the name of the table or view that causes the trigger to fire.</source>
          <target state="translated">sqlite_master.tbl_nameカラムは、オブジェクトが関連付けられているテーブルやビューの名前を保持します。テーブルやビューの場合、tbl_nameカラムはnameカラムのコピーです。インデックスの場合、tbl_nameはインデックス化されたテーブルの名前です。トリガの場合、tbl_name カラムは、トリガを発生させるテーブルまたはビューの名前を格納します。</target>
        </trans-unit>
        <trans-unit id="1161ce8b03e8867e67c57e405c9c72a8e7f39824" translate="yes" xml:space="preserve">
          <source>The sqlite_master.type column will be one of the following text strings: 'table', 'index', 'view', or 'trigger' according to the type of object defined. The 'table' string is used for both ordinary and &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">sqlite_master.typeカラムは、定義されたオブジェクトのタイプに応じて、「テーブル」、「インデックス」、「ビュー」、または「トリガー」のいずれかのテキスト文字列になります。'table'文字列は、通常の&lt;a href=&quot;vtab&quot;&gt;テーブル&lt;/a&gt;と仮想テーブルの両方に使用されます。</target>
        </trans-unit>
        <trans-unit id="8a4ecb6a492d4b0952a80c0d2b263ba43418de02" translate="yes" xml:space="preserve">
          <source>The sqlite_offset(X) SQL function is only available if SQLite is built using the &lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/a&gt; compile-time option.</source>
          <target state="translated">sqlite_offset（X）SQL関数は、SQLiteが&lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/a&gt;コンパイル時オプションを使用してビルドされている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="f36120db3cfab77bf49cfde55bfe4a03928e953b" translate="yes" xml:space="preserve">
          <source>The sqlite_offset(X) function returns the byte offset in the database file for the beginning of the record from which value would be read. If X is not a column in an ordinary table, then sqlite_offset(X) returns NULL. The value returned by sqlite_offset(X) might reference either the original table or an index, depending on the query. If the value X would normally be extracted from an index, the sqlite_offset(X) returns the offset to the corresponding index record. If the value X would be extracted from the original table, then sqlite_offset(X) returns the offset to the table record.</source>
          <target state="translated">sqlite_offset(X)関数は、値が読み込まれるレコードの先頭のデータベースファイル内のバイトオフセットを返します。Xが通常のテーブルのカラムでない場合、sqlite_offset(X)はNULLを返します。sqlite_offset(X)が返す値は、クエリに応じて、元のテーブルかインデックスを参照します。値Xが通常インデックスから抽出される場合、sqlite_offset(X)は対応するインデックスレコードへのオフセットを返します。値Xが元のテーブルから抽出される場合、sqlite_offset(X)はテーブルレコードへのオフセットを返します。</target>
        </trans-unit>
        <trans-unit id="7edde881cc83be6805465c505116db44a7c10317" translate="yes" xml:space="preserve">
          <source>The sqlite_schema table contains one row for each table, index, view, and trigger (collectively &quot;objects&quot;) in the database schema, except there is no entry for the sqlite_schema table itself. The sqlite_schema table contains entries for &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal schema objects&lt;/a&gt; in addition to application- and programmer-defined objects.</source>
          <target state="translated">sqlite_schemaテーブルには、sqlite_schemaテーブル自体のエントリがないことを除いて、データベーススキーマのテーブル、インデックス、ビュー、およびトリガー（総称して「オブジェクト」）ごとに1つの行が含まれます。sqlite_schemaテーブルには、アプリケーション定義オブジェクトとプログラマー定義オブジェクトに加えて、&lt;a href=&quot;fileformat2#intschema&quot;&gt;内部スキーマオブジェクトの&lt;/a&gt;エントリが含まれています。</target>
        </trans-unit>
        <trans-unit id="e02071e2d759314e2fb363a98ec697450c31c3a5" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.name column will hold the name of the object. &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on tables cause SQLite to create &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; with names of the form &quot;sqlite_autoindex_TABLE_N&quot; where TABLE is replaced by the name of the table that contains the constraint and N is an integer beginning with 1 and increasing by one with each constraint seen in the table definition. In a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, there is no sqlite_schema entry for the PRIMARY KEY, but the &quot;sqlite_autoindex_TABLE_N&quot; name is set aside for the PRIMARY KEY as if the sqlite_schema entry did exist. This will affect the numbering of subsequent UNIQUE constraints. The &quot;sqlite_autoindex_TABLE_N&quot; name is never allocated for an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, either in rowid tables or WITHOUT ROWID tables.</source>
          <target state="translated">sqlite_schema.name列は、オブジェクトの名前を保持します。&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;と&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEYの&lt;/a&gt;SQLiteの原因テーブル上の制約が作成し&lt;a href=&quot;fileformat2#intschema&quot;&gt;た内部インデックスを&lt;/a&gt;表の制約が含まれており、Nは整数1から始まり、各制約に1ずつ増加され、テーブルの名前に置き換えられ、フォーム「sqlite_autoindex_TABLE_N」の名前でテーブル定義に表示されます。では&lt;a href=&quot;withoutrowid&quot;&gt;ROWID WITHOUT&lt;/a&gt;テーブル、PRIMARY KEYにはsqlite_schemaエントリが存在しませんが、sqlite_schemaエントリが存在しなかったかのように「sqlite_autoindex_TABLE_N」名前はPRIMARY KEYのために確保されています。これは、後続のUNIQUE制約の番号付けに影響します。 「sqlite_autoindex_TABLE_N」&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARYKEYに名前が割り当てられることはありません&lt;/a&gt;、ROWIDテーブル内またはROWIDテーブルなし。</target>
        </trans-unit>
        <trans-unit id="b54e4469dd50abde5034fd8f801a4d0306037ed0" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.rootpage column stores the page number of the root b-tree page for tables and indexes. For rows that define views, triggers, and virtual tables, the rootpage column is 0 or NULL.</source>
          <target state="translated">sqlite_schema.rootpageカラムは、テーブルとインデックスのルートb-treeページのページ番号を格納します。ビュー、トリガ、仮想テーブルを定義する行の場合、rootpageカラムは0またはNULLです。</target>
        </trans-unit>
        <trans-unit id="ee6bcf89a71c75b0fa182495e5015131f7df248c" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.sql column stores SQL text that describes the object. This SQL text is a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;, or &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement that if evaluated against the database file when it is the main database of a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; would recreate the object. The text is usually a copy of the original statement used to create the object but with normalizations applied so that the text conforms to the following rules:</source>
          <target state="translated">sqlite_schema.sql列には、オブジェクトを説明するSQLテキストが格納されます。このSQLテキストは、&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;、&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;、&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;、&lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;、または&lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;ステートメントであり、&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続の&lt;/a&gt;メインデータベースであるときにデータベースファイルに対して評価すると、オブジェクトが再作成されます。テキストは通常​​、オブジェクトの作成に使用された元のステートメントのコピーですが、テキストが次のルールに準拠するように正規化が適用されています。</target>
        </trans-unit>
        <trans-unit id="d911ebef016f1f15b28a4875cf26c113309d9fa3" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.tbl_name column holds the name of a table or view that the object is associated with. For a table or view, the tbl_name column is a copy of the name column. For an index, the tbl_name is the name of the table that is indexed. For a trigger, the tbl_name column stores the name of the table or view that causes the trigger to fire.</source>
          <target state="translated">sqlite_schema.tbl_nameカラムは、オブジェクトが関連付けられているテーブルやビューの名前を保持します。テーブルやビューの場合、tbl_nameカラムはnameカラムのコピーです。インデックスの場合、tbl_nameはインデックス化されたテーブルの名前です。トリガの場合、tbl_name カラムは、トリガを発生させるテーブルまたはビューの名前を格納します。</target>
        </trans-unit>
        <trans-unit id="02a28099cf1bad8380c62abb7ce56059bbeb63ba" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.type column will be one of the following text strings: 'table', 'index', 'view', or 'trigger' according to the type of object defined. The 'table' string is used for both ordinary and &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">sqlite_schema.type列は、定義されたオブジェクトのタイプに応じて、「テーブル」、「インデックス」、「ビュー」、または「トリガー」のいずれかのテキスト文字列になります。'table'文字列は、通常の&lt;a href=&quot;vtab&quot;&gt;テーブル&lt;/a&gt;と仮想テーブルの両方に使用されます。</target>
        </trans-unit>
        <trans-unit id="4f99e581aad3bfe8af33ed6ae438c6f190e18bdd" translate="yes" xml:space="preserve">
          <source>The sqlite_sequence table is an internal table used to help implement &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;. The sqlite_sequence table is created automatically whenever any ordinary table with an AUTOINCREMENT integer primary key is created. Once created, the sqlite_sequence table exists in the sqlite_master table forever; it cannot be dropped. The schema for the sqlite_sequence table is:</source>
          <target state="translated">sqlite_sequenceテーブルは、&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENTの&lt;/a&gt;実装に役立つ内部テーブルです。sqlite_sequenceテーブルは、AUTOINCREMENT整数の主キーを持つ通常のテーブルが作成されるたびに自動的に作成されます。作成されると、sqlite_sequenceテーブルはsqlite_masterテーブルに永久に存在します。落とすことはできません。sqlite_sequenceテーブルのスキーマは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="45d57d826d6c576b74670b2e5b7c281dbdfadbab" translate="yes" xml:space="preserve">
          <source>The sqlite_sequence table is an internal table used to help implement &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;. The sqlite_sequence table is created automatically whenever any ordinary table with an AUTOINCREMENT integer primary key is created. Once created, the sqlite_sequence table exists in the sqlite_schema table forever; it cannot be dropped. The schema for the sqlite_sequence table is:</source>
          <target state="translated">sqlite_sequenceテーブルは、&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENTの&lt;/a&gt;実装を支援するために使用される内部テーブルです。sqlite_sequenceテーブルは、AUTOINCREMENT整数主キーを持つ通常のテーブルが作成されるたびに自動的に作成されます。作成されると、sqlite_sequenceテーブルはsqlite_schemaテーブルに永久に存在します。ドロップすることはできません。sqlite_sequenceテーブルのスキーマは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="e2336dfb15c81a1bc2e023f4a5ddff1cb80eb4aa" translate="yes" xml:space="preserve">
          <source>The sqlite_source_id() function returns a string that identifies the specific version of the source code that was used to build the SQLite library. The string returned by sqlite_source_id() is the date and time that the source code was checked in followed by the SHA1 hash for that check-in. This function is an SQL wrapper around the &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt; C interface.</source>
          <target state="translated">sqlite_source_id（）関数は、SQLiteライブラリの構築に使用されたソースコードの特定のバージョンを識別する文字列を返します。sqlite_source_id（）によって返される文字列は、ソースコードがチェックインされた日時であり、その後にそのチェックインのSHA1ハッシュが続きます。この関数は、&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid（）&lt;/a&gt; CインターフェイスのSQLラッパーです。</target>
        </trans-unit>
        <trans-unit id="7f3f3c25482d0c81576dfc7ce696a273cc1dcba3" translate="yes" xml:space="preserve">
          <source>The sqlite_stat1 is an internal table created by the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command and used to hold supplemental information about tables and indexes that the query planner can use to help it find better ways of performing queries. Applications can update, delete from, insert into or drop the sqlite_stat1 table, but may not create or alter the sqlite_stat1 table. The schema of the sqlite_stat1 table is as follows:</source>
          <target state="translated">sqlite_stat1は、&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;コマンドによって作成された内部テーブルであり、クエリプランナーがクエリを実行するためのより良い方法を見つけるために使用できるテーブルとインデックスに関する補足情報を保持するために使用されます。アプリケーションは、sqlite_stat1テーブルを更新、削除、挿入、または削除できますが、sqlite_stat1テーブルを作成または変更することはできません。sqlite_stat1テーブルのスキーマは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="eac5f10d8bfa6fc7cd030e9acfc883c862434c99" translate="yes" xml:space="preserve">
          <source>The sqlite_stat2 entries for an index that have sqlite_stat2.sampleno between 0 and 9 inclusive are samples of the left-most key value in the index taken at evenly spaced points along the index. Let C be the number of rows in the index. Then the sampled rows are given by</source>
          <target state="translated">sqlite_stat2.samplenoが0から9の間にあるインデックスのsqlite_stat2項目は、インデックスに沿って等間隔で取得されたインデックスの左端のキー値のサンプルです。Cをインデックスの行数とします。サンプリングされた行は次式で与えられます。</target>
        </trans-unit>
        <trans-unit id="db07f0500ccc51725e75c485f7f2868bee244cc2" translate="yes" xml:space="preserve">
          <source>The sqlite_stat2 is only created and is only used if SQLite is compiled with SQLITE_ENABLE_STAT2 and if the SQLite version number is between 3.6.18 (2009-09-11) and 3.7.8 (2011-09-19). The sqlite_stat2 table is neither read nor written by any version of SQLite before 3.6.18 nor after 3.7.8. The sqlite_stat2 table contains additional information about the distribution of keys within an index. The schema of the sqlite_stat2 table is as follows:</source>
          <target state="translated">sqlite_stat2は、SQLiteがSQLITE_ENABLE_STAT2でコンパイルされ、SQLiteのバージョン番号が3.6.18(2009-09-11)から3.7.8(2011-09-19)の間にある場合にのみ作成され、使用されます。sqlite_stat2テーブルは、3.6.18以前のバージョンのSQLiteでも3.7.8以降のバージョンのSQLiteでも読み書きされません。sqlite_stat2テーブルはインデックス内のキーの分布に関する追加情報を含んでいます。sqlite_stat2テーブルのスキーマは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="5e0f4c3583a4ba1380f140be5cb19d805481ba5e" translate="yes" xml:space="preserve">
          <source>The sqlite_stat2.idx column and the sqlite_stat2.tbl column in each row of the sqlite_stat2 table identify an index described by that row. There are usually 10 rows in the sqlite_stat2 table for each index.</source>
          <target state="translated">sqlite_stat2テーブルの各行のsqlite_stat2.idx列とsqlite_stat2.tbl列は、その行で記述されたインデックスを識別します。各インデックスに対してsqlite_stat2テーブルには通常10行あります。</target>
        </trans-unit>
        <trans-unit id="2f0561169a2bdda1f406d666ccb3f34136d53934" translate="yes" xml:space="preserve">
          <source>The sqlite_stat3 is only used if SQLite is compiled with &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; or &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; and if the SQLite version number is 3.7.9 (2011-11-01) or greater. The sqlite_stat3 table is neither read nor written by any version of SQLite before 3.7.9. If the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is used and the SQLite version number is 3.8.1 (2013-10-17) or greater, then sqlite_stat3 might be read but not written. The sqlite_stat3 table contains additional information about the distribution of keys within an index, information that the query planner can use to devise better and faster query algorithms. The schema of the sqlite_stat3 table is as follows:</source>
          <target state="translated">sqlite_stat3は、SQLiteが&lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt;または&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4で&lt;/a&gt;コンパイルされ、SQLiteのバージョン番号が3.7.9（2011-11-01）以降の場合にのみ使用されます。 sqlite_stat3テーブルは、3.7.9より前のどのバージョンのSQLiteでも読み取りも書き込みもされません。場合&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;コンパイル時のオプションを使用してSQLiteバージョン番号は3.8.1（2013年10月17日）以上であるされ、その後、sqlite_stat3読みますが書き込まれていない可能性があります。 sqlite_stat3テーブルには、インデックス内のキーの分布に関する追加情報が含まれています。この情報は、クエリプランナーがより適切で高速なクエリアルゴリズムを考案するために使用できます。 sqlite_stat3テーブルのスキーマは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="00890c07b6c2c2c2cdb8874e2a1b39eb7801c048" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4 is a generalization of the sqlite_stat3 table. The sqlite_stat3 table provides information about the left-most column of an index whereas the sqlite_stat4 table provides information about all columns of the index.</source>
          <target state="translated">sqlite_stat4はsqlite_stat3テーブルの一般化です。sqlite_stat3テーブルはインデックスの左端の列に関する情報を提供しますが、sqlite_stat4テーブルはインデックスのすべての列に関する情報を提供します。</target>
        </trans-unit>
        <trans-unit id="17be4a34aae6ba200b1b6b315d0554ec130a710a" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4 is only created and is only used if SQLite is compiled with &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; and if the SQLite version number is 3.8.1 (2013-10-17) or greater. The sqlite_stat4 table is neither read nor written by any version of SQLite before 3.8.1. The sqlite_stat4 table contains additional information about the distribution of keys within an index or the distribution of keys in the primary key of a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table. The query planner can sometimes use the additional information in the sqlite_stat4 table to devise better and faster query algorithms. The schema of the sqlite_stat4 table is as follows:</source>
          <target state="translated">sqlite_stat4は、SQLiteが&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;でコンパイルされ、SQLiteのバージョン番号が3.8.1（2013-10-17）以降の場合にのみ作成され、使用されます。 sqlite_stat4テーブルは、3.8.1より前のどのバージョンのSQLiteでも読み取りも書き込みもされません。 sqlite_stat4テーブルには、インデックス内のキーの分散、または&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルの主キーのキーの分散に関する追加情報が含まれています。クエリプランナーは、sqlite_stat4テーブルの追加情報を使用して、より高速で高速なクエリアルゴリズムを考案できる場合があります。 sqlite_stat4テーブルのスキーマは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="dc1ec4b833f86cdac2f0f4646210820d900eb53f" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.idx column holds name of the index that the row describes, or in the case of an sqlite_stat4 entry for a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, the name of the table itself.</source>
          <target state="translated">sqlite_stat4.idx列が行に記載されているインデックスの名前を保持し、又は用sqlite_stat4エントリの場合に&lt;a href=&quot;withoutrowid&quot;&gt;ROWIDのWITHOUT&lt;/a&gt;テーブル、テーブル自体の名前。</target>
        </trans-unit>
        <trans-unit id="1916f53e908a81ccd0bcf17da67632c5df8295de" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.nDLt column holds a list of N integers where the K-th integer is the approximate number of entries in the index that are distinct in the first K columns and where the left-most K columns are collectively less than the left-most K columns of the sample.</source>
          <target state="translated">sqlite_stat4.nDLt列は、K番目の整数が最初のK列で区別され、左端のK列がサンプルの左端のK列よりも集合的に小さいインデックス内のエントリのおおよその数であるN個の整数のリストを保持します。</target>
        </trans-unit>
        <trans-unit id="dc87c0d99b695b0cfc2da2e070670a4e3020def1" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.nEq column holds a list of N integers where the K-th integer is the approximate number of entries in the index whose left-most K columns exactly match the K left-most columns of the sample.</source>
          <target state="translated">sqlite_stat4.nEq列はN個の整数のリストを保持します。ここで、K番目の整数は、左端のK列がサンプルの左端のK列と正確に一致するインデックスのエントリのおおよその数です。</target>
        </trans-unit>
        <trans-unit id="9c81743d3d82af763c76e0a7b4201b09b9bf99f3" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.nLt column holds a list of N integers where the K-th integer is the approximate number of entries in the index whose K left-most columns are collectively less than the K left-most columns of the sample.</source>
          <target state="translated">sqlite_stat4.nLt列はN個の整数のリストを保持します。ここで、K番目の整数は、K個の左端の列がサンプルのK個の左端の列よりも小さいインデックスのエントリのおおよその数です。</target>
        </trans-unit>
        <trans-unit id="d2e1c17126c7777e5bb111d59ea8156e8e7627c8" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.sample column holds a BLOB in the &lt;a href=&quot;fileformat2#record_format&quot;&gt;record format&lt;/a&gt; that encodes the indexed columns followed by the rowid for a rowid table or by the columns of the primary key for a WITHOUT ROWID table. The sqlite_stat4.sample BLOB for the WITHOUT ROWID table itself contains just the columns of the primary key. Let the number of columns encoded by the sqlite_stat4.sample blob be N. For indexes on an ordinary rowid table, N will be one more than the number of columns indexed. For indexes on WITHOUT ROWID tables, N will be the number of columns indexed plus the number of columns in the primary key. For a WITHOUT ROWID table, N will be the number of columns in the primary key.</source>
          <target state="translated">sqlite_stat4.sample列は、インデックス付き列をエンコードした&lt;a href=&quot;fileformat2#record_format&quot;&gt;レコード形式&lt;/a&gt;でBLOBを保持し、その後にROWIDテーブルのROWID、またはWITHOUT ROWIDテーブルの主キーの列が続きます。 WITHOUT ROWIDテーブル自体のsqlite_stat4.sample BLOBには、主キーの列のみが含まれます。 sqlite_stat4.sample blobによってエンコードされた列の数をNとします。通常のROWIDテーブルのインデックスの場合、Nはインデックス付けされた列の数より1つ多くなります。 WITHOUT ROWIDテーブルのインデックスの場合、Nはインデックス付けされた列の数と主キーの列の数の和になります。 WITHOUT ROWIDテーブルの場合、Nは主キーの列の数になります。</target>
        </trans-unit>
        <trans-unit id="d3368a66552678e4208326d2b99cb82cd670c435" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.tbl column holds name of the table that owns the index that the row describes</source>
          <target state="translated">sqlite_stat4.tbl列は、行が記述したインデックスを所有するテーブルの名前を保持します。</target>
        </trans-unit>
        <trans-unit id="b005c74909d1b6008d9a724163e0fb64f6a832fd" translate="yes" xml:space="preserve">
          <source>The sqlite_version() function returns the version string for the SQLite library that is running. This function is an SQL wrapper around the &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion()&lt;/a&gt; C-interface.</source>
          <target state="translated">sqlite_version（）関数は、実行中のSQLiteライブラリのバージョン文字列を返します。この関数は、&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion（）&lt;/a&gt; CインターフェイスのSQLラッパーです。</target>
        </trans-unit>
        <trans-unit id="eeb9bf4120a8b3a5d3dfa457114e73704c247a52" translate="yes" xml:space="preserve">
          <source>The stability of the SQLite database file format and the fact that the file format is cross-platform combine to make SQLite database files an excellent choice as an &lt;a href=&quot;appfileformat&quot;&gt;Application File Format&lt;/a&gt;. The US Library Of Congress acknowledges this by listing SQLite as a &lt;a href=&quot;locrsf&quot;&gt;recommended storage format&lt;/a&gt; for long-term preservation of digital content.</source>
          <target state="translated">SQLiteデータベースファイル形式の安定性とファイル形式がクロスプラットフォームであることにより、SQLiteデータベースファイルは&lt;a href=&quot;appfileformat&quot;&gt;アプリケーションファイル形式&lt;/a&gt;として優れた選択肢になります。米国議会図書館は、SQLite をデジタルコンテンツの長期保存用の&lt;a href=&quot;locrsf&quot;&gt;推奨ストレージフォーマット&lt;/a&gt;としてリストすることでこれを認めています。</target>
        </trans-unit>
        <trans-unit id="edcbc0ddf3b476ae82b56edb901d58f590378e61" translate="yes" xml:space="preserve">
          <source>The standard SQLite source tree contains built-in VFSes for unix and windows. Alternative VFSes can be added at start-time or run-time using the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface.</source>
          <target state="translated">標準SQLiteソースツリーには、UNIXおよびWindows用の組み込みVFSが含まれています。&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;インターフェイスを使用して、起動時または実行時に代替VFSを追加できます。</target>
        </trans-unit>
        <trans-unit id="3afa9cfa18cab2a00e2e2667b20527102ceccaa0" translate="yes" xml:space="preserve">
          <source>The state of the computer when a database connection is first opened is shown conceptually by the diagram at the right. The area of the diagram on the extreme right (labeled &quot;Disk&quot;) represents information stored on the mass storage device. Each rectangle is a sector. The blue color represents that the sectors contain original data. The middle area is the operating systems disk cache. At the onset of our example, the cache is cold and this is represented by leaving the rectangles of the disk cache empty. The left area of the diagram shows the content of memory for the process that is using SQLite. The database connection has just been opened and no information has been read yet, so the user space is empty.</source>
          <target state="translated">データベース接続が最初に開かれたときのコンピュータの状態を概念的に示すのが右図である。図の右端の領域(「ディスク」と表示されている)は、大容量記憶装置に格納されている情報を表しています。各矩形はセクタを表しています。青色は、セクタに元のデータが含まれていることを表しています。真ん中の領域はオペレーティングシステムのディスクキャッシュです。この例の開始時には、キャッシュは冷たくなっており、これはディスクキャッシュの長方形を空にすることで表現されています。図の左側の領域は、SQLiteを使用しているプロセスのメモリの内容を示しています。データベース接続がオープンされたばかりで、まだ情報が読み込まれていないので、ユーザースペースは空です。</target>
        </trans-unit>
        <trans-unit id="c2357c705a667a06ce3b401fc40060cc2044167c" translate="yes" xml:space="preserve">
          <source>The statement above creates a new geopoly table named &quot;newtab&quot;. Every geopoly table contains a built-in integer &quot;rowid&quot; column and a &quot;_shape&quot; column that contains the polygon associated with that row of the table. The example above also defines three auxiliary data columns named &quot;a&quot;, &quot;b&quot;, and &quot;c&quot; that can store whatever additional information the application needs to associate with each polygon. If there is no need to store auxiliary information, the list of auxiliary columns can be omitted.</source>
          <target state="translated">上記のステートメントは、&quot;newtab &quot;という名前の新しいジオポリテーブルを作成します。すべてのジオポリ・テーブルは、テーブルのその行に関連付けられたポリゴンを含むビルトイン整数の &quot;rowid &quot;カラムと&quot;_shape &quot;カラムを含んでいます。上の例では、&quot;a&quot;,&quot;b&quot;,&quot;c &quot;という名前の3つの補助データ列も定義しています。補助情報を格納する必要がない場合は、補助列のリストを省略することができます。</target>
        </trans-unit>
        <trans-unit id="5ab1aefcd821f7c6a31149043d5432c19acbdf4f" translate="yes" xml:space="preserve">
          <source>The statement above may appear syntactically incorrect to some. Refer to the section describing the &lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;simple fts queries&lt;/a&gt; for an explanation.</source>
          <target state="translated">上記の文は、一部の人にとって構文的に正しくないように見えるかもしれません。説明については、&lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;単純なftsクエリ&lt;/a&gt;を説明するセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="ecd0da773db50485ad79c3fe0dd58ba001f98f02" translate="yes" xml:space="preserve">
          <source>The statement journal is given a randomized name, not necessarily in the same directory as the main database, and is automatically deleted at the conclusion of the transaction. The size of the statement journal is proportional to the size of the change implemented by the UPDATE or INSERT statement that caused the statement journal to be created.</source>
          <target state="translated">ステートメント・ジャーナルにはランダムな名前が付けられ、必ずしもメイン・データベースと同じディレクトリにあるとは限らず、トランザクションの終了時に自動的に削除されます。ステートメント・ジャーナルのサイズは、ステートメント・ジャーナルを作成する原因となったUPDATE文またはINSERT文によって実装された変更のサイズに比例します。</target>
        </trans-unit>
        <trans-unit id="abce2a89006a756ad8f25f400ff4bbb7de7fef61" translate="yes" xml:space="preserve">
          <source>The status method is basically a wrapper on the &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; C-language interface.</source>
          <target state="translated">statusメソッドは基本的に&lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status（）&lt;/a&gt; C言語インターフェースのラッパーです。</target>
        </trans-unit>
        <trans-unit id="2957b92cef7bca913b9349499bded01bd701447b" translate="yes" xml:space="preserve">
          <source>The strategy is to compile a single SQL statement using &lt;b&gt;sqlite_compile&lt;/b&gt; then invoke &lt;b&gt;sqlite_step&lt;/b&gt; multiple times, once for each row of output, and finally call &lt;b&gt;sqlite_finalize&lt;/b&gt; to clean up after the SQL has finished execution.</source>
          <target state="translated">戦略は、&lt;b&gt;sqlite_compile&lt;/b&gt;を使用して単一のSQLステートメントをコンパイルしてから、&lt;b&gt;sqlite_stepを&lt;/b&gt;複数回（出力の行ごとに1回）呼び出し、最後に&lt;b&gt;sqlite_finalize&lt;/b&gt;を呼び出して、SQLの実行が終了した後にクリーンアップします。</target>
        </trans-unit>
        <trans-unit id="7809402bc982c32307d88a8090b6d47f604ca513" translate="yes" xml:space="preserve">
          <source>The string value P4 of length P1 (bytes) is stored in register P2.</source>
          <target state="translated">レジスタP2には、長さP1(バイト)の文字列値P4が格納されている。</target>
        </trans-unit>
        <trans-unit id="9a7f87028156aaa8a8bf754d55b553e046a12fec" translate="yes" xml:space="preserve">
          <source>The string value returned by this routine is owned and managed by the database connection. The value will be valid until the database N is &lt;a href=&quot;../lang_detach&quot;&gt;DETACH&lt;/a&gt;-ed or until the database connection closes.</source>
          <target state="translated">このルーチンによって返される文字列値は、データベース接続によって所有および管理されます。この値は、データベースNが&lt;a href=&quot;../lang_detach&quot;&gt;DETACHさ&lt;/a&gt;れるまで、またはデータベース接続が閉じるまで有効です。</target>
        </trans-unit>
        <trans-unit id="cb38b0feb448edc668a127b1d9c6a6f2f876060a" translate="yes" xml:space="preserve">
          <source>The string value returned by this routine is owned and managed by the database connection. The value will be valid until the database N is &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt;-ed or until the database connection closes.</source>
          <target state="translated">このルーチンによって返される文字列値は、データベース接続によって所有および管理されます。この値は、データベースNが&lt;a href=&quot;lang_detach&quot;&gt;DETACHさ&lt;/a&gt;れるまで、またはデータベース接続が閉じるまで有効です。</target>
        </trans-unit>
        <trans-unit id="995f4878031e82187c641f145afc9d059e07a6dd" translate="yes" xml:space="preserve">
          <source>The strings returned by sqlite3_sql(P) and sqlite3_normalized_sql(P) are managed by SQLite and are automatically freed when the prepared statement is finalized. The string returned by sqlite3_expanded_sql(P), on the other hand, is obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and must be free by the application by passing it to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_sql（P）とsqlite3_normalized_sql（P）によって返される文字列はSQLiteによって管理され、準備されたステートメントが終了すると自動的に解放されます。sqlite3_expanded_sql（P）によって返される文字列は、一方から得られる&lt;a href=&quot;#sqlite3_free&quot;&gt;（sqlite3_malloc）&lt;/a&gt;とに渡すことにより、アプリケーションによって自由でなければならない&lt;a href=&quot;#sqlite3_free&quot;&gt;）sqlite3_free（ &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6988de3a51ce0d23769efda8a1dd27ed60344374" translate="yes" xml:space="preserve">
          <source>The strings returned by sqlite3_sql(P) and sqlite3_normalized_sql(P) are managed by SQLite and are automatically freed when the prepared statement is finalized. The string returned by sqlite3_expanded_sql(P), on the other hand, is obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and must be free by the application by passing it to &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_sql（P）とsqlite3_normalized_sql（P）によって返される文字列はSQLiteによって管理され、準備されたステートメントが終了すると自動的に解放されます。sqlite3_expanded_sql（P）によって返される文字列は、一方から得られる&lt;a href=&quot;free&quot;&gt;（sqlite3_malloc）&lt;/a&gt;とに渡すことにより、アプリケーションによって自由でなければならない&lt;a href=&quot;free&quot;&gt;）sqlite3_free（ &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3deeab5872c796defa91ce886ebd57387fbb18a8" translate="yes" xml:space="preserve">
          <source>The subquery and outer query do not both use LIMIT.</source>
          <target state="translated">副問い合わせと外部問い合わせの両方でLIMITを使用していません。</target>
        </trans-unit>
        <trans-unit id="77e0e5365d2489d6a42fa705340d96f457af3864" translate="yes" xml:space="preserve">
          <source>The subquery and the outer query do not both have ORDER BY clauses.</source>
          <target state="translated">副問い合わせと外部問い合わせの両方にORDER BY句がありません。</target>
        </trans-unit>
        <trans-unit id="c18b6359aac0e334ed733af3b59f97a0357158e6" translate="yes" xml:space="preserve">
          <source>The subquery does not use LIMIT or the outer query does not use aggregates.</source>
          <target state="translated">副問い合わせがLIMITを使用しないか、外部問い合わせが集約を使用しない。</target>
        </trans-unit>
        <trans-unit id="b5bd1b6abc2be3885b869265a72b70231dcb2d09" translate="yes" xml:space="preserve">
          <source>The subquery does not use LIMIT or the outer query is not a join.</source>
          <target state="translated">副問い合わせがLIMITを使用していないか、外側の問い合わせが結合ではありません。</target>
        </trans-unit>
        <trans-unit id="9a0c8ea79566123f0e4ecc1c9a70135357fff910" translate="yes" xml:space="preserve">
          <source>The subquery does not use OFFSET.</source>
          <target state="translated">副問い合わせはOFFSETを使用しません。</target>
        </trans-unit>
        <trans-unit id="8e09a48cd0d988ee9dac8cadad6cdbfcea3b74f2" translate="yes" xml:space="preserve">
          <source>The subquery has a FROM clause.</source>
          <target state="translated">副問い合わせにはFROM句があります。</target>
        </trans-unit>
        <trans-unit id="36f95cae80ab7a78b4e298e8fc4b136f62be389f" translate="yes" xml:space="preserve">
          <source>The subquery in the FROM clause computes the amount by which the inventory should be reduced for each itemId. That subquery is joined against the inventory table and the quantity of each affected inventory row is reduced by the appropriate amount.</source>
          <target state="translated">FROM句の副問い合わせは、各itemIdについてインベントリを削減すべき量を計算します。その副問い合わせはインベントリ・テーブルに対して結合され、影響を受ける各インベントリ行の量は適切な量だけ削減されます。</target>
        </trans-unit>
        <trans-unit id="14960c81162a6f569b4caa226a699f43010d4c7e" translate="yes" xml:space="preserve">
          <source>The subquery is not DISTINCT.</source>
          <target state="translated">副問い合わせはDISTINCTではありません。</target>
        </trans-unit>
        <trans-unit id="560b14fd5f0c196e23d6c05b79eac72d5d601e25" translate="yes" xml:space="preserve">
          <source>The subquery may not be a recursive CTE.</source>
          <target state="translated">副問い合わせは再帰的なCTEではないかもしれません。</target>
        </trans-unit>
        <trans-unit id="7577bd701d8770ad9fc4050124549876822aa978" translate="yes" xml:space="preserve">
          <source>The substitute character (unicode codepoint 26).</source>
          <target state="translated">置換文字(ユニコードコードコードポイント26)。</target>
        </trans-unit>
        <trans-unit id="1b25cfaa2f051cde5a374dd5fbd3d25bcae8f82b" translate="yes" xml:space="preserve">
          <source>The substr() function in the SQL view above returns the text of the rbu_control argument with the first character (the one corresponding to column &quot;i&quot;, which is not required by the FTS table) removed.</source>
          <target state="translated">上の SQL ビューの substr()関数は、最初の文字 (FTS テーブルでは不要なカラム &quot;i&quot; に対応するもの)を削除した rbu_control 引数のテキストを返します。</target>
        </trans-unit>
        <trans-unit id="1eb749257ff54f4f9f61b55605ad1eef34135ccf" translate="yes" xml:space="preserve">
          <source>The substr(X,Y,Z) function returns a substring of input string X that begins with the Y-th character and which is Z characters long. If Z is omitted then substr(X,Y) returns all characters through the end of the string X beginning with the Y-th. The left-most character of X is number 1. If Y is negative then the first character of the substring is found by counting from the right rather than the left. If Z is negative then the abs(Z) characters preceding the Y-th character are returned. If X is a string then characters indices refer to actual UTF-8 characters. If X is a BLOB then the indices refer to bytes.</source>
          <target state="translated">substr(X,Y,Z)関数は、入力文字列 X の Y 番目の文字から始まり、Z 文字の長さの部分文字列を返します。Z が省略された場合、 substr(X,Y)は Y 番目の文字から始まる文字列 X の末尾までのすべての文字を返します。X の左端の文字は番号 1 です。Yが負の場合、部分文字列の最初の文字は左からではなく右から数えて見つけます。Zが負の場合、Y番目の文字の前にあるabs(Z)文字が返される。Xが文字列の場合、文字インデックスは実際のUTF-8文字を参照します。XがBLOBの場合、インデックスはバイトを参照する。</target>
        </trans-unit>
        <trans-unit id="8f8f72577e48839e2c6e724a5bcfafdf7566b512" translate="yes" xml:space="preserve">
          <source>The sum of all &quot;four&quot; values. This is used to compute &quot;avg(four)&quot;.</source>
          <target state="translated">すべての &quot;4つ &quot;の値の合計。これは &quot;avg(four)&quot;を計算するために使用されます。</target>
        </trans-unit>
        <trans-unit id="4a5f1cfa6e3d0c304a8016c9b0a8f3f6f7afd998" translate="yes" xml:space="preserve">
          <source>The sum() and total() aggregate functions return sum of all non-NULL values in the group. If there are no non-NULL input rows then sum() returns NULL but total() returns 0.0. NULL is not normally a helpful result for the sum of no rows but the SQL standard requires it and most other SQL database engines implement sum() that way so SQLite does it in the same way in order to be compatible. The non-standard total() function is provided as a convenient way to work around this design problem in the SQL language.</source>
          <target state="translated">sum()および total()集約関数は、グループ内のすべての非NULL値の合計を返します。NULL 以外の入力行がない場合は sum()は NULL を返しますが、 total()は 0.0 を返します。NULL は通常、行が存在しない場合の合計の結果としては役に立ちませんが、 SQL 標準ではこれを要求しており、他のほとんどの SQL データベースエンジンでは sum()をこのように実装しているので、互換性を保つために SQLite でも同じように実装しています。標準ではない total()関数は、この設計上の問題を SQL 言語で回避する便利な方法として提供されています。</target>
        </trans-unit>
        <trans-unit id="c8cc59294c9d81aba99fd5de24fb6dc6b41b0132" translate="yes" xml:space="preserve">
          <source>The super-journal file is only created for &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; operations that involve multiple database files where at least two of the databases meet all of the following requirements:</source>
          <target state="translated">スーパージャーナルファイルは、少なくとも2つのデータベースが次の要件をすべて満たす複数のデータベースファイルを含む&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;操作用にのみ作成されます。</target>
        </trans-unit>
        <trans-unit id="8ee67fa1e83c36dfa202c1d70aacf19927252737" translate="yes" xml:space="preserve">
          <source>The super-journal file is used as part of the atomic commit process when a single transaction makes changes to multiple databases that have been added to a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. The super-journal file is always located in the same directory as the main database file (the main database file is the database that is identified in the original &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; call that created the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;) with a randomized suffix. The super-journal file contains the names of all of the various attached auxiliary databases that were changed during the transaction. The multi-database transaction commits when the super-journal file is deleted. See the documentation titled &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit In SQLite&lt;/a&gt; for additional detail.</source>
          <target state="translated">スーパージャーナルファイルは、&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;ステートメント&lt;a href=&quot;c3ref/sqlite3&quot;&gt;を&lt;/a&gt;使用して単一のデータベース接続に追加された複数のデータベースに単一のトランザクションが変更を加えるときに、アトミックコミットプロセスの一部として使用されます。スーパージャーナルファイルは、常にメインデータベースファイルと同じディレクトリにあります（メインデータベースファイルは、&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;を作成した元の&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;、&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt;、または&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;呼び出しで識別されるデータベースです。）ランダム化されたサフィックス付き。スーパージャーナルファイルには、トランザクション中に変更された、接続されているさまざまな補助データベースすべての名前が含まれています。マルチデータベーストランザクションは、スーパージャーナルファイルが削除されるとコミットされます。詳細については、「&lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit InSQLite&lt;/a&gt;」というタイトルのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="b11b2e43da7a9faed114feb7f008a51dec0a5a77" translate="yes" xml:space="preserve">
          <source>The suppression of redundant columns in the key suffix of an index entry only occurs in WITHOUT ROWID tables. In an ordinary rowid table, the index entry always ends with the rowid even if the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column is one of the columns being indexed.</source>
          <target state="translated">インデックスエントリのキーサフィックスの冗長列の抑制は、WITHOUT ROWIDテーブルでのみ発生します。通常のROWIDテーブルでは、&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列が索引付けされている列の1つであっても、索引エントリは常にROWIDで終わります。</target>
        </trans-unit>
        <trans-unit id="2572ed867faedb74714d50c5898bcb75f0754e78" translate="yes" xml:space="preserve">
          <source>The swarmvtab implementation may open or close databases at any point. By default, it attempts to limit the maximum number of simultaneously open database files to nine. This is not a hard limit - it is possible to construct a scenario that will cause swarmvtab to exceed it.</source>
          <target state="translated">swarmvtab の実装は、いつでもデータベースを開いたり閉じたりすることができます。デフォルトでは、同時に開くデータベースファイルの最大数を9個に制限しようとします。これは難しい制限ではありません-swarmvtabがこの制限を超えるようなシナリオを構築することが可能です。</target>
        </trans-unit>
        <trans-unit id="9f9e99aa51f888cdf6630598d938ef39ae15f9a3" translate="yes" xml:space="preserve">
          <source>The sync operations that SQLite performs to help ensure integrity can be disabled at run-time using the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;synchronous pragma&lt;/a&gt;. By setting PRAGMA synchronous=OFF, all sync operations are omitted. This makes SQLite seem to run faster, but it also allows the operating system to freely reorder writes, which could result in database corruption if a power failure or hard reset occurs prior to all content reaching persistent storage.</source>
          <target state="translated">SQLiteが&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;同期プラグマ&lt;/a&gt;を使用して実行時に整合性を無効にできるようにするために実行する同期操作。 PRAGMA Synchronization = OFFを設定すると、すべての同期操作が省略されます。これにより、SQLiteはより高速に実行されているように見えますが、オペレーティングシステムが書き込みを自由に並べ替えることもできるため、すべてのコンテンツが永続ストレージに到達する前に電源障害またはハードリセットが発生すると、データベースが破損する可能性があります。</target>
        </trans-unit>
        <trans-unit id="8ed0f1cf6ef82d0d97320ed63cceee25b526aa88" translate="yes" xml:space="preserve">
          <source>The synchronous version of SQLite is the slowest of the group in this test, but the asynchronous version is the fastest. The difference is the extra time needed to execute fsync().</source>
          <target state="translated">SQLite の同期版はこのテストではグループの中で最も遅くなりましたが、非同期版が最も速くなりました。違いは fsync()の実行に必要な余分な時間です。</target>
        </trans-unit>
        <trans-unit id="88535ccaca4588c188d3dec59b74e5b6c648c437" translate="yes" xml:space="preserve">
          <source>The syntax for a window function is like this:</source>
          <target state="translated">ウィンドウ関数の構文は次のようになります。</target>
        </trans-unit>
        <trans-unit id="e97f2e6030323368e9626fb51e9e8ff6dc7c7f0a" translate="yes" xml:space="preserve">
          <source>The syntax for integer and floating point literals (collectively &quot;numeric literals&quot;) is shown by the following diagram:</source>
          <target state="translated">整数リテラルと浮動小数点リテラル(総称して「数値リテラル」)の構文を次の図に示します。</target>
        </trans-unit>
        <trans-unit id="c1140f24a0825da092ba683013464dc50c75b952" translate="yes" xml:space="preserve">
          <source>The syntax for row values and the circumstances in which row values can be used are illustrated in examples below.</source>
          <target state="translated">行値の構文と、行値が使用できる状況を以下に例示します。</target>
        </trans-unit>
        <trans-unit id="0601104dedcf396efbb0c30203a6d31fd40a4a67" translate="yes" xml:space="preserve">
          <source>The syntax for the ON CONFLICT clause is as shown above for the CREATE TABLE command. For the INSERT and UPDATE commands, the keywords &quot;ON CONFLICT&quot; are replaced by &quot;OR&quot; so that the syntax reads more naturally. For example, instead of &quot;INSERT ON CONFLICT IGNORE&quot; we have &quot;INSERT OR IGNORE&quot;. The keywords change but the meaning of the clause is the same either way.</source>
          <target state="translated">ON CONFLICT句の構文は、CREATE TABLEコマンドの上記のようになります。INSERTとUPDATEコマンドでは、構文がより自然に読めるように、キーワード &quot;ON CONFLICT &quot;は &quot;OR &quot;に置き換えられています。例えば、&quot;INSERT ON CONFLICT IGNORE &quot;の代わりに &quot;INSERT OR IGNORE &quot;となります。キーワードは変わりますが、句の意味はどちらにしても同じです。</target>
        </trans-unit>
        <trans-unit id="f067d61a53dcb338fdf63bf3df528ef6a0487e73" translate="yes" xml:space="preserve">
          <source>The syntax looks like this:</source>
          <target state="translated">構文は次のようになります。</target>
        </trans-unit>
        <trans-unit id="a61a22c417283e11aa14f2ba9ecd8cd0c90ce62d" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;, &lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt;, &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt;, &lt;a href=&quot;lang_droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt;, &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;, &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; and many other commands all permit the user to specify a database object either by its name alone, or by a combination of its name and the name of its database. If no database is specified as part of the object reference, then SQLite searches the main, temp and all attached databases for an object with a matching name. The temp database is searched first, followed by the main database, followed all attached databases in the order that they were attached. The reference resolves to the first match found. For example:</source>
          <target state="translated">構文&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;、&lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt;、&lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt;、&lt;a href=&quot;lang_droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt;、&lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;、&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;および他の多くのコマンドは、すべて一人で、その名前によって、またはその名の組み合わせとの名前のいずれかによって、データベース・オブジェクトを指定することを許可しますそのデータベース。オブジェクト参照の一部としてデータベースが指定されていない場合、SQLiteはメイン、一時、および接続されているすべてのデータベースで、一致する名前のオブジェクトを検索します。 tempデータベースが最初に検索され、次にメインデータベース、次に接続されているすべてのデータベースが接続された順に検索されます。参照は、最初に見つかった一致に解決されます。例えば：</target>
        </trans-unit>
        <trans-unit id="070a4a12a4cd8479f973f088343e30dee884b914" translate="yes" xml:space="preserve">
          <source>The syntax that occurs in between the &quot;ON CONFLICT&quot; and &quot;DO&quot; keywords is called the &quot;conflict target&quot;. The conflict target specifies a specific uniqueness constraint that will trigger the upsert. The conflict target is required for DO UPDATE upserts, but is optional for DO NOTHING. When the conflict target is omitted, the upsert behavior is triggered by a violation of any uniqueness constraint on the table of the INSERT.</source>
          <target state="translated">ON CONFLICT」と「DO」キーワードの間に発生する構文は、「コンフリクトターゲット」と呼ばれます。競合ターゲットは、アップサートをトリガする特定の一意性制約を指定します。競合ターゲットは、DO UPDATEアップサートでは必須ですが、DO NOTHINGではオプションです。コンフリクト・ターゲットが省略されている場合、アップサート動作は、INSERTのテーブル上の任意の一意性制約の違反によってトリガされます。</target>
        </trans-unit>
        <trans-unit id="6578fb33b7ba1ef0fa58c80688a069c9340aa258" translate="yes" xml:space="preserve">
          <source>The szOsFile field is the size in bytes of the structure that defines an open file: the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object. This object will be described more fully below. The point here is that each VFS implementation can define its own &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object containing whatever information the VFS implementation needs to store about an open file. SQLite needs to know how big this object is, however, in order to preallocate enough space to hold it.</source>
          <target state="translated">szOsFileフィールドは、開いているファイルを定義する構造体（&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;オブジェクト）のバイト単位のサイズです。このオブジェクトについては、後で詳しく説明します。ここでのポイントは、各VFS実装が、VFS実装が開いているファイルについて格納する必要がある情報を含む独自の&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;オブジェクトを定義できることです。SQLiteは、オブジェクトを保持するのに十分なスペースを事前に割り当てるために、このオブジェクトの大きさを知る必要があります。</target>
        </trans-unit>
        <trans-unit id="4160b3968588675d955230ce2bf92a9066be0932" translate="yes" xml:space="preserve">
          <source>The szOsFile field is the size of the subclassed &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; structure used by this VFS. mxPathname is the maximum length of a pathname in this VFS.</source>
          <target state="translated">szOsFileフィールドは、このVFSによって使用されるサブクラス化された&lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt;構造のサイズです。mxPathnameは、このVFS内のパス名の最大長です。</target>
        </trans-unit>
        <trans-unit id="0c08ad2486a604361da59adedd8095e01f05af8a" translate="yes" xml:space="preserve">
          <source>The szOsFile field is the size of the subclassed &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; structure used by this VFS. mxPathname is the maximum length of a pathname in this VFS.</source>
          <target state="translated">szOsFileフィールドは、このVFSによって使用されるサブクラス化された&lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt;構造のサイズです。mxPathnameは、このVFS内のパス名の最大長です。</target>
        </trans-unit>
        <trans-unit id="34b2e05f8be89f8919f89034a92c2255013098b0" translate="yes" xml:space="preserve">
          <source>The t2 table is completely unused in the query above, and so the query planner is able to implement the query as if it were written:</source>
          <target state="translated">上記のクエリではt2テーブルは全く使用されていないので、クエリプランナはクエリが書かれているかのように実装することができます。</target>
        </trans-unit>
        <trans-unit id="4238f21507c2ee050a84b88e1b8452b278b7cbd3" translate="yes" xml:space="preserve">
          <source>The table &quot;t1&quot; has four columns &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, and &quot;d&quot; that have no particular datatype assigned. You can store anything you want in any of those columns.</source>
          <target state="translated">テーブル &quot;t1 &quot;には、特定のデータ型が割り当てられていない4つの列 &quot;a&quot;、&quot;b&quot;、&quot;c&quot;、および &quot;d &quot;がある。これらの列のいずれにも、好きなものを格納することができます。</target>
        </trans-unit>
        <trans-unit id="69666453d6f0a7ffe136a772a15ed97e78f29762" translate="yes" xml:space="preserve">
          <source>The table being clear is in the main database file if P2==0. If P2==1 then the table to be clear is in the auxiliary database file that is used to store tables create using CREATE TEMPORARY TABLE.</source>
          <target state="translated">P2==0の場合、クリアされるテーブルはメインデータベースファイルにあります。 P2==1の場合、クリアされるテーブルはCREATE TEMPORARY TABLEで作成されたテーブルを格納するために使用される補助データベースファイルにあります。</target>
        </trans-unit>
        <trans-unit id="b84cc68d91e3409f1edcdf58fc339f372294c1e2" translate="yes" xml:space="preserve">
          <source>The table being destroyed is in the main database file if P3==0. If P3==1 then the table to be clear is in the auxiliary database file that is used to store tables create using CREATE TEMPORARY TABLE.</source>
          <target state="translated">P3==0の場合、破棄されるテーブルはメインデータベースファイルにあります。 P3==1の場合、クリアされるテーブルはCREATE TEMPORARY TABLEで作成されたテーブルを格納するために使用される補助データベースファイルにあります。</target>
        </trans-unit>
        <trans-unit id="41f345ab868d88acd8992e4784839c2d5c1e8639" translate="yes" xml:space="preserve">
          <source>The table below lists a few of the virtual tables implementations available for SQLite. Developers can deploy these virtual tables in their own applications, or use the implementations shown below as templates for writing their own virtual tables.</source>
          <target state="translated">以下の表は、SQLite で利用可能な仮想テーブルの実装のいくつかを示しています。開発者は、これらの仮想テーブルを独自のアプリケーションに展開したり、以下の実装をテンプレートとして使用して独自の仮想テーブルを作成したりすることができます。</target>
        </trans-unit>
        <trans-unit id="0d5035ee89279b64afd0eeb8d11272d1a3924472" translate="yes" xml:space="preserve">
          <source>The table conceptually has a number of rows and columns. But these numbers are not part of the result table itself. These numbers are obtained separately. Let N be the number of rows and M be the number of columns.</source>
          <target state="translated">テーブルは概念的には行と列の数を持っています。しかし、これらの数字は結果テーブル自体の一部ではありません。これらの数は別々に得られます。Nを行の数、Mを列の数とする。</target>
        </trans-unit>
        <trans-unit id="dcf57858fad384bb52da74fd124071a651012ac9" translate="yes" xml:space="preserve">
          <source>The table has at least as many columns as recorded in the changeset, and</source>
          <target state="translated">テーブルには、チェンジセットに記録されているカラムの数と少なくとも同じ数のカラムがあり</target>
        </trans-unit>
        <trans-unit id="c59c86844961ecda887187879536aa8941add7f6" translate="yes" xml:space="preserve">
          <source>The table has primary key columns in the same position as recorded in the changeset.</source>
          <target state="translated">テーブルには、チェンジセットに記録されているのと同じ位置に主キーカラムがあります。</target>
        </trans-unit>
        <trans-unit id="80f1ee5eb53df523cde7e4859fa53a41bb0e9f57" translate="yes" xml:space="preserve">
          <source>The table has the same name as the name recorded in the changeset, and</source>
          <target state="translated">テーブルは、チェンジセットに記録された名前と同じ名前を持ち</target>
        </trans-unit>
        <trans-unit id="7d27b581c3631a8cd2d37de114b2996daa06d034" translate="yes" xml:space="preserve">
          <source>The table named in the table_info pragma can also be a view.</source>
          <target state="translated">table_infoプラグマで指定されたテーブルはビューにもなります。</target>
        </trans-unit>
        <trans-unit id="79bd6ebb5ebe8eca1811d6164c483996ae2dbb59" translate="yes" xml:space="preserve">
          <source>The table named on the left-hand side of the AS keyword must appear exactly once in the FROM clause of the right-most SELECT statement of the compound select, and nowhere else.</source>
          <target state="translated">AS キーワードの左側に指定されたテーブルは、複合セレクトの右端の SELECT 文の FROM 節に 1 回だけ出現する必要があり、それ以外の場所には出現しません。</target>
        </trans-unit>
        <trans-unit id="747fb24ebf8caf800f314099b86fad330ec2bb21" translate="yes" xml:space="preserve">
          <source>The table that is being changed</source>
          <target state="translated">変更されるテーブル</target>
        </trans-unit>
        <trans-unit id="e089550b926c62bbc2dcb5b20ca60a982f76e723" translate="yes" xml:space="preserve">
          <source>The table-name specified as part of a DELETE statement within a trigger body must be unqualified. In other words, the</source>
          <target state="translated">トリガボディ内のDELETE文の一部として指定されたテーブル名は、修飾されていないものでなければなりません。言い換えれば</target>
        </trans-unit>
        <trans-unit id="f34e54cb0abeaba37df0e01490317583d5a035fb" translate="yes" xml:space="preserve">
          <source>The table-name specified as part of an UPDATE statement within a trigger body must be unqualified. In other words, the</source>
          <target state="translated">トリガ本体内のUPDATE文の一部として指定されたテーブル名は、修飾されていないものでなければなりません。言い換えれば</target>
        </trans-unit>
        <trans-unit id="234e68825ade4fb4c6a3d0e2fe2ac2487e1f2eea" translate="yes" xml:space="preserve">
          <source>The table-valued function returns one row for each record (file, directory or symbolic link) in the zip archive. Each row has the following columns:</source>
          <target state="translated">table-valued 関数は、zip アーカイブ内の各レコード (ファイル、ディレクトリ、シンボリックリンク)について 1 行を返します。各行には以下の列があります。</target>
        </trans-unit>
        <trans-unit id="d7dc1f7c6b1a5d93554b66158b8eab41e9fa0f02" translate="yes" xml:space="preserve">
          <source>The table-valued function syntax may also be used to specify an alternative ranking function. In this case the text describing the ranking function should be specified as the second table-valued function argument. The following three queries are equivalent:</source>
          <target state="translated">テーブル値関数構文は、代替のランキング関数を指定するために使用することもできます。この場合、順位付け関数を記述するテキストを第2のテーブル値関数の引数として指定する必要があります。以下の3つのクエリは同等です。</target>
        </trans-unit>
        <trans-unit id="194c5b8001842ee44aaaa2c4539d9e178d7c37bd" translate="yes" xml:space="preserve">
          <source>The table-valued functions for PRAGMA feature was added in SQLite version 3.16.0 (2017-01-02). Prior versions of SQLite cannot use this feature.</source>
          <target state="translated">SQLite バージョン 3.16.0 (2017-01-02)で PRAGMA 機能のテーブル値関数が追加されました。それ以前のバージョンのSQLiteでは、この機能を使用することはできません。</target>
        </trans-unit>
        <trans-unit id="273bdbb137f334009fcac2c6deba9c8d09edc07d" translate="yes" xml:space="preserve">
          <source>The tableZ table has a single column named &quot;INTEGER&quot;. That column has no datatype specified, but it is the PRIMARY KEY. The column is &lt;em&gt;not&lt;/em&gt; the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; for the table because it has no datatype. The &quot;INTEGER&quot; token is used as an identifier for the column name, not as a datatype keyword.</source>
          <target state="translated">tableZテーブルには、「INTEGER」という名前の単一の列があります。その列にはデータ型が指定されていませんが、これはPRIMARYKEYです。列はあり&lt;em&gt;ません&lt;/em&gt;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;、それは何のデータ型を持っていないため、テーブルの。「INTEGER」トークンは、データ型キーワードとしてではなく、列名の識別子として使用されます。</target>
        </trans-unit>
        <trans-unit id="1296ca23d366e0c8b6ad53b34a86a007a9e6fcba" translate="yes" xml:space="preserve">
          <source>The tables necessary to do full and proper unicode case folding are larger than the whole SQLite library.</source>
          <target state="translated">完全かつ適切なユニコード大文字小文字の折り返しを行うために必要なテーブルは、SQLiteライブラリ全体よりも大きくなります。</target>
        </trans-unit>
        <trans-unit id="1fa68f636ed5379e184e8d386d825c36877f4a63" translate="yes" xml:space="preserve">
          <source>The tables that participate in a union-vtab can be in the same database file, or they can be in separate databases files that are &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed to the same database connection.</source>
          <target state="translated">union-vtabに参加しているテーブルは、同じデータベースファイルに存在することも、同じデータベース接続に&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;された別個のデータベースファイルに存在することもできます。</target>
        </trans-unit>
        <trans-unit id="30590c6f42ddca035bfcfa04a6fd54a5c5428cad" translate="yes" xml:space="preserve">
          <source>The target database may already contain a row with the same PRIMARY KEY values as specified by the INSERT change.</source>
          <target state="translated">ターゲット・データベースには、INSERT変更で指定されたものと同じPRIMARY KEY値を持つ行がすでに含まれている可能性があります。</target>
        </trans-unit>
        <trans-unit id="ddffb3a24b55dea30b114ff8f89840fe90c8c752" translate="yes" xml:space="preserve">
          <source>The target database may contain a row with the specified PRIMARY KEY values, but the current values of the fields that will be modified by the change may not match the original values stored within the changeset. This type of conflict is not detected when using a patchset.</source>
          <target state="translated">ターゲットデータベースには、指定された PRIMARY KEY 値を持つ行が含まれているかもしれませんが、変更によって変更されるフィールドの現在の値は、チェンジセット内に格納されている元の値と一致しないかもしれません。このタイプの競合は、パッチセットを使用している場合には検出されません。</target>
        </trans-unit>
        <trans-unit id="9637f3da3aa12d5bcfe7a6adc7e68c320df396f3" translate="yes" xml:space="preserve">
          <source>The target database may contain a row with the specified PRIMARY KEY values, but the other fields may contain values that do not match those stored as part of the changeset. This type of conflict is not detected when using a patchset.</source>
          <target state="translated">ターゲットデータベースには指定された PRIMARY KEY 値を持つ行が含まれているかもしれませんが、他のフィールドにはチェンジセットの一部として保存されている値と一致しない値が含まれているかもしれません。このタイプの競合は、パッチセットを使用しているときには検出されません。</target>
        </trans-unit>
        <trans-unit id="11c37f0367cfc6691a61d3fba7a936ab62a7d348" translate="yes" xml:space="preserve">
          <source>The target database may contain no row with the specified PRIMARY KEY values to delete.</source>
          <target state="translated">削除対象のデータベースには、指定されたPRIMARY KEY値を持つ行が含まれていない可能性があります。</target>
        </trans-unit>
        <trans-unit id="e2b06a833985a4c35aa0208799ae843a7b65a575" translate="yes" xml:space="preserve">
          <source>The target database may contain no row with the specified PRIMARY KEY values to modify.</source>
          <target state="translated">対象のデータベースには、指定されたPRIMARY KEY値を変更する行が含まれていない可能性があります。</target>
        </trans-unit>
        <trans-unit id="6f87cac991eff302d9976172f7bdf73e926bb9c2" translate="yes" xml:space="preserve">
          <source>The target database may not be in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">ターゲットデータベースが&lt;a href=&quot;wal&quot;&gt;WALモードで&lt;/a&gt;ない可能性があります。</target>
        </trans-unit>
        <trans-unit id="e79db16e64c18b69803344025e269d729d3745a5" translate="yes" xml:space="preserve">
          <source>The target table is not included in the FROM clause, unless the intent is to do a self-join against the target table. In the event of a self-join, the table in the FROM clause must be aliased to a different name than the target table.</source>
          <target state="translated">ターゲット・テーブルに対して自己結合を行う場合を除き、ターゲット・テーブルはFROM句に含まれません。自己結合の場合、FROM句のテーブルはターゲット・テーブルとは異なる名前にエイリアスされなければなりません。</target>
        </trans-unit>
        <trans-unit id="711e958f26b3fdef5ca444454f4ee0f963fc86d6" translate="yes" xml:space="preserve">
          <source>The task of the &quot;query planner&quot; is to figure out the best algorithm or &quot;query plan&quot; to accomplish an SQL statement. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26), the query planner component has been rewritten so that it runs faster and generates better plans. The rewrite is called the &quot;next generation query planner&quot; or &quot;NGQP&quot;.</source>
          <target state="translated">「クエリプランナー」のタスクは、SQLステートメントを実行するための最適なアルゴリズムまたは「クエリプラン」を見つけることです。SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;バージョン3.8.0&lt;/a&gt;（2013-08-26）以降、クエリプランナーコンポーネントが書き直され、より高速に実行され、より優れたプランを生成します。この書き換えは、「次世代クエリプランナー」または「NGQP」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="42a7ae31a25e761d6c699099d742c17f30af41a6" translate="yes" xml:space="preserve">
          <source>The team_id field cannot be unique because there usually multiple people on the same team. One cannot make the combination of team_id and is_team_leader unique since there are usually multiple non-leaders on each team. The solution to enforcing one leader per team is to create a unique index on team_id but restricted to those entries for which is_team_leader is true:</source>
          <target state="translated">通常、同じチームには複数の人がいるので、 team_idフィールドを一意にすることはできません。各チームには通常複数の非リーダーがいるので、 team_id と is_team_leader の組み合わせを一意にすることはできません。チームごとに1人のリーダーを強制する解決策は、チームIDにユニークなインデックスを作成することですが、is_team_leaderが真であるエントリに限定することです。</target>
        </trans-unit>
        <trans-unit id="0785e2dbbfabdba0d3916b209d305b3e5683f44f" translate="yes" xml:space="preserve">
          <source>The technique of having xFindFunction() return values of &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; was initially used in the implementation of the &lt;a href=&quot;geopoly&quot;&gt;Geopoly module&lt;/a&gt;. The xFindFunction() method of that module returns SQLITE_INDEX_CONSTRAINT_FUNCTION for the &lt;a href=&quot;geopoly#goverlap&quot;&gt;geopoly_overlap()&lt;/a&gt; SQL function and it returns SQLITE_INDEX_CONSTRAINT_FUNCTION+1 for the &lt;a href=&quot;geopoly#gwithin&quot;&gt;geopoly_within()&lt;/a&gt; SQL function. This permits search optimizations for queries such as:</source>
          <target state="translated">xFindFunctionを有するの技術は、（）の戻り値&lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTIONは&lt;/a&gt;、最初の実装で使用された&lt;a href=&quot;geopoly&quot;&gt;Geopolyモジュール&lt;/a&gt;。 xFindFunction（）のためにそのモジュールを返すSQLITE_INDEX_CONSTRAINT_FUNCTION方法&lt;a href=&quot;geopoly#goverlap&quot;&gt;geopoly_overlap（）&lt;/a&gt; SQL関数とそれがためSQLITE_INDEX_CONSTRAINT_FUNCTION + 1を返し&lt;a href=&quot;geopoly#gwithin&quot;&gt;geopoly_within（）&lt;/a&gt; SQL関数。これにより、次のようなクエリの検索を最適化できます。</target>
        </trans-unit>
        <trans-unit id="2710792de033b547bac6e441ea1f9b9d8e9fc431" translate="yes" xml:space="preserve">
          <source>The temp.sqlite_parameters table only provides values for parameters in the command-line shell. The temp.sqlite_parameter table has no effect on queries that are run directly using the SQLite C-language API. Individual applications are expected to implement their own parameter binding. You can search for &quot;sqlite_parameters&quot; in the &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;command-line shell source code&lt;/a&gt; to see how the command-line shell does parameter binding, and use that as a hint for how to implement it yourself.</source>
          <target state="translated">temp.sqlite_parametersテーブルは、コマンドラインシェルのパラメーターの値のみを提供します。temp.sqlite_parameterテーブルは、SQLite C言語APIを使用して直接実行されるクエリには影響しません。個々のアプリケーションは、独自のパラメーターバインディングを実装する必要があります。&lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;コマンドラインシェルのソースコード&lt;/a&gt;で「sqlite_parameters」を検索して、コマンドラインシェルがパラメータバインディングを実行する方法を確認し、それを自分で実装する方法のヒントとして使用できます。</target>
        </trans-unit>
        <trans-unit id="e0243e43a9e092811e1870e88e873ed47024b50d" translate="yes" xml:space="preserve">
          <source>The temporary file created by the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command exists only for the duration of the command itself. The size of the temporary file will be no larger than the original database.</source>
          <target state="translated">&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;コマンドによって作成された一時ファイルは、コマンド自体の期間だけ存在します。一時ファイルのサイズは、元のデータベースのサイズ以下になります。</target>
        </trans-unit>
        <trans-unit id="2f2df5fab6b729ca7d2c3e78798e53760ca0b74f" translate="yes" xml:space="preserve">
          <source>The temporary files associated with the TEMP database and its rollback journal are only created if the application makes use of the &quot;CREATE TEMP TABLE&quot; statement.</source>
          <target state="translated">TEMPデータベースとそのロールバックジャーナルに関連付けられた一時ファイルは、アプリケーションが &quot;CREATE TEMP TABLE &quot;ステートメントを使用した場合にのみ作成されます。</target>
        </trans-unit>
        <trans-unit id="f07c39bdad21f0453b3d046fa930925221ebb2c1" translate="yes" xml:space="preserve">
          <source>The temporary files associated with transaction control, namely the rollback journal, master journal, write-ahead log (WAL) files, and shared-memory files, are always written to disk. But the other kinds of temporary files might be stored in memory only and never written to disk. Whether or not temporary files other than the rollback, master, and statement journals are written to disk or stored only in memory depends on the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter, the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;, and on the size of the temporary file.</source>
          <target state="translated">トランザクション制御に関連する一時ファイル、つまりロールバックジャーナル、マスタージャーナル、先読みログ（WAL）ファイル、および共有メモリファイルは、常にディスクに書き込まれます。ただし、他の種類の一時ファイルはメモリにのみ保存され、ディスクに書き込まれることはありません。ロールバック、マスター、ステートメントジャーナル以外の一時ファイルがディスクに書き込まれるか、メモリにのみ保存されるかは、&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;コンパイル時パラメーター、&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_storeプラグマ&lt;/a&gt;、および一時ファイルのサイズによって異なります。</target>
        </trans-unit>
        <trans-unit id="408ca6d25d3ec064e51ba766d2fa74811ccbfcc3" translate="yes" xml:space="preserve">
          <source>The temporary files associated with transaction control, namely the rollback journal, super-journal, write-ahead log (WAL) files, and shared-memory files, are always written to disk. But the other kinds of temporary files might be stored in memory only and never written to disk. Whether or not temporary files other than the rollback, super, and statement journals are written to disk or stored only in memory depends on the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter, the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;, and on the size of the temporary file.</source>
          <target state="translated">トランザクション制御に関連する一時ファイル、つまりロールバックジャーナル、スーパージャーナル、先行書き込みログ（WAL）ファイル、および共有メモリファイルは、常にディスクに書き込まれます。ただし、他の種類の一時ファイルはメモリにのみ保存され、ディスクに書き込まれない場合があります。ロールバック、スーパー、およびステートメントジャーナル以外の一時ファイルがディスクに書き込まれるか、メモリにのみ格納されるかは、&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;コンパイル時パラメーター、&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_storeプラグマ&lt;/a&gt;、および一時ファイルのサイズによって異なります。</target>
        </trans-unit>
        <trans-unit id="42ee5d948678f086d276ab61d7dad5de2797f6e5" translate="yes" xml:space="preserve">
          <source>The term number of the matching term within the full-text query expression. Terms within a query expression are numbered starting from 0 in the order that they occur.</source>
          <target state="translated">フルテキストのクエリ式内の一致する用語の用語番号。クエリ式内の用語には、出現した順に 0 から始まる番号が付けられます。</target>
        </trans-unit>
        <trans-unit id="2146ad4958dfdca7b01896ef7e97e3c556f6bfc0" translate="yes" xml:space="preserve">
          <source>The term, as stored in the FTS5 index.</source>
          <target state="translated">FTS5インデックスに格納されている用語。</target>
        </trans-unit>
        <trans-unit id="efaf8ed4fd273fae5234c31a87ca20e1f921ce05" translate="yes" xml:space="preserve">
          <source>The terms &quot;protected&quot; and &quot;unprotected&quot; refer to whether or not a mutex is held. An internal mutex is held for a protected sqlite3_value object but no mutex is held for an unprotected sqlite3_value object. If SQLite is compiled to be single-threaded (with &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; and with &lt;a href=&quot;threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returning 0) or if SQLite is run in one of reduced mutex modes &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; or &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; then there is no distinction between protected and unprotected sqlite3_value objects and they can be used interchangeably. However, for maximum code portability it is recommended that applications still make the distinction between protected and unprotected sqlite3_value objects even when not strictly required.</source>
          <target state="translated">「保護されている」および「保護されていない」という用語は、ミューテックスが保持されているかどうかを示します。保護されたsqlite3_valueオブジェクトの内部ミューテックスは保持されますが、保護されていないsqlite3_valueオブジェクトのミューテックスは保持されません。 SQLiteがシングルスレッド（&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;および&lt;a href=&quot;threadsafe&quot;&gt;sqlite3_threadsafe（）が&lt;/a&gt; 0を返す）でコンパイルされている場合、またはSQLiteが縮小ミューテックスモード&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;または&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREADの&lt;/a&gt;いずれかで実行されている場合、保護されているsqlite3_valueオブジェクトと保護されていないsqlite3_valueオブジェクトは区別されず、互換的に使用されます。ただし、コードの移植性を最大限に高めるために、厳密に必要でない場合でも、アプリケーションで保護されたsqlite3_valueオブジェクトと保護されていないsqlite3_valueオブジェクトを区別することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="9b59119835d0c98638847083b9be8651dcfed7b3" translate="yes" xml:space="preserve">
          <source>The terms &quot;protected&quot; and &quot;unprotected&quot; refer to whether or not a mutex is held. An internal mutex is held for a protected sqlite3_value object but no mutex is held for an unprotected sqlite3_value object. If SQLite is compiled to be single-threaded (with &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; and with &lt;a href=&quot;#sqlite3_threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returning 0) or if SQLite is run in one of reduced mutex modes &lt;a href=&quot;#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; or &lt;a href=&quot;#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; then there is no distinction between protected and unprotected sqlite3_value objects and they can be used interchangeably. However, for maximum code portability it is recommended that applications still make the distinction between protected and unprotected sqlite3_value objects even when not strictly required.</source>
          <target state="translated">「保護されている」および「保護されていない」という用語は、ミューテックスが保持されているかどうかを示します。保護されたsqlite3_valueオブジェクトの内部ミューテックスは保持されますが、保護されていないsqlite3_valueオブジェクトのミューテックスは保持されません。 SQLiteがシングルスレッド（&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;および&lt;a href=&quot;#sqlite3_threadsafe&quot;&gt;sqlite3_threadsafe（）が&lt;/a&gt; 0を返す）でコンパイルされている場合、またはSQLiteが縮小ミューテックスモード&lt;a href=&quot;#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;または&lt;a href=&quot;#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREADの&lt;/a&gt;いずれかで実行されている場合、保護されているsqlite3_valueオブジェクトと保護されていないsqlite3_valueオブジェクトは区別されず、互換的に使用されます。ただし、コードの移植性を最大限に高めるために、厳密に必要でない場合でも、アプリケーションで保護されたsqlite3_valueオブジェクトと保護されていないsqlite3_valueオブジェクトを区別することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="d0d8bb329a3e29ad5aa4a494be22dcdfc57447c5" translate="yes" xml:space="preserve">
          <source>The terms in W and X must match exactly. SQLite does not do algebra to try to get them to look the same. The term &quot;b=6&quot; does not match &quot;b=3+3&quot; or &quot;b-6=0&quot; or &quot;b BETWEEN 6 AND 6&quot;. &quot;b=6&quot; will match to &quot;6=b&quot; as long as &quot;b=6&quot; is on the index and &quot;6=b&quot; is in the query. If a term of the form &quot;6=b&quot; appears in the index, it will never match anything.</source>
          <target state="translated">WとXの項は正確に一致しなければなりません。SQLite は、それらを同じように見えるようにするために代数学を行いません。&quot;b=6 &quot;という用語は、&quot;b=3+3 &quot;や &quot;b-6=0 &quot;や &quot;b BETWEEN 6 AND 6 &quot;とは一致しません。&quot;b=6 &quot;がインデックスにあり、&quot;6=b &quot;がクエリにある限り、&quot;b=6 &quot;は &quot;6=b &quot;にマッチします。&quot;6=b &quot;という形式の項がインデックスに現れた場合、それは何にもマッチしない。</target>
        </trans-unit>
        <trans-unit id="1a91aabb1ee8a98e3573519dc568a9cdcf09f371" translate="yes" xml:space="preserve">
          <source>The test infrastructure verifies that SQLite does not misuse dynamically allocated memory by using a specially instrumented memory allocator. The instrumented memory allocator is enabled at compile-time using the &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; option. The instrumented memory allocator is much slower than the default memory allocator and so its use is not recommended in production. But when enabled during testing, the instrumented memory allocator performs the following checks:</source>
          <target state="translated">テストインフラストラクチャは、SQLiteが特別に装備されたメモリアロケーターを使用して、動的に割り当てられたメモリを誤用しないことを確認します。インストルメントされたメモリアロケータは、コンパイル時に&lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt;オプションを使用して有効になります。インストルメントされたメモリアロケータは、デフォルトのメモリアロケータよりもはるかに遅いため、本番環境での使用はお勧めしません。ただし、テスト中に有効にすると、インストルメント化されたメモリアロケータは次のチェックを実行します。</target>
        </trans-unit>
        <trans-unit id="23d89111adcbe2ab0ff1f685425a6f5892695526" translate="yes" xml:space="preserve">
          <source>The test suite is designed to be run three times, once for each of the ALWAYS() and NEVER() definitions shown above. All three test runs should yield exactly the same result. There is a run-time test using the &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control&lt;/a&gt;(&lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_ALWAYS&lt;/a&gt;, ...) interface that can be used to verify that the macros are correctly set to the first form (the pass-through form) for deployment.</source>
          <target state="translated">テストスイートは、上記のALWAYS（）およびNEVER（）の定義ごとに1回ずつ、3回実行するように設計されています。3つのテストを実行しても、まったく同じ結果が得られます。&lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control&lt;/a&gt;（&lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_ALWAYS&lt;/a&gt;、...）インターフェースを使用したランタイムテストがあり、展開用にマクロが最初のフォーム（パススルーフォーム）に正しく設定されていることを確認するために使用できます。</target>
        </trans-unit>
        <trans-unit id="77fbf4494f9eeac6c3dd3e8030fecebddc25654d" translate="yes" xml:space="preserve">
          <source>The test suites for SQLite also explore the result of stacking multiple failures. For example, tests are run to ensure correct behavior when an I/O error or OOM fault occurs while trying to recover from a prior crash.</source>
          <target state="translated">SQLite 用のテストスイートでは、複数の障害を積み重ねた結果についても調査しています。例えば、I/O エラーや OOM フォールトが発生したときに、以前のクラッシュから回復しようとしている間に正しい動作を確認するためにテストが実行されます。</target>
        </trans-unit>
        <trans-unit id="a7eb514323fac72f4df40162cf2fb7ca6826d6f1" translate="yes" xml:space="preserve">
          <source>The test1.dir directory will contain 100,000 files with names like &quot;000000&quot;, &quot;000001&quot;, &quot;000002&quot; and so forth but the test1.tree directory will contain the same files in subdirectories like &quot;00/00/00&quot;, &quot;00/00/01&quot;, and so on. The test1.dir and test1.test directories take up approximately the same amount of space, though test1.test is very slightly larger due to the extra directory entries.</source>
          <target state="translated">test1.dirディレクトリには、&quot;000000&quot;、&quot;000001&quot;、&quot;000002 &quot;などの名前を持つ100,000個のファイルが含まれますが、test1.treeディレクトリには、&quot;00/00/00/00&quot;、&quot;00/00/01 &quot;などのサブディレクトリに同じファイルが含まれます。test1.dirとtest1.testディレクトリは、test1.testが余分なディレクトリエントリのために非常にわずかに大きくなっていますが、スペースのほぼ同じ量を占めています。</target>
        </trans-unit>
        <trans-unit id="833841004a13aff638c7a47f3f35a8f25f41ac0a" translate="yes" xml:space="preserve">
          <source>The test_async.c drive now does full file locking and works correctly when used simultaneously by multiple processes on the same database.</source>
          <target state="translated">test_async.c ドライブが完全なファイルロックを行い、同じデータベース上で複数のプロセスが同時に使用された場合に正しく動作するようになりました。</target>
        </trans-unit>
        <trans-unit id="eb420a5e9808216cc66d2c072d0472129ab690a9" translate="yes" xml:space="preserve">
          <source>The testcase() macro is often used to verify that boundary cases of an inequality comparison are checked. For example, at &lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=5766&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=5766&lt;/a&gt;. These kind of checks help to prevent off-by-one errors.</source>
          <target state="translated">testcase（）マクロは、不等比較の境界ケースがチェックされていることを確認するためによく使用されます。たとえば、&lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=5766&quot;&gt;https：//sqlite.org/src/artifact/18a53540aa3？ln = 5766にあります&lt;/a&gt;。これらの種類のチェックは、オフバイワンエラーの防止に役立ちます。</target>
        </trans-unit>
        <trans-unit id="bfd50a8b5d17dc1d197a2f0aeffde22600cc3d5e" translate="yes" xml:space="preserve">
          <source>The testcase(X) macro is normally a no-op, but for a coverage test build it does generate a small amount of extra code that includes at least one branch, in order to verify that test cases exist for which X is both true and false.</source>
          <target state="translated">testcase(X)マクロは通常は実行しませんが、カバレッジテストのビルドでは、X が true と false の両方のテストケースが存在することを検証するために、少なくとも 1 つのブランチを含む少量の余分なコードを生成します。</target>
        </trans-unit>
        <trans-unit id="198025ed4b90dd540b423fcfb30efac73a9076a6" translate="yes" xml:space="preserve">
          <source>The testing process for SQLite is described in the &lt;a href=&quot;testing&quot;&gt;testing&lt;/a&gt; document. Testing objectives include:</source>
          <target state="translated">SQLiteのテストプロセスは、&lt;a href=&quot;testing&quot;&gt;テスト&lt;/a&gt;ドキュメントに記載されています。テストの目的は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="7f341b9da6892f9f513eb1e23029aaad7d1945bb" translate="yes" xml:space="preserve">
          <source>The testing process is controlled by the &lt;a href=&quot;testing#cklist&quot;&gt;release testing checklists&lt;/a&gt;. The checklists succinctly summary all steps necessary to fully validate SQLite, and they record when and by whom each validation step was performed.</source>
          <target state="translated">テストプロセスは、&lt;a href=&quot;testing#cklist&quot;&gt;リリーステストチェックリスト&lt;/a&gt;によって制御されます。チェックリストは、SQLiteを完全に検証するために必要なすべてのステップを簡潔に要約し、各検証ステップがいつ誰によって実行されたかを記録します。</target>
        </trans-unit>
        <trans-unit id="b10a0b7612e25fb69c97ba29101b2f64b4a7581b" translate="yes" xml:space="preserve">
          <source>The text format is pure SQL so you can also use the .dump command to export an SQLite database into other popular SQL database engines. Like this:</source>
          <target state="translated">テキスト形式は純粋なSQLなので、.dumpコマンドを使用してSQLiteデータベースを他の一般的なSQLデータベースエンジンにエクスポートすることもできます。このような感じです。</target>
        </trans-unit>
        <trans-unit id="002ca6dfea0de9e1d73a68077f123004fa9755de" translate="yes" xml:space="preserve">
          <source>The text in the sqlite_master.sql column is a copy of the original CREATE statement text that created the object, except normalized as described above and as modified by subsequent &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; statements. The sqlite_master.sql is NULL for the &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; that are automatically created by &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints.</source>
          <target state="translated">sqlite_master.sql列のテキストは、オブジェクトを作成した元のCREATEステートメントのテキストのコピーです。ただし、上記のように正規化され、後続の&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;ステートメントによって変更される場合を除きます。&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;または&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;制約によって自動的に作成される&lt;a href=&quot;fileformat2#intschema&quot;&gt;内部インデックスの&lt;/a&gt;場合、sqlite_master.sqlはNULLです。</target>
        </trans-unit>
        <trans-unit id="df540746bab5e3cce21edce12d96e726e4a223e9" translate="yes" xml:space="preserve">
          <source>The text in the sqlite_schema.sql column is a copy of the original CREATE statement text that created the object, except normalized as described above and as modified by subsequent &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; statements. The sqlite_schema.sql is NULL for the &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; that are automatically created by &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints.</source>
          <target state="translated">sqlite_schema.sql列のテキストは、上記およびそれに続くによって修正されるよう記載されているように正規化を除いて、オブジェクトを作成した文のテキストを作成オリジナルのコピーである&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLEの&lt;/a&gt;ステートメント。sqlite_schema.sqlはのためのNULLである&lt;a href=&quot;fileformat2#intschema&quot;&gt;内部インデックス&lt;/a&gt;によって自動的に作成された&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;または&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEYの&lt;/a&gt;制約。</target>
        </trans-unit>
        <trans-unit id="3362b59e42a116b494bb787cf561f00b28111a39" translate="yes" xml:space="preserve">
          <source>The text of query parameters is appended to the filename argument of the xOpen method of the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. Any %HH escape sequences in the query parameters are resolved prior to being appended to the xOpen filename. A single zero-byte separates the xOpen filename argument from the key of the first query parameters, each key and value, and each subsequent key from the prior value. The list of query parameters appended to the xOpen filename is terminated by a single zero-length key. Note that the value of a query parameter can be an empty string.</source>
          <target state="translated">クエリパラメータのテキストは、&lt;a href=&quot;vfs&quot;&gt;VFSの&lt;/a&gt; xOpenメソッドのファイル名引数に追加されます。クエリパラメータ内の％HHエスケープシーケンスは、xOpenファイル名に追加される前に解決されます。 1つのゼロバイトは、xOpenファイル名引数を最初のクエリパラメータのキー、各キーと値、および後続の各キーを前の値から分離します。 xOpenファイル名に追加されたクエリパラメータのリストは、単一の長さゼロのキーで終了します。クエリパラメータの値は空の文字列でもかまいません。</target>
        </trans-unit>
        <trans-unit id="f010a4aeda05a6fff949d6b23c4d99edd507a5b9" translate="yes" xml:space="preserve">
          <source>The text of the word that matches the pattern. Both word and pattern can contain unicode characters and can be mixed case.</source>
          <target state="translated">パターンに一致する単語のテキスト。単語とパターンの両方ともユニコード文字を含むことができ、大文字と小文字を混在させることができます。</target>
        </trans-unit>
        <trans-unit id="34ac3915c6fa697bff1880701cc84fcf41ef0614" translate="yes" xml:space="preserve">
          <source>The text to add to the start or end of the selected text to indicate that the returned text does not occur at the start or end of its column, respectively.</source>
          <target state="translated">返されたテキストがその列の先頭または末尾に存在しないことを示すために、選択されたテキストの先頭または末尾にそれぞれ追加するテキスト。</target>
        </trans-unit>
        <trans-unit id="5d227441e585adc9dccb7fd5119a447b09eeb780" translate="yes" xml:space="preserve">
          <source>The text to insert after each phrase match within the returned text.</source>
          <target state="translated">返されたテキスト内の各フレーズマッチの後に挿入するテキスト。</target>
        </trans-unit>
        <trans-unit id="c372789c27ae2ac063bb79f99aab7639b81bdf47" translate="yes" xml:space="preserve">
          <source>The text to insert after each phrase match.</source>
          <target state="translated">フレーズマッチの後に挿入するテキスト。</target>
        </trans-unit>
        <trans-unit id="98deed99ebb119a4eabb19891d9d80c8f6d99766" translate="yes" xml:space="preserve">
          <source>The text to insert before each phrase match within the returned text.</source>
          <target state="translated">返されたテキスト内の各フレーズマッチの前に挿入するテキスト。</target>
        </trans-unit>
        <trans-unit id="011020fd80da1d64051ffd57ff7d4f9db6949595" translate="yes" xml:space="preserve">
          <source>The text to insert before each phrase match.</source>
          <target state="translated">各フレーズマッチの前に挿入するテキスト。</target>
        </trans-unit>
        <trans-unit id="41db7390257d3e1c83cfe7262fbe75efa4098374" translate="yes" xml:space="preserve">
          <source>The theoretical maximum number of rows in a table is 2&lt;sup&gt;&lt;small&gt;64&lt;/small&gt;&lt;/sup&gt; (18446744073709551616 or about 1.8e+19). This limit is unreachable since the maximum database size of 140 terabytes will be reached first. A 140 terabytes database can hold no more than approximately 1e+13 rows, and then only if there are no indices and if each row contains very little data.</source>
          <target state="translated">テーブルの行の理論上の最大数は2 &lt;sup&gt;&lt;small&gt;64&lt;/small&gt;&lt;/sup&gt;（18446744073709551616または約1.8e + 19）です。最初に140テラバイトの最大データベースサイズに到達するため、この制限に到達することはできません。140テラバイトのデータベースが保持できるのは約1e + 13行以下であり、インデックスがなく、各行に含まれるデータが非常に少ない場合のみです。</target>
        </trans-unit>
        <trans-unit id="9c469d0a6dd7814f8f536d83dd0c0d4f9236b847" translate="yes" xml:space="preserve">
          <source>The theoretical maximum number of rows in a table is 2&lt;sup&gt;&lt;small&gt;64&lt;/small&gt;&lt;/sup&gt; (18446744073709551616 or about 1.8e+19). This limit is unreachable since the maximum database size of 281 terabytes will be reached first. A 281 terabytes database can hold no more than approximately 2e+13 rows, and then only if there are no indices and if each row contains very little data.</source>
          <target state="translated">テーブル内の行の理論上の最大数は2である&lt;sup&gt;&lt;small&gt;64&lt;/small&gt;&lt;/sup&gt;（18446744073709551616または1.8E + 19程度）。データベースの最大サイズである281テラバイトに最初に到達するため、この制限には到達できません。281テラバイトのデータベースは、約2e + 13行しか保持できません。これは、インデックスがなく、各行に含まれるデータが非常に少ない場合に限ります。</target>
        </trans-unit>
        <trans-unit id="8e681320a770693ff8880c2fe787c3d46c58d6fe" translate="yes" xml:space="preserve">
          <source>The these routines may attempt to convert the datatype of the result. For example, if the internal representation is FLOAT and a text result is requested, &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; is used internally to perform the conversion automatically. The following table details the conversions that are applied:</source>
          <target state="translated">これらのルーチンは、結果のデータ型を変換しようとする場合があります。たとえば、内部表現がFLOATであり、テキスト結果が要求された場合、&lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;が内部で使用され、変換が自動的に実行されます。次の表に、適用される変換の詳細を示します。</target>
        </trans-unit>
        <trans-unit id="d45ababe332de0d6a9b7d204a8229a091726f141" translate="yes" xml:space="preserve">
          <source>The these routines may attempt to convert the datatype of the result. For example, if the internal representation is FLOAT and a text result is requested, &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; is used internally to perform the conversion automatically. The following table details the conversions that are applied:</source>
          <target state="translated">これらのルーチンは、結果のデータ型を変換しようとする場合があります。たとえば、内部表現がFLOATであり、テキスト結果が要求された場合、&lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;が内部で使用され、変換が自動的に実行されます。次の表に、適用される変換の詳細を示します。</target>
        </trans-unit>
        <trans-unit id="f29b8fd84fbcfd59fccde21c2067cc383b5612cf" translate="yes" xml:space="preserve">
          <source>The third and fourth parameters to this function are the table and column name of the desired column, respectively.</source>
          <target state="translated">この関数の3番目と4番目のパラメータは、それぞれ目的のカラムのテーブル名とカラム名です。</target>
        </trans-unit>
        <trans-unit id="5dad7ccfb7adf02e60a4718cd1bfaf6cc7ad8094" translate="yes" xml:space="preserve">
          <source>The third argument (eTextRep) must be one of the constants:</source>
          <target state="translated">第3引数(eTextRep)は定数のいずれかでなければなりません。</target>
        </trans-unit>
        <trans-unit id="a12fbbce4ea7f98c6f3257e48e8cfdd9d6a7f402" translate="yes" xml:space="preserve">
          <source>The third argument is the value to bind to the parameter. If the third parameter to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_blob() is a NULL pointer then the fourth parameter is ignored and the end result is the same as sqlite3_bind_null().</source>
          <target state="translated">第3引数はパラメータにバインドする値です。sqlite3_bind_text()、sqlite3_bind_text16()、sqlite3_bind_blob()の3番目のパラメータがNULLポインタの場合、4番目のパラメータは無視され、最終的な結果はsqlite3_bind_null()と同じです。</target>
        </trans-unit>
        <trans-unit id="cfd2994dc5175da09229d952b2be33f11c05e0da" translate="yes" xml:space="preserve">
          <source>The third argument is the value to bind to the parameter. If the third parameter to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_blob() is a NULL pointer then the fourth parameter is ignored and the end result is the same as sqlite3_bind_null(). If the third parameter to sqlite3_bind_text() is not NULL, then it should be a pointer to well-formed UTF8 text. If the third parameter to sqlite3_bind_text16() is not NULL, then it should be a pointer to well-formed UTF16 text. If the third parameter to sqlite3_bind_text64() is not NULL, then it should be a pointer to a well-formed unicode string that is either UTF8 if the sixth parameter is SQLITE_UTF8, or UTF16 otherwise.</source>
          <target state="translated">第3引数はパラメータにバインドする値です。sqlite3_bind_text()またはsqlite3_bind_text16()またはsqlite3_bind_blob()の3番目のパラメータがNULLポインタの場合、4番目のパラメータは無視され、最終的な結果はsqlite3_bind_null()と同じになります。sqlite3_bind_text()の3番目のパラメータがNULLでない場合は、整形されたUTF8テキストへのポインタでなければなりません。sqlite3_bind_text16()の3番目のパラメータがNULLでない場合は、整形済みのUTF16テキストへのポインタになります。sqlite3_bind_text64()の3番目のパラメータがNULLでない場合は、6番目のパラメータがSQLITE_UTF8の場合はUTF8、そうでない場合はUTF16のいずれかである整形済みのユニコード文字列へのポインタでなければなりません。</target>
        </trans-unit>
        <trans-unit id="8896799f29c2adcd495a7004a3dfd8ef2c595b55" translate="yes" xml:space="preserve">
          <source>The third argument to the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt;,...) interface (the &quot;pData&quot; argument in the example above) is a pointer to arbitrary data. SQLite passes this pointer through to the first argument of the error logger callback. The pointer can be used to pass application-specific setup or state information, if desired. Or it can simply be a NULL pointer which is ignored by the callback.</source>
          <target state="translated">&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt;、...）インターフェースの3番目の引数（上記の例では &quot;pData&quot;引数）は、任意のデータへのポインターです。 SQLiteは、このポインターをエラーロガーコールバックの最初の引数に渡します。必要に応じて、ポインターを使用して、アプリケーション固有のセットアップまたは状態情報を渡すことができます。または、コールバックによって無視されるNULLポインタにすることもできます。</target>
        </trans-unit>
        <trans-unit id="8e80d3a19f53ad5c94b48f6b4deace1bd8cd6a01" translate="yes" xml:space="preserve">
          <source>The third chart shows that reading blob content out of SQLite can be twice as fast as reading from individual files on disk for Mac and Android, and an amazing ten times faster for Windows.</source>
          <target state="translated">3 番目のグラフは、SQLite から blob コンテンツを読み出す場合、Mac と Android ではディスク上の個別ファイルから読み出す場合の 2 倍の速さで、Windows では驚くほど 10 倍の速さで読み出すことができることを示しています。</target>
        </trans-unit>
        <trans-unit id="ce81cfaf801aa960a0d4e258e6f72c47aaf642db" translate="yes" xml:space="preserve">
          <source>The third column is the minimum value for any rowid in the table.</source>
          <target state="translated">3 番目の列は、テーブル内の任意の rowid の最小値です。</target>
        </trans-unit>
        <trans-unit id="66b245a2c0333e9c6e002eaadabc21caae3f20aa" translate="yes" xml:space="preserve">
          <source>The third form of an INSERT statement is with DEFAULT VALUES. The INSERT ... DEFAULT VALUES statement inserts a single new row into the named table. Each column of the new row is populated with its &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;default value&lt;/a&gt;, or with a NULL if no default value is specified as part of the column definition in the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. The &lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert-clause&lt;/a&gt; is not supported after DEFAULT VALUES.</source>
          <target state="translated">INSERTステートメントの3番目の形式は、DEFAULT VALUESを使用するものです。 INSERT ... DEFAULT VALUESステートメントは、単一の新しい行を名前付きテーブルに挿入します。新しい行の各列には、その&lt;a href=&quot;lang_createtable#dfltval&quot;&gt;デフォルト値&lt;/a&gt;が入力されます&lt;a href=&quot;lang_createtable&quot;&gt;。CREATETABLE&lt;/a&gt;ステートメントの列定義の一部としてデフォルト値が指定されていない場合は、NULLが入力されます。&lt;a href=&quot;syntax/upsert-clause&quot;&gt;アップサート-句は&lt;/a&gt;、デフォルト値の後にサポートされていません。</target>
        </trans-unit>
        <trans-unit id="80211bcbcab262c368d4da63de6e8f61d55d7f66" translate="yes" xml:space="preserve">
          <source>The third line of the example shows the virtual table being used, to read all content of the CSV file. This is perhaps the simplest possible use of the virtual table. The CSV virtual table can be used anywhere an ordinary virtual table can be used. One can use the CSV virtual table inside subqueries, or &lt;a href=&quot;lang_with&quot;&gt;common table expressions&lt;/a&gt; or add WHERE, GROUP BY, HAVING, ORDER BY, and LIMIT clauses as required.</source>
          <target state="translated">例の3行目は、CSVファイルのすべてのコンテンツを読み取るために使用されている仮想テーブルを示しています。これは、おそらく仮想テーブルの最も単純な使用法です。CSV仮想テーブルは、通常の仮想テーブルを使用できる場所であればどこでも使用できます。サブクエリ内のCSV仮想テーブル、または&lt;a href=&quot;lang_with&quot;&gt;共通テーブル式を&lt;/a&gt;使用するか、必要に応じてWHERE、GROUP BY、HAVING、ORDER BY、およびLIMIT句を追加できます。</target>
        </trans-unit>
        <trans-unit id="37d0f732f75ffbc9298be10c6e109dfc37fa5d4b" translate="yes" xml:space="preserve">
          <source>The third number Z is incremented for releases consisting of only small changes that implement performance enhancements and/or bug fixes.</source>
          <target state="translated">3番目のZ数は、パフォーマンスの向上および/またはバグ修正を実施する小さな変更のみで構成されたリリースに対して増分されています。</target>
        </trans-unit>
        <trans-unit id="d43fa02ec7a69fa0b5cb4656ab69a4413a6918c8" translate="yes" xml:space="preserve">
          <source>The third optimization, zeroing the journal file header rather than deleting the rollback journal file, does not depend on holding an exclusive lock at all times. This optimization can be set independently of exclusive lock mode using the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt; as described in &lt;a href=&quot;#section_7_6&quot;&gt;section 7.6&lt;/a&gt; below.</source>
          <target state="translated">3番目の最適化、ロールバックジャーナルファイルを削除するのではなくジャーナルファイルヘッダーをゼロにすることは、常に排他ロックを保持することに依存しません。この最適化は、以下の&lt;a href=&quot;#section_7_6&quot;&gt;セクション7.6で&lt;/a&gt;説明するように、&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_modeプラグマ&lt;/a&gt;を使用して、排他ロックモードとは無関係に設定できます。</target>
        </trans-unit>
        <trans-unit id="226219f131eebb1bb82e3a9e80c20160ef9e49d4" translate="yes" xml:space="preserve">
          <source>The third parameter (nArg) is the number of arguments that the SQL function or aggregate takes. If this parameter is -1, then the SQL function or aggregate may take any number of arguments between 0 and the limit set by &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;). If the third parameter is less than -1 or greater than 127 then the behavior is undefined.</source>
          <target state="translated">3番目のパラメーター（nArg）は、SQL関数または集約が取る引数の数です。このパラメーターが-1の場合、SQL関数または集約は、0と&lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;（&lt;a href=&quot;#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;）によって設定された制限の間の任意の数の引数を取ることができます。 3番目のパラメーターが-1未満または127より大きい場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="11f56952c8e04a9269627afb8274637d6b360ea2" translate="yes" xml:space="preserve">
          <source>The third parameter (nArg) is the number of arguments that the SQL function or aggregate takes. If this parameter is -1, then the SQL function or aggregate may take any number of arguments between 0 and the limit set by &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;c_limit_attached#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;). If the third parameter is less than -1 or greater than 127 then the behavior is undefined.</source>
          <target state="translated">3番目のパラメーター（nArg）は、SQL関数または集約が取る引数の数です。このパラメーターが-1の場合、SQL関数または集約は、0と&lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;（&lt;a href=&quot;c_limit_attached#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;）によって設定された制限の間の任意の数の引数を取ることができます。 3番目のパラメーターが-1未満または127より大きい場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="7effa7c199d796ec9c7957d5b06f69295ac44ef2" translate="yes" xml:space="preserve">
          <source>The third step starts with the four shortest two-node paths and finds the four shortest three-node paths:</source>
          <target state="translated">第3ステップは、最短2ノードの4つのパスから始まり、最短3ノードの4つのパスを見つけます。</target>
        </trans-unit>
        <trans-unit id="97390ca779620e87876318d53cdbb5c0eb4c1782" translate="yes" xml:space="preserve">
          <source>The threading mode can be selected at compile-time (when the SQLite library is being compiled from source code) or at start-time (when the application that intends to use SQLite is initializing) or at run-time (when a new SQLite database connection is being created). Generally speaking, run-time overrides start-time and start-time overrides compile-time. Except, single-thread mode cannot be overridden once selected.</source>
          <target state="translated">スレッディングモードは、コンパイル時(ソースコードからSQLiteライブラリをコンパイルしているとき)、スタート時(SQLiteを使用しようとするアプリケーションが初期化しているとき)、またはランタイム(新しいSQLiteデータベース接続が作成されているとき)に選択することができます。一般的に言えば、ランタイムはスタートタイムよりも優先され、スタートタイムはコンパイルタイムよりも優先されます。ただし、シングルスレッドモードは一度選択すると上書きできません。</target>
        </trans-unit>
        <trans-unit id="7a0e198fd0423256115863d78eac9cac1343e176" translate="yes" xml:space="preserve">
          <source>The threading mode for an individual database connection is determined by flags given as the third argument to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; flag causes the database connection to be in the multi-thread mode and the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; flag causes the connection to be in serialized mode. If neither flag is specified or if &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; are used instead of &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, then the default mode determined by the compile-time and start-time settings is used.</source>
          <target state="translated">個々のデータベース接続のスレッドモードは、&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）の&lt;/a&gt; 3番目の引数として指定されたフラグによって決定されます。&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEXの&lt;/a&gt;フラグは、データベース接続がマルチスレッド・モードであることが原因と&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEXの&lt;/a&gt;フラグがシリアライズモードにする接続を引き起こします。どちらのフラグが指定場合、またはされている場合&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;または&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）&lt;/a&gt;の代わりに使用されている&lt;a href=&quot;c3ref/open&quot;&gt;（sqlite3_open_v2） &lt;/a&gt;、デフォルトのモードは、コンパイル時と開始時間を設定することによって決定に使用されます。</target>
        </trans-unit>
        <trans-unit id="a70f1f8b6fb5520108a2b27f649a3322d3c256dc" translate="yes" xml:space="preserve">
          <source>The three auxiliary functions are only useful within a SELECT statement that uses the FTS table's full-text index. If used within a SELECT that uses the &quot;query by rowid&quot; or &quot;linear scan&quot; strategies, then the snippet and offsets both return an empty string, and the matchinfo function returns a blob value zero bytes in size.</source>
          <target state="translated">3つの補助関数は、FTSテーブルのフルテキストインデックスを使用するSELECT文内でのみ有用です。query by rowid &quot;または &quot;linear scan &quot;ストラテジーを使用するSELECT内で使用された場合、スニペットとオフセットはどちらも空の文字列を返し、matchinfo関数はサイズ0バイトのブロブ値を返します。</target>
        </trans-unit>
        <trans-unit id="6eb0a1f7b89a823f8bdbde0d13568a18262e614a" translate="yes" xml:space="preserve">
          <source>The three basic query types described above may be used to query the full-text index for the set of documents that match the specified criteria. Using the FTS query expression language it is possible to perform various set operations on the results of basic queries. There are currently three supported operations:</source>
          <target state="translated">上で説明した3つの基本的な問い合わせタイプは、指定された条件に一致する文書の集合に対して全文インデックスを問い合わせるために使用することができる。FTS クエリ表現言語を用いて、基本的なクエリの結果に対して様々な集合操作を行うことができます。現在サポートされている操作は3つです。</target>
        </trans-unit>
        <trans-unit id="7097964beca5dc252968954049e7c0946f78e4a9" translate="yes" xml:space="preserve">
          <source>The three leftmost columns of a zipfile virtual table, &quot;name&quot;, &quot;mode&quot; and &quot;mtime&quot;, may each be set to any value that may be inserted into the same column (see above). If either &quot;mode&quot; or &quot;mtime&quot; is set to NULL, the final value is determined as described for an INSERT of a NULL value - the current time for &quot;mtime&quot; and either 33188 or 16877 for &quot;mode&quot;, depending on whether or not the values specified for the next four columns of the zipfile table indicate that the entry is a directory or a file.</source>
          <target state="translated">zipfile仮想テーブルの左端の3つの列、&quot;name&quot;、&quot;mode&quot;、&quot;mtime &quot;は、それぞれ同じ列に挿入することができる任意の値を設定することができます(上記参照)。mode&quot; または &quot;mtime&quot; のいずれかが NULL に設定されている場合、最終的な値は NULL 値の INSERT で説明したように決定されます。</target>
        </trans-unit>
        <trans-unit id="3411dedba6408ea6c13a17f75aea9b87b7d91fad" translate="yes" xml:space="preserve">
          <source>The time string can be followed by zero or more modifiers that alter date and/or time. Each modifier is a transformation that is applied to the time value to its left. Modifiers are applied from left to right; order is important. The available modifiers are as follows.</source>
          <target state="translated">時間文字列の後には、日付や時間を変更する0個以上の修飾子を付けることができます。各修飾子は、その左側の時間値に適用される変換です。修飾子は左から右に適用されます。利用可能な修飾子は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="30024a74e5aefa6cc166b0948a8f34eea1be4641" translate="yes" xml:space="preserve">
          <source>The time taken to execute each virtual machine operation can vary based on many factors. A typical value for a 1 GHz PC is between half and three million per second but may be much higher or lower, depending on the query. As such it is difficult to schedule background operations based on virtual machine operations. Instead, it is recommended that a callback be scheduled relatively frequently (say every 1000 instructions) and external timer routines used to determine whether or not background jobs need to be run.</source>
          <target state="translated">各仮想マシン操作の実行にかかる時間は、多くの要因に基づいて変化します。1GHzのPCの典型的な値は50万~300万/秒ですが、クエリによってはもっと高くなったり低くなったりします。そのため、仮想マシン操作に基づいてバックグラウンド操作をスケジューリングすることは困難です。その代わり、コールバックを比較的頻繁に(例えば1000命令ごとに)スケジュールし、バックグラウンドジョブを実行する必要があるかどうかを判断するために外部タイマールーチンを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="d31d23c9c6ce92ba1161f4e9fe89ef4c4bc1cceb" translate="yes" xml:space="preserve">
          <source>The times reported on all tests represent wall-clock time in seconds. Two separate time values are reported for SQLite. The first value is for SQLite in its default configuration with full disk synchronization turned on. With synchronization turned on, SQLite executes an &lt;b&gt;fsync()&lt;/b&gt; system call (or the equivalent) at key points to make certain that critical data has actually been written to the disk drive surface. Synchronization is necessary to guarantee the integrity of the database if the operating system crashes or the computer powers down unexpectedly in the middle of a database update. The second time reported for SQLite is when synchronization is turned off. With synchronization off, SQLite is sometimes much faster, but there is a risk that an operating system crash or an unexpected power failure could damage the database. Generally speaking, the synchronous SQLite times are for comparison against PostgreSQL (which is also synchronous) and the asynchronous SQLite times are for comparison against the asynchronous MySQL engine.</source>
          <target state="translated">すべてのテストで報告される時間は、秒単位の実時間を表します。 SQLiteでは、2つの異なる時間値が報告されます。最初の値は、フルディスク同期がオンになっているデフォルト構成のSQLiteの値です。同期をオンにすると、SQLiteは&lt;b&gt;fsync（）を&lt;/b&gt;実行します&lt;b&gt;&lt;/b&gt;重要なポイントでシステムコール（または同等のもの）を使用して、重要なデータが実際にディスクドライブの表面に書き込まれたことを確認します。データベースの更新中にオペレーティングシステムがクラッシュしたり、コンピュータの電源が予期せずオフになった場合にデータベースの整合性を保証するには、同期が必要です。 SQLiteについて2回目に報告されるのは、同期がオフになっているときです。同期をオフにすると、SQLiteの方がはるかに高速になる場合がありますが、オペレーティングシステムのクラッシュや予期しない電源障害によってデータベースが損傷する可能性があります。一般的に言って、同期SQLite時間はPostgreSQL（これも同期です）との比較用であり、非同期SQLite時間は非同期MySQLエンジンとの比較用です。</target>
        </trans-unit>
        <trans-unit id="0fc05e4c39e5e71215073020483f372e45a3d893" translate="yes" xml:space="preserve">
          <source>The total amount of free space on a b-tree page consists of the size of the unallocated region plus the total size of all freeblocks plus the number of fragmented free bytes. SQLite may from time to time reorganize a b-tree page so that there are no freeblocks or fragment bytes, all unused bytes are contained in the unallocated space region, and all cells are packed tightly at the end of the page. This is called &quot;defragmenting&quot; the b-tree page.</source>
          <target state="translated">b-tree ページの空き領域の総量は、未割り当て領域のサイズと、すべてのフリーブロックのサイズの合計と、断片化されたフリーバイトの数で構成されています。SQLite は時々 b-tree ページを再編成して、フリーブロックや断片化されたバイトがなく、未使用のバイトがすべて未割り当て領域に含まれ、すべてのセルがページの最後にしっかりと詰め込まれるようにすることがあります。これを b-tree ページの「デフラグ」と呼びます。</target>
        </trans-unit>
        <trans-unit id="460e85c11483674a3089f1a062d5d6ad1f387294" translate="yes" xml:space="preserve">
          <source>The total number of instances of the term in the entire FTS5 table.</source>
          <target state="translated">FTS5テーブル全体の用語のインスタンス数の合計。</target>
        </trans-unit>
        <trans-unit id="8456fd817ff013feb889e3e84d49e1da8d0b8117" translate="yes" xml:space="preserve">
          <source>The total number of instances of the term that appear in column $col of the FTS5 table (considering all rows).</source>
          <target state="translated">FTS5テーブルの$col列に表示される用語のインスタンスの合計数(すべての行を考慮)。</target>
        </trans-unit>
        <trans-unit id="8b23a01c6d0371374c2abef2c4b0a82ba4134902" translate="yes" xml:space="preserve">
          <source>The total number of pages in the btree for the current row</source>
          <target state="translated">現在の行のbtreeの総ページ数</target>
        </trans-unit>
        <trans-unit id="6e6d24f273b69a04a7a37a510d51811f2500b867" translate="yes" xml:space="preserve">
          <source>The total number of rows in the FTS table for which the column contains at least one instance of the phrase.</source>
          <target state="translated">その列にフレーズのインスタンスが少なくとも1つ含まれているFTSテーブルの行の総数。</target>
        </trans-unit>
        <trans-unit id="36827e0806ceb5dc326cee16a98d2a59022e566e" translate="yes" xml:space="preserve">
          <source>The total number of times the phrase appears in the column in all rows in the FTS table.</source>
          <target state="translated">FTS テーブルの全行の列にそのフレーズが出現した回数の合計。</target>
        </trans-unit>
        <trans-unit id="cf5b068f292efb4fb2def2e783aac8fbf8f0464d" translate="yes" xml:space="preserve">
          <source>The total_changes() function returns the number of row changes caused by INSERT, UPDATE or DELETE statements since the current database connection was opened. This function is a wrapper around the &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; C/C++ interface.</source>
          <target state="translated">total_changes（）関数は、現在のデータベース接続が開かれてから、INSERT、UPDATE、またはDELETEステートメントによって発生した行変更の数を返します。この関数は、&lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt; C / C ++インターフェースのラッパーです。</target>
        </trans-unit>
        <trans-unit id="e56b60d01d475c54e2abcd03a315a64862d2471f" translate="yes" xml:space="preserve">
          <source>The traditional rollback journal works by writing a copy of the original unchanged database content into a separate rollback journal file and then writing changes directly into the database file. In the event of a crash or &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;, the original content contained in the rollback journal is played back into the database file to revert the database file to its original state. The &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; occurs when the rollback journal is deleted.</source>
          <target state="translated">従来のロールバックジャーナルは、元の変更されていないデータベースコンテンツのコピーを別のロールバックジャーナルファイルに書き込み、変更をデータベースファイルに直接書き込むことで機能します。クラッシュまたは&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;が発生した場合、ロールバックジャーナルに含まれる元のコンテンツがデータベースファイルに再生され、データベースファイルが元の状態に戻ります。&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;ロールバック・ジャーナルが削除されたときに発生します。</target>
        </trans-unit>
        <trans-unit id="fa45945065730186850cef64d952ee165c9cc090" translate="yes" xml:space="preserve">
          <source>The traditional way of communicating this information was to transform a C-language pointer into a BLOB or a 64-bit integer, then move that BLOB or integer through SQLite using the usual interfaces like &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_blob()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_blob()&lt;/a&gt;, &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_blob()&lt;/a&gt; or the integer equivalents.</source>
          <target state="translated">この情報を伝達する従来の方法は、C言語のポインターをBLOBまたは64ビット整数に変換し、&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_blob（）&lt;/a&gt;、&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_blob（）&lt;/a&gt;、&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_blob（）&lt;/a&gt;または対応する整数。</target>
        </trans-unit>
        <trans-unit id="c2d0f49e1ec0a4672583f25736f97bcbd3e6ba07" translate="yes" xml:space="preserve">
          <source>The transaction command can be used to group together several SQLite commands in a safe way. You can always start transactions manually using BEGIN, of course. But if an error occurs so that the COMMIT or ROLLBACK are never run, then the database will remain locked indefinitely. Also, BEGIN does not nest, so you have to make sure no other transactions are active before starting a new one. The &quot;transaction&quot; method takes care of all of these details automatically.</source>
          <target state="translated">トランザクションコマンドを使用すると、いくつかのSQLiteコマンドを安全な方法でグループ化することができます。もちろん、BEGINを使っていつでも手動でトランザクションを開始することができます。しかし、エラーが発生してCOMMITやROLLBACKが実行されないようになってしまうと、データベースは無期限にロックされたままになってしまいます。また、BEGINはネストしないので、新しいトランザクションを開始する前に、他のトランザクションがアクティブになっていないことを確認しなければなりません。transaction &quot;メソッドはこれらの詳細を自動的に処理します。</target>
        </trans-unit>
        <trans-unit id="66431b524eb3e3d97e40f460537f3aa544382bf9" translate="yes" xml:space="preserve">
          <source>The transaction has already committed at this point so timing is not critical in the deletion of the rollback journals. The current implementation deletes a single rollback journal then unlocks the corresponding database file before proceeding to the next rollback journal. But in the future we might change this so that all rollback journals are deleted before any database files are unlocked. As long as the rollback journal is deleted before its corresponding database file is unlocked it does not matter in what order the rollback journals are deleted or the database files are unlocked.</source>
          <target state="translated">この時点ですでにトランザクションはコミットされているので、ロールバックジャーナルの削除にタイミングは重要ではありません。現在の実装では、1つのロールバックジャーナルを削除した後、対応するデータベースファイルのロックを解除してから次のロールバックジャーナルに進みます。しかし、将来的には、データベースファイルのロックが解除される前にすべてのロールバックジャーナルを削除するように変更するかもしれません。対応するデータベースファイルのロックが解除される前にロールバックジャーナルが削除されている限り、ロールバックジャーナルの削除やデータベースファイルのロック解除の順序は関係ありません。</target>
        </trans-unit>
        <trans-unit id="439b3c25010ac483338852bbf167e17f82acaecb" translate="yes" xml:space="preserve">
          <source>The transformation converts each vertex of the polygon according to the following formula:</source>
          <target state="translated">変換は、次の式に従って多角形の各頂点を変換します。</target>
        </trans-unit>
        <trans-unit id="970a22ffd83744a201d5b074bf5b2eed9b68c352" translate="yes" xml:space="preserve">
          <source>The transient table in which the result is built is created by instruction 0. Three loops then follow. The loop at instructions 5 through 10 implements the first SELECT statement. The second SELECT statement is implemented by the loop at instructions 14 through 19. Finally, a loop at instructions 22 through 25 reads the transient table and invokes the callback once for each row in the result.</source>
          <target state="translated">結果が構築される過渡的なテーブルは命令0によって作成されます。 その後、3つのループが続きます。命令5から10までのループは、最初のSELECT文を実装します。2 番目の SELECT 文は、命令 14 から 19 のループによって実装されます。最後に、命令 22 から 25 までのループがトランジェント・テーブルを読み込み、結果の各行についてコールバックを 1 回呼び出します。</target>
        </trans-unit>
        <trans-unit id="952fc2249e617c46359543a66e348109d3087d3d" translate="yes" xml:space="preserve">
          <source>The transient table in which the results of the inner SELECT are stored is created by the &lt;a href=&quot;opcode#OpenTemp&quot;&gt;OpenTemp&lt;/a&gt; instruction at 0. This opcode is used for tables that exist for the duration of a single SQL statement only. The transient cursor is always opened read/write even if the main database is read-only. The transient table is deleted automatically when the cursor is closed. The P2 value of 1 means the cursor points to a BTree index, which has no data but can have an arbitrary key.</source>
          <target state="translated">内部SELECTの結果が格納される一時テーブルは、0 の&lt;a href=&quot;opcode#OpenTemp&quot;&gt;OpenTemp&lt;/a&gt;命令によって作成されます。このオペコードは、単一のSQLステートメントの実行中にのみ存在するテーブルに使用されます。一時カーソルは、メインデータベースが読み取り専用であっても、常に読み取り/書き込みで開かれます。カーソルを閉じると、一時テーブルは自動的に削除されます。 P2値1は、カーソルがBTreeインデックスを指していることを意味します。BTreeインデックスにはデータはありませんが、任意のキーを持つことができます。</target>
        </trans-unit>
        <trans-unit id="592350be0cb11625e2bd092767c6171c56d03c65" translate="yes" xml:space="preserve">
          <source>The transition from SQLite version 3.4.2 to 3.5.0 is a major change. Every source code file in the SQLite core had to be modified, some extensively. And the change introduced some minor incompatibilities in the C interface. But we feel that the benefits of the transition from 3.4.2 to 3.5.0 far outweigh the pain of porting. The new VFS layer is now well-defined and stable and should simplify future customizations. The VFS layer, and the separable memory allocator and mutex subsystems allow a standard SQLite source code amalgamation to be used in an embedded project without change, greatly simplifying configuration management. And the resulting system is much more tolerant of highly threaded designs.</source>
          <target state="translated">SQLite バージョン 3.4.2 から 3.5.0 への移行は大きな変更です。SQLite コアのすべてのソースコードファイルを変更しなければならず、いくつかは広範囲に渡って変更されました。また、この変更に伴い、C インターフェースにいくつかのマイナーな非互換性が導入されました。しかし、3.4.2 から 3.5.0 への移行のメリットは、移植の痛みをはるかに上回ると感じています。新しい VFS レイヤーは十分に定義されており、安定しているので、将来のカスタマイズが簡単になるはずです。VFS 層と分離可能なメモリアロケータとミューテックスのサブシステムにより、標準的な SQLite ソースコードのアマルガムを変更することなく組み込みプロジェクトで使用できるようになり、設定管理が大幅に簡素化されました。また、結果として得られるシステムは、高度にスレッド化された設計に対してより寛容なものとなります。</target>
        </trans-unit>
        <trans-unit id="b0ecdf62ac64721b60f0c811bc6ae15d2a3d1b27" translate="yes" xml:space="preserve">
          <source>The trick here is the -DTCLSH=1 option. The TCL interface module for SQLite includes a &lt;b&gt;main()&lt;/b&gt; procedure that initializes a TCL interpreter and enters a command-line loop when it is compiled with -DTCLSH=1. The command above works on both Linux and Mac OS X, though one may need to adjust the library options depending on the platform and which version of TCL one is linking against.</source>
          <target state="translated">ここでの秘訣は-DTCLSH = 1オプションです。SQLiteのTCLインターフェイスモジュールには、TCLインタープリターを初期化し、-DTCLSH = 1でコンパイルするとコマンドラインループに入る&lt;b&gt;main（）&lt;/b&gt;プロシージャが含まれています。上記のコマンドはLinuxとMac OS Xの両方で機能しますが、プラットフォームやリンクしているTCLのバージョンに応じて、ライブラリオプションを調整する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="fc5d00c95debe18bbcee9e720337d19dcab11f5a" translate="yes" xml:space="preserve">
          <source>The trigger created by the previous statement is named &quot;AFTER&quot; and it is a &quot;BEFORE&quot; trigger. The &quot;AFTER&quot; token is used as an identifier instead of as a keyword, as that is the only way to parse the statement. Another example:</source>
          <target state="translated">前の文で作成されたトリガーは &quot;AFTER &quot;と名付けられており、&quot;BEFORE &quot;トリガーとなっています。AFTER &quot;トークンは、ステートメントを解析する唯一の方法であるため、キーワードとしてではなく識別子として使用されます。別の例。</target>
        </trans-unit>
        <trans-unit id="3b9b7cf0a7967eed621bbbad3863190e29c44d61" translate="yes" xml:space="preserve">
          <source>The trim(X,Y) function returns a string formed by removing any and all characters that appear in Y from both ends of X. If the Y argument is omitted, trim(X) removes spaces from both ends of X.</source>
          <target state="translated">trim(X,Y)関数は、Xの両端からYに登場するすべての文字を削除した文字列を返します。Y引数が省略された場合、trim(X)はXの両端からスペースを削除します。</target>
        </trans-unit>
        <trans-unit id="02041028dd7a37adeacbb35b1200b0b1a6b27a53" translate="yes" xml:space="preserve">
          <source>The true primary key for a rowid table (the value that is used as the key to look up rows in the underlying &lt;a href=&quot;fileformat2#btree&quot;&gt;B-tree&lt;/a&gt; storage engine) is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">ROWIDテーブルの真の主キー（基になる&lt;a href=&quot;fileformat2#btree&quot;&gt;Bツリー&lt;/a&gt;ストレージエンジンで行を検索するためのキーとして使用される値）は、&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="3f9dae6c570b0f408d716bb105a5e25850cccf9f" translate="yes" xml:space="preserve">
          <source>The truncate optimization can also be disabled at runtime using the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface. If an authorizer callback returns &lt;a href=&quot;c3ref/c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; for an &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; action code, then the DELETE operation will proceed but the truncate optimization will be bypassed and rows will be deleted one by one.</source>
          <target state="translated">トランケート最適化は、&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer（）&lt;/a&gt;インターフェースを使用して実行時に無効にすることもできます。承認者のコールバック返す場合&lt;a href=&quot;c3ref/c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt;用&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETEの&lt;/a&gt;アクションコード、そしてDELETE操作は続行されますが、切り捨て最適化がバイパスされ、行を1つずつ削除されます。</target>
        </trans-unit>
        <trans-unit id="7489f83785acf46d79dbedce76141d020e3a30b4" translate="yes" xml:space="preserve">
          <source>The truncate optimization can be permanently disabled for all queries by recompiling SQLite with the &lt;a href=&quot;compile#omit_truncate_optimization&quot;&gt;SQLITE_OMIT_TRUNCATE_OPTIMIZATION&lt;/a&gt; compile-time switch.</source>
          <target state="translated">&lt;a href=&quot;compile#omit_truncate_optimization&quot;&gt;SQLITE_OMIT_TRUNCATE_OPTIMIZATION&lt;/a&gt;コンパイル時スイッチを使用してSQLiteを再コンパイルすることにより、すべてのクエリに対して切り捨て最適化を永続的に無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="30f49567fa43c7d2e5e26ee8efe4338c93c45898" translate="yes" xml:space="preserve">
          <source>The trusted_schema setting is a per-connection boolean that determines whether or not SQL functions and virtual tables that have not been security audited are allowed to be run by views, triggers, or in expressions of the schema such as &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;, &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;DEFAULT clauses&lt;/a&gt;, &lt;a href=&quot;gencol&quot;&gt;generated columns&lt;/a&gt;, &lt;a href=&quot;expridx&quot;&gt;expression indexes&lt;/a&gt;, and/or &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;. This setting can also be controlled using the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt;,...) C-language interface.</source>
          <target state="translated">trusted_schema設定は、SQL機能とセキュリティが監査されていない仮想テーブルがビュー、トリガ、またはのようなスキーマの表現でで実行することが許可されているか否かを判断し、接続ごとのブールで&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK制約&lt;/a&gt;、&lt;a href=&quot;lang_createtable#dfltval&quot;&gt;DEFAULT句&lt;/a&gt;、&lt;a href=&quot;gencol&quot;&gt;生成されました列&lt;/a&gt;、&lt;a href=&quot;expridx&quot;&gt;式インデックス&lt;/a&gt;、および/または&lt;a href=&quot;partialindex&quot;&gt;部分インデックス&lt;/a&gt;。この設定は、&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt;、...）C言語インターフェイスを使用して制御することもできます。</target>
        </trans-unit>
        <trans-unit id="e242c8734781e20213900394ec30db10b58ee560" translate="yes" xml:space="preserve">
          <source>The two &quot;0&quot; parameters do server a purpose in some contexts, but for using these routine to print a parse tree as ASCII-art on the terminal, they should both be &quot;0&quot;.</source>
          <target state="translated">2つの &quot;0 &quot;パラメータは、いくつかの文脈で目的を果たしますが、これらのルーチンを使用して端末にASCIIアートとしてパースツリーを印刷するためには、両方とも &quot;0 &quot;でなければなりません。</target>
        </trans-unit>
        <trans-unit id="46623d6b4b79b06cc3078e791041446a91edf407" translate="yes" xml:space="preserve">
          <source>The two 4-byte big-endian integers at offsets 52 and 64 are used to manage the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; modes. If the integer at offset 52 is zero then pointer-map (ptrmap) pages are omitted from the database file and neither auto_vacuum nor incremental_vacuum are supported. If the integer at offset 52 is non-zero then it is the page number of the largest root page in the database file, the database file will contain ptrmap pages, and the mode must be either auto_vacuum or incremental_vacuum. In this latter case, the integer at offset 64 is true for incremental_vacuum and false for auto_vacuum. If the integer at offset 52 is zero then the integer at offset 64 must also be zero.</source>
          <target state="translated">オフセット52と64の2つの4バイトビッグエンディアン整数は、&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt;および&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt;モードを管理するために使用されます。オフセット52の整数がゼロの場合、データベースファイルからポインターマップ（ptrmap）ページが省略され、auto_vacuumもincremental_vacuumもサポートされません。オフセット52の整数がゼロ以外の場合、それはデータベースファイル内の最大のルートページのページ番号であり、データベースファイルにはptrmapページが含まれ、モードはauto_vacuumまたはincremental_vacuumでなければなりません。この後者の場合、オフセット64の整数は、incremental_vacuumの場合はtrue、auto_vacuumの場合はfalseです。オフセット52の整数がゼロの場合、オフセット64の整数もゼロでなければなりません。</target>
        </trans-unit>
        <trans-unit id="5d5cec8b4b21ae2b9d4802acdeb66477068dae88" translate="yes" xml:space="preserve">
          <source>The two &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; are:</source>
          <target state="translated">2つの&lt;a href=&quot;vtab#tabfunc2&quot;&gt;テーブル値関数&lt;/a&gt;は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="60d1d8fda3bbd4cfca022cc996f0d5a823d5b6ed" translate="yes" xml:space="preserve">
          <source>The two exceptions are:</source>
          <target state="translated">2つの例外があります。</target>
        </trans-unit>
        <trans-unit id="e1f0bf58781420b540ac606f0e7579a8a2be4378" translate="yes" xml:space="preserve">
          <source>The two fragments of SQL below are similar, but not entirely equivalent, as the latter will fail if the definition of window &quot;win&quot; contains a frame specification.</source>
          <target state="translated">以下の2つのSQLの断片は似ていますが、完全には等価ではないので、後者はウィンドウ &quot;win &quot;の定義にフレーム指定が含まれている場合に失敗します。</target>
        </trans-unit>
        <trans-unit id="f9a92735a6c1a485477340ad1399f41bdfef6983" translate="yes" xml:space="preserve">
          <source>The two remaining tables, %_segments and %_segdir, are used to store the full-text index. Conceptually, this index is a lookup table that maps each term (word) to the set of docid values corresponding to records in the %_content table that contain one or more occurrences of the term. To retrieve all documents that contain a specified term, the FTS module queries this index to determine the set of docid values for records that contain the term, then retrieves the required documents from the %_content table. Regardless of the schema of the FTS virtual table, the %_segments and %_segdir tables are always created as follows:</source>
          <target state="translated">残りの 2 つのテーブル、%_segments と %_segdir は、フルテキスト・インデックスを格納するために使用されます。概念的には、このインデックスは、各用語 (単語)を、その用語を 1 つ以上含む %_content テーブル内のレコードに対応する docid 値のセットにマップするルックアップ・テーブルです。指定された用語を含むすべてのドキュメントを取得するには、FTS モジュールはこのインデックスをクエリして、用語を含むレコードの docid 値のセットを決定し、%_content テーブルから必要なドキュメントを取得します。FTS 仮想テーブルのスキーマに関係なく、%_segments テーブルと %_segdir テーブルは常に以下のように作成されます。</target>
        </trans-unit>
        <trans-unit id="57eb59a7de5c1f2eacd1a8c2e2793991396d4104" translate="yes" xml:space="preserve">
          <source>The two salt value copied from the WAL file header. These values are in the byte-order of the WAL file, which might be different from the native byte-order of the machine.</source>
          <target state="translated">WALファイルのヘッダからコピーした2つのソルト値です。これらの値はWALファイルのバイト順であり、マシンのネイティブバイト順とは異なる可能性があります。</target>
        </trans-unit>
        <trans-unit id="ccc9e431ebc7fabfa6726082e51ef8838fff247f" translate="yes" xml:space="preserve">
          <source>The two-argument version of &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; accepts a pointer to the tokenizer method object even without the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;) setting if the second argument is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameter&lt;/a&gt;</source>
          <target state="translated">2引数バージョンの&lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer（）&lt;/a&gt;は、2番目の引数が&lt;a href=&quot;lang_expr#varparam&quot;&gt;バインドされたパラメーター&lt;/a&gt;である場合、&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;）設定なしでも、トークナイザーメソッドオブジェクトへのポインターを受け入れます</target>
        </trans-unit>
        <trans-unit id="6b8d35e3a824a79bc7ce101b6a6ae7997418f4f7" translate="yes" xml:space="preserve">
          <source>The two-byte integer at offset 1 gives the start of the first freeblock on the page, or is zero if there are no freeblocks.</source>
          <target state="translated">オフセット 1 の 2 バ イ ト 整数は、 ページ上の最初のフ リーブ ロ ッ ク の開始を与え ます。</target>
        </trans-unit>
        <trans-unit id="c4473928239ae1bda74a9fb4bb8276860fc5ffb5" translate="yes" xml:space="preserve">
          <source>The two-byte integer at offset 3 gives the number of cells on the page.</source>
          <target state="translated">オフセット3の2バイト整数は、ページ上のセルの数を与えます。</target>
        </trans-unit>
        <trans-unit id="a06521372b9101f2c70d6a3c29239fdaf5cbc5a7" translate="yes" xml:space="preserve">
          <source>The two-byte integer at offset 5 designates the start of the cell content area. A zero value for this integer is interpreted as 65536.</source>
          <target state="translated">オフセット 5 の 2 バイト整数は、セル内容領域の開始を指定します。この整数の値がゼロの場合は 65536 と解釈されます。</target>
        </trans-unit>
        <trans-unit id="85da2eb104aa5ac23b3d2218d186677a6dbc8b7e" translate="yes" xml:space="preserve">
          <source>The two-byte value beginning at offset 16 determines the page size of the database. For SQLite versions 3.7.0.1 (2010-08-04) and earlier, this value is interpreted as a big-endian integer and must be a power of two between 512 and 32768, inclusive. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_1.html&quot;&gt;version 3.7.1&lt;/a&gt; (2010-08-23), a page size of 65536 bytes is supported. The value 65536 will not fit in a two-byte integer, so to specify a 65536-byte page size, the value at offset 16 is 0x00 0x01. This value can be interpreted as a big-endian 1 and thought of as a magic number to represent the 65536 page size. Or one can view the two-byte field as a little endian number and say that it represents the page size divided by 256. These two interpretations of the page-size field are equivalent.</source>
          <target state="translated">オフセット16で始まる2バイトの値によって、データベースのページサイズが決まります。 SQLiteバージョン3.7.0.1（2010-08-04）以前の場合、この値はビッグエンディアン整数として解釈され、512〜32768の2のべき乗でなければなりません。 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_1.html&quot;&gt;バージョン3.7.1&lt;/a&gt;（2010-08-23）から、65536バイトのページサイズがサポートされています。値65536は2バイト整数に収まらないため、65536バイトのページサイズを指定するには、オフセット16の値は0x00 0x01です。この値はビッグエンディアン1として解釈でき、65536ページサイズを表すマジックナンバーと考えることができます。または、2バイトのフィールドをリトルエンディアンの数値として表示して、ページサイズを256で割ったものと表現することもできます。これら2つのページサイズフィールドの解釈は同等です。</target>
        </trans-unit>
        <trans-unit id="d620a0d4c1327669927184e30780adb142926606" translate="yes" xml:space="preserve">
          <source>The typedef is necessary to work around problems in certain C++ compilers.</source>
          <target state="translated">型定義は、特定のC++コンパイラの問題を回避するために必要です。</target>
        </trans-unit>
        <trans-unit id="2acee6be58c92d0d4d1c18a3c705f7ce6eca583d" translate="yes" xml:space="preserve">
          <source>The typeof(X) function returns a string that indicates the &lt;a href=&quot;datatype3&quot;&gt;datatype&lt;/a&gt; of the expression X: &quot;null&quot;, &quot;integer&quot;, &quot;real&quot;, &quot;text&quot;, or &quot;blob&quot;.</source>
          <target state="translated">typeof（X）関数は、式Xの&lt;a href=&quot;datatype3&quot;&gt;データ型&lt;/a&gt;を示す文字列を返します：「null」、「integer」、「real」、「text」、または「blob」。</target>
        </trans-unit>
        <trans-unit id="7de0eb427df1bd72e4d6981f084f01d2fd7b104b" translate="yes" xml:space="preserve">
          <source>The types and default collation sequences attached to each column must be the same for all component tables.</source>
          <target state="translated">各列に添付されているタイプとデフォルトの照合順序は、すべてのコンポーネントテーブルで同じでなければなりません。</target>
        </trans-unit>
        <trans-unit id="7a193d6baad5e9eae89c634a076cd20d9e39a2d0" translate="yes" xml:space="preserve">
          <source>The unary operator</source>
          <target state="translated">単項演算子</target>
        </trans-unit>
        <trans-unit id="5de3e6de824f9a3c28afdefed054e3e170c8e0d8" translate="yes" xml:space="preserve">
          <source>The uncompress function should uncompress data previously compressed by the compress function. In other words, for all SQLite values X, it should be true that uncompress(compress(X)) equals X. When data that has been compressed by the compress function is read from the database by FTS4, it is passed to the uncompress function before it is used.</source>
          <target state="translated">uncompress関数は、圧縮関数によって以前に圧縮されたデータの圧縮を解除しなければならない。言い換えれば、すべてのSQLite値Xに対して、uncompress(compress(X))がXに等しいことが真でなければなりません。compress関数によって圧縮されたデータがFTS4によってデータベースから読み込まれるとき、それが使用される前にuncompress関数に渡されます。</target>
        </trans-unit>
        <trans-unit id="04cb6e28b7a92f43a8ce66195a1ea7614bfeaae5" translate="yes" xml:space="preserve">
          <source>The underlying implementation can support some subset of these locking levels as long as it meets the other requirements of this paragraph. The locking level is specified as the second argument to both xLock and xUnlock. The xLock method increases the locking level to the specified locking level or higher. The xUnlock method decreases the locking level to no lower than the level specified. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt; means that the file is unlocked. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; gives permission to read the file. Multiple database connections can hold &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; at the same time. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt; is like &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; in that it is permission to read the file. But only a single connection can hold a reserved lock at any point in time. The &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt; is also permission to read the file. Other connections can continue to read the file as well, but no other connection is allowed to escalate a lock from none to shared. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt; is permission to write on the file. Only a single connection can hold an exclusive lock and no other connection can hold any lock (other than &quot;none&quot;) while one connection holds an exclusive lock. The xLock returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success, &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if it is unable to obtain the lock, or &lt;a href=&quot;rescode#ioerr_rdlock&quot;&gt;SQLITE_IOERR_RDLOCK&lt;/a&gt; if something else goes wrong. The xUnlock method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_unlock&quot;&gt;SQLITE_IOERR_UNLOCK&lt;/a&gt; for problems.</source>
          <target state="translated">基礎となる実装は、この段落の他の要件を満たしている限り、これらのロックレベルのサブセットをサポートできます。ロックレベルは、xLockとxUnlockの両方の2番目の引数として指定されます。 xLockメソッドは、ロックレベルを指定されたロックレベル以上に上げます。 xUnlockメソッドは、ロックレベルを指定されたレベル以上に下げます。&lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt;は、ファイルがロック解除されていることを意味します。&lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;は、ファイルの読み取りを許可します。複数のデータベース接続が&lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;を同時に保持できます。&lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt;はSQLITE_LOCK_SHAREDに似てい&lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;ます&lt;/a&gt;そのファイルを読み取る許可です。ただし、いつでも1つの接続だけが予約済みロックを保持できます。&lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_PENDINGは&lt;/a&gt;また、ファイルの読み取り権限です。他の接続も引き続きファイルを読み取ることができますが、ロックをなしから共有にエスカレーションすることはできません。&lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt;は、ファイルへの書き込み権限です。 1つの接続のみが排他ロックを保持でき、1つの接続が排他ロックを保持している間は、他のどの接続もロック（ &quot;none&quot;以外）を保持できません。 XLOCKを返し&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OKを&lt;/a&gt;、成功に&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;ロック、または取得できない場合&lt;a href=&quot;rescode#ioerr_rdlock&quot;&gt;SQLITE_IOERR_RDLOCKを&lt;/a&gt;他の何かがうまくいかない場合。 xUnlockメソッドは&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;成功との&lt;a href=&quot;rescode#ioerr_unlock&quot;&gt;SQLITE_IOERR_UNLOCK&lt;/a&gt;問題について。</target>
        </trans-unit>
        <trans-unit id="0269000c82eb39065f294879a620aecf2c6e833d" translate="yes" xml:space="preserve">
          <source>The underscore character (unicode codepoint 96).</source>
          <target state="translated">アンダースコア文字(ユニコードコードコードポイント96)。</target>
        </trans-unit>
        <trans-unit id="94b1d236b1b1bdea969b9f218085fccfc7fb6de3" translate="yes" xml:space="preserve">
          <source>The undo::activate command creates temporary triggers in the database that record all changes made to the tables named in the arguments.</source>
          <target state="translated">undo::activate コマンドは、引数で指定されたテーブルに加えられたすべての変更を記録する一時的なトリガーをデータベースに作成します。</target>
        </trans-unit>
        <trans-unit id="9d719f9a44e55c933ab5b5fa11156ee426d1545d" translate="yes" xml:space="preserve">
          <source>The undocumented &lt;b&gt;sqlite3_os_switch()&lt;/b&gt; interface has been removed.</source>
          <target state="translated">文書化されていない&lt;b&gt;sqlite3_os_switch（）&lt;/b&gt;インターフェースは削除されました。</target>
        </trans-unit>
        <trans-unit id="93cdbdaae25242141056e83b2feecd9f656881a8" translate="yes" xml:space="preserve">
          <source>The unicode tokenizer classifies all unicode characters as either &quot;separator&quot; or &quot;token&quot; characters. By default all space and punctuation characters, as defined by Unicode 6.1, are considered separators, and all other characters as token characters. More specifically, all unicode characters assigned to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode_character_property#General_Category&quot;&gt; general category&lt;/a&gt; beginning with &quot;L&quot; or &quot;N&quot; (letters and numbers, specifically) or to category &quot;Co&quot; (&quot;other, private use&quot;) are considered tokens. All other characters are separators.</source>
          <target state="translated">ユニコードトークナイザは、すべてのユニコード文字を「セパレータ」または「トークン」文字のいずれかに分類します。デフォルトでは、Unicode 6.1で定義されているすべてのスペースと句読点は区切り文字と見なされ、その他のすべての文字はトークン文字と見なされます。より具体的には、「L」または「N」で始まる&lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode_character_property#General_Category&quot;&gt;一般的なカテゴリ&lt;/a&gt;（具体的には文字と数字）またはカテゴリ「Co」（「その他、私的使用」）に割り当てられたすべてのUnicode文字はトークンと見なされます。他のすべての文字はセパレータです。</target>
        </trans-unit>
        <trans-unit id="8359d1281537e2db390ccb27a011cf0c1e07387b" translate="yes" xml:space="preserve">
          <source>The unicode(X) function returns the numeric unicode code point corresponding to the first character of the string X. If the argument to unicode(X) is not a string then the result is undefined.</source>
          <target state="translated">unicode(X)関数は、文字列Xの最初の文字に対応する数値のunicodeコードポイントを返します。</target>
        </trans-unit>
        <trans-unit id="b06912261f5bb2d984a2ea7d12c5ea40ed3062a1" translate="yes" xml:space="preserve">
          <source>The union-vtab is not built into SQLite. Union-vtab is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;. The source code for union-vtab is contained in a single file located at &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/unionvtab.c&quot;&gt;ext/misc/unionvtab.c&lt;/a&gt; in the SQLite source tree.</source>
          <target state="translated">union-vtabはSQLiteに組み込まれていません。Union-vtabは&lt;a href=&quot;loadext&quot;&gt;ロード可能な拡張機能&lt;/a&gt;です。union-vtabのソースコードは、SQLiteソースツリーの&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/unionvtab.c&quot;&gt;ext / misc / unionvtab.c&lt;/a&gt;にある単一のファイルに含まれています。</target>
        </trans-unit>
        <trans-unit id="70f606d5ad9373cd7360030770268b87dc04b4a8" translate="yes" xml:space="preserve">
          <source>The union-vtab is read-only. Support for writing may be added at a later time, but writing is not a part of the initial implementation.</source>
          <target state="translated">union-vtabは読み取り専用です。書き込みのサポートは後から追加されるかもしれませんが、書き込みは初期実装の一部ではありません。</target>
        </trans-unit>
        <trans-unit id="217c127b8d7dc9166357c6c852e4edb92e8bd2cc" translate="yes" xml:space="preserve">
          <source>The union-vtab shall optimize access to the underlying real tables when the constraints on the query are among forms shown below. Other kinds of constraints may be optimized in the future, but only these constraints are optimized in the initial implementation.</source>
          <target state="translated">union-vtabは、問い合わせに対する制約が以下に示す形式の中にある場合、基礎となる実テーブルへのアクセスを最適化しなければならない。将来的には他の種類の制約も最適化される可能性があるが,初期実装ではこれらの制約のみが最適化される。</target>
        </trans-unit>
        <trans-unit id="5ad25f83f6534911bf90077b4a8c2d24284bf894" translate="yes" xml:space="preserve">
          <source>The unique id (INTEGER PRIMARY KEY)</source>
          <target state="translated">固有の ID (INTEGER PRIMARY KEY)</target>
        </trans-unit>
        <trans-unit id="37c73afc15f55751239631e696091c5fb7a86756" translate="yes" xml:space="preserve">
          <source>The unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; will never use a file descriptor less than</source>
          <target state="translated">UNIX &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;は、以下のファイル記述子を決して使用しません</target>
        </trans-unit>
        <trans-unit id="ae8287e8b161fa1549dd3442fa8607f53d8dfe62" translate="yes" xml:space="preserve">
          <source>The unlikely(X) function returns the argument X unchanged. The unlikely(X) function is a no-op that the code generator optimizes away so that it consumes no CPU cycles at run-time (that is, during calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;). The purpose of the unlikely(X) function is to provide a hint to the query planner that the argument X is a boolean value that is usually not true. The unlikely(X) function is equivalent to &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood&lt;/a&gt;(X, 0.0625).</source>
          <target state="translated">likely（X）関数は、引数Xを変更せずに返します。likelyly（X）関数は、実行時（つまり、&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）の&lt;/a&gt;呼び出し中）に CPUサイクルを消費しないようにコードジェネレーターが最適化しない操作です。likelyly（X）関数の目的は、引数Xが通常は真ではないブール値であるというヒントをクエリプランナーに提供することです。likely（X）関数は、&lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;尤度&lt;/a&gt;（X、0.0625）と同等です。</target>
        </trans-unit>
        <trans-unit id="f74bf3865d4b8d380ed09cdf9682ebd8ba365f80" translate="yes" xml:space="preserve">
          <source>The unlock-notify callback is not reentrant. If an application invokes any sqlite3_xxx API functions from within an unlock-notify callback, a crash or deadlock may be the result.</source>
          <target state="translated">unlock-notifyコールバックはリエントラントではありません。アプリケーションがunlock-notifyコールバック内からsqlite3_xxx API関数を呼び出すと、クラッシュやデッドロックが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="9f10c2e623337226e56371f152fe9704c596a75e" translate="yes" xml:space="preserve">
          <source>The unlock_notify method is used access the &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; interface to the SQLite core library for testing purposes. The use of this method by applications is discouraged.</source>
          <target state="translated">unlock_notifyメソッドは、テスト目的でSQLiteコアライブラリへの&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;インターフェースにアクセスするために使用されます。アプリケーションでこのメソッドを使用することはお勧めしません。</target>
        </trans-unit>
        <trans-unit id="c0db7fcedecb648c350c1b6f11ba954f23165737" translate="yes" xml:space="preserve">
          <source>The update hook implementation must not do anything that will modify the database connection that invoked the update hook. Any actions to modify the database connection must be deferred until after the completion of the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call that triggered the update hook. Note that &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">更新フックの実装は、更新フックを呼び出したデータベース接続を変更するようなことをしてはなりません。データベース接続を変更するアクションは、更新フックをトリガーした&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;呼び出しが完了するまで延期する必要があります。&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;と&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）は&lt;/a&gt;どちらも、この段落の「変更」の意味でデータベース接続を変更することに注意してください。</target>
        </trans-unit>
        <trans-unit id="09532968164962481e11046837aaa8bacbe59ea0" translate="yes" xml:space="preserve">
          <source>The update hook implementation must not do anything that will modify the database connection that invoked the update hook. Any actions to modify the database connection must be deferred until after the completion of the &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call that triggered the update hook. Note that &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">更新フックの実装は、更新フックを呼び出したデータベース接続を変更するようなことをしてはなりません。データベース接続を変更するアクションは、更新フックをトリガーした&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;呼び出しが完了するまで延期する必要があります。&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;と&lt;a href=&quot;step&quot;&gt;sqlite3_step（）は&lt;/a&gt;どちらも、この段落の「変更」の意味でデータベース接続を変更することに注意してください。</target>
        </trans-unit>
        <trans-unit id="f188e349260d6d862bd1151de1aa0b41c96135c8" translate="yes" xml:space="preserve">
          <source>The update hook is not invoked when internal system tables are modified (i.e. sqlite_master and sqlite_sequence). The update hook is not invoked when &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are modified.</source>
          <target state="translated">内部システムテーブルが変更された場合（つまり、sqlite_masterおよびsqlite_sequence）、更新フックは呼び出されません。&lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルが変更された場合、更新フックは呼び出されません。</target>
        </trans-unit>
        <trans-unit id="d4c3b215f10d00c42f1094ebb70e270136be0ef6" translate="yes" xml:space="preserve">
          <source>The update hook is not invoked when internal system tables are modified (i.e. sqlite_master and sqlite_sequence). The update hook is not invoked when &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are modified.</source>
          <target state="translated">内部システムテーブルが変更された場合（つまり、sqlite_masterおよびsqlite_sequence）、更新フックは呼び出されません。&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルが変更された場合、更新フックは呼び出されません。</target>
        </trans-unit>
        <trans-unit id="f04fa9936d514fac1b991da703764bce23461785" translate="yes" xml:space="preserve">
          <source>The update hook is not invoked when internal system tables are modified (i.e. sqlite_sequence). The update hook is not invoked when &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are modified.</source>
          <target state="translated">内部システムテーブルが変更された場合（つまり、sqlite_sequence）、更新フックは呼び出されません。&lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルが変更された場合、更新フックは呼び出されません。</target>
        </trans-unit>
        <trans-unit id="8b14dc5637688b2512ff9a25b9caa046cb0c8fc2" translate="yes" xml:space="preserve">
          <source>The update hook is not invoked when internal system tables are modified (i.e. sqlite_sequence). The update hook is not invoked when &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are modified.</source>
          <target state="translated">内部システムテーブルが変更された場合（つまり、sqlite_sequence）、更新フックは呼び出されません。&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルが変更された場合、更新フックは呼び出されません。</target>
        </trans-unit>
        <trans-unit id="7b3d709a5bf6d8d9c48b677160252ac4da74295a" translate="yes" xml:space="preserve">
          <source>The upper bound on the database &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache size&lt;/a&gt; has traditionally defaulted to 2000 pages. SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;version 3.12.0&lt;/a&gt; also changes this default setting to be &quot;-2000&quot; which means 2000*1024 bytes, regardless of page size. So, the upper bound on the amount of memory used for the page cache is unchanged.</source>
          <target state="translated">データベース&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;キャッシュサイズ&lt;/a&gt;の上限は、伝統的にデフォルトで2000ページに設定されています。SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;バージョン3.12.0&lt;/a&gt;もこのデフォルト設定を「-2000」に変更します。これは、ページサイズに関係なく、2000 * 1024バイトを意味します。したがって、ページキャッシュに使用されるメモリ量の上限は変更されません。</target>
        </trans-unit>
        <trans-unit id="55e210be964a43ed3f79f81acfb0252d2ec508a2" translate="yes" xml:space="preserve">
          <source>The upper(X) function returns a copy of input string X in which all lower-case ASCII characters are converted to their upper-case equivalent.</source>
          <target state="translated">upper(X)関数は、入力文字列 X のコピーを返し、小文字の ASCII 文字はすべて大文字に変換されます。</target>
        </trans-unit>
        <trans-unit id="2ff3bb49a7df2e57465c506adbfbac36859c676c" translate="yes" xml:space="preserve">
          <source>The upsert above inserts the new vocabulary word &quot;jovial&quot; if that word is not already in the dictionary, or if it is already in the dictionary, it increments the counter. The &quot;count+1&quot; expression could also be written as &quot;vocabulary.count&quot;. PostgreSQL requires the second form, but SQLite accepts either.</source>
          <target state="translated">上のアップサートは、その単語がすでに辞書にない場合は新しい語彙「jovial」を挿入し、辞書にある場合はカウンターをインクリメントします。また、&quot;count+1 &quot;式は &quot;vocabulary.count &quot;と書くこともできます。PostgreSQLでは2番目の形式が必要ですが、SQLiteではどちらでも受け付けています。</target>
        </trans-unit>
        <trans-unit id="f98914d65daf1eee948f9cf4215d1bc155ef41fa" translate="yes" xml:space="preserve">
          <source>The usage of pagecache memory is somewhat harder to control in SQLite version 3.6.1, though mechanisms are planned for subsequent releases that will make controlling pagecache memory much easier. Prior to the introduction of these new mechanisms, the only way to control pagecache memory is using the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size pragma&lt;/a&gt;.</source>
          <target state="translated">SQLiteバージョン3.6.1では、ページキャッシュメモリの使用を制御するのがやや難しくなりますが、後続のリリースでは、ページキャッシュメモリの制御をより簡単にするメカニズムが計画されています。これらの新しいメカニズムが導入される前は、ページキャッシュメモリを制御する唯一の方法は、&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_sizeプラグマ&lt;/a&gt;を使用することです。</target>
        </trans-unit>
        <trans-unit id="83c37f6e9e518d22e126d6f49713b321c1f31d9b" translate="yes" xml:space="preserve">
          <source>The use of &quot;:&quot; instead of &quot;$&quot; before the name of a variable can sometimes be useful if the SQL text is enclosed in double-quotes &quot;...&quot; instead of curly-braces {...}. When the SQL is contained within double-quotes &quot;...&quot; then TCL will do the substitution of $-variables, which can lead to SQL injection if extreme care is not used. But TCL will never substitute a :-variable regardless of whether double-quotes &quot;...&quot; or curly-braces {...} are used to enclose the SQL, so the use of :-variables adds an extra measure of defense against SQL injection.</source>
          <target state="translated">変数名の前に&quot;$&quot;の代わりに&quot;:&quot;を使用することは、SQLテキストが中括弧{...}の代わりにダブルクォート&quot;...で囲まれている場合に便利な場合があります。SQLがダブルクォート「...」で囲まれている場合、TCLは$-変数の置換を行います。しかし、TCLはダブルクォート「...」や中括弧{...}がSQLを囲むために使用されているかどうかに関わらず、:-variableを代入することはありません。</target>
        </trans-unit>
        <trans-unit id="53ba0fe6640d81c27b2028a34ac03622ddcd61d3" translate="yes" xml:space="preserve">
          <source>The use of a ZIP archive to encapsulate XML files plus resources is an elegant approach to an application file format. It is clearly superior to a custom binary file format. But using an SQLite database as the container, instead of ZIP, would be more elegant still.</source>
          <target state="translated">XMLファイルとリソースをカプセル化するためのZIPアーカイブの使用は、アプリケーションファイル形式へのエレガントなアプローチです。それは明らかにカスタムバイナリファイルフォーマットよりも優れています。しかし、ZIP の代わりに SQLite データベースをコンテナとして使用することは、よりエレガントな方法です。</target>
        </trans-unit>
        <trans-unit id="62a1d7ca77be3f3b5567800401dc0bf052c2aaae" translate="yes" xml:space="preserve">
          <source>The use of a virtual machine in SQLite has been a great benefit to the library's development. The virtual machine provides a crisp, well-defined junction between the front-end of SQLite (the part that parses SQL statements and generates virtual machine code) and the back-end (the part that executes the virtual machine code and computes a result.) The virtual machine allows the developers to see clearly and in an easily readable form what SQLite is trying to do with each statement it compiles, which is a tremendous help in debugging. Depending on how it is compiled, SQLite also has the capability of tracing the execution of the virtual machine - printing each virtual machine instruction and its result as it executes.</source>
          <target state="translated">SQLite で仮想マシンを使用することは、ライブラリの開発に大きなメリットをもたらしました。仮想マシンは、SQLiteのフロントエンド(SQL文を解析して仮想マシンコードを生成する部分)とバックエンド(仮想マシンコードを実行して結果を計算する部分)の間に、明確に定義された分岐点を提供します。コンパイル方法にもよりますが、SQLite は仮想マシンの実行をトレースする機能も持っています。</target>
        </trans-unit>
        <trans-unit id="9d27ce1c6f5449fceeec41db3a7baef374e89122" translate="yes" xml:space="preserve">
          <source>The use of each of these methods will be explained in the sequel, though not in the order shown above.</source>
          <target state="translated">それぞれの使用方法については、上記の順番ではありませんが、続編で説明します。</target>
        </trans-unit>
        <trans-unit id="ac3e9e4d3a0d1a6a51dbf276370664c84cd0bc3c" translate="yes" xml:space="preserve">
          <source>The use of persistent journal mode provides a noticeable performance improvement on many systems. Of course, the drawback is that the journal files remain on the disk, using disk space and cluttering directories, long after the transaction commits. The only safe way to delete a persistent journal file is to commit a transaction with journaling mode set to DELETE:</source>
          <target state="translated">永続ジャーナルモードを使用すると、多くのシステムで顕著なパフォーマンスの向上が見られます。もちろん、欠点は、トランザクションがコミットされた後も、ジャーナルファイルがディスク上に残り、ディスクスペースを使用し、ディレクトリを乱雑にしてしまうことです。永続的ジャーナルファイルを削除する唯一の安全な方法は、ジャーナリングモードをDELETEに設定してトランザクションをコミットすることです。</target>
        </trans-unit>
        <trans-unit id="ac2e1cc15280219a058aa01cbdd9d14acc3c174c" translate="yes" xml:space="preserve">
          <source>The use of pointer-passing is an advanced technique that should be used infrequently and cautiously. Pointer-passing should not be used haphazardly or carelessly. Pointer-passing is a sharp tool that can leave deep scars if misused.</source>
          <target state="translated">ポインタパッシングの使用は高度な技術であり、使用頻度は低く、慎重に行う必要があります。ポインターパッシングは、行き当たりばったりや不注意に使用するべきではありません。ポインターパッシングは、誤って使用すると深い傷跡を残すことができる鋭いツールです。</target>
        </trans-unit>
        <trans-unit id="716439e76a7ceab1c8c91b09a2f76c73c53bf8c1" translate="yes" xml:space="preserve">
          <source>The use of subtypes on pointers prevented pointer forgery using pure SQL. But subtypes do nothing to prevent an attacker from reading the values of pointers. In other words, subtypes on pointer values prevent attacks using SQL statements like this:</source>
          <target state="translated">ポインタにサブタイプを使用することで、純粋な SQL を使用したポインタフォージェリを防ぐことができました。しかし、攻撃者がポインタの値を読み取ることを防ぐには、サブタイプは何の役にも立ちません。言い換えれば、ポインタの値に対するサブタイプは、このようなSQL文を使った攻撃を防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="d8ed607375ddfb8582a61f0a5132f51fb52c53b0" translate="yes" xml:space="preserve">
          <source>The use of the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; is recommended for all applications.</source>
          <target state="translated">&lt;a href=&quot;amalgamation&quot;&gt;融合&lt;/a&gt;の使用は、すべてのアプリケーションに推奨されます。</target>
        </trans-unit>
        <trans-unit id="789c46abbb3fc4976d476150773395da4c1e0a98" translate="yes" xml:space="preserve">
          <source>The use of the UTF-8 interfaces is preferred, as SQLite currently does all parsing using UTF-8. The UTF-16 interfaces are provided as a convenience. The UTF-16 interfaces work by converting the input text into UTF-8, then invoking the corresponding UTF-8 interface.</source>
          <target state="translated">現在 SQLite は UTF-8 を使用してすべてのパースを行っているため、UTF-8 インターフェイスの使用を推奨します。UTF-16インターフェイスは利便性のために提供されています。UTF-16 インターフェイスは、入力テキストを UTF-8 に変換してから、対応する UTF-8 インターフェイスを呼び出すことで動作します。</target>
        </trans-unit>
        <trans-unit id="7ed5c8c8570cfb3a0d0049b76c3fa5c381dc896c" translate="yes" xml:space="preserve">
          <source>The use of the error logger callback is highly recommended. The debugging information that the error logger provides has proven very useful in tracking down obscure problems that occurs with applications after they get into the field. The error logger callback has also proven useful in catching errors occasional errors that the application misses because of inconsistent checking of API return codes. Developers are encouraged to implement an error logger callback early in the development cycle in order to spot unexpected behavior quickly, and to leave the error logger callback turned on through deployment. If the error logger never finds a problem, then no harm is done. But failure to set up an appropriate error logger might compromise diagnostic capabilities later on.</source>
          <target state="translated">エラー ロガー コールバックの使用を強くお勧めします。エラーロガーが提供するデバッグ情報は、フィールドに入った後にアプリケーションで発生する不明瞭な問題を追跡するのに非常に有用であることが証明されています。また、エラーロガーコールバックは、API リターンコードの一貫性のないチェックのためにアプリケーションが見逃してしまうようなエラーをキャッチするのにも役立ちます。開発者は、開発サイクルの早い段階でエラーロガーコールバックを実装して、予期せぬ動作を素早く発見し、デプロイ時までエラーロガーコールバックをオンにしておくことをお勧めします。エラーロガーが問題を発見しなければ、何の問題もありません。しかし、適切なエラー ロガーをセットアップしないと、後で診断機能が損なわれる可能性があります。</target>
        </trans-unit>
        <trans-unit id="a848d528e6bb7ea17daf03362baa03e736e192f7" translate="yes" xml:space="preserve">
          <source>The use of the standardized speedtest1.c workload and cachegrind has enabled significant performance improvement. However, it is important to recognize the limitations of this approach:</source>
          <target state="translated">標準化された speedtest1.c ワークロードと cachegrind を使用することで、大幅なパフォーマンスの向上が可能になりました。しかし、このアプローチの限界を認識することが重要です。</target>
        </trans-unit>
        <trans-unit id="fbf470196dd9e32d7a6c5961b17698cfadfdbb60" translate="yes" xml:space="preserve">
          <source>The use of variable-length records by SQLite has a number of advantages. It results in smaller database files, obviously. It also makes the database run faster, since there is less information to move to and from disk. And, the use of variable-length records makes it possible for SQLite to employ manifest typing instead of static typing.</source>
          <target state="translated">SQLite で可変長レコードを使用することには多くの利点があります。その結果、データベースファイルが小さくなります。また、ディスクとの間で移動する情報が少なくて済むので、データベースの実行速度も速くなります。また、可変長レコードを使用することで、SQLiteでは静的型付けの代わりにマニフェスト型付けを使用することが可能になります。</target>
        </trans-unit>
        <trans-unit id="f495ec4a4bf3743c12d1f50425c742888001cad3" translate="yes" xml:space="preserve">
          <source>The user_version pragma will to get or set the value of the user-version integer at offset 60 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;. The user-version is an integer that is available to applications to use however they want. SQLite makes no use of the user-version itself.</source>
          <target state="translated">user_versionプラグマは、&lt;a href=&quot;fileformat2#database_header&quot;&gt;データベースヘッダーの&lt;/a&gt;オフセット60にあるユーザーバージョン整数の値を取得または設定します。user-versionは整数であり、アプリケーションが必要に応じて使用できます。SQLiteはユーザーバージョン自体を使用しません。</target>
        </trans-unit>
        <trans-unit id="81fbf2e7b21c5d201e92f96deae7ccf53bbeeddc" translate="yes" xml:space="preserve">
          <source>The usermerge option is similar to the automerge and crisismerge options. It is the minimum number of b-tree segments that will be merged together by a 'merge' command with a positive parameter. For example:</source>
          <target state="translated">usermerge オプションは automerge および crisismerge オプションに似ています。これは、正のパラメータを指定した 'merge' コマンドによってマージされる b-tree セグメントの最小数です。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="7380a4170d0b89318a355604d7dab9b3376f5f00" translate="yes" xml:space="preserve">
          <source>The usual &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; commands work on an R*Tree index just like on regular tables. So to insert some data into our sample R*Tree index, we can do something like this:</source>
          <target state="translated">通常の&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;、&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;、および&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;コマンドは、通常のテーブルと同じようにR * Treeインデックスで機能します。したがって、サンプルのR * Treeインデックスにデータを挿入するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="7245ad2ccb3652b74420857f1f81436b120932a2" translate="yes" xml:space="preserve">
          <source>The usual case is that sqlite3_serialize() copies the serialization of the database into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; and returns a pointer to that memory. The caller is responsible for freeing the returned value to avoid a memory leak. However, if the F argument contains the SQLITE_SERIALIZE_NOCOPY bit, then no memory allocations are made, and the sqlite3_serialize() function will return a pointer to the contiguous memory representation of the database that SQLite is currently using for that database, or NULL if the no such contiguous memory representation of the database exists. A contiguous memory representation of the database will usually only exist if there has been a prior call to &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize(D,S,...)&lt;/a&gt; with the same values of D and S. The size of the database is written into *P even if the SQLITE_SERIALIZE_NOCOPY bit is set but no contiguous copy of the database exists.</source>
          <target state="translated">通常の場合、sqlite3_serialize（）はデータベースのシリアル化を&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;から取得したメモリにコピーし、そのメモリへのポインタを返します。呼び出し元は、メモリリークを回避するために戻り値を解放する責任があります。ただし、F引数にSQLITE_SERIALIZE_NOCOPYビットが含まれている場合、メモリの割り当ては行われず、sqlite3_serialize（）関数は、SQLiteが現在そのデータベースに使用しているデータベースの連続メモリ表現へのポインタを返します。このようなデータベースの連続したメモリ表現が存在します。データベースの連続したメモリ表現は、通常、&lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize（D、S、...）&lt;/a&gt;への以前の呼び出しがあった場合にのみ存在します。SQLITE_SERIALIZE_NOCOPYビットが設定されていてもデータベースの連続したコピーが存在しない場合でも、データベースのサイズは* Pに書き込まれます。</target>
        </trans-unit>
        <trans-unit id="69659aa2e08fcc19f80f4fa144bcabaf8c7b3ed8" translate="yes" xml:space="preserve">
          <source>The usual case is that sqlite3_serialize() copies the serialization of the database into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; and returns a pointer to that memory. The caller is responsible for freeing the returned value to avoid a memory leak. However, if the F argument contains the SQLITE_SERIALIZE_NOCOPY bit, then no memory allocations are made, and the sqlite3_serialize() function will return a pointer to the contiguous memory representation of the database that SQLite is currently using for that database, or NULL if the no such contiguous memory representation of the database exists. A contiguous memory representation of the database will usually only exist if there has been a prior call to &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize(D,S,...)&lt;/a&gt; with the same values of D and S. The size of the database is written into *P even if the SQLITE_SERIALIZE_NOCOPY bit is set but no contiguous copy of the database exists.</source>
          <target state="translated">通常の場合、sqlite3_serialize（）はデータベースのシリアル化を&lt;a href=&quot;free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;から取得したメモリにコピーし、そのメモリへのポインタを返します。呼び出し元は、メモリリークを回避するために戻り値を解放する責任があります。ただし、F引数にSQLITE_SERIALIZE_NOCOPYビットが含まれている場合、メモリの割り当ては行われず、sqlite3_serialize（）関数は、SQLiteが現在そのデータベースに使用しているデータベースの連続メモリ表現へのポインタを返します。このようなデータベースの連続したメモリ表現が存在します。データベースの連続したメモリ表現は、通常、&lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize（D、S、...）&lt;/a&gt;への以前の呼び出しがあった場合にのみ存在します。SQLITE_SERIALIZE_NOCOPYビットが設定されていてもデータベースの連続したコピーが存在しない場合でも、データベースのサイズは* Pに書き込まれます。</target>
        </trans-unit>
        <trans-unit id="2878cf43bc017da229299a9eeb8ee3b6c95340de" translate="yes" xml:space="preserve">
          <source>The usual case is that the entire database file is checked. However, if the argument is</source>
          <target state="translated">通常は、データベースファイル全体をチェックする場合です。しかし、引数が</target>
        </trans-unit>
        <trans-unit id="0fc6512389ff21ec6ba0d889f8647d34fa1771be" translate="yes" xml:space="preserve">
          <source>The usual output is an SQL script that will transform database1.sqlite (the &quot;source&quot; database) into database2.sqlite (the &quot;destination&quot; database). This behavior can be altered using command-line switches:</source>
          <target state="translated">通常の出力は、database1.sqlite(&quot;ソース &quot;データベース)をdatabase2.sqlite(&quot;デスティネーション &quot;データベース)に変換するSQLスクリプトです。この動作はコマンドラインのスイッチを使って変更することができます。</target>
        </trans-unit>
        <trans-unit id="ebe7d136ea02a608354f8bf5123226386a80e2bf" translate="yes" xml:space="preserve">
          <source>The usual usage pattern for an sqlite3_changegroup object is as follows:</source>
          <target state="translated">sqlite3_changegroupオブジェクトの通常の使用パターンは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="f006b61943f366c81b0414ad0d7a764b14620096" translate="yes" xml:space="preserve">
          <source>The usual way of storing a date in a database table is as a single field, as either a unix timestamp, a julian day number, or an ISO-8601 dates string. But some application store dates as three separate fields for the year, month, and day.</source>
          <target state="translated">データベースのテーブルに日付を格納する通常の方法は、単一のフィールドとして、Unixタイムスタンプ、ジュリアンデイ番号、ISO-8601日付文字列のいずれかを使用します。しかし、アプリケーションによっては、年、月、日の3つの独立したフィールドとして日付を保存するものもあります。</target>
        </trans-unit>
        <trans-unit id="e446494ebae458b5aea2681dfd535005a9fb5001" translate="yes" xml:space="preserve">
          <source>The value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1493e5c49d89b37715d26870b14178bb98eff899" translate="yes" xml:space="preserve">
          <source>The value extracted is stored in register P3.</source>
          <target state="translated">抽出された値はレジスタP3に格納される。</target>
        </trans-unit>
        <trans-unit id="b67d4fe7f5972a61b5da20c2ef9a98c84328f043" translate="yes" xml:space="preserve">
          <source>The value of NEW.rowid is undefined in a BEFORE INSERT trigger in which the rowid is not explicitly set to an integer.</source>
          <target state="translated">NEW.rowidの値は、rowidが明示的に整数に設定されていないBEFORE INSERTトリガでは未定義です。</target>
        </trans-unit>
        <trans-unit id="6ccbeb6aa89a69300ffd6eb190f7535f8bc566cf" translate="yes" xml:space="preserve">
          <source>The value of SQLITE_THREADSAFE can be determined at run-time using the &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; interface.</source>
          <target state="translated">SQLITE_THREADSAFEの値は、&lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe（）&lt;/a&gt;インターフェイスを使用して実行時に決定できます。</target>
        </trans-unit>
        <trans-unit id="d5ab5daf4c7771df3bc76b4527132dffd8bea934" translate="yes" xml:space="preserve">
          <source>The value of an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column must always be a non-NULL integer. The PRIMARY KEY columns of a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table are also required to be non-NULL.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列の値は、常にNULL以外の整数でなければなりません。&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルのPRIMARY KEY列も非NULLである必要があります。</target>
        </trans-unit>
        <trans-unit id="94d5eebfcf21e24cf605bf00db4a0642798783cd" translate="yes" xml:space="preserve">
          <source>The value of the N parameter to these interfaces should be non-negative. Future enhancements may make use of negative N values to define new kinds of function caching behavior.</source>
          <target state="translated">これらのインタフェースに対する N パラメータの値は負ではありません。将来の拡張では、新しい種類の関数キャッシュ動作を定義するために、負の N 値を使用することができるかもしれません。</target>
        </trans-unit>
        <trans-unit id="cc7bdc3b5bd50bd43536e1eeee3d4c188a48e335" translate="yes" xml:space="preserve">
          <source>The value of the change counter is copied to the database handle change counter (returned by subsequent calls to sqlite3_changes()). Then the VMs internal change counter resets to 0. This is used by trigger programs.</source>
          <target state="translated">変更カウンタの値は、データベース・ハンドルの変更カウンタにコピーされます(後続のsqlite3_changes()の呼び出しによって返されます)。これはトリガプログラムで使用されます。</target>
        </trans-unit>
        <trans-unit id="4a5b194cd44f85aade16e1c37ccac8a115177304" translate="yes" xml:space="preserve">
          <source>The value returned by sqlite3_backup_finish is &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if no sqlite3_backup_step() errors occurred, regardless or whether or not sqlite3_backup_step() completed. If an out-of-memory condition or IO error occurred during any prior sqlite3_backup_step() call on the same &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object, then sqlite3_backup_finish() returns the corresponding &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">sqlite3_backup_step（）が完了したかどうかに関係なく、sqlite3_backup_step（）エラーが発生しなかった場合、sqlite3_backup_finishが&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;返す&lt;/a&gt;値はSQLITE_OKです。同じ&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt;オブジェクトに対する以前のsqlite3_backup_step（）呼び出し中にメモリ不足状態またはIOエラーが発生した場合、sqlite3_backup_finish（）は対応する&lt;a href=&quot;rescode&quot;&gt;エラーコードを&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="a8b2a631496d509ee2b275504f995fbe8e4ff87c" translate="yes" xml:space="preserve">
          <source>The value returned by sqlite3_backup_finish is &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if no sqlite3_backup_step() errors occurred, regardless or whether or not sqlite3_backup_step() completed. If an out-of-memory condition or IO error occurred during any prior sqlite3_backup_step() call on the same &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object, then sqlite3_backup_finish() returns the corresponding &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">sqlite3_backup_step（）が完了したかどうかに関係なく、sqlite3_backup_step（）エラーが発生しなかった場合、sqlite3_backup_finishが&lt;a href=&quot;../rescode#ok&quot;&gt;返す&lt;/a&gt;値はSQLITE_OKです。同じ&lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt;オブジェクトに対する以前のsqlite3_backup_step（）呼び出し中にメモリ不足状態またはIOエラーが発生した場合、sqlite3_backup_finish（）は対応する&lt;a href=&quot;../rescode&quot;&gt;エラーコードを&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="bc51fa501b0d744e2b8200daac75839a3f391d4e" translate="yes" xml:space="preserve">
          <source>The values &lt;b&gt;M&lt;/b&gt; and &lt;b&gt;n&lt;/b&gt; are properties of the application. If an application is constructed in such a way that both &lt;b&gt;M&lt;/b&gt; and &lt;b&gt;n&lt;/b&gt; are known, or at least have known upper bounds, and if the application uses the &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; memory allocator and is provided with &lt;b&gt;N&lt;/b&gt; bytes of available memory space using &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt; then Robson proves that no memory allocation request will ever fail within the application. To put this another way, the application developer can select a value for &lt;b&gt;N&lt;/b&gt; that will guarantee that no call to any SQLite interface will ever return &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;. The memory pool will never become so fragmented that a new memory allocation request cannot be satisfied. This is an important property for applications where a software fault could cause injury, physical harm, or loss of irreplaceable data.</source>
          <target state="translated">値&lt;b&gt;M&lt;/b&gt;と&lt;b&gt;n&lt;/b&gt;はアプリケーションのプロパティです。アプリケーションが&lt;b&gt;M&lt;/b&gt;と&lt;b&gt;nの&lt;/b&gt;両方が既知であるか、または少なくとも既知の上限があるように構築されており、アプリケーションが&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5メモリア&lt;/a&gt;ロケーターを使用し、SQLITE_CONFIG_HEAPを使用して&lt;b&gt;N&lt;/b&gt;バイトの利用可能なメモリスペースが提供されている&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;場合&lt;/a&gt;、Robsonは次のことを証明します。アプリケーション内でメモリ割り当て要求が失敗することはありません。&lt;a href=&quot;rescode#nomem&quot;&gt;言い換える&lt;/a&gt;と、アプリケーション開発者は&lt;b&gt;Nの&lt;/b&gt;値を選択して、SQLiteインターフェイスへの呼び出しがSQLITE_NOMEMを返さないことを保証できます。。メモリプールは、新しいメモリ割り当て要求を満たすことができないほど断片化されることはありません。これは、ソフトウェアの障害により、怪我、身体的危害、またはかけがえのないデータの損失が発生する可能性があるアプリケーションにとって重要な特性です。</target>
        </trans-unit>
        <trans-unit id="22f534f2da25c6b7c05e8783b8e5bfbbc59c87e8" translate="yes" xml:space="preserve">
          <source>The values for each column in the record immediately follow the header. For serial types 0, 8, 9, 12, and 13, the value is zero bytes in length. If all columns are of these types then the body section of the record is empty.</source>
          <target state="translated">レコード内の各列の値は、ヘッダの直後に続きます。シリアルタイプ 0,8,9,12,13 の場合、値の長さはゼロバイトです。すべての列がこれらのタイプの場合、レコードのボディセクションは空です。</target>
        </trans-unit>
        <trans-unit id="d128efd1de498da70d20d12d2513201d5001c97a" translate="yes" xml:space="preserve">
          <source>The values for each column of the row are stored in these columns. The &quot;.recover&quot; command creates the lost_and_found table with as many columns as required by the longest orphaned row.</source>
          <target state="translated">これらの列には、その行の各列の値が格納される。.recover&quot; コマンドは、孤児となった最長の行が必要とする数だけの列を持つ lost_and_found テーブルを作成する。</target>
        </trans-unit>
        <trans-unit id="fd6b2ec514a48d20f0372d7449abd69ec8081347" translate="yes" xml:space="preserve">
          <source>The values placed in the sqlite_stat1 table by an approximate ANALYZE are not exactly the same as what would be computed by an unrestricted analysis. But they are usually close enough. The index statistics in the sqlite_stat1 table are approximations in any case, so the fact that the results of an approximate ANALYZE are slightly different from a traditional full scan ANALYZE has little practical impact. It is possible to construct a pathological case where an approximate ANALYZE is noticeably inferior to a full-scan ANALYZE, but such cases rare in real-world problems.</source>
          <target state="translated">sqlite_stat1のテーブルに近似ANALYZEで配置された値は、無制限解析で計算されたものと全く同じではありません。しかし、通常は十分に近いです。sqlite_stat1テーブルのインデックス統計量はいずれの場合も近似値ですので、近似ANALYZEの結果が従来のフルスキャンANALYZEとわずかに異なるという事実は、実用的な影響はほとんどありません。近似ANALYZEがフルスキャンANALYZEよりも明らかに劣るような病理学的なケースを構築することは可能ですが、そのようなケースは実世界の問題ではまれです。</target>
        </trans-unit>
        <trans-unit id="61332fb4ed04580474ae395b4c8e0cfc53138b43" translate="yes" xml:space="preserve">
          <source>The values returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; do not include the zero terminators at the end of the string. For clarity: the values returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; are the number of bytes in the string, not the number of characters.</source>
          <target state="translated">返される値&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes（）&lt;/a&gt;と&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16（）は&lt;/a&gt;、文字列の末尾にゼロターミネータを含んでいません。わかりやすくするために、&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes（）&lt;/a&gt;および&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16（）&lt;/a&gt;によって返される値は、文字数ではなく、文字列のバイト数です。</target>
        </trans-unit>
        <trans-unit id="56d75a71d4310cb50689d453693c130f5e211175" translate="yes" xml:space="preserve">
          <source>The values returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; do not include the zero terminators at the end of the string. For clarity: the values returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; are the number of bytes in the string, not the number of characters.</source>
          <target state="translated">返される値&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes（）&lt;/a&gt;と&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16（）は&lt;/a&gt;、文字列の末尾にゼロターミネータを含んでいません。わかりやすくするために、&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes（）&lt;/a&gt;および&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16（）&lt;/a&gt;によって返される値は、文字数ではなく、文字列のバイト数です。</target>
        </trans-unit>
        <trans-unit id="9a34a413d802292386ca8ed35bad50613a2e40f9" translate="yes" xml:space="preserve">
          <source>The values returned by sqlite3_errcode() and/or sqlite3_extended_errcode() might change with each API call. Except, there are some interfaces that are guaranteed to never change the value of the error code. The error-code preserving interfaces are:</source>
          <target state="translated">sqlite3_errcode()やsqlite3_extended_errcode()によって返される値はAPIコールごとに変わるかもしれません。ただし、エラーコードの値を変更しないことが保証されているインタフェースがいくつかあります。エラーコードを保持するインターフェースは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="af0883b91a2c32edd6bb6e8adf9674294de318ba" translate="yes" xml:space="preserve">
          <source>The variable &lt;b&gt;$x&lt;/b&gt; is set by the above code to</source>
          <target state="translated">変数&lt;b&gt;$ x&lt;/b&gt;は、上記のコードによって次のように設定されます</target>
        </trans-unit>
        <trans-unit id="e81b821adc588b80803661eb9435ef7daf5e77e6" translate="yes" xml:space="preserve">
          <source>The variable i in the previous expression varies between 0 and 9. Conceptually, the index space is divided into 10 uniform buckets and the samples are the middle row from each bucket.</source>
          <target state="translated">前の式の変数iは0から9の間で変化する。概念的には、インデックス空間を10個の均一なバケットに分割し、各バケットから中段の行をサンプルとしています。</target>
        </trans-unit>
        <trans-unit id="e46969b4d5144ef5a3ecc1c7c5e86080c0dd5e34" translate="yes" xml:space="preserve">
          <source>The various &lt;b&gt;sqlite_stat&lt;/b&gt;</source>
          <target state="translated">さまざまな&lt;b&gt;sqlite_stat&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4ea0a2ad541e7dfd246d5e09a98161b66d983211" translate="yes" xml:space="preserve">
          <source>The various SQLite Archive Archive commands are implemented using SQL statements. Application developers can easily add SQLite Archive Archive reading and writing support to their own projects by running the appropriate SQL.</source>
          <target state="translated">様々な SQLite Archive コマンドは SQL 文を使用して実装されています。アプリケーション開発者は、適切な SQL を実行することで、SQLite Archive の読み書きサポートを自分のプロジェクトに簡単に追加することができます。</target>
        </trans-unit>
        <trans-unit id="22f8ca9c7ec1168dbb45b57fd3ebfbf3e9d60926" translate="yes" xml:space="preserve">
          <source>The various assert()-like macros behave differently according to how SQLite is built.</source>
          <target state="translated">assert()のような様々なマクロは、SQLite の構築方法によって挙動が異なります。</target>
        </trans-unit>
        <trans-unit id="8789a3da4f75d5b0392ef189d216e2c9312d1546" translate="yes" xml:space="preserve">
          <source>The various unix VFSes differ only in the way they handle file locking - they share most of their implementation in common with one another and are all located in the same SQLite source file: &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt;. Note that except for &quot;unix&quot; and &quot;unix-excl&quot;, the various unix VFSes all use incompatible locking implementations. If two processes are accessing the same SQLite database using different unix VFSes, they may not see each others locks and may end up interfering with one another, resulting in database corruption. The &quot;unix-none&quot; VFS in particular does no locking at all and will easily result in database corruption if used by two or more database connections at the same time. Programmers are encouraged to use only &quot;unix&quot; or &quot;unix-excl&quot; unless there is a compelling reason to do otherwise.</source>
          <target state="translated">さまざまなUNIX VFSは、ファイルロックの処理方法のみが異なります。これらは、実装のほとんどを互いに共有しており、すべて同じSQLiteソースファイル&lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/os_unix.c&quot;&gt;os_unix.cにあり&lt;/a&gt;ます。 「unix」と「unix-excl」を除いて、さまざまなUNIX VFSはすべて互換性のないロック実装を使用しています。 2つのプロセスが異なるUNIX VFSを使用して同じSQLiteデータベースにアクセスしている場合、お互いのロックが認識されず、相互に干渉してデータベースが破損する可能性があります。特に「unix-none」VFSはロックをまったく行わないため、2つ以上のデータベース接続で同時に使用すると、データベースが破損しやすくなります。プログラマーは「unix」または「unix-excl」のみを使用することをお勧めしますそうでなければやむを得ない理由がない限り。</target>
        </trans-unit>
        <trans-unit id="c5ffe5eea46cbcd5a1594ce73f72bf62a68d39e3" translate="yes" xml:space="preserve">
          <source>The versions of SQLite that come preinstalled on Apple Mac OS X computers contain a version of SQLite that has been extended to use alternative locking strategies that work on all network filesystems that Apple supports. These extensions used by Apple work great as long as all processes are accessing the database file in the same way. Unfortunately, the locking mechanisms do not exclude one another, so if one process is accessing a file using (for example) AFP locking and another process (perhaps on a different machine) is using dot-file locks, the two processes might collide because AFP locks do not exclude dot-file locks or vice versa.</source>
          <target state="translated">Apple Mac OS XコンピュータにプリインストールされているSQLiteのバージョンには、Appleがサポートしているすべてのネットワークファイルシステムで動作する代替ロック戦略を使用するように拡張されたSQLiteのバージョンが含まれています。Appleが使用しているこれらの拡張機能は、すべてのプロセスが同じ方法でデータベースファイルにアクセスしている限り、非常に有効に機能します。不幸なことに、ロック機構は互いに除外されないので、あるプロセスが(例えば)AFPロックを使用してファイルにアクセスしていて、別のプロセス(おそらく別のマシン上で)がドットファイルロックを使用している場合、AFPロックはドットファイルロックを除外しないので、2つのプロセスが衝突する可能性がありますし、逆もまた然りです。</target>
        </trans-unit>
        <trans-unit id="27a68965a58736f6647ab050fea465e20bf8ddef" translate="yes" xml:space="preserve">
          <source>The versions of the SQLite amalgamation that are supplied on the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download page&lt;/a&gt; are normally adequate for most users. However, some projects may want or need to build their own amalgamations. A common reason for building a custom amalgamation is in order to use certain &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; to customize the SQLite library. Recall that the SQLite amalgamation contains a lot of C-code that is generated by auxiliary programs and scripts. Many of the compile-time options effect this generated code and must be supplied to the code generators before the amalgamation is assembled. The set of compile-time options that must be passed into the code generators can vary from one release of SQLite to the next, but at the time of this writing (circa SQLite 3.6.20, 2009-11-04) the set of options that must be known by the code generators includes:</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;ダウンロードページで&lt;/a&gt;提供されるSQLiteアマルガムのバージョンは、通常、ほとんどのユーザーに適しています。ただし、一部のプロジェクトでは、独自の統合を構築する必要がある場合があります。カスタム統合を構築する一般的な理由は、特定の&lt;a href=&quot;compile&quot;&gt;コンパイル時オプション&lt;/a&gt;を使用するためですSQLiteライブラリをカスタマイズします。SQLiteの統合には、補助プログラムとスクリプトによって生成された多くのCコードが含まれていることを思い出してください。コンパイル時のオプションの多くはこの生成されたコードに影響を与えるため、融合をアセンブルする前にコードジェネレーターに提供する必要があります。コードジェネレーターに渡す必要があるコンパイル時オプションのセットは、SQLiteのリリースごとに異なる可能性がありますが、この記事の執筆時点では（SQLite 3.6.20、2009年11月4日頃）オプションのセットはコードジェネレーターが認識しなければならないものは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="d08eefb01c3e7948c8ed07ad520422cff4b9225d" translate="yes" xml:space="preserve">
          <source>The very name &quot;Structured Query Language&quot; tells us that SQL should support nested queries. And, in fact, two different kinds of nesting are supported. Any SELECT statement that returns a single-row, single-column result can be used as a term in an expression of another SELECT statement. And, a SELECT statement that returns a single-column, multi-row result can be used as the right-hand operand of the IN and NOT IN operators. We will begin this section with an example of the first kind of nesting, where a single-row, single-column SELECT is used as a term in an expression of another SELECT. Here is our example:</source>
          <target state="translated">構造化されたクエリ言語」という名前は、SQLがネストされたクエリをサポートしなければならないことを教えてくれます。そして実際には、2種類の異なる入れ子がサポートされています。1行1列の結果を返すSELECT文は、別のSELECT文の式の項として使用することができます。また、1列で複数行の結果を返すSELECT文は、INおよびNOT IN演算子の右辺のオペランドとして使用することができます。このセクションでは、1行1列のSELECTが別のSELECT文の式の項として使用される、最初の種類の入れ子の例から始めます。以下に例を示します。</target>
        </trans-unit>
        <trans-unit id="20c4a011c8e3b37249d4469eb52a0ff7a1d9c48e" translate="yes" xml:space="preserve">
          <source>The vfs query parameter causes the database connection to be opened using the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; called</source>
          <target state="translated">vfsクエリパラメータにより、呼び出された&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;を使用してデータベース接続が開かれます</target>
        </trans-unit>
        <trans-unit id="7fc9c565eeb1c6123557989180ff5a163d06934e" translate="yes" xml:space="preserve">
          <source>The view to drop is identified by the view-name and optional schema-name specified as part of the DROP VIEW statement. This reference is resolved using the standard procedure for &lt;a href=&quot;lang_naming&quot;&gt;object resolution&lt;/a&gt;.</source>
          <target state="translated">削除するビューは、DROP VIEWステートメントの一部として指定されたビュー名とオプションのスキーマ名によって識別されます。この参照は、&lt;a href=&quot;lang_naming&quot;&gt;オブジェクト解決の&lt;/a&gt;標準手順を使用して解決されます。</target>
        </trans-unit>
        <trans-unit id="3b2c6960eedc019bcf13fce258370b16a245ba89" translate="yes" xml:space="preserve">
          <source>The view v1 cannot be &lt;a href=&quot;optoverview#flattening&quot;&gt;flattened&lt;/a&gt; because it is DISTINCT. It must instead be run as a subquery with the results being stored in a transient table, then the join is performed between t2 and the transient table. The push-down optimization pushes down the &quot;b BETWEEN 10 AND 20&quot; term into the view. This makes the transient table smaller, and helps the subquery to run faster if there is an index on t1.b. The resulting evaluation is like this:</source>
          <target state="translated">ビューv1 はDISTINCTであるため、&lt;a href=&quot;optoverview#flattening&quot;&gt;フラット化&lt;/a&gt;できません。代わりに、結果が一時テーブルに格納されるサブクエリとして実行する必要があります。その後、t2と一時テーブルの間で結合が実行されます。プッシュダウン最適化は、「b BETWEEN 10 AND 20」という用語をビューにプッシュダウンします。これにより、一時テーブルが小さくなり、t1.bにインデックスがある場合、サブクエリの実行が速くなります。結果の評価は次のようになります。</target>
        </trans-unit>
        <trans-unit id="ce6b93653a867ff824a137b275a2d8a4b5929427" translate="yes" xml:space="preserve">
          <source>The virtual machine itself is entirely contained in a single source file &lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c&lt;/a&gt;. The &lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.h&quot;&gt;vdbe.h&lt;/a&gt; header file defines an interface between the virtual machine and the rest of the SQLite library and &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeInt.h&quot;&gt;vdbeInt.h&lt;/a&gt; which defines structures and interfaces that are private the virtual machine itself. Various other &lt;b&gt;vdbe*.c&lt;/b&gt; files are helpers to the virtual machine. The &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeaux.c&quot;&gt;vdbeaux.c&lt;/a&gt; file contains utilities used by the virtual machine and interface modules used by the rest of the library to construct VM programs. The &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c&lt;/a&gt; file contains external interfaces to the virtual machine such as the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_int()&lt;/a&gt; and &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. Individual values (strings, integer, floating point numbers, and BLOBs) are stored in an internal object named &quot;Mem&quot; which is implemented by &lt;a href=&quot;https://sqlite.org/src/file/src/vdbemem.c&quot;&gt;vdbemem.c&lt;/a&gt;.</source>
          <target state="translated">仮想マシン自体は、単一のソースファイル&lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.cに&lt;/a&gt;完全に含まれています。&lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.h&quot;&gt;vdbe.hの&lt;/a&gt;ヘッダファイルは、仮想マシンとのSQLiteライブラリの残りの部分との間のインタフェース定義&lt;a href=&quot;https://sqlite.org/src/file/src/vdbeInt.h&quot;&gt;vdbeInt.h&lt;/a&gt;仮想マシン自体プライベートである構造とインタフェースを定義します。他のさまざまな&lt;b&gt;vdbe * .c&lt;/b&gt;ファイルは、仮想マシンのヘルパーです。&lt;a href=&quot;https://sqlite.org/src/file/src/vdbeaux.c&quot;&gt;vdbeaux.cの&lt;/a&gt;ファイルは、VMのプログラムを構築するために、ライブラリの残りの部分で使用される仮想マシンとのインタフェースモジュールで使用されるユーティリティが含まれています。&lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.cの&lt;/a&gt;ファイルは以下のような仮想マシンに外部インターフェース含ま&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_int（）&lt;/a&gt;と&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）を&lt;/a&gt;。個々の値（文字列、整数、浮動小数点数、BLOB）は、&lt;a href=&quot;https://sqlite.org/src/file/src/vdbemem.c&quot;&gt;vdbemem.c&lt;/a&gt;によって実装される「Mem」という名前の内部オブジェクトに格納されます。</target>
        </trans-unit>
        <trans-unit id="00bcd77d6dec3bc1a5f96c0e0f3985aefbea69f9" translate="yes" xml:space="preserve">
          <source>The virtual table contains an xShadowName method.</source>
          <target state="translated">仮想テーブルには xShadowName メソッドが含まれています。</target>
        </trans-unit>
        <trans-unit id="aba94b8d1e25fe7120c464dc013b1d34868edb66" translate="yes" xml:space="preserve">
          <source>The virtual table mechanism allows an application to publish interfaces that are accessible from SQL statements as if they were tables. SQL statements can do almost anything to a virtual table that they can do to a real table, with the following exceptions:</source>
          <target state="translated">仮想テーブルのメカニズムにより、アプリケーションはSQL文からアクセス可能なインターフェースを、あたかもテーブルであるかのように公開することができます。SQL ステートメントは、仮想テーブルに対して、実際のテーブルに対してできることと同じように、以下の例外を除いてほとんどすべてのことを行うことができます。</target>
        </trans-unit>
        <trans-unit id="7616eb3efb8cfc2b544466ae9f36f2a81289f276" translate="yes" xml:space="preserve">
          <source>The virtual table will return one row of output for each token in the input string. The &quot;token&quot; column is the text of the token. The &quot;start&quot; and &quot;end&quot; columns are the byte offset to the beginning and end of the token in the original input string. The &quot;position&quot; column is the sequence number of the token in the original input string. There is also an &quot;input&quot; column which is simply a copy of the input string that is specified in the WHERE clause. Note that a constraint of the form &quot;input=?&quot; must appear in the WHERE clause or else the virtual table will have no input to tokenize and will return no rows. The example above generates the following output:</source>
          <target state="translated">仮想テーブルは、入力文字列に含まれるトークンごとに1行の出力を返します。token」列はトークンのテキストです。start&quot; および &quot;end&quot; カラムは、元の入力文字列内のトークンの開始および終了に対するバイトオフセットです。position」列は、元の入力文字列中のトークンのシーケンス番号である。また、「input」列もあり、これは単にWHERE句で指定された入力文字列のコピーである。そうでなければ、仮想テーブルはトークン化する入力を持たず、行を返さないことに注意してください。上記の例では、次のような出力が生成されます。</target>
        </trans-unit>
        <trans-unit id="e7d6d48d0123dd78c2ece991b5f7661cea292174" translate="yes" xml:space="preserve">
          <source>The wal-index file or &quot;shm&quot; file is not actually used as a file. Rather, individual database clients mmap the shm file and use it as shared memory for coordinating access to the database and as a cache for quickly locating frame within the wal file. The name of the shm file is the main database file name with the four characters &quot;-shm&quot; appended. Or, for 8+3 filesystems, the shm file is the main database file with the suffix changed to &quot;.SHM&quot;.</source>
          <target state="translated">wal-indexファイルまたは &quot;shm &quot;ファイルは実際にはファイルとしては使用されません。むしろ、個々のデータベースクライアントはshmファイルをmmapし、データベースへのアクセスを調整するための共有メモリとして、また、walファイル内のフレームを素早く見つけるためのキャッシュとして使用します。shmファイルの名前は、メインのデータベースファイル名に4文字の&quot;-shm &quot;を付加したものです。または、8+3ファイルシステムでは、shmファイルはメインデータベースファイルで、サフィックスを&quot;.shm &quot;に変更したものです。</target>
        </trans-unit>
        <trans-unit id="2705cff44fec902d1ca3ce2af3b554cabc339fb3" translate="yes" xml:space="preserve">
          <source>The wal-index file, usually named &quot;X-shm&quot;.</source>
          <target state="translated">ウォルインデックスファイル、通常は「X-shm」と名付けられています。</target>
        </trans-unit>
        <trans-unit id="3164ee82328b180dbc8289eddc9db733f9109901" translate="yes" xml:space="preserve">
          <source>The wal-index is transient. After a crash, the wal-index is reconstructed from the original WAL file. The VFS is required to either truncate or zero the header of the wal-index when the last connection to it closes. Because the wal-index is transient, it can use an architecture-specific format; it does not have to be cross-platform. Hence, unlike the database and WAL file formats which store all values as big endian, the wal-index stores multi-byte values in the native byte order of the host computer.</source>
          <target state="translated">wal-indexは一時的なものです。クラッシュ後、wal-index は元の WAL ファイルから再構築されます。VFS は wal-index への最後の接続が終了すると、wal-index のヘッダを切り詰めるかゼロにする必要があります。wal-indexは過渡的なものであるため、アーキテクチャ固有のフォーマットを使用することができ、クロスプラットフォームである必要はありません。したがって、すべての値をビッグエンディアンで保存するデータベースや WAL ファイルフォーマットとは異なり、wal-index はホストコンピュータのネイティブバイト順でマルチバイト値を保存します。</target>
        </trans-unit>
        <trans-unit id="f37728360280f92c82e5f63eda2235cd3fe649d8" translate="yes" xml:space="preserve">
          <source>The wal_checkpoint pragma returns a single row with three integer columns. The first column is usually 0 but will be 1 if a RESTART or FULL or TRUNCATE checkpoint was blocked from completing, for example because another thread or process was actively using the database. In other words, the first column is 0 if the equivalent call to &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; would have returned &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; or 1 if the equivalent call would have returned &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. The second column is the number of modified pages that have been written to the write-ahead log file. The third column is the number of pages in the write-ahead log file that have been successfully moved back into the database file at the conclusion of the checkpoint. The second and third column are -1 if there is no write-ahead log, for example if this pragma is invoked on a database connection that is not in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">wal_checkpointプラグマは、3つの整数列を持つ単一の行を返します。最初の列は通常0ですが、たとえば別のスレッドまたはプロセスがデータベースをアクティブに使用していたために、RESTARTまたはFULLまたはTRUNCATEチェックポイントの完了がブロックされた場合は1になります。換言すれば、最初の列は、と等価呼び出し場合は0である&lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）が&lt;/a&gt;返されたであろう&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;同等の呼び出しが戻ってきたかどうか、1 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSYを&lt;/a&gt;。 2番目の列は、先行書き込みログファイルに書き込まれた変更済みページの数です。 3番目の列は、チェックポイントの終了時にデータベースファイルに正常に戻された先行書き込みログファイルのページ数です。たとえば、このプラグマが&lt;a href=&quot;wal&quot;&gt;WALモード&lt;/a&gt;ではないデータベース接続で呼び出された場合、2番目と3番目の列は、先行書き込みログがない場合は-1 です。</target>
        </trans-unit>
        <trans-unit id="7abca67d3b2f6649a3ed46e41721882b254d1af5" translate="yes" xml:space="preserve">
          <source>The way SQLite deals with this is to first run the inner SELECT (the one against examp2) and store its result in a private memory cell. SQLite then substitutes the value of this private memory cell for the inner SELECT when it evaluates the outer SELECT. The code looks like this:</source>
          <target state="translated">SQLiteがこれを処理する方法は、まず内側のSELECT(examp2に対するもの)を実行し、その結果をプライベート・メモリ・セルに格納します。SQLiteは、外側のSELECTを評価する際に、このプライベート・メモリ・セルの値を内側のSELECTの値に置き換えます。コードは次のようになります。</target>
        </trans-unit>
        <trans-unit id="d9f0711eae8ce05c73449f6cd3513a09a5b0c229" translate="yes" xml:space="preserve">
          <source>The way in which the IN and NOT IN operators handle NULL values in their right-hand expressions has been brought into compliance with the SQL standard and with other SQL database engines.</source>
          <target state="translated">IN および NOT IN 演算子が右辺の式で NULL 値を扱う方法は、SQL 標準および他の SQL データベースエンジンに準拠するようになりました。</target>
        </trans-unit>
        <trans-unit id="1bcbf2e1391b1aa7e3ebafdb83d7f3bc20c48ce0" translate="yes" xml:space="preserve">
          <source>The whole point of the xShadowName method is to protect the content of shadow tables from being corrupted by hostile SQL. Every virtual table implementation that uses shadow tables should be able to detect and cope with corrupted shadow table content. However, bugs in particular virtual table implementation might allow a deliberately corrupted shadow table to cause a crash or other malfunction. The xShadowName mechanism seeks to avoid zero-day exploits by preventing ordinary SQL statements from deliberately corrupting shadow tables.</source>
          <target state="translated">xShadowName メソッドの全体的なポイントは、シャドウテーブルの内容が敵対的な SQL によって破損されないように保護することです。シャドウテーブルを使用するすべての仮想テーブルの実装は、破損したシャドウテーブルの内容を検出して対処することができるはずです。しかし、特定の仮想テーブル実装のバグにより、故意に破損したシャドウテーブルがクラッシュやその他の誤動作を引き起こす可能性があります。xShadowNameメカニズムは、通常のSQLステートメントがシャドウテーブルを故意に破損することを防ぐことで、ゼロデイエクスプロイトを回避しようとしています。</target>
        </trans-unit>
        <trans-unit id="7ba3625dd3002c676817bb5d0641f1c309f9b35c" translate="yes" xml:space="preserve">
          <source>The width field specifies the minimum width of the substituted value in the output. If the string or number that is written into the output is shorter than the width, then the value is padded. Padding is on the left (the value is right-justified) by default. If the &quot;-&quot; flag is used, then the padding is on the right and the value is left-justified.</source>
          <target state="translated">widthフィールドは、出力内の置換された値の最小幅を指定します。出力に書き込まれる文字列や数値が幅よりも短い場合、値はパディングされます。パディングは、デフォルトでは左側にある(値は右寄せになる)。フラグ&quot;-&quot;が使用された場合、パディングは右側になり、値は左寄せになる。</target>
        </trans-unit>
        <trans-unit id="a12aad5ee5dbe2d3fff555e1c8b3c9090a69eb38" translate="yes" xml:space="preserve">
          <source>The width is measured in bytes by default. However, if the &quot;!&quot; flag is present then the width is in characters. This only makes a difference for multi-byte utf-8 characters, and those only occur on string substitutions.</source>
          <target state="translated">デフォルトでは、幅はバイト単位で測定されます。しかし、&quot;!&quot; フラグがある場合は、幅は文字単位になります。これはマルチバイトの utf-8 文字にのみ影響を与え、文字列の置換時にのみ発生します。</target>
        </trans-unit>
        <trans-unit id="bb37fe25186c24e9c2d6b18924cc12e6bf999427" translate="yes" xml:space="preserve">
          <source>The word transliterated into lower-case ASCII. There is a standard table of mappings from non-ASCII characters into ASCII. Examples: &quot;&amp;aelig;&quot; -&amp;gt; &quot;ae&quot;, &quot;&amp;thorn;&quot; -&amp;gt; &quot;th&quot;, &quot;&amp;szlig;&quot; -&amp;gt; &quot;ss&quot;, &quot;&amp;aacute;&quot; -&amp;gt; &quot;a&quot;, ... The accessory function spellfix1_translit(X) will do the non-ASCII to ASCII mapping. The built-in lower(X) function will convert to lower-case. Thus: k1 = lower(spellfix1_translit(word)). If the word is already all lower-case ASCII, then the k1 column will contain a NULL. This reduces the storage requirements for the %_vocab table and helps spellfix to run a little faster. Therefore, it is advantageous to populate as much of the spellfix table as possible using lower-case ASCII vocabulary.</source>
          <target state="translated">小文字のASCIIに音訳された単語。非ASCII文字からASCIIへのマッピングの標準的な表があります。例：「&amp;aelig;」-&amp;gt;「ae」、「&amp;thorn;」-&amp;gt;「th」、「&amp;szlig;」-&amp;gt;「ss」、「&amp;aacute;」-&amp;gt;「a」、...付属関数spellfix1_translit（X）は、非ASCIIからASCIIへのマッピング。組み込みのlower（X）関数は小文字に変換されます。したがって：k1 = lower（spellfix1_translit（word））。単語がすべて小文字のASCIIである場合、k1列にはNULLが含まれます。これにより、％_ vocabテーブルのストレージ要件が軽減され、spellfixの実行が少し速くなります。したがって、小文字のASCIIボキャブラリーを使用して、可能な限り多くのspellfixテーブルを埋めることが有利です。</target>
        </trans-unit>
        <trans-unit id="2aea0dad5536afb073da7952899f42822308cf24" translate="yes" xml:space="preserve">
          <source>The working directory</source>
          <target state="translated">作業ディレクトリ</target>
        </trans-unit>
        <trans-unit id="1191da9cfb737ab513b0974862b6931c34d468a3" translate="yes" xml:space="preserve">
          <source>The write-ahead log file, usually named &quot;X-wal&quot;.</source>
          <target state="translated">書き込み可能なログファイルで、通常は「X-wal」と名付けられています。</target>
        </trans-unit>
        <trans-unit id="aa76cd0207c05b41731ac87f189a853ae60f3634" translate="yes" xml:space="preserve">
          <source>The write-ahead log or &quot;wal&quot; file is a roll-forward journal that records transactions that have been committed but not yet applied to the main database. Details on the format of the wal file are describe in the &lt;a href=&quot;fileformat2#walformat&quot;&gt;WAL format&lt;/a&gt; subsection of the main &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; document. The wal file is named by appending the four characters &quot;-wal&quot; to the end of the name of the main database file. Except on 8+3 filesystems, such names are not allowed, and in that case the file suffix is changed to &quot;.WAL&quot;. But as 8+3 filesystems are increasingly rare, that exceptional case can usually be ignored.</source>
          <target state="translated">先行書き込みログまたは「wal」ファイルは、コミットされているがメインデータベースにまだ適用されていないトランザクションを記録するロールフォワードジャーナルです。 walファイルの形式の詳細については、メイン&lt;a href=&quot;fileformat2&quot;&gt;ファイル形式の&lt;/a&gt;ドキュメントの&lt;a href=&quot;fileformat2#walformat&quot;&gt;WAL形式の&lt;/a&gt;サブセクションをご覧ください。 walファイルの名前は、メインデータベースファイルの名前の末尾に「-wal」という4文字を追加したものです。 8 + 3ファイルシステムを除いて、そのような名前は許可されていません。その場合、ファイルのサフィックスは「.WAL」に変更されます。しかし、8 + 3ファイルシステムはますます珍しくなっているため、その例外的なケースは通常無視できます。</target>
        </trans-unit>
        <trans-unit id="9fcf91986e20f3838e989f19567544d31cd8c593" translate="yes" xml:space="preserve">
          <source>The writefile(X,Y) SQL function write the blob Y into the file named X and returns the number of bytes written. Use this function to extract the content of a single table column into a file. For example:</source>
          <target state="translated">writefile(X,Y)SQL 関数は、X という名前のファイルに blob Y を書き込み、書き込まれたバイト数を返します。この関数を使用して、単一のテーブル列の内容をファイルに抽出します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="35efa113638256d189c7bffd527a8b95982adee0" translate="yes" xml:space="preserve">
          <source>The writing test above is not completely fair, since SQLite is doing &lt;a href=&quot;transactional&quot;&gt;power-safe transactions&lt;/a&gt; whereas the direct-to-disk writing is not. To put the tests on a more equal footing, add either the --nosync option to the SQLite writes to disable calling fsync() or FlushFileBuffers() to force content to disk, or using the --fsync option for the direct-to-disk tests to force them to invoke fsync() or FlushFileBuffers() when updating disk files.</source>
          <target state="translated">上記の書き込みテストは完全に公平ではありません。SQLiteは&lt;a href=&quot;transactional&quot;&gt;パワーセーフトランザクションを実行しているの&lt;/a&gt;に対し、ディスクへの直接書き込みはそうではありません。テストをより均等に行うには、SQL書き込みに--nosyncオプションを追加して、fsync（）またはFlushFileBuffers（）の呼び出しを無効にしてコンテンツをディスクに強制するか、または--fsyncオプションを使用して直接ディスクテストでは、ディスクファイルの更新時に、fsync（）またはFlushFileBuffers（）を強制的に呼び出します。</target>
        </trans-unit>
        <trans-unit id="3500eedb790da60f6c7c2c2fe42347161ad2dc7e" translate="yes" xml:space="preserve">
          <source>The xAccess method is used to check for access permissions on a file. The filename will be UTF-8 encoded. The flags argument will be &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt; to check for the existence of the file, &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt; to check to see if the file is both readable and writable, or &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt; to check to see if the file is at least readable. The &quot;file&quot; named by the second parameter might be a directory or folder name.</source>
          <target state="translated">xAccessメソッドは、ファイルへのアクセス許可を確認するために使用されます。ファイル名はUTF-8でエンコードされます。 flags引数は次のようになります&lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt;、ファイルの存在を確認するために&lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READWRITEを&lt;/a&gt;ファイルは読み書き可能の両方であるかどうかを確認するために、または&lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt;ファイルは、少なくとも読み込み可能であるかどうかを確認します。 2番目のパラメーターで指定された「ファイル」は、ディレクトリーまたはフォルダー名である可能性があります。</target>
        </trans-unit>
        <trans-unit id="7e3dceb3a3d82f8b52bd7f5b2f951ed3b0619691" translate="yes" xml:space="preserve">
          <source>The xAccess() method is invoked again to detect if the journal file is still in the file system. If it is, then it is a hot-journal file and SQLite tries to roll it back (see section</source>
          <target state="translated">xAccess()メソッドが再び呼び出され、ジャーナルファイルがファイルシステム内に残っているかどうかを検出します。もしそうであれば、それはホットジャーナルファイルであり、SQLite はそれをロールバックしようとします (</target>
        </trans-unit>
        <trans-unit id="be1521ac61f6da801d0f89ccb40ef26362bd2aea" translate="yes" xml:space="preserve">
          <source>The xAccess() method of the VFS is allowed to return -1 to signal a memory allocation error.</source>
          <target state="translated">VFS の xAccess()メソッドは、メモリ割り当てエラーのシグナルとして -1 を返すことができます。</target>
        </trans-unit>
        <trans-unit id="dbb116d3015d148d9aef4ab4eaf91f8dc7699911" translate="yes" xml:space="preserve">
          <source>The xBestIndex function may have requested the values of certain expressions using the aConstraintUsage[].argvIndex values of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure. Those values are passed to xFilter using the argc and argv parameters.</source>
          <target state="translated">xBestIndex関数は、&lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;構造体のaConstraintUsage []。argvIndex値を使用して特定の式の値を要求した可能性があります。これらの値は、argcおよびargvパラメーターを使用してxFilterに渡されます。</target>
        </trans-unit>
        <trans-unit id="e673068c08d7f626c7139b66b363abe588afdbfb" translate="yes" xml:space="preserve">
          <source>The xBestIndex method fills the idxNum and idxStr fields with information that communicates an indexing strategy to the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method. The information in idxNum and idxStr is arbitrary as far as the SQLite core is concerned. The SQLite core just copies the information through to the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method. Any desired meaning can be assigned to idxNum and idxStr as long as xBestIndex and xFilter agree on what that meaning is.</source>
          <target state="translated">xBestIndexメソッドは、インデックス戦略を&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;メソッドに伝える情報をidxNumおよびidxStrフィールドに入力します。SQLiteコアに関する限り、idxNumおよびidxStrの情報は任意です。SQLiteコアは、情報を&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;メソッドにコピーするだけです。xBestIndexとxFilterがその意味と一致する限り、idxNumとidxStrに任意の意味を割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="7549b2c421b13b6947674708c7a5360fc1373a57" translate="yes" xml:space="preserve">
          <source>The xBestIndex method is required for every virtual table implementation.</source>
          <target state="translated">xBestIndex メソッドは、すべての仮想テーブルの実装で必須です。</target>
        </trans-unit>
        <trans-unit id="6671b4241ef5e4b25933598f6cbd513b0faa9c69" translate="yes" xml:space="preserve">
          <source>The xBestIndex method may optionally populate the idxFlags field with a mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag - SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLite assumes that the strategy may visit at most one row.</source>
          <target state="translated">xBestIndex メソッドは、オプションで idxFlags フィールドに SQLITE_INDEX_SCAN_*フラグのマスクを指定することができます。現在、そのようなフラグは一つだけです-SQLITE_INDEX_SCAN_UNIQUE。xBestIndexメソッドがこのフラグを設定すると、SQLiteはストラテジーが最大でも1行を訪問すると仮定します。</target>
        </trans-unit>
        <trans-unit id="60dc1bff84d7b24ecf260c549a70a2e550acd608" translate="yes" xml:space="preserve">
          <source>The xBestIndex method may set aConstraintUsage[].argvIndex entries to values greater than zero. Exactly one entry should be set to 1, another to 2, another to 3, and so forth up to as many or as few as the xBestIndex method wants. The EXPR of the corresponding constraints will then be passed in as the argv[] parameters to xFilter.</source>
          <target state="translated">xBestIndexメソッドは、aConstraintUsage[].argvIndexエントリをゼロよりも大きな値に設定することができます。正確には、1つのエントリを1に設定し、別のエントリを2に設定し、別のエントリを3に設定するなど、xBestIndexメソッドが望む数だけ、または少ない数だけ設定する必要があります。対応する制約のEXPRは、argv[]パラメータとしてxFilterに渡されます。</target>
        </trans-unit>
        <trans-unit id="b0c67bb7b3ba635b9cd74ad89d5155e843f934eb" translate="yes" xml:space="preserve">
          <source>The xBestIndex method should return SQLITE_OK on success. If any kind of fatal error occurs, an appropriate error code (ex: &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;) should be returned instead.</source>
          <target state="translated">xBestIndexメソッドは成功するとSQLITE_OKを返します。何らかの致命的なエラーが発生した場合は、適切なエラーコード（例：&lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;）が返されます。</target>
        </trans-unit>
        <trans-unit id="6e2147722085d4c968213130f4ef993a32c73b66" translate="yes" xml:space="preserve">
          <source>The xBestIndex method will be invoked once for each of the potential plans above. For plan 1, the aConstraint[].usable flag for for the SQLITE_CONSTRAINT_EQ constraint on the param1 column will be true because the right-hand side value for the &quot;param1 = ?&quot; constraint will be known, since it is determined by the outer realtab loop. But for plan 2, the aConstraint[].usable flag for &quot;param1 = ?&quot; will be false because the right-hand side value is determined by an inner loop and is thus an unknown quantity. Because param1 is a required input to the table-valued functions, the xBestIndex method should return SQLITE_CONSTRAINT when presented with plan 2, indicating that a required input is missing. This forces the query planner to select plan 1.</source>
          <target state="translated">xBestIndexメソッドは、上記の潜在的なプランのそれぞれに対して一度だけ呼び出されます。プラン1では、&quot;param1=? &quot;制約の右側の値は外側のrealtabループによって決定されるので、&quot;param1=? &quot;制約のためのSQLITE_CONSTRAINT_EQ制約のためのaConstraint[].usableフラグは真になります。しかし、プラン2の場合、&quot;param1=? &quot;制約の右側の値は内側のループによって決定されるため、未知の量であるため、&quot;param1=? &quot;制約のaConstraint[].usableフラグは偽になります。param1はテーブル値関数への必須入力であるため、xBestIndexメソッドはプラン2が提示されたときにSQLITE_CONSTRAINTを返し、必須入力が存在しないことを示します。これにより、クエリプランナはプラン1を選択するように強制されます。</target>
        </trans-unit>
        <trans-unit id="c5e6a28d9d92d2bf9deb3f28a367d165a9d141f6" translate="yes" xml:space="preserve">
          <source>The xCachesize() method may be called at any time by SQLite to set the suggested maximum cache-size (number of pages stored by) the cache instance passed as the first argument. This is the value configured using the SQLite &quot;&lt;a href=&quot;../pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt;&quot; command. As with the bPurgeable parameter, the implementation is not required to do anything with this value; it is advisory only.</source>
          <target state="translated">SQLiteは、xCachesize（）メソッドをいつでも呼び出して、最初の引数として渡されるキャッシュインスタンスの推奨最大キャッシュサイズ（保存されるページ数）を設定できます。これは、SQLiteの &quot; &lt;a href=&quot;../pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt; &quot;コマンドを使用して構成された値です。bPurgeableパラメータと同様に、実装はこの値で何もする必要はありません。それは助言のみです。</target>
        </trans-unit>
        <trans-unit id="64860c154593114b929547aef1bfe359a445dd93" translate="yes" xml:space="preserve">
          <source>The xCachesize() method may be called at any time by SQLite to set the suggested maximum cache-size (number of pages stored by) the cache instance passed as the first argument. This is the value configured using the SQLite &quot;&lt;a href=&quot;pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt;&quot; command. As with the bPurgeable parameter, the implementation is not required to do anything with this value; it is advisory only.</source>
          <target state="translated">SQLiteは、xCachesize（）メソッドをいつでも呼び出して、最初の引数として渡されるキャッシュインスタンスの推奨最大キャッシュサイズ（保存されるページ数）を設定できます。これは、SQLiteの &quot; &lt;a href=&quot;pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt; &quot;コマンドを使用して構成された値です。bPurgeableパラメータと同様に、実装はこの値で何もする必要はありません。それは助言のみです。</target>
        </trans-unit>
        <trans-unit id="76bfcc9d387b84934d7209d1ccf2568a52cae2ff" translate="yes" xml:space="preserve">
          <source>The xCheckReservedLock() method checks to see if another connection or another process is currently holding a reserved, pending, or exclusive lock on the file. It returns true or false.</source>
          <target state="translated">xCheckReservedLock()メソッドは、他の接続または他のプロセスが、現在ファイルの予約済み、保留中、または排他的なロックを保持しているかどうかをチェックします。このメソッドは、true または false を返します。</target>
        </trans-unit>
        <trans-unit id="5108534fb3c98c994a35c533b42cb72d472a86d4" translate="yes" xml:space="preserve">
          <source>The xClose method closes a cursor previously opened by &lt;a href=&quot;vtab#xopen&quot;&gt;xOpen&lt;/a&gt;. The SQLite core will always call xClose once for each cursor opened using xOpen.</source>
          <target state="translated">xCloseメソッドは、&lt;a href=&quot;vtab#xopen&quot;&gt;xOpen&lt;/a&gt;によって以前に開かれたカーソルを閉じます。SQLiteコアは、xOpenを使用して開いたカーソルごとに常にxCloseを呼び出します。</target>
        </trans-unit>
        <trans-unit id="a1fcaec496244ffb2502893506be9bff99222ddb" translate="yes" xml:space="preserve">
          <source>The xClose method closes the file. The space for the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; structure is deallocated by the caller. But if the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; contains pointers to other allocated memory or resources, those allocations should be released by the xClose method.</source>
          <target state="translated">xCloseメソッドはファイルを閉じます。&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;構造のスペースは、呼び出し元によって割り当て解除されます。ただし、&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;に他の割り当てられたメモリまたはリソースへのポインターが含まれている場合、それらの割り当てはxCloseメソッドによって解放される必要があります。</target>
        </trans-unit>
        <trans-unit id="2af5d67c2c34fed358127148fe670412a17ae024" translate="yes" xml:space="preserve">
          <source>The xClose method is required for every virtual table implementation.</source>
          <target state="translated">xClose メソッドは、すべての仮想テーブルの実装で必須です。</target>
        </trans-unit>
        <trans-unit id="57537332c9edcb104197db5e7bb9793f5df28547" translate="yes" xml:space="preserve">
          <source>The xColumn method is required for every virtual table implementation.</source>
          <target state="translated">xColumn メソッドは、すべての仮想テーブルの実装で必須です。</target>
        </trans-unit>
        <trans-unit id="ef93eeb561a6057de6700b4a7eda4c4170148438" translate="yes" xml:space="preserve">
          <source>The xColumnSize API always returns -1. There is no way to determine the number of tokens in a value stored within a contentless FTS5 table configured with columnsize=0.</source>
          <target state="translated">xColumnSize API は常に -1 を返します。columnsize=0 で構成されたコンテントレス FTS5 テーブル内に格納された値のトークン数を決定する方法はありません。</target>
        </trans-unit>
        <trans-unit id="9e2d00478c87bed4be4b97709f42f53211a90ec1" translate="yes" xml:space="preserve">
          <source>The xConnect method is required for every virtual table implementation, though the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and xConnect pointers of the &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; object may point to the same function if the virtual table does not need to initialize backing store.</source>
          <target state="translated">けれどもxconnectコン方法は、すべての仮想テーブルの実装に必要とされる&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;のとxconnectのポインタ&lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt;仮想テーブルは、バッキングストアを初期化する必要がない場合、オブジェクトは、同じ機能を指すことがあります。</target>
        </trans-unit>
        <trans-unit id="3a84b2667247b1e27fdcdd3d4cc56221f573c090" translate="yes" xml:space="preserve">
          <source>The xConnect method is very similar to &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;. It has the same parameters and constructs a new &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure just like xCreate. And it must also call &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; like xCreate.</source>
          <target state="translated">xConnectメソッドはxCreateに非常に似てい&lt;a href=&quot;vtab#xcreate&quot;&gt;ます&lt;/a&gt;。同じパラメーターがあり、&lt;a href=&quot;c3ref/vtab&quot;&gt;xCreateと&lt;/a&gt;同じように新しいsqlite3_vtab構造を構築します。また、&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;xCreateの&lt;/a&gt;ようにsqlite3_declare_vtab （）を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="9ec50befd1d20d9f6756f231c4255cc685afba32" translate="yes" xml:space="preserve">
          <source>The xConnect method must return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if it is successful in creating the new virtual table, or &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if it is not successful. If not successful, the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure must not be allocated. An error message may optionally be returned in *pzErr if unsuccessful. Space to hold the error message string must be allocated using an SQLite memory allocation function like &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; as the SQLite core will attempt to free the space using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; after the error has been reported up to the application.</source>
          <target state="translated">エクスコネクト方法は返す必要があり&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OKを&lt;/a&gt;、それが新しい仮想テーブルを作成することに成功、またはある場合&lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;それが成功しなかった場合。成功しない場合は、&lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt;構造を割り当てないでください。失敗した場合、オプションでエラーメッセージが* pzErrに返される場合があります。アプリケーションにエラーが報告された後、SQLiteコアは&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;を使用してスペースを解放しようとするため、エラーメッセージ文字列を保持するスペースは、&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;または&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;などのSQLiteメモリ割り当て関数を使用して割り当てる必要があります。</target>
        </trans-unit>
        <trans-unit id="6920f3a6545664c297cabaad1f1d797cb28640a2" translate="yes" xml:space="preserve">
          <source>The xCreate and xConnect methods are only different when the virtual table has some kind of backing store that must be initialized the first time the virtual table is created. The xCreate method creates and initializes the backing store. The xConnect method just connects to an existing backing store. When xCreate and xConnect are the same, the table is an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt;.</source>
          <target state="translated">xCreateメソッドとxConnectメソッドは、仮想テーブルが初めて作成されたときに初期化する必要があるバッキングストアの種類がある場合にのみ異なります。 xCreateメソッドは、バッキングストアを作成および初期化します。 xConnectメソッドは、既存のバッキングストアに接続するだけです。 xCreateとxConnectが同じ場合、テーブルは代名詞の&lt;a href=&quot;vtab#epovtab&quot;&gt;仮想テーブル&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="dcf39a347f064ec02d2e007cec689340fd805ffc" translate="yes" xml:space="preserve">
          <source>The xCreate method is called to create a new instance of a virtual table in response to a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. If the xCreate method is the same pointer as the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method, then the virtual table is an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt;. If the xCreate method is omitted (if it is a NULL pointer) then the virtual table is an &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual table&lt;/a&gt;.</source>
          <target state="translated">xCreateメソッドは、&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;ステートメントに応答して仮想テーブルの新しいインスタンスを作成するために呼び出されます。xCreateメソッドがxConnectメソッドと同じポインターの場合、仮想テーブルは&lt;a href=&quot;vtab#xconnect&quot;&gt;代名詞の&lt;/a&gt;&lt;a href=&quot;vtab#epovtab&quot;&gt;仮想テーブル&lt;/a&gt;です。xCreateメソッドが省略されている場合（NULLポインターの場合）、仮想テーブルは、&lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;同名のみの仮想テーブル&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="7fa820ae673d5a152c6735ecfbe5a6902d1afc09" translate="yes" xml:space="preserve">
          <source>The xCreate method need not initialize the pModule, nRef, and zErrMsg fields of the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; object. The SQLite core will take care of that chore.</source>
          <target state="translated">xCreateメソッドは、&lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt;オブジェクトのpModule、nRef、およびzErrMsgフィールドを初期化する必要はありません。SQLiteコアがその面倒を処理します。</target>
        </trans-unit>
        <trans-unit id="06c7e419a8719bf400eb11e6ddbab813f843fcfc" translate="yes" xml:space="preserve">
          <source>The xCreate should return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if it is successful in creating the new virtual table, or &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if it is not successful. If not successful, the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure must not be allocated. An error message may optionally be returned in *pzErr if unsuccessful. Space to hold the error message string must be allocated using an SQLite memory allocation function like &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; as the SQLite core will attempt to free the space using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; after the error has been reported up to the application.</source>
          <target state="translated">xCreateは返す必要があり&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OKを&lt;/a&gt;、それが新しい仮想テーブルの作成に成功した場合、または&lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;それが成功しなかった場合。成功しない場合は、&lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt;構造を割り当てないでください。失敗した場合、オプションでエラーメッセージが* pzErrに返される場合があります。アプリケーションにエラーが報告された後、SQLiteコアは&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;を使用してスペースを解放しようとするため、エラーメッセージ文字列を保持するスペースは、&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;または&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;などのSQLiteメモリ割り当て関数を使用して割り当てる必要があります。</target>
        </trans-unit>
        <trans-unit id="f958ace0be88d27965e6fd7b0b417f1f44eb7a29" translate="yes" xml:space="preserve">
          <source>The xCurrentTime method finds the current time and date and writes the result as a double-precision floating point value into pointer provided by the second parameter. The time and date is in coordinated universal time (UTC) and is a fractional Julian day number.</source>
          <target state="translated">xCurrentTime メソッドは、現在の時刻と日付を検出し、その結果を倍精度浮動小数点値として 2 番目のパラメータで指定されたポインタに書き込みます。時刻と日付は、協定世界時 (UTC)であり、分数のユリウス日番号です。</target>
        </trans-unit>
        <trans-unit id="6df2a95b2c02a08ca9301c1af593f076dcec3de1" translate="yes" xml:space="preserve">
          <source>The xDelete callback, if one is specified, is also invoked on the auxiliary data pointer after the FTS5 query has finished.</source>
          <target state="translated">xDeleteコールバックが指定されている場合は、FTS5の問い合わせが終了した後、補助データポインタに対しても呼び出されます。</target>
        </trans-unit>
        <trans-unit id="684db9583b8006f9c3587ed123a3291e36233a15" translate="yes" xml:space="preserve">
          <source>The xDelete method in the built-in &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; now return SQLITE_IOERR_DELETE_NOENT if the file to be deleted does not exist.</source>
          <target state="translated">組み込みVFSのxDeleteメソッドは、削除するファイルが存在しない場合に&lt;a href=&quot;vfs&quot;&gt;SQLITE_IOERR_DELETE_NOENTを&lt;/a&gt;返すようになりました。</target>
        </trans-unit>
        <trans-unit id="8acbdfc184b8627360b75ab194ff6c7691155e56" translate="yes" xml:space="preserve">
          <source>The xDelete method is used to delete a file. The name of the file is given in the second parameter. The filename will be in UTF-8. The VFS must convert the filename into whatever character representation the underlying operating system expects. If the syncDir parameter is true, then the xDelete method should not return until the change to the directory contents for the directory containing the deleted file have been synced to disk in order to ensure that the file does not &quot;reappear&quot; if a power failure occurs soon after.</source>
          <target state="translated">xDeleteメソッドは、ファイルを削除するために使用されます。2 番目のパラメータにファイル名を指定します。ファイル名は UTF-8 になります。VFS は、ファイル名を、基礎となるオペレーティング・システムが期待する文字表現に変換する必要があります。syncDir パラメータが true の場合、xDelete メソッドは、削除されたファイルを含むディレクトリのディレクトリ内容の変更がディスクに同期されるまで返さないようにしてください。</target>
        </trans-unit>
        <trans-unit id="11b2a4e02961f3a81754bcacd1c2618edac811a1" translate="yes" xml:space="preserve">
          <source>The xDestroy callback is &lt;u&gt;not&lt;/u&gt; called if the sqlite3_create_collation_v2() function fails. Applications that invoke sqlite3_create_collation_v2() with a non-NULL xDestroy argument should check the return code and dispose of the application data pointer themselves rather than expecting SQLite to deal with it for them. This is different from every other SQLite interface. The inconsistency is unfortunate but cannot be changed without breaking backwards compatibility.</source>
          <target state="translated">sqlite3_create_collat​​ion_v2（）関数が失敗した場合、xDestroyコールバックは呼び出され&lt;u&gt;ませ&lt;/u&gt;ん。NULL以外のxDestroy引数を指定してsqlite3_create_collat​​ion_v2（）を呼び出すアプリケーションは、SQLiteが処理することを期待するのではなく、戻りコードを確認してアプリケーションデータポインター自体を破棄する必要があります。これは、他のすべてのSQLiteインターフェースとは異なります。不整合は残念ですが、下位互換性を壊さずに変更することはできません。</target>
        </trans-unit>
        <trans-unit id="82fcb2416a6d15ad9c7eed2868bb3c1083659be9" translate="yes" xml:space="preserve">
          <source>The xDestroy method is required for every virtual table implementation, though it is acceptable for the &lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect&lt;/a&gt; and xDestroy methods to be the same function if that makes sense for the particular virtual table.</source>
          <target state="translated">すべての仮想テーブルの実装にはxDestroyメソッドが必要ですが、特定の仮想テーブルにとって意味がある場合は、xDisconnectメソッドとxDestroyメソッドが同じ関数であっても&lt;a href=&quot;vtab#xdisconnect&quot;&gt;問題&lt;/a&gt;ありません。</target>
        </trans-unit>
        <trans-unit id="433eafbb64ee6df6fcf2cd0863165758dd2318f2" translate="yes" xml:space="preserve">
          <source>The xDestroy() method is used to delete a cache allocated by xCreate(). All resources associated with the specified cache should be freed. After calling the xDestroy() method, SQLite considers the &lt;a href=&quot;#sqlite3_pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache*&lt;/a&gt; handle invalid, and will not use it with any other sqlite3_pcache_methods2 functions.</source>
          <target state="translated">xDestroy（）メソッドは、xCreate（）によって割り当てられたキャッシュを削除するために使用されます。指定したキャッシュに関連付けられているすべてのリソースを解放する必要があります。xDestroy（）メソッドを呼び出した後、SQLiteは&lt;a href=&quot;#sqlite3_pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache *&lt;/a&gt;ハンドルを無効と見なし、それを他のsqlite3_pcache_methods2関数で使用しません。</target>
        </trans-unit>
        <trans-unit id="8baf35611bcad0c5db55f35fee163e2aa0c149e9" translate="yes" xml:space="preserve">
          <source>The xDestroy() method is used to delete a cache allocated by xCreate(). All resources associated with the specified cache should be freed. After calling the xDestroy() method, SQLite considers the &lt;a href=&quot;pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache*&lt;/a&gt; handle invalid, and will not use it with any other sqlite3_pcache_methods2 functions.</source>
          <target state="translated">xDestroy（）メソッドは、xCreate（）によって割り当てられたキャッシュを削除するために使用されます。指定したキャッシュに関連付けられているすべてのリソースを解放する必要があります。xDestroy（）メソッドを呼び出した後、SQLiteは&lt;a href=&quot;pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache *&lt;/a&gt;ハンドルを無効と見なし、それを他のsqlite3_pcache_methods2関数で使用しません。</target>
        </trans-unit>
        <trans-unit id="604385447aab898766cb3896d8016d04ab97fc0d" translate="yes" xml:space="preserve">
          <source>The xDeviceCharacteristics method of the &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object returns an integer which is a vector of these bit values expressing I/O characteristics of the mass storage device that holds the file that the &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; refers to.</source>
          <target state="translated">xDeviceCharacteristics方法&lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methodsは&lt;/a&gt;リターンにそのファイルを保持する大容量記憶装置のI / O特性を発現するこれらのビット値のベクトルであり、整数オブジェクト&lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methodsを&lt;/a&gt;指すを。</target>
        </trans-unit>
        <trans-unit id="b98ec973b9735d7dd446dd0f56fe3b7eb0a27d7c" translate="yes" xml:space="preserve">
          <source>The xDeviceCharacteristics method of the &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object returns an integer which is a vector of these bit values expressing I/O characteristics of the mass storage device that holds the file that the &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; refers to.</source>
          <target state="translated">xDeviceCharacteristics方法&lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methodsは&lt;/a&gt;リターンにそのファイルを保持する大容量記憶装置のI / O特性を発現するこれらのビット値のベクトルであり、整数オブジェクト&lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methodsを&lt;/a&gt;指すを。</target>
        </trans-unit>
        <trans-unit id="c2e8466b1e208836960d6bb4f90ed3ea7832fd67" translate="yes" xml:space="preserve">
          <source>The xDeviceCharacteristics method returns an integer bit vector that defines any special properties that the underlying storage medium might have that SQLite can use to increase performance. The allowed return is the bit-wise OR of the following values:</source>
          <target state="translated">xDeviceCharacteristics メソッドは、SQLite がパフォーマンスを向上させるために使用することができる、基礎となるストレージメディアが持つかもしれない特別なプロパティを定義した整数ビットベクタを返します。返される値は、以下の値のビット単位の OR です。</target>
        </trans-unit>
        <trans-unit id="1262b3501d52f25dbe2da92b37772cb17c293d40" translate="yes" xml:space="preserve">
          <source>The xDisconnect method is required for every virtual table implementation, though it is acceptable for the xDisconnect and &lt;a href=&quot;vtab#sqlite3_module.xDestroy&quot;&gt;xDestroy&lt;/a&gt; methods to be the same function if that makes sense for the particular virtual table.</source>
          <target state="translated">すべての仮想テーブルの実装にはxDisconnectメソッドが必要ですが、特定の仮想テーブルに意味がある場合は、&lt;a href=&quot;vtab#sqlite3_module.xDestroy&quot;&gt;xDisconnect&lt;/a&gt;メソッドとxDestroyメソッドが同じ関数であっても問題ありません。</target>
        </trans-unit>
        <trans-unit id="80202d349ad4d59a55548ad8afd689feeefba61b" translate="yes" xml:space="preserve">
          <source>The xDlOpen, xDlError, xDlSym, and xDlClose methods are all used for accessing shared libraries at run-time. These methods may be omitted (and their pointers set to zero) if the library is compiled with &lt;a href=&quot;compile#omit_load_extension&quot;&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/a&gt; or if the &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; interface is never used to enable dynamic extension loading. The xDlOpen method opens a shared library or DLL and returns a pointer to a handle. NULL is returned if the open fails. If the open fails, the xDlError method can be used to obtain a text error message. The message is written into the zErrMsg buffer of the third parameter which is at least nByte bytes in length. The xDlSym returns a pointer to a symbol in the shared library. The name of the symbol is given by the second parameter. UTF-8 encoding is assumed. If the symbol is not found a NULL pointer is returned. The xDlClose routine closes the shared library.</source>
          <target state="translated">xDlOpen、xDlError、xDlSym、およびxDlCloseメソッドはすべて、実行時に共有ライブラリにアクセスするために使用されます。ライブラリが&lt;a href=&quot;compile#omit_load_extension&quot;&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/a&gt;でコンパイルされている場合、または&lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension（）&lt;/a&gt;が使用されている場合、これらのメソッドは省略できます（およびそのポインタはゼロに設定されます）。動的拡張ロードを有効にするためにインターフェースが使用されることはありません。 xDlOpenメソッドは、共有ライブラリまたはDLLを開き、ハンドルへのポインターを返します。オープンが失敗した場合は、NULLが返されます。オープンが失敗した場合、xDlErrorメソッドを使用してテキストエラーメッセージを取得できます。メッセージは、長さが少なくともnByteバイトである3番目のパラメーターのzErrMsgバッファーに書き込まれます。 xDlSymは、共有ライブラリ内のシンボルへのポインタを返します。シンボルの名前は2番目のパラメーターで指定されます。 UTF-8エンコーディングが想定されています。シンボルが見つからない場合は、NULLポインターが返されます。 xDlCloseルーチンは、共有ライブラリを閉じます。</target>
        </trans-unit>
        <trans-unit id="2a328c23f376e27049c3463e790fd30ea24be07c" translate="yes" xml:space="preserve">
          <source>The xEof method is required for every virtual table implementation.</source>
          <target state="translated">xEofメソッドは、すべての仮想テーブルの実装に必要です。</target>
        </trans-unit>
        <trans-unit id="2f524de9f6418ba3f20971cbbb6e678439f267fb" translate="yes" xml:space="preserve">
          <source>The xEof method must return false (zero) if the specified cursor currently points to a valid row of data, or true (non-zero) otherwise. This method is called by the SQL engine immediately after each &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; and &lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; invocation.</source>
          <target state="translated">xEofメソッドは、指定されたカーソルが現在有効なデータ行を指している場合はfalse（ゼロ）を返し、そうでない場合はtrue（ゼロ以外）を返す必要があります。このメソッドは、各&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;および&lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt;呼び出しの直後にSQLエンジンによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="31055a962a7bb13c9dfa534ee5cb14dc7402ab08" translate="yes" xml:space="preserve">
          <source>The xFetch() method locates a page in the cache and returns a pointer to an sqlite3_pcache_page object associated with that page, or a NULL pointer. The pBuf element of the returned sqlite3_pcache_page object will be a pointer to a buffer of szPage bytes used to store the content of a single database page. The pExtra element of sqlite3_pcache_page will be a pointer to the szExtra bytes of extra storage that SQLite has requested for each entry in the page cache.</source>
          <target state="translated">xFetch()メソッドはキャッシュ内のページを探し、そのページに関連付けられたsqlite3_pcache_pageオブジェクトへのポインタ、もしくはNULLポインタを返します。返されたsqlite3_pcache_pageオブジェクトのpBuf要素は、単一のデータベースページの内容を格納するために使用されるszPageバイトのバッファへのポインタになります。sqlite3_pcache_pageのpExtra要素は、ページキャッシュの各エントリに対してSQLiteが要求した追加ストレージのszExtraバイトへのポインタになります。</target>
        </trans-unit>
        <trans-unit id="eec30896c07568e6756a1fd11de9a9be38006b51" translate="yes" xml:space="preserve">
          <source>The xFileControl() method is a generic interface that allows custom VFS implementations to directly control an open file using the (new and experimental) &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface. The second &quot;op&quot; argument is an integer opcode. The third argument is a generic pointer which is intended to be a pointer to a structure that may contain arguments or space in which to write return values. Potential uses for xFileControl() might be functions to enable blocking locks with timeouts, to change the locking strategy (for example to use dot-file locks), to inquire about the status of a lock, or to break stale locks. The SQLite core reserves opcodes less than 100 for its own use. A &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntllockstate&quot;&gt;list of opcodes&lt;/a&gt; less than 100 is available. Applications that define a custom xFileControl method should use opcodes greater than 100 to avoid conflicts.</source>
          <target state="translated">xFileControl（）メソッドは、カスタムVFS実装が（新しい実験的な）&lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;インターフェースを使用して開いているファイルを直接制御できるようにする汎用インターフェースです。 2番目の「op」引数は整数のopcodeです。 3番目の引数は、戻り値を書き込むための引数またはスペースを含む可能性のある構造体へのポインターになることを目的とした汎用ポインターです。 xFileControl（）の潜在的な用途は、タイムアウト付きのロックのブロックを有効にする、ロック戦略を変更する（たとえば、ドットファイルロックを使用する）、ロックのステータスについて問い合わせる、または古いロックを解除する関数などです。 SQLiteコアは、独自に使用するために100未満のオペコードを予約しています。&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntllockstate&quot;&gt;オペコード&lt;/a&gt;のリスト100未満が使用可能です。カスタムxFileControlメソッドを定義するアプリケーションは、競合を回避するために、100より大きいオペコードを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="dddf7acfafd6d3f8269f8f981d3bcbe57970b96a" translate="yes" xml:space="preserve">
          <source>The xFileControl() method is a generic interface that allows custom VFS implementations to directly control an open file using the &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface. The second &quot;op&quot; argument is an integer opcode. The third argument is a generic pointer intended to point to a structure that may contain arguments or space in which to write return values. Potential uses for xFileControl() might be functions to enable blocking locks with timeouts, to change the locking strategy (for example to use dot-file locks), to inquire about the status of a lock, or to break stale locks. The SQLite core reserves all opcodes less than 100 for its own use. A &lt;a href=&quot;#SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&quot;&gt;list of opcodes&lt;/a&gt; less than 100 is available. Applications that define a custom xFileControl method should use opcodes greater than 100 to avoid conflicts. VFS implementations should return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; for file control opcodes that they do not recognize.</source>
          <target state="translated">xFileControl（）メソッドは、カスタムVFS実装が&lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;インターフェースを使用して開いているファイルを直接制御できるようにする汎用インターフェースです。2番目の「op」引数は整数のopcodeです。3番目の引数は、戻り値を書き込むための引数またはスペースを含む可能性のある構造を指すことを目的とした汎用ポインターです。xFileControl（）の潜在的な用途は、タイムアウト付きのロックのブロックを有効にする、ロック戦略を変更する（たとえば、ドットファイルロックを使用する）、ロックのステータスについて問い合わせる、または古いロックを解除する関数などです。SQLiteコアは、100未満のすべてのオペコードを独自に使用するために予約しています。&lt;a href=&quot;#SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&quot;&gt;オペコード&lt;/a&gt;のリスト100未満が使用可能です。カスタムxFileControlメソッドを定義するアプリケーションは、競合を回避するために、100より大きいオペコードを使用する必要があります。 VFS実装は、認識しないファイル制御オペコードに対して&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="0cff0bc514819c033ff2d05910e11b13ceab5fce" translate="yes" xml:space="preserve">
          <source>The xFileControl() method is a generic interface that allows custom VFS implementations to directly control an open file using the &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface. The second &quot;op&quot; argument is an integer opcode. The third argument is a generic pointer intended to point to a structure that may contain arguments or space in which to write return values. Potential uses for xFileControl() might be functions to enable blocking locks with timeouts, to change the locking strategy (for example to use dot-file locks), to inquire about the status of a lock, or to break stale locks. The SQLite core reserves all opcodes less than 100 for its own use. A &lt;a href=&quot;c_fcntl_begin_atomic_write&quot;&gt;list of opcodes&lt;/a&gt; less than 100 is available. Applications that define a custom xFileControl method should use opcodes greater than 100 to avoid conflicts. VFS implementations should return &lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; for file control opcodes that they do not recognize.</source>
          <target state="translated">xFileControl（）メソッドは、カスタムVFS実装が&lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;インターフェースを使用して開いているファイルを直接制御できるようにする汎用インターフェースです。2番目の「op」引数は整数のopcodeです。3番目の引数は、戻り値を書き込むための引数またはスペースを含む可能性のある構造を指すことを目的とした汎用ポインターです。xFileControl（）の潜在的な用途は、タイムアウト付きのロックのブロックを有効にする、ロック戦略を変更する（たとえば、ドットファイルロックを使用する）、ロックのステータスについて問い合わせる、または古いロックを解除する関数などです。SQLiteコアは、100未満のすべてのオペコードを独自に使用するために予約しています。&lt;a href=&quot;c_fcntl_begin_atomic_write&quot;&gt;オペコード&lt;/a&gt;のリスト100未満が使用可能です。カスタムxFileControlメソッドを定義するアプリケーションは、競合を回避するために、100より大きいオペコードを使用する必要があります。 VFS実装は、認識しないファイル制御オペコードに対して&lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="3203c926180842d31c782d904c037633ddf2f91f" translate="yes" xml:space="preserve">
          <source>The xFileSize() method determines the current size of the file in bytes and writes that value into *pSize. It returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_fstat&quot;&gt;SQLITE_IOERR_FSTAT&lt;/a&gt; if something goes wrong.</source>
          <target state="translated">xFileSize（）メソッドは、ファイルの現在のサイズをバイト単位で決定し、その値を* pSizeに書き込みます。成功した場合は&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;を返し、問題が&lt;a href=&quot;rescode#ioerr_fstat&quot;&gt;発生した&lt;/a&gt;場合はSQLITE_IOERR_FSTATを返します。</target>
        </trans-unit>
        <trans-unit id="96653ab4bb654a8e871b1a8c14aa48716aadb8ae" translate="yes" xml:space="preserve">
          <source>The xFilter method is required for every virtual table implementation.</source>
          <target state="translated">xFilter メソッドは、すべての仮想テーブルの実装で必須です。</target>
        </trans-unit>
        <trans-unit id="4479f4bd625e3440b28fa60e755d9671817cfbcf" translate="yes" xml:space="preserve">
          <source>The xFullPathname method is used to convert a relative pathname into a full pathname. The resulting full pathname is written into the buffer provided by the third parameter. SQLite will size the output buffer to at least mxPathname bytes. Both the input and output names should be in UTF-8.</source>
          <target state="translated">xFullPathname メソッドは、相対パス名をフルパス名に変換するために使用されます。結果として得られたフルパス名は、三番目のパラメータで指定したバッファに書き込まれます。SQLite は出力バッファを少なくとも mxPathname バイトのサイズにします。入力名と出力名は両方とも UTF-8 でなければなりません。</target>
        </trans-unit>
        <trans-unit id="5dbd41bd881211c13a1dbbcb8c736851e1bf5d97" translate="yes" xml:space="preserve">
          <source>The xGeom callback always does a depth-first search of the r-tree.</source>
          <target state="translated">xGeomコールバックは、常にr-treeの深さ優先検索を行います。</target>
        </trans-unit>
        <trans-unit id="454e11b15802805175a3b539debe13d361beb72d" translate="yes" xml:space="preserve">
          <source>The xGetTempName method computes the name of a temporary file that SQLite can use. The name should be written into the buffer given by the second parameter. SQLite will size that buffer to hold at least mxPathname bytes. The generated filename should be in UTF-8. To avoid security problems, the generated temporary filename should contain enough randomness to prevent an attacker from guessing the temporary filename in advance.</source>
          <target state="translated">xGetTempName メソッドは、SQLite が使用できる一時ファイルの名前を計算します。この名前は、2 番目のパラメータで指定されたバッファに書き込まれなければなりません。SQLite はこのバッファのサイズを、少なくとも mxPathname バイトを保持するようにします。生成されるファイル名はUTF-8でなければなりません。セキュリティ上の問題を避けるために、生成される一時ファイル名には、攻撃者が一時ファイル名を事前に推測できないように、十分なランダム性が含まれていなければなりません。</target>
        </trans-unit>
        <trans-unit id="5d25f32f0f944f020730e420a59b761837d6fa20" translate="yes" xml:space="preserve">
          <source>The xGetTempname method has been removed from &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;. In its place, the xOpen method is enhanced to open a temporary file of its own invention when the filename parameter is NULL.</source>
          <target state="translated">xGetTempnameメソッドはsqlite3_vfsから削除され&lt;a href=&quot;c3ref/vfs&quot;&gt;ました&lt;/a&gt;。その代わりに、xOpenメソッドは、filenameパラメータがNULLの場合に独自の発明の一時ファイルを開くように拡張されています。</target>
        </trans-unit>
        <trans-unit id="e9de98bc73bd358a33146535bc6a4c0838edf0ac" translate="yes" xml:space="preserve">
          <source>The xInit method initializes the memory allocator. For example, it might allocate any require mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.</source>
          <target state="translated">xInitメソッドは、メモリアロケータを初期化します。たとえば、必要なミューテックスを割り当てたり、内部データ構造を初期化したりできます。 xShutdownメソッドは&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;によって（間接的に）呼び出され、xInitによって取得されたすべてのリソースの割り当てを解除する必要があります。 pAppDataポインターは、xInitおよびxShutdownへの唯一のパラメーターとして使用されます。</target>
        </trans-unit>
        <trans-unit id="3fa9fa67f04b6378191cf480be2d31d4ea4b3e4c" translate="yes" xml:space="preserve">
          <source>The xInit method initializes the memory allocator. For example, it might allocate any require mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.</source>
          <target state="translated">xInitメソッドは、メモリアロケータを初期化します。たとえば、必要なミューテックスを割り当てたり、内部データ構造を初期化したりできます。 xShutdownメソッドは&lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;によって（間接的に）呼び出され、xInitによって取得されたすべてのリソースの割り当てを解除する必要があります。 pAppDataポインターは、xInitおよびxShutdownへの唯一のパラメーターとして使用されます。</target>
        </trans-unit>
        <trans-unit id="b5977e9a51901888e399d44616a096c8dd4ad36a" translate="yes" xml:space="preserve">
          <source>The xInit method initializes the memory allocator. For example, it might allocate any required mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.</source>
          <target state="translated">xInitメソッドは、メモリアロケータを初期化します。たとえば、必要なミューテックスを割り当てたり、内部データ構造を初期化したりする場合があります。xShutdownメソッドは&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;によって（間接的に）呼び出され、xInitによって取得されたリソースの割り当てを解除する必要があります。pAppDataポインターは、xInitおよびxShutdownへの唯一のパラメーターとして使用されます。</target>
        </trans-unit>
        <trans-unit id="f9b210b9a34cdea6b00c84f118c3818052de5137" translate="yes" xml:space="preserve">
          <source>The xInit method initializes the memory allocator. For example, it might allocate any required mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.</source>
          <target state="translated">xInitメソッドは、メモリアロケータを初期化します。たとえば、必要なミューテックスを割り当てたり、内部データ構造を初期化したりする場合があります。xShutdownメソッドは&lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;によって（間接的に）呼び出され、xInitによって取得されたリソースの割り当てを解除する必要があります。pAppDataポインターは、xInitおよびxShutdownへの唯一のパラメーターとして使用されます。</target>
        </trans-unit>
        <trans-unit id="928f04710edbd4aadd8a60154ed8a2e307eed0ef" translate="yes" xml:space="preserve">
          <source>The xInit() method is called once for each effective call to &lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize()&lt;/a&gt; (usually only once during the lifetime of the process). The xInit() method is passed a copy of the sqlite3_pcache_methods2.pArg value. The intent of the xInit() method is to set up global data structures required by the custom page cache implementation. If the xInit() method is NULL, then the built-in default page cache is used instead of the application defined page cache.</source>
          <target state="translated">xInit（）メソッドは、&lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize（）&lt;/a&gt;への有効な呼び出しごとに1回呼び出されます（通常、プロセスの存続期間中に1回だけ）。 xInit（）メソッドには、sqlite3_pcache_methods2.pArg値のコピーが渡されます。 xInit（）メソッドの目的は、カスタムページキャッシュの実装に必要なグローバルデータ構造をセットアップすることです。 xInit（）メソッドがNULLの場合、アプリケーションで定義されたページキャッシュの代わりに、組み込みのデフォルトページキャッシュが使用されます。</target>
        </trans-unit>
        <trans-unit id="6ba32c8d759124102ccc057ecbe6a0c1c85fb3b5" translate="yes" xml:space="preserve">
          <source>The xInit() method is called once for each effective call to &lt;a href=&quot;initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize()&lt;/a&gt; (usually only once during the lifetime of the process). The xInit() method is passed a copy of the sqlite3_pcache_methods2.pArg value. The intent of the xInit() method is to set up global data structures required by the custom page cache implementation. If the xInit() method is NULL, then the built-in default page cache is used instead of the application defined page cache.</source>
          <target state="translated">xInit（）メソッドは、&lt;a href=&quot;initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize（）&lt;/a&gt;への有効な呼び出しごとに1回呼び出されます（通常、プロセスの存続期間中に1回だけ）。 xInit（）メソッドには、sqlite3_pcache_methods2.pArg値のコピーが渡されます。 xInit（）メソッドの目的は、カスタムページキャッシュの実装に必要なグローバルデータ構造をセットアップすることです。 xInit（）メソッドがNULLの場合、アプリケーションで定義されたページキャッシュの代わりに、組み込みのデフォルトページキャッシュが使用されます。</target>
        </trans-unit>
        <trans-unit id="8a32ff6fcc7d9e120e222fe6ef8bbf8b9661df8a" translate="yes" xml:space="preserve">
          <source>The xLock and xUnlock methods are used to set and clear file locks. SQLite supports five levels of file locks, in order:</source>
          <target state="translated">xLock および xUnlock メソッドを使用して、ファイルロックを設定したりクリアしたりします。SQLite はファイルロックのレベルを順に 5 段階でサポートしています。</target>
        </trans-unit>
        <trans-unit id="8a5c74b276f4ba001214e303873304b1cefc6f0e" translate="yes" xml:space="preserve">
          <source>The xMalloc, xRealloc, and xFree methods must work like the malloc(), realloc() and free() functions from the standard C library. SQLite guarantees that the second argument to xRealloc is always a value returned by a prior call to xRoundup.</source>
          <target state="translated">xMalloc、xRealloc、および xFree メソッドは、標準 C ライブラリの malloc()、realloc()、および free()関数と同じように動作しなければなりません。SQLite は、xRealloc の第二引数は常に xRoundup の前の呼び出しで返された値であることを保証しています。</target>
        </trans-unit>
        <trans-unit id="f3c67d901eafc4b8170f137f64b1ed5325131c31" translate="yes" xml:space="preserve">
          <source>The xMutexEnd method defined by this structure is invoked as part of system shutdown by the sqlite3_shutdown() function. The implementation of this method is expected to release all outstanding resources obtained by the mutex methods implementation, especially those obtained by the xMutexInit method. The xMutexEnd() interface is invoked exactly once for each call to &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;.</source>
          <target state="translated">この構造によって定義されたxMutexEndメソッドは、sqlite3_shutdown（）関数によってシステムシャットダウンの一部として呼び出されます。このメソッドの実装は、mutexメソッドの実装によって取得されたすべての未解決のリソース、特にxMutexInitメソッドによって取得されたリソースを解放すると予想されます。xMutexEnd（）インターフェースは、&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown（）を&lt;/a&gt;呼び出すたびに1回だけ呼び出されます。</target>
        </trans-unit>
        <trans-unit id="29460abd69ce976afdb57bd86f856a912e6b2129" translate="yes" xml:space="preserve">
          <source>The xMutexEnd method defined by this structure is invoked as part of system shutdown by the sqlite3_shutdown() function. The implementation of this method is expected to release all outstanding resources obtained by the mutex methods implementation, especially those obtained by the xMutexInit method. The xMutexEnd() interface is invoked exactly once for each call to &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;.</source>
          <target state="translated">この構造によって定義されたxMutexEndメソッドは、sqlite3_shutdown（）関数によってシステムシャットダウンの一部として呼び出されます。このメソッドの実装は、mutexメソッドの実装によって取得されたすべての未解決のリソース、特にxMutexInitメソッドによって取得されたリソースを解放すると予想されます。xMutexEnd（）インターフェースは、&lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown（）を&lt;/a&gt;呼び出すたびに1回だけ呼び出されます。</target>
        </trans-unit>
        <trans-unit id="cd4f06c8938e3564cfbf224eac3d8cf5b5b06a0d" translate="yes" xml:space="preserve">
          <source>The xMutexInit method defined by this structure is invoked as part of system initialization by the sqlite3_initialize() function. The xMutexInit routine is called by SQLite exactly once for each effective call to &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt;.</source>
          <target state="translated">この構造によって定義されたxMutexInitメソッドは、sqlite3_initialize（）関数によるシステム初期化の一部として呼び出されます。xMutexInitルーチンは、&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;への有効な呼び出しごとに1回だけSQLiteによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="dab4cb79a586f29424445d440e5fffbfe8ba4495" translate="yes" xml:space="preserve">
          <source>The xMutexInit method defined by this structure is invoked as part of system initialization by the sqlite3_initialize() function. The xMutexInit routine is called by SQLite exactly once for each effective call to &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt;.</source>
          <target state="translated">この構造によって定義されたxMutexInitメソッドは、sqlite3_initialize（）関数によるシステム初期化の一部として呼び出されます。xMutexInitルーチンは、&lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;への有効な呼び出しごとに1回だけSQLiteによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="89ac720acef7b2cd1f40cadc5a9b4008a6051773" translate="yes" xml:space="preserve">
          <source>The xMutexInit() method must be threadsafe. It must be harmless to invoke xMutexInit() multiple times within the same process and without intervening calls to xMutexEnd(). Second and subsequent calls to xMutexInit() must be no-ops.</source>
          <target state="translated">xMutexInit()メソッドはスレッドセーフでなければなりません。同一プロセス内で xMutexEnd()への呼び出しを介さずに xMutexInit()を複数回呼び出すことは無害でなければなりません。2 回目以降の xMutexInit()の呼び出しは、何もしないようにしなければなりません。</target>
        </trans-unit>
        <trans-unit id="35cc67c51c972e7defc85a2cd19b646cf64aa418" translate="yes" xml:space="preserve">
          <source>The xNext method advances a &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;virtual table cursor&lt;/a&gt; to the next row of a result set initiated by &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;. If the cursor is already pointing at the last row when this routine is called, then the cursor no longer points to valid data and a subsequent call to the &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; method must return true (non-zero). If the cursor is successfully advanced to another row of content, then subsequent calls to &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; must return false (zero).</source>
          <target state="translated">xNextメソッドは、&lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;仮想テーブルカーソル&lt;/a&gt;を&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;によって開始された結果セットの次の行に進めます。このルーチンが呼び出されたときにカーソルがすでに最後の行を指している場合、カーソルは有効なデータを指していません。その後の&lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt;メソッドの呼び出しはtrue（ゼロ以外）を返す必要があります。カーソルがコンテンツの別の行に正常に進んだ場合、その後の&lt;a href=&quot;vtab#xeof&quot;&gt;xEofの&lt;/a&gt;呼び出しはfalse（ゼロ）を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="c07bbf2e5005e8108d2f1c166d0b989d5b0ef5de" translate="yes" xml:space="preserve">
          <source>The xNext method is required for every virtual table implementation.</source>
          <target state="translated">xNext メソッドは、すべての仮想テーブルの実装で必須です。</target>
        </trans-unit>
        <trans-unit id="eee0d952c4251db31a384eceabf2a26d2118eb4d" translate="yes" xml:space="preserve">
          <source>The xOpen method creates a new cursor used for accessing (read and/or writing) a virtual table. A successful invocation of this method will allocate the memory for the &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; (or a subclass), initialize the new object, and make *ppCursor point to the new object. The successful call then returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">xOpenメソッドは、仮想テーブルへのアクセス（読み取りおよび/または書き込み）に使用される新しいカーソルを作成します。このメソッドの呼び出しが成功すると、&lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt;（またはサブクラス）にメモリが割り当てられ、新しいオブジェクトが初期化され、* ppCursorが新しいオブジェクトを指すようになります。成功した呼び出しは&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="00b35252e3240b77ad5fc35ac862013d23c8ea89" translate="yes" xml:space="preserve">
          <source>The xOpen method is required for every virtual table implementation.</source>
          <target state="translated">xOpen メソッドは、すべての仮想テーブルの実装で必須です。</target>
        </trans-unit>
        <trans-unit id="fe219d8e760e2d5872424a8a4fa6980f7d9bd820" translate="yes" xml:space="preserve">
          <source>The xOpen method need not initialize the pVtab field of the &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; structure. The SQLite core will take care of that chore automatically.</source>
          <target state="translated">xOpenメソッドは、&lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt;構造体のpVtabフィールドを初期化する必要はありません。SQLiteコアはその雑用を自動的に処理します。</target>
        </trans-unit>
        <trans-unit id="5883a2e08ea426f3d0e98ebbcc84b207e43eeb5d" translate="yes" xml:space="preserve">
          <source>The xOutput callback is invoked zero or more times to return data to the application. The first parameter passed to each call is a copy of the pOut pointer supplied by the application. The second parameter, pData, points to a buffer nData bytes in size containing the chunk of output data being returned. If the xOutput callback successfully processes the supplied data, it should return SQLITE_OK to indicate success. Otherwise, it should return some other SQLite error code. In this case processing is immediately abandoned and the streaming API function returns a copy of the xOutput error code to the application.</source>
          <target state="translated">xOutput コールバックは、アプリケーションにデータを返すために 0 回以上呼び出されます。各コールに渡される最初のパラメータは、アプリケーションから供給された pOut ポインタのコピーです。2 番目のパラメータ pData は、返される出力データのチャンクを含むサイズのバッファ nData バイトを指します。xOutput コールバックが供給されたデータの処理に成功した場合、成功を示す SQLITE_OK を返します。それ以外の場合は、他の SQLite エラーコードを返します。この場合、処理は直ちに中止され、ストリーミング API 関数は xOutput エラー コードのコピーをアプリケーションに返します。</target>
        </trans-unit>
        <trans-unit id="4fdec734fe0825d4b45223206e7ef21a40dca7d6" translate="yes" xml:space="preserve">
          <source>The xPagecount() method must return the number of pages currently stored in the cache, both pinned and unpinned.</source>
          <target state="translated">xPagecount()メソッドは、現在キャッシュに保存されているページ数を返さなければなりません。</target>
        </trans-unit>
        <trans-unit id="f7670800549df532ce782308a5027526fc2bbf4f" translate="yes" xml:space="preserve">
          <source>The xQueryFunc must set the eWithin field of sqlite3_rtree_query_info to one of the values NOT_WITHIN, PARTLY_WITHIN, or FULLY_WITHIN depending on whether or not the bounding box defined by aCoord[] is completely outside the region, overlaps the region, or is completely inside the region, respectively. In addition, the xQueryFunc must set the rScore field to a non-negative value that indicates the order in which subtrees and entries of the query should be analyzed and returned. Smaller scores are processed first.</source>
          <target state="translated">xQueryFuncは、sqlite3_rtree_query_infoのeWithinフィールドを、aCoord[]で定義されたバウンディングボックスが完全に領域の外にあるか、領域に重なっているか、完全に領域の内側にあるかに応じて、それぞれNOT_WITHIN、PARTLY_WITHIN、FULLY_WITHINのいずれかの値に設定しなければならない。さらに、xQueryFuncは、rScoreフィールドに、クエリのサブツリーとエントリが解析されて返されるべき順序を示す非負の値を設定しなければならない。スコアが小さいものが最初に処理されます。</target>
        </trans-unit>
        <trans-unit id="243e65d787818469363333eb640b0b44f38c6ec4" translate="yes" xml:space="preserve">
          <source>The xRandomness method is used exactly once to initialize the pseudo-random number generator (PRNG) inside of SQLite. Only the xRandomness method on the default VFS is used. The xRandomness methods on other VFSes are never accessed by SQLite. The xRandomness routine requests that nByte bytes of randomness be written into zOut. The routine returns the actual number of bytes of randomness obtained. The quality of the randomness so obtained will determine the quality of the randomness generated by built-in SQLite functions such as random() and randomblob(). SQLite also uses its PRNG to generate temporary file names. On some platforms (ex: Windows) SQLite assumes that temporary file names are unique without actually testing for collisions, so it is important to have good-quality randomness even if the random() and randomblob() functions are never used.</source>
          <target state="translated">xRandomnessメソッドは、SQLite内部の疑似乱数発生器(PRNG)を初期化するために一度だけ使用します。デフォルトの VFS 上の xRandomness メソッドのみが使用されます。他の VFS 上の xRandomness メソッドは、SQLite からアクセスされることはありません。xRandomness ルーチンは、ランダムネスの nByte バイトを zOut に書き込むように要求します。ルーチンは、得られたランダム性の実際のバイト数を返します。得られたランダム性の質は、random()や randlob()などの SQLite の組み込み関数によって生成されたランダム性の質を決定します。SQLite は PRNG を使用して一時的なファイル名を生成します。プラットフォームによっては(Windows など)、SQLite は衝突を実際にテストせずに一時ファイル名が一意であることを前提としているので、たとえ random()や randlob()関数が使用されなかったとしても、質の良いランダム性を持つことが重要です。</target>
        </trans-unit>
        <trans-unit id="2203fe5d9da94fc2d593e73757d6951b646a5aac" translate="yes" xml:space="preserve">
          <source>The xRandomness(), xSleep(), xCurrentTime(), and xCurrentTimeInt64() interfaces are not strictly a part of the filesystem, but they are included in the VFS structure for completeness. The xRandomness() function attempts to return nBytes bytes of good-quality randomness into zOut. The return value is the actual number of bytes of randomness obtained. The xSleep() method causes the calling thread to sleep for at least the number of microseconds given. The xCurrentTime() method returns a Julian Day Number for the current date and time as a floating point value. The xCurrentTimeInt64() method returns, as an integer, the Julian Day Number multiplied by 86400000 (the number of milliseconds in a 24-hour day). SQLite will use the xCurrentTimeInt64() method to get the current date and time if that method is available (if iVersion is 2 or greater and the function pointer is not NULL) and will fall back to xCurrentTime() if xCurrentTimeInt64() is unavailable.</source>
          <target state="translated">xRandomness()、xSleep()、xCurrentTime()、およびxCurrentTimeInt64()インターフェイスは、厳密にはファイルシステムの一部ではありませんが、完全性を確保するために VFS 構造体に含まれています。xRandomness()関数は、品質の良いランダム性の nBytes バイトを zOut に戻そうとします。返される値は、得られたランダム性の実際のバイト数です。xSleep()メソッドは、少なくとも指定されたマイクロ秒数だけスレッドをスリープさせます。xCurrentTime()メソッドは、現在の日付と時刻のユリウス日番号を浮動小数点値として返します。xCurrentTimeInt64()メソッドは、整数として、ジュリアン日番号に 86400000 (24 時間の 1 日のミリ秒数)を掛けたものを返します。SQLite は、xCurrentTimeInt64()メソッドが使用可能な場合 (iVersion が 2 以上で関数ポインタが NULL でない場合)には xCurrentTimeInt64()メソッドを使用して現在の日付と時刻を取得し、xCurrentTimeInt64()が使用できない場合は xCurrentTime()にフォールバックします。</target>
        </trans-unit>
        <trans-unit id="9578c347ea12c88b2a68bb1b8891cc899dd6f688" translate="yes" xml:space="preserve">
          <source>The xRead method reads iAmt bytes from the file beginning at a byte offset to iOfst. The data read is stored in the pointer of the second parameter. xRead returns the &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success, &lt;a href=&quot;rescode#ioerr_short_read&quot;&gt;SQLITE_IOERR_SHORT_READ&lt;/a&gt; if it was not able to read the full number of bytes because it reached end-of-file, or &lt;a href=&quot;rescode#ioerr_read&quot;&gt;SQLITE_IOERR_READ&lt;/a&gt; for any other error.</source>
          <target state="translated">xReadメソッドは、iOfstへのバイトオフセットで始まるファイルからiAmtバイトを読み取ります。読み込まれたデータは、2番目のパラメーターのポインターに格納されます。 XREADを返し&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;、成功した場合には&lt;a href=&quot;rescode#ioerr_short_read&quot;&gt;SQLITE_IOERR_SHORT_READ&lt;/a&gt;、それはファイルの終わりに達した、またはので、バイトの完全な数を読み取ることができなかった場合&lt;a href=&quot;rescode#ioerr_read&quot;&gt;SQLITE_IOERR_READ&lt;/a&gt;その他のエラーのために。</target>
        </trans-unit>
        <trans-unit id="179305437ddf972de11f25d6c031548629b7dbeb" translate="yes" xml:space="preserve">
          <source>The xRekey() method is used to change the key value associated with the page passed as the second argument. If the cache previously contains an entry associated with newKey, it must be discarded. Any prior cache entry associated with newKey is guaranteed not to be pinned.</source>
          <target state="translated">xRekey()メソッドは、第二引数として渡されたページに関連付けられたキー値を変更するために使用されます。キャッシュに newKey に関連付けられたエントリが以前に含まれていた場合は、それを破棄しなければなりません。newKey に関連付けられた以前のキャッシュエントリは、固定されないことが保証されています。</target>
        </trans-unit>
        <trans-unit id="ee97077a16637439ff4f073f89fa74d3ae66efba" translate="yes" xml:space="preserve">
          <source>The xRename method is optional. If omitted, then the virtual table may not be renamed using the ALTER TABLE RENAME command.</source>
          <target state="translated">xRename メソッドはオプションです。省略した場合は、ALTER TABLE RENAME コマンドを使用して仮想テーブルの名前を変更することはできません。</target>
        </trans-unit>
        <trans-unit id="ac1529fc1db9096e5e7532c56994cf7e11a7e7d4" translate="yes" xml:space="preserve">
          <source>The xRoundup method returns what would be the allocated size of a memory allocation given a particular requested size. Most memory allocators round up memory allocations at least to the next multiple of 8. Some allocators round up to a larger multiple or to a power of 2. Every memory allocation request coming in through &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt; first calls xRoundup. If xRoundup returns 0, that causes the corresponding memory allocation to fail.</source>
          <target state="translated">xRoundupメソッドは、特定の要求されたサイズが与えられた場合のメモリ割り当ての割り当てサイズを返します。ほとんどのメモリアロケータは、少なくとも8の次の倍数にメモリ割り当てを切り上げます。一部のアロケータは、より大きい倍数または2の&lt;a href=&quot;#sqlite3_free&quot;&gt;累乗に切り上げます。sqlite3_malloc（）&lt;/a&gt;または&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc（）を&lt;/a&gt;介して着信するすべてのメモリ割り当て要求は、最初にxRoundupを呼び出します。xRoundupが0を返す場合、対応するメモリ割り当てが失敗します。</target>
        </trans-unit>
        <trans-unit id="5558ee9f292501795b089dc2d3175bf349258bae" translate="yes" xml:space="preserve">
          <source>The xRoundup method returns what would be the allocated size of a memory allocation given a particular requested size. Most memory allocators round up memory allocations at least to the next multiple of 8. Some allocators round up to a larger multiple or to a power of 2. Every memory allocation request coming in through &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt; first calls xRoundup. If xRoundup returns 0, that causes the corresponding memory allocation to fail.</source>
          <target state="translated">xRoundupメソッドは、特定の要求されたサイズが与えられた場合のメモリ割り当ての割り当てサイズを返します。ほとんどのメモリアロケータは、少なくとも8の次の倍数にメモリ割り当てを切り上げます。一部のアロケータは、より大きい倍数または2の&lt;a href=&quot;free&quot;&gt;累乗に切り上げます。sqlite3_malloc（）&lt;/a&gt;または&lt;a href=&quot;free&quot;&gt;sqlite3_realloc（）を&lt;/a&gt;介して着信するすべてのメモリ割り当て要求は、最初にxRoundupを呼び出します。xRoundupが0を返す場合、対応するメモリ割り当てが失敗します。</target>
        </trans-unit>
        <trans-unit id="ac776ca96c027496fe8cb024585d72e01e0bde03" translate="yes" xml:space="preserve">
          <source>The xRowid method is required for every virtual table implementation.</source>
          <target state="translated">xRowid メソッドは、すべての仮想テーブルの実装で必須です。</target>
        </trans-unit>
        <trans-unit id="f91951a49d3cd2a19053a4c5034726651d8bcc0a" translate="yes" xml:space="preserve">
          <source>The xSectorSize returns the &quot;sector size&quot; of the underlying non-volatile media. A &quot;sector&quot; is defined as the smallest unit of storage that can be written without disturbing adjacent storage. On a disk drive the &quot;sector size&quot; has until recently been 512 bytes, though there is a push to increase this value to 4KiB. SQLite needs to know the sector size so that it can write a full sector at a time, and thus avoid corrupting adjacent storage space if a power loss occurs in the middle of a write.</source>
          <target state="translated">xSectorSize は、基礎となる不揮発性メディアの「セクタサイズ」を返します。セクタ」とは、隣接するストレージに影響を与えずに書き込めるストレージの最小単位と定義されています。ディスクドライブの「セクタサイズ」は最近まで512バイトでしたが、現在ではこの値を4KiBに引き上げる動きがあります。SQLite は、一度に完全なセクタを書き込めるようにセクタサイズを知る必要があり、書き込みの途中で停電が発生しても隣接するストレージスペースが破損しないようにします。</target>
        </trans-unit>
        <trans-unit id="7905596593f9a3650933e2dff7d4278590e16d18" translate="yes" xml:space="preserve">
          <source>The xSectorSize() method returns the sector size of the device that underlies the file. The sector size is the minimum write that can be performed without disturbing other bytes in the file. The xDeviceCharacteristics() method returns a bit vector describing behaviors of the underlying device:</source>
          <target state="translated">xSectorSize()メソッドは、ファイルの下敷きになっているデバイスのセクタサイズを返します。セクタサイズは、ファイル内の他のバイトに影響を与えることなく実行できる最小の書き込みサイズです。xDeviceCharacteristics()メソッドは、基礎となるデバイスの動作を記述したビットベクトルを返します。</target>
        </trans-unit>
        <trans-unit id="c28ec934424705226c30dba3dc7fb3bbb1c98c66" translate="yes" xml:space="preserve">
          <source>The xSetSystemCall(), xGetSystemCall(), and xNestSystemCall() interfaces are not used by the SQLite core. These optional interfaces are provided by some VFSes to facilitate testing of the VFS code. By overriding system calls with functions under its control, a test program can simulate faults and error conditions that would otherwise be difficult or impossible to induce. The set of system calls that can be overridden varies from one VFS to another, and from one version of the same VFS to the next. Applications that use these interfaces must be prepared for any or all of these interfaces to be NULL or for their behavior to change from one release to the next. Applications must not attempt to access any of these methods if the iVersion of the VFS is less than 3.</source>
          <target state="translated">xSetSystemCall()、xGetSystemCall()、および xNestSystemCall()インターフェイスは、SQLite コアでは使用されません。これらのオプションのインターフェイスは、VFS コードのテストを容易にするために、いくつかの VFS によって提供されています。制御下の関数でシステムコールをオーバーライドすることで、テストプログラムは、そうでなければ誘発することが困難であったり、不可能であったりする障害やエラー状態をシミュレートすることができます。オーバーライドできるシステムコールのセットは、VFS によって異なりますし、同じ VFS のバージョンによっても異なります。これらのインターフェイスを使用するアプリケーションは、これらのインターフェイスの一部または全部が NULL になったり、あるリリースから次のリリースへと動作が変更されたりすることに備えなければなりません。アプリケーションは、VFS の iVersion が 3 未満の場合、これらのメソッドへのアクセスを試みてはなりません。</target>
        </trans-unit>
        <trans-unit id="5423cabb179d0301d2f1838406af9e345543b685" translate="yes" xml:space="preserve">
          <source>The xShadowName method exists to allow SQLite to determine whether a certain real table is in fact a shadow table for a virtual table.</source>
          <target state="translated">xShadowName メソッドは、SQLite がある実在のテーブルが実際に仮想テーブルのシャドウテーブルであるかどうかを判断できるようにするために存在します。</target>
        </trans-unit>
        <trans-unit id="947c2bf35d5cbfd4ce5579dacd8c602d7123b2d2" translate="yes" xml:space="preserve">
          <source>The xShadowName method returns true when its input is the part of the table name past the last &quot;_&quot; character.</source>
          <target state="translated">xShadowNameメソッドは、その入力がテーブル名の最後の&quot;_&quot;文字以降の部分である場合に真を返します。</target>
        </trans-unit>
        <trans-unit id="bb9ed2671c0267a52c772896119a40dfbdf41d3e" translate="yes" xml:space="preserve">
          <source>The xShmLock method can transition between unlocked and SHARED or between unlocked and EXCLUSIVE. It cannot transition between SHARED and EXCLUSIVE.</source>
          <target state="translated">xShmLockメソッドは、unlockedとSHAREDの間、またはunlockedとEXCLUSIVEの間で遷移することができます。SHAREDとEXCLUSIVEの間で遷移することはできません。</target>
        </trans-unit>
        <trans-unit id="3b138a7b2ca75c6da01e38d919aae9bc4beaeeca" translate="yes" xml:space="preserve">
          <source>The xShmLock method on &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; may use values between 0 and this upper bound as its &quot;offset&quot; argument. The SQLite core will never attempt to acquire or release a lock outside of this range</source>
          <target state="translated">上xShmLock方法&lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methodsは&lt;/a&gt; 0の間の値を使用することができ、これは、上部の「オフセット」引数としてバインド。SQLiteコアは、この範囲外のロックを取得または解放しようとはしません</target>
        </trans-unit>
        <trans-unit id="99e14d7c5dc9f436dda83c4868de4dcfa29aa8e2" translate="yes" xml:space="preserve">
          <source>The xShmLock method on &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; may use values between 0 and this upper bound as its &quot;offset&quot; argument. The SQLite core will never attempt to acquire or release a lock outside of this range</source>
          <target state="translated">上xShmLock方法&lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methodsは&lt;/a&gt; 0の間の値を使用することができ、これは、上部の「オフセット」引数としてバインド。SQLiteコアは、この範囲外のロックを取得または解放しようとはしません</target>
        </trans-unit>
        <trans-unit id="c9d6171767cbe080777a834fc404f8313c3bd7a0" translate="yes" xml:space="preserve">
          <source>The xShutdown() method is called by &lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. It can be used to clean up any outstanding resources before process shutdown, if required. The xShutdown() method may be NULL.</source>
          <target state="translated">xShutdown（）メソッドは&lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;によって呼び出されます。必要に応じて、プロセスのシャットダウン前に未処理のリソースをクリーンアップするために使用できます。xShutdown（）メソッドはNULLである可能性があります。</target>
        </trans-unit>
        <trans-unit id="89b517d093efdb5642222dcbac94dd78a355996a" translate="yes" xml:space="preserve">
          <source>The xShutdown() method is called by &lt;a href=&quot;initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. It can be used to clean up any outstanding resources before process shutdown, if required. The xShutdown() method may be NULL.</source>
          <target state="translated">xShutdown（）メソッドは&lt;a href=&quot;initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown（）&lt;/a&gt;によって呼び出されます。必要に応じて、プロセスのシャットダウン前に未処理のリソースをクリーンアップするために使用できます。xShutdown（）メソッドはNULLである可能性があります。</target>
        </trans-unit>
        <trans-unit id="809b6a168241db65edee19e686edd4e9bd3b2bfa" translate="yes" xml:space="preserve">
          <source>The xSleep method is used to suspend the calling thread for at least the number of microseconds given. This method is used to implement the &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep()&lt;/a&gt; and &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; APIs. In the case of &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep()&lt;/a&gt; the xSleep method of the default VFS is always used. If the underlying system does not have a microsecond resolution sleep capability, then the sleep time should be rounded up. xSleep returns this rounded-up value.</source>
          <target state="translated">xSleepメソッドは、少なくとも指定されたマイクロ秒数の間、呼び出しスレッドを一時停止するために使用されます。このメソッドは、&lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep（）&lt;/a&gt;および&lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt; API を実装するために使用されます。&lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep（）の&lt;/a&gt;場合、デフォルトのVFSのxSleepメソッドが常に使用されます。基盤となるシステムにマイクロ秒の解像度のスリープ機能がない場合は、スリープ時間を切り上げる必要があります。xSleepは、この切り上げられた値を返します。</target>
        </trans-unit>
        <trans-unit id="097b3f659c15f2c222834063189d1813c9097500" translate="yes" xml:space="preserve">
          <source>The xSync method is called again, to ensure that the update to the</source>
          <target state="translated">への更新が確実に行われるように、xSyncメソッドが再度呼び出されます。</target>
        </trans-unit>
        <trans-unit id="c43866c10fb70246bff455fcc260272ec7695054" translate="yes" xml:space="preserve">
          <source>The xSync method is used to force previously written data out of operating system cache and into non-volatile memory. The second parameter is usually &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt;. If the second parameter is &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt; then the xSync method should make sure that data has also been flushed through the disk controllers cache. The &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt; parameter is the equivalent of the F_FULLSYNC ioctl() on Mac OS X. The xSync method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_fsync&quot;&gt;SQLITE_IOERR_FSYNC&lt;/a&gt; if anything goes wrong.</source>
          <target state="translated">xSyncメソッドは、以前に書き込まれたデータをオペレーティングシステムキャッシュから不揮発性メモリに強制的に書き込むために使用されます。通常、2番目のパラメーターは&lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt;です。 2番目のパラメーターが&lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULLの&lt;/a&gt;場合、xSyncメソッドは、ディスクコントローラーキャッシュを介してデータもフラッシュされていることを確認する必要があります。&lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULLの&lt;/a&gt;パラメータは、Mac OS X.ザ・XSYNC法に）F_FULLSYNCのioctl（と同等である返し&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OKを&lt;/a&gt;成功と上&lt;a href=&quot;rescode#ioerr_fsync&quot;&gt;SQLITE_IOERR_FSYNC&lt;/a&gt;何かがうまくいかない場合。</target>
        </trans-unit>
        <trans-unit id="d363e92ec2dbc091f6f79c8b02f677c3bfbb4dc4" translate="yes" xml:space="preserve">
          <source>The xSync method of the file-handle opened on the journal file is called. This operation ensures that all</source>
          <target state="translated">ジャーナルファイル上で開かれたファイルハンドルのxSyncメソッドが呼び出されます。この操作により、すべての</target>
        </trans-unit>
        <trans-unit id="2abc7e1d2661195eacab3734a083049181c96938" translate="yes" xml:space="preserve">
          <source>The xTruncate method truncates a file to be nByte bytes in length. If the file is already nByte bytes or less in length then this method is a no-op. The xTruncate method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_truncate&quot;&gt;SQLITE_IOERR_TRUNCATE&lt;/a&gt; if anything goes wrong.</source>
          <target state="translated">xTruncateメソッドは、ファイルをnByteバイトの長さに切り詰めます。ファイルの長さがすでにnByteバイト以下の場合、このメソッドは何もしません。xTruncateメソッドは、成功すると&lt;a href=&quot;rescode#ioerr_truncate&quot;&gt;SQLITE_OKを&lt;/a&gt;返し、&lt;a href=&quot;rescode#ok&quot;&gt;問題&lt;/a&gt;が発生するとSQLITE_IOERR_TRUNCATEを返します。</target>
        </trans-unit>
        <trans-unit id="264cd9fc05e84b4a4186bdf81ed3b9dddd14f364" translate="yes" xml:space="preserve">
          <source>The xUpdate method is optional. If the xUpdate pointer in the &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; for a virtual table is a NULL pointer, then the virtual table is read-only.</source>
          <target state="translated">xUpdateメソッドはオプションです。仮想テーブルの&lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_moduleの&lt;/a&gt; xUpdateポインターがNULLポインターの場合、仮想テーブルは読み取り専用です。</target>
        </trans-unit>
        <trans-unit id="e7991b9300a6d5d1e9dd517f980e91bd729b810d" translate="yes" xml:space="preserve">
          <source>The xUpdate method must return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if and only if it is successful. If a failure occurs, the xUpdate must return an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;. On a failure, the pVTab-&amp;gt;zErrMsg element may optionally be replaced with error message text stored in memory allocated from SQLite using functions such as &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; or &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;.</source>
          <target state="translated">xUpdateメソッドは、成功した場合にのみ、&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OKを&lt;/a&gt;返す必要があります。エラーが発生した場合、xUpdateは適切な&lt;a href=&quot;rescode&quot;&gt;エラーコードを&lt;/a&gt;返す必要があります。失敗した場合、pVTab-&amp;gt; zErrMsg要素は、&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;や&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;などの関数を使用して、SQLiteから割り当てられたメモリに格納されたエラーメッセージテキストで任意に置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="4f4c20f5295bf2671dba3e7fbec564fd71238ee3" translate="yes" xml:space="preserve">
          <source>The xUpdate method will do a DELETE or an INSERT or both. The argv[0] element (which corresponds to memory cell P3) is the rowid of a row to delete. If argv[0] is NULL then no deletion occurs. The argv[1] element is the rowid of the new row. This can be NULL to have the virtual table select the new rowid for itself. The subsequent elements in the array are the values of columns in the new row.</source>
          <target state="translated">xUpdateメソッドは、DELETEまたはINSERT、またはその両方を行います。argv[0]要素(メモリセルP3に対応)は、削除する行の行IDです。argv[0]がNULLの場合、削除は行われません。argv[1]要素は、新しい行の行IDである。これを NULL にすると、仮想テーブルが新しい行 ID を選択するようになります。配列の後続の要素は、新しい行のカラムの値となります。</target>
        </trans-unit>
        <trans-unit id="dce6593181b88387e0232c4fe3315ea114b78c31" translate="yes" xml:space="preserve">
          <source>The xWrite method writes iAmt bytes of data from the second parameter into the file beginning at an offset of iOfst bytes. If the size of the file is less than iOfst bytes prior to the write, then xWrite should ensure that the file is extended with zeros up to iOfst bytes prior to beginning its write. xWrite continues to extends the file as necessary so that the size of the file is at least iAmt+iOfst bytes at the conclusion of the xWrite call. The xWrite method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success. If the write cannot complete because the underlying storage medium is full, then &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; is returned. &lt;a href=&quot;rescode#ioerr_write&quot;&gt;SQLITE_IOERR_WRITE&lt;/a&gt; should be returned for any other error.</source>
          <target state="translated">xWriteメソッドは、iOfstバイトのオフセットで始まる2番目のパラメーターからiAmtバイトのデータをファイルに書き込みます。ファイルのサイズが書き込み前のiOfstバイトよりも小さい場合、xWriteは、書き込みを開始する前に、ファイルがゼロで最大iOfstバイトまで拡張されるようにする必要があります。 xWriteは、必要に応じてファイルを拡張し続けるため、xWrite呼び出しの終了時に、ファイルのサイズは少なくともiAmt + iOfstバイトになります。 xWriteメソッドは成功すると&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;を返します。基になるストレージメディアがいっぱいであるために書き込みを完了できない場合、&lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;が返されます。その他のエラーの場合、&lt;a href=&quot;rescode#ioerr_write&quot;&gt;SQLITE_IOERR_WRITE&lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="d58a45ae0f446bdb86db23efea40a4365e8b2411" translate="yes" xml:space="preserve">
          <source>The zFormat string must not be NULL.</source>
          <target state="translated">zFormat 文字列は NULL であってはなりません。</target>
        </trans-unit>
        <trans-unit id="4f80fc797d2d3e861743d9ee1212caa09c71f3bc" translate="yes" xml:space="preserve">
          <source>The zName field holds the name of the VFS module. The name must be unique across all VFS modules.</source>
          <target state="translated">zName フィールドは、VFS モジュールの名前を保持します。この名前は、すべての VFS モジュールで一意である必要があります。</target>
        </trans-unit>
        <trans-unit id="2e8507d62c194c1ae3ea2e8955ca09d80822bd5b" translate="yes" xml:space="preserve">
          <source>The zName field is the symbolic name of the VFS. This is the name that the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; compares against when it is looking for a VFS.</source>
          <target state="translated">zNameフィールドは、VFSの記号名です。これは、&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find（）&lt;/a&gt;がVFSを探すときに比較する名前です。</target>
        </trans-unit>
        <trans-unit id="159171a13f5482b6256b050c73e581c3c1ed7fde" translate="yes" xml:space="preserve">
          <source>The zeroblob(N) function returns a BLOB consisting of N bytes of 0x00. SQLite manages these zeroblobs very efficiently. Zeroblobs can be used to reserve space for a BLOB that is later written using &lt;a href=&quot;c3ref/blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt;. This SQL function is implemented using the &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_zeroblob()&lt;/a&gt; routine from the C/C++ interface.</source>
          <target state="translated">zeroblob（N）関数は、Nバイトの0x00で構成されるBLOBを返します。SQLiteはこれらのゼロブロブを非常に効率的に管理します。Zeroblobsを使用すると、後で&lt;a href=&quot;c3ref/blob_open&quot;&gt;増分BLOB I / O&lt;/a&gt;を使用して書き込まれるBLOBのスペースを予約できます。このSQL関数は、C / C ++インターフェースの&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_zeroblob（）&lt;/a&gt;ルーチンを使用して実装されます。</target>
        </trans-unit>
        <trans-unit id="211680c2a7f3cd39edd65730ba2dc5798231d4d2" translate="yes" xml:space="preserve">
          <source>The zipfile module provides read/write access to simple &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_%28file_format%29&quot;&gt;ZIP archives&lt;/a&gt;. The current implementation has the following restrictions:</source>
          <target state="translated">zipfileモジュールは、単純な&lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_%28file_format%29&quot;&gt;ZIPアーカイブ&lt;/a&gt;への読み取り/書き込みアクセスを提供します。現在の実装には、次の制限があります。</target>
        </trans-unit>
        <trans-unit id="1b7b70776cb9a79f5d42a047fb481e44592ef0cc" translate="yes" xml:space="preserve">
          <source>The zipfile module provides three similar interfaces for accessing, updating and creating zip file archives:</source>
          <target state="translated">zipfile モジュールは、zip ファイルアーカイブへのアクセス、更新、作成のための 3 つの類似したインターフェイスを提供します。</target>
        </trans-unit>
        <trans-unit id="a3bf102cd7b1098b918321543923b0fbcf9afd25" translate="yes" xml:space="preserve">
          <source>The zipfile module provides two similar interfaces for accessing zip archives. A table-valued function, which provides read-only access to existing archives, and a virtual table interface, which provides both read and write access.</source>
          <target state="translated">zipfile モジュールは、zip アーカイブにアクセスするための二つの類似したインターフェイスを提供します。既存のアーカイブへの読み込み専用のアクセスを提供するテーブル値関数と、 読み込みと書き込みの両方のアクセスを提供する仮想テーブルインターフェースです。</target>
        </trans-unit>
        <trans-unit id="7f26831f509249abeae6c04bd252c7253425a19e" translate="yes" xml:space="preserve">
          <source>The zipfile() aggregate function may be called with 2, 4 or 5 arguments. If it is called with 5 arguments, then the entry added to the archive is equivalent to inserting the same values into the &quot;name&quot;, &quot;mode&quot;, &quot;mtime&quot;, &quot;data&quot; and &quot;method&quot; columns of a zipfile virtual table.</source>
          <target state="translated">zipfile()の集約関数は、2、4、5 のいずれかの引数で呼び出すことができます。5 つの引数で呼ばれた場合、アーカイブに追加されるエントリは、zipfile 仮想テーブルの &quot;name&quot;、&quot;mode&quot;、&quot;mtime&quot;、&quot;data&quot; および &quot;method&quot; カラムに同じ値を挿入することと同等のものとなります。</target>
        </trans-unit>
        <trans-unit id="fda3c54068d6592ac94595a28e9ae2b5a7631d94" translate="yes" xml:space="preserve">
          <source>Then any query that uses operators =, &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=, &amp;lt;&amp;gt;, IN, LIKE, or GLOB on column &quot;c&quot; would be usable with the partial index because those comparison operators are only true if &quot;c&quot; is not NULL. So the following query could use the partial index:</source>
          <target state="translated">次に、列「c」で演算子=、&amp;lt;、&amp;gt;、&amp;lt;=、&amp;gt; =、&amp;lt;&amp;gt;、IN、LIKE、またはGLOBを使用するクエリは、部分インデックスで使用できます。 NULLではありません。したがって、次のクエリは部分インデックスを使用できます。</target>
        </trans-unit>
        <trans-unit id="d38e46789e87cb85236cff516beec8a98a69642c" translate="yes" xml:space="preserve">
          <source>Then continue to merge the changes in &quot;trunk&quot; with your &quot;private&quot; changes as described in section 3.7.</source>
          <target state="translated">その後、3.7項で説明したように、「trunk」の変更を「private」の変更にマージし続けます。</target>
        </trans-unit>
        <trans-unit id="4221ef1a5952683847cd93186bb995482d485923" translate="yes" xml:space="preserve">
          <source>Then creating &lt;a href=&quot;lang_createview&quot;&gt;VIEWs&lt;/a&gt; in that schema that implement the official information schema tables using table-valued PRAGMA functions.</source>
          <target state="translated">次に、そのスキーマで、テーブル値のPRAGMA関数を使用して公式情報スキーマテーブルを実装する&lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt;を作成します。</target>
        </trans-unit>
        <trans-unit id="24143dcd35d1fb5f0ef327aba489cfb57e18e5f5" translate="yes" xml:space="preserve">
          <source>Then download the new version of the SQLite sources and overwrite the files that are in the checkout.</source>
          <target state="translated">そして、新しいバージョンのSQLiteソースをダウンロードして、チェックアウトに入っているファイルを上書きします。</target>
        </trans-unit>
        <trans-unit id="350d0a66ff74448747b37fd69238737bb7294306" translate="yes" xml:space="preserve">
          <source>Then either of the two queries below may be executed to find the number of documents in the database that contain the word &quot;linux&quot; (351). Using one desktop PC hardware configuration, the query on the FTS3 table returns in approximately 0.03 seconds, versus 22.5 for querying the ordinary table.</source>
          <target state="translated">次に、以下の2つのクエリのいずれかを実行して、「linux」という単語を含むデータベース内のドキュメントの数を見つけることができます(351)。1台のデスクトップPCのハードウェア構成を使用すると、FTS3テーブルのクエリは約0.03秒で返されるのに対し、通常のテーブルのクエリは22.5秒で返されます。</target>
        </trans-unit>
        <trans-unit id="dec93deaca5432fc2b3655d16d3eb7b184d40788" translate="yes" xml:space="preserve">
          <source>Then for each &quot;id&quot; value returned, suppose the application creates an UPDATE statement like the following and binds the &quot;id&quot; value returned against the &quot;?1&quot; parameter:</source>
          <target state="translated">そして、返された各 &quot;id &quot;値に対して、アプリケーションが以下のようなUPDATE文を作成し、返された &quot;id &quot;値を&quot;?1 &quot;パラメータにバインドしたとします。</target>
        </trans-unit>
        <trans-unit id="b72f2d807bd1572c917e30647dff75353e7ffc89" translate="yes" xml:space="preserve">
          <source>Then let the application maintain a separate pool of larger lookaside memory buffers that it can distribute to &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; as they are created. In the common case, the application will only have a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; and so the lookaside memory pool can consist of a single large buffer.</source>
          <target state="translated">次に、アプリケーションに、&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;が作成されたときにデータベース接続に配布できる、より大きなlookasideメモリバッファーの個別のプールを維持させます。一般的なケースでは、アプリケーションは単一の&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;しか持たないため、lookasideメモリプールは単一の大きなバッファーで構成できます。</target>
        </trans-unit>
        <trans-unit id="13bc76c23a2d1597cb4fa248a96e4ed2a6339b15" translate="yes" xml:space="preserve">
          <source>Then one of the constraints would be on the &quot;a&quot; column with operator &quot;=&quot; and an expression of &quot;5&quot;. Constraints need not have a literal representation of the WHERE clause. The query optimizer might make transformations to the WHERE clause in order to extract as many constraints as it can. So, for example, if the WHERE clause contained something like this:</source>
          <target state="translated">そうすると、制約の1つは、演算子&quot;=&quot;と &quot;5 &quot;の式を持つ &quot;a &quot;列になります。制約は、WHERE句のリテラル表現を持つ必要はありません。クエリ・オプティマイザは、可能な限り多くの制約を抽出するために、WHERE句に変換を行うかもしれません。例えば、WHERE句に以下のようなものが含まれていたとします。</target>
        </trans-unit>
        <trans-unit id="a6d85a4cee37097aa0048aa17c7e903390d7845d" translate="yes" xml:space="preserve">
          <source>Then run &quot;sh speed-check.sh trunk&quot;.</source>
          <target state="translated">そして、&quot;sh speed-check.sh trunk &quot;を実行します。</target>
        </trans-unit>
        <trans-unit id="5af7ca0994a03bba6845a3d09f85ba03527c6bbf" translate="yes" xml:space="preserve">
          <source>Then that term is rewritten as follows:</source>
          <target state="translated">すると、その項は次のように書き換えられます。</target>
        </trans-unit>
        <trans-unit id="89cb6c0dfe329a7ee49493775fd34d7651a1097e" translate="yes" xml:space="preserve">
          <source>Then the LIKE operator pays attention to case and the example above would evaluate to false. Note that case insensitivity only applies to latin1 characters - basically the upper and lower case letters of English in the lower 127 byte codes of ASCII. International character sets are case sensitive in SQLite unless an application-defined &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#like&quot;&gt;like() SQL function&lt;/a&gt; are provided that take non-ASCII characters into account. But if an application-defined collating sequence and/or like() SQL function are provided, the LIKE optimization described here will never be taken.</source>
          <target state="translated">次に、LIKEオペレーターはケースに注意を払い、上の例はfalseと評価されます。大文字と小文字を区別しないのは、latin1文字にのみ適用されることに注意してください-基本的に、ASCIIの下位127バイトコードの英語の大文字と小文字。非ASCII文字を考慮に入れるアプリケーション定義の&lt;a href=&quot;datatype3#collation&quot;&gt;照合シーケンス&lt;/a&gt;および&lt;a href=&quot;lang_corefunc#like&quot;&gt;like（）SQL関数&lt;/a&gt;が提供されていない限り、国際文字セットはSQLiteで大文字と小文字を区別します。ただし、アプリケーション定義の照合シーケンスやlike（）SQL関数が提供されている場合、ここで説明するLIKE最適化は行われません。</target>
        </trans-unit>
        <trans-unit id="be60a7454a5a8c066c86b3ca9b68995e4f6f1ddf" translate="yes" xml:space="preserve">
          <source>Then the RBU database should contain:</source>
          <target state="translated">そして、RBUデータベースが含まれている必要があります。</target>
        </trans-unit>
        <trans-unit id="afb35789040d9830a99208d5f4ddcf476245eb59" translate="yes" xml:space="preserve">
          <source>Then the UPDATE might fail with an SQLITE_LOCKED error. The reason is that the initial query has not run to completion. It is remembering its place in the middle of a scan of the R-Tree. So an update to the R-Tree cannot be tolerated as this would disrupt the scan.</source>
          <target state="translated">すると、UPDATEがSQLITE_LOCKEDエラーで失敗することがあります。原因は、最初のクエリが完了まで実行されていないことです。これは、R-Tree のスキャンの途中で場所を記憶しているからです。したがって、R-Treeへの更新はスキャンを混乱させるので、許容できません。</target>
        </trans-unit>
        <trans-unit id="996a8ef99f82edf5bb93411418cadd30d4e95347" translate="yes" xml:space="preserve">
          <source>Then the generated SQL will look like the following:</source>
          <target state="translated">すると、生成されたSQLは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="0e329a491713b53943766e19e0cd3bc2370d4353" translate="yes" xml:space="preserve">
          <source>Then the index is usable by the query because the &quot;b=6&quot; term appears in both the index definition and in the query. Remember: terms in the index should be OR-connected and terms in the query should be AND-connected.</source>
          <target state="translated">すると、インデックスの定義とクエリの両方に &quot;b=6 &quot;という用語が現れるので、インデックスはクエリで使用可能になります。覚えておいてください:インデックス内の用語は OR 接続で、クエリ内の用語は AND 接続でなければなりません。</target>
        </trans-unit>
        <trans-unit id="2efe4248a37f7b9e147bfa69326ac21ae4833059" translate="yes" xml:space="preserve">
          <source>Then the index might be used if the initial columns of the index (columns a, b, and so forth) appear in WHERE clause terms. The initial columns of the index must be used with the *=* or *IN* or *IS* operators. The right-most column that is used can employ inequalities. For the right-most column of an index that is used, there can be up to two inequalities that must sandwich the allowed values of the column between two extremes.</source>
          <target state="translated">そうすると、インデックスの初期列(列a,bなど)がWHERE句の項に現れた場合にインデックスが使われるかもしれません。インデックスの最初の列は、*=*または*IN*または*IS*演算子を使用しなければなりません。使用される右端の列は、不等式を使用することができます。使用されるインデックスの最右端の列には、最大2つの不等式を使用することができ、その列の許容値を2つの極端の間に挟まなければなりません。</target>
        </trans-unit>
        <trans-unit id="f563dfd5bcb7f2cd99d04f3adadee6fc2e0e90d8" translate="yes" xml:space="preserve">
          <source>Then the index will &lt;u&gt;not&lt;/u&gt; be used because the expression on the CREATE INDEX statement (x+y) is not the same as the expression as it appears in the query (y+x). The two expressions might be mathematically equivalent, but the SQLite query planner insists that they be the same, not merely equivalent. Consider rewriting the query thusly:</source>
          <target state="translated">その後、CREATE INDEXステートメントの式（x + y）がクエリに表示される式（y + x）と同じではないため、インデックスは使用され&lt;u&gt;ません&lt;/u&gt;。2つの式は数学的に同等である可能性がありますが、SQLiteクエリプランナーは、それらが同じであるだけでなく、同じであると主張します。このようにクエリを書き直すことを検討してください：</target>
        </trans-unit>
        <trans-unit id="faa0b455785c0547f03cc054aee1b96482863f25" translate="yes" xml:space="preserve">
          <source>Then the locking mode applies only to the named database. If no database name qualifier precedes the &quot;locking_mode&quot; keyword then the locking mode is applied to all databases, including any new databases added by subsequent &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; commands.</source>
          <target state="translated">次に、ロックモードは指定されたデータベースにのみ適用されます。「locking_mode」キーワードの前にデータベース名修飾子がない場合、ロックモードは、後続の&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;コマンドによって追加された新しいデータベースを含むすべてのデータベースに適用されます。</target>
        </trans-unit>
        <trans-unit id="2ace62cf521cfc04b47d7dad558287516162d423" translate="yes" xml:space="preserve">
          <source>Then the virtual table would be created with two hidden columns, and with datatypes of &quot;VARCHAR(12)&quot; and &quot;INTEGER&quot;.</source>
          <target state="translated">そうすると、2つの隠しカラムと &quot;VARCHAR(12)&quot;と &quot;INTEGER &quot;のデータ型を持つ仮想テーブルが作成されます。</target>
        </trans-unit>
        <trans-unit id="b398879a2efe1c2e2e8691470971432fd8ac7954" translate="yes" xml:space="preserve">
          <source>Then to read the first page of that database file, one merely runs:</source>
          <target state="translated">そして、そのデータベースファイルの最初のページを読むために、単に実行するだけです。</target>
        </trans-unit>
        <trans-unit id="9a0f2cc8cc7905afb88e588449e50b02e607b774" translate="yes" xml:space="preserve">
          <source>Then two &quot;virtual&quot; terms are added as follows:</source>
          <target state="translated">そして、以下のように2つの「仮想的な」用語が追加されます。</target>
        </trans-unit>
        <trans-unit id="ca7fe30da623ecbcc16dc68b6763c7b9a4af11d0" translate="yes" xml:space="preserve">
          <source>Then use the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX()&lt;/a&gt; functions to bind your large string values to the SQL statement. The use of binding obviates the need to escape quote characters in the string, reducing the risk of SQL injection attacks. It also runs faster since the large string does not need to be parsed or copied as much.</source>
          <target state="translated">次に、&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX（）&lt;/a&gt;関数を使用して、大きな文字列値をSQLステートメントにバインドします。バインディングを使用すると、文字列内の引用符をエスケープする必要がなくなり、SQLインジェクション攻撃のリスクが軽減されます。また、大きな文字列を解析またはコピーする必要がないため、実行速度も速くなります。</target>
        </trans-unit>
        <trans-unit id="1d3ddffeb2cfef8ef81678864135303a52c1015f" translate="yes" xml:space="preserve">
          <source>Then use the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX()&lt;/a&gt; functions to bind your large string values to the SQL statement. The use of binding obviates the need to escape quote characters in the string, reducing the risk of SQL injection attacks. It is also runs faster since the large string does not need to be parsed or copied as much.</source>
          <target state="translated">次に、&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX（）&lt;/a&gt;関数を使用して、大きな文字列値をSQLステートメントにバインドします。バインディングを使用すると、文字列内の引用文字をエスケープする必要がなくなり、SQLインジェクション攻撃のリスクが軽減されます。また、大きな文字列を解析またはコピーする必要がないため、実行速度も速くなります。</target>
        </trans-unit>
        <trans-unit id="265606c9637ac4024a4237e1919b8d5a2a194605" translate="yes" xml:space="preserve">
          <source>Then, love your neighbor as yourself.</source>
          <target state="translated">そして、隣人を自分のように愛しましょう。</target>
        </trans-unit>
        <trans-unit id="3cfbc622cd136a62d323c5b8bab5c8bc5876d69e" translate="yes" xml:space="preserve">
          <source>There are &lt;a href=&quot;vtablist&quot;&gt;many other virtual table implementations&lt;/a&gt; in the SQLite source tree that can be used as examples. Locate these other virtual table implementations by searching for &quot;sqlite3_create_module&quot;.</source>
          <target state="translated">例として使用できるSQLiteソースツリーには、&lt;a href=&quot;vtablist&quot;&gt;他に&lt;/a&gt;も多くの仮想テーブルの実装があります。「sqlite3_create_module」を検索して、これらの他の仮想テーブルの実装を見つけます。</target>
        </trans-unit>
        <trans-unit id="cf0cc9442c93b87173641af3ce48fe6ba6a56819" translate="yes" xml:space="preserve">
          <source>There are U or more such b-trees on a single level (see the documentation for the &lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5 automerge option&lt;/a&gt; for an explanation of b-tree levels), where U is the value assigned to the &lt;a href=&quot;fts5#the_usermerge_configuration_option&quot;&gt;FTS5 usermerge option&lt;/a&gt; option.</source>
          <target state="translated">単一レベルにU以上のそのようなbツリーがあります（bツリーレベルの説明については、&lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5自動マージオプションの&lt;/a&gt;ドキュメントを参照してください）。Uは、&lt;a href=&quot;fts5#the_usermerge_configuration_option&quot;&gt;FTS5ユーザーマージオプション&lt;/a&gt;オプションに割り当てられた値です。</target>
        </trans-unit>
        <trans-unit id="fd10b08d9cff8fbc86ae03afd572ce0a4529a480" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to being serverless. The main advantage is that there is no separate server process to install, setup, configure, initialize, manage, and troubleshoot. This is one reason why SQLite is a &quot;&lt;a href=&quot;zeroconf&quot;&gt;zero-configuration&lt;/a&gt;&quot; database engine. Programs that use SQLite require no administrative support for setting up the database engine before they are run. Any program that is able to access the disk is able to use an SQLite database.</source>
          <target state="translated">サーバーレスであることには長所と短所があります。主な利点は、インストール、セットアップ、構成、初期化、管理、およびトラブルシューティングを行うための個別のサーバープロセスがないことです。これが、SQLiteが「&lt;a href=&quot;zeroconf&quot;&gt;ゼロ構成&lt;/a&gt;」データベースエンジンである理由の1つです。SQLiteを使用するプログラムは、実行前にデータベースエンジンを設定するための管理サポートを必要としません。ディスクにアクセスできるすべてのプログラムは、SQLiteデータベースを使用できます。</target>
        </trans-unit>
        <trans-unit id="9e47d4a7ae3779b3ce3872907368c2ebe6ca93d1" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to being serverless. The main advantage is that there is no separate server process to install, setup, configure, initialize, manage, and troubleshoot. This is one reason why SQLite is a &quot;zero-configuration&quot; database engine. Programs that use SQLite require no administrative support for setting up the database engine before they are run. Any program that is able to access the disk is able to use an SQLite database.</source>
          <target state="translated">サーバーレスにはメリットとデメリットがあります。主なメリットは、インストール、セットアップ、設定、初期化、管理、トラブルシューティングのための別個のサーバープロセスがないことです。これが SQLite が「設定不要」のデータベースエンジンである理由の 1 つです。SQLite を使用するプログラムは、実行前にデータベースエンジンを設定するための管理サポートを必要としません。ディスクにアクセスできるプログラムであれば、SQLite データベースを使用することができます。</target>
        </trans-unit>
        <trans-unit id="a00099ff32dd16c72c3ea081a513584d8f3c38e0" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to using WAL instead of a rollback journal. Advantages include:</source>
          <target state="translated">ロールバックジャーナルではなくWALを使うことにはメリットとデメリットがあります。メリットとしては、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="3093b427039bbfacae2cf7cc0c20cdff14795a5c" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to using memory-mapped I/O. Advantages include:</source>
          <target state="translated">メモリマップされたI/Oを使用することにはメリットとデメリットがあります。メリットには以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="79bd071128837bce919057f74da96b8e84ac063f" translate="yes" xml:space="preserve">
          <source>There are certain reasonable restrictions on expressions that appear in CREATE INDEX statements:</source>
          <target state="translated">CREATE INDEX文に現れる表現には、一定の合理的な制限があります。</target>
        </trans-unit>
        <trans-unit id="0440cacf20ea4b02e6a0db0e8999f07d0748bd04" translate="yes" xml:space="preserve">
          <source>There are compile-time options that will set upper bounds on the sizes of various structures in SQLite. The compile-time options normally set a hard upper bound that can be changed at run-time on individual &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; interface.</source>
          <target state="translated">SQLiteのさまざまな構造のサイズに上限を設定するコンパイル時オプションがあります。コンパイル時オプションは通常、&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;インターフェース&lt;a href=&quot;c3ref/sqlite3&quot;&gt;を&lt;/a&gt;使用して個々のデータベース接続で実行時に変更できるハード上限を設定します。</target>
        </trans-unit>
        <trans-unit id="5db06d3cdfac9a23d2859adb4baf70db2e25be47" translate="yes" xml:space="preserve">
          <source>There are currently 170 opcodes defined by the virtual machine. All currently defined opcodes are described in the table below. This table was generated automatically by scanning the source code from the file &lt;a href=&quot;http://www.sqlite.org/src/artifact/da4030a71acf42be18001b9b7067d6d34ffb76610603ce6fafa52854b9e52936&quot;&gt;vdbe.c&lt;/a&gt;.</source>
          <target state="translated">現在、仮想マシンによって定義されている170のオペコードがあります。現在定義されているすべてのオペコードを以下の表に示します。このテーブルは、ファイル&lt;a href=&quot;http://www.sqlite.org/src/artifact/da4030a71acf42be18001b9b7067d6d34ffb76610603ce6fafa52854b9e52936&quot;&gt;vdbe.c&lt;/a&gt;からソースコードをスキャンして自動的に生成されました。</target>
        </trans-unit>
        <trans-unit id="3d151e494351273cc5176bb466ee794220518dba" translate="yes" xml:space="preserve">
          <source>There are currently 175 opcodes defined by the virtual machine. All currently defined opcodes are described in the table below. This table was generated automatically by scanning the source code from the file &lt;a href=&quot;http://www.sqlite.org/src/artifact/e9f7f818f128c8600058c0eabb6b3975974c95153a104d340f419adabbc15b9f&quot;&gt;vdbe.c&lt;/a&gt;.</source>
          <target state="translated">現在、仮想マシンによって定義されている175のオペコードがあります。現在定義されているすべてのオペコードを次の表に示します。このテーブルは、ファイル&lt;a href=&quot;http://www.sqlite.org/src/artifact/e9f7f818f128c8600058c0eabb6b3975974c95153a104d340f419adabbc15b9f&quot;&gt;vdbe.c&lt;/a&gt;からソースコードをスキャンすることによって自動的に生成されました。</target>
        </trans-unit>
        <trans-unit id="2f94a164918f438c0d1173d53f7a4f94c08b35d7" translate="yes" xml:space="preserve">
          <source>There are currently the following configuration options:</source>
          <target state="translated">現在、以下の設定オプションがあります。</target>
        </trans-unit>
        <trans-unit id="3c95acf82c00de5d5751bda48036e2a0038274e3" translate="yes" xml:space="preserve">
          <source>There are details to fill in here. Perhaps a screen can be provided that displays a history changes (perhaps with a graph) allowing the user to select which version they want to view or edit. Perhaps some facility can be provided to merge forks that might occur in the version history. And perhaps the application should provide a means to purge old and unwanted versions. The key point is that using an SQLite database to store the content, rather than a ZIP archive, makes all of these features much, much easier to implement, which increases the possibility that they will eventually get implemented.</source>
          <target state="translated">ここに記入する詳細があります。おそらく、履歴の変更を表示する画面を提供することができます(おそらくグラフで)ユーザーが表示または編集したいバージョンを選択できるようにします。おそらく、バージョン履歴で発生する可能性のあるフォークをマージする機能を提供することができます。そして、アプリケーションは古いバージョンや不要なバージョンを削除する手段を提供すべきでしょう。重要なポイントは、ZIP アーカイブではなく、コンテンツを保存するために SQLite データベースを使用することで、これらの機能を実装するのが非常に簡単になり、最終的に実装される可能性が高くなるということです。</target>
        </trans-unit>
        <trans-unit id="98cb1601f44f3fee5a33f8d40abfeb82b5e7251a" translate="yes" xml:space="preserve">
          <source>There are five separate read locks, numbers 0 through 4. Read locks may be either SHARED or EXCLUSIVE. Connections obtain a shared lock on one of the read locks bytes while they are within a transaction. Connections also obtain an exclusive lock on read locks, one at a time, for the brief moment while they are updating the values of the corresponding read-marks. Read locks 1 through 4 are held exclusively when running &lt;a href=&quot;walformat#recovery&quot;&gt;recovery&lt;/a&gt;.</source>
          <target state="translated">5つの個別の読み取りロックがあり、0から4の番号が付いています。読み取りロックはSHAREDまたはEXCLUSIVEのいずれかです。接続は、トランザクション内にある間、読み取りロックバイトの1つで共有ロックを取得します。また、接続は、対応する読み取りマークの値を更新している間、読み取りロックに対する排他ロックを一度に1つずつ取得します。読み取りロック1〜4は、&lt;a href=&quot;walformat#recovery&quot;&gt;リカバリの&lt;/a&gt;実行中にのみ保持されます。</target>
        </trans-unit>
        <trans-unit id="c457ee41ba8d1b7387ba8e7edc9a0ac19be4f375" translate="yes" xml:space="preserve">
          <source>There are five ways to describe starting and ending frame boundaries:</source>
          <target state="translated">開始枠と終了枠の境界を表現するには、5つの方法があります。</target>
        </trans-unit>
        <trans-unit id="c2ce0d23c5814413e2c1fb5364c7eef30a6e31f7" translate="yes" xml:space="preserve">
          <source>There are four independent test harnesses used for testing the core SQLite library. Each test harness is designed, maintained, and managed separately from the others.</source>
          <target state="translated">コアとなる SQLite ライブラリのテストには、4 つの独立したテストハーネスが使用されています。それぞれのテストハーネスは、他のものとは別に設計、保守、管理されています。</target>
        </trans-unit>
        <trans-unit id="4083c54b42aa73500fa86d4b0409e55690866a09" translate="yes" xml:space="preserve">
          <source>There are many advantages to using SQLite as an application file format, including:</source>
          <target state="translated">アプリケーションのファイル形式としてSQLiteを使用することには、以下のようなメリットがあります。</target>
        </trans-unit>
        <trans-unit id="7e1c62962db715e611550a655ba502415a8c24f6" translate="yes" xml:space="preserve">
          <source>There are many benefits to this approach, including improved performance, reduced cost and complexity, and improved reliability. See technical notes &lt;a href=&quot;aff_short&quot;&gt;&quot;aff_short.html&quot;&lt;/a&gt; and &lt;a href=&quot;appfileformat&quot;&gt;&quot;appfileformat.html&quot;&lt;/a&gt; and &lt;a href=&quot;fasterthanfs&quot;&gt;&quot;fasterthanfs.html&quot;&lt;/a&gt; for more information. This use case is closely related to the &lt;a href=&quot;#wireproto&quot;&gt;data transfer format&lt;/a&gt; and &lt;a href=&quot;#container&quot;&gt;data container&lt;/a&gt; use cases below.</source>
          <target state="translated">このアプローチには、パフォーマンスの向上、コストと複雑さの軽減、信頼性の向上など、多くの利点があります。テクニカルノートを参照してください&lt;a href=&quot;aff_short&quot;&gt;「aff_short.html」&lt;/a&gt;と&lt;a href=&quot;appfileformat&quot;&gt;「appfileformat.html」&lt;/a&gt;と&lt;a href=&quot;fasterthanfs&quot;&gt;「fasterthanfs.html」&lt;/a&gt;詳細については。この使用例は、以下の&lt;a href=&quot;#wireproto&quot;&gt;データ転送形式&lt;/a&gt;と&lt;a href=&quot;#container&quot;&gt;データコンテナーの&lt;/a&gt;使用例と密接に関連しています。</target>
        </trans-unit>
        <trans-unit id="a6dd1c1ec54122d1cd8a41e77d633d60c4de1054" translate="yes" xml:space="preserve">
          <source>There are many different extended result codes for I/O errors that identify the specific I/O operation that failed.</source>
          <target state="translated">失敗した特定のI/O操作を識別するI/Oエラーのための多くの異なる拡張結果コードがあります。</target>
        </trans-unit>
        <trans-unit id="f265782324871b5641aee92d51fefe1edfb475af" translate="yes" xml:space="preserve">
          <source>There are many fraudulent USB sticks in circulation that report to have a high capacity (ex: 8GB) but are really only capable of storing a much smaller amount (ex: 1GB). Attempts to write on these devices will often result in unrelated files being overwritten. Any use of a fraudulent flash memory device can easily lead to database corruption, therefore. Internet searches such as &quot;fake capacity usb&quot; will turn up lots of disturbing information about this problem.</source>
          <target state="translated">大容量(例:8GB)を謳っているが、実際にはそれ以下の容量(例:1GB)しか保存できないという詐欺的なUSBメモリが多く流通しています。これらのデバイスに書き込みをしようとすると、関係のないファイルが上書きされてしまうことがよくあります。そのため、不正なフラッシュメモリを使用すると、簡単にデータベースの破損につながる可能性があります。インターネットで「偽の容量USB」などと検索すると、この問題についての不穏な情報がたくさん出てきます。</target>
        </trans-unit>
        <trans-unit id="a53dc58a565490cefd808a058bfaad47e191a084" translate="yes" xml:space="preserve">
          <source>There are many more features not listed above. SQLite may be small in size and have &quot;Lite&quot; in its name, but it is not lacking in capability.</source>
          <target state="translated">上記に挙げられていない機能は他にもたくさんあります。SQLiteはサイズが小さく、名前に「Lite」がついているかもしれませんが、機能が不足しているわけではありません。</target>
        </trans-unit>
        <trans-unit id="60f662540321a06d796e68831dc73409bf49f397" translate="yes" xml:space="preserve">
          <source>There are many other dot-commands available in the command-line shell. See the &quot;.help&quot; command for a complete list for any particular version and build of SQLite.</source>
          <target state="translated">コマンドラインシェルには他にも多くのドットコマンドがあります。特定のバージョンやビルドの SQLite の完全なリストは &quot;.help&quot; コマンドを参照してください。</target>
        </trans-unit>
        <trans-unit id="53f739b37a172fddf027f7c8afb4029bf933f8fe" translate="yes" xml:space="preserve">
          <source>There are many other testing options, which can be seen by running the command:</source>
          <target state="translated">他にも多くのテストオプションがあり、コマンドを実行することで確認することができます。</target>
        </trans-unit>
        <trans-unit id="461c7676d827031f4cd64d05f3d67e68ce256daf" translate="yes" xml:space="preserve">
          <source>There are many ways to measure test coverage. The most popular metric is &quot;statement coverage&quot;. When you hear someone say that their program as &quot;XX% test coverage&quot; without further explanation, they usually mean statement coverage. Statement coverage measures what percentage of lines of code are executed at least once by the test suite.</source>
          <target state="translated">テストカバレッジを測定する方法はたくさんあります。最もポピュラーな指標は「ステートメントカバレッジ」です。誰かが自分のプログラムが「○○%のテストカバレッジ」と言っているのを聞いたとき、その人たちはたいていステートメントカバレッジを意味しています。ステートメントカバレッジは、テストスイートによってコードの何パーセントの行が少なくとも一度は実行されたかを測定します。</target>
        </trans-unit>
        <trans-unit id="15784824361af8c293ec21cb8076051131fb442d" translate="yes" xml:space="preserve">
          <source>There are no arbitrary limits in TH3. One could generate a single test program that contained all test modules and all configuration files. However, such a test program might be too large to deploy on embedded platforms. (As of 2018-05-19, a full-up TH3 test is over 850,000 lines and 58MB of C code.) TH3 provides the ability to break the library of test modules up into smaller, more easily digested pieces.</source>
          <target state="translated">TH3 には任意の制限はありません。すべてのテストモジュールとすべての設定ファイルを含む単一のテストプログラムを作成することができます。しかし、そのようなテストプログラムは、組み込みプラットフォームにデプロイするには大きすぎるかもしれません。(2018-05-19現在、フルアップのTH3テストは85万行以上、58MBのCコードになります)。TH3は、テストモジュールのライブラリをより消化しやすい小さな断片に分割する機能を提供しています。</target>
        </trans-unit>
        <trans-unit id="67165e227e06a66e9e2a7c9a359bffd814ca48a8" translate="yes" xml:space="preserve">
          <source>There are no arbitrary limits on the number of indices that can be attached to a single table. The number of columns in an index is limited to the value set by &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcolumn&quot;&gt;SQLITE_LIMIT_COLUMN&lt;/a&gt;,...).</source>
          <target state="translated">1つのテーブルにアタッチできるインデックスの数に任意の制限はありません。インデックス内の列数は、&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcolumn&quot;&gt;SQLITE_LIMIT_COLUMN&lt;/a&gt;、...）によって設定された値に制限されます。</target>
        </trans-unit>
        <trans-unit id="75e5745eabbe1f0d9742be6d3047103706a06632" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; to Multi-thread. In other words, it disables mutexing on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; objects. The application is responsible for serializing access to &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt;. But other mutexes are enabled so that SQLite will be safe to use in a multi-threaded environment as long as no two threads attempt to use the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Multi-thread &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_MULTITHREAD configuration option.</source>
          <target state="translated">このオプションには引数はありません。このオプションは、&lt;a href=&quot;../threadsafe&quot;&gt;スレッド化モード&lt;/a&gt;をマルチスレッドに設定します。つまり、&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;と&lt;a href=&quot;stmt&quot;&gt;準備されたステートメント&lt;/a&gt;オブジェクトのミューテックスを無効にします。アプリケーションは、&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;と&lt;a href=&quot;stmt&quot;&gt;準備されたステートメント&lt;/a&gt;へのアクセスをシリアライズする責任があります。ただし、他のミューテックスが有効になっているため、2つのスレッドが同じ&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;を同時に使用しない限り、SQLiteはマルチスレッド環境で安全に使用できます。 SQLiteが&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;コンパイル時オプションでコンパイルされている場合、マルチスレッド&lt;a href=&quot;../threadsafe&quot;&gt;スレッドモード&lt;/a&gt;と&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;を設定することはできません。戻ります&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERRORを&lt;/a&gt; SQLITE_CONFIG_MULTITHREAD構成オプションを指定して呼び出された場合。</target>
        </trans-unit>
        <trans-unit id="438fea25e22862b67e0b2e195af310125649fa4d" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; to Serialized. In other words, this option enables all mutexes including the recursive mutexes on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; objects. In this mode (which is the default when SQLite is compiled with &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=1&lt;/a&gt;) the SQLite library will itself serialize access to &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt; so that the application is free to use the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; or the same &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; in different threads at the same time. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Serialized &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SERIALIZED configuration option.</source>
          <target state="translated">このオプションには引数はありません。このオプションは、&lt;a href=&quot;../threadsafe&quot;&gt;スレッド化モード&lt;/a&gt;をシリアル化に設定します。つまり、このオプションは、&lt;a href=&quot;sqlite3&quot;&gt;データベース接続の&lt;/a&gt;再帰ミューテックスと&lt;a href=&quot;stmt&quot;&gt;準備されたステートメント&lt;/a&gt;オブジェクトを含むすべてのミューテックスを有効にします。このモード（SQLiteが&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 1で&lt;/a&gt;コンパイルされている場合のデフォルト）では、SQLiteライブラリ自体が&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;と&lt;a href=&quot;stmt&quot;&gt;準備済みステートメント&lt;/a&gt;へのアクセスをシリアル化するため、アプリケーションは異なる&lt;a href=&quot;sqlite3&quot;&gt;データベースで&lt;/a&gt;同じデータベース接続または同じ&lt;a href=&quot;stmt&quot;&gt;準備済みステートメント&lt;/a&gt;を自由に使用できます。同時に。 SQLiteが&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0で&lt;/a&gt;コンパイルされている場合コンパイル時のオプションでは、直列化された設定することはできません&lt;a href=&quot;../threadsafe&quot;&gt;スレッドモード&lt;/a&gt;と&lt;a href=&quot;config&quot;&gt;sqlite3_configを（）&lt;/a&gt;が返されます&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERRORを&lt;/a&gt; SQLITE_CONFIG_SERIALIZEDコンフィギュレーションオプションを指定して呼び出された場合。</target>
        </trans-unit>
        <trans-unit id="4b86fd3dbc8c8ae83073b70ec3ca59694912ef28" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; to Single-thread. In other words, it disables all mutexing and puts SQLite into a mode where it can only be used by a single thread. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to change the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; from its default value of Single-thread and so &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SINGLETHREAD configuration option.</source>
          <target state="translated">このオプションには引数はありません。このオプションは、&lt;a href=&quot;../threadsafe&quot;&gt;スレッドモード&lt;/a&gt;をシングルスレッドに設定します。つまり、すべてのミューテックスを無効にし、SQLiteを単一のスレッドでのみ使用できるモードにします。 SQLiteが&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;コンパイル時オプションでコンパイルされている場合、&lt;a href=&quot;../threadsafe&quot;&gt;スレッドモード&lt;/a&gt;をデフォルト値のシングルスレッドから変更することはできないため、SQLITE_CONFIG_SINGLETHREAD構成オプションで呼び出された場合、&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;は&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="e6b294707b24261f0f532c64902934c051eedbd1" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Multi-thread. In other words, it disables mutexing on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; objects. The application is responsible for serializing access to &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt;. But other mutexes are enabled so that SQLite will be safe to use in a multi-threaded environment as long as no two threads attempt to use the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Multi-thread &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_MULTITHREAD configuration option.</source>
          <target state="translated">このオプションには引数はありません。このオプションは、&lt;a href=&quot;threadsafe&quot;&gt;スレッド化モード&lt;/a&gt;をマルチスレッドに設定します。つまり、&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;と&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備されたステートメント&lt;/a&gt;オブジェクトのミューテックスを無効にします。アプリケーションは、&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;と&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備されたステートメント&lt;/a&gt;へのアクセスをシリアライズする責任があります。ただし、他のミューテックスが有効になっているため、2つのスレッドが同じ&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;を同時に使用しない限り、SQLiteはマルチスレッド環境で安全に使用できます。 SQLiteが&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;コンパイル時オプションでコンパイルされている場合、マルチスレッド&lt;a href=&quot;threadsafe&quot;&gt;スレッドモード&lt;/a&gt;と&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;を設定することはできません。戻ります&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERRORを&lt;/a&gt; SQLITE_CONFIG_MULTITHREAD構成オプションを指定して呼び出された場合。</target>
        </trans-unit>
        <trans-unit id="955a610f066915f2766fca467b944718d1ee6aea" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Serialized. In other words, this option enables all mutexes including the recursive mutexes on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; objects. In this mode (which is the default when SQLite is compiled with &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=1&lt;/a&gt;) the SQLite library will itself serialize access to &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt; so that the application is free to use the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; or the same &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; in different threads at the same time. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Serialized &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SERIALIZED configuration option.</source>
          <target state="translated">このオプションには引数はありません。このオプションは、&lt;a href=&quot;threadsafe&quot;&gt;スレッド化モード&lt;/a&gt;をシリアル化に設定します。つまり、このオプションは、&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続の&lt;/a&gt;再帰ミューテックスと&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備されたステートメント&lt;/a&gt;オブジェクトを含むすべてのミューテックスを有効にします。このモード（SQLiteが&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 1で&lt;/a&gt;コンパイルされている場合のデフォルト）では、SQLiteライブラリ自体が&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;と&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備済みステートメント&lt;/a&gt;へのアクセスをシリアル化するため、アプリケーションは異なる&lt;a href=&quot;#sqlite3&quot;&gt;データベースで&lt;/a&gt;同じデータベース接続または同じ&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備済みステートメント&lt;/a&gt;を自由に使用できます。同時に。 SQLiteが&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0で&lt;/a&gt;コンパイルされている場合コンパイル時のオプションでは、直列化された設定することはできません&lt;a href=&quot;threadsafe&quot;&gt;スレッドモード&lt;/a&gt;と&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_configを（）&lt;/a&gt;が返されます&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERRORを&lt;/a&gt; SQLITE_CONFIG_SERIALIZEDコンフィギュレーションオプションを指定して呼び出された場合。</target>
        </trans-unit>
        <trans-unit id="1bc66a3a72545b16257e521a7b7467b7b7fb116b" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Single-thread. In other words, it disables all mutexing and puts SQLite into a mode where it can only be used by a single thread. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to change the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; from its default value of Single-thread and so &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SINGLETHREAD configuration option.</source>
          <target state="translated">このオプションには引数はありません。このオプションは、&lt;a href=&quot;threadsafe&quot;&gt;スレッドモード&lt;/a&gt;をシングルスレッドに設定します。つまり、すべてのミューテックスを無効にし、SQLiteを単一のスレッドでのみ使用できるモードにします。 SQLiteが&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt;コンパイル時オプションでコンパイルされている場合、&lt;a href=&quot;threadsafe&quot;&gt;スレッドモード&lt;/a&gt;をデフォルト値のシングルスレッドから変更することはできないため、SQLITE_CONFIG_SINGLETHREAD構成オプションで呼び出された場合、&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;は&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="33e0331165757b835edb3c42bfc1d34942851312" translate="yes" xml:space="preserve">
          <source>There are numerous test cases that verify that SQLite is able to deal with malformed database files. These tests first build a well-formed database file, then add corruption by changing one or more bytes in the file by some means other than SQLite. Then SQLite is used to read the database. In some cases, the bytes changes are in the middle of data. This causes the content of the database to change while keeping the database well-formed. In other cases, unused bytes of the file are modified, which has no effect on the integrity of the database. The interesting cases are when bytes of the file that define database structure get changed. The malformed database tests verify that SQLite finds the file format errors and reports them using the &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; return code without overflowing buffers, dereferencing NULL pointers, or performing other unwholesome actions.</source>
          <target state="translated">SQLiteが不正なデータベースファイルを処理できることを確認する多数のテストケースがあります。これらのテストでは、最初に整形式のデータベースファイルを作成し、SQLite以外の方法でファイルの1バイト以上を変更して破損を追加します。次に、SQLiteを使用してデータベースを読み取ります。場合によっては、バイトの変更はデータの途中です。これにより、データベースの形式を維持しながら、データベースの内容が変更されます。他の場合では、ファイルの未使用のバイトが変更され、データベースの整合性には影響しません。興味深いケースは、データベース構造を定義するファイルのバイトが変更される場合です。不正なデータベーステストは、SQLiteがファイル形式エラーを見つけ、&lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt;を使用してそれらを報告することを確認します バッファのオーバーフロー、NULLポインタの逆参照、または他の不健全なアクションの実行なしの戻りコード。</target>
        </trans-unit>
        <trans-unit id="f9afe2547739122b5f898fca4cf352f033d81b8f" translate="yes" xml:space="preserve">
          <source>There are only two reasonable ways to implement this query. (There are many other possible algorithms, but none of the others are contenders for being the &quot;best&quot; algorithm.)</source>
          <target state="translated">このクエリを実装するための合理的な方法は2つしかありません(他にも多くの可能性のあるアルゴリズムがありますが、他のどれも「最良」のアルゴリズムであるとは言えません)。(他にも多くの可能性のあるアルゴリズムがありますが、他のアルゴリズムはどれも「最良」のアルゴリズムではありません)。</target>
        </trans-unit>
        <trans-unit id="35c4953b7b40ec225a59ad1651360c7dbd0086b0" translate="yes" xml:space="preserve">
          <source>There are other SQL database engines with liberal licenses that allow the code to be broadly and freely used. But those other engines are still governed by copyright law. SQLite is different in that copyright law simply does not apply.</source>
          <target state="translated">自由なライセンスを持つSQLデータベースエンジンは他にもあり、そのコードを広く自由に使うことができます。しかし、これらのエンジンは著作権法によって管理されています。SQLite は著作権法が適用されないという点で異なっています。</target>
        </trans-unit>
        <trans-unit id="00840e534b3409464615b9e5469c1789e0356b07" translate="yes" xml:space="preserve">
          <source>There are other VFS implementations both in the core SQLite source code library and in available extensions. The list above is not meant to be exhaustive but merely representative of the kinds of features that can be realized using the VFS interface.</source>
          <target state="translated">VFS の実装は、SQLite のコアソースコードライブラリと、利用可能な拡張機能の両方にあります。上記のリストは網羅的なものではなく、VFS インタフェースを使用して実現できる機能の種類の代表的なものにすぎません。</target>
        </trans-unit>
        <trans-unit id="fe657852dc4212647e79b2906ecbf326edcfcb96" translate="yes" xml:space="preserve">
          <source>There are several other ways to add an equivalent foreign key declaration to a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. Refer to the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE documentation&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;ステートメントに同等の外部キー宣言を追加するには、他にもいくつかの方法があります。詳細については、&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLEのドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="14687afe7afa4066d985b4f03845594063586e18" translate="yes" xml:space="preserve">
          <source>There are several ways of thinking about the RELEASE command:</source>
          <target state="translated">RELEASEコマンドについては、いくつかの考え方があります。</target>
        </trans-unit>
        <trans-unit id="22c57ea3a56c1a621fcb33ba044a6de73ca1f510" translate="yes" xml:space="preserve">
          <source>There are several ways to approach this in FTS5:</source>
          <target state="translated">FTS5ではいくつかのアプローチ方法があります。</target>
        </trans-unit>
        <trans-unit id="de40b756c06e57b21f4c7c518f428b201082172b" translate="yes" xml:space="preserve">
          <source>There are some contexts in SQLite that do not allow the use of non-deterministic functions:</source>
          <target state="translated">SQLite には、非決定論的な関数の使用を許可しないコンテキストがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="ffb257ce26a3636acdb1a9134b8ec418a490f506" translate="yes" xml:space="preserve">
          <source>There are some restrictions on the use of a VALUES clause that are not shown on the syntax diagrams:</source>
          <target state="translated">構文図には示されていないが、VALUES句の使用にはいくつかの制限がある。</target>
        </trans-unit>
        <trans-unit id="4fc9c795ba02424df295c5bd8e19a42a3240738c" translate="yes" xml:space="preserve">
          <source>There are three frame types: ROWS, GROUPS, and RANGE. The frame type determines how the starting and ending boundaries of the frame are measured.</source>
          <target state="translated">フレームの種類は3つあります。ROWS、GROUPS、RANGEです。フレームタイプは、フレームの開始境界と終了境界をどのように測定するかを決定します。</target>
        </trans-unit>
        <trans-unit id="b1e7d89744d05b6a27dde7db2836b2617aa1bbd6" translate="yes" xml:space="preserve">
          <source>There are three independent test harnesses used for testing the core SQLite library. Each test harness is designed, maintained, and managed separately from the others.</source>
          <target state="translated">コアとなる SQLite ライブラリのテストには、3 つの独立したテストハーネスが使用されています。それぞれのテストハーネスは、他のものとは別に設計、保守、管理されています。</target>
        </trans-unit>
        <trans-unit id="045c3584370eb289c548f60cb3b6ecaf401b3ed3" translate="yes" xml:space="preserve">
          <source>There are three levels to the shared-cache locking model, transaction level locking, table level locking and schema level locking. They are described in the following three sub-sections.</source>
          <target state="translated">共有キャッシュ・ロックモデルには、トランザクション・レベル・ロック、テーブル・レベル・ロック、スキーマ・レベル・ロックの3つのレベルがあります。これらは以下の3つのサブセクションで説明されています。</target>
        </trans-unit>
        <trans-unit id="944bcf56eaccf2f8d8f73507f47a4f5f610aa075" translate="yes" xml:space="preserve">
          <source>There are three reasons to set the locking-mode to EXCLUSIVE.</source>
          <target state="translated">ロックモードをEXCLUSIVEにする理由は3つあります。</target>
        </trans-unit>
        <trans-unit id="e889a4b513747e6b54c292e814d5a011df18d8e5" translate="yes" xml:space="preserve">
          <source>There are three special-case entries in the cost table:</source>
          <target state="translated">原価表には3つの特殊なケースの項目があります。</target>
        </trans-unit>
        <trans-unit id="3e8f3752e4f9aab9d7f5e605906342c5eeca4178" translate="yes" xml:space="preserve">
          <source>There are two advantages to using the SQLite printf functions instead of &lt;b&gt;sprintf&lt;/b&gt;. First of all, with the SQLite printf routines, there is never a danger of overflowing a static buffer as there is with &lt;b&gt;sprintf&lt;/b&gt;. The SQLite printf routines automatically allocate (and later frees) as much memory as is necessary to hold the SQL statements generated.</source>
          <target state="translated">&lt;b&gt;sprintfの&lt;/b&gt;代わりにSQLiteのprintf関数を使用することには2つの利点があります。まず、SQLiteのprintfルーチンを使用すると、&lt;b&gt;sprintfの&lt;/b&gt;ように静的バッファーがオーバーフローする危険はありません。SQLiteのprintfルーチンは、生成されたSQLステートメントを保持するために必要なだけのメモリを自動的に割り当てます（後で解放します）。</target>
        </trans-unit>
        <trans-unit id="391950a505dd77c6d9de2b0a8bf9dd26b935ed51" translate="yes" xml:space="preserve">
          <source>There are two aggregate SQL functions:</source>
          <target state="translated">集約SQL関数は2つあります。</target>
        </trans-unit>
        <trans-unit id="631b7dfac93f3d53c23db92b1bef743005732dff" translate="yes" xml:space="preserve">
          <source>There are two cases to consider: (1) Table &quot;tab1&quot; does not previously exist and (2) table &quot;tab1&quot; does already exist.</source>
          <target state="translated">考慮すべきケースは2つあります。(1)テーブル「tab1」が以前に存在しない場合と、(2)テーブル「tab1」が既に存在している場合です。</target>
        </trans-unit>
        <trans-unit id="b8b8531dc422d3e33d42cc7bdad0abd37870f1fe" translate="yes" xml:space="preserve">
          <source>There are two column (M==2) and three rows (N==3). Thus the result table has 8 entries. Suppose the result table is stored in an array names azResult. Then azResult holds this content:</source>
          <target state="translated">2列(M==2)と3行(N==3)があります。このように、結果テーブルには8つのエントリがあります。結果テーブルが azResult という名前の配列に格納されているとします。すると、azResultにはこのような内容が格納されています。</target>
        </trans-unit>
        <trans-unit id="e8adb25d367ffc51207827de29ffc66a0b34c609" translate="yes" xml:space="preserve">
          <source>There are two columns (M==2) and three rows (N==3). Thus the result table has 8 entries. Suppose the result table is stored in an array named azResult. Then azResult holds this content:</source>
          <target state="translated">2列(M==2)と3行(N==3)があります。したがって、結果テーブルには8つのエントリがあります。結果テーブルが azResult という名前の配列に格納されているとします。すると、azResultはこの内容を保持しています。</target>
        </trans-unit>
        <trans-unit id="928a963ad2407ff0d2d21e12347ddb23d756bb64" translate="yes" xml:space="preserve">
          <source>There are two differences in this variation. The initial-select is &quot;SELECT 1&quot; instead of &quot;VALUES(1)&quot;. But those are just different syntaxes for saying exactly the same thing. The other change is that the recursion is stopped by a LIMIT rather than a WHERE clause. The use of LIMIT means that when the one-millionth row is added to the &quot;cnt&quot; table (and returned by the main SELECT, thanks to the query optimizer) then the recursion stops immediately regardless of how many rows might be left in the queue. On more complex queries, it can sometimes be difficult to ensure that the WHERE clause will eventually cause the queue to drain and the recursion to terminate. But the LIMIT clause will always stop the recursion. So it is good practice to always include a LIMIT clause as a safety if an upper bound on the size of the recursion is known.</source>
          <target state="translated">このバリエーションには2つの違いがあります。初期選択は &quot;VALUES(1)&quot;ではなく &quot;SELECT 1 &quot;になっています。しかし、これらは全く同じことを言うための異なる構文です。他の変更点は、WHERE句ではなくLIMITによって再帰が停止されていることです。LIMITの使用は、100万行目の行が &quot;cnt &quot;テーブルに追加されたとき(クエリオプティマイザのおかげでメインのSELECTで返されたとき)、キューに何行残っているかに関わらず、再帰が即座に停止することを意味します。より複雑なクエリでは、WHERE句が最終的にキューを排出して再帰を終了させることを確実にすることが難しい場合があります。しかし、LIMIT句は常に再帰を停止します。ですから、再帰のサイズの上限がわかっている場合には、安全のために LIMIT 句を常に含めることが良い習慣となります。</target>
        </trans-unit>
        <trans-unit id="bb5962b52c02f4df27314354c0118e64e476f288" translate="yes" xml:space="preserve">
          <source>There are two separate configuration changes here which can be used either togethr or separately. The &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; setting disables the mutexes that serialize access to &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; objects and &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; objects. With this setting, the application is free to use SQLite from multiple threads, but it must make sure than no two threads try to access the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; or any &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; associated with the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. Two threads can use SQLite at the same time, but they must use separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt;. The second &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; setting disables the mechanism in SQLite that tracks the total size of all outstanding memory allocation requests. This omits the need to mutex each call to &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;, which saves a huge number of mutex operations. But a consequence of disabling the memory statistics mechanism is that the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt;, &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt;, and &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interfaces cease to work.</source>
          <target state="translated">ここには2つの個別の構成変更があり、一緒にまたは個別に使用できます。&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREADの&lt;/a&gt;設定は、シリアル化へのアクセスというミューテックスを無効にし&lt;a href=&quot;c3ref/sqlite3&quot;&gt;、データベース接続&lt;/a&gt;オブジェクトと&lt;a href=&quot;c3ref/stmt&quot;&gt;準備されたステートメント&lt;/a&gt;オブジェクト。この設定では、アプリケーションは複数のスレッドからSQLiteを自由に使用できますが、2つのスレッドが同じ&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;または同じデータベース接続に関連付けられた&lt;a href=&quot;c3ref/stmt&quot;&gt;プリペアドステートメントに&lt;/a&gt;同時にアクセスしようとしないようにする必要があり&lt;a href=&quot;c3ref/sqlite3&quot;&gt;ます&lt;/a&gt;。 2つのスレッドは同時にSQLiteを使用できますが、別々の&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続を&lt;/a&gt;使用する必要があります。 2番目の&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;設定すると、すべての未処理のメモリ割り当て要求の合計サイズを追跡するSQLiteのメカニズムが無効になります。これにより、&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;および&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）の&lt;/a&gt;各呼び出しをミューテックスする必要がなくなり、ミューテックス操作の数が大幅に節約されます。ただし、メモリ統計メカニズムを無効にすると、&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;、&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;、および&lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64（）&lt;/a&gt;インターフェイスが機能しなくなります。</target>
        </trans-unit>
        <trans-unit id="10f943413bc9e88ca64edb6cc154e6b7583f6c77" translate="yes" xml:space="preserve">
          <source>There are two separate configuration changes here which can be used either togethr or separately. The &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; setting disables the mutexes that serialize access to &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; objects and &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; objects. With this setting, the application is free to use SQLite from multiple threads, but it must make sure than no two threads try to access the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; or any &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; associated with the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. Two threads can use SQLite at the same time, but they must use separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt;. The second &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; setting disables the mechanism in SQLite that tracks the total size of all outstanding memory allocation requests. This omits the need to mutex each call to &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;, which saves a huge number of mutex operations. But a consequence of disabling the memory statistics mechanism is that the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt;, &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt;, and &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interfaces cease to work.</source>
          <target state="translated">ここには、togethrまたは個別に使用できる2つの個別の構成変更があります。&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREADの&lt;/a&gt;設定は、シリアル化へのアクセスというミューテックスを無効にし&lt;a href=&quot;c3ref/sqlite3&quot;&gt;、データベース接続&lt;/a&gt;オブジェクトと&lt;a href=&quot;c3ref/stmt&quot;&gt;準備されたステートメント&lt;/a&gt;オブジェクト。この設定では、アプリケーションは複数のスレッドからSQLiteを自由に使用できますが、2つのスレッドが同じ&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;または同じデータベース接続に関連付けられている&lt;a href=&quot;c3ref/stmt&quot;&gt;準備されたステートメントに&lt;/a&gt;同時にアクセスしないようにする必要があり&lt;a href=&quot;c3ref/sqlite3&quot;&gt;ます&lt;/a&gt;。 2つのスレッドは同時にSQLiteを使用できますが、別々の&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続を&lt;/a&gt;使用する必要があります。 2番目の&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;設定すると、未解決のメモリ割り当て要求すべての合計サイズを追跡するSQLiteのメカニズムが無効になります。これにより、&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;および&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;への各呼び出しをミューテックスする必要がなくなり、膨大な数のミューテックス操作が節約されます。ただし、メモリ統計メカニズムを無効にすると、&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;、&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;、および&lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64（）&lt;/a&gt;インターフェースが機能しなくなります。</target>
        </trans-unit>
        <trans-unit id="03b9684a8e7902c26ab2183576e54dd70242a272" translate="yes" xml:space="preserve">
          <source>There are two types of simple SELECT statement - aggregate and non-aggregate queries. A simple SELECT statement is an aggregate query if it contains either a GROUP BY clause or one or more aggregate functions in the result-set. Otherwise, if a simple SELECT contains no aggregate functions or a GROUP BY clause, it is a non-aggregate query.</source>
          <target state="translated">単純なSELECT文には、集約型と非集約型の2種類があります。単純なSELECT文にGROUP BY句または結果セットに1つ以上の集約関数が含まれている場合、集約クエリとなります。そうでない場合、単純なSELECT文に集約関数やGROUP BY句が含まれていない場合は、非集約クエリとなります。</target>
        </trans-unit>
        <trans-unit id="265655ffc7236582ade45c905963724f97d22dc0" translate="yes" xml:space="preserve">
          <source>There are two ways to use the &quot;content&quot; option:</source>
          <target state="translated">コンテンツ」オプションを使用する方法は2つあります。</target>
        </trans-unit>
        <trans-unit id="6c855557ba4350c988043164f7d90199d18c9af0" translate="yes" xml:space="preserve">
          <source>There are typically between 10 to 40 entries in the sqlite_stat4 table for each index for which statistics are available, however these limits are not hard bounds. The meanings of the columns in the sqlite_stat4 table are as follows:</source>
          <target state="translated">統計情報が利用可能な各インデックスのsqlite_stat4テーブルには通常10から40個のエントリがありますが、これらの制限はハードバウンズではありません。sqlite_stat4テーブルの列の意味は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="7cc2860dd2126e117e20cc785f2f36fc98950f36" translate="yes" xml:space="preserve">
          <source>There are usually multiple entries in the sqlite_stat3 table for each index. The sqlite_stat3.sample column holds the value of the left-most field of an index identified by sqlite_stat3.idx and sqlite_stat3.tbl. The sqlite_stat3.nEq column holds the approximate number of entries in the index whose left-most column exactly matches the sample. The sqlite_stat3.nLt holds the approximate number of entries in the index whose left-most column is less than the sample. The sqlite_stat3.nDLt column holds the approximate number of distinct left-most entries in the index that are less than the sample.</source>
          <target state="translated">通常、各インデックスに対してsqlite_stat3テーブルには複数のエントリがあります。sqlite_stat3.sample列は、sqlite_stat3.idxとsqlite_stat3.tblで識別されるインデックスの左端のフィールドの値を保持します。sqlite_stat3.nEq列は、左端の列がサンプルと正確に一致するインデックスのおおよその項目数を保持します。sqlite_stat3.nLt列は、左端の列が標本より小さいインデックスのおおよその項目数を保持します。sqlite_stat3.nDLt列は、インデックスの左端の列が標本よりも小さい明確な左端のエントリのおおよその数を保持します。</target>
        </trans-unit>
        <trans-unit id="3bc8ca2faf5f82d403479bc810eea0e330c59fbe" translate="yes" xml:space="preserve">
          <source>There can be an arbitrary number of sqlite_stat3 entries per index. The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command will typically generate sqlite_stat3 tables that contain between 10 and 40 samples that are distributed across the key space and with large nEq values.</source>
          <target state="translated">インデックスごとに任意の数のsqlite_stat3エントリが存在できます。&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;コマンドは、典型的には、鍵空間を横切って大きなNEQ値で分布している10〜40個のサンプルを含むsqlite_stat3テーブルを生成します。</target>
        </trans-unit>
        <trans-unit id="76781503806bdc9ca573d5796b00968614643484" translate="yes" xml:space="preserve">
          <source>There can be an arbitrary number of sqlite_stat4 entries per index. The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command will typically generate sqlite_stat4 tables that contain between 10 and 40 samples that are distributed across the key space and with large nEq values.</source>
          <target state="translated">インデックスごとに任意の数のsqlite_stat4エントリが存在できます。&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;コマンドは、典型的には、鍵空間を横切って大きなNEQ値で分布している10〜40個のサンプルを含むsqlite_stat4テーブルを生成します。</target>
        </trans-unit>
        <trans-unit id="4935a4962bbd49a87bfec8ba26bcb0ee96e2bc65" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler defined for each &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;. Setting a new busy handler clears any previously set handler. Note that calling &lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; or evaluating &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout=N&lt;/a&gt; will change the busy handler and thus clear any previously set busy handler.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;ごとに定義されているビジーハンドラは1つだけです。新しいビジーハンドラーを設定すると、以前に設定されたハンドラーがクリアされます。&lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt;を呼び出すか、&lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout = N&lt;/a&gt;を評価すると、ビジーハンドラーが変更され、以前に設定されたビジーハンドラーがクリアされることに注意してください。</target>
        </trans-unit>
        <trans-unit id="595614b4fea7d83eeee9eca9b82c7f15a616950a" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler defined for each &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;. Setting a new busy handler clears any previously set handler. Note that calling &lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; or evaluating &lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout=N&lt;/a&gt; will change the busy handler and thus clear any previously set busy handler.</source>
          <target state="translated">&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;ごとに定義されているビジーハンドラは1つだけです。新しいビジーハンドラーを設定すると、以前に設定されたハンドラーがクリアされます。&lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt;を呼び出すか、&lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout = N&lt;/a&gt;を評価すると、ビジーハンドラーが変更され、以前に設定されたビジーハンドラーがクリアされることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4557f81c54cd198ad30dafda03e1a7688c37ee6a" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler for a particular &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; at any given moment. If another busy handler was defined (using &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt;) prior to calling this routine, that other busy handler is cleared.</source>
          <target state="translated">特定の時点で特定の&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;に対して使用できるハンドラーは1つだけです。このルーチンを呼び出す前に別のビジーハンドラーが（&lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;sqlite3_busy_handler（）&lt;/a&gt;を使用して）定義されている場合、その別のビジーハンドラーはクリアされます。</target>
        </trans-unit>
        <trans-unit id="6c5612f166f3c19adb75f5b9420223d984d062bf" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler for a particular &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; at any given moment. If another busy handler was defined (using &lt;a href=&quot;busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt;) prior to calling this routine, that other busy handler is cleared.</source>
          <target state="translated">特定の時点で特定の&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;に対して使用できるハンドラーは1つだけです。このルーチンを呼び出す前に別のビジーハンドラーが（&lt;a href=&quot;busy_handler&quot;&gt;sqlite3_busy_handler（）&lt;/a&gt;を使用して）定義されている場合、その別のビジーハンドラーはクリアされます。</target>
        </trans-unit>
        <trans-unit id="da947c700e89a2839d81ef99abfdba549201cf04" translate="yes" xml:space="preserve">
          <source>There can only be a single error logging callback per process. The error logging callback is registered at start-time using C-code similar to the following:</source>
          <target state="translated">プロセスごとに1つのエラーロギングコールバックだけが存在することができます。エラーロギングコールバックは、以下のようなCコードを使用してスタート時に登録されます。</target>
        </trans-unit>
        <trans-unit id="297da7a4ca1508d9a0851c1993606776e3a61cd5" translate="yes" xml:space="preserve">
          <source>There can only be a single trace callback registered on a database connection. Each use of &quot;trace&quot; or &quot;trace_v2&quot; cancels all prior trace callback.</source>
          <target state="translated">データベース接続に登録されているトレースコールバックは 1 つだけです。trace&quot; または &quot;trace_v2&quot; を使用するたびに、それ以前のトレースコールバックはすべてキャンセルされます。</target>
        </trans-unit>
        <trans-unit id="13fe35de43729e33636f83c267efada945c04a07" translate="yes" xml:space="preserve">
          <source>There exists some subtle problem with mmap() on QNX such that making a second mmap() call against a single file descriptor can cause the memory obtained from the first mmap() call to be zeroed. SQLite on unix uses mmap() to create a shared memory region for transaction coordination in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, and it will call mmap() multiple times for large transactions. The QNX mmap() has been demonstrated to corrupt database file under that scenario. QNX engineers are aware of this problem and are working on a solution; the problem may have already been fixed by the time you read this.</source>
          <target state="translated">QNXのmmap（）には、単一のファイル記述子に対して2番目のmmap（）呼び出しを行うと、最初のmmap（）呼び出しから取得されたメモリがゼロになる可能性があるなど、いくつかの微妙な問題があります。 UNIX上のSQLiteはmmap（）を使用して、&lt;a href=&quot;wal&quot;&gt;WALモード&lt;/a&gt;でのトランザクション調整用の共有メモリ領域を作成し、大規模なトランザクションの場合はmmap（）を複数回呼び出します。 QNX mmap（）は、そのシナリオでデータベースファイルを破損することが実証されています。 QNXエンジニアはこの問題を認識しており、解決に取り組んでいます。これを読んだ時点で、問題はすでに修正されている可能性があります。</target>
        </trans-unit>
        <trans-unit id="d56d459074bf9b196b2551c494a4c7bec9d94df2" translate="yes" xml:space="preserve">
          <source>There has lately been a lot of interest in &quot;safe&quot; programming languages like Rust or Go in which it is impossible, or is at least difficult, to make common programming errors like memory leaks or array overruns. So the question often arises as to why SQLite is not coded in a &quot;safe&quot; language.</source>
          <target state="translated">最近、RustやGoのような「安全な」プログラミング言語が注目されていますが、この言語ではメモリリークや配列のオーバーランのような一般的なプログラミングエラーを起こすことは不可能です。そこで、なぜ SQLite は「安全な」言語でコーディングされていないのか、という疑問がよく出てきます。</target>
        </trans-unit>
        <trans-unit id="52072b3d340cc958b2ff6cebc4a70e99aba7da9e" translate="yes" xml:space="preserve">
          <source>There have been three historical file formats for SQLite. SQLite 1.0 through 1.0.32 used the &lt;a href=&quot;https://www.gnu.org/software/gdbm/gdbm.html&quot;&gt;gdbm&lt;/a&gt; library as its storage engine. SQLite 2.0.0 through 2.8.17 used a custom b-tree storage engine that supported only text keys and data. All modern versions of SQLite (3.0.0 to present) use a b-tree storage engine that has full support for binary data and Unicode.</source>
          <target state="translated">SQLiteには、3つの歴史的なファイル形式があります。SQLite 1.0から1.0.32までは、ストレージエンジンとして&lt;a href=&quot;https://www.gnu.org/software/gdbm/gdbm.html&quot;&gt;gdbm&lt;/a&gt;ライブラリを使用していました。SQLite 2.0.0から2.8.17までは、テキストキーとデータのみをサポートするカスタムBツリーストレージエンジンを使用していました。SQLiteの最新バージョン（3.0.0から現在まで）はすべて、バイナリデータとUnicodeを完全にサポートするBツリーストレージエンジンを使用しています。</target>
        </trans-unit>
        <trans-unit id="3be8d2f16b71e4444f7f725739b5254eb08f103c" translate="yes" xml:space="preserve">
          <source>There is a function named &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; which will return the integer key for the most recent insert operation.</source>
          <target state="translated">最新の挿入操作の整数キーを返す&lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）&lt;/a&gt;という名前の関数があります。</target>
        </trans-unit>
        <trans-unit id="2c4047eace270e4351576190943319e0de00174c" translate="yes" xml:space="preserve">
          <source>There is a limit, set using &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; and &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitattached&quot;&gt;SQLITE_LIMIT_ATTACHED&lt;/a&gt;, to the number of databases that can be simultaneously attached to a single database connection.</source>
          <target state="translated">&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;と&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitattached&quot;&gt;SQLITE_LIMIT_ATTACHED&lt;/a&gt;を使用して設定された、単一のデータベース接続に同時に接続できるデータベースの数には制限があります。</target>
        </trans-unit>
        <trans-unit id="d03b97c401c9a348f14fea8d291ce117238dc810" translate="yes" xml:space="preserve">
          <source>There is a long list of conditions that must all be met in order for query flattening to occur. Some of the constraints are marked as obsolete by italic text. These extra constraints are retained in the documentation to preserve the numbering of the other constraints.</source>
          <target state="translated">クエリの平坦化が発生するためには、すべて満たさなければならない条件の長いリストがあります。いくつかの制約は、イタリック体のテキストで廃止されたものとしてマークされています。これらの余分な制約は、他の制約の番号付けを維持するために、ドキュメントに保持されています。</target>
        </trans-unit>
        <trans-unit id="098b1868e66c13228c4371a548aa26b3bfac10d5" translate="yes" xml:space="preserve">
          <source>There is a new TypeOf() function used to determine if an expression is numeric or text.</source>
          <target state="translated">式が数値かテキストかを判断するために使用される新しい TypeOf()関数があります。</target>
        </trans-unit>
        <trans-unit id="e6da2fbcc052924976fcf688d82595c343604804" translate="yes" xml:space="preserve">
          <source>There is a single row in the sqlite_sequence table for each ordinary table that uses AUTOINCREMENT. The name of the table (as it appears in sqlite_master.name) is in the sqlite_sequence.main field and the largest &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; ever inserted into that table is in the sqlite_sequence.seq field. New automatically generated integer primary keys for AUTOINCREMENT tables are guaranteed to be larger than the sqlite_sequence.seq field for that table. If the sqlite_sequence.seq field of an AUTOINCREMENT table is already at the largest integer value (9223372036854775807) then attempts to add new rows to that table with an automatically generated integer primary will fail with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error. The sqlite_sequence.seq field is automatically updated if required when new entries are inserted to an AUTOINCREMENT table. The sqlite_sequence row for an AUTOINCREMENT table is automatically deleted when the table is dropped. If the sqlite_sequence row for an AUTOINCREMENT table does not exist when the AUTOINCREMENT table is updated, then a new sqlite_sequence row is created. If the sqlite_sequence.seq value for an AUTOINCREMENT table is manually set to something other than an integer and there is a subsequent attempt to insert the or update the AUTOINCREMENT table, then the behavior is undefined.</source>
          <target state="translated">AUTOINCREMENTを使用する通常のテーブルごとに、sqlite_sequenceテーブルに単一の行があります。テーブルの名前（sqlite_master.nameに表示される）はsqlite_sequence.mainフィールドにあり、そのテーブルに挿入された最大の&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;はsqlite_sequence.seqフィールドにあります。 AUTOINCREMENTテーブルの新しい自動生成整数主キーは、そのテーブルのsqlite_sequence.seqフィールドより大きいことが保証されています。 AUTOINCREMENTテーブルのsqlite_sequence.seqフィールドがすでに最大の整数値（9223372036854775807）にある場合、自動生成された整数のプライマリを使用してそのテーブルに新しい行を追加しようとすると、&lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULLで&lt;/a&gt;失敗します。エラー。sqlite_sequence.seqフィールドは、新しいエントリがAUTOINCREMENTテーブルに挿入されると、必要に応じて自動的に更新されます。AUTOINCREMENTテーブルのsqlite_sequence行は、テーブルが削除されると自動的に削除されます。AUTOINCREMENTテーブルの更新時にAUTOINCREMENTテーブルのsqlite_sequence行が存在しない場合は、新しいsqlite_sequence行が作成されます。AUTOINCREMENTテーブルのsqlite_sequence.seq値が手動で整数以外の値に設定されていて、その後にAUTOINCREMENTテーブルを挿入または更新しようとした場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="873101a14a572759e5a45b0dc79cf0cd42bbd9dd" translate="yes" xml:space="preserve">
          <source>There is a single row in the sqlite_sequence table for each ordinary table that uses AUTOINCREMENT. The name of the table (as it appears in sqlite_schema.name) is in the sqlite_sequence.main field and the largest &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; ever inserted into that table is in the sqlite_sequence.seq field. New automatically generated integer primary keys for AUTOINCREMENT tables are guaranteed to be larger than the sqlite_sequence.seq field for that table. If the sqlite_sequence.seq field of an AUTOINCREMENT table is already at the largest integer value (9223372036854775807) then attempts to add new rows to that table with an automatically generated integer primary will fail with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error. The sqlite_sequence.seq field is automatically updated if required when new entries are inserted to an AUTOINCREMENT table. The sqlite_sequence row for an AUTOINCREMENT table is automatically deleted when the table is dropped. If the sqlite_sequence row for an AUTOINCREMENT table does not exist when the AUTOINCREMENT table is updated, then a new sqlite_sequence row is created. If the sqlite_sequence.seq value for an AUTOINCREMENT table is manually set to something other than an integer and there is a subsequent attempt to insert the or update the AUTOINCREMENT table, then the behavior is undefined.</source>
          <target state="translated">AUTOINCREMENTを使用する通常のテーブルごとに、sqlite_sequenceテーブルに1つの行があります。テーブルの名前（sqlite_schema.nameに表示される）はsqlite_sequence.mainフィールドにあり、そのテーブルにこれまでに挿入された最大の&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER&lt;/a&gt; PRIMARYKEYはsqlite_sequence.seqフィールドにあります。 AUTOINCREMENTテーブルの新しい自動生成された整数主キーは、そのテーブルのsqlite_sequence.seqフィールドよりも大きいことが保証されています。 AUTOINCREMENTテーブルのsqlite_sequence.seqフィールドがすでに最大の整数値（9223372036854775807）にある場合、自動生成された整数プライマリを使用してそのテーブルに新しい行を追加しようとすると、&lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULLで&lt;/a&gt;失敗します。エラー。AUTOINCREMENTテーブルに新しいエントリが挿入されると、必要に応じてsqlite_sequence.seqフィールドが自動的に更新されます。AUTOINCREMENTテーブルのsqlite_sequence行は、テーブルが削除されると自動的に削除されます。AUTOINCREMENTテーブルの更新時にAUTOINCREMENTテーブルのsqlite_sequence行が存在しない場合は、新しいsqlite_sequence行が作成されます。AUTOINCREMENTテーブルのsqlite_sequence.seq値が手動で整数以外に設定され、その後AUTOINCREMENTテーブルを挿入または更新しようとした場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="f02c79b70988445eed051dee5ef879c5abc0fcef" translate="yes" xml:space="preserve">
          <source>There is a single row of the dbstat table for each page in the database file. Freelist pages, the lock page, and pointer-map pages of the database file do not appear in the dbstat virtual table.</source>
          <target state="translated">dbstat テーブルには、データベース ファイル内の各ページに対して 1 行の行があります。データベースファイルのフリーリストページ、ロックページ、ポインタマップページは、dbstat仮想テーブルには表示されません。</target>
        </trans-unit>
        <trans-unit id="aad819f0714ba351410884e15d9171da8c02d268" translate="yes" xml:space="preserve">
          <source>There is also a &quot;.once -e&quot; command which works similarly, except that it names the temporary file with a &quot;.txt&quot; suffix so that the default text editor for the system will be invoked, instead of the default spreadsheet.</source>
          <target state="translated">.once -e&quot; コマンドもありますが、これは一時ファイルの名前に &quot;.txt&quot; という接尾辞を付けて、デフォルトのスプレッドシートではなく、システムのデフォルトのテキストエディタが起動されるようにすることを除いては、同様に動作します。</target>
        </trans-unit>
        <trans-unit id="d689365d69d51f44124dabea5ed23d15cbc239dd" translate="yes" xml:space="preserve">
          <source>There is also a function for computing the Wagner edit distance or the Levenshtein distance between a pattern and a word. This function is exposed as spellfix1_editdist(X,Y). The edit distance function returns the &quot;cost&quot; of converting X into Y. Some transformations cost more than others. Changing one vowel into a different vowel, for example is relatively cheap, as is doubling a constant, or omitting the second character of a double-constant. Other transformations or more expensive. The idea is that the edit distance function returns a low cost for words that are similar and a higher cost for words that are further apart. In this implementation, the maximum cost of any single-character edit (delete, insert, or substitute) is 100, with lower costs for some edits (such as transforming vowels).</source>
          <target state="translated">また、パターンと単語の間の Wagner edit distance や Levenshtein distance を計算する関数もあります。この関数は spellfix1_editdist(X,Y)という名前で公開されています。この関数は、X を Y に変換する際の「コスト」を返します。たとえば、ある母音を別の母音に変えるのは比較的安価ですし、定数を 2 倍にしたり、二重定数の二文字目を省略したりするのと同じです。その他の変換やより高価です。これは、編集距離関数が、似ている単語に対しては低いコストを返し、さらに離れている単語に対しては高いコストを返すという考え方である。この実装では、1文字の編集(削除、挿入、置換)の最大コストは100であり、いくつかの編集(母音の変換など)ではコストが低くなります。</target>
        </trans-unit>
        <trans-unit id="8f729e8ad1be217b3b85bb1dbd08e4580826f423" translate="yes" xml:space="preserve">
          <source>There is also a new &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt; opcode for the &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; that allows an application to query the powersafe overwrite property for a database file.</source>
          <target state="translated">また、アプリケーションがデータベースファイルのpowersafe overwriteプロパティをクエリできるようにする&lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control（）の&lt;/a&gt;新しい&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt;オペコードもあります。</target>
        </trans-unit>
        <trans-unit id="d5d98dc46e0aff9a749813616cdf742a9f8913ea" translate="yes" xml:space="preserve">
          <source>There is also an SQL function that can be used to load extensions: &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension(X,Y)&lt;/a&gt;. It works just like the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; C interface.</source>
          <target state="translated">拡張機能のロードに使用できるSQL関数&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension（X、Y）もあり&lt;/a&gt;ます。&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt; Cインターフェースと同じように機能します。</target>
        </trans-unit>
        <trans-unit id="043cd14b86c980f673cef92a152d79c2c6e3cf2c" translate="yes" xml:space="preserve">
          <source>There is always a default VFS. The legacy interfaces &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; always use the default VFS. The new interface for creating database connections, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, allows you to specify which VFS you want to use by name.</source>
          <target state="translated">常にデフォルトのVFSがあります。従来のインターフェース&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;と&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（）は&lt;/a&gt;常にデフォルトのVFSを使用します。データベース接続を作成するための新しいインターフェース&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;を使用すると、使用するVFSを名前で指定できます。</target>
        </trans-unit>
        <trans-unit id="a75d63f61cb222d77eadc6074711ab25e460df12" translate="yes" xml:space="preserve">
          <source>There is always one VFS which is the default VFS. On unix systems, the &quot;unix&quot; VFS comes up as the default and on windows it is &quot;win32&quot;. If no other actions are taken, new database connections will make use of the default VFS.</source>
          <target state="translated">デフォルトのVFSは常に1つです。unixシステムでは、&quot;unix&quot; VFSがデフォルトで、Windowsでは &quot;win32 &quot;です。他に何もしなければ、新しいデータベース接続はデフォルトのVFSを使用します。</target>
        </trans-unit>
        <trans-unit id="a07e87b2dfc85be098248de6c63083968b9cc2a5" translate="yes" xml:space="preserve">
          <source>There is an additional quasi-persistent &quot;&lt;code&gt;-wal&lt;/code&gt;&quot; file and &quot;&lt;code&gt;-shm&lt;/code&gt;&quot; shared memory file associated with each database, which can make SQLite less appealing for use as an &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt;.</source>
          <target state="translated">追加の準永続的な「 &lt;code&gt;-wal&lt;/code&gt; 」ファイルと「 &lt;code&gt;-shm&lt;/code&gt; 」共有メモリファイルが各データベースに関連付けられているため、SQLiteを&lt;a href=&quot;appfileformat&quot;&gt;アプリケーションファイル形式&lt;/a&gt;として使用するのに魅力がなくなります。</target>
        </trans-unit>
        <trans-unit id="6c15ef6d2dec509f5afb1c6ad236607cae0e66e0" translate="yes" xml:space="preserve">
          <source>There is an assortment of sqlite3_bind routines used to assign values to wildcards in a prepared SQL statement. Unbound wildcards are interpreted as NULLs. Bindings are not reset by sqlite3_reset(). But wildcards can be rebound to new values after an sqlite3_reset().</source>
          <target state="translated">準備されたSQL文のワイルドカードに値を代入するために使用されるsqlite3_bindルーチンがあります。束縛されていないワイルドカードはNULLとして解釈されます。バインドはsqlite3_reset()によってリセットされません。しかし、ワイルドカードはsqlite3_reset()の後で新しい値にリバウンドすることができます。</target>
        </trans-unit>
        <trans-unit id="1cba197f7f4cf87333685b6d55dd8ea7d285abdf" translate="yes" xml:space="preserve">
          <source>There is an implied &quot;&lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; 0 0 0&quot; instruction inserted at the very end of every program. So a jump past the last instruction of the program is the same as executing &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt;.</source>
          <target state="translated">すべてのプログラムの最後に暗黙の「&lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; 0 0 0 &quot;命令が挿入されています。したがって、プログラムの最後の命令を通過するジャンプは、&lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt;を実行することと同じです。</target>
        </trans-unit>
        <trans-unit id="16ef4ec82cf13cdae86f5bf01316c19576909f0f" translate="yes" xml:space="preserve">
          <source>There is an unofficial and unsanctioned Git clone of this repository at &lt;a href=&quot;https://github.com/mackyle/sqlite&quot;&gt;https://github.com/mackyle/sqlite&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/mackyle/sqlite&quot;&gt;https://github.com/mackyle/sqliteに&lt;/a&gt;、このリポジトリの非公式で認可されていないGitクローンがあります。</target>
        </trans-unit>
        <trans-unit id="bea5c372cd0bf0b6a49c619c32079d5921e4aed3" translate="yes" xml:space="preserve">
          <source>There is another, deprecated, method for invoking the optimize operation using a SELECT statement. New code should use statements similar to the INSERT above to optimize FTS structures.</source>
          <target state="translated">SELECT文を使用して最適化処理を実行するための別の、非推奨の方法があります。新しいコードでは、FTS構造を最適化するために上記のINSERTと同様のステートメントを使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="b085a1ad6ab5d12c0b0eb9f325abf631b21418bf" translate="yes" xml:space="preserve">
          <source>There is no &quot;CREATE TEMP VIRTUAL TABLE&quot; statement. To create a temporary virtual table, add the &quot;temp&quot; schema before the virtual table name.</source>
          <target state="translated">CREATE TEMP VIRTUAL TABLE」文はありません。一時的な仮想テーブルを作成するには、仮想テーブル名の前に &quot;temp &quot;スキーマを追加します。</target>
        </trans-unit>
        <trans-unit id="f17db4bcecd606fe4d51c30c972432fc774cef49" translate="yes" xml:space="preserve">
          <source>There is no RESERVED lock on the corresponding database file.</source>
          <target state="translated">対応するデータベース・ファイルには、RESERVEDEDロックはありません。</target>
        </trans-unit>
        <trans-unit id="e99ed00de2d6f07769da563a3ed2aa8bf01a7e2e" translate="yes" xml:space="preserve">
          <source>There is no agreement on what the C datatype for a UTF-16 string should be. Therefore, SQLite uses a generic type of void* to refer to UTF-16 strings. Client software can cast the void* to whatever datatype is appropriate for their system.</source>
          <target state="translated">UTF-16文字列のCデータ型はどうあるべきかについては合意がありません。そのため、SQLiteではUTF-16文字列を参照するために一般的な型のvoid*を使用しています。クライアントソフトウェアは、システムに適したデータ型にvoid*をキャストすることができます。</target>
        </trans-unit>
        <trans-unit id="c505515229e6ccfbb2128baeaa4350ad9e337f7c" translate="yes" xml:space="preserve">
          <source>There is no conflicting row in this case. The results of invoking the sqlite3changeset_conflict() API are undefined.</source>
          <target state="translated">この場合、競合する行はありません。sqlite3changeset_conflict()APIを呼び出した結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="a04b936246a75ee50e5104c87c5e5c3bc05ae139" translate="yes" xml:space="preserve">
          <source>There is no pre-defined release cycle. Releases occur when there is a critical mass of feature enhancements and/or bug fixes. Historically, releases have occurred about 5 or 6 times per year. Users of SQLite pick up new releases from the website on an as-needed basis.</source>
          <target state="translated">事前に定義されたリリースサイクルはありません。リリースは、機能強化やバグ修正がクリティカルな量に達したときに発生します。歴史的に、リリースは年に5、6回程度行われてきました。SQLite のユーザーは、必要に応じてウェブサイトから新しいリリースを入手します。</target>
        </trans-unit>
        <trans-unit id="dd71d330015524aacf28e91f9c23458da952387d" translate="yes" xml:space="preserve">
          <source>There is no reserved lock on the main database file.</source>
          <target state="translated">メインデータベースファイルには予約ロックがありません。</target>
        </trans-unit>
        <trans-unit id="7df732794b7961185fb08c11a413b1539639964a" translate="yes" xml:space="preserve">
          <source>There is no support for &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;. Changes to virtual tables are not captured.</source>
          <target state="translated">&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;はサポートされていません。仮想テーブルへの変更はキャプチャされません。</target>
        </trans-unit>
        <trans-unit id="11d7bfeb25e84c6d1e9766a1abf1f94079350c5e" translate="yes" xml:space="preserve">
          <source>There is normally one row per index, with the index identified by the name in the sqlite_stat1.idx column. The sqlite_stat1.tbl column is the name of the table to which the index belongs. In each such row, the sqlite_stat.stat column will be a string consisting of a list of integers followed by zero or more arguments. The first integer in this list is the approximate number of rows in the index. (The number of rows in the index is the same as the number of rows in the table, except for &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;.) The second integer is the approximate number of rows in the index that have the same value in the first column of the index. The third integer is the number number of rows in the index that have the same value for the first two columns. The N-th integer (for N&amp;gt;1) is the estimated average number of rows in the index which have the same value for the first N-1 columns. For a K-column index, there will be K+1 integers in the stat column. If the index is unique, then the last integer will be 1.</source>
          <target state="translated">通常、インデックスごとに1つの行があり、インデックスはsqlite_stat1.idx列の名前で識別されます。sqlite_stat1.tbl列は、インデックスが属するテーブルの名前です。このような各行のsqlite_stat.stat列は、整数のリストとそれに続く0個以上の引数で構成される文字列になります。このリストの最初の整数は、インデックス内のおおよその行数です。（インデックスの行数は、&lt;a href=&quot;partialindex&quot;&gt;部分的なインデックス&lt;/a&gt;を除いて、テーブルの行数と同じです。。）2番目の整数は、インデックスの最初の列に同じ値を持つインデックスの行の概数です。3番目の整数は、最初の2つの列に同じ値を持つインデックス内の行の数です。N番目の整数（N&amp;gt; 1の場合）は、最初のN-1列と同じ値を持つインデックスの行の推定平均数です。K列のインデックスの場合、stat列にはK + 1の整数があります。インデックスが一意の場合、最後の整数は1になります。</target>
        </trans-unit>
        <trans-unit id="c9c3e6d9120e8e4bfa41b1d6a3111f7343cb6f19" translate="yes" xml:space="preserve">
          <source>There is now a compile-time option that allows an application to define alternative malloc()/free() implementations without having to modify any core SQLite code.</source>
          <target state="translated">コアとなる SQLite のコードを変更することなく、アプリケーションが代替の malloc()/free()実装を定義できるようにするコンパイル時のオプションが追加されました。</target>
        </trans-unit>
        <trans-unit id="f62ae2b58bd448bf76ec1b9c9d9ded56906eaff1" translate="yes" xml:space="preserve">
          <source>There is now a compile-time option that allows an application to define alternative mutex implementations without having to modify any core SQLite code.</source>
          <target state="translated">これにより、アプリケーションはSQLiteのコアコードを変更することなく、代替のミューテックス実装を定義することができるようになりました。</target>
        </trans-unit>
        <trans-unit id="b1cb6058c59ace1351641df9e565cb12b51e73fe" translate="yes" xml:space="preserve">
          <source>There is one entry in the %_node table for each R*Tree node. An R*Tree node consists of one or more entries that are proximate to one another. The nodes of an R*Tree for a tree. All nodes other than the root have an entry in the %_parent shadow table that identifies the parent node. Each entry in an R*Tree has a rowid. The %_rowid shadow table maps entry rowids to the node that contains that entry.</source>
          <target state="translated">各 R*Tree ノードには %_node テーブルに 1 つのエントリがあります。R*Tree ノードは、互いに近接している 1 つ以上のエントリで構成されます。ツリーの R*Tree のノード。ルート以外のすべてのノードには、親ノードを識別する %_parent シャドウ・テーブルのエントリがあります。R*Tree の各エントリには rowid があります。rowid シャドウ・テーブルは、エントリの行 ID をそのエントリを含むノードにマップします。</target>
        </trans-unit>
        <trans-unit id="91aa566670abb0466fc190ee57ffd69271a7af7c" translate="yes" xml:space="preserve">
          <source>There is one exception to the previous paragraph: when a row is inserted, updated or deleted, if one or more of its primary key columns contain a NULL value, no record of the change is made.</source>
          <target state="translated">行の挿入、更新、削除の際に、1つ以上の主キー列にNULL値が含まれている場合、変更の記録は作成されません。</target>
        </trans-unit>
        <trans-unit id="545885bb104866881571615fd910604fef6b0f44" translate="yes" xml:space="preserve">
          <source>There is one important difference between ON UPDATE foreign key actions and SQL triggers. An ON UPDATE action is only taken if the values of the parent key are modified so that the new parent key values are not equal to the old. For example:</source>
          <target state="translated">外部キーのON UPDATEアクションとSQLトリガーの間には、1つの重要な違いがあります。ON UPDATEアクションは、親キーの値が変更され、新しい親キーの値が古い値と一致しない場合にのみ実行されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="67f4030e1b4840bae9054c024eff72bf5cb42560" translate="yes" xml:space="preserve">
          <source>There is one other subtle difference between &quot;docid&quot; and the normal SQLite aliases for the rowid column. Normally, if an INSERT or UPDATE statement assigns discrete values to two or more aliases of the rowid column, SQLite writes the rightmost of such values specified in the INSERT or UPDATE statement to the database. However, assigning a non-NULL value to both the &quot;docid&quot; and one or more of the SQLite rowid aliases when inserting or updating an FTS table is considered an error. See below for an example.</source>
          <target state="translated">docid&quot; と rowid 列の通常の SQLite エイリアスとの間には、もう一つ微妙な違いがあります。通常、INSERT 文または UPDATE 文が rowid 列の 2 つ以上のエイリアスに個別の値を割り当てる場合、SQLite は INSERT 文または UPDATE 文で指定された値のうち、一番右の値をデータベースに書き込みます。ただし、FTS テーブルを挿入または更新する際に、&quot;docid&quot; と SQLite rowid の 1 つ以上のエイリアスの両方に NULL でない値を代入すると、エラーとみなされます。以下の例を参照してください。</target>
        </trans-unit>
        <trans-unit id="f856aedc1ad69cfc42357d4bdb200682208f50ab" translate="yes" xml:space="preserve">
          <source>There is only one sorter object, so there are no instructions to open or close it. It is opened automatically when needed, and it is closed when the VDBE program halts.</source>
          <target state="translated">ソーターオブジェクトは1つしかないので、開閉の指示はない。必要に応じて自動的に開き、VDBEプログラムが停止すると閉じます。</target>
        </trans-unit>
        <trans-unit id="6e50e0d48c576b86d93a31befcc02f54e14b5267" translate="yes" xml:space="preserve">
          <source>There is the extra operation of &lt;a href=&quot;wal#ckpt&quot;&gt;checkpointing&lt;/a&gt; which, though automatic by default, is still something that application developers need to be mindful of.</source>
          <target state="translated">&lt;a href=&quot;wal#ckpt&quot;&gt;チェックポイント&lt;/a&gt;の追加操作がありますが、これはデフォルトでは自動ですが、アプリケーション開発者が注意する必要があるものです。</target>
        </trans-unit>
        <trans-unit id="62428f96be095192850e1858e6283c21fe02dd48" translate="yes" xml:space="preserve">
          <source>There is write permission on the directory containing the database so that the &lt;code&gt;-shm&lt;/code&gt; and &lt;code&gt;-wal&lt;/code&gt; files can be created.</source>
          <target state="translated">&lt;code&gt;-shm&lt;/code&gt; および &lt;code&gt;-wal&lt;/code&gt; ファイルを作成できるように、データベースを含むディレクトリに書き込み権限があります。</target>
        </trans-unit>
        <trans-unit id="5b6352389dca7ff834f53599bb4e1238c6a257d8" translate="yes" xml:space="preserve">
          <source>There may be at most one unlock-notify callback registered by a blocked connection. If sqlite3_unlock_notify() is called when the blocked connection already has a registered unlock-notify callback, then the new callback replaces the old. If sqlite3_unlock_notify() is called with a NULL pointer as its second argument, then any existing unlock-notify callback is canceled. The blocked connections unlock-notify callback may also be canceled by closing the blocked connection using &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">ブロックされた接続によって登録された最大1つのロック解除通知コールバックがある場合があります。ブロックされた接続にすでに登録されたロック解除通知コールバックがあるときにsqlite3_unlock_notify（）が呼び出された場合、新しいコールバックが古いコールバックを置き換えます。 2番目の引数としてNULLポインターを指定してsqlite3_unlock_notify（）を呼び出すと、既存のロック解除通知コールバックはキャンセルされます。ブロックされた接続のロック解除通知コールバックは、&lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close（）&lt;/a&gt;を使用してブロックされた接続を閉じることによってキャンセルすることもできます。</target>
        </trans-unit>
        <trans-unit id="474f04800d7576cb1df432f79959d44e97ec88c4" translate="yes" xml:space="preserve">
          <source>There may be at most one unlock-notify callback registered by a blocked connection. If sqlite3_unlock_notify() is called when the blocked connection already has a registered unlock-notify callback, then the new callback replaces the old. If sqlite3_unlock_notify() is called with a NULL pointer as its second argument, then any existing unlock-notify callback is canceled. The blocked connections unlock-notify callback may also be canceled by closing the blocked connection using &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">ブロックされた接続によって登録された最大1つのロック解除通知コールバックがある場合があります。ブロックされた接続にすでに登録されたロック解除通知コールバックがあるときにsqlite3_unlock_notify（）が呼び出された場合、新しいコールバックが古いコールバックを置き換えます。 2番目の引数としてNULLポインターを指定してsqlite3_unlock_notify（）を呼び出すと、既存のロック解除通知コールバックはキャンセルされます。ブロックされた接続のロック解除通知コールバックは、&lt;a href=&quot;close&quot;&gt;sqlite3_close（）&lt;/a&gt;を使用してブロックされた接続を閉じることによってキャンセルすることもできます。</target>
        </trans-unit>
        <trans-unit id="51e2e6b0569ca6a8c745966ed3e14378d13e60a9" translate="yes" xml:space="preserve">
          <source>There might be merge conflicts. In other words, it might be that the changes from (2) to (3) are incompatible with the changes from (1) to (4). In that case, the maintainer will have to manually resolve the conflicts. Hopefully conflicts will not come up that often. Conflicts are less likely to occur when the private edits are kept to a minimum.</source>
          <target state="translated">マージコンフリクトがあるかもしれません。言い換えれば、(2)から(3)への変更と(1)から(4)への変更が矛盾しているかもしれません。その場合、メンテナは手動でコンフリクトを解決しなければなりません。うまくいけば、コンフリクトはそれほど頻繁には起こらないでしょう。プライベートな編集を最小限に抑えれば、コンフリクトは起こりにくくなります。</target>
        </trans-unit>
        <trans-unit id="c1f15675484de7896b9f4cea6917b5f96c0a2c61" translate="yes" xml:space="preserve">
          <source>There might be one or more &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; objects open and in use on the virtual table instance and perhaps even on the row of the virtual table when the xUpdate method is invoked. The implementation of xUpdate must be prepared for attempts to delete or modify rows of the table out from other existing cursors. If the virtual table cannot accommodate such changes, the xUpdate method must return an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">1つ以上の&lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt;オブジェクトが開いていて、仮想テーブルインスタンスで使用されている可能性があります。また、xUpdateメソッドが呼び出されたときに仮想テーブルの行で使用されている可能性もあります。xUpdateの実装は、他の既存のカーソルからテーブルの行を削除または変更する試みに備えて準備する必要があります。仮想テーブルがそのような変更に対応できない場合、xUpdateメソッドは&lt;a href=&quot;rescode&quot;&gt;エラーコードを&lt;/a&gt;返す必要があります。</target>
        </trans-unit>
        <trans-unit id="f17a65d092891c67c0c7c0d6ffba57606e51c65a" translate="yes" xml:space="preserve">
          <source>There must be a read-lock on the database (either a transaction must be started or there must be an open cursor) before executing this instruction.</source>
          <target state="translated">この命令を実行する前に、データベースにリードロックがなければなりません(トランザクションが開始されているか、オープンカーソルがなければなりません)。</target>
        </trans-unit>
        <trans-unit id="838abced0ca5c629a232ce0c8ac382dc2a5201e9" translate="yes" xml:space="preserve">
          <source>There must be no overlap in the bands of rowids for the various tables in a union-vtab.</source>
          <target state="translated">union-vtab内の様々なテーブルのrowidsのバンドが重複していてはいけません。</target>
        </trans-unit>
        <trans-unit id="2f109c8b1d1e372963703dc38ccb68fefa2006aa" translate="yes" xml:space="preserve">
          <source>There must be no overlapping rowid ranges in the rows returned by the SQL statement. It is an error if there are.</source>
          <target state="translated">SQL 文によって返される行には、重複する rowid の範囲があってはなりません。重複している場合はエラーになります。</target>
        </trans-unit>
        <trans-unit id="af3fe573da439b499f0025edd3eb3c7aa3d7e8cd" translate="yes" xml:space="preserve">
          <source>There must not be a write transaction open on schema S of database connection D.</source>
          <target state="translated">データベース接続DのスキーマS上に書き込みトランザクションが開いていてはいけません。</target>
        </trans-unit>
        <trans-unit id="3d41940c4561987aa3b448b06598e8d1c6472839" translate="yes" xml:space="preserve">
          <source>There should be exactly one call to sqlite3_backup_finish() for each successful call to sqlite3_backup_init().</source>
          <target state="translated">sqlite3_backup_init()の呼び出しが成功するたびに、sqlite3_backup_finish()を1回だけ呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="9cf5a0f0e6851073aea7c635470af127d9d907d8" translate="yes" xml:space="preserve">
          <source>There were reports that SQLite did not perform as well on an indexed table. This test was recently added to disprove those rumors. It is true that SQLite is not as fast at creating new index entries as the other engines (see Test 6 below) but its overall speed is still better.</source>
          <target state="translated">SQLiteがインデックス付きのテーブルではパフォーマンスが低いという報告がありました。このテストはそれらの噂を反証するために最近追加されました。確かにSQLiteは他のエンジンほど新しいインデックスエントリを作成する速度は速くありませんが(下記のテスト6を参照)、全体的な速度はまだ優れています。</target>
        </trans-unit>
        <trans-unit id="7cdb3ca5132a0c3bc86c19fe3abd0889729f8701" translate="yes" xml:space="preserve">
          <source>These APIs are only available if the library was compiled with the &lt;a href=&quot;../compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; C-preprocessor symbol.</source>
          <target state="translated">これらのAPIは、ライブラリが&lt;a href=&quot;../compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; Cプリプロセッサシンボルでコンパイルされている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="04c8e718505dcab90cfc6233e2bd22375b7164d1" translate="yes" xml:space="preserve">
          <source>These APIs are only available if the library was compiled with the &lt;a href=&quot;compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; C-preprocessor symbol.</source>
          <target state="translated">これらのAPIは、ライブラリが&lt;a href=&quot;compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; Cプリプロセッサシンボルでコンパイルされている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="c0bacb531ef3c143611b93d8575c5722c7b86645" translate="yes" xml:space="preserve">
          <source>These action code values signify what kind of operation is to be authorized. The 3rd and 4th parameters to the authorization callback function will be parameters or NULL depending on which of these codes is used as the second parameter. The 5th parameter to the authorizer callback is the name of the database (&quot;main&quot;, &quot;temp&quot;, etc.) if applicable. The 6th parameter to the authorizer callback is the name of the inner-most trigger or view that is responsible for the access attempt or NULL if this access attempt is directly from top-level SQL code.</source>
          <target state="translated">これらのアクションコードの値は、どのような操作を認可するかを示します。認証コールバック関数の3番目と4番目のパラメータは、2番目のパラメータとしてどのコードを使用するかに応じてパラメータかNULLになります。認可コールバック関数の5番目のパラメータは、データベースの名前(該当する場合は &quot;main&quot;、&quot;temp &quot;など)です。認証先コールバックの6番目のパラメータは、アクセス試行の原因となった最上位のトリガまたはビューの名前、またはアクセス試行がトップレベルSQLコードから直接行われている場合はNULLです。</target>
        </trans-unit>
        <trans-unit id="08d99679f060455eb057ba3c4cf117bfe450c567" translate="yes" xml:space="preserve">
          <source>These and other similar syntax restrictions are described in the text.</source>
          <target state="translated">これらおよび他の類似の構文の制限については、本文に記載されています。</target>
        </trans-unit>
        <trans-unit id="373ccf29c36481aabf98cf8d5fcf341e72288794" translate="yes" xml:space="preserve">
          <source>These are just a few of the benefits of using SQLite as an application file format &amp;mdash; the benefits that seem most likely to improve the user experience for applications like OpenOffice. Other applications might benefit from SQLite in different ways. See the &lt;a href=&quot;appfileformat&quot;&gt;Application File Format&lt;/a&gt; document for additional ideas.</source>
          <target state="translated">これらは、SQLiteをアプリケーションファイル形式として使用する利点のほんの一部です。OpenOfficeなどのアプリケーションのユーザーエクスペリエンスを向上させる可能性が最も高いと思われる利点です。他のアプリケーションは、SQLiteからさまざまな方法で恩恵を受けるかもしれません。その他のアイデアについては、&lt;a href=&quot;appfileformat&quot;&gt;アプリケーションファイル形式の&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="840704459c7bebebba604f0b7c84031cf12ac5c7" translate="yes" xml:space="preserve">
          <source>These are special values for the destructor that is passed in as the final argument to routines like &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_blob()&lt;/a&gt;. If the destructor argument is SQLITE_STATIC, it means that the content pointer is constant and will never change. It does not need to be destroyed. The SQLITE_TRANSIENT value means that the content will likely change in the near future and that SQLite should make its own private copy of the content before returning.</source>
          <target state="translated">これらは、&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_blob（）の&lt;/a&gt;ようなルーチンへの最後の引数として渡されるデストラクタの特別な値です。デストラクタの引数がSQLITE_STATICの場合、コンテンツポインタは定数であり、変更されることはありません。破壊する必要はありません。SQLITE_TRANSIENT値は、コンテンツが近い将来変更される可能性があり、SQLiteが戻る前にコンテンツの独自のプライベートコピーを作成する必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="3097b1326f3eb788f48bb5e49292e793f88d3f73" translate="yes" xml:space="preserve">
          <source>These are special values for the destructor that is passed in as the final argument to routines like &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_blob()&lt;/a&gt;. If the destructor argument is SQLITE_STATIC, it means that the content pointer is constant and will never change. It does not need to be destroyed. The SQLITE_TRANSIENT value means that the content will likely change in the near future and that SQLite should make its own private copy of the content before returning.</source>
          <target state="translated">これらは、&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_blob（）の&lt;/a&gt;ようなルーチンへの最後の引数として渡されるデストラクタの特別な値です。デストラクタの引数がSQLITE_STATICの場合、コンテンツポインタは定数であり、変更されることはありません。破壊する必要はありません。SQLITE_TRANSIENT値は、コンテンツが近い将来変更される可能性があり、SQLiteが戻る前にコンテンツの独自のプライベートコピーを作成する必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="49e507a42bf99a1526a38fb0d00d4e955eae6280" translate="yes" xml:space="preserve">
          <source>These are the eight locks supported:</source>
          <target state="translated">これらはサポートされている8つのロックです。</target>
        </trans-unit>
        <trans-unit id="b356241fa91bdf09876f0517086180731227ee47" translate="yes" xml:space="preserve">
          <source>These are utility routines, useful to &lt;a href=&quot;../vfs&quot;&gt;custom VFS implementations&lt;/a&gt;, that check if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter.</source>
          <target state="translated">これらは、&lt;a href=&quot;../vfs&quot;&gt;カスタムVFS実装に&lt;/a&gt;役立つユーティリティルーチンであり、データベースファイルが特定のクエリパラメータを含むURIであるかどうかを確認し、含まれている場合はそのクエリパラメータの値を取得します。</target>
        </trans-unit>
        <trans-unit id="56ef0cc4c32969ca19f4793dd10614a44d9a509c" translate="yes" xml:space="preserve">
          <source>These are utility routines, useful to &lt;a href=&quot;vfs&quot;&gt;custom VFS implementations&lt;/a&gt;, that check if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter.</source>
          <target state="translated">これらは、&lt;a href=&quot;vfs&quot;&gt;カスタムVFS実装に&lt;/a&gt;役立つユーティリティルーチンであり、データベースファイルが特定のクエリパラメータを含むURIであるかどうかを確認し、含まれている場合はそのクエリパラメータの値を取得します。</target>
        </trans-unit>
        <trans-unit id="d61de6a061e0e9a67e085323db1a55d01abf6a99" translate="yes" xml:space="preserve">
          <source>These are utility routines, useful to VFS implementations, that check to see if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter.</source>
          <target state="translated">これらはVFSの実装に便利なユーティリティルーチンで、データベースファイルが特定のクエリパラメータを含むURIであるかどうかをチェックし、その場合はそのクエリパラメータの値を取得します。</target>
        </trans-unit>
        <trans-unit id="0ae1c1d92689387597a221cbf4a8586463c0d9b8" translate="yes" xml:space="preserve">
          <source>These bit values are intended for use in the 3rd parameter to the &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface and in the 4th parameter to the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method.</source>
          <target state="translated">これらのビット値は、&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;インターフェースの3番目のパラメーター、および&lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt;メソッドの4番目のパラメーターで使用するためのものです。</target>
        </trans-unit>
        <trans-unit id="091c1cd775270574b7e8fe92576bddaa3dc774e3" translate="yes" xml:space="preserve">
          <source>These bit values are intended for use in the 3rd parameter to the &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface and in the 4th parameter to the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method.</source>
          <target state="translated">これらのビット値は、&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;インターフェースの3番目のパラメーター、および&lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt;メソッドの4番目のパラメーターで使用するためのものです。</target>
        </trans-unit>
        <trans-unit id="7379d4e0ce4f6675fd9028087eadfa8eb7ff4976" translate="yes" xml:space="preserve">
          <source>These changes in the default behavior of SQLite are not a compatibility break. All legacy database files continue to be readable and writable by newer versions of SQLite, and all newly created database files continue to be readable and writable by legacy versions of the SQLite library. The only thing that is changing is some default settings. This should result in a performance increase for many applications.</source>
          <target state="translated">これらのSQLiteのデフォルト動作の変更は、互換性の問題ではありません。すべてのレガシーデータベースファイルは、新しいバージョンの SQLite で読み書き可能な状態を維持し、新しく作成されたデータベースファイルは、レガシーバージョンの SQLite ライブラリで読み書き可能な状態を維持します。変更されるのは、いくつかのデフォルト設定だけです。これにより、多くのアプリケーションでパフォーマンスが向上するはずです。</target>
        </trans-unit>
        <trans-unit id="f8b6f19362cf61de4d3d35983b38ffd9c2bbd4d6" translate="yes" xml:space="preserve">
          <source>These constant define integer codes that represent the various text encodings supported by SQLite.</source>
          <target state="translated">これらの定数は、SQLite でサポートされている様々なテキストエンコーディングを表す整数コードを定義しています。</target>
        </trans-unit>
        <trans-unit id="28ee7781baba8510621fd94348e40d728944ee20" translate="yes" xml:space="preserve">
          <source>These constants are codes for each of those types.</source>
          <target state="translated">これらの定数は、それぞれのタイプのコードです。</target>
        </trans-unit>
        <trans-unit id="5d678085fc410906abd9ecdf3f62895a2bdac8f9" translate="yes" xml:space="preserve">
          <source>These constants are returned by &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; to inform a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation what the &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode is for the SQL statement being evaluated.</source>
          <target state="translated">これらの定数は&lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict（）&lt;/a&gt;によって返され、評価されるSQLステートメントの&lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;モードが&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;実装に通知されます。</target>
        </trans-unit>
        <trans-unit id="8d5af3a6c05bd2fcca2c0f972b2fd66256957f31" translate="yes" xml:space="preserve">
          <source>These constants are returned by &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; to inform a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implementation what the &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode is for the SQL statement being evaluated.</source>
          <target state="translated">これらの定数は&lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict（）&lt;/a&gt;によって返され、評価されるSQLステートメントの&lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;モードが&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;実装に通知されます。</target>
        </trans-unit>
        <trans-unit id="e0814beadd7fffeacf97b8f77142e48bc418e590" translate="yes" xml:space="preserve">
          <source>These constants are the available integer &quot;verbs&quot; that can be passed as the second argument to the &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;インターフェースの2番目の引数として渡すことができる使用可能な整数「動詞」です。</target>
        </trans-unit>
        <trans-unit id="ee8e50c4c247f1789de616c3122fcd5d75fef481" translate="yes" xml:space="preserve">
          <source>These constants are the available integer &quot;verbs&quot; that can be passed as the second argument to the &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;インターフェースの2番目の引数として渡すことができる使用可能な整数「動詞」です。</target>
        </trans-unit>
        <trans-unit id="5685826d85b489c4a4722d59958f312636d778f9" translate="yes" xml:space="preserve">
          <source>These constants are the available integer configuration options that can be passed as the first argument to the &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; interface.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;インターフェースの最初の引数として渡すことができる使用可能な整数構成オプションです。</target>
        </trans-unit>
        <trans-unit id="cb2ae78ea5b1ae2e5bfc176e2229bcc4eaa83a74" translate="yes" xml:space="preserve">
          <source>These constants are the available integer configuration options that can be passed as the first argument to the &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; interface.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;インターフェースの最初の引数として渡すことができる使用可能な整数構成オプションです。</target>
        </trans-unit>
        <trans-unit id="b8b83f50bcee4d621ab3350b27ae006d83053d8d" translate="yes" xml:space="preserve">
          <source>These constants are the available integer configuration options that can be passed as the second argument to the &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;インターフェースの2番目の引数として渡すことができる使用可能な整数構成オプションです。</target>
        </trans-unit>
        <trans-unit id="bfdbb7c579979335802d5433a0c4351cc2e64138" translate="yes" xml:space="preserve">
          <source>These constants are the available integer configuration options that can be passed as the second argument to the &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config（）&lt;/a&gt;インターフェースの2番目の引数として渡すことができる使用可能な整数構成オプションです。</target>
        </trans-unit>
        <trans-unit id="adcbc56bb51ca533b4d845770250da49d6cb92e5" translate="yes" xml:space="preserve">
          <source>These constants are the valid operation code parameters used as the first argument to &lt;a href=&quot;#sqlite3_test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt;.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;#sqlite3_test_control&quot;&gt;sqlite3_test_control（）の&lt;/a&gt;最初の引数として使用される有効なオペレーションコードパラメーターです。</target>
        </trans-unit>
        <trans-unit id="c9e83fda514b191357ca2f8a433c34a6a2561552" translate="yes" xml:space="preserve">
          <source>These constants are the valid operation code parameters used as the first argument to &lt;a href=&quot;test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt;.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;test_control&quot;&gt;sqlite3_test_control（）の&lt;/a&gt;最初の引数として使用される有効なオペレーションコードパラメーターです。</target>
        </trans-unit>
        <trans-unit id="01b7633fac6735c207dc2ef793e2ed3c159bf015" translate="yes" xml:space="preserve">
          <source>These constants define all valid values for the &quot;checkpoint mode&quot; passed as the third parameter to the &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; interface. See the &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; documentation for details on the meaning of each of these checkpoint modes.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）&lt;/a&gt;インターフェースに3番目のパラメーターとして渡される「チェックポイントモード」のすべての有効な値を定義します。これらの各チェックポイントモードの意味の詳細については、&lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）の&lt;/a&gt;ドキュメントをご覧ください。</target>
        </trans-unit>
        <trans-unit id="1096d3bfc46b56a1b04a8f3fad11f5e8e55e3e9f" translate="yes" xml:space="preserve">
          <source>These constants define all valid values for the &quot;checkpoint mode&quot; passed as the third parameter to the &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; interface. See the &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; documentation for details on the meaning of each of these checkpoint modes.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）&lt;/a&gt;インターフェースに3番目のパラメーターとして渡される「チェックポイントモード」のすべての有効な値を定義します。これらの各チェックポイントモードの意味の詳細については、&lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）の&lt;/a&gt;ドキュメントをご覧ください。</target>
        </trans-unit>
        <trans-unit id="f262688fc8aaf9f38b8c78556de1b6829b6de723" translate="yes" xml:space="preserve">
          <source>These constants define various flags that can be passed into &quot;prepFlags&quot; parameter of the &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; interfaces.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;および&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;インターフェースの「prepFlags」パラメーターに渡すことができるさまざまなフラグを定義します。</target>
        </trans-unit>
        <trans-unit id="52a7e652cd3193b904625b47cf5fc5b4007943d0" translate="yes" xml:space="preserve">
          <source>These constants define various flags that can be passed into &quot;prepFlags&quot; parameter of the &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; interfaces.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;および&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;インターフェースの「prepFlags」パラメーターに渡すことができるさまざまなフラグを定義します。</target>
        </trans-unit>
        <trans-unit id="f4779c39284f3e8f89de78b1cf22bb4300a2dde2" translate="yes" xml:space="preserve">
          <source>These constants define various performance limits that can be lowered at run-time using &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit()&lt;/a&gt;. The synopsis of the meanings of the various limits is shown below. Additional information is available at &lt;a href=&quot;limits&quot;&gt;Limits in SQLite&lt;/a&gt;.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;を使用して実行時に下げることができるさまざまなパフォーマンス制限を定義します。さまざまな制限の意味の概要を以下に示します。追加情報は&lt;a href=&quot;limits&quot;&gt;、SQLiteの制限に&lt;/a&gt;あります。</target>
        </trans-unit>
        <trans-unit id="dc33a9fdf99d3b7c3164b92212d61358e77ed2b2" translate="yes" xml:space="preserve">
          <source>These constants define various performance limits that can be lowered at run-time using &lt;a href=&quot;limit&quot;&gt;sqlite3_limit()&lt;/a&gt;. The synopsis of the meanings of the various limits is shown below. Additional information is available at &lt;a href=&quot;../limits&quot;&gt;Limits in SQLite&lt;/a&gt;.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;を使用して実行時に下げることができるさまざまなパフォーマンス制限を定義します。さまざまな制限の意味の概要を以下に示します。追加情報は&lt;a href=&quot;../limits&quot;&gt;、SQLiteの制限に&lt;/a&gt;あります。</target>
        </trans-unit>
        <trans-unit id="2d9ca50401c9fc616026596d32b3930da4b3846d" translate="yes" xml:space="preserve">
          <source>These constants identify classes of events that can be monitored using the &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; tracing logic. The M argument to &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2(D,M,X,P)&lt;/a&gt; is an OR-ed combination of one or more of the following constants. The first argument to the trace callback is one of the following constants.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;トレースロジックを使用して監視できるイベントのクラスを識別します。&lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2（D、M、X、P）&lt;/a&gt;のM引数は、次の定数の1つ以上のOR結合された組み合わせです。トレースコールバックの最初の引数は、次の定数のいずれかです。</target>
        </trans-unit>
        <trans-unit id="ed407cdd4869216425bae7d051975b3bcd0fdc3b" translate="yes" xml:space="preserve">
          <source>These constants identify classes of events that can be monitored using the &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; tracing logic. The M argument to &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2(D,M,X,P)&lt;/a&gt; is an OR-ed combination of one or more of the following constants. The first argument to the trace callback is one of the following constants.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;トレースロジックを使用して監視できるイベントのクラスを識別します。&lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2（D、M、X、P）&lt;/a&gt;のM引数は、次の定数の1つ以上のOR結合された組み合わせです。トレースコールバックの最初の引数は、次の定数のいずれかです。</target>
        </trans-unit>
        <trans-unit id="14266cc61d0db9a630a6d1107d408c2e2d4959a8" translate="yes" xml:space="preserve">
          <source>These constants may be ORed together with the &lt;a href=&quot;#SQLITE_ANY&quot;&gt;preferred text encoding&lt;/a&gt; as the fourth argument to &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function_v2()&lt;/a&gt;.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;、または&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function_v2（）&lt;/a&gt;の4番目の引数として&lt;a href=&quot;#SQLITE_ANY&quot;&gt;優先テキストエンコーディング&lt;/a&gt;とORで結合されます。</target>
        </trans-unit>
        <trans-unit id="4e4c2775c736d10a648ec5f64c5240681b8a597f" translate="yes" xml:space="preserve">
          <source>These constants may be ORed together with the &lt;a href=&quot;c_any&quot;&gt;preferred text encoding&lt;/a&gt; as the fourth argument to &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt;, &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt;, or &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function_v2()&lt;/a&gt;.</source>
          <target state="translated">これらの定数は、&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;、&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;、または&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function_v2（）&lt;/a&gt;の4番目の引数として&lt;a href=&quot;c_any&quot;&gt;優先テキストエンコーディング&lt;/a&gt;とORで結合されます。</target>
        </trans-unit>
        <trans-unit id="d452c2a5987467cef42875b2093f98a07b801c06" translate="yes" xml:space="preserve">
          <source>These functions (collectively known as &quot;function creation routines&quot;) are used to add SQL functions or aggregates or to redefine the behavior of existing SQL functions or aggregates. The only differences between the three &quot;sqlite3_create_function*&quot; routines are the text encoding expected for the second parameter (the name of the function being created) and the presence or absence of a destructor callback for the application data pointer. Function sqlite3_create_window_function() is similar, but allows the user to supply the extra callback functions needed by &lt;a href=&quot;../windowfunctions#aggwinfunc&quot;&gt;aggregate window functions&lt;/a&gt;.</source>
          <target state="translated">これらの関数（まとめて「関数作成ルーチン」と呼ばれます）は、SQL関数または集約を追加するため、または既存のSQL関数または集約の動作を再定義するために使用されます。3つの &quot;sqlite3_create_function *&quot;ルーチンの唯一の違いは、2番目のパラメーター（作成される関数の名前）に期待されるテキストエンコーディングと、アプリケーションデータポインターのデストラクターコールバックの有無です。関数sqlite3_create_window_function（）は似ていますが、&lt;a href=&quot;../windowfunctions#aggwinfunc&quot;&gt;集計ウィンドウ関数に&lt;/a&gt;必要な追加のコールバック関数を提供できます。</target>
        </trans-unit>
        <trans-unit id="460bddf16e550adbe692fb026aea91fd5c1a8fa1" translate="yes" xml:space="preserve">
          <source>These functions (collectively known as &quot;function creation routines&quot;) are used to add SQL functions or aggregates or to redefine the behavior of existing SQL functions or aggregates. The only differences between the three &quot;sqlite3_create_function*&quot; routines are the text encoding expected for the second parameter (the name of the function being created) and the presence or absence of a destructor callback for the application data pointer. Function sqlite3_create_window_function() is similar, but allows the user to supply the extra callback functions needed by &lt;a href=&quot;windowfunctions#aggwinfunc&quot;&gt;aggregate window functions&lt;/a&gt;.</source>
          <target state="translated">これらの関数（まとめて「関数作成ルーチン」と呼ばれます）は、SQL関数または集約を追加するため、または既存のSQL関数または集約の動作を再定義するために使用されます。3つの &quot;sqlite3_create_function *&quot;ルーチンの唯一の違いは、2番目のパラメーター（作成される関数の名前）に期待されるテキストエンコーディングと、アプリケーションデータポインターのデストラクターコールバックの有無です。関数sqlite3_create_window_function（）は似ていますが、&lt;a href=&quot;windowfunctions#aggwinfunc&quot;&gt;集計ウィンドウ関数に&lt;/a&gt;必要な追加のコールバック関数を提供できます。</target>
        </trans-unit>
        <trans-unit id="f5aa8ee7f5d5dcd17c7a255e21fd6564afc6f3cb" translate="yes" xml:space="preserve">
          <source>These functions add, remove, or modify a &lt;a href=&quot;../datatype3#collation&quot;&gt;collation&lt;/a&gt; associated with the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; specified as the first argument.</source>
          <target state="translated">これらの関数は、最初の引数として指定された&lt;a href=&quot;sqlite3&quot;&gt;データベース接続に&lt;/a&gt;関連付けられた&lt;a href=&quot;../datatype3#collation&quot;&gt;照合を&lt;/a&gt;追加、削除、または変更します。</target>
        </trans-unit>
        <trans-unit id="ed63a5a7289985766e806cdca8d318ceb652f682" translate="yes" xml:space="preserve">
          <source>These functions add, remove, or modify a &lt;a href=&quot;datatype3#collation&quot;&gt;collation&lt;/a&gt; associated with the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; specified as the first argument.</source>
          <target state="translated">これらの関数は、最初の引数として指定された&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続に&lt;/a&gt;関連付けられた&lt;a href=&quot;datatype3#collation&quot;&gt;照合を&lt;/a&gt;追加、削除、または変更します。</target>
        </trans-unit>
        <trans-unit id="e828096ae0ef377574b3a48a5e49c755665e8418" translate="yes" xml:space="preserve">
          <source>These functions are &lt;a href=&quot;capi3ref&quot;&gt;deprecated&lt;/a&gt;. In order to maintain backwards compatibility with older code, these functions continue to be supported. However, new applications should avoid the use of these functions. To encourage programmers to avoid these functions, we will not explain what they do.</source>
          <target state="translated">これらの関数は&lt;a href=&quot;capi3ref&quot;&gt;非推奨です&lt;/a&gt;。古いコードとの下位互換性を維持するために、これらの関数は引き続きサポートされています。ただし、新しいアプリケーションでは、これらの関数の使用を避ける必要があります。プログラマがこれらの関数を回避するように促すために、それらが何をするかについては説明しません。</target>
        </trans-unit>
        <trans-unit id="a53c5b52778acbd5177be1207d66b6e2855a89a9" translate="yes" xml:space="preserve">
          <source>These functions are &lt;a href=&quot;experimental&quot;&gt;deprecated&lt;/a&gt;. In order to maintain backwards compatibility with older code, these functions continue to be supported. However, new applications should avoid the use of these functions. To encourage programmers to avoid these functions, we will not explain what they do.</source>
          <target state="translated">これらの関数は&lt;a href=&quot;experimental&quot;&gt;非推奨です&lt;/a&gt;。古いコードとの下位互換性を維持するために、これらの関数は引き続きサポートされています。ただし、新しいアプリケーションでは、これらの関数の使用を避ける必要があります。プログラマがこれらの関数を回避するように促すために、それらが何をするかについては説明しません。</target>
        </trans-unit>
        <trans-unit id="20e0d52fc906194ab3c598ecb16113bb7e27244d" translate="yes" xml:space="preserve">
          <source>These functions may be used by (non-aggregate) SQL functions to associate metadata with argument values. If the same value is passed to multiple invocations of the same SQL function during query execution, under some circumstances the associated metadata may be preserved. An example of where this might be useful is in a regular-expression matching function. The compiled version of the regular expression can be stored as metadata associated with the pattern string. Then as long as the pattern string remains the same, the compiled regular expression can be reused on multiple invocations of the same function.</source>
          <target state="translated">これらの関数は、(非集約的な)SQL関数がメタデータを引数値に関連付けるために使用することができます。クエリ実行中に同じ値が同じSQL関数の複数回の呼び出しに渡された場合、状況によっては関連付けられたメタデータが保存されることがあります。これが有用な例として、正規表現のマッチング関数があります。正規表現のコンパイルされたバージョンを、パターン文字列に関連付けられたメタデータとして保存することができます。パターン文字列が同じである限り、コンパイルされた正規表現を同じ関数の複数回の呼び出しで再利用することができます。</target>
        </trans-unit>
        <trans-unit id="6522a9f48ff48fe82ed5d5982cbd1db9ee5c56d5" translate="yes" xml:space="preserve">
          <source>These functions only work for dates between 0000-01-01 00:00:00 and 9999-12-31 23:59:59 (julian day numbers 1721059.5 through 5373484.5). For dates outside that range, the results of these functions are undefined.</source>
          <target state="translated">これらの関数は、0000-01-01 00:00:00~9999-12-31 23:59:59の間の日付(ジュリアン日番号1721059.5~5373484.5)でのみ動作します。この範囲外の日付については、これらの関数の結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="c8d304d80363d45f2a701bb02157d9c038cae0f9" translate="yes" xml:space="preserve">
          <source>These functions work very much like the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;parameter binding&lt;/a&gt; family of functions used to bind values to host parameters in prepared statements. Refer to the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQL parameter&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">これらの関数は、準備されたステートメントでホストパラメーターに値をバインドするために使用される関数の&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;パラメーターバインド&lt;/a&gt;ファミリーと非常によく似ています。追加情報については、&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQLパラメーターの&lt;/a&gt;資料を参照してください。</target>
        </trans-unit>
        <trans-unit id="b317ce2527b91fa298699867534154a11da36ac3" translate="yes" xml:space="preserve">
          <source>These functions work very much like the &lt;a href=&quot;bind_blob&quot;&gt;parameter binding&lt;/a&gt; family of functions used to bind values to host parameters in prepared statements. Refer to the &lt;a href=&quot;bind_blob&quot;&gt;SQL parameter&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">これらの関数は、準備されたステートメントでホストパラメーターに値をバインドするために使用される関数の&lt;a href=&quot;bind_blob&quot;&gt;パラメーターバインド&lt;/a&gt;ファミリーと非常によく似ています。追加情報については、&lt;a href=&quot;bind_blob&quot;&gt;SQLパラメーターの&lt;/a&gt;資料を参照してください。</target>
        </trans-unit>
        <trans-unit id="ab78522f9e6af4ebb0a819cdbba908125b1aa9de" translate="yes" xml:space="preserve">
          <source>These integer constants are opcodes for the xFileControl method of the &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object and for the &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface.</source>
          <target state="translated">これらの整数定数は、&lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;オブジェクトのxFileControlメソッドと&lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;インターフェイスのオペコードです。</target>
        </trans-unit>
        <trans-unit id="a38e815d9a81f8a36563593031ac86d208aff3ef" translate="yes" xml:space="preserve">
          <source>These integer constants are opcodes for the xFileControl method of the &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object and for the &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface.</source>
          <target state="translated">これらの整数定数は、&lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;オブジェクトのxFileControlメソッドと&lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;インターフェイスのオペコードです。</target>
        </trans-unit>
        <trans-unit id="ea60b84c9e9ef3033a276fcbd9184666b77d102f" translate="yes" xml:space="preserve">
          <source>These integer constants can be used as the third parameter to the xAccess method of an &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. They determine what kind of permissions the xAccess method is looking for. With SQLITE_ACCESS_EXISTS, the xAccess method simply checks whether the file exists. With SQLITE_ACCESS_READWRITE, the xAccess method checks whether the named directory is both readable and writable (in other words, if files can be added, removed, and renamed within the directory). The SQLITE_ACCESS_READWRITE constant is currently used only by the &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt;, though this could change in a future release of SQLite. With SQLITE_ACCESS_READ, the xAccess method checks whether the file is readable. The SQLITE_ACCESS_READ constant is currently unused, though it might be used in a future release of SQLite.</source>
          <target state="translated">これらの整数定数は、&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトのxAccessメソッドの3番目のパラメーターとして使用できます。それらは、xAccessメソッドが探しているアクセス許可の種類を決定します。SQLITE_ACCESS_EXISTSでは、xAccessメソッドはファイルが存在するかどうかを確認するだけです。SQLITE_ACCESS_READWRITEを使用すると、xAccessメソッドは、指定されたディレクトリが読み取りと書き込みの両方が可能かどうかを確認します（つまり、ディレクトリ内でファイルを追加、削除、名前変更できるかどうか）。SQLITE_ACCESS_READWRITE定数は現在、&lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directoryプラグマで&lt;/a&gt;のみ使用されていますただし、これはSQLiteの将来のリリースで変更される可能性があります。SQLITE_ACCESS_READを使用すると、xAccessメソッドはファイルが読み取り可能かどうかを確認します。SQLITE_ACCESS_READ定数は現在使用されていませんが、SQLiteの将来のリリースで使用される可能性があります。</target>
        </trans-unit>
        <trans-unit id="311aa59e56c46be41f406ebc987fb4c56872151d" translate="yes" xml:space="preserve">
          <source>These integer constants can be used as the third parameter to the xAccess method of an &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. They determine what kind of permissions the xAccess method is looking for. With SQLITE_ACCESS_EXISTS, the xAccess method simply checks whether the file exists. With SQLITE_ACCESS_READWRITE, the xAccess method checks whether the named directory is both readable and writable (in other words, if files can be added, removed, and renamed within the directory). The SQLITE_ACCESS_READWRITE constant is currently used only by the &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt;, though this could change in a future release of SQLite. With SQLITE_ACCESS_READ, the xAccess method checks whether the file is readable. The SQLITE_ACCESS_READ constant is currently unused, though it might be used in a future release of SQLite.</source>
          <target state="translated">これらの整数定数は、&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトのxAccessメソッドの3番目のパラメーターとして使用できます。それらは、xAccessメソッドが探しているアクセス許可の種類を決定します。SQLITE_ACCESS_EXISTSでは、xAccessメソッドはファイルが存在するかどうかを確認するだけです。SQLITE_ACCESS_READWRITEを使用すると、xAccessメソッドは、指定されたディレクトリが読み取りと書き込みの両方が可能かどうかを確認します（つまり、ディレクトリ内でファイルを追加、削除、名前変更できるかどうか）。SQLITE_ACCESS_READWRITE定数は現在、&lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directoryプラグマで&lt;/a&gt;のみ使用されていますただし、これはSQLiteの将来のリリースで変更される可能性があります。SQLITE_ACCESS_READを使用すると、xAccessメソッドはファイルが読み取り可能かどうかを確認します。SQLITE_ACCESS_READ定数は現在使用されていませんが、SQLiteの将来のリリースで使用される可能性があります。</target>
        </trans-unit>
        <trans-unit id="8e30f4610e846824046fcc55a5610ab368656db0" translate="yes" xml:space="preserve">
          <source>These integer constants define the various locking operations allowed by the xShmLock method of &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;. The following are the only legal combinations of flags to the xShmLock method:</source>
          <target state="translated">これらの整数定数はxShmLock法によって許容される様々なロック操作を定義&lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methodsを&lt;/a&gt;。以下は、xShmLockメソッドへのフラグの唯一の有効な組み合わせです。</target>
        </trans-unit>
        <trans-unit id="63c61207725308cbbebcd362e48d34bfbbce9eff" translate="yes" xml:space="preserve">
          <source>These integer constants define the various locking operations allowed by the xShmLock method of &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;. The following are the only legal combinations of flags to the xShmLock method:</source>
          <target state="translated">これらの整数定数はxShmLock法によって許容される様々なロック操作を定義&lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methodsを&lt;/a&gt;。以下は、xShmLockメソッドへのフラグの唯一の有効な組み合わせです。</target>
        </trans-unit>
        <trans-unit id="46be45c61b7407297842f2bf5d770d15053c4ac4" translate="yes" xml:space="preserve">
          <source>These integer constants designate various run-time status parameters that can be returned by &lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status()&lt;/a&gt;.</source>
          <target state="translated">これらの整数定数は、&lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status（）&lt;/a&gt;によって返されるさまざまな実行時ステータスパラメータを指定します。</target>
        </trans-unit>
        <trans-unit id="9d8a64fd442238eaa787788726abe76149b5cae0" translate="yes" xml:space="preserve">
          <source>These integer constants designate various run-time status parameters that can be returned by &lt;a href=&quot;status&quot;&gt;sqlite3_status()&lt;/a&gt;.</source>
          <target state="translated">これらの整数定数は、&lt;a href=&quot;status&quot;&gt;sqlite3_status（）&lt;/a&gt;によって返されるさまざまな実行時ステータスパラメータを指定します。</target>
        </trans-unit>
        <trans-unit id="1dd74d0b7bde7f62eaef94d29d31baa355fc24b9" translate="yes" xml:space="preserve">
          <source>These interfaces add content to an sqlite3_str object previously obtained from &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">これらのインターフェースは、以前に&lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new（）&lt;/a&gt;から取得したsqlite3_strオブジェクトにコンテンツを追加します。</target>
        </trans-unit>
        <trans-unit id="f4c68aa7a2ee53b8d7d01e966ec46bd4df66a0b8" translate="yes" xml:space="preserve">
          <source>These interfaces add content to an sqlite3_str object previously obtained from &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">これらのインターフェースは、以前に&lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new（）&lt;/a&gt;から取得したsqlite3_strオブジェクトにコンテンツを追加します。</target>
        </trans-unit>
        <trans-unit id="37d07c864bda5264afb416a4db651631968abf92" translate="yes" xml:space="preserve">
          <source>These interfaces are available only on Windows. The &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface is used to set the value associated with the &lt;a href=&quot;#sqlite3_temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; or &lt;a href=&quot;#sqlite3_data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; variable, to zValue, depending on the value of the type parameter. The zValue parameter should be NULL to cause the previous value to be freed via &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt;; a non-NULL value will be copied into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; prior to being used. The &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; to indicate success, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if the type is unsupported, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; if memory could not be allocated. The value of the &lt;a href=&quot;#sqlite3_data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; variable is intended to act as a replacement for the current directory on the sub-platforms of Win32 where that concept is not present, e.g. WinRT and UWP. The &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory8&lt;/a&gt; and &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory16&lt;/a&gt; interfaces behave exactly the same as the sqlite3_win32_set_directory interface except the string parameter must be UTF-8 or UTF-16, respectively.</source>
          <target state="translated">これらのインターフェースは、Windowsでのみ使用できます。&lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt;インターフェースが関連付けられている値を設定するために使用される&lt;a href=&quot;#sqlite3_temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;又は&lt;a href=&quot;#sqlite3_data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; typeパラメータの値に応じて、Z値に、変数。以前の値を&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt;で解放するには、zValueパラメータをNULLにする必要があります。 NULL以外の値は、使用前に&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt;から取得したメモリにコピーされます。&lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt;インタフェース戻り&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;、成功を示すために&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERRORを&lt;/a&gt;タイプがサポートされていない場合、または&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;メモリを割り当てることができなかった場合。&lt;a href=&quot;#sqlite3_data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt;変数の値は、WinRTやUWPなど、その概念が存在しないWin32のサブプラットフォーム上の現在のディレクトリの代わりとして機能することを目的としています。&lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory8&lt;/a&gt;と&lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory16&lt;/a&gt;インターフェースは、文字列パラメータを除いsqlite3_win32_set_directoryインタフェースと全く同じで、それぞれ、UTF-8やUTF-16でなければならない振る舞います。</target>
        </trans-unit>
        <trans-unit id="e3077cf84285d5d0c77e1603a1b1cc3c809c60d7" translate="yes" xml:space="preserve">
          <source>These interfaces are available only on Windows. The &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface is used to set the value associated with the &lt;a href=&quot;temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; or &lt;a href=&quot;data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; variable, to zValue, depending on the value of the type parameter. The zValue parameter should be NULL to cause the previous value to be freed via &lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt;; a non-NULL value will be copied into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; prior to being used. The &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; to indicate success, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if the type is unsupported, or &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; if memory could not be allocated. The value of the &lt;a href=&quot;data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; variable is intended to act as a replacement for the current directory on the sub-platforms of Win32 where that concept is not present, e.g. WinRT and UWP. The &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory8&lt;/a&gt; and &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory16&lt;/a&gt; interfaces behave exactly the same as the sqlite3_win32_set_directory interface except the string parameter must be UTF-8 or UTF-16, respectively.</source>
          <target state="translated">これらのインターフェースは、Windowsでのみ使用できます。&lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt;インターフェースが関連付けられている値を設定するために使用される&lt;a href=&quot;temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;又は&lt;a href=&quot;data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; typeパラメータの値に応じて、Z値に、変数。以前の値を&lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt;で解放するには、zValueパラメータをNULLにする必要があります。 NULL以外の値は、使用前に&lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt;から取得したメモリにコピーされます。&lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt;インタフェース戻り&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;、成功を示すために&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERRORを&lt;/a&gt;タイプがサポートされていない場合、または&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;メモリを割り当てることができなかった場合。&lt;a href=&quot;data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt;変数の値は、WinRTやUWPなど、その概念が存在しないWin32のサブプラットフォーム上の現在のディレクトリの代わりとして機能することを目的としています。&lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory8&lt;/a&gt;と&lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory16&lt;/a&gt;インターフェースは、文字列パラメータを除いsqlite3_win32_set_directoryインタフェースと全く同じで、それぞれ、UTF-8やUTF-16でなければならない振る舞います。</target>
        </trans-unit>
        <trans-unit id="bf73a94780de490a8f9c02eb38be04e9aad9c703" translate="yes" xml:space="preserve">
          <source>These interfaces are only available if SQLite is compiled using the &lt;a href=&quot;../compile#enable_preupdate_hook&quot;&gt;SQLITE_ENABLE_PREUPDATE_HOOK&lt;/a&gt; compile-time option.</source>
          <target state="translated">これらのインターフェースは、SQLiteが&lt;a href=&quot;../compile#enable_preupdate_hook&quot;&gt;SQLITE_ENABLE_PREUPDATE_HOOK&lt;/a&gt;コンパイル時オプションを使用してコンパイルされている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="2573d74316b2beb50fe8b93933b238b687b3e25f" translate="yes" xml:space="preserve">
          <source>These interfaces are only available if SQLite is compiled using the &lt;a href=&quot;compile#enable_preupdate_hook&quot;&gt;SQLITE_ENABLE_PREUPDATE_HOOK&lt;/a&gt; compile-time option.</source>
          <target state="translated">これらのインターフェースは、SQLiteが&lt;a href=&quot;compile#enable_preupdate_hook&quot;&gt;SQLITE_ENABLE_PREUPDATE_HOOK&lt;/a&gt;コンパイル時オプションを使用してコンパイルされている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="1dfbcb8f183f59b84e1cdc3c799c0026a4da7b1c" translate="yes" xml:space="preserve">
          <source>These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks. The first argument is an integer code for the specific parameter to measure. Recognized integer codes are of the form &lt;a href=&quot;#SQLITE_STATUS_MALLOC_COUNT&quot;&gt;SQLITE_STATUS_...&lt;/a&gt;. The current value of the parameter is returned into *pCurrent. The highest recorded value is returned in *pHighwater. If the resetFlag is true, then the highest record value is reset after *pHighwater is written. Some parameters do not record the highest value. For those parameters nothing is written into *pHighwater and the resetFlag is ignored. Other parameters record only the highwater mark and not the current value. For these latter parameters nothing is written into *pCurrent.</source>
          <target state="translated">これらのインターフェイスは、SQLiteのパフォーマンスに関するランタイムステータス情報を取得し、オプションでさまざまな上限基準点をリセットするために使用されます。最初の引数は、測定する特定のパラメーターの整数コードです。認識される整数コードの形式は&lt;a href=&quot;#SQLITE_STATUS_MALLOC_COUNT&quot;&gt;SQLITE_STATUS _...&lt;/a&gt;です。パラメータの現在の値は* pCurrentに返されます。記録された最高値は* pHighwaterに返されます。 resetFlagがtrueの場合、最大レコード値は* pHighwaterが書き込まれた後にリセットされます。一部のパラメーターは最高値を記録しません。これらのパラメーターの場合、* pHighwaterには何も書き込まれず、resetFlagは無視されます。その他のパラメーターは、現在の値ではなく、最高水準点のみを記録します。これらの後者のパラメーターについては、* pCurrentには何も書き込まれません。</target>
        </trans-unit>
        <trans-unit id="9a006bb7b78680fec3ca85a8c33bf946ae2c290a" translate="yes" xml:space="preserve">
          <source>These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks. The first argument is an integer code for the specific parameter to measure. Recognized integer codes are of the form &lt;a href=&quot;c_status_malloc_count&quot;&gt;SQLITE_STATUS_...&lt;/a&gt;. The current value of the parameter is returned into *pCurrent. The highest recorded value is returned in *pHighwater. If the resetFlag is true, then the highest record value is reset after *pHighwater is written. Some parameters do not record the highest value. For those parameters nothing is written into *pHighwater and the resetFlag is ignored. Other parameters record only the highwater mark and not the current value. For these latter parameters nothing is written into *pCurrent.</source>
          <target state="translated">これらのインターフェイスは、SQLiteのパフォーマンスに関するランタイムステータス情報を取得し、オプションでさまざまな上限基準点をリセットするために使用されます。最初の引数は、測定する特定のパラメーターの整数コードです。認識される整数コードの形式は&lt;a href=&quot;c_status_malloc_count&quot;&gt;SQLITE_STATUS _...&lt;/a&gt;です。パラメータの現在の値は* pCurrentに返されます。記録された最高値は* pHighwaterに返されます。 resetFlagがtrueの場合、最大レコード値は* pHighwaterが書き込まれた後にリセットされます。一部のパラメーターは最高値を記録しません。これらのパラメーターの場合、* pHighwaterには何も書き込まれず、resetFlagは無視されます。その他のパラメーターは、現在の値ではなく、最高水準点のみを記録します。これらの後者のパラメーターについては、* pCurrentには何も書き込まれません。</target>
        </trans-unit>
        <trans-unit id="7a26bb8a6cfb99470baf86e2f9ba8d8fe1ec3d04" translate="yes" xml:space="preserve">
          <source>These interfaces can be used by an application to monitor how much memory SQLite is using. The &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; routine returns the number of bytes of memory currently in use and the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; returns the maximum instantaneous memory usage. Neither routine includes the overhead associated with the memory allocator. These routines are provided for use by the application. SQLite never invokes them itself. So if the application is providing its own memory allocation subsystem, it can omit these interfaces if desired.</source>
          <target state="translated">アプリケーションはこれらのインターフェースを使用して、SQLiteが使用しているメモリの量を監視できます。&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;リターン現在使用されているメモリのバイト数と&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;瞬間最大メモリ使用量を返します。どちらのルーチンにも、メモリアロケータに関連するオーバーヘッドは含まれていません。これらのルーチンは、アプリケーションで使用するために提供されています。 SQLiteがそれ自体を呼び出すことはありません。したがって、アプリケーションが独自のメモリ割り当てサブシステムを提供している場合、必要に応じてこれらのインターフェイスを省略できます。</target>
        </trans-unit>
        <trans-unit id="5e6bfb4cf13a4a1ec7a21d1345619d3a829697d4" translate="yes" xml:space="preserve">
          <source>These interfaces impose limits on the amount of heap memory that will be by all database connections within a single process.</source>
          <target state="translated">これらのインターフェイスは、単一プロセス内のすべてのデータベース接続によるヒープメモリ量の制限を課します。</target>
        </trans-unit>
        <trans-unit id="5d867180f3b3d1ed5572faf6a624799c6449d787" translate="yes" xml:space="preserve">
          <source>These interfaces provide the same information as the &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt;, &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;, and &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macros but are associated with the library instead of the header file. Cautious programmers might include assert() statements in their application to verify that values returned by these interfaces match the macros in the header, and thus ensure that the application is compiled with matching library and header files.</source>
          <target state="translated">これらのインターフェースは、&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt;、&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;、および&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; Cプリプロセッサマクロと同じ情報を提供しますが、ヘッダーファイルではなくライブラリに関連付けられています。慎重なプログラマーは、アプリケーションにassert（）ステートメントを含めて、これらのインターフェイスから返された値がヘッダー内のマクロと一致することを確認し、アプリケーションがライブラリとヘッダーファイルに一致するようにコンパイルされるようにします。</target>
        </trans-unit>
        <trans-unit id="7e7f85933d01fbbc2719e5dc64309e8e175f6d5d" translate="yes" xml:space="preserve">
          <source>These interfaces provide the same information as the &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt;, &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;, and &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macros but are associated with the library instead of the header file. Cautious programmers might include assert() statements in their application to verify that values returned by these interfaces match the macros in the header, and thus ensure that the application is compiled with matching library and header files.</source>
          <target state="translated">これらのインターフェースは、&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt;、&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;、および&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; Cプリプロセッサマクロと同じ情報を提供しますが、ヘッダーファイルではなくライブラリに関連付けられています。慎重なプログラマーは、アプリケーションにassert（）ステートメントを含めて、これらのインターフェイスから返された値がヘッダー内のマクロと一致することを確認し、アプリケーションがライブラリとヘッダーファイルに一致するようにコンパイルされるようにします。</target>
        </trans-unit>
        <trans-unit id="8f3967be8dcb65457d2a35a639ddbcd4e8748853" translate="yes" xml:space="preserve">
          <source>These interfaces return the current status of an &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object.</source>
          <target state="translated">これらのインターフェイスは、&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt;オブジェクトの現在のステータスを返します。</target>
        </trans-unit>
        <trans-unit id="9f4d86f27a761f3cf1b6a9d1b51464453bd7acc2" translate="yes" xml:space="preserve">
          <source>These interfaces return the current status of an &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object.</source>
          <target state="translated">これらのインターフェイスは、&lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt;オブジェクトの現在のステータスを返します。</target>
        </trans-unit>
        <trans-unit id="edf2097b32647c30069fed117ef937baf26e2654" translate="yes" xml:space="preserve">
          <source>These interfces are provided for use by &lt;a href=&quot;vfs#shim&quot;&gt;VFS shim&lt;/a&gt; implementations and are not useful outside of that context.</source>
          <target state="translated">これらのインターフェースは、&lt;a href=&quot;vfs#shim&quot;&gt;VFSシムの&lt;/a&gt;実装で使用するために提供されており、そのコンテキスト以外では役に立ちません。</target>
        </trans-unit>
        <trans-unit id="c1a8d7ae768abbd8bdb6f16b4e0e326ba78812f7" translate="yes" xml:space="preserve">
          <source>These macros are only available on Windows. They define the allowed values for the type argument to the &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface.</source>
          <target state="translated">これらのマクロはWindowsでのみ使用できます。これらは、&lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt;インターフェイスへのtype引数に許可される値を定義します。</target>
        </trans-unit>
        <trans-unit id="a687dbdbbc158f7b1d8247c45af66df0ad45cf41" translate="yes" xml:space="preserve">
          <source>These macros are only available on Windows. They define the allowed values for the type argument to the &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface.</source>
          <target state="translated">これらのマクロはWindowsでのみ使用できます。これらは、&lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt;インターフェイスへのtype引数に許可される値を定義します。</target>
        </trans-unit>
        <trans-unit id="a53b463320023e1da4e50fb5fb587f4bc7e0b044" translate="yes" xml:space="preserve">
          <source>These macros define the allowed values for the &lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.aConstraint[].op field. Each value represents an operator that is part of a constraint term in the wHERE clause of a query that uses a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">これらのマクロは、&lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; .aConstraint []。opフィールドに許可される値を定義します。各値は、&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;を使用するクエリのwHERE句の制約項の一部である演算子を表します。</target>
        </trans-unit>
        <trans-unit id="285af12f9b73f8c383619a138a0750effc7e59e8" translate="yes" xml:space="preserve">
          <source>These macros define the allowed values for the &lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.aConstraint[].op field. Each value represents an operator that is part of a constraint term in the wHERE clause of a query that uses a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">これらのマクロは、&lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; .aConstraint []。opフィールドに許可される値を定義します。各値は、&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;を使用するクエリのwHERE句の制約項の一部である演算子を表します。</target>
        </trans-unit>
        <trans-unit id="8efdced9c4da4c580aa62b3a5a3c4685a1b1ed67" translate="yes" xml:space="preserve">
          <source>These macros define the various options to the &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; interface that &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementations can use to customize and optimize their behavior.</source>
          <target state="translated">これらのマクロは、&lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config（）&lt;/a&gt;インターフェースのさまざまなオプションを定義し、&lt;a href=&quot;vtab&quot;&gt;仮想テーブルの&lt;/a&gt;実装がそれらの動作をカスタマイズおよび最適化するために使用できます。</target>
        </trans-unit>
        <trans-unit id="648697ac8bc614b007ee6a86dba8449e42be0af2" translate="yes" xml:space="preserve">
          <source>These macros define the various options to the &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; interface that &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implementations can use to customize and optimize their behavior.</source>
          <target state="translated">これらのマクロは、&lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config（）&lt;/a&gt;インターフェースのさまざまなオプションを定義し、&lt;a href=&quot;../vtab&quot;&gt;仮想テーブルの&lt;/a&gt;実装がそれらの動作をカスタマイズおよび最適化するために使用できます。</target>
        </trans-unit>
        <trans-unit id="e2c086e3788cfb99a6897d54171eed03d73b01e8" translate="yes" xml:space="preserve">
          <source>These macros defined the allowed values for the &lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.aConstraint[].op field. Each value represents an operator that is part of a constraint term in the wHERE clause of a query that uses a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">これらのマクロは、&lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; .aConstraint []。opフィールドに許可される値を定義しました。各値は、&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;を使用するクエリのwHERE句の制約条件の一部である演算子を表します。</target>
        </trans-unit>
        <trans-unit id="fa39882fd7522d6ac624eca8d9d3a80dde9e04fa" translate="yes" xml:space="preserve">
          <source>These macros defined the allowed values for the &lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.aConstraint[].op field. Each value represents an operator that is part of a constraint term in the wHERE clause of a query that uses a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">これらのマクロは、&lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; .aConstraint []。opフィールドに許可される値を定義しました。各値は、&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;を使用するクエリのwHERE句の制約条件の一部である演算子を表します。</target>
        </trans-unit>
        <trans-unit id="cef481ad6fa7db18e075879f04ed74ee515d6f8c" translate="yes" xml:space="preserve">
          <source>These methods do not return a result code. If an error occurs, that fact is recorded in the &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object and can be recovered by a subsequent call to &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt;.</source>
          <target state="translated">これらのメソッドは結果コードを返しません。エラーが発生した場合、その事実は&lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt;オブジェクトに記録され、その後の&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode（X）の&lt;/a&gt;呼び出しで回復できます。</target>
        </trans-unit>
        <trans-unit id="cf9638bb05ccc82e92352f4c91e50e88181ed764" translate="yes" xml:space="preserve">
          <source>These methods do not return a result code. If an error occurs, that fact is recorded in the &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object and can be recovered by a subsequent call to &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt;.</source>
          <target state="translated">これらのメソッドは結果コードを返しません。エラーが発生した場合、その事実は&lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt;オブジェクトに記録され、その後の&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode（X）の&lt;/a&gt;呼び出しで回復できます。</target>
        </trans-unit>
        <trans-unit id="c8abab119f90d9828a9a200b591657ce6dda56d7" translate="yes" xml:space="preserve">
          <source>These methods provide the virtual table implementation an opportunity to implement nested transactions. They are always optional and will only be called in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_7.html&quot;&gt;version 3.7.7&lt;/a&gt; (2011-06-23) and later.</source>
          <target state="translated">これらのメソッドは、仮想テーブルの実装に、ネストされたトランザクションを実装する機会を提供します。これらは常にオプションであり、SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_7.html&quot;&gt;バージョン3.7.7&lt;/a&gt;（2011-06-23）以降でのみ呼び出されます。</target>
        </trans-unit>
        <trans-unit id="46bde550196023cbdbd528e902d936fa4e39c988" translate="yes" xml:space="preserve">
          <source>These operations are described in detail in section</source>
          <target state="translated">これらの操作については、セクション</target>
        </trans-unit>
        <trans-unit id="8a581a47ac4eaa711b3f420b4ba4930e1f71a44b" translate="yes" xml:space="preserve">
          <source>These options are obsolete and should not be used by new code. They are retained for backwards compatibility but are now no-ops.</source>
          <target state="translated">これらのオプションは廃止されたものであり、新しいコードでは使用しないでください。これらは下位互換性のために保持されていますが、現在はノーオプションとなっています。</target>
        </trans-unit>
        <trans-unit id="559388a0d9af9b6cbe52d397cd3542b5b1c78fdd" translate="yes" xml:space="preserve">
          <source>These pages are intended to be precise and detailed specification. For a tutorial introduction, see instead:</source>
          <target state="translated">これらのページは、正確で詳細な仕様を意図しています。チュートリアルの紹介は、代わりに参照してください。</target>
        </trans-unit>
        <trans-unit id="6abb0e63f8d45e8d38ed1d32dbd7bc6804598807" translate="yes" xml:space="preserve">
          <source>These parameters and their meanings are subject to change without notice. These values are for testing purposes only. Applications should not use any of these parameters or the &lt;a href=&quot;#sqlite3_test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt; interface.</source>
          <target state="translated">これらのパラメーターとその意味は、予告なしに変更されることがあります。これらの値はテスト専用です。アプリケーションでは、これらのパラメーターまたは&lt;a href=&quot;#sqlite3_test_control&quot;&gt;sqlite3_test_control（）&lt;/a&gt;インターフェースを使用しないでください。</target>
        </trans-unit>
        <trans-unit id="572f36fd8fcb5b2b9a0c163c10706d2d9c69fa95" translate="yes" xml:space="preserve">
          <source>These parameters and their meanings are subject to change without notice. These values are for testing purposes only. Applications should not use any of these parameters or the &lt;a href=&quot;test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt; interface.</source>
          <target state="translated">これらのパラメーターとその意味は、予告なしに変更されることがあります。これらの値はテスト専用です。アプリケーションでは、これらのパラメーターまたは&lt;a href=&quot;test_control&quot;&gt;sqlite3_test_control（）&lt;/a&gt;インターフェースを使用しないでください。</target>
        </trans-unit>
        <trans-unit id="f8a0b86303fc051c5fd0870031ccb3460d4da0f7" translate="yes" xml:space="preserve">
          <source>These pragmas are only available in builds using non-standard compile-time options.</source>
          <target state="translated">これらのプラグマは、非標準のコンパイル時オプションを使用したビルドでのみ利用可能です。</target>
        </trans-unit>
        <trans-unit id="7d1b3b12b0e1a81b824764e591a7c4f5ca02302c" translate="yes" xml:space="preserve">
          <source>These pragmas are used for testing SQLite and are not recommended for use in application programs.</source>
          <target state="translated">これらのプラグマはSQLiteのテストに使用され、アプリケーションプログラムでの使用は推奨されていません。</target>
        </trans-unit>
        <trans-unit id="995493d489d94b8be4b015e9bc63ccee86968693" translate="yes" xml:space="preserve">
          <source>These preprocessor macros define integer codes that name counter values associated with the &lt;a href=&quot;#sqlite3_stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; interface. The meanings of the various counters are as follows:</source>
          <target state="translated">これらのプリプロセッサマクロは、&lt;a href=&quot;#sqlite3_stmt_status&quot;&gt;sqlite3_stmt_status（）&lt;/a&gt;インターフェイスに関連付けられたカウンター値を示す整数コードを定義します。さまざまなカウンタの意味は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="45f1f746bd34bc0ce563d83def09a125c5bf05c1" translate="yes" xml:space="preserve">
          <source>These preprocessor macros define integer codes that name counter values associated with the &lt;a href=&quot;stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; interface. The meanings of the various counters are as follows:</source>
          <target state="translated">これらのプリプロセッサマクロは、&lt;a href=&quot;stmt_status&quot;&gt;sqlite3_stmt_status（）&lt;/a&gt;インターフェイスに関連付けられたカウンター値を示す整数コードを定義します。さまざまなカウンタの意味は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="c705c2e0cd7b6320d8503e4412e5e99c6ba613d2" translate="yes" xml:space="preserve">
          <source>These routines are available to &lt;a href=&quot;vfs&quot;&gt;custom VFS implementations&lt;/a&gt; for translating filenames between the main database file, the journal file, and the WAL file.</source>
          <target state="translated">これらのルーチンは、メインデータベースファイル、ジャーナルファイル、およびWALファイル間でファイル名を変換&lt;a href=&quot;vfs&quot;&gt;する&lt;/a&gt;ためのカスタムVFS実装で使用できます。</target>
        </trans-unit>
        <trans-unit id="2638c6822db8d54f4bd5ddffbdd3a5cd063ac265" translate="yes" xml:space="preserve">
          <source>These routines are deprecated. Use the &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; interface instead of the routines described here.</source>
          <target state="translated">これらのルーチンは非推奨です。ここで説明するルーチンの代わりに&lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;インターフェースを使用してください。</target>
        </trans-unit>
        <trans-unit id="79eec12a37e6ba999a536376578f3d7f9c0f472e" translate="yes" xml:space="preserve">
          <source>These routines are deprecated. Use the &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; interface instead of the routines described here.</source>
          <target state="translated">これらのルーチンは非推奨です。ここで説明するルーチンの代わりに&lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;インターフェースを使用してください。</target>
        </trans-unit>
        <trans-unit id="88da5c4ccf3f13c2b355a0a8cea0eee5123dacc4" translate="yes" xml:space="preserve">
          <source>These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates. See &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; for additional information.</source>
          <target state="translated">これらのルーチンは、SQL関数と集計を実装するxFuncまたはxFinalコールバックによって使用されます。詳細については、&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;および&lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="9ac11b77df30733555a1b785ff3b36747aa22425" translate="yes" xml:space="preserve">
          <source>These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates. See &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; for additional information.</source>
          <target state="translated">これらのルーチンは、SQL関数と集計を実装するxFuncまたはxFinalコールバックによって使用されます。詳細については、&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;および&lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16（）&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a645fc58a9b80b5d58439099cf576c18383cf676" translate="yes" xml:space="preserve">
          <source>These routines are used to register a new &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt; name. Module names must be registered before creating a new &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; using the module and before using a preexisting &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; for the module.</source>
          <target state="translated">これらのルーチンは、新しい&lt;a href=&quot;#sqlite3_module&quot;&gt;仮想テーブルモジュール&lt;/a&gt;名を登録するために使用されます。モジュール名は、モジュールを使用して新しい&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;を作成する前、およびモジュールに既存の&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;を使用する前に登録する必要があります。</target>
        </trans-unit>
        <trans-unit id="947d0c2cba6cd0b29a7af62bdccba7526d0c92de" translate="yes" xml:space="preserve">
          <source>These routines are used to register a new &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt; name. Module names must be registered before creating a new &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; using the module and before using a preexisting &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; for the module.</source>
          <target state="translated">これらのルーチンは、新しい&lt;a href=&quot;module&quot;&gt;仮想テーブルモジュール&lt;/a&gt;名を登録するために使用されます。モジュール名は、モジュールを使用して新しい&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;を作成する前、およびモジュールに既存の&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;を使用する前に登録する必要があります。</target>
        </trans-unit>
        <trans-unit id="52698fd9d4ddf179ee30cea3431e78d27c345761" translate="yes" xml:space="preserve">
          <source>These routines are useful during command-line input to determine if the currently entered text seems to form a complete SQL statement or if additional input is needed before sending the text into SQLite for parsing. These routines return 1 if the input string appears to be a complete SQL statement. A statement is judged to be complete if it ends with a semicolon token and is not a prefix of a well-formed CREATE TRIGGER statement. Semicolons that are embedded within string literals or quoted identifier names or comments are not independent tokens (they are part of the token in which they are embedded) and thus do not count as a statement terminator. Whitespace and comments that follow the final semicolon are ignored.</source>
          <target state="translated">これらのルーチンは、現在入力されているテキストが完全なSQL文を形成しているように見えるかどうか、またはテキストをSQLiteに送信して解析する前に追加入力が必要かどうかを判断するために、コマンドライン入力時に便利です。これらのルーチンは、入力文字列が完全なSQL文であるように見える場合に1を返します。文の最後がセミコロントークンで終わり、整形されたCREATE TRIGGER文の接頭辞ではない場合、文は完全であると判断されます。文字列リテラルや引用符で囲まれた識別子名やコメントの中に埋め込まれたセミコロンは独立したトークンではないので(それらは埋め込まれたトークンの一部です)、文のターミネータとしてカウントされません。最後のセミコロンに続く空白やコメントは無視されます。</target>
        </trans-unit>
        <trans-unit id="1eee207918e3686e6a6a0aff77d6f8f4cd324299" translate="yes" xml:space="preserve">
          <source>These routines are work-alikes of the &quot;printf()&quot; family of functions from the standard C library. These routines understand most of the common formatting options from the standard library printf() plus some additional non-standard formats (&lt;a href=&quot;../printf#percentq&quot;&gt;%q&lt;/a&gt;, &lt;a href=&quot;../printf#percentq&quot;&gt;%Q&lt;/a&gt;, &lt;a href=&quot;../printf#percentw&quot;&gt;%w&lt;/a&gt;, and &lt;a href=&quot;../printf#percentz&quot;&gt;%z&lt;/a&gt;). See the &lt;a href=&quot;../printf&quot;&gt;built-in printf()&lt;/a&gt; documentation for details.</source>
          <target state="translated">これらのルーチンは、標準Cライブラリの「printf（）」ファミリーの関数に似ています。これらのルーチンは、標準ライブラリprintf（）からの一般的なフォーマットオプションのほとんどと、いくつかの追加の非標準フォーマット（&lt;a href=&quot;../printf#percentq&quot;&gt;％q&lt;/a&gt;、&lt;a href=&quot;../printf#percentq&quot;&gt;％Q&lt;/a&gt;、&lt;a href=&quot;../printf#percentw&quot;&gt;％w&lt;/a&gt;、および&lt;a href=&quot;../printf#percentz&quot;&gt;％z&lt;/a&gt;）を理解します。詳細については、&lt;a href=&quot;../printf&quot;&gt;組み込みのprintf（）の&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="5d6ce4df9ede9c6a9b8604117d8eeec42326da1e" translate="yes" xml:space="preserve">
          <source>These routines are work-alikes of the &quot;printf()&quot; family of functions from the standard C library. These routines understand most of the common formatting options from the standard library printf() plus some additional non-standard formats (&lt;a href=&quot;printf#percentq&quot;&gt;%q&lt;/a&gt;, &lt;a href=&quot;printf#percentq&quot;&gt;%Q&lt;/a&gt;, &lt;a href=&quot;printf#percentw&quot;&gt;%w&lt;/a&gt;, and &lt;a href=&quot;printf#percentz&quot;&gt;%z&lt;/a&gt;). See the &lt;a href=&quot;printf&quot;&gt;built-in printf()&lt;/a&gt; documentation for details.</source>
          <target state="translated">これらのルーチンは、標準Cライブラリの「printf（）」ファミリーの関数に似ています。これらのルーチンは、標準ライブラリprintf（）からの一般的なフォーマットオプションのほとんどと、いくつかの追加の非標準フォーマット（&lt;a href=&quot;printf#percentq&quot;&gt;％q&lt;/a&gt;、&lt;a href=&quot;printf#percentq&quot;&gt;％Q&lt;/a&gt;、&lt;a href=&quot;printf#percentw&quot;&gt;％w&lt;/a&gt;、および&lt;a href=&quot;printf#percentz&quot;&gt;％z&lt;/a&gt;）を理解します。詳細については、&lt;a href=&quot;printf&quot;&gt;組み込みのprintf（）の&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="d695b797410a06f75931294f55b67ec9c439fcc7" translate="yes" xml:space="preserve">
          <source>These routines do not parse the SQL statements thus will not detect syntactically incorrect SQL.</source>
          <target state="translated">これらのルーチンはSQL文を解析しないので、構文的に正しくないSQLは検出されません。</target>
        </trans-unit>
        <trans-unit id="7531da5fcda9441742ab989cffc3d5a7ea0da49d" translate="yes" xml:space="preserve">
          <source>These routines extract type, size, and content information from &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Protected sqlite3_value objects are used to pass parameter information into implementation of &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; and &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">これらのルーチンは、&lt;a href=&quot;#sqlite3_value&quot;&gt;保護されたsqlite3_value&lt;/a&gt;オブジェクトからタイプ、サイズ、コンテンツ情報を抽出します。保護されたsqlite3_valueオブジェクトは、&lt;a href=&quot;#sqlite3_create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;と&lt;a href=&quot;vtab&quot;&gt;仮想テーブルの&lt;/a&gt;実装にパラメーター情報を渡すために使用されます。</target>
        </trans-unit>
        <trans-unit id="780ed181ddbb53bd0cd75f887c1efe5a712dae77" translate="yes" xml:space="preserve">
          <source>These routines extract type, size, and content information from &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Protected sqlite3_value objects are used to pass parameter information into the functions that implement &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; and &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">これらのルーチンは、&lt;a href=&quot;#sqlite3_value&quot;&gt;保護されたsqlite3_value&lt;/a&gt;オブジェクトからタイプ、サイズ、およびコンテンツ情報を抽出します。保護されたsqlite3_valueオブジェクトは、&lt;a href=&quot;appfunc&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;と&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;を実装する関数にパラメーター情報を渡すために使用されます。</target>
        </trans-unit>
        <trans-unit id="c79baca34267204233cef0f72fa563f702ea3b9b" translate="yes" xml:space="preserve">
          <source>These routines extract type, size, and content information from &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Protected sqlite3_value objects are used to pass parameter information into implementation of &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; and &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">これらのルーチンは、&lt;a href=&quot;value&quot;&gt;保護されたsqlite3_value&lt;/a&gt;オブジェクトからタイプ、サイズ、コンテンツ情報を抽出します。保護されたsqlite3_valueオブジェクトは、&lt;a href=&quot;create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;と&lt;a href=&quot;../vtab&quot;&gt;仮想テーブルの&lt;/a&gt;実装にパラメーター情報を渡すために使用されます。</target>
        </trans-unit>
        <trans-unit id="080e4929a8edf88eab58f3131b66975c555d313b" translate="yes" xml:space="preserve">
          <source>These routines extract type, size, and content information from &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Protected sqlite3_value objects are used to pass parameter information into the functions that implement &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; and &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">これらのルーチンは、&lt;a href=&quot;value&quot;&gt;保護されたsqlite3_value&lt;/a&gt;オブジェクトからタイプ、サイズ、およびコンテンツ情報を抽出します。保護されたsqlite3_valueオブジェクトは、&lt;a href=&quot;../appfunc&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;と&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;を実装する関数にパラメーター情報を渡すために使用されます。</target>
        </trans-unit>
        <trans-unit id="b6356562f1a7ea967d47e4aa35dbd596cfeb17ce" translate="yes" xml:space="preserve">
          <source>These routines must be called from the same thread as the SQL function that supplied the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value*&lt;/a&gt; parameters.</source>
          <target state="translated">これらのルーチンは、&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value *&lt;/a&gt;パラメータを提供したSQL関数と同じスレッドから呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="ea74f3659cddc5ce0c6b4fa5c6b8b6ea6fcf9692" translate="yes" xml:space="preserve">
          <source>These routines must be called from the same thread as the SQL function that supplied the &lt;a href=&quot;value&quot;&gt;sqlite3_value*&lt;/a&gt; parameters.</source>
          <target state="translated">これらのルーチンは、&lt;a href=&quot;value&quot;&gt;sqlite3_value *&lt;/a&gt;パラメータを提供したSQL関数と同じスレッドから呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="a54537ed3c843a1d7c75c98c519dd12715dd5904" translate="yes" xml:space="preserve">
          <source>These routines must be called from the same thread in which the SQL function is running.</source>
          <target state="translated">これらのルーチンは、SQL関数が実行されているのと同じスレッドから呼び出されなければなりません。</target>
        </trans-unit>
        <trans-unit id="aea4f6b4200dc559c39531008b13c73c4dca39ea" translate="yes" xml:space="preserve">
          <source>These routines open an SQLite database file as specified by the filename argument. The filename argument is interpreted as UTF-8 for sqlite3_open() and sqlite3_open_v2() and as UTF-16 in the native byte order for sqlite3_open16(). A &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; handle is usually returned in *ppDb, even if an error occurs. The only exception is that if SQLite is unable to allocate memory to hold the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object, a NULL will be written into *ppDb instead of a pointer to the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object. If the database is opened (and/or created) successfully, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; is returned. Otherwise an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned. The &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt; routines can be used to obtain an English language description of the error following a failure of any of the sqlite3_open() routines.</source>
          <target state="translated">これらのルーチンは、filename引数で指定されたSQLiteデータベースファイルを開きます。 filename引数は、sqlite3_open（）およびsqlite3_open_v2（）の場合はUTF-8として、sqlite3_open16（）の場合はネイティブバイトオーダーのUTF-16として解釈されます。&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;ハンドルは通常、エラーが発生した場合でも、* ppDbで返されます。唯一の例外は、SQLiteが&lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt;オブジェクトを保持するメモリを割り当てることができない場合、&lt;a href=&quot;#sqlite3&quot;&gt;SQLite3&lt;/a&gt;オブジェクトへのポインタの代わりにNULLが* ppDbに書き込まれることです。データベースが正常に開かれた（または作成された）場合、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;が返されます。それ以外の場合は、&lt;a href=&quot;rescode&quot;&gt;エラーコード&lt;/a&gt;が返されます。&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;または&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg16（）&lt;/a&gt;ルーチンを使用して、sqlite3_open（）ルーチンのいずれかが失敗した後のエラーの英語の説明を取得できます。</target>
        </trans-unit>
        <trans-unit id="24814302ce83d408ddc70164757005571a98a1af" translate="yes" xml:space="preserve">
          <source>These routines open an SQLite database file as specified by the filename argument. The filename argument is interpreted as UTF-8 for sqlite3_open() and sqlite3_open_v2() and as UTF-16 in the native byte order for sqlite3_open16(). A &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; handle is usually returned in *ppDb, even if an error occurs. The only exception is that if SQLite is unable to allocate memory to hold the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object, a NULL will be written into *ppDb instead of a pointer to the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object. If the database is opened (and/or created) successfully, then &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; is returned. Otherwise an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned. The &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; or &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt; routines can be used to obtain an English language description of the error following a failure of any of the sqlite3_open() routines.</source>
          <target state="translated">これらのルーチンは、filename引数で指定されたSQLiteデータベースファイルを開きます。 filename引数は、sqlite3_open（）およびsqlite3_open_v2（）の場合はUTF-8として、sqlite3_open16（）の場合はネイティブバイトオーダーのUTF-16として解釈されます。&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;ハンドルは通常、エラーが発生した場合でも、* ppDbで返されます。唯一の例外は、SQLiteが&lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt;オブジェクトを保持するメモリを割り当てることができない場合、&lt;a href=&quot;sqlite3&quot;&gt;SQLite3&lt;/a&gt;オブジェクトへのポインタの代わりにNULLが* ppDbに書き込まれることです。データベースが正常に開かれた（または作成された）場合、&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;が返されます。それ以外の場合は、&lt;a href=&quot;../rescode&quot;&gt;エラーコード&lt;/a&gt;が返されます。&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;または&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg16（）&lt;/a&gt;ルーチンを使用して、sqlite3_open（）ルーチンのいずれかが失敗した後のエラーの英語の説明を取得できます。</target>
        </trans-unit>
        <trans-unit id="4cb0a6ed5fd628702f759fa88fc57a08522ef219" translate="yes" xml:space="preserve">
          <source>These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The name of the database or table or column can be returned as either a UTF-8 or UTF-16 string. The _database_ routines return the database name, the _table_ routines return the table name, and the origin_ routines return the column name. The returned string is valid until the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed using &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the same information is requested again in a different encoding.</source>
          <target state="translated">これらのルーチンは、&lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントの特定の結果列の起点であるデータベース、テーブル、およびテーブル列を判別する手段を提供します。データベース、テーブル、または列の名前は、UTF-8またはUTF-16文字列として返すことができます。 _database_ルーチンはデータベース名を返し、_table_ルーチンはテーブル名を返し、origin_ルーチンは列名を返します。返された文字列は、&lt;a href=&quot;stmt&quot;&gt;準備されたステートメント&lt;/a&gt;が&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;を使用して破棄されるまで、またはステートメントが特定の実行のために&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;への最初の呼び出しによって自動的に再準備されるまで、または同じ情報が別のエンコーディングで再度要求されるまで有効です。</target>
        </trans-unit>
        <trans-unit id="6747cec9622a96ae1091ed2adc2461d962bf2710" translate="yes" xml:space="preserve">
          <source>These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The name of the database or table or column can be returned as either a UTF-8 or UTF-16 string. The _database_ routines return the database name, the _table_ routines return the table name, and the origin_ routines return the column name. The returned string is valid until the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed using &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the same information is requested again in a different encoding.</source>
          <target state="translated">これらのルーチンは、&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントの特定の結果列の起点であるデータベース、テーブル、およびテーブル列を判別する手段を提供します。データベース、テーブル、または列の名前は、UTF-8またはUTF-16文字列として返すことができます。 _database_ルーチンはデータベース名を返し、_table_ルーチンはテーブル名を返し、origin_ルーチンは列名を返します。返された文字列は、&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備されたステートメント&lt;/a&gt;が&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;を使用して破棄されるまで、またはステートメントが特定の実行のために&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;への最初の呼び出しによって自動的に再準備されるまで、または同じ情報が別のエンコーディングで再度要求されるまで有効です。</target>
        </trans-unit>
        <trans-unit id="723ec7b5764e01bb470a171ac81db6f1bccacf01" translate="yes" xml:space="preserve">
          <source>These routines provide access to the set of SQL language keywords recognized by SQLite. Applications can uses these routines to determine whether or not a specific identifier needs to be escaped (for example, by enclosing in double-quotes) so as not to confuse the parser.</source>
          <target state="translated">これらのルーチンは、SQLite が認識する SQL 言語キーワードのセットへのアクセスを提供します。アプリケーションはこれらのルーチンを使用して、パーサを混乱させないように特定の識別子をエスケープする必要があるかどうかを判断することができます(例えば、ダブルクォートで囲むなど)。</target>
        </trans-unit>
        <trans-unit id="c63151a5ae56c785b897a0325e0c6f8aa37ea7fb" translate="yes" xml:space="preserve">
          <source>These routines provide direct access to the version of the Wagner edit-distance function that allows for application-defined weights on edit operations. The first two forms of this function compare pattern P against word W and return the edit distance. In the first function, the langid is assumed to be 0 and in the second, the langid is given by the L parameter. The third form of this function reloads edit distance coefficients from the table named by T.</source>
          <target state="translated">これらのルーチンは、編集操作にアプリケーション定義の重み付けを可能にする Wagner edit-distance 関数のバージョンへの直接アクセスを提供します。この関数の最初の2つの形式は、パターンPと単語Wを比較し、編集距離を返します。最初の関数では,langidは0と仮定され,2番目の関数では,langidはLパラメータによって与えられます.この関数の第3の形式は,Tで指定されたテーブルから編集距離係数を再読み込みします.</target>
        </trans-unit>
        <trans-unit id="6ece6463ac2989d7eff64fecae9f2305cb234cc2" translate="yes" xml:space="preserve">
          <source>These routines register callback functions that can be used for tracing and profiling the execution of SQL statements.</source>
          <target state="translated">これらのルーチンは、SQL文の実行のトレースやプロファイリングに使用できるコールバック関数を登録します。</target>
        </trans-unit>
        <trans-unit id="40a118423314c412a0ead5a2681ebf518ed77f67" translate="yes" xml:space="preserve">
          <source>These routines return 0 if the statement is incomplete. If a memory allocation fails, then SQLITE_NOMEM is returned.</source>
          <target state="translated">これらのルーチンは、ステートメントが不完全な場合は 0 を返します。メモリの割り当てに失敗した場合は、SQLITE_NOMEMが返されます。</target>
        </trans-unit>
        <trans-unit id="324c17666cfb5119bcfea9a10a94bbaee6b00643" translate="yes" xml:space="preserve">
          <source>These routines return information about a single column of the current result row of a query. In every case the first argument is a pointer to the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; that is being evaluated (the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; that was returned from &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or one of its variants) and the second argument is the index of the column for which information should be returned. The leftmost column of the result set has the index 0. The number of columns in the result can be determined using &lt;a href=&quot;#sqlite3_column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt;.</source>
          <target state="translated">これらのルーチンは、クエリの現在の結果行の単一の列に関する情報を返します。いずれの場合も、最初の引数は評価&lt;a href=&quot;#sqlite3_stmt&quot;&gt;され&lt;/a&gt;ている準備済みステートメント（&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;またはそのバリアントの1つから返された&lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt * &lt;/a&gt;）へのポインターであり、2番目の引数は情報を返す必要がある列のインデックスです。結果セットの左端の列のインデックスは0です。結果の列の数は、&lt;a href=&quot;#sqlite3_column_count&quot;&gt;sqlite3_column_count（）&lt;/a&gt;を使用して決定できます。</target>
        </trans-unit>
        <trans-unit id="5435456a1f2380e65f87b371b45464ea838877ae" translate="yes" xml:space="preserve">
          <source>These routines return information about a single column of the current result row of a query. In every case the first argument is a pointer to the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; that is being evaluated (the &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; that was returned from &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or one of its variants) and the second argument is the index of the column for which information should be returned. The leftmost column of the result set has the index 0. The number of columns in the result can be determined using &lt;a href=&quot;column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt;.</source>
          <target state="translated">これらのルーチンは、クエリの現在の結果行の単一の列に関する情報を返します。いずれの場合も、最初の引数は評価&lt;a href=&quot;stmt&quot;&gt;され&lt;/a&gt;ている準備済みステートメント（&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;またはそのバリアントの1つから返された&lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt * &lt;/a&gt;）へのポインターであり、2番目の引数は情報を返す必要がある列のインデックスです。結果セットの左端の列のインデックスは0です。結果の列の数は、&lt;a href=&quot;column_count&quot;&gt;sqlite3_column_count（）&lt;/a&gt;を使用して決定できます。</target>
        </trans-unit>
        <trans-unit id="86c424b8734fe7ddecb01d35115c043c61c06f29" translate="yes" xml:space="preserve">
          <source>These routines return the name assigned to a particular column in the result set of a &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The sqlite3_column_name() interface returns a pointer to a zero-terminated UTF-8 string and sqlite3_column_name16() returns a pointer to a zero-terminated UTF-16 string. The first parameter is the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; that implements the &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The second parameter is the column number. The leftmost column is number 0.</source>
          <target state="translated">これらのルーチンは、&lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントの結果セットの特定の列に割り当てられた名前を返します。sqlite3_column_name（）インターフェースはゼロで終了するUTF-8文字列へのポインターを返し、sqlite3_column_name16（）はゼロで終了するUTF-16文字列へのポインターを返します。最初のパラメーターは、&lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントを実装する&lt;a href=&quot;stmt&quot;&gt;準備済みステートメント&lt;/a&gt;です。2番目のパラメーターは列番号です。左端の列は番号0です。</target>
        </trans-unit>
        <trans-unit id="c92c0a5a51a4b6415e4465e481831e591f5adbb3" translate="yes" xml:space="preserve">
          <source>These routines return the name assigned to a particular column in the result set of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The sqlite3_column_name() interface returns a pointer to a zero-terminated UTF-8 string and sqlite3_column_name16() returns a pointer to a zero-terminated UTF-16 string. The first parameter is the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; that implements the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The second parameter is the column number. The leftmost column is number 0.</source>
          <target state="translated">これらのルーチンは、&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントの結果セットの特定の列に割り当てられた名前を返します。sqlite3_column_name（）インターフェースはゼロで終了するUTF-8文字列へのポインターを返し、sqlite3_column_name16（）はゼロで終了するUTF-16文字列へのポインターを返します。最初のパラメーターは、&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントを実装する&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備済みステートメント&lt;/a&gt;です。2番目のパラメーターは列番号です。左端の列は番号0です。</target>
        </trans-unit>
        <trans-unit id="5de2bfd9e6d919b373b4c3d1b80a7310909f2955" translate="yes" xml:space="preserve">
          <source>These routines should return true if the mutex in their argument is held or not held, respectively, by the calling thread.</source>
          <target state="translated">これらのルーチンは、引数に含まれるミューテックスが呼び出されたスレッドによって保持されている場合と保持されていない場合、それぞれ真を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="afa365b8dc52497e4284392ecbb9654dff91e29b" translate="yes" xml:space="preserve">
          <source>These routines throw an error if the first JSON argument is not well-formed or if any PATH argument is not well-formed or if any argument is a BLOB.</source>
          <target state="translated">これらのルーチンは、最初の JSON 引数が整形されていない場合や、PATH 引数が整形されていない場合、またはいずれかの引数が BLOB である場合にエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="040db3ed336324c99d540be07030ca6b73dfe1d9" translate="yes" xml:space="preserve">
          <source>These routines work just like the corresponding &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;column access functions&lt;/a&gt; except that these routines take a single &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; object pointer instead of a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; pointer and an integer column number.</source>
          <target state="translated">これらのルーチンは、&lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt *&lt;/a&gt;ポインターと整数の列番号の代わりに単一の&lt;a href=&quot;#sqlite3_value&quot;&gt;保護されたsqlite3_value&lt;/a&gt;オブジェクトポインターを取ることを除いて、対応する&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;列アクセス関数と&lt;/a&gt;同じように機能します。</target>
        </trans-unit>
        <trans-unit id="8f8d6c3e862ca519958d58c8125484847b89c711" translate="yes" xml:space="preserve">
          <source>These routines work just like the corresponding &lt;a href=&quot;column_blob&quot;&gt;column access functions&lt;/a&gt; except that these routines take a single &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; object pointer instead of a &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; pointer and an integer column number.</source>
          <target state="translated">これらのルーチンは、&lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt *&lt;/a&gt;ポインターと整数の列番号の代わりに単一の&lt;a href=&quot;value&quot;&gt;保護されたsqlite3_value&lt;/a&gt;オブジェクトポインターを取ることを除いて、対応する&lt;a href=&quot;column_blob&quot;&gt;列アクセス関数と&lt;/a&gt;同じように機能します。</target>
        </trans-unit>
        <trans-unit id="95d389aedaf4f8ce85f9804703017919fd80feca" translate="yes" xml:space="preserve">
          <source>These routines work only with &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Any attempt to use these routines on an &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; is not threadsafe.</source>
          <target state="translated">これらのルーチンは、&lt;a href=&quot;#sqlite3_value&quot;&gt;保護されたsqlite3_value&lt;/a&gt;オブジェクトでのみ機能します。&lt;a href=&quot;#sqlite3_value&quot;&gt;保護さ&lt;/a&gt;れていないsqlite3_valueでこれらのルーチンを使用しようとしても、スレッドセーフではありません。</target>
        </trans-unit>
        <trans-unit id="7a8ed928c1fb3dc4a20d3be2fb5cfe01bd35f70b" translate="yes" xml:space="preserve">
          <source>These routines work only with &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Any attempt to use these routines on an &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; is not threadsafe.</source>
          <target state="translated">これらのルーチンは、&lt;a href=&quot;value&quot;&gt;保護されたsqlite3_value&lt;/a&gt;オブジェクトでのみ機能します。&lt;a href=&quot;value&quot;&gt;保護さ&lt;/a&gt;れていないsqlite3_valueでこれらのルーチンを使用しようとしても、スレッドセーフではありません。</target>
        </trans-unit>
        <trans-unit id="cf9c078687c96682c6a85bb7a67b91a68491a0f8" translate="yes" xml:space="preserve">
          <source>These static mutexes are reserved for use internally by SQLite and should not be used by the application. The static mutexes are all non-recursive.</source>
          <target state="translated">これらの静的ミューテックスは SQLite 内部で使用するために予約されており、アプリケーションでは使用してはいけません。これらの静的ミューテックスはすべて再帰的ではありません。</target>
        </trans-unit>
        <trans-unit id="a11e17b224413c41480316935dad79b1f586c189" translate="yes" xml:space="preserve">
          <source>These techniques are designed to aid in understanding the core SQLite library itself, not applications that merely use SQLite.</source>
          <target state="translated">これらのテクニックは、単にSQLiteを使用しているだけのアプリケーションではなく、コアとなるSQLiteライブラリ自体を理解するのに役立つように設計されています。</target>
        </trans-unit>
        <trans-unit id="7f9968558d6525a5e69fdd942a06f1a35ab390ef" translate="yes" xml:space="preserve">
          <source>These tests are on a relatively small (approximately 14 megabyte) database. They do not measure how well the database engines scale to larger problems.</source>
          <target state="translated">これらのテストは、比較的小さな(約14メガバイト)データベースを対象としています。これらのテストは、データベースエンジンがどれだけ大きな問題に対応できるかを測定するものではありません。</target>
        </trans-unit>
        <trans-unit id="f97df2bc02e2ab86d912a22d332def150459caf8" translate="yes" xml:space="preserve">
          <source>These tests did not attempt to measure multi-user performance or optimization of complex queries involving multiple joins and subqueries.</source>
          <target state="translated">これらのテストでは、複数のジョインやサブクエリを含む複雑なクエリのマルチユーザー・パフォーマンスや最適化を測定しようとはしていません。</target>
        </trans-unit>
        <trans-unit id="dd70aa0fe10c02751ca4c43bd10acab99e561495" translate="yes" xml:space="preserve">
          <source>These three ways of committing a transaction correspond to the DELETE, TRUNCATE, and PERSIST settings, respectively, of the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt;.</source>
          <target state="translated">トランザクションをコミットするこれらの3つの方法は、それぞれ、&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_modeプラグマ&lt;/a&gt;のDELETE、TRUNCATE、およびPERSIST設定に対応しています。</target>
        </trans-unit>
        <trans-unit id="8f79d49bdd4e3aeeeb4789bde61715a9a01e430c" translate="yes" xml:space="preserve">
          <source>These two rules describe how the query planner for SQLite works as of this writing (2013-08-01). And the rules above will always be honored. However, future versions of SQLite might incorporate a better theorem prover that can find other cases where W&amp;rArr;X is true and thus may find more instances where partial indexes are useful.</source>
          <target state="translated">これらの2つのルールは、SQLiteのクエリプランナーがこの記事（2013-08-01）でどのように機能するかを説明しています。そして、上記のルールは常に守られます。ただし、SQLiteの将来のバージョンには、W&amp;rArr;Xがtrueである他のケースを見つけることができるより優れた定理証明機能が組み込まれる可能性があるため、部分インデックスが役立つインスタンスがさらに見つかる可能性があります。</target>
        </trans-unit>
        <trans-unit id="c8fd956e215d583a512e53c2c78546d08e30ff46" translate="yes" xml:space="preserve">
          <source>Things That Can Go Wrong</source>
          <target state="translated">うまくいかないことがある</target>
        </trans-unit>
        <trans-unit id="42067c10086226bb2498180a8a023f3ac259d639" translate="yes" xml:space="preserve">
          <source>Things are more complicated if the sqlite3_changes() function is executed while a trigger program is running. This may happen if the program uses the &lt;a href=&quot;../lang_corefunc#changes&quot;&gt;changes() SQL function&lt;/a&gt;, or if some other callback function invokes sqlite3_changes() directly. Essentially:</source>
          <target state="translated">トリガープログラムの実行中にsqlite3_changes（）関数を実行すると、状況はさらに複雑になります。これは、プログラムが&lt;a href=&quot;../lang_corefunc#changes&quot;&gt;changes（）SQL関数を&lt;/a&gt;使用する場合、または他のコールバック関数がsqlite3_changes（）を直接呼び出す場合に発生する可能性があります。基本的に：</target>
        </trans-unit>
        <trans-unit id="53a7af1ec1bf96fe1cf7aeeb3a8a96e5b6a416b2" translate="yes" xml:space="preserve">
          <source>Things are more complicated if the sqlite3_changes() function is executed while a trigger program is running. This may happen if the program uses the &lt;a href=&quot;lang_corefunc#changes&quot;&gt;changes() SQL function&lt;/a&gt;, or if some other callback function invokes sqlite3_changes() directly. Essentially:</source>
          <target state="translated">トリガープログラムの実行中にsqlite3_changes（）関数を実行すると、状況はさらに複雑になります。これは、プログラムが&lt;a href=&quot;lang_corefunc#changes&quot;&gt;changes（）SQL関数を&lt;/a&gt;使用する場合、または他のコールバック関数がsqlite3_changes（）を直接呼び出す場合に発生する可能性があります。基本的に：</target>
        </trans-unit>
        <trans-unit id="774483139813d257b6024c3ca6cbcda75578301f" translate="yes" xml:space="preserve">
          <source>Think of each SQL statement as a separate computer program. The original SQL text is source code. A prepared statement object is the compiled object code. All SQL must be converted into a prepared statement before it can be run.</source>
          <target state="translated">それぞれのSQL文を個別のコンピュータプログラムと考えてください。元のSQL文はソースコードです。準備された文オブジェクトは、コンパイルされたオブジェクトコードです。すべてのSQLは、実行する前に準備された文に変換されなければなりません。</target>
        </trans-unit>
        <trans-unit id="2f8cd345a6425d660448be637505c8f25ad1aef9" translate="yes" xml:space="preserve">
          <source>Think of each SQL statement as a small computer program. The purpose of &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; is to compile that program into object code. The &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; is the object code. The &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface then runs the object code to get a result.</source>
          <target state="translated">各SQLステートメントを小さなコンピュータープログラムと考えてください。&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;の目的は、そのプログラムをオブジェクトコードにコンパイルすることです。&lt;a href=&quot;c3ref/stmt&quot;&gt;プリペアドステートメントは、&lt;/a&gt;オブジェクトコードです。次に&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;インターフェースはオブジェクトコードを実行して結果を取得します。</target>
        </trans-unit>
        <trans-unit id="cfafbb2da361739c04c43a8272cc38856e9c67a7" translate="yes" xml:space="preserve">
          <source>Third Improvement: Versioning</source>
          <target state="translated">3回目の改善。バージョニング</target>
        </trans-unit>
        <trans-unit id="865c9c12492c3442466282bf437772709b257a8a" translate="yes" xml:space="preserve">
          <source>This API can be quite slow if used with an FTS5 table created with the &quot;detail=none&quot; option. If the FTS5 table is created with either &quot;detail=none&quot; &quot;content=&quot; option (i.e. if it is a contentless table), then this API always iterates through an empty set (all calls to xPhraseFirstColumn() set iCol to -1).</source>
          <target state="translated">detail=none &quot;オプションで作成されたFTS5テーブルで使用した場合、このAPIは非常に遅くなる可能性があります。FTS5 テーブルが &quot;detail=none&quot; &quot;content=&quot; オプションのいずれかで作成された場合 (つまり、コンテンツレステーブルの場合)、この API は常に空のセットを繰り返し処理します (xPhraseFirstColumn()への呼び出しはすべて iCol を -1 に設定します)。</target>
        </trans-unit>
        <trans-unit id="ebf79b4cb55761477acdbbee63fd4654b2112a93" translate="yes" xml:space="preserve">
          <source>This API can be quite slow if used with an FTS5 table created with the &quot;detail=none&quot; or &quot;detail=column&quot; option.</source>
          <target state="translated">このAPIは、&quot;detail=none &quot;または &quot;detail=column &quot;オプションで作成されたFTS5テーブルで使用すると、非常に遅くなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="320a596dec5edeedf6c5c2728a533311ecff7379" translate="yes" xml:space="preserve">
          <source>This API can be quite slow if used with an FTS5 table created with the &quot;detail=none&quot; or &quot;detail=column&quot; option. If the FTS5 table is created with either &quot;detail=none&quot; or &quot;detail=column&quot; and &quot;content=&quot; option (i.e. if it is a contentless table), then this API always iterates through an empty set (all calls to xPhraseFirst() set iCol to -1).</source>
          <target state="translated">このAPIは、&quot;detail=none &quot;または &quot;detail=column &quot;オプションで作成されたFTS5テーブルで使用すると、非常に遅くなる可能性があります。FTS5 テーブルが &quot;detail=none&quot; または &quot;detail=column&quot; および &quot;content=&quot; オプションのいずれかで作成されている場合 (つまり、コンテンツレステーブルの場合)、この API は常に空のセットを繰り返し処理します (xPhraseFirst()へのすべての呼び出しは iCol を -1 に設定します)。</target>
        </trans-unit>
        <trans-unit id="f65fb946e21f0df296308a1267bfc8d75459c36f" translate="yes" xml:space="preserve">
          <source>This API can be quite slow if used with an FTS5 table created with the &quot;detail=none&quot; or &quot;detail=column&quot; option. If the FTS5 table is created with either &quot;detail=none&quot; or &quot;detail=column&quot; and &quot;content=&quot; option (i.e. if it is a contentless table), then this API always returns 0.</source>
          <target state="translated">このAPIは、&quot;detail=none &quot;または &quot;detail=column &quot;オプションで作成されたFTS5テーブルで使用すると、非常に遅くなる可能性があります。FTS5 テーブルが &quot;detail=none&quot; または &quot;detail=column&quot; と &quot;content=&quot; オプションのいずれかで作成された場合 (つまり、コンテンツレステーブルの場合)、この API は常に 0 を返します。</target>
        </trans-unit>
        <trans-unit id="43444bfacf757a80f8f09485afde0ead5f0a776e" translate="yes" xml:space="preserve">
          <source>This API function is used to query the FTS table for phrase iPhrase of the current query. Specifically, a query equivalent to:</source>
          <target state="translated">本 API 関数は、現在のクエリの phrase iPhrase を FTS テーブルに問い合わせるために使用する。具体的には、これに相当するクエリ。</target>
        </trans-unit>
        <trans-unit id="d89725045237fc9113c1fa0f974917002e582aec" translate="yes" xml:space="preserve">
          <source>This API is only available if the library is built with pre-processor symbol &lt;a href=&quot;../compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt; defined.</source>
          <target state="translated">このAPIは、ライブラリーがプリプロセッサーシンボル&lt;a href=&quot;../compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUSが&lt;/a&gt;定義されてビルドされている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="48dac83568aa304395644b3c39b1c1984d8ea7c3" translate="yes" xml:space="preserve">
          <source>This API is only available if the library is built with pre-processor symbol &lt;a href=&quot;compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt; defined.</source>
          <target state="translated">このAPIは、ライブラリーがプリプロセッサーシンボル&lt;a href=&quot;compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUSが&lt;/a&gt;定義されてビルドされている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="f548cc5880d8bc2ce8ab0c825c0274336bee682c" translate="yes" xml:space="preserve">
          <source>This API makes sure a global version of a function with a particular name and number of parameters exists. If no such function exists before this API is called, a new function is created. The implementation of the new function always causes an exception to be thrown. So the new function is not good for anything by itself. Its only purpose is to be a placeholder function that can be overloaded by a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">このAPIは、特定の名前と数のパラメーターを持つ関数のグローバルバージョンが存在することを確認します。このAPIが呼び出される前にそのような関数が存在しない場合、新しい関数が作成されます。新しい関数の実装により、常に例外がスローされます。そのため、新しい機能はそれ自体では何の役にも立ちません。その唯一の目的は、&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;によってオーバーロードできるプレースホルダー関数になることです。</target>
        </trans-unit>
        <trans-unit id="8540f6a2004da77a77789ccfaf202735cf5c6ba1" translate="yes" xml:space="preserve">
          <source>This API makes sure a global version of a function with a particular name and number of parameters exists. If no such function exists before this API is called, a new function is created. The implementation of the new function always causes an exception to be thrown. So the new function is not good for anything by itself. Its only purpose is to be a placeholder function that can be overloaded by a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">このAPIは、特定の名前と数のパラメーターを持つ関数のグローバルバージョンが存在することを確認します。このAPIが呼び出される前にそのような関数が存在しない場合、新しい関数が作成されます。新しい関数の実装により、常に例外がスローされます。そのため、新しい機能はそれ自体では何の役にも立ちません。その唯一の目的は、&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;によってオーバーロードできるプレースホルダー関数になることです。</target>
        </trans-unit>
        <trans-unit id="6ab96b1e97da69a025cb8ca96b99b710398cad45" translate="yes" xml:space="preserve">
          <source>This C-preprocess macro determines the default setting of the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigcoveringindexscan&quot;&gt;SQLITE_CONFIG_COVERING_INDEX_SCAN&lt;/a&gt; configuration setting. It defaults to 1 (on) which means that covering indices are used for full table scans where possible, in order to reduce I/O and improve performance. However, the use of a covering index for a full scan will cause results to appear in a different order from legacy, which could cause some (incorrectly-coded) legacy applications to break. Hence, the covering index scan option can be disabled at compile-time on systems that what to minimize their risk of exposing errors in legacy applications.</source>
          <target state="translated">このC-プリプロセスマクロは、&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigcoveringindexscan&quot;&gt;SQLITE_CONFIG_COVERING_INDEX_SCAN&lt;/a&gt;構成設定のデフォルト設定を決定します。デフォルトは1（オン）です。これは、I / Oを減らしてパフォーマンスを向上させるために、可能な場合は全表スキャンにカバーするインデックスが使用されることを意味します。ただし、フルスキャンにカバリングインデックスを使用すると、結果がレガシーとは異なる順序で表示されるため、一部の（正しくコーディングされていない）レガシーアプリケーションが破損する可能性があります。したがって、レガシーアプリケーションでエラーを公開するリスクを最小限に抑えるために、システムのコンパイル時にカバーインデックススキャンオプションを無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="9b6673eaea3893e3fceb60fe446b80a1ff19d0e8" translate="yes" xml:space="preserve">
          <source>This DELETE statement will remove every record from the &quot;examp&quot; table where the &quot;two&quot; column is less than 50. The code generated to do this is as follows:</source>
          <target state="translated">このDELETE文は、&quot;examp &quot;テーブルから &quot;two &quot;カラムが50未満のすべてのレコードを削除します。これを行うために生成されたコードは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="b0bfab415a485beb9edddb8d5188d00815376867" translate="yes" xml:space="preserve">
          <source>This allows optimizations: (a) when P4==0 there is no need to test the RowSet object for P3, as it is guaranteed not to contain it, (b) when P4==-1 there is no need to insert the value, as it will never be tested for, and (c) when a value that is part of set X is inserted, there is no need to search to see if the same value was previously inserted as part of set X (only if it was previously inserted as part of some other set).</source>
          <target state="translated">これにより最適化が可能になります。(a)P4==0の場合、P3が含まれていないことが保証されているので、RowSetオブジェクトをテストする必要はありません。 (b)P4==-1の場合、値を挿入する必要はありません。</target>
        </trans-unit>
        <trans-unit id="e9de882f0fc5b21571717171f0fcc8e049f8f4b3" translate="yes" xml:space="preserve">
          <source>This allows separate database connections to share the same in-memory database. Of course, all database connections sharing the in-memory database need to be in the same process. The database is automatically deleted and memory is reclaimed when the last connection to the database closes.</source>
          <target state="translated">これにより、別々のデータベース接続が同じインメモリデータベースを共有することができます。もちろん、インメモリデータベースを共有するすべてのデータベース接続は、同じプロセスである必要があります。データベースへの最後の接続が終了すると、データベースは自動的に削除され、メモリは再利用されます。</target>
        </trans-unit>
        <trans-unit id="c92e98ecc01f031d3a1efe7cd735db9a008161b9" translate="yes" xml:space="preserve">
          <source>This article also uses the terms &quot;bytecode program&quot; and &quot;prepared statement&quot; interchangeably, as they are mostly the same thing.</source>
          <target state="translated">この記事では、&quot;バイトコードプログラム &quot;と &quot;準備されたステートメント &quot;という用語も、ほとんど同じものであるため、互換的に使用しています。</target>
        </trans-unit>
        <trans-unit id="a9af0cbe702f19f3f49888228ef0df406a0e5175" translate="yes" xml:space="preserve">
          <source>This article defines what the limits of SQLite are and how they can be customized for specific applications. The default settings for limits are normally quite large and adequate for almost every application. Some applications may want to increase a limit here or there, but we expect such needs to be rare. More commonly, an application might want to recompile SQLite with much lower limits to avoid excess resource utilization in the event of bug in higher-level SQL statement generators or to help thwart attackers who inject malicious SQL statements.</source>
          <target state="translated">この記事では、SQLite の制限とは何か、そして特定のアプリケーション用にどのようにカスタマイズできるかを定義しています。デフォルトの制限値の設定は通常かなり大きく、ほとんどすべてのアプリケーションに適しています。アプリケーションによっては制限値を増やしたい場合もあるかもしれませんが、そのようなニーズは稀だと考えています。より一般的には、高レベルのSQL文生成器にバグが発生した場合の過剰なリソース利用を避けるため、あるいは悪意のあるSQL文を注入する攻撃者を阻止するために、アプリケーションははるかに低い制限値でSQLiteを再コンパイルしたいと思うかもしれません。</target>
        </trans-unit>
        <trans-unit id="316fd7167581f1bf3b1521c621172952b269d34a" translate="yes" xml:space="preserve">
          <source>This article describes how the SQLite developers measure CPU usage, what those measurements actually mean, and the techniques used by SQLite developers on their continuing quest to further reduce the CPU usage of the SQLite library.</source>
          <target state="translated">この記事では、SQLite 開発者がどのようにして CPU 使用率を測定しているのか、その測定値が実際に何を意味しているのか、そして SQLite ライブラリの CPU 使用率をさらに削減するために SQLite 開発者が使用しているテクニックについて説明しています。</target>
        </trans-unit>
        <trans-unit id="926f25884d306babc2c568ebac87d0360fd509bf" translate="yes" xml:space="preserve">
          <source>This article describes the SQLite OS portability layer or &quot;VFS&quot; - the module at the bottom of the SQLite implementation stack that provides portability across operating systems.</source>
          <target state="translated">この記事では、SQLite OS のポータビリティ層、つまり「VFS」について説明します。</target>
        </trans-unit>
        <trans-unit id="e9493c358448eb3b281eac84dedc92f4531c0a0b" translate="yes" xml:space="preserve">
          <source>This article describes the techniques used by SQLite to create the illusion of atomic commit.</source>
          <target state="translated">この記事では、アトミックコミットのような錯覚を起こすために SQLite で使用されるテクニックについて説明します。</target>
        </trans-unit>
        <trans-unit id="c7354274b5f5ad835c3ba9869336d09f507f1b91" translate="yes" xml:space="preserve">
          <source>This article describes the various temporary files that SQLite creates and uses. It describes when the files are created, when they are deleted, what they are used for, why they are important, and how to avoid them on systems where creating temporary files is expensive.</source>
          <target state="translated">この記事では、SQLite が作成して使用する様々な一時ファイルについて説明します。この記事では、いつファイルが作成され、いつ削除され、何のために使用されるのか、なぜ重要なのか、そして一時ファイルの作成に費用がかかるシステムではどのようにして回避するのかについて説明します。</target>
        </trans-unit>
        <trans-unit id="bf37adfcb2e68d7e2d42601f83e22affd6226d10" translate="yes" xml:space="preserve">
          <source>This article does not contain a step-by-step recipe for compiling SQLite. That would be difficult since each development situation is different. Rather, this article describes and illustrates the principals behind the compilation of SQLite. Typical compilation commands are provided as examples with the expectation that application developers can use these examples as guidance for developing their own custom compilation procedures. In other words, this article provides ideas and insights, not turnkey solutions.</source>
          <target state="translated">この記事には、SQLiteをコンパイルするためのステップバイステップのレシピは含まれていません。それぞれの開発状況が異なるため、それは難しいでしょう。むしろ、この記事ではSQLiteのコンパイルの背後にある原理を説明し、説明します。典型的なコンパイルコマンドは例として提供されており、アプリケーション開発者が独自のコンパイル手順を開発するための指針としてこれらの例を使用できることを期待しています。言い換えれば、この記事はアイデアと洞察を提供するものであり、即効性のある解決策を提供するものではありません。</target>
        </trans-unit>
        <trans-unit id="945df33c68655603cf7dd0502f5d42134ad32f1a" translate="yes" xml:space="preserve">
          <source>This article has been revised multiple times in an attempt to improve clarity, address concerns and misgivings, and to fix errors identified on &lt;a href=&quot;https://news.ycombinator.com/item?id=16806114&quot;&gt;Hacker News&lt;/a&gt;, &lt;a href=&quot;https://www.reddit.com/r/programming/comments/8c2niw/why_sqlite_does_not_use_git/&quot;&gt;Reddit&lt;/a&gt; and &lt;a href=&quot;https://lobste.rs/s/slcntl/why_sqlite_does_not_use_git&quot;&gt;Lobsters&lt;/a&gt;. The complete edit history can be seen at &lt;a href=&quot;https://sqlite.org/docsrc/finfo/pages/whynotgit.in&quot;&gt;https://sqlite.org/docsrc/finfo/pages/whynotgit.in&lt;/a&gt;. (Usage hint: Click on any two nodes of the graph for a diff.)</source>
          <target state="translated">この記事は、明快さを改善し、懸念と不安に対処し、&lt;a href=&quot;https://news.ycombinator.com/item?id=16806114&quot;&gt;Hacker News&lt;/a&gt;、&lt;a href=&quot;https://www.reddit.com/r/programming/comments/8c2niw/why_sqlite_does_not_use_git/&quot;&gt;Reddit&lt;/a&gt;、&lt;a href=&quot;https://lobste.rs/s/slcntl/why_sqlite_does_not_use_git&quot;&gt;Lobstersで&lt;/a&gt;特定されたエラーを修正するために、何度も改訂されました。完全な編集履歴は、&lt;a href=&quot;https://sqlite.org/docsrc/finfo/pages/whynotgit.in&quot;&gt;https：//sqlite.org/docsrc/finfo/pages/whynotgit.inで&lt;/a&gt;確認できます。（使用上のヒント：グラフの任意の2つのノードをクリックして差分を表示します。）</target>
        </trans-unit>
        <trans-unit id="62a4071d7245439102f2788bb499d61e09713933" translate="yes" xml:space="preserve">
          <source>This article has reviewed all of the major techniques used by SQLite's VDBE to implement SQL statements. What has not been shown is that most of these techniques can be used in combination to generate code for an appropriately complex query statement. For example, we have shown how sorting is accomplished on a simple query and we have shown how to implement a compound query. But we did not give an example of sorting in a compound query. This is because sorting a compound query does not introduce any new concepts: it merely combines two previous ideas (sorting and compounding) in the same VDBE program.</source>
          <target state="translated">この記事では、SQLiteのVDBEがSQL文を実装するために使用する主要なテクニックをすべてレビューしてきました。これまで見てこなかったのは、これらのテクニックのほとんどが、適切に複雑なクエリ文のコードを生成するために組み合わせて使用できるということです。例えば、単純なクエリでソートがどのように行われるかを示し、複合クエリを実装する方法を示しました。しかし、複合クエリでのソートの例は示していません。これは、複合クエリのソートは新しい概念を導入していないからである。これは、以前の2つの概念(ソートと複合)を同じVDBEプログラムで組み合わせただけである。</target>
        </trans-unit>
        <trans-unit id="a20be3ae1245d83ff9c73306d203b42ad8b16c54" translate="yes" xml:space="preserve">
          <source>This article is &lt;u&gt;not&lt;/u&gt; a comparison between Fossil and Git. See &lt;a href=&quot;https://fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wiki&quot;&gt;https://fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wiki&lt;/a&gt; for one comparison of the two systems. There are others as well.</source>
          <target state="translated">この記事はFossilとGitの比較ではあり&lt;u&gt;ません&lt;/u&gt;。2つのシステムの1つの比較については、&lt;a href=&quot;https://fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wiki&quot;&gt;https：//fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wiki&lt;/a&gt;を参照してください。他にもあります。</target>
        </trans-unit>
        <trans-unit id="afdaa5ec4a00df9435f74fca69ef2e683fab815e" translate="yes" xml:space="preserve">
          <source>This article is &lt;u&gt;not&lt;/u&gt; advocating that you switch your projects away from Git. You can use whatever version control system you want. If you are perfectly happy with Git, then by all means keep using Git. But, if you are wondering if there isn't something better, then maybe try to understand the perspectives presented below. Use the insights thus obtained to find or write a different and better version control system, or to just make improvements to Git itself.</source>
          <target state="translated">この記事では、プロジェクトをGitから切り替えることを推奨して&lt;u&gt;いません&lt;/u&gt;。必要なバージョン管理システムを使用できます。 Gitに完全に満足している場合は、必ずGitを使い続けてください。しかし、もっと良いものはないのかと疑問に思っているのなら、以下に示す見方を理解してみてください。このようにして得られた洞察を使用して、別のより良いバージョン管理システムを見つけたり、書き込んだり、Git自体を改善したりします。</target>
        </trans-unit>
        <trans-unit id="7e8b2b9b07235888ae1de754eef75c5cbe3b972b" translate="yes" xml:space="preserve">
          <source>This article is a brief introduction to how the VDBE works and in particular how the various VDBE instructions (documented &lt;a href=&quot;opcode&quot;&gt;here&lt;/a&gt;) work together to do useful things with the database. The style is tutorial, beginning with simple tasks and working toward solving more complex problems. Along the way we will visit most submodules in the SQLite library. After completing this tutorial, you should have a pretty good understanding of how SQLite works and will be ready to begin studying the actual source code.</source>
          <target state="translated">この記事は、VDBEがどのように機能するか、特にさまざまなVDBE命令（&lt;a href=&quot;opcode&quot;&gt;ここに&lt;/a&gt;記載されている）がデータベースで有用なことを行うためにどのように機能するかについての簡単な紹介です。スタイルはチュートリアルであり、単純なタスクから始まり、より複雑な問題の解決に向けて取り組みます。途中、SQLiteライブラリのほとんどのサブモジュールにアクセスします。このチュートリアルを完了すると、SQLiteがどのように機能するかをかなり理解でき、実際のソースコードの調査を開始する準備が整います。</target>
        </trans-unit>
        <trans-unit id="2a689ac1a6bfa9fdba228a490c8ca90cb86bfd11" translate="yes" xml:space="preserve">
          <source>This article is about the bottom layer.</source>
          <target state="translated">この記事は底辺層についての記事です。</target>
        </trans-unit>
        <trans-unit id="8376dd4be0a7eabaff5c0a359df7f198ffdee0ed" translate="yes" xml:space="preserve">
          <source>This article only mentions the most important and most commonly used SQLite interfaces. The SQLite library includes many other APIs implementing useful features that are not described here. A &lt;a href=&quot;c3ref/funclist&quot;&gt;complete list of functions&lt;/a&gt; that form the SQLite application programming interface is found at the &lt;a href=&quot;c3ref/intro&quot;&gt;C/C++ Interface Specification&lt;/a&gt;. Refer to that document for complete and authoritative information about all SQLite interfaces.</source>
          <target state="translated">この記事では、最も重要で最も一般的に使用されるSQLiteインターフェイスについてのみ説明します。 SQLiteライブラリには、ここで説明されていない便利な機能を実装する他の多くのAPIが含まれています。SQLiteアプリケーションプログラミングインターフェイスを形成する&lt;a href=&quot;c3ref/funclist&quot;&gt;関数&lt;/a&gt;の完全なリストは、&lt;a href=&quot;c3ref/intro&quot;&gt;C / C ++インターフェイス仕様にあり&lt;/a&gt;ます。すべてのSQLiteインターフェイスに関する完全で信頼できる情報については、そのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="ecb82abd11a7741bac191b285785a86679cd3dd8" translate="yes" xml:space="preserve">
          <source>This article outlines one possible method for keeping a private branch of SQLite in sync with the public SQLite source code. There are many ways of maintaining a private branch, of course. Nobody is compelled to use the method describe here. This article is not trying to impose a particular procedure on maintainers of private branches. The point of this article is to offer an example of one process for maintaining a private branch which can be used as a template for designing processes best suited for the circumstances of each individual project.</source>
          <target state="translated">この記事では、SQLite のプライベートブランチをパブリック SQLite のソースコードと同期させて維持するための方法を概説します。もちろん、プライベートブランチを維持する方法はたくさんあります。ここで説明した方法を使うことを強制されることはありません。この記事はプライベートブランチのメンテナに特定の手続きを課そうとしているわけではありません。この記事のポイントは、個々のプロジェクトの状況に合わせて最適なプロセスを設計するためのテンプレートとして使用できるプライベートブランチを維持するためのプロセスの一例を提供することです。</target>
        </trans-unit>
        <trans-unit id="6e9369c9e16c87662c003b06c9e9f9920fb45e35" translate="yes" xml:space="preserve">
          <source>This article overviews the importance of query planning, describes some of the problems inherent to query planning, and outlines how the NGQP solves those problems.</source>
          <target state="translated">この記事では、クエリ計画の重要性を概観し、クエリ計画に内在する問題のいくつかを説明し、NGQPがこれらの問題をどのように解決しているかを概説します。</target>
        </trans-unit>
        <trans-unit id="edd2ab1205dd1a38d5ce29f020d2d454461aadbe" translate="yes" xml:space="preserve">
          <source>This article presents a technique using the SQLite &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; interface such that calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; and &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; block until the required locks are available instead of returning SQLITE_LOCKED immediately. If the sqlite3_blocking_step() or sqlite3_blocking_prepare_v2() functions presented to the left return SQLITE_LOCKED, this indicates that to block would deadlock the system.</source>
          <target state="translated">この記事では、SQLiteの&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;インターフェースを使用して、SQLITE_LOCKEDをすぐに返すのではなく、必要なロックが利用可能になるまで&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;および&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;を呼び出す手法を紹介します。左側に示されているsqlite3_blocking_step（）またはsqlite3_blocking_prepare_v2（）関数がSQLITE_LOCKEDを返す場合、これはブロックするとシステムがデッドロックすることを示しています。</target>
        </trans-unit>
        <trans-unit id="9498c6cd8712f6376d65af391550cc9e3ffdabcd" translate="yes" xml:space="preserve">
          <source>This block of instruction cleans up the VDBE program. Three of these instructions aren't really required, but are generated by the SQLite parser from its code templates, which are designed to handle more complicated cases.</source>
          <target state="translated">この命令ブロックはVDBEプログラムをクリーンアップする。これらの命令のうち3つは実際には必要ありませんが、SQLiteパーサがコードテンプレートから生成します。</target>
        </trans-unit>
        <trans-unit id="4a01a06f54367b20ad3750e286b70148e2c847d5" translate="yes" xml:space="preserve">
          <source>This built-in window function calculates the window frame for each row in the same way as an aggregate window function. It returns the value of</source>
          <target state="translated">この組み込みウィンドウ関数は、集約ウィンドウ関数と同様に各行のウィンドウ枠を計算します。この関数は</target>
        </trans-unit>
        <trans-unit id="20ec5d83d88c2da3b16c3295bcff75c38125962e" translate="yes" xml:space="preserve">
          <source>This change is an exception to the version number rule described above in that it is neither forwards or backwards compatible. A complete reload of the database is required. This is the only exception.</source>
          <target state="translated">この変更は、前方互換性も後方互換性もないという点で、上述のバージョン番号ルールの例外です。データベースの完全なリロードが必要です。これが唯一の例外です。</target>
        </trans-unit>
        <trans-unit id="c6a5f96c5622bed501ea8661519073e0de4f52cd" translate="yes" xml:space="preserve">
          <source>This column also always contains an integer value greater than zero.</source>
          <target state="translated">また、この列には常にゼロより大きい整数値が含まれています。</target>
        </trans-unit>
        <trans-unit id="fb0358a44a2292d9d05f4777b69d5f05939eb420" translate="yes" xml:space="preserve">
          <source>This column always contains an integer value greater than zero.</source>
          <target state="translated">この列には常にゼロより大きい整数値が含まれています。</target>
        </trans-unit>
        <trans-unit id="1713bd9e06b77e4bbf5df2753a784a802e3933b6" translate="yes" xml:space="preserve">
          <source>This column determines which &lt;a href=&quot;fts3#*fts4languageid&quot; id=&quot;f4alid&quot;&gt;languageid&lt;/a&gt; is used to extract vocabulary from the FTS3/4 table.</source>
          <target state="translated">この列は、FTS3 / 4テーブルから語彙を抽出するために使用される&lt;a href=&quot;fts3#*fts4languageid&quot; id=&quot;f4alid&quot;&gt;言語&lt;/a&gt; IDを決定します。</target>
        </trans-unit>
        <trans-unit id="285c275d9591ca00ecba379d1be0f439e124856e" translate="yes" xml:space="preserve">
          <source>This column may contain either the text value '*' (i.e. a single character, U+002a) or an integer between 0 and N-1, where N is again the number of user-defined columns in the corresponding FTS table.</source>
          <target state="translated">この列は、テキスト値'*'(すなわち、1文字、U+002a)または0からN-1の間の整数を含むことができます。</target>
        </trans-unit>
        <trans-unit id="65f82075152c89e2aff2366597dc220e2a3e5878" translate="yes" xml:space="preserve">
          <source>This column must be set to NULL. If a non-NULL value is inserted into this column, or if a new non-NULL value is provided using an UPDATE statement, it is an error.</source>
          <target state="translated">この列は NULL に設定する必要があります。この列にNULL以外の値が挿入された場合、またはUPDATE文を使用して新しいNULL以外の値が提供された場合はエラーとなります。</target>
        </trans-unit>
        <trans-unit id="e9e3819e4d76ebe92176deabc7d0279eab9fbfc8" translate="yes" xml:space="preserve">
          <source>This column shows the phonetic hash prefix that was used to restrict the search. For any given query, this column should be the same for every row. This information is available for diagnostic purposes and is not normally considered useful in real applications.</source>
          <target state="translated">この列には、検索を制限するために使用されたハッシュ接頭辞が表示されます。どのようなクエリでも、この列はすべての行で同じでなければなりません。この情報は診断のためのものであり、通常は実際のアプリケーションでは有用ではないと考えられています。</target>
        </trans-unit>
        <trans-unit id="01288c4cfddc172d238625a965b9f1003be61617" translate="yes" xml:space="preserve">
          <source>This command both creates the new repository and populates it with all the latest SQLite code. You can then create a private branch as described in section 3.4.</source>
          <target state="translated">このコマンドは、新しいリポジトリを作成し、最新の SQLite コードをすべて埋め込んでいます。その後、3.4節で説明したようにプライベートブランチを作成することができます。</target>
        </trans-unit>
        <trans-unit id="e0ca6b6ac38f5b817649e53a976402c687ab2fa8" translate="yes" xml:space="preserve">
          <source>This command causes SQLite to disconnect from the previous database and reattach to an in-memory database with the content in</source>
          <target state="translated">このコマンドを実行すると、SQLite は以前のデータベースから切断し、インメモリデータベースに再アタッチします。</target>
        </trans-unit>
        <trans-unit id="52245829743ea4e1b3e2fa49a0972f85d14c8fbb" translate="yes" xml:space="preserve">
          <source>This command causes the &quot;callback&quot; script to be invoked whenever certain conditions occurs. The conditions are determined by the</source>
          <target state="translated">このコマンドは、特定の条件が発生したときに、&quot;callback &quot;スクリプトを起動させます。条件は</target>
        </trans-unit>
        <trans-unit id="13f59d1cb3e06c83ff056103acea107f7910080d" translate="yes" xml:space="preserve">
          <source>This command first deletes the entire full-text index, then rebuilds it based on the contents of the table or &lt;a href=&quot;fts5#external_content_tables&quot;&gt;content table&lt;/a&gt;. It is not available with &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless tables&lt;/a&gt;.</source>
          <target state="translated">このコマンドは、最初にフルテキストインデックス全体を削除し、次にテーブルまたは&lt;a href=&quot;fts5#external_content_tables&quot;&gt;コンテンツテーブルの&lt;/a&gt;内容に基づいてインデックスを再構築します。&lt;a href=&quot;fts5#contentless_tables&quot;&gt;コンテンツの&lt;/a&gt;ないテーブルでは使用できません。</target>
        </trans-unit>
        <trans-unit id="fe5638fc83b6cdbce8fdc02e570b8e2b10a1482f" translate="yes" xml:space="preserve">
          <source>This command is only available with &lt;a href=&quot;fts5#external_content_tables&quot;&gt;external content&lt;/a&gt; and &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless&lt;/a&gt; tables. It deletes all entries from the full-text index.</source>
          <target state="translated">このコマンドは、&lt;a href=&quot;fts5#external_content_tables&quot;&gt;外部コンテンツ&lt;/a&gt;とコンテンツの&lt;a href=&quot;fts5#contentless_tables&quot;&gt;ない&lt;/a&gt;テーブルでのみ使用できます。フルテキストインデックスからすべてのエントリを削除します。</target>
        </trans-unit>
        <trans-unit id="7489ecbcacef562551b65244089f9307c364a891" translate="yes" xml:space="preserve">
          <source>This command is only available with &lt;a href=&quot;fts5#external_content_tables&quot;&gt;external content&lt;/a&gt; and &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless&lt;/a&gt; tables. It is used to delete the index entries associated with a single row from the full-text index. This command and the &lt;a href=&quot;fts5#the_delete_all_command&quot;&gt;delete-all&lt;/a&gt; command are the only ways to remove entries from the full-text index of a contentless table.</source>
          <target state="translated">このコマンドは、&lt;a href=&quot;fts5#external_content_tables&quot;&gt;外部コンテンツ&lt;/a&gt;とコンテンツの&lt;a href=&quot;fts5#contentless_tables&quot;&gt;ない&lt;/a&gt;テーブルでのみ使用できます。これは、単一行に関連付けられたインデックスエントリをフルテキストインデックスから削除するために使用されます。このコマンドと&lt;a href=&quot;fts5#the_delete_all_command&quot;&gt;delete-all&lt;/a&gt;コマンドは、コンテンツのないテーブルのフルテキストインデックスからエントリを削除する唯一の方法です。</target>
        </trans-unit>
        <trans-unit id="a1d13a5c03e8731ed6d7cfb96b7277fb1a9eb4b2" translate="yes" xml:space="preserve">
          <source>This command is used to set the persistent &quot;pgsz&quot; option.</source>
          <target state="translated">このコマンドは、永続的な &quot;pgsz &quot;オプションを設定するために使用されます。</target>
        </trans-unit>
        <trans-unit id="b39428042e588fc7d00e73c6e90326dc9e9ea85b" translate="yes" xml:space="preserve">
          <source>This command is used to set the persistent &quot;rank&quot; option.</source>
          <target state="translated">このコマンドは、永続的な「ランク」オプションを設定するために使用されます。</target>
        </trans-unit>
        <trans-unit id="85b16bab1c29894a0c668469c8830c0b869b0913" translate="yes" xml:space="preserve">
          <source>This command is used to set the persistent &quot;usermerge&quot; option.</source>
          <target state="translated">このコマンドは、永続的な &quot;usermerge &quot;オプションを設定するために使用されます。</target>
        </trans-unit>
        <trans-unit id="3730a7c5668daaf6af3f627c894d5a241eb8942e" translate="yes" xml:space="preserve">
          <source>This command is used to verify that the full-text index is consistent with the contents of the FTS5 table or &lt;a href=&quot;fts5#external_content_tables&quot;&gt;content table&lt;/a&gt;. It is not available with &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless tables&lt;/a&gt;.</source>
          <target state="translated">このコマンドは、フルテキストインデックスがFTS5テーブルまたは&lt;a href=&quot;fts5#external_content_tables&quot;&gt;コンテンツテーブルの&lt;/a&gt;内容と一致していることを確認するために使用されます。&lt;a href=&quot;fts5#contentless_tables&quot;&gt;コンテンツの&lt;/a&gt;ないテーブルでは使用できません。</target>
        </trans-unit>
        <trans-unit id="1a574335749833522810d0e9deb16c3b1a8c4736" translate="yes" xml:space="preserve">
          <source>This command may also be used with ordinary FTS4 tables, for example if the implementation of the tokenizer changes. It is an error to attempt to rebuild the full-text index maintained by a contentless FTS4 table, since no content will be available to do the rebuilding.</source>
          <target state="translated">このコマンドは、トークン化の実装が変更された場合など、通常のFTS4テーブルでも使用することができます。内容のないFTS4テーブルが保持するフルテキストインデックスを再構築しようとするとエラーとなります。</target>
        </trans-unit>
        <trans-unit id="61072f8fd085f0b1c6b3c6456d8203db4cf536aa" translate="yes" xml:space="preserve">
          <source>This command merges all individual b-trees that currently make up the full-text index into a single large b-tree structure. This ensures that the full-text index consumes the minimum space within the database and is in the fastest form to query.</source>
          <target state="translated">このコマンドは、現在フルテキストインデックスを構成しているすべての個別の b-tree を 1 つの大きな b-tree 構造に統合します。これにより、フルテキストインデックスがデータベース内で最小のスペースを消費し、クエリを行う際に最も速い形式であることが保証されます。</target>
        </trans-unit>
        <trans-unit id="51ac15b2185be7d66cfb5466a048917c1313d8ae" translate="yes" xml:space="preserve">
          <source>This command merges b-tree structures together until roughly N pages of merged data have been written to the database, where N is the absolute value of the parameter specified as part of the 'merge' command. The size of each page is as configured by the &lt;a href=&quot;fts5#the_pgsz_configuration_option&quot;&gt;FTS5 pgsz option&lt;/a&gt;.</source>
          <target state="translated">このコマンドは、およそNページのマージされたデータがデータベースに書き込まれるまで、Bツリー構造をマージします。Nは、「merge」コマンドの一部として指定されたパラメーターの絶対値です。各ページのサイズは、&lt;a href=&quot;fts5#the_pgsz_configuration_option&quot;&gt;FTS5 pgszオプションで&lt;/a&gt;構成されたとおりです。</target>
        </trans-unit>
        <trans-unit id="f6ccb891d0018f34c8b539ed4ad53a6be49ac1c9" translate="yes" xml:space="preserve">
          <source>This command sequence is a lot to memorize and type. (One would want to create a bash alias or short shell script if it were used frequently.) Furthermore, it is not quite the same thing. The command above gives one a list of descendents without showing the branching structure, which is important for understanding what happened. In contrast, Fossil offers displays such as &lt;a href=&quot;https://sqlite.org/src/timeline?d=8a439a6dda390d74&amp;amp;n=15&quot;&gt;https://sqlite.org/src/timeline?d=8a439a6dda390d74&amp;amp;n=15&lt;/a&gt;, which is a tremendous help in analyzing the aftermath of historical changes.</source>
          <target state="translated">このコマンドシーケンスは、覚えて入力するのがたくさんあります。（頻繁に使用される場合は、bashエイリアスまたは短いシェルスクリプトを作成する必要があります。）さらに、これはまったく同じではありません。上記のコマンドは、分岐構造を示さずに子孫のリストを1つ与えます。これは、何が起こったかを理解するために重要です。対照的に、Fossilは&lt;a href=&quot;https://sqlite.org/src/timeline?d=8a439a6dda390d74&amp;amp;n=15&quot;&gt;https://sqlite.org/src/timeline?d=8a439a6dda390d74&amp;amp;n=15&lt;/a&gt;などの表示を提供します。これは、歴史的な変化の余波を分析するのに非常に役立ちます。</target>
        </trans-unit>
        <trans-unit id="309dfaa9b377c5a8af4ac33fa681865f1bffbfb3" translate="yes" xml:space="preserve">
          <source>This command will create a new branch named &quot;private&quot; (you can use a different name if you like) and assign it a background color of light blue (&quot;#add8e8&quot;). You can omit the background color if you want, though having a distinct background does make it easier to tell the branch from the &quot;trunk&quot; (the public branch) on timeline displays. You can change the background color of the private branch or of the public branch (the &quot;trunk&quot;) using the web interface if you like.</source>
          <target state="translated">このコマンドは &quot;private&quot; という名前の新しいブランチを作成し(好きな名前を使っても構いません)、背景色を水色にします (&quot;#add8e8&quot;)。背景色を省略しても構いませんが、はっきりとした背景を持つことで、Timeline ディスプレイ上で &quot;trunk&quot; (パブリックブランチ)とブランチを見分けるのが簡単になります。プライベートブランチやパブリックブランチ(「トランク」)の背景色は、ウェブインターフェースを使って変更することができます。</target>
        </trans-unit>
        <trans-unit id="5db5e98e2fd20bba8ab658518e972deb34aab3ef" translate="yes" xml:space="preserve">
          <source>This command-line shell leaves unnamed parameters unbound, meaning that they will have a value of an SQL NULL, but named parameters might be assigned values. If there exists a TEMP table named &quot;sqlite_parameters&quot; with a schema like this:</source>
          <target state="translated">このコマンドラインシェルは、名前のないパラメータを解放し、SQL NULLの値を持つことを意味しますが、名前のあるパラメータには値が割り当てられるかもしれません。もし &quot;sqlite_parameters &quot;という名前のTEMPテーブルが存在していて、以下のようなスキーマを持っているとします。</target>
        </trans-unit>
        <trans-unit id="4c4b4e9517b3e559a4264bd38d883b4075b15dd6" translate="yes" xml:space="preserve">
          <source>This compile-time option affects the SQL &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator only and has no impact on the &lt;a href=&quot;c3ref/strlike&quot;&gt;sqlite3_strlike()&lt;/a&gt; C-language interface.</source>
          <target state="translated">このコンパイル時オプションはSQL &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;演算子にのみ影響し、&lt;a href=&quot;c3ref/strlike&quot;&gt;sqlite3_strlike（）&lt;/a&gt; C言語インターフェースには影響しません。</target>
        </trans-unit>
        <trans-unit id="6c67f3211a79226589052fa652c6121f10cd5b9d" translate="yes" xml:space="preserve">
          <source>This compile-time option causes the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator to always return False if either operand is a BLOB. The default behavior of &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; is that BLOB operands are cast to TEXT before the comparison is done.</source>
          <target state="translated">このコンパイル時オプションにより、いずれかのオペランドがBLOBの場合、&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;演算子は常にFalseを返します。&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;のデフォルトの動作では、比較が行われる前にBLOBオペランドがTEXTにキャストされます。</target>
        </trans-unit>
        <trans-unit id="b087b90d5f82c6cd11bb4d6150e1edc15e3c7080" translate="yes" xml:space="preserve">
          <source>This compile-time option changes the default setting of the &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;secure_delete pragma&lt;/a&gt;. When this option is not used, secure_delete defaults to off. When this option is present, secure_delete defaults to on.</source>
          <target state="translated">このコンパイル時オプションは、&lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;secure_deleteプラグマの&lt;/a&gt;デフォルト設定を変更します。このオプションを使用しない場合、secure_deleteのデフォルトはオフです。このオプションが存在する場合、secure_deleteはデフォルトでオンになります。</target>
        </trans-unit>
        <trans-unit id="ec3013abfee74643b8705338ad5e107049f5af6c" translate="yes" xml:space="preserve">
          <source>This compile-time option disables the &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;PRAGMA case_sensitive_like&lt;/a&gt; command.</source>
          <target state="translated">このコンパイル時オプションは、&lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;PRAGMA case_sensitive_like&lt;/a&gt;コマンドを無効にします。</target>
        </trans-unit>
        <trans-unit id="3400d01afcac3cfb7345138b17405acb7d27f932" translate="yes" xml:space="preserve">
          <source>This compile-time option enables SQLite to take advantage batch atomic write capabilities in the underlying filesystem. As of SQLite version 3.21.0 (2017-10-24) this is only supported on &lt;a href=&quot;https://en.wikipedia.org/wiki/F2FS&quot;&gt;F2FS&lt;/a&gt;. However, the interface is implemented generically, using &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; so the capability can be added to other filesystem times in the future. When this option is enabled, SQLite automatically detects that the underlying filesystem supports batch atomic writes, and when it does so it avoids writing the &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; for transaction control. This can make transactions over twice as fast, while simultaneously reducing wear on SSD storage devices.</source>
          <target state="translated">このコンパイル時オプションにより、SQLiteは、基礎となるファイルシステムのバッチアトミック書き込み機能を利用できます。SQLiteバージョン3.21.0（2017-10-24）以降、これはF2FSでのみサポートされ&lt;a href=&quot;https://en.wikipedia.org/wiki/F2FS&quot;&gt;ます&lt;/a&gt;。ただし、インターフェイスは一般的に実装され、&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;および&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;で&lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;を使用して、将来、機能を他のファイルシステムに追加できるようにします。このオプションを有効にすると、SQLiteは、基になるファイルシステムがバッチアトミック書き込みをサポートしていることを自動的に検出し、サポートしている場合は&lt;a href=&quot;lockingv3#rollback&quot;&gt;ロールバックジャーナルの&lt;/a&gt;書き込みを回避しますトランザクション制御用。これにより、2倍以上の速さでトランザクションを実行できると同時に、SSDストレージデバイスの摩耗を低減できます。</target>
        </trans-unit>
        <trans-unit id="2a47cb88e70b43c326cbb7cc659779aee23f98fe" translate="yes" xml:space="preserve">
          <source>This compile-time option enables the &lt;a href=&quot;stmt&quot;&gt;SQLITE_STMT virtual table&lt;/a&gt; logic.</source>
          <target state="translated">このコンパイル時オプションは、&lt;a href=&quot;stmt&quot;&gt;SQLITE_STMT仮想テーブル&lt;/a&gt;ロジックを有効にします。</target>
        </trans-unit>
        <trans-unit id="ff47a638485535b8abdf68c6579ec40497b2ae91" translate="yes" xml:space="preserve">
          <source>This compile-time option has been renamed to &lt;a href=&quot;compile#untestable&quot;&gt;SQLITE_UNTESTABLE&lt;/a&gt;.</source>
          <target state="translated">このコンパイル時オプションは&lt;a href=&quot;compile#untestable&quot;&gt;SQLITE_UNTESTABLEに名前&lt;/a&gt;が変更されました。</target>
        </trans-unit>
        <trans-unit id="e0b75f253921594adb213c37bae38c55286027e5" translate="yes" xml:space="preserve">
          <source>This compile-time option is deprecated and untested.</source>
          <target state="translated">このコンパイル時オプションは非推奨であり、テストされていません。</target>
        </trans-unit>
        <trans-unit id="3be0a309752742e7707ae2403c4dadee6c132ddc" translate="yes" xml:space="preserve">
          <source>This compile-time option is no longer used.</source>
          <target state="translated">このコンパイル時オプションはもはや使用されません。</target>
        </trans-unit>
        <trans-unit id="4333e0a432302d984fdf33eabb1d1ed8fc11d61a" translate="yes" xml:space="preserve">
          <source>This compile-time option makes SQLite run more efficiently when processing queries that use the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator, at the expense of breaking backwards compatibility. However, the backwards compatibility break may be only a technicality. There was a long-standing bug in the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; processing logic (see &lt;a href=&quot;https://www.sqlite.org/src/info/05f43be8fdda9f&quot;&gt;https://www.sqlite.org/src/info/05f43be8fdda9f&lt;/a&gt;) that caused it to misbehavior for BLOB operands and nobody observed that bug in nearly 10 years of active use. So for more users, it is probably safe to enable this compile-time option and thereby save a little CPU time on LIKE queries.</source>
          <target state="translated">このコンパイル時オプションにより、&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;演算子を使用するクエリを処理するときにSQLiteがより効率的に実行されますが、下位互換性が失われます。ただし、下位互換性の中断は技術的なものにすぎない場合があります。&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;処理ロジック（&lt;a href=&quot;https://www.sqlite.org/src/info/05f43be8fdda9f&quot;&gt;https://www.sqlite.org/src/info/05f43be8fdda9fを&lt;/a&gt;参照）に長年のバグがあり、BLOBオペランドの誤動作を引き起こし、約10年間のアクティブな使用でそのバグを誰も観察しなかった。したがって、より多くのユーザーにとって、このコンパイル時オプションを有効にして、LIKEクエリのCPU時間を少し節約することはおそらく安全です。</target>
        </trans-unit>
        <trans-unit id="65b9357f2e420dd3508c81b4ae3257d2786b19ca" translate="yes" xml:space="preserve">
          <source>This constraint arises from the fact that numbers do not sort in lexicographical order. For example: 9&amp;lt;10 but '9'&amp;gt;'10'.</source>
          <target state="translated">この制約は、数値が辞書式順序でソートされないという事実から生じます。例：9 &amp;lt;10が '9'&amp;gt; '10'。</target>
        </trans-unit>
        <trans-unit id="187432feb7a09e6addc8b4c1a243d9ef78920104" translate="yes" xml:space="preserve">
          <source>This design note considers the database to be a collection of objects. Each SQL table is a class. Each row is an instance of that class. There are, of course, other ways to interpret an SQL database schema, and the techniques described here work equally well under alternative interpretations, but an object-oriented view seems be more natural to most contemporary programmers.</source>
          <target state="translated">このデザインノートでは、データベースをオブジェクトの集合体と考えています。各SQLテーブルはクラスです。各行はそのクラスのインスタンスです。もちろん、SQLデータベースのスキーマを解釈する方法は他にもありますし、ここで説明した技術は他の解釈の下でも同じように機能しますが、ほとんどの現代のプログラマにとってはオブジェクト指向のビューの方が自然なようです。</target>
        </trans-unit>
        <trans-unit id="7f5cd63f8a1306fc33b54e6f33d75fb0c8f5824b" translate="yes" xml:space="preserve">
          <source>This document describes SQLite internals. The information provided here is not needed for routine application development using SQLite. This document is intended for people who want to delve more deeply into the internal operation of SQLite.</source>
          <target state="translated">このドキュメントでは、SQLite の内部について説明します。ここで提供される情報は、SQLite を使用した日常的なアプリケーション開発には必要ありません。このドキュメントは、SQLite の内部操作をより深く掘り下げたい方を対象としています。</target>
        </trans-unit>
        <trans-unit id="29000c12ac32a9037c669c50606cdb73ab6f60c1" translate="yes" xml:space="preserve">
          <source>This document describes and defines the on-disk database file format used by all releases of SQLite since version 3.0.0 (2004-06-18).</source>
          <target state="translated">この文書では、バージョン 3.0.0 (2004-06-18)以降のすべてのリリースの SQLite で使用されているディスク上のデータベースファイル形式について説明し、定義しています。</target>
        </trans-unit>
        <trans-unit id="dc53982e7fc871bc167dd841afd5d1fa7b1536a4" translate="yes" xml:space="preserve">
          <source>This document describes how to obtain the canonical source code for SQLite - the raw source files from which the amalgamation is built. See the &lt;a href=&quot;howtocompile&quot;&gt;How To Compile SQLite&lt;/a&gt; page for additional information on what to do with the canonical source code once it is obtained.</source>
          <target state="translated">このドキュメントでは、SQLiteの正規のソースコード（統合が構築される元のソースファイル）を取得する方法について説明します。正規のソースコードを取得した後の処理については、&lt;a href=&quot;howtocompile&quot;&gt;SQLiteのコンパイル方法の&lt;/a&gt;ページを参照してください。</target>
        </trans-unit>
        <trans-unit id="8cb17c7b427d4b622c77f47d250d842b7e4339f9" translate="yes" xml:space="preserve">
          <source>This document describes in detail the way that SQLite uses the API provided by the VFS adaptor component to solve the problems and implement the strategies enumerated above. It also specifies the assumptions made about the properties of the system that the VFS adaptor provides access to. For example, specific assumptions about the extent of data corruption that may occur if a power failure occurs while a database file is being updated are presented in section</source>
          <target state="translated">このドキュメントでは、SQLite が VFS アダプタコンポーネントが提供する API を使用して問題を解決し、上に列挙した戦略を実装する方法について詳細に説明します。また、VFS アダプタがアクセスを提供するシステムのプロパティについての仮定も指定しています。たとえば、データベースファイルの更新中に停電が発生した場合に発生する可能性のあるデータ破損の程度についての具体的な仮定は、次のセクションで説明します。</target>
        </trans-unit>
        <trans-unit id="7da4581d4d5128e1ce5220b57b58fd4271a11dba" translate="yes" xml:space="preserve">
          <source>This document describes incompatibilities that have occurred in SQLite prior to 2004. Since 2004, there have been enhancements to SQLite such that newer database files are unreadable by older versions of the SQLite library. But the most recent versions of the SQLite library should be able to read and write any older SQLite database file without any problems.</source>
          <target state="translated">このドキュメントでは、2004 年以前の SQLite で発生した非互換性について説明します。2004 年以降、SQLite の機能が強化され、新しいデータベースファイルは古いバージョンの SQLite ライブラリでは読めなくなりました。しかし、最新バージョンの SQLite ライブラリでは、古いバージョンの SQLite データベースファイルを問題なく読み書きすることができるはずです。</target>
        </trans-unit>
        <trans-unit id="522199e4ebe6e710a972b890a7a5a64190cc5d3b" translate="yes" xml:space="preserve">
          <source>This document describes low-level details on how &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; is implemented on unix and windows.</source>
          <target state="translated">このドキュメントでは、UNIXとWindowsで&lt;a href=&quot;wal&quot;&gt;WALモード&lt;/a&gt;がどのように実装されるかについて、低レベルの詳細を説明します。</target>
        </trans-unit>
        <trans-unit id="86876920b62069808dcd8a4f6cfa725666d13fe3" translate="yes" xml:space="preserve">
          <source>This document describes the architecture of the SQLite library. The information here is useful to those who want to understand or modify the inner workings of SQLite.</source>
          <target state="translated">このドキュメントでは、SQLite ライブラリのアーキテクチャについて説明します。ここに記載されている情報は、SQLite の内部の仕組みを理解したり、変更したりするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="4d320774e9898d3525e4d8d7e2967bd5937be4b0" translate="yes" xml:space="preserve">
          <source>This document describes the support for SQL foreign key constraints introduced in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;version 3.6.19&lt;/a&gt; (2009-10-14).</source>
          <target state="translated">このドキュメントでは、SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;バージョン3.6.19&lt;/a&gt;（2009-10-14）で導入されたSQL外部キー制約のサポートについて説明します。</target>
        </trans-unit>
        <trans-unit id="2bc5a2a4190725779b47fa8957802675b43bcdcd" translate="yes" xml:space="preserve">
          <source>This document does not contain a full description of the syntax used to create foreign key constraints in SQLite. This may be found as part of the documentation for the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement.</source>
          <target state="translated">このドキュメントには、SQLiteで外部キー制約を作成するために使用される構文の完全な説明は含まれていません。これは、&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;ステートメントのドキュメントの一部として記載されています。</target>
        </trans-unit>
        <trans-unit id="1a95f5bdc9ff03cc2aba9a9f1c4e965180076c32" translate="yes" xml:space="preserve">
          <source>This document does not specify the details of the interface that must be implemented by the VFS adaptor component, that is left to</source>
          <target state="translated">このドキュメントでは、VFS アダプタコンポーネントが実装しなければならないインタフェースの詳細は指定していません。</target>
        </trans-unit>
        <trans-unit id="4458da44ee2dc70541cbb9f7f722e55f2e9b165b" translate="yes" xml:space="preserve">
          <source>This document focuses on the NGQP. For a more general overview of the SQLite query planner that encompasses the entire history of SQLite, see the &quot;&lt;a href=&quot;optoverview&quot;&gt;The SQLite Query Optimizer Overview&lt;/a&gt;&quot; and &quot;&lt;a href=&quot;queryplanner&quot;&gt;How Indexes Work&lt;/a&gt;&quot; documents.</source>
          <target state="translated">このドキュメントでは、NGQPに焦点を当てています。SQLiteの履歴全体を網羅するSQLiteクエリプランナーのより一般的な概要については、「&lt;a href=&quot;optoverview&quot;&gt;SQLiteクエリオプティマイザーの概要&lt;/a&gt;」および「&lt;a href=&quot;queryplanner&quot;&gt;インデックスのしくみ&lt;/a&gt;」のドキュメントをご覧ください。</target>
        </trans-unit>
        <trans-unit id="da2a96113e96df4cba87ef0ebb6ecd70e207ec5c" translate="yes" xml:space="preserve">
          <source>This document gives an overview of the Tcl programming interface for SQLite.</source>
          <target state="translated">このドキュメントでは、SQLite用のTclプログラミングインターフェイスの概要を説明します。</target>
        </trans-unit>
        <trans-unit id="a5a4e1d46e6e2a3f39086d506303b41bc25dcc9a" translate="yes" xml:space="preserve">
          <source>This document is a quick introduction to the changes for SQLite 3.0 for users who are already familiar with SQLite version 2.8.</source>
          <target state="translated">このドキュメントは、すでに SQLite バージョン 2.8 に慣れ親しんでいるユーザーのために、SQLite 3.0 の変更点を簡単に紹介したものです。</target>
        </trans-unit>
        <trans-unit id="c1c02e760418d224f0c07cba5a70ec82e928ba41" translate="yes" xml:space="preserve">
          <source>This document is an introduction to the session extension. The details of the interface are in the separate &lt;a href=&quot;https://sqlite.org/session/intro.html&quot;&gt;Session Extension C-language Interface&lt;/a&gt; document.</source>
          <target state="translated">このドキュメントは、セッション拡張の概要です。インターフェースの詳細は、別の&lt;a href=&quot;https://sqlite.org/session/intro.html&quot;&gt;セッション拡張C言語インターフェースの&lt;/a&gt;ドキュメントに記載されています。</target>
        </trans-unit>
        <trans-unit id="3ff7ff01849be2d401b1d6230764460ab55eb57e" translate="yes" xml:space="preserve">
          <source>This document is concerned with the persistent state of the database file, and since the wal-index is a transient structure, no further information about the format of the wal-index will be provided here. Additional details on the format of the wal-index are contained in the separate &lt;a href=&quot;walformat#walidxfmt&quot;&gt;WAL-index File Format&lt;/a&gt; document.</source>
          <target state="translated">このドキュメントはデータベースファイルの永続的な状態に関するものであり、wal-indexは一時的な構造であるため、ここではwal-indexの形式に関する詳細情報は提供されません。wal-indexのフォーマットの詳細は、別の&lt;a href=&quot;walformat#walidxfmt&quot;&gt;WAL-index File Format&lt;/a&gt;ドキュメントに含まれています。</target>
        </trans-unit>
        <trans-unit id="ce4f9d4c36f7d70e8b9276d0825d097968bc414d" translate="yes" xml:space="preserve">
          <source>This document is created by a script which scans comments in the source code file sqlite3session.h.</source>
          <target state="translated">このドキュメントは、ソースコードファイルsqlite3session.hのコメントをスキャンするスクリプトによって作成されます。</target>
        </trans-unit>
        <trans-unit id="d12748856fa96aaf8fec02bb978ea061f37e25d7" translate="yes" xml:space="preserve">
          <source>This document is still sometimes used as a &quot;Code of Conduct&quot; on supplier registration forms. But it is not a Code of Conduct in the same sense that many communities mean a Code of Conduct. Rather, this document describes the ethical principles upon which SQLite is based. Another way to look at this document is as a succinct description of the SQLite Founder's idea of what it means to be &quot;virtuous&quot;.</source>
          <target state="translated">この文書は、今でもサプライヤー登録用紙に「行動規範」として使用されることがあります。しかし、多くのコミュニティが行動規範を意味するのと同じ意味での行動規範ではありません。むしろ、この文書は SQLite の基礎となる倫理的な原則を記述しています。別の見方をすれば、この文書は SQLite の創設者が考えた「徳のある」とは何かを簡潔に説明したものです。</target>
        </trans-unit>
        <trans-unit id="6ead8dcfb3bc7787acee358a9c3c6b55198ad643" translate="yes" xml:space="preserve">
          <source>This document proposes to use &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;fossil&lt;/a&gt;, but any other distributed software configuration management system such as &lt;a href=&quot;http://www.monotone.ca/&quot;&gt;monotone&lt;/a&gt; or &lt;a href=&quot;http://www.selenic.com/mercurial/wiki/&quot;&gt;mercurial&lt;/a&gt; (a.k.a. &quot;hg&quot;), or &lt;a href=&quot;http://www.git-scm.org/&quot;&gt;git&lt;/a&gt; could serve just as well. The concept will be the same, though the specifics of the procedure will vary.</source>
          <target state="translated">このドキュメントでは&lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;fossilの&lt;/a&gt;使用を提案していますが、&lt;a href=&quot;http://www.monotone.ca/&quot;&gt;monotone&lt;/a&gt;や&lt;a href=&quot;http://www.selenic.com/mercurial/wiki/&quot;&gt;mercurial&lt;/a&gt;（別名 &quot;hg&quot;）、&lt;a href=&quot;http://www.git-scm.org/&quot;&gt;git&lt;/a&gt;などの他の分散ソフトウェア構成管理システムも同様に機能します。手順の詳細は異なりますが、概念は同じです。</target>
        </trans-unit>
        <trans-unit id="98d1415d454d0b20f9e20df74b68698917685b9f" translate="yes" xml:space="preserve">
          <source>This document provides an overview of dynamic memory allocation within SQLite. The target audience is software engineers who are tuning their use of SQLite for peak performance in demanding environments. Nothing in this document is required knowledge for using SQLite. The default settings and configuration for SQLite will work well in most applications. However, the information contained in this document may be useful to engineers who are tuning SQLite to comply with special requirements or to run under unusual circumstances.</source>
          <target state="translated">このドキュメントでは、SQLite 内の動的メモリ割り当ての概要を説明します。対象者は、要求の厳しい環境で最高のパフォーマンスを発揮するために SQLite の使用を調整しているソフトウェアエンジニアです。このドキュメントでは、SQLite を使用するために必要な知識は何もありません。SQLiteのデフォルト設定と構成は、ほとんどのアプリケーションでうまく機能します。しかし、このドキュメントに含まれている情報は、特別な要件を満たすためにSQLiteをチューニングしたり、異常な状況下で動作させたりするエンジニアに役立つかもしれません。</target>
        </trans-unit>
        <trans-unit id="c06afae30b0b7293df04fe27c7c538132693e4c6" translate="yes" xml:space="preserve">
          <source>This document provides an overview of how the query planner and optimizer for SQLite works.</source>
          <target state="translated">このドキュメントでは、SQLite 用のクエリプランナとオプティマイザがどのように動作するかの概要を説明します。</target>
        </trans-unit>
        <trans-unit id="54a3569b4cf066b2b50e3e942ef2c48ddc1b1732" translate="yes" xml:space="preserve">
          <source>This document provides background information about how the SQLite query planner and query engine work. Programmers can use this information to help create better indexes, and provide hints to help the query planner when needed.</source>
          <target state="translated">このドキュメントでは、SQLite クエリプランナとクエリエンジンがどのように動作するかについての背景情報を提供します。プログラマはこの情報を使用して、より良いインデックスを作成したり、必要に応じてクエリプランナを助けるためのヒントを提供したりすることができます。</target>
        </trans-unit>
        <trans-unit id="db48c0715525eb5ade6fdd8bc0b1d41936f8012f" translate="yes" xml:space="preserve">
          <source>This document strives to highlight the principal differences between SQLite and other SQL implementations, as an aid to developers that are porting to or from SQLite or who are trying to build a system that works across multiple database engines.</source>
          <target state="translated">このドキュメントでは、SQLite と他の SQL 実装との主な違いを強調し、SQLite への移植や SQLite からの移植、あるいは複数のデータベースエンジンにまたがって動作するシステムを構築しようとしている開発者の助けとなるように努めています。</target>
        </trans-unit>
        <trans-unit id="499e5ba33e0583ef7d40d010da72b3c26c5f57b3" translate="yes" xml:space="preserve">
          <source>This document was originally called a &quot;Code of Conduct&quot; and was created (in a slightly different format) for the purpose of filling in a box on &quot;supplier registration&quot; forms submitted to the SQLite developers by various minor clients. However, we subsequently learned that &quot;Code of Conduct&quot; has a specific technical meaning within many software development communities, a meaning which was at odds with the intent of this document. Hence, this document is now renamed and replaced by a &lt;a href=&quot;codeofconduct&quot;&gt;Code of Conduct&lt;/a&gt; that does comply with the specific technical requirements was inserted in the place of the old name.</source>
          <target state="translated">このドキュメントは当初「行動規範」と呼ばれ、さまざまなマイナークライアントからSQLite開発者に提出された「サプライヤー登録」フォームのボックスに記入するために（少し異なる形式で）作成されました。ただし、その後、多くのソフトウェア開発コミュニティにおいて「行動規範」には特定の技術的な意味があることを知りました。この意味は、このドキュメントの意図とは矛盾していました。したがって、このドキュメントは名前が変更され、特定の技術要件に準拠する&lt;a href=&quot;codeofconduct&quot;&gt;行動規範に&lt;/a&gt;置き換えられ、古い名前の代わりに挿入されました。</target>
        </trans-unit>
        <trans-unit id="9f4b3397370025bf1fdba593094ae6486be0fecb" translate="yes" xml:space="preserve">
          <source>This document was originally created in early 2004 when SQLite version 2 was still in widespread use and was written to introduce the new concepts of SQLite version 3 to readers who were already familiar with SQLite version 2. But these days, most readers of this document have probably never seen SQLite version 2 and are only familiar with SQLite version 3. Nevertheless, this document continues to serve as an authoritative reference to how database file locking works in SQLite version 3.</source>
          <target state="translated">この文書は、SQLite バージョン 2 がまだ広く使われていた 2004 年初頭に作成されたもので、すでに SQLite バージョン 2 に慣れ親しんでいる読者に SQLite バージョン 3 の新しい概念を紹介するために書かれたものです。しかし最近では、この文書の読者のほとんどは SQLite バージョン 2 を見たことがなく、SQLite バージョン 3 にしか馴染みがないでしょう。それでも、この文書は SQLite バージョン 3 でデータベースファイルのロックがどのように機能するかについての権威あるリファレンスとしての役割を果たし続けています。</target>
        </trans-unit>
        <trans-unit id="efa34a5056d6c01d0548b0f2be11ce7b6109059b" translate="yes" xml:space="preserve">
          <source>This experimental &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; provides information about a single &lt;a href=&quot;fileformat2#btree&quot;&gt;B-tree&lt;/a&gt; in a database file, such as the depth, and estimated number of pages and number of entries, and so forth.</source>
          <target state="translated">この実験的な&lt;a href=&quot;vtab#tabfunc2&quot;&gt;テーブル値関数&lt;/a&gt;は、深さ、推定ページ数やエントリ数など、データベースファイル内の単一の&lt;a href=&quot;fileformat2#btree&quot;&gt;Bツリー&lt;/a&gt;に関する情報を提供します。</target>
        </trans-unit>
        <trans-unit id="0902999854d1422342b1343c7db1457520c25f82" translate="yes" xml:space="preserve">
          <source>This facility is provided for WinRT which does not have an OS mechanism for reading or changing the current working directory. The use of this pragma in any other context is discouraged and may be disallowed in future releases.</source>
          <target state="translated">この機能は、現在の作業ディレクトリを読み込んだり変更したりするためのOSのメカニズムを持たないWinRTのために提供されています。このプラグマを他のコンテキストで使用することは推奨されず、将来のリリースでは禁止されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="a16ab751fe0e625eef00360bec04f5c6e2724bea" translate="yes" xml:space="preserve">
          <source>This feature could be used to implement &lt;a href=&quot;https://en.wikipedia.org/wiki/Information_schema&quot;&gt;information schema&lt;/a&gt; by first creating a separate schema using</source>
          <target state="translated">この機能を使用して、最初に別のスキーマを作成して&lt;a href=&quot;https://en.wikipedia.org/wiki/Information_schema&quot;&gt;情報スキーマ&lt;/a&gt;を実装できます。</target>
        </trans-unit>
        <trans-unit id="bbc13030cdb5706fbe971e91e53cd50c5af469f0" translate="yes" xml:space="preserve">
          <source>This feature is experimental and is subject to change. Further documentation will become available if and when the table-valued functions for PRAGMAs feature becomes officially supported.</source>
          <target state="translated">この機能は実験的なものであり、変更される可能性があります。PRAGMAs のテーブル値関数が正式にサポートされるようになった場合には、さらなるドキュメントが提供される予定です。</target>
        </trans-unit>
        <trans-unit id="18abc550835bcdb0029b1a86390eaca991d2351b" translate="yes" xml:space="preserve">
          <source>This field contains a checksum value, calculated based on the contents of the journaled database page data (the previous field) and the values stored in the</source>
          <target state="translated">このフィールドにはチェックサム値が含まれており、仕訳データベースのページデータの内容(前のフィールド)と</target>
        </trans-unit>
        <trans-unit id="e3760b531cd8fa332f7ee70ed518883a43ad81f8" translate="yes" xml:space="preserve">
          <source>This field contains the original data for the page, exactly as it appeared in the database file before the</source>
          <target state="translated">このフィールドには、そのページの元のデータが含まれています。</target>
        </trans-unit>
        <trans-unit id="3ae121150e2dd424e68324ff08f7e0c6c1d0a2a0" translate="yes" xml:space="preserve">
          <source>This field holds a phonetic code derived from coalesce(k1,word). Letters that have similar sounds are mapped into the same symbol. For example, all vowels and vowel clusters become the single symbol &quot;A&quot;. And the letters &quot;p&quot;, &quot;b&quot;, &quot;f&quot;, and &quot;v&quot; all become &quot;B&quot;. All nasal sounds are represented as &quot;N&quot;. And so forth. The mapping is based on ideas found in Soundex, Metaphone, and other long-standing phonetic matching systems. This key can be generated by the function spellfix1_phonehash(X). Hence: k2 = spellfix1_phonehash(coalesce(k1,word))</source>
          <target state="translated">このフィールドは、coalesce(k1,word)から派生した音声コードを保持しています。似たような音を持つ文字は、同じ記号にマッピングされます。例えば、すべての母音と母音群は、単一の記号 &quot;A &quot;になります。また、&quot;p&quot;、&quot;b&quot;、&quot;f&quot;、&quot;v &quot;の文字はすべて &quot;B &quot;になります。すべての鼻音は「N」という記号になります。といった具合です。このマッピングは、SoundexやMetaphoneなどの長年の音韻照合システムに見られるアイデアに基づいています。このキーは、関数 spellfix1_phonehash(X)で生成できます。したがって、k2=spellfix1_phonehash(coalesce(k1,word))</target>
        </trans-unit>
        <trans-unit id="7981d385aa4b9ca4b4f9844539885d4afde0da8a" translate="yes" xml:space="preserve">
          <source>This field may contain either an integer or a text field consisting of two integers separated by a space character (unicode codepoint 0x20).</source>
          <target state="translated">このフィールドは、スペース文字(ユニコード・コードポイント0x20)で区切られた2つの整数またはテキストフィールドを含むことができます。</target>
        </trans-unit>
        <trans-unit id="de591efb54fdb80ffddf1b7c9525e6ab9978c95c" translate="yes" xml:space="preserve">
          <source>This field must be set one of integer values 0 and 8, or else to NULL.</source>
          <target state="translated">このフィールドは、0と8の整数値のいずれかを設定するか、NULLに設定しなければなりません。</target>
        </trans-unit>
        <trans-unit id="7e75b74f43def5b21dd19f54d176219e2332fba0" translate="yes" xml:space="preserve">
          <source>This field, the &lt;b&gt;database page count&lt;/b&gt;, is set to the number of pages that the</source>
          <target state="translated">このフィールドである&lt;b&gt;データベースのページ数&lt;/b&gt;は、</target>
        </trans-unit>
        <trans-unit id="4ce138fa916045f081e00c343e7762b51298df38" translate="yes" xml:space="preserve">
          <source>This field, the &lt;b&gt;locking page number&lt;/b&gt;, is always set to the page number of the database</source>
          <target state="translated">このフィールドである&lt;b&gt;ロッキングページ番号は&lt;/b&gt;、常にデータベースのページ番号に設定されます。</target>
        </trans-unit>
        <trans-unit id="825eef8a444b33cb8e93566d91167c3eabd02df8" translate="yes" xml:space="preserve">
          <source>This field, the &lt;b&gt;record count&lt;/b&gt;, is set to the number of</source>
          <target state="translated">このフィールドである&lt;b&gt;レコード数&lt;/b&gt;は、次の数に設定され&lt;b&gt;ます&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="f631e740c08280177f2a7f6f8390e6ab3758fda5" translate="yes" xml:space="preserve">
          <source>This field, the &lt;b&gt;sector size&lt;/b&gt;, is set to the</source>
          <target state="translated">このフィールド、&lt;b&gt;セクターサイズ&lt;/b&gt;は、</target>
        </trans-unit>
        <trans-unit id="caf63c1c58b9f87489297844a819efb8d6633a40" translate="yes" xml:space="preserve">
          <source>This flag causes comma-separators to be added to the output of %d and %i substitutions, between every 3 digits from the left. This can help humans to more easily discern the magnitude of large integer values. For example, the value 2147483647 would be rendered as &quot;2147483647&quot; using &quot;%d&quot; but would appear as &quot;2,147,483,647&quot; with &quot;%,d&quot;. This flag is a non-standard extension.</source>
          <target state="translated">このフラグにより、%d および %i 置換の出力に、左から 3 桁ごとにカンマ区切り文字が追加されます。これにより、人間が大きな整数値の大きさをより簡単に識別できるようになります。例えば、値 2147483647 は、&quot;%d&quot; を使用すると &quot;2147483647&quot; と表示されますが、&quot;%,d&quot; を使用すると &quot;2,147,483,647&quot; と表示されます。このフラグは非標準の拡張子です。</target>
        </trans-unit>
        <trans-unit id="a5b80382a268dfe85ecc58efaaccd407cc41e4b2" translate="yes" xml:space="preserve">
          <source>This function adds a set of changes to the session object that could be used to update the table in database zFrom (call this the &quot;from-table&quot;) so that its content is the same as the table attached to the session object (call this the &quot;to-table&quot;). Specifically:</source>
          <target state="translated">この関数は、データベースzFromのテーブル(これを &quot;from-table &quot;と呼びます)を更新するために使用できる一連の変更をセッションオブジェクトに追加し、その内容がセッションオブジェクトに接続されたテーブル(これを &quot;to-table &quot;と呼びます)と同じになるようにします。具体的には</target>
        </trans-unit>
        <trans-unit id="3b5d7e99038e4d5b072061176057f97dc299323e" translate="yes" xml:space="preserve">
          <source>This function and xPhraseNextColumn() are similar to the xPhraseFirst() and xPhraseNext() APIs described above. The difference is that instead of iterating through all instances of a phrase in the current row, these APIs are used to iterate through the set of columns in the current row that contain one or more instances of a specified phrase. For example:</source>
          <target state="translated">この関数と xPhraseNextColumn()は、上述の xPhraseFirst()および xPhraseNext()API に似ています。違いは、現在の行のすべてのフレーズのインスタンスを反復処理するのではなく、これらの API を使用して、指定されたフレーズの 1 つ以上のインスタンスを含む現在の行の列のセットを反復処理します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="80988b461d2df6302b49f4dceec8b27b005d6908" translate="yes" xml:space="preserve">
          <source>This function attempts to retrieve the text of column iCol of the current document. If successful, (*pz) is set to point to a buffer containing the text in utf-8 encoding, (*pn) is set to the size in bytes (not characters) of the buffer and SQLITE_OK is returned. Otherwise, if an error occurs, an SQLite error code is returned and the final values of (*pz) and (*pn) are undefined.</source>
          <target state="translated">この関数は、現在のドキュメントの iCol 列のテキストを取得しようとします。成功した場合、(*pz)は utf-8 エンコーディングのテキストを含むバッファを指すように設定され、(*pn)はバッファのバイト数(文字数ではなく)に設定され、SQLITE_OK が返されます。そうでなければ、エラーが発生した場合、SQLiteエラーコードが返され、(*pz)と(*pn)の最終値は未定義となります。</target>
        </trans-unit>
        <trans-unit id="28a6bb3de337284487682e360c8a725a543916e4" translate="yes" xml:space="preserve">
          <source>This function attempts to scan the WAL file associated with database zDb of database handle db and make all valid snapshots available to sqlite3_snapshot_open(). It is an error if there is already a read transaction open on the database, or if the database is not a WAL mode database.</source>
          <target state="translated">この関数は、データベースハンドルdbのデータベースzDbに関連付けられたWALファイルをスキャンし、すべての有効なスナップショットをsqlite3_snapshot_open()で利用可能にしようとします。既にデータベース上で開かれている読み取りトランザクションがある場合や、データベースがWALモードのデータベースではない場合はエラーとなります。</target>
        </trans-unit>
        <trans-unit id="27eaa9cd67b4a77bfd0fe868cf2e24b92591db2f" translate="yes" xml:space="preserve">
          <source>This function causes all database schemas to be read from disk and parsed, if that has not already been done, and returns an error if any errors are encountered while loading the schema.</source>
          <target state="translated">この関数は、すべてのデータベーススキーマをディスクから読み込み、まだ実行されていない場合は解析し、スキーマの読み込み中にエラーが発生した場合はエラーを返します。</target>
        </trans-unit>
        <trans-unit id="7d871089984a2a55cb6c89bf16fcd0bc4a023753" translate="yes" xml:space="preserve">
          <source>This function causes any pending database operation to abort and return at its earliest opportunity. This routine is typically called in response to a user action such as pressing &quot;Cancel&quot; or Ctrl-C where the user wants a long query operation to halt immediately.</source>
          <target state="translated">この関数は、保留中のデータベース操作を中止させ、最も早い機会に戻ります。このルーチンは通常、ユーザが &quot;Cancel &quot;や &quot;Ctrl-C &quot;を押した場合など、ユーザが長いクエリ操作を直ちに停止させたい場合に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="84f0a277d8eb36da2c14763cce01f3221d3f3be5" translate="yes" xml:space="preserve">
          <source>This function closes an open &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt;. The BLOB handle is closed unconditionally. Even if this routine returns an error code, the handle is still closed.</source>
          <target state="translated">この関数は、開いている&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOBハンドルを&lt;/a&gt;閉じます。BLOBハンドルは無条件に閉じられます。このルーチンがエラーコードを返した場合でも、ハンドルは閉じられたままです。</target>
        </trans-unit>
        <trans-unit id="c52c6ec750ee5ca8bf8f3568aa703ede60385a7a" translate="yes" xml:space="preserve">
          <source>This function closes an open &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt;. The BLOB handle is closed unconditionally. Even if this routine returns an error code, the handle is still closed.</source>
          <target state="translated">この関数は、開いている&lt;a href=&quot;blob&quot;&gt;BLOBハンドルを&lt;/a&gt;閉じます。BLOBハンドルは無条件に閉じられます。このルーチンがエラーコードを返した場合でも、ハンドルは閉じられたままです。</target>
        </trans-unit>
        <trans-unit id="dcb5cb2e9c08e0b9f3037428dbe4920c74c2b405" translate="yes" xml:space="preserve">
          <source>This function combines the two input changesets using an sqlite3_changegroup object. Calling it produces similar results as the following code fragment:</source>
          <target state="translated">この関数は、sqlite3_changegroupオブジェクトを使用して2つの入力チェンジセットを結合します。この関数を呼び出すと、以下のコードの一部と同様の結果が得られます。</target>
        </trans-unit>
        <trans-unit id="4624a9200d853f2e32a44b7a98a35021843efd43" translate="yes" xml:space="preserve">
          <source>This function does not change the order in which changes appear within the changeset. It merely reverses the sense of each individual change.</source>
          <target state="translated">この関数は、チェンジセット内での変更の出現順序を変更しません。それは単に個々の変更の意味を反転させるだけです。</target>
        </trans-unit>
        <trans-unit id="d7cbc42833b432d19d25054e50c1379caf39e23d" translate="yes" xml:space="preserve">
          <source>This function does not set the database handle error code or message returned by the &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; functions.</source>
          <target state="translated">この関数は、&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;および&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;関数によって返されるデータベースハンドルのエラーコードまたはメッセージを設定しません。</target>
        </trans-unit>
        <trans-unit id="2c015e6f1fde0378f350b940649e6bb977266a40" translate="yes" xml:space="preserve">
          <source>This function does not set the database handle error code or message returned by the &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; functions.</source>
          <target state="translated">この関数は、&lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;および&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;関数によって返されるデータベースハンドルのエラーコードまたはメッセージを設定しません。</target>
        </trans-unit>
        <trans-unit id="6303b7057e9914dac072c1b4a0b74b270e4dc698" translate="yes" xml:space="preserve">
          <source>This function fails with SQLITE_ERROR if any of the following are true:</source>
          <target state="translated">この関数は、以下のいずれかが真の場合、SQLITE_ERRORで失敗します。</target>
        </trans-unit>
        <trans-unit id="870ceb33e21de66e2ccc8a5ce1caa06026ee0a3c" translate="yes" xml:space="preserve">
          <source>This function is accessible to SQL statements via the &lt;a href=&quot;../lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid() SQL function&lt;/a&gt;.</source>
          <target state="translated">この関数は、&lt;a href=&quot;../lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid（）SQL関数を&lt;/a&gt;介してSQLステートメントにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="3ed24a06a5fab16f67d5f77a45744a9d31cdf2e0" translate="yes" xml:space="preserve">
          <source>This function is accessible to SQL statements via the &lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid() SQL function&lt;/a&gt;.</source>
          <target state="translated">この関数は、&lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid（）SQL関数を&lt;/a&gt;介してSQLステートメントにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="ba56f71e7eaf44d8bff350353ce98793aa844743" translate="yes" xml:space="preserve">
          <source>This function is expected to tokenize the nText byte string indicated by argument pText. pText may or may not be nul-terminated. The first argument passed to this function is a pointer to an Fts5Tokenizer object returned by an earlier call to xCreate().</source>
          <target state="translated">この関数は、引数 pText で示される nText バイト文字列をトークン化することが期待されます。この関数に渡される最初の引数は、以前の xCreate()の呼び出しで返された Fts5Tokenizer オブジェクトへのポインタです。</target>
        </trans-unit>
        <trans-unit id="c0f6fbfd19fbfc44b1560cfd2b05948b7fed7c50" translate="yes" xml:space="preserve">
          <source>This function is invoked to delete a tokenizer handle previously allocated using xCreate(). Fts5 guarantees that this function will be invoked exactly once for each successful call to xCreate().</source>
          <target state="translated">この関数は、xCreate()を使用して以前に割り当てられたトークンナイザハンドルを削除するために呼び出されます。Fts5 は、xCreate()の呼び出しが成功するたびに、この関数が一度だけ呼び出されることを保証します。</target>
        </trans-unit>
        <trans-unit id="fcde84651450f2b10b0843fe43cf87cdc47c8be9" translate="yes" xml:space="preserve">
          <source>This function is used to &quot;invert&quot; a changeset object. Applying an inverted changeset to a database reverses the effects of applying the uninverted changeset. Specifically:</source>
          <target state="translated">この関数は、チェンジセットオブジェクトを &quot;反転&quot; するために使用します。データベースに転置されたチェンジセットを適用すると、転置されていないチェンジセットを適用したときの効果が逆転します。具体的には</target>
        </trans-unit>
        <trans-unit id="29ae82377275c7b1f1384fc8e2d212e8da0789d4" translate="yes" xml:space="preserve">
          <source>This function is used to allocate and initialize a tokenizer instance. A tokenizer instance is required to actually tokenize text.</source>
          <target state="translated">この関数は、トーナイザーのインスタンスを割り当て、初期化するために使用します。実際にテキストをトークン化するにはトークン化インスタンスが必要です。</target>
        </trans-unit>
        <trans-unit id="24b74a85f4b47c195bc0b6fe21af9724e0d1ed94" translate="yes" xml:space="preserve">
          <source>This function is used to concatenate two changesets, A and B, into a single changeset. The result is a changeset equivalent to applying changeset A followed by changeset B.</source>
          <target state="translated">この関数は、2 つのチェンジセット A と B を 1 つのチェンジセットに連結するために使用されます。結果は、チェンジセットAを適用した後にチェンジセットBを適用したのと同等のチェンジセットとなります。</target>
        </trans-unit>
        <trans-unit id="69eb445f771165e9cf3bdc2eef0ebd4932045f16" translate="yes" xml:space="preserve">
          <source>This function is used to finalize an iterator allocated with &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;.</source>
          <target state="translated">この関数は、&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）で&lt;/a&gt;割り当てられたイテレータをファイナライズするために使用されます。</target>
        </trans-unit>
        <trans-unit id="b35815e34122016382887fcb96a49b58070b37da" translate="yes" xml:space="preserve">
          <source>This function is used to finalize an iterator allocated with &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;.</source>
          <target state="translated">この関数は、&lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）で&lt;/a&gt;割り当てられたイテレータをファイナライズするために使用されます。</target>
        </trans-unit>
        <trans-unit id="2cfec4fd8864b11036478634ce0c848102b439e0" translate="yes" xml:space="preserve">
          <source>This function is used to find which columns comprise the PRIMARY KEY of the table modified by the change that iterator pIter currently points to. If successful, *pabPK is set to point to an array of nCol entries, where nCol is the number of columns in the table. Elements of *pabPK are set to 0x01 if the corresponding column is part of the tables primary key, or 0x00 if it is not.</source>
          <target state="translated">この関数は、イテレータ pIter が現在指す変更によって変更されたテーブルの PRIMARY KEY を構成する列を見つけるために使用されます。成功した場合、*pabPK は nCol エントリの配列を指すように設定されます。pabPK の要素は、対応する列がテーブルの主キーの一部である場合は 0x01 に、そうでない場合は 0x00 に設定されます。</target>
        </trans-unit>
        <trans-unit id="e114c8bad40f12de287f68c473424a8e6e66648d" translate="yes" xml:space="preserve">
          <source>This function is used to move an existing &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; so that it points to a different row of the same database table. The new row is identified by the rowid value passed as the second argument. Only the row can be changed. The database, table and column on which the blob handle is open remain the same. Moving an existing &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; to a new row is faster than closing the existing handle and opening a new one.</source>
          <target state="translated">この関数は、同じデータベーステーブルの別の行を指すように既存の&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOBハンドル&lt;/a&gt;を移動するために使用されます。新しい行は、2番目の引数として渡されたROWID値によって識別されます。行のみ変更できます。blobハンドルが開いているデータベース、テーブル、および列は同じままです。既存の&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOBハンドル&lt;/a&gt;を新しい行に移動する方が、既存のハンドルを閉じて新しいハンドルを開くよりも高速です。</target>
        </trans-unit>
        <trans-unit id="308c798f0a295eb0c4645e5b7f42fbabbc544780" translate="yes" xml:space="preserve">
          <source>This function is used to move an existing &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; so that it points to a different row of the same database table. The new row is identified by the rowid value passed as the second argument. Only the row can be changed. The database, table and column on which the blob handle is open remain the same. Moving an existing &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; to a new row is faster than closing the existing handle and opening a new one.</source>
          <target state="translated">この関数は、同じデータベーステーブルの別の行を指すように既存の&lt;a href=&quot;blob&quot;&gt;BLOBハンドル&lt;/a&gt;を移動するために使用されます。新しい行は、2番目の引数として渡されたROWID値によって識別されます。行のみ変更できます。blobハンドルが開いているデータベース、テーブル、および列は同じままです。既存の&lt;a href=&quot;blob&quot;&gt;BLOBハンドル&lt;/a&gt;を新しい行に移動する方が、既存のハンドルを閉じて新しいハンドルを開くよりも高速です。</target>
        </trans-unit>
        <trans-unit id="4b885ede0001de9f5c638f038a437a23ced24dd6" translate="yes" xml:space="preserve">
          <source>This function is used to read data from an open &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; into a caller-supplied buffer. N bytes of data are copied into buffer Z from the open BLOB, starting at offset iOffset.</source>
          <target state="translated">この関数は、開いている&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOBハンドル&lt;/a&gt;から呼び出し元が提供するバッファーにデータを読み取るために使用されます。Nバイトのデータが、オフセットiOffsetから始まり、開いているBLOBからバッファーZにコピーされます。</target>
        </trans-unit>
        <trans-unit id="21272222209bb70a086675dada0f2b2f97f0f8e4" translate="yes" xml:space="preserve">
          <source>This function is used to read data from an open &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; into a caller-supplied buffer. N bytes of data are copied into buffer Z from the open BLOB, starting at offset iOffset.</source>
          <target state="translated">この関数は、開いている&lt;a href=&quot;blob&quot;&gt;BLOBハンドル&lt;/a&gt;から呼び出し元が提供するバッファーにデータを読み取るために使用されます。Nバイトのデータが、オフセットiOffsetから始まり、開いているBLOBからバッファーZにコピーされます。</target>
        </trans-unit>
        <trans-unit id="9f3667d662139e493e6cf3b56b1b782512c8bc44" translate="yes" xml:space="preserve">
          <source>This function is used to retrieve the total number of rows in the table. In other words, the same value that would be returned by:</source>
          <target state="translated">この関数は、テーブル内の行の総数を取得するために使用されます。言い換えれば、同じ値が返されるのと同じです。</target>
        </trans-unit>
        <trans-unit id="b651a758789810b674e3ae5146e089dc27672b54" translate="yes" xml:space="preserve">
          <source>This function is used to set, clear or query the session object indirect flag. If the second argument passed to this function is zero, then the indirect flag is cleared. If it is greater than zero, the indirect flag is set. Passing a value less than zero does not modify the current value of the indirect flag, and may be used to query the current state of the indirect flag for the specified session object.</source>
          <target state="translated">この関数は、セッションオブジェクトの間接フラグを設定、クリア、またはクエリするために使用されます。この関数に渡された第2引数が0の場合、間接フラグはクリアされます。ゼロよりも大きい場合、間接フラグが設定されます。ゼロ未満の値を渡しても間接フラグの現在の値は変更されず、指定されたセッションオブジェクトの間接フラグの現在の状態を問い合わせるために使用することができます。</target>
        </trans-unit>
        <trans-unit id="57a1761e9d0e1762347b4943de9494b5f2f5f8cc" translate="yes" xml:space="preserve">
          <source>This function is used to write data into an open &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; from a caller-supplied buffer. N bytes of data are copied from the buffer Z into the open BLOB, starting at offset iOffset.</source>
          <target state="translated">この関数は、呼び出し元が提供するバッファーから開いている&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOBハンドルに&lt;/a&gt;データを書き込むために使用されます。オフセットiOffsetから始まるNバイトのデータが、バッファーZからオープンBLOBにコピーされます。</target>
        </trans-unit>
        <trans-unit id="959745cc981e8eae46a52bb0e5894da3fa5cff9f" translate="yes" xml:space="preserve">
          <source>This function is used to write data into an open &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; from a caller-supplied buffer. N bytes of data are copied from the buffer Z into the open BLOB, starting at offset iOffset.</source>
          <target state="translated">この関数は、呼び出し元が提供するバッファーから開いている&lt;a href=&quot;blob&quot;&gt;BLOBハンドルに&lt;/a&gt;データを書き込むために使用されます。オフセットiOffsetから始まるNバイトのデータが、バッファーZからオープンBLOBにコピーされます。</target>
        </trans-unit>
        <trans-unit id="1483892d5daffd0f4eda8275dee22e2f701b626d" translate="yes" xml:space="preserve">
          <source>This function is used, along with type Fts5PhraseIter and the xPhraseNext method, to iterate through all instances of a single query phrase within the current row. This is the same information as is accessible via the xInstCount/xInst APIs. While the xInstCount/xInst APIs are more convenient to use, this API may be faster under some circumstances. To iterate through instances of phrase iPhrase, use the following code:</source>
          <target state="translated">この関数は、Fts5PhraseIter型およびxPhraseNextメソッドとともに、現在の行内の単一のクエリ・フレーズのすべてのインスタンスを反復処理するために使用されます。これは、xInstCount/xInst APIでアクセスできる情報と同じです。xInstCount/xInst APIの方が便利ですが、状況によってはこのAPIの方が高速になる場合があります。phrase iPhrase のインスタンスを反復処理するには、次のコードを使用します。</target>
        </trans-unit>
        <trans-unit id="2e540303404a447a74d8a0d678f9bad1c3c4058d" translate="yes" xml:space="preserve">
          <source>This function maps every page number into an integer between 0 and 8191 inclusive. The aHash field of each 32768-byte shm file unit maps P values into indexes of the aPgno field of the same unit as follows:</source>
          <target state="translated">この関数は、各ページ番号を 0 から 8191 までの整数にマップします。各 32768 バイトの shm ファイルユニットの aHash フィールドは、以下のように P の値を同じユニットの aPgno フィールドのインデックスにマッピングする。</target>
        </trans-unit>
        <trans-unit id="b474b368c95d2db3e02f8d968fb517ea9f808a38" translate="yes" xml:space="preserve">
          <source>This function may also return SQLITE_NOMEM. If it is called with the database handle in autocommit mode but fails for some other reason, whether or not a read transaction is opened on schema S is undefined.</source>
          <target state="translated">この関数は SQLITE_NOMEM を返すこともあります。データベースハンドルをオートコミットモードにした状態で呼び出されたが、何らかの理由で失敗した場合、スキーマS上で読み取りトランザクションが開かれているかどうかは未定義です。</target>
        </trans-unit>
        <trans-unit id="d107c7c4ed710ea3330eefcfd44db3b75a5ff363" translate="yes" xml:space="preserve">
          <source>This function may be called by either the &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implementation to configure various facets of the virtual table interface.</source>
          <target state="translated">この関数は、仮想テーブルインターフェースのさまざまなファセットを構成するために、&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;実装の&lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;または&lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;メソッドのいずれかによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="436450a55b61a947a304f65e4e9be131ade57dc9" translate="yes" xml:space="preserve">
          <source>This function may be called by either the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation to configure various facets of the virtual table interface.</source>
          <target state="translated">この関数は、仮想テーブルインターフェースのさまざまなファセットを構成するために、&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;実装の&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;または&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;メソッドのいずれかによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="892823d34401462a7936657244cacf73ba9d16a7" translate="yes" xml:space="preserve">
          <source>This function may be quite inefficient if used with an FTS5 table created with the &quot;columnsize=0&quot; option.</source>
          <target state="translated">この関数は、&quot;columnsize=0 &quot;オプションで作成されたFTS5テーブルで使用すると、非常に効率が悪いかもしれません。</target>
        </trans-unit>
        <trans-unit id="e3c728fb74daea7a42a0d0a89203b1fbf38464ae" translate="yes" xml:space="preserve">
          <source>This function may only be called from within a call to the &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">この関数は、&lt;a href=&quot;../vtab&quot;&gt;仮想テーブルの&lt;/a&gt;&lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;メソッドの呼び出し内からのみ呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="651e6e671ae629015a6ac3d4f4c461902dc827bb" translate="yes" xml:space="preserve">
          <source>This function may only be called from within a call to the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implementation for an INSERT or UPDATE operation. The value returned is one of &lt;a href=&quot;c_fail&quot;&gt;SQLITE_ROLLBACK&lt;/a&gt;, &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt;, &lt;a href=&quot;c_fail&quot;&gt;SQLITE_FAIL&lt;/a&gt;, &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;, or &lt;a href=&quot;c_fail&quot;&gt;SQLITE_REPLACE&lt;/a&gt;, according to the &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode of the SQL statement that triggered the call to the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of the &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">この関数は、INSERTまたはUPDATE操作の&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;実装の&lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;メソッドの呼び出し内からのみ呼び出すことができます。&lt;a href=&quot;../vtab&quot;&gt;仮想テーブルの&lt;/a&gt;&lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;メソッドの呼び出しをトリガーしたSQLステートメントの&lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;モードに応じて、&lt;a href=&quot;../rescode#abort&quot;&gt;返される&lt;/a&gt;値は&lt;a href=&quot;c_fail&quot;&gt;SQLITE_ROLLBACK&lt;/a&gt;、&lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt;、&lt;a href=&quot;c_fail&quot;&gt;SQLITE_FAIL&lt;/a&gt;、SQLITE_ABORT、または&lt;a href=&quot;c_fail&quot;&gt;SQLITE_REPLACEの&lt;/a&gt;いずれかです。</target>
        </trans-unit>
        <trans-unit id="a16a26f00d528f2a67fb084167cd62426f17fa64" translate="yes" xml:space="preserve">
          <source>This function may only be called from within a call to the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">この関数は、&lt;a href=&quot;vtab&quot;&gt;仮想テーブルの&lt;/a&gt;&lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;メソッドの呼び出し内からのみ呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="a48f675a9216b80779894ce906eb64bd5d832356" translate="yes" xml:space="preserve">
          <source>This function may only be called from within a call to the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation for an INSERT or UPDATE operation. The value returned is one of &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_ROLLBACK&lt;/a&gt;, &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_FAIL&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_REPLACE&lt;/a&gt;, according to the &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode of the SQL statement that triggered the call to the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of the &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">この関数は、INSERTまたはUPDATE操作の&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;実装の&lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;メソッドの呼び出し内からのみ呼び出すことができます。&lt;a href=&quot;vtab&quot;&gt;仮想テーブルの&lt;/a&gt;&lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;メソッドの呼び出しをトリガーしたSQLステートメントの&lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;モードに応じて、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;返される&lt;/a&gt;値は&lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_ROLLBACK&lt;/a&gt;、&lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt;、&lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_FAIL&lt;/a&gt;、SQLITE_ABORT、または&lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_REPLACEの&lt;/a&gt;いずれかです。</target>
        </trans-unit>
        <trans-unit id="9f4b868b197498e92e7be98a22186e8a9d0ec008" translate="yes" xml:space="preserve">
          <source>This function may only be called with an iterator passed to an SQLITE_CHANGESET_FOREIGN_KEY conflict handler callback. In this case it sets the output variable to the total number of known foreign key violations in the destination database and returns SQLITE_OK.</source>
          <target state="translated">この関数は、SQLITE_CHANGESET_FOREIGN_KEY 競合ハンドラコールバックに渡されたイテレータを使用してのみ呼び出すことができます。この場合、出力変数に出力先データベース内の既知の外部キー違反の総数を設定し、SQLITE_OK を返します。</target>
        </trans-unit>
        <trans-unit id="6aefcc013460f98a7eaca0c2faea39955530e82b" translate="yes" xml:space="preserve">
          <source>This function may only be used with iterators created by function &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. If it is called on an iterator passed to a conflict-handler callback by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, SQLITE_MISUSE is returned and the call has no effect.</source>
          <target state="translated">この関数は、関数&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;によって作成された反復子でのみ使用できます。&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt;によって競合ハンドラコールバックに渡されたイテレータで呼び出された場合、SQLITE_MISUSEが返され、呼び出しは無効になります。</target>
        </trans-unit>
        <trans-unit id="6b40997bef104535dd0852dc311c81d541b71952" translate="yes" xml:space="preserve">
          <source>This function may only be used with iterators created by function &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. If it is called on an iterator passed to a conflict-handler callback by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, SQLITE_MISUSE is returned and the call has no effect.</source>
          <target state="translated">この関数は、関数&lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;によって作成された反復子でのみ使用できます。&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt;によって競合ハンドラコールバックに渡されたイテレータで呼び出された場合、SQLITE_MISUSEが返され、呼び出しは無効になります。</target>
        </trans-unit>
        <trans-unit id="81dcfaa530f9bc3b0cf4ff6ac3dd711bd8249deb" translate="yes" xml:space="preserve">
          <source>This function may only be used with iterators created by the function &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. If it is called on an iterator passed to a conflict-handler callback by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, SQLITE_MISUSE is returned and the call has no effect.</source>
          <target state="translated">この関数は、関数&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;によって作成されたイテレーターでのみ使用できます。&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt;によって競合ハンドラーコールバックに渡されたイテレーターで呼び出された場合、SQLITE_MISUSEが返され、呼び出しは効果がありません。</target>
        </trans-unit>
        <trans-unit id="b2a7a3750664d2ff5967d620601e32e54729a198" translate="yes" xml:space="preserve">
          <source>This function may only be used with iterators created by the function &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. If it is called on an iterator passed to a conflict-handler callback by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, SQLITE_MISUSE is returned and the call has no effect.</source>
          <target state="translated">この関数は、関数&lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;によって作成されたイテレーターでのみ使用できます。&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt;によって競合ハンドラーコールバックに渡されたイテレーターで呼び出された場合、SQLITE_MISUSEが返され、呼び出しは効果がありません。</target>
        </trans-unit>
        <trans-unit id="cd3cebc479567b581aaea382b042cd658c5a6fd2" translate="yes" xml:space="preserve">
          <source>This function may only modify the contents of the BLOB; it is not possible to increase the size of a BLOB using this API. If offset iOffset is less than N bytes from the end of the BLOB, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is written. The size of the BLOB (and hence the maximum value of N+iOffset) can be determined using the &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface. If N or iOffset are less than zero &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is written.</source>
          <target state="translated">この関数はBLOBの内容のみを変更できます。このAPIを使用してBLOBのサイズを増やすことはできません。オフセットiOffsetがBLOBの最後からNバイト未満の場合、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;が返され、データは書き込まれません。BLOBのサイズ（およびN + iOffsetの最大値）は、&lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;インターフェースを使用して決定できます。NまたはiOffsetがゼロ未満の場合、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;が返され、データは書き込まれません。</target>
        </trans-unit>
        <trans-unit id="cc4415e783325c61d6eb500d3a2195a9814914cb" translate="yes" xml:space="preserve">
          <source>This function may only modify the contents of the BLOB; it is not possible to increase the size of a BLOB using this API. If offset iOffset is less than N bytes from the end of the BLOB, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is written. The size of the BLOB (and hence the maximum value of N+iOffset) can be determined using the &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface. If N or iOffset are less than zero &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is written.</source>
          <target state="translated">この関数はBLOBの内容のみを変更できます。このAPIを使用してBLOBのサイズを増やすことはできません。オフセットiOffsetがBLOBの最後からNバイト未満の場合、&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;が返され、データは書き込まれません。BLOBのサイズ（およびN + iOffsetの最大値）は、&lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;インターフェースを使用して決定できます。NまたはiOffsetがゼロ未満の場合、&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;が返され、データは書き込まれません。</target>
        </trans-unit>
        <trans-unit id="e611001e69d55801c25d56986ec39153bc754108" translate="yes" xml:space="preserve">
          <source>This function returns SQLITE_OK if successful, or an SQLite error code otherwise.</source>
          <target state="translated">この関数は、成功した場合は SQLITE_OK を、そうでない場合は SQLite エラーコードを返します。</target>
        </trans-unit>
        <trans-unit id="1c2517d3cf09b0cdb52fd7581d781f148fee8f8f" translate="yes" xml:space="preserve">
          <source>This function returns the number of rows modified, inserted or deleted by the most recently completed INSERT, UPDATE or DELETE statement on the database connection specified by the only parameter. Executing any other type of SQL statement does not modify the value returned by this function.</source>
          <target state="translated">この関数は、唯一のパラメータで指定されたデータベース接続上で最近完了したINSERT、UPDATE、またはDELETE文によって変更、挿入、または削除された行の数を返します。他のタイプのSQL文を実行しても、この関数が返す値は変更されません。</target>
        </trans-unit>
        <trans-unit id="6b76b4997f936492171845d7baebab3de049f79f" translate="yes" xml:space="preserve">
          <source>This function returns the total number of rows inserted, modified or deleted by all &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; statements completed since the database connection was opened, including those executed as part of trigger programs. Executing any other type of SQL statement does not affect the value returned by sqlite3_total_changes().</source>
          <target state="translated">この関数は、トリガープログラムの一部として実行されたものも含め、データベース接続が開かれてから完了したすべての&lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;、&lt;a href=&quot;../lang_update&quot;&gt;UPDATE、&lt;/a&gt;または&lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt;ステートメントによって挿入、変更、または削除された行の総数を返します。他のタイプのSQLステートメントを実行しても、sqlite3_total_changes（）から返される値には影響しません。</target>
        </trans-unit>
        <trans-unit id="adf4834644160b8bd2e8b37a1e591e556b1afb6a" translate="yes" xml:space="preserve">
          <source>This function returns the total number of rows inserted, modified or deleted by all &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements completed since the database connection was opened, including those executed as part of trigger programs. Executing any other type of SQL statement does not affect the value returned by sqlite3_total_changes().</source>
          <target state="translated">この関数は、トリガープログラムの一部として実行されたものも含め、データベース接続が開かれてから完了したすべての&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;、&lt;a href=&quot;lang_update&quot;&gt;UPDATE、&lt;/a&gt;または&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;ステートメントによって挿入、変更、または削除された行の総数を返します。他のタイプのSQLステートメントを実行しても、sqlite3_total_changes（）から返される値には影響しません。</target>
        </trans-unit>
        <trans-unit id="8213d08301f09db1801edcdcc6b6898d5bedde17" translate="yes" xml:space="preserve">
          <source>This function sets the database handle error code and message.</source>
          <target state="translated">この関数は、データベースハンドルのエラーコードとメッセージを設定します。</target>
        </trans-unit>
        <trans-unit id="dc027be02604df0d93fb0c7fd87bd8fb650c8db3" translate="yes" xml:space="preserve">
          <source>This function should only be called on iterators created using the &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt; function. If an application calls this function with an iterator passed to a conflict-handler by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; is immediately returned and the call has no effect.</source>
          <target state="translated">この関数は、&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;関数を使用して作成されたイテレータでのみ呼び出す必要があります。アプリケーションが&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt;によって競合ハンドラに渡されたイテレータを使用してこの関数を呼び出すと、&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;がすぐに返され、呼び出しは無効になります。</target>
        </trans-unit>
        <trans-unit id="2df7e3d1377d5e8297acef52974006d62b57703e" translate="yes" xml:space="preserve">
          <source>This function should only be called on iterators created using the &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt; function. If an application calls this function with an iterator passed to a conflict-handler by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; is immediately returned and the call has no effect.</source>
          <target state="translated">この関数は、&lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;関数を使用して作成されたイテレータでのみ呼び出す必要があります。アプリケーションが&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt;によって競合ハンドラに渡されたイテレータを使用してこの関数を呼び出すと、&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;がすぐに返され、呼び出しは無効になります。</target>
        </trans-unit>
        <trans-unit id="6644624c994928cadd1595cf7f165d3a9a2ca4f0" translate="yes" xml:space="preserve">
          <source>This function should only be used with iterator objects passed to a conflict-handler callback by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; with either &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; or &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;. If this function is called on any other iterator, &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; is returned and *ppValue is set to NULL.</source>
          <target state="translated">この関数は、&lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt;または&lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;を使用して&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt;によって競合ハンドラコールバックに渡されたイテレータオブジェクトでのみ使用する必要があります。この関数が他のイテレータで&lt;a href=&quot;rescode#misuse&quot;&gt;呼び出される&lt;/a&gt;と、SQLITE_MISUSEが返され、* ppValueがNULLに設定されます。</target>
        </trans-unit>
        <trans-unit id="548141af0246ca4eef33b575f89c5796207c5a05" translate="yes" xml:space="preserve">
          <source>This function should only be used with iterator objects passed to a conflict-handler callback by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; with either &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; or &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;. If this function is called on any other iterator, &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; is returned and *ppValue is set to NULL.</source>
          <target state="translated">この関数は、&lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt;または&lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;を使用して&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt;によって競合ハンドラコールバックに渡されたイテレータオブジェクトでのみ使用する必要があります。この関数が他のイテレータで&lt;a href=&quot;../rescode#misuse&quot;&gt;呼び出される&lt;/a&gt;と、SQLITE_MISUSEが返され、* ppValueがNULLに設定されます。</target>
        </trans-unit>
        <trans-unit id="aabca26792420e3dedde38828f3aa35b5f3a0612" translate="yes" xml:space="preserve">
          <source>This generates a file named &lt;b&gt;ex1.dump.gz&lt;/b&gt; that contains everything you need to reconstruct the database at a later time, or on another machine. To reconstruct the database, just type:</source>
          <target state="translated">これにより、後で、または別のマシンでデータベースを再構築するために必要なすべてを含む&lt;b&gt;ex1.dump.gz&lt;/b&gt;という名前のファイルが生成されます。データベースを再構築するには、次のように入力します。</target>
        </trans-unit>
        <trans-unit id="311cc4fab23f9723b1a4efe300a30ad45967a776" translate="yes" xml:space="preserve">
          <source>This graph is acyclic. And we assume that the mtime of every child checkin is no less than the mtime of all its parents. But unlike the earlier examples, this graph might have multiple paths of differing lengths between any two checkins.</source>
          <target state="translated">このグラフは非周期的です。そして、すべての子チェックインのmtimeは、すべての親のmtimeよりも小さくないと仮定します。しかし、先ほどの例とは異なり、このグラフは、任意の2つのチェックインの間に長さの異なる複数のパスを持つかもしれません。</target>
        </trans-unit>
        <trans-unit id="fa0e2bf6a1863b49e18b3cb7db1999e03d428ead" translate="yes" xml:space="preserve">
          <source>This historical version numbering system used a two-, three-, or four-number version: W.X, W.X.Y, or W.X.Y.Z. W was the file format: 1 or 2 or 3. X was the major version. Y was the minor version. Z was used only for patch releases to fix bugs.</source>
          <target state="translated">この歴史的なバージョンナンバリングシステムでは、2つ、3つ、または4つの番号のバージョンが使われていました。W.X、W.X.Y、またはW.X.Y.Zで、Wはファイル形式でした。Wはファイル形式で、1または2または3でした。X はメジャーバージョンでした。Y はマイナーバージョンでした。Z はバグ修正のためのパッチリリースにのみ使用されました。</target>
        </trans-unit>
        <trans-unit id="9f4676d0afd51e8fa37c9aa0283801b026a1b72b" translate="yes" xml:space="preserve">
          <source>This instruction causes the VM to halt.</source>
          <target state="translated">この命令により、VM は停止します。</target>
        </trans-unit>
        <trans-unit id="fdc444b74a87e964e8bcc2b42a370bbc5df69c15" translate="yes" xml:space="preserve">
          <source>This instruction makes a deep copy of the value. A duplicate is made of any string or blob constant. See also &lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt;.</source>
          <target state="translated">この命令は、値のディープコピーを作成します。複製は、文字列またはblob定数で構成されます。&lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="0dad5db056b0ca8e5a487c8ab6c8e6dc7e0f2672" translate="yes" xml:space="preserve">
          <source>This instruction makes a shallow copy of the value. If the value is a string or blob, then the copy is only a pointer to the original and hence if the original changes so will the copy. Worse, if the original is deallocated, the copy becomes invalid. Thus the program must guarantee that the original will not change during the lifetime of the copy. Use &lt;a href=&quot;opcode#Copy&quot;&gt;Copy&lt;/a&gt; to make a complete copy.</source>
          <target state="translated">この命令は、値の浅いコピーを作成します。値が文字列またはblobの場合、コピーはオリジナルへのポインタにすぎないため、オリジナルが変更された場合、コピーも変更されます。さらに悪いことに、オリジナルの割り当てが解除されると、コピーは無効になります。したがって、プログラムは、コピーの存続期間中にオリジナルが変更されないことを保証する必要があります。&lt;a href=&quot;opcode#Copy&quot;&gt;コピー&lt;/a&gt;を使用して完全なコピーを作成します。</target>
        </trans-unit>
        <trans-unit id="4df251f100bd98635ac20986854a4f9d3558bf05" translate="yes" xml:space="preserve">
          <source>This instruction only works for indices. The equivalent instruction for tables is &lt;a href=&quot;opcode#Insert&quot;&gt;Insert&lt;/a&gt;.</source>
          <target state="translated">この命令はインデックスに対してのみ機能します。テーブルと同等の命令は&lt;a href=&quot;opcode#Insert&quot;&gt;Insert&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="724c5d92359b2812711bd98fdbbd0ee48ff16933" translate="yes" xml:space="preserve">
          <source>This instruction only works on tables. The equivalent instruction for indices is &lt;a href=&quot;opcode#IdxInsert&quot;&gt;IdxInsert&lt;/a&gt;.</source>
          <target state="translated">この命令はテーブルでのみ機能します。インデックスと同等の命令は&lt;a href=&quot;opcode#IdxInsert&quot;&gt;IdxInsert&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="cc342418f5a1b7e3edc039b6124a9b746a56c8e5" translate="yes" xml:space="preserve">
          <source>This instruction throws an error if the memory cell is not initially an integer.</source>
          <target state="translated">この命令は、メモリセルが最初に整数でない場合にエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="b8399072455bb3b6ee2757655f5f7b2af59230c1" translate="yes" xml:space="preserve">
          <source>This instruction works like &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; except that it opens the cursor in read/write mode.</source>
          <target state="translated">この命令は、カーソルを読み取り/書き込みモードで開くことを除いて、&lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenReadと&lt;/a&gt;同様に機能します。</target>
        </trans-unit>
        <trans-unit id="849ae2eb4b736949542c4487e7de5222b770b0b6" translate="yes" xml:space="preserve">
          <source>This interface allows the size of various constructs to be limited on a connection by connection basis. The first parameter is the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; whose limit is to be set or queried. The second parameter is one of the &lt;a href=&quot;#SQLITE_LIMIT_ATTACHED&quot;&gt;limit categories&lt;/a&gt; that define a class of constructs to be size limited. The third parameter is the new limit for that construct.</source>
          <target state="translated">このインターフェースを使用すると、接続ごとにさまざまな構成体のサイズを制限できます。最初のパラメーターは、制限を設定または照会する&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;です。2番目のパラメーターは、サイズ制限される構成のクラスを定義する&lt;a href=&quot;#SQLITE_LIMIT_ATTACHED&quot;&gt;制限カテゴリーの&lt;/a&gt; 1つです。3番目のパラメーターは、その構成の新しい制限です。</target>
        </trans-unit>
        <trans-unit id="6687035e8ed6fa147345334bd3634ec9e7ff5918" translate="yes" xml:space="preserve">
          <source>This interface allows the size of various constructs to be limited on a connection by connection basis. The first parameter is the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; whose limit is to be set or queried. The second parameter is one of the &lt;a href=&quot;c_limit_attached&quot;&gt;limit categories&lt;/a&gt; that define a class of constructs to be size limited. The third parameter is the new limit for that construct.</source>
          <target state="translated">このインターフェースを使用すると、接続ごとにさまざまな構成体のサイズを制限できます。最初のパラメーターは、制限を設定または照会する&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;です。2番目のパラメーターは、サイズ制限される構成のクラスを定義する&lt;a href=&quot;c_limit_attached&quot;&gt;制限カテゴリーの&lt;/a&gt; 1つです。3番目のパラメーターは、その構成の新しい制限です。</target>
        </trans-unit>
        <trans-unit id="9256e21c25ccdf9db985fbb93738819f3d6d967d" translate="yes" xml:space="preserve">
          <source>This interface can be used by an application to make sure that the version of SQLite that it is linking against was compiled with the desired setting of the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; macro.</source>
          <target state="translated">アプリケーションはこのインターフェースを使用して、リンク先のSQLiteのバージョンが、&lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt;マクロの望ましい設定でコンパイルされていることを確認できます。</target>
        </trans-unit>
        <trans-unit id="32dc361b08c9c60505d75103bdc36b57584e9fcf" translate="yes" xml:space="preserve">
          <source>This interface can be used by an application to make sure that the version of SQLite that it is linking against was compiled with the desired setting of the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; macro.</source>
          <target state="translated">アプリケーションはこのインターフェースを使用して、リンク先のSQLiteのバージョンが、&lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt;マクロの望ましい設定でコンパイルされていることを確認できます。</target>
        </trans-unit>
        <trans-unit id="25ebb19095f954c7ae8a2ed499bdbfed83aadaa6" translate="yes" xml:space="preserve">
          <source>This interface can be used in combination &lt;a href=&quot;#sqlite3_next_stmt&quot;&gt;sqlite3_next_stmt()&lt;/a&gt; to locate all prepared statements associated with a database connection that are in need of being reset. This can be used, for example, in diagnostic routines to search for prepared statements that are holding a transaction open.</source>
          <target state="translated">このインターフェースを&lt;a href=&quot;#sqlite3_next_stmt&quot;&gt;sqlite3_next_stmt（）&lt;/a&gt;と組み合わせて使用​​して、リセットが必要なデータベース接続に関連付けられているすべての準備済みステートメントを見つけることができます。これは、たとえば診断ルーチンで、トランザクションを開いたままにしている準備されたステートメントを検索するために使用できます。</target>
        </trans-unit>
        <trans-unit id="d607ef96133a79a067aeb3d80e9e814bdda87569" translate="yes" xml:space="preserve">
          <source>This interface can be used in combination &lt;a href=&quot;next_stmt&quot;&gt;sqlite3_next_stmt()&lt;/a&gt; to locate all prepared statements associated with a database connection that are in need of being reset. This can be used, for example, in diagnostic routines to search for prepared statements that are holding a transaction open.</source>
          <target state="translated">このインターフェースを&lt;a href=&quot;next_stmt&quot;&gt;sqlite3_next_stmt（）&lt;/a&gt;と組み合わせて使用​​して、リセットが必要なデータベース接続に関連付けられているすべての準備済みステートメントを見つけることができます。これは、たとえば診断ルーチンで、トランザクションを開いたままにしている準備されたステートメントを検索するために使用できます。</target>
        </trans-unit>
        <trans-unit id="d798abdc7bea34806f312f897736975cfc379c7c" translate="yes" xml:space="preserve">
          <source>This interface causes the xEntryPoint() function to be invoked for each new &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that is created. The idea here is that xEntryPoint() is the entry point for a statically linked &lt;a href=&quot;loadext&quot;&gt;SQLite extension&lt;/a&gt; that is to be automatically loaded into all new database connections.</source>
          <target state="translated">このインターフェースにより、作成される新しい&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;ごとにxEntryPoint（）関数が呼び出されます。ここでの考え方は、xEntryPoint（）は、すべての新しいデータベース接続に自動的にロードされる静的にリンクされた&lt;a href=&quot;loadext&quot;&gt;SQLite拡張機能&lt;/a&gt;のエントリポイントであるということです。</target>
        </trans-unit>
        <trans-unit id="a18b59c5465abea2190a535937651aa6f4f67fb4" translate="yes" xml:space="preserve">
          <source>This interface causes the xEntryPoint() function to be invoked for each new &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that is created. The idea here is that xEntryPoint() is the entry point for a statically linked &lt;a href=&quot;../loadext&quot;&gt;SQLite extension&lt;/a&gt; that is to be automatically loaded into all new database connections.</source>
          <target state="translated">このインターフェースにより、作成される新しい&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;ごとにxEntryPoint（）関数が呼び出されます。ここでの考え方は、xEntryPoint（）は、すべての新しいデータベース接続に自動的にロードされる静的にリンクされた&lt;a href=&quot;../loadext&quot;&gt;SQLite拡張機能&lt;/a&gt;のエントリポイントであるということです。</target>
        </trans-unit>
        <trans-unit id="9786ef1ecb8c77d789971c3f849525761d5d38c2" translate="yes" xml:space="preserve">
          <source>This interface disables all automatic extensions previously registered using &lt;a href=&quot;#sqlite3_auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt;.</source>
          <target state="translated">このインターフェイスは、&lt;a href=&quot;#sqlite3_auto_extension&quot;&gt;sqlite3_auto_extension（）&lt;/a&gt;を使用して以前に登録されたすべての自動拡張機能を無効にします。</target>
        </trans-unit>
        <trans-unit id="2b9c0cbd974b30f6431515e1186211476ca08e78" translate="yes" xml:space="preserve">
          <source>This interface disables all automatic extensions previously registered using &lt;a href=&quot;auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt;.</source>
          <target state="translated">このインターフェイスは、&lt;a href=&quot;auto_extension&quot;&gt;sqlite3_auto_extension（）&lt;/a&gt;を使用して以前に登録されたすべての自動拡張機能を無効にします。</target>
        </trans-unit>
        <trans-unit id="8736a85b1a1bcc4c800c4ff7d229eb677c9e2f70" translate="yes" xml:space="preserve">
          <source>This interface enables or disables both the C-API &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; and the SQL function &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt;. Use &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;,..) to enable or disable only the C-API.</source>
          <target state="translated">このインターフェースは、C-API &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;とSQL関数&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension（）の&lt;/a&gt;両方を有効または無効にします。使用&lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;（デシベル、&lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;のみC-APIを有効または無効にするには、...）。</target>
        </trans-unit>
        <trans-unit id="ab1cdc93fe51f37fdae78544827ec5e365f941a3" translate="yes" xml:space="preserve">
          <source>This interface enables or disables both the C-API &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; and the SQL function &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt;. Use &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;,..) to enable or disable only the C-API.</source>
          <target state="translated">このインターフェースは、C-API &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;とSQL関数&lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension（）の&lt;/a&gt;両方を有効または無効にします。使用&lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;（デシベル、&lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;のみC-APIを有効または無効にするには、...）。</target>
        </trans-unit>
        <trans-unit id="737d038457ffc2dd705bbf7d3e67fd74eca8f49b" translate="yes" xml:space="preserve">
          <source>This interface is not for use by applications. It exists solely for verifying the correct operation of the SQLite library. Depending on how the SQLite library is compiled, this interface might not exist.</source>
          <target state="translated">このインターフェイスはアプリケーションが使用するためのものではありません。これは、SQLite ライブラリが正しく動作するかどうかを検証するためだけに存在します。SQLite ライブラリのコンパイル方法によっては、このインターフェイスが存在しない場合があります。</target>
        </trans-unit>
        <trans-unit id="dec74db456b76b7c855d3cb1358c040acad3ef05" translate="yes" xml:space="preserve">
          <source>This interface is only available if SQLite is compiled with the &lt;a href=&quot;../compile#enable_deserialize&quot;&gt;SQLITE_ENABLE_DESERIALIZE&lt;/a&gt; option.</source>
          <target state="translated">このインターフェースは、SQLiteが&lt;a href=&quot;../compile#enable_deserialize&quot;&gt;SQLITE_ENABLE_DESERIALIZE&lt;/a&gt;オプションを使用してコンパイルされている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="5c93fb0edc37eb4be652a31e1dc573b6923060cf" translate="yes" xml:space="preserve">
          <source>This interface is only available if SQLite is compiled with the &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; option.</source>
          <target state="translated">このインターフェースは、SQLiteが&lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt;オプションを指定してコンパイルされている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="17b0e4d3f046d7d363af1d959e76e0c4d41dedec" translate="yes" xml:space="preserve">
          <source>This interface is only available if SQLite is compiled with the &lt;a href=&quot;compile#enable_deserialize&quot;&gt;SQLITE_ENABLE_DESERIALIZE&lt;/a&gt; option.</source>
          <target state="translated">このインターフェースは、SQLiteが&lt;a href=&quot;compile#enable_deserialize&quot;&gt;SQLITE_ENABLE_DESERIALIZE&lt;/a&gt;オプションを使用してコンパイルされている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="f287e88e4474f60d3222ad14486a836ab2470ef3" translate="yes" xml:space="preserve">
          <source>This interface is only available if SQLite is compiled with the &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; option.</source>
          <target state="translated">このインターフェースは、SQLiteが&lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt;オプションを指定してコンパイルされている場合にのみ使用できます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
