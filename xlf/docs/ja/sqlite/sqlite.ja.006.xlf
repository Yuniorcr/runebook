<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="0059fb3429a6e57de6b5c01cc5ac92570ab99c32" translate="yes" xml:space="preserve">
          <source>Argument iVal must be greater than or equal to 0, and less than the number of columns in the table affected by the current change. Otherwise, &lt;a href=&quot;../rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt; is returned and *ppValue is set to NULL.</source>
          <target state="translated">引数iValは、0以上で、現在の変更の影響を受けるテーブル内の列数未満でなければなりません。それ以外の場合、&lt;a href=&quot;../rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt;が返され、* ppValueがNULLに設定されます。</target>
        </trans-unit>
        <trans-unit id="12689143ab00ad889ba38fb7f63c86273b0da663" translate="yes" xml:space="preserve">
          <source>Argument iVal must be greater than or equal to 0, and less than the number of columns in the table affected by the current change. Otherwise, &lt;a href=&quot;rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt; is returned and *ppValue is set to NULL.</source>
          <target state="translated">引数iValは、0以上で、現在の変更の影響を受けるテーブル内の列数未満でなければなりません。それ以外の場合、&lt;a href=&quot;rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt;が返され、* ppValueがNULLに設定されます。</target>
        </trans-unit>
        <trans-unit id="71b5b8ce6122da2fb2f466eddd7275074f8cc26d" translate="yes" xml:space="preserve">
          <source>Argument pIn must point to a buffer containing a changeset nIn bytes in size. This function allocates and populates a buffer with a copy of the changeset rebased according to the configuration of the rebaser object passed as the first argument. If successful, (*ppOut) is set to point to the new buffer containing the rebased changeset and (*pnOut) to its size in bytes and SQLITE_OK returned. It is the responsibility of the caller to eventually free the new buffer using sqlite3_free(). Otherwise, if an error occurs, (*ppOut) and (*pnOut) are set to zero and an SQLite error code returned.</source>
          <target state="translated">引数 pIn は、サイズ nIn バイトのチェンジセットを含むバッファを指す必要があります。この関数は、最初の引数として渡されたリベーザオブジェクトの設定に従って、リベースされたチェンジセットのコピーを含むバッファを割り当て、生成します。成功した場合、(*ppOut)はリベースされたチェンジセットを含む新しいバッファを指すように設定され、(*pnOut)はバイト単位のサイズに設定され、SQLITE_OKが返されます。最終的にsqlite3_free()を使って新しいバッファを解放するのは呼び出し元の責任です。そうでなければ、エラーが発生した場合、(*ppOut)と(*pnOut)はゼロに設定され、SQLiteエラーコードが返されます。</target>
        </trans-unit>
        <trans-unit id="1502f4d9bcf958ec2d3f9df8d5434c6f3fb95622" translate="yes" xml:space="preserve">
          <source>Argument pIn must point to a buffer containing a changeset nIn bytes in size. This function allocates and populates a buffer with a copy of the changeset rebased rebased according to the configuration of the rebaser object passed as the first argument. If successful, (*ppOut) is set to point to the new buffer containing the rebased changeset and (*pnOut) to its size in bytes and SQLITE_OK returned. It is the responsibility of the caller to eventually free the new buffer using sqlite3_free(). Otherwise, if an error occurs, (*ppOut) and (*pnOut) are set to zero and an SQLite error code returned.</source>
          <target state="translated">引数 pIn は、サイズが nIn バイトのチェンジセットを含むバッファを指す必要があります。この関数は、第1引数として渡されたリベーザオブジェクトの設定に従って、リベースされたチェンジセットのコピーを含むバッファを割り当て、ポップします。成功した場合、(*ppOut)はリベースされたチェンジセットを含む新しいバッファを指すように設定され、(*pnOut)はバイト単位のサイズに設定され、SQLITE_OKが返されます。最終的にsqlite3_free()を使って新しいバッファを解放するのは呼び出し元の責任です。そうでなければ、エラーが発生した場合、(*ppOut)と(*pnOut)はゼロに設定され、SQLiteエラーコードが返されます。</target>
        </trans-unit>
        <trans-unit id="3273cfe93e49705347b0b90c1dbaf9e32a834424" translate="yes" xml:space="preserve">
          <source>Argument zFromDb must be the name of a database (&quot;main&quot;, &quot;temp&quot; etc.) attached to the same database handle as the session object that contains a table compatible with the table attached to the session by this function. A table is considered compatible if it:</source>
          <target state="translated">引数 zFromDb は、セッションオブジェクトと同じデータベースハンドルに接続されたデータベース (&quot;main&quot;,&quot;temp&quot; など)の名前でなければなりません。テーブルが互換性のあるものであれば互換性があるとみなされます。</target>
        </trans-unit>
        <trans-unit id="c2dd08aa3192624f9fd5e4d0f584709c36b430c5" translate="yes" xml:space="preserve">
          <source>Arguments on the virtual table name are matched to &lt;a href=&quot;vtab#hiddencol&quot;&gt;hidden columns&lt;/a&gt; in order. The number of arguments can be less than the number of hidden columns, in which case the latter hidden columns are unconstrained. However, an error results if there are more arguments than there are hidden columns in the virtual table.</source>
          <target state="translated">仮想テーブル名の引数は、&lt;a href=&quot;vtab#hiddencol&quot;&gt;非表示の列&lt;/a&gt;と順番に照合されます。引数の数は非表示の列の数より少なくすることができます。その場合、後者の非表示の列は制約されません。ただし、仮想テーブルに非表示の列よりも引数が多い場合、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="90539d8182e17636548ae12105ee212ec9b16743" translate="yes" xml:space="preserve">
          <source>As SQLite developers edit the SQLite source code, they run the &lt;a href=&quot;https://sqlite.org/src/file/tool/speed-check.sh&quot;&gt;speed-check.sh&lt;/a&gt; shell script to track the performance impact of changes. This script compiles the speedtest1.c program, runs it under cachegrind, processes the cachegrind output using the &lt;a href=&quot;https://sqlite.org/src/file/tool/cg_anno.tcl&quot;&gt;cg_anno.tcl&lt;/a&gt; TCL script, then saves the results in a series of text files. Typical output from the speed-check.sh script looks like this:</source>
          <target state="translated">SQLite開発者は、SQLiteソースコードを編集するときに、&lt;a href=&quot;https://sqlite.org/src/file/tool/speed-check.sh&quot;&gt;speed-check.sh&lt;/a&gt;シェルスクリプトを実行して、変更によるパフォーマンスへの影響を追跡します。このスクリプトは、speedtest1.cプログラムをコンパイルし、cachegrindの下で実行し、&lt;a href=&quot;https://sqlite.org/src/file/tool/cg_anno.tcl&quot;&gt;cg_anno.tcl&lt;/a&gt; TCLスクリプトを使用してcachegrind出力を処理し、結果を一連のテキストファイルに保存します。speed-check.shスクリプトの一般的な出力は次のようになります。</target>
        </trans-unit>
        <trans-unit id="7ed7acd0a6e6b88f39315ac5d476eef951a2dd64" translate="yes" xml:space="preserve">
          <source>As a REAL value that is the fractional &lt;a href=&quot;https://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day number&lt;/a&gt;.</source>
          <target state="translated">分数の&lt;a href=&quot;https://en.wikipedia.org/wiki/Julian_day&quot;&gt;ユリウス日で&lt;/a&gt;あるREAL値として。</target>
        </trans-unit>
        <trans-unit id="a4eeeee2e0c94cffee5c99d0db2b5529b4ec1659" translate="yes" xml:space="preserve">
          <source>As a TEXT string in the ISO-8601 format. Example: '2018-04-02 12:13:46'.</source>
          <target state="translated">ISO-8601形式のTEXT文字列として。例:'2018-04-02 12:13:46'。</target>
        </trans-unit>
        <trans-unit id="e71c00fe61fb07ca9e09493bb8ec226ec4260341" translate="yes" xml:space="preserve">
          <source>As a TEXT string in the ISO-8610 format. Example: '2018-04-02 12:13:46'.</source>
          <target state="translated">ISO-8610形式のTEXT文字列として。例:'2018-04-02 12:13:46'。</target>
        </trans-unit>
        <trans-unit id="1f5eb53c0fa9975ea0940d4a4405ff35765d1d45" translate="yes" xml:space="preserve">
          <source>As a performance optimization, reduce actions in the Lemon input grammar are allowed to contain comments of the form &quot;/*A-overwrites-Z*/&quot; to indicate that the semantic value &quot;A&quot; on the right-hand side of the rule is allowed to directly overwrite the semantic value &quot;Z&quot; on the left-hand side. This simple optimization reduces the number of stack operations in the push-down automaton used to parse the input grammar, and thus improve performance of the parser. It also makes the generated code a little smaller.</source>
          <target state="translated">パフォーマンスの最適化として、Lemonの入力文法のリデュースアクションは、ルールの右側の意味値 &quot;A &quot;が左側の意味値 &quot;Z &quot;を直接上書きすることを示すために、&quot;/*A-overwrites-Z*/&quot;という形式のコメントを含むことが許可されています。この単純な最適化により、入力文法を解析するために使用されるプッシュダウンオートマトンのスタック操作の数が減り、パーサの性能が向上します。また、生成されるコードも少し小さくなります。</target>
        </trans-unit>
        <trans-unit id="7bcc1829db91ffdb7536f92aca2feacdc8bcb274" translate="yes" xml:space="preserve">
          <source>As an FTS5 bareword that is not &quot;AND&quot;, &quot;OR&quot; or &quot;NOT&quot; (case sensitive). An FTS5 bareword is a string of one or more consecutive characters that are all either:</source>
          <target state="translated">AND」、「OR」または「NOT」(大文字小文字を区別する)ではないFTS5ベアワードとして。FTS5のベアワードは、1つ以上の連続した文字の文字列で、すべてがどちらかである。</target>
        </trans-unit>
        <trans-unit id="3f6cab6c41155dd3c9ab5be0d8403065e3d7dbaf" translate="yes" xml:space="preserve">
          <source>As an INTEGER number of seconds since 1970 (also known as &quot;unix time&quot;).</source>
          <target state="translated">1970年以降のINTEGER秒数として(「ユニックスタイム」としても知られています)。</target>
        </trans-unit>
        <trans-unit id="32bbd071581bca01328b9dfe1b573f6b34f404d8" translate="yes" xml:space="preserve">
          <source>As an alternative to step 3 above, the transaction may be rolled back. Transaction rollback is described in section</source>
          <target state="translated">前記ステップ3の代替として、トランザクションをロールバックしてもよい。トランザクションのロールバックについては</target>
        </trans-unit>
        <trans-unit id="71c1a7847b731be97050a398f7845485ca21aaa1" translate="yes" xml:space="preserve">
          <source>As an example of how UPDATE-FROM can be useful, suppose you have a point-of-sale application that accumulates purchases in the SALES table. At the end of the day, you want to adjust the INVENTORY table according to the daily sales. To do this, you can run an UPDATE against the INVENTORY table that adjusts the quantity by the aggregated sales for the day. The statement would look like this:</source>
          <target state="translated">UPDATE-ROMがどのように役立つかの例として、SALESテーブルに購入品を蓄積するPOSアプリケーションがあるとします。一日の終わりに、毎日の売上に応じてINVENTORYテーブルを調整したいとします。これを行うには、INVENTORYテーブルに対してUPDATEを実行して、その日の集計された売上によって数量を調整します。ステートメントは次のようになります。</target>
        </trans-unit>
        <trans-unit id="131746c3b1aff392f599c85628677c24f8811860" translate="yes" xml:space="preserve">
          <source>As an example of the result table format, suppose a query result is as follows:</source>
          <target state="translated">結果テーブルの形式の例として、クエリ結果が以下のようになっているとします。</target>
        </trans-unit>
        <trans-unit id="592d95d98cfd4f715eed1be5091215e09168934a" translate="yes" xml:space="preserve">
          <source>As an example, consider a virtual table implementation that provides read-only access to existing comma-separated-value (CSV) files on disk. There is no backing store that needs to be created or initialized for such a virtual table (since the CSV files already exist on disk) so the xCreate and xConnect methods will be identical for that module.</source>
          <target state="translated">例として、ディスク上の既存のカンマ区切り値(CSV)ファイルへの読み取り専用アクセスを提供する仮想テーブルの実装を考えてみましょう。このような仮想テーブルのために作成または初期化する必要のあるバッキングストアはありません(CSV ファイルはすでにディスク上に存在するため)。</target>
        </trans-unit>
        <trans-unit id="0e3486a0e62ced4a8499838d1b8b7393bbcb9f1f" translate="yes" xml:space="preserve">
          <source>As an example, consider creating a two-dimensional R*Tree index for use in spatial queries:</source>
          <target state="translated">例として、空間クエリで使用するための 2 次元 R*Tree インデックスを作成することを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="1f3a827b13a126faa4b33b0ce651746d14a8fc48" translate="yes" xml:space="preserve">
          <source>As an example, consider the following query:</source>
          <target state="translated">例として、次のようなクエリを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="22e02419a6c1aa60126918f747f9d30c0add3ddc" translate="yes" xml:space="preserve">
          <source>As an example, consider the following table that tracks dollar-amount changes on various &quot;accounts&quot;:</source>
          <target state="translated">例として、さまざまな「口座」のドル円の変化を追跡する次の表を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="9685f258b372a754415995a52cb6b9f9c3a80f7a" translate="yes" xml:space="preserve">
          <source>As an example, suppose someone (perhaps a customer) asks you: &quot;What ever became of that 'prefer-coroutine-sort-subquery' branch from two years ago?&quot; You might try to answer the query by consulting the history in your version control system, thusly:</source>
          <target state="translated">例として、誰か(おそらく顧客)があなたに尋ねるとします。&quot;これまでに2年前からその'prefer-coroutin-sort-subquery'ブランチの何になったのですか?&quot; あなたは、このように、バージョン管理システムの履歴を参照してクエリに答えようとするかもしれません。</target>
        </trans-unit>
        <trans-unit id="34ff54cf6acce621207ec9ac9f6485fedf9ef893" translate="yes" xml:space="preserve">
          <source>As an example, the following graphic:</source>
          <target state="translated">例として、以下のようなグラフィックがあります。</target>
        </trans-unit>
        <trans-unit id="d8a7709446ce5823dd6ac2917092a6664f0dbd82" translate="yes" xml:space="preserve">
          <source>As an example, the following setup causes TCL to throw an error if an SQL statement contains an parameter that does not match any global TCL variable:</source>
          <target state="translated">例として、以下の設定では、SQL文にグローバル変数と一致しないパラメータが含まれている場合、TCLはエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="0ed757795f16facadb1fc50b83304333bb04670f" translate="yes" xml:space="preserve">
          <source>As an example, the following table show the relative sizes for an SQLite Archive, a ZIP Archive, and a Tarball of the 1,743 files in the SQLite 3.22.0 source tree:</source>
          <target state="translated">例として、次の表は、SQLite 3.22.0 のソースツリーにある 1,743 個のファイルのうち、SQLite アーカイブ、ZIP アーカイブ、および Tarball の相対的なサイズを示しています。</target>
        </trans-unit>
        <trans-unit id="9d15dfd61e0635160b8312b26c2789af818a9391" translate="yes" xml:space="preserve">
          <source>As an ordinary SQLite table, &quot;wordcount&quot; is implemented as two separate B-Trees. The main table uses the hidden rowid value as the key and stores the &quot;word&quot; and &quot;cnt&quot; columns as data. The &quot;TEXT PRIMARY KEY&quot; phrase of the CREATE TABLE statement causes the creation of an &lt;a href=&quot;lang_createindex#uniqueidx&quot;&gt;unique index&lt;/a&gt; on the &quot;word&quot; column. This index is a separate B-Tree that uses &quot;word&quot; and the &quot;rowid&quot; as the key and stores no data at all. Note that the complete text of every &quot;word&quot; is stored twice: once in the main table and again in the index.</source>
          <target state="translated">通常のSQLiteテーブルと同様に、「wordcount」は2つの個別のBツリーとして実装されます。メインテーブルは、非表示のROWID値をキーとして使用し、「word」列と「cnt」列をデータとして格納します。 CREATE TABLEステートメントの「TEXT PRIMARY KEY」句を使用すると、「word」列に&lt;a href=&quot;lang_createindex#uniqueidx&quot;&gt;一意のインデックスが作成さ&lt;/a&gt;れます。このインデックスは、「単語」と「ROWID」をキーとして使用し、データをまったく格納しない別個のBツリーです。すべての「単語」の完全なテキストは2回保存されます。1回はメインテーブルに、もう1回はインデックスに保存されます。</target>
        </trans-unit>
        <trans-unit id="8276f7702973f7730b88b6137faf5d630b77f015" translate="yes" xml:space="preserve">
          <source>As before, SQLite does single binary search for the range of rows in the covering index that satisfy the WHERE clause, the scans that range from top to bottom to get the desired results. The rows that satisfy the WHERE clause are guaranteed to be adjacent since the WHERE clause is an equality constraint on the left-most column of the index. And by scanning the matching index rows from top to bottom, the output is guaranteed to be ordered by state since the state column is the very next column to the right of the fruit column. And so the resulting query is very efficient.</source>
          <target state="translated">以前と同様に、SQLite は、WHERE 節を満たすカバーリング・インデックス内の行の範囲をシングル・バイナリー検索し、目的の結果を得るために上から下までの範囲をスキャンします。WHERE 句を満たす行は、WHERE 句がインデックスの左端の列に対する等質性制約であるため、隣接していることが保証されます。そして、一致するインデックスの行を上から下へとスキャンすることで、出力は状態順であることが保証されます。そのため、結果として得られるクエリは非常に効率的です。</target>
        </trans-unit>
        <trans-unit id="15882cefbefb220ce1658791117147edd8cba359" translate="yes" xml:space="preserve">
          <source>As before, the Column instruction uses cursor P1 and pushes the data record in column P2 (1, column &quot;two&quot;) onto the stack. The Integer instruction pushes the value 50 onto the top of the stack. After these two instructions the stack looks like:</source>
          <target state="translated">前と同様に、Column命令はカーソルP1を使用して、P2列目(1、列 &quot;2&quot;)のデータレコードをスタックにプッシュします。整数命令は、値50をスタックの先頭に押し出します。この2つの命令の後のスタックは次のようになります。</target>
        </trans-unit>
        <trans-unit id="6c0707574912e68bc0443d44af5e83d6ee57452b" translate="yes" xml:space="preserve">
          <source>As before, the second insert on the left will fail because the comparison will convert both strings into floating-point number first and the only difference in the strings is in the 20-th digit which exceeds the resolution of a 64-bit float. In contrast, the second insert on the right will work because in that case, the numbers being inserted are strings and are compared using memcmp().</source>
          <target state="translated">前述のように、左の 2 番目の挿入は失敗します。なぜなら、比較は最初に両方の文字列を浮動小数点数に変換し、文字列の違いは 20 番目の桁だけで、これは 64 ビットの float の解像度を超えているからです。これに対して、右の2回目の挿入では、挿入されている数値は文字列であり、memcmp()を使用して比較されるため、うまくいきます。</target>
        </trans-unit>
        <trans-unit id="021a9e62497cd6d1534e29c131c8485644cff8ee" translate="yes" xml:space="preserve">
          <source>As can be seen above, a single run of multitest.tcl invokes th3make dozens of times and takes between 12 and 24 CPU hours. The middle section of the output shows the arguments to each individual th3make run and the result and elapse time for that th3make. All build products and output for the separate th3make runs are captures in subdirectories for post-test analysis. The two-line summary at the bottom shows the total number of errors and tests over all th3make runs and the total elapse time, together with the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; information for the version of SQLite that was tested. This summary information is recorded in the &lt;a href=&quot;https://www.sqlite.org/checklists&quot;&gt;release checklist&lt;/a&gt; during final testing.</source>
          <target state="translated">上記からわかるように、multitest.tclを1回実行すると、th3makeが数十回呼び出され、CPU時間は12〜24時間かかります。出力の中央セクションには、個々のth3makeの実行に対する引数と、そのth3makeの結果と経過時間が表示されます。すべてのビルド製品と個別のth3make実行の出力は、テスト後の分析のためにサブディレクトリにキャプチャされます。下部の2行の概要には、th3makeのすべての実行におけるエラーとテストの合計数、および合計経過時間が、テストされたバージョンのSQLiteの&lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;情報とともに表示されます。この概要情報は、最終テスト中に&lt;a href=&quot;https://www.sqlite.org/checklists&quot;&gt;リリースチェックリスト&lt;/a&gt;に記録されます。</target>
        </trans-unit>
        <trans-unit id="a57eec57195e396346032e284f403497e2a6ca2c" translate="yes" xml:space="preserve">
          <source>As far as we can tell, the SQL language specification allows the use of manifest typing. Nevertheless, most other SQL database engines are statically typed and so some people feel that the use of manifest typing is a bug in SQLite. But the authors of SQLite feel very strongly that this is a feature. The use of manifest typing in SQLite is a deliberate design decision which has proven in practice to make SQLite more reliable and easier to use, especially when used in combination with dynamically typed programming languages such as Tcl and Python.</source>
          <target state="translated">私たちが知る限りでは、SQL言語の仕様ではマニフェスト型付けを使用することができます。それにもかかわらず、他のほとんどのSQLデータベースエンジンは静的型付けを行っているため、マニフェスト型付けの使用はSQLiteのバグだと感じる人もいます。しかし、SQLite の作者は、これは機能であると強く感じています。SQLiteでのマニフェスト型付けの使用は意図的な設計上の決定であり、特にTclやPythonのような動的型付けされたプログラミング言語と組み合わせて使用する場合には、SQLiteの信頼性と使いやすさを向上させることが実際に証明されています。</target>
        </trans-unit>
        <trans-unit id="fc29e0fdbff3d25477a8e029f9259bac6f50556e" translate="yes" xml:space="preserve">
          <source>As for all other SQLite tables, virtual or otherwise, data is retrieved from FTS tables using a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement.</source>
          <target state="translated">他のすべてのSQLiteテーブルと同様に、仮想またはその他のデータは、&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントを使用してFTSテーブルから取得されます。</target>
        </trans-unit>
        <trans-unit id="e10a21db398e4cbe3920a0271ec03a17da9374a2" translate="yes" xml:space="preserve">
          <source>As in &lt;a href=&quot;#section_3_11&quot;&gt;section 3.11&lt;/a&gt;, the journal file might be truncated to zero length or its header might be overwritten with zeros as an optimization on systems where deleting a file is expensive. Either way, the journal is no longer hot after this step.</source>
          <target state="translated">&lt;a href=&quot;#section_3_11&quot;&gt;セクション3.11&lt;/a&gt;と同様に、ファイルの削除にコストがかかるシステムでの最適化として、ジャーナルファイルは長さがゼロに切り捨てられるか、そのヘッダーがゼロで上書きされる可能性があります。いずれにせよ、このステップの後、ジャーナルはもはやホットではありません。</target>
        </trans-unit>
        <trans-unit id="4a052665302d7ed15dacb760a0e1d99f7e61c18a" translate="yes" xml:space="preserve">
          <source>As in the INSERT example, we push the database number P1 (0, the main database) onto the stack and use OpenWrite to open the cursor P1 on table P2 (base page 3, &quot;examp&quot;) for modification.</source>
          <target state="translated">INSERTの例のように、データベース番号P1(0、メインデータベース)をスタックにプッシュし、OpenWriteを使用してテーブルP2(ベースページ3、&quot;examp&quot;)のカーソルP1を変更のために開きます。</target>
        </trans-unit>
        <trans-unit id="493b86f021b95461d337801ffc16a105b55e8b55" translate="yes" xml:space="preserve">
          <source>As in the SELECT example, the &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; instruction rewinds the cursor to the beginning of the table, readying it for use in the loop body.</source>
          <target state="translated">SELECTの例と同様に、&lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt;命令は、カーソルをテーブルの先頭に巻き戻し、ループ本体で使用できるようにします。</target>
        </trans-unit>
        <trans-unit id="164cc333da63b4862e96f8a93857b770263a0e06" translate="yes" xml:space="preserve">
          <source>As is the case for a</source>
          <target state="translated">の場合と同じように</target>
        </trans-unit>
        <trans-unit id="ed24902923099bb89f817d03e0f964e2ddf3fe73" translate="yes" xml:space="preserve">
          <source>As its name implies, an R*Tree is organized as a tree. Each node of the tree is a bounding box. The root of the tree is a bounding box that encapsulates all elements of the tree. Beneath the root are a number of subtrees (typically 20 or more) each with their own smaller bounding boxes and each containing some subset of the R*Tree entries. The subtrees may have sub-subtrees, and so forth until finally one reaches the leaves of the tree which are the actual R*Tree entries.</source>
          <target state="translated">その名の通り、R*Treeは木として構成されています。ツリーの各ノードはバウンディングボックスです。ツリーのルートは、ツリーのすべての要素を包み込む外接箱です。ルートの下には、いくつかのサブツリー(通常は20個以上)があり、それぞれが小さな外接箱を持ち、それぞれがR*Treeのエントリのサブセットを含んでいます。サブツリーはサブサブツリーを持つことができ、最終的には実際の R*Tree エントリであるツリーの葉に到達します。</target>
        </trans-unit>
        <trans-unit id="1329f3ec0fa61448c27dc490e807fec1b74fd581" translate="yes" xml:space="preserve">
          <source>As its name suggests, the &quot;close&quot; method to an SQLite database just closes the database. This has the side-effect of deleting the</source>
          <target state="translated">その名が示すように、SQLiteデータベースの &quot;close &quot;メソッドはデータベースを閉じるだけです。これは、データベースの</target>
        </trans-unit>
        <trans-unit id="3b9e6df535e040569dafb3fcef3111ff226a3e67" translate="yes" xml:space="preserve">
          <source>As long as the buffer size is greater than zero, sqlite3_snprintf() guarantees that the buffer is always zero-terminated. The first parameter &quot;n&quot; is the total size of the buffer, including space for the zero terminator. So the longest string that can be completely written will be n-1 characters.</source>
          <target state="translated">バッファサイズがゼロより大きい限り、sqlite3_snprintf()はバッファが常にゼロ終端であることを保証します。最初のパラメータ &quot;n &quot;は、ゼロ終端のためのスペースを含むバッファの合計サイズです。したがって、完全に書き込める最長の文字列はn-1文字になります。</target>
        </trans-unit>
        <trans-unit id="26ea5ee053d47ffa17dd452debb3d0d447e3ffce" translate="yes" xml:space="preserve">
          <source>As long as the input parameter is correct, these routines can only fail if an out-of-memory error occurs during a format conversion. Only the following subset of interfaces are subject to out-of-memory errors:</source>
          <target state="translated">入力パラメータが正しい限り、これらのルーチンは、フォーマット変換中にメモリ外エラーが発生した場合にのみ失敗します。メモリ切れエラーが発生するのは、以下のインタフェースのサブセットだけです。</target>
        </trans-unit>
        <trans-unit id="bc7938d9d029402b8371ec96dc41a03cdd95d8f8" translate="yes" xml:space="preserve">
          <source>As long as the input parameters are correct, these routines will only fail if an out-of-memory error occurs during a format conversion. Only the following subset of interfaces are subject to out-of-memory errors:</source>
          <target state="translated">入力パラメータが正しい限り、これらのルーチンは、フォーマット変換中にメモリ切れエラーが発生した場合にのみ失敗します。メモリ切れエラーが発生するのは、以下のインタフェースのサブセットだけです。</target>
        </trans-unit>
        <trans-unit id="af3758ac84a3f79558343e605f45f43dad96f8ef" translate="yes" xml:space="preserve">
          <source>As new versions of SQLite are released, repeat steps 3.6 and 3.7 to add changes in the new release to the private branch. Additional private changes can be made on the private branch in between releases if desired.</source>
          <target state="translated">SQLite の新しいバージョンがリリースされたら、手順 3.6 と 3.7 を繰り返して、新しいリリースの変更をプライベートブランチに追加します。必要に応じて、リリースの間にプライベートブランチに追加の変更を加えることができます。</target>
        </trans-unit>
        <trans-unit id="e442983efbc639e95659cc425a72881ca75f93d3" translate="yes" xml:space="preserve">
          <source>As noted above, there really is no such thing as a &quot;sqlite3_column()&quot; function in the SQLite API. Instead, what we here call &quot;sqlite3_column()&quot; is a place-holder for an entire family of functions that return a value from the result set in various data types. There are also routines in this family that return the size of the result (if it is a string or BLOB) and the number of columns in the result set.</source>
          <target state="translated">上で述べたように、SQLite APIには &quot;sqlite3_column()&quot;関数のようなものはありません。代わりに、ここで &quot;sqlite3_column()&quot;と呼ぶものは、様々なデータ型の結果セットから値を返す関数ファミリ全体のプレースホルダです。このファミリーには、結果のサイズ(文字列やBLOBの場合)や結果セットのカラム数を返すルーチンもあります。</target>
        </trans-unit>
        <trans-unit id="f7f8a41bee17850d3fdbafd1837635d4f3b48596" translate="yes" xml:space="preserve">
          <source>As of 2017-03-12, you must use Fossil version 2.0 or later for the following instructions to work. The SQLite repository started using artifacts named using SHA3 hashes instead of SHA1 hashes on that date, and Fossil 2.0 or later is needed in order to understand the new SHA3 hashes. To find out what version of Fossil you are running, type &quot;fossil -v&quot;.</source>
          <target state="translated">2017-03-12現在、以下の指示が機能するためにはFossilのバージョン2.0以降を使用する必要があります。SQLite リポジトリでは、その日付から SHA1 ハッシュではなく SHA3 ハッシュを使用して命名されたアーティファクトを使用するようになり、新しい SHA3 ハッシュを理解するためには Fossil 2.0 以降が必要になりました。お使いのFossilのバージョンを調べるには、&quot;fossil -v &quot;と入力してください。</target>
        </trans-unit>
        <trans-unit id="46e28b72fbe9e739630682b02359c85a23e23fe2" translate="yes" xml:space="preserve">
          <source>As of 2018-05-19, the TH3 source tree consists and well over 500,000 lines of source code in 1709 separate files.</source>
          <target state="translated">2018-05-19現在、TH3のソースツリーは1709個の別ファイルで50万行以上のソースコードで構成されています。</target>
        </trans-unit>
        <trans-unit id="32045934e18d7d7235684ae81bb4ad3e112f0c5b" translate="yes" xml:space="preserve">
          <source>As of 2019-03-20, there is now an &lt;a href=&quot;https://github.com/sqlite/sqlite&quot;&gt;official Git mirror&lt;/a&gt; of the SQLite sources on GitHub.</source>
          <target state="translated">2019-03-20現在、SQLiteソースの&lt;a href=&quot;https://github.com/sqlite/sqlite&quot;&gt;公式Gitミラー&lt;/a&gt;がGitHubにあります。</target>
        </trans-unit>
        <trans-unit id="3e28505b65fc1d015c678e6ae0f3c3ddff268608" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_29_0.html&quot;&gt;version 3.29.0&lt;/a&gt; (2019-07-10), the SQLite library consists of approximately 138.9 KSLOC of C code. (KSLOC means thousands of &quot;Source Lines Of Code&quot; or, in other words, lines of code excluding blank lines and comments.) By comparison, the project has 662 times as much test code and test scripts - 91946.2 KSLOC.</source>
          <target state="translated">以下のように&lt;a href=&quot;https://sqlite.org/releaselog/3_29_0.html&quot;&gt;バージョン3.29.0&lt;/a&gt;（2019年7月10日）、SQLiteのライブラリは、Cコードの約138.9 KSLOCから成ります。（KSLOCは、何千もの「ソース行のコード」、つまり、空白行とコメントを除くコード行を意味します。）比較すると、プロジェクトには、662倍のテストコードとテストスクリプト（91946.2 KSLOC）があります。</target>
        </trans-unit>
        <trans-unit id="2f1c2b6d73cf26867292aed34f667ddc2bada8a1" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_33_0.html&quot;&gt;version 3.33.0&lt;/a&gt; (2020-08-14), the SQLite library consists of approximately 143.4 KSLOC of C code. (KSLOC means thousands of &quot;Source Lines Of Code&quot; or, in other words, lines of code excluding blank lines and comments.) By comparison, the project has 640 times as much test code and test scripts - 91911.0 KSLOC.</source>
          <target state="translated">以下のように&lt;a href=&quot;https://sqlite.org/releaselog/3_33_0.html&quot;&gt;バージョン3.33.0&lt;/a&gt;（2020年8月14日）、SQLiteのライブラリは、Cコードの約143.4 KSLOCから成ります。（KSLOCは、数千の「ソースコード行」、つまり、空白行とコメントを除くコード行を意味します。）比較すると、プロジェクトには640倍のテストコードとテストスクリプト（91911.0 KSLOC）があります。</target>
        </trans-unit>
        <trans-unit id="a53c8d218bf20b0261060ea362ee56f13c07c935" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;version 3.6.19&lt;/a&gt; (2009-10-14), SQLite supports &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt;. But enforcement of foreign key constraints is turned off by default (for backwards compatibility). To enable foreign key constraint enforcement, run &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=ON&lt;/a&gt; or compile with &lt;a href=&quot;compile#default_foreign_keys&quot;&gt;-DSQLITE_DEFAULT_FOREIGN_KEYS=1&lt;/a&gt;.</source>
          <target state="translated">とおり&lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;、バージョン3.6.19&lt;/a&gt;（2009年10月14日）、SQLiteはサポート&lt;a href=&quot;foreignkeys&quot;&gt;外部キー制約を&lt;/a&gt;。ただし、外部キー制約の適用はデフォルトでオフになっています（後方互換性のため）。外部キー制約の強制を有効にするには、&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys = ONを&lt;/a&gt;実行するか、&lt;a href=&quot;compile#default_foreign_keys&quot;&gt;-DSQLITE_DEFAULT_FOREIGN_KEYS = 1&lt;/a&gt;を指定してコンパイルします。</target>
        </trans-unit>
        <trans-unit id="836b2728d9d516fbe942ba314e801009ae9980b0" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;version 3.7.6&lt;/a&gt; (2011-04-12), SQLite includes a new virtual table module called &quot;fts4aux&quot;, which can be used to inspect the full-text index of an existing FTS table directly. Despite its name, fts4aux works just as well with FTS3 tables as it does with FTS4 tables. Fts4aux tables are read-only. The only way to modify the contents of an fts4aux table is by modifying the contents of the associated FTS table. The fts4aux module is automatically included in all &lt;a href=&quot;fts3#compiling_and_enabling_fts3_and_fts4&quot;&gt;builds that include FTS&lt;/a&gt;.</source>
          <target state="translated">以下のように&lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;バージョン3.7.6&lt;/a&gt;（2011-04-12）、SQLiteは直接既存のFTSテーブルのフルテキストインデックスを検査するために使用することができる「fts4aux」と呼ばれる新しい仮想テーブルモジュールを含みます。その名前にもかかわらず、fts4auxはFTS4テーブルと同様にFTS3テーブルでも同様に機能します。 Fts4auxテーブルは読み取り専用です。 fts4auxテーブルの内容を変更する唯一の方法は、関連するFTSテーブルの内容を変更することです。 fts4auxモジュールは&lt;a href=&quot;fts3#compiling_and_enabling_fts3_and_fts4&quot;&gt;、FTSを含む&lt;/a&gt;すべてのビルドに自動的に含まれます。</target>
        </trans-unit>
        <trans-unit id="9d225f240bc36e795cb50632150d857ce4c4d78e" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14), FTS5 is included as part of the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. If using one of the two autoconf build system, FTS5 is enabled by specifying the &quot;--enable-fts5&quot; option when running the configure script. (FTS5 is currently disabled by default for the source-tree configure script and enabled by default for the amalgamation configure script, but these defaults might change in the future.)</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;バージョン3.9.0&lt;/a&gt;（2015-10-14）の時点で、FTS5はSQLite&lt;a href=&quot;amalgamation&quot;&gt;統合の&lt;/a&gt;一部として含まれています。2つのautoconfビルドシステムのいずれかを使用している場合、configureスクリプトの実行時に「--enable-fts5」オプションを指定することでFTS5を有効にします。（FTS5は現在、ソースツリー構成スクリプトではデフォルトで無効になっており、統合構成スクリプトではデフォルトで有効になっていますが、これらのデフォルトは将来変更される可能性があります。）</target>
        </trans-unit>
        <trans-unit id="03eb89fc06866a1260f6276654306363ba727d94" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14), FTS5 is included as part of the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. It is disabled by default. If using the two autoconf build system, it is enabled by specifying the &quot;--enable-fts5&quot; option when running the configure script.</source>
          <target state="translated">以下のように&lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;バージョン3.9.0&lt;/a&gt;（2015年10月14日）、FTS5はSQLiteのの一部として含まれている&lt;a href=&quot;amalgamation&quot;&gt;合併&lt;/a&gt;。デフォルトでは無効になっています。2つのautoconfビルドシステムを使用している場合は、構成スクリプトの実行時に「--enable-fts5」オプションを指定することで有効になります。</target>
        </trans-unit>
        <trans-unit id="0cba18acfc338d803dd183b86646f960bc3ebd65" translate="yes" xml:space="preserve">
          <source>As of SQLite 3.16.0 (2017-01-02), the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; contains a dot-command &quot;.imposter&quot; that does all of the work of setting up a transient imposter table. Instead of making multiple calls to sqlite3_test_control() and figuring out and invoking a compatible CREATE TABLE statement, a transient imposter table can be constructed as follows:</source>
          <target state="translated">SQLite 3.16.0（2017-01-02）以降、&lt;a href=&quot;cli&quot;&gt;コマンドラインシェルに&lt;/a&gt;は、一時的な詐称者テーブルを設定するすべての作業を行うドットコマンド「.imposter」が含まれています。sqlite3_test_control（）を複数回呼び出して互換性のあるCREATE TABLEステートメントを見つけて呼び出す代わりに、一時的な詐称者テーブルを次のように作成できます。</target>
        </trans-unit>
        <trans-unit id="98a2e1c87379924c2c171b5738373e64a2f944b7" translate="yes" xml:space="preserve">
          <source>As of SQLite 3.27.0 (2019-02-07) the use of a double-quoted string literal causes a warning message to be sent to the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt;.</source>
          <target state="translated">SQLite 3.27.0（2019-02-07）以降、二重引用符で囲まれた文字列リテラルを使用すると、警告メッセージが&lt;a href=&quot;errlog&quot;&gt;エラーログに&lt;/a&gt;送信されます。</target>
        </trans-unit>
        <trans-unit id="477279c68e157e3c69007f56a275a12b81ee766f" translate="yes" xml:space="preserve">
          <source>As of SQLite 3.29.0 (2019-07-10) the use of double-quoted string literals can be disabled at run-time using the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsddl&quot;&gt;SQLITE_DBCONFIG_DQS_DDL&lt;/a&gt; and &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsdml&quot;&gt;SQLITE_DBCONFIG_DQS_DML&lt;/a&gt; actions to &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt;. The default settings can be altered at compile-time using the &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS=&lt;i&gt;N&lt;/i&gt;&lt;/a&gt; compile-time option. Application developers are encouraged to compile using -DSQLITE_DQS=0 in order to disable the double-quoted string literal misfeature by default. If that is not possible, then disable double-quoted string literals for individual database connections using C-code like this:</source>
          <target state="translated">SQLite 3.29.0（2019-07-10）&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsddl&quot;&gt;以降&lt;/a&gt;、SQLITE_DBCONFIG_DQS_DDLおよび&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsdml&quot;&gt;SQLITE_DBCONFIG_DQS_DML&lt;/a&gt;アクションを&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config（）に&lt;/a&gt;使用することで、実行時に二重引用符で囲まれた文字列リテラルの使用を無効にできます。デフォルト設定は、コンパイル時に&lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS = &lt;i&gt;N&lt;/i&gt;&lt;/a&gt;コンパイル時オプションを使用して変更できます。アプリケーション開発者は、デフォルトで二重引用符付きの文字列リテラルの誤った機能を無効にするために、-DSQLITE_DQS = 0を使用してコンパイルすることをお勧めします。それが不可能な場合は、次のようなCコードを使用して、個々のデータベース接続の二重引用符で囲まれた文字列リテラルを無効にします。</target>
        </trans-unit>
        <trans-unit id="27ccd6edc0578e2c50724724d1f7e72fc2202881" translate="yes" xml:space="preserve">
          <source>As of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;version 3.11.0&lt;/a&gt; (2016-02-15), the WAL file for a single transaction should be proportional in size to the transaction itself. Pages that are changed by the transaction should only be written into the WAL file once. However, with older versions of SQLite, the same page might be written into the WAL file multiple times if the transaction grows larger than the page cache.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;バージョン3.11.0&lt;/a&gt;（2016-02-15）以降、単一のトランザクションのWALファイルは、トランザクション自体のサイズに比例する必要があります。トランザクションによって変更されたページは、WALファイルに1回だけ書き込む必要があります。ただし、SQLiteの古いバージョンでは、トランザクションがページキャッシュより大きくなると、同じページがWALファイルに複数回書き込まれる可能性があります。</target>
        </trans-unit>
        <trans-unit id="9002d4afcf5621573059e14d645945f49cc82521" translate="yes" xml:space="preserve">
          <source>As of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_1.html&quot;&gt;version 3.6.1&lt;/a&gt; (2008-08-06), the soft heap limit only applies to the general-purpose memory allocator. The soft heap limit does not know about or interact with the &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt; or the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt;. This deficiency will likely be addressed in a future release.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_1.html&quot;&gt;バージョン3.6.1&lt;/a&gt;（2008-08-06）以降、ソフトヒープ制限は汎用メモリアロケータにのみ適用されます。ソフトヒープの制限は、&lt;a href=&quot;malloc#pagecache&quot;&gt;ページキャッシュメモリアロケータ&lt;/a&gt;または&lt;a href=&quot;malloc#lookaside&quot;&gt;ルックアサイドメモリアロケータを&lt;/a&gt;認識していないか、相互作用しません。この欠陥は、将来のリリースで対処される可能性があります。</target>
        </trans-unit>
        <trans-unit id="b175c36534eb0163084a39638e664737aba3d613" translate="yes" xml:space="preserve">
          <source>As of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;version 3.6.19&lt;/a&gt;, the default setting for foreign key enforcement is OFF. However, that might change in a future release of SQLite. The default setting for foreign key enforcement can be specified at compile-time using the &lt;a href=&quot;compile#default_foreign_keys&quot;&gt;SQLITE_DEFAULT_FOREIGN_KEYS&lt;/a&gt; preprocessor macro. To minimize future problems, applications should set the foreign key enforcement flag as required by the application and not depend on the default setting.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;バージョン3.6.19&lt;/a&gt;以降、外部キー強制のデフォルト設定はOFFです。ただし、SQLiteの将来のリリースで変更される可能性があります。外部キー強制のデフォルト設定は、&lt;a href=&quot;compile#default_foreign_keys&quot;&gt;SQLITE_DEFAULT_FOREIGN_KEYS&lt;/a&gt;プリプロセッサマクロを使用してコンパイル時に指定できます。将来の問題を最小限に抑えるために、アプリケーションは、アプリケーションの必要に応じて外部キー実施フラグを設定し、デフォルト設定に依存しないようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="0e6461cc943c138056429ef3ecea61d0043a0402" translate="yes" xml:space="preserve">
          <source>As of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14), the &lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt; utility is able to generate RBU databases representing the difference between two databases with identical schemas. For example, the following command:</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;バージョン3.9.0&lt;/a&gt;（2015-10-14）以降、&lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt;ユーティリティは、同じスキーマを持つ2つのデータベースの違いを表すRBUデータベースを生成できます。たとえば、次のコマンド：</target>
        </trans-unit>
        <trans-unit id="dfbf6fd8aef52e316e037404ed7145e5b99ccf6d" translate="yes" xml:space="preserve">
          <source>As of SQLite version 3.21.0 (2017-10-24), the query planner will always prefer to use a co-routine to implement FROM-clause subqueries that contains an ORDER BY clause and that are not part of a join when the result set of the outer query is &quot;complex&quot;. This feature allows applications to shift expensive computations from before the sorter until after the sorter, which can result in faster operation. For example, consider this query:</source>
          <target state="translated">SQLite バージョン 3.21.0 (2017-10-24)の時点では、クエリプランナーは、外側のクエリの結果セットが「複雑」である場合に、ORDER BY 節を含み、結合の一部ではない FROM 節のサブクエリを実装するために、常にコ・ルーティンを使用することを好むようになりました。この機能により、アプリケーションは高価な計算をソータの前からソータの後までシフトさせることができ、結果としてより高速な処理を実現することができます。例えば、次のようなクエリを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="242b46186535aea87c089fafc2bda700b6f5e078" translate="yes" xml:space="preserve">
          <source>As of SQLite version 3.22.0, the &quot;sqlite_stat1&quot; table is an exception to some of the rules above. In SQLite, the schema of sqlite_stat1 is:</source>
          <target state="translated">SQLiteバージョン3.22.0では、&quot;sqlite_stat1 &quot;テーブルは上記のルールのいくつかの例外となっています。SQLiteでは、sqlite_stat1のスキーマは</target>
        </trans-unit>
        <trans-unit id="5ddb98490083a7f2dc1ca2a3b26fa7d781b747ca" translate="yes" xml:space="preserve">
          <source>As of this writing (2017-07-13), the completion virtual table only looks for SQL keywords, and schema, table, and column names. The context contained in $wholeline is completely ignored. Future enhancements will try to return new completions taken from function and pragma names and other sources, as well as consider more context. The completion table should be considered a work-in-progress.</source>
          <target state="translated">この記事を書いている時点(2017-07-13)では、補完仮想テーブルはSQLキーワードとスキーマ名、テーブル名、カラム名のみを探しています。wholelineに含まれるコンテキストは完全に無視されます。今後の拡張機能では、関数名やプラグマ名などから取られた新しい補完を返すようにするとともに、より多くのコンテキストを考慮しようとします。補完テーブルは作業中のものと考えてください。</target>
        </trans-unit>
        <trans-unit id="b289cb5373e1ff5a5a0c905eb902dc91bdb7b556" translate="yes" xml:space="preserve">
          <source>As of this writing (2018-05-29) the only other recommended storage formats for datasets are XML, JSON, and CSV.</source>
          <target state="translated">この記事を書いている時点(2018-05-29)では、データセットの他の推奨ストレージ形式はXML、JSON、CSVのみです。</target>
        </trans-unit>
        <trans-unit id="f2ad4e776d39a3ec2c252f71f4dae40cd1708a1c" translate="yes" xml:space="preserve">
          <source>As of this writing (2019-07-16), the SQLite developers have stopped using AFL for routine testing and instead are focused on running dbsqlfuzz. At least one instance of dbsqlfuzz is running on the latest SQLite source code at all times, in order to catch any new problems that might be introduced into the source tree as features are added and routine maintenance is performed.</source>
          <target state="translated">この記事を書いている時点(2019-07-16)で、SQLiteの開発者はルーチンテストにAFLを使用することをやめ、代わりにdbsqlfuzzを実行することに専念しています。機能が追加されたり、定期的なメンテナンスが行われたりする中で、ソースツリーに新たな問題が発生する可能性がある場合、それをキャッチするために、常に最新の SQLite ソースコード上で dbsqlfuzz の少なくとも 1 つのインスタンスが実行されています。</target>
        </trans-unit>
        <trans-unit id="c36686a25a23f2cfaee766f9bfb5607ad00a8413" translate="yes" xml:space="preserve">
          <source>As one might expect, the amount of data read from the database file is minimized by caching portions of the database file in main memory. Additionally, multiple updates to the database file that are part of the same</source>
          <target state="translated">期待通り、データベースファイルの一部をメインメモリにキャッシュすることで、データベースファイルから読み込まれるデータ量を最小限に抑えることができます。さらに、データベースファイルへの複数の更新は、同じ</target>
        </trans-unit>
        <trans-unit id="972efc3fd6678a6e105ba1a8f1aac17c41abd523" translate="yes" xml:space="preserve">
          <source>As part of opening a new</source>
          <target state="translated">新規開設の一環として</target>
        </trans-unit>
        <trans-unit id="9b40d60a44eca2b862c669b4ece8404effe70c95" translate="yes" xml:space="preserve">
          <source>As part of the query planning process, SQLite enumerates all usable combinations of indexes and WHERE-clause constraints. For certain pathological queries, the number of these index-and-constraint combinations can be very large, resulting in slow performance by the query planner. The SQLITE_QUERY_PLANNER_LIMIT value (in conjunction with the related &lt;a href=&quot;compile#query_planner_limit_incr&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT_INCR&lt;/a&gt; setting) limits the number of index-and-constraint combinations that the query planner will consider, in order to prevent the query planner from using excess CPU time. The default value for SQLITE_QUERY_PLANNER_LIMIT is set high enough so that is never reached for real-world queries. The query planner search limit only applies to queries that are deliberately crafted to use excess planning time.</source>
          <target state="translated">クエリ計画プロセスの一部として、SQLiteはインデックスとWHERE句の制約のすべての使用可能な組み合わせを列挙します。特定の病理学的クエリでは、これらのインデックスと制約の組み合わせの数が非常に多くなり、クエリプランナーのパフォーマンスが低下する可能性があります。 SQLITE_QUERY_PLANNER_LIMIT値（および関連する&lt;a href=&quot;compile#query_planner_limit_incr&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT_INCR&lt;/a&gt;設定と組み合わせて）は、クエリプランナーが過剰なCPU時間を使用しないようにするために、クエリプランナーが考慮するインデックスと制約の組み合わせの数を制限します。 SQLITE_QUERY_PLANNER_LIMITのデフォルト値は、実際のクエリでは到達しないように十分に高く設定されています。クエリプランナーの検索制限は、余分な計画時間を使用するように意図的に作成されたクエリにのみ適用されます。</target>
        </trans-unit>
        <trans-unit id="69ee480d16c703172bf696c37d4bed26f84974f4" translate="yes" xml:space="preserve">
          <source>As part of the task of creating a new &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure, this method &lt;u&gt;must&lt;/u&gt; invoke &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; to tell the SQLite core about the columns and datatypes in the virtual table. The &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; API has the following prototype:</source>
          <target state="translated">新しい&lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt;構造を作成するタスクの一部として、このメソッド&lt;u&gt;は&lt;/u&gt;&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab（）&lt;/a&gt;を呼び出して、仮想テーブルの列とデータ型についてSQLiteコアに通知する&lt;u&gt;必要があり&lt;/u&gt;ます。&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab（）&lt;/a&gt; APIは、次のプロトタイプがあります。</target>
        </trans-unit>
        <trans-unit id="c00876adc6de8fc473fb32b80195d17d4fda9f03" translate="yes" xml:space="preserve">
          <source>As pointed out in the previous paragraph, SQLite takes steps to work around the quirks of POSIX advisory locking. Part of that work-around involves keeping a global list (mutex protected) of open SQLite database files. But, if multiple copies of SQLite are linked into the same application, then there will be multiple instances of this global list. Database connections opened using one copy of the SQLite library will be unaware of database connections opened using the other copy, and will be unable to work around the POSIX advisory locking quirks. A &lt;code&gt;close()&lt;/code&gt; operation on one connection might unknowingly clear the locks on a different database connection, leading to database corruption.</source>
          <target state="translated">前の段落で指摘したように、SQLiteはPOSIXアドバイザリロックの癖を回避する手順を実行します。その回避策の一部には、開いているSQLiteデータベースファイルのグローバルリスト（mutex保護）を保持することが含まれます。ただし、SQLiteの複数のコピーが同じアプリケーションにリンクされている場合、このグローバルリストの複数のインスタンスが存在します。 SQLiteライブラリの1つのコピーを使用して開かれたデータベース接続は、他のコピーを使用して開かれたデータベース接続を認識せず、POSIXアドバイザリロックの癖を回避できません。 &lt;code&gt;close()&lt;/code&gt; 1つの接続での操作は、無意識のうちにデータベースの破損につながる、異なるデータベース接続のロックを解除することがあります。</target>
        </trans-unit>
        <trans-unit id="d6d67b507fa18e45da7b000070cada26cbc7cde7" translate="yes" xml:space="preserve">
          <source>As recently as version 2.7.0, SQLite ran at about the same speed as MySQL on this test. But recent optimizations to SQLite have more than doubled speed of UPDATEs.</source>
          <target state="translated">最近のバージョン2.7.0では、SQLiteはこのテストではMySQLとほぼ同じ速度で動作しました。しかし、最近の SQLite への最適化により、UPDATE の速度が 2 倍以上になりました。</target>
        </trans-unit>
        <trans-unit id="9a13d6d8189152816b2ae81d060e78c812a6905c" translate="yes" xml:space="preserve">
          <source>As soon as the PENDING lock is released from the database file, other processes can begin reading the database again. In the current implementation, the RESERVED lock is also released, but that is not essential for correct operation.</source>
          <target state="translated">pendingロックがデータベースファイルから解放されるとすぐに、他のプロセスは再びデータベースの読み込みを開始することができる。現在の実装では、RESERVEDEDロックも解放されていますが、それは正しい操作のためには必須ではありません。</target>
        </trans-unit>
        <trans-unit id="555c3a9cda5a4b25e0cdbc43fe5e7c8c0b690222" translate="yes" xml:space="preserve">
          <source>As the last step in opening a</source>
          <target state="translated">開設の最後のステップとして</target>
        </trans-unit>
        <trans-unit id="de5e740293d719649dc267008b44fcf5aaa20455" translate="yes" xml:space="preserve">
          <source>As we enter the interior of the second loop (at instruction 17) the stack contains a single integer which is the key of the record we want to modify. We are going to need to use this key twice: once to fetch the old value of the record and a second time to write back the revised record. So the first instruction is a Dup to make a duplicate of the key on the top of the stack. The Dup instruction will duplicate any element of the stack, not just the top element. You specify which element to duplication using the P1 operand. When P1 is 0, the top of the stack is duplicated. When P1 is 1, the next element down on the stack duplication. And so forth.</source>
          <target state="translated">2 番目のループの内部に入ると(命令 17 で)、スタックには修正したいレコードのキーである 1 つの整数が含まれています。1回目はレコードの古い値を取得し、2回目は修正したレコードを書き戻すためです。そこで、最初の命令は、スタックの先頭にあるキーの複製を作るためのDupです。Dup命令は、スタックの先頭の要素だけでなく、スタックのどの要素も複製します。どの要素を複製するかは、P1オペランドを使って指定します。P1が0の場合、スタックの先頭が複製されます。P1が1の場合、スタックの次の下の要素が複製されます。といった具合です。</target>
        </trans-unit>
        <trans-unit id="cf4c617d0371eb7d2e50bdeaba7f0656cfa12c47" translate="yes" xml:space="preserve">
          <source>As well as a list of columns, the module arguments passed to a CREATE VIRTUAL TABLE statement used to create an FTS table may be used to specify a &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt;. This is done by specifying a string of the form &quot;tokenize=&amp;lt;tokenizer name&amp;gt; &amp;lt;tokenizer args&amp;gt;&quot; in place of a column name, where &amp;lt;tokenizer name&amp;gt; is the name of the tokenizer to use and &amp;lt;tokenizer args&amp;gt; is an optional list of whitespace separated qualifiers to pass to the tokenizer implementation. A tokenizer specification may be placed anywhere in the column list, but at most one tokenizer declaration is allowed for each CREATE VIRTUAL TABLE statement. &lt;a href=&quot;fts3#tokenizer&quot;&gt;See below&lt;/a&gt; for a detailed description of using (and, if necessary, implementing) a tokenizer.</source>
          <target state="translated">列のリストだけでなく、FTSテーブルの作成に使用されるCREATE VIRTUAL TABLEステートメントに渡されるモジュール引数を使用して、&lt;a href=&quot;fts3#tokenizer&quot;&gt;トークナイザー&lt;/a&gt;を指定できます。これは、列名の代わりに &quot;tokenize = &amp;lt;tokenizer name&amp;gt; &amp;lt;tokenizer args&amp;gt;&quot;という形式の文字列を指定することで行われます。&amp;lt;tokenizer name&amp;gt;は使用するトークナイザーの名前で、&amp;lt;tokenizer args&amp;gt;はオプションですトークナイザー実装に渡す、空白で区切られた修飾子のリスト。トークナイザーの指定は列リストのどこにでも配置できますが、各CREATE VIRTUAL TABLEステートメントで許可されるトークナイザー宣言は1つだけです。トークナイザーの使用（および必要に応じて実装）の詳細については、&lt;a href=&quot;fts3#tokenizer&quot;&gt;以下&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="aba6435071ee404f8eb600e0af17ad3d0179b00e" translate="yes" xml:space="preserve">
          <source>As well as aggregate window functions, SQLite features a set of built-in window functions based on &lt;a href=&quot;https://www.postgresql.org/docs/10/static/functions-window.html&quot;&gt; those supported by PostgreSQL&lt;/a&gt;.</source>
          <target state="translated">SQLiteは、集約ウィンドウ関数だけでなく&lt;a href=&quot;https://www.postgresql.org/docs/10/static/functions-window.html&quot;&gt;、PostgreSQLでサポートさ&lt;/a&gt;れているものに基づいた一連の組み込みウィンドウ関数を備えています。</target>
        </trans-unit>
        <trans-unit id="4c2adc03d8772b0c49ef19569e284dd9591a16b0" translate="yes" xml:space="preserve">
          <source>As well as being set automatically as rows are inserted into database tables, the value returned by this function may be set explicitly by &lt;a href=&quot;#sqlite3_set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid()&lt;/a&gt;</source>
          <target state="translated">行がデータベーステーブルに挿入されると自動的に設定されるだけでなく、この関数によって返される値は&lt;a href=&quot;#sqlite3_set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid（）&lt;/a&gt;によって明示的に設定できます</target>
        </trans-unit>
        <trans-unit id="6da8075b78c1059d6422bee1d474218e1b6600d9" translate="yes" xml:space="preserve">
          <source>As well as being set automatically as rows are inserted into database tables, the value returned by this function may be set explicitly by &lt;a href=&quot;set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid()&lt;/a&gt;</source>
          <target state="translated">行がデータベーステーブルに挿入されると自動的に設定されるだけでなく、この関数によって返される値は&lt;a href=&quot;set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid（）&lt;/a&gt;によって明示的に設定できます</target>
        </trans-unit>
        <trans-unit id="0a715526e2153a56ee0a3cbcb2c8454333e9e1d8" translate="yes" xml:space="preserve">
          <source>As well as searching for all rows that contain a term, FTS5 allows the user to search for rows that contain:</source>
          <target state="translated">FTS5では、用語を含むすべての行を検索するだけでなく、用語を含む行を検索することができます。</target>
        </trans-unit>
        <trans-unit id="19f6e18c709ce14d58e4401d523e835813272b3a" translate="yes" xml:space="preserve">
          <source>As well as the &quot;simple&quot; tokenizer, the FTS source code features a tokenizer that uses the &lt;a href=&quot;http://tartarus.org/~martin/PorterStemmer/&quot;&gt;Porter Stemming algorithm&lt;/a&gt;. This tokenizer uses the same rules to separate the input document into terms including folding all terms into lower case, but also uses the Porter Stemming algorithm to reduce related English language words to a common root. For example, using the same input document as in the paragraph above, the porter tokenizer extracts the following tokens: &quot;right now thei veri frustrat&quot;. Even though some of these terms are not even English words, in some cases using them to build the full-text index is more useful than the more intelligible output produced by the simple tokenizer. Using the porter tokenizer, the document not only matches full-text queries such as &quot;MATCH 'Frustrated'&quot;, but also queries such as &quot;MATCH 'Frustration'&quot;, as the term &quot;Frustration&quot; is reduced by the Porter stemmer algorithm to &quot;frustrat&quot; - just as &quot;Frustrated&quot; is. So, when using the porter tokenizer, FTS is able to find not just exact matches for queried terms, but matches against similar English language terms. For more information on the Porter Stemmer algorithm, please refer to the page linked above.</source>
          <target state="translated">「シンプルな」トークナイザーと同様に、FTSソースコードは&lt;a href=&quot;http://tartarus.org/~martin/PorterStemmer/&quot;&gt;ポーターステミングアルゴリズム&lt;/a&gt;を使用するトークナイザーを備えています。このトークナイザーは、同じルールを使用して、入力ドキュメントをすべての用語を小文字に変換するなどの用語に分割しますが、Porter Stemmingアルゴリズムを使用して、関連する英語の単語を共通のルートに減らします。たとえば、上記の段落と同じ入力ドキュメントを使用して、ポータートークナイザーは次のトークンを抽出します： &quot;right now thei veri frustrat&quot;。これらの用語の一部は英語の単語でさえない場合でも、単純なトークナイザによって生成されるよりわかりやすい出力よりも、それらを使用してフルテキストインデックスを構築する方が便利な場合があります。ポータートークナイザーを使用すると、ドキュメントは「MATCH 'Frustrated'」などの全文クエリだけでなく、「MATCH 'Frustration'」などのクエリも「Frustration」という用語として照合します。ポーターステマーアルゴリズムによって「フラストラット」に削減されます-「フラストレーション」と同じです。したがって、ポータートークナイザーを使用すると、FTSはクエリされた用語の完全一致だけでなく、類似の英語の用語との一致も検出できます。 Porter Stemmerアルゴリズムの詳細については、上記のリンク先のページを参照してください。</target>
        </trans-unit>
        <trans-unit id="03b7b3d7c7af14aee8c40f5a5eff47a557f13b7f" translate="yes" xml:space="preserve">
          <source>As well as the column values and rowid of a matching row, an application may use &lt;a href=&quot;fts5#_auxiliary_functions_&quot;&gt;FTS5 auxiliary functions&lt;/a&gt; to retrieve extra information regarding the matched row. For example, an auxiliary function may be used to retrieve a copy of a column value for a matched row with all instances of the matched term surrounded by html &amp;lt;b&amp;gt;&amp;lt;/b&amp;gt; tags. Auxiliary functions are invoked in the same way as SQLite &lt;a href=&quot;lang_corefunc&quot;&gt;scalar functions&lt;/a&gt;, except that the name of the FTS5 table is specified as the first argument. For example:</source>
          <target state="translated">一致する行の列値と行IDだけでなく、アプリケーションは&lt;a href=&quot;fts5#_auxiliary_functions_&quot;&gt;FTS5補助関数&lt;/a&gt;を使用して、一致した行に関する追加情報を取得できます。たとえば、補助関数を使用して、html &amp;lt;b&amp;gt; &amp;lt;/ b&amp;gt;タグで囲まれた一致する用語のすべてのインスタンスを含む、一致する行の列値のコピーを取得できます。FTS5テーブルの名前が最初の引数として指定されることを除いて、補助関数はSQLite &lt;a href=&quot;lang_corefunc&quot;&gt;スカラー関数&lt;/a&gt;と同じ方法で呼び出されます。例えば：</target>
        </trans-unit>
        <trans-unit id="5f0b425505ed4df313764b933ddda058638fd396" translate="yes" xml:space="preserve">
          <source>As well as the columns named by the user (or the &quot;content&quot; column if no module arguments were specified as part of the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement), each FTS table has a &quot;rowid&quot; column. The rowid of an FTS table behaves in the same way as the rowid column of an ordinary SQLite table, except that the values stored in the rowid column of an FTS table remain unchanged if the database is rebuilt using the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command. For FTS tables, &quot;docid&quot; is allowed as an alias along with the usual &quot;rowid&quot;, &quot;oid&quot; and &quot;_oid_&quot; identifiers. Attempting to insert or update a row with a docid value that already exists in the table is an error, just as it would be with an ordinary SQLite table.</source>
          <target state="translated">ユーザーが指定した列（または、&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;ステートメントの一部としてモジュール引数が指定されていない場合は「コンテンツ」列）と同様に、各FTSテーブルには「行ID」列があります。 FTSテーブルのROWIDは、通常のSQLiteテーブルのROWID列と同じように動作しますが、データベースが&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;コマンドを使用して再構築された場合、FTSテーブルのROWID列に格納された値は変更されません。 FTSテーブルの場合、「docid」は、通常の「rowid」、「oid」、および「_oid_」識別子とともにエイリアスとして許可されます。テーブルに既に存在するdocid値で行を挿入または更新しようとすると、通常のSQLiteテーブルの場合と同様にエラーになります。</target>
        </trans-unit>
        <trans-unit id="8231b142308216452ffa1a9e5faf9c8e3f6c4c97" translate="yes" xml:space="preserve">
          <source>As well as the command option, each invocation of &quot;.ar&quot; may specify one or more modifier options. Some modifier options require an argument, some do not. The following modifier options are available:</source>
          <target state="translated">コマンドオプションと同様に、&quot;.ar&quot; の各呼び出しは、1つ以上の修飾オプションを指定することができます。修飾オプションの中には引数を必要とするものとそうでないものがあります。以下の修飾オプションが利用可能です。</target>
        </trans-unit>
        <trans-unit id="11a7e6bcced1d592a4403e3d9c67fd5b0f5481cf" translate="yes" xml:space="preserve">
          <source>As well as the regular sqlite3changegroup_add() and sqlite3changegroup_output() functions, also available are the streaming versions sqlite3changegroup_add_strm() and sqlite3changegroup_output_strm().</source>
          <target state="translated">通常のsqlite3changegroup_add()とsqlite3changegroup_output()関数の他に、ストリーミング版のsqlite3changegroup_add_strm()とsqlite3changegroup_output_strm()も利用可能です。</target>
        </trans-unit>
        <trans-unit id="c79aa6a7ac9fe81930f35128aa127b04b14a76a2" translate="yes" xml:space="preserve">
          <source>As with &quot;.tables&quot;, the &quot;.schema&quot; command shows the schema for all &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; databases. If you only want to see the schema for a single database (perhaps &quot;main&quot;) then you can add an argument to &quot;.schema&quot; to restrict its output:</source>
          <target state="translated">「.tables」と同様に、「。schema」コマンドは、&lt;a href=&quot;lang_attach&quot;&gt;接続さ&lt;/a&gt;れているすべてのデータベースのスキーマを表示します。単一のデータベース（おそらく「main」）のスキーマのみを表示したい場合は、「。schema」に引数を追加して、その出力を制限できます。</target>
        </trans-unit>
        <trans-unit id="ea1906458c679a89c4cf89131d2ffd0b8ce0439a" translate="yes" xml:space="preserve">
          <source>As with all SQL syntax, the case of the keywords does not matter. One can write &quot;WITHOUT rowid&quot; or &quot;without rowid&quot; or &quot;WiThOuT rOwId&quot; and it will mean the same thing.</source>
          <target state="translated">すべての SQL 構文と同様に、キーワードの大文字小文字は問題ではありません。WITHOUT rowid &quot;や &quot;without rowid &quot;や &quot;WiThOuT rOwId &quot;と書いても同じ意味になります。</target>
        </trans-unit>
        <trans-unit id="08e240ecd7ad7f6958c55717608dff9d30301be2" translate="yes" xml:space="preserve">
          <source>As with all other SQLite APIs, those whose names end with &quot;16&quot; return UTF-16 encoded strings and the other functions return UTF-8.</source>
          <target state="translated">他のすべてのSQLite APIと同様に、名前が &quot;16 &quot;で終わる関数はUTF-16でエンコードされた文字列を返し、その他の関数はUTF-8を返します。</target>
        </trans-unit>
        <trans-unit id="dad941d012cf3c0fecce4040017740b92b3cab9e" translate="yes" xml:space="preserve">
          <source>As with all virtual table types, it is not possible to create indices or triggers attached to FTS tables. Nor is it possible to use the ALTER TABLE command to add extra columns to FTS tables (although it is possible to use ALTER TABLE to rename an FTS table).</source>
          <target state="translated">すべての仮想テーブル・タイプと同様に、FTSテーブルに添付されたインデックスやトリガーを作成することはできません。また、FTSテーブルに追加の列を追加するためにALTER TABLEコマンドを使用することはできません(FTSテーブルの名前を変更するためにALTER TABLEを使用することは可能ですが)。</target>
        </trans-unit>
        <trans-unit id="2c9244ac5b5d0550aa0d1fc8ca3aa52ca8dfaf6c" translate="yes" xml:space="preserve">
          <source>As with custom file formats, and unlike pure pile-of-file formats, a wrapped pile-of-files format is not as easy to edit, since usually the entire file must be rewritten in order to change any component part.</source>
          <target state="translated">カスタムファイルフォーマットと同様に、また純粋な pile-of-file フォーマットとは異なり、ラップされた pile-of-files フォーマットは編集が容易ではありません。</target>
        </trans-unit>
        <trans-unit id="236d7f982d31124f4b94b3c6bc8e43ed33b0fc4b" translate="yes" xml:space="preserve">
          <source>As with the output of the sqlite3session_changeset() and sqlite3session_patchset() functions, all changes related to a single table are grouped together in the output of this function. Tables appear in the same order as for the very first changeset added to the changegroup. If the second or subsequent changesets added to the changegroup contain changes for tables that do not appear in the first changeset, they are appended onto the end of the output changeset, again in the order in which they are first encountered.</source>
          <target state="translated">sqlite3session_changeset()関数とsqlite3session_patchset()関数の出力と同様に、単一のテーブルに関連するすべての変更はこの関数の出力でまとめられます。テーブルは、変更グループに追加された最初の変更セットと同じ順番で表示されます。changegroup に追加された 2 番目以降のチェンジセットに、最初のチェンジセットにはないテーブルの変更が含まれている場合、それらは出力されたチェンジセットの最後に追加され、再び最初に遭遇した順番で表示されます。</target>
        </trans-unit>
        <trans-unit id="38abe488c2a235f79f98488263f0f24db0790ef4" translate="yes" xml:space="preserve">
          <source>As with unix, most of the code for the various Windows VFSes is shared.</source>
          <target state="translated">unix と同様に、様々な Windows VFS のコードのほとんどが共有されています。</target>
        </trans-unit>
        <trans-unit id="ae23c67b5810fa3b2f8c5dc0de91ee63f46fa321" translate="yes" xml:space="preserve">
          <source>As you can see above, our simple insert statement is implemented in 12 instructions. The first 3 and last 2 instructions are a standard prologue and epilogue, so the real work is done in the middle 7 instructions. There are no jumps, so the program executes once through from top to bottom. Let's now look at each instruction in detail.</source>
          <target state="translated">上で見たように、私たちの単純な挿入文は12の命令で実装されています。最初の3命令と最後の2命令は標準的なプロローグとエピローグなので、実際の作業は中間の7命令で行われます。ジャンプがないので、プログラムは上から下へ一度だけ実行されます。それでは、それぞれの命令を詳しく見ていきましょう。</target>
        </trans-unit>
        <trans-unit id="5e7f8dc6fe3c7e8373b6401e629567228cb8e775" translate="yes" xml:space="preserve">
          <source>As you would expect, it is not possible to manipulate the database to a state that violates the foreign key constraint by deleting or updating rows in the</source>
          <target state="translated">の行を削除したり更新したりすることで、外部キー制約に違反する状態にデータベースを操作することはできません。</target>
        </trans-unit>
        <trans-unit id="d60ffe4ee5253e97c8077a55a44490538dd90ceb" translate="yes" xml:space="preserve">
          <source>Aside from those read operations described by H35070 and H21XXX, SQLite shall read data from the database file in aligned blocks of</source>
          <target state="translated">H35070及びH21XXXで記述されている読み込み操作を除き、SQLiteはデータベースファイルからデータを</target>
        </trans-unit>
        <trans-unit id="42e2846af72fd7f80a66045f0952619fc82cc85d" translate="yes" xml:space="preserve">
          <source>Assert() macros are disabled by compiling with the NDEBUG macro defined. In most systems, asserts are enabled by default. But in SQLite, the asserts are so numerous and are in such performance critical places, that the database engine runs about three times slower when asserts are enabled. Hence, the default (production) build of SQLite disables asserts. Assert statements are only enabled when SQLite is compiled with the SQLITE_DEBUG preprocessor macro defined.</source>
          <target state="translated">Assert()マクロは、NDEBUGマクロを定義してコンパイルすることで無効になります。ほとんどのシステムでは、デフォルトでアサートは有効になっています。しかし、SQLiteでは、アサートが非常に多く、パフォーマンスが重要な場所にあるため、アサートを有効にした場合、データベースエンジンの動作が約3倍遅くなります。そのため、SQLiteのデフォルト(本番環境)のビルドでは、アサートは無効になっています。アサート文が有効になるのは、SQLite が SQLITE_DEBUG プリプロセッサマクロを定義してコンパイルされている場合のみです。</target>
        </trans-unit>
        <trans-unit id="c350f30044b71a607c57f6c34de0b1ed5d9089b9" translate="yes" xml:space="preserve">
          <source>Assertion fault in FTS4. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/d6ec09eccf68cfc&quot;&gt;d6ec09eccf68cfc&lt;/a&gt;</source>
          <target state="translated">FTS4のアサーションエラー。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/d6ec09eccf68cfc&quot;&gt;d6ec09eccf68cfc&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ebc26a866ddd19c561f95f02b90e42c3048bf831" translate="yes" xml:space="preserve">
          <source>Assertion fault on queries involving expressions of the form &quot;x IN (?)&quot;. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/e39d032577&quot;&gt;e39d032577&lt;/a&gt;.</source>
          <target state="translated">「x IN（？）」の形式の式を含むクエリのアサーションフォールト。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/e39d032577&quot;&gt;e39d032577&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8c84e5f05e8b60b78b6a824b91605a18f1523027" translate="yes" xml:space="preserve">
          <source>Assertion fault when doing REPLACE on an index on an expression. Ticket &lt;a href=&quot;https://sqlite.org/src/info/dc3f932f5a147771&quot;&gt;dc3f932f5a147771&lt;/a&gt;</source>
          <target state="translated">式のインデックスでREPLACEを実行すると、アサーションエラーが発生します。チケット&lt;a href=&quot;https://sqlite.org/src/info/dc3f932f5a147771&quot;&gt;dc3f932f5a147771&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="14462bb4d8840870eeb8b473a0f255cc7e22e056" translate="yes" xml:space="preserve">
          <source>Assertion fault when doing an IN operator on a constant index. Ticket &lt;a href=&quot;https://sqlite.org/src/info/aa98619ad08ddcab&quot;&gt;aa98619ad08ddcab&lt;/a&gt;</source>
          <target state="translated">定数インデックスでIN演算子を実行すると、アサーションエラーが発生します。チケット&lt;a href=&quot;https://sqlite.org/src/info/aa98619ad08ddcab&quot;&gt;aa98619ad08ddcab&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6cea6f6a832fd7bbb6517d045402e777f939a795" translate="yes" xml:space="preserve">
          <source>Assigned the integer at offset 68 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt; as the &lt;a href=&quot;fileformat2#appid&quot;&gt;Application ID&lt;/a&gt; for when SQLite is used as an &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt;. Added the &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt; command to query and set the Application ID.</source>
          <target state="translated">SQLiteを&lt;a href=&quot;appfileformat&quot;&gt;アプリケーションファイル形式&lt;/a&gt;として使用する場合の&lt;a href=&quot;fileformat2#appid&quot;&gt;アプリケーションID&lt;/a&gt;として、&lt;a href=&quot;fileformat2#database_header&quot;&gt;データベースヘッダーの&lt;/a&gt;オフセット68にある整数を割り当てました。アプリケーションIDを照会および設定するための&lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt;コマンドを追加しました。</target>
        </trans-unit>
        <trans-unit id="2dc2100f672c34160990cbf608240b0f61030c73" translate="yes" xml:space="preserve">
          <source>Assuming</source>
          <target state="translated">Assuming</target>
        </trans-unit>
        <trans-unit id="ea6dcdcecbe15c6b4677215943bc88e69426e6db" translate="yes" xml:space="preserve">
          <source>Assuming no errors have occurred, then after attempting to detect and roll back a</source>
          <target state="translated">エラーが発生していないと仮定して、検出とロールバックを試みた後に</target>
        </trans-unit>
        <trans-unit id="2d3766c3aab2fade58e514ea17fb6dc49420a581" translate="yes" xml:space="preserve">
          <source>Assuming statistics are enabled, the following routine can be used to access them:</source>
          <target state="translated">統計情報が有効になっていると仮定すると、以下のルーチンを使用して統計情報にアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="836ad82865d510ff9a297c7660cf9d810b0b4728" translate="yes" xml:space="preserve">
          <source>Assuming that after registering for an unlock-notify callback a database waits for the callback to be issued before taking any further action (a reasonable assumption), then using this API may cause the application to deadlock. For example, if connection X is waiting for connection Y's transaction to be concluded, and similarly connection Y is waiting on connection X's transaction, then neither connection will proceed and the system may remain deadlocked indefinitely.</source>
          <target state="translated">unlock-notifyコールバックに登録した後、データベースがそれ以上のアクションを取る前にコールバックの発行を待つと仮定すると(合理的な仮定です)、このAPIを使用するとアプリケーションがデッドロックする可能性があります。例えば、接続 X が接続 Y のトランザクションが終了するのを待っていて、同様に接続 Y が接続 X のトランザクションを待っている場合、どちらの接続も処理が進まず、システムは無期限にデッドロックのままになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="3ba1c75f29bb0c1b541e404f389344df8b7d3190" translate="yes" xml:space="preserve">
          <source>Assuming that any and all sectors in the transient state may be corrupted following a power or system failure is a very pessimistic approach. Some modern systems provide more sophisticated guarantees than this. SQLite allows the VFS implementation to specify at runtime that the current platform supports zero or more of the following properties:</source>
          <target state="translated">過渡状態にあるすべてのセクタが、電源またはシステム障害の後に破損する可能性があると仮定することは、非常に悲観的なアプローチである。最近のシステムの中には、これよりも洗練された保証を提供しているものもあります。SQLite では、VFS の実装で、現在のプラットフォームが以下のプロパティのうちゼロ以上をサポートしていることを実行時に指定することができます。</target>
        </trans-unit>
        <trans-unit id="22e7a33261340b9207abc7f6240781daed2437d8" translate="yes" xml:space="preserve">
          <source>Assuming that customer records are stored in the &quot;customers&quot; table, and that order records are stored in the &quot;orders&quot; table, the following UPDATE trigger ensures that all associated orders are redirected when a customer changes his or her address:</source>
          <target state="translated">顧客レコードが &quot;customers &quot;テーブルに格納され、注文レコードが &quot;order &quot;テーブルに格納されていると仮定すると、以下のUPDATEトリガは、顧客が彼または彼女のアドレスを変更したときに、すべての関連する注文がリダイレクトされることを保証します。</target>
        </trans-unit>
        <trans-unit id="ff40c2070ad237bff82bd7bce4ef0b45898889d0" translate="yes" xml:space="preserve">
          <source>Assuming that the compile-time threading mode is not single-thread, then the threading mode can be changed during initialization using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface. The &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; verb puts SQLite into single-thread mode, the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; verb sets multi-thread mode, and the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt; verb sets serialized mode.</source>
          <target state="translated">コンパイル時のスレッドモードがシングルスレッドでない場合、スレッド化モードは&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;インターフェイスを使用して初期化中に変更できます。&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;シングルスレッドモードに入れSQLiteの動詞&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt;設定マルチスレッドモード動詞、及び&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt;モードをシリアライズ動詞セット。</target>
        </trans-unit>
        <trans-unit id="5e4099134714457b667c5a0d0c91727935a69b43" translate="yes" xml:space="preserve">
          <source>Assuming that the first hidden column of &quot;tablevaluedfunc&quot; is &quot;param1&quot;, the query above is semantically equivalent to this:</source>
          <target state="translated">tablevaluedfunc」の最初の隠しカラムが「param1」であると仮定すると、上のクエリは意味的にはこれと等価です。</target>
        </trans-unit>
        <trans-unit id="a392f90a65c67ef3276bb011e52cf4659579c18e" translate="yes" xml:space="preserve">
          <source>Assuming the changeset blob was created by one of the &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt;, &lt;a href=&quot;#sqlite3changeset_concat&quot;&gt;sqlite3changeset_concat()&lt;/a&gt; or &lt;a href=&quot;#sqlite3changeset_invert&quot;&gt;sqlite3changeset_invert()&lt;/a&gt; functions, all changes within the changeset that apply to a single table are grouped together. This means that when an application iterates through a changeset using an iterator created by this function, all changes that relate to a single table are visited consecutively. There is no chance that the iterator will visit a change the applies to table X, then one for table Y, and then later on visit another change for table X.</source>
          <target state="translated">チェンジセットblobが&lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3changeset_concat&quot;&gt;sqlite3changeset_concat（）、&lt;/a&gt;または&lt;a href=&quot;#sqlite3changeset_invert&quot;&gt;sqlite3changeset_invert（）&lt;/a&gt;関数のいずれかによって作成されたと仮定すると、単一のテーブルに適用されるチェンジセット内のすべての変更はグループ化されます。つまり、アプリケーションがこの関数によって作成されたイテレーターを使用してチェンジセットを反復処理すると、単一のテーブルに関連するすべての変更が連続してアクセスされます。イテレータがテーブルXに適用される変更にアクセスし、次にテーブルYに適用する変更にアクセスし、その後、テーブルXに別の変更にアクセスする可能性はありません。</target>
        </trans-unit>
        <trans-unit id="ae768e26e15e53e036c5e372149bd64f61fe40d5" translate="yes" xml:space="preserve">
          <source>Assuming the changeset blob was created by one of the &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt;, &lt;a href=&quot;sqlite3changeset_concat&quot;&gt;sqlite3changeset_concat()&lt;/a&gt; or &lt;a href=&quot;sqlite3changeset_invert&quot;&gt;sqlite3changeset_invert()&lt;/a&gt; functions, all changes within the changeset that apply to a single table are grouped together. This means that when an application iterates through a changeset using an iterator created by this function, all changes that relate to a single table are visited consecutively. There is no chance that the iterator will visit a change the applies to table X, then one for table Y, and then later on visit another change for table X.</source>
          <target state="translated">チェンジセットblobが&lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset（）&lt;/a&gt;、&lt;a href=&quot;sqlite3changeset_concat&quot;&gt;sqlite3changeset_concat（）、&lt;/a&gt;または&lt;a href=&quot;sqlite3changeset_invert&quot;&gt;sqlite3changeset_invert（）&lt;/a&gt;関数のいずれかによって作成されたと仮定すると、単一のテーブルに適用されるチェンジセット内のすべての変更はグループ化されます。つまり、アプリケーションがこの関数によって作成されたイテレーターを使用してチェンジセットを反復処理すると、単一のテーブルに関連するすべての変更が連続してアクセスされます。イテレータがテーブルXに適用される変更にアクセスし、次にテーブルYに適用する変更にアクセスし、その後、テーブルXに別の変更にアクセスする可能性はありません。</target>
        </trans-unit>
        <trans-unit id="ae27622bf93c5f8e58c667e3d2b3f8634b153cf3" translate="yes" xml:space="preserve">
          <source>Assuming the library is compiled with foreign key constraints enabled, it must still be enabled by the application at runtime, using the &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; command. For example:</source>
          <target state="translated">ライブラリが外部キー制約を有効にしてコンパイルされていると仮定すると、&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt;コマンドを使用して、実行時にアプリケーションによってライブラリを有効にする必要があります。例えば：</target>
        </trans-unit>
        <trans-unit id="4a1dda34c843a460a37b4389bc3fdea530b33452" translate="yes" xml:space="preserve">
          <source>Assuming the nominated table does exist, then its columns must be the same as or a superset of those defined for the FTS table. The external table must also be in the same database file as the FTS table. In other words, The external table cannot be in a different database file connected using &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; nor may one of the FTS table and the external content be in the TEMP database when the other is in a persistent database file such as MAIN.</source>
          <target state="translated">指定されたテーブルが存在すると仮定すると、その列は、FTSテーブルに定義されたものと同じか、そのスーパーセットである必要があります。外部テーブルも、FTSテーブルと同じデータベースファイルにある必要があります。つまり、外部テーブルは、&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;を使用して接続された別のデータベースファイルに置くことはできません。また、FTSテーブルと外部コンテンツのいずれかが、MAINなどの永続データベースファイルにある場合、TEMPデータベースに置くことはできません。</target>
        </trans-unit>
        <trans-unit id="921866ee0046d5a80db64dfb8749244f24a09ba6" translate="yes" xml:space="preserve">
          <source>Assuming the table is not also a &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless table&lt;/a&gt;, the &lt;a href=&quot;#xInstCount&quot;&gt;xInstCount&lt;/a&gt;, &lt;a href=&quot;#xInst&quot;&gt;xInst&lt;/a&gt;, &lt;a href=&quot;#xPhraseFirst&quot;&gt;xPhraseFirst&lt;/a&gt; and &lt;a href=&quot;#xPhraseNext&quot;&gt;xPhraseNext&lt;/a&gt; are slower than usual. This is because instead of reading the required data directly from the FTS index they have to load and tokenize the document text on demand.</source>
          <target state="translated">テーブルが&lt;a href=&quot;#xInstCount&quot;&gt;コンテンツなしの&lt;/a&gt;&lt;a href=&quot;fts5#contentless_tables&quot;&gt;テーブル&lt;/a&gt;でもない場合、xInstCount、&lt;a href=&quot;#xInst&quot;&gt;xInst&lt;/a&gt;、&lt;a href=&quot;#xPhraseFirst&quot;&gt;xPhraseFirst&lt;/a&gt;、および&lt;a href=&quot;#xPhraseNext&quot;&gt;xPhraseNext&lt;/a&gt;は通常よりも遅くなります。これは、必要なデータをFTSインデックスから直接読み取るのではなく、オンデマンドでドキュメントテキストをロードしてトークン化する必要があるためです。</target>
        </trans-unit>
        <trans-unit id="dc375c212f41b57083889574933fcd5e4987a611" translate="yes" xml:space="preserve">
          <source>Assuming the table is not also a contentless table, the &lt;a href=&quot;#xPhraseFirstColumn&quot;&gt;xPhraseFirstColumn&lt;/a&gt; and &lt;a href=&quot;#xPhraseNextColumn&quot;&gt;xPhraseNextColumn&lt;/a&gt; are slower than usual.</source>
          <target state="translated">テーブルが&lt;a href=&quot;#xPhraseFirstColumn&quot;&gt;コンテンツレス&lt;/a&gt;テーブルでもない場合、xPhraseFirstColumnと&lt;a href=&quot;#xPhraseNextColumn&quot;&gt;xPhraseNextColumn&lt;/a&gt;は通常より遅くなります。</target>
        </trans-unit>
        <trans-unit id="504be981e8ff80c0d63cd17a340b7f1cd587e84d" translate="yes" xml:space="preserve">
          <source>Asynchronous I/O appears to give better responsiveness, but at a price. You lose the Durable property. With the default I/O backend of SQLite, once a write completes, you know that the information you wrote is safely on disk. With the asynchronous I/O, this is not the case. If your program crashes or if a power loss occurs after the database write but before the asynchronous write thread has completed, then the database change might never make it to disk and the next user of the database might not see your change.</source>
          <target state="translated">非同期I/Oは応答性が良いように見えますが、その代償があります。耐久性のあるプロパティを失うことになります。SQLiteのデフォルトのI/Oバックエンドでは、書き込みが完了すると、書き込んだ情報がディスク上に安全に保存されていることがわかります。しかし、非同期I/Oではそうではありません。もしプログラムがクラッシュしたり、データベースへの書き込み後に電源喪失が発生した場合、非同期書き込みスレッドが完了する前に、データベースの変更がディスクに到達することはなく、データベースの次のユーザが変更を見ることはできないかもしれません。</target>
        </trans-unit>
        <trans-unit id="2c26b5cd54f0029b1a3269b19cfe3a6ff6addbcc" translate="yes" xml:space="preserve">
          <source>Asynchronous I/O works by creating an SQLite &lt;a href=&quot;c3ref/vfs&quot;&gt;VFS object&lt;/a&gt; and registering it with &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;. When files opened via this VFS are written to (using the vfs xWrite() method), the data is not written directly to disk, but is placed in the &quot;write-queue&quot; to be handled by the background thread.</source>
          <target state="translated">非同期I / Oは、SQLite &lt;a href=&quot;c3ref/vfs&quot;&gt;VFSオブジェクト&lt;/a&gt;を作成し、それを&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）に&lt;/a&gt;登録することで機能します。このVFSを介して開かれたファイルが（vfs xWrite（）メソッドを使用して）書き込まれると、データはディスクに直接書き込まれず、バックグラウンドスレッドによって処理される「書き込みキュー」に配置されます。</target>
        </trans-unit>
        <trans-unit id="4c91d5ce458c482219d3664734d8a556293b6cdf" translate="yes" xml:space="preserve">
          <source>At a shell or DOS prompt, enter: &quot;&lt;b&gt;sqlite3 test.db&lt;/b&gt;&quot;. This will create a new database named &quot;test.db&quot;. (You can use a different name if you like.)</source>
          <target state="translated">シェルまたはDOSプロンプトで、「&lt;b&gt;sqlite3 test.db&lt;/b&gt;」と入力します。これにより、「test.db」という名前の新しいデータベースが作成されます。（必要に応じて、別の名前を使用できます。）</target>
        </trans-unit>
        <trans-unit id="449f6270af54115e84fbbfac0ca3ab28ec064210" translate="yes" xml:space="preserve">
          <source>At about that same time, some avionics manufacturers were expressing interest in SQLite, which prompted the SQLite developers to design TH3 to support the rigorous testing standards of &lt;a href=&quot;https://en.wikipedia.org/wiki/DO-178B&quot;&gt;DO-178B&lt;/a&gt;.</source>
          <target state="translated">ほぼ同時に、一部のアビオニクスメーカーがSQLiteに関心を示していたため、SQLite開発者は、&lt;a href=&quot;https://en.wikipedia.org/wiki/DO-178B&quot;&gt;DO-178Bの&lt;/a&gt;厳密なテスト標準をサポートするようにTH3を設計するようになりました。</target>
        </trans-unit>
        <trans-unit id="d3fd57d066718d01302089d95d92c8454d1b5f4a" translate="yes" xml:space="preserve">
          <source>At any one time, a single table may have any number of active read-locks or a single active write lock. To read data a table, a connection must first obtain a read-lock. To write to a table, a connection must obtain a write-lock on that table. If a required table lock cannot be obtained, the query fails and SQLITE_LOCKED is returned to the caller.</source>
          <target state="translated">1つのテーブルには、アクティブなリードロックがいくつあってもよいし、アクティブなライトロックが1つあってもよい。テーブルのデータを読み込むには、接続はまずリードロックを取得しなければなりません。テーブルに書き込むには、接続はそのテーブルの書き込みロックを取得する必要があります。必要なテーブルロックを取得できなかった場合、クエリは失敗し、SQLITE_LOCKED が呼び出し元に返されます。</target>
        </trans-unit>
        <trans-unit id="b7a3b82c7cb7013957f0c0e0e4f1a6c43e18aa55" translate="yes" xml:space="preserve">
          <source>At any one time, a single table may have any number of active read-locks or a single active write lock. To read data from a table, a connection must first obtain a read-lock. To write to a table, a connection must obtain a write-lock on that table. If a required table lock cannot be obtained, the query fails and SQLITE_LOCKED is returned to the caller.</source>
          <target state="translated">1つのテーブルには、アクティブなリードロックがいくつあってもよいし、アクティブなライトロックが1つあってもよい。テーブルからデータを読み込むには、接続はまずリードロックを取得しなければなりません。テーブルに書き込むには、接続はそのテーブルの書き込みロックを取得する必要があります。必要なテーブルロックを取得できなかった場合、クエリは失敗し、SQLITE_LOCKED が呼び出し元に返されます。</target>
        </trans-unit>
        <trans-unit id="e2c8ad5daed2b52823fb4c80a495b310ef19384a" translate="yes" xml:space="preserve">
          <source>At any one time, each</source>
          <target state="translated">一度に、それぞれの</target>
        </trans-unit>
        <trans-unit id="8560f4e49c6caa4d7228201f89aa3ea44ff72f5b" translate="yes" xml:space="preserve">
          <source>At any one time, the</source>
          <target state="translated">いつの時代でも</target>
        </trans-unit>
        <trans-unit id="faefe425b3756bc94c56346d8a50b44d5ccda922" translate="yes" xml:space="preserve">
          <source>At any point in time, every page in the main database has a single use which is one of the following:</source>
          <target state="translated">いつの時点でも、メインデータベースのすべてのページには、以下のいずれかに該当する単一の用途があります。</target>
        </trans-unit>
        <trans-unit id="4998acdc6089555e0887c221354101b4a2253663" translate="yes" xml:space="preserve">
          <source>At first glance, the final two full-text queries in the example above seem to be syntactically incorrect, as there is a table name (&quot;mail&quot;) used as an SQL expression. The reason this is acceptable is that each FTS table actually has a &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;HIDDEN&lt;/a&gt; column with the same name as the table itself (in this case, &quot;mail&quot;). The value stored in this column is not meaningful to the application, but can be used as the left-hand operand to a MATCH operator. This special column may also be passed as an argument to the &lt;a href=&quot;fts3#snippet&quot;&gt;FTS auxiliary functions&lt;/a&gt;.</source>
          <target state="translated">上記の例の最後の2つのフルテキストクエリは、SQL式として使用されるテーブル名（ &quot;mail&quot;）があるため、一見すると構文的に正しくないように見えます。これが許容される理由は、各FTSテーブルに実際にはテーブル自体と同じ名前（この場合は「mail」）の&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;HIDDEN&lt;/a&gt;列があるためです。この列に格納されている値はアプリケーションにとって意味がありませんが、MATCH演算子の左側のオペランドとして使用できます。この特別な列は、&lt;a href=&quot;fts3#snippet&quot;&gt;FTS補助関数に&lt;/a&gt;引数として渡すこともできます。</target>
        </trans-unit>
        <trans-unit id="2f5836449640e20f49edf00efccee8083a6bcb35" translate="yes" xml:space="preserve">
          <source>At least szOsFile bytes of memory are allocated by SQLite to hold the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; structure passed as the third argument to xOpen. The xOpen method does not have to allocate the structure; it should just fill it in. Note that the xOpen method must set the sqlite3_file.pMethods to either a valid &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object or to NULL. xOpen must do this even if the open fails. SQLite expects that the sqlite3_file.pMethods element will be valid after xOpen returns regardless of the success or failure of the xOpen call.</source>
          <target state="translated">xOpen の3番目の引数として渡される&lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt;構造を保持するために、少なくともszOsFileバイトのメモリがSQLiteによって割り当てられます。 xOpenメソッドは構造を割り当てる必要はありません。 xOpenメソッドはsqlite3_file.pMethodsを有効な&lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;オブジェクトまたはNULLに設定する必要があることに注意してください。 xOpenは、オープンが失敗した場合でもこれを行う必要があります。 SQLiteは、xOpen呼び出しの成功または失敗に関係なく、xOpenが戻った後にsqlite3_file.pMethods要素が有効になることを期待しています。</target>
        </trans-unit>
        <trans-unit id="59514e13b273471c6ec6f5f109fedbde115ba166" translate="yes" xml:space="preserve">
          <source>At least szOsFile bytes of memory are allocated by SQLite to hold the &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; structure passed as the third argument to xOpen. The xOpen method does not have to allocate the structure; it should just fill it in. Note that the xOpen method must set the sqlite3_file.pMethods to either a valid &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object or to NULL. xOpen must do this even if the open fails. SQLite expects that the sqlite3_file.pMethods element will be valid after xOpen returns regardless of the success or failure of the xOpen call.</source>
          <target state="translated">xOpen の3番目の引数として渡される&lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt;構造を保持するために、少なくともszOsFileバイトのメモリがSQLiteによって割り当てられます。 xOpenメソッドは構造を割り当てる必要はありません。 xOpenメソッドはsqlite3_file.pMethodsを有効な&lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;オブジェクトまたはNULLに設定する必要があることに注意してください。 xOpenは、オープンが失敗した場合でもこれを行う必要があります。 SQLiteは、xOpen呼び出しの成功または失敗に関係なく、xOpenが戻った後にsqlite3_file.pMethods要素が有効になることを期待しています。</target>
        </trans-unit>
        <trans-unit id="5cf0c7d5d4e31a3622d3bed10cffc599203f902a" translate="yes" xml:space="preserve">
          <source>At most one connection to a single shared cache may open a write transaction at any one time. This may co-exist with any number of read transactions.</source>
          <target state="translated">単一の共有キャッシュへの接続は最大でも一度に一つの書き込みトランザクションを開くことができます。これは任意の数のリードトランザクションと共存することができます。</target>
        </trans-unit>
        <trans-unit id="2549fa7b8565911915cfbc5b3b9d42147224732f" translate="yes" xml:space="preserve">
          <source>At one point, &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; was sometimes licensed to third-parties. Such licensing no longer occurs. However, back when it was occurring, some of the TH3 test cases contained information that was sensitive and could not be released even to licensees. This sensitive information is stored in yet another repository.</source>
          <target state="translated">ある時点で、&lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt;はサードパーティにライセンス供与されることがありました。このようなライセンスは発生しなくなりました。ただし、TH3のテストケースの一部には、機密情報が含まれており、ライセンシーにも公開できない情報が含まれていました。この機密情報はさらに別のリポジトリに保存されます。</target>
        </trans-unit>
        <trans-unit id="4d936f8adee7e8e3dc2d8a9b26c4bae945a9dd4c" translate="yes" xml:space="preserve">
          <source>At present, there is only one option that may be configured using this function. (See &lt;a href=&quot;#sqlitevtabconstraintsupport&quot;&gt;SQLITE_VTAB_CONSTRAINT_SUPPORT&lt;/a&gt;.) Further options may be added in the future.</source>
          <target state="translated">現在、この機能を使用して設定できるオプションは1つだけです。（&lt;a href=&quot;#sqlitevtabconstraintsupport&quot;&gt;SQLITE_VTAB_CONSTRAINT_SUPPORTを&lt;/a&gt;参照してください。）将来、さらにオプションが追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="e0662b7a2bebf7dce7d12510693eb67ca1548c61" translate="yes" xml:space="preserve">
          <source>At present, there is only one option that may be configured using this function. (See &lt;a href=&quot;c_vtab_constraint_support#sqlitevtabconstraintsupport&quot;&gt;SQLITE_VTAB_CONSTRAINT_SUPPORT&lt;/a&gt;.) Further options may be added in the future.</source>
          <target state="translated">現在、この機能を使用して設定できるオプションは1つだけです。（&lt;a href=&quot;c_vtab_constraint_support#sqlitevtabconstraintsupport&quot;&gt;SQLITE_VTAB_CONSTRAINT_SUPPORTを&lt;/a&gt;参照してください。）将来、さらにオプションが追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="598f95760d8ef9fc04e0c94379f28c6b7cd53470" translate="yes" xml:space="preserve">
          <source>At the beginning of a cache spill, the status of the database connection is as shown in &lt;a href=&quot;#section_3_6&quot;&gt;step 3.6&lt;/a&gt;. Original page content has been saved in the rollback journal and modifications of the pages exist in user memory. To spill the cache, SQLite executes steps &lt;a href=&quot;#section_3_7&quot;&gt;3.7&lt;/a&gt; through &lt;a href=&quot;#section_3_9&quot;&gt;3.9&lt;/a&gt;. In other words, the rollback journal is flushed to disk, an exclusive lock is acquired, and changes are written into the database. But the remaining steps are deferred until the transaction really commits. A new journal header is appended to the end of the rollback journal (in its own sector) and the exclusive database lock is retained, but otherwise processing returns to &lt;a href=&quot;#section_3_6&quot;&gt;step 3.6&lt;/a&gt;. When the transaction commits, or if another cache spill occurs, steps &lt;a href=&quot;#section_3_7&quot;&gt;3.7&lt;/a&gt; and &lt;a href=&quot;#section_3_9&quot;&gt;3.9&lt;/a&gt; are repeated. (Step &lt;a href=&quot;#section_3_8&quot;&gt;3.8&lt;/a&gt; is omitted on second and subsequent passes since an exclusive database lock is already held due to the first pass.)</source>
          <target state="translated">キャッシュスピルの開始時のデータベース接続のステータスは、&lt;a href=&quot;#section_3_6&quot;&gt;ステップ3.6に&lt;/a&gt;示すとおりです。元のページのコンテンツはロールバックジャーナルに保存され、ページの変更はユーザーメモリに存在します。キャッシュをこぼすために、SQLiteはステップ&lt;a href=&quot;#section_3_7&quot;&gt;3.7&lt;/a&gt;から&lt;a href=&quot;#section_3_9&quot;&gt;3.9を&lt;/a&gt;実行します。つまり、ロールバックジャーナルがディスクにフラッシュされ、排他ロックが取得され、変更がデータベースに書き込まれます。しかし、残りのステップは、トランザクションが実際にコミットされるまで延期されます。新しいジャーナルヘッダーがロールバックジャーナルの最後（独自のセクター内）に追加され、排他的なデータベースロックが保持されますが、それ以外の場合、処理は&lt;a href=&quot;#section_3_6&quot;&gt;ステップ3.6に&lt;/a&gt;戻ります。トランザクションがコミットしたとき、または別のキャッシュスピルが発生した場合は、ステップ&lt;a href=&quot;#section_3_7&quot;&gt;3.7&lt;/a&gt;と&lt;a href=&quot;#section_3_9&quot;&gt;3.9&lt;/a&gt;が繰り返されます。（最初のパスのために排他的なデータベースロックが既に保持されているため、2番目以降のパスではステップ&lt;a href=&quot;#section_3_8&quot;&gt;3.8&lt;/a&gt;は省略されます。）</target>
        </trans-unit>
        <trans-unit id="a07c0967c09d3dbc3e32b1c4ad8479eec1c47ba2" translate="yes" xml:space="preserve">
          <source>At this point you are ready to type &quot;&lt;code&gt;./configure; make&lt;/code&gt;&quot; (or on Windows with MSVC, &quot;&lt;code&gt;nmake /f Makefile.msc&lt;/code&gt;&quot;).</source>
          <target state="translated">この時点で、「 &lt;code&gt;./configure; make&lt;/code&gt; 」（またはMSVCを使用するWindowsでは「 &lt;code&gt;nmake /f Makefile.msc&lt;/code&gt; 」）と入力する準備ができています。</target>
        </trans-unit>
        <trans-unit id="5d9739e0c9d62ebb2f85f2435395edecdd3fc346" translate="yes" xml:space="preserve">
          <source>At this point, you can measure the amount of disk space used by the test1.db database and the space used by the test1.dir directory and all of its content. On a standard Ubuntu Linux desktop, the database file will be 1,024,512,000 bytes in size and the test1.dir directory will use 1,228,800,000 bytes of space (according to &quot;du -k&quot;), about 20% more than the database.</source>
          <target state="translated">この時点で、test1.dbデータベースが使用するディスク容量と、test1.dirディレクトリとそのすべてのコンテンツが使用するディスク容量を測定することができます。標準的なUbuntu Linuxデスクトップでは、データベースファイルのサイズは1,024,512,000バイトで、test1.dirディレクトリは1,228,800,000バイトのスペースを使用します(&quot;du -k &quot;によると)。</target>
        </trans-unit>
        <trans-unit id="05593853b78d4288d0ab3317d42f66fcc3356044" translate="yes" xml:space="preserve">
          <source>At this point, you should understand the VDBE well enough to figure out on your own how the above program works. So we will not discuss it further in this text.</source>
          <target state="translated">この時点で、上のプログラムがどのように動作するかを自分で把握するために、VDBEを十分に理解しておく必要があります。そのため、本文中ではこれ以上は触れないことにする。</target>
        </trans-unit>
        <trans-unit id="7ed93611b051b3f2ce2f2e18dd2aa20d02819e82" translate="yes" xml:space="preserve">
          <source>At this point, you should understand the basics of how the VDBE writes to a database. Now let's look at how it does queries. We will use the following simple SELECT statement as our example:</source>
          <target state="translated">この時点で、VDBEがデータベースに書き込む方法の基本を理解しているはずである。ここでは、クエリをどのように実行するかを見てみよう。以下の単純なSELECT文を例に説明する。</target>
        </trans-unit>
        <trans-unit id="ca131936c53e26b047834300b8b5909015686af9" translate="yes" xml:space="preserve">
          <source>At this time SQLite supports only FOR EACH ROW triggers, not FOR EACH STATEMENT triggers. Hence explicitly specifying FOR EACH ROW is optional. FOR EACH ROW implies that the SQL statements specified in the trigger may be executed (depending on the WHEN clause) for each database row being inserted, updated or deleted by the statement causing the trigger to fire.</source>
          <target state="translated">現時点では、SQLite は FOR EACH ROW トリガーのみをサポートしており、FOR EACH STATEMENT トリガーはサポートしていません。したがって、FOR EACH ROW を明示的に指定することはオプションです。FOR EACH ROWは、トリガで指定されたSQL文が、トリガを発生させる文によって挿入、更新、削除される各データベース行に対して(WHEN句に応じて)実行される可能性があることを意味します。</target>
        </trans-unit>
        <trans-unit id="9f2f2ddc27722f56f60ce157d4213f6b2caed0bd" translate="yes" xml:space="preserve">
          <source>At this writing, 2050 is still 34 years in the future. Nobody knows what will happen in that time, and we cannot absolutely promise that SQLite will be viable or useful that far out. But we can promise this: we plan as if we will be supporting SQLite until 2050. That long-term outlook affects our decisions in important ways.</source>
          <target state="translated">この記事を書いている時点では、2050年はまだ34年先の未来です。その時に何が起こるかは誰にもわかりませんし、SQLiteがその先で実行可能であることや有用であることを絶対的に約束することはできません。しかし、2050年までSQLiteをサポートしているかのように計画しています。この長期的な見通しは、私たちの意思決定に重要な影響を与えます。</target>
        </trans-unit>
        <trans-unit id="5dc594be0856868f818e54abe920fd51cc599639" translate="yes" xml:space="preserve">
          <source>Atomic Commit In SQLite</source>
          <target state="translated">SQLite でのアトミックコミット</target>
        </trans-unit>
        <trans-unit id="2d4c9569233db52020accb44326c29045c8c4cce" translate="yes" xml:space="preserve">
          <source>Atomic Transactions</source>
          <target state="translated">原子間取引</target>
        </trans-unit>
        <trans-unit id="01c8139f3cad23c8756bfadca13473ed3a8e76ee" translate="yes" xml:space="preserve">
          <source>Atomic commits for ATTACHed databases.</source>
          <target state="translated">ATTACHEDデータベースのためのアトミックコミット。</target>
        </trans-unit>
        <trans-unit id="d81553de52fcfae8fe4cc1bad5f59236dea06c3f" translate="yes" xml:space="preserve">
          <source>Atomically releases the mutex and begins waiting for the asynchronous signal. When the signal arrives, continue.</source>
          <target state="translated">アトミックにミューテックスを解放し、非同期信号の待機を開始します。シグナルが到着したら、続行します。</target>
        </trans-unit>
        <trans-unit id="92dd7a0665a3434edc8f121885515c600f18e15b" translate="yes" xml:space="preserve">
          <source>Attach A Table To A Session Object</source>
          <target state="translated">セッションオブジェクトにテーブルを添付する</target>
        </trans-unit>
        <trans-unit id="4d752510d48bfeb2c136d1e65419fdd66d0835e6" translate="yes" xml:space="preserve">
          <source>Attempt To Free Heap Memory</source>
          <target state="translated">ヒープメモリの解放の試み</target>
        </trans-unit>
        <trans-unit id="88ccf4926dcde2d4398cadb109fcd1c1c1205d36" translate="yes" xml:space="preserve">
          <source>Attempt to optimize the database. All schemas are optimized in the first two forms, and only the specified schema is optimized in the latter two.</source>
          <target state="translated">データベースの最適化を試みます。前者の2つの形式ではすべてのスキーマが最適化され、後者の2つでは指定されたスキーマのみが最適化されます。</target>
        </trans-unit>
        <trans-unit id="72b5f89658d37542e4f2f47adfbbada66e9f74c3" translate="yes" xml:space="preserve">
          <source>Attempt to return the underlying operating system error code or error number that caused the most recent I/O error or failure to open a file. The return value is OS-dependent. For example, on unix systems, after &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt;, this interface could be called to get back the underlying &quot;errno&quot; that caused the problem, such as ENOSPC, EAUTH, EISDIR, and so forth.</source>
          <target state="translated">最新のI / Oエラーまたはファイルを開くことができなかった原因となっているオペレーティングシステムのエラーコードまたはエラー番号を返そうとしました。戻り値はOSに依存します。たとえば、UNIXシステムでは、&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;が&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPENを&lt;/a&gt;返した後、このインターフェイスを呼び出して、ENOSPC、EAUTH、EISDIRなど、問題の原因となった根本的な「errno」を取得できます。</target>
        </trans-unit>
        <trans-unit id="50dfefcf7c07518a2714e6179a3b3e2c44246560" translate="yes" xml:space="preserve">
          <source>Attempt to return the underlying operating system error code or error number that caused the most recent I/O error or failure to open a file. The return value is OS-dependent. For example, on unix systems, after &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; returns &lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt;, this interface could be called to get back the underlying &quot;errno&quot; that caused the problem, such as ENOSPC, EAUTH, EISDIR, and so forth.</source>
          <target state="translated">最新のI / Oエラーまたはファイルを開くことができなかった原因となっているオペレーティングシステムのエラーコードまたはエラー番号を返そうとしました。戻り値はOSに依存します。たとえば、UNIXシステムでは、&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;が&lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPENを&lt;/a&gt;返した後、このインターフェイスを呼び出して、ENOSPC、EAUTH、EISDIRなど、問題の原因となった根本的な「errno」を取得できます。</target>
        </trans-unit>
        <trans-unit id="316c0eb6ee34ebe2465e653e0615de6cea48d923" translate="yes" xml:space="preserve">
          <source>Attempting to read any column value except the rowid from a contentless FTS5 table returns an SQL NULL value.</source>
          <target state="translated">内容のない FTS5 テーブルから rowid 以外の列の値を読み出そうとすると、SQL NULL 値が返されます。</target>
        </trans-unit>
        <trans-unit id="759ff226aedc6e7693575bc9de2859284a195a00" translate="yes" xml:space="preserve">
          <source>Attempts to signal a waiting thread.</source>
          <target state="translated">待機中のスレッドにシグナルを送ろうとします。</target>
        </trans-unit>
        <trans-unit id="70c4d17e8ff8b4302eac4e4e2a0df21e83e7e1f7" translate="yes" xml:space="preserve">
          <source>Attribute to God, and not to self, whatever good you see in yourself.</source>
          <target state="translated">自分自身ではなく、神に、自分の中にある善は何であれ、自分自身ではなく、神に帰属させなさい。</target>
        </trans-unit>
        <trans-unit id="825e25e0e089626089745a27ce2ef2c2c1ea38e6" translate="yes" xml:space="preserve">
          <source>Authorizer Action Codes</source>
          <target state="translated">承認者アクションコード</target>
        </trans-unit>
        <trans-unit id="1592d27599a37fb2c21560009556822d633223ac" translate="yes" xml:space="preserve">
          <source>Authorizer Return Codes</source>
          <target state="translated">認証元のリターンコード</target>
        </trans-unit>
        <trans-unit id="8d4b099d8f18d61aaa97d7c1192205d9f09f6d1b" translate="yes" xml:space="preserve">
          <source>Authorizer callback now notified of ALTER TABLE ADD COLUMN commands</source>
          <target state="translated">ALTER TABLE ADD COLUMN コマンドの認可コールバックが通知されるようになりました。</target>
        </trans-unit>
        <trans-unit id="f99108c69c3665b09cc818cd43a65b08e779b2ac" translate="yes" xml:space="preserve">
          <source>Auto-vacuuming is only possible if the database stores some additional information that allows each database page to be traced backwards to its referrer. Therefore, auto-vacuuming must be turned on before any tables are created. It is not possible to enable or disable auto-vacuum after a table has been created.</source>
          <target state="translated">自動バキューム機能は、データベースが各データベースページをその参照元までさかのぼってトレースできるようにするための追加情報を保存している場合にのみ可能です。したがって、テーブルが作成される前に自動バキュームを有効にしなければなりません。テーブルが作成された後に自動バキュームを有効にしたり無効にしたりすることはできません。</target>
        </trans-unit>
        <trans-unit id="20745b1bcf8af10b98b427193825b087099c77ec" translate="yes" xml:space="preserve">
          <source>AutoCommit</source>
          <target state="translated">AutoCommit</target>
        </trans-unit>
        <trans-unit id="356d8f675fe3749abf68433babe7ea3575fd985f" translate="yes" xml:space="preserve">
          <source>Autocheckpointing is enabled by default with an interval of 1000 or &lt;a href=&quot;compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt;.</source>
          <target state="translated">自動チェックポイントはデフォルトで1000または&lt;a href=&quot;compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINTの&lt;/a&gt;間隔で有効になっています。</target>
        </trans-unit>
        <trans-unit id="22f681c869bb1ea71c5ddca4b639af93b4fef9e9" translate="yes" xml:space="preserve">
          <source>Autoincrement now works for INSERT from a SELECT.</source>
          <target state="translated">オートインクリメントがSELECTからのINSERTで動作するようになりました。</target>
        </trans-unit>
        <trans-unit id="be6b6b970c4ffe43f44cd98c8c080e19e0935d7d" translate="yes" xml:space="preserve">
          <source>Automatic Creation Of Triggers</source>
          <target state="translated">トリガーの自動作成</target>
        </trans-unit>
        <trans-unit id="b08dba6041d7d4235968c19294ed55fda427f921" translate="yes" xml:space="preserve">
          <source>Automatic Undo/Redo Using SQLite</source>
          <target state="translated">SQLiteを使用した自動元に戻す/やり直し</target>
        </trans-unit>
        <trans-unit id="e4c6cb294be7b858504d17f8ae3afc2b1d34ca14" translate="yes" xml:space="preserve">
          <source>Automatic Undo/Redo With SQLite</source>
          <target state="translated">SQLite を使用した自動元に戻す/やり直し</target>
        </trans-unit>
        <trans-unit id="21544829b41ef1983cd743adcc40b46678a3e3f5" translate="yes" xml:space="preserve">
          <source>Automatic caching of prepared statements in the TCL interface</source>
          <target state="translated">TCLインターフェースでの準備されたステートメントの自動キャッシング</target>
        </trans-unit>
        <trans-unit id="5c31289d03ed4b24b0edaf412e508ce77bc130da" translate="yes" xml:space="preserve">
          <source>Automatic indexing</source>
          <target state="translated">自動インデックス化</target>
        </trans-unit>
        <trans-unit id="b33bad308a6a3f5703b3375cd2f0464df392fd4f" translate="yes" xml:space="preserve">
          <source>Automatically Load Statically Linked Extensions</source>
          <target state="translated">静的にリンクされた拡張機能を自動的に読み込む</target>
        </trans-unit>
        <trans-unit id="1866c31db7344041c61c845f3e6c7f6209984d28" translate="yes" xml:space="preserve">
          <source>Automatically Running ANALYZE</source>
          <target state="translated">自動的に実行されるANALYZE</target>
        </trans-unit>
        <trans-unit id="4babc7f522c90b701f1e40024660f0e6d3fdb828" translate="yes" xml:space="preserve">
          <source>Automatically build binaries for Linux and Windows and put them on the website.</source>
          <target state="translated">LinuxやWindows用のバイナリを自動的にビルドしてWebサイトに載せる。</target>
        </trans-unit>
        <trans-unit id="b5a9f83671a7145cd855649b0b10c0da797dd48a" translate="yes" xml:space="preserve">
          <source>Automatically generated ROWIDs are now sequential.</source>
          <target state="translated">自動生成されたROWIDがシーケンシャルになりました。</target>
        </trans-unit>
        <trans-unit id="33b507ce65fb930f163c0cce40902e91ce9a4aa2" translate="yes" xml:space="preserve">
          <source>Automatically intercepts the raw &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; output and reformats it into an ASCII-art graph.</source>
          <target state="translated">生の&lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;出力を自動的にインターセプトし、ASCIIアートグラフに再フォーマットします。</target>
        </trans-unit>
        <trans-unit id="415678a6fe9db48ebfdb4a92834062e2d75ff761" translate="yes" xml:space="preserve">
          <source>Automatically running ANALYZE</source>
          <target state="translated">自動的に実行されるANALYZE</target>
        </trans-unit>
        <trans-unit id="38a90bc3ee0845edb1d6db34dc8f58cfefb8e89a" translate="yes" xml:space="preserve">
          <source>Autovacuum support added</source>
          <target state="translated">自動バキュームのサポートが追加されました。</target>
        </trans-unit>
        <trans-unit id="1e357312422cd5ec59a0a1ff553c35208f6f0981" translate="yes" xml:space="preserve">
          <source>Auxiliary Function Changes</source>
          <target state="translated">補助機能の変更</target>
        </trans-unit>
        <trans-unit id="2291a1b828f145bde8901e514ec4c748f1d3e7aa" translate="yes" xml:space="preserve">
          <source>Auxiliary columns are marked with a &quot;+&quot; symbol before the column name. Auxiliary columns must come after all of the coordinate boundary columns. There is a limit of no more than 100 auxiliary columns. The following example shows an r-tree table with auxiliary columns that is equivalent to the two tables &quot;demo_index&quot; and &quot;demo_data&quot; above:</source>
          <target state="translated">補助列は、 列名の前に 「+」 記号を付けます。補助列は、 すべての座標境界列の後に来る必要があります。補助列の数には100個以下の制限があります。次の例は、上記の2つのテーブル &quot;demo_index &quot;と &quot;demo_data &quot;と同等の補助列を持つr-treeテーブルを示しています。</target>
        </trans-unit>
        <trans-unit id="107b868f1f6fb032b0de401c1fdc39f9a1324503" translate="yes" xml:space="preserve">
          <source>Auxiliary columns in r-tree tables</source>
          <target state="translated">r-tree テーブルの補助カラム</target>
        </trans-unit>
        <trans-unit id="6771e220703ae7d95117926a910b1882f3865ed2" translate="yes" xml:space="preserve">
          <source>Auxiliary function mapping</source>
          <target state="translated">補助関数マッピング</target>
        </trans-unit>
        <trans-unit id="2a6030396538d218b7dda424404dbcc0322cf175" translate="yes" xml:space="preserve">
          <source>Auxiliary functions are similar to &lt;a href=&quot;lang_corefunc&quot;&gt;SQL scalar functions&lt;/a&gt;, except that they may only be used within full-text queries (those that use the MATCH operator) on an FTS5 table. Their results are calculated based not only on the arguments passed to them, but also on the current match and matched row. For example, an auxiliary function may return a numeric value indicating the accuracy of the match (see the &lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25()&lt;/a&gt; function), or a fragment of text from the matched row that contains one or more instances of the search terms (see the &lt;a href=&quot;fts5#the_snippet_function&quot;&gt;snippet()&lt;/a&gt; function).</source>
          <target state="translated">補助関数は、&lt;a href=&quot;lang_corefunc&quot;&gt;SQLスカラー関数に&lt;/a&gt;似ていますが、FTS5テーブルのフルテキストクエリ（MATCH演算子を使用するクエリ）内でのみ使用できる点が異なります。結果は、渡された引数だけでなく、現在の一致および一致した行にも基づいて計算されます。たとえば、補助関数は、一致の正確さを示す数値（&lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25（）&lt;/a&gt;関数を参照）、または検索語の1つ以上のインスタンスを含む一致した行からのテキストのフラグメントを返します（&lt;a href=&quot;fts5#the_snippet_function&quot;&gt;snippet（ ）&lt;/a&gt;関数）。</target>
        </trans-unit>
        <trans-unit id="ad21e0c1521884ee05b9ffda048d19b6293bf5a4" translate="yes" xml:space="preserve">
          <source>Available as a &lt;a href=&quot;amalgamation&quot;&gt;single ANSI-C source-code file&lt;/a&gt; that is &lt;a href=&quot;howtocompile&quot;&gt;easy to compile&lt;/a&gt; and hence is easy to add into a larger project.</source>
          <target state="translated">入手可能な&lt;a href=&quot;amalgamation&quot;&gt;単ANSI-Cソースコードファイル&lt;/a&gt;で&lt;a href=&quot;howtocompile&quot;&gt;コンパイルすることが容易で&lt;/a&gt;、従って、より大きなプロジェクトに追加することは容易です。</target>
        </trans-unit>
        <trans-unit id="91da5ef1fa7e2e4b29d2c4baf5ea203498773356" translate="yes" xml:space="preserve">
          <source>Avoid a possible use-after-free error by deferring schema resets until after the query planner has finished running. Ticket &lt;a href=&quot;https://sqlite.org/src/info/be436a7f4587ce5&quot;&gt;be436a7f4587ce5&lt;/a&gt;</source>
          <target state="translated">クエリプランナーの実行が完了するまでスキーマのリセットを延期することで、解放後の使用エラーの可能性を回避します。チケット&lt;a href=&quot;https://sqlite.org/src/info/be436a7f4587ce5&quot;&gt;be436a7f4587ce5&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1e3177c978c905dc59ea3eac3bcce9510d2af169" translate="yes" xml:space="preserve">
          <source>Avoid cache pages leaks following disk-full or I/O errors</source>
          <target state="translated">ディスクがいっぱいになったり、I/Oエラーが発生した場合のキャッシュページの漏れを防ぐ</target>
        </trans-unit>
        <trans-unit id="61ddd5eec59e56887e4ac83b6d688d5421fe618d" translate="yes" xml:space="preserve">
          <source>Avoid excess heap usage when copying expressions.</source>
          <target state="translated">式をコピーする際にヒープを過剰に使用しないようにします。</target>
        </trans-unit>
        <trans-unit id="24ba1f7d7979447a7e96cb25e07064d86e5bb1c8" translate="yes" xml:space="preserve">
          <source>Avoid invoking the &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace()&lt;/a&gt; callback multiple times when a statement is automatically reprepared due to &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; errors.</source>
          <target state="translated">&lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt;エラーのためにステートメントが自動的に再準備される場合は、&lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace（）&lt;/a&gt;コールバックを複数回呼び出すことを避けます。</target>
        </trans-unit>
        <trans-unit id="7080f3e1eff1f709a6ca19cf689cc05b5715bf56" translate="yes" xml:space="preserve">
          <source>Avoid recomputing &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt; and &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt; on unchanged columns in &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement.</source>
          <target state="translated">&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;ステートメントの変更&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;さ&lt;/a&gt;れていない列に対する&lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt;およびCHECK制約の再計算を避けます。</target>
        </trans-unit>
        <trans-unit id="b9f47e376b982a42c816c624a45b787e38257b92" translate="yes" xml:space="preserve">
          <source>Avoid resetting the schema of &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; connections when any one connection closes. Instead, wait for the last connection to close before resetting the schema.</source>
          <target state="translated">1つの接続が閉じたときに、&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュ&lt;/a&gt;接続のスキーマをリセットしないでください。代わりに、最後の接続が閉じるのを待ってから、スキーマをリセットしてください。</target>
        </trans-unit>
        <trans-unit id="d3426fcb94fc158c5d46e9b08cc237640ca2e54e" translate="yes" xml:space="preserve">
          <source>Avoid running foreign-key constraint checks on an UPDATE if none of the modified columns are associated with foreign keys.</source>
          <target state="translated">変更された列が外部キーに関連付けられていない場合は、UPDATEで外部キー制約チェックを実行しないようにします。</target>
        </trans-unit>
        <trans-unit id="fc8f5db6ab5f0aaaf5afe5d9db180abf76160161" translate="yes" xml:space="preserve">
          <source>Avoid this step if possible, as it defeats one of the huge advantages of the whole SQL language concept, specifically that the application programmer does not need to get involved with query planning. If you do use CROSS JOIN, wait until late in your development cycle to do so, and comment the use of CROSS JOIN carefully so that you can take it out later if possible. Avoid using CROSS JOIN early in the development cycle as doing so is a premature optimization, which is well known to be &lt;a href=&quot;http://c2.com/cgi/wiki?PrematureOptimization&quot;&gt;the root of all evil&lt;/a&gt;.</source>
          <target state="translated">このステップは、SQL言語の概念全体の大きな利点の1つを無効にするため、可能であれば避けてください。具体的には、アプリケーションプログラマーがクエリの計画に関与する必要がないためです。CROSS JOINを使用する場合は、開発サイクルの後半まで待機し、CROSS JOINの使用をコメントアウトして、可能であれば後で使用できるようにします。開発サイクルの早い段階でCROSS JOINを使用することは避けてください。これは時期尚早の最適化であり&lt;a href=&quot;http://c2.com/cgi/wiki?PrematureOptimization&quot;&gt;、すべての悪の根である&lt;/a&gt;ことがよく知られています。</target>
        </trans-unit>
        <trans-unit id="d522f897af88e992f364f85aee2e8282258fc265" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary foreign key processing in UPDATE statements that do not touch the columns that are constrained by the foreign keys.</source>
          <target state="translated">UPDATE文での不要な外部キー処理を回避し、外部キーで制約されている列には触れないようにします。</target>
        </trans-unit>
        <trans-unit id="f0262f30f0e72ef13d068b5ef0d92433c9097800" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary invalidation of &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; handles when making changes to unrelated tables.</source>
          <target state="translated">関連のないテーブルに変更を加えるときに、&lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt;ハンドルの不要な無効化を回避します。</target>
        </trans-unit>
        <trans-unit id="2faf372496683418fb5422fedd49afd1602aeb2d" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary loads of columns in an aggregate query that are not within an aggregate function and that are not part of the GROUP BY clause.</source>
          <target state="translated">集約関数内ではなく、GROUP BY 句の一部でもないカラムを集約クエリで不必要にロードしないようにします。</target>
        </trans-unit>
        <trans-unit id="0da85f25c4d81aabb9be26649b6528ed9da5a865" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary reparsing of the database schema.</source>
          <target state="translated">データベーススキーマの不必要なリパーシングを回避します。</target>
        </trans-unit>
        <trans-unit id="31ab1c695488dd1d3fd9d54bae9338af8b817457" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary writes to the sqlite_sequence table when an &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; table is updated with an rowid that is less than the maximum.</source>
          <target state="translated">&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;テーブルが最大値よりも小さいROWIDで更新される場合、sqlite_sequenceテーブルへの不要な書き込みを回避します。</target>
        </trans-unit>
        <trans-unit id="446e18ff4fd4514774047f13cdefc3e3875bc4b1" translate="yes" xml:space="preserve">
          <source>Avoid using a prepared statement for &quot;.stats on&quot; command of the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; after it has been closed by the &quot;.eqp full&quot; logicc. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/7be932dfa60a8a6b3b26bcf76&quot;&gt;7be932dfa60a8a6b3b26bcf76&lt;/a&gt;.</source>
          <target state="translated">「.eqp full」logiccによって閉じられた後、&lt;a href=&quot;cli&quot;&gt;CLIの&lt;/a&gt;「.stats on」コマンドの準備済みステートメントを使用しないでください。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/7be932dfa60a8a6b3b26bcf76&quot;&gt;7be932dfa60a8a6b3b26bcf76の&lt;/a&gt;修正。</target>
        </trans-unit>
        <trans-unit id="e234fd1edb94740adc1207ebef38597b49b7c1f2" translate="yes" xml:space="preserve">
          <source>Avoiding the use of low-numbered file descriptors is a defense against accidental database corruption. If a database file was opened using file descriptor 2, for example, and then an assert() failed and invoked write(2,...), that would likely cause database corruption by overwriting part of the database file with the assertion error message. Using only higher-valued file descriptors avoids this potential problem. The protection against using low-numbered file descriptors can be disabled by setting this compile-time option to 0.</source>
          <target state="translated">番号の低いファイルディスクリプタの使用を避けることは、偶発的なデータベースの破損に対する防御策です。例えば、ファイルディスクリプタ2を使用してデータベースファイルを開いた後、assert()が失敗してwrite(2,...)が呼び出された場合、アサーションエラーメッセージでデータベースファイルの一部が上書きされ、データベースが破損する可能性があります。より高い値のファイルディスクリプタのみを使用することで、この潜在的な問題を回避することができます。このコンパイル時オプションを 0 に設定することで、番号の低いファイルディスクリプタの使用に対する保護を無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="a4253b60bc870d118d832ba2a3c8eabe133ebeb0" translate="yes" xml:space="preserve">
          <source>Aways stores polygons using the binary format, which is faster and uses less space.</source>
          <target state="translated">Awaysは、バイナリ形式を使用してポリゴンを格納します。</target>
        </trans-unit>
        <trans-unit id="209ebb59c54866e4ac4c2bdf04c9d0b7b4a958ec" translate="yes" xml:space="preserve">
          <source>B-Tree</source>
          <target state="translated">B-Tree</target>
        </trans-unit>
        <trans-unit id="b149afb9ac3420444ce1e62aefbcdead10e7e777" translate="yes" xml:space="preserve">
          <source>B-tree</source>
          <target state="translated">B-tree</target>
        </trans-unit>
        <trans-unit id="5b87dc158f4c367648401e86eddf1c6445bb5bf6" translate="yes" xml:space="preserve">
          <source>B-tree Cell Format</source>
          <target state="translated">B-tree セル形式</target>
        </trans-unit>
        <trans-unit id="92950af5441bd3255130ef7a72cc86532e49b1e9" translate="yes" xml:space="preserve">
          <source>B-tree Page Header Format</source>
          <target state="translated">B-treeページヘッダー形式</target>
        </trans-unit>
        <trans-unit id="90a72ea1d2706a588dd39ad58e7cba99ec26696d" translate="yes" xml:space="preserve">
          <source>BEFORE</source>
          <target state="translated">BEFORE</target>
        </trans-unit>
        <trans-unit id="3598517c826f1480a241800ce73f781ae2b1cd6a" translate="yes" xml:space="preserve">
          <source>BEGIN</source>
          <target state="translated">BEGIN</target>
        </trans-unit>
        <trans-unit id="4821edeb87e72ffadc6bc2dd7758d1af495e515f" translate="yes" xml:space="preserve">
          <source>BEGIN IMMEDIATE</source>
          <target state="translated">即時開始</target>
        </trans-unit>
        <trans-unit id="8913dda08c8185748e987da82c484c6d35030cb9" translate="yes" xml:space="preserve">
          <source>BEGIN TRANSACTION</source>
          <target state="translated">トランザクションを開始する</target>
        </trans-unit>
        <trans-unit id="51b1b0c3e98b1211a4bf44a668731efbeb0029e7" translate="yes" xml:space="preserve">
          <source>BEGIN;</source>
          <target state="translated">BEGIN;</target>
        </trans-unit>
        <trans-unit id="f8e3370718865431368fd54f746d7da4322cc582" translate="yes" xml:space="preserve">
          <source>BETWEEN</source>
          <target state="translated">BETWEEN</target>
        </trans-unit>
        <trans-unit id="2d0fe684054a53889de74128877e23cf3189b322" translate="yes" xml:space="preserve">
          <source>BIGINT</source>
          <target state="translated">BIGINT</target>
        </trans-unit>
        <trans-unit id="d05fb01e0b399387c3a28586f5fd296e2670d6a3" translate="yes" xml:space="preserve">
          <source>BINARY</source>
          <target state="translated">BINARY</target>
        </trans-unit>
        <trans-unit id="1ce04f29dadb9973458555f164627f66e504686e" translate="yes" xml:space="preserve">
          <source>BLOB</source>
          <target state="translated">BLOB</target>
        </trans-unit>
        <trans-unit id="21ca9d91ce78c58717f1f26654ca03e2a7b624ba" translate="yes" xml:space="preserve">
          <source>BLOB (a.k.a &quot;NONE&quot;)</source>
          <target state="translated">ブローブ</target>
        </trans-unit>
        <trans-unit id="16304f06bca682f9f5ee4a2a62fcbf2abac5ed50" translate="yes" xml:space="preserve">
          <source>BLOB literals are string literals containing hexadecimal data and preceded by a single &quot;x&quot; or &quot;X&quot; character. Example: X'53514C697465'</source>
          <target state="translated">BLOBリテラルは、16進数データを含む文字列リテラルで、前に &quot;x &quot;または &quot;X &quot;の文字が1つ付いています。例 X'53514C697465'</target>
        </trans-unit>
        <trans-unit id="fb465d6672ffe8826d619cf7ad2f842e941cbb22" translate="yes" xml:space="preserve">
          <source>BLOB size</source>
          <target state="translated">BLOBサイズ</target>
        </trans-unit>
        <trans-unit id="80845ed51d0eb2f39da54fe848593b51f5b7523f" translate="yes" xml:space="preserve">
          <source>BLOB support.</source>
          <target state="translated">BLOBに対応しています。</target>
        </trans-unit>
        <trans-unit id="9bf36d55a66f6b65f2497e6f96eb9c688f9ee788" translate="yes" xml:space="preserve">
          <source>BLOB values (even serial types 12 and larger) sort last and in the order determined by memcmp().</source>
          <target state="translated">BLOB 値 (12 以上のシリアル型も含む)は最後にソートされ、memcmp()で決定された順序でソートされます。</target>
        </trans-unit>
        <trans-unit id="066ed32331b295c453ee3f4c55916aa0d7c725b0" translate="yes" xml:space="preserve">
          <source>BLOBs sort last</source>
          <target state="translated">BLOBsの最後のソート</target>
        </trans-unit>
        <trans-unit id="ab68d8e893a82cff70979ba20bec0023dbfe4be3" translate="yes" xml:space="preserve">
          <source>BOOLEAN</source>
          <target state="translated">BOOLEAN</target>
        </trans-unit>
        <trans-unit id="64c3f5e89864d5e803ba483fadc3c80068321744" translate="yes" xml:space="preserve">
          <source>BY</source>
          <target state="translated">BY</target>
        </trans-unit>
        <trans-unit id="987f01f766f58cd662fc3c685393d0d4667cbc0b" translate="yes" xml:space="preserve">
          <source>Back up cursor P1 so that it points to the previous key/data pair in its table or index. If there is no previous key/value pairs then fall through to the following instruction. But if the cursor backup was successful, jump immediately to P2.</source>
          <target state="translated">カーソルP1をそのテーブルまたはインデックスの前のキー/データペアを指すようにバックアップします。前のキー/値のペアがない場合は、次の命令にフォールスルーします。しかし、カーソルのバックアップが成功した場合、すぐにP2にジャンプします。</target>
        </trans-unit>
        <trans-unit id="f09881dbbda2f40a1bff480104e690d3c9470795" translate="yes" xml:space="preserve">
          <source>Backport a &lt;a href=&quot;https://www.sqlite.org/src/info/c648539b52ca28c0&quot;&gt;simple query planner optimization&lt;/a&gt; that allows the IS operator to drive an index on a LEFT OUTER JOIN. No other changes from the &lt;a href=&quot;#version_3_9_2&quot;&gt;version 3.9.2&lt;/a&gt; baseline.</source>
          <target state="translated">ISオペレーターがLEFT OUTER JOINのインデックスを駆動できるようにする&lt;a href=&quot;https://www.sqlite.org/src/info/c648539b52ca28c0&quot;&gt;簡単なクエリプランナー最適化&lt;/a&gt;をバックポートします。&lt;a href=&quot;#version_3_9_2&quot;&gt;バージョン3.9.2&lt;/a&gt;ベースラインからのその他の変更はありません。</target>
        </trans-unit>
        <trans-unit id="88c7762ebd772cef5a8b0f5dbf885740af02d796" translate="yes" xml:space="preserve">
          <source>Backup A: &lt;a href=&quot;https://www2.sqlite.org/docsrc&quot;&gt;https://www2.sqlite.org/docsrc&lt;/a&gt;</source>
          <target state="translated">バックアップA：&lt;a href=&quot;https://www2.sqlite.org/docsrc&quot;&gt;https&lt;/a&gt; : //www2.sqlite.org/docsrc</target>
        </trans-unit>
        <trans-unit id="3758d4866043fb72f7921be565221b2798bf18ec" translate="yes" xml:space="preserve">
          <source>Backup A: &lt;a href=&quot;https://www2.sqlite.org/src&quot;&gt;https://www2.sqlite.org/src&lt;/a&gt;</source>
          <target state="translated">バックアップA：&lt;a href=&quot;https://www2.sqlite.org/src&quot;&gt;https&lt;/a&gt; : //www2.sqlite.org/src</target>
        </trans-unit>
        <trans-unit id="5635a7bbe580f297d0f1cfe698eb39a60af249f7" translate="yes" xml:space="preserve">
          <source>Backup A: &lt;a href=&quot;https://www2.sqlite.org/th3&quot;&gt;https://www2.sqlite.org/th3&lt;/a&gt;</source>
          <target state="translated">バックアップA：&lt;a href=&quot;https://www2.sqlite.org/th3&quot;&gt;https&lt;/a&gt; : //www2.sqlite.org/th3</target>
        </trans-unit>
        <trans-unit id="354ff6f3afacd7c64aab0b45ca232e39fd5ab191" translate="yes" xml:space="preserve">
          <source>Backup B: &lt;a href=&quot;https://www3.sqlite.org/docsrc&quot;&gt;https://www3.sqlite.org/docsrc&lt;/a&gt;</source>
          <target state="translated">バックアップB：&lt;a href=&quot;https://www3.sqlite.org/docsrc&quot;&gt;https&lt;/a&gt; : //www3.sqlite.org/docsrc</target>
        </trans-unit>
        <trans-unit id="a437cf7f4394ac5ab3c8c6bf1f4decbf817f299c" translate="yes" xml:space="preserve">
          <source>Backup B: &lt;a href=&quot;https://www3.sqlite.org/src&quot;&gt;https://www3.sqlite.org/src&lt;/a&gt;</source>
          <target state="translated">バックアップB：&lt;a href=&quot;https://www3.sqlite.org/src&quot;&gt;https&lt;/a&gt; : //www3.sqlite.org/src</target>
        </trans-unit>
        <trans-unit id="06b0bc099757fb937c2145628c4ebe2caf89fed6" translate="yes" xml:space="preserve">
          <source>Backup B: &lt;a href=&quot;https://www3.sqlite.org/th3&quot;&gt;https://www3.sqlite.org/th3&lt;/a&gt;</source>
          <target state="translated">バックアップB：&lt;a href=&quot;https://www3.sqlite.org/th3&quot;&gt;https&lt;/a&gt; : //www3.sqlite.org/th3</target>
        </trans-unit>
        <trans-unit id="ad652023d4f99d0238bf9d42108eaead0a853d3a" translate="yes" xml:space="preserve">
          <source>Backup-filename</source>
          <target state="translated">Backup-filename</target>
        </trans-unit>
        <trans-unit id="8999e5aefef2d471c86fa4aebf649d22b2fddfc3" translate="yes" xml:space="preserve">
          <source>Backups on private servers</source>
          <target state="translated">プライベートサーバーのバックアップ</target>
        </trans-unit>
        <trans-unit id="63591d4f03e6c8c8462a238e710f0f3cd900691f" translate="yes" xml:space="preserve">
          <source>Backwards compatibility constraints mean that SQLite is only able to store values that are NULL, integers, floating-point numbers, text, and BLOBs. It is not possible to add a sixth &quot;JSON&quot; type.</source>
          <target state="translated">下位互換性の制約により、SQLiteはNULL、整数、浮動小数点数、テキスト、BLOBの値しか格納できません。6 番目の &quot;JSON&quot; 型を追加することはできません。</target>
        </trans-unit>
        <trans-unit id="ac8e908309343005a016d54d23589bde15362521" translate="yes" xml:space="preserve">
          <source>Backwards compatibility note:</source>
          <target state="translated">下位互換性ノート。</target>
        </trans-unit>
        <trans-unit id="70457c51de59bc0303eae7ef527e14f90b80a187" translate="yes" xml:space="preserve">
          <source>Backwards-incompatible changes to some extensions in order to take advantage of the improved security offered by the new &lt;a href=&quot;bindptr&quot;&gt;pointer passing interfaces&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;bindptr&quot;&gt;インターフェイスを渡す&lt;/a&gt;新しいポインターによって提供される改善されたセキュリティを利用するために、いくつかの拡張機能に対する下位互換性のない変更：</target>
        </trans-unit>
        <trans-unit id="af928fbbb6d75554958505ba9734eca9710f8051" translate="yes" xml:space="preserve">
          <source>Bad programmers worry about the code. Good programmers worry about data structures and their relationships.</source>
          <target state="translated">下手なプログラマーはコードを気にします。優秀なプログラマーは、データ構造とその関係について心配しています。</target>
        </trans-unit>
        <trans-unit id="d97ded08ec4df20e52b3ce05668bb0a2705fa978" translate="yes" xml:space="preserve">
          <source>Bare aggregate terms</source>
          <target state="translated">ベア集計用語</target>
        </trans-unit>
        <trans-unit id="5e2b9b9d48fdc95bbb5af1e6353dd4395e3738d9" translate="yes" xml:space="preserve">
          <source>Based on the above, SQLite is designed around a model of the file-system whereby any sector of a file written to is considered to be in a transient state until after the file has been successfully</source>
          <target state="translated">上記に基づいて、SQLiteはファイルシステムのモデルを中心に設計されています。</target>
        </trans-unit>
        <trans-unit id="2843b17c6eb4616657b580040fb118c722f6edb6" translate="yes" xml:space="preserve">
          <source>Be a help in times of trouble.</source>
          <target state="translated">困った時の助けになってください。</target>
        </trans-unit>
        <trans-unit id="d1a6a5570deb3a7eb7ea55daa060ee1c39dbe74c" translate="yes" xml:space="preserve">
          <source>Be a stranger to the world's ways.</source>
          <target state="translated">世界の道を知らない人になりましょう。</target>
        </trans-unit>
        <trans-unit id="7fe99077b2a420989db9a6580456c2197461f868" translate="yes" xml:space="preserve">
          <source>Be careful when using the &quot;.save&quot; command as it will overwrite any preexisting database files having the same name without prompting for confirmation. As with the &quot;.open&quot; command, you might want to use a full pathname with forward-slash directory separators to avoid ambiguity.</source>
          <target state="translated">.save &quot;コマンドを使用する際には注意してください。.open&quot; コマンドと同様に、曖昧さを避けるために、ディレクトリをフォワードスラッシュで区切ったフルパス名を使用した方が良いかもしれません。</target>
        </trans-unit>
        <trans-unit id="131acb5be798f8713c6bbeeaf8a6813dbe81748d" translate="yes" xml:space="preserve">
          <source>Be in dread of hell.</source>
          <target state="translated">地獄の恐怖におびえろ</target>
        </trans-unit>
        <trans-unit id="dbdb220ba30f3bde62d258265aacea82a8c9ef6a" translate="yes" xml:space="preserve">
          <source>Be not a detractor.</source>
          <target state="translated">落ちこぼれにならないようにしましょう。</target>
        </trans-unit>
        <trans-unit id="d18586b20264d29baf4b88bd2bdc140f64986d83" translate="yes" xml:space="preserve">
          <source>Be not a great eater.</source>
          <target state="translated">大食漢ではないこと。</target>
        </trans-unit>
        <trans-unit id="7c62076277d9f6b2639631bb528912ff4eff4ffa" translate="yes" xml:space="preserve">
          <source>Be not a grumbler.</source>
          <target state="translated">不平不満を言わないようにしましょう。</target>
        </trans-unit>
        <trans-unit id="288a450b2fc66179cb51c9c9d0a00b7f03fc2121" translate="yes" xml:space="preserve">
          <source>Be not addicted to wine.</source>
          <target state="translated">ワインにはまってはいけません。</target>
        </trans-unit>
        <trans-unit id="30d66a95d2dfd76a1e01a40e31a7daa8f6db0117" translate="yes" xml:space="preserve">
          <source>Be not drowsy.</source>
          <target state="translated">眠くならないように。</target>
        </trans-unit>
        <trans-unit id="c8f81046cf302e1b08a651f45ee31005254461af" translate="yes" xml:space="preserve">
          <source>Be not jealous, nor harbor envy.</source>
          <target state="translated">嫉妬したり、妬みを抱いたりしてはいけません。</target>
        </trans-unit>
        <trans-unit id="6f5bf647a944160204f29d66b6480eda5640fcdc" translate="yes" xml:space="preserve">
          <source>Be not lazy.</source>
          <target state="translated">怠け者にならないこと。</target>
        </trans-unit>
        <trans-unit id="1c899d6734a837258800bab2a2f7343b95199829" translate="yes" xml:space="preserve">
          <source>Be not proud.</source>
          <target state="translated">誇りに思ってはいけない</target>
        </trans-unit>
        <trans-unit id="9305ebf69b60c3d882da16805b530bbf3e6f3d95" translate="yes" xml:space="preserve">
          <source>Bear persecution for justice's sake.</source>
          <target state="translated">正義のために迫害に耐えろ</target>
        </trans-unit>
        <trans-unit id="6ca5c28c37834244df00d49b68c2bef2606b1e1f" translate="yes" xml:space="preserve">
          <source>Because &quot;text&quot; columns have a different sort order from numeric, indices on &quot;text&quot; columns occur in a different order for version 2.7.0 and later database. Hence version 2.6.3 and earlier of SQLite will be unable to read a 2.7.0 or later database. But version 2.7.0 and later of SQLite will read earlier databases.</source>
          <target state="translated">text&quot; カラムは数値とはソート順が異なるため、バージョン 2.7.0 以降のデータベースでは、&quot;text&quot; カラムのインデックスの並び順が異なります。そのため、SQLiteのバージョン2.6.3以前のものは、2.7.0以降のデータベースを読み込むことができません。しかし、SQLite のバージョン 2.7.0 以降では、それ以前のデータベースを読むことができます。</target>
        </trans-unit>
        <trans-unit id="85eeb52404350645676cc7b1bb211e4acfd5ad5b" translate="yes" xml:space="preserve">
          <source>Because AUTOINCREMENT keyword changes the behavior of the ROWID selection algorithm, AUTOINCREMENT is not allowed on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables or on any table column other than INTEGER PRIMARY KEY. Any attempt to use AUTOINCREMENT on a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table or on a column other than the INTEGER PRIMARY KEY column results in an error.</source>
          <target state="translated">AUTOINCREMENTキーワードはROWID選択アルゴリズムの動作を変更するため、&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルまたはINTEGER PRIMARY KEY以外のテーブル列ではAUTOINCREMENTを使用できません。&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルまたはINTEGER PRIMARY KEY列以外の列でAUTOINCREMENTを使用しようとすると、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="eeb868502c2d293980db003c26a1d7e59cde0343" translate="yes" xml:space="preserve">
          <source>Because FTS3 and FTS4 are virtual tables, The &lt;a href=&quot;compile#enable_fts3&quot;&gt;SQLITE_ENABLE_FTS3&lt;/a&gt; compile-time option is incompatible with the &lt;a href=&quot;compile#omit_virtualtable&quot;&gt;SQLITE_OMIT_VIRTUALTABLE&lt;/a&gt; option.</source>
          <target state="translated">FTS3およびFTS4は仮想テーブルであるため、&lt;a href=&quot;compile#enable_fts3&quot;&gt;SQLITE_ENABLE_FTS3&lt;/a&gt;コンパイル時オプションは&lt;a href=&quot;compile#omit_virtualtable&quot;&gt;SQLITE_OMIT_VIRTUALTABLE&lt;/a&gt;オプションと互換性がありません。</target>
        </trans-unit>
        <trans-unit id="4912d0649aa9ed8b2a285af375de29c2823b504b" translate="yes" xml:space="preserve">
          <source>Because Lemon is a program not normally found on development machines, the complete source code to Lemon (just one C file) is included in the SQLite distribution in the &quot;tool&quot; subdirectory.</source>
          <target state="translated">Lemonは通常開発マシンでは見られないプログラムなので、Lemonの完全なソースコード(Cファイル1つだけ)は &quot;tool &quot;サブディレクトリのSQLiteディストリビューションに含まれています。</target>
        </trans-unit>
        <trans-unit id="c877f3293b1082ca722e1e4a350d52f335812101" translate="yes" xml:space="preserve">
          <source>Because SQLite is flexible and forgiving with regard to datatypes, table columns can be created that have no specified datatype at all. For example:</source>
          <target state="translated">SQLite はデータ型に関しては柔軟で寛容なので、指定されたデータ型を全く持たないテーブルカラムを作成することができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="89b4ac6aceecf052168be7879566274bb4b65047" translate="yes" xml:space="preserve">
          <source>Because ZIP archives are optimized for storing big chunks of content, they encourage a style of programming where the entire document is read into memory at startup, all editing occurs in memory, then the entire document is written to disk during &quot;File/Save&quot;. OpenOffice and its descendants embrace that pattern.</source>
          <target state="translated">ZIP アーカイブは大きなコンテンツの塊を保存するために最適化されているので、起動時にドキュメント全体がメモリに読み込まれ、すべての編集がメモリ内で行われ、「ファイル/保存」の間にドキュメント全体がディスクに書き込まれるプログラミングのスタイルを奨励します。OpenOffice とその子孫はこのパターンを採用しています。</target>
        </trans-unit>
        <trans-unit id="1aef204394eb2f42a054518ac1383e25f6308e7c" translate="yes" xml:space="preserve">
          <source>Because allocations are all the same size, the memory allocator can operate much faster. The allocator need not bother with coalescing adjacent free slots or searching for a slot of an appropriate size. All unallocated memory slots can be stored on a linked list. Allocating consists of removing the first entry from the list. Deallocating is simply adding an entry to the beginning of the list.</source>
          <target state="translated">すべての割り当てが同じサイズであるため、メモリアロケータははるかに高速に動作します。アロケータは、隣接する空きスロットを合体させたり、適切なサイズのスロットを探したりする必要はありません。すべての未割り当てのメモリスロットは、リンクされたリストに格納することができます。割り当ては、リストから最初のエントリを削除することで構成されます。割り当て解除は、単にリストの先頭にエントリを追加することです。</target>
        </trans-unit>
        <trans-unit id="8fe792a90bccd6800bd67f3f37ebbaabb1467610" translate="yes" xml:space="preserve">
          <source>Because an SQLite database is a single compact file in a &lt;a href=&quot;fileformat2&quot;&gt;well-defined cross-platform format&lt;/a&gt;, it is often used as a container for transferring content from one system to another. The sender gathers content into an SQLite database file, transfers that one file to the receiver, then the receiver uses SQL to extract the content as needed.</source>
          <target state="translated">SQLiteデータベースは、&lt;a href=&quot;fileformat2&quot;&gt;明確に定義されたクロスプラットフォーム形式の&lt;/a&gt;単一のコンパクトファイルであるため、1つのシステムから別のシステムにコンテンツを転送するためのコンテナーとしてよく使用されます。送信者はコンテンツをSQLiteデータベースファイルに収集し、その1つのファイルを受信者に転送します。その後、受信者はSQLを使用して必要に応じてコンテンツを抽出します。</target>
        </trans-unit>
        <trans-unit id="a4c1f92dc828402b18e6e117bb816b40d1c734ed" translate="yes" xml:space="preserve">
          <source>Because an SQLite database requires no administration, it works well in devices that must operate without expert human support. SQLite is a good fit for use in cellphones, set-top boxes, televisions, game consoles, cameras, watches, kitchen appliances, thermostats, automobiles, machine tools, airplanes, remote sensors, drones, medical devices, and robots: the &quot;internet of things&quot;.</source>
          <target state="translated">SQLite データベースは管理を必要としないため、専門家のサポートなしで操作する必要のあるデバイスでも問題なく動作します。SQLite は、携帯電話、セットトップボックス、テレビ、ゲーム機、カメラ、時計、キッチン家電、サーモスタット、自動車、工作機械、飛行機、リモートセンサー、ドローン、医療機器、ロボットなどの「モノのインターネット」に最適です。</target>
        </trans-unit>
        <trans-unit id="788be5cf964c9ee21f08ece0ea7377ef2e19234d" translate="yes" xml:space="preserve">
          <source>Because assert() can be and is commonly misused, some programming language theorists and designers look upon it with disfavor. For example, the designers of the &lt;a href=&quot;https://golang.org&quot;&gt;Go programming language&lt;/a&gt; intentionally &lt;a href=&quot;https://golang.org/doc/faq#assertions&quot;&gt;omit a built-in assert()&lt;/a&gt;. They feel that the harm caused by misuse of assert() outweighs the benefits of including it as a language built-in. The SQLite developers disagree. In fact, the original purpose of this article is to push back against the common notion that assert() is harmful. In our experience, SQLite would be much more difficult to develop, test, and maintain without assert().</source>
          <target state="translated">assert（）は誤用される可能性があり、誤用されることが多いため、一部のプログラミング言語の理論家や設計者は、これを不愉快に見ています。たとえば、&lt;a href=&quot;https://golang.org&quot;&gt;Goプログラミング言語の&lt;/a&gt;設計者は、&lt;a href=&quot;https://golang.org/doc/faq#assertions&quot;&gt;組み込みのassert（）を&lt;/a&gt;意図的に省略しています。彼らは、assert（）の誤用によって引き起こされる害は、それを組み込み言語として含めることの利点を上回ると感じています。 SQLite開発者は同意しません。実際、この記事の本来の目的は、assert（）が有害であるという一般的な考えに反することです。私たちの経験では、SQLiteは、assert（）なしでは開発、テスト、保守がはるかに困難です。</target>
        </trans-unit>
        <trans-unit id="a6c8b76107dc390feb365087dd23a9e6847d8ec8" translate="yes" xml:space="preserve">
          <source>Because it does not have a central server to coordinate access, SQLite must close and reopen the database file, and thus invalidate its cache, for each transaction. In this test, each SQL statement is a separate transaction so the database file must be opened and closed and the cache must be flushed 1000 times. In spite of this, the asynchronous version of SQLite is still nearly as fast as MySQL. Notice how much slower the synchronous version is, however. SQLite calls &lt;b&gt;fsync()&lt;/b&gt; after each synchronous transaction to make sure that all data is safely on the disk surface before continuing. For most of the 13 seconds in the synchronous test, SQLite was sitting idle waiting on disk I/O to complete.</source>
          <target state="translated">アクセスを調整する中央サーバーがないため、SQLiteはトランザクションごとにデータベースファイルを閉じて再度開き、キャッシュを無効にする必要があります。このテストでは、各SQLステートメントは個別のトランザクションであるため、データベースファイルを開いて閉じ、キャッシュを1000回フラッシュする必要があります。これにもかかわらず、SQLiteの非同期バージョンはまだMySQLとほぼ同じくらい高速です。ただし、同期バージョンの方がはるかに遅いことに注意してください。 SQLiteは各同期トランザクションの後に&lt;b&gt;fsync（）を&lt;/b&gt;呼び出して、続行する前にすべてのデータがディスク表面に安全にあることを確認します。同期テストの13秒間のほとんどの間、SQLiteはディスクI / Oの完了を待機してアイドル状態でした。</target>
        </trans-unit>
        <trans-unit id="44c3dab6a322e3be0dd40f52ec50b7f7abadf611" translate="yes" xml:space="preserve">
          <source>Because it is a simulator, running a binary in Valgrind is slower than running it on native hardware. (To a first approximation, an application running in Valgrind on a workstation will perform about the same as it would running natively on a smartphone.) So it is impractical to run the full SQLite test suite through Valgrind. However, the veryquick tests and the coverage of the TH3 tests are run through Valgrind prior to every release.</source>
          <target state="translated">シミュレータであるため、Valgrindでバイナリを実行すると、ネイティブのハードウェア上で実行するよりも遅くなります(最初の概算では、ワークステーション上でValgrindで実行するアプリケーションは、スマートフォン上でネイティブに実行するのとほぼ同じ性能を発揮します)。(最初の概算では、ワークステーション上で Valgrind で実行されているアプリケーションは、スマートフォン上でネイティブに実行されているのとほぼ同じパフォーマンスを発揮します)。そのため、SQLiteのテストスイートをすべてValgrindで実行することは非現実的です。しかし、非常にクイックなテストとTH3テストのカバレッジは、すべてのリリースの前にValgrindを通して実行されます。</target>
        </trans-unit>
        <trans-unit id="2d7f244d51b1fc8bd92e3755f3ff4412ae2f2b57" translate="yes" xml:space="preserve">
          <source>Because it is simple to setup and use (installation is trivial: just copy the &lt;b&gt;sqlite3&lt;/b&gt; or &lt;b&gt;sqlite3.exe&lt;/b&gt; executable to the target machine and run it) SQLite makes a good database engine for use in teaching SQL. Students can easily create as many databases as they like and can email databases to the instructor for comments or grading. For more advanced students who are interested in studying how an RDBMS is implemented, the modular and well-commented and documented SQLite code can serve as a good basis.</source>
          <target state="translated">セットアップと使用が簡単であるため（インストールは簡単です：&lt;b&gt;sqlite3&lt;/b&gt;または&lt;b&gt;sqlite3.exe&lt;/b&gt;実行可能ファイルをターゲットマシンにコピーして実行するだけです）、SQLiteはSQLの教育に使用するための優れたデータベースエンジンです。学生は好きなだけデータベースを簡単に作成でき、コメントや採点のためにデータベースを講師にメールで送信できます。RDBMSがどのように実装されているかを研究することに興味のある、より上級の学生にとって、モジュール化され、よくコメントされ、文書化されたSQLiteコードは、良い基礎として役立ちます。</target>
        </trans-unit>
        <trans-unit id="4f8ea41ffd9236f49c6f3b48d5813c7ba03da82f" translate="yes" xml:space="preserve">
          <source>Because it reorganizes the entire FTS index, the optimize command can take a long time to run. The &lt;a href=&quot;fts5#the_merge_command&quot;&gt;FTS5 merge command&lt;/a&gt; can be used to divide the work of optimizing the FTS index into multiple steps. To do this:</source>
          <target state="translated">FTSインデックス全体を再編成するため、optimizeコマンドは実行に時間がかかる場合があります。&lt;a href=&quot;fts5#the_merge_command&quot;&gt;FTS5マージコマンドは&lt;/a&gt;、複数のステップにFTSインデックスを最適化する作業を分割するために使用することができます。これをする：</target>
        </trans-unit>
        <trans-unit id="444393da5087c1cdc4456d5a26de8bf63b917b08" translate="yes" xml:space="preserve">
          <source>Because it stores extra information on disk in two new &lt;a href=&quot;fts3#*shadowtab&quot;&gt;shadow tables&lt;/a&gt; in order to support the performance optimizations and extra matchinfo() options, FTS4 tables may consume more disk space than the equivalent table created using FTS3. Usually the overhead is 1-2% or less, but may be as high as 10% if the documents stored in the FTS table are very small. The overhead may be reduced by specifying the directive &lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;&quot;matchinfo=fts3&quot;&lt;/a&gt; as part of the FTS4 table declaration, but this comes at the expense of sacrificing some of the extra supported matchinfo() options.</source>
          <target state="translated">FTS4テーブルは、パフォーマンスの最適化と追加のmatchinfo（）オプションをサポートするために、ディスク上の追加情報を2つの新しい&lt;a href=&quot;fts3#*shadowtab&quot;&gt;シャドウテーブルに格納&lt;/a&gt;するため、FTS3を使用して作成された同等のテーブルより多くのディスク領域を消費する可能性があります。通常、オーバーヘッドは1〜2％以下ですが、FTSテーブルに格納されているドキュメントが非常に小さい場合は、10％になる可能性があります。ディレクティブ&lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;&quot;matchinfo = fts3&quot;&lt;/a&gt;をFTS4テーブル宣言の一部として指定することにより、オーバーヘッドを減らすことができますが、サポートされる余分なmatchinfo（）オプションの一部が犠牲になります。</target>
        </trans-unit>
        <trans-unit id="c9b96b15368e6c99132d7d8a67a04e723712af54" translate="yes" xml:space="preserve">
          <source>Because lookaside allocations are always the same size, the allocation and deallocation algorithms are very quick. There is no need to coalesce adjacent free slots or search for a slot of a particular size. Each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; maintains a singly-linked list of unused slots. Allocation requests simply pull the first element of this list. Deallocations simply push the element back onto the front of the list. Furthermore, each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is assumed to already be running in a single thread (there are mutexes already in place to enforce this) so no additional mutexing is required to serialize access to the lookaside slot freelist. Consequently, lookaside memory allocations and deallocations are very fast. In speed tests on Linux and Mac OS X workstations, SQLite has shown overall performance improvements as high as 10% and 15%, depending on the workload how and lookaside is configured.</source>
          <target state="translated">ルックアサイド割り当ては常に同じサイズであるため、割り当てと割り当て解除のアルゴリズムは非常に高速です。隣接する空きスロットを結合したり、特定のサイズのスロットを検索したりする必要はありません。各&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;は、未使用スロットの単一リンクリストを維持します。割り当て要求は、このリストの最初の要素をプルするだけです。割り当て解除は、単に要素をリストの前面に押し戻します。さらに、各&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;は既にシングルスレッドで実行されていると見なされます（これを実行するためのミューテックスが既に用意されています）。そのため、lookasideスロットフリーリストへのアクセスをシリアル化するために、追加のミューテックスは必要ありません。したがって、lookasideのメモリ割り当てと割り当て解除は非常に高速です。LinuxおよびMac OS Xワークステーションの速度テストで、SQLiteは、ワークロードの設定方法とルックアサイドの設定に応じて、全体的なパフォーマンスが10％および15％も向上することを示しています。</target>
        </trans-unit>
        <trans-unit id="668e105a1044bfeea3b1760bf6f04ba2a54183c0" translate="yes" xml:space="preserve">
          <source>Because main-memory is a limited resource, the</source>
          <target state="translated">メインメモリは限られたリソースなので</target>
        </trans-unit>
        <trans-unit id="fdc0f2ea6af2e7d5aa2876f1718288d4bc691129" translate="yes" xml:space="preserve">
          <source>Because of continuing security concerns, the two-argument version of of the seldom-used and little-known &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; function is disabled unless SQLite is compiled with the &lt;a href=&quot;compile#enable_fts3_tokenizer&quot;&gt;SQLITE_ENABLE_FTS3_TOKENIZER&lt;/a&gt;.</source>
          <target state="translated">引き続きセキュリティ上の懸念があるため、SQLiteが&lt;a href=&quot;compile#enable_fts3_tokenizer&quot;&gt;SQLITE_ENABLE_FTS3_TOKENIZERで&lt;/a&gt;コンパイルされない限り、あまり使用されず、あまり知られていない&lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer（）&lt;/a&gt;関数の2引数バージョンは無効になります。</target>
        </trans-unit>
        <trans-unit id="f16662c44c98100b991163c6c6a9a2f0174c0613" translate="yes" xml:space="preserve">
          <source>Because of its past success, AFL became a standard part of the testing strategy for SQLite beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_8_10.html&quot;&gt;version 3.8.10&lt;/a&gt; (2015-05-07) until it was superseded by better fuzzers in &lt;a href=&quot;https://sqlite.org/releaselog/3_29_0.html&quot;&gt;version 3.29.0&lt;/a&gt; (2019-07-10).</source>
          <target state="translated">過去の成功により、AFLは&lt;a href=&quot;https://sqlite.org/releaselog/3_8_10.html&quot;&gt;バージョン3.8.10&lt;/a&gt;（2015-05-07）から始まり、&lt;a href=&quot;https://sqlite.org/releaselog/3_29_0.html&quot;&gt;バージョン3.29.0&lt;/a&gt;（2019-07-10）でより優れたファザーに取って代わられるまで、SQLiteのテスト戦略の標準的な部分になりました。</target>
        </trans-unit>
        <trans-unit id="70e6d86d9770a8829aec592e59f4248ba67ce358" translate="yes" xml:space="preserve">
          <source>Because of its past success, AFL became a standard part of the testing strategy for SQLite beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_8_10.html&quot;&gt;version 3.8.10&lt;/a&gt; (2015-05-07). Both SQL statements and database files are fuzzed. Billions and billions of mutations have been tried, but AFL's instrumentation has narrowed them down to less than 50,000 test cases that cover all distinct behaviors. Newly discovered test cases are periodically captured and added to the &lt;a href=&quot;testing#tcl&quot;&gt;TCL test suite&lt;/a&gt; where they can be rerun using the &quot;make fuzztest&quot; or &quot;make valgrindfuzz&quot; commands.</source>
          <target state="translated">過去の成功により、AFLは&lt;a href=&quot;https://sqlite.org/releaselog/3_8_10.html&quot;&gt;バージョン3.8.10&lt;/a&gt;（2015-05-07）以降、SQLiteのテスト戦略の標準部分になりました。 SQLステートメントとデータベースファイルの両方がファジー化されます。何十億と何十億もの突然変異が試されてきましたが、AFLのインストルメンテーションはそれらをすべての異なる動作をカバーする50,000未満のテストケースに絞り込みました。新しく発見されたテストケースは定期的にキャプチャされ、&lt;a href=&quot;testing#tcl&quot;&gt;TCLテストスイートに&lt;/a&gt;追加されます。そこでは、「make fuzztest」または「make valgrindfuzz」コマンドを使用して再実行できます。</target>
        </trans-unit>
        <trans-unit id="35a2bab974445beaebfdcb0d2e216e6aab6976e2" translate="yes" xml:space="preserve">
          <source>Because of security concerns, the two-argument fts3_tokenizer() feature was disabled beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;Version 3.11.0&lt;/a&gt; (2016-02-15) unless this compile-time option is used. &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;Version 3.12.0&lt;/a&gt; (2016-03-29) added the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;,1,0) interface that activates the two-argument version of &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; for a specific &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; at run-time.</source>
          <target state="translated">セキュリティ上の理由から、このコンパイル時オプションを使用しない限り、2つの引数を持つfts3_tokenizer（）機能は&lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;バージョン3.11.0&lt;/a&gt;（2016-02-15）以降無効になりました。&lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;バージョン3.12.0&lt;/a&gt;（2016-03-29）は、実行時に特定の&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;に対して2つの引数のバージョンの&lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer（）&lt;/a&gt;をアクティブにする&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;、1,0）インターフェースを追加しました。</target>
        </trans-unit>
        <trans-unit id="90667c0d2f4c3f9e700d1a02bf683d36a408bbd8" translate="yes" xml:space="preserve">
          <source>Because of the behaviors described above, programmers are encouraged to prefer AFTER triggers over BEFORE triggers.</source>
          <target state="translated">上述した動作のため、プログラマは、BEFOREトリガよりもAFTERトリガを好むことが推奨される。</target>
        </trans-unit>
        <trans-unit id="428b411cc0640abd27f1cf3a950377d2c4b5358f" translate="yes" xml:space="preserve">
          <source>Because of the potential disadvantages, memory-mapped I/O is disabled by default. To activate memory-mapped I/O, use the &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;mmap_size pragma&lt;/a&gt; and set the mmap_size to some large number, usually 256MB or larger, depending on how much address space your application can spare. The rest is automatic. The &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt; statement will be a silent no-op on systems that do not support memory-mapped I/O.</source>
          <target state="translated">潜在的な欠点があるため、メモリマップI / Oはデフォルトで無効になっています。メモリマップI / Oをアクティブにするには、&lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;mmap_sizeプラグマ&lt;/a&gt;を使用し、アプリケーションが使用できるアドレススペースの量に応じて、mmap_sizeを大きな値（通常は256MB以上）に設定します。残りは自動です。&lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;プラグマmmap_sizeの&lt;/a&gt;文では、メモリマップドI / Oをサポートしていないシステム上のサイレント無操作になります。</target>
        </trans-unit>
        <trans-unit id="3b4a67ca1996129326c7f0bddce34637e22bf4f7" translate="yes" xml:space="preserve">
          <source>Because of these advantages, SQLite always tries to do a partial sort using an index even if a complete sort by index is not possible.</source>
          <target state="translated">このような利点があるため、SQLite はインデックスによる完全なソートが不可能な場合でも、常にインデックスを使用して部分的なソートを試みます。</target>
        </trans-unit>
        <trans-unit id="0aff0a8b5eb6e0fbec96bd0626840af7bfdbee19" translate="yes" xml:space="preserve">
          <source>Because resetting a database is destructive and irreversible, the process requires the use of this obscure API and multiple steps to help ensure that it does not happen by accident.</source>
          <target state="translated">データベースのリセットは破壊的で不可逆的であるため、このプロセスでは、この不明瞭なAPIと複数のステップを使用して、偶然にも起こらないようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="6b538eb844bddf9ea8a5b9a11872b1b61bfa979d" translate="yes" xml:space="preserve">
          <source>Because sorting can be expensive, SQLite works hard to convert ORDER BY clauses into no-ops. If SQLite determines that output will naturally appear in the order specified, then no sorting is done. So, for example, if you request the output in rowid order, no sorting will be done:</source>
          <target state="translated">ソートにはコストがかかるため、SQLite は ORDER BY 節をノーオペスに変換しようと懸命に働きます。SQLite が出力が自然に指定した順番で表示されると判断した場合、ソートは行われません。つまり、例えば、行番号順に出力を要求した場合、ソートは行われません。</target>
        </trans-unit>
        <trans-unit id="b9e05ab9d98b3cd637f9791d810eeb3b04a00c42" translate="yes" xml:space="preserve">
          <source>Because the SQLite developers do not know whether the SQLITE_ENABLE_SORTER_REFERENCES option will help or hurt performance, it is disabled by default at this time (2018-05-04). It might be enabled by default in some future release, depending on what is learned about its impact on performance.</source>
          <target state="translated">SQLite の開発者は SQLITE_ENABLE_SORTER_REFERENCES オプションがパフォーマンスを助けるか傷つけるかを知らないため、現時点ではデフォルトで無効になっています (2018-05-04)。パフォーマンスへの影響について何が判明したかによっては、将来のリリースでデフォルトで有効になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="15ba7f227189763df8625f3bee22f683d880802a" translate="yes" xml:space="preserve">
          <source>Because the completion table is built into the command-line shell in order to provide for tab-completions, you can run test queries against the completion table directly in the command-line shell. Simply type a query such as the example shown above, filling in appropriate values for $prefix and $wholeline, and observe the output.</source>
          <target state="translated">補完テーブルは、タブ補完を提供するためにコマンドライン・シェルに組み込まれているため、コマンドライン・シェルで直接補完テーブルに対するテスト・クエリを実行できます。上の例のようなクエリを入力し、$prefix と $wholeline に適切な値を入力して、出力を確認します。</target>
        </trans-unit>
        <trans-unit id="a8514da27bd50380cff29e01b5a61eb7772e130b" translate="yes" xml:space="preserve">
          <source>Because the content of leaf freelist pages is unimportant, SQLite avoids storing leaf freelist page content in the rollback journal in &lt;a href=&quot;#section_3_5&quot;&gt;step 3.5&lt;/a&gt; of the commit process. If a leaf freelist page is changed and that change does not get rolled back during a transaction recovery, the database is not harmed by the omission. Similarly, the content of a new freelist page is never written back into the database at &lt;a href=&quot;#section_3_9&quot;&gt;step 3.9&lt;/a&gt; nor read from the database at &lt;a href=&quot;#section_3_3&quot;&gt;step 3.3&lt;/a&gt;. These optimizations can greatly reduce the amount of I/O that occurs when making changes to a database file that contains free space.</source>
          <target state="translated">リーフフリーリストページのコンテンツは重要ではないため、SQLiteはコミットプロセスの&lt;a href=&quot;#section_3_5&quot;&gt;ステップ3.5&lt;/a&gt;でロールバックジャーナルにリーフフリーリストページのコンテンツを保存することを避けます。リーフフリーリストページが変更され、トランザクションの回復中にその変更がロールバックされない場合、データベースは省略によって損なわれることはありません。同様に、新しいフリーリストページのコンテンツは、&lt;a href=&quot;#section_3_9&quot;&gt;ステップ3.9で&lt;/a&gt;データベースに書き戻されたり、&lt;a href=&quot;#section_3_3&quot;&gt;ステップ3.3で&lt;/a&gt;データベースから読み取られたりすることはありません。これらの最適化により、空き領域を含むデータベースファイルを変更するときに発生するI / Oの量を大幅に削減できます。</target>
        </trans-unit>
        <trans-unit id="e09f5109878254b678ca47d639d75e4bf226a1da" translate="yes" xml:space="preserve">
          <source>Because the indexed documents themselves are usually much larger than the full-text index, the content option can be used to achieve significant space savings.</source>
          <target state="translated">インデックス化された文書自体は通常、全文インデックスよりもはるかに大きいため、コンテンツオプションを使用して大幅なスペースの節約を実現することができます。</target>
        </trans-unit>
        <trans-unit id="761cb8246ba69558ca8aeb80b8dbab8c62f5efed" translate="yes" xml:space="preserve">
          <source>Because the left-most column of the index does not appear in the WHERE clause of the query, one is tempted to conclude that the index is not usable here. But SQLite is able to use the index. Conceptually, SQLite uses the index as if the query were more like the following:</source>
          <target state="translated">インデックスの左端の列はクエリの WHERE 句には現れないので、ここではインデックスは使えないと結論付けたくなります。しかし、SQLite はインデックスを使用することができます。概念的には、SQLite は、クエリが以下のようなものであるかのようにインデックスを使用します。</target>
        </trans-unit>
        <trans-unit id="d3bc49abdbbec51c89e15d286d4a875e6d32447c" translate="yes" xml:space="preserve">
          <source>Because the name of the schema table does not appear anywhere in the file format, the meaning of the database file is not changed if the application chooses to refer to the schema table by one of these alternative names.</source>
          <target state="translated">スキーマテーブルの名前はファイル形式のどこにも現れないので、アプリケーションがこれらの代替名のいずれかでスキーマテーブルを参照することを選択しても、データベースファイルの意味は変わりません。</target>
        </trans-unit>
        <trans-unit id="a128485eb3a76806acc833997f2bb0ca8f3bab85" translate="yes" xml:space="preserve">
          <source>Because the non-primary key &quot;old.*&quot; fields are omitted, no SQLITE_CHANGESET_DATA conflicts can be detected or reported if a patchset is passed to the sqlite3changeset_apply() API. Other conflict types work in the same way as for changesets.</source>
          <target state="translated">主キーではない &quot;old.*&quot;フィールドが省略されているため、パッチセットがsqlite3changeset_apply()APIに渡されても、SQLITE_CHANGESET_DATAの競合は検出されませんし、報告されません。他の競合タイプはチェンジセットの場合と同じように動作します。</target>
        </trans-unit>
        <trans-unit id="2e558ba54b31e234aa1a29ff45d5a07a13c1806f" translate="yes" xml:space="preserve">
          <source>Because the pointer is passed in the t1 column of the t1 table as a BLOB (in older versions of SQLite), such a query would have shown the value of the pointer in hex. The attacker could then modify that pointer to try to get the snippet() function to modify memory in some other part of the application address space instead of the fts3cursor object it was supposed to be operating on:</source>
          <target state="translated">ポインタはt1テーブルのt1カラムにBLOBとして渡されるため(古いバージョンのSQLiteでは)、このような問い合わせではポインタの値が16進数で表示されます。攻撃者はそのポインタを修正して、snippet()関数が動作するはずの fts3cursor オブジェクトではなく、アプリケーションのアドレス空間の他の部分のメモリを修正するように取得しようとすることができます。</target>
        </trans-unit>
        <trans-unit id="72ea5223eef09f4a78746e1785e07a1242a94565" translate="yes" xml:space="preserve">
          <source>Because the same query could be written without the use of row values, row values do not provide new capabilities. However, many developers say that the row value format is easier to read, write, and debug.</source>
          <target state="translated">行値を使用しなくても同じクエリを書くことができたので、行値は新しい機能を提供しません。しかし、多くの開発者は、行値形式の方が読みやすく、書きやすく、デバッグしやすいと言っています。</target>
        </trans-unit>
        <trans-unit id="fc8629347e97d2900d75943390265d789337dab5" translate="yes" xml:space="preserve">
          <source>Because the session module uses the &lt;a href=&quot;../c3ref/preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; API, it is not possible for an application to register a pre-update hook on a database handle that has one or more session objects attached. Nor is it possible to create a session object attached to a database handle for which a pre-update hook is already defined. The results of attempting either of these things are undefined.</source>
          <target state="translated">セッションモジュールは&lt;a href=&quot;../c3ref/preupdate_count&quot;&gt;sqlite3_preupdate_hook（）&lt;/a&gt; APIを使用するため、アプリケーションで、1つ以上のセッションオブジェクトがアタッチされているデータベースハンドルに更新前フックを登録することはできません。また、更新前フックがすでに定義されているデータベースハンドルにアタッチされたセッションオブジェクトを作成することもできません。これらのいずれかを試みた結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="2d755c27985069d9c58f3f925b7f20c86ab3fc1d" translate="yes" xml:space="preserve">
          <source>Because the session module uses the &lt;a href=&quot;c3ref/preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; API, it is not possible for an application to register a pre-update hook on a database handle that has one or more session objects attached. Nor is it possible to create a session object attached to a database handle for which a pre-update hook is already defined. The results of attempting either of these things are undefined.</source>
          <target state="translated">セッションモジュールは&lt;a href=&quot;c3ref/preupdate_count&quot;&gt;sqlite3_preupdate_hook（）&lt;/a&gt; APIを使用するため、アプリケーションで、1つ以上のセッションオブジェクトがアタッチされているデータベースハンドルに更新前フックを登録することはできません。また、更新前フックがすでに定義されているデータベースハンドルにアタッチされたセッションオブジェクトを作成することもできません。これらのいずれかを試みた結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="adc547a5fb4644ceebfd077fa4efa0549df654d8" translate="yes" xml:space="preserve">
          <source>Because the shm file is not involved in recovery, the shm file does not need to be machine byte-order independent. Hence, numeric values in the shm file are written in the native byte order of the host computer, rather than being converted into a specific cross-platform byte order as is done with the main database file and the wal file.</source>
          <target state="translated">shmファイルはリカバリには関与しないので、shmファイルはマシンのバイトオーダーに依存しない必要はありません。そのため、shmファイル内の数値は、メインデータベースファイルやwalファイルのように特定のクロスプラットフォームのバイトオーダーに変換されるのではなく、ホストコンピュータのネイティブのバイトオーダーで書き込まれます。</target>
        </trans-unit>
        <trans-unit id="57d0b82e26ee2d676d928a1d7402d5916fc2656a" translate="yes" xml:space="preserve">
          <source>Because the shm is only used to coordinate access between concurrent clients, the shm file is omitted if &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; is set, as an optimization. When &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; is set, SQLite uses heap memory in place of the memory-mapped shm file.</source>
          <target state="translated">shmは同時クライアント間のアクセスを調整するためにのみ使用されるため、最適化として&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;排他ロックモード&lt;/a&gt;が設定されている場合、shmファイルは省略されます。ときに&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;排他ロックモードが&lt;/a&gt;設定されている、SQLiteは、メモリマップされたSHMファイルの代わりに、ヒープメモリを使用しています。</target>
        </trans-unit>
        <trans-unit id="2da09f02d441cbe1ccd49c9803ec08e4160143a9" translate="yes" xml:space="preserve">
          <source>Because there is no cross-platform way to specify 64-bit integer types SQLite includes typedefs for 64-bit signed and unsigned integers.</source>
          <target state="translated">64 ビット整数型を指定するクロスプラットフォームの方法はないため、SQLite には 64 ビット符号付き整数と符号なし整数の型定義が含まれています。</target>
        </trans-unit>
        <trans-unit id="8871399a86a3489a9f90b012e36a01ad56791fa8" translate="yes" xml:space="preserve">
          <source>Before SQLite can write to a database, it must first read the database to see what is there already. Even if it is just appending new data, SQLite still has to read in the database schema from the &quot;&lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt;&quot; table so that it can know how to parse the INSERT statements and discover where in the database file the new information should be stored.</source>
          <target state="translated">SQLiteがデータベースに書き込む前に、まずデータベースを読み取って、すでに存在するものを確認する必要があります。新しいデータを追加するだけの場合でも、SQLiteは「&lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt;」テーブルからデータベーススキーマを読み込む必要があります。これにより、INSERTステートメントを解析し、データベースファイルのどこに新しい情報を格納するかを検出できます。</target>
        </trans-unit>
        <trans-unit id="7d5873520ec115c715db00ab0ac94f393f103400" translate="yes" xml:space="preserve">
          <source>Before SQLite can write to a database, it must first read the database to see what is there already. Even if it is just appending new data, SQLite still has to read in the database schema from the &lt;b&gt;sqlite_master&lt;/b&gt; table so that it can know how to parse the INSERT statements and discover where in the database file the new information should be stored.</source>
          <target state="translated">SQLiteがデータベースに書き込む前に、まずデータベースを読み取って、そこに何があるかを確認する必要があります。新しいデータを追加するだけの場合でも、SQLite はINSERTステートメントを解析し、データベースファイル内の新しい情報を格納する&lt;b&gt;場所を見つける&lt;/b&gt;ために、&lt;b&gt;sqlite_master&lt;/b&gt;テーブルからデータベーススキーマを読み取る必要があります。</target>
        </trans-unit>
        <trans-unit id="ccacc0177cbd2ba716b19132f920379d439772e2" translate="yes" xml:space="preserve">
          <source>Before a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement can be run, the module specified in that statement must be registered with the database connection. This is accomplished using either of the &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; or &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; interfaces:</source>
          <target state="translated">&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;ステートメントを実行する前に、そのステートメントで指定されたモジュールをデータベース接続に登録する必要があります。これは、&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module（）&lt;/a&gt;または&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2（）&lt;/a&gt;インターフェースのいずれかを使用して実現されます。</target>
        </trans-unit>
        <trans-unit id="c589001febca68c36ef8079ff9faca5b3d4efc6b" translate="yes" xml:space="preserve">
          <source>Before a new auxiliary function or tokenizer implementation may be registered with FTS5, an application must obtain a pointer to the &quot;fts5_api&quot; structure. There is one fts5_api structure for each database connection with which the FTS5 extension is registered. To obtain the pointer, the application invokes the SQL user-defined function fts5() with a single argument. That argument must be set to a pointer to a pointer to an fts5_api object using the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; interface. The following example code demonstrates the technique:</source>
          <target state="translated">新しい補助関数またはトークナイザー実装をFTS5に登録する前に、アプリケーションは「fts5_api」構造へのポインターを取得する必要があります。 FTS5拡張が登録されているデータベース接続ごとに1つのfts5_api構造があります。ポインターを取得するために、アプリケーションはSQLユーザー定義関数fts5（）を単一の引数で呼び出します。その引数は、&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;インターフェイスを使用して、fts5_apiオブジェクトへのポインターへのポインターに設定する必要があります。次のコード例は、この手法を示しています。</target>
        </trans-unit>
        <trans-unit id="6ae8b38a31b33865e805e86015a35fae53d45a85" translate="yes" xml:space="preserve">
          <source>Before any database pages may be modified within the</source>
          <target state="translated">データベースページが</target>
        </trans-unit>
        <trans-unit id="2aafeb2e2bb5cf3269cb7e705f038008b263f110" translate="yes" xml:space="preserve">
          <source>Before any information-bearing page of the database is modified, the original unmodified content of that page is written into the rollback journal. If a transaction is interrupted and needs to be rolled back, the rollback journal can then be used to restore the database to its original state. Freelist leaf pages bear no information that would need to be restored on a rollback and so they are not written to the journal prior to modification, in order to reduce disk I/O.</source>
          <target state="translated">データベースの情報を含むページが変更される前に、そのページの変更されていないオリジナルの内容がロールバック・ジャーナルに書き込まれます。トランザクションが中断されてロールバックする必要がある場合、ロールバックジャーナルを使用してデータベースを元の状態に復元することができます。フリーリストのリーフページは、ロールバック時に復元する必要のある情報を持たないため、ディスクI/Oを減らすために、変更前のジャーナルには書き込まれません。</target>
        </trans-unit>
        <trans-unit id="e31e39238fffa8a7d3425c769271d3112873aa6f" translate="yes" xml:space="preserve">
          <source>Before calling this method, the SQLite core initializes an instance of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure with information about the query that it is currently trying to process. This information derives mainly from the WHERE clause and ORDER BY or GROUP BY clauses of the query, but also from any ON or USING clauses if the query is a join. The information that the SQLite core provides to the xBestIndex method is held in the part of the structure that is marked as &quot;Inputs&quot;. The &quot;Outputs&quot; section is initialized to zero.</source>
          <target state="translated">このメソッドを呼び出す前に、SQLiteコアは&lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;構造体のインスタンスを、現在処理しようとしているクエリに関する情報で初期化します。この情報は、主にクエリのWHERE句とORDER BY句またはGROUP BY句から取得されますが、クエリが結合である場合は、ONまたはUSING句からも取得されます。SQLiteコアがxBestIndexメソッドに提供する情報は、「入力」としてマークされている構造の部分に保持されます。「出力」セクションはゼロに初期化されます。</target>
        </trans-unit>
        <trans-unit id="29b6c291315b8e1fb3f265c15e369937b630aaf5" translate="yes" xml:space="preserve">
          <source>Before data may be read from a</source>
          <target state="translated">からデータを読み出す前に</target>
        </trans-unit>
        <trans-unit id="cae7b06f8fadf1f8b2bbb51c0629366481aebe32" translate="yes" xml:space="preserve">
          <source>Before entering a trigger program the value returned by sqlite3_changes() function is saved. After the trigger program has finished, the original value is restored.</source>
          <target state="translated">トリガプログラムに入る前に、sqlite3_changes()関数によって返された値が保存されます。トリガプログラムが終了すると、元の値が復元されます。</target>
        </trans-unit>
        <trans-unit id="7968bdea3fbca698f15e058c3369cb48f81fd4ca" translate="yes" xml:space="preserve">
          <source>Before executing a statement that modifies the database schema (i.e. a CREATE or DROP TABLE statement), a connection must obtain a write-lock on</source>
          <target state="translated">データベーススキーマを変更するステートメント(例えばCREATEやDROP TABLEステートメント)を実行する前に、接続は</target>
        </trans-unit>
        <trans-unit id="64443a5dc257f480bf4a79d829dcae9017cc971a" translate="yes" xml:space="preserve">
          <source>Before making changes to any page of the database, the process writes the original content of that page into the rollback journal. Changes to pages are held in memory at first and are not written to the disk. The original database file remains unaltered, which means that other processes can continue to read the database.</source>
          <target state="translated">データベースの任意のページに変更を加える前に、プロセスはそのページの元の内容をロールバック・ジャーナルに書き込みます。ページへの変更は最初はメモリに保持され、ディスクには書き込まれません。元のデータベースファイルは変更されずに残っているため、他のプロセスがデータベースを読み続けることができます。</target>
        </trans-unit>
        <trans-unit id="ed294139e05d80e58de31e418d68f4cfaebeb6a7" translate="yes" xml:space="preserve">
          <source>Before making changes to the database, SQLite first obtains a &quot;reserved&quot; lock on the database file. A reserved lock is similar to a shared lock in that both a reserved lock and shared lock allow other processes to read from the database file. A single reserve lock can coexist with multiple shared locks from other processes. However, there can only be a single reserved lock on the database file. Hence only a single process can be attempting to write to the database at one time.</source>
          <target state="translated">データベースに変更を加える前に、SQLite は最初にデータベースファイルの「予約済み」ロックを取得します。予約ロックは共有ロックと似ていますが、予約ロックと共有ロックの両方が他のプロセスにデータベースファイルからの読み込みを許可するという点では、共有ロックと似ています。1つの予約ロックは、他のプロセスからの複数の共有ロックと共存することができます。しかし、データベースファイルには1つの予約ロックしか存在できません。そのため、一度にデータベースへの書き込みを試みることができるのは単一のプロセスのみです。</target>
        </trans-unit>
        <trans-unit id="e0b64dbebb4ad46a9aeb1a098c15aadd4e3eaf44" translate="yes" xml:space="preserve">
          <source>Before modifying a database page within the</source>
          <target state="translated">データベースページを変更する前に</target>
        </trans-unit>
        <trans-unit id="98e0ccf77dc018ac7ea18b90477a40f1a7c510fa" translate="yes" xml:space="preserve">
          <source>Before opening a</source>
          <target state="translated">開設前に</target>
        </trans-unit>
        <trans-unit id="6822a9cef8f0664c32cddfaac23e4bff41485b02" translate="yes" xml:space="preserve">
          <source>Before reading from a database file, SQLite always checks to see if that database file has a hot journal. If the file does have a hot journal, then the journal is rolled back before the file is read. In this way, we ensure that the database file is in a consistent state before it is read.</source>
          <target state="translated">データベースファイルから読み込む前に、SQLite は常にそのデータベースファイルにホットジャーナルがあるかどうかをチェックします。ファイルにホットジャーナルがある場合は、ファイルを読み込む前にジャーナルがロールバックされます。このようにして、データベースファイルが読み込まれる前に一貫した状態になっていることを確認します。</target>
        </trans-unit>
        <trans-unit id="2ffabc9625263621654187c58d31675c59e6730d" translate="yes" xml:space="preserve">
          <source>Before the content of a page modified within the</source>
          <target state="translated">内でページの内容が変更される前に</target>
        </trans-unit>
        <trans-unit id="2a76187aef00ad8a5abadfac889a6b98dd1db2fb" translate="yes" xml:space="preserve">
          <source>Before the contents of the</source>
          <target state="translated">の内容の前に</target>
        </trans-unit>
        <trans-unit id="5f97138118a317cbc3bf1e3e8dd4c6fd1edd23a0" translate="yes" xml:space="preserve">
          <source>Before we begin looking at this problem, let's briefly review how queries work in SQLite so that we will know what we are trying to accomplish. For each row in the result of a query, SQLite will invoke a callback function with the following prototype:</source>
          <target state="translated">この問題を見始める前に、何を達成しようとしているのかが分かるように、SQLiteでのクエリの仕組みを簡単におさらいしておきましょう。クエリの結果の各行に対して、SQLiteは以下のようなプロトタイプを持つコールバック関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="5c00a0d3ea5cf97be2cbc8e0c749bfff4206bbf5" translate="yes" xml:space="preserve">
          <source>Begin a transaction on database P1 if a transaction is not already active. If P2 is non-zero, then a write-transaction is started, or if a read-transaction is already active, it is upgraded to a write-transaction. If P2 is zero, then a read-transaction is started.</source>
          <target state="translated">トランザクションがまだアクティブでない場合、データベースP1上でトランザクションを開始します。P2が0以外の場合、書き込みトランザクションが開始され、読み込みトランザクションが既にアクティブな場合は書き込みトランザクションにアップグレードされます。P2が0の場合、読み取りトランザクションが開始されます。</target>
        </trans-unit>
        <trans-unit id="2fd194a93ac6ccfaf40c7f7cd5a992cb067293a7" translate="yes" xml:space="preserve">
          <source>Begin adding lots of new documentation</source>
          <target state="translated">新しいドキュメントをたくさん追加し始める</target>
        </trans-unit>
        <trans-unit id="90c994ef269c7ca4806cc0aace7ca7e97ba28671" translate="yes" xml:space="preserve">
          <source>Begin by obtaining a copy of SQLite in whatever form you use it. The public SQLite you obtain should be as close to your private edited copy as possible. If your project uses the SQLite amalgamation, then get a copy of the amalgamation. If you use the preprocessed separate source files, get those instead. Put all the source files in the checkout directory created in the previous step.</source>
          <target state="translated">使用する形式に関わらず、SQLiteのコピーを取得することから始めます。入手した公開SQLiteは、自分のプライベートな編集コピーにできるだけ近いものにしてください。あなたのプロジェクトがSQLiteアマルガムを使用している場合は、アマルガムのコピーを入手してください。前処理済みの別のソースファイルを使用している場合は、その代わりにそれらのソースファイルを入手してください。すべてのソースファイルを前のステップで作成したチェックアウトディレクトリに置きます。</target>
        </trans-unit>
        <trans-unit id="c95a84f6810e9547323b7d36381036499b6e85a2" translate="yes" xml:space="preserve">
          <source>Begin enforcing &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvdbeop&quot;&gt;SQLITE_LIMIT_VDBE_OP&lt;/a&gt;. This can be used, for example, to prevent excessively large prepared statements in systems that accept SQL queries from untrusted users.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvdbeop&quot;&gt;SQLITE_LIMIT_VDBE_OPの&lt;/a&gt;適用を開始します。これは、たとえば、信頼されていないユーザーからのSQLクエリを受け入れるシステムで準備されたステートメントが過度に大きくなるのを防ぐために使用できます。</target>
        </trans-unit>
        <trans-unit id="6b5e2f03338f65ea55efadd743c2073f0844124d" translate="yes" xml:space="preserve">
          <source>Begin every identifier with the letter &quot;Z&quot; as no SQL keywords start with &quot;Z&quot;.</source>
          <target state="translated">Z &quot;で始まるSQLキーワードはないので、すべての識別子は &quot;Z &quot;で始めてください。</target>
        </trans-unit>
        <trans-unit id="c7c9b7ac07f4b963268a3915518a82c60026c1c8" translate="yes" xml:space="preserve">
          <source>Begin writing documentation on the TCL interface.</source>
          <target state="translated">TCL インタフェースのドキュメントの作成を開始します。</target>
        </trans-unit>
        <trans-unit id="d93624195948cab4e3c3cf8a06c4ba66150434ee" translate="yes" xml:space="preserve">
          <source>Begin writing the &lt;a href=&quot;vdbe&quot;&gt;VDBE tutorial&lt;/a&gt;.</source>
          <target state="translated">書き込みを開始&lt;a href=&quot;vdbe&quot;&gt;VDBEチュートリアルを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2891bac57361d1d80487ccfbba99ba09325df3b5" translate="yes" xml:space="preserve">
          <source>Beginning a Write Transaction</source>
          <target state="translated">書き込みトランザクションの開始</target>
        </trans-unit>
        <trans-unit id="60eca843fdd7093ad8665839ef32416ade71c639" translate="yes" xml:space="preserve">
          <source>Beginning in 2016, a team of engineers at Google started the &lt;a href=&quot;https://github.com/google/oss-fuzz&quot;&gt;OSS Fuzz&lt;/a&gt; project. OSS Fuzz uses a AFL-style guided fuzzer running on Google's infrastructure. The Fuzzer automatically downloads the latest check-ins for participating projects, fuzzes them, and sends email to the developers reporting any problems. When a fix is checked in, the fuzzer automatically detects this and emails a confirmation to the developers.</source>
          <target state="translated">2016年から、Googleのエンジニアチームが&lt;a href=&quot;https://github.com/google/oss-fuzz&quot;&gt;OSS Fuzz&lt;/a&gt;プロジェクトを開始しました。OSSファズは、Googleのインフラストラクチャで実行されるAFLスタイルのガイド付きファザーを使用します。Fuzzerは、参加しているプロジェクトの最新のチェックインを自動的にダウンロードし、ファジングし、問題を報告する開発者にメールを送信します。修正がチェックインされると、ファザーはこれを自動的に検出し、開発者に確認のメールを送信します。</target>
        </trans-unit>
        <trans-unit id="52ddec92a44c4044495e3a4272f88fb5bf0d2787" translate="yes" xml:space="preserve">
          <source>Beginning in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_15_0.html&quot;&gt;version 3.15.0&lt;/a&gt; (2016-10-14), an assignment in the SET clause can be a &lt;a href=&quot;syntax/column-name-list&quot;&gt;parenthesized list of column names&lt;/a&gt; on the left and a &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; of the same size on the right.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_15_0.html&quot;&gt;バージョン3.15.0&lt;/a&gt;（2016-10-14）以降、SET句の割り当ては、左側に&lt;a href=&quot;syntax/column-name-list&quot;&gt;括弧で囲ま&lt;/a&gt;れた列名のリスト、右側に同じサイズの&lt;a href=&quot;rowvalue&quot;&gt;行の値&lt;/a&gt;になります。</target>
        </trans-unit>
        <trans-unit id="8e0744464084ddf340ea6c6e0a24aad6d9c12c18" translate="yes" xml:space="preserve">
          <source>Beginning in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_4.html&quot;&gt;version 3.6.4&lt;/a&gt; (2008-10-15), the TRUNCATE journal mode is also supported:</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_4.html&quot;&gt;バージョン3.6.4&lt;/a&gt;（2008-10-15）以降、TRUNCATEジャーナルモードもサポートされています。</target>
        </trans-unit>
        <trans-unit id="6adac7327da12129344605aed8c6230ec2a45b5c" translate="yes" xml:space="preserve">
          <source>Beginning in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_4.html&quot;&gt;version 3.7.4&lt;/a&gt; (2010-12-07), WAL databases can be created, read, and written even if shared memory is unavailable as long as the &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt; is set to EXCLUSIVE before the first attempted access. In other words, a process can interact with a WAL database without using shared memory if that process is guaranteed to be the only process accessing the database. This feature allows WAL databases to be created, read, and written by legacy &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; that lack the &quot;version 2&quot; shared-memory methods xShmMap, xShmLock, xShmBarrier, and xShmUnmap on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_4.html&quot;&gt;バージョン3.7.4&lt;/a&gt;（2010-12-07）以降、共有メモリが利用できない場合でも、最初にアクセスを試行する前に&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt;がEXCLUSIVEに設定されている限り、WALデータベースを作成、読み取り、書き込みできます。つまり、データベースにアクセスする唯一のプロセスであることが保証されているプロセスは、共有メモリを使用せずにWALデータベースと対話できます。この機能を使用すると、&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;オブジェクトに「バージョン2」の共有メモリメソッドxShmMap、xShmLock、xShmBarrier、&lt;a href=&quot;vfs&quot;&gt;xShmUnmap&lt;/a&gt;がないレガシーVFSでWALデータベースを作成、読み取り、書き込みできます。</target>
        </trans-unit>
        <trans-unit id="0f100a899b26537fc63caa4230653ce9716130e4" translate="yes" xml:space="preserve">
          <source>Beginning in SQLite version 3.5.0, the new Virtual File System (VFS) interface contains a method named xDeviceCharacteristics which reports on special properties that the underlying mass storage device might have. Among the special properties that xDeviceCharacteristics might report is the ability of to do an atomic sector write.</source>
          <target state="translated">SQLite バージョン 3.5.0 以降、新しい仮想ファイルシステム (VFS)インターフェイスには xDeviceCharacteristics という名前のメソッドが含まれています。xDeviceCharacteristics が報告する特殊なプロパティの中には、アトミックセクタ書き込みの能力があります。</target>
        </trans-unit>
        <trans-unit id="dbe6df39f8d021809fb2ab3e47422b19fa74d670" translate="yes" xml:space="preserve">
          <source>Beginning in late 2018, SQLite has been fuzzed using a new proprietary fuzzer called &quot;dbsqlfuzz&quot;. Dbsqlfuzz is built using the &lt;a href=&quot;http://llvm.org/docs/LibFuzzer.html&quot;&gt;libFuzzer&lt;/a&gt; framework of LLVM.</source>
          <target state="translated">2018年後半から、SQLiteは「dbsqlfuzz」と呼ばれる新しい独自のファザーを使用してファジングされました。Dbsqlfuzzは、LLVM の&lt;a href=&quot;http://llvm.org/docs/LibFuzzer.html&quot;&gt;libFuzzer&lt;/a&gt;フレームワークを使用して構築されています。</target>
        </trans-unit>
        <trans-unit id="a4f6d3a3a096224887296bd514258ca7ceae764c" translate="yes" xml:space="preserve">
          <source>Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2010-07-21), SQLite supports a new transaction control mechanism called &quot;&lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt;&quot; or &quot;&lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;&quot;. When a database is in WAL mode, all connections to that database must use the WAL. A particular database will use either a rollback journal or a WAL, but not both at the same time. The WAL is always located in the same directory as the database file and has the same name as the database file but with the string &quot;&lt;code&gt;-wal&lt;/code&gt;&quot; appended.</source>
          <target state="translated">始まる&lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;バージョン3.7.0&lt;/a&gt;（2010-07-21）、SQLiteは「と呼ばれる新しいトランザクション制御メカニズムをサポート&lt;a href=&quot;wal&quot;&gt;先行書き込みログ&lt;/a&gt;」または「&lt;a href=&quot;wal&quot;&gt;WALを&lt;/a&gt;」。データベースがWALモードの場合、そのデータベースへのすべての接続でWALを使用する必要があります。特定のデータベースは、ロールバックジャーナルまたはWALのいずれかを使用しますが、同時に両方は使用しません。WALは常にデータベースファイルと同じディレクトリにあり、データベースファイルと同じ名前ですが、文字列 &quot; &lt;code&gt;-wal&lt;/code&gt; &quot;が追加されています。</target>
        </trans-unit>
        <trans-unit id="d9839d2cef57fa5d151a0ce9cbe15a6e0c36fbc7" translate="yes" xml:space="preserve">
          <source>Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;version 3.7.17&lt;/a&gt; (2013-05-20), SQLite has the option of accessing disk content directly using memory-mapped I/O and the new xFetch() and xUnfetch() methods on &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;.</source>
          <target state="translated">始まる&lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;バージョン3.7.17&lt;/a&gt;（2013年5月20日）、SQLiteのは）メモリマップドI / Oと新しいxFetchを（使用して直接ディスクのコンテンツにアクセスするためのオプションを持っており、上xUnfetch（）メソッド&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="26a395622db69c8b77803fcd06e3a2c5d4cdefa3" translate="yes" xml:space="preserve">
          <source>Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_7.html&quot;&gt;version 3.7.7&lt;/a&gt; (2011-06-23), the SQLite database file argument to the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interfaces and to the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command can be specified either as an ordinary filename or as a Uniform Resource Identifier or URI. The advantage of using a URI filename is that query parameters on the URI can be used to control details of the newly created database connection. For example, an alternative &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; can be specified using a &quot;vfs=&quot; query parameter. Or the database can be opened read-only by using &quot;mode=ro&quot; as a query parameter.</source>
          <target state="translated">始まる&lt;a href=&quot;https://sqlite.org/releaselog/3_7_7.html&quot;&gt;バージョン3.7.7&lt;/a&gt;（2011-06-23）へのSQLiteデータベースファイル引数&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（） &lt;/a&gt;、&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16（） &lt;/a&gt;、及び&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;インターフェースとに&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;コマンドは、通常のファイル名として、またはAのいずれかとして指定することができUniform Resource IdentifierまたはURI。 URIファイル名を使用する利点は、URIのクエリパラメータを使用して、新しく作成されたデータベース接続の詳細を制御できることです。たとえば、「vfs =」クエリパラメータを使用して、代替&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;を指定できます。または、クエリパラメータとして「mode = ro」を使用して、データベースを読み取り専用で開くことができます。</target>
        </trans-unit>
        <trans-unit id="8b26610830584adfe4c3b1f430311725c505dc65" translate="yes" xml:space="preserve">
          <source>Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14) SQLite uses &lt;a href=&quot;http://semver.org&quot;&gt;semantic versioning&lt;/a&gt;. Prior to that time, SQLite employed a version identifier that contained between two and four numbers.</source>
          <target state="translated">始まる&lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;バージョン3.9.0&lt;/a&gt;（2015年10月14日）SQLiteが使用する&lt;a href=&quot;http://semver.org&quot;&gt;セマンティックバージョニングを&lt;/a&gt;。それ以前は、SQLiteは2〜4個の数字を含むバージョン識別子を採用していました。</target>
        </trans-unit>
        <trans-unit id="e8a7a785dc79c6f97e7e9b629f10c98e7d6eaa12" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite 3.23.0 (2018-04-02), SQLite recognizes the identifiers &quot;TRUE&quot; and &quot;FALSE&quot; as boolean literals, if and only if those identifiers are not already used for some other meaning. If there already exists columns or tables or other objects named TRUE or FALSE, then for the sake of backwards compatibility, the TRUE and FALSE identifiers refer to those other objects, not to the boolean values.</source>
          <target state="translated">SQLite 3.23.0 (2018-04-02)以降、SQLite は &quot;TRUE&quot; および &quot;FALSE&quot; という識別子をブール値リテラルとして認識します。カラムやテーブル、あるいは TRUE や FALSE という名前の他のオブジェクトが既に存在する場合は、下位互換性のために、TRUE および FALSE 識別子はそれらの他のオブジェクトを参照し、ブーリアン値を参照するのではありません。</target>
        </trans-unit>
        <trans-unit id="e27a2a72ed98b30f89096b193da3e3a912285cdd" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_10_0.html&quot;&gt;version 3.10.0&lt;/a&gt; (2016-01-06), the unix OS interface will attempt to resolve symbolic links and open the database file by its canonical name. Prior to version 3.10.0, opening a database file through a symbolic link was similar to opening a database file that had multiple hard links and resulted in undefined behavior.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_10_0.html&quot;&gt;バージョン3.10.0&lt;/a&gt;（2016-01-06）以降、UNIX OSインターフェースはシンボリックリンクを解決し、正規名でデータベースファイルを開こうとします。バージョン3.10.0より前のバージョンでは、シンボリックリンクを介してデータベースファイルを開くことは、複数のハードリンクを含むデータベースファイルを開くことに似ていて、未定義の動作を引き起こしていました。</target>
        </trans-unit>
        <trans-unit id="669009bffd329a7525e12f992041efbc93a9e4fc" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_14.html&quot;&gt;version 3.14.0&lt;/a&gt; (2016-08-08), the CREATE TABLE statement that is passed into &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; may contain a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; clause. This is useful for cases where the virtual table rows cannot easily be mapped into unique integers. A CREATE TABLE statement that includes WITHOUT ROWID must define one or more columns as the PRIMARY KEY. Every column of the PRIMARY KEY must individually be NOT NULL and all columns for each row must be collectively unique.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_14.html&quot;&gt;バージョン3.14.0&lt;/a&gt;（2016-08-08）以降、&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab（）に&lt;/a&gt;渡されるCREATE TABLEステートメントには&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;句が含まれる場合があります。これは、仮想テーブルの行を一意の整数に簡単にマップできない場合に役立ちます。 WITHOUT ROWIDを含むCREATE TABLEステートメントは、1つ以上の列をPRIMARY KEYとして定義する必要があります。 PRIMARY KEYのすべての列は個別にNOT NULLでなければならず、各行のすべての列は集合的に一意でなければなりません。</target>
        </trans-unit>
        <trans-unit id="914fd4075646f327da4b592c31312990facc6a8d" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_23_0.html&quot;&gt;version 3.23.0&lt;/a&gt; (2018-04-02), SQLite also recognizes TRUE and FALSE keywords as aliases for integer values 1 and 0, respectively. This provides better compatibility with other SQL implementations. But to retain backwards compatibility, if there are columns named TRUE or FALSE, then the keywords are treated as identifiers referencing those columns, rather than BOOLEAN literals.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_23_0.html&quot;&gt;バージョン3.23.0&lt;/a&gt;（2018-04-02）以降、SQLiteは、TRUEキーワードとFALSEキーワードをそれぞれ整数値1と0のエイリアスとして認識します。これにより、他のSQL実装との互換性が向上します。ただし、下位互換性を維持するために、TRUEまたはFALSEという名前の列がある場合、キーワードはBOOLEANリテラルではなく、それらの列を参照する識別子として扱われます。</target>
        </trans-unit>
        <trans-unit id="67498fb6faa33682195156e0b1885f3794748cc2" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_31_0.html&quot;&gt;version 3.31.0&lt;/a&gt; (2020-01-22) the input F parameter can also be the name of a rollback journal file or WAL file in addition to the main database file. Prior to version 3.31.0, these routines would only work if F was the name of the main database file. When the F parameter is the name of the rollback journal or WAL file, it has access to all the same query parameters as were found on the main database file.</source>
          <target state="translated">SQLite&lt;a href=&quot;https://sqlite.org/releaselog/3_31_0.html&quot;&gt;バージョン3.31.0&lt;/a&gt;（2020-01-22）以降、入力Fパラメーターは、メインデータベースファイルに加えて、ロールバックジャーナルファイルまたはWALファイルの名前にすることもできます。バージョン3.31.0より前では、これらのルーチンは、Fがメインデータベースファイルの名前である場合にのみ機能していました。 FパラメーターがロールバックジャーナルまたはWALファイルの名前である場合、メインデータベースファイルで見つかったものと同じクエリパラメーターすべてにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="d9f2cb99d27921b6ac8152e7a3c891a53596352b" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;version 3.7.13&lt;/a&gt; (2012-06-11), shared cache can be used on &lt;a href=&quot;inmemorydb&quot;&gt;in-memory databases&lt;/a&gt;, provided that the database is created using a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;. For backwards compatibility, shared cache is always disable for in-memory databases if the unadorned name &quot;:memory:&quot; is used to open the database. Prior to version 3.7.13, shared cache was always disabled for in-memory databases regardless of the database name used, current system shared cache setting, or query parameters or flags.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;バージョン3.7.13&lt;/a&gt;（2012-06-11）以降、データベースが&lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;を使用して作成されている場合、共有キャッシュは&lt;a href=&quot;inmemorydb&quot;&gt;インメモリデータベース&lt;/a&gt;で使用できます。下位互換性のために、修飾されていない名前 &quot;：memory：&quot;を使用してデータベースを開く場合、インメモリデータベースの共有キャッシュは常に無効になります。バージョン3.7.13より前のバージョンでは、使用されるデータベース名、現在のシステム共有キャッシュ設定、クエリパラメータやフラグに関係なく、メモリ内データベースの共有キャッシュは常に無効でした。</target>
        </trans-unit>
        <trans-unit id="6365abc3c758d3309a8a458a1000945ef77510f8" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;version 3.7.13&lt;/a&gt; (2012-06-11), shared cache can be used on &lt;a href=&quot;inmemorydb&quot;&gt;in-memory databases&lt;/a&gt;, provided that the database is created using a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;. For backwards compatibility, shared cache is always disabled for in-memory databases if the unadorned name &quot;:memory:&quot; is used to open the database. Prior to version 3.7.13, shared cache was always disabled for in-memory databases regardless of the database name used, current system shared cache setting, or query parameters or flags.</source>
          <target state="translated">SQLite&lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;バージョン3.7.13&lt;/a&gt;（2012-06-11）以降、データベースが&lt;a href=&quot;uri&quot;&gt;URIファイル名&lt;/a&gt;を使用して作成されている場合、共有キャッシュ&lt;a href=&quot;inmemorydb&quot;&gt;をインメモリデータベース&lt;/a&gt;で使用できます。下位互換性のために、装飾されていない名前「：memory：」を使用してデータベースを開く場合、メモリ内データベースの共有キャッシュは常に無効になります。バージョン3.7.13より前は、使用されているデータベース名、現在のシステム共有キャッシュ設定、またはクエリパラメータやフラグに関係なく、インメモリデータベースの共有キャッシュは常に無効にされていました。</target>
        </trans-unit>
        <trans-unit id="4d897fef3b918d90f462942b797bcba2f181cd38" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;version 3.7.17&lt;/a&gt; (2013-05-20), the unix OS interface will send SQLITE_WARNING messages to the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; if a database file has multiple hard links.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;バージョン3.7.17&lt;/a&gt;（2013-05-20）以降、データベースファイルに複数のハードリンクがある場合、UNIX OSインターフェイスはSQLITE_WARNINGメッセージを&lt;a href=&quot;errlog&quot;&gt;エラーログに&lt;/a&gt;送信します。</target>
        </trans-unit>
        <trans-unit id="7fa120398347f1152da8e84a3905c5d3c58c3466" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;version 3.7.17&lt;/a&gt; (2013-05-20), the unix OS interface will send SQLITE_WARNING messages to the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; if a database file is unlinked while it is still in use.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;バージョン3.7.17&lt;/a&gt;（2013-05-20）以降では、データベースファイルがまだ使用されている間にリンクが解除されると、UNIX OSインターフェイスはSQLITE_WARNINGメッセージを&lt;a href=&quot;errlog&quot;&gt;エラーログに&lt;/a&gt;送信します。</target>
        </trans-unit>
        <trans-unit id="8f4af8bd16f5f6dcf0575ed25d9da5ad7a3cecfc" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_3.html&quot;&gt;version 3.7.3&lt;/a&gt; (2010-10-08), the soft heap limit is enforced regardless of whether or not the &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option is invoked. With &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;, the soft heap limit is enforced on every memory allocation. Without &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;, the soft heap limit is only enforced when memory is allocated by the page cache. Testing suggests that because the page cache is the predominate memory user in SQLite, most applications will achieve adequate soft heap limit enforcement without the use of &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_3.html&quot;&gt;バージョン3.7.3&lt;/a&gt;（2010-10-08）以降、&lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;コンパイル時オプションが呼び出されるかどうかに関係なく、ソフトヒープ制限が適用されます。&lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;、ソフトヒープリミットは、すべてのメモリ割り当てに施行されます。なければ&lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;メモリはページキャッシュによって割り当てられた場合、ソフトヒープリミットにのみ適用されます。テストによると、SQLiteではページキャッシュが主なメモリユーザーであるため、ほとんどのアプリケーションは&lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENTを&lt;/a&gt;使用しなくても、適切なソフトヒープ制限を適用できます。</target>
        </trans-unit>
        <trans-unit id="a0dfecc63fffa644348dc3e00941cc0dedd6014a" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_3.html&quot;&gt;version 3.7.3&lt;/a&gt; (2010-10-08), the soft heap limit is enforced regardless of whether or not the &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option is invoked. With &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;, the soft heap limit is enforced on every memory allocation. Without &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;, the soft heap limit is only enforced when memory is allocated by the page cache. Testing suggests that because the page cache is the predominate memory user in SQLite, most applications will achieve adequate soft heap limit enforcement without the use of &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_3.html&quot;&gt;バージョン3.7.3&lt;/a&gt;（2010-10-08）以降、&lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;コンパイル時オプションが呼び出されるかどうかに関係なく、ソフトヒープ制限が適用されます。&lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;、ソフトヒープリミットは、すべてのメモリ割り当てに施行されます。なければ&lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;メモリはページキャッシュによって割り当てられた場合、ソフトヒープリミットにのみ適用されます。テストによると、SQLiteではページキャッシュが主なメモリユーザーであるため、ほとんどのアプリケーションは&lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENTを&lt;/a&gt;使用しなくても、適切なソフトヒープ制限を適用できます。</target>
        </trans-unit>
        <trans-unit id="c179ab3e7d04af330c7efc2cec123a479ee926c3" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite version 3.24.0 (2018-06-04), r-tree tables can have auxiliary columns that store arbitrary data. Auxiliary columns can be used in place of secondary tables such as &quot;demo_data&quot;.</source>
          <target state="translated">SQLite バージョン 3.24.0 (2018-06-04)以降、r-tree テーブルは、任意のデータを格納する補助カラムを持つことができます。補助カラムは、「demo_data」などのセカンダリテーブルの代わりに使用することができます。</target>
        </trans-unit>
        <trans-unit id="e6d8128996ffada537e69bde476b38bfd6abdaaa" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite version 3.3.14 a mechanism has been added to try to reduce the needless rereading of data. In newer versions of SQLite, the data in the user-space pager cache is retained when the lock on the database file is released. Later, after the shared lock is acquired at the beginning of the next transaction, SQLite checks to see if any other process has modified the database file. If the database has been changed in any way since the lock was last released, the user-space cache is erased at that point. But commonly the database file is unchanged and the user-space cache can be retained, and some unnecessary read operations can be avoided.</source>
          <target state="translated">SQLite バージョン 3.3.3.14 以降、データの不要な再読み込みを減らすためのメカニズムが追加されました。新しいバージョンの SQLite では、データベースファイルのロックが解除されると、ユーザースペースのページャーキャッシュ内のデータが保持されます。その後、次のトランザクションの開始時に共有ロックが取得された後、SQLite は他のプロセスがデータベースファイルを変更したかどうかをチェックします。ロックが最後に解放されてからデータベースが何らかの方法で変更された場合、その時点でユーザ空間キャッシュは消去されます。しかし、一般的にはデータベースファイルは変更されず、ユーザースペースキャッシュは保持され、いくつかの不必要な読み込み操作を回避することができます。</target>
        </trans-unit>
        <trans-unit id="c39116a071141537c93dfcacc99b39343f685f47" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite version 3.31.0 (2020-01-22), lookaside supports two memory pools, each with a different size slot. The small-slot pool uses 128-byte slots and the large-slot pool uses whatever size is specified by &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;SQLITE_DBCONFIG_LOOKASIDE&lt;/a&gt; (defaulting to 1200 bytes). Splitting the pool in two like this allows memory allocations to be covered by lookaside more often while at the same time reducing per-database-connection heap usage from 120KB down to 48KB.</source>
          <target state="translated">SQLiteバージョン3.31.0（2020-01-22）以降、lookasideは2つのメモリプールをサポートし、それぞれに異なるサイズのスロットがあります。小スロットプールは128バイトのスロットを使用し、大スロットプールは&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;SQLITE_DBCONFIG_LOOKASIDE&lt;/a&gt;で指定されたサイズ（デフォルトは1200バイト）を使用します。このようにプールを2つに分割すると、メモリ割り当てをルックアサイドでカバーする頻度が高くなると同時に、データベース接続ごとのヒープ使用量が120KBから48KBに削減されます。</target>
        </trans-unit>
        <trans-unit id="635d1349e5a7c9b8fbfcde84b9ea3c1fb202bc64" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite version 3.31.0 (2020-01-22), the DBSTAT table has a new &lt;a href=&quot;vtab#hiddencol&quot;&gt;hidden column&lt;/a&gt; named &quot;aggregate&quot;, which if constrained to be TRUE will cause DBSTAT to generate one row per btree in the database, rather than one row per page. When running in aggregated mode, the &quot;path&quot;, &quot;pagetype&quot;, and &quot;pgoffset&quot; columns are always NULL and the &quot;pageno&quot; column holds the number of pages in the entire btree, rather than the number of the page that corresponds to the row.</source>
          <target state="translated">SQLiteバージョン3.31.0（2020-01-22）以降、DBSTATテーブルには「aggregate」という名前の新しい&lt;a href=&quot;vtab#hiddencol&quot;&gt;非表示列があります&lt;/a&gt;。これをTRUEに制限すると、DBSTATはデータベース内のbtreeごとに1行ではなく1行を生成します。ページあたりの行。集約モードで実行している場合、「path」、「pagetype」、および「pgoffset」列は常にNULLであり、「pageno」列は、に対応するページの数ではなく、btree全体のページ数を保持します。行。</target>
        </trans-unit>
        <trans-unit id="c0eba5a240e8bc3220e00f595afb167768fa6cb7" translate="yes" xml:space="preserve">
          <source>Beginning with release 3.25.0 (2018-09-15), references to the table within trigger bodies and view definitions are also renamed.</source>
          <target state="translated">リリース 3.25.0 (2018-09-15)から、トリガー本体とビュー定義内のテーブルへの参照も名前が変更されました。</target>
        </trans-unit>
        <trans-unit id="d654ce8d1a877b686fbd470426c428e02c9409c6" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.2.0, SQLite no longer builds an index for an INTEGER PRIMARY KEY column. Instead, it uses that column as the actual B-Tree key for the main table.</source>
          <target state="translated">バージョン 2.2.2.0 以降、SQLite は INTEGER PRIMARY KEY カラムのインデックスを構築しなくなりました。代わりに、そのカラムをメインテーブルの実際の B-Tree キーとして使用します。</target>
        </trans-unit>
        <trans-unit id="042e0229fee0d8bfed5724fa18cd980bad0c1945" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.3.0, SQLite supports some additional syntax (the &quot;ON CONFLICT&quot; clause) in the CREATE TABLE and CREATE INDEX statements that are stored in the SQLITE_MASTER table. If you create a database that contains this new syntax, then try to read that database using version 2.2.5 or earlier, the parser will not understand the new syntax and you will get an error. Otherwise, databases for 2.2.x and 2.3.x are interchangeable.</source>
          <target state="translated">バージョン2.3.0以降、SQLiteはSQLITE_MASTERテーブルに格納されているCREATE TABLE文とCREATE INDEX文で、いくつかの追加構文(&quot;ON CONFLICT &quot;句)をサポートしています。この新しい構文を含むデータベースを作成した後、バージョン2.2.5以前のデータベースを使用してそのデータベースを読み込もうとすると、パーサーは新しい構文を理解できず、エラーが発生します。それ以外の場合、2.2.x と 2.3.x のデータベースは互換性があります。</target>
        </trans-unit>
        <trans-unit id="d9bdf31e2f633cc8ef293e098f7f5d722da8a2a8" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.4.0, SQLite added support for views. Information about views is stored in the SQLITE_MASTER table. If an older version of SQLite attempts to read a database that contains VIEW information in the SQLITE_MASTER table, the parser will not understand the new syntax and initialization will fail. Also, the way SQLite keeps track of unused disk blocks in the database file changed slightly. If an older version of SQLite attempts to write a database that was previously written by version 2.4.0 or later, then it may leak disk blocks.</source>
          <target state="translated">バージョン 2.4.0 以降、SQLite ではビューのサポートが追加されました。ビューに関する情報は SQLITE_MASTER テーブルに格納されています。古いバージョンの SQLite が SQLITE_MASTER テーブルに VIEW 情報を含むデータベースを読み込もうとすると、パーサは新しい構文を理解できず、初期化に失敗します。また、SQLite がデータベースファイル内の未使用のディスクブロックを追跡する方法が若干変更されました。古いバージョンの SQLite が、バージョン 2.4.0 以降で以前に書き込まれたデータベースを書こうとすると、ディスクブロックが漏れる可能性があります。</target>
        </trans-unit>
        <trans-unit id="413008ed4f165a3aca53c2fe0890bace8386a170" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.4.0, SQLite allows the SQL language to be extended with new functions implemented as C code. The following interface is used:</source>
          <target state="translated">バージョン 2.4.0 以降、SQLite では C コードとして実装された新しい関数で SQL 言語を拡張することができます。以下のインターフェイスが使用されています。</target>
        </trans-unit>
        <trans-unit id="8dad8b696b630a32cf19067fe14052c10b2bac25" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.5.0, SQLite added support for triggers. Information about triggers is stored in the SQLITE_MASTER table. If an older version of SQLite attempts to read a database that contains a CREATE TRIGGER in the SQLITE_MASTER table, the parser will not understand the new syntax and initialization will fail.</source>
          <target state="translated">バージョン 2.5.0 以降、SQLite ではトリガーのサポートが追加されました。トリガーに関する情報は SQLITE_MASTER テーブルに格納されています。古いバージョンの SQLite が SQLITE_MASTER テーブルに CREATE TRIGGER を含むデータベースを読み込もうとすると、パーサは新しい構文を理解できず、初期化に失敗します。</target>
        </trans-unit>
        <trans-unit id="50c1ec93a00d0cbe5badad130d3d4fbd2db53937" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.7.0, SQLite understands two different datatypes: text and numeric. Text data sorts in memcmp() order. Numeric data sorts in numerical order if it looks like a number, or in memcmp() order if it does not.</source>
          <target state="translated">バージョン 2.7.0 以降、SQLite はテキストと数値の 2 つの異なるデータ型を理解します。テキストデータは memcmp()の順にソートされます。数値データは、数値のように見える場合は数値順に、そうでない場合はmemcmp()順にソートされます。</target>
        </trans-unit>
        <trans-unit id="c06e002a374c4a8233bf3048a5c902a5ad629404" translate="yes" xml:space="preserve">
          <source>Beginning with version 3.5, SQLite obtains all of the heap memory it needs using the routines &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;, and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc()&lt;/a&gt;. These routines have existed in prior versions of SQLite, but SQLite has previously bypassed these routines and used its own memory allocator. This all changes in version 3.5.0.</source>
          <target state="translated">バージョン3.5以降、SQLiteは、&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;、&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;、および&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;ルーチンを使用して、必要なすべてのヒープメモリを取得します。これらのルーチンは以前のバージョンのSQLiteに存在していましたが、SQLiteは以前にこれらのルーチンをバイパスし、独自のメモリアロケータを使用していました。これはバージョン3.5.0ですべて変更されました。</target>
        </trans-unit>
        <trans-unit id="8cb8a180b3917332f0d153bfa0ea4cd9cfa4625e" translate="yes" xml:space="preserve">
          <source>Behavior when page is not already in cache</source>
          <target state="translated">ページがまだキャッシュに入っていない場合の挙動</target>
        </trans-unit>
        <trans-unit id="8f48bb3f768498f6c1f4331bb2d5a6b0f760fe90" translate="yes" xml:space="preserve">
          <source>Below is a simple &lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;TCL program&lt;/a&gt; that demonstrates how to use the TCL interface to SQLite. The program executes the SQL statements given as the second argument on the database defined by the first argument. The commands to watch for are the &lt;b&gt;sqlite3&lt;/b&gt; command on line 7 which opens an SQLite database and creates a new object named &quot;&lt;b&gt;db&lt;/b&gt;&quot; to access that database, the use of the &lt;a href=&quot;tclsqlite#eval&quot;&gt;eval method&lt;/a&gt; on the &lt;b&gt;db&lt;/b&gt; object on line 8 to run SQL commands against the database, and the closing of the database connection on the last line of the script.</source>
          <target state="translated">以下は、SQLiteへのTCLインターフェイスの使用方法を示す簡単な&lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;TCLプログラム&lt;/a&gt;です。プログラムは、最初の引数で定義されたデータベースの2番目の引数として指定されたSQLステートメントを実行します。監視するコマンドは、7行目の&lt;b&gt;sqlite3&lt;/b&gt;コマンドで、SQLiteデータベースを開き、そのデータベースにアクセスするために「&lt;b&gt;db&lt;/b&gt;」という名前の新しいオブジェクトを作成します。8行目の&lt;b&gt;db&lt;/b&gt;オブジェクトで&lt;a href=&quot;tclsqlite#eval&quot;&gt;evalメソッド&lt;/a&gt;を使用して、SQLコマンドを実行します。データベース、およびスクリプトの最後の行でデータベース接続を閉じる。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="51e427c04349f8bec5760358d6c76a33f48f0315" translate="yes" xml:space="preserve">
          <source>Below is a simple C program that demonstrates how to use the &lt;a href=&quot;c3ref/intro&quot;&gt;C/C++ interface&lt;/a&gt; to SQLite. The name of a database is given by the first argument and the second argument is one or more SQL statements to execute against the database. The function calls to pay attention to here are the call to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; on line 22 which opens the database, &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; on line 28 that executes SQL commands against the database, and &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; on line 33 that closes the database connection.</source>
          <target state="translated">以下は、SQLiteへの&lt;a href=&quot;c3ref/intro&quot;&gt;C / C ++インターフェイスの&lt;/a&gt;使用方法を示す簡単なCプログラムです。データベースの名前は最初の引数で指定され、2番目の引数はデータベースに対して実行する1つ以上のSQLステートメントです。ここに注意を払うへの関数呼び出しはへの呼び出しです&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;データベースをオープンライン22に、&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;データベースに対してSQLコマンドを実行ライン28、及び上&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close（）&lt;/a&gt;データベース接続をクローズライン33上で。</target>
        </trans-unit>
        <trans-unit id="14ff95327015619a83afc17706ad74370a046f84" translate="yes" xml:space="preserve">
          <source>Benefits of SQLite As A File Format</source>
          <target state="translated">ファイル形式としてのSQLiteのメリット</target>
        </trans-unit>
        <trans-unit id="616211207d8aaf668be94882f808c6f4c9f8f380" translate="yes" xml:space="preserve">
          <source>Benefits of using WITHOUT ROWID</source>
          <target state="translated">WITHOUT ROWIDを使うメリット</target>
        </trans-unit>
        <trans-unit id="115df5f31354f3b89a7926f5d6643866714998ab" translate="yes" xml:space="preserve">
          <source>Better Applications</source>
          <target state="translated">より良いアプリケーション</target>
        </trans-unit>
        <trans-unit id="4f38499da00d33476ac2d33142547447ccd5f2e2" translate="yes" xml:space="preserve">
          <source>Better detection and handling of corrupt database files.</source>
          <target state="translated">破損したデータベースファイルの検出と処理が改善されました。</target>
        </trans-unit>
        <trans-unit id="add6069aec6aedde19e26e2f4dc8b5d52557685c" translate="yes" xml:space="preserve">
          <source>Better error reporting when problems occur during the automatic 2.5.6 to 2.6.0 database format upgrade.</source>
          <target state="translated">2.5.6から2.6.0へのデータベースフォーマットの自動アップグレード中に問題が発生した場合のエラー報告が改善されました。</target>
        </trans-unit>
        <trans-unit id="5c0db7dca50a13779a4f0032e6c97723feb41348" translate="yes" xml:space="preserve">
          <source>Better handling of aggregate queries where the aggregate functions are contained within subqueries.</source>
          <target state="translated">サブクエリ内に集約関数が含まれている場合の集約クエリの処理が改善されました。</target>
        </trans-unit>
        <trans-unit id="da084dd71de733c50c5b48104f01706c6f95c252" translate="yes" xml:space="preserve">
          <source>Better labels on column names of the result.</source>
          <target state="translated">結果のカラム名のラベルを改良しました。</target>
        </trans-unit>
        <trans-unit id="03681c8056a98d5199927eacf80bcf86a612f164" translate="yes" xml:space="preserve">
          <source>Better optimization of some IN operator expressions.</source>
          <target state="translated">いくつかのIN演算子式の最適化を改善しました。</target>
        </trans-unit>
        <trans-unit id="591ea8e488260fd421c2b234d660007536c8a620" translate="yes" xml:space="preserve">
          <source>Better support for file locking so that two or more processes (or threads) can access the same database simultaneously. More work needed in this area, though.</source>
          <target state="translated">2つ以上のプロセス(またはスレッド)が同時に同じデータベースにアクセスできるように、ファイルロックのサポートを改善しました。この分野では、より多くの作業が必要とされています。</target>
        </trans-unit>
        <trans-unit id="edfa329825b8b1d38ad9507f28f42ef4366de8b4" translate="yes" xml:space="preserve">
          <source>Between them, the contents of the &quot;level&quot; and &quot;idx&quot; fields define the relative age of the segment b-tree. The smaller the value stored in the &quot;level&quot; field, the more recently the segment b-tree was created. If two segment b-trees are of the same &quot;level&quot;, the segment with the larger value stored in the &quot;idx&quot; column is more recent. The PRIMARY KEY constraint on the %_segdir table prevents any two segments from having the same value for both the &quot;level&quot; and &quot;idx&quot; fields.</source>
          <target state="translated">これらの間で、&quot;level&quot; フィールドと &quot;idx&quot; フィールドの内容は、セグメント b-tree の相対的な年齢を定義します。level&quot; フィールドに格納されている値が小さいほど、そのセグメント b-tree が作成されたのが新しいことを意味します。2 つのセグメント b ツリーが同じ &quot;level&quot; の場合、&quot;idx&quot; 列に格納されている値が大きい方のセグメントがより新しいものとなります。segdir テーブルの PRIMARY KEY 制約により、2 つのセグメントが &quot;level&quot; フィールドと &quot;idx&quot; フィールドの両方で同じ値を持つことはできません。</target>
        </trans-unit>
        <trans-unit id="3a826f46e213d85c4e2bac37d6cf8440b8e199d0" translate="yes" xml:space="preserve">
          <source>Beware of deleting persistent journal files by any other means since the journal file might be hot, in which case deleting it will corrupt the corresponding database file.</source>
          <target state="translated">ジャーナルファイルが高温になっている可能性があり、その場合は削除すると対応するデータベースファイルが破損してしまうので、他の方法で永続的なジャーナルファイルを削除することに注意してください。</target>
        </trans-unit>
        <trans-unit id="bb96cbd05d1971e3d28050245a8829dd6b6aafd2" translate="yes" xml:space="preserve">
          <source>Binary operators</source>
          <target state="translated">バイナリ演算子</target>
        </trans-unit>
        <trans-unit id="d2ac1eab329712a8a9c96ce99d077a92e950ad90" translate="yes" xml:space="preserve">
          <source>Bind values to &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; using the sqlite3_bind_*() interfaces.</source>
          <target state="translated">sqlite3_bind _ *（）インターフェースを使用して、値を&lt;a href=&quot;../lang_expr#varparam&quot;&gt;パラメーターに&lt;/a&gt;バインドします。</target>
        </trans-unit>
        <trans-unit id="e8d99e3f4d2a89e533a8c574a3feaf717d81ec03" translate="yes" xml:space="preserve">
          <source>Bind values to &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; using the sqlite3_bind_*() interfaces.</source>
          <target state="translated">sqlite3_bind _ *（）インターフェースを使用して、値を&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメーターに&lt;/a&gt;バインドします。</target>
        </trans-unit>
        <trans-unit id="7e1661e468dacca4fb2103651a60de473fcaf35b" translate="yes" xml:space="preserve">
          <source>Binding Values To Prepared Statements</source>
          <target state="translated">作成されたステートメントへの値のバインド</target>
        </trans-unit>
        <trans-unit id="416ca5a10db41c1cbc8b3d0b2abf3f34e937f4af" translate="yes" xml:space="preserve">
          <source>Bindings are not cleared by the &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; routine. Unbound parameters are interpreted as NULL.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;ルーチンではバインディングはクリアされません。非バインドパラメータはNULLとして解釈されます。</target>
        </trans-unit>
        <trans-unit id="712e7456596b23817bd39e4145191dbf11698c78" translate="yes" xml:space="preserve">
          <source>Bindings are not cleared by the &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; routine. Unbound parameters are interpreted as NULL.</source>
          <target state="translated">&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;ルーチンではバインディングはクリアされません。非バインドパラメータはNULLとして解釈されます。</target>
        </trans-unit>
        <trans-unit id="309af9e25956170a810f78e3c71afc45e9766ccf" translate="yes" xml:space="preserve">
          <source>BitAnd</source>
          <target state="translated">BitAnd</target>
        </trans-unit>
        <trans-unit id="0c26c52f02ad0e8a5ab4b7954c846a924ecffb7e" translate="yes" xml:space="preserve">
          <source>BitNot</source>
          <target state="translated">BitNot</target>
        </trans-unit>
        <trans-unit id="f64578ede789cb16c75f551e17bc358c839da2a7" translate="yes" xml:space="preserve">
          <source>BitOr</source>
          <target state="translated">BitOr</target>
        </trans-unit>
        <trans-unit id="c24315eb20cc1f5a565ec08f29abab31c0925f1a" translate="yes" xml:space="preserve">
          <source>Blob</source>
          <target state="translated">Blob</target>
        </trans-unit>
        <trans-unit id="d309b3faf2ef71b6ca2ba079fca1c0074e7599d4" translate="yes" xml:space="preserve">
          <source>Blob containing the root node of the segment b-tree.</source>
          <target state="translated">セグメント b-tree のルートノードを含むブロブ。</target>
        </trans-unit>
        <trans-unit id="d284e53d53a1c613b92c33b3c974704b23b2a857" translate="yes" xml:space="preserve">
          <source>Block until the unlock-notify callback is invoked by another thread.</source>
          <target state="translated">unlock-notify コールバックが別のスレッドで呼び出されるまでブロックします。</target>
        </trans-unit>
        <trans-unit id="c9ac379f83771407fb1e0d78aaf3f7b5adc6706f" translate="yes" xml:space="preserve">
          <source>Boolean Expressions</source>
          <target state="translated">ブール式</target>
        </trans-unit>
        <trans-unit id="c4e413aea96ae1ca804567104303036969e3a88f" translate="yes" xml:space="preserve">
          <source>Boolean datatype</source>
          <target state="translated">ブール型</target>
        </trans-unit>
        <trans-unit id="cb72c24cf8f622cb6c601ea54b18c1fb6181c3db" translate="yes" xml:space="preserve">
          <source>Boolean expression</source>
          <target state="translated">ブール式</target>
        </trans-unit>
        <trans-unit id="275cc7006db94d75505db825dc5542aed9bfc26c" translate="yes" xml:space="preserve">
          <source>Borland</source>
          <target state="translated">Borland</target>
        </trans-unit>
        <trans-unit id="2198db2aa3b167004c136853d6cdd281fb62f84a" translate="yes" xml:space="preserve">
          <source>Borland Interbase does not support CASE expressions.</source>
          <target state="translated">ボーランド・インターベースはCASE表現をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="ddec281bbecd09ca0988545c1af57dbffaa268c1" translate="yes" xml:space="preserve">
          <source>Both UPDATE statements do exactly the same thing. (They generate identical &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt;.) But the first form, the row value form, seems to make it clearer that the intent of the statement is to swap the values in columns A and B.</source>
          <target state="translated">両方のUPDATEステートメントは、まったく同じことを行います。（それらは同じ&lt;a href=&quot;opcode&quot;&gt;バイトコード&lt;/a&gt;を生成します。）しかし、最初の形式である行値形式は、ステートメントの意図が列AとBの値を交換することであることをより明確にするようです。</target>
        </trans-unit>
        <trans-unit id="1dfb4c7d44434c0c4d4db97610721023fe7e4509" translate="yes" xml:space="preserve">
          <source>Both forms of the CASE expression use lazy, or short-circuit, evaluation.</source>
          <target state="translated">どちらの形式のCASE式も、遅延評価、短絡評価を使用します。</target>
        </trans-unit>
        <trans-unit id="bb63583b07e5e464e63e50a8a4cb32ce2f9c5978" translate="yes" xml:space="preserve">
          <source>Both methods for loading an extension allow you to specify the name of an entry point for the extension. You can leave this argument blank - passing in a NULL pointer for the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; C-language interface or omitting the second argument for the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL interface - and the extension loader logic will attempt to figure out the entry point on its own. It will first try the generic extension name &quot;sqlite3_extension_init&quot;. If that does not work, it constructs a entry point using the template &quot;sqlite3_X_init&quot; where the X is replaced by the lowercase equivalent of every ASCII character in the filename after the last &quot;/&quot; and before the first following &quot;.&quot; omitting the first three characters if they happen to be &quot;lib&quot;. So, for example, if the filename is &quot;/usr/lib/libmathfunc-4.8.so&quot; the entry point name would be &quot;sqlite3_mathfunc_init&quot;. Or if the filename is &quot;./SpellFixExt.dll&quot; then the entry point would be called &quot;sqlite3_spellfixext_init&quot;.</source>
          <target state="translated">拡張機能をロードするためのどちらの方法でも、拡張機能のエントリポイントの名前を指定できます。この引数は空白のままにできます&lt;a href=&quot;c3ref/load_extension&quot;&gt;-sqlite3_load_extension（）&lt;/a&gt; C言語インターフェースのNULLポインターを渡すか、&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension（）の&lt;/a&gt; 2番目の引数を省略しますSQLインターフェース-そして拡張ローダーロジックは、それ自体でエントリポイントを理解しようとします。最初に一般的な拡張名「sqlite3_extension_init」を試します。それが機能しない場合は、テンプレート「sqlite3_X_init」を使用してエントリポイントを作成します。Xは、最後の「/」の後、最初の「。」の前のファイル名のすべてのASCII文字に対応する小文字に置き換えられます。最初の3文字がたまたま「lib」の場合は省略します。したがって、たとえば、ファイル名が「/usr/lib/libmathfunc-4.8.so」の場合、エントリポイント名は「sqlite3_mathfunc_init」になります。または、ファイル名が「./SpellFixExt.dll」の場合、エントリポイントは「sqlite3_spellfixext_init」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="8d91ab9fdfa652980c96ceff09049c0ea85b3c70" translate="yes" xml:space="preserve">
          <source>Both of the RBU functions may be accomplished using SQLite's built-in SQL commands - RBU update via a series of &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; and &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; commands within a single transaction, and RBU vacuum by a single &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command. The RBU module provides the following advantages over these simpler approaches:</source>
          <target state="translated">両方のRBU関数は、SQLiteの組み込みSQLコマンドを使用して実行できます。単一のトランザクション内での一連の&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;、&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;、および&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;コマンドによるRBUの更新、および単一の&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;コマンドによるRBUバキューム。 RBUモジュールには、これらの単純なアプローチに比べて次の利点があります。</target>
        </trans-unit>
        <trans-unit id="e0f6600d4e5a9c39fa518762238ad90dd63b65fb" translate="yes" xml:space="preserve">
          <source>Both of the above example queries would work fine without the acctchng_magnitude index. The acctchng_magnitude index index merely helps the queries to run faster, especially on databases where there are many entries in the table for each account.</source>
          <target state="translated">上記の例のクエリは、どちらも acctchng_magnitude インデックスがなくても問題なく動作します。acctchng_magnitude インデックスは、特に各アカウントのテーブルに多くのエントリがあるデータベースでは、クエリの実行速度を速めるのに役立つだけです。</target>
        </trans-unit>
        <trans-unit id="7a2132ed90a9ffb07d66917a3fc0b34d8d92cac4" translate="yes" xml:space="preserve">
          <source>Both the TCL and TH3 test harnesses automatically track system resources and report resource leaks on &lt;u&gt;every&lt;/u&gt; test run. No special configuration or setup is required. The test harnesses are especially vigilant with regard to memory leaks. If a change causes a memory leak, the test harnesses will recognize this quickly. SQLite is designed to never leak memory, even after an exception such as an OOM error or disk I/O error. The test harnesses are zealous to enforce this.</source>
          <target state="translated">TCLとTH3の両方のテストハーネスは、システムリソースを自動的に追跡し&lt;u&gt;、&lt;/u&gt;テストの実行&lt;u&gt;ごとに&lt;/u&gt;リソースリークを報告します。特別な設定やセットアップは必要ありません。テストハーネスは、メモリリークに関して特に警戒しています。変更によってメモリリークが発生した場合、テストハーネスはこれをすばやく認識します。 SQLiteは、OOMエラーやディスクI / Oエラーなどの例外が発生した後でも、メモリをリークしないように設計されています。テストハーネスはこれを実施するために熱心です。</target>
        </trans-unit>
        <trans-unit id="0ad3d82720f17203691deee7f5777d99c121ae33" translate="yes" xml:space="preserve">
          <source>Both the WHEN clause and the trigger actions may access elements of the row being inserted, deleted or updated using references of the form &quot;NEW.</source>
          <target state="translated">WHEN句とトリガーアクションの両方とも、&quot;NEW &quot;という形式の参照を使用して、挿入、削除、または更新される行の要素にアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="f093637993a88624b64eec10be0614efea759e81" translate="yes" xml:space="preserve">
          <source>Both the pointer and the pointer type parameter to the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; interfaces are &quot;owned&quot; by the caller. In other words, the caller is responsible for ensuring that both values remain valid until after the last access via &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;および&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;インターフェースへのポインターとポインタータイプパラメーターの両方が呼び出し元によって「所有」されます。言い換えると、呼び出し元は、&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer（）を&lt;/a&gt;介した最後のアクセスが完了するまで両方の値が有効であることを確認する責任があります。</target>
        </trans-unit>
        <trans-unit id="d575a966c9a089363bea2d3980a3ff66687213c3" translate="yes" xml:space="preserve">
          <source>Both virtual tables are read-only &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual tables&lt;/a&gt;. You use them by mentioning them directly in the FROM clause of a SELECT statement. They both require a single argument which is the SQL statement to be analyzed. For example:</source>
          <target state="translated">両方の仮想テーブルは、読み取り専用の&lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;同名の仮想テーブル&lt;/a&gt;です。 SELECTステートメントのFROM句で直接言及することにより、それらを使用します。どちらも、分析するSQLステートメントである単一の引数を必要とします。例えば：</target>
        </trans-unit>
        <trans-unit id="2992a96404e75efb9d5d247c72b5e6d63bb4aa3e" translate="yes" xml:space="preserve">
          <source>Boundary value tests</source>
          <target state="translated">境界値テスト</target>
        </trans-unit>
        <trans-unit id="3145fd01726b003b2b97b5a9fb483277f3a90dd2" translate="yes" xml:space="preserve">
          <source>Branch coverage in SQLite is currently measured using &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcov&lt;/a&gt; with the &quot;-b&quot; option. First the test program is compiled using options &quot;-g -fprofile-arcs -ftest-coverage&quot; and then the test program is run. Then &quot;gcov -b&quot; is run to generate a coverage report. The coverage report is verbose and inconvenient to read, so the gcov-generated report is processed using some simple scripts to put it into a more human-friendly format. This entire process is automated using scripts, of course.</source>
          <target state="translated">SQLiteのブランチカバレッジは現在、「-b」オプションを指定した&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcov&lt;/a&gt;を使用して測定されています。最初に、オプション &quot;-g -fprofile-arcs -ftest-coverage&quot;を使用してテストプログラムがコンパイルされ、次にテストプログラムが実行されます。次に、「gcov -b」を実行して、カバレッジレポートを生成します。カバレッジレポートは冗長で読みづらいため、gcovで生成されたレポートは、いくつかの簡単なスクリプトを使用して処理され、より人間に適した形式に変換されます。もちろん、このプロセス全体はスクリプトを使用して自動化されています。</target>
        </trans-unit>
        <trans-unit id="c4adfe3c542d88432092f783bc046835df0fe815" translate="yes" xml:space="preserve">
          <source>Branch coverage is more rigorous than statement coverage. Branch coverage measures the number of machine-code branch instructions that are evaluated at least once on both directions.</source>
          <target state="translated">分岐カバレッジは、ステートメントカバレッジよりも厳密です。分岐カバレッジは、両方の方向で少なくとも一度は評価されるマシンコードの分岐命令の数を測定します。</target>
        </trans-unit>
        <trans-unit id="a22b75ea309c645c4530e03f4541cb259f2d61c7" translate="yes" xml:space="preserve">
          <source>Branch coverage is more strict. With branch coverage, each test and each subblock within the statement is considered separately. In order to achieve 100% branch coverage in the example above, there must be at least three test cases:</source>
          <target state="translated">ブランチカバレッジはより厳密です。ブランチカバレッジでは、各テストとステートメント内の各サブブロックが別々に考慮されます。上記の例で100%のブランチカバレッジを達成するためには、少なくとも3つのテストケースが必要です。</target>
        </trans-unit>
        <trans-unit id="97c730065aaff2da27316c3a4fdb27f33630fd48" translate="yes" xml:space="preserve">
          <source>Break out the &quot;Presentor Notes&quot; from each slide into a separate table, for easier access from third-party applications and/or scripts.</source>
          <target state="translated">各スライドの「プレゼンターノート」を別の表に分割し、サードパーティ製のアプリケーションやスクリプトからのアクセスを容易にします。</target>
        </trans-unit>
        <trans-unit id="c53bff6ff25ebaccf14a4078fdb0261d0ccc01ee" translate="yes" xml:space="preserve">
          <source>Break out the GDBM driver into a separate file in anticipation to added new drivers.</source>
          <target state="translated">新しいドライバが追加されることを見越して、GDBMドライバを別ファイルに分割します。</target>
        </trans-unit>
        <trans-unit id="282c5dfb378bb6abed7a208812bdb6a15f29a876" translate="yes" xml:space="preserve">
          <source>Bring the OS/2 porting layer up-to-date.</source>
          <target state="translated">OS/2の移植層を最新の状態にする。</target>
        </trans-unit>
        <trans-unit id="82e575ff594a72cfcaccd19ccbf9ad35b704bb47" translate="yes" xml:space="preserve">
          <source>Bring the processing of ORDER BY into compliance with the SQL standard for case where a result alias and a table column name are in conflict. Correct behavior is to prefer the result alias. Older versions of SQLite incorrectly picked the table column. (See ticket #2822.)</source>
          <target state="translated">結果エイリアスとテーブルのカラム名が競合する場合のORDER BYの処理をSQL標準に準拠させる。正しい動作は、結果エイリアスを優先することです。古いバージョンのSQLiteでは、テーブルカラムが正しく選択されていませんでした。(チケット #2822 を参照してください)。</target>
        </trans-unit>
        <trans-unit id="4f04fd57f5bfebe96a862aebe73b135def3ab6df" translate="yes" xml:space="preserve">
          <source>Bug fix in the processing of the ORDER BY clause for GROUP BY queries</source>
          <target state="translated">GROUP BY クエリの ORDER BY 句の処理におけるバグ修正</target>
        </trans-unit>
        <trans-unit id="a725ca76655ec9003bb82b1a676029a85c0e7d07" translate="yes" xml:space="preserve">
          <source>Bug fix: &quot;SELECT count(*)&quot; was returning NULL for empty tables. Now it returns 0.</source>
          <target state="translated">空のテーブルに対してSELECT count(*)がNULLを返していたバグを修正しました。今では0を返すようになりました。</target>
        </trans-unit>
        <trans-unit id="9e476047ffbbf1baca852a2317f6d224dd2d875a" translate="yes" xml:space="preserve">
          <source>Bug fix: Add in a mutex that was omitted from the previous release.</source>
          <target state="translated">バグ修正。以前のリリースでは省略されていたミューテックスを追加しました。</target>
        </trans-unit>
        <trans-unit id="ab7e0eb1f7494f905f4da13b15772e1fb07bbe1e" translate="yes" xml:space="preserve">
          <source>Bug fix: An assertion was failing if &quot;PRAGMA full_column_names=ON;&quot; was set and you did a query that used a rowid, like this: &quot;SELECT rowid, * FROM ...&quot;.</source>
          <target state="translated">バグ修正。PRAGMA full_column_names=ON;が設定されていて、以下のように行IDを使用するクエリを実行した場合、アサーションが失敗していました。&quot;SELECT rowid,*FROM ....&quot;のような行IDを使用するクエリを実行した場合にアサーションが失敗しました。</target>
        </trans-unit>
        <trans-unit id="421117f09c1ef6c1c766b17bffc8c48c0d11cebc" translate="yes" xml:space="preserve">
          <source>Bug fix: An assertion was failing when a temporary table with an index had the same name as a permanent table created by a separate process.</source>
          <target state="translated">バグ修正。インデックスを持つ一時テーブルが、別のプロセスによって作成された永続テーブルと同じ名前を持つ場合、アサーションが失敗していました。</target>
        </trans-unit>
        <trans-unit id="0dceede8b9155b23f776e96cfdf9ce26f1c18497" translate="yes" xml:space="preserve">
          <source>Bug fix: An attempt to delete a single row of a table with a WHERE clause of &quot;ROWID=x&quot; when no such rowid exists was causing an error.</source>
          <target state="translated">バグ修正。ROWID=x &quot;のWHERE句を持つテーブルの単一行を削除しようとすると、そのような行IDが存在しない場合にエラーが発生していた。</target>
        </trans-unit>
        <trans-unit id="faaa0c6caea2e40fd936178cd8a1148168d7f164" translate="yes" xml:space="preserve">
          <source>Bug fix: Avoid a deadlock or crash if the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt;, &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt;, and the SQLite Encryption Extension are all used at once.</source>
          <target state="translated">バグ修正：&lt;a href=&quot;backup&quot;&gt;バックアップAPI&lt;/a&gt;、&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュ&lt;/a&gt;、およびSQLite暗号化拡張機能をすべて一度に使用する場合、デッドロックまたはクラッシュを回避します。</target>
        </trans-unit>
        <trans-unit id="c9851f7cc2ef1b47f1ede36a70787a28d8a73936" translate="yes" xml:space="preserve">
          <source>Bug fix: Avoid leaking memory on LIMIT and OFFSET clauses in deeply nested UNION ALL queries.</source>
          <target state="translated">バグ修正。深い入れ子になったUNION ALLクエリでLIMIT句とOFFSET句のメモリリークを回避しました。</target>
        </trans-unit>
        <trans-unit id="eb351871f180a85fd09c35dd04ce4b51eee599a0" translate="yes" xml:space="preserve">
          <source>Bug fix: Avoid segfault when using the &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt; inside of a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt; or &lt;a href=&quot;lang_createview&quot;&gt;view&lt;/a&gt; in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;.</source>
          <target state="translated">バグ修正：避けセグメンテーション違反使っ&lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE演算子&lt;/a&gt;の内部&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK制約&lt;/a&gt;または&lt;a href=&quot;lang_createview&quot;&gt;ビュー&lt;/a&gt;内&lt;a href=&quot;sharedcache&quot;&gt;の共有キャッシュモードを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a618ecebefb94412f1562472983ff94e3605eaab" translate="yes" xml:space="preserve">
          <source>Bug fix: Avoid various concurrency problems in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;.</source>
          <target state="translated">バグ修正：&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュモード&lt;/a&gt;でのさまざまな同時実行の問題を回避します。</target>
        </trans-unit>
        <trans-unit id="633b128d954ff36563e10076bd92bfc7d4d254bc" translate="yes" xml:space="preserve">
          <source>Bug fix: Bare identifiers in ORDER BY clauses bind more tightly to output column names, but identifiers in expressions bind more tightly to input column names. Identifiers in GROUP BY clauses always prefer output column names, however.</source>
          <target state="translated">バグ修正。ORDER BY句の中の素の識別子は出力カラム名とより強固にバインドされますが、式の中の識別子は入力カラム名とより強固にバインドされます。ただし、GROUP BY 句の識別子は常に出力カラム名を優先します。</target>
        </trans-unit>
        <trans-unit id="6a402a829e3faf4148ff927e5cc1ab64a56cfa4a" translate="yes" xml:space="preserve">
          <source>Bug fix: Column names in the result set were not being generated correctly for some (rather complex) VIEWs. This could cause a segfault under certain circumstances.</source>
          <target state="translated">バグ修正。一部の(やや複雑な)VIEWで、結果セットのカラム名が正しく生成されていませんでした。これは、特定の状況下でセグメンテーションフォールトを引き起こす可能性がありました。</target>
        </trans-unit>
        <trans-unit id="a6507d4034fca406ed1e6de7d9c69eb86666298e" translate="yes" xml:space="preserve">
          <source>Bug fix: Compute correct table names with the FULL_COLUMN_NAMES pragma is turned on.</source>
          <target state="translated">バグ修正。FULL_COLUMN_NAMESプラグマがオンになっているときに正しいテーブル名を計算するようにしました。</target>
        </trans-unit>
        <trans-unit id="d170d4831a6701524951017930d51215c0de3ceb" translate="yes" xml:space="preserve">
          <source>Bug fix: Compute the correct answer for queries that contain an IS NOT NULL term in the WHERE clause and also contain an OR term in the WHERE clause and are compiled with &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;. &lt;a href=&quot;http://www.sqlite.org/src/info/4c86b126f2&quot;&gt;Ticket [4c86b126f2]&lt;/a&gt;</source>
          <target state="translated">バグ修正：WHERE句にIS NOT NULL用語が含まれ、さらにWHERE句にOR用語が含まれ、&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4で&lt;/a&gt;コンパイルされたクエリの正解を計算します。&lt;a href=&quot;http://www.sqlite.org/src/info/4c86b126f2&quot;&gt;チケット[4c86b126f2]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e9fa36344bc0f04a7e81c8fa8066aa6b76c8c72" translate="yes" xml:space="preserve">
          <source>Bug fix: Correctly handle functions that appear in the WHERE clause of a join.</source>
          <target state="translated">バグ修正。ジョインのWHERE句に現れる関数を正しく処理するようになりました。</target>
        </trans-unit>
        <trans-unit id="b19417477425f028b30221d15629f2e13bb03e35" translate="yes" xml:space="preserve">
          <source>Bug fix: Correctly handle terms in the WHERE clause of a join that do not contain a comparison operator.</source>
          <target state="translated">バグ修正。比較演算子を含まないジョインのWHERE句の用語を正しく処理します。</target>
        </trans-unit>
        <trans-unit id="f1c7035443112823f2488a80b27044cd7dc930ca" translate="yes" xml:space="preserve">
          <source>Bug fix: Creating and dropping a table all within a single transaction was not working.</source>
          <target state="translated">バグ修正。1つのトランザクション内ですべてのテーブルを作成したりドロップしたりすることができない問題を修正しました。</target>
        </trans-unit>
        <trans-unit id="a65ee45495a64aa4ac7b00532e7dcdea10a45c93" translate="yes" xml:space="preserve">
          <source>Bug fix: DISTINCT now recognizes that a &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob&lt;/a&gt; and a blob of all 0x00 bytes are the same thing. &lt;a href=&quot;http://www.sqlite.org/src/info/fccbde530a&quot;&gt;Ticket [fccbde530a]&lt;/a&gt;</source>
          <target state="translated">バグ修正：DISTINCTは、すべての0x00バイトの&lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;ゼロブロブ&lt;/a&gt;とブロブが同じものであることを認識します。&lt;a href=&quot;http://www.sqlite.org/src/info/fccbde530a&quot;&gt;チケット[fccbde530a]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5e1c19457c6bcac61af13a07643a50b8996bac51" translate="yes" xml:space="preserve">
          <source>Bug fix: DROP TABLE followed by a CREATE TABLE with the same name all within a single transaction was causing a coredump.</source>
          <target state="translated">バグ修正。1つのトランザクション内でDROP TABLEに続いて同じ名前のCREATE TABLEを使用していた場合、コアダンプが発生していたのを修正しました。</target>
        </trans-unit>
        <trans-unit id="ba00de2c0632584e59e348681ca42b12b644bcbe" translate="yes" xml:space="preserve">
          <source>Bug fix: Database corruption can occur due to the optimization that was introduced in version 2.4.0 (check-in [410]). The problem should now be fixed. The use of versions 2.4.0 through 2.5.2 is not recommended.</source>
          <target state="translated">バグ修正を行いました。バージョン2.4.0で導入された最適化により、データベースの破損が発生することがあります(チェックイン[410])。この問題は現在修正されているはずです。バージョン2.4.0から2.5.2までの使用は推奨されません。</target>
        </trans-unit>
        <trans-unit id="bbe70e0c57d51f533365c58d207cdfb57683c5ef" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not allow a virtual table to cancel the ORDER BY clause unless all outer loops are guaranteed to return no more than one row result. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/ba82a4a41eac1&quot;&gt;ba82a4a41eac1&lt;/a&gt;.</source>
          <target state="translated">バグ修正：すべての外部ループが1行以下の結果を返すことが保証されていない限り、仮想テーブルがORDER BY句をキャンセルしないようにしてください。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/ba82a4a41eac1&quot;&gt;ba82a4a41eac1&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c3b898a085ef4e9fd7492842026dc724b1316d2" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not attempt the subquery flattening optimization on queries that lack a FROM clause. To do so causes a segfault.</source>
          <target state="translated">バグ修正。FROM句を持たないクエリで副問い合わせの平坦化最適化を試みないようにしました。これを行うとセグメンテーションフォールトが発生します。</target>
        </trans-unit>
        <trans-unit id="c7d832b024aa33f5c367340914044de719478c03" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not automatically remove the DISTINCT keyword from a SELECT that forms the right-hand side of an IN operator since it is necessary if the SELECT also contains a LIMIT. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/db87229497&quot;&gt;db87229497&lt;/a&gt;.</source>
          <target state="translated">バグ修正：SELECTにLIMITも含まれている場合に必要になるため、IN演算子の右側を形成するSELECTからDISTINCTキーワードを自動的に削除しないでください。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/db87229497&quot;&gt;db87229497&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4ec8b17071def3e40c2a66c3efc8f85f8fbeb60d" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not discard the DISTINCT as superfluous unless a subset of the result set is subject to a UNIQUE constraint &lt;em&gt;and&lt;/em&gt; it none of the columns in that subset can be NULL. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/385a5b56b9&quot;&gt;385a5b56b9&lt;/a&gt;.</source>
          <target state="translated">バグ修正：結果セットのサブセットがUNIQUE制約を受けない限り、DOは余分としてDISTINCTを破棄しない&lt;em&gt;と&lt;/em&gt;、それはそのサブセット内の列のどれもがNULLになることはできません。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/385a5b56b9&quot;&gt;385a5b56b9&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d122c8d80295b61ea78f7985674ee07265e9fe63" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not move WHERE clause terms inside OR expressions that are contained within an ON clause of a LEFT JOIN. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/f2369304e4&quot;&gt;f2369304e4&lt;/a&gt;</source>
          <target state="translated">バグ修正：LEFT JOINのON句に含まれるOR式内でWHERE句の用語を移動しないでください。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/f2369304e4&quot;&gt;f2369304e4&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2b3ae0e3595ba9969a417594021c4332e3d08633" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not optimize away an ORDER BY clause that has the same terms as a UNIQUE index unless those terms are also NOT NULL. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/2a5629202f&quot;&gt;2a5629202f&lt;/a&gt;.</source>
          <target state="translated">バグ修正：UNIQUEインデックスと同じ用語を持つORDER BY句を最適化して、それらの用語もNOT NULLでない限り、削除しないでください。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/2a5629202f&quot;&gt;2a5629202f&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6453e25436ce2c11dc1b6194ae2dc12f5ca5250" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not suppress the ORDER BY clause on a virtual table query if an IN constraint is used. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/f69b96e3076e&quot;&gt;f69b96e3076e&lt;/a&gt;.</source>
          <target state="translated">バグ修正：IN制約が使用されている場合、仮想テーブルクエリのORDER BY句を抑制しないでください。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/f69b96e3076e&quot;&gt;f69b96e3076e&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6f89fece6f5c7d025fca0afff2d5506eaef79c01" translate="yes" xml:space="preserve">
          <source>Bug fix: Ensure that &quot;ORDER BY random()&quot; clauses do not get optimized out. &lt;a href=&quot;http://www.sqlite.org/src/info/65bdeb9739&quot;&gt;Ticket [65bdeb9739]&lt;/a&gt;</source>
          <target state="translated">バグ修正：「ORDER BY random（）」句が最適化されないようにしました。&lt;a href=&quot;http://www.sqlite.org/src/info/65bdeb9739&quot;&gt;チケット[65bdeb9739]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad5b813b289d7e750591bfb845e4ba940a74acee" translate="yes" xml:space="preserve">
          <source>Bug fix: Ensure the cached KeyInfo objects (an internal abstraction not visible to the application) do not go stale when operating in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; and frequently closing and reopening some database connections while leaving other database connections on the same shared cache open continuously. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/e4a18565a36884b00edf&quot;&gt;e4a18565a36884b00edf&lt;/a&gt;.</source>
          <target state="translated">バグ修正：&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュモードで動作&lt;/a&gt;し、同じ共有キャッシュ上の他のデータベース接続を継続的に開いたまま、一部のデータベース接続を頻繁に閉じて再度開くときに、キャッシュされたKeyInfoオブジェクト（アプリケーションから見えない内部抽象化）が古くならないようにします。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/e4a18565a36884b00edf&quot;&gt;e4a18565a36884b00edf&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1c94982c68fc72ac2f6ac980a3323226e84f8466" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix a 32-bit overflow problem on CREATE INDEX for databases larger than 16GB.</source>
          <target state="translated">バグ修正。16GB以上のデータベースのCREATE INDEXで32ビットオーバーフローの問題を修正しました。</target>
        </trans-unit>
        <trans-unit id="b6580b5e5232c84824bf613c858acbb24fc5f483" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix a potential &lt;b&gt;database corruption bug&lt;/b&gt; in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; when one &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is closed while another is in the middle of a write transaction. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/e636a050b7&quot;&gt;e636a050b7&lt;/a&gt;</source>
          <target state="translated">バグ修正：ある&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;が書き込みトランザクションの最中にあるときに別のデータベース接続が閉じられた場合の、&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュモード&lt;/a&gt;での潜在的な&lt;b&gt;データベース破損のバグを修正&lt;/b&gt;しました。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/e636a050b7&quot;&gt;e636a050b7&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="28f644aa67590d02891787c2b2d9de10e303faef" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix an assertion failure that occurred when ROWID was a column in a SELECT statement on a view.</source>
          <target state="translated">バグ修正。ビューの SELECT 文で ROWID がカラムであった場合に発生していたアサーションの失敗を修正しました。</target>
        </trans-unit>
        <trans-unit id="6de63655427b8362357e0b9729e0309dea102b68" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix an uninitialized variable in the VDBE that would could an assert failure.</source>
          <target state="translated">バグ修正。VDBEで初期化されていない変数がアサートに失敗する可能性があったのを修正しました。</target>
        </trans-unit>
        <trans-unit id="15567e970418f92d21404d2b997ca55ed7870f2d" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix column default values expressions of the form &quot;DEFAULT(-(-9223372036854775808))&quot; so that they work correctly, initializing the column to a floating point value approximately equal to +9223372036854775808.0.</source>
          <target state="translated">バグ修正。DEFAULT(-(-9223372036854775808)&quot;形式の列のデフォルト値式を修正し、列を+9223372036854775808.0にほぼ等しい浮動小数点値に初期化して正しく動作するようにしました。</target>
        </trans-unit>
        <trans-unit id="b572be392d93fe8f8aa3c731cb70e9adb855b95a" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix the &lt;a href=&quot;lang_corefunc#char&quot;&gt;char()&lt;/a&gt; SQL function so that it returns an empty string rather than an &quot;out of memory&quot; error when called with zero arguments.</source>
          <target state="translated">バグ修正：引数なしで呼び出されたときに「メモリ不足」エラーではなく空の文字列を返すように、&lt;a href=&quot;lang_corefunc#char&quot;&gt;char（）&lt;/a&gt; SQL関数を修正しました。</target>
        </trans-unit>
        <trans-unit id="ec8ef57ae219363ebc2f9d36c425f7585ca571b1" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix the &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt; command so that it does not cancel pending queries. This repairs a problem introduced in 3.7.11.</source>
          <target state="translated">バグ修正：保留中のクエリがキャンセルされないように&lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt;コマンドを修正しました。これにより、3.7.11で導入された問題が修正されます。</target>
        </trans-unit>
        <trans-unit id="df416fd402ae79122987fd712ad3deeb5c8f5458" translate="yes" xml:space="preserve">
          <source>Bug fix: Generate correct column headers when a compound SELECT is used as a subquery.</source>
          <target state="translated">バグ修正。複合SELECTがサブクエリとして使用されている場合に正しいカラムヘッダを生成するようになりました。</target>
        </trans-unit>
        <trans-unit id="8607f97a039e79f9d7bbfb840d1dbfffbf0765f7" translate="yes" xml:space="preserve">
          <source>Bug fix: In the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; CSV import feature, do not end a field when an escaped double-quote occurs at the end of a CRLN line.</source>
          <target state="translated">バグ修正：&lt;a href=&quot;cli&quot;&gt;コマンドラインシェルの&lt;/a&gt; CSVインポート機能で、エスケープされた二重引用符がCRLN行の最後にある場合、フィールドを終了しないでください。</target>
        </trans-unit>
        <trans-unit id="d77f01bc12cfaa192da17d51a33bb2f997769b11" translate="yes" xml:space="preserve">
          <source>Bug fix: In the &lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt; tokenizer of &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;, treat all private code points as identifier symbols.</source>
          <target state="translated">バグ修正：&lt;a href=&quot;fts3#unicode61&quot;&gt;FTS4&lt;/a&gt;の&lt;a href=&quot;fts3#fts4&quot;&gt;unicode61トークナイザーで&lt;/a&gt;、すべてのプライベートコードポイントを識別子シンボルとして扱います。</target>
        </trans-unit>
        <trans-unit id="fc0e959c372e361cf7f33ef8b8f20d674104ba00" translate="yes" xml:space="preserve">
          <source>Bug fix: Issue an error message if the 16-bit reference counter on a view overflows due to an overly complex query.</source>
          <target state="translated">バグ修正。複雑すぎるクエリが原因でビュー上の16ビット参照カウンタがオーバーフローした場合、エラーメッセージを発行するようにしました。</target>
        </trans-unit>
        <trans-unit id="796cd2d86e5fad8940076a58510533a97b2c56bf" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure &quot;rowid&quot; columns are correctly resolved in joins between normal tables and WITHOUT ROWID tables. &lt;a href=&quot;http://www.sqlite.org/src/info/c34d0557f7&quot;&gt;Ticket [c34d0557f7]&lt;/a&gt;</source>
          <target state="translated">バグ修正：通常のテーブルとWITHOUT ROWIDテーブルの間の結合で、「rowid」列が正しく解決されていることを確認してください。&lt;a href=&quot;http://www.sqlite.org/src/info/c34d0557f7&quot;&gt;チケット[c34d0557f7]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="adf0baa27394f8041aaae283cf02f3ee1bfa8b41" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements appear in &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace()&lt;/a&gt; output.</source>
          <target state="translated">バグ修正：&lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace（）の&lt;/a&gt;出力に&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;ステートメントが表示されることを確認してください。</target>
        </trans-unit>
        <trans-unit id="2334a8bc658fa8a7b723fcf78436e06aa632b55a" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure an error is always reported when attempting to preform an operation that requires a &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; that is missing. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/0fc59f908b&quot;&gt;0fc59f908b&lt;/a&gt;</source>
          <target state="translated">バグ修正：欠落している&lt;a href=&quot;datatype3#collation&quot;&gt;照合シーケンス&lt;/a&gt;を必要とする操作を実行しようとすると、常にエラーが報告されるようにしてください。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/0fc59f908b&quot;&gt;0fc59f908b&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7b7a3c06c81b08010533a335b71314ea1246750e" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure that NULL results from OP_Column are fully and completely NULL and do not have the MEM_Ephem bit set. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/094d39a4c95ee4&quot;&gt;094d39a4c95ee4&lt;/a&gt;.</source>
          <target state="translated">バグ修正：OP_ColumnからのNULL結果が完全かつ完全にNULLであり、MEM_Ephemビットが設定されていないことを確認してください。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/094d39a4c95ee4&quot;&gt;094d39a4c95ee4&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2b6a649b8a7464f814f81388b6be52f54e12c25e" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure the journal file directory entry is committed to disk before writing the database file.</source>
          <target state="translated">バグ修正。データベースファイルを書き込む前に、ジャーナルファイルのディレクトリエントリがディスクにコミットされていることを確認してください。</target>
        </trans-unit>
        <trans-unit id="e185f43b49a3251f6e6597892c2f724efa586d32" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure the same temporary registers are not used in concurrent co-routines used to implement compound SELECT statements containing ORDER BY clauses, as such use can lead to incorrect answers. &lt;a href=&quot;http://www.sqlite.org/src/info/8c63ff0eca&quot;&gt;Ticket [8c63ff0eca]&lt;/a&gt;</source>
          <target state="translated">バグ修正：ORDER BY句を含む複合SELECTステートメントを実装するために使用される同時コルーチンで同じ一時レジスタが使用されていないことを確認してください。このような使用は誤った回答を引き起こす可能性があります。&lt;a href=&quot;http://www.sqlite.org/src/info/8c63ff0eca&quot;&gt;チケット[8c63ff0eca]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="51326d84193d9019e013ecb68f17ddd96b5b7cd8" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure the schema is up-to-date prior to running pragmas table_info, index_list, index_info, and foreign_key_list.</source>
          <target state="translated">バグ修正。pragmas table_info,index_list,index_info,foreign_key_listを実行する前に、スキーマが最新であることを確認してください。</target>
        </trans-unit>
        <trans-unit id="21876ec37a821c06e59ab2273c8a26e3a12144f2" translate="yes" xml:space="preserve">
          <source>Bug fix: Makes sure the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;authorizer&lt;/a&gt; callback gets a valid pointer to the string &quot;ROWID&quot; for the column-name parameter when doing an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; that changes the rowid. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/0eb70d77cb05bb2272&quot;&gt;0eb70d77cb05bb2272&lt;/a&gt;</source>
          <target state="translated">バグ修正：ROWID を変更する&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;を実行するときに、&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;Authorizer&lt;/a&gt;コールバックがcolumn-nameパラメーターの文字列「ROWID」への有効なポインターを確実に取得するようにしました。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/0eb70d77cb05bb2272&quot;&gt;0eb70d77cb05bb2272&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fa2f91d43fa97f1a5999350e4addb5cbb3edaca1" translate="yes" xml:space="preserve">
          <source>Bug fix: Only consider AS names from the result set as candidates for resolving identifiers in the WHERE clause if there are no other matches. In the ORDER BY clause, AS names take priority over any column names. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/2500cdb9be05&quot;&gt;2500cdb9be05&lt;/a&gt;</source>
          <target state="translated">バグ修正：他に一致するものがなければ、結果セットのAS名をWHERE句の識別子を解決する候補としてのみ検討します。ORDER BY句では、AS名が列名よりも優先されます。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/2500cdb9be05&quot;&gt;2500cdb9be05&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="141fde2a748db5215be1ecb9d4a778d891f1cb31" translate="yes" xml:space="preserve">
          <source>Bug fix: Passing in a NULL as the 3rd parameter to &lt;b&gt;sqlite_open()&lt;/b&gt; would sometimes cause a coredump.</source>
          <target state="translated">バグ修正：&lt;b&gt;sqlite_open（）の&lt;/b&gt; 3番目のパラメーターとしてNULLを渡すと、コアダンプが発生することがありました。</target>
        </trans-unit>
        <trans-unit id="2ab06e54b175379ab13bc77c3e0d9c481bc0c496" translate="yes" xml:space="preserve">
          <source>Bug fix: Recognize that any column in the right-hand table of a LEFT JOIN can be NULL even if the column has a NOT NULL constraint. Do not apply optimizations that assume the column is never NULL. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/6f2222d550f5b0ee7ed&quot;&gt;6f2222d550f5b0ee7ed&lt;/a&gt;.</source>
          <target state="translated">バグ修正：列にNOT NULL制約がある場合でも、LEFT JOINの右側のテーブルの列はNULLになる可能性があることを認識してください。列がNULLになることはないと想定して最適化を適用しないでください。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/6f2222d550f5b0ee7ed&quot;&gt;6f2222d550f5b0ee7ed&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="03f2e3e890c570259cec0056bb1e5602f41a8fe5" translate="yes" xml:space="preserve">
          <source>Bug fix: Repair a name-resolution error that can occur in sub-select statements contained within a TRIGGER. &lt;a href=&quot;http://www.sqlite.org/src/info/4ef7e3cfca&quot;&gt;Ticket [4ef7e3cfca]&lt;/a&gt;</source>
          <target state="translated">バグ修正：TRIGGERに含まれる副選択ステートメントで発生する可能性がある名前解決エラーを修復します。&lt;a href=&quot;http://www.sqlite.org/src/info/4ef7e3cfca&quot;&gt;チケット[4ef7e3cfca]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="179d04a255aba0b12c6e57bf1304a5f158b18e87" translate="yes" xml:space="preserve">
          <source>Bug fix: SQL functions created using the TCL interface honor the &quot;nullvalue&quot; setting.</source>
          <target state="translated">バグ修正。TCLインターフェースを使用して作成されたSQL関数は &quot;nullvalue &quot;設定を尊重します。</target>
        </trans-unit>
        <trans-unit id="0cd3dbb56d1124c2a6604fca7c97c5b4d246ad99" translate="yes" xml:space="preserve">
          <source>Bug fix: Sometimes arbitrary strings were passed to the callback function when the actual value of a column was NULL.</source>
          <target state="translated">バグ修正。カラムの実際の値がNULLの場合に任意の文字列がコールバック関数に渡されることがありました。</target>
        </trans-unit>
        <trans-unit id="e6069685c787f1f2374ad59005630cac33f83a18" translate="yes" xml:space="preserve">
          <source>Bug fix: The %c format in sqlite3_mprintf() is able to handle precisions greater than 70.</source>
          <target state="translated">バグ修正。sqlite3_mprintf()の %c 形式は、70 より大きいプリシティを扱えるようになりました。</target>
        </trans-unit>
        <trans-unit id="8545ae69eab7462c35ca27db0ca5feb48e882da0" translate="yes" xml:space="preserve">
          <source>Bug fix: The &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; gives an exit code of 0 when terminated using the &quot;.quit&quot; command.</source>
          <target state="translated">バグ修正：&lt;a href=&quot;cli&quot;&gt;コマンドラインシェル&lt;/a&gt;は、「。quit」コマンドを使用して終了すると、終了コード0を示します。</target>
        </trans-unit>
        <trans-unit id="3c4dbfc44f9dd05912067f94c3eb5f1e8372f6d5" translate="yes" xml:space="preserve">
          <source>Bug fix: There was an incorrect assert() in pager.c. The real code was all correct (as far as is known) so everything should work OK if you compile with -DNDEBUG=1. When asserts are not disabled, there could be a fault.</source>
          <target state="translated">バグ修正。実際のコードは (知られている限りでは)すべて正しいので、-DNDEBUG=1 でコンパイルすれば、すべて正常に動作するはずです。assert が無効化されていない場合は、フォールトが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="ad7bd89e49a8af821827d6b028e2e799f12e2e1e" translate="yes" xml:space="preserve">
          <source>Bug fix: Updates to tables containing an INTEGER PRIMARY KEY and an index could fail.</source>
          <target state="translated">バグ修正。INTEGER PRIMARY KEY とインデックスを含むテーブルへの更新に失敗する可能性がありました。</target>
        </trans-unit>
        <trans-unit id="6b758d1f8710d23a2038913ec37dece3bec7abf6" translate="yes" xml:space="preserve">
          <source>Bug fix: Virtual tables now handle IS NOT NULL constraints correctly.</source>
          <target state="translated">バグ修正。仮想テーブルがIS NOT NULL制約を正しく扱うようになりました。</target>
        </trans-unit>
        <trans-unit id="332e05b490c4cb7238853c006e2e916e2a9e4dbc" translate="yes" xml:space="preserve">
          <source>Bug fix: When a &lt;a href=&quot;lang_select#compound&quot;&gt;compound query&lt;/a&gt; that uses an ORDER BY clause with a &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, make sure that the sorting occurs according to the specified collation and that the comparisons associate with the compound query use the native collation. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/6709574d2a8d8&quot;&gt;6709574d2a8d8&lt;/a&gt;.</source>
          <target state="translated">バグ修正：&lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE演算子&lt;/a&gt;でORDER BY句を使用する&lt;a href=&quot;lang_select#compound&quot;&gt;複合クエリの&lt;/a&gt;場合、指定した照合に従ってソートが行われ、複合クエリに関連付けられている比較でネイティブ照合が使用されていることを確認してください。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/6709574d2a8d8&quot;&gt;6709574d2a8d8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2cfdb97a345b3ce143f2abc5fd945ed42741b35a" translate="yes" xml:space="preserve">
          <source>Bug fix: allow a VACUUM (without segfaulting) on an empty database after setting the EMPTY_RESULT_CALLBACKS pragma.</source>
          <target state="translated">EMPTY_RESULT_CALLBACKS pragmaを設定した後、空のデータベースでVACUUMを許可するようにしました(セグメンテーションフォールトなし)。</target>
        </trans-unit>
        <trans-unit id="1e76d1db13ab52fcac380bd0ae95fbf87bf5df38" translate="yes" xml:space="preserve">
          <source>Bug fix: an assertion was failing if the disk holding the database file became full or stopped accepting writes for some other reason. New tests were added to detect similar problems in the future.</source>
          <target state="translated">バグ修正:データベースファイルを保持しているディスクが一杯になったり、何らかの理由で書き込みを受け付けなくなったりした場合にアサーションが失敗していたのを修正しました。将来的に同様の問題を検出するための新しいテストが追加されました。</target>
        </trans-unit>
        <trans-unit id="f481a7837f1627a5d4384fe68dbbc8fae1d3d0ad" translate="yes" xml:space="preserve">
          <source>Bug fix: an obscure and relatively harmless bug was causing one of the tests to fail when gcc optimizations are turned on. This release fixes the problem.</source>
          <target state="translated">バグ修正:gcc の最適化を有効にしているときにテストが失敗する原因となっていたバグがありました。このリリースはこの問題を修正しました。</target>
        </trans-unit>
        <trans-unit id="1817a2a23947bcba57e850537b31bddd01fd4808" translate="yes" xml:space="preserve">
          <source>Bug fix: correctly evaluate a view of a view without segfaulting.</source>
          <target state="translated">バグ修正:セグフェルトを行わずにビューのビューを正しく評価するようにしました。</target>
        </trans-unit>
        <trans-unit id="0bbfec3e6b5b062aa0e10ea3e3ec25c68f3b48e5" translate="yes" xml:space="preserve">
          <source>Bug fix: do not invoke the authorizer when reparsing the schema after a schema change.</source>
          <target state="translated">スキーマ変更後にスキーマを修復する際にオーサライザーを呼び出さないようにした。</target>
        </trans-unit>
        <trans-unit id="ff59932ad9e1623e668bc5144d9efca6daa5ff06" translate="yes" xml:space="preserve">
          <source>Bug fix: if an integer value will not fit in a 32-bit int, store it in a double instead.</source>
          <target state="translated">バグ修正:整数値が32ビットのintに収まらない場合、代わりにdoubleに格納するようにしました。</target>
        </trans-unit>
        <trans-unit id="09579acd43ac94145eab3e50236de9b1df09778c" translate="yes" xml:space="preserve">
          <source>Bug fix: incorrect VDBE code was being generated for the following circumstance: a query on an indexed table containing a WHERE clause with an IN operator that had a subquery on its right-hand side.</source>
          <target state="translated">バグ修正:以下の状況で不正なVDBEコードが生成されていました:右側に副問い合わせを持つIN演算子を持つWHERE句を含むインデックス付きテーブルの問い合わせ。</target>
        </trans-unit>
        <trans-unit id="e8c1bb430eed1f84c250a2cbb94468adfcff9f43" translate="yes" xml:space="preserve">
          <source>Bug fix: prevent database corruption if you dropped a trigger that had the same name as a table.</source>
          <target state="translated">バグ修正:テーブルと同じ名前のトリガーをドロップした場合のデータベースの破損を防止しました。</target>
        </trans-unit>
        <trans-unit id="77f87bfdf4072c6e0867b3768c5f7d3818056770" translate="yes" xml:space="preserve">
          <source>Bug fix: repair a long-standing problem that could cause incorrect query results in a 3-way or larger join that compared INTEGER fields against TEXT fields in two or more places. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/fc7bd6358f&quot;&gt;fc7bd6358f&lt;/a&gt;</source>
          <target state="translated">バグ修正：3ウェイ以上の結合でINTEGERフィールドと2か所以上のTEXTフィールドを比較する不正なクエリ結果の原因となる長年の問題を修正しました。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/fc7bd6358f&quot;&gt;fc7bd6358f&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c0e4c435db089ba66d14c6f426f1ca923c3e24a" translate="yes" xml:space="preserve">
          <source>Bug fix: the &lt;b&gt;sqlite_busy_timeout()&lt;/b&gt; function was delaying 1000 times too long before failing.</source>
          <target state="translated">バグ修正：&lt;b&gt;sqlite_busy_timeout（）&lt;/b&gt;関数が失敗するまでに1000倍の遅延が発生していました。</target>
        </trans-unit>
        <trans-unit id="1de9526f456e5138884e0e01586b12298617b6e1" translate="yes" xml:space="preserve">
          <source>Bug fixes</source>
          <target state="translated">バグ修正</target>
        </trans-unit>
        <trans-unit id="9af1a1169b55646981d441c46e6271c5d4e76c17" translate="yes" xml:space="preserve">
          <source>Bug fixes and performance enhancements in the query optimizer</source>
          <target state="translated">クエリオプティマイザのバグ修正とパフォーマンスの向上</target>
        </trans-unit>
        <trans-unit id="c92ef11c871ae07b2d656ca889c918e8054c9d2e" translate="yes" xml:space="preserve">
          <source>Bug fixes and speed improvements. Improved test coverage.</source>
          <target state="translated">バグ修正と速度の改善。テストカバレッジの改善。</target>
        </trans-unit>
        <trans-unit id="fa58e385720020fa0c169f308e1843b2e873b0c1" translate="yes" xml:space="preserve">
          <source>Bug fixes in fts1 and fts2 modules.</source>
          <target state="translated">fts1とfts2モジュールのバグ修正。</target>
        </trans-unit>
        <trans-unit id="7084081296e3ad1cf8f7221181be2c129e0aee5c" translate="yes" xml:space="preserve">
          <source>Bug fixes in the TCL interface identified by Oleg Oleinick.</source>
          <target state="translated">Oleg Oleinickによって特定されたTCLインターフェースのバグ修正。</target>
        </trans-unit>
        <trans-unit id="e8aa6f5aee0afe8811b93445b5db21495039c63d" translate="yes" xml:space="preserve">
          <source>Bug fixes in the experimental date/time functions.</source>
          <target state="translated">実験的な日時関数のバグ修正。</target>
        </trans-unit>
        <trans-unit id="b9c7777bb06388cb9dbb8f975e3fd09b2142a8c1" translate="yes" xml:space="preserve">
          <source>Bug fixes to date/time functions.</source>
          <target state="translated">日付・時刻機能のバグ修正。</target>
        </trans-unit>
        <trans-unit id="081661d86510940c54a252302be8551477973958" translate="yes" xml:space="preserve">
          <source>Bug fixes too numerous to mention (see the change log).</source>
          <target state="translated">バグ修正が多すぎて言及できません(変更ログを参照)。</target>
        </trans-unit>
        <trans-unit id="54d964bde3b45008273493e091d5fc828d1a6056" translate="yes" xml:space="preserve">
          <source>Bug fixes:</source>
          <target state="translated">バグ修正。</target>
        </trans-unit>
        <trans-unit id="a6d45e893c4329669744195bd786da10bdc76da3" translate="yes" xml:space="preserve">
          <source>Bug fixes: Correctly handle nested correlated subqueries used with indices in a WHERE clause.</source>
          <target state="translated">バグ修正。WHERE句のインデックスで使用される入れ子になった相関副問い合わせを正しく処理するようになりました。</target>
        </trans-unit>
        <trans-unit id="24673ce72a32d2ab5eb79f34d4f1d1eb683d14be" translate="yes" xml:space="preserve">
          <source>Bug fixes: Multiple problems in the legacy query optimizer were fixed by the move to &lt;a href=&quot;queryplanner-ng&quot;&gt;NGQP&lt;/a&gt;.</source>
          <target state="translated">バグ修正：&lt;a href=&quot;queryplanner-ng&quot;&gt;NGQP&lt;/a&gt;への移行により、従来のクエリオプティマイザーの複数の問題が修正されました。</target>
        </trans-unit>
        <trans-unit id="58535f3c8aa73d70d81e761cda2cb8486c811f2f" translate="yes" xml:space="preserve">
          <source>Bugs are far less likely in SQLite than in custom-written file I/O code.</source>
          <target state="translated">SQLiteのバグは、カスタマイズされたファイルのI/Oコードよりもはるかに少ない可能性があります。</target>
        </trans-unit>
        <trans-unit id="5a61f35b0599148f4a6890e52dcef0661cb0913e" translate="yes" xml:space="preserve">
          <source>Bugs in the FTS3/4 virtual table. (The &quot;integrity-check&quot; command was original conceived as part of the test suite for FTS3/4.)</source>
          <target state="translated">FTS3/4仮想テーブルのバグ。(Integrity-checkコマンドはFTS3/4のテストスイートの一部として考案されたものです)</target>
        </trans-unit>
        <trans-unit id="8f202605eb190dddba6e0719369e8fd2b96ba2d8" translate="yes" xml:space="preserve">
          <source>Build the &quot;fts5.c&quot; target. Which also creates fts5.h.</source>
          <target state="translated">fts5.c &quot;ターゲットをビルドします。これは fts5.h も作成します。</target>
        </trans-unit>
        <trans-unit id="00497bbc4dcbda4f80e1ffef6721bc5a34a86a97" translate="yes" xml:space="preserve">
          <source>Building SQLite directly from individual source code files is certainly possible, but it is not recommended. For some specialized applications, it might be necessary to modify the build process in ways that cannot be done using just the prebuilt amalgamation source file downloaded from the website. For those situations, it is recommended that a customized amalgamation be built (as described &lt;a href=&quot;howtocompile#amal&quot;&gt;below&lt;/a&gt;) and used. In other words, even if a project requires building SQLite beginning with individual source files, it is still recommended that an amalgamation source file be used as an intermediate step.</source>
          <target state="translated">個別のソースコードファイルから直接SQLiteを構築することは確かに可能ですが、お勧めできません。一部の特殊なアプリケーションでは、Webサイトからダウンロードされたビルド済みの統合ソースファイルだけでは実行できない方法でビルドプロセスを変更する必要がある場合があります。これらの状況では、カスタマイズされた融合を構築し（&lt;a href=&quot;howtocompile#amal&quot;&gt;以下で&lt;/a&gt;説明）、使用することをお勧めします。言い換えれば、プロジェクトが個々のソースファイルからSQLiteをビルドする必要がある場合でも、中間ステップとして融合ソースファイルを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="0a71cb495d76b612c809648873b36b593c7393c1" translate="yes" xml:space="preserve">
          <source>Building a DLL</source>
          <target state="translated">DLLの構築</target>
        </trans-unit>
        <trans-unit id="280b6f6ad70e8ba6e9e400ea3d8e0a9edc8b3677" translate="yes" xml:space="preserve">
          <source>Building shared libraries for Mac OS X and Windows is not nearly so simple, unfortunately. For those platforms it is best to use the configure script and makefile that is included with the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;TEA tarball&lt;/a&gt;.</source>
          <target state="translated">Mac OS XとWindows用の共有ライブラリの構築は、残念ながらそれほど単純ではありません。これらのプラットフォームでは、&lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;TEA tarballに&lt;/a&gt;含まれているconfigureスクリプトとmakefileを使用するのが最善です。</target>
        </trans-unit>
        <trans-unit id="22bc37f7023e946a78cac7bbfe5894c0db4b3f89" translate="yes" xml:space="preserve">
          <source>Building the amalgamation</source>
          <target state="translated">アマルガムの構築</target>
        </trans-unit>
        <trans-unit id="baa9f6c7f9720c4460c1521a23a159ddd34e81a1" translate="yes" xml:space="preserve">
          <source>Built-In Scalar SQL Functions</source>
          <target state="translated">組み込みのスカラーSQL関数</target>
        </trans-unit>
        <trans-unit id="c2d49de15987506a3eaf80acc91b361f30b458bf" translate="yes" xml:space="preserve">
          <source>Built-in &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; that return the results of &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements for use within ordinary SQL queries.</source>
          <target state="translated">通常のSQLクエリ内で使用するために&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;ステートメントの結果を返す組み込みの&lt;a href=&quot;vtab#tabfunc2&quot;&gt;テーブル値関数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="78cbf7ad58abfcde67b880290a3fdb26ae265ea9" translate="yes" xml:space="preserve">
          <source>Built-in Aggregate Functions</source>
          <target state="translated">集計機能を内蔵しています。</target>
        </trans-unit>
        <trans-unit id="fb80809ef25b3a813f862af2f128324a798b2745" translate="yes" xml:space="preserve">
          <source>Built-in functions may be overloaded by new application-defined functions.</source>
          <target state="translated">内蔵関数は、新しいアプリケーション定義関数によってオーバーロードされることがあります。</target>
        </trans-unit>
        <trans-unit id="224b755bc066a07e060bb8deb0ae84ff72d8c6e6" translate="yes" xml:space="preserve">
          <source>Built-in window functions honor any PARTITION BY clause in the same way as aggregate window functions - each selected row is assigned to a partition and each partition is processed separately. The ways in which any ORDER BY clause affects each built-in window function is described below. Some of the window functions (rank(), dense_rank(), percent_rank() and ntile()) use the concept of &quot;peer groups&quot; (rows within the same partition that have the same values for all ORDER BY expressions). In these cases, it does not matter whether the frame-spec specifies ROWS, GROUPS, or RANGE. For the purposes of built-in window function processing, rows with the same values for all ORDER BY expressions are considered peers regardless of the frame type.</source>
          <target state="translated">組込みウィンドウ関数は、集約ウィンドウ関数と同じように、任意のPARTITION BY句を尊重します-選択された行はそれぞれパーティションに割り当てられ、各パーティションは別々に処理されます。ORDER BY句が各組み込みウィンドウ関数にどのような影響を与えるかについては、以下に説明します。いくつかのウィンドウ関数(rank()、dense_rank()、percent_rank()、ntile())では、&quot;ピアグループ &quot;の概念を使用しています(同じパーティション内の行で、すべてのORDER BY式で同じ値を持つ行)。これらの場合、フレーム仕様が ROWS、GROUPS、RANGE のいずれを指定していても問題ではありません。ビルトインウィンドウ関数処理の目的では、すべてのORDER BY式に対して同じ値を持つ行は、フレームタイプに関係なくピアとみなされます。</target>
        </trans-unit>
        <trans-unit id="5a25ccfc2ab6b23f400787b0cd05318c6367c6b9" translate="yes" xml:space="preserve">
          <source>Builtin window functions</source>
          <target state="translated">ビルトインウィンドウ機能</target>
        </trans-unit>
        <trans-unit id="3fddbac5f0f5f0b32fe70d555580cce7a2b2229b" translate="yes" xml:space="preserve">
          <source>Bundle sqlite_encode_binary() and sqlite_decode_binary() with the library.</source>
          <target state="translated">sqlite_encode_binary()とsqlite_decode_binary()をライブラリと一緒にバンドルしてください。</target>
        </trans-unit>
        <trans-unit id="f637663e6355164a78b8db75eb1fc4755242d81d" translate="yes" xml:space="preserve">
          <source>Bury the dead.</source>
          <target state="translated">死者を埋めろ</target>
        </trans-unit>
        <trans-unit id="c86307059b070b415312a3a5cc51007f6e153433" translate="yes" xml:space="preserve">
          <source>But SQLite does use the declared type of a column as a hint that you prefer values in that format. So, for example, if a column is of type INTEGER and you try to insert a string into that column, SQLite will attempt to convert the string into an integer. If it can, it inserts the integer instead. If not, it inserts the string. This feature is called &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt;.</source>
          <target state="translated">しかし、SQLiteは、宣言された列の型を、その形式の値を好むというヒントとして使用します。したがって、たとえば、列のタイプがINTEGERで、その列に文字列を挿入しようとすると、SQLiteは文字列を整数に変換しようとします。可能であれば、代わりに整数を挿入します。そうでない場合は、文字列を挿入します。この機能は、&lt;a href=&quot;datatype3#affinity&quot;&gt;タイプアフィニティ&lt;/a&gt;と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="23199e0b44d24bd1ee4c96e22ea9bb3d1c2f67f4" translate="yes" xml:space="preserve">
          <source>But SQLite is built into the application. So if the data is on a separate device from the application, it is required that the higher bandwidth engine-to-disk link be across the network. This works, but it is suboptimal. Hence, it is usually better to select a client/server database engine when the data is on a separate device from the application.</source>
          <target state="translated">しかし、SQLiteはアプリケーションに組み込まれています。そのため、データがアプリケーションとは別のデバイスにある場合は、より高い帯域幅のエンジン対ディスクリンクがネットワークを越えていることが要求されます。これはうまくいきますが、最適ではありません。したがって、データがアプリケーションとは別のデバイス上にある場合は、クライアント/サーバ・データベース・エンジンを選択した方が良いのが一般的です。</target>
        </trans-unit>
        <trans-unit id="09ce2891d1601356f9a03f1d38be77a08462a437" translate="yes" xml:space="preserve">
          <source>But an SQLite database is not limited to a simple key/value structure like a pile-of-files database. An SQLite database can have dozens or hundreds or thousands of different tables, with dozens or hundreds or thousands of fields per table, each with different datatypes and constraints and particular meanings, all cross-referencing each other, appropriately and automatically indexed for rapid retrieval, and all stored efficiently and compactly in a single disk file. And all of this structure is succinctly documented for humans by the SQL schema.</source>
          <target state="translated">しかし、SQLiteデータベースは、pile-of-filesデータベースのような単純なキー/値構造に限定されません。SQLiteデータベースは、テーブルごとに数十、数百、数千の異なるテーブル、数十、数百、数千のフィールドを持ち、それぞれが異なるデータ型や制約、特定の意味を持ち、すべて相互参照し、迅速な検索のために適切かつ自動的にインデックス化され、すべてが単一のディスクファイルに効率的かつコンパクトに格納されています。そして、この構造はすべてSQLスキーマによって簡潔に文書化されています。</target>
        </trans-unit>
        <trans-unit id="d929882a8a439200f669cf52bfce1643d73dfffb" translate="yes" xml:space="preserve">
          <source>But as with any query planner change, upgrading to the NGQP does carry a small risk of introducing performance regressions. The problem here is not that the NGQP is incorrect or buggy or inferior to the legacy query planner. Given reliable information about the selectivity of indexes, the NGQP should always pick a plan that is as good or better than before. The problem is that some applications may be using low-quality and low-selectivity indexes without having run &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;. The older query planners look at many fewer possible implementations for each query and so they may have stumbled over a good plan by stupid luck. The NGQP, on the other hand, looks at many more query plan possibilities, and it may choose a different query plan that works better in theory, assuming good indexes, but which gives a performance regression in practice, because of the shape of the data.</source>
          <target state="translated">ただし、クエリプランナーの変更と同様に、NGQPへのアップグレードには、パフォーマンスの低下を招く小さなリスクがあります。ここでの問題は、NGQPが正しくない、バグがある、またはレガシークエリプランナーよりも劣ることではありません。インデックスの選択性に関する信頼できる情報が与えられると、NGQPは常に以前と同じかそれ以上の計画を選択する必要があります。問題は、一部のアプリケーションが&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;を実行せずに低品質で選択性の低いインデックスを使用している可能性があることです。。古いクエリプランナーは、クエリごとに考えられる実装の数がはるかに少ないため、愚かな運によって良いプランに出くわした可能性があります。一方、NGQPはより多くのクエリプランの可能性を検討し、適切なインデックスを想定して理論的にはより適切に機能する別のクエリプランを選択しますが、実際にはデータの形状によりパフォーマンスが低下します。 。</target>
        </trans-unit>
        <trans-unit id="bcf6c11e8e6d47ec28df41f7ffce035dc6edbeac" translate="yes" xml:space="preserve">
          <source>But because the &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement does not change the database file directly, sqlite3_stmt_readonly() would still return true.</source>
          <target state="translated">しかし、&lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントはデータベースファイルを直接変更しないため、sqlite3_stmt_readonly（）はtrueを返します。</target>
        </trans-unit>
        <trans-unit id="452ab026c840b3ee756da71d85f2e4c8edc72d0b" translate="yes" xml:space="preserve">
          <source>But because the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement does not change the database file directly, sqlite3_stmt_readonly() would still return true.</source>
          <target state="translated">しかし、&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントはデータベースファイルを直接変更しないため、sqlite3_stmt_readonly（）はtrueを返します。</target>
        </trans-unit>
        <trans-unit id="ff4e39f9bba0236549d62b5ae4b68b2eb0a104f9" translate="yes" xml:space="preserve">
          <source>But database engines like SQLite are usually not this way. The SQL scripts that are passed into SQLite come from the (trusted) application itself, not from an attacker. Sometimes applications contain bugs by which an external attacker can trick the application into sending SQL of the attackers design into the database engine. This is a separate bug in the application called an &lt;a href=&quot;https://en.wikipedia.org/wiki/SQL_injection&quot;&gt;SQL Injection vulnerability&lt;/a&gt;. Since SQL text is executable code, an SQL Injection vulnerability is actually a special case of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Arbitrary_code_execution&quot;&gt;Remote Code Execution (RCE) vulnerability&lt;/a&gt;. An SQL Injection is perhaps not quite as bad as other kinds of RCEs because, while SQL is a powerful language, it is not as convenient for crafting an exploit as Python or shell script or raw machine code. Nevertheless, an SQL Injection is a serious problem.</source>
          <target state="translated">しかし、SQLiteのようなデータベースエンジンは通常この方法ではありません。SQLiteに渡されるSQLスクリプトは、攻撃者からではなく、（信頼できる）アプリケーション自体から取得されます。アプリケーションには、外部の攻撃者がアプリケーションをだまして、攻撃者の設計のSQLをデータベースエンジンに送信させるバグが含まれている場合があります。これは、&lt;a href=&quot;https://en.wikipedia.org/wiki/SQL_injection&quot;&gt;SQLインジェクションの脆弱性&lt;/a&gt;と呼ばれるアプリケーションの別のバグです。SQLテキストは実行可能コードであるため、SQLインジェクションの脆弱性は、実際には&lt;a href=&quot;https://en.wikipedia.org/wiki/Arbitrary_code_execution&quot;&gt;リモートコード実行（RCE）の脆弱性の&lt;/a&gt;特殊なケースです。。SQLインジェクションは、おそらく他の種類のRCEほど悪くはありません。なぜなら、SQLは強力な言語ですが、Python、シェルスクリプト、または生のマシンコードほどエクスプロイトを作成するのに便利ではないからです。それにもかかわらず、SQLインジェクションは深刻な問題です。</target>
        </trans-unit>
        <trans-unit id="f3654dae88afc03c2b5b644ec401c70beb10ac13" translate="yes" xml:space="preserve">
          <source>But does this really save time? The number of steps in the &lt;a href=&quot;#fig16&quot;&gt;original indexless sort&lt;/a&gt; is proportional to NlogN since that is how much time it takes to sort N rows. But when we use Idx1 as shown here, we have to do N rowid lookups which take logN time each, so the total time of NlogN is the same!</source>
          <target state="translated">しかし、これは本当に時間を節約するのでしょうか？&lt;a href=&quot;#fig16&quot;&gt;元のインデックスレスソート&lt;/a&gt;のステップ数はNlogNに比例します。これは、N行をソートするのにかかる時間だからです。ただし、ここに示すようにIdx1を使用する場合、それぞれlogN時間を必要とするN個のROWIDルックアップを実行する必要があるため、NlogNの合計時間は同じです。</target>
        </trans-unit>
        <trans-unit id="d6fc31d48c09d06ad4b37abcbcf5f0dce6a8ec76" translate="yes" xml:space="preserve">
          <source>But from the point of view of the VDBE, a CREATE works pretty much like an INSERT and a DROP works like a DELETE. When the SQLite library opens to an existing database, the first thing it does is a SELECT to read the &quot;sql&quot; columns from all entries of the sqlite_master table. The &quot;sql&quot; column contains the complete SQL text of the CREATE statement that originally generated the index or table. This text is fed back into the SQLite parser and used to reconstruct the internal data structures describing the index or table.</source>
          <target state="translated">しかし、VDBEの観点から見ると、CREATEはINSERTのように動作し、DROPはDELETEのように動作します。SQLiteライブラリが既存のデータベースを開くとき、最初に行うことはSELECTで、sqlite_masterテーブルのすべてのエントリから &quot;sql &quot;カラムを読み込むことです。sql &quot;カラムには、元々インデックスやテーブルを生成したCREATE文の完全なSQLテキストが含まれています。このテキストはSQLiteパーサにフィードバックされ、インデックスやテーブルを記述する内部データ構造を再構築するために使用されます。</target>
        </trans-unit>
        <trans-unit id="48911d596580c34107a4030f62db573e6c27c85f" translate="yes" xml:space="preserve">
          <source>But if SQLite wants to access a page of the database file and memory mapped I/O is enabled, it first calls the xFetch() method. The xFetch() method asks the operating system to return a pointer to the requested page, if possible. If the requested page has been or can be mapped into the application address space, then xFetch returns a pointer to that page for SQLite to use without having to copy anything. Skipping the copy step is what makes memory mapped I/O faster.</source>
          <target state="translated">しかし、SQLite がデータベースファイルのページにアクセスしたい場合で、メモリマップされた I/O が有効になっている場合は、まず xFetch()メソッドを呼び出します。xFetch()メソッドは、可能であれば要求されたページへのポインタを返すようにオペレーティングシステムに要求します。要求されたページがアプリケーションのアドレス空間にマップされている、あるいはマップできる場合、xFetch はそのページへのポインタを返し、SQLite が何もコピーせずに使用できるようにします。コピーステップをスキップすることで、メモリマップされたI/Oがより高速になります。</target>
        </trans-unit>
        <trans-unit id="29180962652da325c9c8e705d40a3befafb60fff" translate="yes" xml:space="preserve">
          <source>But if a hacker is able to run arbitrary SQL, he might run a slightly different query, like this:</source>
          <target state="translated">しかし、ハッカーが任意のSQLを実行できるようになれば、次のような少し変わったクエリを実行するかもしれません。</target>
        </trans-unit>
        <trans-unit id="42f14da1dea8e44296cffda380cd3db71f9a44b1" translate="yes" xml:space="preserve">
          <source>But if an attacker can already run arbitrary SQL, they do not need a bug to cause a denial of service. There are plenty of perfectly legal and valid SQL statements that will consume unlimited CPU, memory, and disk I/O in order to create a denial-of-service without requiring help from bugs.</source>
          <target state="translated">しかし、攻撃者がすでに任意のSQLを実行できるのであれば、サービス拒否を引き起こすためのバグは必要ありません。バグの助けを必要とせずにサービス拒否を引き起こすために、CPU、メモリ、ディスクI/Oを無制限に消費する、完全に合法で有効なSQL文はたくさんあります。</target>
        </trans-unit>
        <trans-unit id="560c7f07ebe8e7827f02303fd33e3696ffc6d5d9" translate="yes" xml:space="preserve">
          <source>But if the</source>
          <target state="translated">しかし、もし</target>
        </trans-unit>
        <trans-unit id="a0cdbfa12f5d3945de1878cd75d88dc29371bd31" translate="yes" xml:space="preserve">
          <source>But if the EMPTY_RESULT_CALLBACKS pragma is ON, then the following is returned:</source>
          <target state="translated">しかし、EMPTY_RESULT_CALLBACKS pragmaがONの場合は、以下のように返されます。</target>
        </trans-unit>
        <trans-unit id="3b2f2e220bf3a85ffdbd93e68cd80fcba741ecfe" translate="yes" xml:space="preserve">
          <source>But if the case_sensitive_like pragma is enabled as follows:</source>
          <target state="translated">しかし、以下のようにcase_sensitive_like pragmaが有効になっている場合は。</target>
        </trans-unit>
        <trans-unit id="917ffdb9308404a9f9ecbb2338ae37ba101af829" translate="yes" xml:space="preserve">
          <source>But if the i-th parameter is NULL we will get:</source>
          <target state="translated">しかし、i 番目のパラメータが NULL の場合は、このようになります。</target>
        </trans-unit>
        <trans-unit id="418b21f56edf736ac615f67f52f5ff8cd5de8694" translate="yes" xml:space="preserve">
          <source>But if we change the ORDER BY clause to add the &quot;DESC&quot; modifier, that will cause lower levels in the organization (with larger &quot;level&quot; values) to be processed first by the recursive-select, resulting in a depth-first search:</source>
          <target state="translated">しかし、ORDER BY句を変更して &quot;DESC &quot;修飾子を追加すると、組織内の低レベル(より大きな &quot;レベル &quot;値を持つ)が再帰的選択によって最初に処理され、結果として深さ優先の検索になります。</target>
        </trans-unit>
        <trans-unit id="b73aaf5e4e2de9f2adc91308c0011207fcb7df2b" translate="yes" xml:space="preserve">
          <source>But in a coverage measuring build, the &lt;code&gt;testcase()&lt;/code&gt; macro generates code that evaluates the conditional expression in its argument. Then during analysis, a check is made to ensure tests exist that evaluate the conditional to both true and false. &lt;code&gt;Testcase()&lt;/code&gt; macros are used, for example, to help verify that boundary values are tested. For example:</source>
          <target state="translated">ただし、カバレッジ測定ビルドでは、 &lt;code&gt;testcase()&lt;/code&gt; マクロは、引数の条件式を評価するコードを生成します。次に、分析中に、条件付きを真と偽の両方に評価するテストが存在することを確認するためのチェックが行われます。 &lt;code&gt;Testcase()&lt;/code&gt; マクロは、たとえば、境界値がテストされていることを確認するのに役立ちます。例えば：</target>
        </trans-unit>
        <trans-unit id="6cba989629259efaf3551fd795674dc99bb4d48d" translate="yes" xml:space="preserve">
          <source>But in the following logically equivalent formulation of the same query, the substitution of &quot;CROSS JOIN&quot; for the &quot;,&quot; means that the order of tables must be N1, E, N2.</source>
          <target state="translated">しかし、同じクエリの次の論理的に等価な定式化では、「,」に「CROSS JOIN」を代入すると、テーブルの順序がN1,E,N2にならなければならないことになります。</target>
        </trans-unit>
        <trans-unit id="2a172174425039b0a04cf59d0c65f9b7b37ef450" translate="yes" xml:space="preserve">
          <source>But the &quot;.tables&quot; command does more. It queries the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; table for all &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; databases, not just the primary database. And it arranges its output into neat columns.</source>
          <target state="translated">しかし、「。tables」コマンドはそれ以上のことをします。プライマリデータベースだけでなく、&lt;a href=&quot;lang_attach&quot;&gt;接続さ&lt;/a&gt;れているすべてのデータベースの&lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt;テーブルを照会します。そして、出力をきちんとした列に配置します。</target>
        </trans-unit>
        <trans-unit id="07070136c4e43ff98642891d2498eeab4c61ffd9" translate="yes" xml:space="preserve">
          <source>But the &quot;.tables&quot; command does more. It queries the sqlite_master table for all &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; databases, not just the primary database. And it arranges its output into neat columns.</source>
          <target state="translated">しかし、「。tables」コマンドはさらに多くのことを行います。プライマリデータベースだけでなく、&lt;a href=&quot;lang_attach&quot;&gt;接続さ&lt;/a&gt;れているすべてのデータベースについてsqlite_masterテーブルをクエリします。そして、出力を整然とした列に配置します。</target>
        </trans-unit>
        <trans-unit id="cc1b6b83457a776880f02cbe1ed99910a24b8fb2" translate="yes" xml:space="preserve">
          <source>But the following declaration does not result in &quot;x&quot; being an alias for the rowid:</source>
          <target state="translated">しかし、以下の宣言では、&quot;x &quot;がrowidのエイリアスにはならない。</target>
        </trans-unit>
        <trans-unit id="2d13a39c7ff19d1a4a67287041174bb7cee527dd" translate="yes" xml:space="preserve">
          <source>But the next query can not use the partial index:</source>
          <target state="translated">しかし、次のクエリでは部分インデックスを使用できません。</target>
        </trans-unit>
        <trans-unit id="4968c094e6119e8a687db966e94b26bef2ebe4a4" translate="yes" xml:space="preserve">
          <source>But the use of subtypes does nothing to prevent the value of a pointer from being read using SQL code like this:</source>
          <target state="translated">しかし、サブタイプを使用しても、このようなSQLコードを使用してポインタの値が読み込まれるのを防ぐことはできません。</target>
        </trans-unit>
        <trans-unit id="6310277e9a108b401d7850bc8ffad69350ce478c" translate="yes" xml:space="preserve">
          <source>But there are also disadvantages:</source>
          <target state="translated">しかし、デメリットもあります。</target>
        </trans-unit>
        <trans-unit id="f1e940122523fbd2f68feec81164dcb25704b65b" translate="yes" xml:space="preserve">
          <source>But those routines are optional can can be omitted using a &lt;a href=&quot;compile#zero_malloc&quot;&gt;compile-time option&lt;/a&gt;.</source>
          <target state="translated">ただし、これらのルーチンはオプションであり、&lt;a href=&quot;compile#zero_malloc&quot;&gt;コンパイル時オプション&lt;/a&gt;を使用して省略できます。</target>
        </trans-unit>
        <trans-unit id="b843ee326d7f7cdf5b63dd9bf52bb27bf7756e78" translate="yes" xml:space="preserve">
          <source>But what value to choose for N? One might try N=K. This makes the algorithm O(K&lt;small&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/small&gt;) which is actually still quite efficient, since the maximum value of K is 64 and K rarely exceeds 10. But that is not enough for the TPC-H Q8 problem. With N=8 on TPC-H Q8 the N3 algorithm finds the solution R-N1-C-O-L-S-N2-P with a cost of 29.78. That is a big improvement over NN, but it is still not optimal. N3 finds the optimal solution for TPC-H Q8 when N is 10 or greater.</source>
          <target state="translated">しかし、Nにはどのような値を選択すればよいでしょうか。N = Kを試すかもしれません。K の最大値は64であり、Kはめったに10を超えないため、これはアルゴリズムO（K &lt;small&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/small&gt;）を実際には非常に効率的にしますが、TPC-H Q8問題には十分ではありません。TPC-H Q8でN = 8の場合、N3アルゴリズムは、29.78のコストでソリューションR-N1-COLS-N2-Pを見つけます。これはNNと比べて大きな改善ですが、それでも最適ではありません。N3は、Nが10以上の場合にTPC-H Q8の最適解を見つけます。</target>
        </trans-unit>
        <trans-unit id="65129801103eda08bf342c707b068d5b768e6daf" translate="yes" xml:space="preserve">
          <source>But with SQLite, 200 or more SQL statement per webpage is not a problem.</source>
          <target state="translated">しかし、SQLiteの場合、1ページあたり200文以上のSQL文があれば問題ありません。</target>
        </trans-unit>
        <trans-unit id="36f51675b3471666e7cff23ca3ceb542e736b084" translate="yes" xml:space="preserve">
          <source>But, generally speaking, the more constraints that the R*Tree module has to work with, and the smaller the bounding box, the faster the results will come back.</source>
          <target state="translated">しかし、一般的には、R*Treeモジュールが作業しなければならない制約が多いほど、また、バウンディングボックスが小さければ小さいほど、結果は早く戻ってきます。</target>
        </trans-unit>
        <trans-unit id="bb3dd504a4ceaa15395efbf567f6c35a7b699cba" translate="yes" xml:space="preserve">
          <source>By &quot;static string&quot;, we mean a zero-terminated array of bytes that is fixed and unchanging for the life of the program. In other words, the pointer type string should be a string constant. In contrast, a &quot;dynamic string&quot; is a zero-terminated array of bytes that is held in memory allocated from the heap, and which must be freed to avoid a memory leak. Do not use dynamic strings as the pointer type string.</source>
          <target state="translated">静的文字列」とは、プログラムの寿命の間、固定で不変のゼロ終端バイト配列を意味します。つまり、ポインタ型の文字列は文字列定数でなければなりません。これに対して、「動的文字列」とは、ヒープから割り当てられたメモリに保持され、メモリリークを避けるために解放しなければならないゼロ終端のバイト配列のことです。ポインタ型文字列として動的文字列を使用してはいけません。</target>
        </trans-unit>
        <trans-unit id="f606d9b23ace8996276bde7ccd24b4d280a3c7c4" translate="yes" xml:space="preserve">
          <source>By adding multiple synonyms for a single term to the FTS index. Using this method, when tokenizing document text, the tokenizer provides multiple synonyms for each token. So that when a document such as &quot;I won first place&quot; is tokenized, entries are added to the FTS index for &quot;i&quot;, &quot;won&quot;, &quot;first&quot;, &quot;1st&quot; and &quot;place&quot;.</source>
          <target state="translated">1つの用語に対する複数の同義語をFTSインデックスに追加することによって。この方法を使用すると、文書テキストをトークン化する際に、トークン化器は各トークンに対して複数の同義語を提供します。そのため、&quot;I won first place &quot;のような文書がトークン化されると、&quot;i&quot;、&quot; won&quot;、&quot;first&quot;、&quot;1st&quot;、&quot;place &quot;のエントリがFTSインデックスに追加されます。</target>
        </trans-unit>
        <trans-unit id="80b3f84643451df0998b16a1d70d04019fc8e45c" translate="yes" xml:space="preserve">
          <source>By combining location data and related information into the same table, auxiliary columns can provide a cleaner model and reduce the need to joins. For example, the earlier &lt;a href=&quot;#diquery&quot;&gt;join between demo_index and demo_data&lt;/a&gt; can now be written as a simple query, like this:</source>
          <target state="translated">位置データと関連情報を同じテーブルに結合することにより、補助列はよりクリーンなモデルを提供し、結合の必要性を減らすことができます。たとえば、&lt;a href=&quot;#diquery&quot;&gt;demo_indexとdemo_dataの間&lt;/a&gt;の以前の結合は、次のように単純なクエリとして記述できます。</target>
        </trans-unit>
        <trans-unit id="e37637c9870320bdf8cbf8ef62058290a2f74da5" translate="yes" xml:space="preserve">
          <source>By configuring a callback to be invoked the first time each table is written to that indicates to the session module whether or not changes on the table should be monitored.</source>
          <target state="translated">各テーブルが最初に書き込まれたときに呼び出されるコールバックを設定することで、テーブルの変更を監視するかどうかをセッションモジュールに指示します。</target>
        </trans-unit>
        <trans-unit id="06b847c7709546cccdb0e536dbda4965ee6a96e1" translate="yes" xml:space="preserve">
          <source>By contrast, if foreign key errors can be recognized simply by looking at the definition of the child table and without having to consult the parent table definition, then the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement for the child table fails. Because the error occurs during a schema change, this is a DDL error. Foreign key DDL errors are reported regardless of whether or not foreign key constraints are enabled when the table is created.</source>
          <target state="translated">対照的に、子テーブルの定義を確認するだけで、親テーブルの定義を調べなくても外部キーエラーを認識できる場合、子テーブルの&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;ステートメントは失敗します。エラーはスキーマの変更中に発生するため、これはDDLエラーです。テーブルの作成時に外部キー制約が有効かどうかに関係なく、外部キーDDLエラーが報告されます。</target>
        </trans-unit>
        <trans-unit id="aedeaa844f352e8e17d5cb589064ea1e4109a539" translate="yes" xml:space="preserve">
          <source>By default a session object does not monitor changes on any database table. Before it does so it must be configured. There are three ways to configure the set of tables to monitor changes on:</source>
          <target state="translated">デフォルトでは、セッションオブジェクトはどのデータベーステーブルの変更も監視しません。その前に設定しなければなりません。変更を監視するテーブルのセットを設定するには、3つの方法があります。</target>
        </trans-unit>
        <trans-unit id="55442bbcc7ceaf84de94fa28a3aed619ae9955e0" translate="yes" xml:space="preserve">
          <source>By default, &quot;unicode61&quot; attempts to remove diacritics from Latin script characters. This behaviour can be overridden by adding the tokenizer argument &quot;remove_diacritics=0&quot;. For example:</source>
          <target state="translated">デフォルトでは、&quot;unicode61 &quot;はラテン文字から字句を削除しようとします。この動作は、トークン化引数 &quot;remove_diacritics=0&quot; を追加することで上書きすることができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="7302d3f42259627d0861634979d66a761d287cd5" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; are considered to be non-deterministic. However, if the 4th parameter to &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function_v2()&lt;/a&gt; is OR-ed with &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;, then SQLite will treat that function as if it were deterministic.</source>
          <target state="translated">デフォルトでは、&lt;a href=&quot;appfunc&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;は非決定論的であると見なされます。4番目のパラメータただし、&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function_v2は（）&lt;/a&gt;とOR結合されている&lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;それは決定論的であるかのように、その後、SQLiteは、その関数を扱います。</target>
        </trans-unit>
        <trans-unit id="be3a7476bfd030e836d226174214b4408b10de5a" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are considered to be non-deterministic. However, if the 4th parameter to &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function_v2()&lt;/a&gt; is OR-ed with &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;, then SQLite will treat that function as if it were deterministic.</source>
          <target state="translated">デフォルトでは、&lt;a href=&quot;c3ref/create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;は非決定的であると見なされます。 4番目のパラメータただし、&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function_v2は（）&lt;/a&gt;とOR結合されている&lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;それは決定論的であるかのように、その後、SQLiteは、その関数を処理します。</target>
        </trans-unit>
        <trans-unit id="53685ae8370637562174590d6e02187741d1cecd" translate="yes" xml:space="preserve">
          <source>By default, ANALYZE does a full scan of every index. This can be slow for large databases. So beginning with SQLite version 3.32.0 (2020-05-22), the &lt;a href=&quot;pragma#pragma_analysis_limit&quot;&gt;PRAGMA analysis_limit&lt;/a&gt; command can be used to limit the amount of scanning performed by ANALYZE, and thus help ANALYZE to run faster, even on very large database files. We call this running an &quot;approximate ANALYZE&quot;.</source>
          <target state="translated">デフォルトでは、ANALYZEはすべてのインデックスのフルスキャンを実行します。大規模なデータベースの場合、これは遅くなる可能性があります。そのため、SQLiteバージョン3.32.0（2020-05-22）以降、&lt;a href=&quot;pragma#pragma_analysis_limit&quot;&gt;PRAGMA analysis_limit&lt;/a&gt;コマンドを使用して、ANALYZEによって実行されるスキャンの量を制限できるため、非常に大きなデータベースファイルでもANALYZEをより高速に実行できます。これを「おおよその分析」と呼びます。</target>
        </trans-unit>
        <trans-unit id="78cc7d781eb449f29366e3574bdcdf238af76b02" translate="yes" xml:space="preserve">
          <source>By default, FTS queries (those that use the MATCH operator) consider only those rows with the languageid column set to 0. To query for rows with other languageid values, a constraint of the form &quot;</source>
          <target state="translated">デフォルトでは、FTSクエリ(MATCH演算子を使用するクエリ)は、languageid列が0に設定されている行のみを考慮します。 他のlanguageid値を持つ行にクエリを行うには、&quot;</target>
        </trans-unit>
        <trans-unit id="a4ce99b6ecd6b9193290236a519a16ace8c29ade" translate="yes" xml:space="preserve">
          <source>By default, FTS3/4 occasionally merges together two or more of the b-trees that make up its full-text index within an INSERT, UPDATE or DELETE statement executed by the user. This means that any operation on an FTS3/4 table may turn out to be surprisingly slow, as FTS3/4 may unpredictably choose to merge together two or more large b-trees within it. FTS5 uses incremental merging by default, which limits the amount of processing that may take place within any given INSERT, UPDATE or DELETE operation.</source>
          <target state="translated">デフォルトでは、FTS3/4は、ユーザによって実行されたINSERT、UPDATEまたはDELETE文の中で、その全文インデックスを構成する2つ以上のb-木をマージすることがあります。これは、FTS3/4が予測不能に、その中で2つ以上の大きなb-木をマージすることを選択する可能性があるため、FTS3/4テーブルに対する操作が驚くほど遅くなることを意味します。FTS5はデフォルトでインクリメンタルマージを使用しており、INSERT、UPDATE、DELETE操作の中で行われる処理量を制限しています。</target>
        </trans-unit>
        <trans-unit id="f6e0aaa9f2f3d9d7bf351208161c2a3a5ac7e955" translate="yes" xml:space="preserve">
          <source>By default, FTS5 full-text searches are case-independent. Like any other SQL query that does not contain an ORDER BY clause, the example above returns results in an arbitrary order. To sort results by relevance (most to least relevant), an ORDER BY may be added to a full-text query as follows:</source>
          <target state="translated">既定では、FTS5 のフルテキスト検索は大文字と小文字に依存しません。ORDER BY 節を含まない他の SQL クエリと同様に、上記の例では任意の順序で結果を返します。結果を関連性 (最も関連性の高いものから最も関連性の低いものまで)で並べ替えるには、以下のように ORDER BY をフルテキスト クエリに追加することができます。</target>
        </trans-unit>
        <trans-unit id="9bae9dce645a20ac5b291708dfb54aa225ce0774" translate="yes" xml:space="preserve">
          <source>By default, FTS5 maintains a single index recording the location of each token instance within the document set. This means that querying for complete tokens is fast, as it requires a single lookup, but querying for a prefix token can be slow, as it requires a range scan. For example, to query for the prefix token &quot;abc*&quot; requires a range scan of all tokens greater than or equal to &quot;abc&quot; and less than &quot;abd&quot;.</source>
          <target state="translated">デフォルトでは、FTS5はドキュメントセット内の各トークンインスタンスの位置を記録した単一のインデックスを保持します。つまり、完全なトークンのクエリは1回のルックアップで済むので高速ですが、プレフィックストークンのクエリは範囲スキャンが必要なので、時間がかかることがあります。たとえば、プレフィックストークン &quot;abc*&quot;のクエリを行うには、&quot;abc &quot;以上 &quot;abd &quot;未満のすべてのトークンを範囲スキャンする必要があります。</target>
        </trans-unit>
        <trans-unit id="ff82a6b03b77139ee1bba47d5624340bd5b1daef" translate="yes" xml:space="preserve">
          <source>By default, SQLite assumes that all data uses a fixed-size 8-bit character (iso8859). But if you give the --enable-utf8 option to the configure script, then the library assumes UTF-8 variable sized characters. This makes a difference for the LIKE and GLOB operators and the LENGTH() and SUBSTR() functions. The static string &lt;b&gt;sqlite_encoding&lt;/b&gt; will be set to either &quot;UTF-8&quot; or &quot;iso8859&quot; to indicate how the library was compiled. In addition, the &lt;b&gt;sqlite.h&lt;/b&gt; header file will define one of the macros &lt;b&gt;SQLITE_UTF8&lt;/b&gt; or &lt;b&gt;SQLITE_ISO8859&lt;/b&gt;, as appropriate.</source>
          <target state="translated">デフォルトでは、SQLiteはすべてのデータが固定サイズの8ビット文字（iso8859）を使用すると想定しています。ただし、configureスクリプトに--enable-utf8オプションを指定すると、ライブラリはUTF-8の可変サイズの文字を想定します。これにより、LIKE演算子とGLOB演算子、およびLENGTH（）関数とSUBSTR（）関数に違いが生じます。静的文字列&lt;b&gt;sqlite_encoding&lt;/b&gt;は、「UTF-8」または「iso8859」のいずれかに設定され、ライブラリのコンパイル方法を示します。さらに、&lt;b&gt;sqlite.h&lt;/b&gt;ヘッダーファイルは、必要に応じて、マクロ&lt;b&gt;SQLITE_UTF8&lt;/b&gt;または&lt;b&gt;SQLITE_ISO8859の&lt;/b&gt;&lt;b&gt;いずれ&lt;/b&gt;かを定義します。</target>
        </trans-unit>
        <trans-unit id="cbc8ea1232230a6d65d66bdbfc39e47fe8c9edc5" translate="yes" xml:space="preserve">
          <source>By default, SQLite assumes that an operating system call to write a range of bytes will not damage or alter any bytes outside of that range even if a power loss or OS crash occurs during that write. We call this the &quot;&lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt;&quot; property. Prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_7_9.html&quot;&gt;version 3.7.9&lt;/a&gt; (2011-11-01), SQLite did not assume powersafe overwrite. But with the standard sector size increasing from 512 to 4096 bytes on most disk drives, it has become necessary to assume powersafe overwrite in order to maintain historical performance levels and so powersafe overwrite is assumed by default in recent versions of SQLite. The assumption of powersafe overwrite property can be disabled at compile-time or a run-time if desired. See the &lt;a href=&quot;psow&quot;&gt;powersafe overwrite documentation&lt;/a&gt; for further details.</source>
          <target state="translated">デフォルトでは、SQLiteは、ある範囲のバイトを書き込むためのオペレーティングシステムコールが、その書き込み中に停電やOSクラッシュが発生した場合でも、その範囲外のバイトを損傷または変更しないと想定しています。これを「&lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt;」プロパティと呼びます。&lt;a href=&quot;https://sqlite.org/releaselog/3_7_9.html&quot;&gt;バージョン3.7.9&lt;/a&gt;（2011-11-01）より前は、SQLiteはpowersafe overwriteを想定していませんでした。ただし、ほとんどのディスクドライブで標準セクターサイズが512から4096バイトに増加しているため、履歴パフォーマンスレベルを維持するためにパワーセーフ上書きを想定する必要があり、SQLiteの最近のバージョンではデフォルトでパワーセーフ上書きが想定されています。 powersafe overwriteプロパティの前提は、必要に応じてコンパイル時または実行時に無効にすることができます。詳細については、&lt;a href=&quot;psow&quot;&gt;powersafe overwriteのドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="f018eca355fa9ae5d020ba88bd8ea21f258703c5" translate="yes" xml:space="preserve">
          <source>By default, SQLite does a checkpoint automatically when the WAL file reaches a threshold size of 1000 pages. (The &lt;a href=&quot;compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt; compile-time option can be used to specify a different default.) Applications using WAL do not have to do anything in order to for these checkpoints to occur. But if they want to, applications can adjust the automatic checkpoint threshold. Or they can turn off the automatic checkpoints and run checkpoints during idle moments or in a separate thread or process.</source>
          <target state="translated">デフォルトでは、WALファイルがしきい値サイズの1000ページに達すると、SQLiteは自動的にチェックポイントを実行します。 （&lt;a href=&quot;compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt;コンパイル時オプションを使用して、別のデフォルトを指定できます。）WALを使用するアプリケーションは、これらのチェックポイントを発生させるために何もする必要はありません。ただし、必要に応じて、アプリケーションで自動チェックポイントしきい値を調整できます。または、自動チェックポイントをオフにして、アイドル時に、または別のスレッドやプロセスでチェックポイントを実行することもできます。</target>
        </trans-unit>
        <trans-unit id="c47d73038962ba3e0484234ad47892e41a6eccb3" translate="yes" xml:space="preserve">
          <source>By default, SQLite keeps statistics on its memory usage. These statistics are useful in helping to determine how much memory an application really needs. The statistics can also be used in high-reliability system to determine if the memory usage is coming close to or exceeding the limits of the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt; and hence that the memory allocation subsystem is liable to breakdown.</source>
          <target state="translated">デフォルトでは、SQLiteはメモリ使用量の統計を保持します。これらの統計は、アプリケーションが実際に必要とするメモリの量を決定するのに役立ちます。統計を高信頼性システムで使用して、メモリ使用量が&lt;a href=&quot;malloc#nofrag&quot;&gt;ロブソン証明の&lt;/a&gt;制限に近づいている、または超えているかどうか、したがってメモリ割り当てサブシステムが故障している可能性があるかどうかを判断することもできます。</target>
        </trans-unit>
        <trans-unit id="45a42d60e1bd3a274255ba5930fab23192de66e7" translate="yes" xml:space="preserve">
          <source>By default, SQLite obtains the memory it needs for objects and cache from the malloc()/free() implementation of the standard library. There is also on-going work with experimental memory allocators that satisfy all memory requests from a single fixed memory buffer handed to SQLite at application start. Additional information on these experimental memory allocators will be provided in a future revision of this document.</source>
          <target state="translated">デフォルトでは、SQLite はオブジェクトとキャッシュに必要なメモリを標準ライブラリの malloc()/free()の実装から取得します。また、アプリケーションの起動時に SQLite に渡される単一の固定メモリバッファからすべてのメモリ要求を満たす実験的なメモリアロケータの開発も進行中です。これらの実験的なメモリアロケータに関する追加情報は、このドキュメントの将来のリビジョンで提供される予定です。</target>
        </trans-unit>
        <trans-unit id="f1f4239650661b10de63616260d0037b2cc6746e" translate="yes" xml:space="preserve">
          <source>By default, SQLite uses the malloc(), realloc(), and free() routines from the standard C library for its memory allocation needs. These routines are surrounded by a thin wrapper that also provides a &quot;memsize()&quot; function that will return the size of an existing allocation. The memsize() function is needed to keep an accurate count of the number of bytes of outstanding memory; memsize() determines how many bytes to remove from the outstanding count when an allocation is freed. The default allocator implements memsize() by always allocating 8 extra bytes on each malloc() request and storing the size of the allocation in that 8-byte header.</source>
          <target state="translated">デフォルトでは、SQLite は標準 C ライブラリの malloc()、realloc()、free()ルーチンをメモリ割り当てのために使用します。これらのルーチンは薄いラッパーで囲まれており、既存のアロケーションのサイズを返す &quot;memsize()&quot; 関数も提供しています。memsize()関数は、未処理メモリのバイト数を正確にカウントするために必要です。デフォルトのアロケータは、malloc()リクエストごとに常に 8 バイトの余分なバイトを割り当て、その 8 バイトのヘッダにアロケーションのサイズを格納することで memsize()を実装しています。</target>
        </trans-unit>
        <trans-unit id="ac7bf7e7f400c7dac01c89761055dce039c96113" translate="yes" xml:space="preserve">
          <source>By default, SQLite will automatically checkpoint whenever a &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; occurs that causes the WAL file to be 1000 pages or more in size, or when the last database connection on a database file closes. The default configuration is intended to work well for most applications. But programs that want more control can force a checkpoint using the &lt;a href=&quot;pragma#pragma_wal_checkpoint&quot;&gt;wal_checkpoint pragma&lt;/a&gt; or by calling the &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; C interface. The automatic checkpoint threshold can be changed or automatic checkpointing can be completely disabled using the &lt;a href=&quot;pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint pragma&lt;/a&gt; or by calling the &lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint()&lt;/a&gt; C interface. A program can also use &lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; to register a callback to be invoked whenever any transaction commits to the WAL. This callback can then invoke &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; or &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; based on whatever criteria it thinks is appropriate. (The automatic checkpoint mechanism is implemented as a simple wrapper around &lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt;.)</source>
          <target state="translated">デフォルトでは、SQLiteは、WALファイルのサイズが1000ページ以上になる&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;が発生したとき、またはデータベースファイルの最後のデータベース接続が閉じたときに、自動的にチェックポイントを設定します。デフォルトの構成は、ほとんどのアプリケーションで適切に機能するように設計されています。しかし、より多くの制御を必要とするプログラムは、&lt;a href=&quot;pragma#pragma_wal_checkpoint&quot;&gt;wal_checkpointプラグマ&lt;/a&gt;を使用するか、&lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint（）&lt;/a&gt; Cインターフェースを呼び出すことにより、チェックポイントを強制できます。&lt;a href=&quot;pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpointプラグマ&lt;/a&gt;を使用するか、&lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint（）&lt;/a&gt; Cインターフェースを呼び出すことにより、自動チェックポイントのしきい値を変更したり、自動チェックポイントを完全に無効にしたりできます。プログラムは&lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook（）&lt;/a&gt;も使用できますトランザクションがWALにコミットするたびに呼び出されるコールバックを登録します。このコールバックは、適切と思われる基準に基づいて、&lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint（）&lt;/a&gt;または&lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2（）&lt;/a&gt;を呼び出すことができます。（自動チェックポイントメカニズムは、&lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook（）の&lt;/a&gt;単純なラッパーとして実装されています。）</target>
        </trans-unit>
        <trans-unit id="dfe31588b0add6c729f8eab371bfea7925cb6297" translate="yes" xml:space="preserve">
          <source>By default, VACUUM only works only on the main database. &lt;a href=&quot;lang_attach&quot;&gt;Attached databases&lt;/a&gt; can be vacuumed by appending the appropriate schema-name to the VACUUM statement.</source>
          <target state="translated">デフォルトでは、VACUUMはメインデータベースでのみ機能します。&lt;a href=&quot;lang_attach&quot;&gt;アタッチされたデータベース&lt;/a&gt;は、適切なスキーマ名をVACUUMステートメントに追加することでバキュームできます。</target>
        </trans-unit>
        <trans-unit id="609f717a6d90d2816632d1db2908a5d9109c172f" translate="yes" xml:space="preserve">
          <source>By default, coordinates are stored in an R*Tree using 32-bit floating point values. When a coordinate cannot be exactly represented by a 32-bit floating point number, the lower-bound coordinates are rounded down and the upper-bound coordinates are rounded up. Thus, bounding boxes might be slightly larger than specified, but will never be any smaller. This is exactly what is desired for doing the more common &quot;overlapping&quot; queries where the application wants to find every entry in the R*Tree that overlaps a query bounding box. Rounding the entry bounding boxes outward might cause a few extra entries to appears in an overlapping query if the edge of the entry bounding box corresponds to an edge of the query bounding box. But the overlapping query will never miss a valid table entry.</source>
          <target state="translated">デフ ォ ル ト では、 座標は 32 ビ ッ ト 浮動小数点値を用いて R*Tree に格納されます。座標が32ビット浮動小数点数で正確に表現できない場合は、下位境界の座標は切り捨てられ、上位境界の座標は切り上げられます。したがって、バウンディングボックスは指定されたよりもわずかに大きくなるかもしれませんが、これ以上小さくなることはありません。これは、アプリケーションがR*Treeの中で、クエリのバウンディングボックスと重なるエントリをすべて見つけたいという、より一般的な &quot;オーバーラップ &quot;クエリを行う場合にまさに必要とされるものです。エントリのバウンディングボックスを外側に丸めてしまうと、エントリのバウンディングボックスの端がクエリのバウンディングボックスの端と一致している場合に、重複クエリの中にいくつかの余分なエントリが現れることになります。しかし、オーバーラッピングクエリで有効なテーブルエントリを見逃すことはありません。</target>
        </trans-unit>
        <trans-unit id="199efd35071a0aa576610e8f4fe7005becc87773" translate="yes" xml:space="preserve">
          <source>By default, diacritics are removed from all Latin script characters. This means, for example, that &quot;A&quot;, &quot;a&quot;, &quot;&amp;Agrave;&quot;, &quot;&amp;agrave;&quot;, &quot;&amp;Acirc;&quot; and &quot;&amp;acirc;&quot; are all considered to be equivalent.</source>
          <target state="translated">デフォルトでは、すべてのラテン文字から発音区別符号が削除されます。これは、たとえば、「A」、「a」、「&amp;Agrave;」、「&amp;agrave;」、「&amp;Acirc;」、「&amp;acirc;」はすべて同等と見なされることを意味します。</target>
        </trans-unit>
        <trans-unit id="bb034dd2f0250c21e84e164917272d1dc5842d40" translate="yes" xml:space="preserve">
          <source>By default, differences in the schema or content of virtual tables are not reported on.</source>
          <target state="translated">デフォルトでは、仮想テーブルのスキーマや内容の違いは報告されません。</target>
        </trans-unit>
        <trans-unit id="b77f26d39d106302cf0e476c578f7ebf5e3ef7c7" translate="yes" xml:space="preserve">
          <source>By default, each INSERT statement is its own transaction. But if you surround multiple INSERT statements with &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;...&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; then all the inserts are grouped into a single transaction. The time needed to commit the transaction is amortized over all the enclosed insert statements and so the time per insert statement is greatly reduced.</source>
          <target state="translated">デフォルトでは、各INSERTステートメントは独自のトランザクションです。ただし、&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; ... &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;で複数のINSERTステートメントを囲むと、すべての挿入が1つのトランザクションにグループ化されます。トランザクションをコミットするのに必要な時間は、含まれているすべての挿入ステートメントにわたって償却されるため、挿入ステートメントごとの時間が大幅に短縮されます。</target>
        </trans-unit>
        <trans-unit id="6a7a241c9fa980ec6fabd179e76034fe7898c1e2" translate="yes" xml:space="preserve">
          <source>By default, each column is between 1 and 10 characters wide, depending on the column header name and the width of the first column of data. Data that is too wide to fit in a column is truncated. Use the &quot;.width&quot; dot-command to adjust column widths, like this:</source>
          <target state="translated">デフォルトでは、各カラムの幅は、カラムヘッダ名とデータの最初のカラムの幅に応じて、1文字から10文字の間になります。幅が広すぎて列に収まらないデータは切り捨てられます。列の幅を調整するには、このように「.width」ドットコマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="5e4318cdb175f91c3caf7375a2080f232459374d" translate="yes" xml:space="preserve">
          <source>By default, every row in SQLite has a special column, usually called the &quot;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;&quot;, that uniquely identifies that row within the table. However if the phrase &quot;WITHOUT ROWID&quot; is added to the end of a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement, then the special &quot;rowid&quot; column is omitted. There are sometimes space and performance advantages to omitting the rowid.</source>
          <target state="translated">デフォルトでは、SQLiteのすべての行には、通常「&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;」と呼ばれる特別な列があり、テーブル内のその行を一意に識別します。ただし、「WITHOUT ROWID」という句が&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;ステートメントの最後に追加される場合、特別な「rowid」列は省略されます。ROWIDを省略した方が、スペースとパフォーマンスの面で有利な場合があります。</target>
        </trans-unit>
        <trans-unit id="d6ef17af0abc70adef74ccbccb6e7ada9c1f618f" translate="yes" xml:space="preserve">
          <source>By default, kvtest runs the database I/O measurements all within a single transaction. Use the --multitrans option to run each blob read or write in a separate transaction. The --multitrans option makes SQLite much slower, and uncompetitive with direct disk I/O. This option proves, yet again, that to get the most performance out of SQLite, you should group as much database interaction as possible within a single transaction.</source>
          <target state="translated">デフォルトでは、kvtestはデータベースのI/O測定をすべて1つのトランザクション内で実行します。multitransオプションを使用すると、各ブロブの読み書きを別々のトランザクションで実行することができます。multitransオプションはSQLiteの動作をかなり遅くし、直接のディスクI/Oとは競合しません。このオプションは、SQLite のパフォーマンスを最大限に引き出すためには、できるだけ多くのデータベースの相互作用を単一のトランザクション内でグループ化する必要があることを改めて証明しています。</target>
        </trans-unit>
        <trans-unit id="a027e685d0b82e63c37ab615c6c8b1bef894cf6d" translate="yes" xml:space="preserve">
          <source>By default, sqldiff attempts to process all non-virtual tables within the two databases provided to it. If any table appears in one database but not the other, or if any table has a slightly different schema in one database it is an error. The &quot;--table&quot; option may be useful if this causes a problem</source>
          <target state="translated">デフォルトでは、sqldiffは提供された2つのデータベース内のすべての非仮想テーブルを処理しようとします。片方のデータベースにはテーブルがあってももう片方のデータベースにはない場合や、片方のデータベースにあるテーブルのスキーマが微妙に異なる場合はエラーとなります。これが問題を引き起こす場合は、&quot;--table &quot;オプションが便利です。</target>
        </trans-unit>
        <trans-unit id="46b22419bd1a4fd00ad28b08bf067b6f9f4f5e90" translate="yes" xml:space="preserve">
          <source>By default, sqlite3 sends query results to standard output. You can change this using the &quot;.output&quot; and &quot;.once&quot; commands. Just put the name of an output file as an argument to .output and all subsequent query results will be written to that file. Or use the .once command instead of .output and output will only be redirected for the single next command before reverting to the console. Use .output with no arguments to begin writing to standard output again. For example:</source>
          <target state="translated">デフォルトでは、sqlite3はクエリ結果を標準出力に送ります。これは&quot;.output &quot;と&quot;.once &quot;コマンドを使って変更することができます。.outputの引数に出力ファイル名を指定するだけで、それ以降の全てのクエリ結果はそのファイルに書き込まれます。あるいは、.outputの代わりに.onceコマンドを使用すると、出力はコンソールに戻る前に次のコマンドのためだけにリダイレクトされます。再び標準出力への書き込みを開始するには、引数なしの.outputを使用します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="e508a45fb514da22df2b29ba2714c0232eb3c718" translate="yes" xml:space="preserve">
          <source>By default, swarmvtab attempts to limit the number of simultaneously open databases to nine. This parameter allows that limit to be changed. For example, to create a swarmvtab table that may hold up to 30 databases open simultaneously:</source>
          <target state="translated">既定では、swarmvtabは同時に開くデータベースの数を9個に制限しようとします。このパラメータでは、この制限を変更することができます。たとえば、同時に開いているデータベースを最大 30 個まで保持する swarmvtab テーブルを作成します。</target>
        </trans-unit>
        <trans-unit id="aac34cb1103bf35fa437aa535e48e93e51a7d344" translate="yes" xml:space="preserve">
          <source>By default, the &quot;.expert&quot; command recommends indexes based on the query and database schema alone. This is similar to the way the &lt;a href=&quot;optoverview&quot;&gt;SQLite query planner&lt;/a&gt; selects indexes for queries if the user has not run the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command on the database to generate data distribution statistics.</source>
          <target state="translated">デフォルトでは、「。expert」コマンドは、クエリとデータベーススキーマのみに基づいてインデックスを推奨します。これは、ユーザーがデータベースで&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;コマンドを実行してデータ分散統計を生成していない場合に、&lt;a href=&quot;optoverview&quot;&gt;SQLiteクエリプランナー&lt;/a&gt;がクエリのインデックスを選択する方法に似ています。</target>
        </trans-unit>
        <trans-unit id="79e59781472aaf1cab549c7756351e991a52f37c" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface will automatically invoke &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt; to reset the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; if necessary. This compile-time option changes that behavior so that &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; will return &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; if it called again after returning anything other than &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, or &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; unless there was an intervening call to &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt;.</source>
          <target state="translated">デフォルトでは、&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;インターフェースは自動的に&lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;を呼び出し、必要に応じて&lt;a href=&quot;c3ref/stmt&quot;&gt;準備されたステートメント&lt;/a&gt;をリセットします。そのように、このコンパイル時のオプションは、その動作を変更&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）が&lt;/a&gt;返されます&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSEを&lt;/a&gt;、それ以外の何も戻った後、再び呼び出された場合&lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;、&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;、または&lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKEDを&lt;/a&gt;する介在呼び出しがあった場合を除き&lt;a href=&quot;c3ref/reset&quot;&gt;（）sqlite3_resetを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b8f030cbd6427054daf45dea55ca6b9a3924a3dd" translate="yes" xml:space="preserve">
          <source>By default, the SQLite core double checks all constraints on each row of the virtual table that it receives. If such a check is redundant, the xBestFilter method can suppress that double-check by setting aConstraintUsage[].omit.</source>
          <target state="translated">デフォルトでは、SQLiteコアは受信した仮想テーブルの各行のすべての制約をダブルチェックします。そのようなチェックが冗長な場合、xBestFilterメソッドは、aConstraintUsage[].omitを設定することで、そのダブルチェックを抑制することができます。</target>
        </trans-unit>
        <trans-unit id="fa0f172004db89e74c2b903c6ed15681a8554ce0" translate="yes" xml:space="preserve">
          <source>By default, the output of EXPLAIN QUERY PLAN commands does not include output for any operations performed by trigger programs. This option is used to set or clear (the default) a flag that governs this behavior. The first parameter passed to this operation is an integer - positive to enable output for trigger programs, or zero to disable it, or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether output-for-triggers has been disabled - 0 if it is not disabled, 1 if it is.</source>
          <target state="translated">デフォルトでは、EXPLAIN QUERY PLANコマンドの出力には、トリガプログラムによって実行された操作の出力は含まれません。このオプションは、この動作を制御するフラグを設定またはクリア(デフォルト)するために使用されます。この操作に渡される最初のパラメータは整数で、正の場合はトリガプログラムの出力を有効にし、ゼロの場合は無効にし、負の場合は設定を変更しないままにします。2 番目のパラメータは整数へのポインタで、0 または 1 が書き込まれ、トリガ用出力が無効化されているかどうかを示します-無効化されていない場合は 0、無効化されている場合は 1 となります。</target>
        </trans-unit>
        <trans-unit id="d45ac6e349cce0d243d17d663e9e87155d75add6" translate="yes" xml:space="preserve">
          <source>By default, the porter tokenizer operates as a wrapper around the default tokenizer (unicode61). Or, if one or more extra arguments are added to the &quot;tokenize&quot; option following &quot;porter&quot;, they are treated as a specification for the underlying tokenizer that the porter stemmer uses. For example:</source>
          <target state="translated">デフォルトでは、porter トークン化機能は、デフォルトのトークン化機能 (unicode61)のラッパーとして動作します。あるいは、&quot;porter&quot; の後の &quot;tokenize&quot; オプションに 1 つ以上の追加引数が追加された場合、それらは、 porter ステム機能が使用するトークン化方式の指定として扱われます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="923e8b64eceb6502080849392eadafdbb5ce98eb" translate="yes" xml:space="preserve">
          <source>By default, the sessions module streaming interfaces attempt to input and output data in approximately 1 KiB chunks. This operand may be used to set and query the value of this configuration setting. The pointer passed as the second argument must point to a value of type (int). If this value is greater than 0, it is used as the new streaming data chunk size for both input and output. Before returning, the (int) value pointed to by pArg is set to the final value of the streaming interface chunk size.</source>
          <target state="translated">デフォルトでは、セッション・モジュールのストリーミング・インターフェースは、約1KiBのチャンクでデータを入出力しようとします。このオペランドは、この構成設定の値を設定したり、問い合わせたりするために使用することができます。第2引数として渡されるポインタは、型(int)の値を指す必要があります。この値が0より大きい場合は、入力と出力の両方の新しいストリーミング・データ・チャンク・サイズとして使用されます。復帰する前に、pArgが指す(int)型の値は、ストリーミング・インタフェース・チャンク・サイズの最終値に設定されます。</target>
        </trans-unit>
        <trans-unit id="ed67e473742eb7c111c47a0cfdbbdb68f21a394b" translate="yes" xml:space="preserve">
          <source>By default, the shell is now in &quot;auto-explain&quot; mode. The output of &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; commands is automatically formatted.</source>
          <target state="translated">デフォルトでは、シェルは「自動説明」モードになっています。&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;コマンドの出力は自動的にフォーマットされます。</target>
        </trans-unit>
        <trans-unit id="52d930b9eee7711ba25f4fd9b5cbc893a2bf348f" translate="yes" xml:space="preserve">
          <source>By default, the spellfix1 table returns no more than 20 results. (It might return less than 20 if there were fewer good matches.) You can change the upper bound on the number of returned rows by adding a &quot;top=N&quot; term to the WHERE clause of your query, where N is the new maximum. For example, to see the 5 best matches:</source>
          <target state="translated">デフォルトでは、spellfix1 テーブルが返す結果は 20 件以下となっています (マッチするものが少ない場合は 20 件以下になるかもしれません)。返される行数の上限を変更するには、クエリの WHERE 句に &quot;top=N&quot; を追加します。例えば、ベストマッチ5を表示するには、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="801f0fef23ca30c740bc98f388b5820b01c0a8aa" translate="yes" xml:space="preserve">
          <source>By default, there is a single row in the DBSTAT table for each btree page the database file. Each row provides information about the space utilization of that one page of the database. However, if the hidden column &quot;aggregate&quot; is TRUE, then results are aggregated and there is a single row in the DBSTAT table for each btree in the database, providing information about space utilization across the entire btree.</source>
          <target state="translated">デフォルトでは、データベースファイルの各btreeページのDBSTATテーブルには1つの行があります。各行は、データベースのその一ページのスペース使用率に関する情報を提供します。ただし、隠しカラム &quot;aggregate&quot; が TRUE の場合は、結果が集約され、データベース内の各 btree について DBSTAT テーブルには 1 行が存在し、btree 全体のスペース使用率に関する情報が提供されます。</target>
        </trans-unit>
        <trans-unit id="fa387565dd5968c7d1760a2e2262809354a9a035" translate="yes" xml:space="preserve">
          <source>By enclosing it in double quotes (&quot;). Within a string, any embedded double quote characters may be escaped SQL-style - by adding a second double-quote character.</source>
          <target state="translated">二重引用符(&quot;)で囲むことで、文字列の中に埋め込まれた二重引用符はSQLスタイルでエスケープすることができます。文字列の中に二重引用符で囲まれた文字は、二重引用符の二番目の文字を追加することで、SQLスタイルでエスケープすることができます。</target>
        </trans-unit>
        <trans-unit id="84617083eaab12542d0a6d482dc6332adeedf772" translate="yes" xml:space="preserve">
          <source>By explicitly specifying tables using one call to &lt;a href=&quot;session/sqlite3session_attach&quot;&gt;sqlite3session_attach()&lt;/a&gt; for each table, or</source>
          <target state="translated">テーブルごとに&lt;a href=&quot;session/sqlite3session_attach&quot;&gt;sqlite3session_attach（）&lt;/a&gt;への1回の呼び出しを使用してテーブルを明示的に指定する、または</target>
        </trans-unit>
        <trans-unit id="7ec7970e0cfef9d2d98bfdb89f93e1b8b4b4b117" translate="yes" xml:space="preserve">
          <source>By invoking the xCheckReservedLock() method of the file-handle opened on the database file, SQLite checks if some other connection holds a</source>
          <target state="translated">データベースファイル上で開かれたファイルハンドルの xCheckReservedLock()メソッドを呼び出すことで、SQLite は他の接続が</target>
        </trans-unit>
        <trans-unit id="e392907538e008d1f980f80b5391101815ed2a70" translate="yes" xml:space="preserve">
          <source>By mapping all synonyms to a single token. In this case, the In the above example, this means that the tokenizer returns the same token for inputs &quot;first&quot; and &quot;1st&quot;. Say that token is in fact &quot;first&quot;, so that when the user inserts the document &quot;I won 1st place&quot; entries are added to the index for tokens &quot;i&quot;, &quot;won&quot;, &quot;first&quot; and &quot;place&quot;. If the user then queries for '1st + place', the tokenizer substitutes &quot;first&quot; for &quot;1st&quot; and the query works as expected.</source>
          <target state="translated">すべての同義語を1つのトークンにマッピングすることで この場合は 上記の例では、トークンライザは入力「1位」と「1位」に対して同じトークンを返すことを意味しています。トークンが実際には「1st」であるとすると、ユーザーがドキュメント「I won 1st place」を挿入すると、トークン「i」、「 won」、「first」、「place」のインデックスにエントリが追加されます。ユーザーが「1st+place」のクエリを行うと、トークンライザは「1st」を「1st」に置き換え、クエリは期待通りに動作します。</target>
        </trans-unit>
        <trans-unit id="d6c6c3e21f2551827a19fdcc87eccf2596523e84" translate="yes" xml:space="preserve">
          <source>By mapping all synonyms to a single token. In this case, using the above example, this means that the tokenizer returns the same token for inputs &quot;first&quot; and &quot;1st&quot;. Say that token is in fact &quot;first&quot;, so that when the user inserts the document &quot;I won 1st place&quot; entries are added to the index for tokens &quot;i&quot;, &quot;won&quot;, &quot;first&quot; and &quot;place&quot;. If the user then queries for '1st + place', the tokenizer substitutes &quot;first&quot; for &quot;1st&quot; and the query works as expected.</source>
          <target state="translated">すべての同義語を1つのトークンにマッピングすることによって。この場合、上記の例を使うと、トークンライザは入力 &quot;first &quot;と入力 &quot;1st &quot;に対して同じトークンを返すことを意味します。トークンが実際には「1st」であるとすると、ユーザーが「I won 1st place」というドキュメントを挿入すると、トークン「i」、「 won」、「first」、「place」のインデックスにエントリが追加されます。ユーザーが「1st+place」のクエリを行うと、トークンライザは「1st」を「1st」に置き換え、クエリは期待通りに動作します。</target>
        </trans-unit>
        <trans-unit id="f19cb00f7026582f508ec895d006b5124a9aeb30" translate="yes" xml:space="preserve">
          <source>By querying the index for all synonyms of each query term separately. In this case, when tokenizing query text, the tokenizer may provide multiple synonyms for a single term within the document. FTS5 then queries the index for each synonym individually. For example, faced with the query:</source>
          <target state="translated">各クエリ用語のすべての同義語を別々にインデックスに問い合わせることによって。この場合、クエリテキストをトークン化するとき、トークン化器は文書内の単一の用語に対して複数の同義語を提供することがある。FTS5は、各同義語のインデックスを個別に問い合わせます。例えば、クエリに直面した場合。</target>
        </trans-unit>
        <trans-unit id="55b05786af4043a1be86d71e95ee1411780e7ee4" translate="yes" xml:space="preserve">
          <source>By setting it to an empty string to create a contentless FTS5 table. In this case FTS5 assumes that the original column values are unavailable to it when processing queries. Full-text queries and some auxiliary functions can still be used, but no column values apart from the rowid may be read from the table.</source>
          <target state="translated">空の文字列に設定することで、コンテントレスなFTS5テーブルを作成します。この場合、FTS5は、クエリを処理する際に元のカラム値が利用できないことを前提としています。フルテキストクエリやいくつかの補助関数はまだ使用できますが、 rowid以外のカラム値はテーブルから読み取れません。</target>
        </trans-unit>
        <trans-unit id="61a66a14e7dcfe0861d93ec30802747dfb7523a1" translate="yes" xml:space="preserve">
          <source>By setting it to the name of a database object (table, virtual table or view) that may be queried by FTS5 at any time to retrieve the column values. This is known as an &quot;external content&quot; table. In this case all FTS5 functionality may be used, but it is the responsibility of the user to ensure that the contents of the full-text index are consistent with the named database object. If they are not, query results may be unpredictable.</source>
          <target state="translated">これを設定することで、FTS5が列の値を取得するためにいつでも照会できるデータベースオブジェクト(テーブル、仮想テーブル、またはビュー)の名前にすることができます。これは「外部コンテンツ」テーブルとして知られています。この場合、FTS5のすべての機能を使用することができますが、フルテキストインデックスの内容が名前のついたデータベースオブジェクトと一致していることを確認するのはユーザーの責任です。もしそうでない場合、クエリの結果は予測できないものになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="b65e88a6a0b747d6c1e54c4edd9925d09b470f08" translate="yes" xml:space="preserve">
          <source>By specifying that all tables in the database should be monitored for changes using a call to &lt;a href=&quot;session/sqlite3session_attach&quot;&gt;sqlite3session_attach()&lt;/a&gt; with a NULL argument, or</source>
          <target state="translated">NULL引数を指定した&lt;a href=&quot;session/sqlite3session_attach&quot;&gt;sqlite3session_attach（）の&lt;/a&gt;呼び出しを使用して、データベース内のすべてのテーブルの変更を監視するように指定する、または</target>
        </trans-unit>
        <trans-unit id="63f834f4a2da63acc54bc935f1fd1ad5ded1c97a" translate="yes" xml:space="preserve">
          <source>By the time &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; is invoked by wait_for_unlock_notify(), it is possible that the blocking connection that prevented the sqlite3_step() or sqlite3_prepare_v2() call from succeeding has already finished its transaction. In this case, the unlock-notify callback is invoked immediately, before &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; returns. Or, it is possible that the unlock-notify callback is invoked by a second thread after &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; is called but before the thread starts waiting to be asynchronously signaled.</source>
          <target state="translated">&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;がwait_for_unlock_notify（）によって呼び出されるときまでに、sqlite3_step（）またはsqlite3_prepare_v2（）呼び出しの成功を妨げていたブロッキング接続がすでにトランザクションを終了している可能性があります。この場合、&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;が戻る前に、すぐにロック解除通知コールバックが呼び出されます。または、&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;が呼び出された後で、スレッドが非同期にシグナルされるのを待機する前に、2番目のスレッドによってロック解除通知コールバックが呼び出される可能性があります。</target>
        </trans-unit>
        <trans-unit id="294016815718412ee0c20270b6745c8ced5712e1" translate="yes" xml:space="preserve">
          <source>By using its own built-in implementation, SQLite guarantees that the output will be the same on all platforms and in all LOCALEs. This is important for consistency and for testing. It would be problematic if one machine gave and answer of &quot;5.25e+08&quot; and another gave an answer of &quot;5.250e+008&quot;. Both answers are correct, but it is better when SQLite always gives the same answer.</source>
          <target state="translated">独自の組み込み実装を使用することで、SQLiteはすべてのプラットフォームとすべてのLOCALEで出力が同じであることを保証します。これは一貫性とテストのために重要です。あるマシンが &quot;5.25e+08 &quot;と答え、別のマシンが &quot;5.250e+008 &quot;と答えたとします。どちらの答えも正しいのですが、SQLiteが常に同じ答えを出す方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="478bcd9433faa7931ee1c7c1b62ccda2a8f4f8e8" translate="yes" xml:space="preserve">
          <source>By using standard SQL expressions in the WHERE clause of a SELECT query, a programmer can query for all R*Tree entries that intersect with or are contained within a particular bounding-box. Custom R*Tree queries, using the MATCH operator in the WHERE clause of a SELECT, allow the programmer to query for the set of R*Tree entries that intersect any arbitrary region or shape, not just a box. This capability is useful, for example, in computing the subset of objects in the R*Tree that are visible from a camera positioned in 3-D space.</source>
          <target state="translated">SELECTクエリのWHERE句で標準SQL式を使用することで、プログラマは特定のバウンディングボックスと交差する、または特定のバウンディングボックス内に含まれるすべてのR*Treeエントリをクエリすることができます。SELECTのWHERE句でMATCH演算子を使用したカスタムR*Treeクエリでは、プログラマは、ボックスだけでなく、任意の領域や形状と交差するR*Treeエントリのセットを検索することができます。この機能は、例えば、3D空間に配置されたカメラから見えるR*Tree内のオブジェクトのサブセットを計算するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="89a11056dc1624db725c970738aa5aaf2b86e420" translate="yes" xml:space="preserve">
          <source>Byte offset</source>
          <target state="translated">バイトオフセット</target>
        </trans-unit>
        <trans-unit id="3552062ee633a28da0a78f6b8da0963926758e2e" translate="yes" xml:space="preserve">
          <source>Byte offset to the start of the page</source>
          <target state="translated">ページの先頭へのバイトオフセット</target>
        </trans-unit>
        <trans-unit id="40c37d34180ee81abeec6396f466a7bf1d1f2f45" translate="yes" xml:space="preserve">
          <source>Bytecode Engine</source>
          <target state="translated">バイトコードエンジン</target>
        </trans-unit>
        <trans-unit id="e7d87e87cd071442d28d7e11c0a34595a73b4b95" translate="yes" xml:space="preserve">
          <source>Bytecode and tables_used are &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; built into SQLite that access information about &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt;. Both bytecode and tables_used operate as &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt;. They take a single required argument which is either the text of an SQL statement, or a pointer to an existing prepared statement. The bytecode function returns one row of result for each &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; operation in the prepared statement. The tables_used function returns one row for each persistent btree (either a table or an index) accessed by the prepared statement.</source>
          <target state="translated">Bytecodeとtables_usedは、&lt;a href=&quot;c3ref/stmt&quot;&gt;プリペアドステートメント&lt;/a&gt;に関する情報にアクセスするSQLiteに組み込まれた&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;です。 bytecodeとtables_usedはどちらも、&lt;a href=&quot;vtab#tabfunc2&quot;&gt;テーブル値関数&lt;/a&gt;として機能します。これらは、SQLステートメントのテキスト、または既存のプリペアドステートメントへのポインターのいずれかである単一の必須引数を取ります。バイトコード関数は、プリペアドステートメントの&lt;a href=&quot;opcode&quot;&gt;バイトコード&lt;/a&gt;操作ごとに1行の結果を返します。 Tables_used関数は、プリペアドステートメントによってアクセスされる永続的なbtree（テーブルまたはインデックス）ごとに1つの行を返します。</target>
        </trans-unit>
        <trans-unit id="8e5fdab92dece79d7629d6d901687613ddc6ab5a" translate="yes" xml:space="preserve">
          <source>Bytes</source>
          <target state="translated">Bytes</target>
        </trans-unit>
        <trans-unit id="6e99d2b1b3cf05d1cb901ea3f769e34d773ba90a" translate="yes" xml:space="preserve">
          <source>Bytes 12-15 of the</source>
          <target state="translated">のバイト12~15</target>
        </trans-unit>
        <trans-unit id="89a9bc1f87191389726b0ed1804032da963a975c" translate="yes" xml:space="preserve">
          <source>Bytes 16-19 of the</source>
          <target state="translated">の16~19バイト目</target>
        </trans-unit>
        <trans-unit id="24778eba404891c29eb268fa4b3c469a05e3f5af" translate="yes" xml:space="preserve">
          <source>Bytes 20-23 of the</source>
          <target state="translated">の20~23バイト目の</target>
        </trans-unit>
        <trans-unit id="5e820fc3c84f6f51bd1f6afe4e8dd983524446cf" translate="yes" xml:space="preserve">
          <source>Bytes 24-27 of the</source>
          <target state="translated">の24~27バイト目の</target>
        </trans-unit>
        <trans-unit id="eb167d60299b524eb07991d2141957c03c9ee5cd" translate="yes" xml:space="preserve">
          <source>Bytes 8-11 of the</source>
          <target state="translated">の8~11バイト目</target>
        </trans-unit>
        <trans-unit id="a3587157a4089ec8301b2d0f784b91a32e9749e3" translate="yes" xml:space="preserve">
          <source>Bytes of unused &quot;reserved&quot; space at the end of each page. Usually 0.</source>
          <target state="translated">各ページの最後にある未使用の「予約済み」スペースのバイト数。通常は0。</target>
        </trans-unit>
        <trans-unit id="99c76b931cbafaf267cc3e2ad6a25e46605efcf6" translate="yes" xml:space="preserve">
          <source>Bytes of useful payload on the current page or btree</source>
          <target state="translated">現在のページまたは btree 上の有用なペイロードのバイト数</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="4f3cd44d015b24e6fbf168b36aa5120966aaf5ed" translate="yes" xml:space="preserve">
          <source>C API Requirements Document.</source>
          <target state="translated">C API 要件ドキュメント。</target>
        </trans-unit>
        <trans-unit id="e9a1acddb6f4bd40edd805612e996267e826e064" translate="yes" xml:space="preserve">
          <source>C Interface</source>
          <target state="translated">Cインタフェース</target>
        </trans-unit>
        <trans-unit id="d5efbb98716c6e33e7f3412795c630f8a8a66abd" translate="yes" xml:space="preserve">
          <source>C Interface: Session Module</source>
          <target state="translated">C インターフェイス。セッションモジュール</target>
        </trans-unit>
        <trans-unit id="444516d338383f2d17d8f93aa996b6cd1762c79a" translate="yes" xml:space="preserve">
          <source>C is a great language for writing fast code. C is sometimes described as &quot;portable assembly language&quot;. It enables to developers to code as close to the underlying hardware as possible while still remaining portable across platforms.</source>
          <target state="translated">C言語は高速なコードを書くのに最適な言語です。C言語は「ポータブルなアセンブリ言語」と表現されることもあります。開発者は、プラットフォーム間での移植性を維持しながら、可能な限り基盤となるハードウェアに近いコードを書くことができます。</target>
        </trans-unit>
        <trans-unit id="58790293552f75d17353d3ee29e85a197a62dcbb" translate="yes" xml:space="preserve">
          <source>C-language Interface Specification for SQLite</source>
          <target state="translated">SQLite 用 C 言語インタフェース仕様書</target>
        </trans-unit>
        <trans-unit id="1ac091b19baa70bc10c3d1156fe018d4a8f6ef6b" translate="yes" xml:space="preserve">
          <source>C-style comments are now accepted by the tokenizer.</source>
          <target state="translated">C スタイルのコメントがトークンizer で受け入れられるようになりました。</target>
        </trans-unit>
        <trans-unit id="d4948b1f21c9b5ee92aa9e005ab2ec94317e417f" translate="yes" xml:space="preserve">
          <source>C-style comments begin with &quot;/*&quot; and extend up to and including the next &quot;*/&quot; character pair or until the end of input, whichever comes first. C-style comments can span multiple lines.</source>
          <target state="translated">C スタイルのコメントは &quot;/*&quot; で始まり、次の &quot;*/&quot; 文字ペアまで、または入力終了時まで、どちらか早い方の行になります。C スタイルのコメントは複数行に渡ることができます。</target>
        </trans-unit>
        <trans-unit id="e693971cd8c5db36eaa639a8f7f4320b5c7557fd" translate="yes" xml:space="preserve">
          <source>C/C++ Interface For SQLite Version 3</source>
          <target state="translated">SQLite バージョン 3 の C/C++インターフェイス</target>
        </trans-unit>
        <trans-unit id="b7c9ebb838da580ee5ce0a6b6d3fb9492aadd0cf" translate="yes" xml:space="preserve">
          <source>C/C++ Interface For SQLite Version 3 (old)</source>
          <target state="translated">C/C++Interface For SQLite Version 3 (旧版)</target>
        </trans-unit>
        <trans-unit id="629369eadf6dbb7e5f1900a3d284a7d0ebdf8449" translate="yes" xml:space="preserve">
          <source>CASCADE</source>
          <target state="translated">CASCADE</target>
        </trans-unit>
        <trans-unit id="55c417bda058d7601349aeb7556e3d8607c77f5d" translate="yes" xml:space="preserve">
          <source>CASE</source>
          <target state="translated">CASE</target>
        </trans-unit>
        <trans-unit id="24e95e83710f86d66debac57b5addb22a9ce7983" translate="yes" xml:space="preserve">
          <source>CASE WHEN x=w1 THEN r1 WHEN x=w2 THEN r2 ELSE r3 END</source>
          <target state="translated">CASE WHEN X=W1 THEN r1 WHEN X=W2 THEN r2 ELSE r3 END</target>
        </trans-unit>
        <trans-unit id="fcb688501c6a701cda488771d9ab7d2ba8fccbb2" translate="yes" xml:space="preserve">
          <source>CASE expression</source>
          <target state="translated">ケース式</target>
        </trans-unit>
        <trans-unit id="c688feeff7f51b86a16bfff0e478b5a113fd0c4a" translate="yes" xml:space="preserve">
          <source>CASE x WHEN w1 THEN r1 WHEN w2 THEN r2 ELSE r3 END</source>
          <target state="translated">CASE x WHEN w1 THEN r1 WHEN w2 THEN r2 ELSE r3 END</target>
        </trans-unit>
        <trans-unit id="274ad8f8387ab7001d3681011456578f35fd9e46" translate="yes" xml:space="preserve">
          <source>CAST</source>
          <target state="translated">CAST</target>
        </trans-unit>
        <trans-unit id="bc9630c4f8bc64a9ad87f06d690b75d5f8954d78" translate="yes" xml:space="preserve">
          <source>CAST expressions</source>
          <target state="translated">CAST式</target>
        </trans-unit>
        <trans-unit id="2bab9f8d26cc3165f0ac936b287a5e9381a51aad" translate="yes" xml:space="preserve">
          <source>CAST operator</source>
          <target state="translated">CAST演算子</target>
        </trans-unit>
        <trans-unit id="57c58f87e406bfa72b5233a68e16e6ce57b58a9a" translate="yes" xml:space="preserve">
          <source>CHANGESET_CONFLICT is passed as the second argument to the conflict handler while processing an INSERT change if the operation would result in duplicate primary key values.</source>
          <target state="translated">CHANGESET_CONFLICTは、主キーの値が重複している場合にINSERT変更を処理する際に、コンフリクト・ハンドラの第2引数として渡されます。</target>
        </trans-unit>
        <trans-unit id="49279edf04879138e2ca01fe4da87f165bb8a556" translate="yes" xml:space="preserve">
          <source>CHAR</source>
          <target state="translated">CHAR</target>
        </trans-unit>
        <trans-unit id="ec67cd542d6d42f84f8aea6727411112c2a9eee5" translate="yes" xml:space="preserve">
          <source>CHARACTER(20)</source>
          <target state="translated">CHARACTER(20)</target>
        </trans-unit>
        <trans-unit id="d37267cb2995cccac2283009e1ea4f3a6dd37db3" translate="yes" xml:space="preserve">
          <source>CHECK</source>
          <target state="translated">CHECK</target>
        </trans-unit>
        <trans-unit id="7c8e71cdac81d935a110e970f2e16db27f75d5ec" translate="yes" xml:space="preserve">
          <source>CHECK constraint</source>
          <target state="translated">チェック制約</target>
        </trans-unit>
        <trans-unit id="91f48f96fc5990f4b552ae5c63dd0114792c0da9" translate="yes" xml:space="preserve">
          <source>CHECK constraints</source>
          <target state="translated">チェック制約</target>
        </trans-unit>
        <trans-unit id="6c581d4e90f448ac099620dc82b1bf15e3863e36" translate="yes" xml:space="preserve">
          <source>CHECK constraints use conflict resolution algorithms correctly.</source>
          <target state="translated">CHECK 制約は、紛争解決アルゴリズムを正しく使用します。</target>
        </trans-unit>
        <trans-unit id="700b401ca52b1bd3071dc838bf11be9cdb19fc5f" translate="yes" xml:space="preserve">
          <source>CLI</source>
          <target state="translated">CLI</target>
        </trans-unit>
        <trans-unit id="eb02003c667c1e9ee2fcede2fd0524e495d8ec1b" translate="yes" xml:space="preserve">
          <source>CLOB</source>
          <target state="translated">CLOB</target>
        </trans-unit>
        <trans-unit id="28248452f38e0300dc7c45ab12fbe5d41f97e047" translate="yes" xml:space="preserve">
          <source>COLLATE</source>
          <target state="translated">COLLATE</target>
        </trans-unit>
        <trans-unit id="093c8ab0d477c98bad008d7426a58810ce1d5c6c" translate="yes" xml:space="preserve">
          <source>COLLATE binary</source>
          <target state="translated">コレクトバイナリ</target>
        </trans-unit>
        <trans-unit id="114fac2d95aa36c73c87444e3e119061a6c497e8" translate="yes" xml:space="preserve">
          <source>COLLATE operator</source>
          <target state="translated">コレクト演算子</target>
        </trans-unit>
        <trans-unit id="d517243e2eae9452e340645d614bbcb6cbc92a5f" translate="yes" xml:space="preserve">
          <source>COLLATE uint</source>
          <target state="translated">COLLATE uint</target>
        </trans-unit>
        <trans-unit id="d59db8880904cdfee22d4bdd9e5cb72c42fae180" translate="yes" xml:space="preserve">
          <source>COLUMN</source>
          <target state="translated">COLUMN</target>
        </trans-unit>
        <trans-unit id="17e4d773881595e83eed7274990576cb3c33d081" translate="yes" xml:space="preserve">
          <source>COMMIT</source>
          <target state="translated">COMMIT</target>
        </trans-unit>
        <trans-unit id="b8bace9ba33552e80165d3ede409bac3b53e9442" translate="yes" xml:space="preserve">
          <source>COMMIT TRANSACTION</source>
          <target state="translated">コミットトランザクション</target>
        </trans-unit>
        <trans-unit id="5be9cfb9ef50ef7a3f4855f3a3912ced47c9cd37" translate="yes" xml:space="preserve">
          <source>COMMIT;</source>
          <target state="translated">COMMIT;</target>
        </trans-unit>
        <trans-unit id="716a4859cb65ba79cf0a75301f937ee8dd84b958" translate="yes" xml:space="preserve">
          <source>CONFLICT</source>
          <target state="translated">CONFLICT</target>
        </trans-unit>
        <trans-unit id="eb44b374436f71b41c8c59982685ea220ef821e2" translate="yes" xml:space="preserve">
          <source>CONSTRAINT</source>
          <target state="translated">CONSTRAINT</target>
        </trans-unit>
        <trans-unit id="cabc2219177d43a5c1d71e3003445f83b9a7195f" translate="yes" xml:space="preserve">
          <source>CREATE</source>
          <target state="translated">CREATE</target>
        </trans-unit>
        <trans-unit id="4dfe073e739c382b273bdf0f1bdd27e7f10f38af" translate="yes" xml:space="preserve">
          <source>CREATE INDEX</source>
          <target state="translated">CREATE INDEX</target>
        </trans-unit>
        <trans-unit id="d5c16f75a09033a1e8f65102b202f3992bcbc039" translate="yes" xml:space="preserve">
          <source>CREATE INDEX i2a ON t2(a);</source>
          <target state="translated">CREATE INDEX i2a ON t2(a).</target>
        </trans-unit>
        <trans-unit id="219d80e293971a20fc410c1cb42fe81ee5be3296" translate="yes" xml:space="preserve">
          <source>CREATE INDEX i2b ON t2(b);</source>
          <target state="translated">CREATE INDEX i2b ON t2(b).</target>
        </trans-unit>
        <trans-unit id="015ef83633db6629be0b04929a85c6e8362366cf" translate="yes" xml:space="preserve">
          <source>CREATE INDEX i3 ON t3(c);</source>
          <target state="translated">CREATE INDEX i3 ON t3(c).</target>
        </trans-unit>
        <trans-unit id="979ae29e43d609d39c91f43b7d2c9c6f0170c84c" translate="yes" xml:space="preserve">
          <source>CREATE TABLE</source>
          <target state="translated">クリエイトテーブル</target>
        </trans-unit>
        <trans-unit id="61fe1c0db27d323fd657d34129f0370eddfd6b9e" translate="yes" xml:space="preserve">
          <source>CREATE TABLE ... AS SELECT Statements</source>
          <target state="translated">CREATE TABLE ...AS SELECT ステートメント</target>
        </trans-unit>
        <trans-unit id="fdc5603516a1557309c21e74d5f3a300d7053f48" translate="yes" xml:space="preserve">
          <source>CREATE TABLE AS</source>
          <target state="translated">CREATE TABLE AS</target>
        </trans-unit>
        <trans-unit id="5c1879760c0ac0151021a298b71fc43dd31ae043" translate="yes" xml:space="preserve">
          <source>CREATE TABLE Statement</source>
          <target state="translated">CREATE TABLE ステートメント</target>
        </trans-unit>
        <trans-unit id="ef4e542d71b6fc791055be2754c8bba0c238f3b8" translate="yes" xml:space="preserve">
          <source>CREATE TABLE and DROP TABLE now work correctly as prepared statements.</source>
          <target state="translated">CREATE TABLEとDROP TABLEが準備されたステートメントとして正しく動作するようになりました。</target>
        </trans-unit>
        <trans-unit id="6a035b079a1ff283fd14f7d5c5ea363c26b68cda" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t1(a INTEGER, b INTEGER, c VARCHAR(100));</source>
          <target state="translated">CREATE TABLE t1(a INTEGER,b INTEGER,c VARCHAR(100))。</target>
        </trans-unit>
        <trans-unit id="4619a9be564e2fbde661edf547e025b44154bc1f" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t1(a, b PRIMARY KEY);</source>
          <target state="translated">CREATE TABLE t1(a,b PRIMARY KEY).</target>
        </trans-unit>
        <trans-unit id="7b5a4e879f5838c381c1aaf9522123d8eb51ef28" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t1(a, b UNIQUE);</source>
          <target state="translated">CREATE TABLE t1(a,b UNIQUE).</target>
        </trans-unit>
        <trans-unit id="472c250359f0aac3ac59d709bce28e56fc427ab7" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t1(a, b);</source>
          <target state="translated">CREATE TABLE t1(a,b).</target>
        </trans-unit>
        <trans-unit id="b180c72a56f1e353661ad8a8bf096de1e31921fa" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t1(c1 VARIANT);</source>
          <target state="translated">CREATE TABLE t1(c1 VARIANT).</target>
        </trans-unit>
        <trans-unit id="6c723a031c86a4c7b06f2a3f8d60439c8dcf6107" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t2(a INTEGER, b INTEGER, c VARCHAR(100));</source>
          <target state="translated">CREATE TABLE t2(a INTEGER,b INTEGER,c VARCHAR(100))。</target>
        </trans-unit>
        <trans-unit id="ffb49dd96e70cfeec18ece99b548162395148801" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t3(a INTEGER, b INTEGER, c VARCHAR(100));</source>
          <target state="translated">CREATE TABLE t3(a INTEGER,b INTEGER,c VARCHAR(100))。</target>
        </trans-unit>
        <trans-unit id="cf6418466d171e86053f358e78bdbbeb775f1f4f" translate="yes" xml:space="preserve">
          <source>CREATE TRIGGER</source>
          <target state="translated">CREATE TRIGGER</target>
        </trans-unit>
        <trans-unit id="4862717c14fde4c95f9fc018bad5f1bcdf240d46" translate="yes" xml:space="preserve">
          <source>CREATE UNIQUE INDEX t1b ON t1(b);</source>
          <target state="translated">CREATE UNIQUE INDEX t1b ON t1(b).</target>
        </trans-unit>
        <trans-unit id="c6d65be0664c12895eed3811d312f2344a61a809" translate="yes" xml:space="preserve">
          <source>CREATE VIEW</source>
          <target state="translated">クリエイトビュー</target>
        </trans-unit>
        <trans-unit id="d37bcac589dd2e6a2d9d1fe15b402952fac86edd" translate="yes" xml:space="preserve">
          <source>CREATE VIRTUAL TABLE</source>
          <target state="translated">CREATE VIRTUAL TABLE</target>
        </trans-unit>
        <trans-unit id="3fed731b971838462d00ae70d200fd38b7750b9e" translate="yes" xml:space="preserve">
          <source>CREATE and DROP</source>
          <target state="translated">CREATE と DROP</target>
        </trans-unit>
        <trans-unit id="7ea4fbcff919d74664df2b3abbe9c64927134ca1" translate="yes" xml:space="preserve">
          <source>CROSS</source>
          <target state="translated">CROSS</target>
        </trans-unit>
        <trans-unit id="23cb1ba2135af54bb7f9dc4ac628c8c16b1274c8" translate="yes" xml:space="preserve">
          <source>CSV export</source>
          <target state="translated">CSVエクスポート</target>
        </trans-unit>
        <trans-unit id="41b55f7f4ea3b51535ca8d9719be622b0aa72549" translate="yes" xml:space="preserve">
          <source>CSV import</source>
          <target state="translated">CSVインポート</target>
        </trans-unit>
        <trans-unit id="17e29dae877981f4c14c3c548258e66edf22daf5" translate="yes" xml:space="preserve">
          <source>CSV output from the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; now always uses CRNL for the row separator and avoids inserting CR in front of NLs contained in data.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;コマンドラインシェル&lt;/a&gt;からのCSV出力は、行セパレーターに常にCRNLを使用し、データに含まれるNLの前にCRを挿入することを回避するようになりました。</target>
        </trans-unit>
        <trans-unit id="e6303ccf1ceff324ad3a408b48244faf8b681b0a" translate="yes" xml:space="preserve">
          <source>CURRENT</source>
          <target state="translated">CURRENT</target>
        </trans-unit>
        <trans-unit id="988c655ab1a28987e3b7f4aa07b43ec2f252df71" translate="yes" xml:space="preserve">
          <source>CURRENT_DATE</source>
          <target state="translated">CURRENT_DATE</target>
        </trans-unit>
        <trans-unit id="2c91dc4d76138fb01afa917b2a5880a2ce68218e" translate="yes" xml:space="preserve">
          <source>CURRENT_TIME</source>
          <target state="translated">CURRENT_TIME</target>
        </trans-unit>
        <trans-unit id="b12c7ec3f538b492b9b7b22b81788480777716ca" translate="yes" xml:space="preserve">
          <source>CURRENT_TIME, CURRENT_DATE, and CURRENT_TIMESTAMP added</source>
          <target state="translated">CURRENT_TIME、CURRENT_DATE、CURRENT_TIMESTAMPを追加しました。</target>
        </trans-unit>
        <trans-unit id="a5fb7adeaa54144ee5b07100bdd633a9a88f29b3" translate="yes" xml:space="preserve">
          <source>CURRENT_TIMESTAMP</source>
          <target state="translated">CURRENT_TIMESTAMP</target>
        </trans-unit>
        <trans-unit id="65e385d9a3fe24f8571de75d22a480cc4676d324" translate="yes" xml:space="preserve">
          <source>CVE Number</source>
          <target state="translated">CVE番号</target>
        </trans-unit>
        <trans-unit id="356e8d51d92a4a7c252e86ea6fe14e667fc3ae1e" translate="yes" xml:space="preserve">
          <source>CVE-2019-19317</source>
          <target state="translated">CVE-2019-19317</target>
        </trans-unit>
        <trans-unit id="99f9264fe966c3479910c5d0ba83460e6e3729ad" translate="yes" xml:space="preserve">
          <source>CVE-2019-19923</source>
          <target state="translated">CVE-2019-19923</target>
        </trans-unit>
        <trans-unit id="eebebbb796152888eb988cbad61ced631a21ff64" translate="yes" xml:space="preserve">
          <source>CVE-2019-19924</source>
          <target state="translated">CVE-2019-19924</target>
        </trans-unit>
        <trans-unit id="9070593189adb897b13efec120fbe18b3b48119d" translate="yes" xml:space="preserve">
          <source>CVE-2019-19925</source>
          <target state="translated">CVE-2019-19925</target>
        </trans-unit>
        <trans-unit id="b944efa961d3a4a65106baa20c05ed67ed3d8528" translate="yes" xml:space="preserve">
          <source>CVE-2019-19926</source>
          <target state="translated">CVE-2019-19926</target>
        </trans-unit>
        <trans-unit id="23620708a776d0f4b23595664d860f1eb18db80f" translate="yes" xml:space="preserve">
          <source>CVE-2019-19959</source>
          <target state="translated">CVE-2019-19959</target>
        </trans-unit>
        <trans-unit id="9c19ca22b3ff09cd11be29de3092bac5ecbb6f72" translate="yes" xml:space="preserve">
          <source>CVE-2019-20218</source>
          <target state="translated">CVE-2019-20218</target>
        </trans-unit>
        <trans-unit id="f84119bb7976cd5a8c8919e495a1ea188c8d01ce" translate="yes" xml:space="preserve">
          <source>CVE-2020-11655</source>
          <target state="translated">CVE-2020-11655</target>
        </trans-unit>
        <trans-unit id="24bf60a79a1bdc939cd96a195c263490e183d008" translate="yes" xml:space="preserve">
          <source>CVE-2020-11656</source>
          <target state="translated">CVE-2020-11656</target>
        </trans-unit>
        <trans-unit id="b3458c87a366a597752314c96918a11badac6df6" translate="yes" xml:space="preserve">
          <source>CVE-2020-13434</source>
          <target state="translated">CVE-2020-13434</target>
        </trans-unit>
        <trans-unit id="0c64280d7ac694f06901161e2e4192059c94030d" translate="yes" xml:space="preserve">
          <source>CVE-2020-13435</source>
          <target state="translated">CVE-2020-13435</target>
        </trans-unit>
        <trans-unit id="d2142032cb8f67d47c0f692a8f43b0da8ba3dbb4" translate="yes" xml:space="preserve">
          <source>CVE-2020-13630</source>
          <target state="translated">CVE-2020-13630</target>
        </trans-unit>
        <trans-unit id="01b180dcf9513183380ef259d2b0841c4e7f77b3" translate="yes" xml:space="preserve">
          <source>CVE-2020-13631</source>
          <target state="translated">CVE-2020-13631</target>
        </trans-unit>
        <trans-unit id="2f01c703b75f4b1f7d0a5171ce82a9de250b7508" translate="yes" xml:space="preserve">
          <source>CVE-2020-13632</source>
          <target state="translated">CVE-2020-13632</target>
        </trans-unit>
        <trans-unit id="5d08b8e084f6c27e8e4b3ed9ca47f1f1232dd879" translate="yes" xml:space="preserve">
          <source>CVE-2020-13871</source>
          <target state="translated">CVE-2020-13871</target>
        </trans-unit>
        <trans-unit id="d794882b16e5e67f67cae72af337733774cdf3d1" translate="yes" xml:space="preserve">
          <source>CVE-2020-15358</source>
          <target state="translated">CVE-2020-15358</target>
        </trans-unit>
        <trans-unit id="e199336a03380b560a1ec76506edbffac71e2c63" translate="yes" xml:space="preserve">
          <source>CVE-2020-6405</source>
          <target state="translated">CVE-2020-6405</target>
        </trans-unit>
        <trans-unit id="e0e462c2ba637997a01ca062b46b08478eaea02c" translate="yes" xml:space="preserve">
          <source>CVE-2020-9327</source>
          <target state="translated">CVE-2020-9327</target>
        </trans-unit>
        <trans-unit id="58cc14935f8aae029bbfb78904497935571ef45e" translate="yes" xml:space="preserve">
          <source>CVEs (&quot;Common Vulnerabilities and Exposures&quot;) are reports of software bugs that might allow a system to be hacked. The idea behind CVEs is sound. They provide a common naming scheme whereby software bugs that might compromise information security can be easily tracked.</source>
          <target state="translated">CVE(「一般的な脆弱性と暴露」)とは、システムがハッキングされる可能性のあるソフトウェアのバグの報告です。CVE の背後にある考え方は健全です。CVEは、情報セキュリティを侵害する可能性のあるソフトウェアのバグを簡単に追跡できるように、共通の命名法を提供しています。</target>
        </trans-unit>
        <trans-unit id="51c92beb8c02d63e98c12b62c29e821871eee1bb" translate="yes" xml:space="preserve">
          <source>CVEs about SQLite probably do not apply to your use of SQLite.</source>
          <target state="translated">SQLite に関する CVE は、おそらくあなたの SQLite の使用には適用されません。</target>
        </trans-unit>
        <trans-unit id="2e3affda4e192cdf66e451e6d423b53be2042240" translate="yes" xml:space="preserve">
          <source>CVEs are a low-quality source of information about bugs in SQLite that are likely to affect most applications.</source>
          <target state="translated">CVEは、ほとんどのアプリケーションに影響を与える可能性のあるSQLiteのバグに関する低品質な情報源です。</target>
        </trans-unit>
        <trans-unit id="97154728871232f8ec1e18c7f99aae1f66258be4" translate="yes" xml:space="preserve">
          <source>Cache Validation</source>
          <target state="translated">キャッシュ検証</target>
        </trans-unit>
        <trans-unit id="243348169a35fc01acf2950edac2a8317e1d5705" translate="yes" xml:space="preserve">
          <source>Cache sharing is enabled and disabled for an entire process. This is a change as of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; (2007-09-04). In prior versions of SQLite, sharing was enabled or disabled for each thread separately.</source>
          <target state="translated">キャッシュ共有は、プロセス全体で有効または無効になります。これはSQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;バージョン3.5.0&lt;/a&gt;（2007-09-04）からの変更です。SQLiteの以前のバージョンでは、共有はスレッドごとに個別に有効または無効にされていました。</target>
        </trans-unit>
        <trans-unit id="dfad78f93ed55c3b8305d2de17eb36b19e276c8b" translate="yes" xml:space="preserve">
          <source>Call sqlite3_reset() on the statement handle. Since an SQLITE_LOCKED error may only occur on the first call to sqlite3_step() (it is not possible for one call to sqlite3_step() to return SQLITE_ROW and then the next SQLITE_LOCKED), the statement handle may be reset at this point without affecting the results of the query from the point of view of the caller. If sqlite3_reset() were not called at this point, the next call to sqlite3_step() would return SQLITE_MISUSE.</source>
          <target state="translated">文ハンドルでsqlite3_reset()を呼び出してください。SQLITE_LOCKEDエラーはsqlite3_step()の最初の呼び出しでのみ発生する可能性があるので(sqlite3_step()の1回の呼び出しでSQLITE_ROWを返し、次の呼び出しでSQLITE_LOCKEDを返すことは不可能です)、呼び出し元から見て問い合わせの結果に影響を与えることなく、この時点で文ハンドルをリセットすることができます。この時点でsqlite3_reset()が呼ばれなかった場合、次のsqlite3_step()の呼び出しはSQLITE_MISUSEを返します。</target>
        </trans-unit>
        <trans-unit id="e7253d4d62ac064583560f235c4dc54e68e830f1" translate="yes" xml:space="preserve">
          <source>Call sqlite3_step() on the supplied statement handle. If the call returns anything other than SQLITE_LOCKED, then return this value to the caller. Otherwise, continue.</source>
          <target state="translated">与えられたステートメントハンドル上でsqlite3_step()を呼び出します。呼び出しがSQLITE_LOCKED以外の値を返した場合は、この値を呼び出し元に返します。それ以外の場合は続行します。</target>
        </trans-unit>
        <trans-unit id="ac89c336f7b9f31230fa306e89f0a63e33ec5741" translate="yes" xml:space="preserve">
          <source>Call sqlite3rbu_close(X) to destroy the sqlite3rbu object pointer. If sqlite3rbu_step(X) has been called enough times to completely apply the update to the target database, then the RBU database is marked as fully applied. Otherwise, the state of the RBU update application is saved in the state database (or in the RBU database if the name of the state database file in sqlite3rbu_open() is NULL) for later resumption of the update.</source>
          <target state="translated">sqlite3rbuオブジェクト・ポインタを破棄するためにsqlite3rbu_close(X)を呼び出します。sqlite3rbu_step(X)がターゲット・データベースに更新を完全に適用するのに十分な回数呼び出された場合、RBUデータベースは完全に適用されたものとしてマークされます。そうでなければ、RBU更新アプリケーションの状態は、後で更新を再開するために、状態データベースに保存されます(sqlite3rbu_open()の状態データベースファイル名がNULLの場合はRBUデータベースに保存されます)。</target>
        </trans-unit>
        <trans-unit id="f4cfaf571c0396d88e7a8a5942129605eebc5000" translate="yes" xml:space="preserve">
          <source>Call the table named by the &lt;a href=&quot;syntax/cte-table-name&quot;&gt;cte-table-name&lt;/a&gt; in a recursive common table expression the &quot;recursive table&quot;. In the &lt;a href=&quot;syntax/recursive-cte&quot;&gt;recursive-cte&lt;/a&gt; bubble diagram above, the recursive table must appear exactly once in the FROM clause of the recursive-select and must not appear anywhere else in either the initial-select or the recursive-select, including subqueries. The initial-select may be a &lt;a href=&quot;lang_select#compound&quot;&gt;compound select&lt;/a&gt;, but it may not include an ORDER BY, LIMIT, or OFFSET. The recursive-select must be a simple select, not a compound. The recursive-select is allowed to include an ORDER BY, LIMIT, and/or OFFSET.</source>
          <target state="translated">指定されたテーブル呼び出し&lt;a href=&quot;syntax/cte-table-name&quot;&gt;CTE-table-nameの&lt;/a&gt;再帰共通テーブル式「再帰テーブル」にします。上記の&lt;a href=&quot;syntax/recursive-cte&quot;&gt;recursive-cte&lt;/a&gt;バブル図では、再帰的テーブルは、再帰的選択のFROM句に1回だけ出現し、initial-selectまたはrecursive-selectのほかのサブクエリを含むどこにも出現してはなりません。 initial-selectには&lt;a href=&quot;lang_select#compound&quot;&gt;複合selectを使用できます&lt;/a&gt;が、ORDER BY、LIMIT、またはOFFSETを含めることはできません。再帰的選択は、複合ではなく単純な選択でなければなりません。再帰選択には、ORDER BY、LIMIT、OFFSETを含めることができます。</target>
        </trans-unit>
        <trans-unit id="42fb639b7313463881ed7d9bae34cc709237f03b" translate="yes" xml:space="preserve">
          <source>Callback</source>
          <target state="translated">Callback</target>
        </trans-unit>
        <trans-unit id="fc3110a84b56463b6ac2be236d2d0ee212bb9db8" translate="yes" xml:space="preserve">
          <source>Calling sqlite3_auto_extension(X) with an entry point X that is already on the list of automatic extensions is a harmless no-op. No entry point will be called more than once for each database connection that is opened.</source>
          <target state="translated">すでに自動拡張のリストにあるエントリポイントXでsqlite3_auto_extension(X)を呼び出すことは、無害なノーオペです。開かれたデータベース接続ごとに複数回呼び出されることはありません。</target>
        </trans-unit>
        <trans-unit id="fdd02e84dcaceaea19448095c3e09a162e5292ae" translate="yes" xml:space="preserve">
          <source>Calling sqlite3_free() with a pointer previously returned by sqlite3_malloc() or sqlite3_realloc() releases that memory so that it might be reused. The sqlite3_free() routine is a no-op if is called with a NULL pointer. Passing a NULL pointer to sqlite3_free() is harmless. After being freed, memory should neither be read nor written. Even reading previously freed memory might result in a segmentation fault or other severe error. Memory corruption, a segmentation fault, or other severe error might result if sqlite3_free() is called with a non-NULL pointer that was not obtained from sqlite3_malloc() or sqlite3_realloc().</source>
          <target state="translated">sqlite3_malloc()やsqlite3_realloc()で以前に返されたポインタでsqlite3_free()を呼び出すと、そのメモリを解放して再利用できるようにします。sqlite3_free()ルーチンはNULLポインタを指定して呼ばれた場合は実行しません。sqlite3_free()にNULLポインタを渡すことは無害です。解放された後は、メモリを読み書きしてはいけません。解放された後は、メモリを読み込んだり書き込んだりしてはいけません。解放された後にメモリを読み込んでも、セグメンテーション・フォールトやその他の重大なエラーが発生する可能性があります。sqlite3_malloc()やsqlite3_realloc()で取得したものではないNULLではないポインタでsqlite3_free()を呼び出すと、メモリ破壊やセグメンテーション・フォールト、その他の深刻なエラーが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="3358427e1a8ed1bea8f5a2ad2f5555efabc90a34" translate="yes" xml:space="preserve">
          <source>Calling this function with an argument that is not a NULL pointer or an open blob handle results in undefined behaviour. Calling this routine with a null pointer (such as would be returned by a failed call to &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt;) is a harmless no-op. Otherwise, if this function is passed a valid open blob handle, the values returned by the sqlite3_errcode() and sqlite3_errmsg() functions are set before returning.</source>
          <target state="translated">NULLポインターまたは開いているblobハンドルではない引数を指定してこの関数を呼び出すと、動作が未定義になります。 nullポインターを使用してこのルーチンを呼び出す（&lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open（）の&lt;/a&gt;呼び出しが失敗した場合に返されるなど）と、無害な何もしません。それ以外の場合、この関数に有効なオープンBLOBハンドルが渡されると、sqlite3_errcode（）およびsqlite3_errmsg（）関数によって返される値は、戻る前に設定されます。</target>
        </trans-unit>
        <trans-unit id="508bbd8f844cc227cec9347e436cbdd9ffc04285" translate="yes" xml:space="preserve">
          <source>Calling this function with an argument that is not a NULL pointer or an open blob handle results in undefined behaviour. Calling this routine with a null pointer (such as would be returned by a failed call to &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt;) is a harmless no-op. Otherwise, if this function is passed a valid open blob handle, the values returned by the sqlite3_errcode() and sqlite3_errmsg() functions are set before returning.</source>
          <target state="translated">NULLポインターまたは開いているblobハンドルではない引数を指定してこの関数を呼び出すと、動作が未定義になります。 nullポインターを使用してこのルーチンを呼び出す（&lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open（）の&lt;/a&gt;呼び出しが失敗した場合に返されるなど）と、無害な何もしません。それ以外の場合、この関数に有効なオープンBLOBハンドルが渡されると、sqlite3_errcode（）およびsqlite3_errmsg（）関数によって返される値は、戻る前に設定されます。</target>
        </trans-unit>
        <trans-unit id="64d7627e8fc4bb3206a4244a29e5baede1745ef4" translate="yes" xml:space="preserve">
          <source>Calling this routine with an argument less than or equal to zero turns off all busy handlers.</source>
          <target state="translated">ゼロ以下の引数でこのルーチンを呼び出すと、すべてのビジー・ハンドラがオフになります。</target>
        </trans-unit>
        <trans-unit id="f8f92cf7b8aea43c60bffe0c687691a21c0c3628" translate="yes" xml:space="preserve">
          <source>Calls of the form &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;(db,SQLITE_VTAB_CONSTRAINT_SUPPORT,X) are supported, where X is an integer. If X is zero, then the &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; whose &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; or &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method invoked &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; does not support constraints. In this configuration (which is the default) if a call to the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, then the entire statement is rolled back as if &lt;a href=&quot;lang_conflict&quot;&gt;OR ABORT&lt;/a&gt; had been specified as part of the users SQL statement, regardless of the actual ON CONFLICT mode specified.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;（db、SQLITE_VTAB_CONSTRAINT_SUPPORT、X）という形式の呼び出しがサポートされています。Xは整数です。 Xがゼロの場合、&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;または&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;メソッドが&lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config（）を&lt;/a&gt;呼び出した&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;は制約をサポートしません。呼び出した場合（デフォルト）この構成で&lt;a href=&quot;vtab#xupdate&quot;&gt;のXUpdate&lt;/a&gt;メソッドが返す&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINTを&lt;/a&gt;、その後、文全体がロールバックかのように&lt;a href=&quot;lang_conflict&quot;&gt;OR ABORTは&lt;/a&gt;、ユーザーのSQL文の一部として指定されていたにかかわらず、実際のON CONFLICTモードの指定。</target>
        </trans-unit>
        <trans-unit id="34ad152047e6215f524688d715005c8597525fd4" translate="yes" xml:space="preserve">
          <source>Calls of the form &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;(db,SQLITE_VTAB_DIRECTONLY) from within the the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; methods of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implmentation prohibits that virtual table from being used from within triggers and views.</source>
          <target state="translated">&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;実装の&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;または&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;メソッド内から&lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;（db、SQLITE_VTAB_DIRECTONLY）の形式で呼び出すと、トリガーおよびビュー内から仮想テーブルを使用できなくなります。</target>
        </trans-unit>
        <trans-unit id="8b0bba808ff71be3f5e68d5dc5e9c1b43f075395" translate="yes" xml:space="preserve">
          <source>Calls of the form &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;(db,SQLITE_VTAB_INNOCUOUS) from within the the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; methods of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implmentation identify that virtual table as being safe to use from within triggers and views. Conceptually, the SQLITE_VTAB_INNOCUOUS tag means that the virtual table can do no serious harm even if it is controlled by a malicious hacker. Developers should avoid setting the SQLITE_VTAB_INNOCUOUS flag unless absolutely necessary.</source>
          <target state="translated">&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;実装の&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;または&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;メソッド内から&lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;（db、SQLITE_VTAB_INNOCUOUS）の形式を呼び出すと、その仮想テーブルがトリガーおよびビュー内から安全に使用できることが識別されます。概念的には、SQLITE_VTAB_INNOCUOUSタグは、悪意のあるハッカーによって制御されている場合でも、仮想テーブルが深刻な害を及ぼすことはないことを意味します。開発者は、どうしても必要な場合を除いて、SQLITE_VTAB_INNOCUOUSフラグを設定しないでください。</target>
        </trans-unit>
        <trans-unit id="9cd59c58ce5ea212cbfa095730fc7d7c0c018f0a" translate="yes" xml:space="preserve">
          <source>Calls of the form &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;(db,SQLITE_VTAB_CONSTRAINT_SUPPORT,X) are supported, where X is an integer. If X is zero, then the &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; whose &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; or &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method invoked &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; does not support constraints. In this configuration (which is the default) if a call to the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method returns &lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, then the entire statement is rolled back as if &lt;a href=&quot;../lang_conflict&quot;&gt;OR ABORT&lt;/a&gt; had been specified as part of the users SQL statement, regardless of the actual ON CONFLICT mode specified.</source>
          <target state="translated">&lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;（db、SQLITE_VTAB_CONSTRAINT_SUPPORT、X）という形式の呼び出しがサポートされています。Xは整数です。 Xがゼロの場合、&lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;または&lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;メソッドが&lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config（）を&lt;/a&gt;呼び出した&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;は制約をサポートしません。呼び出した場合（デフォルト）この構成で&lt;a href=&quot;../vtab#xupdate&quot;&gt;のXUpdate&lt;/a&gt;メソッドが返す&lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINTを&lt;/a&gt;、その後、文全体がロールバックかのように&lt;a href=&quot;../lang_conflict&quot;&gt;OR ABORTは&lt;/a&gt;、ユーザーのSQL文の一部として指定されていたにかかわらず、実際のON CONFLICTモードの指定。</target>
        </trans-unit>
        <trans-unit id="0d15b922d29010ebd3f4c6c25124e15853e06a0d" translate="yes" xml:space="preserve">
          <source>Calls of the form &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;(db,SQLITE_VTAB_DIRECTONLY) from within the the &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; methods of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implmentation prohibits that virtual table from being used from within triggers and views.</source>
          <target state="translated">&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;実装の&lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;または&lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;メソッド内から&lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;（db、SQLITE_VTAB_DIRECTONLY）の形式で呼び出すと、トリガーおよびビュー内から仮想テーブルを使用できなくなります。</target>
        </trans-unit>
        <trans-unit id="015012a4348dd0949483c59bb10d1f9a584347cd" translate="yes" xml:space="preserve">
          <source>Calls of the form &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;(db,SQLITE_VTAB_INNOCUOUS) from within the the &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; methods of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implmentation identify that virtual table as being safe to use from within triggers and views. Conceptually, the SQLITE_VTAB_INNOCUOUS tag means that the virtual table can do no serious harm even if it is controlled by a malicious hacker. Developers should avoid setting the SQLITE_VTAB_INNOCUOUS flag unless absolutely necessary.</source>
          <target state="translated">&lt;a href=&quot;../vtab&quot;&gt;仮想テーブル&lt;/a&gt;実装の&lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;または&lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;メソッド内から&lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;（db、SQLITE_VTAB_INNOCUOUS）の形式を呼び出すと、その仮想テーブルがトリガーおよびビュー内から安全に使用できることが識別されます。概念的には、SQLITE_VTAB_INNOCUOUSタグは、悪意のあるハッカーによって制御されている場合でも、仮想テーブルが深刻な害を及ぼすことはないことを意味します。開発者は、どうしても必要な場合を除いて、SQLITE_VTAB_INNOCUOUSフラグを設定しないでください。</target>
        </trans-unit>
        <trans-unit id="86477778aa30209993df2ed08e9c32fc5e63a6fa" translate="yes" xml:space="preserve">
          <source>Calls to sqlite3_db_config() return SQLITE_OK if and only if the call is considered successful.</source>
          <target state="translated">sqlite3_db_config()への呼び出しは、呼び出しが成功したとみなされた場合にのみSQLITE_OKを返します。</target>
        </trans-unit>
        <trans-unit id="98e68b9f843bbc24802b164860be76398c7c74b1" translate="yes" xml:space="preserve">
          <source>Can I use SQLite in my commercial product without paying royalties?</source>
          <target state="translated">商用製品でロイヤリティを払わずにSQLiteを使用することはできますか?</target>
        </trans-unit>
        <trans-unit id="a99feeb9b762e6e46c563375f506a5cca89929e5" translate="yes" xml:space="preserve">
          <source>Can multiple applications or multiple instances of the same application access a single database file at the same time?</source>
          <target state="translated">複数のアプリケーション、または同じアプリケーションの複数のインスタンスが同時に1つのデータベースファイルにアクセスすることはできますか?</target>
        </trans-unit>
        <trans-unit id="1d85ae4c67a45ca5f093c8517be6998fccbe1b6b" translate="yes" xml:space="preserve">
          <source>Cancel Automatic Extension Loading</source>
          <target state="translated">自動延長の読み込みをキャンセル</target>
        </trans-unit>
        <trans-unit id="0f1e2a9d130c394f768ce03af8c9cfdba772362c" translate="yes" xml:space="preserve">
          <source>Capture Changes Using Triggers</source>
          <target state="translated">トリガーを使用して変更をキャプチャする</target>
        </trans-unit>
        <trans-unit id="8d319a418b8f56b5238017081c3f614d4e2d2c3a" translate="yes" xml:space="preserve">
          <source>Carray($PTR,$N) is a &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; with a single column (named &quot;value&quot;) and zero or more rows. The &quot;value&quot; of each row in the carray() is taken from a C-language array that is $N elements long. $PTR is a pointer to the beginning of the array. In this way, the carray() function provides a convenient mechanism to bind C-language arrays to SQL queries.</source>
          <target state="translated">Carray（$ PTR、$ N）は、単一の列（「値」という名前）と0個以上の行を持つ&lt;a href=&quot;vtab#tabfunc2&quot;&gt;テーブル値関数&lt;/a&gt;です。carray（）の各行の「値」は、$ N要素の長さのC言語配列から取得されます。$ PTRは、配列の先頭へのポインターです。このように、carray（）関数は、C言語の配列をSQLクエリにバインドするための便利なメカニズムを提供します。</target>
        </trans-unit>
        <trans-unit id="8c3b32ddf313031d687668680d0df3a761eedc08" translate="yes" xml:space="preserve">
          <source>Case-folding is only performed for ASCII characters. So while &quot;A&quot; and &quot;a&quot; are considered to be equivalent, &quot;&amp;Atilde;&quot; and &quot;&amp;atilde;&quot; are distinct.</source>
          <target state="translated">大文字小文字変換は、ASCII文字に対してのみ実行されます。したがって、「A」と「a」は同等と見なされますが、「&amp;Atilde;」と「&amp;atilde;」は区別されます。</target>
        </trans-unit>
        <trans-unit id="ddb2cf0a81747a42bb2a318554bfc6f3310b70d2" translate="yes" xml:space="preserve">
          <source>Case-insensitive matching of Unicode characters does not work.</source>
          <target state="translated">Unicode 文字の大文字小文字を区別しないマッチングが機能しない。</target>
        </trans-unit>
        <trans-unit id="4a24bc7f7fc1b1e11b0cb6ad38cd14985ad78efd" translate="yes" xml:space="preserve">
          <source>Cases in which the underlying content table has an explicit INTEGER PRIMARY KEY column are slightly more difficult, as the text values stored in the rbu_control column are slightly different for the FTS index and its underlying content table. For the underlying content table, a character must be included in any rbu_control text values for the explicit IPK, but for the FTS table itself, which has an implicit rowid, it should not. This is inconvenient, but can be solved using a more complicated view, as follows:</source>
          <target state="translated">基底コンテンツ・テーブルが明示的なINTEGER PRIMARY KEYカラムを持つ場合は、FTSインデックスとその基底コンテンツ・テーブルでは、rbu_controlカラムに格納されるテキスト値が若干異なるため、少し難しくなります。基底となるコンテンツ・テーブルの場合、明示的なIPKのためのrbu_controlテキスト値には文字が含まれていなければなりませんが、暗黙的なrowidを持つFTSテーブル自体の場合は含まれてはなりません。これは不便ですが、以下のように、より複雑なビューを使用して解決することができます。</target>
        </trans-unit>
        <trans-unit id="6d2fbd5980d329d5d6af3be31953582204f59e3e" translate="yes" xml:space="preserve">
          <source>Cases where a query against a WAL-mode database can return &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; include the following:</source>
          <target state="translated">WALモードのデータベースに対するクエリが&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;を返す可能性があるのは、次のような場合です。</target>
        </trans-unit>
        <trans-unit id="15a2b7aaa72451fad3138411af4836bb6aea25de" translate="yes" xml:space="preserve">
          <source>Cases where the page-sizes of database pInMemory and zFilename are different could be handled better.</source>
          <target state="translated">データベースの pInMemory と zFilename のページサイズが異なる場合の対応を改善した。</target>
        </trans-unit>
        <trans-unit id="60745aef336b682ec827697b3e47b80c7d7555b3" translate="yes" xml:space="preserve">
          <source>Cast</source>
          <target state="translated">Cast</target>
        </trans-unit>
        <trans-unit id="8e96ef594fff82e127e63864e75e54aa6b53b266" translate="yes" xml:space="preserve">
          <source>Casting a REAL or INTEGER value to NUMERIC is a no-op, even if a real value could be losslessly converted to an integer.</source>
          <target state="translated">REAL や INTEGER の値を NUMERIC にキャストすることは、たとえ実数をロスなく整数に変換できたとしても、実行できません。</target>
        </trans-unit>
        <trans-unit id="383678fdbb040838c4ceb85e8d73bcffcce4db9f" translate="yes" xml:space="preserve">
          <source>Casting a TEXT or BLOB value into NUMERIC yields either an INTEGER or a REAL result. If the input text looks like an integer (there is no decimal point nor exponent) and the value is small enough to fit in a 64-bit signed integer, then the result will be INTEGER. Input text that looks like floating point (there is a decimal point and/or an exponent) and the text describes a value that can be losslessly converted back and forth between IEEE 754 64-bit float and a 51-bit signed integer, then the result is INTEGER. (In the previous sentence, a 51-bit integer is specified since that is one bit less than the length of the mantissa of an IEEE 754 64-bit float and thus provides a 1-bit of margin for the text-to-float conversion operation.) Any text input that describes a value outside the range of a 64-bit signed integer yields a REAL result.</source>
          <target state="translated">TEXT や BLOB の値を NUMERIC にキャストすると、INTEGER か REAL のどちらかの結果が得られます。入力テキストが整数のように見えて(小数点も指数もない)、値が 64 ビットの符号付き整数に収まるほど小さい場合、結果は INTEGER になります。入力テキストが浮動小数点のように見え(小数点および/または指数がある)、そのテキストがIEEE 754の64ビット浮動小数点と51ビット符号付き整数の間でロスレスに前後に変換できる値を記述している場合、結果はINTEGERになります。(前の文では51ビットの整数を指定していますが、これはIEEE 754 64ビットフロートの正接の長さよりも1ビット小さいため、テキストからフロートへの変換操作に1ビットのマージンを与えるためです)。64ビット符号付き整数の範囲外の値を記述したテキスト入力は、REALの結果を返します。</target>
        </trans-unit>
        <trans-unit id="6f9cada34f4e450b6e71343e035a2f6e0689a6ef" translate="yes" xml:space="preserve">
          <source>Casting a value to a type-name with no affinity causes the value to be converted into a BLOB. Casting to a BLOB consists of first casting the value to TEXT in the &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;encoding&lt;/a&gt; of the database connection, then interpreting the resulting byte sequence as a BLOB instead of as TEXT.</source>
          <target state="translated">アフィニティのないtype-nameに値をキャストすると、値がBLOBに変換されます。BLOBへのキャストは、まずデータベース接続の&lt;a href=&quot;pragma#pragma_encoding&quot;&gt;エンコード&lt;/a&gt;で値をTEXTにキャストし、次に結果のバイトシーケンスをTEXTではなくBLOBとして解釈することで構成されます。</target>
        </trans-unit>
        <trans-unit id="6fddff049ee62a8963c9618826e1a03cc952e4f9" translate="yes" xml:space="preserve">
          <source>Casting an INTEGER or REAL value into TEXT renders the value as if via &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; except that the resulting TEXT uses the &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;encoding&lt;/a&gt; of the database connection.</source>
          <target state="translated">INTEGERまたはREAL値をTEXTにキャストすると、結果のTEXT がデータベース接続の&lt;a href=&quot;pragma#pragma_encoding&quot;&gt;エンコーディング&lt;/a&gt;を使用することを除いて、&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;経由であるかのように値がレンダリングされます。</target>
        </trans-unit>
        <trans-unit id="250b5faac42b62665141b9500e3ff0cde556b9c8" translate="yes" xml:space="preserve">
          <source>Casual readers are not expected to understand all of these rules. A key take-away from this section is that the rules for determining when query flatting is safe and when it is unsafe are subtle and complex. There have been multiple bugs over the years caused by over-aggressive query flattening. On the other hand, performance of complex queries and/or queries involving views tends to suffer if query flattening is more conservative.</source>
          <target state="translated">カジュアルな読者は、これらのルールのすべてを理解することは期待していません。このセクションで重要なことは、クエリフラット化が安全な場合と安全でない場合を判断するためのルールは、微妙で複雑であるということです。クエリのフラット化を過度に攻撃的に行うことによって引き起こされたバグは、長年に渡って複数発生しています。一方で、複雑なクエリやビューを含むクエリのパフォーマンスは、 クエリフラット化をより保守的に行うと低下する傾向にあります。</target>
        </trans-unit>
        <trans-unit id="8907a1b62f0f750985eefc9ce844fea83efeb9a9" translate="yes" xml:space="preserve">
          <source>Cause precompiled statements to expire. When an expired statement is executed using sqlite3_step() it will either automatically reprepare itself (if it was originally created using sqlite3_prepare_v2()) or it will fail with SQLITE_SCHEMA.</source>
          <target state="translated">プリコンパイルされたステートメントを期限切れにします。期限切れのステートメントがsqlite3_step()を使用して実行されると、自動的に(元々sqlite3_prepare_v2()を使用して作成されていた場合)自分自身を再準備するか、SQLITE_SCHEMAで失敗するかのいずれかになります。</target>
        </trans-unit>
        <trans-unit id="a305305010fac4c32d5e753f973a3552e1f13215" translate="yes" xml:space="preserve">
          <source>Causes the customer.cust_addr field to be updated for a specific customer entry that has customer.cust_id equal to the $cust_id parameter. Note how the values assigned to the view are made available as field in the special &quot;NEW&quot; table within the trigger body.</source>
          <target state="translated">customer.cust_idが$cust_idパラメータと等しい customer.cust_idを持つ特定の顧客エントリのために customer.cust_addrフィールドが更新されるようにします。ビューに割り当てられた値が、トリガー本体内の特別な &quot;NEW &quot;テーブルのフィールドとして利用可能になる方法に注意してください。</target>
        </trans-unit>
        <trans-unit id="dbad4a6e3280246beefd6847d2978b258b3988cb" translate="yes" xml:space="preserve">
          <source>Cautions On The Use Of BEFORE triggers</source>
          <target state="translated">BEFOREトリガの使用上の注意点</target>
        </trans-unit>
        <trans-unit id="b150cf72e99af84282f28eb7200853b8c0ee4cf4" translate="yes" xml:space="preserve">
          <source>Caveats And Bugs</source>
          <target state="translated">警告とバグ</target>
        </trans-unit>
        <trans-unit id="ff583586588dbe1c7f2b18104da572d7a5f33f25" translate="yes" xml:space="preserve">
          <source>Celebrating the SQLite &quot;</source>
          <target state="translated">祝SQLite &quot;</target>
        </trans-unit>
        <trans-unit id="59bd6eed6ef43faee3a8233d127e632eb210e7f2" translate="yes" xml:space="preserve">
          <source>Cell content is stored in the cell content region of the b-tree page. SQLite strives to place cells as far toward the end of the b-tree page as it can, in order to leave space for future growth of the cell pointer array. The area in between the last cell pointer array entry and the beginning of the first cell is the unallocated region.</source>
          <target state="translated">セルの内容は、b-tree ページのセル内容領域に格納されます。SQLite では、セルポインタ配列を将来的に成長させるためのスペースを残すために、できる限り b-tree ページの最後の方にセルを配置するように努力しています。セルポインタ配列の最後のエントリと最初のセルの先頭の間の領域が未割り当て領域です。</target>
        </trans-unit>
        <trans-unit id="3b0cca36895145060f4680c61a83b1cba94677a3" translate="yes" xml:space="preserve">
          <source>Cell format summary</source>
          <target state="translated">セル形式の概要</target>
        </trans-unit>
        <trans-unit id="7ba571bb64ab9af59eb4c60e06ccece4c22b6946" translate="yes" xml:space="preserve">
          <source>Cell payload</source>
          <target state="translated">セルペイロード</target>
        </trans-unit>
        <trans-unit id="4467e902ad5ceab8af5cb553065bb45a1d9e0f01" translate="yes" xml:space="preserve">
          <source>Change &lt;a href=&quot;cli#arinsup&quot;&gt;--update option&lt;/a&gt; in the &lt;a href=&quot;cli#sqlar&quot;&gt;.archive command&lt;/a&gt; so that it skips files that are already in the archive and are unchanged. Add the new --insert option that works like --update used to work.</source>
          <target state="translated">&lt;a href=&quot;cli#sqlar&quot;&gt;.archiveコマンドの&lt;/a&gt;&lt;a href=&quot;cli#arinsup&quot;&gt;--updateオプション&lt;/a&gt;を変更して、アーカイブに既に存在し、変更されていないファイルをスキップするようにします。以前使用されていた--updateのように機能する新しい--insertオプションを追加します。</target>
        </trans-unit>
        <trans-unit id="f2cdcfee54f6e63221834526df456ae33f4748c1" translate="yes" xml:space="preserve">
          <source>Change &lt;a href=&quot;compile#default_pcache_initsz&quot;&gt;SQLITE_DEFAULT_PCACHE_INITSZ&lt;/a&gt; from 100 to 20, for improved performance.</source>
          <target state="translated">パフォーマンスを改善するために、&lt;a href=&quot;compile#default_pcache_initsz&quot;&gt;SQLITE_DEFAULT_PCACHE_INITSZ&lt;/a&gt;を100から20に変更します。</target>
        </trans-unit>
        <trans-unit id="89533c2ad87297c6b1814e96c92819fffab5d853" translate="yes" xml:space="preserve">
          <source>Change both unix and windows &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; to report a sector size of 4096 instead of the old default of 512.</source>
          <target state="translated">UNIXとWindowsの両方の&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;を変更して、以前のデフォルトの512ではなく、4096のセクターサイズを報告します。</target>
        </trans-unit>
        <trans-unit id="a9b62dcab530abf089ef055d542c538c769edd17" translate="yes" xml:space="preserve">
          <source>Change counter</source>
          <target state="translated">カウンターの変更</target>
        </trans-unit>
        <trans-unit id="78284963454462cded2891e165a76967ce7ebecf" translate="yes" xml:space="preserve">
          <source>Change in Default Page Size in SQLite Version 3.12.0</source>
          <target state="translated">SQLite バージョン 3.12.0 でのデフォルトページサイズの変更</target>
        </trans-unit>
        <trans-unit id="8ef7213e575119b9063a9829bf0081766983433e" translate="yes" xml:space="preserve">
          <source>Change log</source>
          <target state="translated">チェンジログ</target>
        </trans-unit>
        <trans-unit id="a9b88ee2ce690ee5c74f615e035bfd14907be3b4" translate="yes" xml:space="preserve">
          <source>Change tclsqlite.c to use the Tcl_Obj interface</source>
          <target state="translated">tclsqlite.cをTcl_Objインタフェースを使用するように変更します。</target>
        </trans-unit>
        <trans-unit id="c9502e13b89a0e998e0002cc9dd2ac28edd6e8ea" translate="yes" xml:space="preserve">
          <source>Change the &lt;a href=&quot;lemon&quot;&gt;Lemon&lt;/a&gt; source code to avoid calling C-library functions that OpenBSD considers dangerous. (Ex: sprintf).</source>
          <target state="translated">&lt;a href=&quot;lemon&quot;&gt;レモンの&lt;/a&gt;ソースコードを変更して、OpenBSDが危険だと見なしているCライブラリ関数を呼び出さないようにします。（例：sprintf）。</target>
        </trans-unit>
        <trans-unit id="5d77baa02e54aeb22b238c0441152b1e5304decd" translate="yes" xml:space="preserve">
          <source>Change the &lt;a href=&quot;tempfiles#tempdir&quot;&gt;temporary directory search algorithm&lt;/a&gt; on Unix to allow directories with write and execute permission, but without read permission, to serve as temporary directories. Apply this same standard to the &quot;.&quot; fallback directory.</source>
          <target state="translated">Unix の&lt;a href=&quot;tempfiles#tempdir&quot;&gt;一時ディレクトリ検索アルゴリズム&lt;/a&gt;を変更して、書き込みと実行の権限を持つが、読み取り権限のないディレクトリが一時ディレクトリとして機能できるようにします。同じ基準を「。」に適用します。フォールバックディレクトリ。</target>
        </trans-unit>
        <trans-unit id="ddfd791371cc9a6cd54b126954447b1ad9112604" translate="yes" xml:space="preserve">
          <source>Change the &lt;b&gt;sqlite&lt;/b&gt; program so that it can read databases for which it lacks write permission. (It used to refuse all access if it could not write.)</source>
          <target state="translated">&lt;b&gt;sqlite&lt;/b&gt;プログラムを変更して、書き込み権限のないデータベースを読み取れるようにします。（以前は書き込みができなかった場合、すべてのアクセスを拒否していました。）</target>
        </trans-unit>
        <trans-unit id="cbf993184d73b432fd33a6a4967c4e16c588f384" translate="yes" xml:space="preserve">
          <source>Change the code so that version 2.1.1 databases that were rendered unreadable by the above bug can be read by this version of the library even though the SQLITE_MASTER table is (slightly) corrupted.</source>
          <target state="translated">SQLITE_MASTERテーブルが(わずかに)破損していても、上記のバグで読めなくなったバージョン2.1.1のデータベースが、このバージョンのライブラリで読めるようにコードを変更しました。</target>
        </trans-unit>
        <trans-unit id="1b2c3ec73b516454d30b27549240c5be169d57e9" translate="yes" xml:space="preserve">
          <source>Change the datatype of SrcList.nSrc from type u8 to type int to work around an issue in the C compiler on AIX.</source>
          <target state="translated">AIX上のCコンパイラの問題を回避するため、SrcList.nSrcのデータ型をu8型からint型に変更しました。</target>
        </trans-unit>
        <trans-unit id="03b6774f351d6b79789eab0049e6b7dfa776c60c" translate="yes" xml:space="preserve">
          <source>Change the format of data records so that records up to 16MB in size can be stored.</source>
          <target state="translated">データレコードのフォーマットを変更し、16MBまでのレコードを保存できるようにします。</target>
        </trans-unit>
        <trans-unit id="cb9d727fc495b196f0a9e9dcf746f3b21fc8137d" translate="yes" xml:space="preserve">
          <source>Change the format of indices to allow for better query optimization.</source>
          <target state="translated">インデックスのフォーマットを変更して、より良いクエリ最適化ができるようにします。</target>
        </trans-unit>
        <trans-unit id="5c9b7b0951ce0a0f4a0c1e9e79102e0b6bc620be" translate="yes" xml:space="preserve">
          <source>Change the format of indices to correct a design flaw the originated with version 2.1.0. *** This is an incompatible file format change *** When version 2.6.0 or later of the library attempts to open a database file created by version 2.5.6 or earlier, it will automatically and irreversibly convert the file format. &lt;b&gt;Make backup copies of older database files before opening them with version 2.6.0 of the library.&lt;/b&gt;</source>
          <target state="translated">インデックスの形式を変更して、バージョン2.1.0に起因する設計上の欠陥を修正します。 ***これは互換性のないファイル形式の変更です***ライブラリのバージョン2.6.0以降がバージョン2.5.6以前で作成されたデータベースファイルを開こうとすると、ファイル形式が自動的かつ不可逆的に変換されます。&lt;b&gt;ライブラリのバージョン2.6.0で開く前に、古いデータベースファイルのバックアップコピーを作成します。&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b18ff5a16f7817612045bc810baefbc9f406946f" translate="yes" xml:space="preserve">
          <source>Change the journal mode of database P1 to P3. P3 must be one of the PAGER_JOURNALMODE_XXX values. If changing between the various rollback modes (delete, truncate, persist, off and memory), this is a simple operation. No IO is required.</source>
          <target state="translated">データベースP1のジャーナルモードをP3に変更します。P3はPAGER_JOURNALMODE_XXXの値のいずれかでなければなりません。様々なロールバックモード(削除、切り捨て、パーシスト、オフ、メモリ)の間で変更する場合、これは簡単な操作です。IOは必要ありません。</target>
        </trans-unit>
        <trans-unit id="6a5f740ae4d06bae054615ec1ed93d10f35a1f54" translate="yes" xml:space="preserve">
          <source>Change the makefile so that it no longer requires GNUmake extensions</source>
          <target state="translated">GNUmake 拡張機能を必要としなくなるように makefile を変更する</target>
        </trans-unit>
        <trans-unit id="1b024f79cb0f34e36e5e78085bb24625608ab395" translate="yes" xml:space="preserve">
          <source>Change the name of new_X to X using: ALTER TABLE new_X RENAME TO X.</source>
          <target state="translated">を使ってnew_Xの名前をXに変更します。ALTER TABLE new_X RENAME TO X.</target>
        </trans-unit>
        <trans-unit id="0f9e3a306b4bd9af67f4b8c1e8cb9e151f5fea94" translate="yes" xml:space="preserve">
          <source>Change the name of the sanity_check PRAGMA to &lt;b&gt;integrity_check&lt;/b&gt; and make it available in all compiles.</source>
          <target state="translated">sanity_check PRAGMAの名前を&lt;b&gt;完全性&lt;/b&gt;チェックに変更し、すべてのコンパイルで使用できるようにします。</target>
        </trans-unit>
        <trans-unit id="a87afe8ac8040316feb3c86d9f29d7a0de41424f" translate="yes" xml:space="preserve">
          <source>Change the round() function to return REAL instead of TEXT.</source>
          <target state="translated">round()関数が TEXT ではなく REAL を返すように変更。</target>
        </trans-unit>
        <trans-unit id="4cc900222ca19ab1e3c50fea1f145e841c36bab9" translate="yes" xml:space="preserve">
          <source>Change the schema parser so that it will error out if any of the type, name, and tbl_name columns of the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master table&lt;/a&gt; have been corrupted and the database connection is not in &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;writable_schema&lt;/a&gt; mode.</source>
          <target state="translated">&lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_masterテーブル&lt;/a&gt;のtype、name、およびtbl_name列のいずれかが破損していて、データベース接続が&lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;writable_schema&lt;/a&gt;モードでない場合にエラーになるように、スキーマパーサーを変更します。</target>
        </trans-unit>
        <trans-unit id="8e16078deadbe9f7e3e1b2c9c9d590cfec88a614" translate="yes" xml:space="preserve">
          <source>Change the schema parser so that it will error out if any of the type, name, and tbl_name columns of the &lt;a href=&quot;schematab&quot;&gt;sqlite_master table&lt;/a&gt; have been corrupted and the database connection is not in &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;writable_schema&lt;/a&gt; mode.</source>
          <target state="translated">スキーマパーサーを変更して、&lt;a href=&quot;schematab&quot;&gt;sqlite_masterテーブル&lt;/a&gt;のtype、name、およびtbl_name列のいずれかが破損していて、データベース接続が&lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;writable_schema&lt;/a&gt;モードでない場合にエラーが発生するようにします。</target>
        </trans-unit>
        <trans-unit id="8cf246de2a9b8a88c663c6913b8ed3a48191818d" translate="yes" xml:space="preserve">
          <source>Change the table_info pragma so that it returns NULL for the default value if there is no default value</source>
          <target state="translated">デフォルト値が存在しない場合は、デフォルト値に対して NULL を返すように table_info プラグマを変更します。</target>
        </trans-unit>
        <trans-unit id="b05df024c90267a155027a34482c97ed1e176816" translate="yes" xml:space="preserve">
          <source>Change the tclsqlite &quot;eval&quot; method to return a list of results if no callback script is specified.</source>
          <target state="translated">コールバックスクリプトが指定されていない場合、結果のリストを返すように tclsqlite の &quot;eval&quot; メソッドを変更しました。</target>
        </trans-unit>
        <trans-unit id="17fc584f1b3f79a52638c936555356d72a9a526e" translate="yes" xml:space="preserve">
          <source>Change the unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to be tolerant of read() system calls that return less then the full number of requested bytes.</source>
          <target state="translated">unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;を変更して、要求されたバイトの総数よりも少ない値を返すread（）システムコールに対応できるようにします。</target>
        </trans-unit>
        <trans-unit id="a542a095188ddcc6129238423271833568a2c07f" translate="yes" xml:space="preserve">
          <source>Change the way SUM() handles NULL values in order to comply with the SQL standard</source>
          <target state="translated">SQL 標準に準拠するために SUM()で NULL 値を処理する方法を変更します。</target>
        </trans-unit>
        <trans-unit id="5b5328bf106285a23dec346b5145893a33e1e8c9" translate="yes" xml:space="preserve">
          <source>Change the xFileControl() methods on all built-in VFSes to return &lt;a href=&quot;rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; instead of &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; for an unrecognized operation code.</source>
          <target state="translated">上xFileControl（）メソッドを変更し、すべてのビルトイン返すためにVFSes &lt;a href=&quot;rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;の代わり&lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERRORを&lt;/a&gt;認識できない操作コードのために。</target>
        </trans-unit>
        <trans-unit id="eca73e726e881b6d471428b557f6268ef3f59ed9" translate="yes" xml:space="preserve">
          <source>Change to use strncmp() or the equivalent instead of memcmp() when comparing non-zero-terminated strings.</source>
          <target state="translated">ゼロ終端でない文字列を比較する際に、memcmp()の代わりに strncmp()または同等のものを使用するように変更。</target>
        </trans-unit>
        <trans-unit id="5514a8922a61fec2577edc11821f533a39d0a9ca" translate="yes" xml:space="preserve">
          <source>Changed the comparison function so that numbers in exponential notation (ex: 1.234e+05) sort in numerical order.</source>
          <target state="translated">指数表記の数値(例:1.234e+05)を数値順に並べ替えるように比較機能を変更した。</target>
        </trans-unit>
        <trans-unit id="df02ed3983d83060874d040fa7eb3a189bd673c0" translate="yes" xml:space="preserve">
          <source>Changed the default configuration of the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; from 500 slots of 128 bytes each into 125 slots of 512 bytes each.</source>
          <target state="translated">&lt;a href=&quot;malloc#lookaside&quot;&gt;ルックアサイドメモリアロケータ&lt;/a&gt;のデフォルト設定を、128バイトの500スロットから、512バイトの125スロットに変更しました。</target>
        </trans-unit>
        <trans-unit id="7e34599469a327d2e948bcc9862b0322f2e510f5" translate="yes" xml:space="preserve">
          <source>Changed the defined behavior for the &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST expression&lt;/a&gt; when floating point values greater than +9223372036854775807 are cast into into integers so that the result is the largest possible integer, +9223372036854775807, instead of the smallest possible integer, -9223372036854775808. After this change, CAST(9223372036854775809.0 as INT) yields +9223372036854775807 instead of -9223372036854775808. &lt;b&gt;&lt;big&gt;&amp;larr;&lt;/big&gt; Potentially Incompatible Change!&lt;/b&gt;</source>
          <target state="translated">+9223372036854775807より大きい浮動小数点値が整数にキャストされるときの&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST式&lt;/a&gt;の定義済み動作を変更し、結果が可能な最小の整数-9223372036854775808ではなく、最大の整数+9223372036854775807になるようにしました。この変更後、CAST（9223372036854775809.0 as INT）は-9223372036854775808ではなく+9223372036854775807になります。&lt;b&gt;&lt;big&gt;&amp;larr;&lt;/big&gt;互換性がない可能性のある変更！&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8caa23815a1a8b1a9c4e9cdf79d42cbf41197489" translate="yes" xml:space="preserve">
          <source>Changed the print format for floating point values from &quot;%g&quot; to &quot;%.15g&quot;.</source>
          <target state="translated">浮動小数点値の印刷形式を &quot;%g&quot; から &quot;%.15g&quot; に変更しました。</target>
        </trans-unit>
        <trans-unit id="24a6e547edd1d04eb53e9f5fe5f292726e669a13" translate="yes" xml:space="preserve">
          <source>Changed the prototype of the &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; interface in a way that is backwards compatible but which might cause warnings in new builds of applications that use that interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension（）&lt;/a&gt;インターフェースのプロトタイプを下位互換性のある方法で変更しましたが、そのインターフェースを使用するアプリケーションの新しいビルドで警告が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="f51c4a6bf59ab3184542658dacdac319c7bb7606" translate="yes" xml:space="preserve">
          <source>Changed the signature of the xDlSym method of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object in a way that is backwards compatible but which might cause compiler warnings.</source>
          <target state="translated">下位互換性がある方法で&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトのxDlSymメソッドのシグネチャを変更しましたが、コンパイラ警告が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="09eb09203ab84e8c2e6e475c70c299202b24c3d8" translate="yes" xml:space="preserve">
          <source>Changegroup Handle</source>
          <target state="translated">変更グループハンドル</target>
        </trans-unit>
        <trans-unit id="11562ffd183a3f8082c848cac1f5dad1ab2f2843" translate="yes" xml:space="preserve">
          <source>Changes In SQLite Version 3.7.10</source>
          <target state="translated">SQLite バージョン 3.7.10 の変更点</target>
        </trans-unit>
        <trans-unit id="2995749ac68f24f9806cbd53a3147e4763d74488" translate="yes" xml:space="preserve">
          <source>Changes are made to the database by executing SQL statements. The session object records these changes.</source>
          <target state="translated">SQL文を実行することでデータベースに変更が加えられます。セッションオブジェクトはこれらの変更を記録します。</target>
        </trans-unit>
        <trans-unit id="3feb747c2cf9c224527b83786a30acbbf79e8f1b" translate="yes" xml:space="preserve">
          <source>Changes are not recorded for individual rows that have NULL values stored in one or more of their PRIMARY KEY columns.</source>
          <target state="translated">1つ以上のPRIMARY KEY列にNULL値が格納されている個々の行については、変更は記録されません。</target>
        </trans-unit>
        <trans-unit id="5ba7ed905184ce22787b0029a4544681dc28b3db" translate="yes" xml:space="preserve">
          <source>Changes are not recorded for rows that have NULL values stored in one or more of their PRIMARY KEY columns. If such a row is inserted or deleted, no corresponding change is present in the changesets returned by this function. If an existing row with one or more NULL values stored in PRIMARY KEY columns is updated so that all PRIMARY KEY columns are non-NULL, only an INSERT is appears in the changeset. Similarly, if an existing row with non-NULL PRIMARY KEY values is updated so that one or more of its PRIMARY KEY columns are set to NULL, the resulting changeset contains a DELETE change only.</source>
          <target state="translated">1つ以上のPRIMARY KEY列にNULL値が格納されている行については、変更は記録されません。そのような行が挿入されたり削除されたりした場合、この関数が返すチェンジセットには対応する変更はありません。PRIMARY KEY列に格納された1つ以上のNULL値を持つ既存の行が、すべてのPRIMARY KEY列がNULL以外の値になるように更新された場合、チェンジセットにはINSERTのみが表示されます。同様に、PRIMARY KEYの値がNULLでない既存の行が、そのPRIMARY KEYカラムの1つ以上がNULLに設定されるように更新された場合、結果として生じるチェンジセットにはDELETE変更のみが含まれます。</target>
        </trans-unit>
        <trans-unit id="f6e50ec4a352fdec5ac39c386ca001416ca1e482" translate="yes" xml:space="preserve">
          <source>Changes can only be recorded for tables that have a PRIMARY KEY explicitly defined as part of their CREATE TABLE statement. It does not matter if the PRIMARY KEY is an &quot;INTEGER PRIMARY KEY&quot; (rowid alias) or not. The PRIMARY KEY may consist of a single column, or may be a composite key.</source>
          <target state="translated">変更は、CREATE TABLE文の一部としてPRIMARY KEYが明示的に定義されているテーブルに対してのみ記録されます。PRIMARY KEYが &quot;INTEGER PRIMARY KEY&quot; (rowidエイリアス)であるかどうかは関係ありません。PRIMARY KEYは単一のカラムで構成されていてもよいし、複合キーであってもよい。</target>
        </trans-unit>
        <trans-unit id="c0acee58dba4e45c8d5f0399ec1f0d4976436ff2" translate="yes" xml:space="preserve">
          <source>Changes made as part of &lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; are included in the count, but those made as part of REPLACE constraint resolution are not. Changes to a view that are intercepted by INSTEAD OF triggers are not counted.</source>
          <target state="translated">&lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;外部キーアクションの&lt;/a&gt;一部として行われた変更はカウントに含まれますが、REPLACE制約の解決の一部として行われた変更は含まれません。INSTEAD OFトリガーによってインターセプトされたビューへの変更はカウントされません。</target>
        </trans-unit>
        <trans-unit id="b4615c7abb16118eca044200ca3ffb2d42e109f3" translate="yes" xml:space="preserve">
          <source>Changes made as part of &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; are included in the count, but those made as part of REPLACE constraint resolution are not. Changes to a view that are intercepted by INSTEAD OF triggers are not counted.</source>
          <target state="translated">&lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;外部キーアクションの&lt;/a&gt;一部として行われた変更はカウントに含まれますが、REPLACE制約の解決の一部として行われた変更は含まれません。INSTEAD OFトリガーによってインターセプトされたビューへの変更はカウントされません。</target>
        </trans-unit>
        <trans-unit id="1e424444f79aa5098cffaecbf261fdab95101506" translate="yes" xml:space="preserve">
          <source>Changes made in one database connection are invisible to all other database connections prior to commit.</source>
          <target state="translated">1つのデータベース接続で行われた変更は、コミット前に他のすべてのデータベース接続からは見えなくなります。</target>
        </trans-unit>
        <trans-unit id="f8bcc1bfedf61a4d6d2302f5aebd841ed0c31154" translate="yes" xml:space="preserve">
          <source>Changes to CREATE VIRTUAL TABLE statements</source>
          <target state="translated">CREATE VIRTUAL TABLE ステートメントの変更</target>
        </trans-unit>
        <trans-unit id="39b78ad4f8a76dbe4baff285b9df3d3da0888670" translate="yes" xml:space="preserve">
          <source>Changes to SELECT statements</source>
          <target state="translated">SELECT文の変更</target>
        </trans-unit>
        <trans-unit id="220e3088537dbb26a066213f366f942dc49c0e70" translate="yes" xml:space="preserve">
          <source>Changes to a view that are intercepted by &lt;a href=&quot;../lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF triggers&lt;/a&gt; are not counted. The value returned by sqlite3_changes() immediately after an INSERT, UPDATE or DELETE statement run on a view is always zero. Only changes made to real tables are counted.</source>
          <target state="translated">&lt;a href=&quot;../lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OFトリガー&lt;/a&gt;によってインターセプトされたビューへの変更はカウントされません。ビューでINSERT、UPDATE、またはDELETEステートメントを実行した直後にsqlite3_changes（）から返される値は常に0です。実際のテーブルに加えられた変更のみがカウントされます。</target>
        </trans-unit>
        <trans-unit id="5d6b66157c1ebd92a27f45e6d4f023a3d4bc6e87" translate="yes" xml:space="preserve">
          <source>Changes to a view that are intercepted by &lt;a href=&quot;lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF triggers&lt;/a&gt; are not counted. The value returned by sqlite3_changes() immediately after an INSERT, UPDATE or DELETE statement run on a view is always zero. Only changes made to real tables are counted.</source>
          <target state="translated">&lt;a href=&quot;lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OFトリガー&lt;/a&gt;によってインターセプトされたビューへの変更はカウントされません。ビューでINSERT、UPDATE、またはDELETEステートメントを実行した直後にsqlite3_changes（）から返される値は常に0です。実際のテーブルに加えられた変更のみがカウントされます。</target>
        </trans-unit>
        <trans-unit id="3ac2cb6fb5d947302cd716dd294d872e94891de1" translate="yes" xml:space="preserve">
          <source>Changes to comments.</source>
          <target state="translated">コメントの変更。</target>
        </trans-unit>
        <trans-unit id="c84397dcd0da39654544ab29ddec3a05373f0685" translate="yes" xml:space="preserve">
          <source>Changes to compile-time options:</source>
          <target state="translated">コンパイル時のオプションを変更しました。</target>
        </trans-unit>
        <trans-unit id="101e26bd8ffca056c8adaec28f53e8804617dcdd" translate="yes" xml:space="preserve">
          <source>Changes to rows that do not already appear in the changegroup are simply copied into it. Or, if both the new changeset and the changegroup contain changes that apply to a single row, the final contents of the changegroup depends on the type of each change, as follows:</source>
          <target state="translated">まだ changegroup に現れていない行への変更は、単に changegroup にコピーされます。あるいは、新しいチェンジセットとチェンジグループの両方に単一の行に適用される変更が含まれている場合、チェンジグループの最終的な内容は、以下のように各変更のタイプに依存します。</target>
        </trans-unit>
        <trans-unit id="3fc8393d45e2f151d9e20c436cc969f753e757c8" translate="yes" xml:space="preserve">
          <source>Changes to some test scripts so that they work on Windows in addition to Unix.</source>
          <target state="translated">いくつかのテストスクリプトを変更し、Unix に加えて Windows でも動作するようにしました。</target>
        </trans-unit>
        <trans-unit id="e4c26ff789d743fb895c4925c581702e142ed6c8" translate="yes" xml:space="preserve">
          <source>Changes to support 64-bit architectures.</source>
          <target state="translated">64ビットアーキテクチャをサポートするための変更。</target>
        </trans-unit>
        <trans-unit id="0e15c1197ceca55511517525b0c74a6a5dfd3ac1" translate="yes" xml:space="preserve">
          <source>Changes to the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトの変更</target>
        </trans-unit>
        <trans-unit id="062c3354f76067d89f734b31e5b499c574c81bb7" translate="yes" xml:space="preserve">
          <source>Changes to the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; to help it work better when compiled using MSVC.</source>
          <target state="translated">MSVCを使用してコンパイルしたときの動作を改善するための&lt;a href=&quot;lemon&quot;&gt;レモンパーサージェネレーターの&lt;/a&gt;変更。</target>
        </trans-unit>
        <trans-unit id="d0bc6551b6a2c8af14e74911872297e41927e492" translate="yes" xml:space="preserve">
          <source>Changes to the FULL_COLUMN_NAMES pragma to help out the ODBC driver.</source>
          <target state="translated">FULL_COLUMN_NAMESプラグマを変更し、ODBCドライバを支援するようにしました。</target>
        </trans-unit>
        <trans-unit id="7e96fb7803c57c4c013f472a7a7b6294655eae95" translate="yes" xml:space="preserve">
          <source>Changes to the OS-layer interface: mutexes must now be recursive.</source>
          <target state="translated">OS 層インターフェースの変更:ミューテックスは再帰的でなければならないようになりました。</target>
        </trans-unit>
        <trans-unit id="32f6cdea79e8215becbb15cf7bd7e55cdcee90d2" translate="yes" xml:space="preserve">
          <source>Changes within a patchset are ordered in the same way as for changesets generated by the sqlite3session_changeset() function (i.e. all changes for a single table are grouped together, tables appear in the order in which they were attached to the session object).</source>
          <target state="translated">パッチセット内の変更は、sqlite3session_changeset()関数によって生成されたチェンジセットと同じ方法で順序付けられます(すなわち、1つのテーブルに対するすべての変更はグループ化され、テーブルはセッションオブジェクトにアタッチされた順番で表示されます)。</target>
        </trans-unit>
        <trans-unit id="da04970767ae72464882ac8a4e16564000ecf171" translate="yes" xml:space="preserve">
          <source>Changes within the local changeset are rebased as follows:</source>
          <target state="translated">ローカル チェンジセット内の変更は、以下のようにリベースされます。</target>
        </trans-unit>
        <trans-unit id="3a336eee124955ea62ce9395beedef4d114ca005" translate="yes" xml:space="preserve">
          <source>Changeset Generation</source>
          <target state="translated">チェンジセット生成</target>
        </trans-unit>
        <trans-unit id="83360005f23e00ab75cb5a31e370b474e7cda3dd" translate="yes" xml:space="preserve">
          <source>Changeset Iterator Handle</source>
          <target state="translated">チェンジセット イテレータ ハンドル</target>
        </trans-unit>
        <trans-unit id="e80a51a4aaef4428a67700502b5f7dc75dbd4588" translate="yes" xml:space="preserve">
          <source>Changesets may only be applied to databases that contain tables matching the above three criteria as stored in the changeset.</source>
          <target state="translated">チェンジセットは、チェンジセットに格納されている上記の3つの基準に一致するテーブルを含むデータベースにのみ適用できます。</target>
        </trans-unit>
        <trans-unit id="ac1c3813780e3748f7f89bcb8cde7110310ebb74" translate="yes" xml:space="preserve">
          <source>Changing Filesystems</source>
          <target state="translated">ファイルシステムの変更</target>
        </trans-unit>
        <trans-unit id="5f75f4f19ef2482e0ee092a7ab747ab2b4de6353" translate="yes" xml:space="preserve">
          <source>Changing the &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;PRAGMA schema_version&lt;/a&gt; while other database connections are open.</source>
          <target state="translated">他のデータベース接続が開いている間に&lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;PRAGMA schema_version&lt;/a&gt;を変更する。</target>
        </trans-unit>
        <trans-unit id="9851972ccfb6ddbbe4682022996c0b7f4c61ad78" translate="yes" xml:space="preserve">
          <source>Changing the data_store_directory setting is &lt;u&gt;not&lt;/u&gt; threadsafe. Never change the data_store_directory setting if another thread within the application is running any SQLite interface at the same time. Doing so results in undefined behavior. Changing the data_store_directory setting writes to the &lt;a href=&quot;c3ref/data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; global variable and that global variable is not protected by a mutex.</source>
          <target state="translated">data_store_directory設定の変更はスレッドセーフではあり&lt;u&gt;ません&lt;/u&gt;。アプリケーション内の別のスレッドが同時にSQLiteインターフェイスを実行している場合は、data_store_directory設定を変更しないでください。これを行うと、未定義の動作が発生します。data_store_directory設定を変更すると、&lt;a href=&quot;c3ref/data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt;グローバル変数に書き込まれ、そのグローバル変数はミューテックスによって保護されません。</target>
        </trans-unit>
        <trans-unit id="430a2be1381002d87b9b8ff73223fcbf66c5e87f" translate="yes" xml:space="preserve">
          <source>Changing the foreign_keys setting affects the execution of all statements prepared using the database connection, including those prepared before the setting was changed. Any existing statements prepared using the legacy &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface may fail with an &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; error after the foreign_keys setting is changed.</source>
          <target state="translated">foreign_keys設定を変更すると、設定が変更される前に準備されたステートメントを含め、データベース接続を使用して準備されたすべてのステートメントの実行に影響します。既存の文は、レガシー用いて調製&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;で失敗することがインターフェイスを&lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMAの&lt;/a&gt; FOREIGN_KEYSの設定が変更された後、エラー。</target>
        </trans-unit>
        <trans-unit id="e64e5108f8dce99580f41bdd628fb1a43e13fc20" translate="yes" xml:space="preserve">
          <source>Changing the recursive_triggers setting affects the execution of all statements prepared using the database connection, including those prepared before the setting was changed. Any existing statements prepared using the legacy &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface may fail with an &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; error after the recursive_triggers setting is changed.</source>
          <target state="translated">recursive_triggers設定を変更すると、設定が変更される前に準備されたステートメントを含め、データベース接続を使用して準備されたすべてのステートメントの実行に影響します。従来の&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;インターフェースを使用して準備された既存のステートメントは、recursive_triggers設定が変更された後、&lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt;エラーで失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="859510e9fde4ba7098039dc9d57957c57590e8ad" translate="yes" xml:space="preserve">
          <source>Changing the temp_store_directory setting is &lt;u&gt;not&lt;/u&gt; threadsafe. Never change the temp_store_directory setting if another thread within the application is running any SQLite interface at the same time. Doing so results in undefined behavior. Changing the temp_store_directory setting writes to the &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable and that global variable is not protected by a mutex.</source>
          <target state="translated">temp_store_directory設定の変更はスレッドセーフではあり&lt;u&gt;ません&lt;/u&gt;。アプリケーション内の別のスレッドが同時にSQLiteインターフェイスを実行している場合は、temp_store_directory設定を変更しないでください。これを行うと、未定義の動作が発生します。temp_store_directory設定を変更すると、&lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;グローバル変数に書き込まれ、そのグローバル変数はミューテックスによって保護されません。</target>
        </trans-unit>
        <trans-unit id="4a3e8791cfca3d884c74337ea57def9c05ece108" translate="yes" xml:space="preserve">
          <source>Changing the value of this variable while a database connection is open can result in a corrupt database.</source>
          <target state="translated">データベース接続が開いている間にこの変数の値を変更すると、データベースが破損する可能性があります。</target>
        </trans-unit>
        <trans-unit id="ee9946c82d4a077c5be79e3015a3d2479d9fcaf2" translate="yes" xml:space="preserve">
          <source>Character</source>
          <target state="translated">Character</target>
        </trans-unit>
        <trans-unit id="cea842266549b8d9e4991a72c7996837bc0ff6f1" translate="yes" xml:space="preserve">
          <source>Characters in the matchinfo format string are processed from left to right. Each character in the format string causes one or more 32-bit unsigned integer values to be added to the returned array. The &quot;values&quot; column in the following table contains the number of integer values appended to the output buffer for each supported format string character. In the formula given,</source>
          <target state="translated">matchinfo 形式文字列の文字は、左から右へ処理されます。フォーマット文字列の各文字によって、1 つ以上の 32 ビット符号なし整数値が返された配列に追加されます。次の表の「values」列には、サポートされているフォーマット文字列の各文字について、出力バッファに追加される整数値の数が含まれています。与えられた式の中で</target>
        </trans-unit>
        <trans-unit id="901d44a58ef0c59ab99643a19134ba47c238ad29" translate="yes" xml:space="preserve">
          <source>Chart 1: SQLite read latency relative to direct filesystem reads.</source>
          <target state="translated">図1:ファイルシステムの直接読み取りに対するSQLiteの読み取りレイテンシ。</target>
        </trans-unit>
        <trans-unit id="27276d4efc029611aba60cde7d26cce5f51fc924" translate="yes" xml:space="preserve">
          <source>Chart 2: SQLite read latency relative to direct filesystem reads.</source>
          <target state="translated">図2:ファイルシステムの直接読み取りに対するSQLiteの読み取りレイテンシ。</target>
        </trans-unit>
        <trans-unit id="9b63c13706e018a965e9ad083cf8558f0ea7a319" translate="yes" xml:space="preserve">
          <source>Chart 3: SQLite read latency relative to direct filesystem reads.</source>
          <target state="translated">図3:ファイルシステムの直接読み取りに対するSQLiteの読み取りレイテンシ。</target>
        </trans-unit>
        <trans-unit id="d2affd8c541db58f31c69f6910d1f00260d88617" translate="yes" xml:space="preserve">
          <source>Chart 4: SQLite write latency relative to direct filesystem writes.</source>
          <target state="translated">図4:ファイルシステムへの直接書き込みに対するSQLiteの書き込みレイテンシ。</target>
        </trans-unit>
        <trans-unit id="3ac7623b08d5a3f0968ebaaaf80eef331d89a328" translate="yes" xml:space="preserve">
          <source>Chart 5: SQLite write latency relative to direct filesystem writes.</source>
          <target state="translated">図5:ファイルシステムへの直接書き込みに対するSQLiteの書き込みレイテンシ。</target>
        </trans-unit>
        <trans-unit id="145b22ca4b4508601bd80ce10219fd8d551a1cef" translate="yes" xml:space="preserve">
          <source>Chastise the body.</source>
          <target state="translated">体を懲らしめる。</target>
        </trans-unit>
        <trans-unit id="0018d2d0130bb05c6b042cf37fbaadc3d3c580d7" translate="yes" xml:space="preserve">
          <source>Check local (non foreign key) constraints,</source>
          <target state="translated">ローカル(非外部キー)制約をチェックします。</target>
        </trans-unit>
        <trans-unit id="b2b621da54eb725e76b59b6aa64ddca11509ebb6" translate="yes" xml:space="preserve">
          <source>Check the cursor P1 to see if it is currently pointing at a NULL row. If it is, then set register P3 to NULL and jump immediately to P2. If P1 is not on a NULL row, then fall through without making any changes.</source>
          <target state="translated">カーソルP1が現在NULL行を指しているかどうかを確認します。もしそうであれば、レジスタP3をNULLに設定し、すぐにP2にジャンプします。P1がNULL行を指していなければ、何も変更せずにフォールスルーする。</target>
        </trans-unit>
        <trans-unit id="09e577018637d04e97c17b023b39748cce6a0852" translate="yes" xml:space="preserve">
          <source>Check the value in register P3. If it is NULL then &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; using parameter P1, P2, and P4 as if this were a &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; instruction. If the value in register P3 is not NULL, then this routine is a no-op. The P5 parameter should be 1.</source>
          <target state="translated">レジスタP3の値を確認します。それがNULLである場合、&lt;a href=&quot;opcode#Halt&quot;&gt;停止し&lt;/a&gt;、これはあたかもP1、P2、およびP4パラメータ使用&lt;a href=&quot;opcode#Halt&quot;&gt;ホールト&lt;/a&gt;命令。レジスタP3の値がNULLでない場合、このルーチンは何もしません。P5パラメータは1である必要があります。</target>
        </trans-unit>
        <trans-unit id="853e2972eec38f585243beee1676c957c81ad890" translate="yes" xml:space="preserve">
          <source>Check to see if the database file has a hot journal. If the file does not have a hot journal, we are done. Return immediately. If there is a hot journal, that journal must be rolled back by the subsequent steps of this algorithm.</source>
          <target state="translated">データベースファイルにホットジャーナルがあるかどうかを確認します。ファイルにホットジャーナルがない場合は、これで終了です。すぐに戻ります。ホット・ジャーナルがある場合、そのジャーナルはこのアルゴリズムの後続のステップでロールバックする必要があります。</target>
        </trans-unit>
        <trans-unit id="a2f036a3bd46936cd9d2c40c2e45e1005b34f3dd" translate="yes" xml:space="preserve">
          <source>Checklist For Choosing The Right Database Engine</source>
          <target state="translated">正しいデータベースエンジンを選択するためのチェックリスト</target>
        </trans-unit>
        <trans-unit id="812e4bd3b7c47c7f81d4167d8aab871141a8c91b" translate="yes" xml:space="preserve">
          <source>Checklists</source>
          <target state="translated">Checklists</target>
        </trans-unit>
        <trans-unit id="5cb9afc05957645058216dd6772ded2e46522ec1" translate="yes" xml:space="preserve">
          <source>Checkpoint</source>
          <target state="translated">Checkpoint</target>
        </trans-unit>
        <trans-unit id="6c8f9631542e10f31e77b7a465542d388b6decdb" translate="yes" xml:space="preserve">
          <source>Checkpoint Information and Locks</source>
          <target state="translated">チェックポイント情報とロック</target>
        </trans-unit>
        <trans-unit id="2a00fbbeacd66d1129876c4f2a120582b60dcc8f" translate="yes" xml:space="preserve">
          <source>Checkpoint Mode Values</source>
          <target state="translated">チェックポイントモード値</target>
        </trans-unit>
        <trans-unit id="f8b00f7fe2c53994a3c2e16e9fff90f46c54af6d" translate="yes" xml:space="preserve">
          <source>Checkpoint a database</source>
          <target state="translated">データベースのチェックポイント</target>
        </trans-unit>
        <trans-unit id="37924a2fe97c6ebb27cab5b2e8b0b2d0894bd2b5" translate="yes" xml:space="preserve">
          <source>Checkpoint as many frames as possible without waiting for any database readers or writers to finish, then sync the database file if all frames in the log were checkpointed. The &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy-handler callback&lt;/a&gt; is never invoked in the SQLITE_CHECKPOINT_PASSIVE mode. On the other hand, passive mode might leave the checkpoint unfinished if there are concurrent readers or writers.</source>
          <target state="translated">データベースリーダーまたはライターが完了するのを待たずに、できるだけ多くのフレームをチェックポイントし、ログ内のすべてのフレームにチェックポイントが設定されている場合は、データベースファイルを同期します。&lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;ビジーハンドラのコールバックは&lt;/a&gt; SQLITE_CHECKPOINT_PASSIVEモードで呼び出されることはありません。一方、パッシブモードでは、リーダーまたはライターが同時に存在する場合、チェックポイントが未完成のままになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="65bebe73feb47e6a7a12e61f091ce204dad0258a" translate="yes" xml:space="preserve">
          <source>Checkpoint as many frames as possible without waiting for any database readers or writers to finish, then sync the database file if all frames in the log were checkpointed. The &lt;a href=&quot;busy_handler&quot;&gt;busy-handler callback&lt;/a&gt; is never invoked in the SQLITE_CHECKPOINT_PASSIVE mode. On the other hand, passive mode might leave the checkpoint unfinished if there are concurrent readers or writers.</source>
          <target state="translated">データベースリーダーまたはライターが完了するのを待たずに、できるだけ多くのフレームをチェックポイントし、ログ内のすべてのフレームにチェックポイントが設定されている場合は、データベースファイルを同期します。&lt;a href=&quot;busy_handler&quot;&gt;ビジーハンドラのコールバックは&lt;/a&gt; SQLITE_CHECKPOINT_PASSIVEモードで呼び出されることはありません。一方、パッシブモードでは、リーダーまたはライターが同時に存在する場合、チェックポイントが未完成のままになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="11999bbd94b14ea8ec845c4fcad50ea24f0a3d45" translate="yes" xml:space="preserve">
          <source>Checkpoint as many frames as possible without waiting for any database readers or writers to finish. Sync the db file if all frames in the log are checkpointed. This mode is the same as calling the &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; C interface. The &lt;a href=&quot;c3ref/busy_handler&quot;&gt;busy-handler callback&lt;/a&gt; is never invoked in this mode.</source>
          <target state="translated">データベースのリーダーまたはライターの終了を待たずに、できるだけ多くのフレームをチェックポイントします。ログ内のすべてのフレームがチェックポイントされている場合は、dbファイルを同期します。このモードは、&lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint（）&lt;/a&gt; Cインターフェースを呼び出すのと同じです。&lt;a href=&quot;c3ref/busy_handler&quot;&gt;ビジーハンドラのコールバックは&lt;/a&gt;、このモードで呼び出されることはありません。</target>
        </trans-unit>
        <trans-unit id="4db6d205b349663d744b71f2a117e634b9469124" translate="yes" xml:space="preserve">
          <source>Checkpoint database P1. This is a no-op if P1 is not currently in WAL mode. Parameter P2 is one of SQLITE_CHECKPOINT_PASSIVE, FULL, RESTART, or TRUNCATE. Write 1 or 0 into mem[P3] if the checkpoint returns SQLITE_BUSY or not, respectively. Write the number of pages in the WAL after the checkpoint into mem[P3+1] and the number of pages in the WAL that have been checkpointed after the checkpoint completes into mem[P3+2]. However on an error, mem[P3+1] and mem[P3+2] are initialized to -1.</source>
          <target state="translated">チェックポイントデータベースP1。P1が現在WALモードになっていない場合、これは実行されません。パラメータP2はSQLITE_CHECKPOINT_PASSIVE、FULL、RESTART、TRUNCATEのいずれかです。チェックポイントがSQLITE_BUSYを返した場合は1、返さなかった場合は0をそれぞれmem[P3]に書き込む。mem[P3+1]にはチェックポイント後のWALのページ数、mem[P3+2]にはチェックポイント終了後にチェックポイントされたWALのページ数を書き込む。ただし、エラー時には、mem[P3+1]とmem[P3+2]は-1に初期化される。</target>
        </trans-unit>
        <trans-unit id="c93c7ed9eb6c55536fc1fa5a09dd161c7c872485" translate="yes" xml:space="preserve">
          <source>Checkpoint sequence number</source>
          <target state="translated">チェックポイントシーケンス番号</target>
        </trans-unit>
        <trans-unit id="73420aa2c87505947c6412ba6601937a69b34e0a" translate="yes" xml:space="preserve">
          <source>Checkpointing does require sync operations in order to avoid the possibility of database corruption following a power loss or hard reboot. The WAL must be synced to persistent storage prior to moving content from the WAL into the database and the database file must by synced prior to resetting the WAL. Checkpoint also requires more seeking. The checkpointer makes an effort to do as many sequential page writes to the database as it can (the pages are transferred from WAL to database in ascending order) but even then there will typically be many seek operations interspersed among the page writes. These factors combine to make checkpoints slower than write transactions.</source>
          <target state="translated">チェックポイントは、停電やハードリブート後のデータベース破損の可能性を避けるために、同期操作を必要とします。WALからデータベースにコンテンツを移動する前にWALを永続的なストレージに同期させ、WALをリセットする前にデータベースファイルを同期させなければなりません。チェックポイントはまた、より多くのシークを必要とします。チェックポイントはデータベースへのシーケンシャルなページ書き込みを可能な限り多く行うように努力しますが(ページはWALからデータベースへ昇順に転送されます)、それでも一般的にはページ書き込みの間に多くのシーク操作が散在することになります。これらの要因が組み合わさって、チェックポイントは書き込みトランザクションよりも遅くなります。</target>
        </trans-unit>
        <trans-unit id="13a5691b3271955325bfbd27f548fc8c0c82dfae" translate="yes" xml:space="preserve">
          <source>Checkpoints initiated by this mechanism are &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;PASSIVE&lt;/a&gt;.</source>
          <target state="translated">このメカニズムによって開始されたチェックポイントは&lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;パッシブ&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="ab8c79d054f22aac4eeb01b5ef4d71f862efa21c" translate="yes" xml:space="preserve">
          <source>Checkpoints initiated by this mechanism are &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;PASSIVE&lt;/a&gt;.</source>
          <target state="translated">このメカニズムによって開始されたチェックポイントは&lt;a href=&quot;wal_checkpoint_v2&quot;&gt;パッシブ&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="df9b91c031577503e347c145ff1b0094db4452ef" translate="yes" xml:space="preserve">
          <source>Checks if the &quot;fired&quot; flag has been set. If so, the unlock-notify callback has already been invoked. Release the mutex and continue.</source>
          <target state="translated">fired&quot; フラグが設定されているかどうかをチェックします。セットされている場合は、 unlock-notify コールバックが既に呼び出されています。ミューテックスを解放して続行します。</target>
        </trans-unit>
        <trans-unit id="d8fcd1cd020581d6d23f7d74cd403fc559263ad5" translate="yes" xml:space="preserve">
          <source>Checksum</source>
          <target state="translated">Checksum</target>
        </trans-unit>
        <trans-unit id="c2d50b4086a2009c1329398de62782c1b322789e" translate="yes" xml:space="preserve">
          <source>Checksum of the last frame in the WAL file.</source>
          <target state="translated">WAL ファイルの最後のフレームのチェックサム。</target>
        </trans-unit>
        <trans-unit id="36775ac61bbdc09836e15e4ec7e669eae516b3d3" translate="yes" xml:space="preserve">
          <source>Checksum-1: Cumulative checksum up through and including this page</source>
          <target state="translated">チェックサム-1:このページまでの累積チェックサム</target>
        </trans-unit>
        <trans-unit id="0f0241436226dd5ad15b784282d744ddcaf53796" translate="yes" xml:space="preserve">
          <source>Checksum-1: First part of a checksum on the first 24 bytes of header</source>
          <target state="translated">Checksum-1:ヘッダの最初の24バイトのチェックサムの最初の部分</target>
        </trans-unit>
        <trans-unit id="25d65b4024e29fd560da0ace1eb3f77896847390" translate="yes" xml:space="preserve">
          <source>Checksum-2: Second half of the cumulative checksum.</source>
          <target state="translated">Checksum-2:累積チェックサムの後半。</target>
        </trans-unit>
        <trans-unit id="abcb92542826823bd4a635495c66df0db032424c" translate="yes" xml:space="preserve">
          <source>Checksum-2: Second part of the checksum on the first 24 bytes of header</source>
          <target state="translated">Checksum-2:ヘッダの最初の24バイト目のチェックサムの2番目の部分</target>
        </trans-unit>
        <trans-unit id="f67c2d32dbe70d2749477ec3873f70b148c33e3f" translate="yes" xml:space="preserve">
          <source>Checksumming only works on databases that have a &lt;a href=&quot;fileformat2#resbyte&quot;&gt;reserve bytes&lt;/a&gt; value of exactly 8. The default value for reserve-bytes is 0. Hence, newly created database files will omit the checksum by default. To create a database that includes a checksum, change the reserve-bytes value to 8 by running code similar to this:</source>
          <target state="translated">チェックサムは、&lt;a href=&quot;fileformat2#resbyte&quot;&gt;予約バイト&lt;/a&gt;値が正確に8であるデータベースでのみ機能します。予約バイトのデフォルト値は0です。したがって、新しく作成されたデータベースファイルは、デフォルトでチェックサムを省略します。チェックサムを含むデータベースを作成するには、次のようなコードを実行して、reserve-bytes値を8に変更します。</target>
        </trans-unit>
        <trans-unit id="2e6fc2f66d5cb19af415e45034e0124b71cc4cce" translate="yes" xml:space="preserve">
          <source>Cherrypick fixes for other obscure problems found since the 3.30.0 release</source>
          <target state="translated">3.30.0リリース以降に発見された他の不明瞭な問題をCherrypickで修正</target>
        </trans-unit>
        <trans-unit id="38f9d9f26118d80f3d659b4ee2e2b654e7c605c0" translate="yes" xml:space="preserve">
          <source>Choose the column names in a compound query from the left-most SELECT instead of the right-most.</source>
          <target state="translated">複合クエリのカラム名は、右端のSELECTではなく、左端のSELECTから選択します。</target>
        </trans-unit>
        <trans-unit id="11cfd2c677994d3ba2e81eb3cb8ff4634809c573" translate="yes" xml:space="preserve">
          <source>Choosing good indexes for each loop</source>
          <target state="translated">各ループに適したインデックスの選択</target>
        </trans-unit>
        <trans-unit id="070374ff80947b819eb8815e8d492bf0a862577e" translate="yes" xml:space="preserve">
          <source>Chronology</source>
          <target state="translated">Chronology</target>
        </trans-unit>
        <trans-unit id="b104217954a3ac451efc2e2bfb3fdea27198ddd0" translate="yes" xml:space="preserve">
          <source>Cksumvfs is a &lt;a href=&quot;vfs#shim&quot;&gt;VFS shim&lt;/a&gt;. When loaded, &quot;cksmvfs&quot; becomes the new default VFS, and it uses the prior default VFS as the next VFS down in the stack. This is normally what you want. However, in complex situations where multiple VFS shims are being loaded, it might be important to ensure that cksumvfs is loaded in the correct order so that it sequences itself into the default VFS Shim stack in the right order.</source>
          <target state="translated">Cksumvfsは&lt;a href=&quot;vfs#shim&quot;&gt;VFSシム&lt;/a&gt;です。ロードされると、「cksmvfs」が新しいデフォルトVFSになり、スタック内の次のVFSとして以前のデフォルトVFSを使用します。これは通常あなたが望むものです。ただし、複数のVFSシムがロードされている複雑な状況では、cksumvfsが正しい順序でロードされ、デフォルトのVFSシムスタックに正しい順序でシーケンスされるようにすることが重要な場合があります。</target>
        </trans-unit>
        <trans-unit id="d697c3a479d4940e72936c6c5796e737d83de121" translate="yes" xml:space="preserve">
          <source>Clean up comments and variable names. Changes to documentation. No functional changes to the code.</source>
          <target state="translated">コメントと変数名のクリーンアップ。ドキュメントの変更。コードの機能的な変更はありません。</target>
        </trans-unit>
        <trans-unit id="719ea396ad92e01b4757ec2b93bb1e5f270f771d" translate="yes" xml:space="preserve">
          <source>Clear</source>
          <target state="translated">Clear</target>
        </trans-unit>
        <trans-unit id="7fe36a4f7ea83f99a8ac259b32e3aa3e06a3e0ea" translate="yes" xml:space="preserve">
          <source>Clearly, a hardware or operating system fault that introduces incorrect data into the middle of the database file or journal will cause problems. Likewise, if a rogue process opens a database file or journal and writes malformed data into the middle of it, then the database will become corrupt. There is not much that can be done about these kinds of problems so they are given no further attention.</source>
          <target state="translated">明らかに、データベースファイルやジャーナルの途中に不正なデータを挿入するハードウェアやオペレーティングシステムの障害が問題を引き起こすことになります。同様に、不正なプロセスがデータベースファイルやジャーナルを開き、その中に不正なデータを書き込むと、データベースが破損します。これらの種類の問題については、対処できることはあまりないので、これ以上の注意を払う必要はありません。</target>
        </trans-unit>
        <trans-unit id="95490bb933b1b789f5f61256736c0ee3697b1303" translate="yes" xml:space="preserve">
          <source>Client applications typically use a generic database interface that allows connections to various SQL database engines. It makes good sense to include SQLite in the mix of supported databases and to statically link the SQLite engine in with the client. That way the client program can be used standalone with an SQLite data file for testing or for demonstrations.</source>
          <target state="translated">クライアントアプリケーションは通常、様々な SQL データベースエンジンへの接続を可能にする汎用データベースインターフェースを使用します。サポートされているデータベースの中に SQLite を含め、SQLite エンジンをクライアントと静的にリンクすることは理にかなっています。そうすれば、クライアントプログラムはテストやデモンストレーションのために、SQLiteデータファイルを使ってスタンドアロンで使用することができます。</target>
        </trans-unit>
        <trans-unit id="525256fa1745ebe5497d79cf726d90129b04804e" translate="yes" xml:space="preserve">
          <source>Client/server SQL database engines strive to implement a shared repository of enterprise data. They emphasize scalability, concurrency, centralization, and control. SQLite strives to provide local data storage for individual applications and devices. SQLite emphasizes economy, efficiency, reliability, independence, and simplicity.</source>
          <target state="translated">クライアント/サーバーSQLデータベースエンジンは、企業データの共有リポジトリの実装に努めています。拡張性、同時実行性、集中化、制御を重視しています。SQLite は、個々のアプリケーションやデバイス用のローカルデータストレージを提供することを目指しています。SQLite は経済性、効率性、信頼性、独立性、シンプルさを重視しています。</target>
        </trans-unit>
        <trans-unit id="e1dbee15a55011ce9dd54d220174f35b9020dbef" translate="yes" xml:space="preserve">
          <source>Client/server database engines are designed to live inside a lovingly-attended datacenter at the core of the network. SQLite works there too, but SQLite also thrives at the edge of the network, fending for itself while providing fast and reliable data services to applications that would otherwise have dodgy connectivity.</source>
          <target state="translated">クライアント/サーバ・データベース・エンジンは、ネットワークの中核にある、愛情を込めて管理されたデータセンターの中で動作するように設計されています。SQLite はそこでも動作しますが、SQLite はネットワークのエッジでも活躍しており、接続性が悪いアプリケーションに高速で信頼性の高いデータサービスを提供しながら、自分自身を守っています。</target>
        </trans-unit>
        <trans-unit id="63b283ce3f8b364e187012832c04f432c579a52d" translate="yes" xml:space="preserve">
          <source>Client/server databases like MySQL, PostgreSQL, SQL Server, Oracle, and others are an important component of modern systems. These systems solve an important problem. But SQLite solves a different problem. Both SQLite and client/server databases have their role. Developers who are comparing SQLite against other SQL database engines need to clearly understand this distinction.</source>
          <target state="translated">MySQL、PostgreSQL、SQL Server、Oracleなどのクライアント/サーバデータベースは、現代のシステムの重要な構成要素となっています。これらのシステムは重要な問題を解決します。しかし、SQLite は別の問題を解決します。SQLite とクライアント/サーバーデータベースの両方にはそれぞれ役割があります。SQLite を他の SQL データベースエンジンと比較する開発者は、この区別を明確に理解する必要があります。</target>
        </trans-unit>
        <trans-unit id="bbfa773e5a63a5ea58c9b6207e608ca0120e592a" translate="yes" xml:space="preserve">
          <source>Close</source>
          <target state="translated">Close</target>
        </trans-unit>
        <trans-unit id="d692c2c202249e9e4fe0069f00e6bff039f0c2b5" translate="yes" xml:space="preserve">
          <source>Close A BLOB Handle</source>
          <target state="translated">BLOBハンドルを閉じる</target>
        </trans-unit>
        <trans-unit id="2e50e33188cf1bf73dcb5e4643c391e4e29a00af" translate="yes" xml:space="preserve">
          <source>Close a cursor previously opened as P1. If P1 is not currently open, this instruction is a no-op.</source>
          <target state="translated">P1として開いていたカーソルを閉じます。P1が現在開いていない場合、この命令は実行されません。</target>
        </trans-unit>
        <trans-unit id="0e4d537da92d49358e224a4a747dea32342b05b1" translate="yes" xml:space="preserve">
          <source>Close both cursors.</source>
          <target state="translated">両方のカーソルを閉じて</target>
        </trans-unit>
        <trans-unit id="29aaf7cec2af0b1f202abf31695f4cd37d74e8ff" translate="yes" xml:space="preserve">
          <source>Close the cursor.</source>
          <target state="translated">カーソルを閉じます。</target>
        </trans-unit>
        <trans-unit id="f1ceaea1ade786b6daac7b066c7f274b9fd722f8" translate="yes" xml:space="preserve">
          <source>Closing A Database Connection</source>
          <target state="translated">データベース接続を閉じる</target>
        </trans-unit>
        <trans-unit id="e0046ff4ec6b0abe476379971c2a006ff70bf46c" translate="yes" xml:space="preserve">
          <source>Closing a Connection</source>
          <target state="translated">接続を閉じる</target>
        </trans-unit>
        <trans-unit id="8661917419fb7cc5ef82c55b2e68e555b2266617" translate="yes" xml:space="preserve">
          <source>Closing a connection.</source>
          <target state="translated">接続を閉じる</target>
        </trans-unit>
        <trans-unit id="db1b559a50c46dcb478b73c9953c212ac94e2736" translate="yes" xml:space="preserve">
          <source>Closing a database connection is a simple matter. The open VFS file-handle is closed and in-memory</source>
          <target state="translated">データベース接続を閉じるのは簡単です。開いているVFSファイルハンドルは閉じられ、インメモリの</target>
        </trans-unit>
        <trans-unit id="7c60089a30c51b5540b0120bd48683a09f4c83f6" translate="yes" xml:space="preserve">
          <source>Clothe the naked.</source>
          <target state="translated">裸に服を着せろ</target>
        </trans-unit>
        <trans-unit id="bb887cae0ad4591660280c949ded3080d0ff24a8" translate="yes" xml:space="preserve">
          <source>Clustered Indexes and the WITHOUT ROWID Optimization</source>
          <target state="translated">クラスター化インデックスとWITHOUT ROWID最適化</target>
        </trans-unit>
        <trans-unit id="79a91b7b9e81e75043a22ebed1514d4b90a130a5" translate="yes" xml:space="preserve">
          <source>Clustered indexes</source>
          <target state="translated">クラスター化されたインデックス</target>
        </trans-unit>
        <trans-unit id="339841482704071d6be66d22a76e8ac915ed405e" translate="yes" xml:space="preserve">
          <source>Co-routines are better than storing the complete result set of the subquery in a transient table because co-routines use less memory. With a co-routine, only a single row of the result needs to be remembered, whereas all rows of the result must be stored for a transient table. Also, because the co-routine does not need to run to completion before the outer query begins its work, the first rows of output can appear much sooner, and if the overall query is aborted, less work is done overall.</source>
          <target state="translated">コ・サブルーチンは、副問い合わせの完全な結果セットを一時的なテーブルに格納するよりも、使用するメモリが少なくて済むので優れています。結果の全行を一過性のテーブルに格納しなければならないのに対し、コ・ルーチンでは結果の1行だけを記憶する必要があります。また、外部クエリが作業を開始する前にコ・ルーチンを完了まで実行する必要がないため、出力の最初の行をより早く表示することができ、クエリ全体が中断された場合、全体的に行われる作業が少なくなります。</target>
        </trans-unit>
        <trans-unit id="fd74b2a71394e7ee81bb386b6917d0be84ba18b0" translate="yes" xml:space="preserve">
          <source>Code Generator</source>
          <target state="translated">コードジェネレータ</target>
        </trans-unit>
        <trans-unit id="47dea711cabe6deab879a9b733dd07b05a63631b" translate="yes" xml:space="preserve">
          <source>Code Of Conduct</source>
          <target state="translated">行動規範</target>
        </trans-unit>
        <trans-unit id="74e1db16aadf744876e02c6a4f106f1aa7afb651" translate="yes" xml:space="preserve">
          <source>Code Of Ethics</source>
          <target state="translated">倫理規定</target>
        </trans-unit>
        <trans-unit id="ae87810899e1431de7026ce043d8dda320fed1e7" translate="yes" xml:space="preserve">
          <source>Code change inspection</source>
          <target state="translated">コード変更検査</target>
        </trans-unit>
        <trans-unit id="b5a54c50fda17aa53c6eedfc8045f9c24c210470" translate="yes" xml:space="preserve">
          <source>Code changes to compile cleanly using OpenWatcom.</source>
          <target state="translated">OpenWatcomを使ってきれいにコンパイルできるようにコードを変更しました。</target>
        </trans-unit>
        <trans-unit id="478104ea503bb6e0eff3a5e3bdba87d5231ae12a" translate="yes" xml:space="preserve">
          <source>Code optimization and refactoring for improved performance.</source>
          <target state="translated">パフォーマンス向上のためのコード最適化とリファクタリング。</target>
        </trans-unit>
        <trans-unit id="c2b53cecb4c71a1d486f72dfb3a0761cddc764ad" translate="yes" xml:space="preserve">
          <source>Coincidentally, that same index is useful for locating the team leader of a particular team:</source>
          <target state="translated">偶然にも、その同じインデックスは、特定のチームのチームリーダーを探すのに便利です。</target>
        </trans-unit>
        <trans-unit id="d5e560637618ccf843afba6188e722395d88af53" translate="yes" xml:space="preserve">
          <source>CollSeq</source>
          <target state="translated">CollSeq</target>
        </trans-unit>
        <trans-unit id="bdc2214c3a09bee2f36f96131835f28a7049fea6" translate="yes" xml:space="preserve">
          <source>Collating functions only matter when comparing string values. Numeric values are always compared numerically, and BLOBs are always compared byte-by-byte using memcmp().</source>
          <target state="translated">照合関数は、文字列の値を比較する場合にのみ問題となります。数値値は常に数値で比較され、BLOB は常に memcmp()を使用してバイト単位で比較されます。</target>
        </trans-unit>
        <trans-unit id="d660ea76dd255d7ad9c4922511054c5e967af78f" translate="yes" xml:space="preserve">
          <source>Collating sequences are used for comparing two text strings. The collating sequence does not change the ordering of NULLs, numbers, or BLOBs, only text.</source>
          <target state="translated">照合シーケンスは、2 つのテキスト文字列を比較するために使用されます。照合シーケンスは、NULL、数値、BLOBの順序を変更せず、テキストのみを比較します。</target>
        </trans-unit>
        <trans-unit id="1e254a056c86801f8b560ebd071943f8829e763e" translate="yes" xml:space="preserve">
          <source>Collation Needed Callbacks</source>
          <target state="translated">照合が必要なコールバック</target>
        </trans-unit>
        <trans-unit id="e0c052d2751435fee70a8eb47de4eb3956e79de1" translate="yes" xml:space="preserve">
          <source>Collectively, the aPgno entries record the database page number stored in all frames of the WAL file. The aPgno[0] entry on the first hash table records the database page number stored in the very first frame in the WAL file. The aPgno[i] entry from the first hash table is the database page number for the i-th frame in the WAL file. The aPgno[k] entry for the second hash table is the database page number for the (k+4062)-th frame in the WAL file. The aPgno[k] entry for the n-th 32768-byte hash table in the shm file (for n&amp;gt;1) holds the database page number stored in the (k+4062+4096*(n-2))-th frame of the WAL file.</source>
          <target state="translated">まとめると、aPgnoエントリは、WALファイルのすべてのフレームに保存されているデータベースページ番号を記録します。最初のハッシュテーブルのaPgno [0]エントリは、WALファイルの最初のフレームに格納されているデータベースページ番号を記録します。最初のハッシュテーブルのaPgno [i]エントリは、WALファイルのi番目のフレームのデータベースページ番号です。 2番目のハッシュテーブルのaPgno [k]エントリは、WALファイルの（k + 4062）番目のフレームのデータベースページ番号です。 shmファイル（n&amp;gt; 1の場合）のn番目の32768バイトのハッシュテーブルのaPgno [k]エントリは、（k + 4062 + 4096 *（n-2））番目のフレームに格納されているデータベースページ番号を保持しますWALファイルの。</target>
        </trans-unit>
        <trans-unit id="d2925a5d74339b84bdd408d91b33688b6815af58" translate="yes" xml:space="preserve">
          <source>Colloquially, the Robson proof shows that in order to guarantee breakdown-free operation, any memory allocator must use a memory pool of size &lt;b&gt;N&lt;/b&gt; which exceeds the maximum amount of memory ever used &lt;b&gt;M&lt;/b&gt; by a multiplier that depends on &lt;b&gt;n&lt;/b&gt;, the ratio of the largest to the smallest allocation size. In other words, unless all memory allocations are of exactly the same size (&lt;b&gt;n&lt;/b&gt;=1) then the system needs access to more memory than it will ever use at one time. Furthermore, we see that the amount of surplus memory required grows rapidly as the ratio of largest to smallest allocations increases, and so there is strong incentive to keep all allocations as near to the same size as possible.</source>
          <target state="translated">口語、保証絶縁破壊のない動作するために、任意のメモリアロケータサイズのメモリ・プールを使用する必要があるロブソンプルーフショー&lt;b&gt;N&lt;/b&gt;今まで使用されるメモリの最大量を超えた&lt;b&gt;M&lt;/b&gt;に依存する乗算器により&lt;b&gt;N&lt;/b&gt;、最大の比率を最小の割り当てサイズに。つまり、すべてのメモリ割り当てがまったく同じサイズ（&lt;b&gt;n&lt;/b&gt; = 1）でない限り、システムは、一度に使用するよりも多くのメモリにアクセスする必要があります。さらに、必要な余剰メモリの量は、最大の割り当てと最小の割り当ての比率が増加するにつれて急速に増加することがわかります。そのため、すべての割り当てをできるだけ同じサイズに近づけたいという強い動機があります。</target>
        </trans-unit>
        <trans-unit id="65ba00e95e60fb8971e699c771908e7c41d91624" translate="yes" xml:space="preserve">
          <source>Column</source>
          <target state="translated">Column</target>
        </trans-unit>
        <trans-unit id="7457b5eaf3d7bfc87797ee1a1767fe0cb49411af" translate="yes" xml:space="preserve">
          <source>Column Contents</source>
          <target state="translated">コラム内容</target>
        </trans-unit>
        <trans-unit id="dc9eb343792aa10d2e4b6816e5d06cae705abefb" translate="yes" xml:space="preserve">
          <source>Column Declared Type</source>
          <target state="translated">カラム宣言型</target>
        </trans-unit>
        <trans-unit id="edbb850ee1e2303abaa75179e5da0bca25a8e6e9" translate="yes" xml:space="preserve">
          <source>Column Definitions</source>
          <target state="translated">カラムの定義</target>
        </trans-unit>
        <trans-unit id="f0e08cc3301877a460436bcf15d46df904fa1c8f" translate="yes" xml:space="preserve">
          <source>Column Name</source>
          <target state="translated">カラム名</target>
        </trans-unit>
        <trans-unit id="cfbfc51b4b3062caab10bcf86299598910467bc8" translate="yes" xml:space="preserve">
          <source>Column Names In A Result Set</source>
          <target state="translated">結果セットのカラム名</target>
        </trans-unit>
        <trans-unit id="2a8d5de5174e3943971a2875266b6881264de3bb" translate="yes" xml:space="preserve">
          <source>Column definition</source>
          <target state="translated">カラムの定義</target>
        </trans-unit>
        <trans-unit id="087b86714eee3da08b0eea49abe7223a80fbe1f7" translate="yes" xml:space="preserve">
          <source>Column filter queries are not available.</source>
          <target state="translated">カラムフィルタクエリは使用できません。</target>
        </trans-unit>
        <trans-unit id="1fb21b8e379e9449d53a5880fcc60a3256a75dc9" translate="yes" xml:space="preserve">
          <source>Column filter specifications may also be applied to arbitrary expressions enclosed in parenthesis. In this case the column filter applies to all phrases within the expression. Nested column filter operations may only further restrict the subset of columns matched, they can not be used to re-enable filtered columns. For example:</source>
          <target state="translated">カラムフィルタの指定は、括弧で囲まれた任意の式にも適用することができます。この場合、カラムフィルタは式内のすべての語句に適用されます。入れ子になったカラムフィルタ操作は、マッチするカラムのサブセットをさらに制限するだけで、フィルタリングされたカラムを再び有効にするために使用することはできません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="8cf5932e078596670c3be6928bc34be28df50868" translate="yes" xml:space="preserve">
          <source>Column names in UPDATE statements were case sensitive. This mistake has now been fixed.</source>
          <target state="translated">UPDATE文のカラム名が大文字と小文字を区別していました。この間違いは修正されました。</target>
        </trans-unit>
        <trans-unit id="c8e2e6347929b3f4a547cbe78f19fbf98ffe174e" translate="yes" xml:space="preserve">
          <source>Column names in the expressions of a DO UPDATE refer to the original unchanged value of the column, before the attempted INSERT. To use the value that would have been inserted had the constraint not failed, add the special &quot;excluded.&quot; table qualifier to the column name.</source>
          <target state="translated">DO UPDATE の式の列名は、INSERT を試行する前の列の元の変更されていない値を参照します。制約が失敗しなかった場合に挿入されていた値を使用するには、特別なテーブル修飾子 &quot;excluded.&quot; を列名に追加します。</target>
        </trans-unit>
        <trans-unit id="032e3b2732306732c32848d470fa8748f95c6026" translate="yes" xml:space="preserve">
          <source>Column zColumn does not exist,</source>
          <target state="translated">列 zColumn が存在しません。</target>
        </trans-unit>
        <trans-unit id="ce5679997a2153bf86b8f374126d7b829b91fac4" translate="yes" xml:space="preserve">
          <source>Column zColumn is part of an index, PRIMARY KEY or UNIQUE constraint and the blob is being opened for read/write access,</source>
          <target state="translated">列 zColumn はインデックス、PRIMARY KEY、または UNIQUE 制約の一部であり、読み書きアクセスのために blob をオープンしています。</target>
        </trans-unit>
        <trans-unit id="e8afcd3f4d854da704b3aef5efd35d7f5bc218f3" translate="yes" xml:space="preserve">
          <source>Column-separator is an optional column separator string. The default is the ASCII tab character \t.</source>
          <target state="translated">Column-separator は、オプションの列区切り文字列です。デフォルトは、ASCII タブ文字の \t です。</target>
        </trans-unit>
        <trans-unit id="cf723c59b62a173547c39c3d661c4ee7c240bab1" translate="yes" xml:space="preserve">
          <source>Columns</source>
          <target state="translated">Columns</target>
        </trans-unit>
        <trans-unit id="56b17410d6d1be4171831dc03181ac757a05e7fe" translate="yes" xml:space="preserve">
          <source>Columns of type INTEGER PRIMARY KEY are actually used as the primary key in underlying B-Tree representation of the table.</source>
          <target state="translated">INTEGER PRIMARY KEY 型のカラムは、テーブルの B-Tree 表現では実際に主キーとして使用されます。</target>
        </trans-unit>
        <trans-unit id="2c97a82dbca5a469c866fbcfd4a0a433b2a0bbf3" translate="yes" xml:space="preserve">
          <source>ColumnsUsed</source>
          <target state="translated">ColumnsUsed</target>
        </trans-unit>
        <trans-unit id="7dbd619aad6c366ee15f8ec72b738cda247ce874" translate="yes" xml:space="preserve">
          <source>Combine the implementations of LIKE and GLOB into a single pattern-matching subroutine.</source>
          <target state="translated">LIKEとGLOBの実装を1つのパターンマッチングサブルーチンに結合します。</target>
        </trans-unit>
        <trans-unit id="1f542b583ad5e9c038e3b491fcfbca274b74980c" translate="yes" xml:space="preserve">
          <source>Combining all the code for SQLite into one big file makes SQLite easier to deploy &amp;mdash; there is just one file to keep track of. And because all code is in a single translation unit, compilers can do better inter-procedure optimization resulting in machine code that is between 5% and 10% faster.</source>
          <target state="translated">SQLiteのすべてのコードを1つの大きなファイルに結合すると、SQLiteの展開が容易になります。追跡するファイルは1つだけです。また、すべてのコードが単一の翻訳単位に含まれているため、コンパイラーはプロシージャー間の最適化を改善して、マシンコードを5％から10％高速化できます。</target>
        </trans-unit>
        <trans-unit id="833e395a74a9048d3a6708096c9bceb3c4d61ab8" translate="yes" xml:space="preserve">
          <source>Comes with a standalone &lt;a href=&quot;cli&quot;&gt;command-line interface&lt;/a&gt; (CLI) client that can be used to administer SQLite databases.</source>
          <target state="translated">SQLiteデータベースの管理に使用できるスタンドアロンの&lt;a href=&quot;cli&quot;&gt;コマンドラインインターフェイス&lt;/a&gt;（CLI）クライアントが付属しています。</target>
        </trans-unit>
        <trans-unit id="606ffe665dbeafe4183539a3e178cfb9ca0e425d" translate="yes" xml:space="preserve">
          <source>Command Line Shell For SQLite</source>
          <target state="translated">SQLite用コマンドラインシェル</target>
        </trans-unit>
        <trans-unit id="fce06e20e5f7f74aacccab40b59b75a56c8f7305" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">Comments</target>
        </trans-unit>
        <trans-unit id="0538dff4886a4148d161292cddf7f24f025bd278" translate="yes" xml:space="preserve">
          <source>Comments are not SQL commands, but can occur within the text of SQL queries passed to &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and related interfaces. Comments are treated as whitespace by the parser. Comments can begin anywhere whitespace can be found, including inside expressions that span multiple lines.</source>
          <target state="translated">コメントはSQLコマンドではありませんが、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;および関連するインターフェースに渡されるSQLクエリのテキスト内で発生する可能性があります。コメントはパーサーによって空白として扱われます。コメントは、複数行にまたがる式の中など、空白が見つかる場所ならどこからでも開始できます。</target>
        </trans-unit>
        <trans-unit id="ce2337551468efeca0ed2bee143ae11b7529f35e" translate="yes" xml:space="preserve">
          <source>Comments can appear anywhere whitespace can occur, including inside expressions and in the middle of other SQL statements. Comments do not nest.</source>
          <target state="translated">コメントは、式の中や他のSQL文の途中など、空白が発生する可能性のある場所に表示することができます。コメントはネストしません。</target>
        </trans-unit>
        <trans-unit id="ffc61bb49c86bffaff083a2ed5fcbad20841a45a" translate="yes" xml:space="preserve">
          <source>Commit And Rollback Notification Callbacks</source>
          <target state="translated">コミットとロールバック通知のコールバック</target>
        </trans-unit>
        <trans-unit id="b67528525c7cbe3a2bdfe091a15601f0cfe434dc" translate="yes" xml:space="preserve">
          <source>Commit the transaction started in step 2.</source>
          <target state="translated">ステップ2で開始したトランザクションをコミットします。</target>
        </trans-unit>
        <trans-unit id="3e921ad8fb3469be1c1aae1e9c542f259ea843f7" translate="yes" xml:space="preserve">
          <source>Commit the transaction started on step 1 above.</source>
          <target state="translated">上記のステップ1で開始したトランザクションをコミットします。</target>
        </trans-unit>
        <trans-unit id="dcb41d75c37afedd19b91ddeac8ef4a861184289" translate="yes" xml:space="preserve">
          <source>Committing a</source>
          <target state="translated">コミット</target>
        </trans-unit>
        <trans-unit id="ca50d239d0c5f707752157b74490a4762cc31cc1" translate="yes" xml:space="preserve">
          <source>Committing a Transaction</source>
          <target state="translated">トランザクションのコミット</target>
        </trans-unit>
        <trans-unit id="a6b2b4078078c94d88c10ba671b8570bcd19b64c" translate="yes" xml:space="preserve">
          <source>Committing a multi-file transaction.</source>
          <target state="translated">複数ファイルのトランザクションをコミットします。</target>
        </trans-unit>
        <trans-unit id="938c8ff92d76193cdabf706c7c9bd4d6322fdb0d" translate="yes" xml:space="preserve">
          <source>Committing a read-write transaction.</source>
          <target state="translated">読み書き可能なトランザクションをコミットします。</target>
        </trans-unit>
        <trans-unit id="7f07598efa7d083be720757f9b4819e013d7faa3" translate="yes" xml:space="preserve">
          <source>Committing a statement transaction.</source>
          <target state="translated">ステートメントトランザクションをコミットします。</target>
        </trans-unit>
        <trans-unit id="3d0965b4050b33d43b6f8f1d0b90555ef5b6f358" translate="yes" xml:space="preserve">
          <source>Common Table Expressions or CTEs act like temporary &lt;a href=&quot;lang_createview&quot;&gt;views&lt;/a&gt; that exist only for the duration of a single SQL statement. There are two kinds of common table expressions: &quot;ordinary&quot; and &quot;recursive&quot;. Ordinary common table expressions are helpful for making queries easier to understand by factoring subqueries out of the main SQL statement. Recursive common table expressions provide the ability to do hierarchical or recursive queries of trees and graphs, a capability that is not otherwise available in the SQL language.</source>
          <target state="translated">共通テーブル式またはCTE は、単一のSQLステートメントの間だけ存在する一時&lt;a href=&quot;lang_createview&quot;&gt;ビューの&lt;/a&gt;ように機能します。一般的なテーブル式には、「通常」と「再帰的」の2種類があります。通常の共通テーブル式は、メインSQLステートメントからサブクエリを分解してクエリを理解しやすくするのに役立ちます。再帰的共通テーブル式は、ツリーやグラフの階層的または再帰的クエリを実行する機能を提供します。これは、SQL言語では使用できない機能です。</target>
        </trans-unit>
        <trans-unit id="8d105cf44d3926289e65c1c83d8e37cb23fd049e" translate="yes" xml:space="preserve">
          <source>Compare</source>
          <target state="translated">Compare</target>
        </trans-unit>
        <trans-unit id="61bf40991dc6cf79e005a417dde1c212c92bf988" translate="yes" xml:space="preserve">
          <source>Compare the ages of two snapshot handles</source>
          <target state="translated">2つのスナップショットハンドルの年齢を比較する</target>
        </trans-unit>
        <trans-unit id="c69b8e330786eb35150cb1cdb917926c81985161" translate="yes" xml:space="preserve">
          <source>Compare the ages of two snapshot handles.</source>
          <target state="translated">2つのスナップショットハンドルの年齢を比較します。</target>
        </trans-unit>
        <trans-unit id="b7893f36396a39c33c9b065563149f1fc3b7de3a" translate="yes" xml:space="preserve">
          <source>Compare the values in register P1 and P3. If reg(P3)&amp;lt;reg(P1) then jump to address P2. Or if the SQLITE_STOREP2 flag is set in P5 store the result of comparison (0 or 1 or NULL) into register P2.</source>
          <target state="translated">レジスタP1とP3の値を比較します。reg（P3）&amp;lt;reg（P1）の場合、アドレスP2にジャンプします。または、SQLITE_STOREP2フラグがP5で設定されている場合は、比較結果（0または1またはNULL）をレジスタP2に格納します。</target>
        </trans-unit>
        <trans-unit id="64f72da6a28852747af852811f0159350ec037fd" translate="yes" xml:space="preserve">
          <source>Compare the values in register P1 and P3. If reg(P3)==reg(P1) then jump to address P2. Or if the SQLITE_STOREP2 flag is set in P5, then store the result of comparison in register P2.</source>
          <target state="translated">レジスタP1とP3の値を比較します。reg(P3)==reg(P1)ならば、アドレスP2にジャンプします。または、P5 に SQLITE_STOREP2 フラグが設定されている場合は、比較結果をレジスタ P2 に格納します。</target>
        </trans-unit>
        <trans-unit id="716736d76052378cdb4fa2fb220c0af66c296429" translate="yes" xml:space="preserve">
          <source>Compare two vectors of registers in reg(P1)..reg(P1+P3-1) (call this vector &quot;A&quot;) and in reg(P2)..reg(P2+P3-1) (&quot;B&quot;). Save the result of the comparison for use by the next &lt;a href=&quot;opcode#Jump&quot;&gt;Jump&lt;/a&gt; instruct.</source>
          <target state="translated">reg（P1）.. reg（P1 + P3-1）（このベクトルを &quot;A&quot;と呼ぶ）とreg（P2）.. reg（P2 + P3-1）（ &quot;B&quot;）の2つのレジスターのベクトルを比較します。比較の結果を保存して、次の&lt;a href=&quot;opcode#Jump&quot;&gt;Jump&lt;/a&gt;命令で使用します。</target>
        </trans-unit>
        <trans-unit id="83d5898be3634e470654cbd85b9deec85a9c9f73" translate="yes" xml:space="preserve">
          <source>Comparison affinity rules</source>
          <target state="translated">比較親和性のルール</target>
        </trans-unit>
        <trans-unit id="134badaaa974d64bb5437d6b34d1293f7d86554c" translate="yes" xml:space="preserve">
          <source>Comparison expressions</source>
          <target state="translated">表現の比較</target>
        </trans-unit>
        <trans-unit id="8f31c13dc4b4da5bf8cbe8bac8ef033f779731d8" translate="yes" xml:space="preserve">
          <source>Comparison with fts4</source>
          <target state="translated">fts4との比較</target>
        </trans-unit>
        <trans-unit id="5d60c7dd62fdcf4abcc61a6a7d335b7117968b4d" translate="yes" xml:space="preserve">
          <source>Compatibility</source>
          <target state="translated">Compatibility</target>
        </trans-unit>
        <trans-unit id="7637a56b8025cf4632b2ae465571d61372b6d40e" translate="yes" xml:space="preserve">
          <source>Compatibility node: Prior to SQLite version 3.28.0 (2019-04-16) only the --update option was supported but that option worked like --insert in that it always reinserted every file regardless of whether or not it had changed.</source>
          <target state="translated">互換性のあるノードです。SQLite バージョン 3.28.0 (2019-04-16)より前のバージョンでは --update オプションのみがサポートされていましたが、このオプションは --insert と同様に動作し、ファイルが変更されたかどうかに関わらず、常にすべてのファイルを再挿入していました。</target>
        </trans-unit>
        <trans-unit id="633ffa201e66fd459288742adf70c255cf4ddcdc" translate="yes" xml:space="preserve">
          <source>Compile SQLite in an as-delivered configuration, without any special telemetry or debugging options.</source>
          <target state="translated">特別なテレメトリやデバッグオプションを使用せずに、配信された構成でSQLiteをコンパイルします。</target>
        </trans-unit>
        <trans-unit id="4435f0088179f3879b5ae857aab9a8517a3bf84a" translate="yes" xml:space="preserve">
          <source>Compile SQLite using the &lt;a href=&quot;compile#trusted_schema&quot;&gt;-DSQLITE_TRUSTED_SCHEMA=0&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#trusted_schema&quot;&gt;-DSQLITE_TRUSTED_SCHEMA = 0&lt;/a&gt;コンパイル時オプションを使用してSQLiteをコンパイルします。</target>
        </trans-unit>
        <trans-unit id="47c942ddb7cb0b2c2a634cd495a4fe44be7c77ab" translate="yes" xml:space="preserve">
          <source>Compile SQLite using the &lt;a href=&quot;compile#trusted_schema&quot;&gt;-DSQLITE_TRUSTED_SCHEMA=0&lt;/a&gt; compile-time option. This make SQLite distrust application-defined functions inside of the schema by default.</source>
          <target state="translated">&lt;a href=&quot;compile#trusted_schema&quot;&gt;-DSQLITE_TRUSTED_SCHEMA = 0&lt;/a&gt;コンパイル時オプションを使用してSQLiteをコンパイルします。これにより、SQLiteはデフォルトでスキーマ内のアプリケーション定義関数を信用しなくなります。</target>
        </trans-unit>
        <trans-unit id="7a5b8e5cc0e47f26d2d005f2486e0f5c2a2c206c" translate="yes" xml:space="preserve">
          <source>Compile fts</source>
          <target state="translated">ftsをコンパイル</target>
        </trans-unit>
        <trans-unit id="107e25274d1b787330bb17ec68cf503455bc4672" translate="yes" xml:space="preserve">
          <source>Compile the SQLite library with the either the compile-time options &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES=1&lt;/a&gt; or &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES=2&lt;/a&gt;. Support for 8+3 filenames is not included in SQLite by default because it does introduce some overhead. The overhead is tiny, but even so, we do not want to burden the billions of SQLite applications that do not need 8+3 filename support.</source>
          <target state="translated">コンパイル時オプション&lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES = 1&lt;/a&gt;または&lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES = 2を&lt;/a&gt;使用して、SQLiteライブラリをコンパイルします。8 + 3のファイル名のサポートは、オーバーヘッドを引き起こすため、デフォルトではSQLiteに含まれていません。オーバーヘッドはわずかですが、それでも、8 + 3のファイル名サポートを必要としない何十億ものSQLiteアプリケーションに負担をかけたくありません。</target>
        </trans-unit>
        <trans-unit id="c8149cd52fe785ecf8f59126442a4f04b3761167" translate="yes" xml:space="preserve">
          <source>Compile-Time Authorization Callbacks</source>
          <target state="translated">コンパイル時認可コールバック</target>
        </trans-unit>
        <trans-unit id="5ce286997996977a2b237b29a86f8db1efc35204" translate="yes" xml:space="preserve">
          <source>Compile-Time Library Version Numbers</source>
          <target state="translated">コンパイルタイムライブラリのバージョン番号</target>
        </trans-unit>
        <trans-unit id="ab7d35e46c49beab638f326c5a28b5f3ad2b8c85" translate="yes" xml:space="preserve">
          <source>Compile-time Options</source>
          <target state="translated">コンパイル時間オプション</target>
        </trans-unit>
        <trans-unit id="1453f0519dea087605be7dc19703a1f478ff0ab3" translate="yes" xml:space="preserve">
          <source>Compile-time options OS_UNIX, OS_WIN, OS_OS2, OS_OTHER, and TEMP_STORE have been renamed to include an &quot;SQLITE_&quot; prefix in order to help avoid namespace collisions with application software. The new names of these options are respectively: SQLITE_OS_UNIX, SQLITE_OS_WIN, SQLITE_OS_OS2, SQLITE_OS_OTHER, and &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;.</source>
          <target state="translated">コンパイル時オプションOS_UNIX、OS_WIN、OS_OS2、OS_OTHER、およびTEMP_STOREの名前が変更され、アプリケーションソフトウェアとのネームスペースの競合を回避するために「SQLITE_」プレフィックスが含まれるようになりました。これらのオプションの新しい名前は、それぞれSQLITE_OS_UNIX、SQLITE_OS_WIN、SQLITE_OS_OS2、SQLITE_OS_OTHER、および&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="b67395ae5988ac5f1079e7140abc23ed771501d4" translate="yes" xml:space="preserve">
          <source>Compile-time options to SQLite are controlled by C-preprocessor macros. SQLite version 3.6.0 changes the names of some of these macros so that all C-preprocessor macros that are specific to SQLite begin with the &quot;SQLITE_&quot; prefix. This is done to reduce the risk of name collisions with other software modules.</source>
          <target state="translated">SQLite のコンパイル時オプションは、C プリプロセッサ マクロによって制御されます。SQLite バージョン 3.6.0 では、これらのマクロの一部の名前が変更され、SQLite に固有の C プリプロセッサ マクロはすべて接頭辞 &quot;SQLITE_&quot; で始まるようになりました。これは、他のソフトウェア モジュールと名前が衝突するリスクを減らすためです。</target>
        </trans-unit>
        <trans-unit id="7bfb67af50943c68cc8db4a086f448c070c20b10" translate="yes" xml:space="preserve">
          <source>Compiling An SQL Statement</source>
          <target state="translated">SQLステートメントのコンパイル</target>
        </trans-unit>
        <trans-unit id="5aad775a4fde57c9a7d789da7ebb4f28bacbccb3" translate="yes" xml:space="preserve">
          <source>Compiling Loadable Extensions</source>
          <target state="translated">ロード可能な拡張機能のコンパイル</target>
        </trans-unit>
        <trans-unit id="17dae604367670c84a2179095a23e948fe606538" translate="yes" xml:space="preserve">
          <source>Compiling the CLI</source>
          <target state="translated">CLIのコンパイル</target>
        </trans-unit>
        <trans-unit id="42bc083c37979291f51503e346021e5adf7ef736" translate="yes" xml:space="preserve">
          <source>Compiling the TCL interface</source>
          <target state="translated">TCLインターフェースのコンパイル</target>
        </trans-unit>
        <trans-unit id="f6b7336de511d34be1007604b55dc1686fbabd26" translate="yes" xml:space="preserve">
          <source>Compiling with GCC and -Os results in a binary that is slightly less than 500KB in size. (Update 2018-07-07: Due to the addition of new features such as &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt; and &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt;, the library footprint is now slightly larger than 500KB.)</source>
          <target state="translated">GCCおよび-Oを使用してコンパイルすると、サイズが500KBをわずかに下回るバイナリが生成されます。（2018-07-07の更新：&lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt;や&lt;a href=&quot;windowfunctions&quot;&gt;ウィンドウ関数&lt;/a&gt;などの新機能の追加により、ライブラリのフットプリントは500KBよりわずかに大きくなりました。）</target>
        </trans-unit>
        <trans-unit id="016600cc08f9b09c5ede26e00051860d386d3258" translate="yes" xml:space="preserve">
          <source>Completely disable all mutexing for use in single-threaded applications.</source>
          <target state="translated">シングルスレッドアプリケーションで使用するために、すべてのミューテックスを完全に無効にします。</target>
        </trans-unit>
        <trans-unit id="92cab31e763f04f0a9379d06fa22ebdf435b210d" translate="yes" xml:space="preserve">
          <source>Completion = 100% * (pagecount() - remaining()) / pagecount()</source>
          <target state="translated">完成度=100%*(pagecount()-remaining())/pagecount()</target>
        </trans-unit>
        <trans-unit id="0e8198cb08e14211a17b2113a2bd05ad2475de6d" translate="yes" xml:space="preserve">
          <source>Complex SQL queries that compile down to large &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt;.</source>
          <target state="translated">コンパイルして大きな&lt;a href=&quot;c3ref/stmt&quot;&gt;準備済みステートメントに&lt;/a&gt;変換する複雑なSQLクエリ。</target>
        </trans-unit>
        <trans-unit id="2a71a43f0af5e946760833a731194bc756332728" translate="yes" xml:space="preserve">
          <source>Component tables must not be declared WITHOUT ROWID, and must all have the same schema, but may have different names within their databases. In this context, &quot;the same schema&quot; means that:</source>
          <target state="translated">コンポーネントテーブルは、WITHOUT ROWIDで宣言されてはならず、すべて同じスキーマを持っていなければなりませんが、そのデータベース内では異なる名前を持つことができます。この文脈では、「同じスキーマ」とは、次のような意味です。</target>
        </trans-unit>
        <trans-unit id="73fefbebc7ea5875c1b1def30f50ddaec200fca3" translate="yes" xml:space="preserve">
          <source>Compound SELECT Statements</source>
          <target state="translated">複合SELECT文</target>
        </trans-unit>
        <trans-unit id="fc1dbf04d5c2c01646f4f6f5a41a610a2c9e6452" translate="yes" xml:space="preserve">
          <source>Compound SELECT statements joined by UNION, EXCEPT, or INTERSECT</source>
          <target state="translated">UNION、EXCEPT、またはINTERSECTで結合された複合SELECT文</target>
        </trans-unit>
        <trans-unit id="b777b90633cd6198da59fc74556aaf318e15c82b" translate="yes" xml:space="preserve">
          <source>Compound Select Statements</source>
          <target state="translated">複合セレクト文</target>
        </trans-unit>
        <trans-unit id="41afde278d24cef38341e9c639a6f290a66a33e9" translate="yes" xml:space="preserve">
          <source>Compound select</source>
          <target state="translated">コンパウンドセレクト</target>
        </trans-unit>
        <trans-unit id="e99b67d469ceb0e0903f3fdb83544c4883bac6aa" translate="yes" xml:space="preserve">
          <source>Compressed FTS4 content</source>
          <target state="translated">圧縮されたFTS4コンテンツ</target>
        </trans-unit>
        <trans-unit id="d750266cb42e04add18c2049e2c2458292889a29" translate="yes" xml:space="preserve">
          <source>Compute all columns for the current row of the result.</source>
          <target state="translated">結果の現在の行のすべての列を計算します。</target>
        </trans-unit>
        <trans-unit id="83c78585de25cd96c1c2ab80c2c2412af55dbfdf" translate="yes" xml:space="preserve">
          <source>Compute the Mandelbrot set</source>
          <target state="translated">マンデルブロ集合を計算する</target>
        </trans-unit>
        <trans-unit id="b448f9527d237644e1fc4a194d188e6a4b4d1334" translate="yes" xml:space="preserve">
          <source>Compute the current date.</source>
          <target state="translated">現在の日付を計算します。</target>
        </trans-unit>
        <trans-unit id="41873a1f5500f4b614234079571f3016e43ab82f" translate="yes" xml:space="preserve">
          <source>Compute the current unix timestamp.</source>
          <target state="translated">現在の unix タイムスタンプを計算します。</target>
        </trans-unit>
        <trans-unit id="e04bc35c7b102a71d56a8c32d3bd5fac01970545" translate="yes" xml:space="preserve">
          <source>Compute the date and time given a unix timestamp 1092941466, and compensate for your local timezone.</source>
          <target state="translated">日付と時刻を計算し、UNIXタイムスタンプ1092941466を与えられ、あなたのローカルタイムゾーンを補正します。</target>
        </trans-unit>
        <trans-unit id="a79ce5022e7222955180721f104a747e76cc865d" translate="yes" xml:space="preserve">
          <source>Compute the date and time given a unix timestamp 1092941466.</source>
          <target state="translated">unix タイムスタンプ 1092941466 が与えられた日時を計算します。</target>
        </trans-unit>
        <trans-unit id="876432c3d5981b5bb35c00fb0bc71a0643cea495" translate="yes" xml:space="preserve">
          <source>Compute the date of the first Tuesday in October for the current year.</source>
          <target state="translated">現在の年の10月の第1火曜日の日付を計算します。</target>
        </trans-unit>
        <trans-unit id="85e08c9c66c5c14d3d7f7fdaf91b03031363b7fc" translate="yes" xml:space="preserve">
          <source>Compute the hash value: h = P * 383</source>
          <target state="translated">ハッシュ値を計算する:h=P*383</target>
        </trans-unit>
        <trans-unit id="7548a41024e6603fd25f9fadf45476eb046bf623" translate="yes" xml:space="preserve">
          <source>Compute the last day of the current month.</source>
          <target state="translated">現在の月の最終日を計算します。</target>
        </trans-unit>
        <trans-unit id="1c0a0d1208aea03d34c1fcb88dbad15854e8464f" translate="yes" xml:space="preserve">
          <source>Compute the number of days since the signing of the US Declaration of Independence.</source>
          <target state="translated">アメリカの独立宣言に署名してからの日数を計算します。</target>
        </trans-unit>
        <trans-unit id="5d82004a2aadc6ec6baebba8982b8bfbd8ed18a8" translate="yes" xml:space="preserve">
          <source>Compute the number of seconds since a particular moment in 2004:</source>
          <target state="translated">2004年のある瞬間からの秒数を計算します。</target>
        </trans-unit>
        <trans-unit id="9240e490f170f5bfe9b5ac2684f082567e717920" translate="yes" xml:space="preserve">
          <source>Compute the remainder after integer register P2 is divided by register P1 and store the result in register P3. If the value in register P1 is zero the result is NULL. If either operand is NULL, the result is NULL.</source>
          <target state="translated">整数レジスタP2をレジスタP1で除算した後の余りを計算し、その結果をレジスタP3に格納します。レジスタP1の値が0の場合、結果はNULLになります。どちらかのオペランドがNULLの場合、結果はNULLになります。</target>
        </trans-unit>
        <trans-unit id="f47380023b575b27550d43814811cc725e477ad2" translate="yes" xml:space="preserve">
          <source>Compute the time since the unix epoch in seconds (like strftime('%s','now') except includes fractional part):</source>
          <target state="translated">unix エポックからの時間を秒単位で計算します (strftime('%s','now')のように、小数点以下の部分を除いて)。</target>
        </trans-unit>
        <trans-unit id="e144db42c7fe7841a847f92a642087b247050e3f" translate="yes" xml:space="preserve">
          <source>Compute the transitive closure of a set.</source>
          <target state="translated">集合の推移的閉塞を計算します。</target>
        </trans-unit>
        <trans-unit id="6ad79ab6353b1eee8ebbc085e10d17c4fcfb024f" translate="yes" xml:space="preserve">
          <source>Concat</source>
          <target state="translated">Concat</target>
        </trans-unit>
        <trans-unit id="bbae6853fb6e0fd40e4ce00a77adbb0072630198" translate="yes" xml:space="preserve">
          <source>Concatenate Two Changeset Objects</source>
          <target state="translated">2 つのチェンジセットオブジェクトを連結</target>
        </trans-unit>
        <trans-unit id="dbcb0f9023d09dcdfc6e54ecf5de70332ecf46a5" translate="yes" xml:space="preserve">
          <source>Conceptually, the wal-index is shared memory, though the current VFS implementations use a memory-mapped file for operating-system portability. The memory-mapped file is in the same directory as the database and has the same name as the database with a &quot;&lt;code&gt;-shm&lt;/code&gt;&quot; suffix appended. Because the wal-index is shared memory, SQLite does not support &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode=WAL&lt;/a&gt; on a network filesystem when clients are on different machines, as all clients of the database must be able to share the same memory.</source>
          <target state="translated">概念的には、wal-indexは共有メモリですが、現在のVFS実装では、オペレーティングシステムの移植性のためにメモリマップファイルを使用しています。メモリマップファイルはデータベースと同じディレクトリにあり、データベースと同じ名前に &quot; &lt;code&gt;-shm&lt;/code&gt; &quot;サフィックスが追加されています。 wal-indexは共有メモリであるため、クライアントが異なるマシン上にある場合、データベースのすべてのクライアントが同じメモリを共有できる必要があるため、SQLiteはネットワークファイルシステムでの&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode = WAL&lt;/a&gt;をサポートしません。</target>
        </trans-unit>
        <trans-unit id="49b7441ed47d615d68b5fa69e66989fb88012252" translate="yes" xml:space="preserve">
          <source>Conceptually, there is just a single DELETE-mode lock. The DELETE-mode lock for a single database connection can be in exactly one of the following states:</source>
          <target state="translated">概念的には、単一のDELETEモードロックが存在するだけです。単一のデータベース接続のDELETEモードロックは、以下の状態のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="7a3f4c2c7a172166630a7d362c10fe1d0fc91c29" translate="yes" xml:space="preserve">
          <source>Concurrent Use By Multiple Processes</source>
          <target state="translated">複数プロセスによる同時使用</target>
        </trans-unit>
        <trans-unit id="eef82957c155636f622355147508a53bea076447" translate="yes" xml:space="preserve">
          <source>Configurable edit distances</source>
          <target state="translated">設定可能な編集距離</target>
        </trans-unit>
        <trans-unit id="b8577c99aaca7f628cb921ee68fce4bf962909c4" translate="yes" xml:space="preserve">
          <source>Configuration Options</source>
          <target state="translated">設定オプション</target>
        </trans-unit>
        <trans-unit id="e6080fcd15996fc8da790077d2f333df934dd233" translate="yes" xml:space="preserve">
          <source>Configuration continues to use the SQLITE_DBCONFIG_LOOKASIDE or SQLITE_CONFIG_LOOKASIDE configuration options, as described above, with parameters &quot;sz&quot; and &quot;cnt&quot;. The total heap space used for lookaside continues to be sz*cnt bytes. But the space is allocated between the small-slot lookaside and big-slot lookaside, with preference given to small-slot lookaside. The total number of slots will usually exceed &quot;cnt&quot;, since &quot;sz&quot; is typically much larger than the small-slot size of 128 bytes.</source>
          <target state="translated">設定は、前述のSQLITE_DBCONFIG_LOOKASIDEまたはSQLITE_CONFIG_LOOKASIDE設定オプションを、パラメータ &quot;sz &quot;と &quot;cnt &quot;で引き続き使用します。lookasideに使用される総ヒープ空間は、sz*cntバイトであることに変わりはありません。しかし、スペースはスモールスロットルアーサイドとビッグスロットルアーサイドの間に割り当てられ、スモールスロットルアーサイドが優先される。スロットの総数は通常、&quot;sz &quot;が通常128バイトのスモールスロットサイズよりもはるかに大きいため、&quot;cnt &quot;を超えることになる。</target>
        </trans-unit>
        <trans-unit id="5d3a088dea7acb9fc65cbb6e86dc351c6aa1d47c" translate="yes" xml:space="preserve">
          <source>Configure a changeset rebaser object</source>
          <target state="translated">チェンジセットリベイザーオブジェクトを構成する</target>
        </trans-unit>
        <trans-unit id="c2e506c363291ec2edbc4c00e46f58bf68ba2d4e" translate="yes" xml:space="preserve">
          <source>Configure a changeset rebaser object.</source>
          <target state="translated">チェンジセットリベイザーオブジェクトを構成します。</target>
        </trans-unit>
        <trans-unit id="1cfd39d93ce243f8209e2cb0fd6a72bd5199a441" translate="yes" xml:space="preserve">
          <source>Configure an auto-checkpoint</source>
          <target state="translated">自動チェックポイントの設定</target>
        </trans-unit>
        <trans-unit id="5cda84f2fffb92ec6200fae3e17f21d369027339" translate="yes" xml:space="preserve">
          <source>Configure database connections</source>
          <target state="translated">データベース接続の設定</target>
        </trans-unit>
        <trans-unit id="9104fdd73ba3ec2b0c456f6d3cca5876e340e73f" translate="yes" xml:space="preserve">
          <source>Configure global parameters</source>
          <target state="translated">グローバルパラメータの設定</target>
        </trans-unit>
        <trans-unit id="fffa5ae7207c4ce72ae9a5c16488369d68b30ee7" translate="yes" xml:space="preserve">
          <source>Configure the changeset rebaser object to rebase changesets according to the conflict resolutions described by buffer pRebase (size nRebase bytes), which must have been obtained from a previous call to sqlite3changeset_apply_v2().</source>
          <target state="translated">バッファpRebase (サイズnRebaseバイト)で記述された競合解決に従ってチェンジセットをリベースするようにチェンジセットリベースオブジェクトを構成します。</target>
        </trans-unit>
        <trans-unit id="037fffb22a00fbc77fceb8bfd136c7237a83b229" translate="yes" xml:space="preserve">
          <source>Configuring Memory-Mapped I/O</source>
          <target state="translated">メモリマップドI/Oの構成</target>
        </trans-unit>
        <trans-unit id="9d3bc7d832ae044f63c47a2f9e7fae292f78d77f" translate="yes" xml:space="preserve">
          <source>Configuring The SQLite Library</source>
          <target state="translated">SQLite ライブラリの設定</target>
        </trans-unit>
        <trans-unit id="3479acef100487d6ec8205ddc884e90381568fa7" translate="yes" xml:space="preserve">
          <source>Configuring an ON UPDATE or ON DELETE action does not mean that the foreign key constraint does not need to be satisfied. For example, if an &quot;ON DELETE SET DEFAULT&quot; action is configured, but there is no row in the parent table that corresponds to the default values of the child key columns, deleting a parent key while dependent child keys exist still causes a foreign key violation. For example:</source>
          <target state="translated">ON UPDATEまたはON DELETEアクションを構成しても、外部キー制約を満たす必要がないという意味ではありません。例えば、&quot;ON DELETE SET DEFAULT &quot;アクションが構成されていても、親テーブルに子キー列のデフォルト値に対応する行がない場合、従属する子キーが存在する間に親キーを削除すると、外部キー違反が発生します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="377ada5c437e4e8ecbb86b359c764c7d510c3e88" translate="yes" xml:space="preserve">
          <source>Conflict Resolution Algorithms</source>
          <target state="translated">紛争解決アルゴリズム</target>
        </trans-unit>
        <trans-unit id="8975355354bcb513bcd2981e89b88a2159127a86" translate="yes" xml:space="preserve">
          <source>Conflict resolution modes</source>
          <target state="translated">紛争解決モード</target>
        </trans-unit>
        <trans-unit id="9658bf354692dbe100fe5694b8f321b7b117d4a0" translate="yes" xml:space="preserve">
          <source>Conflict-algorithm must be one of the SQLite conflict algorithms for the INSERT statement:</source>
          <target state="translated">競合アルゴリズムは、INSERT文のSQLite競合アルゴリズムの1つでなければなりません。</target>
        </trans-unit>
        <trans-unit id="af76481a91ddbca2a009d9ab58cd9c8e2ed5ef31" translate="yes" xml:space="preserve">
          <source>Connections hold an exclusive lock when change in between WAL mode and any of the various rollback-modes. Connections might also attempt to obtain an EXCLUSIVE lock when they disconnect from WAL mode. If a connection is able to obtain an EXCLUSIVE lock, that means it is the only connection to the database and so it may attempt to checkpoint and then delete the WAL-index and WAL files.</source>
          <target state="translated">接続は、WAL モードとさまざまなロールバック・モードの間で変更するときに排他的なロックを保持します。また、接続は、WALモードから切断したときに排他的ロックを取得しようとすることがあります。接続がEXCLUSIVEロックを取得できた場合、それはデータベースへの唯一の接続であることを意味し、チェックポイントしてからWAL-indexとWALファイルを削除しようとするかもしれません。</target>
        </trans-unit>
        <trans-unit id="aec1d9b262374bdba4b3ad5a6350b6ef2fd31b30" translate="yes" xml:space="preserve">
          <source>Consider a different database with &quot;CREATE TABLE big(json JSON)&quot;. To see a complete line-by-line decomposition of the data:</source>
          <target state="translated">CREATE TABLE big(json JSON)」で別のデータベースを考えてみましょう。データを1行ごとに完全に分解したものを見るには</target>
        </trans-unit>
        <trans-unit id="89d5e40d39c9d5acb3a34ddf23480e47ca55947d" translate="yes" xml:space="preserve">
          <source>Consider a slightly different scenario:</source>
          <target state="translated">少し変わったシナリオを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="c5d0d6c9988bc87a91e1eceb2b1190187ebda45c" translate="yes" xml:space="preserve">
          <source>Consider a table (shown below) intended to store a vocabulary of words together with a count of the number of occurrences of each word in some text corpus:</source>
          <target state="translated">あるテキストコーパスに含まれる各単語の出現回数のカウントと一緒に単語の語彙を保存するための表(以下に示す)を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="8ec68a1b2150a873bc929bf5c86810425d54b691" translate="yes" xml:space="preserve">
          <source>Consider a table such as the following:</source>
          <target state="translated">以下のような表を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="163f9a2c7a0b11befe42d8af38ac3f4e6b7bc949" translate="yes" xml:space="preserve">
          <source>Consider a table that describes the members of an organization as well as the chain-of-command within that organization:</source>
          <target state="translated">組織のメンバーと、その組織内での指揮命令系統を記述した表を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="4d89aaebca400a1430435ad2d544ef0799645f0e" translate="yes" xml:space="preserve">
          <source>Consider an example. Suppose you are trying to insert a string value into a database table where the string value was obtained from user input. Suppose the string to be inserted is stored in a variable named zString. The code to do the insertion might look like this:</source>
          <target state="translated">例を考えてみましょう。文字列の値がユーザ入力から取得されたデータベース・テーブルに文字列の値を挿入しようとしているとします。挿入する文字列が zString という名前の変数に格納されているとします。挿入するコードは次のようになります。</target>
        </trans-unit>
        <trans-unit id="968f255a5a54f60fb698955e4fcb28ea4353bc5f" translate="yes" xml:space="preserve">
          <source>Consider explicit collate clauses when matching WHERE constraints to indices in the query optimizer. Ticket #2391</source>
          <target state="translated">クエリオプティマイザでWHERE制約をインデックスにマッチングさせる際に、明示的な照合句を考慮するようにしました。チケット #2391</target>
        </trans-unit>
        <trans-unit id="444e122b76db00a9b4c3d12c64b80faed572e3e1" translate="yes" xml:space="preserve">
          <source>Consider how this query works. The initial-select runs first and returns a single row with a single column &quot;1&quot;. This one row is added to the queue. In step 2a, that one row is extracted from the queue and added to &quot;cnt&quot;. Then the recursive-select is run in accordance with step 2c generating a single new row with value &quot;2&quot; to add to the queue. The queue still has one row, so step 2 repeats. The &quot;2&quot; row is extracted and added to the recursive table by steps 2a and 2b. Then the row containing 2 is used as if it were the complete content of the recursive table and the recursive-select is run again, resulting in a row with value &quot;3&quot; being added to the queue. This repeats 999999 times until finally at step 2a the only value on the queue is a row containing 1000000. That row is extracted and added to the recursive table. But this time, the WHERE clause causes the recursive-select to return no rows, so the queue remains empty and the recursion stops.</source>
          <target state="translated">このクエリがどのように動作するかを考えてみましょう。最初に初期選択が実行され、1つの列 &quot;1 &quot;を持つ1つの行が返されます。この1行がキューに追加される。ステップ2aでは、その1行がキューから抽出され、&quot;cnt &quot;に追加される。その後、再帰的選択は、ステップ2cに従って実行され、キューに追加するために、値 &quot;2 &quot;を持つ単一の新しい行を生成する。キューはまだ1つの行を持っているので、ステップ2が繰り返されます。2 &quot;行は抽出され、ステップ2aと2bによって再帰テーブルに追加される。その後、2を含む行は、あたかも再帰テーブルの完全な内容であるかのように使用され、再帰的選択が再び実行され、結果として、値 &quot;3 &quot;を持つ行がキューに追加される。これは、最終的にステップ2aでキュー上の唯一の値が1000000を含む行になるまで9999回繰り返されます。その行は抽出され、再帰テーブルに追加されます。しかし、今回は、WHERE句によって、再帰的選択は行を返さないので、キューは空のままで、再帰は停止します。</target>
        </trans-unit>
        <trans-unit id="f8fa74d8815f89442ddf62f70a180b631fe1665c" translate="yes" xml:space="preserve">
          <source>Consider querying this table to find the number of occurrences of the word &quot;xyzzy&quot;.:</source>
          <target state="translated">このテーブルにクエリを実行して、&quot;xyzzy &quot;という単語の出現数を検索してみてください。</target>
        </trans-unit>
        <trans-unit id="8e332dd9034fe99b489d4794d57d3e6f28bfd9ef" translate="yes" xml:space="preserve">
          <source>Consider the following SQL:</source>
          <target state="translated">次のSQLを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="e890ad26c51af96d02d41774ffeaa333b700b830" translate="yes" xml:space="preserve">
          <source>Consider the following two command sequences:</source>
          <target state="translated">次の2つのコマンドシーケンスを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="38f2ce12e9214d8cde3ab5b6d1808e89b342965a" translate="yes" xml:space="preserve">
          <source>Consider using the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface to limit the scope of SQL that will be processed. For example, an application that does not need to change the database schema might add an sqlite3_set_authorizer() callback that causes any CREATE or DROP statement to fail.</source>
          <target state="translated">&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer（）&lt;/a&gt;インターフェースを使用して、処理されるSQLのスコープを制限することを検討してください。たとえば、データベーススキーマを変更する必要のないアプリケーションがsqlite3_set_authorizer（）コールバックを追加すると、CREATEまたはDROPステートメントが失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="3f881ec6e1c51116405b7bd7506d06d9368faea1" translate="yes" xml:space="preserve">
          <source>Consider what would happen if disk sector writes are interrupted by a power loss. If an application writes two or three bytes in the middle of some file, the operating system will implement this by first reading the entire sector containing those bytes, making the change to the sector in memory, then writing the entire sector back to the disk. If a power loss occurs during the writeback and the sector was not completely written, then on the next read after reboot, error correcting codes in the sector will probably detect irreparable damage and the disk controller will read out the sector as all zeros or all ones. Thus values will have changed outside of the range of the two or three bytes that were written at the application level - a violation of the powersafe overwrite property.</source>
          <target state="translated">ディスクセクタへの書き込みが停電で中断された場合に何が起こるかを考えてみましょう。アプリケーションがファイルの途中で 2 バイトか 3 バイトを書き込む場合、オペレーティングシステムは、まずそのバイトを含むセクタ全体を読み込み、メモリ内のセクタに変更を加えてから、セクタ全体をディスクに書き戻すという方法でこれを実装します。もし、ライトバック中に停電が発生し、セクタが完全に書き込まれなかった場合、再起動後の次の読み取りでは、セクタ内のエラー訂正コードが修復不可能な損傷を検出し、ディスクコントローラはセクタをすべてゼロまたはすべて1として読み出すことになります。このように、値はアプリケーションレベルで書き込まれた2~3バイトの範囲外で変更されることになり、パワーセーフ上書きプロパティの違反となります。</target>
        </trans-unit>
        <trans-unit id="454478261b68992469d64496e9cfb5f053cfbed3" translate="yes" xml:space="preserve">
          <source>Console the sorrowing.</source>
          <target state="translated">悲しみを慰めろ</target>
        </trans-unit>
        <trans-unit id="c51c1399ff5b435aa7c4c51efe988981e74f0189" translate="yes" xml:space="preserve">
          <source>Constant value 0.</source>
          <target state="translated">定数値 0。</target>
        </trans-unit>
        <trans-unit id="f14defda3a0615f9817e1062360bb6f9e7654bb6" translate="yes" xml:space="preserve">
          <source>Constant value 1. This field is omitted for any term-offset list associated with column 0.</source>
          <target state="translated">定数値 1。このフィールドは、列 0 に関連付けられたタームオフセットリストでは省略されます。</target>
        </trans-unit>
        <trans-unit id="f7d639ba9c48f5467c4d1a8f0152a2dc90222051" translate="yes" xml:space="preserve">
          <source>Constants Defining Special Destructor Behavior</source>
          <target state="translated">特殊デストラクタの動作を定義する定数</target>
        </trans-unit>
        <trans-unit id="af7e74633bc458147e8d5da16df8562d003b392e" translate="yes" xml:space="preserve">
          <source>Constants Passed To The Conflict Handler</source>
          <target state="translated">コンフリクトハンドラに渡される定数</target>
        </trans-unit>
        <trans-unit id="aa0aeb15b7dcd6d473c7d1bf166a40ca61fee668" translate="yes" xml:space="preserve">
          <source>Constants Returned By The Conflict Handler</source>
          <target state="translated">コンフリクトハンドラが返す定数</target>
        </trans-unit>
        <trans-unit id="6337f09e95dde3b3b58675d8b6f0257adf22ba40" translate="yes" xml:space="preserve">
          <source>Constants:</source>
          <target state="translated">Constants:</target>
        </trans-unit>
        <trans-unit id="f37e46006a1745cf96ebe1f73c1de5744dcf1d1d" translate="yes" xml:space="preserve">
          <source>Constraint Conflict Resolution in SQLite</source>
          <target state="translated">SQLite での制約の競合の解決</target>
        </trans-unit>
        <trans-unit id="6889aa68d48cec7c8c38bf28801d4701520ff0dc" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt;</source>
          <target state="translated">コンストラクター：&lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a878fca8a43e71d4ec596dfa4ec029c0c81a75d0" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt;</source>
          <target state="translated">コンストラクター：&lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a2c5628cdcd91822efac04edcb216499727358f" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;</source>
          <target state="translated">コンストラクター：&lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d1cdc0adde4d7b415af1d0d33bde5ec5e8f55638" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;#sqlite3changegroup_new&quot;&gt;sqlite3changegroup_new()&lt;/a&gt;</source>
          <target state="translated">コンストラクター：&lt;a href=&quot;#sqlite3changegroup_new&quot;&gt;sqlite3changegroup_new（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d43a93e241e64f205e9be40e6849d360ecb314d2" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;#sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt;</source>
          <target state="translated">コンストラクター：&lt;a href=&quot;#sqlite3session_create&quot;&gt;sqlite3session_create（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06e9fffe66b7ccd965b3d8281c4189b6873e699b" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt;</source>
          <target state="translated">コンストラクター：&lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e898f79bdd10cd47ee3054a83ab75f61437a7aa4" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt;</source>
          <target state="translated">コンストラクター：&lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="08db86cfe6351f2012dbf46992a9fa7d1631a5e2" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;sqlite3changegroup_new&quot;&gt;sqlite3changegroup_new()&lt;/a&gt;</source>
          <target state="translated">コンストラクター：&lt;a href=&quot;sqlite3changegroup_new&quot;&gt;sqlite3changegroup_new（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="38014e350b2ec610dc63ea6835bc8bf20566c178" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt;</source>
          <target state="translated">コンストラクター：&lt;a href=&quot;sqlite3session_create&quot;&gt;sqlite3session_create（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f94c6d14960e90153f9e56ef05e080f43ace38fd" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;</source>
          <target state="translated">コンストラクター：&lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3617dc14ae8be730219fa2aabd32aaa900ccfc3a" translate="yes" xml:space="preserve">
          <source>Constructors: &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;</source>
          <target state="translated">コンストラクタ：&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b2da4ffc9b2e344254d3be3ef8d1b5463c6c55d3" translate="yes" xml:space="preserve">
          <source>Constructors: &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;, &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2()&lt;/a&gt;</source>
          <target state="translated">コンストラクター：&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b84725656dbaa01e32202bf862175e15f3aa743" translate="yes" xml:space="preserve">
          <source>Constructors: &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;</source>
          <target state="translated">コンストラクタ：&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;、&lt;a href=&quot;open&quot;&gt;sqlite3_open16（）&lt;/a&gt;、&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="63842448f26d096823a3c51f076ae6fb704d1709" translate="yes" xml:space="preserve">
          <source>Constructors: &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;, &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2()&lt;/a&gt;</source>
          <target state="translated">コンストラクター：&lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt;、&lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2（）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5e8adbf806de9adae308cb1a722a2834efb03d01" translate="yes" xml:space="preserve">
          <source>Contains the actual data inserted into the FTS5 table. This shadow table is not present for &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless&lt;/a&gt; or &lt;a href=&quot;fts5#external_content_tables&quot;&gt;external content&lt;/a&gt; FTS5 tables.</source>
          <target state="translated">FTS5テーブルに挿入された実際のデータが含まれます。このシャドウテーブルには、のために存在していない&lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless&lt;/a&gt;または&lt;a href=&quot;fts5#external_content_tables&quot;&gt;外部コンテンツ&lt;/a&gt; FTS5テーブル。</target>
        </trans-unit>
        <trans-unit id="6773795897579cbc7647c6d1ac1d4b8bc25387d4" translate="yes" xml:space="preserve">
          <source>Contains the size of each column of each row in the virtual table in tokens. This shadow table is not present if the &lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&quot;columnsize&quot; option&lt;/a&gt; is set to 0.</source>
          <target state="translated">仮想テーブルの各行の各列のサイズがトークンに含まれています。&lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;「columnsize」オプション&lt;/a&gt;が0に設定されている場合、このシャドウテーブルは存在しません。</target>
        </trans-unit>
        <trans-unit id="c6336221afe18ddc0e53b18acd141d3c916c6884" translate="yes" xml:space="preserve">
          <source>Contains the text of the term for this row.</source>
          <target state="translated">この行の用語のテキストを含みます。</target>
        </trans-unit>
        <trans-unit id="8149ba57ba940e5c3672ef00fa60ad0d2afcb776" translate="yes" xml:space="preserve">
          <source>Contains the values of persistent configuration parameters.</source>
          <target state="translated">永続的な構成パラメータの値を保持します。</target>
        </trans-unit>
        <trans-unit id="17ad25c1af7990d50b53a9e2d46ba0f493597884" translate="yes" xml:space="preserve">
          <source>Content Size</source>
          <target state="translated">コンテンツサイズ</target>
        </trans-unit>
        <trans-unit id="311a2e63246045d0ca04704e25eb8fe09678745a" translate="yes" xml:space="preserve">
          <source>Content can be accessed and updated using concise SQL queries instead of lengthy and error-prone procedural routines.</source>
          <target state="translated">長くてエラーが発生しやすい手続きルーチンの代わりに、簡潔なSQLクエリを使用して、コンテンツにアクセスして更新することができます。</target>
        </trans-unit>
        <trans-unit id="54e6a597c2b0fe05466617946d21001a0e849ccf" translate="yes" xml:space="preserve">
          <source>Content can be updated continuously and atomically so that little or no work is lost in a power failure or crash.</source>
          <target state="translated">コンテンツは、継続的かつ原子的に更新することができるので、停電やクラッシュでほとんど作業ができなくなることはありません。</target>
        </trans-unit>
        <trans-unit id="5a0ca8d8e7e6987ce002e1b9cc19498346916cd0" translate="yes" xml:space="preserve">
          <source>Content stored in an SQLite database is more likely to be recoverable decades in the future, long after all traces of the original application have been lost. Data lives longer than code.</source>
          <target state="translated">SQLite データベースに保存されているコンテンツは、元のアプリケーションの痕跡がすべて失われた後も、数十年後には回復可能な可能性が高くなります。データはコードよりも長生きします。</target>
        </trans-unit>
        <trans-unit id="2d4a0281b46f5532a617239a67837a43f539390e" translate="yes" xml:space="preserve">
          <source>Contentless FTS4 tables also support SELECT statements. However, it is an error to attempt to retrieve the value of any table column other than the docid column. The auxiliary function matchinfo() may be used, but snippet() and offsets() may not. For example:</source>
          <target state="translated">Contentless FTS4テーブルはSELECT文もサポートしています。しかし、docidカラム以外のテーブルカラムの値を取得しようとするとエラーになります。補助関数 matchinfo()は使用できますが、snippet()と offsets()は使用できません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="466e0c80c6a0ee6d90e9a1cf84c5c7f81c6af7ec" translate="yes" xml:space="preserve">
          <source>Contentless FTS5 tables do not support UPDATE or DELETE statements, or INSERT statements that do not supply a non-NULL value for the rowid field. Contentless tables do not support REPLACE conflict handling. REPLACE and INSERT OR REPLACE statements are treated as regular INSERT statements. Rows may be deleted from a contentless table using an &lt;a href=&quot;fts5#the_delete_command&quot;&gt;FTS5 delete command&lt;/a&gt;.</source>
          <target state="translated">コンテンツレスFTS5テーブルは、UPDATEまたはDELETEステートメント、またはROWIDフィールドにNULL以外の値を提供しないINSERTステートメントをサポートしません。コンテンツのないテーブルは、REPLACE競合処理をサポートしていません。REPLACEおよびINSERT OR REPLACEステートメントは、通常のINSERTステートメントとして扱われます。&lt;a href=&quot;fts5#the_delete_command&quot;&gt;FTS5削除コマンド&lt;/a&gt;を使用して、コンテンツのないテーブルから行を削除できます。</target>
        </trans-unit>
        <trans-unit id="450f660f2dc175257d82b71bd1a3662299271f61" translate="yes" xml:space="preserve">
          <source>Contentless fts4 tables</source>
          <target state="translated">内容のないfts4テーブル</target>
        </trans-unit>
        <trans-unit id="f5cbdf6bfb51439be085b5c6b7460a7c91eabc3c" translate="yes" xml:space="preserve">
          <source>Contents</source>
          <target state="translated">Contents</target>
        </trans-unit>
        <trans-unit id="38c62e79a8a690e9f86401a7b90826fac3d70fe4" translate="yes" xml:space="preserve">
          <source>Continuing enhancements and improvements to &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fts3&quot;&gt;FTS3の&lt;/a&gt;継続的な拡張と改善。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
