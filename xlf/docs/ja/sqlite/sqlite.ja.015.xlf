<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="8485338d9edebd1879a88fb2aa42a3b5aaf70e71" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS_DML option activates or deactivates the legacy &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DML statements only, that is DELETE, INSERT, SELECT, and UPDATE statements. The default value of this setting is determined by the &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_DBCONFIG_DQS_DMLオプションは、DMLステートメント、つまりDELETE、INSERT、SELECT、およびUPDATEステートメントに対してのみ、従来の&lt;a href=&quot;quirks#dblquote&quot;&gt;二重引用符で囲まれた文字列リテラルの&lt;/a&gt;誤動作をアクティブ化または非アクティブ化します。この設定のデフォルト値は、&lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt;コンパイル時オプションによって決定されます。</target>
        </trans-unit>
        <trans-unit id="763206f446e43106378de90da986cb3503647378" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_ENABLE_QPSG option activates or deactivates the &lt;a href=&quot;../queryplanner-ng#qpstab&quot;&gt;query planner stability guarantee&lt;/a&gt; (QPSG). When the QPSG is active, a single SQL query statement will always use the same algorithm regardless of values of &lt;a href=&quot;../lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;. The QPSG disables some query optimizations that look at the values of bound parameters, which can make some queries slower. But the QPSG has the advantage of more predictable behavior. With the QPSG active, SQLite will always use the same query plan in the field as was used during testing in the lab. The first argument to this setting is an integer which is 0 to disable the QPSG, positive to enable QPSG, or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether the QPSG is disabled or enabled following this call.</source>
          <target state="translated">SQLITE_DBCONFIG_ENABLE_QPSGオプションは、&lt;a href=&quot;../queryplanner-ng#qpstab&quot;&gt;クエリプランナーの安定性保証&lt;/a&gt;（QPSG）をアクティブまたは非アクティブにします。 QPSGがアクティブな場合、&lt;a href=&quot;../lang_expr#varparam&quot;&gt;バインドされたパラメーター&lt;/a&gt;の値に関係なく、単一のSQLクエリステートメントは常に同じアルゴリズムを使用します。 QPSGは、バインドされたパラメーターの値を参照する一部のクエリ最適化を無効にし、一部のクエリを遅くする可能性があります。しかし、QPSGにはより予測可能な動作という利点があります。 QPSGがアクティブな場合、SQLiteは常に、ラボでのテスト中に使用されたものと同じクエリプランをフィールドで使用します。この設定の最初の引数は、QPSGを無効にする場合は0、QPSGを有効にする場合は正、設定を変更しない場合は負の整数です。 2番目のパラメーターは、この呼び出しに続いてQPSGが無効か有効かを示すために0または1が書き込まれる整数へのポインターです。</target>
        </trans-unit>
        <trans-unit id="e62faf35588a5d4eafe007180e96f2c0c110300b" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_ENABLE_QPSG option activates or deactivates the &lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;query planner stability guarantee&lt;/a&gt; (QPSG). When the QPSG is active, a single SQL query statement will always use the same algorithm regardless of values of &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;. The QPSG disables some query optimizations that look at the values of bound parameters, which can make some queries slower. But the QPSG has the advantage of more predictable behavior. With the QPSG active, SQLite will always use the same query plan in the field as was used during testing in the lab. The first argument to this setting is an integer which is 0 to disable the QPSG, positive to enable QPSG, or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether the QPSG is disabled or enabled following this call.</source>
          <target state="translated">SQLITE_DBCONFIG_ENABLE_QPSGオプションは、&lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;クエリプランナーの安定性保証&lt;/a&gt;（QPSG）をアクティブまたは非アクティブにします。 QPSGがアクティブな場合、&lt;a href=&quot;lang_expr#varparam&quot;&gt;バインドされたパラメーター&lt;/a&gt;の値に関係なく、単一のSQLクエリステートメントは常に同じアルゴリズムを使用します。 QPSGは、バインドされたパラメーターの値を参照する一部のクエリ最適化を無効にし、一部のクエリを遅くする可能性があります。しかし、QPSGにはより予測可能な動作という利点があります。 QPSGがアクティブな場合、SQLiteは常に、ラボでのテスト中に使用されたものと同じクエリプランをフィールドで使用します。この設定の最初の引数は、QPSGを無効にする場合は0、QPSGを有効にする場合は正、設定を変更しない場合は負の整数です。 2番目のパラメーターは、この呼び出しに続いてQPSGが無効か有効かを示すために0または1が書き込まれる整数へのポインターです。</target>
        </trans-unit>
        <trans-unit id="8bef3f5951097e41221958d251dd3bbb9ce96dee" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_LEGACY_ALTER_TABLE option activates or deactivates the legacy behavior of the &lt;a href=&quot;../lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt; command such it behaves as it did prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_24_0.html&quot;&gt;version 3.24.0&lt;/a&gt; (2018-06-04). See the &quot;Compatibility Notice&quot; on the &lt;a href=&quot;../lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME documentation&lt;/a&gt; for additional information. This feature can also be turned on and off using the &lt;a href=&quot;../pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt; statement.</source>
          <target state="translated">SQLITE_DBCONFIG_LEGACY_ALTER_TABLEオプションは、&lt;a href=&quot;../lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt;コマンドのレガシー動作をアクティブまたは非アクティブにし、&lt;a href=&quot;https://sqlite.org/releaselog/3_24_0.html&quot;&gt;バージョン3.24.0&lt;/a&gt;（2018-06-04）より前と同じように動作します。詳細については、&lt;a href=&quot;../lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAMEドキュメント&lt;/a&gt;の「互換性に関する通知」を参照してください。この機能は、&lt;a href=&quot;../pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt;ステートメントを使用してオンとオフを切り替えることもできます。</target>
        </trans-unit>
        <trans-unit id="07c20d63d2e6b14f99d190fcacbd95a681ec8f6a" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_LEGACY_ALTER_TABLE option activates or deactivates the legacy behavior of the &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt; command such it behaves as it did prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_24_0.html&quot;&gt;version 3.24.0&lt;/a&gt; (2018-06-04). See the &quot;Compatibility Notice&quot; on the &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME documentation&lt;/a&gt; for additional information. This feature can also be turned on and off using the &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt; statement.</source>
          <target state="translated">SQLITE_DBCONFIG_LEGACY_ALTER_TABLEオプションは、&lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt;コマンドのレガシー動作をアクティブまたは非アクティブにし、&lt;a href=&quot;https://sqlite.org/releaselog/3_24_0.html&quot;&gt;バージョン3.24.0&lt;/a&gt;（2018-06-04）より前と同じように動作します。詳細については、&lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAMEドキュメント&lt;/a&gt;の「互換性に関する通知」を参照してください。この機能は、&lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt;ステートメントを使用してオンとオフを切り替えることもできます。</target>
        </trans-unit>
        <trans-unit id="b56f76674dd3d27b6ff064c91089204d7b0e90fc" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_LEGACY_FILE_FORMAT option activates or deactivates the legacy file format flag. When activated, this flag causes all newly created database file to have a schema format version number (the 4-byte integer found at offset 44 into the database header) of 1. This in turn means that the resulting database file will be readable and writable by any SQLite version back to 3.0.0 (2004-06-18). Without this setting, newly created databases are generally not understandable by SQLite versions prior to 3.3.0 (2006-01-11). As these words are written, there is now scarcely any need to generated database files that are compatible all the way back to version 3.0.0, and so this setting is of little practical use, but is provided so that SQLite can continue to claim the ability to generate new database files that are compatible with version 3.0.0.</source>
          <target state="translated">SQLITE_DBCONFIG_LEGACY_FILE_FORMAT オプションは、レガシー ファイル形式フラグを有効または無効にします。このフラグを有効にすると、新しく作成されたすべてのデータベースファイルのスキーマフォーマットのバージョン番号(データベースヘッダーのオフセット44にある4バイトの整数)が1になります。 これは、結果として得られるデータベースファイルが3.0.0 (2004-06-18)以前のSQLiteバージョンでも読み書きが可能になることを意味します。この設定がない場合、新しく作成されたデータベースは、一般的に3.3.0 (2006-01-11)以前のバージョンのSQLiteでは理解できません。この言葉が書かれているように、現在ではバージョン3.0.0.0まで遡って互換性のあるデータベースファイルを生成する必要性はほとんどないので、この設定はほとんど実用的ではありませんが、SQLiteがバージョン3.0.0.0と互換性のある新しいデータベースファイルを生成する能力を主張し続けるために提供されています。</target>
        </trans-unit>
        <trans-unit id="609f392579cb3bfb47e8225e916b400815ceda24" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_TRUSTED_SCHEMA option tells SQLite to assume that database schemas are untainted by malicious content. When the SQLITE_DBCONFIG_TRUSTED_SCHEMA option is disabled, SQLite takes additional defensive steps to protect the application from harm including:</source>
          <target state="translated">SQLITE_DBCONFIG_TRUSTED_SCHEMA オプションは、データベース スキーマが悪意のあるコンテンツに汚染されていないことを前提とするように SQLite に指示します。SQLITE_DBCONFIG_TRUSTED_SCHEMA オプションが無効になっている場合、SQLite はアプリケーションを害から保護するために、以下のような追加の防御ステップを実行します。</target>
        </trans-unit>
        <trans-unit id="6b8460a489883d4335645b0e8208feef234ba632" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_WRITABLE_SCHEMA option activates or deactivates the &quot;writable_schema&quot; flag. This has the same effect and is logically equivalent to setting &lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt; or &lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=OFF&lt;/a&gt;. The first argument to this setting is an integer which is 0 to disable the writable_schema, positive to enable writable_schema, or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether the writable_schema is enabled or disabled following this call.</source>
          <target state="translated">SQLITE_DBCONFIG_WRITABLE_SCHEMAオプションは、「writable_schema」フラグをアクティブまたは非アクティブにします。これは同じ効果があり、&lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema = ON&lt;/a&gt;または&lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema = OFF&lt;/a&gt;を設定することと論理的に同等です。この設定の最初の引数は整数で、0はwritable_schemaを無効にし、正の値はwritable_schemaを有効にするか、負の値は設定を変更しないままにします。 2番目のパラメーターは、この呼び出しに続いてwritable_schemaが有効か無効かを示すために0または1が書き込まれる整数へのポインターです。</target>
        </trans-unit>
        <trans-unit id="46872dc1f07ab31c88fb7c7af6f4fae5ff78bc83" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_WRITABLE_SCHEMA option activates or deactivates the &quot;writable_schema&quot; flag. This has the same effect and is logically equivalent to setting &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt; or &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=OFF&lt;/a&gt;. The first argument to this setting is an integer which is 0 to disable the writable_schema, positive to enable writable_schema, or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether the writable_schema is enabled or disabled following this call.</source>
          <target state="translated">SQLITE_DBCONFIG_WRITABLE_SCHEMAオプションは、「writable_schema」フラグをアクティブまたは非アクティブにします。これは同じ効果があり、&lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema = ON&lt;/a&gt;または&lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema = OFF&lt;/a&gt;を設定することと論理的に同等です。この設定の最初の引数は整数で、0はwritable_schemaを無効にし、正の値はwritable_schemaを有効にするか、負の値は設定を変更しないままにします。 2番目のパラメーターは、この呼び出しに続いてwritable_schemaが有効か無効かを示すために0または1が書き込まれる整数へのポインターです。</target>
        </trans-unit>
        <trans-unit id="6b85aa8ea894875435c445b85abe99205949918e" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE Virtual Table</source>
          <target state="translated">SQLITE_DBPAGE 仮想テーブル</target>
        </trans-unit>
        <trans-unit id="66cd1369214f0f32feaaff6ac1895398317fe842" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE extension implements an &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual table&lt;/a&gt; that provides direct access to the underlying database file by interacting with the pager. SQLITE_DBPAGE is capable of both reading and writing any page of the database. Because interaction is through the pager layer, all changes are transactional.</source>
          <target state="translated">SQLITE_DBPAGE拡張機能は、ページャーと対話することにより、基になるデータベースファイルへの直接アクセスを提供する、同義語&lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;のみの仮想テーブル&lt;/a&gt;を実装します。SQLITE_DBPAGEは、データベースの任意のページの読み取りと書き込みの両方が可能です。インタラクションはページャーレイヤーを通じて行われるため、すべての変更はトランザクション対応です。</target>
        </trans-unit>
        <trans-unit id="10bc6095f9cb7b42e8d331fa1d325222ae39eae9" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE extension is enabled in default builds of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">SQLITE_DBPAGE拡張機能は、&lt;a href=&quot;cli&quot;&gt;コマンドラインシェルの&lt;/a&gt;デフォルトビルドで有効になっています。</target>
        </trans-unit>
        <trans-unit id="6759306b08f50bd9c66f3b5fb6678d1fa27bfe11" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE extension is included in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; though it is disabled by default. Use the &lt;a href=&quot;compile#enable_dbpage_vtab&quot;&gt;SQLITE_ENABLE_DBPAGE_VTAB&lt;/a&gt; compile-time option to enable the SQLITE_DBPAGE extension. The SQLITE_DBPAGE extension makes use of unpublished internal interfaces and is not run-time loadable. The only way to add SQLITE_DBPAGE to an application is to compile it in using the &lt;a href=&quot;compile#enable_dbpage_vtab&quot;&gt;SQLITE_ENABLE_DBPAGE_VTAB&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLITE_DBPAGE拡張機能は&lt;a href=&quot;amalgamation&quot;&gt;統合に&lt;/a&gt;含まれていますが、デフォルトでは無効になっています。&lt;a href=&quot;compile#enable_dbpage_vtab&quot;&gt;SQLITE_ENABLE_DBPAGE_VTAB&lt;/a&gt;コンパイル時オプションを使用して、SQLITE_DBPAGE拡張を有効にします。 SQLITE_DBPAGE拡張機能は、公開されていない内部インターフェースを利用するため、実行時にロードできません。 SQLITE_DBPAGEをアプリケーションに追加する唯一の方法は、&lt;a href=&quot;compile#enable_dbpage_vtab&quot;&gt;SQLITE_ENABLE_DBPAGE_VTAB&lt;/a&gt;コンパイル時オプションを使用してコンパイルすることです。</target>
        </trans-unit>
        <trans-unit id="29d747e639293b4d0174864bbfeb0a0f144170ea" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE table allows an application to view or replace the raw binary content of each page of the database file. No attempt is made to interpret the content of the page. Content is returned byte-for-byte as it appears on disk.</source>
          <target state="translated">SQLITE_DBPAGE テーブルは、アプリケーションがデータベースファイルの各ページの生のバイナリ内容を表示したり置き換えたりすることを可能にします。ページの内容を解釈しようとはしません。内容はディスク上に表示されている状態でバイト単位で返されます。</target>
        </trans-unit>
        <trans-unit id="f9b8d935ab9300d2651f69fa35d68c10b3cdb857" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE table can participate in a join just like any other table. Hence, to see the content of the first page to all connected database files, one might run a statement like this:</source>
          <target state="translated">SQLITE_DBPAGEテーブルは、他のテーブルと同様に結合に参加することができます。したがって、接続されているすべてのデータベースファイルに最初のページの内容を表示するには、次のようなステートメントを実行することができます。</target>
        </trans-unit>
        <trans-unit id="15d4ed3f8e0c537ab57736b4ad4d051438f525bd" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE table has one row for each page in the database file. SQLITE_DBPAGE allows pages to be read or to be overwritten. However the size of the database file cannot be changed. It is not possible to change the number of rows in the SQLITE_DBPAGE table by running DELETE or INSERT operations against that table.</source>
          <target state="translated">SQLITE_DBPAGE テーブルは、データベースファイル内の各ページに対して 1 つの行を持ちます。SQLITE_DBPAGEは、ページを読み込んだり、上書きしたりすることができます。ただし、データベースファイルのサイズは変更できません。SQLITE_DBPAGE テーブルに対して DELETE または INSERT 操作を実行して、SQLITE_DBPAGE テーブルの行数を変更することはできません。</target>
        </trans-unit>
        <trans-unit id="74c5162b414c69b11a7519aa50aa6d53d70b24f0" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE table schema shown above is incomplete. There is a third &lt;a href=&quot;vtab#hiddencol&quot;&gt;hidden column&lt;/a&gt; named &quot;schema&quot; that determines which &lt;a href=&quot;lang_attach&quot;&gt;ATTACH-ed database&lt;/a&gt; should be read or written. Because the &quot;schema&quot; column is hidden, it can be used as a parameter when SQLITE_DBPAGE is invoked as a &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt;.</source>
          <target state="translated">上記のSQLITE_DBPAGEテーブルスキーマは不完全です。「スキーマ」という名前の3番目の&lt;a href=&quot;vtab#hiddencol&quot;&gt;非表示列&lt;/a&gt;があり、どの&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;が適用されたデータベースの読み取りまたは書き込みを行うかを決定します。「スキーマ」列は非表示になっているため、SQLITE_DBPAGEが&lt;a href=&quot;vtab#tabfunc2&quot;&gt;テーブル値関数&lt;/a&gt;として呼び出されたときにパラメーターとして使用できます。</target>
        </trans-unit>
        <trans-unit id="518c52e0806550bfb6aa69b1fed15fbc4111a9ca" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE virtual table read/write table that provides direct access to the underlying disk file on a page-by-page basis. The virtual table appears to have a schema like this:</source>
          <target state="translated">SQLITE_DBPAGE 仮想テーブルは、ページ単位で基礎となるディスクファイルへの直接アクセスを提供する読み書きテーブルです。仮想テーブルは、このようなスキーマを持っているようです。</target>
        </trans-unit>
        <trans-unit id="c1930c1236dfcd2ca69ef991dff0ceab5ad493f1" translate="yes" xml:space="preserve">
          <source>The SQLITE_DESERIALIZE_FREEONCLOSE means that the database serialization in the P argument is held in memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; and that SQLite should take ownership of this memory and automatically free it when it has finished using it. Without this flag, the caller is responsible for freeing any dynamically allocated memory.</source>
          <target state="translated">SQLITE_DESERIALIZE_FREEONCLOSEは、P引数のデータベースシリアル化が&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;から取得したメモリに保持され、SQLiteがこのメモリの所有権を取得し、使用を終了すると自動的に解放することを意味します。このフラグがない場合、呼び出し元は、動的に割り当てられたメモリを解放する必要があります。</target>
        </trans-unit>
        <trans-unit id="76631b67d929ebcd295444bce3ec1691bb16c502" translate="yes" xml:space="preserve">
          <source>The SQLITE_DESERIALIZE_FREEONCLOSE means that the database serialization in the P argument is held in memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; and that SQLite should take ownership of this memory and automatically free it when it has finished using it. Without this flag, the caller is responsible for freeing any dynamically allocated memory.</source>
          <target state="translated">SQLITE_DESERIALIZE_FREEONCLOSEは、P引数のデータベースシリアル化が&lt;a href=&quot;free&quot;&gt;sqlite3_malloc64（）&lt;/a&gt;から取得したメモリに保持され、SQLiteがこのメモリの所有権を取得し、使用を終了すると自動的に解放することを意味します。このフラグがない場合、呼び出し元は、動的に割り当てられたメモリを解放する必要があります。</target>
        </trans-unit>
        <trans-unit id="fffd4707786aad32f12960ea601bc8b62704db6b" translate="yes" xml:space="preserve">
          <source>The SQLITE_DESERIALIZE_READONLY flag means that the deserialized database should be treated as read-only.</source>
          <target state="translated">SQLITE_DESERIALIZE_READONLY フラグは、デシリアライズされたデータベースを読み取り専用として扱うべきであることを意味します。</target>
        </trans-unit>
        <trans-unit id="684cad9c07969122877d4a208d11cefd54e63c00" translate="yes" xml:space="preserve">
          <source>The SQLITE_DESERIALIZE_RESIZEABLE flag means that SQLite is allowed to grow the size of the database using calls to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc64()&lt;/a&gt;. This flag should only be used if SQLITE_DESERIALIZE_FREEONCLOSE is also used. Without this flag, the deserialized database cannot increase in size beyond the number of bytes specified by the M parameter.</source>
          <target state="translated">SQLITE_DESERIALIZE_RESIZEABLEフラグは、SQLiteが&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc64（）の&lt;/a&gt;呼び出しを使用してデータベースのサイズを拡大できることを意味します。このフラグは、SQLITE_DESERIALIZE_FREEONCLOSEも使用されている場合にのみ使用してください。このフラグがないと、デシリアライズされたデータベースのサイズを、Mパラメーターで指定されたバイト数を超えて増やすことはできません。</target>
        </trans-unit>
        <trans-unit id="80121a4afb11422b1c8bfdaf5caf6ca8a41c2e89" translate="yes" xml:space="preserve">
          <source>The SQLITE_DESERIALIZE_RESIZEABLE flag means that SQLite is allowed to grow the size of the database using calls to &lt;a href=&quot;free&quot;&gt;sqlite3_realloc64()&lt;/a&gt;. This flag should only be used if SQLITE_DESERIALIZE_FREEONCLOSE is also used. Without this flag, the deserialized database cannot increase in size beyond the number of bytes specified by the M parameter.</source>
          <target state="translated">SQLITE_DESERIALIZE_RESIZEABLEフラグは、SQLiteが&lt;a href=&quot;free&quot;&gt;sqlite3_realloc64（）の&lt;/a&gt;呼び出しを使用してデータベースのサイズを拡大できることを意味します。このフラグは、SQLITE_DESERIALIZE_FREEONCLOSEも使用されている場合にのみ使用してください。このフラグがないと、デシリアライズされたデータベースのサイズを、Mパラメーターで指定されたバイト数を超えて増やすことはできません。</target>
        </trans-unit>
        <trans-unit id="19352bde546497cb9c8447fd1d7dfafe9e2fb83c" translate="yes" xml:space="preserve">
          <source>The SQLITE_DETERMINISTIC flag means that the new function always gives the same output when the input parameters are the same. The &lt;a href=&quot;../lang_corefunc#abs&quot;&gt;abs() function&lt;/a&gt; is deterministic, for example, but &lt;a href=&quot;../lang_corefunc#randomblob&quot;&gt;randomblob()&lt;/a&gt; is not. Functions must be deterministic in order to be used in certain contexts such as with the WHERE clause of &lt;a href=&quot;../partialindex&quot;&gt;partial indexes&lt;/a&gt; or in &lt;a href=&quot;../gencol&quot;&gt;generated columns&lt;/a&gt;. SQLite might also optimize deterministic functions by factoring them out of inner loops.</source>
          <target state="translated">SQLITE_DETERMINISTICフラグは、入力パラメーターが同じ場合、新しい関数が常に同じ出力を提供することを意味します。&lt;a href=&quot;../lang_corefunc#abs&quot;&gt;ABS（）関数は&lt;/a&gt;、例えば、決定論的であるが、&lt;a href=&quot;../lang_corefunc#randomblob&quot;&gt;randomblob（）は&lt;/a&gt;ありません。関数は、&lt;a href=&quot;../partialindex&quot;&gt;部分インデックスの&lt;/a&gt;WHERE句や&lt;a href=&quot;../gencol&quot;&gt;生成された列&lt;/a&gt;など、特定のコンテキストで使用するために決定論的である必要があります。 SQLiteは、決定論的関数を内部ループから除外することにより、それらを最適化する場合もあります。</target>
        </trans-unit>
        <trans-unit id="a94dcf703cfcb3aebcafb1d5511712f18433c467" translate="yes" xml:space="preserve">
          <source>The SQLITE_DETERMINISTIC flag means that the new function always gives the same output when the input parameters are the same. The &lt;a href=&quot;lang_corefunc#abs&quot;&gt;abs() function&lt;/a&gt; is deterministic, for example, but &lt;a href=&quot;lang_corefunc#randomblob&quot;&gt;randomblob()&lt;/a&gt; is not. Functions must be deterministic in order to be used in certain contexts such as with the WHERE clause of &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt; or in &lt;a href=&quot;gencol&quot;&gt;generated columns&lt;/a&gt;. SQLite might also optimize deterministic functions by factoring them out of inner loops.</source>
          <target state="translated">SQLITE_DETERMINISTICフラグは、入力パラメーターが同じ場合、新しい関数が常に同じ出力を提供することを意味します。&lt;a href=&quot;lang_corefunc#abs&quot;&gt;ABS（）関数は&lt;/a&gt;、例えば、決定論的であるが、&lt;a href=&quot;lang_corefunc#randomblob&quot;&gt;randomblob（）は&lt;/a&gt;ありません。関数は、&lt;a href=&quot;partialindex&quot;&gt;部分インデックスの&lt;/a&gt;WHERE句や&lt;a href=&quot;gencol&quot;&gt;生成された列&lt;/a&gt;など、特定のコンテキストで使用するために決定論的である必要があります。 SQLiteは、決定論的関数を内部ループから除外することにより、それらを最適化する場合もあります。</target>
        </trans-unit>
        <trans-unit id="a817ebcb8adde635efe8cf6f019a45cbccc77452" translate="yes" xml:space="preserve">
          <source>The SQLITE_DETERMINISTIC flag means that the new function will always maps the same inputs into the same output. The abs() function is deterministic, for example, but randomblob() is not.</source>
          <target state="translated">SQLITE_DETERMINISTIC フラグは、新しい関数が常に同じ入力を同じ出力にマッピングすることを意味します。例えば abs()関数は決定論的ですが、randlob()はそうではありません。</target>
        </trans-unit>
        <trans-unit id="e7795e7dba3d35d408494ba100326feff56ac8bd" translate="yes" xml:space="preserve">
          <source>The SQLITE_DIRECTONLY flag means that the function may only be invoked from top-level SQL, and cannot be used in VIEWs or TRIGGERs nor in schema structures such as &lt;a href=&quot;../lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;, &lt;a href=&quot;../lang_createtable#dfltval&quot;&gt;DEFAULT clauses&lt;/a&gt;, &lt;a href=&quot;../expridx&quot;&gt;expression indexes&lt;/a&gt;, &lt;a href=&quot;../partialindex&quot;&gt;partial indexes&lt;/a&gt;, or &lt;a href=&quot;../gencol&quot;&gt;generated columns&lt;/a&gt;. The SQLITE_DIRECTONLY flags is a security feature which is recommended for all &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;, and especially for functions that have side-effects or that could potentially leak sensitive information.</source>
          <target state="translated">SQLITE_DIRECTONLYフラグは、関数がトップレベルSQLからのみ呼び出すことができ、VIEWまたはTRIGGERでも、&lt;a href=&quot;../lang_createtable#ckconst&quot;&gt;CHECK制約&lt;/a&gt;、&lt;a href=&quot;../lang_createtable#dfltval&quot;&gt;DEFAULT句&lt;/a&gt;、&lt;a href=&quot;../expridx&quot;&gt;式インデックス&lt;/a&gt;、&lt;a href=&quot;../partialindex&quot;&gt;部分インデックス&lt;/a&gt;、または&lt;a href=&quot;../gencol&quot;&gt;生成された列&lt;/a&gt;などのスキーマ構造でも使用できないことを意味します。 SQLITE_DIRECTONLYフラグは、すべての&lt;a href=&quot;../appfunc&quot;&gt;アプリケーション定義SQL関数&lt;/a&gt;、特に副作用がある関数や機密情報が漏洩する可能性のある関数に推奨されるセキュリティ機能です。</target>
        </trans-unit>
        <trans-unit id="fbd921523501ad6603970193474c7602b6fd6ef1" translate="yes" xml:space="preserve">
          <source>The SQLITE_DIRECTONLY flag means that the function may only be invoked from top-level SQL, and cannot be used in VIEWs or TRIGGERs nor in schema structures such as &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;, &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;DEFAULT clauses&lt;/a&gt;, &lt;a href=&quot;expridx&quot;&gt;expression indexes&lt;/a&gt;, &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;, or &lt;a href=&quot;gencol&quot;&gt;generated columns&lt;/a&gt;. The SQLITE_DIRECTONLY flags is a security feature which is recommended for all &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;, and especially for functions that have side-effects or that could potentially leak sensitive information.</source>
          <target state="translated">SQLITE_DIRECTONLYフラグは、関数がトップレベルSQLからのみ呼び出すことができ、VIEWまたはTRIGGERでも、&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK制約&lt;/a&gt;、&lt;a href=&quot;lang_createtable#dfltval&quot;&gt;DEFAULT句&lt;/a&gt;、&lt;a href=&quot;expridx&quot;&gt;式インデックス&lt;/a&gt;、&lt;a href=&quot;partialindex&quot;&gt;部分インデックス&lt;/a&gt;、または&lt;a href=&quot;gencol&quot;&gt;生成された列&lt;/a&gt;などのスキーマ構造でも使用できないことを意味します。 SQLITE_DIRECTONLYフラグは、すべての&lt;a href=&quot;appfunc&quot;&gt;アプリケーション定義SQL関数&lt;/a&gt;、特に副作用がある関数や機密情報が漏洩する可能性のある関数に推奨されるセキュリティ機能です。</target>
        </trans-unit>
        <trans-unit id="8bfa7a3aa99efd025281e40fa4911eb7511574c2" translate="yes" xml:space="preserve">
          <source>The SQLITE_DIRECTONLY flag means that the function may only be invoked from top-level SQL, and cannot be used in VIEWs or TRIGGERs. This is a security feature which is recommended for all &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; that have side-effects. This flag prevents an attacker from adding triggers and views to a schema then tricking a high-privilege application into causing unintended side-effects while performing ordinary queries.</source>
          <target state="translated">SQLITE_DIRECTONLYフラグは、関数がトップレベルのSQLからのみ呼び出され、VIEWまたはTRIGGERで使用できないことを意味します。これは、副作用があるすべての&lt;a href=&quot;#sqlite3_create_function&quot;&gt;アプリケーション定義のSQL関数に&lt;/a&gt;推奨されるセキュリティ機能です。このフラグは、攻撃者がトリガーとビューをスキーマに追加し、通常のクエリの実行中に、特権の高いアプリケーションをだまして意図しない副作用を引き起こすのを防ぎます。</target>
        </trans-unit>
        <trans-unit id="ad5270c7d2917dccd93322da5fb7248f9aa949c0" translate="yes" xml:space="preserve">
          <source>The SQLITE_DIRECTONLY flag means that the function may only be invoked from top-level SQL, and cannot be used in VIEWs or TRIGGERs. This is a security feature which is recommended for all &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; that have side-effects. This flag prevents an attacker from adding triggers and views to a schema then tricking a high-privilege application into causing unintended side-effects while performing ordinary queries.</source>
          <target state="translated">SQLITE_DIRECTONLYフラグは、関数がトップレベルのSQLからのみ呼び出され、VIEWまたはTRIGGERで使用できないことを意味します。これは、副作用があるすべての&lt;a href=&quot;create_function&quot;&gt;アプリケーション定義のSQL関数に&lt;/a&gt;推奨されるセキュリティ機能です。このフラグは、攻撃者がトリガーとビューをスキーマに追加し、通常のクエリの実行中に、特権の高いアプリケーションをだまして意図しない副作用を引き起こすのを防ぎます。</target>
        </trans-unit>
        <trans-unit id="ec40aca0df374578f31a734ba1f44f72205f5695" translate="yes" xml:space="preserve">
          <source>The SQLITE_DONE result code indicates that an operation has completed. The SQLITE_DONE result code is most commonly seen as a return value from &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; indicating that the SQL statement has run to completion. But SQLITE_DONE can also be returned by other multi-step interfaces such as &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt;.</source>
          <target state="translated">SQLITE_DONE結果コードは、操作が完了したことを示します。SQLITE_DONE結果コードは、SQLステートメントが&lt;a href=&quot;c3ref/step&quot;&gt;最後&lt;/a&gt;まで実行されたことを示すsqlite3_step（）からの戻り値として最もよく見られます。ただし、SQLITE_DONEは、&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step（）&lt;/a&gt;などの他のマルチステップインターフェースからも返されます。</target>
        </trans-unit>
        <trans-unit id="bb790f9dfaacb5c859298fcd4607429394630f86" translate="yes" xml:space="preserve">
          <source>The SQLITE_EMPTY result code is not currently used.</source>
          <target state="translated">SQLITE_EMPTY 結果コードは現在使用されていません。</target>
        </trans-unit>
        <trans-unit id="ae12a93b43b3b42e7d80f8bbf0372c74ffcd4aa7" translate="yes" xml:space="preserve">
          <source>The SQLITE_ENABLE_SELECTTRACE and SQLITE_ENABLE_WHERETRACE options are not documented in &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; document because they are not officially supported. What they do is activate the &quot;.selecttrace&quot; and &quot;.wheretrace&quot; dot-commands in the command-line shell, which provide low-level tracing output for the logic that generates code for SELECT statements and WHERE clauses, respectively.</source>
          <target state="translated">SQLITE_ENABLE_SELECTTRACEおよびSQLITE_ENABLE_WHERETRACEオプションは、正式にサポートされていないため、&lt;a href=&quot;compile&quot;&gt;コンパイル時オプション&lt;/a&gt;ドキュメントに記載されていません。それらが行うことは、コマンドラインシェルの「.selecttrace」および「.wheretrace」ドットコマンドをアクティブ化することで、それぞれSELECTステートメントとWHERE句のコードを生成するロジックに低レベルのトレース出力を提供します。</target>
        </trans-unit>
        <trans-unit id="270e8d29bbaf2c173c8af4cf652d5609825ae163" translate="yes" xml:space="preserve">
          <source>The SQLITE_ERROR result code is a generic error code that is used when no other more specific error code is available.</source>
          <target state="translated">SQLITE_ERROR の結果コードは、より具体的なエラーコードがない場合に使用される汎用的なエラーコードです。</target>
        </trans-unit>
        <trans-unit id="98c271c04ddb7b453a82bc99e0c9a2f05fc01521" translate="yes" xml:space="preserve">
          <source>The SQLITE_ERROR_MISSING_COLLSEQ result code means that an SQL statement could not be prepared because a collating sequence named in that SQL statement could not be located.</source>
          <target state="translated">SQLITE_ERROR_MISSING_COLLSEQ の結果コードは、その SQL 文の中で名前が付けられた照合順序が見つからなかったために SQL 文を準備できなかったことを意味します。</target>
        </trans-unit>
        <trans-unit id="ba8f59027948d8336d219d332d3588711710c0d1" translate="yes" xml:space="preserve">
          <source>The SQLITE_ERROR_RETRY is used internally to provoke &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; (or one of its sibling routines for creating prepared statements) to try again to prepare a statement that failed with an error on the previous attempt.</source>
          <target state="translated">SQLITE_ERROR_RETRYは内部で使用され、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;（または準備されたステートメントを作成するための兄弟ルーチンの1つ）を呼び出して、前の試行でエラーが発生して失敗したステートメントの準備を再試行します。</target>
        </trans-unit>
        <trans-unit id="ccb2dd2db61b6baf0b7083d2230974437265ca99" translate="yes" xml:space="preserve">
          <source>The SQLITE_ERROR_SNAPSHOT result code might be returned when attempting to start a read transaction on an historical version of the database by using the &lt;a href=&quot;c3ref/snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface. If the historical snapshot is no longer available, then the read transaction will fail with the SQLITE_ERROR_SNAPSHOT. This error code is only possible if SQLite is compiled with &lt;a href=&quot;compile#enable_snapshot&quot;&gt;-DSQLITE_ENABLE_SNAPSHOT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/snapshot_open&quot;&gt;sqlite3_snapshot_open（）&lt;/a&gt;インターフェースを使用して、データベースの履歴バージョンで読み取りトランザクションを開始しようとすると、SQLITE_ERROR_SNAPSHOT結果コードが返される場合があります。履歴スナップショットが利用できなくなった場合、読み取りトランザクションはSQLITE_ERROR_SNAPSHOTで失敗します。このエラーコードは、SQLiteが&lt;a href=&quot;compile#enable_snapshot&quot;&gt;-DSQLITE_ENABLE_SNAPSHOT&lt;/a&gt;でコンパイルされている場合にのみ発生します。</target>
        </trans-unit>
        <trans-unit id="4cbfe2b69087f0c646cf57766f8596a36d37fac1" translate="yes" xml:space="preserve">
          <source>The SQLITE_EXTRA_DURABLE compile-time option that used to cause the default &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; setting to be EXTRA, rather than FULL. This option is no longer supported. Use &lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS=3&lt;/a&gt; instead.</source>
          <target state="translated">デフォルトの&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同期&lt;/a&gt;設定をFULLではなくEXTRAにするために使用されていたSQLITE_EXTRA_DURABLEコンパイル時オプション。このオプションはサポートされなくなりました。代わりに&lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS = 3を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="b13fb7c225046a481ec4f5c3de65895a35d5a534" translate="yes" xml:space="preserve">
          <source>The SQLITE_FORMAT error code is not currently used by SQLite.</source>
          <target state="translated">SQLITE_FORMATエラーコードは、現在のところSQLiteでは使用されていません。</target>
        </trans-unit>
        <trans-unit id="26b0edcf7878a4f55c879fd1aba1c1f540342aa6" translate="yes" xml:space="preserve">
          <source>The SQLITE_FULL result code indicates that a write could not complete because the disk is full. Note that this error can occur when trying to write information into the main database file, or it can also occur when writing into &lt;a href=&quot;tempfiles&quot;&gt;temporary disk files&lt;/a&gt;.</source>
          <target state="translated">SQLITE_FULL結果コードは、ディスクがいっぱいのため、書き込みを完了できなかったことを示します。このエラーは、メインデータベースファイルに情報を書き込もうとしたときに発生したり、&lt;a href=&quot;tempfiles&quot;&gt;一時ディスクファイル&lt;/a&gt;に書き込んだときに発生したりする場合があります。</target>
        </trans-unit>
        <trans-unit id="52c86e9943e29fd3d57282b842d9c3bedce88e03" translate="yes" xml:space="preserve">
          <source>The SQLITE_HISTORY environment variable, if it exists, specifies the name of the command-line editing history file</source>
          <target state="translated">環境変数 SQLITE_HISTORY が存在する場合は、コマンドライン編集履歴ファイルの名前を指定します。</target>
        </trans-unit>
        <trans-unit id="e10c2e4fcb65972fbd71d50bdb5c4ac5d88e54e7" translate="yes" xml:space="preserve">
          <source>The SQLITE_INNOCUOUS flag means that the function is unlikely to cause problems even if misused. An innocuous function should have no side effects and should not depend on any values other than its input parameters. The &lt;a href=&quot;../lang_corefunc#abs&quot;&gt;abs() function&lt;/a&gt; is an example of an innocuous function. The &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension() SQL function&lt;/a&gt; is not innocuous because of its side effects.</source>
          <target state="translated">SQLITE_INNOCUOUSフラグは、誤用された場合でも関数が問題を引き起こす可能性が低いことを意味します。無害な関数には副作用がなく、入力パラメーター以外の値に依存してはなりません。&lt;a href=&quot;../lang_corefunc#abs&quot;&gt;ABS（）関数は、&lt;/a&gt;無害な関数の一例です。&lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension（）SQL関数は&lt;/a&gt;、その副作用の無害ではありません。</target>
        </trans-unit>
        <trans-unit id="a3a2b2609c215ba1aae8c191414849f564b054dd" translate="yes" xml:space="preserve">
          <source>The SQLITE_INNOCUOUS flag means that the function is unlikely to cause problems even if misused. An innocuous function should have no side effects and should not depend on any values other than its input parameters. The &lt;a href=&quot;lang_corefunc#abs&quot;&gt;abs() function&lt;/a&gt; is an example of an innocuous function. The &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension() SQL function&lt;/a&gt; is not innocuous because of its side effects.</source>
          <target state="translated">SQLITE_INNOCUOUSフラグは、誤用された場合でも関数が問題を引き起こす可能性が低いことを意味します。無害な関数には副作用がなく、入力パラメーター以外の値に依存してはなりません。&lt;a href=&quot;lang_corefunc#abs&quot;&gt;ABS（）関数は、&lt;/a&gt;無害な関数の一例です。&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension（）SQL関数は&lt;/a&gt;、その副作用の無害ではありません。</target>
        </trans-unit>
        <trans-unit id="521e2762edbf8211c7cbb9d7bfb58da8a1f086c6" translate="yes" xml:space="preserve">
          <source>The SQLITE_INTERNAL result code indicates an internal malfunction. In a working version of SQLite, an application should never see this result code. If application does encounter this result code, it shows that there is a bug in the database engine.</source>
          <target state="translated">SQLITE_INTERNAL の結果コードは、内部の不具合を示しています。SQLite の動作するバージョンでは、アプリケーションはこの結果コードを決して見るべきではありません。アプリケーションがこの結果コードに遭遇した場合は、データベースエンジンにバグがあることを示しています。</target>
        </trans-unit>
        <trans-unit id="b38d579654b4f1182c07a8a6f5867deba9d19d28" translate="yes" xml:space="preserve">
          <source>The SQLITE_INTERRUPT result code indicates that an operation was interrupted by the &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; interface. See also: &lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;</source>
          <target state="translated">SQLITE_INTERRUPT結果コードは、&lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt（）&lt;/a&gt;インターフェースによって操作が中断されたことを示します。参照：&lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c1b9bcba49ffcf44baa9a43853834f3537e3646" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOCAP_ATOMIC property means that all writes of any size are atomic. The SQLITE_IOCAP_ATOMICnnn values mean that writes of blocks that are nnn bytes in size and are aligned to an address which is an integer multiple of nnn are atomic. The SQLITE_IOCAP_SAFE_APPEND value means that when data is appended to a file, the data is appended first then the size of the file is extended, never the other way around. The SQLITE_IOCAP_SEQUENTIAL property means that information is written to disk in the same order as calls to xWrite().</source>
          <target state="translated">SQLITE_IOCAP_ATOMIC プロパティは、任意のサイズのすべての書き込みがアトミックであることを意味します。SQLITE_IOCAP_ATOMICnnn の値は、サイズが nnn バイトで、nnn の整数倍のアドレスにアラインメントされたブロックの書き込みがアトミックであることを意味します。SQLITE_IOCAP_SAFE_APPEND の値は、データがファイルに追加されるとき、データが最初に追加されてからファイルのサイズが拡張されることを意味します。SQLITE_IOCAP_SEQUENTIAL プロパティは、情報が xWrite()の呼び出しと同じ順番でディスクに書き込まれることを意味します。</target>
        </trans-unit>
        <trans-unit id="6cfdb556dc4a2d2c3aee5156579c0505409a3242" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOCAP_ATOMIC property means that all writes of any size are atomic. The SQLITE_IOCAP_ATOMICnnn values mean that writes of blocks that are nnn bytes in size and are aligned to an address which is an integer multiple of nnn are atomic. The SQLITE_IOCAP_SAFE_APPEND value means that when data is appended to a file, the data is appended first then the size of the file is extended, never the other way around. The SQLITE_IOCAP_SEQUENTIAL property means that information is written to disk in the same order as calls to xWrite(). The SQLITE_IOCAP_POWERSAFE_OVERWRITE property means that after reboot following a crash or power loss, the only bytes in a file that were written at the application level might have changed and that adjacent bytes, even bytes within the same sector are guaranteed to be unchanged. The SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN flag indicates that a file cannot be deleted when open. The SQLITE_IOCAP_IMMUTABLE flag indicates that the file is on read-only media and cannot be changed even by processes with elevated privileges.</source>
          <target state="translated">SQLITE_IOCAP_ATOMIC プロパティは、任意のサイズのすべての書き込みがアトミックであることを意味します。SQLITE_IOCAP_ATOMICnnn の値は、サイズが nnn バイトで、nnn の整数倍のアドレスにアラインメントされたブロックの書き込みがアトミックであることを意味します。SQLITE_IOCAP_SAFE_APPEND の値は、データがファイルに追加されるとき、データが最初に追加されてからファイルのサイズが拡張されることを意味します。SQLITE_IOCAP_SEQUENTIAL プロパティは、情報が xWrite()の呼び出しと同じ順番でディスクに書き込まれることを意味します。SQLITE_IOCAP_POWERSAFE_OVERWRITE プロパティは、クラッシュや電源喪失後の再起動後、アプリケーションレベルで書き込まれたファイル内のバイトだけが変更されている可能性があり、隣接するバイト、たとえ同じセクタ内のバイトであっても変更されないことが保証されていることを意味します。SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN フラグは、オープン時にファイルを削除できないことを示します。SQLITE_IOCAP_IMMUTABLE フラグは、ファイルが読み取り専用メディア上にあり、昇格した権限を持つプロセスであっても変更できないことを示します。</target>
        </trans-unit>
        <trans-unit id="d6e9041084560f5cee1cd0f7e8b2669a77b404b5" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOCAP_BATCH_ATOMIC property means that the underlying filesystem supports doing multiple write operations atomically when those write operations are bracketed by &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; and &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="translated">SQLITE_IOCAP_BATCH_ATOMICプロパティは、それらの書き込み操作が&lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;および&lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;によってブラケット化されている場合、基礎となるファイルシステムが複数の書き込み操作のアトミックな実行をサポートすることを意味します。</target>
        </trans-unit>
        <trans-unit id="7cb11acb1c9a7effbe4c566606f90f111aeaa51c" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOCAP_BATCH_ATOMIC property means that the underlying filesystem supports doing multiple write operations atomically when those write operations are bracketed by &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; and &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="translated">SQLITE_IOCAP_BATCH_ATOMICプロパティは、それらの書き込み操作が&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;および&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;によってブラケット化されている場合、基礎となるファイルシステムが複数の書き込み操作のアトミックな実行をサポートすることを意味します。</target>
        </trans-unit>
        <trans-unit id="abba910b15531d36f82588d451d0981d7b760afc" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR result code says that the operation could not finish because the operating system reported an I/O error.</source>
          <target state="translated">SQLITE_IOERR の結果コードによると、オペレーティング・システムが I/O エラーを報告したため、操作を終了できませんでした。</target>
        </trans-unit>
        <trans-unit id="6217042802c9b2c3161cf544abc5162c5330d1de" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_ACCESS error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xAccess method on the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object.</source>
          <target state="translated">SQLITE_IOERR_ACCESSエラーコードである&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;にxAccessメソッド内でI / Oエラーを示す&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクト。</target>
        </trans-unit>
        <trans-unit id="e2437ab6f22990f68cc3c6b6ab11345e11bf39ab" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_ACCESS error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xClose method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">SQLITE_IOERR_ACCESSエラーコードである&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;にxCloseメソッド内でI / Oエラーを示す&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methodsの&lt;/a&gt;オブジェクト。</target>
        </trans-unit>
        <trans-unit id="d2cdfe432186a7333ec15fb6eebac01e4168d421" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_BLOCKED error code is no longer used.</source>
          <target state="translated">SQLITE_IOERR_BLOCKED エラーコードは使用されなくなりました。</target>
        </trans-unit>
        <trans-unit id="d52b5d2e176049b701cd38566a1ec537e178a582" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_CHECKRESERVEDLOCK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xCheckReservedLock method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">SQLITE_IOERR_CHECKRESERVEDLOCKエラーコードである&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;にxCheckReservedLockメソッド内でI / Oエラーを示す&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methodsの&lt;/a&gt;オブジェクト。</target>
        </trans-unit>
        <trans-unit id="0ad717c7b1ad0bbb8f95440fa25c68effa605b2e" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_CONVPATH error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; used only by Cygwin &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; and indicating that the cygwin_conv_path() system call failed. See also: &lt;a href=&quot;rescode#cantopen_convpath&quot;&gt;SQLITE_CANTOPEN_CONVPATH&lt;/a&gt;</source>
          <target state="translated">SQLITE_IOERR_CONVPATHエラーコードは、Cygwin &lt;a href=&quot;vfs&quot;&gt;VFSで&lt;/a&gt;のみ使用され、cygwin_conv_path（）システムコールが失敗したことを示す&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERRの&lt;/a&gt;&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;です。参照：&lt;a href=&quot;rescode#cantopen_convpath&quot;&gt;SQLITE_CANTOPEN_CONVPATH&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a1351f2d6333fe014b3d2efb02bea78fd2458ea8" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_DELETE_NOENT error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating that the xDelete method on the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object failed because the file being deleted does not exist.</source>
          <target state="translated">SQLITE_IOERR_DELETE_NOENTエラーコードは、&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;にxDelete法ことを示す&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfsが&lt;/a&gt;削除されたファイルが存在しないために失敗したオブジェクト。</target>
        </trans-unit>
        <trans-unit id="3d4ef8736b02588e9ecd702311e3b92f76c71f42" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_DIR_CLOSE error code is no longer used.</source>
          <target state="translated">SQLITE_IOERR_DIR_CLOSE エラーコードが使用されなくなりました。</target>
        </trans-unit>
        <trans-unit id="257039837e1e28ae4885f94438deef37c72bcb03" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_DIR_FSYNC error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer while trying to invoke fsync() on a directory. The unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; attempts to fsync() directories after creating or deleting certain files to ensure that those files will still appear in the filesystem following a power loss or system crash. This error code indicates a problem attempting to perform that fsync().</source>
          <target state="translated">SQLITE_IOERR_DIR_FSYNCエラーコードは、SQLITE_IOERRの&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコードであり&lt;/a&gt;、&lt;a href=&quot;rescode#ioerr&quot;&gt;ディレクトリでfsync&lt;/a&gt;（）を呼び出そうとしたときに&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;レイヤーでI / Oエラーが発生したことを示します。 unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;は、特定のファイルを作成または削除した後にfsync（）ディレクトリを試行して、停電またはシステムクラッシュ後もそれらのファイルがファイルシステムに引き続き表示されるようにします。このエラーコードは、そのfsync（）を実行しようとしたときに問題が発生したことを示しています。</target>
        </trans-unit>
        <trans-unit id="703a40890c81baa50195428ead914670c8029bb4" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_FSTAT error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer while trying to invoke fstat() (or the equivalent) on a file in order to determine information such as the file size or access permissions.</source>
          <target state="translated">SQLITE_IOERR_FSTATエラーコードは、&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のため&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;にI / Oエラーを示す&lt;a href=&quot;vfs&quot;&gt;VFSの&lt;/a&gt;ようなファイルサイズやアクセス権限などの情報を決定するためにファイルを呼び出しFSTAT（）（または同等品）に試みている間層。</target>
        </trans-unit>
        <trans-unit id="4411956ede5824f9653b6f7288932d4d59a1407a" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_FSYNC error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer while trying to flush previously written content out of OS and/or disk-control buffers and into persistent storage. In other words, this code indicates a problem with the fsync() system call in unix or the FlushFileBuffers() system call in windows.</source>
          <target state="translated">SQLITE_IOERR_FSYNCエラーコードは、&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のため&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;にI / Oエラーを示す&lt;a href=&quot;vfs&quot;&gt;VFSの&lt;/a&gt; OS及び/又はディスク制御バッファから永続的なストレージに以前に書き込まれたコンテンツをフラッシュしようとしたときの層。つまり、このコードは、UNIXのfsync（）システムコールまたはWindowsのFlushFileBuffers（）システムコールに問題があることを示しています。</target>
        </trans-unit>
        <trans-unit id="1a80a6afbc34a7c330788ef9f803a0b5991e12c1" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_GETTEMPPATH error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating that the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; is unable to determine a suitable directory in which to place temporary files.</source>
          <target state="translated">SQLITE_IOERR_GETTEMPPATHエラーコードである&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;ことを示す&lt;a href=&quot;vfs&quot;&gt;VFSが&lt;/a&gt;一時ファイルを配置する、適切なディレクトリを決定することができません。</target>
        </trans-unit>
        <trans-unit id="cb09e15d8dd94c07c078d48b512a0e609b4a1ec7" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_LOCK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the advisory file locking logic. Usually an SQLITE_IOERR_LOCK error indicates a problem obtaining a &lt;a href=&quot;lockingv3#pending_lock&quot;&gt;PENDING lock&lt;/a&gt;. However it can also indicate miscellaneous locking errors on some of the specialized &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; used on Macs.</source>
          <target state="translated">SQLITE_IOERR_LOCKエラーコードは、アドバイザリファイルロックロジックのI / Oエラーを示す&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERRの&lt;/a&gt;&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;です。通常、SQLITE_IOERR_LOCKエラーは、保留中の&lt;a href=&quot;lockingv3#pending_lock&quot;&gt;ロックの&lt;/a&gt;取得に問題があることを示します。ただし、Macで使用されている一部の特殊な&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;でのその他のロックエラーを示している場合もあります。</target>
        </trans-unit>
        <trans-unit id="928b9fb773e51d9b98d4eea6c5ad41e7a120edb9" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_MMAP error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xFetch or xUnfetch methods on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object while trying to map or unmap part of the database file into the process address space.</source>
          <target state="translated">SQLITE_IOERR_MMAPエラーコードは、&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERRが&lt;/a&gt;オンxFetch又はxUnfetchメソッド内でI / Oエラーを示す&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methodsの&lt;/a&gt;プロセスのアドレス空間にデータベース・ファイルの一部をマップまたはマップ解除しようとしたときのオブジェクト。</target>
        </trans-unit>
        <trans-unit id="f2e769d752ed0575abbf0db74e042a1d936197ca" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_NOMEM error code is sometimes returned by the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer to indicate that an operation could not be completed due to the inability to allocate sufficient memory. This error code is normally converted into &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; by the higher layers of SQLite before being returned to the application.</source>
          <target state="translated">SQLITE_IOERR_NOMEMエラーコードは、十分なメモリを割り当てることができないために操作を完了できなかったことを示すために、&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;レイヤーによって時々返されます。このエラーコードは通常、アプリケーションに返される前に、SQLiteの上位層によって&lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEMに&lt;/a&gt;変換されます。</target>
        </trans-unit>
        <trans-unit id="8545169dd7924f6c6604c36309fb09b48638942a" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_READ error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer while trying to read from a file on disk. This error might result from a hardware malfunction or because a filesystem came unmounted while the file was open.</source>
          <target state="translated">SQLITE_IOERR_READエラーコードは、&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のため&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;にI / Oエラーを示す&lt;a href=&quot;vfs&quot;&gt;VFSの&lt;/a&gt;ディスク上のファイルから読み取るしようとしたときの層。このエラーは、ハードウェアの誤動作、またはファイルが開いている間にファイルシステムがマウント解除されたことが原因である可能性があります。</target>
        </trans-unit>
        <trans-unit id="1b973a2eb159aa040eee4609af08e2a1feaa8688" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_SEEK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xRead or xWrite methods on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object while trying to seek a file descriptor to the beginning point of the file where the read or write is to occur.</source>
          <target state="translated">SQLITE_IOERR_SEEKエラーコードは、&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;にXREAD又はxWriteメソッド内でI / Oエラーを示す&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;読み取りまたは書き込みが発生するファイルの開始点までのファイル記述子をシークしようとしたときにオブジェクト。</target>
        </trans-unit>
        <trans-unit id="105abf471dd5b51825236d9c7cd0fbb3eb6cb7cd" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_SHMLOCK error code is no longer used.</source>
          <target state="translated">SQLITE_IOERR_SHMLOCK エラーコードが使用されなくなりました。</target>
        </trans-unit>
        <trans-unit id="19454e66c26708e9c7b0cf7de58d9fc407f5f14b" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_SHMMAP error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xShmMap method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object while trying to map a shared memory segment into the process address space.</source>
          <target state="translated">SQLITE_IOERR_SHMMAPエラーコードである&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERRが&lt;/a&gt;上xShmMapメソッド内でI / Oエラーを示す&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methodsの&lt;/a&gt;プロセスのアドレス空間に共有メモリセグメントをマッピングしようとしたときにオブジェクト。</target>
        </trans-unit>
        <trans-unit id="2dc7d56b93948bb563eb131a1d4f4001df7a785f" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_SHMOPEN error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xShmMap method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object while trying to open a new shared memory segment.</source>
          <target state="translated">SQLITE_IOERR_SHMOPENエラーコードは、&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERRが&lt;/a&gt;上xShmMapメソッド内でI / Oエラーを示す&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methodsの&lt;/a&gt;新たな共有メモリセグメントを開くしようとしているときにオブジェクト。</target>
        </trans-unit>
        <trans-unit id="38683c7c8ec002f5c2268623f613c65a832d0744" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_SHMSIZE error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xShmMap method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object while trying to enlarge a &lt;a href=&quot;walformat#shm&quot;&gt;&quot;shm&quot; file&lt;/a&gt; as part of &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; transaction processing. This error may indicate that the underlying filesystem volume is out of space.</source>
          <target state="translated">SQLITE_IOERR_SHMSIZEエラーコードは、&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERRが&lt;/a&gt;上xShmMapメソッド内でI / Oエラーを示す&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methodsを&lt;/a&gt;拡大しようとしたときにオブジェクト&lt;a href=&quot;walformat#shm&quot;&gt;「SHM」ファイル&lt;/a&gt;の一部として&lt;a href=&quot;wal&quot;&gt;WALモード&lt;/a&gt;トランザクション処理。このエラーは、基礎となるファイルシステムボリュームの容量が不足していることを示している可能性があります。</target>
        </trans-unit>
        <trans-unit id="9742197ad61d509380008ae49be67afbc4a5ec72" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_SHORT_READ error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating that a read attempt in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer was unable to obtain as many bytes as was requested. This might be due to a truncated file.</source>
          <target state="translated">SQLITE_IOERR_SHORT_READエラーコードである&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;の読み出しの試みていることを示す&lt;a href=&quot;vfs&quot;&gt;VFSの&lt;/a&gt;層が要求されたようなバイト数として得ることができませんでした。これは、切り捨てられたファイルが原因である可能性があります。</target>
        </trans-unit>
        <trans-unit id="11a04eeb47de957ef3978cba210956d9cb5d652c" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_TRUNCATE error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer while trying to truncate a file to a smaller size.</source>
          <target state="translated">SQLITE_IOERR_TRUNCATEエラーコードは、&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のため&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;にI / Oエラーを示す&lt;a href=&quot;vfs&quot;&gt;VFSの&lt;/a&gt;小さいサイズにファイルを切り捨てるしようとしたときの層。</target>
        </trans-unit>
        <trans-unit id="fea43ead41e3ee8f14dc4f738a5d86af22fa9867" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_UNLOCK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within xDelete method on the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object.</source>
          <target state="translated">SQLITE_IOERR_UNLOCKエラーコードである&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;にxDeleteメソッド内でI / Oエラーを示す&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクト。</target>
        </trans-unit>
        <trans-unit id="0b74fa52836b69d8f9666b0cd822fdd7307145f4" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_UNLOCK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within xLock method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object while trying to obtain a read lock.</source>
          <target state="translated">SQLITE_IOERR_UNLOCKエラーコードである&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;にXLOCKメソッド内でI / Oエラーを示す&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;読み取りロックを取得しようとしているときにオブジェクト。</target>
        </trans-unit>
        <trans-unit id="c346b35d66f482df6af0e3e742d33c4546a4dc99" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_UNLOCK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within xUnlock method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">SQLITE_IOERR_UNLOCKエラーコードである&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;にxUnlockメソッド内でI / Oエラーを示す&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methodsの&lt;/a&gt;オブジェクト。</target>
        </trans-unit>
        <trans-unit id="7f8d955a87bc68c4a0c5a3d4a1efee03acc84572" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_WRITE error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer while trying to write into a file on disk. This error might result from a hardware malfunction or because a filesystem came unmounted while the file was open. This error should not occur if the filesystem is full as there is a separate error code (SQLITE_FULL) for that purpose.</source>
          <target state="translated">SQLITE_IOERR_WRITEエラーコードは、&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のため&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;にI / Oエラーを示す&lt;a href=&quot;vfs&quot;&gt;VFSの&lt;/a&gt;ディスク上のファイルに書き込もうとしながら、層。このエラーは、ハードウェアの誤動作、またはファイルが開いている間にファイルシステムがマウント解除されたことが原因である可能性があります。この目的のために別のエラーコード（SQLITE_FULL）があるため、ファイルシステムがいっぱいの場合、このエラーは発生しません。</target>
        </trans-unit>
        <trans-unit id="81a8e9c53d139815a64f5839604fdd22fadaa0e7" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCKED result code differs from &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; in that SQLITE_LOCKED indicates a conflict on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; (or on a connection with a &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt;) whereas &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; indicates a conflict with a different database connection, probably in a different process.</source>
          <target state="translated">SQLITE_LOCKEDの結果コードは&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;とは異なります。SQLITE_LOCKEDは同じ&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;（または&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュ&lt;/a&gt;との接続）での競合を示し、&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;は異なるデータベース接続での競合（おそらく別のプロセス）を示します。</target>
        </trans-unit>
        <trans-unit id="a782dd7cfb6d09bfdc0225cdd7b256e70fd078f6" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCKED result code indicates that a write operation could not continue because of a conflict within the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; or a conflict with a different database connection that uses a &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt;.</source>
          <target state="translated">SQLITE_LOCKED結果コードは、同じ&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;内の競合、または&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュ&lt;/a&gt;を使用する別のデータベース接続との競合が原因で、書き込み操作を続行できなかったことを示しています。</target>
        </trans-unit>
        <trans-unit id="82a5261f187f8bb18f86e6b8f8f93ccb09c0a9f0" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCKED_SHARECACHE error code works very much like the &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error code except that SQLITE_LOCKED_SHARECACHE is for separate database connections that share a cache whereas SQLITE_BUSY is for the much more common case of separate database connections that do not share the same cache. Also, the &lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt; and &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; interfaces do not help in resolving SQLITE_LOCKED_SHAREDCACHE conflicts.</source>
          <target state="translated">SQLITE_LOCKED_SHARECACHEは、&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;エラーコードと非常によく似ていますが、SQLITE_LOCKED_SHARECACHEは、キャッシュを共有する個別のデータベース接続用であり、SQLITE_BUSYは、同じキャッシュを共有しない個別のデータベース接続のより一般的なケース用です。また、&lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler（）&lt;/a&gt;および&lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt;インターフェースは、SQLITE_LOCKED_SHAREDCACHEの競合の解決に役立ちません。</target>
        </trans-unit>
        <trans-unit id="43736bf56a426c4b58c2bec90f4d48ac9099897c" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCKED_SHAREDCACHE error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; indicating that the locking conflict has occurred due to contention with a different &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; that happens to hold a &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; with the database connection to which the error was returned. For example, if the other database connection is holding an &lt;a href=&quot;lockingv3#excl_lock&quot;&gt;exclusive lock&lt;/a&gt; on the database, then the database connection that receives this error will be unable to read or write any part of the database file unless it has the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; enabled.</source>
          <target state="translated">SQLITE_LOCKED_SHAREDCACHEエラーコードは、&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt;ロック競合が異なるとの競合が原因で発生したことを示す&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;を保持するために起こる&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュ&lt;/a&gt;エラーが返されたのデータベース接続とします。たとえば、他のデータベース接続がデータベースの&lt;a href=&quot;lockingv3#excl_lock&quot;&gt;排他ロック&lt;/a&gt;を保持している場合、このエラーを受け取ったデータベース接続は、&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommittedプラグマが&lt;/a&gt;有効になっていない限り、データベースファイルの一部を読み書きできません。</target>
        </trans-unit>
        <trans-unit id="3cda10b684d70e57b826f0fa4c4df09ccba017aa" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCKED_VTAB result code is not used by the SQLite core, but it is available for use by extensions. Virtual table implementations can return this result code to indicate that they cannot complete the current operation because of locks held by other threads or processes.</source>
          <target state="translated">SQLITE_LOCKED_VTAB 結果コードは SQLite コアでは使用されませんが、拡張機能では使用可能です。仮想テーブルの実装はこの結果コードを返すことで、他のスレッドやプロセスがロックを保持しているために現在の操作を完了できないことを示すことができます。</target>
        </trans-unit>
        <trans-unit id="e51cbf2f4ccfc41ba0ad01c890bead2935bfa934" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCK_EXCLUSIVE lock must be held by a connection that wants to transition into our out of WAL mode. Transitioning into WAL mode is, therefore, just like any other write transaction, since every write transaction in rollback mode requires the SQLITE_LOCK_EXCLUSIVE lock. If the database file is already in WAL mode (hence if the desire it to change it back into rollback mode) and if there are two or more connections to the database, then each of these connections will be holding an SQLITE_LOCK_SHARED lock. That means that the SQLITE_LOCK_EXCLUSIVE cannot be obtained, and the transition out of WAL mode will not be allowed. This prevents one connection from deleting WAL mode out from under another. It also means that the only way to move a database from WAL mode into rollback mode is to close all but one connection to the database.</source>
          <target state="translated">SQLITE_LOCK_EXCLUSIVE ロックは、WAL モードからの移行を希望する接続で保持する必要があります。WALモードへの移行は、ロールバックモードのすべての書き込みトランザクションにSQLITE_LOCK_EXCLUSIVEロックが必要なので、他の書き込みトランザクションと同じように行うことができます。データベースファイルがすでにWALモードになっていて(ロールバックモードに戻したい場合)、データベースへの接続が2つ以上ある場合、それぞれの接続はSQLITE_LOCK_SHAREDロックを保持していることになります。つまり、SQLITE_LOCK_EXCLUSIVEを取得することができず、WALモードからの移行ができなくなります。これにより、ある接続が別の接続の下からWALモードを削除することができなくなります。また、データベースをWALモードからロールバックモードに移行する唯一の方法は、データベースへの1つの接続を除くすべての接続を閉じることであることを意味します。</target>
        </trans-unit>
        <trans-unit id="bc70544c321ca8a14f098bcf8a7d9ab71f0f189a" translate="yes" xml:space="preserve">
          <source>The SQLITE_MAX_COLUMN compile-time parameter is used to set an upper bound on:</source>
          <target state="translated">SQLITE_MAX_COLUMN コンパイル時のパラメータを使用して、その上限を設定します。</target>
        </trans-unit>
        <trans-unit id="6525988f532e320cb712d12a43eb0921bdec4dc2" translate="yes" xml:space="preserve">
          <source>The SQLITE_MAX_EXPR_DEPTH parameter determines the maximum expression tree depth. If the value is 0, then no limit is enforced. The current implementation has a default value of 1000.</source>
          <target state="translated">SQLITE_MAX_EXPR_DEPTH パラメータは、式ツリーの最大深度を指定します。値が0の場合、制限はありません。現在の実装では、デフォルト値は1000です。</target>
        </trans-unit>
        <trans-unit id="87bafa8316c35e0283e8d900b37b61b6cd965c07" translate="yes" xml:space="preserve">
          <source>The SQLITE_MAX_FUNCTION_ARG parameter determines the maximum number of parameters that can be passed to an SQL function. The default value of this limit is 100. SQLite should work with functions that have thousands of parameters. However, we suspect that anybody who tries to invoke a function with more than a few parameters is really trying to find security exploits in systems that use SQLite, not do useful work, and so for that reason we have set this parameter relatively low.</source>
          <target state="translated">SQLITE_MAX_FUNCTION_ARG パラメータは、SQL 関数に渡すことができるパラメータの最大数を指定します。この制限のデフォルト値は 100 です。SQLite は何千ものパラメータを持つ関数で動作するはずです。しかし、数個以上のパラメータを持つ関数を呼び出そうとする人は、有用な作業をするのではなく、SQLiteを使用しているシステムのセキュリティ攻撃を見つけようとしているのではないかと疑っています。</target>
        </trans-unit>
        <trans-unit id="189922ac7fd95f7c9bc12f9ce7e9ab04f1adf79f" translate="yes" xml:space="preserve">
          <source>The SQLITE_MAX_PAGE_SIZE compile-time option is now silently ignored. The maximum page size is hard-coded at 65536 bytes.</source>
          <target state="translated">SQLITE_MAX_PAGE_SIZE コンパイル時オプションは無視されるようになりました。最大ページサイズは 65536 バイトでハードコードされています。</target>
        </trans-unit>
        <trans-unit id="862c9c40eeff1a20092e93732416f94a8f2c333f" translate="yes" xml:space="preserve">
          <source>The SQLITE_MEMDEBUG option causes an instrumented &lt;a href=&quot;malloc#memdebug&quot;&gt;debugging memory allocator&lt;/a&gt; to be used as the default memory allocator within SQLite. The instrumented memory allocator checks for misuse of dynamically allocated memory. Examples of misuse include using memory after it is freed, writing off the ends of a memory allocation, freeing memory not previously obtained from the memory allocator, or failing to initialize newly allocated memory.</source>
          <target state="translated">SQLITE_MEMDEBUGオプションを使用&lt;a href=&quot;malloc#memdebug&quot;&gt;する&lt;/a&gt;と、インストルメント化されたデバッグメモリアロケータがSQLite内のデフォルトのメモリアロケータとして使用されます。インストルメントされたメモリアロケータは、動的に割り当てられたメモリの誤用をチェックします。誤用の例としては、解放後のメモリの使用、メモリ割り当ての両端の書き込み、以前にメモリアロケータから取得していないメモリの解放、または新しく割り当てられたメモリの初期化の失敗などがあります。</target>
        </trans-unit>
        <trans-unit id="d5d3984ec504895ac3fbb00da3cebcbba9dedbe7" translate="yes" xml:space="preserve">
          <source>The SQLITE_MEMSTAT Virtual Table</source>
          <target state="translated">SQLITE_MEMSTAT 仮想テーブル</target>
        </trans-unit>
        <trans-unit id="21d4cb84411a45f761656443b3561b46a357ff18" translate="yes" xml:space="preserve">
          <source>The SQLITE_MEMSTAT extension implements an &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual table&lt;/a&gt; that provides SQL access to the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64()&lt;/a&gt; and &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interfaces.</source>
          <target state="translated">SQLITE_MEMSTAT拡張は、&lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64（）&lt;/a&gt;および&lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;インターフェースへのSQLアクセスを提供する、代名詞&lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;のみの仮想テーブル&lt;/a&gt;を実装します。</target>
        </trans-unit>
        <trans-unit id="aad795204ac31f320600f752e689de3d922a2bd2" translate="yes" xml:space="preserve">
          <source>The SQLITE_MEMSTAT table appears to have the following schema:</source>
          <target state="translated">SQLITE_MEMSTAT テーブルには、以下のスキーマがあるようです。</target>
        </trans-unit>
        <trans-unit id="c5c71018abf94b8f9efc3c61940d93dd9b424da6" translate="yes" xml:space="preserve">
          <source>The SQLITE_MEMSTAT virtual table is a read-only table that can be queried to determine performance characteristics (primarily the amount of memory being used) of the current instance of SQLite. The SQLITE_MEMSTATE table is essentially a wrapper around the C-language APIs &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64()&lt;/a&gt; and &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt;. If the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/memstat.c&quot;&gt;memstat.c&lt;/a&gt; source file is compiled with the -DSQLITE_ENABLE_ZIPVFS option, then SQLITE_MEMSTAT will also do some &lt;a href=&quot;c3ref/file_control&quot;&gt;file-control&lt;/a&gt; calls to extract memory usage information about the &lt;a href=&quot;https://www.hwaci.com/sw/sqlite/zipvfs.html&quot;&gt;ZIPVFS&lt;/a&gt; subsystem, if that subsystem as been licensed, installed, and is in use.</source>
          <target state="translated">SQLITE_MEMSTAT仮想テーブルは、SQLiteの現在のインスタンスのパフォーマンス特性（主に使用されているメモリの量）を判断するためにクエリできる読み取り専用テーブルです。 SQLITE_MEMSTATEテーブルは基本的に、C言語のAPIである&lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64（）&lt;/a&gt;および&lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status（）の&lt;/a&gt;ラッパーです。場合&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/memstat.c&quot;&gt;memstat.cの&lt;/a&gt;ソースファイルが-DSQLITE_ENABLE_ZIPVFSオプションでコンパイルされ、その後、SQLITE_MEMSTATもいくつか行います&lt;a href=&quot;c3ref/file_control&quot;&gt;ファイル制御&lt;/a&gt;に関するエキスメモリの使用状況に関する情報の呼び出し&lt;a href=&quot;https://www.hwaci.com/sw/sqlite/zipvfs.html&quot;&gt;ZIPVFSの&lt;/a&gt;、ライセンスのインストール、およびされているサブシステムが使用されている場合、サブシステムを。</target>
        </trans-unit>
        <trans-unit id="3941fc28dfa25db6c38115ec794332d498f61a67" translate="yes" xml:space="preserve">
          <source>The SQLITE_MISMATCH error code indicates a datatype mismatch.</source>
          <target state="translated">SQLITE_MISMATCH エラー・コードは、データ型の不一致を示しています。</target>
        </trans-unit>
        <trans-unit id="545fecc55ea90185cbbd63fd3b5f04d2c005fc32" translate="yes" xml:space="preserve">
          <source>The SQLITE_MISUSE return code might be returned if the application uses any SQLite interface in a way that is undefined or unsupported. For example, using a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; after that prepared statement has been &lt;a href=&quot;c3ref/finalize&quot;&gt;finalized&lt;/a&gt; might result in an SQLITE_MISUSE error.</source>
          <target state="translated">アプリケーションがSQLiteインターフェースを未定義またはサポートされていない方法で使用すると、SQLITE_MISUSE戻りコードが返される場合があります。例えば、使用して&lt;a href=&quot;c3ref/stmt&quot;&gt;プリペアドステートメントを&lt;/a&gt;その準備された文がされた後に&lt;a href=&quot;c3ref/finalize&quot;&gt;確定&lt;/a&gt; SQLITE_MISUSEエラーになる場合があります。</target>
        </trans-unit>
        <trans-unit id="7378cf4ec519f0105a315e8c418689ed2c8b9d03" translate="yes" xml:space="preserve">
          <source>The SQLITE_MUTEX_APPDEF compile-time option is no longer supported. Alternative mutex implementations can now be added at run-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface with the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; verb. *** Potentially incompatible change ***</source>
          <target state="translated">SQLITE_MUTEX_APPDEFコンパイル時オプションはサポートされなくなりました。&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt;動詞で&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;インターフェースを使用して、代替のmutex実装を実行時に追加できるようになりました。***互換性がない可能性のある変更***</target>
        </trans-unit>
        <trans-unit id="b652223c3c3d5b396101734631bda4e93654d297" translate="yes" xml:space="preserve">
          <source>The SQLITE_MUTEX_APPDEF compile-time parameter is no longer recognized. As a replacement, alternative &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;mutex implementations&lt;/a&gt; may be created at runtime using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; with the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; operator and the &lt;a href=&quot;c3ref/mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; object.</source>
          <target state="translated">SQLITE_MUTEX_APPDEFコンパイル時パラメーターは認識されなくなりました。代わりに、&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt;演算子と&lt;a href=&quot;c3ref/mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt;オブジェクトを&lt;a href=&quot;c3ref/config&quot;&gt;指定&lt;/a&gt;したsqlite3_config（）を使用して、実行時に代替&lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;mutex実装&lt;/a&gt;を作成できます。</target>
        </trans-unit>
        <trans-unit id="d2c0584076e7e10d1a5a608c7c90ebdabce289b7" translate="yes" xml:space="preserve">
          <source>The SQLITE_MUTEX_NOOP implementation is a set of routines that does no real locking and is appropriate for use in a single-threaded application. The SQLITE_MUTEX_PTHREADS and SQLITE_MUTEX_W32 implementations are appropriate for use on Unix and Windows.</source>
          <target state="translated">SQLITE_MUTEX_NOOP 実装は、実際のロックを行わないルーチンのセットであり、シングルスレッドアプリケーションでの使用に適しています。SQLITE_MUTEX_PTHREADS および SQLITE_MUTEX_W32 実装は、Unix および Windows での使用に適しています。</target>
        </trans-unit>
        <trans-unit id="8dd7fbf941fcd0cbf4106dee4f6ff2100d3cc081" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOLFS error can be returned on systems that do not support large files when the database grows to be larger than what the filesystem can handle. &quot;NOLFS&quot; stands for &quot;NO Large File Support&quot;.</source>
          <target state="translated">SQLITE_NOLFS エラーは、ラージファイルをサポートしていないシステムで、データベースがファイルシステムが扱えるサイズよりも大きくなったときに返されることがあります。&quot;NOLFS&quot; は &quot;NO Large File Support&quot; の略です。</target>
        </trans-unit>
        <trans-unit id="1cda63147d327bf25d081e640b795908860d57cd" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOMEM result code indicates that SQLite was unable to allocate all the memory it needed to complete the operation. In other words, an internal call to &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc()&lt;/a&gt; has failed in a case where the memory being allocated was required in order to continue the operation.</source>
          <target state="translated">SQLITE_NOMEM結果コードは、SQLiteが操作を完了するために必要なすべてのメモリを割り当てることができなかったことを示しています。つまり、操作を続行するために割り当てられているメモリが必要な場合に、&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;または&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;への内部呼び出しが失敗しました。</target>
        </trans-unit>
        <trans-unit id="90348aff38a7fe2d16e98097b8d995eefcd13821" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOTFOUND result code is also used internally by the SQLite implementation, but those internal uses are not exposed to the application.</source>
          <target state="translated">SQLITE_NOTFOUNDの結果コードはSQLiteの実装でも内部的に使用されていますが、これらの内部的な使用はアプリケーションには公開されていません。</target>
        </trans-unit>
        <trans-unit id="04b892d49dde78c36512aea678380b1b3cb4740c" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOTFOUND result code is used in two contexts. SQLITE_NOTFOUND can be returned by the &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface to indicate that the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write&quot;&gt;file control opcode&lt;/a&gt; passed as the third argument was not recognized by the underlying &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. SQLITE_NOTFOUND can also be returned by the xSetSystemCall() method of an &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object.</source>
          <target state="translated">SQLITE_NOTFOUND結果コードは、2つのコンテキストで使用されます。SQLITE_NOTFOUNDは&lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control（）&lt;/a&gt;インターフェースから返され、3番目の引数として渡された&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write&quot;&gt;ファイル制御オペコード&lt;/a&gt;が、基礎となる&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;によって認識されなかったことを示します。SQLITE_NOTFOUNDは、&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトのxSetSystemCall（）メソッドによっても返されます。</target>
        </trans-unit>
        <trans-unit id="2006836e7cf841369d470c41165b6630c3c15ae9" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOTICE result code is not returned by any C/C++ interface. However, SQLITE_NOTICE (or rather one of its &lt;a href=&quot;rescode#extrc&quot;&gt;extended error codes&lt;/a&gt;) is sometimes used as the first argument in an &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; callback to indicate that an unusual operation is taking place.</source>
          <target state="translated">SQLITE_NOTICE結果コードは、どのC / C ++インターフェースからも返されません。ただし、SQLITE_NOTICE（またはその&lt;a href=&quot;rescode#extrc&quot;&gt;拡張エラーコードの&lt;/a&gt; 1つ）が&lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log（）&lt;/a&gt;コールバックの最初の引数として使用され、異常な操作が行われていることを示す場合があります。</target>
        </trans-unit>
        <trans-unit id="02cb61634cf3f64c55c04a76d9ecf0d6931de129" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOTICE_RECOVER_ROLLBACK result code is passed to the callback of &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; when a &lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;hot journal&lt;/a&gt; is rolled back.</source>
          <target state="translated">SQLITE_NOTICE_RECOVER_ROLLBACK結果コードのコールバックに渡される&lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log（）&lt;/a&gt;場合&lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;ホットジャーナルが&lt;/a&gt;ロールバックされます。</target>
        </trans-unit>
        <trans-unit id="f198e3499c541e2a07f04094a1095a33b4f9550d" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOTICE_RECOVER_WAL result code is passed to the callback of &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; when a &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; database file is recovered.</source>
          <target state="translated">SQLITE_NOTICE_RECOVER_WAL結果コードは、&lt;a href=&quot;wal&quot;&gt;WALモードの&lt;/a&gt;データベースファイルがリカバリされるときに&lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log（）の&lt;/a&gt;コールバックに渡されます。</target>
        </trans-unit>
        <trans-unit id="ee291eadebc9e5d4151fc8b157f062bbbf6ed568" translate="yes" xml:space="preserve">
          <source>The SQLITE_OK result code means that the operation was successful and that there were no errors. Most other result codes indicate an error.</source>
          <target state="translated">SQLITE_OK 結果コードは、操作が成功し、エラーがなかったことを意味します。他のほとんどの結果コードはエラーを示します。</target>
        </trans-unit>
        <trans-unit id="db1bbd15a81f09ee87a066e983ed6980b9d26517" translate="yes" xml:space="preserve">
          <source>The SQLITE_OK_LOAD_PERMANENTLY return code is useful to &lt;a href=&quot;loadext&quot;&gt;loadable extensions&lt;/a&gt; that register new &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;, for example.</source>
          <target state="translated">SQLITE_OK_LOAD_PERMANENTLYリターンコードは、たとえば、新しい&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;を登録する&lt;a href=&quot;loadext&quot;&gt;ロード可能な拡張機能に&lt;/a&gt;役立ちます。</target>
        </trans-unit>
        <trans-unit id="6becbabbe4a84dad21c1b1544eb673040cac46e2" translate="yes" xml:space="preserve">
          <source>The SQLITE_OMIT_* options are unsupported. By this we mean that an SQLITE_OMIT_* option that omits code from the build in the current release might become a no-op in the next release. Or the other way around: an SQLITE_OMIT_* that is a no-op in the current release might cause code to be excluded in the next release. Also, not all SQLITE_OMIT_* options are tested. Some SQLITE_OMIT_* options might cause SQLite to malfunction and/or provide incorrect answers.</source>
          <target state="translated">SQLITE_OMIT_*オプションはサポートされていません。これは、現在のリリースでビルドからコードを省略する SQLITE_OMIT_*オプションが、次のリリースでは無効になる可能性があることを意味します。また、現在のリリースではno-opであるSQLITE_OMIT_*は、次のリリースではコードが除外される可能性があります。また、すべての SQLITE_OMIT_*オプションがテストされているわけではありません。いくつかの SQLITE_OMIT_*オプションは、SQLite が誤動作したり、正しくない答えを提供したりする原因になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="5d47886ed69e3788c34a2d6c9a632c5948855a34" translate="yes" xml:space="preserve">
          <source>The SQLITE_OMIT_MERGE_SORT option has been removed. The merge sorter is now a required component of SQLite.</source>
          <target state="translated">SQLITE_OMIT_MERGE_SORT オプションが削除されました。マージソーターは SQLite の必須コンポーネントとなりました。</target>
        </trans-unit>
        <trans-unit id="2ace5bda746aeaa5497bcf0c7e8c12395a91c1c1" translate="yes" xml:space="preserve">
          <source>The SQLITE_PERM result code indicates that the requested access mode for a newly created database could not be provided.</source>
          <target state="translated">SQLITE_PERM 結果コードは、新しく作成されたデータベースに対して要求されたアクセス・モードを提供できなかったことを示しています。</target>
        </trans-unit>
        <trans-unit id="57074805a6a2909f8660b15999da8d8adc66e584" translate="yes" xml:space="preserve">
          <source>The SQLITE_PREPARE_NORMALIZE flag is a no-op. This flag used to be required for any prepared statement that wanted to use the &lt;a href=&quot;#sqlite3_expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt; interface. However, the &lt;a href=&quot;#sqlite3_expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt; interface is now available to all prepared statements, regardless of whether or not they use this flag.</source>
          <target state="translated">SQLITE_PREPARE_NORMALIZEフラグは何もしません。このフラグは、&lt;a href=&quot;#sqlite3_expanded_sql&quot;&gt;sqlite3_normalized_sql（）&lt;/a&gt;インターフェースを使用したい準備済みステートメントに必要でした。ただし、&lt;a href=&quot;#sqlite3_expanded_sql&quot;&gt;sqlite3_normalized_sql（）&lt;/a&gt;インターフェースは、このフラグを使用するかどうかに関係なく、すべての準備済みステートメントで使用できるようになりました。</target>
        </trans-unit>
        <trans-unit id="1ad4cab077701a7da0038bd41b3f79ceedfd12d8" translate="yes" xml:space="preserve">
          <source>The SQLITE_PREPARE_NORMALIZE flag is a no-op. This flag used to be required for any prepared statement that wanted to use the &lt;a href=&quot;expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt; interface. However, the &lt;a href=&quot;expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt; interface is now available to all prepared statements, regardless of whether or not they use this flag.</source>
          <target state="translated">SQLITE_PREPARE_NORMALIZEフラグは何もしません。このフラグは、&lt;a href=&quot;expanded_sql&quot;&gt;sqlite3_normalized_sql（）&lt;/a&gt;インターフェースを使用したい準備済みステートメントに必要でした。ただし、&lt;a href=&quot;expanded_sql&quot;&gt;sqlite3_normalized_sql（）&lt;/a&gt;インターフェースは、このフラグを使用するかどうかに関係なく、すべての準備済みステートメントで使用できるようになりました。</target>
        </trans-unit>
        <trans-unit id="a0438ba55e3894ec50e9427fa15e7d877e35f842" translate="yes" xml:space="preserve">
          <source>The SQLITE_PREPARE_NO_VTAB flag causes the SQL compiler to return an error (error code SQLITE_ERROR) if the statement uses any virtual tables.</source>
          <target state="translated">SQLITE_PREPARE_NO_VTAB フラグは、文が仮想テーブルを使用している場合、SQL コンパイラがエラー (エラーコード SQLITE_ERROR)を返します。</target>
        </trans-unit>
        <trans-unit id="68c6b699083a20e7dac515dfb0a940a1d2fa1d0a" translate="yes" xml:space="preserve">
          <source>The SQLITE_PREPARE_PERSISTENT flag is a hint to the query planner that the prepared statement will be retained for a long time and probably reused many times. Without this flag, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; assume that the prepared statement will be used just once or at most a few times and then destroyed using &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; relatively soon. The current implementation acts on this hint by avoiding the use of &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory&lt;/a&gt; so as not to deplete the limited store of lookaside memory. Future versions of SQLite may act on this hint differently.</source>
          <target state="translated">SQLITE_PREPARE_PERSISTENTフラグは、準備されたステートメントが長期間保持され、おそらく何度も再利用されるというクエリプランナーへのヒントです。このフラグがない場合、&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;および&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;は、準備されたステートメントが1回だけまたは多くても数回使用され、その後&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;を使用して比較的すぐに破棄されると想定します。現在の実装では、&lt;a href=&quot;malloc#lookaside&quot;&gt;ルックアサイドメモリ&lt;/a&gt;の使用を回避することにより、このヒントに基づいて、ルックアサイドメモリの限られたストアを使い果たしないようにしています。 SQLiteの将来のバージョンでは、このヒントに対する動作が異なる可能性があります。</target>
        </trans-unit>
        <trans-unit id="799dbb7451dd41ca217be627d63018af5431d1bf" translate="yes" xml:space="preserve">
          <source>The SQLITE_PREPARE_PERSISTENT flag is a hint to the query planner that the prepared statement will be retained for a long time and probably reused many times. Without this flag, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; assume that the prepared statement will be used just once or at most a few times and then destroyed using &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; relatively soon. The current implementation acts on this hint by avoiding the use of &lt;a href=&quot;../malloc#lookaside&quot;&gt;lookaside memory&lt;/a&gt; so as not to deplete the limited store of lookaside memory. Future versions of SQLite may act on this hint differently.</source>
          <target state="translated">SQLITE_PREPARE_PERSISTENTフラグは、準備されたステートメントが長期間保持され、おそらく何度も再利用されるというクエリプランナーへのヒントです。このフラグがない場合、&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3（）&lt;/a&gt;および&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;は、準備されたステートメントが1回だけまたは多くても数回使用され、その後&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;を使用して比較的すぐに破棄されると想定します。現在の実装では、&lt;a href=&quot;../malloc#lookaside&quot;&gt;ルックアサイドメモリ&lt;/a&gt;の使用を回避することにより、このヒントに基づいて、ルックアサイドメモリの限られたストアを使い果たしないようにしています。 SQLiteの将来のバージョンでは、このヒントに対する動作が異なる可能性があります。</target>
        </trans-unit>
        <trans-unit id="2c11fb868fc472e55f703cb835b3c6a27d603969" translate="yes" xml:space="preserve">
          <source>The SQLITE_PROTOCOL result code indicates a problem with the file locking protocol used by SQLite. The SQLITE_PROTOCOL error is currently only returned when using &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; and attempting to start a new transaction. There is a race condition that can occur when two separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; both try to start a transaction at the same time in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. The loser of the race backs off and tries again, after a brief delay. If the same connection loses the locking race dozens of times over a span of multiple seconds, it will eventually give up and return SQLITE_PROTOCOL. The SQLITE_PROTOCOL error should appear in practice very, very rarely, and only when there are many separate processes all competing intensely to write to the same database.</source>
          <target state="translated">SQLITE_PROTOCOL結果コードは、SQLiteが使用するファイルロックプロトコルに問題があることを示しています。 SQLITE_PROTOCOLエラーは現在、&lt;a href=&quot;wal&quot;&gt;WALモード&lt;/a&gt;を使用して新しいトランザクションを開始しようとした場合にのみ返されます。 2つの別個の&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続の&lt;/a&gt;両方が&lt;a href=&quot;wal&quot;&gt;WALモードで&lt;/a&gt;同時にトランザクションを開始しようとすると、競合状態が発生する可能性があります。レースの敗者は、少し遅れて後退し、再試行します。同じ接続が数秒間に数十回ロックレースを失うと、結局あきらめてSQLITE_PROTOCOLを返します。 SQLITE_PROTOCOLエラーは、実際には非常にまれにしか発生せず、同じデータベースに書き込むためにすべてのプロセスが激しく競合している場合にのみ発生します。</target>
        </trans-unit>
        <trans-unit id="2290c0085d649d3364cd3e13fd796218538f0c97" translate="yes" xml:space="preserve">
          <source>The SQLITE_RANGE error indices that the parameter number argument to one of the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind&lt;/a&gt; routines or the column number in one of the &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column&lt;/a&gt; routines is out of range.</source>
          <target state="translated">SQLITE_RANGEエラー指標の一つのパラメータnumber引数こと&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind&lt;/a&gt;ルーチン又はの一つの列数&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_columnの&lt;/a&gt;ルーチンは範囲外です。</target>
        </trans-unit>
        <trans-unit id="81db86b91239da795ab1877a821491920db31614" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY result code is returned when an attempt is made to alter some data for which the current database connection does not have write permission.</source>
          <target state="translated">現在のデータベース接続に書き込み権限がないデータを変更しようとした場合、SQLITE_READONLY 結果コードが返されます。</target>
        </trans-unit>
        <trans-unit id="20a2e61649ed0f39a9f887714e92e822fd9ead1d" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY_CANTINIT result code originates in the xShmMap method of a &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to indicate that the shared memory region used by &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; exists buts its content is unreliable and unusable by the current process since the current process does not have write permission on the shared memory region. (The shared memory region for WAL mode is normally a file with a &quot;-wal&quot; suffix that is mmapped into the process space. If the current process does not have write permission on that file, then it cannot write into shared memory.)</source>
          <target state="translated">SQLITE_READONLY_CANTINIT結果コードは、&lt;a href=&quot;vfs&quot;&gt;VFSの&lt;/a&gt; xShmMapメソッドで発生し、&lt;a href=&quot;wal&quot;&gt;WALモードで&lt;/a&gt;使用される共有メモリ領域は存在するが、現在のプロセスには共有メモリ領域への書き込み権限がないため、その内容は現在のプロセスでは信頼できず、使用できないことを示します。（WALモードの共有メモリ領域は通常、プロセススペースにmmapされた「-wal」サフィックスを持つファイルです。現在のプロセスがそのファイルに対する書き込み権限を持っていない場合、共有メモリに書き込むことはできません。）</target>
        </trans-unit>
        <trans-unit id="8cc5d69c49bd0049fa508081d686d1a3ef3d0153" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY_CANTLOCK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;. The SQLITE_READONLY_CANTLOCK error code indicates that SQLite is unable to obtain a read lock on a &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; database because the shared-memory file associated with that database is read-only.</source>
          <target state="translated">SQLITE_READONLY_CANTLOCKエラーコードは、&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;。SQLITE_READONLY_CANTLOCKエラーコードは、そのデータベースに関連付けられた共有メモリファイルが読み取り専用であるため、SQLiteが&lt;a href=&quot;wal&quot;&gt;WALモード&lt;/a&gt;データベースの読み取りロックを取得できないことを示します。</target>
        </trans-unit>
        <trans-unit id="19656bfe231a68e2b6cce42b55c5197d3d416be0" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY_DBMOVED error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;. The SQLITE_READONLY_DBMOVED error code indicates that a database cannot be modified because the database file has been moved since it was opened, and so any attempt to modify the database might result in database corruption if the processes crashes because the &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; would not be correctly named.</source>
          <target state="translated">SQLITE_READONLY_DBMOVEDエラーコードは、&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;。SQLITE_READONLY_DBMOVEDエラーコードは、データベースファイルが開かれてから移動されたためにデータベースを変更できないことを示しています。そのため、データベースを変更しようとすると、&lt;a href=&quot;lockingv3#rollback&quot;&gt;ロールバックジャーナルの&lt;/a&gt;名前が正しくないためにプロセスがクラッシュすると、データベースが破損する可能性があります。</target>
        </trans-unit>
        <trans-unit id="41ecb30affe77245ceb751ab6c0b2e9fce929efd" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY_DIRECTORY result code indicates that the database is read-only because process does not have permission to create a journal file in the same directory as the database and the creation of a journal file is a prerequisite for writing.</source>
          <target state="translated">SQLITE_READONLY_DIRECTORY の結果コードは、プロセスがデータベースと同じディレクトリにジャーナルファイルを作成する権限を持っておらず、ジャーナルファイルの作成が書き込みの前提条件であるため、データベースが読み取り専用であることを示しています。</target>
        </trans-unit>
        <trans-unit id="c2523ec31f0b9a2d33cf73109d61b1e043f8086c" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY_RECOVERY error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;. The SQLITE_READONLY_RECOVERY error code indicates that a &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; database cannot be opened because the database file needs to be recovered and recovery requires write access but only read access is available.</source>
          <target state="translated">SQLITE_READONLY_RECOVERYエラーコードは、&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;。SQLITE_READONLY_RECOVERYエラーコードは、データベースファイルを回復する必要があり、回復には書き込みアクセスが必要だが、読み取りアクセスしか利用できないため、&lt;a href=&quot;wal&quot;&gt;WALモード&lt;/a&gt;データベースを開けないことを示します。</target>
        </trans-unit>
        <trans-unit id="ba838fe9f900034dae5111194ba7ea1d5270d1c2" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY_ROLLBACK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;. The SQLITE_READONLY_ROLLBACK error code indicates that a database cannot be opened because it has a &lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;hot journal&lt;/a&gt; that needs to be rolled back but cannot because the database is readonly.</source>
          <target state="translated">SQLITE_READONLY_ROLLBACKエラーコードは、&lt;a href=&quot;rescode#pve&quot;&gt;拡張エラーコード&lt;/a&gt;のための&lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;。SQLITE_READONLY_ROLLBACKエラーコードは、ロールバックする必要がある&lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;ホットジャーナル&lt;/a&gt;があるためデータベースを開くことができないが、データベースが読み取り専用であるために開くことができないことを示します。</target>
        </trans-unit>
        <trans-unit id="d25154fd2f20b85ded4823ebe97f48106c96d4d1" translate="yes" xml:space="preserve">
          <source>The SQLITE_ROW result code returned by &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; indicates that another row of output is available.</source>
          <target state="translated">&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;によって返されるSQLITE_ROW結果コードは、出力の別の行が利用可能であることを示しています。</target>
        </trans-unit>
        <trans-unit id="1d91aee6732a465a4cc20090bf5eb9177f9e582c" translate="yes" xml:space="preserve">
          <source>The SQLITE_SCHEMA result code indicates that the database schema has changed. This result code can be returned from &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; for a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; that was generated using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;. If the database schema was changed by some other process in between the time that the statement was prepared and the time the statement was run, this error can result.</source>
          <target state="translated">SQLITE_SCHEMA結果コードは、データベーススキーマが変更されたことを示します。この結果コードは、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;または&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16（）&lt;/a&gt;を使用して生成&lt;a href=&quot;c3ref/stmt&quot;&gt;さ&lt;/a&gt;れた準備済みステートメントの&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;から返すことができます。ステートメントが準備されてからステートメントが実行されるまでの間にデータベーススキーマが他のプロセスによって変更された場合、このエラーが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="bccaf372951fcf999b80b85d54115242255c5910" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT Virtual Table</source>
          <target state="translated">SQLITE_STMT 仮想テーブル</target>
        </trans-unit>
        <trans-unit id="0210be179f988cfe689d56f75f4d1fa3e0b6bb8b" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT extension can also be loaded at run-time by compiling the extension into a shared library or DLL using the source code at &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/memstat.c&quot;&gt;https://sqlite.org/src/file/ext/misc/memstat.c&lt;/a&gt; and following the instructions for how to &lt;a href=&quot;loadext#build&quot;&gt;compile loadable extensions&lt;/a&gt;.</source>
          <target state="translated">SQLITE_STMT拡張機能は、https：//sqlite.org/src/file/ext/misc/memstat.cのソースコードを使用して拡張機能を共有ライブラリまたはDLLにコンパイルし、次の手順に従って実行時にロードすることもでき&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/memstat.c&quot;&gt;ます。&lt;/a&gt;&lt;a href=&quot;loadext#build&quot;&gt;ロード可能な拡張機能&lt;/a&gt;をコンパイルする方法。</target>
        </trans-unit>
        <trans-unit id="c79456ebf36875bab38cefa2c6e55d9482f8dca7" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT extension implements an &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual table&lt;/a&gt; that provides information about all &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; associated with the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">SQLITE_STMT拡張機能は、&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続に&lt;/a&gt;関連付けられているすべての&lt;a href=&quot;c3ref/stmt&quot;&gt;準備済みステートメント&lt;/a&gt;に関する情報を提供する、同義語&lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;のみの仮想テーブル&lt;/a&gt;を実装します。</target>
        </trans-unit>
        <trans-unit id="514c2473199b17afc5dd1d8c02362217c121606a" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT extension is enabled in default builds of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">SQLITE_STMT拡張機能は、&lt;a href=&quot;cli&quot;&gt;コマンドラインシェルの&lt;/a&gt;デフォルトビルドで有効になっています。</target>
        </trans-unit>
        <trans-unit id="e53abd5cd3368a9c18b0e2f006747b4e8c1e98ad" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT extension is included in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; though it is disabled by default. Use the &lt;a href=&quot;compile#enable_stmtvtab&quot;&gt;SQLITE_ENABLE_STMTVTAB&lt;/a&gt; compile-time option to enable the SQLITE_STMT extension. The SQLITE_STMT extension can also be loaded at run-time by compiling the extension into a shared library or DLL using the source code at &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/stmt.c&quot;&gt;https://sqlite.org/src/file/ext/misc/stmt.c&lt;/a&gt; and following the instructions for how to &lt;a href=&quot;loadext#build&quot;&gt;compile loadable extensions&lt;/a&gt;.</source>
          <target state="translated">SQLITE_STMT拡張機能は&lt;a href=&quot;amalgamation&quot;&gt;統合に&lt;/a&gt;含まれていますが、デフォルトでは無効になっています。&lt;a href=&quot;compile#enable_stmtvtab&quot;&gt;SQLITE_ENABLE_STMTVTAB&lt;/a&gt;コンパイル時オプションを使用して、SQLITE_STMT拡張を有効にします。SQLITE_STMT拡張機能は、https：//sqlite.org/src/file/ext/misc/stmt.cのソースコードを使用して拡張機能を共有ライブラリまたはDLLにコンパイルし、次の手順に従って実行時にロードすることもでき&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/stmt.c&quot;&gt;ます。&lt;/a&gt;&lt;a href=&quot;loadext#build&quot;&gt;ロード可能な拡張機能&lt;/a&gt;をコンパイルする方法。</target>
        </trans-unit>
        <trans-unit id="eff6d72f1420a16df254227915d0745e46f60ade" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT virtual table can also be used to access performance information about prepared statements, to aid in optimization an application. For example, to find out how much memory is being used by &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; that have never been used, one could run:</source>
          <target state="translated">SQLITE_STMT仮想テーブルを使用して、準備済みステートメントに関するパフォーマンス情報にアクセスし、アプリケーションの最適化を支援することもできます。たとえば、使用さ&lt;a href=&quot;c3ref/stmt&quot;&gt;れ&lt;/a&gt;たことのない準備済みステートメントが使用しているメモリの量を調べるには、次のコマンドを実行します。</target>
        </trans-unit>
        <trans-unit id="36a652edafe32e1a6a69623202e497c2b84971e5" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT virtual table is a read-only table that can be directly queried to access information about all prepared statements on the current database connection. For example:</source>
          <target state="translated">SQLITE_STMT 仮想テーブルは読み取り専用のテーブルで、現在のデータベース接続上で準備されたすべてのステートメントに関する情報にアクセスするために直接問い合わせることができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="c57e4bb46f13bf2108682321d36a64fbe9c7f037" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMTJRNL_SPILL compile-time option determines the default setting of the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;SQLITE_CONFIG_STMTJRNL_SPILL&lt;/a&gt; start-time setting. That setting determines the size threshold above which &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;statement journals&lt;/a&gt; are moved from memory to disk.</source>
          <target state="translated">SQLITE_STMTJRNL_SPILLコンパイル時オプションは、&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;SQLITE_CONFIG_STMTJRNL_SPILL&lt;/a&gt;開始時設定のデフォルト設定を決定します。その設定により、&lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;ステートメントジャーナル&lt;/a&gt;がメモリからディスクに移動されるサイズのしきい値が決まります。</target>
        </trans-unit>
        <trans-unit id="53aa1b2835c1a75b5cdfb5b24f66527df47e52af" translate="yes" xml:space="preserve">
          <source>The SQLITE_SUBTYPE flag indicates to SQLite that a function may call &lt;a href=&quot;#sqlite3_value_subtype&quot;&gt;sqlite3_value_subtype()&lt;/a&gt; to inspect the sub-types of its arguments. Specifying this flag makes no difference for scalar or aggregate user functions. However, if it is not specified for a user-defined window function, then any sub-types belonging to arguments passed to the window function may be discarded before the window function is called (i.e. sqlite3_value_subtype() will always return 0).</source>
          <target state="translated">SQLITE_SUBTYPEフラグは、関数がその引数のサブタイプを検査するために&lt;a href=&quot;#sqlite3_value_subtype&quot;&gt;sqlite3_value_subtype（）&lt;/a&gt;を呼び出す可能性があることをSQLiteに示します。このフラグを指定しても、スカラーまたは集約ユーザー関数には違いはありません。ただし、ユーザー定義のウィンドウ関数に指定されていない場合、ウィンドウ関数に渡される引数に属するサブタイプは、ウィンドウ関数が呼び出される前に破棄される場合があります（つまり、sqlite3_value_subtype（）は常に0を返します）。</target>
        </trans-unit>
        <trans-unit id="a9bfb18749058a748b6ef8d70f30272423e2e061" translate="yes" xml:space="preserve">
          <source>The SQLITE_SUBTYPE flag indicates to SQLite that a function may call &lt;a href=&quot;value_subtype&quot;&gt;sqlite3_value_subtype()&lt;/a&gt; to inspect the sub-types of its arguments. Specifying this flag makes no difference for scalar or aggregate user functions. However, if it is not specified for a user-defined window function, then any sub-types belonging to arguments passed to the window function may be discarded before the window function is called (i.e. sqlite3_value_subtype() will always return 0).</source>
          <target state="translated">SQLITE_SUBTYPEフラグは、関数がその引数のサブタイプを検査するために&lt;a href=&quot;value_subtype&quot;&gt;sqlite3_value_subtype（）&lt;/a&gt;を呼び出す可能性があることをSQLiteに示します。このフラグを指定しても、スカラーまたは集約ユーザー関数には違いはありません。ただし、ユーザー定義のウィンドウ関数に指定されていない場合、ウィンドウ関数に渡される引数に属するサブタイプは、ウィンドウ関数が呼び出される前に破棄される場合があります（つまり、sqlite3_value_subtype（）は常に0を返します）。</target>
        </trans-unit>
        <trans-unit id="eebb912b265a126853dad1960970bce68414c982" translate="yes" xml:space="preserve">
          <source>The SQLITE_TMPDIR environment variable</source>
          <target state="translated">SQLITE_TMPDIR 環境変数</target>
        </trans-unit>
        <trans-unit id="c73fb526ebe5bd57bd3e299a92027075f6d77195" translate="yes" xml:space="preserve">
          <source>The SQLITE_TOOBIG error code can also result when an oversized SQL statement is passed into one of the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; interfaces. The maximum length of an SQL statement defaults to a much smaller value of 1,000,000 bytes. The maximum SQL statement length can be set at compile-time using &lt;a href=&quot;limits#max_sql_length&quot;&gt;SQLITE_MAX_SQL_LENGTH&lt;/a&gt; or at run-time using &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitsqllength&quot;&gt;SQLITE_LIMIT_SQL_LENGTH&lt;/a&gt;,...).</source>
          <target state="translated">SQLITE_TOOBIGエラーコードは、特大のSQLステートメントが&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;インターフェースの1つに渡された場合にも発生する可能性があります。 SQLステートメントの最大長は、デフォルトで1,000,000バイトというはるかに小さい値になっています。 SQLステートメントの最大長は、コンパイル時に&lt;a href=&quot;limits#max_sql_length&quot;&gt;SQLITE_MAX_SQL_LENGTH&lt;/a&gt;を使用して設定するか、実行時に&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitsqllength&quot;&gt;SQLITE_LIMIT_SQL_LENGTH&lt;/a&gt;、...）を使用して設定できます。</target>
        </trans-unit>
        <trans-unit id="95a063038fc4fca17964bc0777d759cfc88b33bd" translate="yes" xml:space="preserve">
          <source>The SQLITE_TOOBIG error code indicates that a string or BLOB was too large. The default maximum length of a string or BLOB in SQLite is 1,000,000,000 bytes. This maximum length can be changed at compile-time using the &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; compile-time option, or at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;,...) interface. The SQLITE_TOOBIG error results when SQLite encounters a string or BLOB that exceeds the compile-time or run-time limit.</source>
          <target state="translated">SQLITE_TOOBIGエラーコードは、文字列またはBLOBが大きすぎることを示します。 SQLiteの文字列またはBLOBのデフォルトの最大長は1,000,000,000バイトです。この最大長は、コンパイル時に&lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;コンパイル時オプションを使用して、または実行時に&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;、...）インターフェイスを使用して変更できます。 SQLITE_TOOBIGエラーは、SQLiteがコンパイル時または実行時の制限を超える文字列またはBLOBを検出した場合に発生します。</target>
        </trans-unit>
        <trans-unit id="b22248b709740e89a9f8d423ea84335819e1ee2a" translate="yes" xml:space="preserve">
          <source>The SQLITE_WARNING result code is not returned by any C/C++ interface. However, SQLITE_WARNING (or rather one of its &lt;a href=&quot;rescode#extrc&quot;&gt;extended error codes&lt;/a&gt;) is sometimes used as the first argument in an &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; callback to indicate that an unusual and possibly ill-advised operation is taking place.</source>
          <target state="translated">SQLITE_WARNING結果コードは、どのC / C ++インターフェースからも返されません。ただし、SQLITE_WARNING（またはその&lt;a href=&quot;rescode#extrc&quot;&gt;拡張エラーコードの&lt;/a&gt; 1つ）が&lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log（）&lt;/a&gt;コールバックの最初の引数として使用され、異常で不適切な可能性のある操作が行われていることを示す場合があります。</target>
        </trans-unit>
        <trans-unit id="bd54655a92d09c02b918de6e8114904fcbbd22b3" translate="yes" xml:space="preserve">
          <source>The SQLITE_WARNING_AUTOINDEX result code is passed to the callback of &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; whenever &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexing&lt;/a&gt; is used. This can serve as a warning to application designers that the database might benefit from additional indexes.</source>
          <target state="translated">SQLITE_WARNING_AUTOINDEX結果コードは、&lt;a href=&quot;optoverview#autoindex&quot;&gt;自動インデックス作成&lt;/a&gt;が使用されるたびに&lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log（）の&lt;/a&gt;コールバックに渡されます。これは、データベースが追加のインデックスから利益を得る可能性があるというアプリケーション設計者への警告として役立ちます。</target>
        </trans-unit>
        <trans-unit id="c76259d82167d5f943a68fb0352bace5b64fab37" translate="yes" xml:space="preserve">
          <source>The SQLite Amalgamation</source>
          <target state="translated">SQLiteの合併</target>
        </trans-unit>
        <trans-unit id="e5e12b48e05726457e7db136c89d439a466ab852" translate="yes" xml:space="preserve">
          <source>The SQLite Archive is a relatively new format. It was first described in in 2014. ZIP Archives and Tarballs, on the other hand, have been around for decades and are well-entrenched as standard formats. Most programmers know what a ZIP Archive or Tarball is, but if you say &quot;SQLite Archive&quot; you are more likely to get a reply of &quot;What?&quot; Tooling to process ZIP Archives and Tarballs is more likely to be installed on stock computers.</source>
          <target state="translated">SQLite Archiveは比較的新しいフォーマットです。最初に記述されたのは2014年です。一方、ZIPアーカイブやタルボールは数十年前から存在し、標準フォーマットとして定着しています。ほとんどのプログラマは ZIP アーカイブやターボールが何であるかを知っていますが、&quot;SQLite Archive&quot; と言えば &quot;What?&quot; という返事が返ってくる可能性が高くなります。ZIPアーカイブやターボールを処理するためのツールは、純正のコンピュータにインストールされている可能性が高いです。</target>
        </trans-unit>
        <trans-unit id="14b38e43f93cb1f6666b258c1070654e3f60d3ab" translate="yes" xml:space="preserve">
          <source>The SQLite Bytecode Engine</source>
          <target state="translated">SQLite バイトコードエンジン</target>
        </trans-unit>
        <trans-unit id="60d2d0a8c73ed165c49cdebcf186c3bd62509aba" translate="yes" xml:space="preserve">
          <source>The SQLite OS Interface or &quot;VFS&quot;</source>
          <target state="translated">SQLite OS インターフェイスまたは &quot;VFS&quot;</target>
        </trans-unit>
        <trans-unit id="67edc3d607c153611c830c05dc44105c120df169" translate="yes" xml:space="preserve">
          <source>The SQLite OS Interface or &amp;quot;VFS&amp;quot;</source>
          <target state="translated">SQLite OSインターフェイスまたは「VFS」</target>
        </trans-unit>
        <trans-unit id="eb768474c2c960b1f80b5ec4636fc5c556432ed7" translate="yes" xml:space="preserve">
          <source>The SQLite Query Optimizer Overview</source>
          <target state="translated">SQLite クエリ オプティマイザーの概要</target>
        </trans-unit>
        <trans-unit id="656be9ece72b3b3c8af07774a0a4473889d5a0ca" translate="yes" xml:space="preserve">
          <source>The SQLite R*Tree Module</source>
          <target state="translated">SQLite R*Tree モジュール</target>
        </trans-unit>
        <trans-unit id="f7f3e9d21d121d5b3e8db61ea6e7dde70d17b4dd" translate="yes" xml:space="preserve">
          <source>The SQLite R*Tree module is implemented as a &lt;a href=&quot;c3ref/create_module&quot;&gt;virtual table&lt;/a&gt;. Each R*Tree index is a virtual table with an odd number of columns between 3 and 11. The first column is always a 64-bit signed integer primary key. The other columns are pairs, one pair per dimension, containing the minimum and maximum values for that dimension, respectively. A 1-dimensional R*Tree thus has 3 columns. A 2-dimensional R*Tree has 5 columns. A 3-dimensional R*Tree has 7 columns. A 4-dimensional R*Tree has 9 columns. And a 5-dimensional R*Tree has 11 columns. The SQLite R*Tree implementation does not support R*Trees wider than 5 dimensions.</source>
          <target state="translated">SQLite R * Treeモジュールは、&lt;a href=&quot;c3ref/create_module&quot;&gt;仮想テーブル&lt;/a&gt;として実装されます。各R * Treeインデックスは、3〜11の奇数列の仮想テーブルです。最初の列は常に64ビットの符号付き整数の主キーです。他の列はペアで、ディメンションごとに1つのペアで、それぞれそのディメンションの最小値と最大値を含みます。したがって、1次元のR * Treeには3つの列があります。 2次元のR * Treeには5つの列があります。 3次元のR * Treeには7つの列があります。 4次元のR * Treeには9つの列があります。また、5次元のR * Treeには11列があります。 SQLite R * Tree実装は、5次元を超えるR * Treeをサポートしていません。</target>
        </trans-unit>
        <trans-unit id="d26287506df7d739659f92d570a45374e9d6b203" translate="yes" xml:space="preserve">
          <source>The SQLite Zipfile Module</source>
          <target state="translated">SQLite Zipfile モジュール</target>
        </trans-unit>
        <trans-unit id="2a322992d7eadef1cbb665cdba826abcbe8d4bc9" translate="yes" xml:space="preserve">
          <source>The SQLite approach of storing the schema as text has advantages for an embedded relational database. For one, it means that the schema takes up less space in the database file. This is important since a common SQLite usage pattern is to have many small, separate database files instead of putting everything in one big global database file, which is the usual approach for client/server database engines. Since the schema is duplicated in each separate database file, it is important to keep the schema representation compact.</source>
          <target state="translated">スキーマをテキストとして格納するSQLiteのアプローチは、組み込みリレーショナルデータベースにとって利点があります。まず、スキーマがデータベースファイルの中でより少ないスペースを占めることを意味します。SQLiteの一般的な使用パターンは、クライアント/サーバーデータベースエンジンの通常のアプローチである、1つの大きなグローバルデータベースファイルにすべてを格納するのではなく、多くの小さな別々のデータベースファイルを持つことであるため、これは重要です。スキーマはそれぞれの個別のデータベースファイルで重複しているので、スキーマ表現をコンパクトに保つことが重要です。</target>
        </trans-unit>
        <trans-unit id="4156bb8a5bb8b9775d5b39350cba56f0d4323350" translate="yes" xml:space="preserve">
          <source>The SQLite code is broken up into multiple repositories, each described in a separate section below.</source>
          <target state="translated">SQLite のコードは複数のリポジトリに分割されており、それぞれ以下の別のセクションで説明されています。</target>
        </trans-unit>
        <trans-unit id="50c10f7a2161303f10be1e978ecf9c20c8b5ff8a" translate="yes" xml:space="preserve">
          <source>The SQLite community has been a kind, welcoming and well-mannered community since its inception nearly two decades ago. In that time many of the qualities we've worked hard to bring to our project - safety, consistency, usability and integrity among them - have become part of our community's culture as well. Much like the care and effort we've put into securing the longevity of SQLite, we'd like to do the same for that community by clarifying our goals and expectations for all involved. To that end the SQLite project has officially adopted the &lt;a href=&quot;https://www.mozilla.org/en-US/about/governance/policies/participation/&quot;&gt;Mozilla Community Participation Guidelines&lt;/a&gt; as its Code of Conduct with the exception that the reporting email address is changed to &lt;a href=&quot;mailto:codeofconduct@sqlite.org&quot;&gt;codeofconduct@sqlite.org&lt;/a&gt;. While we are not doing so in reaction to any current or ongoing issues, we believe that this will be a helpful part of maintaining the long-term sustainability of the project.</source>
          <target state="translated">SQLiteコミュニティは、約20年前の創業以来、親切で親しみやすく、礼儀正しいコミュニティでした。その間、私たちがプロジェクトにもたらすために一生懸命取り組んだ資質の多く-それらの間の安全性、一貫性、使いやすさ、および整合性-は、コミュニティの文化の一部にもなりました。 SQLiteの寿命を確保するために注力した努力と同様に、関係者全員の目標と期待を明確にすることで、コミュニティに対しても同じことを行いたいと考えています。そのため、SQLiteプロジェクトは、行動規範として&lt;a href=&quot;https://www.mozilla.org/en-US/about/governance/policies/participation/&quot;&gt;Mozilla Community Participationガイドライン&lt;/a&gt;を正式に採用しています。ただし、報告用メールアドレスは&lt;a href=&quot;mailto:codeofconduct@sqlite.org&quot;&gt;codeofconduct@sqlite.orgに&lt;/a&gt;変更されています。。現在または進行中の問題に対処するためにそうしているわけではありませんが、これはプロジェクトの長期的な持続可能性を維持するための有用な部分になると考えています。</target>
        </trans-unit>
        <trans-unit id="6e54c3c7cfbe74cbcff4d32cf11ceb85c2d59225" translate="yes" xml:space="preserve">
          <source>The SQLite core and its memory allocation subsystem provides the following capabilities:</source>
          <target state="translated">SQLiteコアとそのメモリ割り当てサブシステムは、以下の機能を提供します。</target>
        </trans-unit>
        <trans-unit id="4a8db7c1ed47d07dc8525eeb4fe9e3c2cadccf8a" translate="yes" xml:space="preserve">
          <source>The SQLite core calls the xBestIndex method when it is compiling a query that involves a virtual table. In other words, SQLite calls this method when it is running &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or the equivalent. By calling this method, the SQLite core is saying to the virtual table that it needs to access some subset of the rows in the virtual table and it wants to know the most efficient way to do that access. The xBestIndex method replies with information that the SQLite core can then use to conduct an efficient search of the virtual table.</source>
          <target state="translated">SQLiteコアは、仮想テーブルを含むクエリをコンパイルするときにxBestIndexメソッドを呼び出します。つまり、SQLiteは、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;または同等の機能を実行しているときにこのメソッドを呼び出します。このメソッドを呼び出すことにより、SQLiteコアは仮想テーブルの行のサブセットにアクセスする必要があることを仮想テーブルに伝え、そのアクセスを行う最も効率的な方法を知りたいと考えています。xBestIndexメソッドは、SQLiteコアが仮想テーブルの効率的な検索を実行するために使用できる情報で応答します。</target>
        </trans-unit>
        <trans-unit id="0101337cc0cb6fad83f4b1e21e8fd59c6d10699a" translate="yes" xml:space="preserve">
          <source>The SQLite core communicates with the xBestIndex method by filling in certain fields of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure and passing a pointer to that structure into xBestIndex as the second parameter. The xBestIndex method fills out other fields of this structure which forms the reply. The &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure looks like this:</source>
          <target state="translated">SQLiteコアは、&lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;構造の特定のフィールドに入力し、その構造へのポインターを2番目のパラメーターとしてxBestIndexに渡すことにより、xBestIndexメソッドと通信します。xBestIndexメソッドは、応答を形成するこの構造の他のフィールドに入力します。&lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_infoの&lt;/a&gt;このような構造になります。</target>
        </trans-unit>
        <trans-unit id="d592f9a3c73be507b58cc4d8ef9e1e11527c40f2" translate="yes" xml:space="preserve">
          <source>The SQLite core contains 5665 &lt;code&gt;assert()&lt;/code&gt; statements that verify function preconditions and postconditions and loop invariants. Assert() is a macro which is a standard part of ANSI-C. The argument is a boolean value that is assumed to always be true. If the assertion is false, the program prints an error message and halts.</source>
          <target state="translated">SQLiteコアには、関数の前提条件と事後条件、およびループ不変条件を検証する5665 &lt;code&gt;assert()&lt;/code&gt; ステートメントが含まれています。Assert（）は、ANSI-Cの標準部分であるマクロです。引数はブール値であり、常にtrueであると見なされます。アサーションがfalseの場合、プログラムはエラーメッセージを出力して停止します。</target>
        </trans-unit>
        <trans-unit id="7a7923d469bddb357e4bafd2e77a5357a3ce8703" translate="yes" xml:space="preserve">
          <source>The SQLite core contains 5855 &lt;code&gt;assert()&lt;/code&gt; statements that verify function preconditions and postconditions and loop invariants. Assert() is a macro which is a standard part of ANSI-C. The argument is a boolean value that is assumed to always be true. If the assertion is false, the program prints an error message and halts.</source>
          <target state="translated">SQLiteコアには、関数の前提条件と事後条件、およびループ不変条件を検証する5855の &lt;code&gt;assert()&lt;/code&gt; ステートメントが含まれています。Assert（）は、ANSI-Cの標準部分であるマクロです。引数は、常に真であると想定されるブール値です。アサーションがfalseの場合、プログラムはエラーメッセージを出力して停止します。</target>
        </trans-unit>
        <trans-unit id="8a046e08f75eaccd925ae647cf15c7aa3a8226b9" translate="yes" xml:space="preserve">
          <source>The SQLite core invokes the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlsyncomitted&quot;&gt;SQLITE_FCNTL_SYNC_OMITTED&lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;file control&lt;/a&gt; to the VFS in place of a call to xSync if the database has &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to OFF.</source>
          <target state="translated">データベースで&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同期&lt;/a&gt;がオフに設定されている場合、SQLiteコアは、&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlsyncomitted&quot;&gt;xSyncを&lt;/a&gt;呼び出す代わりに、SQLITE_FCNTL_SYNC_OMITTED &lt;a href=&quot;c3ref/file_control&quot;&gt;ファイルコントロール&lt;/a&gt;をVFSに呼び出します。</target>
        </trans-unit>
        <trans-unit id="9454a146cdf6bd63746f75afc554dedcf8a89f3d" translate="yes" xml:space="preserve">
          <source>The SQLite core invokes this method in order to find the value for the N-th column of the current row. N is zero-based so the first column is numbered 0. The xColumn method may return its result back to SQLite using one of the following interface:</source>
          <target state="translated">SQLite コアは、現在の行の N 番目の列の値を見つけるためにこのメソッドを呼び出します。N はゼロベースなので、最初の列には 0 が付けられます。 xColumn メソッドは、以下のインターフェイスのいずれかを使用して結果を SQLite に返すことができます。</target>
        </trans-unit>
        <trans-unit id="81909f2a4a51a96b134a34a4888c44983e2d76d3" translate="yes" xml:space="preserve">
          <source>The SQLite core uses these routines for thread synchronization. Though they are intended for internal use by SQLite, code that links against SQLite is permitted to use any of these routines.</source>
          <target state="translated">SQLite コアはこれらのルーチンをスレッド同期のために使用します。これらのルーチンは SQLite の内部での使用を目的としていますが、SQLite にリンクするコードは、これらのルーチンのいずれかを使用することが許可されています。</target>
        </trans-unit>
        <trans-unit id="922f1172309b4b736f1e305e3916cca7c4256be1" translate="yes" xml:space="preserve">
          <source>The SQLite core uses these three routines for all of its own internal memory allocation needs. &quot;Core&quot; in the previous sentence does not include operating-system specific &lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt; implementation. The Windows VFS uses native malloc() and free() for some operations.</source>
          <target state="translated">SQLiteコアは、独自の内部メモリ割り当てのニーズすべてにこれら3つのルーチンを使用します。前の文の「コア」には、オペレーティングシステム固有の&lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt;実装は含まれていません。Windows VFSは、一部の操作にネイティブのmalloc（）とfree（）を使用します。</target>
        </trans-unit>
        <trans-unit id="a9334c44f83a523ef26ab7a77c74c4218d746143" translate="yes" xml:space="preserve">
          <source>The SQLite core uses these three routines for all of its own internal memory allocation needs. &quot;Core&quot; in the previous sentence does not include operating-system specific &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementation. The Windows VFS uses native malloc() and free() for some operations.</source>
          <target state="translated">SQLiteコアは、独自の内部メモリ割り当てのニーズすべてにこれら3つのルーチンを使用します。前の文の「コア」には、オペレーティングシステム固有の&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;実装は含まれていません。Windows VFSは、一部の操作にネイティブのmalloc（）とfree（）を使用します。</target>
        </trans-unit>
        <trans-unit id="c22d82769d3da3cfaaf7c30bf60dfe3d4e431d6a" translate="yes" xml:space="preserve">
          <source>The SQLite core uses these three routines for all of its own internal memory allocation needs. &quot;Core&quot; in the previous sentence does not include operating-system specific VFS implementation. The Windows VFS uses native malloc() and free() for some operations.</source>
          <target state="translated">SQLiteコアは、これら3つのルーチンを使用して、独自の内部メモリ割り当ての必要性のすべてに使用します。&quot;前の文中の「コア」には、オペレーティングシステム固有のVFS実装は含まれていません。Windows の VFS では、ネイティブの malloc()と free()をいくつかの操作に使用しています。</target>
        </trans-unit>
        <trans-unit id="310e86b319144a9b8ab497d9dda0fd59a92fa402" translate="yes" xml:space="preserve">
          <source>The SQLite core will call &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; early. The auxiliary C code file can contain an implementation of sqlite3_initialize() that registers an appropriate VFS and also perhaps initializes an alternative mutex system (if mutexes are required) or does any memory allocation subsystem initialization that is required. The SQLite core never calls &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; but it is part of the official SQLite API and is not otherwise provided when compiled with -DSQLITE_OS_OTHER=1, so the auxiliary C code file should probably provide it for completeness.</source>
          <target state="translated">SQLiteコアは&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize（）を&lt;/a&gt;早く呼び出します。補助Cコードファイルには、適切なVFSを登録するsqlite3_initialize（）の実装を含めることができます。また、ミューテックスが必要な場合は代替のミューテックスシステムを初期化したり、必要なメモリ割り当てサブシステムの初期化を行うこともできます。SQLiteコアが&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown（）を&lt;/a&gt;呼び出すことはありませんが、公式のSQLite APIの一部であり、-DSQLITE_OS_OTHER = 1でコンパイルした場合は提供されないため、完全を期すために補助Cコードファイルで提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="a3389235261ef05c3ad08031ba3272b1839ea345" translate="yes" xml:space="preserve">
          <source>The SQLite core, including the unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;, has 100% branch test coverage under &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; in its default configuration as measured by &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcov&lt;/a&gt;. Extensions such as FTS3 and RTree are excluded from this analysis.</source>
          <target state="translated">UNIX &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;を含むSQLiteコアは、&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcovで&lt;/a&gt;測定されたデフォルト構成で&lt;a href=&quot;th3&quot;&gt;TH3の&lt;/a&gt;下で100％分岐テストカバレッジを持っています。FTS3やRTreeなどの拡張機能は、この分析から除外されています。</target>
        </trans-unit>
        <trans-unit id="25f0f08e26b5d1ff28a9d0772acbc6ec5d4dc8bf" translate="yes" xml:space="preserve">
          <source>The SQLite database allows multiple simultaneous readers or a single writer but not both. If any process is writing to the database no other process is allows to read or write. If any process is reading the database other processes are allowed to read but not write. The entire database shared a single lock.</source>
          <target state="translated">SQLiteデータベースでは、複数の同時読み込みや単一の書き込みが可能ですが、その両方はできません。いずれかのプロセスがデータベースに書き込みを行っている場合、他のプロセスは読み書きできません。いずれかのプロセスがデータベースを読んでいる場合、他のプロセスは読むことはできますが、書くことはできません。データベース全体が単一のロックを共有していました。</target>
        </trans-unit>
        <trans-unit id="c9e7754ee2f8ef030d3e0c4851d0ab23e5bf681e" translate="yes" xml:space="preserve">
          <source>The SQLite database file (&quot;self2014.sqlar&quot;) is about a half percent smaller than the equivalent ODP file! How can this be? Apparently the ZIP archive generator logic in NeoOffice is not as efficient as it could be, because when the same pile-of-files is recompressed using the command-line &quot;zip&quot; utility, one gets a file (&quot;zip.odp&quot;) that is smaller still, by another half percent, as seen in the third line above. So, a well-written ZIP archive can be slightly smaller than the equivalent SQLite database, as one would expect. But the difference is slight. The key take-away is that an SQLite database is size-competitive with a ZIP archive.</source>
          <target state="translated">SQLiteデータベースファイル(&quot;self2014.sqlar&quot;)は、同等のODPファイルよりも約半分の割合で小さくなっています。これはどうしてなのでしょうか?なぜなら、同じファイルの山をコマンドラインの &quot;zip &quot;ユーティリティを使って再圧縮すると、上の3行目にあるように、さらに半分の割合でより小さいファイル(&quot;zip.odp&quot;)が得られるからです。つまり、よく書かれた ZIP アーカイブは、期待通り、同等の SQLite データベースよりもわずかに小さくなる可能性があります。しかし、その差はわずかです。重要なのは、SQLite データベースは ZIP アーカイブとサイズ競争力があるということです。</target>
        </trans-unit>
        <trans-unit id="20b6f43ea15deb4c44a24b00c6944cb60a4b8d86" translate="yes" xml:space="preserve">
          <source>The SQLite database file format is also stable. All releases of SQLite version 3 can read and write database files created by the very first SQLite 3 release (version 3.0.0) going back to 2004-06-18. This is &quot;backwards compatibility&quot;. The developers promise to maintain backwards compatibility of the database file format for all future releases of SQLite 3. &quot;Forwards compatibility&quot; means that older releases of SQLite can also read and write databases created by newer releases. SQLite is usually, but not completely forwards compatible.</source>
          <target state="translated">SQLite データベースファイル形式も安定しています。SQLiteバージョン3のすべてのリリースは、2004-06-18にさかのぼり、最初のSQLite 3のリリース(バージョン3.0.0)によって作成されたデータベースファイルを読み書きすることができます。これが「後方互換性」です。開発者は、SQLite 3 の将来のすべてのリリースにおいて、データベースファイル形式の後方互換性を維持することを約束しています。&quot;後方互換性 &quot;とは、古いリリースのSQLiteでも、新しいリリースのSQLiteで作成されたデータベースを読み書きできることを意味します。SQLite は通常、完全な前方互換性はありません。</target>
        </trans-unit>
        <trans-unit id="a9896b9f0acf4d53bbeb650db03c052b65e4b39c" translate="yes" xml:space="preserve">
          <source>The SQLite developers use an on-line checklist to coordinate testing activity and to verify that all tests pass prior each SQLite release. &lt;a href=&quot;http://www.sqlite.org/checklists/index.html&quot;&gt;Past checklists&lt;/a&gt; are retained for historical reference. (The checklists are read-only for anonymous internet viewers, but developers can log in and update checklist items in their web browsers.) The use of checklists for SQLite testing and other development activities is inspired by</source>
          <target state="translated">SQLite開発者は、オンラインチェックリストを使用して、テストアクティビティを調整し、すべてのテストが各SQLiteリリースの前に合格することを確認します。&lt;a href=&quot;http://www.sqlite.org/checklists/index.html&quot;&gt;過去のチェックリスト&lt;/a&gt;は、履歴参照のために保持されます。（チェックリストは匿名のインターネットビューアでは読み取り専用ですが、開発者はWebブラウザでログインしてチェックリストの項目を更新できます。）SQLiteのテストやその他の開発活動でのチェックリストの使用は、</target>
        </trans-unit>
        <trans-unit id="4f35e69a2395e538db8157dc3dbb68d5b6f19b6e" translate="yes" xml:space="preserve">
          <source>The SQLite file format is cross-platform. A database file written on one machine can be copied to and used on a different machine with a different architecture. Big-endian or little-endian, 32-bit or 64-bit does not matter. All machines use the same file format. Furthermore, the developers have pledged to keep the file format stable and backwards compatible, so newer versions of SQLite can read and write older database files.</source>
          <target state="translated">SQLiteファイルフォーマットはクロスプラットフォームです。あるマシンに書かれたデータベースファイルを、異なるアーキテクチャの異なるマシンにコピーして使用することができます。ビッグエンディアンかリトルエンディアンか、32ビットか64ビットかは関係ありません。すべてのマシンは同じファイル形式を使用します。さらに、開発者はファイルフォーマットの安定性と下位互換性を保つことを約束していますので、新しいバージョンのSQLiteでも古いデータベースファイルを読み書きすることができます。</target>
        </trans-unit>
        <trans-unit id="a470f0b14147aeef040dd5381d7be5b2946cd2d3" translate="yes" xml:space="preserve">
          <source>The SQLite interface elements can be grouped into three categories:</source>
          <target state="translated">SQLite インターフェースの要素は、3 つのカテゴリにグループ化することができます。</target>
        </trans-unit>
        <trans-unit id="d2127d3816b52817dc6b4ce63d16e29894ba0878" translate="yes" xml:space="preserve">
          <source>The SQLite library consists of 102 files of C code (as of &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;Version 3.9.0&lt;/a&gt; - 2015-10-14) in the core with 32 additional files that implement the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;, &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;, &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;, &lt;a href=&quot;dbstat&quot;&gt;DBSTAT&lt;/a&gt;, &lt;a href=&quot;json1&quot;&gt;JSON1&lt;/a&gt;, and &lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt; extensions. Of the 102 main source files, about 75% are C code and about 25% are C header files. Most of these are &quot;source&quot; files in the sense that they are stored in the &lt;a href=&quot;https://www.sqlite.org/src&quot;&gt;SQLite version control system&lt;/a&gt; and are edited manually in an ordinary text editor. But some of the C-language files are generated using scripts or auxiliary programs. For example, the &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=src/parse.y&quot;&gt;parse.y&lt;/a&gt; file contains an LALR(1) grammar of the SQL language which is compiled down into are parser in files &quot;parse.c&quot; and &quot;parse.h&quot; by the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt;.</source>
          <target state="translated">SQLiteライブラリは、コア内の102個のCコードのファイル（&lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;バージョン3.9.0-2015-10-14現在&lt;/a&gt;）と、&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;、&lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;、&lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;、&lt;a href=&quot;dbstat&quot;&gt;DBSTAT&lt;/a&gt;、&lt;a href=&quot;json1&quot;&gt;JSON1&lt;/a&gt;、および&lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt;拡張を実装する32個の追加ファイルで構成されています。 102のメインソースファイルのうち、約75％がCコードで、約25％がCヘッダーファイルです。これらのほとんどは、&lt;a href=&quot;https://www.sqlite.org/src&quot;&gt;SQLiteバージョン管理システムに&lt;/a&gt;格納され、通常のテキストエディターで手動で編集されるという意味で、「ソース」ファイルです。ただし、一部のC言語ファイルは、スクリプトまたは補助プログラムを使用して生成されます。たとえば、&lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=src/parse.y&quot;&gt;parse.y&lt;/a&gt;ファイルには、SQL言語のLALR（1）文法が含まれています。これは、&lt;a href=&quot;lemon&quot;&gt;レモンパーサージェネレーター&lt;/a&gt;によってファイル「parse.c」と「parse.h」のパーサーにコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="7fdfec2d5c500b7ac74b77876e6dfdaa2cdecb05" translate="yes" xml:space="preserve">
          <source>The SQLite library exports the string constant named &lt;b&gt;sqlite_version&lt;/b&gt; which contains the version number of the library. The header file contains a macro SQLITE_VERSION with the same information. If desired, a program can compare the SQLITE_VERSION macro against the &lt;b&gt;sqlite_version&lt;/b&gt; string constant to verify that the version number of the header file and the library match.</source>
          <target state="translated">SQLiteライブラリは、ライブラリのバージョン番号を含む&lt;b&gt;sqlite_version&lt;/b&gt;という名前の文字列定数をエクスポートします。ヘッダーファイルには、同じ情報を持つマクロSQLITE_VERSIONが含まれています。必要に応じて、プログラムはSQLITE_VERSIONマクロを&lt;b&gt;sqlite_version&lt;/b&gt;文字列定数と比較して、ヘッダーファイルとライブラリのバージョン番号が一致することを確認できます。</target>
        </trans-unit>
        <trans-unit id="3f89e1941b8b597af45ed78a7c716ad9e7232f89" translate="yes" xml:space="preserve">
          <source>The SQLite library is designed to be very easy to use from a &lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;Tcl or Tcl/Tk&lt;/a&gt; script. SQLite began as a &lt;a href=&quot;http://www.tcl-lang.org/doc/tea/&quot;&gt;Tcl extension&lt;/a&gt; and the primary &lt;a href=&quot;testing&quot;&gt;test suite&lt;/a&gt; for SQLite is written in TCL. SQLite can be used with any programming language, but its connections to TCL run deep.</source>
          <target state="translated">SQLiteライブラリは、&lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;TclまたはTcl / Tk&lt;/a&gt;スクリプトから非常に使いやすいように設計されています。 SQLiteは&lt;a href=&quot;http://www.tcl-lang.org/doc/tea/&quot;&gt;Tcl拡張&lt;/a&gt;として始まり、SQLite の主要な&lt;a href=&quot;testing&quot;&gt;テストスイート&lt;/a&gt;はTCLで記述されています。 SQLiteは任意のプログラミング言語で使用できますが、TCLへの接続は深く実行されます。</target>
        </trans-unit>
        <trans-unit id="f0e8965a9252a8aca8a477026acb0a17bd84805b" translate="yes" xml:space="preserve">
          <source>The SQLite library is designed to be very easy to use from a C or C++ program. This document gives an overview of the C/C++ programming interface.</source>
          <target state="translated">SQLiteライブラリは、CまたはC++プログラムから非常に使いやすいように設計されています。このドキュメントでは、C/C++プログラミングインターフェイスの概要を説明します。</target>
        </trans-unit>
        <trans-unit id="0602c28d1654d00a16d8fb7d7632cbb5225eb5e8" translate="yes" xml:space="preserve">
          <source>The SQLite library may need less RAM since it shares pages with the operating-system page cache and does not always need its own copy of working pages.</source>
          <target state="translated">SQLite ライブラリはオペレーティングシステムのページキャッシュとページを共有しているため、RAM が少なくて済むかもしれません。</target>
        </trans-unit>
        <trans-unit id="b68ac5f0b4be242c75b75b113e85779b0d2d24fb" translate="yes" xml:space="preserve">
          <source>The SQLite library supplies the VDBE with a pointer to the callback function and the &lt;b&gt;pUserData&lt;/b&gt; pointer. (Both the callback and the user data were originally passed in as arguments to the &lt;b&gt;sqlite_exec()&lt;/b&gt; API function.) The job of the VDBE is to come up with values for &lt;b&gt;nColumn&lt;/b&gt;, &lt;b&gt;azData[]&lt;/b&gt;, and &lt;b&gt;azColumnName[]&lt;/b&gt;. &lt;b&gt;nColumn&lt;/b&gt; is the number of columns in the results, of course. &lt;b&gt;azColumnName[]&lt;/b&gt; is an array of strings where each string is the name of one of the result columns. &lt;b&gt;azData[]&lt;/b&gt; is an array of strings holding the actual data.</source>
          <target state="translated">SQLiteライブラリは、VDBEにコールバック関数へのポインターと&lt;b&gt;pUserData&lt;/b&gt;ポインターを&lt;b&gt;提供し&lt;/b&gt;ます。（コールバックとユーザーデータの両方が、最初は引数として&lt;b&gt;sqlite_exec（）&lt;/b&gt; API関数に渡されました。）VDBEの仕事は、&lt;b&gt;nColumn&lt;/b&gt;、&lt;b&gt;azData []&lt;/b&gt;、および&lt;b&gt;azColumnName []の&lt;/b&gt;値を&lt;b&gt;考え出すこと&lt;/b&gt;です。&lt;b&gt;もちろん&lt;/b&gt;、&lt;b&gt;nColumn&lt;/b&gt;は結果の列数です。&lt;b&gt;azColumnName []&lt;/b&gt;は文字列の配列で、各文字列は結果列の1つの名前です。&lt;b&gt;azData []&lt;/b&gt;は、実際のデータを保持する文字列の配列です。</target>
        </trans-unit>
        <trans-unit id="bec59993baf9ef121d8c6051be0842d34bbcc286" translate="yes" xml:space="preserve">
          <source>The SQLite library was compiled with &lt;a href=&quot;compile#use_uri&quot;&gt;-DSQLITE_USE_URI=1&lt;/a&gt;.</source>
          <target state="translated">SQLiteライブラリは&lt;a href=&quot;compile#use_uri&quot;&gt;-DSQLITE_USE_URI = 1で&lt;/a&gt;コンパイルされました。</target>
        </trans-unit>
        <trans-unit id="e9d0a1ae4dbbafaabd699c25677e883038d9a262" translate="yes" xml:space="preserve">
          <source>The SQLite project provides a simple command-line program named &lt;b&gt;sqlite3&lt;/b&gt; (or &lt;b&gt;sqlite3.exe&lt;/b&gt; on Windows) that allows the user to manually enter and execute SQL statements against an SQLite database or against a &lt;a href=&quot;#zipdb&quot;&gt;ZIP archive&lt;/a&gt;. This document provides a brief introduction on how to use the &lt;b&gt;sqlite3&lt;/b&gt; program.</source>
          <target state="translated">SQLiteプロジェクトは、&lt;b&gt;sqlite3&lt;/b&gt;（またはWindowsでは&lt;b&gt;sqlite3.exe&lt;/b&gt;）という名前の単純なコマンドラインプログラムを提供します。これにより、ユーザーはSQLiteデータベースまたは&lt;a href=&quot;#zipdb&quot;&gt;ZIPアーカイブ&lt;/a&gt;に対してSQLステートメントを手動で入力して実行できます。このドキュメントでは、&lt;b&gt;sqlite3&lt;/b&gt;プログラムの使用方法について簡単に紹介します。</target>
        </trans-unit>
        <trans-unit id="f3d928b1fc0f8261eeda1295ec9247d5985e38f7" translate="yes" xml:space="preserve">
          <source>The SQLite project provides a simple command-line program named &lt;b&gt;sqlite3&lt;/b&gt; (or &lt;b&gt;sqlite3.exe&lt;/b&gt; on Windows) that allows the user to manually enter and execute SQL statements against an SQLite database. This document provides a brief introduction on how to use the &lt;b&gt;sqlite3&lt;/b&gt; program.</source>
          <target state="translated">SQLiteプロジェクトは、&lt;b&gt;sqlite3&lt;/b&gt;（Windowsでは&lt;b&gt;sqlite3.exe&lt;/b&gt;）という名前のシンプルなコマンドラインプログラムを提供します。これにより、ユーザーはSQLiteデータベースに対して手動でSQLステートメントを入力して実行できます。このドキュメントでは、&lt;b&gt;sqlite3&lt;/b&gt;プログラムの使用方法について簡単に説明します。</target>
        </trans-unit>
        <trans-unit id="c372f90b5ac62e99b6357128106b66701a0411a3" translate="yes" xml:space="preserve">
          <source>The SQLite query planner will consider using an index on an expression when the expression that is indexed appears in the WHERE clause or in the ORDER BY clause of a query,</source>
          <target state="translated">SQLite クエリプランナーは、インデックスが付けられた式がクエリの WHERE 句や ORDER BY 句に現れた場合、式に対するインデックスの使用を考慮します。</target>
        </trans-unit>
        <trans-unit id="6dfbc1d18bbce16026bdcc86a5bffbbe6b1beb8b" translate="yes" xml:space="preserve">
          <source>The SQLite source code and the &lt;a href=&quot;testing#tcl&quot;&gt;TCL test suite&lt;/a&gt; are stored together in a single repository. This one repository is all that is required to build the SQLite. The source repository is public and is readable by anonymous passers by on the internet.</source>
          <target state="translated">SQLiteソースコードと&lt;a href=&quot;testing#tcl&quot;&gt;TCLテストスイート&lt;/a&gt;は、1つのリポジトリに一緒に保存されます。SQLiteを構築するために必要なのは、この1つのリポジトリだけです。ソースリポジトリは公開されており、匿名の通行人がインターネットで読むことができます。</target>
        </trans-unit>
        <trans-unit id="038ea963840df99a058067d40caa3b0cbd33dedb" translate="yes" xml:space="preserve">
          <source>The SQLite source code contains 1084 uses of the &lt;code&gt;testcase()&lt;/code&gt; macro.</source>
          <target state="translated">SQLiteソースコードには、 &lt;code&gt;testcase()&lt;/code&gt; マクロの1084回の使用が含まれています。</target>
        </trans-unit>
        <trans-unit id="1097f713df32cd3a870e17f648d7622d77d22cd2" translate="yes" xml:space="preserve">
          <source>The SQLite source code contains 992 uses of the &lt;code&gt;testcase()&lt;/code&gt; macro.</source>
          <target state="translated">SQLiteソースコードには、 &lt;code&gt;testcase()&lt;/code&gt; マクロの992の使用法が含まれています。</target>
        </trans-unit>
        <trans-unit id="200e89ebce3af8e9c7c026a8d18cac87a1da0318" translate="yes" xml:space="preserve">
          <source>The SQLite source code contains literally thousands of assert() statements used to verify internal assumptions and subroutine preconditions and postconditions. These assert() statements are normally turned off (they generate no code) since turning them on makes SQLite run approximately three times slower. But for testing and analysis, it is useful to turn the assert() statements on. The SQLITE_DEBUG compile-time option does this.</source>
          <target state="translated">SQLiteのソースコードには、文字通り何千ものassert()文が含まれており、内部の仮定やサブルーチンの前提条件や事後条件を検証するために使用されています。これらの assert()文は通常オフ(コードを生成しない)に設定されていますが、これをオンにすると SQLite の動作が約 3 倍遅くなるからです。しかし、テストや分析のためには assert()文をオンにしておくと便利です。SQLITE_DEBUG コンパイル時オプションがこれを行います。</target>
        </trans-unit>
        <trans-unit id="7203161cfe6b6f33980e05611daeaed418ec5ae9" translate="yes" xml:space="preserve">
          <source>The SQLite source code contains multiple implementations of these mutex routines. An appropriate implementation is selected automatically at compile-time. The following implementations are available in the SQLite core:</source>
          <target state="translated">SQLite のソースコードには、これらのミューテックスルーチンの複数の実装が含まれています。適切な実装はコンパイル時に自動的に選択されます。SQLite コアでは以下の実装が利用可能です。</target>
        </trans-unit>
        <trans-unit id="519e11bf2b879a67e8b0e9134459d439da57e623" translate="yes" xml:space="preserve">
          <source>The SQLite source code includes several different memory allocation modules that can be selected at compile-time, or to a limited extent at start-time.</source>
          <target state="translated">SQLite のソースコードには、コンパイル時に選択できる複数の異なるメモリ割り当てモジュールが含まれています。</target>
        </trans-unit>
        <trans-unit id="b459704fa1dc2f133cc1300473552a0909311a3d" translate="yes" xml:space="preserve">
          <source>The SQLite source code provides multiple implementations of these APIs, suitable for varying environments. If SQLite is compiled with the SQLITE_THREADSAFE=0 flag then a no-op mutex implementation that is fast but does no real mutual exclusion is provided. That implementation is suitable for use in single-threaded applications or applications that only use SQLite in a single thread. Other real mutex implementations are provided based on the underlying operating system.</source>
          <target state="translated">SQLite のソースコードでは、これらの API の複数の実装が提供されており、様々な環境に適しています。SQLite が SQLITE_THREADSAFE=0 フラグでコンパイルされている場合、高速ではありますが実際の相互排除を行わないノーオプのミューテックス実装が提供されています。この実装は、シングルスレッドのアプリケーションや、SQLiteをシングルスレッドでのみ使用するアプリケーションでの使用に適しています。その他の本当のミューテックスの実装は、基礎となるオペレーティングシステムに基づいて提供されています。</target>
        </trans-unit>
        <trans-unit id="4146cdfa0001cfa5a66203144506da17c3646968" translate="yes" xml:space="preserve">
          <source>The SQLite source tree actually contains multiple versions of the memory allocator. The default high-speed version found in the &quot;mem1.c&quot; source file is used for most builds. But if the SQLITE_MEMDEBUG flag is enabled, a separate memory allocator the &quot;mem2.c&quot; source file is used instead. The mem2.c allocator implements lots of hooks to do error checking and to simulate memory allocation failures for testing purposes. Both of these allocators use the malloc()/free() implementation in the standard C library.</source>
          <target state="translated">SQLite のソースツリーには、実際には複数のバージョンのメモリアロケータが含まれています。ほとんどのビルドでは、&quot;mem1.c&quot; ソースファイルにあるデフォルトの高速バージョンが使用されます。しかし、SQLITE_MEMDEBUG フラグが有効になっている場合は、&quot;mem2.c&quot; ソースファイルの別のメモリアロケータが代わりに使用されます。mem2.c アロケータには、エラーチェックを行ったり、テスト目的でメモリ割り当ての失敗をシミュレートしたりするための多くのフックが実装されています。これらのアロケータはどちらも標準 C ライブラリの malloc()/free()の実装を使用しています。</target>
        </trans-unit>
        <trans-unit id="4ba1f99040a37a507011c1205b1aef886c686eaf" translate="yes" xml:space="preserve">
          <source>The SQLite version identifier returned by the &lt;a href=&quot;lang_corefunc#sqlite_source_id&quot;&gt;sqlite_source_id()&lt;/a&gt; SQL function and the &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt; C API and found in the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; macro is now a 64-digit SHA3-256 hash instead of a 40-digit SHA1 hash.</source>
          <target state="translated">SQLiteのバージョン識別子によって返さ&lt;a href=&quot;lang_corefunc#sqlite_source_id&quot;&gt;sqlite_source_id（）&lt;/a&gt; SQL関数と&lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid（）&lt;/a&gt; C APIとに見出さ&lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_IDの&lt;/a&gt;マクロは、現在代わりに40桁のSHA1ハッシュの64桁SHA3​​-256ハッシュです。</target>
        </trans-unit>
        <trans-unit id="0c3d7b8c49e09915f93340abac558621318ffacf" translate="yes" xml:space="preserve">
          <source>The SQLite website (&lt;a href=&quot;https://www.sqlite.org/&quot;&gt;https://www.sqlite.org/&lt;/a&gt;) uses SQLite itself, of course, and as of this writing (2015) it handles about 400K to 500K HTTP requests per day, about 15-20% of which are dynamic pages touching the database. Dynamic content uses &lt;a href=&quot;np1queryprob&quot;&gt;about 200 SQL statements per webpage&lt;/a&gt;. This setup runs on a single VM that shares a physical server with 23 others and yet still keeps the load average below 0.1 most of the time.</source>
          <target state="translated">SQLite Webサイト（&lt;a href=&quot;https://www.sqlite.org/&quot;&gt;https://www.sqlite.org/&lt;/a&gt;）はもちろんSQLite自体を使用しており、この記事（2015）の執筆時点では1日あたり約40万から500万のHTTPリクエストを処理しています。データベースに接触するページ。動的コンテンツは&lt;a href=&quot;np1queryprob&quot;&gt;、Webページごとに約200のSQLステートメントを&lt;/a&gt;使用します。このセットアップは、物理サーバーを他の23と共有する単一のVMで実行されますが、ほとんどの場合、平均負荷を0.1以下に保ちます。</target>
        </trans-unit>
        <trans-unit id="dc3cc55be8b0168568fc5c682e636d1909810e07" translate="yes" xml:space="preserve">
          <source>The SQLite-specific printf() supports a new flag (!) called the &quot;alternate-form-2&quot; flag. The alternate-form-2 flag changes the processing of floating-point conversions in subtle ways so that the output is always an SQL-compatible text representation of a floating-point number - something that is not possible to achieve with standard-library printf(). For string substitutions, the alternate-form-2 flag causes the width and precision to be measured in characters instead of bytes, which simplifies processing of strings containing multi-byte UTF8 characters.</source>
          <target state="translated">SQLite固有のprintf()は、&quot;alternate-form-2 &quot;フラグと呼ばれる新しいフラグ(!)をサポートしています。alternate-form-2フラグは、浮動小数点変換の処理を微妙に変更し、出力が常にSQL互換性のある浮動小数点数のテキスト表現になるようにします。文字列の置換については、 alternate-form-2 フラグにより、幅と精度がバイトではなく文字で測定されるようになります。</target>
        </trans-unit>
        <trans-unit id="ab1ef24a2c3d89dbbf816b75c5ebad085546d51d" translate="yes" xml:space="preserve">
          <source>The SUM function detects integer overflow and converts to accumulating an approximate result using floating point numbers</source>
          <target state="translated">SUM関数は、整数のオーバーフローを検出し、浮動小数点数を用いた近似結果の累積に変換します。</target>
        </trans-unit>
        <trans-unit id="9d27464a9b4c0f0bdd924575293003beb50c81e1" translate="yes" xml:space="preserve">
          <source>The SUM() function throws an error on integer overflow.</source>
          <target state="translated">SUM()関数は、整数オーバーフローでエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="7cc003a9427832539005b297ca058e10476ece22" translate="yes" xml:space="preserve">
          <source>The Session Extension</source>
          <target state="translated">セッション拡張</target>
        </trans-unit>
        <trans-unit id="0aa8192c55de05490d2622bfdb109c271f14a02d" translate="yes" xml:space="preserve">
          <source>The Spellfix1 Virtual Table</source>
          <target state="translated">Spellfix1の仮想表</target>
        </trans-unit>
        <trans-unit id="7366e749b34cc79e46fd62658a2ec13bee8b7b92" translate="yes" xml:space="preserve">
          <source>The T argument is the name of the target database file. The A argument is the name of the RBU database file. The S argument is the name of a &quot;state database&quot; used to store state information needed to resume the update after an interruption. The S argument can be NULL in which case the state information is stored in the RBU database in various tables whose names all begin with &quot;rbu_&quot;.</source>
          <target state="translated">T 引数はターゲットデータベースファイルの名前です。A 引数は、RBU データベースファイルの名前です。S 引数は、中断後に更新を再開するために必要な状態情報を格納するために使用される「状態データベース」の名前である。S引数にはNULLを指定することができ、その場合、状態情報は、すべて &quot;rbu_&quot;で始まる名前の様々なテーブルにRBUデータベースに格納される。</target>
        </trans-unit>
        <trans-unit id="b1d051df5b386db985e4647bccdf4da6546279c0" translate="yes" xml:space="preserve">
          <source>The TCL bindings transfer data without necessarily doing a conversion to a string.</source>
          <target state="translated">TCL バインディングは、必ずしも文字列への変換を行わずにデータを転送します。</target>
        </trans-unit>
        <trans-unit id="65bc381e62f8723019edd6efca853c02189bf80a" translate="yes" xml:space="preserve">
          <source>The TCL interface for SQLite is a small module that is added into the regular amalgamation. The result is a new amalgamated source file called &quot;&lt;b&gt;tclsqlite3.c&lt;/b&gt;&quot;. This single source file is all that is needed to generate a shared library that can be loaded into a standard &lt;a href=&quot;http://wiki.tcl-lang.org/2541&quot;&gt;tclsh&lt;/a&gt; or &lt;a href=&quot;http://wiki.tcl-lang.org/2364&quot;&gt;wish&lt;/a&gt; using the &lt;a href=&quot;http://wiki.tcl-lang.org/9830&quot;&gt;TCL load command&lt;/a&gt;, or to generate a standalone tclsh that comes with SQLite built in. A copy of the tcl amalgamation is included on the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download page&lt;/a&gt; as a file in the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;TEA tarball&lt;/a&gt;.</source>
          <target state="translated">SQLiteのTCLインターフェイスは、通常の融合に追加される小さなモジュールです。結果は、 &quot; &lt;b&gt;tclsqlite3.c&lt;/b&gt; &quot; と呼ばれる新しい統合されたソースファイルです。この単一のソースファイルには、標準にロードすることができ、共有ライブラリを生成するために必要なことすべてです&lt;a href=&quot;http://wiki.tcl-lang.org/2541&quot;&gt;TCLSH&lt;/a&gt;や&lt;a href=&quot;http://wiki.tcl-lang.org/2364&quot;&gt;願い&lt;/a&gt;使用して&lt;a href=&quot;http://wiki.tcl-lang.org/9830&quot;&gt;TCLのloadコマンドを&lt;/a&gt;、またはに建てられたSQLiteが付属してスタンドアロンにtclshを生成する。TCL合併のAコピーされます&lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;TEA tarballの&lt;/a&gt;ファイルとして&lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;ダウンロードページに&lt;/a&gt;含まれています。</target>
        </trans-unit>
        <trans-unit id="f9e41f74fbcda169959b0e1c5ad24699dcf79aca" translate="yes" xml:space="preserve">
          <source>The TEMP database file is very similar to auxiliary database files added using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement, though with a few special properties. The TEMP database is always automatically deleted when the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is closed. The TEMP database always uses the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;synchronous=OFF&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode=PERSIST&lt;/a&gt; PRAGMA settings. And, the TEMP database cannot be used with &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt; nor can another process &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; the TEMP database.</source>
          <target state="translated">TEMPデータベースファイルは、いくつかの特別なプロパティがありますが、&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;ステートメントを使用して追加された補助データベースファイルと非常に似ています。 TEMPデータベースは、&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;が閉じられると常に自動的に削除されます。 TEMPデータベースは、常に&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;Synchronous = OFF&lt;/a&gt;および&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode = PERSIST&lt;/a&gt; PRAGMA設定を使用します。また、TEMPデータベースを&lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt;とともに使用することも、別のプロセスがTEMPデータベースを&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;することもできません。</target>
        </trans-unit>
        <trans-unit id="53f0498bc726c9a2250102fc1ce88dd0e04a9743" translate="yes" xml:space="preserve">
          <source>The TEMP or TEMPORARY keyword is removed if it occurs after the initial CREATE keyword.</source>
          <target state="translated">TEMP キーワードまたは TEMPORARY キーワードは、最初の CREATE キーワードの後に発生した場合に削除されます。</target>
        </trans-unit>
        <trans-unit id="4b9ade3b04856b7f86ec94b71b3743aaff256ca8" translate="yes" xml:space="preserve">
          <source>The TEMP schema always has synchronous=OFF since the content of of TEMP is ephemeral and is not expected to survive a power outage. Attempts to change the synchronous setting for TEMP are silently ignored.</source>
          <target state="translated">TEMP スキーマは常に synchronous=OFF になっていますが、これは TEMP の内容が一時的なものであり、停電に耐えられるとは考えられないからです。TEMP の同期設定を変更しようとする試みは静かに無視されます。</target>
        </trans-unit>
        <trans-unit id="dd8090269fd066de5e15019d6f63ecc9dd8e6b9f" translate="yes" xml:space="preserve">
          <source>The TEMP_STORE and DEFAULT_TEMP_STORE pragmas now work.</source>
          <target state="translated">TEMP_STORE および DEFAULT_TEMP_STORE プラグマが動作するようになりました。</target>
        </trans-unit>
        <trans-unit id="5dbd6ac1d86267c3b2604d6573027830c458f6aa" translate="yes" xml:space="preserve">
          <source>The TH3 program generator is a TCL script named &quot;&lt;code&gt;mkth3.tcl&lt;/code&gt;&quot;. To generate a test program, one has merely to run this script and supply the names of files containing test modules and configurations on the command line. Test modules are files that use the &quot;&lt;code&gt;.test&lt;/code&gt;&quot; suffix and configurations are files that use the &quot;&lt;code&gt;.cfg&lt;/code&gt;&quot; suffix. A typical invocation of mkth3.tcl might look something like the following:</source>
          <target state="translated">TH3プログラムジェネレーターは、「 &lt;code&gt;mkth3.tcl&lt;/code&gt; 」という名前のTCLスクリプトです。テストプログラムを生成するには、このスクリプトを実行して、コマンドラインでテストモジュールと構成を含むファイルの名前を指定するだけです。テストモジュールは「 &lt;code&gt;.test&lt;/code&gt; 」サフィックスを使用するファイルであり、構成は「 &lt;code&gt;.cfg&lt;/code&gt; 」サフィックスを使用するファイルです。mkth3.tclの一般的な呼び出しは、次のようになります。</target>
        </trans-unit>
        <trans-unit id="b8c8240b8bebcede58e6b71d1007e7276f3ab838" translate="yes" xml:space="preserve">
          <source>The TH3 repository also includes the &quot;multitest.tcl&quot; script, another TCL script used to automate TH3 testing on workstations. Multitest.tcl automatically compiles SQLite, then runs ./th3make repeatedly with a variety of alignments, and captures the output in a succinct summary screen. A typical multitest.tcl run generates output that looks like this:</source>
          <target state="translated">TH3 リポジトリには &quot;multitest.tcl&quot; スクリプトも含まれており、ワークステーション上で TH3 テストを自動化するための TCL スクリプトです。multitest.tclは自動的にSQLiteをコンパイルし、./th3makeを様々なアラインメントで繰り返し実行し、出力を簡潔なサマリー画面でキャプチャします。典型的なmultitest.tclの実行は、以下のような出力を生成します。</target>
        </trans-unit>
        <trans-unit id="b6f9b2cda115a994b187cb0154afbb957f0c6ad7" translate="yes" xml:space="preserve">
          <source>The TH3 source tree contains a scripted name &quot;mutation-test.tcl&quot; that automates the process of &lt;a href=&quot;testing#mutationtests&quot;&gt;mutation testing&lt;/a&gt;.</source>
          <target state="translated">TH3ソースツリーには、ミューテーション&lt;a href=&quot;testing#mutationtests&quot;&gt;テストの&lt;/a&gt;プロセスを自動化するスクリプト名「mutation-test.tcl」が含まれています。</target>
        </trans-unit>
        <trans-unit id="7cdfe00d64176fc80b6e066f8b6b12526ed3a13b" translate="yes" xml:space="preserve">
          <source>The TH3 test harness needs to run on embedded systems that do not necessarily have the ability to spawn child processes, so it uses an in-memory &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to simulate crashes. The in-memory &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; can be rigged to make a snapshot of the entire filesystem after a set number of I/O operations. Crash tests run in a loop. On each iteration of the loop, the point at which a snapshot is made is advanced until the SQLite operations being tested run to completion without ever hitting a snapshot. Within the loop, after the SQLite operation under test has completed, the filesystem is reverted to the snapshot and random file damage is introduced that is characteristic of the kinds of damage one expects to see following a power loss. Then the database is opened and checks are made to ensure that it is well-formed and that the transaction either ran to completion or was completely rolled back. The interior of the loop is repeated multiple times for each snapshot with different random damage each time.</source>
          <target state="translated">TH3テストハーネスは、必ずしも子プロセスを生成する機能がない組み込みシステムで実行する必要があるため、メモリ内&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;を使用してクラッシュをシミュレートします。インメモリ&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;設定された数のI / O操作の後で、ファイルシステム全体のスナップショットを作成するためにリギングできます。クラッシュテストはループで実行されます。ループの各反復で、スナップショットが作成されるポイントは、テストされるSQLite操作がスナップショットにヒットすることなく完了するまで実行されるまで進められます。ループ内では、テスト中のSQLite操作が完了した後、ファイルシステムがスナップショットに戻り、停電後に予期される種類の損傷に特徴的なランダムファイル損傷が導入されます。次に、データベースが開かれ、整形式であること、およびトランザクションが完全に実行されたか、完全にロールバックされたことを確認するためのチェックが行われます。ループの内部は、スナップショットごとに複数回繰り返され、毎回異なるランダムな損傷が発生します。</target>
        </trans-unit>
        <trans-unit id="17fbf6e9083452ddac2fd083a957049cd4961ff8" translate="yes" xml:space="preserve">
          <source>The TMPDIR environment variable</source>
          <target state="translated">TMPDIR環境変数</target>
        </trans-unit>
        <trans-unit id="03b5c9a4012ba043f6ac023992fea614e9559aac" translate="yes" xml:space="preserve">
          <source>The TRUNCATE journaling mode commits transactions by truncating the rollback journal to zero-length instead of deleting it. On many systems, truncating a file is much faster than deleting the file since the containing directory does not need to be changed.</source>
          <target state="translated">TRUNCATE ジャーナリング・モードは、ロールバック・ジャーナルを削除するのではなく、長さゼロに切り詰めることでトランザクションをコミットします。多くのシステムでは、ファイルを切り詰めることは、ファイルを含むディレクトリを変更する必要がないため、ファイルを削除するよりもはるかに高速です。</target>
        </trans-unit>
        <trans-unit id="8b6a576f2a0740b1d820bb0b389ef9405211a467" translate="yes" xml:space="preserve">
          <source>The Tcl interface to the SQLite library</source>
          <target state="translated">SQLite ライブラリへの Tcl インターフェイス</target>
        </trans-unit>
        <trans-unit id="ea435d43ff01f7eaaaed2d71b4ee7a4a7d014eaf" translate="yes" xml:space="preserve">
          <source>The Tcl script language is used to help translate canonical source code into the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; and to manage testing. Tcl is not used directly by SQLite itself (unless requested by a compile-time option). End users of the SQLite amalgamation sources do not need Tcl.</source>
          <target state="translated">Tclスクリプト言語は、正規のソースコードを&lt;a href=&quot;amalgamation&quot;&gt;融合に&lt;/a&gt;変換し、テストを管理するために使用されます。TclはSQLite自体では直接使用されません（コンパイル時オプションで要求されない限り）。SQLite統合ソースのエンドユーザーはTclを必要としません。</target>
        </trans-unit>
        <trans-unit id="4ea1be33d0917718998fde5f34057649d7f00dc5" translate="yes" xml:space="preserve">
          <source>The Truncate Optimization</source>
          <target state="translated">切り捨て最適化</target>
        </trans-unit>
        <trans-unit id="663111ce13348e029be0eb29fd78279aef78534e" translate="yes" xml:space="preserve">
          <source>The UNION Virtual Table</source>
          <target state="translated">UNIONバーチャルテーブル</target>
        </trans-unit>
        <trans-unit id="83a6780922b4732cbc0add9d73d09070752444e6" translate="yes" xml:space="preserve">
          <source>The UNION operator for compound queries is implemented by creating a transient index in a temporary file and storing the results of the left and right subquery in the transient index, discarding duplicates. After both subqueries have been evaluated, the transient index is walked from beginning to end to generate the final output.</source>
          <target state="translated">複合クエリのUNION演算子は、一時ファイルにトランジェントインデックスを作成し、左右の副問い合わせの結果をトランジェントインデックスに格納し、重複したものを破棄することで実装されます。両方の副問い合わせが評価された後、トランジェントインデックスは最初から最後までウォークされ、最終的な出力が生成されます。</target>
        </trans-unit>
        <trans-unit id="7930c62c86f89ebc6a986709239760afad2bba9f" translate="yes" xml:space="preserve">
          <source>The UNION virtual table (hereafter: &quot;union-vtab&quot;) is a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; that makes multiple independent &lt;a href=&quot;rowidtable&quot;&gt;rowid tables&lt;/a&gt; tables look like a single large table.</source>
          <target state="translated">UNION仮想テーブル（以下：「union-vtab」）は、複数の独立した&lt;a href=&quot;rowidtable&quot;&gt;ROWIDテーブルを&lt;/a&gt; 1つの大きなテーブルのように見せかける&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="16da95be83b926d661aef977fab4f723fc62a011" translate="yes" xml:space="preserve">
          <source>The UPDATE and DELETE statements are coded using a template that is very similar to the SELECT statement template. The main difference, of course, is that the end action is to modify the database rather than invoke a callback function. Because it modifies the database it will also use transactions. Let's begin by looking at a DELETE statement:</source>
          <target state="translated">UPDATE文とDELETE文は、SELECT文のテンプレートに非常に似たテンプレートを使用してコード化されています。主な違いは、もちろん、コールバック関数を呼び出すのではなく、データベースを変更することです。データベースを変更するので、トランザクションも使用します。まずはDELETE文を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="d012a450cb6e8a62342d872acae64f627c638672" translate="yes" xml:space="preserve">
          <source>The UPDATE statement was not working when the WHERE clause contained some terms that could be satisfied using indices and other terms that could not. Fixed.</source>
          <target state="translated">WHERE句に、インデックスを使用して満たすことができるいくつかの用語と、満たすことができないその他の用語が含まれている場合、UPDATE文が機能していませんでした。修正されました。</target>
        </trans-unit>
        <trans-unit id="33c2760fb2236b7ba6d326e49f2cb15eef8f0600" translate="yes" xml:space="preserve">
          <source>The UPDATE-FROM idea is an extension to SQL that allows an UPDATE statement to be driven by other tables in the database. The &quot;target&quot; table is the specific table that is being updated. With UPDATE-FROM you can join the target table against other tables in the database in order to help compute which rows need updating and what the new values should be on those rows. UPDATE-FROM is supported beginning in SQLite version 3.33.0 (2020-08-14).</source>
          <target state="translated">UPDATE-FROMのアイデアは、データベース内の他のテーブルによってUPDATE文を駆動することを可能にするSQLの拡張です。ターゲット」テーブルは、更新される特定のテーブルです。UPDATE-ROMを使用すると、データベース内の他のテーブルに対してターゲットテーブルを結合することができ、どの行を更新する必要があるのか、また、それらの行の新しい値は何であるべきなのかを計算するのに役立ちます。UPDATE-ROM は SQLite バージョン 3.33.0 (2020-08-14)以降でサポートされています。</target>
        </trans-unit>
        <trans-unit id="a45a66b4cdc4b1cad87f2ad44961d2b0a1e7cb34" translate="yes" xml:space="preserve">
          <source>The Use Of assert() In SQLite</source>
          <target state="translated">SQLite での assert()の使用</target>
        </trans-unit>
        <trans-unit id="91cb86d3be85bb36d2918c344be4f7a7dbe55738" translate="yes" xml:space="preserve">
          <source>The VACUUM INTO command is transactional in the sense that the generated output database is a consistent snapshot of the original database. However, if the VACUUM INTO command is interrupted by an unplanned shutdown or power lose, then the generated output database might be incomplete and corrupt. Also, SQLite does not invoke fsync() or FlushFileBuffers() on the generated database to ensure that it has reached non-volatile storage before completing.</source>
          <target state="translated">VACUUM INTOコマンドは、生成された出力データベースが元のデータベースの一貫したスナップショットであるという意味で、トランザクショナルです。しかし、VACUUM INTOコマンドが計画外のシャットダウンや停電によって中断された場合、生成された出力データベースは不完全で破損している可能性があります。また、SQLite は生成されたデータベースに対して fsync()や FlushFileBuffers()を呼び出さず、生成が完了する前に不揮発性ストレージに到達したことを確認します。</target>
        </trans-unit>
        <trans-unit id="122691010e5d737070edb247661b2776162b982c" translate="yes" xml:space="preserve">
          <source>The VACUUM INTO command works the same way except that it uses the file named on the INTO clause in place of the temporary database and omits the step of copying the vacuumed database back over top of the original database.</source>
          <target state="translated">VACUUM INTOコマンドは、一時データベースの代わりにINTO句で指定されたファイルを使用し、バキュームされたデータベースを元のデータベースの上にコピーするステップを省いている点を除いては、同じように動作します。</target>
        </trans-unit>
        <trans-unit id="7b858ec9bacb824cb3d161c5dbed06b788759184" translate="yes" xml:space="preserve">
          <source>The VACUUM command may change the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWIDs&lt;/a&gt; of entries in any tables that do not have an explicit &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;.</source>
          <target state="translated">VACUUMコマンドは、明示的な&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;がないテーブルのエントリの&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;を変更する場合があります。</target>
        </trans-unit>
        <trans-unit id="41696dc3c99878e16f90bac54782d308e462d0f3" translate="yes" xml:space="preserve">
          <source>The VACUUM command now works with the non-callback API</source>
          <target state="translated">VACUUMコマンドが非コールバックAPIで動作するようになりました。</target>
        </trans-unit>
        <trans-unit id="27866863317458114de851c82a30b86b318d52b6" translate="yes" xml:space="preserve">
          <source>The VACUUM command rebuilds the database file, repacking it into a minimal amount of disk space. There are several reasons an application might do this:</source>
          <target state="translated">VACUUMコマンドは、データベースファイルを再構築し、最小限のディスク容量にリパックします。アプリケーションがこれを行う理由はいくつかあります。</target>
        </trans-unit>
        <trans-unit id="9aa5f71406817eba130230946d703a26da25090a" translate="yes" xml:space="preserve">
          <source>The VACUUM command with an INTO clause is an alternative to the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt; for generating backup copies of a live database. The advantage of using VACUUM INTO is that the resulting backup database is minimal in size and hence the amount of filesystem I/O may be reduced. Also, all deleted content is purged from the backup, leaving behind no forensic traces. On the other hand, the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt; uses fewer CPU cycles and can be executed incrementally.</source>
          <target state="translated">INTO句を指定したVACUUMコマンドは、ライブデータベースのバックアップコピーを生成&lt;a href=&quot;backup&quot;&gt;する&lt;/a&gt;ためのバックアップAPIの代替手段です。 VACUUM INTOを使用する利点は、結果として得られるバックアップデータベースのサイズが最小になるため、ファイルシステムI / Oの量を削減できることです。また、削除されたコンテンツはすべてバックアップから削除され、フォレンジックトレースは残りません。一方、&lt;a href=&quot;backup&quot;&gt;バックアップAPI&lt;/a&gt;はより少ないCPUサイクルを使用し、インクリメンタルに実行できます。</target>
        </trans-unit>
        <trans-unit id="e0a189fd9e3d1e02aa0528451d9b2483299ef4e9" translate="yes" xml:space="preserve">
          <source>The VACUUM command works by copying the contents of the database into a temporary database file and then overwriting the original with the contents of the temporary file. When overwriting the original, a rollback journal or &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; WAL file is used just as it would be for any other database transaction. This means that when VACUUMing a database, as much as twice the size of the original database file is required in free disk space.</source>
          <target state="translated">VACUUMコマンドは、データベースの内容を一時データベースファイルにコピーし、元のファイルを一時ファイルの内容で上書きすることで機能します。元のファイルを上書きするときは、他のデータベーストランザクションの場合と同様に、ロールバックジャーナルまたは&lt;a href=&quot;wal&quot;&gt;ログ先行書き込み&lt;/a&gt; WALファイルが使用されます。これは、データベースをバキュームするときに、元のデータベースファイルの2倍のサイズが空きディスク領域に必要であることを意味します。</target>
        </trans-unit>
        <trans-unit id="778738485f953e3a9b76b31822d939e887b55074" translate="yes" xml:space="preserve">
          <source>The VALUE and HIWTR columns report the current value of the measure and its &quot;high-water mark&quot;. The high-water mark is the highest value ever seen for the measurement, at least since the last reset. The SQLITE_MEMSTAT virtual table does not provide a mechanism for resetting the high-water mark.</source>
          <target state="translated">VALUE 列と HIWTR 列は、メジャーの現在の値とその &quot;ハイ・ウォーター・マーク &quot;を報告します。ハイ・ウォーター・マークは、少なくとも最後にリセットされてからの測定の最高値です。SQLITE_MEMSTAT 仮想テーブルには、ハイ・ウォーター・マークをリセットするためのメカニズムはありません。</target>
        </trans-unit>
        <trans-unit id="1b2ece5b4ab8b91b62ace8f0cc0040f19a643253" translate="yes" xml:space="preserve">
          <source>The VALUES clause</source>
          <target state="translated">VALUES条項</target>
        </trans-unit>
        <trans-unit id="b8a859f7de071f48cff5a7fe9193dabc82e472c2" translate="yes" xml:space="preserve">
          <source>The VALUES clause of an INSERT can now contain expressions, including scalar SELECT clauses.</source>
          <target state="translated">INSERTのVALUES句は、スカラーSELECT句を含む式を含むことができるようになりました。</target>
        </trans-unit>
        <trans-unit id="222a8cea06637d3ca462a60582d77b6f51ecd46d" translate="yes" xml:space="preserve">
          <source>The VDBE code generated by the above statement looks like the following:</source>
          <target state="translated">上記の文で生成されたVDBEコードは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="914b54584037bedb35946860061828500f1bc504" translate="yes" xml:space="preserve">
          <source>The VDBE code generated for this query is as follows:</source>
          <target state="translated">このクエリのために生成されたVDBEコードは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="44e862e51e63dc8e6d2cfc4ebc01e6bf18bd5d5d" translate="yes" xml:space="preserve">
          <source>The VDBE implements a virtual computer that runs a program in its virtual machine language. The goal of each program is to interrogate or change the database. Toward this end, the machine language that the VDBE implements is specifically designed to search, read, and modify databases.</source>
          <target state="translated">VDBEは、その仮想マシン言語でプログラムを実行する仮想コンピュータを実装する。各プログラムの目的は、データベースを照会したり変更したりすることである。この目的のために、VDBEが実装するマシン言語は、データベースを検索、読み込み、変更するために特別に設計されている。</target>
        </trans-unit>
        <trans-unit id="2dceeabf6f031eb26374896fc49e25ce44afb511" translate="yes" xml:space="preserve">
          <source>The VDBE program generated for this SQL statement is as follows:</source>
          <target state="translated">このSQL文に対して生成されたVDBEプログラムは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="80bc0b2de97d753f617c4eaf5d3c9b6776ea43cf" translate="yes" xml:space="preserve">
          <source>The VERSION table shown above has columns to record a check-in comment (presumably supplied by the user) and the time and date at which the File/Save action occurred. It also records the parent version to record the history of changes. Perhaps the manifest could be stored as a delta from the parent version, though typically the manifest will be small enough that storing a delta might be more trouble than it is worth. The SLIDE table also contains a derivedFrom column which could be used for delta encoding if it is determined that saving the slide content as a delta from its previous version is a worthwhile optimization.</source>
          <target state="translated">上記のVERSIONテーブルには、チェックインコメント(おそらくユーザーが提供したものと思われます)と、ファイル/保存アクションが発生した日時を記録する列があります。また、変更の履歴を記録するための親バージョンも記録されます。おそらく、マニフェストは親バージョンからの差分として保存することができますが、通常、マニフェストは十分に小さく、差分を保存することはそれに見合う以上に面倒なことかもしれません。SLIDEテーブルには、前のバージョンからのデルタとしてスライドコンテンツを保存することが価値のある最適化であると判断された場合に、デルタエンコーディングに使用される可能性のある derivedFromカラムも含まれています。</target>
        </trans-unit>
        <trans-unit id="1b59010289d2579bd6e51282e421f222dba65ae2" translate="yes" xml:space="preserve">
          <source>The VFS interface is sometimes extended by adding new methods onto the end. Each time such an extension occurs, the iVersion field is incremented. The iVersion value started out as 1 in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; on 2007-09-04, then increased to 2 with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; on 2010-07-21, and then increased to 3 with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;version 3.7.6&lt;/a&gt; on 2011-04-12. Additional fields may be appended to the sqlite3_vfs object and the iVersion value may increase again in future versions of SQLite. Note that due to an oversight, the structure of the sqlite3_vfs object changed in the transition from SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_9.html&quot;&gt;version 3.5.9&lt;/a&gt; to &lt;a href=&quot;https://sqlite.org/releaselog/3_6_0.html&quot;&gt;version 3.6.0&lt;/a&gt; on 2008-07-16 and yet the iVersion field was not increased.</source>
          <target state="translated">VFSインターフェースは、最後に新しいメソッドを追加することによって拡張されることがあります。このような拡張が発生するたびに、iVersionフィールドがインクリメントされます。 iVersion値は、2007-09-04のSQLite&lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;バージョン3.5.0&lt;/a&gt;で1として始まり、2010-07-21のSQLite&lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;バージョン3.7.0&lt;/a&gt;で2に増加し、2011年のSQLite&lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;バージョン3.7.6&lt;/a&gt;で3に増加しました。 -04-12。追加のフィールドがsqlite3_vfsオブジェクトに追加される可能性があり、iVersion値はSQLiteの将来のバージョンで再び増加する可能性があります。見落としのため、2008-07-16のSQLite&lt;a href=&quot;https://sqlite.org/releaselog/3_5_9.html&quot;&gt;バージョン3.5.9&lt;/a&gt;から&lt;a href=&quot;https://sqlite.org/releaselog/3_6_0.html&quot;&gt;バージョン3.6.0&lt;/a&gt;への移行中にsqlite3_vfsオブジェクトの構造が変更されましたが、iVersionフィールドは増加していませんでした。</target>
        </trans-unit>
        <trans-unit id="0766456a2002e4475782706d0b0fb713540038a5" translate="yes" xml:space="preserve">
          <source>The VFS interface is sometimes extended by adding new methods onto the end. Each time such an extension occurs, the iVersion field is incremented. The iVersion value started out as 1 in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; on 2007-09-04, then increased to 2 with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; on 2010-07-21, and then increased to 3 with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;version 3.7.6&lt;/a&gt; on 2011-04-12. Additional fields may be appended to the sqlite3_vfs object and the iVersion value may increase again in future versions of SQLite. Note that the structure of the sqlite3_vfs object changes in the transition from SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_9.html&quot;&gt;version 3.5.9&lt;/a&gt; to &lt;a href=&quot;https://sqlite.org/releaselog/3_6_0.html&quot;&gt;version 3.6.0&lt;/a&gt; on 2008-07-16 and yet the iVersion field was not modified.</source>
          <target state="translated">VFSインターフェースは、最後に新しいメソッドを追加することで拡張される場合があります。このような拡張が行われるたびに、iVersionフィールドが増加します。2007-09-04のSQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;バージョン3.5.0&lt;/a&gt;では、iVersion値は1から始まり、2010-07-21のSQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;バージョン3.7.0&lt;/a&gt;では2に増加し、2011 ではSQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;バージョン3.7.6&lt;/a&gt;で3に増加しました。 -04-12。追加のフィールドがsqlite3_vfsオブジェクトに追加され、iVersion値がSQLiteの将来のバージョンで再び増加する可能性があります。 sqlite3_vfsオブジェクトの構造は、2008-07-16のSQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_9.html&quot;&gt;バージョン3.5.9&lt;/a&gt;から&lt;a href=&quot;https://sqlite.org/releaselog/3_6_0.html&quot;&gt;バージョン3.6.0&lt;/a&gt;への移行時に変更されますが、iVersionフィールドは変更されていません。</target>
        </trans-unit>
        <trans-unit id="9428f4f61873bedbb7fa546ce9da2878f0f6b46f" translate="yes" xml:space="preserve">
          <source>The VFS specified by a URI has the highest priority. After that comes a VFS specified as the fourth argument to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. The default VFS is used if no VFS is specified otherwise.</source>
          <target state="translated">URIで指定されたVFSが最も優先されます。その後、&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）の&lt;/a&gt; 4番目の引数としてVFSが指定されます。特に指定されていない場合は、デフォルトのVFSが使用されます。</target>
        </trans-unit>
        <trans-unit id="59f617b8350433543bfe3f6503e9062a84ed6414" translate="yes" xml:space="preserve">
          <source>The Virtual Database Engine of SQLite</source>
          <target state="translated">SQLiteの仮想データベースエンジン</target>
        </trans-unit>
        <trans-unit id="2fc007776417aa54116dbc71f8065ab7e3ac76ea" translate="yes" xml:space="preserve">
          <source>The Virtual Table Mechanism Of SQLite</source>
          <target state="translated">SQLiteの仮想テーブルの仕組み</target>
        </trans-unit>
        <trans-unit id="4a47770692c502c7c39564cd0fc7b210860b676a" translate="yes" xml:space="preserve">
          <source>The WAL approach inverts this. The original content is preserved in the database file and the changes are appended into a separate WAL file. A &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; occurs when a special record indicating a commit is appended to the WAL. Thus a COMMIT can happen without ever writing to the original database, which allows readers to continue operating from the original unaltered database while changes are simultaneously being committed into the WAL. Multiple transactions can be appended to the end of a single WAL file.</source>
          <target state="translated">WALアプローチはこれを逆にします。元のコンテンツはデータベースファイルに保存され、変更は別のWALファイルに追加されます。Aは、&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;コミット示す特別なレコードがWALに追加されるときに発生します。したがって、COMMITは、元のデータベースに書き込むことなく発生する可能性があります。これにより、変更が同時にWALにコミットされている間、リーダーは変更されていない元のデータベースから操作を続行できます。単一のWALファイルの末尾に複数のトランザクションを追加できます。</target>
        </trans-unit>
        <trans-unit id="82b1501dab1e647276daeb770adadd0f94b39bd1" translate="yes" xml:space="preserve">
          <source>The WAL file can optionally be truncated on a reset, but it need not be. Performance is usually a little better if the WAL is not truncated, since filesystems generally will overwrite an existing file faster than they will grow a file.</source>
          <target state="translated">WALファイルは、リセット時に任意で切り捨てることができますが、切り捨てる必要はありません。なぜなら、ファイルシステムは通常、ファイルを成長させるよりも既存のファイルを上書きする方が早いからです。</target>
        </trans-unit>
        <trans-unit id="6ee114cc7fc43aace09ed2f31fdb137fc0cc57b0" translate="yes" xml:space="preserve">
          <source>The WAL file exists for as long as any &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; has the database open. Usually, the WAL file is deleted automatically when the last connection to the database closes. However, if the last process to have the database open exits without cleanly shutting down the database connection, or if the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;file control&lt;/a&gt; is used, then the WAL file might be retained on disk after all connections to the database have been closed. The WAL file is part of the persistent state of the database and should be kept with the database if the database is copied or moved. If a database file is separated from its WAL file, then transactions that were previously committed to the database might be lost, or the database file might become corrupted. The only safe way to remove a WAL file is to open the database file using one of the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; interfaces then immediately close the database using &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">WALファイルは、データベース&lt;a href=&quot;c3ref/sqlite3&quot;&gt;接続&lt;/a&gt;でデータベースが開いている限り存在します。通常、WALファイルは、データベースへの最後の接続が閉じると自動的に削除されます。ただし、データベースを開く最後のプロセスが、データベース接続を&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;正常&lt;/a&gt;にシャットダウンせずに終了する場合、またはSQLITE_FCNTL_PERSIST_WAL &lt;a href=&quot;c3ref/file_control&quot;&gt;ファイルコントロールが&lt;/a&gt;を使用すると、データベースへのすべての接続が閉じられた後、WALファイルがディスクに保持される可能性があります。 WALファイルはデータベースの永続的な状態の一部であり、データベースがコピーまたは移動された場合、データベースとともに保持する必要があります。データベースファイルがWALファイルから分離されている場合、以前にデータベースにコミットされたトランザクションが失われるか、データベースファイルが破損する可能性があります。 WALファイルを削除する唯一の安全な方法は、&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;インターフェースの1つを使用してデータベースファイルを開き、&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close（）&lt;/a&gt;を使用してデータベースをすぐに閉じることです。</target>
        </trans-unit>
        <trans-unit id="79014b745cf0a5f8595085db33b3a7e639f66d1c" translate="yes" xml:space="preserve">
          <source>The WAL header is 32 bytes in size and consists of the following eight big-endian 32-bit unsigned integer values:</source>
          <target state="translated">WALヘッダは32バイトのサイズで、以下の8つのビッグエンディアン32ビット符号なし整数値で構成されています。</target>
        </trans-unit>
        <trans-unit id="3ad8fc65cf4c28a6553ebe75589fa3de09b97b25" translate="yes" xml:space="preserve">
          <source>The WAL journal mode will be set on all connections to the same database file if it is set on any one connection.</source>
          <target state="translated">WAL ジャーナルモードは、1 つの接続でも設定されていれば、同じデータベースファイルへのすべての接続で設定されます。</target>
        </trans-unit>
        <trans-unit id="c2da5fc09a01446274895178b9f5584cc12d72c9" translate="yes" xml:space="preserve">
          <source>The WAL journaling mode uses a &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; instead of a rollback journal to implement transactions. The WAL journaling mode is persistent; after being set it stays in effect across multiple database connections and after closing and reopening the database. A database in WAL journaling mode can only be accessed by SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2010-07-21) or later.</source>
          <target state="translated">WALジャーナリングモードは、ロールバックジャーナルの代わりに&lt;a href=&quot;wal&quot;&gt;先行書き込みログを&lt;/a&gt;使用してトランザクションを実装します。WALジャーナリングモードは永続的です。設定後は、複数のデータベース接続にわたって有効であり、データベースを閉じて再度開いた後も有効です。WALジャーナリングモードのデータベースには、SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;バージョン3.7.0&lt;/a&gt;（2010-07-21）以降でのみアクセスできます。</target>
        </trans-unit>
        <trans-unit id="bbeadb5beff9552e41ebfc0aed8339e43743fd64" translate="yes" xml:space="preserve">
          <source>The WAL-index format version number. Always 3007000.</source>
          <target state="translated">WAL-indexフォーマットのバージョン番号。常に3007000。</target>
        </trans-unit>
        <trans-unit id="a0470594be37c3f0ff60237d02ae37bf43150bc8" translate="yes" xml:space="preserve">
          <source>The WAL-index or &quot;shm&quot; file is used to coordinate access to the database by multiple clients, and as a cache to help clients quickly locate frames within the wal file.</source>
          <target state="translated">WAL-indexまたは &quot;shm &quot;ファイルは、複数のクライアントによるデータベースへのアクセスを調整するために使用され、クライアントがWALファイル内のフレームを素早く見つけるのを助けるためのキャッシュとしても使用されます。</target>
        </trans-unit>
        <trans-unit id="3fa0bf716018ca8d2c184cf21d82cae1245d9415" translate="yes" xml:space="preserve">
          <source>The WAL_CKPT_LOCK is only locked exclusively. There is never a shared lock taken on WAL_CKPT_LOCK.</source>
          <target state="translated">WAL_CKPT_LOCKは排他的にロックされているだけです。WAL_CKPT_LOCK上で共有ロックが取られることはありません。</target>
        </trans-unit>
        <trans-unit id="42d567271c4a4abf54f649e6218b2a342b7491c5" translate="yes" xml:space="preserve">
          <source>The WAL_RECOVER_LOCK is only locked exclusively. There is never a shared lock taken on WAL_RECOVER_LOCK.</source>
          <target state="translated">WAL_RECOVER_LOCKは排他的にロックされているだけです。WAL_RECOVER_LOCKで取られる共有ロックは決してありません。</target>
        </trans-unit>
        <trans-unit id="f378361895c3312e72c176b00bbf1af957e8b29d" translate="yes" xml:space="preserve">
          <source>The WAL_WRITE_LOCK is only locked exclusively. There is never a shared lock taken on WAL_WRITE_LOCK.</source>
          <target state="translated">WAL_WRITE_LOCKは排他的にロックされているだけです。WAL_WRITE_LOCK上で共有ロックが取られることはありません。</target>
        </trans-unit>
        <trans-unit id="cddb2fff96db0eb2561a8fa9288188bd61c4a17a" translate="yes" xml:space="preserve">
          <source>The WHERE clause is implemented by instructions 6 through 8. The job of the where clause is to skip the ListWrite if the WHERE condition is false. To this end, it jumps ahead to the Next instruction if the &quot;two&quot; column (extracted by the Column instruction) is greater than or equal to 50.</source>
          <target state="translated">WHERE句は命令6から8によって実装されています。WHERE句の役割は、WHERE条件がFalseの場合にListWriteをスキップすることです。このため、(Column命令で抽出された)&quot;2 &quot;列が50以上であれば、Next命令にジャンプする。</target>
        </trans-unit>
        <trans-unit id="29f1ffc6e309ea1c4b2ff1d0678fe7459979e894" translate="yes" xml:space="preserve">
          <source>The WHERE clause on a query is broken up into &quot;terms&quot; where each term is separated from the others by an AND operator. If the WHERE clause is composed of constraints separate by the OR operator then the entire clause is considered to be a single &quot;term&quot; to which the &lt;a href=&quot;#or_opt&quot;&gt;OR-clause optimization&lt;/a&gt; is applied.</source>
          <target state="translated">クエリのWHERE句は「用語」に分割され、各用語はAND演算子によって他の用語から分離されます。WHERE句がOR演算子で区切られた制約で構成されている場合、句全体は、&lt;a href=&quot;#or_opt&quot;&gt;OR句の最適化&lt;/a&gt;が適用される単一の「用語」と見なされます。</target>
        </trans-unit>
        <trans-unit id="67af3225970c5961856bbb922d2677740529dd45" translate="yes" xml:space="preserve">
          <source>The WINDOW clause, when one is present, comes after any HAVING clause and before any ORDER BY.</source>
          <target state="translated">WINDOW句は、人がいる場合、HAVING句の後、ORDER BY句の前に来ます。</target>
        </trans-unit>
        <trans-unit id="59f006cfccb1b0c07b582f38b2b03e476dd1faa4" translate="yes" xml:space="preserve">
          <source>The WITH Clause</source>
          <target state="translated">WITH句</target>
        </trans-unit>
        <trans-unit id="49bb3b8074d7fe6469254452d39dc417f079e333" translate="yes" xml:space="preserve">
          <source>The WITH clause cannot be used within a &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;.</source>
          <target state="translated">WITH句は&lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;内では使用できません。</target>
        </trans-unit>
        <trans-unit id="469f423bf145b329a62c79e892ff06f00b735aaa" translate="yes" xml:space="preserve">
          <source>The WITH clause must appear at the beginning of a top-level &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement or at the beginning of a subquery. The WITH clause cannot be prepended to the second or subsequent SELECT statement of a &lt;a href=&quot;lang_select#compound&quot;&gt;compound select&lt;/a&gt;.</source>
          <target state="translated">WITH句は、トップレベルの&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントの先頭またはサブクエリの先頭に指定する必要があります。WITH句は、&lt;a href=&quot;lang_select#compound&quot;&gt;複合選択の&lt;/a&gt; 2番目以降のSELECTステートメントの前に追加できません。</target>
        </trans-unit>
        <trans-unit id="0790118e4cc64a2949db095a0b8b9579da7d5654" translate="yes" xml:space="preserve">
          <source>The WITHOUT ROWID optimization is likely to be helpful for tables that have non-integer or composite (multi-column) PRIMARY KEYs and that do not store large strings or BLOBs.</source>
          <target state="translated">WITHOUT ROWIDの最適化は、非整数や複合(複数列)のPRIMARY KEYを持ち、大きな文字列やBLOBを保存しないテーブルで役立つでしょう。</target>
        </trans-unit>
        <trans-unit id="b74650aa10ba4b42e039edd4a2cc74f6b68fb08b" translate="yes" xml:space="preserve">
          <source>The WITHOUT ROWID syntax is an optimization. It provides no new capabilities. Anything that can be done using a WITHOUT ROWID table can also be done in exactly the same way, and exactly the same syntax, using an ordinary rowid table. The only advantage of a WITHOUT ROWID table is that it can sometimes use less disk space and/or perform a little faster than an ordinary rowid table.</source>
          <target state="translated">WITHOUT ROWID構文は最適化です。これは新しい機能を提供しません。WITHOUT ROWIDテーブルを使用してできることはすべて、通常のROWIDテーブルを使用して全く同じ方法で、全く同じ構文で行うことができます。WITHOUT ROWIDテーブルの唯一の利点は、通常のROWIDテーブルよりもディスク容量が少なくて済むことや、少しだけ高速に実行できることです。</target>
        </trans-unit>
        <trans-unit id="d5d979d02523b8b3c921a385853078f31581834f" translate="yes" xml:space="preserve">
          <source>The WITHOUT ROWID table that has the same structure as the t1bc index would look like this:</source>
          <target state="translated">t1bcインデックスと同じ構造を持つWITHOUT ROWIDテーブルは次のようになります。</target>
        </trans-unit>
        <trans-unit id="ebd241bcb9edacf4c26a21a11fc0d3a7cc0b5d00" translate="yes" xml:space="preserve">
          <source>The X callback is invoked whenever any of the events identified by mask M occur. The integer return value from the callback is currently ignored, though this may change in future releases. Callback implementations should return zero to ensure future compatibility.</source>
          <target state="translated">X コールバックは、マスク M で指定されたイベントが発生するたびに呼び出されます。コールバックからの整数値の戻り値は現在無視されていますが、将来のリリースでは変更される可能性があります。将来の互換性を確保するために、コールバックの実装はゼロを返すべきです。</target>
        </trans-unit>
        <trans-unit id="d9560a5bff3ce71963e342a5450ede2debbbea82" translate="yes" xml:space="preserve">
          <source>The aConstraintUsage[] array contains one element for each of the nConstraint constraints in the inputs section of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure. The aConstraintUsage[] array is used by xBestIndex to tell the core how it is using the constraints.</source>
          <target state="translated">aConstraintUsage []配列には、&lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;構造の入力セクションのnConstraint制約ごとに1つの要素が含まれます。aConstraintUsage []配列は、xBestIndexによって使用され、制約がどのように使用されているかをコアに伝えます。</target>
        </trans-unit>
        <trans-unit id="3276fd18c87b4e795759956677bbdc04f564672d" translate="yes" xml:space="preserve">
          <source>The aConstraint[] array contains information about all constraints that apply to the virtual table. But some of the constraints might not be usable because of the way tables are ordered in a join. The xBestIndex method must therefore only consider constraints that have an aConstraint[].usable flag which is true.</source>
          <target state="translated">aConstraint[]配列には、仮想テーブルに適用されるすべての制約に関する情報が含まれます。しかし、テーブルが結合で順序付けされる方法のため、制約の中には使用できないものがあるかもしれません。そのため、xBestIndexメソッドは、aConstraint[].usableフラグが真である制約のみを考慮しなければなりません。</target>
        </trans-unit>
        <trans-unit id="08f35e14867214bff1de15c06eccca3a8c64a445" translate="yes" xml:space="preserve">
          <source>The aConstraint[] array records WHERE clause constraints of the form:</source>
          <target state="translated">aConstraint[]配列は、形式のWHERE句制約を記録します。</target>
        </trans-unit>
        <trans-unit id="cb4f46690b6dce470ed710606d550164c584726b" translate="yes" xml:space="preserve">
          <source>The ability to add &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;, including aggregate and table-valued functions.</source>
          <target state="translated">集計&lt;a href=&quot;appfunc&quot;&gt;関数&lt;/a&gt;やテーブル値関数など、アプリケーション定義のSQL関数を追加する機能。</target>
        </trans-unit>
        <trans-unit id="201991425b66ed2865e7a91ab0511b280556125f" translate="yes" xml:space="preserve">
          <source>The ability to add &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;, including aggregate and table-valued functions.</source>
          <target state="translated">集計&lt;a href=&quot;c3ref/create_function&quot;&gt;関数&lt;/a&gt;やテーブル値関数など、アプリケーション定義のSQL関数を追加する機能。</target>
        </trans-unit>
        <trans-unit id="a3094b48cb721d2768a7d14f0821434de8cd0a90" translate="yes" xml:space="preserve">
          <source>The ability to index expressions was added to SQLite with &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). A database that uses an index on expressions will not be usable by earlier versions of SQLite.</source>
          <target state="translated">SQLiteの&lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;バージョン3.9.0&lt;/a&gt;（2015-10-14）では、式にインデックスを付ける機能が追加されました。式にインデックスを使用するデータベースは、以前のバージョンのSQLiteでは使用できません。</target>
        </trans-unit>
        <trans-unit id="e647580ce3a971bdf9683f9f823fdf4aa9345057" translate="yes" xml:space="preserve">
          <source>The ability to store BLOBs in indexed columns.</source>
          <target state="translated">インデックス化された列にBLOBを格納する機能。</target>
        </trans-unit>
        <trans-unit id="2b4889307c133133bf332e84c716afd8e6689ea5" translate="yes" xml:space="preserve">
          <source>The ability to use keywords as identifiers promotes backwards compatibility. As new keywords are added, legacy schemas that just happen to use those keywords as table or column names continue to work. However, the ability to use a keyword as an identifier sometimes leads to surprising outcomes. For example:</source>
          <target state="translated">識別子としてキーワードを使用する機能は、下位互換性を促進します。新しいキーワードが追加されても、たまたまそのキーワードをテーブル名やカラム名として使用していたレガシースキーマは引き続き動作します。しかし、キーワードを識別子として使用する機能は、時には驚くような結果をもたらすことがあります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="4e7fcdb984584a84897317afa23740edc4a933b7" translate="yes" xml:space="preserve">
          <source>The above code creates a new table named &lt;b&gt;t1&lt;/b&gt; with columns &lt;b&gt;a&lt;/b&gt; and &lt;b&gt;b&lt;/b&gt;. What could be simpler?</source>
          <target state="translated">上記のコードは、列&lt;b&gt;a&lt;/b&gt;および&lt;b&gt;bを&lt;/b&gt;持つ&lt;b&gt;t1&lt;/b&gt;という名前の新しいテーブルを作成します。何がもっと簡単になるでしょうか？&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1e597cdc48d987ee3a37507f5f4f64e4eebc9821" translate="yes" xml:space="preserve">
          <source>The above command should be run from the MSVC Native Tools Command Prompt. If you have MSVC installed on your machine, you probably have multiple versions of this Command Prompt, for native builds for x86 and x64, and possibly also for cross-compiling to ARM. Use the appropriate Command Prompt depending on the desired DLL.</source>
          <target state="translated">上記のコマンドは MSVC Native Tools のコマンドプロンプトから実行してください。お使いのマシンにMSVCがインストールされている場合、おそらくこのコマンドプロンプトの複数のバージョンがあり、x86とx64のネイティブビルド用に、またARMへのクロスコンパイル用に、複数のバージョンがあります。目的の DLL に応じて適切なコマンドプロンプトを使用してください。</target>
        </trans-unit>
        <trans-unit id="40e5d3c82a1f28fca2d855ebabf947c2e6309d01" translate="yes" xml:space="preserve">
          <source>The above is all you really need to know in order to use SQLite in your C or C++ programs. There are other interface functions available (and described below) but we will begin by describing the core functions shown above.</source>
          <target state="translated">CやC++プログラムでSQLiteを使用するために本当に知っておくべきことは以上です。他にも利用可能なインターフェース関数はありますが(後述します)、まずは上記のコア関数について説明します。</target>
        </trans-unit>
        <trans-unit id="e1d8b560084e958b9b180ef1ea3e4c34811a8e33" translate="yes" xml:space="preserve">
          <source>The above means that executing the 'merge' command with a negative parameter until the before and after difference in the return value of &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; is less than two optimizes the FTS index in the same way as the &lt;a href=&quot;fts5#the_optimize_command&quot;&gt;FTS5 optimize command&lt;/a&gt;. However, if a new b-tree is added to the FTS index while this process is ongoing, FTS5 will move the new b-tree to the same level as the existing b-trees and restart the merge. To avoid this, only the first call to 'merge' should specify a negative parameter. Each subsequent call to 'merge' should specify a positive value so that the merge started by the first call is run to completion even if new b-trees are added to the FTS index.</source>
          <target state="translated">上記は、&lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes（）の&lt;/a&gt;戻り値の前後の差が2未満になるまで負のパラメーターで 'merge'コマンドを実行すると、&lt;a href=&quot;fts5#the_optimize_command&quot;&gt;FTS5最適化コマンド&lt;/a&gt;と同じ方法でFTSインデックスが最適化されることを意味します。ただし、このプロセスの進行中に新しいBツリーがFTSインデックスに追加されると、FTS5は新しいBツリーを既存のBツリーと同じレベルに移動し、マージを再開します。これを回避するには、 'merge'の最初の呼び出しでのみ負のパラメーターを指定する必要があります。後続の各 'merge'の呼び出しでは、新しいbツリーがFTSインデックスに追加された場合でも、最初の呼び出しによって開始されたマージが最後まで実行されるように、正の値を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="a9200726c1128b95e04b731c9b7e036f2a699198" translate="yes" xml:space="preserve">
          <source>The above two assumptions may be interpreted to mean that if a system failure occurs after file truncation but before the truncated file is</source>
          <target state="translated">上記2つの仮定は、ファイルの切り捨て後にシステム障害が発生しても、切り捨てられたファイルが</target>
        </trans-unit>
        <trans-unit id="63e4faf9292fbb17cef84d7ffb499ec94358865c" translate="yes" xml:space="preserve">
          <source>The above will return something like this:</source>
          <target state="translated">上記のようなものが返ってきます。</target>
        </trans-unit>
        <trans-unit id="0861e077c18aeb6848f0b5c9c63fbc9c90c17596" translate="yes" xml:space="preserve">
          <source>The abs(X) function returns the absolute value of the numeric argument X. Abs(X) returns NULL if X is NULL. Abs(X) returns 0.0 if X is a string or blob that cannot be converted to a numeric value. If X is the integer -9223372036854775808 then abs(X) throws an integer overflow error since there is no equivalent positive 64-bit two complement value.</source>
          <target state="translated">abs(X)関数は数値引数Xの絶対値を返します。Abs(X)は、Xが数値に変換できない文字列またはブロブの場合は0.0を返します。X が整数 -9223372036854775808 の場合は、等価な正の 64 ビット 2 補数値が存在しないため、 abs(X)は整数オーバーフローエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="3eb517318225f5fe795733968275ce4a51bc681e" translate="yes" xml:space="preserve">
          <source>The absolute value of this integer argument is used as the (approximate) number of tokens to include in the returned text value. The maximum allowable absolute value is 64. The value of this argument is referred to as</source>
          <target state="translated">この整数引数の絶対値は、返されたテキスト値に含めるトークンの数(おおよその)として使用されます。絶対値の最大値は64です。この引数の値は</target>
        </trans-unit>
        <trans-unit id="85ca4a9788c6f1b476159c0eeb6719f0a0122577" translate="yes" xml:space="preserve">
          <source>The acctchng_magnitude index is over the account number (&quot;acct_no&quot;) and on the absolute value of the amount. This index allows one to do efficient queries over the magnitude of a change to the account. For example, to list all changes to account number $xyz that are more than $100.00, one can say:</source>
          <target state="translated">acctchng_magnitude インデックスは、口座番号 (&quot;acct_no&quot;)と金額の絶対値の上にあります。このインデックスを使用すると、アカウントへの変更の大きさを効率的に調べることができます。例えば、口座番号 $xyz へのすべての変更が $100.00 以上であることをリストアップするには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="5e14d586171fc852b529e7898dae84a1afce65ec" translate="yes" xml:space="preserve">
          <source>The acronym RBU stands for &quot;Resumable Bulk Update&quot;.</source>
          <target state="translated">RBUは「Resumable Bulk Update」の頭文字をとったものです。</target>
        </trans-unit>
        <trans-unit id="cd26fea06f2a519581c858bc894c62df5370dfe9" translate="yes" xml:space="preserve">
          <source>The act of deleting a file is expensive on many systems. As an optimization, SQLite can be configured to truncate the journal file to zero bytes in length or overwrite the journal file header with zeros. In either case, the resulting journal file is no longer capable of rolling back and so the transaction still commits. Truncating a file to zero length, like deleting a file, is assumed to be an atomic operation from the point of view of a user process. Overwriting the header of the journal with zeros is not atomic, but if any part of the header is malformed the journal will not roll back. Hence, one can say that the commit occurs as soon as the header is sufficiently changed to make it invalid. Typically this happens as soon as the first byte of the header is zeroed.</source>
          <target state="translated">ファイルを削除するという行為は、多くのシステムではコストがかかります。最適化として、SQLite はジャーナルファイルの長さをゼロバイトに切り詰めたり、ジャーナルファイルヘッダをゼロで上書きしたりするように設定することができます。いずれの場合も、結果として生じるジャーナルファイルはロールバックできなくなるため、トランザクションはコミットされたままになります。ファイルを長さ0に切り詰めることは、ファイルの削除と同様に、ユーザープロセスから見てアトミックな操作であると 想定される。ジャーナルのヘッダをゼロで上書きすることはアトミックではありませんが、ヘッダのどこかの部分が不正な形になっている場合、ジャーナルはロールバックしません。したがって、ヘッダが十分に変更されて無効になるとすぐにコミットが発生すると言うことができます。通常、これはヘッダの最初のバイトがゼロになるとすぐに起こります。</target>
        </trans-unit>
        <trans-unit id="eb72a7b6e0cde775aa0861a739588c085322d8b5" translate="yes" xml:space="preserve">
          <source>The action of the preupdate hook is similar to the &lt;a href=&quot;c3ref/update_hook&quot;&gt;update hook&lt;/a&gt; except that the callback is invoked before the change, not afterwards, and the preupdate hook interfaces are omitted unless this compile-time option is used.</source>
          <target state="translated">preupdateフックのアクションは、後でではなく変更の前にコールバックが呼び出され、このコンパイル時オプションが使用されない限りpreupdateフックインターフェイスが省略されることを除いて、&lt;a href=&quot;c3ref/update_hook&quot;&gt;更新&lt;/a&gt;フックと同様です。</target>
        </trans-unit>
        <trans-unit id="d730b41c0c65afc48bf2186d2e78971f79c0ae93" translate="yes" xml:space="preserve">
          <source>The actual remote head</source>
          <target state="translated">実際のリモートヘッド</target>
        </trans-unit>
        <trans-unit id="d5942dd3b483843b4b3b13169967e9623c12cf60" translate="yes" xml:space="preserve">
          <source>The actual value of the automerge parameter determines the number of index segments merged simultaneously by an automatic inverted index merge. If the value is set to N, the system waits until there are at least N segments on a single level before beginning to incrementally merge them. Setting a lower value of N causes segments to be merged more quickly, which may speed up full-text queries and, if the workload contains UPDATE or DELETE operations as well as INSERTs, reduce the space on disk consumed by the full-text index. However, it also increases the amount of data written to disk.</source>
          <target state="translated">automerge パラメータの実際の値は、自動転置インデックスマージで同時にマージされるインデックスセグメントの数を決定します。値が N に設定されている場合、システムは、1 つのレベルに少なくとも N 個のセグメントが存在するまで待ってから、それらのセグメントのインクリメンタルなマージを開始します。N の値を低く設定すると、セグメントのマージがより迅速に行われるようになり、フルテキストクエリの速度が向上し、作業負荷に UPDATE や DELETE 操作と INSERT が含まれている場合には、フルテキストインデックスが消費するディスク上の容量が減少します。しかし、ディスクに書き込まれるデータ量も増えます。</target>
        </trans-unit>
        <trans-unit id="fcad8bd16dfc8bbae32259b89340b3c09c02938b" translate="yes" xml:space="preserve">
          <source>The address of the cell in the parent frame is determined by adding the value of the P1 argument to the value of the P1 argument to the calling &lt;a href=&quot;opcode#Program&quot;&gt;Program&lt;/a&gt; instruction.</source>
          <target state="translated">親フレーム内のセルのアドレスは、呼び出し元の&lt;a href=&quot;opcode#Program&quot;&gt;Program&lt;/a&gt;命令のP1引数の値にP1引数の値を追加することによって決定されます。</target>
        </trans-unit>
        <trans-unit id="e600ae2c57bf2172dc311ec955786ffac68bdb53" translate="yes" xml:space="preserve">
          <source>The advantage of the table-valued function format is that the query can return just a subset of the PRAGMA columns, can include a WHERE clause, can use aggregate functions, and the table-valued function can be just one of several data sources in a join. For example, to get a list of all indexed columns in a schema, one could query:</source>
          <target state="translated">テーブル値関数形式の利点は、クエリがPRAGMAカラムのサブセットだけを返すことができ、WHERE句を含めることができ、集約関数を使用することができ、テーブル値関数は結合の中の複数のデータソースのうちの1つにすぎないことです。例えば、スキーマ内のすべてのインデックス付きカラムのリストを取得するには、クエリを実行します。</target>
        </trans-unit>
        <trans-unit id="d98ae93ba70e0ca59260993947a4e24c760765d2" translate="yes" xml:space="preserve">
          <source>The advantages of doing many smaller sorts instead of a single large sort are:</source>
          <target state="translated">1つの大きなソートをするのではなく、小さなソートをたくさんすることのメリットがあります。</target>
        </trans-unit>
        <trans-unit id="15b97dc5f9d1078668a6ce572dccbfb387883173" translate="yes" xml:space="preserve">
          <source>The affinity of a column is determined by the declared type of the column, according to the following rules in the order shown:</source>
          <target state="translated">カラムの親和性は、以下のルールに従って、カラムの宣言された型によって、示された順に決定されます。</target>
        </trans-unit>
        <trans-unit id="81c1ff1ba114ea49399c70cede12a7ccd08cc3d4" translate="yes" xml:space="preserve">
          <source>The affinity of the v1.x column will be the same as the affinity of t1.b (TEXT), since v1.x maps directly into t1.b. But columns v1.y and v1.z both have no affinity, since those columns map into expression a+c and 42, and expressions always have no affinity.</source>
          <target state="translated">しかし、列v1.yとv1.zの両方は、それらの列が式a+cと42にマップされ、式は常に何の親和性も持たないので、親和性を持たない。</target>
        </trans-unit>
        <trans-unit id="ab16418452d7d68b0bd05abd8cefe39ddc38000d" translate="yes" xml:space="preserve">
          <source>The aggregate functions shown below are available by default. Additional aggregate functions written in C may be added using the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; API.</source>
          <target state="translated">以下に示す集計関数は、デフォルトで使用できます。Cで記述された追加の集約関数は、&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt; API を使用して追加できます。</target>
        </trans-unit>
        <trans-unit id="084c900ab7b78b8fb14c15704a0ab2585c905626" translate="yes" xml:space="preserve">
          <source>The algorithm above works quite well for most cases, but there are exceptions. These exceptions can be dealt with by making additional entries in the virtual table using the &quot;soundslike&quot; column.</source>
          <target state="translated">上記のアルゴリズムはほとんどの場合でうまく機能しますが、例外もあります。これらの例外は、&quot;soundslike&quot; カラムを使用して仮想テーブルに追加のエントリを作成することで対処できます。</target>
        </trans-unit>
        <trans-unit id="db0be7814305eaba73945c0429fa38151c410e55" translate="yes" xml:space="preserve">
          <source>The algorithm specified in the OR clause of an INSERT or UPDATE overrides any algorithm specified in a CREATE TABLE. If no algorithm is specified anywhere, the ABORT algorithm is used.</source>
          <target state="translated">INSERTまたはUPDATEのOR句で指定されたアルゴリズムは、CREATE TABLEで指定されたアルゴリズムを上書きします。どこにもアルゴリズムが指定されていない場合、ABORTアルゴリズムが使用されます。</target>
        </trans-unit>
        <trans-unit id="8f1bb5e260f6d6940f8038960690efd8a13241e0" translate="yes" xml:space="preserve">
          <source>The algorithm used by memsys5 can be called &quot;power-of-two, first-fit&quot;. The sizes of all memory allocation requests are rounded up to a power of two and the request is satisfied by the first free slot in pBuf that is large enough. Adjacent freed allocations are coalesced using a buddy system. When used appropriately, this algorithm provides mathematical guarantees against fragmentation and breakdown, as described further &lt;a href=&quot;#nofrag&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">memsys5で使用されるアルゴリズムは、「2のべき乗、最初の適合」と呼ぶことができます。すべてのメモリ割り当て要求のサイズは2の累乗に切り上げられ、pBuf内の十分な大きさの最初の空きスロットによって要求が満たされます。隣接する解放された割り当ては、バディシステムを使用して結合されます。このアルゴリズムを適切に使用すると、&lt;a href=&quot;#nofrag&quot;&gt;以下で&lt;/a&gt;さらに説明するように、フラグメンテーションとブレークダウンに対する数学的保証が提供されます。</target>
        </trans-unit>
        <trans-unit id="91caf7e2c108fa5ca12a12fe7d7f1b642ba24d6e" translate="yes" xml:space="preserve">
          <source>The algorithm used by the sqlite3_blocking_prepare_v2() function is similar, except that step 4 (resetting the statement handle) is omitted.</source>
          <target state="translated">sqlite3_blocking_prepare_v2()関数で使用されるアルゴリズムは、ステップ4(ステートメントハンドルのリセット)が省略されていることを除いて、似ています。</target>
        </trans-unit>
        <trans-unit id="cae289508ac99f821f2b991e22b21782588d9eaa" translate="yes" xml:space="preserve">
          <source>The algorithm used by the sqlite3_blocking_step() function is as follows:</source>
          <target state="translated">sqlite3_blocking_step()関数が使用するアルゴリズムは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="ce63f03e43853b117cae180b17d7d91a1fc4423c" translate="yes" xml:space="preserve">
          <source>The alternate-form-2 flag is a non-standard extension that appears in no other printf() implementations, as far as we know.</source>
          <target state="translated">alternate-form-2 フラグは、私たちの知る限り、他の printf()の実装には存在しない非標準の拡張です。</target>
        </trans-unit>
        <trans-unit id="28b22ace0382822e0d79f9e1827563fce76153d6" translate="yes" xml:space="preserve">
          <source>The alternative page cache mechanism is an extreme measure that is only needed by the most demanding applications. The built-in page cache is recommended for most uses.</source>
          <target state="translated">代替ページキャッシュ機構は、最も要求の厳しいアプリケーションでのみ必要とされる極端な対策です。ほとんどの用途では、組み込みのページキャッシュが推奨されています。</target>
        </trans-unit>
        <trans-unit id="8b4794d01495b7d8ad2197d5e4f4f33e4044492d" translate="yes" xml:space="preserve">
          <source>The alternative query formulations shown above are conceptual only. SQLite does not really transform the query. The actual query plan is like this: SQLite locates the first possible value for &quot;role&quot;, which it can do by rewinding the &quot;people_idx1&quot; index to the beginning and reading the first record. SQLite stores this first &quot;role&quot; value in an internal variable that we will here call &quot;$role&quot;. Then SQLite runs a query like: &quot;SELECT name FROM people WHERE role=$role AND height&amp;gt;=180&quot;. This query has an equality constraint on the left-most column of the index and so the index can be used to resolve that query. Once that query is finished, SQLite then uses the &quot;people_idx1&quot; index to locate the next value of the &quot;role&quot; column, using code that is logically similar to &quot;SELECT role FROM people WHERE role&amp;gt;$role LIMIT 1&quot;. This new &quot;role&quot; value overwrites the $role variable, and the process repeats until all possible values for &quot;role&quot; have been examined.</source>
          <target state="translated">上記の代替クエリの公式は概念的なものです。 SQLiteは実際にはクエリを変換しません。実際のクエリプランは次のようになります。SQLiteは、「people_idx1」インデックスを先頭に巻き戻して最初のレコードを読み取ることで、「ロール」の最初の可能な値を見つけます。 SQLiteは、最初の「ロール」値を、ここでは「$ロール」と呼ぶ内部変数に格納します。次に、SQLiteは、「SELECT FROM FROM people WHERE role = $ role AND height&amp;gt; = 180」のようなクエリを実行します。このクエリには、インデックスの左端の列に等価制約があるため、インデックスを使用してそのクエリを解決できます。クエリが完了すると、SQLiteは「people_idx1」インデックスを使用して、「role」列の次の値を検索します。SELECT FROM FROM people WHERE role&amp;gt; $ role LIMIT 1 &quot;。この新しい「role」の値は$ role変数を上書きし、「role」のすべての可能な値が調べられるまでプロセスが繰り返されます。</target>
        </trans-unit>
        <trans-unit id="a91f523f7f1e692f775ff82bc9d632716d5637ec" translate="yes" xml:space="preserve">
          <source>The amalgamation and the sqlite3.h header file are available on the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download page&lt;/a&gt; as a file named sqlite-amalgamation-X.zip where the X is replaced by the appropriate version number.</source>
          <target state="translated">amalgamationとsqlite3.hヘッダーファイルは、Xが適切なバージョン番号に置き換えられたsqlite-amalgamation-X.zipという名前のファイルとして&lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;ダウンロードページで&lt;/a&gt;入手できます。</target>
        </trans-unit>
        <trans-unit id="c0a154d12ef5a44def7683dee324b4a87567d061" translate="yes" xml:space="preserve">
          <source>The amalgamation contains everything you need to integrate SQLite into a larger project. Just copy the amalgamation into your source directory and compile it along with the other C code files in your project. (A &lt;a href=&quot;howtocompile&quot;&gt;more detailed discussion&lt;/a&gt; of the compilation process is available.) You may also want to make use of the &quot;sqlite3.h&quot; header file that defines the programming API for SQLite. The sqlite3.h header file is available separately. The sqlite3.h file is also contained within the amalgamation, in the first few thousand lines. So if you have a copy of sqlite3.c but cannot seem to locate sqlite3.h, you can always regenerate the sqlite3.h by copying and pasting from the amalgamation.</source>
          <target state="translated">この統合には、SQLiteをより大きなプロジェクトに統合するために必要なすべてのものが含まれています。融合をソースディレクトリにコピーして、プロジェクト内の他のCコードファイルと共にコンパイルするだけです。 （コンパイルプロセスの&lt;a href=&quot;howtocompile&quot;&gt;詳細な説明&lt;/a&gt;が利用可能です。）また、SQLiteのプログラミングAPIを定義する「sqlite3.h」ヘッダーファイルを利用することもできます。 sqlite3.hヘッダーファイルは別途入手できます。 sqlite3.hファイルも、最初の数千行で、アマガメーション内に含まれています。そのため、sqlite3.cのコピーはあるがsqlite3.hが見つからない場合は、アマルガムからコピーして貼り付けることで、常にsqlite3.hを再生成できます。</target>
        </trans-unit>
        <trans-unit id="c5760ad296baf5ccd7d73666c3833985afa715a2" translate="yes" xml:space="preserve">
          <source>The amount of payload that spills onto overflow pages also depends on the page type. For the following computations, let U be the usable size of a database page, the total page size less the reserved space at the end of each page. And let P be the payload size. In the following, symbol X represents the maximum amount of payload that can be stored directly on the b-tree page without spilling onto an overflow page and symbol M represents the minimum amount of payload that must be stored on the btree page before spilling is allowed.</source>
          <target state="translated">オーバーフローページにこぼれるペイロードの量は、ページの種類にも依存します。以下の計算では、U をデータベースページの使用可能なサイズ、すなわちページ全体のサイズから各ページの最後に予約されたスペースを差し引いたものとします。また、ペイロードサイズを P とする。以下では、記号 X は、オーバーフローページにこぼれることなく b-tree ページに直接格納できるペイロードの最大量を表し、記号 M は、こぼれが許される前に b-tree ページに格納しなければならないペイロードの最小量を表しています。</target>
        </trans-unit>
        <trans-unit id="cc7c17ba1fc473503228a1ad5223b1322c93e902" translate="yes" xml:space="preserve">
          <source>The amount of space allocated by sqlite3_aggregate_context(C,N) is determined by the N parameter on first successful call. Changing the value of N in any subsequent call to sqlite3_aggregate_context() within the same aggregate function instance will not resize the memory allocation. Within the xFinal callback, it is customary to set N=0 in calls to sqlite3_aggregate_context(C,N) so that no pointless memory allocations occur.</source>
          <target state="translated">sqlite3_aggregate_context(C,N)によって割り当てられる空間の量は、最初の呼び出しに成功したときのNパラメータによって決定されます。同じ集約関数インスタンス内でsqlite3_aggregate_context()を呼び出す際にNの値を変更しても、メモリ割り当てのサイズは変更されません。xFinalコールバック内では、無意味なメモリ割り当てが発生しないように、sqlite3_aggregate_context(C,N)の呼び出しでN=0を設定するのが一般的です。</target>
        </trans-unit>
        <trans-unit id="3035b3f13a8c2eedd1a82b2e759ec82828d6061b" translate="yes" xml:space="preserve">
          <source>The amount of space allocated by sqlite3_aggregate_context(C,N) is determined by the N parameter on first successful call. Changing the value of N in subsequent call to sqlite3_aggregate_context() within the same aggregate function instance will not resize the memory allocation. Within the xFinal callback, it is customary to set N=0 in calls to sqlite3_aggregate_context(C,N) so that no pointless memory allocations occur.</source>
          <target state="translated">sqlite3_aggregate_context(C,N)によって割り当てられた領域の量は、最初の呼び出しに成功したときのNパラメータによって決定されます。同じ集約関数インスタンス内のsqlite3_aggregate_context()を呼び出す際にNの値を変更しても、メモリ割り当てのサイズは変更されません。xFinalコールバック内では、無意味なメモリ割り当てが発生しないように、sqlite3_aggregate_context(C,N)の呼び出しでN=0を設定するのが一般的です。</target>
        </trans-unit>
        <trans-unit id="48fa74a585edf255bca976e35bf58c2115a55266" translate="yes" xml:space="preserve">
          <source>The android performance numbers for the write experiments are omitted because the performance tests on the Galaxy S3 are so random. Two consecutive runs of the exact same experiment would give wildly different times. And, to be fair, the performance of SQLite on android is slightly slower than writing directly to disk.</source>
          <target state="translated">Galaxy S3での性能テストは非常にランダムなので、書き込み実験のandroidの性能数値は省略しています。全く同じ実験を2回連続して実行すると、全く異なる時間が出てきます。そして、公平に言うと、android上のSQLiteの性能は、ディスクに直接書き込むよりもわずかに遅い。</target>
        </trans-unit>
        <trans-unit id="ba25e29078b648c595b0c513af632a78976e2d1a" translate="yes" xml:space="preserve">
          <source>The application file is portable across all operating systems, 32-bit and 64-bit and big- and little-endian architectures.</source>
          <target state="translated">アプリケーションファイルは、32ビット、64ビット、ビッグエンディアン、リトルエンディアンのアーキテクチャを問わず、すべてのオペレーティングシステムで移植可能です。</target>
        </trans-unit>
        <trans-unit id="553858a0531981a9db580aff8d49f00f4db9f6bc" translate="yes" xml:space="preserve">
          <source>The application has made changes to the &lt;a href=&quot;fts3#*shadowtab&quot;&gt;FTS shadow tables&lt;/a&gt; directly, without using the FTS3/4 virtual table, causing the shadow tables to become out of sync with each other.</source>
          <target state="translated">アプリケーションがFTS3 / 4仮想テーブルを使用せずに&lt;a href=&quot;fts3#*shadowtab&quot;&gt;FTSシャドウテーブルに&lt;/a&gt;直接変更を加えたため、シャドウテーブルが互いに同期しなくなりました。</target>
        </trans-unit>
        <trans-unit id="744b17ec690883f96b76e631855849a6884a7431" translate="yes" xml:space="preserve">
          <source>The application must ensure that the 1st parameter to sqlite3_exec() is a valid and open &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">アプリケーションは、sqlite3_exec（）への最初のパラメーターが有効でオープンな&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続である&lt;/a&gt;ことを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="1a416f0180cf818dc5e0d104e2af8fd17ae77d32" translate="yes" xml:space="preserve">
          <source>The application must ensure that the 1st parameter to sqlite3_exec() is a valid and open &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">アプリケーションは、sqlite3_exec（）への最初のパラメーターが有効でオープンな&lt;a href=&quot;sqlite3&quot;&gt;データベース接続である&lt;/a&gt;ことを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="9dbea7596a56ecae7226dfed468f733b0ebf473a" translate="yes" xml:space="preserve">
          <source>The application must finalize every &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; in order to avoid resource leaks. It is a grievous error for the application to try to use a prepared statement after it has been finalized. Any use of a prepared statement after it has been finalized can result in undefined and undesirable behavior such as segfaults and heap corruption.</source>
          <target state="translated">アプリケーションは、リソースリークを回避するために、&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備され&lt;/a&gt;たすべてのステートメントを終了する必要があります。アプリケーションが準備されたステートメントを確定した後で使用しようとすると、重大なエラーになります。ファイナライズ後にプリペアドステートメントを使用すると、セグメンテーション違反やヒープの破損など、未定義の望ましくない動作が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="fb5d8c6646b2fcb9cbadc4a78abf91f82a6d7868" translate="yes" xml:space="preserve">
          <source>The application must finalize every &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; in order to avoid resource leaks. It is a grievous error for the application to try to use a prepared statement after it has been finalized. Any use of a prepared statement after it has been finalized can result in undefined and undesirable behavior such as segfaults and heap corruption.</source>
          <target state="translated">アプリケーションは、リソースリークを回避するために、&lt;a href=&quot;stmt&quot;&gt;準備され&lt;/a&gt;たすべてのステートメントを終了する必要があります。アプリケーションが準備されたステートメントを確定した後で使用しようとすると、重大なエラーになります。ファイナライズ後にプリペアドステートメントを使用すると、セグメンテーション違反やヒープの破損など、未定義の望ましくない動作が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="99cabfda3eb8aea847c63c772b815f9008f98dc6" translate="yes" xml:space="preserve">
          <source>The application must not close the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; specified by the 1st parameter to sqlite3_exec() while sqlite3_exec() is running.</source>
          <target state="translated">アプリケーションは、sqlite3_exec（）の実行中に、sqlite3_exec（）への第1パラメータで指定された&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続を&lt;/a&gt;閉じてはなりません。</target>
        </trans-unit>
        <trans-unit id="0e45e1c6c5dd0bb0af2de4709122fb9b7f5aa23a" translate="yes" xml:space="preserve">
          <source>The application must not close the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; specified by the 1st parameter to sqlite3_exec() while sqlite3_exec() is running.</source>
          <target state="translated">アプリケーションは、sqlite3_exec（）の実行中に、sqlite3_exec（）への第1パラメータで指定された&lt;a href=&quot;sqlite3&quot;&gt;データベース接続を&lt;/a&gt;閉じてはなりません。</target>
        </trans-unit>
        <trans-unit id="1ec93d570d3944810e00416d33fc158ef0b8df22" translate="yes" xml:space="preserve">
          <source>The application must not modify the SQL statement text passed into the 2nd parameter of sqlite3_exec() while sqlite3_exec() is running.</source>
          <target state="translated">アプリケーションは、sqlite3_exec()が実行されている間、sqlite3_exec()の2番目のパラメータに渡されたSQL文のテキストを変更してはいけません。</target>
        </trans-unit>
        <trans-unit id="dd08aa5c98a2b87e47c47375f85e57ce41e870bc" translate="yes" xml:space="preserve">
          <source>The application must not read or write any part of a block of memory after it has been released using &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt;.</source>
          <target state="translated">アプリケーションは、&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;または&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;を使用して解放された後、メモリブロックの一部を読み書きしないでください。</target>
        </trans-unit>
        <trans-unit id="04da8df88f025325ec4119082e7436a2ab79cfbf" translate="yes" xml:space="preserve">
          <source>The application must not read or write any part of a block of memory after it has been released using &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; or &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt;.</source>
          <target state="translated">アプリケーションは、&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;または&lt;a href=&quot;free&quot;&gt;sqlite3_realloc（）&lt;/a&gt;を使用して解放された後、メモリブロックの一部を読み書きしないでください。</target>
        </trans-unit>
        <trans-unit id="7136e470c61d513b5e2e7bb04278f687766f03e3" translate="yes" xml:space="preserve">
          <source>The application only has to load the data it needs, rather than reading the entire file and holding a complete parse in memory.</source>
          <target state="translated">アプリケーションは、ファイル全体を読み込んで完全なパースをメモリに保持するのではなく、必要なデータだけをロードする必要があります。</target>
        </trans-unit>
        <trans-unit id="e521cca41ad74c95daa61ed9901e7bb27bdf7838" translate="yes" xml:space="preserve">
          <source>The application should never invoke either sqlite3_os_init() or sqlite3_os_end() directly. The application should only invoke sqlite3_initialize() and sqlite3_shutdown(). The sqlite3_os_init() interface is called automatically by sqlite3_initialize() and sqlite3_os_end() is called by sqlite3_shutdown(). Appropriate implementations for sqlite3_os_init() and sqlite3_os_end() are built into SQLite when it is compiled for Unix, Windows, or OS/2. When &lt;a href=&quot;../custombuild&quot;&gt;built for other platforms&lt;/a&gt; (using the &lt;a href=&quot;../compile#os_other&quot;&gt;SQLITE_OS_OTHER=1&lt;/a&gt; compile-time option) the application must supply a suitable implementation for sqlite3_os_init() and sqlite3_os_end(). An application-supplied implementation of sqlite3_os_init() or sqlite3_os_end() must return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and some other &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; upon failure.</source>
          <target state="translated">アプリケーションでsqlite3_os_init（）またはsqlite3_os_end（）を直接呼び出さないでください。アプリケーションは、sqlite3_initialize（）およびsqlite3_shutdown（）のみを呼び出す必要があります。 sqlite3_os_init（）インターフェースはsqlite3_initialize（）によって自動的に呼び出され、sqlite3_os_end（）はsqlite3_shutdown（）によって呼び出されます。 sqlite3_os_init（）およびsqlite3_os_end（）の適切な実装は、Unix、Windows、またはOS / 2用にコンパイルされたときにSQLiteに組み込まれます。（&lt;a href=&quot;../compile#os_other&quot;&gt;SQLITE_OS_OTHER = 1&lt;/a&gt;コンパイル時オプションを使用&lt;a href=&quot;../custombuild&quot;&gt;して）他のプラットフォーム用にビルドする&lt;/a&gt;場合、アプリケーションはsqlite3_os_init（）およびsqlite3_os_end（）の適切な実装を提供する必要があります。アプリケーションが提供するsqlite3_os_init（）またはsqlite3_os_end（）の実装は、成功した場合は&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;を返し、その他の場合は&lt;a href=&quot;../rescode&quot;&gt;&lt;/a&gt;失敗時のエラーコード。</target>
        </trans-unit>
        <trans-unit id="5f9522c8f8708f8f795d05750d26ac94e862ee81" translate="yes" xml:space="preserve">
          <source>The application should never invoke either sqlite3_os_init() or sqlite3_os_end() directly. The application should only invoke sqlite3_initialize() and sqlite3_shutdown(). The sqlite3_os_init() interface is called automatically by sqlite3_initialize() and sqlite3_os_end() is called by sqlite3_shutdown(). Appropriate implementations for sqlite3_os_init() and sqlite3_os_end() are built into SQLite when it is compiled for Unix, Windows, or OS/2. When &lt;a href=&quot;custombuild&quot;&gt;built for other platforms&lt;/a&gt; (using the &lt;a href=&quot;compile#os_other&quot;&gt;SQLITE_OS_OTHER=1&lt;/a&gt; compile-time option) the application must supply a suitable implementation for sqlite3_os_init() and sqlite3_os_end(). An application-supplied implementation of sqlite3_os_init() or sqlite3_os_end() must return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success and some other &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; upon failure.</source>
          <target state="translated">アプリケーションでsqlite3_os_init（）またはsqlite3_os_end（）を直接呼び出さないでください。アプリケーションは、sqlite3_initialize（）およびsqlite3_shutdown（）のみを呼び出す必要があります。 sqlite3_os_init（）インターフェースはsqlite3_initialize（）によって自動的に呼び出され、sqlite3_os_end（）はsqlite3_shutdown（）によって呼び出されます。 sqlite3_os_init（）およびsqlite3_os_end（）の適切な実装は、Unix、Windows、またはOS / 2用にコンパイルされたときにSQLiteに組み込まれます。（&lt;a href=&quot;compile#os_other&quot;&gt;SQLITE_OS_OTHER = 1&lt;/a&gt;コンパイル時オプションを使用&lt;a href=&quot;custombuild&quot;&gt;して）他のプラットフォーム用にビルドする&lt;/a&gt;場合、アプリケーションはsqlite3_os_init（）およびsqlite3_os_end（）の適切な実装を提供する必要があります。アプリケーションが提供するsqlite3_os_init（）またはsqlite3_os_end（）の実装は、成功した場合は&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;を返し、その他の場合は&lt;a href=&quot;rescode&quot;&gt;&lt;/a&gt;失敗時のエラーコード。</target>
        </trans-unit>
        <trans-unit id="371b08e858c1c9c61f57bffa9ac30d2c2c9616ae" translate="yes" xml:space="preserve">
          <source>The application wants to prevent other processes from accessing the database file.</source>
          <target state="translated">このアプリケーションは、他のプロセスがデータベースファイルにアクセスするのを防ぎたいと考えています。</target>
        </trans-unit>
        <trans-unit id="da9edea5d79c9c534eb8f394ef49ec7d996e51c8" translate="yes" xml:space="preserve">
          <source>The application_id PRAGMA is used to query or set the 32-bit signed big-endian &quot;Application ID&quot; integer located at offset 68 into the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;. Applications that use SQLite as their &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt; should set the Application ID integer to a unique integer so that utilities such as &lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file(1)&lt;/a&gt; can determine the specific file type rather than just reporting &quot;SQLite3 Database&quot;. A list of assigned application IDs can be seen by consulting the &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=magic.txt&quot;&gt;magic.txt&lt;/a&gt; file in the SQLite source repository.</source>
          <target state="translated">application_id PRAGMAは、オフセット68にある32ビットの符号付きビッグエンディアン「アプリケーションID」整数を照会または&lt;a href=&quot;fileformat2#database_header&quot;&gt;データベースヘッダーに&lt;/a&gt;設定するために使用されます。アプリケーション&lt;a href=&quot;appfileformat&quot;&gt;ファイル形式&lt;/a&gt;としてSQLiteを使用するアプリケーションは、アプリケーションID整数を一意の整数に設定して、&lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file（1）&lt;/a&gt;などのユーティリティが単に「SQLite3データベース」を報告するのではなく、特定のファイルタイプを判別できるようにする必要があります。割り当てられたアプリケーションIDのリストは、SQLiteソースリポジトリの&lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=magic.txt&quot;&gt;magic.txt&lt;/a&gt;ファイルを参照することで確認できます。</target>
        </trans-unit>
        <trans-unit id="fbebe3f29ae821a203a540ede83fca7a51f6300e" translate="yes" xml:space="preserve">
          <source>The applications using this database are entitled to assume that for each row in the</source>
          <target state="translated">このデータベースを使用しているアプリケーションは</target>
        </trans-unit>
        <trans-unit id="c4abdec20da55bda36a7679394be4f500b633ccf" translate="yes" xml:space="preserve">
          <source>The argc parameter specifies the number of entries in the argv array. The value of argc will be 1 for a pure delete operation or N+2 for an insert or replace or update where N is the number of columns in the table. In the previous sentence, N includes any hidden columns.</source>
          <target state="translated">argcパラメータは、argv配列のエントリ数を指定します。argcの値は、純粋な削除操作の場合は1、挿入、置換、更新の場合はN+2となります。前の文では、Nには隠された列が含まれています。</target>
        </trans-unit>
        <trans-unit id="b66b85dc16bc6667c3624ba8e6f64b24df3ac149" translate="yes" xml:space="preserve">
          <source>The argument N is the maximum number of bytes of the database file that will be accessed using memory-mapped I/O. If N is zero then memory mapped I/O is disabled. If N is negative, then the limit reverts to the default value determined by the most recent &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;), or to the compile time default determined by &lt;a href=&quot;compile#default_mmap_size&quot;&gt;SQLITE_DEFAULT_MMAP_SIZE&lt;/a&gt; if not start-time limit has been set.</source>
          <target state="translated">引数Nは、メモリマップI / Oを使用してアクセスされるデータベースファイルの最大バイト数です。Nがゼロの場合、メモリマップI / Oは無効になります。Nが負の場合、制限は最新の&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;）によって決定されるデフォルト値に戻るか、開始時間制限が設定されていない場合は&lt;a href=&quot;compile#default_mmap_size&quot;&gt;SQLITE_DEFAULT_MMAP_SIZE&lt;/a&gt;によって決定されるコンパイル時のデフォルトに戻ります。</target>
        </trans-unit>
        <trans-unit id="ab61127b621c6e57d8aaaae340d80e94025b5867" translate="yes" xml:space="preserve">
          <source>The argument is a double which is displayed in decimal.</source>
          <target state="translated">引数には10進数で表示されるダブルを指定します。</target>
        </trans-unit>
        <trans-unit id="7c92aff7ca85efdc01cd4da9e4f23a18dad234e0" translate="yes" xml:space="preserve">
          <source>The argument is a double which is displayed in either normal decimal notation or if the exponent is not close to zero, in exponential notation.</source>
          <target state="translated">引数はdoubleで、通常の10進数表記で表示されるか、指数がゼロに近くない場合は指数表記で表示されます。</target>
        </trans-unit>
        <trans-unit id="2096ff23b8873f39597795db4f99b816ed776fc9" translate="yes" xml:space="preserve">
          <source>The argument is a double which is displayed in exponential notation. The exponent character is 'e' or 'E' depending on the type.</source>
          <target state="translated">引数には、指数表記で表示されるダブルを指定します。指数文字は型に応じて 'e' または 'E' です。</target>
        </trans-unit>
        <trans-unit id="11129b8da0d471f1bf24142ea87e57c0024e71a8" translate="yes" xml:space="preserve">
          <source>The argument is a pointer to an integer. Nothing is displayed for this substitution type. Instead, the integer to which the argument points is overwritten with the number of characters in the generated string that result from all format symbols to the left of the %n.</source>
          <target state="translated">引数は整数へのポインタです。この置換型では何も表示されません。代わりに、引数が指す整数は、%n の左にあるすべての書式記号の結果として生成された文字列の文字数で上書きされます。</target>
        </trans-unit>
        <trans-unit id="e6906c7030bdaf7b36a456360b0fbb4934d1a4ca" translate="yes" xml:space="preserve">
          <source>The argument is a pointer which is displayed as a hexadecimal address. Since the SQL language has no concept of a pointer, the %p substitution for the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt; works like %x.</source>
          <target state="translated">引数は、16進数のアドレスとして表示されるポインターです。SQL言語にはポインターの概念がないため、&lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf（）SQL関数&lt;/a&gt;の％p置換は％xのように機能します。</target>
        </trans-unit>
        <trans-unit id="e27c7fe9a83c9f08bcef3b205174fd7f4958e0c9" translate="yes" xml:space="preserve">
          <source>The argument is a signed integer which is displayed in decimal.</source>
          <target state="translated">引数は符号付き整数で、10進数で表示されます。</target>
        </trans-unit>
        <trans-unit id="9b566b967632a4d496722ab350e0797c5b50a8e6" translate="yes" xml:space="preserve">
          <source>The argument is a zero-terminated string that is displayed. For the %z type in C-language interfaces, &lt;a href=&quot;c3ref/free&quot; id=&quot;percentz&quot;&gt;sqlite3_free()&lt;/a&gt; is invoked on the string after it has be copied into the output. The %s and %z substitutions are identical for the SQL printf() function.</source>
          <target state="translated">引数は、表示されるゼロで終了する文字列です。C言語インターフェイスの％zタイプの場合、文字列が出力にコピーされた後、文字列に対して&lt;a href=&quot;c3ref/free&quot; id=&quot;percentz&quot;&gt;sqlite3_free（）&lt;/a&gt;が呼び出されます。％sと％zの置換は、SQLのprintf（）関数と同じです。</target>
        </trans-unit>
        <trans-unit id="fcbbea9fc49916ff3eab8108379983087fe602ea" translate="yes" xml:space="preserve">
          <source>The argument is a zero-terminated string. The string is printed with all single quote (') characters doubled so that the string can safely appear inside an SQL string literal. The %Q substitution type also puts single-quotes on both ends of the substituted string.</source>
          <target state="translated">引数はゼロ終端の文字列です。SQL 文字列リテラル内に文字列が安全に表示されるように、文字列はシングル・クォート (')文字をすべて 2 倍にして印刷されます。Q 置換型もまた、置換された文字列の両端にシングル引用符を付けます。</target>
        </trans-unit>
        <trans-unit id="f7cdf0497339bca82de3b36c80d3d61e29bc5c49" translate="yes" xml:space="preserve">
          <source>The argument is an integer which is displayed in hexadecimal. Lower-case hexadecimal is used for %x and upper-case is used for %X</source>
          <target state="translated">引数は、16 進数で表示される整数です。小文字の 16 進数が %x に、大文字の 16 進数が %X に使用されます。</target>
        </trans-unit>
        <trans-unit id="e8fcc09e116d95e79ec104c4fc555cc628b5c95b" translate="yes" xml:space="preserve">
          <source>The argument is an integer which is displayed in octal.</source>
          <target state="translated">引数は整数で、8進数で表示されます。</target>
        </trans-unit>
        <trans-unit id="544017bf0d02198d9d372e60ce173d51892cc644" translate="yes" xml:space="preserve">
          <source>The argument is an unsigned integer which is displayed in decimal.</source>
          <target state="translated">引数には10進数で表示される符号なし整数を指定します。</target>
        </trans-unit>
        <trans-unit id="5c161c084d3e3e79567bd33437dedcb35b7796bf" translate="yes" xml:space="preserve">
          <source>The argument is the symbolic name for the desired VFS. If the argument is a NULL pointer, then the default VFS is returned. The function returns a pointer to the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object that implements the VFS. Or it returns a NULL pointer if no object could be found that matched the search criteria.</source>
          <target state="translated">引数は、目的のVFSの記号名です。引数がNULLポインターの場合、デフォルトのVFSが返されます。この関数は、VFSを実装する&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトへのポインターを返します。または、検索条件に一致するオブジェクトが見つからなかった場合は、NULLポインターを返します。</target>
        </trans-unit>
        <trans-unit id="850af1642ffa208db124c3d32de875df305d3783" translate="yes" xml:space="preserve">
          <source>The argument to INTO can be a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; if URI filenames are enabled. URL filenames are enabled if any of the following are true:</source>
          <target state="translated">INTOへの引数は、&lt;a href=&quot;uri&quot;&gt;URIファイル&lt;/a&gt;名が有効な場合、URIファイル名にすることができます。次のいずれかに該当する場合、URLファイル名が有効になります。</target>
        </trans-unit>
        <trans-unit id="5b032a307670cabd16d781ba02c89e270db9d32d" translate="yes" xml:space="preserve">
          <source>The argument to the timeout method is the maximum number of milliseconds to wait for the lock to clear. So in the example above, the maximum delay would be 2 seconds.</source>
          <target state="translated">timeout メソッドの引数には、ロックがクリアされるまで待つ最大ミリ秒数を指定します。したがって、上の例では、最大遅延時間は 2 秒となります。</target>
        </trans-unit>
        <trans-unit id="6304247ca5d53ec4d2f27644451268a5fc4c44d5" translate="yes" xml:space="preserve">
          <source>The arguments passed to the &quot;tokenchars=&quot; or &quot;separators=&quot; options are case-sensitive. In the example above, specifying that &quot;X&quot; is a separator character does not affect the way &quot;x&quot; is handled.</source>
          <target state="translated">tokenchars=&quot; や &quot;separators=&quot; オプションに渡される引数は、大文字と小文字を区別します。上の例では、&quot;X&quot; がセパレータ文字であることを指定しても、&quot;x&quot; の扱いには影響しません。</target>
        </trans-unit>
        <trans-unit id="f42ca2142ac7440fc4af993ad46bce7740b98121" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;b&gt;sqlite_busy_handler&lt;/b&gt; are the opaque structure returned from &lt;b&gt;sqlite_open&lt;/b&gt;, a pointer to the busy callback function, and a generic pointer that will be passed as the first argument to the busy callback. When SQLite invokes the busy callback, it sends it three arguments: the generic pointer that was passed in as the third argument to &lt;b&gt;sqlite_busy_handler&lt;/b&gt;, the name of the database table or index that the library is trying to access, and the number of times that the library has attempted to access the database table or index.</source>
          <target state="translated">引数&lt;b&gt;sqlite_busy_handlerが&lt;/b&gt;から返された不透明な構造です&lt;b&gt;sqlite_open&lt;/b&gt;、忙しいコールバック関数へのポインタ、と忙しいコールバックへの最初の引数として渡される汎用ポインタ。SQLiteがビジーコールバックを呼び出すと、3つの引数が送信されます。3番目の引数として&lt;b&gt;sqlite_busy_handler&lt;/b&gt;に3番目の引数として渡されたジェネリックポインター、ライブラリがアクセスしようとしているデータベーステーブルまたはインデックスの名前、およびライブラリがデータベーステーブルまたはインデックスにアクセスしようとしました。</target>
        </trans-unit>
        <trans-unit id="6fa9f93d8e2b44eeb698d1ed1229d89e77acc71a" translate="yes" xml:space="preserve">
          <source>The argv[0] parameter is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of a row in the virtual table to be deleted. If argv[0] is an SQL NULL, then no deletion occurs.</source>
          <target state="translated">argv [0]パラメータは、削除される仮想テーブルの行の行&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ID&lt;/a&gt;です。argv [0]がSQL NULLの場合、削除は行われません。</target>
        </trans-unit>
        <trans-unit id="94f42e72810bd428d0a06485b57a23695591e88c" translate="yes" xml:space="preserve">
          <source>The argv[1] parameter is the rowid of a new row to be inserted into the virtual table. If argv[1] is an SQL NULL, then the implementation must choose a rowid for the newly inserted row. Subsequent argv[] entries contain values of the columns of the virtual table, in the order that the columns were declared. The number of columns will match the table declaration that the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method made using the &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; call. All hidden columns are included.</source>
          <target state="translated">argv [1]パラメータは、仮想テーブルに挿入される新しい行のROWIDです。argv [1]がSQL NULLの場合、実装は新しく挿入された行のROWIDを選択する必要があります。後続のargv []エントリには、仮想テーブルの列の値が、列が宣言された順序で含まれています。列の数は、&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;または&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;メソッドが&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab（）&lt;/a&gt;呼び出しを使用して作成したテーブル宣言と一致します。すべての非表示の列が含まれています。</target>
        </trans-unit>
        <trans-unit id="960c591f856ba7201455da5f944d6e4f1ebae33d" translate="yes" xml:space="preserve">
          <source>The arrows from the small circles labeled with &quot;*&quot; indicate the cost of running each loop with no dependencies. The outer loop must use this *-cost. Inner loops have the option of using the *-cost or a cost assuming one of the other terms is in an outer loop, whichever gives the best result. One can think of the *-costs as a short-hand notation indicating multiple arcs, one from each of the other nodes in the graph. The graph is therefore &quot;complete&quot;, meaning that there are arcs (some explicit and some implied) in both directions between every pair of nodes in the graph.</source>
          <target state="translated">と書かれた小さな丸からの矢印は、依存関係のない状態で各ループを実行するためのコストを示しています。外部ループはこの*コストを使用しなければなりません。内側のループでは、*-costを使うか、他の条件のいずれかが外側のループにあると仮定してコストを使うかの選択肢があり、どちらが最良の結果をもたらします。コストは、グラフ内の他のノードからの複数の円弧を示す短手の記法と考えることができます。したがって,グラフは「完全」であり,グラフ内の各ノードのペアの間に,両方向に円弧(いくつかの明示的なものと暗示的なもの)が存在することを意味します.</target>
        </trans-unit>
        <trans-unit id="d6a2923f627b3acd76aca2425895d68fa7fb43f5" translate="yes" xml:space="preserve">
          <source>The assert(X) macro is &lt;a href=&quot;https://en.wikipedia.org/wiki/Assert.h&quot;&gt;part of standard C&lt;/a&gt;, in the &amp;lt;assert.h&amp;gt; header file. SQLite adds three other assert()-like macros named NEVER(X), ALWAYS(X), and testcase(X).</source>
          <target state="translated">assert（X）マクロは、&amp;lt;assert.h&amp;gt;ヘッダーファイル内&lt;a href=&quot;https://en.wikipedia.org/wiki/Assert.h&quot;&gt;の標準Cの一部&lt;/a&gt;です。SQLiteは、NEVER（X）、ALWAYS（X）、およびtestcase（X）という名前の3つのassert（）のようなマクロを追加します。</target>
        </trans-unit>
        <trans-unit id="8da4f4835817f9b4a63cc18fb5421f7207d5d808" translate="yes" xml:space="preserve">
          <source>The asynchronous I/O VFS is registered (and unregistered) by calls to the API functions sqlite3async_initialize() and sqlite3async_shutdown(). See section &quot;Compilation and Usage&quot; below for details.</source>
          <target state="translated">非同期I/O VFSはAPI関数sqlite3async_initialize()とsqlite3async_shutdown()の呼び出しによって登録(および登録解除)されます。詳細は後述の「コンパイルと使用法」を参照してください。</target>
        </trans-unit>
        <trans-unit id="535287426332e5a1ad8bec16b3d83b02751661a5" translate="yes" xml:space="preserve">
          <source>The asynchronous IO VFS API is described in detail in comments in sqlite3async.h. Using the API usually consists of the following steps:</source>
          <target state="translated">非同期IO VFS APIの詳細はsqlite3async.hのコメントで説明されています。</target>
        </trans-unit>
        <trans-unit id="99f2292b58193481d23d957b96b6816c332c0bd5" translate="yes" xml:space="preserve">
          <source>The asynchronous IO extension consists of a single file of C code (sqlite3async.c), and a header file (sqlite3async.h), located in the &lt;a href=&quot;http://www.sqlite.org/src/dir?name=ext/async&quot;&gt; &lt;code&gt;ext/async/&lt;/code&gt; subfolder&lt;/a&gt; of the SQLite source tree, that defines the C API used by applications to activate and control the modules functionality.</source>
          <target state="translated">非同期IO拡張は、Cコードの単一のファイル（sqlite3async.c）と、SQLiteソースツリーの&lt;a href=&quot;http://www.sqlite.org/src/dir?name=ext/async&quot;&gt; &lt;code&gt;ext/async/&lt;/code&gt; &lt;/a&gt;サブフォルダーにあるヘッダーファイル（sqlite3async.h）で構成され、アプリケーションが使用するC APIを定義します。モジュールの機能をアクティブにして制御します。</target>
        </trans-unit>
        <trans-unit id="fa3d3b11288ba36989fe692263c29b42026caa0f" translate="yes" xml:space="preserve">
          <source>The asynchronous SQLite is just a shade slower than MySQL on this test. (MySQL seems to be especially adept at INSERT...SELECT statements.) The PostgreSQL engine is still thrashing - most of the 61 seconds it used were spent waiting on disk I/O.</source>
          <target state="translated">非同期SQLiteは、このテストではMySQLよりもわずかに遅くなっています。(MySQLはINSERT...SELECT文に特に秀でているようです。)PostgreSQLエンジンは未だに荒れ狂い続けています。</target>
        </trans-unit>
        <trans-unit id="09f0791bf3a9c39b17b6897fd1eef3b3d7a8e21f" translate="yes" xml:space="preserve">
          <source>The atomic commit mechanism in SQLite has proven to be robust, but it can be circumvented by a sufficiently creative adversary or a sufficiently broken operating system implementation. This section describes a few of the ways in which an SQLite database might be corrupted by a power failure or system crash. (See also: &lt;a href=&quot;howtocorrupt&quot;&gt;How To Corrupt Your Database Files&lt;/a&gt;.)</source>
          <target state="translated">SQLiteのアトミックコミットメカニズムは堅牢であることが証明されていますが、十分に創造的な敵または十分に壊れたオペレーティングシステムの実装によって回避できます。このセクションでは、電源障害またはシステムクラッシュによってSQLiteデータベースが破損する可能性があるいくつかの方法について説明します。（参照：&lt;a href=&quot;howtocorrupt&quot;&gt;データベースファイルを破損する方法&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="7497e373861cdeb1f861bd3cb7a15f476a8a4234" translate="yes" xml:space="preserve">
          <source>The author of Lemon and SQLite (Hipp) reports that his C programming skills were greatly enhanced by studying John Ousterhout's original source code to Tcl. Hipp discovered and studied Tcl in 1993. Lemon was written before then, and SQLite afterwards. There is a clear difference in the coding styles of these two products, with SQLite seeming to be cleaner, more readable, and easier to maintain.</source>
          <target state="translated">LemonとSQLiteの著者(Hipp)は、John OusterhoutのTclへのオリジナルソースコードを研究したことで、C言語のプログラミングスキルが大幅に向上したと報告しています。HippがTclを発見して研究したのは1993年のことです。Lemonはそれ以前に書かれたもので、SQLiteはその後に書かれたものです。この2つの製品のコーディングスタイルには明らかな違いがあり、SQLiteの方がよりクリーンで読みやすく、メンテナンスも容易になっているようです。</target>
        </trans-unit>
        <trans-unit id="b01615602e972abb3c5942edbe63b3d8efbfa2ac" translate="yes" xml:space="preserve">
          <source>The authority may be omitted, may be blank, or may be &quot;&lt;code&gt;localhost&lt;/code&gt;&quot;. Any other authority results in an error. Exception: If SQLite is compiled with &lt;a href=&quot;compile#allow_uri_authority&quot;&gt;SQLITE_ALLOW_URI_AUTHORITY&lt;/a&gt; then any authority value other than &quot;localhost&quot; is passed through to the underlying operating system as a UNC filename.</source>
          <target state="translated">権限は省略されたり、空白になったり、「 &lt;code&gt;localhost&lt;/code&gt; 」になったりします。その他の権限はエラーになります。例外：SQLiteが&lt;a href=&quot;compile#allow_uri_authority&quot;&gt;SQLITE_ALLOW_URI_AUTHORITY&lt;/a&gt;でコンパイルされている場合、 &quot;localhost&quot;以外の権限値はUNCファイル名として基本となるオペレーティングシステムに渡されます。</target>
        </trans-unit>
        <trans-unit id="939e9fe5172b44eee1c6df02720143adc80675d6" translate="yes" xml:space="preserve">
          <source>The authorizer callback must not do anything that will modify the database connection that invoked the authorizer callback. Note that &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">オーソライザーコールバックは、オーソライザーコールバックを呼び出したデータベース接続を変更するようなことをしてはなりません。&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;と&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）は&lt;/a&gt;どちらも、この段落の「変更」の意味でデータベース接続を変更することに注意してください。</target>
        </trans-unit>
        <trans-unit id="cd0b9544f8e0ba2efe9de0f3a90df70febb9c84b" translate="yes" xml:space="preserve">
          <source>The authorizer callback must not do anything that will modify the database connection that invoked the authorizer callback. Note that &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">オーソライザーコールバックは、オーソライザーコールバックを呼び出したデータベース接続を変更するようなことをしてはなりません。&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;と&lt;a href=&quot;step&quot;&gt;sqlite3_step（）は&lt;/a&gt;どちらも、この段落の「変更」の意味でデータベース接続を変更することに注意してください。</target>
        </trans-unit>
        <trans-unit id="861ac52bff28d8b37d00f46c9e8ab0bcdffeef17" translate="yes" xml:space="preserve">
          <source>The automatic indexing capability can be disabled at run-time using the &lt;a href=&quot;pragma#pragma_automatic_index&quot;&gt;automatic_index pragma&lt;/a&gt;. Automatic indexing is turned on by default, but this can be changed so that automatic indexing is off by default using the &lt;a href=&quot;compile#default_automatic_index&quot;&gt;SQLITE_DEFAULT_AUTOMATIC_INDEX&lt;/a&gt; compile-time option. The ability to create automatic indices can be completely disabled by compiling with the &lt;a href=&quot;compile#omit_automatic_index&quot;&gt;SQLITE_OMIT_AUTOMATIC_INDEX&lt;/a&gt; compile-time option.</source>
          <target state="translated">自動インデックス機能は、&lt;a href=&quot;pragma#pragma_automatic_index&quot;&gt;automatic_indexプラグマ&lt;/a&gt;を使用して、実行時に無効にすることができます。自動インデックス作成はデフォルトでオンになっていますが、&lt;a href=&quot;compile#default_automatic_index&quot;&gt;SQLITE_DEFAULT_AUTOMATIC_INDEX&lt;/a&gt;コンパイル時オプションを使用して自動インデックス作成がデフォルトでオフになるように変更できます。&lt;a href=&quot;compile#omit_automatic_index&quot;&gt;SQLITE_OMIT_AUTOMATIC_INDEX&lt;/a&gt;コンパイル時オプションを指定してコンパイルすると、自動インデックスを作成する機能を完全に無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="ea88f1175fb0f90865a8970907b5e05e253378e5" translate="yes" xml:space="preserve">
          <source>The avg() function returns the average value of all non-NULL</source>
          <target state="translated">avg()関数は、NULL ではないすべての</target>
        </trans-unit>
        <trans-unit id="c29cb183c63bdd561faeb944d923a238a65c8f1b" translate="yes" xml:space="preserve">
          <source>The b-tree algorithm provides key/data storage with unique and ordered keys on page-oriented storage devices. For background information on b-trees, see Knuth, &lt;u&gt;The Art Of Computer Programming&lt;/u&gt;, Volume 3 &quot;Sorting and Searching&quot;, pages 471-479. Two kinds of b-trees are used by SQLite. The algorithm that Knuth calls &quot;B*-Tree&quot; stores all data in the leaves of the tree. SQLite calls this variety of b-tree a &quot;table b-tree&quot;. The algorithm that Knuth calls simply &quot;B-Tree&quot; stores both the key and the data together in both leaves and in interior pages. In the SQLite implementation, the original B-Tree algorithm stores keys only, omitting the data entirely, and is called an &quot;index b-tree&quot;.</source>
          <target state="translated">bツリーアルゴリズムは、ページ指向のストレージデバイス上で、一意の順序付けられたキーをキー/データストレージに提供します。 Bツリーの背景情報については、Knuth、&lt;u&gt;The Art Of Computer Programming&lt;/u&gt;、Volume 3「Sorting and Searching」、471〜479ページを参照してください。 SQLiteは2種類のBツリーを使用します。 Knuthが「B * -Tree」と呼ぶアルゴリズムは、すべてのデータをツリーの葉に格納します。 SQLiteは、このさまざまなbツリーを「テーブルbツリー」と呼びます。 Knuthが単に「Bツリー」と呼ぶアルゴリズムは、キーとデータの両方をリーフと内部ページの両方に格納します。 SQLite実装では、元のBツリーアルゴリズムはキーのみを格納し、データを完全に省略します。これは「インデックスbツリー」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="d112311c7e2ccc4f400060b3e5337023ffd30dd4" translate="yes" xml:space="preserve">
          <source>The b-tree algorithm provides key/data storage with unique and ordered keys on page-oriented storage devices. For background information on b-trees, see Knuth, &lt;u&gt;The Art Of Computer Programming&lt;/u&gt;, Volume 3 &quot;Sorting and Searching&quot;, pages 471-479. Two variants of b-trees are used by SQLite. &quot;Table b-trees&quot; use a 64-bit signed integer key and store all data in the leaves. &quot;Index b-trees&quot; use arbitrary keys and store no data at all.</source>
          <target state="translated">b-treeアルゴリズムは、ページ指向のストレージデバイス上で一意の順序付けられたキーを使用してキー/データストレージを提供します。Bツリーの背景情報については、Knuth、&lt;u&gt;The Art Of Computer Programming&lt;/u&gt;、第3巻「Sortingand Searching」、471〜479ページを参照してください。SQLiteではbツリーの2つのバリアントが使用されます。「テーブルBツリー」は64ビットの符号付き整数キーを使用し、すべてのデータをリーフに格納します。「インデックスbツリー」は任意のキーを使用し、データをまったく保存しません。</target>
        </trans-unit>
        <trans-unit id="bb8fb65a49101b4953ed3553fa6d2836b2742f88" translate="yes" xml:space="preserve">
          <source>The b-tree page header is 8 bytes in size for leaf pages and 12 bytes for interior pages. All multibyte values in the page header are big-endian. The b-tree page header is composed of the following fields:</source>
          <target state="translated">b-treeページヘッダのサイズは、リーフページでは8バイト、内部ページでは12バイトです。ページヘッダ内のすべてのマルチバイト値はビッグエンディアンです。b-treeページヘッダは以下のフィールドで構成されています。</target>
        </trans-unit>
        <trans-unit id="b3cbe5b0fd4215124588bcf352c662cc2398e510" translate="yes" xml:space="preserve">
          <source>The backup API copies the content of one database into another. It is useful either for creating backups of databases or for copying in-memory databases to or from persistent files.</source>
          <target state="translated">backup APIは、あるデータベースの内容を別のデータベースにコピーします。これは、データベースのバックアップを作成したり、インメモリデータベースを永続ファイルにコピーしたり、永続ファイルからコピーしたりするのに便利です。</target>
        </trans-unit>
        <trans-unit id="2cf1eb05a922a766ec8d7dd18ed7d6f4aa38bd5f" translate="yes" xml:space="preserve">
          <source>The backupDb() function uses the sqlite3_backup_remaining() and sqlite3_backup_pagecount() functions to report its progress via the user-supplied xProgress() callback. Function sqlite3_backup_remaining() returns the number of pages left to copy and sqlite3_backup_pagecount() returns the total number of pages in the source database (in this case the database opened by pDb). So the percentage completion of the process may be calculated as:</source>
          <target state="translated">backupDb()関数は、sqlite3_backup_remaining()関数とsqlite3_backup_pagecount()関数を使用して、ユーザが提供するxProgress()コールバックで進捗状況を報告します。関数sqlite3_backup_remaining()はコピーに残っているページ数を返し、sqlite3_backup_pagecount()はコピー元のデータベース(この場合はpDbによって開かれたデータベース)の総ページ数を返します。そのため、処理の完了率は次のように計算されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="6b553d2761ee3fe64acd25548c40d0f8e4d42c23" translate="yes" xml:space="preserve">
          <source>The base window may not specify a frame specification. The frame specification can only be given in the new window specification.</source>
          <target state="translated">ベースウィンドウでは、フレーム指定を指定しないことができます。フレーム指定は、新しいウィンドウの指定でのみ与えることができます。</target>
        </trans-unit>
        <trans-unit id="5c2a91b9a2da4a8d6526f62c2bd849ce606c97d4" translate="yes" xml:space="preserve">
          <source>The basic algorithm for computing the content of the recursive table is as follows:</source>
          <target state="translated">再帰表の内容を計算するための基本的なアルゴリズムは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="cc257445d9ceee252762e517b278c85329543c96" translate="yes" xml:space="preserve">
          <source>The basic principals described above apply to both ordinary rowid tables and &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. The only difference is that the rowid column that serves as the key for tables and that appears as the right-most term in indexes is replaced by the PRIMARY KEY.</source>
          <target state="translated">上記の基本原則は、通常のROWIDテーブルと&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルの両方に適用されます。唯一の違いは、テーブルのキーとして機能し、インデックスの右端の用語として表示されるROWID列がPRIMARY KEYに置き換えられていることです。</target>
        </trans-unit>
        <trans-unit id="07bf749b7aaedba2ca3c53251a2ebc2903cbff5d" translate="yes" xml:space="preserve">
          <source>The basic procedure above may modified by the following additional rules:</source>
          <target state="translated">上記の基本的な手順は、以下の追加ルールによって変更することができます。</target>
        </trans-unit>
        <trans-unit id="5580fafc283a76d74ea47e0554226ba42ea5bc40" translate="yes" xml:space="preserve">
          <source>The behavior implemented by the AUTOINCREMENT keyword is subtly different from the default behavior. With AUTOINCREMENT, rows with automatically selected ROWIDs are guaranteed to have ROWIDs that have never been used before by the same table in the same database. And the automatically generated ROWIDs are guaranteed to be monotonically increasing. These are important properties in certain applications. But if your application does not need these properties, you should probably stay with the default behavior since the use of AUTOINCREMENT requires additional work to be done as each row is inserted and thus causes INSERTs to run a little slower.</source>
          <target state="translated">AUTOINCREMENT キーワードによって実装される動作は、既定の動作とは微妙に異なります。AUTOINCREMENT を使用すると、自動的に選択された ROWID を持つ行は、同じデータベース内の同じテーブルで以前に使用されたことのない ROWID を持つことが保証されます。そして、自動的に生成されたROWIDは、単調に増加することが保証されています。これらは特定のアプリケーションでは重要な特性です。しかし、アプリケーションがこれらのプロパティを必要としない場合は、デフォルトの動作のままにしておくべきでしょう。なぜなら、AUTOINCREMENTを使用すると、各行が挿入されるたびに追加の作業が必要となり、INSERTの実行が少し遅くなるからです。</target>
        </trans-unit>
        <trans-unit id="53ddd9ac28fbcaf8f2c3233a5b531ac7ced77a80" translate="yes" xml:space="preserve">
          <source>The behavior of cache_size with a negative N was different prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;version 3.7.10&lt;/a&gt; (2012-01-16). In earlier versions, the number of pages in the cache was set to the absolute value of N.</source>
          <target state="translated">負のNを持つcache_sizeの動作は、&lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;バージョン3.7.10&lt;/a&gt;（2012-01-16）より前では異なりました。以前のバージョンでは、キャッシュ内のページ数はNの絶対値に設定されていました。</target>
        </trans-unit>
        <trans-unit id="478ce327d17671071ecdc539934c95e63faeda7c" translate="yes" xml:space="preserve">
          <source>The behavior of sqlite3changeset_apply_v2() and its streaming equivalent may be modified by passing a combination of &lt;a href=&quot;#SQLITE_CHANGESETAPPLY_INVERT&quot;&gt;supported flags&lt;/a&gt; as the 9th parameter.</source>
          <target state="translated">sqlite3changeset_apply_v2（）とそれに相当するストリーミングの動作は、&lt;a href=&quot;#SQLITE_CHANGESETAPPLY_INVERT&quot;&gt;サポート&lt;/a&gt;されているフラグの組み合わせを9番目のパラメーターとして渡すことで変更できます。</target>
        </trans-unit>
        <trans-unit id="6e75893c7d343c6a289f5aa0da4c1e36a51499e7" translate="yes" xml:space="preserve">
          <source>The behavior of sqlite3changeset_apply_v2() and its streaming equivalent may be modified by passing a combination of &lt;a href=&quot;c_changesetapply_invert&quot;&gt;supported flags&lt;/a&gt; as the 9th parameter.</source>
          <target state="translated">sqlite3changeset_apply_v2（）とそれに相当するストリーミングの動作は、&lt;a href=&quot;c_changesetapply_invert&quot;&gt;サポート&lt;/a&gt;されているフラグの組み合わせを9番目のパラメーターとして渡すことで変更できます。</target>
        </trans-unit>
        <trans-unit id="3b226ef505264d45ed6c9760d30054930a97eb46" translate="yes" xml:space="preserve">
          <source>The behavior of sqlite3changeset_start_v2() and its streaming equivalent may be modified by passing a combination of &lt;a href=&quot;#SQLITE_CHANGESETSTART_INVERT&quot;&gt;supported flags&lt;/a&gt; as the 4th parameter.</source>
          <target state="translated">sqlite3changeset_start_v2（）とそれに相当するストリーミングの動作は、&lt;a href=&quot;#SQLITE_CHANGESETSTART_INVERT&quot;&gt;サポート&lt;/a&gt;されているフラグの組み合わせを4番目のパラメーターとして渡すことで変更できます。</target>
        </trans-unit>
        <trans-unit id="462fed9af71f32884c9943463dae76b5706b0104" translate="yes" xml:space="preserve">
          <source>The behavior of sqlite3changeset_start_v2() and its streaming equivalent may be modified by passing a combination of &lt;a href=&quot;c_changesetstart_invert&quot;&gt;supported flags&lt;/a&gt; as the 4th parameter.</source>
          <target state="translated">sqlite3changeset_start_v2（）とそれに相当するストリーミングの動作は、&lt;a href=&quot;c_changesetstart_invert&quot;&gt;サポート&lt;/a&gt;されているフラグの組み合わせを4番目のパラメーターとして渡すことで変更できます。</target>
        </trans-unit>
        <trans-unit id="0cd600a43e57a68ed3c7e61e8926b28cfcf03236" translate="yes" xml:space="preserve">
          <source>The behaviour described above may be modified slightly by using the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted&lt;/a&gt; pragma to change the isolation level from serialized (the default), to read-uncommitted.</source>
          <target state="translated">上記の動作は、&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted&lt;/a&gt;プラグマを使用して分離レベルをシリアル化（デフォルト）から読み取り非コミットに変更することにより、わずかに変更できます。</target>
        </trans-unit>
        <trans-unit id="d91219df791273fdd065b20fbe3a1ddef8cd79ad" translate="yes" xml:space="preserve">
          <source>The behaviour of queries when a column-filter is specified both as part of the FTS query and by using a column as the LHS of a MATCH operator is slightly different. For a table with columns &quot;a&quot; and &quot;b&quot; and a query similar to:</source>
          <target state="translated">FTS クエリの一部としてカラムフィルタが指定されている場合と、MATCH 演算子の LHS としてカラムを使用している場合のクエリの挙動は若干異なります。カラム &quot;a&quot; と &quot;b&quot; を持つテーブルと、似たようなクエリの場合。</target>
        </trans-unit>
        <trans-unit id="1b74d0e5579c64699d464837588df4c3744c10fa" translate="yes" xml:space="preserve">
          <source>The best approach to make reliable backup copies of an SQLite database is to make use of the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt; that is part of the SQLite library. Failing that, it is safe to make a copy of an SQLite database file as long as there are no transactions in progress by any process. If the previous transaction failed, then it is important that any rollback journal (the &lt;code&gt;*-journal&lt;/code&gt; file) or write-ahead log (the &lt;code&gt;*-wal&lt;/code&gt; file) be copied together with the database file itself.</source>
          <target state="translated">SQLiteデータベースの信頼できるバックアップコピーを作成する最善の方法は、SQLiteライブラリの一部である&lt;a href=&quot;backup&quot;&gt;バックアップAPI&lt;/a&gt;を利用することです。失敗した場合は、プロセスによって進行中のトランザクションがない限り、SQLiteデータベースファイルのコピーを作成しても安全です。前のトランザクションが失敗した場合は、ロールバックジャーナル（ &lt;code&gt;*-journal&lt;/code&gt; ファイル）または先読みログ（ &lt;code&gt;*-wal&lt;/code&gt; ファイル）をデータベースファイル自体と一緒にコピーすることが重要です。</target>
        </trans-unit>
        <trans-unit id="3e4c95bce459286798ea2a27bd9ecd8decb1253c" translate="yes" xml:space="preserve">
          <source>The best feature of SQL (in &lt;u&gt;all&lt;/u&gt; its implementations, not just SQLite) is that it is a</source>
          <target state="translated">SQLの最良の機能（SQLiteだけでなく、その&lt;u&gt;すべての&lt;/u&gt;実装において）は、</target>
        </trans-unit>
        <trans-unit id="dc958ef4fbaadd7154585494d4a1f0d8657cd355" translate="yes" xml:space="preserve">
          <source>The block above uses a shorthand form to create the foreign key constraint. Attaching a &quot;REFERENCES</source>
          <target state="translated">上のブロックでは、短縮形を使って外部キー制約を作成しています。REFERENCES」を添付する</target>
        </trans-unit>
        <trans-unit id="be5a6e82c647cd58e78eb343df366b2a12164999" translate="yes" xml:space="preserve">
          <source>The blockid that corresponds to the leaf node with the largest blockid that belongs to this segment b-tree. Or zero if the entire segment b-tree fits on the root node.</source>
          <target state="translated">このセグメント b-tree に属する最大の blockid を持つリーフノードに対応する blockid。または、セグメント b-tree 全体がルートノードに収まる場合はゼロ。</target>
        </trans-unit>
        <trans-unit id="8114ba8fdc8ebfe0e7461c055a0e2fd44faa8a98" translate="yes" xml:space="preserve">
          <source>The blockid that corresponds to the node with the smallest blockid that belongs to this segment b-tree. Or zero if the entire segment b-tree fits on the root node. If it exists, this node is always a leaf node.</source>
          <target state="translated">このセグメント b-tree に属する最小のブロック ID を持つノードに対応するブロック ID。または、セグメント b-tree 全体がルートノードに収まる場合はゼロ。存在する場合、このノードは常にリーフノードです。</target>
        </trans-unit>
        <trans-unit id="f9a2b7b8a28aace68acd7dc6116c16ed08d188be" translate="yes" xml:space="preserve">
          <source>The boolean identifiers TRUE and FALSE are usually just aliases for the integer values 1 and 0, respectively. However, if TRUE or FALSE occur on the right-hand side of an IS operator, then they form new unary postfix operators &quot;IS TRUE&quot; and &quot;IS FALSE&quot; which test the boolean value of the operand on the left.</source>
          <target state="translated">真偽値識別子TRUEとFALSEは、通常、それぞれ整数値1と0のエイリアスです。しかし、TRUEやFALSEがIS演算子の右辺にある場合、これらは新しい単項演算子 &quot;IS TRUE &quot;と &quot;IS FALSE &quot;を形成し、左辺のオペランドのブール値をテストします。</target>
        </trans-unit>
        <trans-unit id="cab234605422320bfe969b5533e06293770750e7" translate="yes" xml:space="preserve">
          <source>The boundary between a file format and an application format is fuzzy. This article calls JPEG a file format, but for an image editor, JPEG might be considered the application format. Much depends on context. For this article, let us say that a file format stores a single object and an application format stores many different objects and their relationships to one another.</source>
          <target state="translated">ファイルフォーマットとアプリケーションフォーマットの境界は曖昧です。この記事では JPEG をファイルフォーマットと呼んでいますが、画像編集者にとっては JPEG がアプリケーションフォーマットとみなされるかもしれません。多くは文脈に依存します。この記事では、ファイルフォーマットは単一のオブジェクトを格納し、アプリケーションフォーマットは多くの異なるオブジェクトとその関係を格納しているとします。</target>
        </trans-unit>
        <trans-unit id="47707c3fbd653507bcb6765a57019dc2e9df3e77" translate="yes" xml:space="preserve">
          <source>The boundary description &quot;0 PRECEDING&quot; always means the same thing as &quot;CURRENT ROW&quot;.</source>
          <target state="translated">境界の記述「0 PRECEDING」は、常に「CURRENT ROW」と同じ意味です。</target>
        </trans-unit>
        <trans-unit id="65e8d52b8ac553953a11325088115a059c247d93" translate="yes" xml:space="preserve">
          <source>The build process makes extensive use of the &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;Tcl&lt;/a&gt; scripting language. You will need to have a copy of TCL installed in order for the make targets above to work. Easy-to-use installers can be obtained from &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;http://www.tcl-lang.org/&lt;/a&gt;. Many unix workstations have Tcl installed by default.</source>
          <target state="translated">ビルドプロセスでは、&lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;Tcl&lt;/a&gt;スクリプト言語を幅広く使用します。上記のmakeターゲットを機能させるには、TCLのコピーをインストールする必要があります。使いやすいインストーラーは、&lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;http：//www.tcl-lang.org/&lt;/a&gt;から入手できます。多くのUNIXワークステーションには、デフォルトでTclがインストールされています。</target>
        </trans-unit>
        <trans-unit id="7d4e60a19016fc83307d1ede2e1aa59927cbae39" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;lang_corefunc#iif&quot;&gt;iif(x,y,z) SQL function&lt;/a&gt; is logically equivalent to &quot;CASE WHEN x THEN y ELSE z END&quot;. The iif() function is found in SQL Server and is included in SQLite for compatibility. Some developers prefer the iif() function because it is more concise.</source>
          <target state="translated">組み込みの&lt;a href=&quot;lang_corefunc#iif&quot;&gt;iif（x、y、z）SQL関数&lt;/a&gt;は、論理的には「CASE WHEN x THEN y ELSEzEND」と同等です。 iif（）関数はSQL Serverにあり、互換性のためにSQLiteに含まれています。一部の開発者は、より簡潔であるため、iif（）関数を好みます。</target>
        </trans-unit>
        <trans-unit id="2c9c97359a7945f825df70e8e7d3bf03b435fc83" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; have been enhanced so that they can be used in &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;, in &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;, and in the WHERE clauses of &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;, provided that they do not use the 'now', 'localtime', or 'utc' keywords. &lt;a href=&quot;deterministic#dtexception&quot;&gt;More information&lt;/a&gt;.</source>
          <target state="translated">組み込みの&lt;a href=&quot;lang_datefunc&quot;&gt;日付および時刻関数&lt;/a&gt;が拡張され、&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK制約&lt;/a&gt;、&lt;a href=&quot;expridx&quot;&gt;式のインデックス&lt;/a&gt;、および&lt;a href=&quot;partialindex&quot;&gt;部分インデックスの&lt;/a&gt; WHERE句で使用できるようになりました。ただし、 'now'、 'localtime'を使用しない場合、または「utc」キーワード。&lt;a href=&quot;deterministic#dtexception&quot;&gt;さらなる情報&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8a2f201a6d744f00508ed72b40ed46b5c83f60f1" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; of SQLite are a special case. These functions are usually considered deterministic. However, if these functions use the string &quot;now&quot; as the date, or if they use the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime modifier&lt;/a&gt; or the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;utc modifier&lt;/a&gt;, then they are considered non-deterministic. Because the function inputs are not necessarily known until run-time, the date/time functions will throw an exception if they encounter any of the non-deterministic features in a context where only deterministic functions are allowed.</source>
          <target state="translated">SQLiteの組み込みの&lt;a href=&quot;lang_datefunc&quot;&gt;日付と時刻の関数&lt;/a&gt;は特殊なケースです。これらの関数は通常、決定論的と見なされます。ただし、これらの関数が文字列「now」を日付として使用する場合、または&lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime修飾子&lt;/a&gt;または&lt;a href=&quot;lang_datefunc#localtime&quot;&gt;utc修飾子&lt;/a&gt;を使用する場合、それらは非決定論的であると見なされます。関数入力は実行時まで必ずしも既知ではないため、日付/時刻関数は、決定論的関数のみが許可されているコンテキストで非決定論的機能のいずれかに遭遇した場合、例外をスローします。</target>
        </trans-unit>
        <trans-unit id="96663fb71968ae34b1131b3cb53ad7ba03319209" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; of SQLite are a special case. These functions are usually considered deterministic. However, if these functions use the string &quot;now&quot; as the date, or if they use the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime modifier&lt;/a&gt; or the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;utc modifier&lt;/a&gt;, then they are considered non-deterministic. Because the function inputs are not necessarily known until run-time, the date/time functions will throw an exception if they encounter any of the non-deterministic features in a context where only deterministic functions are allows.</source>
          <target state="translated">SQLite の組み込みの&lt;a href=&quot;lang_datefunc&quot;&gt;日付と時刻関数&lt;/a&gt;は特殊なケースです。これらの関数は通常、確定的と見なされます。ただし、これらの関数が日付として「now」という文字列を使用する場合、または&lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime修飾子&lt;/a&gt;または&lt;a href=&quot;lang_datefunc#localtime&quot;&gt;utc修飾子&lt;/a&gt;を使用する場合、これらは非決定的と見なされます。関数の入力は実行時まで必ずしもわかっていないため、日付/時刻関数は、決定論的関数のみが許可されているコンテキストで非決定論的機能に遭遇すると例外をスローします。</target>
        </trans-unit>
        <trans-unit id="adf744ca87e6c1a5f3b9a68b24961edea60809eb" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; of SQLite understand date/times in all of the formats above, and can freely change between them. Which format you use, is entirely up to your application.</source>
          <target state="translated">SQLite の組み込みの&lt;a href=&quot;lang_datefunc&quot;&gt;日付と時刻関数&lt;/a&gt;は、上記のすべての形式の日付と時刻を理解し、それらの間で自由に変更できます。どちらの形式を使用するかは、完全にアプリケーション次第です。</target>
        </trans-unit>
        <trans-unit id="8a5b38222ac4fb96f9a2b189215735dd804f8b2d" translate="yes" xml:space="preserve">
          <source>The built-in BINARY collation compares strings byte by byte using the memcmp() function from the standard C library.</source>
          <target state="translated">ビルトインのBINARY照合は、標準Cライブラリのmemcmp()関数を使って文字列をバイト単位で比較します。</target>
        </trans-unit>
        <trans-unit id="1b9d8615812e1b5dddaadf330db3704ed6104526" translate="yes" xml:space="preserve">
          <source>The built-in SQLite has compile-time options such as SQLITE_PRINTF_PRECISION_LIMIT that provide defense against denial-of-service attacks for application that expose the printf() functionality to untrusted users.</source>
          <target state="translated">組み込みの SQLite には、信頼されていないユーザに printf()の機能を公開するアプリケーションに対するサービス拒否攻撃に対する防御を提供する SQLITE_PRINTF_PRECISION_LIMIT のようなコンパイル時オプションがあります。</target>
        </trans-unit>
        <trans-unit id="55ca16581ef8177476edac12f1cd562f40820547" translate="yes" xml:space="preserve">
          <source>The built-in Wagner edit-distance function with fixed weights can be replaced by the &lt;a href=&quot;spellfix1#editdist3&quot;&gt;editdist3()&lt;/a&gt; edit-distance function with application-defined weights and support for unicode, by specifying the &quot;edit_cost_table=</source>
          <target state="translated">&quot;edit_cost_table =&quot;を指定することで、重みが固定された組み込みのWagner編集距離関数を、アプリケーションで定義された重みとUnicodeをサポートする&lt;a href=&quot;spellfix1#editdist3&quot;&gt;editdist3（）&lt;/a&gt;編集距離関数で置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="919d1860b9bd16d4532d25388f1ffc8375baa209" translate="yes" xml:space="preserve">
          <source>The built-in auxiliary function bm25() returns a real value indicating how well the current row matches the full-text query. The better the match, the numerically smaller the value returned. A query such as the following may be used to return matches in order from best to worst match:</source>
          <target state="translated">組み込みの補助関数 bm25()は、現在の行がフルテキストクエリにどれだけマッチしているかを示す実数を返します。マッチが良ければ良いほど、返される値は数値的に小さくなります。以下のようなクエリを使用して、マッチしたものを最良のものから最悪のものまで順に返すことができます。</target>
        </trans-unit>
        <trans-unit id="89afdc49975b5af95582dcbca838ad26684b8aa6" translate="yes" xml:space="preserve">
          <source>The built-in auxiliary functions provided as part of FTS5 are described in the following section. Applications may also implement &lt;a href=&quot;fts5#custom_auxiliary_functions&quot;&gt;custom auxiliary functions in C&lt;/a&gt;.</source>
          <target state="translated">FTS5の一部として提供される組み込みの補助機能については、次のセクションで説明します。アプリケーションは&lt;a href=&quot;fts5#custom_auxiliary_functions&quot;&gt;、Cにカスタム補助関数を&lt;/a&gt;実装することもできます。</target>
        </trans-unit>
        <trans-unit id="9249ce5cc7f5a31c9f40d1d2aedadc1d6c797929" translate="yes" xml:space="preserve">
          <source>The built-in functions used to implement LIKE and GLOB must not have been overloaded using the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; API.</source>
          <target state="translated">LIKEおよびGLOBの実装に使用される組み込み関数は、&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt; API を使用してオーバーロードされていない必要があります。</target>
        </trans-unit>
        <trans-unit id="49a23aa1a5c2e20f2c3c4ac966e9783cdfed04b2" translate="yes" xml:space="preserve">
          <source>The built-in memory allocators in SQLite also provide the following additional interfaces:</source>
          <target state="translated">SQLite の組み込みメモリアロケータには、以下の追加インターフェースも用意されています。</target>
        </trans-unit>
        <trans-unit id="4fa083c0cbf6940d57170ea9aa2f51d37713e7a7" translate="yes" xml:space="preserve">
          <source>The built-in min() and max() functions now honor the difference between NUMERIC and TEXT datatypes. Formerly, min() and max() always assumed their arguments were of type NUMERIC.</source>
          <target state="translated">組み込みの min()および max()関数は、NUMERIC と TEXT のデータ型の違いに対応するようになりました。以前は、min()および max()は常に引数の型が NUMERIC 型であることを前提としていました。</target>
        </trans-unit>
        <trans-unit id="09829581870ec4ebe1c207006b15fd18f63554a5" translate="yes" xml:space="preserve">
          <source>The built-in printf() implementation does not handle posix positional referencing modifiers that allow the order of arguments to printf() to be different from the order of the %-substitutions. In the built-in printf(), the order of the arguments must exactly match the order of the %-substitutions.</source>
          <target state="translated">組み込みの printf()実装では、printf()への引数の順序が %-置換の順序と異なることを可能にする posix 位置参照修飾子は処理されません。組み込みの printf()では、引数の順序は %-置換の順序と正確に一致しなければなりません。</target>
        </trans-unit>
        <trans-unit id="e86ab3d5db7f0615044de9985403c55275e95eaf" translate="yes" xml:space="preserve">
          <source>The built-in printf() implementation uses extra code space (about 7800 bytes on GCC 5.4 with -Os).</source>
          <target state="translated">組み込みの printf()の実装は、余分なコードスペースを使用します (GCC 5.4 で -Os を使用した場合は約 7800 バイト)。</target>
        </trans-unit>
        <trans-unit id="68470e8ed26cf7ace0d2e09f00b9eab48903fc0b" translate="yes" xml:space="preserve">
          <source>The built-in tokenizers and auxiliary functions described in this document are all implemented using the publicly available API described below.</source>
          <target state="translated">このドキュメントで説明されているビルトイントークナイザと補助関数は、以下に説明されている一般に公開されているAPIを使用して実装されています。</target>
        </trans-unit>
        <trans-unit id="9fc396222878f092f3ee1e16fde31353451d89d0" translate="yes" xml:space="preserve">
          <source>The busy callback should not take any actions which modify the database connection that invoked the busy handler. In other words, the busy handler is not reentrant. Any such actions result in undefined behavior.</source>
          <target state="translated">busyコールバックは、ビジーハンドラを呼び出したデータベース接続を変更するようなアクションを取るべきではありません。言い換えれば、ビジーハンドラはリエントラントではありません。そのようなアクションは、未定義の動作になります。</target>
        </trans-unit>
        <trans-unit id="f4f573b1a486bc41f01b46a6d80d9ecec47641b0" translate="yes" xml:space="preserve">
          <source>The byte offset of the matching term within the column.</source>
          <target state="translated">列内の一致するタームのバイトオフセット。</target>
        </trans-unit>
        <trans-unit id="05f015bc1e7204efce9fc81ea976f5bbb81740a9" translate="yes" xml:space="preserve">
          <source>The byte-order of UTF16 input text is determined by the byte-order mark (BOM, U+FEFF) found in first character, which is removed, or in the absence of a BOM the byte order is the native byte order of the host machine for sqlite3_bind_text16() or the byte order specified in the 6th parameter for sqlite3_bind_text64(). If UTF16 input text contains invalid unicode characters, then SQLite might change those invalid characters into the unicode replacement character: U+FFFD.</source>
          <target state="translated">UTF16入力テキストのバイト順は、最初の文字にあるバイト順マーク(BOM,U+FEFF)によって決定され、それが削除されます。BOMがない場合、バイト順はsqlite3_bind_text16()ではホストマシンのネイティブバイト順、sqlite3_bind_text64()では6番目のパラメータで指定されたバイト順になります。UTF16入力テキストに無効なunicode文字が含まれている場合、SQLiteはその無効な文字をunicode置換文字に変更するかもしれません。U+FFFDに変更されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="dbb76aa2fa15c5bd4f4468b266b4d77ab34c0a75" translate="yes" xml:space="preserve">
          <source>The bytecode engine begins execution on instruction number 0. Execution continues until a &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; instruction is seen, or until the program counter becomes greater than the address of last instruction, or until there is an error. When the bytecode engine halts, all memory that it allocated is released and all database cursors it may have had open are closed. If the execution stopped due to an error, any pending transactions are terminated and changes made to the database are rolled back.</source>
          <target state="translated">バイトコードエンジンは、命令番号0で実行を開始します。実行は、&lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt;命令が見つかるまで、またはプログラムカウンターが最後の命令のアドレスよりも大きくなるまで、またはエラーが発生するまで続きます。バイトコードエンジンが停止すると、割り当てられたすべてのメモリが解放され、開いていた可能性のあるすべてのデータベースカーソルが閉じられます。エラーが原因で実行が停止した場合、保留中のトランザクションはすべて終了し、データベースに加えられた変更はロールバックされます。</target>
        </trans-unit>
        <trans-unit id="9a6398c9082248055b1fbc77ff5022201f3b1441" translate="yes" xml:space="preserve">
          <source>The bytecode engine has no stack on which to store the return address of a subroutine. Return addresses must be stored in registers. Hence, bytecode subroutines are not reentrant.</source>
          <target state="translated">バイトコードエンジンには、サブルーチンのリターンアドレスを格納するためのスタックがありません。リターンアドレスはレジスタに格納しなければなりません。したがって、バイトコードサブルーチンはリエントラントではありません。</target>
        </trans-unit>
        <trans-unit id="28f086fcda9ebdf902655d03a38811e78fc96fb9" translate="yes" xml:space="preserve">
          <source>The bytecode engine is &lt;u&gt;not&lt;/u&gt; an API of SQLite. Details about the bytecode engine change from one release of SQLite to the next. Applications that use SQLite should not depend on any of the details found in this document.</source>
          <target state="translated">バイトコードエンジンはSQLiteのAPIではあり&lt;u&gt;ません&lt;/u&gt;。バイトコードエンジンの詳細は、SQLiteのリリースごとに変更されています。SQLiteを使用するアプリケーションは、このドキュメントにある詳細に依存するべきではありません。</target>
        </trans-unit>
        <trans-unit id="8f39ef66488b6211208c988daf5ffcab23760705" translate="yes" xml:space="preserve">
          <source>The bytecode virtual machine is the heart of SQLite. Programmers who want to understand how SQLite operates internally must be familiar with the bytecode engine.</source>
          <target state="translated">バイトコード仮想マシンは SQLite の心臓部です。SQLite が内部的にどのように動作するかを理解したいプログラマーは、バイトコードエンジンに精通していなければなりません。</target>
        </trans-unit>
        <trans-unit id="efeaf3fe17bdefca5b34d3df41725c68d1db2de0" translate="yes" xml:space="preserve">
          <source>The cFrom and cTo columns show edit transformation strings. Either or both columns may contain more than one character. Or either column (but not both) may hold an empty string. When cFrom is empty, that is the cost of inserting cTo. When cTo is empty, that is the cost of deleting cFrom.</source>
          <target state="translated">cFrom列とcTo列は編集変換文字列を示します。どちらか、または両方の列に複数の文字が含まれている可能性があります。あるいは、どちらかのカラム(両方ではありません)に空の文字列が格納されていることがあります。cFrom が空の場合、これは cTo を挿入するためのコストです。cTo が空の場合、それは cFrom を削除するためのコストです。</target>
        </trans-unit>
        <trans-unit id="334e7f3d3c0f1d00666221b0f79b06086771f2a0" translate="yes" xml:space="preserve">
          <source>The cache must not perform any reference counting. A single call to xUnpin() unpins the page regardless of the number of prior calls to xFetch().</source>
          <target state="translated">キャッシュは参照カウントを行ってはいけません。xUnpin()への一回の呼び出しは、xFetch()への前の呼び出しの数に関係なく、ページのピンを外します。</target>
        </trans-unit>
        <trans-unit id="ba91e47edf5c7de46f6d683125d4647799118c05" translate="yes" xml:space="preserve">
          <source>The cache query parameter determines if the new database is opened using &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; or with a private cache.</source>
          <target state="translated">キャッシュクエリパラメータは、&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュモード&lt;/a&gt;を使用して、またはプライベートキャッシュを使用して、新しいデータベースを開くかどうかを決定します。</target>
        </trans-unit>
        <trans-unit id="3b1d92f7c11891a9dfcf8a02bdb8e1d1b67e45d9" translate="yes" xml:space="preserve">
          <source>The cache sharing mode set by this interface effects all subsequent calls to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;. Existing database connections continue to use the sharing mode that was in effect at the time they were opened.</source>
          <target state="translated">このインターフェースによって設定されたキャッシュ共有モードは、&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;、および&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16（）&lt;/a&gt;への後続のすべての呼び出しに影響します。既存のデータベース接続は、開かれたときに有効だった共有モードを引き続き使用します。</target>
        </trans-unit>
        <trans-unit id="6c24d3d1b52233a8d1d33d1521f0d40a35115941" translate="yes" xml:space="preserve">
          <source>The cache sharing mode set by this interface effects all subsequent calls to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;. Existing database connections continue use the sharing mode that was in effect at the time they were opened.</source>
          <target state="translated">このインターフェースによって設定されるキャッシュ共有モードは、&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;、および&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16（）&lt;/a&gt;への後続のすべての呼び出しに影響します。既存のデータベース接続では、開かれたときに有効だった共有モードが引き続き使用されます。</target>
        </trans-unit>
        <trans-unit id="84568a531cbb8fea84a45d0e913a15a98ad6bdd3" translate="yes" xml:space="preserve">
          <source>The cache sharing mode set by this interface effects all subsequent calls to &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;. Existing database connections continue to use the sharing mode that was in effect at the time they were opened.</source>
          <target state="translated">このインターフェースによって設定されたキャッシュ共有モードは、&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;、&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;、および&lt;a href=&quot;open&quot;&gt;sqlite3_open16（）&lt;/a&gt;への後続のすべての呼び出しに影響します。既存のデータベース接続は、開かれたときに有効だった共有モードを引き続き使用します。</target>
        </trans-unit>
        <trans-unit id="f37b504a453065b9fe4d5c4bf29c4836a5d7646e" translate="yes" xml:space="preserve">
          <source>The cache sharing mode set by this interface effects all subsequent calls to &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;. Existing database connections continue use the sharing mode that was in effect at the time they were opened.</source>
          <target state="translated">このインターフェースによって設定されるキャッシュ共有モードは、&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;、&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;、および&lt;a href=&quot;open&quot;&gt;sqlite3_open16（）&lt;/a&gt;への後続のすべての呼び出しに影響します。既存のデータベース接続では、開かれたときに有効だった共有モードが引き続き使用されます。</target>
        </trans-unit>
        <trans-unit id="e474b4529162f0cc96b1a00a4049ab5a12dcf32d" translate="yes" xml:space="preserve">
          <source>The cache-flush method &lt;a href=&quot;c3ref/finalize&quot;&gt;finalizes&lt;/a&gt; all prepared statements currently in the cache.</source>
          <target state="translated">cache-flushメソッドは、現在キャッシュにあるすべての準備済みステートメントを&lt;a href=&quot;c3ref/finalize&quot;&gt;ファイナライズし&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="9d8d3b22c77f42c07d50a96703e45047516a539f" translate="yes" xml:space="preserve">
          <source>The cache_spill pragma enables or disables the ability of the pager to spill dirty cache pages to the database file in the middle of a transaction. Cache_spill is enabled by default and most applications should leave it that way as cache spilling is usually advantageous. However, a cache spill has the side-effect of acquiring an &lt;a href=&quot;lockingv3#excl_lock&quot;&gt;EXCLUSIVE lock&lt;/a&gt; on the database file. Hence, some applications that have large long-running transactions may want to disable cache spilling in order to prevent the application from acquiring an exclusive lock on the database until the moment that the transaction &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;s.</source>
          <target state="translated">cache_spillプラグマは、トランザクションの途中でダーティキャッシュページをデータベースファイルにスピルするページャの機能を有効または無効にします。 Cache_spillはデフォルトで有効になっています。通常、キャッシュスピルが有利であるため、ほとんどのアプリケーションはそのままにしておきます。ただし、キャッシュスピルには、データベースファイルの&lt;a href=&quot;lockingv3#excl_lock&quot;&gt;排他ロック&lt;/a&gt;を取得するという副作用があります。したがって、長時間実行される大きなトランザクションがある一部のアプリケーションでは、トランザクションが&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;する瞬間まで、アプリケーションがデータベースの排他ロックを取得できないようにするために、キャッシュのスピルを無効にする必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="9721a1202302bdb3675cb33fdaf401b47649ef3f" translate="yes" xml:space="preserve">
          <source>The callback function is used to receive the results of a query. A prototype for the callback function is as follows:</source>
          <target state="translated">コールバック関数は、クエリの結果を受け取るために使用されます。コールバック関数のプロトタイプは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="dce299de07269b78871b3c034bf37ba0c0271573" translate="yes" xml:space="preserve">
          <source>The callback function registered by sqlite3_profile() is invoked as each SQL statement finishes. The profile callback contains the original statement text and an estimate of wall-clock time of how long that statement took to run. The profile callback time is in units of nanoseconds, however the current implementation is only capable of millisecond resolution so the six least significant digits in the time are meaningless. Future versions of SQLite might provide greater resolution on the profiler callback. Invoking either &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; will cancel the profile callback.</source>
          <target state="translated">sqlite3_profile（）によって登録されたコールバック関数は、各SQLステートメントが完了するたびに呼び出されます。プロファイルコールバックには、元のステートメントテキストと、そのステートメントの実行にかかった時間の概算時間が含まれています。プロファイルのコールバック時間はナノ秒単位ですが、現在の実装ではミリ秒の分解能しか使用できないため、時間の最下位6桁は意味がありません。 SQLiteの将来のバージョンでは、プロファイラーコールバックの解像度が向上する可能性があります。&lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace（）&lt;/a&gt;または&lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;を呼び出すと、プロファイルコールバックがキャンセルされます。</target>
        </trans-unit>
        <trans-unit id="a6f29aa702b9f0b66493dfb5e14c2df5fa8051eb" translate="yes" xml:space="preserve">
          <source>The callback function registered by sqlite3_profile() is invoked as each SQL statement finishes. The profile callback contains the original statement text and an estimate of wall-clock time of how long that statement took to run. The profile callback time is in units of nanoseconds, however the current implementation is only capable of millisecond resolution so the six least significant digits in the time are meaningless. Future versions of SQLite might provide greater resolution on the profiler callback. Invoking either &lt;a href=&quot;profile&quot;&gt;sqlite3_trace()&lt;/a&gt; or &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; will cancel the profile callback.</source>
          <target state="translated">sqlite3_profile（）によって登録されたコールバック関数は、各SQLステートメントが完了するたびに呼び出されます。プロファイルコールバックには、元のステートメントテキストと、そのステートメントの実行にかかった時間の概算時間が含まれています。プロファイルのコールバック時間はナノ秒単位ですが、現在の実装ではミリ秒の分解能しか使用できないため、時間の最下位6桁は意味がありません。 SQLiteの将来のバージョンでは、プロファイラーコールバックの解像度が向上する可能性があります。&lt;a href=&quot;profile&quot;&gt;sqlite3_trace（）&lt;/a&gt;または&lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;を呼び出すと、プロファイルコールバックがキャンセルされます。</target>
        </trans-unit>
        <trans-unit id="6cc8b0e0c1561082e8c35dc0acaf0338a474ad77" translate="yes" xml:space="preserve">
          <source>The callback function registered by sqlite3_trace() is invoked at various times when an SQL statement is being run by &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt;. The sqlite3_trace() callback is invoked with a UTF-8 rendering of the SQL statement text as the statement first begins executing. Additional sqlite3_trace() callbacks might occur as each triggered subprogram is entered. The callbacks for triggers contain a UTF-8 SQL comment that identifies the trigger.</source>
          <target state="translated">sqlite3_trace（）によって登録されたコールバック関数は、SQLステートメントが&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;によって実行されているさまざまなタイミングで呼び出されます。sqlite3_trace（）コールバックは、ステートメントが最初に実行を開始するときに、SQLステートメントテキストのUTF-8レンダリングで呼び出されます。トリガーされた各サブプログラムに入るときに、追加のsqlite3_trace（）コールバックが発生する可能性があります。トリガーのコールバックには、トリガーを識別するUTF-8 SQLコメントが含まれています。</target>
        </trans-unit>
        <trans-unit id="ce29a09fb52c337eecabbd8bc599ef45377bf00d" translate="yes" xml:space="preserve">
          <source>The callback function registered by sqlite3_trace() is invoked at various times when an SQL statement is being run by &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt;. The sqlite3_trace() callback is invoked with a UTF-8 rendering of the SQL statement text as the statement first begins executing. Additional sqlite3_trace() callbacks might occur as each triggered subprogram is entered. The callbacks for triggers contain a UTF-8 SQL comment that identifies the trigger.</source>
          <target state="translated">sqlite3_trace（）によって登録されたコールバック関数は、SQLステートメントが&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;によって実行されているさまざまなタイミングで呼び出されます。sqlite3_trace（）コールバックは、ステートメントが最初に実行を開始するときに、SQLステートメントテキストのUTF-8レンダリングで呼び出されます。トリガーされた各サブプログラムに入るときに、追加のsqlite3_trace（）コールバックが発生する可能性があります。トリガーのコールバックには、トリガーを識別するUTF-8 SQLコメントが含まれています。</target>
        </trans-unit>
        <trans-unit id="b2f2fd31e08bf7a8ddd0b8f8f2559aa236b781e8" translate="yes" xml:space="preserve">
          <source>The callback function should normally return 0. If the callback function returns non-zero, the query is immediately aborted and &lt;b&gt;sqlite_exec&lt;/b&gt; will return SQLITE_ABORT.</source>
          <target state="translated">コールバック関数は通常0を返します。コールバック関数がゼロ以外の値を返す場合、クエリは直ちに中止され、&lt;b&gt;sqlite_exec&lt;/b&gt;はSQLITE_ABORTを返します。</target>
        </trans-unit>
        <trans-unit id="2394e983e60bde9a89a8173fd3ab1cfc913e1dc5" translate="yes" xml:space="preserve">
          <source>The callback function should normally return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;. If an error code is returned, that error will propagate back up through the SQLite code base to cause the statement that provoked the callback to report an error, though the commit will have still occurred. If the callback returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, or if it returns a value that does not correspond to any valid SQLite error code, the results are undefined.</source>
          <target state="translated">コールバック関数は通常&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OKを&lt;/a&gt;返します。エラーコードが返されると、そのエラーはSQLiteコードベースを介して伝播し、コールバックを引き起こしたステートメントがエラーを報告しますが、コミットはまだ発生しています。コールバックが&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;または&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONEを&lt;/a&gt;返す場合、または有効なSQLiteエラーコードに対応しない値を返す場合、結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="e115553094195c6d671fc1803e4945ba335eedc5" translate="yes" xml:space="preserve">
          <source>The callback function should normally return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;. If an error code is returned, that error will propagate back up through the SQLite code base to cause the statement that provoked the callback to report an error, though the commit will have still occurred. If the callback returns &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; or &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, or if it returns a value that does not correspond to any valid SQLite error code, the results are undefined.</source>
          <target state="translated">コールバック関数は通常&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OKを&lt;/a&gt;返します。エラーコードが返されると、そのエラーはSQLiteコードベースを介して伝播し、コールバックを引き起こしたステートメントがエラーを報告しますが、コミットはまだ発生しています。コールバックが&lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;または&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONEを&lt;/a&gt;返す場合、または有効なSQLiteエラーコードに対応しない値を返す場合、結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="dd2c627a789615e3efe180bdedfefe32d9d62d76" translate="yes" xml:space="preserve">
          <source>The callback function should register the desired collation using &lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collation16()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collation_v2()&lt;/a&gt;.</source>
          <target state="translated">コールバック関数は、&lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collat​​ion（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collat​​ion16（）&lt;/a&gt;、または&lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collat​​ion_v2（）&lt;/a&gt;を使用して目的の照合を登録する必要があります。</target>
        </trans-unit>
        <trans-unit id="c17f517957de57a117a3b4627294584d44e59419" translate="yes" xml:space="preserve">
          <source>The callback function should register the desired collation using &lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt;, &lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collation16()&lt;/a&gt;, or &lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collation_v2()&lt;/a&gt;.</source>
          <target state="translated">コールバック関数は、&lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collat​​ion（）&lt;/a&gt;、&lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collat​​ion16（）&lt;/a&gt;、または&lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collat​​ion_v2（）&lt;/a&gt;を使用して目的の照合を登録する必要があります。</target>
        </trans-unit>
        <trans-unit id="fefabcb34707d427a36b9901ef209a203d46bf9f" translate="yes" xml:space="preserve">
          <source>The callback is invoked by SQLite after the commit has taken place and the associated write-lock on the database released, so the implementation may read, write or &lt;a href=&quot;../wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; the database as required.</source>
          <target state="translated">コールバックは、コミットが行われ、データベースの関連する書き込みロックが解放された後にSQLiteによって呼び出されるため、実装は必要に応じてデータベースの読み取り、書き込み、または&lt;a href=&quot;../wal#ckpt&quot;&gt;チェックポイントを&lt;/a&gt;実行できます。</target>
        </trans-unit>
        <trans-unit id="f6c4a8d646e0cbd66ca6c45574aae0dd0351286a" translate="yes" xml:space="preserve">
          <source>The callback is invoked by SQLite after the commit has taken place and the associated write-lock on the database released, so the implementation may read, write or &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; the database as required.</source>
          <target state="translated">コールバックは、コミットが行われ、データベースの関連する書き込みロックが解放された後にSQLiteによって呼び出されるため、実装は必要に応じてデータベースの読み取り、書き込み、または&lt;a href=&quot;wal#ckpt&quot;&gt;チェックポイントを&lt;/a&gt;実行できます。</target>
        </trans-unit>
        <trans-unit id="facad5f03164aa5e049b3e0fcdccc7d1ce7b086d" translate="yes" xml:space="preserve">
          <source>The callback is invoked every N virtual machine operations, where N is supplied as the second argument to &lt;b&gt;sqlite_progress_handler()&lt;/b&gt;. The third and fourth arguments to &lt;b&gt;sqlite_progress_handler()&lt;/b&gt; are a pointer to the routine to be invoked and a void pointer to be passed as the first argument to it.</source>
          <target state="translated">コールバックはN個の仮想マシン操作ごとに呼び出されます。Nは&lt;b&gt;sqlite_progress_handler（）の&lt;/b&gt; 2番目の引数として提供されます。&lt;b&gt;sqlite_progress_handler（）&lt;/b&gt;の3番目と4番目の引数は、呼び出されるルーチンへのポインターと、最初の引数として渡されるvoidポインターです。</target>
        </trans-unit>
        <trans-unit id="70ae791199d0c0d2e25d25668478f3c97d6fcbcf" translate="yes" xml:space="preserve">
          <source>The callback registered by this function replaces any existing callback registered using &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt;. Likewise, registering a callback using &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; disables the automatic checkpoint mechanism configured by this function.</source>
          <target state="translated">この関数によって登録されたコールバックは、&lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook（）&lt;/a&gt;を使用して登録された既存のコールバックを置き換えます。同様に、&lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook（）&lt;/a&gt;を使用してコールバックを登録すると、この関数によって構成された自動チェックポイントメカニズムが無効になります。</target>
        </trans-unit>
        <trans-unit id="95427739ef742c846008bdf4e9ade466f5ff0b68" translate="yes" xml:space="preserve">
          <source>The callback registered by this function replaces any existing callback registered using &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt;. Likewise, registering a callback using &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; disables the automatic checkpoint mechanism configured by this function.</source>
          <target state="translated">この関数によって登録されたコールバックは、&lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook（）&lt;/a&gt;を使用して登録された既存のコールバックを置き換えます。同様に、&lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook（）&lt;/a&gt;を使用してコールバックを登録すると、この関数によって構成された自動チェックポイントメカニズムが無効になります。</target>
        </trans-unit>
        <trans-unit id="af79ec8f0bec910d80bc717aab639238d9ea73fe" translate="yes" xml:space="preserve">
          <source>The caller could distinguish between this special &quot;DROP TABLE|INDEX&quot; case and other cases by using &lt;a href=&quot;rescode#extrc&quot;&gt;extended error codes&lt;/a&gt;. When it is appropriate to call &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt;, the extended error code is SQLITE_LOCKED_SHAREDCACHE. Otherwise, in the &quot;DROP TABLE|INDEX&quot; case, it is just plain SQLITE_LOCKED. Another solution might be to limit the number of times that any single query could be reattempted (to say 100). Although this might be less efficient than one might wish, the situation in question is not likely to occur often.</source>
          <target state="translated">呼び出し側は、&lt;a href=&quot;rescode#extrc&quot;&gt;拡張エラーコード&lt;/a&gt;を使用して、この特別な「DROP TABLE | INDEX」のケースと他のケースを区別できます。&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;を呼び出すのが適切な場合、拡張エラーコードはSQLITE_LOCKED_SHAREDCACHEです。それ以外の場合、「DROP TABLE | INDEX」の場合、それは単なるSQLITE_LOCKEDです。別の解決策は、単一のクエリを再試行できる回数を制限することです（たとえば100）。これは望んでいるよりも効率が悪いかもしれませんが、問題の状況は頻繁に発生する可能性は低いです。</target>
        </trans-unit>
        <trans-unit id="b3f82dd9e0519120922fe3d796ee7df0852a43b3" translate="yes" xml:space="preserve">
          <source>The canonical FTS5 source code consists of a series of *.c and other files in the &quot;ext/fts5&quot; directory of the SQLite source tree. A build process reduces this to just two files - &quot;fts5.c&quot; and &quot;fts5.h&quot; - which may be used to build an SQLite loadable extension.</source>
          <target state="translated">標準的な FTS5 のソースコードは、SQLite ソースツリーの &quot;ext/fts5&quot; ディレクトリにある一連の *.c とその他のファイルで構成されています。ビルド処理により、これを &quot;fts5.c&quot; と &quot;fts5.h&quot; の 2 つのファイルだけに減らすことができます。-これらのファイルは、SQLite のロード可能な拡張機能をビルドするために使用することができます。</target>
        </trans-unit>
        <trans-unit id="821b27603ed5a2bcfa634bb0e0d6241eee07c748" translate="yes" xml:space="preserve">
          <source>The carray() function can be used in the FROM clause of a query. For example, to query two entries from the OBJ table using rowids taken from a C-language array at address $PTR.</source>
          <target state="translated">carray()関数は、クエリの FROM 句で使用することができます。例えば、アドレス$PTRのC言語配列から取得した行番号を使用してOBJテーブルから2つのエントリを問い合わせるには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="44fb31ec0ece772e4bff94846b749fc144432db5" translate="yes" xml:space="preserve">
          <source>The carray() function is not compiled into SQLite by default. It is available as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; in the &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/carray.c&quot;&gt;ext/misc/carray.c&lt;/a&gt; source file.</source>
          <target state="translated">carray（）関数は、デフォルトではSQLiteにコンパイルされていません。これは、&lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/carray.c&quot;&gt;ext / misc / carray.c&lt;/a&gt;ソースファイルで&lt;a href=&quot;loadext&quot;&gt;ロード可能な拡張機能&lt;/a&gt;として使用できます。</target>
        </trans-unit>
        <trans-unit id="435764c5d08e172eacd91d4b4315996e3f48003b" translate="yes" xml:space="preserve">
          <source>The carray() function takes two or three arguments. The first argument is a pointer to an array. Since pointer values cannot be specified directly in SQL, the first argument must be a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that is bound to a pointer value using the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; interface using a pointer-type of &quot;carray&quot;. The second argument is the number of elements in the array. The optional third argument is a string that determines the datatype of the elements in the C-language array. Allowed values for the third argument are:</source>
          <target state="translated">carray（）関数は2つまたは3つの引数を取ります。最初の引数は配列へのポインタです。SQLでポインター値を直接指定することはできないため、最初の引数は、 &quot;carray&quot;のポインター型を使用する&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;インターフェイスを使用してポインター値にバインドされる&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメーターで&lt;/a&gt;ある必要があります。2番目の引数は、配列内の要素の数です。オプションの3番目の引数は、C言語配列の要素のデータ型を決定する文字列です。3番目の引数に使用できる値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="41b5d7c612b8b2127750760016443da99495e2ab" translate="yes" xml:space="preserve">
          <source>The casual reader is not expected to understand or remember any part of the list above. The point of this list is to demonstrate that the decision of whether or not to flatten a query is complex.</source>
          <target state="translated">カジュアルな読者は、上記のリストのどの部分も理解したり覚えていたりすることは期待していません。このリストのポイントは、クエリを平坦にするかどうかの判断が複雑であることを示すことです。</target>
        </trans-unit>
        <trans-unit id="bcf344511369b084d726030fdafcea463d5dc468" translate="yes" xml:space="preserve">
          <source>The cell content area</source>
          <target state="translated">セルの内容領域</target>
        </trans-unit>
        <trans-unit id="4e5d403004805e89c7f707b8add474e39df5ebd7" translate="yes" xml:space="preserve">
          <source>The cell pointer array</source>
          <target state="translated">セルポインタの配列</target>
        </trans-unit>
        <trans-unit id="e6c56d9636275558f42c1d09a95b01d119d13bcb" translate="yes" xml:space="preserve">
          <source>The cell pointer array of a b-tree page immediately follows the b-tree page header. Let K be the number of cells on the btree. The cell pointer array consists of K 2-byte integer offsets to the cell contents. The cell pointers are arranged in key order with left-most cell (the cell with the smallest key) first and the right-most cell (the cell with the largest key) last.</source>
          <target state="translated">b-treeページのセルポインタ配列は、b-treeページヘッダの直後に続く。Kをb-tree上のセルの数とする。セルポインタの配列は、セルの内容にオフセットされた K 個の 2 バイト整数で構成される。セルポインタはキー順に配列され、左端のセル(キーが最小のセル)が最初に、右端のセル(キーが最大のセル)が最後になる。</target>
        </trans-unit>
        <trans-unit id="1302721086a59f9c1c80a0439335aec4ebc89654" translate="yes" xml:space="preserve">
          <source>The cell_size_check pragma enables or disables additional sanity checking on database b-tree pages as they are initially read from disk. With cell size checking enabled, database corruption is detected earlier and is less likely to &quot;spread&quot;. However, there is a small performance hit for doing the extra checks and so cell size checking is turned off by default.</source>
          <target state="translated">cell_size_check pragma は、データベースの b-tree ページがディスクから最初に読み込まれたときに、追加のサニティチェックを有効または無効にします。セルサイズチェックを有効にすると、データベースの破損がより早く検出され、「拡散」する可能性が低くなります。しかし、追加のチェックを行うためのパフォーマンスの低下があるため、セルサイズチェックはデフォルトではオフになっています。</target>
        </trans-unit>
        <trans-unit id="68b13b4df554f0eca9f783dc081206c3c433b689" translate="yes" xml:space="preserve">
          <source>The cg_anno.tcl script removes extraneous details from the default cachegrind annotation output so that before-and-after reports can be compared using a side-by-side diff to view specific details of how a micro-optimization attempt affected performance.</source>
          <target state="translated">cg_anno.tcl スクリプトはデフォルトの cachegrind アノテーション出力から余計な詳細を削除します。</target>
        </trans-unit>
        <trans-unit id="fdc2d39d7bf4988a1e3259d80bd003ba0f7f2a24" translate="yes" xml:space="preserve">
          <source>The change is made by an SQL trigger or foreign key action instead of directly as a result of a users SQL statement.</source>
          <target state="translated">変更は、ユーザーのSQL文の結果として直接ではなく、SQLトリガまたは外部キーアクションによって行われます。</target>
        </trans-unit>
        <trans-unit id="55b6de28efb13f598ab97e8c9b2ad359898d3863" translate="yes" xml:space="preserve">
          <source>The changes must consist of &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; operations only. CREATE and DROP operations are not supported.</source>
          <target state="translated">変更は、&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;、&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;、および&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;操作のみで構成されている必要があります。CREATEおよびDROP操作はサポートされていません。</target>
        </trans-unit>
        <trans-unit id="204b32b2b5c56879d06b01e160a1a35686edf225" translate="yes" xml:space="preserve">
          <source>The changes to locking and concurrency control in SQLite version 3 also introduce some subtle changes in the way transactions work at the SQL language level. By default, SQLite version 3 operates in &lt;em&gt;autocommit&lt;/em&gt; mode. In autocommit mode, all changes to the database are committed as soon as all operations associated with the current database connection complete.</source>
          <target state="translated">SQLiteバージョン3でのロックおよび同時実行制御の変更により、SQL言語レベルでのトランザクションの動作方法にも微妙な変更がいくつか加えられました。デフォルトでは、SQLiteバージョン3は&lt;em&gt;自動コミット&lt;/em&gt;モードで動作します。自動コミットモードでは、現在のデータベース接続に関連付けられているすべての操作が完了するとすぐに、データベースに対するすべての変更がコミットされます。</target>
        </trans-unit>
        <trans-unit id="9ec4059d42e348f2d46482a218570373eadf5d72" translate="yes" xml:space="preserve">
          <source>The changes() function returns the number of database rows that were changed or inserted or deleted by the most recently completed INSERT, DELETE, or UPDATE statement, exclusive of statements in lower-level triggers. The changes() SQL function is a wrapper around the &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; C/C++ function and hence follows the same rules for counting changes.</source>
          <target state="translated">changes（）関数は、最後に完了したINSERT、DELETE、またはUPDATEステートメントによって変更または挿入または削除されたデータベース行の数を返します。下位レベルのトリガーのステートメントは含まれません。changes（）SQL関数は、&lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes（）&lt;/a&gt; C / C ++関数のラッパーであるため、変更をカウントする場合と同じルールに従います。</target>
        </trans-unit>
        <trans-unit id="a67c4e9392e6b6f9ae02f045b5dfeb70fe9c0330" translate="yes" xml:space="preserve">
          <source>The char(X1,X2,...,XN) function returns a string composed of characters having the unicode code point values of integers X1 through XN, respectively.</source>
          <target state="translated">char(X1,X2,...,XN)関数は、それぞれ整数X1からXNまでのユニコードコードコードポイント値を持つ文字からなる文字列を返します。</target>
        </trans-unit>
        <trans-unit id="37f1486781d28feebc971db6315e3ab886799387" translate="yes" xml:space="preserve">
          <source>The chart below shows average time to read a blob directly from the filesystem versus the time needed to read the same blob from the SQLite database. The actual timings vary considerably from one system to another (the Ubuntu desktop is much faster than the Galaxy S3 phone, for example). This chart shows the ratio of the times needed to read blobs from a file divided by the time needed to from the database. The left-most column in the chart is the normalized time to read from the database, for reference.</source>
          <target state="translated">下のグラフは、ファイルシステムから直接ブロブを読み取るのに必要な平均時間と、SQLiteデータベースから同じブロブを読み取るのに必要な時間を比較したものです。実際の時間はシステムによってかなり異なります(例えば、UbuntuデスクトップはGalaxy S3携帯電話よりもはるかに高速です)。このチャートは、ファイルからブロブを読み取るのに必要な時間をデータベースから読み取るのに必要な時間で割った比率を示しています。チャートの一番左の列は、参考までに、データベースからの読み込みに必要な時間を正規化したものです。</target>
        </trans-unit>
        <trans-unit id="f11b1918c906d3777fe0d3b93cddb4875a03b224" translate="yes" xml:space="preserve">
          <source>The chart below shows data collected using &lt;a href=&quot;https://www.sqlite.org/src/file/test/kvtest.c&quot;&gt;kvtest.c&lt;/a&gt; on five different systems:</source>
          <target state="translated">以下のチャートは、5つの異なるシステムで&lt;a href=&quot;https://www.sqlite.org/src/file/test/kvtest.c&quot;&gt;kvtest.c&lt;/a&gt;を使用して収集されたデータを示しています。</target>
        </trans-unit>
        <trans-unit id="7328593ed0585c2ca2a1685910b260ca61685e5b" translate="yes" xml:space="preserve">
          <source>The chart below shows the relative size and performance for SQLite as of 2017-10-08 for various compilers and optimization settings as tested on Ubuntu 16.04.3 on x86_64. General observations:</source>
          <target state="translated">以下の表は、Ubuntu 16.04.3 on x86_64でテストした、さまざまなコンパイラと最適化設定に対する2017-10-08時点でのSQLiteの相対的なサイズとパフォーマンスを示しています。一般的な観察です。</target>
        </trans-unit>
        <trans-unit id="3c6947bf2e572c7854301cde9f7c5737935d4086" translate="yes" xml:space="preserve">
          <source>The chart shows that on Windows10, content can be read from the SQLite database about 5 times faster than it can be read directly from disk. On Android, SQLite is only about 35% faster than reading from disk.</source>
          <target state="translated">このグラフを見ると、Windows10では、ディスクから直接読み込むよりもSQLiteデータベースからコンテンツを約5倍速く読み込むことができます。Androidでは、SQLiteはディスクからの読み込みよりも約35%しか速くなりません。</target>
        </trans-unit>
        <trans-unit id="4b79be443470ce0f3ea4b17f53ee3e0a63d67172" translate="yes" xml:space="preserve">
          <source>The check-in has a &quot;trunk&quot; tag.</source>
          <target state="translated">チェックインには「トランク」のタグが付いています。</target>
        </trans-unit>
        <trans-unit id="83b47a927090544c586621a60b2916e19fae4550" translate="yes" xml:space="preserve">
          <source>The check-in has a child that has a &quot;trunk&quot; tag.</source>
          <target state="translated">チェックインには「トランク」というタグがついている子がいます。</target>
        </trans-unit>
        <trans-unit id="62c61bcc8ce340ae3a9c5cbdd0d35b553d2386d8" translate="yes" xml:space="preserve">
          <source>The check-in has a parent that has a &quot;trunk&quot; tag.</source>
          <target state="translated">チェックインには「トランク」というタグが付いた親がいます。</target>
        </trans-unit>
        <trans-unit id="b751a07c985fa86fe7c3c40b3bf6704b7852bcb1" translate="yes" xml:space="preserve">
          <source>The checksum algorithm only works for content which is a multiple of 8 bytes in length. In other words, if the inputs are x(0) through x(N) then N must be odd. The checksum algorithm is as follows:</source>
          <target state="translated">チェックサムアルゴリズムは、長さが8バイトの倍数であるコンテンツに対してのみ動作します。言い換えれば、入力が x(0)から x(N)の場合、N は奇数でなければなりません。チェックサムアルゴリズムは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="9654e9833d2bad18eac61dc57f147c1ed15a761f" translate="yes" xml:space="preserve">
          <source>The checksum is an unsigned 32-bit integer computed as follows:</source>
          <target state="translated">チェックサムは、以下のように計算された符号なし32ビット整数です。</target>
        </trans-unit>
        <trans-unit id="270f933e45ef3250cf9dcd69e18f5fd196bd90a0" translate="yes" xml:space="preserve">
          <source>The checksum is computed by interpreting the input as an even number of unsigned 32-bit integers: x(0) through x(N). The 32-bit integers are big-endian if the magic number in the first 4 bytes of the WAL header is 0x377f0683 and the integers are little-endian if the magic number is 0x377f0682. The checksum values are always stored in the frame header in a big-endian format regardless of which byte order is used to compute the checksum.</source>
          <target state="translated">チェックサムは、入力をx(0)からx(N)までの偶数の符号なし32ビット整数として解釈することで計算されます。32ビット整数は、WALヘッダの最初の4バイトのマジックナンバーが0x377f0683の場合はビッグエンディアン、マジックナンバーが0x377f0682の場合はリトルエンディアンになります。チェックサム値は、どのバイトオーダーでチェックサムを計算するかに関わらず、常にビッグエンディアン形式でフレームヘッダに格納されます。</target>
        </trans-unit>
        <trans-unit id="cc24b6f9af8e44f6ff2e41a4a1721f4bd21f35c7" translate="yes" xml:space="preserve">
          <source>The checksum value is used to guard against incomplete writes of a journal page record following a power failure. A different random nonce is used each time a transaction is started in order to minimize the risk that unwritten sectors might by chance contain data from the same page that was a part of prior journals. By changing the nonce for each transaction, stale data on disk will still generate an incorrect checksum and be detected with high probability. The checksum only uses a sparse sample of 32-bit words from the data record for performance reasons - design studies during the planning phases of SQLite 3.0.0 showed a significant performance hit in checksumming the entire page.</source>
          <target state="translated">チェックサム値は、停電後のジャーナル・ページ・レコードの不完全な書き込みを防ぐために使用されます。書かれていないセクタに、以前のジャーナルの一部であった同じページのデータが偶然にも含まれている可能性を最小限に抑えるために、トランザクションが開始されるたびに異なるランダムなnonceが使用されます。トランザクションごとにnonceを変更することで、ディスク上の古いデータは依然として不正確なチェックサムを生成し、高確率で検出されます。SQLite 3.0.0 の計画段階での設計研究では、ページ全体をチェックサムするとパフォーマンスが大幅に低下することが示されていました。</target>
        </trans-unit>
        <trans-unit id="3990c0ed7263ce684acb68c345cf784357432dbe" translate="yes" xml:space="preserve">
          <source>The checksum value written to the</source>
          <target state="translated">に書き込まれたチェックサム値が</target>
        </trans-unit>
        <trans-unit id="77ac1ab95620d7ae472b49582dcc0e306b38c020" translate="yes" xml:space="preserve">
          <source>The checksum values in the final 8 bytes of the frame-header exactly match the checksum computed consecutively on the first 24 bytes of the WAL header and the first 8 bytes and the content of all frames up to and including the current frame.</source>
          <target state="translated">フレームヘッダの最後の8バイトのチェックサム値は、WALヘッダの最初の24バイトと最初の8バイト、および現在のフレームまでのすべてのフレームの内容について連続して計算されたチェックサムと正確に一致します。</target>
        </trans-unit>
        <trans-unit id="6c5140842eec97f2402faa79d3b18bc3769b3084" translate="yes" xml:space="preserve">
          <source>The child table references the primary key of the parent without specifying the primary key columns and the number of primary key columns in the parent do not match the number of child key columns.</source>
          <target state="translated">子テーブルは主キー列を指定せずに親の主キーを参照しており、親の主キー列の数と子キー列の数が一致しない。</target>
        </trans-unit>
        <trans-unit id="cb680522ff952474c4763f726c9755f62f14ba34" translate="yes" xml:space="preserve">
          <source>The circumstances under which SQLite will enforce the heap limits may changes in future releases of SQLite.</source>
          <target state="translated">SQLite がヒープ制限を適用する状況は、将来の SQLite のリリースで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="da194c4576594e7457a28ceeefa6139ab020edb1" translate="yes" xml:space="preserve">
          <source>The circumstances under which SQLite will enforce the soft heap limit may changes in future releases of SQLite.</source>
          <target state="translated">SQLite がソフトヒープ制限を適用する状況は、SQLite の将来のリリースで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="eed6f77a1a12342f6f0e71580e9b4032c3ba5e49" translate="yes" xml:space="preserve">
          <source>The claim of the previous paragraph is extensively checked in the SQLite regression test suite using a special test harness that simulates the effects on a database file of operating system crashes and power failures.</source>
          <target state="translated">前段落の主張は、オペレーティングシステムのクラッシュや停電によるデータベースファイルへの影響をシミュレートする特別なテストハーネスを使用して、SQLiteリグレッションテストスイートで広範囲にチェックされています。</target>
        </trans-unit>
        <trans-unit id="ce6585a17c4368c809080175136a8937ad00861b" translate="yes" xml:space="preserve">
          <source>The coalesce() function returns a copy of its first non-NULL argument, or NULL if all arguments are NULL. Coalesce() must have at least 2 arguments.</source>
          <target state="translated">coalesce()関数は、最初の非NULL引数のコピーを返します。Coalesce()は、少なくとも 2 つの引数を持たなければなりません。</target>
        </trans-unit>
        <trans-unit id="f7c2331fa2d3327c8c4beede4ed0b6e31a651048" translate="yes" xml:space="preserve">
          <source>The code above is for the general case. For the special case of an SQLite Archive that only stores uncompressed or uncompressible content (this might come up, for example, in an SQLite Archive that stores only JPEG, GIF, and/or PNG images) then the content can be inserted into and extracted from the database without using the sqlar_compress() and sqlar_uncompress() functions, and the sqlar.c extension is not required.</source>
          <target state="translated">上記のコードは一般的な場合のものです。非圧縮あるいは非圧縮のコンテンツのみを保存する SQLite Archive の特殊なケース (例えば JPEG、GIF、PNG 画像のみを保存する SQLite Archive など)では、sqlar_compress()や sqlar_uncompress()関数を使用せずにデータベースにコンテンツを挿入したり抽出したりすることができ、sqlar.c 拡張モジュールは必要ありません。</target>
        </trans-unit>
        <trans-unit id="4eb7b1d4fed609f9eafac0ed3cfa712e4a84c44c" translate="yes" xml:space="preserve">
          <source>The code appears stable so we are now calling it &quot;beta&quot;.</source>
          <target state="translated">コードは安定しているようなので、現在は「ベータ」と呼んでいます。</target>
        </trans-unit>
        <trans-unit id="4dcec88beb123f0b5fcd5b586036ea0a356cf753" translate="yes" xml:space="preserve">
          <source>The code audits used to ensure that memory allocation size computations do not overflow in SQLite are repeated prior to every SQLite release.</source>
          <target state="translated">SQLite のメモリ割り当てサイズの計算がオーバーフローしないようにするために使用されるコード監査は、SQLite のリリースのたびに繰り返されます。</target>
        </trans-unit>
        <trans-unit id="b0a804ee343680af0bae1b47adaea7bd27c01026" translate="yes" xml:space="preserve">
          <source>The code for the swarmvtab virtual table is found in the ext/misc/unionvtab.c file of the main SQLite source tree. It may be compiled into an SQLite &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; using a command like:</source>
          <target state="translated">swarmvtab仮想テーブルのコードは、メインのSQLiteソースツリーのext / misc / unionvtab.cファイルにあります。次のようなコマンドを使用して、SQLiteの&lt;a href=&quot;loadext&quot;&gt;ロード可能な拡張機能に&lt;/a&gt;コンパイルできます。</target>
        </trans-unit>
        <trans-unit id="429be1d142052bd4928f94110562bdb201e97a74" translate="yes" xml:space="preserve">
          <source>The code for the zipfile module is found in the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/zipfile.c&quot;&gt;ext/misc/zipfile.c&lt;/a&gt; file of the &lt;a href=&quot;https://sqlite.org/src&quot;&gt;main SQLite source tree&lt;/a&gt;. It may be compiled into an SQLite &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; using a command like:</source>
          <target state="translated">zipfileモジュールのコードは、&lt;a href=&quot;https://sqlite.org/src&quot;&gt;メインのSQLiteソースツリー&lt;/a&gt;の&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/zipfile.c&quot;&gt;ext / misc / zipfile.c&lt;/a&gt;ファイルにあります。次のようなコマンドを使用して、SQLiteの&lt;a href=&quot;loadext&quot;&gt;ロード可能な拡張機能に&lt;/a&gt;コンパイルできます。</target>
        </trans-unit>
        <trans-unit id="e9f5bceb13445c13d968dff10e26983b65675c68" translate="yes" xml:space="preserve">
          <source>The code generated in this last example is the same as the previous except for the addition of two conditional jumps used to implement the extra WHERE and HAVING clauses. The WHERE clause is implemented by instructions 9 through 11 in the query loop. The HAVING clause is implemented by instruction 28 through 30 in the output loop.</source>
          <target state="translated">この最後の例で生成されたコードは、追加の WHERE 節と HAVING 節を実装するために使用される 2 つの条件ジャンプが追加されていることを除いては、前の例と同じです。WHERE句は、クエリループ内の命令9から11によって実装されています。HAVING句は出力ループ内の命令28から30によって実装されています。</target>
        </trans-unit>
        <trans-unit id="ecc7e2ea5797377ee55e53ff370e71d0a0432eb1" translate="yes" xml:space="preserve">
          <source>The code generated to implement this last query is as follows:</source>
          <target state="translated">この最後のクエリを実装するために生成されたコードは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="26011ad1079cb8255e24204fff9114945ad7804b" translate="yes" xml:space="preserve">
          <source>The code generator in SQLite processes compound SELECT statements using a recursive algorithm. In order to limit the size of the stack, we therefore limit the number of terms in a compound SELECT. The maximum number of terms is SQLITE_MAX_COMPOUND_SELECT which defaults to 500. We think this is a generous allotment since in practice we almost never see the number of terms in a compound select exceed single digits.</source>
          <target state="translated">SQLite のコード・ジェネレーターは、再帰的アルゴリズムを使用して複合 SELECT 文を処理します。スタックのサイズを制限するために、複合 SELECT のターム数を制限しています。タームの最大数は SQLITE_MAX_COMPOUND_SELECT で、デフォルトは 500 です。実際には複合セレクトのターム数が一桁を超えることはほとんどないので、これは寛大な割り当てだと考えています。</target>
        </trans-unit>
        <trans-unit id="0a5ca134725357f1db49cf5e9aed85ae431b52f8" translate="yes" xml:space="preserve">
          <source>The code generator, and especially the logic in &lt;b&gt;where*.c&lt;/b&gt; and in &lt;a href=&quot;https://sqlite.org/src/file/src/select.c&quot;&gt;select.c&lt;/a&gt;, is sometimes called the &lt;a href=&quot;optoverview&quot;&gt;query planner&lt;/a&gt;. For any particular SQL statement, there might be hundreds, thousands, or millions of different algorithms to compute the answer. The query planner is an AI that strives to select the best algorithm from these millions of choices.</source>
          <target state="translated">コードジェネレーター、特に&lt;b&gt;where * .c&lt;/b&gt;および&lt;a href=&quot;https://sqlite.org/src/file/src/select.c&quot;&gt;select.c&lt;/a&gt;のロジックは、&lt;a href=&quot;optoverview&quot;&gt;クエリプランナー&lt;/a&gt;と呼ばれることもあります。特定のSQLステートメントでは、答えを計算するための数百、数千、または数百万の異なるアルゴリズムが存在する場合があります。クエリプランナーは、これらの数百万の選択肢から最適なアルゴリズムを選択することに努めるAIです。</target>
        </trans-unit>
        <trans-unit id="25e3614fe3c2a2058c86f93c8b850392e16eae8c" translate="yes" xml:space="preserve">
          <source>The code in &quot;fts5.c&quot; may then be compiled into a loadable extension or statically linked into an application as described in &lt;a href=&quot;loadext#build&quot;&gt;Compiling Loadable Extensions&lt;/a&gt;. There are two entry points defined, both of which do the same thing:</source>
          <target state="translated">次に、「fts5.c」のコードをロード可能な拡張にコンパイルするか、「ロード可能な拡張の&lt;a href=&quot;loadext#build&quot;&gt;コンパイル」で&lt;/a&gt;説明されているようにアプリケーションに静的にリンクします。2つのエントリポイントが定義されており、どちらも同じことを行います。</target>
        </trans-unit>
        <trans-unit id="c15d2613b82ac42eff7d51f6a4257bfde77f5feb" translate="yes" xml:space="preserve">
          <source>The code in this article could be improved in at least two ways:</source>
          <target state="translated">この記事のコードは、少なくとも2つの方法で改善することができます。</target>
        </trans-unit>
        <trans-unit id="81d14a407fed1c180dec58abfdf7e1bfd2ff10aa" translate="yes" xml:space="preserve">
          <source>The code space used by the SQLite library depends on the target platform, the compiler, and optimization settings. These variables also affect performance.</source>
          <target state="translated">SQLite ライブラリが使用するコードスペースは、ターゲットプラットフォーム、コンパイラ、最適化設定に依存します。これらの変数はパフォーマンスにも影響します。</target>
        </trans-unit>
        <trans-unit id="5c4a1121bef63849753648d7ec67f82ac551ebbe" translate="yes" xml:space="preserve">
          <source>The colUsed field indicates which columns of the virtual table may be required by the current scan. Virtual table columns are numbered from zero in the order in which they appear within the CREATE TABLE statement passed to sqlite3_declare_vtab(). For the first 63 columns (columns 0-62), the corresponding bit is set within the colUsed mask if the column may be required by SQLite. If the table has at least 64 columns and any column to the right of the first 63 is required, then bit 63 of colUsed is also set. In other words, column iCol may be required if the expression (colUsed &amp;amp; ((sqlite3_uint64)1 &amp;lt;&amp;lt; (iCol&amp;gt;=63 ? 63 : iCol))) evaluates to non-zero.</source>
          <target state="translated">colUsedフィールドは、現在のスキャンで仮想テーブルのどの列が必要になるかを示します。仮想テーブルの列には、sqlite3_declare_vtab（）に渡されるCREATE TABLEステートメント内に出現する順序で、ゼロから番号が付けられます。最初の63列（列0〜62）では、SQLiteが列を必要とする場合、対応するビットがcolUsedマスク内に設定されます。テーブルに少なくとも64列があり、最初の63の右側の列が必要な場合は、colUsedのビット63も設定されます。つまり、式（colUsed＆（（sqlite3_uint64）1 &amp;lt;&amp;lt;（iCol&amp;gt; = 63？63：iCol）））がゼロ以外に評価される場合、列iColが必要になる場合があります。</target>
        </trans-unit>
        <trans-unit id="cd6add92b1a269fd1ee22788d7c2c68cbcfa3387" translate="yes" xml:space="preserve">
          <source>The collating function callback is invoked with a copy of the pArg application data pointer and with two strings in the encoding specified by the eTextRep argument. The collating function must return an integer that is negative, zero, or positive if the first string is less than, equal to, or greater than the second, respectively. A collating function must always return the same answer given the same inputs. If two or more collating functions are registered to the same collation name (using different eTextRep values) then all must give an equivalent answer when invoked with equivalent strings. The collating function must obey the following properties for all strings A, B, and C:</source>
          <target state="translated">照合関数のコールバックは、pArgアプリケーションデータポインタのコピーと、eTextRep引数で指定されたエンコーディングの2つの文字列で呼び出されます。照合関数は、最初の文字列が2番目の文字列よりも小さい、等しい、または大きい場合、それぞれ負、ゼロ、または正の整数を返さなければなりません。照合関数は、同じ入力が与えられた場合、常に同じ答えを返さなければなりません。2つ以上の照合関数が同じ照合名に登録されている場合(異なるeTextRep値を使用している場合)、等価な文字列で呼び出された場合は、すべて等価な答えを返さなければなりません。照合関数は、すべての文字列A、B、Cに対して以下のプロパティに従わなければなりません。</target>
        </trans-unit>
        <trans-unit id="0a8a7f3b3c83ac2e3d1763414e674a2e2ca29ee7" translate="yes" xml:space="preserve">
          <source>The collating function callback is invoked with a copy of the pArg application data pointer and with two strings in the encoding specified by the eTextRep argument. The two integer parameters to the collating function callback are the length of the two strings, in bytes. The collating function must return an integer that is negative, zero, or positive if the first string is less than, equal to, or greater than the second, respectively. A collating function must always return the same answer given the same inputs. If two or more collating functions are registered to the same collation name (using different eTextRep values) then all must give an equivalent answer when invoked with equivalent strings. The collating function must obey the following properties for all strings A, B, and C:</source>
          <target state="translated">照合関数コールバックは、pArgアプリケーションデータポインタのコピーと、eTextRep引数で指定されたエンコーディングの2つの文字列で呼び出されます。照合関数コールバックの2つの整数パラメータは、2つの文字列の長さをバイト単位で表します。照合関数は、最初の文字列が2番目の文字列よりも小さい、等しい、または大きい場合は、それぞれ負、ゼロ、または正の整数を返さなければなりません。照合関数は、同じ入力が与えられた場合、常に同じ答えを返さなければなりません。2つ以上の照合関数が同じ照合名に登録されている場合(異なるeTextRep値を使用している場合)、等価な文字列で呼び出された場合は、すべて等価な答えを返さなければなりません。照合関数は、すべての文字列A、B、Cに対して以下のプロパティに従わなければなりません。</target>
        </trans-unit>
        <trans-unit id="65d2bfaa5988de22a32b291f24dfa00da4fc2f70" translate="yes" xml:space="preserve">
          <source>The column is identified by the second, third and fourth parameters to this function. The second parameter is either the name of the database (i.e. &quot;main&quot;, &quot;temp&quot;, or an attached database) containing the specified table or NULL. If it is NULL, then all attached databases are searched for the table using the same algorithm used by the database engine to resolve unqualified table references.</source>
          <target state="translated">カラムは、この関数の2番目、3番目、および4番目のパラメータによって識別されます。2番目のパラメータは、指定されたテーブルを含むデータベース(すなわち、&quot;main&quot;、&quot;temp&quot;、またはアタッチされたデータベース)の名前、またはNULLのいずれかです。これがNULLの場合、すべてのアタッチされたデータベースが、データベースエンジンが非限定テーブル参照を解決するために使用するのと同じアルゴリズムを使用して、そのテーブルを検索します。</target>
        </trans-unit>
        <trans-unit id="7829593889659cca230ab3239645af748546a7d0" translate="yes" xml:space="preserve">
          <source>The column labels that appear on the first two lines of output can be turned on and off using the &quot;.header&quot; dot command. In the examples above, the column labels are on. To turn them off you could do this:</source>
          <target state="translated">出力の最初の2行に表示されるカラムラベルは、&quot;.header &quot;ドットコマンドを使用してオンまたはオフにすることができます。上の例では、カラムラベルがオンになっています。それらをオフにするには、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="9b37c354a4343966405cb0363479fdc771c7551d" translate="yes" xml:space="preserve">
          <source>The column may not be &lt;a href=&quot;gencol&quot;&gt;GENERATED ALWAYS ... STORED&lt;/a&gt;, though VIRTUAL columns are allowed.</source>
          <target state="translated">VIRTUAL列は許可されていますが、列は&lt;a href=&quot;gencol&quot;&gt;GENERATED ALWAYS ... STORED&lt;/a&gt;ではない場合があります。</target>
        </trans-unit>
        <trans-unit id="71d2d7e1bd431710201b6152bbbf86fa85eac1e5" translate="yes" xml:space="preserve">
          <source>The column may not have a PRIMARY KEY or UNIQUE constraint.</source>
          <target state="translated">列には PRIMARY KEY または UNIQUE 制約がない場合があります。</target>
        </trans-unit>
        <trans-unit id="99d848b798067eee9317efc709f08dee3a25b0a8" translate="yes" xml:space="preserve">
          <source>The column may not have a default value of CURRENT_TIME, CURRENT_DATE, CURRENT_TIMESTAMP, or an expression in parentheses.</source>
          <target state="translated">この列には、CURRENT_TIME、CURRENT_DATE、CURRENT_TIMESTAMP、または括弧内の式のデフォルト値が含まれていない場合があります。</target>
        </trans-unit>
        <trans-unit id="adb879e73b7d88dc161320c793668864d27ae4e6" translate="yes" xml:space="preserve">
          <source>The column names and definitions for</source>
          <target state="translated">のカラム名と定義</target>
        </trans-unit>
        <trans-unit id="b16cccd51ed940f2dd9c18cb3d4d9b130c9ecd9e" translate="yes" xml:space="preserve">
          <source>The column names for the result sets of &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements have been tweaked in some cases to work more like other SQL database engines.</source>
          <target state="translated">&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントの結果セットの列名は、他のSQLデータベースエンジンのように機能するように調整されている場合があります。</target>
        </trans-unit>
        <trans-unit id="239fe7786e783e697b78c9df7c06b9daecb4d9f7" translate="yes" xml:space="preserve">
          <source>The column names of the virtual table are determined primarily by the &lt;b&gt;schema=&lt;/b&gt; argument. If the &lt;b&gt;schema=&lt;/b&gt; argument is omitted, but &lt;b&gt;header&lt;/b&gt; is true, then the values found in the first line of the CSV file become the column names. If the &lt;b&gt;schema=&lt;/b&gt; argument is omitted and &lt;b&gt;header&lt;/b&gt; is false, then the columns are named &quot;c0&quot;, &quot;c1&quot;, &quot;c2&quot;, and so forth.</source>
          <target state="translated">仮想テーブルの列名は、主に&lt;b&gt;schema =&lt;/b&gt;引数によって決定されます。場合&lt;b&gt;スキーマ=&lt;/b&gt;引数を省略しているが、&lt;b&gt;ヘッダが&lt;/b&gt;真である場合、値は、列名となるCSVファイルの1行目に見出さ。場合は&lt;b&gt;、スキーマ=&lt;/b&gt;引数が省略され&lt;b&gt;ヘッダが&lt;/b&gt;偽である場合、列は等々 、「C0」、「C1」、「C2」、およびという名前が付いています。</target>
        </trans-unit>
        <trans-unit id="27cc219896194f2cbf6cb1853331dc30b6f1a32f" translate="yes" xml:space="preserve">
          <source>The column names reported by join subqueries have been modified slightly in order to work more like other database engines. Consider the following query:</source>
          <target state="translated">join subqueriesで報告されたカラム名は、他のデータベースエンジンと同じように動作するように少し修正されています。次のクエリを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="cf988c97f1d408bf1402feb7e21744609abdb492" translate="yes" xml:space="preserve">
          <source>The column number (1 for the second leftmost column, etc.). This field is omitted for any term-offset list associated with column 0.</source>
          <target state="translated">カラム番号(左端の2番目のカラムなどは1)。このフィールドは、列0に関連付けられたタームオフセットリストの場合は省略されます。</target>
        </trans-unit>
        <trans-unit id="0d64ee03e40c54227cba3f5e9c70df99b5d87845" translate="yes" xml:space="preserve">
          <source>The column number that the term instance occurs in (0 for the leftmost column of the FTS table, 1 for the next leftmost, etc.).</source>
          <target state="translated">用語のインスタンスが発生する列番号(FTSテーブルの一番左端の列は0、次の左端の列は1など)。</target>
        </trans-unit>
        <trans-unit id="0e0d4c37f8f415ca48f1578c5fbfec2c6eeee2e7" translate="yes" xml:space="preserve">
          <source>The column-name list syntax was added in SQLite versions 3.9.0 (2015-10-14).</source>
          <target state="translated">SQLite バージョン 3.9.0 (2015-10-14)でカラム名リスト構文が追加されました。</target>
        </trans-unit>
        <trans-unit id="74b05d9163657d39d9cb9b3d5f80884cae70cb2c" translate="yes" xml:space="preserve">
          <source>The columns are provided by the SQLITE_STMT virtual table are summarized by the hypothetical CREATE TABLE statement show here:</source>
          <target state="translated">SQLITE_STMT仮想テーブルによって提供されるカラムは、ここに示す仮想的なCREATE TABLE文によって要約されています。</target>
        </trans-unit>
        <trans-unit id="99fc02c8d425b8c14b21527882dd349490360fd6" translate="yes" xml:space="preserve">
          <source>The columns referenced in the WHERE clause of a partial index can be any of the columns in the table, not just columns that happen to be indexed. However, it is very common for the WHERE clause expression of a partial index to be a simple expression on the column being indexed. The following is a typical example:</source>
          <target state="translated">部分インデックスのWHERE句で参照されるカラムは、たまたまインデックスが付けられたカラムだけでなく、テーブル内の任意のカラムである可能性があります。しかし、部分インデックスのWHERE句の式が、インデックスされているカラムに対する単純な式であることは非常に一般的です。以下は典型的な例です。</target>
        </trans-unit>
        <trans-unit id="c36ceb732928b62fa9f17cf0516fa8ff6f38d20c" translate="yes" xml:space="preserve">
          <source>The command above created the new branch. But your checkout is still on the trunk - a fact you can see by running the command:</source>
          <target state="translated">上のコマンドは新しいブランチを作成しました。しかし、あなたのチェックアウトはまだトランク上にあります-これはコマンドを実行するとわかります。</target>
        </trans-unit>
        <trans-unit id="39e91ef2d072dfac6ebe4c80889ed64220c2f4b1" translate="yes" xml:space="preserve">
          <source>The command above will make a copy of the complete development history of SQLite into the &quot;sqlite.fossil&quot; file on your computer. Making this copy takes about a minute and uses about 32 megabytes of transfer. After making the copy, &quot;open&quot; the repository by typing:</source>
          <target state="translated">上のコマンドは、SQLiteの完全な開発履歴のコピーをコンピュータ上の &quot;sqlite.fossil &quot;ファイルに作成します。このコピーの作成には約1分かかり、約32メガバイトの転送量を使用します。コピーを作成したら、次のようにタイプしてリポジトリを「開く」。</target>
        </trans-unit>
        <trans-unit id="4b3dc1d8af5139eaa56167ba29f9c2c18e9d510c" translate="yes" xml:space="preserve">
          <source>The command above writes the output of the query as CSV into a temporary file, invokes the default handler for CSV files (usually the preferred spreadsheet program such as Excel or LibreOffice), then deletes the temporary file. This is essentially a short-hand method of doing the sequence of &quot;.csv&quot;, &quot;.once&quot;, and &quot;.system&quot; commands described above.</source>
          <target state="translated">上記のコマンドは、クエリの出力をCSVとして一時ファイルに書き出し、CSVファイルのデフォルトハンドラ(通常はExcelやLibreOfficeなどの好ましい表計算プログラム)を呼び出してから、一時ファイルを削除します。これは基本的に、上で説明した「.csv」、「.once」、「.system」コマンドのシーケンスを実行する手短な方法です。</target>
        </trans-unit>
        <trans-unit id="b075c13635ba5e790ee4582ea35e32db5040da00" translate="yes" xml:space="preserve">
          <source>The command returns a new TCL channel for reading or writing to the BLOB. The channel is opened using the underlying &lt;a href=&quot;c3ref/blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; C-language interface. Close the channel using the &lt;b&gt;close&lt;/b&gt; command of TCL.</source>
          <target state="translated">このコマンドは、BLOBの読み取りまたは書き込み用の新しいTCLチャネルを返します。チャネルは、基礎となる&lt;a href=&quot;c3ref/blob_open&quot;&gt;sqlite3_blob_open（）&lt;/a&gt; C言語インターフェースを使用して開かれます。TCL の&lt;b&gt;close&lt;/b&gt;コマンドを使用してチャネルを閉じます。</target>
        </trans-unit>
        <trans-unit id="988274d0addcbb9018970d10733f7b4052f070a2" translate="yes" xml:space="preserve">
          <source>The command-line shell adds two &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; that facilitate reading content from a file into a table column, and writing the content of a column into a file, respectively.</source>
          <target state="translated">コマンドラインシェルは、ファイルからテーブル列へのコンテンツの読み取りと、列のコンテンツのファイルへの書き込みをそれぞれ容易にする2つの&lt;a href=&quot;appfunc&quot;&gt;アプリケーション定義SQL関数&lt;/a&gt;を追加します。</target>
        </trans-unit>
        <trans-unit id="1a64c0d6110f60679f08571c4a254a77214045a1" translate="yes" xml:space="preserve">
          <source>The command-line shell adds two &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; that facilitate reading content from a file into a table column, and writing the content of a column into a file, respectively.</source>
          <target state="translated">コマンドラインシェルは、ファイルからテーブル列へのコンテンツの読み取りと、ファイルへの列のコンテンツの書き込みをそれぞれ容易にする2つの&lt;a href=&quot;c3ref/create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;を追加します。</target>
        </trans-unit>
        <trans-unit id="5a15969d303479025517006f69c3c3e87572075f" translate="yes" xml:space="preserve">
          <source>The command-line shell uses the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; to access ZIP archives. You can see this by running the &quot;.schema&quot; command when a ZIP archive is open:</source>
          <target state="translated">コマンドラインシェルは、&lt;a href=&quot;zipfile&quot;&gt;Zipfile仮想テーブル&lt;/a&gt;を使用してZIPアーカイブにアクセスします。これは、ZIPアーカイブが開いているときに「.schema」コマンドを実行することで確認できます。</target>
        </trans-unit>
        <trans-unit id="9d792fd30ad98774099bd3871331d49c13f01ab7" translate="yes" xml:space="preserve">
          <source>The commit and rollback hook callbacks are not reentrant. The callback implementation must not do anything that will modify the database connection that invoked the callback. Any actions to modify the database connection must be deferred until after the completion of the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call that triggered the commit or rollback hook in the first place. Note that running any other SQL statements, including SELECT statements, or merely calling &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; will modify the database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">commitおよびrollbackフックのコールバックは再入可能ではありません。コールバック実装は、コールバックを呼び出したデータベース接続を変更するようなことをしてはなりません。データベース接続を変更するアクションはすべて、最初にコミットまたはロールバックフックをトリガーした&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;呼び出しが完了するまで延期する必要があります。 SELECTステートメントを含む他のSQLステートメントを実行するか、単に&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;と&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;を呼び出すと、この段落の「変更」の意味でデータベース接続が変更されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="837a3144fbcca3d5f0e20f9cd17c26bc03114566" translate="yes" xml:space="preserve">
          <source>The commit and rollback hook callbacks are not reentrant. The callback implementation must not do anything that will modify the database connection that invoked the callback. Any actions to modify the database connection must be deferred until after the completion of the &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call that triggered the commit or rollback hook in the first place. Note that running any other SQL statements, including SELECT statements, or merely calling &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; will modify the database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">commitおよびrollbackフックのコールバックは再入可能ではありません。コールバック実装は、コールバックを呼び出したデータベース接続を変更するようなことをしてはなりません。データベース接続を変更するアクションはすべて、最初にコミットまたはロールバックフックをトリガーした&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;呼び出しが完了するまで延期する必要があります。 SELECTステートメントを含む他のSQLステートメントを実行するか、単に&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;と&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;を呼び出すと、この段落の「変更」の意味でデータベース接続が変更されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5854e2359472df03b69e7808b8ee34022d4a6816" translate="yes" xml:space="preserve">
          <source>The commit process shown in &lt;a href=&quot;#section_3_0&quot;&gt;section 3.0&lt;/a&gt; assumes that all database changes fit in memory until it is time to commit. This is the common case. But sometimes a larger change will overflow the user-space cache prior to transaction commit. In those cases, the cache must spill to the database before the transaction is complete.</source>
          <target state="translated">&lt;a href=&quot;#section_3_0&quot;&gt;セクション3.0に&lt;/a&gt;示すコミットプロセスでは、コミットする時まで、すべてのデータベース変更がメモリに収まることを前提としています。これは一般的なケースです。ただし、大きな変更により、トランザクションのコミット前にユーザー空間キャッシュがオーバーフローする場合があります。これらの場合、トランザクションが完了する前に、キャッシュがデータベースにスピルする必要があります。</target>
        </trans-unit>
        <trans-unit id="831de8c9305e21ddee6326436c38620139c51d57" translate="yes" xml:space="preserve">
          <source>The common table expression works without having to load an extension. On the other hand, the extension is easier to program and faster.</source>
          <target state="translated">一般的なテーブル式は、拡張機能をロードすることなく動作します。その一方で、拡張子はプログラミングが簡単で高速です。</target>
        </trans-unit>
        <trans-unit id="975322957294bcdde1991bc8533b4c3c42c34fe5" translate="yes" xml:space="preserve">
          <source>The comparison is a sort comparison, so NULLs compare equal, NULLs are less than numbers, numbers are less than strings, and strings are less than blobs.</source>
          <target state="translated">比較はソート比較なので、NULLは等しく比較し、NULLは数値よりも小さく、数値は文字列よりも小さく、文字列はブロブよりも小さくなります。</target>
        </trans-unit>
        <trans-unit id="77fdffaa220770108e157d8f6fdf86e8984310f3" translate="yes" xml:space="preserve">
          <source>The compilation step shown immediately above is merely representative. In a working installation, one would normally want to specify optimization parameters and compile-time switches on the compiler command line.</source>
          <target state="translated">上に示したコンパイルステップは代表的なものに過ぎません。動作中のインストールでは、通常、最適化パラメータとコンパイル時のスイッチをコンパイラのコマンドラインで指定したいと思うでしょう。</target>
        </trans-unit>
        <trans-unit id="06859965a5874b48e17ef99de2638103b952d1aa" translate="yes" xml:space="preserve">
          <source>The compile-time options for setting upper bounds are &lt;a href=&quot;limits&quot;&gt;documented separately&lt;/a&gt;. The following is a list of the available settings:</source>
          <target state="translated">上限を設定するためのコンパイル時オプションは、&lt;a href=&quot;limits&quot;&gt;個別に説明されてい&lt;/a&gt;ます。以下は、使用可能な設定のリストです。</target>
        </trans-unit>
        <trans-unit id="d37610227543b6269c9a6c07ddb9c1381df5a58a" translate="yes" xml:space="preserve">
          <source>The complete state of an SQLite database is usually contained in a single file on disk called the &quot;main database file&quot;.</source>
          <target state="translated">SQLiteデータベースの完全な状態は、通常「メインデータベースファイル」と呼ばれるディスク上の単一のファイルに含まれています。</target>
        </trans-unit>
        <trans-unit id="96bf44cd55dc348e4e3f4d568f7843d225f7562d" translate="yes" xml:space="preserve">
          <source>The completion table is designed for interactive use. It will return answers at a speed appropriate for human typing. No effort is made to be unusually efficient, so long as the response time is nearly instantaneous in a user interface.</source>
          <target state="translated">補完表はインタラクティブな使用のために設計されています。人間が入力するのに適したスピードで回答を返してくれます。ユーザーインターフェースでの応答時間がほぼ瞬時である限り、異常に効率的になるような努力はしていません。</target>
        </trans-unit>
        <trans-unit id="d59eec775be7e50d6274c344c801f729c91ab804" translate="yes" xml:space="preserve">
          <source>The completion table is used to implement tab-completion in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; in conjunction with either the readline or linenoise input line editing packages for unix. See the &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;https://sqlite.org/src/file/src/shell.c.in&lt;/a&gt; source file for example code. Search for &quot;FROM completion&quot; to find the relevant code sections.</source>
          <target state="translated">補完テーブルは、UNIXのreadlineまたはlinenoise入力行編集パッケージと組み合わせて、&lt;a href=&quot;cli&quot;&gt;コマンドラインシェル&lt;/a&gt;でタブ補完を実装するために使用されます。コードの例については、&lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;https：//sqlite.org/src/file/src/shell.c.in&lt;/a&gt;ソースファイルを参照してください。「FROM完了」を検索して、関連するコードセクションを見つけます。</target>
        </trans-unit>
        <trans-unit id="e034c5722458a4ef5f557863bb00dfc415febe07" translate="yes" xml:space="preserve">
          <source>The completion table might return the same candidate more than once, and it will return candidates in an arbitrary order. The DISTINCT keyword and the ORDER BY in the sample query above are added to make the answers unique and in lexicographical order.</source>
          <target state="translated">補完テーブルは同じ候補を複数回返す可能性があり、任意の順序で候補を返すことになります。上のサンプルクエリのDISTINCTキーワードとORDER BYは、回答を一意で辞書順にするために追加されています。</target>
        </trans-unit>
        <trans-unit id="7bf1657f4892b438bb6c981746dfe40cd870c0fa" translate="yes" xml:space="preserve">
          <source>The complexity of Git distracts attention from the software under development. A user of Git needs to keep all of the following in mind:</source>
          <target state="translated">Git の複雑さは、開発中のソフトウェアから注意を逸らしてしまいます。Gitのユーザーは、以下のことをすべて念頭に置いておく必要があります。</target>
        </trans-unit>
        <trans-unit id="15376f7aadf15df031fa31738229dcbaf3f18c9d" translate="yes" xml:space="preserve">
          <source>The compound SELECT operators UNION, INTERSECT and EXCEPT perform implicit comparisons between values. No affinity is applied to comparison operands for the implicit comparisons associated with UNION, INTERSECT, or EXCEPT - the values are compared as is.</source>
          <target state="translated">複合SELECT演算子UNION、INTERSECT、EXCEPTは、値間の暗黙の比較を実行します。UNION、INTERSECT、またはEXCEPTに関連付けられた暗黙の比較では、比較オペランドに親和性は適用されません-値はそのまま比較されます。</target>
        </trans-unit>
        <trans-unit id="dc11a925c84e89a2d79f62896a81bbc87b31205f" translate="yes" xml:space="preserve">
          <source>The compress and uncompress options allow FTS4 content to be stored in the database in a compressed form. Both options should be set to the name of an SQL scalar function registered using &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; that accepts a single argument.</source>
          <target state="translated">圧縮オプションと圧縮解除オプションを使用すると、FTS4コンテンツを圧縮形式でデータベースに保存できます。どちらのオプションも、単一の引数を受け入れる&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;を使用して登録されたSQLスカラー関数の名前に設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="8f77d8f289ab8ab189cc2f583f00d06f6f32d94d" translate="yes" xml:space="preserve">
          <source>The compress function should return a compressed version of the value passed to it as an argument. Each time data is written to the FTS4 table, each column value is passed to the compress function and the result value stored in the database. The compress function may return any type of SQLite value (blob, text, real, integer or null).</source>
          <target state="translated">圧縮関数は、引数として渡された値を圧縮したものを返す必要があります。データがFTS4テーブルに書き込まれるたびに、各列の値が圧縮関数に渡され、その結果の値がデータベースに格納されます。圧縮関数は、任意のタイプのSQLite値(blob、text、real、integer、null)を返すことができます。</target>
        </trans-unit>
        <trans-unit id="290b0a4fd26e950183bc56ef03571b78a9f077cd" translate="yes" xml:space="preserve">
          <source>The compress option is used to specify the compress function. It is an error to specify a compress function without also specifying an uncompress function. &lt;a href=&quot;fts3#the_compress_and_uncompress_options&quot;&gt;See below&lt;/a&gt; for details.</source>
          <target state="translated">圧縮オプションは、圧縮機能を指定するために使用されます。圧縮解除関数を指定せずに圧縮関数を指定すると、エラーになります。&lt;a href=&quot;fts3#the_compress_and_uncompress_options&quot;&gt;詳細については、以下&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="5836c13f879c56ed967a4394bb1d7a4816e02cd2" translate="yes" xml:space="preserve">
          <source>The compress=, uncompress= and languageid= options are not available. There is as of yet no equivalent for their functionality.</source>
          <target state="translated">compress=,uncompress=,languageid=オプションは利用できません。これらの機能に相当するものはまだありません。</target>
        </trans-unit>
        <trans-unit id="2469db0ecb30ed655de4891189661dea5b883567" translate="yes" xml:space="preserve">
          <source>The compression method used to compress the data (an integer). The value 0 indicates that the data is stored in the zip archive without compression. 8 means the raw deflate algorithm.</source>
          <target state="translated">データを圧縮するために使用する圧縮方法(整数)。値0は圧縮せずにZIPアーカイブにデータを保存したことを示します。8は生のデフレーションアルゴリズムを意味します。</target>
        </trans-unit>
        <trans-unit id="c682ba9f6178606617e01c8b48358fa9163f9c2c" translate="yes" xml:space="preserve">
          <source>The computation of local time depends heavily on the whim of politicians and is thus difficult to get correct for all locales. In this implementation, the standard C library function localtime_r() is used to assist in the calculation of local time. The localtime_r() C function normally only works for years between 1970 and 2037. For dates outside this range, SQLite attempts to map the year into an equivalent year within this range, do the calculation, then map the year back.</source>
          <target state="translated">ローカルタイムの計算は政治家の気まぐれに大きく依存しているため、すべてのロケールで正しく計算することは困難です。この実装では、標準的な C ライブラリ関数 localtime_r()を使用してローカルタイムの計算を支援します。localtime_r()C関数は通常、1970年から2037年の間でのみ動作します。この範囲外の日付については、SQLite はその年をこの範囲内の同等の年にマップし、計算を行い、年をマップし直します。</target>
        </trans-unit>
        <trans-unit id="a84ddecfbfcfd1c573cf704dea12a071acade093" translate="yes" xml:space="preserve">
          <source>The concept of fuzz testing has been around for decades, but fuzz testing was not an effective way to find bugs until 2014 when Michal Zalewski invented the first practical profile-guided fuzzer, &lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;American Fuzzy Lop&lt;/a&gt; or &quot;AFL&quot;. Unlike prior fuzzers that blindly generate random inputs, AFL instruments the program being tested (by modifying the assembly-language output from the C compiler) and uses that instrumentation to detect when an input causes the program to do something different - to follow a new control path or loop a different number of times. Inputs that provoke new behavior are retained and further mutated. In this way, AFL is able to &quot;discover&quot; new behaviors of the program under test, including behaviors that were never envisioned by the designers.</source>
          <target state="translated">ファジングテストの概念は何十年も前から存在していましたが、ミハウザレフスキが最初の実用的なプロファイルガイドファジングである&lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;American Fuzzy Lop&lt;/a&gt;または「AFL」を発明した2014年まで、ファジングテストはバグを見つける効果的な方法ではありませんでした。ランダムな入力を盲目的に生成する以前のファザーとは異なり、AFLはテスト対象のプログラムを（Cコンパイラからのアセンブリ言語出力を変更することによって）計測し、その計測を使用して、入力によってプログラムが別のことを実行するタイミングを検出します-新しい制御に従います異なる回数のパスまたはループ。新しい動作を引き起こす入力は保持され、さらに変更されます。このようにして、AFLは、設計者が想定していなかった動作を含む、テスト対象のプログラムの新しい動作を「発見」することができます。</target>
        </trans-unit>
        <trans-unit id="3c788bf48ee2358b78bb00bc56b593bb09c394d8" translate="yes" xml:space="preserve">
          <source>The configure script (on unix) automatically detects pread() and pwrite() and sets compile-time options to use those OS interfaces if they are available.</source>
          <target state="translated">configure スクリプト (unix 上)は pread()と pwrite()を自動的に検出し、それらの OS インターフェイスが利用可能な場合には、それらのインターフェイスを使用するようにコンパイル時のオプションを設定します。</target>
        </trans-unit>
        <trans-unit id="b71509666058777b45e3ddaa4c2923ebc4c7fa2f" translate="yes" xml:space="preserve">
          <source>The configure-make works whether your are building from the canonical sources from the source tree, or from an amalgamated bundle. There are few dependencies. When building from canonical sources, a working &lt;a href=&quot;https://www.tcl.tk/man/tcl8.3/UserCmd/tclsh.htm&quot;&gt;tclsh&lt;/a&gt; is required. If using an amalgamation bundle, all the preprocessing work normally done by tclsh will have already been carried out and only normal build tools are required.</source>
          <target state="translated">configure-makeは、ソースツリーの正規ソースから構築する場合でも、融合バンドルから構築する場合でも機能します。依存関係はほとんどありません。正規のソースからビルドする場合は、機能する&lt;a href=&quot;https://www.tcl.tk/man/tcl8.3/UserCmd/tclsh.htm&quot;&gt;tclsh&lt;/a&gt;が必要です。融合バンドルを使用する場合、通常tclshによって行われるすべての前処理作業はすでに実行されており、通常のビルドツールのみが必要です。</target>
        </trans-unit>
        <trans-unit id="8ac9040eb64152e9af693ac6b3d6353d633a032f" translate="yes" xml:space="preserve">
          <source>The conflict handler is invoked with CHANGESET_DATA as the second argument when processing a DELETE or UPDATE change if a row with the required PRIMARY KEY fields is present in the database, but one or more other (non primary-key) fields modified by the update do not contain the expected &quot;before&quot; values.</source>
          <target state="translated">競合ハンドラは、DELETEまたはUPDATEの変更を処理する際に、CHANGESET_DATAを第2引数に指定して呼び出されます。</target>
        </trans-unit>
        <trans-unit id="23fc4d91796bed566e82459162cebcab0cf84b45" translate="yes" xml:space="preserve">
          <source>The conflict handler is invoked with CHANGESET_NOTFOUND as the second argument when processing a DELETE or UPDATE change if a row with the required PRIMARY KEY fields is not present in the database.</source>
          <target state="translated">必須のPRIMARY KEYフィールドを持つ行がデータベースに存在しない場合、DELETEまたはUPDATEの変更を処理する際に、CHANGESET_NOTFOUNDを第2引数に指定してコンフリクトハンドラが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="c661dc346561d136d5859295a5527b2af74324a7" translate="yes" xml:space="preserve">
          <source>The conflicting row in this case is the database row with the matching primary key.</source>
          <target state="translated">この場合の競合する行は、一致する主キーを持つデータベース行です。</target>
        </trans-unit>
        <trans-unit id="4298401952abf69332c686d0b1f446ca8e2e6344" translate="yes" xml:space="preserve">
          <source>The conflicting row, in this case, is the database row with the matching primary key.</source>
          <target state="translated">この場合、競合する行は、一致する主キーを持つデータベース行です。</target>
        </trans-unit>
        <trans-unit id="ca62ceaf8e4848fb4512d05da76c6a9337ad0aa5" translate="yes" xml:space="preserve">
          <source>The connection checks if a</source>
          <target state="translated">接続は</target>
        </trans-unit>
        <trans-unit id="72c42ad2c395427b5b34bc215df721de823e8688" translate="yes" xml:space="preserve">
          <source>The connection checks if the data in the</source>
          <target state="translated">のデータがあるかどうかをチェックします。</target>
        </trans-unit>
        <trans-unit id="aed384d7e555153a17ceb13abbd6bca15763f13c" translate="yes" xml:space="preserve">
          <source>The content allows the text being indexed to be stored in a separate table distinct from the FTS4 table, or even outside of SQLite.</source>
          <target state="translated">この内容により、インデックス化されているテキストをFTS4テーブルとは別のテーブルに格納したり、SQLiteの外部に格納したりすることができます。</target>
        </trans-unit>
        <trans-unit id="d6e0eda1c9ea11f507c054ff491306a6eca1ff67" translate="yes" xml:space="preserve">
          <source>The content in the sqlite_stat4 table cannot be computed with anything less than a full scan. Hence, if a non-zero analysis limit is specified, the sqlite_stat4 table is not computed.</source>
          <target state="translated">sqlite_stat4テーブルの内容はフルスキャン以下では計算できません。したがって、ゼロ以外の分析限界が指定された場合、sqlite_stat4テーブルは計算されません。</target>
        </trans-unit>
        <trans-unit id="cbbe292e23fdc57896771b367c267746f39de5b7" translate="yes" xml:space="preserve">
          <source>The content of P3 registers starting at register P2 form an unpacked index key. This opcode removes that entry from the index opened by cursor P1.</source>
          <target state="translated">レジスタP2から始まるレジスタP3の内容は、アンパックされたインデックスキーを形成する。このオペコードは、カーソルP1で開いたインデックスからそのエントリを削除する。</target>
        </trans-unit>
        <trans-unit id="53039aadd3f75ae33d382081b8b5f0e6fd60f4d6" translate="yes" xml:space="preserve">
          <source>The content of an R*Tree index is actually stored in three ordinary SQLite tables with names derived from the name of the R*Tree. These three tables are called &quot;&lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt;&quot;. This is their schema:</source>
          <target state="translated">R * Treeインデックスの内容は、実際にはR * Treeの名前から派生した名前を持つ3つの通常のSQLiteテーブルに格納されます。これらの3つのテーブルは「&lt;a href=&quot;vtab#xshadowname&quot;&gt;シャドウテーブル&lt;/a&gt;」と呼ばれます。これは彼らのスキーマです：</target>
        </trans-unit>
        <trans-unit id="dd5b1eb070f31c8697b621bf1847b35fb7a8adaf" translate="yes" xml:space="preserve">
          <source>The content of each SQL table row is stored in the database file by first combining the values in the various columns into a byte array in the record format, then storing that byte array as the payload in an entry in the table b-tree. The order of values in the record is the same as the order of columns in the SQL table definition. When an SQL table includes an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column (which aliases the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;) then that column appears in the record as a NULL value. SQLite will always use the table b-tree key rather than the NULL value when referencing the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column.</source>
          <target state="translated">各SQLテーブル行の内容は、最初にさまざまな列の値をレコード形式のバイト配列に結合し、次にそのバイト配列をペイロードとしてテーブルbツリーのエントリに格納することにより、データベースファイルに格納されます。レコード内の値の順序は、SQLテーブル定義の列の順序と同じです。 SQLテーブルに&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列（&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWIDの&lt;/a&gt;エイリアス）が含まれている場合、その列はNULL値としてレコードに表示されます。 SQLiteは、&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列を参照するときに、NULL値ではなく常にテーブルのBツリーキーを使用します。</target>
        </trans-unit>
        <trans-unit id="71920b63c9e6445164e490bc0f251a06d6bb693f" translate="yes" xml:space="preserve">
          <source>The content of each rollback journal is flushed to disk both before and after the master journal filename is written into the rollback journal header. It is important to do both of these flushes. Fortunately, the second flush is usually inexpensive since typically only a single page of the journal file (the first page) has changed.</source>
          <target state="translated">各ロールバックジャーナルの内容は、マスタージャーナルのファイル名がロールバックジャーナルヘッダに書き込まれる前と後の両方でディスクにフラッシュされます。この両方のフラッシュを行うことが重要です。幸いなことに、2回目のフラッシュは通常、ジャーナルファイルの1ページ(最初のページ)だけが変更されるため、コストがかかりません。</target>
        </trans-unit>
        <trans-unit id="2c74d571015e1e1c51708cccb3ac9a7ab08632cc" translate="yes" xml:space="preserve">
          <source>The content of each rollback journal is flushed to disk both before and after the super-journal filename is written into the rollback journal header. It is important to do both of these flushes. Fortunately, the second flush is usually inexpensive since typically only a single page of the journal file (the first page) has changed.</source>
          <target state="translated">各ロールバックジャーナルの内容は、スーパージャーナルのファイル名がロールバックジャーナルヘッダに書き込まれる前と後の両方でディスクにフラッシュされます。この両方のフラッシュを行うことが重要です。幸いなことに、2回目のフラッシュは通常、ジャーナルファイルの1ページ(最初のページ)だけが変更されるため、コストがかかりません。</target>
        </trans-unit>
        <trans-unit id="39b372f8730aa69db1fd10c964b137259496c534" translate="yes" xml:space="preserve">
          <source>The content of each slide could still be stored as compressed XML. But now each page is stored separately. So when opening a new document, the application could simply run:</source>
          <target state="translated">各スライドの内容は、まだ圧縮されたXMLとして保存することができました。しかし、今では各ページは別々に保存されています。だから、新しいドキュメントを開くときに、アプリケーションは単に実行することができました。</target>
        </trans-unit>
        <trans-unit id="ef2de54ba7f62420a379fc46c4ab7cf3080ae413" translate="yes" xml:space="preserve">
          <source>The content of the statistics tables can be queried using &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; and can be changed using the &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, and &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; commands. The &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; command works on statistics tables as of SQLite version 3.7.9. (2011-11-01) The &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command does not work on statistics tables. Appropriate care should be used when changing the content of the statistics tables as invalid content can cause SQLite to select inefficient query plans. Generally speaking, one should not modify the content of the statistics tables by any mechanism other than invoking the ANALYZE command. See &quot;&lt;a href=&quot;optoverview#manctrl&quot;&gt;Manual Control Of Query Plans Using SQLITE_STAT Tables&lt;/a&gt;&quot; for further information.</source>
          <target state="translated">統計テーブルの内容は、&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;を使用して照会でき、&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;、&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;、および&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;コマンドを使用して変更できます。&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLEの&lt;/a&gt;コマンドはSQLiteバージョン3.7.9のよう統計表上で動作します。 （2011-11-01）&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;コマンドは統計テーブルでは機能しません。統計テーブルのコンテンツを変更する場合は、無効なコンテンツが原因でSQLiteが非効率的なクエリプランを選択する可能性があるため、適切な注意が必要です。一般的に言えば、ANALYZEコマンドを呼び出す以外のメカニズムで統計テーブルの内容を変更しないでください。詳細については、「&lt;a href=&quot;optoverview#manctrl&quot;&gt;SQLITE_STATテーブルを使用したクエリプランの手動制御&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="cb0bc8e6cf7e707512464168a8333cd25f0f7228" translate="yes" xml:space="preserve">
          <source>The content option allows FTS4 to forego storing the text being indexed. The content option can be used in two ways:</source>
          <target state="translated">内容オプシ ョ ンは、 FTS4 が イ ンデ ッ ク ス さ れてい る テ キ ス ト を保存 し ない よ う にす る こ と を可能に し ます。content オプシ ョ ンは 2 つの方法で使えます。</target>
        </trans-unit>
        <trans-unit id="50fd4cd87f476ff7994844fe209f20e1e61a3e92" translate="yes" xml:space="preserve">
          <source>The content table may also be queried as follows:</source>
          <target state="translated">また、コンテンツテーブルは、以下のように問い合わせてもよい。</target>
        </trans-unit>
        <trans-unit id="43da535bae3bfe186441cea4bad1d427988c63d1" translate="yes" xml:space="preserve">
          <source>The contents of a changeset may be traversed using an iterator created using the &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt; API. A changeset may be applied to a database with a compatible schema using the &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; API.</source>
          <target state="translated">変更セットの内容は、&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt; API を使用して作成されたイテレーターを使用してトラバースできます。変更セットは、&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt; API を使用して、互換性のあるスキーマを持つデータベースに適用できます。</target>
        </trans-unit>
        <trans-unit id="d1fc4719b451a2f189cbf09b3af719ceaa1455fd" translate="yes" xml:space="preserve">
          <source>The contents of a changeset may be traversed using an iterator created using the &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt; API. A changeset may be applied to a database with a compatible schema using the &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; API.</source>
          <target state="translated">変更セットの内容は、&lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start（）&lt;/a&gt; API を使用して作成されたイテレーターを使用してトラバースできます。変更セットは、&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply（）&lt;/a&gt; API を使用して、互換性のあるスキーマを持つデータベースに適用できます。</target>
        </trans-unit>
        <trans-unit id="17197a14b8f9ff583e2fbe7ec6a33d12aff2f981" translate="yes" xml:space="preserve">
          <source>The contents of an SQLite database file are formatted as a set of fixed size pages. See</source>
          <target state="translated">SQLite データベースファイルの内容は、固定サイズのページのセットとしてフォーマットされています。以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="6741b03ffce89c3a2ca3addb1cadccc791915ce5" translate="yes" xml:space="preserve">
          <source>The contents of columns qualified with the UNINDEXED column option are not added to the FTS index. This means that for the purposes of MATCH queries and &lt;a href=&quot;fts5#_auxiliary_functions_&quot;&gt;FTS5 auxiliary functions&lt;/a&gt;, the column contains no matchable tokens.</source>
          <target state="translated">UNINDEXED列オプションで修飾された列の内容は、FTSインデックスに追加されません。これは、MATCHクエリと&lt;a href=&quot;fts5#_auxiliary_functions_&quot;&gt;FTS5補助関数&lt;/a&gt;の目的で、列に一致するトークンが含まれていないことを意味します。</target>
        </trans-unit>
        <trans-unit id="f4381b2c97365bdc1448864c183789c2d75a4c76" translate="yes" xml:space="preserve">
          <source>The contents of the logical full-text index is found by merging the contents of all segment b-trees. If a term is present in more than one segment b-tree, then it maps to the union of each individual doclist. If, for a single term, the same docid occurs in more than one doclist, then only the doclist that is part of the most recently created segment b-tree is considered valid.</source>
          <target state="translated">論理的な全文インデックスの内容は、すべてのセグメント b-tree の内容をマージすることで発見されます。ある用語が複数のセグメント b ツリーに存在する場合、それは各個別の doclist の和にマッピングされます。一つの用語について、同じ docid が複数の doclist に存在する場合は、最近作成されたセグメント b ツリーの一部である doclist のみが有効とみなされます。</target>
        </trans-unit>
        <trans-unit id="603ef17ea7e8b979fdc97587b739002125ee3a17" translate="yes" xml:space="preserve">
          <source>The contents of the sqlite3_pcache_methods2 structure are copied to an internal buffer by SQLite within the call to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;. Hence the application may discard the parameter after the call to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; returns.</source>
          <target state="translated">sqlite3_pcache_methods2構造の内容は、への呼び出し内のSQLiteによって内部バッファにコピーされ&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;。したがって、&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;への呼び出しが戻った後、アプリケーションはパラメーターを破棄する可能性があります。</target>
        </trans-unit>
        <trans-unit id="d33c4566f4b0045dff066d31694e73d46d2bf6db" translate="yes" xml:space="preserve">
          <source>The contents of the sqlite3_pcache_methods2 structure are copied to an internal buffer by SQLite within the call to &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;. Hence the application may discard the parameter after the call to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; returns.</source>
          <target state="translated">sqlite3_pcache_methods2構造の内容は、への呼び出し内のSQLiteによって内部バッファにコピーされ&lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;。したがって、&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;への呼び出しが戻った後、アプリケーションはパラメーターを破棄する可能性があります。</target>
        </trans-unit>
        <trans-unit id="1e184948fbfc41a2f2c0c14809d37c70c80c03a2" translate="yes" xml:space="preserve">
          <source>The context in which an SQL function executes is stored in an sqlite3_context object. A pointer to an sqlite3_context object is always first parameter to &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;. The application-defined SQL function implementation will pass this pointer through into calls to &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_get_auxdata()&lt;/a&gt;, and/or &lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt;.</source>
          <target state="translated">SQL関数が実行されるコンテキストは、sqlite3_contextオブジェクトに格納されます。sqlite3_contextオブジェクトへのポインターは、常に&lt;a href=&quot;#sqlite3_create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;への最初のパラメーターです。アプリケーション定義のSQL関数実装は、このポインターを&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_aggregate_context&quot;&gt;sqlite3_aggregate_context（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_context_db_handle&quot;&gt;sqlite3_context_db_handle（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_get_auxdata（）&lt;/a&gt;、または&lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_set_auxdata（）&lt;/a&gt;への呼び出しに渡します。</target>
        </trans-unit>
        <trans-unit id="eb189ce529b8d7d0045783021bb7d8fd77526437" translate="yes" xml:space="preserve">
          <source>The context in which an SQL function executes is stored in an sqlite3_context object. A pointer to an sqlite3_context object is always first parameter to &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;. The application-defined SQL function implementation will pass this pointer through into calls to &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result()&lt;/a&gt;, &lt;a href=&quot;aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt;, &lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;, &lt;a href=&quot;context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt;, &lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_get_auxdata()&lt;/a&gt;, and/or &lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt;.</source>
          <target state="translated">SQL関数が実行されるコンテキストは、sqlite3_contextオブジェクトに格納されます。sqlite3_contextオブジェクトへのポインターは、常に&lt;a href=&quot;../appfunc&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;への最初のパラメーターです。アプリケーション定義のSQL関数の実装は、このポインターを&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result（）&lt;/a&gt;、&lt;a href=&quot;aggregate_context&quot;&gt;sqlite3_aggregate_context（）&lt;/a&gt;、&lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data（）&lt;/a&gt;、&lt;a href=&quot;context_db_handle&quot;&gt;sqlite3_context_db_handle（）&lt;/a&gt;、&lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_get_auxdata（）&lt;/a&gt;、および/または&lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_set_auxdata（）の呼び出しに渡し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="53fb8a37d043abdf36747b3ab57dd8a44c62d486" translate="yes" xml:space="preserve">
          <source>The context in which an SQL function executes is stored in an sqlite3_context object. A pointer to an sqlite3_context object is always first parameter to &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;. The application-defined SQL function implementation will pass this pointer through into calls to &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_get_auxdata()&lt;/a&gt;, and/or &lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt;.</source>
          <target state="translated">SQL関数が実行されるコンテキストは、sqlite3_contextオブジェクトに格納されます。sqlite3_contextオブジェクトへのポインターは、常に&lt;a href=&quot;appfunc&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;への最初のパラメーターです。アプリケーション定義のSQL関数の実装は、このポインターを&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_aggregate_context&quot;&gt;sqlite3_aggregate_context（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_context_db_handle&quot;&gt;sqlite3_context_db_handle（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_get_auxdata（）&lt;/a&gt;、および/または&lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_set_auxdata（）の呼び出しに渡し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="f7c0cad9919ee775dcafe683809a8efa13aeacfd" translate="yes" xml:space="preserve">
          <source>The context in which an SQL function executes is stored in an sqlite3_context object. A pointer to an sqlite3_context object is always first parameter to &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;. The application-defined SQL function implementation will pass this pointer through into calls to &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result()&lt;/a&gt;, &lt;a href=&quot;aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt;, &lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;, &lt;a href=&quot;context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt;, &lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_get_auxdata()&lt;/a&gt;, and/or &lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt;.</source>
          <target state="translated">SQL関数が実行されるコンテキストは、sqlite3_contextオブジェクトに格納されます。sqlite3_contextオブジェクトへのポインターは、常に&lt;a href=&quot;create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;への最初のパラメーターです。アプリケーション定義のSQL関数実装は、このポインターを&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result（）&lt;/a&gt;、&lt;a href=&quot;aggregate_context&quot;&gt;sqlite3_aggregate_context（）&lt;/a&gt;、&lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data（）&lt;/a&gt;、&lt;a href=&quot;context_db_handle&quot;&gt;sqlite3_context_db_handle（）&lt;/a&gt;、&lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_get_auxdata（）&lt;/a&gt;、または&lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_set_auxdata（）&lt;/a&gt;への呼び出しに渡します。</target>
        </trans-unit>
        <trans-unit id="2dc88bed6dbd7abe62664d54e6bdaf4f83cf04fb" translate="yes" xml:space="preserve">
          <source>The copy is edited to change the branch instruction into either a no-op or an unconditional jump.</source>
          <target state="translated">コピーを編集して、分岐命令を無停止または無条件ジャンプに変更します。</target>
        </trans-unit>
        <trans-unit id="cb1935e51d150180f58869cd5c4365f67de7c57a" translate="yes" xml:space="preserve">
          <source>The copy method implements similar functionality to the &lt;b&gt;.import&lt;/b&gt; SQLite shell command.</source>
          <target state="translated">copyメソッドは、&lt;b&gt;.import&lt;/b&gt; SQLiteシェルコマンドと同様の機能を実装します。</target>
        </trans-unit>
        <trans-unit id="7d3c9b74d67dc166ca8e07aaa910e143f4d6cf96" translate="yes" xml:space="preserve">
          <source>The copy of sqlite3.s is assembled into sqlite3.o then linked again th3.o to generate the &quot;th3&quot; executable.</source>
          <target state="translated">sqlite3.sのコピーをsqlite3.oに組み立て、th3.oをリンクして &quot;th3 &quot;の実行ファイルを生成します。</target>
        </trans-unit>
        <trans-unit id="b047a98a10f78ed2613ab80ee6fd529ee912f70f" translate="yes" xml:space="preserve">
          <source>The core functions shown below are available by default. &lt;a href=&quot;lang_datefunc&quot;&gt;Date &amp;amp; Time functions&lt;/a&gt;, &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate functions&lt;/a&gt;, &lt;a href=&quot;windowfunctions#biwinfunc&quot;&gt;window functions&lt;/a&gt;, and &lt;a href=&quot;json1&quot;&gt;JSON functions&lt;/a&gt; are documented separately. An application may define additional functions written in C and added to the database engine using the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; API.</source>
          <target state="translated">以下に示すコア機能は、デフォルトで使用可能です。&lt;a href=&quot;lang_datefunc&quot;&gt;日付と時刻の関数&lt;/a&gt;、&lt;a href=&quot;lang_aggfunc&quot;&gt;集計関数&lt;/a&gt;、&lt;a href=&quot;windowfunctions#biwinfunc&quot;&gt;ウィンドウ関数&lt;/a&gt;、&lt;a href=&quot;json1&quot;&gt;JSON関数&lt;/a&gt;については、個別に説明しています。アプリケーションは、Cで記述され、&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt; API を使用してデータベースエンジンに追加される追加の関数を定義できます。</target>
        </trans-unit>
        <trans-unit id="a7002ce76e139b64c91049472e1737291c84c664" translate="yes" xml:space="preserve">
          <source>The core idea is to create a special table (named &quot;UNDOLOG&quot; in the example) that holds information needed to undo/redo changes to the database. For each class (table) in the database that wants to participate in the undo/redo, triggers are created that cause entries to be made in the UNDOLOG table for each DELETE, INSERT, and UPDATE of the participating class. The UNDOLOG entries consist of ordinary SQL statements the can be played back to reverse the changes.</source>
          <target state="translated">中心となるのは、データベースの変更を元に戻したり、やり直したりするために必要な情報を保持する特別なテーブル(この例では &quot;UNDOLOG &quot;という名前)を作成することです。元に戻す/やり直しに参加したいデータベースの各クラス(テーブル)に対して、参加しているクラスのDELETE、INSERT、UPDATEごとにUNDOLOGテーブルにエントリを作成するトリガーを作成します。UNDOLOGのエントリは通常のSQL文で構成されており、変更を元に戻すために再生することができます。</target>
        </trans-unit>
        <trans-unit id="b4619c14d9f61ffdd467d39188a12cbd3dab6b8b" translate="yes" xml:space="preserve">
          <source>The core of a SELECT statement is a &quot;simple SELECT&quot; shown by the &lt;a href=&quot;syntax/select-core&quot;&gt;select-core&lt;/a&gt; and &lt;a href=&quot;syntax/simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt; syntax diagrams below. In practice, most SELECT statements are simple SELECT statements.</source>
          <target state="translated">SELECTステートメントのコアは、以下の&lt;a href=&quot;syntax/select-core&quot;&gt;select-core&lt;/a&gt;および&lt;a href=&quot;syntax/simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;構文図で示されている「単純なSELECT」です。実際には、ほとんどのSELECTステートメントは単純なSELECTステートメントです。</target>
        </trans-unit>
        <trans-unit id="202f127cc642aea639fbf4c524ee9db3a310c986" translate="yes" xml:space="preserve">
          <source>The core query used to generate the branch timeline is shown below. (Readers are not expected to understand the details of this query. Commentary will follow.)</source>
          <target state="translated">ブランチタイムラインを生成するために使用されるコアクエリを以下に示します。(読者はこのクエリの詳細を理解する必要はありません。解説は後ほど)</target>
        </trans-unit>
        <trans-unit id="ca59f51d09381d1b3447776404c915b9169882ab" translate="yes" xml:space="preserve">
          <source>The core string formatting routine is the sqlite3VXPrintf() function found in the &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt; source file. All the various interfaces invoke (sometimes indirectly) this one core function. The sqlite3VXPrintf() function began as code written by the first author of SQLite (&lt;a href=&quot;https://sqlite.org/crew.html&quot;&gt;Hipp&lt;/a&gt;) when he was a graduate student a Duke University in the late 1980s. Hipp kept this printf() implementation in his personal toolbox until he started working on SQLite in 2000. The code was incorporated into the SQLite source tree on &lt;a href=&quot;https://sqlite.org/src/timeline?c=f9372072a6&quot;&gt;2000-10-08&lt;/a&gt; for SQLite version 1.0.9.</source>
          <target state="translated">コア文字列フォーマットルーチンは、&lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt;ソースファイルにあるsqlite3VXPrintf（）関数です。さまざまなインターフェースすべてが、この1つのコア機能を（時には間接的に）呼び出します。 sqlite3VXPrintf（）関数は、SQLiteの最初の作者（&lt;a href=&quot;https://sqlite.org/crew.html&quot;&gt;Hipp&lt;/a&gt;）が1980年代後半にデューク大学の大学院生であったときにコードとして書き始めました。 Hippは、2000年にSQLiteの作業を開始するまで、このprintf（）実装を自分のツールボックスに保持しました。コードは、SQLiteバージョン&lt;a href=&quot;https://sqlite.org/src/timeline?c=f9372072a6&quot;&gt;1.0.9の2000-10-08に&lt;/a&gt; SQLiteソースツリーに組み込まれました。</target>
        </trans-unit>
        <trans-unit id="093b78a42e1ecfed114ac694aeda4be18d47e5e9" translate="yes" xml:space="preserve">
          <source>The cost table can be named anything you want - it does not have to be called &quot;editcost&quot;. And the table can contain additional columns. The only requirement is that the table must contain the four columns show above, with exactly the names shown.</source>
          <target state="translated">コストテーブルには、好きな名前をつけることができます-&quot;editcost &quot;という名前である必要はありません。そして、テーブルには追加のカラムを含めることができます。唯一の要件は、上記の4つのカラムをテーブルに含まなければならないということです。</target>
        </trans-unit>
        <trans-unit id="ab3b915916ad100c2de3d193cbc3d8e54968ac9c" translate="yes" xml:space="preserve">
          <source>The costs are comprised of multiple numbers, not a single number as shown in the graph. SQLite computes several different estimated costs for each loop that apply at different times. For example, there is a &quot;setup&quot; cost that is incurred just once when the query starts. The setup cost is the cost of computing an &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic index&lt;/a&gt; for a table that does not already have an index. Then there is the cost of running each step of the loop. Finally, there is an estimate of the number rows generated by the loop, which is information needed in estimating the costs of inner loops. Sorting costs may come into play if the query has an ORDER BY clause.</source>
          <target state="translated">コストは、グラフに示されている単一の数値ではなく、複数の数値で構成されています。 SQLiteは、ループごとに異なる時間に適用されるいくつかの異なる推定コストを計算します。たとえば、クエリの開始時に一度だけ発生する「セットアップ」コストがあります。セットアップコストは、まだインデックスを持たないテーブルの&lt;a href=&quot;optoverview#autoindex&quot;&gt;自動インデックス&lt;/a&gt;を計算するコストです。次に、ループの各ステップを実行するコストがあります。最後に、ループによって生成された行数の見積もりがあります。これは、内部ループのコストを見積もるのに必要な情報です。クエリにORDER BY句がある場合、並べ替えコストが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="19bc3b9522f26a7b0a814b17b06d2223be3c56f5" translate="yes" xml:space="preserve">
          <source>The count(X) function returns a count of the number of times that</source>
          <target state="translated">count(X)関数は</target>
        </trans-unit>
        <trans-unit id="e3944d86225bf50f66350ca2264ab4a84abeb87d" translate="yes" xml:space="preserve">
          <source>The cov1 test set used to obtain 100% branch test coverage are only a subset of the tests currently implemented using TH3. New test modules are added on a regular basis.</source>
          <target state="translated">100% ブランチテストのカバレッジを得るために使用されている cov1 テストセットは、TH3 を使用して現在実装されているテストのサブセットに過ぎません。新しいテストモジュールは定期的に追加されています。</target>
        </trans-unit>
        <trans-unit id="d677c2d682d4dade2e8fc2faf6167d79dbe61f08" translate="yes" xml:space="preserve">
          <source>The crash tests in SQLite have discovered a number of very subtle bugs (now fixed) in the recovery mechanism. Some of these bugs were very obscure and unlikely to have been found using only code inspection and analysis techniques. From this experience, the developers of SQLite feel confident that any other database system that does not use a similar crash test system likely contains undetected bugs that will lead to database corruption following a system crash or power failure.</source>
          <target state="translated">SQLiteのクラッシュテストでは、リカバリ機構に非常に微妙なバグがいくつか発見されました(現在は修正されています)。これらのバグの中には非常に不明瞭なものもあり、コードの検査や解析技術だけでは発見できそうにないものもありました。この経験から、SQLiteの開発者は、同様のクラッシュテストシステムを使用していない他のデータベースシステムには、システムクラッシュや停電の後にデータベースが破損するような未検出のバグが含まれている可能性が高いと確信しています。</target>
        </trans-unit>
        <trans-unit id="33ac0d26d4e9c7d412c89e095055cacaebdbb563" translate="yes" xml:space="preserve">
          <source>The cumulative distribution. Calculated as</source>
          <target state="translated">累積分布です として計算されます。</target>
        </trans-unit>
        <trans-unit id="9f3f4c9ed1a83693cad288a8dbbe975dd262d497" translate="yes" xml:space="preserve">
          <source>The current implementation of SQLite uses only loop joins. That is to say, joins are implemented as nested loops.</source>
          <target state="translated">現在のSQLiteの実装では、ループ結合のみを使用しています。つまり、結合は入れ子になったループとして実装されています。</target>
        </trans-unit>
        <trans-unit id="0595dd468ba4f2594b89c18514e0ce47ff0d0c46" translate="yes" xml:space="preserve">
          <source>The current implementation of this JSON library uses a recursive descent parser. In order to avoid using excess stack space, any JSON input that has more than 2000 levels of nesting is considered invalid. Limits on nesting depth are allowed for compatible implementations of JSON by &lt;a href=&quot;https://tools.ietf.org/html/rfc7159#section-9&quot;&gt;RFC-7159 section 9&lt;/a&gt;.</source>
          <target state="translated">このJSONライブラリの現在の実装では、再帰的降下パーサーが使用されています。過剰なスタックスペースの使用を回避するために、入れ子のレベルが2000を超えるJSON入力は無効と見なされます。&lt;a href=&quot;https://tools.ietf.org/html/rfc7159#section-9&quot;&gt;RFC-7159セクション9&lt;/a&gt;により、JSONの互換性のある実装に対してネスト深度の制限が許可されています。</target>
        </trans-unit>
        <trans-unit id="1859423b8976d8bfae8dfc344c1935671c660093" translate="yes" xml:space="preserve">
          <source>The current implementation will only support a string or BLOB length up to 2&lt;small&gt;&lt;sup&gt;31&lt;/sup&gt;&lt;/small&gt;-1 or 2147483647. And some built-in functions such as hex() might fail well before that point. In security-sensitive applications it is best not to try to increase the maximum string and blob length. In fact, you might do well to lower the maximum string and blob length to something more in the range of a few million if that is possible.</source>
          <target state="translated">現在の実装では、2 &lt;small&gt;&lt;sup&gt;31&lt;/sup&gt;&lt;/small&gt; -1または2147483647 までの文字列またはBLOBの長さのみがサポートされます。また、hex（）などの一部の組み込み関数は、その時点よりかなり前に失敗する可能性があります。セキュリティを重視するアプリケーションでは、文字列とBLOBの最大長を増やそうとしないのが最善です。実際、可能であれば、文字列とBLOBの最大長を数百万の範囲に減らすことができます。</target>
        </trans-unit>
        <trans-unit id="ce671671108a214d3061700585cfbe08230e46de" translate="yes" xml:space="preserve">
          <source>The current row. For RANGE and GROUPS frame types, peers of the current row are also included in the frame, unless specifically excluded by the EXCLUDE clause. This is true regardless of whether CURRENT ROW is used as the starting or ending frame boundary.</source>
          <target state="translated">現在の行。RANGEおよびGROUPSフレームタイプの場合、EXCLUDE句によって特に除外されない限り、現在の行のピアもフレームに含まれます。これは、CURRENT ROWがフレームの開始または終了の境界として使用されているかどうかにかかわらず、真です。</target>
        </trans-unit>
        <trans-unit id="bd2930f3fd3f6f19fc9ada96c54055098b67532e" translate="yes" xml:space="preserve">
          <source>The current value of the requested parameter is written into *pCur and the highest instantaneous value is written into *pHiwtr. If the resetFlg is true, then the highest instantaneous value is reset back down to the current value.</source>
          <target state="translated">要求されたパラメータの現在値が *pCur に書き込まれ、最高瞬間値が *pHiwtr に書き込まれます。resetFlgが真の場合、最高瞬間値は現在の値にリセットされます。</target>
        </trans-unit>
        <trans-unit id="b3c10a59b750c785e72b4dc21d7b05d270490210" translate="yes" xml:space="preserve">
          <source>The current working directory (&quot;.&quot;)</source>
          <target state="translated">現在の作業ディレクトリ(&quot;.)</target>
        </trans-unit>
        <trans-unit id="34c8be248703e890d36c7a3af0b628d68ce8275b" translate="yes" xml:space="preserve">
          <source>The current writer concludes its transaction, OR</source>
          <target state="translated">現在のライターは、そのトランザクションを終了します。</target>
        </trans-unit>
        <trans-unit id="d429ef679ef6041cdac168ab25fbc584b8f7c9d4" translate="yes" xml:space="preserve">
          <source>The cycle above can be repeated many times. The diagram shows a third SQLite release, 3.6.17 in circle (6). The private branch maintainer can do another merge in order to incorporate the changes moving from (4) to (6) into the private branch, resulting in version (7).</source>
          <target state="translated">上記のサイクルを何度も繰り返すことができます。この図では、3番目のSQLiteリリースである3.6.17を円(6)で示しています。プライベートブランチのメンテナは、(4)から(6)に移動した変更をプライベートブランチに組み込むために、別のマージを行うことができ、結果としてバージョン(7)が得られます。</target>
        </trans-unit>
        <trans-unit id="8810808ac8350e84a24599fba1a1c44e6d0fc9da" translate="yes" xml:space="preserve">
          <source>The cycle counts provided by cachegrind are a good proxy for actual performance, but they are not 100% accurate.</source>
          <target state="translated">cachegrindが提供するサイクルカウントは実際のパフォーマンスの良い代理ですが、100%正確ではありません。</target>
        </trans-unit>
        <trans-unit id="fac9319a6ade67af6ca8dc4d7c432433a5c8d584" translate="yes" xml:space="preserve">
          <source>The data and method columns may also be set as described for an INSERT above.</source>
          <target state="translated">また、データ列とメソッド列は、上記のINSERTで説明したように設定することもできます。</target>
        </trans-unit>
        <trans-unit id="062b3a0f8f6a4c6911f0379b0878b031acaf0a51" translate="yes" xml:space="preserve">
          <source>The data for a table b-tree leaf page and the key of an index b-tree page was characterized above as an arbitrary sequence of bytes. The prior discussion mentioned one key being less than another, but did not define what &quot;less than&quot; meant. The current section will address these omissions.</source>
          <target state="translated">テーブルb-treeリーフページのデータとインデックスb-treeページのキーは、任意のバイト列として上記で特徴付けられていた。先の議論では、あるキーが別のキーよりも小さいことに言及していたが、&quot;less than &quot;が何を意味するのかを定義していなかった。現在のセクションでは、これらの省略に対処する。</target>
        </trans-unit>
        <trans-unit id="b9c10539b9c59116b81ff7089713236e6e1327e8" translate="yes" xml:space="preserve">
          <source>The data for rowid tables is stored as a B-Tree structure containing one entry for each table row, using the rowid value as the key. This means that retrieving or sorting records by rowid is fast. Searching for a record with a specific rowid, or for all records with rowids within a specified range is around twice as fast as a similar search made by specifying any other PRIMARY KEY or indexed value.</source>
          <target state="translated">rowidテーブルのデータは、rowid値をキーにして、テーブルの行ごとに1つのエントリを含むB-Tree構造として格納されます。このため、rowid によるレコードの検索やソートが高速に行えます。特定の rowid を持つレコード、または指定した範囲内の rowid を持つすべてのレコードを検索する場合は、他の PRIMARY KEY やインデックス値を指定して検索する場合に比べて約 2 倍の速度で検索できます。</target>
        </trans-unit>
        <trans-unit id="8f8b09e33f29c0f7e2cdc53d761f0421d3f8a545" translate="yes" xml:space="preserve">
          <source>The data_% table must have all the same columns as the target table, plus one additional column named &quot;rbu_control&quot;. The data_% table should have no PRIMARY KEY or UNIQUE constraints, but each column should have the same type as the corresponding column in the target database. The rbu_control column should have no type at all. For example, if the target database contains:</source>
          <target state="translated">data_% テーブルには、ターゲット・テーブルと同じすべての列に加えて、&quot;rbu_control&quot; という名前の列が 1 つ追加されている必要があります。data_% テーブルには PRIMARY KEY 制約や UNIQUE 制約はありませんが、各列はターゲット・データベースの対応する列と同じ型を持つ必要があります。rbu_control カラムは全く型を持たない必要があります。例えば、ターゲット・データベースに</target>
        </trans-unit>
        <trans-unit id="17bee7a4a210b94f9cd35ef19e344d890d514950" translate="yes" xml:space="preserve">
          <source>The data_% tables may be created as follows:</source>
          <target state="translated">data_%テーブルは、以下のように作成することができます。</target>
        </trans-unit>
        <trans-unit id="d8fc42980131b74512111cf667ced537b6faec1f" translate="yes" xml:space="preserve">
          <source>The data_% tables themselves should have no PRIMARY KEY declarations. However, RBU is more efficient if reading the rows in from each data_% table in &quot;rowid&quot; order is roughly the same as reading them sorted by the PRIMARY KEY of the corresponding target database table. In other words, rows should be sorted using the destination table PRIMARY KEY fields before they are inserted into the data_% tables.</source>
          <target state="translated">data_%テーブル自体はPRIMARY KEY宣言を持たないはずです。しかし、RBUは、各data_%テーブルから &quot;rowid &quot;の順序で行を読み込むことが、対応するターゲット・データベース・テーブルのPRIMARY KEYでソートされた行を読み込むこととほぼ同じであれば、より効率的である。言い換えれば、行はdata_%テーブルに挿入される前に、宛先テーブルのPRIMARY KEYフィールドを使用してソートされるべきである。</target>
        </trans-unit>
        <trans-unit id="0e861495335228dd9715b8957c822d148379befb" translate="yes" xml:space="preserve">
          <source>The data_ccc table may then be populated as normal with the updates intended for target database table ccc. The same updates will be read by RBU from the data0_ccc_fts view and applied to FTS table ccc_fts. Because &quot;data0_ccc_fts&quot; is smaller than &quot;data_ccc&quot;, the FTS table will be updated first, as required.</source>
          <target state="translated">その後、data_cccテーブルには、通常通り、ターゲット・データベース・テーブルccc用の更新が入力されます。同じ更新は、RBUによってdata0_ccc_ftsビューから読み出され、FTSテーブルccc_ftsに適用されます。data0_ccc_fts」は「data_ccc」よりも小さいため、必要に応じてFTSテーブルが最初に更新される。</target>
        </trans-unit>
        <trans-unit id="7a9df4aba808f0f7f287daab1202c053d1ad5c81" translate="yes" xml:space="preserve">
          <source>The database being vacuumed may not be in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">バキュームされるデータベースが&lt;a href=&quot;wal&quot;&gt;WALモード&lt;/a&gt;ではない可能性があります。</target>
        </trans-unit>
        <trans-unit id="d1f84e31daf7f78443fa69ada7a9a8e535388ab9" translate="yes" xml:space="preserve">
          <source>The database connection can be changed between full and incremental autovacuum mode at any time. However, changing from &quot;none&quot; to &quot;full&quot; or &quot;incremental&quot; can only occur when the database is new (no tables have yet been created) or by running the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command. To change auto-vacuum modes, first use the auto_vacuum pragma to set the new desired mode, then invoke the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command to reorganize the entire database file. To change from &quot;full&quot; or &quot;incremental&quot; back to &quot;none&quot; always requires running &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; even on an empty database.</source>
          <target state="translated">データベース接続は、フルバキュームモードとインクリメンタル自動バキュームモードの間でいつでも変更できます。ただし、「none」から「full」または「incremental」への変更は、データベースが新しい場合（テーブルがまだ作成されていない場合）または&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;コマンドを実行したときにのみ発生します。自動バキュームモードを変更するには、最初にauto_vacuumプラグマを使用して新しい目的のモードを設定し、次に&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;コマンドを呼び出してデータベースファイル全体を再編成します。「フル」または「インクリメンタル」から「なし」に戻すには、空のデータベースでも常に&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUMを&lt;/a&gt;実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="3e8669da1288d64c48a1d4da77efa2cfbe93e717" translate="yes" xml:space="preserve">
          <source>The database connection is opened using the &lt;a href=&quot;uri#uriimmutable&quot;&gt;immutable query parameter&lt;/a&gt;.</source>
          <target state="translated">データベース接続は、&lt;a href=&quot;uri#uriimmutable&quot;&gt;不変のクエリパラメータ&lt;/a&gt;を使用して開かれます。</target>
        </trans-unit>
        <trans-unit id="17dc502f4a596e5beade9b059c41722a7380dd5f" translate="yes" xml:space="preserve">
          <source>The database file format is unchanged for WAL mode. However, the WAL file and the &lt;a href=&quot;walformat#shm&quot;&gt;wal-index&lt;/a&gt; are new concepts and so older versions of SQLite will not know how to recover a crashed SQLite database that was operating in WAL mode when the crash occurred. To prevent older versions of SQLite (prior to version 3.7.0, 2010-07-22) from trying to recover a WAL-mode database (and making matters worse) the database file format version numbers (bytes 18 and 19 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;) are increased from 1 to 2 in WAL mode. Thus, if an older version of SQLite attempts to connect to an SQLite database that is operating in WAL mode, it will report an error along the lines of &quot;file is encrypted or is not a database&quot;.</source>
          <target state="translated">WALモードのデータベースファイル形式は変更されていません。ただし、WALファイルと&lt;a href=&quot;walformat#shm&quot;&gt;wal-index&lt;/a&gt;は新しい概念であるため、SQLiteの古いバージョンでは、クラッシュが発生したときにWALモードで動作していたクラッシュしたSQLiteデータベースを回復する方法がわかりません。SQLiteの古いバージョン（バージョン3.7.0、2010-07-22より前）がWALモードのデータベースを回復しようとする（さらに悪いことに）のを防ぐには、データベースファイル形式のバージョン番号（&lt;a href=&quot;fileformat2#database_header&quot;&gt;データベースヘッダーの&lt;/a&gt;バイト18および19））は、WALモードで1から2に増加します。したがって、古いバージョンのSQLiteがWALモードで動作しているSQLiteデータベースに接続しようとすると、「ファイルが暗号化されているか、データベースではない」というエラーが報告されます。</target>
        </trans-unit>
        <trans-unit id="9c1329ad6c1d5d5a9b13da19601459b465ae67ba" translate="yes" xml:space="preserve">
          <source>The database file format is unchanged.</source>
          <target state="translated">データベースのファイル形式は変更されていません。</target>
        </trans-unit>
        <trans-unit id="1d07edfc3d0d439a4f2d02bad68d889bf985841b" translate="yes" xml:space="preserve">
          <source>The database file header</source>
          <target state="translated">データベースファイルのヘッダ</target>
        </trans-unit>
        <trans-unit id="042540519692f217502c3ae945ec1187e2e057d0" translate="yes" xml:space="preserve">
          <source>The database file is synced to ensure that all updates are stored safely on the persistent media.</source>
          <target state="translated">データベースファイルは、すべての更新が永続的なメディアに安全に保存されるように同期されます。</target>
        </trans-unit>
        <trans-unit id="e23d0cd874d4749bf56cbe1f6d077df68f5dc7f5" translate="yes" xml:space="preserve">
          <source>The database file is unlocked.</source>
          <target state="translated">データベースファイルのロックが解除されています。</target>
        </trans-unit>
        <trans-unit id="0b3f3d4ba2117afe864ef2e2e3855b3dd6cb1ace" translate="yes" xml:space="preserve">
          <source>The database filename is not allowed to be a symbolic link</source>
          <target state="translated">データベースのファイル名はシンボリックリンクにすることはできません。</target>
        </trans-unit>
        <trans-unit id="6f5b1b36f625c53227300ca5232e63d1f84ef897" translate="yes" xml:space="preserve">
          <source>The database for TEMP tables is not created until it is needed.</source>
          <target state="translated">TEMPテーブル用のデータベースは必要になるまで作成されません。</target>
        </trans-unit>
        <trans-unit id="0bdbc9610964d617ffff9c05691c3e95d705203e" translate="yes" xml:space="preserve">
          <source>The database handle must not be in &lt;a href=&quot;#sqlite3_get_autocommit&quot;&gt;autocommit mode&lt;/a&gt;.</source>
          <target state="translated">データベースハンドルを&lt;a href=&quot;#sqlite3_get_autocommit&quot;&gt;自動コミットモードにする&lt;/a&gt;ことはできません。</target>
        </trans-unit>
        <trans-unit id="94abbac71c91061eed5db3642683f70b586a784a" translate="yes" xml:space="preserve">
          <source>The database handle must not be in &lt;a href=&quot;get_autocommit&quot;&gt;autocommit mode&lt;/a&gt;.</source>
          <target state="translated">データベースハンドルを&lt;a href=&quot;get_autocommit&quot;&gt;自動コミットモードにする&lt;/a&gt;ことはできません。</target>
        </trans-unit>
        <trans-unit id="915d44defd987e4d007442eec15de7482af138fa" translate="yes" xml:space="preserve">
          <source>The database in which the new table is created. Tables may be created in the main database, the temp database, or in any attached database.</source>
          <target state="translated">新しいテーブルが作成されるデータベース。テーブルは、メイン データベース、一時データベース、または任意のアタッチされたデータベースに作成することができます。</target>
        </trans-unit>
        <trans-unit id="f11c35a2d4a1cdd518b7cc45f596b046478c935a" translate="yes" xml:space="preserve">
          <source>The database is modified by the transaction</source>
          <target state="translated">データベースはトランザクション</target>
        </trans-unit>
        <trans-unit id="a60dcb2504ad2ca1f013e489bb243d5fba664847" translate="yes" xml:space="preserve">
          <source>The database is opened &lt;a href=&quot;../sharedcache&quot;&gt;shared cache&lt;/a&gt; disabled, overriding the default shared cache setting provided by &lt;a href=&quot;enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;.</source>
          <target state="translated">データベースが開かれ、&lt;a href=&quot;../sharedcache&quot;&gt;共有キャッシュが&lt;/a&gt;無効になり、&lt;a href=&quot;enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（）&lt;/a&gt;によって提供されるデフォルトの共有キャッシュ設定が上書きされます。</target>
        </trans-unit>
        <trans-unit id="4eaa608858923b8628e324d3b5e39f5d6ac0b6e8" translate="yes" xml:space="preserve">
          <source>The database is opened &lt;a href=&quot;../sharedcache&quot;&gt;shared cache&lt;/a&gt; enabled, overriding the default shared cache setting provided by &lt;a href=&quot;enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;.</source>
          <target state="translated">データベースは&lt;a href=&quot;../sharedcache&quot;&gt;共有キャッシュが&lt;/a&gt;有効になっている状態で開かれ、&lt;a href=&quot;enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（）&lt;/a&gt;によって提供されるデフォルトの共有キャッシュ設定を上書きします。</target>
        </trans-unit>
        <trans-unit id="438e6e4f2464e93327c1c43679960b9033bba769" translate="yes" xml:space="preserve">
          <source>The database is opened &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; disabled, overriding the default shared cache setting provided by &lt;a href=&quot;#sqlite3_enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;.</source>
          <target state="translated">データベースが開かれ、&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュが&lt;/a&gt;無効になり、&lt;a href=&quot;#sqlite3_enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（）&lt;/a&gt;によって提供されるデフォルトの共有キャッシュ設定が上書きされます。</target>
        </trans-unit>
        <trans-unit id="2866aa5f974824c8ab6f079d70d8228fd2d735a8" translate="yes" xml:space="preserve">
          <source>The database is opened &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; enabled, overriding the default shared cache setting provided by &lt;a href=&quot;#sqlite3_enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;.</source>
          <target state="translated">データベースは&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュが&lt;/a&gt;有効になっている状態で開かれ、&lt;a href=&quot;#sqlite3_enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（）&lt;/a&gt;によって提供されるデフォルトの共有キャッシュ設定を上書きします。</target>
        </trans-unit>
        <trans-unit id="0ca1bec50c05a4f92423e17a029876db2e2195fa" translate="yes" xml:space="preserve">
          <source>The database is opened for reading and writing if possible, or reading only if the file is write protected by the operating system. In either case the database must already exist, otherwise an error is returned.</source>
          <target state="translated">データベースは、可能であれば読み込みと書き込みのために開かれ、ファイルがオペレーティングシステムによって書き込み保護されている場合には読み込みのみが行われます。いずれの場合もデータベースは既に存在していなければならず、そうでない場合はエラーが返されます。</target>
        </trans-unit>
        <trans-unit id="9bd4a4b6de8565a3e1cf815b4bc5b9706070cf17" translate="yes" xml:space="preserve">
          <source>The database is opened for reading and writing, and is created if it does not already exist. This is the behavior that is always used for sqlite3_open() and sqlite3_open16().</source>
          <target state="translated">データベースは読み書きのためにオープンされ、まだ存在しない場合は作成されます。これはsqlite3_open()とsqlite3_open16()で常に使用される動作です。</target>
        </trans-unit>
        <trans-unit id="e33053c4558a1f3729067b3cae6e30d0b922d25b" translate="yes" xml:space="preserve">
          <source>The database is opened in read-only mode. If the database does not already exist, an error is returned.</source>
          <target state="translated">データベースは読み取り専用モードで開かれます。データベースが既に存在しない場合は、エラーが返されます。</target>
        </trans-unit>
        <trans-unit id="c36f905350b3694fef2e907f7076bd6c0eb07bcf" translate="yes" xml:space="preserve">
          <source>The database may be read but not written. Any number of processes can hold SHARED locks at the same time, hence there can be many simultaneous readers. But no other thread or process is allowed to write to the database file while one or more SHARED locks are active.</source>
          <target state="translated">データベースは読み込まれますが、書き込まれることはありません。任意の数のプロセスが同時にSHAREDロックを保持することができるので、多くの同時読み込みが可能です。しかし、1つ以上のSHAREDロックがアクティブな間は、他のスレッドやプロセスがデータベースファイルに書き込むことはできません。</target>
        </trans-unit>
        <trans-unit id="2cc9e66b5c02e09e5ad16f7b64822b0c58495bb9" translate="yes" xml:space="preserve">
          <source>The database page size in bytes, or 1 if the page size is 65536.</source>
          <target state="translated">データベースのページサイズをバイト単位で、ページサイズが65536の場合は1で指定します。</target>
        </trans-unit>
        <trans-unit id="8a5fb001456adc96d15706d6924ffd2f301ed99f" translate="yes" xml:space="preserve">
          <source>The database page size in bytes. Must be a power of two between 512 and 32768 inclusive, or the value 1 representing a page size of 65536.</source>
          <target state="translated">データベースのページサイズをバイト単位で指定します。512 から 32768 までの間の 2 の累乗、または 65536 のページサイズを表す値 1 でなければなりません。</target>
        </trans-unit>
        <trans-unit id="960363c84d760f550ea9fae647b23fad91849f93" translate="yes" xml:space="preserve">
          <source>The database schema (in the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; table) is not normally included in the hash, but can be added by the &quot;--schema&quot; option.</source>
          <target state="translated">データベーススキーマ（&lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt;テーブル内）は通常ハッシュに含まれませんが、「-schema」オプションで追加できます。</target>
        </trans-unit>
        <trans-unit id="14a6eadb07a326767237571a6c459f7de69f6f90" translate="yes" xml:space="preserve">
          <source>The database schema (in the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; table) is not normally included in the hash, but can be added by the &quot;--schema&quot; option.</source>
          <target state="translated">データベーススキーマ（&lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt;テーブル内）は通常ハッシュに含まれていませんが、「-schema」オプションで追加できます。</target>
        </trans-unit>
        <trans-unit id="8594a821095f6391744d60f5433b9311564cee65" translate="yes" xml:space="preserve">
          <source>The database text encoding. A value of 1 means UTF-8. A value of 2 means UTF-16le. A value of 3 means UTF-16be.</source>
          <target state="translated">データベースのテキストエンコーディング。値1はUTF-8を意味します。値2はUTF-16leを意味します。3の値はUTF-16beを意味します。</target>
        </trans-unit>
        <trans-unit id="e0c8f6d94e8860f110aff3d0dcf3dec439a12ec1" translate="yes" xml:space="preserve">
          <source>The database will be opened as an in-memory database. The database is named by the &quot;filename&quot; argument for the purposes of cache-sharing, if shared cache mode is enabled, but the &quot;filename&quot; is otherwise ignored.</source>
          <target state="translated">データベースは、インメモリデータベースとしてオープンされる。共有キャッシュモードが有効な場合には、キャッシュ共有の目的で &quot;filename&quot; 引数によってデータベースの名前が付けられますが、それ以外の場合には &quot;filename&quot; は無視されます。</target>
        </trans-unit>
        <trans-unit id="8474bd3b47622066afeb4b46c5b6be93034d3e7c" translate="yes" xml:space="preserve">
          <source>The datatype of columns now appear in the 4th argument to the callback.</source>
          <target state="translated">カラムのデータ型がコールバックの第4引数に表示されるようになりました。</target>
        </trans-unit>
        <trans-unit id="aa9bbe0be9ce7cff21329528d0726ee0baa77cf6" translate="yes" xml:space="preserve">
          <source>The date and time functions use a subset of &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601&quot;&gt;IS0-8601&lt;/a&gt; date and time formats. The date() function returns the date in this format: YYYY-MM-DD. The time() function returns the time as HH:MM:SS. The datetime() function returns &quot;YYYY-MM-DD HH:MM:SS&quot;. The julianday() function returns the &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day&lt;/a&gt; - the number of days since noon in Greenwich on November 24, 4714 B.C. (&lt;a href=&quot;http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar&quot;&gt;Proleptic Gregorian calendar&lt;/a&gt;). The strftime() routine returns the date formatted according to the format string specified as the first argument. The format string supports the most common substitutions found in the &lt;a href=&quot;http://opengroup.org/onlinepubs/007908799/xsh/strftime.html&quot;&gt;strftime() function&lt;/a&gt; from the standard C library plus two new substitutions, %f and %J. The following is a complete list of valid strftime() substitutions:</source>
          <target state="translated">日付と時刻の関数は、&lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601&quot;&gt;IS0-8601の&lt;/a&gt;日付と時刻の形式のサブセットを使用します。 date（）関数は、YYYY-MM-DDの形式で日付を返します。 time（）関数は時間をHH：MM：SSとして返します。 datetime（）関数は「YYYY-MM-DD HH：MM：SS」を返します。 julianday（）関数は、&lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;ユリウス日&lt;/a&gt;（紀元前4714年11月24日、グリニッジ正午からの日数（紀元前&lt;a href=&quot;http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar&quot;&gt;グレゴリオ暦&lt;/a&gt;））を返します。 strftime（）ルーチンは、最初の引数として指定されたフォーマット文字列に従ってフォーマットされた日付を返します。フォーマット文字列は、標準Cライブラリの&lt;a href=&quot;http://opengroup.org/onlinepubs/007908799/xsh/strftime.html&quot;&gt;strftime（）関数に&lt;/a&gt;ある最も一般的な置換に加えて、2つの新しい置換％fと％Jをサポートしています。以下は、有効なstrftime（）置換の完全なリストです。</target>
        </trans-unit>
        <trans-unit id="41f51b9af9bc71b6bb1cc99119d6849c39b622ad" translate="yes" xml:space="preserve">
          <source>The db parameter is a pointer to the SQLite &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; that is executing the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. The pAux argument is the copy of the client data pointer that was the fourth argument to the &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; or &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; call that registered the &lt;a href=&quot;c3ref/module&quot;&gt;virtual table module&lt;/a&gt;. The argv parameter is an array of argc pointers to null terminated strings. The first string, argv[0], is the name of the module being invoked. The module name is the name provided as the second argument to &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; and as the argument to the USING clause of the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement that is running. The second, argv[1], is the name of the database in which the new virtual table is being created. The database name is &quot;main&quot; for the primary database, or &quot;temp&quot; for TEMP database, or the name given at the end of the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for attached databases. The third element of the array, argv[2], is the name of the new virtual table, as specified following the TABLE keyword in the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. If present, the fourth and subsequent strings in the argv[] array report the arguments to the module name in the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement.</source>
          <target state="translated">dbパラメータは、&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;ステートメントを実行しているSQLite &lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;へのポインタです。 pAux引数は、&lt;a href=&quot;c3ref/module&quot;&gt;仮想テーブルモジュール&lt;/a&gt;を登録した&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module（）&lt;/a&gt;または&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2（）&lt;/a&gt;呼び出しの4番目の引数であったクライアントデータポインターのコピーです。 argvパラメータは、nullで終了する文字列へのargcポインタの配列です。最初の文字列argv [0]は、呼び出されるモジュールの名前です。モジュール名は、&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module（）の&lt;/a&gt; 2番目の引数および&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLEの&lt;/a&gt; USING句の引数として提供される名前です。実行中のステートメント。 2番目のargv [1]は、新しい仮想テーブルが作成されるデータベースの名前です。データベース名は、プライマリデータベースの場合は「main」、TEMPデータベースの場合は「temp」、接続されているデータベースの場合は&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;ステートメントの最後に指定された名前です。配列の3番目の要素であるargv [2]は、&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;ステートメントのTABLEキーワードに続いて指定される、新しい仮想テーブルの名前です。存在する場合、argv []配列の4番目以降の文字列は、&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;ステートメントのモジュール名への引数を報告します。</target>
        </trans-unit>
        <trans-unit id="f728f7217f7fc88bd0e8e8228a6a594400b21afc" translate="yes" xml:space="preserve">
          <source>The dbhash program is implemented by a single file of C-code called &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=tool/dbhash.c&quot;&gt;dbhash.c&lt;/a&gt;. To build the dbhash program manually, simply compile the dbhash.c source file and link it against the SQLite library.</source>
          <target state="translated">dbhashプログラムは、&lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=tool/dbhash.c&quot;&gt;dbhash.c&lt;/a&gt;と呼ばれるCコードの単一ファイルによって実装されます。dbhashプログラムを手動でビルドするには、dbhash.cソースファイルをコンパイルし、SQLiteライブラリにリンクします。</target>
        </trans-unit>
        <trans-unit id="b16703d23a9ca6a2a8cb4ca235cc87a944a6dff5" translate="yes" xml:space="preserve">
          <source>The dbhash.exe Utility Program</source>
          <target state="translated">dbhash.exe ユーティリティープログラム</target>
        </trans-unit>
        <trans-unit id="825612a3619e0d061fa775e13b4301fdfc5c4d06" translate="yes" xml:space="preserve">
          <source>The dbsqlfuzz fuzzer has been so successful at hardening the SQLite code base against malicious attack that it is now considered one of the four primary test harnesses for SQLite.</source>
          <target state="translated">dbsqlfuzzファザーはSQLiteのコードベースを悪意のある攻撃から守ることに成功しており、現在ではSQLiteの4つの主要なテストハーネスの1つと考えられています。</target>
        </trans-unit>
        <trans-unit id="ce23c499eac5efbdaf2dbb036cb7b2ac9a155ffe" translate="yes" xml:space="preserve">
          <source>The dbsqlfuzz fuzzer mutates both the SQL input and the database file at the same time. Dbsqlfuzz uses a custom &lt;a href=&quot;https://github.com/google/fuzzer-test-suite/blob/master/tutorial/structure-aware-fuzzing.md&quot;&gt;Structure-Aware Mutator&lt;/a&gt; on a specialized input file that defines both an input database and SQL text to be run against that database. Because it mutates both the input database and the input SQL at the same time, dbsqlfuzz has been able to find some obscure faults in SQLite that were missed by prior fuzzers that mutated only SQL inputs or only the database file.</source>
          <target state="translated">dbsqlfuzz fuzzerは、SQL入力とデータベースファイルの両方を同時に変更します。Dbsqlfuzzは、入力データベースとそのデータベースに対して実行されるSQLテキストの両方を定義する特殊な入力ファイルで、カスタム&lt;a href=&quot;https://github.com/google/fuzzer-test-suite/blob/master/tutorial/structure-aware-fuzzing.md&quot;&gt;構造認識ミュー&lt;/a&gt;テーターを使用します。入力データベースと入力SQLの両方を同時に変更するため、dbsqlfuzzは、SQL入力のみまたはデータベースファイルのみを変更する以前のファザーでは見逃されていた、SQLiteの不明瞭な障害を見つけることができました。</target>
        </trans-unit>
        <trans-unit id="e0f01bd5981d7e05e25eea466d94ddbb29381d04" translate="yes" xml:space="preserve">
          <source>The dbsqlfuzz fuzzer mutates both the SQL input and the database file at the same time. Dbsqlfuzz uses a custom &lt;a href=&quot;https://github.com/google/fuzzer-test-suite/blob/master/tutorial/structure-aware-fuzzing.md&quot;&gt;Structure-Aware Mutator&lt;/a&gt; on a specialized input file that defines both an input database and SQL text to be run against that database. Because it mutates both the input database and the input SQL at the same time, dbsqlfuzz has been able to find some obscure faults in SQLite that were missed by prior fuzzers that mutated only SQL inputs or only the database file. The SQLite developers usually leave an instance or two of dbsqlfuzz running on the latest trunk code of SQLite whenever they are away from the office for an extended period, such as overnight.</source>
          <target state="translated">dbsqlfuzzファザーは、SQL入力とデータベースファイルの両方を同時に変更します。 Dbsqlfuzzは、入力データベースとそのデータベースに対して実行されるSQLテキストの両方を定義する特殊な入力ファイルでカスタム&lt;a href=&quot;https://github.com/google/fuzzer-test-suite/blob/master/tutorial/structure-aware-fuzzing.md&quot;&gt;Structure-&lt;/a&gt; AwareMutatorを使用します。入力データベースと入力SQLの両方を同時に変更するため、dbsqlfuzzは、SQL入力のみまたはデータベースファイルのみを変更した以前のファザーでは見逃されていたSQLiteのいくつかのあいまいな障害を見つけることができました。 SQLite開発者は通常、夜間などの長期間オフィスを離れるときはいつでも、SQLiteの最新のトランクコードでdbsqlfuzzのインスタンスまたは2つを実行したままにします。</target>
        </trans-unit>
        <trans-unit id="0bae73cc22154360311af38fab160d5138d312f9" translate="yes" xml:space="preserve">
          <source>The dbstat virtual table is an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt;, meaning that is not necessary to run &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; to create an instance of the dbstat virtual table before using it. The &quot;dbstat&quot; module name can be used as if it were a table name to query the dbstat virtual table directly. For example:</source>
          <target state="translated">dbstat仮想テーブルがある&lt;a href=&quot;vtab#epovtab&quot;&gt;町の名を冠した仮想テーブル&lt;/a&gt;それを実行する必要はありませんつまり、&lt;a href=&quot;lang_createvtab&quot;&gt;仮想テーブルをCREATE&lt;/a&gt;それを使用する前に、dbstat仮想テーブルのインスタンスを作成します。「dbstat」モジュール名は、dbstat仮想テーブルを直接照会するためのテーブル名であるかのように使用できます。例えば：</target>
        </trans-unit>
        <trans-unit id="efcc1572318b12d880dcf6c5ba6e48d567425a65" translate="yes" xml:space="preserve">
          <source>The decision of whether to implement a FROM-clause subquery as a co-routine or using &lt;a href=&quot;optoverview#flattening&quot;&gt;query flattening&lt;/a&gt; now considers whether the result set of the outer query is &quot;complex&quot; (if it contains functions or expression subqueries). A complex result set biases the decision toward the use of co-routines.</source>
          <target state="translated">FROM句のサブクエリをコルーチンとして実装するか、&lt;a href=&quot;optoverview#flattening&quot;&gt;クエリのフラット化&lt;/a&gt;を使用するかを決定する際に、外部クエリの結果セットが「複雑」かどうかが考慮されます（関数または式のサブクエリが含まれている場合）。複雑な結果セットは、コルーチンの使用に決定を偏らせます。</target>
        </trans-unit>
        <trans-unit id="ab20325df0acc9b2aa5397a0a5067782536af164" translate="yes" xml:space="preserve">
          <source>The decision of which collating sequence to use is controlled by the COLLATE clause in SQL. A COLLATE clause can occur on a table definition, to define a default collating sequence to a table column, or on field of an index, or in the ORDER BY clause of a SELECT statement. Planned enhancements to SQLite are to include standard CAST() syntax to allow the collating sequence of an expression to be defined.</source>
          <target state="translated">どの照合順序を使用するかの決定は、SQLのCOLLATE句によって制御されます。COLLATE 句は、テーブルの定義、テーブルのカラムへのデフォルトの照合順序の定義、 インデックスのフィールド、SELECT 文の ORDER BY 句の中で使用することができます。SQLite では、標準の CAST()構文を使用して式の照合順序を定義できるようにすることが予定されています。</target>
        </trans-unit>
        <trans-unit id="18e04830dfd2e28b2697cd44ccf76543eadbcceb" translate="yes" xml:space="preserve">
          <source>The declared type of each column in the table.</source>
          <target state="translated">テーブルの各列の宣言された型。</target>
        </trans-unit>
        <trans-unit id="68032822fa262cd72f80461a11d217079b712edb" translate="yes" xml:space="preserve">
          <source>The default 'crisismerge' value is 16. There is no maximum limit. Attempting to set the 'crisismerge' parameter to a value of 0 or 1 is equivalent to setting it to the default value (16). It is an error to attempt to set the 'crisismerge' option to a negative value.</source>
          <target state="translated">crisismerge」のデフォルト値は16です。上限はありません。crisismerge」パラメータの値を 0 または 1 に設定しようとすると、デフォルト値 (16)に設定したのと同じことになります。crisismerge」オプションを負の値に設定しようとするとエラーになります。</target>
        </trans-unit>
        <trans-unit id="04fcbed48c760da194eb2fb040297255b4fffa15" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;schema format number&lt;/a&gt; is changed from 1 to 4. This means that, unless the &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;PRAGMA legacy_file_format=ON&lt;/a&gt; statement is run, newly created database files will be unreadable by version of SQLite prior to 3.3.0 (2006-01-10). It also means that the &lt;a href=&quot;lang_createindex#descidx&quot;&gt;descending indices&lt;/a&gt; are enabled by default.</source>
          <target state="translated">デフォルトの&lt;a href=&quot;fileformat2#schemaformat&quot;&gt;スキーマフォーマット番号&lt;/a&gt;が1から4に変更されました。これは、&lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;PRAGMA legacy_file_format = ON&lt;/a&gt;ステートメントが実行されない限り、新しく作成されたデータベースファイルは、3.3.0（2006-01-10）より前のバージョンのSQLiteで読み取ることができないことを意味します。また、&lt;a href=&quot;lang_createindex#descidx&quot;&gt;降順のインデックス&lt;/a&gt;はデフォルトで有効になっています。</target>
        </trans-unit>
        <trans-unit id="b8d41b5a0a8527b81ce581d5cb059a7a0ef7283f" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;schema format number&lt;/a&gt; used by SQLite when creating new database files is set by this macro. The schema formats are all very similar. The difference between formats 1 and 4 is that format 4 understands &lt;a href=&quot;lang_createindex#descidx&quot;&gt;descending indices&lt;/a&gt; and has a tighter encoding for boolean values.</source>
          <target state="translated">新しいデータベースファイルを作成するときにSQLiteが使用するデフォルトの&lt;a href=&quot;fileformat2#schemaformat&quot;&gt;スキーマフォーマット番号&lt;/a&gt;は、このマクロによって設定されます。スキーマ形式はすべて非常に似ています。形式1と形式4の違いは、形式4は&lt;a href=&quot;lang_createindex#descidx&quot;&gt;降順のインデックス&lt;/a&gt;を理解し、ブール値をより厳密にエンコードすることです。</target>
        </trans-unit>
        <trans-unit id="ca0921362c7fa29bf8c96529653cba6ff2aa4225" translate="yes" xml:space="preserve">
          <source>The default MASK is and always shall be 0xfffe. The 0xfffe mask means perform all of the optimizations listed above except Debug Mode. If new optimizations are added in the future that should be off by default, those new optimizations will be given a mask of 0x10000 or larger.</source>
          <target state="translated">デフォルトのMASKは0xfffeで、常に0xfffeでなければなりません。0xfffeマスクは、Debug Mode以外の上記のすべての最適化を実行することを意味します。将来、デフォルトではオフになっているはずの新しい最適化が追加された場合、それらの新しい最適化には0x10000以上のマスクが与えられます。</target>
        </trans-unit>
        <trans-unit id="a903124a6abce3d6d4d4bbe7f6d1f8b599823062" translate="yes" xml:space="preserve">
          <source>The default VFS can be changed by registering or re-registering the VFS using the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface with a second parameter of 1. Hence, if a (unix) process wants to always use the &quot;unix-nolock&quot; VFS in place of &quot;unix&quot;, the following code would work:</source>
          <target state="translated">デフォルトのVFSは、&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;インターフェースを使用して、2番目のパラメーターを1にしてVFSを登録または再登録することで変更できます。したがって、（unix）プロセスが常に「unix-nolock」VFSをunix」の場合、次のコードが機能します。</target>
        </trans-unit>
        <trans-unit id="c5a51f22fb2e29520e6fcdc862dfe6400d4b2d95" translate="yes" xml:space="preserve">
          <source>The default behavior for a loadable extension is that it is unloaded from process memory when the database connection that originally invoked &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; closes. (In other words, the xDlUnload method of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object is called for all extensions when a database connection closes.) However, if the initialization procedure returns &lt;a href=&quot;rescode#ok_load_permanently&quot;&gt;SQLITE_OK_LOAD_PERMANENTLY&lt;/a&gt; instead of SQLITE_OK, then the extension will not be unloaded (xDlClose will not be invoked) and the extension will remain in process memory indefinitely. The SQLITE_OK_LOAD_PERMANENTLY return value is useful for extensions that want to register new &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;.</source>
          <target state="translated">ロード可能な拡張機能のデフォルトの動作は、最初に&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）を&lt;/a&gt;呼び出したデータベース接続が閉じたときに、プロセスメモリからアンロードされることです。 （つまり、データベース接続が閉じると、&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトのxDlUnloadメソッドがすべての拡張機能に対して呼び出されます。）ただし、初期化プロシージャが&lt;a href=&quot;rescode#ok_load_permanently&quot;&gt;SQLITE_OK&lt;/a&gt;ではなくSQLITE_OK_LOAD_PERMANENTLYを返す場合、拡張機能はアンロードされません（xDlCloseは呼び出されません）。また、拡張機能は無期限にプロセスメモリに残ります。 SQLITE_OK_LOAD_PERMANENTLYの戻り値は、新しい&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;を登録する拡張機能に役立ちます。</target>
        </trans-unit>
        <trans-unit id="35fa7584b655adc25cbf99cb25271bb088b3504f" translate="yes" xml:space="preserve">
          <source>The default behavior gives this results:</source>
          <target state="translated">デフォルトの動作ではこのような結果になります。</target>
        </trans-unit>
        <trans-unit id="929789505d4e7daeec8d95f7bd37c902d7905d6b" translate="yes" xml:space="preserve">
          <source>The default behavior of assert(X) in standard C is that it is enabled for release builds. This is a reasonable default. However, the SQLite code base has many assert() statements in performance-sensitive areas of the code. Leaving assert(X) turned on causes SQLite to run about three times slower. Also, SQLite strives to provide 100% MC/DC in an as-delivered configuration, which is obviously impossible if assert(X) statements are enabled. For these reasons, assert(X) is a no-op for release builds in SQLite.</source>
          <target state="translated">標準 C の assert(X)のデフォルトの動作は、リリースビルドで有効になっています。これは妥当なデフォルトです。しかし、SQLite のコードベースには、パフォーマンスに敏感な部分に多くの assert()文があります。assert(X)をオンにしたままにしておくと、SQLite の動作が約 3 倍遅くなります。また、SQLite はアズデリバリ構成で 100% の MC/DC を提供するように努力していますが、assert(X)ステートメントが有効になっている場合は明らかに不可能です。これらの理由から、SQLite のリリースビルドでは assert(X)は使用しないでください。</target>
        </trans-unit>
        <trans-unit id="d9b3b8cc178a304f2169b7fe7ac799ae14ab4502" translate="yes" xml:space="preserve">
          <source>The default behavior of the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator is to ignore case for ASCII characters. Hence, by default &lt;b&gt;'a' LIKE 'A'&lt;/b&gt; is true. The case_sensitive_like pragma installs a new application-defined LIKE function that is either case sensitive or insensitive depending on the value of the case_sensitive_like pragma. When case_sensitive_like is disabled, the default LIKE behavior is expressed. When case_sensitive_like is enabled, case becomes significant. So, for example, &lt;b&gt;'a' LIKE 'A'&lt;/b&gt; is false but &lt;b&gt;'a' LIKE 'a'&lt;/b&gt; is still true.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;演算子のデフォルトの動作では、ASCII文字の大文字と小文字が区別されません。したがって、デフォルトでは&lt;b&gt;'a' LIKE 'A'&lt;/b&gt;はtrueです。 case_sensitive_likeプラグマは、case_sensitive_likeプラグマの値に応じて、大文字と小文字を区別するか、または区別しない新しいアプリケーション定義のLIKE関数をインストールします。 case_sensitive_likeを無効にすると、デフォルトのLIKE動作が表現されます。 case_sensitive_likeを有効にすると、大文字と小文字が区別されます。したがって、たとえば、&lt;b&gt;'a' LIKE 'A'&lt;/b&gt;は偽ですが、&lt;b&gt;'a' LIKE 'a'&lt;/b&gt;は依然として真です。</target>
        </trans-unit>
        <trans-unit id="9edad614da3d9aaf086c0a5c5b068d92a4f96481" translate="yes" xml:space="preserve">
          <source>The default builds for SQLite on Unix, Windows, and OS/2 include a VFS appropriate for the target platform. SQLite builds for other operating systems do not contain a VFS by default, but the application can register one or more at run-time.</source>
          <target state="translated">Unix、Windows、OS/2上のSQLiteのデフォルトのビルドには、ターゲットプラットフォームに適したVFSが含まれています。他のオペレーティングシステム用の SQLite ビルドにはデフォルトで VFS は含まれていませんが、アプリケーションはランタイムに 1 つ以上の VFS を登録することができます。</target>
        </trans-unit>
        <trans-unit id="6a78f3c92a0ec476b159128dcf1aca02c9237966" translate="yes" xml:space="preserve">
          <source>The default busy callback is NULL.</source>
          <target state="translated">デフォルトのビジーコールバックは NULL です。</target>
        </trans-unit>
        <trans-unit id="a139fc5b0808f70ee2866da438ce9a4197bf896c" translate="yes" xml:space="preserve">
          <source>The default collating function for all strings is BINARY. Alternative collating functions for table columns can be specified in the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement using the COLLATE clause on the &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;column definition&lt;/a&gt;. When a column is indexed, the same collating function specified in the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement is used for the column in the index, by default, though this can be overridden using a COLLATE clause in the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement.</source>
          <target state="translated">すべての文字列のデフォルトの照合関数はBINARYです。テーブル列の代替照合関数は、&lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;列定義の&lt;/a&gt; COLLATE句を使用して&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;ステートメントで指定できます。列にインデックスが付けられると、デフォルトでは、&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;ステートメントで指定された同じ照合関数がインデックス内の列に使用されますが、これは&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;ステートメントのCOLLATE句を使用してオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="4196a7b520d0708c2ca6c2f0dd09284b39f44638" translate="yes" xml:space="preserve">
          <source>The default configuration for SQLite works great for most applications. But sometimes developers want to tweak the setup to try to squeeze out a little more performance, or take advantage of some obscure feature.</source>
          <target state="translated">SQLite のデフォルトの設定は、ほとんどのアプリケーションで素晴らしい働きをします。しかし、時には開発者はもう少しパフォーマンスを上げたい、あるいはよくわからない機能を利用したいと思うこともあるでしょう。</target>
        </trans-unit>
        <trans-unit id="7f629fe0c846fce25506268b75e0f95dc1a4e2cd" translate="yes" xml:space="preserve">
          <source>The default configuration of SQLite assumes the underlying filesystem supports long filenames.</source>
          <target state="translated">SQLite のデフォルト設定は、基礎となるファイルシステムが長いファイル名をサポートしていることを前提としています。</target>
        </trans-unit>
        <trans-unit id="f9ca0f7d70101ac90e64f7de1b18481b2e2650e6" translate="yes" xml:space="preserve">
          <source>The default configuration of SQLite only supports case-insensitive comparisons of ASCII characters. The reason for this is that doing full Unicode case-insensitive comparisons and case conversions requires tables and logic that would nearly double the size of the SQLite library. The SQLite developers reason that any application that needs full Unicode case support probably already has the necessary tables and functions and so SQLite should not take up space to duplicate this ability.</source>
          <target state="translated">SQLite のデフォルトの設定では、ASCII 文字の大文字小文字を区別しない比較しかサポートしていません。その理由は、完全な Unicode 大文字小文字を区別しない比較や大文字小文字の変換を行うためには、SQLite ライブラリのサイズを 2 倍近くにするテーブルやロジックが必要になるからです。SQLite の開発者は、完全な Unicode 大文字小文字のサポートを必要とするアプリケーションは、おそらくすでに必要なテーブルや関数を持っているはずであり、SQLite はこの機能を複製するためにスペースを取るべきではないと考えています。</target>
        </trans-unit>
        <trans-unit id="c23763d0cb18af4da83857106ae71fb287c36d2b" translate="yes" xml:space="preserve">
          <source>The default datatype is 'int32'.</source>
          <target state="translated">デフォルトのデータ型は 'int32' です。</target>
        </trans-unit>
        <trans-unit id="57ca93f20ecfcb67f54da8e6ff374c396f410f8d" translate="yes" xml:space="preserve">
          <source>The default deletion cost</source>
          <target state="translated">デフォルトの削除コスト</target>
        </trans-unit>
        <trans-unit id="348ca4d833d68a6b457e44e2f51c5dde36928e20" translate="yes" xml:space="preserve">
          <source>The default directory for temporary files depends on the OS. Some OS interfaces may choose to ignore this variable and place temporary files in some other directory different from the directory specified here. In that sense, this pragma is only advisory.</source>
          <target state="translated">一時ファイルのデフォルトのディレクトリは OS に依存します。OS のインタフェースによっては、この変数を無視して、一時ファイルをここで指定したディレクトリとは別のディレクトリに置くことを選択する場合があります。その意味で、このpragmaは勧告的なものでしかありません。</target>
        </trans-unit>
        <trans-unit id="09a19fe31cacf32f0a49986af2b636abaafd7a24" translate="yes" xml:space="preserve">
          <source>The default encoding will be UTF-8 for databases created using sqlite3_open() or sqlite3_open_v2(). The default encoding for databases created using sqlite3_open16() will be UTF-16 in the native byte order.</source>
          <target state="translated">sqlite3_open()またはsqlite3_open_v2()を使用して作成されたデータベースのデフォルトのエンコーディングはUTF-8になります。sqlite3_open16()を使用して作成されたデータベースのデフォルトのエンコーディングは、ネイティブのバイト順でUTF-16になります。</target>
        </trans-unit>
        <trans-unit id="93b91496e8c579b792f6528c1582f57d8e5307a9" translate="yes" xml:space="preserve">
          <source>The default file format is now 1.</source>
          <target state="translated">デフォルトのファイル形式が1になりました。</target>
        </trans-unit>
        <trans-unit id="07f52e2687ee82b720aa1390843c77644fb57108" translate="yes" xml:space="preserve">
          <source>The default file format is set by the &lt;a href=&quot;compile#default_file_format&quot;&gt;SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt; compile-time option.</source>
          <target state="translated">デフォルトのファイル形式は、&lt;a href=&quot;compile#default_file_format&quot;&gt;SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt;コンパイル時オプションによって設定されます。</target>
        </trans-unit>
        <trans-unit id="cc414446f05fe3ef5190b22cd556bce2036d0102" translate="yes" xml:space="preserve">
          <source>The default frame-spec is:</source>
          <target state="translated">デフォルトのフレーム仕様は</target>
        </trans-unit>
        <trans-unit id="c9df385f1bced3c35670bbdf7a0e4f5a1cfdb4ca" translate="yes" xml:space="preserve">
          <source>The default implementation stores all statistics in a single table named &quot;&lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt;&quot;. If SQLite is compiled with the &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; option and without the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; option, then additional histogram data is collected and stored in &lt;a href=&quot;fileformat2#stat3tab&quot;&gt;sqlite_stat3&lt;/a&gt;. If SQLite is compiled with the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; option, then additional histogram data is collected and stored in &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt;. Older versions of SQLite would make use of the &lt;a href=&quot;fileformat2#stat2tab&quot;&gt;sqlite_stat2&lt;/a&gt; table when compiled with &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; but all recent versions of SQLite ignore the sqlite_stat2 table. Future enhancements may create additional &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal tables&lt;/a&gt; with the same name pattern except with final digit larger than &quot;4&quot;. All of these tables are collectively referred to as &quot;statistics tables&quot;.</source>
          <target state="translated">デフォルトの実装では、すべての統計が「&lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt;」という名前の単一のテーブルに格納されます。 SQLiteのがコンパイルされている場合は&lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3の&lt;/a&gt;オプションとすることなく、&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4の&lt;/a&gt;オプション、追加のヒストグラムデータが収集され、中に格納され&lt;a href=&quot;fileformat2#stat3tab&quot;&gt;sqlite_stat3&lt;/a&gt;。 SQLiteが&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;オプションでコンパイルされている場合、追加のヒストグラムデータが収集され、&lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4に&lt;/a&gt;保存されます。 SQLiteの古いバージョンは、&lt;a href=&quot;fileformat2#stat2tab&quot;&gt;SQLITE_ENABLE_STAT2で&lt;/a&gt;コンパイルすると&lt;a href=&quot;compile#enable_stat2&quot;&gt;sqlite_stat2&lt;/a&gt;テーブルを使用しますが、SQLiteの最新バージョンはすべてsqlite_stat2テーブルを無視します。将来の拡張により、追加の&lt;a href=&quot;fileformat2#intschema&quot;&gt;内部テーブル&lt;/a&gt;が作成される可能性があります「4」より大きい最後の桁を除いて、同じ名前パターンで。これらのテーブルはすべてまとめて「統計テーブル」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="2000f471d1e2f9fad888fbe96454c85325906ea0" translate="yes" xml:space="preserve">
          <source>The default implementation stores all statistics in a single table named &quot;&lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt;&quot;. If SQLite is compiled with the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; option, then additional histogram data is collected and stored in &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt;. Older versions of SQLite would make use of the &lt;a href=&quot;fileformat2#stat2tab&quot;&gt;sqlite_stat2&lt;/a&gt; table or &lt;a href=&quot;fileformat2#stat3tab&quot;&gt;sqlite_stat3&lt;/a&gt; table when compiled with &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; or &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt;, but all recent versions of SQLite ignore the sqlite_stat2 and sqlite_stat3 tables. Future enhancements may create additional &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal tables&lt;/a&gt; with the same name pattern except with final digit larger than &quot;4&quot;. All of these tables are collectively referred to as &quot;statistics tables&quot;.</source>
          <target state="translated">デフォルトの実装では、すべての統計が「&lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt; &quot;」という名前の単一のテーブルに格納されます。 SQLiteが&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;オプションを使用してコンパイルされている場合、追加のヒストグラムデータが収集され、&lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4に&lt;/a&gt;保存されます。 SQLiteの古いバージョンの使用になるだろう&lt;a href=&quot;fileformat2#stat2tab&quot;&gt;sqlite_stat2の&lt;/a&gt;テーブルまたは&lt;a href=&quot;fileformat2#stat3tab&quot;&gt;sqlite_stat3&lt;/a&gt;してコンパイルする場合、テーブルを&lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt;または&lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt;が、SQLiteのすべての最近のバージョンはsqlite_stat2とsqlite_stat3テーブルを無視します。将来の拡張により、追加の&lt;a href=&quot;fileformat2#intschema&quot;&gt;内部テーブル&lt;/a&gt;が作成される可能性があります最後の桁が「4」より大きいことを除いて、同じ名前パターンで。これらのテーブルはすべて、まとめて「統計テーブル」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="92c0ee558e2a1a06a318ed232e40e1c0e6d83d45" translate="yes" xml:space="preserve">
          <source>The default insertion cost</source>
          <target state="translated">デフォルトの挿入コスト</target>
        </trans-unit>
        <trans-unit id="44b061817ffc2eb0f5dadec06f4e66f4f81231c2" translate="yes" xml:space="preserve">
          <source>The default locking mechanism used by SQLite on unix platforms is POSIX advisory locking, but there are other options. By selecting an alternative &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; using the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface, an application can make use of other locking protocols that might be more appropriate to certain filesystems. For example, dot-file locking might be select for use in an application that has to run on an NFS filesystem that does not support POSIX advisory locking.</source>
          <target state="translated">UNIXプラットフォームでSQLiteが使用するデフォルトのロックメカニズムはPOSIX勧告ロックですが、他のオプションもあります。&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;インターフェースを使用して代替の&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;を選択することで、アプリケーションは、特定のファイルシステムにより適切な他のロックプロトコルを利用できます。たとえば、ドットファイルロックは、POSIXアドバイザリロックをサポートしないNFSファイルシステムで実行する必要があるアプリケーションで使用するために選択される場合があります。</target>
        </trans-unit>
        <trans-unit id="d9e0888f3707dfa1a041c24c2a5eb623fe8f593b" translate="yes" xml:space="preserve">
          <source>The default locking mechanism used by SQLite on unix platforms is POSIX advisory locking. Unfortunately, POSIX advisory locking has design quirks that make it prone to misuse and failure. In particular, any thread in the same process with a file descriptor that is holding a POSIX advisory lock can override that lock using a different file descriptor. One particularly pernicious problem is that the &lt;code&gt;close()&lt;/code&gt; system call will cancel all POSIX advisory locks on the same file for all threads and all file descriptors in the process.</source>
          <target state="translated">UNIXプラットフォームでSQLiteが使用するデフォルトのロックメカニズムは、POSIX勧告ロックです。残念ながら、POSIXアドバイザリロックには設計上の癖があり、誤用や失敗が発生しやすくなっています。特に、POSIXアドバイザリロックを保持しているファイル記述子を持つ同じプロセス内のスレッドは、別のファイル記述子を使用してそのロックをオーバーライドできます。特に厄介な問題の1つは、 &lt;code&gt;close()&lt;/code&gt; システムコールが、プロセス内のすべてのスレッドとすべてのファイル記述子について、同じファイルのすべてのPOSIX勧告ロックをキャンセルすることです。</target>
        </trans-unit>
        <trans-unit id="07275b3b33b4fa68f4e8147d7f962856df7d7bd0" translate="yes" xml:space="preserve">
          <source>The default lookaside configuration has changed from 100 slots of 1200 bytes each (120KB) to be 40 slots of 1200 bytes each (48KB). This space ends up being allocated as 93 slots of 128 bytes each and 30 slots of 1200 bytes each. So more lookaside slots are available but much less heap space is used.</source>
          <target state="translated">デフォルトのルックサイド設定は、各1200バイトの100スロット(120KB)から、各1200バイトの40スロット(48KB)に変更された。このスペースは、128バイトずつの93スロットと1200バイトずつの30スロットとして割り当てられている。つまり、より多くのルックサイドスロットが利用可能になりますが、使用されるヒープスペースははるかに少なくなります。</target>
        </trans-unit>
        <trans-unit id="4e313113e047c2f26bfe18f713c540368922a076" translate="yes" xml:space="preserve">
          <source>The default lookaside configuration, the size of the small-slots, and the details of how heap space is allocated between small-slots and big-slots, are all subject to change from one release to the next.</source>
          <target state="translated">デフォルトのルックサイド設定、スモールスロットのサイズ、スモールスロットとビッグスロットの間のヒープ領域の割り当て方法の詳細は、すべてリリースごとに変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="fdf451db4759c12771bfb1206d604a686ee94bb6" translate="yes" xml:space="preserve">
          <source>The default mapping of the rank column for a table may be modified using the &lt;a href=&quot;fts5#the_rank_configuration_option&quot;&gt;FTS5 rank configuration option&lt;/a&gt;.</source>
          <target state="translated">テーブルのランク列のデフォルトのマッピングは、&lt;a href=&quot;fts5#the_rank_configuration_option&quot;&gt;FTS5ランク構成オプション&lt;/a&gt;を使用して変更できます。</target>
        </trans-unit>
        <trans-unit id="676ab2fe4bf4ab903767c236b27e9b63051796ee" translate="yes" xml:space="preserve">
          <source>The default maximum trigger recursion depth is 1000.</source>
          <target state="translated">デフォルトでは、トリガの再帰深さの最大値は1000です。</target>
        </trans-unit>
        <trans-unit id="fd5421bb6c7fc35d245339e5557eb27520f8453d" translate="yes" xml:space="preserve">
          <source>The default means that aggregate window functions read all rows from the beginning of the partition up to and including the current row and its peers. This implies that rows that have the same values for all ORDER BY expressions will also have the same value for the result of the window function (as the window frame is the same). For example:</source>
          <target state="translated">デフォルトでは、集約ウィンドウ関数はパーティションの先頭から現在の行とその仲間を含むすべての行を読み取ることを意味します。これは、すべてのORDER BY式に同じ値を持つ行は、ウィンドウ関数の結果にも同じ値を持つことを意味します(ウィンドウフレームが同じであるため)。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="2d78a92ed9db0e9db8d034d6998442b87734337c" translate="yes" xml:space="preserve">
          <source>The default mechanism by which SQLite accesses and updates database disk files is the xRead() and xWrite() methods of the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; VFS object. These methods are typically implemented as &quot;read()&quot; and &quot;write()&quot; system calls which cause the operating system to copy disk content between the kernel buffer cache and user space.</source>
          <target state="translated">SQLiteがデータベースディスクファイルにアクセスして更新するデフォルトのメカニズムは、&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; VFSオブジェクトのxRead（）およびxWrite（）メソッドです。これらのメソッドは通常、 &quot;read（）&quot;および &quot;write（）&quot;システムコールとして実装され、オペレーティングシステムがカーネルバッファーキャッシュとユーザースペースの間でディスクコンテンツをコピーします。</target>
        </trans-unit>
        <trans-unit id="af6b4fd5a17994d4af89bdbebf0e8f01053d45e7" translate="yes" xml:space="preserve">
          <source>The default memory allocation settings in SQLite are appropriate for most applications. However, applications with unusual or particularly strict requirements may want to adjust the configuration to more closely align SQLite to their needs. Both compile-time and start-time configuration options are available.</source>
          <target state="translated">SQLite のデフォルトのメモリ割り当て設定は、ほとんどのアプリケーションに適しています。しかし、通常とは異なる、あるいは特に厳しい要件を持つアプリケーションでは、SQLiteをより密接にニーズに合わせて設定を調整したいと思うかもしれません。コンパイル時と起動時の両方の設定オプションが利用可能です。</target>
        </trans-unit>
        <trans-unit id="62759f30ef7e2768a0dc269d58d4f224a639e96a" translate="yes" xml:space="preserve">
          <source>The default memory allocator is recommended for most applications. If you do not have a compelling need to use an alternative memory allocator, then use the default.</source>
          <target state="translated">ほとんどのアプリケーションでは、デフォルトのメモリアロケータを使用することをお勧めします。代替のメモリアロケータを使用する必要がない場合は、デフォルトのメモリアロケータを使用してください。</target>
        </trans-unit>
        <trans-unit id="dcfc21fe3a44b7df155912e662a52083d37f6130" translate="yes" xml:space="preserve">
          <source>The default method by which SQLite implements &lt;a href=&quot;atomiccommit&quot;&gt;atomic commit and rollback&lt;/a&gt; is a &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt;. Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2010-07-21), a new &quot;Write-Ahead Log&quot; option (hereafter referred to as &quot;WAL&quot;) is available.</source>
          <target state="translated">SQLiteが&lt;a href=&quot;atomiccommit&quot;&gt;アトミックコミットとロールバックを&lt;/a&gt;実装するデフォルトの方法は、&lt;a href=&quot;lockingv3#rollback&quot;&gt;ロールバックジャーナル&lt;/a&gt;です。始まる&lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;バージョン3.7.0&lt;/a&gt;（2010-07-21）、新「先行書き込みログ」オプション（以下「WAL」と呼ばれる）が使用可能です。</target>
        </trans-unit>
        <trans-unit id="03533018c376c706c7055694a5695128f6d5dba9" translate="yes" xml:space="preserve">
          <source>The default mode is serialized.</source>
          <target state="translated">デフォルトのモードはシリアル化されています。</target>
        </trans-unit>
        <trans-unit id="c91c1c07eac44347101354cb661e73cefc49a14a" translate="yes" xml:space="preserve">
          <source>The default numeric file permissions for newly created database files under unix. If not specified, the default is 0644 which means that the files is globally readable but only writable by the creator.</source>
          <target state="translated">unixで新しく作成されたデータベースファイルのデフォルトのファイルパーミッションを数値で指定します。指定されていない場合、デフォルトは 0644 で、ファイルはグローバルに読み取り可能ですが、作成者のみが書き込み可能であることを意味します。</target>
        </trans-unit>
        <trans-unit id="b7b908d4b0d2fc05c9ddc3f95f430fcff134a8ed" translate="yes" xml:space="preserve">
          <source>The default operation of edit() is to invoke a text editor. But by using an alternative edit program in the second argument, you can also get it to edit images or other non-text resources. For example, if you want to modify a JPEG image that happens to be stored in a field of a table, you could run:</source>
          <target state="translated">edit()のデフォルトの操作は、テキストエディタを呼び出すことです。しかし、第二引数に代替の編集プログラムを使用することで、画像やその他のテキスト以外のリソースを編集することもできます。例えば、テーブルのフィールドに保存されているJPEG画像を修正したい場合、以下のように実行することができます。</target>
        </trans-unit>
        <trans-unit id="e15d9f7898bd04fad7c8bec9316feb2b3c4d67cc" translate="yes" xml:space="preserve">
          <source>The default order of the nested loops in a join is for the left-most table in the FROM clause to form the outer loop and the right-most table to form the inner loop. However, SQLite will nest the loops in a different order if doing so will help it to select better indices.</source>
          <target state="translated">結合におけるネストされたループのデフォルトの順序は、FROM句の左端のテーブルが外側のループを形成し、右端のテーブルが内側のループを形成します。しかし、SQLiteは、より良いインデックスを選択するのに役立つ場合には、ループを別の順序で入れ子にします。</target>
        </trans-unit>
        <trans-unit id="c60124ec3003cce0626fc7fdd9909bdc4316bd6f" translate="yes" xml:space="preserve">
          <source>The default output mode is &quot;list&quot;. In list mode, each row of a query result is written on one line of output and each column within that row is separated by a specific separator string. The default separator is a pipe symbol (&quot;|&quot;). List mode is especially useful when you are going to send the output of a query to another program (such as AWK) for additional processing.</source>
          <target state="translated">デフォルトの出力モードは &quot;list &quot;です。リストモードでは、クエリ結果の各行が1行の出力に書き込まれ、その行内の各列は特定の区切り文字列で区切られます。デフォルトの区切り文字はパイプ記号(&quot;|&quot;)です。リストモードは、クエリの出力を別のプログラム(AWKなど)に送信して追加処理を行う場合に特に便利です。</target>
        </trans-unit>
        <trans-unit id="cae14327c7d6852834539912db17ff8fae315187" translate="yes" xml:space="preserve">
          <source>The default output shows the beginning and end of each configuration and test module combination. In the example above &quot;c1&quot; and &quot;64k&quot; are configurations and &quot;pager08&quot;, &quot;build33&quot;, &quot;orderby01&quot;, etc. are test modules. Compile-time and run-time options are available to increase or decrease the amount of output. The output can be increased by showing each test case within each test module. The output can be decreased by degrees: omitting test modules starts and stops, omitting configuration starts and stops, and finally by omitting all output.</source>
          <target state="translated">デフォルトの出力では、各コンフィグレーションとテストモジュールの組み合わせの先頭と末尾が表示されます。上の例では、&quot;c1 &quot;と &quot;64k &quot;がコンフィギュレーション、&quot;pager08&quot;、&quot;build33&quot;、&quot;orderby01 &quot;などがテストモジュールです。出力量を増減させるために、コンパイル時と実行時のオプションが用意されています。各テストモジュール内に各テストケースを表示することで、出力を増やすことができます。出力は、テストモジュールの開始と停止を省略し、設定の開始と停止を省略し、最終的にすべての出力を省略することで、程度の差はありますが、出力を減らすことができます。</target>
        </trans-unit>
        <trans-unit id="81fe79158a35398aa7562b0fca6f1415aa39b894" translate="yes" xml:space="preserve">
          <source>The default page cache implemention does not allocate the full amount of cache memory all at once. Cache memory is allocated in smaller chunks on an as-needed basis. The page_cache setting is a (suggested) upper bound on the amount of memory that the cache can use, not the amount of memory it will use all of the time. This is the behavior of the default page cache implementation, but an &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;application defined page cache&lt;/a&gt; is free to behave differently if it wants.</source>
          <target state="translated">デフォルトのページキャッシュの実装では、一度に全量のキャッシュメモリが割り当てられるわけではありません。キャッシュメモリは、必要に応じて小さなチャンクで割り当てられます。 page_cache設定は、キャッシュが常に使用するメモリ量ではなく、キャッシュが使用できるメモリ量の（推奨）上限です。これはデフォルトのページキャッシュ実装の動作ですが、&lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;アプリケーション定義のページキャッシュ&lt;/a&gt;は、必要に応じて自由に異なる動作をさせることができます。</target>
        </trans-unit>
        <trans-unit id="fc5d7962d2b50c7baceb7ed65dad81e0058ad64b" translate="yes" xml:space="preserve">
          <source>The default page cache strives more diligently to avoid using memory beyond what is allocated to it by &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. Or if using page cache is allocating from the heap, it strives to avoid going over the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt;, even if &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; is not set.</source>
          <target state="translated">デフォルトのページキャッシュは、&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;によって割り当てられたメモリを超えてメモリを使用しないように、より熱心に取り組んでいます。または、ページキャッシュの使用がヒープから割り当てられている場合、&lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;が設定されていなくても、&lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64（）&lt;/a&gt;を超えないように努めます。</target>
        </trans-unit>
        <trans-unit id="b40256b332aa600059fdd4657f3e43acb14b4e3d" translate="yes" xml:space="preserve">
          <source>The default page cache strives more diligently to avoid using memory beyond what is allocated to it by &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. Or if using page cache is allocating from the heap, it strives to avoid going over the &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt;, even if &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; is not set.</source>
          <target state="translated">デフォルトのページキャッシュは、&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;によって割り当てられたメモリを超えてメモリを使用しないように、さらに努力しています。または、ページキャッシュの使用がヒープから割り当てられている場合は、&lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;が設定されていなくても、&lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64（）&lt;/a&gt;を超えないようにします。</target>
        </trans-unit>
        <trans-unit id="619cdf9a91dcb3b5377126d1f738a21802c8e3aa" translate="yes" xml:space="preserve">
          <source>The default page size on windows is automatically adjusted to match the capabilities of the underlying filesystem.</source>
          <target state="translated">Windows上のデフォルトのページサイズは、基礎となるファイルシステムの機能に合わせて自動的に調整されます。</target>
        </trans-unit>
        <trans-unit id="df04859a275716c6652a67712d525008dc797ebb" translate="yes" xml:space="preserve">
          <source>The default setting for SQLITE_MAX_COLUMN is 2000. You can change it at compile time to values as large as 32767. On the other hand, many experienced database designers will argue that a well-normalized database will never need more than 100 columns in a table.</source>
          <target state="translated">SQLITE_MAX_COLUMNのデフォルト設定は2000です。コンパイル時に32767という大きな値に変更することができます。一方で、経験豊富なデータベース設計者の多くは、正規化されたデータベースではテーブルに100以上のカラムが必要になることはないと主張するでしょう。</target>
        </trans-unit>
        <trans-unit id="0506f7d82e65a6fef4e6e411dc34fd230ff22185" translate="yes" xml:space="preserve">
          <source>The default setting for auto-vacuum is 0 or &quot;none&quot;, unless the &lt;a href=&quot;compile#default_autovacuum&quot;&gt;SQLITE_DEFAULT_AUTOVACUUM&lt;/a&gt; compile-time option is used. The &quot;none&quot; setting means that auto-vacuum is disabled. When auto-vacuum is disabled and data is deleted data from a database, the database file remains the same size. Unused database file pages are added to a &quot;&lt;a href=&quot;fileformat2#freelist&quot;&gt;freelist&lt;/a&gt;&quot; and reused for subsequent inserts. So no database file space is lost. However, the database file does not shrink. In this mode the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command can be used to rebuild the entire database file and thus reclaim unused disk space.</source>
          <target state="translated">&lt;a href=&quot;compile#default_autovacuum&quot;&gt;SQLITE_DEFAULT_AUTOVACUUM&lt;/a&gt;コンパイル時オプションが使用されていない限り、自動バキュームのデフォルト設定は0または「なし」です。 「なし」設定は、自動バキュームが無効であることを意味します。自動バキュームが無効で、データがデータベースから削除された場合、データベースファイルは同じサイズのままです。未使用のデータベースファイルページは「&lt;a href=&quot;fileformat2#freelist&quot;&gt;フリーリスト&lt;/a&gt;」に追加され、後続の挿入で再利用されます。したがって、データベースファイル領域が失われることはありません。ただし、データベースファイルは縮小されません。このモードでは、&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;コマンドを使用してデータベースファイル全体を再構築し、未使用のディスク領域を再利用できます。</target>
        </trans-unit>
        <trans-unit id="de25e032063f16295b8e77c37d21842694e060fe" translate="yes" xml:space="preserve">
          <source>The default setting for the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; is 0, which means to following the recommendation of &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_storeプラグマ&lt;/a&gt;のデフォルト設定は0です。これは、&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;コンパイル時パラメーターの推奨に従うことを意味します。</target>
        </trans-unit>
        <trans-unit id="d111baa1a5224d066ace9e922bc0723387d0391f" translate="yes" xml:space="preserve">
          <source>The default setting for this pragma is OFF, which means that all references to the table anywhere in the schema are converted to the new name.</source>
          <target state="translated">このプラグマのデフォルト設定はOFFで、スキーマ内のどこかのテーブルへのすべての参照が新しい名前に変換されることを意味します。</target>
        </trans-unit>
        <trans-unit id="5060b84cc58c53853f2caf81d58480c0590b9ac5" translate="yes" xml:space="preserve">
          <source>The default setting is 1. Additional information can be found in &lt;a href=&quot;tempfiles#tempstore&quot;&gt;tempfiles.html&lt;/a&gt;.</source>
          <target state="translated">デフォルト設定は1です。追加情報は&lt;a href=&quot;tempfiles#tempstore&quot;&gt;tempfiles.htmlにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="4e7fc079075b7fd84d6268869958a93f9d4d68c3" translate="yes" xml:space="preserve">
          <source>The default sorting procedure is to gather all information that will ultimately be output into a &quot;record&quot; and pass that complete record to the sorter. But in some cases, for example if some of the output columns consists of large BLOB values, the size of the each record can be large, which means that the sorter has to either use more memory, and/or write more content to temporary storage.</source>
          <target state="translated">デフォルトのソート手順は、最終的に &quot;レコード &quot;に出力されるすべての情報を収集し、その完全なレコードをソーターに渡すことです。しかし、いくつかのケースでは、例えば、出力列のいくつかが大きなBLOB値で構成されている場合、各レコードのサイズが大きくなることがあります。</target>
        </trans-unit>
        <trans-unit id="6f4517865a59fec2a530bec6db77e7cd99eb8490" translate="yes" xml:space="preserve">
          <source>The default strategy is to allow successive write transactions to grow the WAL until the WAL becomes about 1000 pages in size, then to run a checkpoint operation for each subsequent COMMIT until the WAL is reset to be smaller than 1000 pages. By default, the checkpoint will be run automatically by the same thread that does the COMMIT that pushes the WAL over its size limit. This has the effect of causing most COMMIT operations to be very fast but an occasional COMMIT (those that trigger a checkpoint) to be much slower. If that effect is undesirable, then the application can disable automatic checkpointing and run the periodic checkpoints in a separate thread, or separate process. (Links to commands and interfaces to accomplish this are &lt;a href=&quot;#how_to_checkpoint&quot;&gt;shown below&lt;/a&gt;.)</source>
          <target state="translated">デフォルトの戦略では、WALのサイズが約1000ページになるまで、連続する書き込みトランザクションでWALを拡張し、その後、WALが1000ページ未満にリセットされるまで、後続の各COMMITに対してチェックポイント操作を実行します。デフォルトでは、チェックポイントは、サイズ制限を超えてWALをプッシュするCOMMITを実行する同じスレッドによって自動的に実行されます。これにより、ほとんどのCOMMIT操作が非常に高速になりますが、時々発生するCOMMIT（チェックポイントをトリガーする操作）は非常に遅くなります。その影響が望ましくない場合、アプリケーションは自動チェックポイントを無効にして、別のスレッドまたは別のプロセスで定期的なチェックポイントを実行できます。 （これを実現するためのコマンドとインターフェースへのリンクを&lt;a href=&quot;#how_to_checkpoint&quot;&gt;以下に示します&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="7aba3882e935c491d72d10d266cb950c10ccee5f" translate="yes" xml:space="preserve">
          <source>The default substitution cost</source>
          <target state="translated">デフォルトの代用コスト</target>
        </trans-unit>
        <trans-unit id="6947c6a992789a324c997f5478292dca047e240d" translate="yes" xml:space="preserve">
          <source>The default synchronous setting is full so the above is what usually happens. However, if the synchronous setting is lowered to &quot;normal&quot;, SQLite only flushes the rollback journal once, after the page count has been written. This carries a risk of corruption because it might happen that the modified (non-zero) page count reaches the disk surface before all of the data does. The data will have been written first, but SQLite assumes that the underlying filesystem can reorder write requests and that the page count can be burned into oxide first even though its write request occurred last. So as a second line of defense, SQLite also uses a 32-bit checksum on every page of data in the rollback journal. This checksum is evaluated for each page during rollback while rolling back a journal as described in &lt;a href=&quot;#section_4_4&quot;&gt;section 4.4&lt;/a&gt;. If an incorrect checksum is seen, the rollback is abandoned. Note that the checksum does not guarantee that the page data is correct since there is a small but finite probability that the checksum might be right even if the data is corrupt. But the checksum does at least make such an error unlikely.</source>
          <target state="translated">デフォルトの同期設定はフルであるため、上記が通常発生します。ただし、同期設定を「通常」に下げると、SQLiteは、ページカウントが書き込まれた後、ロールバックジャーナルを一度だけフラッシュします。すべてのデータが到達する前に、変更された（ゼロ以外の）ページカウントがディスク表面に到達する可能性があるため、これは破損のリスクを伴います。データは最初に書き込まれますが、SQLiteは、基礎となるファイルシステムが書き込み要求を並べ替えることができ、書き込み要求が最後に発生した場合でも、ページカウントを最初に酸化物に書き込むことができると想定しています。したがって、SQLiteは2番目の防御線として、ロールバックジャーナルのデータのすべてのページで32ビットチェックサムを使用します。&lt;a href=&quot;#section_4_4&quot;&gt;セクション4.4で&lt;/a&gt;説明されているように、このチェックサムは、ジャーナルをロールバックしている間、ロールバック中に各ページに対して評価されます。。不正なチェックサムが表示された場合、ロールバックは中止されます。データが破損している場合でもチェックサムが正しい可能性は小さいが有限の確率があるため、チェックサムはページデータが正しいことを保証しないことに注意してください。しかし、チェックサムは少なくともそのようなエラーを起こしそうにありません。</target>
        </trans-unit>
        <trans-unit id="095be1a2c22dcc1b72f1d8ee5a80821a8e3ba1f7" translate="yes" xml:space="preserve">
          <source>The default value for SQLITE_PRINTF_PRECISION_LIMIT is 2147483647 (0x7fffffff).</source>
          <target state="translated">SQLITE_PRINTF_PRECISION_LIMIT のデフォルト値は 2147483647 (0x7fffffff)です。</target>
        </trans-unit>
        <trans-unit id="5887e5cef0e652ea249c383a61a9790399db5025" translate="yes" xml:space="preserve">
          <source>The default value for languageid is 0. If an alternative language is specified in WHERE clause constraints, then that alternative is used instead of 0. There can only be a single languageid per query. In other words, the WHERE clause cannot contain a range constraint or IN operator on the languageid.</source>
          <target state="translated">languageidのデフォルト値は0です。 WHERE句の制約で代替言語が指定されている場合は、その代替言語が0の代わりに使用されます。 クエリごとに1つのlanguageidだけを指定することができます。言い換えれば、WHERE句には、languageidに範囲制約やIN演算子を含めることはできません。</target>
        </trans-unit>
        <trans-unit id="3d6f85ef321cfdfaecfbd8525333d39487f3c884" translate="yes" xml:space="preserve">
          <source>The default value of a languageid column is 0. Any value inserted into a languageid column is converted to a 32-bit (not 64) signed integer.</source>
          <target state="translated">languageid列のデフォルト値は0です。 languageid列に挿入された値はすべて32ビットの符号付き整数に変換されます(64ではありません)。</target>
        </trans-unit>
        <trans-unit id="0bb45f8540234b96b45cb058d442c35d3ea03bfa" translate="yes" xml:space="preserve">
          <source>The default value of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter is 1, which means to store temporary files on disk but provide the option of overriding the behavior using the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;コンパイル時パラメーターのデフォルト値は1です。これは、一時ファイルをディスクに格納することを意味しますが、&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_storeプラグマ&lt;/a&gt;を使用して動作をオーバーライドするオプションを提供します。</target>
        </trans-unit>
        <trans-unit id="3aae70c9121f536fa334d3f452170e8968ea3458" translate="yes" xml:space="preserve">
          <source>The default value of the usermerge option is 4. The minimum allowed value is 2, and the maximum 16.</source>
          <target state="translated">usermergeオプションのデフォルト値は4で、最小許容値は2、最大許容値は16です。</target>
        </trans-unit>
        <trans-unit id="6973079b710b23783ded0a80f07fc117f677c334" translate="yes" xml:space="preserve">
          <source>The default virtual table (&quot;rtree&quot;) normally stores coordinates as single-precision (4-byte) floating point numbers. If integer coordinates are desired, declare the table using &quot;rtree_i32&quot; instead:</source>
          <target state="translated">デフォルトの仮想テーブル (&quot;rtree&quot;)は通常、座標を単精度 (4 バイト)の浮動小数点数で格納します。整数の座標が必要な場合は、代わりに &quot;rtree_i32&quot; を使用してテーブルを宣言します。</target>
        </trans-unit>
        <trans-unit id="f282a44d7dfb6c6134a7e29df48c07aa44737ff7" translate="yes" xml:space="preserve">
          <source>The demonstration code assumes that the SQLite database is opened used as a database object named &quot;db&quot;.</source>
          <target state="translated">デモコードは、SQLiteデータベースが &quot;db &quot;という名前のデータベースオブジェクトとして使用されて開かれていることを前提としています。</target>
        </trans-unit>
        <trans-unit id="8837968f443dfe5005184f2c6a7e1c74103e5e88" translate="yes" xml:space="preserve">
          <source>The demonstration code below includes a status_refresh method that grays-out or activates the Undo and Redo buttons and menu entries depending on whether or not there is anything to be undone or redone. You will need to redefine this method to control the Undo and Redo buttons in your application.</source>
          <target state="translated">以下のデモコードには、元に戻すかやり直すかに応じて、元に戻すボタンややり直しボタン、メニュー項目をグレーアウトしたり、アクティブにしたりする status_refresh メソッドが含まれています。アプリケーションで元に戻すボタンややり直しボタンを制御するには、このメソッドを再定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="e759858c504e056da064aff365282dc111db1fea" translate="yes" xml:space="preserve">
          <source>The depth of recursion for triggers has a hard upper limit set by the &lt;a href=&quot;limits#max_trigger_depth&quot;&gt;SQLITE_MAX_TRIGGER_DEPTH&lt;/a&gt; compile-time option and a run-time limit set by &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimittriggerdepth&quot;&gt;SQLITE_LIMIT_TRIGGER_DEPTH&lt;/a&gt;,...).</source>
          <target state="translated">トリガーの再帰の深さには、&lt;a href=&quot;limits#max_trigger_depth&quot;&gt;SQLITE_MAX_TRIGGER_DEPTH&lt;/a&gt;コンパイル時オプションによって設定されるハード上限と、&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimittriggerdepth&quot;&gt;SQLITE_LIMIT_TRIGGER_DEPTH&lt;/a&gt;、...）によって設定されるランタイム制限があります。</target>
        </trans-unit>
        <trans-unit id="40be115b96b882b5a59636c2c2b3cce3bdbb02d6" translate="yes" xml:space="preserve">
          <source>The descendants of OpenOffice tend to segfault more often than commercial competitors. Perhaps for this reason, the OpenOffice forks make periodic backups of their in-memory documents so that users do not lose all pending edits when the inevitable application crash does occur. This causes frustrating pauses in the application for the few seconds while each backup is being made. After restarting from a crash, the user is presented with a dialog box that walks them through the recovery process. Managing the crash recovery this way involves lots of extra application logic and is generally an annoyance to the user.</source>
          <target state="translated">OpenOffice の子孫は商業的な競争相手よりも頻繁にセグメンテーションフォールトを起こす傾向があります。おそらくこの理由のためか、OpenOffice のフォークは、不可避なアプリケーションのクラッシュが発生したときにユーザーが保留中のすべての編集を失わないように、定期的にメモリ内のドキュメントのバックアップを作成します。これは各バックアップが行われている間の数秒間のアプリケーションのイライラするような一時停止を引き起こします。クラッシュから再起動すると、回復プロセスを説明するダイアログボックスが表示されます。この方法でクラッシュ回復を管理すると、多くの余分なアプリケーションロジックが必要となり、一般的にはユーザーを悩ませることになります。</target>
        </trans-unit>
        <trans-unit id="2a2b8799305e9ca9fdc0f3b11f07bd75b53378d6" translate="yes" xml:space="preserve">
          <source>The designed query interface is:</source>
          <target state="translated">設計されたクエリインターフェースは</target>
        </trans-unit>
        <trans-unit id="85d6b31a6dd13fa4a2b19e14c162e00851337050" translate="yes" xml:space="preserve">
          <source>The detail option may be set to &quot;full&quot; (the default value), &quot;column&quot; or &quot;none&quot;. For example:</source>
          <target state="translated">詳細オプションは、&quot;full&quot;(デフォルト値)、&quot;column&quot;、または &quot;none &quot;のいずれかに設定することができます。例えば</target>
        </trans-unit>
        <trans-unit id="1de34563fa7a58730a8b8b8a025ab7bdcb0a2940" translate="yes" xml:space="preserve">
          <source>The details of optimizations performed by this pragma are expected to change and improve over time. Applications should anticipate that this pragma will perform new optimizations in future releases.</source>
          <target state="translated">このpragmaによって実行される最適化の詳細は、時間の経過とともに変化し、改善されることが予想されます。アプリケーションは、将来のリリースでこのプラグマが新しい最適化を実行することを期待してください。</target>
        </trans-unit>
        <trans-unit id="2ec6e7a356da9ba89cc679a27100e250b07d2b68" translate="yes" xml:space="preserve">
          <source>The details of the behavior of the sqlite3_step() interface depend on whether the statement was prepared using the newer &quot;vX&quot; interfaces &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt; or the older legacy interfaces &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;. The use of the new &quot;vX&quot; interface is recommended for new applications but the legacy interface will continue to be supported.</source>
          <target state="translated">sqlite3_step（）インターフェースの動作の詳細については、ステートメントは、新しい「のvX」インターフェースを用いて調製したかどうかに依存&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3（） &lt;/a&gt;、&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（） &lt;/a&gt;、&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3（） &lt;/a&gt;、&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;または古いレガシーインターフェイスは&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;と&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16を（）&lt;/a&gt;。新しいアプリケーションには新しい「vX」インターフェースの使用が推奨されますが、レガシーインターフェースは引き続きサポートされます。</target>
        </trans-unit>
        <trans-unit id="a66564cccde706fd2f76931336faa29d5380763d" translate="yes" xml:space="preserve">
          <source>The details of the behavior of the sqlite3_step() interface depend on whether the statement was prepared using the newer &quot;vX&quot; interfaces &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt; or the older legacy interfaces &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; and &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;. The use of the new &quot;vX&quot; interface is recommended for new applications but the legacy interface will continue to be supported.</source>
          <target state="translated">sqlite3_step（）インターフェースの動作の詳細については、ステートメントは、新しい「のvX」インターフェースを用いて調製したかどうかに依存&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3（） &lt;/a&gt;、&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（） &lt;/a&gt;、&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3（） &lt;/a&gt;、&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;または古いレガシーインターフェイスは&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;と&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16を（）&lt;/a&gt;。新しいアプリケーションには新しい「vX」インターフェースの使用が推奨されますが、レガシーインターフェースは引き続きサポートされます。</target>
        </trans-unit>
        <trans-unit id="d328873bfc7a5d2f8f59abeab740350558a37fbf" translate="yes" xml:space="preserve">
          <source>The details of the effects of the analysis limit described in the previous paragraph are subject to change in future versions of SQLite. But the core idea will remain the same. An analysis limit of N will strive to limit the number of rows visited in each index to approximately N.</source>
          <target state="translated">前項で説明した解析限界の影響の詳細は、今後のSQLiteのバージョンで変更される可能性があります。しかし、核心的な考え方は変わりません。Nの分析制限は、各インデックスで訪問する行数を約Nに制限しようとするものです。</target>
        </trans-unit>
        <trans-unit id="47cfb6e87da2bbb4d38b35a83664b9fdcddd81cb" translate="yes" xml:space="preserve">
          <source>The details of the operation codes, their meanings, the parameters they take, and what they do are all subject to change without notice. Unlike most of the SQLite API, this function is not guaranteed to operate consistently from one release to the next.</source>
          <target state="translated">操作コードの詳細、その意味、それらが取るパラメータ、そしてそれらが何をするかは、すべて予告なく変更される可能性があります。ほとんどの SQLite API とは異なり、この関数はあるリリースから次のリリースまで一貫して動作することは保証されていません。</target>
        </trans-unit>
        <trans-unit id="dd71fb5d39136060492d732375a6fec71ebfc8ad" translate="yes" xml:space="preserve">
          <source>The developers are also on the lookout for new ways to optimize the commit mechanism. The current VFS implementations for Unix (Linux and Mac OS X) and Windows make pessimistic assumptions about the behavior of those systems. After consultation with experts on how these systems work, we might be able to relax some of the assumptions on these systems and allow them to run faster. In particular, we suspect that most modern filesystems exhibit the safe append property and that many of them might support atomic sector writes. But until this is known for certain, SQLite will take the conservative approach and assume the worst.</source>
          <target state="translated">開発者はまた、コミットメカニズムを最適化するための新しい方法を模索しています。現在の Unix (Linux と Mac OS X)と Windows 用の VFS の実装は、これらのシステムの動作について悲観的な仮定をしています。これらのシステムがどのように動作するかについて専門家と相談した結果、これらのシステムの前提条件をいくつか緩和し、より高速に動作させることができるようになるかもしれません。特に、最新のファイルシステムのほとんどは安全な追加特性を持ち、それらの多くはアトミックセクタ書き込みをサポートしているのではないかと考えています。しかし、これが確実に判明するまでは、SQLite は保守的なアプローチをとり、最悪の事態を想定しています。</target>
        </trans-unit>
        <trans-unit id="cba4f98976654b480368200cf64e4d7ca1caf336" translate="yes" xml:space="preserve">
          <source>The developers of SQLite are confident that it is robust in the face of power failures and system crashes because the automatic test procedures do extensive checks on the ability of SQLite to recover from simulated power loss. We call these the &quot;crash tests&quot;.</source>
          <target state="translated">SQLite の開発者は、停電やシステムクラッシュに直面しても SQLite が堅牢であることを確信しています。これを「クラッシュテスト」と呼んでいます。</target>
        </trans-unit>
        <trans-unit id="57e3f42d8aa639c2f77c64f6029c9126e99e122e" translate="yes" xml:space="preserve">
          <source>The developers of SQLite have found that full coverage testing is an extremely effective method for locating and preventing bugs. Because every single branch instruction in SQLite core code is covered by test cases, the developers can be confident that changes made in one part of the code do not have unintended consequences in other parts of the code. The many new features and performance improvements that have been added to SQLite in recent years would not have been possible without the availability full-coverage testing.</source>
          <target state="translated">SQLite の開発者は、フルカバレッジテストがバグを発見し、防止するために非常に効果的な方法であることに気づいています。SQLiteコアコードのすべての分岐命令がテストケースでカバーされているため、開発者はコードのある部分で行われた変更が他の部分で意図しない結果を招くことがないことを確信することができます。近年SQLiteに追加された多くの新機能やパフォーマンスの向上は、フルカバレッジテストなしでは実現できなかったでしょう。</target>
        </trans-unit>
        <trans-unit id="c6e54cb667da50110192519bd611d69d7d2d59cd" translate="yes" xml:space="preserve">
          <source>The developers of SQLite intend to support the product through the year 2050. To this end, the source code is carefully documented to promote long-term maintainability. We prefer mature and stable over trendy and cutting-edge.</source>
          <target state="translated">SQLite の開発者は、2050 年まで製品をサポートすることを意図しています。そのために、ソースコードは長期的な保守性を促進するために慎重に文書化されています。私たちは、流行や最先端のものよりも成熟した安定したものを好みます。</target>
        </trans-unit>
        <trans-unit id="aa1c82e2078fb346e28f27499859e5261dd7cb0d" translate="yes" xml:space="preserve">
          <source>The diagram above implies that SQLite computes all of the rowids first and then combines them with a union operation before starting to do rowid lookups on the original table. In reality, the rowid lookups are interspersed with rowid computations. SQLite uses one index at a time to find rowids while remembering which rowids it has seen before so as to avoid duplicates. That is just an implementation detail, though. The diagram, while not 100% accurate, provides a good overview of what is happening.</source>
          <target state="translated">上の図は、SQLite が最初にすべての行 ID を計算してから、元のテーブルの行 ID の検索を開始する前に、それらの行 ID を和演算で結合することを意味しています。実際には、行 ID の検索は行 ID の計算と並行して行われます。SQLite は、重複を避けるために、以前に見たことのある行番号を記憶しながら、一度に一つのインデックスを使用して行番号を検索します。これは実装の詳細に過ぎません。この図は100%正確ではありませんが、何が起こっているのかの良い概要を提供しています。</target>
        </trans-unit>
        <trans-unit id="cc06f8d8201603f348e84ed00b97e2bebb250253" translate="yes" xml:space="preserve">
          <source>The diagram at the right illustrates the concept. One begins with a standard SQLite release. For the sake of example, suppose that one intends to create a private branch off of SQLite version 3.6.15. In the diagram this is version (1). The maintainer makes an exact copy of the baseline SQLite into the branch space, shown as version (2). Note that (1) and (2) are exactly the same. Then the maintainer applies the private changes to version (2) resulting in version (3). In other words, version (3) is SQLite version 3.6.15 plus edits.</source>
          <target state="translated">右の図は、そのコンセプトを説明しています。まず、標準的なSQLiteのリリースから始めます。例として、SQLiteバージョン3.6.15からプライベートブランチを作成しようとしたとします。図ではこれがバージョン(1)です。メンテナは、ベースライン SQLite の正確なコピーをブランチ空間に作成します。(1)と(2)は全く同じであることに注意してください。そして、メンテナはプライベートな変更をバージョン(2)に適用し、結果としてバージョン(3)を生成します。言い換えれば、バージョン(3)はSQLiteのバージョン3.6.15に編集を加えたものです。</target>
        </trans-unit>
        <trans-unit id="7b170d383461e4dd7d9f55e0934f811bdf7d240b" translate="yes" xml:space="preserve">
          <source>The difference between reading from the rank column and using the bm25() function directly within the query is only significant when sorting by the returned value. In this case, using &quot;rank&quot; is faster than using bm25().</source>
          <target state="translated">rank列から読み込む場合と、クエリ内で直接bm25()関数を使用する場合の違いは、返された値でソートする場合にのみ大きくなります。この場合、&quot;rank &quot;を使用する方がbm25()を使用するよりも高速です。</target>
        </trans-unit>
        <trans-unit id="9a6b573084b906296ca61d103b50efb82fd91899" translate="yes" xml:space="preserve">
          <source>The difference between this option and the 'automerge' option is that when the 'automerge' limit is reached FTS5 only begins to merge the b-trees together. Most of the work is performed as part of subsequent INSERT, UPDATE or DELETE operations. Whereas when the 'crisismerge' limit is reached, the offending b-trees are all merged immediately. This means that an INSERT, UPDATE or DELETE that triggers a crisis-merge may take a long time to complete.</source>
          <target state="translated">このオプションと 'automerge' オプションの違いは、'automerge' の制限に達すると、FTS5 は b-tree の結合を開始するだけであるということです。ほとんどの作業は、その後のINSERT、UPDATE、DELETE操作の一部として実行されます。一方、'crisismerge'リミットに達すると、問題のあるb-treeはすべて即座にマージされます。これは、危機的なマージのトリガーとなるINSERT、UPDATE、またはDELETEは、完了するまでに長い時間がかかる可能性があることを意味します。</target>
        </trans-unit>
        <trans-unit id="6b73e10a6ce3d527b6333ec3f4b76095553830b9" translate="yes" xml:space="preserve">
          <source>The difference is that xConnect is called to establish a new connection to an existing virtual table whereas xCreate is called to create a new virtual table from scratch.</source>
          <target state="translated">違いは、xConnect が既存の仮想テーブルへの新しい接続を確立するために呼び出されるのに対し、xCreate がゼロから新しい仮想テーブルを作成するために呼び出されることです。</target>
        </trans-unit>
        <trans-unit id="2f41e80a4cb41a6cee44f4eaec98226e9c29f84f" translate="yes" xml:space="preserve">
          <source>The differences between a patchset and a changeset are that:</source>
          <target state="translated">パッチセットとチェンジセットの違いは、その点です。</target>
        </trans-unit>
        <trans-unit id="4fa2acc79952a3a20f72fc7c3e0f092b1e96e820" translate="yes" xml:space="preserve">
          <source>The differences between an &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TEMP_DB&lt;/a&gt; database and an &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TRANSIENT_DB&lt;/a&gt; database is this: The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TEMP_DB&lt;/a&gt; is used for explicitly declared and named TEMP tables (using the CREATE TEMP TABLE syntax) or for named tables in a temporary database that is created by opening a database with a filename that is an empty string. An &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TRANSIENT_DB&lt;/a&gt; holds a database table that SQLite creates automatically in order to evaluate a subquery or ORDER BY or GROUP BY clause. Both TEMP_DB and TRANSIENT_DB databases are private and are deleted automatically. TEMP_DB databases last for the duration of the database connection. TRANSIENT_DB databases last only for the duration of a single SQL statement.</source>
          <target state="translated">間の違い&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TEMP_DBの&lt;/a&gt;データベースと&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TRANSIENT_DBの&lt;/a&gt;データベースはこれです：&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TEMP_DBは&lt;/a&gt;（CREATE TEMP TABLE構文を使用して）明示的に宣言し、名前のTEMPテーブルのために使用されるか、またはファイル名でデータベースをオープンすることによって作成される一時的なデータベース内の名前付きのテーブルのためにされますそれは空の文字列です。アン&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TRANSIENT_DBは、&lt;/a&gt; SQLiteのは、サブクエリまたはORDER BYまたはGROUP BY句を評価するために、自動的に作成されるデータベーステーブルを保持しています。 TEMP_DBデータベースとTRANSIENT_DBデータベースはどちらもプライベートであり、自動的に削除されます。 TEMP_DBデータベースは、データベース接続の間存続します。 TRANSIENT_DBデータベースは、単一のSQLステートメントの間だけ持続します。</target>
        </trans-unit>
        <trans-unit id="ea188c1a8a3d9f0d3afac3d8adfd72df27cd7aa2" translate="yes" xml:space="preserve">
          <source>The direct-to-disk writes are accomplished using fopen()/fwrite()/fclose(). By default, and in all the results shown below, the OS filesystem buffers are never flushed to persistent storage using fsync() or FlushFileBuffers(). In other words, there is no attempt to make the direct-to-disk writes transactional or power-safe. We found that invoking fsync() or FlushFileBuffers() on each file written causes direct-to-disk storage to be about 10 times or more slower than writes to SQLite.</source>
          <target state="translated">直接ディスクへの書き込みは、fopen()/fwrite()/fclose()を使用して行われます。デフォルトでは、以下に示すすべての結果において、OS のファイルシステムバッファは fsync()や FlushFileBuffers()を使用して永続的なストレージにフラッシュされることはありません。言い換えれば、直接ディスクへの書き込みをトランザクション的にもパワーセーフにもしようとする試みはありません。書き込まれた各ファイルに対して fsync()や FlushFileBuffers()を実行すると、直接ディスクへの書き込みが SQLite への書き込みの約 10 倍以上遅くなることがわかりました。</target>
        </trans-unit>
        <trans-unit id="480bdad0842ce92215a602c8e8a2e2ba5036d89a" translate="yes" xml:space="preserve">
          <source>The directory or folder in which temporary files are created is determined by the OS-specific &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;.</source>
          <target state="translated">一時ファイルが作成されるディレクトリまたはフォルダーは、OS固有の&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;によって決定されます。</target>
        </trans-unit>
        <trans-unit id="58c1fd9cf0b8fae2622f0a1831b48a0d95eaabc6" translate="yes" xml:space="preserve">
          <source>The directory set by &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA temp_store_directory&lt;/a&gt; or by the &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA temp_store_directory&lt;/a&gt;または&lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;グローバル変数によって設定されたディレクトリ</target>
        </trans-unit>
        <trans-unit id="8e347995ace178c5b68534f7a6dde94c35392830" translate="yes" xml:space="preserve">
          <source>The directory used to hold temporary files on unix can now be set using the SQLITE_TMPDIR environment variable, which takes precedence over the TMPDIR environment variable. The &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable still has higher precedence than both environment variables, however.</source>
          <target state="translated">UNIXで一時ファイルを保持するために使用されるディレクトリは、SQLITE_TMPDIR環境変数を使用して設定できるようになりました。これは、TMPDIR環境変数よりも優先されます。&lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;グローバル変数はまだしかし、両方の環境変数よりも優先順位が高いです。</target>
        </trans-unit>
        <trans-unit id="081d4a11583041f4e8625a8cc56c88ce7150faa6" translate="yes" xml:space="preserve">
          <source>The docid value. The first entry in a doclist contains the literal docid value. The first field of each subsequent doclist entry contains the difference between the new docid and the previous one (always a positive number).</source>
          <target state="translated">docid 値。doclist の最初のエントリには、リテラルの docid 値が含まれます。後続の各 doclist エントリの最初のフィールドには、新しい docid と前の docid との差分が含まれます (常に正の数)。</target>
        </trans-unit>
        <trans-unit id="49e2bf067b92acf951896b04368654ffcd3a3f99" translate="yes" xml:space="preserve">
          <source>The document only describes locking for the older rollback-mode transaction mechanism. Locking for the newer &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; or &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; is described separately.</source>
          <target state="translated">このドキュメントでは、古いロールバックモードのトランザクションメカニズムのロックについてのみ説明しています。新しい&lt;a href=&quot;wal&quot;&gt;先読みログ&lt;/a&gt;または&lt;a href=&quot;wal&quot;&gt;WALモードの&lt;/a&gt;ロックについては、別途説明します。</target>
        </trans-unit>
        <trans-unit id="1297878fc527d5d7c17142be2f4f043e484d8aa6" translate="yes" xml:space="preserve">
          <source>The documentation is maintained in separate source repositories on those same servers:</source>
          <target state="translated">ドキュメントは、同じサーバー上の別のソースリポジトリで管理されています。</target>
        </trans-unit>
        <trans-unit id="d0017ab9193a6ed1029ad59fab58ce3ec88e592f" translate="yes" xml:space="preserve">
          <source>The documentation sources include documentation text and images with the scripts and makefile needed to construct the SQLite website documentation. This document is contained within the documentation sources. The document sources are kept in a separate repository distinct from the source code. The documentation sources repository is publicly readable.</source>
          <target state="translated">ドキュメントソースには、SQLite ウェブサイトのドキュメントを構築するために必要なスクリプトと makefile を含むドキュメントのテキストとイメージが含まれています。このドキュメントはドキュメントソースの中に含まれています。ドキュメントソースは、ソースコードとは別のリポジトリに保管されています。ドキュメントソースのリポジトリは一般に読めるようになっています。</target>
        </trans-unit>
        <trans-unit id="278f1b137f0865ba684c7cde1fa14cf1c768e813" translate="yes" xml:space="preserve">
          <source>The documentation system automatically maintains a &lt;a href=&quot;https://sqlite.org/chronology.html&quot;&gt;chronology&lt;/a&gt; of past releases, as well as a &lt;a href=&quot;changes&quot;&gt;complete list of SQLite releases&lt;/a&gt; with change summaries.</source>
          <target state="translated">ドキュメントシステムは、過去のリリースの&lt;a href=&quot;https://sqlite.org/chronology.html&quot;&gt;年表&lt;/a&gt;と、変更の要約&lt;a href=&quot;changes&quot;&gt;を含むSQLiteリリースの完全なリストを&lt;/a&gt;自動的に維持します。</target>
        </trans-unit>
        <trans-unit id="65988e654b808af94ee6da6f09345ac1241a1ac8" translate="yes" xml:space="preserve">
          <source>The dot-command must be entirely contained on a single input line.</source>
          <target state="translated">ドットコマンドは、1 つの入力行に完全に含まれていなければなりません。</target>
        </trans-unit>
        <trans-unit id="6fcffd0a57b5ba6715e1715a67438a136bebf610" translate="yes" xml:space="preserve">
          <source>The dot-commands are interpreted by the sqlite3.exe command-line program, not by SQLite itself. So none of the dot-commands will work as an argument to SQLite interfaces like &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt;.</source>
          <target state="translated">ドットコマンドは、SQLite自体ではなく、sqlite3.exeコマンドラインプログラムによって解釈されます。したがって、ドットコマンドは、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;や&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）の&lt;/a&gt;ようなSQLiteインターフェースへの引数として機能しません。</target>
        </trans-unit>
        <trans-unit id="73b101a4a2aed2c88c1089ef5e27eb7bd916289f" translate="yes" xml:space="preserve">
          <source>The downside of automatic incremental merging is that it makes every INSERT, UPDATE, and DELETE operation on an FTS3/4 table run a little slower, since extra time must be used to do the incremental merge. For maximum performance, it is recommended that applications disable automatic incremental merge and instead use the &lt;a href=&quot;fts3#*fts4mergecmd&quot;&gt;&quot;merge&quot; command&lt;/a&gt; in an idle process to keep the inverted indices well merged. But if the structure of an application does not easily allow for idle processes, the use of automatic incremental merge is a very reasonable fallback solution.</source>
          <target state="translated">自動増分マージの欠点は、FTS3 / 4テーブルでのすべてのINSERT、UPDATE、およびDELETE操作の実行が少し遅くなることです。これは、増分マージを行うために余分な時間を使用する必要があるためです。最大のパフォーマンスを得るには、アプリケーションで自動インクリメンタルマージを無効にし、代わりにアイドルプロセスで&lt;a href=&quot;fts3#*fts4mergecmd&quot;&gt;「merge」コマンドを&lt;/a&gt;使用して、反転したインデックスを適切にマージすることをお勧めします。しかし、アプリケーションの構造がアイドルプロセスを容易に許容しない場合、自動インクリメンタルマージの使用は非常に合理的なフォールバックソリューションです。</target>
        </trans-unit>
        <trans-unit id="c77ebced48dfa7e23a77c44a167057f7558d4f17" translate="yes" xml:space="preserve">
          <source>The downside of storing schema a text is that it can make the schema tricky to modify. And for that reason, the ALTER TABLE support in SQLite has traditionally lagged behind other SQL database engines that store their schemas as parsed system tables that are easier to modify.</source>
          <target state="translated">スキーマをテキストとして保存することの欠点は、スキーマを変更するのが難しいということです。そのため、SQLiteのALTER TABLEサポートは伝統的に他のSQLデータベースエンジンに遅れをとってきましたが、それはスキーマを変更しやすい解析されたシステムテーブルとして保存することです。</target>
        </trans-unit>
        <trans-unit id="1bd6a18e90f1a8ee8256e02fe4825c2a58f166f7" translate="yes" xml:space="preserve">
          <source>The dynamic webpages on the SQLite website are mostly generated by the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil version control system&lt;/a&gt;. A typical dynamic page would be a timeline such as &lt;a href=&quot;https://www.sqlite.org/src/timeline&quot;&gt;https://www.sqlite.org/src/timeline&lt;/a&gt;. A log of all SQL used by the timeline is shown below.</source>
          <target state="translated">SQLite Webサイトの動的Webページは、主に&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossilバージョン管理システム&lt;/a&gt;によって生成されます。典型的な動的ページは、&lt;a href=&quot;https://www.sqlite.org/src/timeline&quot;&gt;https：&lt;/a&gt; //www.sqlite.org/src/timelineなどのタイムラインです。タイムラインで使用されるすべてのSQLのログを以下に示します。</target>
        </trans-unit>
        <trans-unit id="f53c608dfb99715244babeb0f18e6bedb4ce61c6" translate="yes" xml:space="preserve">
          <source>The eTextRep argument determines the encoding of strings passed to the collating function callback, xCallback. The &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt; and &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; values for eTextRep force strings to be UTF16 with native byte order. The &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; value for eTextRep forces strings to begin on an even byte address.</source>
          <target state="translated">eTextRep引数は、照合関数コールバックxCallbackに渡される文字列のエンコーディングを決定します。&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;と&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt;ネイティブのバイト順でUTF16なるようにeTextRep力文字列の値。&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; eTextRepの値は偶数バイトアドレスに開始するように文字列を強制します。</target>
        </trans-unit>
        <trans-unit id="1f8a73896c29d2961fd12e3fd13060416db06dbd" translate="yes" xml:space="preserve">
          <source>The eTextRep argument determines the encoding of strings passed to the collating function callback, xCallback. The &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt; and &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; values for eTextRep force strings to be UTF16 with native byte order. The &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; value for eTextRep forces strings to begin on an even byte address.</source>
          <target state="translated">eTextRep引数は、照合関数コールバックxCallbackに渡される文字列のエンコーディングを決定します。&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;と&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt;ネイティブのバイト順でUTF16なるようにeTextRep力文字列の値。&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; eTextRepの値は偶数バイトアドレスに開始するように文字列を強制します。</target>
        </trans-unit>
        <trans-unit id="4013154ef9b1afc10a2efd1408a9638085e650fc" translate="yes" xml:space="preserve">
          <source>The eTextRep argument determines the encoding of strings passed to the collating function callback, xCompare. The &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt; and &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; values for eTextRep force strings to be UTF16 with native byte order. The &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; value for eTextRep forces strings to begin on an even byte address.</source>
          <target state="translated">eTextRep引数は、照合関数のコールバックxCompareに渡される文字列のエンコーディングを決定します。&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;と&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt;ネイティブのバイト順でUTF16なるようにeTextRep力文字列の値。&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; eTextRepの値は偶数バイトアドレスに開始するように文字列を強制します。</target>
        </trans-unit>
        <trans-unit id="7222f354f082d59aa96eba0376b7b091cc4ec0bd" translate="yes" xml:space="preserve">
          <source>The eTextRep argument determines the encoding of strings passed to the collating function callback, xCompare. The &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt; and &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; values for eTextRep force strings to be UTF16 with native byte order. The &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; value for eTextRep forces strings to begin on an even byte address.</source>
          <target state="translated">eTextRep引数は、照合関数のコールバックxCompareに渡される文字列のエンコーディングを決定します。&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;と&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt;ネイティブのバイト順でUTF16なるようにeTextRep力文字列の値。&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; eTextRepの値は偶数バイトアドレスに開始するように文字列を強制します。</target>
        </trans-unit>
        <trans-unit id="af71ae840c72707272be3031b3c3ee6f45c5d71f" translate="yes" xml:space="preserve">
          <source>The edit distance coefficients are normally read from the APPCOST table once and there after stored in memory. Hence, run-time changes to the APPCOST table will not normally affect the edit distance results. However, inserting the special string 'reset' into the &quot;command&quot; column of the virtual table causes the edit distance coefficients to be reread the APPCOST table. Hence, applications should run a SQL statement similar to the following when changes to the APPCOST table occur:</source>
          <target state="translated">編集距離係数は通常、APPCOSTテーブルから一度読み出され、その後メモリに格納されます。したがって、APPCOSTテーブルへのランタイム変更は、通常、編集距離の結果には影響しません。しかし、仮想テーブルの &quot;command &quot;列に特別な文字列'reset'を挿入すると、編集距離係数がAPPCOSTテーブルから再読み込みされる。したがって、アプリケーションは、APPCOSTテーブルへの変更が発生したときに、以下のようなSQL文を実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="49994af0743488763f79d75d2c9c86ebfda2dfb6" translate="yes" xml:space="preserve">
          <source>The edit program can also be used as a viewer, by simply ignoring the return value. For example, to merely look at the image above, you might run:</source>
          <target state="translated">編集プログラムは、単に戻り値を無視することで、ビューアとしても使用することができます。例えば、単に上の画像を見るためには、次のように実行します。</target>
        </trans-unit>
        <trans-unit id="47a4a763ba31495e47240c644f7558e9498bae30" translate="yes" xml:space="preserve">
          <source>The edit() function can be used to make changes to large text values. For example:</source>
          <target state="translated">edit()関数を使用すると、大きなテキスト値に変更を加えることができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="fd34f0d751c4ddc69b221f64ffd45f8927b66781" translate="yes" xml:space="preserve">
          <source>The editdist3 algorithm is a function that computes the minimum edit distance (a.k.a. the Levenshtein distance) between two input strings. The editdist3 algorithm is a configurable alternative to the default edit distance function of spellfix1. Features of editdist3 include:</source>
          <target state="translated">editdist3 アルゴリズムは、2 つの入力文字列間の最小編集距離 (別名 Levenshtein 距離)を計算する関数です。editdist3 アルゴリズムは、spellfix1 のデフォルトの編集距離関数に代わるものとして設定可能です。editdist3 の特徴は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="870b1bf5bd7c0178ecc9a04d5313cc57bc40b4f1" translate="yes" xml:space="preserve">
          <source>The effects of a &lt;b&gt;truncate file&lt;/b&gt; operation are not assumed to be made persistent until after the corresponding file has been</source>
          <target state="translated">&lt;b&gt;ファイル&lt;/b&gt;の&lt;b&gt;切り捨て&lt;/b&gt;操作の影響は、対応するファイルが削除されるまで持続するとは見なされません。</target>
        </trans-unit>
        <trans-unit id="393d1077fa976da06b2c81028e0e667751bfce07" translate="yes" xml:space="preserve">
          <source>The empty-result-callbacks flag affects the &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; API only. Normally, when the empty-result-callbacks flag is cleared, the callback function supplied to the &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; is not invoked for commands that return zero rows of data. When empty-result-callbacks is set in this situation, the callback function is invoked exactly once, with the third parameter set to 0 (NULL). This is to enable programs that use the &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; API to retrieve column-names even when a query returns no data.</source>
          <target state="translated">empty-result-callbacksフラグは&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）&lt;/a&gt; APIにのみ影響します。通常、empty-result-callbacksフラグがクリアされている場合、&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）に&lt;/a&gt;提供されるコールバック関数は、データの行を返さないコマンドに対しては呼び出されません。この状況でempty-result-callbacksが設定されている場合、コールバック関数は1回だけ呼び出され、3番目のパラメーターは0（NULL）に設定されます。これは、クエリがデータを返さない場合でも、&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）&lt;/a&gt; APIを使用するプログラムが列名を取得できるようにするためです。</target>
        </trans-unit>
        <trans-unit id="f1a25180fc453bfc9b7157e5b028aa8235fc10f5" translate="yes" xml:space="preserve">
          <source>The end-user executes DML or DDL SQL statements that require the structure of the database file of the database file to be modified. These modifications may be any combination of operations to</source>
          <target state="translated">のデータベースファイルの構造を修正することを要求するDMLまたはDDL SQL文をエンドユーザが実行する。これらの修正は、以下の操作の任意の組み合わせとすることができます。</target>
        </trans-unit>
        <trans-unit id="5b923462226ca9a3f1ea2da34aa276431384d659" translate="yes" xml:space="preserve">
          <source>The ending frame boundary can be omitted (if the BETWEEN and AND keywords that surround the starting frame boundary are also omitted), in which case the ending frame boundary defaults to CURRENT ROW.</source>
          <target state="translated">終了フレーム境界は省略することができます(開始フレーム境界を囲むBETWEENキーワードとANDキーワードも省略されている場合)。</target>
        </trans-unit>
        <trans-unit id="b26c1d5670afb707a661dd133bd85c139805e555" translate="yes" xml:space="preserve">
          <source>The ending frame boundary may not take a form that appears higher in the above list than the starting frame boundary.</source>
          <target state="translated">前記終了フレーム境界は、前記開始フレーム境界よりも上位に出現する形態を取らないようにしてもよい。</target>
        </trans-unit>
        <trans-unit id="1133a1a20cf9f9901ca7376082c18ed0b6c4a36d" translate="yes" xml:space="preserve">
          <source>The engine no longer consults the main table if it can get all the information it needs from an index.</source>
          <target state="translated">インデックスから必要な情報をすべて取得できるのであれば、エンジンはもはやメインテーブルを参照しません。</target>
        </trans-unit>
        <trans-unit id="b873e4983f185f34587580faeee301ccc43a5a88" translate="yes" xml:space="preserve">
          <source>The enhanced query syntax supports the AND, OR and NOT binary set operators. Each of the two operands to an operator may be a basic FTS query, or the result of another AND, OR or NOT set operation. Operators must be entered using capital letters. Otherwise, they are interpreted as basic term queries instead of set operators.</source>
          <target state="translated">拡張クエリ構文は、AND、ORおよびNOTバイナリセット演算子をサポートしています。演算子への2つのオペランドのそれぞれは、基本的なFTSクエリ、または別のAND、OR、NOTセット演算の結果となります。演算子は、大文字で入力する必要があります。そうでない場合、それらはセット演算子ではなく、基本的なタームクエリとして解釈されます。</target>
        </trans-unit>
        <trans-unit id="ec0a2d5aa63b2e3b719340bb237dcfc9aebe4443" translate="yes" xml:space="preserve">
          <source>The entries above might represent (for example) a bounding box around the main office for SQLite.org and bounding box around the 12th Congressional District of North Carolina (prior to the 2011 redistricting) in which SQLite.org was located.</source>
          <target state="translated">上記のエントリは、(例えば)SQLite.orgのメインオフィス周辺のバウンディングボックスと、SQLite.orgがあったノースカロライナ州第12議会区(2011年の再編成前)周辺のバウンディングボックスを表しているかもしれません。</target>
        </trans-unit>
        <trans-unit id="df23c9e0d03ef84c1b3ecc39ad637f8b14bf70ea" translate="yes" xml:space="preserve">
          <source>The entry point is zProc. zProc may be 0, in which case SQLite will try to come up with an entry point name on its own. It first tries &quot;sqlite3_extension_init&quot;. If that does not work, it constructs a name &quot;sqlite3_X_init&quot; where the X is consists of the lower-case equivalent of all ASCII alphabetic characters in the filename from the last &quot;/&quot; to the first following &quot;.&quot; and omitting any initial &quot;lib&quot;. The sqlite3_load_extension() interface returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if something goes wrong. If an error occurs and pzErrMsg is not 0, then the &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface shall attempt to fill *pzErrMsg with error message text stored in memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The calling function should free this memory by calling &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">エントリー・ポイントはzProcです。 zProcは0の場合があります。その場合、SQLiteは独自にエントリポイント名を考え出そうとします。最初に「sqlite3_extension_init」を試行します。それが機能しない場合は、「sqlite3_X_init」という名前を作成します。Xは、ファイル名の最後の「/」から最初の「。」までのすべてのASCIIアルファベット文字の小文字に相当する文字で構成されます。最初の「lib」は省略します。 sqlite3_load_extension（）インターフェースは、成功すると&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OKを返し&lt;/a&gt;、何かがうまくいかない場合は&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;を返します。エラーが発生し、pzErrMsgが0でない場合、&lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;インターフェースは、&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;から取得したメモリに格納されたエラーメッセージテキストで* pzErrMsgを埋めようとします。。呼び出し元の関数は、&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）を&lt;/a&gt;呼び出してこのメ​​モリを解放する必要があります。</target>
        </trans-unit>
        <trans-unit id="4f2e7b718e4064a2f8cc8acbe7a051458f014ce0" translate="yes" xml:space="preserve">
          <source>The entry point is zProc. zProc may be 0, in which case SQLite will try to come up with an entry point name on its own. It first tries &quot;sqlite3_extension_init&quot;. If that does not work, it constructs a name &quot;sqlite3_X_init&quot; where the X is consists of the lower-case equivalent of all ASCII alphabetic characters in the filename from the last &quot;/&quot; to the first following &quot;.&quot; and omitting any initial &quot;lib&quot;. The sqlite3_load_extension() interface returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if something goes wrong. If an error occurs and pzErrMsg is not 0, then the &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface shall attempt to fill *pzErrMsg with error message text stored in memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The calling function should free this memory by calling &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">エントリー・ポイントはzProcです。 zProcは0の場合があります。その場合、SQLiteは独自にエントリポイント名を考え出そうとします。最初に「sqlite3_extension_init」を試行します。それが機能しない場合は、「sqlite3_X_init」という名前を作成します。Xは、ファイル名の最後の「/」から最初の「。」までのすべてのASCIIアルファベット文字の小文字に相当する文字で構成されます。最初の「lib」は省略します。 sqlite3_load_extension（）インターフェースは、成功すると&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_OKを返し&lt;/a&gt;、何かがうまくいかない場合は&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_ERROR&lt;/a&gt;を返します。エラーが発生し、pzErrMsgが0でない場合、&lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;インターフェースは、&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;から取得したメモリに格納されたエラーメッセージテキストで* pzErrMsgを埋めようとします。。呼び出し元の関数は、&lt;a href=&quot;free&quot;&gt;sqlite3_free（）を&lt;/a&gt;呼び出してこのメ​​モリを解放する必要があります。</target>
        </trans-unit>
        <trans-unit id="40007c6bf4af7619580a2e5c3ec81a4fee4ad813" translate="yes" xml:space="preserve">
          <source>The error code is changed to &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; (instead of &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;) when an attempt is made to &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; while one or more queries are still pending.</source>
          <target state="translated">1つ以上のクエリがまだ保留されているときに&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;を試行すると、エラーコードは&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;（&lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;ではなく）に変更されます。</target>
        </trans-unit>
        <trans-unit id="2e60aa60ea376ea9ca807c8cc7d0b0b91ec054e5" translate="yes" xml:space="preserve">
          <source>The error codes for SQLite version 3 are unchanged from version 2. They are as follows:</source>
          <target state="translated">SQLite バージョン 3 のエラーコードはバージョン 2 から変更されていません。エラーコードは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="2ccece93e5a00d5f5d9d7a6919183b3a66f82129" translate="yes" xml:space="preserve">
          <source>The error logger callback function might look something like this:</source>
          <target state="translated">エラーロガーのコールバック関数は、次のようなものです。</target>
        </trans-unit>
        <trans-unit id="8ad007677ae545b2ad036dc3fbfd526afb2a9647" translate="yes" xml:space="preserve">
          <source>The error logger callback should be treated like a signal handler. The application should save off or otherwise process the error, then return as soon as possible. No other SQLite APIs should be invoked, directly or indirectly, from the error logger. SQLite is &lt;u&gt;not&lt;/u&gt; reentrant through the error logger callback. In particular, the error logger callback is invoked when a memory allocation fails, so it is generally a bad idea to try to allocate memory inside the error logger. Do not even think about trying to store the error message in another SQLite database.</source>
          <target state="translated">エラーロガーのコールバックはシグナルハンドラのように扱われるべきです。アプリケーションはエラーを保存するか、そうでなければエラーを処理して、できるだけ早く戻る必要があります。エラーロガーから他のSQLite APIを直接または間接的に呼び出すことはできません。 SQLiteは、エラーロガーコールバックを通じて再入可能ではあり&lt;u&gt;ません&lt;/u&gt;。特に、エラーロガーコールバックはメモリ割り当てが失敗したときに呼び出されるため、一般的にエラーロガー内にメモリを割り当てようとすることはお勧めできません。エラーメッセージを別のSQLiteデータベースに格納しようとすることさえ考えないでください。</target>
        </trans-unit>
        <trans-unit id="931b7a49e1d266b8f7af8c59c48646cf4fc9a825" translate="yes" xml:space="preserve">
          <source>The error messages that might be sent to the error logger and their exact format is subject to changes from one release to the next. So applications should not depend on any particular error message text formats or error codes. Things do not change capriciously, but they do sometimes changes.</source>
          <target state="translated">エラーロガーに送信される可能性のあるエラーメッセージとその正確なフォーマットは、あるリリースから次のリリースへと変更される可能性があります。そのため、アプリケーションは特定のエラーメッセージのテキスト形式やエラーコードに依存すべきではありません。物事は気まぐれに変化するものではありませんが、時々変更されることがあります。</target>
        </trans-unit>
        <trans-unit id="6f0f73d0eed4daf2fa7ce504b606f01da04260dc" translate="yes" xml:space="preserve">
          <source>The estimatedCost field should be set to the estimated number of disk access operations required to execute this query against the virtual table. The SQLite core will often call xBestIndex multiple times with different constraints, obtain multiple cost estimates, then choose the query plan that gives the lowest estimate. The SQLite core initializes estimatedCost to a very large value prior to invoking xBestIndex, so if xBestIndex determines that the current combination of parameters is undesirable, it can leave the estimatedCost field unchanged to discourage its use.</source>
          <target state="translated">estimatedCost フィールドには、仮想テーブルに対してこのクエリを実行するのに必要なディスクアクセス操作の推定数を設定する必要があります。SQLite コアは多くの場合、異なる制約条件で xBestIndex を複数回呼び出し、複数のコスト推定値を取得した後、最も低い推定値を与えるクエリプランを選択します。SQLite コアは、xBestIndex を呼び出す前に estimatedCost を非常に大きな値に初期化するので、もし xBestIndex が現在のパラメータの組み合わせが望ましくないと判断した場合には、その使用を避けるために estimatedCost フィールドを変更しないでおくことができます。</target>
        </trans-unit>
        <trans-unit id="9110d26065cfada658af48dd22a731f2e42c4634" translate="yes" xml:space="preserve">
          <source>The estimatedCost value is an estimate of the cost of a particular strategy. A cost of N indicates that the cost of the strategy is similar to a linear scan of an SQLite table with N rows. A cost of log(N) indicates that the expense of the operation is similar to that of a binary search on a unique indexed field of an SQLite table with N rows.</source>
          <target state="translated">estimatedCost値は、特定のストラテジーのコストの推定値です。Nのコストは、その戦略のコストがN行のSQLiteテーブルのリニアスキャンに似ていることを示します。log(N)のコストは、その操作のコストが、N行のSQLiteテーブルの一意のインデックス付きフィールドのバイナリ検索のコストに似ていることを示しています。</target>
        </trans-unit>
        <trans-unit id="a1d11ebb28b1bb46c038273ece9416f81d29642b" translate="yes" xml:space="preserve">
          <source>The estimatedRows value is an estimate of the number of rows that will be returned by the strategy.</source>
          <target state="translated">estimatedRows値は、ストラテジーが返す行数の推定値です。</target>
        </trans-unit>
        <trans-unit id="6e98b869e8e492045895b07f0da4a451a3b65571" translate="yes" xml:space="preserve">
          <source>The exact logic used to determine if a</source>
          <target state="translated">のかどうかを判断するために使用される正確なロジックは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="c7341ca7ddb26c5a501b148a51edcbd920ab7841" translate="yes" xml:space="preserve">
          <source>The exact same source code can be used for both a run-time loadable shared library or DLL and as a module that is statically linked with your application. This provides flexibility and allows you to reuse the same code in different ways.</source>
          <target state="translated">全く同じソースコードを、実行時にロード可能な共有ライブラリや DLL と、アプリケーションと静的にリンクされたモジュールの両方に使用することができます。これは柔軟性を提供し、同じコードを異なる方法で再利用することを可能にします。</target>
        </trans-unit>
        <trans-unit id="51d3ce62c3eb93876d401465d70f8ba808604db2" translate="yes" xml:space="preserve">
          <source>The example above causes the database file named &quot;ex1.db&quot; to be opened and used. The &quot;ex1.db&quot; file is created if it does not previously exist. You might want to use a full pathname to ensure that the file is in the directory that you think it is in. Use forward-slashes as the directory separator character. In other words use &quot;c:/work/ex1.db&quot;, not &quot;c:\work\ex1.db&quot;.</source>
          <target state="translated">上の例では、&quot;ex1.db &quot;という名前のデータベースファイルを開いて使用しています。ex1.db」ファイルは、以前に存在しなかった場合に作成されます。ファイルがあると思われるディレクトリにあることを確認するために、フルパス名を使用するとよいでしょう。ディレクトリの区切り文字としてフォワードスラッシュを使用します。言い換えれば、&quot;c:/work/ex1.db &quot;ではなく、&quot;c:\workex1.db &quot;を使用してください。</target>
        </trans-unit>
        <trans-unit id="97b14b6298ce84315e618c11d7722d98fb92421a" translate="yes" xml:space="preserve">
          <source>The example above contains two &quot;SCALAR&quot; subqueries. The subqueries are SCALAR in the sense that they return a single value - a one-row, one-column table. If the actual query returns more than that, then only the first column of the first row is used.</source>
          <target state="translated">上の例では、2つの &quot;SCALAR &quot;副問い合わせが含まれています。これらのサブクエリは、1つの値、つまり1行1列のテーブルを返すという意味でSCALARです。実際のクエリがそれ以上の値を返す場合は、最初の行の最初の列のみが使用されます。</target>
        </trans-unit>
        <trans-unit id="d7a7c3999051bd06566a95bdd9bc9de8e3e4adaa" translate="yes" xml:space="preserve">
          <source>The example above illustrates the signature of the error logger callback. However, in an embedded application, one usually does not print messages on stderr. Instead, one might store the messages in a preallocated circular buffer where they can be accessed when diagnostic information is needed during debugging. Or perhaps the messages can be sent to &lt;a href=&quot;http://en.wikipedia.org/wiki/Syslog&quot;&gt;Syslog&lt;/a&gt;. Somehow, the messages need to be stored where they are accessible to developers, not displayed to end users.</source>
          <target state="translated">上記の例は、エラーロガーコールバックの署名を示しています。ただし、組み込みアプリケーションでは、通常はstderrにメッセージを出力しません。代わりに、事前に割り当てられた循環バッファにメッセージを保存し、デバッグ中に診断情報が必要になったときにメッセージにアクセスできるようにします。または、メッセージを&lt;a href=&quot;http://en.wikipedia.org/wiki/Syslog&quot;&gt;Syslog&lt;/a&gt;に送信することもできます。どういうわけか、メッセージは、エンドユーザーに表示するのではなく、開発者がアクセスできる場所に保存する必要があります。</target>
        </trans-unit>
        <trans-unit id="d307547a7cd9c2e8e0dc86cacf98f3de8afb55c2" translate="yes" xml:space="preserve">
          <source>The example above showed a single &lt;b&gt;filename='thefile.csv'&lt;/b&gt; argument for the CSV virtual table. But other arguments are also possible.</source>
          <target state="translated">上記の例は、CSV仮想テーブルの単一の&lt;b&gt;filename = 'thefile.csv'&lt;/b&gt;引数を示しています。しかし、他の議論も可能です。</target>
        </trans-unit>
        <trans-unit id="11a05b76af4570008579a529531a96eb802e047d" translate="yes" xml:space="preserve">
          <source>The example above shows SQLite picking full-table scan will visit all rows in the table. If the query were able to use an index, then the SCAN/SEARCH record would include the name of the index and, for a SEARCH record, an indication of how the subset of rows visited is identified. For example:</source>
          <target state="translated">上記の例では、SQLiteがフルテーブルスキャンをピックして、テーブル内のすべての行を訪問することを示しています。クエリがインデックスを使用できる場合、SCAN/SEARCHレコードにはインデックスの名前と、SEARCHレコードの場合は、訪問した行のサブセットがどのように識別されるかの表示が含まれます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="abd381887f2ea42f76bfd9ebc8b17425d16e2957" translate="yes" xml:space="preserve">
          <source>The example below uses ntile() to divide the six rows into two groups (the ntile(2) call) and into four groups (the ntile(4) call). For ntile(2), there are three rows assigned to each group. For ntile(4), there are two groups of two and two groups of one. The larger groups of two appear first.</source>
          <target state="translated">以下の例では、ntile()を使用して6行を2つのグループ(ntile(2)呼び出し)と4つのグループ(ntile(4)呼び出し)に分割しています。ntile(2)では、各グループに3つの行が割り当てられています。ntile(4)では、2つのグループが2つ、1つのグループが2つあります。大きい方の2つのグループが最初に現れます。</target>
        </trans-unit>
        <trans-unit id="c8ad72613a1253e10b2aeefbfa091cedb3448e07" translate="yes" xml:space="preserve">
          <source>The example code below demonstrates the steps involved in capturing a changeset while executing SQL commands. In summary:</source>
          <target state="translated">以下のコード例は、SQL コマンドの実行中にチェンジセットをキャプチャする手順を示しています。要約すると</target>
        </trans-unit>
        <trans-unit id="cfda7c494f05312b3bf7826ec92aff6df2e44b46" translate="yes" xml:space="preserve">
          <source>The example code below demonstrates the techniques used to iterate through and extract the data related to all changes in a changeset. To summarize:</source>
          <target state="translated">以下のコード例は、チェンジセット内のすべての変更に関連するデータを反復処理して抽出するために使用されるテクニックを示しています。要約すると</target>
        </trans-unit>
        <trans-unit id="5dde8802fcba008ca09e765d610fcb4f5bf326ca" translate="yes" xml:space="preserve">
          <source>The example code below uses the second of the methods enumerated above - it monitors for changes on all database tables.</source>
          <target state="translated">以下のコード例では、上で列挙したメソッドの 2 番目のメソッドを使用しています-すべてのデータベーステーブルの変更を監視します。</target>
        </trans-unit>
        <trans-unit id="3f036ecd22d9629ed467ac2dbb67b517f12166ad" translate="yes" xml:space="preserve">
          <source>The examples above all use basic full-text term queries as both operands of the set operations demonstrated. Phrase and NEAR queries may also be used, as may the results of other set operations. When more than one set operation is present in an FTS query, the precedence of operators is as follows:</source>
          <target state="translated">上記の例では、基本的なフルテキスト語クエリをセット操作のオペランドとして使用しています。フレーズ検索やNEAR検索も、他のセット操作の結果と同様に使用することができます。FTS クエリで複数のセット操作が存在する場合、演算子の優先順位は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="1921013ee1678e9933f635ab4c9457e39025bfc3" translate="yes" xml:space="preserve">
          <source>The examples below identify the collating sequences that would be used to determine the results of text comparisons that may be performed by various SQL statements. Note that a text comparison may not be required, and no collating sequence used, in the case of numeric, blob or NULL values.</source>
          <target state="translated">以下の例では、さまざまな SQL 文で実行されるテキスト比較の結果を決定するために使用される照合順序を示します。数値、ブロブ、またはNULL値の場合、テキスト比較は必須ではなく、照合シーケンスは使用されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="367a92feb39a9287f4306f6946c319f7064a8b02" translate="yes" xml:space="preserve">
          <source>The examples in this section all assume that the database is populated as follows:</source>
          <target state="translated">このセクションの例はすべて、以下のようにデータベースが格納されていることを前提としています。</target>
        </trans-unit>
        <trans-unit id="c2bd8a896b6e33422d64448169403c1bc373cf0d" translate="yes" xml:space="preserve">
          <source>The examples in this section all assume the following data:</source>
          <target state="translated">このセクションの例では、すべて以下のデータを想定しています。</target>
        </trans-unit>
        <trans-unit id="4d8c3a17bac2c4be1cb9b2d64248454f5513cff9" translate="yes" xml:space="preserve">
          <source>The exception mentioned above is that if the declaration of a column with declared type &quot;INTEGER&quot; includes an &quot;PRIMARY KEY DESC&quot; clause, it does not become an alias for the rowid and is not classified as an integer primary key. This quirk is not by design. It is due to a bug in early versions of SQLite. But fixing the bug could result in backwards incompatibilities. Hence, the original behavior has been retained (and documented) because odd behavior in a corner case is far better than a compatibility break. This means that the following three table declarations all cause the column &quot;x&quot; to be an alias for the rowid (an integer primary key):</source>
          <target state="translated">上述の例外は、宣言された型が「INTEGER」のカラムの宣言に「PRIMARY KEY DESC」句が含まれている場合、そのカラムはROWIDのエイリアスにならず、整数の主キーとして分類されないということです。この奇妙な現象は設計上のものではありません。これはSQLiteの初期バージョンのバグによるものです。しかし、このバグを修正すると後方互換性がなくなる可能性があります。そこで、コーナーケースでの奇妙な動作は互換性を失うよりもはるかに優れているため、元の動作が保持されています (そして文書化されています)。つまり、以下の 3 つのテーブル宣言では、列 &quot;x&quot; が rowid (整数の主キー)のエイリアスになっているということです。</target>
        </trans-unit>
        <trans-unit id="f41b51d024f674a1f6149c31aede1e868d7d56cf" translate="yes" xml:space="preserve">
          <source>The existence of a transaction depends on whether or not the rollback journal file exists and the deletion of a file appears to be an atomic operation from the point of view of a user-space process. Therefore, a transaction appears to be an atomic operation.</source>
          <target state="translated">トランザクションの存在は、ロールバック・ジャーナル・ファイルが存在するかどうかに依存し、ファイルの削除は、ユーザ空間プロセスから見ればアトミックな操作に見える。したがって、トランザクションはアトミックな操作であるように見えます。</target>
        </trans-unit>
        <trans-unit id="6021cb5e88d7481ca7795a9ddd0c04e6033fc0e0" translate="yes" xml:space="preserve">
          <source>The existing INSERT is removed from the changegroup. The DELETE is not added.</source>
          <target state="translated">既存のINSERTはchangegroupから削除されます。DELETEは追加されません。</target>
        </trans-unit>
        <trans-unit id="4a2b5a6b7a6bdb1833a8cf1e839e065d174385dc" translate="yes" xml:space="preserve">
          <source>The existing UPDATE is replaced by the new DELETE within the changegroup.</source>
          <target state="translated">既存のUPDATEは、changegroup内の新しいDELETEに置き換えられます。</target>
        </trans-unit>
        <trans-unit id="5c1e2e9de2a17cfdc315c14e1e74a36e45b9c92f" translate="yes" xml:space="preserve">
          <source>The existing UPDATE remains within the changegroup. It is amended so that the accompanying values are as if the row was updated once by the existing change and then again by the new change.</source>
          <target state="translated">既存のUPDATEはchangegroup内に残ります。これは、行が既存の変更によって一度更新され、その後、新しい変更によって再び更新されたかのように、付随する値が修正されています。</target>
        </trans-unit>
        <trans-unit id="fca9185c8e0eb9e3e49b7068e021cf8a710c066e" translate="yes" xml:space="preserve">
          <source>The explicit COMMIT command runs immediately, even if there are pending &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements. However, if there are pending write operations, the COMMIT command will fail with an error code &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;.</source>
          <target state="translated">保留中の&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントがある場合でも、明示的なCOMMITコマンドはすぐに実行されます。ただし、保留中の書き込み操作がある場合、COMMITコマンドはエラーコード&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSYで&lt;/a&gt;失敗します。</target>
        </trans-unit>
        <trans-unit id="e2d16a733bb795b8f24e0161c9bf1e3201567a34" translate="yes" xml:space="preserve">
          <source>The expression &quot;+column&quot; is now considered the same as &quot;column&quot; when computing the collating sequence to use on the expression.</source>
          <target state="translated">式 &quot;+column &quot;は、式に使用する照合順序を計算する際に &quot;column &quot;と同じとみなされるようになりました。</target>
        </trans-unit>
        <trans-unit id="fee373e0e83d3368c40362493777ab8e984bd97b" translate="yes" xml:space="preserve">
          <source>The expression &quot;a BETWEEN b AND c&quot; is treated as two separate binary comparisons &quot;a &amp;gt;= b AND a &amp;lt;= c&quot;, even if that means different affinities are applied to 'a' in each of the comparisons. Datatype conversions in comparisons of the form &quot;x IN (SELECT y ...)&quot; are handled is if the comparison were really &quot;x=y&quot;. The expression &quot;a IN (x, y, z, ...)&quot; is equivalent to &quot;a = +x OR a = +y OR a = +z OR ...&quot;. In other words, the values to the right of the IN operator (the &quot;x&quot;, &quot;y&quot;, and &quot;z&quot; values in this example) are considered to have no affinity, even if they happen to be column values or CAST expressions.</source>
          <target state="translated">「a BETWEEN b AND c」という表現は、2つの異なるバイナリ比較「a&amp;gt; = b AND a &amp;lt;= c」として扱われます。これは、各比較で「a」に異なるアフィニティが適用されることを意味します。 &quot;x IN（SELECT y ...）&quot;形式の比較でのデータ型変換は、比較が実際に &quot;x = y&quot;であった場合に行われます。 「a IN（x、y、z、...）」という表現は、「a = + x OR a = + y OR a = + z OR ...」と同等です。つまり、IN演算子の右側の値（この例では「x」、「y」、および「z」の値）は、たとえ列の値またはCAST式であっても、類似性がないと見なされます。 。</target>
        </trans-unit>
        <trans-unit id="15a424b3e7e4f20cd419dc00af0824f2446f3f50" translate="yes" xml:space="preserve">
          <source>The expression &quot;x BETWEEN y and z&quot; is logically equivalent to two comparisons &quot;x &amp;gt;= y AND x &amp;lt;= z&quot; and works with respect to collating functions as if it were two separate comparisons. The expression &quot;x IN (SELECT y ...)&quot; is handled in the same way as the expression &quot;x = y&quot; for the purposes of determining the collating sequence. The collating sequence used for expressions of the form &quot;x IN (y, z, ...)&quot; is the collating sequence of x.</source>
          <target state="translated">式 &quot;x BETWEEN y and z&quot;は、2つの比較 &quot;x&amp;gt; = y AND x &amp;lt;= z&quot;と論理的に同等であり、2つの別個の比較であるかのように照合関数に関して機能します。式「x IN（SELECT y ...）」は、照合シーケンスを決定するために、式「x = y」と同じ方法で処理されます。「x IN（y、z、...）」の形式の式に使用される照合シーケンスは、xの照合シーケンスです。</target>
        </trans-unit>
        <trans-unit id="70c0ccea32ba2d8b128981db932845adc7b90c4c" translate="yes" xml:space="preserve">
          <source>The expression &quot;x BETWEEN y and z&quot; is logically equivalent to two comparisons &quot;x &amp;gt;= y AND x &amp;lt;= z&quot; and works with respect to collating functions as if it were two separate comparisons. The expression &quot;x IN (SELECT y ...)&quot; is handled in the same way as the expression &quot;x = y&quot; for the purposes of determining the collating sequence. The collating sequence used for expressions of the form &quot;x IN (y, z, ...)&quot; is the collating sequence of x. If an explicit collating sequence is required on an IN operator it should be applied to the left operand, like this: &quot;x COLLATE nocase IN (y,z, ...)&quot;.</source>
          <target state="translated">式「xBETWEENy and z」は、2つの比較「x&amp;gt; = y AND x &amp;lt;= z」と論理的に同等であり、照合関数に関して、2つの別々の比較であるかのように機能します。式「xIN（SELECT y ...）」は、照合シーケンスを決定するために、式「x = y」と同じ方法で処理されます。 「xIN（y、z、...）」の形式の式に使用される照合シーケンスは、xの照合シーケンスです。 IN演算子で明示的な照合シーケンスが必要な場合は、「x COLLATE nocase IN（y、z、...）」のように、左側のオペランドに適用する必要があります。</target>
        </trans-unit>
        <trans-unit id="0c6d1934b411c6401d1051c4d7453826ea7a9843" translate="yes" xml:space="preserve">
          <source>The expression attached to the optional OFFSET clause that may follow a LIMIT clause must also evaluate to an integer, or a value that can be losslessly converted to an integer. If an expression has an OFFSET clause, then the first M rows are omitted from the result set returned by the SELECT statement and the next N rows are returned, where M and N are the values that the OFFSET and LIMIT clauses evaluate to, respectively. Or, if the SELECT would return less than M+N rows if it did not have a LIMIT clause, then the first M rows are skipped and the remaining rows (if any) are returned. If the OFFSET clause evaluates to a negative value, the results are the same as if it had evaluated to zero.</source>
          <target state="translated">LIMIT句に続くオプションのOFFSET句に接続された式は、整数、または可逆的に整数に変換できる値を評価しなければなりません。式にOFFSET句がある場合、最初のM行はSELECT文によって返される結果セットから省略され、次のN行が返されます。または、SELECT文がLIMIT句を持たない場合、返される行数がM+N行よりも少ない場合、最初のM行はスキップされ、残りの行(あれば)が返されます。OFFSET句が負の値として評価された場合、結果はゼロとして評価された場合と同じです。</target>
        </trans-unit>
        <trans-unit id="1cd8c2a06181abbb52fb772c5e4393bf493adec9" translate="yes" xml:space="preserve">
          <source>The expression following the WHERE clause may contain operators, literal values, and names of columns in the table being indexed. The WHERE clause may &lt;em&gt;not&lt;/em&gt; contain subqueries, references to other tables, &lt;a href=&quot;deterministic&quot;&gt;non-deterministic functions&lt;/a&gt;, or &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;.</source>
          <target state="translated">WHERE句に続く式には、演算子、リテラル値、およびインデックス付けされるテーブルの列の名前を含めることができます。WHERE句には、サブクエリ、他のテーブルへの参照、&lt;a href=&quot;deterministic&quot;&gt;非決定的関数&lt;/a&gt;、または&lt;a href=&quot;lang_expr#varparam&quot;&gt;バインドされたパラメータを&lt;/a&gt;含めることはでき&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="fa57007d3af78002775463ea997fdbb172a0c191" translate="yes" xml:space="preserve">
          <source>The extension loading mechanism of SQLite (accessed using the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL function) is turned off by default. This is a security precaution. If an application wants to make use of the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; function it must first turn the capability on using this method.</source>
          <target state="translated">SQLiteの拡張機能読み込みメカニズム&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;（&lt;/a&gt; SQL関数load_extension（）を使用してアクセス）は、デフォルトでオフになっています。これはセキュリティ上の予防措置です。アプリケーションが&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension（）&lt;/a&gt;関数を使用する場合は、まずこのメソッドを使用して機能をオンにする必要があります。</target>
        </trans-unit>
        <trans-unit id="bbd9a40496de97ba5cfcabba824166980ee9d8c1" translate="yes" xml:space="preserve">
          <source>The extra write overhead prompted a reexamination of assumptions about powersafe overwrite. With modern disk drives, the capacity has become so large and the data density so great that a single sector is very small and writing a single sector takes very little time. We know that disk drives can detect an impending power loss and continue to operate for some small amount of time on residual energy because those drives are able to park their heads before spinning down. And so if an impending power loss is detectable by the disk controller, it seems reasonable that the controller will finish writing whatever sector it is current working on when the imminent power loss is first detected, prior to parking the heads, as long as doing so does not take too long, which it should not with small and dense sectors. Hence it seems reasonable to assume powersafe overwrite for modern disks. Indeed, BerkeleyDB has made this assumption for decades, we are told. Caution is advised though. As Roger Binns noted on the SQLite developers mailing list: &quot;'poorly written' should be the main assumption about drive firmware.&quot;</source>
          <target state="translated">余分な書き込みオーバーヘッドは、パワーセーフの上書きに関する前提条件の再検討を促しました。最新のディスクドライブでは、容量が非常に大きくなり、データ密度が非常に高くなっているため、1 セクタは非常に小さく、1 セクタの書き込みにはほとんど時間がかかりません。私たちは、ディスクドライブが差し迫った停電を検知して、わずかな時間でも残余エネルギーで動作し続けることができることを知っています。したがって、差し迫った電力損失がディスクコントローラによって検出された場合、コントローラは、差し迫った電力損失が最初に検出されたときに、ヘッドを駐車する前に、現在作業しているセクタの書き込みを終了するのが合理的であると思われる。したがって、最新のディスクではパワーセーフな上書きが可能であると仮定するのが妥当なようです。実際、BerkeleyDBは何十年にもわたってこの仮定をしてきたと聞いている。しかし、注意が必要である。Roger BinnsがSQLite開発者メーリングリストで指摘しているように ドライブのファームウェアについては、「&quot;書き込まれていない &quot;というのが主な前提であるべきだ」と。</target>
        </trans-unit>
        <trans-unit id="f31765748ec404a72a387c3ce457db0e7fddb3f0" translate="yes" xml:space="preserve">
          <source>The fact that NULLs are distinct for UNIQUE columns but are indistinct for SELECT DISTINCT and UNION continues to be puzzling. It seems that NULLs should be either distinct everywhere or nowhere. And the SQL standards documents suggest that NULLs should be distinct everywhere. Yet as of this writing, no SQL engine tested treats NULLs as distinct in a SELECT DISTINCT statement or in a UNION.</source>
          <target state="translated">NULLはUNIQUE列では区別されますが、SELECT DISTINCTやUNIONでは区別されないという事実には、引き続き不可解さを感じます。NULLはどこでもはっきりしていなければならないようですが、どこでもはっきりしていなければなりません。そして、SQL標準ドキュメントでは、NULLはどこでも明瞭であるべきであることを示唆しています。しかし、この記事を書いている時点では、テストしたSQLエンジンではSELECT DISTINCT文やUNIONでNULLを区別して扱うものはありません。</target>
        </trans-unit>
        <trans-unit id="36716fd190ed79338836da067e34479b294afa61" translate="yes" xml:space="preserve">
          <source>The fact that SQLite is embedded and &lt;a href=&quot;serverless&quot;&gt;serverless&lt;/a&gt; instead of being client/server is a feature, not a bug.</source>
          <target state="translated">SQLiteが埋め込まれ、クライアント/サーバーではなく&lt;a href=&quot;serverless&quot;&gt;サーバーレスである&lt;/a&gt;という事実は機能であり、バグではありません。</target>
        </trans-unit>
        <trans-unit id="893ade2ecf018b089d7d0c2f18f2d37a93397ea0" translate="yes" xml:space="preserve">
          <source>The fifth argument to the BLOB and string binding interfaces is a destructor used to dispose of the BLOB or string after SQLite has finished with it. The destructor is called to dispose of the BLOB or string even if the call to the bind API fails, except the destructor is not called if the third parameter is a NULL pointer or the fourth parameter is negative. If the fifth argument is the special value &lt;a href=&quot;#SQLITE_STATIC&quot;&gt;SQLITE_STATIC&lt;/a&gt;, then SQLite assumes that the information is in static, unmanaged space and does not need to be freed. If the fifth argument has the value &lt;a href=&quot;#SQLITE_STATIC&quot;&gt;SQLITE_TRANSIENT&lt;/a&gt;, then SQLite makes its own private copy of the data immediately, before the sqlite3_bind_*() routine returns.</source>
          <target state="translated">BLOBと文字列バインディングインターフェイスへの5番目の引数は、SQLiteがBLOBまたは文字列を使い終わった後に、BLOBまたは文字列を破棄するために使用されるデストラクタです。バインドAPIの呼び出しが失敗した場合でも、BLOBまたは文字列を破棄するためにデストラクターが呼び出されます。ただし、3番目のパラメーターがNULLポインターである場合、または4番目のパラメーターが負の場合は、デストラクターは呼び出されません。 5番目の引数が特別な値&lt;a href=&quot;#SQLITE_STATIC&quot;&gt;SQLITE_STATIC&lt;/a&gt;である場合、SQLiteは情報が静的な非管理スペースにあり、解放する必要がないと想定します。 5番目の引数の値が&lt;a href=&quot;#SQLITE_STATIC&quot;&gt;SQLITE_TRANSIENTの&lt;/a&gt;場合、SQLiteはsqlite3_bind _ *（）ルーチンが戻る前に、データの独自のプライベートコピーをすぐに作成します。</target>
        </trans-unit>
        <trans-unit id="e68c8434fb7585b2fc0da0f853455aed19727f06" translate="yes" xml:space="preserve">
          <source>The fifth argument to the BLOB and string binding interfaces is a destructor used to dispose of the BLOB or string after SQLite has finished with it. The destructor is called to dispose of the BLOB or string even if the call to the bind API fails, except the destructor is not called if the third parameter is a NULL pointer or the fourth parameter is negative. If the fifth argument is the special value &lt;a href=&quot;c_static&quot;&gt;SQLITE_STATIC&lt;/a&gt;, then SQLite assumes that the information is in static, unmanaged space and does not need to be freed. If the fifth argument has the value &lt;a href=&quot;c_static&quot;&gt;SQLITE_TRANSIENT&lt;/a&gt;, then SQLite makes its own private copy of the data immediately, before the sqlite3_bind_*() routine returns.</source>
          <target state="translated">BLOBと文字列バインディングインターフェイスへの5番目の引数は、SQLiteがBLOBまたは文字列を使い終わった後に、BLOBまたは文字列を破棄するために使用されるデストラクタです。バインドAPIの呼び出しが失敗した場合でも、BLOBまたは文字列を破棄するためにデストラクターが呼び出されます。ただし、3番目のパラメーターがNULLポインターである場合、または4番目のパラメーターが負の場合は、デストラクターは呼び出されません。 5番目の引数が特別な値&lt;a href=&quot;c_static&quot;&gt;SQLITE_STATIC&lt;/a&gt;である場合、SQLiteは情報が静的な非管理スペースにあり、解放する必要がないと想定します。 5番目の引数の値が&lt;a href=&quot;c_static&quot;&gt;SQLITE_TRANSIENTの&lt;/a&gt;場合、SQLiteはsqlite3_bind _ *（）ルーチンが戻る前に、データの独自のプライベートコピーをすぐに作成します。</target>
        </trans-unit>
        <trans-unit id="901b5e438fd14b98c5489ac30117b7e4f79582ec" translate="yes" xml:space="preserve">
          <source>The fifth argument, xCallback, is a pointer to the collating function. Multiple collating functions can be registered using the same name but with different eTextRep parameters and SQLite will use whichever function requires the least amount of data transformation. If the xCallback argument is NULL then the collating function is deleted. When all collating functions having the same name are deleted, that collation is no longer usable.</source>
          <target state="translated">5 番目の引数 xCallback は照合関数へのポインタです。複数の照合関数を同じ名前を使用して登録することができますが、eTextRep のパラメータが異なるため、SQLite はデータ変換の量が最も少ない関数を使用します。xCallback 引数が NULL の場合、照合関数は削除されます。同じ名前の照合関数がすべて削除されると、その照合はもう使えなくなります。</target>
        </trans-unit>
        <trans-unit id="9b66d05a972406caa6b8e66ca673681eea81f8a6" translate="yes" xml:space="preserve">
          <source>The fifth argument, xCompare, is a pointer to the collating function. Multiple collating functions can be registered using the same name but with different eTextRep parameters and SQLite will use whichever function requires the least amount of data transformation. If the xCompare argument is NULL then the collating function is deleted. When all collating functions having the same name are deleted, that collation is no longer usable.</source>
          <target state="translated">5 番目の引数 xCompare は照合関数へのポインタです。複数の照合関数を同じ名前で登録することができますが、eTextRep のパラメータが異なるため、SQLite はデータ変換が最も少なくて済む関数を使用します。xCompare 引数が NULL の場合、照合関数は削除されます。同じ名前を持つ照合関数がすべて削除されると、その照合は使用できなくなります。</target>
        </trans-unit>
        <trans-unit id="3a3d71778e0851af7f19eb98c05ebd04280b893c" translate="yes" xml:space="preserve">
          <source>The fifth parameter is an arbitrary pointer. The implementation of the function can gain access to this pointer using &lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;.</source>
          <target state="translated">5番目のパラメーターは任意のポインターです。関数の実装は、&lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data（）&lt;/a&gt;を使用してこのポインターにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="8991c375d182bf0ed874e01ceb3c3fba4c90a4d1" translate="yes" xml:space="preserve">
          <source>The fifth parameter is an arbitrary pointer. The implementation of the function can gain access to this pointer using &lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;.</source>
          <target state="translated">5番目のパラメーターは任意のポインターです。関数の実装は、&lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data（）&lt;/a&gt;を使用してこのポインターにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="8b5fa94425e25711d656d2caafbaef27474f2b42" translate="yes" xml:space="preserve">
          <source>The file I/O implementation can use the object type flags to change the way it deals with files. For example, an application that does not care about crash recovery or rollback might make the open of a journal file a no-op. Writes to this journal would also be no-ops, and any attempt to read the journal would return SQLITE_IOERR. Or the implementation might recognize that a database file will be doing page-aligned sector reads and writes in a random order and set up its I/O subsystem accordingly.</source>
          <target state="translated">ファイルI/Oの実装では、オブジェクトタイプフラグを使用してファイルの扱い方を変更することができます。例えば、クラッシュのリカバリやロールバックを気にしないアプリケーションでは、ジャーナルファイルをオープンすることはできません。このジャーナルへの書き込みも無効となり、ジャーナルを読もうとすると SQLITE_IOERR を返すことになります。あるいは、データベースファイルがページアラインメントされたセクタの読み書きをランダムな順序で行うことを認識し、それに応じてI/Oサブシステムをセットアップする実装も考えられます。</target>
        </trans-unit>
        <trans-unit id="2ace627b4eb1891a06a62ee2e61523c0922ec242" translate="yes" xml:space="preserve">
          <source>The file I/O implementation can use the object type flags to changes the way it deals with files. For example, an application that does not care about crash recovery or rollback, might make the open of a journal file a no-op. Writes to this journal are also a no-op. Any attempt to read the journal returns &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;. Or the implementation might recognize the a database file will be doing page-aligned sector reads and writes in a random order and set up its I/O subsystem accordingly. SQLite might also add one of the following flags to the xOpen method:</source>
          <target state="translated">ファイルI / O実装は、オブジェクトタイプフラグを使用して、ファイルの処理方法を変更できます。たとえば、クラッシュからの回復やロールバックを気にしないアプリケーションでは、ジャーナルファイルを開くことができない場合があります。このジャーナルへの書き込みもノーオペレーションです。ジャーナルを読み取ろうとすると、&lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;が返されます。または、実装は、データベースファイルがランダムな順序でページに揃えられたセクターの読み取りと書き込みを行い、それに応じてI / Oサブシステムをセットアップすることを認識する場合があります。SQLiteは、xOpenメソッドに次のフラグのいずれかを追加する場合もあります。</target>
        </trans-unit>
        <trans-unit id="339116ded6000b1bbd01c16fbc4b426fdbec3ebf" translate="yes" xml:space="preserve">
          <source>The file change counter is a 4-byte big-endian integer at offset 24 that is incremented whenever the database file is unlocked after having been modified. When two or more processes are reading the same database file, each process can detect database changes from other processes by monitoring the change counter. A process will normally want to flush its database page cache when another process modified the database, since the cache has become stale. The file change counter facilitates this.</source>
          <target state="translated">ファイル変更カウンタはオフセット24にある4バイトのビッグエンディアン整数で、データベースファイルが変更された後にロックが解除されるたびにインクリメントされます。2つ以上のプロセスが同じデータベースファイルを読み込んでいる場合、各プロセスは変更カウンタを監視することで他のプロセスからのデータベースの変更を検出することができます。プロセスは通常、別のプロセスがデータベースを変更した場合、キャッシュが古くなっているため、データベースページのキャッシュをフラッシュしたいと思うでしょう。ファイル変更カウンタはこれを容易にします。</target>
        </trans-unit>
        <trans-unit id="3144a807afc9a81e0cce3e084ad085692d9830bb" translate="yes" xml:space="preserve">
          <source>The file format can be extended in future releases simply by adding new tables and/or column, preserving backwards compatibility.</source>
          <target state="translated">ファイル形式は、新しいテーブルや列を追加するだけで、将来のリリースで拡張でき、下位互換性を保つことができます。</target>
        </trans-unit>
        <trans-unit id="e6aaed4a8d57b71607b8967869bcc7f23189ec3d" translate="yes" xml:space="preserve">
          <source>The file format for indices was changed slightly in order to work around an inefficiency that can sometimes come up with GDBM when there are large indices having many entries with the same key. ** Incompatible Change **</source>
          <target state="translated">インデックスのファイル形式が少し変更されたのは、同じキーを持つ多数のエントリを持つ大きなインデックスがある場合に、GDBMで時々発生する非効率性を回避するためです。**互換性のない変更</target>
        </trans-unit>
        <trans-unit id="227aafe2527e84f2018568e74a1b6b84889b7a1b" translate="yes" xml:space="preserve">
          <source>The file format write version and file format read version at offsets 18 and 19 are intended to allow for enhancements of the file format in future versions of SQLite. In current versions of SQLite, both of these values are 1 for rollback journalling modes and 2 for &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; journalling mode. If a version of SQLite coded to the current file format specification encounters a database file where the read version is 1 or 2 but the write version is greater than 2, then the database file must be treated as read-only. If a database file with a read version greater than 2 is encountered, then that database cannot be read or written.</source>
          <target state="translated">オフセット18および19でのファイル形式書き込みバージョンとファイル形式読み取りバージョンは、SQLiteの将来のバージョンでファイル形式を拡張できるようにすることを目的としています。 SQLiteの現在のバージョンでは、これらの値はどちらも、ロールバックジャーナリングモードの場合は1、&lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;ジャーナリングモードの場合は2 です。現在のファイル形式仕様にコーディングされたSQLiteのバージョンが、読み取りバージョンが1または2であるが書き込みバージョンが2より大きいデータベースファイルを検出した場合、データベースファイルは読み取り専用として扱う必要があります。読み取りバージョンが2より大きいデータベースファイルが検出された場合、そのデータベースの読み取りまたは書き込みはできません。</target>
        </trans-unit>
        <trans-unit id="57007ced430f8a0cf3127ebbd04af2dceb5d897b" translate="yes" xml:space="preserve">
          <source>The file-handle open on the</source>
          <target state="translated">で開いているファイルハンドルは</target>
        </trans-unit>
        <trans-unit id="b75893e55d63ac0a30441dba63c6c7335b33555b" translate="yes" xml:space="preserve">
          <source>The file-system</source>
          <target state="translated">ファイルシステム</target>
        </trans-unit>
        <trans-unit id="e3cc87e79b2a7545d431775230c50e5146077116" translate="yes" xml:space="preserve">
          <source>The filename can be interpreted as a URI if this flag is set.</source>
          <target state="translated">このフラグが設定されている場合、ファイル名はURIとして解釈されます。</target>
        </trans-unit>
        <trans-unit id="c1f230eea69094b4593dd99813cb077b78f99716" translate="yes" xml:space="preserve">
          <source>The filename for the database to be attached is the value of the expression that occurs before the AS keyword. The filename of the database follows the same semantics as the filename argument to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;; the special name &quot;&lt;a href=&quot;inmemorydb&quot;&gt;:memory:&lt;/a&gt;&quot; results in an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; and an empty string results in a new temporary database. The filename argument can be a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; if URI filename processing is enable on the database connection. The default behavior is for URI filenames to be disabled, however that might change in a future release of SQLite, so application developers are advised to plan accordingly.</source>
          <target state="translated">アタッチするデータベースのファイル名は、ASキーワードの前にある式の値です。データベースのファイル名は、&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;および&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;のファイル名引数と同じセマンティクスに従います。特別な名前 &quot; &lt;a href=&quot;inmemorydb&quot;&gt;：memory：&lt;/a&gt; &quot; &lt;a href=&quot;inmemorydb&quot;&gt;はインメモリデータベースを作成&lt;/a&gt;し、空の文字列は新しい一時データベースを作成します。データベース接続でURIファイル名処理が有効になっている場合、filename引数には&lt;a href=&quot;uri&quot;&gt;URIファイル&lt;/a&gt;名を指定できます。デフォルトの動作ではURIファイル名が無効になりますが、SQLiteの将来のリリースで変更される可能性があるため、アプリケーション開発者はそれに応じて計画することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f17e1c0d84ff3c2fe25d0856ea88c3fbd19c5fb1" translate="yes" xml:space="preserve">
          <source>The filename in the INTO clause can be an arbitrary SQL expression that evaluates to a string. The file named by the INTO clause must not previously exist, or else it must be an empty file, or the VACUUM INTO command will fail with an error.</source>
          <target state="translated">INTO句のファイル名には、文字列として評価される任意のSQL式を指定することができます。INTO句で指定されたファイルは、以前に存在していないか、空のファイルでなければなりません。</target>
        </trans-unit>
        <trans-unit id="d4df05c7fc29b7702e9fa3ab7eeeb629cbcad3f5" translate="yes" xml:space="preserve">
          <source>The filename returned by this function is the output of the xFullPathname method of the &lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt;. In other words, the filename will be an absolute pathname, even if the filename used to open the database originally was a URI or relative pathname.</source>
          <target state="translated">この関数によって返されるファイル名は、&lt;a href=&quot;../vfs&quot;&gt;VFSの&lt;/a&gt; xFullPathnameメソッドの出力です。つまり、データベースを開くために使用されたファイル名が元々URIまたは相対パス名であったとしても、ファイル名は絶対パス名になります。</target>
        </trans-unit>
        <trans-unit id="9485b160522d31184c8916615322f5219f0612b8" translate="yes" xml:space="preserve">
          <source>The filename returned by this function is the output of the xFullPathname method of the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. In other words, the filename will be an absolute pathname, even if the filename used to open the database originally was a URI or relative pathname.</source>
          <target state="translated">この関数によって返されるファイル名は、&lt;a href=&quot;vfs&quot;&gt;VFSの&lt;/a&gt; xFullPathnameメソッドの出力です。つまり、データベースを開くために使用されたファイル名が元々URIまたは相対パス名であったとしても、ファイル名は絶対パス名になります。</target>
        </trans-unit>
        <trans-unit id="fc318f399f5ecbc4db919258057f39b26883fdf3" translate="yes" xml:space="preserve">
          <source>The final answer is found by looking for a string with ind==0. If the original sudoku problem did not have a unique solution, then the query will return all possible solutions. If the original problem was unsolvable, then no rows will be returned. In this case, the unique answer is:</source>
          <target state="translated">最終的な答えは、ind==0の文字列を探して見つけます。 元のすどくの問題が一意の解を持っていなかった場合、クエリは可能性のあるすべての解を返します。元の問題が解けなかった場合、行は何も返されません。この場合、ユニークな解答は</target>
        </trans-unit>
        <trans-unit id="0fa7031611bf07c03077958f2b8ed29a77590306" translate="yes" xml:space="preserve">
          <source>The final argument is an output variable. If successful, (*ppOut) should be set to point to the new tokenizer handle and SQLITE_OK returned. If an error occurs, some value other than SQLITE_OK should be returned. In this case, fts5 assumes that the final value of *ppOut is undefined.</source>
          <target state="translated">最後の引数は出力変数です。成功した場合、(*ppOut)は新しいトークナイザーハンドルを指すように設定され、SQLITE_OKが返されます。エラーが発生した場合は、SQLITE_OK以外の値を返さなければなりません。この場合、fts5 は *ppOut の最終値が未定義であることを前提としています。</target>
        </trans-unit>
        <trans-unit id="3adcbd65298a5982e7a64803692e07245861c301" translate="yes" xml:space="preserve">
          <source>The final byte of an encoded FTS varint has its most significant bit cleared. All preceding bytes have the most significant bit set. Data is stored in the remaining seven least significant bits of each byte. The first byte of the encoded representation contains the least significant seven bits of the encoded integer value. The second byte of the encoded representation, if it is present, contains the seven next least significant bits of the integer value, and so on. The following table contains examples of encoded integer values:</source>
          <target state="translated">エンコードされた FTS varint の最後のバイトは、その最上位ビットがクリアされます。それ以前のすべてのバイトは最上位ビットがセットされています。データは各バイトの残りの最下位7ビットに格納される。符号化された表現の最初のバイトは、符号化された整数値の最下位7ビットを含む。符号化された表現の2番目のバイトは、存在する場合、整数値の次の最下位7ビットを含みます。符号化された整数値の例を以下の表に示す。</target>
        </trans-unit>
        <trans-unit id="c65b7966b6f5867eece6741b751cabc0c349ca6a" translate="yes" xml:space="preserve">
          <source>The final line of the example (the &quot;.system c:/work/dataout.csv&quot;) has the same effect as double-clicking on the c:/work/dataout.csv file in windows. This will typically bring up a spreadsheet program to display the CSV file.</source>
          <target state="translated">例の最終行(「.system c:/work/dataout.csv」)は、ウィンドウズのc:/work/dataout.csvファイルをダブルクリックするのと同じ効果があります。これにより、通常はCSVファイルを表示するための表計算プログラムが表示されます。</target>
        </trans-unit>
        <trans-unit id="312ab3f0c70e0337ccdf666710177cbb51a2f6d3" translate="yes" xml:space="preserve">
          <source>The final query in the block above may not work as expected. Because the &quot;*&quot; character is inside the double-quotes, it will be passed to the tokenizer, which will likely discard it (or perhaps, depending on the specific tokenizer in use, include it as part of the final token) instead of recognizing it as a special FTS character.</source>
          <target state="translated">上のブロックの最後のクエリは期待通りには動作しないかもしれません。文字 &quot;*&quot; はダブルクォートの中に入っているため、トークン化ツールに渡され、トークン化ツールはこれを特別な FTS 文字として認識するのではなく、破棄します (使用しているトークン化ツールによっては、最終的なトークンの一部として含めることもあります)。</target>
        </trans-unit>
        <trans-unit id="a564ec7adef18f2e787e1258b9aed3803202963e" translate="yes" xml:space="preserve">
          <source>The final recovery step is to reduce the exclusive lock back to a shared lock. Once this happens, the database is back in the state that it would have been if the aborted transaction had never started. Since all of this recovery activity happens completely automatically and transparently, it appears to the program using SQLite as if the aborted transaction had never begun.</source>
          <target state="translated">最終的な回復ステップは、排他ロックを共有ロックに戻すことです。これが起こると、データベースは、中断されたトランザクションが開始されなかった場合の状態に戻ります。この復旧作業はすべて完全に自動的かつ透過的に行われるため、SQLiteを使用するプログラムからは、中断されたトランザクションが開始されていなかったかのように見えます。</target>
        </trans-unit>
        <trans-unit id="434e32f7c5be2c22a40571665c3031a75ce803d2" translate="yes" xml:space="preserve">
          <source>The final source of large memory allocations is the space to hold the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; that result from compiling complex SQL operations. Ongoing work by the SQLite developers is reducing the amount of space required here. But large and complex queries might still require &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; that are several kilobytes in size. The only workaround at the moment is for the application to break complex SQL operations up into two or more smaller and simpler operations contained in separate &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt;.</source>
          <target state="translated">大量のメモリ割り当ての最後のソースは、複雑なSQL操作のコンパイルから生じる&lt;a href=&quot;c3ref/stmt&quot;&gt;準備済みステートメント&lt;/a&gt;を保持するためのスペースです。 SQLite開発者による継続的な作業により、ここで必要なスペースの量が減少しています。ただし、大規模で複雑なクエリでは、サイズが数キロバイトの&lt;a href=&quot;c3ref/stmt&quot;&gt;準備済みステートメント&lt;/a&gt;が必要になる場合があります。現時点での唯一の回避策は、アプリケーションが、複雑なSQL操作を、別々の&lt;a href=&quot;c3ref/stmt&quot;&gt;準備されたステートメントに&lt;/a&gt;含まれる2つ以上のより単純な操作に分割することです。</target>
        </trans-unit>
        <trans-unit id="2e5be990568c2b06d13617fdb20a3f4473d59b9c" translate="yes" xml:space="preserve">
          <source>The final step in a multi-file commit is to delete the individual rollback journals and drop the exclusive locks on the database files so that other processes can see the changes. This corresponds to &lt;a href=&quot;#section_3_12&quot;&gt;step 3.12&lt;/a&gt; in the single-file commit sequence.</source>
          <target state="translated">マルチファイルコミットの最後の手順は、個々のロールバックジャーナルを削除し、データベースファイルの排他ロックを削除して、他のプロセスが変更を確認できるようにすることです。これは、単一ファイルのコミットシーケンスの&lt;a href=&quot;#section_3_12&quot;&gt;ステップ3.12&lt;/a&gt;に対応します。</target>
        </trans-unit>
        <trans-unit id="570119a07afaf61a9f20cf9abd68b217ebf33834" translate="yes" xml:space="preserve">
          <source>The final three arguments passed to the auxiliary function callback are similar to the three arguments passed to the implementation of a scalar SQL function. All arguments except the first passed to the auxiliary function are available to the implementation in the apVal[] array. The implementation should return a result or error via the content handle pCtx.</source>
          <target state="translated">補助関数のコールバックに渡される最後の3つの引数は、スカラーSQL関数の実装に渡される3つの引数と似ています。補助関数に渡される最初の引数以外のすべての引数は、実装ではapVal[]配列で利用可能です。実装は、結果またはエラーをコンテンツハンドルpCtxを介して返さなければなりません。</target>
        </trans-unit>
        <trans-unit id="72acf6716754df5bf7660108439b7caacc7e6afa" translate="yes" xml:space="preserve">
          <source>The first 100 bytes of the database file comprise the database file header. The database file header is divided into fields as shown by the table below. All multibyte fields in the database file header are stored with the most significant byte first (big-endian).</source>
          <target state="translated">データベースファイルの最初の100バイトは、データベースファイルヘッダからなる。データベースファイルヘッダは、以下の表に示すようにフィールドに分割されています。データベースファイルヘッダ内のすべてのマルチバイトフィールドは、最上位バイトを先頭にして格納されます(ビッグエンディアン)。</target>
        </trans-unit>
        <trans-unit id="7ad8baeb9b6a7d25df8e53c7bba57a3b07d6a12e" translate="yes" xml:space="preserve">
          <source>The first 136 bytes of the shm file are a header. The shm header has three main divisions as follows:</source>
          <target state="translated">shmファイルの最初の136バイトはヘッダです。shmのヘッダは以下のように3つの主要な分割があります。</target>
        </trans-unit>
        <trans-unit id="32a4d848523b5982a35dd9ccae2a5e300c48ac95" translate="yes" xml:space="preserve">
          <source>The first 8 bytes of the</source>
          <target state="translated">の最初の8バイトは</target>
        </trans-unit>
        <trans-unit id="31e639e14579d85dee4c60a5aeaa903eaa1984f2" translate="yes" xml:space="preserve">
          <source>The first argument must be the sqlite3_index_info object that is the first parameter to the xBestIndex() method. The second argument must be an index into the aConstraint[] array belonging to the sqlite3_index_info structure passed to xBestIndex. This function returns a pointer to a buffer containing the name of the collation sequence for the corresponding constraint.</source>
          <target state="translated">第一引数は、xBestIndex()メソッドの第一引数であるsqlite3_index_infoオブジェクトでなければなりません。第2引数は、xBestIndexに渡されたsqlite3_index_info構造体に属するaConstraint[]配列へのインデックスでなければなりません。この関数は、対応する制約の照合順序の名前を含むバッファへのポインタを返します。</target>
        </trans-unit>
        <trans-unit id="756a3aef230a7b2fc01840e9c05f1d8a68c861b7" translate="yes" xml:space="preserve">
          <source>The first argument passed should be the database handle to register the extension with. The second and third arguments should both be passed 0.</source>
          <target state="translated">最初の引数には、拡張機能を登録するデータベースハンドルを渡す必要があります。第二引数と第三引数はどちらも0を渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="7fa580625e479f237836af3af275aa2f6a47351d" translate="yes" xml:space="preserve">
          <source>The first argument passed to an auxiliary function callback is a pointer to a structure containing methods that may be invoked in order to obtain information regarding the current query or row. The second argument is an opaque handle that should be passed as the first argument to any such method invocation. For example, the following auxiliary function definition returns the total number of tokens in all columns of the current row:</source>
          <target state="translated">補助関数コールバックに渡される第一引数は、現在のクエリまたは行に関する情報を取得するために呼び出される可能性のあるメソッドを含む構造体へのポインタです。第2引数は不透明なハンドルで、このようなメソッド呼び出しの第1引数として渡されるべきものです。例えば、以下の補助関数の定義は、現在の行の全列のトークンの総数を返します。</target>
        </trans-unit>
        <trans-unit id="d4428415829da9afdeca7abddd54df2e62906cce" translate="yes" xml:space="preserve">
          <source>The first argument passed to this function is a copy of the (void*) pointer provided by the application when the fts5_tokenizer object was registered with FTS5 (the third argument to xCreateTokenizer()). The second and third arguments are an array of nul-terminated strings containing the tokenizer arguments, if any, specified following the tokenizer name as part of the CREATE VIRTUAL TABLE statement used to create the FTS5 table.</source>
          <target state="translated">この関数に渡される第一引数は、fts5_tokenizerオブジェクトがFTS5に登録されたときにアプリケーションによって提供された(void*)ポインタのコピーです(xCreateTokenizer()の第三引数)。2 番目と 3 番目の引数は、FTS5 テーブルを作成するために使用された CREATE VIRTUAL TABLE 文の一部としてトーケナイザー名の後に指定されたトーケナイザー引数があれば、それを含むヌル終端文字列の配列です。</target>
        </trans-unit>
        <trans-unit id="3ddc48958f41facca8a1ecdc60ac948a59cb2349" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; must be the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; pointer as the first parameter to this method. The second argument to &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; must a zero-terminated UTF-8 string that contains a well-formed &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement that defines the columns in the virtual table and their data types. The name of the table in this CREATE TABLE statement is ignored, as are all constraints. Only the column names and datatypes matter. The CREATE TABLE statement string need not to be held in persistent memory. The string can be deallocated and/or reused as soon as the &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; routine returns.</source>
          <target state="translated">最初の引数&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab（）は&lt;/a&gt;同じである必要があり&lt;a href=&quot;c3ref/sqlite3&quot;&gt;、データベース接続&lt;/a&gt;この方法の最初のパラメータとして、ポインタ。&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab（）&lt;/a&gt;の2番目の引数は、仮想テーブルの列とそのデータ型を定義する整形式の&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;ステートメントを含む、ゼロで終了するUTF-8文字列である必要があります。このCREATE TABLEステートメントのテーブルの名前は、すべての制約と同様に無視されます。重要なのは列名とデータ型だけです。 CREATE TABLEステートメント文字列は、永続メモリに保持する必要はありません。&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab（）&lt;/a&gt;ルーチンが戻るとすぐに、文字列の割り当てを解除したり、再利用したりできます。</target>
        </trans-unit>
        <trans-unit id="1aed5522193a69fc6ff8aa89cff3e41266a3f600" translate="yes" xml:space="preserve">
          <source>The first argument to all three special SQL scalar functions must be the &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; of the FTS table that the function is applied to. The &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; is an automatically-generated column found on all FTS tables that has the same name as the FTS table itself. For example, given an FTS table named &quot;mail&quot;:</source>
          <target state="translated">3つすべての特別なSQLスカラー関数の最初の引数は、関数が適用されるFTSテーブルの&lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS非表示列&lt;/a&gt;である必要があります。&lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS隠された列は、&lt;/a&gt; FTSテーブル自体と同じ名前を持つすべてのFTSテーブルで見つかっ自動的に生成された列です。たとえば、「mail」という名前のFTSテーブルがあるとします。</target>
        </trans-unit>
        <trans-unit id="952294bca557c59738bac0e545034c52a263067f" translate="yes" xml:space="preserve">
          <source>The first argument to sqlite3_config() is an integer &lt;a href=&quot;#SQLITE_CONFIG_COVERING_INDEX_SCAN&quot;&gt;configuration option&lt;/a&gt; that determines what property of SQLite is to be configured. Subsequent arguments vary depending on the &lt;a href=&quot;#SQLITE_CONFIG_COVERING_INDEX_SCAN&quot;&gt;configuration option&lt;/a&gt; in the first argument.</source>
          <target state="translated">sqlite3_config（）の最初の引数は、SQLite のどのプロパティを&lt;a href=&quot;#SQLITE_CONFIG_COVERING_INDEX_SCAN&quot;&gt;構成&lt;/a&gt;するかを決定する整数構成オプションです。後続の引数は、最初の引数の&lt;a href=&quot;#SQLITE_CONFIG_COVERING_INDEX_SCAN&quot;&gt;構成オプション&lt;/a&gt;によって異なります。</target>
        </trans-unit>
        <trans-unit id="f875f5d7c01e9a29524328575e142babf2bae3ae" translate="yes" xml:space="preserve">
          <source>The first argument to sqlite3_config() is an integer &lt;a href=&quot;c_config_covering_index_scan&quot;&gt;configuration option&lt;/a&gt; that determines what property of SQLite is to be configured. Subsequent arguments vary depending on the &lt;a href=&quot;c_config_covering_index_scan&quot;&gt;configuration option&lt;/a&gt; in the first argument.</source>
          <target state="translated">sqlite3_config（）の最初の引数は、SQLite のどのプロパティを&lt;a href=&quot;c_config_covering_index_scan&quot;&gt;構成&lt;/a&gt;するかを決定する整数構成オプションです。後続の引数は、最初の引数の&lt;a href=&quot;c_config_covering_index_scan&quot;&gt;構成オプション&lt;/a&gt;によって異なります。</target>
        </trans-unit>
        <trans-unit id="3f0ed77e9965fa2c39bb9cbb993108ef55b7d05b" translate="yes" xml:space="preserve">
          <source>The first argument to the busy handler is a copy of the void* pointer which is the third argument to sqlite3_busy_handler(). The second argument to the busy handler callback is the number of times that the busy handler has been invoked previously for the same locking event. If the busy callback returns 0, then no additional attempts are made to access the database and &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned to the application. If the callback returns non-zero, then another attempt is made to access the database and the cycle repeats.</source>
          <target state="translated">busyハンドラーの最初の引数は、sqlite3_busy_handler（）の3番目の引数であるvoid *ポインターのコピーです。ビジーハンドラーコールバックの2番目の引数は、ビジーハンドラーが同じロックイベントに対して以前に呼び出された回数です。ビジーコールバックが0を返した場合、データベースへのアクセスは試行されず、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;がアプリケーションに返されます。コールバックがゼロ以外を返す場合、データベースへのアクセスが再度試行され、サイクルが繰り返されます。</target>
        </trans-unit>
        <trans-unit id="73aa47dd980f8a887b15a2decc4e912f8fd4e328" translate="yes" xml:space="preserve">
          <source>The first argument to the busy handler is a copy of the void* pointer which is the third argument to sqlite3_busy_handler(). The second argument to the busy handler callback is the number of times that the busy handler has been invoked previously for the same locking event. If the busy callback returns 0, then no additional attempts are made to access the database and &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned to the application. If the callback returns non-zero, then another attempt is made to access the database and the cycle repeats.</source>
          <target state="translated">busyハンドラーの最初の引数は、sqlite3_busy_handler（）の3番目の引数であるvoid *ポインターのコピーです。ビジーハンドラーコールバックの2番目の引数は、ビジーハンドラーが同じロックイベントに対して以前に呼び出された回数です。ビジーコールバックが0を返した場合、データベースへのアクセスは試行されず、&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;がアプリケーションに返されます。コールバックがゼロ以外を返す場合、データベースへのアクセスが再度試行され、サイクルが繰り返されます。</target>
        </trans-unit>
        <trans-unit id="395ff21e8cf7b4d90e5bc3764e07164a7c24e72d" translate="yes" xml:space="preserve">
          <source>The first argument to the callback is just a copy of the fourth argument to &lt;b&gt;sqlite_exec&lt;/b&gt; This parameter can be used to pass arbitrary information through to the callback function from client code. The second argument is the number of columns in the query result. The third argument is an array of pointers to strings where each string is a single column of the result for that record. Note that the callback function reports a NULL value in the database as a NULL pointer, which is very different from an empty string. If the i-th parameter is an empty string, we will get:</source>
          <target state="translated">コールバックの最初の引数は、&lt;b&gt;sqlite_exec&lt;/b&gt;の4番目の引数のコピーです。このパラメーターを使用して、クライアントコードからコールバック関数に任意の情報を渡すことができます。 2番目の引数は、クエリ結果の列数です。 3番目の引数は文字列へのポインタの配列で、各文字列はそのレコードの結果の単一の列です。コールバック関数は、データベース内のNULL値をNULLポインターとして報告することに注意してください。これは、空の文字列とは大きく異なります。 i番目のパラメーターが空の文字列の場合、次のようになります。</target>
        </trans-unit>
        <trans-unit id="19ed31ae74a9a14120db33894759ec36b8a3df0f" translate="yes" xml:space="preserve">
          <source>The first argument to the snippet function must always be the &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; of the FTS table being queried and from which the snippet is to be taken. The &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; is an automatically generated column with the same name as the FTS table itself.</source>
          <target state="translated">スニペット関数の最初の引数は、常に、照会されるFTSテーブルの&lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS非表示列&lt;/a&gt;であり、そこからスニペットが取得されます。&lt;a href=&quot;fts3#hiddencol&quot;&gt;カラムを隠されたFTSは、&lt;/a&gt; FTSテーブル自体と同じ名前を使用して自動的に生成された列です。</target>
        </trans-unit>
        <trans-unit id="a3c117d3156af5d9687ce63c9ca2baca71f1029c" translate="yes" xml:space="preserve">
          <source>The first argument to the sqlite3_bind_*() routines is always a pointer to the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object returned from &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or its variants.</source>
          <target state="translated">sqlite3_bind _ *（）ルーチンへの最初の引数は常にへのポインタである&lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;から返されたオブジェクト&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;またはその変種。</target>
        </trans-unit>
        <trans-unit id="e62bb2c9601439134c1919cc9d703235a3e8dcf1" translate="yes" xml:space="preserve">
          <source>The first argument to the sqlite3_bind_*() routines is always a pointer to the &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object returned from &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or its variants.</source>
          <target state="translated">sqlite3_bind _ *（）ルーチンへの最初の引数は常にへのポインタである&lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt&lt;/a&gt;から返されたオブジェクト&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;またはその変種。</target>
        </trans-unit>
        <trans-unit id="4376fc02622bfe056753a887d840cb5de850cf76" translate="yes" xml:space="preserve">
          <source>The first argument to the sqlite3session_config() function must be one of the SQLITE_SESSION_CONFIG_XXX constants defined below. The interpretation of the (void*) value passed as the second parameter and the effect of calling this function depends on the value of the first parameter.</source>
          <target state="translated">sqlite3session_config()関数の第1引数は、以下に定義されているSQLITE_SESSION_CONFIG_XXX定数のいずれかでなければなりません。2番目のパラメータとして渡された(void*)値の解釈と、この関数を呼び出す効果は、1番目のパラメータの値に依存します。</target>
        </trans-unit>
        <trans-unit id="46628205e32bedcd53350a6840ee825a63d42391" translate="yes" xml:space="preserve">
          <source>The first argument to these interfaces is a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. These functions return information about the Nth result column returned by the statement, where N is the second function argument. The left-most column is column 0 for these routines.</source>
          <target state="translated">これらのインターフェースの最初の引数は、&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備済みステートメント&lt;/a&gt;です。これらの関数は、ステートメントによって返されるN番目の結果列に関する情報を返します。Nは2番目の関数引数です。これらのルーチンの左端の列は列0です。</target>
        </trans-unit>
        <trans-unit id="0f76a71e763d5bd4fbae26e4a6f14b3c938ceb32" translate="yes" xml:space="preserve">
          <source>The first argument to these interfaces is a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. These functions return information about the Nth result column returned by the statement, where N is the second function argument. The left-most column is column 0 for these routines.</source>
          <target state="translated">これらのインターフェースの最初の引数は、&lt;a href=&quot;stmt&quot;&gt;準備済みステートメント&lt;/a&gt;です。これらの関数は、ステートメントによって返されるN番目の結果列に関する情報を返します。Nは2番目の関数引数です。これらのルーチンの左端の列は列0です。</target>
        </trans-unit>
        <trans-unit id="a5ff723764d00dd9ac3f381e3bed0a1f08296ed5" translate="yes" xml:space="preserve">
          <source>The first argument, &quot;db&quot;, is a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; obtained from a prior successful call to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;. The database connection must not have been closed.</source>
          <target state="translated">最初の引数 &quot;db&quot;は、以前に成功した&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;または&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16（）の&lt;/a&gt;呼び出しから取得された&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;です。データベース接続が閉じられていない必要があります。</target>
        </trans-unit>
        <trans-unit id="691e78895187de6910913a151c966bb350230789" translate="yes" xml:space="preserve">
          <source>The first argument, &quot;db&quot;, is a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; obtained from a prior successful call to &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; or &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;. The database connection must not have been closed.</source>
          <target state="translated">最初の引数 &quot;db&quot;は、以前に成功した&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;、&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;または&lt;a href=&quot;open&quot;&gt;sqlite3_open16（）の&lt;/a&gt;呼び出しから取得された&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;です。データベース接続が閉じられていない必要があります。</target>
        </trans-unit>
        <trans-unit id="5da926bf27ba88ce6fa226bb8489971c4b0badd1" translate="yes" xml:space="preserve">
          <source>The first attempt at closing security gaps in pointer passing was to prevent pointer values from being forged. This was accomplished by having the sender attach a subtype to each pointer using &lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; and having the receiver verify that subtype using &lt;a href=&quot;c3ref/value_subtype&quot;&gt;sqlite3_value_subtype()&lt;/a&gt; and reject pointers that had an incorrect subtype. Since there is no way to attach a subtype to a result using pure SQL, this prevents pointers from being forged using SQL. The only way to send a pointer is to use C code. If an attacker can set a subtype, then he is also able to forge a pointer without the help of SQLite.</source>
          <target state="translated">ポインターの受け渡しにおけるセキュリティのギャップを埋める最初の試みは、ポインターの値が偽造されるのを防ぐことでした。これは、送信者が使用して、各ポインタにサブタイプを取り付けることによって達成された&lt;a href=&quot;c3ref/result_subtype&quot;&gt;（sqlite3_result_subtypeを）&lt;/a&gt;と受信機が使用してそのサブタイプを検証有する&lt;a href=&quot;c3ref/value_subtype&quot;&gt;sqlite3_value_subtypeを（）&lt;/a&gt;と誤っサブタイプを持っていたポインタを拒否する。純粋なSQLを使用してサブタイプを結果に添付する方法がないため、SQLを使用してポインターが偽造されるのを防ぎます。ポインタを送信する唯一の方法は、Cコードを使用することです。攻撃者がサブタイプを設定できる場合、攻撃者はSQLiteを使用せずにポインタを偽造することもできます。</target>
        </trans-unit>
        <trans-unit id="b3f912cc569c0361b5c2cd2202f03f7409e6b0b1" translate="yes" xml:space="preserve">
          <source>The first beta release for SQLite 3.0.</source>
          <target state="translated">SQLite 3.0の最初のベータリリースです。</target>
        </trans-unit>
        <trans-unit id="85577f9e39e1e56bdcef30a17afd1e7fd9d77720" translate="yes" xml:space="preserve">
          <source>The first byte of the header is a flag byte. The least significant bit of the flag byte determines whether the coordinate pairs that follow the header are stored big-endian or little-endian. A value of 0 for the least significant bit means big-endian and a value of 1 means little endian. Other bits of the first byte in the header are reserved for future expansion.</source>
          <target state="translated">ヘッダの最初のバ イ ト は フ ラ グバ イ ト です。フラグバイトの最下位ビットは、ヘッダに続く座標ペアがビッグエンディアンかリトルエンディアンかを決定する。最下位ビットの値が0であればビッグエンディアンを意味し、1であればリトルエンディアンを意味する。ヘッダの最初のバイトの他のビットは、将来の拡張のために予約されています。</target>
        </trans-unit>
        <trans-unit id="f63d26f2f4bc609cd955a5edef912da4a0a9006c" translate="yes" xml:space="preserve">
          <source>The first call to &lt;a href=&quot;session/sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; on the iterator moves it to point to the first change in the changeset (or to EOF, if the changeset is completely empty). sqlite3changeset_next() returns SQLITE_ROW if it moves the iterator to point to a valid entry, SQLITE_DONE if it moves the iterator to EOF, or an SQLite error code if an error occurs.</source>
          <target state="translated">イテレータの&lt;a href=&quot;session/sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）&lt;/a&gt;への最初の呼び出しは、変更セットの最初の変更（または変更セットが完全に空の場合はEOF）を指すように移動します。sqlite3changeset_next（）は、イテレータを有効なエントリを指すように移動するとSQLITE_ROWを返し、イテレータをEOFに移動するとSQLITE_DONEを返し、エラーが発生した場合はSQLiteエラーコードを返します。</target>
        </trans-unit>
        <trans-unit id="261c910c7fa661af930e1c363bad2fff3671bdea" translate="yes" xml:space="preserve">
          <source>The first call to sqlite3_backup_step() obtains an exclusive lock on the destination file. The exclusive lock is not released until either sqlite3_backup_finish() is called or the backup operation is complete and sqlite3_backup_step() returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;. Every call to sqlite3_backup_step() obtains a &lt;a href=&quot;lockingv3#shared_lock&quot;&gt;shared lock&lt;/a&gt; on the source database that lasts for the duration of the sqlite3_backup_step() call. Because the source database is not locked between calls to sqlite3_backup_step(), the source database may be modified mid-way through the backup process. If the source database is modified by an external process or via a database connection other than the one being used by the backup operation, then the backup will be automatically restarted by the next call to sqlite3_backup_step(). If the source database is modified by the using the same database connection as is used by the backup operation, then the backup database is automatically updated at the same time.</source>
          <target state="translated">sqlite3_backup_step（）への最初の呼び出しは、宛先ファイルの排他ロックを取得します。sqlite3_backup_finish（）が呼び出されるか、バックアップ操作が完了してsqlite3_backup_step（）が&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONEを&lt;/a&gt;返すまで、排他ロックは解放されません。sqlite3_backup_step（）を呼び出すたびに&lt;a href=&quot;lockingv3#shared_lock&quot;&gt;共有ロック&lt;/a&gt;が取得されますsqlite3_backup_step（）呼び出しの期間中続くソースデータベース。ソースデータベースはsqlite3_backup_step（）の呼び出し間でロックされないため、ソースデータベースはバックアッププロセスの途中で変更される可能性があります。ソースデータベースが外部プロセスによって、またはバックアップ操作で使用されているもの以外のデータベース接続を介して変更された場合、バックアップはsqlite3_backup_step（）への次の呼び出しによって自動的に再開されます。バックアップ操作で使用されるのと同じデータベース接続を使用してソースデータベースが変更された場合、バックアップデータベースは同時に自動的に更新されます。</target>
        </trans-unit>
        <trans-unit id="57eb736cb2a536a07c53b0e0f817765662d0da0a" translate="yes" xml:space="preserve">
          <source>The first call to sqlite3_backup_step() obtains an exclusive lock on the destination file. The exclusive lock is not released until either sqlite3_backup_finish() is called or the backup operation is complete and sqlite3_backup_step() returns &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;. Every call to sqlite3_backup_step() obtains a &lt;a href=&quot;../lockingv3#shared_lock&quot;&gt;shared lock&lt;/a&gt; on the source database that lasts for the duration of the sqlite3_backup_step() call. Because the source database is not locked between calls to sqlite3_backup_step(), the source database may be modified mid-way through the backup process. If the source database is modified by an external process or via a database connection other than the one being used by the backup operation, then the backup will be automatically restarted by the next call to sqlite3_backup_step(). If the source database is modified by the using the same database connection as is used by the backup operation, then the backup database is automatically updated at the same time.</source>
          <target state="translated">sqlite3_backup_step（）への最初の呼び出しは、宛先ファイルの排他ロックを取得します。sqlite3_backup_finish（）が呼び出されるか、バックアップ操作が完了してsqlite3_backup_step（）が&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONEを&lt;/a&gt;返すまで、排他ロックは解放されません。sqlite3_backup_step（）を呼び出すたびに&lt;a href=&quot;../lockingv3#shared_lock&quot;&gt;共有ロック&lt;/a&gt;が取得されますsqlite3_backup_step（）呼び出しの期間中続くソースデータベース。ソースデータベースはsqlite3_backup_step（）の呼び出し間でロックされないため、ソースデータベースはバックアッププロセスの途中で変更される可能性があります。ソースデータベースが外部プロセスによって、またはバックアップ操作で使用されているもの以外のデータベース接続を介して変更された場合、バックアップはsqlite3_backup_step（）への次の呼び出しによって自動的に再開されます。バックアップ操作で使用されるのと同じデータベース接続を使用してソースデータベースが変更された場合、バックアップデータベースは同時に自動的に更新されます。</target>
        </trans-unit>
        <trans-unit id="878621de1d1518fe649327da44b122a6dcc1e4c1" translate="yes" xml:space="preserve">
          <source>The first code for TH3 was laid down on 2008-09-25. An intense effort over the next 10 months resulted in TH3 achieving 100% MC/DC on 2009-07-25. The TH3 code continues to be improved and expanded.</source>
          <target state="translated">TH3 の最初のコードは 2008-09-25 に策定されました。その後10ヶ月間の努力の結果、2009年7月25日にTH3は100%MC/DCを達成しました。TH3 のコードは改良され、拡張され続けています。</target>
        </trans-unit>
        <trans-unit id="708a1cddc7d07a561f3445a868346de6a13841df" translate="yes" xml:space="preserve">
          <source>The first column is the schema name for the database that contains the tables. Examples: &quot;main&quot;, &quot;zone512&quot;.</source>
          <target state="translated">最初の列は、テーブルを含むデータベースのスキーマ名です。例としては、以下のようになります。&quot;main&quot;、&quot;zone512&quot;。</target>
        </trans-unit>
        <trans-unit id="9814feb56c887ece7381e15fd8887b6ec1a1d8c0" translate="yes" xml:space="preserve">
          <source>The first column of an SQLite R*Tree is similar to an integer primary key column of a normal SQLite table. It may only store a 64-bit signed integer value. Inserting a NULL value into this column causes SQLite to automatically generate a new unique primary key value. If an attempt is made to insert any other non-integer value into this column, the r-tree module silently converts it to an integer before writing it into the database.</source>
          <target state="translated">SQLite R*Tree の最初の列は、通常の SQLite テーブルの整数主キー列に似ています。64 ビット符号付き整数値のみを格納することができます。この列に NULL 値を挿入すると、SQLite は自動的に新しい一意の主キー値を生成します。この列に他の非整数値を挿入しようとすると、r-tree モジュールはそれをデータベースに書き込む前に静かに整数に変換します。</target>
        </trans-unit>
        <trans-unit id="840bd12d54aba66c9e7cdaff39f91dd2e3886bf1" translate="yes" xml:space="preserve">
          <source>The first condition causes all of the trunk check-ins to be displayed and the second and third cause check-ins that merge into or fork from the trunk to also be included. The three conditions are implemented by the three OR-connected EXISTS statements in the WHERE clause of the query. The slowdown that occurred with the NGQP was caused by the second and third conditions. The problem is the same in each, so we will examine just the second one. The subquery of the second condition can be rewritten (with minor and immaterial simplifications) as follows:</source>
          <target state="translated">最初の条件では、トランクのすべてのチェックインが表示され、2 番目と 3 番目では、トランクにマージしたり、トランクからフォークしたりするチェックインも含まれます。この3つの条件は、クエリのWHERE句にある3つのOR-connected EXISTS文によって実装されています。NGQPで発生したスローダウンは、2つ目と3つ目の条件が原因でした。問題はそれぞれで同じなので、2つ目の条件だけを見ていきます。2つ目の条件の副問い合わせは、以下のように書き換えることができます(軽微で重要ではない簡略化をしています)。</target>
        </trans-unit>
        <trans-unit id="1d90855e6a48f657d5fb1f13585eab05ee2b6665" translate="yes" xml:space="preserve">
          <source>The first example above is the preferred definition of the table, of course. All of the examples create a WITHOUT ROWID table with two PRIMARY KEY columns, &quot;a&quot; and &quot;c&quot;, in that order, followed by two data columns &quot;b&quot; and &quot;d&quot;, also in that order.</source>
          <target state="translated">上の最初の例は、もちろんテーブルの好ましい定義です。すべての例は、2つのPRIMARY KEYカラム &quot;a &quot;と &quot;c &quot;を持つWITHOUT ROWIDテーブルを作成し、その順番に2つのデータカラム &quot;b &quot;と &quot;d &quot;が続きます。</target>
        </trans-unit>
        <trans-unit id="d78f5e7f65436952c61eefc9d02af59c750bcb9f" translate="yes" xml:space="preserve">
          <source>The first five fields of the sqlite3_rtree_query_info structure are identical to the sqlite3_rtree_geometry structure, and have exactly the same meaning. The sqlite3_rtree_query_info structure also contains nCoord and aCoord fields which have the same meaning as the parameter of the same name in the xGeom callback.</source>
          <target state="translated">sqlite3_rtree_query_info構造体の最初の5つのフィールドはsqlite3_rtree_geometry構造体と同じで、全く同じ意味を持ちます。sqlite3_rtree_query_info構造体は、xGeomコールバックの同名のパラメータと同じ意味を持つnCoordとaCoordフィールドも含んでいます。</target>
        </trans-unit>
        <trans-unit id="8e073e98c04e5afd81b1a912e72c323c17ce2eb5" translate="yes" xml:space="preserve">
          <source>The first form (with the &quot;VALUES&quot; keyword) creates one or more new rows in an existing table. If the column-name list after table-name is omitted then the number of values inserted into each row must be the same as the number of columns in the table. In this case the result of evaluating the left-most expression from each term of the VALUES list is inserted into the left-most column of each new row, and so forth for each subsequent expression. If a column-name list is specified, then the number of values in each term of the VALUE list must match the number of specified columns. Each of the named columns of the new row is populated with the results of evaluating the corresponding VALUES expression. Table columns that do not appear in the column list are populated with the &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;default column value&lt;/a&gt; (specified as part of the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement), or with NULL if no &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;default value&lt;/a&gt; is specified.</source>
          <target state="translated">最初のフォーム（「VALUES」キーワードを使用）は、既存のテーブルに1つ以上の新しい行を作成します。 table-nameの後のcolumn-nameリストが省略されている場合、各行に挿入される値の数は、テーブルの列の数と同じでなければなりません。この場合、VALUESリストの各項の左端の式を評価した結果は、新しい各行の左端の列に挿入され、以降の各式で同様に続きます。列名リストを指定する場合、VALUEリストの各項の値の数は、指定した列の数と一致する必要があります。新しい行の名前付きの各列には、対応するVALUES式の評価結果が入力されます。列リストに表示されないテーブル列には、&lt;a href=&quot;lang_createtable#dfltval&quot;&gt;デフォルトの列値&lt;/a&gt;が入力されます（&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;ステートメントの一部として指定）、または&lt;a href=&quot;lang_createtable#dfltval&quot;&gt;デフォルト値&lt;/a&gt;が指定されていない場合はNULLを使用します。</target>
        </trans-unit>
        <trans-unit id="2570c22a55e27cbe9ad6c1dce2c1cff1bff0c5c4" translate="yes" xml:space="preserve">
          <source>The first form loads the edit distance coefficients from a table called 'TABLENAME'. Any prior coefficients are discarded. So when experimenting with weights and the weight table changes, simply rerun the single-argument form of editdist3() to reload revised coefficients. Note that the edit distance weights used by the editdist3() SQL function are independent from the weights used by the spellfix1 virtual table.</source>
          <target state="translated">最初のフォームは'TABLENAME'というテーブルから編集距離係数をロードします。それ以前の係数はすべて破棄されます。そのため、重みを実験していて重みテーブルが変更された場合、単純に editdist3()の単一引数フォームを再実行して、変更された係数を再ロードしてください。editdist3()SQL 関数で使用される編集距離の重みは、spellfix1 仮想テーブルで使用される重みとは独立していることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7597ee6d3f1982d757a998bf7dd70b5fa125869a" translate="yes" xml:space="preserve">
          <source>The first form of the lag() function returns the result of evaluating expression</source>
          <target state="translated">lag()関数の最初の形式は,式</target>
        </trans-unit>
        <trans-unit id="99435f14d6ece88179aba89152e1459d1e98bf65" translate="yes" xml:space="preserve">
          <source>The first form of the lead() function returns the result of evaluating expression</source>
          <target state="translated">lead()関数の最初の形式は、式</target>
        </trans-unit>
        <trans-unit id="0e38dddff1d9fcb9023e44603abe1408f559a08e" translate="yes" xml:space="preserve">
          <source>The first form of this pragma queries the current journaling mode for</source>
          <target state="translated">このプラグマの最初の形式は、現在のジャーナリングモードの</target>
        </trans-unit>
        <trans-unit id="b8118a5225d858802697d63c772d9f2007991455" translate="yes" xml:space="preserve">
          <source>The first four columns a, b, c, and d of the index would be usable since those four columns form a prefix of the index and are all bound by equality constraints.</source>
          <target state="translated">インデックスの最初の4つの列a,b,c,およびdは、これら4つの列がインデックスの接頭辞を形成し、すべて等質性制約に拘束されているため、使用可能であろう。</target>
        </trans-unit>
        <trans-unit id="4ead6c16538264b763b7c6adde08cc0b22f7c9e0" translate="yes" xml:space="preserve">
          <source>The first group of queries in the log are extracting display options from the &quot;config&quot; and &quot;global_config&quot; tables of the Fossil database. Then there is a single complex query that extracts a list of all elements to be displayed on the timeline. This &quot;timeline&quot; query demonstrates that SQLite can easily process complex relational database queries involving multiple tables, subqueries, and complex WHERE clause constraints, and it can make effective use of indexes to solve the queries with minimal disk I/O.</source>
          <target state="translated">ログの最初のクエリグループは、Fossilデータベースの &quot;config &quot;と &quot;global_config &quot;テーブルから表示オプションを抽出しています。そして、タイムラインに表示されるすべての要素のリストを抽出する単一の複雑なクエリがあります。この「Timeline」クエリは、SQLiteが複数のテーブル、サブクエリ、複雑なWHERE句制約を含む複雑なリレーショナルデータベースクエリを簡単に処理でき、インデックスを効果的に利用して最小限のディスクI/Oでクエリを解決できることを示しています。</target>
        </trans-unit>
        <trans-unit id="4e52fafda10d32765550d3edce2eeda11c3b4ffd" translate="yes" xml:space="preserve">
          <source>The first host parameter has an index of 1, not 0.</source>
          <target state="translated">最初のホストパラメータのインデックスは0ではなく1です。</target>
        </trans-unit>
        <trans-unit id="178a49643c52d6ff462985df8e6c238cfb8ec5cd" translate="yes" xml:space="preserve">
          <source>The first instruction of interest is the &lt;a href=&quot;opcode#AggReset&quot;&gt;AggReset&lt;/a&gt; at 2. The AggReset instruction initializes the set of buckets to be the empty set and specifies the number of memory slots available in each bucket as P2. In this example, each bucket will hold 3 memory slots. It is not obvious, but if you look closely at the rest of the program you can figure out what each of these slots is intended for.</source>
          <target state="translated">関心の最初の命令である&lt;a href=&quot;opcode#AggReset&quot;&gt;AggReset&lt;/a&gt; 2でAggReset命令は空集合であるとバケットのセットを初期化し、P2、各バケット内の利用可能なメモリスロットの数を指定します。この例では、各バケットが3つのメモリスロットを保持します。それは明白ではありませんが、プログラムの残りの部分をよく見ると、これらの各スロットが何を意図しているのかを理解できます。</target>
        </trans-unit>
        <trans-unit id="11dcba86733ec3f9c57f212488f98cc390a1b479" translate="yes" xml:space="preserve">
          <source>The first integer in the P4 integer array is the length of the array and does not become part of the permutation.</source>
          <target state="translated">P4 整数配列の最初の整数は配列の長さであり、順列の一部にはなりません。</target>
        </trans-unit>
        <trans-unit id="388856185e941f1980f4fd92691075a08784c68c" translate="yes" xml:space="preserve">
          <source>The first line of the script above causes the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; to read and activate the run-time loadable extension for CSV. For an application, the equivalent C-language API is &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt;. Observe that the filename extension (ex: &quot;.dll&quot; or &quot;.so&quot; or &quot;.dylib&quot;) is omitted from the extension filename. Omitting the filename extension is not required, but it helps in making the script cross-platform. SQLite will automatically append the appropriate extension.</source>
          <target state="translated">上記のスクリプトの最初の行により、&lt;a href=&quot;cli&quot;&gt;コマンドラインシェルは&lt;/a&gt;、CSV用のランタイムロード可能拡張機能を読み取り、アクティブ化します。アプリケーションの場合、同等のC言語APIは&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension（）&lt;/a&gt;です。ファイル名の拡張子（例：「.dll」、「。so」、「。dylib」）が拡張子のファイル名から省略されていることを確認します。ファイル名拡張子の省略は必須ではありませんが、スクリプトをクロスプラットフォームにするのに役立ちます。 SQLiteは自動的に適切な拡張子を追加します。</target>
        </trans-unit>
        <trans-unit id="75252c48c68a826da51013f5fcc062daddeb6d8f" translate="yes" xml:space="preserve">
          <source>The first of the above that is found to exist and have the write and execute bits set is used. The final &quot;.&quot; fallback is important for some applications that use SQLite inside of chroot jails that do not have the standard temporary file locations available.</source>
          <target state="translated">上記のうち、最初に存在し、書き込みおよび実行ビットが設定されていることが判明したものが使用されます。最後の&quot;.&quot;フォールバックは、標準の一時ファイルの場所が利用できない chroot jail の中で SQLite を使用するいくつかのアプリケーションにとって重要です。</target>
        </trans-unit>
        <trans-unit id="1f9a60bfbed88db253a25c41a987f86e19f4d6aa" translate="yes" xml:space="preserve">
          <source>The first page of a cell payload overflow chain. The page number is the b-tree page that contains the cell whose content has overflowed.</source>
          <target state="translated">セルのペイロードがオーバーフローしたチェインの最初のページ。ページ番号は、コンテンツがオーバーフローしたセルを含む b-tree ページです。</target>
        </trans-unit>
        <trans-unit id="571e717de8bab6f472a3daa4d0e34a129cf9485d" translate="yes" xml:space="preserve">
          <source>The first parameter is a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. If this statement is a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement and the Nth column of the returned result set of that &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; is a table column (not an expression or subquery) then the declared type of the table column is returned. If the Nth column of the result set is an expression or subquery, then a NULL pointer is returned. The returned string is always UTF-8 encoded.</source>
          <target state="translated">最初のパラメーターは、&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備済みステートメント&lt;/a&gt;です。このステートメントが&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントであり、その&lt;a href=&quot;lang_select&quot;&gt;SELECTの&lt;/a&gt;返された結果セットのN番目の列が（式やサブクエリではなく）テーブル列である場合、テーブル列の宣言された型が返されます。結果セットのN番目の列が式またはサブクエリである場合、NULLポインターが返されます。返される文字列は常にUTF-8でエンコードされています。</target>
        </trans-unit>
        <trans-unit id="2d95d478fea3b8287d0a6628b14c6c99e2b30bf0" translate="yes" xml:space="preserve">
          <source>The first parameter is a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. If this statement is a &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement and the Nth column of the returned result set of that &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; is a table column (not an expression or subquery) then the declared type of the table column is returned. If the Nth column of the result set is an expression or subquery, then a NULL pointer is returned. The returned string is always UTF-8 encoded.</source>
          <target state="translated">最初のパラメーターは、&lt;a href=&quot;stmt&quot;&gt;準備済みステートメント&lt;/a&gt;です。このステートメントが&lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントであり、その&lt;a href=&quot;../lang_select&quot;&gt;SELECTの&lt;/a&gt;返された結果セットのN番目の列が（式やサブクエリではなく）テーブル列である場合、テーブル列の宣言された型が返されます。結果セットのN番目の列が式またはサブクエリである場合、NULLポインターが返されます。返される文字列は常にUTF-8でエンコードされています。</target>
        </trans-unit>
        <trans-unit id="c8355444303911368f3db824744273405e752637" translate="yes" xml:space="preserve">
          <source>The first parameter is the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; to which the SQL function is to be added. If an application uses more than one database connection then application-defined SQL functions must be added to each database connection separately.</source>
          <target state="translated">最初のパラメーターは、SQL関数を追加する&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;です。アプリケーションが複数のデータベース接続を使用する場合、アプリケーション定義のSQL関数を各データベース接続に個別に追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="2034bce444668b7bc337245a2c547e0aff9b9fd1" translate="yes" xml:space="preserve">
          <source>The first parameter is the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; to which the SQL function is to be added. If an application uses more than one database connection then application-defined SQL functions must be added to each database connection separately.</source>
          <target state="translated">最初のパラメーターは、SQL関数を追加する&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;です。アプリケーションが複数のデータベース接続を使用する場合、アプリケーション定義のSQL関数を各データベース接続に個別に追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="02bbb4f6b68ff55742031c8b1808d80607aaa103" translate="yes" xml:space="preserve">
          <source>The first parameter must be a copy of the &lt;a href=&quot;#sqlite3_context&quot;&gt;SQL function context&lt;/a&gt; that is the first parameter to the xStep or xFinal callback routine that implements the aggregate function.</source>
          <target state="translated">最初のパラメーターは、集約関数を実装するxStepまたはxFinalコールバックルーチンへの最初のパラメーターである&lt;a href=&quot;#sqlite3_context&quot;&gt;SQL関数コンテキストの&lt;/a&gt;コピーである必要があります。</target>
        </trans-unit>
        <trans-unit id="303b1214ac90198e86e2d6fded39de6f12728048" translate="yes" xml:space="preserve">
          <source>The first parameter must be a copy of the &lt;a href=&quot;context&quot;&gt;SQL function context&lt;/a&gt; that is the first parameter to the xStep or xFinal callback routine that implements the aggregate function.</source>
          <target state="translated">最初のパラメーターは、集約関数を実装するxStepまたはxFinalコールバックルーチンへの最初のパラメーターである&lt;a href=&quot;context&quot;&gt;SQL関数コンテキストの&lt;/a&gt;コピーである必要があります。</target>
        </trans-unit>
        <trans-unit id="51bc3b9167a1367dcb303b210930c2e99a40f80a" translate="yes" xml:space="preserve">
          <source>The first parameter passed to the callback function when it is invoked is a copy of the third parameter passed to sqlite3_wal_hook() when registering the callback. The second is a copy of the database handle. The third parameter is the name of the database that was written to - either &quot;main&quot; or the name of an &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed database. The fourth parameter is the number of pages currently in the write-ahead log file, including those that were just committed.</source>
          <target state="translated">コールバック関数の呼び出し時に渡される最初のパラメーターは、コールバックの登録時にsqlite3_wal_hook（）に渡される3番目のパラメーターのコピーです。2つ目は、データベースハンドルのコピーです。3番目のパラメーターは、「メイン」または&lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt;されたデータベースの名前のいずれかに書き込まれたデータベースの名前です。4番目のパラメーターは、コミットされたばかりのページを含む、現在の先行書き込みログファイル内のページ数です。</target>
        </trans-unit>
        <trans-unit id="8448fcb45b7f072723f93590a80d37aef6a727c3" translate="yes" xml:space="preserve">
          <source>The first parameter passed to the callback function when it is invoked is a copy of the third parameter passed to sqlite3_wal_hook() when registering the callback. The second is a copy of the database handle. The third parameter is the name of the database that was written to - either &quot;main&quot; or the name of an &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed database. The fourth parameter is the number of pages currently in the write-ahead log file, including those that were just committed.</source>
          <target state="translated">コールバック関数の呼び出し時に渡される最初のパラメーターは、コールバックの登録時にsqlite3_wal_hook（）に渡される3番目のパラメーターのコピーです。2つ目は、データベースハンドルのコピーです。3番目のパラメーターは、「メイン」または&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;されたデータベースの名前のいずれかに書き込まれたデータベースの名前です。4番目のパラメーターは、コミットされたばかりのページを含む、現在の先行書き込みログファイル内のページ数です。</target>
        </trans-unit>
        <trans-unit id="114b67e4b3a89669211882b27d3030f929c0b812" translate="yes" xml:space="preserve">
          <source>The first parameter to the authorizer callback is a copy of the third parameter to the sqlite3_set_authorizer() interface. The second parameter to the callback is an integer &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;action code&lt;/a&gt; that specifies the particular action to be authorized. The third through sixth parameters to the callback are either NULL pointers or zero-terminated strings that contain additional details about the action to be authorized. Applications must always be prepared to encounter a NULL pointer in any of the third through the sixth parameters of the authorization callback.</source>
          <target state="translated">オーソライザーコールバックへの最初のパラメーターは、sqlite3_set_authorizer（）インターフェースへの3番目のパラメーターのコピーです。コールバックの2番目のパラメーターは、承認する特定のアクションを指定する整数&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;アクションコード&lt;/a&gt;です。コールバックへの3番目から6番目のパラメーターは、許可されるアクションに関する追加の詳細を含むNULLポインターまたはゼロで終了する文字列です。アプリケーションは常に、許可コールバックの3番目から6番目のパラメーターのいずれかでNULLポインターに遭遇するように準備する必要があります。</target>
        </trans-unit>
        <trans-unit id="031900d436ad256c6483a02e204c32e4df2ca84e" translate="yes" xml:space="preserve">
          <source>The first parameter to the authorizer callback is a copy of the third parameter to the sqlite3_set_authorizer() interface. The second parameter to the callback is an integer &lt;a href=&quot;c_alter_table&quot;&gt;action code&lt;/a&gt; that specifies the particular action to be authorized. The third through sixth parameters to the callback are either NULL pointers or zero-terminated strings that contain additional details about the action to be authorized. Applications must always be prepared to encounter a NULL pointer in any of the third through the sixth parameters of the authorization callback.</source>
          <target state="translated">オーソライザーコールバックへの最初のパラメーターは、sqlite3_set_authorizer（）インターフェースへの3番目のパラメーターのコピーです。コールバックの2番目のパラメーターは、承認する特定のアクションを指定する整数&lt;a href=&quot;c_alter_table&quot;&gt;アクションコード&lt;/a&gt;です。コールバックへの3番目から6番目のパラメーターは、許可されるアクションに関する追加の詳細を含むNULLポインターまたはゼロで終了する文字列です。アプリケーションは常に、許可コールバックの3番目から6番目のパラメーターのいずれかでNULLポインターに遭遇するように準備する必要があります。</target>
        </trans-unit>
        <trans-unit id="1622094cd4d4c27ce242fb95c194e4ab11274192" translate="yes" xml:space="preserve">
          <source>The first parameter to these interfaces (hereafter referred to as F) must be one of:</source>
          <target state="translated">これらのインタフェースに対する第1のパラメータ(以下、Fという)は、いずれか1つでなければならない。</target>
        </trans-unit>
        <trans-unit id="29c4884990e25d1601d544fb2189fcbf8e2210be" translate="yes" xml:space="preserve">
          <source>The first section introduces the concept of an SQL foreign key by example and defines the terminology used for the remainder of the document. Section 2 describes the steps an application must take in order to enable foreign key constraints in SQLite (it is disabled by default). The next section, section 3, describes the indexes that the user must create in order to use foreign key constraints, and those that should be created in order for foreign key constraints to function efficiently. Section 4 describes the advanced foreign key related features supported by SQLite and section 5 describes the way the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER&lt;/a&gt; and &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; commands are enhanced to support foreign key constraints. Finally, section 6 enumerates the missing features and limits of the current implementation.</source>
          <target state="translated">最初のセクションでは、例によってSQL外部キーの概念を紹介し、ドキュメントの残りの部分で使用される用語を定義します。セクション2では、SQLiteで外部キー制約を有効にするためにアプリケーションが実行する必要がある手順について説明します（デフォルトでは無効になっています）。次のセクション、セクション3では、外部キー制約を使用するためにユーザーが作成する必要があるインデックスと、外部キー制約を効率的に機能させるために作成する必要があるインデックスについて説明します。セクション4では、SQLiteでサポートされる拡張外部キー関連の機能について説明し、セクション5では、&lt;a href=&quot;lang_altertable&quot;&gt;ALTER&lt;/a&gt;および&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;コマンドが拡張されて外部キー制約をサポートする方法について説明します。最後に、セクション6では、現在の実装に欠けている機能と制限を列挙します。</target>
        </trans-unit>
        <trans-unit id="6abe8a139c8044b273ba74ec6b9c2e3f141ecabe" translate="yes" xml:space="preserve">
          <source>The first set of three values corresponds to the left-most column of the table (column 0) and the left-most matchable phrase in the query (phrase 0). If the table has more than one column, the second set of three values in the output array correspond to phrase 0 and column 1. Followed by phrase 0, column 2 and so on for all columns of the table. And so on for phrase 1, column 0, then phrase 1, column 1 etc. In other words, the data for occurrences of phrase</source>
          <target state="translated">3つの値の最初のセットは、テーブルの左端の列(列0)と、クエリの中で最も左に一致するフレーズ(フレーズ0)に対応します。テーブルに複数のカラムがある場合、出力配列の 2 番目の 3 つの値のセットは、フレーズ 0 とカラム 1 に対応します。続いて、テーブルのすべての列について、フレーズ 0、列 2 と続きます。そして、フレーズ 1、カラム 0、フレーズ 1、カラム 1 などと続きます。言い換えれば、フレーズ</target>
        </trans-unit>
        <trans-unit id="b88b9c17da99b9d9285ae75db888dfa7bebfc06c" translate="yes" xml:space="preserve">
          <source>The first six interfaces (_blob, _double, _int, _int64, _text, and _text16) each return the value of a result column in a specific data format. If the result column is not initially in the requested format (for example, if the query returns an integer but the sqlite3_column_text() interface is used to extract the value) then an automatic type conversion is performed.</source>
          <target state="translated">最初の6つのインタフェース(_blob,_double,_int,_int64,_text,_text16)はそれぞれ、結果カラムの値を特定のデータ形式で返します。結果カラムが最初に要求された形式ではない場合(例えば、クエリが整数を返し、値を抽出するためにsqlite3_column_text()インタフェースが使用されている場合など)、自動型変換が行われます。</target>
        </trans-unit>
        <trans-unit id="67231aa738e6314e6f80285f8fe72b39964cf222" translate="yes" xml:space="preserve">
          <source>The first six modifiers (1 through 6) simply add the specified amount of time to the date and time specified by the preceding timestring and modifiers. The 's' character at the end of the modifier names is optional. Note that &quot;&amp;plusmn;NNN months&quot; works by rendering the original date into the YYYY-MM-DD format, adding the &amp;plusmn;NNN to the MM month value, then normalizing the result. Thus, for example, the data 2001-03-31 modified by '+1 month' initially yields 2001-04-31, but April only has 30 days so the date is normalized to 2001-05-01. A similar effect occurs when the original date is February 29 of a leapyear and the modifier is &amp;plusmn;N years where N is not a multiple of four.</source>
          <target state="translated">最初の6つの修飾子（1から6）は、前のtimestringと修飾子で指定された日時に、指定された時間を追加するだけです。修飾子名の最後の「s」文字はオプションです。 「&amp;plusmn;NNN月」は、元の日付をYYYY-MM-DD形式にレンダリングし、&amp;plusmn;NNNをMM月の値に追加して、結果を正規化することで機能することに注意してください。したがって、たとえば、2001-03-31を「+1か月」で変更したデータは、最初は2001-04-31になりますが、4月は30日しかないため、日付は2001-05-01に正規化されます。元の日付がうるう年の2月29日で、修飾子が&amp;plusmn;N年の場合も同様の効果が発生します。Nは4の倍数ではありません。</target>
        </trans-unit>
        <trans-unit id="de80fd15e7d30919dde63ea2e434aa9d73b98e29" translate="yes" xml:space="preserve">
          <source>The first step toward dealing with a hot journal is to obtain an exclusive lock on the database file. This prevents two or more processes from trying to rollback the same hot journal at the same time.</source>
          <target state="translated">ホットジャーナルを処理するための最初のステップは、データベースファイルの排他的なロックを取得することです。これにより、2つ以上のプロセスが同時に同じホットジャーナルをロールバックしようとすることを防ぎます。</target>
        </trans-unit>
        <trans-unit id="6d5dce142e8b6c56f2485efc4da630bd41e2b246" translate="yes" xml:space="preserve">
          <source>The first step toward reading from the database file is obtaining a shared lock on the database file. A &quot;shared&quot; lock allows two or more database connections to read from the database file at the same time. But a shared lock prevents another database connection from writing to the database file while we are reading it. This is necessary because if another database connection were writing to the database file at the same time we are reading from the database file, we might read some data before the change and other data after the change. This would make it appear as if the change made by the other process is not atomic.</source>
          <target state="translated">データベースファイルから読み取るための最初のステップは、データベースファイルの共有ロックを取得することです。共有」ロックは、2つ以上のデータベース接続が同時にデータベースファイルから読み出すことを可能にします。しかし、共有ロックは、私たちがデータベースファイルを読み込んでいる間、別のデータベース接続がデータベースファイルに書き込むことを防ぎます。これは、私たちがデータベースファイルから読み込んでいるときに別のデータベース接続がデータベースファイルに書き込んでいた場合、変更前のデータと変更後のデータを読み込んでしまう可能性があるためです。これは、他のプロセスによって行われた変更がアトミックではないかのように見えてしまうからです。</target>
        </trans-unit>
        <trans-unit id="728a2c812c40e366db04b46879d8327a7463b66e" translate="yes" xml:space="preserve">
          <source>The first string or bareword in a column declaration is the column name. It is an error to attempt to name an fts5 table column &quot;rowid&quot; or &quot;rank&quot;, or to assign the same name to a column as is used by the table itself. This is not supported.</source>
          <target state="translated">カラム宣言の最初の文字列またはベアワードはカラム名です。fts5 テーブルのカラムに &quot;rowid&quot; や &quot;rank&quot; という名前を付けようとしたり、テーブル自体が使用しているのと同じ名前をカラムに割り当てるのはエラーです。これはサポートされていません。</target>
        </trans-unit>
        <trans-unit id="15aebb5889bf7eacd8a14d41dd89f37206fa7a06" translate="yes" xml:space="preserve">
          <source>The first subquery above is constant with respect to the outer query. The value for the first subquery can be computed once and then reused for each row of the outer SELECT. The second subquery, however, is &quot;CORRELATED&quot;. The value of the second subquery changes depending on values in the current row of the outer query. Hence, the second subquery must be run once for each output row in the outer SELECT.</source>
          <target state="translated">上記の最初の副問い合わせは、外側の問い合わせに対して一定です。最初の副問い合わせの値は、一度計算され、その後、外側のSELECTの各行に対して再利用することができます。しかし、2番目の副問い合わせは「correlated」です。2番目の副問い合わせの値は、外部クエリの現在の行の値に応じて変化します。したがって、第2の副問い合わせは、外側のSELECTの各出力行に対して1回実行されなければなりません。</target>
        </trans-unit>
        <trans-unit id="c31bdf542d6f05cfa5241d61c80e5148ec82df02" translate="yes" xml:space="preserve">
          <source>The first term stored on each node (&quot;Term 1&quot; in the figure above) is stored verbatim. Each subsequent term is prefix-compressed with respect to its predecessor. Terms are stored within a page in sorted (memcmp) order.</source>
          <target state="translated">各ノードに格納された最初のターム(上図の「ターム1」)は、逐語的に格納される。それ以降の各タームは、その前のタームに対して接頭辞圧縮されます。項は、ページ内でソートされた(memcmp)順序で格納されます。</target>
        </trans-unit>
        <trans-unit id="7a099bb22daac790c8e16aa7a285108628e1197d" translate="yes" xml:space="preserve">
          <source>The first thing that happens is that we open the table being indexed for reading. In order to construct an index for a table, we have to know what is in that table. The index has already been opened for writing using cursor 0 by instructions 3 and 4.</source>
          <target state="translated">最初に起こることは、インデックスが作成されているテーブルを開いて読み込むことです。テーブルのインデックスを構築するためには、そのテーブルに何があるかを知る必要があります。インデックスは、命令3と4によって、カーソル0を使用して書き込み用に既にオープンされています。</target>
        </trans-unit>
        <trans-unit id="5eb1752f78007fa49f66b7f76488ea011879482b" translate="yes" xml:space="preserve">
          <source>The first time that any SQLite process attempts to access the database file, it obtains a shared lock as described in &lt;a href=&quot;https://sqlite.org/section_3_2&quot;&gt;section 3.2&lt;/a&gt; above. But then it notices that there is a rollback journal file present. SQLite then checks to see if the rollback journal is a &quot;hot journal&quot;. A hot journal is a rollback journal that needs to be played back in order to restore the database to a sane state. A hot journal only exists when an earlier process was in the middle of committing a transaction when it crashed or lost power.</source>
          <target state="translated">SQLiteプロセスが最初にデータベースファイルにアクセスしようとすると、&lt;a href=&quot;https://sqlite.org/section_3_2&quot;&gt;セクション3.2で&lt;/a&gt;説明したように、共有ロックが取得されます。しかし、その後、ロールバックジャーナルファイルが存在することがわかります。 SQLiteは、ロールバックジャーナルが「ホットジャーナル」であるかどうかを確認します。ホットジャーナルは、データベースを正常な状態に復元するために再生する必要のあるロールバックジャーナルです。ホットジャーナルが存在するのは、以前のプロセスがトランザクションをクラッシュまたは停電したときに、トランザクションをコミットしている最中だけです。</target>
        </trans-unit>
        <trans-unit id="e68a1d44352d39217814d6bf160a385833864476" translate="yes" xml:space="preserve">
          <source>The first time the sqlite3_aggregate_context(C,N) routine is called for a particular aggregate function, SQLite allocates N bytes of memory, zeroes out that memory, and returns a pointer to the new memory. On second and subsequent calls to sqlite3_aggregate_context() for the same aggregate function instance, the same buffer is returned. Sqlite3_aggregate_context() is normally called once for each invocation of the xStep callback and then one last time when the xFinal callback is invoked. When no rows match an aggregate query, the xStep() callback of the aggregate function implementation is never called and xFinal() is called exactly once. In those cases, sqlite3_aggregate_context() might be called for the first time from within xFinal().</source>
          <target state="translated">sqlite3_aggregate_context(C,N)ルーチンが特定の集約関数に対して初めて呼び出されたとき、SQLiteはNバイトのメモリを確保し、そのメモリをゼロアウトし、新しいメモリへのポインタを返します。同じ集約関数インスタンスに対してsqlite3_aggregate_context()を2回目以降に呼び出すと、同じバッファが返されます。Sqlite3_aggregate_context()は通常、xStepコールバックが呼び出されるたびに一度だけ呼び出され、その後xFinalコールバックが呼び出されたときに最後に一度だけ呼び出されます。集約クエリにマッチする行がない場合、集約関数実装のxStep()コールバックは呼び出されず、xFinal()は一度だけ呼び出されます。このような場合、xFinal()の中から初めてsqlite3_aggregate_context()が呼び出されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="e3a42cd86f3f8e7c9fddbcba13c3c1c638314931" translate="yes" xml:space="preserve">
          <source>The first time the sqlite3_aggregate_context(C,N) routine is called for a particular aggregate function, SQLite allocates N of memory, zeroes out that memory, and returns a pointer to the new memory. On second and subsequent calls to sqlite3_aggregate_context() for the same aggregate function instance, the same buffer is returned. Sqlite3_aggregate_context() is normally called once for each invocation of the xStep callback and then one last time when the xFinal callback is invoked. When no rows match an aggregate query, the xStep() callback of the aggregate function implementation is never called and xFinal() is called exactly once. In those cases, sqlite3_aggregate_context() might be called for the first time from within xFinal().</source>
          <target state="translated">特定の集約関数に対してsqlite3_aggregate_context(C,N)ルーチンが初めて呼び出されたとき、SQLiteはN個のメモリを確保し、そのメモリをゼロアウトし、新しいメモリへのポインタを返します。同じ集約関数インスタンスに対してsqlite3_aggregate_context()を2回目以降に呼び出すと、同じバッファが返されます。Sqlite3_aggregate_context()は通常、xStepコールバックが呼び出されるたびに一度だけ呼び出され、その後xFinalコールバックが呼び出されたときに最後に一度だけ呼び出されます。集約クエリにマッチする行がない場合、集約関数実装のxStep()コールバックは呼び出されず、xFinal()は一度だけ呼び出されます。このような場合、xFinal()の中から初めてsqlite3_aggregate_context()が呼び出されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="33a73e33477151458e48dab8a4d76f2a383719c8" translate="yes" xml:space="preserve">
          <source>The first two constants (SQLITE_MUTEX_FAST and SQLITE_MUTEX_RECURSIVE) cause sqlite3_mutex_alloc() to create a new mutex. The new mutex is recursive when SQLITE_MUTEX_RECURSIVE is used but not necessarily so when SQLITE_MUTEX_FAST is used. The mutex implementation does not need to make a distinction between SQLITE_MUTEX_RECURSIVE and SQLITE_MUTEX_FAST if it does not want to. SQLite will only request a recursive mutex in cases where it really needs one. If a faster non-recursive mutex implementation is available on the host platform, the mutex subsystem might return such a mutex in response to SQLITE_MUTEX_FAST.</source>
          <target state="translated">最初の2つの定数(SQLITE_MUTEX_FASTとSQLITE_MUTEX_RECURSIVE)はsqlite3_mutex_alloc()に新しいミューテックスを生成させます。SQLITE_MUTEX_RECURSIVEが使用されている場合は新しいミューテックスは再帰的ですが、SQLITE_MUTEX_FASTが使用されている場合は必ずしもそうではありません。もし必要なければ、ミューテックスの実装はSQLITE_MUTEX_RECURSIVEとSQLITE_MUTEX_FASTを区別する必要はありません。SQLiteは本当に再帰的なミューテックスが必要な場合にのみ要求します。ホストプラットフォーム上でより高速な非再帰的ミューテックスの実装が利用可能な場合、ミューテックスサブシステムはSQLITE_MUTEX_FASTに応答してそのようなミューテックスを返すかもしれません。</target>
        </trans-unit>
        <trans-unit id="3ad84c4124333660ac2ec2d4b3b96a74793fd127" translate="yes" xml:space="preserve">
          <source>The first two elements in the list above, the associated</source>
          <target state="translated">前記リストの最初の2つの要素、関連する</target>
        </trans-unit>
        <trans-unit id="9de36623b06dcc8a12dabc9fe8d69bf46f2afdab" translate="yes" xml:space="preserve">
          <source>The first two instructions in the VDBE program for our query are concerned with setting up values for &lt;b&gt;azColumn&lt;/b&gt;. The &lt;a href=&quot;opcode#ColumnName&quot;&gt;ColumnName&lt;/a&gt; instructions tell the VDBE what values to fill in for each element of the &lt;b&gt;azColumnName[]&lt;/b&gt; array. Every query will begin with one ColumnName instruction for each column in the result, and there will be a matching Column instruction for each one later in the query.</source>
          <target state="translated">私たちのクエリのVDBEプログラムの最初の2つの命令は、の値を設定すると懸念している&lt;b&gt;azColumn&lt;/b&gt;。&lt;a href=&quot;opcode#ColumnName&quot;&gt;ColumnNameにする&lt;/a&gt;命令は、各要素のために埋めるためにどのような値VDBEを伝える&lt;b&gt;azColumnName []&lt;/b&gt;配列。すべてのクエリは、結果の列ごとに1つのColumnName命令で始まります。クエリの後半では、各列に対応するColumn命令があります。</target>
        </trans-unit>
        <trans-unit id="80f7eaccbd1b0c6d2fde7b56494766bcf2304eb6" translate="yes" xml:space="preserve">
          <source>The first two query examples illustrate a kind of template that every SELECT program will follow. Basically, we have:</source>
          <target state="translated">最初の2つのクエリの例は、すべてのSELECTプログラムが従うテンプレートの一種であることを示しています。基本的には</target>
        </trans-unit>
        <trans-unit id="c636087069b26e9346b965d8bb5b5d8294795344" translate="yes" xml:space="preserve">
          <source>The first value in the array of integer values corresponds to the leftmost column of the table (column 0) and the first phrase in the query (phrase 0). The values corresponding to other column/phrase combinations may be located using the following formula:</source>
          <target state="translated">整数値の配列の最初の値は、テーブルの左端の列(列0)とクエリの最初のフレーズ(フレーズ0)に対応します。他の列/フレーズの組み合わせに対応する値は、次の式を用いて配置することができる。</target>
        </trans-unit>
        <trans-unit id="61029d8449643ad48e743f1026fb94f8a1ed1222" translate="yes" xml:space="preserve">
          <source>The first, or only, integer is the blockid that corresponds to the interior node with the largest blockid that belongs to this segment b-tree. Or zero if the entire segment b-tree fits on the root node. If it exists, this node is always an interior node.</source>
          <target state="translated">最初の、または唯一の整数は、このセグメント b-木に属する最大のブロック ID を持つ内部ノードに対応するブロック ID です。または、セグメント b-tree 全体がルートノードに収まる場合は 0 です。存在する場合、このノードは常に内部ノードです。</target>
        </trans-unit>
        <trans-unit id="c0ebe13b31f8942f70d44d11a35f84a9529666cd" translate="yes" xml:space="preserve">
          <source>The fix in the 3.25.0 release for the endless-loop in the byte-code associated with the ORDER BY LIMIT optimization did not work for some queries involving window functions. An additional correction is required. Ticket &lt;a href=&quot;https://sqlite.org/src/info/510cde277783b5fb&quot;&gt;510cde277783b5fb&lt;/a&gt;</source>
          <target state="translated">3.25.0リリースでの、ORDER BY LIMIT最適化に関連するバイトコードのエンドレスループの修正は、ウィンドウ関数を含む一部のクエリでは機能しませんでした。追加の修正が必要です。チケット&lt;a href=&quot;https://sqlite.org/src/info/510cde277783b5fb&quot;&gt;510cde277783b5fb&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c2032be06ad1313d23c4aa0f2d29e1f73447dfd8" translate="yes" xml:space="preserve">
          <source>The fix to the previous bug uncovered a deadlock which was also fixed.</source>
          <target state="translated">以前のバグの修正でデッドロックが発覚したが、それも修正された。</target>
        </trans-unit>
        <trans-unit id="8197368f601d93edb14a348de0bf212d3c1bcf51" translate="yes" xml:space="preserve">
          <source>The flags argument to xAccess() may be &lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot; id=&quot;sqlite3vfsxaccess&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt; to test for the existence of a file, or &lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt; to test whether a file is readable and writable, or &lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt; to test whether a file is at least readable. The SQLITE_ACCESS_READ flag is never actually used and is not implemented in the built-in VFSes of SQLite. The file is named by the second argument and can be a directory. The xAccess method returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success or some non-zero error code if there is an I/O error or if the name of the file given in the second argument is illegal. If SQLITE_OK is returned, then non-zero or zero is written into *pResOut to indicate whether or not the file is accessible.</source>
          <target state="translated">xAccessにフラグ引数は（）であってもよい&lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot; id=&quot;sqlite3vfsxaccess&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt;ファイルの存在のためのテスト、またはそれに&lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt;ファイルを読み書き可能であるかどうかを試験するために、または&lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt;ファイルは、少なくとも読み取り可能であるかどうかをテストします。 SQLITE_ACCESS_READフラグは実際には使用されず、SQLiteの組み込みVFSには実装されていません。ファイルは2番目の引数によって名前が付けられ、ディレクトリにすることができます。 xAccessメソッドは、I / Oエラーが発生した場合、または2番目の引数で指定されたファイルの名前が不正である場合、成功すると&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;を返すか、ゼロ以外のエラーコードを返します。 SQLITE_OKが返された場合、* pResOutにゼロ以外の値またはゼロが書き込まれ、ファイルにアクセスできるかどうかが示されます。</target>
        </trans-unit>
        <trans-unit id="ee0102cf2398a56ff989592f19a055847f5dc920" translate="yes" xml:space="preserve">
          <source>The flags argument to xAccess() may be &lt;a href=&quot;c_access_exists&quot; id=&quot;sqlite3vfsxaccess&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt; to test for the existence of a file, or &lt;a href=&quot;c_access_exists&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt; to test whether a file is readable and writable, or &lt;a href=&quot;c_access_exists&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt; to test whether a file is at least readable. The SQLITE_ACCESS_READ flag is never actually used and is not implemented in the built-in VFSes of SQLite. The file is named by the second argument and can be a directory. The xAccess method returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success or some non-zero error code if there is an I/O error or if the name of the file given in the second argument is illegal. If SQLITE_OK is returned, then non-zero or zero is written into *pResOut to indicate whether or not the file is accessible.</source>
          <target state="translated">xAccessにフラグ引数は（）であってもよい&lt;a href=&quot;c_access_exists&quot; id=&quot;sqlite3vfsxaccess&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt;ファイルの存在のためのテスト、またはそれに&lt;a href=&quot;c_access_exists&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt;ファイルを読み書き可能であるかどうかを試験するために、または&lt;a href=&quot;c_access_exists&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt;ファイルは、少なくとも読み取り可能であるかどうかをテストします。 SQLITE_ACCESS_READフラグは実際には使用されず、SQLiteの組み込みVFSには実装されていません。ファイルは2番目の引数によって名前が付けられ、ディレクトリにすることができます。 xAccessメソッドは、I / Oエラーが発生した場合、または2番目の引数で指定されたファイルの名前が不正である場合、成功すると&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;を返すか、ゼロ以外のエラーコードを返します。 SQLITE_OKが返された場合、* pResOutにゼロ以外の値またはゼロが書き込まれ、ファイルにアクセスできるかどうかが示されます。</target>
        </trans-unit>
        <trans-unit id="d9f0c284ad1c57f7e5da616991af768f686e341f" translate="yes" xml:space="preserve">
          <source>The flags argument to xOpen() includes all bits set in the flags argument to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. Or if &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt; is used, then flags includes at least &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;. If xOpen() opens a file read-only then it sets *pOutFlags to include &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;. Other bits in *pOutFlags may be set.</source>
          <target state="translated">XOPENにflags引数（）へのflags引数に設定されたすべてのビットを含む&lt;a href=&quot;#sqlite3_open&quot;&gt;）（sqlite3_open_v2&lt;/a&gt;。または、&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;または&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16（）&lt;/a&gt;が使用されている場合、フラグには少なくとも&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; |が含まれます。&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;。 xOpen（）がファイルを読み取り専用で開くと、SQLITE_OPEN_READONLYを含めるように* pOutFlagsが設定され&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;ます&lt;/a&gt;。 * pOutFlagsの他のビットが設定される場合があります。</target>
        </trans-unit>
        <trans-unit id="f5198d48ad55972f3bafe448a5f83115c01462b7" translate="yes" xml:space="preserve">
          <source>The flags argument to xOpen() includes all bits set in the flags argument to &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. Or if &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt; or &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt; is used, then flags includes at least &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;. If xOpen() opens a file read-only then it sets *pOutFlags to include &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;. Other bits in *pOutFlags may be set.</source>
          <target state="translated">XOPENにflags引数（）へのflags引数に設定されたすべてのビットを含む&lt;a href=&quot;open&quot;&gt;）（sqlite3_open_v2&lt;/a&gt;。または、&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;または&lt;a href=&quot;open&quot;&gt;sqlite3_open16（）&lt;/a&gt;が使用されている場合、フラグには少なくとも&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; |が含まれます。&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;。 xOpen（）がファイルを読み取り専用で開くと、SQLITE_OPEN_READONLYを含めるように* pOutFlagsが設定され&lt;a href=&quot;c_open_autoproxy&quot;&gt;ます&lt;/a&gt;。 * pOutFlagsの他のビットが設定される場合があります。</target>
        </trans-unit>
        <trans-unit id="7bc004618637404d4a4bd35b24cc91bd411a3086" translate="yes" xml:space="preserve">
          <source>The flags argument to xSync may be one of &lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt; or &lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt;. The first choice is the normal fsync(). The second choice is a Mac OS X style fullsync. The &lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_DATAONLY&lt;/a&gt; flag may be ORed in to indicate that only the data of the file and not its inode needs to be synced.</source>
          <target state="translated">xSyncのflags引数は、&lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt;または&lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt;のいずれかです。最初の選択は通常のfsync（）です。2番目の選択肢は、Mac OS Xスタイルの完全同期です。&lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_DATAONLY&lt;/a&gt;フラグをORして、ファイルのデータのみを同期し、そのiノードを同期する必要がないことを示すことができます。</target>
        </trans-unit>
        <trans-unit id="99d3aea2b8c0b18767851d7c8d3921e4603f6ed1" translate="yes" xml:space="preserve">
          <source>The flags argument to xSync may be one of &lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt; or &lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt;. The first choice is the normal fsync(). The second choice is a Mac OS X style fullsync. The &lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_DATAONLY&lt;/a&gt; flag may be ORed in to indicate that only the data of the file and not its inode needs to be synced.</source>
          <target state="translated">xSyncのflags引数は、&lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt;または&lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt;のいずれかです。最初の選択は通常のfsync（）です。2番目の選択肢は、Mac OS Xスタイルの完全同期です。&lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_DATAONLY&lt;/a&gt;フラグをORして、ファイルのデータのみを同期し、そのiノードを同期する必要がないことを示すことができます。</target>
        </trans-unit>
        <trans-unit id="c377d5a3884469a39150e12bd3af49c973f2fad1" translate="yes" xml:space="preserve">
          <source>The floating-point to text conversion subfunction for the built-in printf() is limited in precision to 16 significant digits or 26 significant digits if the &quot;!&quot; alternate-form-2 flag is used. Every IEEE-754 double can be represented exactly as a decimal floating-point value, but some doubles require more than 16 or 26 significant digits.</source>
          <target state="translated">組み込みのprintf()の浮動小数点からテキストへの変換サブ関数の精度は、&quot;!&quot; alternate-form-2フラグが使用されている場合、16桁の有効数字、または26桁の有効数字に制限されています。IEEE-754のすべてのダブルは10進浮動小数点値として正確に表現することができますが、一部のダブルは16桁または26桁以上の有効数字を必要とします。</target>
        </trans-unit>
        <trans-unit id="68fce5c170ab1896511f13fd3e82f411098f2695" translate="yes" xml:space="preserve">
          <source>The folder returned by the GetTempPath() system interface.</source>
          <target state="translated">GetTempPath()システムインターフェイスが返すフォルダ。</target>
        </trans-unit>
        <trans-unit id="4f48bdf9b1dfd94aea260fd19b610d7cf9d72be5" translate="yes" xml:space="preserve">
          <source>The folder set by &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA temp_store_directory&lt;/a&gt; or by the &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA temp_store_directory&lt;/a&gt;または&lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;グローバル変数によって設定されたフォルダー</target>
        </trans-unit>
        <trans-unit id="8f393fa7f5f393cd220ff4a7a6a7ccbac66e5676" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://xkcd.com/1597/&quot;&gt;https://xkcd.com/1597/&lt;/a&gt; cartoon is an exaggeration, yet hits close to home:</source>
          <target state="translated">次の&lt;a href=&quot;https://xkcd.com/1597/&quot;&gt;https://xkcd.com/1597/&lt;/a&gt;漫画は誇張ですが、家の近くにヒットします。</target>
        </trans-unit>
        <trans-unit id="40de557d79eeab5be4528c0beef95dcb1a5f7ef4" translate="yes" xml:space="preserve">
          <source>The following RBU database schema may be used:</source>
          <target state="translated">以下のRBUデータベーススキーマを使用することができる。</target>
        </trans-unit>
        <trans-unit id="ae49ebf9365c52bbf37afc8c396e0cba8b2d31d3" translate="yes" xml:space="preserve">
          <source>The following SQL demonstrates how SQLite uses column affinity to do type conversions when values are inserted into a table.</source>
          <target state="translated">次の SQL は、SQLite がカラムアフィニティを使用して、テーブルに値が挿入されたときに型変換を行う方法を示しています。</target>
        </trans-unit>
        <trans-unit id="b7479fafb0c600f993e6250d871980ae79cbdf35" translate="yes" xml:space="preserve">
          <source>The following SQLite command-line session illustrates the effect of the foreign key constraint added to the</source>
          <target state="translated">次の SQLite コマンドラインセッションは、外部キー制約が</target>
        </trans-unit>
        <trans-unit id="1f8a8aec572c42d81f9a9d30dc36ba0c1a7ca331" translate="yes" xml:space="preserve">
          <source>The following additional compile-time options are recommended in order to provide a full-featured command-line shell:</source>
          <target state="translated">フル機能のコマンドラインシェルを提供するために、以下の追加のコンパイル時オプションを推奨します。</target>
        </trans-unit>
        <trans-unit id="e661fc6daecc53fc88e2038803ed3bcb13092e93" translate="yes" xml:space="preserve">
          <source>The following additional syntax restrictions apply to UPDATE statements that occur within the body of a &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement.</source>
          <target state="translated">以下の追加の構文制限が、&lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;ステートメントの本体内で発生するUPDATEステートメントに適用されます。</target>
        </trans-unit>
        <trans-unit id="0a78308c3e0962720a3b6c6b2c92b551ac030e31" translate="yes" xml:space="preserve">
          <source>The following are allowed values for 6th argument (the F argument) to the &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize(D,S,P,N,M,F)&lt;/a&gt; interface.</source>
          <target state="translated">以下は、&lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize（D、S、P、N、M、F）&lt;/a&gt;インターフェイスの6番目の引数（F引数）に許可される値です。</target>
        </trans-unit>
        <trans-unit id="b9076a86669fb7bce220c5cc2398686ebb071016" translate="yes" xml:space="preserve">
          <source>The following are allowed values for 6th argument (the F argument) to the &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize(D,S,P,N,M,F)&lt;/a&gt; interface.</source>
          <target state="translated">以下は、&lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize（D、S、P、N、M、F）&lt;/a&gt;インターフェイスの6番目の引数（F引数）に許可される値です。</target>
        </trans-unit>
        <trans-unit id="a59459d6632d0bbc1149f827b602fb3d835358c8" translate="yes" xml:space="preserve">
          <source>The following are examples of disabling the built-in protection mechanisms of SQLite:</source>
          <target state="translated">以下は、SQLite の組み込みの保護機構を無効にする例です。</target>
        </trans-unit>
        <trans-unit id="80d00e742a47603d638009e13703b23c42a0d91f" translate="yes" xml:space="preserve">
          <source>The following are other VFS implementations available in the public SQLite source tree:</source>
          <target state="translated">公開されているSQLiteのソースツリーで利用可能な他のVFS実装は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="ec123026fdd8e1c2278a5f9715d6939ab0dbeb46" translate="yes" xml:space="preserve">
          <source>The following are the available OMIT options:</source>
          <target state="translated">OMITオプションは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="8fa3cecc90ff41687bc039d2f339ed203679e422" translate="yes" xml:space="preserve">
          <source>The following block contains a summary of the FTS query syntax in BNF form. A detailed explanation follows.</source>
          <target state="translated">以下のブロックには、BNF 形式の FTS クエリ構文の概要が含まれています。詳細な説明は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="9eacb2386777a09c397574d603b9f7b4a178b7c8" translate="yes" xml:space="preserve">
          <source>The following block contains an example of calling the fts3_tokenizer() function from C code:</source>
          <target state="translated">以下のブロックには、Cコードからfts3_tokenizer()関数を呼び出す例が含まれています。</target>
        </trans-unit>
        <trans-unit id="8a513f3e74d7cb1dc9f72503b5eb2053d246b6ad" translate="yes" xml:space="preserve">
          <source>The following block contains examples that use the offsets function.</source>
          <target state="translated">以下のブロックには、オフセット関数を使用する例が含まれています。</target>
        </trans-unit>
        <trans-unit id="5c334635414a3c37311f7280f25331d2da05c0d0" translate="yes" xml:space="preserve">
          <source>The following chart shows the substitution types supported by SQLite:</source>
          <target state="translated">次の表は、SQLite でサポートされている置換タイプを示しています。</target>
        </trans-unit>
        <trans-unit id="16f175b629dac9ff34c51ebace5610e8bb2a6ee9" translate="yes" xml:space="preserve">
          <source>The following compile-time options are recommended for applications that are able to use them, in order to minimized the number of CPU cycles and the bytes of memory used by SQLite. Not all of these compile-time options are usable by every application. For example, the SQLITE_THREADSAFE=0 option is only usable by applications that never access SQLite from more than one thread at a time. And the SQLITE_OMIT_PROGRESS_CALLBACK option is only usable by applications that do not use the &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler()&lt;/a&gt; interface. And so forth.</source>
          <target state="translated">以下のコンパイル時オプションは、SQLiteが使用するCPUサイクル数とメモリのバイト数を最小限に抑えるために、それらを使用できるアプリケーションに推奨されます。これらのコンパイル時オプションのすべてがすべてのアプリケーションで使用できるわけではありません。たとえば、SQLITE_THREADSAFE = 0オプションは、一度に複数のスレッドからSQLiteにアクセスすることのないアプリケーションでのみ使用できます。また、SQLITE_OMIT_PROGRESS_CALLBACKオプションは、&lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler（）&lt;/a&gt;インターフェイスを使用しないアプリケーションでのみ使用できます。などなど。</target>
        </trans-unit>
        <trans-unit id="c06c8d896e801657db8f70d5a5bd2960e6843e64" translate="yes" xml:space="preserve">
          <source>The following compile-time options are recommended for applications that are able to use them, in order to minimized the number of CPU cycles and the bytes of memory used by SQLite. Not all of these compile-time options are usable by every application. For example, the SQLITE_THREADSAFE=0 option is only usable by applications that never access SQLite from more than one thread at a time. And the SQLITE_OMIT_PROGRESS_CALLBACK option is only usable by applications that doe not use the &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler()&lt;/a&gt; interface. And so forth.</source>
          <target state="translated">SQLiteが使用するCPUサイクル数とメモリのバイト数を最小限に抑えるために、それらを使用できるアプリケーションには、次のコンパイル時オプションをお勧めします。これらのコンパイル時オプションのすべてがすべてのアプリケーションで使用できるわけではありません。たとえば、SQLITE_THREADSAFE = 0オプションは、一度に複数のスレッドからSQLiteにアクセスすることのないアプリケーションでのみ使用できます。また、SQLITE_OMIT_PROGRESS_CALLBACKオプションは、&lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler（）&lt;/a&gt;インターフェースを使用しないアプリケーションでのみ使用できます。などなど。</target>
        </trans-unit>
        <trans-unit id="1f053eef3c13d51d862b4f23cc04af6f84e75626" translate="yes" xml:space="preserve">
          <source>The following constants can be used for the T parameter to the &lt;a href=&quot;#sqlite3_stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus(S,X,T,V)&lt;/a&gt; interface. Each constant designates a different metric for sqlite3_stmt_scanstatus() to return.</source>
          <target state="translated">次の定数は、&lt;a href=&quot;#sqlite3_stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus（S、X、T、V）&lt;/a&gt;インターフェイスのTパラメータに使用できます。各定数は、sqlite3_stmt_scanstatus（）が返す異なるメトリックを指定します。</target>
        </trans-unit>
        <trans-unit id="42e5a30e943fe484b45c04468e002affa80c1a88" translate="yes" xml:space="preserve">
          <source>The following constants can be used for the T parameter to the &lt;a href=&quot;stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus(S,X,T,V)&lt;/a&gt; interface. Each constant designates a different metric for sqlite3_stmt_scanstatus() to return.</source>
          <target state="translated">次の定数は、&lt;a href=&quot;stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus（S、X、T、V）&lt;/a&gt;インターフェイスのTパラメータに使用できます。各定数は、sqlite3_stmt_scanstatus（）が返す異なるメトリックを指定します。</target>
        </trans-unit>
        <trans-unit id="0dd0f222abc9f123e613d4dc8f011601915507ab" translate="yes" xml:space="preserve">
          <source>The following diagram depicts the format of a segment b-tree interior (non-leaf) node.</source>
          <target state="translated">次の図は、セグメント b-tree 内側(非リーフ)ノードの形式を示しています。</target>
        </trans-unit>
        <trans-unit id="24519f5efb1b482cdcbf663c45ec684bda267ab2" translate="yes" xml:space="preserve">
          <source>The following diagram depicts the format of a segment b-tree leaf node.</source>
          <target state="translated">次の図は、セグメント b-tree リーフ・ノードの形式を示しています。</target>
        </trans-unit>
        <trans-unit id="d2d809dec5a64a655b9636ca71424601eda3c8d0" translate="yes" xml:space="preserve">
          <source>The following example code illustrates the techniques described above.</source>
          <target state="translated">以下の例示的なコードは、上述した技術を説明するものである。</target>
        </trans-unit>
        <trans-unit id="54bdf2a30ded538a716ed8a4baee084a78f8a312" translate="yes" xml:space="preserve">
          <source>The following example creates a new SQL function named &quot;hex&quot; that converts its numeric argument in to a hexadecimal encoded string:</source>
          <target state="translated">次の例では、数値引数を16進数でエンコードされた文字列に変換する、&quot;hex &quot;という名前の新しいSQL関数を作成しています。</target>
        </trans-unit>
        <trans-unit id="9d4eb7545f22068db9db1145bb2583cae1439f33" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the effect of the various forms of the EXCLUDE clause:</source>
          <target state="translated">次の例は、EXCLUDE 節のさまざまな形式の効果を示しています。</target>
        </trans-unit>
        <trans-unit id="3fb64142e08ab04e58bc3d16cc93b9564bb653f2" translate="yes" xml:space="preserve">
          <source>The following example illustrates precedence of operators using the standard query syntax:</source>
          <target state="translated">次の例は、標準のクエリ構文を使用した演算子の優先順位を示しています。</target>
        </trans-unit>
        <trans-unit id="33e08656a40dfd68bcb2d6194c63e1be80dcd4d4" translate="yes" xml:space="preserve">
          <source>The following example illustrates the above. The expressions &quot;docs&quot;, &quot;docs.docs&quot; and &quot;main.docs.docs&quot; all refer to column &quot;docs&quot;. However, the expression &quot;main.docs&quot; does not refer to any column. It could be used to refer to a table, but a table name is not allowed in the context in which it is used below.</source>
          <target state="translated">以下の例では、上記のことを説明しています。表現「docs」、「docs.docs」、「main.docs.docs」は、いずれもカラム「docs」を参照している。しかし、「main.docs」という表現は、どのカラムも参照していません。テーブルを参照するために使用することはできますが、以下のような文脈ではテーブル名を使用することはできません。</target>
        </trans-unit>
        <trans-unit id="6318f87943b573664a21e50213cf281e74663a27" translate="yes" xml:space="preserve">
          <source>The following example illustrates the behaviour of the five ranking functions - row_number(), rank(), dense_rank(), percent_rank() and cume_dist().</source>
          <target state="translated">以下の例は、5つのランキング関数、row_number()、rank()、dense_rank()、percent_rank()、cume_dist()の挙動を示しています。</target>
        </trans-unit>
        <trans-unit id="fd2f5de221e0f758d71eb8931f8c7e719ace6200" translate="yes" xml:space="preserve">
          <source>The following example illustrates the effect of using a deferred foreign key constraint.</source>
          <target state="translated">以下の例は、遅延された外部キー制約を使用した場合の効果を示しています。</target>
        </trans-unit>
        <trans-unit id="21740a6dff76788fbc521cbbbedbec453f6795d5" translate="yes" xml:space="preserve">
          <source>The following example uses the sumint() function implemented by the above C code. For each row, the window consists of the preceding row (if any), the current row and the following row (again, if any):</source>
          <target state="translated">以下の例では、上記の C コードで実装された sumint()関数を使用しています。各行について、ウィンドウは前の行(もしあれば)、現在の行、そして次の行(もしあればまた)から構成されています。</target>
        </trans-unit>
        <trans-unit id="9b577d330901567bab085337ea84d2a43135e876" translate="yes" xml:space="preserve">
          <source>The following example will better illustrate the use of SQLITE_CONSTRAINT as a return value from xBestIndex:</source>
          <target state="translated">次の例は、xBestIndex の戻り値として SQLITE_CONSTRAINT を使用することをよりよく説明しています。</target>
        </trans-unit>
        <trans-unit id="3f5880fbaaf652f0861c35b2ed9bf834e8800e30" translate="yes" xml:space="preserve">
          <source>The following flags may passed via the 4th parameter to &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2&lt;/a&gt; and &lt;a href=&quot;#sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_start_v2_strm&lt;/a&gt;:</source>
          <target state="translated">次のフラグは、4番目のパラメーターを介して&lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2&lt;/a&gt;と&lt;a href=&quot;#sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_start_v2_strm&lt;/a&gt;に渡すことができます：</target>
        </trans-unit>
        <trans-unit id="dcb818ec6ae695589b5e698d66cbb55415f5689e" translate="yes" xml:space="preserve">
          <source>The following flags may passed via the 4th parameter to &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2&lt;/a&gt; and &lt;a href=&quot;sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_start_v2_strm&lt;/a&gt;:</source>
          <target state="translated">次のフラグは、4番目のパラメーターを介して&lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2&lt;/a&gt;と&lt;a href=&quot;sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_start_v2_strm&lt;/a&gt;に渡すことができます：</target>
        </trans-unit>
        <trans-unit id="eaf06e6487557d77e67f76618b64eb4b39aae85e" translate="yes" xml:space="preserve">
          <source>The following flags may passed via the 9th parameter to &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply_v2&lt;/a&gt; and &lt;a href=&quot;#sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_apply_v2_strm&lt;/a&gt;:</source>
          <target state="translated">次のフラグは、9番目のパラメーターを介して&lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply_v2&lt;/a&gt;と&lt;a href=&quot;#sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_apply_v2_strm&lt;/a&gt;に渡すことができます：</target>
        </trans-unit>
        <trans-unit id="8acfd72cc7dc7df0be4ef94764fa15b5b7e0e403" translate="yes" xml:space="preserve">
          <source>The following flags may passed via the 9th parameter to &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply_v2&lt;/a&gt; and &lt;a href=&quot;sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_apply_v2_strm&lt;/a&gt;:</source>
          <target state="translated">次のフラグは、9番目のパラメーターを介して&lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply_v2&lt;/a&gt;と&lt;a href=&quot;sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_apply_v2_strm&lt;/a&gt;に渡すことができます：</target>
        </trans-unit>
        <trans-unit id="90a5abe74323cb727451a1fc89d79f6674e34a04" translate="yes" xml:space="preserve">
          <source>The following four configuration changes are recommended for maximum application security. Turning off the trust_schema setting prevents virtual tables and dodgy SQL functions from being used inside of triggers, views, CHECK constraints, generated columns, and expression indexes. Turning off the dqs_dml and dqs_ddl settings prevents the use of double-quoted strings. Turning on defensive prevents direct writes to shadow tables.</source>
          <target state="translated">アプリケーションのセキュリティを最大化するために、以下の4つの構成変更を推奨します。trust_schema設定をオフにすると、仮想テーブルや不正なSQL関数がトリガー、ビュー、CHECK制約、生成されたカラム、式インデックスの内部で使用されるのを防ぐことができます。dqs_dmlおよびdqs_ddlの設定をオフにすると、二重引用符で囲まれた文字列の使用を防ぐことができます。defensive をオンにすると、シャドウ・テーブルへの直接書き込みができなくなります。</target>
        </trans-unit>
        <trans-unit id="f88559c5309089b2c53eff7ab551567dc8265aad" translate="yes" xml:space="preserve">
          <source>The following functions can be used to advance and query a changeset iterator created by this function:</source>
          <target state="translated">以下の関数を使用して、この関数によって作成されたチェンジセットイテレータを進めたり、問い合わせたりすることができます。</target>
        </trans-unit>
        <trans-unit id="35f53ac017499b71e5f28f348a1b347ee5939139" translate="yes" xml:space="preserve">
          <source>The following is a log of all SQL used to generate one particular timeline (captured on 2016-09-16):</source>
          <target state="translated">以下は、ある特定のタイムラインを生成するために使用されたすべてのSQLのログです(2016-09-16にキャプチャされています)。</target>
        </trans-unit>
        <trans-unit id="8ca654574638bb42c5b323e2fbbcf528a1c97560" translate="yes" xml:space="preserve">
          <source>The following is a partial list of the kinds of messages that might appear in the error logger callback.</source>
          <target state="translated">以下に、エラー・ロガー・コールバックで表示されるメッセージの種類の一部を示します。</target>
        </trans-unit>
        <trans-unit id="91f9f5074c39cae7458cb274b5e2472dd1f18791" translate="yes" xml:space="preserve">
          <source>The following is a random assortment of techniques used by the SQLite developers to trace, examine, and understand the behavior of the core SQLite library.</source>
          <target state="translated">以下は、SQLite 開発者がコア SQLite ライブラリの動作をトレース、調査、理解するために使用したテクニックのランダムな詰め合わせです。</target>
        </trans-unit>
        <trans-unit id="172b7cc8402676bd9591f1901c350fe56e3b1a3a" translate="yes" xml:space="preserve">
          <source>The following is sqlite3_analyzer output for an example places.sqlite database used by Firefox.</source>
          <target state="translated">以下は、Firefoxで使用されている例のplace.sqliteデータベースのsqlite3_analyzerの出力です。</target>
        </trans-unit>
        <trans-unit id="3b9bb38ec5e22c57b0f7c289494707329a29a947" translate="yes" xml:space="preserve">
          <source>The following limitations apply to RBU updates:</source>
          <target state="translated">RBUのアップデートには、以下の制限が適用されます。</target>
        </trans-unit>
        <trans-unit id="fc2fda4c09167d54864b95b318f076cb56ce31c3" translate="yes" xml:space="preserve">
          <source>The following macros specify interface linkage for certain kinds of SQLite builds. The Makefiles will normally handle setting these macros automatically. Application developers should not need to worry with these macros. The following documentation about these macros is included completeness.</source>
          <target state="translated">以下のマクロは、特定の種類の SQLite ビルドのためのインターフェイス連携を指定します。通常、Makefile はこれらのマクロを自動的に設定します。アプリケーション開発者はこれらのマクロを気にする必要はありません。これらのマクロに関する以下のドキュメントが含まれています。</target>
        </trans-unit>
        <trans-unit id="e520cf121083171350ce54bdc25d9fb94f2ae9df" translate="yes" xml:space="preserve">
          <source>The following must be true for this function to succeed. If any of the following statements are false when sqlite3_snapshot_get() is called, SQLITE_ERROR is returned. The final value of *P is undefined in this case.</source>
          <target state="translated">この関数が成功するためには、以下の記述が真でなければなりません。sqlite3_snapshot_get()が呼び出されたときに以下の文のいずれかがfalseの場合、SQLITE_ERRORが返されます。この場合、*Pの最終値は未定義です。</target>
        </trans-unit>
        <trans-unit id="13b4c313c53ce999997969a2a1da623479829206" translate="yes" xml:space="preserve">
          <source>The following options can be used to &lt;a href=&quot;footprint&quot;&gt;reduce the size of the compiled library&lt;/a&gt; by omitting unused features. This is probably only useful in embedded systems where space is especially tight, as even with all features included the SQLite library is relatively small. Don't forget to tell your compiler to optimize for binary size! (the -Os option if using GCC). Telling your compiler to optimize for size usually has a much larger impact on library footprint than employing any of these compile-time options. You should also verify that &lt;a href=&quot;#debugoptions&quot;&gt;debugging options&lt;/a&gt; are disabled.</source>
          <target state="translated">次のオプションを使用する&lt;a href=&quot;footprint&quot;&gt;と、&lt;/a&gt;未使用の機能を省略して、コンパイル済みライブラリのサイズを削減できます。SQLiteライブラリが含まれているすべての機能が比較的小さいため、これはおそらくスペースが特に狭い組み込みシステムでのみ役立ちます。バイナリサイズを最適化するようコンパイラーに指示することを忘れないでください！（GCCを使用する場合の-Osオプション）。通常、サイズを最適化するようコンパイラーに指示すると、これらのコンパイル時オプションを使用するよりも、ライブラリーのフットプリントにはるかに大きな影響があります。また、&lt;a href=&quot;#debugoptions&quot;&gt;デバッグオプション&lt;/a&gt;が無効になっていることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="aa7c844b688230c89a2857560379c0f551e0b077" translate="yes" xml:space="preserve">
          <source>The following query computes an approximation of the Mandelbrot Set and outputs the result as ASCII-art:</source>
          <target state="translated">以下のクエリは、マンデルブロ集合の近似を計算し、結果をASCII-artとして出力します。</target>
        </trans-unit>
        <trans-unit id="165c7c17f77322908874e60dfb0fb76218a06202" translate="yes" xml:space="preserve">
          <source>The following query parameters are recognized by SQLite as of &lt;a href=&quot;https://sqlite.org/releaselog/3_15_0.html&quot;&gt;version 3.15.0&lt;/a&gt; (2016-10-14). New query parameters might be added in the future.</source>
          <target state="translated">次のクエリパラメータは、&lt;a href=&quot;https://sqlite.org/releaselog/3_15_0.html&quot;&gt;バージョン3.15.0&lt;/a&gt;（2016-10-14）以降、SQLiteによって認識されます。新しいクエリパラメータは将来追加される可能性があります。</target>
        </trans-unit>
        <trans-unit id="482aaeeca1acb6ff828caa9e341d537cef50e256" translate="yes" xml:space="preserve">
          <source>The following query returns all integers between 1 and 1000000:</source>
          <target state="translated">以下のクエリは、1から1000000までのすべての整数を返します。</target>
        </trans-unit>
        <trans-unit id="df61dccd4718a46758145386ef91e3af7a125626" translate="yes" xml:space="preserve">
          <source>The following requirements describe step 1 of the above procedure in more detail.</source>
          <target state="translated">以下の要件では、上記手順のステップ1をより詳細に説明します。</target>
        </trans-unit>
        <trans-unit id="c7e0a9c1d2e39a35866f813a7b58e616f8a0dfa1" translate="yes" xml:space="preserve">
          <source>The following requirements describe step 2 of the above procedure in more detail.</source>
          <target state="translated">以下の要件では、上記手順のステップ2をより詳細に説明します。</target>
        </trans-unit>
        <trans-unit id="ab60a1fc45053970e49cb2236072b7574ce682f2" translate="yes" xml:space="preserve">
          <source>The following requirements describe step 3 of the above procedure in more detail.</source>
          <target state="translated">以下の要件では、上記手順のステップ3をより詳細に説明する。</target>
        </trans-unit>
        <trans-unit id="0f5ce0f453d6b71b276dab07b31a916fac2ad143" translate="yes" xml:space="preserve">
          <source>The following requirements describe step 4 of the above procedure in more detail.</source>
          <target state="translated">以下の要件では、上記手順のステップ4をより詳細に説明する。</target>
        </trans-unit>
        <trans-unit id="ff1604c4fd7473773943aa62c8883c18d8179ef1" translate="yes" xml:space="preserve">
          <source>The following requirements describe the steps enumerated above in more detail.</source>
          <target state="translated">以下の要件では、上記で列挙したステップをより詳細に説明します。</target>
        </trans-unit>
        <trans-unit id="ca6589a3a75bae1a771049671e8297b9c43f424f" translate="yes" xml:space="preserve">
          <source>The following restrictions apply to DELETE statements that occur within the body of a &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement:</source>
          <target state="translated">&lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;ステートメントの本体内で発生するDELETEステートメントには、次の制限が適用されます。</target>
        </trans-unit>
        <trans-unit id="1404887613e3d3d478c15bfa20064138fe1f758d" translate="yes" xml:space="preserve">
          <source>The following routines are used to implement user-defined collating sequences:</source>
          <target state="translated">以下のルーチンを使用して、ユーザー定義の照合シーケンスを実装します。</target>
        </trans-unit>
        <trans-unit id="9d61d2cb84c2da7119bdaa99ad1c2d7a32c4afe9" translate="yes" xml:space="preserve">
          <source>The following rules and caveats apply to the values specified as part of each INSERT statement:</source>
          <target state="translated">各INSERT文の一部として指定された値には、以下のルールと注意事項が適用されます。</target>
        </trans-unit>
        <trans-unit id="a26a29856749163d9eb4f80a667633bb87f813e9" translate="yes" xml:space="preserve">
          <source>The following rules show how each of the locks is used.</source>
          <target state="translated">以下のルールでは、それぞれのロックがどのように使用されているかを示しています。</target>
        </trans-unit>
        <trans-unit id="737ea9fa3e70c97a0a7b4c9228ebcdc9127f52cb" translate="yes" xml:space="preserve">
          <source>The following scenario illustrates how an SQLITE_BUSY_SNAPSHOT error might arise:</source>
          <target state="translated">次のシナリオは、SQLITE_BUSY_SNAPSHOT エラーがどのように発生するかを示しています。</target>
        </trans-unit>
        <trans-unit id="4840312a4c02316c9bb1b228254597da9db65628" translate="yes" xml:space="preserve">
          <source>The following script was used to gather information for the table above.</source>
          <target state="translated">上記の表の情報収集には、以下のスクリプトを使用しました。</target>
        </trans-unit>
        <trans-unit id="5f95a6062676138baa336da2cd5b1ec87382d19c" translate="yes" xml:space="preserve">
          <source>The following section describes the API offered to auxiliary function implementations in detail. Further examples may be found in the &quot;fts5_aux.c&quot; file of the source code.</source>
          <target state="translated">以下のセクションでは、補助関数の実装に提供されるAPIについて詳しく説明します。さらなる例は、ソースコードの &quot;fts5_aux.c &quot;ファイルにあります。</target>
        </trans-unit>
        <trans-unit id="c91d01efc0ba3649e7eacbf59f700342ec3a53a5" translate="yes" xml:space="preserve">
          <source>The following sections describe some low-level details of the R*Tree implementation, that might be useful for trouble-shooting or performance analysis.</source>
          <target state="translated">以下のセクションでは、トラブルシューティングやパフォーマンス解析に役立つかもしれないR*Treeの実装の低レベルの詳細について説明します。</target>
        </trans-unit>
        <trans-unit id="17e43452198f5289d975fb07abeb874782ed48a0" translate="yes" xml:space="preserve">
          <source>The following sections describe the supported parameters. Specifying an unrecognized parameter name is an error.</source>
          <target state="translated">以下のセクションでは、サポートされているパラメータについて説明します。認識できないパラメータ名を指定するとエラーとなります。</target>
        </trans-unit>
        <trans-unit id="009cc36fd7239429da331a5197a208b717cdb22a" translate="yes" xml:space="preserve">
          <source>The following sections provide additional detail on the operation of the various functions that are part of the json1 extension.</source>
          <target state="translated">以下のセクションでは、json1 拡張機能の一部である様々な関数の操作についての詳細を説明します。</target>
        </trans-unit>
        <trans-unit id="0b996a91eae66dcc3a2860511963eb7fa7efc7eb" translate="yes" xml:space="preserve">
          <source>The following syntax documentation topics are available:</source>
          <target state="translated">以下の構文ドキュメントのトピックがあります。</target>
        </trans-unit>
        <trans-unit id="0e5fa08cf1724f31556de517effc85351bb377ec" translate="yes" xml:space="preserve">
          <source>The following table shows how many common datatype names from more traditional SQL implementations are converted into affinities by the five rules of the previous section. This table shows only a small subset of the datatype names that SQLite will accept. Note that numeric arguments in parentheses that following the type name (ex: &quot;VARCHAR(255)&quot;) are ignored by SQLite - SQLite does not impose any length restrictions (other than the large global &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; limit) on the length of strings, BLOBs or numeric values.</source>
          <target state="translated">次の表は、より多くの従来のSQL実装からの一般的なデータ型名が、前のセクションの5つのルールによって類似性に変換される数を示しています。この表は、SQLiteが受け入れるデータ型名の小さなサブセットのみを示しています。型名に続く括弧内の数値引数（例： &quot;VARCHAR（255）&quot;）はSQLiteによって無視されることに注意してください&lt;a href=&quot;limits#max_length&quot;&gt;-SQLite&lt;/a&gt;は、文字列、BLOB、または長さに長さ制限（大きなグローバルSQLITE_MAX_LENGTH制限を除く）を課しません。数値。</target>
        </trans-unit>
        <trans-unit id="54c0ab33937bb3d0205754132a184edc97ac8f8b" translate="yes" xml:space="preserve">
          <source>The following table shows the meanings of the (non-hidden) columns of DBSTAT in both normal and aggregated mode:</source>
          <target state="translated">以下の表は、通常モードと集計モードの両方でのDBSTATの(非隠蔽)カラムの意味を示しています。</target>
        </trans-unit>
        <trans-unit id="54feeefe0d9e52f7880c035de3af5b0398710d6a" translate="yes" xml:space="preserve">
          <source>The following table shows the results of the NULL handling experiments.</source>
          <target state="translated">以下の表は、NULLハンドリングの実験結果を示しています。</target>
        </trans-unit>
        <trans-unit id="12e0a00ef75b703780c84d1074e0287b2f403501" translate="yes" xml:space="preserve">
          <source>The following table summarizes the SQLite file format changes that have occurred since version 1.0.0:</source>
          <target state="translated">以下の表は、バージョン 1.0.0 以降に発生した SQLite ファイル形式の変更点をまとめたものです。</target>
        </trans-unit>
        <trans-unit id="ea82e2bbe8fed4a7a8a0361c062cdbf2a7cb2e1f" translate="yes" xml:space="preserve">
          <source>The following two objects and eight methods comprise the essential elements of the SQLite interface:</source>
          <target state="translated">以下の 2 つのオブジェクトと 8 つのメソッドは、SQLite インターフェイスの重要な要素を構成しています。</target>
        </trans-unit>
        <trans-unit id="1b3057a8ce2692f0addf4973e487586ba5e334ab" translate="yes" xml:space="preserve">
          <source>The foregoing is all one really needs to know in order to use SQLite effectively. All the rest is optimization and detail.</source>
          <target state="translated">上記は、SQLiteを効果的に使用するために本当に必要な知識のすべてです。あとは最適化と詳細な情報だけです。</target>
        </trans-unit>
        <trans-unit id="75a22928178fbb3c0cbb048a8ad2cc0d5b3170b7" translate="yes" xml:space="preserve">
          <source>The foregoing text describes low-level aspects of the SQLite file format. The b-tree mechanism provides a powerful and efficient means of accessing a large data set. This section will describe how the low-level b-tree layer is used to implement higher-level SQL capabilities.</source>
          <target state="translated">前述のテキストでは、SQLite ファイル形式の低レベルな側面について説明しています。b-treeメカニズムは、大規模なデータセットにアクセスするための強力で効率的な手段を提供します。このセクションでは、低レベルのb-tree層がどのようにして高レベルのSQL機能を実装するために使用されるかを説明します。</target>
        </trans-unit>
        <trans-unit id="12199f4a726aab3fb6304db80ece6cf69a955319" translate="yes" xml:space="preserve">
          <source>The foreign key constraint is satisfied if for each row in the child table either one or more of the child key columns are NULL, or there exists a row in the parent table for which each parent key column contains a value equal to the value in its associated child key column.</source>
          <target state="translated">外部キー制約は、子テーブルの各行について、1つ以上の子キー列のいずれかがNULLであるか、または親テーブルの各親キー列が、関連する子キー列の値と等しい値を含む行が存在する場合に満たされます。</target>
        </trans-unit>
        <trans-unit id="7eb5b173b9130668a2a0b17e4f207640eaa017f0" translate="yes" xml:space="preserve">
          <source>The foreign key constraints created as part of tables</source>
          <target state="translated">テーブルの一部として作成された外部キー制約</target>
        </trans-unit>
        <trans-unit id="add6cc21a0d1ec9f3c982acde6cc5dc3f05465f0" translate="yes" xml:space="preserve">
          <source>The foreign_key_check pragma checks the database, or the table called &quot;</source>
          <target state="translated">foreign_key_checkプラグマはデータベース、または&quot;</target>
        </trans-unit>
        <trans-unit id="9efc16f15cca4547a2a6b1e6f0aea092764cfc35" translate="yes" xml:space="preserve">
          <source>The formalized assumptions in this section refer to</source>
          <target state="translated">このセクションでの形式化された前提条件は、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="fe9496c466bbe179ee18ac47ed69a346233c9cbd" translate="yes" xml:space="preserve">
          <source>The format for sqlite_stat2 is recorded here for legacy reference. Recent versions of SQLite no longer support sqlite_stat2 and the sqlite_stat2 table, if is exists, is simply ignored.</source>
          <target state="translated">sqlite_stat2のフォーマットは、レガシー参照のためにここに記録されています。最近のバージョンのSQLiteはもはやsqlite_stat2をサポートしておらず、もしsqlite_stat2テーブルが存在する場合は単純に無視されます。</target>
        </trans-unit>
        <trans-unit id="d2a469c667d3464f2b4b57e3f59fb88c3da53ff2" translate="yes" xml:space="preserve">
          <source>The format of a cell depends on which kind of b-tree page the cell appears on. The following table shows the elements of a cell, in order of appearance, for the various b-tree page types.</source>
          <target state="translated">セルの書式は、そのセルがどの種類の b-tree ページに表示されるかによって異なります。以下の表は、さまざまな種類の b-tree ページに対して、セルの要素を外観順に示しています。</target>
        </trans-unit>
        <trans-unit id="8f6ebed1965bbd7f7af8c4c0949451b7c054d06f" translate="yes" xml:space="preserve">
          <source>The format of the arguments to the module is very general. Each module-argument may contain keywords, string literals, identifiers, numbers, and punctuation. Each module-argument is passed as written (as text) into the &lt;a href=&quot;vtab#xcreate&quot;&gt;constructor method&lt;/a&gt; of the virtual table implementation when the virtual table is created and that constructor is responsible for parsing and interpreting the arguments. The argument syntax is sufficiently general that a virtual table implementation can, if it wants to, interpret its arguments as &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;column definitions&lt;/a&gt; in an ordinary &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. The implementation could also impose some other interpretation on the arguments.</source>
          <target state="translated">モジュールへの引数の形式は非常に一般的です。各モジュール引数には、キーワード、文字列リテラル、識別子、数字、句読点を含めることができます。各モジュール引数は、仮想テーブルが作成され、引数の解析と解釈を担当するコンストラクターの場合、書き込まれたとおりに（テキストとして）仮想テーブル実装の&lt;a href=&quot;vtab#xcreate&quot;&gt;コンストラクターメソッド&lt;/a&gt;に渡されます。引数の構文は十分に一般的であり、仮想テーブルの実装では、必要に応じて、その引数を通常の&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;ステートメントの&lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;列定義&lt;/a&gt;として解釈できます。実装は、引数に他の解釈を課すこともできます。</target>
        </trans-unit>
        <trans-unit id="ce6813c51545b0e36cbda5b5ae9abe31c78f2212" translate="yes" xml:space="preserve">
          <source>The format of the main database file is as described in the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; document. The &lt;a href=&quot;fileformat2#vnums&quot;&gt;file format version numbers&lt;/a&gt; at offsets 18 and 19 into the main database must both be 2 to indicate that the database is in WAL mode. The main database may have an arbitrary name allowed by the underlying filesystem. No special file suffixes are required, though &quot;.db&quot;, &quot;.sqlite&quot;, and &quot;.sqlite3&quot; seem to be popular choices.</source>
          <target state="translated">メインデータベース&lt;a href=&quot;fileformat2&quot;&gt;ファイルの形式&lt;/a&gt;は、ファイル形式のドキュメントに記載されています。&lt;a href=&quot;fileformat2#vnums&quot;&gt;ファイル形式のバージョン番号&lt;/a&gt;オフセット18とメインデータベースに19においては、両方のデータベースはWALモードにあることを示すために2でなければなりません。メインデータベースには、基礎となるファイルシステムで許可されている任意の名前を付けることができます。 「.db」、「。sqlite」、「。sqlite3」が一般的な選択肢のようですが、特別なファイルサフィックスは必要ありません。</target>
        </trans-unit>
        <trans-unit id="c748249cfa33fdfdfb8560eb0a7a2d06c6a7130e" translate="yes" xml:space="preserve">
          <source>The format string for printf() is a template for the generated string. Substitutions are made whenever a &quot;%&quot; character appears in the format string. The &quot;%&quot; is followed by one or more additional characters that describe the substitution. Each substitution has the following format:</source>
          <target state="translated">printf()の書式文字列は、生成された文字列のテンプレートです。フォーマット文字列の中に&quot;%&quot;が現れるたびに、置換が行われます。この&quot;%&quot;の後には、置換を説明する1つ以上の文字が続きます。各置換は以下の形式になります。</target>
        </trans-unit>
        <trans-unit id="e5481902d614e43b8906fc140d4dc2a9c7914623" translate="yes" xml:space="preserve">
          <source>The format used by SQLite database files has been completely revised. The old version 2.1 format and the new 3.0 format are incompatible with one another. Version 2.8 of SQLite will not read a version 3.0 database files and version 3.0 of SQLite will not read a version 2.8 database file.</source>
          <target state="translated">SQLiteデータベースファイルが使用するフォーマットが全面的に見直されました。旧バージョン2.1のフォーマットと新バージョン3.0のフォーマットは互いに互換性がありません。SQLiteのバージョン2.8ではバージョン3.0のデータベースファイルは読み込まれず、SQLiteのバージョン3.0ではバージョン2.8のデータベースファイルは読み込まれません。</target>
        </trans-unit>
        <trans-unit id="a376c207dbbf638ec2db0cb626e4c46931a236b1" translate="yes" xml:space="preserve">
          <source>The fossil delta format may only be used to update BLOB values. Instead of storing the new BLOB within the data_% table, the fossil delta is stored instead. And instead of specifying an 'x' as part of the rbu_control string for the column to be updated, an 'f' character is stored. When processing an 'f' update, RBU loads the original BLOB data from disk, applies the fossil delta to it and stores the results back into the database file. The RBU databases generated by &lt;a href=&quot;rbu#sqldiff&quot;&gt;sqldiff --rbu&lt;/a&gt; make use of fossil deltas wherever doing so would save space in the RBU database.</source>
          <target state="translated">化石デルタ形式は、BLOB値の更新にのみ使用できます。 data_％テーブル内に新しいBLOBを保存する代わりに、化石デルタが代わりに保存されます。そして、更新される列のrbu_control文字列の一部として「x」を指定する代わりに、「f」文字が格納されます。 'f'更新を処理するとき、RBUは元のBLOBデータをディスクからロードし、化石デルタをそれに適用し、結果をデータベースファイルに保存します。&lt;a href=&quot;rbu#sqldiff&quot;&gt;sqldiff --rbu&lt;/a&gt;によって生成されたRBUデータベースは、RBUデータベースのスペースを節約する場所で化石デルタを利用します。</target>
        </trans-unit>
        <trans-unit id="23a39933682f9054d9fbfd81554ffb9e23300f95" translate="yes" xml:space="preserve">
          <source>The founder of SQLite and all current developers have pledged to follow spirit of The Rule to the best of their ability. They view The Rule as their promise to all SQLite users of how the developers are expected to behave in community. This is a one-way promise, or covenant. In other words, the developers are saying: &quot;We will treat you this way regardless of how you treat us.&quot;</source>
          <target state="translated">SQLite の創設者と現在の開発者は、The Rule の精神にできる限り従うことを誓っています。彼らはThe Ruleを、開発者がコミュニティでどのように振る舞うことを期待されているかという、すべてのSQLiteユーザーとの約束だと考えています。これは一方通行の約束、または誓約です。言い換えれば、開発者はこう言っているのです。&quot;あなたが私たちをどう扱うかに関わらず、私たちはあなたをこのように扱います。</target>
        </trans-unit>
        <trans-unit id="fac57078ba906f356fde5d5be039fc86e66f550e" translate="yes" xml:space="preserve">
          <source>The founder of SQLite, and all of the current developers at the time when this document was composed, have pledged to govern their interactions with each other, with their clients, and with the larger SQLite user community in accordance with the &quot;instruments of good works&quot; from chapter 4 of &lt;a href=&quot;https://en.wikipedia.org/wiki/Rule_of_Saint_Benedict&quot;&gt;The Rule of St. Benedict&lt;/a&gt; (hereafter: &quot;The Rule&quot;). This code of ethics has proven its mettle in thousands of diverse communities for over 1,500 years, and has served as a baseline for many civil law codes since the time of Charlemagne.</source>
          <target state="translated">SQLiteの創設者、およびこのドキュメントが作成された当時のすべての現在の開発者は、「優れた作品の計器」に従って、相互の、クライアントとの、およびより大きなSQLiteユーザーコミュニティとの相互作用を管理することを誓約しています。 「&lt;a href=&quot;https://en.wikipedia.org/wiki/Rule_of_Saint_Benedict&quot;&gt;聖ベネディクトの支配の&lt;/a&gt;第4章から（以下：「支配」）。この倫理規定は、1500年以上にわたり、何千もの多様なコミュニティでその能力を証明しており、シャルルマーニュの時代以来、多くの民法典典のベースラインとしての役割を果たしてきました。</target>
        </trans-unit>
        <trans-unit id="555d8586503882b041c2a8a309c2f9e999580160" translate="yes" xml:space="preserve">
          <source>The four utility functions</source>
          <target state="translated">4つの効用関数</target>
        </trans-unit>
        <trans-unit id="6cfb5a37e3c4d212e2442aae712218c04b105dd5" translate="yes" xml:space="preserve">
          <source>The four-byte page number at offset 8 is the right-most pointer. This value appears in the header of interior b-tree pages only and is omitted from all other pages.</source>
          <target state="translated">オフセット 8 の 4 バイトページ番号は、右端のポインタである。この値は、内部のb-treeページのヘッダにのみ現れ、それ以外のページからは省略される。</target>
        </trans-unit>
        <trans-unit id="76f618a5029c6002ebdae975ee6043d888618d19" translate="yes" xml:space="preserve">
          <source>The fourth argument (xFilter) passed to these functions is the &quot;filter callback&quot;. If it is not NULL, then for each table affected by at least one change in the changeset, the filter callback is invoked with the table name as the second argument, and a copy of the context pointer passed as the sixth argument as the first. If the &quot;filter callback&quot; returns zero, then no attempt is made to apply any changes to the table. Otherwise, if the return value is non-zero or the xFilter argument to is NULL, all changes related to the table are attempted.</source>
          <target state="translated">これらの関数に渡される第4引数(xFilter)は、&quot;フィルタコールバック &quot;です。これがNULLでない場合、チェンジセットの少なくとも一つの変更によって影響を受ける各テーブルに対して、第二引数にテーブル名を、第六引数にコンテキストポインタのコピーを第一引数として、フィルタコールバックが呼び出されます。もし &quot;filter callback &quot;が0を返した場合、テーブルに変更を適用しようとはしません。そうでなければ、戻り値がゼロでない場合、あるいは xFilter の引数が NULL の場合は、テーブルに関連するすべての変更が試みられます。</target>
        </trans-unit>
        <trans-unit id="999f04c49ef94f8766fa9cb6bb9bbba18afe2ece" translate="yes" xml:space="preserve">
          <source>The fourth argument, pArg, is an application data pointer that is passed through as the first argument to the collating function callback.</source>
          <target state="translated">第4引数のpArgは、照合関数コールバックの第1引数として渡されるアプリケーションデータポインタです。</target>
        </trans-unit>
        <trans-unit id="c6b1934196a189db01281779b0c51a4b66faf522" translate="yes" xml:space="preserve">
          <source>The fourth column is the maximum value of any rowid in the table.</source>
          <target state="translated">第4列は、テーブル内の任意のrowidの最大値です。</target>
        </trans-unit>
        <trans-unit id="69cc3b7ae5b0c474135cb2e440fa03951919eaf0" translate="yes" xml:space="preserve">
          <source>The fourth parameter may also optionally include the &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag, which if present prevents the function from being invoked from within VIEWs or TRIGGERs. For security reasons, the &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag is recommended for any application-defined SQL function that has side-effects.</source>
          <target state="translated">4番目のパラメーターには、オプションで&lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;フラグを含めることもできます。このフラグがあると、VIEWまたはTRIGGER内から関数を呼び出すことができなくなります。セキュリティ上の理由から、副作用のあるアプリケーション定義のSQL関数には&lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;フラグをお勧めします。</target>
        </trans-unit>
        <trans-unit id="c1fbaaa3083276ec5194db2d1a793d5691751026" translate="yes" xml:space="preserve">
          <source>The fourth parameter may also optionally include the &lt;a href=&quot;#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag, which if present prevents the function from being invoked from within VIEWs, TRIGGERs, CHECK constraints, generated column expressions, index expressions, or the WHERE clause of partial indexes.</source>
          <target state="translated">4番目のパラメーターには、オプションで&lt;a href=&quot;#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;フラグを含めることもできます。このフラグが存在する場合、関数がVIEW、TRIGGER、CHECK制約、生成された列式、インデックス式、または部分インデックスのWHERE句内から呼び出されるのを防ぎます。</target>
        </trans-unit>
        <trans-unit id="f52c4099bf56a2a098b10ec045515f7e30e89130" translate="yes" xml:space="preserve">
          <source>The fourth parameter may also optionally include the &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag, which if present prevents the function from being invoked from within VIEWs or TRIGGERs. For security reasons, the &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag is recommended for any application-defined SQL function that has side-effects.</source>
          <target state="translated">4番目のパラメーターには、オプションで&lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;フラグを含めることもできます。このフラグがあると、VIEWまたはTRIGGER内から関数を呼び出すことができなくなります。セキュリティ上の理由から、副作用のあるアプリケーション定義のSQL関数には&lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;フラグをお勧めします。</target>
        </trans-unit>
        <trans-unit id="67ad2195f1817b78a8b4837501855037b255117b" translate="yes" xml:space="preserve">
          <source>The fourth parameter may also optionally include the &lt;a href=&quot;c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag, which if present prevents the function from being invoked from within VIEWs, TRIGGERs, CHECK constraints, generated column expressions, index expressions, or the WHERE clause of partial indexes.</source>
          <target state="translated">4番目のパラメーターには、オプションで&lt;a href=&quot;c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;フラグを含めることもできます。このフラグが存在する場合、関数がVIEW、TRIGGER、CHECK制約、生成された列式、インデックス式、または部分インデックスのWHERE句内から呼び出されるのを防ぎます。</target>
        </trans-unit>
        <trans-unit id="649add83c8043b4bf2ea6e4b6cf49a7fdf941dff" translate="yes" xml:space="preserve">
          <source>The fourth parameter may optionally be ORed with &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; to signal that the function will always return the same result given the same inputs within a single SQL statement. Most SQL functions are deterministic. The built-in &lt;a href=&quot;lang_corefunc#random&quot;&gt;random()&lt;/a&gt; SQL function is an example of a function that is not deterministic. The SQLite query planner is able to perform additional optimizations on deterministic functions, so use of the &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is recommended where possible.</source>
          <target state="translated">4番目のパラメーターは、オプションで&lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;とORして、単一のSQLステートメント内で同じ入力が与えられた場合、関数が常に同じ結果を返すことを通知できます。ほとんどのSQL関数は確定的です。組み込みの&lt;a href=&quot;lang_corefunc#random&quot;&gt;random（）&lt;/a&gt; SQL関数は、決定論的ではない関数の例です。 SQLiteクエリプランナーは確定的関数に対して追加の最適化を実行できるため、可能な場合は&lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;フラグの使用をお勧めします。</target>
        </trans-unit>
        <trans-unit id="6481c8ccbbe2254925779028e6672b2de9b23312" translate="yes" xml:space="preserve">
          <source>The fourth parameter may optionally be ORed with &lt;a href=&quot;#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; to signal that the function will always return the same result given the same inputs within a single SQL statement. Most SQL functions are deterministic. The built-in &lt;a href=&quot;lang_corefunc#random&quot;&gt;random()&lt;/a&gt; SQL function is an example of a function that is not deterministic. The SQLite query planner is able to perform additional optimizations on deterministic functions, so use of the &lt;a href=&quot;#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is recommended where possible.</source>
          <target state="translated">4番目のパラメーターはオプションで&lt;a href=&quot;#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;とOR演算して、単一のSQLステートメント内で同じ入力が与えられた場合に関数が常に同じ結果を返すことを通知できます。ほとんどのSQL関数は決定論的です。組み込みの&lt;a href=&quot;lang_corefunc#random&quot;&gt;random（）&lt;/a&gt; SQL関数は、決定論的ではない関数の例です。SQLiteクエリプランナーは決定論的関数に対して追加の最適化を実行できるため、可能な場合は&lt;a href=&quot;#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;フラグを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="658cc43bdf2652e8cf4b2cffdcf6459b264f185d" translate="yes" xml:space="preserve">
          <source>The fourth parameter may optionally be ORed with &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; to signal that the function will always return the same result given the same inputs within a single SQL statement. Most SQL functions are deterministic. The built-in &lt;a href=&quot;../lang_corefunc#random&quot;&gt;random()&lt;/a&gt; SQL function is an example of a function that is not deterministic. The SQLite query planner is able to perform additional optimizations on deterministic functions, so use of the &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is recommended where possible.</source>
          <target state="translated">4番目のパラメーターは、オプションで&lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;とORして、単一のSQLステートメント内で同じ入力が与えられた場合、関数が常に同じ結果を返すことを通知できます。ほとんどのSQL関数は確定的です。組み込みの&lt;a href=&quot;../lang_corefunc#random&quot;&gt;random（）&lt;/a&gt; SQL関数は、決定論的ではない関数の例です。 SQLiteクエリプランナーは確定的関数に対して追加の最適化を実行できるため、可能な場合は&lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;フラグの使用をお勧めします。</target>
        </trans-unit>
        <trans-unit id="7980c4f3a8ec7ae6d00b95c7cb68067b43db4da9" translate="yes" xml:space="preserve">
          <source>The fourth parameter may optionally be ORed with &lt;a href=&quot;c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; to signal that the function will always return the same result given the same inputs within a single SQL statement. Most SQL functions are deterministic. The built-in &lt;a href=&quot;../lang_corefunc#random&quot;&gt;random()&lt;/a&gt; SQL function is an example of a function that is not deterministic. The SQLite query planner is able to perform additional optimizations on deterministic functions, so use of the &lt;a href=&quot;c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is recommended where possible.</source>
          <target state="translated">4番目のパラメーターはオプションで&lt;a href=&quot;c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;とOR演算して、単一のSQLステートメント内で同じ入力が与えられた場合に関数が常に同じ結果を返すことを通知できます。ほとんどのSQL関数は決定論的です。組み込みの&lt;a href=&quot;../lang_corefunc#random&quot;&gt;random（）&lt;/a&gt; SQL関数は、決定論的ではない関数の例です。SQLiteクエリプランナーは決定論的関数に対して追加の最適化を実行できるため、可能な場合は&lt;a href=&quot;c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;フラグを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="feefd1b9ff1b8c4a1a74b3c8f0c879ca3de261f9" translate="yes" xml:space="preserve">
          <source>The fourth parameter to sqlite3_open_v2() is the name of the &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object that defines the operating system interface that the new database connection should use. If the fourth parameter is a NULL pointer then the default &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object is used.</source>
          <target state="translated">sqlite3_open_v2（）の4番目のパラメーターは、新しいデータベース接続が使用するオペレーティングシステムインターフェースを定義する&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトの名前です。 4番目のパラメーターがNULLポインターの場合、デフォルトの&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトが使用されます。</target>
        </trans-unit>
        <trans-unit id="b7bbbda582299a1f3186b36dde756d304b0fa7e6" translate="yes" xml:space="preserve">
          <source>The fourth parameter to sqlite3_open_v2() is the name of the &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object that defines the operating system interface that the new database connection should use. If the fourth parameter is a NULL pointer then the default &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object is used.</source>
          <target state="translated">sqlite3_open_v2（）の4番目のパラメーターは、新しいデータベース接続が使用するオペレーティングシステムインターフェースを定義する&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトの名前です。 4番目のパラメーターがNULLポインターの場合、デフォルトの&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトが使用されます。</target>
        </trans-unit>
        <trans-unit id="d063d165e08786a1b7ee913cfa396d1655f4a730" translate="yes" xml:space="preserve">
          <source>The fourth parameter, eTextRep, specifies what &lt;a href=&quot;#SQLITE_ANY&quot;&gt;text encoding&lt;/a&gt; this SQL function prefers for its parameters. The application should set this parameter to &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; if the function implementation invokes &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16le()&lt;/a&gt; on an input, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; if the implementation invokes &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16be()&lt;/a&gt; on an input, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt; if &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt; is used, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt; otherwise. The same SQL function may be registered multiple times using different preferred text encodings, with different implementations for each encoding. When multiple implementations of the same function are available, SQLite will pick the one that involves the least amount of data conversion.</source>
          <target state="translated">4番目のパラメーターeTextRepは、このSQL関数がそのパラメーターにどの&lt;a href=&quot;#SQLITE_ANY&quot;&gt;テキストエンコードを&lt;/a&gt;優先するかを指定します。アプリケーションにこのパラメータを設定する必要があり&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;機能実現呼び出すがあれば&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;（sqlite3_value_text16le）&lt;/a&gt;入力に、または&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;実装呼び出すがあれば&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;（sqlite3_value_text16be）&lt;/a&gt;入力に、または&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;場合&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16）は、（&lt;/a&gt;使用されるか、または&lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;さもないと。同じSQL関数が、異なる優先テキストエンコーディングを使用して複数回登録され、エンコーディングごとに実装が異なる場合があります。同じ関数の複数の実装が利用可能な場合、SQLiteは、データ変換が最も少ない実装を選択します。</target>
        </trans-unit>
        <trans-unit id="57c66b621bee32c598b5cb9d09e4c1e1ae3f09dc" translate="yes" xml:space="preserve">
          <source>The fourth parameter, eTextRep, specifies what &lt;a href=&quot;c_any&quot;&gt;text encoding&lt;/a&gt; this SQL function prefers for its parameters. The application should set this parameter to &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; if the function implementation invokes &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16le()&lt;/a&gt; on an input, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; if the implementation invokes &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16be()&lt;/a&gt; on an input, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt; if &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt; is used, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt; otherwise. The same SQL function may be registered multiple times using different preferred text encodings, with different implementations for each encoding. When multiple implementations of the same function are available, SQLite will pick the one that involves the least amount of data conversion.</source>
          <target state="translated">4番目のパラメーターeTextRepは、このSQL関数がそのパラメーターにどの&lt;a href=&quot;c_any&quot;&gt;テキストエンコードを&lt;/a&gt;優先するかを指定します。アプリケーションにこのパラメータを設定する必要があり&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;機能実現呼び出すがあれば&lt;a href=&quot;value_blob&quot;&gt;（sqlite3_value_text16le）&lt;/a&gt;入力に、または&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;実装呼び出すがあれば&lt;a href=&quot;value_blob&quot;&gt;（sqlite3_value_text16be）&lt;/a&gt;入力に、または&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;場合&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16）は、（&lt;/a&gt;使用されるか、または&lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;さもないと。同じSQL関数が、異なる優先テキストエンコーディングを使用して複数回登録され、エンコーディングごとに実装が異なる場合があります。同じ関数の複数の実装が利用可能な場合、SQLiteは、データ変換が最も少ない実装を選択します。</target>
        </trans-unit>
        <trans-unit id="cdeeaf74a0034cfafd692646911468eeef688545" translate="yes" xml:space="preserve">
          <source>The fragment is optional. If present, it is ignored.</source>
          <target state="translated">フラグメントはオプションです。存在する場合は無視されます。</target>
        </trans-unit>
        <trans-unit id="36f14f55d888327ce43d396d69903a3ff7fd8e07" translate="yes" xml:space="preserve">
          <source>The frame boundary is the first row in the &lt;a href=&quot;windowfunctions#ptxn&quot;&gt;partition&lt;/a&gt;.</source>
          <target state="translated">フレーム境界は、&lt;a href=&quot;windowfunctions#ptxn&quot;&gt;パーティションの&lt;/a&gt;最初の行です。</target>
        </trans-unit>
        <trans-unit id="3a03f5ecd3e39afb46315f6d23c888ecf09dac7b" translate="yes" xml:space="preserve">
          <source>The frame boundary is the last row in the &lt;a href=&quot;windowfunctions#ptxn&quot;&gt;partition&lt;/a&gt;.</source>
          <target state="translated">フレーム境界は、&lt;a href=&quot;windowfunctions#ptxn&quot;&gt;パーティションの&lt;/a&gt;最後の行です。</target>
        </trans-unit>
        <trans-unit id="d8ad39ba6054748efcf881cf5f3cfd24dafacebd" translate="yes" xml:space="preserve">
          <source>The frame-spec determines which output rows are read by an aggregate window function. The frame-spec consists of four parts:</source>
          <target state="translated">フレーム仕様は、集約ウィンドウ関数によって読み込まれる出力行を決定します。フレーム仕様は4つの部分から構成されています。</target>
        </trans-unit>
        <trans-unit id="8eb0b0542bfd6ed405e2b53c332150eda864217a" translate="yes" xml:space="preserve">
          <source>The freelist is organized as a linked list of freelist trunk pages with each trunk page containing page numbers for zero or more freelist leaf pages.</source>
          <target state="translated">フリーリストは、フリーリストのトランクページのリンクされたリストとして組織されており、各トランクページにはゼロ以上のフリーリストのリーフページのページ番号が含まれています。</target>
        </trans-unit>
        <trans-unit id="4faa37aa2595b1d3bc75280cd8996cd072597ac3" translate="yes" xml:space="preserve">
          <source>The fts3tokenize virtual table can be used on any tokenizer, regardless of whether or not there exists an FTS3 or FTS4 table that actually uses that tokenizer.</source>
          <target state="translated">fts3tokenize 仮想テーブルは、実際にそのトークナイザーを使用している FTS3 や FTS4 テーブルが存在するかどうかにかかわらず、任意のトークナイザーで使用できます。</target>
        </trans-unit>
        <trans-unit id="346445abda1b7582bb76e9ab2cc48bb753bf4d95" translate="yes" xml:space="preserve">
          <source>The fts5 unicode61 tokenizer is byte-for-byte compatible with the fts3/4 unicode61 tokenizer.</source>
          <target state="translated">fts5 unicode61トークナイザーは、fts3/4 unicode61トークナイザーとバイト単位で互換性があります。</target>
        </trans-unit>
        <trans-unit id="78675caf2de7d160a88a0d764272d7a44454db10" translate="yes" xml:space="preserve">
          <source>The fts5_api structure is defined as follows. It exposes three methods, one each for registering new auxiliary functions and tokenizers, and one for retrieving existing tokenizer. The latter is intended to facilitate the implementation of &quot;tokenizer wrappers&quot; similar to the built-in porter tokenizer.</source>
          <target state="translated">fts5_api構造体は以下のように定義されています。これは3つのメソッドを公開しており、それぞれ1つは新しい補助関数とトークンサイザを登録するためのもの、もう1つは既存のトークンサイザを取得するためのものです。後者は、組み込みのPORTERトークナイザーに似た「トークナイザーラッパー」の実装を容易にすることを目的としています。</target>
        </trans-unit>
        <trans-unit id="162ffee085d8569c08bb1ab9fff2a388996d64c4" translate="yes" xml:space="preserve">
          <source>The fts5_api structure methods are described individually in the following sections.</source>
          <target state="translated">fts5_api構造体のメソッドについては、以下のセクションで個別に説明します。</target>
        </trans-unit>
        <trans-unit id="10c372ee6826e322ad4396357787688e82cce472" translate="yes" xml:space="preserve">
          <source>The fts5vocab virtual table module allows users to extract information from an FTS5 full-text index directly. The fts5vocab module is a part of FTS5 - it is available whenever FTS5 is.</source>
          <target state="translated">fts5vocab仮想テーブルモジュールは、ユーザーがFTS5のフルテキストインデックスから直接情報を抽出することを可能にします。fts5vocabモジュールはFTS5の一部です。</target>
        </trans-unit>
        <trans-unit id="7f3f12f1d0cab297fd4ff2f20d0ccb7ef0778aa5" translate="yes" xml:space="preserve">
          <source>The full pathname of the database file is now remembered even if a relative path is passed into sqlite_open(). This allows the library to continue operating correctly after a chdir().</source>
          <target state="translated">sqlite_open()に相対パスが渡された場合でも、データベースファイルのフルパス名が記憶されるようになりました。これにより、chdir()の後でもライブラリを正しく動作させることができるようになりました。</target>
        </trans-unit>
        <trans-unit id="3b9a46ef2b67e207b1134faeedabd205f3bd8481" translate="yes" xml:space="preserve">
          <source>The full syntax for specifying foreign key constraints is available as part of the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; documentation. Replacing the phrase above with any of the following creates an immediate foreign key constraint.</source>
          <target state="translated">外部キー制約を指定するための完全な構文は、&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;ドキュメントの一部として利用できます。上記のフレーズを次のいずれかに置き換えると、すぐに外部キー制約が作成されます。</target>
        </trans-unit>
        <trans-unit id="976d387f058fd1530001e6bc24b270372cb7f6ff" translate="yes" xml:space="preserve">
          <source>The full-text index maintained by FTS5 is stored as a series of fixed-size blobs in a database table. It is not strictly necessary for all blobs that make up a full-text index to be the same size. The pgsz option determines the size of all blobs created by subsequent index writers. The default value is 1000.</source>
          <target state="translated">FTS5によって維持されるフルテキストインデックスは、データベーステーブル内の固定サイズの一連のブロブとして格納される。フルテキストインデックスを構成するすべてのブロブが同じサイズであることは厳密には必要ではありません。pgsz オプシ ョ ンは、 後続の イ ンデ ッ ク ス作成者が作成す る すべてのブロブのサ イ ズ を決定 し ます。デフォルト値は1000です。</target>
        </trans-unit>
        <trans-unit id="7d7917f6db9701130aeed21c2478cad3cdfc0903" translate="yes" xml:space="preserve">
          <source>The function name is specified in UTF-8. A separate sqlite3_create_function16() API works the same as sqlite_create_function() except that the function name is specified in UTF-16 host byte order.</source>
          <target state="translated">関数名はUTF-8で指定されます。別のsqlite3_create_function16()APIはsqlite_create_function()と同じように動作しますが、関数名がUTF-16ホストバイト順で指定されていることが異なります。</target>
        </trans-unit>
        <trans-unit id="026205ed147556f48d88752d5a21eccbd2a64b48" translate="yes" xml:space="preserve">
          <source>The function pointer returned by this routine must be valid for the lifetime of the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; object given in the first parameter.</source>
          <target state="translated">このルーチンによって返される関数ポインターは、最初のパラメーターで指定された&lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt;オブジェクトの存続期間中有効でなければなりません。</target>
        </trans-unit>
        <trans-unit id="d5578e17f6c531f672841ef155dfdacbfa341e5d" translate="yes" xml:space="preserve">
          <source>The function presented in the previous example copies the entire source database in one call to &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt;. This requires holding a read-lock on the source database file for the duration of the operation, preventing any other database user from writing to the database. It also holds the mutex associated with database pInMemory throughout the copy, preventing any other thread from using it. The C function in this section, designed to be called by a background thread or process for creating a backup of an online database, avoids these problems using the following approach:</source>
          <target state="translated">前の例で示した関数は、&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step（）&lt;/a&gt;への1回の呼び出しでソースデータベース全体をコピーします。これには、操作中にソースデータベースファイルの読み取りロックを保持し、他のデータベースユーザーがデータベースに書き込むのを防ぐ必要があります。また、コピー全体にわたってデータベースpInMemoryに関連付けられたミューテックスを保持し、他のスレッドがそれを使用できないようにします。このセクションのC関数は、オンラインデータベースのバックアップを作成するためのバックグラウンドスレッドまたはプロセスによって呼び出されるように設計されており、次のアプローチを使用してこれらの問題を回避します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
