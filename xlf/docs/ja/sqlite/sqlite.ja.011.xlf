<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="cc11826689203b888f22525a7551a5472c324526" translate="yes" xml:space="preserve">
          <source>OVER</source>
          <target state="translated">OVER</target>
        </trans-unit>
        <trans-unit id="829a2c0005fc7d37eb660c0d5cde206b5192f790" translate="yes" xml:space="preserve">
          <source>Obey in all things the commands of those whom God has placed in authority over you even though they (which God forbid) should act otherwise, mindful of the Lord's precept, &quot;Do what they say, but not what they do.&quot;</source>
          <target state="translated">たとえ彼らが(神が禁じている)他の行動をとることがあっても、「彼らが言うことをして、彼らがすることをしてはならない」という主の戒めに注意して、神があなたの上に権威を置かれた人の命令にすべてのことで従いなさい。</target>
        </trans-unit>
        <trans-unit id="a21a5206c75e38db5a2f38df79e6283758ee658a" translate="yes" xml:space="preserve">
          <source>Object-Oriented Design</source>
          <target state="translated">オブジェクト指向設計</target>
        </trans-unit>
        <trans-unit id="898a9f4f224c827df0fb00ecec65822c23a3936e" translate="yes" xml:space="preserve">
          <source>Object-Oriented is a design pattern, not a programming language. You can do object-oriented programming in any language you want, including assembly language. Some languages (ex: C++ or Java) make object-oriented easier. But you can still do object-oriented programming in languages like C.</source>
          <target state="translated">オブジェクト指向はデザインパターンであって、プログラミング言語ではありません。アセンブリ言語を含め、どんな言語でもオブジェクト指向プログラミングを行うことができます。いくつかの言語(例:C++やJava)はオブジェクト指向をより簡単にしています。しかし、C言語のような言語でもオブジェクト指向プログラミングはできます。</target>
        </trans-unit>
        <trans-unit id="1e6159d8c90870c6430155592639731dac8033a3" translate="yes" xml:space="preserve">
          <source>Object-oriented is not the only valid design pattern. Many programmers have been taught to think purely in terms of objects. And, to be fair, objects are often a good way to decompose a problem. But objects are not the only way, and are not always the best way to decompose a problem. Sometimes good old procedural code is easier to write, easier to maintain and understand, and faster than object-oriented code.</source>
          <target state="translated">オブジェクト指向だけが有効な設計パターンではありません。多くのプログラマは、純粋にオブジェクトの観点から考えるように教えられてきました。そして、確かに、オブジェクトは問題を分解するのに良い方法であることが多い。しかし、オブジェクトは唯一の方法ではありませんし、問題を分解する最良の方法とは限りません。古き良き手続き的なコードの方が、オブジェクト指向のコードよりも書きやすく、メンテナンスや理解が容易で、高速であることもあります。</target>
        </trans-unit>
        <trans-unit id="ea838bb1557d80ce2bdbf51816fc7a1525503976" translate="yes" xml:space="preserve">
          <source>Objects:</source>
          <target state="translated">Objects:</target>
        </trans-unit>
        <trans-unit id="3a36347e6c9b66b32ae45cd886e8708db38d062b" translate="yes" xml:space="preserve">
          <source>Obscure bug fix on triggers (&lt;a href=&quot;http://www.sqlite.org/src/info/efc02f9779&quot;&gt;[efc02f9779]&lt;/a&gt;).</source>
          <target state="translated">トリガーの不明瞭なバグ修正（&lt;a href=&quot;http://www.sqlite.org/src/info/efc02f9779&quot;&gt;[efc02f9779]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="06705e47733fa2d26527ca5b13fe92c1b7ca1944" translate="yes" xml:space="preserve">
          <source>Obsolete Documents</source>
          <target state="translated">廃止された文書</target>
        </trans-unit>
        <trans-unit id="adcd55329b6153adb94eaf8a12d01ba2bc7cea95" translate="yes" xml:space="preserve">
          <source>Obtain A Composite Changeset From A Changegroup</source>
          <target state="translated">チェンジグループからのコンポジット チェンジセットの取得</target>
        </trans-unit>
        <trans-unit id="f036e380a093cadb7b7384e4b591b8c75c1ba145" translate="yes" xml:space="preserve">
          <source>Obtain Aggregate Function Context</source>
          <target state="translated">集計関数コンテキストの取得</target>
        </trans-unit>
        <trans-unit id="e79fb280b93973e6bfe3f8e79ba72b5b038ba1fa" translate="yes" xml:space="preserve">
          <source>Obtain Conflicting Row Values From A Changeset Iterator</source>
          <target state="translated">チェンジセット イテレータからの矛盾する行値の取得</target>
        </trans-unit>
        <trans-unit id="d4c8c29e25fb3ccc649578fec3be2c67a658b123" translate="yes" xml:space="preserve">
          <source>Obtain The Current Operation From A Changeset Iterator</source>
          <target state="translated">チェンジセット イテレータからの現在の操作の取得</target>
        </trans-unit>
        <trans-unit id="7ada95f817f8fc624dbadc0c0f495b244a8d38b3" translate="yes" xml:space="preserve">
          <source>Obtain The Primary Key Definition Of A Table</source>
          <target state="translated">表の主キー定義の取得</target>
        </trans-unit>
        <trans-unit id="2f0f8596ef7c82c2d68f88fe0c2c42b22b20b24e" translate="yes" xml:space="preserve">
          <source>Obtain Values For URI Parameters</source>
          <target state="translated">URIパラメータの値の取得</target>
        </trans-unit>
        <trans-unit id="e719cf57b48331ec73c3d09816f240ac71d990d4" translate="yes" xml:space="preserve">
          <source>Obtain a PENDING lock and then an EXCLUSIVE lock on the database file. If other processes still have SHARED locks, the writer might have to wait until those SHARED locks clear before it is able to obtain an EXCLUSIVE lock.</source>
          <target state="translated">データベースファイルのPENDINGロックとEXCLUSIVEロックを取得します。他のプロセスがまだSHAREDロックを持っている場合、ライタはEXCLUSIVEロックを取得できるようになる前に、SHAREDロックがクリアされるまで待たなければならないかもしれません。</target>
        </trans-unit>
        <trans-unit id="c4c184719398e2fd529d288f83e902aa72fdd7b4" translate="yes" xml:space="preserve">
          <source>Obtain a buffer containing a changeset (or patchset) representing the current contents of the changegroup. If the inputs to the changegroup were themselves changesets, the output is a changeset. Or, if the inputs were patchsets, the output is also a patchset.</source>
          <target state="translated">チェンジグループの現在の内容を表すチェンジセット(またはパッチセット)を含むバッファを取得します。changegroupへの入力がそれ自体がチェンジセットであった場合、出力はチェンジセットになります。あるいは、入力がパッチセットであった場合、出力はパッチセットでもあります。</target>
        </trans-unit>
        <trans-unit id="0ad736b5bee2570f5cbf619854f8b97d9b6134d1" translate="yes" xml:space="preserve">
          <source>Obtain a changeset containing changes to the tables attached to the session object passed as the first argument. If successful, set *ppChangeset to point to a buffer containing the changeset and *pnChangeset to the size of the changeset in bytes before returning SQLITE_OK. If an error occurs, set both *ppChangeset and *pnChangeset to zero and return an SQLite error code.</source>
          <target state="translated">第一引数として渡されたセッション・オブジェクトにアタッチされたテーブルの変更を含むチェンジセットを取得します。成功した場合、*ppChangesetをチェンジセットを含むバッファを指すように設定し、*pnChangesetをチェンジセットのサイズをバイト単位で設定してからSQLITE_OKを返します。エラーが発生した場合、*ppChangeset と *pnChangeset の両方をゼロに設定し、SQLite エラー・コードを返します。</target>
        </trans-unit>
        <trans-unit id="4304c4d08f4f900e2ab1ec29540131e8bf87ae39" translate="yes" xml:space="preserve">
          <source>Obtain a lock on a particular table. This instruction is only used when the shared-cache feature is enabled.</source>
          <target state="translated">特定のテーブルのロックを取得します。この命令は、共有キャッシュ機能が有効な場合にのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="35cc8c81bb0ab78babd3f65cb1b473a29bd69034" translate="yes" xml:space="preserve">
          <source>Obtain an EXCLUSIVE lock on the database file and make sure all memory changes have been written to the database file using the algorithm of steps 1-3 above.</source>
          <target state="translated">データベースファイルのEXCLUSIVEロックを取得し、上記の手順1-3のアルゴリズムを使用して、すべてのメモリ変更がデータベースファイルに書き込まれていることを確認します。</target>
        </trans-unit>
        <trans-unit id="edc981514ab58076de28ce864d46ccc2641ec1d0" translate="yes" xml:space="preserve">
          <source>Obtain new.* Values From A Changeset Iterator</source>
          <target state="translated">変更セット・イテレータからの new.*値の取得</target>
        </trans-unit>
        <trans-unit id="c31b9f4e355939157fe39f17fcb0e54282736c63" translate="yes" xml:space="preserve">
          <source>Obtain old.* Values From A Changeset Iterator</source>
          <target state="translated">変更セット・イテレータからの old.*値の取得</target>
        </trans-unit>
        <trans-unit id="d399842fa2ae120f608cae0543637da5b44e2b8c" translate="yes" xml:space="preserve">
          <source>Obtain the latest SQLite code from fossil.</source>
          <target state="translated">fossilから最新のSQLiteコードを取得します。</target>
        </trans-unit>
        <trans-unit id="9ed23644c9e9a46df1cd037be0519be726230e11" translate="yes" xml:space="preserve">
          <source>Obtaining SQL Values</source>
          <target state="translated">SQL値の取得</target>
        </trans-unit>
        <trans-unit id="ffe740a4611067b4b4dd0b5b7a28183003203956" translate="yes" xml:space="preserve">
          <source>Obtaining the</source>
          <target state="translated">の取得</target>
        </trans-unit>
        <trans-unit id="a8fbf19c89308087d70d289986f946de344868c9" translate="yes" xml:space="preserve">
          <source>Obtains the mutex.</source>
          <target state="translated">ミューテックスを取得します。</target>
        </trans-unit>
        <trans-unit id="974debb0f023f79fb3eec2db47da68008b639181" translate="yes" xml:space="preserve">
          <source>Occasionally, a serious problem is found and a small &quot;patch&quot; release must be made against a regular maintenance release. Patch are distinct from maintenance releases in that the number of lines of code changed from the previous release is very small. Every effort is made to avoid patch releases by making sure that maintenance releases are bug free.</source>
          <target state="translated">時折、深刻な問題が発見され、通常のメンテナンスリリースに対して小さな「パッチ」リリースを行わなければならないことがあります。パッチはメンテナンスリリースとは異なり、以前のリリースから変更されたコードの行数が非常に少ないという点で区別されます。メンテナンスリリースがバグフリーであることを確認することで、パッチリリースを避けるためのあらゆる努力がなされています。</target>
        </trans-unit>
        <trans-unit id="10b7fae72f94602297b15a7cf850a8e1ee7b4b31" translate="yes" xml:space="preserve">
          <source>Of course, ANALYZE only works effectively if you have a significant amount of content in your database in the first place. When creating a new database that you expect to accumulate a lot of data, you can run the command &quot;ANALYZE sqlite_master&quot; to create the SQLITE_STAT1 table, then prepopulate the SQLITE_STAT1 table (using ordinary INSERT statements) with content that describes a typical database for your application - perhaps content that you extracted after running ANALYZE on a well-populated template database in the lab.</source>
          <target state="translated">もちろん、ANALYZEが有効に機能するのは、そもそもデータベースにかなりの量のコンテンツが蓄積されている場合に限られます。多くのデータを蓄積することが予想される新しいデータベースを作成する場合、&quot;ANALYZE sqlite_master &quot;コマンドを実行してSQLITE_STAT1テーブルを作成し、アプリケーションの典型的なデータベースを記述したコンテンツでSQLITE_STAT1テーブルを事前に埋め込んで(通常のINSERT文を使用して)おくことができます。</target>
        </trans-unit>
        <trans-unit id="3d4796f0a34c568634b9634297a83ac77168e0e1" translate="yes" xml:space="preserve">
          <source>Of course, ANALYZE only works effectively if you have a significant amount of content in your database in the first place. When creating a new database that you expect to accumulate a lot of data, you can run the command &quot;ANALYZE sqlite_schema&quot; to create the SQLITE_STAT1 table, then prepopulate the SQLITE_STAT1 table (using ordinary INSERT statements) with content that describes a typical database for your application - perhaps content that you extracted after running ANALYZE on a well-populated template database in the lab.</source>
          <target state="translated">もちろん、analyzeが有効に機能するのは、そもそもデータベースにかなりの量のコンテンツが蓄積されている場合に限られます。多くのデータを蓄積することが予想される新しいデータベースを作成する場合、&quot;ANALYZE sqlite_schema &quot;コマンドを実行してSQLITE_STAT1テーブルを作成し、(通常のINSERT文を使用して)SQLITE_STAT1テーブルにアプリケーションの典型的なデータベースを記述したコンテンツを事前に登録しておくことができます-おそらくラボでよく登録されたテンプレートデータベースでANALYZEを実行した後に抽出したコンテンツです。</target>
        </trans-unit>
        <trans-unit id="79c23fc170f4a6f6a03298037f6a0ed97740fe0f" translate="yes" xml:space="preserve">
          <source>Of course, an error may occur while attempting any of the 4 steps enumerated above. If this happens, then the</source>
          <target state="translated">もちろん、上記の4つのステップのいずれかを実行中にエラーが発生する可能性があります。このような場合は</target>
        </trans-unit>
        <trans-unit id="4144a21a0e5e7b5ef89db325c2463b409501b64d" translate="yes" xml:space="preserve">
          <source>Of course, an ordinary SQLite table will also do a query against its integer primary key efficiently, so the previous is no big deal. The real reason for using an R*Tree is so that you can efficiently do inequality queries against the coordinate ranges. To find all elements of the index that are contained within the vicinity of Charlotte, North Carolina, one might do:</source>
          <target state="translated">もちろん、通常のSQLiteテーブルであれば、整数の主キーに対するクエリも効率的に実行されますので、前者は大した問題ではありません。R*Treeを使う本当の理由は、座標範囲に対する不等式クエリを効率的に行うためです。ノースカロライナ州シャーロット付近に含まれるインデックスのすべての要素を見つけるには、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="ad9000f84241cbe168fcf9edea5a309a2f41cf64" translate="yes" xml:space="preserve">
          <source>Of course, it is also possible that it does exist following system recovery.</source>
          <target state="translated">もちろん、システムリカバリー後に存在する可能性もあります。</target>
        </trans-unit>
        <trans-unit id="7a79fe7e88cf76ed8c1ab2e6617de9596ed474d8" translate="yes" xml:space="preserve">
          <source>Of course, it is usually not possible to atomically apply all the changes required by a</source>
          <target state="translated">もちろん、通常は、すべての変更をアトミックに適用することはできません。</target>
        </trans-unit>
        <trans-unit id="03e6ead3b1dad229ee29b568087a8cd4aada1c2d" translate="yes" xml:space="preserve">
          <source>Of course, not every language fits neatly into one of the above catagories. This applies to both SQL database engines and more familiar imperative programming languages. Javascript is famous for using a hybrid execution model, where the code is initially compiled into a tree of objects, but might be further translating (using just-in-time compilation) down into more efficient bytecode or machine code, as a means of boosting performance.</source>
          <target state="translated">もちろん、すべての言語が上記のカテゴリのいずれかにきちんと収まるわけではありません。これは SQL データベースエンジンにも、より身近な命令型プログラミング言語にも当てはまります。Javascriptはハイブリッド実行モデルを使用していることで有名ですが、コードは最初はオブジェクトのツリーにコンパイルされますが、パフォーマンスを向上させるための手段として、(ジャストインタイムコンパイルを使用して)さらに効率的なバイトコードやマシンコードに変換されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="b8a4fe5b2fe5db1f855a348ab89c3de5aa545089" translate="yes" xml:space="preserve">
          <source>Of course, one wants to eventually transfer all the transactions that are appended in the WAL file back into the original database. Moving the WAL file transactions back into the database is called a &quot;</source>
          <target state="translated">もちろん、最終的にはWALファイルに追加されたすべてのトランザクションを元のデータベースに戻したいと考えています。WALファイルのトランザクションをデータベースに戻すことを&quot;</target>
        </trans-unit>
        <trans-unit id="a8d7cb464eb0b5300b1a2a71635654f684270965" translate="yes" xml:space="preserve">
          <source>Of course, ordering the output of a query by rowid is seldom useful. Usually one wants to order the output by some other column.</source>
          <target state="translated">もちろん、クエリの出力をrowidで順番に並べることは滅多にありません。通常は、他のカラムで出力を順番に並べたいものです。</target>
        </trans-unit>
        <trans-unit id="178df5e8851c3ac34f7dcea098e85da7dbfe235b" translate="yes" xml:space="preserve">
          <source>Of course, substitute the desired index and imposter table names in place of the &quot;t1bc&quot; and &quot;t2&quot; shown in the example. The &quot;.imposter&quot; command reads the schema of the &quot;t1bc&quot; index, uses that information to construct a compatible CREATE TABLE statement for the imposter table, then makes all the necessary calls to create the transient imposter table automatically.</source>
          <target state="translated">もちろん、例に示した &quot;t1bc &quot;と &quot;t2 &quot;の代わりに、希望するインデックスとインポスターテーブル名を代入してください。.imposter &quot;コマンドは、&quot;t1bc &quot;インデックスのスキーマを読み込み、その情報を使用してインポスターテーブル用の互換性のあるCREATE TABLE文を構築し、その後、過渡的なインポスターテーブルを自動的に作成するために必要なすべての呼び出しを行います。</target>
        </trans-unit>
        <trans-unit id="116444cf2f220a0caf732f16ffb5a2f69fd9321c" translate="yes" xml:space="preserve">
          <source>Of course, the two queries above are not entirely equivalent. For example the LIKE query matches rows that contain terms such as &quot;linuxophobe&quot; or &quot;EnterpriseLinux&quot; (as it happens, the Enron E-Mail Dataset does not actually contain any such terms), whereas the MATCH query on the FTS3 table selects only those rows that contain &quot;linux&quot; as a discrete token. Both searches are case-insensitive. The FTS3 table consumes around 2006 MB on disk compared to just 1453 MB for the ordinary table. Using the same hardware configuration used to perform the SELECT queries above, the FTS3 table took just under 31 minutes to populate, versus 25 for the ordinary table.</source>
          <target state="translated">もちろん、上記の2つのクエリは完全に等価というわけではありません。例えば、LIKEクエリは &quot;linuxophobe &quot;や &quot;EnterpriseLinux &quot;のような用語を含む行にマッチします(実際にはEnron E-Mail Datasetにはそのような用語は含まれていません)。どちらの検索も大文字小文字を区別しません。FTS3テーブルのディスク消費量は、通常のテーブルが1453 MBであるのに対し、FTS3テーブルは約2006 MBです。上記の SELECT クエリの実行に使用したのと同じハードウェア構成を使用した場合、FTS3 テーブルの入力に要した時間は、通常のテーブルが 25 分であったのに対し、31 分弱でした。</target>
        </trans-unit>
        <trans-unit id="68b0ebb94fca52bc2076d132ead5c0f0cef17ce0" translate="yes" xml:space="preserve">
          <source>Of course, users would prefer code that is both robust in normal use and resistant to malicious attack. The SQLite developers are dedicated to providing that. The purpose of this section is merely to point out that doing both at the same time is hard.</source>
          <target state="translated">もちろん、ユーザーは通常の使用では堅牢で、悪意のある攻撃にも強いコードを好むでしょう。SQLite の開発者はそれを提供することに専念しています。このセクションの目的は、両方を同時に行うことが難しいことを指摘することにあります。</target>
        </trans-unit>
        <trans-unit id="e6778acfecc08483f487870a27c4e0b19bb8701d" translate="yes" xml:space="preserve">
          <source>Of course, your mileage may vary depending on hardware, filesystem, and operating system. Double-check these figures on target hardware before committing to a particular design.</source>
          <target state="translated">もちろん、ハードウェア、ファイルシステム、オペレーティング・システムによって異なる場合があります。特定のデザインにコミットする前に、ターゲットハードウェアでこれらの数字をダブルチェックしてください。</target>
        </trans-unit>
        <trans-unit id="315230e941921effe51cc9ebfa05403b855f0476" translate="yes" xml:space="preserve">
          <source>Of these changes, only 1a and 2a through 2c are incompatibilities in any formal sense. But users who have previously made custom modifications to the SQLite source (for example to add a custom OS layer for embedded hardware) might find that these changes have a larger impact. On the other hand, an important goal of these changes is to make it much easier to customize SQLite for use on different operating systems.</source>
          <target state="translated">これらの変更のうち、形式的な意味での非互換性があるのは 1a と 2a から 2c だけです。しかし、以前に SQLite ソースにカスタムの変更を加えたことのあるユーザ(例えば、組み込みハードウェア用のカスタム OS レイヤを追加するなど)は、これらの変更がより大きな影響を与えることに気づくかもしれません。一方で、これらの変更の重要な目的は、異なるオペレーティングシステムで使用するためのSQLiteのカスタマイズをより簡単にすることです。</target>
        </trans-unit>
        <trans-unit id="e3de5ab0ca4c69dbf00e86d2558843e8d806bb49" translate="yes" xml:space="preserve">
          <source>Off</source>
          <target state="translated">Off</target>
        </trans-unit>
        <trans-unit id="ce667716547fa82bc8795ad7ef205e9410193ed0" translate="yes" xml:space="preserve">
          <source>Offset</source>
          <target state="translated">Offset</target>
        </trans-unit>
        <trans-unit id="58190317f4f075103c701ab1719a5146c7d71c8f" translate="yes" xml:space="preserve">
          <source>OffsetLimit</source>
          <target state="translated">OffsetLimit</target>
        </trans-unit>
        <trans-unit id="1ab3ac50fee719ce4797840a2df9f8c5ee707c03" translate="yes" xml:space="preserve">
          <source>Older versions of SQLite could not read a WAL-mode database that was read-only. In other words, write access was required in order to read a WAL-mode database. This constraint was relaxed beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;version 3.22.0&lt;/a&gt; (2018-01-22).</source>
          <target state="translated">SQLiteの古いバージョンは、読み取り専用のWALモードデータベースを読み取ることができませんでした。つまり、WALモードのデータベースを読み取るには、書き込みアクセス権が必要でした。この制約は、SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;バージョン3.22.0&lt;/a&gt;（2018-01-22）から緩和されました。</target>
        </trans-unit>
        <trans-unit id="28b3eeca1402aeadaf4db2bf8f6d2403ee957bf0" translate="yes" xml:space="preserve">
          <source>Older versions of firebird omits all NULLs from SELECT DISTINCT and from UNION.</source>
          <target state="translated">古いバージョンのfirebirdでは、SELECT DISTINCTやUNIONからはすべてのNULLを省略しています。</target>
        </trans-unit>
        <trans-unit id="8bfe5e60a5daf11fac21979e5a4fa9643a76bc3b" translate="yes" xml:space="preserve">
          <source>Omit all use of &quot;awk&quot; in the makefiles, to make building easier for MSVC users.</source>
          <target state="translated">MSVC ユーザーがビルドしやすくするために、makefile での &quot;awk&quot; の使用をすべて省略しました。</target>
        </trans-unit>
        <trans-unit id="bf4d0857bd27f59258be5d9b1e12776a9ff94992" translate="yes" xml:space="preserve">
          <source>Omitted parameters take on default values. STEP defaults to 1. END defaults to 9223372036854775807. START defaults to 0.</source>
          <target state="translated">省略されたパラメータは、デフォルト値を使用します。STEPのデフォルト値は1です。END のデフォルトは 9223372036854775807 です。START のデフォルト値は 0 です。</target>
        </trans-unit>
        <trans-unit id="e0049a66519cae71159800bb77a35007bc2d76d3" translate="yes" xml:space="preserve">
          <source>On</source>
          <target state="translated">On</target>
        </trans-unit>
        <trans-unit id="0e46092ad025ac57fb1677f1d311680029cda2c1" translate="yes" xml:space="preserve">
          <source>On Android, we are told, there are many services that will blindly run arbitrary SQL that is passed to them by untrustworthy apps that have been downloaded from dodgy corners of the internet. Android services are suppose to be more guarded about running SQL from unvetted sources. This author does not have any specific examples to the contrary, but he has heard rumors that they exist. Even if all Android services are more careful and properly vet all the SQL they run, it would be difficult to audit them all in order to verify that they are safe. Hence, security-minded people are keen to ensure that no exploits are possible by passing arbitrary SQL text.</source>
          <target state="translated">Androidでは、インターネットの怪しげなコーナーからダウンロードした信頼できないアプリから渡された任意のSQLを盲目的に実行するサービスがたくさんあると言われています。Androidのサービスは、信頼されていないソースからのSQLを実行することについては、より警戒されているはずだ。筆者はそれに反して具体的な例を持っていないが、存在するという噂を聞いたことがある。仮にすべての Android サービスがより慎重になり、実行するすべての SQL を適切に検証したとしても、それらが安全であることを確認するためにすべての SQL を監査することは難しいだろう。それゆえ、セキュリティに関心のある人たちは、任意のSQLテキストを渡すことで悪用されることがないようにしたいと考えている。</target>
        </trans-unit>
        <trans-unit id="26c3af907230190631617dbb8e5acb92e9854301" translate="yes" xml:space="preserve">
          <source>On Linux and other unix systems you will need to enter something like:</source>
          <target state="translated">Linux やその他の Unix システムでは、次のように入力する必要があります。</target>
        </trans-unit>
        <trans-unit id="1273deeaf4de08300113723f337bae0ec716c243" translate="yes" xml:space="preserve">
          <source>On Win32, do not return an error when attempting to delete a file that does not exist.</source>
          <target state="translated">Win32では、存在しないファイルを削除しようとしてもエラーを返さないようにしました。</target>
        </trans-unit>
        <trans-unit id="b2b2f36a4fafa25d031c2e6870c72d35c487959e" translate="yes" xml:space="preserve">
          <source>On Windows systems, folders are searched in the following order:</source>
          <target state="translated">Windows システムでは、フォルダは次の順序で検索されます。</target>
        </trans-unit>
        <trans-unit id="9d83a99bbbc3869a446954149b390c5195af03a3" translate="yes" xml:space="preserve">
          <source>On Windows with MSVC, use nmake with the Makefile.msc:</source>
          <target state="translated">MSVCを搭載したWindowsでは、Makefile.mscでnmakeを使用します。</target>
        </trans-unit>
        <trans-unit id="e51bd18dd2b65a7e346c37ac44c1031b3f3942d7" translate="yes" xml:space="preserve">
          <source>On Windows, enter:</source>
          <target state="translated">Windowsでは、入力します。</target>
        </trans-unit>
        <trans-unit id="aacb79e6ea038d7e3cda09880e0781239b1e3933" translate="yes" xml:space="preserve">
          <source>On a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt;, the WAL is first flushed to persistent storage using the xSync method of the &lt;a href=&quot;c3ref/io_methods&quot;&gt;VFS&lt;/a&gt;. Then valid content of the WAL is transferred into the database file. Finally, the database is flushed to persistent storage using another xSync method call. The xSync operations serve as write barriers - all writes launched before the xSync must complete before any write that launches after the xSync begins.</source>
          <target state="translated">上の&lt;a href=&quot;wal#ckpt&quot;&gt;チェックポイント&lt;/a&gt;、WALは、第一のXSYNC方法使用永続ストレージにフラッシュされる&lt;a href=&quot;c3ref/io_methods&quot;&gt;VFSを&lt;/a&gt;。次に、WALの有効なコンテンツがデータベースファイルに転送されます。最後に、データベースは別のxSyncメソッド呼び出しを使用して永続ストレージにフラッシュされます。xSync操作は書き込みバリアとして機能します。xSyncの前に起動されたすべての書き込みは、xSyncの開始後に起動される書き込みの前に完了する必要があります。</target>
        </trans-unit>
        <trans-unit id="ea7fd316bd0a1ed7abbfd63a2c9be9dcb14966c5" translate="yes" xml:space="preserve">
          <source>On a DISTINCT query that uses an index, try to skip ahead to the next distinct entry using the index rather than stepping through rows, when an appropriate index is available.</source>
          <target state="translated">インデックスを使用するDISTINCTクエリでは、適切なインデックスが利用可能な場合には、行をステップスルーするのではなく、インデックスを使用して次の明確なエントリにスキップしてみてください。</target>
        </trans-unit>
        <trans-unit id="439b4340c2826997b9311dbcdfa182caed0bc968" translate="yes" xml:space="preserve">
          <source>On a traditional spinning disk, a sector is the minimum unit of transfer in both directions, both reading and writing. On flash memory, however, the minimum size of a read is typically much smaller than a minimum write. SQLite is only concerned with the minimum write amount and so for the purposes of this article, when we say &quot;sector&quot; we mean the minimum amount of data that can be written to mass storage in a single go.</source>
          <target state="translated">従来のスピニングディスクでは、セクタとは、読み取りと書き込みの両方の方向の転送の最小単位である。しかし、フラッシュメモリでは、通常、読み込みの最小サイズは書き込みの最小サイズよりもはるかに小さくなります。SQLiteは最小書き込み量にしか関心がないので、この記事では「セクタ」というと、大容量ストレージに一度に書き込める最小データ量のことを指します。</target>
        </trans-unit>
        <trans-unit id="4d25766d7605da89f0dc45ce4758796da7aaedb1" translate="yes" xml:space="preserve">
          <source>On an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, if the ROWID or INTEGER PRIMARY KEY column is not explicitly given a value, then it will be filled automatically with an unused integer, usually one more than the largest ROWID currently in use. This is true regardless of whether or not the AUTOINCREMENT keyword is used.</source>
          <target state="translated">上&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; ROWIDまたはINTEGER PRIMARY KEY列が明示的に値が与えられていない場合、それは通常、1つ以上の現在使用されている最大ROWIDより、未使用整数で自動的に満たされます。これは、AUTOINCREMENTキーワードが使用されているかどうかに関係なく当てはまります。</target>
        </trans-unit>
        <trans-unit id="ebef8439735d14eb6033471fd2e7d318b20febc6" translate="yes" xml:space="preserve">
          <source>On an UPSERT when the order of constraint checks is rearranged, ensure that the affinity transformations on the inserted content occur before any of the constraint checks. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/79cad5e4b2e219dd197242e9e&quot;&gt;79cad5e4b2e219dd197242e9e&lt;/a&gt;.</source>
          <target state="translated">UPSERTでは、制約チェックの順序が再配置される場合、挿入されたコンテンツのアフィニティ変換が制約チェックの前に行われることを確認してください。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/79cad5e4b2e219dd197242e9e&quot;&gt;79cad5e4b2e219dd197242e9eの&lt;/a&gt;修正。</target>
        </trans-unit>
        <trans-unit id="0a7e67fba14e6027ea80edde2148e2473e22f15f" translate="yes" xml:space="preserve">
          <source>On each call to undo::undo or undo::redo, the undo/redo module automatically invokes methods status_refresh and reload_all in all toplevel namespaces. These methods should be defined to reconstruct the display or otherwise update the state of the program based on the undone/redone changes to the database.</source>
          <target state="translated">undo::undo または undo::redo を呼び出すたびに、undo/redo モジュールは、すべてのトップレベルの名前空間で status_refresh および reload_all メソッドを自動的に呼び出します。これらのメソッドは、表示を再構築したり、データベースに対する undo/redone の変更に基づいてプログラムの状態を更新したりするために定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="51efe73d5459fecda0ebf237f9f8f384ca5daf31" translate="yes" xml:space="preserve">
          <source>On embedded systems with synchronous filesystems, TRUNCATE results in slower behavior than PERSIST. The commit operation is the same speed. But subsequent transactions are slower following a TRUNCATE because it is faster to overwrite existing content than to append to the end of a file. New journal file entries will always be appended following a TRUNCATE but will usually overwrite with PERSIST.</source>
          <target state="translated">同期ファイルシステムを持つ組み込みシステムでは、TRUNCATEはPERSISTよりも動作が遅くなります。コミット操作は同じ速度です。しかし、ファイルの最後に追加するよりも既存のコンテンツを上書きする方が速いため、TRUNCATEの後に続くトランザクションは遅くなります。新しいジャーナルファイルエントリはTRUNCATEの後に常に追加されますが、通常はPERSISTで上書きされます。</target>
        </trans-unit>
        <trans-unit id="cff1aa0bee9c89492d085449129eae77e72bb5fa" translate="yes" xml:space="preserve">
          <source>On most systems, the malloc() system call returns a buffer that is aligned to an 8-byte boundary. But on some systems (ex: windows) malloc() returns 4-byte aligned pointer. This compile-time option must be used on systems that return 4-byte aligned pointers from malloc().</source>
          <target state="translated">ほとんどのシステムでは、malloc()システムコールは 8 バイトの境界に整列したバッファを返します。しかし、一部のシステム (例:windows)では malloc()は 4 バイトアライメントされたポインタを返します。このコンパイル時オプションは、malloc()から 4 バイトアライメントされたポインタを返すシステムで使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="87f5be0e7a33503458f9f1fc5e662122708d06fc" translate="yes" xml:space="preserve">
          <source>On newer versions of SQLite, a WAL-mode database on read-only media, or a WAL-mode database that lacks write permission, can still be read as long as one or more of the following conditions are met:</source>
          <target state="translated">新しいバージョンのSQLiteでは、読み取り専用メディア上のWALモードデータベースや、書き込み権限を持たないWALモードデータベースでも、以下の条件の1つ以上が満たされていれば読み込むことができます。</target>
        </trans-unit>
        <trans-unit id="0a3b32dd2c0c0446522505f738b73e43600ba9ad" translate="yes" xml:space="preserve">
          <source>On startup, the &lt;b&gt;sqlite3&lt;/b&gt; program will show a brief banner message then prompt you to enter SQL. Type in SQL statements (terminated by a semicolon), press &quot;Enter&quot; and the SQL will be executed.</source>
          <target state="translated">起動時に、&lt;b&gt;sqlite3&lt;/b&gt;プログラムは短いバナーメッセージを表示し、SQLの入力を要求します。SQLステートメントを入力し（セミコロンで終了）、[Enter]を押すとSQLが実行されます。</target>
        </trans-unit>
        <trans-unit id="a6133c9cbc7fd01002e1fd8f131c7ef4a48f7b82" translate="yes" xml:space="preserve">
          <source>On startup, the application first decides which version it wants to display. Since the versionId will naturally increase in time and one would normally want to see the latest version, an appropriate query might be:</source>
          <target state="translated">起動時に、アプリケーションは最初に表示したいバージョンを決定します。versionIdは当然ながら時間の経過とともに増加し、通常は最新のバージョンを表示したいので、適切なクエリは次のようになります。</target>
        </trans-unit>
        <trans-unit id="d2a06dc722811f829dbda8827b08f5f0b5f36ae8" translate="yes" xml:space="preserve">
          <source>On success, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; is returned and the new &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; is stored in *ppBlob. Otherwise an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned and, unless the error code is SQLITE_MISUSE, *ppBlob is set to NULL. This means that, provided the API is not misused, it is always safe to call &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt; on *ppBlob after this function it returns.</source>
          <target state="translated">成功すると、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;が返され、新しい&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOBハンドル&lt;/a&gt;が* ppBlobに格納されます。それ以外の場合、&lt;a href=&quot;rescode&quot;&gt;エラーコード&lt;/a&gt;が返され、エラーコードがSQLITE_MISUSEでない限り、* ppBlobはNULLに設定されます。つまり、APIが誤用されていない限り、この関数が返した後、* ppBlobで&lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close（）&lt;/a&gt;を呼び出しても常に安全です。</target>
        </trans-unit>
        <trans-unit id="749e0ca8bebcf0ea981a3b5d51013a9a74a29d29" translate="yes" xml:space="preserve">
          <source>On success, &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; is returned and the new &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; is stored in *ppBlob. Otherwise an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned and, unless the error code is SQLITE_MISUSE, *ppBlob is set to NULL. This means that, provided the API is not misused, it is always safe to call &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt; on *ppBlob after this function it returns.</source>
          <target state="translated">成功すると、&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;が返され、新しい&lt;a href=&quot;blob&quot;&gt;BLOBハンドル&lt;/a&gt;が* ppBlobに格納されます。それ以外の場合、&lt;a href=&quot;../rescode&quot;&gt;エラーコード&lt;/a&gt;が返され、エラーコードがSQLITE_MISUSEでない限り、* ppBlobはNULLに設定されます。つまり、APIが誤用されていない限り、この関数が返した後、* ppBlobで&lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close（）&lt;/a&gt;を呼び出しても常に安全です。</target>
        </trans-unit>
        <trans-unit id="65eaebdd334ea618570d91e4458e0eb1b208375f" translate="yes" xml:space="preserve">
          <source>On success, &lt;b&gt;sqlite_compile&lt;/b&gt; returns SQLITE_OK. Otherwise and error code is returned.</source>
          <target state="translated">成功すると、&lt;b&gt;sqlite_compile&lt;/b&gt;は&lt;b&gt;SQLITE_OKを&lt;/b&gt;返します。それ以外の場合は、エラーコードが返されます。</target>
        </trans-unit>
        <trans-unit id="3e9b1d8e369d082b964c508c283e64eea1e0560c" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_read() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned.</source>
          <target state="translated">成功すると、sqlite3_blob_read（）はSQLITE_OKを返します。それ以外の場合は、&lt;a href=&quot;../rescode&quot;&gt;エラーコード&lt;/a&gt;または&lt;a href=&quot;../rescode#extrc&quot;&gt;拡張エラーコード&lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="e81bdc76837634caa6cec9a7812e38a822384af4" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_read() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned.</source>
          <target state="translated">成功すると、sqlite3_blob_read（）はSQLITE_OKを返します。それ以外の場合は、&lt;a href=&quot;rescode&quot;&gt;エラーコード&lt;/a&gt;または&lt;a href=&quot;rescode#extrc&quot;&gt;拡張エラーコード&lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="00223380eeb8684c87e10d42630c25143e83fb7d" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_write() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned. Unless SQLITE_MISUSE is returned, this function sets the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">成功すると、sqlite3_blob_write（）はSQLITE_OKを返します。それ以外の場合は、&lt;a href=&quot;../rescode&quot;&gt;エラーコード&lt;/a&gt;または&lt;a href=&quot;../rescode#extrc&quot;&gt;拡張エラーコード&lt;/a&gt;が返されます。SQLITE_MISUSEが返されない限り、この関数は、&lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;と&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;および関連する関数を介してアクセス可能な&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;エラーコードとメッセージを設定します。</target>
        </trans-unit>
        <trans-unit id="e1d8319a0f054e12945ffdcd496271dbacaf81a2" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_write() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned. Unless SQLITE_MISUSE is returned, this function sets the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">成功すると、sqlite3_blob_write（）はSQLITE_OKを返します。それ以外の場合は、&lt;a href=&quot;rescode&quot;&gt;エラーコード&lt;/a&gt;または&lt;a href=&quot;rescode#extrc&quot;&gt;拡張エラーコード&lt;/a&gt;が返されます。SQLITE_MISUSEが返されない限り、この関数は、&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;と&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;および関連する関数を介してアクセス可能な&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;エラーコードとメッセージを設定します。</target>
        </trans-unit>
        <trans-unit id="8609e89a9e3f181cc9bf01d1a6238ab2d0959ed4" translate="yes" xml:space="preserve">
          <source>On success, the sqlite3_prepare() family of routines return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;; otherwise an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">成功すると、sqlite3_prepare（）ファミリーのルーチンは&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OKを返し&lt;/a&gt;ます。それ以外の場合は、&lt;a href=&quot;rescode&quot;&gt;エラーコード&lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="3e16251e40927c67fe655d2518e028082c6fa9b3" translate="yes" xml:space="preserve">
          <source>On success, the sqlite3_prepare() family of routines return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;; otherwise an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">成功すると、sqlite3_prepare（）ファミリーのルーチンは&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OKを返し&lt;/a&gt;ます。それ以外の場合は、&lt;a href=&quot;../rescode&quot;&gt;エラーコード&lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="79e4255a03a365ba20cd0884b8ee349e3d935179" translate="yes" xml:space="preserve">
          <source>On the Mac, you can set this pragma:</source>
          <target state="translated">Macでは、このプラグマを設定することができます。</target>
        </trans-unit>
        <trans-unit id="69a450284be9205b76c2e066c35f545c5c025beb" translate="yes" xml:space="preserve">
          <source>On the other hand, a database engine that uses a server can provide better protection from bugs in the client application - stray pointers in a client cannot corrupt memory on the server. And because a server is a single persistent process, it is able control database access with more precision, allowing for finer grain locking and better concurrency.</source>
          <target state="translated">一方、サーバーを使用するデータベースエンジンは、クライアントアプリケーションのバグからより良い保護を提供することができます。また、サーバは単一の永続的なプロセスであるため、データベースへのアクセスをより正確に制御することができ、より細かい粒度のロックとより良い同時実行が可能になります。</target>
        </trans-unit>
        <trans-unit id="84736c128a35123ea022380e6a3900484bf1a802" translate="yes" xml:space="preserve">
          <source>On the other hand, a database engine that uses a server can provide better protection from bugs in the client application - stray pointers in a client cannot corrupt memory on the server. And because a server is a single persistent process, it is able to control database access with more precision, allowing for finer-grained locking and better concurrency.</source>
          <target state="translated">一方、サーバーを使用するデータベースエンジンは、クライアントアプリケーションのバグからより良い保護を提供することができます。また、サーバは単一の永続的なプロセスであるため、データベースへのアクセスをより正確に制御することができ、より細かなロックとより良い同時実行が可能になります。</target>
        </trans-unit>
        <trans-unit id="71cbc82c664fd1caf1a677d0c65b18293805a90f" translate="yes" xml:space="preserve">
          <source>On the other hand, an RBU Vacuum uses more CPU than a regular SQLite VACUUM - in one test as much as five times as much. For this reason, an RBU Vacuum is often significantly slower than an SQLite VACUUM under the same conditions.</source>
          <target state="translated">一方、RBUバキュームは通常のSQLite VACUUMよりも多くのCPUを使用します。このため、RBU VACUUMは、同じ条件下ではSQLite VACUUMよりも大幅に遅くなることがよくあります。</target>
        </trans-unit>
        <trans-unit id="2ec9b50cf6f067a94359ec578926c021dba81fa8" translate="yes" xml:space="preserve">
          <source>On the other hand, dropping tables is not a very common operation so if SQLite takes a little longer, that is not seen as a big problem.</source>
          <target state="translated">一方で、テーブルのドロップはあまり一般的な操作ではないので、SQLiteがもう少し時間がかかっても、それは大きな問題とは思われません。</target>
        </trans-unit>
        <trans-unit id="b75edbc4ccb51b3a0effc26ec943821968d21e88" translate="yes" xml:space="preserve">
          <source>On the other hand, if the result of the subquery must be scanned multiple times (because, for example, it is just one table in a join) then it is better to use a transient table to remember the entire result of the subquery, in order to avoid computing the subquery more than once.</source>
          <target state="translated">一方、副問い合わせの結果を複数回スキャンしなければならない場合(例えば、ジョインの中の1つのテーブルだけであるため)、副問い合わせを複数回計算しないようにするために、副問い合わせの結果全体を記憶するために過渡的なテーブルを使用する方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="4cb26bb6bd2845585001f514df8ac5e23d3a9784" translate="yes" xml:space="preserve">
          <source>On the other hand, read performance deteriorates as the WAL file grows in size since each reader must check the WAL file for the content and the time needed to check the WAL file is proportional to the size of the WAL file. The wal-index helps find content in the WAL file much faster, but performance still falls off with increasing WAL file size. Hence, to maintain good read performance it is important to keep the WAL file size down by running checkpoints at regular intervals.</source>
          <target state="translated">一方、WALファイルのサイズが大きくなると、各リーダーがWALファイルの内容をチェックしなければならず、チェックに要する時間はWALファイルのサイズに比例するため、読み取り性能が低下します。wal-indexはWALファイル内のコンテンツをより速く見つけるのに役立ちますが、WALファイルのサイズが大きくなるとパフォーマンスは低下します。したがって、良好な読み取り性能を維持するためには、一定の間隔でチェックポイントを実行してWALファイルのサイズを抑えることが重要です。</target>
        </trans-unit>
        <trans-unit id="9a0c49cb1cedb27f90f5b843b5321b6c2675c041" translate="yes" xml:space="preserve">
          <source>On the stack display, most entries are shown with a prefix that tells the datatype of that stack entry. Integers begin with &quot;&lt;code&gt;i:&lt;/code&gt;&quot;. Floating point values begin with &quot;&lt;code&gt;r:&lt;/code&gt;&quot;. (The &quot;r&quot; stands for &quot;real-number&quot;.) Strings begin with either &quot;&lt;code&gt;s:&lt;/code&gt;&quot;, &quot;&lt;code&gt;t:&lt;/code&gt;&quot;, &quot;&lt;code&gt;e:&lt;/code&gt;&quot; or &quot;&lt;code&gt;z:&lt;/code&gt;&quot;. The difference among the string prefixes is caused by how their memory is allocated. The z: strings are stored in memory obtained from &lt;b&gt;malloc()&lt;/b&gt;. The t: strings are statically allocated. The e: strings are ephemeral. All other strings have the s: prefix. This doesn't make any difference to you, the observer, but it is vitally important to the VDBE since the z: strings need to be passed to &lt;b&gt;free()&lt;/b&gt; when they are popped to avoid a memory leak. Note that only the first 10 characters of string values are displayed and that binary values (such as the result of the MakeRecord instruction) are treated as strings. The only other datatype that can be stored on the VDBE stack is a NULL, which is display without prefix as simply &quot;&lt;code&gt;NULL&lt;/code&gt;&quot;. If an integer has been placed on the stack as both an integer and a string, its prefix is &quot;&lt;code&gt;si:&lt;/code&gt;&quot;.</source>
          <target state="translated">スタック表示では、ほとんどのエントリは、そのスタックエントリのデータ型を示すプレフィックスで表示されます。整数は「 &lt;code&gt;i:&lt;/code&gt; 」で始まります。浮動小数点値は「 &lt;code&gt;r:&lt;/code&gt; 」で始まります。 （「r」は「実数」を表します。）文字列は「 &lt;code&gt;s:&lt;/code&gt; 」、「 &lt;code&gt;t:&lt;/code&gt; 」、「 &lt;code&gt;e:&lt;/code&gt; 」または「 &lt;code&gt;z:&lt;/code&gt; 」で始まります。文字列プレフィックスの違いは、メモリの割り当て方法が原因です。 z：文字列は、&lt;b&gt;malloc（）&lt;/b&gt;から取得したメモリに格納されます。 t：文字列は静的に割り当てられます。 e：文字列は短命です。他のすべての文字列にはs：プレフィックスがあります。これは観察者であるあなたに何の違いもありません、ただし、z：文字列を渡す必要があるため、VDBEにとって非常に重要です。&lt;b&gt;&lt;/b&gt;メモリリークを回避するためにポップされたときの&lt;b&gt;free（）&lt;/b&gt;。文字列値の最初の10文字だけが表示され、バイナリ値（MakeRecord命令の結果など）は文字列として扱われることに注意してください。VDBEスタックに格納できる他の唯一のデータ型はNULLで、接頭辞なしで単に「 &lt;code&gt;NULL&lt;/code&gt; 」として表示されます。整数が整数と文字列の両方としてスタックに配置されている場合、その接頭辞は &quot; &lt;code&gt;si:&lt;/code&gt; &quot;です。</target>
        </trans-unit>
        <trans-unit id="e3336bd71adcf37ccf53527f3a1cc4855eac8894" translate="yes" xml:space="preserve">
          <source>On unix systems (or on Windows using cygwin or mingw+msys) the command typically looks something like this:</source>
          <target state="translated">unix システム (または cygwin や mingw+msys を使用している Windows)では、このコマンドは通常次のようになります。</target>
        </trans-unit>
        <trans-unit id="287d1cbba1056569ceaf042e45ed9558181651a7" translate="yes" xml:space="preserve">
          <source>On unix, if a symlink to a database file is opened, then the corresponding journal files are based on the actual filename, not the symlink name.</source>
          <target state="translated">unixでは、データベースファイルへのシンボリックリンクが開かれた場合、対応するジャーナルファイルはシンボリックリンク名ではなく実際のファイル名に基づいています。</target>
        </trans-unit>
        <trans-unit id="6c70d0e29a89e83eef274cc81c5528ba689d997c" translate="yes" xml:space="preserve">
          <source>On unix-like systems, directories are searched in the following order:</source>
          <target state="translated">unix ライクなシステムでは、ディレクトリは以下の順序で検索されます。</target>
        </trans-unit>
        <trans-unit id="db7db60b91e81d2d39614db0d3144dc3caa85aa5" translate="yes" xml:space="preserve">
          <source>On windows only, convert all &quot;&lt;code&gt;\&lt;/code&gt;&quot; characters into &quot;&lt;code&gt;/&lt;/code&gt;&quot;.</source>
          <target state="translated">Windowsのみで、すべての「 &lt;code&gt;\&lt;/code&gt; 」文字を「 &lt;code&gt;/&lt;/code&gt; 」に変換します。</target>
        </trans-unit>
        <trans-unit id="aa996bed689bb081c327fe76624367885c13654f" translate="yes" xml:space="preserve">
          <source>On windows only, if the filename begins with a drive letter, prepend a single &quot;&lt;code&gt;/&lt;/code&gt;&quot; character.</source>
          <target state="translated">Windowsのみで、ファイル名がドライブ文字で始まる場合は、単一の「 &lt;code&gt;/&lt;/code&gt; 」文字を先頭に追加します。</target>
        </trans-unit>
        <trans-unit id="d9c768782ea8653d485fb3b7f5aba21cb2ca7bf3" translate="yes" xml:space="preserve">
          <source>Once</source>
          <target state="translated">Once</target>
        </trans-unit>
        <trans-unit id="87f26aaf5f6994f877b899775d955216fa5722f5" translate="yes" xml:space="preserve">
          <source>Once a</source>
          <target state="translated">一度は</target>
        </trans-unit>
        <trans-unit id="8464198c181050b3c7b7af3b57436c91d71a13de" translate="yes" xml:space="preserve">
          <source>Once a VFS has been registered, it should never be modified. If a change in behavior is required, a new VFS should be registered. The application could, perhaps, use &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; to locate the old VFS, make a copy of the old VFS into a new &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object, make the desired modifications to the new VFS, unregister the old VFS, then register the new VFS in its place. Existing database connections would continue to use the old VFS even after it is unregistered, but new database connections would use the new VFS.</source>
          <target state="translated">VFSが登録されたら、決して変更しないでください。動作の変更が必要な場合は、新しいVFSを登録する必要があります。アプリケーションは、おそらく、&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find（）&lt;/a&gt;を使用して古いVFSを特定し、古いVFSのコピーを新しい&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトに作成し、新しいVFSに必要な変更を加え、古いVFSの登録を解除し、新しいVFSを場所。登録を解除した後でも、既存のデータベース接続は古いVFSを使用し続けますが、新しいデータベース接続は新しいVFSを使用します。</target>
        </trans-unit>
        <trans-unit id="55b2eace4f6d572184649196769be324d9ec08aa" translate="yes" xml:space="preserve">
          <source>Once a connection obtains a table lock, it is not released until the current transaction (read or write) is concluded.</source>
          <target state="translated">接続がテーブルロックを取得すると、現在のトランザクション(読み取りまたは書き込み)が終了するまで解放されません。</target>
        </trans-unit>
        <trans-unit id="5e4e9f1432dcf3c9b2a4412dec01ffd3ea3a631b" translate="yes" xml:space="preserve">
          <source>Once a process obtains an exclusive lock, it is permitted to write to the database file. It then proceeds to read the original content of pages out of the rollback journal and write that content back to where it came from in the database file. Recall that the header of the rollback journal records the original size of the database file prior to the start of the aborted transaction. SQLite uses this information to truncate the database file back to its original size in cases where the incomplete transaction caused the database to grow. At the end of this step, the database should be the same size and contain the same information as it did before the start of the aborted transaction.</source>
          <target state="translated">プロセスが排他的ロックを取得すると、データベースファイルへの書き込みが許可されます。その後、ロールバック・ジャーナルからページの元の内容を読み取り、その内容をデータベース・ファイルの元の場所に書き戻します。ロールバックジャーナルのヘッダには、中断されたトランザクションが開始される前のデータベースファイルの元のサイズが記録されていることを思い出してください。SQLiteはこの情報を使用して、不完全なトランザクションが原因でデータベースが大きくなった場合に、データベースファイルを元のサイズに戻すために切り詰めます。このステップの終了時には、データベースは同じサイズになり、中断されたトランザクションの開始前と同じ情報が含まれているはずです。</target>
        </trans-unit>
        <trans-unit id="b42ea281b3fc7c07c016d5e3f2cf18291c599ca4" translate="yes" xml:space="preserve">
          <source>Once a table has been attached to a session object, the session object records the primary key values of all new rows inserted into the table. It also records the original primary key and other column values of any deleted or updated rows. For each unique primary key value, data is only recorded once - the first time a row with said primary key is inserted, updated or deleted in the lifetime of the session.</source>
          <target state="translated">テーブルがセッションオブジェクトにアタッチされると、セッションオブジェクトは、テーブルに挿入されたすべての新しい行の主キーの値を記録します。また、削除された行や更新された行の元の主キーやその他の列の値も記録されます。それぞれのユニークな主キー値に対して、データが記録されるのは1回だけです。</target>
        </trans-unit>
        <trans-unit id="9c0b7ad6ff995bbd9fed309a9d73615d47bfa0e5" translate="yes" xml:space="preserve">
          <source>Once a transaction has been opened, reading data from a database connection is a simple operation. Using the xRead() method of the file-handle open on the database file, the required database file pages are read one at a time. SQLite never reads partial pages and always uses a single call to xRead() for each required page.</source>
          <target state="translated">トランザクションがオープンされると、データベース接続からデータを読み込むのは簡単な操作です。データベースファイル上で開いているファイルハンドルの xRead()メソッドを使用して、必要なデータベースファイルのページを一度に一つずつ読み込みます。SQLite は部分的なページを読み込むことはなく、常に必要なページごとに xRead()を 1 回だけ呼び出します。</target>
        </trans-unit>
        <trans-unit id="511dc23c3f8ad619f86fc49e5ac60cacc5f4cbfc" translate="yes" xml:space="preserve">
          <source>Once a virtual table has been created, it can be used like any other table with the exceptions noted above and imposed by specific virtual table implementations. A virtual table is destroyed using the ordinary &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; syntax.</source>
          <target state="translated">仮想テーブルが作成されると、上記の例外を除き、特定の仮想テーブルの実装によって強制される他のテーブルと同じように使用できます。仮想テーブルは、通常の&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;構文を使用して破棄されます。</target>
        </trans-unit>
        <trans-unit id="c3f695a7b377f8d655c6f7bd1deb78c481aa015e" translate="yes" xml:space="preserve">
          <source>Once again, practical implementations will likely subclass this structure to add additional private fields.</source>
          <target state="translated">繰り返しになりますが、実用的な実装ではこの構造体をサブクラス化してプライベートフィールドを追加することになるでしょう。</target>
        </trans-unit>
        <trans-unit id="44317a76e0c4f1b6b3d16db84fa92562885dc8a9" translate="yes" xml:space="preserve">
          <source>Once again, the SQL statements generate identical bytecode and thus do exactly the same job in exactly the same way. But the second form is made easier for humans to read by grouping the query parameters together into a single row value rather than scattering them across the WHERE clause.</source>
          <target state="translated">繰り返しになりますが、SQL文は同じバイトコードを生成するので、全く同じ方法で全く同じ仕事をします。しかし、2つ目の形式では、クエリパラメータをWHERE句に分散させるのではなく、1つの行の値にまとめることで、人間が読みやすくなっています。</target>
        </trans-unit>
        <trans-unit id="d645ca4d6b0e5bfa41d1d0e06bb9cd91ff636156" translate="yes" xml:space="preserve">
          <source>Once all rollback journal files have been flushed to disk, it is safe to begin updating database files. We have to obtain an exclusive lock on all database files before writing the changes. After all the changes are written, it is important to flush the changes to disk so that they will be preserved in the event of a power failure or operating system crash.</source>
          <target state="translated">すべてのロールバックジャーナルファイルがディスクにフラッシュされると、データベースファイルの更新を開始しても安全です。変更を書き込む前に、すべてのデータベースファイルの排他的ロックを取得しなければなりません。すべての変更が書き込まれた後は、電源障害やオペレーティングシステムのクラッシュが発生した場合でも変更を保存できるように、変更をディスクにフラッシュすることが重要です。</target>
        </trans-unit>
        <trans-unit id="73fcb528effe6301ec78591adf7629a8ed98b913" translate="yes" xml:space="preserve">
          <source>Once an SQLite database is open, it can be controlled using methods of the</source>
          <target state="translated">SQLite データベースがオープンされると、そのデータベースは</target>
        </trans-unit>
        <trans-unit id="1676ac6920d27f0701cc052fe7ff5982a44cea9d" translate="yes" xml:space="preserve">
          <source>Once an encoding has been set for a database, it cannot be changed.</source>
          <target state="translated">一度データベースに設定したエンコーディングは変更できません。</target>
        </trans-unit>
        <trans-unit id="1f61d0c0dc743205cfd592b973902a4df3bd2139" translate="yes" xml:space="preserve">
          <source>Once an exclusive lock is held, we know that no other processes are reading from the database file and it is safe to write changes into the database file. Usually those changes only go as far as the operating systems disk cache and do not make it all the way to mass storage.</source>
          <target state="translated">排他的なロックがかかっていれば、他のプロセスがデータベースファイルから読み込んでいないことがわかり、データベースファイルに変更を書き込むことは安全です。通常、これらの変更はオペレーティングシステムのディスクキャッシュの範囲内でしか行われず、大容量ストレージには到達しません。</target>
        </trans-unit>
        <trans-unit id="8d6da848ac7743477288c842a221e398489c8a06" translate="yes" xml:space="preserve">
          <source>Once any conversions have taken place, and neither value is NULL, the values are compared. If both values are blobs then memcmp() is used to determine the results of the comparison. If both values are text, then the appropriate collating function specified in P4 is used to do the comparison. If P4 is not specified then memcmp() is used to compare text string. If both values are numeric, then a numeric comparison is used. If the two values are of different types, then numbers are considered less than strings and strings are considered less than blobs.</source>
          <target state="translated">変換が行われ、どちらの値もNULLでなければ、値が比較されます。両方の値がblobの場合は,比較の結果を決定するためにmemcmp()が使用されます。両方の値がテキストの場合は,P4で指定された適切な照合関数が比較のために使用されます.P4 が指定されていない場合は、memcmp()がテキスト文字列の比較に使用されます。両方の値が数値の場合、数値比較が使用されます。2つの値が異なるタイプのものであれば、数値は文字列よりも小さく、文字列はブロブよりも小さいとみなされます。</target>
        </trans-unit>
        <trans-unit id="4b170c45b3f098d917697616ac86ca3f213bd255" translate="yes" xml:space="preserve">
          <source>Once everything is ready, run the &quot;&lt;code&gt;fossil commit&lt;/code&gt;&quot; command to check in the changes. This creates circle (4) in the diagram above.</source>
          <target state="translated">すべての準備が整ったら、「 &lt;code&gt;fossil commit&lt;/code&gt; 」コマンドを実行して変更をチェックインします。これにより、上図の円（4）が作成されます。</target>
        </trans-unit>
        <trans-unit id="89efbd20c0a9cf3f9851965660941121b8a57cbc" translate="yes" xml:space="preserve">
          <source>Once one is comfortable with the concept of storing each slide separately, it is a small step to support versioning of the presentation. Consider the following schema:</source>
          <target state="translated">1つは、それぞれのスライドを別々に格納するという概念に快適になったら、それはプレゼンテーションのバージョン管理をサポートするための小さなステップです。次のスキーマを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="05be8dd08c1c90f1df285706af044dc836d0d98a" translate="yes" xml:space="preserve">
          <source>Once populated, there are three ways to execute a full-text query against the contents of an FTS5 table:</source>
          <target state="translated">一度埋め込んだ後、FTS5テーブルの内容に対してフルテキストクエリを実行するには、3つの方法があります。</target>
        </trans-unit>
        <trans-unit id="e7dc51406db9bf51bbe6620c6512b34c3f0e8f5e" translate="yes" xml:space="preserve">
          <source>Once the dirty page being purged is writable, it is simply written into the database file.</source>
          <target state="translated">パージされるダーティなページが書き込み可能になると、それは単にデータベースファイルに書き込まれます。</target>
        </trans-unit>
        <trans-unit id="821430ef05c1ab204de759a3df24102ae4261d90" translate="yes" xml:space="preserve">
          <source>Once the input data from the FROM clause has been filtered by the WHERE clause expression (if any), the set of result rows for the simple SELECT are calculated. Exactly how this is done depends on whether the simple SELECT is an aggregate or non-aggregate query, and whether or not a GROUP BY clause was specified.</source>
          <target state="translated">FROM句からの入力データがWHERE句式(あれば)でフィルタリングされると、単純なSELECTの結果行のセットが計算されます。これがどのように行われるかは、単純なSELECTが集約クエリか非集約クエリか、GROUP BY句が指定されているかどうかによって異なります。</target>
        </trans-unit>
        <trans-unit id="79336569e93b2e9d0a83cc5e0a929d5ce48d2824" translate="yes" xml:space="preserve">
          <source>Once the project repository is created, create an open checkout of the project by moving to the directory where you want to keep all of the project source code and typing:</source>
          <target state="translated">プロジェクトリポジトリを作成したら、プロジェクトのソースコードをすべて保管しておきたいディレクトリに移動して、プロジェクトのオープンチェックアウトを作成し、タイピングを行います。</target>
        </trans-unit>
        <trans-unit id="c4e9c9ce3f592c90096798d4d198a8b0474086e9" translate="yes" xml:space="preserve">
          <source>Once the spellfix1 extension is loaded, an instance of the spellfix1 virtual table is created like this:</source>
          <target state="translated">spellfix1 拡張モジュールを読み込むと、spellfix1 仮想テーブルのインスタンスがこのように作成されます。</target>
        </trans-unit>
        <trans-unit id="8513b43854c13df7657753be614db748baf13f7a" translate="yes" xml:space="preserve">
          <source>Once the test program is generated, it is run with no arguments to perform the tests. Progress information as well as error diagnostics appear on standard output. (Alternative output arrangements can be made using a compile-time option for embedded devices that lack a standard output channel.) The program returns zero if there are no errors and non-zero if any problems were detected.</source>
          <target state="translated">テストプログラムが生成されると、テストを実行するために引数なしで実行されます。進捗情報とエラー診断は、標準出力に表示されます。(標準出力チャネルを持たない組み込み機器の場合は、コンパイル時のオプションを使用して、代替の出力を設定することができます)。プログラムは、エラーがない場合はゼロを返し、問題が検出された場合はゼロ以外を返します。</target>
        </trans-unit>
        <trans-unit id="bd0d76b14cf548de7ba347b074f1a4d3fbd73686" translate="yes" xml:space="preserve">
          <source>Once the virtual table is created, it can be queried as follows:</source>
          <target state="translated">仮想テーブルが作成されると、以下のように問い合わせができます。</target>
        </trans-unit>
        <trans-unit id="1f76d0dc14ccffaabe0506021b655e9b2d8e3d76" translate="yes" xml:space="preserve">
          <source>Once you locate a specific version, click on the hyperlink for that version to see the &quot;Check-in Information Page&quot;. Then click on either the &quot;Tarball&quot; link or the &quot;ZIP archive&quot; link to download the complete source tree.</source>
          <target state="translated">特定のバージョンを見つけたら、そのバージョンのハイパーリンクをクリックして、「チェックイン情報ページ」を見てください。その後、「Tarball」リンクまたは「ZIPアーカイブ」リンクをクリックして、完全なソースツリーをダウンロードしてください。</target>
        </trans-unit>
        <trans-unit id="5d89aa77c530c282e22378ce0f5d708e01a8b4fb" translate="yes" xml:space="preserve">
          <source>One approach to this query is to use the fruit='Orange' term of the WHERE clause to find all rows dealing with oranges, then filter those rows by rejecting any that are from states other than California. This process is shown by &lt;a href=&quot;#fig7&quot;&gt;figure 7&lt;/a&gt; above. This is a perfectly reasonable approach in most cases. Yes, the database engine did have to do an extra binary search for the Florida orange row that was later rejected, so it was not as efficient as we might hope, though for many applications it is efficient enough.</source>
          <target state="translated">このクエリへのアプローチの1つは、WHERE句のfruit = 'Orange'用語を使用してオレンジを扱うすべての行を検索し、カリフォルニア以外の州からの行をすべて拒否することによってそれらの行をフィルター処理することです。このプロセスは、上の&lt;a href=&quot;#fig7&quot;&gt;図7に&lt;/a&gt;示されています。これは、ほとんどの場合、完全に妥当なアプローチです。はい、データベースエンジンはフロリダのオレンジ色の行に対して追加のバイナリ検索を実行する必要があったため、後で拒否されたため、期待したほど効率的ではありませんでしたが、多くのアプリケーションでは十分に効率的です。</target>
        </trans-unit>
        <trans-unit id="83e48e323326e14265bd89807dc478da45112a98" translate="yes" xml:space="preserve">
          <source>One can also provide comma-separated arguments to the module following the module name:</source>
          <target state="translated">モジュール名の後にカンマ区切りの引数を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="c99a07ebdfa971a90b20da9b4561b5f49cd6023c" translate="yes" xml:space="preserve">
          <source>One can also set the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; into automatic EXPLAIN QUERY PLAN mode using the &quot;.eqp on&quot; command:</source>
          <target state="translated">「.eqp on」コマンドを使用して、&lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;を自動EXPLAIN QUERY PLANモードに設定することもできます。</target>
        </trans-unit>
        <trans-unit id="efbb187108974c009f143234a98d6989ff9c9ac6" translate="yes" xml:space="preserve">
          <source>One can also think of savepoints as &quot;marks&quot; in the transaction timeline. In this view, the SAVEPOINT command creates a new mark, the ROLLBACK TO command rewinds the timeline back to a point just after the named mark, and the RELEASE command erases marks from the timeline without actually making any changes to the database.</source>
          <target state="translated">また、セーブポイントをトランザクションのタイムラインにおける「マーク」と考えることもできます。このビューでは、SAVEPOINTコマンドは新しいマークを作成し、ROLLBACK TOコマンドはタイムラインを指定されたマークの直後のポイントに巻き戻し、RELEASEコマンドは実際にデータベースに変更を加えることなくタイムラインからマークを消去します。</target>
        </trans-unit>
        <trans-unit id="3d55d95e5af6d3d744fa5a934dc2cc27683084a3" translate="yes" xml:space="preserve">
          <source>One can explicitly change out of WAL mode using a pragma such as this:</source>
          <target state="translated">このようなプラグマを使って、WALモードから明示的に切り替えることができます。</target>
        </trans-unit>
        <trans-unit id="5812082b2084545c8ed5d26ce266777d4a58efe5" translate="yes" xml:space="preserve">
          <source>One can see how the OR-by-UNION technique could also be leveraged to use multiple indices on queries where the WHERE clause has terms connected by AND, by using an intersect operator in place of union. Many SQL database engines will do just that. But the performance gain over using just a single index is slight and so SQLite does not implement that technique at this time. However, a future version SQLite might be enhanced to support AND-by-INTERSECT.</source>
          <target state="translated">OR-by-UNIONテクニックを利用して、WHERE句がANDで結ばれた用語を持つクエリで、ユニオンの代わりにインターセクト演算子を使用することで、複数のインデックスを使用することができることがわかります。多くのSQLデータベースエンジンはこれを実行します。しかし、単一のインデックスを使用した場合のパフォーマンスの向上はわずかであるため、現在のところSQLiteではこのテクニックは実装されていません。しかし、将来のバージョンの SQLite は AND-by-INTERSECT をサポートするように拡張されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="18266c8f1da4ccb3784663f1422488207a89b45d" translate="yes" xml:space="preserve">
          <source>One cannot create a trigger on a virtual table.</source>
          <target state="translated">仮想テーブルにトリガーを作成することはできません。</target>
        </trans-unit>
        <trans-unit id="08c14fea12c1a91b86b4eb3020bc8d201daa13d9" translate="yes" xml:space="preserve">
          <source>One cannot create additional indices on a virtual table. (Virtual tables can have indices but that must be built into the virtual table implementation. Indices cannot be added separately using &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statements.)</source>
          <target state="translated">仮想テーブルに追加のインデックスを作成することはできません。（仮想テーブルはインデックスを持つことができますが、仮想テーブルの実装に組み込む必要があります。インデックスは、&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;ステートメントを使用して個別に追加することはできません。）</target>
        </trans-unit>
        <trans-unit id="d3b50c178c087fb42ad06f0aba999c85b1ef895b" translate="yes" xml:space="preserve">
          <source>One cannot easily view, change, or extract the content of an OpenDocument presentation using generic tools. The only reasonable way to view or edit an OpenDocument document is to open it up using an application that is specifically designed to read or write OpenDocument (read: LibreOffice or one of its cousins). The situation could be worse. One can extract and view individual images (say) from a presentation using just the &quot;zip&quot; archiver tool. But it is not reasonable try to extract the text from a slide. Remember that all content is stored in a single &quot;context.xml&quot; file. That file is XML, so it is a text file. But it is not a text file that can be managed with an ordinary text editor. For the example presentation above, the content.xml file consist of exactly two lines. The first line of the file is just:</source>
          <target state="translated">一般的なツールを使って OpenDocument プレゼンテーションの内容を閲覧、変更、抽出することは簡単にはできません。OpenDocument ドキュメントを閲覧・編集する唯一の合理的な方法は、OpenDocument を読み書きするために特別に設計されたアプリケーショ ンを使って開くことです(読み方:LibreOffice やその従兄弟の一つ)。状況はもっと悪いかもしれません。プレゼンテーションから個々の画像を抽出して表示するには、単に「zip」アーカイバツールを使用します。しかし、それはスライドからテキストを抽出しようとすると合理的ではありません。すべてのコンテンツは、単一の ³&quot;context.xml³&quot;ファイルに格納されていることを覚えておいてください。そのファイルはXMLなので、テキストファイルです。しかし、それは通常のテキストエディタで管理できるテキストファイルではありません。上のプレゼンテーションの例では、content.xmlファイルはちょうど2行で構成されています。ファイルの1行目は、ただの</target>
        </trans-unit>
        <trans-unit id="8b60832325e280604faf68cf7c5149fd06825525" translate="yes" xml:space="preserve">
          <source>One cannot run &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; commands against a virtual table.</source>
          <target state="translated">仮想テーブルに対して&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt;コマンドを実行することはできません。</target>
        </trans-unit>
        <trans-unit id="8229271a498b58a8b73749061ba175879d5bffff" translate="yes" xml:space="preserve">
          <source>One difference between Next and ListRead is their idea of a &quot;thing&quot;. The &quot;things&quot; for the Next instruction are records in a database file. &quot;Things&quot; for ListRead are integer keys in a list. Another difference is whether to jump or fall through if there is no next &quot;thing&quot;. In this case, Next falls through, and ListRead jumps. Later on, we will see other looping instructions (NextIdx and SortNext) that operate using the same principle.</source>
          <target state="translated">Next命令とListRead命令の違いの一つは、「モノ」の考え方です。Next命令の「モノ」はデータベースファイル内のレコードです。&quot;ListReadの「もの」は、リスト内の整数キーです。もう一つの違いは、次の &quot;もの &quot;がない場合に、ジャンプするかフォールスルーするかということです。この場合、Nextはスルーし、ListReadはジャンプします。後に、同じ原理で動作する他のループ命令(NextIdxとSortNext)を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="0e2add845dd3757fedbc712aca0fdd2b6ebca768" translate="yes" xml:space="preserve">
          <source>One example of this occurred circa 2013-08-30 on the canonical repository for the &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt;. In that event, file descriptor 2 (standard error) was being erroneously closed (by &lt;a href=&quot;http://www.stunnel.org/&quot;&gt;stunnel&lt;/a&gt;, we suspect) prior to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; so that the file descriptor used for the repository database file was 2. Later, an application bug caused an assert() statement to emit an error message by invoking write(2,...). But since file descriptor 2 was now connected to a database file, the error message overwrote part of the database. To guard against this kind of problem, SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_1.html&quot;&gt;version 3.8.1&lt;/a&gt; (2013-10-17) and later refuse to use low-numbered file descriptors for database files. (See &lt;a href=&quot;compile#minimum_file_descriptor&quot;&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR&lt;/a&gt; for additional information.)</source>
          <target state="translated">この一例は、2013-08-30年に&lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil DVCSの&lt;/a&gt;正規リポジトリで発生しました。そのイベントでは、ファイル記述子2（標準エラー）が&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）の&lt;/a&gt;前に誤って閉じられていたため（おそらく&lt;a href=&quot;http://www.stunnel.org/&quot;&gt;stunnel&lt;/a&gt;によって）、リポジトリデータベースファイルに使用されるファイル記述子は2でした。その後、アプリケーションのバグによりassert（ ）ステートメントでwrite（2、...）を呼び出してエラーメッセージを出力します。しかし、ファイル記述子2がデータベースファイルに接続されたため、エラーメッセージがデータベースの一部を上書きしました。この種の問題を防ぐために、SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_1.html&quot;&gt;バージョン3.8.1&lt;/a&gt;（2013-10-17）以降では、データベースファイルに小さい番号のファイル記述子を使用することを拒否しています。（&lt;a href=&quot;compile#minimum_file_descriptor&quot;&gt;SQLITE_MINIMUM_FILE_DESCRIPTORを&lt;/a&gt;参照してください 詳細については）。</target>
        </trans-unit>
        <trans-unit id="f155185b09ba1b186403646b80d41d02e18f29b2" translate="yes" xml:space="preserve">
          <source>One exception to the typelessness of SQLite is a column whose type is INTEGER PRIMARY KEY. (And you must use &quot;INTEGER&quot; not &quot;INT&quot;. A column of type INT PRIMARY KEY is typeless just like any other.) INTEGER PRIMARY KEY columns must contain a 32-bit signed integer. Any attempt to insert non-integer data will result in an error.</source>
          <target state="translated">SQLiteの型なしの例外として、型がINTEGER PRIMARY KEYであるカラムがあります。(そして、&quot;INT &quot;ではなく &quot;INTEGER &quot;を使用しなければなりません。INT PRIMARY KEY型のカラムは、他のカラムと同様に型無しです)。INTEGER PRIMARY KEY カラムは 32 ビット符号付き整数を含まなければなりません。整数以外のデータを挿入しようとするとエラーになります。</target>
        </trans-unit>
        <trans-unit id="c476dc0c19b1ad151c922c972d11950866ac1040" translate="yes" xml:space="preserve">
          <source>One fuzzing researcher of particular note is &lt;a href=&quot;https://www.manuelrigger.at/&quot;&gt;Manuel Rigger&lt;/a&gt;, currently (as this paragraph is written on 2019-12-21) at &lt;a href=&quot;https://ethz.ch/en.html&quot;&gt;ETH Zurich&lt;/a&gt;. Most fuzzers only look for assertion faults, crashes, undefined behavior (UB), or other easily detected anomalies. Dr. Rigger's fuzzers, on the other hand, are able to find cases where SQLite computes an incorrect answer. Rigger has found &lt;a href=&quot;https://www.sqlite.org/src/timeline?y=t&amp;amp;u=mrigger&amp;amp;n=all&quot;&gt;many such cases&lt;/a&gt;. Most of these finds are fairly obscure corner cases involving type conversions and affinity transformations, and a good number of the finds are against unreleased features. Nevertheless, his finds are still important as they are real bugs, and the SQLite developers are grateful to be able to identify and fix the underlying problems. Rigger's work is currently unpublished. When it is released, it could be as influential as Zalewski's invention of AFL and profile-guided fuzzing.</source>
          <target state="translated">特に注目の一つファジング研究者である&lt;a href=&quot;https://www.manuelrigger.at/&quot;&gt;マヌエル・リガー&lt;/a&gt;で（この段落は、2019年12月21日に書かれているもの）は現在、&lt;a href=&quot;https://ethz.ch/en.html&quot;&gt;スイス連邦工科大学チューリッヒ校&lt;/a&gt;。ほとんどのファザーは、アサーションフォールト、クラッシュ、未定義の動作（UB）、またはその他の簡単に検出される異常のみを探します。一方、リガー博士のファザーは、SQLiteが誤った答えを計算するケースを見つけることができます。リガーは&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=t&amp;amp;u=mrigger&amp;amp;n=all&quot;&gt;そのようなケースをたくさん&lt;/a&gt;見つけました。これらの発見のほとんどは、型変換とアフィニティ変換を含むかなりあいまいなコーナーケースであり、かなりの数の発見が未リリースの機能に反対しています。それにもかかわらず、彼の発見は実際のバグであるため依然として重要であり、SQLite開発者は根本的な問題を特定して修正できることに感謝しています。リガーの作品は現在未発表です。それがリリースされるとき、それはAFLとプロファイルガイドファジングのZalewskiの発明と同じくらい影響力があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="a6bf8910e6414d0165fef0d30b0886bc0f8d4329" translate="yes" xml:space="preserve">
          <source>One implication of the above is that if a change is made and then unmade within a single session (for example if a row is inserted and then deleted again), the sessions module does not report any change at all. Or if a row is updated multiple times within the same session, all updates are coalesced into a single update within any changeset or patchset blob.</source>
          <target state="translated">上記の意味するところは、1つのセッション内で変更が行われた後に変更が解除された場合(例えば、行が挿入された後に再び削除された場合など)、セッションモジュールは変更を全く報告しないということです。あるいは、同じセッション内で行が複数回更新された場合、すべての更新はチェンジセットやパッチセットブロブ内の1つの更新にまとめられます。</target>
        </trans-unit>
        <trans-unit id="fc9f38831587103a404686b12cd389ecfbf1fe12" translate="yes" xml:space="preserve">
          <source>One might argue that it is ok, in this era of multi-gigabyte desktops, to read the entire document into memory. But it is not ok. For one, the amount of memory used far exceeds the (compressed) file size on disk. So a 50MB presentation might take 200MB or more RAM. That still is not a problem if one only edits a single document at a time. But when working on a talk, this author will typically have 10 or 15 different presentations up all at the same time (to facilitate copy/paste of slides from past presentation) and so gigabytes of memory are required. Add in an open web browser or two and a few other desktop apps, and suddenly the disk is whirling and the machine is swapping. And even having just a single document is a problem when working on an inexpensive Chromebook retrofitted with Ubuntu. Using less memory is always better.</source>
          <target state="translated">マルチ・ギガバイトのデスクトップの時代には、文書全体をメモリに読み込んでもいいのではないかという議論があるかもしれません。しかし、それは大丈夫ではありません。まず、使用されるメモリの量は、ディスク上の(圧縮された)ファイルサイズをはるかに超えています。そのため、50MBのプレゼンテーションには200MB以上のRAMが必要になるかもしれません。一度に一つの文書を編集するだけならまだ問題ありません。しかし、トークに取り組んでいるとき、この著者は通常、10または15の異なるプレゼンテーションをすべて同時にアップしているでしょう(過去のプレゼンテーションからのスライドのコピー/貼り付けを容易にするために)ので、メモリのギガバイトが必要です。それに加えて、開いているWebブラウザやデスクトップアプリケーションをいくつか追加すると、突然ディスクが回転し、マシンが入れ替わるようになります。そして、ちょうど単一のドキュメントを持っていても、Ubuntuで改装された安価なChromebookで作業するときに問題となっています.少ないメモリを使うのは常に良いことです。</target>
        </trans-unit>
        <trans-unit id="f44cc341ba0d29ec39fe1d9113cc5db69afebdc7" translate="yes" xml:space="preserve">
          <source>One might want to provide other &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; such as &lt;a href=&quot;compile#enable_fts4&quot;&gt;-DSQLITE_ENABLE_FTS4&lt;/a&gt; or &lt;a href=&quot;compile#enable_fts5&quot;&gt;-DSQLITE_ENABLE_FTS5&lt;/a&gt; for full-text search, &lt;a href=&quot;compile#enable_rtree&quot;&gt;-DSQLITE_ENABLE_RTREE&lt;/a&gt; for the R*Tree search engine extension, &lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt; to include &lt;a href=&quot;json1&quot;&gt;JSON SQL functions&lt;/a&gt;, or &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;-DSQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; for the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;. In order to see extra commentary in &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; listings, add the &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; option. On unix systems, add -DHAVE_USLEEP=1 if the host machine supports the usleep() system call. Add -DHAVE_READLINE and the -lreadline and -lncurses libraries to get command-line editing support. One might also want to specify some compiler optimization switches. (The precompiled CLI available for download from the SQLite website uses &quot;-Os&quot;.) There are countless possible variations here. A command to compile a full-featured shell might look something like this:</source>
          <target state="translated">一つは、他の提供する場合があります&lt;a href=&quot;compile&quot;&gt;コンパイル時のオプション&lt;/a&gt;など&lt;a href=&quot;compile#enable_fts4&quot;&gt;-DSQLITE_ENABLE_FTS4&lt;/a&gt;や&lt;a href=&quot;compile#enable_fts5&quot;&gt;-DSQLITE_ENABLE_FTS5&lt;/a&gt;全文検索のため、&lt;a href=&quot;compile#enable_rtree&quot;&gt;-DSQLITE_ENABLE_RTREE&lt;/a&gt; R *ツリー検索エンジンの拡張のために、&lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1を&lt;/a&gt;含めるように&lt;a href=&quot;json1&quot;&gt;JSON SQL関数&lt;/a&gt;、または&lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;-DSQLITE_ENABLE_DBSTAT_VTABを&lt;/a&gt;するために&lt;a href=&quot;dbstat&quot;&gt;仮想テーブルdbstat&lt;/a&gt;。で余分な解説を見るために&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;リスト、追加&lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTSを&lt;/a&gt;オプション。 UNIXシステムで、ホストマシンがusleep（）システムコールをサポートしている場合は、-DHAVE_USLEEP = 1を追加します。 -DHAVE_READLINEおよび-lreadlineおよび-lncursesライブラリを追加して、コマンドライン編集サポートを取得します。一部のコンパイラ最適化スイッチを指定することもできます。 （SQLite Webサイトからダウンロードできるプリコンパイル済みCLIは「-Os」を使用します。）ここには無数の可能なバリエーションがあります。フル機能のシェルをコンパイルするコマンドは、次のようになります。</target>
        </trans-unit>
        <trans-unit id="6a02d032d7380123e8a5e72e863e1054c5bd48cb" translate="yes" xml:space="preserve">
          <source>One minor downside of splitting content into smaller pieces is that compression does not work as well on shorter texts and so the size of the document might increase. But as the bulk of the document space is used to store images, a small reduction in the compression efficiency of the text content will hardly be noticeable, and is a small price to pay for an improved user experience.</source>
          <target state="translated">コンテンツをより小さな断片に分割することの小さな欠点は、短いテキストでは圧縮がうまく機能しないため、ドキュメントのサイズが大きくなる可能性があるということです。しかし、文書スペースの大部分は画像の保存に使用されているため、テキストコンテンツの圧縮効率が少し低下してもほとんど気にならないでしょう。</target>
        </trans-unit>
        <trans-unit id="b297ff44d76535e06e20e05a05458aba9a18af0a" translate="yes" xml:space="preserve">
          <source>One of the 10 decimal digit ASCII characters, or</source>
          <target state="translated">10進数10桁のASCII文字のうちの1つ、または</target>
        </trans-unit>
        <trans-unit id="67403b0cb5390fcf0c705699aeb495a2edb6d96b" translate="yes" xml:space="preserve">
          <source>One of the 52 upper and lower case ASCII characters, or</source>
          <target state="translated">52文字の大文字と小文字のASCII文字のうちの1つ、または</target>
        </trans-unit>
        <trans-unit id="cff101187bdbe5720613db95b3564ea1057f17a1" translate="yes" xml:space="preserve">
          <source>One of the &lt;a href=&quot;different&quot;&gt;distinctive features&lt;/a&gt; of SQLite is that a database consists of a single disk file. This simplifies the use of SQLite since moving or backing up a database is a simple as copying a single file. It also makes SQLite appropriate for use as an &lt;a href=&quot;whentouse#appfileformat&quot;&gt;application file format&lt;/a&gt;. But while a complete database is held in a single disk file, SQLite does make use of many temporary files during the course of processing a database.</source>
          <target state="translated">SQLiteの&lt;a href=&quot;different&quot;&gt;特徴の&lt;/a&gt; 1つは、データベースが単一のディスクファイルで構成されることです。データベースの移動やバックアップは、単一のファイルをコピーするのと同じくらい簡単なので、SQLiteの使用が簡単になります。また、SQLiteを&lt;a href=&quot;whentouse#appfileformat&quot;&gt;アプリケーションファイル形式&lt;/a&gt;として使用するのにも適しています。しかし、完全なデータベースは単一のディスクファイルに保持されますが、SQLiteはデータベースの処理中に多くの一時ファイルを利用します。</target>
        </trans-unit>
        <trans-unit id="e5c91de459561e96de8f3e9e77eaa61509cd18a7" translate="yes" xml:space="preserve">
          <source>One of the ALL or DISTINCT keywords may follow the SELECT keyword in a simple SELECT statement. If the simple SELECT is a SELECT ALL, then the entire set of result rows are returned by the SELECT. If neither ALL or DISTINCT are present, then the behavior is as if ALL were specified. If the simple SELECT is a SELECT DISTINCT, then duplicate rows are removed from the set of result rows before it is returned. For the purposes of detecting duplicate rows, two NULL values are considered to be equal. The &lt;a href=&quot;datatype3#colrules&quot;&gt;usual rules&lt;/a&gt; apply for selecting a collation sequence to compare text values.</source>
          <target state="translated">ALLまたはDISTINCTキーワードのいずれかが、単純なSELECTステートメントのSELECTキーワードの後に​​続く場合があります。単純なSELECTがSELECT ALLの場合、結果行のセット全体がSELECTによって返されます。 ALLもDISTINCTも存在しない場合、動作はALLが指定されたかのようになります。単純なSELECTがSELECT DISTINCTの場合、結果の行のセットから重複する行が削除されてから返されます。重複行を検出するために、2つのNULL値は等しいと見なされます。&lt;a href=&quot;datatype3#colrules&quot;&gt;通常の規則は、&lt;/a&gt;テキスト値を比較するための照合順序を選択するために適用されます。</target>
        </trans-unit>
        <trans-unit id="148ba6e1c7e039de60e4599c768cf9921948e4c8" translate="yes" xml:space="preserve">
          <source>One of the advantages of hosting code generator tools as part of the project is that the tools can be optimized to serve specific needs of the overall project. Lemon has benefited from this effect. Over the years, the Lemon parser generator has been extended and enhanced to provide new capabilities and improved performance to SQLite. A few of the specific enhancements to Lemon that are specifically designed for use by SQLite include:</source>
          <target state="translated">プロジェクトの一部としてコードジェネレーターツールをホスティングする利点の1つは、プロジェクト全体の特定のニーズに対応するためにツールを最適化できることです。Lemonはこの効果の恩恵を受けています。長年にわたり、Lemon パーサージェネレータは拡張され、SQLiteに新しい機能とパフォーマンスの向上を提供するために強化されてきました。SQLiteで使用するために特別に設計されたLemonの具体的な機能強化には、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="66a50c77336f3c9a6df53cb2e7363aee5a52fbbd" translate="yes" xml:space="preserve">
          <source>One of the interesting features of the VFS interface is that SQLite can support multiple VFSes at the same time. Each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; has to choose a single VFS for its use when the connection is first opened using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. But if a process contains multiple &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; each can choose a different VFS. VFSes can be added at run-time using the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface.</source>
          <target state="translated">VFSインターフェースの興味深い機能の1つは、SQLiteが複数のVFSを同時にサポートできることです。各&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;は、&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;を使用して接続が最初に開かれるときに、その使用のために単一のVFSを選択する必要があります。ただし、プロセスに複数の&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;が含まれている場合、それぞれが異なるVFSを選択できます。 VFSは、&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;インターフェイスを使用して実行時に追加できます。</target>
        </trans-unit>
        <trans-unit id="f1c2a440e7d12be65f7ff95454bfa77307c4b02e" translate="yes" xml:space="preserve">
          <source>One of the many reports that Fossil makes available is a timeline of changes to a single branch showing all merges in and out of that branch. See &lt;a href=&quot;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&quot;&gt;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&lt;/a&gt; for a typical example of such a report. Generating such a report normally takes just a few milliseconds. But after upgrading to the NGQP we noticed that this one report was taking closer to 10 seconds for the trunk of the repository.</source>
          <target state="translated">Fossilが提供する多くのレポートの1つは、単一のブランチへの変更のタイムラインで、そのブランチに出入りするすべてのマージを示しています。このようなレポートの典型的な例については、&lt;a href=&quot;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&quot;&gt;http：//www.sqlite.org/src/timeline？nd＆n = 200＆r = trunk&lt;/a&gt;を参照してください。このようなレポートの生成には、通常数ミリ秒しかかかりません。しかし、NGQPにアップグレードした後、この1つのレポートがリポジトリのトランクに10秒近くかかっていることに気付きました。</target>
        </trans-unit>
        <trans-unit id="16f929fd09cef7d1acb11b165614f8e6f651a35f" translate="yes" xml:space="preserve">
          <source>One of the things that SQLite does to ensure that transactions are atomic across system crashes and power failures is to write all changes into the rollback journal file prior to changing the database. The TCL test harness contains an alternative &lt;a href=&quot;vfs&quot;&gt;OS backend&lt;/a&gt; implementation that helps to verify this is occurring correctly. The &quot;journal-test VFS&quot; monitors all disk I/O traffic between the database file and rollback journal, checking to make sure that nothing is written into the database file which has not first been written and synced to the rollback journal. If any discrepancies are found, an assertion fault is raised.</source>
          <target state="translated">SQLiteがシステムクラッシュや停電全体でトランザクションをアトミックにするために行うことの1つは、データベースを変更する前に、すべての変更をロールバックジャーナルファイルに書き込むことです。 TCLテストハーネスには、これが正しく行われていることを確認するのに役立つ代替の&lt;a href=&quot;vfs&quot;&gt;OSバックエンド&lt;/a&gt;実装が含まれています。 「ジャーナルテストVFS」は、データベースファイルとロールバックジャーナルの間のすべてのディスクI / Oトラフィックを監視し、最初に書き込まれてロールバックジャーナルに同期されていないものがデータベースファイルに書き込まれていないことを確認します。不一致が見つかった場合、アサーションエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="8702bf42f5b52e2937e5261eb8fe5e53cb025817" translate="yes" xml:space="preserve">
          <source>One or more indexes of the table are currently unanalyzed &lt;em&gt;or&lt;/em&gt; the number of rows in the table has increased by 25 times or more since the last time ANALYZE was run.</source>
          <target state="translated">テーブルの1つ以上のインデックスが現在分析されてい&lt;em&gt;ないか&lt;/em&gt;、前回のANALYZEの実行以降、テーブルの行数が25倍以上増加しています。</target>
        </trans-unit>
        <trans-unit id="c07477cd0e5dcf04189629377d839b6d5b58ba89" translate="yes" xml:space="preserve">
          <source>One or more transactions must have been written to the current wal file since it was created on disk (by any connection). This means that a snapshot cannot be taken on a wal mode database with no wal file immediately after it is first opened. At least one transaction must be written to it first.</source>
          <target state="translated">ディスク上に作成されてから(どのような接続でも)、現在のwalファイルに1つ以上のトランザクションが書き込まれていなければなりません。これは、最初に開いた直後に wal ファイルがない wal モードのデータベースでスナップショットを撮影することはできないことを意味します。少なくとも1つのトランザクションが最初に書き込まれていなければなりません。</target>
        </trans-unit>
        <trans-unit id="b839504f0d97f30339eb42940d7178a50aed3e9b" translate="yes" xml:space="preserve">
          <source>One solution is to add an SQL foreign key constraint to the database schema to enforce the relationship between the</source>
          <target state="translated">1つの解決策は、データベーススキーマにSQL外部キー制約を追加して</target>
        </trans-unit>
        <trans-unit id="9e9e9e6d05419e1f1b802f612d5f17adfe32fb1a" translate="yes" xml:space="preserve">
          <source>One solution to this problem is to change SQLite to do an exhaustive search for the best path. But an exhaustive search requires time proportional to K! (where K is the number of tables in the join) and so when you get beyond a 10-way join, the time to run &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; becomes very large.</source>
          <target state="translated">この問題の1つの解決策は、SQLiteを変更して、最適なパスを徹底的に検索することです。しかし、徹底的な検索にはKに比例した時間が必要です。（Kは結合内のテーブルの数です）したがって、10方向結合を超えると、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare（）&lt;/a&gt;を実行する時間が非常に長くなります。</target>
        </trans-unit>
        <trans-unit id="3ea27e906845c470414940dc542a3a724c62dba9" translate="yes" xml:space="preserve">
          <source>One technique for avoiding a full table scan is to do lookups by rowid (or by the equivalent &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;). To lookup the price of peaches, one would query for the entry with a rowid of 4:</source>
          <target state="translated">全表スキャンを回避するための1つの方法は、ROWID（または同等の&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;）によるルックアップを行うことです。桃の価格を調べるには、ROWIDが4のエントリをクエリします。</target>
        </trans-unit>
        <trans-unit id="9d59b48161b2263d40d4491d1bb939a7b7f92e6e" translate="yes" xml:space="preserve">
          <source>One user of both Git and Fossil &lt;a href=&quot;https://news.ycombinator.com/item?id=16806955&quot;&gt;writes in HN&lt;/a&gt;:</source>
          <target state="translated">GitとFossilの両方の1人のユーザーが&lt;a href=&quot;https://news.ycombinator.com/item?id=16806955&quot;&gt;HNで書き込みます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="75f64ba853c8246c4f074dd74725d9448e0221f8" translate="yes" xml:space="preserve">
          <source>One verification technique used on SQLite is to run an entire test suite twice, once with optimizations left on and a second time with optimizations turned off, and verify that the same output is obtained both times. This shows that the optimizations do not introduce errors.</source>
          <target state="translated">SQLiteで使用されている検証手法の1つは、テストスイート全体を2回実行し、1回目は最適化をオンにしたまま、2回目は最適化をオフにして、2回とも同じ出力が得られることを検証するというものです。これは、最適化がエラーを発生させないことを示しています。</target>
        </trans-unit>
        <trans-unit id="1193850e31c2f1f6fdd8ba5f6d6a21ba1025f991" translate="yes" xml:space="preserve">
          <source>One very simple scheme might be to count the number of instances of the users search terms in each result document. Those documents that contain many instances of the terms are considered more relevant than those with a small number of instances of each term. In an FTS application, the number of term instances in each result could be determined by counting the number of integers in the return value of the &lt;a href=&quot;fts3#offsets&quot;&gt;offsets&lt;/a&gt; function. The following example shows a query that could be used to obtain the ten most relevant results for a query entered by the user:</source>
          <target state="translated">1つの非常に単純なスキームは、各結果ドキュメント内のユーザー検索語のインスタンスの数をカウントすることです。用語のインスタンスが多数含まれているドキュメントは、各用語のインスタンスが少ないドキュメントよりも関連性が高いと見なされます。 FTSアプリケーションでは、各結果の項インスタンスの数は、&lt;a href=&quot;fts3#offsets&quot;&gt;オフセット&lt;/a&gt;関数の戻り値の整数の数を数えることで決定できます。次の例は、ユーザーが入力したクエリに対して最も関連性の高い10個の結果を取得するために使用できるクエリを示しています。</target>
        </trans-unit>
        <trans-unit id="ef8241368a545dcfd4804f314c3279bd316a6040" translate="yes" xml:space="preserve">
          <source>One way around this problem is to check the extended error code returned by an sqlite3_step() call. If there is a blocking connection, then the extended error code is set to SQLITE_LOCKED_SHAREDCACHE. Otherwise, in the special &quot;DROP TABLE/INDEX&quot; case, the extended error code is just SQLITE_LOCKED.</source>
          <target state="translated">この問題を回避する一つの方法は、sqlite3_step()呼び出しで返される拡張エラーコードをチェックすることです。ブロッキング接続がある場合、拡張エラーコードはSQLITE_LOCKED_SHAREDCACHEに設定されます。そうでなければ、特別な &quot;DROP TABLE/INDEX &quot;の場合、拡張エラーコードはSQLITE_LOCKEDだけになります。</target>
        </trans-unit>
        <trans-unit id="acee115381c0c09c4f7ee9640610c7e8117858b5" translate="yes" xml:space="preserve">
          <source>One way to compute FindFrame(P,M) would be to scan the aPgno array starting with the M-th entry and working backwards towards the beginning and return J where aPgno[J]==P. Such an algorithm would work, and it would be faster than searching the whole WAL file for the latest frame with page number P. But the search can be made much faster still by using the aHash structure.</source>
          <target state="translated">FindFrame(P,M)を計算する一つの方法は、M番目のエントリから始まり、最初のエントリに向かって遡っていくaPgno配列をスキャンし、aPgno[J]==PでJを返すというものです。このようなアルゴリズムは機能し、ページ番号Pの最新のフレームをWALファイル全体から探すよりも高速です。</target>
        </trans-unit>
        <trans-unit id="43ce70174605b98e2611ee3fa62c55d5c3b3d847" translate="yes" xml:space="preserve">
          <source>One way to create an imposter table is to directly edit the sqlite_master table to insert a new row that describes the table. For example, suppose the schema is like this:</source>
          <target state="translated">インポスターテーブルを作成する1つの方法は、sqlite_masterテーブルを直接編集して、テーブルを記述する新しい行を挿入することです。例えば、スキーマが次のようなものだとします。</target>
        </trans-unit>
        <trans-unit id="84cd9c4bdeae83b60aa9ede1d4ab69d156255724" translate="yes" xml:space="preserve">
          <source>One way to create an imposter table is to directly edit the sqlite_schema table to insert a new row that describes the table. For example, suppose the schema is like this:</source>
          <target state="translated">偽装テーブルを作成する1つの方法は、sqlite_schemaテーブルを直接編集して、テーブルを記述する新しい行を挿入することです。例えば、スキーマが次のようなものだとします。</target>
        </trans-unit>
        <trans-unit id="5371a62fb713016b88bf9cbe1ee3e53f088627a9" translate="yes" xml:space="preserve">
          <source>One way to use sqlite3 in a shell script is to use &quot;echo&quot; or &quot;cat&quot; to generate a sequence of commands in a file, then invoke sqlite3 while redirecting input from the generated command file. This works fine and is appropriate in many circumstances. But as an added convenience, sqlite3 allows a single SQL command to be entered on the command line as a second argument after the database name. When the sqlite3 program is launched with two arguments, the second argument is passed to the SQLite library for processing, the query results are printed on standard output in list mode, and the program exits. This mechanism is designed to make sqlite3 easy to use in conjunction with programs like &quot;awk&quot;. For example:</source>
          <target state="translated">シェルスクリプトでsqlite3を使う一つの方法は、&quot;echo &quot;や &quot;cat &quot;を使ってファイルに一連のコマンドを生成し、生成されたコマンドファイルから入力をリダイレクトしながらsqlite3を起動することです。これはうまく動作し、多くの状況で適切です。しかし、追加の利便性として、sqlite3は単一のSQLコマンドをデータベース名の後の第二引数としてコマンドラインに入力することができます。sqlite3プログラムが2つの引数で起動されると、2番目の引数は処理のためにSQLiteライブラリに渡され、クエリ結果はリストモードで標準出力に印刷され、プログラムは終了します。この仕組みは、&quot;awk &quot;のようなプログラムと組み合わせてsqlite3を使いやすくするためのものです。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="c9f164cc934fc44dc3087a408a43d581d45a004f" translate="yes" xml:space="preserve">
          <source>One would get the same answer without the use of the R*Tree index using the following simpler query:</source>
          <target state="translated">R*Treeインデックスを使用しなくても、以下のより単純なクエリを使用して同じ答えを得ることができます。</target>
        </trans-unit>
        <trans-unit id="17f5a4fe2f5c62ecd81776d246b8c0c725190c25" translate="yes" xml:space="preserve">
          <source>One-Step Query Execution Interface</source>
          <target state="translated">ワンステップクエリ実行インタフェース</target>
        </trans-unit>
        <trans-unit id="aa3d3adac784c0d74a31276058a965e9e8ca9895" translate="yes" xml:space="preserve">
          <source>Online Backup API</source>
          <target state="translated">オンラインバックアップAPI</target>
        </trans-unit>
        <trans-unit id="84ecd14ddbadabe468f63832d803f2392f405f33" translate="yes" xml:space="preserve">
          <source>Online Backup API.</source>
          <target state="translated">オンラインバックアップAPI。</target>
        </trans-unit>
        <trans-unit id="df4435ab96f572a5ddc0d0575dab3a2326c426c1" translate="yes" xml:space="preserve">
          <source>Online Backup Object</source>
          <target state="translated">オンラインバックアップオブジェクト</target>
        </trans-unit>
        <trans-unit id="cf333df0d0137378797eeac3fd91be937936f09b" translate="yes" xml:space="preserve">
          <source>Only CPU cycle counts are being measured here. CPU cycle counts are a good proxy for energy consumption, but do not necessary correlate well with real-world timings. Time spent doing I/O is not reflected in the CPU cycle counts, and I/O time predominates in many SQLite usage scenarios.</source>
          <target state="translated">ここではCPUサイクルカウントのみを測定しています。CPUサイクルカウントはエネルギー消費量の良いプロキシですが、実際のタイミングとの相関性はあまり必要ありません。I/Oを行っていた時間はCPUサイクルカウントには反映されておらず、多くのSQLite使用シナリオではI/O時間が主に使用されています。</target>
        </trans-unit>
        <trans-unit id="d5604491374c9f17a80675ca75c6861a336b77e6" translate="yes" xml:space="preserve">
          <source>Only a single authorizer can be in place on a database connection at a time. Each call to sqlite3_set_authorizer overrides the previous call. Disable the authorizer by installing a NULL callback. The authorizer is disabled by default.</source>
          <target state="translated">一度に1つのデータベース接続に1つのオーソライザーだけを配置することができます。sqlite3_set_authorizerの各呼び出しは前の呼び出しを上書きします。NULLコールバックをインストールすることでオーサライザを無効にします。オーサライザはデフォルトでは無効になっています。</target>
        </trans-unit>
        <trans-unit id="478d5d49691bd8c6240a1fe276d18045c9e67957" translate="yes" xml:space="preserve">
          <source>Only a single progress handler may be defined at one time per &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;; setting a new progress handler cancels the old one. Setting parameter X to NULL disables the progress handler. The progress handler is also disabled by setting N to a value less than 1.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;ごとに一度に定義できる進行ハンドラは1つだけです。新しい進捗ハンドラを設定すると、古いハンドラがキャンセルされます。パラメータXをNULLに設定すると、進捗ハンドラが無効になります。Nを1未満の値に設定すると、進行状況ハンドラーも無効になります。</target>
        </trans-unit>
        <trans-unit id="94e56a9c57047e711c69e819b360a3dd7e101263" translate="yes" xml:space="preserve">
          <source>Only a single progress handler may be defined at one time per &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;; setting a new progress handler cancels the old one. Setting parameter X to NULL disables the progress handler. The progress handler is also disabled by setting N to a value less than 1.</source>
          <target state="translated">&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;ごとに一度に定義できる進行ハンドラは1つだけです。新しい進捗ハンドラを設定すると、古いハンドラがキャンセルされます。パラメータXをNULLに設定すると、進捗ハンドラが無効になります。Nを1未満の値に設定すると、進行状況ハンドラーも無効になります。</target>
        </trans-unit>
        <trans-unit id="7036e4ebe3282d4cd750dee2b265f33019cf27cb" translate="yes" xml:space="preserve">
          <source>Only changes made directly by the INSERT, UPDATE or DELETE statement are considered - auxiliary changes caused by &lt;a href=&quot;../lang_createtrigger&quot;&gt;triggers&lt;/a&gt;, &lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; or &lt;a href=&quot;../lang_replace&quot;&gt;REPLACE&lt;/a&gt; constraint resolution are not counted.</source>
          <target state="translated">INSERT、UPDATE、またはDELETEステートメントによって直接行われた変更のみが考慮され&lt;a href=&quot;../lang_createtrigger&quot;&gt;ます。トリガー&lt;/a&gt;、&lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;外部キーアクション、&lt;/a&gt;または&lt;a href=&quot;../lang_replace&quot;&gt;REPLACE&lt;/a&gt;制約の解決によって引き起こされた補助的な変更はカウントされません。</target>
        </trans-unit>
        <trans-unit id="c27ab9dbf00600e9d93b4dae249b72bd85740109" translate="yes" xml:space="preserve">
          <source>Only changes made directly by the INSERT, UPDATE or DELETE statement are considered - auxiliary changes caused by &lt;a href=&quot;lang_createtrigger&quot;&gt;triggers&lt;/a&gt;, &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; or &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; constraint resolution are not counted.</source>
          <target state="translated">INSERT、UPDATE、またはDELETEステートメントによって直接行われた変更のみが考慮され&lt;a href=&quot;lang_createtrigger&quot;&gt;ます。トリガー&lt;/a&gt;、&lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;外部キーアクション、&lt;/a&gt;または&lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt;制約の解決によって引き起こされた補助的な変更はカウントされません。</target>
        </trans-unit>
        <trans-unit id="9ca2d95ecc0496343a0233bd681510ca318c6946" translate="yes" xml:space="preserve">
          <source>Only columns a and b of the index would be usable. The d column would not be usable because column c is not constrained and there can be no gaps in the set of columns that usable by the index.</source>
          <target state="translated">インデックスのa列とb列だけが使用可能です。c列は制約を受けておらず、インデックスが使用可能な列の集合に隙間がないため、d列は使用できません。</target>
        </trans-unit>
        <trans-unit id="05736f4fee6c4c67dfd5428743f05e710b55053c" translate="yes" xml:space="preserve">
          <source>Only columns a, b, and c of the index would be usable. The d column would not be usable because it occurs to the right of c and c is constrained only by inequalities.</source>
          <target state="translated">インデックスの a,b,c 列だけが使用可能です。d列はcの右側にあり、cは不等式によってのみ制約されるため、使用できません。</target>
        </trans-unit>
        <trans-unit id="6822d83fba844c52182b6e2b1305124432ab29b8" translate="yes" xml:space="preserve">
          <source>Only create &lt;a href=&quot;tempfiles#masterjrnl&quot;&gt;master journal&lt;/a&gt; files if two or more attached databases are all modified, do not have &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to OFF, and do not have the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; set to OFF, MEMORY, or WAL.</source>
          <target state="translated">2つ以上の接続されたデータベースがすべて変更され、&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同期&lt;/a&gt;がOFFに設定されておらず、&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt;がOFF、MEMORY、またはWALに設定されていない場合にのみ、&lt;a href=&quot;tempfiles#masterjrnl&quot;&gt;マスタージャーナル&lt;/a&gt;ファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="9d1635246b5aeaad6de58e92e5095276c845c10a" translate="yes" xml:space="preserve">
          <source>Only create &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;statement journal&lt;/a&gt; files when their size exceeds a threshold. Otherwise the journal is held in memory and no I/O occurs. The threshold can be configured at compile-time using &lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; or at start-time using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;SQLITE_CONFIG_STMTJRNL_SPILL&lt;/a&gt;).</source>
          <target state="translated">サイズがしきい値を超えた場合にのみ、&lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;ステートメントジャーナル&lt;/a&gt;ファイルを作成します。それ以外の場合、ジャーナルはメモリに保持され、I / Oは発生しません。しきい値は、コンパイル時に&lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt;を使用して、または開始時に&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;SQLITE_CONFIG_STMTJRNL_SPILL&lt;/a&gt;）を使用して構成できます。</target>
        </trans-unit>
        <trans-unit id="04951ae9e91c50e633618b0424f4870112bf6e2c" translate="yes" xml:space="preserve">
          <source>Only create master journal files if two or more attached databases are all modified, do not have &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to OFF, and do not have the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; set to OFF, MEMORY, or WAL.</source>
          <target state="translated">2つ以上の接続されたデータベースがすべて変更され、&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同期&lt;/a&gt;がOFFに設定されておらず、&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt;がOFF、MEMORY、またはWALに設定されていない場合にのみ、マスタージャーナルファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="610003d6616c61d3e569880b1cf6337a8bfaac43" translate="yes" xml:space="preserve">
          <source>Only rows of the table for which the WHERE clause evaluates to true are included in the index. If the WHERE clause expression evaluates to NULL or to false for some rows of the table, then those rows are omitted from the index.</source>
          <target state="translated">WHERE句が真と評価されるテーブルの行のみがインデックスに含まれます。WHERE句式の評価値がNULLまたはFalseの場合、それらの行はインデックスから除外されます。</target>
        </trans-unit>
        <trans-unit id="255e530c466468dcdf3e2dbc7217cf60c632c517" translate="yes" xml:space="preserve">
          <source>Only terms of the vocabulary with a matching langid are searched. Hence, the same table can contain entries from multiple languages and only the requested language will be used. The default langid is 0.</source>
          <target state="translated">一致する言語の語彙の用語のみが検索されます。したがって、同じテーブルに複数の言語からのエントリを含めることができ、要求された言語のみが使用されます。デフォルトのlangidは0です。</target>
        </trans-unit>
        <trans-unit id="2ece13f71abf0bca8da38ece8f95957b023f2f28" translate="yes" xml:space="preserve">
          <source>Only the &quot;ll&quot; length modifier ever makes a difference for SQLite. And it only makes a difference when using the C-language interfaces.</source>
          <target state="translated">SQLite の場合、&quot;ll &quot;長の修飾子だけが違いを生むことがあります。そして、C 言語のインターフェイスを使用しているときだけ違いがあります。</target>
        </trans-unit>
        <trans-unit id="85148a6237828ed28c44695045ab73ff06e6fcad" translate="yes" xml:space="preserve">
          <source>Only the RENAME TABLE, ADD COLUMN, and RENAME COLUMN variants of the ALTER TABLE command are supported. Other kinds of ALTER TABLE operations such as DROP COLUMN, ALTER COLUMN, ADD CONSTRAINT, and so forth are omitted.</source>
          <target state="translated">ALTER TABLEコマンドのRENAME TABLE、ADD COLUMN、RENAME COLUMNのみサポートしています。DROP COLUMN、ALTER COLUMN、ADD CONSTRAINTなどの他の種類のALTER TABLE操作は省略されています。</target>
        </trans-unit>
        <trans-unit id="718ea1282b5847e8c3e9e8f8d5345c6ee50c38cc" translate="yes" xml:space="preserve">
          <source>Only the implicit version of the AND operator is supported. Specifying the string &quot;AND&quot; as part of a standard query syntax query is interpreted as a term query for the set of documents containing the term &quot;and&quot;.</source>
          <target state="translated">AND演算子の暗黙のバージョンだけがサポートされています。標準的なクエリ構文クエリの一部として文字列 &quot;AND &quot;を指定すると、用語 &quot;and &quot;を含む文書の集合に対する用語クエリとして解釈されます。</target>
        </trans-unit>
        <trans-unit id="1eda18e73564838ddd329dd3f15abb7d2f114fbe" translate="yes" xml:space="preserve">
          <source>Only the three core routines described in section 1.0 are required to use SQLite. But there are many other functions that provide useful interfaces. These extended routines are as follows:</source>
          <target state="translated">SQLiteを使用するために必要なのは、1.0節で説明した3つのコアルーチンのみです。しかし、有用なインターフェースを提供する他の多くの関数があります。これらの拡張ルーチンは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="97073c710caef6e8b97ed50f7242027a83850af5" translate="yes" xml:space="preserve">
          <source>Only unsigned integers are recognized. Plus and minus signs are ignored. Decimal points and exponential notation are ignored.</source>
          <target state="translated">符号なし整数のみが認識されます。プラスとマイナスの記号は無視されます。小数点および指数表記は無視されます。</target>
        </trans-unit>
        <trans-unit id="9ddd9d23f19b01af8d3915a7bfd11c89aef2d1d4" translate="yes" xml:space="preserve">
          <source>Only use indexes-on-expressions to optimize ORDER BY or GROUP BY if the COLLATE is correct. Ticket &lt;a href=&quot;https://sqlite.org/src/info/e20dd54ab0e4383&quot;&gt;e20dd54ab0e4383&lt;/a&gt;</source>
          <target state="translated">COLLATEが正しい場合にのみ、ORDERS-ON-EXPRESSIONSを使用してORDER BYまたはGROUP BYを最適化します。チケット&lt;a href=&quot;https://sqlite.org/src/info/e20dd54ab0e4383&quot;&gt;e20dd54ab0e4383&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c74dd7ced7cd4ea8002b3c96a9b1ecdff66b1e59" translate="yes" xml:space="preserve">
          <source>Opcode Name</source>
          <target state="translated">オペコード名</target>
        </trans-unit>
        <trans-unit id="1682c59856887894432baf4bb39e98c21d42d731" translate="yes" xml:space="preserve">
          <source>Opcode definitions</source>
          <target state="translated">オプコード定義</target>
        </trans-unit>
        <trans-unit id="313411b9bd1b97b8fcd666d91d350cb8e6bed0d1" translate="yes" xml:space="preserve">
          <source>Open A BLOB For Incremental I/O</source>
          <target state="translated">インクリメンタルI/O用のBLOBを開く</target>
        </trans-unit>
        <trans-unit id="beb2e15e058a69d62502daa1bdfb1095abeb86de" translate="yes" xml:space="preserve">
          <source>Open a cursor into the table to be queried.</source>
          <target state="translated">クエリ対象のテーブルにカーソルを開きます。</target>
        </trans-unit>
        <trans-unit id="7e8e851c144078264ee423ec854e116a3d7fdff4" translate="yes" xml:space="preserve">
          <source>Open a new cursor P1 that points to the same ephemeral table as cursor P2. The P2 cursor must have been opened by a prior &lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt; opcode. Only ephemeral cursors may be duplicated.</source>
          <target state="translated">カーソルP2と同じ一時テーブルを指す新しいカーソルP1を開きます。P2カーソルは、前の&lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt;オペコードによって開かれている必要があります。一時カーソルのみを複製できます。</target>
        </trans-unit>
        <trans-unit id="57454cf77dc40f8ad1e1086dd9c199e6c88ed771" translate="yes" xml:space="preserve">
          <source>Open a new cursor P1 to a transient table. The cursor is always opened read/write even if the main database is read-only. The ephemeral table is deleted automatically when the cursor is closed.</source>
          <target state="translated">トランジェントテーブルに新規カーソルP1をオープンします。メインデータベースが読み取り専用であっても、カーソルは常に読み書きで開かれます。エフェメラルテーブルはカーソルを閉じると自動的に削除されます。</target>
        </trans-unit>
        <trans-unit id="545bc19bf66be6511144aed187f1840c5a4278d1" translate="yes" xml:space="preserve">
          <source>Open a new cursor that points to a fake table that contains a single row of data. The content of that one row is the content of memory register P2. In other words, cursor P1 becomes an alias for the MEM_Blob content contained in register P2.</source>
          <target state="translated">1行のデータを含む偽のテーブルを指す新しいカーソルを開きます。その1行の内容は、メモリレジスタP2の内容です。つまり、カーソルP1は、レジスタP2に含まれるMEM_Blobの内容のエイリアスになります。</target>
        </trans-unit>
        <trans-unit id="135ddb8c48350a0a78c4aa223b6b8ae16522c7fd" translate="yes" xml:space="preserve">
          <source>Open a read-only cursor for the database table whose root page is P2 in a database file. The database file is determined by P3. P3==0 means the main database, P3==1 means the database used for temporary tables, and P3&amp;gt;1 means used the corresponding attached database. Give the new cursor an identifier of P1. The P1 values need not be contiguous but all P1 values should be small integers. It is an error for P1 to be negative.</source>
          <target state="translated">データベースファイルで、ルートページがP2であるデータベーステーブルの読み取り専用カーソルを開きます。データベースファイルはP3によって決定されます。P3 == 0はメインデータベースを意味し、P3 == 1は一時テーブルに使用されるデータベースを意味し、P3&amp;gt; 1は対応する接続​​データベースを使用することを意味します。新しいカーソルにP1の識別子を与えます。P1値は連続している必要はありませんが、すべてのP1値は小さい整数である必要があります。P1が負になるのはエラーです。</target>
        </trans-unit>
        <trans-unit id="84089bd01646e44fd57253086466eec04ccae47a" translate="yes" xml:space="preserve">
          <source>Open a read/write cursor named P1 on the table or index whose root page is P2 (or whose root page is held in register P2 if the OPFLAG_P2ISREG bit is set in P5 - see below).</source>
          <target state="translated">ルートページがP2であるテーブルまたはインデックス上にP1という名前の読み書きカーソルをオープンします(OPFLAG_P2ISREGビットがP5にセットされている場合は、そのルートページがレジスタP2に保持されています-以下を参照)。</target>
        </trans-unit>
        <trans-unit id="4063448157b3ab2686e1495793b9571ba748ea89" translate="yes" xml:space="preserve">
          <source>Open an RBU handle using the sqlite3rbu_open(T,A,S) function.</source>
          <target state="translated">sqlite3rbu_open(T,A,S)関数を使用してRBUハンドルを開きます。</target>
        </trans-unit>
        <trans-unit id="596a83fa51ee88b7bacaba491d0bd9269153f384" translate="yes" xml:space="preserve">
          <source>Open database connections using the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interfaces, as normal. Ordinary database files (without a checksum) will operate normally. Databases with checksums will return an SQLITE_IOERR_DATA error if a page is encountered that contains an invalid checksum.</source>
          <target state="translated">通常&lt;a href=&quot;c3ref/open&quot;&gt;どおり&lt;/a&gt;、&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;またはsqlite3_open_v2（）インターフェイスを使用してデータベース接続を開きます。通常のデータベースファイル（チェックサムなし）は正常に動作します。チェックサムのあるデータベースは、無効なチェックサムを含むページが検出された場合、SQLITE_IOERR_DATAエラーを返します。</target>
        </trans-unit>
        <trans-unit id="6423cf77a906b294f7ccb82649c19b9b21d337a4" translate="yes" xml:space="preserve">
          <source>Open file &quot;/home/fred/data.db&quot;. Use the special VFS &quot;unix-dotfile&quot; that uses dot-files in place of posix advisory locking.</source>
          <target state="translated">ファイル「/home/fred/data.db」を開きます。posixのアドバイザリロックの代わりにドットファイルを使用する特殊なVFS「unix-dotfile」を使用します。</target>
        </trans-unit>
        <trans-unit id="d23dfc68fcbe2b64c96946a59f2391f88d879ada" translate="yes" xml:space="preserve">
          <source>Open file &quot;data.db&quot; in the current directory for read-only access. Regardless of whether or not shared-cache mode is enabled by default, use a private cache.</source>
          <target state="translated">読み取り専用のアクセスのために、カレントディレクトリにあるファイル &quot;data.db &quot;を開きます。デフォルトで共有キャッシュモードが有効になっているかどうかに関わらず、プライベートキャッシュを使用します。</target>
        </trans-unit>
        <trans-unit id="32023375b26a0776fe1660f78af585c47d78b01e" translate="yes" xml:space="preserve">
          <source>Open the database file &quot;/home/fred/data.db&quot;.</source>
          <target state="translated">データベースファイル「/home/fred/data.db」を開きます。</target>
        </trans-unit>
        <trans-unit id="b140126e4bb0c579baba79fa4b78910264cad628" translate="yes" xml:space="preserve">
          <source>Open the database file and obtain a SHARED lock. If the SHARED lock cannot be obtained, fail immediately and return SQLITE_BUSY.</source>
          <target state="translated">データベースファイルを開き、SHAREDロックを取得します。SHARED ロックが取得できない場合は、直ちに失敗して SQLITE_BUSY を返します。</target>
        </trans-unit>
        <trans-unit id="1fdbee3b0460b37f393d93c476774730b651cdaf" translate="yes" xml:space="preserve">
          <source>Open the file &quot;data.db&quot; in the current directory.</source>
          <target state="translated">カレントディレクトリにある「data.db」というファイルを開きます。</target>
        </trans-unit>
        <trans-unit id="e305cdc0a6e58d2992d00df36114935a966f06eb" translate="yes" xml:space="preserve">
          <source>Open two cursors, one to each of the two tables being queried.</source>
          <target state="translated">2つのカーソルを開き、1つは問い合わせ先の2つのテーブルにそれぞれ1つずつ。</target>
        </trans-unit>
        <trans-unit id="db8828ea77768020acda7b34e1bdcfb01f4a650b" translate="yes" xml:space="preserve">
          <source>Open, release or rollback the savepoint named by parameter P4, depending on the value of P1. To open a new savepoint set P1==0 (SAVEPOINT_BEGIN). To release (commit) an existing savepoint set P1==1 (SAVEPOINT_RELEASE). To rollback an existing savepoint set P1==2 (SAVEPOINT_ROLLBACK).</source>
          <target state="translated">パラメータP4で指定されたセーブポイントをオープン、リリース、またはロールバックします。新規セーブポイントを開くには、P1==0 (SAVEPOINT_BEGIN)を設定します。既存のセーブポイントを解放(コミット)するには、P1==1 (SAVEPOINT_RELEASE)を設定します。既存のセーブポイントをロールバックするには、P1==2 (SAVEPOINT_ROLLBACK)を設定します。</target>
        </trans-unit>
        <trans-unit id="e54c6e14fb4a075fa699ffdaaaf395ff313982e8" translate="yes" xml:space="preserve">
          <source>OpenAutoindex</source>
          <target state="translated">OpenAutoindex</target>
        </trans-unit>
        <trans-unit id="4102c59c0ab3f6e830e46718de359a59f628ee07" translate="yes" xml:space="preserve">
          <source>OpenDup</source>
          <target state="translated">OpenDup</target>
        </trans-unit>
        <trans-unit id="ad5bdfbe38582d74f4e2d987d0014c4a061fc0bc" translate="yes" xml:space="preserve">
          <source>OpenEphemeral</source>
          <target state="translated">OpenEphemeral</target>
        </trans-unit>
        <trans-unit id="4a5d4d0e6cf7c26b571b8ed8b7d9e91f5a55707c" translate="yes" xml:space="preserve">
          <source>OpenPseudo</source>
          <target state="translated">OpenPseudo</target>
        </trans-unit>
        <trans-unit id="321f145cb1e3470cc293ca452256220e4b476cbf" translate="yes" xml:space="preserve">
          <source>OpenRead</source>
          <target state="translated">OpenRead</target>
        </trans-unit>
        <trans-unit id="3894e594709a936290c9439b10b580db3b56e3b5" translate="yes" xml:space="preserve">
          <source>OpenWrite</source>
          <target state="translated">OpenWrite</target>
        </trans-unit>
        <trans-unit id="10f17177db5db183ce11fbbf98483043f8f93d13" translate="yes" xml:space="preserve">
          <source>Openclose callback</source>
          <target state="translated">オープンクローズコールバック</target>
        </trans-unit>
        <trans-unit id="f1ba5b2c8dba45952ee1dd4e3e5587becf1e4832" translate="yes" xml:space="preserve">
          <source>Opening A New Database Connection</source>
          <target state="translated">新しいデータベース接続を開く</target>
        </trans-unit>
        <trans-unit id="8bea067fa84f98eb8cb08b76d377cd2759d84a48" translate="yes" xml:space="preserve">
          <source>Opening a New Connection</source>
          <target state="translated">新しい接続を開く</target>
        </trans-unit>
        <trans-unit id="0fcdc2f790b5b05c0b11e1b00c614a1147af7a65" translate="yes" xml:space="preserve">
          <source>Opening a Read-Only Transaction</source>
          <target state="translated">読み取り専用のトランザクションを開く</target>
        </trans-unit>
        <trans-unit id="8c328ea219e123938753dd011cc218695e36770e" translate="yes" xml:space="preserve">
          <source>Opening a connection.</source>
          <target state="translated">接続を開く。</target>
        </trans-unit>
        <trans-unit id="0a848c1fa6f5b691a8b43871dbf9920b32a63f8f" translate="yes" xml:space="preserve">
          <source>Opening a new database connection is a two-step process:</source>
          <target state="translated">新しいデータベース接続を開くには、2つのステップがあります。</target>
        </trans-unit>
        <trans-unit id="60a2e026abe5554a6164ccf369d3bdb712d462a6" translate="yes" xml:space="preserve">
          <source>Opening a read-only transaction.</source>
          <target state="translated">読み取り専用のトランザクションを開く。</target>
        </trans-unit>
        <trans-unit id="d0a97ec8f1b3b761b48ba3f0b5793b7b063cf28e" translate="yes" xml:space="preserve">
          <source>Opening a read-write transaction.</source>
          <target state="translated">読み書き可能なトランザクションをオープンします。</target>
        </trans-unit>
        <trans-unit id="5bef4a855a587c7ae88d0d6e7fbc4f0cf1d92d9c" translate="yes" xml:space="preserve">
          <source>Opening a statement transaction.</source>
          <target state="translated">ステートメント取引を開く。</target>
        </trans-unit>
        <trans-unit id="5f6fc2590106eab5d853e4838b574315ff3651ac" translate="yes" xml:space="preserve">
          <source>Operand P1 must be 0x7fffffff and P2 must positive.</source>
          <target state="translated">オペランドP1は0x7fffffff、P2は正でなければなりません。</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="653e79b2411d60c991c837c40648dc99da326979" translate="yes" xml:space="preserve">
          <source>Optimization: When doing an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; on a table with &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;, do not update the expression indexes if they do not refer to any of the columns of the table being updated.</source>
          <target state="translated">最適化：&lt;a href=&quot;expridx&quot;&gt;式&lt;/a&gt;にインデックスがあるテーブルで&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;を実行するとき、更新されるテーブルの列を参照していない場合は、式のインデックスを更新しないでください。</target>
        </trans-unit>
        <trans-unit id="a794f9704b3031ad0771d79793775c086e03f157" translate="yes" xml:space="preserve">
          <source>Optimizations to the sqlite_mprintf() routine.</source>
          <target state="translated">sqlite_mprintf()ルーチンの最適化。</target>
        </trans-unit>
        <trans-unit id="088089a3961fc329e20285999528f0da0604b13a" translate="yes" xml:space="preserve">
          <source>Optimize the &lt;a href=&quot;lang_corefunc#typeof&quot;&gt;typeof()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#length&quot;&gt;length()&lt;/a&gt; SQL functions so that they avoid unnecessary reading of database content from disk.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#typeof&quot;&gt;typeof（）&lt;/a&gt;および&lt;a href=&quot;lang_corefunc#length&quot;&gt;length（）&lt;/a&gt; SQL関数を最適化して、ディスクからのデータベースコンテンツの不要な読み取りを回避します。</target>
        </trans-unit>
        <trans-unit id="89ea4f0e94546aba0e6576de32f5af050f08375b" translate="yes" xml:space="preserve">
          <source>Optimizer does a better job of using indices to satisfy ORDER BY clauses that sort on the integer primary key</source>
          <target state="translated">オプティマイザーは、整数の主キーでソートするORDER BY句を満たすためにインデックスを使用することができるようになりました。</target>
        </trans-unit>
        <trans-unit id="d859dd72c637fafc6319ca0f4f6cb8c1fd01736f" translate="yes" xml:space="preserve">
          <source>Optimizer enhancement: &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; are automatically re-compiled when a binding on the RHS of a LIKE operator changes or when any range constraint changes under &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt;.</source>
          <target state="translated">オプティマイザの強化：LIKE演算子のRHSでのバインディングが変更されたとき、または&lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2で&lt;/a&gt;範囲制約が変更されたときに、&lt;a href=&quot;c3ref/stmt&quot;&gt;準備されたステートメント&lt;/a&gt;が自動的に再コンパイルされます。</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="6120d3ea8f989e319fa4157b88a6894abd99ea8b" translate="yes" xml:space="preserve">
          <source>Option 1:</source>
          <target state="translated">オプション1。</target>
        </trans-unit>
        <trans-unit id="787636b9cef675727f97423a49f2d6e8aeb5b354" translate="yes" xml:space="preserve">
          <source>Option 2:</source>
          <target state="translated">オプション2</target>
        </trans-unit>
        <trans-unit id="620a38bc45cce1e89bad8abed95cee233ec74ca8" translate="yes" xml:space="preserve">
          <source>Optional LIMIT and ORDER BY Clauses</source>
          <target state="translated">オプションの制限と ORDER BY 条項</target>
        </trans-unit>
        <trans-unit id="4a8101f15dc88fa6899984a679049286645dada8" translate="yes" xml:space="preserve">
          <source>Optional LIMIT and ORDER BY clauses</source>
          <target state="translated">オプションのLIMITとORDER BY句</target>
        </trans-unit>
        <trans-unit id="147fccad2acf5d54cf4c9bd90959d2b685bb12a8" translate="yes" xml:space="preserve">
          <source>Optional READ UNCOMMITTED isolation (instead of the default isolation level of SERIALIZABLE) and table level locking when database connections share a common cache.</source>
          <target state="translated">データベース接続が共通のキャッシュを共有している場合のREAD UNCOMMITTED隔離(デフォルトのSERIALIZABLE隔離レベルの代わりに)とテーブルレベルのロックをオプションで指定できます。</target>
        </trans-unit>
        <trans-unit id="99e39e3c25d749e303cfb0392ac6108be81a9ed0" translate="yes" xml:space="preserve">
          <source>Optionally, a &lt;a href=&quot;gencol&quot;&gt;generated column&lt;/a&gt; constraint.</source>
          <target state="translated">オプションで、&lt;a href=&quot;gencol&quot;&gt;生成された列&lt;/a&gt;制約。</target>
        </trans-unit>
        <trans-unit id="f3c4d258c19e0b0e32f1a0047f810a58bf67a8d7" translate="yes" xml:space="preserve">
          <source>Optionally, a PRIMARY KEY for the table. Both single column and composite (multiple column) primary keys are supported.</source>
          <target state="translated">オプションで、テーブルのPRIMARY KEY。シングルカラムとコンポジット(複数カラム)の両方の主キーがサポートされています。</target>
        </trans-unit>
        <trans-unit id="afb65b09ecb1abf655b3870806d0d663e9055759" translate="yes" xml:space="preserve">
          <source>Options understood by the &lt;b&gt;sqlite3&lt;/b&gt; command include:</source>
          <target state="translated">&lt;b&gt;sqlite3&lt;/b&gt;コマンドが理解できるオプションは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="e72184f55cc026514b7160d78c3c5aef63c2a050" translate="yes" xml:space="preserve">
          <source>Or</source>
          <target state="translated">Or</target>
        </trans-unit>
        <trans-unit id="1a5a89789f35d1adc160640f07b04eccb062e675" translate="yes" xml:space="preserve">
          <source>Or consider these identical queries:</source>
          <target state="translated">または、これらの同一のクエリを考えてみてください。</target>
        </trans-unit>
        <trans-unit id="16127303ea06cc226e15f6d081becfc0853f54f2" translate="yes" xml:space="preserve">
          <source>Or go the other way:</source>
          <target state="translated">それとも別の道を行くか。</target>
        </trans-unit>
        <trans-unit id="aa8e4bd6460fbb4edd20d4ab7cc84cb756c25fa7" translate="yes" xml:space="preserve">
          <source>Or on Windows with MSVC:</source>
          <target state="translated">またはMSVCを搭載したWindows上で。</target>
        </trans-unit>
        <trans-unit id="65cc0e4d32009c846d3d67b851864fc0e2100eac" translate="yes" xml:space="preserve">
          <source>Or optimization</source>
          <target state="translated">または最適化</target>
        </trans-unit>
        <trans-unit id="fbfd8b5435e1bb1225c27564f4e61467d6052b3a" translate="yes" xml:space="preserve">
          <source>Or perhaps the application would rather use the most recent checkinTime:</source>
          <target state="translated">あるいは、アプリケーションは最新のcheckinTimeを使用したいのかもしれません。</target>
        </trans-unit>
        <trans-unit id="2a55f1def49ba2cf28edd04aebe0ae914d6adc01" translate="yes" xml:space="preserve">
          <source>Or this:</source>
          <target state="translated">それともこれかな</target>
        </trans-unit>
        <trans-unit id="4adffe1f4f67467b27dd86bae1fcc140644a1e80" translate="yes" xml:space="preserve">
          <source>Or to be extra safe with a database and to force SQLite to assume the database lacks powersafe overwrite, open it using</source>
          <target state="translated">また、データベースの安全性を高めるために、SQLiteにデータベースの上書きを強制的に行わせるには、以下のようにしてデータベースを開きます。</target>
        </trans-unit>
        <trans-unit id="cb4a4efee56406c1c1e484f479dafaa1ce0d3fdd" translate="yes" xml:space="preserve">
          <source>Or using &lt;a href=&quot;cli#fileio&quot;&gt;file I/O functions&lt;/a&gt;, you can extract elements of the ZIP archive:</source>
          <target state="translated">または、&lt;a href=&quot;cli#fileio&quot;&gt;ファイルI / O関数&lt;/a&gt;を使用して、ZIPアーカイブの要素を抽出できます。</target>
        </trans-unit>
        <trans-unit id="beb6e4abd1b3ea2eadafe45050288632422b5468" translate="yes" xml:space="preserve">
          <source>Or,</source>
          <target state="translated">Or,</target>
        </trans-unit>
        <trans-unit id="66d567cd524d8ab999d4e199670d77fab66ce1bc" translate="yes" xml:space="preserve">
          <source>Or, from the SQLite shell tool (the &lt;a href=&quot;cli#fileio&quot;&gt;readfile()&lt;/a&gt; function reads the contents of a file from the file-system and returns it as a blob):</source>
          <target state="translated">または、SQLiteシェルツールから（&lt;a href=&quot;cli#fileio&quot;&gt;readfile（）&lt;/a&gt;関数はファイルシステムからファイルの内容を読み取り、blobとして返します）：</target>
        </trans-unit>
        <trans-unit id="5555ca89e43c2c41b68ce29dd846f696f04f9021" translate="yes" xml:space="preserve">
          <source>Or, if argument zTab is NULL, then changes are recorded for all tables in the database. If additional tables are added to the database (by executing &quot;CREATE TABLE&quot; statements) after this call is made, changes for the new tables are also recorded.</source>
          <target state="translated">あるいは、引数zTabがNULLの場合、データベース内のすべてのテーブルに対して変更が記録されます。この呼び出しの後に(CREATE TABLE文を実行して)追加のテーブルがデータベースに追加された場合、新しいテーブルの変更も記録されます。</target>
        </trans-unit>
        <trans-unit id="0aca97133f8a0b1812de40afe8dc2efdb01e49c8" translate="yes" xml:space="preserve">
          <source>Or, if double-quoted string literals are disabled by default, but need to be selectively enabled for some historical database connections, that can be done using the same C-code as shown above except with the third parameter changed from 0 to 1.</source>
          <target state="translated">あるいは、二重引用符で囲まれた文字列リテラルがデフォルトでは無効になっているが、過去のデータベース接続のために選択的に有効にする必要がある場合、3番目のパラメータを0から1に変更する以外は、上記と同じCコードを使用して行うことができます。</target>
        </trans-unit>
        <trans-unit id="322edc10740abf86eb6c1728491b5451dec39f1d" translate="yes" xml:space="preserve">
          <source>Or, if sqlite3.c is compiled using some other build system, by arranging for the SQLITE_ENABLE_FTS5 pre-processor symbol to be defined.</source>
          <target state="translated">あるいは、sqlite3.cが他のビルドシステムを使ってコンパイルされている場合、SQLITE_ENABLE_FTS5プリプロセッサシンボルが定義されているように手配してください。</target>
        </trans-unit>
        <trans-unit id="658f77f8eef94489e4209dc1e50f66504ceb72eb" translate="yes" xml:space="preserve">
          <source>Or, if the argument attached to the REINDEX identifies a specific database table, then all indices attached to the database table are rebuilt. If it identifies a specific database index, then just that index is recreated.</source>
          <target state="translated">または、REINDEXに付けられた引数が特定のデータベース・テーブルを特定する場合、データベース・テーブルに付けられたすべてのインデックスが再構築されます。特定のデータベースインデックスを特定した場合は、そのインデックスだけが再構築されます。</target>
        </trans-unit>
        <trans-unit id="60a5aae7483ffe81235af01c0cffa5d4ff23cd22" translate="yes" xml:space="preserve">
          <source>Or, if the table is also a &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless table&lt;/a&gt;, then the following apply:</source>
          <target state="translated">または、テーブルが&lt;a href=&quot;fts5#contentless_tables&quot;&gt;コンテンツレステーブル&lt;/a&gt;でもある場合は、次のようになります。</target>
        </trans-unit>
        <trans-unit id="aa1077574bb502a8689f667cb965b8e30b1c1e85" translate="yes" xml:space="preserve">
          <source>Or, if using the autoconf build system, pass the --enable-session option to the configure script.</source>
          <target state="translated">または、autoconf ビルドシステムを使用している場合は、configure スクリプトに --enable-session オプションを渡します。</target>
        </trans-unit>
        <trans-unit id="0ff802a22b003329b02ab696a2c315faad2a0e85" translate="yes" xml:space="preserve">
          <source>Or, multiple presentations could be stored within the same document.</source>
          <target state="translated">あるいは、複数のプレゼンテーションを同一ドキュメント内に保存することもできます。</target>
        </trans-unit>
        <trans-unit id="d354f2e196d0e9cdbbdd8e5133631fe7bd7c69f7" translate="yes" xml:space="preserve">
          <source>Or, the same content can be read using:</source>
          <target state="translated">または、同じ内容を使って読むことができます。</target>
        </trans-unit>
        <trans-unit id="e7aee41fb363d46e588ad49a1b5591b283e863a6" translate="yes" xml:space="preserve">
          <source>Or, to list all changes to one particular account ($xyz) in order of decreasing magnitude, one can write:</source>
          <target state="translated">あるいは、ある特定のアカウント($xyz)へのすべての変更を小さい順にリストアップするには、次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="8a1681e612a2025087b703fdf1f8f617e506b053" translate="yes" xml:space="preserve">
          <source>Oracle</source>
          <target state="translated">Oracle</target>
        </trans-unit>
        <trans-unit id="6e8727d6e68eed5d20f3fa889a8e8b2bd24438db" translate="yes" xml:space="preserve">
          <source>Orders of magnitude performance improvement for &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; on very large tables.</source>
          <target state="translated">非常に大きなテーブルでの&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;の桁違いのパフォーマンス向上。</target>
        </trans-unit>
        <trans-unit id="6ce3fb54d989f83f97843b164388df9c55d52716" translate="yes" xml:space="preserve">
          <source>Ordinary Common Table Expressions</source>
          <target state="translated">通常の共通表式</target>
        </trans-unit>
        <trans-unit id="628b6d597a836775d3c57cc85ac20362e62df83f" translate="yes" xml:space="preserve">
          <source>Ordinary SQL statements are free-form, and can be spread across multiple lines, and can have whitespace and comments anywhere. Dot-commands are more restrictive:</source>
          <target state="translated">通常のSQL文は自由形式で、複数の行にまたがることができ、どこでも空白とコメントを持つことができます。ドットコマンドはより制限があります。</target>
        </trans-unit>
        <trans-unit id="410efca163172750b4e7d07d3df715195f75df04" translate="yes" xml:space="preserve">
          <source>Ordinary common table expressions</source>
          <target state="translated">通常の一般的なテーブル表現</target>
        </trans-unit>
        <trans-unit id="d3bfeb484e7ad7fe55b8281bb0d45da13e3151eb" translate="yes" xml:space="preserve">
          <source>Original content of the page prior to the start of the transaction</source>
          <target state="translated">取引開始前のページのオリジナル内容</target>
        </trans-unit>
        <trans-unit id="53583b5aa5fa79b35a37fe615fa3d9b1eece6568" translate="yes" xml:space="preserve">
          <source>Other C-libraries that process complex structured inputs will routinely be asked to deal with unvetted inputs from untrusted sources. Libraries like libjpeg, or libzip, or OpenSSL are handed input streams that come directly from potentially hostile agents.</source>
          <target state="translated">複雑な構造化された入力を処理する他の C ライブラリは、信頼されていないソースからのベットされていない入力を処理するように日常的に要求されます。libjpeg や libzip、OpenSSL のようなライブラリは、潜在的に敵対的なエージェントから直接送られてくる入力ストリームを渡されます。</target>
        </trans-unit>
        <trans-unit id="220b92a9851d65e3f5763bc585c592d7a14215e7" translate="yes" xml:space="preserve">
          <source>Other Issues</source>
          <target state="translated">その他の問題</target>
        </trans-unit>
        <trans-unit id="286c105cf7e1fc8242c5f069e4037b0e5e35102f" translate="yes" xml:space="preserve">
          <source>Other SQL database engines tend to store data as a large collection of files. Often these files are in a standard location that only the database engine itself can access. This makes the data more secure, but also makes it harder to access. Some SQL database engines provide the option of writing directly to disk and bypassing the filesystem all together. This provides added performance, but at the cost of considerable setup and maintenance complexity.</source>
          <target state="translated">他のSQLデータベースエンジンは、データを大きなファイルの集合体として保存する傾向があります。多くの場合、これらのファイルはデータベースエンジン自身だけがアクセスできる標準的な場所にあります。これによりデータはより安全になりますが、アクセスが難しくなります。SQLデータベースエンジンの中には、ディスクに直接書き込んでファイルシステムをバイパスするオプションを提供しているものもあります。これはパフォーマンスを向上させますが、セットアップやメンテナンスの複雑さを犠牲にしています。</target>
        </trans-unit>
        <trans-unit id="5210f14e159e526b00e7b67ae5e00a7489e472f8" translate="yes" xml:space="preserve">
          <source>Other and more complex extensions can be found in subfolders under &lt;a href=&quot;https://www.sqlite.org/src/file/ext&quot;&gt;ext/&lt;/a&gt; other than ext/misc/.</source>
          <target state="translated">その他、より複雑な拡張は、下のサブフォルダに見つけることができ&lt;a href=&quot;https://www.sqlite.org/src/file/ext&quot;&gt;内線/&lt;/a&gt;内線/ miscの/以外。</target>
        </trans-unit>
        <trans-unit id="a5885d7d219a9dd314e80ea53c10a7870f48702f" translate="yes" xml:space="preserve">
          <source>Other compile-time options such as using -O3 instead of -Os or using &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=0&lt;/a&gt; and/or some of the other &lt;a href=&quot;compile#rcmd&quot;&gt;recommended compile-time options&lt;/a&gt; might help SQLite to run even faster relative to direct filesystem reads.</source>
          <target state="translated">このよう-Osの代わりに-O3を使用して、または使用などの他のコンパイル時のオプション&lt;a href=&quot;compile#threadsafe&quot;&gt;0 = -DSQLITE_THREADSAFE&lt;/a&gt;および/または他のいくつかの&lt;a href=&quot;compile#rcmd&quot;&gt;推奨コンパイル時のオプションは、&lt;/a&gt; SQLiteのは、ファイルシステムが読み込み指示し、さらに高速相対実行するために役立つかもしれないが。</target>
        </trans-unit>
        <trans-unit id="68a8c532629b4cb41be7b1e40786ac6ad241781e" translate="yes" xml:space="preserve">
          <source>Other database engines may run great once you get them going. But doing the initial installation and configuration can often be intimidating.</source>
          <target state="translated">他のデータベースエンジンは、一度起動してしまえば素晴らしい動作をするかもしれません。しかし、最初のインストールと設定を行うことは、しばしば威圧的になることがあります。</target>
        </trans-unit>
        <trans-unit id="0d3a3415efe071d534d2ab15cd7fe976055daeb3" translate="yes" xml:space="preserve">
          <source>Other entries in the cost table specific transforms for particular characters. The cost of specific transforms should be less than the default costs, or else the default costs will take precedence and the specific transforms will never be used.</source>
          <target state="translated">特定のキ ャ ラ ク タ に対す る 特定の変換を コ ス ト テーブル内の他の項目。そうでなければ、デフォルトのコストが優先され、特定の変換は決して使われません。</target>
        </trans-unit>
        <trans-unit id="0ac3c9882a4b70189ad1bfa57e91f5a096b4d423" translate="yes" xml:space="preserve">
          <source>Other examples:</source>
          <target state="translated">その他の例。</target>
        </trans-unit>
        <trans-unit id="cae24656c6711756dea7bb8cd35f3afb8c810eb8" translate="yes" xml:space="preserve">
          <source>Other experimental memory allocators might be added in future releases of SQLite. One may anticipate that these will be called memsys7, memsys8, and so forth.</source>
          <target state="translated">SQLite の将来のリリースでは、他の実験的なメモリアロケータが追加されるかもしれません。これらは memsys7 や memsys8 などと呼ばれるようになると予想されます。</target>
        </trans-unit>
        <trans-unit id="10c1a85e8f6e1ba9ad67291c0e509d27f0146a7c" translate="yes" xml:space="preserve">
          <source>Other important bug fixes</source>
          <target state="translated">その他の重要なバグ修正</target>
        </trans-unit>
        <trans-unit id="eafff73d48037ade49167d838ce6e1b6a891fb16" translate="yes" xml:space="preserve">
          <source>Other information fields of the sqlite3_rtree_query_info structure are available for use by the xQueryFunc callback, if desired. The iRowid field is the rowid (the first of the 3 to 11 columns in the R*Tree) for the element being considered. iRowid is only valid for leaves. The eParentWithin and rParentScore values are copies of the eWithin and rScore values from the containing subtree of the current row. The anQueue field is an array of mxLevel+1 unsigned integers that tell the current number of elements in the priority queue at each level.</source>
          <target state="translated">sqlite3_rtree_query_info構造体の他の情報フィールドは、必要に応じてxQueryFuncコールバックで使用することができます。iRowidフィールドは、考慮される要素のrowid(R*Treeの3~11列の最初の列)です。eParentWithin値とrParentScore値は、現在の行のサブツリーのeWithin値とrScore値のコピーです。anQueueフィールドは、各レベルでの優先度キューの現在の要素数を示すmxLevel+1の符号なし整数の配列です。</target>
        </trans-unit>
        <trans-unit id="ac116740090073aa7d395dd931c8587b7e5ed819" translate="yes" xml:space="preserve">
          <source>Other kinds of constraints may be used and will work, but other constraints will be checked individually for each row and will not be optimized (at least not initially). All constraint checking is completely automatic regardless of whether or not optimization occurs. The optimization referred to in this bullet point is a performance consideration only. The same result is obtained regardless of whether or not the query is optimized.</source>
          <target state="translated">他の種類の制約を使用しても動作しますが、他の制約は行ごとに個別にチェックされ、最適化は行われません(少なくとも最初は行われません)。最適化が行われるかどうかに関わらず、すべての制約チェックは完全に自動で行われます。この箇条書きで言及されている最適化は、性能のみを考慮したものです。クエリが最適化されているかどうかに関わらず、同じ結果が得られます。</target>
        </trans-unit>
        <trans-unit id="aea1c45528f91c41cd64bff7bc4b9fe5c5d9e390" translate="yes" xml:space="preserve">
          <source>Other languages like Java, Perl, Python, and TCL typically translate the program source text into bytecode. This bytecode is then run through an interpreter that reads the bytecode and carries out the desired operations. SQLite uses this bytecode approach. If you preceed any SQL statement with the &quot;&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;&quot; keyword in SQLite, it will show you the bytecode that is generated rather than run the bytecode.</source>
          <target state="translated">Java、Perl、Python、TCLなどの他の言語は、通常、プログラムのソーステキストをバイトコードに変換します。次に、このバイトコードは、バイトコードを読み取り、必要な操作を実行するインタープリターを介して実行されます。SQLiteはこのバイトコードアプローチを使用します。SQLiteで「&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;」キーワードを使用してSQLステートメントの前に置くと、バイトコードを実行するのではなく、生成されたバイトコードが表示されます。</target>
        </trans-unit>
        <trans-unit id="808f70785d1ef92ea5c6148eaa9481e6d0e14aa1" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt; and &lt;a href=&quot;../rescode&quot;&gt;Result Codes&lt;/a&gt;.</source>
          <target state="translated">その他のリスト：&lt;a href=&quot;constlist&quot;&gt;定数&lt;/a&gt;と&lt;a href=&quot;funclist&quot;&gt;関数&lt;/a&gt;および&lt;a href=&quot;../rescode&quot;&gt;結果コード&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="254b17e4c2182837b7ef0fdd5b3824e226f2c5a8" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt;.</source>
          <target state="translated">その他のリスト：&lt;a href=&quot;constlist&quot;&gt;定数&lt;/a&gt;と&lt;a href=&quot;funclist&quot;&gt;関数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f2e591c11c09005f92f16a4e53401bee7662b02" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt; and &lt;a href=&quot;../rescode&quot;&gt;Result Codes&lt;/a&gt;</source>
          <target state="translated">その他のリスト：&lt;a href=&quot;constlist&quot;&gt;定数&lt;/a&gt;と&lt;a href=&quot;objlist&quot;&gt;オブジェクト&lt;/a&gt;、および&lt;a href=&quot;../rescode&quot;&gt;結果コード&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="710d410006003e6c96fa23b1a96739384d30f239" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt;.</source>
          <target state="translated">その他のリスト：&lt;a href=&quot;constlist&quot;&gt;定数&lt;/a&gt;と&lt;a href=&quot;objlist&quot;&gt;オブジェクト&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dc0c16f3fd55dac69e3748a6c043c6447d6ab575" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt; and &lt;a href=&quot;../rescode&quot;&gt;Result Codes&lt;/a&gt;.</source>
          <target state="translated">その他のリスト：&lt;a href=&quot;objlist&quot;&gt;オブジェクト&lt;/a&gt;と&lt;a href=&quot;funclist&quot;&gt;関数&lt;/a&gt;および&lt;a href=&quot;../rescode&quot;&gt;結果コード&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce8676972cf44ad111328d5252187ad79820f8b7" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt;.</source>
          <target state="translated">その他のリスト：&lt;a href=&quot;objlist&quot;&gt;オブジェクト&lt;/a&gt;と&lt;a href=&quot;funclist&quot;&gt;関数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6e05129b6c75ff832aa70dbb2deb9f7c3bddb6dc" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes</source>
          <target state="translated">その他のマイナーなバグ修正</target>
        </trans-unit>
        <trans-unit id="d4fc03a4fb1eb22ede8954ef99eea86a034ae6d2" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and documentation enhancements</source>
          <target state="translated">その他のマイナーなバグ修正とドキュメントの強化</target>
        </trans-unit>
        <trans-unit id="890b3d475caba8d5bd7557f9c475d8af3c752a15" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and documentation enhancements.</source>
          <target state="translated">その他のマイナーなバグ修正とドキュメントの強化。</target>
        </trans-unit>
        <trans-unit id="aa1b8c87b3d167a75e9df291742b29d3051fb50c" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and performance enhancements.</source>
          <target state="translated">その他、細かなバグ修正とパフォーマンスの向上。</target>
        </trans-unit>
        <trans-unit id="0fa68e95547b847335553befa0f2cb7b67624587" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and performance optimizations.</source>
          <target state="translated">その他、マイナーなバグフィックスとパフォーマンスの最適化。</target>
        </trans-unit>
        <trans-unit id="1057a4540e5ed3386909678e9ca548cf6300a507" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes in preparation for the first stable release of version 3.3</source>
          <target state="translated">バージョン3.3の最初の安定版リリースに向けて、その他のマイナーなバグ修正を行いました。</target>
        </trans-unit>
        <trans-unit id="f58ff693cc659b1eb66fa3445ac112f3a975e0d7" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes.</source>
          <target state="translated">その他、細かなバグ修正。</target>
        </trans-unit>
        <trans-unit id="3d1e22329a4cb1219246e265a7a252a723c9d5fa" translate="yes" xml:space="preserve">
          <source>Other minor changes and enhancements.</source>
          <target state="translated">その他、細かい変更や機能強化を行っています。</target>
        </trans-unit>
        <trans-unit id="251ead6fb529a54fa107bbdc4f76c0af651e9179" translate="yes" xml:space="preserve">
          <source>Other minor compiler-warning fixes and whatnot.</source>
          <target state="translated">その他、マイナーなコンパイラの警告の修正など。</target>
        </trans-unit>
        <trans-unit id="deee6da4efcaf54f2a7bee650d4c13bb508dfa45" translate="yes" xml:space="preserve">
          <source>Other minor documentation and makefile changes and bug fixes.</source>
          <target state="translated">その他の細かいドキュメントとmakefileの変更とバグ修正。</target>
        </trans-unit>
        <trans-unit id="031aa8e8c99846cb30787089a75b424566d207ca" translate="yes" xml:space="preserve">
          <source>Other minor tweaks to improve the quality of &lt;a href=&quot;opcode&quot;&gt;VDBE&lt;/a&gt; code.</source>
          <target state="translated">&lt;a href=&quot;opcode&quot;&gt;VDBE&lt;/a&gt;コードの品質を改善するためのその他のマイナーな調整。</target>
        </trans-unit>
        <trans-unit id="8b05e7277715773ceabf87f5e50fad5de6b24dd9" translate="yes" xml:space="preserve">
          <source>Other miscellaneous bug fixes</source>
          <target state="translated">その他の雑多なバグ修正</target>
        </trans-unit>
        <trans-unit id="5d73e7d5d87f0b601b3cbf8f19cc97602a0f29c4" translate="yes" xml:space="preserve">
          <source>Other miscellaneous bug fixes.</source>
          <target state="translated">その他雑なバグ修正。</target>
        </trans-unit>
        <trans-unit id="4b8124041770cac5d89ae555b4ac03153c37ffc1" translate="yes" xml:space="preserve">
          <source>Other miscellaneous enhancements such as loop unrolling.</source>
          <target state="translated">その他、ループ解除などの雑な強化。</target>
        </trans-unit>
        <trans-unit id="6f62eac50d6703d3917c9f2154f9f77dce98abcd" translate="yes" xml:space="preserve">
          <source>Other miscellaneous micro-optimizations for improved performance and reduced memory usage.</source>
          <target state="translated">その他、性能向上やメモリ使用量削減のための雑多なマイクロ最適化。</target>
        </trans-unit>
        <trans-unit id="26485a453cc99f6d07c9ad5f2979b799b10596af" translate="yes" xml:space="preserve">
          <source>Other miscellaneous minor bug fixes.</source>
          <target state="translated">その他、雑な細かいバグ修正。</target>
        </trans-unit>
        <trans-unit id="583fac43540a1c8647f7a52c63c6d87ee3c57112" translate="yes" xml:space="preserve">
          <source>Other miscellaneous performance enhancements.</source>
          <target state="translated">その他雑な性能強化。</target>
        </trans-unit>
        <trans-unit id="d5335cc4f60749bd941dc9764ef3c6855a7a176b" translate="yes" xml:space="preserve">
          <source>Other more familiar database engines run great once you get them going. But doing the initial installation and configuration can be intimidatingly complex.</source>
          <target state="translated">他のより馴染みのあるデータベースエンジンは、一度起動すると素晴らしい動作をします。しかし、最初のインストールと設定を行うことは、威圧的に複雑になることがあります。</target>
        </trans-unit>
        <trans-unit id="d62a6e61f5dec5bfc458e9cb92c78c02e716a2af" translate="yes" xml:space="preserve">
          <source>Other output modes include &quot;html&quot;, &quot;json&quot;, and &quot;tcl&quot;. Try these yourself to see what they do.</source>
          <target state="translated">他の出力モードには、&quot;html&quot;、&quot;json&quot;、&quot;tcl &quot;があります。これらが何をするかは、自分で試してみてください。</target>
        </trans-unit>
        <trans-unit id="453575f6d5ccd906017a354a3747a73c275dcbf4" translate="yes" xml:space="preserve">
          <source>Other pages that talk about Fossil and Git include:</source>
          <target state="translated">他にも、FossilとGitについて語っているページがあります。</target>
        </trans-unit>
        <trans-unit id="1691c79ed589685ad615d8d10ce5d4a24f7887ad" translate="yes" xml:space="preserve">
          <source>Other performance improvements. Uses about &lt;a href=&quot;cpu&quot;&gt;6.5% fewer CPU cycles&lt;/a&gt;.</source>
          <target state="translated">その他のパフォーマンスの改善。&lt;a href=&quot;cpu&quot;&gt;CPUサイクル&lt;/a&gt;を約6.5％削減します。</target>
        </trans-unit>
        <trans-unit id="53a9f15c17fc6f690db9ec48e6c595c7787f86a9" translate="yes" xml:space="preserve">
          <source>Other performance optimizations:</source>
          <target state="translated">その他のパフォーマンスの最適化。</target>
        </trans-unit>
        <trans-unit id="a62bf7250068b9b0c4a25d2045a53dbb9795b912" translate="yes" xml:space="preserve">
          <source>Other programming languages sometimes claim to be &quot;as fast as C&quot;. But no other language claims to be faster than C for general-purpose programming, because none are.</source>
          <target state="translated">他のプログラミング言語は「Cと同じくらい速い」と主張することがあります。しかし、汎用プログラミングにおいてCよりも速いと主張する言語は他にはありません。</target>
        </trans-unit>
        <trans-unit id="400864fb9a5435081d0153c603d26034407232fd" translate="yes" xml:space="preserve">
          <source>Other relation database engines also implement UPDATE-FROM, but because the construct is not part of the SQL standards, each product implements UPDATE-FROM differently. The SQLite implementation strives to be compatible with PostgreSQL. The SQL Server and MySQL implementations of the same idea work a little differently.</source>
          <target state="translated">他のリレーションデータベースエンジンもUPDATE-ROMを実装していますが、この構文はSQL標準の一部ではないため、製品ごとにUPDATE-ROMの実装が異なります。SQLiteの実装はPostgreSQLとの互換性を保つように努力しています。同じ考えのSQL ServerとMySQLの実装は、少し違った動作をします。</target>
        </trans-unit>
        <trans-unit id="b724fba24bcbd81609e47345dfce9dfa38bb53b6" translate="yes" xml:space="preserve">
          <source>Other similar tree-display routines include:</source>
          <target state="translated">他の類似したツリー表示ルーチンには、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="eb0b09bd0abc9cbcebf776931eb89745e9f2f6c6" translate="yes" xml:space="preserve">
          <source>Other small bug fixes and optimizations.</source>
          <target state="translated">その他の小さなバグ修正と最適化。</target>
        </trans-unit>
        <trans-unit id="ce257a3574985ec3c0e88eff4d14f53603f86d62" translate="yes" xml:space="preserve">
          <source>Other systems sometimes use assert(X) in a way that is similar to the use of ALWAYS(X) or NEVER(X) in SQLite. Developers will add an assert(X) as a &lt;a href=&quot;https://blog.regehr.org/archives/1576&quot;&gt;tacit acknowledgement that they do not fully believe that X is always true&lt;/a&gt;. We believe that this use of assert(X) is wrong and violates the intent and purpose of having assert(X) available in C in the first place. An assert(X) should not be seen as a safety-net or top-rope used to guard against mistakes. Nor is assert(X) appropriate for defense-in-depth. An ALWAYS(X) or NEVER(X) macro, or something similar, should be used in those cases because ALWAYS(X) or NEVER(X) will be followed by code to actually deal with the problem when the programmers reasoning turns out to be wrong. Since the code that follows ALWAYS(X) or NEVER(X) is untested, it should be something very simple, like a &quot;return&quot; statement, that is easily verified by inspection.</source>
          <target state="translated">他のシステムでは、SQLiteでのALWAYS（X）またはNEVER（X）の使用と同様の方法でassert（X）を使用することがあります。開発者は&lt;a href=&quot;https://blog.regehr.org/archives/1576&quot;&gt;、Xが常に真であると完全には信じていない&lt;/a&gt;という暗黙の了解として、assert（X）を追加します。このassert（X）の使用は誤りであり、最初にCでassert（X）を使用できるようにする意図と目的に違反すると私たちは考えています。assert（X）は、ミスを防ぐために使用されるセーフティネットまたはトップロープと見なされるべきではありません。また、assert（X）は多層防御に適していません。ALWAYS（X）またはNEVER（X）マクロ、または類似の何かがこれらのケースで使用されるべきです間違っている。ALWAYS（X）またはNEVER（X）に続くコードはテストされていないため、「return」ステートメントのように、検査によって簡単に検証できる非常に単純なコードにする必要があります。</target>
        </trans-unit>
        <trans-unit id="34d2c9c7d77d063050411b9cf0d5ad05916eb325" translate="yes" xml:space="preserve">
          <source>Otherwise, an expression has no affinity.</source>
          <target state="translated">そうでなければ、式は親和性を持たない。</target>
        </trans-unit>
        <trans-unit id="6917a7f5da3062b0cb87b819a1b98dde64d2060e" translate="yes" xml:space="preserve">
          <source>Otherwise, if no error occurs, &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush()&lt;/a&gt; returns SQLITE_OK.</source>
          <target state="translated">それ以外の場合、エラーが発生しなければ、&lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush（）&lt;/a&gt;はSQLITE_OKを返します。</target>
        </trans-unit>
        <trans-unit id="63ffff1a975b81be129a4faecffea464b53159fd" translate="yes" xml:space="preserve">
          <source>Otherwise, if no error occurs, &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush()&lt;/a&gt; returns SQLITE_OK.</source>
          <target state="translated">それ以外の場合、エラーが発生しなければ、&lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush（）&lt;/a&gt;はSQLITE_OKを返します。</target>
        </trans-unit>
        <trans-unit id="f4554128dd35917d0080717168dbd2c249f00b56" translate="yes" xml:space="preserve">
          <source>Otherwise, if the ORDER BY expression is a column or an alias of an expression that is a column, then the default collation sequence for the column is used.</source>
          <target state="translated">そうでなければ、ORDER BY式が列または列である式のエイリアスである場合、列のデフォルトの照合順序が使用されます。</target>
        </trans-unit>
        <trans-unit id="7e53078a08397e14f15e969e1f704be9f2cd8b70" translate="yes" xml:space="preserve">
          <source>Otherwise, if the ORDER BY expression is an alias to an expression that has been assigned a collation sequence using the postfix &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, then the collation sequence assigned to the aliased expression is used.</source>
          <target state="translated">それ以外の場合、ORDER BY式が、後&lt;a href=&quot;lang_expr#collateop&quot;&gt;置COLLATE演算子&lt;/a&gt;を使用して照合シーケンスが割り当てられた式のエイリアスである場合、エイリアスされた式に割り当てられた照合シーケンスが使用されます。</target>
        </trans-unit>
        <trans-unit id="16e19790e123dd698bb68d8acfc3c250ddf0f26c" translate="yes" xml:space="preserve">
          <source>Otherwise, if the ORDER BY expression is any other expression, it is evaluated and the returned value used to order the output rows. If the SELECT statement is a simple SELECT, then an ORDER BY may contain any arbitrary expressions. However, if the SELECT is a compound SELECT, then ORDER BY expressions that are not aliases to output columns must be exactly the same as an expression used as an output column.</source>
          <target state="translated">そうでなければ、ORDER BY式が他の式である場合、それが評価され、返された値が出力行の順序付けに使用されます。SELECT文が単純なSELECTの場合、ORDER BYは任意の式を含むことができます。しかし、SELECTが複合SELECTである場合、出力列へのエイリアスではないORDER BY式は、出力列として使用される式と全く同じでなければなりません。</target>
        </trans-unit>
        <trans-unit id="74d7943e809a432b89e323d15537e7de75d402f8" translate="yes" xml:space="preserve">
          <source>Otherwise, no affinity is applied and both operands are compared as is.</source>
          <target state="translated">そうでなければ、アフィニティは適用されず、両方のオペランドがそのまま比較されます。</target>
        </trans-unit>
        <trans-unit id="ace2ae60f4f3efb9070beb6a2fed407ad7cd8e65" translate="yes" xml:space="preserve">
          <source>Otherwise, r[P2] is set to the sum of r[P1] and r[P3].</source>
          <target state="translated">そうでなければ、r[P2]は、r[P1]とr[P3]の和に設定される。</target>
        </trans-unit>
        <trans-unit id="c9d8794c47ac5fbe000cffe629c489a9791ed713" translate="yes" xml:space="preserve">
          <source>Otherwise, the &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt; collation sequence is used.</source>
          <target state="translated">それ以外の場合は、&lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt;照合シーケンスが使用されます。</target>
        </trans-unit>
        <trans-unit id="35b896906bdef712969f9e7297c680f9a2e53cd3" translate="yes" xml:space="preserve">
          <source>Otherwise, the BINARY collating function is used for comparison.</source>
          <target state="translated">それ以外の場合は、BINARY照合機能を使用して比較を行います。</target>
        </trans-unit>
        <trans-unit id="638ab872140702484af1c059aebc57de13dbd98b" translate="yes" xml:space="preserve">
          <source>Otherwise, the affinity is NUMERIC.</source>
          <target state="translated">そうでなければ、親和性はNUMERICです。</target>
        </trans-unit>
        <trans-unit id="cfc6f8803bf4c712ac864728c4305aa6942d9a6a" translate="yes" xml:space="preserve">
          <source>Otherwise, the value inserted into this field is the file contents for a regular file, or the target of a symbolic link.</source>
          <target state="translated">そうでなければ、このフィールドに挿入される値は、通常のファイルのファイル内容、またはシンボリックリンクの対象となります。</target>
        </trans-unit>
        <trans-unit id="cb91e52cc1b3ca8f3f684e2966f8d4c11f3cb0b5" translate="yes" xml:space="preserve">
          <source>Otherwise, this API returns a negative value if P1 refers to an older snapshot than P2, zero if the two handles refer to the same database snapshot, and a positive value if P1 is a newer snapshot than P2.</source>
          <target state="translated">そうでなければ、このAPIは、P1がP2よりも古いスナップショットを参照している場合は負の値を、2つのハンドルが同じデータベースのスナップショットを参照している場合は0を、P1がP2よりも新しいスナップショットを参照している場合は正の値を返します。</target>
        </trans-unit>
        <trans-unit id="afebc4d098577eaf408f5312d05f2e55f910ee39" translate="yes" xml:space="preserve">
          <source>Our goal is to make the content you store in SQLite today as easily accessible to your grandchildren as it is to you.</source>
          <target state="translated">私たちの目標は、今日のSQLiteに保存しているコンテンツを、お孫さんにも簡単にアクセスできるようにすることです。</target>
        </trans-unit>
        <trans-unit id="3edd7f9a4b0d8d87dc9885a06cb59a66ad8766a5" translate="yes" xml:space="preserve">
          <source>Out of memory (OOM) error conditions generate error logging events with the SQLITE_NOMEM error code and a message that says how many bytes of memory were requested by the failed allocation.</source>
          <target state="translated">Out of memory (OOM)エラー状態は、SQLITE_NOMEM エラーコードと、割り当てに失敗して要求されたメモリのバイト数を示すメッセージを含むエラーロギングイベントを生成します。</target>
        </trans-unit>
        <trans-unit id="3eb43b3eb70e7d12a47e5820876f3c296dc05bc2" translate="yes" xml:space="preserve">
          <source>Out-of-memory tests</source>
          <target state="translated">記憶喪失テスト</target>
        </trans-unit>
        <trans-unit id="c1bf191f6ccc359ad8a3c05c295f7fe8cef84ae3" translate="yes" xml:space="preserve">
          <source>Outlandish Recursive Query Examples</source>
          <target state="translated">突飛な再帰的クエリの例</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="1bd1112bbbb687e4d808e79cb404cc3ec423a23a" translate="yes" xml:space="preserve">
          <source>Output Change</source>
          <target state="translated">出力変化</target>
        </trans-unit>
        <trans-unit id="0c51e370c031f37870509dc46422ce61ca6e1f16" translate="yes" xml:space="preserve">
          <source>Output columns from the index_info pragma are as follows:</source>
          <target state="translated">index_infoプラグマから出力されるカラムは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="8383ea0f1fb51fe84444b17104e0dd18b8f3f3b4" translate="yes" xml:space="preserve">
          <source>Output columns from the index_list pragma are as follows:</source>
          <target state="translated">index_listプラグマからの出力カラムは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="bc6e58f2bacd5891df7b631d05c18328e75e62f4" translate="yes" xml:space="preserve">
          <source>Output columns from the index_xinfo pragma are as follows:</source>
          <target state="translated">index_xinfoプラグマからの出力カラムは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="d1088854d972e4ceb1796db8756ad3486790779d" translate="yes" xml:space="preserve">
          <source>Output infinity as 1e999 in the &quot;.dump&quot; command of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;コマンドラインシェル&lt;/a&gt;の「.dump」コマンドで無限大を1e999として出力します。</target>
        </trans-unit>
        <trans-unit id="17e008cf652984308f7573376fc6932528a013cf" translate="yes" xml:space="preserve">
          <source>Output rows can be returned to the application as each small sort completes, and well before the table scan is complete.</source>
          <target state="translated">出力行は、各スモールソートが完了するたびに、テーブルスキャンが完了する前にアプリケーションに返すことができます。</target>
        </trans-unit>
        <trans-unit id="b785807667b898e4c7f09b3ee44afccba51a9945" translate="yes" xml:space="preserve">
          <source>Outputs an SQL script to create an RBU database which, if used to update database t1.db, patches it so that its contents are identical to that of database t2.db.</source>
          <target state="translated">RBUデータベースを作成するSQLスクリプトを出力し、データベースt1.dbの更新に使用された場合、その内容がデータベースt2.dbと同じになるようにパッチを当てます。</target>
        </trans-unit>
        <trans-unit id="25a352aa2e3e3671bf4d083fdd886df3d305e826" translate="yes" xml:space="preserve">
          <source>Over 100 separate source files are concatenated into a single large files of C-code named &quot;sqlite3.c&quot; and called &quot;the amalgamation&quot;. The amalgamation contains everything an application needs to embed SQLite. The amalgamation file is more than 220,000 lines long and over 7.5 megabytes in size (as of 2018-11-24).</source>
          <target state="translated">100以上の別々のソースファイルは、&quot;sqlite3.c &quot;という名前のCコードの1つの大きなファイルに連結され、&quot;アマルガム &quot;と呼ばれています。アマルガムには、アプリケーションがSQLiteを埋め込むために必要なすべてのものが含まれています。アマルガムファイルの長さは22万行以上、サイズは7.5メガバイトを超えています(2018-11-24現在)。</target>
        </trans-unit>
        <trans-unit id="6f2a6be035cf5a02d68b5e9127156e17d6b333b6" translate="yes" xml:space="preserve">
          <source>Overflow page</source>
          <target state="translated">オーバーフローページ</target>
        </trans-unit>
        <trans-unit id="26c78f2170e31758038f3bb0a52b3d4d222f938f" translate="yes" xml:space="preserve">
          <source>Overload A Function For A Virtual Table</source>
          <target state="translated">仮想テーブルの関数をオーバーロード</target>
        </trans-unit>
        <trans-unit id="007c99e63ddccff493d60c3cf9732ab7365f22fb" translate="yes" xml:space="preserve">
          <source>Override other operating system interfaces such as calls to obtain Zulu or local time.</source>
          <target state="translated">Zulu やローカルタイムを取得するための呼び出しなど、他のオペレーティングシステムのインターフェイスをオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="46880b89366d47b3659d0ee6bf4c167da19b6968" translate="yes" xml:space="preserve">
          <source>Overview Documents</source>
          <target state="translated">概要資料</target>
        </trans-unit>
        <trans-unit id="04e78b5fd19361d42f0880283437d8302448583e" translate="yes" xml:space="preserve">
          <source>Overwrite if already exists?</source>
          <target state="translated">既に存在する場合は上書きしますか?</target>
        </trans-unit>
        <trans-unit id="9ada09a735411e9de190da46810d6bab2f578abd" translate="yes" xml:space="preserve">
          <source>Overwriting a database file with another without also deleting any hot journal associated with the original database.</source>
          <target state="translated">元のデータベースに関連付けられたホットジャーナルを削除せずに、データベースファイルを別のものに上書きします。</target>
        </trans-unit>
        <trans-unit id="bcfd518ec9aac14be70cb40d43cadb15da01978e" translate="yes" xml:space="preserve">
          <source>Overwritting a journal file with a different journal file.</source>
          <target state="translated">ジャーナルファイルを別のジャーナルファイルに上書きします。</target>
        </trans-unit>
        <trans-unit id="f6202fa6f9727ecd28cda41b586c4f17db3f9662" translate="yes" xml:space="preserve">
          <source>P (cost: 7.71)</source>
          <target state="translated">P(コスト:7.71</target>
        </trans-unit>
        <trans-unit id="80d8eec7d81f7a0324484c1ac454ead7da895c4f" translate="yes" xml:space="preserve">
          <source>P1 can be either an ordinary table or a virtual table. There used to be a separate OP_VRowid opcode for use with virtual tables, but this one opcode now works for both table types.</source>
          <target state="translated">P1 は通常のテーブルでも仮想テーブルでもどちらでも構いません。以前は仮想テーブルで使用するためのOP_VRowidオプコードが別個にありましたが、このオプコードは両方のテーブルタイプで動作するようになりました。</target>
        </trans-unit>
        <trans-unit id="84bf22352f6da5dd236d64694b38dd6696254f42" translate="yes" xml:space="preserve">
          <source>P1 contains the address of the memory cell that contains the first memory cell in an array of values used as arguments to the sub-program. P2 contains the address to jump to if the sub-program throws an IGNORE exception using the RAISE() function. Register P3 contains the address of a memory cell in this (the parent) VM that is used to allocate the memory required by the sub-vdbe at runtime.</source>
          <target state="translated">P1には、サブプログラムの引数として使用される値の配列の最初のメモリセルを含むメモリセルのアドレスが含まれています。P2 には、サブプログラムが RAISE()関数を使用して IGNORE 例外をスローした場合にジャンプするアドレスが格納されています。レジスタP3には、実行時にサブvdbeが必要とするメモリを割り当てるために使用される、この(親の)VM内のメモリセルのアドレスが格納されています。</target>
        </trans-unit>
        <trans-unit id="bbb7c16489d0b290a1227473f0d5f4da2b7691cc" translate="yes" xml:space="preserve">
          <source>P1 is a 32-bit bitmask indicating whether or not each argument to the function was determined to be constant at compile time. If the first argument was constant then bit 0 of P1 is set. This is used to determine whether meta data associated with a user function argument using the sqlite3_set_auxdata() API may be safely retained until the next invocation of this opcode.</source>
          <target state="translated">P1は、コンパイル時に関数の各引数が定数であると判断されたかどうかを示す32ビットのビットマスクです。最初の引数が定数であった場合、P1のビット0が設定されます。これは、sqlite3_set_auxdata()APIを使用したユーザ関数の引数に関連付けられたメタデータが、このオペコードの次の呼び出しまで安全に保持されるかどうかを判断するために使用されます。</target>
        </trans-unit>
        <trans-unit id="ce2db3e033bf07aaa2aac0e6df082aac39175194" translate="yes" xml:space="preserve">
          <source>P1 is a boolean flag. If it is set to true and the xUpdate call is successful, then the value returned by sqlite3_last_insert_rowid() is set to the value of the rowid for the row just inserted.</source>
          <target state="translated">P1はブール値のフラグです。これがtrueに設定され、xUpdate呼び出しが成功した場合、sqlite3_last_insert_rowid()によって返される値は、挿入されたばかりの行のrowidの値に設定されます。</target>
        </trans-unit>
        <trans-unit id="ab3846ffb469791c7c875a7d6e64699955c09eb4" translate="yes" xml:space="preserve">
          <source>P1 is a cursor opened using &lt;a href=&quot;opcode#VOpen&quot;&gt;VOpen&lt;/a&gt;. P2 is an address to jump to if the filtered result set is empty.</source>
          <target state="translated">P1は&lt;a href=&quot;opcode#VOpen&quot;&gt;VOpen&lt;/a&gt;を使用して開かれたカーソルです。P2は、フィルタリングされた結果セットが空の場合にジャンプするアドレスです。</target>
        </trans-unit>
        <trans-unit id="99e16bb5285cdf74213efcd911112d0254cc888f" translate="yes" xml:space="preserve">
          <source>P1 is a register in the root frame of this VM (the root frame is different from the current frame if this instruction is being executed within a sub-program). Set the value of register P1 to the maximum of its current value and the value in register P2.</source>
          <target state="translated">P1は、このVMのルートフレーム内のレジスタです(この命令がサブプログラム内で実行されている場合、ルートフレームはカレントフレームとは異なります)。レジスタP1の値を、現在の値とレジスタP2の値の最大値に設定します。</target>
        </trans-unit>
        <trans-unit id="17a3ab4e084c4ae225f4e64b76426d06344fe074" translate="yes" xml:space="preserve">
          <source>P1 is a sorter cursor. If the sequence counter is currently zero, jump to P2. Regardless of whether or not the jump is taken, increment the the sequence value.</source>
          <target state="translated">P1はソーターカーソルです。シーケンスカウンタが現在0の場合、P2にジャンプします。ジャンプの有無に関わらず、シーケンス値をインクリメントします。</target>
        </trans-unit>
        <trans-unit id="f9ac2a8e79b4d0f70e9cfe08c3c644453f11b20b" translate="yes" xml:space="preserve">
          <source>P1 is a sorter cursor. This instruction compares a prefix of the record blob in register P3 against a prefix of the entry that the sorter cursor currently points to. Only the first P4 fields of r[P3] and the sorter record are compared.</source>
          <target state="translated">P1 はソーターカーソルです。この命令は、レジスタP3のレコードブロブの接頭辞と、ソーターカーソルが現在指しているエントリの接頭辞を比較します。r[P3]とソーターレコードの最初のP4フィールドのみが比較されます。</target>
        </trans-unit>
        <trans-unit id="d14bcdd4246c685563dd290988090774223c445f" translate="yes" xml:space="preserve">
          <source>P1 is an open index cursor and P3 is a cursor on the corresponding table. This opcode does a deferred seek of the P3 table cursor to the row that corresponds to the current row of P1.</source>
          <target state="translated">P1はオープンインデックスカーソルであり、P3は対応するテーブル上のカーソルである。このオペコードは、P1の現在の行に対応する行へのP3テーブルカーソルの遅延シークを行う。</target>
        </trans-unit>
        <trans-unit id="86c484d0a40d444e4dc0b4d443a06296772d4391" translate="yes" xml:space="preserve">
          <source>P1 is the index of a cursor open on an SQL table btree (with integer keys). If register P3 does not contain an integer or if P1 does not contain a record with rowid P3 then jump immediately to P2. Or, if P2 is 0, raise an SQLITE_CORRUPT error. If P1 does contain a record with rowid P3 then leave the cursor pointing at that record and fall through to the next instruction.</source>
          <target state="translated">P1はSQLテーブルbtree(整数キーを持つ)上で開いているカーソルのインデックスです。レジスタP3が整数を含まない場合、またはP1がrowid P3を持つレコードを含まない場合、直ちにP2にジャンプします。または、P2が0の場合は、SQLITE_CORRUPTエラーを発生させます。P1に行番号P3のレコードが含まれている場合、カーソルはそのレコードを指したままにして次の命令に進みます。</target>
        </trans-unit>
        <trans-unit id="be17250db9325023bb6814cabfbf543abfa5ba67" translate="yes" xml:space="preserve">
          <source>P1 is the index of a cursor open on an SQL table btree (with integer keys). P3 is an integer rowid. If P1 does not contain a record with rowid P3 then jump immediately to P2. Or, if P2 is 0, raise an SQLITE_CORRUPT error. If P1 does contain a record with rowid P3 then leave the cursor pointing at that record and fall through to the next instruction.</source>
          <target state="translated">P1はSQLテーブルbtree(整数のキーを持つ)で開いているカーソルのインデックスです。P3は整数の行番号です。P1に行番号P3のレコードが含まれていない場合、直ちにP2にジャンプします。または、P2が0の場合、SQLITE_CORRUPTエラーを発生させます。P1に行番号P3を持つレコードが含まれている場合、カーソルはそのレコードを指したままにして次の命令に進みます。</target>
        </trans-unit>
        <trans-unit id="35a6c564ff4d581152e9a1f876d9eb72d2af48f4" translate="yes" xml:space="preserve">
          <source>P1 is the index of the database file on which the transaction is started. Index 0 is the main database file and index 1 is the file used for temporary tables. Indices of 2 or more are used for attached databases.</source>
          <target state="translated">P1は、トランザクションが開始されるデータベースファイルのインデックスである。インデックス0はメインデータベースファイル、インデックス1はテンポラリテーブルに使用されるファイルである。2以上のインデックスは、アタッチされたデータベースに使用されます。</target>
        </trans-unit>
        <trans-unit id="b9198f15e439eca54714083fc1fc6d108cc42915" translate="yes" xml:space="preserve">
          <source>P1 is the index of the database in sqlite3.aDb[] of the database on which the lock is acquired. A readlock is obtained if P3==0 or a write lock if P3==1.</source>
          <target state="translated">P1はロックを取得したデータベースのsqlite3.aDb[]内のデータベースのインデックスです。P3==0ならリードロック、P3==1ならライトロックを取得します。</target>
        </trans-unit>
        <trans-unit id="1fcd6d3417638283143894ac28a56d5766856870" translate="yes" xml:space="preserve">
          <source>P1 is the memory location that is the accumulator for an aggregate or window function. Execute the finalizer function for an aggregate and store the result in P1.</source>
          <target state="translated">P1 は集約関数やウィンドウ関数のアキュムレータとなるメモリ位置です。集計のファイナライザ関数を実行し、その結果をP1に格納します。</target>
        </trans-unit>
        <trans-unit id="9564a9171b616f080f45aeeeeb50a759cf2543a9" translate="yes" xml:space="preserve">
          <source>P1 is the result code returned by sqlite3_exec(), sqlite3_reset(), or sqlite3_finalize(). For a normal halt, this should be SQLITE_OK (0). For errors, it can be some other value. If P1!=0 then P2 will determine whether or not to rollback the current transaction. Do not rollback if P2==OE_Fail. Do the rollback if P2==OE_Rollback. If P2==OE_Abort, then back out all changes that have occurred during this execution of the VDBE, but do not rollback the transaction.</source>
          <target state="translated">P1はsqlite3_exec()、sqlite3_reset()、またはsqlite3_finalize()によって返される結果コードです。通常の停止では、これはSQLITE_OK (0)でなければなりません。エラーの場合は、他の値を指定することができます。P1!=0の場合、P2は現在のトランザクションをロールバックするかどうかを決定します。P2==OE_Failの場合はロールバックしません。P2==OE_Rollbackの場合はロールバックを行います。P2==OE_Abortならば、このVDBEの実行中に発生した全ての変更をバックアウトするが、トランザクションはロールバックしない。</target>
        </trans-unit>
        <trans-unit id="05f5c83f3b169019c8e82a0eaf11fb45a16518b4" translate="yes" xml:space="preserve">
          <source>P1 must be a valid b-tree cursor. P2 must be a boolean value, either 0 or 1.</source>
          <target state="translated">P1は有効なb-treeカーソルでなければなりません。P2はブール値、0または1でなければなりません。</target>
        </trans-unit>
        <trans-unit id="05f600aab9b18602c22139c66a31c7458bbfad3f" translate="yes" xml:space="preserve">
          <source>P1 must not be pseudo-table. It has to be a real table with multiple rows.</source>
          <target state="translated">P1は疑似テーブルであってはなりません。複数の行を持つ本物のテーブルでなければなりません。</target>
        </trans-unit>
        <trans-unit id="f93c0802a39924cff1b00e9015e9aa33f54938f7" translate="yes" xml:space="preserve">
          <source>P2 contains the root-page of the table to lock.</source>
          <target state="translated">P2にはロックするテーブルのルートページが含まれています。</target>
        </trans-unit>
        <trans-unit id="9ce77455e05f3264d5bb123f4f714e82dd11c666" translate="yes" xml:space="preserve">
          <source>P2 is a register that holds the name of a virtual table in database P1. Call the xCreate method for that table.</source>
          <target state="translated">P2はデータベースP1内の仮想テーブルの名前を保持するレジスタです。そのテーブルのxCreateメソッドを呼び出します。</target>
        </trans-unit>
        <trans-unit id="be0d49dbe18b5a0cf012a9f8a24be16667dd4219" translate="yes" xml:space="preserve">
          <source>P2 is the column number for the argument to the sqlite_offset() function. This opcode does not use P2 itself, but the P2 value is used by the code generator. The P1, P2, and P3 operands to this opcode are the same as for &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt;.</source>
          <target state="translated">P2は、sqlite_offset（）関数への引数の列番号です。このオペコードはP2自体を使用しませんが、P2値はコードジェネレーターによって使用されます。このオペコードのP1、P2、およびP3オペランドは、&lt;a href=&quot;opcode#Column&quot;&gt;Columnの場合&lt;/a&gt;と同じです。</target>
        </trans-unit>
        <trans-unit id="b9b9294fefdd80f907d449f8b026a50941891877" translate="yes" xml:space="preserve">
          <source>P2 is the number of arguments that the step function takes and P4 is a pointer to the FuncDef for this function. The P2 argument is not used by this opcode. It is only there to disambiguate functions that can take varying numbers of arguments. The P4 argument is only needed for the case where the step function was not previously called.</source>
          <target state="translated">P2はステップ関数が取る引数の数、P4はこの関数のFuncDefへのポインタです。P2 引数はこのオペコードでは使用されません。これは、様々な数の引数を取ることができる関数を区別するためだけに存在します。P4 引数は、ステップ関数が以前に呼び出されなかった場合にのみ必要です。</target>
        </trans-unit>
        <trans-unit id="3bd7cc65ffe04a6cbb96320f3dfb05bef13a6003" translate="yes" xml:space="preserve">
          <source>P2 is the number of columns in the ephemeral table. The cursor points to a BTree table if P4==0 and to a BTree index if P4 is not 0. If P4 is not NULL, it points to a KeyInfo structure that defines the format of keys in the index.</source>
          <target state="translated">P2はエフェメラルテーブルのカラム数です。カーソルは、P4==0の場合はBTreeテーブルを指し、P4が0でない場合はBTreeインデックスを指します。P4がNULLでない場合は、インデックスのキーの形式を定義するKeyInfo構造体を指します。</target>
        </trans-unit>
        <trans-unit id="d43bd5b8560de02b50e24570db7ff928128725ba" translate="yes" xml:space="preserve">
          <source>P2=='A' &amp;rarr; BLOB</source>
          <target state="translated">P2 == 'A'&amp;rarr;BLOB</target>
        </trans-unit>
        <trans-unit id="549df038ddec37fc17c85e7dccfd3d0f7eac490b" translate="yes" xml:space="preserve">
          <source>P2=='B' &amp;rarr; TEXT</source>
          <target state="translated">P2 == 'B'&amp;rarr;TEXT</target>
        </trans-unit>
        <trans-unit id="3eb880697f1f955293bf5968bad5752ba9e6c36d" translate="yes" xml:space="preserve">
          <source>P2=='C' &amp;rarr; NUMERIC</source>
          <target state="translated">P2 == 'C'&amp;rarr;数値</target>
        </trans-unit>
        <trans-unit id="11082965a2f3470ce5a9187e0cfe05f51096d4b9" translate="yes" xml:space="preserve">
          <source>P2=='D' &amp;rarr; INTEGER</source>
          <target state="translated">P2 == 'D'&amp;rarr;INTEGER</target>
        </trans-unit>
        <trans-unit id="8d3f310a6285b7cb02844a9cd70fd245db85edd2" translate="yes" xml:space="preserve">
          <source>P2=='E' &amp;rarr; REAL</source>
          <target state="translated">P2 == 'E'&amp;rarr;REAL</target>
        </trans-unit>
        <trans-unit id="12d088ae7e89df349fe37f3d37cf8b1ca4c09b3a" translate="yes" xml:space="preserve">
          <source>P3 = P2 || P1</source>
          <target state="translated">P3=P2 || P1</target>
        </trans-unit>
        <trans-unit id="3a22c873357ee7f56f10d2e038f148e48353f460" translate="yes" xml:space="preserve">
          <source>P3 is the number of fields in the records that will be stored by the pseudo-table.</source>
          <target state="translated">P3は、疑似テーブルが格納するレコードのフィールド数である。</target>
        </trans-unit>
        <trans-unit id="fa5df0db7433454e4380316b1e3b9bfe2adbea6f" translate="yes" xml:space="preserve">
          <source>P4 contains a pointer to the name of the table being locked. This is only used to generate an error message if the lock cannot be obtained.</source>
          <target state="translated">P4には、ロックされているテーブル名へのポインタが含まれています。これは、ロックを取得できなかった場合のエラーメッセージを生成するためにのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="3f5b2dbcd76db7494d70506eccc181bd880869ce" translate="yes" xml:space="preserve">
          <source>P4 is a KeyInfo structure that defines collating sequences and sort orders for the comparison. The permutation applies to registers only. The KeyInfo elements are used sequentially.</source>
          <target state="translated">P4 は、比較のための照合シーケンスとソート順序を定義する KeyInfo 構造体です。並べ替えはレジスタのみに適用されます。KeyInfo要素は順次使用されます。</target>
        </trans-unit>
        <trans-unit id="6e63a14f434c9d816b03aebb21b25ccfa99f1b42" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a 64-bit floating point value. Write that value into register P2.</source>
          <target state="translated">P4は64ビット浮動小数点値へのポインタです。その値をレジスタP2に書き込む。</target>
        </trans-unit>
        <trans-unit id="006b4d737b2fe81d322403675fc01054f9eaddfd" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a 64-bit integer value. Write that value into register P2.</source>
          <target state="translated">P4は64ビット整数値へのポインタです。その値をレジスタP2に書き込む。</target>
        </trans-unit>
        <trans-unit id="93432616419a7361a72b061b65e02339a1738910" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a CollSeq object. If the next call to a user function or aggregate calls sqlite3GetFuncCollSeq(), this collation sequence will be returned. This is used by the built-in min(), max() and nullif() functions.</source>
          <target state="translated">P4はCollSeqオブジェクトへのポインタです。ユーザ関数や集約の次の呼び出しがsqlite3GetFuncCollSeq()を呼び出すと、この照合シーケンスが返されます。これは組み込みのmin(),max(),nullif()関数で使用されます。</target>
        </trans-unit>
        <trans-unit id="d80240e61957d32e7437d69346afb9ca3c15eca9" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a virtual table object, an sqlite3_vtab structure. P1 is a cursor number. This opcode opens a cursor to the virtual table and stores that cursor in P1.</source>
          <target state="translated">P4は仮想テーブルオブジェクト、sqlite3_vtab構造体へのポインタです。P1はカーソル番号です。このオペコードは仮想テーブルへのカーソルをオープンし、そのカーソルをP1に格納します。</target>
        </trans-unit>
        <trans-unit id="0dbffabc54d98d6801900e6ab537de5e2bcdd805" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a virtual table object, an sqlite3_vtab structure. This opcode invokes the corresponding xRename method. The value in register P1 is passed as the zName argument to the xRename method.</source>
          <target state="translated">P4は仮想テーブルオブジェクト(sqlite3_vtab構造体)へのポインタです。このオペコードは対応するxRenameメソッドを呼び出します。レジスタP1の値はxRenameメソッドの引数zNameとして渡されます。</target>
        </trans-unit>
        <trans-unit id="8c184e85a48a476ce012fdb53452bec6f0cb31bc" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a virtual table object, an sqlite3_vtab structure. This opcode invokes the corresponding xUpdate method. P2 values are contiguous memory cells starting at P3 to pass to the xUpdate invocation. The value in register (P3+P2-1) corresponds to the p2th element of the argv array passed to xUpdate.</source>
          <target state="translated">P4は仮想テーブルオブジェクト(sqlite3_vtab構造体)へのポインタです。このオペコードは対応するxUpdateメソッドを呼び出します。P2の値は、xUpdate呼び出しに渡すP3から始まる連続したメモリセルです。レジスタ(P3+P2-1)の値は、xUpdateに渡されるargv配列のp2番目の要素に対応します。</target>
        </trans-unit>
        <trans-unit id="ad1bbf355e84d3c7a49f4b2d106cdd6317b07ee3" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to the VM containing the trigger program.</source>
          <target state="translated">P4は、トリガプログラムを含むVMへのポインタです。</target>
        </trans-unit>
        <trans-unit id="f47594ef27452803fbd06eb33f15569fa2ff24ae" translate="yes" xml:space="preserve">
          <source>P4 is a string that is P2 characters long. The N-th character of the string indicates the column affinity that should be used for the N-th memory cell in the range.</source>
          <target state="translated">P4は、P2文字の長さの文字列である。文字列のn番目の文字は、範囲内のn番目のメモリセルに使用すべきカラム親和性を示す。</target>
        </trans-unit>
        <trans-unit id="990f075b203cf5ad046ffef4a8c3f52f5d8e8021" translate="yes" xml:space="preserve">
          <source>P4 is always of type P4_ADVANCE. The function pointer points to sqlite3BtreeNext().</source>
          <target state="translated">P4は常にP4_ADVANCE型です。関数ポインタはsqlite3BtreeNext()を指します。</target>
        </trans-unit>
        <trans-unit id="33ef9db58085779c3fa7810a9ac7b841027b65e6" translate="yes" xml:space="preserve">
          <source>P4 is always of type P4_ADVANCE. The function pointer points to sqlite3BtreePrevious().</source>
          <target state="translated">P4は常にP4_ADVANCE型です。関数ポインタはsqlite3BtreePrevious()を指します。</target>
        </trans-unit>
        <trans-unit id="d1b9c8ecf53ced9f246c4b6e555cd6111c1ca23e" translate="yes" xml:space="preserve">
          <source>P4 is either NULL or a string that was generated by the xBestIndex method of the module. The interpretation of the P4 string is left to the module implementation.</source>
          <target state="translated">P4はNULLか、モジュールのxBestIndexメソッドによって生成された文字列です。P4文字列の解釈はモジュールの実装に委ねられています。</target>
        </trans-unit>
        <trans-unit id="c28c1dcafe0312975199fcb1fcfbb17e24dd7d0c" translate="yes" xml:space="preserve">
          <source>P4 is the name of a virtual table in database P1. Call the xDestroy method of that table.</source>
          <target state="translated">P4はデータベースP1の仮想テーブルの名前です。そのテーブルのxDestroyメソッドを呼び出します。</target>
        </trans-unit>
        <trans-unit id="b1c200e3bc2517ade0a0775a576b9a6ce0d06b98" translate="yes" xml:space="preserve">
          <source>P4 may be a pointer to an sqlite3_vtab structure. If so, call the xBegin method for that table.</source>
          <target state="translated">P4はsqlite3_vtab構造体へのポインタかもしれません。その場合は、そのテーブルのxBeginメソッドを呼び出してください。</target>
        </trans-unit>
        <trans-unit id="946a7239230e3ec0a9c66885447aaf26ad8bc930" translate="yes" xml:space="preserve">
          <source>P4 may be a string that is P2 characters long. The N-th character of the string indicates the column affinity that should be used for the N-th field of the index key.</source>
          <target state="translated">P4は、P2文字の長さの文字列であってもよい。文字列のN番目の文字は、インデックスキーのN番目のフィールドに使用すべきカラムの親和性を示す。</target>
        </trans-unit>
        <trans-unit id="69adfac261137322671a1ca5cef4f8a650bcfbae" translate="yes" xml:space="preserve">
          <source>P4 may be an array of integers (type P4_INTARRAY) containing one entry for each column in the P3 table. If array entry a(i) is non-zero, then reading column a(i)-1 from cursor P3 is equivalent to performing the deferred seek and then reading column i from P1. This information is stored in P3 and used to redirect reads against P3 over to P1, thus possibly avoiding the need to seek and read cursor P3.</source>
          <target state="translated">P4は、P3テーブルの各列に1つのエントリを含む整数の配列(P4_INTARRAY型)である。配列エントリa(i)が0でない場合、カーソルP3から列a(i)-1を読み出すことは、遅延シークを実行してからP1から列iを読み出すことと等価である。この情報はP3に格納され、P3からの読み取りをP1にリダイレクトするために使用され、カーソルP3をシークして読み出す必要性を回避することができます。</target>
        </trans-unit>
        <trans-unit id="2b3aae431e84b9e296011557b13fc95c59d8a3fe" translate="yes" xml:space="preserve">
          <source>P4 points to a blob of data P1 bytes long. Store this blob in register P2.</source>
          <target state="translated">P4 は、P1 バイト長のデータのブロブを指します。このブロブをレジスタP2に格納します。</target>
        </trans-unit>
        <trans-unit id="5f1f77c01d77787acda0ee06f04f3dd3dab581c9" translate="yes" xml:space="preserve">
          <source>P4 points to a nul terminated UTF-8 string. This opcode is transformed into a &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; opcode before it is executed for the first time. During this transformation, the length of string P4 is computed and stored as the P1 parameter.</source>
          <target state="translated">P4は、nulで終了するUTF-8文字列を指します。このオペコードは、初めて実行される前に&lt;a href=&quot;opcode#String&quot;&gt;文字列&lt;/a&gt;オペコードに変換されます。この変換中に、文字列P4の長さが計算され、P1パラメータとして保存されます。</target>
        </trans-unit>
        <trans-unit id="8c8ae2d7e0dfc4268ff56cfc9e2e47a67fc1ddaf" translate="yes" xml:space="preserve">
          <source>P5 is a value between 0 and 4, inclusive, that modifies the P4 string.</source>
          <target state="translated">P5は、P4の文字列を変更する0から4の間の値です。</target>
        </trans-unit>
        <trans-unit id="e03c8fcb835da321a7966f8a1cfc9fb80046f7b0" translate="yes" xml:space="preserve">
          <source>P5 is the error actions (OE_Replace, OE_Fail, OE_Ignore, etc) to apply in the case of a constraint failure on an insert or update.</source>
          <target state="translated">P5は、挿入や更新で制約に失敗した場合に適用するエラーアクション(OE_Replace、OE_Fail、OE_Ignoreなど)です。</target>
        </trans-unit>
        <trans-unit id="b092db6b7249be33e50e9f2a75c65696bf56d25e" translate="yes" xml:space="preserve">
          <source>P5 ought to be set on every call to this opcode. However, there are places in the code generator will release registers before their are used, under the (valid) assumption that the registers will not be reallocated for some other purpose before they are used and hence are safe to release.</source>
          <target state="translated">P5はこのオペコードを呼び出すたびに設定されるべきです。しかし、レジスタが使用される前に他の目的のために再割り当てされないという(有効な)仮定の下で、コードジェネレーターがレジスタを使用する前に解放する場所があります、したがって、解放しても安全です。</target>
        </trans-unit>
        <trans-unit id="d23183b7ef6b3cfee6722e9cab664f9eba24c080" translate="yes" xml:space="preserve">
          <source>PARTITION</source>
          <target state="translated">PARTITION</target>
        </trans-unit>
        <trans-unit id="7c423f3264effc4f744de4e6255ff034137bcc1e" translate="yes" xml:space="preserve">
          <source>PASSIVE</source>
          <target state="translated">PASSIVE</target>
        </trans-unit>
        <trans-unit id="418f304013689ba52fc7c27eebb7dcb9d2ced563" translate="yes" xml:space="preserve">
          <source>PDF - Portable Document Format from Adobe</source>
          <target state="translated">PDF-Adobeのポータブルドキュメント形式</target>
        </trans-unit>
        <trans-unit id="0a7b38b716933a39c0bca66f229cd6d52f0c1271" translate="yes" xml:space="preserve">
          <source>PENDING</source>
          <target state="translated">PENDING</target>
        </trans-unit>
        <trans-unit id="5a61e634ec49d3919b83a13434809a009040ffa1" translate="yes" xml:space="preserve">
          <source>PLAN</source>
          <target state="translated">PLAN</target>
        </trans-unit>
        <trans-unit id="4b01f0d6c5bf45bcaa85e117787de16b76894b18" translate="yes" xml:space="preserve">
          <source>POSIX locking style. This is the default locking style and the style used by other (non Mac OS X) Unixes. Locks are obtained and released using the fcntl() system call.</source>
          <target state="translated">POSIXのロックスタイル。これはデフォルトのロックスタイルであり、他の (Mac OS X 以外の)Unix で使用されているスタイルです。ロックは fcntl()システムコールを使って取得・解放されます。</target>
        </trans-unit>
        <trans-unit id="304e41f1b7440f605b6d901a3f56679fe5127675" translate="yes" xml:space="preserve">
          <source>PPT - Microsoft PowerPoint presentations</source>
          <target state="translated">PPT-Microsoft PowerPointプレゼンテーション</target>
        </trans-unit>
        <trans-unit id="eb3b3e1144fc0ba039acb3375dbf811550aeb6d8" translate="yes" xml:space="preserve">
          <source>PRAGMA</source>
          <target state="translated">PRAGMA</target>
        </trans-unit>
        <trans-unit id="2031386335ef51b174ad3b83ba1c813522943aeb" translate="yes" xml:space="preserve">
          <source>PRAGMA Statements</source>
          <target state="translated">PRAGMA ステートメント</target>
        </trans-unit>
        <trans-unit id="dd8e7015522cfd4dcf823317fdfa144e1ffa8793" translate="yes" xml:space="preserve">
          <source>PRAGMA application_id</source>
          <target state="translated">PRAGMAアプリケーションID</target>
        </trans-unit>
        <trans-unit id="4272fe5aa2578d44c85ef586cbdb481255d6ef40" translate="yes" xml:space="preserve">
          <source>PRAGMA auto_vacuum</source>
          <target state="translated">PRAGMA自動バキューム</target>
        </trans-unit>
        <trans-unit id="ecdb75c7d78bb2d218243fd805db4a0952130227" translate="yes" xml:space="preserve">
          <source>PRAGMA automatic_index</source>
          <target state="translated">プラーグマ自動インデックス</target>
        </trans-unit>
        <trans-unit id="06f21794e50e9014cbc68dddc08b0afe728a2339" translate="yes" xml:space="preserve">
          <source>PRAGMA busy_timeout</source>
          <target state="translated">PRAGMAビジータイムアウト</target>
        </trans-unit>
        <trans-unit id="0079a2a1c563d3a80935f663efd9c2f3f214bd31" translate="yes" xml:space="preserve">
          <source>PRAGMA cache_size</source>
          <target state="translated">PRAGMA cache_size</target>
        </trans-unit>
        <trans-unit id="53830be86cc01d9861a99c96b4baf9389520d439" translate="yes" xml:space="preserve">
          <source>PRAGMA cache_spill</source>
          <target state="translated">PRAGMA cache_spill</target>
        </trans-unit>
        <trans-unit id="c62c55dc2230d9ef14955c77928155e6ec4c7ae3" translate="yes" xml:space="preserve">
          <source>PRAGMA case_sensitive_like</source>
          <target state="translated">PRAGMA case_sensitive_like</target>
        </trans-unit>
        <trans-unit id="629aac38c33c9e2128ff55cc2623e94247525dd5" translate="yes" xml:space="preserve">
          <source>PRAGMA cell_size_check</source>
          <target state="translated">PRAGMA cell_size_check</target>
        </trans-unit>
        <trans-unit id="f7a6fea31875d2709fc8636382fa71e3e405a8bd" translate="yes" xml:space="preserve">
          <source>PRAGMA checkpoint_fullfsync</source>
          <target state="translated">PRAGMAチェックポイント_fullfsync</target>
        </trans-unit>
        <trans-unit id="c3bb771e91f755dbbaf486313dfb86863abb68c6" translate="yes" xml:space="preserve">
          <source>PRAGMA collation_list</source>
          <target state="translated">PRAGMA照合リスト</target>
        </trans-unit>
        <trans-unit id="03029df867e6189d3cb8be071de311b5adc094ca" translate="yes" xml:space="preserve">
          <source>PRAGMA command syntax</source>
          <target state="translated">PRAGMA コマンド構文</target>
        </trans-unit>
        <trans-unit id="41b472d1fbef46bb9f050319914604b6fc2ba68d" translate="yes" xml:space="preserve">
          <source>PRAGMA compile_options</source>
          <target state="translated">PRAGMA compile_options</target>
        </trans-unit>
        <trans-unit id="c654b246f7037e0f8929e3e045a813d87f20921d" translate="yes" xml:space="preserve">
          <source>PRAGMA count_changes</source>
          <target state="translated">PRAGMA count_changes</target>
        </trans-unit>
        <trans-unit id="e558ad585b01cc3a4aa52bb53490182d9eacc4e8" translate="yes" xml:space="preserve">
          <source>PRAGMA data_store_directory</source>
          <target state="translated">PRAGMAデータストアディレクトリ</target>
        </trans-unit>
        <trans-unit id="9a7e5a694b84807a56ec0b72b64b9c9c84d92f92" translate="yes" xml:space="preserve">
          <source>PRAGMA data_version</source>
          <target state="translated">プラーグマデータバージョン</target>
        </trans-unit>
        <trans-unit id="71f193736d432d273c489df59218224a1bd26bb0" translate="yes" xml:space="preserve">
          <source>PRAGMA database_list</source>
          <target state="translated">PRAGMA データベースリスト</target>
        </trans-unit>
        <trans-unit id="d2b0abac3ff561286d0f244f1229dbe0d7c413ba" translate="yes" xml:space="preserve">
          <source>PRAGMA default_cache_size</source>
          <target state="translated">PRAGMA default_cache_size</target>
        </trans-unit>
        <trans-unit id="baa9b0985d524aa3c28f49ac66dec16e57647a96" translate="yes" xml:space="preserve">
          <source>PRAGMA defer_foreign_keys</source>
          <target state="translated">PRAGMA defer_foreign_keys</target>
        </trans-unit>
        <trans-unit id="5a13b54115c31e192bafba5863e3b69f614ae8e0" translate="yes" xml:space="preserve">
          <source>PRAGMA empty_result_callbacks</source>
          <target state="translated">PRAGMA empty_result_callbacks</target>
        </trans-unit>
        <trans-unit id="464f0c2fc86d3a8263fffd42239b50d53989d1da" translate="yes" xml:space="preserve">
          <source>PRAGMA encoding</source>
          <target state="translated">プラーグマ符号化方式</target>
        </trans-unit>
        <trans-unit id="5a35e091ec7521a831d067bdc90ecb017a359b26" translate="yes" xml:space="preserve">
          <source>PRAGMA foreign_key_check</source>
          <target state="translated">PRAGMA foreign_key_check</target>
        </trans-unit>
        <trans-unit id="4f9cabaf50d87f897238e4cfca01cbf9a956476a" translate="yes" xml:space="preserve">
          <source>PRAGMA foreign_key_list</source>
          <target state="translated">PRAGMA外国語キーリスト</target>
        </trans-unit>
        <trans-unit id="c26430dedacc940c37179bc2ab043a40726e60aa" translate="yes" xml:space="preserve">
          <source>PRAGMA foreign_keys</source>
          <target state="translated">PRAGMA foreign_keys</target>
        </trans-unit>
        <trans-unit id="f6f4d8a618687004328fc80c2fe129e8548fb446" translate="yes" xml:space="preserve">
          <source>PRAGMA freelist_count</source>
          <target state="translated">PRAGMA freelist_count</target>
        </trans-unit>
        <trans-unit id="a1a0446b52b0c9481ab686d03b259ad5f54f8cce" translate="yes" xml:space="preserve">
          <source>PRAGMA full_column_names</source>
          <target state="translated">PRAGMA full_column_names</target>
        </trans-unit>
        <trans-unit id="19952a9490a74b7cefcba8ae3ffcd4c6cd36c908" translate="yes" xml:space="preserve">
          <source>PRAGMA fullfsync</source>
          <target state="translated">PRAGMA fullfsync</target>
        </trans-unit>
        <trans-unit id="9b4ca9a487733d7c417ae8784f57aa1ed11b34f0" translate="yes" xml:space="preserve">
          <source>PRAGMA fullfsync=ON;</source>
          <target state="translated">PRAGMA fullfsync=ON。</target>
        </trans-unit>
        <trans-unit id="327858b59b9cfef735d94d93f6b85bcef5690111" translate="yes" xml:space="preserve">
          <source>PRAGMA function</source>
          <target state="translated">プラーグマ機能</target>
        </trans-unit>
        <trans-unit id="2a0bacb7b9cc513abddcbbe743f428bab68dfa8c" translate="yes" xml:space="preserve">
          <source>PRAGMA function_list</source>
          <target state="translated">プラーグマ関数リスト</target>
        </trans-unit>
        <trans-unit id="e837cb07b592292e4ed84f750d66cb314f82a9c5" translate="yes" xml:space="preserve">
          <source>PRAGMA functions</source>
          <target state="translated">PRAGMA機能</target>
        </trans-unit>
        <trans-unit id="f7e42e33fd73efd0a92d36f4ff6b3819913f9bc4" translate="yes" xml:space="preserve">
          <source>PRAGMA ignore_check_constraints</source>
          <target state="translated">PRAGMA ignore_check_constraints</target>
        </trans-unit>
        <trans-unit id="cd58bb64e6b2a173c5b581b0cb503c85da1dbd24" translate="yes" xml:space="preserve">
          <source>PRAGMA incremental_vacuum</source>
          <target state="translated">PRAGMA incremental_vacuum</target>
        </trans-unit>
        <trans-unit id="652aaaf1f9e0a84122b69d9954ec064ee9d02a48" translate="yes" xml:space="preserve">
          <source>PRAGMA index_info</source>
          <target state="translated">PRAGMA index_info</target>
        </trans-unit>
        <trans-unit id="125af8cf007c5ae9f4a12bfd4e392de5088aeebd" translate="yes" xml:space="preserve">
          <source>PRAGMA index_list</source>
          <target state="translated">プラーグマインデックスリスト</target>
        </trans-unit>
        <trans-unit id="2da953925bb8a4bec48afa57978cfa755a68b864" translate="yes" xml:space="preserve">
          <source>PRAGMA index_xinfo</source>
          <target state="translated">PRAGMA index_xinfo</target>
        </trans-unit>
        <trans-unit id="a0a681b89ba9014d636bfe01c90f033d409952e9" translate="yes" xml:space="preserve">
          <source>PRAGMA integrity_check</source>
          <target state="translated">プラーグマ完全性検査</target>
        </trans-unit>
        <trans-unit id="47cd2260e4aae51e91f7618b4491c7a57dbd31aa" translate="yes" xml:space="preserve">
          <source>PRAGMA integrity_check does not find &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY&lt;/a&gt; errors. Use the &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; command for to find errors in FOREIGN KEY constraints.</source>
          <target state="translated">PRAGMA integer_checkは、&lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY&lt;/a&gt;エラーを検出しません。&lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt;コマンドを使用して、FOREIGN KEY制約のエラーを見つけます。</target>
        </trans-unit>
        <trans-unit id="fed086b5dc8e5ae4d059caf4aa86921613ca6bce" translate="yes" xml:space="preserve">
          <source>PRAGMA integrity_check does not find &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY&lt;/a&gt; errors. Use the &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; command to find errors in FOREIGN KEY constraints.</source>
          <target state="translated">PRAGMA integrity_checkは見つけられません&lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEYの&lt;/a&gt;エラーを。&lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA Foreign_key_check&lt;/a&gt;コマンドを使用して、FOREIGNKEY制約のエラーを見つけます。</target>
        </trans-unit>
        <trans-unit id="0e40c9bb92f26ef5f07d9f3367463e8597505eee" translate="yes" xml:space="preserve">
          <source>PRAGMA journal_mode</source>
          <target state="translated">PRAGMAログモード</target>
        </trans-unit>
        <trans-unit id="0dc7949f2c37427da3286461ab0d99c192b23454" translate="yes" xml:space="preserve">
          <source>PRAGMA journal_size_limit</source>
          <target state="translated">PRAGMA journal_size_limit</target>
        </trans-unit>
        <trans-unit id="1d1d61ff55f21546bb199472fc5fb09c63e7801f" translate="yes" xml:space="preserve">
          <source>PRAGMA legacy_alter_table</source>
          <target state="translated">PRAGMA legacy_alter_table</target>
        </trans-unit>
        <trans-unit id="1d7e28dc08cc03a9bb08dd39291f00ea3a00d6ce" translate="yes" xml:space="preserve">
          <source>PRAGMA legacy_file_format</source>
          <target state="translated">PRAGMA legacy_file_format</target>
        </trans-unit>
        <trans-unit id="e05eb926ae67395e18a7ff48872e6bf6de93826e" translate="yes" xml:space="preserve">
          <source>PRAGMA locking_mode</source>
          <target state="translated">PRAGMAロックモード</target>
        </trans-unit>
        <trans-unit id="a71f8b9f21a1c76ece9dc64397bce57f203e4519" translate="yes" xml:space="preserve">
          <source>PRAGMA max_page_count</source>
          <target state="translated">PRAGMA max_page_count</target>
        </trans-unit>
        <trans-unit id="3aba9ed125640a69838f81731ba34ebdf094d76a" translate="yes" xml:space="preserve">
          <source>PRAGMA mmap_size</source>
          <target state="translated">PRAGMA mmap_size</target>
        </trans-unit>
        <trans-unit id="c29ccc2a4945dfe06f8af7b8b574f07e8a513dc7" translate="yes" xml:space="preserve">
          <source>PRAGMA module_list</source>
          <target state="translated">PRAGMAモジュールリスト</target>
        </trans-unit>
        <trans-unit id="ed5cd9ca526909b51a8497a39931b7a730a4b534" translate="yes" xml:space="preserve">
          <source>PRAGMA optimize</source>
          <target state="translated">PRAGMA最適化</target>
        </trans-unit>
        <trans-unit id="9618d59586d55b1fe7cf6403a08d5878deeff0b2" translate="yes" xml:space="preserve">
          <source>PRAGMA page_count</source>
          <target state="translated">PRAGMAページカウント</target>
        </trans-unit>
        <trans-unit id="73b1778335144273f1b55bbda71292b3236c2f7c" translate="yes" xml:space="preserve">
          <source>PRAGMA page_size</source>
          <target state="translated">PRAGMAページサイズ</target>
        </trans-unit>
        <trans-unit id="0c33d6f9f55335baef42453f3966f2ae2790fe21" translate="yes" xml:space="preserve">
          <source>PRAGMA parser_trace</source>
          <target state="translated">PRAGMA parser_trace</target>
        </trans-unit>
        <trans-unit id="987c5140e9a3de6520e0e9a5de928a2bd5f2af7c" translate="yes" xml:space="preserve">
          <source>PRAGMA synchronous=FULL;</source>
          <target state="translated">PRAGMA synchronous=FULL。</target>
        </trans-unit>
        <trans-unit id="c40b0db1ea40d45cf9c01804a3ada577b8b752ae" translate="yes" xml:space="preserve">
          <source>PRAGMA temp_store_directory = ''</source>
          <target state="translated">PRAGMA temp_store_directory=''</target>
        </trans-unit>
        <trans-unit id="0662bf3087347b5b0ecf25fecad0c21f9bfb340d" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_addoptrace</source>
          <target state="translated">PRAGMA vdbe_addoptrace</target>
        </trans-unit>
        <trans-unit id="ed607acfa6bacfc2bc133e1d2e829c3c31c8a51c" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_debug</source>
          <target state="translated">PRAGMA vdbe_debug</target>
        </trans-unit>
        <trans-unit id="f5251eb4d3acd0707857877ee684d1bef0e741e2" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_listing</source>
          <target state="translated">PRAGMA vdbe_listing</target>
        </trans-unit>
        <trans-unit id="319d369f27e5d322702e5eca965b605f26e48c8b" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_trace</source>
          <target state="translated">PRAGMA vdbe_trace</target>
        </trans-unit>
        <trans-unit id="f0a71878598fa251896a1bb5f07402743f02c1c6" translate="yes" xml:space="preserve">
          <source>PRAGMAs that return results and that have no side-effects can be accessed from ordinary &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements as &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt;. For each participating PRAGMA, the corresponding table-valued function has the same name as the PRAGMA with a 7-character &quot;pragma_&quot; prefix. The PRAGMA argument and schema, if any, are passed as arguments to the table-valued function.</source>
          <target state="translated">結果を返し、副作用がないPRAGMAには、通常の&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントから&lt;a href=&quot;vtab#tabfunc2&quot;&gt;テーブル値関数&lt;/a&gt;としてアクセスできます。参加している各PRAGMAについて、対応するテーブル値関数は、7文字の &quot;pragma_&quot;接頭辞が付いたPRAGMAと同じ名前を持っています。 PRAGMA引数とスキーマ（存在する場合）は、引数としてテーブル値関数に渡されます。</target>
        </trans-unit>
        <trans-unit id="f5e246fc197bcab96dcc71246fd51e046d154a6b" translate="yes" xml:space="preserve">
          <source>PRECEDING</source>
          <target state="translated">PRECEDING</target>
        </trans-unit>
        <trans-unit id="ed15de08f42371953d12d6c433f3d7a83e50d659" translate="yes" xml:space="preserve">
          <source>PRIMARY</source>
          <target state="translated">PRIMARY</target>
        </trans-unit>
        <trans-unit id="5d81ed20f739b911f425c9e71391691185dad6d3" translate="yes" xml:space="preserve">
          <source>PRIMARY KEY constraint</source>
          <target state="translated">PRIMARY KEY 制約</target>
        </trans-unit>
        <trans-unit id="fcdd367db6d48a1ca9ffb0132d54992dd930544d" translate="yes" xml:space="preserve">
          <source>Page 1 and the Expected Page Size</source>
          <target state="translated">1ページ目と期待されるページサイズ</target>
        </trans-unit>
        <trans-unit id="626d2e810cbdab389ce5499e79846105d079da1c" translate="yes" xml:space="preserve">
          <source>Page 1 of a database file is the root page of a table b-tree that holds a special table named &quot;&lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt;&quot;. This b-tree is known as the &quot;schema table&quot; since it stores the complete database schema. The structure of the sqlite_schema table is as if it had been created using the following SQL:</source>
          <target state="translated">データベースファイルのページ1は、「&lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt;」という名前の特別なテーブルを保持するテーブルbツリーのルートページです。このBツリーは、完全なデータベーススキーマを格納するため、「スキーマテーブル」と呼ばれます。sqlite_schemaテーブルの構造は、次のSQLを使用して作成されたかのようになります。</target>
        </trans-unit>
        <trans-unit id="e0da1c304b873d5c4bfe7eb2116e8b2b93162178" translate="yes" xml:space="preserve">
          <source>Page 1 of a database file is the root page of a table b-tree that holds a special table named &quot;sqlite_master&quot; (or &quot;sqlite_temp_master&quot; in the case of a TEMP database) which stores the complete database schema. The structure of the sqlite_master table is as if it had been created using the following SQL:</source>
          <target state="translated">データベースファイルの1ページ目は、完全なデータベーススキーマを格納する &quot;sqlite_master&quot;(TEMPデータベースの場合は &quot;sqlite_temp_master&quot;)という名前の特別なテーブルを保持するテーブルb-treeのルートページです。sqlite_masterテーブルの構造は、以下のSQLを使用して作成されたかのようになっています。</target>
        </trans-unit>
        <trans-unit id="bb98169c72c2e0218852294c4088a714e55ae813" translate="yes" xml:space="preserve">
          <source>Page Cache</source>
          <target state="translated">ページキャッシュ</target>
        </trans-unit>
        <trans-unit id="111e3d8b941451e6256ee0ce1fa5b2560f773697" translate="yes" xml:space="preserve">
          <source>Page Cache Algorithms</source>
          <target state="translated">ページキャッシュアルゴリズム</target>
        </trans-unit>
        <trans-unit id="51e73b0787f74035c32eccb9bca14aa82436008b" translate="yes" xml:space="preserve">
          <source>Page Cache Configuration</source>
          <target state="translated">ページキャッシュの構成</target>
        </trans-unit>
        <trans-unit id="91dcdd907d00efb6c274aa541e77d89ded5b848c" translate="yes" xml:space="preserve">
          <source>Page cache memory allocations that overflow into the general-purpose memory allocator.</source>
          <target state="translated">汎用メモリアロケータにオーバーフローするページキャッシュメモリの割り当て。</target>
        </trans-unit>
        <trans-unit id="8b08ca42225d56c2d889ece253767100d76e7c2a" translate="yes" xml:space="preserve">
          <source>Page number</source>
          <target state="translated">ページ数</target>
        </trans-unit>
        <trans-unit id="ad392683af791420db4e7324c20464059ce3492a" translate="yes" xml:space="preserve">
          <source>Page number of first overflow page</source>
          <target state="translated">最初のオーバーフローページのページ番号</target>
        </trans-unit>
        <trans-unit id="6e528c19af566e5c19716241accd44732b15c3f1" translate="yes" xml:space="preserve">
          <source>Page number of left child</source>
          <target state="translated">左の子のページ番号</target>
        </trans-unit>
        <trans-unit id="1d20e1ca269b0f7a9ac2bdd34ee817b875d0828b" translate="yes" xml:space="preserve">
          <source>Page number of the first freelist trunk page.</source>
          <target state="translated">フリーリストの最初のトランクのページ番号です。</target>
        </trans-unit>
        <trans-unit id="2f6078feea4fe70e006a40f0bbe8960bf8454aee" translate="yes" xml:space="preserve">
          <source>Pagecache memory allocator</source>
          <target state="translated">ページキャッシュメモリアロケータ</target>
        </trans-unit>
        <trans-unit id="7a89afd5ef39a4cff0b861ab314756ac6e516da0" translate="yes" xml:space="preserve">
          <source>Pagecount</source>
          <target state="translated">Pagecount</target>
        </trans-unit>
        <trans-unit id="2a084ba7d77808cea5a5f8f9c1ab34ab55b7585a" translate="yes" xml:space="preserve">
          <source>Pager and btree subsystems removed. These will be used in a follow-on SQL server library named &quot;SQLus&quot;.</source>
          <target state="translated">ページャーとbtreeサブシステムが削除されました。これらは &quot;SQLus&quot; という名前の後続の SQL サーバーライブラリで使用されます。</target>
        </trans-unit>
        <trans-unit id="d03660f900d198f933a03da740944dbf17018900" translate="yes" xml:space="preserve">
          <source>Pager subsystem added but not yet used.</source>
          <target state="translated">ページャーサブシステムを追加しましたが、まだ使用していません。</target>
        </trans-unit>
        <trans-unit id="70384aa891f4780133eb9e575d0bd72469e20f4e" translate="yes" xml:space="preserve">
          <source>Pages are numbered beginning with 1. The maximum page number is 2147483646 (2&lt;sup&gt;&lt;small&gt;31&lt;/small&gt;&lt;/sup&gt; - 2). The minimum size SQLite database is a single 512-byte page. The maximum size database would be 2147483646 pages at 65536 bytes per page or 140,737,488,224,256 bytes (about 140 terabytes). Usually SQLite will hit the maximum file size limit of the underlying filesystem or disk hardware long before it hits its own internal size limit.</source>
          <target state="translated">ページは、最大ページ数が2147483646（2である1から始まる番号が付けられている&lt;sup&gt;&lt;small&gt;31&lt;/small&gt;&lt;/sup&gt; - 2）。最小サイズのSQLiteデータベースは、単一の512バイトページです。データベースの最大サイズは、ページあたり65536バイトの2147483646ページ、または140,737,488,224,256バイト（約140テラバイト）です。通常、SQLiteは、独自の内部サイズ制限に達する前に、基盤となるファイルシステムまたはディスクハードウェアの最大ファイルサイズ制限に達します。</target>
        </trans-unit>
        <trans-unit id="a6bf70b89378b1b3ed63fb1aa677ec02aea17bdf" translate="yes" xml:space="preserve">
          <source>Pages are numbered beginning with 1. The maximum page number is 4294967294 (2&lt;sup&gt;&lt;small&gt;32&lt;/small&gt;&lt;/sup&gt; - 2). The minimum size SQLite database is a single 512-byte page. The maximum size database would be 2147483646 pages at 65536 bytes per page or 281,474,976,579,584 bytes (about 281 terabytes). Usually SQLite will hit the maximum file size limit of the underlying filesystem or disk hardware long before it hits its own internal size limit.</source>
          <target state="translated">ページは、最大ページ番号が4294967294（2である1から始まる番号が付けられている&lt;sup&gt;&lt;small&gt;32&lt;/small&gt;&lt;/sup&gt; - 2）。最小サイズのSQLiteデータベースは単一の512バイトページです。データベースの最大サイズは、1ページあたり65536バイトの2147483646ページ、または281,474,976,579,584バイト（約281テラバイト）になります。通常、SQLiteは、自身の内部サイズ制限に達するずっと前に、基盤となるファイルシステムまたはディスクハードウェアの最大ファイルサイズ制限に達します。</target>
        </trans-unit>
        <trans-unit id="0f332eeefd007bb0043ccb46738196508c6a602b" translate="yes" xml:space="preserve">
          <source>Param</source>
          <target state="translated">Param</target>
        </trans-unit>
        <trans-unit id="f699f295e5ae4ac633cfa18437fed38d028b3fdb" translate="yes" xml:space="preserve">
          <source>Parameter</source>
          <target state="translated">Parameter</target>
        </trans-unit>
        <trans-unit id="8b81f4321a39e53a61cf8fbe1b4d654902c2cd89" translate="yes" xml:space="preserve">
          <source>Parameter P4 may point to a Table structure, or may be NULL. If it is not NULL, then the update-hook (sqlite3.xUpdateCallback) is invoked following a successful insert.</source>
          <target state="translated">パラメータP4はテーブル構造体を指すか、NULLです。NULLでない場合、挿入に成功した後に更新フック(sqlite3.xUpdateCallback)が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="a5652d036064588f8b6a1cd35001bca04abb6577" translate="yes" xml:space="preserve">
          <source>Parameter zDb is not the filename that contains the database, but rather the symbolic name of the database. For attached databases, this is the name that appears after the AS keyword in the &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. For the main database file, the database name is &quot;main&quot;. For TEMP tables, the database name is &quot;temp&quot;.</source>
          <target state="translated">パラメータzDbは、データベースを含むファイル名ではなく、データベースのシンボル名です。接続されているデータベースの場合、これは&lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt;ステートメントのASキーワードの後に​​表示される名前です。メインデータベースファイルの場合、データベース名は「メイン」です。TEMPテーブルの場合、データベース名は「temp」です。</target>
        </trans-unit>
        <trans-unit id="6b3dbfca494676dd202b93efd1413416a69fb138" translate="yes" xml:space="preserve">
          <source>Parameter zDb is not the filename that contains the database, but rather the symbolic name of the database. For attached databases, this is the name that appears after the AS keyword in the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. For the main database file, the database name is &quot;main&quot;. For TEMP tables, the database name is &quot;temp&quot;.</source>
          <target state="translated">パラメータzDbは、データベースを含むファイル名ではなく、データベースのシンボル名です。接続されているデータベースの場合、これは&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;ステートメントのASキーワードの後に​​表示される名前です。メインデータベースファイルの場合、データベース名は「メイン」です。TEMPテーブルの場合、データベース名は「temp」です。</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="799e97b7e20fea27a8af5b85f72a1e45ff70f20e" translate="yes" xml:space="preserve">
          <source>Parameters can be either named or unnamed. An unnamed parameter is a single question mark (&quot;?&quot;). Named parameters are a &quot;?&quot; followed immediately by a number (ex: &quot;?15&quot; or &quot;?123&quot;) or one of the characters &quot;$&quot;, &quot;:&quot;, or &quot;@&quot; followed by an alphanumeric name (ex: &quot;$var1&quot;, &quot;:xyz&quot;, &quot;@bingo&quot;).</source>
          <target state="translated">パラメータには名前を付けることも、名前を付けないこともできます。名前のないパラメータは、単一のクエスチョンマーク(&quot;?&quot;)です。名前付きパラメータは、&quot;? &quot;の後に数字 (例:&quot;?15&quot; や &quot;?123&quot;)、または &quot;$&quot;、&quot;:&quot;、&quot;@&quot; のいずれかの文字の後に英数字の名前 (例:&quot;$var1&quot;,&quot;:xyz&quot;,&quot;@bingo&quot;)を付けたものです。</target>
        </trans-unit>
        <trans-unit id="8cba5f18115ee2b196f01cd67b537bb6b53bf7ec" translate="yes" xml:space="preserve">
          <source>Parameters that are not assigned values using &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; are treated as NULL. The &lt;a href=&quot;c3ref/bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; interface can be used to translate a symbolic parameter name into its equivalent numeric index.</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind（）&lt;/a&gt;を使用して値が割り当てられていないパラメーターは、NULLとして扱われます。&lt;a href=&quot;c3ref/bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index（）&lt;/a&gt;インタフェースは、それに相当する数値インデックスにシンボリックパラメータ名を変換するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="4de5d1891af8779fc1d212b882aca704731f9909" translate="yes" xml:space="preserve">
          <source>Parent and child keys must have the same cardinality. In SQLite, if any of the child key columns (in this case songartist and songalbum) are NULL, then there is no requirement for a corresponding row in the parent table.</source>
          <target state="translated">親キーと子キーは同じカーディナリティを持たなければなりません。SQLite では、子キーのカラム (この場合は songartist と songalbum)のいずれかが NULL であれば、親テーブルに対応する行は必要ありません。</target>
        </trans-unit>
        <trans-unit id="f4093b4053e6e304b33edcd1e545c7ac44407405" translate="yes" xml:space="preserve">
          <source>Parent table</source>
          <target state="translated">親テーブル</target>
        </trans-unit>
        <trans-unit id="4e28259727cc9bea774f5aa837a0a46e7e8f6e3d" translate="yes" xml:space="preserve">
          <source>Parentheses around the column name are ignored. Hence if X and Y.Z are column names, then (X) and (Y.Z) are also considered column names and have the affinity of the corresponding columns.</source>
          <target state="translated">カラム名の周りの括弧は無視されます。したがって、XとY.Zがカラム名である場合、(X)と(Y.Z)もカラム名とみなされ、対応するカラムの親和性を持つことになります。</target>
        </trans-unit>
        <trans-unit id="e9b3806832484c8806fbc046fab28912aa2aa64c" translate="yes" xml:space="preserve">
          <source>Parenthesis are not supported.</source>
          <target state="translated">括弧はサポートされていません。</target>
        </trans-unit>
        <trans-unit id="75d39bc816f04be94a422f23dd0120a1ebf6cf81" translate="yes" xml:space="preserve">
          <source>Parenthesis may be used to group expressions in order to modify operator precedence in the usual ways. For example:</source>
          <target state="translated">括弧は、通常の方法で演算子の優先順位を変更するために式をグループ化するために使用することができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="a5d92895b79471a4a9fa3ce0a6ffdf64945a6880" translate="yes" xml:space="preserve">
          <source>Parse (but do not implement) foreign keys.</source>
          <target state="translated">外部キーをパースします(実装はしません)。</target>
        </trans-unit>
        <trans-unit id="c98796aa2add46f2617d36d2c94c638a1c0df012" translate="yes" xml:space="preserve">
          <source>ParseSchema</source>
          <target state="translated">ParseSchema</target>
        </trans-unit>
        <trans-unit id="1b3cf5033ed01a4fcbff3f2957e66cfe44af45a9" translate="yes" xml:space="preserve">
          <source>Parser</source>
          <target state="translated">Parser</target>
        </trans-unit>
        <trans-unit id="e5dde1d1ec704f9acd81aeb949908d6d48dedf9c" translate="yes" xml:space="preserve">
          <source>Parser detects and reports automaton stack overflow.</source>
          <target state="translated">パーサはオートマトンスタックのオーバーフローを検出して報告します。</target>
        </trans-unit>
        <trans-unit id="de7186ac205c0a4d05d1b7e13d0477c901e264d5" translate="yes" xml:space="preserve">
          <source>Parsing Ambiguity</source>
          <target state="translated">曖昧さの解析</target>
        </trans-unit>
        <trans-unit id="6893b79566df0f4ab433d9b0d800d95d1637ec25" translate="yes" xml:space="preserve">
          <source>Partial Indexes</source>
          <target state="translated">部分インデックス</target>
        </trans-unit>
        <trans-unit id="b83a6d7f720f864139ebf6cd22707c1309f4af67" translate="yes" xml:space="preserve">
          <source>Partial index causes assertion fault on UPDATE OR REPLACE. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/2ea3e9fe63&quot;&gt;2ea3e9fe63&lt;/a&gt;</source>
          <target state="translated">部分インデックスにより、UPDATE OR REPLACEでアサーションエラーが発生します。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/2ea3e9fe63&quot;&gt;2ea3e9fe63&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="92e7c6c4dccd56837450920de775aa91130dc6eb" translate="yes" xml:space="preserve">
          <source>Partial indexes</source>
          <target state="translated">部分インデックス</target>
        </trans-unit>
        <trans-unit id="a6b00209f988aae401d1637e4d3a48cf480b87b9" translate="yes" xml:space="preserve">
          <source>Partial indexes have been supported in SQLite since &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26).</source>
          <target state="translated">部分インデックスは、&lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;バージョン3.8.0&lt;/a&gt;（2013-08-26）以降、SQLiteでサポートされています。</target>
        </trans-unit>
        <trans-unit id="2c653f2abbb32f0888ba48000a6d19c0a678be3c" translate="yes" xml:space="preserve">
          <source>Partial sorting by index</source>
          <target state="translated">インデックスによる部分ソート</target>
        </trans-unit>
        <trans-unit id="8e7b279371a7a0621eac24aac6019fdbd06fb946" translate="yes" xml:space="preserve">
          <source>Partially or fully disable the use of mutexes using &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;, &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;、&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt;、および&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt;を使用して、ミューテックスの使用を部分的または完全に無効にします。</target>
        </trans-unit>
        <trans-unit id="322d75c78f20c6c69dad6d4668258bee1cff55cf" translate="yes" xml:space="preserve">
          <source>Pass information about !=, IS, IS NOT, NOT NULL, and IS NULL constraints into the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of virtual tables.</source>
          <target state="translated">！=、IS、IS NOT、NOT NULL、およびIS NULL制約に関する情報を仮想テーブルの&lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;メソッドに渡します。</target>
        </trans-unit>
        <trans-unit id="87139427c07163b54b934cac2e589a5477f5abd2" translate="yes" xml:space="preserve">
          <source>Passing around pointers as if they were integers or BLOBs is easy, effective, and works well in an environment where the application components are all friendly toward one another. However, passing pointers as integers and BLOBs allows hostile SQL text to forge invalid pointers that can carry out mischief.</source>
          <target state="translated">ポインタをあたかも整数やBLOBであるかのように渡すことは簡単で効果的で、アプリケーションのコンポーネントが互いに友好的な環境ではうまく機能します。しかし、ポインタを整数やBLOBのように渡すと、敵対的なSQLテキストが不正なポインタを偽造し、悪事を働く可能性があります。</target>
        </trans-unit>
        <trans-unit id="3138de58b357feeff45cc3442a6fef1e07764789" translate="yes" xml:space="preserve">
          <source>Passing zero to this function disables the session. Passing a value greater than zero enables it. Passing a value less than zero is a no-op, and may be used to query the current state of the session.</source>
          <target state="translated">この関数にゼロを渡すと、セッションは無効になります。ゼロよりも大きい値を渡すとセッションが有効になります。ゼロよりも小さい値を渡すと無効化され、セッションの現在の状態を問い合わせるために使用されます。</target>
        </trans-unit>
        <trans-unit id="590be09d7533f1bdecea251bf8fa20c21692381c" translate="yes" xml:space="preserve">
          <source>Patch releases may or may not have a release checklist, depending on the issue. This is a judgement call by the project leader.</source>
          <target state="translated">パッチリリースには、課題によってリリースチェックリストがある場合とない場合があります。これはプロジェクトリーダーの判断によるものです。</target>
        </trans-unit>
        <trans-unit id="6943c09e1bab506ed4d4e77bf277765f2ba43e9d" translate="yes" xml:space="preserve">
          <source>Patches from Christian Werner to improve ODBC compatibility and to fix a bug in the round() function.</source>
          <target state="translated">Christian Werner からのパッチで、ODBC の互換性を改善し、round()関数のバグを修正しました。</target>
        </trans-unit>
        <trans-unit id="2e7fec23d54bbd8979f0f75ea726578cd4ba06c0" translate="yes" xml:space="preserve">
          <source>Pay close attention to the last sentence in the previous paragraph:</source>
          <target state="translated">前段落の最後の一文に注意してください。</target>
        </trans-unit>
        <trans-unit id="c30415eacc6a59446974b716eff56cf28219815d" translate="yes" xml:space="preserve">
          <source>Payload</source>
          <target state="translated">Payload</target>
        </trans-unit>
        <trans-unit id="2cd642b895a9277d90f1edb51ac2e97d29897374" translate="yes" xml:space="preserve">
          <source>Payload, either table b-tree data or index b-tree keys, is always in the &quot;record format&quot;. The record format defines a sequence of values corresponding to columns in a table or index. The record format specifies the number of columns, the datatype of each column, and the content of each column.</source>
          <target state="translated">ペイロードは、テーブルの b-tree データまたはインデックスの b-tree キーのいずれかであり、常に「レコード形式」である。レコードフォーマットは、テーブルまたはインデックスのカラムに対応する一連の値を定義する。レコードフォーマットは、列の数、各列のデータ型、各列の内容を指定する。</target>
        </trans-unit>
        <trans-unit id="e74a4343f3025ea9dd8df608f45f6bce992f0d7e" translate="yes" xml:space="preserve">
          <source>Pending statements no longer block &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;. Instead, the pending statement will return SQLITE_ABORT upon next access after the ROLLBACK.</source>
          <target state="translated">保留中のステートメントは&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACKを&lt;/a&gt;ブロックしなくなりました。代わりに、保留中のステートメントは、ROLLBACK後の次のアクセス時にSQLITE_ABORTを返します。</target>
        </trans-unit>
        <trans-unit id="4737507de6ca940161ab97310c9c1d96280bacd6" translate="yes" xml:space="preserve">
          <source>People often wonder why SQLite does not use the &lt;a href=&quot;https://git-scm.org&quot;&gt;Git&lt;/a&gt; version control system like everybody else. This article attempts to answer that question. Also, in &lt;a href=&quot;#getthecode&quot;&gt;section 3&lt;/a&gt;, this article provides hints to Git users about how they can easily access the SQLite source code.</source>
          <target state="translated">SQLiteが他の皆のように&lt;a href=&quot;https://git-scm.org&quot;&gt;Git&lt;/a&gt;バージョン管理システムを使用しないのはなぜかと不思議に思う人がよくいます。この記事はその質問に答えようとしています。また、この記事では、&lt;a href=&quot;#getthecode&quot;&gt;セクション3で&lt;/a&gt;、GitユーザーがSQLiteソースコードに簡単にアクセスする方法についてヒントを提供しています。</target>
        </trans-unit>
        <trans-unit id="a859905b933e3207fdf46d957c4ccc640fdf48ae" translate="yes" xml:space="preserve">
          <source>People who understand SQL can employ the &lt;a href=&quot;cli&quot;&gt;sqlite3 command-line shell&lt;/a&gt; (or various third-party SQLite access programs) to analyze large datasets. Raw data can be imported from CSV files, then that data can be sliced and diced to generate a myriad of summary reports. More complex analysis can be done using simple scripts written in Tcl or Python (both of which come with SQLite built-in) or in R or other languages using readily available adaptors. Possible uses include website log analysis, sports statistics analysis, compilation of programming metrics, and analysis of experimental results. Many bioinformatics researchers use SQLite in this way.</source>
          <target state="translated">SQLを理解している人は、&lt;a href=&quot;cli&quot;&gt;sqlite3コマンドラインシェル&lt;/a&gt;（またはさまざまなサードパーティのSQLiteアクセスプログラム）を使用して、大規模なデータセットを分析できます。生データをCSVファイルからインポートしてから、そのデータをスライスおよびダイシングして、無数のサマリーレポートを生成できます。より複雑な分析は、TclまたはPython（どちらもSQLiteが組み込まれています）またはRまたは他の言語で簡単に利用できるアダプターを使用して記述された単純なスクリプトを使用して実行できます。可能な用途には、ウェブサイトのログ分析、スポーツ統計分析、プログラミング指標の編集、実験結果の分析などがあります。多くのバイオインフォマティクス研究者は、このようにSQLiteを使用しています。</target>
        </trans-unit>
        <trans-unit id="deda64204144c5cb8a53d34e5d28a353e9faf513" translate="yes" xml:space="preserve">
          <source>Perform a single step of the incremental vacuum procedure on the P1 database. If the vacuum has finished, jump to instruction P2. Otherwise, fall through to the next instruction.</source>
          <target state="translated">P1データベース上でインクリメンタルバキュームプロシージャの1ステップを実行します。バキュームが終了したら、命令P2にジャンプします。それ以外の場合は、次の命令にフォールスルーします。</target>
        </trans-unit>
        <trans-unit id="54eef71ea08bf2a0291b4730516048fec290cbbf" translate="yes" xml:space="preserve">
          <source>Perform any required foreign key actions,</source>
          <target state="translated">必要な外部キーアクションを実行します。</target>
        </trans-unit>
        <trans-unit id="94e7748396990532238f46b792b6a833a4e68178" translate="yes" xml:space="preserve">
          <source>Perform some &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; operations in a single pass instead of in two passes.</source>
          <target state="translated">2つのパスではなく、1つのパスでいくつかの&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;操作を実行します。</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="0b4045b439e29414aaf2009ad15f476795f21a79" translate="yes" xml:space="preserve">
          <source>Performance Related Assumptions</source>
          <target state="translated">パフォーマンス関連の前提条件</target>
        </trans-unit>
        <trans-unit id="5539b01935cddeb466afb8949c00cacfd4174474" translate="yes" xml:space="preserve">
          <source>Performance can be improved and the size reduced by enabling &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=0&lt;/a&gt;, &lt;a href=&quot;compile#default_memstatus&quot;&gt;-DSQLITE_DEFAULT_MEMSTATUS=0&lt;/a&gt;, &lt;a href=&quot;compile#default_wal_synchronous&quot;&gt;-DSQLITE_DEFAULT_WAL_SYNCHRONOUS=1&lt;/a&gt;, &lt;a href=&quot;compile#like_doesnt_match_blobs&quot;&gt;-DSQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/a&gt;, &lt;a href=&quot;limits#max_expr_depth&quot;&gt;-DSQLITE_MAX_EXPR_DEPTH=0&lt;/a&gt;, &lt;a href=&quot;compile#omit_decltype&quot;&gt;-DSQLITE_OMIT_DECLTYPE&lt;/a&gt;, &lt;a href=&quot;compile#omit_deprecated&quot;&gt;-DSQLITE_OMIT_DEPRECATED&lt;/a&gt;, &lt;a href=&quot;compile#omit_progress_callback&quot;&gt;-DSQLITE_OMIT_PROGRESS_CALLBACK&lt;/a&gt;, &lt;a href=&quot;compile#omit_shared_cache&quot;&gt;-DSQLITE_OMIT_SHARED_CACHE&lt;/a&gt;, and &lt;a href=&quot;compile#use_alloca&quot;&gt;-DSQLITE_USE_ALLOCA&lt;/a&gt;. All these options together result in about a 3.5% performance increase and a 3.0% size reduction.</source>
          <target state="translated">性能を向上させることができ、サイズが有効に減少&lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE = 0&lt;/a&gt;、&lt;a href=&quot;compile#default_memstatus&quot;&gt;-DSQLITE_DEFAULT_MEMSTATUS = 0&lt;/a&gt;、&lt;a href=&quot;compile#default_wal_synchronous&quot;&gt;-DSQLITE_DEFAULT_WAL_SYNCHRONOUS = 1&lt;/a&gt;、&lt;a href=&quot;compile#like_doesnt_match_blobs&quot;&gt;-DSQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/a&gt;、&lt;a href=&quot;limits#max_expr_depth&quot;&gt;-DSQLITE_MAX_EXPR_DEPTH = 0&lt;/a&gt;、&lt;a href=&quot;compile#omit_decltype&quot;&gt;-DSQLITE_OMIT_DECLTYPEを&lt;/a&gt;、&lt;a href=&quot;compile#omit_deprecated&quot;&gt;-DSQLITE_OMIT_DEPRECATED&lt;/a&gt;、&lt;a href=&quot;compile#omit_progress_callback&quot;&gt;-DSQLITE_OMIT_PROGRESS_CALLBACK&lt;/a&gt;、&lt;a href=&quot;compile#omit_shared_cache&quot;&gt;-DSQLITE_OMIT_SHARED_CACHE&lt;/a&gt;、及び&lt;a href=&quot;compile#use_alloca&quot;&gt;-DSQLITE_USE_ALLOCA&lt;/a&gt;。これらすべてのオプションを組み合わせると、パフォーマンスが約3.5％向上し、サイズが3.0％削減されます。</target>
        </trans-unit>
        <trans-unit id="1860a0dfdb81986d4ea2f6eb535ec453b85d5fe2" translate="yes" xml:space="preserve">
          <source>Performance does not always increase with memory-mapped I/O. In fact, it is possible to construct test cases where performance is reduced by the use of memory-mapped I/O.</source>
          <target state="translated">メモリマップドI/Oを使用しても性能が常に向上するわけではありません。実際、メモリマップドI/Oを使用することで性能が低下するテストケースを構築することができます。</target>
        </trans-unit>
        <trans-unit id="61bd66ed39fd686f0ca14a86562254f51520b57c" translate="yes" xml:space="preserve">
          <source>Performance enhancement: Reengineer the internal routines used to interpret and render variable-length integers.</source>
          <target state="translated">パフォーマンスの向上。可変長整数の解釈およびレンダリングに使用される内部ルーチンをリエンジニアリングしました。</target>
        </trans-unit>
        <trans-unit id="cea233e3b9eddbf52457c8a5a182ae23ce06f170" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the &lt;a href=&quot;lemon&quot;&gt;Lemon&lt;/a&gt;-generated parser</source>
          <target state="translated">&lt;a href=&quot;lemon&quot;&gt;Lemonで&lt;/a&gt;生成されたパーサーのパフォーマンス強化</target>
        </trans-unit>
        <trans-unit id="c2ed78164f58cda3689de3af94b6683e701f4012" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the VDBE, especially to the OP_Column opcode.</source>
          <target state="translated">VDBEにおけるパフォーマンスの向上、特にOP_Columnオペコードの強化。</target>
        </trans-unit>
        <trans-unit id="3e83f7e02f169f16c4ce4c1bf1daf1d4f6a2d0dd" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the parser.</source>
          <target state="translated">パーサーのパフォーマンスを向上させました。</target>
        </trans-unit>
        <trans-unit id="1553d9684987d03c293eb61361d1bad6eb661140" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the sorter used by ORDER BY and CREATE INDEX.</source>
          <target state="translated">ORDER BYとCREATE INDEXで使用されるソーターのパフォーマンスが強化されました。</target>
        </trans-unit>
        <trans-unit id="d07c917b16f3c5d3172eade92a68d5375afe8a41" translate="yes" xml:space="preserve">
          <source>Performance enhancements on some corner cases of COUNT(*).</source>
          <target state="translated">COUNT(*)のいくつかのコーナーケースでのパフォーマンスの向上。</target>
        </trans-unit>
        <trans-unit id="2136335adf2e68388f67bd194f29e528095a22d7" translate="yes" xml:space="preserve">
          <source>Performance enhancements through reductions in disk I/O:</source>
          <target state="translated">ディスクI/Oの削減による性能向上</target>
        </trans-unit>
        <trans-unit id="f10f9c4b246cd76bbc82d16d809b97086003c9dc" translate="yes" xml:space="preserve">
          <source>Performance enhancements to tree balancing logic in the B-Tree layer.</source>
          <target state="translated">B-Tree レイヤのツリーバランシングロジックのパフォーマンスが強化されました。</target>
        </trans-unit>
        <trans-unit id="c1957e5fe4e4a95d607424db9c544dbfb2c9f147" translate="yes" xml:space="preserve">
          <source>Performance enhancements.</source>
          <target state="translated">パフォーマンスの強化。</target>
        </trans-unit>
        <trans-unit id="fd543174849447437d626cec826158c9d3d9aa89" translate="yes" xml:space="preserve">
          <source>Performance improvement: Constant subexpressions are factored out of loops.</source>
          <target state="translated">パフォーマンスの向上。定数の副表現はループの外で処理されます。</target>
        </trans-unit>
        <trans-unit id="6267206177784b60f0b03bc62ec213be82afcde6" translate="yes" xml:space="preserve">
          <source>Performance improvement: Results of OP_Column are reused rather than issuing multiple OP_Column opcodes.</source>
          <target state="translated">パフォーマンスの向上。複数のOP_Columnオペコードを発行するのではなく、OP_Columnの結果を再利用するようになりました。</target>
        </trans-unit>
        <trans-unit id="865a67eeabea312b0a75ae22ab67eb186cfe013a" translate="yes" xml:space="preserve">
          <source>Performance improvement: The OP_IdxDelete opcode uses unpacked records, obviating the need for one OP_MakeRecord opcode call for each index record deleted.</source>
          <target state="translated">パフォーマンスの向上。OP_IdxDelete オプトコードはアンパックされたレコードを使用し、削除されたインデックスレコードごとにOP_MakeRecord オプトコードを1回呼び出す必要がなくなりました。</target>
        </trans-unit>
        <trans-unit id="78e2db7e7f2b2267a1830af4b4a2ed0ba33c683b" translate="yes" xml:space="preserve">
          <source>Performance improvements for &quot;count(*)&quot; queries.</source>
          <target state="translated">count(*)クエリのパフォーマンスの向上。</target>
        </trans-unit>
        <trans-unit id="6efb6a4d8f17dc824c346d05f15cd7b2b88dcf5d" translate="yes" xml:space="preserve">
          <source>Performance improvements for &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt;, &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;, &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt;.</source>
          <target state="translated">以下のためのパフォーマンスの向上&lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt;、&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;、&lt;a href=&quot;lang_createindex&quot;&gt;INDEX、CREATE&lt;/a&gt;、&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;、および&lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_checkを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c7ba2d57a08f2fc705e0114aa7d1ce0a8358e340" translate="yes" xml:space="preserve">
          <source>Performance improvements for &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt;, especially in cases where the number of free pages is greater than what will fit on a single trunk page of the freelist.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuumの&lt;/a&gt;パフォーマンスの向上。特に、フリーページの数が、フリーリストの単一のトランクページに収まる数よりも多い場合。</target>
        </trans-unit>
        <trans-unit id="ca9c11fd98f734889e089bb0e89c4f23dda7fe58" translate="yes" xml:space="preserve">
          <source>Performance improvements in the LEMON-generated parser.</source>
          <target state="translated">LEMON生成パーサの性能向上。</target>
        </trans-unit>
        <trans-unit id="a14e5b6d4c4866ac4384c7883a92dffe274c0fdc" translate="yes" xml:space="preserve">
          <source>Performance improvements in the parser, pager, and WHERE clause code generator.</source>
          <target state="translated">パーサ、ページャー、WHERE句コード生成器の性能向上。</target>
        </trans-unit>
        <trans-unit id="4775771a833741ba344ee91f202aad2d4ccd4444" translate="yes" xml:space="preserve">
          <source>Performance improvements in the query optimizer.</source>
          <target state="translated">クエリオプティマイザの性能向上。</target>
        </trans-unit>
        <trans-unit id="db2c756a058cad6c443215c62bd837d8ebcd7c86" translate="yes" xml:space="preserve">
          <source>Performance improvements. The library is now much faster.</source>
          <target state="translated">パフォーマンスの向上。ライブラリが大幅に高速化されました。</target>
        </trans-unit>
        <trans-unit id="7776d02639084ffcec06b8eee5d8080752868819" translate="yes" xml:space="preserve">
          <source>Performance measurements are done with a single compiler (gcc 5.4.0), optimization setting (-Os), and on a single platform (Ubuntu 16.04 LTS on x64). The performance of other compilers and processors may vary.</source>
          <target state="translated">性能測定は、単一のコンパイラ(gcc 5.4.0)、最適化設定(-Os)、単一のプラットフォーム(Ubuntu 16.04 LTS on x64)で行っています。他のコンパイラやプロセッサの性能は異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="4313721e53c3870801c269d394561df5830ac670" translate="yes" xml:space="preserve">
          <source>Performance optimizations targeting a specific use case from a single high-profile user of SQLite. A 12% reduction in the number of CPU operations is achieved (as measured by Valgrind). Actual performance improvements in practice may vary depending on workload. Changes include:</source>
          <target state="translated">SQLiteの注目度の高い1人のユーザーから、特定のユースケースを対象としたパフォーマンスの最適化。CPU 操作数を 12% 削減しました(Valgrind で測定)。実際のパフォーマンス向上はワークロードによって異なる場合があります。変更点は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="aafc19be49f715a88d989d3b462949b02cf65924" translate="yes" xml:space="preserve">
          <source>Performance problems can often be resolved, even late in the development cycle, using &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, avoiding costly redesign, rewrite, and retest efforts.</source>
          <target state="translated">多くの場合、パフォーマンスの問題は、開発サイクルの後半でも&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;を使用して解決でき、コストのかかる再設計、再書き込み、再テストの作業を回避できます。</target>
        </trans-unit>
        <trans-unit id="80d748ed593bda4d15f97528a4a48c139940ad2c" translate="yes" xml:space="preserve">
          <source>Performance was measured by running speedtest1 using cachegrind and observing the &quot;I refs&quot; output.</source>
          <target state="translated">パフォーマンスは、cachegrind を使用して speedtest1 を実行し、&quot;I refs&quot; 出力を観察することで測定されました。</target>
        </trans-unit>
        <trans-unit id="fd932d13fa7bed8f3a51946f0c1cded4ce734cc8" translate="yes" xml:space="preserve">
          <source>Performance was measured using the &lt;a href=&quot;https://sqlite.org/src/file/test/speedtest1.c&quot;&gt;speedtest1.c&lt;/a&gt; utility program, which attempts to mimic a typical workload for SQLite. Options to the test runs are:</source>
          <target state="translated">パフォーマンスは、&lt;a href=&quot;https://sqlite.org/src/file/test/speedtest1.c&quot;&gt;speedite1.c&lt;/a&gt;ユーティリティプログラムを使用して測定されました。このプログラムは、SQLiteの典型的なワークロードを模倣しようとします。テスト実行のオプションは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="306df6900907956d3250e5c6b9116143f3e59d56" translate="yes" xml:space="preserve">
          <source>Perhaps you are referring to the following statement from SQL92:</source>
          <target state="translated">おそらく、SQL92の以下の文を参照しているのではないでしょうか。</target>
        </trans-unit>
        <trans-unit id="dc174949d4e077b47c1979929b03d9b696ed5987" translate="yes" xml:space="preserve">
          <source>Permit SELECT statements without a FROM clause.</source>
          <target state="translated">FROM句なしのSELECT文を許可します。</target>
        </trans-unit>
        <trans-unit id="6cbfe59727ef5993727b847bb5705e98e92cb339" translate="yes" xml:space="preserve">
          <source>Permutation</source>
          <target state="translated">Permutation</target>
        </trans-unit>
        <trans-unit id="4fce736ea498cc616300b0a192c1d1da1b783f4c" translate="yes" xml:space="preserve">
          <source>Permuted Title Index</source>
          <target state="translated">パーミュレートされたタイトルインデックス</target>
        </trans-unit>
        <trans-unit id="d33cf936053187794d74699260279a0a85c60b95" translate="yes" xml:space="preserve">
          <source>Persistent loadable extensions</source>
          <target state="translated">永続的にロード可能な拡張機能</target>
        </trans-unit>
        <trans-unit id="cda60e78224642430ac8ecc50f20cf5762fbe57b" translate="yes" xml:space="preserve">
          <source>Phrase and NEAR queries may not span multiple columns within a row.</source>
          <target state="translated">フレーズおよびNEARクエリは、行内の複数の列にまたがることができません。</target>
        </trans-unit>
        <trans-unit id="8867fcbca825b3aa1d7306421a378db86e201e5f" translate="yes" xml:space="preserve">
          <source>Phrase queries</source>
          <target state="translated">フレーズクエリ</target>
        </trans-unit>
        <trans-unit id="a363180d8d104ea58876b6a7416ecc65d37a83bd" translate="yes" xml:space="preserve">
          <source>Phrase queries are not available.</source>
          <target state="translated">フレーズクエリは利用できません。</target>
        </trans-unit>
        <trans-unit id="c2d36c2214269a55cf08fe15db0efb7f6b50dc52" translate="yes" xml:space="preserve">
          <source>Phrases and NEAR groups may also be connected by &lt;b&gt;implicit AND operators&lt;/b&gt;. For simplicity, these are not shown in the BNF grammar above. Essentially, any sequence of phrases or NEAR groups (including those restricted to matching specified columns) separated only by whitespace are handled as if there were an implicit AND operator between each pair of phrases or NEAR groups. Implicit AND operators are never inserted after or before an expression enclosed in parenthesis. For example:</source>
          <target state="translated">句とNEARグループは、&lt;b&gt;暗黙のAND演算子で&lt;/b&gt;接続することもできます。簡単にするために、これらは上記のBNF文法には示されていません。基本的に、空白でのみ区切られたフレーズまたはNEARグループのシーケンス（指定された列の一致に限定されたものを含む）は、フレーズまたはNEARグループの各ペア間に暗黙のAND演算子が存在するかのように処理されます。暗黙のAND演算子は、括弧で囲まれた式の前後に挿入されることはありません。例えば：</target>
        </trans-unit>
        <trans-unit id="c324bfc69bd8b1bd8095017021f5a91e3ea40b2c" translate="yes" xml:space="preserve">
          <source>Phrases and NEAR groups may be arranged into expressions using &lt;b&gt;boolean operators&lt;/b&gt;. In order of precedence, from highest (tightest grouping) to lowest (loosest grouping), the operators are:</source>
          <target state="translated">句とNEARグループは、&lt;b&gt;ブール演算子&lt;/b&gt;を使用して式に配置できます。優先順位の高い順に、最も高い（最もタイトなグループ化）から最も低い（最もルーズなグループ化）まで、演算子は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="3ae7ce4ac376e04456d5e49b6ed2413b1a3d558b" translate="yes" xml:space="preserve">
          <source>Picking the nested order of the various loops</source>
          <target state="translated">様々なループの入れ子になった順番をピックする</target>
        </trans-unit>
        <trans-unit id="e6557cb061d60a980305721118e117b8668196a9" translate="yes" xml:space="preserve">
          <source>Picking the nesting order is generally the more challenging problem. Once the nesting order of the join is established, the choice of indexes for each loop is normally obvious.</source>
          <target state="translated">入れ子の順番を選ぶことは、一般的にはより困難な問題です。結合の入れ子順序が確立されると、各ループのインデックスの選択は通常、明らかになります。</target>
        </trans-unit>
        <trans-unit id="48838d5eebf4e016bae8e0582e9b79166631f842" translate="yes" xml:space="preserve">
          <source>Pinning (reading) a database page.</source>
          <target state="translated">データベースのページをピン留め(読み込み)します。</target>
        </trans-unit>
        <trans-unit id="e786fb34d40222929b9ef3bd84afa78c0fc799e8" translate="yes" xml:space="preserve">
          <source>Plays better with virus scanners on Windows</source>
          <target state="translated">Windows上のウイルススキャナーとの相性が良い</target>
        </trans-unit>
        <trans-unit id="0ba6acad031749dfc1ea19f37cf3cf3ba6821875" translate="yes" xml:space="preserve">
          <source>Please pay particular attention to the fact that the pointer returned from &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_blob()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt; can be invalidated by a subsequent call to &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes16()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt;.</source>
          <target state="translated">ポインタがから返されたという事実に特に注意を払ってください&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_blob（） &lt;/a&gt;、&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text（） &lt;/a&gt;、または&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16（）&lt;/a&gt;へのその後の呼び出しによって無効化することができます&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes（） &lt;/a&gt;、&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes16（） &lt;/a&gt;、&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text（） &lt;/a&gt;、または&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7ae91e82ac5caaf87714c26921fb437ec0209ebd" translate="yes" xml:space="preserve">
          <source>Please pay particular attention to the fact that the pointer returned from &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_blob()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt; can be invalidated by a subsequent call to &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes16()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt;.</source>
          <target state="translated">ポインタがから返されたという事実に特に注意を払ってください&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_blob（） &lt;/a&gt;、&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text（） &lt;/a&gt;、または&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16（）&lt;/a&gt;へのその後の呼び出しによって無効化することができます&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes（） &lt;/a&gt;、&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes16（） &lt;/a&gt;、&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text（） &lt;/a&gt;、または&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="82e80b8ed5a5ef5a7f7f84502fd344efe74ab819" translate="yes" xml:space="preserve">
          <source>Plug some memory leaks that use to occur if malloc() failed. We have been and continue to be memory leak free as long as malloc() works.</source>
          <target state="translated">malloc()が失敗した場合に発生していたメモリリークを塞ぎます。malloc()が動作する限り、メモリリークはありません。</target>
        </trans-unit>
        <trans-unit id="9885c5aa124b354814a6a44123b3e909495fe046" translate="yes" xml:space="preserve">
          <source>Pointer Passing Interfaces</source>
          <target state="translated">ポインタパッシングインタフェース</target>
        </trans-unit>
        <trans-unit id="59e3eae717dea15b934265a0c37302cf590a5714" translate="yes" xml:space="preserve">
          <source>Pointer leak</source>
          <target state="translated">ポインターリーク</target>
        </trans-unit>
        <trans-unit id="893d8abe3b1d2dc513b4dcba9c2db9ee48da24a6" translate="yes" xml:space="preserve">
          <source>Pointer map or ptrmap pages are extra pages inserted into the database to make the operation of &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; modes more efficient. Other page types in the database typically have pointers from parent to child. For example, an interior b-tree page contains pointers to its child b-tree pages and an overflow chain has a pointer from earlier to later links in the chain. A ptrmap page contains linkage information going in the opposite direction, from child to parent.</source>
          <target state="translated">ポインターマップまたはptrmapページは、&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt;および&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt;モードの操作をより効率的にするためにデータベースに挿入される追加のページです。データベースの他のページタイプには、通常、親から子へのポインタがあります。たとえば、内部のBツリーページには、その子Bツリーページへのポインタが含まれており、オーバーフローチェーンには、チェーン内の前のリンクから後のリンクへのポインタがあります。ptrmapページには、子から親へと反対方向に進むリンク情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="d9fb370b0a40e2e2f19446936bcadb07206247ac" translate="yes" xml:space="preserve">
          <source>Pointer types</source>
          <target state="translated">ポインタ型</target>
        </trans-unit>
        <trans-unit id="1091e0ac6927998f6cf6d184bfe2c9b9dcea6870" translate="yes" xml:space="preserve">
          <source>Pointer types are static strings, which ideally should be string literals embedded directly in the SQLite API call, not parameters passed in from other functions. Consideration was given to using integer values as the pointer type, but static strings provides a much larger name space which reduces the chance of accidental type-name collisions between unrelated extensions.</source>
          <target state="translated">ポインタ型は静的文字列であり、理想的には SQLite API の呼び出しに直接埋め込まれた文字列リテラルであるべきであり、他の関数から渡されたパラメータではありません。ポインタ型として整数値を使用することも検討されましたが、静的文字列の方が名前空間が広くなるため、無関係な拡張モジュール間で型名の衝突が起こる可能性が低くなります。</target>
        </trans-unit>
        <trans-unit id="3b1d288532e92abf21814dda987180d6353e6315" translate="yes" xml:space="preserve">
          <source>Pointer values generated by &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; cannot be read by pure SQL. Hence, it is not possible for SQL to leak the value of pointers.</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;と&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;によって生成されたポインター値は、純粋なSQLでは読み取ることができません。したがって、SQLがポインターの値をリークすることはありません。</target>
        </trans-unit>
        <trans-unit id="362edd7f45230e1071baa348e5b8aa0beef2dc87" translate="yes" xml:space="preserve">
          <source>Pointer values must flow directly from their producer into their consumer, with no intermediate operators or functions. Any transformation of a pointer value destroys the pointer and transforms the value into an ordinary SQL NULL.</source>
          <target state="translated">ポインタ値は、中間演算子や関数を介さずに、生成者から消費者へ直接流れなければなりません。ポインタ値の変換は、ポインタを破棄し、値を通常のSQL NULLに変換します。</target>
        </trans-unit>
        <trans-unit id="d40a766f8bf600e29b3ebb06afc3c66d8eb2275c" translate="yes" xml:space="preserve">
          <source>Pointer values read by &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; cannot be generated by pure SQL. Hence, it is not possible for SQL to forge pointers.</source>
          <target state="translated">&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer（）&lt;/a&gt;によって読み取られたポインター値は、純粋なSQLでは生成できません。したがって、SQLがポインターを偽造することはできません。</target>
        </trans-unit>
        <trans-unit id="074017050c52f59774a49045cefb3a8e55469503" translate="yes" xml:space="preserve">
          <source>Pointers should &lt;u&gt;never&lt;/u&gt; be exchanged by encoding them as some other SQL datatype, such as integers or BLOBs. Instead, use the interfaces designed to facilitate secure pointer passing: &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt;, and &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;.</source>
          <target state="translated">ポインターは、整数やBLOBなどの他のSQLデータ型としてエンコードして交換する&lt;u&gt;ことは&lt;/u&gt;できませ&lt;u&gt;ん&lt;/u&gt;。代わりに、安全なポインターの受け渡しを容易にするために設計されたインターフェース&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;、&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;、および&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer（）を使用してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3758fcfa626c0aaafd8e85f7ec0b94d37eb1b41f" translate="yes" xml:space="preserve">
          <source>Porting SQLite To New Operating Systems</source>
          <target state="translated">新しいオペレーティングシステムへのSQLiteの移植</target>
        </trans-unit>
        <trans-unit id="492619cf72b9410d05b5a1fac306af0804a5c47b" translate="yes" xml:space="preserve">
          <source>Position cursor P1 at the end of the btree for the purpose of appending a new entry onto the btree.</source>
          <target state="translated">カーソルP1をbtreeの末尾に配置し、btreeに新しいエントリを追加する。</target>
        </trans-unit>
        <trans-unit id="24fd6c2d1150de6a47543209150ff4c2a2d3104f" translate="yes" xml:space="preserve">
          <source>PostgreSQL</source>
          <target state="translated">PostgreSQL</target>
        </trans-unit>
        <trans-unit id="a6c78fee1df30606dfc4f598f623eca0d1354255" translate="yes" xml:space="preserve">
          <source>PostgreSQL:</source>
          <target state="translated">PostgreSQL:</target>
        </trans-unit>
        <trans-unit id="957feaeb06e5a65656c3283c9c7193ebcf008b45" translate="yes" xml:space="preserve">
          <source>Postpone I/O associated with TEMP files for as long as possible, with the hope that the I/O can ultimately be avoided completely.</source>
          <target state="translated">TEMPファイルに関連するI/Oは、最終的にI/Oが完全に回避されることを期待して、できるだけ長く延期します。</target>
        </trans-unit>
        <trans-unit id="1bdd037a51c3dae4c27aa3b443867933947439ca" translate="yes" xml:space="preserve">
          <source>Powersafe Overwrite</source>
          <target state="translated">パワーズセーフ上書き</target>
        </trans-unit>
        <trans-unit id="10329807f69720bd141eb1a12685730b2cfaf4cd" translate="yes" xml:space="preserve">
          <source>Pragma list</source>
          <target state="translated">プラグマリスト</target>
        </trans-unit>
        <trans-unit id="c984aa3372c91f167c3b8d4c0c9f9715c82d4221" translate="yes" xml:space="preserve">
          <source>Pragma statements supported by SQLite</source>
          <target state="translated">SQLite でサポートされているプラグマ文</target>
        </trans-unit>
        <trans-unit id="4a80a5f45da767ce7271bd5ac307890ba0ff78a6" translate="yes" xml:space="preserve">
          <source>Pragmas whose names are &lt;s&gt;struck through&lt;/s&gt; are deprecated. Do not use them. They exist for historical compatibility.</source>
          <target state="translated">名前がされているプラグマ&lt;s&gt;によって打た&lt;/s&gt;廃止されました。使用しないでください。これらは、歴史的な互換性のために存在しています。</target>
        </trans-unit>
        <trans-unit id="36fd60583248a73e8dcb8aeb3b04450519f9ddea" translate="yes" xml:space="preserve">
          <source>Pray for your enemies in the love of Christ.</source>
          <target state="translated">キリストの愛のうちに敵のために祈りましょう。</target>
        </trans-unit>
        <trans-unit id="1d437b581e9dcd72eb07665e29677b9a7ea18988" translate="yes" xml:space="preserve">
          <source>Prefer nothing more than the love of Christ.</source>
          <target state="translated">キリストの愛以上のものはありません。</target>
        </trans-unit>
        <trans-unit id="6b85b242b16c8eaf303d30b62e8918e8c764ab9e" translate="yes" xml:space="preserve">
          <source>Prefix indexes may be used to optimize &lt;a href=&quot;fts3#termprefix&quot;&gt;prefix queries&lt;/a&gt; in two cases. If the query is for a prefix of N bytes, then a prefix index created with &quot;prefix=N&quot; provides the best optimization. Or, if no &quot;prefix=N&quot; index is available, a &quot;prefix=N+1&quot; index may be used instead. Using a &quot;prefix=N+1&quot; index is less efficient than a &quot;prefix=N&quot; index, but is better than no prefix index at all.</source>
          <target state="translated">プレフィックスインデックスは、2つのケースで&lt;a href=&quot;fts3#termprefix&quot;&gt;プレフィックスクエリ&lt;/a&gt;を最適化するために使用できます。クエリがNバイトのプレフィックスに対するものである場合、「prefix = N」で作成されたプレフィックスインデックスが最適化を提供します。または、「prefix = N」インデックスが使用できない場合は、代わりに「prefix = N + 1」インデックスを使用できます。&quot;prefix = N + 1&quot;インデックスを使用することは、 &quot;prefix = N&quot;インデックスより効率的ではありませんが、プレフィックスインデックスをまったく使用しないよりは優れています。</target>
        </trans-unit>
        <trans-unit id="f58acbef3b4f1545b36db43fdb7aa3248226ddc3" translate="yes" xml:space="preserve">
          <source>Prefix query</source>
          <target state="translated">プレフィックスクエリ</target>
        </trans-unit>
        <trans-unit id="d876a9e47626f4666efcfc69bdf4c50fcc426b9e" translate="yes" xml:space="preserve">
          <source>Prefix search in FTS3 is much more efficient.</source>
          <target state="translated">FTS3でのプレフィックス検索は、より効率的になりました。</target>
        </trans-unit>
        <trans-unit id="68a57fd3726c085ce337dc259dc3b2499a35efce" translate="yes" xml:space="preserve">
          <source>Preliminaries</source>
          <target state="translated">Preliminaries</target>
        </trans-unit>
        <trans-unit id="f3d20f83dbeeb1d79306958dea533c43146bb29c" translate="yes" xml:space="preserve">
          <source>Prepare Flags</source>
          <target state="translated">国旗の準備</target>
        </trans-unit>
        <trans-unit id="d5f65540d8f04f5669bf0a7783fb7256d5f3309f" translate="yes" xml:space="preserve">
          <source>Prepared Statement Object</source>
          <target state="translated">準備されたステートメントオブジェクト</target>
        </trans-unit>
        <trans-unit id="d84580c0a3c076e6a6095c0d8c0427ccdaa13d1e" translate="yes" xml:space="preserve">
          <source>Prepared Statement Scan Status</source>
          <target state="translated">作成されたステートメントのスキャン状況</target>
        </trans-unit>
        <trans-unit id="1037ef270384cfd9be096004017447826d2cb2f5" translate="yes" xml:space="preserve">
          <source>Prepared Statement Scan Status Opcodes</source>
          <target state="translated">準備されたステートメントスキャンの状態のオプコード</target>
        </trans-unit>
        <trans-unit id="2f5da103100b3440f26c60eb3e05807f62717d70" translate="yes" xml:space="preserve">
          <source>Prepared Statement Status</source>
          <target state="translated">作成されたステートメントの状況</target>
        </trans-unit>
        <trans-unit id="213d6f218c41a8dc480fb564c77564038e40e839" translate="yes" xml:space="preserve">
          <source>Prepend as many &quot;0&quot; characters to numeric substitutions as necessary to expand the value out to the specified width. If the width field is omitted, then this flag is a no-op.</source>
          <target state="translated">指定された幅に値を展開するために、必要なだけ多くの &quot;0 &quot;文字を数値置換にプリペンドします。幅フィールドが省略された場合、このフラグは無効となります。</target>
        </trans-unit>
        <trans-unit id="07ea5425dab39a1ce6090bfaba72b208d8a2bb32" translate="yes" xml:space="preserve">
          <source>Prepend the &quot;&lt;code&gt;file:&lt;/code&gt;&quot; scheme.</source>
          <target state="translated">「 &lt;code&gt;file:&lt;/code&gt; 」スキームを付加します。</target>
        </trans-unit>
        <trans-unit id="b5b2c6aa0c741177b3341a9cac682f0503cc7181" translate="yes" xml:space="preserve">
          <source>Pretend that the single row just extracted is the only row in the recursive table and run the recursive-select, adding all results to the queue.</source>
          <target state="translated">先ほど抽出した単一の行が再帰テーブルの唯一の行であると仮定して、すべての結果をキューに追加して再帰的選択を実行します。</target>
        </trans-unit>
        <trans-unit id="e96fea52df5eb0d7ea088eb0523f5fd6be20645f" translate="yes" xml:space="preserve">
          <source>Prev</source>
          <target state="translated">Prev</target>
        </trans-unit>
        <trans-unit id="d011a785f80d4ac2978260fd4baeb9a488339607" translate="yes" xml:space="preserve">
          <source>Prevent journal file overflows on huge transactions.</source>
          <target state="translated">膨大なトランザクションでのジャーナルファイルのオーバーフローを防止します。</target>
        </trans-unit>
        <trans-unit id="15aff2aaf0be53526cd90b44a8f7faa67462af63" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/docsrc&quot;&gt;https://www.sqlite.org/docsrc&lt;/a&gt;</source>
          <target state="translated">主な場所：&lt;a href=&quot;https://www.sqlite.org/docsrc&quot;&gt;https&lt;/a&gt; : //www.sqlite.org/docsrc</target>
        </trans-unit>
        <trans-unit id="bb559fe38e423e3bb19de0649fe3fd5b6b237723" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/sqllogictest&quot;&gt;https://www.sqlite.org/sqllogictest&lt;/a&gt;</source>
          <target state="translated">主な場所：&lt;a href=&quot;https://www.sqlite.org/sqllogictest&quot;&gt;https&lt;/a&gt; : //www.sqlite.org/sqllogictest</target>
        </trans-unit>
        <trans-unit id="40da77fe99b4c2e0002b4b5a88b9bdf5b5ffd788" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/src&quot;&gt;https://www.sqlite.org/src&lt;/a&gt;</source>
          <target state="translated">主な場所：&lt;a href=&quot;https://www.sqlite.org/src&quot;&gt;https&lt;/a&gt; : //www.sqlite.org/src</target>
        </trans-unit>
        <trans-unit id="72c44b5ab0d08449343e1c11f7db59a0baee6a06" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/th3&quot;&gt;https://www.sqlite.org/th3&lt;/a&gt;</source>
          <target state="translated">主な場所：&lt;a href=&quot;https://www.sqlite.org/th3&quot;&gt;https&lt;/a&gt; : //www.sqlite.org/th3</target>
        </trans-unit>
        <trans-unit id="284d8db03255f327420e4917415f7de011fcda53" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/th3private&quot;&gt;https://www.sqlite.org/th3private&lt;/a&gt;</source>
          <target state="translated">主な場所：&lt;a href=&quot;https://www.sqlite.org/th3private&quot;&gt;https&lt;/a&gt; : //www.sqlite.org/th3private</target>
        </trans-unit>
        <trans-unit id="12c6ce30d8dde9c30a0548e43a1a65f2399c3ac8" translate="yes" xml:space="preserve">
          <source>Primary result code symbolic names are of the form &quot;SQLITE_XXXXXX&quot; where XXXXXX is a sequence of uppercase alphabetic characters. Extended result code names are of the form &quot;SQLITE_XXXXXX_YYYYYYY&quot; where the XXXXXX part is the corresponding primary result code and the YYYYYYY is an extension that further classifies the result code.</source>
          <target state="translated">一次結果コードのシンボリック名は、&quot;SQLITE_XXXXXXXX &quot;という形式で、XXXXXXはアルファベット大文字のシーケンスです。拡張結果コード名は &quot;SQLITE_XXXXXXXX_YYYYY &quot;の形式で、XXXXXX の部分は対応する一次結果コードであり、YYYYYY は結果コードをさらに分類する拡張コードです。</target>
        </trans-unit>
        <trans-unit id="4fda803b9a957798a3e6c9099105e126c5e73e36" translate="yes" xml:space="preserve">
          <source>Primary versus extended result codes</source>
          <target state="translated">一次結果コードと拡張結果コード</target>
        </trans-unit>
        <trans-unit id="3b2d52029dad08f51a816bff4a2b1ace042995a8" translate="yes" xml:space="preserve">
          <source>Print the offending SQL statement when an error occurs.</source>
          <target state="translated">エラーが発生した場合、問題のある SQL 文を表示します。</target>
        </trans-unit>
        <trans-unit id="93863d358af110c5080e64cc1cfc5d8749e0490f" translate="yes" xml:space="preserve">
          <source>Prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26), SQLite always used the &quot;Nearest Neighbor&quot; or &quot;NN&quot; heuristic when searching for the best query plan. The NN heuristic makes a single traversal of the graph, always choosing the lowest-cost arc as the next step. The NN heuristic works surprisingly well in most cases. And NN is fast, so that SQLite is able to quickly find good plans for even large 64-way joins. In contrast, other SQL database engines that do more extensive searching tend to bog down when the number of tables in a join goes above 10 or 15.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;バージョン3.8.0&lt;/a&gt;（2013-08-26）より前のSQLiteでは、最適なクエリプランを検索するときに、常に「最近傍」または「NN」ヒューリスティックを使用していました。NNヒューリスティックは、グラフを1回トラバースし、次のステップとして常に最低コストのアークを選択します。ほとんどの場合、NNヒューリスティックは驚くほどうまく機能します。また、NNは高速であるため、SQLiteは、大規模な64方向結合についても適切な計画をすばやく見つけることができます。対照的に、より広範な検索を行う他のSQLデータベースエンジンは、結合内のテーブルの数が10または15を超えると、パフォーマンスが低下する傾向があります。</target>
        </trans-unit>
        <trans-unit id="0cbead769cfd094dac2d1d702814135203e88038" translate="yes" xml:space="preserve">
          <source>Prior to SQLite 3.20.0 (2017-08-01) all date/time functions were always considered non-deterministic. The ability for date/time functions to be deterministic sometimes and non-deterministic at other times, depending on their arguments, was added for the 3.20.0 release.</source>
          <target state="translated">SQLite 3.20.0 (2017-08-01)より前は、すべての date/time 関数は常に非決定論的とみなされていました。3.20.0 リリースでは、引数に応じて date/time 関数が決定論的になることもあれば、非決定論的になることもあるという機能が追加されました。</target>
        </trans-unit>
        <trans-unit id="6c7f8cc84bc5292827563b13ba75248881d97140" translate="yes" xml:space="preserve">
          <source>Prior to SQLite 3.7.15 (2012-12-12), a subquery in the FROM clause would be either flattened into the outer query, or else the subquery would be run to completion before the outer query started, the result set from the subquery would be stored in a transient table, and then the transient table would be used in the outer query. Newer versions of SQLite have a third option, which is to implement the subquery using a co-routine.</source>
          <target state="translated">SQLite 3.7.15 (2012-12-12)より前のバージョンでは、FROM句の副問い合わせは外部の問い合わせに平坦化されるか、外部の問い合わせが開始される前に副問い合わせが完了するまで実行され、副問い合わせの結果セットが過渡的なテーブルに格納され、その後、過渡的なテーブルが外部の問い合わせで使用されていました。新しいバージョンのSQLiteには3つ目のオプションがあり、それはcoroutineを使用して副問い合わせを実装することです。</target>
        </trans-unit>
        <trans-unit id="a720aafd2afa8c2c385472fc2e648bd2ccdf321e" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;version 3.11.0&lt;/a&gt; (2016-02-15), the arguments to fts3_tokenzer() could be literal strings or BLOBs. They did not have to be &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;. But that could lead to security problems in the event of an SQL injection. Hence, the legacy behavior is now disabled by default. But the old legacy behavior can be enabled, for backwards compatibility in applications that really need it, by calling &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;,1,0).</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;バージョン3.11.0&lt;/a&gt;（2016-02-15）より前のバージョンでは、fts3_tokenzer（）への引数はリテラル文字列またはBLOBでした。それらは&lt;a href=&quot;lang_expr#varparam&quot;&gt;バインドされたパラメータである&lt;/a&gt;必要はありませんでした。しかし、SQLインジェクションが発生すると、セキュリティ上の問題が発生する可能性があります。そのため、従来の動作はデフォルトで無効になっています。ただし、&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;、1,0）を呼び出すことで、以前の動作を有効にして、本当に必要なアプリケーションの下位互換性を保つことができます。</target>
        </trans-unit>
        <trans-unit id="51d8edb11a84377ed9b294770763b3964473b7ee" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;version 3.6.17&lt;/a&gt; (2009-08-10), the virtual table mechanism assumes that each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; kept its own copy of the database schema. Hence, the virtual table mechanism could not be used in a database that has &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; enabled. The &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; interface would return an error if &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; is enabled. That restriction was relaxed beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;version 3.6.17&lt;/a&gt;.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;バージョン3.6.17&lt;/a&gt;（2009-08-10）より前のバージョンでは、仮想テーブルメカニズムは、各&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;が独自のデータベーススキーマのコピーを保持していると想定していました。したがって、仮想テーブルメカニズムは、&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュモードが&lt;/a&gt;有効になっているデータベースでは使用できませんでした。&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module（）&lt;/a&gt;場合のインタフェースはエラーを返します&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュモードが&lt;/a&gt;有効になっています。この制限はSQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;バージョン3.6.17&lt;/a&gt;から緩和されました。</target>
        </trans-unit>
        <trans-unit id="33d0fd70a8f55e9f98c0c7adf04301e981d0c322" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;version 3.6.18&lt;/a&gt; (2009-09-11), recursive triggers were not supported. The behavior of SQLite was always as if this pragma was set to OFF. Support for recursive triggers was added in version 3.6.18 but was initially turned OFF by default, for compatibility. Recursive triggers may be turned on by default in future versions of SQLite.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;バージョン3.6.18&lt;/a&gt;（2009-09-11）より前は、再帰トリガーはサポートされていませんでした。 SQLiteの動作は、このプラグマがOFFに設定されているかのようでした。再帰トリガーのサポートはバージョン3.6.18で追加されましたが、互換性のためにデフォルトでデフォルトでオフにされました。 SQLiteの将来のバージョンでは、再帰トリガーがデフォルトでオンになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="a28758e140ed243892fd7015e84c9739d352fdbe" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;version 3.6.18&lt;/a&gt; (2009-09-11), triggers were not recursive and so this limit was meaningless. Beginning with version 3.6.18, recursive triggers were supported but had to be explicitly enabled using the &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt; statement. Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2009-09-11), recursive triggers are enabled by default but can be manually disabled using &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt;. The SQLITE_MAX_TRIGGER_DEPTH is only meaningful if recursive triggers are enabled.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;バージョン3.6.18&lt;/a&gt;（2009-09-11）より前は、トリガーは再帰的ではなかったため、この制限は意味がありませんでした。バージョン3.6.18以降、再帰トリガーがサポートされていましたが、&lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt;ステートメントを使用して明示的に有効にする必要がありました。始まる&lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;バージョン3.7.0&lt;/a&gt;（2009-09-11）、再帰的なトリガはデフォルトで有効になっていますが、手動で使用して無効にすることができ&lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;プラグマRECURSIVE_TRIGGERSを&lt;/a&gt;。SQLITE_MAX_TRIGGER_DEPTHは、再帰トリガーが有効になっている場合にのみ意味があります。</target>
        </trans-unit>
        <trans-unit id="534f30ad3bfba01b49cf3bf01218d9cf22140413" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.17.0, the session extension only worked with &lt;a href=&quot;rowidtable&quot;&gt;rowid tables&lt;/a&gt;, not &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. As of 3.17.0, both rowid and WITHOUT ROWID tables are supported.</source>
          <target state="translated">SQLiteバージョン3.17.0に先立ち、セッション延長はわずかで働いた&lt;a href=&quot;rowidtable&quot;&gt;ROWIDのテーブル&lt;/a&gt;ではない、&lt;a href=&quot;withoutrowid&quot;&gt;ROWIDのWITHOUT&lt;/a&gt;テーブル。3.17.0以降、ROWIDテーブルとWITHOUT ROWIDテーブルの両方がサポートされています。</target>
        </trans-unit>
        <trans-unit id="8ca3ddf5fd526ae6f9a1aaa722828cf40f2bf92a" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.3.14, a sector size of 512 bytes was assumed in all cases. There was a compile-time option to change this but the code had never been tested with a larger value. The 512 byte sector assumption seemed reasonable since until very recently all disk drives used a 512 byte sector internally. However, there has recently been a push to increase the sector size of disks to 4096 bytes. Also the sector size for flash memory is usually larger than 512 bytes. For these reasons, versions of SQLite beginning with 3.3.14 have a method in the OS interface layer that interrogates the underlying filesystem to find the true sector size. As currently implemented (version 3.5.0) this method still returns a hard-coded value of 512 bytes, since there is no standard way of discovering the true sector size on either Unix or Windows. But the method is available for embedded device manufacturers to tweak according to their own needs. And we have left open the possibility of filling in a more meaningful implementation on Unix and Windows in the future.</source>
          <target state="translated">SQLite バージョン 3.3.14 より前のバージョンでは、すべてのケースで 512 バイトのセクタサイズが想定されていました。これを変更するコンパイル時のオプションがありましたが、コードはこれより大きな値でテストされたことがありませんでした。最近まですべてのディスクドライブは内部的に 512 バイトのセクタを使用していたので、512 バイトのセクタを仮定するのは妥当なように思えました。しかし、最近ではディスクのセクタサイズを4096バイトに拡大する動きがあります。また、フラッシュメモリのセクタサイズは通常 512 バイトよりも大きくなっています。これらの理由から、3.3.14 以降のバージョンの SQLite では、OS インターフェイス層にメソッドが用意されており、ファイルシステムを照会して本当のセクタサイズを見つけることができるようになっています。現在実装されている(バージョン3.5.0)このメソッドは、UnixやWindowsには真のセクタサイズを発見する標準的な方法がないため、まだ512バイトのハードコードされた値を返します。しかし、この方法は組み込み機器メーカーが独自のニーズに応じて調整できるようになっています。そして、将来的にはUnixやWindows上でより意味のある実装を行う可能性を残しています。</target>
        </trans-unit>
        <trans-unit id="d9c2ee7b5aac6da179c8f578b8285aa5c54f4524" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.7.10, the Windows OS interface layer called the system malloc() and free() directly when converting filenames between the UTF-8 encoding used by SQLite and whatever filename encoding is used by the particular Windows installation. Memory allocation errors were detected, but they were reported back as &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_IOERR&lt;/a&gt; rather than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;.</source>
          <target state="translated">SQLiteバージョン3.7.10より前は、SQLiteで使用されるUTF-8エンコーディングと特定のWindowsインストールで使用されるファイル名エンコーディング間でファイル名を変換するときに、Windows OSインターフェースレイヤーがシステムのmalloc（）とfree（）を直接呼び出しました。メモリ割り当てエラーが検出されましたが、それらは&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;ではなく&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt;またはSQLITE_IOERRとして報告され&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;ました&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="91089ffc77affdb7ae59f739dbaf9014a293f340" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.7.10, the Windows OS interface layer called the system malloc() and free() directly when converting filenames between the UTF-8 encoding used by SQLite and whatever filename encoding is used by the particular Windows installation. Memory allocation errors were detected, but they were reported back as &lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; or &lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; rather than &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;.</source>
          <target state="translated">SQLiteバージョン3.7.10より前は、SQLiteで使用されるUTF-8エンコーディングと特定のWindowsインストールで使用されるファイル名エンコーディング間でファイル名を変換するときに、Windows OSインターフェースレイヤーがシステムのmalloc（）とfree（）を直接呼び出しました。メモリ割り当てエラーが検出されましたが、それらは&lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_NOMEM&lt;/a&gt;ではなく&lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt;またはSQLITE_IOERRとして報告され&lt;a href=&quot;../rescode#nomem&quot;&gt;ました&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f00bebae92fba462c0a2ff1a68401159dfc1bce" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.8.2 (2013-12-06), casting a REAL value greater than +9223372036854775807.0 into an integer resulted in the most negative integer, -9223372036854775808. This behavior was meant to emulate the behavior of x86/x64 hardware when doing the equivalent cast.</source>
          <target state="translated">SQLite バージョン 3.8.2 (2013-12-06)より前のバージョンでは、+9223372036854775807.0 より大きい REAL 値を整数にキャストすると、最も負の整数である -9223372036854775808 が得られました。この動作は、x86/x64ハードウェアで同等のキャストを行う際の動作をエミュレートすることを意図していました。</target>
        </trans-unit>
        <trans-unit id="a1634472b77cd282aba3425a6cf5a2a4d268772c" translate="yes" xml:space="preserve">
          <source>Prior to each check-in to the SQLite source tree, developers typically run a subset (called &quot;veryquick&quot;) of the Tcl tests consisting of about 248.5 thousand test cases. The veryquick tests include most tests other than the anomaly, fuzz, and soak tests. The idea behind the veryquick tests are that they are sufficient to catch most errors, but also run in only a few minutes instead of a few hours.</source>
          <target state="translated">SQLite のソースツリーにチェックインする前に、開発者は通常、約 248.5 千のテストケースからなる Tcl テストのサブセット (veryquick と呼ばれる)を実行します。veryquickテストには、アノマリー、ファズ、ソークテスト以外のほとんどのテストが含まれています。veryquickテストの背後にある考えは、ほとんどのエラーをキャッチするのに十分であると同時に、数時間ではなく数分で実行されるということです。</target>
        </trans-unit>
        <trans-unit id="ce5fd27df1123f4d155915fc1d5725287e09a7ea" translate="yes" xml:space="preserve">
          <source>Prior to making any changes to the database file, SQLite first creates a separate rollback journal file and writes into the rollback journal the original content of the database pages that are to be altered. The idea behind the rollback journal is that it contains all information needed to restore the database back to its original state.</source>
          <target state="translated">データベース ファイルに変更を加える前に、SQLite は最初に別のロールバック ジャーナル ファイルを作成し、変更するデータベース ページの元の内容をロールバック ジャーナルに書き込みます。ロールバック ジャーナルには、データベースを元の状態に戻すために必要なすべての情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="5e201518d0d186ad7cdf7483565006fe761fd040" translate="yes" xml:space="preserve">
          <source>Prior to making changes to the database file itself, we must obtain an exclusive lock on the database file. Obtaining an exclusive lock is really a two-step process. First SQLite obtains a &quot;pending&quot; lock. Then it escalates the pending lock to an exclusive lock.</source>
          <target state="translated">データベースファイル自体に変更を加える前に、データベースファイルの排他的なロックを取得しなければなりません。排他的なロックを取得するには、実際には2段階のプロセスがあります。最初にSQLiteは「保留中」のロックを取得します。次に、保留中のロックを排他的なロックにエスカレートします。</target>
        </trans-unit>
        <trans-unit id="3f85c53dbe23e0808bcb91d75d8ad07e4c7bc69c" translate="yes" xml:space="preserve">
          <source>Prior to version 3.26.0 (2018-12-01), FOREIGN KEY references to a table that is renamed were only edited if the &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=ON&lt;/a&gt;, or in other words if &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt; were begin enforced. With &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=OFF&lt;/a&gt;, FOREIGN KEY constraints would not be changed when the table that the foreign key referred to (the &quot;&lt;a href=&quot;foreignkeys#parentchild&quot;&gt;parent table&lt;/a&gt;&quot;) was renamed. Beginning with version 3.26.0, FOREIGN KEY constraints are always converted when a table is renamed, unless the &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table=ON&lt;/a&gt; setting is engaged. The following table summaries the difference:</source>
          <target state="translated">バージョン3.26.0（2018-12-01）より前は、名前が変更されたテーブルへのFOREIGN KEY参照は、&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys = ONの&lt;/a&gt;場合、つまり&lt;a href=&quot;foreignkeys&quot;&gt;外部キー制約&lt;/a&gt;が適用され始めた場合にのみ編集されました。&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;プラグマFOREIGN_KEYS = OFF&lt;/a&gt;外部キーが（「に言及するテーブルと、FOREIGN KEY制約を変更することはないだろう&lt;a href=&quot;foreignkeys#parentchild&quot;&gt;、親テーブルが&lt;/a&gt;」）と改名されました。バージョン3.26.0以降、&lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table = ON&lt;/a&gt;設定が有効になっていない限り、テーブルの名前が変更されると、FOREIGN KEY制約は常に変換されます。次の表は、違いをまとめたものです。</target>
        </trans-unit>
        <trans-unit id="5f15493198f102fc11171baf7abf0e0dbb2b1e4b" translate="yes" xml:space="preserve">
          <source>Prior to version 3.5.0 the &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; function would try to reclaim memory from all database connections in the same thread as the sqlite3_release_memory() call. Beginning with version 3.5.0, the sqlite3_release_memory() function will attempt to reclaim memory from all database connections in all threads.</source>
          <target state="translated">バージョン3.5.0より前は、&lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory（）&lt;/a&gt;関数は、sqlite3_release_memory（）呼び出しと同じスレッド内のすべてのデータベース接続からメモリを再利用しようとしました。バージョン3.5.0以降、sqlite3_release_memory（）関数は、すべてのスレッドのすべてのデータベース接続からメモリを再利用しようとします。</target>
        </trans-unit>
        <trans-unit id="4167592bfe9ab2523a8fde6561d95f830a107410" translate="yes" xml:space="preserve">
          <source>Prior to version 3.5.0 the &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt; set an upper bound on heap memory usage for all database connections within a single thread. Each thread could have its own heap limit. Beginning in version 3.5.0, there is a single heap limit for the entire process. This seems more restrictive (one limit as opposed to many) but in practice it is what most users want.</source>
          <target state="translated">バージョン3.5.0より前の&lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit（）&lt;/a&gt;は、単一スレッド内のすべてのデータベース接続のヒープメモリ使用量の上限を設定していました。各スレッドには独自のヒープ制限を設定できます。バージョン3.5.0以降では、プロセス全体に対して単一のヒープ制限があります。これはより制限的です（多くの制限ではなく1つの制限）が、実際にはほとんどのユーザーが望んでいます。</target>
        </trans-unit>
        <trans-unit id="fc681e809e94e340265ecee10f223e6915cced6a" translate="yes" xml:space="preserve">
          <source>Prior to version 3.5.0, the &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; API would enable and disable the shared cache feature for all connections within a single thread - the same thread from which the sqlite3_enable_shared_cache() routine was called. Database connections that used the shared cache were restricted to running in the same thread in which they were opened. Beginning with version 3.5.0, the sqlite3_enable_shared_cache() applies to all database connections in all threads within the process. Now database connections running in separate threads can share a cache. And database connections that use shared cache can migrate from one thread to another.</source>
          <target state="translated">バージョン3.5.0より前は、&lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（）&lt;/a&gt; APIは、単一のスレッド（sqlite3_enable_shared_cache（）ルーチンが呼び出されたのと同じスレッド）内のすべての接続の共有キャッシュ機能を有効または無効にしていました。共有キャッシュを使用したデータベース接続は、それらが開かれたのと同じスレッドでの実行に制限されていました。バージョン3.5.0以降、sqlite3_enable_shared_cache（）はプロセス内のすべてのスレッドのすべてのデータベース接続に適用されます。別のスレッドで実行されているデータベース接続がキャッシュを共有できるようになりました。また、共有キャッシュを使用するデータベース接続は、あるスレッドから別のスレッドに移行できます。</target>
        </trans-unit>
        <trans-unit id="d828632471991da7903c0c2be934633680ad57e8" translate="yes" xml:space="preserve">
          <source>Process A now tries to write to the database. But process A's view of the database content is now obsolete because process B has modified the database file after process A read from it. Hence process A gets an SQLITE_BUSY_SNAPSHOT error.</source>
          <target state="translated">プロセスAはデータベースに書き込もうとします。しかし、プロセスAがデータベースから読み込んだ後にプロセスBがデータベースファイルを変更したため、プロセスAのデータベースコンテンツのビューは現在では時代遅れになっています。そのため、プロセスAはSQLITE_BUSY_SNAPSHOTエラーを取得します。</target>
        </trans-unit>
        <trans-unit id="6588c47b29127d1f98a87c238369e743b0e77d94" translate="yes" xml:space="preserve">
          <source>Process A starts a read transaction on the database and does one or more SELECT statement. Process A keeps the transaction open.</source>
          <target state="translated">プロセスAは、データベース上の読み取りトランザクションを開始し、1つ以上のSELECT文を実行します。プロセスAはトランザクションをオープンしたままにします。</target>
        </trans-unit>
        <trans-unit id="7e082f5417cd4ab89e9c56b231bce953e66b35a9" translate="yes" xml:space="preserve">
          <source>Process B updates the database, changing values previous read by process A.</source>
          <target state="translated">プロセスBは、プロセスAによって以前に読み込まれた値を変更してデータベースを更新します。</target>
        </trans-unit>
        <trans-unit id="ee0914d299e6e7430a22ed0faafffc12d302d567" translate="yes" xml:space="preserve">
          <source>Productize and officially support the group_concat() SQL function.</source>
          <target state="translated">SQL関数group_concat()をプロダクト化し、正式にサポートします。</target>
        </trans-unit>
        <trans-unit id="9257f2cbe973bd89967c512a0ab4ef3a71be8dcc" translate="yes" xml:space="preserve">
          <source>Profile guided optimization (PGO) is not helpful with SQLite. PGO results in binaries that are about 1% larger and about 0.33% slower.</source>
          <target state="translated">プロファイルガイド付き最適化 (PGO)は SQLite では役に立ちません。PGOの結果、バイナリは約1%大きくなり、約0.33%遅くなります。</target>
        </trans-unit>
        <trans-unit id="b46994e8cc3c2683acbfd969c84c88b83b02d9c0" translate="yes" xml:space="preserve">
          <source>Profiling indicates that for most systems and in most circumstances SQLite spends most of its time doing disk I/O. It follows then that anything we can do to reduce the amount of disk I/O will likely have a large positive impact on the performance of SQLite. This section describes some of the techniques used by SQLite to try to reduce the amount of disk I/O to a minimum while still preserving atomic commit.</source>
          <target state="translated">プロファイリングによると、ほとんどのシステムで、またほとんどの状況で、SQLiteはディスクI/Oの実行にほとんどの時間を費やしていることがわかります。したがって、ディスク I/O の量を減らすためにできることは何でも、SQLite のパフォーマンスに大きなプラスの影響を与えることになります。この節では、アトミックコミットを維持しつつディスクI/Oの量を最小限に抑えるためにSQLiteで使用されている技術のいくつかを説明します。</target>
        </trans-unit>
        <trans-unit id="9d68007b0763cb230f9034ec96f52b39d03ad630" translate="yes" xml:space="preserve">
          <source>Program</source>
          <target state="translated">Program</target>
        </trans-unit>
        <trans-unit id="6bc5295aed74aa8af8bf9a74f722f2706e580d3c" translate="yes" xml:space="preserve">
          <source>Programmers are cautioned not to use the two exceptions described in the previous bullets. We emphasize that they exist only so that old and ill-formed SQL statements will run correctly. Future versions of SQLite might raise errors instead of accepting the malformed statements covered by the exceptions above.</source>
          <target state="translated">プログラマーは、前の箇条書きで説明した2つの例外を使用しないように注意してください。これらの例外は、古くて形の悪い SQL 文が正しく実行されるためだけに存在することを強調しています。将来のバージョンのSQLiteでは、上記の例外でカバーされている不正な形式の文を受け入れる代わりにエラーが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="442f2f1b223aedc9d27d672e9d91f49a3b27fb5b" translate="yes" xml:space="preserve">
          <source>Programmers can force SQLite to use a particular loop nesting order for a join by using the CROSS JOIN operator instead of just JOIN, INNER JOIN, NATURAL JOIN, or a &quot;,&quot; join. Though CROSS JOINs are commutative in theory, SQLite chooses to never reorder the tables in a CROSS JOIN. Hence, the left table of a CROSS JOIN will always be in an outer loop relative to the right table.</source>
          <target state="translated">プログラマーは、JOIN、INNER JOIN、NATURAL JOIN、または&quot;,&quot;結合の代わりにCROSS JOIN演算子を使用することで、SQLiteが結合に特定のループの入れ子順序を使用するように強制することができます。理論的にはCROSS JOINは可換的ですが、SQLiteはCROSS JOINの中でテーブルの並び替えを行わないことを選択しています。そのため、CROSS JOINの左テーブルは常に右テーブルからの相対的な外部ループ内にあります。</target>
        </trans-unit>
        <trans-unit id="9ecd00ed19c9aa2f215c5b5e8453037ffd17fc89" translate="yes" xml:space="preserve">
          <source>Programming Interfaces</source>
          <target state="translated">プログラミングインタフェース</target>
        </trans-unit>
        <trans-unit id="1c8b4bfbf1e2ec54cc62ffa3332992d5ae9a4350" translate="yes" xml:space="preserve">
          <source>Programming Loadable Extensions</source>
          <target state="translated">ロード可能な拡張機能のプログラミング</target>
        </trans-unit>
        <trans-unit id="19ca1fa808a68639f1670f7213bf267471fdbd20" translate="yes" xml:space="preserve">
          <source>Programs contain a single instance of this opcode as the very first opcode.</source>
          <target state="translated">プログラムは、このオペコードの単一のインスタンスを最初のオペコードとして含みます。</target>
        </trans-unit>
        <trans-unit id="7b85e7edf23f7121981c9a7f81acf2f88e25d897" translate="yes" xml:space="preserve">
          <source>Prohibit the use of SQL functions inside triggers, views, CHECK constraints, DEFAULT clauses, expression indexes, partial indexes, or generated columns unless those functions are tagged with &lt;a href=&quot;#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt;.</source>
          <target state="translated">これらの関数が&lt;a href=&quot;#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUSで&lt;/a&gt;タグ付けされていない限り、トリガー、ビュー、CHECK制約、DEFAULT句、式インデックス、部分インデックス、または生成された列内でのSQL関数の使用を禁止します。</target>
        </trans-unit>
        <trans-unit id="836cdbe091f8e6d2e0a3bc0953580f5b61d80d1b" translate="yes" xml:space="preserve">
          <source>Prohibit the use of SQL functions inside triggers, views, CHECK constraints, DEFAULT clauses, expression indexes, partial indexes, or generated columns unless those functions are tagged with &lt;a href=&quot;c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt;.</source>
          <target state="translated">これらの関数が&lt;a href=&quot;c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUSで&lt;/a&gt;タグ付けされていない限り、トリガー、ビュー、CHECK制約、DEFAULT句、式インデックス、部分インデックス、または生成された列内でのSQL関数の使用を禁止します。</target>
        </trans-unit>
        <trans-unit id="a4131fb0c74864c2b5168b32ce6c60e9b911d245" translate="yes" xml:space="preserve">
          <source>Prohibit the use of virtual tables inside of triggers or views unless those virtual tables are tagged with &lt;a href=&quot;#sqlitevtabinnocuous&quot;&gt;SQLITE_VTAB_INNOCUOUS&lt;/a&gt;.</source>
          <target state="translated">仮想テーブルが&lt;a href=&quot;#sqlitevtabinnocuous&quot;&gt;SQLITE_VTAB_INNOCUOUSで&lt;/a&gt;タグ付けされていない限り、トリガーまたはビュー内での仮想テーブルの使用を禁止します。</target>
        </trans-unit>
        <trans-unit id="0dd1398efbb71440f12c0472c04e04e100c1dd4b" translate="yes" xml:space="preserve">
          <source>Prohibit the use of virtual tables inside of triggers or views unless those virtual tables are tagged with &lt;a href=&quot;c_vtab_constraint_support#sqlitevtabinnocuous&quot;&gt;SQLITE_VTAB_INNOCUOUS&lt;/a&gt;.</source>
          <target state="translated">仮想テーブルが&lt;a href=&quot;c_vtab_constraint_support#sqlitevtabinnocuous&quot;&gt;SQLITE_VTAB_INNOCUOUSで&lt;/a&gt;タグ付けされていない限り、トリガーまたはビュー内での仮想テーブルの使用を禁止します。</target>
        </trans-unit>
        <trans-unit id="1b341d69d9619d4d85640d6150737c146812b7c0" translate="yes" xml:space="preserve">
          <source>Provide &lt;a href=&quot;pragma#pragfunc&quot;&gt;PRAGMA functions&lt;/a&gt; for &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt;.</source>
          <target state="translated">提供&lt;a href=&quot;pragma#pragfunc&quot;&gt;PRAGMA機能を&lt;/a&gt;ため&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;、&lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt;、および&lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;プラグマforeign_key_check&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7a4632572329984193ba91894b49406924b5a89d" translate="yes" xml:space="preserve">
          <source>Provide a hint to cursor P1 that it only needs to return rows that satisfy the Expr in P4. TK_REGISTER terms in the P4 expression refer to values currently held in registers. TK_COLUMN terms in the P4 expression refer to columns in the b-tree to which cursor P1 is pointing.</source>
          <target state="translated">カーソルP1に、P4のExprを満たす行を返すだけでよいというヒントを与えます。P4式のTK_REGISTER項は、現在レジスタに保持されている値を参照します。P4式中のTK_COLUMN項は、カーソルP1が指し示すb-treeの列を参照します。</target>
        </trans-unit>
        <trans-unit id="054ee0d871e7b20122b3ff23a8374fbfb871d9ca" translate="yes" xml:space="preserve">
          <source>Provide an appropriate error message when the sqlite_master table contains a CREATE TABLE AS statement. Formerly this caused either an assertion fault or null pointer dereference. Problem found by OSSFuzz on the GDAL project. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/d75e67654aa96&quot;&gt;d75e67654aa96&lt;/a&gt;</source>
          <target state="translated">sqlite_masterテーブルにCREATE TABLE ASステートメントが含まれている場合は、適切なエラーメッセージを提供します。以前は、これによりアサーションエラーまたはnullポインター逆参照が発生していました。OSSFuzzがGDALプロジェクトで発見した問題。チェックイン&lt;a href=&quot;https://www.sqlite.org/src/info/d75e67654aa96&quot;&gt;d75e67654aa96&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c2fd3e74c8200bf8ab45d458d069a0c702c0cd7" translate="yes" xml:space="preserve">
          <source>Provide the &lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparepersistent&quot;&gt;SQLITE_PREPARE_PERSISTENT&lt;/a&gt; flag for &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and use it to limit &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory&lt;/a&gt; misuse by &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;, &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;, and the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3（）に&lt;/a&gt;&lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparepersistent&quot;&gt;SQLITE_PREPARE_PERSISTENT&lt;/a&gt;フラグを提供し、それを使用して&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;、&lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;、および&lt;a href=&quot;rtree&quot;&gt;R-Tree拡張&lt;/a&gt;による&lt;a href=&quot;malloc#lookaside&quot;&gt;メモリの&lt;/a&gt;誤用を制限します。</target>
        </trans-unit>
        <trans-unit id="0788f21345510b44c97d1a7ea9db2e84d27c5ed1" translate="yes" xml:space="preserve">
          <source>Provide the &lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset(X)&lt;/a&gt; SQL function that returns the byte offset into the database file to the beginning of the record holding value X, when compiling with &lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/a&gt;.</source>
          <target state="translated">提供&lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset（X）&lt;/a&gt;でコンパイルするとき、記録保持値Xの先頭にデータベースファイルへのバイトオフセットを返すSQL関数&lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNCを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6abc71c7c814cc2d05ebc22239e7790b1f15e917" translate="yes" xml:space="preserve">
          <source>Provide the ability to tag &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; with new properties &lt;a href=&quot;c3ref/c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt; or &lt;a href=&quot;c3ref/c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;appfunc&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;に新しいプロパティ&lt;a href=&quot;c3ref/c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt;または&lt;a href=&quot;c3ref/c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;をタグ付けする機能を提供します。</target>
        </trans-unit>
        <trans-unit id="fcb01e4e57cfae253305eca2f9007587c22f7fb2" translate="yes" xml:space="preserve">
          <source>Provides SQL access to the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64()&lt;/a&gt; and &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interfaces.</source>
          <target state="translated">&lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64（）&lt;/a&gt;および&lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status（）&lt;/a&gt;インターフェースへのSQLアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="c78b408cda5c2c489b9c5ef105dac2382d881e16" translate="yes" xml:space="preserve">
          <source>Provides information about all files in a single check-in in the &lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil version control system&lt;/a&gt;. This virtual table is not part of the SQLite project but is included because it provides an example of how to use virtual tables and because it is used to help version control the SQLite sources.</source>
          <target state="translated">&lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossilバージョン管理システムの&lt;/a&gt; 1回のチェックインですべてのファイルに関する情報を提供します。この仮想テーブルはSQLiteプロジェクトの一部ではありませんが、仮想テーブルの使用方法の例を提供し、SQLiteソースのバージョン管理を支援するために使用されるため、含まれています。</target>
        </trans-unit>
        <trans-unit id="3126f48ce2a68ae1473f8364444a7e563e9968c3" translate="yes" xml:space="preserve">
          <source>Provides information about the purpose and use of each page in a database file. Used in the implementation of the &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer&lt;/a&gt; utility program.</source>
          <target state="translated">データベースファイルの各ページの目的と使用に関する情報を提供します。&lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer&lt;/a&gt;ユーティリティプログラムの実装で使用されます。</target>
        </trans-unit>
        <trans-unit id="bfec143c19b8a7da8ef2986bfdff976c6539b3dc" translate="yes" xml:space="preserve">
          <source>Pseudo-Random Number Generator</source>
          <target state="translated">擬似乱数発生器</target>
        </trans-unit>
        <trans-unit id="52a406d334528b19ea259feaeb009e7160aeac5f" translate="yes" xml:space="preserve">
          <source>Ptrmap pages must exist in any database file which has a non-zero largest root b-tree page value at offset 52 in the database header. If the largest root b-tree page value is zero, then the database must not contain ptrmap pages.</source>
          <target state="translated">Ptrmapページは、データベースヘッダのオフセット52にある最大のルートb-treeページ値が0ではないデータベースファイルに存在しなければならない。最大ルートb-treeページ値が0の場合、データベースにはptrmapページは含まれていないはずです。</target>
        </trans-unit>
        <trans-unit id="fe35e9945539e89cd05f704b37cf341406598782" translate="yes" xml:space="preserve">
          <source>Punctuation characters like &quot;,&quot; or &quot;==&quot; or &quot;;&quot;.</source>
          <target state="translated">のような句読点文字。</target>
        </trans-unit>
        <trans-unit id="b7a7b9c96916fe33cad00dfc0a31cbc73811f7fc" translate="yes" xml:space="preserve">
          <source>PureFunc</source>
          <target state="translated">PureFunc</target>
        </trans-unit>
        <trans-unit id="73f66c4bb296f02b5e558e94e1ebb8671640db19" translate="yes" xml:space="preserve">
          <source>Purging a Dirty Page</source>
          <target state="translated">汚いページをパージする</target>
        </trans-unit>
        <trans-unit id="a0fb821bdaf93ed9a1f1e920acfb2840eff5b153" translate="yes" xml:space="preserve">
          <source>Purpose</source>
          <target state="translated">Purpose</target>
        </trans-unit>
        <trans-unit id="865ca2a73367e4e56f98cc35dd0cc7fe25f8e129" translate="yes" xml:space="preserve">
          <source>Push the next &quot;thing&quot; onto the stack and fall through OR jump to P2, depending on whether or not there is a next &quot;thing&quot; to push.</source>
          <target state="translated">次の「もの」があるかどうかによって、次の「もの」をスタックに押し付けて落下したり、P2にジャンプしたりします。</target>
        </trans-unit>
        <trans-unit id="0555ed5711adce7afcbd2d3235114460d585953d" translate="yes" xml:space="preserve">
          <source>Put all identifier names inside double-quotes. This is the official SQL way to escape identifier names.</source>
          <target state="translated">すべての識別子名をダブルクォートで囲みます。これは、識別子名をエスケープする公式のSQLの方法です。</target>
        </trans-unit>
        <trans-unit id="73eb67d0cb954e65c543496b0577de68b482cb5a" translate="yes" xml:space="preserve">
          <source>Put identifier names inside [...]. This is not standard SQL, but it is what SQL Server does and so lots of programmers use this technique.</source>
          <target state="translated">識別子名を[....]の中に入れます。これは標準SQLではありませんが、SQL Serverが行うことなので、多くのプログラマがこのテクニックを使用しています。</target>
        </trans-unit>
        <trans-unit id="e8b5818c3fdaa2a399fa24163289f33ef9912b79" translate="yes" xml:space="preserve">
          <source>Put the macro &quot;&lt;code&gt;SQLITE_EXTENSION_INIT1&lt;/code&gt;&quot; on a line by itself right after the &quot;&lt;code&gt;#include &amp;lt;sqlite3ext.h&amp;gt;&lt;/code&gt;&quot; line.</source>
          <target state="translated">「 &lt;code&gt;#include &amp;lt;sqlite3ext.h&amp;gt;&lt;/code&gt; 」行の直後の行にマクロ「 &lt;code&gt;SQLITE_EXTENSION_INIT1&lt;/code&gt; 」を単独で配置します。</target>
        </trans-unit>
        <trans-unit id="36dc5ec2a56fbc19dcd1aa69b72dba8e93123b26" translate="yes" xml:space="preserve">
          <source>Put your hope in God.</source>
          <target state="translated">神に希望を託してください。</target>
        </trans-unit>
        <trans-unit id="c3156e00d3c2588c639e0d3cf6821258b05761c7" translate="yes" xml:space="preserve">
          <source>Q</source>
          <target state="translated">Q</target>
        </trans-unit>
        <trans-unit id="4ae694911c3fee4e1df954bf5e225e075d582d11" translate="yes" xml:space="preserve">
          <source>QUERY</source>
          <target state="translated">QUERY</target>
        </trans-unit>
        <trans-unit id="ebdfba68a60db859050a346ba6621b2d1c232869" translate="yes" xml:space="preserve">
          <source>Quality Management</source>
          <target state="translated">品質管理</target>
        </trans-unit>
        <trans-unit id="3dd6362242ec4d8e950fc308f0c9c5371ac3e523" translate="yes" xml:space="preserve">
          <source>Quality assurance in SQLite is done using &lt;a href=&quot;testing#coverage&quot;&gt;full-coverage testing&lt;/a&gt;, not by compiler warnings or other static code analysis tools. In other words, we verify that SQLite actually gets the correct answer, not that it merely satisfies stylistic constraints. Most of the SQLite code base is devoted purely to testing. The SQLite test suite runs tens of thousands of separate test cases and many of those test cases are parameterized so that hundreds of millions of tests involving billions of SQL statements are run and evaluated for correctness prior to every release. The developers use code coverage tools to verify that all paths through the code are tested. Whenever a bug is found in SQLite, new test cases are written to exhibit the bug so that the bug cannot recur undetected in the future.</source>
          <target state="translated">SQLiteの品質保証は、コンパイラ警告やその他の静的コード分析ツールではなく、&lt;a href=&quot;testing#coverage&quot;&gt;フルカバレッジテスト&lt;/a&gt;を使用して行われます。言い換えれば、SQLiteが文体上の制約を満たすだけではなく、実際に正しい答えが得られることを確認します。 SQLiteコードベースのほとんどは、純粋にテスト専用です。 SQLiteテストスイートは数万の個別のテストケースを実行し、それらのテストケースの多くはパラメーター化されているため、リリースごとに数十億のSQLステートメントを含む数億のテストが実行され、正確性が評価されます。開発者はコードカバレッジツールを使用して、コードのすべてのパスがテストされていることを確認します。 SQLiteでバグが見つかった場合はいつでも、新しいテストケースが作成され、バグが検出されないため、将来バグが検出されないまま再発することはありません。</target>
        </trans-unit>
        <trans-unit id="96ecb898d9fd59826f9555c415e65eadb6f74ead" translate="yes" xml:space="preserve">
          <source>Quality management documents tend to expand into binders full of incomprehensible jargon that nobody reads. This document strives to break that pattern by being concise and useful.</source>
          <target state="translated">品質管理文書は、誰も読まないような分かりにくい専門用語で埋め尽くされたバインダーの中に膨れ上がる傾向があります。この文書は、簡潔で有用なものであることによって、そのパターンを打破することを目指しています。</target>
        </trans-unit>
        <trans-unit id="61b1d96663c5eb21b3f12fad273403f6ef48c73d" translate="yes" xml:space="preserve">
          <source>Queries (and also DELETE and UPDATE statements) in which the WHERE clause contains a bare geopoly_overlap() or geopoly_within() function make use of the underlying R*Tree data structures for a fast lookup that only has to examine a subset of the rows in the table. The number of rows examines depends, of course, on the size of the $query_polygon. Large $query_polygons will normally need to look at more rows than small ones.</source>
          <target state="translated">WHERE句に裸のgeopoly_overlap()またはgeopoly_within()関数が含まれているクエリ(およびDELETEやUPDATE文も)は、テーブル内の行のサブセットを調べるだけの高速な検索のために、基礎となるR*Treeデータ構造を利用しています。検査する行の数は、もちろん$query_polygonのサイズに依存します。大きな $query_polygon は通常、小さなものよりも多くの行を調べる必要があります。</target>
        </trans-unit>
        <trans-unit id="5877d4b4dd805510713fc8b0f7324db5905fcfac" translate="yes" xml:space="preserve">
          <source>Queries Against A Graph</source>
          <target state="translated">グラフに対するクエリ</target>
        </trans-unit>
        <trans-unit id="83b570c5458fbacf6723ef9304ccc7570ee10af8" translate="yes" xml:space="preserve">
          <source>Queries against the rowid of a geopoly table are also very quick, even for tables with a vast number of rows. However, none of the auxiliary data columns are indexes, and so queries against the auxiliary data columns will involve a full table scan.</source>
          <target state="translated">ジオポリテーブルのrowidに対するクエリは、膨大な行数を持つテーブルに対しても、非常に迅速に実行されます。しかし、補助データ列はどれもインデックスではないので、補助データ列に対するクエリはテーブル全体をスキャンしなければなりません。</target>
        </trans-unit>
        <trans-unit id="e655d8b919b6556f1f0ce40faccc63fe0ee22962" translate="yes" xml:space="preserve">
          <source>Queries of the form: &quot;SELECT max(x), y FROM table&quot; returns the value of y on the same row that contains the maximum x value.</source>
          <target state="translated">形式のクエリ。&quot;SELECT max(x),y FROM table &quot;は、最大のxの値を含む同じ行のyの値を返します。</target>
        </trans-unit>
        <trans-unit id="e4ff6a5e7ac06c745f7d49496f70f4a140defd99" translate="yes" xml:space="preserve">
          <source>Queries that contain a single MIN() or MAX() aggregate function whose argument is the left-most column of an index might be satisfied by doing a single index lookup rather than by scanning the entire table. Examples:</source>
          <target state="translated">インデックスの左端のカラムを引数とする単一のMIN()またはMAX()集約関数を含むクエリは、テーブル全体をスキャンするのではなく、単一のインデックス検索を行うことで満たすことができるかもしれません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="29a6a39bdba4fd39660625514af2f1cb40b3edcf" translate="yes" xml:space="preserve">
          <source>Queries that contain subqueries must sometime evaluate the subqueries separately and store the results in a temporary table, then use the content of the temporary table to evaluate the outer query. We call this &quot;materializing&quot; the subquery. The query optimizer in SQLite attempts to avoid materializing, but sometimes it is not easily avoidable. The temporary tables created by materialization are each stored in their own separate temporary file, which is automatically deleted at the conclusion of the query. The size of these temporary tables depends on the amount of data in the materialization of the subquery, of course.</source>
          <target state="translated">副問い合わせを含む問い合わせは、いつかは副問い合わせを別々に評価して一時的なテーブルに結果を格納し、一時的なテーブルの内容を使って外側の問い合わせを評価しなければなりません。これを副問い合わせの「マテリアライズ」と呼びます。SQLiteのクエリオプティマイザはマテリアライズを回避しようとしますが、簡単には回避できないこともあります。マテリアライズによって作成されたテンポラリテーブルは、それぞれ別個のテンポラリファイルに格納され、クエリの終了時に自動的に削除されます。これらの一時テーブルのサイズは、もちろん副問い合わせのマテリアライズのデータ量に依存します。</target>
        </trans-unit>
        <trans-unit id="cfbd9457ec43caaedb5b89c759265cf2be427fe5" translate="yes" xml:space="preserve">
          <source>Queries that use ORDER BY and LIMIT now try to avoid computing rows that cannot possibly come in under the LIMIT. This can greatly improve performance of ORDER BY LIMIT queries, especially when the LIMIT is small relative to the number of unrestricted output rows.</source>
          <target state="translated">ORDER BYとLIMITを使用するクエリは、LIMITの下に来る可能性のある行の計算を避けようとします。これにより、ORDER BY LIMITクエリのパフォーマンスを大幅に向上させることができ、特にLIMITが無制限の出力行数に比べて小さい場合に有効です。</target>
        </trans-unit>
        <trans-unit id="e885c97cd0eb73037d91afe0e25f71733d813af5" translate="yes" xml:space="preserve">
          <source>Query Language Understood by SQLite</source>
          <target state="translated">SQLiteで理解できるクエリ言語</target>
        </trans-unit>
        <trans-unit id="3d4f16fd1d91b47c556b84948dabe05573437a3d" translate="yes" xml:space="preserve">
          <source>Query Planner</source>
          <target state="translated">クエリプランナー</target>
        </trans-unit>
        <trans-unit id="efa9d81fc99ae6041fbe49339a919ef99bac7ade" translate="yes" xml:space="preserve">
          <source>Query Planning</source>
          <target state="translated">クエリプランニング</target>
        </trans-unit>
        <trans-unit id="625af40606e435d60c7571eb3eaed21802aa70ee" translate="yes" xml:space="preserve">
          <source>Query Progress Callbacks</source>
          <target state="translated">クエリ プログレス コールバック</target>
        </trans-unit>
        <trans-unit id="4af542248ab5d4cfc6f1e9df7245e3bb184ea082" translate="yes" xml:space="preserve">
          <source>Query The EXPLAIN Setting For A Prepared Statement</source>
          <target state="translated">準備されたステートメントのEXPLAIN設定を問い合わせる</target>
        </trans-unit>
        <trans-unit id="27930b82a7c3d467781ad3b52e0b1d9894281ffa" translate="yes" xml:space="preserve">
          <source>Query flattener</source>
          <target state="translated">クエリフラットナー</target>
        </trans-unit>
        <trans-unit id="e60fdc9ba7fb5d86546748b364cd1dfbde0107e1" translate="yes" xml:space="preserve">
          <source>Query flattening is an important optimization when views are used as each use of a view is translated into a subquery.</source>
          <target state="translated">クエリのフラット化は、ビューの各使用がサブクエリに変換されるため、ビューを使用する際の重要な最適化です。</target>
        </trans-unit>
        <trans-unit id="bfee3391ed2fb89e3470d4d2a93c4c710274a3ef" translate="yes" xml:space="preserve">
          <source>Query for the details of phrase match iIdx within the current row. Phrase matches are numbered starting from zero, so the iIdx argument should be greater than or equal to zero and smaller than the value output by xInstCount().</source>
          <target state="translated">現在の行内のフレーズマッチ iIdx の詳細を取得します。フレーズマッチの番号はゼロから始まるので、iIdx 引数はゼロ以上で xInstCount()が出力する値よりも小さくなければなりません。</target>
        </trans-unit>
        <trans-unit id="3a7dd1ac6b04f70fb3ec3bd5dfe2b333de122f27" translate="yes" xml:space="preserve">
          <source>Query optimizer enhancements:</source>
          <target state="translated">クエリオプティマイザの機能強化。</target>
        </trans-unit>
        <trans-unit id="a2c73363a91970f8d7d0f3ba2033b2b1141c7659" translate="yes" xml:space="preserve">
          <source>Query optimizer improvements:</source>
          <target state="translated">クエリオプティマイザの改善。</target>
        </trans-unit>
        <trans-unit id="65d2f2329c994ccea3b5e213a1d1b909c0f33338" translate="yes" xml:space="preserve">
          <source>Query or change a limit on the &lt;a href=&quot;lang_analyze#approx&quot;&gt;approximate ANALYZE&lt;/a&gt; setting. This is approximate number of rows examined in each index by the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command. If the argument</source>
          <target state="translated">&lt;a href=&quot;lang_analyze#approx&quot;&gt;おおよそのANALYZE&lt;/a&gt;設定の制限を照会または変更します。これは、&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;コマンドによって各インデックスで検査される行のおおよその数です。引数が</target>
        </trans-unit>
        <trans-unit id="d0fbdef4345ce05f423c29e77346a76ae1183a9c" translate="yes" xml:space="preserve">
          <source>Query or change the count-changes flag. Normally, when the count-changes flag is not set, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements return no data. When count-changes is set, each of these commands returns a single row of data consisting of one integer value - the number of rows inserted, modified or deleted by the command. The returned change count does not include any insertions, modifications or deletions performed by triggers, any changes made automatically by &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt;, or updates caused by an &lt;a href=&quot;lang_upsert&quot;&gt;upsert&lt;/a&gt;.</source>
          <target state="translated">count-changesフラグを照会または変更します。通常、カウント変更フラグが設定されていない場合、&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;、&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;および&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;ステートメントはデータを返しません。 count-changesが設定されている場合、これらの各コマンドは、1つの整数値（コマンドによって挿入、変更、または削除された行の数）で構成されるデータの単一行を返します。返された変更カウントには、トリガーによって実行された挿入、変更、削除、&lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;外部キーアクション&lt;/a&gt;によって自動的に行われた変更、&lt;a href=&quot;lang_upsert&quot;&gt;アップサート&lt;/a&gt;によって発生した更新は含まれません。</target>
        </trans-unit>
        <trans-unit id="9a7df9605f2eec87d8f2db2efd84251b953fcfd6" translate="yes" xml:space="preserve">
          <source>Query or change the empty-result-callbacks flag.</source>
          <target state="translated">empty-result-callbacks フラグをクエリまたは変更します。</target>
        </trans-unit>
        <trans-unit id="4386c302fe03b8bf430568c307ba9f2bfa451ec8" translate="yes" xml:space="preserve">
          <source>Query or change the full_column_names flag. This flag together with the &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; flag determine the way SQLite assigns names to result columns of &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements. Result columns are named by applying the following rules in order:</source>
          <target state="translated">full_column_namesフラグを照会または変更します。このフラグと&lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt;フラグは、SQLiteが&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントの結果の列に名前を割り当てる方法を決定します。結果列には、次のルールを順番に適用することによって名前が付けられます。</target>
        </trans-unit>
        <trans-unit id="6ea33a7feb73dab172e527ce6afcb51892e3e546" translate="yes" xml:space="preserve">
          <source>Query or change the fullfsync flag for &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operations. If this flag is set, then the F_FULLFSYNC syncing method is used during checkpoint operations on systems that support F_FULLFSYNC. The default value of the checkpoint_fullfsync flag is off. Only Mac OS-X supports F_FULLFSYNC.</source>
          <target state="translated">&lt;a href=&quot;wal#ckpt&quot;&gt;チェックポイント&lt;/a&gt;操作のfullfsyncフラグを照会または変更します。このフラグが設定されている場合、F_FULLFSYNCをサポートするシステムでのチェックポイント操作中に、F_FULLFSYNC同期メソッドが使用されます。checkpoint_fullfsyncフラグのデフォルト値はオフです。Mac OS-XのみがF_FULLFSYNCをサポートします。</target>
        </trans-unit>
        <trans-unit id="563bc8c4477c1c2b886876e5894cd59e0001b35e" translate="yes" xml:space="preserve">
          <source>Query or change the fullfsync flag. This flag determines whether or not the F_FULLFSYNC syncing method is used on systems that support it. The default value of the fullfsync flag is off. Only Mac OS X supports F_FULLFSYNC.</source>
          <target state="translated">fullfsync フラグを取得または変更します。このフラグは、F_FULLFSYNC 同期方式をサポートするシステムで使用するかどうかを決定します。fullfsync フラグのデフォルト値は off です。Mac OS X のみが F_FULLFSYNC をサポートしています。</target>
        </trans-unit>
        <trans-unit id="77df4b91f1e34f39b185a6ee7e54e82d58dfa005" translate="yes" xml:space="preserve">
          <source>Query or change the maximum number of bytes that are set aside for memory-mapped I/O on a single database. The first form (without an argument) queries the current limit. The second form (with a numeric argument) sets the limit for the specified database, or for all databases if the optional database name is omitted. In the second form, if the database name is omitted, the limit that is set becomes the default limit for all databases that are added to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; by subsequent &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statements.</source>
          <target state="translated">単一のデータベースでメモリマップI / Oのために確保されている最大バイト数を照会または変更します。最初の形式（引数なし）は、現在の制限を照会します。 2番目の形式（数値引数付き）は、指定されたデータベース、またはオプションのデータベース名が省略されている場合はすべてのデータベースに制限を設定します。 2番目の形式では、データベース名を省略した場合、設定された制限が、後続の&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;ステートメントによって&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続に&lt;/a&gt;追加されるすべてのデータベースのデフォルトの制限になります。</target>
        </trans-unit>
        <trans-unit id="5b3761ba731b4ca68bda2cd1e8fe9ffa86d5d2f0" translate="yes" xml:space="preserve">
          <source>Query or change the secure-delete setting. When secure_delete is on, SQLite overwrites deleted content with zeros. The default setting for secure_delete is determined by the &lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt; compile-time option and is normally off. The off setting for secure_delete improves performance by reducing the number of CPU cycles and the amount of disk I/O. Applications that wish to avoid leaving forensic traces after content is deleted or updated should enable the secure_delete pragma prior to performing the delete or update, or else run &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; after the delete or update.</source>
          <target state="translated">セキュア削除設定を照会または変更します。 secure_deleteがオンの場合、SQLiteは削除されたコンテンツをゼロで上書きします。 secure_deleteのデフォルト設定は、&lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt;コンパイル時オプションによって決定され、通常はオフです。 secure_deleteをオフに設定すると、CPUサイクル数とディスクI / Oの量が減少するため、パフォーマンスが向上します。コンテンツが削除または更新された後にフォレンシックトレースを残したくないアプリケーションは、削除または更新を実行する前にsecure_deleteプラグマを有効にするか、削除または更新後に&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;を実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="de56ca3e30c1c074a1fd98f6d3fdce5680f699b3" translate="yes" xml:space="preserve">
          <source>Query or change the setting of the &quot;&lt;b&gt;temp_store&lt;/b&gt;&quot; parameter. When temp_store is DEFAULT (0), the compile-time C preprocessor macro &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; is used to determine where temporary tables and indices are stored. When temp_store is MEMORY (2) &lt;a href=&quot;inmemorydb#temp_db&quot;&gt;temporary tables&lt;/a&gt; and indices are kept in as if they were pure &lt;a href=&quot;inmemorydb&quot;&gt;in-memory databases&lt;/a&gt; memory. When temp_store is FILE (1) &lt;a href=&quot;inmemorydb#temp_db&quot;&gt;temporary tables&lt;/a&gt; and indices are stored in a file. The &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory&lt;/a&gt; pragma can be used to specify the directory containing temporary files when &lt;b&gt;FILE&lt;/b&gt; is specified. When the temp_store setting is changed, all existing temporary tables, indices, triggers, and views are immediately deleted.</source>
          <target state="translated">「&lt;b&gt;temp_store&lt;/b&gt;」パラメーターの設定を照会または変更します。 temp_storeがDEFAULT（0）の場合、コンパイル時のCプリプロセッサマクロ&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;を使用して、一時テーブルとインデックスが格納される場所を決定します。 temp_storeがMEMORY（2）の場合、&lt;a href=&quot;inmemorydb#temp_db&quot;&gt;一時テーブル&lt;/a&gt;とインデックスは、純粋な&lt;a href=&quot;inmemorydb&quot;&gt;インメモリデータベース&lt;/a&gt;メモリであるかのように保持されます。 temp_storeがFILE（1）の場合、&lt;a href=&quot;inmemorydb#temp_db&quot;&gt;一時テーブル&lt;/a&gt;とインデックスはファイルに保存されます。&lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory&lt;/a&gt;プラグマは時に一時ファイルを含むディレクトリを指定するために使用することができ&lt;b&gt;FILEが&lt;/b&gt;指定されています。 temp_store設定が変更されると、すべての既存の一時テーブル、インデックス、トリガー、およびビューがすぐに削除されます。</target>
        </trans-unit>
        <trans-unit id="0eb005d9ab4e0804f12c87dee002073b411d274d" translate="yes" xml:space="preserve">
          <source>Query or change the setting of the &quot;synchronous&quot; flag. The first (query) form will return the synchronous setting as an integer. The second form changes the synchronous setting. The meanings of the various synchronous settings are as follows:</source>
          <target state="translated">synchronous&quot; フラグの設定を問い合わせたり変更したりします。最初の (クエリ)形式は同期設定を整数で返します。2 番目のフォームは同期設定を変更します。様々な同期設定の意味は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="8dcfcd54b0505cd09f50244da9bbd756766eef81" translate="yes" xml:space="preserve">
          <source>Query or change the setting of the &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;busy timeout&lt;/a&gt;. This pragma is an alternative to the &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; C-language interface which is made available as a pragma for use with language bindings that do not provide direct access to &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/busy_timeout&quot;&gt;ビジータイムアウトの&lt;/a&gt;設定を照会または変更します。このプラグマは、に代替され&lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt;への直接アクセスを提供していない言語バインディングと共に使用するためのプラグマとして利用可能にされるC言語インターフェース&lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeoutを（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9a6f0cf05490ce574881ff5675cbd192d91cf992" translate="yes" xml:space="preserve">
          <source>Query or change the short-column-names flag. This flag affects the way SQLite names columns of data returned by &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements. See the &lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;full_column_names&lt;/a&gt; pragma for full details.</source>
          <target state="translated">short-column-namesフラグを照会または変更します。このフラグは、SQLiteが&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントによって返されるデータの列に名前を付ける方法に影響します。詳細については、&lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;full_column_names&lt;/a&gt;プラグマを参照してください。</target>
        </trans-unit>
        <trans-unit id="c472dc3fc7ff36d8acee51946b1687ac08bd59fe" translate="yes" xml:space="preserve">
          <source>Query or change the suggested maximum number of database disk pages that SQLite will hold in memory at once per open database file. Whether or not this suggestion is honored is at the discretion of the &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;Application Defined Page Cache&lt;/a&gt;. The default page cache that is built into SQLite honors the request, however alternative application-defined page cache implementations may choose to interpret the suggested cache size in different ways or to ignore it all together. The default suggested cache size is -2000, which means the cache size is limited to 2048000 bytes of memory. The default suggested cache size can be altered using the &lt;a href=&quot;compile#default_cache_size&quot;&gt;SQLITE_DEFAULT_CACHE_SIZE&lt;/a&gt; compile-time options. The TEMP database has a default suggested cache size of 0 pages.</source>
          <target state="translated">SQLiteが開いているデータベースファイルごとに一度にメモリに保持するデータベースディスクページの推奨最大数を照会または変更します。この提案を尊重するかどうかは、&lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;アプリケーション定義のページキャッシュの&lt;/a&gt;裁量に任されています。 SQLiteに組み込まれているデフォルトのページキャッシュは要求を受け入れますが、代替のアプリケーション定義のページキャッシュ実装は、提案されたキャッシュサイズをさまざまな方法で解釈するか、すべて一緒に無視するかを選択できます。デフォルトの推奨キャッシュサイズは-2000です。つまり、キャッシュサイズはメモリの2048000バイトに制限されます。デフォルトの推奨キャッシュサイズは、&lt;a href=&quot;compile#default_cache_size&quot;&gt;SQLITE_DEFAULT_CACHE_SIZE&lt;/a&gt;コンパイル時オプションを使用して変更できます。 TEMPデータベースのデフォルトの推奨キャッシュサイズは0ページです。</target>
        </trans-unit>
        <trans-unit id="38317b0c0d1df51bd83790ce312ba13da0c5ed05" translate="yes" xml:space="preserve">
          <source>Query or change the value of the &lt;a href=&quot;c3ref/data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; global variable, which windows operating-system interface backends use to determine where to store database files specified using a relative pathname.</source>
          <target state="translated">&lt;a href=&quot;c3ref/data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt;グローバル変数の値を照会または変更します。これは、Windowsオペレーティングシステムインターフェイスのバックエンドが、相対パス名を使用して指定されたデータベースファイルを保存する場所を決定するために使用します。</target>
        </trans-unit>
        <trans-unit id="f61590ed5a58a97ecca18f3fbb40bf0ae63fb037" translate="yes" xml:space="preserve">
          <source>Query or change the value of the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt;,...) limit for the current database connection. This limit sets an upper bound on the number of auxiliary threads that a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; is allowed to launch to assist with a query. The default limit is 0 unless it is changed using the &lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt; compile-time option. When the limit is zero, that means no auxiliary threads will be launched.</source>
          <target state="translated">現在のデータベース接続の&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt;、...）制限の値を照会または変更します。この制限は、&lt;a href=&quot;c3ref/stmt&quot;&gt;準備されたステートメント&lt;/a&gt;がクエリを支援するために起動できる補助スレッドの数の上限を設定します。&lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt;コンパイル時オプションを使用して変更しない限り、デフォルトの制限は0です。制限がゼロの場合、それは補助スレッドが起動されないことを意味します。</target>
        </trans-unit>
        <trans-unit id="4ad35fae3f5b98f4ef0cd9485074046877d96539" translate="yes" xml:space="preserve">
          <source>Query or change the value of the &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable, which many operating-system interface backends use to determine where to store &lt;a href=&quot;inmemorydb#temp_db&quot;&gt;temporary tables&lt;/a&gt; and indices.</source>
          <target state="translated">&lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;グローバル変数の値をクエリまたは変更します。これは、多くのオペレーティングシステムインターフェイスバックエンドが、&lt;a href=&quot;inmemorydb#temp_db&quot;&gt;一時テーブル&lt;/a&gt;とインデックスを格納する場所を決定するために使用します。</target>
        </trans-unit>
        <trans-unit id="5866fac6602f3e40c19df259ea318d2b63caf2bd" translate="yes" xml:space="preserve">
          <source>Query or set the auto-vacuum status in the database.</source>
          <target state="translated">データベースの自動バキュームの状態を照会または設定します。</target>
        </trans-unit>
        <trans-unit id="3cc5d0ecc46bacf93e04d7b7978224221ecdf262" translate="yes" xml:space="preserve">
          <source>Query or set the maximum number of pages in the database file. Both forms of the pragma return the maximum page count. The second form attempts to modify the maximum page count. The maximum page count cannot be reduced below the current database size.</source>
          <target state="translated">データベースファイルの最大ページ数を問い合わせるか設定します。どちらの形式のプラグマも最大ページ数を返します。2 番目の形式は、最大ページ数の変更を試みます。最大ページ数を現在のデータベースサイズ以下に減らすことはできません。</target>
        </trans-unit>
        <trans-unit id="3b4e54fcf1e120591a5a6535bff6e2b69b86d7df" translate="yes" xml:space="preserve">
          <source>Query or set the page size of the database. The page size must be a power of two between 512 and 65536 inclusive.</source>
          <target state="translated">データベースのページサイズを問い合わせるか設定します。ページサイズは 512 から 65536 の間の 2 の累乗でなければなりません。</target>
        </trans-unit>
        <trans-unit id="627a1950bccb0926f06969a3db2d136c3cabdca5" translate="yes" xml:space="preserve">
          <source>Query planner checklist</source>
          <target state="translated">クエリプランナーのチェックリスト</target>
        </trans-unit>
        <trans-unit id="e93c39912e396551e04ed9b46c1ea823e2d8b3bb" translate="yes" xml:space="preserve">
          <source>Query planner enhancement - automatic transient indices are created when doing so reduces the estimated query time.</source>
          <target state="translated">クエリプランナの機能強化-クエリプランナの機能強化により、見積クエリ時間が短縮された場合に、自動的にトランジェントインデックスが作成されるようになりました。</target>
        </trans-unit>
        <trans-unit id="15e2bd2467aae946e711f6cc5ade007f83eb3c87" translate="yes" xml:space="preserve">
          <source>Query planner enhancement - the ORDER BY becomes a no-op if the query also contains a GROUP BY clause that forces the correct output order.</source>
          <target state="translated">クエリプランナーの強化-クエリに正しい出力順序を強制するGROUP BY句が含まれている場合、ORDER BYは無効になります。</target>
        </trans-unit>
        <trans-unit id="26786d5880615e168b7819292d8f2bd689ef42b3" translate="yes" xml:space="preserve">
          <source>Query planner enhancement: Use the transitive property of constraints to move constraints into the outer loops of a join whenever possible, thereby reducing the amount of work that needs to occur in inner loops.</source>
          <target state="translated">クエリプランナの強化。可能な限り制約を結合の外側ループに移動させるために、制約の遷移特性を使用して、内側ループで発生する作業量を削減します。</target>
        </trans-unit>
        <trans-unit id="736e85cef8966360d93b45933c07771905d6a0b9" translate="yes" xml:space="preserve">
          <source>Query planner enhancements.</source>
          <target state="translated">クエリプランナーの機能強化。</target>
        </trans-unit>
        <trans-unit id="c7e16cd25b99db12dc36d4eb42e08d056acec1b1" translate="yes" xml:space="preserve">
          <source>Query planner enhancements:</source>
          <target state="translated">クエリプランナーの機能強化。</target>
        </trans-unit>
        <trans-unit id="666ab0644bcf7abdf389c79c890bad61c7c7fec2" translate="yes" xml:space="preserve">
          <source>Query planner improvements:</source>
          <target state="translated">クエリプランナーの改善</target>
        </trans-unit>
        <trans-unit id="b2b452d242e61d8f7480bffaae127bf001921fa3" translate="yes" xml:space="preserve">
          <source>Query planner stability guarantee</source>
          <target state="translated">クエリプランナーの安定性保証</target>
        </trans-unit>
        <trans-unit id="ca5891ff28346fccc5150a605b02b68689910ebb" translate="yes" xml:space="preserve">
          <source>Query planners are what make SQL database engines so amazingly useful and powerful. (This is true of all SQL database engines, not just SQLite.) The query planner frees the programmer from the chore of selecting a particular query plan, and thereby allows the programmer to focus more mental energy on higher-level application issues and on providing more value to the end user. For simple queries where the choice of query plan is obvious, this is convenient but not hugely important. But as applications and schemas and queries grow more complex, a clever query planner can greatly speed and simplify the work of application development. There is amazing power in being about to tell the database engine what content is desired, and then let the database engine figure out the best way to retrieve that content.</source>
          <target state="translated">クエリプランナはSQLデータベースエンジンを驚くほど便利で強力なものにしています(これはSQLiteに限らず、すべてのSQLデータベースエンジンに言えることです)。(これはSQLiteに限らず、すべてのSQLデータベースエンジンに言えることです。)クエリプランナを使用することで、プログラマは特定のクエリプランを選択するという煩雑な作業から解放され、それによってプログラマはより高いレベルのアプリケーションの問題に精神的なエネルギーを集中させ、エンドユーザにより多くの価値を提供することができるようになります。クエリプランの選択が明白な単純なクエリの場合、これは便利ですが、それほど重要ではありません。しかし、アプリケーションやスキーマ、クエリが複雑になってくると、巧妙なクエリプランナーは、アプリケーション開発の作業を大幅にスピードアップし、単純化することができます。どのようなコンテンツが必要なのかをデータベースエンジンに伝え、そのコンテンツを取得するための最良の方法をデータベースエンジンに考えさせることには、驚くべき力があります。</target>
        </trans-unit>
        <trans-unit id="9ee854629ae78a2199bdb56da8e286e6006b5d8d" translate="yes" xml:space="preserve">
          <source>Query results are returned as a list of column values. If a query requests 2 columns and there are 3 rows matching the query, then the returned list will contain 6 elements. For example:</source>
          <target state="translated">クエリの結果は、カラムの値のリストとして返されます。クエリが 2 カラムを要求し、クエリにマッチする行が 3 行ある場合、返されるリストには 6 つの要素が含まれます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="50cb7820ab431080267a59361b01e9af99b0f2f7" translate="yes" xml:space="preserve">
          <source>Query, set, or clear READ UNCOMMITTED isolation. The default isolation level for SQLite is SERIALIZABLE. Any process or thread can select READ UNCOMMITTED isolation, but SERIALIZABLE will still be used except between connections that share a common page and schema cache. Cache sharing is enabled using the &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; API. Cache sharing is disabled by default.</source>
          <target state="translated">READ UNCOMMITTED分離を照会、設定、またはクリアします。SQLiteのデフォルトの分離レベルはSERIALIZABLEです。どのプロセスまたはスレッドもREAD UNCOMMITTED分離を選択できますが、共通のページとスキーマキャッシュを共有する接続間を除いて、SERIALIZABLEは引き続き使用されます。キャッシュ共有は、&lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache（）&lt;/a&gt; API を使用して有効にします。キャッシュ共有はデフォルトで無効になっています。</target>
        </trans-unit>
        <trans-unit id="0366bdd9a4ae5e944fbf6092ddc8900d9aeaaed5" translate="yes" xml:space="preserve">
          <source>Query, set, or clear the &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexing&lt;/a&gt; capability.</source>
          <target state="translated">&lt;a href=&quot;optoverview#autoindex&quot;&gt;自動インデックス&lt;/a&gt;機能を照会、設定、またはクリアします。</target>
        </trans-unit>
        <trans-unit id="14ccb18dde2fc34367c93b804727ccf1143765e5" translate="yes" xml:space="preserve">
          <source>Query, set, or clear the enforcement of &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;foreignkeys&quot;&gt;外部キー制約の適用を&lt;/a&gt;照会、設定、またはクリアします。</target>
        </trans-unit>
        <trans-unit id="160bfb7a8121ce10fe672d852b6ba0dcf536c5e1" translate="yes" xml:space="preserve">
          <source>Query, set, or clear the recursive trigger capability.</source>
          <target state="translated">再帰的トリガ機能をクエリ、設定、またはクリアします。</target>
        </trans-unit>
        <trans-unit id="bf0ed56a136cbe5ffad095931c71813d09f0273f" translate="yes" xml:space="preserve">
          <source>Questions and confusion quickly arose on the &lt;a href=&quot;https://sqlite.org/support.html#mailinglists&quot;&gt;mailing lists&lt;/a&gt; about the purpose behind these new interfaces, why they were introduced, and what problem they solve. This essay attempts to answer those questions and clear up the confusion.</source>
          <target state="translated">これらの新しいインターフェイスの背後にある目的、それらが導入された理由、およびそれらが解決する問題についての質問と混乱が&lt;a href=&quot;https://sqlite.org/support.html#mailinglists&quot;&gt;メーリングリストで&lt;/a&gt;すぐに発生しました。このエッセイは、それらの質問に答えて混乱を解消しようと試みます。</target>
        </trans-unit>
        <trans-unit id="6fb0e0d11a03f78b5ecb2f7f8b42ef10b6e101e0" translate="yes" xml:space="preserve">
          <source>Questions like these (and countless others) can be answered without having to uncompress or extract any content.</source>
          <target state="translated">このような質問には(他にも数え切れないほどの)、コンテンツを解凍したり抽出したりしなくても答えることができます。</target>
        </trans-unit>
        <trans-unit id="09a7d1d2da3256534f8a2a26b3d747dbae8b2a14" translate="yes" xml:space="preserve">
          <source>Quirks, Caveats, and Gotchas In SQLite</source>
          <target state="translated">SQLite の奇妙な点、洞窟、ガッチャ</target>
        </trans-unit>
        <trans-unit id="9432058147a91a2c4afeff95adc17f4930b4c6b9" translate="yes" xml:space="preserve">
          <source>R (cost: 3.56)</source>
          <target state="translated">R(コスト:3.56</target>
        </trans-unit>
        <trans-unit id="37abd4d23bc413fb5db77feee86f46ad0b861e2d" translate="yes" xml:space="preserve">
          <source>R*Tree Module</source>
          <target state="translated">R*ツリーモジュール</target>
        </trans-unit>
        <trans-unit id="43ea99300f03323c6239855a57c58f91be6c0d63" translate="yes" xml:space="preserve">
          <source>R-N1 (cost: 7.03)</source>
          <target state="translated">R-N1(コスト:7.03</target>
        </trans-unit>
        <trans-unit id="00f923142bbc27eb285a9f64b857d908b86719d8" translate="yes" xml:space="preserve">
          <source>R-N1-C (cost: 13.43)</source>
          <target state="translated">R-N1-C(コスト:13.43</target>
        </trans-unit>
        <trans-unit id="f743ed80cd4af3e3dd6aaa0242ee69bf26b480c0" translate="yes" xml:space="preserve">
          <source>R-N1-N2 (cost: 12.55)</source>
          <target state="translated">R-N1-N2(コスト:12.55</target>
        </trans-unit>
        <trans-unit id="12fc721fdde87226fb7f977e95887d024b7fef9e" translate="yes" xml:space="preserve">
          <source>R-N1-P (cost: 14.74)</source>
          <target state="translated">R-N1-P(コスト:14.74</target>
        </trans-unit>
        <trans-unit id="fab85d63ca52ab34a7d0d4d635cb4434f4c73c7c" translate="yes" xml:space="preserve">
          <source>R-N2 (cost: 9.08)</source>
          <target state="translated">R-N2(コスト:9.08</target>
        </trans-unit>
        <trans-unit id="2a3b1ad1ab0d9afa5d157dd5a7723841765c8a20" translate="yes" xml:space="preserve">
          <source>R-N2-S (cost: 15.08)</source>
          <target state="translated">R-N2-S(コスト:15.08</target>
        </trans-unit>
        <trans-unit id="181200f18a6abb830d9a1e4da77cb05da7c0b226" translate="yes" xml:space="preserve">
          <source>R-P {cost: 11.27}</source>
          <target state="translated">R-P {コスト:11.27}の場合</target>
        </trans-unit>
        <trans-unit id="a39f8b032fb6773009f23cdf1fc4a43dca07ca75" translate="yes" xml:space="preserve">
          <source>R-tree indexes</source>
          <target state="translated">R-木インデックス</target>
        </trans-unit>
        <trans-unit id="27625665a48434a97da2f59bce85a61c08c57d13" translate="yes" xml:space="preserve">
          <source>RAISE</source>
          <target state="translated">RAISE</target>
        </trans-unit>
        <trans-unit id="eab70b41d287161d06757b3c91f16b40700edd9b" translate="yes" xml:space="preserve">
          <source>RAISE function</source>
          <target state="translated">RAISES機能</target>
        </trans-unit>
        <trans-unit id="578e6dad8d99e7211a3086f6ebcd1836a6b2b2b0" translate="yes" xml:space="preserve">
          <source>RANGE</source>
          <target state="translated">RANGE</target>
        </trans-unit>
        <trans-unit id="ddd7e61302a8592bafc0bc44fda92b4c46585957" translate="yes" xml:space="preserve">
          <source>RANGE frames</source>
          <target state="translated">レンジフレーム</target>
        </trans-unit>
        <trans-unit id="3314a11c461e2d3c3169c9709d07e23cec14a354" translate="yes" xml:space="preserve">
          <source>RANGE n PRECEDING</source>
          <target state="translated">RANGE n PRECEDING</target>
        </trans-unit>
        <trans-unit id="f4c206eeb5c6f3b744195c276954fdb473ea9623" translate="yes" xml:space="preserve">
          <source>RBU Database Contents</source>
          <target state="translated">RBUデータベースの内容</target>
        </trans-unit>
        <trans-unit id="712d8aa663fc4fe498c4350eb3d107a2e61b11c3" translate="yes" xml:space="preserve">
          <source>RBU Database Tables</source>
          <target state="translated">RBUデータベーステーブル</target>
        </trans-unit>
        <trans-unit id="07201c49e16cf7ee53c14561a1009692319b08f1" translate="yes" xml:space="preserve">
          <source>RBU Extension</source>
          <target state="translated">RBU拡張</target>
        </trans-unit>
        <trans-unit id="e78ae84baf56b93a5fa01e9dafad71c1200f7218" translate="yes" xml:space="preserve">
          <source>RBU FTS3/4 Tables</source>
          <target state="translated">RBU FTS3/4テーブル</target>
        </trans-unit>
        <trans-unit id="462b7e20bcfb4a1c16aa1cac30ebb2f5b6113539" translate="yes" xml:space="preserve">
          <source>RBU Update</source>
          <target state="translated">RBUアップデート</target>
        </trans-unit>
        <trans-unit id="fa41f4d5c464fe94904b941d3fdd9fd06f70c8d7" translate="yes" xml:space="preserve">
          <source>RBU Vacuum</source>
          <target state="translated">RBU真空</target>
        </trans-unit>
        <trans-unit id="29b65cd1a0583c71c8f08f136996230310e8af2c" translate="yes" xml:space="preserve">
          <source>RBU Vacuum applications all implement some variation of the following procedure:</source>
          <target state="translated">RBU真空アプリケーションはすべて、以下の手順のいくつかのバリエーションを実装しています。</target>
        </trans-unit>
        <trans-unit id="5f247eac406d30bce84777c8b0ea049a1e0cac26" translate="yes" xml:space="preserve">
          <source>RBU operations may be suspended and then later resumed, perhaps with intervening power outages and/or system resets. For an RBU update, the original database content remains visible to all database readers until the entire update has been applied - even if the update is suspended and then later resumed.</source>
          <target state="translated">RBU 操作は中断され、その後再開されることがあります。RBU更新では、更新が中断された後に再開された場合でも、すべての更新が適用されるまでは、元のデータベースの内容はすべてのデータベース リーダーに表示されたままです。</target>
        </trans-unit>
        <trans-unit id="51d4c96a1d92222b7d93c52475b51db8766c79b8" translate="yes" xml:space="preserve">
          <source>RBU updates cannot be applied to any tables that contain a column named &quot;rbu_control&quot;.</source>
          <target state="translated">RBU 更新は、&quot;rbu_control&quot; という名前の列を含むテーブルには適用できません。</target>
        </trans-unit>
        <trans-unit id="3b330731a188b19fdf61999609e5e9b932bb400b" translate="yes" xml:space="preserve">
          <source>REAL</source>
          <target state="translated">REAL</target>
        </trans-unit>
        <trans-unit id="d2c4a8bcf4efc09f908cb4e40d7d6f381c3c3ef0" translate="yes" xml:space="preserve">
          <source>RECURSIVE</source>
          <target state="translated">RECURSIVE</target>
        </trans-unit>
        <trans-unit id="d4730753022e62db3135b00e0df88859d25187e8" translate="yes" xml:space="preserve">
          <source>REFERENCES</source>
          <target state="translated">REFERENCES</target>
        </trans-unit>
        <trans-unit id="2347c845abd05fb0d1bae0ab927335b643793946" translate="yes" xml:space="preserve">
          <source>REGEXP</source>
          <target state="translated">REGEXP</target>
        </trans-unit>
        <trans-unit id="5345e769e7d2d5a04080b106526b4188c28b2947" translate="yes" xml:space="preserve">
          <source>REINDEX</source>
          <target state="translated">REINDEX</target>
        </trans-unit>
        <trans-unit id="f73b278fdabab028fe5f65c62197e4b5634529e5" translate="yes" xml:space="preserve">
          <source>RELEASE</source>
          <target state="translated">RELEASE</target>
        </trans-unit>
        <trans-unit id="bec39b2581dc86d96ef7eb4b59715b2db9fb5b98" translate="yes" xml:space="preserve">
          <source>RELEASE SAVEPOINT</source>
          <target state="translated">リリースセーブポイント</target>
        </trans-unit>
        <trans-unit id="4756081595ff9366e8b59c094aebf3df53a8fc98" translate="yes" xml:space="preserve">
          <source>RENAME</source>
          <target state="translated">RENAME</target>
        </trans-unit>
        <trans-unit id="a464c34da3d7dbc3eb6ade113363a4f1b48466a0" translate="yes" xml:space="preserve">
          <source>RENAME COLUMN</source>
          <target state="translated">カラムの名前を変更する</target>
        </trans-unit>
        <trans-unit id="c336fcec997db68ba1a16ff95d4b5a6b5f133c3b" translate="yes" xml:space="preserve">
          <source>REPLACE</source>
          <target state="translated">REPLACE</target>
        </trans-unit>
        <trans-unit id="eb5450aba42e33754272b8b32dc01c695827c179" translate="yes" xml:space="preserve">
          <source>REPLACE INTO</source>
          <target state="translated">に置き換えてください。</target>
        </trans-unit>
        <trans-unit id="044eabc2191e6bd2b8395304f84a790584ab5cd3" translate="yes" xml:space="preserve">
          <source>RESERVED</source>
          <target state="translated">RESERVED</target>
        </trans-unit>
        <trans-unit id="69ed002a9f57d1ba3022c561c2f3bb595bf68418" translate="yes" xml:space="preserve">
          <source>RESTART</source>
          <target state="translated">RESTART</target>
        </trans-unit>
        <trans-unit id="99e2cdb8b048ca3999469c35242023f92980f5e6" translate="yes" xml:space="preserve">
          <source>RESTRICT</source>
          <target state="translated">RESTRICT</target>
        </trans-unit>
        <trans-unit id="95253203f79304981143599cedfdaa606f083ca2" translate="yes" xml:space="preserve">
          <source>RIGHT</source>
          <target state="translated">RIGHT</target>
        </trans-unit>
        <trans-unit id="2ce42e824f2163751d62c49d3226c338efa1179d" translate="yes" xml:space="preserve">
          <source>ROLLBACK</source>
          <target state="translated">ROLLBACK</target>
        </trans-unit>
        <trans-unit id="1b38c7ab7be8eb4066bc5bd507af4275ed737be5" translate="yes" xml:space="preserve">
          <source>ROLLBACK TRANSACTION</source>
          <target state="translated">ロールバック取引</target>
        </trans-unit>
        <trans-unit id="fee8f3fde6222d1d587520ccdcc8bdc883934e5b" translate="yes" xml:space="preserve">
          <source>ROW</source>
          <target state="translated">ROW</target>
        </trans-unit>
        <trans-unit id="27bcbad0c7dc6e890992a45957c32cb63b180961" translate="yes" xml:space="preserve">
          <source>ROWID</source>
          <target state="translated">ROWID</target>
        </trans-unit>
        <trans-unit id="1066d5101585674b0bf2bb2a7f36e54bd28ffb0c" translate="yes" xml:space="preserve">
          <source>ROWIDs and the INTEGER PRIMARY KEY</source>
          <target state="translated">ROWID と INTEGER PRIMARY KEY</target>
        </trans-unit>
        <trans-unit id="35c47b79dc3cdab698d2bf71b053c1b257f8db73" translate="yes" xml:space="preserve">
          <source>ROWS</source>
          <target state="translated">ROWS</target>
        </trans-unit>
        <trans-unit id="43bc1be6b036dd85df3053c47dc4432d982cf8e0" translate="yes" xml:space="preserve">
          <source>RTRIM</source>
          <target state="translated">RTRIM</target>
        </trans-unit>
        <trans-unit id="912333c4ddec40db71424e4b21120e0065cfde78" translate="yes" xml:space="preserve">
          <source>RTRIM collating function</source>
          <target state="translated">RTRIM照合機能</target>
        </trans-unit>
        <trans-unit id="d4ccca8588cab0a99233c6cf71400747dcf81d92" translate="yes" xml:space="preserve">
          <source>RTRIM is like BINARY except that extra spaces at the end of either string do not change the result. In other words, strings will compare equal to one another as long as they differ only in the number of spaces at the end.</source>
          <target state="translated">RTRIM は BINARY と似ていますが、どちらの文字列の最後に余分なスペースがあっても結果は変わりません。言い換えれば、文字列は末尾のスペースの数だけが異なる限り、互いに等しい比較を行います。</target>
        </trans-unit>
        <trans-unit id="73bc329996a4b61f272d21a8ef8e13d37b2f5bf8" translate="yes" xml:space="preserve">
          <source>Raising the number of open databases may improve performance in some scenarios.</source>
          <target state="translated">オープンデータベースの数を増やすと、シナリオによってはパフォーマンスが向上する可能性があります。</target>
        </trans-unit>
        <trans-unit id="d62e76ddc1a4a4c5a8b50ba8345b20a992c2b937" translate="yes" xml:space="preserve">
          <source>Range query optimization</source>
          <target state="translated">レンジクエリの最適化</target>
        </trans-unit>
        <trans-unit id="415026844c74bb5d00489173b1d5e1a90b70bfca" translate="yes" xml:space="preserve">
          <source>Raw (possibly compressed) data associated with zip file entry (a blob).</source>
          <target state="translated">zip ファイルエントリ (ブロブ)に関連付けられた生の (圧縮されている可能性のある)データ。</target>
        </trans-unit>
        <trans-unit id="3685a628a8d194c36e92956d9b368621a3c4f89e" translate="yes" xml:space="preserve">
          <source>Reactivated the VACUUM command that reclaims unused disk space in a database file.</source>
          <target state="translated">データベースファイル内の未使用のディスク領域を回収するVACUUMコマンドを再起動しました。</target>
        </trans-unit>
        <trans-unit id="7bf4a534bd19935da933046f9a9ff7be5b6a7965" translate="yes" xml:space="preserve">
          <source>Read Data From A BLOB Incrementally</source>
          <target state="translated">BLOBからのデータの読み込みを段階的に行う</target>
        </trans-unit>
        <trans-unit id="4817ee387eb1c80d362458e295a1ce28b034e185" translate="yes" xml:space="preserve">
          <source>Read and parse all entries from the SQLITE_MASTER table of database P1 that match the WHERE clause P4. If P4 is a NULL pointer, then the entire schema for P1 is reparsed.</source>
          <target state="translated">データベース P1 の SQLITE_MASTER テーブルから WHERE 節 P4 に一致するすべてのエントリを読み込み、解析します。P4 が NULL ポインタの場合、P1 のスキーマ全体がパースされます。</target>
        </trans-unit>
        <trans-unit id="427a567a06032b13c88b02d33d153fca76063c5d" translate="yes" xml:space="preserve">
          <source>Read and parse all entries from the schema table of database P1 that match the WHERE clause P4. If P4 is a NULL pointer, then the entire schema for P1 is reparsed.</source>
          <target state="translated">データベースP1のスキーマテーブルからWHERE句P4に一致するすべてのエントリを読み込み、解析します。P4がNULLポインタの場合、P1のスキーマ全体がパースされます。</target>
        </trans-unit>
        <trans-unit id="06b6a6259408a05057f38693264034af5b800655" translate="yes" xml:space="preserve">
          <source>Read and/or write the content of a comma-separated value (CSV) file</source>
          <target state="translated">カンマ区切り値(CSV)ファイルの内容を読み書きすることができます。</target>
        </trans-unit>
        <trans-unit id="37ad8caf62966373ce6c4e8d0b90dbca553a6d76" translate="yes" xml:space="preserve">
          <source>Read cookie number P3 from database P1 and write it into register P2. P3==1 is the schema version. P3==2 is the database format. P3==3 is the recommended pager cache size, and so forth. P1==0 is the main database file and P1==1 is the database file used to store temporary tables.</source>
          <target state="translated">データベースP1からクッキー番号P3を読み出し、レジスタP2に書き込む。P3==1はスキーマのバージョンです。P3==2はデータベースのフォーマットです。P3==3は推奨ページャーキャッシュサイズなどです。P1==0はメインデータベースファイル、P1==1はテンポラリテーブルを格納するためのデータベースファイルです。</target>
        </trans-unit>
        <trans-unit id="e71f89bd0ef9b4251c544f6970cc91848cb5836e" translate="yes" xml:space="preserve">
          <source>Read the journal file and roll back the changes.</source>
          <target state="translated">ジャーナルファイルを読み込んで、変更をロールバックします。</target>
        </trans-unit>
        <trans-unit id="6d88c31d2b81845a511df588f6a77f45dfc3be73" translate="yes" xml:space="preserve">
          <source>Read the sqlite_stat1 table for database P1 and load the content of that table into the internal index hash table. This will cause the analysis to be used when preparing all subsequent queries.</source>
          <target state="translated">データベースP1のsqlite_stat1テーブルを読み込み、そのテーブルの内容を内部インデックスハッシュテーブルにロードします。これにより、後続のすべてのクエリを準備する際に分析が使用されるようになります。</target>
        </trans-unit>
        <trans-unit id="0e44b30ba60fce1cc60703c777be280cb42ce89f" translate="yes" xml:space="preserve">
          <source>Read transactions versus write transactions</source>
          <target state="translated">読み込みトランザクションと書き込みトランザクションの比較</target>
        </trans-unit>
        <trans-unit id="c8e239ec9521392219205446c1db66f47cb14a6f" translate="yes" xml:space="preserve">
          <source>Read-mark name</source>
          <target state="translated">リードマーク名</target>
        </trans-unit>
        <trans-unit id="e722ca5fefcf08950d7578b4ed97dfff47cf060e" translate="yes" xml:space="preserve">
          <source>Read-mark offset</source>
          <target state="translated">リードマークオフセット</target>
        </trans-unit>
        <trans-unit id="54ac153bd485005c1470e6c415d25c56cea6db82" translate="yes" xml:space="preserve">
          <source>Read-uncommitted mode has no effect on the locks required to write to database tables (i.e. read-uncommitted connections must still obtain write-locks and hence database writes may still block or be blocked). Also, read-uncommitted mode has no effect on the</source>
          <target state="translated">リードアンコミットモードは、データベーステーブルへの書き込みに必要なロックに影響を与えません(つまり、リードアンコミット接続でも書き込みロックを取得しなければならないため、データベースへの書き込みがブロックされたり、ブロックされたりする可能性があります)。また、read-uncommittedモードは</target>
        </trans-unit>
        <trans-unit id="0f2ef9917dd28993c09e6d3368ecafd38ec21fd3" translate="yes" xml:space="preserve">
          <source>Read-uncommitted mode has no effect on the locks required to write to database tables (i.e. read-uncommitted connections must still obtain write-locks and hence database writes may still block or be blocked). Also, read-uncommitted mode has no effect on the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; locks required by the rules enumerated below (see section &quot;Schema (sqlite_schema) Level Locking&quot;).</source>
          <target state="translated">読み取り非コミットモードは、データベーステーブルへの書き込みに必要なロックに影響を与えません（つまり、読み取り非コミット接続は引き続き書き込みロックを取得する必要があるため、データベースの書き込みはブロックまたはブロックされる可能性があります）。また、読み取り非コミットモードは、以下に列挙するルールで必要な&lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt;ロックには影響しません（「スキーマ（sqlite_schema）レベルロック」のセクションを参照）。</target>
        </trans-unit>
        <trans-unit id="3be7f0a767b2f2348fac25e36a455df9d59b0aa8" translate="yes" xml:space="preserve">
          <source>ReadCookie</source>
          <target state="translated">ReadCookie</target>
        </trans-unit>
        <trans-unit id="31f3f980bf6aafbf0b6a01d8c93e178b55b84057" translate="yes" xml:space="preserve">
          <source>Readers can also interpret this document as a primer on the world-view of the SQLite Founder, to help them better understand &quot;where he is coming from&quot;.</source>
          <target state="translated">また、読者はこのドキュメントをSQLiteの創始者の世界観の入門書として解釈することで、「彼がどこから来ているのか」をより深く理解することができます。</target>
        </trans-unit>
        <trans-unit id="ae8a4ca543f39205e57cdf686189d6cb9f899366" translate="yes" xml:space="preserve">
          <source>Reading Data</source>
          <target state="translated">読み取りデータ</target>
        </trans-unit>
        <trans-unit id="d6ac804a10ccff7c120f27eba34a8d2846e4c951" translate="yes" xml:space="preserve">
          <source>Reading Database Data</source>
          <target state="translated">データベースデータの読み取り</target>
        </trans-unit>
        <trans-unit id="5e3252839a95733cfd147953cc0469ba8c3ee82b" translate="yes" xml:space="preserve">
          <source>Reading and writing from an SQLite database is often faster than reading and writing individual files from disk. See &lt;a href=&quot;fasterthanfs&quot;&gt;35% Faster Than The Filesystem&lt;/a&gt; and &lt;a href=&quot;intern-v-extern-blob&quot;&gt;Internal Versus External BLOBs&lt;/a&gt;.</source>
          <target state="translated">SQLiteデータベースからの読み取りと書き込みは、多くの場合、ディスクからの個々のファイルの読み取りと書き込みよりも高速です。&lt;a href=&quot;fasterthanfs&quot;&gt;ファイルシステムより35％高速&lt;/a&gt;、&lt;a href=&quot;intern-v-extern-blob&quot;&gt;内部と外部のBLOBの比較を&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="629464bd60f83394a3a117af1490178a3f7649b8" translate="yes" xml:space="preserve">
          <source>Reading is about an order of magnitude faster than writing, for all systems and for both SQLite and direct-to-disk I/O.</source>
          <target state="translated">読み込みは、すべてのシステムで、SQLite と直接ディスクへの I/O の両方で、書き込みよりも桁違いに速くなります。</target>
        </trans-unit>
        <trans-unit id="8e16e5b2c446aea3b142d9320755f82932fc2cdf" translate="yes" xml:space="preserve">
          <source>Real</source>
          <target state="translated">Real</target>
        </trans-unit>
        <trans-unit id="51b9846d84b8915556858261f582bc9dc0399f32" translate="yes" xml:space="preserve">
          <source>RealAffinity</source>
          <target state="translated">RealAffinity</target>
        </trans-unit>
        <trans-unit id="316d0580c3ad15b3966bd98be1d84957c1e60292" translate="yes" xml:space="preserve">
          <source>Realign the memory allocation subsystem so that it never calls malloc() at all but instead satisfies all memory requests using a fixed-size memory buffer assigned to SQLite at startup.</source>
          <target state="translated">メモリ割り当てサブシステムを再調整し、malloc()を全く呼び出さず、代わりに起動時に SQLite に割り当てられた固定サイズのメモリバッファを使用してすべてのメモリ要求を満たすようにします。</target>
        </trans-unit>
        <trans-unit id="2d8e19244acdc1fed3e593bd66d86fe928aee4c4" translate="yes" xml:space="preserve">
          <source>Really means</source>
          <target state="translated">本当に意味がある</target>
        </trans-unit>
        <trans-unit id="9da9cf4099ea26b56238081e57a06dfa3fa584c9" translate="yes" xml:space="preserve">
          <source>Rebase a changeset</source>
          <target state="translated">チェンジセットのリベース</target>
        </trans-unit>
        <trans-unit id="f4699eec6b4e510d56bd2c8d9d97198adba02986" translate="yes" xml:space="preserve">
          <source>Rebasing changesets</source>
          <target state="translated">チェンジセットのリベース</target>
        </trans-unit>
        <trans-unit id="2ef8fffd38b336e3ddd055d82551d4885c779b2a" translate="yes" xml:space="preserve">
          <source>Recall that by default SQLite assumes that sector writes are linear but not atomic. A linear write starts at one end of the sector and changes information byte by byte until it gets to the other end of the sector. If a power loss occurs in the middle of a linear write then part of the sector might be modified while the other end is unchanged. In an atomic sector write, either the entire sector is overwritten or else nothing in the sector is changed.</source>
          <target state="translated">デフォルトでは、SQLite はセクタへの書き込みはリニアではあるがアトミックではないと想定していることを覚えておいてください。リニアライトはセクタの一方の端から始まり、セクタのもう一方の端に到達するまで情報をバイト単位で変更します。リニアライトの途中で電源が切れた場合、セクタの一部が変更され、もう一方の端は変更されない可能性があります。アトミックセクタ書き込みでは、セクタ全体が上書きされるか、セクタ内の何も変更されません。</target>
        </trans-unit>
        <trans-unit id="fe42ed2ae63e9fc51b86e94617527ae66cabf09d" translate="yes" xml:space="preserve">
          <source>Recall that there are two versions of the count() aggregate. With zero arguments, count() returns a count of the number of rows. With one argument, count() returns the number of times that the argument was non-NULL.</source>
          <target state="translated">count()集計には2つのバージョンがあることを覚えておいてください。引数がゼロの場合、count()は行数のカウントを返します。引数が1つの場合、count()は引数がNULLではなかった回数を返します。</target>
        </trans-unit>
        <trans-unit id="a00f50656a9b34825cf831a680edaba10510fe56" translate="yes" xml:space="preserve">
          <source>Recall the query template discussed above where there was a single loop that searched through every record of the table. In a join we have basically the same thing except that there are nested loops. For example, to join two tables, the query template might look something like this:</source>
          <target state="translated">上で説明したクエリテンプレートを思い出してください。結合でも基本的には同じですが、入れ子になったループがあることを除いては同じです。例えば、2つのテーブルを結合する場合、クエリテンプレートは次のようになります。</target>
        </trans-unit>
        <trans-unit id="86809186276b082875677dfb8773e34c548fc873" translate="yes" xml:space="preserve">
          <source>Recent versions of SQLite (&lt;a href=&quot;https://sqlite.org/releaselog/3_5_4.html&quot;&gt;version 3.5.4&lt;/a&gt; 2007-12-14) and later) will do this rewrite automatically if an index exists on the column ex2.b.</source>
          <target state="translated">SQLiteの最近のバージョン（&lt;a href=&quot;https://sqlite.org/releaselog/3_5_4.html&quot;&gt;バージョン3.5.4&lt;/a&gt; 2007-12-14以降）では、列ex2.bにインデックスが存在する場合、これが自動的に書き換えられます。</target>
        </trans-unit>
        <trans-unit id="3bc92f0a6532d70c3844508e07c71adfd5cc6f39" translate="yes" xml:space="preserve">
          <source>Recently, folks have begun to use the word &quot;serverless&quot; to mean something subtly different from its intended meaning in this document. Here are two possible definitions of &quot;serverless&quot;:</source>
          <target state="translated">最近では、「サーバーレス」という言葉を、この文書で意図されている意味とは微妙に異なる意味で使うようになってきました。ここでは、&quot;serverless &quot;の定義として、2つの可能性があります。</target>
        </trans-unit>
        <trans-unit id="6aff9d1c0cd44324ba9f0bf36546b5e1f8429f77" translate="yes" xml:space="preserve">
          <source>Recognize TRUE and FALSE as constants. (For compatibility, if there exist columns named &quot;true&quot; or &quot;false&quot;, then the identifiers refer to the columns rather than Boolean constants.)</source>
          <target state="translated">TRUE と FALSE を定数として認識します。(互換性のため、&quot;true&quot; や &quot;false&quot; という名前のカラムが存在する場合は、その識別子がブール定数ではなくカラムを参照します)。</target>
        </trans-unit>
        <trans-unit id="179015156dce938e7897002183aef5320bee7f01" translate="yes" xml:space="preserve">
          <source>Recognize always that evil is your own doing, and to impute it to yourself.</source>
          <target state="translated">悪は自分自身の行いであることを常に認識し、それを自分のものとすること。</target>
        </trans-unit>
        <trans-unit id="29b5caee3338c6458807b234105f74058b4d7a0e" translate="yes" xml:space="preserve">
          <source>Recognize and use the &lt;a href=&quot;uri#coreqp&quot;&gt;mode=memory&lt;/a&gt; query parameter in &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;uri&quot;&gt;URIファイル名&lt;/a&gt;で&lt;a href=&quot;uri#coreqp&quot;&gt;mode = memory&lt;/a&gt;クエリパラメータを認識して使用します。</target>
        </trans-unit>
        <trans-unit id="cb32b6d7f8df5da26a0dcd937f77f995164cb71d" translate="yes" xml:space="preserve">
          <source>Recommended practice is to omit any extra tokens in the rtree specification. Let each argument to &quot;rtree&quot; be a single ordinary label that is the name of the corresponding column, and omit all other tokens from the argument list.</source>
          <target state="translated">推奨されるのは、rtree仕様では余分なトークンを省略することである。rtree &quot;への各引数は、対応する列の名前である単一の通常のラベルとし、引数リストから他のすべてのトークンを省略する。</target>
        </trans-unit>
        <trans-unit id="c16e180b0bdec1403e839436f75c49abbd9e4f92" translate="yes" xml:space="preserve">
          <source>Recommended storage formats are formats which, in the opinion of the preservationists at the Library of Congress, maximizes the chance of survival and continued accessibility of digital content. When selecting recommended storage formats, the following criteria are considered (quoting from the LOC website):</source>
          <target state="translated">推奨される保存形式とは、米国議会図書館の保存担当者の意見として、デジタルコンテンツの存続と継続的なアクセスの可能性を最大限に高める形式のことです。推奨される保存形式を選択する際には、以下の基準が考慮されます(LOCのウェブサイトより引用)。</target>
        </trans-unit>
        <trans-unit id="5592531a18661eb883b5bed3c568528bf424614f" translate="yes" xml:space="preserve">
          <source>Reconfigure the memory allocation subsystem to use a memory allocator other the malloc() implementation from the standard library.</source>
          <target state="translated">標準ライブラリの malloc()実装以外のメモリアロケータを使用するように、メモリ割り当てサブシステムを再構成します。</target>
        </trans-unit>
        <trans-unit id="8ba4782c1f2f1755a1c2a5a0d315ff7ac146d397" translate="yes" xml:space="preserve">
          <source>Record A Database Snapshot</source>
          <target state="translated">データベースのスナップショットを記録する</target>
        </trans-unit>
        <trans-unit id="8234a19b9512ea840c0ba24f55af66169cacecab" translate="yes" xml:space="preserve">
          <source>Record format</source>
          <target state="translated">レコード形式</target>
        </trans-unit>
        <trans-unit id="10c3664b2112d9f16bd331cd75392554bbbcdf62" translate="yes" xml:space="preserve">
          <source>Records may be removed from an existing zip archive by deleting the corresponding rows. For example, to remove file &quot;m.txt&quot; from zip archive &quot;test.zip&quot; using the virtual table created above:</source>
          <target state="translated">既存の zip アーカイブからレコードを削除するには、対応する行を削除します。例えば、上記で作成した仮想テーブルを使用して、zipアーカイブ「test.zip」からファイル「m.txt」を削除するには、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="9d25bfb94d2fc125544295d666182c0dd2c985e3" translate="yes" xml:space="preserve">
          <source>Recover snapshots from a wal file</source>
          <target state="translated">ウォルファイルからスナップショットを復元</target>
        </trans-unit>
        <trans-unit id="a5ee4bb9875041e97087fa0bc2157c001344d43d" translate="yes" xml:space="preserve">
          <source>Recovery is run by the first thread to connect to a WAL-mode database. Recovery restores the WAL-index so that it accurately describes the WAL file. If there is no WAL file present when the first thread connects to the database, there is nothing to recover, but the recovery process still runs to initialize the WAL-index.</source>
          <target state="translated">リカバリは、WAL モードのデータベースに接続する最初のスレッドによって実行されます。リカバリは、WALファイルを正確に記述するようにWAL-indexを復元する。最初のスレッドがデータベースに接続したときに WAL ファイルが存在しない場合、回復するものは何もありませんが、回復プロセスは WAL-index を初期化するために実行されます。</target>
        </trans-unit>
        <trans-unit id="bb50e77cc812505c4eff76e2425d38fe88e897da" translate="yes" xml:space="preserve">
          <source>Recovery is the process of rebuilding the WAL-index so that it is synchronized with the WAL.</source>
          <target state="translated">リカバリーとは、WAL-indexがWALと同期するように再構築するプロセスです。</target>
        </trans-unit>
        <trans-unit id="126c442522e8176d581a74aac3e674f456801a72" translate="yes" xml:space="preserve">
          <source>Recovery works by doing a single pass over the WAL, from beginning to end. The checksums are verified on each frame of the WAL as it is read. The scan stops at the end of the file or at the first invalid checksum. The &lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt; field is set to the index of the last valid commit frame in WAL. Since WAL frame numbers are indexed starting with 1, mxFrame is also the number of valid frames in the WAL. A &quot;commit frame&quot; is a frame that has a non-zero value in bytes 4 through 7 of the frame header. Since the recovery procedure has no way of knowing how many frames of the WAL might have previously been copied back into the database, it initializes the &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt; value to zero.</source>
          <target state="translated">回復は、WALを最初から最後まで1回パスすることで機能します。チェックサムは、読み取られるときにWALの各フレームで検証されます。スキャンは、ファイルの最後または最初の無効なチェックサムで停止します。&lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrameの&lt;/a&gt;フィールドはWALに有効なコミット最後のフレームのインデックスに設定されています。WALフレーム番号には1から始まるインデックスが付けられているため、mxFrameはWAL内の有効なフレームの数でもあります。「コミットフレーム」は、フレームヘッダーのバイト4〜7にゼロ以外の値を持つフレームです。リカバリー手順では、以前にデータベースにコピーされたWALのフレームの数を知る方法がないため、&lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt;値をゼロに初期化します。</target>
        </trans-unit>
        <trans-unit id="3d82c021f8a8434797b007430def5edf49be84c3" translate="yes" xml:space="preserve">
          <source>Recursive Common Table Expressions</source>
          <target state="translated">再帰的共通表式</target>
        </trans-unit>
        <trans-unit id="7c623be56f37d78f01c1c7d914b54e7a24680aab" translate="yes" xml:space="preserve">
          <source>Recursive Query Examples</source>
          <target state="translated">再帰的クエリの例</target>
        </trans-unit>
        <trans-unit id="8f08fb34ad6f2633ad710e95a13cbec5c283657b" translate="yes" xml:space="preserve">
          <source>Recursive query</source>
          <target state="translated">再帰的な問い合わせ</target>
        </trans-unit>
        <trans-unit id="c73052a6762ac25c0cb1d9b0bebcfc3a9bcec8a1" translate="yes" xml:space="preserve">
          <source>Recursive triggers can be enabled using the &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt; statement.</source>
          <target state="translated">再帰トリガーは、&lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt;ステートメントを使用して有効にできます。</target>
        </trans-unit>
        <trans-unit id="142c98a709e57d4d546600faca999a5bf35abdaa" translate="yes" xml:space="preserve">
          <source>Redesign the OS interface layer. See &lt;a href=&quot;34to35&quot;&gt;34to35.html&lt;/a&gt; for details. *** Potentially incompatible change ***</source>
          <target state="translated">OSインターフェース層を再設計します。詳細については、&lt;a href=&quot;34to35&quot;&gt;34to35.html&lt;/a&gt;を参照してください。***互換性がない可能性のある変更***</target>
        </trans-unit>
        <trans-unit id="7d081723177fd4e3a870ace0d58c302ef456d798" translate="yes" xml:space="preserve">
          <source>Reduce the &lt;a href=&quot;limits&quot;&gt;limits&lt;/a&gt; that SQLite imposes on inputs. This can help prevent denial of service attacks and other kinds of mischief that can occur as a result of unusually large inputs. You can do this either at compile-time using -DSQLITE_MAX_... options, or at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; interface. Most applications can reduce limits dramatically without impacting functionality. The table below provides some suggestions, though exact values will vary depending on the application:</source>
          <target state="translated">SQLiteが入力に課す&lt;a href=&quot;limits&quot;&gt;制限&lt;/a&gt;を減らします。これは、異常に大きな入力の結果として発生する可能性のあるサービス拒否攻撃やその他の種類のいたずらを防ぐのに役立ちます。これは、コンパイル時に-DSQLITE_MAX _...オプションを使用するか、実行時に&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;インターフェースを使用して実行できます。ほとんどのアプリケーションは、機能に影響を与えることなく、制限を劇的に減らすことができます。以下の表にいくつかの提案を示しますが、正確な値はアプリケーションによって異なります。</target>
        </trans-unit>
        <trans-unit id="818c7c2bc91785e19d03eddcb38dd27df259ccaf" translate="yes" xml:space="preserve">
          <source>Reduce the amount of heap memory used, especially by TRIGGERs.</source>
          <target state="translated">特にTRIGGERによって使用されるヒープメモリの量を減らします。</target>
        </trans-unit>
        <trans-unit id="eef61fea62e3c60ebd3be2d6739fac06ddb5ab7f" translate="yes" xml:space="preserve">
          <source>Reduce the amount of memory needed to hold the schema.</source>
          <target state="translated">スキーマを保持するために必要なメモリ量を削減します。</target>
        </trans-unit>
        <trans-unit id="46eb8cc3e58b2e58eac841d7bad510287fbae8b0" translate="yes" xml:space="preserve">
          <source>Reduce the amount of stack space used</source>
          <target state="translated">スタックスペースの使用量を減らす</target>
        </trans-unit>
        <trans-unit id="2a4594bb7a13597e42630528fe396b294272a9f2" translate="yes" xml:space="preserve">
          <source>Reduce the number of memcpy() operations involved in balancing a b-tree, for 3.2% overall performance boost.</source>
          <target state="translated">b-tree のバランシングに関わる memcpy()操作の数を減らし、全体のパフォーマンスを 3.2% 向上させます。</target>
        </trans-unit>
        <trans-unit id="15563f82edab75e0e9a9533c5985511dfd901167" translate="yes" xml:space="preserve">
          <source>Reduce the size and increase the speed of various modules, especially the virtual machine.</source>
          <target state="translated">様々なモジュール、特に仮想マシンのサイズを縮小し、高速化します。</target>
        </trans-unit>
        <trans-unit id="f355d2ddba29d09803b074513416794452b26fe2" translate="yes" xml:space="preserve">
          <source>Reenable the xCurrentTime and xGetLastError methods in the built-in unix &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; as long as &lt;a href=&quot;compile#omit_deprecated&quot;&gt;SQLITE_OMIT_DEPRECATED&lt;/a&gt; is not defined.</source>
          <target state="translated">&lt;a href=&quot;compile#omit_deprecated&quot;&gt;SQLITE_OMIT_DEPRECATED&lt;/a&gt;が定義されていない限り、組み込み UNIX &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;でxCurrentTimeおよびxGetLastErrorメソッドを再度有効にします。</target>
        </trans-unit>
        <trans-unit id="f79991a5be2e57d9f5c8d975047a7ce1e99e2e69" translate="yes" xml:space="preserve">
          <source>Refactor parts of the code in order to make the code footprint smaller. The code is now also a little bit faster.</source>
          <target state="translated">コードのフットプリントを小さくするために、コードの一部をリファクタします。コードも少し速くなりました。</target>
        </trans-unit>
        <trans-unit id="731a046a349bd8b2ec56f17167cd9586697efc8d" translate="yes" xml:space="preserve">
          <source>Refactor the implementation of PRAGMA statements to improve parsing performance.</source>
          <target state="translated">構文解析のパフォーマンスを向上させるためにPRAGMA文の実装をリファクタリングしました。</target>
        </trans-unit>
        <trans-unit id="e01090e00d57212fc38896c2384f678dca5a4d12" translate="yes" xml:space="preserve">
          <source>Refactor the internal representation of SQL expressions so that they use less memory on embedded platforms.</source>
          <target state="translated">組み込みプラットフォームでのメモリ使用量が少なくなるように、SQL式の内部表現をリファクタリングしました。</target>
        </trans-unit>
        <trans-unit id="f207a8a558acb07f31589303df5e596105913ffb" translate="yes" xml:space="preserve">
          <source>Refactored the pager module.</source>
          <target state="translated">ページャーモジュールをリファクタリングしました。</target>
        </trans-unit>
        <trans-unit id="226346556688fb9ee0c75ecc678574e3685f1eba" translate="yes" xml:space="preserve">
          <source>Refer to comments in the &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=ext/async/sqlite3async.h&quot;&gt; sqlite3async.h header file&lt;/a&gt; for details.</source>
          <target state="translated">詳細については、&lt;a href=&quot;http://www.sqlite.org/src/finfo?name=ext/async/sqlite3async.h&quot;&gt;sqlite3async.hヘッダーファイルの&lt;/a&gt;コメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="aaa837aee763755888a50c44b690c5b28c724c42" translate="yes" xml:space="preserve">
          <source>Refer to section</source>
          <target state="translated">セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="4604acc1b8f76983f5d1c6cf4dd45f3755df9f62" translate="yes" xml:space="preserve">
          <source>Refer to the documentation for the &lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5 automerge option&lt;/a&gt; for more details regarding the relationship between the full-text index and its component b-trees.</source>
          <target state="translated">フルテキストインデックスとそのコンポーネントのBツリーの間の関係の詳細については、&lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5自動マージオプションの&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="5c53a88bcf3d728c764909fd53351fd558c74013" translate="yes" xml:space="preserve">
          <source>Refer to the sqlite3_changegroup documentation below for details.</source>
          <target state="translated">詳細は下記のsqlite3_changegroupのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="96203fca2f22f72728b0d96559374bef790492f7" translate="yes" xml:space="preserve">
          <source>Refer to wikipedia for &lt;a href=&quot;http://en.wikipedia.org/wiki/Okapi_BM25&quot;&gt;more information regarding BM25&lt;/a&gt; and its variants.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Okapi_BM25&quot;&gt;BM25&lt;/a&gt;およびその変種に関する詳細については、ウィキペディアを参照してください。</target>
        </trans-unit>
        <trans-unit id="5d20d0fee3b91643dd8d272ac33d01ca95179d82" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="translated">References</target>
        </trans-unit>
        <trans-unit id="ed24ba4d4b3deaa5349f31379e8793cc898888c5" translate="yes" xml:space="preserve">
          <source>References to the table within CHECK constraints in the original CREATE TABLE statement.</source>
          <target state="translated">元のCREATE TABLE文のCHECK制約内のテーブルへの参照。</target>
        </trans-unit>
        <trans-unit id="f196200e5cee3f63f8cb5af84d2656fca6403f9b" translate="yes" xml:space="preserve">
          <source>References to the table within the WHERE clauses of &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;partialindex&quot;&gt;部分インデックスの&lt;/a&gt; WHERE句内のテーブルへの参照。</target>
        </trans-unit>
        <trans-unit id="9ee14d3156938bfc006a2f0c8ed355d9ca151ab6" translate="yes" xml:space="preserve">
          <source>References to the table within the bodies of triggers and views.</source>
          <target state="translated">トリガーやビューのボディ内のテーブルを参照します。</target>
        </trans-unit>
        <trans-unit id="906a77daf0ffffc997c9b5822b41dc5c11c3a7b9" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#alter-table-stmt&quot;&gt;alter-table-stmt&lt;/a&gt;&lt;a href=&quot;#analyze-stmt&quot;&gt;analyze-stmt&lt;/a&gt;&lt;a href=&quot;#attach-stmt&quot;&gt;attach-stmt&lt;/a&gt;&lt;a href=&quot;#begin-stmt&quot;&gt;begin-stmt&lt;/a&gt;&lt;a href=&quot;#commit-stmt&quot;&gt;commit-stmt&lt;/a&gt;&lt;a href=&quot;#create-index-stmt&quot;&gt;create-index-stmt&lt;/a&gt;&lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;&lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;#create-view-stmt&quot;&gt;create-view-stmt&lt;/a&gt;&lt;a href=&quot;#create-virtual-table-stmt&quot;&gt;create-virtual-table-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;#detach-stmt&quot;&gt;detach-stmt&lt;/a&gt;&lt;a href=&quot;#drop-index-stmt&quot;&gt;drop-index-stmt&lt;/a&gt;&lt;a href=&quot;#drop-table-stmt&quot;&gt;drop-table-stmt&lt;/a&gt;&lt;a href=&quot;#drop-trigger-stmt&quot;&gt;drop-trigger-stmt&lt;/a&gt;&lt;a href=&quot;#drop-view-stmt&quot;&gt;drop-view-stmt&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;#pragma-stmt&quot;&gt;pragma-stmt&lt;/a&gt;&lt;a href=&quot;#reindex-stmt&quot;&gt;reindex-stmt&lt;/a&gt;&lt;a href=&quot;#release-stmt&quot;&gt;release-stmt&lt;/a&gt;&lt;a href=&quot;#rollback-stmt&quot;&gt;rollback-stmt&lt;/a&gt;&lt;a href=&quot;#savepoint-stmt&quot;&gt;savepoint-stmt&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;#vacuum-stmt&quot;&gt;vacuum-stmt&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#alter-table-stmt&quot;&gt;alter-table-stmt &lt;/a&gt;&lt;a href=&quot;#analyze-stmt&quot;&gt;analyze-stmt &lt;/a&gt;&lt;a href=&quot;#attach-stmt&quot;&gt;attach-stmt &lt;/a&gt;&lt;a href=&quot;#begin-stmt&quot;&gt;begin-stmt &lt;/a&gt;&lt;a href=&quot;#commit-stmt&quot;&gt;commit-stmt &lt;/a&gt;&lt;a href=&quot;#create-index-stmt&quot;&gt;create-index-stmt &lt;/a&gt;&lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt &lt;/a&gt;&lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;#create-view-stmt&quot;&gt;create-view-stmt &lt;/a&gt;&lt;a href=&quot;#create-virtual-table-stmt&quot;&gt;create-virtual-table-stmt &lt;/a&gt;&lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete -stmt-limited &lt;/a&gt;&lt;a href=&quot;#detach-stmt&quot;&gt;detach-stmt &lt;/a&gt;&lt;a href=&quot;#drop-index-stmt&quot;&gt;drop-index-stmt &lt;/a&gt;&lt;a href=&quot;#drop-table-stmt&quot;&gt;drop-table-stmt &lt;/a&gt;&lt;a href=&quot;#drop-trigger-stmt&quot;&gt;drop-trigger-stmt &lt;/a&gt;&lt;a href=&quot;#drop-view-stmt&quot;&gt;drop-view-stmt &lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;#pragma-stmt&quot;&gt;pragma-stmt &lt;/a&gt;&lt;a href=&quot;#reindex-stmt&quot;&gt;reindex-stmt &lt;/a&gt;&lt;a href=&quot;#release-stmt&quot;&gt;release-stmt &lt;/a&gt;&lt;a href=&quot;#rollback-stmt&quot;&gt;rollback-stmt &lt;/a&gt;&lt;a href=&quot;#savepoint-stmt&quot;&gt;savepoint-stmt &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update- stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited &lt;/a&gt;&lt;a href=&quot;#vacuum-stmt&quot;&gt;vacuum-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91c7fe4cacb331d9cfb44eb087944db8da3afcbf" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;#type-name&quot;&gt;type-name&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#column-constraint&quot;&gt;column-constraint &lt;/a&gt;&lt;a href=&quot;#type-name&quot;&gt;type-name&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6d8aed8c6ef717e51cf55fa5d410506ec56f1af1" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-def&quot;&gt;column-def&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#column-def&quot;&gt;column-def&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd54af792928e125a7c3d661324a97a3ce29b673" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-def&quot;&gt;column-def&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;table-constraint&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#column-def&quot;&gt;column-def &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;table-constraint&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="071f7537398d675e45a2fdaeb7bd26af44546b4d" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#column-name-list&quot;&gt;column-name-list &lt;/a&gt;&lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering- &lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;termqualified-table &lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;-nametable-or-subquery&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="282f6190a1e00fb7ff7db1945ee84f7660a92c19" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#column-name-list&quot;&gt;column-name-list &lt;/a&gt;&lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clausequalified &lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;-table &lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;-nametable-or-subquery&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e21742ff977fd9e5a8403d3239f8a93202fb0f39" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;indexed-column&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#column-name-list&quot;&gt;column-name-list &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;indexed-column&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3f805e85c41e9b3e30cafd3a842789358c3b6f12" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#column-name-list&quot;&gt;column-name-list &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering- &lt;/a&gt;termqualified &lt;a href=&quot;#qualified-table-name&quot;&gt;-table-name &lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c69d978973c2b2241d5e4e82a79030c6aad5250" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#column-name-list&quot;&gt;column-name-list &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;exprqualified &lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;-table-name &lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c2fd61f6a02e283a2e59272b7eb020a882319466" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#compound-operator&quot;&gt;compound-operator&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#result-column&quot;&gt;result-column&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;#compound-operator&quot;&gt;複合演算子&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term &lt;/a&gt;&lt;a href=&quot;#result-column&quot;&gt;result-column &lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery &lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="667fd9a2ec0f33043daaaa5159b9ecc1f39e7b33" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#compound-operator&quot;&gt;compound-operator&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;#compound-operator&quot;&gt;複合演算子&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term &lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8472bb382411c88450e331d7c59babdb2e746659" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering- &lt;/a&gt;termqualified &lt;a href=&quot;#qualified-table-name&quot;&gt;-table-name&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="77d3b028f4d456c29b115c3c1f35daadd6ff1624" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term &lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1f8ccd3795f8b71bf70343d3fadc3ac179cc9d91" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;exprqualified &lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;-table-name&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9a74b1ac9b009442b86c0a0250e3450f6dd245c7" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="093e3a3349236fc2dfd7410c161635443356bb67" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#conflict-clause&quot;&gt;conflict-clause&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#foreign-key-clause&quot;&gt;foreign-key-clause&lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;indexed-column&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#conflict-clause&quot;&gt;conflict-clause &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#foreign-key-clause&quot;&gt;foreign-key-clause &lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;indexed-column&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75b80513956bb1581ff56ceefb5d202b11f453b7" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#conflict-clause&quot;&gt;conflict-clause&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#foreign-key-clause&quot;&gt;foreign-key-clause&lt;/a&gt;&lt;a href=&quot;#literal-value&quot;&gt;literal-value&lt;/a&gt;&lt;a href=&quot;#signed-number&quot;&gt;signed-number&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#conflict-clause&quot;&gt;conflict-clause &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#foreign-key-clause&quot;&gt;foreign-key-clause &lt;/a&gt;&lt;a href=&quot;#literal-value&quot;&gt;literal-value &lt;/a&gt;&lt;a href=&quot;#signed-number&quot;&gt;signed-number&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d11da2b5af692e996d5a48b32dfe86b2041eb8fa" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#cte-table-name&quot;&gt;cte-table-name&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#cte-table-name&quot;&gt;cte-table-name&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7d0820e324079711069f47384d996edb389c3588" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#cte-table-name&quot;&gt;cte-table-name&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#cte-table-name&quot;&gt;cte-table-name &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="20cbc57031b425ef7fc75a576696f91fe9b3d951" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="93149806f66b1921c7517b514d80a3b282666f6b" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8bd75a2c3ba3eeca6c41d3a9318cbfdbb49e88c0" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#filter-clause&quot;&gt;filter-clause&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#filter-clause&quot;&gt;filter-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="af58968390f59e5f5b4c323addb3e01a57ee6c1e" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#filter-clause&quot;&gt;filter-clause&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#filter-clause&quot;&gt;filter-clause &lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="32f96f5ec0fb2907e9e4e032ea0ae81ddc82a1a3" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#frame-spec&quot;&gt;frame-spec&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#frame-spec&quot;&gt;frame-spec &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9dbf0458189780b769224889b3056c63b7e1f84" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;indexed-column&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;indexed-column&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="59c40f8bbdab8cad4f5af93d93f71d7dbf30aa93" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#result-column&quot;&gt;result-column&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;#result-column&quot;&gt;result-column &lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery &lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5b9919027e05781036111a8daacdadf3c525fde5" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0773bdc1abf8efee6c1c60cecf9ee9685433dab7" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term &lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;modifier-table-name &lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="24422bef8d6810e38018f045129e207f3e959155" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;修飾テーブル名&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with節&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="85f3810be175c469cf369360e14b9b2e5e01ac51" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause &lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="70abaefe9f99828256cfd758a3afb7aa4c216e61" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#filter-clause&quot;&gt;filter-clause&lt;/a&gt;&lt;a href=&quot;#literal-value&quot;&gt;literal-value&lt;/a&gt;&lt;a href=&quot;#over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;#raise-function&quot;&gt;raise-function&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#type-name&quot;&gt;type-name&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#filter-clause&quot;&gt;filter-clause &lt;/a&gt;&lt;a href=&quot;#literal-value&quot;&gt;literal-value &lt;/a&gt;&lt;a href=&quot;#over-clause&quot;&gt;over-clause &lt;/a&gt;&lt;a href=&quot;#raise-function&quot;&gt;raise-function &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#type-name&quot;&gt;type-name&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c999a62fb82e126ba176715636e35111bb542d88" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#join-constraint&quot;&gt;join-constraint&lt;/a&gt;&lt;a href=&quot;#join-operator&quot;&gt;join-operator&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#join-constraint&quot;&gt;結合制約&lt;/a&gt;&lt;a href=&quot;#join-operator&quot;&gt;結合演算子&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;テーブルまたはサブクエリ&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3ad3c1f9f2a404dc774db57c85b8cec60718ee04" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#pragma-value&quot;&gt;pragma-value&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#pragma-value&quot;&gt;プラグマ値&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="442eba43f59acab4d01a4fc91704194929768abd" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="be27274cd4dccea52cefd3991def25081da71262" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#signed-number&quot;&gt;signed-number&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#signed-number&quot;&gt;符号付き番号&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a57a4e147f3de189d6e7e73c4c51f52022e0bd82" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="38492d751f295bea065fa71e3925fb3ad037a1e2" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;alter-table-stmt&quot;&gt;alter-table-stmt&lt;/a&gt;&lt;a href=&quot;analyze-stmt&quot;&gt;analyze-stmt&lt;/a&gt;&lt;a href=&quot;attach-stmt&quot;&gt;attach-stmt&lt;/a&gt;&lt;a href=&quot;begin-stmt&quot;&gt;begin-stmt&lt;/a&gt;&lt;a href=&quot;commit-stmt&quot;&gt;commit-stmt&lt;/a&gt;&lt;a href=&quot;create-index-stmt&quot;&gt;create-index-stmt&lt;/a&gt;&lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;&lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;create-view-stmt&quot;&gt;create-view-stmt&lt;/a&gt;&lt;a href=&quot;create-virtual-table-stmt&quot;&gt;create-virtual-table-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;detach-stmt&quot;&gt;detach-stmt&lt;/a&gt;&lt;a href=&quot;drop-index-stmt&quot;&gt;drop-index-stmt&lt;/a&gt;&lt;a href=&quot;drop-table-stmt&quot;&gt;drop-table-stmt&lt;/a&gt;&lt;a href=&quot;drop-trigger-stmt&quot;&gt;drop-trigger-stmt&lt;/a&gt;&lt;a href=&quot;drop-view-stmt&quot;&gt;drop-view-stmt&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;pragma-stmt&quot;&gt;pragma-stmt&lt;/a&gt;&lt;a href=&quot;reindex-stmt&quot;&gt;reindex-stmt&lt;/a&gt;&lt;a href=&quot;release-stmt&quot;&gt;release-stmt&lt;/a&gt;&lt;a href=&quot;rollback-stmt&quot;&gt;rollback-stmt&lt;/a&gt;&lt;a href=&quot;savepoint-stmt&quot;&gt;savepoint-stmt&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;vacuum-stmt&quot;&gt;vacuum-stmt&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;alter-table-stmt&quot;&gt;alter-table-stmt &lt;/a&gt;&lt;a href=&quot;analyze-stmt&quot;&gt;analyze-stmt &lt;/a&gt;&lt;a href=&quot;attach-stmt&quot;&gt;attach-stmt &lt;/a&gt;&lt;a href=&quot;begin-stmt&quot;&gt;begin-stmt &lt;/a&gt;&lt;a href=&quot;commit-stmt&quot;&gt;commit-stmt &lt;/a&gt;&lt;a href=&quot;create-index-stmt&quot;&gt;create-index-stmt &lt;/a&gt;&lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt &lt;/a&gt;&lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;create-view-stmt&quot;&gt;create-view-stmt &lt;/a&gt;&lt;a href=&quot;create-virtual-table-stmt&quot;&gt;create-virtual-table-stmt &lt;/a&gt;&lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete -stmt-limited &lt;/a&gt;&lt;a href=&quot;detach-stmt&quot;&gt;detach-stmt &lt;/a&gt;&lt;a href=&quot;drop-index-stmt&quot;&gt;drop-index-stmt &lt;/a&gt;&lt;a href=&quot;drop-table-stmt&quot;&gt;drop-table-stmt &lt;/a&gt;&lt;a href=&quot;drop-trigger-stmt&quot;&gt;drop-trigger-stmt &lt;/a&gt;&lt;a href=&quot;drop-view-stmt&quot;&gt;drop-view-stmt &lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;pragma-stmt&quot;&gt;pragma-stmt &lt;/a&gt;&lt;a href=&quot;reindex-stmt&quot;&gt;reindex-stmt &lt;/a&gt;&lt;a href=&quot;release-stmt&quot;&gt;release-stmt &lt;/a&gt;&lt;a href=&quot;rollback-stmt&quot;&gt;rollback-stmt &lt;/a&gt;&lt;a href=&quot;savepoint-stmt&quot;&gt;savepoint-stmt &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update- stmt &lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited &lt;/a&gt;&lt;a href=&quot;vacuum-stmt&quot;&gt;vacuum-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="650835c724bb2a86f89f84e9bbd3b780c13b6c9b" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;type-name&quot;&gt;type-name&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;column-constraint&quot;&gt;column-constraint &lt;/a&gt;&lt;a href=&quot;type-name&quot;&gt;type-name&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="794b40cf8cd20637c83761e0684d3f4a5ca08040" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-def&quot;&gt;column-def&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;column-def&quot;&gt;column-def&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aa218b2013469fb9882536f9cece6e55484d18b7" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-def&quot;&gt;column-def&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;table-constraint&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;column-def&quot;&gt;column-def &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;table-constraint&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5321f3c79df9e1ae13dc45785cee7ab2db6ce76c" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;column-name-list&quot;&gt;column-name-list &lt;/a&gt;&lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering- &lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;termqualified-table &lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;-nametable-or-subquery&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d04da558e7b275ed093eaddcfd1b8fc7d2f8e276" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;column-name-list&quot;&gt;column-name-list &lt;/a&gt;&lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clausequalified &lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;-table &lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;-nametable-or-subquery&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0efb77e2ca9ef9f00e4b6a166106c03c563ce0be" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;indexed-column&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;column-name-list&quot;&gt;column-name-list &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;indexed-column&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e4f6089017390e83489b6d24ed571adac8331d80" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;column-name-list&quot;&gt;column-name-list &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering- &lt;/a&gt;termqualified &lt;a href=&quot;qualified-table-name&quot;&gt;-table-name &lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1113daac28cbd063c08079443895f5566fdb33e5" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;column-name-list&quot;&gt;column-name-list &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;exprqualified &lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;-table-name &lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3451b0f3b2b5af6b8d8b5aaefde1b19828f7a6c" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;compound-operator&quot;&gt;compound-operator&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;result-column&quot;&gt;result-column&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;compound-operator&quot;&gt;compound-operator &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term &lt;/a&gt;&lt;a href=&quot;result-column&quot;&gt;result-column &lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery &lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bba4382f55d6ffe66c81fa9289d49182e1355fcb" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;compound-operator&quot;&gt;compound-operator&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;compound-operator&quot;&gt;複合演算子&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term &lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8b632fa679cae46b9a02f325553f2a2a7613b116" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering- &lt;/a&gt;termqualified &lt;a href=&quot;qualified-table-name&quot;&gt;-table-name&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="79d31ae5a462b6f054075ad5596a58eef1283d37" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term &lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1445ac57fe2b5334ccb8353e30f33be3e0e94b22" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;exprqualified &lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;-table-name&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91e02a407b8ce1872e126aedfe89133ac0d4f641" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8df9ea1d38fc83cf8d4c226cc463aaf1077b0c6f" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;conflict-clause&quot;&gt;conflict-clause&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;foreign-key-clause&quot;&gt;foreign-key-clause&lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;indexed-column&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;conflict-clause&quot;&gt;conflict-clause &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;foreign-key-clause&quot;&gt;foreign-key-clause &lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;indexed-column&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b098cacd25ca6e0fe7a4f6cbe7dc7b7acf41b7b8" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;conflict-clause&quot;&gt;conflict-clause&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;foreign-key-clause&quot;&gt;foreign-key-clause&lt;/a&gt;&lt;a href=&quot;literal-value&quot;&gt;literal-value&lt;/a&gt;&lt;a href=&quot;signed-number&quot;&gt;signed-number&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;conflict-clause&quot;&gt;conflict-clause &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;foreign-key-clause&quot;&gt;foreign-key-clause &lt;/a&gt;&lt;a href=&quot;literal-value&quot;&gt;literal-value &lt;/a&gt;&lt;a href=&quot;signed-number&quot;&gt;signed-number&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="21f46943158a8d7768ec74ac4bca397f3d7466cc" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;cte-table-name&quot;&gt;cte-table-name&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;cte-table-name&quot;&gt;cte-table-name&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52f4dcceccfec99df86cc955c80ee8cdbaf49960" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;cte-table-name&quot;&gt;cte-table-name&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;cte-table-name&quot;&gt;cte-table-name &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96f363ba239b93df7e224622a52457e08203ac21" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b1460387ec8f592a739d62fe04e5527e471ea1d0" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="192d6846ace3aa19cd52dd4ee585f12a733bb1e7" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;filter-clause&quot;&gt;filter-clause&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;filter-clause&quot;&gt;filter-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c9283f303c0dddff0aeb96fe77630b3f0f7f1cd0" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;filter-clause&quot;&gt;filter-clause&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;filter-clause&quot;&gt;filter-clause &lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="885613b30bdc3bb4e3fc4bfce7226fd3a4194313" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;frame-spec&quot;&gt;frame-spec&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;frame-spec&quot;&gt;frame-spec &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5bbd33495175a536a093475520310921d8e80cb9" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;indexed-column&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;indexed-column&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ac7994da54203d91b06af47c53b1f26548090ed" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;result-column&quot;&gt;result-column&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;result-column&quot;&gt;result-column &lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery &lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5211947595082a78c56fd9fbfa97e9aa9db46e39" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8ef3d4989ffca292fb408e36d6c80a0be05d38e3" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term &lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;modifier-table-name &lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2f754738e511b595c21699d1599455b2ad77e7ea" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;修飾テーブル名&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with節&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="10dff942ab951e8379beded21b97716b5a9470ac" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause &lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aead43f0300958c1d62f97ac7d9dbb7744c5f973" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;filter-clause&quot;&gt;filter-clause&lt;/a&gt;&lt;a href=&quot;literal-value&quot;&gt;literal-value&lt;/a&gt;&lt;a href=&quot;over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;raise-function&quot;&gt;raise-function&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;type-name&quot;&gt;type-name&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;filter-clause&quot;&gt;filter-clause &lt;/a&gt;&lt;a href=&quot;literal-value&quot;&gt;literal-value &lt;/a&gt;&lt;a href=&quot;over-clause&quot;&gt;over-clause &lt;/a&gt;&lt;a href=&quot;raise-function&quot;&gt;raise-function &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;type-name&quot;&gt;type-name&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e4a21a32ca632c80e791992375d683d3cb2b152e" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;join-constraint&quot;&gt;join-constraint&lt;/a&gt;&lt;a href=&quot;join-operator&quot;&gt;join-operator&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;join-constraint&quot;&gt;結合制約&lt;/a&gt;&lt;a href=&quot;join-operator&quot;&gt;結合演算子&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;テーブルまたはサブクエリ&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eab2c400e1da9841def91aa5e9939c315ac03195" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;pragma-value&quot;&gt;pragma-value&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;pragma-value&quot;&gt;プラグマ値&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9ba25d3b7bd9b22c410033510c17375ba8fbc355" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1911821b127dd809d42d87c2ae5a010deb04e3f1" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;signed-number&quot;&gt;signed-number&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;signed-number&quot;&gt;符号付き番号&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4105cc2bca5aa3561ea07c37d7a688f2cefa3733" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</source>
          <target state="translated">参照：&lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fee8a9d70903bab5247e1644ccd6676a4cf76b15" translate="yes" xml:space="preserve">
          <source>Regardless of whether or not the instrumented memory allocator is used, SQLite keeps track of how much memory is currently checked out. There are hundreds of test scripts used for testing SQLite. At the end of each script, all objects are destroyed and a test is made to ensure that all memory has been freed. This is how memory leaks are detected. Notice that memory leak detection is in force at all times, during test builds and during production builds. Whenever one of the developers runs any individual test script, memory leak detection is active. Hence memory leaks that do arise during development are quickly detected and fixed.</source>
          <target state="translated">インスツルメンテッド・メモリ・アロケータが使用されているかどうかに関わらず、SQLite は現在どれだけのメモリがチェックアウトされているかを追跡しています。SQLite のテストには何百ものテストスクリプトが使用されています。各スクリプトの最後には、すべてのオブジェクトが破棄され、すべてのメモリが解放されたことを確認するためのテストが行われます。これがメモリリークの検出方法です。メモリリークの検出は、テストビルド中も本番ビルド中も常に行われていることに注意してください。開発者の一人が個別のテストスクリプトを実行すると、いつでもメモリリーク検出が有効になります。したがって、開発中に発生したメモリリークは迅速に検出され、修正されます。</target>
        </trans-unit>
        <trans-unit id="ae990d665eb1948d09faab80d8ea36e2fb369696" translate="yes" xml:space="preserve">
          <source>Regardless of whether or not the limit was changed, the &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit()&lt;/a&gt; interface returns the prior value of the limit. Hence, to find the current value of a limit without changing it, simply invoke this interface with the third parameter set to -1.</source>
          <target state="translated">制限が変更されたかどうかに関係なく、&lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;インターフェースは制限の以前の値を返します。したがって、制限の現在の値を変更せずに見つけるには、3番目のパラメーターを-1に設定してこのインターフェイスを呼び出すだけです。</target>
        </trans-unit>
        <trans-unit id="475dd8379b7144ac8a6fe852e876196470fc7208" translate="yes" xml:space="preserve">
          <source>Regardless of whether or not the limit was changed, the &lt;a href=&quot;limit&quot;&gt;sqlite3_limit()&lt;/a&gt; interface returns the prior value of the limit. Hence, to find the current value of a limit without changing it, simply invoke this interface with the third parameter set to -1.</source>
          <target state="translated">制限が変更されたかどうかに関係なく、&lt;a href=&quot;limit&quot;&gt;sqlite3_limit（）&lt;/a&gt;インターフェースは制限の以前の値を返します。したがって、制限の現在の値を変更せずに見つけるには、3番目のパラメーターを-1に設定してこのインターフェイスを呼び出すだけです。</target>
        </trans-unit>
        <trans-unit id="e9e73aedbb554e1304705d3de0f39389c534343e" translate="yes" xml:space="preserve">
          <source>Regions for custom R*Tree queries are defined by R*Tree geometry callbacks implemented by the application and registered with SQLite via a call to one of the following two APIs:</source>
          <target state="translated">カスタム R*Tree クエリ用のリージョンは、アプリケーションによって実装された R*Tree ジオメトリコールバックによって定義され、以下の 2 つの API のいずれかを呼び出すことで SQLite に登録されます。</target>
        </trans-unit>
        <trans-unit id="16168729e57b855923c7a71a802959676ea3a2be" translate="yes" xml:space="preserve">
          <source>Register A Callback To Handle SQLITE_BUSY Errors</source>
          <target state="translated">SQLITE_BUSY エラーを処理するためのコールバックの登録</target>
        </trans-unit>
        <trans-unit id="d7ada71741a5c5efe7fce5b9acb6e7cf75421e75" translate="yes" xml:space="preserve">
          <source>Register A Virtual Table Implementation</source>
          <target state="translated">仮想テーブルの実装を登録する</target>
        </trans-unit>
        <trans-unit id="958187253e4e67d26cfc6c57d03a7d486067c5db" translate="yes" xml:space="preserve">
          <source>Register P1 must contain an integer. If the content of register P1 is initially greater than zero, then decrement the value in register P1. If it is non-zero (negative or positive) and then also jump to P2. If register P1 is initially zero, leave it unchanged and fall through.</source>
          <target state="translated">レジスタP1は整数を含む必要があります。レジスタP1の内容が最初はゼロより大きい場合は、レジスタP1の値をデクリメントします。ゼロでない場合(負または正)、さらにP2にジャンプします。レジスタP1の内容が最初にゼロであれば、そのままにしてフォールスルーします。</target>
        </trans-unit>
        <trans-unit id="6fc7ce61728bc6135a810d1467e955ec5c18cca5" translate="yes" xml:space="preserve">
          <source>Register P1 must contain an integer. If the value of register P1 is 1 or greater, subtract P3 from the value in P1 and jump to P2.</source>
          <target state="translated">レジスタP1には整数が含まれている必要があります。レジスタP1の値が1以上の場合は、P1の値からP3を引いてP2にジャンプします。</target>
        </trans-unit>
        <trans-unit id="d06710a36a9775573764357fb20e740182e291de" translate="yes" xml:space="preserve">
          <source>Register P1 must hold an integer. Decrement the value in P1 and jump to P2 if the new value is exactly zero.</source>
          <target state="translated">レジスタP1は整数を保持する必要があります。P1の値をデクリメントし、新しい値が正確にゼロの場合はP2にジャンプします。</target>
        </trans-unit>
        <trans-unit id="e5b942ab2eff4aada4b58db13bc65435ed431f02" translate="yes" xml:space="preserve">
          <source>Register P2 holds an SQL index key made using the &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; instructions. This opcode writes that key into the index P1. Data for the entry is nil.</source>
          <target state="translated">レジスタP2は、&lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;命令を使用して作成されたSQLインデックスキーを保持します。このオペコードは、そのキーをインデックスP1に書き込みます。エントリのデータはnilです。</target>
        </trans-unit>
        <trans-unit id="01732db42505a803a66049796c8bf94fe2cae34d" translate="yes" xml:space="preserve">
          <source>Register P2 holds an SQL index key made using the &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; instructions. This opcode writes that key into the sorter P1. Data for the entry is nil.</source>
          <target state="translated">レジスタP2は、&lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;命令を使用して作成されたSQLインデックスキーを保持します。このオペコードは、そのキーをソーターP1に書き込みます。エントリのデータはnilです。</target>
        </trans-unit>
        <trans-unit id="3d2ffa8c9852450209f632158a1e7073fb3dfaaa" translate="yes" xml:space="preserve">
          <source>Register P3 is assumed to hold a 64-bit integer value. If register P1 contains a RowSet object and that RowSet object contains the value held in P3, jump to register P2. Otherwise, insert the integer in P3 into the RowSet and continue on to the next opcode.</source>
          <target state="translated">レジスタP3は64ビットの整数値を保持するものとします。レジスタP1にRowSetオブジェクトが含まれており、そのRowSetオブジェクトにP3に保持されている値が含まれている場合、レジスタP2にジャンプします。そうでない場合は、P3 の整数を RowSet に挿入して次のオペコードに進みます。</target>
        </trans-unit>
        <trans-unit id="bb45c70cacf149749ff353ab480989cee1443045" translate="yes" xml:space="preserve">
          <source>Register P3 is the first of P4 registers that form an unpacked record.</source>
          <target state="translated">レジスタP3は、アンパックされたレコードを形成するレジスタP4の最初のレジスタである。</target>
        </trans-unit>
        <trans-unit id="6b0d004c3926bf5b1daf83fe67dbd02805bbbe04" translate="yes" xml:space="preserve">
          <source>Register any required virtual table modules with the database handle returned by sqlite3rbu_db(X) (where argument X is the sqlite3rbu pointer returned from sqlite3rbu_open()). Also, if required, register the rbu_delta() SQL function using &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function_v2()&lt;/a&gt;.</source>
          <target state="translated">sqlite3rbu_db（X）（引数Xはsqlite3rbu_open（）から返されるsqlite3rbuポインター）によって返されるデータベースハンドルに必要な仮想テーブルモジュールを登録します。また、必要に応じて、使用してrbu_delta（）SQL関数の登録&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function_v2を（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6b1ab59684ecdfa6e23d462a92936dce3e5d8ac7" translate="yes" xml:space="preserve">
          <source>Register the asynchronous IO VFS with SQLite by calling the sqlite3async_initialize() function.</source>
          <target state="translated">sqlite3async_initialize()関数を呼び出して、非同期IO VFSをSQLiteに登録します。</target>
        </trans-unit>
        <trans-unit id="89422a050ade616c86455a9e2dd6f33cb03ad894" translate="yes" xml:space="preserve">
          <source>Register your &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; structure using one of the &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; or &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; interfaces.</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module（）&lt;/a&gt;または&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2（）&lt;/a&gt;インターフェースのいずれかを使用して、&lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt;構造を登録します。</target>
        </trans-unit>
        <trans-unit id="27c9b460c397ef5be790575add8647f1cec36dca" translate="yes" xml:space="preserve">
          <source>Registered sqlite3_vfs objects are kept on a linked list formed by the pNext pointer. The &lt;a href=&quot;#sqlite3_vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_vfs_find&quot;&gt;sqlite3_vfs_unregister()&lt;/a&gt; interfaces manage this list in a thread-safe way. The &lt;a href=&quot;#sqlite3_vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; interface searches the list. Neither the application code nor the VFS implementation should use the pNext pointer.</source>
          <target state="translated">登録されたsqlite3_vfsオブジェクトは、pNextポインタによって形成されるリンクリストに保持されます。&lt;a href=&quot;#sqlite3_vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;と&lt;a href=&quot;#sqlite3_vfs_find&quot;&gt;sqlite3_vfs_unregister（）&lt;/a&gt;インターフェースは、スレッドセーフな方法でこのリストを管理します。&lt;a href=&quot;#sqlite3_vfs_find&quot;&gt;sqlite3_vfs_find（）&lt;/a&gt;インタフェースは、リストを検索します。アプリケーションコードもVFS実装もpNextポインタを使用しないでください。</target>
        </trans-unit>
        <trans-unit id="de4afbb05497a501a0da1ff3e255c9bea23038bf" translate="yes" xml:space="preserve">
          <source>Registered sqlite3_vfs objects are kept on a linked list formed by the pNext pointer. The &lt;a href=&quot;vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; and &lt;a href=&quot;vfs_find&quot;&gt;sqlite3_vfs_unregister()&lt;/a&gt; interfaces manage this list in a thread-safe way. The &lt;a href=&quot;vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; interface searches the list. Neither the application code nor the VFS implementation should use the pNext pointer.</source>
          <target state="translated">登録されたsqlite3_vfsオブジェクトは、pNextポインタによって形成されるリンクリストに保持されます。&lt;a href=&quot;vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;と&lt;a href=&quot;vfs_find&quot;&gt;sqlite3_vfs_unregister（）&lt;/a&gt;インターフェースは、スレッドセーフな方法でこのリストを管理します。&lt;a href=&quot;vfs_find&quot;&gt;sqlite3_vfs_find（）&lt;/a&gt;インタフェースは、リストを検索します。アプリケーションコードもVFS実装もpNextポインタを使用しないでください。</target>
        </trans-unit>
        <trans-unit id="9a5c1b8d7536fe55fb50a507d2ffb4e2ef3d6e66" translate="yes" xml:space="preserve">
          <source>Registering a NULL function disables the callback.</source>
          <target state="translated">NULL関数を登録すると、コールバックが無効になります。</target>
        </trans-unit>
        <trans-unit id="7e5b14172bb50385ea604b908cd56b4ced0181ef" translate="yes" xml:space="preserve">
          <source>Registering a new FTS tokenizer is similar to registering a new virtual table module with SQLite. The user passes a pointer to a structure containing pointers to various callback functions that make up the implementation of the new tokenizer type. For tokenizers, the structure (defined in fts3_tokenizer.h) is called &quot;sqlite3_tokenizer_module&quot;.</source>
          <target state="translated">新しい FTS トークンナイザの登録は、SQLite で新しい仮想テーブルモジュールを登録するのと似ています。ユーザーは、新しいトークナイザー型の実装を構成する様々なコールバック関数へのポインタを含む構造体へのポインタを渡す。トークンizerの場合、構造体(fts3_tokenizer.hで定義されている)は &quot;sqlite3_tokenizer_module &quot;と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="b0c19399b5563dfe1fd2d9520239e189e1da88bf" translate="yes" xml:space="preserve">
          <source>Registers are numbered beginning with 0. Most opcodes refer to at least one register.</source>
          <target state="translated">レジスタには 0 から始まる番号が付けられています。 ほとんどのオペコードは少なくとも 1 つのレジスタを参照しています。</target>
        </trans-unit>
        <trans-unit id="3416ca847c2f3fcac36ca80a6aa453bda2a4a879" translate="yes" xml:space="preserve">
          <source>Regression tests</source>
          <target state="translated">回帰テスト</target>
        </trans-unit>
        <trans-unit id="d3a13cdc6fea5f8b0f17f86149a799a401cfa954" translate="yes" xml:space="preserve">
          <source>Reimplemented the memory allocation subsystem and made it replaceable at compile-time.</source>
          <target state="translated">メモリ割り当てサブシステムを再実装し、コンパイル時に置き換えることができるようにしました。</target>
        </trans-unit>
        <trans-unit id="7c51b2c09a7ac00c32d5f5b60d5cc13c023b651f" translate="yes" xml:space="preserve">
          <source>Reinstate performance improvements that were added in &lt;a href=&quot;#version_3_3_14&quot;&gt;Version 3.3.14&lt;/a&gt; but regressed in &lt;a href=&quot;#version_3_3_15&quot;&gt;Version 3.3.15&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#version_3_3_14&quot;&gt;バージョン3.3.14で&lt;/a&gt;追加されたが、バージョン3.3.15で低下したパフォーマンスの改善を&lt;a href=&quot;#version_3_3_15&quot;&gt;元に戻し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="3011dfada1ebc527f6c1a610c58b9f9d0286fe3f" translate="yes" xml:space="preserve">
          <source>Related to C-API requirements:</source>
          <target state="translated">C-APIの要件に関連しています。</target>
        </trans-unit>
        <trans-unit id="4e090a454ee61aaf3f58e28631cff8999e93331b" translate="yes" xml:space="preserve">
          <source>Related to SQL requirements:</source>
          <target state="translated">SQLの要件に関連しています。</target>
        </trans-unit>
        <trans-unit id="3eb999525849eac11552ac3098daf2b69f5321b3" translate="yes" xml:space="preserve">
          <source>Related to file-format requirements:</source>
          <target state="translated">ファイル形式の要件に関連しています。</target>
        </trans-unit>
        <trans-unit id="8f24d23adbf6898f82e865e9f816b7bd6e3ba106" translate="yes" xml:space="preserve">
          <source>Relational database engines act as bandwidth-reducing data filters. So it is best to keep the database engine and the data on the same physical device so that the high-bandwidth engine-to-disk link does not have to traverse the network, only the lower-bandwidth application-to-engine link.</source>
          <target state="translated">リレーショナルデータベースエンジンは、帯域幅を削減するデータフィルタとして機能します。そのため、データベースエンジンとデータを同じ物理デバイス上に置いておくのがベストです。</target>
        </trans-unit>
        <trans-unit id="720fa9e6ba7dd17be077bf0b4c2393be699b32bc" translate="yes" xml:space="preserve">
          <source>Relationship to Other Documents</source>
          <target state="translated">その他の書類との関係</target>
        </trans-unit>
        <trans-unit id="910fe0ebb846d769acb1f768f3b350b52b7c87fa" translate="yes" xml:space="preserve">
          <source>Relax the SQL statement length restriction in the CLI so that the &quot;.dump&quot; output of databases with very large BLOBs and strings can be played back to recreate the database.</source>
          <target state="translated">CLIでSQL文の長さ制限を緩和し、非常に大きなBLOBや文字列を持つデータベースの&quot;.dump &quot;出力を再生してデータベースを再作成できるようにしました。</target>
        </trans-unit>
        <trans-unit id="d41f56cea1ac933d25c57aebc6522e2b6c58eb87" translate="yes" xml:space="preserve">
          <source>Release</source>
          <target state="translated">Release</target>
        </trans-unit>
        <trans-unit id="3f453891a8b048016ad785ded9267d527fc4c217" translate="yes" xml:space="preserve">
          <source>Release History</source>
          <target state="translated">リリース履歴</target>
        </trans-unit>
        <trans-unit id="b5d6e335495f80d39d703350d3e97ffdb93dd6dd" translate="yes" xml:space="preserve">
          <source>Release History Of SQLite</source>
          <target state="translated">SQLiteのリリース履歴</target>
        </trans-unit>
        <trans-unit id="059948eaf49ab1f91af7a1724f1325548609c407" translate="yes" xml:space="preserve">
          <source>Release registers from service. Any content that was in the the registers is unreliable after this opcode completes.</source>
          <target state="translated">サービスからレジスタを解放してください。このオペコードが完了した後、レジスタにあった内容は信頼できなくなります。</target>
        </trans-unit>
        <trans-unit id="f91d8788ccb8580c59f2957385adedb96f9eebdb" translate="yes" xml:space="preserve">
          <source>Release testing proceeds by &lt;a href=&quot;testing#cklist&quot;&gt;checklist&lt;/a&gt;. The current status and complete change history for each checklist is stored in a separate SQLite database file. These files are not version controlled, but separate copies are maintained on private backup servers.</source>
          <target state="translated">リリーステストは&lt;a href=&quot;testing#cklist&quot;&gt;チェックリストごとに&lt;/a&gt;進行します。各チェックリストの現在のステータスと完全な変更履歴は、個別のSQLiteデータベースファイルに保存されます。これらのファイルはバージョン管理されていませんが、個別のコピーがプライベートバックアップサーバーに保持されています。</target>
        </trans-unit>
        <trans-unit id="d39cd2c52497ee84030ad057906e4ab9e12677f2" translate="yes" xml:space="preserve">
          <source>ReleaseReg</source>
          <target state="translated">ReleaseReg</target>
        </trans-unit>
        <trans-unit id="68bd446f9608234bde9262049ecc13307a217604" translate="yes" xml:space="preserve">
          <source>Releases the mutex.</source>
          <target state="translated">ミューテックスを解放します。</target>
        </trans-unit>
        <trans-unit id="093e4161a9fbb2d3df1b7e1618ac6472d6ffad88" translate="yes" xml:space="preserve">
          <source>Releasing a register clears the Mem.pScopyFrom pointer. That means that if the content of the released register was set using &lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt;, a change to the value of the source register for the &lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt; will no longer generate an assertion fault in sqlite3VdbeMemAboutToChange().</source>
          <target state="translated">レジスタを解放すると、Mem.pScopyFromポインタがクリアされます。つまり、その放出されたレジスタの内容を使用して設定された場合&lt;a href=&quot;opcode#SCopy&quot;&gt;SCOPY&lt;/a&gt;、ソースレジスタの値に変更&lt;a href=&quot;opcode#SCopy&quot;&gt;SCOPYを&lt;/a&gt;もはやsqlite3VdbeMemAboutToChangeでアサーション障害が発生しません（）。</target>
        </trans-unit>
        <trans-unit id="9e7fb42133185287484ac33cdd16d16a32e9573a" translate="yes" xml:space="preserve">
          <source>Relieve the poor.</source>
          <target state="translated">貧乏人を解放してください。</target>
        </trans-unit>
        <trans-unit id="c129618e6f09666fc71019f6f11ca49c584723bd" translate="yes" xml:space="preserve">
          <source>Relinquish the shared lock on the database file obtained in step 1.</source>
          <target state="translated">手順1で取得したデータベースファイルの共有ロックを解除します。</target>
        </trans-unit>
        <trans-unit id="c20a1017faea096d3f06199fd35a9c0037bfb227" translate="yes" xml:space="preserve">
          <source>Remainder</source>
          <target state="translated">Remainder</target>
        </trans-unit>
        <trans-unit id="d7020f448aaf8aacc8b4d63537e375e865fff9d8" translate="yes" xml:space="preserve">
          <source>Remarks</source>
          <target state="translated">Remarks</target>
        </trans-unit>
        <trans-unit id="f818b7fc01e1b4eb78ea0d60ac974d5efb37d086" translate="yes" xml:space="preserve">
          <source>Remember that every table (except sqlite_master) and every named index has an entry in the sqlite_master table. Since we are creating a new index, we have to add a new entry to sqlite_master. This is handled by instructions 3 through 15. Adding an entry to sqlite_master works just like any other INSERT statement so we will not say any more about it here. In this example, we want to focus on populating the new index with valid data, which happens on instructions 16 through 23.</source>
          <target state="translated">すべてのテーブル(sqlite_masterを除く)と名前付きインデックスはsqlite_masterテーブルにエントリを持っていることを覚えておいてください。新しいインデックスを作成しているので、sqlite_masterに新しいエントリを追加しなければなりません。これは命令3から15で処理されます。sqlite_masterへのエントリの追加は、他のINSERT文と同じように動作しますので、ここではこれ以上説明しません。この例では、新しいインデックスに有効なデータを追加することに焦点を当てたいと思います。</target>
        </trans-unit>
        <trans-unit id="69897e6a01044562fef92617e584bcaf82e348ea" translate="yes" xml:space="preserve">
          <source>Remember that the names and meanings of opcodes often change from one release of SQLite to the next. So if you are studying the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; output from SQLite, you should reference the version of this document (or the vdbe.c source code) that corresponds to the version of SQLite that ran the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;. Otherwise, the description of the opcodes may not be accurate. This document is derived from SQLite version 3.30.1 check-in &lt;a href=&quot;https://www.sqlite.org/src/timeline?c=18db032d058f1&quot;&gt;18db032d058f1&lt;/a&gt; dated 2019-10-10.</source>
          <target state="translated">オペコードの名前と意味は、SQLiteのリリースごとに変更されることが多いことを覚えておいてください。したがって、SQLiteからの&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;出力を調べる場合は、&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;を実行したSQLiteのバージョンに対応するこのドキュメントのバージョン（またはvdbe.cソースコード）を参照する必要があります。そうしないと、オペコードの説明が正確にならない場合があります。このドキュメントは、&lt;a href=&quot;https://www.sqlite.org/src/timeline?c=18db032d058f1&quot;&gt;2019-10-10&lt;/a&gt;日付のSQLiteバージョン3.30.1チェックイン18db032d058f1から派生しています。</target>
        </trans-unit>
        <trans-unit id="f553d13a1a4a6a005164fe968cc587aaf66e9b40" translate="yes" xml:space="preserve">
          <source>Remember that the names and meanings of opcodes often change from one release of SQLite to the next. So if you are studying the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; output from SQLite, you should reference the version of this document (or the vdbe.c source code) that corresponds to the version of SQLite that ran the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;. Otherwise, the description of the opcodes may not be accurate. This document is derived from SQLite version 3.33.0 check-in &lt;a href=&quot;https://www.sqlite.org/src/timeline?c=fca8dc8b578f2&quot;&gt;fca8dc8b578f2&lt;/a&gt; dated 2020-08-14.</source>
          <target state="translated">オペコードの名前と意味は、SQLiteのリリースごとに変わることが多いことを忘れないでください。あなたが勉強しているのであれば&lt;a href=&quot;lang_explain&quot;&gt;、EXPLAIN&lt;/a&gt; SQLiteのからの出力を、あなたは走ったのSQLiteのバージョンに対応していることを、この文書（またはvdbe.cソースコード）のバージョンを参照する必要があり&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;。そうしないと、オペコードの説明が正確でない可能性があります。このドキュメントは、&lt;a href=&quot;https://www.sqlite.org/src/timeline?c=fca8dc8b578f2&quot;&gt;2020&lt;/a&gt;年8月14日付けのSQLiteバージョン3.33.0チェックインfca8dc8b578f2から派生しています。</target>
        </trans-unit>
        <trans-unit id="6eb5f044eeebb740c044069cc0a1760dfcfed869" translate="yes" xml:space="preserve">
          <source>Remember the format of all indexes, triggers, and views associated with table X. This information will be needed in step 8 below. One way to do this is to run a query like the following: SELECT type, sql FROM sqlite_master WHERE tbl_name='X'.</source>
          <target state="translated">テーブルXに関連付けられたすべてのインデックス、トリガ、およびビューのフォーマットを覚えておいてください。これを行う1つの方法は、以下のようなクエリを実行することです。SELECT type,sql FROM sqlite_master WHERE tbl_name='X'.</target>
        </trans-unit>
        <trans-unit id="96ba241fe10cc7a94246b3ba48e08be55ea73559" translate="yes" xml:space="preserve">
          <source>Remember the format of all indexes, triggers, and views associated with table X. This information will be needed in step 8 below. One way to do this is to run a query like the following: SELECT type, sql FROM sqlite_schema WHERE tbl_name='X'.</source>
          <target state="translated">テーブルXに関連付けられたすべてのインデックス、トリガ、およびビューのフォーマットを覚えておいてください。これを行う1つの方法は、以下のようなクエリを実行することです。SELECT type,sql FROM sqlite_schema WHERE tbl_name='X'.</target>
        </trans-unit>
        <trans-unit id="7697dd70c220c16d6cd40cffcf6ebbe938ec6d8c" translate="yes" xml:space="preserve">
          <source>Remember: The VDBE opcodes are &lt;u&gt;not&lt;/u&gt; part of the interface definition for SQLite. The number of opcodes and their names and meanings change from one release of SQLite to the next. The opcodes shown in the table below are valid for SQLite version 3.30.1 check-in &lt;a href=&quot;https://www.sqlite.org/src/timeline?c=18db032d058f1&quot;&gt;18db032d058f1&lt;/a&gt; dated 2019-10-10.</source>
          <target state="translated">注意：VDBEオペコードはSQLiteのインターフェース定義の一部ではあり&lt;u&gt;ません&lt;/u&gt;。オペコードの数とその名前および意味は、SQLiteのリリースごとに異なります。以下の表に示すオペコードは、&lt;a href=&quot;https://www.sqlite.org/src/timeline?c=18db032d058f1&quot;&gt;2019-10-10&lt;/a&gt;日付のSQLiteバージョン3.30.1チェックイン18db032d058f1に有効です。</target>
        </trans-unit>
        <trans-unit id="0cf1bdb8435fa5c7b1a229b2efb579581c575742" translate="yes" xml:space="preserve">
          <source>Remember: The VDBE opcodes are &lt;u&gt;not&lt;/u&gt; part of the interface definition for SQLite. The number of opcodes and their names and meanings change from one release of SQLite to the next. The opcodes shown in the table below are valid for SQLite version 3.33.0 check-in &lt;a href=&quot;https://www.sqlite.org/src/timeline?c=fca8dc8b578f2&quot;&gt;fca8dc8b578f2&lt;/a&gt; dated 2020-08-14.</source>
          <target state="translated">注意：VDBEオペコードはSQLiteのインターフェース定義の一部ではあり&lt;u&gt;ません&lt;/u&gt;。オペコードの数とその名前および意味は、SQLiteのリリースごとに異なります。以下の表に示されているオペコードは、&lt;a href=&quot;https://www.sqlite.org/src/timeline?c=fca8dc8b578f2&quot;&gt;2020&lt;/a&gt;年8月14日付けのSQLiteバージョン3.33.0チェックインfca8dc8b578f2で有効です。</target>
        </trans-unit>
        <trans-unit id="ad8914d260e2d26c0f65a1244263c5ebd74ffa40" translate="yes" xml:space="preserve">
          <source>Removals occurs sequentially from left to right. Changes caused by prior removals can affect the path search for subsequent arguments.</source>
          <target state="translated">削除は左から順に行われます。先に削除されたことによる変更は、後続の引数のパス検索に影響を与える可能性があります。</target>
        </trans-unit>
        <trans-unit id="911efbaa270338e46274d0437cfd895711d3b921" translate="yes" xml:space="preserve">
          <source>Remove Unnecessary Virtual Table Implementations</source>
          <target state="translated">不要な仮想テーブルの実装を削除する</target>
        </trans-unit>
        <trans-unit id="e2ba27377e47e450dcae92850eed494633ee561a" translate="yes" xml:space="preserve">
          <source>Remove a call to rand_s() in the Windows VFS since it was causing problems in Firefox on some older laptops.</source>
          <target state="translated">Windows VFS の rand_s()の呼び出しが古いノートパソコンの Firefox で問題を起こしていたので削除。</target>
        </trans-unit>
        <trans-unit id="de2c1add2fd3544da9609574c31dec164859c5a6" translate="yes" xml:space="preserve">
          <source>Remove a surplus semicolon that was causing problems for older versions of MSVC.</source>
          <target state="translated">古いバージョンのMSVCで問題となっていた余剰のセミコロンを削除しました。</target>
        </trans-unit>
        <trans-unit id="d1a5392ba748cb8c4dacc7b44e730fc30161dbb4" translate="yes" xml:space="preserve">
          <source>Remove all instances of sprintf() from the code</source>
          <target state="translated">コードから sprintf()のインスタンスをすべて削除します。</target>
        </trans-unit>
        <trans-unit id="a7347e37ad5bb38746524ddb0e6ffca369e7fc25" translate="yes" xml:space="preserve">
          <source>Remove all uses of umask() in the unix VFS.</source>
          <target state="translated">unix VFS の umask()の使用をすべて削除します。</target>
        </trans-unit>
        <trans-unit id="e9a7875d6c4fd8a037f45ad1e5ae66d9676a5804" translate="yes" xml:space="preserve">
          <source>Remove cruft from the APIs.</source>
          <target state="translated">API から cruft を削除します。</target>
        </trans-unit>
        <trans-unit id="1b6d6e3634ac9d3666b932168ce6ff89f16adfc2" translate="yes" xml:space="preserve">
          <source>Remove limits on the magnitude of precision and width value in the format specifiers of the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; family of string rendering routines.</source>
          <target state="translated">文字列レンダリングルーチンの&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;ファミリのフォーマット指定子で、精度の大きさと幅の値の制限を削除します。</target>
        </trans-unit>
        <trans-unit id="232f2fe0e5dd49ef4b04602d08b8943e14a7d142" translate="yes" xml:space="preserve">
          <source>Remove some C++ style comments from btree.c so that it will compile using compilers other than gcc.</source>
          <target state="translated">gcc以外のコンパイラでもコンパイルできるように、btree.cからC++スタイルのコメントを削除しました。</target>
        </trans-unit>
        <trans-unit id="f2e07b9153ec780a2a1b29629bb1d3f64a20239f" translate="yes" xml:space="preserve">
          <source>Remove the &lt;b&gt;sqlite_encoding&lt;/b&gt; TCL variable that was introduced in the previous version.</source>
          <target state="translated">以前のバージョンで導入された&lt;b&gt;sqlite_encoding&lt;/b&gt; TCL変数を削除します。</target>
        </trans-unit>
        <trans-unit id="2b21568b3fad30533d945c9f60e6bb04786d29af" translate="yes" xml:space="preserve">
          <source>Remove the internal (in-memory) data structures that describe the index named P4 in database P1. This is called after an index is dropped from disk (using the &lt;a href=&quot;opcode#Destroy&quot;&gt;Destroy&lt;/a&gt; opcode) in order to keep the internal representation of the schema consistent with what is on disk.</source>
          <target state="translated">データベースP1のP4という名前のインデックスを記述する内部（メモリ内）データ構造を削除します。これは、スキーマの内部表現をディスク上の内容と一致させるために、（&lt;a href=&quot;opcode#Destroy&quot;&gt;Destroy&lt;/a&gt;オペコードを使用して）インデックスがディスクから削除された後に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="36574b14e4fba42639d51b715dd56510bbbe9bbe" translate="yes" xml:space="preserve">
          <source>Remove the internal (in-memory) data structures that describe the table named P4 in database P1. This is called after a table is dropped from disk (using the &lt;a href=&quot;opcode#Destroy&quot;&gt;Destroy&lt;/a&gt; opcode) in order to keep the internal representation of the schema consistent with what is on disk.</source>
          <target state="translated">データベースP1のP4という名前のテーブルを記述する内部（メモリ内）データ構造を削除します。これは、ディスクの内容とスキーマの内部表現を一致させるために、テーブルが（&lt;a href=&quot;opcode#Destroy&quot;&gt;Destroy&lt;/a&gt;オペコードを使用して）ディスクから削除された後に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="a2ee755d70dfde8b6acc7bc963a2c09e0d856e3d" translate="yes" xml:space="preserve">
          <source>Remove the internal (in-memory) data structures that describe the trigger named P4 in database P1. This is called after a trigger is dropped from disk (using the &lt;a href=&quot;opcode#Destroy&quot;&gt;Destroy&lt;/a&gt; opcode) in order to keep the internal representation of the schema consistent with what is on disk.</source>
          <target state="translated">データベースP1のP4という名前のトリガーを記述する内部（メモリ内）データ構造を削除します。これは、ディスクの内容とスキーマの内部表現を一致させるために、トリガーがディスクから削除された後に（&lt;a href=&quot;opcode#Destroy&quot;&gt;Destroy&lt;/a&gt;オペコードを使用して）呼び出されます。</target>
        </trans-unit>
        <trans-unit id="4bdb98bb814d00a40fac7a5bc5a53816ed8a4fe3" translate="yes" xml:space="preserve">
          <source>Remove the limit (formerly 100) on the number of terms in the WHERE clause</source>
          <target state="translated">WHERE句の用語数の制限(以前は100)を撤廃する</target>
        </trans-unit>
        <trans-unit id="6c2cfa3751933f72373c8446091ad7cbfc829e90" translate="yes" xml:space="preserve">
          <source>Remove the rarely-used &quot;scratch&quot; memory allocator. Replace it with the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsmallmalloc&quot;&gt;SQLITE_CONFIG_SMALL_MALLOC&lt;/a&gt; configuration setting that gives SQLite a hint that large memory allocations should be avoided when possible.</source>
          <target state="translated">まれに使用される「スクラッチ」メモリアロケータを削除します。これを&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsmallmalloc&quot;&gt;SQLITE_CONFIG_SMALL_MALLOC&lt;/a&gt;構成設定に置き換えます。これにより、SQLiteに、可能な場合は大量のメモリ割り当てを回避する必要があるというヒントが与えられます。</target>
        </trans-unit>
        <trans-unit id="f76d7af1679885a7bfe9d24b6ffde8997604493f" translate="yes" xml:space="preserve">
          <source>Remove the restriction on &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; and &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;. Virtual tables and shared cache can now be used at the same time.</source>
          <target state="translated">&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;と&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュモード&lt;/a&gt;の制限を削除します。仮想テーブルと共有キャッシュを同時に使用できるようになりました。</target>
        </trans-unit>
        <trans-unit id="0f161850d96f27ed56876982a84f7c1b8a07321a" translate="yes" xml:space="preserve">
          <source>Remove the use of strcasecmp() from the shell</source>
          <target state="translated">シェルから strcasecmp()の使用を削除します。</target>
        </trans-unit>
        <trans-unit id="b82adca5a3d606350246be926940c7079f564580" translate="yes" xml:space="preserve">
          <source>Removed a few variables that were not being used. Etc.</source>
          <target state="translated">使用していなかったいくつかの変数を削除しました。などを削除しました。</target>
        </trans-unit>
        <trans-unit id="ce23c20d6612496d01f2695dbdf3e159dffac5f1" translate="yes" xml:space="preserve">
          <source>Removed all instances of sprintf() and strcpy() from the core library.</source>
          <target state="translated">コアライブラリから sprintf()と strcpy()のインスタンスをすべて削除しました。</target>
        </trans-unit>
        <trans-unit id="1cae4989947b35c7db5ba36e62fdeec64147115e" translate="yes" xml:space="preserve">
          <source>Removed encode.c file (containing unused routines) from the version 3.0 source tree.</source>
          <target state="translated">バージョン 3.0 のソースツリーから encode.c ファイル (未使用のルーチンを含む)を削除しました。</target>
        </trans-unit>
        <trans-unit id="57859e1d20dcbe4d104c0ddc713636157aa93b7b" translate="yes" xml:space="preserve">
          <source>Removed some unused &quot;#include</source>
          <target state="translated">未使用の &quot;#include &quot;を削除しました。</target>
        </trans-unit>
        <trans-unit id="8d2a9960e30e515570aed5ad791fda0cf2ff5231" translate="yes" xml:space="preserve">
          <source>Removed support for &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt;, replacing it with the much more capable &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; option.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2の&lt;/a&gt;サポートを削除し、より優れた&lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt;オプションに置き換えました。</target>
        </trans-unit>
        <trans-unit id="65be623270aae4b13c60984d581079005860c71c" translate="yes" xml:space="preserve">
          <source>Removed support for an ON CONFLICT clause on CREATE INDEX - it never worked correctly so this should not present any backward compatibility problems.</source>
          <target state="translated">CREATE INDEXでのON CONFLICT句のサポートを削除しました。</target>
        </trans-unit>
        <trans-unit id="ba2329a69fcada7cfc55496da4a2c7aa1027255b" translate="yes" xml:space="preserve">
          <source>Removed support for the Oracle8 outer join syntax.</source>
          <target state="translated">Oracle8の外部結合構文のサポートを削除しました。</target>
        </trans-unit>
        <trans-unit id="29a877d4bc4a615404fe28f15ef25cea333f3dfb" translate="yes" xml:space="preserve">
          <source>Removed the experimental sqlite_open_aux_file(). Its function is subsumed in the new ATTACH command.</source>
          <target state="translated">実験的なsqlite_open_aux_file()を削除しました。その関数は新しいATTACHコマンドに含まれています。</target>
        </trans-unit>
        <trans-unit id="d84a5c2bd6c237fcc154859882d3b6c252699015" translate="yes" xml:space="preserve">
          <source>Removed the vestigal SQLITE_PROTOCOL error.</source>
          <target state="translated">vestigal SQLITE_PROTOCOL エラーを削除しました。</target>
        </trans-unit>
        <trans-unit id="eace5c7b4ff6a4702d4283d3160c8d68a2dcede9" translate="yes" xml:space="preserve">
          <source>Rename column</source>
          <target state="translated">カラム名の変更</target>
        </trans-unit>
        <trans-unit id="23dbd5b69dca406be177f26a10ac454eda104e75" translate="yes" xml:space="preserve">
          <source>Rename new into old</source>
          <target state="translated">新しい名前を古い名前に変更</target>
        </trans-unit>
        <trans-unit id="5bd4049b4d784a22b055fc8e5f3c3684061c5d9c" translate="yes" xml:space="preserve">
          <source>Rename old table</source>
          <target state="translated">古いテーブルの名前を変更</target>
        </trans-unit>
        <trans-unit id="c9a739b6bb3de7aee85aef1cd51db485f31caf22" translate="yes" xml:space="preserve">
          <source>Rename table</source>
          <target state="translated">テーブル名の変更</target>
        </trans-unit>
        <trans-unit id="a6f163085aea45df98f42b1c1ebd60597433d37a" translate="yes" xml:space="preserve">
          <source>Rename the &lt;a href=&quot;compile#omit_builtin_test&quot;&gt;SQLITE_OMIT_BUILTIN_TEST&lt;/a&gt; compile-time option to &lt;a href=&quot;compile#untestable&quot;&gt;SQLITE_UNTESTABLE&lt;/a&gt; to better reflect the implications of using it.</source>
          <target state="translated">&lt;a href=&quot;compile#omit_builtin_test&quot;&gt;SQLITE_OMIT_BUILTIN_TEST&lt;/a&gt;コンパイル時オプションの名前を&lt;a href=&quot;compile#untestable&quot;&gt;SQLITE_UNTESTABLE&lt;/a&gt;に変更して、使用の影響をより適切に反映します。</target>
        </trans-unit>
        <trans-unit id="be5b8fd29874b31a75967598563d2c598ed8c802" translate="yes" xml:space="preserve">
          <source>Render expressions of the form &quot;x IN (?)&quot; (with a single value in the list on the right-hand side of the IN operator) as if they where &quot;x==?&quot;, Similarly optimize &quot;x NOT IN (?)&quot;</source>
          <target state="translated">x IN (?)」という形式の式を、あたかも「x==?&quot;」であるかのように(IN演算子の右側にあるリストの中に値が1つある)レンダリングします。</target>
        </trans-unit>
        <trans-unit id="88333a43b7fd427d0516f0a5d5107e5f54e545df" translate="yes" xml:space="preserve">
          <source>ReopenIdx</source>
          <target state="translated">ReopenIdx</target>
        </trans-unit>
        <trans-unit id="7c28d43c9fc88003b6477ed308834ef4aec930a4" translate="yes" xml:space="preserve">
          <source>Reorganize the Unix interface in os_unix.c</source>
          <target state="translated">os_unix.c の Unix インターフェースを再編成します。</target>
        </trans-unit>
        <trans-unit id="4b096fbd5cf8040410b520d0087755f15a4e4623" translate="yes" xml:space="preserve">
          <source>Repeatedly switching an SQLite database in and out of &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; and running the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command in between switches, in one process or thread, can cause another process or thread that has the database file open to miss the fact that the database has changed. That second process or thread might then try to modify the database using a stale cache and cause database corruption.</source>
          <target state="translated">1つのプロセスまたはスレッドで、SQLiteデータベースを&lt;a href=&quot;wal&quot;&gt;WALモードに切り替え&lt;/a&gt;たり、WALモードから切り替えたりして、スイッチ間で&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;コマンドを実行すると、データベースファイルが開いている別のプロセスまたはスレッドが、データベースが変更されたという事実を見失う可能性があります。その2番目のプロセスまたはスレッドは、古いキャッシュを使用してデータベースを変更しようとし、データベースの破損を引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="08d1902d969043d4f5ff76c612c66edc344a58a0" translate="yes" xml:space="preserve">
          <source>Replace the built-in mutex subsystem with an alternative implementation.</source>
          <target state="translated">組み込みのミューテックスサブシステムを代替の実装に置き換えます。</target>
        </trans-unit>
        <trans-unit id="6fd04b040e5c22cd85b1871575a876977a443534" translate="yes" xml:space="preserve">
          <source>Replace the interface to the file system with an alternative design. In other words, override all of the system calls that SQLite makes in order to talk to the disk with a completely different set of system calls.</source>
          <target state="translated">ファイルシステムへのインターフェイスを別のデザインに置き換えます。言い換えれば、全く異なるシステムコールのセットでディスクと対話するために、SQLite が行うシステムコールをすべてオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="8a67a8b071dbf97af58f9f8fc030dc4129a982a5" translate="yes" xml:space="preserve">
          <source>Report an error if an ORDER BY or GROUP BY expression is constant.</source>
          <target state="translated">ORDER BY式またはGROUP BY式が定数の場合、エラーを報告します。</target>
        </trans-unit>
        <trans-unit id="5382d03ec82f0e424f0e2bcd884c37beaa553f16" translate="yes" xml:space="preserve">
          <source>Report rollback recovery in the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; as SQLITE_NOTICE_RECOVER_ROLLBACK. Change the error log code for WAL recover from SQLITE_OK to SQLITE_NOTICE_RECOVER_WAL.</source>
          <target state="translated">&lt;a href=&quot;errlog&quot;&gt;エラーログ&lt;/a&gt;でロールバック回復をSQLITE_NOTICE_RECOVER_ROLLBACKとして報告します。WALリカバリのエラーログコードをSQLITE_OKからSQLITE_NOTICE_RECOVER_WALに変更します。</target>
        </trans-unit>
        <trans-unit id="2a209e68ce6d7ef5cbfce6e23fd387511ef2796d" translate="yes" xml:space="preserve">
          <source>Report the name of specific &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt; constraints that fail.</source>
          <target state="translated">失敗した特定の&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt;制約の名前を報告します。</target>
        </trans-unit>
        <trans-unit id="1b12d49166f15edffd3aeb0179e7e1787f48ce27" translate="yes" xml:space="preserve">
          <source>Report the risky uses of &lt;a href=&quot;howtocorrupt#unlink&quot;&gt;unlinked database files&lt;/a&gt; and &lt;a href=&quot;howtocorrupt#alias&quot;&gt;database filename aliasing&lt;/a&gt; as SQLITE_WARNING messages in the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;howtocorrupt#unlink&quot;&gt;リンクされていないデータベースファイル&lt;/a&gt;と&lt;a href=&quot;howtocorrupt#alias&quot;&gt;データベースファイル名のエイリアス&lt;/a&gt;の危険な使用をSQLITE_WARNINGメッセージとして&lt;a href=&quot;errlog&quot;&gt;エラーログに&lt;/a&gt;報告します。</target>
        </trans-unit>
        <trans-unit id="a328f2c4ddffb4f007ee170c822e792cbe7ac2bd" translate="yes" xml:space="preserve">
          <source>Reposition cursor P1 so that it points to the largest entry that is less than or equal to the key value. If there are no records less than or equal to the key and P2 is not zero, then jump to P2.</source>
          <target state="translated">カーソルP1をキー値以下の最大のエントリを指すように再配置します。キー以下のレコードがなく、P2が0でない場合は、P2にジャンプします。</target>
        </trans-unit>
        <trans-unit id="3135b4b4b6f2ab789efbcd1b22f24612c3f91745" translate="yes" xml:space="preserve">
          <source>Reposition cursor P1 so that it points to the largest entry that is less than the key value. If there are no records less than the key and P2 is not zero, then jump to P2.</source>
          <target state="translated">カーソルP1を、キー値よりも小さい最大のエントリを指すように再配置します。キーより小さいレコードがなく、P2が0でない場合は、P2にジャンプします。</target>
        </trans-unit>
        <trans-unit id="0ecdc43c68575ffe0f6b403b40297cdd23849385" translate="yes" xml:space="preserve">
          <source>Reposition cursor P1 so that it points to the smallest entry that is greater than or equal to the key value. If there are no records greater than or equal to the key and P2 is not zero, then jump to P2.</source>
          <target state="translated">カーソルP1がキー値以上の最小のエントリを指すように、カーソルP1を再配置します。キー以上のレコードがなく、P2が0でない場合は、P2にジャンプします。</target>
        </trans-unit>
        <trans-unit id="12d5076757ddc1b93a63854acae2fbdea1746c5f" translate="yes" xml:space="preserve">
          <source>Reposition cursor P1 so that it points to the smallest entry that is greater than the key value. If there are no records greater than the key and P2 is not zero, then jump to P2.</source>
          <target state="translated">カーソルP1をキー値よりも大きい最小のエントリを指すように再配置します。キーより大きいレコードがなく、P2が0でない場合は、P2にジャンプします。</target>
        </trans-unit>
        <trans-unit id="c029db81bd8f30ac7ba33c5eb9c17a5ae29866f1" translate="yes" xml:space="preserve">
          <source>Represent a &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_(file_format)&quot;&gt;ZIP Archive&lt;/a&gt; as an SQL table. Works for both reading and writing. Used by the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; to implement the ability to read and write ZIP Archives.</source>
          <target state="translated">表す&lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_(file_format)&quot;&gt;ZIPアーカイブを&lt;/a&gt; SQLテーブルとして。読み取りと書き込みの両方で機能します。&lt;a href=&quot;cli&quot;&gt;CLIで&lt;/a&gt;使用され、ZIPアーカイブを読み書きする機能を実装します。</target>
        </trans-unit>
        <trans-unit id="bf10d00bc3da2452de6c68f43ec52e620c1a7872" translate="yes" xml:space="preserve">
          <source>Representation is the essence of computer programming.</source>
          <target state="translated">表現はコンピュータプログラミングの本質です。</target>
        </trans-unit>
        <trans-unit id="1d9b3293e88caaa716c1a885e5b50e65b2bb3b2a" translate="yes" xml:space="preserve">
          <source>Represents the global variables of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Tcl&quot;&gt;TCL Interpreter&lt;/a&gt; as an SQL table. Used as part of the SQLite test suite.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Tcl&quot;&gt;TCLインタープリターの&lt;/a&gt;グローバル変数をSQLテーブルとして表します。SQLiteテストスイートの一部として使用されます。</target>
        </trans-unit>
        <trans-unit id="c26bf60fed3744bb0049608ff95380b842c473a6" translate="yes" xml:space="preserve">
          <source>Requested</source>
          <target state="translated">Requested</target>
        </trans-unit>
        <trans-unit id="dbbf6c568082dd9fe7decc89c41aaaa504df8ded" translate="yes" xml:space="preserve">
          <source>Requirement H35050 (section</source>
          <target state="translated">要件H35050(セクション</target>
        </trans-unit>
        <trans-unit id="4e1bcb3ced4612d53be234208553c503d16c2746" translate="yes" xml:space="preserve">
          <source>Requirements describing how a</source>
          <target state="translated">をどのように記述するかを記述する要件</target>
        </trans-unit>
        <trans-unit id="5472f074118e0fcc2fcc663b98dfc71e267df752" translate="yes" xml:space="preserve">
          <source>Requirements describing step 1 of the above procedure in detail:</source>
          <target state="translated">上記手順のステップ1を詳細に記述した要件</target>
        </trans-unit>
        <trans-unit id="fad7011bc39debdd3199704eacbe43fe1a48d858" translate="yes" xml:space="preserve">
          <source>Requirements describing step 2 of the above procedure in detail:</source>
          <target state="translated">上記手順のステップ2を詳細に記述した要件</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
