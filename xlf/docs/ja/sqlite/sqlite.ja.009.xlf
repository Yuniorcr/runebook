<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="84d99b586ac4808874504752037c1f68b1dc681c" translate="yes" xml:space="preserve">
          <source>If a &quot;truncate file&quot; operation is executed by SQLite, and then the truncated file</source>
          <target state="translated">SQLiteで「ファイルを切り捨てる」操作が実行され、切り捨てられたファイルが</target>
        </trans-unit>
        <trans-unit id="a177cd3b97251df1bda061d91a729d6e25be393e" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../wal#walfile&quot;&gt;WAL file&lt;/a&gt; remains on disk after all database connections close (either through the use of the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;file control&lt;/a&gt; or because the last process to have the database opened exited without calling &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt;) and a new connection is subsequently opened on that database and &lt;a href=&quot;../wal#walfile&quot;&gt;WAL file&lt;/a&gt;, the &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface will only be able to open the last transaction added to the WAL file even though the WAL file contains other valid transactions.</source>
          <target state="translated">場合&lt;a href=&quot;../wal#walfile&quot;&gt;WALファイル&lt;/a&gt;をすべて閉じデータベース接続後にディスク上に残っている（いずれかを使用して&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WALの&lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;ファイル制御&lt;/a&gt;データベースを持っているか、最後のプロセス理由を呼び出さずに終了した開かれた&lt;a href=&quot;close&quot;&gt;sqlite3_close（）&lt;/a&gt;と新しい接続を）、その後、そのデータベースに開かれ、&lt;a href=&quot;../wal#walfile&quot;&gt;WALファイル&lt;/a&gt;、&lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open（）&lt;/a&gt;インターフェースは、WALファイルに他の有効なトランザクションが含まれている場合でも、WALファイルに追加された最後のトランザクションのみを開くことができます。</target>
        </trans-unit>
        <trans-unit id="ce5e78d94d5947b9e328c1516e3f265b0f48637a" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; is generated from &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; then the statement is automatically re-prepared if the schema changes, up to &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; times (default: 50). The &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface will only return SQLITE_SCHEMA back to the application if the failure persists after these many retries.</source>
          <target state="translated">場合&lt;a href=&quot;c3ref/stmt&quot;&gt;プリペアドステートメントを&lt;/a&gt;から生成される&lt;a href=&quot;c3ref/prepare&quot;&gt;（sqlite3_prepare_v2） &lt;/a&gt;、その後の文は、スキーマの変更、までの場合は再作成し、自動的にある&lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRYの&lt;/a&gt;時間（デフォルト：50）。&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;障害解決しない場合は、インタフェースのみ、これらの多くの再試行後にアプリケーションにSQLITE_SCHEMAバックを返します。</target>
        </trans-unit>
        <trans-unit id="3249186023e31b2ef81a917670edb42184c4e1e6" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; operation occurs on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; as a pending read or write, then the pending read or write may fail with an SQLITE_ABORT or &lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt; error.</source>
          <target state="translated">場合&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACKの&lt;/a&gt;動作は同じで発生する&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;保留中の読取りまたは書込みのような、その後ペンディング読み取りまたは書き込みがSQLITE_ABORTまたはで失敗することがあり&lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACKの&lt;/a&gt;エラー。</target>
        </trans-unit>
        <trans-unit id="a092e1c1463db0502720c4f04f6df73156ddbd46" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;wal#walfile&quot;&gt;WAL file&lt;/a&gt; remains on disk after all database connections close (either through the use of the &lt;a href=&quot;#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;file control&lt;/a&gt; or because the last process to have the database opened exited without calling &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt;) and a new connection is subsequently opened on that database and &lt;a href=&quot;wal#walfile&quot;&gt;WAL file&lt;/a&gt;, the &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface will only be able to open the last transaction added to the WAL file even though the WAL file contains other valid transactions.</source>
          <target state="translated">場合&lt;a href=&quot;wal#walfile&quot;&gt;WALファイル&lt;/a&gt;をすべて閉じデータベース接続後にディスク上に残っている（いずれかを使用して&lt;a href=&quot;#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WALの&lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;ファイル制御&lt;/a&gt;データベースを持っているか、最後のプロセス理由を呼び出さずに終了した開かれた&lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close（）&lt;/a&gt;と新しい接続を）、その後、そのデータベースに開かれ、&lt;a href=&quot;wal#walfile&quot;&gt;WALファイル&lt;/a&gt;、&lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open（）&lt;/a&gt;インターフェースは、WALファイルに他の有効なトランザクションが含まれている場合でも、WALファイルに追加された最後のトランザクションのみを開くことができます。</target>
        </trans-unit>
        <trans-unit id="fa0658f406309a7c36c783a199e98aa7bfe2c3be" translate="yes" xml:space="preserve">
          <source>If a BEFORE UPDATE or BEFORE DELETE trigger modifies or deletes a row that was to have been updated or deleted, then the result of the subsequent update or delete operation is undefined. Furthermore, if a BEFORE trigger modifies or deletes a row, then it is undefined whether or not AFTER triggers that would have otherwise run on those rows will in fact run.</source>
          <target state="translated">BEFORE UPDATE または BEFORE DELETE トリガが更新または削除されるはずの行を変更または削除した場合、その後の更新または削除操作の結果は未定義です。さらに、BEFORE トリガが行を変更または削除する場合、それらの行で実行されるはずの AFTER トリガが実際に実行されるかどうかは未定義です。</target>
        </trans-unit>
        <trans-unit id="a3ab52a71f2c1fab71f9f4f7d4dd870ab7b02c55" translate="yes" xml:space="preserve">
          <source>If a COMMIT statement (or the RELEASE of a transaction SAVEPOINT) fails because the database is currently in a state that violates a deferred foreign key constraint and there are currently &lt;a href=&quot;lang_savepoint&quot;&gt;nested savepoints&lt;/a&gt;, the nested savepoints remain open.</source>
          <target state="translated">データベースが延期外部キー制約に違反して現在がある状態で、現在あるため、ステートメント（またはトランザクションのSAVEPOINTのRELEASE）が失敗した場合は、COMMIT &lt;a href=&quot;lang_savepoint&quot;&gt;、ネストされたセーブポイントは&lt;/a&gt;、ネストされたセーブポイントは開いたまま。</target>
        </trans-unit>
        <trans-unit id="4862567128635ae0bf91b3eee8827f7e081e0187" translate="yes" xml:space="preserve">
          <source>If a DELETE statement has a LIMIT clause, the maximum number of rows that will be deleted is found by evaluating the accompanying expression and casting it to an integer value. If the result of the evaluating the LIMIT clause cannot be losslessly converted to an integer value, it is an error. A negative LIMIT value is interpreted as &quot;no limit&quot;. If the DELETE statement also has an OFFSET clause, then it is similarly evaluated and cast to an integer value. Again, it is an error if the value cannot be losslessly converted to an integer. If there is no OFFSET clause, or the calculated integer value is negative, the effective OFFSET value is zero.</source>
          <target state="translated">DELETE文にLIMIT句がある場合、削除される行の最大数は、付随する式を評価して整数値にキャストすることで求められます。LIMIT句の評価結果が整数値にロスレスに変換できない場合は、エラーとなります。負のLIMIT値は「制限なし」と解釈されます。DELETE文にOFFSET句がある場合、同様に評価され、整数値にキャストされます。ここでも、値を可逆的に整数に変換できない場合はエラーとなります。OFFSET句がない場合、または計算された整数値が負の場合、有効なOFFSET値はゼロになります。</target>
        </trans-unit>
        <trans-unit id="a8ebe41fb4265f7abee56db5ee7b5c4f78f4ea2f" translate="yes" xml:space="preserve">
          <source>If a FILTER clause is provided, then only rows for which the</source>
          <target state="translated">FILTER句が指定されている場合、その行の中で</target>
        </trans-unit>
        <trans-unit id="94816fac33b04eac89bfe331f82f9493ef356c93" translate="yes" xml:space="preserve">
          <source>If a FROM clause is specified, the data on which a simple SELECT query operates comes from the one or more tables or subqueries (SELECT statements in parentheses) specified following the FROM keyword. A subquery specified in the table-or-subquery following the FROM clause in a simple SELECT statement is handled as if it was a table containing the data returned by executing the subquery statement. Each column of the subquery has the &lt;a href=&quot;datatype3#collation&quot;&gt;collation sequence&lt;/a&gt; and &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt; of the corresponding expression in the subquery statement.</source>
          <target state="translated">FROM句が指定されている場合、単純なSELECTクエリの対象となるデータは、FROMキーワードの後に​​指定された1つ以上のテーブルまたはサブクエリ（括弧内のSELECTステートメント）から取得されます。単純なSELECTステートメントのFROM句に続くtable-or-subqueryで指定されたサブクエリは、サブクエリステートメントを実行して返されたデータを含むテーブルであるかのように処理されます。サブクエリの各列には、サブクエリステートメントの対応する式の&lt;a href=&quot;datatype3#collation&quot;&gt;照合順序&lt;/a&gt;と&lt;a href=&quot;datatype3#affinity&quot;&gt;類似性&lt;/a&gt;があります。</target>
        </trans-unit>
        <trans-unit id="257e2a863a3526135a72b7350cb70ec4620d0ce5" translate="yes" xml:space="preserve">
          <source>If a HAVING clause is specified, it is evaluated once for each group of rows as a &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt;. If the result of evaluating the HAVING clause is false, the group is discarded. If the HAVING clause is an aggregate expression, it is evaluated across all rows in the group. If a HAVING clause is a non-aggregate expression, it is evaluated with respect to an arbitrarily selected row from the group. The HAVING expression may refer to values, even aggregate functions, that are not in the result.</source>
          <target state="translated">HAVING句を指定すると、行のグループごとに&lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;ブール式&lt;/a&gt;として1回評価されます。 HAVING句の評価結果がfalseの場合、グループは破棄されます。 HAVING句が集計式の場合、グループ内のすべての行にわたって評価されます。 HAVING句が非集計式である場合、グループから任意に選択された行に対して評価されます。 HAVING式は、結果に含まれていない値（集約関数でさえ）を参照する場合があります。</target>
        </trans-unit>
        <trans-unit id="30445e74b001ab802719baf4ad36071ade7519f0" translate="yes" xml:space="preserve">
          <source>If a LIMIT clause is present, it might be possible to avoid scanning the entire table.</source>
          <target state="translated">LIMIT句がある場合は、テーブル全体をスキャンしないようにすることができるかもしれません。</target>
        </trans-unit>
        <trans-unit id="948b4ac14d2baa3362d0ca28f059b73564c6f3e7" translate="yes" xml:space="preserve">
          <source>If a Linux &lt;a href=&quot;http://en.wikipedia.org/wiki/Ext3&quot;&gt;ext3&lt;/a&gt; filesystem is mounted without the &quot;barrier=1&quot; option in the &lt;a href=&quot;http://en.wikipedia.org/wiki/fstab&quot;&gt;/etc/fstab&lt;/a&gt; and the disk drive write cache is enabled then filesystem corruption can occur following a power loss or OS crash. Whether or not corruption can occur depends on the details of the disk control hardware; corruption is more likely with inexpensive consumer-grade disks and less of a problem for enterprise-class storage devices with advanced features such as non-volatile write caches. Various ext3 experts &lt;a href=&quot;http://www.redhat.com/archives/ext3-users/2010-July/msg00001.html&quot;&gt; confirm this behavior&lt;/a&gt;. We are told that most Linux distributions do not use barrier=1 and do not disable the write cache so most Linux distributions are vulnerable to this problem. Note that this is an operating system and hardware issue and that there is nothing that SQLite can do to work around it. &lt;a href=&quot;http://ozlabs.org/~rusty/index.cgi/tech/2009-10-20.html&quot;&gt; Other database engines&lt;/a&gt; have also run into this same problem.</source>
          <target state="translated">Linux &lt;a href=&quot;http://en.wikipedia.org/wiki/Ext3&quot;&gt;ext3&lt;/a&gt;ファイルシステムが&lt;a href=&quot;http://en.wikipedia.org/wiki/fstab&quot;&gt;/ etc / fstab&lt;/a&gt;の「barrier = 1」オプションなしでマウントされており、ディスクドライブの書き込みキャッシュが有効になっている場合、停電またはOSのクラッシュ後にファイルシステムの破損が発生する可能性があります。破損が発生するかどうかは、ディスク制御ハードウェアの詳細によって異なります。破損は、安価なコンシューマーグレードのディスクで発生する可能性が高く、不揮発性書き込みキャッシュなどの高度な機能を備えたエンタープライズクラスのストレージデバイスでは問題が少ないです。さまざまなext3エキスパートが&lt;a href=&quot;http://www.redhat.com/archives/ext3-users/2010-July/msg00001.html&quot;&gt;この動作を確認します&lt;/a&gt;。ほとんどのLinuxディストリビューションはバリア= 1を使用せず、書き込みキャッシュを無効にしないため、ほとんどのLinuxディストリビューションはこの問題に対して脆弱です。これはオペレーティングシステムとハードウェアの問題であり、SQLiteがそれを回避するためにできることは何もないことに注意してください。&lt;a href=&quot;http://ozlabs.org/~rusty/index.cgi/tech/2009-10-20.html&quot;&gt;他のデータベースエンジンで&lt;/a&gt;もこの同じ問題が発生しています。</target>
        </trans-unit>
        <trans-unit id="99b0a8e8602a0a06983153315092cfd9796ad41e" translate="yes" xml:space="preserve">
          <source>If a NOT NULL constraint is specified, then the column must have a default value other than NULL.</source>
          <target state="translated">NOT NULL 制約が指定された場合、列は NULL 以外のデフォルト値を持つ必要があります。</target>
        </trans-unit>
        <trans-unit id="55be5a331b8cf28f9f746d3f7eb6341aa17eff02" translate="yes" xml:space="preserve">
          <source>If a SELECT query contains an ORDER BY, GROUP BY or DISTINCT clause, SQLite may need to use a temporary b-tree structure to sort the output rows. Or, it might &lt;a href=&quot;queryplanner#sorting&quot;&gt;use an index&lt;/a&gt;. Using an index is almost always much more efficient than performing a sort. If a temporary b-tree is required, a record is added to the EXPLAIN QUERY PLAN output with the &quot;detail&quot; field set to a string value of the form &quot;USE TEMP B-TREE FOR xxx&quot;, where xxx is one of &quot;ORDER BY&quot;, &quot;GROUP BY&quot; or &quot;DISTINCT&quot;. For example:</source>
          <target state="translated">SELECTクエリにORDER BY、GROUP BY、またはDISTINCT句が含まれている場合、SQLiteは一時的なBツリー構造を使用して出力行をソートする必要がある場合があります。または、&lt;a href=&quot;queryplanner#sorting&quot;&gt;インデックスを使用する場合があります&lt;/a&gt;。ほとんどの場合、インデックスを使用する方が、ソートを実行するよりもはるかに効率的です。一時的なbツリーが必要な場合、「詳細」フィールドを「USE TEMP B-TREE FOR xxx」という形式の文字列値に設定して、EXPLAIN QUERY PLAN出力にレコードを追加します。ここで、xxxは「ORDER BY」、「GROUP BY」、または「DISTINCT」。例えば：</target>
        </trans-unit>
        <trans-unit id="5b44dbe4fb9e1c6ef0606b8af702048ca0e438cc" translate="yes" xml:space="preserve">
          <source>If a SELECT statement that returns more than one row does not have an ORDER BY clause, the order in which the rows are returned is undefined. Or, if a SELECT statement does have an ORDER BY clause, then the list of expressions attached to the ORDER BY determine the order in which rows are returned to the user.</source>
          <target state="translated">複数の行を返すSELECT文にORDER BY句がない場合、返される行の順序は未定義です。あるいは、SELECT文にORDER BY句がある場合、ORDER BYに付随する式のリストが、ユーザに返される行の順序を決定します。</target>
        </trans-unit>
        <trans-unit id="1b3cef981ef6c33ad4faa712cdaf3b903f15861f" translate="yes" xml:space="preserve">
          <source>If a UNION operator connects the initial-select with the recursive-select, then only add rows to the queue if no identical row has been previously added to the queue. Repeated rows are discarded before being added to the queue even if the repeated rows have already been extracted from the queue by the recursion step. If the operator is UNION ALL, then all rows generated by both the initial-select and the recursive-select are always added to the queue even if they are repeats. When determining if a row is repeated, NULL values compare equal to one another and not equal to any other value.</source>
          <target state="translated">UNION演算子が初期選択と再帰選択を接続している場合、以前に同じ行がキューに追加されていない場合にのみ、行をキューに追加します。繰り返しの行は、たとえその繰り返しの行が再帰ステップによって既にキューから抽出されていたとしても、キューに追加される前に破棄されます。演算子が UNION ALL の場合、初期選択と再帰選択の両方によって生成されたすべての行は、たとえそれらが繰り返し行であっても、常にキューに追加されます。行が繰り返されているかどうかを判断する際には、NULL値は互いに等しく比較され、他の値とは等しくありません。</target>
        </trans-unit>
        <trans-unit id="56d92b47e4081e5a6e548ebb6f898e186d052899" translate="yes" xml:space="preserve">
          <source>If a WHEN clause is supplied, the SQL statements specified are only executed if the WHEN clause is true. If no WHEN clause is supplied, the SQL statements are executed every time the trigger fires.</source>
          <target state="translated">WHEN句が指定された場合、指定されたSQL文はWHEN句が真の場合にのみ実行されます。WHEN句が与えられなかった場合、トリガが発生するたびにSQL文が実行されます。</target>
        </trans-unit>
        <trans-unit id="85a070271019d9b24039a7b30649256cb4c49fd9" translate="yes" xml:space="preserve">
          <source>If a WHERE clause is specified, the WHERE expression is evaluated for each row in the input data as a &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt;. Only rows for which the WHERE clause expression evaluates to true are included from the dataset before continuing. Rows are excluded from the result if the WHERE clause evaluates to either false or NULL.</source>
          <target state="translated">WHERE句が指定されている場合、WHERE式は入力データの各行に対して&lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;ブール式&lt;/a&gt;として評価されます。続行する前に、WHERE句の式がtrueと評価される行のみがデータセットから含まれます。 WHERE句の評価がfalseまたはNULLの場合、行は結果から除外されます。</target>
        </trans-unit>
        <trans-unit id="99314068471e46954e8f897765afda682981e6bc" translate="yes" xml:space="preserve">
          <source>If a build of SQLite does not include the FTS modules, then any attempt to prepare an SQL statement to create an FTS3 or FTS4 table or to drop or access an existing FTS table in any way will fail. The error message returned will be similar to &quot;no such module: ftsN&quot; (where N is either 3 or 4).</source>
          <target state="translated">SQLite のビルドに FTS モジュールが含まれていない場合、FTS3 または FTS4 テーブルを作成したり、既存の FTS テーブルを削除したりアクセスしたりする SQL 文を準備しようとしても失敗します。返されるエラーメッセージは、&quot;no such module:ftsN&quot; (ここで、N は 3 または 4 のいずれかです)のようなものになります。</target>
        </trans-unit>
        <trans-unit id="c07dc39ee71e6a6e8537165278b706aabd6e81bd" translate="yes" xml:space="preserve">
          <source>If a call to sqlite3_step() that attempts to write to a database table returns SQLITE_LOCKED, then more than one other connection may be holding a read-lock on the database table in question. In this case SQLite simply selects one of those other connections arbitrarily and issues the unlock-notify callback when that connection's transaction is finished. Whether the call to sqlite3_step() was blocked by one or many connections, when the corresponding unlock-notify callback is issued it is not guaranteed that the required lock is available, only that it may be.</source>
          <target state="translated">データベーステーブルへの書き込みを試みたsqlite3_step()の呼び出しがSQLITE_LOCKEDを返す場合、問題のデータベーステーブルに対して複数の他の接続がリードロックを保持している可能性があります。この場合、SQLiteは単に他の接続のうちの1つを任意に選択し、その接続のトランザクションが終了したときにunlock-notifyコールバックを発行します。sqlite3_step()の呼び出しが1つのコネクションによってブロックされていようが、多数のコネクションによってブロックされていようが、対応する unlock-notifyコールバックが発行されたときに、必要なロックが利用可能であることを保証するものではありません。</target>
        </trans-unit>
        <trans-unit id="12e866adc40a794d5a50cd7647771628a0fe472b" translate="yes" xml:space="preserve">
          <source>If a character specified as part of the argument to &quot;tokenchars=&quot; is considered to be a token character by default, it is ignored. This is true even if it has been marked as a separator by an earlier &quot;separators=&quot; option. Similarly, if a character specified as part of a &quot;separators=&quot; option is treated as a separator character by default, it is ignored. If multiple &quot;tokenchars=&quot; or &quot;separators=&quot; options are specified, all are processed. For example:</source>
          <target state="translated">tokenchars=&quot; の引数の一部として指定された文字が、デフォルトではトークン文字とみなされている場合、それは無視されます。これは、以前の &quot;separators=&quot; オプションで区切り文字としてマークされていた場合でも同様です。同様に、&quot;separators=&quot;オプションの一部として指定された文字がデフォルトでセパレータ文字として扱われている場合、それは無視されます。複数の &quot;tokenchars=&quot; または &quot;separators=&quot; オプションが指定されている場合は、すべて処理されます。例えば、&quot;tokenchars=&quot;または &quot;separators=&quot;オプションを複数指定した場合は、すべて処理されます。</target>
        </trans-unit>
        <trans-unit id="4047a69992390b90bb1e651abb363899dad3ce20" translate="yes" xml:space="preserve">
          <source>If a collating function fails any of the above constraints and that collating function is registered and used, then the behavior of SQLite is undefined.</source>
          <target state="translated">照合関数が上記の制約のいずれかに失敗し、その照合関数が登録されて使用されている場合、SQLiteの動作は未定義となります。</target>
        </trans-unit>
        <trans-unit id="4a25d30fe6f01a94e32b9a3c4b8ab96f2806f18f" translate="yes" xml:space="preserve">
          <source>If a column datatype contains the special keyword &quot;HIDDEN&quot; (in any combination of upper and lower case letters) then that keyword it is omitted from the column datatype name and the column is marked as a hidden column internally. A hidden column differs from a normal column in three respects:</source>
          <target state="translated">列のデータ型に特別なキーワード &quot;HIDDEN&quot; が含まれている場合は、そのキーワードは列のデータ型名から省略され、その列は内部的に hidden 列としてマークされます。隠された列は、3つの点で通常の列とは異なります。</target>
        </trans-unit>
        <trans-unit id="4a3060f5f06633a8fd81221c196cda03a0efe5c5" translate="yes" xml:space="preserve">
          <source>If a column filter specification is preceded by a &quot;-&quot; character, then it is interpreted as a list of column not to match against. For example:</source>
          <target state="translated">カラムフィルタ指定の前に&quot;-&quot;文字が付けられている場合は、マッチしないカラムのリストとして解釈されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="4784be250e1d29a9c62d93440a67186e8f2d433e" translate="yes" xml:space="preserve">
          <source>If a column has the type INTEGER PRIMARY KEY AUTOINCREMENT then a slightly different ROWID selection algorithm is used. The ROWID chosen for the new row is at least one larger than the largest ROWID that has ever before existed in that same table. If the table has never before contained any data, then a ROWID of 1 is used. If the largest possible ROWID has previously been inserted, then new INSERTs are not allowed and any attempt to insert a new row will fail with an SQLITE_FULL error. Only ROWID values from previous transactions that were committed are considered. ROWID values that were rolled back are ignored and can be reused.</source>
          <target state="translated">列の型が INTEGER PRIMARY KEY AUTOINCREMENT の場合は、少し異なる ROWID 選択アルゴリズムが使用されます。新しい行に選択される ROWID は、同じテーブルに過去に存在した最大の ROWID よりも少なくとも 1 つ大きいものです。テーブルにデータが一度も含まれていない場合は、1のROWIDが使用されます。可能な限り最大の ROWID が以前に挿入されていた場合、新しい INSERT は許可されず、新しい行を挿入しようとすると SQLITE_FULL エラーで失敗します。コミットされた以前のトランザクションの ROWID 値のみが考慮されます。ロールバックされた ROWID 値は無視され、再利用することができます。</target>
        </trans-unit>
        <trans-unit id="85779fa11fd249fc0a9433b1c9e912b143d1abd7" translate="yes" xml:space="preserve">
          <source>If a column-name list follows the view-name, then that list determines the names of the columns for the view. If the column-name list is omitted, then the names of the columns in the view are derived from the names of the result-set columns in the &lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt;. The use of column-name list is recommended. Or, if column-name list is omitted, then the result columns in the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement that defines the view should have well-defined names using the &quot;&lt;a href=&quot;syntax/result-column&quot;&gt;AS column-alias&lt;/a&gt;&quot; syntax. SQLite allows you to create views that depend on automatically generated column names, but you should avoid using them since the rules used to generate column names are not a defined part of the interface and might change in future releases of SQLite.</source>
          <target state="translated">column-nameリストがview-nameの後に続く場合、そのリストはビューの列の名前を決定します。 column-nameリストが省略されている場合、ビューの列の名前は、&lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmtの&lt;/a&gt;結果セット列の名前から派生します。 column-nameリストの使用をお勧めします。または、column-nameリストが省略されている場合、ビューを定義する&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントの結果列には、 &quot; &lt;a href=&quot;syntax/result-column&quot;&gt;AS column-alias&lt;/a&gt; &quot;構文を使用して明確に定義された名前が必要です。 SQLiteでは、自動的に生成された列名に依存するビューを作成できますが、列名の生成に使用されるルールはインターフェースの定義された部分ではなく、SQLiteの将来のリリースで変更される可能性があるため、これらの使用は避けてください。</target>
        </trans-unit>
        <trans-unit id="7f7aaafed42977493a2413f4303512821df4e3b2" translate="yes" xml:space="preserve">
          <source>If a conflict handler returns this value no special action is taken. The change that caused the conflict is not applied. The session module continues to the next change in the changeset.</source>
          <target state="translated">競合ハンドラがこの値を返した場合、特別なアクションは実行されません。コンフリクトの原因となった変更は適用されません。セッションモジュールは、チェンジセットの次の変更に継続します。</target>
        </trans-unit>
        <trans-unit id="a40b2d39f56dad1b134a26af2fe2ae696281adc1" translate="yes" xml:space="preserve">
          <source>If a covering index can be used for a query, then the multiple rowid lookups can be avoided and the cost of the query drops dramatically.</source>
          <target state="translated">カバーリングインデックスをクエリに使用できる場合は、複数の行IDのルックアップを避けることができ、クエリのコストは劇的に低下します。</target>
        </trans-unit>
        <trans-unit id="653b4381ff1ad3607fbc3061d7b4f5d80ed74deb" translate="yes" xml:space="preserve">
          <source>If a crash or power failure occurs and results in a hot journal but that journal is deleted, the next process to open the database will not know that it contains changes that need to be rolled back. The rollback will not occur and the database will be left in an inconsistent state. Rollback journals might be deleted for any number of reasons:</source>
          <target state="translated">クラッシュや停電が発生してホット・ジャーナルが発生したが、そのジャーナルが削除された場合、データベースを開く次のプロセスでは、ロールバックする必要のある変更が含まれていることがわかりません。ロールバックは発生せず、データベースは一貫性のない状態のままになります。ロールバック・ジャーナルは、いくつかの理由で削除される可能性があります。</target>
        </trans-unit>
        <trans-unit id="dbc53ced19579b45a05b723b3063167292a44232" translate="yes" xml:space="preserve">
          <source>If a crash or power loss does occur and a hot journal is left on the disk, it is essential that the original database file and the hot journal remain on disk with their original names until the database file is opened by another SQLite process and rolled back. During recovery at &lt;a href=&quot;#section_4_2&quot;&gt;step 4.2&lt;/a&gt; SQLite locates the hot journal by looking for a file in the same directory as the database being opened and whose name is derived from the name of the file being opened. If either the original database file or the hot journal have been moved or renamed, then the hot journal will not be seen and the database will not be rolled back.</source>
          <target state="translated">クラッシュまたは停電が発生し、ホットジャーナルがディスクに残っている場合、元のデータベースファイルとホットジャーナルは、データベースファイルが別のSQLiteプロセスによって開かれてロールバックされるまで、元の名前でディスクに残ることが重要です。 。&lt;a href=&quot;#section_4_2&quot;&gt;ステップ4.2での&lt;/a&gt;リカバリー中に、SQLiteは、開かれているデータベースと同じディレクトリーで、開かれているファイルの名前から派生した名前のファイルを探すことにより、ホットジャーナルを見つけます。元のデータベースファイルまたはホットジャーナルが移動または名前変更されている場合、ホットジャーナルは表示されず、データベースはロールバックされません。</target>
        </trans-unit>
        <trans-unit id="fb8183919d1fc07417b2707b8092ba7a7a08090d" translate="yes" xml:space="preserve">
          <source>If a crash or power loss occurs in the middle of a transaction, then the rollback journal file is left on disk. The next time another application attempts to open the database file, it notices the presence of the abandoned rollback journal (we call it a &quot;hot journal&quot; in this circumstance) and uses the information in the journal to restore the database to its state prior to the start of the incomplete transaction. This is how SQLite implements atomic commit.</source>
          <target state="translated">トランザクションの途中でクラッシュや停電が発生した場合、ロールバック・ジャーナル・ファイルはディスク上に残されます。次に別のアプリケーションがデータベースファイルを開こうとすると、放棄されたロールバックジャーナル(この状況では「ホットジャーナル」と呼んでいます)の存在に気付き、ジャーナル内の情報を使ってデータベースを不完全なトランザクションの開始前の状態に復元します。これが SQLite がアトミックコミットを実装する方法です。</target>
        </trans-unit>
        <trans-unit id="ac9f0e2592a2df4c51e939a4b5d49b41b7d7ebcb" translate="yes" xml:space="preserve">
          <source>If a database connection is opened with the &quot;-uri 1&quot; option, then &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; are honored by the &quot;backup&quot; and &quot;restore&quot; commands.</source>
          <target state="translated">「-uri 1」オプションを使用してデータベース接続が開かれている場合、&lt;a href=&quot;uri&quot;&gt;URIファイル名&lt;/a&gt;は「backup」および「restore」コマンドによって受け入れられます。</target>
        </trans-unit>
        <trans-unit id="d5923feff2a2aef8fc7abf4f600aff34fc785066" translate="yes" xml:space="preserve">
          <source>If a database connection is operating in &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; or in &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;persistent journal mode&lt;/a&gt; (PRAGMA journal_mode=persist) then after committing a transaction the &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; file may remain in the file-system. This increases performance for subsequent transactions since overwriting an existing file is faster than append to a file, but it also consumes file-system space. After a large transaction (e.g. a &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;), the rollback journal file may consume a very large amount of space.</source>
          <target state="translated">データベース接続が&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;排他ロックモード&lt;/a&gt;または&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;永続ジャーナルモード&lt;/a&gt;（PRAGMA journal_mode = persist）で動作している場合、トランザクションをコミットした後、&lt;a href=&quot;lockingv3#rollback&quot;&gt;ロールバックジャーナル&lt;/a&gt;ファイルがファイルシステムに残ることがあります。既存のファイルを上書きする方がファイルに追加するより高速なので、これにより後続のトランザクションのパフォーマンスが向上しますが、ファイルシステムのスペースも消費します。大きなトランザクション（&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUMなど&lt;/a&gt;）の後、ロールバックジャーナルファイルは非常に大量のスペースを消費する場合があります。</target>
        </trans-unit>
        <trans-unit id="5f55f04439258c2d344a35f29269aa9db3e5202b" translate="yes" xml:space="preserve">
          <source>If a database file is accessed using 8+3 naming rather than the default long filename, then it must be consistently accessed using 8+3 naming by every database connection every time it is opened, or else there is a risk of database corruption. The auxiliary &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; and &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; files are essential to SQLite for being about to recover from a crash. If an application is using 8+3 names and crashes, then the information needed to safely recover from the crash is stored in files with the &quot;&lt;code&gt;.nal&lt;/code&gt;&quot; or &quot;&lt;code&gt;.wal&lt;/code&gt;&quot; extension. If the next application to open the database does not specify the &quot;&lt;code&gt;8_3_names=1&lt;/code&gt;&quot; URI parameter, then SQLite will use the long filenames to try to locate the rollback journal or write-ahead log files. It will not find them, since they were saved using 8+3 names by the application that crashed, and hence the database will not be properly recovered and will likely go corrupt.</source>
          <target state="translated">デフォルトの長いファイル名ではなく8 + 3ネーミングを使用してデータベースファイルにアクセスする場合は、開かれるたびにすべてのデータベース接続で8 + 3ネーミングを使用して一貫してアクセスする必要があります。そうしないと、データベースが破損するおそれがあります。SQLiteがクラッシュから回復しようとするためには、補助&lt;a href=&quot;lockingv3#rollback&quot;&gt;ロールバックジャーナル&lt;/a&gt;と&lt;a href=&quot;wal&quot;&gt;先行書き込みログ&lt;/a&gt;ファイルが不可欠です。アプリケーションが8 + 3の名前とクラッシュを使用している場合、クラッシュから安全に回復するために必要な情報は、 &lt;code&gt;.nal&lt;/code&gt; が「.nal」または「 &lt;code&gt;.wal&lt;/code&gt; 」のファイルに保存されます。データベースを開く次のアプリケーションで &quot; &lt;code&gt;8_3_names=1&lt;/code&gt; &quot;URIパラメータの場合、SQLiteは長いファイル名を使用してロールバックジャーナルまたは先読みログファイルを見つけようとします。クラッシュしたアプリケーションによって8 + 3の名前を使用して保存されたため、これらのファイルは見つからないため、データベース正しく回復されず、破損する可能性があります。</target>
        </trans-unit>
        <trans-unit id="bd70a20b8f5f47bbbe011a3bee3a583fecc50caa" translate="yes" xml:space="preserve">
          <source>If a database is written by SQLite version 3.7.0 or later and then written again by SQLite version 3.6.23 or earlier in such a way as to make the size of the database file decrease, then the next time that SQLite version 3.7.0 access the database file, it might report that the database file is corrupt. The database file is not really corrupt, however. Version 3.7.0 was simply being overly zealous in its corruption detection.</source>
          <target state="translated">SQLite バージョン 3.7.0 以降でデータベースを書き込んだ後、SQLite バージョン 3.6.23 以前でデータベースファイルのサイズを小さくするような方法で再度書き込んだ場合、次に SQLite バージョン 3.7.0 がデータベースファイルにアクセスしたときに、データベースファイルが破損していると報告されることがあります。しかし、データベースファイルは実際には壊れていません。バージョン3.7.0は単に破損検出に熱心になりすぎただけです。</target>
        </trans-unit>
        <trans-unit id="c0e8b12ff7ad15986137c5d5f01f4e0ef949a4a6" translate="yes" xml:space="preserve">
          <source>If a database were originally created using SQLite version 3.7.0, then written by SQLite version 3.6.23.1 such that the size of the database file increased, then written again by SQLite version 3.7.0, the database file could go corrupt.</source>
          <target state="translated">もともとSQLiteバージョン3.7.0でデータベースを作成し、SQLiteバージョン3.6.23.1で書き込んでデータベースファイルのサイズが大きくなった後、再度SQLiteバージョン3.7.0で書き込んだ場合、データベースファイルが破損してしまう可能性があります。</target>
        </trans-unit>
        <trans-unit id="f7f861f58b781638426cc97ad65bbe6addfa6a62" translate="yes" xml:space="preserve">
          <source>If a keyword in double quotes (ex: &lt;b&gt;&quot;key&quot;&lt;/b&gt; or &lt;b&gt;&quot;glob&quot;&lt;/b&gt;) is used in a context where it cannot be resolved to an identifier but where a string literal is allowed, then the token is understood to be a string literal instead of an identifier.</source>
          <target state="translated">二重引用符で囲まれたキーワード（例：&lt;b&gt;&quot;key&quot;&lt;/b&gt;または&lt;b&gt;&quot;glob&quot;&lt;/b&gt;）が、識別子に解決できないが文字列リテラルが許可されているコンテキストで使用されている場合、トークンは文字列リテラルではなく、識別子。</target>
        </trans-unit>
        <trans-unit id="ff734731d1dd61e745b8c19a93e379fd051ea7fb" translate="yes" xml:space="preserve">
          <source>If a keyword in single quotes (ex: &lt;b&gt;'key'&lt;/b&gt; or &lt;b&gt;'glob'&lt;/b&gt;) is used in a context where an identifier is allowed but where a string literal is not allowed, then the token is understood to be an identifier instead of a string literal.</source>
          <target state="translated">単一引用符で囲まれたキーワード（例：&lt;b&gt;'key'&lt;/b&gt;または&lt;b&gt;'glob'&lt;/b&gt;）が、識別子は許可されているが文字列リテラルは許可されていないコンテキストで使用される場合、トークンは文字列リテラルではなく識別子であると理解されます。</target>
        </trans-unit>
        <trans-unit id="fd8582b07f28c43cf6305e6462fb4a6db23b8ea7" translate="yes" xml:space="preserve">
          <source>If a matchable phrase is part of a series of phrases connected by NEAR operators in the FTS query expression, then each phrase match must be sufficiently close to other phrase matches of the relevant types to satisfy the NEAR condition.</source>
          <target state="translated">一致可能なフレーズが、FTS クエリ式の NEAR 演算子によって接続された一連のフレーズの一部である場合、各フレーズの一致は、NEAR 条件を満たすために、関連するタイプの他のフレーズの一致に十分に近接していなければなりません。</target>
        </trans-unit>
        <trans-unit id="a2a6d03cae632eedbf962d2919113c9e0642d81c" translate="yes" xml:space="preserve">
          <source>If a memory allocation error occurs, sqlite3_create_filename() might return a NULL pointer. The memory obtained from sqlite3_create_filename(X) must be released by a corresponding call to sqlite3_free_filename(Y).</source>
          <target state="translated">メモリ割り当てエラーが発生した場合、sqlite3_create_filename()はNULLポインタを返すかもしれません。sqlite3_create_filename(X)で得られたメモリは、対応するsqlite3_free_filename(Y)の呼び出しによって解放されなければなりません。</target>
        </trans-unit>
        <trans-unit id="16ba62507a795aad87688bd7a66b598560ff99c0" translate="yes" xml:space="preserve">
          <source>If a named virtual table that uses the dbstat module is desired, then the recommended way to create an instance of the dbstat virtual table is as follows:</source>
          <target state="translated">dbstatモジュールを使用する名前付き仮想テーブルが必要な場合は、以下のようにdbstat仮想テーブルのインスタンスを作成することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f0a2ba4a4cc7d08c018b4dbe8137dc10439214b7" translate="yes" xml:space="preserve">
          <source>If a numeric literal has a decimal point or an exponentiation clause or if its magnitude is less than -9223372036854775808 or greater than 9223372036854775807, then it is a floating point literal. Otherwise is it is an integer literal. The &quot;E&quot; character that begins the exponentiation clause of a floating point literal can be either upper or lower case. The &quot;.&quot; character is always used as the decimal point even if the locale setting specifies &quot;,&quot; for this role - the use of &quot;,&quot; for the decimal point would result in syntactic ambiguity.</source>
          <target state="translated">数値リテラルに小数点または指数節がある場合、またはその大きさが-9223372036854775808より小さいか、9223372036854775807より大きい場合、それは浮動小数点リテラルです。それ以外の場合は整数リテラルです。浮動小数点リテラルの指数化句の先頭にある &quot;E &quot;文字は、大文字または小文字のどちらでも構いません。ロケール設定でこの役割のために&quot;,&quot;が指定されている場合でも、&quot;.&quot;は常に小数点として使用されます-小数点に&quot;,&quot;を使用すると、構文的に曖昧になります。</target>
        </trans-unit>
        <trans-unit id="8cf3813aebca15b6b5e1583aeffa06f6925412e6" translate="yes" xml:space="preserve">
          <source>If a page contains no cells (which is only possible for a root page of a table that contains no rows) then the offset to the cell content area will equal the page size minus the bytes of reserved space. If the database uses a 65536-byte page size and the reserved space is zero (the usual value for reserved space) then the cell content offset of an empty page wants to be 65536. However, that integer is too large to be stored in a 2-byte unsigned integer, so a value of 0 is used in its place.</source>
          <target state="translated">ページにセルが含まれていない場合(これは行を含まないテーブルのルートページでのみ可能です)、セル内容領域へのオフセットはページサイズから予約領域のバイト数を引いたものになります。データベースが65536バイトのページサイズを使用しており、予約領域がゼロ(予約領域の通常の値)である場合、空ページのセルコンテンツオフセットは65536になります。しかし、この整数は2バイトの符号なし整数に格納するには大きすぎるため、0の値が代わりに使用されます。</target>
        </trans-unit>
        <trans-unit id="c99e07bc95c7e7eeb5ce8d8ce056128a45cab0ab" translate="yes" xml:space="preserve">
          <source>If a parameter name begins with a &quot;:&quot;, then it is assumed to be a value to bind to the SQL statement before executing it. The value is always bound as text. It is an error if the specified SQL parameter does not exist. For example:</source>
          <target state="translated">パラメータ名が&quot;:&quot;で始まる場合、それはSQL文を実行する前にバインドする値であると見なされます。値は常にテキストとしてバインドされます。指定されたSQLパラメータが存在しない場合はエラーとなります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="a3a6677c34d1c31ace005a4fa6f3930c2040066e" translate="yes" xml:space="preserve">
          <source>If a power failure or operating system crash occurs at this point, the transaction will not rollback when the system reboots even though there are rollback journals present. The difference is the master journal pathname in the header of the rollback journal. Upon restart, SQLite only considers a journal to be hot and will only playback the journal if there is no master journal filename in the header (which is the case for a single-file commit) or if the master journal file still exists on disk.</source>
          <target state="translated">この時点で電源障害やオペレーティングシステムのクラッシュが発生した場合、ロールバックジャーナルが存在していてもシステムが再起動したときにトランザクションはロールバックされません。違いは、ロールバック・ジャーナルのヘッダーにあるマスター・ジャーナル・パス名です。再起動時には、SQLite はジャーナルをホットジャーナルとみなし、ヘッダーにマスタージャーナルファイル名がない場合(シングルファイルコミットの場合がこれにあたります)、またはマスタージャーナルファイルがディスク上にまだ存在する場合にのみジャーナルを再生します。</target>
        </trans-unit>
        <trans-unit id="df0966ae095afce680bcbe564721893f2e27c89b" translate="yes" xml:space="preserve">
          <source>If a power failure or operating system crash occurs at this point, the transaction will not rollback when the system reboots even though there are rollback journals present. The difference is the super-journal pathname in the header of the rollback journal. Upon restart, SQLite only considers a journal to be hot and will only playback the journal if there is no super-journal filename in the header (which is the case for a single-file commit) or if the super-journal file still exists on disk.</source>
          <target state="translated">この時点で電源障害やオペレーティングシステムのクラッシュが発生した場合、ロールバックジャーナルが存在していてもシステムが再起動したときにトランザクションはロールバックされません。違いは、ロールバック・ジャーナルのヘッダーにあるスーパー・ジャーナル・パス名です。再起動時には、SQLite はジャーナルがホットであるとのみみなし、ヘッダーにスーパージャーナルのファイル名がない場合(シングルファイルコミットの場合)、またはスーパージャーナルのファイルがディスク上にまだ存在する場合にのみジャーナルを再生します。</target>
        </trans-unit>
        <trans-unit id="f031e4113363c1780559d56fb503c736f7031cb4" translate="yes" xml:space="preserve">
          <source>If a power failure or operating system failure occurs while copying the database file the backup database may be corrupted following system recovery.</source>
          <target state="translated">データベース ファイルのコピー中に電源障害またはオペレーティング システム障害が発生した場合、システム リカバリ後にバックアップ データベースが破損する可能性があります。</target>
        </trans-unit>
        <trans-unit id="d63fd60747c59caf947d214389cf965d0e528d08" translate="yes" xml:space="preserve">
          <source>If a query contains an ORDER BY clause with multiple terms, it might be that SQLite can use indices to cause rows to come out in the order of some prefix of the terms in the ORDER BY but that later terms in the ORDER BY are not satisfied. In that case, SQLite does block sorting. Suppose the ORDER BY clause has four terms and the natural order of the query results in rows appearing in order of the first two terms. As each row is output by the query engine and enters the sorter, the outputs in the current row corresponding to the first two terms of the ORDER BY are compared against the previous row. If they have changed, the current sort is finished and output and a new sort is started. This results in a slightly faster sort. But the bigger advantages are that many fewer rows need to be held in memory, reducing memory requirements, and outputs can begin to appear before the core query has run to completion.</source>
          <target state="translated">クエリに複数の単語を含む ORDER BY 句が含まれている場合、SQLite がインデックスを使用して ORDER BY の単語のプレフィックスの順に行を出力することができますが、それ以降の ORDER BY の単語が満たされていない場合があります。この場合、SQLite はブロックソートを行います。例えば、ORDER BY 句には 4 つの項があり、クエリの自然な順序では、最初の 2 つの項から順に行が出力されるとします。各行がクエリエンジンによって出力され、ソーターに入ると、ORDER BYの最初の2つの項に対応する現在の行の出力が前の行と比較されます。それらが変更されている場合は、現在のソートが終了して出力され、新しいソートが開始されます。その結果、ソートが若干速くなります。しかし、より大きな利点は、メモリに保持する必要のある行の数が少なくて済むため、メモリの必要量が減り、コアクエリが完了する前に出力を開始することができることです。</target>
        </trans-unit>
        <trans-unit id="ec318f6e2d2904b05a3f02946f0559cc8fefaa28" translate="yes" xml:space="preserve">
          <source>If a query contains no aggregate functions at all, then a GROUP BY clause can be added as a substitute for the DISTINCT ON clause. In other words, output rows are filtered so that only one row is shown for each distinct set of values in the GROUP BY clause. If two or more output rows would have otherwise had the same set of values for the GROUP BY columns, then one of the rows is chosen arbitrarily. (SQLite supports DISTINCT but not DISTINCT ON, whose functionality is provided instead by GROUP BY.)</source>
          <target state="translated">クエリに集約関数が全く含まれていない場合、GROUP BY句をDISTINCT ON句の代わりに追加することができます。言い換えれば、出力行はフィルタリングされ、GROUP BY句の異なる値のセットに対して1つの行のみが表示されるようになります。2 つ以上の出力行が、GROUP BY 列の値のセットが同じでなければならない場合は、そのうちの 1 つの行が任意に選択されます (SQLite は DISTINCT ON 節をサポートしています)。(SQLite は DISTINCT をサポートしていますが、DISTINCT ON はサポートしていません。)</target>
        </trans-unit>
        <trans-unit id="bdf63c23188158127b26cd2c4807de45ccf6dea6" translate="yes" xml:space="preserve">
          <source>If a query contains no aggregate functions at all, then a GROUP BY clause can be added as a substitute of DISTINCT ON clause. In other words, output rows are filtered so that only one row is shows for each distinct set of values in the GROUP BY clause. If two or more output rows would have otherwise had the same set of values for the GROUP BY columns, then one of the rows is chosen arbitrarily.</source>
          <target state="translated">クエリに集約関数が全く含まれていない場合は、GROUP BY句をDISTINCT ON句の代わりに追加することができます。言い換えれば、出力行は、GROUP BY句の異なる値のセットに対して1つの行のみが表示されるようにフィルタリングされます。2つ以上の出力行が、そうでなければGROUP BY列の値のセットが同じであった場合、そのうちの1つの行が任意に選択されます。</target>
        </trans-unit>
        <trans-unit id="cab66c0bca9a377eb02b4b0ac5090404c2d874c0" translate="yes" xml:space="preserve">
          <source>If a read/write client invokes &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control&lt;/a&gt;(&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;) prior to shutdown, then at shutdown a checkpoint is still run, but the shm file and wal file are not deleted. This allows subsequent read-only clients to connect to and read the database.</source>
          <target state="translated">読み取り/書き込みクライアントがシャットダウンの前に&lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control&lt;/a&gt;（&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;）を呼び出す場合、シャットダウン時にチェックポイントは引き続き実行されますが、shmファイルとwalファイルは削除されません。これにより、後続の読み取り専用クライアントがデータベースに接続して読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="337133b7d09a387cf87665a4c7d79ff39c533386" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the modified non-primary key fields contains a value different from an original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. Since UPDATE changes only contain values for non-primary key fields that are to be modified, only those fields need to match the original values to avoid the SQLITE_CHANGESET_DATA conflict-handler callback.</source>
          <target state="translated">主キー値が一致する行が見つかったが、変更された非主キーフィールドの1つ以上に、チェンジセットに格納されている元の行値とは異なる値が含まれている場合、2番目の引数として&lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt;を使用して競合ハンドラ関数が呼び出されます。 。UPDATEの変更には、変更される非主キーフィールドの値のみが含まれるため、SQLITE_CHANGESET_DATA競合ハンドラーコールバックを回避するには、これらのフィールドのみが元の値と一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="35c7138a2b7260bc49d6f60cf430df710c00202b" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the modified non-primary key fields contains a value different from an original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. Since UPDATE changes only contain values for non-primary key fields that are to be modified, only those fields need to match the original values to avoid the SQLITE_CHANGESET_DATA conflict-handler callback.</source>
          <target state="translated">主キー値が一致する行が見つかったが、変更された非主キーフィールドの1つ以上に、チェンジセットに格納されている元の行値とは異なる値が含まれている場合、2番目の引数として&lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt;を使用して競合ハンドラ関数が呼び出されます。 。UPDATEの変更には、変更される非主キーフィールドの値のみが含まれるため、SQLITE_CHANGESET_DATA競合ハンドラーコールバックを回避するには、これらのフィールドのみが元の値と一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="1b234b4b89cfdd9943a23340845cb2723771c58a" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the non-primary key fields contains a value different from the original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. If the database table has more columns than are recorded in the changeset, only the values of those non-primary key fields are compared against the current database contents - any trailing database table columns are ignored.</source>
          <target state="translated">主キー値が一致する行が見つかったが、非主キーフィールドの1つ以上に、変更セットに格納されている元の行値とは異なる値が含まれている場合、&lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLのCHANGESET_DATA&lt;/a&gt;を2番目の引数として使用して、競合ハンドラー関数が呼び出されます。変更セットに記録されているよりも多くの列がデータベーステーブルにある場合、それらの非主キーフィールドの値のみが現在のデータベースの内容と比較されます。後続のデータベーステーブルの列は無視されます。</target>
        </trans-unit>
        <trans-unit id="ca3b8d6b7470e9a00b63341bcac487b0076109fe" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the non-primary key fields contains a value different from the original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. If the database table has more columns than are recorded in the changeset, only the values of those non-primary key fields are compared against the current database contents - any trailing database table columns are ignored.</source>
          <target state="translated">主キー値が一致する行が見つかったが、非主キーフィールドの1つ以上に、変更セットに格納されている元の行値とは異なる値が含まれている場合、&lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLのCHANGESET_DATA&lt;/a&gt;を2番目の引数として使用して、競合ハンドラー関数が呼び出されます。変更セットに記録されているよりも多くの列がデータベーステーブルにある場合、それらの非主キーフィールドの値のみが現在のデータベースの内容と比較されます。後続のデータベーステーブルの列は無視されます。</target>
        </trans-unit>
        <trans-unit id="e400ae567f256dbdcc0abe528516e66e2c791942" translate="yes" xml:space="preserve">
          <source>If a schema name is specified as part of an object reference, it must be either &quot;main&quot;, or &quot;temp&quot; or the schema-name of an attached database. Like other SQL identifiers, schema names are case-insensitive. If a schema name is specified, then only that one schema is searched for the named object.</source>
          <target state="translated">スキーマ名がオブジェクト参照の一部として指定されている場合は、&quot;main&quot;、&quot;temp&quot;、またはアタッチされているデータベースのスキーマ名のいずれかでなければなりません。他の SQL 識別子と同様に、スキーマ名は大文字小文字を区別しません。スキーマ名が指定された場合、指定されたオブジェクトに対してはそのスキーマのみが検索されます。</target>
        </trans-unit>
        <trans-unit id="a287d9b64545db85e7dfa26422162809454f183b" translate="yes" xml:space="preserve">
          <source>If a schema-name is specified, it must be either &quot;main&quot;, &quot;temp&quot;, or the name of an &lt;a href=&quot;lang_attach&quot;&gt;attached database&lt;/a&gt;. In this case the new table is created in the named database. If the &quot;TEMP&quot; or &quot;TEMPORARY&quot; keyword occurs between the &quot;CREATE&quot; and &quot;TABLE&quot; then the new table is created in the temp database. It is an error to specify both a schema-name and the TEMP or TEMPORARY keyword, unless the schema-name is &quot;temp&quot;. If no schema name is specified and the TEMP keyword is not present then the table is created in the main database.</source>
          <target state="translated">schema-nameを指定する場合は、「main」、「temp」、または&lt;a href=&quot;lang_attach&quot;&gt;接続されているデータベースの&lt;/a&gt;名前のいずれかである必要があります。この場合、新しいテーブルは指定されたデータベースに作成されます。 「TEMP」または「TEMPORARY」キーワードが「CREATE」と「TABLE」の間にある場合、新しいテーブルが一時データベースに作成されます。 schema-nameが &quot;temp&quot;でない限り、schema-nameとTEMPまたはTEMPORARYキーワードの両方を指定するとエラーになります。スキーマ名が指定されておらず、TEMPキーワードが存在しない場合、テーブルはメインデータベースに作成されます。</target>
        </trans-unit>
        <trans-unit id="d186fac3c43b0ebe9fb52f2e0bcd9b8dc9321942" translate="yes" xml:space="preserve">
          <source>If a schema-name is specified, then the view is created in the specified database. It is an error to specify both a schema-name and the TEMP keyword on a VIEW, unless the schema-name is &quot;temp&quot;. If no schema name is specified, and the TEMP keyword is not present, the VIEW is created in the main database.</source>
          <target state="translated">スキーマ名を指定すると、指定したデータベースにビューが作成されます。スキーマ名が &quot;temp&quot; でない限り、VIEW でスキーマ名と TEMP キーワードの両方を指定するとエラーになります。スキーマ名が指定されず、TEMP キーワードが存在しない場合、ビューはメイン データベースに作成されます。</target>
        </trans-unit>
        <trans-unit id="5a3b25f9ef77a5c2a55ede994e4212a6c3bae634" translate="yes" xml:space="preserve">
          <source>If a search token (on the right-hand side of the MATCH operator) in &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; begins with &quot;^&quot; then that token must be the first in its field of the document. &lt;b&gt;** Potentially Incompatible Change **&lt;/b&gt;</source>
          <target state="translated">&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4の&lt;/a&gt;検索トークン（MATCH演算子の右側）が&quot;^&quot;で始まる場合、そのトークンはドキュメントのフィールドの最初でなければなりません。&lt;b&gt;**互換性がない可能性のある変更**&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e0b0e745b5660b6e63d47617f06b59c6fe2aec60" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;#sqlite3_changes&quot;&gt;sqlite3_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_changes&quot;&gt;sqlite3_changes（）の&lt;/a&gt;実行中に別のスレッドが同じデータベース接続に変更を加えると、返される値は予測不可能で意味がありません。</target>
        </trans-unit>
        <trans-unit id="e161385bf705ff3ca3325998e8904218252e0a24" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes（）の&lt;/a&gt;実行中に別のスレッドが同じデータベース接続に変更を加えると、返される値は予測不能で意味がありません。</target>
        </trans-unit>
        <trans-unit id="48949b30f7cc8dfe518df452770028dcf8268e04" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;changes&quot;&gt;sqlite3_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">&lt;a href=&quot;changes&quot;&gt;sqlite3_changes（）の&lt;/a&gt;実行中に別のスレッドが同じデータベース接続に変更を加えると、返される値は予測不可能で意味がありません。</target>
        </trans-unit>
        <trans-unit id="e69017ebf8db42f4c918537142f058b4e1e4b99c" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">&lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes（）の&lt;/a&gt;実行中に別のスレッドが同じデータベース接続に変更を加えると、返される値は予測不能で意味がありません。</target>
        </trans-unit>
        <trans-unit id="67e0dff317f2ea719a9272889d4afc4730b1b5fc" translate="yes" xml:space="preserve">
          <source>If a separate thread performs a new &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; on the same database connection while the &lt;a href=&quot;last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; function is running and thus changes the last insert &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;, then the value returned by &lt;a href=&quot;last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; is unpredictable and might not equal either the old or the new last insert &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）&lt;/a&gt;関数の実行中に別のスレッドが同じデータベース接続で新しい&lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;を実行し、それによって最後の挿入&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;を変更した場合、&lt;a href=&quot;last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）から&lt;/a&gt;返される値は予測不能であり、古いものと新しいもののどちらにも等しくない可能性があります&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;ROWIDを&lt;/a&gt;挿入します。</target>
        </trans-unit>
        <trans-unit id="f8a05ae1d1d14adcdf537d4865ddc934cf60a0a4" translate="yes" xml:space="preserve">
          <source>If a separate thread performs a new &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; on the same database connection while the &lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; function is running and thus changes the last insert &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;, then the value returned by &lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; is unpredictable and might not equal either the old or the new last insert &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）&lt;/a&gt;関数の実行中に別のスレッドが同じデータベース接続で新しい&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;を実行し、それによって最後の挿入&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;を変更した場合、&lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）から&lt;/a&gt;返される値は予測不能であり、古いものと新しいもののどちらにも等しくない可能性があります&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWIDを&lt;/a&gt;挿入します。</target>
        </trans-unit>
        <trans-unit id="9c0a40f4902327b395568a304aa57a5c4039b9e5" translate="yes" xml:space="preserve">
          <source>If a single database file has multiple links (either hard or soft links) then that is just another way of saying that the file has multiple names. If two or more processes open the database using different names, then they will use different rollback journals and WAL files. That means that if one process crashes, the other process will be unable to recover the transaction in progress because it will be looking in the wrong place for the appropriate journal.</source>
          <target state="translated">1つのデータベースファイルに複数のリンク(ハードリンクまたはソフトリンク)がある場合、それはファイルに複数の名前があることを意味します。2つ以上のプロセスが異なる名前を使用してデータベースを開く場合、それらのプロセスは異なるロールバックジャーナルとWALファイルを使用します。つまり、一方のプロセスがクラッシュした場合、他方のプロセスは適切なジャーナルを探す場所を間違えてしまうため、進行中のトランザクションを回復することができないということです。</target>
        </trans-unit>
        <trans-unit id="54992194ecdfbf1a36948d0111a0401fc51b1ec9" translate="yes" xml:space="preserve">
          <source>If a single row is affected by more than one operation within a session, then the change is considered indirect if all operations meet the criteria for an indirect change above, or direct otherwise.</source>
          <target state="translated">1つの行がセッション内で複数の操作によって影響を受ける場合、すべての操作が上記の間接的な変更の基準を満たしていれば、その変更は間接的なものとみなされ、そうでなければ直接なものとみなされます。</target>
        </trans-unit>
        <trans-unit id="8aed35bc8fc658c89e5539bc9b828e9558656314" translate="yes" xml:space="preserve">
          <source>If a statement modifies the contents of the database so that an immediate foreign key constraint is in violation at the conclusion the statement, an exception is thrown and the effects of the statement are reverted. By contrast, if a statement modifies the contents of the database such that a deferred foreign key constraint is violated, the violation is not reported immediately. Deferred foreign key constraints are not checked until the transaction tries to &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;. For as long as the user has an open transaction, the database is allowed to exist in a state that violates any number of deferred foreign key constraints. However, &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; will fail as long as foreign key constraints remain in violation.</source>
          <target state="translated">ステートメントがデータベースの内容を変更して、ステートメントの終了時に即時外部キー制約に違反する場合、例外がスローされ、ステートメントの効果が元に戻ります。対照的に、ステートメントがデータベースの内容を変更して遅延外部キー制約に違反した場合、違反はすぐには報告されません。遅延外部キー制約は、トランザクションが&lt;a href=&quot;lang_transaction&quot;&gt;COMMITを&lt;/a&gt;試みるまでチェックされません。ユーザーが開いているトランザクションを持っている限り、データベースは、任意の数の遅延外部キー制約に違反する状態で存在することができます。ただし、外部キー制約が違反している限り、&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;は失敗します。</target>
        </trans-unit>
        <trans-unit id="4a9fe68ac2f3c48ea32a43f2c5cf9be89d342ee4" translate="yes" xml:space="preserve">
          <source>If a subquery cannot be &lt;a href=&quot;optoverview#flattening&quot;&gt;flattened&lt;/a&gt; into the outer query, it might still be possible to enhance performance by &quot;pushing down&quot; WHERE clause terms from the outer query into the subquery. Consider an example:</source>
          <target state="translated">サブクエリを外部クエリに&lt;a href=&quot;optoverview#flattening&quot;&gt;フラット化&lt;/a&gt;できない場合でも、外部クエリからサブクエリにWHERE句の用語を「プッシュダウン」することにより、パフォーマンスを向上させることができる場合があります。例を考えてみましょう：</target>
        </trans-unit>
        <trans-unit id="cfbdc72faddc3dd92eaf2d66d72d9166e0ce65e3" translate="yes" xml:space="preserve">
          <source>If a system failure occurs at any time after a &quot;delete file&quot; operation (call to the VFS xDelete() method) returns successfully, it is assumed that the file-system will not contain the deleted file following system recovery.</source>
          <target state="translated">ファイルの削除」操作(VFS xDelete()メソッドの呼び出し)が成功した後にシステム障害が発生した場合、システム回復後にファイルシステムに削除されたファイルが含まれないことが想定されます。</target>
        </trans-unit>
        <trans-unit id="c32e1e0b557aefde59c28d931cf3e5d6733099fd" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during a &quot;delete file&quot; operation, it is assumed that following system recovery the file-system will either contain the file being deleted in the state it was in before the operation was attempted, or not contain the file at all. It is assumed that it is not possible for the file to have become corrupted purely as a result of a failure occurring during a &quot;delete file&quot; operation.</source>
          <target state="translated">ファイルの削除」操作中にシステム障害が発生した場合、システム復旧後のファイルシステムには、削除しようとしているファイルが操作前の状態で格納されるか、ファイルが全く格納されないことが想定されています。ファイルの削除」操作中に発生した障害の結果、純粋にファイルが破損することはありえないと想定されます。</target>
        </trans-unit>
        <trans-unit id="91f96ef24748138cdd82c09ceabe7f648ae9cf43" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;create file&quot; operation, but before the created file has been</source>
          <target state="translated">ファイルの作成」操作中または操作後にシステム障害が発生した場合で、作成したファイルが</target>
        </trans-unit>
        <trans-unit id="1fcfee495c57582bc4c6e63019680717056464ec" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;truncate file&quot; operation, but before the truncated file has been</source>
          <target state="translated">ファイルの切り捨て」操作中または操作後に、切り捨てられたファイルが切り捨てられる前にシステム障害が発生した場合</target>
        </trans-unit>
        <trans-unit id="e3c60bc044d7ebf2be0e926e292ed7263d6ed54a" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;write file&quot; operation that causes the file to grow, but before the corresponding file has been</source>
          <target state="translated">ファイルの書き込み」操作中または操作後にシステム障害が発生してファイルが成長したが、対応するファイルが成長する前に</target>
        </trans-unit>
        <trans-unit id="0de8e98595413448f2b535870f8da207b8048237" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;write file&quot; operation, but before the corresponding file has been</source>
          <target state="translated">ファイルへの書き込み」操作中または操作後に、対応するファイルが作成される前にシステム障害が発生した場合</target>
        </trans-unit>
        <trans-unit id="12d84c274c03171c71b26275c99f75f3392362a6" translate="yes" xml:space="preserve">
          <source>If a system failure occurs on a system that supports the</source>
          <target state="translated">をサポートしているシステムでシステム障害が発生した場合</target>
        </trans-unit>
        <trans-unit id="70f739b455c168080412690c97f5940222b8f766" translate="yes" xml:space="preserve">
          <source>If a system supports</source>
          <target state="translated">システムが</target>
        </trans-unit>
        <trans-unit id="ec9800aa0fd4fbf6e94d5e57566c8304e2f2782b" translate="yes" xml:space="preserve">
          <source>If a system supports the</source>
          <target state="translated">をサポートしているシステムであれば</target>
        </trans-unit>
        <trans-unit id="16f55a3959edd0a92c0395b9cf4c3468da074f4f" translate="yes" xml:space="preserve">
          <source>If a table contains a column of type &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, then that column becomes an alias for the ROWID. You can then access the ROWID using any of four different names, the original three names described above or the name given to the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column. All these names are aliases for one another and work equally well in any context.</source>
          <target state="translated">テーブルに&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;型の列が含まれている場合、その列はROWIDのエイリアスになります。その後、4つの異なる名前、上記の元の3つの名前、または&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列に指定された名前を使用して、ROWIDにアクセスできます。これらの名前はすべて相互のエイリアスであり、どのようなコンテキストでも同様に機能します。</target>
        </trans-unit>
        <trans-unit id="a73b6736040e74c7d625fd213eca9757c75eee19" translate="yes" xml:space="preserve">
          <source>If a table has a single column primary key and the declared type of that column is &quot;INTEGER&quot; and the table is not a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, then the column is known as an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;. See &lt;a href=&quot;lang_createtable#rowid&quot;&gt;below&lt;/a&gt; for a description of the special properties and behaviors associated with an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;.</source>
          <target state="translated">テーブルに単一列の主キーがあり、その列の宣言されたタイプが「INTEGER」であり、テーブルが&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルでない場合、その列は&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;と呼ばれます。&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEYに&lt;/a&gt;関連する特別なプロパティと動作の説明については、&lt;a href=&quot;lang_createtable#rowid&quot;&gt;以下&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="5e353db8a7a970978b864076f23349bbe29b3cd1" translate="yes" xml:space="preserve">
          <source>If a term in X is of the form &quot;z IS NOT NULL&quot; and if a term in W is a comparison operator on &quot;z&quot; other than &quot;IS&quot;, then those terms match.</source>
          <target state="translated">X の項が &quot;z IS NOT NULL&quot; の形式であり、W の項が &quot;IS&quot; 以外の &quot;z&quot; の比較演算子である場合、それらの項は一致します。</target>
        </trans-unit>
        <trans-unit id="d7704041f8ff8a11a4c662eef3d671025a3e5ebe" translate="yes" xml:space="preserve">
          <source>If a term of the WHERE clause is of the following form:</source>
          <target state="translated">WHERE句の項が以下の形式の場合。</target>
        </trans-unit>
        <trans-unit id="e5d671a1040d0448cbcd3997833359da102571a4" translate="yes" xml:space="preserve">
          <source>If a transaction involves multiple databases, then a more complex commit sequence is used, as follows:</source>
          <target state="translated">トランザクションが複数のデータベースを含む場合は、以下のように、より複雑なコミットシーケンスが使用されます。</target>
        </trans-unit>
        <trans-unit id="1b08d45fd51c4591fce14d3b424e9dccc579bef5" translate="yes" xml:space="preserve">
          <source>If a transaction is aborted due to an application crash, an operating system crash, or a hardware power failure or crash, then the database may be left in an inconsistent state. The next time SQLite attempts to open the database file, the presence of the rollback journal file will be detected and the journal will be automatically played back to restore the database to its state at the start of the incomplete transaction.</source>
          <target state="translated">アプリケーションのクラッシュ、オペレーティングシステムのクラッシュ、またはハードウェアの電源障害やクラッシュによってトランザクションが中断された場合、データベースは矛盾した状態のままになることがあります。次回SQLiteがデータベースファイルを開こうとすると、ロールバックジャーナルファイルの存在が検出され、ジャーナルが自動的に再生されてデータベースが不完全なトランザクションの開始時の状態に復元されます。</target>
        </trans-unit>
        <trans-unit id="b139c7ece8944c0ce3ad448cfb0c14ea14a36c67" translate="yes" xml:space="preserve">
          <source>If a write-transaction is open on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D when the &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk. A dirty page may be in use if a database cursor created by an active SQL statement is reading from it, or if it is page 1 of a database file (page 1 is always &quot;in use&quot;). The &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface flushes caches for all schemas - &quot;main&quot;, &quot;temp&quot;, and any &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; databases.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush（D）&lt;/a&gt;インターフェースが呼び出されたときに&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt; Dで書き込みトランザクションが開いている場合、現在使用されていないページャーキャッシュ内のダーティページがディスクに書き込まれます。アクティブなSQLステートメントによって作成されたデータベースカーソルがダーティページを読み取っている場合、またはダーティページがデータベースファイルのページ1である場合（ページ1は常に「使用中」）、ダーティページが使用されている可能性があります。&lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush（D）&lt;/a&gt;インターフェースは、すべてのスキーマのキャッシュをフラッシュ- 「メイン」、「TEMP」、および任意の&lt;a href=&quot;lang_attach&quot;&gt;添付の&lt;/a&gt;データベース。</target>
        </trans-unit>
        <trans-unit id="94598ac271e5cdca4a0d9c950ece2e2fde3c85ae" translate="yes" xml:space="preserve">
          <source>If a write-transaction is open on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D when the &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk. A dirty page may be in use if a database cursor created by an active SQL statement is reading from it, or if it is page 1 of a database file (page 1 is always &quot;in use&quot;). The &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface flushes caches for all schemas - &quot;main&quot;, &quot;temp&quot;, and any &lt;a href=&quot;../lang_attach&quot;&gt;attached&lt;/a&gt; databases.</source>
          <target state="translated">&lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush（D）&lt;/a&gt;インターフェースが呼び出されたときに&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt; Dで書き込みトランザクションが開いている場合、現在使用されていないページャーキャッシュ内のダーティページがディスクに書き込まれます。アクティブなSQLステートメントによって作成されたデータベースカーソルがダーティページを読み取っている場合、またはダーティページがデータベースファイルのページ1である場合（ページ1は常に「使用中」）、ダーティページが使用されている可能性があります。&lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush（D）&lt;/a&gt;インターフェースは、すべてのスキーマのキャッシュをフラッシュ- 「メイン」、「TEMP」、および任意の&lt;a href=&quot;../lang_attach&quot;&gt;添付の&lt;/a&gt;データベース。</target>
        </trans-unit>
        <trans-unit id="9d687ea67d2673f11d5b429c0195a169c2caa77a" translate="yes" xml:space="preserve">
          <source>If a write-transaction is started and the Vdbe.usesStmtJournal flag is true (this flag is set if the Vdbe may modify more than one row and may throw an ABORT exception), a statement transaction may also be opened. More specifically, a statement transaction is opened iff the database connection is currently not in autocommit mode, or if there are other active statements. A statement transaction allows the changes made by this VDBE to be rolled back after an error without having to roll back the entire transaction. If no error is encountered, the statement transaction will automatically commit when the VDBE halts.</source>
          <target state="translated">書き込みトランザクションが開始され、Vdbe.usesStmtJournalフラグがtrueの場合(このフラグは、Vdbeが複数の行を変更し、ABORT例外を投げる可能性がある場合に設定されます)、ステートメントトランザクションもオープンされる可能性があります。より具体的には、データベース接続が現在オートコミットモードではない場合、または他にアクティブなステートメントがある場合、ステートメント・トランザクションが開かれます。ステートメント・トランザクションは、トランザクション全体をロールバックすることなく、エラー後にこのVDBEによって行われた変更をロールバックすることを可能にする。エラーが発生しなかった場合、ステートメント・トランザクションはVDBEが停止したときに自動的にコミットされる。</target>
        </trans-unit>
        <trans-unit id="7e874d6b40d57619d9fa5fb8dd75a92de53ed059" translate="yes" xml:space="preserve">
          <source>If all three of the steps enumerated above are executed successfully, then it is safe to modify the content of the</source>
          <target state="translated">上に列挙した3つのステップのすべてが正常に実行された場合、それは</target>
        </trans-unit>
        <trans-unit id="8a9cfb8256efd43eaa74ef64ff226cfbf427865f" translate="yes" xml:space="preserve">
          <source>If an &quot;ALTER TABLE ... RENAME TO&quot; command is used to rename a table that is the parent table of one or more foreign key constraints, the definitions of the foreign key constraints are modified to refer to the parent table by its new name. The text of the child CREATE TABLE statement or statements stored in the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema table&lt;/a&gt; are modified to reflect the new parent table name.</source>
          <target state="translated">If an &quot;ALTER TABLE ... RENAME TO&quot; command is used to rename a table that is the parent table of one or more foreign key constraints, the definitions of the foreign key constraints are modified to refer to the parent table by its new name. The text of the child CREATE TABLE statement or statements stored in the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema table&lt;/a&gt; are modified to reflect the new parent table name.</target>
        </trans-unit>
        <trans-unit id="76124bb023821e31ac6f5cbf1f8b54083a3ec643" translate="yes" xml:space="preserve">
          <source>If an &quot;ALTER TABLE ... RENAME TO&quot; command is used to rename a table that is the parent table of one or more foreign key constraints, the definitions of the foreign key constraints are modified to refer to the parent table by its new name. The text of the child CREATE TABLE statement or statements stored in the sqlite_master table are modified to reflect the new parent table name.</source>
          <target state="translated">ALTER TABLE ...RENAME TO &quot;コマンドが、1つ以上の外部キー制約の親テーブルであるテーブルの名前を変更するために使用された場合、外部キー制約の定義は、新しい名前で親テーブルを参照するように変更されます。sqlite_masterテーブルに格納されている子CREATE TABLE文またはステートメントのテキストは、新しい親テーブル名を反映するように変更されます。</target>
        </trans-unit>
        <trans-unit id="7603e9a69b7a72c62bbc679327133633953ff9aa" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is destroyed while a transaction is open, the transaction is automatically rolled back.</source>
          <target state="translated">場合は&lt;a href=&quot;#sqlite3&quot;&gt;sqlite3の&lt;/a&gt;トランザクションが開いている間は、オブジェクトが破壊され、トランザクションが自動的にロールバックされます。</target>
        </trans-unit>
        <trans-unit id="53a3481d0fa9e30b2f0d27a6044ee94e1a62bb9b" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; occurs within a trigger then this routine will return the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the inserted row as long as the trigger is running. Once the trigger program ends, the value returned by this routine reverts to what it was before the trigger was fired.</source>
          <target state="translated">トリガー内で&lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;が発生した場合、このルーチンは、トリガーが実行されている限り、挿入された行の&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;を返します。トリガープログラムが終了すると、このルーチンによって返される値は、トリガーが起動される前の値に戻ります。</target>
        </trans-unit>
        <trans-unit id="877e1b4a7430ba11b48b32c5598ad0c65dc34442" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; occurs within a trigger then this routine will return the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the inserted row as long as the trigger is running. Once the trigger program ends, the value returned by this routine reverts to what it was before the trigger was fired.</source>
          <target state="translated">トリガー内で&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;が発生した場合、このルーチンは、トリガーが実行されている限り、挿入された行の&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;を返します。トリガープログラムが終了すると、このルーチンによって返される値は、トリガーが起動される前の値に戻ります。</target>
        </trans-unit>
        <trans-unit id="b95cb40fc8352b696796b3bff79e2f006b1ce07a" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is destroyed while a transaction is open, the transaction is automatically rolled back.</source>
          <target state="translated">場合は&lt;a href=&quot;sqlite3&quot;&gt;sqlite3の&lt;/a&gt;トランザクションが開いている間は、オブジェクトが破壊され、トランザクションが自動的にロールバックされます。</target>
        </trans-unit>
        <trans-unit id="9f62d9384e44621989efc3c00f1a3ba721b2e39d" translate="yes" xml:space="preserve">
          <source>If an FTS5 table is configured with columnsize=0 but is not a &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless table&lt;/a&gt;, the xColumnSize API function still works, but runs much more slowly. In this case, instead of reading the value to return directly from the database, it reads the text value itself and count the tokens within it on demand.</source>
          <target state="translated">FTS5テーブルがcolumnsize = 0で構成されているが、コンテンツのない&lt;a href=&quot;fts5#contentless_tables&quot;&gt;テーブル&lt;/a&gt;ではない場合、xColumnSize API関数は引き続き機能しますが、実行速度ははるかに遅くなります。この場合、データベースから直接返す値を読み取る代わりに、テキスト値自体を読み取り、要求に応じてその中のトークンをカウントします。</target>
        </trans-unit>
        <trans-unit id="a593df8166351f80d07eb58cb262614d9dbc8634" translate="yes" xml:space="preserve">
          <source>If an INSERT statement attempts to insert a NULL value into a rowid or integer primary key column, the system chooses an integer value to use as the rowid automatically. A detailed description of how this is done is provided &lt;a href=&quot;autoinc&quot;&gt;separately&lt;/a&gt;.</source>
          <target state="translated">INSERTステートメントがNULL値をROWIDまたは整数の主キー列に挿入しようとした場合、システムは、ROWIDとして使用する整数値を自動的に選択します。これがどのように行われるかの詳細な説明は、&lt;a href=&quot;autoinc&quot;&gt;別途&lt;/a&gt;提供されます。</target>
        </trans-unit>
        <trans-unit id="ba4158b1467dce3a1f2ceab9abb8de00b0fe4463" translate="yes" xml:space="preserve">
          <source>If an ORDER BY clause is present, it determines the order in which rows are extracted from the queue in step 2a. If there is no ORDER BY clause, then the order in which rows are extracted is undefined. (In the current implementation, the queue becomes a FIFO if the ORDER BY clause is omitted, but applications should not depend on that fact since it might change.)</source>
          <target state="translated">ORDER BY句が存在する場合、それはステップ2aでキューから行が抽出される順序を決定します。ORDER BY 句が存在しない場合、行が抽出される順序は未定義です。(現在の実装では、ORDER BY句が省略された場合、キューはFIFOになりますが、アプリケーションは変更される可能性があるので、その事実に依存すべきではありません)。</target>
        </trans-unit>
        <trans-unit id="22141c686821647d4155d6b151a8d8fa154cd1a8" translate="yes" xml:space="preserve">
          <source>If an SQL operation is very nearly finished at the time when sqlite3_interrupt() is called, then it might not have an opportunity to be interrupted and might continue to completion.</source>
          <target state="translated">sqlite3_interrupt()が呼ばれた時点でSQL操作がほぼ終了している場合は、中断する機会がなく、完了まで継続する可能性があります。</target>
        </trans-unit>
        <trans-unit id="923eabd2cf996c975383b0dccd3e5fb8dc063dde" translate="yes" xml:space="preserve">
          <source>If an SQL statement is limited to be a million bytes in length, then obviously you will not be able to insert multi-million byte strings by embedding them as literals inside of INSERT statements. But you should not do that anyway. Use host &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; for your data. Prepare short SQL statements like this:</source>
          <target state="translated">SQLステートメントの長さが100万バイトに制限されている場合は、INSERTステートメント内にリテラルとして埋め込んでも、数百万バイトの文字列を挿入することはできません。しかし、とにかくそれを行うべきではありません。データにホスト&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメータ&lt;/a&gt;を使用します。次のような短いSQLステートメントを準備します。</target>
        </trans-unit>
        <trans-unit id="a519000750401db43c985f6fefc862d71c74bede" translate="yes" xml:space="preserve">
          <source>If an SQL table is created using the &quot;WITHOUT ROWID&quot; clause at the end of its CREATE TABLE statement, then that table is a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table and uses a different on-disk representation. A WITHOUT ROWID table uses an index b-tree rather than a table b-tree for storage. The key for each entry in the WITHOUT ROWID b-tree is a record composed of the columns of the PRIMARY KEY followed by all remaining columns of the table. The primary key columns appear in the order they they were declared in the PRIMARY KEY clause and the remaining columns appear in the order they occur in the CREATE TABLE statement.</source>
          <target state="translated">SQLテーブルがCREATE TABLEステートメントの最後にある「WITHOUT ROWID」句を使用して作成されている場合、そのテーブルは&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルであり、別のディスク上の表現を使用します。WITHOUT ROWIDテーブルは、テーブルbツリーではなくインデックスbツリーを使用して格納します。WITHOUT ROWID Bツリーの各エントリのキーは、PRIMARY KEYの列とそれに続くテーブルの残りのすべての列で構成されるレコードです。主キー列は、PRIMARY KEY句で宣言された順序で表示され、残りの列は、CREATE TABLEステートメントで発生した順序で表示されます。</target>
        </trans-unit>
        <trans-unit id="7a1f15ef308e23ec2fc80a29e25882265ebf0786" translate="yes" xml:space="preserve">
          <source>If an UPDATE statement attempts to set an integer primary key or rowid column to a NULL or blob value, or to a string or real value that cannot be losslessly converted to an integer, a &quot;datatype mismatch&quot; error occurs and the statement is aborted. If an INSERT statement attempts to insert a blob value, or a string or real value that cannot be losslessly converted to an integer into an integer primary key or rowid column, a &quot;datatype mismatch&quot; error occurs and the statement is aborted.</source>
          <target state="translated">UPDATE 文が、整数の主キーまたは rowid 列を NULL または blob 値、または可逆的に整数に変換できない文字列または実数値に設定しようとすると、&quot;datatype mismatch&quot; エラーが発生し、文が中断されます。INSERT 文が、ブロブ値、または可逆的に整数に変換できない文字列または実数値を整数の主キーまたは rowid 列に挿入しようとすると、&quot;datatype mismatch&quot; エラーが発生し、文が中断されます。</target>
        </trans-unit>
        <trans-unit id="284b34da69fbf9cd89926df318af7634184253b9" translate="yes" xml:space="preserve">
          <source>If an UPDATE statement has a LIMIT clause, the maximum number of rows that will be updated is found by evaluating the accompanying expression and casting it to an integer value. A negative value is interpreted as &quot;no limit&quot;.</source>
          <target state="translated">UPDATE文にLIMIT句がある場合、更新される行の最大数は、付属の式を評価して整数値にキャストすることで求められます。負の値は「制限なし」と解釈されます。</target>
        </trans-unit>
        <trans-unit id="35654cca0e06875d8f71c06cdb825a502007ac27" translate="yes" xml:space="preserve">
          <source>If an application issues a SELECT statement on a single table like &quot;</source>
          <target state="translated">アプリケーションが、&quot; のような単一のテーブルに対して SELECT 文を発行した場合</target>
        </trans-unit>
        <trans-unit id="3c9847a3fc8345f21ef2aae877b6da29936db6dc" translate="yes" xml:space="preserve">
          <source>If an application puts SQLite in &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; using the pragma:</source>
          <target state="translated">アプリケーションがプラグマを使用してSQLiteを&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;排他ロックモードにする&lt;/a&gt;場合：</target>
        </trans-unit>
        <trans-unit id="16930c87a89e5aa4dacec21b97a534c286412312" translate="yes" xml:space="preserve">
          <source>If an application using asynchronous IO executes transactions in quick succession, other database users may be effectively locked out of the database. This is because when a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; is executed, a database lock is established immediately. But when the corresponding COMMIT or ROLLBACK occurs, the lock is not released until the relevant part of the write-queue has been flushed through. As a result, if a COMMIT is followed by a BEGIN before the write-queue is flushed through, the database is never unlocked,preventing other processes from accessing the database.</source>
          <target state="translated">非同期IOを使用するアプリケーションが連続してトランザクションを実行すると、他のデータベースユーザーがデータベースから事実上ロックアウトされる可能性があります。これは、&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;が実行されると、データベースロックがすぐに確立されるためです。ただし、対応するCOMMITまたはROLLBACKが発生すると、書き込みキューの関連部分がフラッシュされるまで、ロックは解放されません。その結果、書き込みキューがフラッシュされる前にCOMMITの後にBEGINが続く場合、データベースはロック解除されず、他のプロセスがデータベースにアクセスできなくなります。</target>
        </trans-unit>
        <trans-unit id="dec67a679cc10b4fb4ca0df679f1b42a8a809bf0" translate="yes" xml:space="preserve">
          <source>If an attempt to acquire a</source>
          <target state="translated">を取得しようとすると</target>
        </trans-unit>
        <trans-unit id="ae2dad7a2ac6f9639d4f707a82a9b585c9a56bd8" translate="yes" xml:space="preserve">
          <source>If an attempt to upgrade to an</source>
          <target state="translated">にアップグレードしようとすると</target>
        </trans-unit>
        <trans-unit id="0f4ee50fd2b5b886cf93345554e2cb331273f09d" translate="yes" xml:space="preserve">
          <source>If an error (e.g. an OOM condition) occurs within this function, the auxiliary data is set to NULL and an error code returned. If the xDelete parameter was not NULL, it is invoked on the auxiliary data pointer before returning.</source>
          <target state="translated">この関数内でエラー(OOM条件など)が発生した場合、補助データはNULLに設定され、エラーコードが返されます。xDeleteパラメータがNULLでなかった場合は、返す前に補助データポインタで呼び出されます。</target>
        </trans-unit>
        <trans-unit id="8045cc0ef3fd13ca44d5e4369a94674b9f7300cd" translate="yes" xml:space="preserve">
          <source>If an error occurs in any of the three main backup API routines then the &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; and &lt;a href=&quot;c3ref/errcode&quot;&gt;message&lt;/a&gt; are attached to the destination &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. Additionally, if &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; encounters an error, then the &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned by both the &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; call itself, and by the subsequent call to &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt;. So a call to &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt; does not overwrite an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; stored in the destination &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; by &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt;. This feature is used in the example code to reduce amount of error handling required. The return values of the &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; and &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt; calls are ignored and the error code indicating the success or failure of the copy operation collected from the destination &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; afterward.</source>
          <target state="translated">3つのメインバックアップAPIルーチンのいずれかでエラーが発生した場合、エラー&lt;a href=&quot;rescode&quot;&gt;コード&lt;/a&gt;と&lt;a href=&quot;c3ref/errcode&quot;&gt;メッセージ&lt;/a&gt;が宛先&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続に&lt;/a&gt;添付されます。さらに、もし&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step（）&lt;/a&gt;次に、エラーが発生した&lt;a href=&quot;rescode&quot;&gt;エラーコードが&lt;/a&gt;両方によって返され&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;（）sqlite3_backup_step&lt;/a&gt;自体を呼び出し、以降の呼び出しによって&lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish（） &lt;/a&gt;。そうへの呼び出し&lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish（）が&lt;/a&gt;上書きされない&lt;a href=&quot;rescode&quot;&gt;エラーコード&lt;/a&gt;先に格納された&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;によって&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_stepを（）&lt;/a&gt;。この機能はサンプルコードで使用され、必要なエラー処理の量を減らします。&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step（）&lt;/a&gt;および&lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish（）&lt;/a&gt;呼び出しの戻り値は無視され、コピー先の&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;から収集されたコピー操作の成功または失敗を示すエラーコードが後で収集されます。</target>
        </trans-unit>
        <trans-unit id="e8416d9f169797cd1d1df3d689a0f3981d1e1914" translate="yes" xml:space="preserve">
          <source>If an error occurs while evaluating the SQL statements passed into sqlite3_exec(), then execution of the current statement stops and subsequent statements are skipped. If the 5th parameter to sqlite3_exec() is not NULL then any error message is written into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and passed back through the 5th parameter. To avoid memory leaks, the application should invoke &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; on error message strings returned through the 5th parameter of sqlite3_exec() after the error message string is no longer needed. If the 5th parameter to sqlite3_exec() is not NULL and no errors occur, then sqlite3_exec() sets the pointer in its 5th parameter to NULL before returning.</source>
          <target state="translated">sqlite3_exec（）に渡されたSQLステートメントの評価中にエラーが発生した場合、現在のステートメントの実行は停止し、後続のステートメントはスキップされます。 sqlite3_exec（）の5番目のパラメーターがNULLでない場合、エラーメッセージは&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;から取得したメモリに書き込まれ、5番目のパラメーターを介して渡されます。メモリリークを回避するために、アプリケーションは、エラーメッセージ文字列が不要になった後、sqlite3_exec（）の5番目のパラメータを通じて返されるエラーメッセージ文字列で&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;を呼び出す必要があります。 sqlite3_exec（）の5番目のパラメーターがNULLではなく、エラーが発生しない場合、sqlite3_exec（）は5番目のパラメーターのポインターをNULLに設定してから戻ります。</target>
        </trans-unit>
        <trans-unit id="67c739deca1fc659fe9011cffdf430f71e9a737b" translate="yes" xml:space="preserve">
          <source>If an error occurs while evaluating the SQL statements passed into sqlite3_exec(), then execution of the current statement stops and subsequent statements are skipped. If the 5th parameter to sqlite3_exec() is not NULL then any error message is written into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and passed back through the 5th parameter. To avoid memory leaks, the application should invoke &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; on error message strings returned through the 5th parameter of sqlite3_exec() after the error message string is no longer needed. If the 5th parameter to sqlite3_exec() is not NULL and no errors occur, then sqlite3_exec() sets the pointer in its 5th parameter to NULL before returning.</source>
          <target state="translated">sqlite3_exec（）に渡されたSQLステートメントの評価中にエラーが発生した場合、現在のステートメントの実行は停止し、後続のステートメントはスキップされます。 sqlite3_exec（）の5番目のパラメーターがNULLでない場合、エラーメッセージは&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;から取得したメモリに書き込まれ、5番目のパラメーターを介して渡されます。メモリリークを回避するために、アプリケーションは、エラーメッセージ文字列が不要になった後、sqlite3_exec（）の5番目のパラメータを通じて返されるエラーメッセージ文字列で&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;を呼び出す必要があります。 sqlite3_exec（）の5番目のパラメーターがNULLではなく、エラーが発生しない場合、sqlite3_exec（）は5番目のパラメーターのポインターをNULLに設定してから戻ります。</target>
        </trans-unit>
        <trans-unit id="194a0b44e46a56e474b265407cd79a961ab1ee3b" translate="yes" xml:space="preserve">
          <source>If an error occurs within sqlite3_backup_init(D,N,S,M), then NULL is returned and an error code and error message are stored in the destination &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D. The error code and message for the failed call to sqlite3_backup_init() can be retrieved using the &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;, and/or &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt; functions. A successful call to sqlite3_backup_init() returns a pointer to an &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object. The &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object may be used with the sqlite3_backup_step() and sqlite3_backup_finish() functions to perform the specified backup operation.</source>
          <target state="translated">sqlite3_backup_init（D、N、S、M）内でエラーが発生した場合、NULLが返され、エラーコードとエラーメッセージが宛先&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt; Dに格納されます。sqlite3_backup_init（）の呼び出しが失敗した場合のエラーコードとメッセージは&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;、または&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg16（）&lt;/a&gt;関数を使用して取得する。 sqlite3_backup_init（）の呼び出しが成功すると、&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt;オブジェクトへのポインタが返されます。&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backupの&lt;/a&gt;オブジェクトが指定されたバックアップ操作を実行するsqlite3_backup_step（）とsqlite3_backup_finish（）関数で使用されてもよいです。</target>
        </trans-unit>
        <trans-unit id="1200818faf5a8fe2f6854c6a6851d33b2f623b3d" translate="yes" xml:space="preserve">
          <source>If an error occurs within sqlite3_backup_init(D,N,S,M), then NULL is returned and an error code and error message are stored in the destination &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D. The error code and message for the failed call to sqlite3_backup_init() can be retrieved using the &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt;, &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;, and/or &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt; functions. A successful call to sqlite3_backup_init() returns a pointer to an &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object. The &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object may be used with the sqlite3_backup_step() and sqlite3_backup_finish() functions to perform the specified backup operation.</source>
          <target state="translated">sqlite3_backup_init（D、N、S、M）内でエラーが発生した場合、NULLが返され、エラーコードとエラーメッセージが宛先&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt; Dに格納されます。sqlite3_backup_init（）の呼び出しが失敗した場合のエラーコードとメッセージは&lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;、&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;、または&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg16（）&lt;/a&gt;関数を使用して取得する。 sqlite3_backup_init（）の呼び出しが成功すると、&lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt;オブジェクトへのポインタが返されます。&lt;a href=&quot;backup&quot;&gt;sqlite3_backupの&lt;/a&gt;オブジェクトが指定されたバックアップ操作を実行するsqlite3_backup_step（）とsqlite3_backup_finish（）関数で使用されてもよいです。</target>
        </trans-unit>
        <trans-unit id="100ded69e0a780b44961df68d1032c0e7c075797" translate="yes" xml:space="preserve">
          <source>If an error occurs, an SQLite error code is returned and the output variables (*pnData) and (*ppData) are set to 0. Otherwise, SQLITE_OK is returned and the output variables are set to the size of and a pointer to the output buffer, respectively. In this case it is the responsibility of the caller to eventually free the buffer using a call to sqlite3_free().</source>
          <target state="translated">エラーが発生した場合、SQLiteエラーコードが返され、出力変数(*pnData)と(*ppData)に0が設定されます。 そうでなければ、SQLITE_OKが返され、出力変数にはそれぞれ出力バッファのサイズとポインタが設定されます。この場合、最終的にsqlite3_free()を呼び出してバッファを解放するのは呼び出し元の責任です。</target>
        </trans-unit>
        <trans-unit id="622e26e115262f02ac7f60da2462323cdc540b9f" translate="yes" xml:space="preserve">
          <source>If an error occurs, an SQLite error code is returned. Possible error codes include SQLITE_CORRUPT (if the changeset buffer is corrupt) or SQLITE_NOMEM.</source>
          <target state="translated">エラーが発生した場合、SQLite エラーコードが返されます。考えられるエラーコードには、SQLITE_CORRUPT (チェンジセットバッファが破損している場合)や SQLITE_NOMEM があります。</target>
        </trans-unit>
        <trans-unit id="e455ebdd54ae8a16893e6de74ee6f1db7c5e35d7" translate="yes" xml:space="preserve">
          <source>If an error was encountered within a call to an sqlite3changeset_xxx() function (for example an &lt;a href=&quot;../rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; in &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; or an &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; in &lt;a href=&quot;sqlite3changeset_new&quot;&gt;sqlite3changeset_new()&lt;/a&gt;) then an error code corresponding to that error is returned by this function. Otherwise, SQLITE_OK is returned. This is to allow the following pattern (pseudo-code):</source>
          <target state="translated">エラーがsqlite3changeset_xxx（）関数の呼び出し（例えば内で発生した場合&lt;a href=&quot;../rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt;で&lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）&lt;/a&gt;または&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;における&lt;a href=&quot;sqlite3changeset_new&quot;&gt;（）sqlite3changeset_new&lt;/a&gt;）、そのエラーに対応するエラーコードは、この関数によって返されます。それ以外の場合、SQLITE_OKが返されます。これは、次のパターン（疑似コード）を許可するためのものです。</target>
        </trans-unit>
        <trans-unit id="1bc5bca387ff960fe9687401573a47507a4fa49f" translate="yes" xml:space="preserve">
          <source>If an error was encountered within a call to an sqlite3changeset_xxx() function (for example an &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; in &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; or an &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; in &lt;a href=&quot;#sqlite3changeset_new&quot;&gt;sqlite3changeset_new()&lt;/a&gt;) then an error code corresponding to that error is returned by this function. Otherwise, SQLITE_OK is returned. This is to allow the following pattern (pseudo-code):</source>
          <target state="translated">エラーがsqlite3changeset_xxx（）関数の呼び出し（例えば内で発生した場合&lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt;で&lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）&lt;/a&gt;または&lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;における&lt;a href=&quot;#sqlite3changeset_new&quot;&gt;（）sqlite3changeset_new&lt;/a&gt;）、そのエラーに対応するエラーコードは、この関数によって返されます。それ以外の場合、SQLITE_OKが返されます。これは、次のパターン（疑似コード）を許可するためのものです。</target>
        </trans-unit>
        <trans-unit id="1b680ceb7d64040ce2b6564485c5ca5b1c9689a0" translate="yes" xml:space="preserve">
          <source>If an fts5vocab table is created in the temp database, it may be associated with an FTS5 table in any attached database. In order to attach the fts5vocab table to an FTS5 table located in a database other than &quot;temp&quot;, the name of the database is inserted before the FTS5 table name in the CREATE VIRTUAL TABLE arguments. For example:</source>
          <target state="translated">temp データベースに fts5vocab テーブルが作成された場合、どのようなアタッチされたデータベースの FTS5 テーブルにも関連付けることができます。temp」以外のデータベースにあるFTS5テーブルにfts5vocabテーブルをアタッチするには、CREATE VIRTUAL TABLE引数でFTS5テーブル名の前にデータベース名を挿入します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="3334fd5a8f49d3b3b23387e0ded39340f08eab83" translate="yes" xml:space="preserve">
          <source>If an index is available on the ORDER BY column, that index can be used for sorting. Consider the request for all items sorted by &quot;fruit&quot;:</source>
          <target state="translated">ORDER BYカラムにインデックスがある場合、そのインデックスをソートに使用することができます。fruit」でソートされたすべてのアイテムのリクエストを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="7ff3ecb138d9749f1bf1bb734a03098e601b851c" translate="yes" xml:space="preserve">
          <source>If an index is created using a statement like this:</source>
          <target state="translated">このようなステートメントを使用してインデックスを作成した場合。</target>
        </trans-unit>
        <trans-unit id="19ed5776fff64746115879da20e80724a2114442" translate="yes" xml:space="preserve">
          <source>If an instance-list grows so large that it exceeds the &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; limit, FTS3/4 is unable to handle it. FTS5 does not have this problem.</source>
          <target state="translated">インスタンスリストが大きくなり&lt;a href=&quot;limits#max_length&quot;&gt;すぎてSQLITE_MAX_LENGTHの&lt;/a&gt;制限を超えた場合、FTS3 / 4はそれを処理できません。FTS5にはこの問題はありません。</target>
        </trans-unit>
        <trans-unit id="e669868d5fcfe552cb1dbbc9c2998f5505f629e6" translate="yes" xml:space="preserve">
          <source>If an interface fails with SQLITE_MISUSE, that means the interface was invoked incorrectly by the application. In that case, the error code and message may or may not be set.</source>
          <target state="translated">インターフェイスが SQLITE_MISUSE で失敗した場合、それはアプリケーションによってインターフェイスが誤って呼び出されたことを意味します。その場合、エラーコードとメッセージは設定されているか、設定されていないかもしれません。</target>
        </trans-unit>
        <trans-unit id="582fb0780f4838faf9f9c1524bd108b2fc64370c" translate="yes" xml:space="preserve">
          <source>If an out-of-memory error occurs, then the return value from these routines is the same as if the column had contained an SQL NULL value. Valid SQL NULL returns can be distinguished from out-of-memory errors by invoking the &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; immediately after the suspect return value is obtained and before any other SQLite interface is called on the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">メモリ不足エラーが発生した場合、これらのルーチンからの戻り値は、列にSQL NULL値が含まれていた場合と同じです。有効なSQL NULL戻り値は、疑わしい戻り値が取得された直後で、同じ&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続で&lt;/a&gt;他のSQLiteインターフェイスが呼び出される前に&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;を呼び出すことにより、メモリ不足エラーと区別できます。</target>
        </trans-unit>
        <trans-unit id="5851016a3fb15ec26147b80722e832005884d3e4" translate="yes" xml:space="preserve">
          <source>If an out-of-memory error occurs, then the return value from these routines is the same as if the column had contained an SQL NULL value. Valid SQL NULL returns can be distinguished from out-of-memory errors by invoking the &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; immediately after the suspect return value is obtained and before any other SQLite interface is called on the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">メモリ不足エラーが発生した場合、これらのルーチンからの戻り値は、列にSQL NULL値が含まれていた場合と同じです。有効なSQL NULL戻り値は、疑わしい戻り値が取得された直後で、同じ&lt;a href=&quot;sqlite3&quot;&gt;データベース接続で&lt;/a&gt;他のSQLiteインターフェイスが呼び出される前に&lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;を呼び出すことにより、メモリ不足エラーと区別できます。</target>
        </trans-unit>
        <trans-unit id="53a860ff4ceaa780f514879a263f3e2bd7a64b45" translate="yes" xml:space="preserve">
          <source>If an sqlite3_exec() callback returns non-zero, the sqlite3_exec() routine returns SQLITE_ABORT without invoking the callback again and without running any subsequent SQL statements.</source>
          <target state="translated">sqlite3_exec()コールバックが0以外の値を返した場合、sqlite3_exec()ルーチンは、コールバックを再度呼び出さず、それ以降のSQL文を実行せずにSQLITE_ABORTを返します。</target>
        </trans-unit>
        <trans-unit id="86f2a1856f49f287cef6815b989e3bcfc9f7c019" translate="yes" xml:space="preserve">
          <source>If an update is only partially applied to the target database by the time sqlite3rbu_close() is called, state information is saved within the state database if it exists, or otherwise in the RBU database. This allows subsequent processes to automatically resume the RBU update from where it left off. If state information is stored in the RBU database, it can be removed by dropping all tables whose names begin with &quot;rbu_&quot;.</source>
          <target state="translated">sqlite3rbu_close()が呼び出されるまでにターゲット・データベースに更新が部分的にしか適用されない場合、状態情報は状態データベースが存在する場合は状態データベース内に、そうでない場合はRBUデータベース内に保存されます。これにより、後続のプロセスは、RBU更新を中断したところから自動的に再開することができます。状態情報がRBUデータベースに保存されている場合、名前が &quot;rbu_&quot;で始まるすべてのテーブルを削除することで削除することができる。</target>
        </trans-unit>
        <trans-unit id="bd175412c5f187514ee87168844f1bedfa975635" translate="yes" xml:space="preserve">
          <source>If an xToken() callback returns any value other than SQLITE_OK, then the tokenization should be abandoned and the xTokenize() method should immediately return a copy of the xToken() return value. Or, if the input buffer is exhausted, xTokenize() should return SQLITE_OK. Finally, if an error occurs with the xTokenize() implementation itself, it may abandon the tokenization and return any error code other than SQLITE_OK or SQLITE_DONE.</source>
          <target state="translated">xToken()コールバックが SQLITE_OK 以外の値を返す場合は、トークン化を放棄して xTokenize()メソッドは直ちに xToken()の戻り値のコピーを返すべきです。あるいは、入力バッファを使い切った場合は、xTokenize()は SQLITE_OK を返すべきです。最後に、xTokenize()の実装自体にエラーが発生した場合、トークン化を放棄して SQLITE_OK または SQLITE_DONE 以外のエラーコードを返すことがあります。</target>
        </trans-unit>
        <trans-unit id="0be452758cf5838f411f1a08b26770962254070e" translate="yes" xml:space="preserve">
          <source>If and only if the previously described conversion of OR to an IN operator does not work, the second OR-clause optimization is attempted. Suppose the OR clause consists of multiple subterms as follows:</source>
          <target state="translated">前述のORからIN演算子への変換がうまくいかない場合にのみ、2番目のOR句の最適化を試みます。OR句が以下のように複数のサブタームで構成されているとします。</target>
        </trans-unit>
        <trans-unit id="1d92fd7f31be8d1f3061a17050b41ab1479f4bcd" translate="yes" xml:space="preserve">
          <source>If another database connection has the database mode open in &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; then all queries against the database will return &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. Both Chrome and Firefox open their database files in exclusive locking mode, so attempts to read Chrome or Firefox databases while the applications are running will run into this problem, for example.</source>
          <target state="translated">別のデータベース接続がデータベースモードを&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;排他ロックモードで&lt;/a&gt;開いている場合、データベースに対するすべてのクエリは&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;を返します。ChromeとFirefoxはどちらもデータベースファイルを排他ロックモードで開くため、たとえば、アプリケーションの実行中にChromeまたはFirefoxデータベースを読み取ろうとすると、この問題が発生します。</target>
        </trans-unit>
        <trans-unit id="52c07a908a81f106b3dd1bc1b1492081c7a35d47" translate="yes" xml:space="preserve">
          <source>If another thread changes the autocommit status of the database connection while this routine is running, then the return value is undefined.</source>
          <target state="translated">このルーチンの実行中に別のスレッドがデータベース接続のオートコミット状態を変更した場合、戻り値は未定義です。</target>
        </trans-unit>
        <trans-unit id="8503a498072091f7cabc2db6a10e976de9bc12b1" translate="yes" xml:space="preserve">
          <source>If another thread or process writes to the source database while this function is sleeping, then SQLite detects this and usually restarts the backup process when sqlite3_backup_step() is next called. There is one exception to this rule: If the source database is not an in-memory database, and the write is performed from within the same process as the backup operation and uses the same database handle (pDb), then the destination database (the one opened using connection pFile) is automatically updated along with the source. The backup process may then be continued after the sqlite3_sleep() call returns as if nothing had happened.</source>
          <target state="translated">この関数がスリープしている間に別のスレッドやプロセスがソース・データベースに書き込みを行った場合、SQLiteはこれを検出し、sqlite3_backup_step()が次に呼び出されたときに通常はバックアップ・プロセスを再起動します。このルールには1つの例外があります:ソースデータベースがインメモリデータベースではなく、書き込みがバックアップ処理と同じプロセス内で行われ、同じデータベースハンドル(pDb)を使用している場合、宛先データベース(接続pFileを使用してオープンされたデータベース)はソースと共に自動的に更新されます。バックアップ処理はsqlite3_sleep()コールが何も起きなかったかのように戻った後も継続されます。</target>
        </trans-unit>
        <trans-unit id="6abf22da0f107c51712228d5db063535c6a4d21a" translate="yes" xml:space="preserve">
          <source>If any application-defined SQL functions have potentially dangerous side-effects, or if they could potentially leak sensitive information to an attacker if misused, then tag those functions using the &lt;a href=&quot;c3ref/c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; option on the &quot;enc&quot; parameter. This means that the function can never be run from schema-code even if the trusted-schema option is on.</source>
          <target state="translated">アプリケーション定義のSQL関数に潜在的に危険な副作用がある場合、または悪用された場合に機密情報が攻撃者に漏洩する可能性がある場合は、「enc」パラメーターの&lt;a href=&quot;c3ref/c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;オプションを使用してそれらの関数にタグを付けます。これは、trusted-schemaオプションがオンになっている場合でも、関数をスキーマコードから実行できないことを意味します。</target>
        </trans-unit>
        <trans-unit id="452fe80b19e0f85e5121496bd6edf4647e872526" translate="yes" xml:space="preserve">
          <source>If any checksum is incorrect, the &quot;PRAGMA quick_check&quot; command will find it. To verify that checksums are actually enabled and running, use SQL like the following:</source>
          <target state="translated">チェックサムが正しくない場合は、「PRAGMA quick_check」コマンドで発見します。チェックサムが実際に有効で実行されているかどうかを確認するには、以下のようなSQLを使用します。</target>
        </trans-unit>
        <trans-unit id="b9f8be087686590dab771595e5bd54b7d246dba5" translate="yes" xml:space="preserve">
          <source>If any errors are encountered during compilation, an error message is written into memory obtained from &lt;b&gt;malloc&lt;/b&gt; and the 5th parameter is made to point to that memory. If the 5th parameter is NULL, then no error message is generated. If the 5th parameter is not NULL, then the calling function should dispose of the memory containing the error message by calling &lt;b&gt;sqlite_freemem&lt;/b&gt;.</source>
          <target state="translated">コンパイル中にエラーが発生した場合、エラーメッセージが&lt;b&gt;malloc&lt;/b&gt;から取得されたメモリに書き込まれ、5番目のパラメータがそのメモリを指すようになります。 5番目のパラメータがNULLの場合、エラーメッセージは生成されません。 5番目のパラメータがNULLでない場合、呼び出し元の関数は&lt;b&gt;sqlite_freemem&lt;/b&gt;を呼び出して、エラーメッセージを含むメモリを&lt;b&gt;破棄する必要があり&lt;/b&gt;ます。</target>
        </trans-unit>
        <trans-unit id="83125f64332cc16259858298cfafac27aca598bf" translate="yes" xml:space="preserve">
          <source>If any of the special-case entries shows above are omitted, then the value of 100 is used for insertion and deletion and 150 is used for substitution. To disable the default insertion, deletion, and/or substitution set their respective cost to 10000 or more.</source>
          <target state="translated">上記の特殊文字列が省略された場合は、挿入・削除に100、置換に150を使用します。デフォルトの挿入・削除・置換を無効にするには、それぞれのコストを10000以上に設定してください。</target>
        </trans-unit>
        <trans-unit id="8b09289d91105f4036d96455156f97ad8f84efdf" translate="yes" xml:space="preserve">
          <source>If any of the sqlite3_bind_*() routines are called with a NULL pointer for the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; or with a prepared statement for which &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; has been called more recently than &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, then the call will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. If any sqlite3_bind_() routine is passed a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; that has been finalized, the result is undefined and probably harmful.</source>
          <target state="translated">sqlite3_bindのいずれか_ *（）ルーチンがためにNULLポインタで呼び出された場合は&lt;a href=&quot;#sqlite3_stmt&quot;&gt;プリペアドステートメント&lt;/a&gt;またはのために準備されたステートメントで&lt;a href=&quot;#sqlite3_step&quot;&gt;（sqlite3_step）&lt;/a&gt;最近になっ超えると呼ばれてきた&lt;a href=&quot;#sqlite3_reset&quot;&gt;（sqlite3_reset） &lt;/a&gt;、コールは戻ります&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSEを&lt;/a&gt;。 sqlite3_bind_（）ルーチンに、ファイナライズ済みの&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備済みステートメント&lt;/a&gt;が渡された場合、結果は定義されておらず、おそらく有害です。</target>
        </trans-unit>
        <trans-unit id="4d6ffdf1dd2e882d0d92b18297a217958bf3b943" translate="yes" xml:space="preserve">
          <source>If any of the sqlite3_bind_*() routines are called with a NULL pointer for the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; or with a prepared statement for which &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; has been called more recently than &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, then the call will return &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. If any sqlite3_bind_() routine is passed a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; that has been finalized, the result is undefined and probably harmful.</source>
          <target state="translated">sqlite3_bindのいずれか_ *（）ルーチンがためにNULLポインタで呼び出された場合は&lt;a href=&quot;stmt&quot;&gt;プリペアドステートメント&lt;/a&gt;またはのために準備されたステートメントで&lt;a href=&quot;step&quot;&gt;（sqlite3_step）&lt;/a&gt;最近になっ超えると呼ばれてきた&lt;a href=&quot;reset&quot;&gt;（sqlite3_reset） &lt;/a&gt;、コールは戻ります&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSEを&lt;/a&gt;。 sqlite3_bind_（）ルーチンに、ファイナライズ済みの&lt;a href=&quot;stmt&quot;&gt;準備済みステートメント&lt;/a&gt;が渡された場合、結果は定義されておらず、おそらく有害です。</target>
        </trans-unit>
        <trans-unit id="ecc451199e804c2d9bbaab7eeb8ae7260c861c03" translate="yes" xml:space="preserve">
          <source>If any of these options are defined, then the same set of SQLITE_OMIT_* options must also be defined when using the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; tool to generate the parse.c file and when compiling the 'mkkeywordhash' tool which generates the keywordhash.h file. Because of this, these options may only be used when the library is built from canonical source, not from the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. Some SQLITE_OMIT_* options might work, or appear to work, when used with the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. But this is not guaranteed. In general, always compile from canonical sources in order to take advantage of SQLITE_OMIT_* options.</source>
          <target state="translated">これらのオプションのいずれかが定義されている場合、&lt;a href=&quot;lemon&quot;&gt;レモンパーサージェネレーター&lt;/a&gt;ツールを使用してparse.cファイルを生成するとき、およびkeywordhash.hファイルを生成する 'mkkeywordhash'ツールをコンパイルするときに、同じSQLITE_OMIT_ *オプションのセットも定義する必要があります。このため、これらのオプションは、ライブラリが&lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;からではなく、正規のソースから構築されている場合にのみ使用できます。一部のSQLITE_OMIT_ *オプションは、&lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;と一緒に使用すると機能するか、機能しているように見えます。しかし、これは保証されていません。一般に、SQLITE_OMIT_ *オプションを利用するには、常に正規のソースからコンパイルしてください。</target>
        </trans-unit>
        <trans-unit id="066af8ac5653f5f78e3e77b86a9535152f8106eb" translate="yes" xml:space="preserve">
          <source>If any other constraint violation occurs while applying a change (i.e. a UNIQUE, CHECK or NOT NULL constraint), the conflict handler is invoked with CHANGESET_CONSTRAINT as the second argument.</source>
          <target state="translated">変更の適用中に他の制約違反が発生した場合(すなわち、UNIQUE、CHECK、NOT NULL 制約)、第二引数として CHANGESET_CONSTRAINT を使用してコンフリクトハンドラが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="c1ffcbd8edc1e59c920bc1e42ef8ae6a08f1c489" translate="yes" xml:space="preserve">
          <source>If any other error occurs while flushing dirty pages to disk (for example an IO error or out-of-memory condition), then processing is abandoned and an SQLite &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned to the caller immediately.</source>
          <target state="translated">ダーティページをディスクにフラッシュしている間に他のエラー（IOエラーやメモリ不足状態など）が発生した場合、処理は中止され、SQLite &lt;a href=&quot;../rescode&quot;&gt;エラーコード&lt;/a&gt;が呼び出し元にすぐに返されます。</target>
        </trans-unit>
        <trans-unit id="547159ba42f3dd194cd2ac6c73df9dfb51226b89" translate="yes" xml:space="preserve">
          <source>If any other error occurs while flushing dirty pages to disk (for example an IO error or out-of-memory condition), then processing is abandoned and an SQLite &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned to the caller immediately.</source>
          <target state="translated">ダーティページをディスクにフラッシュしている間に他のエラー（IOエラーやメモリ不足状態など）が発生した場合、処理は中止され、SQLite &lt;a href=&quot;rescode&quot;&gt;エラーコード&lt;/a&gt;が呼び出し元にすぐに返されます。</target>
        </trans-unit>
        <trans-unit id="ed9a42f661215804821abb386ff5f31ffa1294e2" translate="yes" xml:space="preserve">
          <source>If any prior errors have occurred while constructing the dynamic string in sqlite3_str X, then the &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method will return an appropriate error code. The &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; following any out-of-memory error, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; if the size of the dynamic string exceeds &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if there have been no errors.</source>
          <target state="translated">sqlite3_str Xで動的文字列を構築しているときに以前のエラーが発生した場合、&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode（X）&lt;/a&gt;メソッドは適切なエラーコードを返します。&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode（X）&lt;/a&gt;メソッド戻り、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;任意のメモリ不足エラー、または以下&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_TOOBIG&lt;/a&gt;動的文字列のサイズを超える場合&lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;、又は&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OKに&lt;/a&gt;エラーがなかった場合。</target>
        </trans-unit>
        <trans-unit id="2797997123bd9f48d4b03d213989316f5ee2db3a" translate="yes" xml:space="preserve">
          <source>If any prior errors have occurred while constructing the dynamic string in sqlite3_str X, then the &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method will return an appropriate error code. The &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method returns &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; following any out-of-memory error, or &lt;a href=&quot;../rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; if the size of the dynamic string exceeds &lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;, or &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if there have been no errors.</source>
          <target state="translated">sqlite3_str Xで動的文字列を構築しているときに以前のエラーが発生した場合、&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode（X）&lt;/a&gt;メソッドは適切なエラーコードを返します。&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode（X）&lt;/a&gt;メソッド戻り、&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;任意のメモリ不足エラー、または以下&lt;a href=&quot;../rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt;動的文字列のサイズを超える場合&lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;、又は&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OKに&lt;/a&gt;エラーがなかった場合。</target>
        </trans-unit>
        <trans-unit id="8cf62e1e5822970ab1a0772544bba1f6a9886bdb" translate="yes" xml:space="preserve">
          <source>If any views refer to table X in a way that is affected by the schema change, then drop those views using &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt; and recreate them with whatever changes are necessary to accommodate the schema change using &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;.</source>
          <target state="translated">スキーマの変更の影響を受けるビューでテーブルXを参照している場合は、&lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt;を使用してそれらのビューを削除し、&lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;を使用してスキーマの変更に対応するために必要な変更を加えて再作成します。</target>
        </trans-unit>
        <trans-unit id="f4bcba20e82a98be0954f7a995f190f8be3b9e76" translate="yes" xml:space="preserve">
          <source>If argument P3 is non-zero, then it indicates that the sorter may assume that a stable sort considering the first P3 fields of each key is sufficient to produce the required results.</source>
          <target state="translated">引数P3が0でない場合、ソーターは各キーの最初のP3フィールドを考慮した安定したソートが必要な結果を生成するのに十分であると仮定してもよいことを示しています。</target>
        </trans-unit>
        <trans-unit id="35693c95846989c47eb6a922b6389598e5e5c2ef" translate="yes" xml:space="preserve">
          <source>If argument pnCol is not NULL, then *pnCol is set to the number of columns in the table.</source>
          <target state="translated">引数pnColがNULLでない場合、*pnColにはテーブルの列数が設定されます。</target>
        </trans-unit>
        <trans-unit id="6eebf7ee5a909998cdac6e1af93d8bf0c4b9e6a9" translate="yes" xml:space="preserve">
          <source>If argument pzTab is not NULL, then *pzTab is set to point to a nul-terminated utf-8 encoded string containing the name of the table affected by the current change. The buffer remains valid until either sqlite3changeset_next() is called on the iterator or until the conflict-handler function returns. If pnCol is not NULL, then *pnCol is set to the number of columns in the table affected by the change. If pbIndirect is not NULL, then *pbIndirect is set to true (1) if the change is an indirect change, or false (0) otherwise. See the documentation for &lt;a href=&quot;#sqlite3session_indirect&quot;&gt;sqlite3session_indirect()&lt;/a&gt; for a description of direct and indirect changes. Finally, if pOp is not NULL, then *pOp is set to one of &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the type of change that the iterator currently points to.</source>
          <target state="translated">引数pzTabがNULLでない場合、* pzTabは、現在の変更の影響を受けるテーブルの名前を含む、ヌル文字で終了するutf-8エンコードされた文字列を指すように設定されます。イテレーターでsqlite3changeset_next（）が呼び出されるまで、または競合ハンドラー関数が戻るまで、バッファーは有効なままです。 pnColがNULLでない場合、* pnColは、変更の影響を受けるテーブル内の列数に設定されます。 pbIndirectがNULLでない場合、* pbIndirectは、変更が間接的な変更である場合はtrue（1）に設定され、そうでない場合はfalse（0）に設定されます。直接的および間接的な変更の説明については、&lt;a href=&quot;#sqlite3session_indirect&quot;&gt;sqlite3session_indirect（）の&lt;/a&gt;ドキュメントを参照してください。最後に、pOpがNULLでない場合、* pOpは&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;、&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE、&lt;/a&gt;または&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATEの&lt;/a&gt;いずれかに設定されます。、イテレータが現在指している変更のタイプによって異なります。</target>
        </trans-unit>
        <trans-unit id="eeb423ada7e3f3af8ece536280a90cde13ccf0f0" translate="yes" xml:space="preserve">
          <source>If argument pzTab is not NULL, then *pzTab is set to point to a nul-terminated utf-8 encoded string containing the name of the table affected by the current change. The buffer remains valid until either sqlite3changeset_next() is called on the iterator or until the conflict-handler function returns. If pnCol is not NULL, then *pnCol is set to the number of columns in the table affected by the change. If pbIndirect is not NULL, then *pbIndirect is set to true (1) if the change is an indirect change, or false (0) otherwise. See the documentation for &lt;a href=&quot;sqlite3session_indirect&quot;&gt;sqlite3session_indirect()&lt;/a&gt; for a description of direct and indirect changes. Finally, if pOp is not NULL, then *pOp is set to one of &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; or &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the type of change that the iterator currently points to.</source>
          <target state="translated">引数pzTabがNULLでない場合、* pzTabは、現在の変更の影響を受けるテーブルの名前を含む、ヌル文字で終了するutf-8エンコードされた文字列を指すように設定されます。イテレーターでsqlite3changeset_next（）が呼び出されるまで、または競合ハンドラー関数が戻るまで、バッファーは有効なままです。 pnColがNULLでない場合、* pnColは、変更の影響を受けるテーブル内の列数に設定されます。 pbIndirectがNULLでない場合、* pbIndirectは、変更が間接的な変更である場合はtrue（1）に設定され、そうでない場合はfalse（0）に設定されます。直接的および間接的な変更の説明については、&lt;a href=&quot;sqlite3session_indirect&quot;&gt;sqlite3session_indirect（）の&lt;/a&gt;ドキュメントを参照してください。最後に、pOpがNULLでない場合、* pOpは&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;、&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_DELETE、&lt;/a&gt;または&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATEの&lt;/a&gt;いずれかに設定されます。、イテレータが現在指している変更のタイプによって異なります。</target>
        </trans-unit>
        <trans-unit id="012db9d404feeb7b242a5f104e807e9ebcf5e6cc" translate="yes" xml:space="preserve">
          <source>If argument zTab is not NULL, then it is the name of a table to attach to the session object passed as the first argument. All subsequent changes made to the table while the session object is enabled will be recorded. See documentation for &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; for further details.</source>
          <target state="translated">引数zTabがNULLでない場合、それは最初の引数として渡されたセッションオブジェクトにアタッチするテーブルの名前です。セッションオブジェクトが有効になっている間にテーブルに加えられた変更はすべて記録されます。詳細については、&lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset（）の&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="1874355cfa55a648a95d55d6cc4ad4d5d5a5435f" translate="yes" xml:space="preserve">
          <source>If argument zTab is not NULL, then it is the name of a table to attach to the session object passed as the first argument. All subsequent changes made to the table while the session object is enabled will be recorded. See documentation for &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; for further details.</source>
          <target state="translated">引数zTabがNULLでない場合、それは最初の引数として渡されたセッションオブジェクトにアタッチするテーブルの名前です。セッションオブジェクトが有効になっている間にテーブルに加えられた変更はすべて記録されます。詳細については、&lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset（）の&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="21fcaf7a804fb18a6bdf460073dabd9a55d816ad" translate="yes" xml:space="preserve">
          <source>If both SQLITE_STOREP2 and SQLITE_KEEPNULL flags are set then the content of r[P2] is only changed if the new value is NULL or 0 (false). In other words, a prior r[P2] value will not be overwritten by 1 (true).</source>
          <target state="translated">SQLITE_STOREP2 と SQLITE_KEEPNULL フラグの両方が設定されている場合、新しい値が NULL または 0 (False)の場合にのみ r[P2]の内容が変更されます。言い換えれば、以前の r[P2]の値は 1 (true)で上書きされません。</target>
        </trans-unit>
        <trans-unit id="f091230c98fc9fb42f84687fff668e2e8782487e" translate="yes" xml:space="preserve">
          <source>If both SQLITE_STOREP2 and SQLITE_KEEPNULL flags are set then the content of r[P2] is only changed if the new value is NULL or 1 (true). In other words, a prior r[P2] value will not be overwritten by 0 (false).</source>
          <target state="translated">SQLITE_STOREP2 と SQLITE_KEEPNULL フラグの両方が設定されている場合、r[P2]の内容は、新しい値が NULL または 1 (真)の場合にのみ変更されます。つまり、以前の r[P2]の値は 0 (False)で上書きされません。</target>
        </trans-unit>
        <trans-unit id="b35b42f8226135f60e30979149548acecdb3cd9a" translate="yes" xml:space="preserve">
          <source>If both pragmas &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;full_column_names&lt;/a&gt; are OFF then case (2) applies.</source>
          <target state="translated">プラグマ&lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt;と&lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;full_column_namesの&lt;/a&gt;両方がOFFの場合、ケース（2）が適用されます。</target>
        </trans-unit>
        <trans-unit id="c1ea5de7bdcea197233ed39232910d2d33159cd2" translate="yes" xml:space="preserve">
          <source>If certain kinds of errors occur on a statement within a multi-statement transaction (errors including &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_FULL&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_IOERR&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;, and &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;) then the transaction might be rolled back automatically. The only way to find out whether SQLite automatically rolled back the transaction after an error is to use this function.</source>
          <target state="translated">マルチステートメントトランザクション内のステートメントで特定の種類のエラー（&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_FULL&lt;/a&gt;、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_IOERR&lt;/a&gt;、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;、および&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;を含むエラー）が発生した場合、トランザクションは自動的にロールバックされる可能性があります。エラー後にSQLiteがトランザクションを自動的にロールバックしたかどうかを確認する唯一の方法は、この関数を使用することです。</target>
        </trans-unit>
        <trans-unit id="063cf3d6b1f8d89a285c8317271a90d08b9bd66c" translate="yes" xml:space="preserve">
          <source>If certain kinds of errors occur on a statement within a multi-statement transaction (errors including &lt;a href=&quot;../rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;, &lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;, &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, and &lt;a href=&quot;../rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;) then the transaction might be rolled back automatically. The only way to find out whether SQLite automatically rolled back the transaction after an error is to use this function.</source>
          <target state="translated">マルチステートメントトランザクション内のステートメントで特定の種類のエラー（&lt;a href=&quot;../rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;、&lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;、&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;、&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;、および&lt;a href=&quot;../rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;を含むエラー）が発生した場合、トランザクションは自動的にロールバックされる可能性があります。エラー後にSQLiteがトランザクションを自動的にロールバックしたかどうかを確認する唯一の方法は、この関数を使用することです。</target>
        </trans-unit>
        <trans-unit id="65b57925e204e3ebe11c23e15127d898a0e33ca6" translate="yes" xml:space="preserve">
          <source>If certain kinds of errors occur within a transaction, the transaction may or may not be rolled back automatically. The errors that can cause an automatic rollback include:</source>
          <target state="translated">ある種のエラーがトランザクション内で発生した場合、トランザクションは自動的にロールバックされる場合とされない場合があります。自動ロールバックの原因となるエラーには、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="debbf4ee0f449f15f2b2fad59057f8a4eccd847a" translate="yes" xml:space="preserve">
          <source>If changes occur on the same database connection after a query starts running but before the query completes, then it is undefined whether or not the query will see those changes.</source>
          <target state="translated">クエリが実行を開始した後、クエリが完了する前に同じデータベース接続で変更が発生した場合、クエリがそれらの変更を見るかどうかは未定義です。</target>
        </trans-unit>
        <trans-unit id="92abf58210ebaa6ec510b645429d6e91e6ca04d8" translate="yes" xml:space="preserve">
          <source>If changes occur on the same database connection after a query starts running but before the query completes, then the query might return a changed row more than once, or it might return a row that was previously deleted.</source>
          <target state="translated">クエリの実行開始後、クエリが完了する前に同じデータベース接続で変更が発生した場合、クエリは変更された行を複数回返したり、以前に削除された行を返したりする可能性があります。</target>
        </trans-unit>
        <trans-unit id="437112dad4bafb7626f6351c41b7b34b2abfaca6" translate="yes" xml:space="preserve">
          <source>If changing into or out of WAL mode the procedure is more complicated.</source>
          <target state="translated">WALモードへの切り替え、またはWALモードからの切り替えの場合は、手順が複雑になります。</target>
        </trans-unit>
        <trans-unit id="f754396c33d700ad2fd9dbdfe823fd9ae27672f4" translate="yes" xml:space="preserve">
          <source>If column names are explicitly provided for the FTS table as part of the CREATE VIRTUAL TABLE statement, then a datatype name may be optionally specified for each column. This is pure syntactic sugar, the supplied typenames are not used by FTS or the SQLite core for any purpose. The same applies to any constraints specified along with an FTS column name - they are parsed but not used or recorded by the system in any way.</source>
          <target state="translated">CREATE VIRTUAL TABLE文の一部としてFTSテーブルに明示的にカラム名が提供されている場合、各カラムにはオプションでデータ型名を指定することができます。これは純粋な構文上の問題であり、提供された型名はFTSやSQLiteコアがどのような目的でも使用することはありません。同じことが、FTSカラム名と共に指定された制約にも適用されます-それらは解析されますが、システムによって使用されたり記録されたりすることはありません。</target>
        </trans-unit>
        <trans-unit id="4ec154d4b803f19da5aae8c26059349f5ffc0b8b" translate="yes" xml:space="preserve">
          <source>If conflict is with a remote UPDATE and the resolution is OMIT, then the old.* values are rebased using the new.* values in the remote change. Or, if the resolution is REPLACE, then the change is copied into the rebased changeset with updates to columns also updated by the conflicting remote UPDATE removed. If this means no columns would be updated, the change is omitted.</source>
          <target state="translated">競合がリモートUPDATEで、解決方法がOMITの場合、old.*値は、リモート変更のnew.*値を使用してリベースされます。または、解決方法がREPLACEの場合、競合するリモートUPDATEによって更新されたカラムの更新が削除された状態で、変更がリベースされたチェンジセットにコピーされます。これにより列が更新されない場合は、変更は省略されます。</target>
        </trans-unit>
        <trans-unit id="eacad9fb0a3ce1ea1edfa735ab3f942dbf9e8cd8" translate="yes" xml:space="preserve">
          <source>If cursor P1 is an index, then the content is the key of the row. If cursor P2 is a table, then the content extracted is the data.</source>
          <target state="translated">カーソルP1がインデックスであれば、抽出された内容はその行のキーである。カーソルP2がテーブルであれば、抽出された内容はデータである。</target>
        </trans-unit>
        <trans-unit id="ecd4bc0795e5315c7b840830ae1ae10db7944fd7" translate="yes" xml:space="preserve">
          <source>If cursor P1 is not open, jump to instruction P2. Otherwise, fall through.</source>
          <target state="translated">カーソルP1が開いていない場合は、命令P2にジャンプします。それ以外の場合はフォールスルー。</target>
        </trans-unit>
        <trans-unit id="b0e0c624719d0c72631b398ea85cd293212feef6" translate="yes" xml:space="preserve">
          <source>If cursor P1 refers to an SQL table (B-Tree that uses integer keys), use the value in register P3 as a key. If cursor P1 refers to an SQL index, then P3 is the first in an array of P4 registers that are used as an unpacked index key.</source>
          <target state="translated">カーソルP1がSQLテーブル(整数キーを使用するBツリー)を参照している場合、レジスタP3の値をキーとして使用します。カーソルP1がSQLインデックスを参照している場合、P3は、アンパックされたインデックスキーとして使用されるP4レジスタの配列の最初のものです。</target>
        </trans-unit>
        <trans-unit id="eed3ade81291c8b1e43812aa13b2f866776f9f36" translate="yes" xml:space="preserve">
          <source>If cursor P1 refers to an SQL table (B-Tree that uses integer keys), use the value in register P3 as the key. If cursor P1 refers to an SQL index, then P3 is the first in an array of P4 registers that are used as an unpacked index key.</source>
          <target state="translated">カーソルP1がSQLテーブル(整数キーを使用するB-Tree)を参照している場合、レジスタP3の値をキーとして使用します。カーソルP1がSQLインデックスを参照している場合、P3は、アンパックされたインデックスキーとして使用されるP4レジスタの配列の最初のものです。</target>
        </trans-unit>
        <trans-unit id="bde1d5766ee802e72c51189e7fb68596781976ad" translate="yes" xml:space="preserve">
          <source>If cursor P1 was previously moved via &lt;a href=&quot;opcode#DeferredSeek&quot;&gt;DeferredSeek&lt;/a&gt;, complete that seek operation now, without further delay. If the cursor seek has already occurred, this instruction is a no-op.</source>
          <target state="translated">If cursor P1 was previously moved via &lt;a href=&quot;opcode#DeferredSeek&quot;&gt;DeferredSeek&lt;/a&gt;, complete that seek operation now, without further delay. If the cursor seek has already occurred, this instruction is a no-op.</target>
        </trans-unit>
        <trans-unit id="b9a382b280888652763d650554446d773be05c07" translate="yes" xml:space="preserve">
          <source>If data is of type &lt;b&gt;text&lt;/b&gt; then the comparison is determined by the standard C data comparison functions &lt;b&gt;memcmp()&lt;/b&gt; or &lt;b&gt;strcmp()&lt;/b&gt;. The comparison looks at bytes from two inputs one by one and returns the first non-zero difference. Strings are '\000' terminated so shorter strings sort before longer strings, as you would expect.</source>
          <target state="translated">データ型である場合&lt;b&gt;、テキスト&lt;/b&gt;、比較関数は、標準のCデータを比較することによって決定される&lt;b&gt;memcmp（）を&lt;/b&gt;または&lt;b&gt;のstrcmp（）を&lt;/b&gt;。比較では、2つの入力からのバイトを1つずつ調べ、最初のゼロ以外の差を返します。文字列は '\ 000'で終了するので、予想どおり、短い文字列は長い文字列の前にソートされます。</target>
        </trans-unit>
        <trans-unit id="0120d2592940874456695d5517c48510978290bc" translate="yes" xml:space="preserve">
          <source>If database zDb is the name of an attached database that is not in WAL mode, SQLITE_OK is returned and both *pnLog and *pnCkpt set to -1. If zDb is not NULL (or a zero length string) and is not the name of any attached database, SQLITE_ERROR is returned to the caller.</source>
          <target state="translated">データベース zDb が WAL モードではない添付データベースの名前である場合、SQLITE_OK が返され、*pnLog と *pnCkpt の両方が -1 に設定されます。zDb が NULL (または長さ 0 の文字列)ではなく、接続されているデータベースの名前ではない場合は、SQLITE_ERROR がコール元に返されます。</target>
        </trans-unit>
        <trans-unit id="ed9f3d01c8cb63f65cf1f8cb1ada863d801c5821" translate="yes" xml:space="preserve">
          <source>If defined, support for sub-selects and the IN() operator are omitted.</source>
          <target state="translated">定義されている場合は、サブセレクトとIN()演算子のサポートは省略されます。</target>
        </trans-unit>
        <trans-unit id="5f4710e921e7c9706b1a7d0affff80c102083b4a" translate="yes" xml:space="preserve">
          <source>If desired, you can verify the new database by running this command:</source>
          <target state="translated">必要に応じて、このコマンドを実行して新しいデータベースを検証することができます。</target>
        </trans-unit>
        <trans-unit id="d0b0b6a44b8709f88072f86b2bad9194c580b896" translate="yes" xml:space="preserve">
          <source>If either P1 or P2 is 0 (false) then the result is 0 even if the other input is NULL. A NULL and true or two NULLs give a NULL output.</source>
          <target state="translated">P1 または P2 のどちらかが 0 (false)の場合、他の入力が NULL であっても結果は 0 になります。NULLと真、または2つのNULLがあればNULL出力となります。</target>
        </trans-unit>
        <trans-unit id="0c5f4e14888f22c44de9608417d3500cbb09c876" translate="yes" xml:space="preserve">
          <source>If either P1 or P2 is nonzero (true) then the result is 1 (true) even if the other input is NULL. A NULL and false or two NULLs give a NULL output.</source>
          <target state="translated">P1 または P2 のどちらかが 0 以外の値(真)の場合、他の入力が NULL であっても結果は 1(真)となります。NULLとFalse、または2つのNULLを指定すると、NULL出力となります。</target>
        </trans-unit>
        <trans-unit id="f718f36fc0872a36f2f90015ef098011701953fd" translate="yes" xml:space="preserve">
          <source>If either P3 or the sorter contains a NULL in one of their significant fields (not counting the P4 fields at the end which are ignored) then the comparison is assumed to be equal.</source>
          <target state="translated">P3またはソーターのいずれかが有効なフィールドの1つにNULLを含む場合(最後のP4フィールドは無視されますがカウントされません)、比較は等しいと仮定されます。</target>
        </trans-unit>
        <trans-unit id="cb70cc2d7081446ae1bd92c809ed77dcb6489c40" translate="yes" xml:space="preserve">
          <source>If either X&lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; or X&lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt; are non-numeric, then the boundary is the first row for which the expression &quot;X&lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; IS X&lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt;&quot; is true.</source>
          <target state="translated">X &lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt;またはX &lt;sub&gt;&lt;small&gt;cの&lt;/small&gt;&lt;/sub&gt;いずれかが数値でない場合、境界は式「X &lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; IS X &lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt;」が真である最初の行です。</target>
        </trans-unit>
        <trans-unit id="40afda50342c1866ef5c9245fe131f4faa8b196a" translate="yes" xml:space="preserve">
          <source>If either operand has an explicit collating function assignment using the postfix &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, then the explicit collating function is used for comparison, with precedence to the collating function of the left operand.</source>
          <target state="translated">いずれかのオペランドに後&lt;a href=&quot;lang_expr#collateop&quot;&gt;置COLLATE演算子&lt;/a&gt;を使用した明示的な照合関数の割り当てがある場合、明示的な照合関数が比較に使用され、左側のオペランドの照合関数が優先されます。</target>
        </trans-unit>
        <trans-unit id="55672cdef058eed493a94d268600f0dc4cf6e695" translate="yes" xml:space="preserve">
          <source>If either operand is a column, then the collating function of that column is used with precedence to the left operand. For the purposes of the previous sentence, a column name preceded by one or more unary &quot;+&quot; operators and/or CAST operators is still considered a column name.</source>
          <target state="translated">どちらかのオペランドが列である場合、その列の照合関数が左のオペランドに優先して使用されます。前の文の目的のために、1つ以上の単項の &quot;+&quot;演算子および/またはCAST演算子が先行する列名は、依然として列名とみなされます。</target>
        </trans-unit>
        <trans-unit id="c6ebcbeab69b86f653a3410afabe08a544dcaea8" translate="yes" xml:space="preserve">
          <source>If either the current value or the highwater mark is too large to be represented by a 32-bit integer, then the values returned by sqlite3_status() are undefined.</source>
          <target state="translated">現在の値またはハイウォーターマークのいずれかが32ビット整数で表現するには大きすぎる場合、sqlite3_status()によって返される値は未定義です。</target>
        </trans-unit>
        <trans-unit id="f734ad1cf91506e2435f2ec6895dbb828ca868ad" translate="yes" xml:space="preserve">
          <source>If everything is OK, the query above should return a single row where the second column is 1. Any other result indicates either that there is a checksum error, or checksum validation is disabled.</source>
          <target state="translated">すべてがOKの場合、上記のクエリは2番目の列が1である1行を返します。 それ以外の結果は、チェックサムエラーがあるか、チェックサム検証が無効になっていることを示しています。</target>
        </trans-unit>
        <trans-unit id="10b7374ac7ffa60e3b709049b312d9aea49ec9de" translate="yes" xml:space="preserve">
          <source>If file-locking is enabled (it is enabled by default), then connections from multiple processes may also read and write the database file. However concurrency is reduced as follows:</source>
          <target state="translated">ファイルロックが有効になっている場合(デフォルトでは有効になっています)、複数のプロセスからの接続もデータベースファイルを読み書きすることができます。ただし、同時実行性は以下のように低下します。</target>
        </trans-unit>
        <trans-unit id="d3ef8fd536a105baf87d357ae62955ed380fa9cf" translate="yes" xml:space="preserve">
          <source>If foreign key constraints are enabled when it is prepared, the &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; command performs an implicit &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; to remove all rows from the table before dropping it. The implicit DELETE does not cause any SQL triggers to fire, but may invoke foreign key actions or constraint violations. If an immediate foreign key constraint is violated, the DROP TABLE statement fails and the table is not dropped. If a deferred foreign key constraint is violated, then an error is reported when the user attempts to commit the transaction if the foreign key constraint violations still exist at that point. Any &quot;foreign key mismatch&quot; errors encountered as part of an implicit DELETE are ignored.</source>
          <target state="translated">外部キー制約が準備時に有効になっている場合、&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;コマンドは暗黙的な&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;を実行して、テーブルからすべての行を削除してから削除します。暗黙的なDELETEによってSQLトリガーが起動することはありませんが、外部キーアクションまたは制約違反を呼び出す可能性があります。即時外部キー制約に違反すると、DROP TABLEステートメントは失敗し、テーブルは削除されません。遅延外部キー制約に違反している場合、外部キー制約違反がその時点でまだ存在しているときにユーザーがトランザクションをコミットしようとすると、エラーが報告されます。暗黙的なDELETEの一部として発生した「外部キーの不一致」エラーは無視されます。</target>
        </trans-unit>
        <trans-unit id="4f44f3a8f93f85a791245b413bb9ad1095b808f6" translate="yes" xml:space="preserve">
          <source>If foreign key constraints are enabled, disable them using &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=OFF&lt;/a&gt;.</source>
          <target state="translated">外部キー制約が有効になっている場合は、&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys = OFF&lt;/a&gt;を使用して無効にします。</target>
        </trans-unit>
        <trans-unit id="6a1eb421ae6f8eb8b7414f3ba7bf623bab8ed0c1" translate="yes" xml:space="preserve">
          <source>If foreign key constraints were originally enabled then run &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; to verify that the schema change did not break any foreign key constraints.</source>
          <target state="translated">最初に外部キー制約が有効になっていた場合は、&lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt;を実行して、スキーマの変更によって外部キー制約が壊れていないことを確認します。</target>
        </trans-unit>
        <trans-unit id="c13741cd4626e3d89fe66c4aae10d469f36c6a45" translate="yes" xml:space="preserve">
          <source>If foreign key handling is enabled, and applying a changeset leaves the database in a state containing foreign key violations, the conflict handler is invoked with CHANGESET_FOREIGN_KEY as the second argument exactly once before the changeset is committed. If the conflict handler returns CHANGESET_OMIT, the changes, including those that caused the foreign key constraint violation, are committed. Or, if it returns CHANGESET_ABORT, the changeset is rolled back.</source>
          <target state="translated">外部キー処理が有効で、チェンジセットを適用すると外部キー違反を含む状態でデータベースを離れる場合、チェンジセットがコミットされる前に、CHANGESET_FOREIGN_KEYを第2引数に指定してコンフリクトハンドラが呼び出されます。コンフリクトハンドラが CHANGESET_OMIT を返す場合、外部キー制約違反の原因となった変更を含む変更がコミットされます。あるいは、CHANGESET_ABORT を返した場合、チェンジセットはロールバックされます。</target>
        </trans-unit>
        <trans-unit id="664ed429f3e8a71469131f1cf927d67cea7224ef" translate="yes" xml:space="preserve">
          <source>If foreign keys constraints were originally enabled, reenable them now.</source>
          <target state="translated">外部キー制約が元々有効であった場合は、再度有効にしてください。</target>
        </trans-unit>
        <trans-unit id="ae0d6d454ce848e119fe19c9d3921a6301be3ccd" translate="yes" xml:space="preserve">
          <source>If it is not already attached to the session object passed as the first argument, this function attaches table zTbl in the same manner as the &lt;a href=&quot;#sqlite3session_attach&quot;&gt;sqlite3session_attach()&lt;/a&gt; function. If zTbl does not exist, or if it does not have a primary key, this function is a no-op (but does not return an error).</source>
          <target state="translated">最初の引数として渡されたセッションオブジェクトにまだアタッチされていない場合、この関数は&lt;a href=&quot;#sqlite3session_attach&quot;&gt;sqlite3session_attach（）&lt;/a&gt;関数と同じ方法でテーブルzTblをアタッチします。zTblが存在しない場合、または主キーがない場合、この関数は何もしません（ただし、エラーを返しません）。</target>
        </trans-unit>
        <trans-unit id="b18e9847f65d260e65a6581d1c54f05d17b07506" translate="yes" xml:space="preserve">
          <source>If it is not already attached to the session object passed as the first argument, this function attaches table zTbl in the same manner as the &lt;a href=&quot;sqlite3session_attach&quot;&gt;sqlite3session_attach()&lt;/a&gt; function. If zTbl does not exist, or if it does not have a primary key, this function is a no-op (but does not return an error).</source>
          <target state="translated">最初の引数として渡されたセッションオブジェクトにまだアタッチされていない場合、この関数は&lt;a href=&quot;sqlite3session_attach&quot;&gt;sqlite3session_attach（）&lt;/a&gt;関数と同じ方法でテーブルzTblをアタッチします。zTblが存在しない場合、または主キーがない場合、この関数は何もしません（ただし、エラーを返しません）。</target>
        </trans-unit>
        <trans-unit id="a8c1f9f82d9d1138df42ada4c0e8d4ac1b13017c" translate="yes" xml:space="preserve">
          <source>If many threads and/or processes need to write the database at the same instant (and they cannot queue up and take turns) then it is best to select a database engine that supports that capability, which always means a client/server database engine.</source>
          <target state="translated">多くのスレッドやプロセスが同時にデータベースに書き込む必要がある場合(キューに並んで交代で書き込むことができない場合)、その機能をサポートするデータベースエンジンを選択するのがベストです。</target>
        </trans-unit>
        <trans-unit id="277d800367bb442a2e4d79fba0d9ab386719bb03" translate="yes" xml:space="preserve">
          <source>If mmap_size is set to N then all current implementations map the first N bytes of the database file and use legacy xRead() calls for any content beyond N bytes. If the database file is smaller than N bytes, then the entire file is mapped. In the future, new OS interfaces could, in theory, map regions of the file other than the first N bytes, but no such implementation currently exists.</source>
          <target state="translated">mmap_size が N に設定されている場合、現在のすべての実装では、データベースファイルの最初の N バイトがマップされ、N バイト以上の内容については従来の xRead()コールが使用されます。データベースファイルが N バイトよりも小さい場合は、ファイル全体がマップされます。将来的には、理論的には、新しい OS インターフェイスによって、最初の N バイト以外のファイルの領域がマップされるようになる可能性がありますが、現在のところそのような実装は存在しません。</target>
        </trans-unit>
        <trans-unit id="44cd764c270354ba3be43d380aabce5d77a1bc54" translate="yes" xml:space="preserve">
          <source>If more than one such fragment can be found, then fragments that contain a larger number of &quot;extra&quot; phrase matches are favored. The start of the selected text fragment may be moved a few tokens forward or backward to attempt to concentrate the phrase matches toward the center of the fragment.</source>
          <target state="translated">このようなフラグメントが 1 つ以上見つかった場合は、&quot;余分な&quot; フレーズマッチを多く含むフラグメントが優先されます。選択されたテキスト フラグメントの開始位置を数トークン前方または後方に移動して、フレーズマッチをフラグメントの中心に集中させることができます。</target>
        </trans-unit>
        <trans-unit id="26cb5f0f4343465953038f56daf635f7d45d2d33" translate="yes" xml:space="preserve">
          <source>If multi-threaded processing is enabled via the &lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; setting, then sort operations will attempt to start helper threads when the amount of content to be sorted exceeds the minimum of the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt; and PMA Size determined by the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt; start-time option. This compile-time option sets the default value for the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt; start-time option. The default value is 250.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMAスレッド&lt;/a&gt;設定を介してマルチスレッド処理が有効になっている場合、ソートするコンテンツの量が、&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt;開始時間オプションによって決定される&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt;およびPMAサイズの最小値を超えると、ソート操作はヘルパースレッドを開始しようとします。このコンパイル時オプションは、&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt;開始時オプションのデフォルト値を設定します。デフォルト値は250です。</target>
        </trans-unit>
        <trans-unit id="aefd863d94581cbe189ba146626a8379609c65b7" translate="yes" xml:space="preserve">
          <source>If multiple calls to sqlite3_create_function() specify the same function name, and the same number of arguments, and the same preferred text encoding, then the callbacks and other parameters of the second call overwrite the first, and the destructor callback from the first call (if it exists) is invoked.</source>
          <target state="translated">sqlite3_create_function()の複数回の呼び出しで、同じ関数名、同じ数の引数、同じテキスト・エンコーディングを指定した場合、2回目の呼び出しのコールバックと他のパラメータは1回目の呼び出しを上書きし、1回目の呼び出しのデストラクタ・コールバック(存在する場合)が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="180acf91f65a788cf692bf4d0ecd25eb3f41224e" translate="yes" xml:space="preserve">
          <source>If multiple commands are being executed against the same SQLite database connection at the same time, the autocommit is deferred until the very last command completes. For example, if a SELECT statement is being executed, the execution of the command will pause as each row of the result is returned. During this pause other INSERT, UPDATE, or DELETE commands can be executed against other tables in the database. But none of these changes will commit until the original SELECT statement finishes.</source>
          <target state="translated">同じ SQLite データベース接続に対して複数のコマンドが同時に実行されている場合、オートコミットは最後のコマンドが完了するまで延期されます。例えば、SELECT文が実行されている場合、結果の各行が返されるとコマンドの実行は一時停止します。この一時停止の間、データベース内の他のテーブルに対して他のINSERT、UPDATE、またはDELETEコマンドを実行することができます。しかし、元のSELECT文が終了するまで、これらの変更はコミットされません。</target>
        </trans-unit>
        <trans-unit id="02760b51331cbab337a4b4abdc9926115fb4b89f" translate="yes" xml:space="preserve">
          <source>If neither of these two query strategies can be used, all queries on FTS tables are implemented using a linear scan of the entire table. If the table contains large amounts of data, this may be an impractical approach (the first example on this page shows that a linear scan of 1.5 GB of data takes around 30 seconds using a modern PC).</source>
          <target state="translated">これら2つのクエリ戦略のどちらも使用できない場合、FTSテーブル上のすべてのクエリは、テーブル全体のリニアスキャンを使用して実装されます。テーブルに大量のデータが含まれている場合、これは非現実的なアプローチかもしれません(このページの最初の例では、最新のPCを使用して1.5GBのデータのリニアスキャンに約30秒かかることが示されています)。</target>
        </trans-unit>
        <trans-unit id="46d15914a8966b2144fb307d96a3896b83eea8f4" translate="yes" xml:space="preserve">
          <source>If no</source>
          <target state="translated">ない場合</target>
        </trans-unit>
        <trans-unit id="d80775017369d9f582b22c2b8463af70c053cb1a" translate="yes" xml:space="preserve">
          <source>If no ROWID is specified on the insert, or if the specified ROWID has a value of NULL, then an appropriate ROWID is created automatically. The usual algorithm is to give the newly created row a ROWID that is one larger than the largest ROWID in the table prior to the insert. If the table is initially empty, then a ROWID of 1 is used. If the largest ROWID is equal to the largest possible integer (9223372036854775807) then the database engine starts picking positive candidate ROWIDs at random until it finds one that is not previously used. If no unused ROWID can be found after a reasonable number of attempts, the insert operation fails with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error. If no negative ROWID values are inserted explicitly, then automatically generated ROWID values will always be greater than zero.</source>
          <target state="translated">挿入でROWIDが指定されていない場合、または指定されたROWIDの値がNULLの場合、適切なROWIDが自動的に作成されます。通常のアルゴリズムは、新しく作成された行に、挿入前のテーブル内の最大のROWIDよりも1つ大きいROWIDを与えることです。テーブルが最初は空の場合、ROWID 1が使用されます。最大のROWIDが可能な最大の整数（9223372036854775807）と等しい場合、データベースエンジンは、以前に使用されていないROWIDが見つかるまでランダムに正の候補ROWIDの選択を開始します。妥当な回数試行しても未使用のROWIDが見つからない場合、挿入操作は&lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;エラーで失敗します。負のROWID値が明示的に挿入されていない場合、自動生成されたROWID値は常にゼロより大きくなります。</target>
        </trans-unit>
        <trans-unit id="e2deadd7a9c793e3167a0e629e8b9b96ff70f176" translate="yes" xml:space="preserve">
          <source>If no error occurs, SQLITE_OK is returned.</source>
          <target state="translated">エラーが発生しない場合は、SQLITE_OK が返されます。</target>
        </trans-unit>
        <trans-unit id="8e5398b47308ea9ae66110e9bb05403692680696" translate="yes" xml:space="preserve">
          <source>If no error occurs, SQLITE_OK is returned. If an error does occur, an SQLite error code is returned. The values of the output variables may not be trusted in this case.</source>
          <target state="translated">エラーが発生しない場合は、SQLITE_OK が返されます。エラーが発生した場合は、SQLite エラーコードが返されます。この場合、出力変数の値は信頼できないかもしれません。</target>
        </trans-unit>
        <trans-unit id="b8dd386d2569bc5457aac9dba2010126d7a04d7d" translate="yes" xml:space="preserve">
          <source>If no master journal is involved, then a journal is hot if it exists and has a non-zero header and its corresponding database file does not have a RESERVED lock. If a master journal is named in the file journal, then the file journal is hot if its master journal exists and there is no RESERVED lock on the corresponding database file. It is important to understand when a journal is hot so the preceding rules will be repeated in bullets:</source>
          <target state="translated">マスター・ジャーナルが関与していない場合、ジャーナルが存在し、ゼロではないヘッダを持ち、対応するデータベース・ファイルにRESERVEDEDEDロックがない場合、ジャーナルはホットです。ファイル・ジャーナルにマスター・ジャーナルの名前が付けられている場合、そのマスター・ジャーナルが存在し、対応するデータベース・ファイルにRESERVEDEDEDロックがない場合、ファイル・ジャーナルはホットになります。ジャーナルがホットになるタイミングを理解することが重要なので、先行するルールを箇条書きで繰り返します。</target>
        </trans-unit>
        <trans-unit id="e9ec2ab3e066aabbb424ce10a035adf5f5270552" translate="yes" xml:space="preserve">
          <source>If no row with matching primary key values is found in the database, the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_NOTFOUND&lt;/a&gt; passed as the second argument.</source>
          <target state="translated">主キーの値が一致する行がデータベースで見つからない場合、競合ハンドラ関数が呼び出され、2番目の引数として&lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_NOTFOUND&lt;/a&gt;が渡されます。</target>
        </trans-unit>
        <trans-unit id="532395f09f545a6e9963ddaa843af136eeb8913b" translate="yes" xml:space="preserve">
          <source>If no row with matching primary key values is found in the database, the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_NOTFOUND&lt;/a&gt; passed as the second argument.</source>
          <target state="translated">主キーの値が一致する行がデータベースで見つからない場合、競合ハンドラ関数が呼び出され、2番目の引数として&lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_NOTFOUND&lt;/a&gt;が渡されます。</target>
        </trans-unit>
        <trans-unit id="96d3acb3ee8eb3ea8e9644e28f8d2dc56f1b840a" translate="yes" xml:space="preserve">
          <source>If no super-journal is involved, then a journal is hot if it exists and has a non-zero header and its corresponding database file does not have a RESERVED lock. If a super-journal is named in the file journal, then the file journal is hot if its super-journal exists and there is no RESERVED lock on the corresponding database file. It is important to understand when a journal is hot so the preceding rules will be repeated in bullets:</source>
          <target state="translated">スーパー・ジャーナルが関与していない場合、ジャーナルが存在し、ゼロではないヘッダを持ち、対応するデータベース・ファイルにRESERVEDEDEDロックがない場合、ジャーナルはホットです。ファイル・ジャーナルにスーパー・ジャーナルが指定されている場合、そのスーパー・ジャーナルが存在し、対応するデータベース・ファイルにRESERVEDEDEDロックがない場合、ファイル・ジャーナルはホットになります。ジャーナルがホットになるタイミングを理解することが重要なので、先行するルールを箇条書きで繰り返します。</target>
        </trans-unit>
        <trans-unit id="5795a39454965fb21426bc7bb9e2147672f5e177" translate="yes" xml:space="preserve">
          <source>If none of the strings above occur anywhere in the type declaration, then the datatype is numeric. Note in particular that the datatype for columns with an empty type declaration is numeric.</source>
          <target state="translated">上記の文字列のいずれも型宣言のどこにも存在しない場合、データ型は数値です。特に、空の型宣言を持つ列のデータ型は数値であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5b0f610d4827d05770d8c3809730eca324b8d352" translate="yes" xml:space="preserve">
          <source>If offset iOffset is less than N bytes from the end of the BLOB, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is read. If N or iOffset is less than zero, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is read. The size of the blob (and hence the maximum value of N+iOffset) can be determined using the &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface.</source>
          <target state="translated">オフセットiOffsetがBLOBの終わりからNバイト未満の場合、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;が返され、データは読み取られません。NまたはiOffsetがゼロ未満の場合、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;が返され、データは読み取られません。blobのサイズ（およびN + iOffsetの最大値）は、&lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;インターフェースを使用して決定できます。</target>
        </trans-unit>
        <trans-unit id="bcc2dad992498753f10de4ee979d37a3e30daa67" translate="yes" xml:space="preserve">
          <source>If offset iOffset is less than N bytes from the end of the BLOB, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is read. If N or iOffset is less than zero, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is read. The size of the blob (and hence the maximum value of N+iOffset) can be determined using the &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface.</source>
          <target state="translated">オフセットiOffsetがBLOBの終わりからNバイト未満の場合、&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;が返され、データは読み取られません。NまたはiOffsetがゼロ未満の場合、&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;が返され、データは読み取られません。blobのサイズ（およびN + iOffsetの最大値）は、&lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes（）&lt;/a&gt;インターフェースを使用して決定できます。</target>
        </trans-unit>
        <trans-unit id="2e41507fc7f4f5f8ed7f1f9f86f50446d711b557" translate="yes" xml:space="preserve">
          <source>If one operand has INTEGER, REAL or NUMERIC affinity and the other operand has TEXT or BLOB or no affinity then NUMERIC affinity is applied to other operand.</source>
          <target state="translated">一方のオペランドが INTEGER,REAL,NUMERIC のいずれかにアフィニティがあり、もう一方のオペランドが TEXT,BLOB,またはアフィニティがない場合は、もう一方のオペランドに NUMERIC アフィニティが適用されます。</target>
        </trans-unit>
        <trans-unit id="316990fa091894331a5bfab80d20b7d7b8a1b17a" translate="yes" xml:space="preserve">
          <source>If one operand has TEXT affinity and the other has no affinity, then TEXT affinity is applied to the other operand.</source>
          <target state="translated">一方のオペランドがTEXT affinityを持ち、他方のオペランドがアフィニティを持たない場合、もう一方のオペランドにはTEXT affinityが適用されます。</target>
        </trans-unit>
        <trans-unit id="4a746052c71f7cca567e925f8568ed0089126b0e" translate="yes" xml:space="preserve">
          <source>If one or more of the column values in the row inserted by the new change differ from those in the row deleted by the existing change, the existing DELETE is replaced by an UPDATE within the changegroup. Otherwise, if the inserted row is exactly the same as the deleted row, the existing DELETE is simply discarded.</source>
          <target state="translated">新しい変更によって挿入された行の列の値が、既存の変更によって削除された行の列の値と異なる場合、既存のDELETEは changegroup内のUPDATEに置き換えられます。そうでなければ、挿入された行が削除された行と全く同じであれば、既存のDELETEは単に破棄されます。</target>
        </trans-unit>
        <trans-unit id="bbb903a0b2fa794db9f8ce5d76be92c6e8ad13da" translate="yes" xml:space="preserve">
          <source>If ownership of the pointer is passed into SQLite by providing a non-NULL D parameter to &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; or &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; then the ownership remains with SQLite until the object is destroyed. There is no way to transfer ownership out of SQLite and back into the application again.</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer（）&lt;/a&gt;または&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）に&lt;/a&gt; NULL以外のDパラメータを指定してポインタの所有権をSQLiteに渡すと、オブジェクトが破棄されるまでSQLiteの所有権が維持されます。所有権をSQLiteから転送してアプリケーションに戻す方法はありません。</target>
        </trans-unit>
        <trans-unit id="8503abe821374258f98c6ba5585311ca76bf6ece" translate="yes" xml:space="preserve">
          <source>If page 1 data is read as required by H35230, then the value of the</source>
          <target state="translated">H35230で要求されたように1ページ目のデータが読み込まれた場合には</target>
        </trans-unit>
        <trans-unit id="017b230392006407b67880da521173469a1b31d0" translate="yes" xml:space="preserve">
          <source>If parameter iCol is greater than or equal to the number of columns in the table, SQLITE_RANGE is returned. Or, if an error occurs (e.g. an OOM condition or IO error), an appropriate SQLite error code is returned.</source>
          <target state="translated">パラメータ iCol がテーブルの列数以上の場合、SQLITE_RANGE が返されます。あるいは、エラーが発生した場合 (OOM 条件や IO エラーなど)、適切な SQLite エラーコードが返されます。</target>
        </trans-unit>
        <trans-unit id="c373aca4c319795b45d2c1f0dc2245e638666f60" translate="yes" xml:space="preserve">
          <source>If parameter iCol is less than zero, set output variable *pnToken to the total number of tokens in the FTS5 table. Or, if iCol is non-negative but less than the number of columns in the table, return the total number of tokens in column iCol, considering all rows in the FTS5 table.</source>
          <target state="translated">パラメータ iCol がゼロよりも小さい場合、出力変数 *pnToken に FTS5 テーブル内のトークンの総数を設定します。あるいは、iCol が負ではなく、テーブルの列数よりも少ない場合、FTS5 テーブルのすべての行を考慮して、iCol 列のトークンの総数を返します。</target>
        </trans-unit>
        <trans-unit id="686ce79e8e629eea956f529880e81a4b9a406c30" translate="yes" xml:space="preserve">
          <source>If parameter iCol is less than zero, set output variable *pnToken to the total number of tokens in the current row. Or, if iCol is non-negative but less than the number of columns in the table, set *pnToken to the number of tokens in column iCol of the current row.</source>
          <target state="translated">パラメータ iCol が 0 より小さい場合、出力変数 *pnToken に現在の行のトークンの総数を設定します。あるいは、iCol が負ではなく、テーブルの列数よりも少ない場合、現在の行の iCol 列にあるトークンの数を *pnToken に設定します。</target>
        </trans-unit>
        <trans-unit id="88577f66da407130b6c2fbcee7dc6e283e2a74d7" translate="yes" xml:space="preserve">
          <source>If parameter zDb is NULL or points to a zero length string, then the specified operation is attempted on all WAL databases &lt;a href=&quot;../lang_attach&quot;&gt;attached&lt;/a&gt; to &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; db. In this case the values written to output parameters *pnLog and *pnCkpt are undefined. If an SQLITE_BUSY error is encountered when processing one or more of the attached WAL databases, the operation is still attempted on any remaining attached databases and SQLITE_BUSY is returned at the end. If any other error occurs while processing an attached database, processing is abandoned and the error code is returned to the caller immediately. If no error (SQLITE_BUSY or otherwise) is encountered while processing the attached databases, SQLITE_OK is returned.</source>
          <target state="translated">ZDBは、長さゼロの文字列にNULLまたはポイントであるパラメータ場合、指定された動作は全てWALデータベースで試行される&lt;a href=&quot;../lang_attach&quot;&gt;添付&lt;/a&gt;に&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt; DB。この場合、出力パラメーター* pnLogおよび* pnCkptに書き込まれる値は未定義です。接続されている1つ以上のWALデータベースの処理中にSQLITE_BUSYエラーが発生した場合でも、残りの接続されているデータベースで操作が試行され、最後にSQLITE_BUSYが返されます。接続されたデータベースの処理中に他のエラーが発生した場合、処理は中止され、エラーコードが呼び出し元にすぐに返されます。接続されたデータベースの処理中にエラー（SQLITE_BUSYなど）が発生しなかった場合、SQLITE_OKが返されます。</target>
        </trans-unit>
        <trans-unit id="83e25a419f885754ebe2acacb05d4faa8a67cc7b" translate="yes" xml:space="preserve">
          <source>If parameter zDb is NULL or points to a zero length string, then the specified operation is attempted on all WAL databases &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; to &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; db. In this case the values written to output parameters *pnLog and *pnCkpt are undefined. If an SQLITE_BUSY error is encountered when processing one or more of the attached WAL databases, the operation is still attempted on any remaining attached databases and SQLITE_BUSY is returned at the end. If any other error occurs while processing an attached database, processing is abandoned and the error code is returned to the caller immediately. If no error (SQLITE_BUSY or otherwise) is encountered while processing the attached databases, SQLITE_OK is returned.</source>
          <target state="translated">ZDBは、長さゼロの文字列にNULLまたはポイントであるパラメータ場合、指定された動作は全てWALデータベースで試行される&lt;a href=&quot;lang_attach&quot;&gt;添付&lt;/a&gt;に&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt; DB。この場合、出力パラメーター* pnLogおよび* pnCkptに書き込まれる値は未定義です。接続されている1つ以上のWALデータベースの処理中にSQLITE_BUSYエラーが発生した場合でも、残りの接続されているデータベースで操作が試行され、最後にSQLITE_BUSYが返されます。接続されたデータベースの処理中に他のエラーが発生した場合、処理は中止され、エラーコードが呼び出し元にすぐに返されます。接続されたデータベースの処理中にエラー（SQLITE_BUSYなど）が発生しなかった場合、SQLITE_OKが返されます。</target>
        </trans-unit>
        <trans-unit id="d5e79777c8fc72c43d9863555c6ca53f645883e2" translate="yes" xml:space="preserve">
          <source>If pnLog is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in &lt;a href=&quot;../wal&quot;&gt;WAL mode&lt;/a&gt;. If pnCkpt is not NULL,then *pnCkpt is set to the total number of checkpointed frames in the log file (including any that were already checkpointed before the function was called) or to -1 if the checkpoint could not run due to an error or because the database is not in WAL mode. Note that upon successful completion of an SQLITE_CHECKPOINT_TRUNCATE, the log file will have been truncated to zero bytes and so both *pnLog and *pnCkpt will be set to zero.</source>
          <target state="translated">pnLogがNULLでない場合、* pnLogはログファイル内のフレームの総数に設定され&lt;a href=&quot;../wal&quot;&gt;ます&lt;/a&gt;。エラーまたはデータベースがWALモードでないためにチェックポイントを実行できなかった場合は、-1に設定されます。 pnCkptがNULLでない場合、* pnCkptは、ログファイル内のチェックポイントされたフレームの総数（関数が呼び出される前にすでにチェックポイントされたフレームを含む）に設定されます。エラーまたはデータベースがWALモードではないためです。 SQLITE_CHECKPOINT_TRUNCATEが正常に完了すると、ログファイルはゼロバイトに切り捨てられるため、* pnLogと* pnCkptの両方がゼロに設定されます。</target>
        </trans-unit>
        <trans-unit id="d64232e8314def054a53cca48179ce0748631809" translate="yes" xml:space="preserve">
          <source>If pnLog is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. If pnCkpt is not NULL,then *pnCkpt is set to the total number of checkpointed frames in the log file (including any that were already checkpointed before the function was called) or to -1 if the checkpoint could not run due to an error or because the database is not in WAL mode. Note that upon successful completion of an SQLITE_CHECKPOINT_TRUNCATE, the log file will have been truncated to zero bytes and so both *pnLog and *pnCkpt will be set to zero.</source>
          <target state="translated">pnLogがNULLでない場合、* pnLogはログファイル内のフレームの総数に設定され&lt;a href=&quot;wal&quot;&gt;ます&lt;/a&gt;。エラーまたはデータベースがWALモードでないためにチェックポイントを実行できなかった場合は、-1に設定されます。 pnCkptがNULLでない場合、* pnCkptは、ログファイル内のチェックポイントされたフレームの総数（関数が呼び出される前にすでにチェックポイントされたフレームを含む）に設定されます。エラーまたはデータベースがWALモードではないためです。 SQLITE_CHECKPOINT_TRUNCATEが正常に完了すると、ログファイルはゼロバイトに切り捨てられるため、* pnLogと* pnCkptの両方がゼロに設定されます。</target>
        </trans-unit>
        <trans-unit id="41dd1bdb1c62f1c1fa9eb1f2a9f608c75f290fb8" translate="yes" xml:space="preserve">
          <source>If present, output a more verbose report for each query analyzed.</source>
          <target state="translated">存在する場合は、分析された各クエリについて、より詳細なレポートを出力します。</target>
        </trans-unit>
        <trans-unit id="dfd446567083de1e9ebdea0d18573182ac68033b" translate="yes" xml:space="preserve">
          <source>If pzTail is not NULL then *pzTail is made to point to the first byte past the end of the first SQL statement in zSql. These routines only compile the first statement in zSql, so *pzTail is left pointing to what remains uncompiled.</source>
          <target state="translated">pzTailがNULLでない場合、*pzTailはzSql内の最初のSQL文の最後から1バイト目を指すように作られます。これらのルーチンはzSql内の最初の文をコンパイルするだけなので、*pzTailはコンパイルされていない部分を指したままになります。</target>
        </trans-unit>
        <trans-unit id="daeeadf12f9cfe6f720cf3d4bdd4fb456397cc60" translate="yes" xml:space="preserve">
          <source>If r[P3] is zero or negative, that means there is no OFFSET and r[P2] is set to be the value of the LIMIT, r[P1].</source>
          <target state="translated">r[P3]が0または負の場合は、OFFSETがないことを意味し、r[P2]にはLIMITの値であるr[P1]が設定されています。</target>
        </trans-unit>
        <trans-unit id="6c50ebdc1c9d5314285662a0bf55da3e625fe7b5" translate="yes" xml:space="preserve">
          <source>If register P1 holds an integer convert it to a real value.</source>
          <target state="translated">レジスタP1が整数を保持している場合は、実数に変換します。</target>
        </trans-unit>
        <trans-unit id="24add31372893a82dd86705b4a5c1cbba71ea8ec" translate="yes" xml:space="preserve">
          <source>If required to truncate a database page from the end of the database file, the associated</source>
          <target state="translated">データベースファイルの末尾からデータベースページを切り詰める必要がある場合、関連する</target>
        </trans-unit>
        <trans-unit id="986e38dddb8763966fae3720cfb00c3ae4f64940" translate="yes" xml:space="preserve">
          <source>If result of an &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; comparison on the same two operands as the prior &lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt; or &lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt; would have been NULL or false (0), then then jump to P2. If the result of an &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; comparison on the two previous operands would have been true (1), then fall through.</source>
          <target state="translated">If result of an &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; comparison on the same two operands as the prior &lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt; or &lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt; would have been NULL or false (0), then then jump to P2. If the result of an &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; comparison on the two previous operands would have been true (1), then fall through.</target>
        </trans-unit>
        <trans-unit id="3939be1758da993faac1647e5a0238d1c34fd401" translate="yes" xml:space="preserve">
          <source>If running in &lt;a href=&quot;../sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, the application must guarantee that the shared cache used by the destination database is not accessed while the backup is running. In practice this means that the application must guarantee that the disk file being backed up to is not accessed by any connection within the process, not just the specific connection that was passed to sqlite3_backup_init().</source>
          <target state="translated">&lt;a href=&quot;../sharedcache&quot;&gt;共有キャッシュモード&lt;/a&gt;で実行している場合、アプリケーションは、バックアップの実行中に宛先データベースが使用する共有キャッシュにアクセスしないことを保証する必要があります。実際には、これは、アプリケーションが、sqlite3_backup_init（）に渡された特定の接続だけでなく、プロセス内のどの接続からもアクセスされないことを保証する必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="91671997be6a1d6d67488b4259ddff989b286fc6" translate="yes" xml:space="preserve">
          <source>If running in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, the application must guarantee that the shared cache used by the destination database is not accessed while the backup is running. In practice this means that the application must guarantee that the disk file being backed up to is not accessed by any connection within the process, not just the specific connection that was passed to sqlite3_backup_init().</source>
          <target state="translated">&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュモード&lt;/a&gt;で実行している場合、アプリケーションは、バックアップの実行中に宛先データベースが使用する共有キャッシュにアクセスしないことを保証する必要があります。実際には、これは、アプリケーションが、sqlite3_backup_init（）に渡された特定の接続だけでなく、プロセス内のどの接続からもアクセスされないことを保証する必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="813ffbbe7a10f587c30164e3c760a93f923869e0" translate="yes" xml:space="preserve">
          <source>If set to 1, then the default &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt; is set to EXCLUSIVE. If omitted or set to 0 then the default &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt; is NORMAL.</source>
          <target state="translated">1に設定すると、デフォルトの&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt;はEXCLUSIVEに設定されます。省略した場合、または0に設定した場合、デフォルトの&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt;はNORMALです。</target>
        </trans-unit>
        <trans-unit id="8dd726c58400329230cb7ffbb590015b7fc272ad" translate="yes" xml:space="preserve">
          <source>If single-thread mode has not been selected at compile-time or start-time, then individual database connections can be created as either multi-thread or serialized. It is not possible to downgrade an individual database connection to single-thread mode. Nor is it possible to escalate an individual database connection if the compile-time or start-time mode is single-thread.</source>
          <target state="translated">コンパイル時または起動時にシングルスレッドモードが選択されていない場合、個々のデータベース接続はマルチスレッドまたはシリアライズのいずれかで作成することができます。個々のデータベース接続をシングルスレッドモードにダウングレードすることはできません。また、コンパイル時または開始時のモードがシングルスレッドの場合、個々のデータベース接続をエスカレートすることもできません。</target>
        </trans-unit>
        <trans-unit id="297fbafe0f12618a3892916307ed5e193747b9f8" translate="yes" xml:space="preserve">
          <source>If single-thread mode is selected at compile-time, then critical mutexing logic is omitted from the build and it is impossible to enable either multi-thread or serialized modes at start-time or run-time.</source>
          <target state="translated">コンパイル時にシングルスレッドモードが選択されている場合、重要なミューテックスロジックがビルドから省略され、起動時や実行時にマルチスレッドモードやシリアライズモードを有効にすることはできません。</target>
        </trans-unit>
        <trans-unit id="bc15b1addaaecdb30cb643e4374238a5f983835b" translate="yes" xml:space="preserve">
          <source>If some future version of SQLite adds new ALTER TABLE capabilities, those capabilities will very likely use one of the two procedures outlined above.</source>
          <target state="translated">将来のバージョンのSQLiteに新しいALTER TABLE機能が追加された場合、その機能は上で説明した2つのプロシージャのうちの1つを使用することになるでしょう。</target>
        </trans-unit>
        <trans-unit id="a247ea4cd25be5ebc1e3446b36da4e3d6e48aaf1" translate="yes" xml:space="preserve">
          <source>If some other error occurs (e.g. an OOM condition), an SQLite error code is returned and *ppValue is set to NULL.</source>
          <target state="translated">その他のエラーが発生した場合(OOM条件など)、SQLiteエラーコードが返され、*ppValueがNULLに設定されます。</target>
        </trans-unit>
        <trans-unit id="e277177a9a5ad8b0a8ae8ddf4692ab5b1cd48938" translate="yes" xml:space="preserve">
          <source>If specified, interpret all relative paths as relative to DIR, instead of the current working directory.</source>
          <target state="translated">指定された場合、すべての相対パスを、カレントの作業ディレクトリではなく、DIRに対する相対パスとして解釈します。</target>
        </trans-unit>
        <trans-unit id="c10bbb5923a9a453a504ada2ef95db3b448455c2" translate="yes" xml:space="preserve">
          <source>If specified, use file FILE as the archive. Otherwise, assume that the current &quot;main&quot; database is the archive to be operated on.</source>
          <target state="translated">指定された場合、アーカイブとしてFILEファイルを使用します。そうでなければ、現在の &quot;メイン &quot;データベースが操作対象のアーカイブであると仮定します。</target>
        </trans-unit>
        <trans-unit id="781f0c1e44a6d5e4cbc382e01b2a73157527db47" translate="yes" xml:space="preserve">
          <source>If sqlite3_backup_step() cannot obtain a required file-system lock, then the &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy-handler function&lt;/a&gt; is invoked (if one is specified). If the busy-handler returns non-zero before the lock is available, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned to the caller. In this case the call to sqlite3_backup_step() can be retried later. If the source &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is being used to write to the source database when sqlite3_backup_step() is called, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt; is returned immediately. Again, in this case the call to sqlite3_backup_step() can be retried later on. If &lt;a href=&quot;#SQLITE_ABORT_ROLLBACK&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt; is returned, then there is no point in retrying the call to sqlite3_backup_step(). These errors are considered fatal. The application must accept that the backup operation has failed and pass the backup operation handle to the sqlite3_backup_finish() to release associated resources.</source>
          <target state="translated">sqlite3_backup_step（）が必要なファイルシステムロックを取得できない場合、&lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy-handler関数&lt;/a&gt;が呼び出されます（指定されている場合）。ロックが使用可能になる前にbusy-handlerがゼロ以外の値を返した場合、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;が呼び出し元に返されます。この場合、sqlite3_backup_step（）の呼び出しは後で再試行できます。sqlite3_backup_step（）が呼び出されたときにソースデータベースへの書き込みにソース&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;が使用されている場合、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt;がすぐに返されます。この場合も、sqlite3_backup_step（）の呼び出しは後で再試行できます。もし&lt;a href=&quot;#SQLITE_ABORT_ROLLBACK&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt;、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;、または&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt;が返された場合、sqlite3_backup_step（）の呼び出しを再試行しても意味がありません。これらのエラーは致命的と見なされます。アプリケーションは、バックアップ操作が失敗したことを受け入れ、バックアップ操作ハンドルをsqlite3_backup_finish（）に渡して、関連するリソースを解放する必要があります。</target>
        </trans-unit>
        <trans-unit id="97664464d7946d7d0d5f82dbee0724dc2319f847" translate="yes" xml:space="preserve">
          <source>If sqlite3_backup_step() cannot obtain a required file-system lock, then the &lt;a href=&quot;busy_handler&quot;&gt;busy-handler function&lt;/a&gt; is invoked (if one is specified). If the busy-handler returns non-zero before the lock is available, then &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned to the caller. In this case the call to sqlite3_backup_step() can be retried later. If the source &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is being used to write to the source database when sqlite3_backup_step() is called, then &lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; is returned immediately. Again, in this case the call to sqlite3_backup_step() can be retried later on. If &lt;a href=&quot;../rescode#ioerr_access&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt;, &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, or &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt; is returned, then there is no point in retrying the call to sqlite3_backup_step(). These errors are considered fatal. The application must accept that the backup operation has failed and pass the backup operation handle to the sqlite3_backup_finish() to release associated resources.</source>
          <target state="translated">sqlite3_backup_step（）が必要なファイルシステムロックを取得できない場合、&lt;a href=&quot;busy_handler&quot;&gt;busy-handler関数&lt;/a&gt;が呼び出されます（指定されている場合）。ロックが使用可能になる前にbusy-handlerがゼロ以外の値を返した場合、&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;が呼び出し元に返されます。この場合、sqlite3_backup_step（）の呼び出しは後で再試行できます。sqlite3_backup_step（）が呼び出されたときにソースデータベースへの書き込みにソース&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;が使用されている場合、&lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt;がすぐに返されます。この場合も、sqlite3_backup_step（）の呼び出しは後で再試行できます。もし&lt;a href=&quot;../rescode#ioerr_access&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt;、&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;、または&lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;が返された場合、sqlite3_backup_step（）の呼び出しを再試行しても意味がありません。これらのエラーは致命的と見なされます。アプリケーションは、バックアップ操作が失敗したことを受け入れ、バックアップ操作ハンドルをsqlite3_backup_finish（）に渡して、関連するリソースを解放する必要があります。</target>
        </trans-unit>
        <trans-unit id="416d4d371ff0cd3598d43dc30a0639c13aed646a" translate="yes" xml:space="preserve">
          <source>If sqlite3_deserialize(D,S,P,N,M,F) fails for any reason and if the SQLITE_DESERIALIZE_FREEONCLOSE bit is set in argument F, then &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; is invoked on argument P prior to returning.</source>
          <target state="translated">sqlite3_deserialize（D、S、P、N、M、F）が何らかの理由で失敗し、SQLITE_DESERIALIZE_FREEONCLOSEビットが引数Fで設定されている場合、戻る前に引数Pで&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="cec31d664476098d45397cb4e64acc667d8c0501" translate="yes" xml:space="preserve">
          <source>If sqlite3_deserialize(D,S,P,N,M,F) fails for any reason and if the SQLITE_DESERIALIZE_FREEONCLOSE bit is set in argument F, then &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; is invoked on argument P prior to returning.</source>
          <target state="translated">sqlite3_deserialize（D、S、P、N、M、F）が何らかの理由で失敗し、SQLITE_DESERIALIZE_FREEONCLOSEビットが引数Fで設定されている場合、戻る前に引数Pで&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="aeea9650fe067179f154dc4c0a23753bc2cbcaea" translate="yes" xml:space="preserve">
          <source>If sqlite3_malloc() fails during the processing of either routine (for example during a conversion from UTF-8 to UTF-16) then a NULL pointer is returned.</source>
          <target state="translated">どちらかのルーチンの処理中(例えばUTF-8からUTF-16への変換中など)にsqlite3_malloc()が失敗した場合、NULLポインタが返されます。</target>
        </trans-unit>
        <trans-unit id="cac2f36b365eeaba945df88aa0f1da7631750708" translate="yes" xml:space="preserve">
          <source>If sqlite3_unlock_notify() is called in a multi-threaded application, there is a chance that the blocking connection will have already concluded its transaction by the time sqlite3_unlock_notify() is invoked. If this happens, then the specified callback is invoked immediately, from within the call to sqlite3_unlock_notify().</source>
          <target state="translated">マルチスレッド・アプリケーションでsqlite3_unlock_notify()が呼び出された場合、sqlite3_unlock_notify()が呼び出されるまでにブロッキング接続が既にトランザクションを終了している可能性があります。この場合、指定されたコールバックはsqlite3_unlock_notify()の呼び出しの中から直ちに呼び出されます。</target>
        </trans-unit>
        <trans-unit id="d3dbf8613ad9cf5c029072fff340e1a64123138d" translate="yes" xml:space="preserve">
          <source>If state database S does not exist when sqlite3rbu_vacuum() is invoked, it is automatically created and populated with the single table used to store the state of an RBU vacuum - &quot;rbu_state&quot;. If an ongoing RBU vacuum is suspended, this table is populated with state data. The next time sqlite3rbu_vacuum() is called with the same S parameter, it detects this data and attempts to resume the suspended vacuum operation. When an RBU vacuum operation is completed or encounters an error, RBU automatically deletes the contents of the rbu_state table. In this case, the next call to sqlite3rbu_vacuum() starts an entirely new vacuum operation from scratch.</source>
          <target state="translated">sqlite3rbu_vacuum()が呼び出された時に状態データベースSが存在しない場合、自動的に作成され、RBUバキュームの状態を格納するために使用される単一のテーブル &quot;rbu_state &quot;で生成されます。進行中のRBUバキュームが中断された場合、このテーブルには状態データが格納されます。次にsqlite3rbu_vacuum()が同じSパラメータで呼び出された時、このデータを検出し、中断していた真空操作を再開しようとします。RBUのバキューム操作が完了したとき、またはエラーに遭遇したとき、RBUは自動的にrbu_stateテーブルの内容を削除します。この場合、次のsqlite3rbu_vacuum()の呼び出しは、全く新しいバキューム操作をゼロから開始します。</target>
        </trans-unit>
        <trans-unit id="9b583cb7d9f730fb38a0d4c0658d985458639786" translate="yes" xml:space="preserve">
          <source>If step 1 was successful, an attempt is made to read the</source>
          <target state="translated">ステップ1が成功した場合は</target>
        </trans-unit>
        <trans-unit id="95b4922965cf280511e54a7e6a975a3cf943cead" translate="yes" xml:space="preserve">
          <source>If successful, a pointer to a buffer containing the inverted changeset is stored in *ppOut, the size of the same buffer is stored in *pnOut, and SQLITE_OK is returned. If an error occurs, both *pnOut and *ppOut are zeroed and an SQLite error code returned.</source>
          <target state="translated">成功した場合、転置されたチェンジセットを含むバッファへのポインタが *ppOut に格納され、同じバッファのサイズが *pnOut に格納され、SQLITE_OK が返されます。エラーが発生した場合、*pnOut と *ppOut の両方がゼロになり、SQLite のエラーコードが返されます。</target>
        </trans-unit>
        <trans-unit id="2d2a26797b61cd3892af9cbfe95715fb203e64ff" translate="yes" xml:space="preserve">
          <source>If successful, this function returns SQLITE_OK and populates (*pp) with a pointer to a new sqlite3_changegroup object before returning. The caller should eventually free the returned object using a call to sqlite3changegroup_delete(). If an error occurs, an SQLite error code (i.e. SQLITE_NOMEM) is returned and *pp is set to NULL.</source>
          <target state="translated">成功した場合、この関数はSQLITE_OKを返し、返す前に新しいsqlite3_changegroupオブジェクトへのポインタを(*pp)に格納します。呼び出し元は最終的にsqlite3changegroup_delete()を呼び出して返されたオブジェクトを解放しなければなりません。エラーが発生した場合、SQLiteエラーコード(すなわちSQLITE_NOMEM)が返され、*ppはNULLに設定されます。</target>
        </trans-unit>
        <trans-unit id="25d0330551ddd2fa16bdd016ab08a130f3f7634f" translate="yes" xml:space="preserve">
          <source>If successful, this function sets *ppValue to point to a protected sqlite3_value object containing the iVal'th value from the &quot;conflicting row&quot; associated with the current conflict-handler callback and returns SQLITE_OK.</source>
          <target state="translated">成功した場合、この関数は、現在のコンフリクトハンドラコールバックに関連付けられた &quot;競合する行 &quot;のiVal'th値を含む、保護されたsqlite3_valueオブジェクトを指すように*ppValueを設定し、SQLITE_OKを返します。</target>
        </trans-unit>
        <trans-unit id="fa261183bb429d753dbe1a765227df127f987423" translate="yes" xml:space="preserve">
          <source>If successful, this function sets *ppValue to point to a protected sqlite3_value object containing the iVal'th value from the vector of new row values stored as part of the UPDATE or INSERT change and returns SQLITE_OK. If the change is an UPDATE and does not include a new value for the requested column, *ppValue is set to NULL and SQLITE_OK returned. The name of the function comes from the fact that this is similar to the &quot;new.*&quot; columns available to update or delete triggers.</source>
          <target state="translated">成功した場合、この関数は*ppValueをUPDATEまたはINSERTの変更の一部として格納された新しい行の値のベクトルからiVal'thの値を含む保護されたsqlite3_valueオブジェクトを指すように設定し、SQLITE_OKを返します。変更がUPDATEで、要求された列の新しい値が含まれていない場合、*ppValueはNULLに設定され、SQLITE_OKが返されます。この関数の名前は、これが更新や削除のトリガーで利用可能な &quot;new.*&quot;カラムに似ていることに由来しています。</target>
        </trans-unit>
        <trans-unit id="8a04e15ae358710d2ad80e6a9a9c13bb73faba6b" translate="yes" xml:space="preserve">
          <source>If successful, this function sets *ppValue to point to a protected sqlite3_value object containing the iVal'th value from the vector of original row values stored as part of the UPDATE or DELETE change and returns SQLITE_OK. The name of the function comes from the fact that this is similar to the &quot;old.*&quot; columns available to update or delete triggers.</source>
          <target state="translated">成功した場合、この関数は*ppValueをUPDATEまたはDELETE変更の一部として格納された元の行の値のベクトルからiVal'thの値を含む保護されたsqlite3_valueオブジェクトを指すように設定し、SQLITE_OKを返します。この関数の名前は、これが更新や削除のトリガーで利用可能な &quot;old.*&quot;カラムに似ていることに由来しています。</target>
        </trans-unit>
        <trans-unit id="5f323dfa9043b9e0668bb0be64be173c0214f5b4" translate="yes" xml:space="preserve">
          <source>If successful, xCreateFunction() returns SQLITE_OK. Otherwise, it returns an SQLite error code. In this case the xDestroy function is &lt;b&gt;not&lt;/b&gt; invoked.</source>
          <target state="translated">正常に実行された場合、xCreateFunction（）はSQLITE_OKを戻します。それ以外の場合は、SQLiteエラーコードを返します。この場合、xDestroy関数は呼び出され&lt;b&gt;ません&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="0c5491699943eedd46aaea7dc769af1705417f26" translate="yes" xml:space="preserve">
          <source>If successful, xCreateTokenizer() returns SQLITE_OK. Otherwise, it returns an SQLite error code. In this case the xDestroy function is &lt;b&gt;not&lt;/b&gt; invoked.</source>
          <target state="translated">正常に実行された場合、xCreateTokenizer（）はSQLITE_OKを戻します。それ以外の場合は、SQLiteエラーコードを返します。この場合、xDestroy関数は呼び出され&lt;b&gt;ません&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="128b9faf8d31130c2470e9c58674eddd1a9c50a3" translate="yes" xml:space="preserve">
          <source>If such a text fragment can be found, it is returned with the following modifications:</source>
          <target state="translated">そのようなテキストフラグメントが見つかった場合は、以下のように修正して返されます。</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">の場合は</target>
        </trans-unit>
        <trans-unit id="2b388f659392c2a3dcc9c7c0db559bd88cf8ff51" translate="yes" xml:space="preserve">
          <source>If the &quot;.output&quot; or &quot;.once&quot; commands have a &quot;-x&quot; argument, that causes them to accumulate output as Comma-Separated-Values (CSV) in a temporary file, then invoke the default system utility for viewing CSV files (usually a spreadsheet program) on the result. This is a quick way of sending the result of a query to a spreadsheet for easy viewing:</source>
          <target state="translated">output &quot;または &quot;once &quot;コマンドに&quot;-x &quot;引数がある場合、一時ファイルにカンマ区切り値(CSV)として出力を蓄積し、その結果にCSVファイルを表示するためのデフォルトのシステムユーティリティ(通常はスプレッドシートプログラム)を起動します。これは、クエリの結果をスプレッドシートに送信して簡単に表示するための手っ取り早い方法です。</target>
        </trans-unit>
        <trans-unit id="b4746f29b85def95350d80c6bb29ef47dac1ca98" translate="yes" xml:space="preserve">
          <source>If the &quot;.output&quot; or &quot;.once&quot; commands have an argument of &quot;-e&quot; then output is collected into a temporary file and the system text editor is invoked on that text file. Thus, the command &quot;.once -e&quot; achieves the same result as &quot;.once '|open -f'&quot; but with the benefit of being portable across all systems.</source>
          <target state="translated">もし &quot;.output&quot; または &quot;.once&quot; コマンドの引数が &quot;-e&quot; の場合、出力は一時ファイルに集められ、そのテキストファイル上でシステムのテキストエディタが起動されます。このように、&quot;.once -e&quot; コマンドは &quot;.once '|open -f'&quot; と同じ結果を得ることができますが、すべてのシステムで移植性があるという利点があります。</target>
        </trans-unit>
        <trans-unit id="3daa35758772f94d91f7bd83ab5f9ceb0840b773" translate="yes" xml:space="preserve">
          <source>If the &quot;.recover&quot; command recovers one or more rows that it cannot attribute to any database table, the output script creates a &quot;lost_and_found&quot; table to store the orphaned rows. The schema of the lost_and_found table is as follows:</source>
          <target state="translated">.recover &quot;コマンドが、どのデータベーステーブルにも属性を付与できない1つ以上の行を回復した場合、出力スクリプトは、孤児となった行を格納するための &quot;lost_and_found &quot;テーブルを作成する。lost_and_foundテーブルのスキーマは以下の通りである。</target>
        </trans-unit>
        <trans-unit id="1ddf7f749d8128e48a3bd895bfea3bcecad29d40" translate="yes" xml:space="preserve">
          <source>If the &quot;CREATE VIRTUAL TABLE&quot; statement specifies module FTS4 (not FTS3), then special directives - FTS4 options - similar to the &quot;tokenize=*&quot; option may also appear in place of column names. An FTS4 option consists of the option name, followed by an &quot;=&quot; character, followed by the option value. The option value may optionally be enclosed in single or double quotes, with embedded quote characters escaped in the same way as for SQL literals. There may not be whitespace on either side of the &quot;=&quot; character. For example, to create an FTS4 table with the value of option &quot;matchinfo&quot; set to &quot;fts3&quot;:</source>
          <target state="translated">CREATE VIRTUAL TABLE&quot; ステートメントがモジュール FTS4 (FTS3ではない)を指定している場合、&quot;tokenize=*&quot; オプションに似た特別なディレクティブ-FTS4 オプション-が列名の代わりに現れることがあります。FTS4オプションは、オプション名の後に&quot;=&quot;文字が続き、その後にオプション値が続く。オプション値は、一重引用符または二重引用符で囲むことができ、埋め込まれた引用符は、SQLリテラルの場合と同様にエスケープされる。また、「=」文字の両側には空白を入れてはいけない。例えば、オプション &quot;matchinfo &quot;の値を &quot;fts3 &quot;に設定したFTS4テーブルを作成する場合。</target>
        </trans-unit>
        <trans-unit id="77546b3dd108217dd30ccb1edbd6835383de8523" translate="yes" xml:space="preserve">
          <source>If the &quot;TEMP&quot; or &quot;TEMPORARY&quot; keyword occurs in between &quot;CREATE&quot; and &quot;VIEW&quot; then the view that is created is only visible to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; that created it and is automatically deleted when the database connection is closed.</source>
          <target state="translated">「TEMP」または「TEMPORARY」キーワードが「CREATE」と「VIEW」の間にある場合、作成されたビューはそれを作成した&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;でのみ表示され、データベース接続が閉じられると自動的に削除されます。</target>
        </trans-unit>
        <trans-unit id="e15eb31b4ca840d3439ac476fb29777eeeba453d" translate="yes" xml:space="preserve">
          <source>If the &quot;col&quot; column contains the value '*', then this column contains the number of rows of the FTS table that contain at least one instance of the term (in any column). If col contains an integer value, then this column contains the number of rows of the FTS table that contain at least one instance of the term in the column identified by the col value. As usual, the columns of the FTS table are numbered from left to right, starting with zero.</source>
          <target state="translated">col」列に値「*」が含まれている場合、この列には、(どの列でも)その用語の少なくとも1つのインスタンスを含むFTSテーブルの行数が含まれる。col が整数値を含む場合、この列には、col の値で識別される列に用語の少なくとも一つのインスタンスを含む FTS テーブルの行の数が含まれる。通常通り、FTS テーブルの列は左から右へ、ゼロから始まる番号が付けられます。</target>
        </trans-unit>
        <trans-unit id="be0668162f080a59b68a89416d5dac39edc657f3" translate="yes" xml:space="preserve">
          <source>If the &quot;col&quot; column contains the value '*', then this column contains the total number of instances of the term in all rows of the FTS table (in any column). Otherwise, if col contains an integer value, then this column contains the total number of instances of the term that appear in the FTS table column identified by the col value.</source>
          <target state="translated">col」列が値「*」を含む場合、この列には、FTSテーブルの全行(任意の列)のタームのインスタンスの合計数が含まれる。そうでなければ、colが整数値を含む場合、この列には、colの値によって識別されるFTSテーブルの列に現れるタームのインスタンスの合計数が含まれる。</target>
        </trans-unit>
        <trans-unit id="f99db6ea5060e99b5afec54227ba46139ccc5e7b" translate="yes" xml:space="preserve">
          <source>If the &quot;schema&quot; is omitted, it defaults to the primary database (usually called 'main', unless renamed using &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigmaindbname&quot;&gt;SQLITE_DBCONFIG_MAINDBNAME&lt;/a&gt;). Hence, the following two queries are normally equivalent:</source>
          <target state="translated">「スキーマ」を省略すると、デフォルトでプライマリデータベースになります（&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigmaindbname&quot;&gt;SQLITE_DBCONFIG_MAINDBNAME&lt;/a&gt;を使用して名前を変更しない限り、通常は「メイン」と呼ばれます）。したがって、次の2つのクエリは通常同等です。</target>
        </trans-unit>
        <trans-unit id="9f6d4e5f223a311e53834767137885dbc0d539c8" translate="yes" xml:space="preserve">
          <source>If the &quot;unordered&quot; argument is present, then the query planner assumes that the index is unordered and will not use the index for a range query or for sorting.</source>
          <target state="translated">unordered &quot;引数が存在する場合、クエリプランナはインデックスが順序付けられていないと仮定し、範囲問い合わせやソートにはインデックスを使用しません。</target>
        </trans-unit>
        <trans-unit id="8751a71ff20c3c0ca54298560e238a1beb92d451" translate="yes" xml:space="preserve">
          <source>If the $bigstring variable has both a string and a &quot;bytearray&quot; representation, then TCL inserts the value as a string. If it has only a &quot;bytearray&quot; representation, then the value is inserted as a BLOB. To force a value to be inserted as a BLOB even if it also has a text representation, use a &quot;@&quot; character to in place of the &quot;$&quot;. Like this:</source>
          <target state="translated">BIGSTRING 変数が文字列とバイト配列の両方の表現を持つ場合、TCL はその値を文字列として挿入します。バイト配列」表現のみを持つ場合は、値は BLOB として挿入されます。値がテキスト表現でも BLOB として挿入されるようにするには、&quot;$&quot; の代わりに &quot;@&quot; 文字を使用します。このようにします。</target>
        </trans-unit>
        <trans-unit id="0c3adca9fee497a14e9991dafc4be56e1a6347bb" translate="yes" xml:space="preserve">
          <source>If the %Q formatting option is used instead of %q, like this:</source>
          <target state="translated">q の代わりに %Q フォーマットオプションが使用されている場合、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="0d1bfccef6e7ea95fdaf4eab71d72c15d5446d0c" translate="yes" xml:space="preserve">
          <source>If the --vtab option is passed to sqldiff.exe, then it ignores all underlying shadow tables belonging to an FTS3, FTS5 or rtree virtual table and instead includes the virtual table differences directly.</source>
          <target state="translated">sqldiff.exeに--vtabオプションが渡された場合、FTS3、FTS5、またはrtree仮想テーブルに属するすべてのシャドウテーブルを無視し、代わりに仮想テーブルの差分を直接含めます。</target>
        </trans-unit>
        <trans-unit id="07a5d9f4ebefe616bbce2e1699c303419392f340" translate="yes" xml:space="preserve">
          <source>If the 2nd parameter actually contains two or more statements of SQL, only the first statement is compiled. (This is different from the behavior of &lt;b&gt;sqlite_exec&lt;/b&gt; which executes all SQL statements in its input string.) The 3rd parameter to &lt;b&gt;sqlite_compile&lt;/b&gt; is made to point to the first character beyond the end of the first statement of SQL in the input. If the 2nd parameter contains only a single SQL statement, then the 3rd parameter will be made to point to the '\000' terminator at the end of the 2nd parameter.</source>
          <target state="translated">2番目のパラメーターに実際にSQLの2つ以上のステートメントが含まれている場合、最初のステートメントのみがコンパイルされます。（これは、入力文字列内のすべてのSQLステートメントを実行する&lt;b&gt;sqlite_exec&lt;/b&gt;の動作とは異なります。）&lt;b&gt;sqlite_compile&lt;/b&gt;の3番目のパラメーターは、入力内のSQLの最初のステートメントの終わりを超える最初の文字を指すように作成されます。2番目のパラメーターに単一のSQLステートメントのみが含まれている場合、3番目のパラメーターは、2番目のパラメーターの末尾にある '\ 000'ターミネーターを指すように作成されます。</target>
        </trans-unit>
        <trans-unit id="ace6723edaabac46df7516bfbb37cb232ed631b4" translate="yes" xml:space="preserve">
          <source>If the 2nd parameter to sqlite3_exec() is a NULL pointer, a pointer to an empty string, or a pointer that contains only whitespace and/or SQL comments, then no SQL statements are evaluated and the database is not changed.</source>
          <target state="translated">sqlite3_exec()の2番目のパラメータがNULLポインタ、空の文字列へのポインタ、空白文字やSQLコメントのみを含むポインタの場合、SQL文は評価されず、データベースは変更されません。</target>
        </trans-unit>
        <trans-unit id="c83d25737a958db458bb466d715ef1df1385742b" translate="yes" xml:space="preserve">
          <source>If the 3rd parameter to sqlite3_open_v2() is not one of the combinations shown above optionally combined with other &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_* bits&lt;/a&gt; then the behavior is undefined.</source>
          <target state="translated">sqlite3_open_v2（）の3番目のパラメーターが上記の組み合わせの1つではなく、オプションで他の&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_ *ビット&lt;/a&gt;と組み合わせられている場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="a1fab614cdb3090bc486b1f93bb2bcc48a6de130" translate="yes" xml:space="preserve">
          <source>If the 3rd parameter to sqlite3_open_v2() is not one of the combinations shown above optionally combined with other &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_* bits&lt;/a&gt; then the behavior is undefined.</source>
          <target state="translated">sqlite3_open_v2（）の3番目のパラメーターが上記の組み合わせの1つではなく、オプションで他の&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_ *ビット&lt;/a&gt;と組み合わせられている場合、動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="fab55d69b6d16a6b2315e4a3b04227ca982143b2" translate="yes" xml:space="preserve">
          <source>If the 3rd parameter to sqlite3_open_v2() is not one of the required combinations shown above optionally combined with other &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_* bits&lt;/a&gt; then the behavior is undefined.</source>
          <target state="translated">If the 3rd parameter to sqlite3_open_v2() is not one of the required combinations shown above optionally combined with other &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_* bits&lt;/a&gt; then the behavior is undefined.</target>
        </trans-unit>
        <trans-unit id="eafad762f6d4301ebb9f9fbfe8b641eb52751808" translate="yes" xml:space="preserve">
          <source>If the 3rd parameter to sqlite3_open_v2() is not one of the required combinations shown above optionally combined with other &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_* bits&lt;/a&gt; then the behavior is undefined.</source>
          <target state="translated">If the 3rd parameter to sqlite3_open_v2() is not one of the required combinations shown above optionally combined with other &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_* bits&lt;/a&gt; then the behavior is undefined.</target>
        </trans-unit>
        <trans-unit id="34c05ef78416159159b83c40de507c749c65acd9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; flag is set, then the database connection opens in the multi-thread &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; as long as the single-thread mode has not been set at compile-time or start-time. If the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; flag is set then the database connection opens in the serialized &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; unless single-thread was previously selected at compile-time or start-time. The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; flag causes the database connection to be eligible to use &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, regardless of whether or not shared cache is enabled using &lt;a href=&quot;#sqlite3_enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;. The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; flag causes the database connection to not participate in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; even if it is enabled.</source>
          <target state="translated">&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;フラグが設定されている場合、シングルスレッドモードがコンパイル時または開始時に設定されていない限り、データベース接続はマルチスレッド&lt;a href=&quot;threadsafe&quot;&gt;スレッドモード&lt;/a&gt;で開きます。&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;フラグが設定されている場合、コンパイル時または開始時にシングルスレッドが以前に選択されていなければ、データベース接続はシリアル&lt;a href=&quot;threadsafe&quot;&gt;化&lt;/a&gt;されたスレッドモードで開きます。&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHEの&lt;/a&gt;フラグは、データベース接続を使用する資格させる&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュモード&lt;/a&gt;かどうかにかかわらず、共有キャッシュの使用して有効になっている、&lt;a href=&quot;#sqlite3_enable_shared_cache&quot;&gt;sqlite3_enable_shared_cacheを（） &lt;/a&gt;。&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;フラグを設定すると、データベース接続が有効になっていても、&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュモードに&lt;/a&gt;参加しません。</target>
        </trans-unit>
        <trans-unit id="f124aef410c3a3a5452b1a6fa293c0baf98a2590" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; passed as the first argument was not opened for writing (the flags parameter to &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; was zero), this function returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt;.</source>
          <target state="translated">最初の引数として渡された&lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOBハンドル&lt;/a&gt;が書き込み用に開かれていなかった&lt;a href=&quot;#sqlite3_blob_open&quot;&gt;場合（sqlite3_blob_open（）&lt;/a&gt;へのフラグパラメータがゼロであった場合）、この関数は&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLYを&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="b097a680522bfef6d5db94910e22cbe0a87ca6c4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method sets the sqlite3_file.pMethods element to a non-NULL pointer, then the sqlite3_io_methods.xClose method may be invoked even if the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; reported that it failed. The only way to prevent a call to xClose following a failed &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; is for the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; to set the sqlite3_file.pMethods element to NULL.</source>
          <target state="translated">場合&lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpenの&lt;/a&gt;方法は、非NULLポインタにsqlite3_file.pMethods要素を設定し、その後sqlite3_io_methods.xClose方法は、場合でも呼び出すことができる&lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpenは、&lt;/a&gt;それが失敗したことを報告しました。失敗し、次のxCloseへの呼び出しを防ぐ唯一の方法&lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpenは&lt;/a&gt;です&lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpenが&lt;/a&gt; NULLにsqlite3_file.pMethods要素を設定します。</target>
        </trans-unit>
        <trans-unit id="c4075392a6aa7bc2b0c022c207b5beef854359fa" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot; id=&quot;sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; opcode returns SQLITE_OK, then the file descriptor is placed in &quot;batch write mode&quot;, which means all subsequent write operations will be deferred and done atomically at the next &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;. Systems that do not support batch atomic writes will return SQLITE_NOTFOUND. Following a successful SQLITE_FCNTL_BEGIN_ATOMIC_WRITE and prior to the closing &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; or &lt;a href=&quot;#sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt;, SQLite will make no VFS interface calls on the same &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; file descriptor except for calls to the xWrite method and the xFileControl method with &lt;a href=&quot;#sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot; id=&quot;sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;オペコードがSQLITE_OKを返す場合、ファイル記述子は「バッチ書き込みモード」に置かれます。これは、後続のすべての書き込み操作が遅延され、次の&lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITEで&lt;/a&gt;アトミックに実行されることを意味します。バッチアトミック書き込みをサポートしないシステムは、SQLITE_NOTFOUNDを返します。成功SQLITE_FCNTL_BEGIN_ATOMIC_WRITE前クロージングするには、以下の&lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;または&lt;a href=&quot;#sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt;、SQLiteは同じにはVFSインタフェース呼び出しを行いません&lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_fileの&lt;/a&gt; xWrite方法としてxFileControlメソッドの呼び出し以外のファイルディスクリプタを&lt;a href=&quot;#sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eadccb78851e96452064935ca6338980e2d4c8f7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method calls sqlite3_vtab_nochange() and finds that the column is not changed by the UPDATE statement, then the xColumn method can optionally return without setting a result, without calling any of the &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_xxxxx() interfaces&lt;/a&gt;. In that case, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_nochange(X)&lt;/a&gt; will return true for the same column in the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method.</source>
          <target state="translated">場合&lt;a href=&quot;../vtab#xcolumn&quot;&gt;Xcolumnにする&lt;/a&gt;メソッド呼び出しは、列がUPDATE文によって変更されないことsqlite3_vtab_nochange（）と求め、次いでXcolumnに方法は、任意の任意呼び出すことなく、結果を設定せずに返すことができ&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_xxxxx（）インターフェースを&lt;/a&gt;。その場合、&lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_nochange（X）&lt;/a&gt;は、&lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;メソッドの同じ列に対してtrueを返します。</target>
        </trans-unit>
        <trans-unit id="a8a1933767ab95a99c4ac8ef45461802121a0a08" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; passed as the first argument was not opened for writing (the flags parameter to &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; was zero), this function returns &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;.</source>
          <target state="translated">最初の引数として渡された&lt;a href=&quot;blob&quot;&gt;BLOBハンドル&lt;/a&gt;が書き込み用に開かれていなかった&lt;a href=&quot;blob_open&quot;&gt;場合（sqlite3_blob_open（）&lt;/a&gt;へのフラグパラメータがゼロであった場合）、この関数は&lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLYを&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="b723e9fc3d49332b65d60edda223c8ec9ca4d696" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; interface is used to override the glob(X,Y) function with an alternative implementation then the &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator will invoke the alternative implementation.</source>
          <target state="translated">場合&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function（）&lt;/a&gt;インターフェースを代替実装でグロブ（X、Y）の機能をオーバーライドするために使用され、次いで&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOBの&lt;/a&gt;オペレータは、別のインプリメンテーションを呼び出します。</target>
        </trans-unit>
        <trans-unit id="3092cc5ebddb90376d018bb6c31fa51fc5b9d178" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot; id=&quot;sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; opcode returns SQLITE_OK, then the file descriptor is placed in &quot;batch write mode&quot;, which means all subsequent write operations will be deferred and done atomically at the next &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;. Systems that do not support batch atomic writes will return SQLITE_NOTFOUND. Following a successful SQLITE_FCNTL_BEGIN_ATOMIC_WRITE and prior to the closing &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; or &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt;, SQLite will make no VFS interface calls on the same &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; file descriptor except for calls to the xWrite method and the xFileControl method with &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot; id=&quot;sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;オペコードがSQLITE_OKを返す場合、ファイル記述子は「バッチ書き込みモード」に置かれます。これは、後続のすべての書き込み操作が遅延され、次の&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITEで&lt;/a&gt;アトミックに実行されることを意味します。バッチアトミック書き込みをサポートしないシステムは、SQLITE_NOTFOUNDを返します。成功SQLITE_FCNTL_BEGIN_ATOMIC_WRITE前クロージングするには、以下の&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;または&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt;、SQLiteは同じにはVFSインタフェース呼び出しを行いません&lt;a href=&quot;file&quot;&gt;sqlite3_fileの&lt;/a&gt; xWrite方法としてxFileControlメソッドの呼び出し以外のファイルディスクリプタを&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="26aea5eaba4882a7f57e469fe581e38b779b7c63" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; flag is set, then the database connection opens in the multi-thread &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; as long as the single-thread mode has not been set at compile-time or start-time. If the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; flag is set then the database connection opens in the serialized &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; unless single-thread was previously selected at compile-time or start-time. The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; flag causes the database connection to be eligible to use &lt;a href=&quot;../sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, regardless of whether or not shared cache is enabled using &lt;a href=&quot;enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;. The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; flag causes the database connection to not participate in &lt;a href=&quot;../sharedcache&quot;&gt;shared cache mode&lt;/a&gt; even if it is enabled.</source>
          <target state="translated">&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;フラグが設定されている場合、シングルスレッドモードがコンパイル時または開始時に設定されていない限り、データベース接続はマルチスレッド&lt;a href=&quot;../threadsafe&quot;&gt;スレッドモード&lt;/a&gt;で開きます。&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;フラグが設定されている場合、コンパイル時または開始時にシングルスレッドが以前に選択されていなければ、データベース接続はシリアル&lt;a href=&quot;../threadsafe&quot;&gt;化&lt;/a&gt;されたスレッドモードで開きます。&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHEの&lt;/a&gt;フラグは、データベース接続を使用する資格させる&lt;a href=&quot;../sharedcache&quot;&gt;共有キャッシュモード&lt;/a&gt;かどうかにかかわらず、共有キャッシュの使用して有効になっている、&lt;a href=&quot;enable_shared_cache&quot;&gt;sqlite3_enable_shared_cacheを（） &lt;/a&gt;。&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;フラグを設定すると、データベース接続が有効になっていても、&lt;a href=&quot;../sharedcache&quot;&gt;共有キャッシュモードに&lt;/a&gt;参加しません。</target>
        </trans-unit>
        <trans-unit id="3d6b9e280cf3c9ed4800b321c18f34c5a4956d1e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES=1&lt;/a&gt; option is used, then SQLite is capable of using 8+3 filenames but that capabilities is disabled and must be enabled separately for each database connection by using using &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; when &lt;a href=&quot;c3ref/open&quot;&gt;opening&lt;/a&gt; or &lt;a href=&quot;lang_attach&quot;&gt;ATTACH-ing&lt;/a&gt; the database files and include the &quot;&lt;code&gt;8_3_names=1&lt;/code&gt;&quot; query parameter in the URI. If SQLite is compiled with &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES=2&lt;/a&gt; then 8+3 filenames are enabled by default and this step can be skipped.</source>
          <target state="translated">場合&lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES = 1つの&lt;/a&gt;オプションが使用され、その後、SQLiteは8 + 3ファイル名を使用することが可能となるが、その機能は無効になり、使用して使用して、各データベース接続ごとに個別に有効にする必要があり&lt;a href=&quot;uri&quot;&gt;URIファイル名の&lt;/a&gt;とき&lt;a href=&quot;c3ref/open&quot;&gt;開口部&lt;/a&gt;または&lt;a href=&quot;lang_attach&quot;&gt;-INGのATTACH&lt;/a&gt;データベースファイルをと含まURIの「 &lt;code&gt;8_3_names=1&lt;/code&gt; 」クエリパラメータ。SQLiteが&lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES = 2で&lt;/a&gt;コンパイルされている場合、デフォルトで8 + 3のファイル名が有効になり、この手順はスキップできます。</target>
        </trans-unit>
        <trans-unit id="f14f4e625a540ecf3e1de270c88730b0b55cfa0f" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter specifies disk storage for temporary files, then override that decision and use memory storage instead. Otherwise follow the recommendation of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter.</source>
          <target state="translated">&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;コンパイル時パラメーターが一時ファイル用のディスクストレージを指定している場合は、その決定を上書きして、代わりにメモリストレージを使用します。それ以外の場合は、&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;コンパイル時パラメーターの推奨に従います。</target>
        </trans-unit>
        <trans-unit id="cc4e5ad04a8f404976f4ea549e621889ed4a2406" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter specifies memory storage for temporary files, then override that decision and use disk storage instead. Otherwise follow the recommendation of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter.</source>
          <target state="translated">&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;コンパイル時パラメーターが一時ファイルのメモリストレージを指定している場合は、その決定を上書きして、代わりにディスクストレージを使用します。それ以外の場合は、&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;コンパイル時パラメーターの推奨に従います。</target>
        </trans-unit>
        <trans-unit id="c75f136169c511a3f8a8fd887440953a9ba6fdef" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt; of a column is REAL and that column contains a value that can be converted to an integer without loss of information (if the value contains no fractional part and is not too large to be represented as an integer) then the column may be stored in the record as an integer. SQLite will convert the value back to floating point when extracting it from the record.</source>
          <target state="translated">場合&lt;a href=&quot;datatype3#affinity&quot;&gt;アフィニティー&lt;/a&gt;カラムのがREALであり、（値は小数部分を含まず、整数として表すことが大きすぎない場合）、その列は、情報の損失なし整数に変換することができる値を含むその列であってもよいですレコードに整数として格納されます。SQLiteは、レコードから抽出するときに値を浮動小数点に変換します。</target>
        </trans-unit>
        <trans-unit id="6bdd9340a9dcd6ebb4b2136a687baf206a35c611" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; is not aliased by &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; then it is not persistent and might change. In particular the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command will change rowids for tables that do not declare an INTEGER PRIMARY KEY. Therefore, applications should not normally access the rowid directly, but instead use an INTEGER PRIMARY KEY.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;が&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;によってエイリアスされていない場合、永続的ではなく、変更される可能性があります。特に、&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;コマンドは、INTEGER PRIMARY KEYを宣言していないテーブルのROWIDを変更します。したがって、アプリケーションは通常、ROWIDに直接アクセスするのではなく、INTEGER PRIMARY KEYを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="96317212b202d64aa994eed839385d463798a08e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;opcode#VColumn&quot;&gt;VColumn&lt;/a&gt; opcode is being used to fetch the value of an unchanging column during an UPDATE operation, then the P5 value is OPFLAG_NOCHNG. This will cause the sqlite3_vtab_nochange() function to return true inside the xColumn method of the virtual table implementation. The P5 column might also contain other bits (OPFLAG_LENGTHARG or OPFLAG_TYPEOFARG) but those bits are unused by &lt;a href=&quot;opcode#VColumn&quot;&gt;VColumn&lt;/a&gt;.</source>
          <target state="translated">場合&lt;a href=&quot;opcode#VColumn&quot;&gt;VCOLUMNの&lt;/a&gt;オペコードは、更新処理中に不変のカラムの値を取得するために使用され、次いで、P5の値がOPFLAG_NOCHNGあります。これにより、sqlite3_vtab_nochange（）関数が仮想テーブル実装のxColumnメソッド内でtrueを返します。P5列には他のビット（OPFLAG_LENGTHARGまたはOPFLAG_TYPEOFARG）も含まれている可能性がありますが、それらのビットは&lt;a href=&quot;opcode#VColumn&quot;&gt;VColumnでは&lt;/a&gt;使用されません。</target>
        </trans-unit>
        <trans-unit id="2b4eaedd5855ff13b903e656d850adc325c12c79" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt; is used on a subquery in the FROM clause of a SELECT statement, that effectively merges the subquery into the outer query. The output of EXPLAIN QUERY PLAN reflects this, as in the following example:</source>
          <target state="translated">場合は&lt;a href=&quot;optoverview#flattening&quot;&gt;平坦化最適化が&lt;/a&gt;効果的に外側のクエリにサブクエリをマージし、SELECT文のFROM句でのサブクエリに使用されています。EXPLAIN QUERY PLANの出力は、次の例のようにこれを反映しています。</target>
        </trans-unit>
        <trans-unit id="6110f6d9f2445ffa2d331ca1dfcaf53aa3a365b6" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt; EMPTY_RESULT_CALLBACKS&lt;/a&gt; pragma is set to ON and the result of a query is an empty set, then the callback is invoked once with the third parameter (argv) set to 0. In other words</source>
          <target state="translated">場合&lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt;EMPTY_RESULT_CALLBACKSの&lt;/a&gt;プラグマがONに設定され、クエリの結果が空集合である場合、コールバックは、換言すれば0に三番目のパラメータ（ARGV）が設定された後に呼び出されます</target>
        </trans-unit>
        <trans-unit id="b1c24c8f45d6339d5389a76337c9e88f41b5e36a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;pragma#pragma_fullfsync&quot;&gt;fullfsync&lt;/a&gt; flag is set, then the F_FULLFSYNC syncing method is used for all sync operations and the checkpoint_fullfsync setting is irrelevant.</source>
          <target state="translated">場合&lt;a href=&quot;pragma#pragma_fullfsync&quot;&gt;fullfsync&lt;/a&gt;フラグがセットされ、次いでF_FULLFSYNC同期方法は、すべての同期動作のために使用され、checkpoint_fullfsync設定は無関係です。</target>
        </trans-unit>
        <trans-unit id="a73873febe6d7de1338d537c333841d126c81b5b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; pragma is ON, then the name of the result is the name of the source table column without the source table name prefix: COLUMN.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt;プラグマがONの場合、結果の名前はソーステーブル名の接頭辞を除いたソーステーブル列の名前です：COLUMN。</target>
        </trans-unit>
        <trans-unit id="1069754e926abbbcc7551f7b3c103d01ced65dbe" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method sets the sqlite3_file.pMethods element to a non-NULL pointer, then the sqlite3_io_methods.xClose method may be invoked even if the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; reported that it failed. The only way to prevent a call to xClose following a failed &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; is for the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; to set the sqlite3_file.pMethods element to NULL.</source>
          <target state="translated">場合&lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpenの&lt;/a&gt;方法は、非NULLポインタにsqlite3_file.pMethods要素を設定し、その後sqlite3_io_methods.xClose方法は、場合でも呼び出すことができる&lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpenは、&lt;/a&gt;それが失敗したことを報告しました。失敗し、次のxCloseへの呼び出しを防ぐ唯一の方法&lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpenは&lt;/a&gt;です&lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpenが&lt;/a&gt; NULLにsqlite3_file.pMethods要素を設定します。</target>
        </trans-unit>
        <trans-unit id="e03a0f37d058bb5a34bec7fac575235294acd0da" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method calls sqlite3_vtab_nochange() and finds that the column is not changed by the UPDATE statement, then the xColumn method can optionally return without setting a result, without calling any of the &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_xxxxx() interfaces&lt;/a&gt;. In that case, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_nochange(X)&lt;/a&gt; will return true for the same column in the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method.</source>
          <target state="translated">場合&lt;a href=&quot;vtab#xcolumn&quot;&gt;Xcolumnにする&lt;/a&gt;メソッド呼び出しは、列がUPDATE文によって変更されないことsqlite3_vtab_nochange（）と求め、次いでXcolumnに方法は、任意の任意呼び出すことなく、結果を設定せずに返すことができ&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_xxxxx（）インターフェースを&lt;/a&gt;。その場合、&lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_nochange（X）&lt;/a&gt;は、&lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;メソッドの同じ列に対してtrueを返します。</target>
        </trans-unit>
        <trans-unit id="6aba978070ccc979bd49ef28d0ef204e751d91d9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method in a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation returns an error message using &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_error()&lt;/a&gt; then give that error message preference over internally-generated messages.</source>
          <target state="translated">&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;実装の&lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;メソッドが&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_error（）&lt;/a&gt;を使用してエラーメッセージを返す場合、内部で生成されたメッセージよりもそのエラーメッセージを優先します。</target>
        </trans-unit>
        <trans-unit id="a18d90fb5154dfedaa1471558060511dc56cfb54" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method is NULL, then &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statements are prohibited for that virtual table, and the virtual table is an &quot;eponymous-only virtual table&quot;. Eponymous-only virtual tables are useful as &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;メソッドがNULLの場合、その仮想テーブルに対する&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;ステートメントは禁止され、仮想テーブルは「匿名のみの仮想テーブル」になります。代名詞のみの仮想テーブルは、&lt;a href=&quot;vtab#tabfunc2&quot;&gt;テーブル値関数&lt;/a&gt;として役立ちます。</target>
        </trans-unit>
        <trans-unit id="e36f28038a4ddd30d8f77a7f397ce33837d3478d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction()&lt;/a&gt; method for the virtual table is defined, and if xFindFunction() sometimes returns &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; or larger, then the constraints might also be of the form:</source>
          <target state="translated">仮想テーブルの&lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction（）&lt;/a&gt;メソッドが定義されており、xFindFunction（）が&lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt;以上を返すことがある場合、制約も次の形式になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="89b6cc463721d8831624d29f70a88929969774cd" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; is enabled (via the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt;), this pragma causes a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operation to run on database</source>
          <target state="translated">場合は&lt;a href=&quot;wal&quot;&gt;、先行書き込みログ&lt;/a&gt;（経由で有効になっている&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_modeプラグマ&lt;/a&gt;）、このプラグマは、原因となる&lt;a href=&quot;wal#ckpt&quot;&gt;チェックポイントの&lt;/a&gt;データベース上で実行する操作を</target>
        </trans-unit>
        <trans-unit id="fa30bb229e0ba6c16b036d0680166f4c0e969175" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;header&lt;/b&gt; argument is true then the first row of the CSV file to be treated as a header rather than as data. The second line of the CSV file becomes the first row of content. If the &lt;b&gt;schema=&lt;/b&gt; options is omitted, then the first line of the CSV file determines the names of the columns.</source>
          <target state="translated">&lt;b&gt;header&lt;/b&gt;引数がtrueの場合、CSVファイルの最初の行はデータではなくヘッダーとして扱われます。CSVファイルの2行目がコンテンツの最初の行になります。&lt;b&gt;schema =&lt;/b&gt;オプションを省略した場合、CSVファイルの最初の行で列の名前が決まります。</target>
        </trans-unit>
        <trans-unit id="c1cfb6451556f25af13b7b368489aadb6eb20ce2" translate="yes" xml:space="preserve">
          <source>If the AUTOINCREMENT keyword appears after INTEGER PRIMARY KEY, that changes the automatic ROWID assignment algorithm to prevent the reuse of ROWIDs over the lifetime of the database. In other words, the purpose of AUTOINCREMENT is to prevent the reuse of ROWIDs from previously deleted rows.</source>
          <target state="translated">INTEGER PRIMARY KEY の後に AUTOINCREMENT キーワードが出現した場合、データベースの有効期間中に ROWID が再利用されるのを防ぐために、自動 ROWID 代入アルゴリズムが変更されます。言い換えれば、AUTOINCREMENTの目的は、以前に削除された行からのROWIDの再利用を防ぐことです。</target>
        </trans-unit>
        <trans-unit id="e7ae8b25bf55713a14aa930c0d079c55585a0c82" translate="yes" xml:space="preserve">
          <source>If the C version of the &lt;a href=&quot;http://site.icu-project.org/&quot;&gt;ICU library&lt;/a&gt; is available, then FTS may also be compiled with the SQLITE_ENABLE_ICU pre-processor macro defined. Compiling with this macro enables an FTS &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt; that uses the ICU library to split a document into terms (words) using the conventions for a specified language and locale.</source>
          <target state="translated">&lt;a href=&quot;http://site.icu-project.org/&quot;&gt;ICUライブラリ&lt;/a&gt;のCバージョンが利用可能な場合、FTSはSQLITE_ENABLE_ICUプリプロセッサマクロを定義してコンパイルすることもできます。このマクロを使用してコンパイルすると、ICUライブラリを使用するFTS &lt;a href=&quot;fts3#tokenizer&quot;&gt;トークナイザー&lt;/a&gt;が、指定された言語とロケールの規則を使用してドキュメントを用語（単語）に分割できるようになります。</target>
        </trans-unit>
        <trans-unit id="aade338ead72cd83806851289f36afe9ffee6390" translate="yes" xml:space="preserve">
          <source>If the DELETE operation is attempted, but SQLite returns SQLITE_CONSTRAINT (which can only happen if a foreign key constraint is violated), the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; passed as the second argument. This includes the case where the DELETE operation is attempted because an earlier call to the conflict handler function returned &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">DELETE操作が試行されたが、SQLiteがSQLITE_CONSTRAINTを返す場合（これは、外部キー制約に違反している場合にのみ発生します）、2番目の引数として&lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt;が渡されて競合ハンドラー関数が呼び出されます。これには、競合ハンドラー関数への以前の呼び出しが&lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACEを&lt;/a&gt;返したためにDELETE操作が試行された場合が含まれます。</target>
        </trans-unit>
        <trans-unit id="c4726b3dbe2c58403328aff3054192714f5fc075" translate="yes" xml:space="preserve">
          <source>If the DELETE operation is attempted, but SQLite returns SQLITE_CONSTRAINT (which can only happen if a foreign key constraint is violated), the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; passed as the second argument. This includes the case where the DELETE operation is attempted because an earlier call to the conflict handler function returned &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">DELETE操作が試行されたが、SQLiteがSQLITE_CONSTRAINTを返す場合（これは、外部キー制約に違反している場合にのみ発生します）、2番目の引数として&lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt;が渡されて競合ハンドラー関数が呼び出されます。これには、競合ハンドラー関数への以前の呼び出しが&lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACEを&lt;/a&gt;返したためにDELETE操作が試行された場合が含まれます。</target>
        </trans-unit>
        <trans-unit id="a02c654b3d70302948f2081631be3edc27671a93" translate="yes" xml:space="preserve">
          <source>If the DELETE statement has an ORDER BY clause, then all rows that would be deleted in the absence of the LIMIT clause are sorted according to the ORDER BY. The first</source>
          <target state="translated">DELETE文にORDER BY句がある場合、LIMIT句がない場合に削除されるすべての行はORDER BYに従ってソートされます。最初の</target>
        </trans-unit>
        <trans-unit id="63547bac31e35c719e75fc46ff0cebecf92fd269" translate="yes" xml:space="preserve">
          <source>If the DELETE statement has no ORDER BY clause, then all rows that would be deleted in the absence of the LIMIT clause are assembled in an arbitrary order before applying the LIMIT and OFFSET clauses to determine the subset that are actually deleted.</source>
          <target state="translated">DELETE文にORDER BY句がない場合、LIMIT句がない場合に削除されるすべての行は、LIMIT句とOFFSET句を適用して実際に削除されるサブセットを決定する前に、任意の順序で組み立てられます。</target>
        </trans-unit>
        <trans-unit id="20e8eb12f584aa2a2c71da9ffe10b6bc6f97692b" translate="yes" xml:space="preserve">
          <source>If the ESCAPE option is used, the ESCAPE character must be ASCII, or a single-byte character in UTF-8.</source>
          <target state="translated">ESCAPE オプションを使用する場合、ESCAPE 文字は ASCII または UTF-8 のシングルバイト文字でなければなりません。</target>
        </trans-unit>
        <trans-unit id="d5df7edc7165f75cb1f0d5e995a539c8d7c8967f" translate="yes" xml:space="preserve">
          <source>If the F parameter is not one of the above, then the behavior is undefined and probably undesirable. Older versions of SQLite were more tolerant of invalid F parameters than newer versions.</source>
          <target state="translated">F パラメータが上記のいずれかでない場合、動作は未定義であり、おそらく望ましくありません。古いバージョンの SQLite は、新しいバージョンよりも無効な F パラメータに対して寛容でした。</target>
        </trans-unit>
        <trans-unit id="7f76a2496ff32a61cee2f76ed3e0830800bfd787" translate="yes" xml:space="preserve">
          <source>If the FROM clause is omitted from a simple SELECT statement, then the input data is implicitly a single row zero columns wide (i.e.</source>
          <target state="translated">単純なSELECT文からFROM句が省略された場合、入力データは暗黙のうちに0列幅の1行になります。</target>
        </trans-unit>
        <trans-unit id="408ec930c8db59ef8bcaccad18026b5e15f9eaec" translate="yes" xml:space="preserve">
          <source>If the FTS table is an FTS4 table (not FTS3), a token may also be prefixed with a &quot;^&quot; character. In this case, in order to match the token must appear as the very first token in any column of the matching row. Examples:</source>
          <target state="translated">FTSテーブルがFTS4テーブル(FTS3ではない)の場合、トークンの前に&quot;^&quot;文字を付けることもできます。この場合、トークンが一致するためには、一致する行のいずれかの列の最初のトークンとして表示されなければなりません。例。</target>
        </trans-unit>
        <trans-unit id="93fd7e443f86d05e9fc567cfba4cc2ea3b224813" translate="yes" xml:space="preserve">
          <source>If the FTS5 table is created with the 'detail' option set to 'col', then the</source>
          <target state="translated">FTS5 テーブルが 'detail' オプションを 'col' に設定して作成されている場合は</target>
        </trans-unit>
        <trans-unit id="99ee296e09aab46dd06e0a5f1c140a90b72606e3" translate="yes" xml:space="preserve">
          <source>If the HAVE_FDATASYNC compile-time option is true, then the default &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; for unix systems will attempt to use fdatasync() instead of fsync() where appropriate. If this flag is missing or false, then fsync() is always used.</source>
          <target state="translated">HAVE_FDATASYNCコンパイル時オプションがtrueの場合、UNIXシステムのデフォルトの&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;は、必要に応じてfsync （）ではなくfdatasync（）を使用しようとします。このフラグがないかfalseの場合、fsync（）が常に使用されます。</target>
        </trans-unit>
        <trans-unit id="8e31d6de70624cd3258a7c666db7d8624e2234e9" translate="yes" xml:space="preserve">
          <source>If the HAVE_GMTIME_R option is true and if &lt;a href=&quot;compile#omit_datetime_funcs&quot;&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/a&gt; is true, then the CURRENT_TIME, CURRENT_DATE, and CURRENT_TIMESTAMP keywords will use the threadsafe &quot;gmtime_r()&quot; interface rather than &quot;gmtime()&quot;. In the usual case where &lt;a href=&quot;compile#omit_datetime_funcs&quot;&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/a&gt; is not defined or is false, then the built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; are used to implement the CURRENT_TIME, CURRENT_DATE, and CURRENT_TIMESTAMP keywords and neither gmtime_r() nor gmtime() is ever called.</source>
          <target state="translated">HAVE_GMTIME_Rオプションがtrueで、&lt;a href=&quot;compile#omit_datetime_funcs&quot;&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/a&gt;がtrueの場合、CURRENT_TIME、CURRENT_DATE、およびCURRENT_TIMESTAMPキーワードは、「gmtime（）」ではなくスレッドセーフな「gmtime_r（）」インターフェースを使用します。&lt;a href=&quot;compile#omit_datetime_funcs&quot;&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/a&gt;が定義されていないかfalseである通常の場合、組み込みの&lt;a href=&quot;lang_datefunc&quot;&gt;日付と時刻の関数&lt;/a&gt;を使用して、CURRENT_TIME、CURRENT_DATE、およびCURRENT_TIMESTAMPキーワードが実装され、gmtime_r（）もgmtime（）も呼び出されません。</target>
        </trans-unit>
        <trans-unit id="40cdcf3ade2687218b791686ca4436d6b3c5cfba" translate="yes" xml:space="preserve">
          <source>If the HAVE_ISNAN option is true, then SQLite invokes the system library isnan() function to determine if a double-precision floating point value is a NaN. If HAVE_ISNAN is undefined or false, then SQLite substitutes its own home-grown implementation of isnan().</source>
          <target state="translated">HAVE_ISNAN オプションが true の場合、SQLite はシステム・ライブラリの isnan()関数を呼び出し、倍精度浮動小数点値が NaN であるかどうかを判断します。HAVE_ISNAN が未定義または false の場合、SQLite は isnan()の独自の実装を代用します。</target>
        </trans-unit>
        <trans-unit id="153cb2536cd91084b29b41e9d14f8a7ef310cc61" translate="yes" xml:space="preserve">
          <source>If the HAVE_LOCALTIME_R option is true, then SQLite uses the threadsafe localtime_r() library routine instead of localtime() to help implement the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime modifier&lt;/a&gt; to the built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt;.</source>
          <target state="translated">HAVE_LOCALTIME_Rオプションがtrueの場合、SQLiteはlocaltime（）ではなくスレッドセーフのlocaltime_r（）ライブラリルーチンを使用して、組み込みの&lt;a href=&quot;lang_datefunc&quot;&gt;日付および時刻関数に&lt;/a&gt;&lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime修飾子&lt;/a&gt;を実装します。</target>
        </trans-unit>
        <trans-unit id="0c4b14956847344de7b5a6ccb25e5f358e368735" translate="yes" xml:space="preserve">
          <source>If the HAVE_LOCALTIME_S option is true, then SQLite uses the threadsafe localtime_s() library routine instead of localtime() to help implement the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime modifier&lt;/a&gt; to the built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt;.</source>
          <target state="translated">HAVE_LOCALTIME_Sオプションがtrueの場合、SQLiteはlocaltime（）ではなくスレッドセーフのlocaltime_s（）ライブラリルーチンを使用して、組み込みの&lt;a href=&quot;lang_datefunc&quot;&gt;日付および時刻関数に&lt;/a&gt;&lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime修飾子&lt;/a&gt;を実装します。</target>
        </trans-unit>
        <trans-unit id="997bea68ec053527286253926a4446e11225f13c" translate="yes" xml:space="preserve">
          <source>If the HAVE_MALLOC_USABLE_SIZE option is omitted or is false, then SQLite uses a wrapper around system malloc() and realloc() that enlarges each allocation by 8 bytes and writes the size of the allocation in the initial 8 bytes, and then SQLite also implements its own home-grown version of malloc_usable_size() that consults that 8-byte prefix to find the allocation size. This approach works but it is suboptimal. Applications are encouraged to use HAVE_MALLOC_USABLE_SIZE whenever possible.</source>
          <target state="translated">HAVE_MALLOC_USABLE_SIZE オプションが省略されているか false の場合、SQLite はシステムの malloc()および realloc()のラッパーを使用して各アロケーションを 8 バイトずつ拡大し、最初の 8 バイトにアロケーションのサイズを書き込みます。このアプローチはうまくいきますが、最適ではありません。アプリケーションは可能な限り HAVE_MALLOC_USABLE_SIZE を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="55308f0ca78c87c49d7100dbf1e1e1adc1d30409" translate="yes" xml:space="preserve">
          <source>If the HAVE_MALLOC_USABLE_SIZE option is true, then SQLite tries uses the malloc_usable_size() interface to find the size of a memory allocation obtained from the standard-library malloc() or realloc() routines. This option is only applicable if the standard-library malloc() is used. On Apple systems, &quot;zone malloc&quot; is used instead, and so this option is not applicable. And, of course, if the application supplies its own malloc implementation using &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; then this option has no effect.</source>
          <target state="translated">HAVE_MALLOC_USABLE_SIZEオプションがtrueの場合、SQLiteはmalloc_usable_size（）インターフェースを使用して、標準ライブラリのmalloc（）またはrealloc（）ルーチンから取得したメモリ割り当てのサイズを見つけようとします。このオプションは、標準ライブラリのmalloc（）が使用されている場合にのみ適用されます。Appleシステムでは、代わりに「zone malloc」が使用されるため、このオプションは適用されません。そしてもちろん、アプリケーションが&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;を使用して独自のmalloc実装を提供する場合、このオプションは効果がありません。</target>
        </trans-unit>
        <trans-unit id="3344d140659472562fd4dea21990938229ddf3ec" translate="yes" xml:space="preserve">
          <source>If the HAVE_STRCHRNUL option is true, then SQLite uses the strchrnul() library function. If this option is missing or false, then SQLite substitutes its own home-grown implementation of strchrnul().</source>
          <target state="translated">HAVE_STRCHRNUL オプションが true の場合、SQLite は strchrnul()ライブラリ関数を使用します。このオプションがない場合や false の場合は、SQLite は strchrnul()の独自の実装を代用します。</target>
        </trans-unit>
        <trans-unit id="08d8894136dfc0e284f285c182990a928235abdc" translate="yes" xml:space="preserve">
          <source>If the HAVE_USLEEP option is true, then the default unix VFS uses the usleep() system call to implement the xSleep method. If this option is undefined or false, then xSleep on unix is implemented using sleep() which means that &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep()&lt;/a&gt; will have a minimum wait interval of 1000 milliseconds regardless of its argument.</source>
          <target state="translated">HAVE_USLEEPオプションがtrueの場合、デフォルトのUNIX VFSはusleep（）システムコールを使用してxSleepメソッドを実装します。このオプションが未定義またはfalseの場合、UNIXでのxSleepは、sleep（）を使用して実装されます。つまり、&lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep（）の&lt;/a&gt;引数に関係なく、1000ミリ秒の最小待機間隔があります。</target>
        </trans-unit>
        <trans-unit id="538ccd48ed8bd61407504bbf28bbe6d0ffe8bf96" translate="yes" xml:space="preserve">
          <source>If the HAVE_UTIME option is true, then the built-in but non-standard &quot;unix-dotfile&quot; VFS will use the utime() system call, instead of utimes(), to set the last access time on the lock file.</source>
          <target state="translated">HAVE_UTIME オプションが真の場合、組み込みではあるが非標準の &quot;unix-dotfile&quot; VFS は utimes()の代わりに utime()システムコールを使用して、ロックファイルの最後のアクセス時間を設定します。</target>
        </trans-unit>
        <trans-unit id="7cab5093752cc9a8b0a63442b0923931057ad2d6" translate="yes" xml:space="preserve">
          <source>If the INTO clause is included, then the original database file is unchanged and a new database is created in the filename given by the argument to the INTO clause. The new database will contain the same logical content as the original database, fully vacuumed.</source>
          <target state="translated">INTO句が含まれている場合、元のデータベースファイルは変更されず、INTO句の引数で指定されたファイル名に新しいデータベースが作成されます。新しいデータベースは、完全にバキュームされた元のデータベースと同じ論理的な内容を含みます。</target>
        </trans-unit>
        <trans-unit id="b0e0bffd82940bcd9134c72373f0af179d9c5474" translate="yes" xml:space="preserve">
          <source>If the LIMIT expression evaluates to non-negative value</source>
          <target state="translated">LIMIT式が非負の値として評価された場合</target>
        </trans-unit>
        <trans-unit id="f61e07bad4e222ccefd74ac63dc52c1ed3c63a8f" translate="yes" xml:space="preserve">
          <source>If the NATURAL keyword is in the join-operator then an implicit USING clause is added to the join-constraints. The implicit USING clause contains each of the column names that appear in both the left and right-hand input datasets. If the left and right-hand input datasets feature no common column names, then the NATURAL keyword has no effect on the results of the join. A USING or ON clause may not be added to a join that specifies the NATURAL keyword.</source>
          <target state="translated">join-operatorにNATURALキーワードがある場合、暗黙のUSING句がjoin-constraintsに追加されます。暗黙のUSING句は、左手と右手の入力データセットに現れる列名をそれぞれ含みます。左手と右手の入力データセットに共通の列名がない場合、NATURALキーワードは結合結果に影響しません。NATURALキーワードを指定した結合には、USING句やON句を追加してはいけません。</target>
        </trans-unit>
        <trans-unit id="a2b9577c2b86e52c07b264eb7017d085b143b677" translate="yes" xml:space="preserve">
          <source>If the Nth column returned by the statement is an expression or subquery and is not a column value, then all of these functions return NULL. These routine might also return NULL if a memory allocation error occurs. Otherwise, they return the name of the attached database, table, or column that query result column was extracted from.</source>
          <target state="translated">ステートメントによって返されたN番目の列が式または副問い合わせであり、列の値ではない場合、これらの関数はすべてNULLを返します。また、これらのルーチンは、メモリ割り当てエラーが発生した場合にもNULLを返す場合があります。それ以外の場合は、クエリ結果カラムが抽出されたアタッチされたデータベース、テーブル、またはカラムの名前を返します。</target>
        </trans-unit>
        <trans-unit id="7286275584ec903ae36c4fc51d813a102d9d7ca1" translate="yes" xml:space="preserve">
          <source>If the Nth column returned by the statement is an expression or subquery and is not a column value, then all of these functions return NULL. These routines might also return NULL if a memory allocation error occurs. Otherwise, they return the name of the attached database, table, or column that query result column was extracted from.</source>
          <target state="translated">ステートメントが返すN番目の列が式または副問い合わせであり、列の値ではない場合、これらの関数はすべてNULLを返します。これらのルーチンは、メモリ割り当てエラーが発生した場合にもNULLを返す場合があります。それ以外の場合は、クエリ結果のカラムが抽出されたアタッチされたデータベース、テーブル、またはカラムの名前を返します。</target>
        </trans-unit>
        <trans-unit id="f987b1e749686c5439c4369e9509e69172835e8f" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_AUXDELETE bit is set on P5, that indicates that this delete one of several associated with deleting a table row and all its associated index entries. Exactly one of those deletes is the &quot;primary&quot; delete. The others are all on OPFLAG_FORDELETE cursors or else are marked with the AUXDELETE flag.</source>
          <target state="translated">P5 で OPFLAG_AUXDELETE ビットが設定されている場合、この削除は、テーブル行とそれに関連付けられたすべてのインデックス項目の削除に関連する複数の削除のうちの 1 つであることを示しています。これらの削除のうちの1つは、まさに &quot;プライマリ &quot;削除です。他の削除はすべて OPFLAG_FORDELETE カーソル上にあるか、AUXDELETE フラグでマークされています。</target>
        </trans-unit>
        <trans-unit id="2e0584b25ae53697595c710240b674cfcd931b66" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_ISUPDATE flag is set in P2, then P3 contains the address of the memory cell that contains the value that the rowid of the row will be set to by the update.</source>
          <target state="translated">P2にOPFLAG_ISUPDATEフラグがセットされている場合、P3には、その行のROWIDが更新によって設定される値を含むメモリセルのアドレスが格納される。</target>
        </trans-unit>
        <trans-unit id="85453347b772792d0ef83ca6247504c978601416" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_ISUPDATE flag is set, then this opcode is part of an UPDATE operation. Otherwise (if the flag is clear) then this opcode is part of an INSERT operation. The difference is only important to the update hook.</source>
          <target state="translated">OPFLAG_ISUPDATEフラグがセットされている場合、このオペコードはUPDATE操作の一部である。そうでない場合(フラグがクリアされている場合)、このオペコードは INSERT 操作の一部となります。この違いは、UPDATEフックにとってのみ重要です。</target>
        </trans-unit>
        <trans-unit id="358930ea0c0cb3bf8ddbac06391138cf9e1e9b1f" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_LENGTHARG and OPFLAG_TYPEOFARG bits are set on P5 then the result is guaranteed to only be used as the argument of a length() or typeof() function, respectively. The loading of large blobs can be skipped for length() and all content loading can be skipped for typeof().</source>
          <target state="translated">P5 で OPFLAG_LENGTHARG および OPFLAG_TYPEOFARG ビッ トが設定されている場合、その結果はそれぞれ length()または typeof()関数の引数としてのみ使用されることが保証されます。length()では大きなブロブの読み込みを省略でき、typeof()ではすべての内容の読み込みを省略できます。</target>
        </trans-unit>
        <trans-unit id="b673a87eca1e30fb0e05ce7b3a0e2e621baf2f1c" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_NCHANGE flag of P2 (NB: P2 not P5) is set, then the row change count is incremented (otherwise not).</source>
          <target state="translated">P2(NB:P5ではなくP2)のOPFLAG_NCHANGEフラグがセットされている場合は、行の変更回数がインクリメントされます(そうでない場合はインクリメントされません)。</target>
        </trans-unit>
        <trans-unit id="8006bf0580f0ceee7abfbb502ff0bc2738a32586" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_NCHANGE flag of P5 is set, then the row change count is incremented (otherwise not). If the OPFLAG_LASTROWID flag of P5 is set, then rowid is stored for subsequent return by the sqlite3_last_insert_rowid() function (otherwise it is unmodified).</source>
          <target state="translated">P5のOPFLAG_NCHANGEフラグがセットされている場合、行の変更回数がインクリメントされます(そうでない場合はインクリメントされません)。P5のOPFLAG_LASTROWIDフラグがセットされている場合、行IDはsqlite3_last_insert_rowid()関数によって返されるために保存されます(それ以外の場合は変更されません)。</target>
        </trans-unit>
        <trans-unit id="0464f564c819708fc95ba0ca873e884f00c0c5ec" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_SAVEPOSITION bit of the P5 parameter is set, then the cursor will be left pointing at either the next or the previous record in the table. If it is left pointing at the next record, then the next &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; instruction will be a no-op. As a result, in this case it is ok to delete a record from within a &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; loop. If OPFLAG_SAVEPOSITION bit of P5 is clear, then the cursor will be left in an undefined state.</source>
          <target state="translated">P5パラメータのOPFLAG_SAVEPOSITIONビットが設定されている場合、カーソルはテーブル内の次のレコードまたは前のレコードのいずれかに置かれたままになります。次のレコードをポイントしたままにすると、次の&lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt;命令はノーオペレーションになります。その結果、この場合、&lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt;ループ内からレコードを削除しても問題ありません。P5のOPFLAG_SAVEPOSITIONビットがクリアされている場合、カーソルは未定義の状態のままになります。</target>
        </trans-unit>
        <trans-unit id="b8443bd622375a798ed2a10b2bb936621afb5e73" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_USESEEKRESULT flag of P5 is set, the implementation might run faster by avoiding an unnecessary seek on cursor P1. However, the OPFLAG_USESEEKRESULT flag must only be set if there have been no prior seeks on the cursor or if the most recent seek used a key equal to P3.</source>
          <target state="translated">P5のOPFLAG_USESEEKRESULTフラグがセットされている場合、カーソルP1への不要なシークを回避することで、実装はより速く実行されるかもしれない。しかし、OPFLAG_USESEEKRESULTフラグは、カーソル上に前のシークがない場合、または最新のシークがP3と等しいキーを使用している場合にのみ設定されなければならない。</target>
        </trans-unit>
        <trans-unit id="24d1994d6156f999d1ee517ed391edb59d48c618" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_USESEEKRESULT flag of P5 is set, the implementation might run faster by avoiding an unnecessary seek on cursor P1. However, the OPFLAG_USESEEKRESULT flag must only be set if there have been no prior seeks on the cursor or if the most recent seek used a key equivalent to P2.</source>
          <target state="translated">P5のOPFLAG_USESEEKRESULTフラグがセットされている場合、カーソルP1への不要なシークを回避することで、実装はより速く実行されるかもしれない。しかし、OPFLAG_USESEEKRESULTフラグは、カーソル上に先行シークがない場合、または直近のシークがP2と同等のキーを使用している場合にのみ設定されなければならない。</target>
        </trans-unit>
        <trans-unit id="1f2be7bea7738f3621eca4267ce81f09d41a2e23" translate="yes" xml:space="preserve">
          <source>If the ORDER BY expression is a constant integer K then the expression is considered an alias for the K-th column of the result set (columns are numbered from left to right starting with 1).</source>
          <target state="translated">ORDER BY式が定数整数Kの場合、式は結果集合のK番目の列のエイリアスとみなされます(列は左から1で始まる番号が付けられます)。</target>
        </trans-unit>
        <trans-unit id="54b7818868eb0e39bd8ddbed56195f5499a4600b" translate="yes" xml:space="preserve">
          <source>If the ORDER BY expression is an identifier that corresponds to the alias of one of the output columns, then the expression is considered an alias for that column.</source>
          <target state="translated">ORDER BY式が出力列の1つのエイリアスに対応する識別子である場合、その式はその列のエイリアスとみなされます。</target>
        </trans-unit>
        <trans-unit id="00fdbe0ee21cda19b4a8ae7897474539b1f0a75c" translate="yes" xml:space="preserve">
          <source>If the ORDER BY expression is assigned a collation sequence using the postfix &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, then the specified collation sequence is used.</source>
          <target state="translated">ORDER BY式に、後&lt;a href=&quot;lang_expr#collateop&quot;&gt;置COLLATE演算子&lt;/a&gt;を使用して照合シーケンスが割り当てられている場合、指定された照合シーケンスが使用されます。</target>
        </trans-unit>
        <trans-unit id="d77a3e5eca6240aa4cf73a2d563a4460d778268d" translate="yes" xml:space="preserve">
          <source>If the P1 cursor must be pointing to a valid row (not a NULL row) of a real table, not a pseudo-table.</source>
          <target state="translated">P1カーソルが擬似テーブルではなく、実テーブルの有効な行(NULL行ではない)を指していなければなりません。</target>
        </trans-unit>
        <trans-unit id="1f5366d1e68bed932cc9eadcf38bc5c4aed05e24" translate="yes" xml:space="preserve">
          <source>If the P1 index entry is greater than or equal to the key value then jump to P2. Otherwise fall through to the next instruction.</source>
          <target state="translated">P1 インデックスエントリがキー値以上の場合は、P2 にジャンプします。それ以外の場合は、次の命令にフォールスルーします。</target>
        </trans-unit>
        <trans-unit id="eb12e9cd16de01f1875169ba7dbce89a734843ad" translate="yes" xml:space="preserve">
          <source>If the P1 index entry is greater than the key value then jump to P2. Otherwise fall through to the next instruction.</source>
          <target state="translated">P1 インデックスエントリがキー値より大きい場合は、P2 にジャンプします。それ以外の場合は、次の命令にフォールスルーします。</target>
        </trans-unit>
        <trans-unit id="dbe830f25814f54ccec56a9eb14db5b310130922" translate="yes" xml:space="preserve">
          <source>If the P1 index entry is less than or equal to the key value then jump to P2. Otherwise fall through to the next instruction.</source>
          <target state="translated">P1 インデックスエントリがキー値以下の場合は、P2 にジャンプします。それ以外の場合は、次の命令にフォールスルーします。</target>
        </trans-unit>
        <trans-unit id="a25915e27b156d98cb891f738fe575b0c439ae6a" translate="yes" xml:space="preserve">
          <source>If the P1 index entry is less than the key value then jump to P2. Otherwise fall through to the next instruction.</source>
          <target state="translated">P1 インデックスエントリがキー値より小さい場合は、P2 にジャンプします。それ以外の場合は、次の命令にフォールスルーします。</target>
        </trans-unit>
        <trans-unit id="64d6010c68c3d803b2d20f7d66e38f73be2fb061" translate="yes" xml:space="preserve">
          <source>If the P1 value is non-zero, then also set the MEM_Cleared flag so that NULL values will not compare equal even if SQLITE_NULLEQ is set on &lt;a href=&quot;opcode#Ne&quot;&gt;Ne&lt;/a&gt; or &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt;.</source>
          <target state="translated">P1値がゼロ以外の場合は、MEM_Clearedフラグも設定して、SQLITE_NULLEQが&lt;a href=&quot;opcode#Ne&quot;&gt;Ne&lt;/a&gt;または&lt;a href=&quot;opcode#Eq&quot;&gt;Eqに&lt;/a&gt;設定されている場合でも、NULL値が等しくならないようにします。</target>
        </trans-unit>
        <trans-unit id="f14a9a47b078e93cd304b6691cdab49407396c8d" translate="yes" xml:space="preserve">
          <source>If the P3 value is non-zero, then the table referred to must be an intkey table (an SQL table, not an index). In this case the row change count is incremented by the number of rows in the table being cleared. If P3 is greater than zero, then the value stored in register P3 is also incremented by the number of rows in the table being cleared.</source>
          <target state="translated">P3 の値が 0 以外の場合、参照するテーブルは intkey テーブル (インデックスではなく SQL テーブル)でなければなりません。この場合、行の変更カウントは、クリアされるテーブルの行数だけインクリメントされます。P3が0より大きい場合、レジスタP3に格納されている値も、クリアされるテーブルの行数だけインクリメントされます。</target>
        </trans-unit>
        <trans-unit id="5877a66b1cea7b0ea64daa7c24ed48ab6bbcee07" translate="yes" xml:space="preserve">
          <source>If the PRIMARY KEY of a WITHOUT ROWID tables uses the same columns with the same collating sequence more than once, then the second and subsequent occurrences of that column in the PRIMARY KEY definition are ignored. For example, the following CREATE TABLE statements all specify the same table, which will have the exact same representation on disk:</source>
          <target state="translated">WITHOUT ROWIDテーブルのPRIMARY KEYが同じ照合順序の同じ列を複数回使用している場合、PRIMARY KEY定義内のその列の2回目以降の出現は無視されます。例えば、以下のCREATE TABLE文は全て同じテーブルを指定しており、ディスク上では全く同じ表現になります。</target>
        </trans-unit>
        <trans-unit id="d8742c4d987b7b8bb8b01f7cdaee658b0bce0f67" translate="yes" xml:space="preserve">
          <source>If the REINDEX keyword is followed by a collation-sequence name, then all indices in all attached databases that use the named collation sequences are recreated.</source>
          <target state="translated">REINDEX キーワードの後に照合順序名を付けると、名前付き照合順序を使用するすべてのアタッチされたデータベースのすべてのインデックスが再作成されます。</target>
        </trans-unit>
        <trans-unit id="89611a3566f7e2d206b997930c668d8b59f61d02" translate="yes" xml:space="preserve">
          <source>If the REINDEX keyword is not followed by a collation-sequence or database object identifier, then all indices in all attached databases are rebuilt.</source>
          <target state="translated">REINDEX キーワードの後に照合順序またはデータベース・オブジェクト識別子が続いていない場合、すべてのアタッチされたデータベースのすべてのインデックスが再構築されます。</target>
        </trans-unit>
        <trans-unit id="95360c5e4a315542249137c79e8a2d6b511f7fdc" translate="yes" xml:space="preserve">
          <source>If the SELECT statement is &lt;b&gt;a non-aggregate query&lt;/b&gt;, then each expression in the result expression list is evaluated for each row in the dataset filtered by the WHERE clause.</source>
          <target state="translated">SELECTステートメントが&lt;b&gt;非集計クエリの&lt;/b&gt;場合、結果式リストの各式は、WHERE句でフィルタリングされたデータセットの各行に対して評価されます。</target>
        </trans-unit>
        <trans-unit id="869026a04188f9191fbf03ed77ea46ac1ecc8cb4" translate="yes" xml:space="preserve">
          <source>If the SELECT statement is &lt;b&gt;an aggregate query with a GROUP BY&lt;/b&gt; clause, then each of the expressions specified as part of the GROUP BY clause is evaluated for each row of the dataset. Each row is then assigned to a &quot;group&quot; based on the results; rows for which the results of evaluating the GROUP BY expressions are the same get assigned to the same group. For the purposes of grouping rows, NULL values are considered equal. The usual rules for &lt;a href=&quot;datatype3#collation&quot;&gt;selecting a collation sequence&lt;/a&gt; with which to compare text values apply when evaluating expressions in a GROUP BY clause. The expressions in the GROUP BY clause do &lt;em&gt;not&lt;/em&gt; have to be expressions that appear in the result. The expressions in a GROUP BY clause may not be aggregate expressions.</source>
          <target state="translated">SELECTステートメントが&lt;b&gt;GROUP BY&lt;/b&gt;句&lt;b&gt;を含む集計クエリの&lt;/b&gt;場合、&lt;b&gt;GROUP BY&lt;/b&gt;句の一部として指定された各式は、データセットの各行に対して評価されます。各行は、結果に基づいて「グループ」に割り当てられます。 GROUP BY式の評価結果が同じである行は、同じグループに割り当てられます。行をグループ化するために、NULL値は等しいと見なされます。テキスト値を比較&lt;a href=&quot;datatype3#collation&quot;&gt;する照合シーケンス&lt;/a&gt;を選択するための通常のルールは、GROUP BY句の式を評価するときに適用されます。 GROUP BY句の式は、結果に表示される式である必要&lt;em&gt;は&lt;/em&gt;ありませ&lt;em&gt;ん&lt;/em&gt;。 GROUP BY句の式は、集約式ではない場合があります。</target>
        </trans-unit>
        <trans-unit id="5f32b910ff370c514af729f0255dcd885c666376" translate="yes" xml:space="preserve">
          <source>If the SELECT statement is &lt;b&gt;an aggregate query without a GROUP BY&lt;/b&gt; clause, then each aggregate expression in the result-set is evaluated once across the entire dataset. Each non-aggregate expression in the result-set is evaluated once for an arbitrarily selected row of the dataset. The same arbitrarily selected row is used for each non-aggregate expression. Or, if the dataset contains zero rows, then each non-aggregate expression is evaluated against a row consisting entirely of NULL values.</source>
          <target state="translated">SELECTステートメントが&lt;b&gt;GROUP BY&lt;/b&gt;句の&lt;b&gt;ない集計クエリ&lt;/b&gt;で&lt;b&gt;ある&lt;/b&gt;場合、結果セットの各集計式は、データセット全体で1回評価されます。結果セット内の各非集計式は、データセットの任意に選択された行に対して1回評価されます。任意に選択された同じ行が、非集計式ごとに使用されます。または、データセットにゼロ行が含まれている場合、各非集計式は、完全にNULL値で構成される行に対して評価されます。</target>
        </trans-unit>
        <trans-unit id="14209330d1f571e7543dcd8d5633bd2d841dd6e1" translate="yes" xml:space="preserve">
          <source>If the SELECT statement specified as part of the CREATE VIRTUAL TABLE command returns five columns, then the final column is used for application context only. Swarmvtab does not use this value at all, except that it is passed after &amp;lt;database-name&amp;gt; to both the openclose and missing functions, if specified. In other words, instead of invoking the functions as described above, if the &quot;context&quot; column is present swarmvtab instead invokes:</source>
          <target state="translated">CREATE VIRTUAL TABLEコマンドの一部として指定されたSELECTステートメントが5つの列を返す場合、最後の列はアプリケーションコンテキストにのみ使用されます。Swarmvtabはこの値をまったく使用しません。ただし、&amp;lt;database-name&amp;gt;の後に、指定されている場合、openclose関数と不足している関数の両方に渡されます。言い換えると、上記の関数を呼び出す代わりに、「context」列が存在する場合、swarmvtabは代わりに以下を呼び出します。</target>
        </trans-unit>
        <trans-unit id="40411dedc1ef7864197c263597ddfac1b246cd97" translate="yes" xml:space="preserve">
          <source>If the SQL COMMIT command turns autocommit on and the autocommit logic then tries to commit change but fails because some other process is holding a SHARED lock, then autocommit is turned back off automatically. This allows the user to retry the COMMIT at a later time after the SHARED lock has had an opportunity to clear.</source>
          <target state="translated">SQL COMMITコマンドでオートコミットをオンにした後、他のプロセスがSHAREDロックを保持しているためにオートコミットロジックが変更をコミットしようとして失敗した場合、オートコミットは自動的にオフに戻されます。これにより、SHAREDロックがクリアされた後、後でCOMMITを再試行することができます。</target>
        </trans-unit>
        <trans-unit id="507b41df5b9644d0a599bc2c2ba64c3ea6d21fd9" translate="yes" xml:space="preserve">
          <source>If the SQL statement being executed returns any data, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; is returned each time a new row of data is ready for processing by the caller. The values may be accessed using the &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;column access functions&lt;/a&gt;. sqlite3_step() is called again to retrieve the next row of data.</source>
          <target state="translated">実行中のSQLステートメントがデータを返す場合、呼び出し元が新しいデータ行を処理する準備ができるたびに、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;が返されます。値には、&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;列アクセス関数&lt;/a&gt;を使用してアクセスできます。sqlite3_step（）は、データの次の行を取得するために再度呼び出されます。</target>
        </trans-unit>
        <trans-unit id="ae2787ab5fa2a6425b73b07a4b0ad6b9f341262a" translate="yes" xml:space="preserve">
          <source>If the SQL statement being executed returns any data, then &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; is returned each time a new row of data is ready for processing by the caller. The values may be accessed using the &lt;a href=&quot;column_blob&quot;&gt;column access functions&lt;/a&gt;. sqlite3_step() is called again to retrieve the next row of data.</source>
          <target state="translated">実行中のSQLステートメントがデータを返す場合、呼び出し元が新しいデータ行を処理する準備ができるたびに、&lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;が返されます。値には、&lt;a href=&quot;column_blob&quot;&gt;列アクセス関数&lt;/a&gt;を使用してアクセスできます。sqlite3_step（）は、データの次の行を取得するために再度呼び出されます。</target>
        </trans-unit>
        <trans-unit id="95d391fa1b14c12c13b7ff2232dd79f1ad704028" translate="yes" xml:space="preserve">
          <source>If the SQL statement does not currently point to a valid row, or if the column index is out of range, the result is undefined. These routines may only be called when the most recent call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; has returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; and neither &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; nor &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; have been called subsequently. If any of these routines are called after &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or after &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; has returned something other than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;, the results are undefined. If &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; are called from a different thread while any of these routines are pending, then the results are undefined.</source>
          <target state="translated">SQLステートメントが現在有効な行を指していない場合、または列インデックスが範囲外の場合、結果は未定義です。これらのルーチンは、唯一の最新の呼び出し時に呼び出すことができ&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）が&lt;/a&gt;戻ってきた&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROWを&lt;/a&gt;し、どちらも&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;も&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;後に呼び出されました。&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;または&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）の&lt;/a&gt;後、または&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;が&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;以外のものを返した後に、これらのルーチンのいずれかが呼び出された場合、結果は定義されていません。もし&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;または&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;または&lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;これらのルーチンのいずれかが保留中に別のスレッドから呼び出された場合、結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="34c305f0b8de32e5d504a58326a82216502c31ad" translate="yes" xml:space="preserve">
          <source>If the SQL statement does not currently point to a valid row, or if the column index is out of range, the result is undefined. These routines may only be called when the most recent call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; has returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; and neither &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; nor &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; have been called subsequently. If any of these routines are called after &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or after &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; has returned something other than &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, the results are undefined. If &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; are called from a different thread while any of these routines are pending, then the results are undefined.</source>
          <target state="translated">SQLステートメントが現在有効な行を指していない場合、または列インデックスが範囲外の場合、結果は未定義です。これらのルーチンは、唯一の最新の呼び出し時に呼び出すことができ&lt;a href=&quot;step&quot;&gt;sqlite3_step（）が&lt;/a&gt;戻ってきた&lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROWを&lt;/a&gt;し、どちらも&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;も&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;後に呼び出されました。&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;または&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）の&lt;/a&gt;後、または&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;が&lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;以外のものを返した後に、これらのルーチンのいずれかが呼び出された場合、結果は定義されていません。もし&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;または&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）&lt;/a&gt;または&lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize（）&lt;/a&gt;これらのルーチンのいずれかが保留中に別のスレッドから呼び出された場合、結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="975432fbe3b7571414ef3444c9bae0dbbb675815" translate="yes" xml:space="preserve">
          <source>If the SQLITE_DESERIALIZE_FREEONCLOSE bit is set in F, then SQLite will invoke sqlite3_free() on the serialization buffer when the database connection closes. If the SQLITE_DESERIALIZE_RESIZEABLE bit is set, then SQLite will try to increase the buffer size using sqlite3_realloc64() if writes on the database cause it to grow larger than M bytes.</source>
          <target state="translated">SQLITE_DESERIALIZE_FREEONCLOSEビットがFにセットされている場合、SQLiteはデータベース接続が閉じたときにシリアライズバッファ上でsqlite3_free()を呼び出します。SQLITE_DESERIALIZE_RESIZEABLEビットがセットされている場合、SQLiteはデータベースへの書き込みによりバッファサイズがMバイトよりも大きくなった場合、sqlite3_realloc64()を使用してバッファサイズを増やそうとします。</target>
        </trans-unit>
        <trans-unit id="ea23bbe6e0f5cd400c470a465a873018f1aa3b8b" translate="yes" xml:space="preserve">
          <source>If the SQLITE_JUMPIFNULL bit of P5 is set and either reg(P1) or reg(P3) is NULL then the take the jump. If the SQLITE_JUMPIFNULL bit is clear then fall through if either operand is NULL.</source>
          <target state="translated">P5のSQLITE_JUMPIFNULLビットがセットされていて、reg(P1)またはreg(P3)のいずれかがNULLであれば、ジャンプを行います。SQLITE_JUMPIFNULLビットがクリアされている場合は、オペランドのいずれかがNULLであればフォールスルーします。</target>
        </trans-unit>
        <trans-unit id="d13a5c515dea25bad07a7535880df286b04090a5" translate="yes" xml:space="preserve">
          <source>If the SQLite library is compiled without the NDEBUG preprocessor macro, then the PRAGMA &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;vdbe_trace &lt;/a&gt; causes the VDBE to trace the execution of programs. Though this feature was originally intended for testing and debugging, it can also be useful in learning about how the VDBE operates. Use &quot;&lt;code&gt;PRAGMA vdbe_trace=ON;&lt;/code&gt;&quot; to turn tracing on and &quot;&lt;code&gt;PRAGMA vdbe_trace=OFF&lt;/code&gt;&quot; to turn tracing back off. Like this:</source>
          <target state="translated">SQLiteライブラリがNDEBUGプリプロセッサマクロなしでコンパイルされている場合、PRAGMA &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;vdbe_trace&lt;/a&gt;によってVDBEがプログラムの実行をトレースします。この機能は元々テストとデバッグを目的としたものでしたが、VDBEの動作方法を学ぶのにも役立ちます。「 &lt;code&gt;PRAGMA vdbe_trace=ON;&lt;/code&gt; 」を使用してトレースをオンにし、「 &lt;code&gt;PRAGMA vdbe_trace=OFF&lt;/code&gt; 」を使用してトレースをオフに戻します。このような：</target>
        </trans-unit>
        <trans-unit id="4b9cda344fb3698660c6374cdcb25b1c3d461a5e" translate="yes" xml:space="preserve">
          <source>If the UNIQUE keyword appears between CREATE and INDEX then duplicate index entries are not allowed. Any attempt to insert a duplicate entry will result in an error.</source>
          <target state="translated">CREATEとINDEXの間にUNIQUEキーワードが現れた場合、インデックス項目の重複は許可されません。重複したエントリを挿入しようとするとエラーになります。</target>
        </trans-unit>
        <trans-unit id="2b55abf3573b260c179e3130856801dc205be5f3" translate="yes" xml:space="preserve">
          <source>If the UNIQUE keyword appears between CREATE and INDEX then duplicate index entries are not allowed. Any attempt to insert a duplicate entry will result in an error. For the purposes of unique indices, all NULL values are considered different from all other NULL values and are thus unique. This is one of the two possible interpretations of the SQL-92 standard (the language in the standard is ambiguous) and is the interpretation followed by PostgreSQL, MySQL, Firebird, and Oracle. Informix and Microsoft SQL Server follow the other interpretation of the standard.</source>
          <target state="translated">CREATEとINDEXの間にUNIQUEキーワードが現れた場合、インデックス項目の重複は許可されません。重複した項目を挿入しようとするとエラーになります。一意なインデックスの目的では、すべてのNULL値は他のすべてのNULL値とは異なるものとみなされ、したがって一意です。これはSQL-92標準の2つの解釈のうちの1つであり(標準の言語は曖昧です)、PostgreSQL、MySQL、Firebird、Oracleが採用している解釈です。Informix と Microsoft SQL Server は、もう一方の解釈に従っています。</target>
        </trans-unit>
        <trans-unit id="302753955d8021d9d751890a4a62678a7bd1dc4c" translate="yes" xml:space="preserve">
          <source>If the UPDATE operation is attempted, but SQLite returns SQLITE_CONSTRAINT, the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; passed as the second argument. This includes the case where the UPDATE operation is attempted after an earlier call to the conflict handler function returned &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">UPDATE操作を試みてもSQLiteがSQLITE_CONSTRAINTを返す場合、2番目の引数として&lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINTを&lt;/a&gt;渡して競合ハンドラ関数が呼び出されます。これには、競合ハンドラー関数への以前の呼び出しが&lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACEを&lt;/a&gt;返した後にUPDATE操作が試行された場合が含まれます。</target>
        </trans-unit>
        <trans-unit id="40c8985574cc4136a7a40f15001ace597cd448e0" translate="yes" xml:space="preserve">
          <source>If the UPDATE operation is attempted, but SQLite returns SQLITE_CONSTRAINT, the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; passed as the second argument. This includes the case where the UPDATE operation is attempted after an earlier call to the conflict handler function returned &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">UPDATE操作を試みてもSQLiteがSQLITE_CONSTRAINTを返す場合、2番目の引数として&lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINTを&lt;/a&gt;渡して競合ハンドラ関数が呼び出されます。これには、競合ハンドラー関数への以前の呼び出しが&lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACEを&lt;/a&gt;返した後にUPDATE操作が試行された場合が含まれます。</target>
        </trans-unit>
        <trans-unit id="751229ce68d5f9fb206ae67bb99718de4be423dd" translate="yes" xml:space="preserve">
          <source>If the UPDATE statement does not have a WHERE clause, all rows in the table are modified by the UPDATE. Otherwise, the UPDATE affects only those rows for which the WHERE clause &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression is true&lt;/a&gt;. It is not an error if the WHERE clause does not evaluate to true for any row in the table - this just means that the UPDATE statement affects zero rows.</source>
          <target state="translated">UPDATEステートメントにWHERE句がない場合、テーブル内のすべての行がUPDATEによって変更されます。それ以外の場合、UPDATEは、WHERE句の&lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;ブール式がtrue&lt;/a&gt;である行にのみ影響します。WHERE句がテーブルのどの行に対してもtrueと評価されない場合でもエラーではありません。これは、UPDATEステートメントが影響を受ける行がないことを意味します。</target>
        </trans-unit>
        <trans-unit id="074562fe8dfabc7ba122942fddf559f05fa48e31" translate="yes" xml:space="preserve">
          <source>If the UPDATE statement has no ORDER BY clause, then all rows that would be updated in the absence of the LIMIT clause are assembled in an arbitrary order before applying the LIMIT and OFFSET clauses to determine which are actually updated.</source>
          <target state="translated">UPDATE文にORDER BY句がない場合、LIMIT句がない場合に更新されるすべての行は、LIMIT句とOFFSET句を適用して実際に更新される行を決定する前に、任意の順序で組み立てられます。</target>
        </trans-unit>
        <trans-unit id="0ee1b94b95429e744f462704efa364a50f2413f6" translate="yes" xml:space="preserve">
          <source>If the WAL-index is implemented as a memory-mapped file and that file is read-only to the first thread to connect, then that thread creates an private heap-memory ersazt WAL-index and runs the recovery routine to populate that private WAL-index. The same data results, but it is held privately rather that being written into the public shared memory area.</source>
          <target state="translated">WAL-index がメモリマップされたファイルとして実装されており、そのファイルが最初に接続するスレッドに対して読み取り専用である場合、そのスレッドはプライベートなヒープメモリの ersazt WAL-index を作成し、そのプライベートな WAL-index を埋めるためにリカバリールーチンを実行します。同じデータの結果が得られるが、それはパブリックな共有メモリ領域に書き込まれるのではなく、プライベートに保持される。</target>
        </trans-unit>
        <trans-unit id="7648c2d70dafce18f6cb4ef634247a503d61eeca" translate="yes" xml:space="preserve">
          <source>If the WHERE clause evaluates to FALSE, then skip the steps that follow and continue to the next record.</source>
          <target state="translated">WHERE 句が FALSE と評価された場合は、次のステップをスキップして次のレコードに進みます。</target>
        </trans-unit>
        <trans-unit id="37f61285fabc2a1caf8acf5c9c00c9ccc80b5f28" translate="yes" xml:space="preserve">
          <source>If the WHERE clause is not present, all records in the table are deleted. If a WHERE clause is supplied, then only those rows for which the WHERE clause &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt; is true are deleted. Rows for which the expression is false or NULL are retained.</source>
          <target state="translated">WHERE句が存在しない場合、テーブル内のすべてのレコードが削除されます。WHERE句が指定されている場合、WHERE句の&lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;ブール式&lt;/a&gt;がtrue である行のみが削除されます。式がfalseまたはNULLの行は保持されます。</target>
        </trans-unit>
        <trans-unit id="7ecdfb78c909bf7386760f4b8a9af44a0acb2a2c" translate="yes" xml:space="preserve">
          <source>If the WHERE clause of a query contains an OR expression, then SQLite might use the &lt;a href=&quot;queryplanner#or_in_where&quot;&gt;&quot;OR by union&quot;&lt;/a&gt; strategy (also known as the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt;). In this case there will be single top-level record for the search, with two sub-records, one for each index:</source>
          <target state="translated">クエリのWHERE句にOR式が含まれている場合、SQLiteは&lt;a href=&quot;queryplanner#or_in_where&quot;&gt;「OR by union」&lt;/a&gt;戦略（&lt;a href=&quot;optoverview#or_opt&quot;&gt;OR最適化と&lt;/a&gt;も呼ばれます）を使用する場合があります。この場合、検索には単一のトップレベルレコードがあり、各インデックスに1つずつ、2つのサブレコードがあります。</target>
        </trans-unit>
        <trans-unit id="66d534e3ba541f4a816044bc7bb6de32d19f621c" translate="yes" xml:space="preserve">
          <source>If the Y parameter to sqlite3_free_filename(Y) is anything other than a NULL pointer or a pointer previously acquired from sqlite3_create_filename(), then bad things such as heap corruption or segfaults may occur. The value Y should be used again after sqlite3_free_filename(Y) has been called. This means that if the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen()&lt;/a&gt; method of a VFS has been called using Y, then the corresponding [sqlite3_module.xClose() method should also be invoked prior to calling sqlite3_free_filename(Y).</source>
          <target state="translated">If the Y parameter to sqlite3_free_filename(Y) is anything other than a NULL pointer or a pointer previously acquired from sqlite3_create_filename(), then bad things such as heap corruption or segfaults may occur. The value Y should be used again after sqlite3_free_filename(Y) has been called. This means that if the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen()&lt;/a&gt; method of a VFS has been called using Y, then the corresponding [sqlite3_module.xClose() method should also be invoked prior to calling sqlite3_free_filename(Y).</target>
        </trans-unit>
        <trans-unit id="47f803875c1a08bebb885c914c92a3d72ff50a92" translate="yes" xml:space="preserve">
          <source>If the Y parameter to sqlite3_free_filename(Y) is anything other than a NULL pointer or a pointer previously acquired from sqlite3_create_filename(), then bad things such as heap corruption or segfaults may occur. The value Y should be used again after sqlite3_free_filename(Y) has been called. This means that if the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen()&lt;/a&gt; method of a VFS has been called using Y, then the corresponding [sqlite3_module.xClose() method should also be invoked prior to calling sqlite3_free_filename(Y).</source>
          <target state="translated">sqlite3_free_filename（Y）のYパラメーターがNULLポインター、または以前にsqlite3_create_filename（）から取得したポインター以外の場合、ヒープの破損やセグメンテーション違反などの問題が発生する可能性があります。sqlite3_free_filename（Y）が呼び出された後、値Yを再度使用する必要があります。これは、VFSの&lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen（）&lt;/a&gt;メソッドがYを使用して呼び出された場合、sqlite3_free_filename（Y）を呼び出す前に、対応する[sqlite3_module.xClose（）メソッドも呼び出す必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="74877c4dea96c98f4b3c0b669711d0dd7770d2b9" translate="yes" xml:space="preserve">
          <source>If the _HAVE_SQLITE_CONFIG_H macro is defined then the SQLite source code will attempt to #include a file named &quot;config.h&quot;. The &quot;config.h&quot; file usually contains other configuration options, especially &quot;HAVE_</source>
          <target state="translated">マクロ _HAVE_SQLITE_CONFIG_H が定義されている場合、SQLite のソースコードは &quot;config.h&quot; という名前のファイルを#インクルードしようとします。config.h&quot; ファイルには通常、他の設定オプション、特に &quot;HAVE_HAVE_CONFIG_H&quot; が含まれています。</target>
        </trans-unit>
        <trans-unit id="558abcd908b311140ea78da82869118d13cb3c75" translate="yes" xml:space="preserve">
          <source>If the action code is &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_READ&lt;/a&gt; and the callback returns &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; then the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; statement is constructed to substitute a NULL value in place of the table column that would have been read if &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; had been returned. The &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; return can be used to deny an untrusted user access to individual columns of a table. When a table is referenced by a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; but no column values are extracted from that table (for example in a query like &quot;SELECT count(*) FROM tab&quot;) then the &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_READ&lt;/a&gt; authorizer callback is invoked once for that table with a column name that is an empty string. If the action code is &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt; and the callback returns &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; then the &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; operation proceeds but the &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt; is disabled and all rows are deleted individually.</source>
          <target state="translated">アクションコードが&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_READ&lt;/a&gt;で、コールバックが&lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt;を返す場合、&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備されたステートメント&lt;/a&gt;ステートメントは、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;が返された場合に読み取られたであろうテーブル列の代わりにNULL値を置き換えるように構築されます。&lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNOREの&lt;/a&gt;リターンは、テーブルの個々の列に信頼されないユーザのアクセスを拒否するために使用することができます。テーブルが&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;によって参照されているが、そのテーブルから列値が抽出されない場合（たとえば、「SELECT count（*）FROM tab」のようなクエリで）、&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_READオーソライザー&lt;/a&gt;コールバックは、次の列名を持つそのテーブルに対して1回呼び出されます。空の文字列です。アクションコードが&lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETEの&lt;/a&gt;場合コールバックが&lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt;を返すと、&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;操作は続行されますが、&lt;a href=&quot;lang_delete#truncateopt&quot;&gt;トランケートの最適化&lt;/a&gt;は無効になり、すべての行が個別に削除されます。</target>
        </trans-unit>
        <trans-unit id="551e501bb088fee5fee1641a8f77e7fc3633f5dd" translate="yes" xml:space="preserve">
          <source>If the action code is &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt; and the callback returns &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; then the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; statement is constructed to substitute a NULL value in place of the table column that would have been read if &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; had been returned. The &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; return can be used to deny an untrusted user access to individual columns of a table. When a table is referenced by a &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; but no column values are extracted from that table (for example in a query like &quot;SELECT count(*) FROM tab&quot;) then the &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt; authorizer callback is invoked once for that table with a column name that is an empty string. If the action code is &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; and the callback returns &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; then the &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; operation proceeds but the &lt;a href=&quot;../lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt; is disabled and all rows are deleted individually.</source>
          <target state="translated">アクションコードが&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt;で、コールバックが&lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt;を返す場合、&lt;a href=&quot;stmt&quot;&gt;準備されたステートメント&lt;/a&gt;ステートメントは、&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;が返された場合に読み取られたであろうテーブル列の代わりにNULL値を置き換えるように構築されます。&lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNOREの&lt;/a&gt;リターンは、テーブルの個々の列に信頼されないユーザのアクセスを拒否するために使用することができます。テーブルが&lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt;によって参照されているが、そのテーブルから列値が抽出されない場合（たとえば、「SELECT count（*）FROM tab」のようなクエリで）、&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_READオーソライザー&lt;/a&gt;コールバックは、次の列名を持つそのテーブルに対して1回呼び出されます。空の文字列です。アクションコードが&lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETEの&lt;/a&gt;場合コールバックが&lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt;を返すと、&lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt;操作は続行されますが、&lt;a href=&quot;../lang_delete#truncateopt&quot;&gt;トランケートの最適化&lt;/a&gt;は無効になり、すべての行が個別に削除されます。</target>
        </trans-unit>
        <trans-unit id="bd1e313db1648e3d841b56f1eba1325f9492fb26" translate="yes" xml:space="preserve">
          <source>If the application does not use triggers or views, consider disabling the unused capabilities with:</source>
          <target state="translated">アプリケーションがトリガーやビューを使用しない場合は、使用していない機能を無効にすることを検討してください。</target>
        </trans-unit>
        <trans-unit id="e48946c22fc154fe87cb537c121e425dbb9574d0" translate="yes" xml:space="preserve">
          <source>If the application does not use triggers or views, then disable the unused capabilities using:</source>
          <target state="translated">アプリケーションがトリガーやビューを使用しない場合は、使用していない機能を無効にします。</target>
        </trans-unit>
        <trans-unit id="f5d26d8716b0cdd9f988973fac2e73b815006603" translate="yes" xml:space="preserve">
          <source>If the application does use triggers or views, then use queries to scan the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; table to verify that the triggers and views found there are expected, that there are no surplus triggers or views, existing triggers and views have not been tampered with, and that no existing ordinary tables have been replaced by malicious views.</source>
          <target state="translated">アプリケーションがトリガーまたはビューを使用する場合は、クエリを使用して&lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt;テーブルをスキャンし、トリガーとビューが予期されていること、余計なトリガーとビューがないこと、既存のトリガーとビューが改ざんされていないこと、および既存の通常のテーブルは、悪意のあるビューに置き換えられていません。</target>
        </trans-unit>
        <trans-unit id="0aef3c759a1be5c730a8586e6ee0c4911bb88637" translate="yes" xml:space="preserve">
          <source>If the application includes any &lt;a href=&quot;appfunc&quot;&gt;custom SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab#customvtab&quot;&gt;custom virtual tables&lt;/a&gt; that have side effects or that might leak privileged information, then the application should use one or more of the techniques below to prevent a maliciously crafted database schema from surreptitiously running those SQL functions and/or virtual tables for nefarious purposes:</source>
          <target state="translated">If the application includes any &lt;a href=&quot;appfunc&quot;&gt;custom SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab#customvtab&quot;&gt;custom virtual tables&lt;/a&gt; that have side effects or that might leak privileged information, then the application should use one or more of the techniques below to prevent a maliciously crafted database schema from surreptitiously running those SQL functions and/or virtual tables for nefarious purposes:</target>
        </trans-unit>
        <trans-unit id="2469e0f7ca599347e4594642b1d8b0b3f0287081" translate="yes" xml:space="preserve">
          <source>If the application invokes &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control&lt;/a&gt;(&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;) on the database connection prior to closing, then the final checkpoint is still run but the WAL and WAL-index files are not deleted as they normally would be. This leaves the database in a state that allows other processes without write permission on the database, WAL, or WAL-index files to open the database read-only. If the WAL and WAL-index files are missing, then a process that lacks permission to create and initialize those files will not be able to open the database, unless the database is designated as immutable using the &lt;a href=&quot;uri#uriimmutable&quot;&gt;immutable query parameter&lt;/a&gt;.</source>
          <target state="translated">アプリケーションが閉じる前にデータベース接続で&lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control&lt;/a&gt;（&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;）を呼び出す場合、最終チェックポイントは引き続き実行されますが、WALおよびWALインデックスファイルは通常どおり削除されません。これにより、データベースは、データベース、WAL、またはWAL-indexファイルに対する書き込み権限のない他のプロセスがデータベースを読み取り専用で開くことができる状態になります。 WALおよびWAL-indexファイルがない場合、これらのファイルを作成および初期化する権限のないプロセスは、データベースが&lt;a href=&quot;uri#uriimmutable&quot;&gt;不変クエリパラメータ&lt;/a&gt;を使用して不変として指定されていない限り、データベースを開くことができません。</target>
        </trans-unit>
        <trans-unit id="0623d9575995bdb9d6c267b0da83f975d16d83ea" translate="yes" xml:space="preserve">
          <source>If the application is designed to manage data in small pieces, then the database should never contain any large strings or BLOBs and hence element 1 above should not be a factor. If the database does contain large strings or BLOBs, they should be read using &lt;a href=&quot;c3ref/blob&quot;&gt;incremental BLOB I/O&lt;/a&gt; and rows that contain the large strings or BLOBs should never be update by any means other than &lt;a href=&quot;c3ref/blob&quot;&gt;incremental BLOB I/O&lt;/a&gt;. Otherwise, the &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; routine will need to read the entire row into contiguous memory at some point, and that will involve at least one large memory allocation.</source>
          <target state="translated">アプリケーションがデータを小さな単位で管理するように設計されている場合、データベースに大きな文字列やBLOBが含まれることは決してないため、上記の要素1は要素になりません。データベースに大きな文字列またはBLOBが含まれている場合は、&lt;a href=&quot;c3ref/blob&quot;&gt;インクリメンタルBLOB I / O&lt;/a&gt;を使用して読み取り、大きな文字列またはBLOBを含む行は&lt;a href=&quot;c3ref/blob&quot;&gt;インクリメンタルBLOB I / O&lt;/a&gt;以外の方法で更新しないでください。それ以外の場合、&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;ルーチンは、ある時点で行全体を連続したメモリに読み込む必要があり、これには少なくとも1つの大きなメモリ割り当てが含まれます。</target>
        </trans-unit>
        <trans-unit id="d0ebb1eaae39f6046644fb7a5c8e50db080966a3" translate="yes" xml:space="preserve">
          <source>If the application or host computer crashes before the transaction completes, then the rollback journal or write-ahead log contains information needed to restore the main database file to a consistent state. When a rollback journal or write-ahead log contains information necessary for recovering the state of the database, they are called a &quot;hot journal&quot; or &quot;hot WAL file&quot;. Hot journals and WAL files are only a factor during error recovery scenarios and so are uncommon, but they are part of the state of an SQLite database and so cannot be ignored. This document defines the format of a rollback journal and the write-ahead log file, but the focus is on the main database file.</source>
          <target state="translated">トランザクションが完了する前にアプリケーションまたはホストコンピュータがクラッシュした場合、ロールバックジャーナルまたは書込先ログには、メインデータベースファイルを一貫した状態に復元するために必要な情報が含まれています。ロールバックジャーナルまたは書込み先ログにデータベースの状態を回復するために必要な情報が含まれている場合、それらは「ホットジャーナル」または「ホットWALファイル」と呼ばれます。ホットジャーナルやWALファイルは、エラー回復のシナリオの中でのみ要素となるため、珍しいものではありませんが、SQLiteデータベースの状態の一部であるため、無視することはできません。このドキュメントでは、ロールバック・ジャーナルとライトアップ・リード・ログ・ファイルのフォーマットを定義していますが、メイン・データベース・ファイルに焦点を当てています。</target>
        </trans-unit>
        <trans-unit id="2a5d41f54973dce5874420b1200abe91d1314dc8" translate="yes" xml:space="preserve">
          <source>If the application uses &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; that have side effects, then it is recommended to set the &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag on those SQL functions to prevent them from being used inside triggers and views. To illustrate the importance of this flag, consider an application that implements an SQL function &quot;send_money(...)&quot;. Without the SQLITE_DIRECTONLY flag, an attacker might be able to add a trigger or view that uses that custom function, then trick a high-privilege application to run an otherwise harmless query that invokes that malicious trigger or view. The SQLITE_DIRECTONLY flag prevents the attack by requiring the &quot;send_money()&quot; function to be invoked directly by the application, rather than indirectly through a trigger or view.</source>
          <target state="translated">アプリケーションが副作用のある&lt;a href=&quot;c3ref/create_function&quot;&gt;アプリケーション定義のSQL関数&lt;/a&gt;を使用する場合は、それらのSQL関数に&lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;フラグを設定して、トリガーやビュー内で使用されないようにすることをお勧めします。このフラグの重要性を説明するために、SQL関数「send_money（...）」を実装するアプリケーションを考えてみましょう。 SQLITE_DIRECTONLYフラグがないと、攻撃者はそのカスタム関数を使用するトリガーまたはビューを追加し、高特権のアプリケーションをだまして、その悪意のあるトリガーまたはビューを呼び出す無害なクエリを実行できる可能性があります。 SQLITE_DIRECTONLYフラグは、 &quot;send_money（）&quot;関数がトリガーまたはビューを介して間接的にではなく、アプリケーションによって直接呼び出されることを要求することにより、攻撃を防ぎます。</target>
        </trans-unit>
        <trans-unit id="d6f9cd1b9ea5044b899607d0f8509b7399b72066" translate="yes" xml:space="preserve">
          <source>If the application wanted to keep all content in memory, it could continue reading and parsing the other pages using a background thread after drawing the first page. Or, since reading from SQLite is so efficient, the application might instead choose to reduce its memory footprint and only keep a single slide in memory at a time. Or maybe it keeps the current slide and the next slide in memory, to facility rapid transitions to the next slide.</source>
          <target state="translated">アプリケーションがすべてのコンテンツをメモリに保持したい場合は、最初のページを描画した後、バックグラウンドスレッドを使用して他のページの読み込みと解析を続けることができます。あるいは、SQLiteからの読み込みは非常に効率的なので、アプリケーションは代わりにメモリフットプリントを減らして、一度に1つのスライドだけをメモリに保持することを選択するかもしれません。あるいは、メモリ内に現在のスライドと次のスライドを保持し、次のスライドへの迅速な移行を可能にします。</target>
        </trans-unit>
        <trans-unit id="8569a113bc3212a8fdd578bf6c990f890a161761" translate="yes" xml:space="preserve">
          <source>If the argument N is positive then the suggested cache size is set to N. If the argument N is negative, then the number of cache pages is adjusted to be a number of pages that would use approximately abs(N*1024) bytes of memory based on the current page size. SQLite remembers the number of pages in the page cache, not the amount of memory used. So if you set the cache size using a negative number and subsequently change the page size (using the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt; command) then the maximum amount of cache memory will go up or down in proportion to the change in page size.</source>
          <target state="translated">引数Nが正の場合、推奨されるキャッシュサイズはNに設定されます。引数Nが負の場合、キャッシュページの数は、約abs（N * 1024）バイトのメモリを使用するページの数に調整されます。現在のページサイズに基づきます。SQLiteは、使用されているメモリの量ではなく、ページキャッシュ内のページ数を記憶しています。したがって、負の数を使用してキャッシュサイズを設定し、その後（&lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt;コマンドを使用して）ページサイズを変更すると、キャッシュメモリの最大量はページサイズの変更に比例して増減します。</target>
        </trans-unit>
        <trans-unit id="333007bde9d13022c1e70f3f252829b77ea3504a" translate="yes" xml:space="preserve">
          <source>If the argument N is zero then the soft heap limit is disabled.</source>
          <target state="translated">引数Nが0の場合、ソフトヒープの制限は無効になります。</target>
        </trans-unit>
        <trans-unit id="0910062f14fed63da9341471516f0b8c2feb398e" translate="yes" xml:space="preserve">
          <source>If the argument X to json(X) contains JSON objects with duplicate labels, then it is undefined whether or not the duplicates are preserved. The current implementation preserves duplicates. However, future enhancements to this routine may choose to silently remove duplicates.</source>
          <target state="translated">json(X)への引数Xにラベルが重複するJSONオブジェクトが含まれている場合、重複を保存するかどうかは未定義です。現在の実装では、重複は保存されます。しかし、このルーチンへの将来の拡張は、重複を黙って削除することを選択するかもしれません。</target>
        </trans-unit>
        <trans-unit id="6f833aefc23dc66bc8a11fd873780dad93c32799" translate="yes" xml:space="preserve">
          <source>If the argument is an empty string then the authorizer is disabled. If the argument is omitted, then the current authorizer is returned.</source>
          <target state="translated">引数が空の文字列の場合、オーソライズは無効になります。引数が省略された場合は、現在の認証者が返されます。</target>
        </trans-unit>
        <trans-unit id="db2e11d8e987617a2ede3ca5cb77cc0207ab30da" translate="yes" xml:space="preserve">
          <source>If the argument to %Q is a null pointer then the output is an unquoted &quot;NULL&quot;. In other words, a null pointer generates an SQL NULL, and a non-null pointer generates a valid SQL string literal. If the argument to %q is a null pointer then no output is generated. Thus a null-pointer to %q is the same as an empty string.</source>
          <target state="translated">Q の引数が NULL ポインタの場合、出力は引用符で囲まれていない &quot;NULL&quot; です。言い換えれば、NULL ポインタは SQL NULL を生成し、NULL 以外のポインタは有効な SQL 文字列リテラルを生成します。q の引数が NULL ポインタの場合、出力は生成されません。したがって、%q への NULL ポインタは空の文字列と同じです。</target>
        </trans-unit>
        <trans-unit id="34bfefe0d198d1d0315cf64a45912620ff3af0d6" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; is negative N, that means to use approximately -1024*N bytes of memory for the page cache regardless of the page size.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt;の引数が負のNの場合、ページサイズに関係なく、ページキャッシュに約-1024 * Nバイトのメモリを使用することを意味します。</target>
        </trans-unit>
        <trans-unit id="ad1260c6e1a01baa74d5f905fe5850603affd484" translate="yes" xml:space="preserve">
          <source>If the argument to sqlite3_mutex_enter(), sqlite3_mutex_try(), or sqlite3_mutex_leave() is a NULL pointer, then all three routines behave as no-ops.</source>
          <target state="translated">sqlite3_mutex_enter(),sqlite3_mutex_try(),sqlite3_mutex_leave()の引数がNULLポインタの場合、3つのルーチンは全てno-opsとして動作します。</target>
        </trans-unit>
        <trans-unit id="0142caf16fb3155af68268c72b44fbf8e770bbff" translate="yes" xml:space="preserve">
          <source>If the argument to sqlite3_mutex_held() is a NULL pointer then the routine should return 1. This seems counter-intuitive since clearly the mutex cannot be held if it does not exist. But the reason the mutex does not exist is because the build is not using mutexes. And we do not want the assert() containing the call to sqlite3_mutex_held() to fail, so a non-zero return is the appropriate thing to do. The sqlite3_mutex_notheld() interface should also return 1 when given a NULL pointer.</source>
          <target state="translated">sqlite3_mutex_held()の引数がNULLポインタであれば、ルーチンは1を返します。これは直観的ではないように思えますが、ミューテックスが存在しない場合、ミューテックスを保持することはできません。しかし、ミューテックスが存在しないのは、ビルドでミューテックスを使用していないからです。また、sqlite3_mutex_held()の呼び出しを含むassert()が失敗しないようにしたいので、0以外の値を返すのが適切です。sqlite3_mutex_notheld()インタフェースもNULLポインタが与えられた場合は1を返すべきです。</target>
        </trans-unit>
        <trans-unit id="a14ce7fd473c10953375f9ccbf76e06b28005ef4" translate="yes" xml:space="preserve">
          <source>If the array variable name is omitted or is the empty string, then the value of each column is stored in a variable with the same name as the column itself. For example:</source>
          <target state="translated">配列の変数名が省略された場合や空文字列の場合は、各カラムの値がカラムそのものと同じ名前の変数に格納されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="ac696fda1c1264eced84b7c7d2919bb500892965" translate="yes" xml:space="preserve">
          <source>If the attempt to insert the row fails because of some other constraint violation (e.g. NOT NULL or UNIQUE), the conflict handler function is invoked with the second argument set to &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt;. This includes the case where the INSERT operation is re-attempted because an earlier call to the conflict handler function returned &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">その他の制約違反（NOT NULLやUNIQUEなど）が原因で行の挿入が失敗した場合、2番目の引数を&lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINTに&lt;/a&gt;設定して競合ハンドラー関数が呼び出されます。これには、競合ハンドラー関数への以前の呼び出しが&lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACEを&lt;/a&gt;返したため、INSERT操作が再試行された場合が含まれます。</target>
        </trans-unit>
        <trans-unit id="00b4296a5ab760c82790fc716c15427ea1f6520d" translate="yes" xml:space="preserve">
          <source>If the attempt to insert the row fails because of some other constraint violation (e.g. NOT NULL or UNIQUE), the conflict handler function is invoked with the second argument set to &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt;. This includes the case where the INSERT operation is re-attempted because an earlier call to the conflict handler function returned &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">その他の制約違反（NOT NULLやUNIQUEなど）が原因で行の挿入が失敗した場合、2番目の引数を&lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINTに&lt;/a&gt;設定して競合ハンドラー関数が呼び出されます。これには、競合ハンドラー関数への以前の呼び出しが&lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACEを&lt;/a&gt;返したため、INSERT操作が再試行された場合が含まれます。</target>
        </trans-unit>
        <trans-unit id="1a0b7bf9240c877d42c55de96b224187eca54a50" translate="yes" xml:space="preserve">
          <source>If the attempt to insert the row fails because the database already contains a row with the same primary key values, the conflict handler function is invoked with the second argument set to &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;.</source>
          <target state="translated">同じ主キー値を持つ行がデータベースにすでに含まれているために行の挿入が失敗した場合、2番目の引数を&lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONFLICTに&lt;/a&gt;設定して競合ハンドラー関数が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="86e563d45d385632baebf3e72388be8c4af6aec3" translate="yes" xml:space="preserve">
          <source>If the attempt to insert the row fails because the database already contains a row with the same primary key values, the conflict handler function is invoked with the second argument set to &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;.</source>
          <target state="translated">同じ主キー値を持つ行がデータベースにすでに含まれているために行の挿入が失敗した場合、2番目の引数を&lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONFLICTに&lt;/a&gt;設定して競合ハンドラー関数が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="3629ea18c991de1dc5f5b9e0680718c68964bd44" translate="yes" xml:space="preserve">
          <source>If the bClear argument is non-zero, then the auxiliary data is cleared (set to NULL) before this function returns. In this case the xDelete, if any, is not invoked.</source>
          <target state="translated">引数bClearが0以外の場合、この関数が戻る前に補助データがクリアされます(NULLに設定されます)。この場合、xDeleteは呼び出されません。</target>
        </trans-unit>
        <trans-unit id="85be6aa821286c3a809817d29ac82866a6650696" translate="yes" xml:space="preserve">
          <source>If the backup process is restarted frequently enough it may never run to completion and the backupDb() function may never return.</source>
          <target state="translated">バックアッププロセスが頻繁に再起動されると、完了まで実行されず、 backupDb()関数が戻らない可能性があります。</target>
        </trans-unit>
        <trans-unit id="ed3ecd64439c51685da70c45077d54474b903f89" translate="yes" xml:space="preserve">
          <source>If the base expression is NULL then the result of the CASE is always the result of evaluating the ELSE expression if it exists, or NULL if it does not.</source>
          <target state="translated">ベースとなる式がNULLの場合、CASEの結果は常にELSE式が存在する場合はELSE式を評価した結果となり、存在しない場合はNULLとなります。</target>
        </trans-unit>
        <trans-unit id="8a427aa0dc34d2b046c1ad51ad7573c594257eb3" translate="yes" xml:space="preserve">
          <source>If the base window has an ORDER BY clause, it is copied into the new window. In this case the new window must not specify an ORDER BY clause. If the base window has no ORDER BY clause, one may be specified as part of the new window definition.</source>
          <target state="translated">ベース・ウィンドウに ORDER BY 節がある場合、それは新しいウィンドウにコピーされます。この場合、新しいウィンドウは ORDER BY 節を指定してはいけません。ベース・ウィンドウに ORDER BY 句がない場合、新しいウィンドウの定義の一部として ORDER BY 句を指定することができます。</target>
        </trans-unit>
        <trans-unit id="119dee4cbf58f5993be5ffddf2563e1e23c3d8e2" translate="yes" xml:space="preserve">
          <source>If the blob handle being closed was opened for read-write access, and if the database is in auto-commit mode and there are no other open read-write blob handles or active write statements, the current transaction is committed. If an error occurs while committing the transaction, an error code is returned and the transaction rolled back.</source>
          <target state="translated">閉じられているブロブ・ハンドルが読み書きアクセスのために開かれていて、データベースがオートコミット・モードで、他に開いている読み書きブロブ・ハンドルやアクティブな書き込み文がない場合、現在のトランザクションはコミットされます。トランザクションのコミット中にエラーが発生した場合、エラーコードが返され、トランザクションはロールバックされます。</target>
        </trans-unit>
        <trans-unit id="a888511d0d42c7a009b52c11f52254e39a8e8777" translate="yes" xml:space="preserve">
          <source>If the blocked connection is attempting to obtain a write-lock on a shared-cache table, and more than one other connection currently holds a read-lock on the same table, then SQLite arbitrarily selects one of the other connections to use as the blocking connection.</source>
          <target state="translated">ブロックされた接続が共有キャッシュ・テーブルの書き込みロックを取得しようとしており、現在同じテーブルの読み取りロックを保持している他の接続が複数ある場合、SQLite は任意に他の接続のうちの 1 つをブロック接続として使用するように選択します。</target>
        </trans-unit>
        <trans-unit id="b15e015a6e8222ac8277a814fcfbbc84b5b7b2fa" translate="yes" xml:space="preserve">
          <source>If the branch instruction that implements the &quot;c!=0&quot; test on line 58 is changed into a no-op, then the while-loop will loop forever and the test suite will fail with a time-out. But if that branch is changed into an unconditional jump, then the hash function will always return 0. The problem is that 0 is a valid hash. A hash function that always returns 0 still works in the sense that SQLite still always gets the correct answer. The table-name hash table degenerates into a linked-list and so the table-name lookups that occur while parsing SQL statements might be a little slower, but the end result will be the same.</source>
          <target state="translated">58行目の &quot;c!=0 &quot;テストを実装する分岐命令が無条件ジャンプに変更された場合、while-loopは永遠にループし、テストスイートはタイムアウトで失敗します。しかし、そのブランチが無条件ジャンプに変更された場合、ハッシュ関数は常に0を返します。問題は、0が有効なハッシュであることです。常に0を返すハッシュ関数は、SQLiteが常に正しい答えを得るという意味ではまだ機能します。テーブル名ハッシュテーブルはリンクされたリストに退化するので、SQL文の解析中に発生するテーブル名の検索は少し遅くなるかもしれませんが、最終的な結果は同じです。</target>
        </trans-unit>
        <trans-unit id="d10a175cfd1fe16985e295daacc2dcfb3f2982ad" translate="yes" xml:space="preserve">
          <source>If the buffer contains a patchset, then all prior calls to this function on the same changegroup object must also have specified patchsets. Or, if the buffer contains a changeset, so must have the earlier calls to this function. Otherwise, SQLITE_ERROR is returned and no changes are added to the changegroup.</source>
          <target state="translated">バッファにパッチセットが含まれている場合、同じ changegroup オブジェクト上でこの関数を呼び出す前の全ての呼び出しも指定されたパッチセットを持っていなければなりません。あるいは、バッファにチェンジセットが含まれている場合は、以前にこの関数を呼び出したことがあるはずです。そうでない場合は SQLITE_ERROR が返され、変更は changegroup に追加されません。</target>
        </trans-unit>
        <trans-unit id="5cba5e39badf94f78fab97af6a07c73e6243cd28" translate="yes" xml:space="preserve">
          <source>If the busy callback is NULL, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned immediately upon encountering the lock. If the busy callback is not NULL, then the callback might be invoked with two arguments.</source>
          <target state="translated">ビジーコールバックがNULLの場合、ロックが発生するとすぐに&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;が返されます。ビジーコールバックがNULLでない場合、コールバックは2つの引数で呼び出される可能性があります。</target>
        </trans-unit>
        <trans-unit id="5b0bd17ec528127c481fd60daa34e2af13ea7150" translate="yes" xml:space="preserve">
          <source>If the busy callback is NULL, then &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned immediately upon encountering the lock. If the busy callback is not NULL, then the callback might be invoked with two arguments.</source>
          <target state="translated">ビジーコールバックがNULLの場合、ロックが発生するとすぐに&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;が返されます。ビジーコールバックがNULLでない場合、コールバックは2つの引数で呼び出される可能性があります。</target>
        </trans-unit>
        <trans-unit id="afcbf1f3e790adb1bb6040c89a071eb5f4f5a2b5" translate="yes" xml:space="preserve">
          <source>If the busy method is invoked without an argument, the name of the callback procedure last set by the busy method is returned. If no callback procedure has been set, an empty string is returned.</source>
          <target state="translated">引数なしでビジー・メソッドが呼び出された場合、ビジー・メソッドで最後に設定されたコールバック・プロシージャの名前が返されます。コールバックプロシージャが設定されていない場合は、空の文字列が返されます。</target>
        </trans-unit>
        <trans-unit id="85f5b0357119cb8e1c6a774de7f6ae30085546fa" translate="yes" xml:space="preserve">
          <source>If the cache validate procedure prescribed by H35040 is required and does not prove that the</source>
          <target state="translated">H35040で規定されたキャッシュバリデート手順が必要であり、その証明ができない場合には</target>
        </trans-unit>
        <trans-unit id="854ac2efa118a1d9433a97bc97dd8176f442561c" translate="yes" xml:space="preserve">
          <source>If the call to xAccess() required by H35140 fails (due to an IO error or similar), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">H35140 で要求された xAccess()の呼び出しが (IO エラーなどにより)失敗した場合、SQLite は</target>
        </trans-unit>
        <trans-unit id="1c9becc9db0bbc14b6323875b3f39aa5c2a244e7" translate="yes" xml:space="preserve">
          <source>If the call to xAccess() required by H35490 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">H35490 で要求された xAccess()の呼び出しが (IO またはその他の内部 VFS エラーのために)失敗した場合、SQLite は</target>
        </trans-unit>
        <trans-unit id="7bd0a091025aae3680b1db643d16d28c98cc6e9b" translate="yes" xml:space="preserve">
          <source>If the call to xAccess() required by H35490 reveals that the journal file is no longer present in the file system, then SQLite shall abandon the attempt to open a</source>
          <target state="translated">H35490 で要求された xAccess()の呼び出しにより、ファイルシステム内にジャーナルファイルが存在しなくなったことが判明した場合、SQLite は</target>
        </trans-unit>
        <trans-unit id="3c3c8cf623e8c157f82c9c8bd8de3ce49f6292d0" translate="yes" xml:space="preserve">
          <source>If the call to xCheckReservedLock() required by H35160 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">H35160 で要求された xCheckReservedLock()の呼び出しが (IO またはその他の内部 VFS エラーのために)失敗した場合、SQLite は</target>
        </trans-unit>
        <trans-unit id="527cca95e4fd8fdc84a2ca6b5f00a7e854482d28" translate="yes" xml:space="preserve">
          <source>If the call to xCheckReservedLock() required by H35160 indicates that some other</source>
          <target state="translated">H35160で要求されたxCheckReservedLock()の呼び出しが、他のいくつかの</target>
        </trans-unit>
        <trans-unit id="b6b7e886a7c9cbfdadb1dc23e73d315693f496ee" translate="yes" xml:space="preserve">
          <source>If the call to xDelete() required by H35450 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">H35450 で要求された xDelete()の呼び出しが (IO またはその他の内部 VFS エラーのために)失敗した場合、SQLite は</target>
        </trans-unit>
        <trans-unit id="5af5d373c56bb9dcd62ea184e1e76437bf4a9601" translate="yes" xml:space="preserve">
          <source>If the call to xFileSize() required by H35450 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">H35450 で要求された xFileSize()の呼び出しが (IO またはその他の内部 VFS エラーのために)失敗した場合、SQLite は</target>
        </trans-unit>
        <trans-unit id="2a548d9a4e673897d73f6b03d7eb848a11645c48" translate="yes" xml:space="preserve">
          <source>If the call to xOpen() required by H35440 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">H35440 で要求された xOpen()の呼び出しに失敗した場合 (IO またはその他の内部 VFS エラーが原因)、SQLite は</target>
        </trans-unit>
        <trans-unit id="d1ec650a833c11cb6d8b04d5f0bcc10f45ba6aa9" translate="yes" xml:space="preserve">
          <source>If the callback function returns any value other than SQLITE_OK, the query is abandoned and the xQueryPhrase function returns immediately. If the returned value is SQLITE_DONE, xQueryPhrase returns SQLITE_OK. Otherwise, the error code is propagated upwards.</source>
          <target state="translated">コールバック関数が SQLITE_OK 以外の値を返す場合、クエリは放棄され、xQueryPhrase 関数は直ちに戻ります。返された値が SQLITE_DONE の場合、xQueryPhrase は SQLITE_OK を返します。それ以外の場合は、エラー コードが上方に伝搬されます。</target>
        </trans-unit>
        <trans-unit id="e7031b92fb19c04c6b57152812c2809849a4f000" translate="yes" xml:space="preserve">
          <source>If the callback function to &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; returns non-zero, then sqlite3_exec() will return SQLITE_ABORT.</source>
          <target state="translated">&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec（）&lt;/a&gt;へのコールバック関数がゼロ以外を返す場合、sqlite3_exec（）はSQLITE_ABORTを返します。</target>
        </trans-unit>
        <trans-unit id="a386306ee9feeed2835e0b935d9f3858fdfe7719" translate="yes" xml:space="preserve">
          <source>If the change to table X also affects other tables or indexes or triggers are views within schema, then run &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statements to modify those other tables indexes and views too. For example, if the name of a column changes, all FOREIGN KEY constraints, triggers, indexes, and views that refer to that column must be modified.</source>
          <target state="translated">テーブルXへの変更が他のテーブルまたはインデックスにも影響する場合、またはトリガーがスキーマ内のビューである場合、&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;ステートメントを実行して、他のテーブルインデックスとビューも変更します。たとえば、列の名前が変更された場合、その列を参照するすべてのFOREIGN KEY制約、トリガー、インデックス、およびビューを変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="4f32e1ca273326c7edb692e7f8fb897873c86b6d" translate="yes" xml:space="preserve">
          <source>If the columns of your result set are named by AS clauses, then SQLite is guaranteed to use the identifier to the right of the AS keyword as the column name. If the result set does not use an AS clause, then SQLite is free to name the column anything it wants. See the &lt;a href=&quot;c3ref/column_name&quot;&gt;sqlite3_column_name()&lt;/a&gt; documentation for further information.</source>
          <target state="translated">結果セットの列がAS句によって名前が付けられている場合、SQLiteはASキーワードの右側にある識別子を列名として使用することが保証されています。結果セットがAS句を使用しない場合、SQLiteは自由に列に自由に名前を付けることができます。詳細については、&lt;a href=&quot;c3ref/column_name&quot;&gt;sqlite3_column_name（）の&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="2f6ac289e0c179705fc9860a15b31aba8aa6dfe9" translate="yes" xml:space="preserve">
          <source>If the compression method for the record is either 0 or 8 (see below), then the uncompressed data associated with the zip file entry. Or, if the compression method is not 0 or 8, this column contains a NULL value.</source>
          <target state="translated">レコードの圧縮方法が 0 または 8 のいずれかである場合 (以下を参照)、ZIP ファイルエントリに関連付けられた非圧縮データ。または、圧縮方法が 0 または 8 でない場合、この列には NULL 値が含まれます。</target>
        </trans-unit>
        <trans-unit id="6d7fff8b9b0e80fbe64f6ffbfb79c99106754efa" translate="yes" xml:space="preserve">
          <source>If the content is compressed, then such an &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive&lt;/a&gt; database is &lt;a href=&quot;affcase1#smaller&quot;&gt;the same size&lt;/a&gt; (&amp;plusmn;1%) as an equivalent ZIP archive, and it has the advantage of being able to update individual &quot;files&quot; without rewriting the entire document.</source>
          <target state="translated">コンテンツが圧縮されている場合、そのような&lt;a href=&quot;sqlar&quot;&gt;SQLiteアーカイブ&lt;/a&gt;データベースは同等のZIPアーカイブ&lt;a href=&quot;affcase1#smaller&quot;&gt;と同じサイズ&lt;/a&gt;（&amp;plusmn;1％）であり、ドキュメント全体を書き換えることなく個々の「ファイル」を更新できるという利点があります。</target>
        </trans-unit>
        <trans-unit id="07d4949504c6ebefef1a44e834288b1c17ef2c29" translate="yes" xml:space="preserve">
          <source>If the content of a subquery might need to be visited more than once, then the use of a co-routine is undesirable, as the co-routine would then have to compute the data more than once. And if the subquery cannot be flattened, that means the subquery must be manifested into a transient table.</source>
          <target state="translated">副問い合わせの内容が複数回訪問する必要がある場合、コ・ルーチンの使用は望ましくありません。そして、副問い合わせを平坦化することができない場合、それは副問い合わせが過渡的なテーブルに顕在化しなければならないことを意味します。</target>
        </trans-unit>
        <trans-unit id="c4de8e7a63ccfd940999297f77703800e91edb69" translate="yes" xml:space="preserve">
          <source>If the content option is used along with the languageid option, then the named languageid column must exist in the content= table (subject to the usual rules - if a query never needs to read the content table then this restriction does not apply).</source>
          <target state="translated">content オプションを languageid オプションとともに使用した場合は、 content=テーブルの中に languageid という名前のカラムが存在しなければなりません (通常のルールに従うことになります。 クエリが content テーブルを読む必要がない場合は、この制限は適用されません)。</target>
        </trans-unit>
        <trans-unit id="69c4116a662051610d482a3763e629de02d91b0e" translate="yes" xml:space="preserve">
          <source>If the coroutine that is launched by this instruction ends with &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt; or &lt;a href=&quot;opcode#Return&quot;&gt;Return&lt;/a&gt; then continue to the next instruction. But if the coroutine launched by this instruction ends with &lt;a href=&quot;opcode#EndCoroutine&quot;&gt;EndCoroutine&lt;/a&gt;, then jump to P2 rather than continuing with the next instruction.</source>
          <target state="translated">この命令によって起動されたコルーチンが&lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt;または&lt;a href=&quot;opcode#Return&quot;&gt;Returnで&lt;/a&gt;終了する場合は、次の命令に進みます。ただし、この命令によって起動されたコルーチンが&lt;a href=&quot;opcode#EndCoroutine&quot;&gt;EndCoroutine&lt;/a&gt;で終わっている場合は、次の命令を続行するのではなく、P2にジャンプします。</target>
        </trans-unit>
        <trans-unit id="d90236a26f30bb94fe93491f2ee7d8229a45dcb7" translate="yes" xml:space="preserve">
          <source>If the covering index is used for the scan, the &quot;fruit&quot; column will appear naturally in the correct order, but when there are two or more rows with the same fruit, the price might be out of order. When this occurs, SQLite does many small sorts, one sort for each distinct value of fruit, rather than one large sort. Figure 22 below illustrates the concept.</source>
          <target state="translated">カバーリングインデックスがスキャンに使用されている場合、「果実」列は自然に正しい順序で表示されますが、同じ果実を持つ行が2つ以上ある場合、価格がずれていることがあります。このような場合、SQLiteは大きなソートを行うのではなく、多くの小さなソートを行います。下の図22はその概念を示しています。</target>
        </trans-unit>
        <trans-unit id="9c6f80849dfd69b57ae6014cb409620e08c9388e" translate="yes" xml:space="preserve">
          <source>If the current statement is not inside an explicit transaction (a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;/&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;/&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; block), then an implicit transaction is committed as soon as the statement has finished executing. In this case deferred constraints behave the same as immediate constraints.</source>
          <target state="translated">現在のステートメントが明示的なトランザクション（&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; / &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; / &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;ブロック）内にない場合、暗黙的なトランザクションは、ステートメントの実行が終了するとすぐにコミットされます。この場合、遅延制約は即時制約と同じように動作します。</target>
        </trans-unit>
        <trans-unit id="392488489ea8e86894e96e98c9d528e435e44b99" translate="yes" xml:space="preserve">
          <source>If the current version of SQLite is 3.8.2 or greater, the estimatedRows field may be set to an estimate of the number of rows returned by the proposed query plan. If this value is not explicitly set, the default estimate of 25 rows is used.</source>
          <target state="translated">現在のSQLiteのバージョンが3.8.2以上の場合、推定行数フィールドには、提案されたクエリプランから返される行数の推定値を設定することができます。この値が明示的に設定されていない場合は、デフォルトの推定行数25行が使用されます。</target>
        </trans-unit>
        <trans-unit id="d14a622439a8b842f388bc686b9c68da678476ab" translate="yes" xml:space="preserve">
          <source>If the current version of SQLite is 3.9.0 or greater, the idxFlags field may be set to SQLITE_INDEX_SCAN_UNIQUE to indicate that the virtual table will return only zero or one rows given the input constraints. Additional bits of the idxFlags field might be understood in later versions of SQLite.</source>
          <target state="translated">現在のSQLiteのバージョンが3.9.0以上の場合、idxFlagsフィールドをSQLITE_INDEX_SCAN_UNIQUEに設定することで、入力制約が与えられた場合に仮想テーブルが0行または1行のみを返すことを示すことができます。idxFlags フィールドの追加ビットは、SQLite の後のバージョンでは理解されているかもしれません。</target>
        </trans-unit>
        <trans-unit id="7ead26894e06c87e567f28556505a47feb41761a" translate="yes" xml:space="preserve">
          <source>If the cursor P1 is already opened on an ephemeral table, the table is cleared (all content is erased).</source>
          <target state="translated">カーソルP1が既にエフェメラルテーブル上に開いている場合は、テーブルをクリアする(全ての内容を消去する)。</target>
        </trans-unit>
        <trans-unit id="4895543ee94b53e62d72914bc8c347747fb66179" translate="yes" xml:space="preserve">
          <source>If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this opcode will always land on a record that equally equals the key, or else jump immediately to P2. When the cursor is OPFLAG_SEEKEQ, this opcode must be followed by an &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode with the same arguments. The &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode will be skipped if this opcode succeeds, but the &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode will be used on subsequent loop iterations.</source>
          <target state="translated">カーソルP1がOPFLAG_SEEKEQフラグを使用して開かれた場合、このオペコードは常にキーに等しいレコードに到達するか、そうでなければすぐにP2にジャンプします。カーソルがOPFLAG_SEEKEQの場合、このオペコードの後に、同じ引数を持つ&lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt;オペコードが続く必要があります。&lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGEの&lt;/a&gt;このオペコードが成功した場合、オペコードはスキップされますが、&lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGEの&lt;/a&gt;オペコードは、後続のループの繰り返しで使用されます。</target>
        </trans-unit>
        <trans-unit id="77bb6e8019c4e57a173df053565a659dee60ffeb" translate="yes" xml:space="preserve">
          <source>If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this opcode will always land on a record that equally equals the key, or else jump immediately to P2. When the cursor is OPFLAG_SEEKEQ, this opcode must be followed by an &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode with the same arguments. The &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode will be skipped if this opcode succeeds, but the &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode will be used on subsequent loop iterations.</source>
          <target state="translated">カーソルP1がOPFLAG_SEEKEQフラグを使用して開かれた場合、このオペコードは常にキーに等しいレコードに到達するか、そうでなければすぐにP2にジャンプします。カーソルがOPFLAG_SEEKEQの場合、このオペコードの後に同じ引数を持つ&lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt;オペコードが続く必要があります。&lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLEの&lt;/a&gt;このオペコードが成功した場合、オペコードはスキップされますが、&lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLEの&lt;/a&gt;オペコードは、後続のループの繰り返しで使用されます。</target>
        </trans-unit>
        <trans-unit id="6654fbd1f580e1606c2cb7ef134e0a96bcfe4a7c" translate="yes" xml:space="preserve">
          <source>If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this opcode will either land on a record that exactly matches the key, or else it will cause a jump to P2. When the cursor is OPFLAG_SEEKEQ, this opcode must be followed by an &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode with the same arguments. The &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode will be skipped if this opcode succeeds, but the &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode will be used on subsequent loop iterations. The OPFLAG_SEEKEQ flags is a hint to the btree layer to say that this is an equality search.</source>
          <target state="translated">If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this opcode will either land on a record that exactly matches the key, or else it will cause a jump to P2. When the cursor is OPFLAG_SEEKEQ, this opcode must be followed by an &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode with the same arguments. The &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode will be skipped if this opcode succeeds, but the &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode will be used on subsequent loop iterations. The OPFLAG_SEEKEQ flags is a hint to the btree layer to say that this is an equality search.</target>
        </trans-unit>
        <trans-unit id="a5226a8f5df78028a70c1168477ceda8c9db8705" translate="yes" xml:space="preserve">
          <source>If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this opcode will either land on a record that exactly matches the key, or else it will cause a jump to P2. When the cursor is OPFLAG_SEEKEQ, this opcode must be followed by an &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode with the same arguments. The &lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt; opcode will be skipped if this opcode succeeds, but the &lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt; opcode will be used on subsequent loop iterations. The OPFLAG_SEEKEQ flags is a hint to the btree layer to say that this is an equality search.</source>
          <target state="translated">If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this opcode will either land on a record that exactly matches the key, or else it will cause a jump to P2. When the cursor is OPFLAG_SEEKEQ, this opcode must be followed by an &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode with the same arguments. The &lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt; opcode will be skipped if this opcode succeeds, but the &lt;a href=&quot;opcode#IdxGT&quot;&gt;IdxGT&lt;/a&gt; opcode will be used on subsequent loop iterations. The OPFLAG_SEEKEQ flags is a hint to the btree layer to say that this is an equality search.</target>
        </trans-unit>
        <trans-unit id="9c34174e24836739ad2de38f328a95e6bd8361fd" translate="yes" xml:space="preserve">
          <source>If the database connection is associated with unfinalized prepared statements or unfinished sqlite3_backup objects then sqlite3_close() will leave the database connection open and return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;. If sqlite3_close_v2() is called with unfinalized prepared statements and/or unfinished sqlite3_backups, then the database connection becomes an unusable &quot;zombie&quot; which will automatically be deallocated when the last prepared statement is finalized or the last sqlite3_backup is finished. The sqlite3_close_v2() interface is intended for use with host languages that are garbage collected, and where the order in which destructors are called is arbitrary.</source>
          <target state="translated">データベース接続が未完成の準備済みステートメントまたは未完成のsqlite3_backupオブジェクトに関連付けられている場合、sqlite3_close（）はデータベース接続を開いたままにして&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;を返します。 sqlite3_close_v2（）が未確定の準備済みステートメントや未完了のsqlite3_backupsで呼び出された場合、データベース接続は使用できない「ゾンビ」になり、最後の準備済みステートメントが終了するか、最後のsqlite3_backupが終了すると、自動的に割り当てが解除されます。 sqlite3_close_v2（）インターフェースは、ガベージコレクションされ、デストラクタが呼び出される順序が任意であるホスト言語での使用を目的としています。</target>
        </trans-unit>
        <trans-unit id="6a86fbb2e17cc862733085ba2da83a55d59e3eb0" translate="yes" xml:space="preserve">
          <source>If the database connection is associated with unfinalized prepared statements or unfinished sqlite3_backup objects then sqlite3_close() will leave the database connection open and return &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. If sqlite3_close_v2() is called with unfinalized prepared statements and/or unfinished sqlite3_backups, then the database connection becomes an unusable &quot;zombie&quot; which will automatically be deallocated when the last prepared statement is finalized or the last sqlite3_backup is finished. The sqlite3_close_v2() interface is intended for use with host languages that are garbage collected, and where the order in which destructors are called is arbitrary.</source>
          <target state="translated">データベース接続が未完成の準備済みステートメントまたは未完成のsqlite3_backupオブジェクトに関連付けられている場合、sqlite3_close（）はデータベース接続を開いたままにして&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;を返します。 sqlite3_close_v2（）が未確定の準備済みステートメントや未完了のsqlite3_backupsで呼び出された場合、データベース接続は使用できない「ゾンビ」になり、最後の準備済みステートメントが終了するか、最後のsqlite3_backupが終了すると、自動的に割り当てが解除されます。 sqlite3_close_v2（）インターフェースは、ガベージコレクションされ、デストラクタが呼び出される順序が任意であるホスト言語での使用を目的としています。</target>
        </trans-unit>
        <trans-unit id="fb1362fb98673ef522db1a6a32001f7f2b59540f" translate="yes" xml:space="preserve">
          <source>If the database connection is newly opened, make sure it has read the database schema by preparing then discarding some query against the database, or calling sqlite3_table_column_metadata(), ignoring any errors. This step is only necessary if the application desires to keep the database in WAL mode after the reset if it was in WAL mode before the reset.</source>
          <target state="translated">データベース接続が新たにオープンされた場合、データベースに対するクエリを準備してから破棄するか、エラーを無視してsqlite3_table_column_metadata()を呼び出すことで、データベーススキーマを読み込んだことを確認してください。このステップは、リセット前にWALモードであった場合、アプリケーションがリセット後もWALモードでデータベースを維持したい場合にのみ必要です。</target>
        </trans-unit>
        <trans-unit id="1e3e236bab50bdd2cf247016c21c0818a0ad15df" translate="yes" xml:space="preserve">
          <source>If the database file has aliases (hard or soft links) and the file is opened by a different alias than the one used to create the journal, then the journal will not be found. To avoid this problem, you should not create links to SQLite database files.</source>
          <target state="translated">データベースファイルにエイリアス(ハードリンクまたはソフトリンク)があり、ジャーナルの作成に使用したエイリアスとは異なるエイリアスでファイルを開いた場合、ジャーナルは見つかりません。この問題を回避するには、SQLiteデータベースファイルへのリンクを作成してはいけません。</target>
        </trans-unit>
        <trans-unit id="b5462897225632e86adf2dda0274ca8b010e12de" translate="yes" xml:space="preserve">
          <source>If the database schema changes, instead of returning &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; as it always used to do, &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; will automatically recompile the SQL statement and try to run it again. As many as &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; retries will occur before sqlite3_step() gives up and returns an error.</source>
          <target state="translated">データベーススキーマが変更された場合、いつものように&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_SCHEMA&lt;/a&gt;を返すのではなく、&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;はSQLステートメントを自動的に再コンパイルして、もう一度実行しようとします。sqlite3_step（）が中止してエラーを返す前に、&lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY回の&lt;/a&gt;再試行が発生します。</target>
        </trans-unit>
        <trans-unit id="589bc4cd8d0a621a42dc8c997193ae6380bd4790" translate="yes" xml:space="preserve">
          <source>If the database schema changes, instead of returning &lt;a href=&quot;../rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; as it always used to do, &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; will automatically recompile the SQL statement and try to run it again. As many as &lt;a href=&quot;../compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; retries will occur before sqlite3_step() gives up and returns an error.</source>
          <target state="translated">データベーススキーマが変更された場合、いつものように&lt;a href=&quot;../rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt;を返すのではなく、&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;はSQLステートメントを自動的に再コンパイルして、もう一度実行しようとします。sqlite3_step（）が中止してエラーを返す前に、&lt;a href=&quot;../compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY回の&lt;/a&gt;再試行が発生します。</target>
        </trans-unit>
        <trans-unit id="66c44f3be0c0d8ad85eed52612c2f2c579f73474" translate="yes" xml:space="preserve">
          <source>If the database schema contains foreign key errors that require looking at more than one table definition to identify, then those errors are not detected when the tables are created. Instead, such errors prevent the application from preparing SQL statements that modify the content of the child or parent tables in ways that use the foreign keys. Errors reported when content is changed are &quot;DML errors&quot; and errors reported when the schema is changed are &quot;DDL errors&quot;. So, in other words, misconfigured foreign key constraints that require looking at both the child and parent are DML errors. The English language error message for foreign key DML errors is usually &quot;foreign key mismatch&quot; but can also be &quot;no such table&quot; if the parent table does not exist. Foreign key DML errors are reported if:</source>
          <target state="translated">データベーススキーマに、識別のために複数のテーブル定義を調べる必要がある外部キーエラーが含まれている場合、テーブルが作成されたときにはそれらのエラーは検出されません。その代わり、そのようなエラーは、アプリケーションが外部キーを使用する方法で子テーブルまたは親テーブルの内容を変更するSQL文を準備することを妨げます。コンテンツが変更されたときに報告されるエラーは「DMLエラー」であり、スキーマが変更されたときに報告されるエラーは「DDLエラー」です。つまり、子テーブルと親テーブルの両方を見なければならないような誤った設定の外部キー制約は「DMLエラー」ということになります。外部キーDMLエラーの英語のエラーメッセージは、通常は「外部キーの不一致」ですが、親テーブルが存在しない場合は「そのようなテーブルがない」ということもあります。外部キーDMLエラーは、以下の場合に報告されます。</target>
        </trans-unit>
        <trans-unit id="8302ec0e25c3b92c0aa14eef9d1503f836a94585" translate="yes" xml:space="preserve">
          <source>If the declared type contains the string &quot;INT&quot; then it is assigned INTEGER affinity.</source>
          <target state="translated">宣言された型に文字列 &quot;INT &quot;が含まれている場合は、INTEGER親和性が割り当てられます。</target>
        </trans-unit>
        <trans-unit id="9bb6b49e698e48cc0bb2b3442b91fd7f7d66dd5e" translate="yes" xml:space="preserve">
          <source>If the declared type for a column contains any of the strings &quot;REAL&quot;, &quot;FLOA&quot;, or &quot;DOUB&quot; then the column has REAL affinity.</source>
          <target state="translated">カラムの宣言された型に文字列 &quot;REAL&quot;、&quot;FLOA&quot;、または &quot;DOUB&quot; のいずれかが含まれている場合、そのカラムはREALと親和性を持っています。</target>
        </trans-unit>
        <trans-unit id="f28b903cf6eed2606240e84c579a7053774d3dee" translate="yes" xml:space="preserve">
          <source>If the declared type for a column contains the string &quot;BLOB&quot; or if no type is specified then the column has affinity BLOB.</source>
          <target state="translated">カラムの宣言された型が文字列 &quot;BLOB&quot; を含む場合、または型が指定されていない場合は、カラムはアフィニティ BLOB を持つことになります。</target>
        </trans-unit>
        <trans-unit id="ee88c791daf6e99faa6560e540692aa5bc2c800f" translate="yes" xml:space="preserve">
          <source>If the declared type of the column contains any of the strings &quot;CHAR&quot;, &quot;CLOB&quot;, or &quot;TEXT&quot; then that column has TEXT affinity. Notice that the type VARCHAR contains the string &quot;CHAR&quot; and is thus assigned TEXT affinity.</source>
          <target state="translated">列の宣言された型に文字列 &quot;CHAR&quot;、&quot;CLOB&quot;、または &quot;TEXT&quot; のいずれかが含まれている場合、その列は文字列との親和性を持っています。VARCHAR型には文字列 &quot;CHAR &quot;が含まれているため、そのカラムにはTEXT親和性が割り当てられていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="de0d2c280ce73b7cd6a79e09cb8d9ab5ce1c8380" translate="yes" xml:space="preserve">
          <source>If the default entry point &quot;sqlite3_extension_init&quot; is not present in the loadable extension, also try an entry point &quot;sqlite3_X_init&quot; where &quot;X&quot; is based on the shared library filename. This allows every extension to have a different entry point, which allows them to be statically linked with no code changes.</source>
          <target state="translated">デフォルトのエントリポイント &quot;sqlite3_extension_init &quot;がロード可能な拡張機能に存在しない場合、&quot;X &quot;が共有ライブラリのファイル名に基づいているエントリポイント &quot;sqlite3_X_init &quot;も試してみてください。これにより、すべての拡張機能が異なるエントリポイントを持つことができ、コードを変更せずに静的にリンクすることができます。</target>
        </trans-unit>
        <trans-unit id="2f1570bf7cd89b0efb998b886e0a28b989f79bba" translate="yes" xml:space="preserve">
          <source>If the default value of a column is CURRENT_TIME, CURRENT_DATE or CURRENT_TIMESTAMP, then the value used in the new row is a text representation of the current UTC date and/or time. For CURRENT_TIME, the format of the value is &quot;HH:MM:SS&quot;. For CURRENT_DATE, &quot;YYYY-MM-DD&quot;. The format for CURRENT_TIMESTAMP is &quot;YYYY-MM-DD HH:MM:SS&quot;.</source>
          <target state="translated">列のデフォルト値が CURRENT_TIME、CURRENT_DATE、または CURRENT_TIMESTAMP の場合、新しい行で使用される値は、現在の UTC 日付および/または時刻をテキストで表したものになります。CURRENT_TIMEの場合、値の形式は「HH:MM:SS」です。CURRENT_DATEの場合は、「YYYY-MM-DD」です。CURRENT_TIMESTAMP の場合、値の形式は「YYYY-MM-DD HH:MM:SS」です。</target>
        </trans-unit>
        <trans-unit id="763669d7f38746d95d771edeb8a196a32d9d9e41" translate="yes" xml:space="preserve">
          <source>If the default value of a column is an expression in parentheses, then the expression is evaluated once for each row inserted and the results used in the new row.</source>
          <target state="translated">列のデフォルト値が括弧内の式である場合、その式は挿入された行と新しい行で使用された結果に対して1回評価されます。</target>
        </trans-unit>
        <trans-unit id="f9fe1ed106b11da1d5f4cf451a970a2b10eba0b4" translate="yes" xml:space="preserve">
          <source>If the default value of the column is a constant NULL, text, blob or signed-number value, then that value is used directly in the new row.</source>
          <target state="translated">列のデフォルト値が定数NULL、テキスト、ブロブ、または符号付き数字の値である場合は、その値が新しい行で直接使用されます。</target>
        </trans-unit>
        <trans-unit id="6072ed5efdb78dd0e13242a8b605916b880d7376" translate="yes" xml:space="preserve">
          <source>If the detail option is set to &lt;b&gt;column&lt;/b&gt;, then for each term the FTS index records the rowid and column number only, omitting the term offset information. This results in the following restrictions:</source>
          <target state="translated">詳細オプションが&lt;b&gt;column&lt;/b&gt;に設定されている場合、用語ごとにFTSインデックスはROWIDと列番号のみを記録し、用語のオフセット情報を省略します。これにより、次の制限が発生します。</target>
        </trans-unit>
        <trans-unit id="e6f14be9765a087a59fad069383360a3c524d64a" translate="yes" xml:space="preserve">
          <source>If the detail option is set to &lt;b&gt;none&lt;/b&gt;, then for each term the FTS index records just the rowid is stored. Both column and offset information are omitted. As well as the restrictions itemized above for detail=column mode, this imposes the following extra limitations:</source>
          <target state="translated">詳細オプションが&lt;b&gt;none&lt;/b&gt;に設定されている場合、FTSインデックスレコードごとに、ROWIDのみが保存されます。列とオフセット情報の両方が省略されています。上記のdetail = columnモードで説明した制限に加えて、これにより次の追加の制限が課されます。</target>
        </trans-unit>
        <trans-unit id="c0b004cd1f197d0bb3d8b70f7d3071c3e7d65b08" translate="yes" xml:space="preserve">
          <source>If the file-size is not zero bytes and the page cache does not contain valid data for the first page of the database, then the data for the first page must be read from the database.</source>
          <target state="translated">ファイルサイズがゼロバイトではなく、ページキャッシュがデータベースの最初のページの有効なデータを含んでいない場合、最初のページのデータをデータベースから読み込まなければなりません。</target>
        </trans-unit>
        <trans-unit id="7d40fd66a8466c922e947b1b7af920a75a0b5408" translate="yes" xml:space="preserve">
          <source>If the filename argument to the shell is a ZIP archive rather than an SQLite database, then the shell automatically opens that ZIP archive using the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt;.</source>
          <target state="translated">シェルのファイル名引数がSQLiteデータベースではなくZIPアーカイブである場合、シェルは&lt;a href=&quot;zipfile&quot;&gt;Zipfile仮想テーブル&lt;/a&gt;を使用してそのZIPアーカイブを自動的に開きます。</target>
        </trans-unit>
        <trans-unit id="ae3dbad88e43cb04cd5afd00c461d318a7360e00" translate="yes" xml:space="preserve">
          <source>If the filename is &quot;:memory:&quot;, then a private, temporary in-memory database is created for the connection. This in-memory database will vanish when the database connection is closed. Future versions of SQLite might make use of additional special filenames that begin with the &quot;:&quot; character. It is recommended that when a database filename actually does begin with a &quot;:&quot; character you should prefix the filename with a pathname such as &quot;./&quot; to avoid ambiguity.</source>
          <target state="translated">ファイル名が&quot;:memory:&quot;の場合、接続のためのプライベートな一時的なインメモリデータベースが作成されます。このインメモリデータベースは、データベース接続が閉じられると消滅します。SQLite の将来のバージョンでは、&quot;:&quot; で始まる特殊なファイル名を使用することができるかもしれません。データベースのファイル名が実際に &quot;:&quot; 文字で始まる場合は、曖昧さを避けるためにファイル名の前に &quot;./&quot; のようなパス名を付けることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="62f7e60cb107b276af1d9e468c997800e50e0c47" translate="yes" xml:space="preserve">
          <source>If the filename is an empty string, then a private, temporary on-disk database will be created. This private database will be automatically deleted as soon as the database connection is closed.</source>
          <target state="translated">ファイル名が空文字列の場合は、プライベートで一時的なディスク上のデータベースが作成されます。このプライベートデータベースは、データベース接続が閉じられるとすぐに自動的に削除されます。</target>
        </trans-unit>
        <trans-unit id="e090a4024fb7e0384c6590b18fdaa1dae521998f" translate="yes" xml:space="preserve">
          <source>If the filename pointer returned by this routine is not NULL, then it can be used as the filename input parameter to these routines:</source>
          <target state="translated">このルーチンによって返されたファイル名ポインタがNULLでない場合、それをこれらのルーチンへのファイル名入力パラメータとして使用することができます。</target>
        </trans-unit>
        <trans-unit id="32dd493cb01796f1b19bb91ce938cad16395b6df" translate="yes" xml:space="preserve">
          <source>If the final parameter to sqlite3_create_function_v2() or sqlite3_create_window_function() is not NULL, then it is destructor for the application data pointer. The destructor is invoked when the function is deleted, either by being overloaded or when the database connection closes. The destructor is also invoked if the call to sqlite3_create_function_v2() fails. When the destructor callback is invoked, it is passed a single argument which is a copy of the application data pointer which was the fifth parameter to sqlite3_create_function_v2().</source>
          <target state="translated">sqlite3_create_function_v2()またはsqlite3_create_window_function()の最終パラメータがNULLでない場合、それはアプリケーションデータポインタのデストラクタです。デストラクタは関数が削除されたとき、オーバーロードされたとき、またはデータベース接続が閉じたときに呼び出されます。デストラクタは、sqlite3_create_function_v2()の呼び出しが失敗した場合にも呼び出されます。デストラクタ・コールバックが呼び出されたとき、sqlite3_create_function_v2()の5番目のパラメータであるアプリケーション・データ・ポインタのコピーが1つの引数として渡されます。</target>
        </trans-unit>
        <trans-unit id="a0307f53fcf484b466b65b063fa221cd6f594f91" translate="yes" xml:space="preserve">
          <source>If the first character of the &quot;.output&quot; or &quot;.once&quot; filename is a pipe symbol (&quot;|&quot;) then the remaining characters are treated as a command and the output is sent to that command. This makes it easy to pipe the results of a query into some other process. For example, the &quot;open -f&quot; command on a Mac opens a text editor to display the content that it reads from standard input. So to see the results of a query in a text editor, one could type:</source>
          <target state="translated">.output&quot; または &quot;.once&quot; ファイル名の最初の文字がパイプ記号 (&quot;|&quot;)の場合、残りの文字はコマンドとして扱われ、出力はそのコマンドに送られます。これにより、クエリの結果を他のプロセスにパイプすることが容易になります。例えば、Mac の &quot;open -f&quot; コマンドは、標準入力から読み込んだ内容を表示するためにテキストエディタを開きます。ですから、テキストエディタでクエリの結果を見るには、次のように入力します。</target>
        </trans-unit>
        <trans-unit id="f6248b44ea5d1fc55c81c80463d285a1931abd4d" translate="yes" xml:space="preserve">
          <source>If the flags parameter is non-zero, then the BLOB is opened for read and write access. If the flags parameter is zero, the BLOB is opened for read-only access.</source>
          <target state="translated">flagsパラメータが0以外の場合、BLOBは読み取りおよび書き込みアクセスのためにオープンされます。flagsパラメータが0の場合、BLOBは読み取り専用アクセス用にオープンされます。</target>
        </trans-unit>
        <trans-unit id="42e53a5898ca221d8e5453208404df16340c520e" translate="yes" xml:space="preserve">
          <source>If the frame type is RANGE or GROUPS, then rows with the same values for all ORDER BY expressions are considered &quot;peers&quot;. Or, if there are no ORDER BY terms, all rows are peers. Peers are always within the same frame.</source>
          <target state="translated">フレームタイプがRANGEまたはGROUPSの場合、すべてのORDER BY式で同じ値を持つ行は「ピア」とみなされます。または、ORDER BY式がない場合、すべての行は「ピア」とみなされます。ピアは常に同じフレーム内に存在します。</target>
        </trans-unit>
        <trans-unit id="4aa0a21905f32bbcafa3289b7a629a809ef523ab" translate="yes" xml:space="preserve">
          <source>If the full-text index is consistent with the contents of the table, the INSERT used to invoke the integrity-check command succeeds. Or, if any discrepancy is found, it fails with an &lt;a href=&quot;rescode#corrupt_vtab&quot;&gt;SQLITE_CORRUPT_VTAB&lt;/a&gt; error.</source>
          <target state="translated">フルテキストインデックスがテーブルの内容と一致している場合、整合性チェックコマンドを呼び出すために使用されるINSERTは成功します。または、不一致が見つかった場合、&lt;a href=&quot;rescode#corrupt_vtab&quot;&gt;SQLITE_CORRUPT_VTAB&lt;/a&gt;エラーで失敗します。</target>
        </trans-unit>
        <trans-unit id="f22af0b11cea33d685991d206d7069a56eda1b2e" translate="yes" xml:space="preserve">
          <source>If the function is registered using the sqlite3_collation_needed() API, then it is passed the names of undefined collation sequences as strings encoded in UTF-8. If sqlite3_collation_needed16() is used, the names are passed as UTF-16 in machine native byte order. A call to either function replaces the existing collation-needed callback.</source>
          <target state="translated">sqlite3_collation_needed()APIを使用して関数を登録した場合、未定義の照合順序の名前をUTF-8でエンコードされた文字列として渡します。sqlite3_collation_need16()を使用した場合、名前はマシンネイティブのバイト順でUTF-16として渡されます。いずれかの関数の呼び出しは、既存の照合が必要なコールバックを置き換えます。</target>
        </trans-unit>
        <trans-unit id="6a62bcf0e73dbd9b64d823a84e324e7b03ef33b0" translate="yes" xml:space="preserve">
          <source>If the hard upper bound on mmap_size is non-zero at compilation time, it may still be reduced or zeroed at start-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;,X,Y) interface. The X and Y parameters must both be 64-bit signed integers. The X parameter is the default mmap_size of the process and the Y is the new hard upper bound. The hard upper bound cannot be increased above its compile-time setting using &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt; but it can be reduced or zeroed.</source>
          <target state="translated">mmap_sizeのハード上限がコンパイル時にゼロでない場合でも、&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;、X、Y）インターフェースを使用して、起動時に削減またはゼロ化される可能性があります。XおよびYパラメーターは、両方とも64ビットの符号付き整数でなければなりません。Xパラメータはプロセスのデフォルトのmmap_sizeであり、Yは新しいハード上限です。ハード上限は、&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;を使用してコンパイル時の設定を超えて増やすことはできませんが、減らすかゼロにすることができます。</target>
        </trans-unit>
        <trans-unit id="7e3c788b80a3fc760cf36b37df86e977c5bf4e82" translate="yes" xml:space="preserve">
          <source>If the initial value of register P1 is less than 1, then the value is unchanged and control passes through to the next instruction.</source>
          <target state="translated">レジスタP1の初期値が1未満であれば、その値は変化せず、次の命令に制御が通る。</target>
        </trans-unit>
        <trans-unit id="c6c2836bf573a577c3b9e85be740fd6180f2bc75" translate="yes" xml:space="preserve">
          <source>If the insert operation would cause the uniqueness constraint identified by the conflict-target clause to fail, then the insert is omitted and either the DO NOTHING or DO UPDATE operation is performed instead. In the case of a multi-row insert, this decision is made separately for each row of the insert.</source>
          <target state="translated">挿入操作により、conflict-target節で特定された一意性制約が失敗する場合、挿入は省略され、代わりにDO NOTHINGまたはDO UPDATE操作が実行されます。複数行挿入の場合、この決定は挿入の各行に対して個別に行われます。</target>
        </trans-unit>
        <trans-unit id="94f24cffd74c8aa91288ff50b98f2890c0c1dd37" translate="yes" xml:space="preserve">
          <source>If the integrity_check pragma finds problems, strings are returned (as multiple rows with a single column per row) which describe the problems. Pragma integrity_check will return at most</source>
          <target state="translated">integrity_checkプラグマが問題を発見した場合、問題を記述した文字列が返されます (行ごとに単一のカラムを持つ複数の行として)。プラグマ integrity_check は、最大でも</target>
        </trans-unit>
        <trans-unit id="5cd79e7c31e9806cd77deff0cb0e96d9ab910562" translate="yes" xml:space="preserve">
          <source>If the iterator points to a valid DELETE or UPDATE entry, the &lt;a href=&quot;session/sqlite3changeset_old&quot;&gt;sqlite3changeset_old()&lt;/a&gt; API may be used to obtain the old.* values within the change payload.</source>
          <target state="translated">イテレーターが有効なDELETEまたはUPDATEエントリーを指す場合、&lt;a href=&quot;session/sqlite3changeset_old&quot;&gt;sqlite3changeset_old（）&lt;/a&gt; APIを使用して、変更ペイロード内のold。*値を取得できます。</target>
        </trans-unit>
        <trans-unit id="b3c7141c41f848703cade5e408485ed848edf925" translate="yes" xml:space="preserve">
          <source>If the iterator points to a valid INSERT or UPDATE entry, the &lt;a href=&quot;session/sqlite3changeset_new&quot;&gt;sqlite3changeset_new()&lt;/a&gt; API may be used to obtain the new.* values within the change payload.</source>
          <target state="translated">イテレータが有効なINSERTまたはUPDATEエントリを指す場合、&lt;a href=&quot;session/sqlite3changeset_new&quot;&gt;sqlite3changeset_new（）&lt;/a&gt; APIを使用して、変更ペイロード内のnew。*値を取得できます。</target>
        </trans-unit>
        <trans-unit id="27b2873f49d5b86c6645b602757d6284a617e429" translate="yes" xml:space="preserve">
          <source>If the iterator points to a valid entry, the &lt;a href=&quot;session/sqlite3changeset_op&quot;&gt;sqlite3changeset_op()&lt;/a&gt; API may be used to determine the type of change (INSERT, UPDATE or DELETE) that the iterator points to. Additionally, the same API can be used to obtain the name of the table the change applies to and its expected number of columns and primary key columns.</source>
          <target state="translated">イテレーターが有効なエントリーを指す場合、&lt;a href=&quot;session/sqlite3changeset_op&quot;&gt;sqlite3changeset_op（）&lt;/a&gt; APIを使用して、イテレーターが指す変更のタイプ（INSERT、UPDATE、またはDELETE）を判別できます。さらに、同じAPIを使用して、変更が適用されるテーブルの名前と、列および主キー列の予想される数を取得できます。</target>
        </trans-unit>
        <trans-unit id="b7875cd04c26b022cfa813504a6e1447dc659fda" translate="yes" xml:space="preserve">
          <source>If the join between the target table and the FROM clause results in multiple output rows for the same target table row, then only one of those output rows is used for updating the target table. The output row selected is arbitrary and might change from one release of SQLite to the next, or from one run to the next.</source>
          <target state="translated">ターゲット・テーブルとFROM句の結合の結果、同じターゲット・テーブルの行に対して複数の出力行がある場合、それらの出力行のうちの1つだけがターゲット・テーブルの更新に使用されます。選択される出力行は任意であり、SQLiteのリリースが次のものになったときや、ある実行が次のものになったときに変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="5e43f90e3097e7ba0e1ecf1e86b3e41e586eb695" translate="yes" xml:space="preserve">
          <source>If the join-operator is &quot;CROSS JOIN&quot;, &quot;INNER JOIN&quot;, &quot;JOIN&quot; or a comma (&quot;,&quot;) and there is no ON or USING clause, then the result of the join is simply the cartesian product of the left and right-hand datasets. If join-operator does have ON or USING clauses, those are handled according to the following bullet points:</source>
          <target state="translated">join-operatorが &quot;CROSS JOIN&quot;,&quot;INNER JOIN&quot;,&quot;JOIN&quot;,&quot;JOIN &quot;またはカンマ(&quot;,&quot;)で、ON句やUSING句がない場合、結合の結果は単に左手と右手のデータセットの直交積となります。JOIN演算子にON句やUSING句がある場合、それらは以下の箇条書きに従って処理されます。</target>
        </trans-unit>
        <trans-unit id="e1fb18a5273cd27a264734974f9f02d1710aa767" translate="yes" xml:space="preserve">
          <source>If the join-operator is a &quot;LEFT JOIN&quot; or &quot;LEFT OUTER JOIN&quot;, then after the ON or USING filtering clauses have been applied, an extra row is added to the output for each row in the original left-hand input dataset that corresponds to no rows at all in the composite dataset (if any). The added rows contain NULL values in the columns that would normally contain values copied from the right-hand input dataset.</source>
          <target state="translated">join-operatorが &quot;LEFT JOIN &quot;または &quot;LEFT OUTER JOIN &quot;の場合、ON句またはUSING句のフィルタリングが適用された後、元の左手入力データセットの各行の出力に余分な行が追加され、その行は複合データセットの行が全く存在しないことに対応します(存在する場合)。追加された行には,通常は右手入力データセットからコピーされた値を含むであろう列に NULL 値が含まれる.</target>
        </trans-unit>
        <trans-unit id="76658faf4e1e99248322d20ab1af06451a7269ae" translate="yes" xml:space="preserve">
          <source>If the json_remove(X) function is called with no path arguments, then it returns the input X reformatted, with excess whitespace removed.</source>
          <target state="translated">json_remove(X)関数がパス引数なしで呼ばれた場合は、余分な空白を削除して再フォーマットされた入力 X を返します。</target>
        </trans-unit>
        <trans-unit id="b094bdd6dfc46d4028fcd23aee2c781ab15d0c15" translate="yes" xml:space="preserve">
          <source>If the last client using the database shuts down cleanly by calling &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt;, then a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; is run automatically in order to transfer all information from the wal file over into the main database, and both the shm file and the wal file are unlinked. Thus, when the database is not in use by any client, it is usually the case that only the main database file exists on disk. However, if the last client did not call &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; before it shut down, or if the last client to disconnect was a read-only client, then the final cleanup operation does not occur and the shm and wal files may still exist on disk even when the database is not in use.</source>
          <target state="translated">最後のクライアントが呼び出すことでダウンきれいデータベース閉まりを使用している場合&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_closeを（） &lt;/a&gt;、その後、&lt;a href=&quot;wal#ckpt&quot;&gt;チェックポイントは&lt;/a&gt;、メインデータベースにかけWALファイルからすべての情報を転送するために自動的に実行され、SHMファイルとWALファイルの両方がリンク解除されます。したがって、データベースがどのクライアントでも使用されていない場合、通常は、メインデータベースファイルのみがディスクに存在します。ただし、最後のクライアントがシャットダウンする前に&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close（）を&lt;/a&gt;呼び出さなかった場合、または切断する最後のクライアントが読み取り専用クライアントであった場合、最後のクリーンアップ操作は行われず、ディスク上にshmおよびwalファイルがまだ存在する可能性があります。データベースが使用されていないときでも。</target>
        </trans-unit>
        <trans-unit id="4f7a9d6c2807cb225b7b7ab46b05552f481cc42e" translate="yes" xml:space="preserve">
          <source>If the last connection to a database crashed, then the first new connection to open the database will start a recovery process. An exclusive lock is held during recovery. So if a third database connection tries to jump in and query while the second connection is running recovery, the third connection will get an &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error.</source>
          <target state="translated">データベースへの最後の接続がクラッシュした場合、データベースを開くための最初の新しい接続が回復プロセスを開始します。リカバリー中、排他ロックが保持されます。そのため、2番目の接続が回復を実行しているときに3番目のデータベース接続がジャンプしてクエリを実行しようとすると、3番目の接続で&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="37b7298e57bd67e9cd0305c3baee9cc81b8dbc9d" translate="yes" xml:space="preserve">
          <source>If the lastname and firstname on the bottom row of the previous screen are bound to ?1 and ?2, then the query above computes the next 7 rows. And, assuming there is an appropriate index, it does so very efficiently &amp;mdash; much more efficiently than OFFSET.</source>
          <target state="translated">前の画面の一番下の行の姓と名が？1と？2にバインドされている場合、上記のクエリは次の7行を計算します。そして、適切なインデックスがあると仮定すると、非常に効率的になります&amp;mdash; OFFSETよりもはるかに効率的です。</target>
        </trans-unit>
        <trans-unit id="4e01c1ab95f2a00094ec0341f6411fa5bdba3e3d" translate="yes" xml:space="preserve">
          <source>If the library is not configured for UTF-8 and the Tcl library is one of the newer ones that uses UTF-8 internally, then a conversion from UTF-8 to iso8859 and back again is done inside the TCL interface.</source>
          <target state="translated">ライブラリが UTF-8 用に設定されておらず、Tcl ライブラリが内部的に UTF-8 を使用する新しいものの 1 つである場合、UTF-8 から iso8859 への変換が TCL インターフェイス内で行われ、再び変換されます。</target>
        </trans-unit>
        <trans-unit id="e9f32c50cc50b5c20674f65e05651f4083f0b21f" translate="yes" xml:space="preserve">
          <source>If the locking mode is EXCLUSIVE when first entering &lt;a href=&quot;wal&quot;&gt;WAL journal mode&lt;/a&gt;, then the locking mode cannot be changed to NORMAL until after exiting WAL journal mode. If the locking mode is NORMAL when first entering WAL journal mode, then the locking mode can be changed between NORMAL and EXCLUSIVE and back again at any time and without needing to exit WAL journal mode.</source>
          <target state="translated">最初に&lt;a href=&quot;wal&quot;&gt;WALジャーナルモード&lt;/a&gt;に入るときにロックモードがEXCLUSIVEである場合、WALジャーナルモードを終了するまでロックモードをNORMALに変更できません。最初にWALジャーナルモードに入るときにロックモードがNORMALの場合、WALジャーナルモードを終了せずに、ロックモードをNORMALとEXCLUSIVEの間でいつでも変更できます。</target>
        </trans-unit>
        <trans-unit id="4d5f5f76a7fce4a19ed7250628145b10beef7a78" translate="yes" xml:space="preserve">
          <source>If the matchable phrase in the FTS query is restricted to matching data in a specified FTS table column, then only phrase matches that occur within that column are considered.</source>
          <target state="translated">FTS クエリ内の一致可能なフレーズが、指定された FTS テーブル列内のデータとの一致に制限されている場合、その列内で発生したフレーズの一致のみが考慮されます。</target>
        </trans-unit>
        <trans-unit id="e74ad1dee292520ae801328610398f65c1bd2944" translate="yes" xml:space="preserve">
          <source>If the memory allocation subsystems within SQLite are configured for breakdown-free operation but the actual memory usage exceeds design limits set by the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt;, SQLite will usually continue to operate normally. The &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt; and the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; automatically failover to the &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; general-purpose memory allocator. And it is usually the case that the &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; memory allocator will continue to function without fragmentation even if &lt;b&gt;M&lt;/b&gt; and/or &lt;b&gt;n&lt;/b&gt; exceeds the limits imposed by the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt;. The &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt; shows that it is possible for a memory allocation to break down and fail in this circumstance, but such a failure requires an especially despicable sequence of allocations and deallocations - a sequence that SQLite has never been observed to follow. So in practice it is usually the case that the limits imposed by Robson can be exceeded by a considerable margin with no ill effect.</source>
          <target state="translated">SQLite内のメモリ割り当てサブシステムが故障のない操作用に構成されているが、実際のメモリ使用量が&lt;a href=&quot;malloc#nofrag&quot;&gt;Robson証明&lt;/a&gt;によって設定された設計の制限を超えている場合、SQLiteは通常どおり正常に動作し続けます。&lt;a href=&quot;malloc#pagecache&quot;&gt;ページキャッシュメモリアロケータ&lt;/a&gt;と&lt;a href=&quot;malloc#lookaside&quot;&gt;ルックアサイドメモリアロケータ&lt;/a&gt;自動フェイルオーバに&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;汎用メモリアロケータ。また、&lt;b&gt;M&lt;/b&gt;や&lt;b&gt;n&lt;/b&gt;が&lt;a href=&quot;malloc#nofrag&quot;&gt;Robsonの証明&lt;/a&gt;によって課された制限を超えた場合でも、通常、&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;メモリアロケータは断片化せずに機能し続けます。&lt;a href=&quot;malloc#nofrag&quot;&gt;ロブソンの証拠&lt;/a&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;は、この状況でメモリ割り当てが故障して失敗する可能性があることを示していますが、そのような失敗には、割り当てと割り当て解除の特に目立たないシーケンスが必要です。したがって、実際には、通常、ロブソンによって課された制限は、悪影響を与えることなくかなりのマージンで超えることができます。</target>
        </trans-unit>
        <trans-unit id="ccc13fed0f9a7a53b6beaefda251b5fe55a5b377" translate="yes" xml:space="preserve">
          <source>If the missing function returns an error, then the database is not opened and the error returned to the user. If an openclose function is configured, then a &quot;close&quot; invocation is issued at this point to match the earlier &quot;open&quot;. The following pseudo-code illustrates the procedure used by a swarmvtab instance with both missing and openclose functions configured when a component database is opened.</source>
          <target state="translated">欠落した関数がエラーを返した場合、データベースはオープンされず、そのエラーがユーザに返されます。openclose関数が構成されている場合、この時点で「close」呼び出しが発行され、以前の「open」と一致します。以下の擬似コードは、コンポーネント・データベースがオープンされたときに、欠落関数とopenclose関数の両方が構成されているswarmvtabインスタンスで使用される手順を示しています。</target>
        </trans-unit>
        <trans-unit id="da30913cd33d5b91e0a650b018579fde9dd09c23" translate="yes" xml:space="preserve">
          <source>If the most recent call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt; for the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S indicated an error, then &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; returns an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備されたステートメント&lt;/a&gt; S に対する&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（S）&lt;/a&gt;への最後の呼び出しがエラーを示した場合、&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（S）&lt;/a&gt;は適切な&lt;a href=&quot;rescode&quot;&gt;エラーコードを&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="40013c6ef594b13a3f8340842450df9d33bd6702" translate="yes" xml:space="preserve">
          <source>If the most recent call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt; for the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, or if &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt; has never before been called on S, then &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">最新の呼び出し場合は&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（S）&lt;/a&gt;のために&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備された文&lt;/a&gt; Sが返さ&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;または&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;、または場合&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（S）を&lt;/a&gt;前にSで呼び出されたことがない、そして&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（S）&lt;/a&gt;を返し&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OKを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0cc58a427f7c8746f7e6e3f5425c1b7c73b16876" translate="yes" xml:space="preserve">
          <source>If the most recent call to &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt; for the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S indicated an error, then &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; returns an appropriate &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stmt&quot;&gt;準備されたステートメント&lt;/a&gt; S に対する&lt;a href=&quot;step&quot;&gt;sqlite3_step（S）&lt;/a&gt;への最後の呼び出しがエラーを示した場合、&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（S）&lt;/a&gt;は適切な&lt;a href=&quot;../rescode&quot;&gt;エラーコードを&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="36afaf441091086a1762a1226de0f8218bd283bf" translate="yes" xml:space="preserve">
          <source>If the most recent call to &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt; for the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; or &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, or if &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt; has never before been called on S, then &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">最新の呼び出し場合は&lt;a href=&quot;step&quot;&gt;sqlite3_step（S）&lt;/a&gt;のために&lt;a href=&quot;stmt&quot;&gt;準備された文&lt;/a&gt; Sが返さ&lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;または&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;、または場合&lt;a href=&quot;step&quot;&gt;sqlite3_step（S）を&lt;/a&gt;前にSで呼び出されたことがない、そして&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（S）&lt;/a&gt;を返し&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OKを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bd08063b2d67d7c5aa3fda6b30f29f4f613d2690" translate="yes" xml:space="preserve">
          <source>If the most recent sqlite3_* API call associated with &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D failed, then the sqlite3_errcode(D) interface returns the numeric &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt; or &lt;a href=&quot;rescode#extrc&quot;&gt;extended result code&lt;/a&gt; for that API call. The sqlite3_extended_errcode() interface is the same except that it always returns the &lt;a href=&quot;rescode#extrc&quot;&gt;extended result code&lt;/a&gt; even when extended result codes are disabled.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt; Dに関連付けられた最新のsqlite3_ * API呼び出しが失敗した場合、sqlite3_errcode（D）インターフェースは、そのAPI呼び出しの数値&lt;a href=&quot;rescode&quot;&gt;結果コード&lt;/a&gt;または&lt;a href=&quot;rescode#extrc&quot;&gt;拡張結果コード&lt;/a&gt;を返します。sqlite3_extended_errcode（）インターフェースは同じですが、拡張結果コードが無効になっている場合でも、常に&lt;a href=&quot;rescode#extrc&quot;&gt;拡張結果コードを&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="02b382e95c5f6b3f587125cf8455da646274a1ae" translate="yes" xml:space="preserve">
          <source>If the most recent sqlite3_* API call associated with &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D failed, then the sqlite3_errcode(D) interface returns the numeric &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt; or &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result code&lt;/a&gt; for that API call. The sqlite3_extended_errcode() interface is the same except that it always returns the &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result code&lt;/a&gt; even when extended result codes are disabled.</source>
          <target state="translated">&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt; Dに関連付けられた最新のsqlite3_ * API呼び出しが失敗した場合、sqlite3_errcode（D）インターフェースは、そのAPI呼び出しの数値&lt;a href=&quot;../rescode&quot;&gt;結果コード&lt;/a&gt;または&lt;a href=&quot;../rescode#extrc&quot;&gt;拡張結果コード&lt;/a&gt;を返します。sqlite3_extended_errcode（）インターフェースは同じですが、拡張結果コードが無効になっている場合でも、常に&lt;a href=&quot;../rescode#extrc&quot;&gt;拡張結果コードを&lt;/a&gt;返します。</target>
        </trans-unit>
        <trans-unit id="5550b629f440ed23b3241e812f943180a93fdc19" translate="yes" xml:space="preserve">
          <source>If the nByte argument is negative, then zSql is read up to the first zero terminator. If nByte is positive, then it is the number of bytes read from zSql. If nByte is zero, then no prepared statement is generated. If the caller knows that the supplied string is nul-terminated, then there is a small performance advantage to passing an nByte parameter that is the number of bytes in the input string</source>
          <target state="translated">nByte 引数が負の場合、zSql は最初のゼロ終端まで読み込まれます。nByteが正の場合、それはzSqlから読み出されたバイト数です。nByte がゼロの場合、準備されたステートメントは生成されません。呼び出し側が供給された文字列がヌル終端であることを知っている場合、入力文字列のバイト数である nByte パラメータを渡すことには小さなパフォーマンス上の利点があります。</target>
        </trans-unit>
        <trans-unit id="e34afe39a4a88dd3fd33f4104d3959b3a21962af" translate="yes" xml:space="preserve">
          <source>If the name of the database is an empty string, open a new database in a temporary file that is automatically deleted when the database is closed.</source>
          <target state="translated">データベースの名前が空の文字列の場合は、データベースが閉じられたときに自動的に削除される一時ファイルに新しいデータベースを開きます。</target>
        </trans-unit>
        <trans-unit id="4c3da3e28f6b46a881fb905c79f9b554244037e3" translate="yes" xml:space="preserve">
          <source>If the new changeset contains changes to a table that is already present in the changegroup, then the number of columns and the position of the primary key columns for the table must be consistent. If this is not the case, this function fails with SQLITE_SCHEMA. If the input changeset appears to be corrupt and the corruption is detected, SQLITE_CORRUPT is returned. Or, if an out-of-memory condition occurs during processing, this function returns SQLITE_NOMEM. In all cases, if an error occurs the final contents of the changegroup is undefined.</source>
          <target state="translated">新しいチェンジセットに、すでにチェンジグループに存在するテーブルへの変更が含まれている場合、そのテーブルのカラム数と主キーカラムの位置が一致していなければなりません。そうでない場合、この関数はSQLITE_SCHEMAで失敗します。入力されたチェンジセットが破損しているように見え、破損が検出された場合、SQLITE_CORRUPTが返されます。または、処理中にメモリ切れ状態が発生した場合、この関数はSQLITE_NOMEMを返します。いずれの場合も、エラーが発生した場合、チェンジグループの最終的な内容は未定義となります。</target>
        </trans-unit>
        <trans-unit id="96ca16b2fc66ae0f3d6b77a841fb9c9703e99865" translate="yes" xml:space="preserve">
          <source>If the new changeset contains changes to a table that is already present in the changegroup, then the number of columns and the position of the primary key columns for the table must be consistent. If this is not the case, this function fails with SQLITE_SCHEMA. If the input changeset appears to be corrupt and the corruption is detected, SQLITE_CORRUPT is returned. Or, if an out-of-memory condition occurs during processing, this function returns SQLITE_NOMEM. In all cases, if an error occurs the state of the final contents of the changegroup is undefined.</source>
          <target state="translated">新しいチェンジセットに、すでにチェンジグループに存在するテーブルへの変更が含まれている場合、そのテーブルのカラム数と主キーカラムの位置が一致していなければなりません。そうでない場合、この関数はSQLITE_SCHEMAで失敗します。入力されたチェンジセットが破損しているように見え、破損が検出された場合、SQLITE_CORRUPTが返されます。または、処理中にメモリ切れ状態が発生した場合、この関数はSQLITE_NOMEMを返します。いずれの場合も、エラーが発生した場合、チェンジグループの最終的な内容の状態は未定義です。</target>
        </trans-unit>
        <trans-unit id="27ef56041d2d705e25a721ff1b854e81e350859e" translate="yes" xml:space="preserve">
          <source>If the new limit is a negative number, the limit is unchanged. For each limit category SQLITE_LIMIT_</source>
          <target state="translated">新しい制限が負の数の場合、制限は変更されません。各リミットカテゴリについて SQLITE_LIMIT_LIMIT</target>
        </trans-unit>
        <trans-unit id="dbc989a098eb2be336e5500ea022b41d17fc93aa" translate="yes" xml:space="preserve">
          <source>If the number of output rows is K, then the time needed to sort is proportional to KlogK. If K is small, the sorting time is usually not a factor, but in a query such as the above where K==N, the time needed to sort can be much greater than the time needed to do a full table scan. Furthermore, the entire output is accumulated in temporary storage (which might be either in main memory or on disk, depending on various compile-time and run-time settings) which can mean that a lot of temporary storage is required to complete the query.</source>
          <target state="translated">出力行数がKの場合、ソートに要する時間はKlogKに比例します。Kが小さければ、通常はソート時間は関係ありませんが、上記のようなK==Nのクエリでは、ソートに必要な時間は、テーブル全体のスキャンに必要な時間よりもはるかに大きくなる可能性があります。さらに、出力全体が一時的なストレージに蓄積されます(コンパイル時やランタイムの設定によっては、メインメモリやディスク上に蓄積されることもあります)。</target>
        </trans-unit>
        <trans-unit id="c9314fcd77821589cea840c1fc80043331e7d710" translate="yes" xml:space="preserve">
          <source>If the operating system does not support sleep requests with millisecond time resolution, then the time will be rounded up to the nearest second. The number of milliseconds of sleep actually requested from the operating system is returned.</source>
          <target state="translated">オペレーティングシステムがミリ秒単位の時間分解能を持つスリープ要求をサポートしていない場合、時間は最も近い秒に切り上げられます。オペレーティングシステムから実際に要求されたスリープのミリ秒数が返されます。</target>
        </trans-unit>
        <trans-unit id="13ac5ae90471727393e9b13c70a7b1b4bc52ca60" translate="yes" xml:space="preserve">
          <source>If the operating system returns an I/O error while attempting to obtain a certain lock on shared memory in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; then SQLite might fail to reset its cache, which could lead to database corruption if subsequent writes are attempted.</source>
          <target state="translated">&lt;a href=&quot;wal&quot;&gt;WALモード&lt;/a&gt;で共有メモリの特定のロックを取得しようとしたときにオペレーティングシステムがI / Oエラーを返した場合、SQLiteはキャッシュのリセットに失敗し、その後の書き込みが試行されるとデータベースが破損する可能性があります。</target>
        </trans-unit>
        <trans-unit id="cdf4bb4c410d8ce86d8512a4260a05ff5271bb95" translate="yes" xml:space="preserve">
          <source>If the operation is successful, SQLITE_OK is returned. Otherwise, an SQLite error code. In this case, if argument pzErrMsg is not NULL, *pzErrMsg may be set to point to a buffer containing an English language error message. It is the responsibility of the caller to free this buffer using sqlite3_free().</source>
          <target state="translated">操作が成功した場合、SQLITE_OK が返されます。そうでなければ、SQLite エラーコードが返されます。この場合、引数pzErrMsgがNULLでない場合、*pzErrMsgは英語のエラーメッセージを含むバッファを指すように設定されます。sqlite3_free()を使用してこのバッファを解放するのは呼び出し元の責任です。</target>
        </trans-unit>
        <trans-unit id="387f85a0f9d5d2d59fdee2093a34c406de18ba33" translate="yes" xml:space="preserve">
          <source>If the operation successful, SQLITE_OK is returned. Otherwise, an SQLite error code. In this case, if argument pzErrMsg is not NULL, *pzErrMsg may be set to point to a buffer containing an English language error message. It is the responsibility of the caller to free this buffer using sqlite3_free().</source>
          <target state="translated">操作が成功した場合、SQLITE_OK が返されます。そうでなければ、SQLite エラーコードが返されます。この場合、引数pzErrMsgがNULLでない場合、*pzErrMsgは英語のエラーメッセージを含むバッファを指すように設定されます。sqlite3_free()を使用してこのバッファを解放するのは呼び出し元の責任です。</target>
        </trans-unit>
        <trans-unit id="64ab9d2da26c1826cadd00ea1395a9af67e21893" translate="yes" xml:space="preserve">
          <source>If the optional ESCAPE clause is present, then the expression following the ESCAPE keyword must evaluate to a string consisting of a single character. This character may be used in the LIKE pattern to include literal percent or underscore characters. The escape character followed by a percent symbol (%), underscore (_), or a second instance of the escape character itself matches a literal percent symbol, underscore, or a single escape character, respectively.</source>
          <target state="translated">オプションの ESCAPE 節がある場合、ESCAPE キーワードに続く式は、1 つの文字からなる文字列として評価する必要があります。この文字は、リテラルのパーセント文字やアンダースコア文字を含むように LIKE パターンで使用することができます。パーセント記号 (%)、アンダースコア (_)、またはエスケープ文字の 2 番目のインスタンスが続くエスケープ文字は、それぞれリテラルのパーセント記号、アンダースコア、または単一のエスケープ文字にマッチします。</target>
        </trans-unit>
        <trans-unit id="3874cddaea0653331a0794c8eb1dd76401bd55b2" translate="yes" xml:space="preserve">
          <source>If the optional IF NOT EXISTS clause is present and another index with the same name already exists, then this command becomes a no-op.</source>
          <target state="translated">オプションのIF NOT EXISTS句が存在し、同名の別のインデックスが既に存在する場合、このコマンドは実行不可能になります。</target>
        </trans-unit>
        <trans-unit id="65cace3a0d2d4d6370079a8ce7f587fee8e20bbc" translate="yes" xml:space="preserve">
          <source>If the outer query is an aggregate, then the subquery may not contain ORDER BY.</source>
          <target state="translated">外部クエリが集約である場合、サブクエリはORDER BYを含んではいけません。</target>
        </trans-unit>
        <trans-unit id="0b950d8e0107ea7fe292918a7624ecc4c5105550" translate="yes" xml:space="preserve">
          <source>If the outer query is part of a compound select, then the subquery may not have a LIMIT clause.</source>
          <target state="translated">外部クエリが複合セレクトの一部である場合、サブクエリはLIMIT句を持たないことがあります。</target>
        </trans-unit>
        <trans-unit id="9ec4e583fb2aac08c6ef7929f12a08ccd0d23acd" translate="yes" xml:space="preserve">
          <source>If the output parameters (ppRebase) and (pnRebase) are non-NULL and the input is a changeset (not a patchset), then sqlite3changeset_apply_v2() may set (*ppRebase) to point to a &quot;rebase&quot; that may be used with the sqlite3_rebaser APIs buffer before returning. In this case (*pnRebase) is set to the size of the buffer in bytes. It is the responsibility of the caller to eventually free any such buffer using sqlite3_free(). The buffer is only allocated and populated if one or more conflicts were encountered while applying the patchset. See comments surrounding the sqlite3_rebaser APIs for further details.</source>
          <target state="translated">出力パラメータ(ppRebase)と(pnRebase)がNULLではなく、入力がチェンジセット(パッチセットではない)の場合、sqlite3changeset_apply_v2()は(*ppRebase)に、返す前にsqlite3_rebaser APIsバッファで使用される &quot;リベース &quot;を指すように設定することができます。この場合、(*pnRebase)はバッファのサイズをバイト単位で設定します。最終的にsqlite3_free()を使ってそのようなバッファを解放するのは呼び出し元の責任です。バッファは、パッチセットの適用中に1つ以上の競合が発生した場合にのみ確保され、生成されます。詳細はsqlite3_rebaser APIを取り巻くコメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="e9ff399a5e615a33dc8fa9681024351734065387" translate="yes" xml:space="preserve">
          <source>If the parameter is a positive value, B-tree structures are only eligible for merging if one of the following is true:</source>
          <target state="translated">パラメータが正の値の場合、B-tree構造は、以下のいずれかが真の場合にのみマージの対象となります。</target>
        </trans-unit>
        <trans-unit id="60b6cd8e8d3dd19980d55457d739967fca11e05a" translate="yes" xml:space="preserve">
          <source>If the parameter is named, then its name appears in P4. The P4 value is used by sqlite3_bind_parameter_name().</source>
          <target state="translated">パラメータに名前が付けられている場合は、その名前がP4に表示されます。P4の値はsqlite3_bind_parameter_name()によって使用されます。</target>
        </trans-unit>
        <trans-unit id="b51f3bd8d197cc75de48b64a5587d9918566615a" translate="yes" xml:space="preserve">
          <source>If the parameter is negative, and there are B-tree structures on more than one level within the FTS index, all B-tree structures are assigned to the same level before the merge operation is commenced. Additionally, if the parameter is negative, the value of the usermerge configuration option is not respected - as few as two b-trees from the same level may be merged together.</source>
          <target state="translated">パラメータが負の値で、FTS インデックス内に複数のレベルに B-tree 構造がある場合、マージ操作を開始する前に、すべての B-tree 構造が同じレベルに割り当てられます。さらに、パラメータが負の値の場合、usermerge設定オプションの値は尊重されません。</target>
        </trans-unit>
        <trans-unit id="ff1e8b8711836cc88e8f7bc11a03808c27d6ff91" translate="yes" xml:space="preserve">
          <source>If the paths are sorted using the BINARY collation sequence, then the overflow pages associated with a cell will appear earlier in the sort-order than its child page:</source>
          <target state="translated">パスが BINARY 照合順序を用いてソートされている場合、セルに関連付けられたオーバーフローページは、その子ページよりもソート順の方が早く表示されます。</target>
        </trans-unit>
        <trans-unit id="e58cd97227118f50b919227b576a1a6d96943367" translate="yes" xml:space="preserve">
          <source>If the process that wants to write is unable to obtain a RESERVED lock, it must mean that another process already has a RESERVED lock. In that case, the write attempt fails and returns SQLITE_BUSY.</source>
          <target state="translated">書き込もうとするプロセスがRESERVEDEDロックを取得できない場合、別のプロセスがすでにRESERVEDロックを持っていることを意味しなければなりません。その場合、書き込みの試みは失敗し、SQLITE_BUSY を返します。</target>
        </trans-unit>
        <trans-unit id="406129ab5d2092b3ea22acba195d09ec62e01cc6" translate="yes" xml:space="preserve">
          <source>If the progress callback returns non-zero, the operation is interrupted. This feature can be used to implement a &quot;Cancel&quot; button on a GUI progress dialog box.</source>
          <target state="translated">プログレスコールバックがゼロ以外の値を返した場合、操作は中断されます。この機能は、GUIのプログレス・ダイアログ・ボックスに &quot;キャンセル &quot;ボタンを実装するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="ab297d564d935b4268428b382c93fe0d78c1a7ca" translate="yes" xml:space="preserve">
          <source>If the query contains an ORDER BY clause or a GROUP BY clause or if the query uses the DISTINCT keyword then it is advantageous to select a path through the graph that causes rows to naturally appear in sorted order, so that no separate sorting step is required. Automatic elimination of ORDER BY clauses can make a large performance difference, so this is another factor that needs to be considered in a complete implementation.</source>
          <target state="translated">クエリにORDER BY句やGROUP BY句が含まれている場合や、クエリがDISTINCTキーワードを使用している場合は、グラフを通過するパスを選択して、行が自然にソートされた順序で表示されるようにして、別のソートステップを必要としないようにするのが有利です。ORDER BY句を自動的に排除することで、パフォーマンスに大きな差が出る可能性があるので、これも完全な実装において考慮する必要がある要素です。</target>
        </trans-unit>
        <trans-unit id="4359b51a903396b955ce1a84240a1385d5c4cd97" translate="yes" xml:space="preserve">
          <source>If the query runs to completion without incident, SQLITE_OK is returned. Or, if some error occurs before the query completes or is aborted by the callback, an SQLite error code is returned.</source>
          <target state="translated">クエリが何事もなく完了するまで実行された場合、SQLITE_OK が返されます。あるいは、クエリが完了する前に何らかのエラーが発生したり、コールバックによって中断されたりした場合は、SQLite のエラーコードが返されます。</target>
        </trans-unit>
        <trans-unit id="78d49d24ce74dae451d0ef728d6bf465dbd467e9" translate="yes" xml:space="preserve">
          <source>If the reason for writing to the database file is because the memory cache was full, then the writer will not commit right away. Instead, the writer might continue to make changes to other pages. Before subsequent changes are written to the database file, the rollback journal must be flushed to disk again. Note also that the EXCLUSIVE lock that the writer obtained in order to write to the database initially must be held until all changes are committed. That means that no other processes are able to access the database from the time the memory cache first spills to disk until the transaction commits.</source>
          <target state="translated">データベースファイルへの書き込みの理由がメモリキャッシュが一杯だったからだとしたら、ライターはすぐにはコミットしません。その代わり、ライターは他のページに変更を加え続けるかもしれません。後続の変更がデータベースファイルに書き込まれる前に、ロールバックジャーナルを再びディスクにフラッシュする必要があります。また、ライターがデータベースに書き込むために最初に取得したEXCLUSIVEロックは、すべての変更がコミットされるまで保持されなければならないことにも注意してください。つまり、メモリキャッシュが最初にディスクに流出してからトランザクションがコミットされるまで、他のプロセスはデータベースにアクセスできないということです。</target>
        </trans-unit>
        <trans-unit id="f4de1a28535def0f53f335b0aa1ec084bfb958b6" translate="yes" xml:space="preserve">
          <source>If the record contains fewer than P2 fields, then extract a NULL. Or, if the P4 argument is a P4_MEM use the value of the P4 argument as the result.</source>
          <target state="translated">レコードに含まれるフィールドがP2よりも少ない場合は、NULLを抽出します。または、P4引数がP4_MEMの場合は、P4引数の値を結果として使用します。</target>
        </trans-unit>
        <trans-unit id="a233c4347f5d21c12355351382fcf901413d7e49" translate="yes" xml:space="preserve">
          <source>If the recovered database schema already contains a table named &quot;lost_and_found&quot;, the &quot;.recover&quot; command uses the name &quot;lost_and_found0&quot;. If the name &quot;lost_and_found0&quot; is also already taken, &quot;lost_and_found1&quot;, and so on. The default name &quot;lost_and_found&quot; may be overridden by invoking &quot;.recover&quot; with the --lost-and-found switch. For example, to have the output script call the table &quot;orphaned_rows&quot;:</source>
          <target state="translated">回復したデータベーススキーマに「lost_and_found」という名前のテーブルが既にある場合、「.recover」コマンドは「lost_and_found0」という名前を使用します。lost_and_found0」という名前も既に取られている場合は、「lost_and_found1」などとなります。デフォルトの名前「lost_and_found」は、--lost-and-foundスイッチで「.recover」を呼び出すことで上書きすることができる。例えば、出力スクリプトがテーブル &quot;orphaned_rows &quot;を呼び出すようにするには、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="872cffdf6d4bf05d01de18a6904e492aef161446" translate="yes" xml:space="preserve">
          <source>If the requested page is already in the page cache, then the page cache implementation must return a pointer to the page buffer with its content intact. If the requested page is not already in the cache, then the cache implementation should use the value of the createFlag parameter to help it determined what action to take:</source>
          <target state="translated">要求されたページが既にページキャッシュ内にある場合,ページキャッシュの実装は内容がそのままの状態でページバッファへのポインタを返さなければなりません.要求されたページが既にキャッシュにない場合,キャッシュの実装は createFlag パラメータの値を使用して,どのようなアクションを取るべきかを決定するのに役立ちます.</target>
        </trans-unit>
        <trans-unit id="db0bc69173aefab4964d855c64d49581690da543" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or UTF-16 string then the sqlite3_column_bytes16() routine returns the number of bytes in that BLOB or string. If the result is a UTF-8 string, then sqlite3_column_bytes16() converts the string to UTF-16 and then returns the number of bytes. If the result is a numeric value then sqlite3_column_bytes16() uses &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to convert that value to a UTF-16 string and returns the number of bytes in that string. If the result is NULL, then sqlite3_column_bytes16() returns zero.</source>
          <target state="translated">結果がBLOBまたはUTF-16文字列の場合、sqlite3_column_bytes16（）ルーチンはそのBLOBまたは文字列のバイト数を返します。結果がUTF-8文字列の場合、sqlite3_column_bytes16（）は文字列をUTF-16に変換し、バイト数を返します。結果が数値の場合、sqlite3_column_bytes16（）は&lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;を使用してその値をUTF-16文字列に変換し、その文字列のバイト数を返します。結果がNULLの場合、sqlite3_column_bytes16（）はゼロを返します。</target>
        </trans-unit>
        <trans-unit id="3b44d7bd1746ffad7cf756ce26aeea67c4d49e66" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or UTF-16 string then the sqlite3_column_bytes16() routine returns the number of bytes in that BLOB or string. If the result is a UTF-8 string, then sqlite3_column_bytes16() converts the string to UTF-16 and then returns the number of bytes. If the result is a numeric value then sqlite3_column_bytes16() uses &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to convert that value to a UTF-16 string and returns the number of bytes in that string. If the result is NULL, then sqlite3_column_bytes16() returns zero.</source>
          <target state="translated">結果がBLOBまたはUTF-16文字列の場合、sqlite3_column_bytes16（）ルーチンはそのBLOBまたは文字列のバイト数を返します。結果がUTF-8文字列の場合、sqlite3_column_bytes16（）は文字列をUTF-16に変換し、バイト数を返します。結果が数値の場合、sqlite3_column_bytes16（）は&lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;を使用してその値をUTF-16文字列に変換し、その文字列のバイト数を返します。結果がNULLの場合、sqlite3_column_bytes16（）はゼロを返します。</target>
        </trans-unit>
        <trans-unit id="5a04fb4ab27b4007fb1a3789b739c65a862ccba9" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or UTF-8 string then the sqlite3_column_bytes() routine returns the number of bytes in that BLOB or string. If the result is a UTF-16 string, then sqlite3_column_bytes() converts the string to UTF-8 and then returns the number of bytes. If the result is a numeric value then sqlite3_column_bytes() uses &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to convert that value to a UTF-8 string and returns the number of bytes in that string. If the result is NULL, then sqlite3_column_bytes() returns zero.</source>
          <target state="translated">結果がBLOBまたはUTF-8文字列の場合、sqlite3_column_bytes（）ルーチンはそのBLOBまたは文字列のバイト数を返します。結果がUTF-16文字列の場合、sqlite3_column_bytes（）は文字列をUTF-8に変換し、バイト数を返します。結果が数値の場合、sqlite3_column_bytes（）は&lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;を使用してその値をUTF-8文字列に変換し、その文字列のバイト数を返します。結果がNULLの場合、sqlite3_column_bytes（）はゼロを返します。</target>
        </trans-unit>
        <trans-unit id="97aa0401915ee07da3fcfb4b2dd9b95ffff68377" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or UTF-8 string then the sqlite3_column_bytes() routine returns the number of bytes in that BLOB or string. If the result is a UTF-16 string, then sqlite3_column_bytes() converts the string to UTF-8 and then returns the number of bytes. If the result is a numeric value then sqlite3_column_bytes() uses &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to convert that value to a UTF-8 string and returns the number of bytes in that string. If the result is NULL, then sqlite3_column_bytes() returns zero.</source>
          <target state="translated">結果がBLOBまたはUTF-8文字列の場合、sqlite3_column_bytes（）ルーチンはそのBLOBまたは文字列のバイト数を返します。結果がUTF-16文字列の場合、sqlite3_column_bytes（）は文字列をUTF-8に変換し、バイト数を返します。結果が数値の場合、sqlite3_column_bytes（）は&lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf（）&lt;/a&gt;を使用してその値をUTF-8文字列に変換し、その文字列のバイト数を返します。結果がNULLの場合、sqlite3_column_bytes（）はゼロを返します。</target>
        </trans-unit>
        <trans-unit id="cce95bf5c0bc98e89e8fc40f80872857badf8433" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or a TEXT string, then the sqlite3_column_bytes() or sqlite3_column_bytes16() interfaces can be used to determine the size of that BLOB or string.</source>
          <target state="translated">結果がBLOBまたはテキスト文字列の場合、sqlite3_column_bytes()またはsqlite3_column_bytes16()インターフェースを使用して、そのBLOBまたは文字列のサイズを決定することができます。</target>
        </trans-unit>
        <trans-unit id="fd9c1a162239f42f97865bf762c6375eed8fe6fe" translate="yes" xml:space="preserve">
          <source>If the result is a general expression, not a just the name of a source table column, then the name of the result is a copy of the expression text.</source>
          <target state="translated">結果が単なるソーステーブルのカラム名ではなく、一般的な式である場合、結果の名前は式のテキストのコピーになります。</target>
        </trans-unit>
        <trans-unit id="57f0dbb6f6834911f1360c14b63d681228556516" translate="yes" xml:space="preserve">
          <source>If the result set of a query is empty, then by default &lt;b&gt;sqlite_get_table&lt;/b&gt; will set nrow to 0 and leave its result parameter is set to NULL. But if the EMPTY_RESULT_CALLBACKS pragma is ON then the result parameter is initialized to the names of the columns only. For example, consider this query which has an empty result set:</source>
          <target state="translated">クエリの結果セットが空の場合、デフォルトでは&lt;b&gt;sqlite_get_table&lt;/b&gt;はnrowを0に設定し、その結果パラメーターをNULLに設定したままにします。ただし、EMPTY_RESULT_CALLBACKSプラグマがONの場合、結果パラメーターは列の名前のみに初期化されます。たとえば、空の結果セットを持つ次のクエリを考えてみます。</target>
        </trans-unit>
        <trans-unit id="d816ce55af3aa1bc324149c293eb2742dfc0c53d" translate="yes" xml:space="preserve">
          <source>If the right-hand side of an IN operator can be list of values as in the following:</source>
          <target state="translated">IN演算子の右辺が以下のように値のリスト化が可能な場合。</target>
        </trans-unit>
        <trans-unit id="b287ebc787ae1fe1352a6696e98abccff05e37e6" translate="yes" xml:space="preserve">
          <source>If the row comes from a WITHOUT ROWID table, this column contains NULL. Otherwise, it contains the 64-bit integer rowid value for the row.</source>
          <target state="translated">行が WITHOUT ROWID テーブルから来ている場合、この列には NULL が含まれます。そうでない場合は、その行の64ビット整数のROWID値が含まれます。</target>
        </trans-unit>
        <trans-unit id="489be44720b2f1c706095444d825988cba31b9db" translate="yes" xml:space="preserve">
          <source>If the row that a BLOB handle points to is modified by an &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt;, or by &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; side-effects then the BLOB handle is marked as &quot;expired&quot;. This is true if any column of the row is changed, even a column other than the one the BLOB handle is open on. Calls to &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; and &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; for an expired BLOB handle fail with a return code of &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;. Changes written into a BLOB prior to the BLOB expiring are not rolled back by the expiration of the BLOB. Such changes will eventually commit if the transaction continues to completion.</source>
          <target state="translated">BLOBハンドルが指す行が&lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt;、&lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt;、または&lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;の副作用によって変更された場合、BLOBハンドルは「期限切れ」としてマークされます。これは、行のいずれかの列が変更された場合に当てはまります。BLOBハンドルが開いている列以外の列も変更されます。期限切れのBLOBハンドルに対する&lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;および&lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write（）の&lt;/a&gt;呼び出しは、&lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORTの&lt;/a&gt;戻りコードで失敗します。 BLOBが期限切れになる前にBLOBに書き込まれた変更は、BLOBの期限切れによってロールバックされません。そのような変更は、トランザクションが完了し続けると、最終的にコミットされます。</target>
        </trans-unit>
        <trans-unit id="855918a93d6aa4472f75825b61dee9d03ea7eab1" translate="yes" xml:space="preserve">
          <source>If the row that a BLOB handle points to is modified by an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, or by &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; side-effects then the BLOB handle is marked as &quot;expired&quot;. This is true if any column of the row is changed, even a column other than the one the BLOB handle is open on. Calls to &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; for an expired BLOB handle fail with a return code of &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt;. Changes written into a BLOB prior to the BLOB expiring are not rolled back by the expiration of the BLOB. Such changes will eventually commit if the transaction continues to completion.</source>
          <target state="translated">BLOBハンドルが指す行が&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;、&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;、または&lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt;の副作用によって変更された場合、BLOBハンドルは「期限切れ」としてマークされます。これは、行のいずれかの列が変更された場合に当てはまります。BLOBハンドルが開いている列以外の列も変更されます。期限切れのBLOBハンドルに対する&lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;および&lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write（）の&lt;/a&gt;呼び出しは、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORTの&lt;/a&gt;戻りコードで失敗します。 BLOBが期限切れになる前にBLOBに書き込まれた変更は、BLOBの期限切れによってロールバックされません。そのような変更は、トランザクションが完了し続けると、最終的にコミットされます。</target>
        </trans-unit>
        <trans-unit id="5ad667b790a078db1e6c6968fc928120e549e94b" translate="yes" xml:space="preserve">
          <source>If the same database is being read and written using two different &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; (two different &lt;a href=&quot;c3ref/sqlite3&quot;&gt;sqlite3&lt;/a&gt; objects returned by separate calls to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;) and the two database connections do not have a &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt;, then the reader is only able to see complete committed transactions from the writer. Partial changes by the writer that have not been committed are invisible to the reader. This is true regardless of whether the two database connections are in the same thread, in different threads of the same process, or in different processes. This is the usual and expected behavior for SQL database systems.</source>
          <target state="translated">同じデータベースが2つの異なる&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;（&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;への個別の呼び出しによって返される2つの異なる&lt;a href=&quot;c3ref/sqlite3&quot;&gt;sqlite3&lt;/a&gt;オブジェクト）を使用して読み書きされており、2つのデータベース接続が&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュ&lt;/a&gt;を持たない場合、リーダーは完全なコミットのみを確認できます作家からのトランザクション。コミットされていないライターによる部分的な変更は、リーダーには見えません。これは、2つのデータベース接続が同じスレッドにあるか、同じプロセスの異なるスレッドにあるか、または異なるプロセスにあるかに関係なく当てはまります。これは、SQLデータベースシステムの通常の予想される動作です。</target>
        </trans-unit>
        <trans-unit id="2e0132de71fd47828befdd8cddea786393211a76" translate="yes" xml:space="preserve">
          <source>If the savepoint-name in a RELEASE command does not match any savepoint currently in the transaction stack, then no savepoints are released, the database is unchanged, and the RELEASE command returns an error.</source>
          <target state="translated">RELEASEコマンドのsaveepoint-nameが、現在トランザクションスタックにあるどのsaveepointとも一致しない場合、saveepointは解放されず、データベースは変更されず、RELEASEコマンドはエラーを返します。</target>
        </trans-unit>
        <trans-unit id="0e8e411b07fe2c001323f612676b1abf9cd50210" translate="yes" xml:space="preserve">
          <source>If the second parameter (zDbName) does not match the name of any open database file, then SQLITE_ERROR is returned. This error code is not remembered and will not be recalled by &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;. The underlying xFileControl method might also return SQLITE_ERROR. There is no way to distinguish between an incorrect zDbName and an SQLITE_ERROR return from the underlying xFileControl method.</source>
          <target state="translated">2番目のパラメーター（zDbName）が開いているデータベースファイルの名前と一致しない場合、SQLITE_ERRORが返されます。このエラーコードは記憶されておらず、&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;または&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;によって呼び出されません。基になるxFileControlメソッドもSQLITE_ERRORを返す場合があります。不正なzDbNameと、基になるxFileControlメソッドからのSQLITE_ERROR戻りを区別する方法はありません。</target>
        </trans-unit>
        <trans-unit id="0a6c4ada949c40cb1aa6d07b25694fd6c11c1796" translate="yes" xml:space="preserve">
          <source>If the second parameter (zDbName) does not match the name of any open database file, then SQLITE_ERROR is returned. This error code is not remembered and will not be recalled by &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; or &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;. The underlying xFileControl method might also return SQLITE_ERROR. There is no way to distinguish between an incorrect zDbName and an SQLITE_ERROR return from the underlying xFileControl method.</source>
          <target state="translated">2番目のパラメーター（zDbName）が開いているデータベースファイルの名前と一致しない場合、SQLITE_ERRORが返されます。このエラーコードは記憶されておらず、&lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;または&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;によって呼び出されません。基になるxFileControlメソッドもSQLITE_ERRORを返す場合があります。不正なzDbNameと、基になるxFileControlメソッドからのSQLITE_ERROR戻りを区別する方法はありません。</target>
        </trans-unit>
        <trans-unit id="b78c0101bf92e2df502819dbd3877a0d27dbb142" translate="yes" xml:space="preserve">
          <source>If the size of a potentially hot journal file is revealed to be greater than zero bytes by a query required by H35450, then SQLite shall attempt to upgrade the</source>
          <target state="translated">H35450で要求されているクエリにより、ホットになる可能性のあるジャーナルファイルのサイズがゼロバイトよりも大きいことが判明した場合、SQLiteは</target>
        </trans-unit>
        <trans-unit id="84a94aa97953d8f31911d07edfb705a8ac22630d" translate="yes" xml:space="preserve">
          <source>If the size of a potentially hot journal file is revealed to be zero bytes by a query required by H35450, then SQLite shall close the file handle opened on the journal file and delete the journal file using a call to the VFS xDelete() method. In this case SQLite shall conclude that there is no</source>
          <target state="translated">H35450 で要求されたクエリにより、ホットになる可能性のあるジャーナル・ファイルのサイズがゼロバイトであることが判明した場合、SQLite は、ジャーナル・ファイルで開かれたファイル・ハンドルを閉じ、VFS の xDelete()メソッドの呼び出しを使用してジャーナル・ファイルを削除するものとする。この場合、SQLite は、ジャーナル・ファイルには</target>
        </trans-unit>
        <trans-unit id="8775f72effd63665f56849704eebc4e3eb03a777" translate="yes" xml:space="preserve">
          <source>If the specific value bound to &lt;a href=&quot;../lang_expr#varparam&quot;&gt;host parameter&lt;/a&gt; in the WHERE clause might influence the choice of query plan for a statement, then the statement will be automatically recompiled, as if there had been a schema change, on the first &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call following any change to the &lt;a href=&quot;bind_blob&quot;&gt;bindings&lt;/a&gt; of that &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt;. The specific value of WHERE-clause &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; might influence the choice of query plan if the parameter is the left-hand side of a &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator or if the parameter is compared to an indexed column and the &lt;a href=&quot;../compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">WHERE句の&lt;a href=&quot;../lang_expr#varparam&quot;&gt;ホストパラメータ&lt;/a&gt;にバインドされた特定の値がステートメントのクエリプランの選択に影響を与える可能性がある場合、スキーマ変更があったかのように、変更後の最初の&lt;a href=&quot;step&quot;&gt;sqlite3_step（）&lt;/a&gt;呼び出しでステートメントが自動的に再コンパイルされます。その&lt;a href=&quot;../lang_expr#varparam&quot;&gt;パラメータ&lt;/a&gt;の&lt;a href=&quot;bind_blob&quot;&gt;バインディング&lt;/a&gt;に。 WHERE節&lt;a href=&quot;../lang_expr#varparam&quot;&gt;パラメーター&lt;/a&gt;の特定の値は、パラメーターが&lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt;または&lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;演算子の左側である場合、またはパラメーターがインデックス付き列と比較され、&lt;a href=&quot;../compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;コンパイル時オプションが有効になっている場合、クエリプランの選択に影響を与える可能性があります。</target>
        </trans-unit>
        <trans-unit id="44b5aede3751869315efb1ad0c6228b799d6377d" translate="yes" xml:space="preserve">
          <source>If the specific value bound to &lt;a href=&quot;lang_expr#varparam&quot;&gt;host parameter&lt;/a&gt; in the WHERE clause might influence the choice of query plan for a statement, then the statement will be automatically recompiled, as if there had been a schema change, on the first &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call following any change to the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;bindings&lt;/a&gt; of that &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt;. The specific value of WHERE-clause &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; might influence the choice of query plan if the parameter is the left-hand side of a &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator or if the parameter is compared to an indexed column and the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">WHERE句の&lt;a href=&quot;lang_expr#varparam&quot;&gt;ホストパラメータ&lt;/a&gt;にバインドされた特定の値がステートメントのクエリプランの選択に影響を与える可能性がある場合、スキーマ変更があったかのように、変更後の最初の&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step（）&lt;/a&gt;呼び出しでステートメントが自動的に再コンパイルされます。その&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメータ&lt;/a&gt;の&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;バインディング&lt;/a&gt;に。 WHERE節&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメーター&lt;/a&gt;の特定の値は、パラメーターが&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;または&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;演算子の左側である場合、またはパラメーターがインデックス付き列と比較され、&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;コンパイル時オプションが有効になっている場合、クエリプランの選択に影響を与える可能性があります。</target>
        </trans-unit>
        <trans-unit id="a67ab94a492111af2ad307d63a14eece5d2506a2" translate="yes" xml:space="preserve">
          <source>If the specific value bound to a &lt;a href=&quot;../lang_expr#varparam&quot;&gt;host parameter&lt;/a&gt; in the WHERE clause might influence the choice of query plan for a statement, then the statement will be automatically recompiled, as if there had been a schema change, on the first &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call following any change to the &lt;a href=&quot;bind_blob&quot;&gt;bindings&lt;/a&gt; of that &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt;. The specific value of a WHERE-clause &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; might influence the choice of query plan if the parameter is the left-hand side of a &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator or if the parameter is compared to an indexed column and the &lt;a href=&quot;../compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">If the specific value bound to a &lt;a href=&quot;../lang_expr#varparam&quot;&gt;host parameter&lt;/a&gt; in the WHERE clause might influence the choice of query plan for a statement, then the statement will be automatically recompiled, as if there had been a schema change, on the first &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call following any change to the &lt;a href=&quot;bind_blob&quot;&gt;bindings&lt;/a&gt; of that &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt;. The specific value of a WHERE-clause &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; might influence the choice of query plan if the parameter is the left-hand side of a &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator or if the parameter is compared to an indexed column and the &lt;a href=&quot;../compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is enabled.</target>
        </trans-unit>
        <trans-unit id="1532d90d6e0b3047b8c2ebb4f13faa142948903d" translate="yes" xml:space="preserve">
          <source>If the specific value bound to a &lt;a href=&quot;lang_expr#varparam&quot;&gt;host parameter&lt;/a&gt; in the WHERE clause might influence the choice of query plan for a statement, then the statement will be automatically recompiled, as if there had been a schema change, on the first &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call following any change to the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;bindings&lt;/a&gt; of that &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt;. The specific value of a WHERE-clause &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; might influence the choice of query plan if the parameter is the left-hand side of a &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator or if the parameter is compared to an indexed column and the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">If the specific value bound to a &lt;a href=&quot;lang_expr#varparam&quot;&gt;host parameter&lt;/a&gt; in the WHERE clause might influence the choice of query plan for a statement, then the statement will be automatically recompiled, as if there had been a schema change, on the first &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call following any change to the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;bindings&lt;/a&gt; of that &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt;. The specific value of a WHERE-clause &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; might influence the choice of query plan if the parameter is the left-hand side of a &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator or if the parameter is compared to an indexed column and the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is enabled.</target>
        </trans-unit>
        <trans-unit id="9e1ce97d9fc0705c3229e21c8809d3855d59efd3" translate="yes" xml:space="preserve">
          <source>If the specified column is &quot;rowid&quot;, &quot;oid&quot; or &quot;_rowid_&quot; and the table is not a &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table and an &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column has been explicitly declared, then the output parameters are set for the explicitly declared column. If there is no &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column, then the outputs for the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; are set as follows:</source>
          <target state="translated">指定された列が「rowid」、「oid」または「_rowid_」であり、表が&lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表ではなく、&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列が明示的に宣言されている場合、出力パラメーターは明示的に宣言された列に設定されます。&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列がない場合、&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;の出力は次のように設定されます。</target>
        </trans-unit>
        <trans-unit id="8f350a11b8322175a383ceadb167cdbb00955970" translate="yes" xml:space="preserve">
          <source>If the specified column is &quot;rowid&quot;, &quot;oid&quot; or &quot;_rowid_&quot; and the table is not a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table and an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column has been explicitly declared, then the output parameters are set for the explicitly declared column. If there is no &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column, then the outputs for the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; are set as follows:</source>
          <target state="translated">指定された列が「rowid」、「oid」または「_rowid_」であり、表が&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;表ではなく、&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列が明示的に宣言されている場合、出力パラメーターは明示的に宣言された列に設定されます。&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列がない場合、&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;の出力は次のように設定されます。</target>
        </trans-unit>
        <trans-unit id="f3164e0e380d4749ee94c4239d71835f6ebe7294" translate="yes" xml:space="preserve">
          <source>If the specified compress or uncompress functions do not exist, the table may still be created. An error is not returned until the FTS4 table is read (if the uncompress function does not exist) or written (if it is the compress function that does not exist).</source>
          <target state="translated">指定された圧縮関数又は圧縮解除関数が存在しない場合でも,テーブルは作成されることがある。FTS4 テーブルが読み込まれるまで(圧縮解除関数が存在しない場合)、または書き込まれるまで(圧縮解除関数が存在しない場合)、エラーは返されません。</target>
        </trans-unit>
        <trans-unit id="63eb5c5c72bb1ff543038003d7ef2fd45c2837fe" translate="yes" xml:space="preserve">
          <source>If the specified table is actually a view, an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">指定されたテーブルが実際にビューである場合、&lt;a href=&quot;../rescode&quot;&gt;エラーコード&lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="ce9d8284bfd79645e82900ecac60c2249827b2a4" translate="yes" xml:space="preserve">
          <source>If the specified table is actually a view, an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">指定されたテーブルが実際にビューである場合、&lt;a href=&quot;rescode&quot;&gt;エラーコード&lt;/a&gt;が返されます。</target>
        </trans-unit>
        <trans-unit id="7fece2731796046aa37a6f47896457da35d0048d" translate="yes" xml:space="preserve">
          <source>If the specified value is an integer (or text that looks like an integer), it is inserted verbatim. If the value is not a valid UNIX mode, some programs may behave unexpectedly when extracting files from the archive.</source>
          <target state="translated">指定された値が整数(または整数のように見えるテキスト)の場合は、そのまま挿入されます。この値が有効なUNIXモードでない場合、アーカイブからファイルを抽出する際に、一部のプログラムが予期せぬ動作をすることがあります。</target>
        </trans-unit>
        <trans-unit id="e4f3a6c8e56d6f7f8102c0223dc18717b78218c4" translate="yes" xml:space="preserve">
          <source>If the specified view cannot be found and the IF EXISTS clause is not present, it is an error. If the specified view cannot be found and an IF EXISTS clause is present in the DROP VIEW statement, then the statement is a no-op.</source>
          <target state="translated">指定したビューが見つからず、IF EXISTS句が存在しない場合はエラーとなります。指定されたビューが見つからず、DROP VIEW文の中にIF EXISTS句が存在する場合、その文はno-opとなります。</target>
        </trans-unit>
        <trans-unit id="90a8c9a64f685446aa6aabbcaddc7d44c89fc5a1" translate="yes" xml:space="preserve">
          <source>If the sqlite3_vtab_nochange(X) routine is called within the &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;, then it returns true if and only if the column is being fetched as part of an UPDATE operation during which the column value will not change. Applications might use this to substitute a return value that is less expensive to compute and that the corresponding &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method understands as a &quot;no-change&quot; value.</source>
          <target state="translated">sqlite3_vtab_nochange（X）ルーチンが&lt;a href=&quot;../vtab&quot;&gt;仮想テーブルの&lt;/a&gt;&lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;メソッド内で呼び出された場合、その列がUPDATE操作の一部としてフェッチされ、その間に列の値が変化しない場合にのみ、trueを返します。アプリケーションはこれを使用して、計算にかかるコストが低く、対応する&lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;メソッドが「変更なし」の値として理解する戻り値を置き換える場合があります。</target>
        </trans-unit>
        <trans-unit id="589f84e6663e321a54522d9b6141cb9b22a8427e" translate="yes" xml:space="preserve">
          <source>If the sqlite3_vtab_nochange(X) routine is called within the &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;, then it returns true if and only if the column is being fetched as part of an UPDATE operation during which the column value will not change. Applications might use this to substitute a return value that is less expensive to compute and that the corresponding &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method understands as a &quot;no-change&quot; value.</source>
          <target state="translated">sqlite3_vtab_nochange（X）ルーチンが&lt;a href=&quot;vtab&quot;&gt;仮想テーブルの&lt;/a&gt;&lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;メソッド内で呼び出された場合、その列がUPDATE操作の一部としてフェッチされ、その間に列の値が変化しない場合にのみ、trueを返します。アプリケーションはこれを使用して、計算にかかるコストが低く、対応する&lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;メソッドが「変更なし」の値として理解する戻り値を置き換える場合があります。</target>
        </trans-unit>
        <trans-unit id="aeaddc8619c2a7f7c9c53fa9fbcf5b7907cc4bc7" translate="yes" xml:space="preserve">
          <source>If the sqlite_stat1.idx column is NULL, then the sqlite_stat1.stat column contains a single integer which is the approximate number of rows in the table identified by sqlite_stat1.tbl. If the sqlite_stat1.idx column is the same as the sqlite_stat1.tbl column, then the table is a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table and the sqlite_stat1.stat field contains information about the index btree that implements the WITHOUT ROWID table.</source>
          <target state="translated">sqlite_stat1.idx列がNULLの場合、sqlite_stat1.stat列には、sqlite_stat1.tblで識別されるテーブル内のおおよその行数である単一の整数が含まれます。sqlite_stat1.idx列がsqlite_stat1.tbl列と同じ場合、テーブルは&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルであり、sqlite_stat1.statフィールドには、WITHOUT ROWIDテーブルを実装するインデックスbtreeに関する情報が含まれます。</target>
        </trans-unit>
        <trans-unit id="7ef8812fff06e258ef45bbe3080d7b83145fdfcb" translate="yes" xml:space="preserve">
          <source>If the sub-query is a compound SELECT, then</source>
          <target state="translated">サブクエリが複合SELECTの場合は、次のようになります。</target>
        </trans-unit>
        <trans-unit id="95d8d057928b20b8273091a81f8f75e5dc26f5b2" translate="yes" xml:space="preserve">
          <source>If the sub-query is a compound select, then all terms of the ORDER by clause of the parent must be simple references to columns of the sub-query.</source>
          <target state="translated">副問い合わせが複合セレクトの場合、親のORDER by節のすべての項は副問い合わせの列への単純な参照でなければなりません。</target>
        </trans-unit>
        <trans-unit id="cfa26eb2d70555062705f5059521f66db3517508" translate="yes" xml:space="preserve">
          <source>If the sub-query is a compound select, then it must not use an ORDER BY clause.</source>
          <target state="translated">副問い合わせが複合セレクトの場合、ORDER BY句を使用してはいけません。</target>
        </trans-unit>
        <trans-unit id="a41d547f4cfa21fa6c9e383332bb2ccbe73488d1" translate="yes" xml:space="preserve">
          <source>If the subquery is the right operand of a LEFT JOIN then</source>
          <target state="translated">副問い合わせがLEFT JOINの右オペランドである場合、次のようになります。</target>
        </trans-unit>
        <trans-unit id="9251592b196cd1f8e1c4b9db367256eca51eaf76" translate="yes" xml:space="preserve">
          <source>If the subquery uses LIMIT then the outer query may not have a WHERE clause.</source>
          <target state="translated">副問い合わせがLIMITを使用している場合、外側の問い合わせにWHERE句がない場合があります。</target>
        </trans-unit>
        <trans-unit id="3915c5066778c0e52bdae49ad9f9428a2640f7be" translate="yes" xml:space="preserve">
          <source>If the subquery uses LIMIT, then the outer query may not be DISTINCT.</source>
          <target state="translated">副問い合わせがLIMITを使用している場合、外側の問い合わせはDISTINCTではないかもしれません。</target>
        </trans-unit>
        <trans-unit id="3ca99915e9f2329a546bdb9b1fd10bf3cea382c2" translate="yes" xml:space="preserve">
          <source>If the table has 32 or fewer columns, a single unsigned integer is output for each phrase in the query. The least significant bit of the integer is set if the phrase appears at least once in column 0. The second least significant bit is set if the phrase appears once or more in column 1. And so on.</source>
          <target state="translated">テーブルの列数が32以下の場合、クエリ内の各フレーズに対して1つの符号なし整数が出力されます。フレーズが0列目に1回以上出現すると、その整数の最下位ビットがセットされます。フレーズが 1 列目に 1 回以上出現すると、2 番目の最下位ビットが設定されます。といった具合です。</target>
        </trans-unit>
        <trans-unit id="721c91e5cd9182aa981b27d672f91c90481093e6" translate="yes" xml:space="preserve">
          <source>If the table has more than 32 columns, an extra integer is added to the output of each phrase for each extra 32 columns or part thereof. Integers corresponding to the same phrase are clumped together. For example, if a table with 45 columns is queried for two phrases, 4 integers are output. The first corresponds to phrase 0 and columns 0-31 of the table. The second integer contains data for phrase 0 and columns 32-44, and so on.</source>
          <target state="translated">テーブルに32列以上の列がある場合、各フレーズの出力には、余分な32列またはその一部ごとに余分な整数が追加されます。同じフレーズに対応する整数はまとめて出力されます。例えば、45 カラムのテーブルが 2 つのフレーズに対してクエリされた場合、4 つの整数が出力されます。1 番目の整数は、フレーズ 0 とテーブルの 0 ~ 31 カラムに対応します。2 番目の整数には、フレーズ 0 とカラム 32-44 などのデータが含まれています。</target>
        </trans-unit>
        <trans-unit id="dd1a6a322a6da8501607606cd285b56e7643fea3" translate="yes" xml:space="preserve">
          <source>If the table is also a contentless table, the xInstCount, xInst, xPhraseFirst and xPhraseNext APIs behave as if the current row contains no phrase matches at all (i.e. xInstCount() returns 0).</source>
          <target state="translated">テーブルが内容のないテーブルでもある場合、xInstCount、xInst、xPhraseFirst、およびxPhraseNext APIは、現在の行にフレーズの一致が全くない場合のように動作します (すなわち、xInstCount()は 0 を返します)。</target>
        </trans-unit>
        <trans-unit id="6fe44f3588c5a2857dcbb9370708a1c62e0664e1" translate="yes" xml:space="preserve">
          <source>If the table is also a contentless table, the xPhraseFirstColumn and xPhraseNextColumn APIs behave as if the current row contains no phrase matches at all (i.e. xPhraseFirstColumn() sets the iterator to EOF).</source>
          <target state="translated">テーブルが内容のないテーブルでもある場合、xPhraseFirstColumn API および xPhraseNextColumn API は、現在の行にフレーズの一致が全く含まれていない場合のように動作します (すなわち、xPhraseFirstColumn()はイテレータを EOF に設定します)。</target>
        </trans-unit>
        <trans-unit id="8fa583fa8336ae813a54303aa49ca52aa9df3514" translate="yes" xml:space="preserve">
          <source>If the tables are not compatible, SQLITE_SCHEMA is returned. If the tables are compatible but do not have any PRIMARY KEY columns, it is not an error but no changes are added to the session object. As with other session APIs, tables without PRIMARY KEYs are simply ignored.</source>
          <target state="translated">テーブルに互換性がない場合、SQLITE_SCHEMAが返されます。テーブルに互換性があるが PRIMARY KEY カラムがない場合は、エラーではありませんが、セッションオブジェクトに変更は加えられません。他のセッションAPIと同様に、PRIMARY KEYを持たないテーブルは単に無視されます。</target>
        </trans-unit>
        <trans-unit id="39d5998574043194036193b1ccfe1d960d708066" translate="yes" xml:space="preserve">
          <source>If the target database table has an INTEGER PRIMARY KEY, it is not possible to insert a NULL value into the IPK column. Attempting to do so results in an SQLITE_MISMATCH error.</source>
          <target state="translated">対象のデータベース・テーブルに INTEGER PRIMARY KEY がある場合、IPK カラムに NULL 値を挿入することはできません。これを試みると、SQLITE_MISMATCH エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="9c95a9c982f66790e65014b945cf26e39c71b898" translate="yes" xml:space="preserve">
          <source>If the target database table is a virtual table or a table that has no PRIMARY KEY declaration, the data_% table must also contain a column named &quot;rbu_rowid&quot;. The rbu_rowid column is mapped to the tables &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;. For example, if the target database contains either of the following:</source>
          <target state="translated">ターゲットデータベーステーブルが仮想テーブルまたはPRIMARY KEY宣言のないテーブルである場合、data_％テーブルには &quot;rbu_rowid&quot;という名前の列も含まれている必要があります。rbu_rowid列は、表&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWIDに&lt;/a&gt;マップされます。たとえば、ターゲットデータベースに次のいずれかが含まれているとします。</target>
        </trans-unit>
        <trans-unit id="fbd25358ffefdc6dc4f80487cafab05d3b5b26ee" translate="yes" xml:space="preserve">
          <source>If the target database table is a virtual table or a table with no PRIMARY KEY, the rbu_control value should not include a character corresponding to the rbu_rowid value. For example, this:</source>
          <target state="translated">対象のデータベーステーブルが仮想テーブルまたはPRIMARY KEYのないテーブルである場合、rbu_controlの値にはrbu_rowidの値に対応する文字を含めてはいけません。例えば、これは</target>
        </trans-unit>
        <trans-unit id="01af3a5676cb2f1557deacfea75c22d3ec69c112" translate="yes" xml:space="preserve">
          <source>If the text fragment does not begin at the start of a column value, the &quot;ellipses&quot; text is prepended to it.</source>
          <target state="translated">テキストの断片が列の値の先頭で始まらない場合は、&quot;ellipses &quot;テキストが前に付加されます。</target>
        </trans-unit>
        <trans-unit id="c5699be55281fc6c124864de2ed79fa2e78862fa" translate="yes" xml:space="preserve">
          <source>If the text fragment does not finish at the end of a column value, the &quot;ellipses&quot; text is appended to it.</source>
          <target state="translated">テキストの断片が列の値の最後で終了しない場合は、&quot;ellipses &quot;のテキストが追加されます。</target>
        </trans-unit>
        <trans-unit id="9b02a2cc603460380751e873e7881c3872500434" translate="yes" xml:space="preserve">
          <source>If the third parameter (the pointer to the sqlite3_module object) is NULL then no new module is create and any existing modules with the same name are dropped.</source>
          <target state="translated">3番目のパラメータ(sqlite3_moduleオブジェクトへのポインタ)がNULLの場合、新しいモジュールは作成されず、同じ名前の既存のモジュールはすべて削除されます。</target>
        </trans-unit>
        <trans-unit id="1fb42f686bdf0ae2d9460cba55a33f179256de59" translate="yes" xml:space="preserve">
          <source>If the two snapshot handles are not associated with the same database file, the result of the comparison is undefined.</source>
          <target state="translated">2 つのスナップショットハンドルが同じデータベースファイルに関連付けられていない場合、比較の結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="e40d631505df75eada1d7356f623733efe0e7e84" translate="yes" xml:space="preserve">
          <source>If the value N is out of range or if the N-th parameter is nameless, then NULL is returned. The returned string is always in UTF-8 encoding even if the named parameter was originally specified as UTF-16 in &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;.</source>
          <target state="translated">値Nが範囲外の場合、またはN番目のパラメーターに名前がない場合、NULLが返されます。名前付きパラメーターが&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;、または&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;で最初に UTF-16として指定されていたとしても、返される文字列は常にUTF-8エンコーディングです。</target>
        </trans-unit>
        <trans-unit id="345b60970d744b5b63e874a6cd2300d092b35eca" translate="yes" xml:space="preserve">
          <source>If the value N is out of range or if the N-th parameter is nameless, then NULL is returned. The returned string is always in UTF-8 encoding even if the named parameter was originally specified as UTF-16 in &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;.</source>
          <target state="translated">値Nが範囲外の場合、またはN番目のパラメーターに名前がない場合、NULLが返されます。名前付きパラメーターが&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16（）&lt;/a&gt;、&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2（）&lt;/a&gt;、または&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3（）&lt;/a&gt;で最初に UTF-16として指定されていたとしても、返される文字列は常にUTF-8エンコーディングです。</target>
        </trans-unit>
        <trans-unit id="d68928282b4992ea60ac59e231acaeb89700dde0" translate="yes" xml:space="preserve">
          <source>If the value being substituted is larger than the width, then full value is added to the output. In other words, the width is the minimum width of the value as it is rendered in the output.</source>
          <target state="translated">置換される値が幅よりも大きい場合は、完全な値が出力に追加されます。言い換えれば、幅は出力でレンダリングされる値の最小幅です。</target>
        </trans-unit>
        <trans-unit id="c4b0ded1a1deef22b5fab46f3c6efeda2921b5b8" translate="yes" xml:space="preserve">
          <source>If the value of</source>
          <target state="translated">の値が</target>
        </trans-unit>
        <trans-unit id="6f9d3eb4af97233320c8cb8d005d76e733f1eb82" translate="yes" xml:space="preserve">
          <source>If the value of a path/value pair is an SQLite TEXT value, then it is normally inserted as a quoted JSON string, even if the string looks like valid JSON. However, if the value is the result of another json1 function (such as &lt;a href=&quot;json1#jmini&quot;&gt;json()&lt;/a&gt; or &lt;a href=&quot;json1#jarray&quot;&gt;json_array()&lt;/a&gt; or &lt;a href=&quot;json1#jobj&quot;&gt;json_object()&lt;/a&gt;) then it is interpreted as JSON and is inserted as JSON retaining all of its substructure.</source>
          <target state="translated">パスと値のペアの値がSQLite TEXT値の場合、文字列が有効なJSONのように見えても、通常は引用符で囲まれたJSON文字列として挿入されます。ただし、値が別のjson1関数（&lt;a href=&quot;json1#jmini&quot;&gt;json（）&lt;/a&gt;、&lt;a href=&quot;json1#jarray&quot;&gt;json_array（）&lt;/a&gt;、&lt;a href=&quot;json1#jobj&quot;&gt;json_object（）など&lt;/a&gt;）の結果である場合は、JSONとして解釈され、すべての部分構造を保持するJSONとして挿入されます。</target>
        </trans-unit>
        <trans-unit id="b32ac49b143ce73b794453377ce559efe5961df7" translate="yes" xml:space="preserve">
          <source>If the value of the zString variable is NULL, the generated SQL will look like the following:</source>
          <target state="translated">zString 変数の値が NULL の場合、生成される SQL は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="8161ccbb4f6a18f526e60b92f180512b88485f22" translate="yes" xml:space="preserve">
          <source>If the values &quot;inserted&quot; into the text columns as part of a 'delete' command are not the same as those currently stored within the table, the results may be unpredictable.</source>
          <target state="translated">delete」コマンドの一部としてテキスト列に「挿入」された値が、現在テーブル内に保存されている値と異なる場合、結果が予測できない場合があります。</target>
        </trans-unit>
        <trans-unit id="59bbe3f4e62b07925a07b5a183754aca1009b0a0" translate="yes" xml:space="preserve">
          <source>If the variable does not have a bytearray representation, then &quot;@&quot; works just like &quot;$&quot;. Note that &quot;:&quot; works like &quot;$&quot; in all cases so the following is another way to express the same statement:</source>
          <target state="translated">変数がバイト配列で表現されていない場合、&quot;@&quot;は&quot;$&quot;と同じように動作します。ただし、&quot;:&quot; はすべての場合で &quot;$&quot; と同じように動作するので、同じ文を表現する別の方法を以下に示します。</target>
        </trans-unit>
        <trans-unit id="967912701ccde0cf6890cfdea463d69721e44f33" translate="yes" xml:space="preserve">
          <source>If the virtual machine is unable to open the database file because it is locked by another thread or process, &lt;b&gt;sqlite_step&lt;/b&gt; will return SQLITE_BUSY. The calling function should do some other activity, or sleep, for a short amount of time to give the lock a chance to clear, then invoke &lt;b&gt;sqlite_step&lt;/b&gt; again. This can be repeated as many times as desired.</source>
          <target state="translated">別のスレッドまたはプロセスによってロックされているために仮想マシンがデータベースファイルを開くことができない場合、&lt;b&gt;sqlite_step&lt;/b&gt;はSQLITE_BUSYを返します。呼び出し側の関数は、ロックをクリアする機会を与えるために、他のアクティビティをいくつか実行するか、またはスリープしてから、&lt;b&gt;sqlite_stepを&lt;/b&gt;再度呼び出す&lt;b&gt;必要&lt;/b&gt;があります。これは、必要に応じて何度でも繰り返すことができます。</target>
        </trans-unit>
        <trans-unit id="d0cab5be9268823b532780f4620139e0b2493eda" translate="yes" xml:space="preserve">
          <source>If the virtual table contains one or more rows that match the search criteria, then the cursor must be left point at the first row. Subsequent calls to &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; must return false (zero). If there are no rows match, then the cursor must be left in a state that will cause the &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; to return true (non-zero). The SQLite engine will use the &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; and &lt;a href=&quot;vtab#xrowid&quot;&gt;xRowid&lt;/a&gt; methods to access that row content. The &lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; method will be used to advance to the next row.</source>
          <target state="translated">仮想テーブルに検索条件に一致する1つ以上の行が含まれている場合、カーソルは最初の行を左に置く必要があります。&lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt;への後続の呼び出しはfalse（ゼロ）を返す必要があります。一致する行がない場合、カーソルは、&lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt;がtrue（ゼロ以外）を返すような状態にしておく必要があります。 SQLiteのエンジンが使用する&lt;a href=&quot;vtab#xcolumn&quot;&gt;Xcolumnに&lt;/a&gt;及び&lt;a href=&quot;vtab#xrowid&quot;&gt;xRowid&lt;/a&gt;行コンテンツそのアクセス方法を。&lt;a href=&quot;vtab#xnext&quot;&gt;xNextの&lt;/a&gt;方法は、次の行に進むために使用されます。</target>
        </trans-unit>
        <trans-unit id="ad0d9be234c914ee5ff307719c3b70dd43c84d33" translate="yes" xml:space="preserve">
          <source>If the virtual table will output rows in the order specified by the ORDER BY clause, then the orderByConsumed flag may be set to true. If the output is not automatically in the correct order then orderByConsumed must be left in its default false setting. This will indicate to the SQLite core that it will need to do a separate sorting pass over the data after it comes out of the virtual table.</source>
          <target state="translated">仮想テーブルが ORDER BY 節で指定した順序で行を出力する場合は、 orderByConsumed フラグを true に設定することができます。自動的に正しい順序で出力されない場合は、 orderByConsumed をデフォルトの false のままにしておかなければなりません。これは、SQLiteコアに対して、仮想テーブルからデータが出てきた後に別のソートパスを実行する必要があることを示します。</target>
        </trans-unit>
        <trans-unit id="40852f77f22b22d25b15aa100b0b83a4fb17d34c" translate="yes" xml:space="preserve">
          <source>If the width is a single &quot;*&quot; character instead of a number, then the actual width value is read as an integer from the argument list. If the value read is negative, then the absolute value is used for the width and the value is left-justified as if the &quot;-&quot; flag were present.</source>
          <target state="translated">幅が数値ではなく &quot;*&quot;一文字の場合、実際の幅の値が引数リストから整数として読み込まれる。読み込まれた値が負の場合、絶対値が幅に使用され、値は&quot;-&quot;フラグがあるかのように左寄せされる。</target>
        </trans-unit>
        <trans-unit id="5f665397e9a7b0fe05142c4eb0f952c2d738840c" translate="yes" xml:space="preserve">
          <source>If the xAccess() query required by H35490 reveals that the journal file is still present in the file system, then SQLite shall conclude that the journal file is a</source>
          <target state="translated">H35490 で要求された xAccess()クエリにより、ファイルシステム内にジャーナルファイルがまだ存在することが判明した場合、SQLite は、ジャーナルファイルが</target>
        </trans-unit>
        <trans-unit id="2ece4dc60c85bd0f6370651e04aa59f231e6a232" translate="yes" xml:space="preserve">
          <source>If the xColumn method implementation calls none of the functions above, then the value of the column defaults to an SQL NULL.</source>
          <target state="translated">xColumnメソッドの実装が上記の関数のいずれも呼び出さない場合、カラムの値はSQL NULLがデフォルトとなります。</target>
        </trans-unit>
        <trans-unit id="df9512eb02b352fc76419bfac69b024afe92a594" translate="yes" xml:space="preserve">
          <source>If the xCreate method is omitted (left as a NULL pointer) then the virtual table is an &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual table&lt;/a&gt;. New instances of the virtual table cannot be created using &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; and the virtual table can only be used via its module name. Note that SQLite versions prior to 3.9.0 (2015-10-14) do not understand eponymous-only virtual tables and will segfault if an attempt is made to &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; on an eponymous-only virtual table because the xCreate method was not checked for null.</source>
          <target state="translated">xCreateメソッドが省略されている場合（NULLポインターとして残されている場合）、仮想テーブルは、&lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;同名のみの仮想テーブル&lt;/a&gt;です。&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;を使用して仮想テーブルの新しいインスタンスを作成することはできず、仮想テーブルはそのモジュール名を介してのみ使用できます。 SQLiteのより前のバージョンの3.9.0（2015年10月14日）が名を冠した専用の仮想テーブルを理解していないとの試みがさせるとセグメンテーションフォールトがあることに注意してください&lt;a href=&quot;lang_createvtab&quot;&gt;VIRTUAL CREATE TABLEを&lt;/a&gt; xCreateメソッドがチェックされていなかったので、名を冠した専用の仮想テーブルの上にnullの場合。</target>
        </trans-unit>
        <trans-unit id="2621a8e3fdadffc723f38e49d09955e1039ab97f" translate="yes" xml:space="preserve">
          <source>If the xCreate method is the exact same pointer as the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method, that indicates that the virtual table does not need to initialize backing store. Such a virtual table can be used as an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt; or as a named virtual table using &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; or both.</source>
          <target state="translated">xCreate方法はまったく同じポインタである場合&lt;a href=&quot;vtab#xconnect&quot;&gt;xconnectコン&lt;/a&gt;仮想テーブルはバッキングストアを初期化する必要がないことを示している方法は、。このような仮想テーブルは、&lt;a href=&quot;vtab#epovtab&quot;&gt;代名詞の仮想テーブル&lt;/a&gt;として、または&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;またはその両方を使用した名前付き仮想テーブルとして使用できます。</target>
        </trans-unit>
        <trans-unit id="1ea6013e86112c06dab3e4770a560b43808bcc0c" translate="yes" xml:space="preserve">
          <source>If the xEntryPoint routine encounters an error, it should make *pzErrMsg point to an appropriate error message (obtained from &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt;) and return an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;. SQLite ensures that *pzErrMsg is NULL before calling the xEntryPoint(). SQLite will invoke &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; on *pzErrMsg after xEntryPoint() returns. If any xEntryPoint() returns an error, the &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; call that provoked the xEntryPoint() will fail.</source>
          <target state="translated">xEntryPointルーチンでエラーが発生した場合、* pzErrMsgが適切なエラーメッセージ（&lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;から取得）を指すようにし、適切な&lt;a href=&quot;rescode&quot;&gt;エラーコード&lt;/a&gt;を返す必要があります。 SQLiteは、xEntryPoint（）を呼び出す前に* pzErrMsgがNULLであることを確認します。 SQLiteは起動します&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt; xEntryPoint（）が復帰した後* pzErrMsg上を。 xEntryPoint（）がエラーを返す場合、xEntryPoint（）を引き起こした&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16（）&lt;/a&gt;、または&lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;呼び出しは失敗します。</target>
        </trans-unit>
        <trans-unit id="f84dff46c33beaf54e0ca4079880cc37a3fce130" translate="yes" xml:space="preserve">
          <source>If the xEntryPoint routine encounters an error, it should make *pzErrMsg point to an appropriate error message (obtained from &lt;a href=&quot;mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt;) and return an appropriate &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt;. SQLite ensures that *pzErrMsg is NULL before calling the xEntryPoint(). SQLite will invoke &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; on *pzErrMsg after xEntryPoint() returns. If any xEntryPoint() returns an error, the &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; call that provoked the xEntryPoint() will fail.</source>
          <target state="translated">xEntryPointルーチンでエラーが発生した場合、* pzErrMsgが適切なエラーメッセージ（&lt;a href=&quot;mprintf&quot;&gt;sqlite3_mprintf（）&lt;/a&gt;から取得）を指すようにし、適切な&lt;a href=&quot;../rescode&quot;&gt;エラーコード&lt;/a&gt;を返す必要があります。 SQLiteは、xEntryPoint（）を呼び出す前に* pzErrMsgがNULLであることを確認します。 SQLiteは起動します&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt; xEntryPoint（）が復帰した後* pzErrMsg上を。 xEntryPoint（）がエラーを返す場合、xEntryPoint（）を引き起こした&lt;a href=&quot;open&quot;&gt;sqlite3_open（）&lt;/a&gt;、&lt;a href=&quot;open&quot;&gt;sqlite3_open16（）&lt;/a&gt;、または&lt;a href=&quot;open&quot;&gt;sqlite3_open_v2（）&lt;/a&gt;呼び出しは失敗します。</target>
        </trans-unit>
        <trans-unit id="74fa84b64e4977d1c29908e0f6708d6d082c0af7" translate="yes" xml:space="preserve">
          <source>If the xUpdate method is performing an UPDATE, then &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange(X)&lt;/a&gt; can be used to discover which columns of the virtual table were actually modified by the UPDATE statement. The &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange(X)&lt;/a&gt; interface returns true for columns that do not change. On every UPDATE, SQLite will first invoke &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; separately for each unchanging column in the table to obtain the value for that column. The &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method can check to see if the column is unchanged at the SQL level by invoking &lt;a href=&quot;c3ref/vtab_nochange&quot;&gt;sqlite3_vtab_nochange()&lt;/a&gt;. If &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; sees that the column is not being modified, it should return without setting a result using one of the &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_xxxxx()&lt;/a&gt; interfaces. Only in that case &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange()&lt;/a&gt; will be true within the xUpdate method. If &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; does invoke one or more &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_xxxxx()&lt;/a&gt; interfaces, then SQLite understands that as a change in the value of the column and the &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange()&lt;/a&gt; call for that column within xUpdate will return false.</source>
          <target state="translated">xUpdateメソッドがUPDATEを実行している場合、sqlite3_value_nochange &lt;a href=&quot;c3ref/value_blob&quot;&gt;（X）&lt;/a&gt;を使用して、UPDATEステートメントによって実際に変更された仮想テーブルの列を検出できます。&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange（X）&lt;/a&gt;変更しない列のための真のインターフェイスに戻ります。 SQLiteはすべてのUPDATEで、最初にテーブルの&lt;a href=&quot;vtab#xcolumn&quot;&gt;変更&lt;/a&gt;されていない列ごとにxColumnを個別に呼び出し、その列の値を取得します。&lt;a href=&quot;vtab#xcolumn&quot;&gt;Xcolumnにする&lt;/a&gt;方法は、カラムが起動することにより、SQLレベルで変化していないかどうかを確認することができ&lt;a href=&quot;c3ref/vtab_nochange&quot;&gt;sqlite3_vtab_nochangeを（） &lt;/a&gt;。列が変更されていないことを&lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;が確認した場合、&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_xxxxx（）の&lt;/a&gt;いずれかを使用して結果を設定せずに戻る必要がありますインターフェース。その場合にのみ、&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange（）&lt;/a&gt;がxUpdateメソッド内でtrueになります。&lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt;が1つ以上の&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_xxxxx（）&lt;/a&gt;インターフェースを呼び出す場合、SQLiteは列の値の変更と&lt;a href=&quot;c3ref/value_blob&quot;&gt;xUpdate&lt;/a&gt;内のその列に対するsqlite3_value_nochange（）呼び出しがfalseを返すことを理解します。</target>
        </trans-unit>
        <trans-unit id="7b85064db380f0c3b1175d1e7fe24a5bdf881bd8" translate="yes" xml:space="preserve">
          <source>If the xUpdate method violates some constraint of the virtual table (including, but not limited to, attempting to store a value of the wrong datatype, attempting to store a value that is too large or too small, or attempting to change a read-only value) then the xUpdate must fail with an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">xUpdateメソッドが仮想テーブルの制約に違反している場合（これに限定されないが、間違ったデータ型の値を格納しようとする、大きすぎるまたは小さすぎる値を格納しようとする、または読み取り専用を変更しようとするなど）値）その後、xUpdateは適切な&lt;a href=&quot;rescode&quot;&gt;エラーコードで&lt;/a&gt;失敗する必要があります。</target>
        </trans-unit>
        <trans-unit id="9a7985513fccd145b507f142e6f37dfce68e7177" translate="yes" xml:space="preserve">
          <source>If the zString variable holds text like &quot;Hello&quot;, then this statement will work just fine. But suppose the user enters a string like &quot;Hi y'all!&quot;. The SQL statement generated reads as follows:</source>
          <target state="translated">zString 変数が &quot;Hello&quot; のようなテキストを保持している場合、この文はうまく動作します。しかし、ユーザが &quot;Hi y'all!&quot; のような文字列を入力したとします。生成されたSQL文は次のように読み取れます。</target>
        </trans-unit>
        <trans-unit id="38c9c0042a5b1d208534216bf07dfb6099f9ebb4" translate="yes" xml:space="preserve">
          <source>If there are many client programs sending SQL to the same database over a network, then use a client/server database engine instead of SQLite. SQLite will work over a network filesystem, but because of the latency associated with most network filesystems, performance will not be great. Also, file locking logic is buggy in many network filesystem implementations (on both Unix and Windows). If file locking does not work correctly, two or more clients might try to modify the same part of the same database at the same time, resulting in corruption. Because this problem results from bugs in the underlying filesystem implementation, there is nothing SQLite can do to prevent it.</source>
          <target state="translated">ネットワーク経由で同じデータベースにSQLを送信するクライアントプログラムが多数ある場合は、SQLiteの代わりにクライアント/サーバーデータベースエンジンを使用してください。SQLiteはネットワークファイルシステム上で動作しますが、ほとんどのネットワークファイルシステムに関連するレイテンシのため、パフォーマンスはあまり良くありません。また、多くのネットワークファイルシステムの実装(UnixとWindowsの両方)では、ファイルロックのロジックにバグがあります。ファイルロックが正しく動作しない場合、複数のクライアントが同時に同じデータベースの同じ部分を変更しようとし、破損を引き起こす可能性があります。この問題は、基礎となるファイルシステムの実装のバグに起因するものなので、SQLite がこれを防ぐためにできることは何もありません。</target>
        </trans-unit>
        <trans-unit id="36f4c3a2fda5cf31617c5fabae95e90bafd39057" translate="yes" xml:space="preserve">
          <source>If there are multiple (hard or symbolic) links to a database file, the journal will be created using the name of the link through which the file was opened. If a crash occurs and the database is opened again using a different link, the hot journal will not be located and no rollback will occur.</source>
          <target state="translated">データベースファイルへの複数の(ハードまたはシンボリック)リンクがある場合、ジャーナルは、ファイルが開かれたリンクの名前を使用して作成されます。クラッシュが発生し、別のリンクを使用してデータベースを再度開いた場合、ホット・ジャーナルは存在せず、ロールバックも発生しません。</target>
        </trans-unit>
        <trans-unit id="11044e3b942016886a776e1bab1892306cb966d9" translate="yes" xml:space="preserve">
          <source>If there are still more pages to copy from database pDb, then the function sleeps for 250 milliseconds (using the &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep()&lt;/a&gt; utility) and then returns to step 2.</source>
          <target state="translated">データベースpDbからコピーするページがまだある場合、関数は（&lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep（）&lt;/a&gt;ユーティリティを使用して） 250ミリ秒間スリープしてから、手順2に戻ります。</target>
        </trans-unit>
        <trans-unit id="afce5a653d0b42c7793177067bc50ad86675aae0" translate="yes" xml:space="preserve">
          <source>If there exists an index that maps the &quot;two&quot; column of the &quot;examp&quot; table into integers, then SQLite will use that index to find the integer keys of all rows in examp that have a value of 50 for column two, or all rows that are less than 50, etc. But the following queries cannot use the index:</source>
          <target state="translated">もし &quot;examp &quot;テーブルの &quot;two &quot;カラムを整数にマッピングするインデックスが存在する場合、SQLiteはそのインデックスを使用して、examp内のすべての行のうち、カラム2の値が50である行、または50より小さい行などの整数キーを見つけます。しかし、以下のクエリはインデックスを使用できません。</target>
        </trans-unit>
        <trans-unit id="856948c8edddeced0c9cafe3bd0f42f4ee0fc501" translate="yes" xml:space="preserve">
          <source>If there has been one or more REPLACE resolutions on a key, it is rebased according to a REPLACE.</source>
          <target state="translated">キーに1つ以上のREPLACE決議があった場合、REPLACEに従ってリベースされます。</target>
        </trans-unit>
        <trans-unit id="4dc77fa5e92703a982360848038ee795cce33659" translate="yes" xml:space="preserve">
          <source>If there have been no REPLACE resolutions on a key, then the local changeset is rebased according to the most recent of the OMIT resolutions.</source>
          <target state="translated">キーに REPLACE 決議がなかった場合、ローカル変更セットは、OMIT 決議のうち最新のものに基づいてリベースされます。</target>
        </trans-unit>
        <trans-unit id="b7ee1d4caced0cc280acbdfbbd3da7974e0aedc7" translate="yes" xml:space="preserve">
          <source>If there is a USING clause then each of the column names specified must exist in the datasets to both the left and right of the join-operator. For each pair of named columns, the expression &quot;lhs.X = rhs.X&quot; is evaluated for each row of the cartesian product as a &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt;. Only rows for which all such expressions evaluates to true are included from the result set. When comparing values as a result of a USING clause, the normal rules for handling affinities, collation sequences and NULL values in comparisons apply. The column from the dataset on the left-hand side of the join-operator is considered to be on the left-hand side of the comparison operator (=) for the purposes of collation sequence and affinity precedence.</source>
          <target state="translated">USING句がある場合、指定された各列名は、結合演算子の左側と右側の両方のデータセットに存在する必要があります。名前付き列の各ペアについて、式「lhs.X = rhs.X」は、デカルト積の各行に対して&lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;ブール式&lt;/a&gt;として評価されます。結果セットには、そのような式がすべてtrueと評価された行のみが含まれます。 USING句の結果として値を比較する場合、比較における類似性、照合シーケンス、およびNULL値の処理に関する通常の規則が適用されます。結合演算子の左側にあるデータセットの列は、照合順序と類似性の優先順位のために、比較演算子（=）の左側にあると見なされます。</target>
        </trans-unit>
        <trans-unit id="d234388212b95e999640f17f4b156605cf6f600f" translate="yes" xml:space="preserve">
          <source>If there is already a read transaction open when this function is invoked, then the same read transaction remains open (on the same database snapshot) if SQLITE_ERROR, SQLITE_BUSY or SQLITE_ERROR_SNAPSHOT is returned. If another error code - for example SQLITE_PROTOCOL or an SQLITE_IOERR error code - is returned, then the final state of the read transaction is undefined. If SQLITE_OK is returned, then the read transaction is now open on database snapshot P.</source>
          <target state="translated">この関数が呼び出されたときに既にオープンされている読み取りトランザクションがある場合、SQLITE_ERROR、SQLITE_BUSY、またはSQLITE_ERROR_SNAPSHOTが返されても、同じ読み取りトランザクションは(同じデータベースのスナップショット上で)オープンされたままです。SQLITE_PROTOCOL や SQLITE_IOERR などの別のエラーコードが返された場合、読み取りトランザクションの最終状態は未定義です。SQLITE_OK が返された場合、読み取りトランザクションはデータベースのスナップショット P で開かれています。</target>
        </trans-unit>
        <trans-unit id="b3ba606d14be7904e644a6f345ba54604a8e5ba7" translate="yes" xml:space="preserve">
          <source>If there is already an auxiliary data pointer when this function is invoked, then it is replaced by the new pointer. If an xDelete callback was specified along with the original pointer, it is invoked at this point.</source>
          <target state="translated">この関数が呼び出されたときに既に補助データポインタがある場合は、そのポインタが新しいポインタに置き換えられます。元のポインタと一緒に xDelete コールバックが指定されていた場合は、この時点で呼び出されます。</target>
        </trans-unit>
        <trans-unit id="7d3f7f6da384d18458af17b6bbb473e63bd6c0a4" translate="yes" xml:space="preserve">
          <source>If there is an AS clause on the result, then the name of the column is the right-hand side of the AS clause.</source>
          <target state="translated">結果にAS句がある場合、カラム名はAS句の右側になります。</target>
        </trans-unit>
        <trans-unit id="ea4985ea47701fb618426a82280d62d99731524f" translate="yes" xml:space="preserve">
          <source>If there is an ON clause then the ON expression is evaluated for each row of the cartesian product as a &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt;. Only rows for which the expression evaluates to true are included from the dataset.</source>
          <target state="translated">ON句がある場合、ON式はデカルト積の各行に対して&lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;ブール式&lt;/a&gt;として評価されます。式がtrueと評価される行のみがデータセットから含まれます。</target>
        </trans-unit>
        <trans-unit id="2e70dfed6b6c48ce8dce24e64f939fa0229381a9" translate="yes" xml:space="preserve">
          <source>If there is no compatible table, it is not an error, but none of the changes associated with the table are applied. A warning message is issued via the sqlite3_log() mechanism with the error code SQLITE_SCHEMA. At most one such warning is issued for each table in the changeset.</source>
          <target state="translated">互換性のあるテーブルがない場合はエラーではありませんが、そのテーブルに関連付けられた変更は何も適用されません。警告メッセージはsqlite3_log()メカニズムを介してエラーコードSQLITE_SCHEMAで発行されます。このような警告は、チェンジセット内の各テーブルに対して最大で1つ発行されます。</target>
        </trans-unit>
        <trans-unit id="8b1f218c8fcc4cd8280015ffb23038ba539a45b9" translate="yes" xml:space="preserve">
          <source>If there is no index named</source>
          <target state="translated">という名前のインデックスがない場合</target>
        </trans-unit>
        <trans-unit id="5f851a7381e365ca34ec1852c08b2f940f8860fc" translate="yes" xml:space="preserve">
          <source>If there is no selftest table, the &quot;.selftest&quot; command runs &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;.</source>
          <target state="translated">セルフテストテーブルがない場合、「。selftest」コマンドは&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA&lt;/a&gt; integer_checkを実行します。</target>
        </trans-unit>
        <trans-unit id="c042772d4bc73bd02a9ce067deaf034251147e0f" translate="yes" xml:space="preserve">
          <source>If there is only a single table or subquery in the FROM clause, then the input data used by the SELECT statement is the contents of the named table. If there is more than one table or subquery in FROM clause then the contents of all tables and/or subqueries are joined into a single dataset for the simple SELECT statement to operate on. Exactly how the data is combined depends on the specific &lt;a href=&quot;syntax/join-operator&quot;&gt;join-operator&lt;/a&gt; and &lt;a href=&quot;syntax/join-constraint&quot;&gt;join-constraint&lt;/a&gt; used to connect the tables or subqueries together.</source>
          <target state="translated">FROM句にテーブルまたはサブクエリが1つしかない場合、SELECTステートメントで使用される入力データは、名前付きテーブルの内容です。FROM句に複数のテーブルまたはサブクエリがある場合、すべてのテーブルまたはサブクエリ、あるいはその両方の内容が単一のデータセットに結合され、単純なSELECTステートメントが処理されます。データが正確に結合される方法は、テーブルまたはサブクエリを接続するために使用される特定の&lt;a href=&quot;syntax/join-operator&quot;&gt;結合演算子&lt;/a&gt;と&lt;a href=&quot;syntax/join-constraint&quot;&gt;結合制約に&lt;/a&gt;依存します。</target>
        </trans-unit>
        <trans-unit id="4c64aa9b4e57f38edc6d2ba80d1689a5d372c4ee" translate="yes" xml:space="preserve">
          <source>If these routines are called from within the different thread than the one containing the application-defined function that received the &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; pointer, the results are undefined.</source>
          <target state="translated">これらのルーチンが、&lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt;ポインターを受け取ったアプリケーション定義関数を含むスレッドとは異なるスレッド内から呼び出された場合、結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="cd8848554ca2d7f3d01b722c239f1dc6287ba93f" translate="yes" xml:space="preserve">
          <source>If these routines are called from within the different thread than the one containing the application-defined function that received the &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; pointer, the results are undefined.</source>
          <target state="translated">これらのルーチンが、&lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt;ポインターを受け取ったアプリケーション定義関数を含むスレッドとは異なるスレッド内から呼び出された場合、結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="915164f8017ef4e64adbf0d45fa62da4e11e9b32" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro disables the &quot;deferred token&quot; optimization in &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;. The &quot;deferred token&quot; optimization avoids loading massive posting lists for terms that are in most documents of the collection and instead simply scans for those tokens in the document source. &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; should get exactly the same answer both with and without this optimization.</source>
          <target state="translated">このCプリプロセッサマクロが&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4の&lt;/a&gt;「遅延トークン」最適化を無効にする場合。 「据え置きトークン」の最適化により、コレクションのほとんどの文書にある用語の大量の投稿リストのロードが回避され、代わりに文書ソース内のそれらのトークンがスキャンされます。&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;は、この最適化の有無にかかわらず、まったく同じ答えを得るはずです。</target>
        </trans-unit>
        <trans-unit id="ae29c8f0136956324cb9875e314002993d7a9c98" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined and if the xDeviceCharacteristics method of &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object for a database file reports (via one of the &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt; bits) that the filesystem supports atomic writes and if a transaction involves a change to only a single page of the database file, then the transaction commits with just a single write request of a single page of the database and no rollback journal is created or written. On filesystems that support atomic writes, this optimization can result in significant speed improvements for small updates. However, few filesystems support this capability and the code paths that check for this capability slow down write performance on systems that lack atomic write capability, so this feature is disabled by default.</source>
          <target state="translated">このCプリプロセッサマクロが定義されており、データベースファイルの&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;オブジェクトのxDeviceCharacteristicsメソッドが（&lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt;ビットの1つを介して）ファイルシステムがアトミックな書き込みをサポートしていること、およびトランザクションにデータベースの単一ページのみの変更が含まれることを報告する場合ファイルの場合、トランザクションはデータベースの単一ページの単一の書き込み要求のみでコミットされ、ロールバックジャーナルは作成または書き込まれません。アトミックな書き込みをサポートするファイルシステムでは、この最適化により、小さな更新の速度が大幅に向上します。ただし、この機能をサポートするファイルシステムはほとんどなく、この機能をチェックするコードパスは、アトミック書き込み機能がないシステムでの書き込みパフォーマンスを低下させるため、この機能はデフォルトで無効になっています。</target>
        </trans-unit>
        <trans-unit id="f74239b5b9713fd263bba27dcb07765bb74b0239" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined, directory syncs are disabled. SQLite typically attempts to sync the parent directory when a file is deleted to ensure the directory entries are updated immediately on disk.</source>
          <target state="translated">この C プリプロセッサ マクロが定義されている場合、ディレクトリの同期は無効になります。SQLite は通常、ファイルが削除されたときに親ディレクトリの同期を試み、ディレクトリエントリがディスク上で即座に更新されるようにします。</target>
        </trans-unit>
        <trans-unit id="5737b83035ce500dcfa496d2b2b66e0845cad862" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined, large file support is disabled.</source>
          <target state="translated">このCプリプロセッサマクロが定義されている場合、ラージファイルのサポートは無効になります。</target>
        </trans-unit>
        <trans-unit id="262e2217c94b5b2f3ea64e55aebf18183a8f388a" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined, the &lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt; tokenizer in &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; is omitted from the build and is unavailable to applications.</source>
          <target state="translated">このC-プリプロセッサマクロが定義されている場合、&lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt;にトークナイザ&lt;a href=&quot;fts3&quot;&gt;FTS3が&lt;/a&gt;ビルドから省略及びアプリケーションに利用不可能です。</target>
        </trans-unit>
        <trans-unit id="39617688d9840b06235bc5d306b07bb0ba889ba9" translate="yes" xml:space="preserve">
          <source>If this C-preprocessor macro is defined, then extra code is included that allows SQLite to function on a filesystem that only support 8+3 filenames. If the value of this macro is 1, then the default behavior is to continue to use long filenames and to only use 8+3 filenames if the database connection is opened using &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; with the &quot;&lt;code&gt;8_3_names=1&lt;/code&gt;&quot; query parameter. If the value of this macro is 2, then the use of 8+3 filenames becomes the default but may be disabled on using the &lt;code&gt;8_3_names=0&lt;/code&gt; query parameter.</source>
          <target state="translated">このCプリプロセッサマクロが定義されている場合、8 + 3のファイル名のみをサポートするファイルシステムでSQLiteが機能できるようにする追加のコードが含まれます。このマクロの値が1の場合、デフォルトの動作では、長いファイル名を引き続き使用し、データベース接続が&quot; &lt;code&gt;8_3_names=1&lt;/code&gt; &quot;クエリパラメータを持つ&lt;a href=&quot;uri&quot;&gt;URIファイル名&lt;/a&gt;を使用して開かれている場合にのみ8 + 3ファイル名を使用します。このマクロの値が2の場合、8 + 3ファイル名の使用がデフォルトになりますが、 &lt;code&gt;8_3_names=0&lt;/code&gt; クエリパラメータを使用すると無効になる場合があります。</target>
        </trans-unit>
        <trans-unit id="ad3d89f2752a79cf47c58e04a726219583d11898" translate="yes" xml:space="preserve">
          <source>If this SELECT returns any rows at all, then SQLite concludes that deleting the row from the parent table would violate the foreign key constraint and returns an error. Similar queries may be run if the content of the parent key is modified or a new row is inserted into the parent table. If these queries cannot use an index, they are forced to do a linear scan of the entire child table. In a non-trivial database, this may be prohibitively expensive.</source>
          <target state="translated">この SELECT が行を全く返さない場合、SQLite は親テーブルから行を削除すると外部キー制約に違反すると結論付け、エラーを返します。親キーの内容が変更されたり、親テーブルに新しい行が挿入されたりした場合にも、同様のクエリが実行されることがあります。これらのクエリがインデックスを使用できない場合は、子テーブル全体のリニアスキャンを行う必要があります。非自明なデータベースでは、これは法外なコストがかかるかもしれません。</target>
        </trans-unit>
        <trans-unit id="1a76560d5f1317c75f52d66cf33f56778e31d3b4" translate="yes" xml:space="preserve">
          <source>If this expression returns a non-zero value N, then there exists an embedded NUL at the N-th character position. Thus to count the number fo rows that contain embedded NUL characters:</source>
          <target state="translated">この式が0以外の値Nを返す場合、N番目の文字位置に埋め込まれたNULが存在することになります。したがって、埋め込まれたNUL文字を含む行の数を数えることができます。</target>
        </trans-unit>
        <trans-unit id="5f0db89932b716eb4d510a7bedc168db8c08402a" translate="yes" xml:space="preserve">
          <source>If this extension is compiled with -DSQLITE_CKSUMVFS_STATIC and statically linked against the application, initialize it using a single API call as follows:</source>
          <target state="translated">この拡張機能が -DSQLITE_CKSUMVFS_STATIC でコンパイルされ、アプリケーションに対して静的にリンクされている場合は、次のように単一の API コールを使用して初期化します。</target>
        </trans-unit>
        <trans-unit id="d8ee4bc759bb4de0d55341a4133e995c0e985e4b" translate="yes" xml:space="preserve">
          <source>If this extension is compiled with the SQLITE_ENABLE_ICU pre-processor symbol defined, then there exists a built-in tokenizer named &quot;icu&quot; implemented using the ICU library. The first argument passed to the xCreate() method (see fts3_tokenizer.h) of this tokenizer may be an ICU locale identifier. For example &quot;tr_TR&quot; for Turkish as used in Turkey, or &quot;en_AU&quot; for English as used in Australia. For example:</source>
          <target state="translated">この拡張モジュールが SQLITE_ENABLE_ICU プリプロセッサシンボルを定義してコンパイルされている場合、ICU ライブラリを使用して実装された &quot;icu&quot; という名前の組み込みトークナイザーが存在します。このトークナイザーの xCreate()メソッド (fts3_tokenizer.h を参照)に渡される最初の引数は、ICU のロケール識別子である可能性があります。例えば、トルコで使われているトルコ語は &quot;tr_TR&quot;、オーストラリアで使われている英語は &quot;en_AU &quot;などです。例えば、トルコ語なら &quot;tr_TR&quot;、オーストラリアで使われている英語なら &quot;en_AU &quot;など。</target>
        </trans-unit>
        <trans-unit id="d023458a29576f7575443a7b9afec6275af3fcf1" translate="yes" xml:space="preserve">
          <source>If this function is called when the iterator does not point to a valid entry, SQLITE_MISUSE is returned and the output variables zeroed. Otherwise, SQLITE_OK is returned and the output variables populated as described above.</source>
          <target state="translated">イテレータが有効なエントリを指していない場合にこの関数が呼び出されると、SQLITE_MISUSEが返され、出力変数がゼロになります。そうでない場合は、SQLITE_OKが返され、上で説明したように出力変数が生成されます。</target>
        </trans-unit>
        <trans-unit id="575c4fba56a8b3b5c139b07c2f0bb05a15bdbd1b" translate="yes" xml:space="preserve">
          <source>If this function needs to obtain extra database locks before dirty pages can be flushed to disk, it does so. If those locks cannot be obtained immediately and there is a busy-handler callback configured, it is invoked in the usual manner. If the required lock still cannot be obtained, then the database is skipped and an attempt made to flush any dirty pages belonging to the next (if any) database. If any databases are skipped because locks cannot be obtained, but no other error occurs, this function returns SQLITE_BUSY.</source>
          <target state="translated">この関数は、ダーティページをディスクにフラッシュする前にデータベースのロックを追加で取得する必要がある場合、それを行います。これらのロックがすぐに取得できず、ビジーハンドラコールバックが設定されている場合は、通常の方法で呼び出されます。それでも必要なロックが得られない場合、そのデータベースはスキップされ、次の(もしあれば)データベースに属するダーティページのフラッシュが試みられます。ロックが取得できなかったためにデータベースがスキップされたが、他のエラーが発生しなかった場合、この関数は SQLITE_BUSY を返します。</target>
        </trans-unit>
        <trans-unit id="4a59fbb2ab0548034e0f0c93999e3d83e86e0a83" translate="yes" xml:space="preserve">
          <source>If this global variable is made to point to a string which is the name of a folder (a.k.a. directory), then all database files specified with a relative pathname and created or accessed by SQLite when using a built-in windows &lt;a href=&quot;#sqlite3_vfs&quot;&gt;VFS&lt;/a&gt; will be assumed to be relative to that directory. If this variable is a NULL pointer, then SQLite assumes that all database files specified with a relative pathname are relative to the current directory for the process. Only the windows VFS makes use of this global variable; it is ignored by the unix VFS.</source>
          <target state="translated">このグローバル変数がフォルダー（別名ディレクトリ）の名前である文字列を指すようにした場合、相対パス名で指定され、組み込みのWindows &lt;a href=&quot;#sqlite3_vfs&quot;&gt;VFS&lt;/a&gt;を使用するときにSQLiteによって作成またはアクセスされるすべてのデータベースファイルは、そのディレクトリを基準にしてください。この変数がNULLポインターの場合、SQLiteは、相対パス名で指定されたすべてのデータベースファイルがプロセスの現在のディレクトリからの相対パスであると想定します。 Windows VFSのみがこのグローバル変数を使用します。 UNIX VFSでは無視されます。</target>
        </trans-unit>
        <trans-unit id="84ebd8e9c186529f8ee21c34bc9c7d688ed08739" translate="yes" xml:space="preserve">
          <source>If this global variable is made to point to a string which is the name of a folder (a.k.a. directory), then all database files specified with a relative pathname and created or accessed by SQLite when using a built-in windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; will be assumed to be relative to that directory. If this variable is a NULL pointer, then SQLite assumes that all database files specified with a relative pathname are relative to the current directory for the process. Only the windows VFS makes use of this global variable; it is ignored by the unix VFS.</source>
          <target state="translated">このグローバル変数がフォルダー（別名ディレクトリ）の名前である文字列を指すようにした場合、相対パス名で指定され、組み込みのWindows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;を使用するときにSQLiteによって作成またはアクセスされるすべてのデータベースファイルは、そのディレクトリを基準にしてください。この変数がNULLポインターの場合、SQLiteは、相対パス名で指定されたすべてのデータベースファイルがプロセスの現在のディレクトリからの相対パスであると想定します。 Windows VFSのみがこのグローバル変数を使用します。 UNIX VFSでは無視されます。</target>
        </trans-unit>
        <trans-unit id="ae61adf99b3e9cfc86e28932de2b54c5d4c9e28e" translate="yes" xml:space="preserve">
          <source>If this global variable is made to point to a string which is the name of a folder (a.k.a. directory), then all temporary files created by SQLite when using a built-in &lt;a href=&quot;#sqlite3_vfs&quot;&gt;VFS&lt;/a&gt; will be placed in that directory. If this variable is a NULL pointer, then SQLite performs a search for an appropriate temporary file directory.</source>
          <target state="translated">このグローバル変数がフォルダー（別名ディレクトリー）の名前である文字列を指すようにすると、組み込みの&lt;a href=&quot;#sqlite3_vfs&quot;&gt;VFS&lt;/a&gt;を使用するときにSQLiteによって作成されたすべての一時ファイルがそのディレクトリーに配置されます。この変数がNULLポインターの場合、SQLiteは適切な一時ファイルディレクトリを検索します。</target>
        </trans-unit>
        <trans-unit id="2fef70c16016d67dc3025afd347c1e52be3b317a" translate="yes" xml:space="preserve">
          <source>If this global variable is made to point to a string which is the name of a folder (a.k.a. directory), then all temporary files created by SQLite when using a built-in &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; will be placed in that directory. If this variable is a NULL pointer, then SQLite performs a search for an appropriate temporary file directory.</source>
          <target state="translated">このグローバル変数がフォルダー（別名ディレクトリー）の名前である文字列を指すようにすると、組み込みの&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;を使用するときにSQLiteによって作成されたすべての一時ファイルがそのディレクトリーに配置されます。この変数がNULLポインターの場合、SQLiteは適切な一時ファイルディレクトリを検索します。</target>
        </trans-unit>
        <trans-unit id="377f589c93b8d1620f4832f74e589324c623fda3" translate="yes" xml:space="preserve">
          <source>If this interface is invoked outside the context of an xConnect or xCreate virtual table method then the behavior is undefined.</source>
          <target state="translated">このインターフェイスが xConnect または xCreate 仮想テーブルメソッドのコンテキスト外で呼び出された場合の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="16ae3ddca07ff1751105a0aea6145c79101d244a" translate="yes" xml:space="preserve">
          <source>If this macro is defined to a positive integer</source>
          <target state="translated">このマクロが正の整数に定義されている場合</target>
        </trans-unit>
        <trans-unit id="5cc647c8428edf625b094fb0de5d9a7c439f06d1" translate="yes" xml:space="preserve">
          <source>If this macro is defined, then the special &quot;$</source>
          <target state="translated">このマクロが定義されている場合、特別な「$</target>
        </trans-unit>
        <trans-unit id="53c0130971cedde038e298ffc488f5a86580ab11" translate="yes" xml:space="preserve">
          <source>If this option is defined, SQLite's built-in date and time manipulation functions are omitted. Specifically, the SQL functions julianday(), date(), time(), datetime() and strftime() are not available. The default column values CURRENT_TIME, CURRENT_DATE and CURRENT_TIMESTAMP are still available.</source>
          <target state="translated">このオプションが定義されている場合、SQLiteに組み込まれている日付と時刻の操作関数は省略されます。具体的には、SQL 関数 julianday()、date()、time()、datetime()、および strftime()は使用できません。デフォルトのカラム値である CURRENT_TIME、CURRENT_DATE、CURRENT_TIMESTAMP は引き続き利用可能です。</target>
        </trans-unit>
        <trans-unit id="3a2de06267117d8a8013c26631a2b4a79f2165b1" translate="yes" xml:space="preserve">
          <source>If this option is defined, the library cannot create or write to databases that support &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt;. Executing a &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;PRAGMA auto_vacuum&lt;/a&gt; statement is not an error (since unknown PRAGMAs are silently ignored), but does not return a value or modify the auto-vacuum flag in the database file. If a database that supports auto-vacuum is opened by a library compiled with this option, it is automatically opened in read-only mode.</source>
          <target state="translated">このオプションが定義されている場合、ライブラリは&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt;をサポートするデータベースを作成またはデータベースに書き込むことができません。&lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;PRAGMA auto_vacuum&lt;/a&gt;ステートメントの実行はエラーではありませんが（不明なPRAGMAは暗黙的に無視されるため）、値を返したり、データベースファイルの自動バキュームフラグを変更したりすることはありません。自動バキュームをサポートするデータベースが、このオプションでコンパイルされたライブラリーによって開かれた場合、そのデータベースは自動的に読み取り専用モードで開かれます。</target>
        </trans-unit>
        <trans-unit id="0d1cff91ceb786cc24acfd1c107d786b9aaa0367" translate="yes" xml:space="preserve">
          <source>If this option is defined, then &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; syntax is not recognized.</source>
          <target state="translated">このオプションが定義されている場合、&lt;a href=&quot;foreignkeys&quot;&gt;外部キー制約&lt;/a&gt;構文は認識されません。</target>
        </trans-unit>
        <trans-unit id="6e68b63912f5ef9b57357a53a1d6030e0a438ede" translate="yes" xml:space="preserve">
          <source>If this option is defined, then &lt;a href=&quot;gencol&quot;&gt;generated column&lt;/a&gt; syntax is not recognized.</source>
          <target state="translated">If this option is defined, then &lt;a href=&quot;gencol&quot;&gt;generated column&lt;/a&gt; syntax is not recognized.</target>
        </trans-unit>
        <trans-unit id="de1fe97e82a4364864c18ee6d16ca1ab17fe291c" translate="yes" xml:space="preserve">
          <source>If this option is defined, then it must also be defined when using the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; tool to generate a parse.c file. Because of this, this option may only be used when the library is built from source, not from the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; or from the collection of pre-packaged C files provided for non-Unix like platforms on the website.</source>
          <target state="translated">このオプションが定義されている場合は、&lt;a href=&quot;lemon&quot;&gt;レモンパーサージェネレーター&lt;/a&gt;ツールを使用してparse.cファイルを生成するときにも定義する必要があります。このため、このオプションは、ライブラリーがソースからビルドされた場合にのみ使用できます。&lt;a href=&quot;amalgamation&quot;&gt;アマガメーション&lt;/a&gt;や、Webサイト上の非UNIXのようなプラットフォーム用に提供されている事前にパッケージ化されたCファイルのコレクションからではありません。</target>
        </trans-unit>
        <trans-unit id="391001eddc6a6f9380d8efca6c5990bffd30c02d" translate="yes" xml:space="preserve">
          <source>If this option is enabled, then the alloca() memory allocator will be used in a few situations where it is appropriate. This results in a slightly smaller and faster binary. The SQLITE_USE_ALLOCA compile-time only only works, of course, on systems that support alloca().</source>
          <target state="translated">このオプションを有効にすると、alloca()メモリアロケータが適切ないくつかの状況で使用されるようになります。これにより、バイナリが少し小さくなり、より高速になります。SQLITE_USE_ALLOCA のコンパイル時にのみ機能するのは、もちろん alloca()をサポートしているシステムでのみです。</target>
        </trans-unit>
        <trans-unit id="0a7cb0c994326370629ee23298fc6078fa599fa4" translate="yes" xml:space="preserve">
          <source>If this option is enabled, then the alloca() memory allocator will be used in a few situations where it is appropriate. This results in a slightly smaller and faster binary. The SQLITE_USE_ALLOCA compile-time only works, of course, on systems that support alloca().</source>
          <target state="translated">このオプションを有効にすると、alloca()メモリアロケータが適切ないくつかの状況で使用されるようになります。その結果、バイナリが少し小さくなり、より高速になります。SQLITE_USE_ALLOCA コンパイル時に動作するのは、もちろん alloca()をサポートしているシステムでのみです。</target>
        </trans-unit>
        <trans-unit id="e396be7869391838487d1744007a3e656f8af09d" translate="yes" xml:space="preserve">
          <source>If this option is passed a non-zero argument, the &quot;.expert&quot; command generates similar data distribution statistics for all indexes considered based on PERCENT percent of the rows currently stored in each database table. For databases with unusual data distributions, this may lead to better index recommendations, particularly if the application intends to run ANALYZE.</source>
          <target state="translated">このオプションに0以外の引数を渡すと、&quot;.expert &quot;コマンドは、各データベーステーブルに現在格納されている行のPERCENTパーセントに基づいて、考慮されるすべてのインデックスについて同様のデータ分布統計を生成します。異常なデータ分布を持つデータベースでは、特にアプリケーションがANALYZEを実行しようとしている場合には、これがより良いインデックスの推奨につながるかもしれません。</target>
        </trans-unit>
        <trans-unit id="84432c7bc70fca55a254f66874dd4bc62fe9abea" translate="yes" xml:space="preserve">
          <source>If this option is present, then SQLite will use the isnan() function from the system math library. This is an alias for the &lt;a href=&quot;compile#isnan&quot;&gt;HAVE_ISNAN&lt;/a&gt; configuration option.</source>
          <target state="translated">このオプションが存在する場合、SQLiteはシステム数学ライブラリのisnan（）関数を使用します。これは、&lt;a href=&quot;compile#isnan&quot;&gt;HAVE_ISNAN&lt;/a&gt;構成オプションのエイリアスです。</target>
        </trans-unit>
        <trans-unit id="8be490fe1c118ec4e22a3ceeab9a17451a39a86c" translate="yes" xml:space="preserve">
          <source>If this option is present, then the built-in &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator will be case sensitive. This same effect can be achieved at run-time using the &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like pragma&lt;/a&gt;.</source>
          <target state="translated">このオプションが存在する場合、組み込みの&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;演算子では大文字と小文字が区別されます。これと同じ効果は、実行時に&lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_likeプラグマ&lt;/a&gt;を使用して実現できます。</target>
        </trans-unit>
        <trans-unit id="ada121bcb0877b4a8c48986ff56dc5ba81d63e98" translate="yes" xml:space="preserve">
          <source>If this routine has not been previously called or if the previous call had N less than one or a NULL pointer for P, then the PRNG is seeded using randomness obtained from the xRandomness method of the default &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. If the previous call to this routine had an N of 1 or more and a non-NULL P then the pseudo-randomness is generated internally and without recourse to the &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; xRandomness method.</source>
          <target state="translated">このルーチンが以前に呼び出されていない場合、または前の呼び出しでNが1未満か、PのNULLポインターがあった場合、PRNGは、デフォルトの&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトのxRandomnessメソッドから取得した乱数を使用してシードされます。このルーチンへの以前の呼び出しでNが1以上で、NULLでないPがあった場合、&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; xRandomnessメソッドに頼ることなく、疑似乱数が内部的に生成されます。</target>
        </trans-unit>
        <trans-unit id="37bc48a662f5023c1e8434007284ca1643b9979a" translate="yes" xml:space="preserve">
          <source>If this routine has not been previously called or if the previous call had N less than one or a NULL pointer for P, then the PRNG is seeded using randomness obtained from the xRandomness method of the default &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. If the previous call to this routine had an N of 1 or more and a non-NULL P then the pseudo-randomness is generated internally and without recourse to the &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; xRandomness method.</source>
          <target state="translated">このルーチンが以前に呼び出されていない場合、または前の呼び出しでNが1未満か、PのNULLポインターがあった場合、PRNGは、デフォルトの&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトのxRandomnessメソッドから取得した乱数を使用してシードされます。このルーチンへの以前の呼び出しでNが1以上で、NULLでないPがあった場合、&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; xRandomnessメソッドに頼ることなく、疑似乱数が内部的に生成されます。</target>
        </trans-unit>
        <trans-unit id="7e75d3fd5002bfcaea7e83bd9fd2a7a917209184" translate="yes" xml:space="preserve">
          <source>If this value is returned, any changes applied so far are rolled back and the call to sqlite3changeset_apply() returns SQLITE_ABORT.</source>
          <target state="translated">この値が返された場合、これまでに適用された変更はすべてロールバックされ、sqlite3changeset_apply()の呼び出しはSQLITE_ABORTを返します。</target>
        </trans-unit>
        <trans-unit id="aefcb4f212e79bade6ab9e99069db614c4e4b2ca" translate="yes" xml:space="preserve">
          <source>If tracing is enabled (by the sqlite3_trace()) interface, then the UTF-8 string contained in P4 is emitted on the trace callback. Or if P4 is blank, use the string returned by sqlite3_sql().</source>
          <target state="translated">(sqlite3_trace()インタフェースによって)トレースが有効になっている場合、P4に含まれるUTF-8文字列がトレースコールバックで出力されます。または、P4が空白の場合は、sqlite3_sql()によって返された文字列を使用します。</target>
        </trans-unit>
        <trans-unit id="3f4fc8020e070710f30d36574cc04f57550a8abc" translate="yes" xml:space="preserve">
          <source>If two database connections shared the same cache and the reader has enabled the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt;, then the reader will be able to see changes made by the writer before the writer transaction commits. The combined use of &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; and the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; is the only way that one database connection can see uncommitted changes on a different database connection. In all other circumstances, separate database connections are completely isolated from one another.</source>
          <target state="translated">2つのデータベース接続が同じキャッシュを共有し、リーダーが&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommittedプラグマ&lt;/a&gt;を有効にしている場合、リーダーは、ライタートランザクションがコミットする前にライターによって行われた変更を確認できます。併用&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュモード&lt;/a&gt;と&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;READ_UNCOMMITTEDプラグマは、&lt;/a&gt; 1つのデータベース接続が異なるデータベース接続にコミットされていない変更を見ることができる唯一の方法です。他のすべての状況では、個別のデータベース接続は互いに完全に分離されています。</target>
        </trans-unit>
        <trans-unit id="b41151cd8ed57f8a05f71e68d3e6f727b509adc0" translate="yes" xml:space="preserve">
          <source>If two or more distinct but shareable in-memory databases are needed in a single process, then the &lt;a href=&quot;uri#coreqp&quot;&gt;mode=memory&lt;/a&gt; query parameter can be used with a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; to create a named in-memory database:</source>
          <target state="translated">1つのプロセスで2つ以上の異なるが共有可能なインメモリデータベースが必要な場合は、&lt;a href=&quot;uri#coreqp&quot;&gt;mode = memory&lt;/a&gt;クエリパラメータを&lt;a href=&quot;uri&quot;&gt;URIファイル名&lt;/a&gt;と共に使用して、名前付きインメモリデータベースを作成できます。</target>
        </trans-unit>
        <trans-unit id="7c051c04a74b426b583f6b46003048b9ec27b20e" translate="yes" xml:space="preserve">
          <source>If two or more threads call one or more &lt;a href=&quot;#sqlite3_column_database_name&quot;&gt;column metadata interfaces&lt;/a&gt; for the same &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; and result column at the same time then the results are undefined.</source>
          <target state="translated">2つ以上のスレッドが同じ&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備済みステートメント&lt;/a&gt;と結果列に対して同時に1つ以上の&lt;a href=&quot;#sqlite3_column_database_name&quot;&gt;列メタデータインターフェイス&lt;/a&gt;を呼び出す場合、結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="3f3b1a7191faa957bd4b9a2df637334c8be60539" translate="yes" xml:space="preserve">
          <source>If two or more threads call one or more &lt;a href=&quot;column_database_name&quot;&gt;column metadata interfaces&lt;/a&gt; for the same &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; and result column at the same time then the results are undefined.</source>
          <target state="translated">2つ以上のスレッドが同じ&lt;a href=&quot;stmt&quot;&gt;準備済みステートメント&lt;/a&gt;と結果列に対して同時に1つ以上の&lt;a href=&quot;column_database_name&quot;&gt;列メタデータインターフェイス&lt;/a&gt;を呼び出す場合、結果は未定義です。</target>
        </trans-unit>
        <trans-unit id="f59e0a816231da9addc2b58ecf1aebf4318f03f1" translate="yes" xml:space="preserve">
          <source>If two or more threads call one or more of these routines against the same prepared statement and column at the same time then the results are undefined.</source>
          <target state="translated">2つ以上のスレッドが、同じ準備されたステートメントとカラムに対して、これらのルーチンのうちの1つ以上を同時に呼び出した場合、結果は未定義になります。</target>
        </trans-unit>
        <trans-unit id="47c7553b72e9db086338dfa731f7055b973ce5ac" translate="yes" xml:space="preserve">
          <source>If two processes have open connections to the same database file and one process closes its connection, unlinks the file, then creates a new database file in its place with the same name and reopens the new file, then the two processes will be talking to different database files with the same name. (Note that this is only possible on Posix and Posix-like systems that permit a file to be unlinked while it is still open for reading and writing. Windows does not allow this to occur.) Since rollback journals and WAL files are based on the name of the database file, the two different database files will share the same rollback journal or WAL file. A rollback or recovery for one of the databases might use content from the other database, resulting in corruption. A similar problem occurs if a database file is renamed while it is opened and a new file is created with the old name.</source>
          <target state="translated">2つのプロセスが同じデータベースファイルへの接続を開いていて、1つのプロセスがその接続を閉じ、そのファイルのリンクを解除し、その場所に同じ名前の新しいデータベースファイルを作成し、新しいファイルを再び開いた場合、2つのプロセスは同じ名前の異なるデータベースファイルと通信していることになります(これは、ファイルを読み書きするために開いたままでリンクを解除することを許可しているPosixやPosixに似たシステムでのみ可能です)。(これは、ファイルが読み書き可能な状態で開いている間にリンクを解除することを許可しているPosixやPosixに似たシステムでのみ可能であることに注意してください。Windowsでは、これは許可されていません)。ロールバックジャーナルとWALファイルはデータベースファイルの名前に基づいているので、2つの異なるデータベースファイルは同じロールバックジャーナルまたはWALファイルを共有します。一方のデータベースのロールバックやリカバリは、もう一方のデータベースのコンテンツを使用する可能性があり、破損の原因となります。同様の問題は、データベース ファイルを開いているときに名前が変更され、古い名前で新しいファイルが作成された場合にも発生します。</target>
        </trans-unit>
        <trans-unit id="0f73506a4d083541e30151f33df9ff76bf05c8d1" translate="yes" xml:space="preserve">
          <source>If using the MATCH or = operators, the expression to the left of the MATCH operator is usually the name of the FTS5 table (the exception is when &lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;specifying a column-filter&lt;/a&gt;). The expression on the right must be a text value specifying the term to search for. For the table-valued function syntax, the term to search for is specified as the first table argument. For example:</source>
          <target state="translated">MATCHまたは=演算子を使用する場合、MATCH演算子の左側の式は通常、FTS5テーブルの名前です（&lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;column-filterを指定する&lt;/a&gt;場合は例外です）。右側の式は、検索する用語を指定するテキスト値である必要があります。テーブル値関数構文の場合、検索する用語は最初のテーブル引数として指定されます。例えば：</target>
        </trans-unit>
        <trans-unit id="10c759f053d61c7e03ff959d29d1e1974783d209" translate="yes" xml:space="preserve">
          <source>If using the MinGW compiler, the command-line is this:</source>
          <target state="translated">MinGWコンパイラを使用している場合、コマンドラインはこのようになります。</target>
        </trans-unit>
        <trans-unit id="06877745f4f906674e7afae07a31cb3adf870f29" translate="yes" xml:space="preserve">
          <source>If using the amalgamation autoconf based build system, setting the CPPFLAGS environment variable while running the 'configure' script is an easy way to set these macros. For example, the following command:</source>
          <target state="translated">amalgamation autoconf ベースのビルドシステムを使用している場合、'configure' スクリプトを実行している間に CPPFLAGS 環境変数を設定すると、これらのマクロを設定する簡単な方法があります。例えば、以下のコマンドを実行します。</target>
        </trans-unit>
        <trans-unit id="c06d03a70a5b876ea7069032c87d9367a09e46c5" translate="yes" xml:space="preserve">
          <source>If when you try to load your library you get back an error message that says &quot;mach-o, but wrong architecture&quot; then you might need to add command-line options &quot;-arch i386&quot; or &quot;arch x86_64&quot; to gcc, depending on how your application is built.</source>
          <target state="translated">ライブラリを読み込もうとしたときに &quot;mach-o,but wrong architecture&quot; というエラーメッセージが返ってくる場合は、アプリケーションのビルド方法に応じて、gcc に &quot;-arch i386&quot; や &quot;arch x86_64&quot; というコマンドラインオプションを追加する必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="7cf9b897ab48ed18b82e59ac2a561abc36b27d81" translate="yes" xml:space="preserve">
          <source>If while attempting to detect a</source>
          <target state="translated">を検出しようとしている間に</target>
        </trans-unit>
        <trans-unit id="56ea56ee57997f44a3b4181f1b3a8efe3168e325" translate="yes" xml:space="preserve">
          <source>If xBestIndex returns &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, that does not indicate an error. Rather, SQLITE_CONSTRAINT indicates that the particular combination of input parameters specified should not be used in the query plan. The SQLITE_CONSTRAINT return is useful for &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; that have required parameters. If the aConstraint[].usable field is false for one of the required parameter, then the xBestIndex method should return SQLITE_CONSTRAINT.</source>
          <target state="translated">xBestIndexが返す場合&lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINTを&lt;/a&gt;、それはエラーを示すものではありません。むしろ、SQLITE_CONSTRAINTは、指定された入力パラメーターの特定の組み合わせをクエリプランで使用してはならないことを示します。 SQLITE_CONSTRAINTの戻り&lt;a href=&quot;vtab#tabfunc2&quot;&gt;値&lt;/a&gt;は、必須パラメーターを持つテーブル値関数に役立ちます。必須パラメーターの1つでaConstraint []。usableフィールドがfalseの場合、xBestIndexメソッドはSQLITE_CONSTRAINTを返す必要があります。</target>
        </trans-unit>
        <trans-unit id="f2ddd15ff69a5ac03ff2cdad02ade0037f75db16" translate="yes" xml:space="preserve">
          <source>If xRead() returns SQLITE_IOERR_SHORT_READ it must also fill in the unread portions of the buffer with zeros. A VFS that fails to zero-fill short reads might seem to work. However, failure to zero-fill short reads will eventually lead to database corruption.</source>
          <target state="translated">xRead()が SQLITE_IOERR_SHORT_READ を返す場合、バッファの未読部分もゼロで埋めなければなりません。ショートリードのゼロフィルに失敗したVFSはうまくいくように見えるかもしれません。しかし、ショートリードのゼロフィルに失敗すると、最終的にはデータベースの破損につながります。</target>
        </trans-unit>
        <trans-unit id="406e06acbef99d386159c93608eee295bbb8911c" translate="yes" xml:space="preserve">
          <source>If you &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST&lt;/a&gt; a string into a BLOB, then the entire length of the string is shown. For example:</source>
          <target state="translated">あなたがいる場合&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST&lt;/a&gt; BLOBに文字列を、その文字列の全体の長さが示されています。例えば：</target>
        </trans-unit>
        <trans-unit id="4c77d01ec7cf778a68ddf7a39c6762175e2b9a47" translate="yes" xml:space="preserve">
          <source>If you abuse the library by trying to call &lt;b&gt;sqlite_step&lt;/b&gt; inappropriately it will attempt return SQLITE_MISUSE. This can happen if you call sqlite_step() on the same virtual machine at the same time from two or more threads or if you call sqlite_step() again after it returned SQLITE_DONE or SQLITE_ERROR or if you pass in an invalid virtual machine pointer to sqlite_step(). You should not depend on the SQLITE_MISUSE return code to indicate an error. It is possible that a misuse of the interface will go undetected and result in a program crash. The SQLITE_MISUSE is intended as a debugging aid only - to help you detect incorrect usage prior to a mishap. The misuse detection logic is not guaranteed to work in every case.</source>
          <target state="translated">&lt;b&gt;sqlite_stepを&lt;/b&gt;不適切に&lt;b&gt;呼び出そ&lt;/b&gt;うとしてライブラリを悪用すると、&lt;b&gt;SQLITE_MISUSE&lt;/b&gt;が返されます。これは、2つ以上のスレッドから同時に同じ仮想マシンでsqlite_step（）を呼び出した場合、またはSQLITE_DONEまたはSQLITE_ERRORを返した後に再度sqlite_step（）を呼び出した場合、または無効な仮想マシンポインターをsqlite_step（ ）。エラーを示すためにSQLITE_MISUSE戻りコードに依存しないでください。インターフェイスの誤用が検出されず、プログラムがクラッシュする可能性があります。 SQLITE_MISUSEは、デバッグの補助としてのみ意図されています-事故の前に誤った使用法を検出するのに役立ちます。誤用検出ロジックは、すべてのケースで機能するとは限りません。</target>
        </trans-unit>
        <trans-unit id="873a7faf9a3abe0d1c1b374fb25f49d1d975c393" translate="yes" xml:space="preserve">
          <source>If you append the character '*' to the end of the pattern, then a prefix search is performed. For example:</source>
          <target state="translated">パターンの最後に文字'*'を追加すると、接頭辞検索が行われます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="feb267998fb090ad7c9de72555f7d36aa562a1a7" translate="yes" xml:space="preserve">
          <source>If you are a &quot;rustacean&quot; and feel that Rust already meets the preconditions listed above, and that SQLite should be recoded in Rust, then you are welcomed and encouraged to contact the SQLite developers privately and argue your case.</source>
          <target state="translated">もしあなたが &quot;rustacean &quot;で、Rust が上記の前提条件を既に満たしており、SQLite が Rust で再コード化されるべきだと感じているのであれば、個人的に SQLite 開発者に連絡して、あなたの主張を主張することを歓迎し、奨励します。</target>
        </trans-unit>
        <trans-unit id="abe76df81a0ba114f6ec2f514aa5a8bd31614980" translate="yes" xml:space="preserve">
          <source>If you are a devoted Git user, you can still easily access SQLite. This section gives some hints on how to do so.</source>
          <target state="translated">Git の熱心なユーザーであれば、SQLite に簡単にアクセスすることができます。このセクションでは、その方法についていくつかのヒントを紹介します。</target>
        </trans-unit>
        <trans-unit id="b343ba4a7d7f527696dab2d0f4840db430c944d2" translate="yes" xml:space="preserve">
          <source>If you are an SQLite user whose has stumbled over some quirk of SQLite that is not mentioned here, please send us an email so that we can document the problem.</source>
          <target state="translated">もしあなたがSQLiteユーザーで、ここに記載されていないSQLiteの奇妙な点に躓いてしまった場合は、その問題を文書化するためにメールを送ってください。</target>
        </trans-unit>
        <trans-unit id="5de71147613f21cf2bdcb3bcc197abf7747cdeb4" translate="yes" xml:space="preserve">
          <source>If you are using separate source files, name all of the source files instead of just the two amalgamation source files. Once this is done, commit your changes as follows:</source>
          <target state="translated">別々のソースファイルを使用している場合は、2つのアマルガムソースファイルだけではなく、すべてのソースファイルに名前を付けてください。これが完了したら、以下のように変更をコミットします。</target>
        </trans-unit>
        <trans-unit id="4850a90372994c2a6bc8e2907d79c1145e74bbe1" translate="yes" xml:space="preserve">
          <source>If you delete a lot of data and want to shrink the database file, run the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command. VACUUM will reconstruct the database from scratch. This will leave the database with an empty free-list and a file that is minimal in size. Note, however, that the VACUUM can take some time to run and it can use up to twice as much temporary disk space as the original file while it is running.</source>
          <target state="translated">大量のデータを削除し、データベースファイルを&lt;a href=&quot;lang_vacuum&quot;&gt;圧縮&lt;/a&gt;する場合は、VACUUMコマンドを実行します。 VACUUMはデータベースを最初から再構築します。これにより、データベースには空の空きリストと最小サイズのファイルが残ります。ただし、VACUUMの実行にはしばらく時間がかかり、実行中は元のファイルの最大2倍の一時ディスク容量を使用する可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5f248ef1c5726530e6b14bd3353f02b25fd1dbc4" translate="yes" xml:space="preserve">
          <source>If you delete the</source>
          <target state="translated">を削除した場合</target>
        </trans-unit>
        <trans-unit id="45dba72fc49e11d88cfbda6839af5580be8953a7" translate="yes" xml:space="preserve">
          <source>If you do not have a backup, recovery is very difficult. You might be able to find partial string data in a binary dump of the raw database file. Recovering numeric data might also be possible given special tools, though to our knowledge no such tools exist. SQLite is sometimes compiled with the &lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt; option which overwrites all deleted content with zeros. If that is the case then recovery is clearly impossible. Recovery is also impossible if you have run &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; since the data was deleted. If SQLITE_SECURE_DELETE is not used and VACUUM has not been run, then some of the deleted content might still be in the database file, in areas marked for reuse. But, again, there exist no procedures or tools that we know of to help you recover that data.</source>
          <target state="translated">バックアップがない場合、リカバリは非常に困難です。未加工のデータベースファイルのバイナリダンプで部分的な文字列データを見つけることができる場合があります。数値データの回復は、特別なツールがあれば可能かもしれませんが、私たちの知る限り、そのようなツールは存在しません。 SQLiteは、削除されたすべてのコンテンツをゼロで上書きする&lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt;オプションを使用してコンパイルされることがあります。その場合、回復は明らかに不可能です。データが削除されてから&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;を実行した場合も、リカバリは不可能です。 SQLITE_SECURE_DELETEが使用されておらず、VACUUMが実行されていない場合、削除されたコンテンツの一部は、再利用のマークが付けられた領域のデータベースファイルに残っている可能性があります。しかし、繰り返しになりますが、そのデータを回復するのに役立つ手順やツールはありません。</target>
        </trans-unit>
        <trans-unit id="6123d0cbcd49adc87278ebf33c0308d19e13c18e" translate="yes" xml:space="preserve">
          <source>If you do not want to use your web browser to view the new check-in, you can get some information from the command-line using commands like these:</source>
          <target state="translated">Webブラウザを使って新規チェックインを表示したくない場合は、以下のようなコマンドを使ってコマンドラインから情報を得ることができます。</target>
        </trans-unit>
        <trans-unit id="165e1548a7d4a581b8c9984a9f7ab5cdc62be5bb" translate="yes" xml:space="preserve">
          <source>If you do this immediately after creating a new database file, before anything else has been written into the file, then that might be all that you need to do. Otherwise, the API call above should be followed by:</source>
          <target state="translated">新しいデータベースファイルを作成した直後に、他の何かがファイルに書き込まれる前にこれを行う場合は、それだけで十分かもしれません。そうでない場合は、上記のAPIコールの後に</target>
        </trans-unit>
        <trans-unit id="c8e5a488a0f9459d060660cf0d22bea3c48ed8ca" translate="yes" xml:space="preserve">
          <source>If you feel that you need dynamic pointer type strings in your application, that is a strong indicator that you are misusing the pointer-passing interface. Your intended use may be unsafe. Please rethink your design. Determine if you really need to be passing pointers through SQL in the first place. Or perhaps find a different mechanism other than the pointer-passing interfaces described by this article.</source>
          <target state="translated">アプリケーションで動的なポインタ型の文字列が必要だと感じた場合、それはポインタ通過インタフェースを誤って使用していることを強く示しています。あなたの意図した使用は安全ではないかもしれません。設計を再考してください。そもそもポインタをSQLに渡す必要があるのかどうかを判断してください。あるいは、この記事で説明したポインタ・パス・インターフェイス以外の別のメカニズムを見つけてください。</target>
        </trans-unit>
        <trans-unit id="88a9f11dc162c0fbb6ecd06e339a9fb7195e5fab" translate="yes" xml:space="preserve">
          <source>If you find errors in either the documentation or the code, feel free to fix them and/or contact the author at &lt;a href=&quot;mailto:drh@hwaci.com&quot;&gt;drh@hwaci.com&lt;/a&gt;. Your bug fixes or suggestions are always welcomed.</source>
          <target state="translated">ドキュメントまたはコードのいずれかにエラーが見つかった場合は、自由に修正するか、作者（&lt;a href=&quot;mailto:drh@hwaci.com&quot;&gt;drh@hwaci.com）にお問い合わせください&lt;/a&gt;。バグ修正や提案はいつでも歓迎します。</target>
        </trans-unit>
        <trans-unit id="888116b604c695e34258cc3ceb95b003a7ab4815" translate="yes" xml:space="preserve">
          <source>If you have a backup copy of your database file, recover the information from your backup.</source>
          <target state="translated">データベースファイルのバックアップコピーがある場合は、バックアップから情報を復元します。</target>
        </trans-unit>
        <trans-unit id="882c38087164067f62c9c7b1c8a9cb99d1dcf2ef" translate="yes" xml:space="preserve">
          <source>If you have a database of large BLOBs, do you get better read performance when you store the complete BLOB content directly in the database or is it faster to store each BLOB in a separate file and store just the corresponding filename in the database?</source>
          <target state="translated">大規模なBLOBのデータベースを持っている場合、完全なBLOBの内容を直接データベースに格納した方が読み込みパフォーマンスが向上するのでしょうか?それとも、各BLOBを個別のファイルに格納し、対応するファイル名だけをデータベースに格納した方が速いのでしょうか?</target>
        </trans-unit>
        <trans-unit id="763f3c8f82a8dbfe2292008ca244c1681fbd52b1" translate="yes" xml:space="preserve">
          <source>If you have a script and you want to start debugging at some point half-way through that script, simply set a breakpoint in gdb (or whatever debugger you are using) on the test_breakpoint() function, and add a &quot;.breakpoint&quot; command where you want to stop. When you reach that first breakpoint, set whatever additional breakpoints are variable traces you need.</source>
          <target state="translated">スクリプトがあり、そのスクリプトの途中でデバッグを開始したい場合、test_breakpoint()関数で gdb (または使用しているデバッガ)にブレークポイントを設定し、停止したい場所に &quot;.breakpoint&quot; コマンドを追加するだけです。最初のブレークポイントに到達したら、必要に応じて追加のブレークポイントを変数トレースに設定します。</target>
        </trans-unit>
        <trans-unit id="a1693c0c5d23752d02c6e3b93f043c8eb31a26df" translate="yes" xml:space="preserve">
          <source>If you have done any assembly language programming or have worked with any kind of abstract machine before, all of these details should be familiar to you. So let's jump right in and start looking as some code.</source>
          <target state="translated">アセンブリ言語でプログラミングをしたことがある人や、以前に抽象的な機械を扱ったことがある人なら、これらの詳細はすべてお馴染みのものでしょう。それでは、すぐに飛び込んでコードを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="ec726a0b109ca2b2f984dbfe63a95238609005d5" translate="yes" xml:space="preserve">
          <source>If you intend to use this virtual table in cooperation with an &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; table (for spelling correction of search terms) then you might extract the vocabulary using an &lt;a href=&quot;fts3#fts4aux&quot;&gt;fts4aux&lt;/a&gt; table:</source>
          <target state="translated">この仮想テーブルを&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;テーブル（検索語のスペル修正用）と&lt;a href=&quot;fts3#fts4aux&quot;&gt;組み合わせて&lt;/a&gt;使用する場合は、fts4auxテーブルを使用して語彙を抽出できます。</target>
        </trans-unit>
        <trans-unit id="20f09458f074cbdfa69a4cd879b9a24a9c5ffaed" translate="yes" xml:space="preserve">
          <source>If you made NL to CR-NL line ending changes or space to tab indentation changes in the original baseline, make the same changes to the new source file.</source>
          <target state="translated">元のベースラインで NL から CR-NL への改行やスペースからタブのインデントを変更した場合は、新しいソース ファイルにも同じ変更を加えます。</target>
        </trans-unit>
        <trans-unit id="6938d0165858c470278846efb2784fece3e6d115" translate="yes" xml:space="preserve">
          <source>If you need an exact answer, you should not use binary64 floating-point values, in SQLite or in any other product. This is not an SQLite limitation. It is a mathematical limitation inherent in the design of floating-point numbers.</source>
          <target state="translated">正確な答えが必要な場合は、SQLiteでも他の製品でも、バイナリ64の浮動小数点値を使用してはいけません。これは SQLite の制限ではありません。これは浮動小数点数の設計に内在する数学的な制限です。</target>
        </trans-unit>
        <trans-unit id="5e4831ba155a21bf312a9328909ee6b27a5a08fb" translate="yes" xml:space="preserve">
          <source>If you need to verify that the SQLite source code that you have is authentic and has not been modified in any way (perhaps by an adversary) that can be done using a few simple command-line tools. At the root of the SQLite source tree is a file named &quot;manifest&quot;. The manifest file contains the name of every other file in the source tree together with either a SHA1 or SHA3-256 hash for that file. (SHA1 is used for older files and SHA3-256 for newer files.) You can write a script to extract these hashes and verify them against the source code files. The hash name for the check-in is just the SHA3-256 hash of the &quot;manifest&quot; file itself.</source>
          <target state="translated">あなたが持っているSQLiteソースコードが本物であり、(おそらく敵対者によって)いかなる方法でも変更されていないことを確認する必要がある場合は、いくつかのシンプルなコマンドラインツールを使用して行うことができます。SQLite ソースツリーのルートには、「マニフェスト」という名前のファイルがあります。マニフェストファイルには、ソースツリー内の他のすべてのファイルの名前と、そのファイルの SHA1 または SHA3-256 ハッシュが含まれています(古いファイルでは SHA1 が使用されます)。(SHA1 は古いファイルに、SHA3-256 は新しいファイルに使用されます。)これらのハッシュを抽出し、ソース コード ファイルと照合して検証するスクリプトを記述することができます。チェックインのためのハッシュ名は、単に「マニフェスト」ファイル自体の SHA3-256 ハッシュです。</target>
        </trans-unit>
        <trans-unit id="a95dfc6dc355d4bcfc654c806aedf507385d37e3" translate="yes" xml:space="preserve">
          <source>If you notice new CVEs associated with SQLite that are not in the table below, please bring them to the attention of the developers on the &lt;a href=&quot;https://sqlite.org/forum/about&quot;&gt;SQLite Forum&lt;/a&gt; so they can be added.</source>
          <target state="translated">以下の表にないSQLiteに関連付けられた新しいCVEに気付いた場合は、&lt;a href=&quot;https://sqlite.org/forum/about&quot;&gt;SQLiteフォーラムの&lt;/a&gt;開発者に知らせて、追加できるようにしてください。</target>
        </trans-unit>
        <trans-unit id="397118cfe02899896d93de7bdac7c4252da15fbe" translate="yes" xml:space="preserve">
          <source>If you really need to update an R-Tree based on complex queries against the same R-Tree, it is best to run the complex queries first and store the results in a temporary table, then update the R-Tree based on the values stored in the temporary table.</source>
          <target state="translated">本当に同じR-Treeに対する複雑なクエリに基づいてR-Treeを更新する必要がある場合は、最初に複雑なクエリを実行して結果を一時テーブルに格納し、その後、一時テーブルに格納された値に基づいてR-Treeを更新するのがベストです。</target>
        </trans-unit>
        <trans-unit id="5df7ef5af012df18a05531f4528bcf648f59acb3" translate="yes" xml:space="preserve">
          <source>If you remember nothing else about floating-point values, please don't forget this one key idea.</source>
          <target state="translated">浮動小数点値について何も覚えていない方は、この1つの重要な考え方を忘れないようにしてください。</target>
        </trans-unit>
        <trans-unit id="13da8fa523e1031c91ec41d25db356602a2c65ba" translate="yes" xml:space="preserve">
          <source>If you specify a column a width of 0, then the column width is automatically adjusted to be the maximum of three numbers: 10, the width of the header, and the width of the first row of data. This makes the column width self-adjusting. The default width setting for every column is this auto-adjusting 0 value.</source>
          <target state="translated">列の幅を0に指定した場合、列の幅は3つの数字の最大値になるように自動的に調整されます。10、ヘッダの幅、データの最初の行の幅の3つの数字の最大値になるように自動的に調整されます。これにより、カラムの幅は自己調整されます。すべてのカラムのデフォルトの幅の設定は、この自動調整された0の値です。</target>
        </trans-unit>
        <trans-unit id="473942d6eb4b318988fc65567c504fbaea4558ae" translate="yes" xml:space="preserve">
          <source>If you use version 2.6.0 or later of the library to open a database file that was originally created by version 2.5.6 or earlier, an attempt to rebuild the database into the new format will occur automatically. This can take some time for a large database. (Allow 1 or 2 seconds per megabyte of database under Unix - longer under Windows.) This format conversion is irreversible. It is &lt;strong&gt;strongly&lt;/strong&gt; suggested that you make a backup copy of older database files prior to opening them with version 2.6.0 or later of the library, in case there are errors in the format conversion logic.</source>
          <target state="translated">ライブラリのバージョン2.6.0以降を使用して、バージョン2.5.6以前で作成されたデータベースファイルを開く場合、データベースを新しい形式に再構築する試みが自動的に行われます。大規模なデータベースの場合、これには時間がかかることがあります。 （Unixではデータベースのメガバイトあたり1秒または2秒を許可します-Windowsでは長くなります。）このフォーマット変換は元に戻せません。&lt;strong&gt;強く&lt;/strong&gt;、あなたがた場合にフォーマット変換ロジックにエラーがある、以降のライブラリのバージョン2.6.0またはそれらを開く前に、古いデータベースファイルのバックアップコピーを作成することを示唆しました。</target>
        </trans-unit>
        <trans-unit id="57f756e359121a9c945b91158a295a20dd82b0db" translate="yes" xml:space="preserve">
          <source>If you want to configure the new project, type:</source>
          <target state="translated">新しいプロジェクトを設定したい場合は、タイプします。</target>
        </trans-unit>
        <trans-unit id="bda3419a07a7eb3933cb5a599b2b66398d9d3b26" translate="yes" xml:space="preserve">
          <source>If you want to know how the SQLite library works internally, you need to begin with a solid understanding of the Virtual Database Engine or VDBE. The VDBE occurs right in the middle of the processing stream (see the &lt;a href=&quot;arch&quot;&gt;architecture diagram&lt;/a&gt;) and so it seems to touch most parts of the library. Even parts of the code that do not directly interact with the VDBE are usually in a supporting role. The VDBE really is the heart of SQLite.</source>
          <target state="translated">SQLiteライブラリが内部でどのように機能するかを知りたい場合は、仮想データベースエンジンまたはVDBEをしっかりと理解することから始める必要があります。 VDBEは処理ストリームの真ん中に発生するため（&lt;a href=&quot;arch&quot;&gt;アーキテクチャ図を参照&lt;/a&gt;）、ライブラリのほとんどの部分に影響しているようです。 VDBEと直接対話しないコードの部分でさえ、通常はサポートの役割を果たします。 VDBEは本当にSQLiteの心臓部です。</target>
        </trans-unit>
        <trans-unit id="45ef57f77f1b898b089bfb8776638647a0457adc" translate="yes" xml:space="preserve">
          <source>If you want to use a keyword as a name, you need to quote it. There are four ways of quoting keywords in SQLite:</source>
          <target state="translated">キーワードを名前として使いたい場合は、そのキーワードを引用する必要があります。SQLiteでキーワードを引用するには4つの方法があります。</target>
        </trans-unit>
        <trans-unit id="33c132e45cdeb83d38d9892ca9d1c9494534573d" translate="yes" xml:space="preserve">
          <source>If you will be opening multiple database connections in your application, rather than invoking the extension entry points for each database connection separately, you might want to consider using the &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; interface to register your extensions and to cause them to be automatically started as each database connection is opened. You only have to register each extension once, and you can do so near the beginning of your main() routine. Using the &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; interface to register your extensions makes your extensions work as if they were built into the core SQLite - they automatically exist whenever you open a new database connection without needing to be initialized. Just be sure to complete any configuration you need to accomplish using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; before registering your extensions, since the &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; interface implicitly calls &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt;.</source>
          <target state="translated">アプリケーションで複数のデータベース接続を開く場合は、各データベース接続の拡張エントリポイントを個別に呼び出すのではなく、&lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension（）&lt;/a&gt;インターフェースを使用して拡張を登録し、それぞれの拡張を自動的に開始することを検討できます。データベース接続が開かれます。各拡張機能を登録する必要があるのは一度だけであり、main（）ルーチンの最初の方で登録できます。&lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension（）&lt;/a&gt;インターフェースを使用して拡張機能を登録すると、拡張機能はコアSQLiteに組み込まれたかのように機能します。初期化する必要なく新しいデータベース接続を開くと、拡張機能は自動的に存在します。使用するために必要な設定をすべて完了してください。&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config（）&lt;/a&gt;以来、拡張機能を登録する前に&lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension（）&lt;/a&gt;インタフェースは暗黙的に呼び出します&lt;a href=&quot;c3ref/initialize&quot;&gt;（）sqlite3_initializeを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c2a19b719f76f7faa9b10e93907a0fe776f85db7" translate="yes" xml:space="preserve">
          <source>If your data will grow to a size that you are uncomfortable or unable to fit into a single disk file, then you should select a solution other than SQLite. SQLite supports databases up to 140 terabytes in size, assuming you can find a disk drive and filesystem that will support 140-terabyte files. Even so, when the size of the content looks like it might creep into the terabyte range, it would be good to consider a centralized client/server database.</source>
          <target state="translated">データが1つのディスクファイルに収まりきらない、あるいは収まりきらないサイズにまで大きくなるのであれば、SQLite以外のソリューションを選択すべきです。SQLite は、140 テラバイトのファイルをサポートするディスク ドライブとファイルシステムがあれば、140 テラバイトまでのデータベースをサポートしています。それでも、コンテンツのサイズがテラバイトの範囲内に収まりそうな場合は、集中型のクライアント/サーバーデータベースを検討するのが良いでしょう。</target>
        </trans-unit>
        <trans-unit id="22b27cadfcf6135e72ec61c4781266a907795c13" translate="yes" xml:space="preserve">
          <source>If your data will grow to a size that you are uncomfortable or unable to fit into a single disk file, then you should select a solution other than SQLite. SQLite supports databases up to 281 terabytes in size, assuming you can find a disk drive and filesystem that will support 281-terabyte files. Even so, when the size of the content looks like it might creep into the terabyte range, it would be good to consider a centralized client/server database.</source>
          <target state="translated">データが1つのディスクファイルに収まりきらない、または収まりきらないサイズにまで大きくなる場合は、SQLite以外のソリューションを選択する必要があります。SQLiteは、281テラバイトのファイルをサポートするディスクドライブとファイルシステムがあれば、最大281テラバイトまでのデータベースをサポートしています。それでも、コンテンツのサイズがテラバイトの範囲に入りそうな場合は、集中型のクライアント/サーバーデータベースを検討するのが良いでしょう。</target>
        </trans-unit>
        <trans-unit id="b8bce6edf7a889c813c03d5b445472e1ddc49ad2" translate="yes" xml:space="preserve">
          <source>If your system defines a custom OS interface for SQLite or if you were using the undocumented &lt;b&gt;sqlite3_os_switch()&lt;/b&gt; interface, then you will need to make modifications in order to upgrade to SQLite version 3.5.0. This may seem painful at first glance. But as you look more closely, you will probably discover that your changes are made smaller and easier to understand and manage by the new SQLite interface. It is likely that your changes will now also work seamlessly with the SQLite amalgamation. You will no longer need to make any changes to the code SQLite source code. All of your changes can be effected by application code and you can link against a standard, unmodified version of the SQLite amalgamation. Furthermore, the OS interface layer, which was formerly undocumented, is now an officially support interface for SQLite. So you have some assurance that this will be a one-time change and that your new backend will continue to work in future versions of SQLite.</source>
          <target state="translated">システムがSQLiteのカスタムOSインターフェースを定義している場合、または文書化されていない&lt;b&gt;sqlite3_os_switch（）&lt;/b&gt;を使用していた場合&lt;b&gt;&lt;/b&gt;インターフェイス、SQLiteバージョン3.5.0にアップグレードするために変更を加える必要があります。これは一見苦痛に思えるかもしれません。しかし、よく見ると、新しいSQLiteインターフェイスによって変更が小さく、理解しやすく、管理しやすくなっていることに気付くでしょう。変更がSQLiteアマルガムとシームレスに機能するようになる可能性があります。コードSQLiteソースコードに変更を加える必要はもうありません。すべての変更はアプリケーションコードの影響を受ける可能性があり、SQLite融合の標準の変更されていないバージョンに対してリンクできます。さらに、以前はドキュメント化されていなかったOSインターフェイスレイヤーが、SQLiteの公式サポートインターフェイスになりました。したがって、これは1回限りの変更であり、新しいバックエンドがSQLiteの将来のバージョンでも引き続き機能することが保証されます。</target>
        </trans-unit>
        <trans-unit id="4d01491e7aaf0e3b7eeb3d6755bf0ba092a441ec" translate="yes" xml:space="preserve">
          <source>If zipfile() is invoked with 2 arguments, then the entry added to the archive is equivalent to that added by inserting the same two values into the &quot;name&quot; and &quot;data&quot; columns of a zipfile virtual table, with all other values set to NULL. If invoked with 4 arguments, it is equivalent to inserting the 4 values into the &quot;name&quot;, &quot;mode&quot;, &quot;mtime&quot; and &quot;data&quot; columns. In other words, the following pairs of queries are equivalent:</source>
          <target state="translated">zipfile()が 2 つの引数で起動された場合、 アーカイブに追加されるエントリは、同じ 2 つの値を zipfile 仮想テーブルの &quot;name&quot; と &quot;data&quot; カラムに挿入して追加したものと同等のものとなり、 他のすべての値は NULL に設定されます。4 つの引数で呼び出された場合、4 つの値を &quot;name&quot;,&quot;mode&quot;,&quot;mtime&quot;,&quot;data&quot; の列に挿入するのと同じことになります。言い換えれば、以下のペアのクエリが等価である。</target>
        </trans-unit>
        <trans-unit id="d49c9a42ebbe9cba3927bb51a35d92fe353713e9" translate="yes" xml:space="preserve">
          <source>If, as part of the</source>
          <target state="translated">の一部として</target>
        </trans-unit>
        <trans-unit id="1b931ae5cbce5d6c96daf33260c2b72ee5539dbd" translate="yes" xml:space="preserve">
          <source>If, while opening a</source>
          <target state="translated">を開いている間に</target>
        </trans-unit>
        <trans-unit id="f48c9c6740ea7cbd9ee32d778ecff2f9da591ab1" translate="yes" xml:space="preserve">
          <source>IfNoHope</source>
          <target state="translated">IfNoHope</target>
        </trans-unit>
        <trans-unit id="0d430ae72e07c71cbfc6aac6b856ba69c4a14902" translate="yes" xml:space="preserve">
          <source>IfNot</source>
          <target state="translated">IfNot</target>
        </trans-unit>
        <trans-unit id="f975ef3b4d80471cd49ea9ce8bd7a669078224d8" translate="yes" xml:space="preserve">
          <source>IfNotOpen</source>
          <target state="translated">IfNotOpen</target>
        </trans-unit>
        <trans-unit id="d2a091305f84e463b224fd2549c504926b658103" translate="yes" xml:space="preserve">
          <source>IfNotZero</source>
          <target state="translated">IfNotZero</target>
        </trans-unit>
        <trans-unit id="8ea5813d833284a6b426730c347d4a031b76be44" translate="yes" xml:space="preserve">
          <source>IfNullRow</source>
          <target state="translated">IfNullRow</target>
        </trans-unit>
        <trans-unit id="7661d111573d853c18bf38582f4762e932f703e7" translate="yes" xml:space="preserve">
          <source>IfPos</source>
          <target state="translated">IfPos</target>
        </trans-unit>
        <trans-unit id="a6bb95ea00b2b20f56a2debeb7afeb897471ef50" translate="yes" xml:space="preserve">
          <source>IfSmaller</source>
          <target state="translated">IfSmaller</target>
        </trans-unit>
        <trans-unit id="91d8cebb7b70f29e3262ce44bfc944c449089a8d" translate="yes" xml:space="preserve">
          <source>Ignore extra whitespace at the end of of &quot;.&quot; commands in the shell.</source>
          <target state="translated">シェル内の &quot;.&quot; コマンドの末尾にある余分な空白を無視するようにしました。</target>
        </trans-unit>
        <trans-unit id="d609bda3312485a36bcab24d9a33ae880a4d9c03" translate="yes" xml:space="preserve">
          <source>Immediately after an iterator is created by sqlite3changeset_start(), it does not point to any change in the changeset. Assuming the changeset is not empty, the first call to this function advances the iterator to point to the first change in the changeset. Each subsequent call advances the iterator to point to the next change in the changeset (if any). If no error occurs and the iterator points to a valid change after a call to sqlite3changeset_next() has advanced it, SQLITE_ROW is returned. Otherwise, if all changes in the changeset have already been visited, SQLITE_DONE is returned.</source>
          <target state="translated">sqlite3changeset_start()によってイテレータが作成された直後は、チェンジセット内のいかなる変更も指し示しません。チェンジセットが空ではないと仮定して、この関数の最初の呼び出しは、チェンジセットの最初の変更を指すようにイテレータを進めます。それ以降の各呼び出しは、チェンジセット内の次の変更点を指すようにイテレータを進めます(もしあれば)。エラーが発生せず、sqlite3changeset_next()が呼び出された後にイテレータが有効な変更を指し示す場合、SQLITE_ROWが返されます。そうでなければ、チェンジセット内のすべての変更がすでに訪問されている場合、SQLITE_DONEが返されます。</target>
        </trans-unit>
        <trans-unit id="49deaa07b4de652a28623d07d5618cb8f1e55666" translate="yes" xml:space="preserve">
          <source>Immediately following the wal-header are zero or more frames. Each frame consists of a 24-byte frame-header followed by a</source>
          <target state="translated">wal-headerの直後には、0個以上のフレームがある。各フレームは、24バイトのフレームヘッダの後に</target>
        </trans-unit>
        <trans-unit id="efc77ef3528cb380e78002c642146ddfcb72a6c8" translate="yes" xml:space="preserve">
          <source>Implement a procedure that calls &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; and passes it a pointer to the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; structure from the previous step. This procedure is probably the only exported symbol in the source file that implements your VFS.</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（）&lt;/a&gt;を呼び出し、前の手順の&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;構造体へのポインターを渡すプロシージャを実装します。この手順は、おそらくVFSを実装するソースファイル内の唯一のエクスポートされたシンボルです。</target>
        </trans-unit>
        <trans-unit id="5f991f27713d088110dc4560a5b48613a2e55fa7" translate="yes" xml:space="preserve">
          <source>Implement the &quot;LIMIT ... OFFSET ...&quot; clause on SELECT statements.</source>
          <target state="translated">SELECT文に「LIMIT ...OFFSET ...」句を実装しました。</target>
        </trans-unit>
        <trans-unit id="cb1780300fa34dfe12b3de8afb5a8d426d248748" translate="yes" xml:space="preserve">
          <source>Implement the methods required by the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;オブジェクトが必要とするメソッドを実装します。</target>
        </trans-unit>
        <trans-unit id="edbf1d07115719c5c7e93d86f1046b341948dbde" translate="yes" xml:space="preserve">
          <source>Implement the other methods required by &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfsが&lt;/a&gt;必要とする他のメソッドを実装します。</target>
        </trans-unit>
        <trans-unit id="a8b02a72a8b5be24e42656704837d215920a00aa" translate="yes" xml:space="preserve">
          <source>Implement the xOpen method that opens a file and populates an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object, including setting pMethods to point to the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object from the previous step.</source>
          <target state="translated">前の手順の&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;オブジェクトを指すようにpMethodsを設定するなど、ファイルを開いて&lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;オブジェクトにデータを入力するxOpenメソッドを実装します。</target>
        </trans-unit>
        <trans-unit id="87cdff8728ab99514f76ab384b99b3f529310cf0" translate="yes" xml:space="preserve">
          <source>Implementation Limits For SQLite</source>
          <target state="translated">SQLite の実装の限界</target>
        </trans-unit>
        <trans-unit id="32808d9f543dc0758af6de0786717c61ede1f9c3" translate="yes" xml:space="preserve">
          <source>Implementations of aggregate SQL functions use this routine to allocate memory for storing their state.</source>
          <target state="translated">集約SQL関数の実装では、このルーチンを使用して、その状態を格納するためのメモリを割り当てます。</target>
        </trans-unit>
        <trans-unit id="7165ad4b3d6ce30cae4f1408c3a0f8924f93a699" translate="yes" xml:space="preserve">
          <source>Implementing a custom auxiliary function is similar to implementing a &lt;a href=&quot;appfunc&quot;&gt;scalar SQL function&lt;/a&gt;. The implementation should be a C function of type fts5_extension_function, defined as follows:</source>
          <target state="translated">Implementing a custom auxiliary function is similar to implementing a &lt;a href=&quot;appfunc&quot;&gt;scalar SQL function&lt;/a&gt;. The implementation should be a C function of type fts5_extension_function, defined as follows:</target>
        </trans-unit>
        <trans-unit id="4018bcd662e8105cb957cfc5a507fd128f58cc71" translate="yes" xml:space="preserve">
          <source>Implementing a custom auxiliary function is similar to implementing a &lt;a href=&quot;c3ref/create_function&quot;&gt;scalar SQL function&lt;/a&gt;. The implementation should be a C function of type fts5_extension_function, defined as follows:</source>
          <target state="translated">カスタム補助関数の実装は、&lt;a href=&quot;c3ref/create_function&quot;&gt;スカラーSQL関数の&lt;/a&gt;実装に似ています。実装は、次のように定義されたタイプfts5_extension_functionのC関数である必要があります。</target>
        </trans-unit>
        <trans-unit id="cf816f713b7837e18241382d77dfd40a1b6bacf3" translate="yes" xml:space="preserve">
          <source>Implicit versus explicit transactions</source>
          <target state="translated">暗黙の取引と明示の取引</target>
        </trans-unit>
        <trans-unit id="2f1059e48758f0fdc4ddd1f86b6fae46066d008b" translate="yes" xml:space="preserve">
          <source>Important bug fix: the IN operator was not working if either the left-hand or right-hand side was derived from an INTEGER PRIMARY KEY.</source>
          <target state="translated">重要なバグ修正:左側または右側のどちらかが INTEGER PRIMARY KEY から派生している場合に IN 演算子が動作していませんでした。</target>
        </trans-unit>
        <trans-unit id="a0fe78ecda103e8930771647f6dec46b0b349000" translate="yes" xml:space="preserve">
          <source>Impose A Limit On Heap Size</source>
          <target state="translated">ヒープサイズに制限をかける</target>
        </trans-unit>
        <trans-unit id="ed65a595437d44d40ac23326bd1b47c2bed21cbd" translate="yes" xml:space="preserve">
          <source>Imposter Tables</source>
          <target state="translated">インポスターテーブル</target>
        </trans-unit>
        <trans-unit id="8bd676db829fa1254e9904aed550e4eaa10267fe" translate="yes" xml:space="preserve">
          <source>Imposter tables are intended for analysis and debugging only. This is not a feature that most application developers should understand or even know about. Imposter tables are for experts only.</source>
          <target state="translated">Imposterテーブルは、分析とデバッグのみを目的としています。これは、ほとんどのアプリケーション開発者が理解すべき機能ではありませんし、知るべき機能でもありません。インポスターテーブルは、エキスパートのみを対象としています。</target>
        </trans-unit>
        <trans-unit id="310974bd6288a19d56c62511f50674a5f6b79b46" translate="yes" xml:space="preserve">
          <source>Improper use of imposter tables can cause index corruption, though any corruption created this way can be fixed by running &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_reindex&quot;&gt;偽の&lt;/a&gt;テーブルを不適切に使用すると、インデックスが破損する可能性がありますが、この方法で作成された破損はREINDEXを実行することで修正できます。</target>
        </trans-unit>
        <trans-unit id="7cc4395a9bbe14f613da8e2834455cc8120ab269" translate="yes" xml:space="preserve">
          <source>Improve the &lt;a href=&quot;optoverview#omitnoopjoin&quot;&gt;omit-left-join optimization&lt;/a&gt; so that it works in cases where the right-hand table is UNIQUE but not necessarily NOT NULL.</source>
          <target state="translated">omit &lt;a href=&quot;optoverview#omitnoopjoin&quot;&gt;-left-join最適化を&lt;/a&gt;改善して、右側のテーブルが一意であるが必ずしもNOT NULLである必要がない場合に機能するようにします。</target>
        </trans-unit>
        <trans-unit id="15dafad2713cbb23a2ff9f35c0397160bab08c72" translate="yes" xml:space="preserve">
          <source>Improve the &lt;a href=&quot;optoverview#pushdown&quot;&gt;push-down optimization&lt;/a&gt; so that it works for many LEFT JOINs.</source>
          <target state="translated">&lt;a href=&quot;optoverview#pushdown&quot;&gt;プッシュダウンの最適化を&lt;/a&gt;改善して、多くのLEFT JOINで機能するようにします。</target>
        </trans-unit>
        <trans-unit id="115d57ca1c0c67b9c62b8627805bc54cd437ed61" translate="yes" xml:space="preserve">
          <source>Improve the format of the &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; raw output, so that it gives better information about the query plan and about the relationships between the various components of the plan.</source>
          <target state="translated">&lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLANの&lt;/a&gt; raw出力のフォーマットを改善して、クエリプランおよびプランのさまざまなコンポーネント間の関係についてのより良い情報を提供するようにします。</target>
        </trans-unit>
        <trans-unit id="14bd38dceda1ed2c01f162d1f3444a0f4f8b3ecd" translate="yes" xml:space="preserve">
          <source>Improve the performance of fts3/4 queries that use the OR operator and at least one auxiliary fts function.</source>
          <target state="translated">OR演算子と少なくとも1つの補助fts関数を使用するfts3/4クエリのパフォーマンスを改善しました。</target>
        </trans-unit>
        <trans-unit id="b9c8f318457693f2fa88c903d8d43102377e8c69" translate="yes" xml:space="preserve">
          <source>Improve the performance of the &lt;a href=&quot;lang_corefunc#replace&quot;&gt;replace() SQL function&lt;/a&gt; for cases where there are many substitutions on megabyte-sized strings, in an attempt to avoid OSSFuzz timeouts during testing. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/fab2c2b07b5d3&quot;&gt;fab2c2b07b5d3&lt;/a&gt;</source>
          <target state="translated">テスト中のOSSFuzzタイムアウトを回避するために、メガバイトサイズの文字列で多くの置換が行われる場合の&lt;a href=&quot;lang_corefunc#replace&quot;&gt;replace（）SQL関数&lt;/a&gt;のパフォーマンスを改善します。チェックイン&lt;a href=&quot;https://www.sqlite.org/src/info/fab2c2b07b5d3&quot;&gt;fab2c2b07b5d3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="018ed5007819cc6bdecc581d33162266f7dd3fe7" translate="yes" xml:space="preserve">
          <source>Improved Concurrency</source>
          <target state="translated">並行性の向上</target>
        </trans-unit>
        <trans-unit id="072e9878a7002455b6aee44f48f435995e934eb5" translate="yes" xml:space="preserve">
          <source>Improved Concurrency.</source>
          <target state="translated">並行性の向上。</target>
        </trans-unit>
        <trans-unit id="fd596055fe2374f07cb22e2ed1eddaf72d523d42" translate="yes" xml:space="preserve">
          <source>Improved accuracy of floating-point conversions using &quot;long double&quot;.</source>
          <target state="translated">long double」を使用した浮動小数点変換の精度を向上させました。</target>
        </trans-unit>
        <trans-unit id="93fc56155be2598f9cbcf49e841b4a0140cf2c72" translate="yes" xml:space="preserve">
          <source>Improved algorithm for running queries with both an ORDER BY and a LIMIT where only the inner-most loop naturally generates rows in the correct order.</source>
          <target state="translated">ORDER BYとLIMITの両方を使用してクエリを実行する際に、最内周ループだけが正しい順序で行を自然に生成するようにアルゴリズムを改良しました。</target>
        </trans-unit>
        <trans-unit id="b070ecb9dcd3bd88a65a96d0f66e5d97c46345dc" translate="yes" xml:space="preserve">
          <source>Improved concurrency.</source>
          <target state="translated">並行性が向上しました。</target>
        </trans-unit>
        <trans-unit id="9f23829b58c284f668ccf3661f99fc3dbbec1e58" translate="yes" xml:space="preserve">
          <source>Improved crash-robustness: write the database page size into the rollback journal header.</source>
          <target state="translated">クラッシュ・ロバスト性の向上:データベースのページサイズをロールバック・ジャーナル・ヘッダに記述するようにしました。</target>
        </trans-unit>
        <trans-unit id="7321289816f2bf6478248e1de203f755159291e2" translate="yes" xml:space="preserve">
          <source>Improved de-quoting of column names for &lt;a href=&quot;lang_createtable#createtabas&quot;&gt;CREATE TABLE AS&lt;/a&gt; statements with an aggregate query on the right-hand side.</source>
          <target state="translated">右側に集約クエリがある&lt;a href=&quot;lang_createtable#createtabas&quot;&gt;CREATE TABLE AS&lt;/a&gt;ステートメントの列名のクォートの改善。</target>
        </trans-unit>
        <trans-unit id="bf0fc640800a9514f6d8718203e257a7690d605b" translate="yes" xml:space="preserve">
          <source>Improved error detection of misused aggregate functions.</source>
          <target state="translated">誤用された集計関数のエラー検出を改善しました。</target>
        </trans-unit>
        <trans-unit id="10bc21bc5dd5e57a67add58ea3202819c9a3c931" translate="yes" xml:space="preserve">
          <source>Improved error messages for &quot;foreign key mismatch&quot; showing the names of the two tables involved.</source>
          <target state="translated">外部キーの不一致」のエラーメッセージに、関係する2つのテーブル名を表示するようにしました。</target>
        </trans-unit>
        <trans-unit id="90dbb37d863c75537960cc5646693be15d517e85" translate="yes" xml:space="preserve">
          <source>Improved error messages for invalid boolean arguments to dot-commands in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;コマンドラインシェルの&lt;/a&gt;ドットコマンドに対する無効なブール引数のエラーメッセージが改善されました。</target>
        </trans-unit>
        <trans-unit id="b0dec14662a3a9f70430b0cb1619e2a60b783318" translate="yes" xml:space="preserve">
          <source>Improved error messages in the &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; extension.</source>
          <target state="translated">&lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;拡張機能のエラーメッセージが改善されました。</target>
        </trans-unit>
        <trans-unit id="2c62ff1f4b8293cf16ee945ea648937c03b9bc58" translate="yes" xml:space="preserve">
          <source>Improved fuzz-testing of database files, with fixes for problems found.</source>
          <target state="translated">データベースファイルのファズテストを改善し、見つかった問題を修正しました。</target>
        </trans-unit>
        <trans-unit id="26cc1d230c175a8810d6dd909c46be8d110c203b" translate="yes" xml:space="preserve">
          <source>Improved name resolution for deeply nested queries.</source>
          <target state="translated">深い入れ子になったクエリの名前解決が改善されました。</target>
        </trans-unit>
        <trans-unit id="d3565d7b7ed6ef82845a8772788a705a908dc7c3" translate="yes" xml:space="preserve">
          <source>Improved optimization of &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST&lt;/a&gt; operators.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST&lt;/a&gt;演算子の最適化の改善。</target>
        </trans-unit>
        <trans-unit id="a23eee66d3ed2b6341f9511337eea95095e21556" translate="yes" xml:space="preserve">
          <source>Improved optimization of AND and OR operators when one or the other operand is a constant.</source>
          <target state="translated">一方または他方のオペランドが定数である場合のAND演算子およびOR演算子の最適化を改善しました。</target>
        </trans-unit>
        <trans-unit id="524c0e2c2353a4bf3f7178e269f56a6cac4ecf9b" translate="yes" xml:space="preserve">
          <source>Improved optimization of ORDER BY clauses on compound queries.</source>
          <target state="translated">複合クエリのORDER BY句の最適化を改善しました。</target>
        </trans-unit>
        <trans-unit id="af8c59932cd987b7607835b656e726f3dcea902b" translate="yes" xml:space="preserve">
          <source>Improved optimization of aggregate subqueries contained within an aggregate query.</source>
          <target state="translated">アグリゲートクエリ内に含まれるアグリゲートサブクエリの最適化が改善されました。</target>
        </trans-unit>
        <trans-unit id="d664cf7cb7a8aa891620cace778bbb7e18301125" translate="yes" xml:space="preserve">
          <source>Improved optimization of queries containing aggregate min() or max().</source>
          <target state="translated">集約min()またはmax()を含むクエリの最適化が改善されました。</target>
        </trans-unit>
        <trans-unit id="aa1222b8dcd6d3acb1bb29b90eb9192b7d6106ad" translate="yes" xml:space="preserve">
          <source>Improved performance of queries like &quot;SELECT min(x) FROM t WHERE y IN (?,?,?)&quot; assuming an index on t(x,y).</source>
          <target state="translated">t(x,y)上のインデックスを仮定した「SELECT min(x)FROM t WHERE y IN (?,?,?)」のようなクエリのパフォーマンスが改善されました。</target>
        </trans-unit>
        <trans-unit id="84a557fad116fe49221d1a9424a92f1e575e49e1" translate="yes" xml:space="preserve">
          <source>Improved performance of queries with many OR-connected terms in the WHERE clause that can all be indexed.</source>
          <target state="translated">すべてのインデックスを作成できるWHERE句で、多くのOR接続語を持つクエリのパフォーマンスを向上させました。</target>
        </trans-unit>
        <trans-unit id="fc268c97ccbef9521d6905694e7c21645578065f" translate="yes" xml:space="preserve">
          <source>Improved pthreads detection in configure scripts.</source>
          <target state="translated">configureスクリプトでのpthreadの検出を改善しました。</target>
        </trans-unit>
        <trans-unit id="17ac50232b81e80729264e903268e1bebc9e53d7" translate="yes" xml:space="preserve">
          <source>Improved query plan optimization when the DISTINCT keyword is present.</source>
          <target state="translated">DISTINCTキーワードが存在する場合のクエリプランの最適化を改善しました。</target>
        </trans-unit>
        <trans-unit id="59b96d30821cc9cbdef8a394c82f7fd97d223fd7" translate="yes" xml:space="preserve">
          <source>Improved resistance against goofy query planner decisions caused by incomplete or incorrect modifications to the &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt; table by the application.</source>
          <target state="translated">アプリケーションによる&lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt;テーブルの不完全または誤った変更によって引き起こされる、間抜けなクエリプランナーの決定に対する耐性の向上。</target>
        </trans-unit>
        <trans-unit id="6b8ef39e97edafb5ec621a586930697f00cfaa0e" translate="yes" xml:space="preserve">
          <source>Improved response to out-of-memory errors</source>
          <target state="translated">メモリ切れエラーへの対応が改善されました。</target>
        </trans-unit>
        <trans-unit id="5ae15f37694ee149c6eea70b18fae46fd07528e4" translate="yes" xml:space="preserve">
          <source>Improved robustness against corrupt database files.</source>
          <target state="translated">破損したデータベースファイルに対するロバスト性を向上させました。</target>
        </trans-unit>
        <trans-unit id="166028811fd163330b2455278e9c44de42779fbe" translate="yes" xml:space="preserve">
          <source>Improved support for Cygwin.</source>
          <target state="translated">Cygwinのサポートを強化しました。</target>
        </trans-unit>
        <trans-unit id="4c53e2cba5a1410927dfe514c0901b0fd71f140c" translate="yes" xml:space="preserve">
          <source>Improved support for using the STDCALL calling convention in winsqlite3.dll.</source>
          <target state="translated">winsqlite3.dllでのSTDCALL呼び出し規則の使用のサポートを改善しました。</target>
        </trans-unit>
        <trans-unit id="92763dc3583bdd282b9026c7f80e9e51775413fc" translate="yes" xml:space="preserve">
          <source>Improved syntax error messages in the parser</source>
          <target state="translated">パーサーでの構文エラーメッセージの改善</target>
        </trans-unit>
        <trans-unit id="35f950df2561f1db8f684a7b33f41fde15c8c04c" translate="yes" xml:space="preserve">
          <source>Improved test coverage</source>
          <target state="translated">テストカバレッジの向上</target>
        </trans-unit>
        <trans-unit id="6fb91ee1a232fc876617f991f25282c326c1cf11" translate="yes" xml:space="preserve">
          <source>Improved test coverage. Fixed a few obscure bugs found by the improved tests.</source>
          <target state="translated">テスト範囲を改善しました。改良されたテストで見つかったいくつかの不明瞭なバグを修正しました。</target>
        </trans-unit>
        <trans-unit id="5177fb86b97cfe6466bc589640835c3dab84ade3" translate="yes" xml:space="preserve">
          <source>Improved the cost estimation for an index scan which includes a WHERE clause that can be partially or fully evaluated using columns in the index and without having to do a table lookup. This fixes a performance regression that occurred for some obscure queries following the ORDER BY LIMIT optimization introduced in &lt;a href=&quot;#version_3_12_0&quot;&gt;version 3.12.0&lt;/a&gt;.</source>
          <target state="translated">インデックスの列を使用して部分的または完全に評価できるWHERE句を含むインデックススキャンのコスト見積もりを改善しました。テーブルルックアップを実行する必要はありません。これにより、&lt;a href=&quot;#version_3_12_0&quot;&gt;バージョン3.12.0で&lt;/a&gt;導入されたORDER BY LIMIT最適化に続くいくつかのあいまいなクエリで発生したパフォーマンスの低下が修正されます。</target>
        </trans-unit>
        <trans-unit id="9737446abc238ba64625d047b10e2ea194379924" translate="yes" xml:space="preserve">
          <source>Improved the query planner so that the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt; can be used on &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; even if one or more of the disjuncts use the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;, &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;, &lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;, &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt; operators.</source>
          <target state="translated">クエリプランナーが改善され、1つ以上の論理和が&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;、&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;、&lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;、&lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt;演算子を使用している場合でも、&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;で&lt;a href=&quot;optoverview#or_opt&quot;&gt;OR最適化&lt;/a&gt;を使用できるようになりました。</target>
        </trans-unit>
        <trans-unit id="7c7991b90a25fa494ea7173ba16f41d0e843c78b" translate="yes" xml:space="preserve">
          <source>Improved the windows VFS to better defend against interference from anti-virus software.</source>
          <target state="translated">Windows VFSを改善し、アンチウイルスソフトウェアからの干渉をよりよく防御できるようにしました。</target>
        </trans-unit>
        <trans-unit id="6c9542942225b685370a9ff791f1911ab55a40d4" translate="yes" xml:space="preserve">
          <source>Improved tracing and debugging facilities in the Windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;.</source>
          <target state="translated">Windows &lt;a href=&quot;vfs&quot;&gt;VFSの&lt;/a&gt;改善されたトレースおよびデバッグ機能。</target>
        </trans-unit>
        <trans-unit id="c1ee9a0442382c4cebcfe1b576c0d1fff396e4cb" translate="yes" xml:space="preserve">
          <source>Improved unicode filename handling in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; on Windows.</source>
          <target state="translated">Windowsの&lt;a href=&quot;cli&quot;&gt;コマンドラインシェル&lt;/a&gt;でのUnicodeファイル名の処理が改善されました。</target>
        </trans-unit>
        <trans-unit id="09e6f225ca0ca885645a927e0763b14b484dc7f0" translate="yes" xml:space="preserve">
          <source>Improvements and bug-fixes in support for &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINTの&lt;/a&gt;サポートにおける改善とバグ修正。</target>
        </trans-unit>
        <trans-unit id="c4b534f7c6c26f504f16d9c38af50fef3ae45002" translate="yes" xml:space="preserve">
          <source>Improvements to &quot;dot-command&quot; handling in the &lt;a href=&quot;cli&quot;&gt;Command Line Interface&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;コマンドラインインターフェース&lt;/a&gt;での「ドットコマンド」処理の改善。</target>
        </trans-unit>
        <trans-unit id="47099268e1cc1a7d37272d0a960d324c9d2e5b20" translate="yes" xml:space="preserve">
          <source>Improvements to &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fts3&quot;&gt;FTS3の&lt;/a&gt;改善。</target>
        </trans-unit>
        <trans-unit id="18fe2fab208a9bdfd95bd5b0724b7f338ba76be8" translate="yes" xml:space="preserve">
          <source>Improvements to cost estimates for the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;optoverview#skipscan&quot;&gt;スキップスキャン最適化の&lt;/a&gt;コスト見積もりの​​改善。</target>
        </trans-unit>
        <trans-unit id="f56d95c4feb425fac688efbe211f20dca39f2585" translate="yes" xml:space="preserve">
          <source>Improvements to rounding behavior, so that the results of rounding binary numbers using the &lt;a href=&quot;lang_corefunc#round&quot;&gt;round()&lt;/a&gt; function are closer to what people who are used to thinking in decimal actually expect.</source>
          <target state="translated">Improvements to rounding behavior, so that the results of rounding binary numbers using the &lt;a href=&quot;lang_corefunc#round&quot;&gt;round()&lt;/a&gt; function are closer to what people who are used to thinking in decimal actually expect.</target>
        </trans-unit>
        <trans-unit id="5353c2af79675cc29c5733088967c970c2cbd2d3" translate="yes" xml:space="preserve">
          <source>Improvements to test coverage, other minor bugs fixed, memory leaks plugged, code refactored and/or recommended in places for easier reading.</source>
          <target state="translated">テストカバレッジの改善、その他の軽微なバグの修正、メモリリークの修正、コードのリファクタリング、読みやすい場所での推奨などを行いました。</target>
        </trans-unit>
        <trans-unit id="1672d028ed8042c2cdc755bd4feb4bfb1a305542" translate="yes" xml:space="preserve">
          <source>Improvements to the &quot;.help&quot; command.</source>
          <target state="translated">.help&quot; コマンドの改良。</target>
        </trans-unit>
        <trans-unit id="9829e00db8ef5babdf62ad53520c9aed14ba5d0e" translate="yes" xml:space="preserve">
          <source>Improvements to the &quot;PRAGMA integrity_check&quot; command</source>
          <target state="translated">PRAGMA integrity_check &quot;コマンドの改善</target>
        </trans-unit>
        <trans-unit id="e5c25ee1584b55a6798dccb371f9de65d6e26320" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;コマンドラインシェルの&lt;/a&gt;改善：</target>
        </trans-unit>
        <trans-unit id="7bd7a08c86f6e2927260bf75b7f206267bdb5a66" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;cli#recover&quot;&gt;.recover dot-command&lt;/a&gt; in the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; so that it recovers more content from corrupt database files.</source>
          <target state="translated">破損したデータベースファイルからより多くのコンテンツを回復できるように、&lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;の&lt;a href=&quot;cli#recover&quot;&gt;.recoverドットコマンドの&lt;/a&gt;改善。</target>
        </trans-unit>
        <trans-unit id="56bedeb29e748e173925f592478fb7224bd2a9a7" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;fts3#*fts4automergecmd&quot;&gt;automerge command&lt;/a&gt; of &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; to better control the index size for a full-text index that is subject to a large number of updates.</source>
          <target state="translated">改善&lt;a href=&quot;fts3#*fts4automergecmd&quot;&gt;自動マージコマンド&lt;/a&gt;の&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;良く多数の更新の対象となるフルテキストインデックスのインデックスサイズを制御します。</target>
        </trans-unit>
        <trans-unit id="4f8a0d7434e9fa0e3d93bd594ec2f731beeeee4c" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;optoverview&quot;&gt;query planner&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;optoverview&quot;&gt;クエリプランナーの&lt;/a&gt;改善：</target>
        </trans-unit>
        <trans-unit id="64a384308e143ce85fad7f48be7bf89bd88826a0" translate="yes" xml:space="preserve">
          <source>Improvements to the &lt;a href=&quot;syntaxdiagrams&quot;&gt;syntax bubble diagrams&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;syntaxdiagrams&quot;&gt;構文バブル図の&lt;/a&gt;改善</target>
        </trans-unit>
        <trans-unit id="444f392b3ac06b6a270033461a34681437b33fc9" translate="yes" xml:space="preserve">
          <source>Improvements to the Makefiles and build scripts used by VisualStudio.</source>
          <target state="translated">VisualStudio で使用される Makefile とビルドスクリプトの改善。</target>
        </trans-unit>
        <trans-unit id="187c307e740f14eb7715914261b63385a7891140" translate="yes" xml:space="preserve">
          <source>Improvements to the amalgamation generator script so that all symbols are prefixed with either SQLITE_PRIVATE or SQLITE_API.</source>
          <target state="translated">アマルガム生成スクリプトの改良により、すべてのシンボルの前に SQLITE_PRIVATE または SQLITE_API のいずれかが付くようになりました。</target>
        </trans-unit>
        <trans-unit id="8487f548381bd47de49bbe554c9e3c26fcef5a1f" translate="yes" xml:space="preserve">
          <source>Improvements to the comments in the VDBE byte-code display when running &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;実行時のVDBEバイトコード表示のコメントの改善。</target>
        </trans-unit>
        <trans-unit id="e6a8494de38f18f2b5e148ff117a682e5366a648" translate="yes" xml:space="preserve">
          <source>Improvements to the effectiveness and accuracy of the &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood()&lt;/a&gt;, &lt;a href=&quot;lang_corefunc#likely&quot;&gt;likely()&lt;/a&gt;, and &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely()&lt;/a&gt; SQL hint functions.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;尤度（）&lt;/a&gt;、尤度&lt;a href=&quot;lang_corefunc#likely&quot;&gt;（）&lt;/a&gt;、および&lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;可能性（）の&lt;/a&gt; SQLヒント関数の有効性と精度の改善。</target>
        </trans-unit>
        <trans-unit id="fb078db70835b73a43d340944c34ddf931e04436" translate="yes" xml:space="preserve">
          <source>Improvements to the handling of CSV inputs in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;コマンドラインシェル&lt;/a&gt;でのCSV入力の処理の改善</target>
        </trans-unit>
        <trans-unit id="35621122cb25f12ea29297b200f9cd7f54653df0" translate="yes" xml:space="preserve">
          <source>Improvements to the query planner so that it makes better estimates of plan costs and hence does a better job of choosing the right plan, especially when &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; is used.</source>
          <target state="translated">特に&lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt;が使用されている場合に、プランコストの見積もりが適切になり、適切なプランをより適切に選択できるようにするためのクエリプランナーの改善。</target>
        </trans-unit>
        <trans-unit id="b56408ef9cd6514cec8e529db1c7c154a8214dac" translate="yes" xml:space="preserve">
          <source>Improvements to the windows makefiles and build processes.</source>
          <target state="translated">Windows の makefile とビルドプロセスの改善。</target>
        </trans-unit>
        <trans-unit id="01c7395c54005792d7fd39d556adb0b44131f473" translate="yes" xml:space="preserve">
          <source>In &quot;column&quot; mode (and also in &quot;box&quot;, &quot;table&quot;, and &quot;markdown&quot; modes) the width of columns adjusts automatically. But you can override this, providing a minimum width for each column using the &quot;.width&quot; command. The arguments to &quot;.width&quot; are integers which are the minimum number of spaces to devote to each column. Negative numbers mean right-justify. Thus:</source>
          <target state="translated">column&quot; モード (および &quot;box&quot;、&quot;table&quot;、&quot;markdown&quot; モードでも)では、カラムの幅は自動的に調整されます。しかし、&quot;.width&quot; コマンドを使って各列の最小幅を指定することで、これをオーバーライドすることができます。.width&quot; の引数は整数で、各カラムに割り当てるスペースの最小数です。負の数は右寄せを意味します。したがって、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="b24a3b4f842f4beb9d0cf338bd2105050638be32" translate="yes" xml:space="preserve">
          <source>In &quot;line&quot; mode, each column in a row of the database is shown on a line by itself. Each line consists of the column name, an equal sign and the column data. Successive records are separated by a blank line. Here is an example of line mode output:</source>
          <target state="translated">行」モードでは、データベースの行の各列がそれ自身で行として表示されます。各行は、カラム名、等号、カラムデータで構成されています。連続するレコードは空白行で区切られます。以下にラインモードの出力例を示します。</target>
        </trans-unit>
        <trans-unit id="ba464cb54f172ce24a6d088a3cb06af2c611f784" translate="yes" xml:space="preserve">
          <source>In &quot;quote&quot; mode, the output is formatted as SQL literals. Strings are enclosed in single-quotes and internal single-quotes are escaped by doubling. Blobs are displayed in hexadecimal blob literal notation (Ex: x'abcd'). Numbers are displayed as ASCII text and NULL values are shown as &quot;NULL&quot;. All columns are separated from each other by a comma (or whatever alternative character is selected using &quot;.separator&quot;).</source>
          <target state="translated">quote &quot;モードでは、出力はSQLリテラルとしてフォーマットされます。文字列はシングルクォートで囲まれ、内部のシングルクォートは倍数でエスケープされます。ブロブは16進数のブロブリテラル表記で表示されます(例:x'abcd')。数字はASCIIテキストとして表示され、NULL値は &quot;NULL &quot;として表示されます。すべての列はカンマで区切られています(または、&quot;.separator &quot;を使用して選択された代替文字であれば何でも構いません)。</target>
        </trans-unit>
        <trans-unit id="e70135d1b4c87e02724b6a6725f67c0cdcedb6a8" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../wal&quot;&gt;WAL mode&lt;/a&gt;, multiple &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; that are open on the same database file can each be reading a different historical version of the database file. When a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; begins a read transaction, that connection sees an unchanging copy of the database as it existed for the point in time when the transaction first started. Subsequent changes to the database from other connections are not seen by the reader until a new read transaction is started.</source>
          <target state="translated">で&lt;a href=&quot;../wal&quot;&gt;WALモード&lt;/a&gt;、複数&lt;a href=&quot;sqlite3&quot;&gt;のデータベース接続&lt;/a&gt;同じデータベースファイルに開かれている各データベース・ファイルの異なるバージョンの履歴を読み出すことができます。ときに&lt;a href=&quot;sqlite3&quot;&gt;、データベース接続が&lt;/a&gt;読み取りトランザクションを開始トランザクションが最初に始めたとき、それは時間のポイントのために存在していたとして、その接続はデータベースの不変のコピーを見ています。他の接続からのその後のデータベースへの変更は、新しい読み取りトランザクションが開始されるまで、リーダーには表示されません。</target>
        </trans-unit>
        <trans-unit id="545faac3a749c9fbe686ac2c42b0a8ce0746bb4b" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; (2007-09-04), shared-cache mode was modified so that the same cache can be shared across an entire process rather than just within a single thread. Prior to this change, there were restrictions on passing database connections between threads. Those restrictions were dropped in 3.5.0 update. This document describes shared-cache mode as of version 3.5.0.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;バージョン3.5.0&lt;/a&gt;（2007-09-04）、共有キャッシュ・モードは、同じキャッシュがプロセス全体を横切るだけではなく、単一のスレッド内で共有することができるように変更されました。この変更の前は、スレッド間でのデータベース接続の受け渡しに制限がありました。これらの制限は3.5.0アップデートで削除されました。このドキュメントでは、バージョン3.5.0以降の共有キャッシュモードについて説明します。</target>
        </trans-unit>
        <trans-unit id="8b22aada76f514795f041039b72ce60807690314" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=TRUNCATE&lt;/a&gt; mode, call fsync() immediately after truncating the journal file to ensure that the transaction is durable across a power loss.</source>
          <target state="translated">では&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;プラグマjournal_mode = TRUNCATEの&lt;/a&gt;モード、コールのfsync（）すぐにジャーナル・ファイルを切り捨てた後、トランザクションが電力損失全体の耐久性があることを確認します。</target>
        </trans-unit>
        <trans-unit id="b06cad3e4dffb16827f43add94eb56f4465695b9" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, attempting to attach the same database file more than once results in an error.</source>
          <target state="translated">では&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュモード&lt;/a&gt;、エラーが発生し複数回同じデータベースファイルを添付しようとします。</target>
        </trans-unit>
        <trans-unit id="9f41922c2aa21a0c294b4cbf9d4bf48e3b8e9e1c" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, if a writer crashes and leaves the &lt;a href=&quot;walformat#shm&quot;&gt;shm file&lt;/a&gt; in an inconsistent state, subsequent transactions are now able to recover the shm file even if there are active read transactions. Before this enhancement, shm file recovery that scenario would result in an &lt;a href=&quot;rescode#protocol&quot;&gt;SQLITE_PROTOCOL&lt;/a&gt; error.</source>
          <target state="translated">In &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, if a writer crashes and leaves the &lt;a href=&quot;walformat#shm&quot;&gt;shm file&lt;/a&gt; in an inconsistent state, subsequent transactions are now able to recover the shm file even if there are active read transactions. Before this enhancement, shm file recovery that scenario would result in an &lt;a href=&quot;rescode#protocol&quot;&gt;SQLITE_PROTOCOL&lt;/a&gt; error.</target>
        </trans-unit>
        <trans-unit id="4d45c296410a6677088e7e7ac84b1e93a1f22edc" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, multiple &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; that are open on the same database file can each be reading a different historical version of the database file. When a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; begins a read transaction, that connection sees an unchanging copy of the database as it existed for the point in time when the transaction first started. Subsequent changes to the database from other connections are not seen by the reader until a new read transaction is started.</source>
          <target state="translated">で&lt;a href=&quot;wal&quot;&gt;WALモード&lt;/a&gt;、複数&lt;a href=&quot;#sqlite3&quot;&gt;のデータベース接続&lt;/a&gt;同じデータベースファイルに開かれている各データベース・ファイルの異なるバージョンの履歴を読み出すことができます。ときに&lt;a href=&quot;#sqlite3&quot;&gt;、データベース接続が&lt;/a&gt;読み取りトランザクションを開始トランザクションが最初に始めたとき、それは時間のポイントのために存在していたとして、その接続はデータベースの不変のコピーを見ています。他の接続からのその後のデータベースへの変更は、新しい読み取りトランザクションが開始されるまで、リーダーには表示されません。</target>
        </trans-unit>
        <trans-unit id="ddd420dd1a1ef7aee27736d7c043708aacde1ceb" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; mode when synchronous is NORMAL (1), the WAL file is synchronized before each &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; and the database file is synchronized after each completed &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; and the WAL file header is synchronized when a WAL file begins to be reused after a checkpoint, but no sync operations occur during most transactions. With synchronous=FULL in WAL mode, an additional sync operation of the WAL file happens after each transaction commit. The extra WAL sync following each transaction help ensure that transactions are durable across a power loss. Transactions are consistent with or without the extra syncs provided by synchronous=FULL. If durability is not a concern, then synchronous=NORMAL is normally all one needs in WAL mode.</source>
          <target state="translated">で&lt;a href=&quot;wal&quot;&gt;WALの&lt;/a&gt;モード同期は、NORMAL（1）である場合、WALファイルには、各前同期化され&lt;a href=&quot;wal#ckpt&quot;&gt;たチェックポイント&lt;/a&gt;と各完了後にデータベースファイルが同期され&lt;a href=&quot;wal#ckpt&quot;&gt;、チェックポイント&lt;/a&gt; WALファイルは、チェックポイント後に再利用され始めたときとWALファイルヘッダが同期され、ありません同期操作は、ほとんどのトランザクション中に発生します。 WALモードでsynchronized = FULLを使用すると、トランザクションがコミットされるたびに、WALファイルの追加の同期操作が発生します。各トランザクションに続く追加のWAL同期により、停電後もトランザクションの耐久性が確保されます。トランザクションは、synchronized = FULLによって提供される追加の同期の有無にかかわらず一貫しています。持続性が問題にならない場合は、通常、synchronous = NORMALがWALモードで必要なすべてです。</target>
        </trans-unit>
        <trans-unit id="5a4b7cd3ba1686efa11d9b9c015db21adcf22977" translate="yes" xml:space="preserve">
          <source>In CHECK constraints of a table definition.</source>
          <target state="translated">テーブル定義のCHECK制約では</target>
        </trans-unit>
        <trans-unit id="1207ec4eb27468881c3e5a75c509547ec16346af" translate="yes" xml:space="preserve">
          <source>In DDL</source>
          <target state="translated">DDLでは</target>
        </trans-unit>
        <trans-unit id="06bb676fb43ba64638eb5aba12a8d226fa52bf86" translate="yes" xml:space="preserve">
          <source>In DEFAULT constraints of a table definition.</source>
          <target state="translated">テーブル定義のDEFAULT制約で。</target>
        </trans-unit>
        <trans-unit id="0fc22d3edb7a25933470b0fc98cd018feb112e2e" translate="yes" xml:space="preserve">
          <source>In DML</source>
          <target state="translated">DMLでは</target>
        </trans-unit>
        <trans-unit id="805c25b267572c14bae2116b6611f039f1f80c5c" translate="yes" xml:space="preserve">
          <source>In I/O error tests, after the I/O error simulation failure mechanism is disabled, the database is examined using &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; to make sure that the I/O error has not introduced database corruption.</source>
          <target state="translated">I / Oエラーテストでは、I / Oエラーシミュレーションの失敗メカニズムを無効にした後、&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMAの整合性&lt;/a&gt;チェックを使用してデータベースを調べ、I / Oエラーがデータベースの破損を引き起こしていないことを確認します。</target>
        </trans-unit>
        <trans-unit id="0f2cfcdcfc92b4b01bee8dec645ecb5ceaaa8098" translate="yes" xml:space="preserve">
          <source>In Lemon, the tokenizer calls the parser. Yacc operates the other way around, with the parser calling the tokenizer. The Lemon approach is reentrant and threadsafe, whereas Yacc uses global variables and is therefore neither. Reentrancy is especially important for SQLite since some SQL statements make recursive calls to the parser. For example, when parsing a CREATE TABLE statement, SQLite invokes the parser recursively to generate an INSERT statement to make a new entry in the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; table.</source>
          <target state="translated">レモンでは、トークナイザーはパーサーを呼び出します。Yaccは逆の方法で動作し、パーサーはトークナイザーを呼び出します。レモンアプローチは再入可能でスレッドセーフですが、Yaccはグローバル変数を使用するため、どちらも使用されません。一部のSQLステートメントはパーサーに対して再帰呼び出しを行うため、再入可能性はSQLiteにとって特に重要です。たとえば、CREATE TABLEステートメントを解析する場合、SQLiteはパーサーを再帰的に呼び出してINSERTステートメントを生成し、&lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt;テーブルに新しいエントリを作成します。</target>
        </trans-unit>
        <trans-unit id="d3369588aeb6a765cf20a5709a06e66a042c401f" translate="yes" xml:space="preserve">
          <source>In NORMAL locking-mode (the default unless overridden at compile-time using &lt;a href=&quot;compile#default_locking_mode&quot;&gt;SQLITE_DEFAULT_LOCKING_MODE&lt;/a&gt;), a database connection unlocks the database file at the conclusion of each read or write transaction. When the locking-mode is set to EXCLUSIVE, the database connection never releases file-locks. The first time the database is read in EXCLUSIVE mode, a shared lock is obtained and held. The first time the database is written, an exclusive lock is obtained and held.</source>
          <target state="translated">NORMALロッキングモード（コンパイル時に&lt;a href=&quot;compile#default_locking_mode&quot;&gt;SQLITE_DEFAULT_LOCKING_MODE&lt;/a&gt;を使用してオーバーライドされない限り、デフォルト）では、データベース接続は、各読み取りまたは書き込みトランザクションの終了時にデータベースファイルのロックを解除します。ロッキングモードがEXCLUSIVEに設定されている場合、データベース接続はファイルロックを解放しません。データベースが初めてEXCLUSIVEモードで読み取られるときに、共有ロックが取得されて保持されます。データベースが初めて書き込まれるときに、排他ロックが取得されて保持されます。</target>
        </trans-unit>
        <trans-unit id="f8c693ba3fad2e1d7df97dd42327c19b66a284bb" translate="yes" xml:space="preserve">
          <source>In SQLite</source>
          <target state="translated">SQLiteでは</target>
        </trans-unit>
        <trans-unit id="e298a84cbd8720f440fc21a95dd67ebcefa40857" translate="yes" xml:space="preserve">
          <source>In SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_10_0.html&quot;&gt;version 3.10.0&lt;/a&gt; (2016-01-06) and later, the colUsed field is available to indicate which fields of the virtual table are actually used by the statement being prepared. If the lowest bit of colUsed is set, that means that the first column is used. The second lowest bit corresponds to the second column. And so forth. If the most significant bit of colUsed is set, that means that one or more columns other than the first 63 columns are used. If column usage information is needed by the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method, then the required bits must be encoded into either the idxNum or idxStr output fields.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_10_0.html&quot;&gt;バージョン3.10.0&lt;/a&gt;（2016-01-06）以降では、colUsedフィールドを使用して、準備中のステートメントが実際に仮想テーブルのどのフィールドを使用しているかを示すことができます。 colUsedの最下位ビットが設定されている場合、それは最初の列が使用されることを意味します。 2番目に低いビットは2番目の列に対応します。などなど。 colUsedの最上位ビットが設定されている場合は、最初の63列以外の1つ以上の列が使用されていることを意味します。&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;メソッドで列の使用情報が必要な場合は、必要なビットをidxNumまたはidxStr出力フィールドにエンコードする必要があります。</target>
        </trans-unit>
        <trans-unit id="828bdde156beec9d0455bf5a047ac9dedf77b343" translate="yes" xml:space="preserve">
          <source>In SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_28_0.html&quot;&gt;version 3.28.0&lt;/a&gt; (2019-04-16), windows function support was extended to include the EXCLUDE clause, GROUPS frame types, window chaining, and support for &quot;&amp;lt;expr&amp;gt; PRECEDING&quot; and &quot;&amp;lt;expr&amp;gt; FOLLOWING&quot; boundaries in RANGE frames.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_28_0.html&quot;&gt;バージョン3.28.0&lt;/a&gt;（2019-04-16）では、Windows関数のサポートが拡張され、EXCLUDE句、GROUPSフレームタイプ、ウィンドウチェーン、および &quot;&amp;lt;expr&amp;gt; PRECEDING&quot;および &quot;&amp;lt;expr&amp;gt; FOLLOWING&quot;境界のサポートが含まれています。 RANGEフレーム。</target>
        </trans-unit>
        <trans-unit id="7a9dbb486e8961eb98612eeeff0292e2cdc9f06c" translate="yes" xml:space="preserve">
          <source>In SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;version 3.6.23.1&lt;/a&gt; (2010-03-26) and earlier, &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; used to always return &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; if it was invoked again after returning anything other than &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; without an intervening call to &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt;. This caused problems on some poorly written smartphone applications which did not correctly handle the &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; and &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error returns. Rather than fix the many defective smartphone applications, the behavior of SQLite was changed in 3.6.23.2 to automatically reset the prepared statement. But that changed caused issues in other improperly implemented applications that were actually looking for an &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; return to terminate their query loops. (Anytime an application gets an SQLITE_MISUSE error code from SQLite, that means the application is misusing the SQLite interface and is thus incorrectly implemented.) The SQLITE_OMIT_AUTORESET interface was added to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_5.html&quot;&gt;version 3.7.5&lt;/a&gt; (2011-02-01) in an effort to get all of the (broken) applications to work again without having to actually fix the applications.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;バージョン3.6.23.1&lt;/a&gt;（2010-03-26）以前では、&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_reset（）&lt;/a&gt;への呼び出しを&lt;a href=&quot;c3ref/reset&quot;&gt;介さ&lt;/a&gt;ずに&lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;以外のものを返した後に再度呼び出された場合、sqlite3_step（）は常に&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;を返していました。これにより、&lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt;および&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;エラーが正しく返されない、不適切に作成されたスマートフォンアプリケーションで問題が発生しました。多くの欠陥のあるスマートフォンアプリケーションを修正するのではなく、SQLiteの動作が3.6.23.2で変更され、準備されたステートメントが自動的にリセットされました。しかし、この変更により、&lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSEを&lt;/a&gt;実際に探していた他の不適切に実装されたアプリケーションで問題が発生しました。戻り、クエリループを終了します。（アプリケーションがSQLiteからSQLITE_MISUSEエラーコードを受け取ったときはいつでも、アプリケーションがSQLiteインターフェースを誤用しているため、正しく実装されていません。）SQLITE_OMIT_AUTORESETインターフェースは、SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_5.html&quot;&gt;バージョン&lt;/a&gt; 3.7.5 （2011-02-01）に追加されました。アプリケーションを実際に修正しなくても、すべての（壊れた）アプリケーションが再び機能するようにします。</target>
        </trans-unit>
        <trans-unit id="ae75dbb8c6b830d21fb52ab24e85cf97f8c0d055" translate="yes" xml:space="preserve">
          <source>In SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26) and later, an &lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX&lt;/a&gt; message is sent to the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; every time a statement is prepared that uses an automatic index. Application developers can and should use these warnings to identify the need for new persistent indices in the schema.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;バージョン3.8.0&lt;/a&gt;（2013-08-26）以降では、自動インデックスを使用するステートメントが準備されるたびに、&lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX&lt;/a&gt;メッセージが&lt;a href=&quot;errlog&quot;&gt;エラーログに&lt;/a&gt;送信されます。アプリケーション開発者は、これらの警告を使用して、スキーマ内の新しい永続インデックスの必要性を特定できます。</target>
        </trans-unit>
        <trans-unit id="311b836bebf13bf229bfb5d427d7d61edb397191" translate="yes" xml:space="preserve">
          <source>In SQLite Version 3</source>
          <target state="translated">SQLiteバージョン3では</target>
        </trans-unit>
        <trans-unit id="44b0d77bd3716352e42cf5f2569dabd7987b859f" translate="yes" xml:space="preserve">
          <source>In SQLite version 2</source>
          <target state="translated">SQLiteバージョン2では</target>
        </trans-unit>
        <trans-unit id="ab1b358df4951321dec42436274a7fc7055620c8" translate="yes" xml:space="preserve">
          <source>In SQLite version 2, if many processes are reading from the database, it might be the case that there is never a time when there are no active readers. And if there is always at least one read lock on the database, no process would ever be able to make changes to the database because it would be impossible to acquire a write lock. This situation is called &lt;em&gt;writer starvation&lt;/em&gt;.</source>
          <target state="translated">SQLiteバージョン2では、多くのプロセスがデータベースから読み取っている場合、アクティブなリーダーが存在しない時間がない場合があります。また、データベースに少なくとも1つの読み取りロックが常に存在する場合、書き込みロックを取得できないため、データベースに変更を加えることができるプロセスはありません。この状況は、&lt;em&gt;ライターの飢餓&lt;/em&gt;と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="0e7545ebfe6eb34f26f31fe8304f6f550663c8e8" translate="yes" xml:space="preserve">
          <source>In SQLite version 3, the sqlite3_exec routine is just a wrapper around calls to the prepared statement interface.</source>
          <target state="translated">SQLiteバージョン3では、sqlite3_execルーチンはprepared statementインターフェースの呼び出しのラッパーに過ぎません。</target>
        </trans-unit>
        <trans-unit id="e7a56207acc60b29c6f42211f54c5ca8f6e54fa3" translate="yes" xml:space="preserve">
          <source>In SQLite version 3.0, the rowid is a 64-bit signed integer. This is an expansion of SQLite version 2.8 which only permitted rowids of 32-bits.</source>
          <target state="translated">SQLite バージョン 3.0 では、rowid は 64 ビットの符号付き整数です。これは SQLite バージョン 2.8 を拡張したもので、32 ビットの行 ID のみを許可していました。</target>
        </trans-unit>
        <trans-unit id="eade6a0b14d85e68f1dde5969cd3e571c5e3e4f6" translate="yes" xml:space="preserve">
          <source>In SQLite version 3.5.0 and 3.5.1, it was possible to define the SQLITE_OMIT_MEMORY_ALLOCATION which would cause the built-in implementation of these routines to be omitted. That capability is no longer provided. Only built-in memory allocators can be used.</source>
          <target state="translated">SQLite バージョン 3.5.0 および 3.5.1 では、これらのルーチンの組み込み実装を省略する SQLITE_OMIT_MEMORY_ALLOCATION を定義することが可能でした。その機能はもはや提供されていません。組み込みのメモリアロケータのみが使用できます。</target>
        </trans-unit>
        <trans-unit id="7278a0046b6c686e7491a606645054d45ac6a9da" translate="yes" xml:space="preserve">
          <source>In SQLite versions 3.3.0 through 3.4.2 when shared-cache mode is enabled, a database connection may only be used by the thread that called &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; to create it. And a connection could only share cache with another connection in the same thread. These restrictions were dropped beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; (2007-09-04).</source>
          <target state="translated">SQLiteバージョン3.3.0〜3.4.2では、共有キャッシュモードが有効になっている場合、データベース接続は、それを作成するために&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（）&lt;/a&gt;を呼び出したスレッドでのみ使用できます。また、接続は、同じスレッド内の別の接続とのみキャッシュを共有できます。これらの制限は、SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;バージョン3.5.0&lt;/a&gt;（2007-09-04）から削除されました。</target>
        </trans-unit>
        <trans-unit id="4af0e6be92f4dba4280a2c7e3664bbca74929393" translate="yes" xml:space="preserve">
          <source>In SQLite, a column with type INTEGER PRIMARY KEY is an alias for the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; (except in &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables) which is always a 64-bit signed integer.</source>
          <target state="translated">SQLiteでは、タイプINTEGER PRIMARY KEYの列は&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;（&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルを除く）のエイリアスであり、常に64ビットの符号付き整数です。</target>
        </trans-unit>
        <trans-unit id="d48f1e4d1dbe48d61b2a0bc14d1d629523402032" translate="yes" xml:space="preserve">
          <source>In SQLite, a database object (a table, index, trigger or view) is identified by the name of the object and the name of the database that it resides in. Database objects may reside in the main database, the temp database, or in an &lt;a href=&quot;lang_attach&quot;&gt;attached database&lt;/a&gt;.</source>
          <target state="translated">SQLiteでは、データベースオブジェクト（テーブル、インデックス、トリガー、またはビュー）は、オブジェクトの名前とそれが常駐するデータベースの名前で識別されます。データベースオブジェクトは、メインデータベース、一時データベース、または&lt;a href=&quot;lang_attach&quot;&gt;アタッチされたデータベース&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5d037fc285a8e821543df8fc13d9f7837388fd3a" translate="yes" xml:space="preserve">
          <source>In SQLite, table rows normally have a 64-bit signed integer &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; which is unique among all rows in the same table. (&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are the exception.)</source>
          <target state="translated">SQLiteでは、通常、テーブルの行には64ビットの符号付き整数&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWIDが&lt;/a&gt;あり、同じテーブルのすべての行の中で一意です。（&lt;a href=&quot;withoutrowid&quot;&gt;ROWIDなしの&lt;/a&gt;テーブルは例外です。）</target>
        </trans-unit>
        <trans-unit id="fe38d7c32db7d9028a7337d49fe5d30adb864ee5" translate="yes" xml:space="preserve">
          <source>In SQLite, the answer to the previous question is &quot;no&quot;. For testing purposes, the SQLite source code defines macros called ALWAYS() and NEVER(). The ALWAYS() macro surrounds conditions which are expected to always evaluate as true and NEVER() surrounds conditions that are always evaluated to false. These macros serve as comments to indicate that the conditions are defensive code. In release builds, these macros are pass-throughs:</source>
          <target state="translated">SQLite では、先ほどの質問の答えは「いいえ」です。テストのために、SQLite のソースコードでは ALWAYS()および NEVER()と呼ばれるマクロが定義されています。ALWAYS()マクロは、常に真として評価されると予想される条件を囲み、NEVER()は常に偽として評価される条件を囲みます。これらのマクロは、条件が防御コードであることを示すコメントとして機能します。リリースビルドでは、これらのマクロはパススルーです。</target>
        </trans-unit>
        <trans-unit id="f43676df6968c4bb63677e4842db7886283fb3e7" translate="yes" xml:space="preserve">
          <source>In SQLite, the presence of assert(X) means that the developers have a proof that X is always true. Readers can depend upon X being true to help them reason about the code. An assert(X) is a strong statement about the truth of X. There is no doubt.</source>
          <target state="translated">SQLite では、assert(X)が存在するということは、開発者が X が常に真であるという証明を持っていることを意味します。読者はXが真であることを信頼して、コードについての推論を行うことができます。assert(X)は X の真実についての強力なステートメントです。</target>
        </trans-unit>
        <trans-unit id="afc867db69a6f0ff03a7d5c74a860a19b5e1f763" translate="yes" xml:space="preserve">
          <source>In WAL mode, changes to the database are detected using the wal-index and so the change counter is not needed. Hence, the change counter might not be incremented on each transaction in WAL mode.</source>
          <target state="translated">WALモードでは、データベースへの変更はwal-indexを使用して検出されるため、変更カウンタは必要ありません。したがって、WALモードでは、変更カウンタはトランザクションごとにインクリメントされないかもしれません。</target>
        </trans-unit>
        <trans-unit id="56b4d5a656b5f1cb948b72fc909adc62f6fce99b" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt; statement, all ORDER BY expressions are handled as aliases for one of the result columns of the compound. If an ORDER BY expression is not an integer alias, then SQLite searches the left-most SELECT in the compound for a result column that matches either the second or third rules above. If a match is found, the search stops and the expression is handled as an alias for the result column that it has been matched against. Otherwise, the next SELECT to the right is tried, and so on. If no matching expression can be found in the result columns of any constituent SELECT, it is an error. Each term of the ORDER BY clause is processed separately and may be matched against result columns from different SELECT statements in the compound.</source>
          <target state="translated">で&lt;a href=&quot;lang_select#compound&quot;&gt;化合物SELECT&lt;/a&gt;文で、表現BYすべてORDERは、化合物の結果列の一つの別名として扱われます。 ORDER BY式が整数エイリアスでない場合、SQLiteはコンパウンドの左端のSELECTを検索して、上記の2番目または3番目のルールに一致する結果列を探します。一致が見つかった場合、検索は停止し、式は一致した結果列のエイリアスとして処理されます。それ以外の場合は、右側の次のSELECTが試行されます。構成要素のSELECTの結果列に一致する式が見つからない場合は、エラーです。 ORDER BY句の各用語は個別に処理され、コンパウンド内の異なるSELECTステートメントからの結果列と照合されます。</target>
        </trans-unit>
        <trans-unit id="7e23feed60f0ebed492861c5dd540e487916faa3" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt; statement, only the last or right-most &lt;a href=&quot;lang_select#simpleselect&quot;&gt;simple SELECT&lt;/a&gt; may have an ORDER BY clause. That ORDER BY clause will apply across all elements of the compound. If the right-most element of a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt; is a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt; clause, then no ORDER BY clause is allowed on that statement.</source>
          <target state="translated">で&lt;a href=&quot;lang_select#compound&quot;&gt;化合物SELECT&lt;/a&gt;文で、最後または一番右&lt;a href=&quot;lang_select#simpleselect&quot;&gt;の単純なSELECTは、&lt;/a&gt; ORDER BY句を持つことができます。そのORDER BY句は、複合のすべての要素に適用されます。一番右の要素ならば&lt;a href=&quot;lang_select#compound&quot;&gt;化合物SELECTが&lt;/a&gt;ある&lt;a href=&quot;lang_select#values&quot;&gt;VALUESの&lt;/a&gt;句は、ORDER BY句なしORDERはその文では許可されません。</target>
        </trans-unit>
        <trans-unit id="60dd93ddbe8f5275cb023ced823e2e72128039a2" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt;, only the last or right-most &lt;a href=&quot;lang_select#simpleselect&quot;&gt;simple SELECT&lt;/a&gt; may contain a LIMIT clause. In a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt;, the LIMIT clause applies to the entire compound, not just the final SELECT. If the right-most &lt;a href=&quot;lang_select#simpleselect&quot;&gt;simple SELECT&lt;/a&gt; is a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES clause&lt;/a&gt; then no LIMIT clause is allowed.</source>
          <target state="translated">で&lt;a href=&quot;lang_select#compound&quot;&gt;化合物SELECT&lt;/a&gt;、最後または一番右&lt;a href=&quot;lang_select#simpleselect&quot;&gt;の単純なSELECTは、&lt;/a&gt; LIMIT句が含まれていてもよいです。で&lt;a href=&quot;lang_select#compound&quot;&gt;化合物SELECT&lt;/a&gt;、LIMIT句は全体の化合物だけではなく、最後のSELECTに適用されます。右端の&lt;a href=&quot;lang_select#simpleselect&quot;&gt;単純なSELECT&lt;/a&gt;が&lt;a href=&quot;lang_select#values&quot;&gt;VALUES句の&lt;/a&gt;場合、LIMIT句は許可されません。</target>
        </trans-unit>
        <trans-unit id="4a8149bd98030a655ea899de201ec17546792e89" translate="yes" xml:space="preserve">
          <source>In a CASE with a base expression, the base expression is evaluated just once and the result is compared against the evaluation of each WHEN expression from left to right. The result of the CASE expression is the evaluation of the THEN expression that corresponds to the first WHEN expression for which the comparison is true. Or, if none of the WHEN expressions evaluate to a value equal to the base expression, the result of evaluating the ELSE expression, if any. If there is no ELSE expression and none of the WHEN expressions produce a result equal to the base expression, the overall result is NULL.</source>
          <target state="translated">ベース式を持つCASEでは、ベース式は一度だけ評価され、その結果は左から右に向かって各WHEN式の評価と比較されます。CASE式の結果は、比較が真である最初のWHEN式に対応するTHEN式の評価となります。あるいは、WHEN式のどれも基底式に等しい値に評価されない場合、ELSE式がある場合は、ELSE式を評価した結果である。ELSE式が存在せず、WHEN式のどれも基底式と等しい結果を生成しない場合、全体の結果はNULLとなります。</target>
        </trans-unit>
        <trans-unit id="9908cac3e7af8453ade042a08abc46157b47dbc8" translate="yes" xml:space="preserve">
          <source>In a CASE without a base expression, each WHEN expression is evaluated and the result treated as a boolean, starting with the leftmost and continuing to the right. The result of the CASE expression is the evaluation of the THEN expression that corresponds to the first WHEN expression that evaluates to true. Or, if none of the WHEN expressions evaluate to true, the result of evaluating the ELSE expression, if any. If there is no ELSE expression and none of the WHEN expressions are true, then the overall result is NULL.</source>
          <target state="translated">ベース式のないCASEでは、各WHEN式が評価され、その結果は、左端から始まり右に続くブーリアンとして扱われます。CASE式の結果は、真と評価される最初のWHEN式に対応するTHEN式の評価となります。または、WHEN式のどれもが真に評価されない場合、ELSE式があれば、その評価結果。ELSE式が存在せず、WHEN式のどれも真でない場合、全体の結果はNULLとなります。</target>
        </trans-unit>
        <trans-unit id="6181d4389ce1218d0117e383d6876208b5204220" translate="yes" xml:space="preserve">
          <source>In a compound SELECT, all the constituent SELECTs must return the same number of result columns. As the components of a compound SELECT must be simple SELECT statements, they may not contain &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; or &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; clauses. &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; and &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; clauses may only occur at the end of the entire compound SELECT, and then only if the final element of the compound is not a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt; clause.</source>
          <target state="translated">複合SELECTでは、すべての構成SELECTが同じ数の結果列を返す必要があります。複合SELECTのコンポーネントは単純なSELECTステートメントである必要があるため、&lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt;句や&lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt;句を含めることはできません。&lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt;句と&lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt;句は、複合SELECT全体の最後にのみ出現し、複合の最後の要素が&lt;a href=&quot;lang_select#values&quot;&gt;VALUES&lt;/a&gt;句でない場合にのみ出現します。</target>
        </trans-unit>
        <trans-unit id="78d71ac8fe601725ccb2ce14d7f5ff1b4e551c1c" translate="yes" xml:space="preserve">
          <source>In a custom format defined by the RBU application.</source>
          <target state="translated">RBUアプリケーションによって定義されたカスタムフォーマットで。</target>
        </trans-unit>
        <trans-unit id="c01843d896cd964dc56835ee2c755615d047e3ab" translate="yes" xml:space="preserve">
          <source>In a database that uses ptrmap pages, all pages at locations identified by the computation in the previous paragraph must be ptrmap page and no other page may be a ptrmap page. Except, if the byte-lock page happens to fall on the same page number as a ptrmap page, then the ptrmap is moved to the following page for that one case.</source>
          <target state="translated">ptrmapページを使用するデータベースでは、前項の計算で特定された位置にあるすべてのページがptrmapページでなければならず、それ以外のページがptrmapページになってはならない。ただし、バイトロックページがたまたまptrmapページと同じページ番号に該当する場合は、その1つの場合を除いて、ptrmapは次のページに移動されます。</target>
        </trans-unit>
        <trans-unit id="27e8a07a53d50d810a0832f44496263b4918565d" translate="yes" xml:space="preserve">
          <source>In a database with ptrmap pages, the first ptrmap page is page 2. A ptrmap page consists of an array of 5-byte entries. Let J be the number of 5-byte entries that will fit in the usable space of a page. (In other words, J=U/5.) The first ptrmap page will contain back pointer information for pages 3 through J+2, inclusive. The second pointer map page will be on page J+3 and that ptrmap page will provide back pointer information for pages J+4 through 2*J+3 inclusive. And so forth for the entire database file.</source>
          <target state="translated">ptrmapページを持つデータベースでは、最初のptrmapページは2ページ目である。ptrmapページは5バイトのエントリの配列で構成される。1ページの使用可能なスペースに収まる5バイトエントリの数をJとする(言い換えれば、J=U/5)。(言い換えれば、J=U/5)最初のptrmapページには、3ページ目からJ+2ページ目までのバックポインタ情報が格納される。2番目のポインタマップページはJ+3ページにあり、そのptrmapページはJ+4から2*J+3までのページのバックポインタ情報を提供します。といった具合に、データベースファイル全体の情報を提供します。</target>
        </trans-unit>
        <trans-unit id="413d5f86aecfe4e03a70ec087a2506b07314a985" translate="yes" xml:space="preserve">
          <source>In a general query, dependencies need not be on a single loop, and hence the matrix of dependencies might not be representable as a graph. For example, one of the WHERE clause constraints might be S.a=L.b+P.c, implying that the S loop must be an inner loop of both L and P. Such dependencies cannot be drawn as a graph since there is no way for an arc to originate at two or more nodes at once.</source>
          <target state="translated">一般的な問い合わせでは、依存関係は単一のループ上にある必要はなく、依存関係の行列はグラフとして表現できない場合があります。例えば、WHERE句制約の1つは、S.a=L.b+P.cとなり、SループがLとPの両方の内側ループでなければならないことを暗示しています。</target>
        </trans-unit>
        <trans-unit id="3cba367e5a45e9ef327972801946d29ebc579596" translate="yes" xml:space="preserve">
          <source>In a join, two or more tables are combined to generate a single result. The result table consists of every possible combination of rows from the tables being joined. The easiest and most natural way to implement this is with nested loops.</source>
          <target state="translated">結合では、2つ以上のテーブルを結合して1つの結果を生成します。結果テーブルは、結合されるテーブルの行のすべての可能な組み合わせで構成されます。これを実装する最も簡単で自然な方法は、入れ子になったループです。</target>
        </trans-unit>
        <trans-unit id="ea43a43981be0da7d2383a4a8fa8f578ad332998" translate="yes" xml:space="preserve">
          <source>In a more complete build, SQLite also uses library routines like malloc() and free() and operating system interfaces for opening, reading, writing, and closing files. But even then, the number of dependencies is very small. Other &quot;modern&quot; language, in contrast, often require multi-megabyte runtimes loaded with thousands and thousands of interfaces.</source>
          <target state="translated">より完全なビルドでは、SQLite は malloc()や free()のようなライブラリルーチンや、ファイルを開いたり、読んだり、書いたり、閉じたりするためのオペレーティングシステムのインターフェイスも使用しています。しかし、それでも依存関係の数は非常に少ないのです。対照的に、他の「現代的な」言語では、多くの場合、何千、何千ものインターフェイスを搭載したマルチメガバイトのランタイムを必要とします。</target>
        </trans-unit>
        <trans-unit id="84d7fa8dbd084f79299c977c5d7f182884242ce4" translate="yes" xml:space="preserve">
          <source>In a multi-threaded application, access to the &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; is serialized if and only if &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; is enabled. If &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; is disabled then the methods in &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; must take care of their own serialization needs.</source>
          <target state="translated">マルチスレッドアプリケーションでは、&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;が有効な場合にのみ、&lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt;へのアクセスがシリアル化されます。場合&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUSが&lt;/a&gt;無効になっている、その後のメソッド&lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methodsは&lt;/a&gt;自分のシリアル化のニーズの世話をする必要があります。</target>
        </trans-unit>
        <trans-unit id="f07ff4f6d979804b51470d547e3016d910de27f0" translate="yes" xml:space="preserve">
          <source>In a multithreaded environment, SQLite uses mutexes to serialize access to shared resources. The mutex subsystem is only required for applications that access SQLite from multiple threads. For single-threaded applications, or applications which only call SQLite from a single thread, the mutex subsystem can be completely disabled by recompiling with the following option:</source>
          <target state="translated">マルチスレッド環境では、SQLite はミューテックスを使用して共有リソースへのアクセスをシリアライズします。ミューテックスサブシステムが必要なのは、複数のスレッドからSQLiteにアクセスするアプリケーションのみです。シングルスレッドのアプリケーションや、単一のスレッドからのみSQLiteを呼び出すアプリケーションでは、以下のオプションを使用して再コンパイルすることで、ミューテックスサブシステムを完全に無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="4d4533ee698cc81c52715976a896f4db12f7a8cf" translate="yes" xml:space="preserve">
          <source>In a normal index, there is a one-to-one mapping between rows in a table and entries in each index associated with that table. However, in a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt;, the index b-tree only contains entries corresponding to table rows for which the WHERE clause expression on the CREATE INDEX statement is true. Corresponding rows in the index and table b-trees share the same rowid or primary key values and contain the same value for all indexed columns.</source>
          <target state="translated">通常のインデックスでは、テーブルの行とそのテーブルに関連付けられている各インデックスのエントリとの間に1対1のマッピングがあります。ただし、&lt;a href=&quot;partialindex&quot;&gt;部分インデックス&lt;/a&gt;では、インデックスBツリーには、CREATE INDEXステートメントのWHERE句の式が真であるテーブル行に対応するエントリのみが含まれます。インデックスとテーブルのBツリー内の対応する行は、同じROWIDまたは主キーの値を共有し、すべてのインデックス付き列に同じ値を含みます。</target>
        </trans-unit>
        <trans-unit id="ce9e9da4042a8b1a6fff277efdbca241b2bb44b8" translate="yes" xml:space="preserve">
          <source>In a prefix search, the matchlen is the number of characters in the string that match against the prefix. For a non-prefix search, this is the same as length(word).</source>
          <target state="translated">プレフィックス検索の場合、matchlen は、プレフィックスにマッチする文字列の文字数です。プレフィックス以外の検索では、これは length(word)と同じです。</target>
        </trans-unit>
        <trans-unit id="540eb7e11b15dfedf16222538153a627d93ae118" translate="yes" xml:space="preserve">
          <source>In a well-formed sqlite_stat3 table, the samples for any single index must appear in the same order that they occur in the index. In other words, if the entry with left-most column S1 is earlier in the index b-tree than the entry with left-most column S2, then in the sqlite_stat3 table, sample S1 must have a smaller rowid than sample S2.</source>
          <target state="translated">整形されたsqlite_stat3テーブルでは、単一のインデックスのサンプルはインデックスの中で発生するのと同じ順番で現れなければなりません。言い換えれば、左端の列S1を持つエントリが左端の列S2を持つエントリよりもインデックスb-treeの中で早い場合、sqlite_stat3テーブルでは、サンプルS1はサンプルS2よりも小さいrowidを持っていなければなりません。</target>
        </trans-unit>
        <trans-unit id="471a1674cd89ff60cc26aaa2e09dcb5715c114d4" translate="yes" xml:space="preserve">
          <source>In a well-formed sqlite_stat4 table, the samples for any single index must appear in the same order that they occur in the index. In other words, if entry S1 is earlier in the index b-tree than entry S2, then in the sqlite_stat4 table, sample S1 must have a smaller rowid than sample S2.</source>
          <target state="translated">整形されたsqlite_stat4テーブルでは、単一のインデックスのサンプルはインデックスの中に現れるのと同じ順番で現れなければなりません。言い換えれば、エントリS1がエントリS2よりもインデックスb-treeの中で早い場合、sqlite_stat4テーブルでは、サンプルS1はサンプルS2よりも小さい行IDを持っていなければなりません。</target>
        </trans-unit>
        <trans-unit id="211f3f65b2d350ffdf823361c3c94beeb6b3685e" translate="yes" xml:space="preserve">
          <source>In addition to &quot;supporting&quot; SQLite through the year 2050, the developers also promise to keep the SQLite &lt;a href=&quot;cintro&quot;&gt;C-language API&lt;/a&gt; and &lt;a href=&quot;fileformat2&quot;&gt;on-disk format&lt;/a&gt; fully backwards compatible. This means that application written to use SQLite today should be able to link against and use future versions of SQLite released decades in the future.</source>
          <target state="translated">2050年までのSQLiteの「サポート」に加えて、開発者はSQLite &lt;a href=&quot;cintro&quot;&gt;C言語のAPI&lt;/a&gt;と&lt;a href=&quot;fileformat2&quot;&gt;ディスク上のフォーマットを&lt;/a&gt;完全に下位互換性を保つことも約束します。つまり、今日SQLiteを使用するように作成されたアプリケーションは、数十年先にリリースされたSQLiteの将来のバージョンにリンクして使用できるはずです。</target>
        </trans-unit>
        <trans-unit id="2d62e10830dbc04e04eb1ce98ea4d36c1849dd6d" translate="yes" xml:space="preserve">
          <source>In addition to WHERE clause constraints, the SQLite core also tells the xBestIndex method about the ORDER BY clause. (In an aggregate query, the SQLite core might put in GROUP BY clause information in place of the ORDER BY clause information, but this fact should not make any difference to the xBestIndex method.) If all terms of the ORDER BY clause are columns in the virtual table, then nOrderBy will be the number of terms in the ORDER BY clause and the aOrderBy[] array will identify the column for each term in the order by clause and whether or not that column is ASC or DESC.</source>
          <target state="translated">WHERE 句の制約に加えて、SQLite コアは ORDER BY 句についても xBestIndex メソッドに伝えます。(集計クエリでは、SQLite コアは ORDER BY 句の情報の代わりに GROUP BY 句の情報を入れるかもしれませんが、この事実は xBestIndex メソッドには何の影響もありません)。ORDER BY 句のすべての項が仮想テーブルのカラムである場合、nOrderBy は ORDER BY 句の項数となり、aOrderBy[]配列は ORDER BY 句の各項のカラムと、そのカラムが ASC か DESC かを識別します。</target>
        </trans-unit>
        <trans-unit id="ae32760f149e6ccbf9d662c3e5f266d79f8381ea" translate="yes" xml:space="preserve">
          <source>In addition to being a result code, the SQLITE_ABORT value is also used as a &lt;a href=&quot;c3ref/c_fail&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;c3ref/vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">SQLITE_ABORT値は、結果コードであるだけでなく、&lt;a href=&quot;c3ref/vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict（）&lt;/a&gt;インターフェースから返される&lt;a href=&quot;c3ref/c_fail&quot;&gt;競合解決モード&lt;/a&gt;としても使用されます。</target>
        </trans-unit>
        <trans-unit id="7bf173fd8743d9addd4d23da77cbd1023dcac612" translate="yes" xml:space="preserve">
          <source>In addition to locking this byte, a connection running &lt;a href=&quot;walformat#recovery&quot;&gt;recovery&lt;/a&gt; also gets an exclusive lock on all other WAL locks except for WAL_READ_LOCK(0).</source>
          <target state="translated">このバイトをロックすることに加えて、&lt;a href=&quot;walformat#recovery&quot;&gt;リカバリ&lt;/a&gt;を実行している接続は、WAL_READ_LOCK（0）を除く他のすべてのWALロックで排他ロックも取得します。</target>
        </trans-unit>
        <trans-unit id="cb3414acfc85a9001c1b555d3204dd8c38c36eeb" translate="yes" xml:space="preserve">
          <source>In addition to making SQLite easier to incorporate into other projects, the amalgamation also makes it run faster. Many compilers are able to do additional optimizations on code when it is contained with in a single translation unit such as it is in the amalgamation. We have measured performance improvements of between 5 and 10% when we use the amalgamation to compile SQLite rather than individual source files. The downside of this is that the additional optimizations often take the form of function inlining which tends to make the size of the resulting binary image larger.</source>
          <target state="translated">アマルガムは SQLite を他のプロジェクトに組み込むのを容易にするだけでなく、実行速度も向上させます。多くのコンパイラは、アマルガムのような単一の翻訳ユニットにコードが含まれている場合、コードに対して追加の最適化を行うことができます。個々のソースファイルではなく、SQLiteをコンパイルするためにアマルガムを使用した場合、5~10%のパフォーマンス向上が確認されています。これの欠点は、追加の最適化が関数のインライン化という形で行われることが多く、結果として得られるバイナリイメージのサイズを大きくする傾向があることです。</target>
        </trans-unit>
        <trans-unit id="dc82fe62c10524b3d4ccdfbeed7cfd03442b0fdf" translate="yes" xml:space="preserve">
          <source>In addition to providing built-in &quot;simple&quot;, &quot;porter&quot; and (possibly) &quot;icu&quot; and &quot;unicode61&quot; tokenizers, FTS provides an interface for applications to implement and register custom tokenizers written in C. The interface used to create a new tokenizer is defined and described in the fts3_tokenizer.h source file.</source>
          <target state="translated">組み込みの &quot;simple&quot;、&quot;porter&quot;、(おそらく)&quot;icu&quot;、&quot;unicode61 &quot;トークナイザーを提供することに加えて、FTSはアプリケーションがC言語で書かれたカスタムトークナイザーを実装し、登録するためのインターフェイスを提供しています。</target>
        </trans-unit>
        <trans-unit id="96c71370cd3f6550d6c5dcd90baa2ddaf820ea27" translate="yes" xml:space="preserve">
          <source>In addition to reading and writing SQLite database files, the &lt;b&gt;sqlite3&lt;/b&gt; program will also read and write ZIP archives. Simply specify a ZIP archive filename in place of an SQLite database filename on the initial command line, or in the &quot;.open&quot; command, and &lt;b&gt;sqlite3&lt;/b&gt; will automatically detect that the file is a ZIP archive instead of an SQLite database and will open it as such. This works regardless of file suffix. So you can open JAR, DOCX, and ODP files and any other file format that is really a ZIP archive and SQLite will read it for you.</source>
          <target state="translated">In addition to reading and writing SQLite database files, the &lt;b&gt;sqlite3&lt;/b&gt; program will also read and write ZIP archives. Simply specify a ZIP archive filename in place of an SQLite database filename on the initial command line, or in the &quot;.open&quot; command, and &lt;b&gt;sqlite3&lt;/b&gt; will automatically detect that the file is a ZIP archive instead of an SQLite database and will open it as such. This works regardless of file suffix. So you can open JAR, DOCX, and ODP files and any other file format that is really a ZIP archive and SQLite will read it for you.</target>
        </trans-unit>
        <trans-unit id="73759a104c50187a5dc43c3f84c36657f75e9027" translate="yes" xml:space="preserve">
          <source>In addition to the four main test harnesses, there several other small programs that implement specialized tests.</source>
          <target state="translated">4つの主要なテストハーネスに加えて、特殊なテストを実装する他のいくつかの小さなプログラムがあります。</target>
        </trans-unit>
        <trans-unit id="7ffa68d498101dd69c9fe08bfcd580625d879a08" translate="yes" xml:space="preserve">
          <source>In addition to the incompatible changes listed above, SQLite version 3.6.0 adds the following backwards compatible changes and enhancements:</source>
          <target state="translated">上記の互換性のない変更点に加え、SQLite バージョン 3.6.0 では、以下のような下位互換性のある変更点と機能強化が追加されています。</target>
        </trans-unit>
        <trans-unit id="8f29eabb94163c908fdf9ce75645a4e743012d26" translate="yes" xml:space="preserve">
          <source>In addition to the official repositories, the developers typically keep complete clones of all software on their personal machines. And there are uncountable clones scattered about the internet.</source>
          <target state="translated">公式リポジトリに加えて、開発者は通常、すべてのソフトウェアの完全なクローンを個人のマシンに保存しています。そして、インターネット上には数え切れないほどのクローンが散らばっています。</target>
        </trans-unit>
        <trans-unit id="7d07efab2f131a863a93f94a25375b6ef4bc7a4a" translate="yes" xml:space="preserve">
          <source>In addition to the primary vdbe.c source code file, there are other helper code files in the source tree, all of whose names begin with &quot;vdbe&quot; - short for &quot;Virtual DataBase Engine&quot;.</source>
          <target state="translated">ソースツリーには、プライマリの vdbe.c ソースコードファイルに加えて、他にもヘルパーコードファイルがあり、その名前はすべて &quot;vdbe&quot; で始まります。</target>
        </trans-unit>
        <trans-unit id="e225e51508417bb108b16321c68b3adb1795c7b9" translate="yes" xml:space="preserve">
          <source>In addition to the required flags, the following optional flags are also supported:</source>
          <target state="translated">必須のフラグに加えて、以下のオプションのフラグもサポートしています。</target>
        </trans-unit>
        <trans-unit id="77b9657ef03e307e851c2e7bae3bdd3ad8613131" translate="yes" xml:space="preserve">
          <source>In addition to the tables, indexes, views, and triggers created by the application and/or the developer using CREATE statements SQL, the sqlite_master table may contain zero or more entries for</source>
          <target state="translated">アプリケーションおよび/または開発者がCREATE文SQLを使って作成したテーブル、インデックス、ビュー、トリガに加えて、sqlite_masterテーブルは0個以上の</target>
        </trans-unit>
        <trans-unit id="52a812fb18ec964152fad4865c6ca9189ffdf18b" translate="yes" xml:space="preserve">
          <source>In addition to the tables, indexes, views, and triggers created by the application and/or the developer using CREATE statements SQL, the sqlite_schema table may contain zero or more entries for</source>
          <target state="translated">アプリケーションおよび/または開発者がCREATE文SQLを使用して作成したテーブル、インデックス、ビュー、トリガに加えて、sqlite_schemaテーブルは0個以上の</target>
        </trans-unit>
        <trans-unit id="a409c2d7a3384bc3f57eb2c0537e46f7868645bd" translate="yes" xml:space="preserve">
          <source>In addition to the three major test harnesses, there several other small programs that implement specialized tests.</source>
          <target state="translated">3つの主要なテストハーネスに加えて、特殊なテストを実装する他のいくつかの小さなプログラムがあります。</target>
        </trans-unit>
        <trans-unit id="0718e6fdf0cd1e299f6d920f46595f0908dd4b09" translate="yes" xml:space="preserve">
          <source>In addition, there are some defined constants:</source>
          <target state="translated">さらに、いくつかの定義された定数があります。</target>
        </trans-unit>
        <trans-unit id="fbb8e299adb3ff32a155642d73390e9d9fa9566c" translate="yes" xml:space="preserve">
          <source>In all of the above, if F is not the name of a database, journal or WAL filename passed into the VFS from the SQLite core and F is not the return value from &lt;a href=&quot;#sqlite3_db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, then the result is undefined and is likely a memory access violation.</source>
          <target state="translated">In all of the above, if F is not the name of a database, journal or WAL filename passed into the VFS from the SQLite core and F is not the return value from &lt;a href=&quot;#sqlite3_db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, then the result is undefined and is likely a memory access violation.</target>
        </trans-unit>
        <trans-unit id="0a6f4780ac68779fff537a2221e3188df1c6d53f" translate="yes" xml:space="preserve">
          <source>In all of the above, if F is not the name of a database, journal or WAL filename passed into the VFS from the SQLite core and F is not the return value from &lt;a href=&quot;db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, then the result is undefined and is likely a memory access violation.</source>
          <target state="translated">上記のすべてにおいて、FがSQLiteコアからVFSに渡されるデータベース、ジャーナル、またはWALファイル名の名前ではなく、Fが&lt;a href=&quot;db_filename&quot;&gt;sqlite3_db_filename（）&lt;/a&gt;からの戻り値でない場合、結果は未定義であり、メモリである可能性がありますアクセス違反。</target>
        </trans-unit>
        <trans-unit id="650bcf7f3c9667b8bca2e9d81188fd4ca62bdf99" translate="yes" xml:space="preserve">
          <source>In all of the full-text queries above, the right-hand operand of the MATCH operator is a string consisting of a single term. In this case, the MATCH expression evaluates to true for all documents that contain one or more instances of the specified word (&quot;sqlite&quot;, &quot;search&quot; or &quot;database&quot;, depending on which example you look at). Specifying a single term as the right-hand operand of the MATCH operator results in the simplest and most common type of full-text query possible. However more complicated queries are possible, including phrase searches, term-prefix searches and searches for documents containing combinations of terms occurring within a defined proximity of each other. The various ways in which the full-text index may be queried are &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;described below&lt;/a&gt;.</source>
          <target state="translated">上記のすべてのフルテキストクエリで、MATCH演算子の右側のオペランドは、単一の用語で構成される文字列です。この場合、MATCH式は、指定された単語（「sqlite」、「search」、または「database」のどちらを参照するかによって異なります）の1つ以上のインスタンスを含むすべてのドキュメントに対してtrueと評価されます。 MATCH演算子の右側のオペランドとして単一の用語を指定すると、可能な最も単純で最も一般的なタイプのフルテキストクエリになります。ただし、フレーズ検索、用語プレフィックス検索、相互に定義された近接範囲内で発生する用語の組み合わせを含むドキュメントの検索など、より複雑なクエリが可能です。フルテキストインデックスを照会するさまざまな方法を&lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;以下に説明します&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fec3ea71809f1fd12bdd320ecfb2400479f6f909" translate="yes" xml:space="preserve">
          <source>In all of the write tests, it is important to disable anti-virus software prior to running the direct-to-disk performance tests. We found that anti-virus software slows down direct-to-disk by an order of magnitude whereas it impacts SQLite writes very little. This is probably due to the fact that direct-to-disk changes thousands of separate files which all need to be checked by anti-virus, whereas SQLite writes only changes the single database file.</source>
          <target state="translated">すべての書き込みテストでは、直接ディスクへのパフォーマンステストを実行する前に、アンチウイルスソフトウェアを無効にすることが重要です。ウィルス対策ソフトウェアは、SQLite の書き込みにはほとんど影響を与えないのに対し、Direct-to-disk の速度を桁違いに遅くすることがわかりました。これは、SQLite の書き込みが単一のデータベースファイルを変更するだけであるのに対し、Direct-to-disk が何千もの個別ファイルを変更するという事実に起因していると考えられます。</target>
        </trans-unit>
        <trans-unit id="19fd1c2e26ad6ba4190cb1ba85655e3d415fb1a9" translate="yes" xml:space="preserve">
          <source>In all other cases this function returns SQLITE_MISUSE.</source>
          <target state="translated">それ以外の場合、この関数は SQLITE_MISUSE を返します。</target>
        </trans-unit>
        <trans-unit id="a9b1d686d80c16cbd892850ec817e33e118fdb64" translate="yes" xml:space="preserve">
          <source>In all the examples above, there has only been a single SELECT statement. If a query contains sub-selects, those are shown as being children of the outer SELECT. For example:</source>
          <target state="translated">上記のすべての例では、SELECT文は1つしかありません。クエリにサブセレクトが含まれている場合、それらは外側のSELECTの子として表示されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="c9c18ce865540a24f1f5ee5d4ef74324465c3e44" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement, a list of column names can be set to a row value of the same size.</source>
          <target state="translated">&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;ステートメント、列名のリストは、同じサイズの行の値に設定することができます。</target>
        </trans-unit>
        <trans-unit id="34ecd17e630ff3ecf740af54bcb0cb9af6e271db" translate="yes" xml:space="preserve">
          <source>In an expression used as part of an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expridx&quot;&gt;式インデックスの&lt;/a&gt;一部として使用される式の中。</target>
        </trans-unit>
        <trans-unit id="68e31982331dd4f44aeeef7efedd25a5db6a0a14" translate="yes" xml:space="preserve">
          <source>In an index on a WITHOUT ROWID table, if a column of the PRIMARY KEY is also a column in the index and has a matching collating sequence, then the indexed column is not repeated in the table-key suffix on the end of the index record. As an example, consider the following SQL:</source>
          <target state="translated">WITHOUT ROWIDテーブル上のインデックスにおいて、PRIMARY KEYのカラムがインデックス内のカラムでもあり、照合順序が一致している場合、インデックスレコードの末尾のテーブルキー接尾辞では、インデックス化されたカラムは繰り返されません。例として、次のようなSQLを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="b98eca53cbed3b51f01e882fbf03443737203ad3" translate="yes" xml:space="preserve">
          <source>In an interior b-tree page, the pointers and keys logically alternate with a pointer on both ends. (The previous sentence is to be understood conceptually - the actual layout of the keys and pointers within the page is more complicated and will be described in the sequel.) All keys within the same page are unique and are logically organized in ascending order from left to right. (Again, this ordering is logical, not physical. The actual location of keys within the page is arbitrary.) For any key X, pointers to the left of a X refer to b-tree pages on which all keys are less than or equal to X. Pointers to the right of X refer to pages where all keys are greater than X.</source>
          <target state="translated">内部のb-treeページでは、ポインタとキーは論理的に両端にポインタを持って交互に配置されます。(前の文は概念的に理解されるべきものですが、ページ内のキーとポインタの実際のレイアウトはもっと複雑で、後述します)。同じページ内のすべてのキーは一意であり、左から右へと昇順に論理的に整理されています。(繰り返しになりますが、この順序は論理的なものであり、物理的なものではありません。ページ内のキーの実際の位置は任意です)。任意のキーXに対して、Xの左側のポインタは、すべてのキーがX以下かそれ以下のb-treeページを指します。</target>
        </trans-unit>
        <trans-unit id="39488c0191328e370ea86a4f1833476c2e9dc423" translate="yes" xml:space="preserve">
          <source>In an ordinary SQLite table, the PRIMARY KEY is really just a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; index. The key used to look up records on disk is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;. The special &quot;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;&quot; column type in ordinary SQLite tables causes the column to be an alias for the rowid, and so an INTEGER PRIMARY KEY is a true PRIMARY KEY. But any other kind of PRIMARY KEYs, including &quot;INT PRIMARY KEY&quot; are just unique indexes in an ordinary rowid table.</source>
          <target state="translated">通常のSQLiteテーブルでは、PRIMARY KEYは実際には単なる&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;一意の&lt;/a&gt;インデックスです。ディスク上のレコードを検索するために使用されるキーは、&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;です。通常のSQLiteテーブルの特別な「&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;」列タイプでは、列がROWIDのエイリアスになるため、INTEGER PRIMARY KEYは真のPRIMARY KEYです。ただし、「INT PRIMARY KEY」を含む他の種類のPRIMARY KEYは、通常のROWIDテーブル内の一意のインデックスにすぎません。</target>
        </trans-unit>
        <trans-unit id="2602231eda03cd82b0bfe3849f20e2339713b36f" translate="yes" xml:space="preserve">
          <source>In any aggregate function that takes a single argument, that argument can be preceded by the keyword DISTINCT. In such cases, duplicate elements are filtered before being passed into the aggregate function. For example, the function &quot;count(distinct X)&quot; will return the number of distinct values of column X instead of the total number of non-null values in column X.</source>
          <target state="translated">1 つの引数を取る集約関数では、その引数の前にキーワード DISTINCT を付けることができます。このような場合、重複する要素は、集約関数に渡される前にフィルタリングされます。例えば、関数 &quot;count(distinct X)&quot;は、列Xの非ヌル値の合計数ではなく、列Xのdistinctな値の数を返します。</target>
        </trans-unit>
        <trans-unit id="15eb51d3758bed15da54f5c0830882a735d49cb2" translate="yes" xml:space="preserve">
          <source>In any database file that contains ptrmap pages, all b-tree root pages must come before any non-root b-tree page, cell payload overflow page, or freelist page. This restriction ensures that a root page will never be moved during an auto-vacuum or incremental-vacuum. The auto-vacuum logic does not know how to update the root_page field of the sqlite_master table and so it is necessary to prevent root pages from being moved during an auto-vacuum in order to preserve the integrity of the sqlite_master table. Root pages are moved to the beginning of the database file by the CREATE TABLE, CREATE INDEX, DROP TABLE, and DROP INDEX operations.</source>
          <target state="translated">ptrmapページを含むデータベースファイルでは、すべてのb-treeルートページは、ルートではないb-treeページ、セルペイロードオーバーフローページ、フリーリストページの前に置かなければなりません。この制限により、自動バキュームやインクリメンタルバキュームの間にルートページが移動することはありません。自動バキュームロジックはsqlite_masterテーブルのroot_pageフィールドを更新する方法を知らないので、sqlite_masterテーブルの完全性を維持するために自動バキューム中にルートページが移動されないようにする必要があります。ルートページはCREATE TABLE、CREATE INDEX、DROP TABLE、DROP INDEX操作によってデータベースファイルの先頭に移動されます。</target>
        </trans-unit>
        <trans-unit id="d9bc87111dc7feda77c011e8d21c00fc7e80e539" translate="yes" xml:space="preserve">
          <source>In any database file that contains ptrmap pages, all b-tree root pages must come before any non-root b-tree page, cell payload overflow page, or freelist page. This restriction ensures that a root page will never be moved during an auto-vacuum or incremental-vacuum. The auto-vacuum logic does not know how to update the root_page field of the sqlite_schema table and so it is necessary to prevent root pages from being moved during an auto-vacuum in order to preserve the integrity of the sqlite_schema table. Root pages are moved to the beginning of the database file by the CREATE TABLE, CREATE INDEX, DROP TABLE, and DROP INDEX operations.</source>
          <target state="translated">ptrmapページを含むデータベースファイルでは、すべてのb-treeルートページは、ルートではないb-treeページ、セルペイロードオーバーフローページ、フリーリストページの前に置かなければなりません。この制限により、自動バキュームやインクリメンタルバキュームの間にルートページが移動することはありません。自動バキュームロジックはsqlite_schemaテーブルのroot_pageフィールドを更新する方法を知らないので、sqlite_schemaテーブルの完全性を維持するために自動バキューム中にルートページが移動されないようにする必要があります。ルートページはCREATE TABLE、CREATE INDEX、DROP TABLE、DROP INDEX操作によってデータベースファイルの先頭に移動されます。</target>
        </trans-unit>
        <trans-unit id="016fc239bf2f87e674a823e588afff2d09643b5a" translate="yes" xml:space="preserve">
          <source>In automatic EXPLAIN QUERY PLAN mode, the shell automatically runs a separate EXPLAIN QUERY PLAN query for each statement you enter and displays the result before actually running the query. Use the &quot;.eqp off&quot; command to turn automatic EXPLAIN QUERY PLAN mode back off.</source>
          <target state="translated">EXPLAIN QUERY PLAN自動実行モードでは、シェルは、入力された文ごとに別個のEXPLAIN QUERY PLANクエリを自動的に実行し、クエリを実際に実行する前に結果を表示します。自動EXPLAIN QUERY PLANモードをオフにするには、&quot;.eqp off &quot;コマンドを使用してください。</target>
        </trans-unit>
        <trans-unit id="a0296b5facf2017142e185ec710adebd650dd374" translate="yes" xml:space="preserve">
          <source>In batch-mode operation, where an FTS table is initially built up using a large number of INSERT operations, then queried repeatedly without further changes, it is often a good idea to run &quot;optimize&quot; after the last INSERT and before the first query.</source>
          <target state="translated">バッチモードの操作では、FTSテーブルは最初に多数のINSERT操作を使用して構築され、その後、それ以上変更することなく繰り返しクエリを実行する場合、多くの場合、最後のINSERTの後、最初のクエリの前に &quot;optimize &quot;を実行することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="0f704787571a999cc9c3b84bb71144a5bcf64e37" translate="yes" xml:space="preserve">
          <source>In both cases, the split amalgamation can be obtained by substituting &quot;sqlite3-all.c&quot; for &quot;sqlite3.c&quot; as the make target.</source>
          <target state="translated">いずれの場合も、makeターゲットを &quot;sqlite3.c &quot;に &quot;sqlite3-all.c &quot;を代入することで、分割アマルガムが得られます。</target>
        </trans-unit>
        <trans-unit id="fc2950d0c83c287a896b8aadaea3a0c15a77bfa3" translate="yes" xml:space="preserve">
          <source>In brief, sqlite3_wal_checkpoint(D,X) causes the content in the &lt;a href=&quot;../wal&quot;&gt;write-ahead log&lt;/a&gt; for database X on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D to be transferred into the database file and for the write-ahead log to be reset. See the &lt;a href=&quot;../wal#ckpt&quot;&gt;checkpointing&lt;/a&gt; documentation for addition information.</source>
          <target state="translated">簡単に言えば、sqlite3_wal_checkpoint（D、X）は、&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt; D 上のデータベース Xの&lt;a href=&quot;../wal&quot;&gt;先行書き込みログの&lt;/a&gt;内容をデータベースファイルに転送し、先行書き込みログをリセットします。追加情報については、&lt;a href=&quot;../wal#ckpt&quot;&gt;チェックポイントの&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="05e7a053b7377f3e594b4b5661cacef3a8037473" translate="yes" xml:space="preserve">
          <source>In brief, sqlite3_wal_checkpoint(D,X) causes the content in the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; for database X on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D to be transferred into the database file and for the write-ahead log to be reset. See the &lt;a href=&quot;wal#ckpt&quot;&gt;checkpointing&lt;/a&gt; documentation for addition information.</source>
          <target state="translated">簡単に言えば、sqlite3_wal_checkpoint（D、X）は、&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt; D 上のデータベース Xの&lt;a href=&quot;wal&quot;&gt;先行書き込みログの&lt;/a&gt;内容をデータベースファイルに転送し、先行書き込みログをリセットします。追加情報については、&lt;a href=&quot;wal#ckpt&quot;&gt;チェックポイントの&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="9c00ece9c1ea98470c62a3e9e8dcd9514aa371cf" translate="yes" xml:space="preserve">
          <source>In brief, the CPU performance of SQLite is measured as follows:</source>
          <target state="translated">簡単に言うと、SQLiteのCPU性能は以下のように測定されます。</target>
        </trans-unit>
        <trans-unit id="9e64879e9d401b77adebcff06d6d47d07d757ab4" translate="yes" xml:space="preserve">
          <source>In cases where it is complicated, the complications in applying a changeset lie in conflict resolution. Refer to the API documentation linked above for details.</source>
          <target state="translated">複雑な場合、チェンジセットを適用する際の複雑さは、競合の解決にあります。詳細については、上記のリンク先の API ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="0d808e9f43de5ebbcabce2337be4b9dd05f38065" translate="yes" xml:space="preserve">
          <source>In cases where two or more phrase instances overlap (share one or more tokens in common), a single open and close marker is inserted for each set of overlapping phrases. For example:</source>
          <target state="translated">2 つ以上のフレーズ インスタンスが重なっている (1 つ以上のトークンを共有している)場合は、重なっているフレーズのセットごとに 1 つの開閉マーカが挿入されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="c541beea5651ea9308221a19ef6bad8134493156" translate="yes" xml:space="preserve">
          <source>In column mode, each record is shown on a separate line with the data aligned in columns. For example:</source>
          <target state="translated">カラムモードでは、各レコードは別々の行に表示され、データは列に整列して表示されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="27dcedbb38ae9d16b71fde759bf65bb67ce0f587" translate="yes" xml:space="preserve">
          <source>In common use, SQLite databases tend to range in size from a few kilobytes to a few gigabytes, though terabyte-size SQLite databases are known to exist in production.</source>
          <target state="translated">一般的に使用されているSQLiteデータベースのサイズは、数キロバイトから数ギガバイトまでの範囲になりますが、テラバイトサイズのSQLiteデータベースが本番環境に存在することが知られています。</target>
        </trans-unit>
        <trans-unit id="15ec9746d32bfb65e8d0e42717374e59fcc87690" translate="yes" xml:space="preserve">
          <source>In contrast, Fossil is a single standalone binary which is installed by putting it on $PATH. That one binary contains all the functionality of core Git and also GitHub and/or GitLab. It manages a community server with wiki, bug tracking, and forums, provides packaged downloads for consumers, login managements, and so forth, with no extra software required.</source>
          <target state="translated">対照的に、Fossil はスタンドアロンのバイナリで、それを $PATH に置くことでインストールされます。この1つのバイナリにはコアGitのすべての機能が含まれており、GitHubやGitLabも含まれています。wiki、バグ追跡、フォーラムなどのコミュニティサーバーを管理し、消費者向けのパッケージダウンロード、ログイン管理などを提供し、余分なソフトウェアを必要としません。</target>
        </trans-unit>
        <trans-unit id="a51fb2bb312c4e04f9b038dff963c7e47c882987" translate="yes" xml:space="preserve">
          <source>In contrast, Fossil users only need to think about their working directory and the check-in they are working on. That is 60% less distraction. Every developer has a finite number of brain-cycles. Fossil requires fewer brain-cycles to operate, thus freeing up intellectual resources to focus on the software under development.</source>
          <target state="translated">これに対して、Fossilのユーザーは、作業ディレクトリと作業中のチェックインのことだけを考えればいい。これは気が散ることを60%減らすことになります。すべての開発者は有限の脳サイクルを持っています。Fossilは操作に必要なブレインサイクルが少ないので、開発中のソフトウェアに集中するための知的リソースが解放されます。</target>
        </trans-unit>
        <trans-unit id="0fcdb16d38afda3fa9a7a2e8625220ffc33d6191" translate="yes" xml:space="preserve">
          <source>In either case, if performance problems do arise in an SQLite application those problems can often be resolved by adding one or two &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statements to the schema or perhaps running &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; one time and without having to touch a single line of application code. But if a performance problem comes up in a custom or pile-of-files format, the fix will often require extensive changes to application code to add and maintain new indices or to extract information using different algorithms.</source>
          <target state="translated">どちらの場合でも、SQLiteアプリケーションでパフォーマンスの問題が発生した場合、1つまたは2つの&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;ステートメントをスキーマに追加するか、おそらく&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZEを&lt;/a&gt; 1回実行するだけで、アプリケーションコードの1行を変更することなく、問題を解決できます。ただし、パフォーマンスの問題がカスタムまたはパイルオブファイル形式で発生した場合、新しいインデックスを追加して維持したり、さまざまなアルゴリズムを使用して情報を抽出したりするために、アプリケーションコードを大幅に変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="25aa68ecfd2b0c4f0ec2db607f906e4651bce4ef" translate="yes" xml:space="preserve">
          <source>In every case, the pager cache size was adjusted to keep the amount of cache memory at about 2MB. For example, a 2000 page cache was used for 1024 byte pages and a 31 page cache was used for 65536 byte pages. The BLOB values were read in a random order.</source>
          <target state="translated">いずれの場合も、ページャーのキャッシュサイズは、キャッシュメモリ量が2MB程度になるように調整した。例えば、2000ページのキャッシュは1024バイトのページに使用され、31ページのキャッシュは65536バイトのページに使用された。BLOB値はランダムな順序で読み込まれた。</target>
        </trans-unit>
        <trans-unit id="cf40b39d63a8fb0ce771e83c7921ec57173f92f8" translate="yes" xml:space="preserve">
          <source>In extreme cases, consider compiling SQLite with the &lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5&lt;/a&gt; option and then providing SQLite with a fixed chunk of memory to use as its heap via the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;) interface. This will prevent malicious SQL from executing a denial-of-service attack by using an excessive amount of memory. If (say) 5 MB of memory is provided for SQLite to use, once that much has been consumed, SQLite will start returning SQLITE_NOMEM errors, rather than soaking up memory needed by other parts of the application. This also sandboxes SQLite's memory so that a write-after-free error in some other part of the application will not cause problems for SQLite, or vice versa.</source>
          <target state="translated">極端な場合は、&lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5&lt;/a&gt;オプションを使用してSQLiteをコンパイルし、SQLiteに&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;）インターフェースを介してヒープとして使用する固定メモリチャンクを提供することを検討してください。これにより、悪意のあるSQLが過剰な量のメモリを使用してサービス拒否攻撃を実行するのを防ぎます。 （たとえば）SQLiteが使用するために5 MBのメモリが提供されている場合、それが消費されると、SQLiteはアプリケーションの他の部分が必要とするメモリを吸収するのではなく、SQLITE_NOMEMエラーを返し始めます。これはSQLiteのメモリもサンドボックス化するので、アプリケーションの他の部分での解放後の書き込みエラーがSQLiteに問題を引き起こしたり、その逆になったりすることはありません。</target>
        </trans-unit>
        <trans-unit id="b60127a70276716ca6ce96b164af1caff22c34ff" translate="yes" xml:space="preserve">
          <source>In fairness to PostgreSQL, it started thrashing on this test. A knowledgeable administrator might be able to get PostgreSQL to run a lot faster here by tweaking and tuning the server a little.</source>
          <target state="translated">PostgreSQLの公平性を考えれば、このテストでは、PostgreSQLの動作が不安定になっていました。知識のある管理者であれば、サーバを少し調整したりチューニングしたりすることで、PostgreSQLをより高速に動作させることができるかもしれません。</target>
        </trans-unit>
        <trans-unit id="776b2a0854afad2e6c812aae004c09f148d516c9" translate="yes" xml:space="preserve">
          <source>In fairness, having a built-in implementation of printf() also comes with some disadvantages. To wit:</source>
          <target state="translated">公平に考えれば、printf()の組み込み実装を持っていることには、いくつかの欠点もあります。それは、以下のようなことです。</target>
        </trans-unit>
        <trans-unit id="c2fda1dfe98bf18ac7aa5572676942f62e5e1fe2" translate="yes" xml:space="preserve">
          <source>In first form, if the main database has already been created, then this pragma returns the text encoding used by the main database, one of 'UTF-8', 'UTF-16le' (little-endian UTF-16 encoding) or 'UTF-16be' (big-endian UTF-16 encoding). If the main database has not already been created, then the value returned is the text encoding that will be used to create the main database, if it is created by this session.</source>
          <target state="translated">最初の形式では、メインデータベースが既に作成されている場合、このpragmaはメインデータベースで使用されるテキストエンコーディングを、'UTF-8'、'UTF-16le' (リトルエンディアンのUTF-16エンコーディング)、または'UTF-16be' (ビッグエンディアンのUTF-16エンコーディング)のいずれかで返します。メインデータベースがまだ作成されていない場合、返される値は、このセッションでメインデータベースが作成された場合、メインデータベースの作成に使用されるテキストエンコーディングです。</target>
        </trans-unit>
        <trans-unit id="b4265b09e5ee96a8a7b2a30c889a0bcc8a3fb773" translate="yes" xml:space="preserve">
          <source>In formats 4, 7, and 10, the fractional seconds value SS.SSS can have one or more digits following the decimal point. Exactly three digits are shown in the examples because only the first three digits are significant to the result, but the input string can have fewer or more than three digits and the date/time functions will still operate correctly. Similarly, format 12 is shown with 10 significant digits, but the date/time functions will really accept as many or as few digits as are necessary to represent the Julian day number.</source>
          <target state="translated">フォーマット 4、7、および 10 では、端数秒値 SS.SSS は小数点以下に 1 桁以上の数字を持つことができます。この例では、最初の3桁だけが結果にとって重要であるため、正確に3桁の桁が示されていますが、入力文字列は3桁以下でもそれ以上でも構いませんし、日付/時刻関数は依然として正しく動作します。同様に、フォーマット12は10桁の有効数字で示されていますが、日付/時刻関数は、ユリウス日の数字を表すのに必要な数だけ、または数だけの数字を受け入れます。</target>
        </trans-unit>
        <trans-unit id="af29b68f8112f5b3ba3c7546feb616bd5c5cfef7" translate="yes" xml:space="preserve">
          <source>In formats 5 through 7, the &quot;T&quot; is a literal character separating the date and the time, as required by &lt;a href=&quot;http://www.w3c.org/TR/NOTE-datetime&quot;&gt;ISO-8601&lt;/a&gt;. Formats 8 through 10 that specify only a time assume a date of 2000-01-01. Format 11, the string 'now', is converted into the current date and time as obtained from the xCurrentTime method of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object in use. The 'now' argument to date and time functions always returns exactly the same value for multiple invocations within the same &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call. &lt;a href=&quot;http://en.wikipedia.org/wiki/Coordinated_Universal_Time&quot;&gt;Universal Coordinated Time (UTC)&lt;/a&gt; is used. Format 12 is the &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day number&lt;/a&gt; expressed as a floating point value.</source>
          <target state="translated">形式5〜7では、「T」は、&lt;a href=&quot;http://www.w3c.org/TR/NOTE-datetime&quot;&gt;ISO-8601で&lt;/a&gt;要求されているように、日付と時刻を区切るリテラル文字です。時間のみを指定するフォーマット8から10は、2000-01-01の日付を想定しています。形式11、文字列「now」は、使用中の&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;オブジェクトのxCurrentTimeメソッドから取得した現在の日付と時刻に変換されます。日付と時刻関数の 'now'引数は、同じ&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;呼び出し内の複数の呼び出しに対して常に正確に同じ値を返します。&lt;a href=&quot;http://en.wikipedia.org/wiki/Coordinated_Universal_Time&quot;&gt;協定世界時（UTC）&lt;/a&gt;が使用されます。形式12は、浮動小数点値として表される&lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;ユリウス日&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="f289b58633d51c42244b9615eefef812e48059b3" translate="yes" xml:space="preserve">
          <source>In general, you can do anything with a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; that can be done with an ordinary table, except that you cannot create indices or triggers on a virtual table. Some virtual table implementations might impose additional restrictions. For example, many virtual tables are read-only.</source>
          <target state="translated">一般に、&lt;a href=&quot;vtab&quot;&gt;仮想テーブル&lt;/a&gt;でインデックスやトリガーを作成できないことを除いて、通常のテーブルで実行できる仮想テーブルで何でも実行できます。一部の仮想テーブルの実装では、追加の制限が課される場合があります。たとえば、多くの仮想テーブルは読み取り専用です。</target>
        </trans-unit>
        <trans-unit id="eeca88e5ce04c05464f766d95ff0eeb5cfc7eabb" translate="yes" xml:space="preserve">
          <source>In hindsight, we should not have tried to make SQLite accept MySQL 3.x syntax, and should have never allowed double-quoted string literals. However, there are countless applications that make use of double-quoted string literals and so we continue to support that capability to avoid breaking legacy.</source>
          <target state="translated">今思えば、SQLite が MySQL 3.x の構文を受け入れるようにしようとするべきではなかったし、二重引用符で囲まれた文字列リテラルを許可すべきではありませんでした。しかし、二重引用符で囲まれた文字列リテラルを使用するアプリケーションは数え切れないほどあるので、レガシーを壊さないようにその機能をサポートし続けます。</target>
        </trans-unit>
        <trans-unit id="5bb614f9a4728b882cfa854761e8ce05293a6c53" translate="yes" xml:space="preserve">
          <source>In in TRIGGERSs.</source>
          <target state="translated">In in TRIGGERSs.</target>
        </trans-unit>
        <trans-unit id="dc71bff31ad5848828d3dd9115d5b5dfb6294eb3" translate="yes" xml:space="preserve">
          <source>In in VIEWs.</source>
          <target state="translated">in VIEWsで。</target>
        </trans-unit>
        <trans-unit id="f3caa4201cfb419be724f72954ef422185458de8" translate="yes" xml:space="preserve">
          <source>In its default configuration, SQLite API routines return one of 30 integer &lt;a href=&quot;../rescode&quot;&gt;result codes&lt;/a&gt;. However, experience has shown that many of these result codes are too coarse-grained. They do not provide as much information about problems as programmers might like. In an effort to address this, newer versions of SQLite (version 3.3.8 2006-10-09 and later) include support for additional result codes that provide more detailed information about errors. These &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; are enabled or disabled on a per database connection basis using the &lt;a href=&quot;extended_result_codes&quot;&gt;sqlite3_extended_result_codes()&lt;/a&gt; API. Or, the extended code for the most recent error can be obtained using &lt;a href=&quot;errcode&quot;&gt;sqlite3_extended_errcode()&lt;/a&gt;.</source>
          <target state="translated">デフォルトの構成では、SQLite APIルーチンは30の整数&lt;a href=&quot;../rescode&quot;&gt;結果コードの&lt;/a&gt; 1つを返します。ただし、経験から、これらの結果コードの多くは粒度が粗すぎることがわかっています。それらはプログラマーが望むかもしれないほど問題についての多くの情報を提供しません。これに対処するために、SQLiteの新しいバージョン（バージョン3.3.8 2006-10-09以降）では、エラーに関する詳細情報を提供する追加の結果コードのサポートが含まれています。これらの&lt;a href=&quot;../rescode#extrc&quot;&gt;拡張結果コード&lt;/a&gt;は、&lt;a href=&quot;extended_result_codes&quot;&gt;sqlite3_extended_result_codes（）&lt;/a&gt; API を使用して、データベース接続ごとに有効または無効になります。または、最新のエラーの拡張コードは、&lt;a href=&quot;errcode&quot;&gt;sqlite3_extended_errcode（）&lt;/a&gt;を使用して取得できます。</target>
        </trans-unit>
        <trans-unit id="3039a66b6632d9561c27b79f80cd7bfba4d1c329" translate="yes" xml:space="preserve">
          <source>In its default configuration, SQLite API routines return one of 30 integer &lt;a href=&quot;rescode&quot;&gt;result codes&lt;/a&gt;. However, experience has shown that many of these result codes are too coarse-grained. They do not provide as much information about problems as programmers might like. In an effort to address this, newer versions of SQLite (version 3.3.8 2006-10-09 and later) include support for additional result codes that provide more detailed information about errors. These &lt;a href=&quot;rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; are enabled or disabled on a per database connection basis using the &lt;a href=&quot;#sqlite3_extended_result_codes&quot;&gt;sqlite3_extended_result_codes()&lt;/a&gt; API. Or, the extended code for the most recent error can be obtained using &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_extended_errcode()&lt;/a&gt;.</source>
          <target state="translated">デフォルトの構成では、SQLite APIルーチンは30の整数&lt;a href=&quot;rescode&quot;&gt;結果コードの&lt;/a&gt; 1つを返します。ただし、経験から、これらの結果コードの多くは粒度が粗すぎることがわかっています。それらはプログラマーが望むかもしれないほど問題についての多くの情報を提供しません。これに対処するために、SQLiteの新しいバージョン（バージョン3.3.8 2006-10-09以降）では、エラーに関する詳細情報を提供する追加の結果コードのサポートが含まれています。これらの&lt;a href=&quot;rescode#extrc&quot;&gt;拡張結果コード&lt;/a&gt;は、&lt;a href=&quot;#sqlite3_extended_result_codes&quot;&gt;sqlite3_extended_result_codes（）&lt;/a&gt; API を使用して、データベース接続ごとに有効または無効になります。または、最新のエラーの拡張コードは、&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_extended_errcode（）&lt;/a&gt;を使用して取得できます。</target>
        </trans-unit>
        <trans-unit id="c851426635cb37e8f1ffc6284cb9e22ec511a9f4" translate="yes" xml:space="preserve">
          <source>In keeping with the pile-of-files theme, OpenDocument stores all slide content in a single big XML file named &quot;content.xml&quot;. LibreOffice reads and parses this entire file just to display the first slide. LibreOffice also seems to read all images into memory as well, which makes sense seeing as when the user does &quot;File/Save&quot; it is going to have to write them all back out again, even though none of them changed. The net effect is that start-up is slow. Double-clicking an OpenDocument file brings up a progress bar rather than the first slide. This results in a bad user experience. The situation grows ever more annoying as the document size increases.</source>
          <target state="translated">ファイルの山」というテーマに沿って、OpenDocument はすべてのスライドの内容を「content.xml」という名前の単一の大きな XML ファイルに保存します。LibreOfficeは、最初のスライドを表示するためだけに、このファイル全体を読み込んで解析します。LibreOfficeはまた、すべての画像をメモリに読み込んでいるようです。これは、ユーザーが「ファイル/保存」をするときに、何も変更していないにもかかわらず、すべての画像を再び書き出さなければならないことを考えると、理にかなっています。その結果、起動が遅くなります。OpenDocumentファイルをダブルクリックすると、最初のスライドではなくプログレスバーが表示されます。これは悪いユーザー体験になります。この状況は、ドキュメントのサイズが大きくなるにつれて、ますますイライラしてきます。</target>
        </trans-unit>
        <trans-unit id="c55972e777545acb2431d05db4c4023b23be4d2b" translate="yes" xml:space="preserve">
          <source>In many cases, method (1) above is the best approach. It does not add extra data to the FTS index or require FTS5 to query for multiple terms, so it is efficient in terms of disk space and query speed. However, it does not support prefix queries very well. If, as suggested above, the token &quot;first&quot; is substituted for &quot;1st&quot; by the tokenizer, then the query:</source>
          <target state="translated">多くの場合、上記(1)の方法が最良のアプローチである。この方法は、FTSインデックスに余分なデータを追加したり、FTS5に複数の用語の問い合わせを要求したりすることがないので、ディスク容量や問い合わせ速度の点で効率的です。しかし、プレフィックスクエリはあまりサポートしていません。上で提案されているように、トークンライザによってトークン「1st」が「1st」に置き換えられた場合、クエリは</target>
        </trans-unit>
        <trans-unit id="5d477280cde1f0cb61a1a86eeb18153043aeb432" translate="yes" xml:space="preserve">
          <source>In most SQL databases, if you have a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;, &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt;, or &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt; constraint on a table and you try to do an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; that violates the constraint, the database will abort the operation in progress, back out any prior changes associated with the same UPDATE or INSERT statement, and return an error. This is the default behavior of SQLite, though SQLite also allows one to define alternative ways for dealing with constraint violations. This article describes those alternatives and how to use them.</source>
          <target state="translated">ほとんどのSQLデータベースでは、テーブルに&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;、&lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt;、または&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt;制約があり、制約に違反する&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;または&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;を実行しようとすると、データベースは進行中の操作を中止し、関連する以前の変更をすべて取り消します。同じUPDATEまたはINSERTステートメントで、エラーを返します。これはSQLiteのデフォルトの動作ですが、SQLiteでは制約違反に対処するための代替方法を定義することもできます。この記事では、これらの代替策とその使用方法について説明します。</target>
        </trans-unit>
        <trans-unit id="a92a8e52f2222eb943cf97b12f1b58ee960571a6" translate="yes" xml:space="preserve">
          <source>In most SQL implementations, output columns of an aggregate query may only reference aggregate functions or columns named in the GROUP BY clause. It does not make good sense to reference an ordinary column in an aggregate query because each output row might be composed from two or more rows in the input table(s).</source>
          <target state="translated">ほとんどのSQL実装では、集約クエリの出力カラムは集約関数かGROUP BY句で指定されたカラムのみを参照することができます。各出力行は入力テーブルの2つ以上の行から構成されている可能性があるため、集約クエリで通常のカラムを参照することはあまり意味がありません。</target>
        </trans-unit>
        <trans-unit id="ebf21aed9282198e08f544c4b59f1cde35658d89" translate="yes" xml:space="preserve">
          <source>In most applications, the database page cache subsystem within SQLite uses more dynamically allocated memory than all other parts of SQLite combined. It is not unusual to see the database page cache consume over 10 times more memory than the rest of SQLite combined.</source>
          <target state="translated">ほとんどのアプリケーションでは、SQLite 内のデータベースページキャッシュサブシステムは、SQLite の他のすべての部分を合わせたものよりも多くの動的に割り当てられたメモリを使用しています。データベースページキャッシュがSQLiteの他の部分を合わせると10倍以上のメモリを消費することも珍しくありません。</target>
        </trans-unit>
        <trans-unit id="ea5d93a0bdef6b6a869ec9bc6ec20416d6dd4af5" translate="yes" xml:space="preserve">
          <source>In most applications, the number of columns is small - a few dozen. There are places in the SQLite code generator that use algorithms that are O(N&amp;sup2;) where N is the number of columns. So if you redefine SQLITE_MAX_COLUMN to be a really huge number and you generate SQL that uses a large number of columns, you may find that &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; runs slowly.</source>
          <target state="translated">ほとんどのアプリケーションでは、列の数は少なく、数ダースです。SQLiteコードジェネレーターには、O（N&amp;sup2;）のアルゴリズムを使用する場所があります。Nは列数です。そのため、SQLITE_MAX_COLUMNを非常に大きな数に再定義し、多数の列を使用するSQLを生成すると、&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）の&lt;/a&gt;実行が遅くなることがあります。</target>
        </trans-unit>
        <trans-unit id="5715db4d1b11556e8f8726b68f211a79da84d8fd" translate="yes" xml:space="preserve">
          <source>In most cases, UNIQUE and PRIMARY KEY constraints are implemented by creating a unique index in the database. (The exceptions are &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; and PRIMARY KEYs on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.) Hence, the following schemas are logically equivalent:</source>
          <target state="translated">ほとんどの場合、UNIQUEおよびPRIMARY KEY制約は、データベースに一意のインデックスを作成することによって実装されます。（例外は、&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルの&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;およびPRIMARY KEYです。）したがって、次のスキーマは論理的に同等です。</target>
        </trans-unit>
        <trans-unit id="5a1cd73f371732c3b6f817956ff2682bb7f1000a" translate="yes" xml:space="preserve">
          <source>In most cases, you will want to supplement the basic commands above with &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; appropriate for your application. Commonly used compile-time options include:</source>
          <target state="translated">ほとんどの場合、上記の基本的なコマンドを、アプリケーションに適した&lt;a href=&quot;compile&quot;&gt;コンパイル時オプション&lt;/a&gt;で補足する必要があります。一般的に使用されるコンパイル時オプションは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="97ef5a309f4aafbcba4ef803b72a915f31e696d6" translate="yes" xml:space="preserve">
          <source>In most contexts, the special &quot;rowid&quot; column of normal tables can also be called &quot;oid&quot; or &quot;_rowid_&quot;. However, only &quot;rowid&quot; works as the keyword in the CREATE TABLE statement.</source>
          <target state="translated">ほとんどの文脈では、通常のテーブルの特別な &quot;rowid &quot;カラムは &quot;oid &quot;や&quot;_rowid_&quot;と呼ぶこともできます。しかし、&quot;rowid &quot;のみがCREATE TABLE文のキーワードとして機能します。</target>
        </trans-unit>
        <trans-unit id="08bdbf2096af9fe45fd4ac595bd3e0c7bb6e8da7" translate="yes" xml:space="preserve">
          <source>In most other SQL database engines the datatype is associated with the table column that holds the data - with the data container. In SQLite 3.0, the datatype is associated with the data itself, not with its container. &lt;a href=&quot;http://www.paulgraham.com/&quot;&gt;Paul Graham&lt;/a&gt; in his book</source>
          <target state="translated">他のほとんどのSQLデータベースエンジンでは、データ型は、データを保持するテーブル列に関連付けられています-データコンテナー。SQLite 3.0では、データ型はコンテナではなくデータ自体に関連付けられています。&lt;a href=&quot;http://www.paulgraham.com/&quot;&gt;ポール・グラハム&lt;/a&gt;の著書</target>
        </trans-unit>
        <trans-unit id="9b4441386a86e2d230e048847afd960634eadb47" translate="yes" xml:space="preserve">
          <source>In normal cases, new content is appended to the WAL file until the WAL file accumulates about 1000 pages (and is thus about 4MB in size) at which point a checkpoint is automatically run and the WAL file is recycled. The checkpoint does not normally truncate the WAL file (unless the &lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;journal_size_limit pragma&lt;/a&gt; is set). Instead, it merely causes SQLite to start overwriting the WAL file from the beginning. This is done because it is normally faster to overwrite an existing file than to append. When the last connection to a database closes, that connection does one last checkpoint and then deletes the WAL and its associated shared-memory file, to clean up the disk.</source>
          <target state="translated">通常の場合、新しいコンテンツは、WALファイルが約1000ページ（したがって、サイズが約4MB）になるまでチェックポイントが自動的に実行され、WALファイルがリサイクルされるまで、WALファイルに追加されます。チェックポイントは通常、WALファイルを切り捨てません（&lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;journal_size_limitプラグマ&lt;/a&gt;が設定されていない場合）。代わりに、SQLiteに最初からWALファイルの上書きを開始させるだけです。これは、通常、追加するよりも既存のファイルを上書きする方が速いためです。データベースへの最後の接続が閉じると、その接続は最後の1つのチェックポイントを実行し、WALとそれに関連する共有メモリファイルを削除して、ディスクをクリーンアップします。</target>
        </trans-unit>
        <trans-unit id="9b10dbf3c620afa11c457409454feda884f8c775" translate="yes" xml:space="preserve">
          <source>In older versions of SQLite, shared cache mode could not be used together with virtual tables. This restriction was removed in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;version 3.6.17&lt;/a&gt; (2009-08-10).</source>
          <target state="translated">SQLiteの古いバージョンでは、共有キャッシュモードは仮想テーブルと一緒に使用できませんでした。この制限はSQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;バージョン3.6.17&lt;/a&gt;（2009-08-10）で削除されました。</target>
        </trans-unit>
        <trans-unit id="c0ec8617fee4e8f946bad89174a49f940e3f428d" translate="yes" xml:space="preserve">
          <source>In one test that indexed a large set of emails (1636 MiB on disk), the FTS index was 743 MiB on disk with detail=full, 340 MiB with detail=column and 134 MiB with detail=none.</source>
          <target state="translated">大規模な電子メールのセット(ディスク上の1636 MiB)をインデックス化した1つのテストでは、FTSのインデックスはディスク上の743 MiB(detail=fullの場合)、340 MiB(detail=columnの場合)、134 MiB(detail=noneの場合)となっていました。</target>
        </trans-unit>
        <trans-unit id="79708a29f43e4b6af877ac3750b35c58a6cfa4a6" translate="yes" xml:space="preserve">
          <source>In order for an application to &lt;a href=&quot;fts5#extending_fts5&quot;&gt;add new extensions to FTS5&lt;/a&gt;, such as new tokenizers, the application needs a pointer to the &quot;fts5_api&quot; object.</source>
          <target state="translated">アプリケーションで&lt;a href=&quot;fts5#extending_fts5&quot;&gt;FTS5&lt;/a&gt;に新しいトークナイザーなどの新しい拡張機能を追加するには、アプリケーションに「fts5_api」オブジェクトへのポインターが必要です。</target>
        </trans-unit>
        <trans-unit id="28a836bfad6faf09ee027032e5467aeee1a64f66" translate="yes" xml:space="preserve">
          <source>In order for the OR-by-UNION technique shown above to be useful, there must be an index available that helps resolve every OR-connected term in the WHERE clause. If even a single OR-connected term is not indexed, then a full table scan would have to be done in order to find the rowids generated by the one term, and if SQLite has to do a full table scan, it might as well do it on the original table and get all of the results in a single pass without having to mess with union operations and follow-on binary searches.</source>
          <target state="translated">上で示した OR-by-UNION テクニックを有効にするためには、WHERE 句の中の OR 接続されたすべての項を解決するのに役立つインデックスが必要です。もし単一の OR 接続された項がインデックス化されていない場合は、その項が生成した行 ID を見つけるためにテーブルのフルスキャンを行わなければなりません。</target>
        </trans-unit>
        <trans-unit id="eb3713c378b1d1ce3d9a0c47d48cd2eaea6cff83" translate="yes" xml:space="preserve">
          <source>In order to allow multiple threads to use the same database connection at the same time, SQLite must make extensive use of mutexes. And for this reason a new mutex subsystem as been added. The mutex subsystem as the following interface:</source>
          <target state="translated">複数のスレッドが同時に同じデータベース接続を使用できるようにするためには、SQLite はミューテックスを広く利用しなければなりません。このため、新しいミューテックスサブシステムが追加されました。ミューテックスサブシステムは次のようなインターフェースです。</target>
        </trans-unit>
        <trans-unit id="2b5d71d84c9eba5a8b5eeb690db9b2671be986f0" translate="yes" xml:space="preserve">
          <source>In order to avoid this problem, instead of a single large buffer, input is passed to a streaming API functions by way of a callback function that the sessions module invokes to incrementally request input data as it is required. In all cases, a pair of API function parameters such as</source>
          <target state="translated">この問題を避けるために、入力は単一の大きなバッファの代わりに、必要に応じて入力データをインクリメンタルに要求するためにセッションモジュールが呼び出すコールバック関数を介してストリーミングAPI関数に渡されます。どのような場合でも、API関数のパラメータとして</target>
        </trans-unit>
        <trans-unit id="4b125f2963fbbbf781a2aacf5295274d0ac9b884" translate="yes" xml:space="preserve">
          <source>In order to calculate a documents score, the full-text query is separated into its component phrases. The bm25 score for document</source>
          <target state="translated">ドキュメントのスコアを計算するために、フルテキストクエリを構成フレーズに分離します。ドキュメントのBM25スコア</target>
        </trans-unit>
        <trans-unit id="7154e5ea3dd269ef8c7a3c815659cc160be40ee6" translate="yes" xml:space="preserve">
          <source>In order to change the mapping of the rank column for a single query, a term similar to either of the following is added to the WHERE clause of a query:</source>
          <target state="translated">単一のクエリのランク列のマッピングを変更するには、以下のいずれかに似た用語をクエリのWHERE句に追加します。</target>
        </trans-unit>
        <trans-unit id="2abb792779e09d00b7b2cceff1ab43c73c0ae359" translate="yes" xml:space="preserve">
          <source>In order to create an FTS4 table that does not store a copy of the indexed documents at all, the content option should be set to an empty string. For example, the following SQL creates such an FTS4 table with three columns - &quot;a&quot;, &quot;b&quot;, and &quot;c&quot;:</source>
          <target state="translated">インデックス化された文書のコピーを全く保存しないFTS4テーブルを作成するためには、contentオプションを空の文字列に設定する必要があります。例えば、以下のSQLは、&quot;a&quot;、&quot;b&quot;、&quot;c &quot;の3つのカラムを持つこのようなFTS4テーブルを作成します。</target>
        </trans-unit>
        <trans-unit id="dfa1c414109c4c2ee027ceb1647c28553c0a4044" translate="yes" xml:space="preserve">
          <source>In order to create or modify an existing zip file, a &quot;zipfile&quot; virtual table must be created in the database schema. The CREATE VIRTUAL TABLE statement expects a path to the zip file as its only argument. For example, to write to zip file &quot;test.zip&quot; in the current directory, a zipfile table may be created using:</source>
          <target state="translated">既存の zip ファイルを作成または変更するには、データベーススキーマに &quot;zipfile&quot; 仮想テーブルを作成する必要があります。CREATE VIRTUAL TABLE文は、唯一の引数としてzipファイルへのパスを指定します。例えば、カレントディレクトリ内のzipファイル &quot;test.zip &quot;に書き込むには、以下のようにしてzipファイルテーブルを作成します。</target>
        </trans-unit>
        <trans-unit id="46eb456df96a41735386e11e34c4d6e23c625078" translate="yes" xml:space="preserve">
          <source>In order to determine whether or not the database file has changed, SQLite uses a counter in the database header (in bytes 24 through 27) which is incremented during every change operation. SQLite saves a copy of this counter prior to releasing its database lock. Then after acquiring the next database lock it compares the saved counter value against the current counter value and erases the cache if the values are different, or reuses the cache if they are the same.</source>
          <target state="translated">データベースファイルが変更されたかどうかを判断するために、SQLite はデータベースヘッダ内のカウンタ(24 バイトから 27 バイトまで)を使用します。SQLite はデータベースロックを解放する前にこのカウンタのコピーを保存します。次のデータベースロックを取得した後、SQLiteは保存されたカウンタの値を現在のカウンタの値と比較し、値が異なる場合はキャッシュを消去し、値が同じ場合はキャッシュを再利用します。</target>
        </trans-unit>
        <trans-unit id="c5338f8b41864bbeb0f4c2c2e58a285f7e7a5717" translate="yes" xml:space="preserve">
          <source>In order to gain experience with the main ideas surrounding asynchronous IO, this implementation is deliberately kept simple. Additional capabilities may be added in the future.</source>
          <target state="translated">非同期 IO に関する主な考え方を経験するために、この実装は意図的にシンプルにしています。将来的には追加機能が追加されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="a809ecf69a6ad9ffe3bc78cfb9dbeacb5971a731" translate="yes" xml:space="preserve">
          <source>In order to guarantee that database files are always consistent, SQLite will occasionally ask the operating system to flush all pending writes to persistent storage then wait for that flush to complete. This is accomplished using the &lt;code&gt;fsync()&lt;/code&gt; system call under unix and &lt;code&gt;FlushFileBuffers()&lt;/code&gt; under Windows. We call this flush of pending writes a &quot;sync&quot;.</source>
          <target state="translated">データベースファイルが常に一貫していることを保証するために、SQLiteはオペレーティングシステムに永続ストレージへの保留中のすべての書き込みをフラッシュして、そのフラッシュが完了するのを待つように要求することがあります。これは、使用して達成される &lt;code&gt;fsync()&lt;/code&gt; UNIXと下のシステムコール &lt;code&gt;FlushFileBuffers()&lt;/code&gt; Windowsで。この保留中の書き込みのフラッシュを「同期」と呼びます。</target>
        </trans-unit>
        <trans-unit id="78171183b8bae18fcaabb772e335a2f85feaf3a5" translate="yes" xml:space="preserve">
          <source>In order to maintain backwards compatibility, this setting is ON by default. There are advantages to turning it off, and most applications will be unaffected if it is turned off. For that reason, all applications are encouraged to switch this setting off on every database connection as soon as that connection is opened.</source>
          <target state="translated">後方互換性を維持するために、この設定はデフォルトでオンになっています。この設定をオフにすることには利点があり、オフにしてもほとんどのアプリケーションは影響を受けません。そのため、すべてのアプリケーションでは、データベース接続が開かれたらすぐにこの設定をオフにすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="3d3d52a785446942df482ef9658c77840bb31674" translate="yes" xml:space="preserve">
          <source>In order to maintain full backwards compatibility for legacy applications, the URI filename capability is disabled by default. URI filenames can be enabled or disabled using the &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI=1&lt;/a&gt; or &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI=0&lt;/a&gt; compile-time options. The compile-time setting for URI filenames can be changed at start-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;,1) or &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;,0) configuration calls. Regardless of the compile-time or start-time settings, URI filenames can be enabled for individual database connections by including the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; bit in the set of bits passed as the F parameter to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2(N,P,F,V)&lt;/a&gt;.</source>
          <target state="translated">レガシーアプリケーションの完全な下位互換性を維持するために、URIファイル名機能はデフォルトで無効になっています。&lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI = 1&lt;/a&gt;または&lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI = 0&lt;/a&gt;コンパイル時オプションを使用して、URIファイル名を有効または無効にできます。URIファイル名のコンパイル時設定は、&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;、1）または&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;、0）構成呼び出しを使用して、開始時に変更できます。コンパイル時または開始時の設定に関係なく、F &lt;a href=&quot;c3ref/open&quot;&gt;ファイル&lt;/a&gt;としてsqlite3_open_v2（N、P、F、V）に渡されるビットのセットに&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;ビットを含めることにより、個々のデータベース接続でURIファイル名を有効にできます。。</target>
        </trans-unit>
        <trans-unit id="ee9ce9696c9f5b398459fe9fa5003d871b602ba2" translate="yes" xml:space="preserve">
          <source>In order to maximize compatibility between SQLite and other database engines, and so that the example above will work on SQLite as it does on other SQL database engines, SQLite supports the concept of &quot;type affinity&quot; on columns. The type affinity of a column is the recommended type for data stored in that column. The important idea here is that the type is recommended, not required. Any column can still store any type of data. It is just that some columns, given the choice, will prefer to use one storage class over another. The preferred storage class for a column is called its &quot;affinity&quot;.</source>
          <target state="translated">SQLiteと他のデータベースエンジン間の互換性を最大化し、上記の例がSQLite上でも他のSQLデータベースエンジンと同様に動作するようにするために、SQLiteはカラムの &quot;型の親和性 &quot;という概念をサポートしています。カラムの型の親和性とは、そのカラムに格納されているデータに推奨される型のことです。ここで重要なのは、型は推奨されるものであり、必須ではないということです。どのカラムでも、どのようなタイプのデータを格納することができます。ただ、いくつかのカラムは、選択の余地があれば、別のストレージクラスよりも、あるストレージクラスを使用することを好むということです。カラムに好ましいストレージクラスは、その「親和性」と呼ばれています。</target>
        </trans-unit>
        <trans-unit id="c4c58e4d4912a4704b0cbb27832e1afdc4578e5c" translate="yes" xml:space="preserve">
          <source>In order to port SQLite to a new operating system - an operating system not supported by default - the application must provide...</source>
          <target state="translated">SQLite を新しいオペレーティング・システム(デフォルトではサポートされていないオペレーティング・システム)に移植するためには、アプリケーションは...</target>
        </trans-unit>
        <trans-unit id="9139039adfb729ff69195002226ce412be58a20b" translate="yes" xml:space="preserve">
          <source>In order to prevent the number of b-trees in the database from becoming too large (slowing down queries), smaller b-trees are periodically merged into single larger b-trees containing the same data. By default, this happens automatically within INSERT, UPDATE or DELETE statements that modify the full-text index. The 'automerge' parameter determines how many smaller b-trees are merged together at a time. Setting it to a small value can speed up queries (as they have to query and merge the results from fewer b-trees), but can also slow down writing to the database (as each INSERT, UPDATE or DELETE statement has to do more work as part of the automatic merging process).</source>
          <target state="translated">データベース内のb-木の数が大きくなりすぎてクエリが遅くなるのを防ぐために、小さなb-木は定期的に同じデータを含む単一の大きなb-木にマージされます。デフォルトでは、これはフルテキストインデックスを変更するINSERT、UPDATE、またはDELETE文の中で自動的に行われます。automerge' パラメータは、一度に何本の小さな b-木をマージするかを決定します。これを小さな値に設定すると、クエリを高速化することができます(より少ないb-木からの結果をクエリしてマージしなければならないので)が、データベースへの書き込みを遅くすることもできます(各INSERT、UPDATE、またはDELETE文は、自動マージ処理の一部としてより多くの作業をしなければならないので)。</target>
        </trans-unit>
        <trans-unit id="3d48be902e74206d36d33669d85fb41c800c7878" translate="yes" xml:space="preserve">
          <source>In order to provide portability between across operating systems, SQLite uses abstract object called the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. Each VFS provides methods for opening, read, writing, and closing files on disk, and for other OS-specific task such as finding the current time, or obtaining randomness to initialize the built-in pseudo-random number generator. SQLite currently provides VFSes for unix (in the &lt;a href=&quot;https://sqlite.org/src/file/src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt; file) and Windows (in the &lt;a href=&quot;https://sqlite.org/src/file/src/os_win.c&quot;&gt;os_win.c&lt;/a&gt; file).</source>
          <target state="translated">SQLiteは、オペレーティングシステム間での移植性を提供するために、&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;と呼ばれる抽象オブジェクトを使用します。各VFSは、ディスク上のファイルを開いたり、読み込んだり、書き込んだり、閉じたりするためのメソッドを提供します。また、現在の時刻を検索したり、ランダム性を取得して組み込みの疑似乱数ジェネレーターを初期化したりするなど、他のOS固有のタスクを実行します。 SQLiteは現在、UNIX（&lt;a href=&quot;https://sqlite.org/src/file/src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt;ファイル内）およびWindows（os_win.cファイル内）用のVFSを提供して&lt;a href=&quot;https://sqlite.org/src/file/src/os_win.c&quot;&gt;い&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="31ad990efe0b69348774fca33a1caeca8003e9e6" translate="yes" xml:space="preserve">
          <source>In order to rebase a local changeset, the remote changeset must first be applied to the local database using sqlite3changeset_apply_v2() and the buffer of rebase information captured. Then:</source>
          <target state="translated">ローカルのチェンジセットをリベースするためには、まずリモートのチェンジセットをsqlite3changeset_apply_v2()を使用してローカルのデータベースに適用し、リベース情報のバッファをキャプチャしなければなりません。そして、リベース情報のバッファをキャプチャします。</target>
        </trans-unit>
        <trans-unit id="aa098185ca802c3d4bb821bfd07089d8121f87d8" translate="yes" xml:space="preserve">
          <source>In order to return data from the database to the user, for example as the results of a SELECT query, SQLite must at some point read data from the database file. Usually, data is read from the database file in aligned blocks of</source>
          <target state="translated">データベースからデータをユーザーに返すためには、例えばSELECTクエリの結果として、SQLiteはある時点でデータベースファイルからデータを読み込まなければなりません。通常、データはデータベースファイルから</target>
        </trans-unit>
        <trans-unit id="fbe7b2f0d6747492938cc0cedd14f11e91e462ca" translate="yes" xml:space="preserve">
          <source>In order to save space, this backing table may be omitted by setting the columnsize option to zero. For example:</source>
          <target state="translated">スペースを節約するために、columnizeオプションを0に設定することで、この裏付け表を省略することができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="1dc49d196adf92707040503b638c58b0d1b51283" translate="yes" xml:space="preserve">
          <source>In order to succeed, the database connection must not be in &lt;a href=&quot;#sqlite3_get_autocommit&quot;&gt;autocommit mode&lt;/a&gt; when &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; is called. If there is already a read transaction open on schema S, then the database handle must have no active statements (SELECT statements that have been passed to sqlite3_step() but not sqlite3_reset() or sqlite3_finalize()). SQLITE_ERROR is returned if either of these conditions is violated, or if schema S does not exist, or if the snapshot object is invalid.</source>
          <target state="translated">成功するには、&lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open（D、S、P）&lt;/a&gt;が呼び出されたときにデータベース接続が&lt;a href=&quot;#sqlite3_get_autocommit&quot;&gt;自動コミットモードであって&lt;/a&gt;はなりません。スキーマSですでに開いている読み取りトランザクションがある場合、データベースハンドルにはアクティブなステートメント（sqlite3_step（）に渡され、sqlite3_reset（）またはsqlite3_finalize（）には渡されないSELECTステートメント）があってはなりません。これらの条件のいずれかに違反した場合、スキーマSが存在しない場合、またはスナップショットオブジェクトが無効な場合は、SQLITE_ERRORが返されます。</target>
        </trans-unit>
        <trans-unit id="4bcc91176e8c72eef945e65a5e94e40093e70723" translate="yes" xml:space="preserve">
          <source>In order to succeed, the database connection must not be in &lt;a href=&quot;get_autocommit&quot;&gt;autocommit mode&lt;/a&gt; when &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; is called. If there is already a read transaction open on schema S, then the database handle must have no active statements (SELECT statements that have been passed to sqlite3_step() but not sqlite3_reset() or sqlite3_finalize()). SQLITE_ERROR is returned if either of these conditions is violated, or if schema S does not exist, or if the snapshot object is invalid.</source>
          <target state="translated">成功するには、&lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open（D、S、P）&lt;/a&gt;が呼び出されたときにデータベース接続が&lt;a href=&quot;get_autocommit&quot;&gt;自動コミットモードであって&lt;/a&gt;はなりません。スキーマSですでに開いている読み取りトランザクションがある場合、データベースハンドルにはアクティブなステートメント（sqlite3_step（）に渡され、sqlite3_reset（）またはsqlite3_finalize（）には渡されないSELECTステートメント）があってはなりません。これらの条件のいずれかに違反した場合、スキーマSが存在しない場合、またはスナップショットオブジェクトが無効な場合は、SQLITE_ERRORが返されます。</target>
        </trans-unit>
        <trans-unit id="3885c40685a2b0fc9bd29a3371e31ed82a66178a" translate="yes" xml:space="preserve">
          <source>In order to use FTS5 instead of FTS3 or FTS4, applications usually require minimal modifications. Most of these fall into three categories - changes required to the CREATE VIRTUAL TABLE statement used to create the FTS table, changes required to SELECT queries used to execute queries against the table, and changes required to applications that use &lt;a href=&quot;fts3#snippet&quot;&gt;FTS auxiliary functions&lt;/a&gt;.</source>
          <target state="translated">FTS3またはFTS4の代わりにFTS5を使用するために、アプリケーションは通常最小限の変更を必要とします。これらのほとんどは、FTSテーブルの作成に使用されるCREATE VIRTUAL TABLEステートメントに必要な変更、テーブルに対するクエリの実行に使用されるSELECTクエリに必要な変更、および&lt;a href=&quot;fts3#snippet&quot;&gt;FTS補助関数&lt;/a&gt;を使用するアプリケーションに必要な変更の3つのカテゴリに分類されます。</target>
        </trans-unit>
        <trans-unit id="362a80a01b0db13fb3dac03d2ae8d3c5e2853e16" translate="yes" xml:space="preserve">
          <source>In order to use foreign key constraints in SQLite, the library must be compiled with neither &lt;a href=&quot;compile#omit_foreign_key&quot;&gt;SQLITE_OMIT_FOREIGN_KEY&lt;/a&gt; or &lt;a href=&quot;compile#omit_trigger&quot;&gt;SQLITE_OMIT_TRIGGER&lt;/a&gt; defined. If SQLITE_OMIT_TRIGGER is defined but SQLITE_OMIT_FOREIGN_KEY is not, then SQLite behaves as it did prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;version 3.6.19&lt;/a&gt; (2009-10-14) - foreign key definitions are parsed and may be queried using &lt;a href=&quot;pragma#pragma_foreign_key_list&quot;&gt;PRAGMA foreign_key_list&lt;/a&gt;, but foreign key constraints are not enforced. The &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; command is a no-op in this configuration. If OMIT_FOREIGN_KEY is defined, then foreign key definitions cannot even be parsed (attempting to specify a foreign key definition is a syntax error).</source>
          <target state="translated">SQLiteで外部キー制約を使用するには、&lt;a href=&quot;compile#omit_foreign_key&quot;&gt;SQLITE_OMIT_FOREIGN_KEY&lt;/a&gt;または&lt;a href=&quot;compile#omit_trigger&quot;&gt;SQLITE_OMIT_TRIGGERが&lt;/a&gt;定義されていない状態でライブラリをコンパイルする必要があります。 SQLITE_OMIT_TRIGGERは定義されているがSQLITE_OMIT_FOREIGN_KEYが定義されていない場合、SQLiteは&lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;バージョン3.6.19&lt;/a&gt;（2009-10-14）より前と同じように動作します-外部キー定義は解析され、&lt;a href=&quot;pragma#pragma_foreign_key_list&quot;&gt;PRAGMA foreign_key_list&lt;/a&gt;を使用してクエリできますが、外部キー制約は強制されません。&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA FOREIGN_KEYS&lt;/a&gt;コマンドは、この構成では何もしません。 OMIT_FOREIGN_KEYが定義されている場合、外部キー定義を解析することもできません（外部キー定義を指定しようとすると、構文エラーになります）。</target>
        </trans-unit>
        <trans-unit id="2a10b918ff09134ab69409cf683db7b4a9557318" translate="yes" xml:space="preserve">
          <source>In order to use this command to delete a row, the text value 'delete' must be inserted into the special column with the same name as the table. The rowid of the row to delete is inserted into the rowid column. The values inserted into the other columns must match the values currently stored in the table. For example:</source>
          <target state="translated">このコマンドを使用して行を削除するためには、テーブルと同じ名前の特殊な列にテキスト値「delete」を挿入する必要があります。削除する行の rowid が rowid 列に挿入されます。他の列に挿入される値は、現在テーブルに格納されている値と一致している必要があります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="18acf9de092948631a77a8a7268e93e0863d7575" translate="yes" xml:space="preserve">
          <source>In ordinary indexes, there is exactly one entry in the index for every row in the table. In partial indexes, only some subset of the rows in the table have corresponding index entries. For example, a partial index might omit entries for which the column being indexed is NULL. When used judiciously, partial indexes can result in smaller database files and improvements in both query and write performance.</source>
          <target state="translated">通常のインデックスでは、テーブル内の各行に対してインデックス内に正確に1つのエントリが存在します。部分インデックスでは、テーブル内の行の一部のサブセットのみが対応するインデックス項目を持ちます。たとえば、部分インデックスでは、インデックスを作成する列がNULLであるエントリを省略することができます。慎重に使用すれば、部分インデックスはデータベースファイルを小さくし、クエリと書き込みの両方のパフォーマンスを向上させることができます。</target>
        </trans-unit>
        <trans-unit id="2aff0a10aa915dae8ca55cc20203451ac3b580cc" translate="yes" xml:space="preserve">
          <source>In other words, an SQLite database can do everything that a pile-of-files or wrapped pile-of-files format can do, plus much more, and with greater lucidity. An SQLite database is a more versatile container than key/value filesystem or a ZIP archive. (For a detailed example, see the &lt;a href=&quot;affcase1&quot;&gt;OpenOffice case study&lt;/a&gt; essay.)</source>
          <target state="translated">言い換えると、SQLiteデータベースは、パイルオブファイルまたはラップされたパイルオブファイル形式で実行できるすべての操作に加えて、さらに多くのことをより明確に行うことができます。 SQLiteデータベースは、キー/値ファイルシステムやZIPアーカイブよりも用途の広いコンテナです。 （詳細な例については、&lt;a href=&quot;affcase1&quot;&gt;OpenOfficeのケーススタディ&lt;/a&gt;エッセイを参照してください。）</target>
        </trans-unit>
        <trans-unit id="a0407b322bda5c84932b9210d6c9dd55dfaff1cd" translate="yes" xml:space="preserve">
          <source>In other words, if X begins a write transaction using &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; then issues one or more &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, and/or &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statements, then those changes are visible to subsequent &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements that are evaluated in database connection X. &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements on a different database connection Y will show no changes until the X transaction commits. But &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements in X will show the changes prior to the commit.</source>
          <target state="translated">換言すれば、Xは、使用して書き込みトランザクションを開始する場合&lt;a href=&quot;lang_transaction#immediate&quot;&gt;IMMEDIATE BEGIN&lt;/a&gt;次いで課題一つ以上の&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;、&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;、および/または&lt;a href=&quot;lang_insert&quot;&gt;INSERTの&lt;/a&gt;それらの変化は、その後に表示され、文の&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;データベース接続X.で評価されるステートメント&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;別に文データベース接続Yは、Xトランザクションがコミットするまで変更を表示しません。ただし、Xの&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントには、コミット前の変更が表示されます。</target>
        </trans-unit>
        <trans-unit id="b76e19862dad40faf099a9e663056c35b57f6bbd" translate="yes" xml:space="preserve">
          <source>In other words, make the same sqlite3_test_control() call except change the last two parameters to zero.</source>
          <target state="translated">言い換えれば、最後の2つのパラメータをゼロに変更する以外は、同じsqlite3_test_control()を呼び出してください。</target>
        </trans-unit>
        <trans-unit id="a943abceb2efdd003ead8aa4530811df4446fd2f" translate="yes" xml:space="preserve">
          <source>In other words, opening and using a database file that has two or more names results in behavior that is undefined and probably undesirable.</source>
          <target state="translated">言い換えれば、2つ以上の名前を持つデータベースファイルを開いて使用すると、定義されていない、おそらく望ましくない動作をすることになります。</target>
        </trans-unit>
        <trans-unit id="5f5d40599d0989dfe7615dba1f4690adcb6d4ca6" translate="yes" xml:space="preserve">
          <source>In other words, powersafe overwrite means that there is no &quot;collateral damage&quot; when a power loss occurs while writing. Only those bytes actually being written might be damaged.</source>
          <target state="translated">言い換えれば、パワーズセーフ上書きは、書き込み中に停電が発生しても「巻き添え被害」が発生しないことを意味しています。実際に書き込まれているバイトだけがダメージを受ける可能性があります。</target>
        </trans-unit>
        <trans-unit id="ebd1e3e7febed4c7b9b73c22b3802bc322206c02" translate="yes" xml:space="preserve">
          <source>In other words, since 2004 all SQLite releases have been backwards compatible, though not necessarily forwards compatible.</source>
          <target state="translated">言い換えれば、2004年以降、すべてのSQLiteリリースは、必ずしも前方互換性があるわけではありませんが、後方互換性があります。</target>
        </trans-unit>
        <trans-unit id="1f360548804fb547b2c55aa98cf2f1549c641a34" translate="yes" xml:space="preserve">
          <source>In other words, the session extension provides a facility for SQLite database files that is similar to the unix &lt;a href=&quot;https://en.wikipedia.org/wiki/Patch_(Unix)&quot;&gt;patch&lt;/a&gt; utility program, or to the &quot;merge&quot; capabilities of version control systems such as &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt;, &lt;a href=&quot;https://git-scm.com&quot;&gt;Git&lt;/a&gt;, or &lt;a href=&quot;http://www.mercurial-scm.org/&quot;&gt;Mercurial&lt;/a&gt;.</source>
          <target state="translated">つまり、セッション拡張機能は、UNIX &lt;a href=&quot;https://en.wikipedia.org/wiki/Patch_(Unix)&quot;&gt;パッチ&lt;/a&gt;ユーティリティプログラム、または&lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt;、&lt;a href=&quot;https://git-scm.com&quot;&gt;Git&lt;/a&gt;、&lt;a href=&quot;http://www.mercurial-scm.org/&quot;&gt;Mercurial&lt;/a&gt;などのバージョン管理システムの「マージ」機能に類似したSQLiteデータベースファイルの機能を提供します。</target>
        </trans-unit>
        <trans-unit id="c9d46649fb7fd18d588f4a5f73a3e3c10dcafa53" translate="yes" xml:space="preserve">
          <source>In other words, unlinking or renaming an open database file results in behavior that is undefined and probably undesirable.</source>
          <target state="translated">言い換えれば、開いているデータベースファイルのリンクを解除したり、名前を変更したりすると、定義されていない、おそらく望ましくない動作をすることになります。</target>
        </trans-unit>
        <trans-unit id="a8fad5ad802fc08a8688a68301e637bb10e07021" translate="yes" xml:space="preserve">
          <source>In other words, you should call sqlite3_column_text(), sqlite3_column_blob(), or sqlite3_column_text16() first to force the result into the desired format, then invoke sqlite3_column_bytes() or sqlite3_column_bytes16() to find the size of the result. Do not mix calls to sqlite3_column_text() or sqlite3_column_blob() with calls to sqlite3_column_bytes16(), and do not mix calls to sqlite3_column_text16() with calls to sqlite3_column_bytes().</source>
          <target state="translated">言い換えれば、まずsqlite3_column_text()、sqlite3_column_blob()、またはsqlite3_column_text16()を呼び出して結果を希望の形式に強制し、次にsqlite3_column_bytes()またはsqlite3_column_bytes16()を呼び出して結果のサイズを求める必要があります。sqlite3_column_text()やsqlite3_column_blob()の呼び出しとsqlite3_column_bytes16()の呼び出しを混ぜてはいけません。</target>
        </trans-unit>
        <trans-unit id="456e92a6a9d74515a6d36409e4455702906122d6" translate="yes" xml:space="preserve">
          <source>In practical terms, what the powersafe write property means is that when the disk controller detects an impending power loss, it finishes writing whatever sector it is working on prior to parking the heads. It means that individual sector writes will complete once started, even if there is a power loss.</source>
          <target state="translated">実際的には、パワーセーフ書き込みプロパティが意味するのは、ディスクコントローラが差し迫った停電を検出した場合、ヘッドを駐車する前に、作業中のセクタの書き込みを終了するということです。これは、たとえ停電があったとしても、個々のセクタの書き込みが一旦開始されれば完了することを意味します。</target>
        </trans-unit>
        <trans-unit id="9fe8084319ab239e87ac8042e3d629376c48f43e" translate="yes" xml:space="preserve">
          <source>In practice, metadata is preserved between function calls for function parameters that are compile-time constants, including literal values and &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; and expressions composed from the same.</source>
          <target state="translated">実際には、メタデータは、リテラル値とそれから構成される&lt;a href=&quot;../lang_expr#varparam&quot;&gt;パラメーター&lt;/a&gt;と式を含む、コンパイル時定数である関数パラメーターの関数呼び出し間で保持されます。</target>
        </trans-unit>
        <trans-unit id="553ff79ef31136314c6f3a02cf8b8c9de3d93346" translate="yes" xml:space="preserve">
          <source>In practice, metadata is preserved between function calls for function parameters that are compile-time constants, including literal values and &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; and expressions composed from the same.</source>
          <target state="translated">実際には、メタデータは、リテラル値とそれから構成される&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメーター&lt;/a&gt;と式を含む、コンパイル時定数である関数パラメーターの関数呼び出し間で保持されます。</target>
        </trans-unit>
        <trans-unit id="235238a95713f71f096fe2094b1d8d70514424be" translate="yes" xml:space="preserve">
          <source>In precompiled SQLite libraries available on the website, the Unix versions are compiled with THREADSAFE turned off but the Windows versions are compiled with THREADSAFE turned on. If you need something different that this you will have to recompile.</source>
          <target state="translated">ウェブサイトで公開されているプリコンパイルされたSQLiteライブラリでは、Unix版はTHREADSAFEをオフにしてコンパイルされていますが、Windows版はTHREADSAFEをオンにしてコンパイルされています。これとは異なるものが必要な場合は、再コンパイルする必要があります。</target>
        </trans-unit>
        <trans-unit id="49d7b0c7067454bf2994ce5482f78c23710e1d3a" translate="yes" xml:space="preserve">
          <source>In prior discussion, it was assumed that each SQL statement is prepared once, evaluated, then destroyed. However, SQLite allows the same &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; to be evaluated multiple times. This is accomplished using the following routines:</source>
          <target state="translated">以前の説明では、各SQLステートメントは一度準備され、評価されてから破棄されると想定されていました。ただし、SQLiteでは、同じ&lt;a href=&quot;c3ref/stmt&quot;&gt;準備済みステートメント&lt;/a&gt;を複数回評価できます。これは、次のルーチンを使用して実行されます。</target>
        </trans-unit>
        <trans-unit id="86c3b83aa53c8f50b7b8f707247a7f27be6c0dc8" translate="yes" xml:space="preserve">
          <source>In processing the query above, SQLite invokes the sumint callbacks as follows:</source>
          <target state="translated">上記のクエリを処理する際に、SQLiteは以下のようにsumintコールバックを呼び出します。</target>
        </trans-unit>
        <trans-unit id="59cf5532e18c9ee34b181fd5de97a560addf74bf" translate="yes" xml:space="preserve">
          <source>In queries that are driven by a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt;, avoid unnecessary tests of the constraint named in the WHERE clause of the partial index, since we know that constraint must always be true.</source>
          <target state="translated">&lt;a href=&quot;partialindex&quot;&gt;部分インデックス&lt;/a&gt;によって駆動されるクエリでは、制約が常にtrueでなければならないことがわかっているため、部分インデックスのWHERE句で指定された制約の不要なテストを回避します。</target>
        </trans-unit>
        <trans-unit id="82246b58b2662ec98735d83b367a59b70f82fb40" translate="yes" xml:space="preserve">
          <source>In rollback mode, SQLite implements isolation by locking the database file and preventing any reads by other database connections while each write transaction is underway. Readers can be be active at the beginning of a write, before any content is flushed to disk and while all changes are still held in the writer's private memory space. But before any changes are made to the database file on disk, all readers must be (temporally) expelled in order to give the writer exclusive access to the database file. Hence, readers are prohibited from seeing incomplete transactions by virtue of being locked out of the database while the transaction is being written to disk. Only after the transaction is completely written and synced to disk and commits are the readers allowed back into the database. Hence readers never get a chance to see partially written changes.</source>
          <target state="translated">ロールバックモードでは、SQLite はデータベースファイルをロックし、各書き込みトランザクションが実行されている間、他のデータベース接続による読み込みを防止することで分離を実装しています。読み込みは書き込みの開始時にアクティブにすることができ、ディスクにコンテンツがフラッシュされる前に、すべての変更がライターのプライベートメモリ空間に保持されている間に行うことができます。しかし、ディスク上のデータベースファイルに変更が加えられる前に、ライターがデータベースファイルに排他的にアクセスできるようにするために、すべてのリーダーは(一時的に)追放されなければなりません。したがって、トランザクションがディスクに書き込まれている間は、データベースからロックアウトされているため、読者は不完全なトランザクションを見ることが禁じられている。トランザクションが完全に書き込まれ、ディスクに同期されてコミットされた後にのみ、 読者はデータベースに戻ることが許される。したがって、読者は部分的に書き込まれた変更を見る機会を得ることができません。</target>
        </trans-unit>
        <trans-unit id="068d2699f531d0825115d300a0cccce10e48a71e" translate="yes" xml:space="preserve">
          <source>In spite of the disadvantages, the developers believe that having a built-in printf() implementation inside of SQLite is a net positive.</source>
          <target state="translated">欠点があるにもかかわらず、開発者たちは、SQLite の中に組み込みの printf()の実装があることは正味のプラスになると考えています。</target>
        </trans-unit>
        <trans-unit id="cf039b1afa32ebe62123ae1292d3fdd466d22e3b" translate="yes" xml:space="preserve">
          <source>In step 2 of the procedure above, the database file is not locked before it is read from. This is the only exception to the locking rules described in section</source>
          <target state="translated">上記手順のステップ2では、データベースファイルを読み出す前にロックされません。で説明したロック規則の唯一の例外です。</target>
        </trans-unit>
        <trans-unit id="8ea8892717935eea12390eaf98af13ff334785db" translate="yes" xml:space="preserve">
          <source>In summary then, any query with aggregate functions is implemented by two loops. The first loop scans the input table and computes aggregate information into buckets and the second loop scans through all the buckets to compute the final result.</source>
          <target state="translated">要約すると、集約関数を持つクエリは2つのループによって実装されます。1つ目のループは入力テーブルをスキャンしてバケットに集約情報を計算し、2つ目のループはすべてのバケットをスキャンして最終的な結果を計算します。</target>
        </trans-unit>
        <trans-unit id="2fe8cccc0c3831ee16f379b0a96fc3ebe090262e" translate="yes" xml:space="preserve">
          <source>In summary, the claim of this essay is that using SQLite as a container for an application file format like OpenDocument and storing lots of smaller objects in that container works out much better than using a ZIP archive holding a few larger objects. To wit:</source>
          <target state="translated">要約すると、このエッセイの主張は、SQLite を OpenDocument のようなアプリケーションファイル形式のコンテナとして使用し、そのコンテナ内に多くの小さなオブジェクトを保存することは、いくつかの大きなオブジェクトを保持する ZIP アーカイブを使用するよりもはるかにうまくいくということです。ウィットによれば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="14368b74fc6cabbc46f6b11af62f68ec319ac0f1" translate="yes" xml:space="preserve">
          <source>In support of the &lt;a href=&quot;testing#mcdc&quot;&gt;100% MC/DC testing&lt;/a&gt; goal for SQLite, the parser code generated by Lemon has no unreachable branches, and contains extra (compile-time selected) instrumentation useful for measuring test coverage.</source>
          <target state="translated">SQLite の&lt;a href=&quot;testing#mcdc&quot;&gt;100％MC / DCテスト&lt;/a&gt;目標をサポートするため、Lemonによって生成されたパーサーコードには到達できないブランチがなく、テストカバレッジの測定に役立つ追加の（コンパイル時に選択された）インスツルメンテーションが含まれています。</target>
        </trans-unit>
        <trans-unit id="aad3b77ed5e3adba0d4656a1d99071301ddd4bc1" translate="yes" xml:space="preserve">
          <source>In the &quot;fossil delta&quot; format - the format used for blob deltas by the &lt;a href=&quot;http://fossil-scm.org&quot;&gt;Fossil source-code management system&lt;/a&gt;, or</source>
          <target state="translated">「fossil delta」形式&lt;a href=&quot;http://fossil-scm.org&quot;&gt;-Fossilソースコード管理システムが&lt;/a&gt; blobデルタに使用する形式、または</target>
        </trans-unit>
        <trans-unit id="30519768573ed5dd959ec460751bfce418bf4435" translate="yes" xml:space="preserve">
          <source>In the &quot;without ANALYZE&quot; case on the left, the NN algorithm chooses loop P (PLINK) as the outer loop because 4.9 is less than 5.2, resulting in path P-T which is algorithm-1. NN only looks at the single best choice at each step so it completely misses the fact that 5.2+4.4 makes a slightly cheaper plan than 4.9+4.8. But the N3 algorithm keeps track of the 5 best paths for a 2-way join, so it ends up selecting path T-P because of its slightly lower overall cost. Path T-P is algorithm-2.</source>
          <target state="translated">左の「ANALYZEなし」のケースでは、4.9が5.2よりも小さいため、NNアルゴリズムは外側のループとしてループP(PLINK)を選択し、結果としてアルゴリズム1のパスP-Tが得られます。NNは各ステップで単一の最良の選択を見るだけなので、5.2+4.4の方が4.9+4.8よりもわずかに安いプランになるという事実を完全に見逃しています。しかし、NN3アルゴリズムは2ウェイ結合のための5つのベストパスを追跡しているので、パスT-Pを選択します。パスT-Pはアルゴリズム2です。</target>
        </trans-unit>
        <trans-unit id="88edd036016e74b41ab30f363489bc8baf2ff243" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;carray&quot;&gt;CARRAY extension&lt;/a&gt;, the application needs to tell the extension the location of a C-language array that contains the data for the table-valued function that the extension implements.</source>
          <target state="translated">で&lt;a href=&quot;carray&quot;&gt;CARRAY拡張子&lt;/a&gt;、アプリケーションは拡張を拡張実装するテーブル値関数のデータを含むC言語のアレイの位置を指示する必要があります。</target>
        </trans-unit>
        <trans-unit id="0673453ee376202611f58f23515a709feb8d4034" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;, enhance the &quot;.mode&quot; command so that it restores the default column and row separators for modes &quot;line&quot;, &quot;list&quot;, &quot;column&quot;, and &quot;tcl&quot;.</source>
          <target state="translated">で&lt;a href=&quot;cli&quot;&gt;コマンドラインシェル&lt;/a&gt;、それはモード『ライン』、 『リスト』、 『列』、および『TCL』のデフォルトの列と行区切り文字を復元するように、「.mode」コマンドを高めます。</target>
        </trans-unit>
        <trans-unit id="c5b3d2f7e7ec64c2ea66a15e4b9de436ddc07a10" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; extension, the &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;MATCH operator&lt;/a&gt; (which does the full-text search) needs to communicate details of matching entries to the &lt;a href=&quot;fts3#snippet&quot;&gt;snippet()&lt;/a&gt;, &lt;a href=&quot;fts3#offsets&quot;&gt;offsets()&lt;/a&gt;, and &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; functions so that those functions can convert the details of the match into useful output.</source>
          <target state="translated">で&lt;a href=&quot;fts3&quot;&gt;FTS3の&lt;/a&gt;拡張、&lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;MATCH演算子&lt;/a&gt;（フルテキスト検索を行い）に一致するエントリの詳細を通信する必要がある&lt;a href=&quot;fts3#snippet&quot;&gt;（スニペット）&lt;/a&gt;、&lt;a href=&quot;fts3#offsets&quot;&gt;オフセット（） &lt;/a&gt;、及び&lt;a href=&quot;fts3#matchinfo&quot;&gt;（）のMatchInfo&lt;/a&gt;これらの関数は、一致の詳細を変換することができるような機能を有用な出力に。</target>
        </trans-unit>
        <trans-unit id="7f5a2150475db6cefe817c8c9175290580ea2ad7" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;json1&quot;&gt;JSON extension&lt;/a&gt;, fix the JSON validator so that it correctly rejects invalid backslash escapes within strings.</source>
          <target state="translated">では&lt;a href=&quot;json1&quot;&gt;JSON拡張&lt;/a&gt;、それが正しく、文字列内の無効なバックスラッシュエスケープを拒否するようにJSONバリデータを修正します。</target>
        </trans-unit>
        <trans-unit id="29cf2e016ded4e45037d7dd8bd42e21681c156af" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;rbu&quot;&gt;RBU extension&lt;/a&gt;, add extra sync operations to avoid the possibility of corruption following a power failure.</source>
          <target state="translated">で&lt;a href=&quot;rbu&quot;&gt;RBU拡張&lt;/a&gt;、停電、以下の破損の可能性を回避するために、余分な同期操作を追加します。</target>
        </trans-unit>
        <trans-unit id="11f2b4a17490be52b1b76c1ff6aa70a95cb65d46" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; extension, when rounding 64-bit floating point numbers to 32-bit for storage, always round in a direction that causes the bounding box to get larger.</source>
          <target state="translated">で&lt;a href=&quot;rtree&quot;&gt;RTREEの&lt;/a&gt;バウンディングボックスが大きく取得させる方向に常にラウンド、貯蔵のために32ビットを64ビットの浮動小数点数を丸める拡張、。</target>
        </trans-unit>
        <trans-unit id="240fef4158af161eb22e60a820c151dc84eafe1e" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt;, add the -uri option to the &quot;sqlite3&quot; TCL command used for creating new database connection objects.</source>
          <target state="translated">では&lt;a href=&quot;tclsqlite&quot;&gt;TCLインタフェース&lt;/a&gt;、新しいデータベース接続オブジェクトを作成するために使用される「sqlite3の」TCLコマンドに-uriオプションを追加します。</target>
        </trans-unit>
        <trans-unit id="156e69c7f61ba1dcce1a1142af151766e801c151" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;tclsqlite&quot;&gt;TCL language interface&lt;/a&gt;, &quot;@variable&quot; instead of &quot;$variable&quot; always binds as a blob.</source>
          <target state="translated">では&lt;a href=&quot;tclsqlite&quot;&gt;TCL言語インタフェース&lt;/a&gt;の代わりに「$変数」の、「@Variable」ブロブいつものように結合します。</target>
        </trans-unit>
        <trans-unit id="7ed9b7e87f45e28428e0b4c11b7a622203b8e9d6" translate="yes" xml:space="preserve">
          <source>In the BLOB output, you can clearly see the NUL character as the 4th character in the 7-character string.</source>
          <target state="translated">BLOB出力では、7文字の文字列の4番目にNUL文字があるのがはっきりとわかります。</target>
        </trans-unit>
        <trans-unit id="d3bfa67674bb524ce3387e6563f15051a77fe593" translate="yes" xml:space="preserve">
          <source>In the C programming language where &lt;b&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/b&gt; and &lt;b&gt;&lt;code&gt;||&lt;/code&gt;&lt;/b&gt; are &quot;short-circuit&quot; operators, MC/DC and branch coverage are very nearly the same thing. The primary difference is in boolean vector tests. One can test for any of several bits in bit-vector and still obtain 100% branch test coverage even though the second element of MC/DC - the requirement that each condition in a decision take on every possible outcome - might not be satisfied.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; &lt;/b&gt;および&lt;b&gt; &lt;code&gt;||&lt;/code&gt; の&lt;/b&gt; Cプログラミング言語「短絡」演算子であるMC / DCとブランチカバレッジはほとんど同じものです。主な違いは、ブールベクトルテストです。 MC / DCの2番目の要素-意思決定の各条件がすべての可能な結果を​​とるという要件-が満たされない場合でも、ビットベクトルのいくつかのビットのいずれかをテストし、100％分岐テストカバレッジを取得できます。</target>
        </trans-unit>
        <trans-unit id="a49a291dae627f989ba703462ee2c7e1bcc8b060" translate="yes" xml:space="preserve">
          <source>In the C programming language, it is very easy to write code that has &quot;undefined&quot; or &quot;implementation defined&quot; behavior. That means that the code might work during development, but then give a different answer on a different system, or when recompiled using different compiler options. Examples of undefined and implementation-defined behavior in ANSI C include:</source>
          <target state="translated">C言語のプログラミング言語では、「未定義」または「実装で定義された」動作を持つコードを書くことは非常に簡単です。これは、開発中には動作していても、別のシステムでは動作したり、別のコンパイラオプションを使用して再コンパイルした場合には別の答えが返ってくる可能性があることを意味します。ANSI C での未定義および実装定義の動作の例としては、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="c817a7331349197e219cdd351370db507b5f89c0" translate="yes" xml:space="preserve">
          <source>In the COPY command, backslash can now be used to escape a newline.</source>
          <target state="translated">COPYコマンドで、バックスラッシュを使用して改行をエスケープできるようになりました。</target>
        </trans-unit>
        <trans-unit id="cb9f3cc234a2699a8be8b939bc81e4cd1e3c8028" translate="yes" xml:space="preserve">
          <source>In the Fossil full-text search system, documents that participate in the full-text search (wiki pages, tickets, check-ins, documentation files, etc) are tracked by a table called &quot;ftsdocs&quot; (&lt;u&gt;f&lt;/u&gt;ull &lt;u&gt;t&lt;/u&gt;ext &lt;u&gt;s&lt;/u&gt;earch &lt;u&gt;doc&lt;/u&gt;ument&lt;u&gt;s&lt;/u&gt;). As new documents are added to the repository, they are not indexed right away. Indexing is deferred until there is a search request. The ftsdocs table contains an &quot;idxed&quot; field which is true if the document has been indexed and false if not.</source>
          <target state="translated">化石全文検索システム、フルテキスト検索に参加したドキュメント（Wikiページ、チケット、チェックイン、ドキュメントファイルなど）で（「ftsdocs」と呼ばれるテーブルによって追跡されている&lt;u&gt;F&lt;/u&gt; ULL &lt;u&gt;トン&lt;/u&gt;内線&lt;u&gt;の&lt;/u&gt; earchが&lt;u&gt;ドキュメント&lt;/u&gt;&lt;u&gt;sを&lt;/u&gt;増加します）。新しいドキュメントがリポジトリに追加されると、すぐにインデックスが作成されません。インデックス作成は、検索リクエストがあるまで延期されます。ftsdocsテーブルには、「idxed」フィールドが含まれています。このフィールドは、ドキュメントがインデックス付けされている場合はtrue、インデックス付けされていない場合はfalseです。</target>
        </trans-unit>
        <trans-unit id="54570b346f4d608f2bbac12e4181cf27370c513d" translate="yes" xml:space="preserve">
          <source>In the SQL statement text input to &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and its variants, literals may be replaced by a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that matches one of following templates:</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;とそのバリアントへのSQLステートメントテキスト入力では、リテラルは次のテンプレートのいずれかに一致する&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメーターに&lt;/a&gt;置き換えられます。</target>
        </trans-unit>
        <trans-unit id="2d198fd96a87b68a84840a27e15d7192fd58115f" translate="yes" xml:space="preserve">
          <source>In the SQL statement text input to &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and its variants, literals may be replaced by a &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that matches one of following templates:</source>
          <target state="translated">&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt;とそのバリアントへのSQLステートメントテキスト入力では、リテラルは次のテンプレートのいずれかに一致する&lt;a href=&quot;../lang_expr#varparam&quot;&gt;パラメーターに&lt;/a&gt;置き換えられます。</target>
        </trans-unit>
        <trans-unit id="0bfef1786d8548ec0f82e3f4f67466b9d9c84839" translate="yes" xml:space="preserve">
          <source>In the TCL test harness, the crash simulation is done in a separate process. The main testing process spawns a child process which runs some SQLite operation and randomly crashes somewhere in the middle of a write operation. A special &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; randomly reorders and corrupts the unsynchronized write operations to simulate the effect of buffered filesystems. After the child dies, the original test process opens and reads the test database and verifies that the changes attempted by the child either completed successfully or else were completely rolled back. The &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check&lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; is used to make sure no database corruption occurs.</source>
          <target state="translated">TCLテストハーネスでは、クラッシュシミュレーションは別のプロセスで行われます。メインのテストプロセスは、SQLite操作を実行する子プロセスを生成し、書き込み操作の途中でランダムにクラッシュします。特別な&lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;は、非同期の書き込み操作をランダムに並べ替えて破壊し、バッファリングされたファイルシステムの効果をシミュレートします。子が死亡した後、元のテストプロセスが開いてテストデータベースを読み取り、子が試みた変更が正常に完了したか、完全にロールバックされたかを確認します。&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check &lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;プラグマは&lt;/a&gt;必ず何のデータベースの破損が発生しないために使用されます。</target>
        </trans-unit>
        <trans-unit id="2e83d8a255a88980125401cd881c484a48bd6dc6" translate="yes" xml:space="preserve">
          <source>In the TPC-H Q8 query, the setup costs are all negligible, all dependencies are between individual nodes, and there is no ORDER BY, GROUP BY, or DISTINCT clause. So for TPC-H Q8, the graph above is a reasonable representation of what needs to be computed. The general case involves a lot of extra complication, which for clarity is neglected in the remainder of this article.</source>
          <target state="translated">TPC-H Q8 クエリでは、セットアップ・コストはすべて無視できる程度であり、依存関係はすべて個々のノード間であり、ORDER BY、GROUP BY、DISTINCT句はありません。したがって、TPC-H Q8の場合、上のグラフは、計算する必要があることを合理的に表現しています。一般的なケースでは、多くの余分な複雑さを伴いますが、この記事の残りの部分では明確にするために無視しています。</target>
        </trans-unit>
        <trans-unit id="9f3539e13c22fa6c6ec2b58a1ccd7e90a2d77370" translate="yes" xml:space="preserve">
          <source>In the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;partialindex&quot;&gt;部分インデックスの&lt;/a&gt; WHERE句内。</target>
        </trans-unit>
        <trans-unit id="2ff78c844bf874e8944245ab0f90e378a482a538" translate="yes" xml:space="preserve">
          <source>In the WHERE clause of a partial index.</source>
          <target state="translated">部分インデックスのWHERE句で。</target>
        </trans-unit>
        <trans-unit id="b6311a2e6a2d0640df13bf33c58d5ba4044c66ce" translate="yes" xml:space="preserve">
          <source>In the Windows OS driver, reacquire a SHARED lock if an attempt to acquire an EXCLUSIVE lock fails. Ticket #2354</source>
          <target state="translated">Windows OSドライバで、EXCLUSIVEロックの取得に失敗した場合にSHAREDロックを再取得するという問題がありました。チケット番号2354</target>
        </trans-unit>
        <trans-unit id="c812acc1f415592dcfc5eeb302d23caa6a39526f" translate="yes" xml:space="preserve">
          <source>In the above paragraph, the term &quot;equal&quot; means equal when values are compared using the rules &lt;a href=&quot;datatype3#comparisons&quot;&gt;specified here&lt;/a&gt;. The following clarifications apply:</source>
          <target state="translated">上記の段落で、「等しい」という用語は、&lt;a href=&quot;datatype3#comparisons&quot;&gt;ここで指定され&lt;/a&gt;たルールを使用して値を比較するときに等しいことを意味します。次の説明が適用されます。</target>
        </trans-unit>
        <trans-unit id="94f9ba60d2631df2a644921fed4cce7a6456d2d7" translate="yes" xml:space="preserve">
          <source>In the above,</source>
          <target state="translated">上記の中で</target>
        </trans-unit>
        <trans-unit id="441e596237bc1ae031cea29bc5e12b44c88ed81c" translate="yes" xml:space="preserve">
          <source>In the above, &amp;lt;content&amp;gt; is replaced by the name of the content table. By default, &amp;lt;content_rowid&amp;gt; is replaced by the literal text &quot;rowid&quot;. Or, if the &quot;content_rowid&quot; option is set within the CREATE VIRTUAL TABLE statement, by the value of that option. &amp;lt;cols&amp;gt; is replaced by a comma-separated list of the FTS5 table column names. For example:</source>
          <target state="translated">上記では、&amp;lt;content&amp;gt;はコンテンツテーブルの名前に置き換えられます。デフォルトでは、&amp;lt;content_rowid&amp;gt;はリテラルテキスト「rowid」に置き換えられます。または、「content_rowid」オプションがCREATE VIRTUAL TABLEステートメント内でそのオプションの値によって設定されている場合。&amp;lt;cols&amp;gt;は、FTS5テーブルの列名のコンマ区切りのリストに置き換えられます。例えば：</target>
        </trans-unit>
        <trans-unit id="a2464dd3bf1c506de33685f476dfeec6d3c9f83a" translate="yes" xml:space="preserve">
          <source>In the above, the user creates the database schema (a single table - &quot;x1&quot;), and then uses the &quot;.expert&quot; command to analyze a query, in this case &quot;SELECT * FROM x1 WHERE a=? AND b&amp;gt;?&quot;. The shell tool recommends that the user create a new index (index &quot;x1_idx_000123a7&quot;) and outputs the plan that the query would use in &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; format. The user then creates an index with an equivalent schema and runs the analysis on the same query again. This time the shell tool does not recommend any new indexes, and outputs the plan that SQLite will use for the query given the existing indexes.</source>
          <target state="translated">上記では、ユーザーはデータベーススキーマ（単一のテーブル-&quot;x1&quot;）を作成し、次に &quot;.expert&quot;コマンドを使用してクエリを分析します。この場合、 &quot;SELECT * FROM x1 WHERE a =？AND b&amp;gt;？ 」シェルツールは、ユーザーが新しいインデックス（インデックス &quot;x1_idx_000123a7&quot;）を作成し、クエリが&lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;形式で使用するプランを出力することを推奨します。次に、ユーザーは同等のスキーマを使用してインデックスを作成し、同じクエリで分析を再度実行します。今回、シェルツールは新しいインデックスを推奨せず、SQLiteが既存のインデックスを指定したクエリに使用する計画を出力します。</target>
        </trans-unit>
        <trans-unit id="c0edb5d51a3281366e0040cd06804f7b08ee3eaa" translate="yes" xml:space="preserve">
          <source>In the argments to &quot;rtree&quot; in the CREATE VIRTUAL TABLE statement, the names of the columns are taken from the first token of each argument. All subsequent tokens within each argument are silently ignored. This means, for example, that if you try to give a column a &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; or add a constraint such as UNIQUE or NOT NULL or DEFAULT to a column, those extra tokens are accepted as valid, but they do not change the behavior of the rtree. In an RTREE virtual table, the first column always has a &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; of INTEGER and all other data columns have a &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; of NUMERIC.</source>
          <target state="translated">In the argments to &quot;rtree&quot; in the CREATE VIRTUAL TABLE statement, the names of the columns are taken from the first token of each argument. All subsequent tokens within each argument are silently ignored. This means, for example, that if you try to give a column a &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; or add a constraint such as UNIQUE or NOT NULL or DEFAULT to a column, those extra tokens are accepted as valid, but they do not change the behavior of the rtree. In an RTREE virtual table, the first column always has a &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; of INTEGER and all other data columns have a &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; of NUMERIC.</target>
        </trans-unit>
        <trans-unit id="94df2ec8cdab4e4a1c3463eb8499a5bac9b92ebf" translate="yes" xml:space="preserve">
          <source>In the call above, pBuf is a pointer to a large, contiguous chunk of memory space that SQLite will use to satisfy all of its memory allocation needs. pBuf might point to a static array or it might be memory obtained from some other application-specific mechanism. szBuf is an integer that is the number of bytes of memory space pointed to by pBuf. mnReq is another integer that is the minimum size of an allocation. Any call to &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc(N)&lt;/a&gt; where N is less than mnReq will be rounded up to mnReq. mnReq must be a power of two. We shall see later that the mnReq parameter is important in reducing the value of &lt;b&gt;n&lt;/b&gt; and hence the minimum memory size requirement in the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt;.</source>
          <target state="translated">上記の呼び出しで、pBufは、SQLiteがメモリ割り当てのニーズをすべて満たすために使用する、大きく連続したメモリ領域のチャンクへのポインタです。 pBufは静的配列を指す場合もあれば、他のアプリケーション固有のメカニズムから取得したメモリである場合もあります。 szBufは、pBufが指すメモリ空間のバイト数である整数です。 mnReqは、割り当ての最小サイズである別の整数です。&lt;a href=&quot;c3ref/free&quot;&gt;N&lt;/a&gt;がmnReqより小さいsqlite3_malloc（N）への呼び出しは、mnReqに切り上げられます。 mnReqは2の累乗でなければなりません。後でmnReqパラメータが&lt;b&gt;n&lt;/b&gt;の値を減らすのに重要であり、したがって&lt;a href=&quot;malloc#nofrag&quot;&gt;ロブソン証明の&lt;/a&gt;最小メモリサイズ要件が重要であることがわかります。</target>
        </trans-unit>
        <trans-unit id="90165ee71034491a4c0d9359bc73082f9488de28" translate="yes" xml:space="preserve">
          <source>In the call above, pMem is a pointer to an &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; object that defines the interface to the application-specific memory allocator. The &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; object is really just a structure containing pointers to functions to implement the various memory allocation primitives.</source>
          <target state="translated">上記の呼び出しで、pMemは、アプリケーション固有の&lt;a href=&quot;c3ref/mem_methods&quot;&gt;メモリア&lt;/a&gt;ロケーターへのインターフェイスを定義するsqlite3_mem_methodsオブジェクトへのポインターです。&lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methodsの&lt;/a&gt;オブジェクトは、実際に様々なメモリ割り当てプリミティブを実装する関数へのポインタを含むだけの構造です。</target>
        </trans-unit>
        <trans-unit id="c159dc37c192a0696adfe0ed4e91dc6c74c10ae1" translate="yes" xml:space="preserve">
          <source>In the call sqlite3_vtab_config(D,C,...) the D parameter is the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; in which the virtual table is being created and which is passed in as the first argument to the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method that is invoking sqlite3_vtab_config(). The C parameter is one of the &lt;a href=&quot;#SQLITE_VTAB_CONSTRAINT_SUPPORT&quot;&gt;virtual table configuration options&lt;/a&gt;. The presence and meaning of parameters after C depend on which &lt;a href=&quot;#SQLITE_VTAB_CONSTRAINT_SUPPORT&quot;&gt;virtual table configuration option&lt;/a&gt; is used.</source>
          <target state="translated">In the call sqlite3_vtab_config(D,C,...) the D parameter is the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; in which the virtual table is being created and which is passed in as the first argument to the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method that is invoking sqlite3_vtab_config(). The C parameter is one of the &lt;a href=&quot;#SQLITE_VTAB_CONSTRAINT_SUPPORT&quot;&gt;virtual table configuration options&lt;/a&gt;. The presence and meaning of parameters after C depend on which &lt;a href=&quot;#SQLITE_VTAB_CONSTRAINT_SUPPORT&quot;&gt;virtual table configuration option&lt;/a&gt; is used.</target>
        </trans-unit>
        <trans-unit id="b10e05d68bb770ad4b44c8424ff81a8fc9e69978" translate="yes" xml:space="preserve">
          <source>In the call sqlite3_vtab_config(D,C,...) the D parameter is the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; in which the virtual table is being created and which is passed in as the first argument to the &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method that is invoking sqlite3_vtab_config(). The C parameter is one of the &lt;a href=&quot;c_vtab_constraint_support&quot;&gt;virtual table configuration options&lt;/a&gt;. The presence and meaning of parameters after C depend on which &lt;a href=&quot;c_vtab_constraint_support&quot;&gt;virtual table configuration option&lt;/a&gt; is used.</source>
          <target state="translated">In the call sqlite3_vtab_config(D,C,...) the D parameter is the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; in which the virtual table is being created and which is passed in as the first argument to the &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method that is invoking sqlite3_vtab_config(). The C parameter is one of the &lt;a href=&quot;c_vtab_constraint_support&quot;&gt;virtual table configuration options&lt;/a&gt;. The presence and meaning of parameters after C depend on which &lt;a href=&quot;c_vtab_constraint_support&quot;&gt;virtual table configuration option&lt;/a&gt; is used.</target>
        </trans-unit>
        <trans-unit id="890332a4e5fd5b1fbcf7ece72dd3f24eeb42de4e" translate="yes" xml:space="preserve">
          <source>In the case of &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;, whenever the word &quot;column&quot; is used in the foregoing text, one can substitute &quot;indexed expression&quot; (meaning a copy of the expression that appears in the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement) and everything will work the same.</source>
          <target state="translated">&lt;a href=&quot;expridx&quot;&gt;式&lt;/a&gt;のインデックスの場合、前述のテキストで「列」という単語が使用されているときはいつでも、「インデックス付き式」（&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;ステートメントに表示される式のコピーを意味する）に置き換えることができ、すべてが同じように機能します。</target>
        </trans-unit>
        <trans-unit id="d6023ff2ef6625bf825c5177040f5f9d0c7e6eaa" translate="yes" xml:space="preserve">
          <source>In the case of sqlite3changeset_start_strm(), the xInput callback may be invoked by the sessions module at any point during the lifetime of the iterator. If such an xInput callback returns an error, the iterator enters an error state, whereby all subsequent calls to iterator functions immediately fail with the same error code as returned by xInput.</source>
          <target state="translated">sqlite3changeset_start_strm()の場合、xInputコールバックはイテレータが生きている間、いつでもセッション・モジュールによって呼び出されます。このようなxInputコールバックがエラーを返すと、イテレータはエラー状態になり、それ以降のイテレータ関数の呼び出しはすべてxInputが返したのと同じエラーコードで直ちに失敗します。</target>
        </trans-unit>
        <trans-unit id="2c842ccec3d83bffac0868a71bae98e55882c42d" translate="yes" xml:space="preserve">
          <source>In the cases above, the values returned by the function affects the information stored in the database file. The values of functions in CHECK constraints determines which entries are valid for a table, and functions in the WHERE clause of a partial index or in an index on an expression compute values stored in the index b-tree. If any of these functions later returns a different value, then the database might no longer be well-formed. Hence, to avoid database corruption, only deterministic functions can be used in the contexts above.</source>
          <target state="translated">上記のケースでは、関数によって返される値は、データベース・ファイルに格納された情報に影響を与えます。CHECK制約内の関数の値は、テーブルに対して有効なエントリを決定し、部分インデックスのWHERE句または式のインデックス内の関数は、インデックスb-treeに格納された値を計算します。これらの関数のいずれかが後で異なる値を返した場合、データベースはもはや十分に形成されていないかもしれません。したがって、データベースの破損を避けるために、上記の文脈では決定論的な関数のみを使用することができます。</target>
        </trans-unit>
        <trans-unit id="212f1ca207fd318cb7601421ea08bad1d38b37aa" translate="yes" xml:space="preserve">
          <source>In the command-line shell, use popen() instead of fopen() if the first character of the argument to the &quot;.output&quot; command is &quot;|&quot;.</source>
          <target state="translated">コマンドラインシェルでは、&quot;.output &quot;コマンドの引数の最初の文字が&quot;|&quot;の場合、fopen()の代わりにpopen()を使用します。</target>
        </trans-unit>
        <trans-unit id="bd2d277ff0771ee506fb5065fe7a06ad8e377ea0" translate="yes" xml:space="preserve">
          <source>In the current implementation of SQLite, the SQL parser only works with UTF-8 text. So if you supply UTF-16 text it will be converted. This is just an implementation issue and there is nothing to prevent future versions of SQLite from parsing UTF-16 encoded SQL natively.</source>
          <target state="translated">現在のSQLiteの実装では、SQLパーサはUTF-8テキストでしか動作しません。そのため、UTF-16テキストを指定した場合は変換されます。これは単なる実装上の問題であり、将来のバージョンの SQLite が UTF-16 エンコードされた SQL をネイティブで解析することを妨げるものは何もありません。</target>
        </trans-unit>
        <trans-unit id="2904f602a19479b220a87ade171425cb57484f61" translate="yes" xml:space="preserve">
          <source>In the current implementation, a table is analyzed if and only if all of the following are true:</source>
          <target state="translated">現在の実装では、以下のすべてが真である場合にのみ、テーブルが解析されます。</target>
        </trans-unit>
        <trans-unit id="f2454c76bf66b1405ea30b83fd1ca60a2a98f0ef" translate="yes" xml:space="preserve">
          <source>In the current implementation, the update hook is not invoked when conflicting rows are deleted because of an &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT REPLACE&lt;/a&gt; clause. Nor is the update hook invoked when rows are deleted using the &lt;a href=&quot;../lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt;. The exceptions defined in this paragraph might change in a future release of SQLite.</source>
          <target state="translated">現在の実装では、&lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT REPLACE&lt;/a&gt;句が原因で競合する行が削除されても、更新フックは呼び出されません。また、&lt;a href=&quot;../lang_delete#truncateopt&quot;&gt;トランケート最適化&lt;/a&gt;を使用して行が削除されたときに、更新フックも呼び出されません。この段落で定義されている例外は、SQLiteの将来のリリースで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="fb481751cd63e35f2d57a7f24a37356fd4bf25b0" translate="yes" xml:space="preserve">
          <source>In the current implementation, the update hook is not invoked when conflicting rows are deleted because of an &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT REPLACE&lt;/a&gt; clause. Nor is the update hook invoked when rows are deleted using the &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt;. The exceptions defined in this paragraph might change in a future release of SQLite.</source>
          <target state="translated">現在の実装では、&lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT REPLACE&lt;/a&gt;句が原因で競合する行が削除されても、更新フックは呼び出されません。また、&lt;a href=&quot;lang_delete#truncateopt&quot;&gt;トランケート最適化&lt;/a&gt;を使用して行が削除されたときに、更新フックも呼び出されません。この段落で定義されている例外は、SQLiteの将来のリリースで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="6c3c5dcd56d182703694f79901fe613441a9864b" translate="yes" xml:space="preserve">
          <source>In the current row, the number of times the phrase appears in the column.</source>
          <target state="translated">現在の列では、そのフレーズの出現回数が表示されています。</target>
        </trans-unit>
        <trans-unit id="cee9466acdd5b62aa76761a9bf112fbd7910b30a" translate="yes" xml:space="preserve">
          <source>In the definitions of generated columns.</source>
          <target state="translated">生成されたカラムの定義で</target>
        </trans-unit>
        <trans-unit id="d3116d32ea608324199d5e0469ef8b030b799865" translate="yes" xml:space="preserve">
          <source>In the diagram at the right, we show that the information that was held in user space is cleared when the lock is released. This used to be literally true for older versions of SQLite. But more recent versions of SQLite keep the user space information in memory in case it might be needed again at the start of the next transaction. It is cheaper to reuse information that is already in local memory than to transfer the information back from the operating system disk cache or to read it off of the disk drive again. Prior to reusing the information in user space, we must first reacquire the shared lock and then we have to check to make sure that no other process modified the database file while we were not holding a lock. There is a counter in the first page of the database that is incremented every time the database file is modified. We can find out if another process has modified the database by checking that counter. If the database was modified, then the user space cache must be cleared and reread. But it is commonly the case that no changes have been made and the user space cache can be reused for a significant performance savings.</source>
          <target state="translated">右の図では、ロックが解除されると、ユーザ空間に保持されていた情報がクリアされることを示しています。これは古いバージョンのSQLiteでは文字通り真実でした。しかし、最近のバージョンのSQLiteでは、次のトランザクションの開始時に再び必要になるかもしれない場合に備えて、ユーザ空間の情報をメモリに保持しています。オペレーティングシステムのディスクキャッシュから情報を転送したり、ディスクドライブから情報を読み出すよりも、ローカルメモリにある情報を再利用する方が安く済みます。ユーザースペースにある情報を再利用する前に、まず共有ロックを再取得し、ロックを保持していない間に他のプロセスがデータベースファイルを変更していないことを確認しなければなりません。データベースの最初のページには、データベースファイルが変更されるたびにインクリメントされるカウンタがあります。このカウンタをチェックすることで、他のプロセスがデータベースを変更したかどうかを知ることができます。データベースが変更された場合は、ユーザースペースキャッシュをクリアして再読込しなければなりません。しかし、一般的には何も変更されていないことが多く、ユーザースペースキャッシュを再利用することで大幅なパフォーマンスの低下を防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="bc4afe67e993812e607ae27c7ab087c30151c22e" translate="yes" xml:space="preserve">
          <source>In the diagram, each of the 8 tables in the FROM clause of the query is identified by a large circle with the label of the FROM-clause term: N2, S, L, P, O, C, N1 and R. The arcs in the graph represent the estimated cost of computing each term assuming that the origin of the arc is in an outer loop. For example, the cost of running the S loop as an inner loop to L is 2.30 whereas the cost of running the S loop as an outer loop to L is 9.17.</source>
          <target state="translated">この図では、問い合わせのFROM句の8つのテーブルのそれぞれは、FROM句の項のラベルが付いた大きな円で識別されています。グラフ内の円弧は、円弧の原点が外側のループにあると仮定した場合の各項の計算コストの推定値を表しています。例えば、SループをLへの内ループとして実行するコストは2.30であるのに対し、SループをLへの外ループとして実行するコストは9.17である。</target>
        </trans-unit>
        <trans-unit id="395caf8810d6babac050840aec487ecca9bbc4bd" translate="yes" xml:space="preserve">
          <source>In the event of an operating system or power failure, the various combinations of file-system software and storage hardware available provide varying levels of guarantee as to the integrity of the data written to the file system just before or during the failure. The exact combination of IO operations that SQLite is required to perform in order to safely modify a database file depend on the exact characteristics of the target platform.</source>
          <target state="translated">オペレーティングシステムや電源障害が発生した場合、利用可能なファイルシステムソフトウェアとストレージハードウェアの様々な組み合わせにより、障害発生直前や障害発生中にファイルシステムに書き込まれたデータの整合性を様々なレベルで保証することができます。データベースファイルを安全に修正するために SQLite が実行する必要のある IO 操作の正確な組み合わせは、ターゲットプラットフォームの正確な特性に依存します。</target>
        </trans-unit>
        <trans-unit id="fbf76308006177e994e0ad525f9e6c338bce580b" translate="yes" xml:space="preserve">
          <source>In the example above, all the rows for each partition are grouped together in the final output. This is because the PARTITION BY clause is a prefix of the ORDER BY clause on the overall query. But that does not have to be the case. A partition can be composed of rows scattered about haphazardly within the result set. For example:</source>
          <target state="translated">上の例では、各パーティションのすべての行が最終的な出力でグループ化されています。これは、PARTITION BY句がクエリ全体のORDER BY句の接頭辞になっているからです。しかし、そうである必要はありません。パーティションは、結果セット内に散らばった行で構成することができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="5cf1e8a43e9d63b712df3d7090fc5c9414ccb7c0" translate="yes" xml:space="preserve">
          <source>In the example above, each triple identifies the location of a token instance by rowid, column number (columns are numbered sequentially starting at 0 from left to right) and position within the column value (the first token in a column value is 0, the second is 1, and so on). Using this index, FTS5 is able to provide timely answers to queries such as &quot;the set of all documents that contain the token 'A'&quot;, or &quot;the set of all documents that contain the sequence 'Y Z'&quot;. The list of instances associated with a single token is called an &quot;instance-list&quot;.</source>
          <target state="translated">上の例では、各トリプルは、rowid、カラム番号(カラムは左から順に0から順に番号が振られている)、カラム値内の位置(カラム値内の最初のトークンは0、2番目のトークンは1、など)によって、トークンインスタンスの位置を特定している。このインデックスを使用することで、FTS5は、「トークン'A'を含むすべての文書の集合」や「シーケンス'Y Z'を含むすべての文書の集合」のようなクエリに対するタイムリーな回答を提供することができる。単一のトークンに関連付けられたインスタンスのリストは、「インスタンスリスト」と呼ばれる。</target>
        </trans-unit>
        <trans-unit id="6670429b3f62749505c4b98851abdba99076dc7b" translate="yes" xml:space="preserve">
          <source>In the example above, if most purchase orders do not have a &quot;parent&quot; purchase order, then most parent_po values will be NULL. That means only a small subset of the rows in the purchaseorder table will be indexed. Hence the index will take up much less space. And changes to the original purchaseorder table will run faster since the po_parent index only needs to be updated for those exceptional rows where parent_po is not NULL. But the index is still useful for querying. In particular, if one wants to know all &quot;children&quot; of a particular purchase order &quot;?1&quot;, the query would be:</source>
          <target state="translated">上記の例では、ほとんどの購入注文に「親」の購入注文がない場合、ほとんどの parent_po 値は NULL になります。これは、購入注文テーブルの行のごく一部がインデックス化されることを意味します。そのため、インデックスが占めるスペースはかなり少なくなります。po_parentインデックスは、parent_poがNULLではない例外的な行のために更新する必要があるだけなので、元の購入オーダーテーブルへの変更はより速く実行されます。しかし、インデックスはクエリを実行するのに便利です。特に、特定の購入注文「?1」のすべての「子」を知りたい場合、クエリは次のようになります。</target>
        </trans-unit>
        <trans-unit id="093d39a0dc19bc985afaed609f6ca65b1771f970" translate="yes" xml:space="preserve">
          <source>In the example above, the &quot;.header on&quot; line causes column labels to be printed as the first row of output. This means that the first row of the resulting CSV file will contain column labels. If column labels are not desired, set &quot;.header off&quot; instead. (The &quot;.header off&quot; setting is the default and can be omitted if the headers have not been previously turned on.)</source>
          <target state="translated">上の例では、「.header on」行は、出力の最初の行としてカラムラベルを出力します。これは、結果として出力されるCSVファイルの最初の行にカラムラベルが表示されることを意味します。列ラベルが不要な場合は、「.header off」を設定してください。(「.header off」の設定はデフォルトであり、ヘッダーが以前にオンになっていない場合は省略することができます)。</target>
        </trans-unit>
        <trans-unit id="19c364b4c4bd5bb78a54b1baeb3476ed5a370176" translate="yes" xml:space="preserve">
          <source>In the example above, the &quot;.headers on&quot; line causes column labels to be printed as the first row of output. This means that the first row of the resulting CSV file will contain column labels. If column labels are not desired, set &quot;.headers off&quot; instead. (The &quot;.headers off&quot; setting is the default and can be omitted if the headers have not been previously turned on.)</source>
          <target state="translated">上の例では、「.headers on」行は、出力の最初の行としてカラムラベルを印刷します。これは、結果として出力されるCSVファイルの最初の行にカラムラベルが含まれることを意味します。列ラベルが不要な場合は、「.headers off」を設定してください。(「.headers off」の設定はデフォルトであり、ヘッダーが以前にオンになっていない場合は省略することができます)。</target>
        </trans-unit>
        <trans-unit id="10cd93c52fe5f9cca786dee67c9404fab91f9de8" translate="yes" xml:space="preserve">
          <source>In the example above, the window frame consists of all rows between the previous row (&quot;1 PRECEDING&quot;) and the following row (&quot;1 FOLLOWING&quot;), inclusive, where rows are sorted according to the ORDER BY clause in the window-defn (in this case &quot;ORDER BY a&quot;). For example, the frame for the row with (a=3) consists of rows (2, 'B', 'two'), (3, 'C', 'three') and (4, 'D', 'one'). The result of group_concat(b, '.') for that row is therefore 'B.C.D'.</source>
          <target state="translated">上の例では、ウィンドウフレームは、前の行(&quot;1 PRECEDING&quot;)と次の行(&quot;1 FOLLOWING&quot;)の間のすべての行で構成されており、その中の行は、ウィンドウ-defnのORDER BY句(この場合は &quot;ORDER BY a&quot;)に従ってソートされます。例えば、(a=3)の行のフレームは、(2,'B','2')、(3,'C','3')、(4,'D','1')の行で構成されています。したがって、その行に対するgroup_concat(b,'.')の結果は、'B.C.D'となります。</target>
        </trans-unit>
        <trans-unit id="b3d6a23d97e4594c0776e73b100f4f0f95f7c245" translate="yes" xml:space="preserve">
          <source>In the example queries above, every row of the table being queried must be loaded off of the disk and examined, even if only a small percentage of the rows end up in the result. This can take a long time on a big table. To speed things up, SQLite can use an index.</source>
          <target state="translated">上記の例のクエリでは、たとえ結果がごく一部の行であっても、クエリされたテーブルのすべての行がディスクからロードされ、検査されなければなりません。これは、大きなテーブルでは長い時間がかかります。これを高速化するために、SQLite ではインデックスを使用することができます。</target>
        </trans-unit>
        <trans-unit id="097fb65fd13aa3cb8c9440796ac79504d1b2d367" translate="yes" xml:space="preserve">
          <source>In the example, instead of a single sort of 7 elements, there are 5 sorts of one-element each and 1 sort of 2 elements for the case of fruit=='Orange'.</source>
          <target state="translated">この例では、果物=='Orange'の場合は、7要素の1ソートではなく、1要素ずつ5ソート、2要素1ソートとなっています。</target>
        </trans-unit>
        <trans-unit id="28b65ff31e772aaf95fd7eecfcefa7c33d5a2c49" translate="yes" xml:space="preserve">
          <source>In the example, the values in the &quot;term&quot; column are all lower case, even though they were inserted into table &quot;ft&quot; in mixed case. This is because an fts4aux table contains the terms as extracted from the document text by the &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt;. In this case, since table &quot;ft&quot; uses the &lt;a href=&quot;fts3#tokenizer&quot;&gt;simple tokenizer&lt;/a&gt;, this means all terms have been folded to lower case. Also, there is (for example) no row with column &quot;term&quot; set to &quot;apple&quot; and column &quot;col&quot; set to 1. Since there are no instances of the term &quot;apple&quot; in column 1, no row is present in the fts4aux table.</source>
          <target state="translated">この例では、「term」列の値は、小文字のテーブル「ft」に挿入されていても、すべて小文字です。で、文書テキストから抽出されたようfts4aux表は用語が含まれているためです&lt;a href=&quot;fts3#tokenizer&quot;&gt;トークナイザ&lt;/a&gt;。この場合、テーブル &quot;ft&quot;は&lt;a href=&quot;fts3#tokenizer&quot;&gt;単純なトークナイザーを&lt;/a&gt;使用しているため、すべての用語が小文字に変換されています。また、（たとえば）列「term」が「apple」に設定され、列「col」が1に設定された行はありません。列1に「apple」という用語のインスタンスがないため、行に存在しません。 fts4auxテーブル。</target>
        </trans-unit>
        <trans-unit id="4d08492de7be0204d6bca6b75942d78b6a5e659c" translate="yes" xml:space="preserve">
          <source>In the examples above,</source>
          <target state="translated">上記の例では</target>
        </trans-unit>
        <trans-unit id="de880219c17c8178404452e7a6a65a0e25a5ab03" translate="yes" xml:space="preserve">
          <source>In the examples above, the APPCOST table would be interrogated to find the edit distance coefficients. It is the presence of the &quot;edit_cost_table=&quot; parameter to the spellfix1 module name that causes editdist3() to be used in place of the built-in edit distance function. If APPCOST is an empty string, then the built-in Wagner edit-distance function is used.</source>
          <target state="translated">上記の例では、編集距離係数を見つけるために APPCOST テーブルを照会しています。spellfix1 モジュール名に &quot;edit_cost_table=&quot; パラメータがあると、組み込みの編集距離関数の代わりに editdist3()が使用されます。APPCOST が空文字列の場合は、組み込みの Wagner 編集距離関数が使用されます。</target>
        </trans-unit>
        <trans-unit id="2400a1ee49a9dce2718b34cdfc5c379cec93c638" translate="yes" xml:space="preserve">
          <source>In the expression of a &lt;a href=&quot;gencol&quot;&gt;generated column&lt;/a&gt;.</source>
          <target state="translated">In the expression of a &lt;a href=&quot;gencol&quot;&gt;generated column&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="e3adc83f3d79277fad8353d570dcfc825d479731" translate="yes" xml:space="preserve">
          <source>In the expression of a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK制約の&lt;/a&gt;式で。</target>
        </trans-unit>
        <trans-unit id="1dc67cb87d0120f285414b41e4beb1e776521f83" translate="yes" xml:space="preserve">
          <source>In the expression part of an index on an expression.</source>
          <target state="translated">式のインデックスの式の部分では</target>
        </trans-unit>
        <trans-unit id="7ff8ef765e12ede160f30458a862b4edd37cec09" translate="yes" xml:space="preserve">
          <source>In the extreme case where the columns being indexed cover all columns of the PRIMARY KEY, the index will consist of only the columns being indexed. The ex25acde example above demonstrates this. Each entry in the ex25acde index consists of only the columns a, c, d, and e, in that order.</source>
          <target state="translated">インデックス化される列が PRIMARY KEY のすべての列をカバーしている極端なケースでは、インデックスはインデックス化される列のみで構成されます。上のex25acdeの例がこれを示しています。ex25acde インデックスの各エントリは、a,c,d,e の順に列 a,c,d,e だけで構成されています。</target>
        </trans-unit>
        <trans-unit id="f9d2f7bcd7e33c3c61f03684e92a0123ee2c50c1" translate="yes" xml:space="preserve">
          <source>In the first case, when the table does not previously exist, the table is automatically created and the content of the first row of the input CSV file is used to determine the name of all the columns in the table. In other words, if the table does not previously exist, the first row of the CSV file is interpreted to be column names and the actual data starts on the second row of the CSV file.</source>
          <target state="translated">最初のケースでは、テーブルが事前に存在しない場合は、自動的にテーブルが作成され、入力されたCSVファイルの1行目の内容から、テーブル内のすべての列の名前が決定されます。つまり、テーブルが事前に存在しない場合は、CSVファイルの1行目の内容がカラム名と解釈され、実際のデータはCSVファイルの2行目から開始されます。</target>
        </trans-unit>
        <trans-unit id="8cfb2ab353eeb9931ea61c166eef50db11918f37" translate="yes" xml:space="preserve">
          <source>In the following example, the window frame for each row consists of all rows from the current row to the end of the set, where rows are sorted according to &quot;ORDER BY a&quot;.</source>
          <target state="translated">次の例では、各行のウィンドウフレームは、現在の行からセットの最後までのすべての行で構成されており、行は「ORDER BY a」に従ってソートされています。</target>
        </trans-unit>
        <trans-unit id="ad3b432372161232b364559d85e3c83dbfa80ec8" translate="yes" xml:space="preserve">
          <source>In the following query, the optimizer is free to reorder the tables of FROM clause anyway it sees fit:</source>
          <target state="translated">次のクエリでは、オプティマイザは自由にFROM句のテーブルを並べ替えることができます。</target>
        </trans-unit>
        <trans-unit id="213dce290e5c56de530174ae284660516d8c6333" translate="yes" xml:space="preserve">
          <source>In the future, this option may also disable other floating point functionality, for example the &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_double()&lt;/a&gt;, &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_double()&lt;/a&gt;, &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_double()&lt;/a&gt; and &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_double()&lt;/a&gt; API functions.</source>
          <target state="translated">将来、このオプションは他の浮動小数点機能、たとえば&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_double（）&lt;/a&gt;、&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_double（）&lt;/a&gt;、&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_double（）&lt;/a&gt;および&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_double（）&lt;/a&gt; API関数も無効にする可能性があります。</target>
        </trans-unit>
        <trans-unit id="dfaedc6be2b7553cc537d3ce90c362a4be2c9a84" translate="yes" xml:space="preserve">
          <source>In the latter query, the query plan must be &lt;a href=&quot;#option2&quot;&gt;option 2&lt;/a&gt;. Note that you must use the keyword &quot;CROSS&quot; in order to disable the table reordering optimization; INNER JOIN, NATURAL JOIN, JOIN, and other similar combinations work just like a comma join in that the optimizer is free to reorder tables as it sees fit. (Table reordering is also disabled on an outer join, but that is because outer joins are not associative or commutative. Reordering tables in OUTER JOIN changes the result.)</source>
          <target state="translated">後者のクエリでは、クエリプランは&lt;a href=&quot;#option2&quot;&gt;オプション2で&lt;/a&gt;なければなりません。テーブルの並べ替えの最適化を無効にするには、キーワード「CROSS」を使用する必要があることに注意してください。INNER JOIN、NATURAL JOIN、JOIN、およびその他の同様の組み合わせは、コンマ結合と同じように機能し、オプティマイザはテーブルを適切に並べ替えることができます。（外部ジョインではテーブルの並べ替えも無効になりますが、これは外部ジョインが連想的または可換的ではないためです。OUTERJOINでテーブルを並べ替えると結果が変わります。）</target>
        </trans-unit>
        <trans-unit id="db1ceb5581cb83e63561f68248a7b5044a5f4d90" translate="yes" xml:space="preserve">
          <source>In the legacy interface, the return value will be either &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. With the &quot;v2&quot; interface, any of the other &lt;a href=&quot;rescode&quot;&gt;result codes&lt;/a&gt; or &lt;a href=&quot;rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; might be returned as well.</source>
          <target state="translated">従来のインターフェースでは、戻り値は&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;、または&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSEの&lt;/a&gt;いずれかになります。 「v2」インターフェースでは、他の&lt;a href=&quot;rescode&quot;&gt;結果コード&lt;/a&gt;または&lt;a href=&quot;rescode#extrc&quot;&gt;拡張結果コード&lt;/a&gt;も返される場合があります。</target>
        </trans-unit>
        <trans-unit id="c4f1e2e6a1b6e2882af269cc303fc56c8348c472" translate="yes" xml:space="preserve">
          <source>In the legacy interface, the return value will be either &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;, or &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. With the &quot;v2&quot; interface, any of the other &lt;a href=&quot;../rescode&quot;&gt;result codes&lt;/a&gt; or &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; might be returned as well.</source>
          <target state="translated">従来のインターフェースでは、戻り値は&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;、&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;、&lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;、&lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;、または&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSEの&lt;/a&gt;いずれかになります。 「v2」インターフェースでは、他の&lt;a href=&quot;../rescode&quot;&gt;結果コード&lt;/a&gt;または&lt;a href=&quot;../rescode#extrc&quot;&gt;拡張結果コード&lt;/a&gt;も返される場合があります。</target>
        </trans-unit>
        <trans-unit id="3e24ef81342a9cacce2edb83f3edc5fc97054dd2" translate="yes" xml:space="preserve">
          <source>In the previous query the fruit='Peach' constraint narrowed the result down to a single row. But the same technique works even if multiple rows are obtained. Suppose we looked up the price of Oranges instead of Peaches:</source>
          <target state="translated">前のクエリでは、fruit='Peach'制約により、結果は1行に絞られました。しかし、複数の行が得られた場合でも同じ手法が有効です。例えば、桃ではなくオレンジの価格を調べたとします。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
