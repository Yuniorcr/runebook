<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="4297ce915073f569ab40d9b2eef2a6a433c9c771" translate="yes" xml:space="preserve">
          <source>Fix a long-standing bug in the byte-code engine that can cause a &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; command report as success when in fact it failed to commit. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/810dc8038872e212&quot;&gt;810dc8038872e212&lt;/a&gt;</source>
          <target state="translated">Fix a long-standing bug in the byte-code engine that can cause a &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; command report as success when in fact it failed to commit. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/810dc8038872e212&quot;&gt;810dc8038872e212&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1e421af2a92eeb75b68bc6dee75d2cded7fea49f" translate="yes" xml:space="preserve">
          <source>Fix a long-standing bug in the query planner that caused incorrect results on a LEFT JOIN where the left-hand table is a subquery and the join constraint is a bare column name coming from the left-hand subquery. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/2df0107b&quot;&gt;2df0107b&lt;/a&gt;.</source>
          <target state="translated">左側のテーブルがサブクエリであり、結合制約が左側のサブクエリからの裸の列名であるLEFT JOINで誤った結果を引き起こしたクエリプランナーの長期にわたるバグを修正します。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/2df0107b&quot;&gt;2df0107b&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5fd66bb0d12f0c4694325a08e38b8332a42b240a" translate="yes" xml:space="preserve">
          <source>Fix a long-standing bug in the storage engine that would (very rarely) cause a spurious report of an SQLITE_CORRUPT error but which was otherwise harmless. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/6bfb98dfc0c&quot;&gt;6bfb98dfc0c&lt;/a&gt;.</source>
          <target state="translated">（まれに）SQLITE_CORRUPTエラーの誤ったレポートを引き起こし、それ以外は無害であったストレージエンジンの長期にわたるバグを修正します。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/6bfb98dfc0c&quot;&gt;6bfb98dfc0c&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="71423e6b2d68869ba9f90d3de52635f50c9c7337" translate="yes" xml:space="preserve">
          <source>Fix a long-standing problem in &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables that was reported a few hours after the 3.8.11 release.</source>
          <target state="translated">で長年の問題を修正しました&lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes（）&lt;/a&gt;のための&lt;a href=&quot;withoutrowid&quot;&gt;ROWIDのWITHOUT&lt;/a&gt;数時間3.8.11リリース後に報告されたテーブル。</target>
        </trans-unit>
        <trans-unit id="29e8d63f91df6bbd58bdb3b0c96b08a128597488" translate="yes" xml:space="preserve">
          <source>Fix a long-standing problem wherein a corrupt schema on the &lt;a href=&quot;fileformat2#seqtab&quot;&gt;sqlite_sequence&lt;/a&gt; table used by &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; can lead to a crash. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/d8dc2b3a58cd5dc29&quot;&gt;d8dc2b3a58cd5dc2918a1&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;が使用する&lt;a href=&quot;fileformat2#seqtab&quot;&gt;sqlite_sequence&lt;/a&gt;テーブルの破損したスキーマがクラッシュにつながるという長年の問題を修正します。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/d8dc2b3a58cd5dc29&quot;&gt;d8dc2b3a58cd5dc2918a1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d123dda0b40a993f6ee01005258efb1310831bb" translate="yes" xml:space="preserve">
          <source>Fix a memory allocation error in the new ADD COLUMN comment.</source>
          <target state="translated">新しいADD COLUMNコメントのメモリ割り当てエラーを修正。</target>
        </trans-unit>
        <trans-unit id="557f85fef49a7d6b5ef7280b85eaabf9d86a9cbc" translate="yes" xml:space="preserve">
          <source>Fix a memory leak that can occur following a disk I/O error.</source>
          <target state="translated">ディスクI/Oエラーの後に発生する可能性のあるメモリリークを修正しました。</target>
        </trans-unit>
        <trans-unit id="b2e50e850f4bad5e2b888790e4a27dda05de65d0" translate="yes" xml:space="preserve">
          <source>Fix a memory leak that can occur following a failure to open error in the &lt;a href=&quot;csv&quot;&gt;CSV virtual table&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;csv&quot;&gt;CSV仮想テーブルで&lt;/a&gt;エラーを開くエラーの後に発生する可能性のあるメモリリークを修正する</target>
        </trans-unit>
        <trans-unit id="08e2d33c27f7ca8760cc5e591fecb5972898df17" translate="yes" xml:space="preserve">
          <source>Fix a memory leak that occurred when sqlite_open() failed.</source>
          <target state="translated">sqlite_open()が失敗したときに発生したメモリリークを修正。</target>
        </trans-unit>
        <trans-unit id="475ca6beba2ec99949495af6c237c0b95d23fba9" translate="yes" xml:space="preserve">
          <source>Fix a missing &quot;sync&quot; that when omitted could lead to database corruption if a power failure or OS crash occurred just as a ROLLBACK operation was finishing.</source>
          <target state="translated">ROLLBACK操作が終了した直後に停電やOSクラッシュが発生した場合に、欠落していた &quot;sync &quot;を修正した。</target>
        </trans-unit>
        <trans-unit id="dd148f4d09fd6cc6bad30b19733a82972a2cebe0" translate="yes" xml:space="preserve">
          <source>Fix a naming conflict between sqlite.h and sqlite3.h.</source>
          <target state="translated">sqlite.hとsqlite3.hの間の名前の競合を修正。</target>
        </trans-unit>
        <trans-unit id="86cbab0ce9e871e04d98798d23ca791be9552d16" translate="yes" xml:space="preserve">
          <source>Fix a parser bug that prevented the use of parentheses around table-valued functions.</source>
          <target state="translated">テーブル値を持つ関数の周囲で括弧を使用できないパーサーのバグを修正しました。</target>
        </trans-unit>
        <trans-unit id="1ea82017fb31c1e817b4ca5fcdba2b68c62a7e38" translate="yes" xml:space="preserve">
          <source>Fix a performance bug in the pager cache, ticket #3844</source>
          <target state="translated">ページャーキャッシュのパフォーマンスバグを修正、チケット #3844</target>
        </trans-unit>
        <trans-unit id="0b4a31de7ab7e54e3e4f0e6dd796fb43aef54770" translate="yes" xml:space="preserve">
          <source>Fix a performance regression on LEFT JOIN (see ticket #3015) that was mistakenly introduced in &lt;a href=&quot;#version_3_5_8&quot;&gt;version 3.5.8&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#version_3_5_8&quot;&gt;バージョン3.5.8で&lt;/a&gt;誤って導入されたLEFT JOIN（チケット＃3015を参照）のパフォーマンス低下を修正します。</target>
        </trans-unit>
        <trans-unit id="51a1cd95a4c2ce3fd6ef13919dca1d81326877a9" translate="yes" xml:space="preserve">
          <source>Fix a performance regression related to the query planner enhancements of version 3.7.0.</source>
          <target state="translated">バージョン3.7.0のクエリプランナーの機能強化に関連したパフォーマンスの低下を修正しました。</target>
        </trans-unit>
        <trans-unit id="59850e50fa6095504ef5b88efd743956885d3a6e" translate="yes" xml:space="preserve">
          <source>Fix a possible infinite loop on VACUUM for corrupt database files. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/27754b74ddf64&quot;&gt;27754b74ddf64&lt;/a&gt;</source>
          <target state="translated">破損したデータベースファイルのVACUUMで発生する可能性があった無限ループを修正します。チェックイン&lt;a href=&quot;https://www.sqlite.org/src/info/27754b74ddf64&quot;&gt;27754b74ddf64&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="16de14f899013ff24b7caea8ce7237c3023ffe3c" translate="yes" xml:space="preserve">
          <source>Fix a possible segfault with DELETE when table is a &lt;a href=&quot;rowidtable&quot;&gt;rowid table&lt;/a&gt; with an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; and the WHERE clause contains a OR and the table has one or more indexes that are able to trigger the OR optimization, but none of the indexes reference any table columns other than the INTEGER PRIMARY KEY. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/16c9801ceba49&quot;&gt;16c9801ceba49&lt;/a&gt;.</source>
          <target state="translated">テーブルが&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;を持つ&lt;a href=&quot;rowidtable&quot;&gt;ROWIDテーブル&lt;/a&gt;であり、WHERE句にORが含まれ、テーブルにOR最適化をトリガーできる1つ以上のインデックスがあるが、どのインデックスもテーブル列を参照していない場合、DELETEで発生する可能性があるセグメンテーション違反を修正します。 INTEGER PRIMARY KEY以外。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/16c9801ceba49&quot;&gt;16c9801ceba49&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d502547575294f85b69c2db2bf60e7be17520a7d" translate="yes" xml:space="preserve">
          <source>Fix a potential 32-bit integer overflow problem in the &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; and &lt;a href=&quot;c3ref/blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; interfaces.</source>
          <target state="translated">&lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;および&lt;a href=&quot;c3ref/blob_write&quot;&gt;sqlite3_blob_write（）&lt;/a&gt;インターフェースの潜在的な32ビット整数オーバーフローの問題を修正します。</target>
        </trans-unit>
        <trans-unit id="86abca115efafefa4d8227ca90c204f72ac25973" translate="yes" xml:space="preserve">
          <source>Fix a potential buffer overread that could result when trying to search a corrupt database file.</source>
          <target state="translated">破損したデータベースファイルを検索しようとしたときに発生する可能性のあるバッファオーバーリードを修正しました。</target>
        </trans-unit>
        <trans-unit id="e6cf1ce475579b639fd9a6e590dcc754d75c144f" translate="yes" xml:space="preserve">
          <source>Fix a potential database corruption bug that can occur if version 3.7.0 and version 3.6.23.1 alternately write to the same database file. &lt;a href=&quot;http://www.sqlite.org/src/info/51ae9cad317a1&quot;&gt; Ticket [51ae9cad317a1]&lt;/a&gt;</source>
          <target state="translated">バージョン3.7.0とバージョン3.6.23.1が同じデータベースファイルに交互に書き込む場合に発生する可能性のある、データベース破損の潜在的なバグを修正します。&lt;a href=&quot;http://www.sqlite.org/src/info/51ae9cad317a1&quot;&gt;チケット[51ae9cad317a1]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2326ddb13e351e1098f9d7af1605ec053a972e00" translate="yes" xml:space="preserve">
          <source>Fix a potential database corruption problem on Unix caused by the fact that all POSIX advisory locks are cleared whenever you close() a file. The work around it to embargo all close() calls while locks are outstanding.</source>
          <target state="translated">ファイルをclose()するたびにすべてのPOSIX勧告ロックがクリアされるという事実に起因するUnix上の潜在的なデータベース破損の問題を修正しました。この問題を回避するには、ロックが未解決の間はすべての close()の呼び出しを禁じるようにします。</target>
        </trans-unit>
        <trans-unit id="3c1404201cf0f45ed7d26fb3ee3e025fabad8654" translate="yes" xml:space="preserve">
          <source>Fix a potential integer overflow problem when compiling a particular horrendous common table expression. This was another problem discovered by OSSFuzz. Check-in &lt;a href=&quot;https://sqlite.org/src/info/6ee8cb6ae5&quot;&gt;6ee8cb6ae5&lt;/a&gt;.</source>
          <target state="translated">特定の恐ろしい共通テーブル式をコンパイルするときに発生する可能性がある整数オーバーフローの問題を修正します。これは、OSSFuzzによって発見された別の問題でした。チェックイン&lt;a href=&quot;https://sqlite.org/src/info/6ee8cb6ae5&quot;&gt;6ee8cb6ae5&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fa021a738435d20102aefd6ba8aa9227f2196bfd" translate="yes" xml:space="preserve">
          <source>Fix a potential memory leak in &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; processing. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/2df6bbf1b8ca8&quot;&gt;2df6bbf1b8ca8&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;rowvalue&quot;&gt;行の値の&lt;/a&gt;処理における潜在的なメモリリークを修正します。チェックイン&lt;a href=&quot;https://www.sqlite.org/src/info/2df6bbf1b8ca8&quot;&gt;2df6bbf1b8ca8&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d59a5b1204741917d207d0911c7f5b60cccb2e8" translate="yes" xml:space="preserve">
          <source>Fix a potential memory leak in the new &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; interface. Ticket &lt;a href=&quot;https://sqlite.org/src/info/7486aa54b968e9b5&quot;&gt;7486aa54b968e9b5&lt;/a&gt;.</source>
          <target state="translated">新しい&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）&lt;/a&gt;インターフェースの潜在的なメモリリークを修正します。チケット&lt;a href=&quot;https://sqlite.org/src/info/7486aa54b968e9b5&quot;&gt;7486aa54b968e9b5&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0c9b94c0ee4da7edac18db1b27719d5740439e09" translate="yes" xml:space="preserve">
          <source>Fix a potential out-of-bound read when querying a corrupt database file, a problem detected by Natalie Silvanovich of Google Project Zero. Check-in &lt;a href=&quot;https://sqlite.org/src/info/04925dee41a21f&quot;&gt;04925dee41a21f&lt;/a&gt;.</source>
          <target state="translated">破損したデータベースファイルに対してクエリを実行するときに、潜在的な範囲外の読み取りを修正します。これは、Google Project ZeroのNatalie Silvanovichによって検出された問題です。チェックイン&lt;a href=&quot;https://sqlite.org/src/info/04925dee41a21f&quot;&gt;04925dee41a21f&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="94450756c5f997edafdb983263e971e139725961" translate="yes" xml:space="preserve">
          <source>Fix a potential segfault in complex recursive triggers, resulting from a bug in the OP_Once opcode introduced as part of a performance optimization in version 3.15.0. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/06796225f59c057c&quot;&gt;06796225f59c057c&lt;/a&gt;</source>
          <target state="translated">バージョン3.15.0のパフォーマンス最適化の一部として導入されたOP_Onceオペコードのバグに起因する、複雑な再帰トリガーの潜在的なsegfaultを修正します。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/06796225f59c057c&quot;&gt;06796225f59c057c&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9c23851f526115afe862ef20f590dcfe854957d3" translate="yes" xml:space="preserve">
          <source>Fix a potential segfault when destroying locks on WinCE in a multi-threaded environment.</source>
          <target state="translated">マルチスレッド環境で WinCE のロックを破壊する際のセグメンテーションフォールトの可能性を修正しました。</target>
        </trans-unit>
        <trans-unit id="c5254d73f95694f4312acfaaba5e2519c7f711c7" translate="yes" xml:space="preserve">
          <source>Fix a problem in &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; that can result in a corrupt database containing two or more rows with the same &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f68dc596c4e6018d&quot;&gt;f68dc596c4e6018d&lt;/a&gt;.</source>
          <target state="translated">問題点修正&lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt;同じ2つの以上の列を含むデータベース破損をもたらすことができること&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWIDを&lt;/a&gt;。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/f68dc596c4e6018d&quot;&gt;f68dc596c4e6018dの&lt;/a&gt;修正。</target>
        </trans-unit>
        <trans-unit id="cce51ec3d9eafc83d9bef6eb168bd83fba551391" translate="yes" xml:space="preserve">
          <source>Fix a problem in &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; that was causing a subsequent &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; to behave suboptimally.</source>
          <target state="translated">後続の&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;が最適ではない動作をする原因となっていた、&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integer_checkの&lt;/a&gt;問題を修正します。</target>
        </trans-unit>
        <trans-unit id="e2ab7efe53f641d1c01e53f622fc41a617719096" translate="yes" xml:space="preserve">
          <source>Fix a problem in CSV import in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; where if the leftmost field of the first row in the CSV file was both zero bytes in size and unquoted no data would be imported.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;コマンドラインシェル&lt;/a&gt;でのCSVインポートの問題を修正します。CSVファイルの最初の行の左端のフィールドのサイズがゼロバイトで、引用符で囲まれていない場合、データはインポートされません。</target>
        </trans-unit>
        <trans-unit id="b8e5e51fd7781a4a270ea3403c1d91e18539fa5d" translate="yes" xml:space="preserve">
          <source>Fix a problem in FTS4 where the left-most column that contained the &lt;a href=&quot;fts3#fts4notindexed&quot;&gt;notindexed column&lt;/a&gt; name as a prefix was not indexed rather than the column whose name matched exactly.</source>
          <target state="translated">名前が&lt;a href=&quot;fts3#fts4notindexed&quot;&gt;完全に&lt;/a&gt;一致する列ではなく、接頭辞としてnotindexed列名を含む左端の列が索引付けされなかったFTS4の問題を修正します。</target>
        </trans-unit>
        <trans-unit id="ed16f1842283c33640adef4111628a226934ccb4" translate="yes" xml:space="preserve">
          <source>Fix a problem in the &lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; interface that could cause problems for the &lt;a href=&quot;json1&quot;&gt;json1&lt;/a&gt; extension under obscure circumstances. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f45ac567eaa9f9&quot;&gt;f45ac567eaa9f9&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype（）&lt;/a&gt;インターフェースの問題を修正します。これにより、あいまいな状況で&lt;a href=&quot;json1&quot;&gt;json1&lt;/a&gt;拡張機能で問題が発生する可能性があります。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/f45ac567eaa9f9&quot;&gt;f45ac567eaa9f9の&lt;/a&gt;修正。</target>
        </trans-unit>
        <trans-unit id="7871f6059f0a9d8ae6199f7ed5e914925c1946d3" translate="yes" xml:space="preserve">
          <source>Fix a problem in the query planner that results when a row-value expression is used with a PRIMARY KEY with redundant columns. Ticket &lt;a href=&quot;https://sqlite.org/src/info/1a84668dcfdebaf12415d&quot;&gt;1a84668dcfdebaf12415d&lt;/a&gt;</source>
          <target state="translated">冗長列を持つPRIMARY KEYで行値式が使用されたときに発生するクエリプランナーの問題を修正します。チケット&lt;a href=&quot;https://sqlite.org/src/info/1a84668dcfdebaf12415d&quot;&gt;1a84668dcfdebaf12415d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ee14ad300b53edffc750ba4ada032439baf8cf04" translate="yes" xml:space="preserve">
          <source>Fix a problem in the virtual table commit mechanism that was causing a crash in FTS3. Ticket #3497.</source>
          <target state="translated">FTS3でクラッシュの原因となっていた仮想テーブルのコミットメカニズムの問題を修正しました。チケット #3497。</target>
        </trans-unit>
        <trans-unit id="367c86dcc3176132b397b28f7554be7148358015" translate="yes" xml:space="preserve">
          <source>Fix a problem that was causing excess memory usage with large &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; transactions in win32 systems.</source>
          <target state="translated">Win32システムでの大きな&lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;トランザクションでメモリ使用量が過剰になる問題を修正します。</target>
        </trans-unit>
        <trans-unit id="e4c5c3190d6e5398a03cc1624a8ad085afe03197" translate="yes" xml:space="preserve">
          <source>Fix a problem that was causing poor performance when many thousands of SQL statements were executed by a single sqlite_exec() call.</source>
          <target state="translated">1回のsqlite_exec()呼び出しで何千ものSQL文が実行された場合にパフォーマンスが低下する問題を修正しました。</target>
        </trans-unit>
        <trans-unit id="d6546ef65a68047eca9a74f928d58465048048f8" translate="yes" xml:space="preserve">
          <source>Fix a problem that will corrupt the database file if you drop a table from the main database that has a TEMP index.</source>
          <target state="translated">TEMPインデックスを持つメインデータベースからテーブルをドロップするとデータベースファイルが破損する問題を修正しました。</target>
        </trans-unit>
        <trans-unit id="6a895d74574faf7c3e5b7c17bfc4a1aebd1bd35a" translate="yes" xml:space="preserve">
          <source>Fix a problem that will corrupt the indices on a table if you do an INSERT OR REPLACE or an UPDATE OR REPLACE on a table that contains an INTEGER PRIMARY KEY plus one or more indices.</source>
          <target state="translated">INTEGER PRIMARY KEYと1つ以上のインデックスを含むテーブルでINSERT OR REPLACEやUPDATE OR REPLACEを行うと、テーブルのインデックスが破損する問題を修正しました。</target>
        </trans-unit>
        <trans-unit id="fa339d6b0d5c93a4f64854920f80fba0a5a92e67" translate="yes" xml:space="preserve">
          <source>Fix a problem where &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;PRAGMA count_changes&lt;/a&gt; was causing incorrect results for updates on tables with triggers</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;PRAGMA count_changes&lt;/a&gt;がトリガーのあるテーブルの更新で誤った結果を引き起こしていた問題を修正</target>
        </trans-unit>
        <trans-unit id="2367f688e4ee0ae00d13a38bb5c62a10fab4c4f9" translate="yes" xml:space="preserve">
          <source>Fix a problem with 3-way joins that do not use indices</source>
          <target state="translated">インデックスを使用しない 3 者間結合の問題を修正</target>
        </trans-unit>
        <trans-unit id="fc131893314d3ec5912c469546ad607795fe252a" translate="yes" xml:space="preserve">
          <source>Fix a problem with &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; which could cause transactions to silently rollback if the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt; is set very small (less than 10) and SQLite comes under memory pressure.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt;が非常に小さく（10未満）設定されていて、SQLiteがメモリ不足に陥った場合にトランザクションが警告なしにロールバックする可能性がある&lt;a href=&quot;wal&quot;&gt;WALモードの&lt;/a&gt;問題を修正します。</target>
        </trans-unit>
        <trans-unit id="1f2f150e12c534df43b52ade585282148590c894" translate="yes" xml:space="preserve">
          <source>Fix a problem with VACUUM on databases from which tables containing AUTOINCREMENT have been dropped.</source>
          <target state="translated">AUTOINCREMENTを含むテーブルが削除されたデータベースのVACUUMの問題を修正しました。</target>
        </trans-unit>
        <trans-unit id="e98ac2eb09507917a285747f2d5bd3a4164f2534" translate="yes" xml:space="preserve">
          <source>Fix a problem with string memory management in the VDBE</source>
          <target state="translated">VDBEでの文字列メモリ管理の問題を修正しました。</target>
        </trans-unit>
        <trans-unit id="1c1c998fb53575b975370a5727818e77b27c3b5a" translate="yes" xml:space="preserve">
          <source>Fix a problem with the &lt;a href=&quot;optoverview#leftjoinreduction&quot;&gt;LEFT JOIN strength reduction optimization&lt;/a&gt; in which the optimization was being applied inappropriately due to an IS NOT NULL operator. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/5948e09b8c415bc45d&quot;&gt;5948e09b8c415bc45d&lt;/a&gt;.</source>
          <target state="translated">IS NOT NULL演算子が原因で最適化が不適切に適用されていた&lt;a href=&quot;optoverview#leftjoinreduction&quot;&gt;LEFT JOIN強度削減最適化の&lt;/a&gt;問題を修正します。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/5948e09b8c415bc45d&quot;&gt;5948e09b8c415bc45d&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3e42c3e04422e8992158af198fdedf65d8a494b4" translate="yes" xml:space="preserve">
          <source>Fix a problem with the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt; on &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/d96eba87698a428c1d&quot;&gt;d96eba87698a428c1d&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expridx&quot;&gt;式のインデックス&lt;/a&gt;の&lt;a href=&quot;optoverview#or_opt&quot;&gt;OR最適化の&lt;/a&gt;問題を修正します。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/d96eba87698a428c1d&quot;&gt;d96eba87698a428c1d&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a552a20d99699b5fa85e0ed7fb142721053399d9" translate="yes" xml:space="preserve">
          <source>Fix a problem with the multi-row one-pass DELETE optimization that was causing it to compute incorrect answers with a self-referential subquery in the WHERE clause. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/dc6ebeda9396087&quot;&gt;dc6ebeda9396087&lt;/a&gt;</source>
          <target state="translated">WHERE句の自己参照サブクエリを使用して誤った回答を計算する原因となっていた複数行の1パスDELETE最適化の問題を修正します。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/dc6ebeda9396087&quot;&gt;dc6ebeda9396087の&lt;/a&gt;修正</target>
        </trans-unit>
        <trans-unit id="070ed03b719700575899432a2c98f057535dbcc4" translate="yes" xml:space="preserve">
          <source>Fix a problem with the new &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt; implementation that caused a malfunction when complicated expressions involving window functions were used inside of a view.</source>
          <target state="translated">ウィンドウ関数を含む複雑な式がビュー内で使用されたときに誤動作を引き起こした新しい&lt;a href=&quot;windowfunctions&quot;&gt;ウィンドウ関数の&lt;/a&gt;実装の問題を修正します。</target>
        </trans-unit>
        <trans-unit id="ef0924214b0eb9fe23d46afbb07aaf1261d67d0a" translate="yes" xml:space="preserve">
          <source>Fix a problem with the sort order when comparing upper-case strings against characters greater than 'Z' but less than 'a'.</source>
          <target state="translated">大文字の文字列を'Z'より大きいが'a'より小さい文字と比較する際のソート順の問題を修正しました。</target>
        </trans-unit>
        <trans-unit id="5e753a491c25e8edb1492253042a4e79f112f875" translate="yes" xml:space="preserve">
          <source>Fix a problem with the use of &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt; used within &lt;a href=&quot;lang_expr#cosub&quot;&gt;correlated subqueries&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/d0866b26f83e9c55e3&quot;&gt;d0866b26f83e9c55e3&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lang_expr#cosub&quot;&gt;相関サブクエリ&lt;/a&gt;内で使用される&lt;a href=&quot;windowfunctions&quot;&gt;ウィンドウ関数&lt;/a&gt;の使用に関する問題を修正します。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/d0866b26f83e9c55e3&quot;&gt;d0866b26f83e9c55e3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="551f44e055f1b2367c902fea7be697c804fc97a8" translate="yes" xml:space="preserve">
          <source>Fix a problem with using the &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE optimization&lt;/a&gt; on an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/b850dd159918af56&quot;&gt;b850dd159918af56&lt;/a&gt;.</source>
          <target state="translated">使用して問題を修正しました&lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKEの最適化&lt;/a&gt;に&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEYを&lt;/a&gt;。チェックイン&lt;a href=&quot;https://www.sqlite.org/src/info/b850dd159918af56&quot;&gt;b850dd159918af56&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="293886e1e2fac8f6d1689e1a0e83ac48f4add2fd" translate="yes" xml:space="preserve">
          <source>Fix a query planner bug involving a LEFT JOIN with a BETWEEN or LIKE/GLOB constraint and then another INNER JOIN to the right that involves an OR constraint.</source>
          <target state="translated">クエリプランナのバグを修正しました。これは、BETWEENまたはLIKE/GLOB制約を含むLEFT JOINと、OR制約を含む右への別のINNER JOINを含むものです。</target>
        </trans-unit>
        <trans-unit id="8ff17cc556a87f30aa15241b1ac5c7a361de91a4" translate="yes" xml:space="preserve">
          <source>Fix a query planner bug that could result in a segfault when querying tables with a UNIQUE or PRIMARY KEY constraint with more than four columns.</source>
          <target state="translated">4つ以上の列を持つUNIQUEまたはPRIMARY KEY制約を持つテーブルにクエリを実行した場合にセグメンテーションフォールトが発生する可能性があるクエリプランナのバグを修正しました。</target>
        </trans-unit>
        <trans-unit id="9fb45458b64cd84ba2a2f30a7bfee1435ad64176" translate="yes" xml:space="preserve">
          <source>Fix a query planner bug that might cause a table to be scanned in the wrong direction (thus reversing the order of output) when a DESC index is used to implement the ORDER BY clause on a query that has an identical GROUP BY clause. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/ba7cbfaedc7e6&quot;&gt;ba7cbfaedc7e6&lt;/a&gt;.</source>
          <target state="translated">DESCインデックスを使用して、同じGROUP BY句を持つクエリにORDER BY句を実装すると、テーブルが間違った方向にスキャンされる（その結果、出力の順序が逆になる）可能性があるクエリプランナーのバグを修正します。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/ba7cbfaedc7e6&quot;&gt;ba7cbfaedc7e6&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="09bdfd52ac4cb9f3c70abc6d5f401e62168b1225" translate="yes" xml:space="preserve">
          <source>Fix a query planner problem that could result in an incorrect answer due to the use of &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexing&lt;/a&gt; in subqueries in the FROM clause of a correlated scalar subqueries. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/8a2adec1&quot;&gt;8a2adec1&lt;/a&gt;.</source>
          <target state="translated">相関スカラーサブクエリのFROM句のサブクエリで&lt;a href=&quot;optoverview#autoindex&quot;&gt;自動インデックス付け&lt;/a&gt;を使用するために不正解になる可能性があるクエリプランナーの問題を修正します。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/8a2adec1&quot;&gt;8a2adec1の&lt;/a&gt;修正。</target>
        </trans-unit>
        <trans-unit id="3db45cb5a06554ceffd3c2fab04e67abb9573838" translate="yes" xml:space="preserve">
          <source>Fix a race condition in AUTOVACUUM that can lead to corrupt databases</source>
          <target state="translated">データベースが破損する可能性のあるAUTOVACUUMの競合状態を修正</target>
        </trans-unit>
        <trans-unit id="96a8e915a1becae62cd060b6c6ea6fdc08fd0da2" translate="yes" xml:space="preserve">
          <source>Fix a race condition in test_async.c.</source>
          <target state="translated">test_async.c の競合状態を修正。</target>
        </trans-unit>
        <trans-unit id="625e5e94c16544ff24dd9e860382b39ea7c80a87" translate="yes" xml:space="preserve">
          <source>Fix a segfault that can occur for queries that use table-valued functions in an IN or EXISTS subquery. Ticket &lt;a href=&quot;https://sqlite.org/src/info/b899b6042f97f5&quot;&gt;b899b6042f97f5&lt;/a&gt;</source>
          <target state="translated">INまたはEXISTSサブクエリでテーブル値関数を使用するクエリで発生する可能性があるsegfaultを修正します。チケット&lt;a href=&quot;https://sqlite.org/src/info/b899b6042f97f5&quot;&gt;b899b6042f97f5&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a280dd5a4ba61a6ed5b8a4172311dcec663fd176" translate="yes" xml:space="preserve">
          <source>Fix a serious bug in the INSERT command which was causing data to go into the wrong columns if the data source was a SELECT and the INSERT clauses specified its columns in some order other than the default.</source>
          <target state="translated">データソースがSELECTで、INSERT句がデフォルト以外の順序で列を指定している場合に、データが間違った列に入る原因となっていたINSERTコマンドの重大なバグを修正しました。</target>
        </trans-unit>
        <trans-unit id="a11d09fcf4c5c4f534bed3e95aeaedc75d2eadb8" translate="yes" xml:space="preserve">
          <source>Fix a strange (but valid) C declaration that was causing problems for QNX. No logical changes.</source>
          <target state="translated">QNX の問題の原因となっていた奇妙な (有効な)C 宣言を修正しました。論理的な変更はありません。</target>
        </trans-unit>
        <trans-unit id="7c6a164c4c1dd8fe7b071d0ade9de88fbde73880" translate="yes" xml:space="preserve">
          <source>Fix a typos in the sqlite3ext.h header file that prevented the &lt;a href=&quot;c3ref/stmt_isexplain&quot;&gt;sqlite3_stmt_isexplain()&lt;/a&gt; and &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_frombind()&lt;/a&gt; interfaces from being called from &lt;a href=&quot;loadext&quot;&gt;run-time loadable extensions&lt;/a&gt;.</source>
          <target state="translated">Fix a typos in the sqlite3ext.h header file that prevented the &lt;a href=&quot;c3ref/stmt_isexplain&quot;&gt;sqlite3_stmt_isexplain()&lt;/a&gt; and &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_frombind()&lt;/a&gt; interfaces from being called from &lt;a href=&quot;loadext&quot;&gt;run-time loadable extensions&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="0a54239aed950f147b9530647f9884464a8a7700" translate="yes" xml:space="preserve">
          <source>Fix a use-after-free that can occur when SQLite is compiled with -DSQLITE_HAS_CODEC.</source>
          <target state="translated">SQLite が -DSQLITE_HAS_CODEC でコンパイルされている場合に発生する可能性のある使用後フリーを修正しました。</target>
        </trans-unit>
        <trans-unit id="65b8ad24259b51f708505579d558096b74643e0f" translate="yes" xml:space="preserve">
          <source>Fix an 64-bit alignment bug on HP/UX and Sparc</source>
          <target state="translated">HP/UX および Sparc での 64 ビットアライメントのバグを修正</target>
        </trans-unit>
        <trans-unit id="8d3940a154d321cca0d2eb2aa13ea157138409fd" translate="yes" xml:space="preserve">
          <source>Fix an &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; issue in which the 'optimize' command could cause index corruption.</source>
          <target state="translated">'optimize'コマンドがインデックスの破損を引き起こす可能性がある&lt;a href=&quot;fts5&quot;&gt;FTS5の&lt;/a&gt;問題を修正します。</target>
        </trans-unit>
        <trans-unit id="cf27be06b87f8658f160d75e065a66b3575cb593" translate="yes" xml:space="preserve">
          <source>Fix an &lt;a href=&quot;http://www.sqlite.org/src/info/5e10420e8d&quot;&gt; old and very obscure bug&lt;/a&gt; that can lead to corruption of the database &lt;a href=&quot;fileformat2#freelist&quot;&gt;free-page list&lt;/a&gt; when &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; is used.</source>
          <target state="translated">修正&lt;a href=&quot;http://www.sqlite.org/src/info/5e10420e8d&quot;&gt;古いと非常にあいまいなバグ&lt;/a&gt;データベースの破損につながる可能&lt;a href=&quot;fileformat2#freelist&quot;&gt;空きページ・リスト&lt;/a&gt;際&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuumが&lt;/a&gt;使用されているが。</target>
        </trans-unit>
        <trans-unit id="2b834d02e62a3f123a1b8d14a7dd0d0f55d7a363" translate="yes" xml:space="preserve">
          <source>Fix an alignment problem on 64-bit machines</source>
          <target state="translated">64 ビットマシンでのアライメントの問題を修正</target>
        </trans-unit>
        <trans-unit id="22b28f14aad0849b7f089af3e0ae2de83c9cc448" translate="yes" xml:space="preserve">
          <source>Fix an assertion failure that occurred when deleting all rows of a table with the &quot;count_changes&quot; pragma turned on.</source>
          <target state="translated">count_changes &quot;プラグマをオンにしてテーブルの全行を削除したときに発生したアサーションの失敗を修正しました。</target>
        </trans-unit>
        <trans-unit id="24c083d9fe654c2c6b13e8a4783ebdcf071478d1" translate="yes" xml:space="preserve">
          <source>Fix an assertion fault that can occur when updating the NULL value of a field at the end of a table that was added using &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ADD COLUMN&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ADD COLUMN&lt;/a&gt;を使用して追加されたテーブルの最後にあるフィールドのNULL値を更新するときに発生する可能性があるアサーションフォールトを修正します。</target>
        </trans-unit>
        <trans-unit id="24c0b7a3124e531d424b372570a621483ca0c334" translate="yes" xml:space="preserve">
          <source>Fix an assertion fault that could occur following &lt;a href=&quot;pragma#pragma_reverse_unordered_selects&quot;&gt;PRAGMA reverse_unordered_selects&lt;/a&gt;. Ticket &lt;a href=&quot;https://sqlite.org/src/info/cb91bf4290c211d&quot;&gt;cb91bf4290c211d&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_reverse_unordered_selects&quot;&gt;PRAGMA reverse_unordered_selectsの&lt;/a&gt;後に発生する可能性があったアサーションフォールトを修正します。チケット&lt;a href=&quot;https://sqlite.org/src/info/cb91bf4290c211d&quot;&gt;cb91bf4290c211d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="28b592fe11bf16075b14f304072980cfa741f4d3" translate="yes" xml:space="preserve">
          <source>Fix an assertion fault that occurred on deeply nested views.</source>
          <target state="translated">深くネストされたビューで発生したアサーションフォールトを修正しました。</target>
        </trans-unit>
        <trans-unit id="5a204d98c949cf8975212c05340c51bd92e0547a" translate="yes" xml:space="preserve">
          <source>Fix an assertion fault that was coming up when the expression in an index-on-expressions is really a constant. Ticket &lt;a href=&quot;https://sqlite.org/src/info/aa98619ad08ddca&quot;&gt;aa98619ad08ddca&lt;/a&gt;</source>
          <target state="translated">index-on-expressionsの式が実際に定数であるときに発生していたアサーションフォールトを修正します。チケット&lt;a href=&quot;https://sqlite.org/src/info/aa98619ad08ddca&quot;&gt;aa98619ad08ddca&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5edfc637acd59a3db220a001c5781ab4bd7de9b5" translate="yes" xml:space="preserve">
          <source>Fix an index corruption issue introduced by &lt;a href=&quot;#version_3_8_7&quot;&gt;version 3.8.7&lt;/a&gt;. An index with a TEXT key can be corrupted by an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; into the corresponding table if the table has two nested triggers that convert the key value to INTEGER and back to TEXT again. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/34cd55d68e0e6e7c9a0711aab81a2ee3c354b4c0&quot;&gt;34cd55d68e0&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#version_3_8_7&quot;&gt;バージョン3.8.7で&lt;/a&gt;導入されたインデックス破損の問題を修正します。テーブルにキー値をINTEGERに変換して再度TEXTに戻す2つのネストされたトリガーがある場合、対応するテーブルへの&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;によってTEXTキーを持つインデックスが破損する可能性があります。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/34cd55d68e0e6e7c9a0711aab81a2ee3c354b4c0&quot;&gt;34cd55d68e0&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8eeeaac39b440e493474edfe8a18c8edd3970590" translate="yes" xml:space="preserve">
          <source>Fix an infinite-loop in the query planner that could occur on malformed &lt;a href=&quot;lang_with&quot;&gt;common table expressions&lt;/a&gt;.</source>
          <target state="translated">不正な形式の&lt;a href=&quot;lang_with&quot;&gt;共通テーブル式で&lt;/a&gt;発生する可能性があったクエリプランナーの無限ループを修正します。</target>
        </trans-unit>
        <trans-unit id="e7f2f6913b7c03deeb2b6b41e2ed3b92c354b90f" translate="yes" xml:space="preserve">
          <source>Fix an internal code generator problem that was causing some &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; operations to no-op. Ticket &lt;a href=&quot;https://sqlite.org/src/info/ef360601&quot;&gt;ef360601&lt;/a&gt;</source>
          <target state="translated">一部の&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;操作で何も実行されなかった内部コードジェネレーターの問題を修正します。チケット&lt;a href=&quot;https://sqlite.org/src/info/ef360601&quot;&gt;ef360601&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="337ef48955d3bd9a0a84bd4a9dd181f41e6cabab" translate="yes" xml:space="preserve">
          <source>Fix an issue in the fsdir(PATH) &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; to the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/fileio.c&quot;&gt;fileio.c&lt;/a&gt; extension, that caused a segfault if the fsdir() table was used as the inner table of a join. Problem reported on the mailing list and fixed by check-in &lt;a href=&quot;https://www.sqlite.org/src/info/7ce4e71c1b7251be&quot;&gt;7ce4e71c1b7251be&lt;/a&gt;</source>
          <target state="translated">fsdir（）テーブルが結合の内部テーブルとして使用された場合に、segfaultを引き起こした、&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/fileio.c&quot;&gt;fileio.c&lt;/a&gt;拡張に対するfsdir（PATH）&lt;a href=&quot;vtab#tabfunc2&quot;&gt;テーブル値関数の&lt;/a&gt;問題を修正します。メーリングリストで報告され、チェックイン&lt;a href=&quot;https://www.sqlite.org/src/info/7ce4e71c1b7251be&quot;&gt;7ce4e71c1b7251beで&lt;/a&gt;修正された問題</target>
        </trans-unit>
        <trans-unit id="6f2b91637b2c2c39f1dab693ce0e485fd3cd7d63" translate="yes" xml:space="preserve">
          <source>Fix an issue with incorrect sharing of VDBE temporary registers between co-routines that could cause incorrect query results in obscure cases. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/d06a25c84454a&quot;&gt;d06a25c84454a&lt;/a&gt;.</source>
          <target state="translated">コルーチン間でのV​​DBE一時レジスターの誤った共有により、あいまいなケースで誤った照会結果を引き起こす可能性がある問題を修正します。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/d06a25c84454a&quot;&gt;d06a25c84454a&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7c984a9789b89b098bf54d9a87bf8ad24379596a" translate="yes" xml:space="preserve">
          <source>Fix an obscure and relatively harmless problem that might have caused a resource leak following an I/O error.</source>
          <target state="translated">I/Oエラーの後にリソースリークが発生した可能性のある、不明瞭で比較的無害な問題を修正しました。</target>
        </trans-unit>
        <trans-unit id="9af5e2e7bb886d04f6d1d3a91c18b1bcfc2e680c" translate="yes" xml:space="preserve">
          <source>Fix an obscure bug that can cause database corruption under the following unusual circumstances: A large INSERT or UPDATE statement which is part of an even larger transaction fails due to a uniqueness constraint but the containing transaction commits.</source>
          <target state="translated">以下の異常な状況下でデータベースが破損する原因となる不明瞭なバグを修正しました。さらに大きなトランザクションの一部である大規模なINSERTまたはUPDATE文は、一意性制約のために失敗しますが、それを含むトランザクションはコミットします。</target>
        </trans-unit>
        <trans-unit id="0096a0fca1b6b43797d06b363272bd306cbf7ce9" translate="yes" xml:space="preserve">
          <source>Fix an obscure bug that can cause database corruption under the following unusual circumstances: A large INSERT or UPDATE statement which is part of an even larger transaction fails due to a uniqueness contraint but the containing transaction commits.</source>
          <target state="translated">以下の異常な状況下でデータベースが破損する可能性がある不明瞭なバグを修正しました。さらに大きなトランザクションの一部である大規模なINSERTまたはUPDATE文は、一意性の矛盾により失敗しますが、それを含むトランザクションはコミットします。</target>
        </trans-unit>
        <trans-unit id="ce8d90d9be96ff29e6eda51d841a97e900370a1d" translate="yes" xml:space="preserve">
          <source>Fix an obscure memory leak in &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt;. Ticket &lt;a href=&quot;https://sqlite.org/src/info/7486aa54b968e9b&quot;&gt;7486aa54b968e9b&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer（）の&lt;/a&gt;あいまいなメモリリークを修正します。チケット&lt;a href=&quot;https://sqlite.org/src/info/7486aa54b968e9b&quot;&gt;7486aa54b968e9b&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9faef411a2ddeadaf79ebd73389c10f7af52120" translate="yes" xml:space="preserve">
          <source>Fix an obscure segfault in UTF-8 to UTF-16 conversions</source>
          <target state="translated">UTF-8からUTF-16への変換で不明瞭なセグメンテーションフォールトを修正</target>
        </trans-unit>
        <trans-unit id="b5c1f0802c64a77b99076bfc9059cf131dd55807" translate="yes" xml:space="preserve">
          <source>Fix an off-by-one error that caused quoted empty string at the end of a CRNL-terminated line of CSV input to be misread by the command-line shell.</source>
          <target state="translated">CRNLで終端したCSV入力の行の最後にある引用符で囲まれた空の文字列がコマンドラインシェルで誤読されていたオフバイワンエラーを修正しました。</target>
        </trans-unit>
        <trans-unit id="30b0fd93ee02b86cc24f6cc7bd2523397f033eee" translate="yes" xml:space="preserve">
          <source>Fix an optimizer bug involving subqueries in a compound SELECT that has both an ORDER BY and a LIMIT clause. Ticket #2339.</source>
          <target state="translated">ORDER BY句とLIMIT句の両方を持つ複合SELECTのサブクエリに関連するオプティマイザーのバグを修正しました。チケット #2339。</target>
        </trans-unit>
        <trans-unit id="683ed4e4563f819c0aec9579fc2147e259103b73" translate="yes" xml:space="preserve">
          <source>Fix an optimizer bug that could have caused some unusual LEFT OUTER JOINs to give incorrect results.</source>
          <target state="translated">オプティマイザのバグを修正しました。</target>
        </trans-unit>
        <trans-unit id="762e5ec5f054c66d660a449bf35057af7025d512" translate="yes" xml:space="preserve">
          <source>Fix an uninitialized variable in pager.c which could (with a probability of about 1 in 4 billion) result in a corrupted database.</source>
          <target state="translated">pager.c の初期化されていない変数を修正しました。</target>
        </trans-unit>
        <trans-unit id="4ff50f16c16225e491f827922f36f0a1b00ee9e8" translate="yes" xml:space="preserve">
          <source>Fix another bug in the IS NULL optimization that was added in version 3.3.9.</source>
          <target state="translated">バージョン3.3.9で追加されたIS NULL最適化の別のバグを修正。</target>
        </trans-unit>
        <trans-unit id="e8f06a6dcd8a035bb10d1fb00994a8c1617f3e5c" translate="yes" xml:space="preserve">
          <source>Fix another bug in the implementation of the new &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; API. We'll get it right eventually...</source>
          <target state="translated">新しい&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt; APIの実装における別のバグを修正します。私たちは最終的にそれを正しくするでしょう...</target>
        </trans-unit>
        <trans-unit id="6f129ae803d9883975a2438f98f71935a3f57c27" translate="yes" xml:space="preserve">
          <source>Fix bugs in pager.c that could lead to database corruption if two processes both try to recover a hot journal at the same instant</source>
          <target state="translated">2つのプロセスが同時にホットジャーナルを回復しようとした場合に、データベースが破損する可能性があるpager.cのバグを修正。</target>
        </trans-unit>
        <trans-unit id="e51c167c962ab37e883d84e10e98aee9dad05d15" translate="yes" xml:space="preserve">
          <source>Fix bugs in the implementation of the new &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; API that can lead to segfaults.</source>
          <target state="translated">新しい&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2（）&lt;/a&gt; API の実装で、segfaultにつながる可能性のあるバグを修正します。</target>
        </trans-unit>
        <trans-unit id="15b10b87ff343116def15b81c85457d634788432" translate="yes" xml:space="preserve">
          <source>Fix bugs that can (rarely) lead to incorrect query results when the CAST or OR operators are used in the WHERE clause of a query.</source>
          <target state="translated">クエリのWHERE句でCAST演算子やOR演算子が使用されている場合に、間違ったクエリ結果につながる可能性のあるバグを修正しました(まれに)。</target>
        </trans-unit>
        <trans-unit id="3d935fe3f3737292749bd1972d56f443d7c93968" translate="yes" xml:space="preserve">
          <source>Fix byte alignment problems on 64-bit architectures.</source>
          <target state="translated">64ビットアーキテクチャでのバイトアライメントの問題を修正しました。</target>
        </trans-unit>
        <trans-unit id="7bca40ab59e8b9695f58ea94f5115e8c80d7a7c3" translate="yes" xml:space="preserve">
          <source>Fix commenting errors and improve the comments generated on &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; listings when the &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt;コンパイル時オプションが使用されている場合、コメントエラーを修正し、&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;リストで生成されるコメントを改善します。</target>
        </trans-unit>
        <trans-unit id="f6a563b99fee018f87bcc6d45b57949ce6d02874" translate="yes" xml:space="preserve">
          <source>Fix data races that might occur under stress when running with many threads in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; where some of the threads are opening and closing connections.</source>
          <target state="translated">スレッドの一部が接続を開いたり閉じたりしている&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュモード&lt;/a&gt;で多くのスレッドを実行しているときにストレス下で発生する可能性があるデータの競合を修正します。</target>
        </trans-unit>
        <trans-unit id="3810fcb3cfb91e5274e7723b80500a70b2e4eef7" translate="yes" xml:space="preserve">
          <source>Fix data structure alignment issues on Sparc. Ticket #3777.</source>
          <target state="translated">Sparc でのデータ構造のアラインメントの問題を修正しました。チケット #3777。</target>
        </trans-unit>
        <trans-unit id="a7f89cd0a1f20da8469d2ab54509c35e86684ab3" translate="yes" xml:space="preserve">
          <source>Fix editline support in the command-line shell.</source>
          <target state="translated">コマンドラインシェルのeditlineサポートを修正。</target>
        </trans-unit>
        <trans-unit id="87d44c2123224749ec741fa602897daad30b0e0b" translate="yes" xml:space="preserve">
          <source>Fix for a bug in the ORDER BY optimizer that was introduced in &lt;a href=&quot;#version_3_7_15&quot;&gt;version 3.7.15&lt;/a&gt; which would sometimes optimize out the sorting step when in fact the sort was required. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/a179fe7465&quot;&gt;a179fe7465&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#version_3_7_15&quot;&gt;バージョン3.7.15&lt;/a&gt;で導入されたORDER BYオプティマイザーのバグを修正しました。これにより、実際にソートが必要な場合に、ソート手順が最適化されない場合がありました。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/a179fe7465&quot;&gt;a179fe7465&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0a782f7686d7d9707b5dc5190d2cb994db1da8ac" translate="yes" xml:space="preserve">
          <source>Fix for a bug in the SELECT DISTINCT logic that was introduced by the prior version.</source>
          <target state="translated">以前のバージョンで導入されたSELECT DISTINCTロジックのバグを修正しました。</target>
        </trans-unit>
        <trans-unit id="293d91bd4dad89365956202fbbdc05193695a217" translate="yes" xml:space="preserve">
          <source>Fix for another problem (unrelated to the one fixed in 2.1.4) that sometimes causes &lt;b&gt;sqlite_exec()&lt;/b&gt; to return SQLITE_PROTOCOL unnecessarily. This time the bug was in the POSIX locking code and should not effect Windows users.</source>
          <target state="translated">&lt;b&gt;sqlite_exec（）&lt;/b&gt;が不必要にSQLITE_PROTOCOLを返す場合がある別の問題（2.1.4で修正された問題とは無関係）を修正します。今回のバグはPOSIXロックコードにあり、Windowsユーザーには影響しません。</target>
        </trans-unit>
        <trans-unit id="692cc3acdf11cc382c710566eb5e8d41ae9a76e6" translate="yes" xml:space="preserve">
          <source>Fix inconsistent integer to floating-point comparison operations that could result in a corrupt index if the index is created on a table column that contains both large integers and floating point values of similar magnitude. Ticket &lt;a href=&quot;https://www.sqlite.org/src/tktview?name=38a97a87a6&quot;&gt;38a97a87a6&lt;/a&gt;.</source>
          <target state="translated">大きな整数と同様の大きさの浮動小数点値の両方を含むテーブル列にインデックスが作成された場合に、インデックスが破損する可能性のある不整合整数と浮動小数点の比較演算を修正します。チケット&lt;a href=&quot;https://www.sqlite.org/src/tktview?name=38a97a87a6&quot;&gt;38a97a87a6&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cbe4713574b5e7e1bf3ea574e5968f7da369b174" translate="yes" xml:space="preserve">
          <source>Fix incorrect result with complex OR-connected WHERE and STAT4. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/ec32177c99ccac2&quot;&gt;ec32177c99ccac2&lt;/a&gt;</source>
          <target state="translated">複雑なOR接続されたWHEREおよびSTAT4での誤った結果を修正します。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/ec32177c99ccac2&quot;&gt;ec32177c99ccac2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="32ba32659ea655886bad57a0dd08fbe5d98856b9" translate="yes" xml:space="preserve">
          <source>Fix locking behavior under Windows</source>
          <target state="translated">Windowsでのロック動作を修正</target>
        </trans-unit>
        <trans-unit id="1f35665eab7b4eb2d565f64daa7ab9de3e2952ac" translate="yes" xml:space="preserve">
          <source>Fix many obscure problems discovered while &lt;a href=&quot;testing#fuzztesting&quot;&gt;SQL fuzzing&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;testing#fuzztesting&quot;&gt;SQLファジング&lt;/a&gt;中に発見された多くのあいまいな問題を修正します。</target>
        </trans-unit>
        <trans-unit id="8e786cb80b44d5b0bc787df47e982713af4c0ff9" translate="yes" xml:space="preserve">
          <source>Fix many potential segfaults that could be caused by malicious SQL statements.</source>
          <target state="translated">悪意のあるSQL文によって引き起こされる可能性のある多くのセグメンテーションフォールトを修正しました。</target>
        </trans-unit>
        <trans-unit id="0ab2336b4ec301e575c6d8af5dd4486d9002cf92" translate="yes" xml:space="preserve">
          <source>Fix memory leaks that used to occur after a malloc() failure.</source>
          <target state="translated">malloc()の失敗後に発生していたメモリリークを修正。</target>
        </trans-unit>
        <trans-unit id="6b6c482ed533b8d025b0b530bd86fd284d9ab805" translate="yes" xml:space="preserve">
          <source>Fix memory size tracking so that it works even if SQLite uses more than 2GiB of memory.</source>
          <target state="translated">SQLiteが2GiB以上のメモリを使用していても動作するように、メモリサイズのトラッキングを修正しました。</target>
        </trans-unit>
        <trans-unit id="83c4e0c639eeed5339ef3f3550050703ea306329" translate="yes" xml:space="preserve">
          <source>Fix minor issues with the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;dbstat&quot;&gt;dbstat仮想テーブルの&lt;/a&gt;小さな問題を修正します。</target>
        </trans-unit>
        <trans-unit id="6d8fc1c13727f748ff40e9e6be94b0b7005ead11" translate="yes" xml:space="preserve">
          <source>Fix misbehavior of the FTS5 xBestIndex method. Ticket &lt;a href=&quot;https://sqlite.org/src/info/2b8aed9f7c9e61e8&quot;&gt;2b8aed9f7c9e61e8&lt;/a&gt;.</source>
          <target state="translated">FTS5 xBestIndexメソッドの誤動作を修正しました。チケット&lt;a href=&quot;https://sqlite.org/src/info/2b8aed9f7c9e61e8&quot;&gt;2b8aed9f7c9e61e8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d6aeb35ac1eb7c66584445cf87b55f99254ca966" translate="yes" xml:space="preserve">
          <source>Fix more bugs in the LEFT JOIN &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/7fde638e94287d2c&quot;&gt;7fde638e94287d2c&lt;/a&gt;.</source>
          <target state="translated">LEFT JOINの&lt;a href=&quot;optoverview#flattening&quot;&gt;平坦化の最適化の&lt;/a&gt;バグをさらに修正します。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/7fde638e94287d2c&quot;&gt;7fde638e94287d2c&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1506d1bb252e85d5b0e36b68a46cf1665d4a7c8f" translate="yes" xml:space="preserve">
          <source>Fix more problems with rollback. Enhance the test suite to exercise the rollback logic extensively in order to prevent any future problems.</source>
          <target state="translated">ロールバックに関するより多くの問題を修正する。将来の問題を防ぐために、ロールバックロジックを広範囲に実行するためのテストスイートを強化します。</target>
        </trans-unit>
        <trans-unit id="3fb27e5b00960417518969df0f918d06f25d9624" translate="yes" xml:space="preserve">
          <source>Fix multiple bugs that can occur following a malloc() failure.</source>
          <target state="translated">malloc()の失敗後に発生する可能性のある複数のバグを修正。</target>
        </trans-unit>
        <trans-unit id="8252f0ee7c2b56c6e1d2a3ae12fb9ec74fcaf061" translate="yes" xml:space="preserve">
          <source>Fix obscure crash bugs found by &lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;american fuzzy lop&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/a59ae93ee990a55&quot;&gt;a59ae93ee990a55&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;American Fuzzy Lopが&lt;/a&gt;見つけたあいまいなクラッシュバグを修正します。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/a59ae93ee990a55&quot;&gt;a59ae93ee990a55&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="029dc6c7c9dc876556264390601510f43467cb42" translate="yes" xml:space="preserve">
          <source>Fix other minor problems with using small soft heap limits.</source>
          <target state="translated">小さなソフトヒープの制限を使用している場合のその他の小さな問題を修正しました。</target>
        </trans-unit>
        <trans-unit id="2953bbeca888101c80fba41134554ee3b46a5872" translate="yes" xml:space="preserve">
          <source>Fix portability problems for MinGW/MSYS.</source>
          <target state="translated">MinGW/MSYSの移植性の問題を修正。</target>
        </trans-unit>
        <trans-unit id="46269c4cd0e4bb26c3e434c946d6ad61c56e3d22" translate="yes" xml:space="preserve">
          <source>Fix potential corruption in &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt; due to automatic datatype conversions. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/343634942dd54ab&quot;&gt;343634942dd54ab&lt;/a&gt;</source>
          <target state="translated">自動データ型変換による&lt;a href=&quot;expridx&quot;&gt;式のインデックスの&lt;/a&gt;潜在的な破損を修正します。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/343634942dd54ab&quot;&gt;343634942dd54ab&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6e4b60b2ce1e9e806c6a1d1ab2efe5b7b8417ffc" translate="yes" xml:space="preserve">
          <source>Fix problems found on 64-bit systems.</source>
          <target state="translated">64ビットシステムで見つかった問題を修正しました。</target>
        </trans-unit>
        <trans-unit id="07f0a4d00027e8a55978e27f100b7e116a031b97" translate="yes" xml:space="preserve">
          <source>Fix problems with the handling of ORDER BY expressions on compound SELECT statements in subqueries.</source>
          <target state="translated">サブクエリ内の複合SELECT文でのORDER BY式の取り扱いに関する問題を修正しました。</target>
        </trans-unit>
        <trans-unit id="3f1665257f79bd93e546dd7e3d88c5139efb7056" translate="yes" xml:space="preserve">
          <source>Fix rare false-positives in &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; when run on a database connection with &lt;a href=&quot;lang_attach&quot;&gt;attached databases&lt;/a&gt;. Ticket &lt;a href=&quot;https://sqlite.org/src/info/a4e06e75a9ab61a12&quot;&gt;a4e06e75a9ab61a12&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lang_attach&quot;&gt;アタッチさ&lt;/a&gt;れたデータベースとのデータベース接続で実行したときの&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integer_checkの&lt;/a&gt;まれな誤検知を修正しました。チケット&lt;a href=&quot;https://sqlite.org/src/info/a4e06e75a9ab61a12&quot;&gt;a4e06e75a9ab61a12&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="715572171eb76d3d2c9de665f3a896a9b21d3581" translate="yes" xml:space="preserve">
          <source>Fix several important bugs in the new ATTACH and DETACH commands.</source>
          <target state="translated">新しいATTACHコマンドとDETACHコマンドのいくつかの重要なバグを修正しました。</target>
        </trans-unit>
        <trans-unit id="ddb3a4c421a408022b093da748a9383a9c659be4" translate="yes" xml:space="preserve">
          <source>Fix several nuisance bugs.</source>
          <target state="translated">いくつかの迷惑なバグを修正しました。</target>
        </trans-unit>
        <trans-unit id="893a9bc034bf998aa3ff5b40cdc26495f66e42a9" translate="yes" xml:space="preserve">
          <source>Fix table rename feature so that it also updates references to the renamed table in &lt;a href=&quot;lang_createtrigger&quot;&gt;triggers&lt;/a&gt; and &lt;a href=&quot;lang_createview&quot;&gt;views&lt;/a&gt;.</source>
          <target state="translated">テーブルの名前変更機能を修正して、&lt;a href=&quot;lang_createtrigger&quot;&gt;トリガー&lt;/a&gt;と&lt;a href=&quot;lang_createview&quot;&gt;ビューの&lt;/a&gt;名前が変更されたテーブルへの参照も更新するようにします。</target>
        </trans-unit>
        <trans-unit id="6c93787ec12e369e67cea4716187fa506565c4de" translate="yes" xml:space="preserve">
          <source>Fix the &quot;.import&quot; command of the shell so that it ignores \r characters at the end of lines.</source>
          <target state="translated">シェルの&quot;.import &quot;コマンドが行末の\r文字を無視するように修正した。</target>
        </trans-unit>
        <trans-unit id="efa608a017df9d7fa42cace30fce54f90785e7c6" translate="yes" xml:space="preserve">
          <source>Fix the &quot;.read&quot; command in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; so that it understands that its input is not interactive.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;コマンドラインシェル&lt;/a&gt;の「.read」コマンドを修正して、入力がインタラクティブでないことを理解できるようにします。</target>
        </trans-unit>
        <trans-unit id="7dd018e621c55cac03b1d82cf14914c81075f182" translate="yes" xml:space="preserve">
          <source>Fix the --enable-threadsafe option on the configure script</source>
          <target state="translated">configure スクリプトの --enable-threadsafe オプションを修正。</target>
        </trans-unit>
        <trans-unit id="4f27e177384472d9d1a0c017bbab8f18de27d2fa" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;c3ref/db_readonly&quot;&gt;sqlite3_db_readonly()&lt;/a&gt; interface so that it returns true if the database is read-only due to the file format write version number being too large.</source>
          <target state="translated">&lt;a href=&quot;c3ref/db_readonly&quot;&gt;sqlite3_db_readonly（）&lt;/a&gt;インターフェースを修正して、ファイル形式の書き込みバージョン番号が大きすぎるためにデータベースが読み取り専用の場合にtrueを返すようにしてください。</target>
        </trans-unit>
        <trans-unit id="bec6839af346a0afcfd8b6b2618aee85250ace7f" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; interfaces so that they actually do provide a 64-bit answer.</source>
          <target state="translated">&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used（）&lt;/a&gt;および&lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater（）&lt;/a&gt;インターフェースを修正して、実際に64ビットの回答が得られるようにします。</target>
        </trans-unit>
        <trans-unit id="9ba95583c49ccb4f7efb59b2718e52202fa58e8d" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;c3ref/stmt_busy&quot;&gt;sqlite3_stmt_busy()&lt;/a&gt; interface so that it gives the correct answer for &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; statements that have been stepped but never reset.</source>
          <target state="translated">&lt;a href=&quot;c3ref/stmt_busy&quot;&gt;sqlite3_stmt_busy（）&lt;/a&gt;インターフェースを修正して、ステップ実行されたがリセットされなかった&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;ステートメントに対して正しい答えが得られるようにします。</target>
        </trans-unit>
        <trans-unit id="0d8b77554fdfe7204548bebac009120f0ab4ce5d" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; interface so that it is disabled if either the callback or the mask arguments are zero, in accordance with the documentation.</source>
          <target state="translated">ドキュメントに従って、コールバック引数またはマスク引数のいずれかがゼロの場合に無効になるように、&lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2（）&lt;/a&gt;インターフェースを修正します。</target>
        </trans-unit>
        <trans-unit id="956e98f8a5992e566b23150a8321e220d594d919" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt; interface so that it correctly translates content generated by &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob()&lt;/a&gt; into a string of all 0x00 characters. This is a long-standing issue discovered after the 3.16.1 release by &lt;a href=&quot;https://github.com/google/oss-fuzz&quot;&gt;OSS-Fuzz&lt;/a&gt;</source>
          <target state="translated">修正&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_text（）&lt;/a&gt;が正しくによって生成されたコンテンツ変換できるようインターフェイスを&lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;（）zeroblobを&lt;/a&gt;すべて0x00文字の文字列に。これは、&lt;a href=&quot;https://github.com/google/oss-fuzz&quot;&gt;OSS-Fuzzに&lt;/a&gt;よる3.16.1リリース後に発見された長期にわたる問題です。</target>
        </trans-unit>
        <trans-unit id="56c77cb746417e9f9c249b6c4c57b8b0bd6b303c" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; so that it builds with -DSQLITE_UNTESTABLE</source>
          <target state="translated">-DSQLITE_UNTESTABLEでビルドするように&lt;a href=&quot;cli&quot;&gt;CLIを&lt;/a&gt;修正します</target>
        </trans-unit>
        <trans-unit id="2ac07a1bdc161b16f3469a85c1d0b7329721b6d7" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;cli#fileio&quot;&gt;readfile()&lt;/a&gt; function so that it returns an empty BLOB rather than throwing an out-of-memory error when reading an empty file.</source>
          <target state="translated">空のファイルを読み取るときにメモリ不足エラーをスローするのではなく、空のBLOBを返すように&lt;a href=&quot;cli#fileio&quot;&gt;readfile（）&lt;/a&gt;関数を修正します。</target>
        </trans-unit>
        <trans-unit id="403d90d10026656bd2341e3610eb64ec19d4191d" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;cli#fileio&quot;&gt;writefile()&lt;/a&gt; function so that when it creates new directories along the path of a new file, it gives them umask permissions rather than the same permissions as the file.</source>
          <target state="translated">新しいファイルのパスに沿って新しいディレクトリを作成するときに、ファイルと同じアクセス許可ではなくumaskアクセス許可を与えるように、&lt;a href=&quot;cli#fileio&quot;&gt;writefile（）&lt;/a&gt;関数を修正します。</target>
        </trans-unit>
        <trans-unit id="c637b1ba45c5e9182867d4d4a220fb33c1f49c9d" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/eval.c&quot;&gt;eval.c&lt;/a&gt; extension so that it works with &lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt;PRAGMA empty_result_callbacks=ON&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/eval.c&quot;&gt;eval.c&lt;/a&gt;拡張子を修正して、&lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt;PRAGMA empty_result_callbacks = ON&lt;/a&gt;で動作するようにします。</target>
        </trans-unit>
        <trans-unit id="742c65bbfe2ba6c5ffb22d31b0549c4b28db3ce5" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;json1#jeach&quot;&gt;json_each()&lt;/a&gt; function so that it returns valid results on its &quot;fullkey&quot; column when the input is a simple value rather than an array or object.</source>
          <target state="translated">&lt;a href=&quot;json1#jeach&quot;&gt;json_each（）&lt;/a&gt;関数を修正して、入力が配列やオブジェクトではなく単純な値である場合に「fullkey」列に有効な結果が返されるようにします。</target>
        </trans-unit>
        <trans-unit id="6faddebbbfb3cf6bd640c7723cc149f43cca6d2e" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command so that it does not corrupt &lt;a href=&quot;lang_createindex#descidx&quot;&gt;descending indexes&lt;/a&gt; when adding a column to a &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy file format&lt;/a&gt; database. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f68bf68513a1c15f&quot;&gt;f68bf68513a1c15f&lt;/a&gt;</source>
          <target state="translated">列を&lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;レガシーファイル形式の&lt;/a&gt;データベースに追加するときに&lt;a href=&quot;lang_createindex#descidx&quot;&gt;降順インデックスが&lt;/a&gt;破損しないように、&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;コマンドを修正します。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/f68bf68513a1c15f&quot;&gt;f68bf68513a1c15f&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="02f53a9fc9d770e6300288b8428f8e92433fe895" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_altertable#altertabmvcol&quot;&gt;ALTER TABLE RENAME COLUMN&lt;/a&gt; command so that it works for tables that have redundant UNIQUE constraints. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/bc8d94f0fbd633fd9a&quot;&gt;bc8d94f0fbd633fd9a&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lang_altertable#altertabmvcol&quot;&gt;ALTER TABLE RENAME COLUMN&lt;/a&gt;コマンドを修正して、冗長なUNIQUE制約を持つテーブルで機能するようにします。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/bc8d94f0fbd633fd9a&quot;&gt;bc8d94f0fbd633fd9a&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="97c52dd1e73a0efdc1a5a635f402eb42bf6e057e" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command so that it adds correct samples for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables in the &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; table. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/b2fa5424e6fcb15&quot;&gt;b2fa5424e6fcb15&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;コマンドを修正して、&lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt;テーブルに&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルの正しいサンプルを追加します。チケット&lt;a href=&quot;http://www.sqlite.org/src/info/b2fa5424e6fcb15&quot;&gt;b2fa5424e6fcb15&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8d872c8e6bb3c85572831647367d9180d6f56948" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command so that it computes statistics on tables whose names begin with &quot;sqlite&quot;. Check-in &lt;a href=&quot;https://sqlite.org/src/info/0249d9aecf69948d&quot;&gt;0249d9aecf69948d&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;コマンドを修正して、名前が「sqlite」で始まるテーブルの統計を計算するようにします。チェックイン&lt;a href=&quot;https://sqlite.org/src/info/0249d9aecf69948d&quot;&gt;0249d9aecf69948d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bc9460bbb01c2af9870b809ff07c3b2b7356fe99" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; command so that it is no longer able to sneak a NULL value into a NOT NULL column even if the NOT NULL column has a default value of NULL. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/e6f1f2e34dceeb1ed6&quot;&gt;e6f1f2e34dceeb1ed6&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt;コマンドを修正して、NOT NULL列のデフォルト値がNULLであっても、NULL値をNOT NULL列にこっそり入れられないようにします。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/e6f1f2e34dceeb1ed6&quot;&gt;e6f1f2e34dceeb1ed6&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0d54e2533360cb4659b717a0226d2d7a1dbf1bbf" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; statement for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables that lack secondary indexes so that it works correctly with triggers and foreign keys. This was a new bug caused by performance optimizations added in version 3.16.0. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/30027b613b4&quot;&gt;30027b613b4&lt;/a&gt;</source>
          <target state="translated">トリガーと外部キーで正しく機能するように、セカンダリインデックスのない&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルの&lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt;ステートメントを修正します。これは、バージョン3.16.0で追加されたパフォーマンス最適化によって引き起こされる新しいバグでした。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/30027b613b4&quot;&gt;30027b613b4&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d509397fe960e4575a2e26f651dde6ff90b84a19" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command so that it spills excess content to disk rather than holding everything in memory, and possible causing an out-of-memory error for larger database files. This fixes an issue introduced by version 3.15.0.</source>
          <target state="translated">&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;コマンドを修正して、メモリにすべてを保持するのではなく、ディスクに過剰なコンテンツをこぼし、大きなデータベースファイルでメモリ不足エラーが発生する可能性があるようにします。これにより、バージョン3.15.0で導入された問題が修正されます。</target>
        </trans-unit>
        <trans-unit id="b036730fcf1ecafecf0573d1d74619be57162b96" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;optoverview#flattening&quot;&gt;query flattener&lt;/a&gt; so that it works on queries that contain subqueries that use &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f09fcd17810f65f717&quot;&gt;709fcd17810f65f717&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;windowfunctions&quot;&gt;ウィンドウ関数&lt;/a&gt;を使用するサブクエリを含むクエリで機能するように、&lt;a href=&quot;optoverview#flattening&quot;&gt;クエリフラット&lt;/a&gt;ナを修正します。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/f09fcd17810f65f717&quot;&gt;709fcd17810f65f717&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7a295aba8a2bc4b671641db0bf3a60e0d6006706" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt; so that it always ignores subplans that do not use an index.</source>
          <target state="translated">&lt;a href=&quot;optoverview#or_opt&quot;&gt;OR最適化を&lt;/a&gt;修正して、インデックスを使用しないサブプランを常に無視するようにします。</target>
        </trans-unit>
        <trans-unit id="69a683f5bb13785c6e99f6455ca83c519f9c2e7d" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt; so that it works correctly when the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt; is used on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/8fd39115d8f46&quot;&gt;8fd39115d8f46&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;optoverview#or_opt&quot;&gt;OR最適化&lt;/a&gt;が&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルで使用されているときに正しく機能するように、&lt;a href=&quot;optoverview#skipscan&quot;&gt;スキップスキャン最適化を&lt;/a&gt;修正します。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/8fd39115d8f46&quot;&gt;8fd39115d8f46&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d64c703876098dc69084f33c7133d65be1531802" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; command so that it works correctly with foreign keys on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt;コマンドを修正して、&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルの外部キーで正しく機能するようにします。</target>
        </trans-unit>
        <trans-unit id="0d608a4f7657ad4f577e7889d266b51e07ca7fe6" translate="yes" xml:space="preserve">
          <source>Fix the &lt;a href=&quot;series&quot;&gt;generate_series&lt;/a&gt; virtual table so that it correctly returns no rows if any of its constraints are NULL.</source>
          <target state="translated">制約のいずれかがNULLの場合に行が正しく返されないように、&lt;a href=&quot;series&quot;&gt;generate_series&lt;/a&gt;仮想テーブルを修正します。</target>
        </trans-unit>
        <trans-unit id="16b43b19be563d99895b6b7aa73c97080f1c15c0" translate="yes" xml:space="preserve">
          <source>Fix the REPLACE() function so that it returns NULL if the second argument is an empty string. Ticket #2324.</source>
          <target state="translated">REPLACE()関数の第2引数が空文字列の場合にNULLを返すように修正。チケット#2324。</target>
        </trans-unit>
        <trans-unit id="b71b83145fe1ea70f5f98014557a62cf7f2c2ec4" translate="yes" xml:space="preserve">
          <source>Fix the TCL interface so that the &quot;nullvalue&quot; setting is honored for TCL implementations of SQL functions.</source>
          <target state="translated">SQL関数のTCL実装で &quot;nullvalue &quot;設定が優先されるように、TCLインタフェースを修正しました。</target>
        </trans-unit>
        <trans-unit id="681e860e148ced87ec9dd7b3cfb9b43a75c2065d" translate="yes" xml:space="preserve">
          <source>Fix the behavior of &lt;a href=&quot;c3ref/column_name&quot;&gt;sqlite3_column_name()&lt;/a&gt; for queries that use the &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt; so that the result is consistent with other queries that do not use that optimization, and with PostgreSQL, MySQL, and SQLServer. Ticket &lt;a href=&quot;https://sqlite.org/src/info/de3403bf5ae&quot;&gt;de3403bf5ae&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;optoverview#flattening&quot;&gt;フラット化最適化&lt;/a&gt;を使用するクエリの&lt;a href=&quot;c3ref/column_name&quot;&gt;sqlite3_column_name（）の&lt;/a&gt;動作を修正して、その最適化を使用しない他のクエリ、およびPostgreSQL、MySQL、SQLServerと結果が一致するようにします。チケット&lt;a href=&quot;https://sqlite.org/src/info/de3403bf5ae&quot;&gt;de3403bf5ae&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e2fb92f8546f34175b1dda79777c363dd68d103" translate="yes" xml:space="preserve">
          <source>Fix the behavior of comparison operators (ex: &quot;&lt;b&gt;&amp;amp;lt&lt;/b&gt;&quot;, &quot;&lt;b&gt;==&lt;/b&gt;&quot;, etc.) so that they are consistent with the order of entries in an index.</source>
          <target state="translated">比較演算子（例： &quot; &lt;b&gt;＆lt&lt;/b&gt; &quot;、 &quot; &lt;b&gt;==&lt;/b&gt; &quot;など）の動作を修正して、インデックス内のエントリの順序と一致するようにします。</target>
        </trans-unit>
        <trans-unit id="a6cdb1736bb68b0b3c4ede9fdba04199758b7855" translate="yes" xml:space="preserve">
          <source>Fix the behavior of comparison operators (ex: &quot;&lt;b&gt;&amp;lt;&lt;/b&gt;&quot;, &quot;&lt;b&gt;==&lt;/b&gt;&quot;, etc.) so that they are consistent with the order of entries in an index.</source>
          <target state="translated">Fix the behavior of comparison operators (ex: &quot;&lt;b&gt;&amp;lt;&lt;/b&gt;&quot;, &quot;&lt;b&gt;==&lt;/b&gt;&quot;, etc.) so that they are consistent with the order of entries in an index.</target>
        </trans-unit>
        <trans-unit id="6a8e8cd65707752281f4a6188d7da381520e451a" translate="yes" xml:space="preserve">
          <source>Fix the behavior of typeof() and length() on virtual tables. Ticket &lt;a href=&quot;https://sqlite.org/src/info/69d642332d25aa3b7315a6d385&quot;&gt;69d642332d25aa3b7315a6d385&lt;/a&gt;</source>
          <target state="translated">仮想テーブルでのtypeof（）およびlength（）の動作を修正しました。チケット&lt;a href=&quot;https://sqlite.org/src/info/69d642332d25aa3b7315a6d385&quot;&gt;69d642332d25aa3b7315a6d385&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="df05e2dc4f6d16d80624e7984c8465e501af7d3b" translate="yes" xml:space="preserve">
          <source>Fix the build so that it works with -DSQLITE_OMIT_WAL.</source>
          <target state="translated">DSQLITE_OMIT_WALで動作するようにビルドを修正。</target>
        </trans-unit>
        <trans-unit id="2766a0c67ddd6ed7f5aaccb304bc1ba6ad153261" translate="yes" xml:space="preserve">
          <source>Fix the built-in printf logic so that it prints &quot;NaN&quot; not &quot;Inf&quot; for floating-point NaNs. Ticket #2345</source>
          <target state="translated">組み込みのprintfロジックを修正し、浮動小数点のNaNに対しては &quot;Inf &quot;ではなく &quot;NaN &quot;を出力するようにしました。チケット #2345</target>
        </trans-unit>
        <trans-unit id="5bfcd9ce8f5df54205f92dd3b6c0521e656224b0" translate="yes" xml:space="preserve">
          <source>Fix the bytecode generator to deal with a subquery in the FROM clause that is itself a UNION ALL where one side of the UNION ALL is a view that contains an ORDER BY. This is a long-standing issue that was discovered after the release of 3.16.1. See ticket &lt;a href=&quot;https://www.sqlite.org/src/info/190c2507&quot;&gt;190c2507&lt;/a&gt;.</source>
          <target state="translated">それ自体がUNION ALLであるFROM句のサブクエリを処理するようにバイトコードジェネレータを修正します。UNIONALLの片側はORDER BYを含むビューです。これは、3.16.1のリリース後に発見された長期にわたる問題です。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/190c2507&quot;&gt;190c2507を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d203309fb6041974c7687fc93bbf99d6e93873bc" translate="yes" xml:space="preserve">
          <source>Fix the code generator for expressions of the form &quot;x IN (SELECT...)&quot; where the SELECT statement on the RHS is a correlated subquery. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/5e3c886796e5512e&quot;&gt;5e3c886796e5512e&lt;/a&gt;.</source>
          <target state="translated">RHSのSELECTステートメントが相関サブクエリである &quot;x IN（SELECT ...）&quot;形式の式のコードジェネレーターを修正します。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/5e3c886796e5512e&quot;&gt;5e3c886796e5512e&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="13a43d34f4444938ebdb413873a4acf48769174e" translate="yes" xml:space="preserve">
          <source>Fix the configure script for the amalgamation so that the --readline option works again on Raspberry PIs.</source>
          <target state="translated">Raspberry PI で --readline オプションが再び動作するように、アマルガム化のための configure スクリプトを修正した。</target>
        </trans-unit>
        <trans-unit id="0dffaab8602b04f745c3456ad0e79054b8bf2a09" translate="yes" xml:space="preserve">
          <source>Fix the function prototype for the open(2) system call to agree with POSIX. Without this fix, pthreads does not work correctly on NetBSD.</source>
          <target state="translated">open(2)システムコールのための関数プロトタイプを POSIX と一致するように修正。この修正がないと、NetBSD 上で pthreads が正しく動作しません。</target>
        </trans-unit>
        <trans-unit id="0cdcb447680d92da840bf449347a30236662eba4" translate="yes" xml:space="preserve">
          <source>Fix the locking mechanism yet again to prevent &lt;b&gt;sqlite_exec()&lt;/b&gt; from returning SQLITE_PROTOCOL unnecessarily. This time the bug was a race condition in the locking code. This change affects both POSIX and Windows users.</source>
          <target state="translated">&lt;b&gt;sqlite_exec（）&lt;/b&gt;が不必要にSQLITE_PROTOCOLを返さないように、ロックメカニズムをもう一度修正します。今回のバグは、ロックコードの競合状態でした。この変更は、POSIXとWindowsの両方のユーザーに影響します。</target>
        </trans-unit>
        <trans-unit id="007c6c873e32f4b431e8ac6f01127288ee55c964" translate="yes" xml:space="preserve">
          <source>Fix the min() and max() optimizer so that it works when the FROM clause consists of a subquery.</source>
          <target state="translated">min()およびmax()オプティマイザを修正し、FROM句が副問い合わせで構成されている場合に動作するようにしました。</target>
        </trans-unit>
        <trans-unit id="b12f6e9f1f8f67709743497fbebb71ef8c53459f" translate="yes" xml:space="preserve">
          <source>Fix the parser to accept valid &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; syntax. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/7310e2fb3d046a5&quot;&gt;7310e2fb3d046a5&lt;/a&gt;</source>
          <target state="translated">有効な&lt;a href=&quot;rowvalue&quot;&gt;行値&lt;/a&gt;構文を受け入れるようにパーサーを修正してください。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/7310e2fb3d046a5&quot;&gt;7310e2fb3d046a5&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="13f421298ab97922575edd88af10f5d60d0152b2" translate="yes" xml:space="preserve">
          <source>Fix the query optimizer to correctly handle constant expressions in the ON clause of a LEFT JOIN. Ticket #2403</source>
          <target state="translated">クエリオプティマイザがLEFT JOINのON句の定数式を正しく処理するように修正しました。チケット #2403</target>
        </trans-unit>
        <trans-unit id="40584ba785f1b7ac57821c3d2f85216f2b32614c" translate="yes" xml:space="preserve">
          <source>Fix the query optimizer to handle rowid comparisons to NULL correctly. Ticket #2404</source>
          <target state="translated">クエリオプティマイザが行IDのNULLへの比較を正しく処理するように修正しました。チケット #2404</target>
        </trans-unit>
        <trans-unit id="dfa9a47acf25a2f05ea48c9410e4c4747561d320" translate="yes" xml:space="preserve">
          <source>Fix the query planner so that IS and IS NULL operators are able to drive an index on a LEFT OUTER JOIN.</source>
          <target state="translated">クエリプランナを修正し、ISおよびIS NULL演算子がLEFT OUTER JOINでインデックスを駆動できるようにしました。</target>
        </trans-unit>
        <trans-unit id="5653a698bc06b9d4be42b0c1c2f59e7a1e2b1d3a" translate="yes" xml:space="preserve">
          <source>Fix the query planner so that it knows not to use &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexes&lt;/a&gt; on the right table of LEFT JOIN if the WHERE clause uses the &lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS operator&lt;/a&gt;. Fix for &lt;a href=&quot;https://sqlite.org/src/info/ce68383bf6aba&quot;&gt;ce68383bf6aba&lt;/a&gt;.</source>
          <target state="translated">WHERE句で&lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS演算子が&lt;/a&gt;使用されている場合に、LEFT JOINの右側のテーブルで&lt;a href=&quot;optoverview#autoindex&quot;&gt;自動インデックス&lt;/a&gt;を使用しないように、クエリプランナーを修正します。&lt;a href=&quot;https://sqlite.org/src/info/ce68383bf6aba&quot;&gt;ce68383bf6abaの&lt;/a&gt;修正。</target>
        </trans-unit>
        <trans-unit id="f099fcbe9d8c0841133d0c1acb48be9e9aec8aff" translate="yes" xml:space="preserve">
          <source>Fix the query planner so that it takes into account dependencies in the arguments to table-valued functions in subexpressions in the WHERE clause. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/80177f0c226ff54&quot;&gt;80177f0c226ff54&lt;/a&gt;</source>
          <target state="translated">クエリプランナーを修正して、WHERE句のサブ式のテーブル値関数への引数の依存関係を考慮に入れます。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/80177f0c226ff54&quot;&gt;80177f0c226ff54&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c51036bc7729aa3fd5a9f1ed633c206de4f498ea" translate="yes" xml:space="preserve">
          <source>Fix the query planner so that it works correctly for IS NOT NULL operators in the ON clause of a LEFT JOIN with the SQLITE_ENABLE_STAT4 compile-time option. &lt;a href=&quot;https://sqlite.org/src/info/65eb38f6e46de8c75e188a17ec&quot;&gt;65eb38f6e46de8c75e188a17ec&lt;/a&gt;</source>
          <target state="translated">クエリプランナーを修正して、SQLITE_ENABLE_STAT4コンパイル時オプションを指定したLEFT JOINのON句のIS NOT NULL演算子に対して正しく機能するようにします。&lt;a href=&quot;https://sqlite.org/src/info/65eb38f6e46de8c75e188a17ec&quot;&gt;65eb38f6e46de8c75e188a17ec&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2e67f4820003d691c4c8b5a0ce32d382b50cc512" translate="yes" xml:space="preserve">
          <source>Fix the regression test suite so that it works with Tcl8.5</source>
          <target state="translated">Tcl8.5で動作するようにリグレッションテストスイートを修正</target>
        </trans-unit>
        <trans-unit id="6d468d38a1ed912125e5b1192b25781bdc29bb56" translate="yes" xml:space="preserve">
          <source>Fix the schema parser so that it interprets certain (obscure and ill-formed) CREATE TABLE statements the same as legacy. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/ac661962a2aeab3c331&quot;&gt;ac661962a2aeab3c331&lt;/a&gt;</source>
          <target state="translated">スキーマパーサーを修正して、特定の（あいまいで不正な形式の）CREATE TABLEステートメントをレガシーと同じように解釈するようにします。チケット&lt;a href=&quot;https://www.sqlite.org/src/info/ac661962a2aeab3c331&quot;&gt;ac661962a2aeab3c331の&lt;/a&gt;修正</target>
        </trans-unit>
        <trans-unit id="29c5cfa4d69ee4c85bc560fdea69b6008202a144" translate="yes" xml:space="preserve">
          <source>Fix to UPDATE triggers on TEMP tables.</source>
          <target state="translated">TEMPテーブルのUPDATEトリガを修正。</target>
        </trans-unit>
        <trans-unit id="8ac8e543b0bc738b6dc67d65d9b587bde27a9189" translate="yes" xml:space="preserve">
          <source>Fix to the --rbu option of &lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt;.</source>
          <target state="translated">sqldiffの--rbuオプションを&lt;a href=&quot;sqldiff&quot;&gt;修正&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dce0daf2e8b6a6a74ce23add5bf251c814f89da9" translate="yes" xml:space="preserve">
          <source>Fix two bugs in the locking protocol. (One was masking the other.)</source>
          <target state="translated">ロックプロトコルの2つのバグを修正しました。(1つはもう1つをマスクしていました)</target>
        </trans-unit>
        <trans-unit id="140466bf745b30af0254a8472b1f139b069fbb53" translate="yes" xml:space="preserve">
          <source>Fix two bugs, which when combined might result in incorrect query results. Both bugs were harmless by themselves; only when they team up do they cause problems. Ticket #3581.</source>
          <target state="translated">2つのバグを修正しました。どちらのバグもそれ自体は無害でしたが、それらが組み合わさったときだけ問題が発生するようになりました。チケット#3581。</target>
        </trans-unit>
        <trans-unit id="e9669895532c079b8fe44ba1553500c34f15f036" translate="yes" xml:space="preserve">
          <source>Fix two long-standing bugs that allow malicious SQL statements to crash the process that is running SQLite. These bugs were announced by a third-party approximately 24 hours after the 3.32.0 release but are not specific to the 3.32.0 release.</source>
          <target state="translated">悪意のあるSQL文がSQLiteを実行しているプロセスをクラッシュさせることができる2つの長年のバグを修正しました。これらのバグは3.32.0リリースから約24時間後にサードパーティから発表されたものですが、3.32.0リリース特有のものではありません。</target>
        </trans-unit>
        <trans-unit id="c6b3c2eac5340186aa60ec6ef1bd320d9af1b4cf" translate="yes" xml:space="preserve">
          <source>Fix two problems in the new &lt;a href=&quot;optoverview#leftjoinreduction&quot;&gt;LEFT JOIN strength reduction optimization&lt;/a&gt;. Tickets &lt;a href=&quot;https://sqlite.org/src/info/1e39b966ae9ee739&quot;&gt;1e39b966ae9ee739&lt;/a&gt; and &lt;a href=&quot;https://sqlite.org/src/info/fac496b61722daf2&quot;&gt;fac496b61722daf2&lt;/a&gt;.</source>
          <target state="translated">新しい&lt;a href=&quot;optoverview#leftjoinreduction&quot;&gt;LEFT JOIN強度削減最適化の&lt;/a&gt; 2つの問題を修正します。チケット&lt;a href=&quot;https://sqlite.org/src/info/1e39b966ae9ee739&quot;&gt;1e39b966ae9ee739&lt;/a&gt;および&lt;a href=&quot;https://sqlite.org/src/info/fac496b61722daf2&quot;&gt;fac496b61722daf2&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce60dbf83ec6124a3874f74bb112313a53e7aca8" translate="yes" xml:space="preserve">
          <source>Fix type coercion rules for the IN operator</source>
          <target state="translated">IN演算子の型強制ルールの修正</target>
        </trans-unit>
        <trans-unit id="1ef59214b1b8979108ab36722686dbe71717d826" translate="yes" xml:space="preserve">
          <source>Fix typos in documentation.</source>
          <target state="translated">ドキュメントのタイプミスを修正。</target>
        </trans-unit>
        <trans-unit id="c5df6889e7873170528ac5b7149060416fb8a48c" translate="yes" xml:space="preserve">
          <source>Fix typos in the documentation</source>
          <target state="translated">ドキュメントのタイプミスを修正</target>
        </trans-unit>
        <trans-unit id="a8caeeab6423273de2d0f3b9037854eda089993c" translate="yes" xml:space="preserve">
          <source>Fix uninitialized variables causing malfunctions for various obscure queries</source>
          <target state="translated">初期化されていない変数が、さまざまな不明瞭なクエリの誤動作の原因となっていたのを修正</target>
        </trans-unit>
        <trans-unit id="334faf48b2d08d39ac3f83df69ba4313064d2eca" translate="yes" xml:space="preserve">
          <source>Fix various documentation typos</source>
          <target state="translated">様々なドキュメントのタイプミスを修正</target>
        </trans-unit>
        <trans-unit id="bfc06020350fd18063be73e1e193870b6478ef89" translate="yes" xml:space="preserve">
          <source>Fix various other minor test script problems.</source>
          <target state="translated">その他、様々なマイナーなテストスクリプトの問題を修正しました。</target>
        </trans-unit>
        <trans-unit id="04a80b08dce7f337318b3de8005ba6821f9088b9" translate="yes" xml:space="preserve">
          <source>Fix warning messages in VC++ 7.0. (Patches from nicolas352001)</source>
          <target state="translated">VC++7.0の警告メッセージを修正。(nicolas352001 からのパッチ)</target>
        </trans-unit>
        <trans-unit id="e356e2b704a2e01de653ed2ebbf706f69ff2717e" translate="yes" xml:space="preserve">
          <source>Fixed &lt;b&gt;sqlite.h&lt;/b&gt; so that it is usable from C++</source>
          <target state="translated">C ++から使用できるように&lt;b&gt;sqlite.hを&lt;/b&gt;修正</target>
        </trans-unit>
        <trans-unit id="79e373e30e82498299cb604bd835209f11c2361f" translate="yes" xml:space="preserve">
          <source>Fixed a bug in the &quot;copy&quot; method of the TCL interface.</source>
          <target state="translated">TCLインターフェースの &quot;copy &quot;メソッドのバグを修正しました。</target>
        </trans-unit>
        <trans-unit id="c148872cc8b9ab806e9be600a6bc5019b39f4b73" translate="yes" xml:space="preserve">
          <source>Fixed a bug in the processing of LEFT OUTER JOIN</source>
          <target state="translated">LEFT OUTER JOINの処理のバグを修正しました。</target>
        </trans-unit>
        <trans-unit id="8958f58770783b2b2d9b98f41e760b01637c6fbf" translate="yes" xml:space="preserve">
          <source>Fixed a bug in the query planner that caused performance regressions relative to 3.6.23.1 on some complex joins.</source>
          <target state="translated">クエリプランナのバグを修正し、複雑な結合で3.6.23.1との相対的なパフォーマンスの低下を引き起こしていた問題を修正しました。</target>
        </trans-unit>
        <trans-unit id="ce57a2f7dac9c404f24a8b0780affccd90fd36f4" translate="yes" xml:space="preserve">
          <source>Fixed a bug that caused database corruption when an &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; is rolled back in an in-memory database. Ticket #3761.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt;がメモリ内データベースでロールバックされたときにデータベースの破損を引き起こしたバグを修正しました。チケット＃3761。</target>
        </trans-unit>
        <trans-unit id="47075269c498ed42295ff1e4b7548fb034943cbd" translate="yes" xml:space="preserve">
          <source>Fixed a bug that was causing updates to fail inside of transactions when the database contained a temporary table.</source>
          <target state="translated">データベースに一時的なテーブルが含まれている場合に、トランザクション内で更新が失敗する原因となっていたバグを修正しました。</target>
        </trans-unit>
        <trans-unit id="479bbff8b43af13fac5ef791395960b4f803b850" translate="yes" xml:space="preserve">
          <source>Fixed a critical bug in the &lt;a href=&quot;https://www.sqlite.org/see/doc/trunk/www/readme.wiki&quot;&gt;SQLite Encryption Extension&lt;/a&gt; that could cause the database to become unreadable and unrecoverable if a &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command changed the size of the encryption nonce.</source>
          <target state="translated">&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;コマンドが暗号化ナンスのサイズを変更した場合にデータベースが読み取り不能になり回復不能になる可能性がある&lt;a href=&quot;https://www.sqlite.org/see/doc/trunk/www/readme.wiki&quot;&gt;SQLite暗号化拡張機能の&lt;/a&gt;重大なバグを修正しました。</target>
        </trans-unit>
        <trans-unit id="59729403a0ff39e62d5592f59ad0496bc74d3cb0" translate="yes" xml:space="preserve">
          <source>Fixed a typo in the OS/2 backend.</source>
          <target state="translated">OS/2バックエンドの誤字を修正しました。</target>
        </trans-unit>
        <trans-unit id="639269284376af975435d947ede551d59f7c8a90" translate="yes" xml:space="preserve">
          <source>Fixed an off-by-one error that was causing a coredump in the '%q' format directive of the new &lt;b&gt;sqlite_..._printf()&lt;/b&gt; routines.</source>
          <target state="translated">新しい&lt;b&gt;sqlite _..._ printf（）&lt;/b&gt;ルーチンの '％q'形式ディレクティブでコアダンプを引き起こしていた1つずれたエラーを修正しました。</target>
        </trans-unit>
        <trans-unit id="2f93f642c24bc3ca9d72401aa0c30d511f868145" translate="yes" xml:space="preserve">
          <source>Fixed lots of spelling errors in the source-code comments</source>
          <target state="translated">ソースコードコメントのスペルミスを多数修正</target>
        </trans-unit>
        <trans-unit id="fd59e954365ccfc713ffa89ef7eee7b8910b50c3" translate="yes" xml:space="preserve">
          <source>Fixed naming conflicts so that versions 2.8 and 3.0 can be linked and used together in the same ANSI-C source file.</source>
          <target state="translated">バージョン2.8と3.0の名前の競合を修正し、同じANSI-Cソースファイル内でバージョン2.8と3.0をリンクして一緒に使用できるようにしました。</target>
        </trans-unit>
        <trans-unit id="8dc0276046c4c36ea547c5cf770bbba66b28361f" translate="yes" xml:space="preserve">
          <source>Fixed performance problems and potential stack overflows when creating &lt;a href=&quot;lang_createview&quot;&gt;views&lt;/a&gt; from multi-row VALUES clauses with hundreds of thousands of rows.</source>
          <target state="translated">数十万行の複数行VALUES句から&lt;a href=&quot;lang_createview&quot;&gt;ビュー&lt;/a&gt;を作成するときのパフォーマンスの問題と潜在的なスタックオーバーフローを修正しました。</target>
        </trans-unit>
        <trans-unit id="48a5b411b131a16a7c3a81ff9ffe341d205ab7e3" translate="yes" xml:space="preserve">
          <source>Fixed some instances where &lt;b&gt;sqlite_exec()&lt;/b&gt; was returning the wrong error code.</source>
          <target state="translated">&lt;b&gt;sqlite_exec（）&lt;/b&gt;が誤ったエラーコードを返すいくつかのインスタンスを修正しました。</target>
        </trans-unit>
        <trans-unit id="d2abd59d7529d7221419b75d94eed0ee9277c4cd" translate="yes" xml:space="preserve">
          <source>Fixed the &quot;.dump&quot; command in the command-line shell to show indices, triggers and views again.</source>
          <target state="translated">コマンドラインシェルの&quot;.dump &quot;コマンドで、インデックス、トリガー、ビューを再び表示するように修正しました。</target>
        </trans-unit>
        <trans-unit id="923cc8fbcaf6842679b5f1e15d6df83e508e85ec" translate="yes" xml:space="preserve">
          <source>Fixed the &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt; so that &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; and &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interfaces and the &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes pragma&lt;/a&gt; return the correct values.</source>
          <target state="translated">&lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes（）&lt;/a&gt;および&lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes（）&lt;/a&gt;インターフェースと&lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changesプラグマ&lt;/a&gt;が正しい値を返すように、&lt;a href=&quot;lang_delete#truncateopt&quot;&gt;トランケートの最適化を&lt;/a&gt;修正しました。</target>
        </trans-unit>
        <trans-unit id="9e28c4773e158241fde9583f9f170c5ef9db0282" translate="yes" xml:space="preserve">
          <source>Fixed the operator precedence for the ~ operator.</source>
          <target state="translated">演算子 ~ 演算子の優先順位を修正しました。</target>
        </trans-unit>
        <trans-unit id="7effc13b7d809cd0670d65239ee3df045defba54" translate="yes" xml:space="preserve">
          <source>Fixes for various minor bugs.</source>
          <target state="translated">様々なマイナーなバグを修正しました。</target>
        </trans-unit>
        <trans-unit id="6db891bdea0dad81fb2181f92e7eface672bbf02" translate="yes" xml:space="preserve">
          <source>Fixes for various other compiler warnings and minor problems associated with obscure configurations.</source>
          <target state="translated">他の様々なコンパイラの警告や、不明瞭な設定に関連したマイナーな問題を修正しました。</target>
        </trans-unit>
        <trans-unit id="2582d7cc3520de6113cfebc05a4c0c40c10d2aea" translate="yes" xml:space="preserve">
          <source>Fixes to the rollback and locking behavior</source>
          <target state="translated">ロールバックとロックの動作を修正</target>
        </trans-unit>
        <trans-unit id="300a0178f58415dda787e9c4b1d46e58f9cdc26d" translate="yes" xml:space="preserve">
          <source>FkCounter</source>
          <target state="translated">FkCounter</target>
        </trans-unit>
        <trans-unit id="a7826ae0da180dcf999c042085ef7ac58cfd77ff" translate="yes" xml:space="preserve">
          <source>FkIfZero</source>
          <target state="translated">FkIfZero</target>
        </trans-unit>
        <trans-unit id="a774409a00c21de377cf8ed5c6a56b8547973042" translate="yes" xml:space="preserve">
          <source>Flag</source>
          <target state="translated">Flag</target>
        </trans-unit>
        <trans-unit id="502eddf598188b96c0b40f89e8492bff9de3fa43" translate="yes" xml:space="preserve">
          <source>Flags For File Open Operations</source>
          <target state="translated">ファイルを開く操作のフラグ</target>
        </trans-unit>
        <trans-unit id="9e0bdeb766ef28db46f01b095bdb326b4da9f972" translate="yes" xml:space="preserve">
          <source>Flags consist of zero or more characters that immediately follow the &quot;%&quot; that introduces the substitution. The various flags and their meanings are as follows:</source>
          <target state="translated">フラグは、置換を導入する&quot;%&quot;の直後に続く0文字以上の文字で構成されています。様々なフラグとその意味は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="e52973142fb5309e0599d0aece55b28093c55ec5" translate="yes" xml:space="preserve">
          <source>Flags for sqlite3_deserialize()</source>
          <target state="translated">sqlite3_deserialize()のフラグ</target>
        </trans-unit>
        <trans-unit id="763319af81f124ab801773d718a34a5b48132717" translate="yes" xml:space="preserve">
          <source>Flags for sqlite3_serialize</source>
          <target state="translated">sqlite3_serializeのフラグ</target>
        </trans-unit>
        <trans-unit id="f15088d96e03c231ed7711a618b87a23e40d38d1" translate="yes" xml:space="preserve">
          <source>Flags for sqlite3changeset_apply_v2</source>
          <target state="translated">sqlite3changeset_apply_v2のフラグ</target>
        </trans-unit>
        <trans-unit id="9c6b7b2401c21ffe043e97decac28ab2c77bcf8f" translate="yes" xml:space="preserve">
          <source>Flags for sqlite3changeset_start_v2</source>
          <target state="translated">sqlite3changeset_start_v2のフラグ</target>
        </trans-unit>
        <trans-unit id="8565c5e3d19dd91c15d8aea38675feb62cbfe94b" translate="yes" xml:space="preserve">
          <source>Flags for the xAccess VFS method</source>
          <target state="translated">xAccess VFS メソッドのフラグ</target>
        </trans-unit>
        <trans-unit id="caa91d141d9230cced8ac027e0837943663b4e27" translate="yes" xml:space="preserve">
          <source>Flags for the xShmLock VFS method</source>
          <target state="translated">xShmLock VFS メソッドのフラグ</target>
        </trans-unit>
        <trans-unit id="a4c5b52302ff6c09b0d29efa63650e0dd9711b0a" translate="yes" xml:space="preserve">
          <source>Flexible typing is considered a feature of SQLite, not a bug. Nevertheless, we recognize that this feature does sometimes cause confusion and pain for developers who are acustomed to working with other databases that are more judgemental with regard to data types. In retrospect, perhaps it would have been better if SQLite had merely implemented an ANY datatype so that developers could explicitly state when they wanted to use flexible typing, rather than making flexible typing the default. But that is not something that can be changed now without breaking the millions of applications and trillions of database files that already use SQLite's flexible typing feature.</source>
          <target state="translated">柔軟な型付けは SQLite の機能であり、バグではないと考えられています。とはいえ、この機能がデータ型に関してより判断力のある他のデータベースでの作業に慣れている開発者にとっては、時に混乱と苦痛の原因になることもあると認識しています。振り返ってみると、柔軟な型付けをデフォルトにするのではなく、SQLiteが単にANYデータ型を実装して、開発者が柔軟な型付けを使いたいときに明示的に指定できるようにしていれば、もっと良かったのかもしれません。しかし、すでにSQLiteの柔軟な型付け機能を使用している何百万ものアプリケーションや何兆ものデータベースファイルを壊すことなく、今すぐにでも変更できるものではありません。</target>
        </trans-unit>
        <trans-unit id="f7fca84542efdc71814460460268fade242aaf16" translate="yes" xml:space="preserve">
          <source>Flexible typing is considered a feature of SQLite, not a bug. Nevertheless, we recognize that this feature does sometimes cause confusion and pain for developers who are acustomed to working with other databases that are more judgmental with regard to data types. In retrospect, perhaps it would have been better if SQLite had merely implemented an ANY datatype so that developers could explicitly state when they wanted to use flexible typing, rather than making flexible typing the default. But that is not something that can be changed now without breaking the millions of applications and trillions of database files that already use SQLite's flexible typing feature.</source>
          <target state="translated">柔軟な型付けは SQLite の機能であり、バグではないと考えられています。とはいえ、この機能がデータ型の判断に厳しい他のデータベースを扱うことに慣れている開発者に混乱と苦痛を与えることがあることは認識しています。振り返ってみると、柔軟な型付けをデフォルトにするのではなく、SQLiteが単にANYデータ型を実装して、開発者が柔軟な型付けを使いたいときに明示的に表明できるようにしていれば、もっと良かったのかもしれません。しかし、すでにSQLiteの柔軟な型付け機能を使用している何百万ものアプリケーションや何兆ものデータベースファイルを壊すことなく、今すぐにでも変更できるものではありません。</target>
        </trans-unit>
        <trans-unit id="595acd952f7adef405182868a3f64d0a5da38dfd" translate="yes" xml:space="preserve">
          <source>Flock locking style. This is used for file-systems that do not support POSIX locking style. Locks are obtained and released using the flock() system call.</source>
          <target state="translated">フロック・ロッキング・スタイル。これはPOSIXロックスタイルをサポートしていないファイルシステムで使用されます。ロックは flock()システムコールを使用して取得・解放されます。</target>
        </trans-unit>
        <trans-unit id="c57073033af4c5995ecd6e60b89e343929d9d2c9" translate="yes" xml:space="preserve">
          <source>Flush all database file changes to the disk. Wait for those changes to actually be written onto the disk surface.</source>
          <target state="translated">すべてのデータベースファイルの変更をディスクにフラッシュします。変更が実際にディスク表面に書き込まれるのを待ちます。</target>
        </trans-unit>
        <trans-unit id="de39ff51371c017e6227bb21dd0f83307b8a58ff" translate="yes" xml:space="preserve">
          <source>Flush caches to disk mid-transaction</source>
          <target state="translated">トランザクションの途中でキャッシュをディスクにフラッシュする</target>
        </trans-unit>
        <trans-unit id="f57e8f8a92192df5f1207764618acfad2559efdf" translate="yes" xml:space="preserve">
          <source>Follow these steps to create your own virtual table:</source>
          <target state="translated">以下の手順に従って、独自の仮想テーブルを作成します。</target>
        </trans-unit>
        <trans-unit id="95cf2c9a54fa89f9d97591c92b0397a9def66730" translate="yes" xml:space="preserve">
          <source>Following a successful call to this function, it is the responsibility of the caller to eventually free the buffer that *ppChangeset points to using &lt;a href=&quot;../c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">この関数の呼び出しが成功した後、最終的に* ppChangesetが&lt;a href=&quot;../c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;を使用してポイントしているバッファーを解放するのは呼び出し元の責任です。</target>
        </trans-unit>
        <trans-unit id="94243dad6fb7fd03cdf4ccdea9ad8045597be29a" translate="yes" xml:space="preserve">
          <source>Following a successful call to this function, it is the responsibility of the caller to eventually free the buffer that *ppChangeset points to using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">この関数の呼び出しが成功した後、最終的に* ppChangesetが&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free（）&lt;/a&gt;を使用してポイントしているバッファーを解放するのは呼び出し元の責任です。</target>
        </trans-unit>
        <trans-unit id="6ecbb1f3edb4dd34a3fdff354068e2c4ff752166" translate="yes" xml:space="preserve">
          <source>Following a system recovery, if a device sector is deemed to be untrustworthy as defined by A21008 and neither A21011 or A21012 apply to the range of bytes written, then no assumption can be made about the content of the sector following recovery. It is assumed that it is possible for such a sector to be written correctly, not written at all, populated with garbage data or any combination thereof.</source>
          <target state="translated">システムリカバリ後、A21008 で定義されているようにデバイスセクタが信頼できないと判断され、書き込まれたバイトの範囲に A21011 も A21012 も適用されない場合、リカバリ後のセクタの内容については何も仮定することができません。そのようなセクタは、正しく書き込まれるか、全く書き込まれないか、ガベージデータで埋め尽くされるか、またはそれらの組み合わせが可能であると仮定しています。</target>
        </trans-unit>
        <trans-unit id="1945818b9ff5e13872866426c7d8f1fe8a043f70" translate="yes" xml:space="preserve">
          <source>Following the header is the array of coordinate pairs. Each coordinate is a 32-bit floating point number. The use of 32-bit floating point values for coordinates means that any point on the earth's surface can be mapped with a resolution of approximately 2.5 meters. Higher resolutions are of course possible if the map is restricted to a single continent or country. Note that the resolution of coordinates in the geopoly module is similar in magnitude to daily movement of points on the earth's surface due to tidal forces.</source>
          <target state="translated">ヘッダの後に続くのは、 座標ペアの配列です。各座標は32ビット浮動小数点数です。座標に 32 ビット浮動小数点値を用いると、地表のどの点でも約 2.5 メートルの分解能で地図を作成できることになります。もちろん、地図が単一の大陸や国に限定されている場合は、それ以上の解像度も可能です。ジオポリモジュールの座標の解像度は、潮汐力による地表上の点の日々の移動に似ていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="581c115a7d0dc8fd1981c305296d4c558b5b086c" translate="yes" xml:space="preserve">
          <source>Following the single big &quot;timeline&quot; query, there are additional queries for each timeline element. Fossil is using the &quot;N+1 Query&quot; pattern rather than trying to grab all the information in as few queries as possible. But that is ok because there is no unnecessary IPC overhead. At the bottom of each timeline page, Fossil shows approximately how long it took to generate the page. For a 50-entry timeline, the latency is usually less than 25 milliseconds. Profiling shows that few of those milliseconds were spent inside the database engine.</source>
          <target state="translated">1つの大きな &quot;Timeline &quot;クエリに続いて、各Timeline要素に対して追加のクエリがあります。Fossilは可能な限り少ないクエリで全ての情報を取得しようとするのではなく、&quot;N+1クエリ &quot;パターンを使用しています。しかし、不必要なIPCのオーバーヘッドがないので、それでいいのです。各Timelineページの一番下に、Fossilはページの生成にかかった時間を表示しています。50エントリのTimelineの場合、レイテンシは通常25ミリ秒以下です。プロファイリングでは、これらのミリ秒がデータベースエンジン内で使われていないことがわかります。</target>
        </trans-unit>
        <trans-unit id="19775ac9542956e84e3786d1a483a9c9a75b880c" translate="yes" xml:space="preserve">
          <source>For BLOBs smaller than 100KB, reads are faster when the BLOBs are stored directly in the database file. For BLOBs larger than 100KB, reads from a separate file are faster.</source>
          <target state="translated">100KBより小さいBLOBの場合、BLOBがデータベース・ファイルに直接保存されている場合、読み込みが高速になります。100KBより大きいBLOBについては、別のファイルからの読み込みの方が高速です。</target>
        </trans-unit>
        <trans-unit id="395ae193aa1eadd77633da6e02ed51db87786473" translate="yes" xml:space="preserve">
          <source>For SQLite</source>
          <target state="translated">SQLiteの場合</target>
        </trans-unit>
        <trans-unit id="f3c131948733abd40fff7115bdc1ab412d61d9a8" translate="yes" xml:space="preserve">
          <source>For SQLite version 2.6.3 and earlier, all values used the numeric datatype. The text datatype appears in version 2.7.0 and later. In the sequel it is assumed that you are using version 2.7.0 or later of SQLite.</source>
          <target state="translated">SQLite バージョン 2.6.3 以前のバージョンでは、すべての値に数値データ型が使用されていました。テキスト・データ型はバージョン2.7.0以降で登場します。続編では、SQLite のバージョン 2.7.0 以降を使用していることを前提としています。</target>
        </trans-unit>
        <trans-unit id="942453851992f474fda1456f6f181f26cf640d20" translate="yes" xml:space="preserve">
          <source>For SQLite versions prior to 3.24.0 (2018-06-04), the only information that an R*Tree index stores about an object is its integer ID and its bounding box. Additional information needs to be stored in separate tables and related to the R*Tree index using the primary key. For the example above, one might create an auxiliary table as follows:</source>
          <target state="translated">3.24.0 (2018-06-04)より前の SQLite バージョンでは、R*Tree インデックスがオブジェクトについて保存する情報は、その整数 ID とバウンディング ボックスのみです。追加の情報は別のテーブルに格納され、主キーを使用してR*Treeインデックスに関連する必要があります。上の例では、次のように補助テーブルを作成することができます。</target>
        </trans-unit>
        <trans-unit id="50f58131252372876ea89c95a887df9a9f6004ed" translate="yes" xml:space="preserve">
          <source>For UTF-16 databases, when using the &quot;simple&quot; tokenizer, it is possible to use malformed unicode strings to cause the &lt;a href=&quot;#integcheck&quot;&gt;integrity-check special command&lt;/a&gt; to falsely report corruption, or for &lt;a href=&quot;#snippet&quot;&gt;auxiliary functions&lt;/a&gt; to return incorrect results. More specifically, the bug can be triggered by any of the following:</source>
          <target state="translated">For UTF-16 databases, when using the &quot;simple&quot; tokenizer, it is possible to use malformed unicode strings to cause the &lt;a href=&quot;#integcheck&quot;&gt;integrity-check special command&lt;/a&gt; to falsely report corruption, or for &lt;a href=&quot;#snippet&quot;&gt;auxiliary functions&lt;/a&gt; to return incorrect results. More specifically, the bug can be triggered by any of the following:</target>
        </trans-unit>
        <trans-unit id="a64fca4030b56c7de05a5fe2b410b314416229df" translate="yes" xml:space="preserve">
          <source>For UTF16 input text to the sqlite3_result_text16(), sqlite3_result_text16be(), sqlite3_result_text16le(), and sqlite3_result_text64() routines, if the text contains invalid UTF16 characters, the invalid characters might be converted into the unicode replacement character, U+FFFD.</source>
          <target state="translated">sqlite3_result_text16(),sqlite3_result_text16be(),sqlite3_result_text16le(),sqlite3_result_text64()ルーチンへのUTF16入力テキストに対して、テキストに無効なUTF16文字が含まれている場合、無効な文字はユニコード置換文字であるU+FFFDに変換される可能性があります。</target>
        </trans-unit>
        <trans-unit id="55b4a9ef398b6737e332f74269051f6a928aaf6c" translate="yes" xml:space="preserve">
          <source>For a &lt;b&gt;DELETE&lt;/b&gt; change, the payload consists of the PRIMARY KEY fields only. The original values of other fields are not stored as part of a patchset.</source>
          <target state="translated">&lt;b&gt;DELETE&lt;/b&gt;変更、ペイロードはPRIMARY KEYフィールドで構成されています。他のフィールドの元の値は、パッチセットの一部として保存されません。</target>
        </trans-unit>
        <trans-unit id="bad0ea706b018c5833dc966db96c3bbf3f0b2138" translate="yes" xml:space="preserve">
          <source>For a JOIN or INNER JOIN or CROSS JOIN, there is no difference between a constraint expression in the WHERE clause and one in the ON clause. However, for a LEFT JOIN or LEFT OUTER JOIN, the difference is very important. In a LEFT JOIN, the extra NULL row for the right-hand table is added after ON clause processing but before WHERE clause processing. A constraint of the form &quot;left.x=right.y&quot; in an ON clause will therefore allow through the added all-NULL rows of the right table. But if that same constraint is in the WHERE clause a NULL in &quot;right.y&quot; will prevent the expression &quot;left.x=right.y&quot; from being true, and thus exclude that row from the output.</source>
          <target state="translated">JOIN、INNER JOIN、CROSS JOINでは、WHERE句の制約式とON句の制約式に違いはありません。しかし、LEFT JOINやLEFT OUTER JOINでは、この違いは非常に重要です。LEFT JOINでは、右手テーブルの余分なNULL行はON句の処理の後に追加されますが、WHERE句の処理の前に追加されます。したがって、ON句で &quot;left.x=right.y &quot;という形式の制約は、右テーブルの追加されたすべてのNULL行を通過させることができます。しかし、同じ制約がWHERE句にある場合、&quot;right.y &quot;にNULLがあると、式 &quot;left.x=right.y &quot;が真であることができず、その行は出力から除外されます。</target>
        </trans-unit>
        <trans-unit id="2837a8bb64314525a9077bf3440c2ed144dbb1b8" translate="yes" xml:space="preserve">
          <source>For a LEFT OUTER JOIN the situation is more complex. The following two queries are not equivalent:</source>
          <target state="translated">LEFT OUTER JOINの場合、状況はより複雑です。以下の2つのクエリは等価ではありません。</target>
        </trans-unit>
        <trans-unit id="ad715a95908c984b7542ffaa9563f1288257e6ce" translate="yes" xml:space="preserve">
          <source>For a SELECT query that uses the full-text index, the offsets() function returns a text value containing a series of space-separated integers. For each term in each &lt;a href=&quot;#matchable&quot;&gt;phrase match&lt;/a&gt; of the current row, there are four integers in the returned list. Each set of four integers is interpreted as follows:</source>
          <target state="translated">全文索引を使用するSELECTクエリの場合、offsets（）関数は、スペースで区切られた一連の整数を含むテキスト値を返します。現在の行の各&lt;a href=&quot;#matchable&quot;&gt;フレーズ一致の&lt;/a&gt;各用語について、返されるリストには4つの整数があります。 4つの整数の各セットは、次のように解釈されます。</target>
        </trans-unit>
        <trans-unit id="6eca1d9c3f6f9db89f4bb4081945f8167605d308" translate="yes" xml:space="preserve">
          <source>For a command of the form &quot;REINDEX</source>
          <target state="translated">REINDEX &quot;という形式のコマンドの場合</target>
        </trans-unit>
        <trans-unit id="06d5551761da6c159b879a307caa21c04cdacf8a" translate="yes" xml:space="preserve">
          <source>For a commit involving multiple databases and a master journal, if the various databases were on different disk volumes and a power failure occurs during the commit, then when the machine comes back up the disks might be remounted with different names. Or some disks might not be mounted at all. When this happens the individual file journals and the master journal might not be able to find each other. The worst outcome from this scenario is that the commit ceases to be atomic. Some databases might be rolled back and others might not. All databases will continue to be self-consistent. To defend against this problem, keep all databases on the same disk volume and/or remount disks using exactly the same names after a power failure.</source>
          <target state="translated">複数のデータベースとマスタージャーナルを含むコミットの場合、様々なデータベースが異なるディスクボリューム上にあり、コミット中に停電が発生した場合、マシンが復旧したときにディスクが異なる名前で再マウントされるかもしれません。あるいは、いくつかのディスクは全くマウントされないかもしれません。このような場合、個々のファイルジャーナルとマスタージャーナルはお互いを見つけることができないかもしれません。このシナリオの最悪の結果は、コミットがアトミックでなくなることです。一部のデータベースはロールバックされるかもしれませんし、そうでないデータベースもあるかもしれません。すべてのデータベースは自己整合性を保ち続けます。この問題を回避するには、すべてのデータベースを同じディスクボリュームに保つか、停電後にまったく同じ名前のディスクをリマウントしてください。</target>
        </trans-unit>
        <trans-unit id="e40bdd6eb01aba5fc405b17e2bcc433fd88a3c9f" translate="yes" xml:space="preserve">
          <source>For a commit involving multiple databases and a super-journal, if the various databases were on different disk volumes and a power failure occurs during the commit, then when the machine comes back up the disks might be remounted with different names. Or some disks might not be mounted at all. When this happens the individual file journals and the super-journal might not be able to find each other. The worst outcome from this scenario is that the commit ceases to be atomic. Some databases might be rolled back and others might not. All databases will continue to be self-consistent. To defend against this problem, keep all databases on the same disk volume and/or remount disks using exactly the same names after a power failure.</source>
          <target state="translated">複数のデータベースとスーパージャーナルを含むコミットの場合、様々なデータベースが異なるディスクボリューム上にあり、コミット中に停電が発生した場合、マシンが復旧したときにディスクが異なる名前で再マウントされるかもしれません。あるいは、いくつかのディスクは全くマウントされないかもしれません。このような場合、個々のファイルジャーナルとスーパージャーナルはお互いを見つけることができなくなるかもしれません。このシナリオの最悪の結果は、コミットがアトミックでなくなることです。いくつかのデータベースはロールバックされるかもしれませんし、そうでないデータベースもあるかもしれません。すべてのデータベースは自己矛盾しません。この問題を回避するには、すべてのデータベースを同じディスクボリュームに保つか、停電後にまったく同じ名前のディスクをリマウントするようにしてください。</target>
        </trans-unit>
        <trans-unit id="bb9e9e569c28385b62c9d2cc5d8fba70bcf036db" translate="yes" xml:space="preserve">
          <source>For a directory entry, any value inserted into this field is ignored. Otherwise, if it is set to 0, then the file data or symbolic link target is stored as is in the zip archive and the compression method set to 0. If it is set to 8, then the file data or link target is compressed using deflate compression before it is stored and the compression method set to 8. Finally, if a NULL value is written to this field, the zipfile module automatically decides whether or not to compress the data before storing it.</source>
          <target state="translated">ディレクトリエントリの場合、このフィールドに挿入された値は無視されます。0 に設定されている場合は、ファイルデータまたはシンボリックリンクターゲットはそのまま zip アーカイブに保存され、圧縮方法は 0 に設定されます。 8 に設定されている場合は、ファイルデータまたはリンクターゲットは、保存前に deflate 圧縮を用いて圧縮され、圧縮方法は 8 に設定されます。最後に、このフィールドにNULL値が書き込まれた場合、zipfileモジュールはデータを保存する前に圧縮するかどうかを自動的に決定します。</target>
        </trans-unit>
        <trans-unit id="60b588cb6440e5757b3bffacb57c3da76e66f360" translate="yes" xml:space="preserve">
          <source>For a listing of the available dot commands, you can enter &quot;.help&quot; with no arguments. Or enter &quot;.help TOPIC&quot; for detailed information about TOPIC. The list of available dot-commands follows:</source>
          <target state="translated">利用可能なドットコマンドのリストは、引数なしで「.help」と入力することができます。または、「.help TOPIC」と入力すると、TOPICに関する詳細な情報を得ることができます。利用可能なドットコマンドのリストは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="d4baaae0b83211d05bdb6a6f17481963667e90c7" translate="yes" xml:space="preserve">
          <source>For a program that uses an SQLite database as its &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt;, when a new database instance is first created the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command is ineffective because the database contain no data from which to gather statistics. In that case, one could construct a large prototype database containing typical data during development and run the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command on this prototype database to gather statistics, then save the prototype statistics as part of the application. After deployment, when the application goes to create a new database file, it can run the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command in order to create the statistics tables, then copy the precomputed statistics obtained from the prototype database into these new statistics tables. In that way, statistics from large working data sets can be preloaded into newly created application files.</source>
          <target state="translated">SQLiteデータベースを&lt;a href=&quot;appfileformat&quot;&gt;アプリケーションファイル形式&lt;/a&gt;として使用するプログラムの場合、新しいデータベースインスタンスが最初に作成されたとき、データベースには統計を収集するためのデータが含まれていないため、&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;コマンドは無効です。その場合、開発中に典型的なデータを含む大きなプロトタイプデータベースを構築し、このプロトタイプデータベースで&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;コマンドを実行して統計を収集し、アプリケーションの一部としてプロトタイプ統計を保存できます。デプロイ後、アプリケーションが新しいデータベースファイルを作成するときに、&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;を実行できます。コマンドを使用して統計テーブルを作成し、プロトタイプデータベースから取得した事前計算された統計をこれらの新しい統計テーブルにコピーします。このようにして、大きな作業データセットの統計情報を、新しく作成されたアプリケーションファイルにプリロードできます。</target>
        </trans-unit>
        <trans-unit id="a94574556e6541171dc1e77628bd7786ebcc44a5" translate="yes" xml:space="preserve">
          <source>For a row-value &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN operator&lt;/a&gt;, the left-hand side (hereafter &quot;LHS&quot;) can be either a parenthesized list of values or a subquery with multiple columns. But the right-hand side (hereafter &quot;RHS&quot;) must be a subquery expression.</source>
          <target state="translated">行値&lt;a href=&quot;lang_expr#in_op&quot;&gt;IN演算子の&lt;/a&gt;場合、左側（以下「LHS」）は、括弧で囲まれた値のリストか、複数の列を持つサブクエリのいずれかになります。ただし、右側（以下「RHS」）はサブクエリ式でなければなりません。</target>
        </trans-unit>
        <trans-unit id="1f6b45d36586c69d55b8983f8d799c1d8e89a8c6" translate="yes" xml:space="preserve">
          <source>For a string value X, the length(X) function returns the number of characters (not bytes) in X prior to the first NUL character. Since SQLite strings do not normally contain NUL characters, the length(X) function will usually return the total number of characters in the string X. For a blob value X, length(X) returns the number of bytes in the blob. If X is NULL then length(X) is NULL. If X is numeric then length(X) returns the length of a string representation of X.</source>
          <target state="translated">文字列値 X の場合、length(X)関数は X の最初の NUL 文字より前の文字数 (バイト数ではありません)を返します。SQLite の文字列は通常 NUL 文字を含まないので、 length(X)関数は通常、文字列 X の文字数の合計を返します。X が NULL の場合は length(X)は NULL です。X が数値の場合、length(X)は X の文字列表現の長さを返します。</target>
        </trans-unit>
        <trans-unit id="d7e042b4a217a46e364221bac2287b2e16ce5e8f" translate="yes" xml:space="preserve">
          <source>For added readability, also set &quot;.echo on&quot; so that the output contains the original SQL text.</source>
          <target state="translated">可読性を高めるために、&quot;.echo on&quot; を設定して、元の SQL テキストを出力するようにします。</target>
        </trans-unit>
        <trans-unit id="464bd448fbdde2a69f1880b4aadf91dc5c60e76e" translate="yes" xml:space="preserve">
          <source>For additional information on how the SQLite library functions, the reader is directed to look at the SQLite source code directly. If you understand the material in this article, you should not have much difficulty in following the sources. Serious students of the internals of SQLite will probably also want to make a careful study of the VDBE opcodes as documented &lt;a href=&quot;opcode&quot;&gt;here&lt;/a&gt;. Most of the opcode documentation is extracted from comments in the source code using a script so you can also get information about the various opcodes directly from the &lt;b&gt;vdbe.c&lt;/b&gt; source file. If you have successfully read this far, you should have little difficulty understanding the rest.</source>
          <target state="translated">SQLiteライブラリがどのように機能するかの詳細については、SQLiteソースコードを直接参照することをお勧めします。この記事の内容を理解していれば、出典をたどるのはそれほど難しくありません。 SQLiteの内部について真面目な学生は、おそらく&lt;a href=&quot;opcode&quot;&gt;ここに&lt;/a&gt;記載されているようにVDBEオペコードを注意深く研究したいと思うでしょう。ほとんどのopcodeドキュメントは、スクリプトを使用してソースコード内のコメントから抽出されるため、&lt;b&gt;vdbe.c&lt;/b&gt;ソースファイルからさまざまな&lt;b&gt;opcode&lt;/b&gt;に関する情報を直接取得することもできます。ここまで読んだことがあれば、残りを理解するのにほとんど困難はないはずです。</target>
        </trans-unit>
        <trans-unit id="5cc0c6c827845b6d255c4013e6ccd3c888188ba4" translate="yes" xml:space="preserve">
          <source>For aggregate functions, the &lt;b&gt;xStep&lt;/b&gt; callback is invoked once for each row in the result and then &lt;b&gt;xFinalize&lt;/b&gt; is invoked at the end to compute a final answer. The xStep routine can use the &lt;b&gt;sqlite_aggregate_context()&lt;/b&gt; interface to allocate memory that will be unique to that particular instance of the SQL function. This memory will be automatically deleted after xFinalize is called. The &lt;b&gt;sqlite_aggregate_count()&lt;/b&gt; routine can be used to find out how many rows of data were passed to the aggregate. The xFinalize callback should invoke one of the &lt;b&gt;sqlite_set_result_...&lt;/b&gt; interfaces to set the final result of the aggregate.</source>
          <target state="translated">集約関数の場合、結果の行ごとに&lt;b&gt;xStep&lt;/b&gt;コールバックが1回呼び出され、最後に&lt;b&gt;xFinalize&lt;/b&gt;が呼び出されて最終的な回答が計算されます。 xStepルーチンは、&lt;b&gt;sqlite_aggregate_context（）&lt;/b&gt;インターフェースを使用して、SQL関数の特定のインスタンスに固有のメモリーを割り当てることができます。このメモリは、xFinalizeが呼び出された後に自動的に削除されます。&lt;b&gt;sqlite_aggregate_count（）&lt;/b&gt;ルーチンは、データの多くの行が集計に渡されたかを調べるために使用することができます。 xFinalizeコールバックは、&lt;b&gt;sqlite_set_result _...&lt;/b&gt;インターフェースの1つを呼び出して、集約の最終結果を設定する&lt;b&gt;必要があります&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="4a2b8e655022b370f7bf1cade1de14d9df62358a" translate="yes" xml:space="preserve">
          <source>For all of these errors, SQLite attempts to undo just the one statement it was working on and leave changes from prior statements within the same transaction intact and continue with the transaction. However, depending on the statement being evaluated and the point at which the error occurs, it might be necessary for SQLite to rollback and cancel the entire transaction. An application can tell which course of action SQLite took by using the &lt;a href=&quot;c3ref/get_autocommit&quot;&gt;sqlite3_get_autocommit()&lt;/a&gt; C-language interface.</source>
          <target state="translated">これらすべてのエラーについて、SQLiteは、処理していた1つのステートメントだけを元に戻し、同じトランザクション内の以前のステートメントからの変更をそのままにして、トランザクションを続行しようとします。ただし、評価されるステートメントとエラーが発生するポイントによっては、SQLiteがトランザクション全体をロールバックしてキャンセルすることが必要になる場合があります。アプリケーションは、&lt;a href=&quot;c3ref/get_autocommit&quot;&gt;sqlite3_get_autocommit（）&lt;/a&gt; C言語インターフェースを使用することにより、SQLiteがどのようなアクションをとったかを知ることができます。</target>
        </trans-unit>
        <trans-unit id="edd867afbc99c464b46e982c8bdb271f01de00a1" translate="yes" xml:space="preserve">
          <source>For all versions of SQLite up to and including 3.6.23.1, a call to &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; was required after sqlite3_step() returned anything other than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; before any subsequent invocation of sqlite3_step(). Failure to reset the prepared statement using &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; would result in an &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt; return from sqlite3_step(). But after &lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;version 3.6.23.1&lt;/a&gt; (2010-03-26, sqlite3_step() began calling &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; automatically in this circumstance rather than returning &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. This is not considered a compatibility break because any application that ever receives an SQLITE_MISUSE error is broken by definition. The &lt;a href=&quot;compile#omit_autoreset&quot;&gt;SQLITE_OMIT_AUTORESET&lt;/a&gt; compile-time option can be used to restore the legacy behavior.</source>
          <target state="translated">3.6.23.1までのすべてのバージョンのSQLiteでは、&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_step（）&lt;/a&gt;がSQLITE_ROW以外のものを&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;返した&lt;/a&gt;後、その後のsqlite3_step（）の呼び出しの前に、sqlite3_reset（）の呼び出しが必要でした。使用してプリペアドステートメントをリセットしないと&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_resetは（）&lt;/a&gt;につながる&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSEの&lt;/a&gt; sqlite3_stepからのリターン（）。ただし、&lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;バージョン3.6.23.1&lt;/a&gt;（2010-03-26、sqlite3_step（）以降は、この状況で&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSEを&lt;/a&gt;返すのではなく、自動的に&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset（）を&lt;/a&gt;呼び出し始めました。これは、SQLITE_MISUSEエラーを受け取るすべてのアプリケーションが定義により壊れているため、互換性の問題とは見なされません。 。&lt;a href=&quot;compile#omit_autoreset&quot;&gt;SQLITE_OMIT_AUTORESET&lt;/a&gt;コンパイル時オプションを使用して、従来の動作を復元できます。</target>
        </trans-unit>
        <trans-unit id="c8ec8a08c58f886e596c21082f16011397cbdb2b" translate="yes" xml:space="preserve">
          <source>For all versions of SQLite up to and including 3.6.23.1, a call to &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; was required after sqlite3_step() returned anything other than &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; before any subsequent invocation of sqlite3_step(). Failure to reset the prepared statement using &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; would result in an &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; return from sqlite3_step(). But after &lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;version 3.6.23.1&lt;/a&gt; (2010-03-26, sqlite3_step() began calling &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; automatically in this circumstance rather than returning &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. This is not considered a compatibility break because any application that ever receives an SQLITE_MISUSE error is broken by definition. The &lt;a href=&quot;../compile#omit_autoreset&quot;&gt;SQLITE_OMIT_AUTORESET&lt;/a&gt; compile-time option can be used to restore the legacy behavior.</source>
          <target state="translated">3.6.23.1までのすべてのバージョンのSQLiteでは、&lt;a href=&quot;reset&quot;&gt;sqlite3_step（）&lt;/a&gt;がSQLITE_ROW以外のものを&lt;a href=&quot;../rescode#row&quot;&gt;返した&lt;/a&gt;後、その後のsqlite3_step（）の呼び出しの前に、sqlite3_reset（）の呼び出しが必要でした。使用してプリペアドステートメントをリセットしないと&lt;a href=&quot;reset&quot;&gt;sqlite3_resetは（）&lt;/a&gt;につながる&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSEの&lt;/a&gt; sqlite3_stepからのリターン（）。ただし、&lt;a href=&quot;https://sqlite.org/releaselog/3_6_23_1.html&quot;&gt;バージョン3.6.23.1&lt;/a&gt;（2010-03-26、sqlite3_step（）以降は、この状況で&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSEを&lt;/a&gt;返すのではなく、自動的に&lt;a href=&quot;reset&quot;&gt;sqlite3_reset（）を&lt;/a&gt;呼び出し始めました。これは、SQLITE_MISUSEエラーを受け取るすべてのアプリケーションが定義により壊れているため、互換性の問題とは見なされません。 。&lt;a href=&quot;../compile#omit_autoreset&quot;&gt;SQLITE_OMIT_AUTORESET&lt;/a&gt;コンパイル時オプションを使用して、従来の動作を復元できます。</target>
        </trans-unit>
        <trans-unit id="cb3ef573edb29303f7422a9886c28f0ac60f646d" translate="yes" xml:space="preserve">
          <source>For allocators other than &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;, all memory allocations are of the same size. Hence, &lt;b&gt;n&lt;/b&gt;=1 and therefore &lt;b&gt;N&lt;/b&gt;=&lt;b&gt;M&lt;/b&gt;. In other words, the memory pool need be no larger than the largest amount of memory in use at any given moment.</source>
          <target state="translated">&lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;以外のアロケータの場合、すべてのメモリ割り当ては同じサイズです。したがって、&lt;b&gt;n&lt;/b&gt; = 1、したがって&lt;b&gt;N&lt;/b&gt; = &lt;b&gt;M&lt;/b&gt;です。つまり、メモリプールは、ある時点で使用されているメモリの最大量を超える必要はありません。</target>
        </trans-unit>
        <trans-unit id="a2e786b5782b352cf04ddbf2d2c01d46af6ed148" translate="yes" xml:space="preserve">
          <source>For an &lt;b&gt;UPDATE&lt;/b&gt; change, the payload consists of the PRIMARY KEY fields and the new values of modified fields only. The original values of modified fields are not stored as part of a patchset.</source>
          <target state="translated">ため&lt;b&gt;UPDATEの&lt;/b&gt;変化、ペイロードは、PRIMARY KEYフィールドのみ変更されたフィールドの新しい値から成ります。変更されたフィールドの元の値は、パッチセットの一部として保存されません。</target>
        </trans-unit>
        <trans-unit id="87c8bcb65c916a4e76edf02935c7238f192ed71f" translate="yes" xml:space="preserve">
          <source>For an UPDATE or DELETE operation on a &lt;a href=&quot;../rowidtable&quot;&gt;rowid table&lt;/a&gt;, the sixth parameter passed to the preupdate callback is the initial &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the row being modified or deleted. For an INSERT operation on a rowid table, or any operation on a WITHOUT ROWID table, the value of the sixth parameter is undefined. For an INSERT or UPDATE on a rowid table the seventh parameter is the final rowid value of the row being inserted or updated. The value of the seventh parameter passed to the callback function is not defined for operations on WITHOUT ROWID tables, or for INSERT operations on rowid tables.</source>
          <target state="translated">&lt;a href=&quot;../rowidtable&quot;&gt;ROWIDテーブル&lt;/a&gt;に対するUPDATEまたはDELETE操作の場合、事前更新コールバックに渡される6番目のパラメータは、変更または削除される行の最初の&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;です。 ROWIDテーブルに対するINSERT操作、またはWITHOUT ROWIDテーブルに対する任意の操作の場合、6番目のパラメータの値は未定義です。 ROWIDテーブルでのINSERTまたはUPDATEの場合、7番目のパラメータは、挿入または更新される行の最後のROWID値です。コールバック関数に渡される7番目のパラメーターの値は、WITHOUT ROWIDテーブルに対する操作、またはROWIDテーブルに対するINSERT操作に対して定義されていません。</target>
        </trans-unit>
        <trans-unit id="3fa74a389b030ce220f00901508abe1120507900" translate="yes" xml:space="preserve">
          <source>For an UPDATE or DELETE operation on a &lt;a href=&quot;rowidtable&quot;&gt;rowid table&lt;/a&gt;, the sixth parameter passed to the preupdate callback is the initial &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the row being modified or deleted. For an INSERT operation on a rowid table, or any operation on a WITHOUT ROWID table, the value of the sixth parameter is undefined. For an INSERT or UPDATE on a rowid table the seventh parameter is the final rowid value of the row being inserted or updated. The value of the seventh parameter passed to the callback function is not defined for operations on WITHOUT ROWID tables, or for INSERT operations on rowid tables.</source>
          <target state="translated">&lt;a href=&quot;rowidtable&quot;&gt;ROWIDテーブル&lt;/a&gt;に対するUPDATEまたはDELETE操作の場合、事前更新コールバックに渡される6番目のパラメータは、変更または削除される行の最初の&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;です。 ROWIDテーブルに対するINSERT操作、またはWITHOUT ROWIDテーブルに対する任意の操作の場合、6番目のパラメータの値は未定義です。 ROWIDテーブルでのINSERTまたはUPDATEの場合、7番目のパラメータは、挿入または更新される行の最後のROWID値です。コールバック関数に渡される7番目のパラメーターの値は、WITHOUT ROWIDテーブルに対する操作、またはROWIDテーブルに対するINSERT操作に対して定義されていません。</target>
        </trans-unit>
        <trans-unit id="6babaeb551e0ac84ca65632772689ec35209b982" translate="yes" xml:space="preserve">
          <source>For an example of an INSTEAD OF trigger, consider the following schema:</source>
          <target state="translated">INSTEAD OF トリガの例として、以下のスキーマを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="1cb2ec7dc6172161d64c33e9d01d6ab6fb648efe" translate="yes" xml:space="preserve">
          <source>For an expression, the datatype of the result is often determined by the outermost operator. For example, arithmetic operators (&quot;+&quot;, &quot;*&quot;, &quot;%&quot;) always return a numeric results. The string concatenation operator (&quot;||&quot;) returns a text result. And so forth. If you are ever in doubt about the datatype of an expression you can use the special &lt;b&gt;typeof()&lt;/b&gt; SQL function to determine what the datatype is. For example:</source>
          <target state="translated">式の場合、結果のデータ型は多くの場合、最も外側の演算子によって決定されます。たとえば、算術演算子（ &quot;+&quot;、 &quot;*&quot;、 &quot;％&quot;）は常に数値の結果を返します。文字列連結演算子（ &quot;||&quot;）はテキスト結果を返します。などなど。式のデータ型に疑問がある場合は、特別な&lt;b&gt;typeof（）&lt;/b&gt; SQL関数を使用してデータ型を判別できます。例えば：</target>
        </trans-unit>
        <trans-unit id="8771671648f56259c0348d58066fbd244a9f5761" translate="yes" xml:space="preserve">
          <source>For an inner join, the two queries above would be identical. But special processing applies to the ON and USING clauses of an OUTER join: specifically, the constraints in an ON or USING clause do not apply if the right table of the join is on a null row, but the constraints do apply in the WHERE clause. The net effect is that putting the ON or USING clause expressions for a LEFT JOIN in the WHERE clause effectively converts the query to an ordinary INNER JOIN - albeit an inner join that runs more slowly.</source>
          <target state="translated">内部結合の場合、上記の2つのクエリは同じです。具体的には、結合の右テーブルがヌル行の場合、ON句やUSING句の制約は適用されませんが、WHERE句では制約が適用されます。正味の効果は、LEFT JOINのON句やUSING句の表現をWHERE句に入れることで、クエリを通常のINNER JOINに効果的に変換することです。</target>
        </trans-unit>
        <trans-unit id="a4c04f89a73080a41ad80cd0704141b22ed403a6" translate="yes" xml:space="preserve">
          <source>For an ordinary on-disk database file, the serialization is just a copy of the disk file. For an in-memory database or a &quot;TEMP&quot; database, the serialization is the same sequence of bytes which would be written to disk if that database where backed up to disk.</source>
          <target state="translated">通常のディスク上のデータベースファイルの場合、シリアライズはディスクファイルのコピーに過ぎません。インメモリデータベースや &quot;TEMP &quot;データベースの場合、シリアル化は、もしそのデータベースがディスクにバックアップされている場合、ディスクに書き込まれるバイトのシーケンスと同じです。</target>
        </trans-unit>
        <trans-unit id="363689c9e649bf1c45ea48634a5a7f396dccdc2a" translate="yes" xml:space="preserve">
          <source>For any given SQL statement, there might be hundreds or thousands or even millions of different algorithms of performing the operation. All of these algorithms will get the correct answer, though some will run faster than others. The query planner is an &lt;a href=&quot;https://en.wikipedia.org/wiki/Artificial_intelligence&quot;&gt;AI&lt;/a&gt; that tries to pick the fastest and most efficient algorithm for each SQL statement.</source>
          <target state="translated">特定のSQLステートメントについて、操作を実行する数百、数千、または数百万もの異なるアルゴリズムが存在する場合があります。これらのアルゴリズムはすべて正解になりますが、他のアルゴリズムよりも高速に実行されるものもあります。クエリプランナーは、各SQLステートメントに対して最速かつ最も効率的なアルゴリズムを選択しようとする&lt;a href=&quot;https://en.wikipedia.org/wiki/Artificial_intelligence&quot;&gt;AI&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="20178a76e031f6e0dd46cd965f669f77257d11d8" translate="yes" xml:space="preserve">
          <source>For any given query, the fact that the OR-clause optimization described here can be used does not guarantee that it will be used. SQLite uses a cost-based query planner that estimates the CPU and disk I/O costs of various competing query plans and chooses the plan that it thinks will be the fastest. If there are many OR terms in the WHERE clause or if some of the indices on individual OR-clause subterms are not very selective, then SQLite might decide that it is faster to use a different query algorithm, or even a full-table scan. Application developers can use the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; prefix on a statement to get a high-level overview of the chosen query strategy.</source>
          <target state="translated">どのクエリでも、ここで説明するOR句の最適化を使用できるという事実は、それが使用されることを保証するものではありません。 SQLiteはコストベースのクエリプランナーを使用して、競合するさまざまなクエリプランのCPUおよびディスクI / Oコストを見積もり、最速と思われるプランを選択します。 WHERE句にOR用語が多数ある場合、または個々のOR句サブタームのインデックスの一部があまり選択的でない場合、SQLiteは、異なるクエリアルゴリズムを使用したり、フルテーブルスキャンを使用したりする方が速いと判断する場合があります。アプリケーション開発者は、ステートメントで&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;プレフィックスを使用して、選択したクエリ戦略の概要を取得できます。</target>
        </trans-unit>
        <trans-unit id="16c7cb0ca5e5ce3a2a0070ff33c0953ef0a2395f" translate="yes" xml:space="preserve">
          <source>For any historical version of SQLite, the source tree can be obtained from the &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; version control system, either downloading a tarball or ZIP archive for a specific version, or by cloning the entire project history.</source>
          <target state="translated">SQLiteの過去のバージョンの場合、ソースツリーは&lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt;バージョン管理システムから取得できます。特定のバージョンのtarballまたはZIPアーカイブをダウンロードするか、プロジェクト履歴全体を複製します。</target>
        </trans-unit>
        <trans-unit id="6136d5ebef73dfa5b00893d194ed16a2a41f54ee" translate="yes" xml:space="preserve">
          <source>For auxiliary columns, only the name of the column matters. The &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; is ignored. Constraints such as NOT NULL, UNIQUE, REFERENCES, or CHECK are also ignored. However, future versions of SQLite might start paying attention to the type affinity and constraints, so users of auxiliary columns are advised to leave both blank, to avoid future compatibility problems.</source>
          <target state="translated">For auxiliary columns, only the name of the column matters. The &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; is ignored. Constraints such as NOT NULL, UNIQUE, REFERENCES, or CHECK are also ignored. However, future versions of SQLite might start paying attention to the type affinity and constraints, so users of auxiliary columns are advised to leave both blank, to avoid future compatibility problems.</target>
        </trans-unit>
        <trans-unit id="38f9906eb0f1f05679eef0c31ffe0e8cfcb13adf" translate="yes" xml:space="preserve">
          <source>For backwards compatibility with older versions of SQLite that lack the &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; interface, the &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; interface is called automatically upon entry to certain key interfaces such as &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;, and &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt;. The overhead of invoking &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; automatically in this way may be omitted by building SQLite with the SQLITE_OMIT_AUTOINIT C-preprocessor macro. When built using SQLITE_OMIT_AUTOINIT, SQLite will not automatically initialize itself and the application is required to invoke &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; directly prior to beginning use of the SQLite library.</source>
          <target state="translated">欠けのSQLiteの古いバージョンとの後方互換性のため&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;インターフェースを、&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;インターフェースは、次のような特定のキーのインターフェイスへのエントリ時に自動的に呼び出され&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open（） &lt;/a&gt;、&lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register（） &lt;/a&gt;、及び&lt;a href=&quot;c3ref/mprintf&quot;&gt;（）sqlite3_mprintf&lt;/a&gt;。この方法で&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize（）を&lt;/a&gt;自動的に呼び出すオーバーヘッドは、SQLITE_OMIT_AUTOINIT Cプリプロセッサマクロを使用してSQLiteを構築することで省略できます。 SQLITE_OMIT_AUTOINITを使用してビルドした場合、SQLiteは自動的に初期化されないため、アプリケーションはSQLiteライブラリの使用を開始する直前に&lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="2d1531a5da60e68beb6877ebc84583e140b012b5" translate="yes" xml:space="preserve">
          <source>For best security, do not use this method unless truly needed, and run &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema=OFF&lt;/a&gt; or the &quot;&lt;a href=&quot;#config&quot;&gt;db config trusted_schema 0&lt;/a&gt;&quot; method &lt;u&gt;before&lt;/u&gt; invoking this method.</source>
          <target state="translated">For best security, do not use this method unless truly needed, and run &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema=OFF&lt;/a&gt; or the &quot;&lt;a href=&quot;#config&quot;&gt;db config trusted_schema 0&lt;/a&gt;&quot; method &lt;u&gt;before&lt;/u&gt; invoking this method.</target>
        </trans-unit>
        <trans-unit id="9c2a0d57a438475dac09b9669a68b59949b61514" translate="yes" xml:space="preserve">
          <source>For best security, the &lt;a href=&quot;#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag is recommended for all application-defined SQL functions that do not need to be used inside of triggers, view, CHECK constraints, or other elements of the database schema. This flags is especially recommended for SQL functions that have side effects or reveal internal application state. Without this flag, an attacker might be able to modify the schema of a database file to include invocations of the function with parameters chosen by the attacker, which the application will then execute when the database file is opened and read.</source>
          <target state="translated">For best security, the &lt;a href=&quot;#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag is recommended for all application-defined SQL functions that do not need to be used inside of triggers, view, CHECK constraints, or other elements of the database schema. This flags is especially recommended for SQL functions that have side effects or reveal internal application state. Without this flag, an attacker might be able to modify the schema of a database file to include invocations of the function with parameters chosen by the attacker, which the application will then execute when the database file is opened and read.</target>
        </trans-unit>
        <trans-unit id="a82f5f85ed3a810b5bb82f46aed446a44b2ed973" translate="yes" xml:space="preserve">
          <source>For best security, the &lt;a href=&quot;c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag is recommended for all application-defined SQL functions that do not need to be used inside of triggers, view, CHECK constraints, or other elements of the database schema. This flags is especially recommended for SQL functions that have side effects or reveal internal application state. Without this flag, an attacker might be able to modify the schema of a database file to include invocations of the function with parameters chosen by the attacker, which the application will then execute when the database file is opened and read.</source>
          <target state="translated">For best security, the &lt;a href=&quot;c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag is recommended for all application-defined SQL functions that do not need to be used inside of triggers, view, CHECK constraints, or other elements of the database schema. This flags is especially recommended for SQL functions that have side effects or reveal internal application state. Without this flag, an attacker might be able to modify the schema of a database file to include invocations of the function with parameters chosen by the attacker, which the application will then execute when the database file is opened and read.</target>
        </trans-unit>
        <trans-unit id="ad7a915b64d6fe6bb79ac5b4ba72d86b2b8e4dad" translate="yes" xml:space="preserve">
          <source>For bitmask tests, &lt;code&gt;testcase()&lt;/code&gt; macros are used to verify that every bit of the bitmask affects the outcome. For example, in the following block of code, the condition is true if the mask contains either of two bits indicating either a MAIN_DB or a TEMP_DB is being opened. The &lt;code&gt;testcase()&lt;/code&gt; macros that precede the if statement verify that both cases are tested:</source>
          <target state="translated">ビットマスクテストでは、 &lt;code&gt;testcase()&lt;/code&gt; マクロを使用して、ビットマスクのすべてのビットが結果に影響することを確認します。たとえば、次のコードブロックでは、MAIN_DBまたはTEMP_DBが開かれていることを示す2つのビットのいずれかがマスクに含まれている場合、条件はtrueです。 &lt;code&gt;testcase()&lt;/code&gt; ステートメントは、両方のケースがテストされることを確認した場合に先行マクロ：</target>
        </trans-unit>
        <trans-unit id="1eab60de14b7b002b878e809e16b0c4001fb65d3" translate="yes" xml:space="preserve">
          <source>For both text and numeric values, NULL sorts before any other value. A comparison of any value against NULL using operators like &quot;&amp;lt;&quot; or &quot;&amp;gt;=&quot; is always false.</source>
          <target state="translated">テキストと数値の両方で、NULLは他の値の前にソートされます。&quot;&amp;lt;&quot;や &quot;&amp;gt; =&quot;などの演算子を使用した値とNULLの比較は常にfalseです。</target>
        </trans-unit>
        <trans-unit id="0001dc558eb2ab6e42a7bb8e2fadd29ee6f23dde" translate="yes" xml:space="preserve">
          <source>For brevity, the diagrams in this section are simplified from those that came before. Blue color still signifies original content and pink still signifies new content. But the individual pages in the rollback journal and the database file are not shown and we are not making the distinction between information in the operating system cache and information that is on disk. All of these factors still apply in a multi-file commit scenario. They just take up a lot of space in the diagrams and they do not add any new information, so they are omitted here.</source>
          <target state="translated">簡潔にするために、このセクションの図は以前のものを簡略化したものです。青色はまだオリジナルの内容を示し、ピンク色はまだ新しい内容を示しています。しかし、ロールバックジャーナルやデータベースファイルの個々のページは表示されておらず、オペレーティングシステムのキャッシュ内の情報とディスク上の情報を区別していません。これらの要素はすべて、マルチファイルコミットのシナリオにも適用されます。これらの要素は図の中で多くのスペースを取るだけで、新しい情報を追加するものではありませんので、ここでは省略します。</target>
        </trans-unit>
        <trans-unit id="4e31069a755a0df659f64899fd564b4a8cf6e824" translate="yes" xml:space="preserve">
          <source>For command-line usage, add the short style command-line options immediately following the &quot;-A&quot;, without an intervening space. All subsequent arguments are considered to be part of the .archive command. For example, the following commands are equivalent:</source>
          <target state="translated">コマンドラインで使用するためには、&quot;-A &quot;の直後にショートスタイルのコマンドラインオプションを追加し、間にスペースを入れないでください。それ以降のすべての引数は、.archiveコマンドの一部とみなされます。例えば、以下のコマンドは同等です。</target>
        </trans-unit>
        <trans-unit id="b9d0d974a63b482f33f7f36907a5721a5611077f" translate="yes" xml:space="preserve">
          <source>For commit records, the size of the database file in pages after the commit. For all other records, zero.</source>
          <target state="translated">コミットレコードの場合、コミット後のデータベースファイルのサイズをページ単位で指定します。それ以外のすべてのレコードでは、ゼロ。</target>
        </trans-unit>
        <trans-unit id="e91c377baed35ec4162bb3c1ca2f7aeb4671aa6f" translate="yes" xml:space="preserve">
          <source>For compatibility with older &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementations, this flag is turned on temporarily while the &lt;a href=&quot;vtab#xrename&quot;&gt;sqlite3_module.xRename&lt;/a&gt; method is being run. The value of this flag is restore after the &lt;a href=&quot;vtab#xrename&quot;&gt;sqlite3_module.xRename&lt;/a&gt; method finishes.</source>
          <target state="translated">古い&lt;a href=&quot;vtab&quot;&gt;仮想テーブルの&lt;/a&gt;実装との互換性のために、&lt;a href=&quot;vtab#xrename&quot;&gt;sqlite3_module.xRename&lt;/a&gt;メソッドの実行中にこのフラグが一時的にオンになります。このフラグの値は、&lt;a href=&quot;vtab#xrename&quot;&gt;sqlite3_module.xRename&lt;/a&gt;メソッドの完了後に復元されます。</target>
        </trans-unit>
        <trans-unit id="da9484ca4033054fc98b8e99fd5bf556ff20f8cb" translate="yes" xml:space="preserve">
          <source>For completeness, some of the higher level formatting information contains in the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; document and elsewhere is replicated here, when it pertains to WAL mode processing.</source>
          <target state="translated">完全を期すために、WALモードの処理に関連する場合、一部の上位レベルのフォーマット情報は&lt;a href=&quot;fileformat2&quot;&gt;ファイルフォーマット&lt;/a&gt;ドキュメントに含まれ、他の場所ではここで複製されます。</target>
        </trans-unit>
        <trans-unit id="e99fbef35a40e331c478cf6f191e30ae20bee3b1" translate="yes" xml:space="preserve">
          <source>For correct operation of the &lt;a href=&quot;cli#sqlar&quot;&gt;.archive command&lt;/a&gt;, make a copy of the &lt;a href=&quot;https://zlib.net&quot;&gt;zlib source code&lt;/a&gt; into the compat/zlib subdirectory of the source tree and compile this way:</source>
          <target state="translated">&lt;a href=&quot;cli#sqlar&quot;&gt;.archiveコマンドを&lt;/a&gt;正しく動作させるには、&lt;a href=&quot;https://zlib.net&quot;&gt;zlibソースコードの&lt;/a&gt;コピーをソースツリーのcompat / zlibサブディレクトリに作成し、次のようにコンパイルします。</target>
        </trans-unit>
        <trans-unit id="a28c51fc9c57d328cc18317fd43208e2e391d0d1" translate="yes" xml:space="preserve">
          <source>For device-local storage with low writer concurrency and less than a terabyte of content, SQLite is almost always a better solution. SQLite is fast and reliable and it requires no configuration or maintenance. It keeps thing simple. SQLite &quot;just works&quot;.</source>
          <target state="translated">ライターの同時実行性が低く、コンテンツの量がテラバイト未満のデバイスローカルストレージでは、ほとんどの場合 SQLite の方が優れたソリューションとなります。SQLite は高速で信頼性が高く、設定やメンテナンスも必要ありません。物事をシンプルに保つことができます。SQLite は「ただ動作するだけ」です。</target>
        </trans-unit>
        <trans-unit id="72afef4549faaf3eb91dc5ed7c4f9e5ba9217a77" translate="yes" xml:space="preserve">
          <source>For device-local storage with low writer concurrency and less than a terabyte of content, SQLite is almost always a better solution. SQLite is fast and reliable and it requires no configuration or maintenance. It keeps things simple. SQLite &quot;just works&quot;.</source>
          <target state="translated">ライターの同時実行性が低く、コンテンツの量がテラバイト未満のデバイスローカルストレージでは、ほとんどの場合 SQLite の方が優れたソリューションとなります。SQLite は高速で信頼性が高く、設定やメンテナンスが不要です。物事をシンプルに保つことができます。SQLite は「ただ動作するだけ」です。</target>
        </trans-unit>
        <trans-unit id="14026abb0078c30fcbc6bf88b3e2948c23e3f5c6" translate="yes" xml:space="preserve">
          <source>For doclists for which the term appears in more than one column of the FTS virtual table, term-offset lists within the doclist are stored in column number order. This ensures that the term-offset list associated with column 0 (if any) is always first, allowing the first two fields of the term-offset list to be omitted in this case.</source>
          <target state="translated">FTS 仮想テーブルの複数の列に用語が出現するドキュメントリストの場合、ドキュメントリスト内の用語オフセットリストは列番号順に格納されます。これにより、列 0 に関連付けられた条件オフセットリスト (もしあれば)が常に最初になり、この場合は条件オフセットリストの最初の 2 つのフィールドを省略することができます。</target>
        </trans-unit>
        <trans-unit id="89b4ec40df531b5b987432b4a7fed5ea5b3e27ac" translate="yes" xml:space="preserve">
          <source>For each DELETE change, the function checks if the target database contains a row with the same primary key value (or values) as the original row values stored in the changeset. If it does, and the values stored in all non-primary key columns also match the values stored in the changeset the row is deleted from the target database.</source>
          <target state="translated">各DELETE変更に対して、この関数はターゲットデータベースに、チェンジセットに格納されている元の行の値と同じ主キー値(または値)を持つ行が含まれているかどうかをチェックします。その場合、主キーではないすべてのカラムに格納されている値がチェンジセットに格納されている値と一致した場合、その行はターゲットデータベースから削除されます。</target>
        </trans-unit>
        <trans-unit id="1fb2d165bb57742263f5c19d2ad3dc7e863bddd8" translate="yes" xml:space="preserve">
          <source>For each FTS virtual table in a database, three to five real (non-virtual) tables are created to store the underlying data. These real tables are called &quot;shadow tables&quot;. The real tables are named &quot;%_content&quot;, &quot;%_segdir&quot;, &quot;%_segments&quot;, &quot;%_stat&quot;, and &quot;%_docsize&quot;, where &quot;%&quot; is replaced by the name of the FTS virtual table.</source>
          <target state="translated">データベース内の各FTS仮想テーブルに対して、基礎となるデータを格納するために3~5つのリアル(非仮想)テーブルが作成されます。これらのリアル・テーブルは &quot;シャドウ・テーブル&quot; と呼ばれます。実テーブルの名前は、&quot;%_content&quot;、&quot;%_segdir&quot;、&quot;%_segments&quot;、&quot;%_stat&quot;、および &quot;%_docsize&quot; で、&quot;%&quot; は FTS 仮想テーブルの名前に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="ca14bfe0c8ef783300da3fae2f2faf6123712788" translate="yes" xml:space="preserve">
          <source>For each INSERT change, an attempt is made to insert the new row into the database. If the changeset row contains fewer fields than the database table, the trailing fields are populated with their default values.</source>
          <target state="translated">各INSERT変更に対して、新しい行をデータベースに挿入する試みが行われます。チェンジセット行がデータベース・テーブルより少ないフィールドを含む場合、末尾のフィールドはデフォルト値で入力されます。</target>
        </trans-unit>
        <trans-unit id="af26a43594c40c8d5075b1d213281d1a0d5d674e" translate="yes" xml:space="preserve">
          <source>For each UPDATE change, the function checks if the target database contains a row with the same primary key value (or values) as the original row values stored in the changeset. If it does, and the values stored in all modified non-primary key columns also match the values stored in the changeset the row is updated within the target database.</source>
          <target state="translated">UPDATEの各変更に対して、この関数は、チェンジセットに格納されている元の行の値と同じ主キー値(または値)を持つ行がターゲットデータベースに含まれているかどうかをチェックします。その場合、変更された主キー以外のすべての列に格納されている値が、チェンジセットに格納されている値と一致した場合、その行はターゲットデータベース内で更新されます。</target>
        </trans-unit>
        <trans-unit id="4c2b6b338ac313921ef720ea9cbd33ced2c0a043" translate="yes" xml:space="preserve">
          <source>For each UPDATE change, the old.* and new.* values are exchanged.</source>
          <target state="translated">UPDATEの変更ごとに、old.*とnew.*の値が交換されます。</target>
        </trans-unit>
        <trans-unit id="d2a86ead2de9a7fdab60caec05b45cc30754d41b" translate="yes" xml:space="preserve">
          <source>For each cell in the r-tree structure (%_node table), that:</source>
          <target state="translated">r-tree 構造 (%_node テーブル)の各セルに対して、その。</target>
        </trans-unit>
        <trans-unit id="44564b0e8d37eeca09117cb0ce5677dfdd15f643" translate="yes" xml:space="preserve">
          <source>For each change for which there is a compatible table, an attempt is made to modify the table contents according to the UPDATE, INSERT or DELETE change. If a change cannot be applied cleanly, the conflict handler function passed as the fifth argument to sqlite3changeset_apply() may be invoked. A description of exactly when the conflict handler is invoked for each type of change is below.</source>
          <target state="translated">互換性のあるテーブルがある各変更に対して、UPDATE、INSERT、DELETEの変更に応じてテーブルの内容を変更しようとします。変更をきれいに適用できない場合、sqlite3changeset_apply()の第5引数として渡された競合ハンドラ関数が呼び出されます。以下に、各タイプの変更に対していつコンフリクトハンドラが呼び出されるかを正確に説明します。</target>
        </trans-unit>
        <trans-unit id="fabf5b0df1d79746c4d3b0f7c3d3e26095a89ed6" translate="yes" xml:space="preserve">
          <source>For each column in a row of the result, the name of that column is used as an index in to array and the value of the column is stored in the corresponding array entry. (Caution: If two or more columns in the result set of a query have the same name, then the last column with that name will overwrite prior values and earlier columns with the same name will be inaccessible.) The special array index * is used to store a list of column names in the order that they appear.</source>
          <target state="translated">結果の行の各カラムに対して、そのカラム名を配列のインデックスとして使用し、そのカラムの値を対応する配列エントリに格納します。(注意。クエリの結果セットに含まれる複数のカラムが同じ名前を持つ場合は、その名前を持つ最後のカラムがそれ以前の値を上書きし、同じ名前を持つそれ以前のカラムにはアクセスできなくなります)。特殊な配列インデックス*は、カラム名のリストを表示順に格納するために使用されます。</target>
        </trans-unit>
        <trans-unit id="c334738444e4ad47d383e7911a76c91bc19cd2c6" translate="yes" xml:space="preserve">
          <source>For each column, the average number of tokens in the text values stored in the column (considering all rows in the FTS4 table). This value is only available when querying FTS4 tables, not FTS3.</source>
          <target state="translated">各列について、その列に格納されているテキスト値の平均トークン数(FTS4テーブルの全行を考慮)。この値は、FTS3ではなく、FTS4テーブルへの問い合わせ時にのみ利用可能です。</target>
        </trans-unit>
        <trans-unit id="7a8f829d184d100e174a5aa5857d53deb24e800d" translate="yes" xml:space="preserve">
          <source>For each column, the length of the longest subsequence of phrase matches that the column value has in common with the query text. For example, if a table column contains the text 'a b c d e' and the query is 'a c &quot;d e&quot;', then the length of the longest common subsequence is 2 (phrase &quot;c&quot; followed by phrase &quot;d e&quot;).</source>
          <target state="translated">各列について、その列の値がクエリのテキストと共通しているフレーズの最長の部分一致の長さが計算されます。例えば、テーブルのカラムにテキスト 'a b c d e' があり、クエリが 'a c &quot;d e&quot;' の場合、最長の共通部分の長さは 2 (フレーズ &quot;c&quot; の後にフレーズ &quot;d e&quot; が続く)となります。</target>
        </trans-unit>
        <trans-unit id="a1353b0cd18d624357976b5c201f2ed175d084b1" translate="yes" xml:space="preserve">
          <source>For each column, the length of the value stored in the current row of the FTS4 table, in tokens. This value is only available when querying FTS4 tables, not FTS3. And only if the &quot;matchinfo=fts3&quot; directive was not specified as part of the &quot;CREATE VIRTUAL TABLE&quot; statement used to create the FTS4 table.</source>
          <target state="translated">各列について、FTS4テーブルの現在の行に格納されている値の長さをトークン単位で指定します。この値は、FTS3ではなくFTS4テーブルへの問い合わせ時にのみ利用可能です。また、FTS4テーブルを作成するために使用された &quot;CREATE VIRTUAL TABLE &quot;文の一部として &quot;matchinfo=fts3 &quot;指令が指定されていない場合に限ります。</target>
        </trans-unit>
        <trans-unit id="6e8b6483ba6be5818f8c523c79ce85a1e7ccc3ba" translate="yes" xml:space="preserve">
          <source>For each distinct combination of a phrase and table column, the following three values:</source>
          <target state="translated">フレーズと表欄の明確な組み合わせごとに、以下の3つの値を設定します。</target>
        </trans-unit>
        <trans-unit id="cf92fe281dadfcf306551aea2a8a2fccc4c37192" translate="yes" xml:space="preserve">
          <source>For each distinct combination of a phrase and table column, the number of usable phrase matches that appear in the column. This is usually identical to the first value in each set of three returned by the &lt;a href=&quot;fts3#matchinfo-x&quot; id=&quot;matchinfo-y&quot;&gt;matchinfo 'x' flag&lt;/a&gt;. However, the number of hits reported by the 'y' flag is zero for any phrase that is part of a sub-expression that does not match the current row. This makes a difference for expressions that contain AND operators that are descendants of OR operators. For example, consider the expression:</source>
          <target state="translated">フレーズとテーブルの列の組み合わせごとに、列に表示される使用可能なフレーズ一致の数。これは通常、&lt;a href=&quot;fts3#matchinfo-x&quot; id=&quot;matchinfo-y&quot;&gt;matchinfo 'x'フラグ&lt;/a&gt;によって返される3つの各セットの最初の値と同じです。ただし、「y」フラグで報告されるヒット数は、現在の行と一致しない部分式の一部であるフレーズについてはゼロです。これにより、OR演算子の子孫であるAND演算子を含む式に違いが生じます。たとえば、次の式について考えてみます。</target>
        </trans-unit>
        <trans-unit id="fffbd38440022e9244e6e0693275b0d19d1857ad" translate="yes" xml:space="preserve">
          <source>For each modified table, a changeset includes the following:</source>
          <target state="translated">変更された各テーブルに対して、チェンジセットには以下のものが含まれます。</target>
        </trans-unit>
        <trans-unit id="a24f08d30b83fb31d42fefd2e7c6a4eb2dab4115" translate="yes" xml:space="preserve">
          <source>For each pair of columns identified by a USING clause, the column from the right-hand dataset is omitted from the joined dataset. This is the only difference between a USING clause and its equivalent ON constraint.</source>
          <target state="translated">USING節で識別された列の各組について、右手のデータセットの列は結合されたデータセットから省略されます。これがUSING句と同等のON制約との唯一の違いです。</target>
        </trans-unit>
        <trans-unit id="9c5c3e6a930debab2d5dd5b538d4a23999481e17" translate="yes" xml:space="preserve">
          <source>For each primary key recorded as a result of an INSERT operation, the sessions module checks if there is a row with a matching primary key still in the table. If so, an INSERT change is added to the changeset.</source>
          <target state="translated">INSERT操作の結果として記録された各主キーについて、セッションモジュールは、テーブル内に一致する主キーを持つ行がまだ存在するかどうかをチェックします。存在する場合、INSERTの変更がチェンジセットに追加されます。</target>
        </trans-unit>
        <trans-unit id="829855e999389ecdd1577f6b633317b639cef854" translate="yes" xml:space="preserve">
          <source>For each primary key recorded as a result of an UPDATE or DELETE operation, the sessions module also checks for a row with a matching primary key within the table. If one can be found, but one or more of the non-PRIMARY KEY fields does not match the original recorded value, an UPDATE is added to the changeset. Or, if there is no row at all with the specified primary key, a DELETE is added to the changeset. If the row does exist but none of the non-PRIMARY KEY fields have been modified, no change is added to the changeset.</source>
          <target state="translated">UPDATEまたはDELETE操作の結果として記録された各プライマリキーについて、セッションモジュールはテーブル内に一致するプライマリキーを持つ行がないかどうかもチェックします。一致する主キーを持つ行が見つかりましたが、PRIMARY KEY以外のフィールドの1つまたは複数が元の記録された値と一致しない場合、UPDATEがチェンジセットに追加されます。または、指定された主キーを持つ行が全くない場合、DELETEがチェンジセットに追加されます。行が存在するが、非PRIMARY KEYフィールドのどれも変更されていない場合、変更はチェンジセットに追加されません。</target>
        </trans-unit>
        <trans-unit id="d07e7398b3da8e6434d5c2443839062a6f35040b" translate="yes" xml:space="preserve">
          <source>For each record generated by an insert, the database is queried for a row with a matching primary key. If one is found, an INSERT change is added to the changeset. If no such row is found, no change is added to the changeset.</source>
          <target state="translated">挿入によって生成された各レコードについて、データベースは一致する主キーを持つ行を検索します。一致する行が見つかった場合、INSERT 変更がチェンジセットに追加されます。そのような行が見つからない場合、変更はチェンジセットに追加されません。</target>
        </trans-unit>
        <trans-unit id="9651a17487870ac448b95f61451215a9e031bca7" translate="yes" xml:space="preserve">
          <source>For each record generated by an update or delete, the database is queried for a row with a matching primary key. If such a row is found and one or more of the non-primary key fields have been modified from their original values, an UPDATE change is added to the changeset. Or, if no such row is found in the table, a DELETE change is added to the changeset. If there is a row with a matching primary key in the database, but all fields contain their original values, no change is added to the changeset.</source>
          <target state="translated">更新または削除によって生成された各レコードについて、データベースは一致する主キーを持つ行を検索します。そのような行が見つかり、1つ以上の主キー以外のフィールドが元の値から変更されている場合、UPDATE変更がチェンジセットに追加されます。または、テーブル内にそのような行が見つからない場合、DELETE 変更がチェンジセットに追加されます。データベース内に一致する主キーを持つ行があるが、すべてのフィールドに元の値が含まれている場合、変更はチェンジセットに追加されません。</target>
        </trans-unit>
        <trans-unit id="1d85944e801be901ece01bab4a06681779097370" translate="yes" xml:space="preserve">
          <source>For each record in the first table, do:</source>
          <target state="translated">最初のテーブルの各レコードについては、実行します。</target>
        </trans-unit>
        <trans-unit id="db1b960f818a6af8cfaa2c24a19e780d2703af81" translate="yes" xml:space="preserve">
          <source>For each record in the second table do:</source>
          <target state="translated">2 番目のテーブルの各レコードのために行います。</target>
        </trans-unit>
        <trans-unit id="07832e91f880502fa8c96087f4d7417bdd043461" translate="yes" xml:space="preserve">
          <source>For each record in the table, do:</source>
          <target state="translated">テーブルの各レコードについては、実行します。</target>
        </trans-unit>
        <trans-unit id="87586acdd8d3aae53c73008136985fcb94271fa7" translate="yes" xml:space="preserve">
          <source>For each row (primary key) that exists in both tables, but features different non-PK values in each, an UPDATE record is added to the session.</source>
          <target state="translated">両方のテーブルに存在するが、それぞれのテーブルで異なる非PK値を持つ各行(主キー)について、UPDATEレコードがセッションに追加されます。</target>
        </trans-unit>
        <trans-unit id="6b65ebd60d0a165260cae83ea942ac1bc3113efb" translate="yes" xml:space="preserve">
          <source>For each row (primary key) that exists in the to-table but not in the from-table, a DELETE record is added to the session object.</source>
          <target state="translated">to-tableには存在するがfrom-tableには存在しない各行(主キー)について、DELETEレコードがセッションオブジェクトに追加されます。</target>
        </trans-unit>
        <trans-unit id="9d14fe0322a1c66d129265052088ccffec38ab12" translate="yes" xml:space="preserve">
          <source>For each row (primary key) that exists in the to-table but not in the from-table, an INSERT record is added to the session object.</source>
          <target state="translated">to-tableには存在するがfrom-tableには存在しない各行(主キー)について、セッション・オブジェクトにINSERTレコードが追加されます。</target>
        </trans-unit>
        <trans-unit id="cf4da03b9da8c161d1cf42bd495a3368247989f4" translate="yes" xml:space="preserve">
          <source>For each row in the FTS table, the %_docsize table contains a corresponding row with the same &quot;docid&quot; value. The &quot;size&quot; field contains a blob consisting of</source>
          <target state="translated">FTS テーブルの各行に対して、%_docsize テーブルには、同じ &quot;docid&quot; 値を持つ対応する行が含まれます。size&quot; フィールドには、以下からなるブロブが含まれます。</target>
        </trans-unit>
        <trans-unit id="a8c233269c53521f30c5ffc0bf77144b7402512d" translate="yes" xml:space="preserve">
          <source>For each row to DELETE from the target database as part of the RBU update, the corresponding data_% table should contain a single record with the &quot;rbu_control&quot; column set to contain integer value 1. The real primary key values of the row to delete should be stored in the corresponding columns of the data_% table. The values stored in the other columns are not used.</source>
          <target state="translated">RBU更新の一部としてターゲット・データベースからDELETEする各行に対して、対応するdata_%テーブルには、整数値1を含む &quot;rbu_control &quot;列が設定された1つのレコードが含まれている必要があります。削除する行の実主キー値は、data_%テーブルの対応する列に格納されるべきである。他の列に格納されている値は使用されません。</target>
        </trans-unit>
        <trans-unit id="6a5706b24e2b237dcb339a0ad1090fb73a23781f" translate="yes" xml:space="preserve">
          <source>For each row to INSERT into the target database as part of the RBU update, the corresponding data_% table should contain a single record with the &quot;rbu_control&quot; column set to contain integer value 0. The other columns should be set to the values that make up the new record to insert.</source>
          <target state="translated">RBU更新の一部としてターゲット・データベースにINSERTする各行に対して、対応するdata_%テーブルには、整数値0を含むように &quot;rbu_control &quot;列が設定された1つのレコードが含まれている必要があります。他の列は、挿入する新しいレコードを構成する値に設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="34669c17538b482482cba6957b264502d60d1060" translate="yes" xml:space="preserve">
          <source>For each row to UPDATE from the target database as part of the RBU update, the corresponding data_% table should contain a single record with the &quot;rbu_control&quot; column set to contain a value of type text. The real primary key values identifying the row to update should be stored in the corresponding columns of the data_% table row, as should the new values of all columns being update. The text value in the &quot;rbu_control&quot; column must contain the same number of characters as there are columns in the target database table, and must consist entirely of 'x' and '.' characters (or in some special cases 'd' - see below). For each column that is being updated, the corresponding character is set to 'x'. For those that remain as they are, the corresponding character of the rbu_control value should be set to '.'. For example, given the tables above, the update statement:</source>
          <target state="translated">RBU 更新の一部としてターゲット・データベースから UPDATE する各行について、対応する data_% テーブルには、&quot;rbu_control&quot; 列に text 型の値を含むように設定された 1 つのレコードが含まれている必要があります。更新する行を識別する実際の主キー値は、更新されるすべての列の新しい値と同様に、data_%テーブルの行の対応する列に格納される必要があります。rbu_control&quot; カラムのテキスト値は、ターゲット・データベース・テーブルのカラム数と同じ数の文字を含んでいなければならず、'x' と '.' の文字のみで構成されていなければなりません (特殊な場合は 'd' もあります-以下を参照)。更新される各カラムには、対応する文字が 'x' に設定されます。そのまま残っている列については、rbu_control 値の対応する文字を '.' に設定する必要があります。例えば、上記のテーブルを指定すると、更新文は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="a430b6812c406e37a693a08685ab05caa617b118" translate="yes" xml:space="preserve">
          <source>For each such constraint, the aConstraint[].iColumn field indicates which column appears on the left-hand side of the constraint. The first column of the virtual table is column 0. The rowid of the virtual table is column -1. The aConstraint[].op field indicates which operator is used. The SQLITE_INDEX_CONSTRAINT_* constants map integer constants into operator values. Columns occur in the order they were defined by the call to &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; in the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; or &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method. Hidden columns are counted when determining the column index.</source>
          <target state="translated">このような制約ごとに、aConstraint []。iColumnフィールドは、制約の左側に表示される列を示します。仮想テーブルの最初の列は列0です。仮想テーブルのROWIDは列-1です。 aConstraint []。opフィールドは、使用される演算子を示します。 SQLITE_INDEX_CONSTRAINT_ *定数は、整数定数を演算子値にマップします。列は、&lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;または&lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;メソッドでのsqlite3_declare_vtab &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;（）の&lt;/a&gt;呼び出しによって定義された順序で発生します。非表示の列は、列のインデックスを決定するときにカウントされます。</target>
        </trans-unit>
        <trans-unit id="f5aad29ac204438525f336e09bd7bc093d292717" translate="yes" xml:space="preserve">
          <source>For each table in the target database that will be modified by the update, a corresponding table is created within the RBU database. The RBU database table schema is not the same as that of the target database, but is derived from it as &lt;a href=&quot;rbu#database_tables&quot;&gt;described below&lt;/a&gt;.</source>
          <target state="translated">更新によって変更されるターゲットデータベースのテーブルごとに、対応するテーブルがRBUデータベース内に作成されます。RBUデータベーステーブルスキーマは、ターゲットデータベースのスキーマと同じではありませんが、&lt;a href=&quot;rbu#database_tables&quot;&gt;以下で説明するよう&lt;/a&gt;に、そこから派生します。</target>
        </trans-unit>
        <trans-unit id="f11dacd70a0954440fff36de5fbb6ca308465c38" translate="yes" xml:space="preserve">
          <source>For each table in the target database, the RBU database should contain a table named &quot;data&amp;lt;</source>
          <target state="translated">ターゲットデータベースの各テーブルについて、RBUデータベースには「data &amp;lt;</target>
        </trans-unit>
        <trans-unit id="42f788bf7b6ac170ed8ce05feddfec2cba592bef" translate="yes" xml:space="preserve">
          <source>For each table read by the query, the output of EXPLAIN QUERY PLAN includes a record for which the value in the &quot;detail&quot; column begins with either &quot;SCAN&quot; or &quot;SEARCH&quot;. &quot;SCAN&quot; is used for a full-table scan, including cases where SQLite iterates through all records in a table in an order defined by an index. &quot;SEARCH&quot; indicates that only a subset of the table rows are visited. Each SCAN or SEARCH record includes the following information:</source>
          <target state="translated">クエリによって読み込まれた各テーブルに対して、EXPLAIN QUERY PLANの出力には、&quot;detail &quot;列の値が &quot;SCAN &quot;または &quot;SEARCH &quot;のいずれかで始まるレコードが含まれる。&quot;SCAN &quot;は、SQLiteがインデックスによって定義された順序でテーブル内のすべてのレコードを反復処理する場合を含む、フルテーブルスキャンに使用されます。&quot;SEARCH &quot;は、テーブルの行のサブセットのみが訪問されることを示します。各 SCAN または SEARCH レコードには、以下の情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="ecba2625cd566548c3eee164f8360eb376f2aaad" translate="yes" xml:space="preserve">
          <source>For each table that is not excluded by the filter callback, this function tests that the target database contains a compatible table. A table is considered compatible if all of the following are true:</source>
          <target state="translated">この関数は、フィルタコールバックによって除外されない各テーブルについて、ターゲットデータベースに互換性のあるテーブルが含まれているかどうかをテストします。テーブルは、以下のすべてが真であれば互換性があるとみなされます。</target>
        </trans-unit>
        <trans-unit id="a67fb3e6d59fc22a676badf1b731424e48e59895" translate="yes" xml:space="preserve">
          <source>For each term in a document, the FTS index maintained by FTS5 stores the rowid of the document, the column number of the column that contains the term and the offset of the term within the column value. The &quot;detail&quot; option may be used to omit some of this information. This reduces the space that the index consumes within the database file, but also reduces the capability and efficiency of the system.</source>
          <target state="translated">文書内の各タームについて、FTS5によって保持されるFTSインデックスは、文書のrowid、タームを含むカラムのカラム番号、およびカラム値内のタームのオフセットを格納する。detail」オプションを使用すると、この情報の一部を省略することができます。これにより、インデックスがデータベースファイル内で消費するスペースが減りますが、システムの能力と効率が低下します。</target>
        </trans-unit>
        <trans-unit id="ec159e8f6dc1a68285f736b240d086ca832050e3" translate="yes" xml:space="preserve">
          <source>For each term present in the FTS table, there are between 2 and N+1 rows in the fts4aux table, where N is the number of user-defined columns in the associated FTS table. An fts4aux table always has the same four columns, as follows, from left to right:</source>
          <target state="translated">FTSテーブルに存在する各項に対して、fts4auxテーブルには2行からN+1行が存在し、Nは関連するFTSテーブルのユーザ定義列の数である。fts4auxテーブルは、左から右へ、以下のように、常に同じ4つの列を持つ。</target>
        </trans-unit>
        <trans-unit id="2bdf0037f493d99e63f11ef023d4ede2161885e4" translate="yes" xml:space="preserve">
          <source>For each token in the input string, the supplied callback xToken() must be invoked. The first argument to it should be a copy of the pointer passed as the second argument to xTokenize(). The third and fourth arguments are a pointer to a buffer containing the token text, and the size of the token in bytes. The 4th and 5th arguments are the byte offsets of the first byte of and first byte immediately following the text from which the token is derived within the input.</source>
          <target state="translated">入力文字列内の各トークンに対して、指定されたコールバックの xToken()を起動しなければなりません。第一引数には xTokenize()の第二引数として渡されたポインタのコピーを指定します。第三引数と第四引数には、トークンのテキストを含むバッファへのポインタと、トークンのサイズをバイト単位で指定します。第4引数と第5引数は、入力内でトークンが導出されたテキストの最初のバイトとその直後の最初のバイトのバイトオフセットである。</target>
        </trans-unit>
        <trans-unit id="77d69c67e1a2a185641c2031933b357307710ee5" translate="yes" xml:space="preserve">
          <source>For each token in the text fragment that is part of a phrase match, the &quot;start match&quot; text is inserted into the fragment before the token, and the &quot;end match&quot; text is inserted immediately after it.</source>
          <target state="translated">フレーズマッチの一部であるテキストフラグメント内の各トークンに対して、&quot;開始マッチ &quot;テキストがその前のフラグメントに挿入され、&quot;終了マッチ &quot;テキストがその直後に挿入されます。</target>
        </trans-unit>
        <trans-unit id="4d08b18694ad651bc6411787c4cb9cda3d56703c" translate="yes" xml:space="preserve">
          <source>For embedded systems, consider compiling SQLite with the &lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5&lt;/a&gt; option and then providing SQLite with a fixed chunk of memory to use as its heap via the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;) interface. This will prevent malicious SQL from executing a denial-of-service attack by using an excessive amount of memory. If (say) 5 MB of memory is provided for SQLite to use, once that much has been consumed, SQLite will start returning SQLITE_NOMEM errors rather than soaking up memory needed by other parts of the application. This also sandboxes SQLite's memory so that a write-after-free error in some other part of the application will not cause problems for SQLite, or vice versa.</source>
          <target state="translated">For embedded systems, consider compiling SQLite with the &lt;a href=&quot;compile#enable_memsys5&quot;&gt;-DSQLITE_ENABLE_MEMSYS5&lt;/a&gt; option and then providing SQLite with a fixed chunk of memory to use as its heap via the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;) interface. This will prevent malicious SQL from executing a denial-of-service attack by using an excessive amount of memory. If (say) 5 MB of memory is provided for SQLite to use, once that much has been consumed, SQLite will start returning SQLITE_NOMEM errors rather than soaking up memory needed by other parts of the application. This also sandboxes SQLite's memory so that a write-after-free error in some other part of the application will not cause problems for SQLite, or vice versa.</target>
        </trans-unit>
        <trans-unit id="4c5274d9826ac0360165a29a3e66a8506f1ab799" translate="yes" xml:space="preserve">
          <source>For every successful call to this method, the SQLite core will later invoke the &lt;a href=&quot;vtab#xclose&quot;&gt;xClose&lt;/a&gt; method to destroy the allocated cursor.</source>
          <target state="translated">このメソッドの呼び出しが成功するたびに、SQLiteコアは後で&lt;a href=&quot;vtab#xclose&quot;&gt;xClose&lt;/a&gt;メソッドを呼び出して、割り当てられたカーソルを破棄します。</target>
        </trans-unit>
        <trans-unit id="c6c48664cbefae23df70df3591300d92263e5f4c" translate="yes" xml:space="preserve">
          <source>For example to find the highest paid employee:</source>
          <target state="translated">例えば、最も高給取りの従業員を見つけるために。</target>
        </trans-unit>
        <trans-unit id="2479f1e642da058be56d1001ffac81d069a0ba6c" translate="yes" xml:space="preserve">
          <source>For example, a &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; statement cannot be run while another thread is reading from that table on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; because dropping the table would delete the table out from under the concurrent reader.</source>
          <target state="translated">たとえば、テーブルを削除すると、同時リーダーの下からテーブルが削除されるため、同じ&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続で&lt;/a&gt;別のスレッドがそのテーブルから読み取りを行っている間は、&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;ステートメントを実行できません。</target>
        </trans-unit>
        <trans-unit id="6761f7f398c5e173f6115ef00ea11329cb9f3d54" translate="yes" xml:space="preserve">
          <source>For example, a query like the following might be used to find all R*Tree entries that overlap with a circle centered a 45.3,22.9 with a radius of 5.0:</source>
          <target state="translated">例えば、以下のようなクエリを使用して、半径5.0の45.3,22.9を中心とする円と重なるR*Treeエントリをすべて見つけることができます。</target>
        </trans-unit>
        <trans-unit id="42fbeb339bf81a5c29e36447b781a19ea1d40440" translate="yes" xml:space="preserve">
          <source>For example, adding an &quot;ON UPDATE CASCADE&quot; clause to the foreign key as shown below enhances the example schema from section 1 to allow the user to update the artistid (the parent key of the foreign key constraint) column without breaking referential integrity:</source>
          <target state="translated">例えば、以下に示すように外部キーに &quot;ON UPDATE CASCADE&quot; 節を追加することで、セクション 1 のスキーマ例を強化し、参照整合性を壊すことなく artistid (外部キー制約の親キー)カラムを更新できるようにします。</target>
        </trans-unit>
        <trans-unit id="68a7b041107b28bf1e4e9feea5241e1ae83cb4f3" translate="yes" xml:space="preserve">
          <source>For example, as currently implemented, if writes are happening at a steady stream that exceeds the I/O capability of the background writer thread, the queue of pending write operations will grow without bound. If this goes on for long enough, the host system could run out of memory. A more sophisticated module could to keep track of the quantity of pending writes and stop accepting new write requests when the queue of pending writes grows too large.</source>
          <target state="translated">例えば、現在実装されているように、バックグラウンドのライタースレッドのI/O能力を超える安定したストリームで書き込みが行われている場合、保留中の書き込み操作のキューは制限なく増えていきます。これが長く続くと、ホストシステムはメモリを使い果たしてしまう可能性があります。より洗練されたモジュールは、保留中の書き込みの量を追跡し、保留中の書き込みのキューが大きくなりすぎたときに、新しい書き込み要求の受け入れを停止することができます。</target>
        </trans-unit>
        <trans-unit id="74530ffba7f866870009106e3c8e5c0a0af944ca" translate="yes" xml:space="preserve">
          <source>For example, given the database schema:</source>
          <target state="translated">例えば、データベーススキーマが与えられているとします。</target>
        </trans-unit>
        <trans-unit id="c7f52cca71f3aa80082462a01861b0a720f46594" translate="yes" xml:space="preserve">
          <source>For example, if a prepared statement is created using the SQL text &quot;SELECT $abc,:xyz&quot; and if parameter $abc is bound to integer 2345 and parameter :xyz is unbound, then sqlite3_sql() will return the original string, &quot;SELECT $abc,:xyz&quot; but sqlite3_expanded_sql() will return &quot;SELECT 2345,NULL&quot;.</source>
          <target state="translated">例えば、「SELECT $abc,:xyz」というSQLテキストを使用して準備された文が作成され、パラメータ$abcが整数2345にバインドされ、パラメータ:xyzがアンバインドされている場合、sqlite3_sql()は元の文字列「SELECT $abc,:xyz」を返しますが、sqlite3_expanded_sql()は「SELECT 2345,NULL」を返すことになります。</target>
        </trans-unit>
        <trans-unit id="06bed93067ff2c82141c677c5fde8b31f46e4d93" translate="yes" xml:space="preserve">
          <source>For example, if both the local and remote changesets contain an INSERT of the same key on &quot;CREATE TABLE t1(a PRIMARY KEY, b)&quot;:</source>
          <target state="translated">例えば、ローカルとリモートの両方のチェンジセットに &quot;CREATE TABLE t1(a PRIMARY KEY,b)&quot;で同じキーのINSERTが含まれている場合。</target>
        </trans-unit>
        <trans-unit id="336ff6fc840939163a24ab8fbcfd1876f5d7462b" translate="yes" xml:space="preserve">
          <source>For example, if each of the 517430 documents in the &quot;&lt;a href=&quot;http://www.cs.cmu.edu/~enron/&quot;&gt;Enron E-Mail Dataset&lt;/a&gt;&quot; is inserted into both an FTS table and an ordinary SQLite table created using the following SQL script:</source>
          <target state="translated">たとえば、 &quot; &lt;a href=&quot;http://www.cs.cmu.edu/~enron/&quot;&gt;Enron E-Mail Dataset&lt;/a&gt; &quot; 内の各517430ドキュメントが、FTSテーブルと、次のSQLスクリプトを使用して作成された通常のSQLiteテーブルの両方に挿入されたとします。</target>
        </trans-unit>
        <trans-unit id="9af2b0a0be2507f901ab349b61afc42441edaa60" translate="yes" xml:space="preserve">
          <source>For example, if nCol is the number of columns in the table, to determine if phrase p is present in column c:</source>
          <target state="translated">例えば、nColが表の列数である場合、c列にフレーズpが存在するかどうかを判断する。</target>
        </trans-unit>
        <trans-unit id="4ff402b57bb3c7de072fb37615e2f1f44b822435" translate="yes" xml:space="preserve">
          <source>For example, if process A is in the middle of a large write transaction and at the same time process B attempts to start a new write transaction, process B will get back an SQLITE_BUSY result because SQLite only supports one writer at a time. Process B will need to wait for process A to finish its transaction before starting a new transaction. The &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; and &lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt; interfaces and the &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;busy_timeout pragma&lt;/a&gt; are available to process B to help it deal with SQLITE_BUSY errors.</source>
          <target state="translated">たとえば、プロセスAが大きな書き込みトランザクションの途中にあり、同時にプロセスBが新しい書き込みトランザクションを開始しようとすると、SQLiteは一度に1つのライターしかサポートしないため、プロセスBはSQLITE_BUSYの結果を返します。プロセスBは、新しいトランザクションを開始する前に、プロセスAがトランザクションを完了するのを待つ必要があります。&lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout（）&lt;/a&gt;と&lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler（）&lt;/a&gt;インターフェースと&lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;busy_timeoutプラグマは&lt;/a&gt;、それがSQLITE_BUSYエラーに対処するために、プロセスBに利用可能です。</target>
        </trans-unit>
        <trans-unit id="d347b5f74f99e1b9952eb3244ae0159feff20d3e" translate="yes" xml:space="preserve">
          <source>For example, if the</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="c3622449954a6635d6d6221d72610b7472bd6c7b" translate="yes" xml:space="preserve">
          <source>For example, if the aConstraint[3].argvIndex is set to 1, then when xFilter is called, the argv[0] passed to xFilter will have the EXPR value of the aConstraint[3] constraint.</source>
          <target state="translated">例えば、aConstraint[3].argvIndexが1に設定されている場合、xFilterが呼び出されると、xFilterに渡されたargv[0]はaConstraint[3]制約のEXPR値を持つことになります。</target>
        </trans-unit>
        <trans-unit id="7f637c26bc4431eea662487596dfe6901f17e071" translate="yes" xml:space="preserve">
          <source>For example, if the following SQL is passed to &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt;:</source>
          <target state="translated">たとえば、次のSQLが&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab（）に&lt;/a&gt;渡された場合：</target>
        </trans-unit>
        <trans-unit id="9d9a182c3de2bb26679903dabe753f3a90f09588" translate="yes" xml:space="preserve">
          <source>For example, if you have a table column declared to be of type &quot;INTEGER&quot; and you try to insert a string, the column will look at the text string and see if it looks like a number. If the string does look like a number it is converted into a number and into an integer if the number does not have a fractional part, and stored that way. But if the string is not a well-formed number it is still stored as a string. A column with a type of &quot;TEXT&quot; tries to convert numbers into an ASCII-Text representation before storing them. But BLOBs are stored in TEXT columns as BLOBs because you cannot in general convert a BLOB into text.</source>
          <target state="translated">例えば、テーブルのカラムが &quot;INTEGER &quot;型であると宣言されていて、文字列を挿入しようとした場合、カラムは文字列を見て、それが数値に見えるかどうかを確認します。文字列が数値に見える場合は数値に変換され、小数部がない場合は整数に変換され、そのように保存されます。しかし、文字列が整形された数値でない場合は、文字列として保存されます。TEXT&quot; 型のカラムは、数値を格納する前に ASCII-Text 表現に変換しようとします。しかし、一般的にはBLOBをテキストに変換することはできないので、BLOBはBLOBとしてTEXTカラムに格納されます。</target>
        </trans-unit>
        <trans-unit id="2e8d78d9a4a4ef5a078d77893775dee024ca144a" translate="yes" xml:space="preserve">
          <source>For example, in gdb, to see the complete hierarchy of an Expr node (that is to say, the Expr node and all of its children), given a pointer &quot;pExpr&quot; to that node, type:</source>
          <target state="translated">例えば、gdbでは、Exprノード(つまり、Exprノードとそのすべての子ノード)の完全な階層を見るには、そのノードへのポインタ &quot;pExpr &quot;が与えられています。</target>
        </trans-unit>
        <trans-unit id="65de8cd85e7f9352044ea42fa34fc26263f7d653" translate="yes" xml:space="preserve">
          <source>For example, in the following call to json_object(), the</source>
          <target state="translated">例えば、以下の json_object()の呼び出しでは</target>
        </trans-unit>
        <trans-unit id="376c3a63c2d900eda2a882017f3f3a33aef34667" translate="yes" xml:space="preserve">
          <source>For example, information about the columns in an index can be read using the &lt;a href=&quot;pragma#pragma_index_info&quot;&gt;index_info pragma&lt;/a&gt; as follows:</source>
          <target state="translated">たとえば、インデックスの列に関する情報は、次のように&lt;a href=&quot;pragma#pragma_index_info&quot;&gt;index_infoプラグマ&lt;/a&gt;を使用して読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="6bccea8458a0de711e349540a29ecfcb98a65f40" translate="yes" xml:space="preserve">
          <source>For example, let the index be</source>
          <target state="translated">例えば、インデックスを</target>
        </trans-unit>
        <trans-unit id="3da423bea60d2f28b9bd6c6b606ccc9294140d5b" translate="yes" xml:space="preserve">
          <source>For example, many words of Greek origin begin with letters &quot;ps&quot; where the &quot;p&quot; is silent. Ex: psalm, pseudonym, psoriasis, psyche. In another example, many Scottish surnames can be spelled with an initial &quot;Mac&quot; or &quot;Mc&quot;. Thus, &quot;MacKay&quot; and &quot;McKay&quot; are both pronounced the same.</source>
          <target state="translated">例えば、ギリシャ語由来の多くの単語は、&quot;p &quot;が無音の &quot;ps &quot;で始まる。例:psalm,pseudonym,psoriasis,psyche.別の例では、多くのスコットランドの名字は、頭文字の &quot;Mac &quot;や &quot;Mc &quot;で綴られることがあります。このように、&quot;MacKay &quot;と &quot;McKay &quot;はどちらも同じ発音になります。</target>
        </trans-unit>
        <trans-unit id="20083fcfe31a171e687fd7f98763b1bd15a6a1ec" translate="yes" xml:space="preserve">
          <source>For example, say the SQL statement returns the following data when executed:</source>
          <target state="translated">例えば、SQL文を実行すると以下のようなデータが返ってくるとします。</target>
        </trans-unit>
        <trans-unit id="2fbaaa7d12d4edb21ff19c0963b0289115f32a55" translate="yes" xml:space="preserve">
          <source>For example, suppose an additional database is attached to the database connection using a statement like this:</source>
          <target state="translated">例えば、このようなステートメントを使用して、追加のデータベースをデータベース接続にアタッチしたとします。</target>
        </trans-unit>
        <trans-unit id="81c47bbba7e6d3bcfa83f9d58601629924b27df8" translate="yes" xml:space="preserve">
          <source>For example, suppose the input word is &quot;Paskagula&quot;. The phonetic key is &quot;BACACALA&quot; which is then truncated to 4 characters &quot;BACA&quot;. The edit distance is then run on the 4980 entries (out of 272,597 entries total) of the vocabulary whose k2 values begin with BACA, yielding &quot;Pascagoula&quot; as the best match.</source>
          <target state="translated">例えば、入力された単語が「パスカグラ」だとします。このとき、音声キーは &quot;BACACALA &quot;であり、これを4文字の &quot;BACA &quot;に切り捨てる。次に、k2値が &quot;BACA &quot;で始まる語彙の4980項目(合計272,597項目のうち)に対して編集距離が実行され、&quot;Pascagoula &quot;がベストマッチすることがわかります。</target>
        </trans-unit>
        <trans-unit id="bd462d6a706c77e5432cc4b960d8cc42361a6e96" translate="yes" xml:space="preserve">
          <source>For example, suppose you have a database of the members of a large organization where each person is assigned to a particular &quot;team&quot;. Each team has a &quot;leader&quot; who is also a member of that team. The table might look something like this:</source>
          <target state="translated">例えば、ある大きな組織のメンバーのデータベースを持っていて、各人が特定の「チーム」に割り当てられているとします。各チームには、そのチームのメンバーでもある「リーダー」がいます。そのテーブルは次のようになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="2d2ab8533e293c8a84090c9b6694f2a969c007bb" translate="yes" xml:space="preserve">
          <source>For example, suppose you have a table named &quot;t1&quot; with columns names &quot;a&quot;, &quot;b&quot;, and &quot;c&quot; and that you want to delete column &quot;c&quot; from this table. The following steps illustrate how this could be done:</source>
          <target state="translated">例えば、&quot;t1 &quot;というテーブルに &quot;a&quot;、&quot;b&quot;、&quot;c &quot;という名前の列があり、このテーブルから列 &quot;c &quot;を削除したいとします。以下の手順では、その方法を説明します。</target>
        </trans-unit>
        <trans-unit id="e8c74e845df3aa4e4554ece864cf2478aa417801" translate="yes" xml:space="preserve">
          <source>For example, suppose you wanted undo/redo on a class (table) that looks like this:</source>
          <target state="translated">例えば、以下のようなクラス(テーブル)を元に戻したりやり直したりしたいとします。</target>
        </trans-unit>
        <trans-unit id="c888ac7552fad64c94327f4d9dde6c1939c79ffa" translate="yes" xml:space="preserve">
          <source>For example, the &quot;generate_series&quot; extension (located in the &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/series.c&quot;&gt;ext/misc/series.c&lt;/a&gt; file in the &lt;a href=&quot;http://www.sqlite.org/src/tree?ci=trunk&quot;&gt;source tree&lt;/a&gt;) implements an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt; with the following schema:</source>
          <target state="translated">たとえば、「generate_series」拡張（&lt;a href=&quot;http://www.sqlite.org/src/tree?ci=trunk&quot;&gt;ソースツリー&lt;/a&gt;の&lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/series.c&quot;&gt;ext / misc / series.c&lt;/a&gt;ファイルにあります）は、次のスキーマを使用して、&lt;a href=&quot;vtab#epovtab&quot;&gt;名義の仮想テーブル&lt;/a&gt;を実装します。</target>
        </trans-unit>
        <trans-unit id="a41d4a0a2c571159c4d3d9a9bcfe397816127e93" translate="yes" xml:space="preserve">
          <source>For example, the first argument to the &lt;a href=&quot;fts3#snippet&quot;&gt;snippet()&lt;/a&gt; function is supposed to be a special column of the FTS3 table that contains a pointer to an fts3cursor object that contains information about the current full text search match. That pointer was formerly passed as a BLOB. For example, if the FTS3 table is named &quot;t1&quot; and has a column named &quot;cx&quot;, one might write:</source>
          <target state="translated">たとえば、&lt;a href=&quot;fts3#snippet&quot;&gt;snippet（）&lt;/a&gt;関数の最初の引数は、現在の全文検索の一致に関する情報を含むfts3cursorオブジェクトへのポインターを含むFTS3テーブルの特別な列であると想定されています。そのポインタは、以前はBLOBとして渡されていました。たとえば、FTS3テーブルの名前が「t1」で、「cx」という名前の列がある場合、次のように記述できます。</target>
        </trans-unit>
        <trans-unit id="a1719c0fad0c46d95494599fc76472814afb3096" translate="yes" xml:space="preserve">
          <source>For example, the following EXPLAIN QUERY PLAN command operates on a SELECT statement that is implemented by performing a full-table scan on table t1:</source>
          <target state="translated">例えば、以下のEXPLAIN QUERY PLANコマンドは、テーブルt1に対してフルテーブルスキャンを実行することで実装されるSELECT文に対して動作します。</target>
        </trans-unit>
        <trans-unit id="f54bfe9858a294d74efc1029b390f83e76127bc5" translate="yes" xml:space="preserve">
          <source>For example, the following JSON describes an isosceles triangle, sitting on the X axis and with an area of 0.5:</source>
          <target state="translated">例えば、次のJSONは、X軸上に位置し、面積が0.5の二等辺三角形を記述しています。</target>
        </trans-unit>
        <trans-unit id="83a6fbeea816f56be60daf62a9ac68c383f63398" translate="yes" xml:space="preserve">
          <source>For example, the following code implements a collating sequence called &quot;NOCASE&quot; that sorts in text order without regard to case:</source>
          <target state="translated">例えば、以下のコードは、&quot;NOCASE &quot;と呼ばれる照合シーケンスを実装したもので、大文字小文字を問わずにテキスト順にソートします。</target>
        </trans-unit>
        <trans-unit id="9c27a0d3845f1eceb95943662637d42bbbaddf2a" translate="yes" xml:space="preserve">
          <source>For example, the following statement is valid in SQLite:</source>
          <target state="translated">例えば、SQLiteでは次のような文が有効です。</target>
        </trans-unit>
        <trans-unit id="c949165d26ebc110da68da66e13bc86685e04c18" translate="yes" xml:space="preserve">
          <source>For example, the values NULL, 0.0, 0, 'english' and '0' are all considered to be false. Values 1, 1.0, 0.1, -0.1 and '1english' are considered to be true.</source>
          <target state="translated">例えば、値 NULL,0.0,0,'english' と '0' はすべて false とみなされます。値 1,1.0,0.1,-0.1,'1english' は真とみなされます。</target>
        </trans-unit>
        <trans-unit id="a80abcae23d48d4d5c71b5964b931b771a14df0d" translate="yes" xml:space="preserve">
          <source>For example, this row:</source>
          <target state="translated">例えば、この行。</target>
        </trans-unit>
        <trans-unit id="f0774215613f5a93e554bf719be214f376054f20" translate="yes" xml:space="preserve">
          <source>For example, to avoid adding the contents of the &quot;uuid&quot; field to the FTS index:</source>
          <target state="translated">例えば、「uuid」フィールドの内容をFTSインデックスに追加しないようにする。</target>
        </trans-unit>
        <trans-unit id="e25e9fcbc6cbbe4aa86a860fba9ee3e23406906c" translate="yes" xml:space="preserve">
          <source>For example, to create a new SQLite database named &quot;ex1&quot; with a single table named &quot;tbl1&quot;, you might do this:</source>
          <target state="translated">例えば、&quot;ex1 &quot;という名前の新しいSQLiteデータベースを作成し、&quot;tbl1 &quot;という名前の単一のテーブルを作成するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="0a8b8eec2dca22f4460d3c1b6d1607de62d83c18" translate="yes" xml:space="preserve">
          <source>For example, to create an archive containing two text files, &quot;a.txt&quot; and &quot;b.txt&quot;, containing the text &quot;abc&quot; and &quot;123&quot; respectively:</source>
          <target state="translated">例えば、&quot;a.txt &quot;と &quot;b.txt &quot;という2つのテキストファイルを含むアーカイブを作成するには、それぞれ &quot;abc &quot;と &quot;123 &quot;というテキストが含まれています。</target>
        </trans-unit>
        <trans-unit id="e1c45bec4422b2834e5d74273014f0905a33b70e" translate="yes" xml:space="preserve">
          <source>For example, to inspect the contents of zip archive &quot;test.zip&quot; from the current directory:</source>
          <target state="translated">例えば、カレントディレクトリからzipアーカイブ「test.zip」の内容を検査するには、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="460920e6960fc9166bdf09c3d3e3d2d1b9cb1172" translate="yes" xml:space="preserve">
          <source>For example, to optimize the full-text index for an FTS table named &quot;docs&quot;:</source>
          <target state="translated">例えば、「docs」という名前のFTSテーブルのフルテキストインデックスを最適化するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="8112859719fda223d11dd9ecc671a2d731113a48" translate="yes" xml:space="preserve">
          <source>For example, to see a list of the tables in the database, you can enter &quot;.tables&quot;.</source>
          <target state="translated">例えば、データベース内のテーブルの一覧を表示するには、「.tables」と入力します。</target>
        </trans-unit>
        <trans-unit id="3403f20bef06b9f62c829264d38a448f07fbf25f" translate="yes" xml:space="preserve">
          <source>For example, using the tables created above:</source>
          <target state="translated">例えば、上記で作成した表を使って</target>
        </trans-unit>
        <trans-unit id="8baebd4e0fce8f0dca8a23890fbbeb7b6c6bd6f4" translate="yes" xml:space="preserve">
          <source>For example, when a document containing the text &quot;Right now, they're very frustrated.&quot;, the terms extracted from the document and added to the full-text index are, in order, &quot;right now they re very frustrated&quot;. Such a document would match a full-text query such as &quot;MATCH 'Frustrated'&quot;, as the simple tokenizer transforms the term in the query to lowercase before searching the full-text index.</source>
          <target state="translated">例えば、&quot;Right now,they're very frustrated.&quot;というテキストを含む文書があった場合、その文書から抽出されて全文インデックスに追加される用語は、&quot;right now they're very frustrated &quot;の順になります。このような文書は、全文インデックスを検索する前に、単純なトークナイザーがクエリ内の用語を小文字に変換するので、&quot;MATCH 'Frustrated'&quot;のような全文クエリにマッチします。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="0dc693a709e03c8a242ebc99f829d5a5f0d7f07e" translate="yes" xml:space="preserve">
          <source>For examples of how the SQLite C/C++ interface can be used, refer to the source code for the &lt;b&gt;sqlite&lt;/b&gt; program in the file &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;src/shell.c&lt;/a&gt; of the source tree. Additional information about sqlite is available at &lt;a href=&quot;cli&quot;&gt;cli.html&lt;/a&gt;. See also the sources to the Tcl interface for SQLite in the source file &lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;src/tclsqlite.c&lt;/a&gt;.</source>
          <target state="translated">SQLite C / C ++インターフェースの使用例については、ソースツリーの&lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;src / shell.c&lt;/a&gt;ファイルにある&lt;b&gt;sqlite&lt;/b&gt;プログラムのソースコードを参照してください。sqliteの詳細については、&lt;a href=&quot;cli&quot;&gt;cli.htmlを参照&lt;/a&gt;してください。ソースファイル&lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;src / tclsqlite.cの&lt;/a&gt; SQLiteのTclインターフェイスのソースも参照してください。</target>
        </trans-unit>
        <trans-unit id="db416b5f222a1960fcc408837e83b440afa98ccd" translate="yes" xml:space="preserve">
          <source>For floating-point substitutions (%e, %E, %f, %g, %G) the precision specifies the number of digits to display to the right of the decimal point.</source>
          <target state="translated">浮動小数点置換 (%e,%E,%f,%g,%G)の場合、精度は小数点の右側に表示する桁数を指定します。</target>
        </trans-unit>
        <trans-unit id="cf9d217953f034811d5791d9759455b504d70d86" translate="yes" xml:space="preserve">
          <source>For full prefix support, method (3) may be preferred. In this case, because the index contains entries for both &quot;first&quot; and &quot;1st&quot;, prefix queries such as 'fi*' or '1s*' will match correctly. However, because extra entries are added to the FTS index, this method uses more space within the database.</source>
          <target state="translated">プレフィックスを完全にサポートするには、(3)の方法が好ましいかもしれません。この場合、インデックスには &quot;first&quot; と &quot;1st&quot; の両方のエントリが含まれているため、'fi*' や '1s*' のようなプレフィックスクエリが正しくマッチします。ただし、FTS インデックスに余分なエントリが追加されるため、この方法ではデータベース内のスペースをより多く使用します。</target>
        </trans-unit>
        <trans-unit id="af625b5ec940a13ac3f0b796c61917d55c083bf9" translate="yes" xml:space="preserve">
          <source>For functions that accept &quot;</source>
          <target state="translated">を受け入れる関数の場合</target>
        </trans-unit>
        <trans-unit id="8e0c304ceb8d93d914d671ff91751c10ea1ee104" translate="yes" xml:space="preserve">
          <source>For functions that accept JSON as their first argument, that argument can be a JSON object, array, number, string, or null. SQLite numeric values and NULL values are interpreted as JSON numbers and nulls, respectively. SQLite text values can be understood as JSON objects, arrays, or strings. If an SQLite text value that is not a well-formed JSON object, array, or string is passed into json1 function, that function will usually throw an error. (Exceptions to this rule are &lt;a href=&quot;json1#jvalid&quot;&gt;json_valid()&lt;/a&gt; and &lt;a href=&quot;json1#jquote&quot;&gt;json_quote()&lt;/a&gt;.)</source>
          <target state="translated">最初の引数としてJSONを受け入れる関数の場合、その引数はJSONオブジェクト、配列、数値、文字列、またはnullにすることができます。 SQLiteの数値とNULL値は、それぞれJSON番号とnullとして解釈されます。 SQLiteテキスト値は、JSONオブジェクト、配列、または文字列として理解できます。整形式のJSONオブジェクト、配列、または文字列ではないSQLiteテキスト値がjson1関数に渡されると、その関数は通常エラーをスローします。 （このルールの例外は、&lt;a href=&quot;json1#jvalid&quot;&gt;json_valid（）&lt;/a&gt;および&lt;a href=&quot;json1#jquote&quot;&gt;json_quote（）&lt;/a&gt;です。）</target>
        </trans-unit>
        <trans-unit id="f4454df1a142f9ac3cdff944002d68d2bfdcbcbb" translate="yes" xml:space="preserve">
          <source>For functions that accept PATH arguments, that PATH must be well-formed or else the function will throw an error. A well-formed PATH is a text value that begins with exactly one '$' character followed by zero or more instances of &quot;.</source>
          <target state="translated">PATH 引数を受け取る関数の場合、その PATH は整形されていなければなりません。整形された PATH とは、正確に 1 つの '$' 文字で始まるテキスト値の後に &quot;.</target>
        </trans-unit>
        <trans-unit id="8848d7d3d9820023afd4f5c595baf809ffcb7c92" translate="yes" xml:space="preserve">
          <source>For general use in cases where the workload contains few UPDATE or DELETE operations, a good choice for automerge is 8. If the workload contains many UPDATE or DELETE commands, or if query speed is a concern, it may be advantageous to reduce automerge to 2.</source>
          <target state="translated">一般的に、ワークロードにUPDATEやDELETE操作がほとんどない場合には、オートマージを8にするのが良いでしょう。 ワークロードにUPDATEやDELETEコマンドが多く含まれている場合や、クエリの速度が気になる場合には、オートマージを2にした方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="bf5110604d852a2448723644607996c9499bf3c7" translate="yes" xml:space="preserve">
          <source>For historic compatibility, the C-language interfaces return primary result codes by default. The extended result code for the most recent error can be retrieved using the &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_extended_errcode()&lt;/a&gt; interface. The &lt;a href=&quot;c3ref/extended_result_codes&quot;&gt;sqlite3_extended_result_codes()&lt;/a&gt; interface can be used to put a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; into a mode where it returns the extended result codes instead of the primary result codes.</source>
          <target state="translated">歴史的な互換性のために、C言語インターフェイスはデフォルトでプライマリ結果コードを返します。最新のエラーの拡張結果コードは、&lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_extended_errcode（）&lt;/a&gt;インターフェースを使用して取得できます。&lt;a href=&quot;c3ref/extended_result_codes&quot;&gt;sqlite3_extended_result_codes（）&lt;/a&gt;インターフェースを置くために使用することができる&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;が拡張結果コードの代わりに、一次結果コードを返すモードにします。</target>
        </trans-unit>
        <trans-unit id="17b53a99ea41c50893270b0043884f065027650e" translate="yes" xml:space="preserve">
          <source>For historical reasons, and for efficiency, all sorting is currently done in memory.</source>
          <target state="translated">歴史的な理由と効率化のため、現在はすべてのソートがメモリ内で行われています。</target>
        </trans-unit>
        <trans-unit id="eeed22fa30af9d54901acfbf4c1ce1f017feb462" translate="yes" xml:space="preserve">
          <source>For integer substitutions (%d, %i, %x, %X, %o, and %p) the precision specifies minimum number of digits to display. Leading zeros are added if necessary, to expand the output to the minimum number of digits.</source>
          <target state="translated">整数置換 (%d、%i、%x、%X、%o、および %p)の場合、精度は表示する最小桁数を指定します。必要に応じて先頭のゼロが追加され、出力を最小桁数に拡張します。</target>
        </trans-unit>
        <trans-unit id="6f753dacad85542947673dd8fa7db3bccc0a7592" translate="yes" xml:space="preserve">
          <source>For maximum reliability and for robustness against database corruption, SQLite should always be run with its default synchronous setting of FULL.</source>
          <target state="translated">最大限の信頼性とデータベースの破損に対する堅牢性を確保するために、SQLite は常にデフォルトの同期設定 FULL で実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="489e54409f8b7e0829c336efb96f4282b5ccf13a" translate="yes" xml:space="preserve">
          <source>For more details, refer to the comments in &lt;a href=&quot;http://sqlite.org/src/doc/trunk/ext/rbu/sqlite3rbu.h&quot;&gt;header file sqlite3rbu.h&lt;/a&gt;.</source>
          <target state="translated">詳細については、&lt;a href=&quot;http://sqlite.org/src/doc/trunk/ext/rbu/sqlite3rbu.h&quot;&gt;ヘッダーファイルsqlite3rbu.hの&lt;/a&gt;コメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="4e6f70ecf49e4210656602d693e569fcb03d8193" translate="yes" xml:space="preserve">
          <source>For most applications, the recommended method for building SQLite is to use &lt;a href=&quot;amalgamation&quot;&gt;the amalgamation&lt;/a&gt; code file, &lt;b&gt;sqlite3.c&lt;/b&gt;, and its corresponding header file &lt;b&gt;sqlite3.h&lt;/b&gt;. The sqlite3.c code file should compile and run on any unix, Windows system without any changes or special compiler options. Most applications can simply include the sqlite3.c file together with the other C code files that make up the application, compile them all together, and have working and well configured version of SQLite.</source>
          <target state="translated">ほとんどのアプリケーションで、SQLiteの構築に推奨される方法は&lt;a href=&quot;amalgamation&quot;&gt;、統合&lt;/a&gt;コードファイル&lt;b&gt;sqlite3.c&lt;/b&gt;とそれに対応するヘッダーファイル&lt;b&gt;sqlite3.hを使用すること&lt;/b&gt;です。 sqlite3.cコードファイルは、変更や特別なコンパイラオプションを使用せずに、UNIXのWindowsシステムでコンパイルして実行する必要があります。ほとんどのアプリケーションは、アプリケーションを構成する他のCコードファイルと一緒にsqlite3.cファイルを単純にインクルードし、それらをすべてコンパイルして、SQLiteの適切に構成されたバージョンを機能させることができます。</target>
        </trans-unit>
        <trans-unit id="99e3c9a88b32764d83bb0da10699b12fcd9a531f" translate="yes" xml:space="preserve">
          <source>For most applications, upgrading from the legacy query planner to the NGQP requires little thought or effort. Simply replace the older SQLite version with the newer version of SQLite and recompile and the application will run faster. There are no API changes nor modifications to compilation procedures.</source>
          <target state="translated">ほとんどのアプリケーションでは、従来のクエリプランナーからNGQPへのアップグレードは、ほとんど考えも努力も必要ありません。古いバージョンのSQLiteを新しいバージョンのSQLiteに置き換えて再コンパイルするだけで、アプリケーションはより速く実行されます。APIの変更やコンパイル手順の変更はありません。</target>
        </trans-unit>
        <trans-unit id="0efe87a820fa8cd327d2f74d3e3f1deb32107fb9" translate="yes" xml:space="preserve">
          <source>For most cases, it is true that potential attackers have no way of injecting arbitrary SQL, and so most uses of SQLite are immune to the attack above. But there are some notable exceptions. To wit:</source>
          <target state="translated">ほとんどの場合、潜在的な攻撃者が任意の SQL を注入する方法がないことは事実であり、SQLite のほとんどの用途では上記の攻撃を受けることはありません。しかし、いくつかの顕著な例外があります。それは、以下のような場合です。</target>
        </trans-unit>
        <trans-unit id="c86754da6df36988096aed27dea948d5f58eceba" translate="yes" xml:space="preserve">
          <source>For most non-trivial SQL databases, the key to performance is creating the right SQL indexes. In this context &quot;the right SQL indexes&quot; means those that cause the queries that an application needs to optimize run fast. The &quot;.expert&quot; command can assist with this by proposing indexes that might assist with specific queries, were they present in the database.</source>
          <target state="translated">ほとんどの非自明なSQLデータベースでは、パフォーマンスの鍵となるのは正しいSQLインデックスを作成することです。ここでいう「正しいSQLインデックス」とは、アプリケーションが最適化する必要のあるクエリを高速に実行するためのインデックスを意味します。.expert」コマンドは、特定のクエリを支援する可能性のあるインデックスがデータベースに存在する場合に、それを提案することでこれを支援します。</target>
        </trans-unit>
        <trans-unit id="e0fd582fdc761484a0a0ca3bb5f583aafab7cdf5" translate="yes" xml:space="preserve">
          <source>For most purposes, SQLite can be built just fine using the default compilation options. However, if required, the compile-time options documented below can be used to &lt;a href=&quot;#omitfeatures&quot;&gt;omit SQLite features&lt;/a&gt; (resulting in a &lt;a href=&quot;footprint&quot;&gt;smaller compiled library size&lt;/a&gt;) or to change the &lt;a href=&quot;#defaults&quot;&gt;default values&lt;/a&gt; of some parameters.</source>
          <target state="translated">ほとんどの目的で、SQLiteはデフォルトのコンパイルオプションを使用して問題なく構築できます。ただし、必要に応じて、以下で説明するコンパイル時オプションを使用して、&lt;a href=&quot;#omitfeatures&quot;&gt;SQLite機能&lt;/a&gt;を省略したり（結果として、&lt;a href=&quot;footprint&quot;&gt;コンパイル済みライブラリのサイズを小さくし&lt;/a&gt;たり）、一部のパラメーターの&lt;a href=&quot;#defaults&quot;&gt;デフォルト値&lt;/a&gt;を変更したりできます。</target>
        </trans-unit>
        <trans-unit id="932b2392df531ace28cd032a80948aba14e668af" translate="yes" xml:space="preserve">
          <source>For much of its history SQLite has been focused on 100% MC/DC testing. Resistance to fuzzing attacks only became a concern with the introduction of AFL in 2014. For a while there, fuzzers were finding many problems in SQLite. In more recent years, the testing strategy of SQLite has evolved to place more emphasis on fuzz testing. We still maintain 100% MC/DC of the core SQLite code, but most testing CPU cycles are now devoted to fuzzing.</source>
          <target state="translated">その歴史の多くの間、SQLiteは100%MC/DCテストに焦点を当ててきました。ファジング攻撃への耐性が懸念されるようになったのは、2014年にAFLが導入されてからです。そこでのしばらくの間、ファジング攻撃はSQLiteに多くの問題を発見していました。近年では、SQLiteのテスト戦略はファズテストをより重視するように進化しています。私たちは今でもSQLiteのコアコードの100%MC/DCを維持していますが、テストのCPUサイクルのほとんどがファズに費やされるようになりました。</target>
        </trans-unit>
        <trans-unit id="be3d8fa3ad8b3f16b5f81b3d35db241bab90e030" translate="yes" xml:space="preserve">
          <source>For multi-threaded applications that are careful about how they manage threads, SQLite supports an alternative run-time configuration that is half way between not using any mutexes and the default situation of mutexing everything in sight. This in-the-middle mutex alignment can be established as follows:</source>
          <target state="translated">スレッドの管理方法に注意を払っているマルチスレッドアプリケーションのために、SQLiteはミューテックスを一切使用しないことと、目の前にあるすべてのものをミューテックスで処理するというデフォルトの状況との中間的なランタイム設定をサポートしています。この中間的なミューテックスの配置は、以下のように設定することができます。</target>
        </trans-unit>
        <trans-unit id="5bfaf72720042391e9725050a2097ea765a5277e" translate="yes" xml:space="preserve">
          <source>For newer applications, FTS4 is recommended; though if compatibility with older versions of SQLite is important, then FTS3 will usually serve just as well.</source>
          <target state="translated">しかし、古いバージョンの SQLite との互換性が重要な場合は、FTS3 で十分に機能します。</target>
        </trans-unit>
        <trans-unit id="74f1cec569d928f5163be03c8f3a97d88c4bb5d9" translate="yes" xml:space="preserve">
          <source>For non-TEMP triggers, the table to be modified or queried must exist in the same database as the table or view to which the trigger is attached. TEMP triggers are not subject to the same-database rule. A TEMP trigger is allowed to query or modify any table in any &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed database.</source>
          <target state="translated">非TEMPトリガーの場合、変更または照会されるテーブルは、トリガーがアタッチされているテーブルまたはビューと同じデータベースに存在する必要があります。TEMPトリガーは、同じデータベースのルールの対象ではありません。TEMPトリガーは、任意の&lt;a href=&quot;lang_attach&quot;&gt;ATTACHされた&lt;/a&gt;データベース内の任意のテーブルを照会または変更することができます。</target>
        </trans-unit>
        <trans-unit id="eaf4afda655b698c5089cf162bb3637b1ddce067" translate="yes" xml:space="preserve">
          <source>For numeric data, this situation is more complex. If both inputs look like well-formed numbers, then they are converted into floating point values using &lt;b&gt;atof()&lt;/b&gt; and compared numerically. If one input is not a well-formed number but the other is, then the number is considered to be less than the non-number. If neither inputs is a well-formed number, then &lt;b&gt;strcmp()&lt;/b&gt; is used to do the comparison.</source>
          <target state="translated">数値データの場合、この状況はより複雑です。両方の入力が整形式の数値のように見える場合、それらは&lt;b&gt;atof（）&lt;/b&gt;を使用して浮動小数点値に変換され、数値的に比較されます。 1つの入力が整形式の数値ではなく、もう1つの入力の場合、数値は非数値よりも小さいと見なされます。どちらの入力も整形式の数値ではない場合、比較には&lt;b&gt;strcmp（）&lt;/b&gt;が使用されます。</target>
        </trans-unit>
        <trans-unit id="11d66790f63457992337a522f75d0ba8c19d49c3" translate="yes" xml:space="preserve">
          <source>For ordinary FTS3/FTS4 queries, the search tree depth is approximately the base-2 logarithm of the number of terms in the right-hand side of the MATCH operator. However, for &lt;a href=&quot;fts3#phrase&quot;&gt;phrase queries&lt;/a&gt; and &lt;a href=&quot;fts3#near&quot;&gt;NEAR queries&lt;/a&gt; the search tree depth is linear in the number of right-hand side terms. So the default depth limit of 12 is sufficient for up to 4095 ordinary terms on a MATCH, it is only sufficient for 11 or 12 phrase or NEAR terms. Even so, the default is more than enough for most application.</source>
          <target state="translated">通常のFTS3 / FTS4クエリの場合、検索ツリーの深さは、MATCH演算子の右側の項数の2を底とする対数です。ただし、&lt;a href=&quot;fts3#phrase&quot;&gt;フレーズクエリ&lt;/a&gt;と&lt;a href=&quot;fts3#near&quot;&gt;NEARクエリの場合&lt;/a&gt;、検索ツリーの深さは右側の用語の数に比例します。したがって、デフォルトの深さ制限12は、MATCHの最大4095の通常の用語には十分であり、11または12のフレーズまたはNEAR用語にのみ十分です。それでも、ほとんどのアプリケーションではデフォルトで十分です。</target>
        </trans-unit>
        <trans-unit id="87e6be4eb608f1997fb25355e4537ee88db28dd4" translate="yes" xml:space="preserve">
          <source>For performance measurement, SQLite is compiled in approximately the same way as it would be for use in production systems. The compile-time configuration is &quot;approximate&quot; in the sense that every production use of SQLite is different. Compile-time options used by one system are not necessarily the same as those used by others. The key point is that options that significantly impact the generated machine code are avoided. For example, the -DSQLITE_DEBUG option is omitted because that option inserts thousands of assert() statements in the middle of performance critical sections of the SQLite library. The -pg option (on GCC) is omitted because it causes the compiler to emit extra probabilistic performance measuring code which interferes with actual performance measurements.</source>
          <target state="translated">パフォーマンス測定のために、SQLite は本番システムで使用する場合とほぼ同じ方法でコンパイルされています。コンパイル時の設定は、SQLiteの本番システムでの使用方法がそれぞれ異なるという意味で「近似的」です。あるシステムで使用されているコンパイル時のオプションは、他のシステムで使用されているものと必ずしも同じではありません。重要なのは、生成されるマシンコードに大きな影響を与えるオプションは避けるということです。例えば、-DSQLITE_DEBUG オプションは、SQLite ライブラリのパフォーマンスが重要なセクションの途中で何千もの assert()文を挿入してしまうため、省略されています。pg オプション (GCC 上)は省略されています。これは、実際のパフォーマンス測定を妨げる確率的なパフォーマンス測定コードを余分に出力する原因となるためです。</target>
        </trans-unit>
        <trans-unit id="f448cd989ab34ec0bc46f3d775e49bf2cb96fd96" translate="yes" xml:space="preserve">
          <source>For performance measurements, the -Os option is used (optimize for size) rather than -O2 because the -O2 option creates so much code movement that it is difficult to associate specific CPU instructions to C source code lines.</source>
          <target state="translated">パフォーマンス測定では、-O2ではなく-Osオプション(サイズの最適化)が使用されます。</target>
        </trans-unit>
        <trans-unit id="5c184bd0f5295912e4ff3123f4057a4db6895161" translate="yes" xml:space="preserve">
          <source>For performance reasons, it is advantageous to &lt;b&gt;minimize the quantity of data read and written&lt;/b&gt; to and from the file-system.</source>
          <target state="translated">パフォーマンス上の理由から、ファイルシステムとの間で&lt;b&gt;読み書きさ&lt;/b&gt;れる&lt;b&gt;データの量&lt;/b&gt;を&lt;b&gt;最小限に抑える&lt;/b&gt;と有利です。</target>
        </trans-unit>
        <trans-unit id="07b863ed3fe569c9ef5b6a594040618449a6d03c" translate="yes" xml:space="preserve">
          <source>For programs that have a lot of data that must be sifted and sorted in diverse ways, it is often easier and quicker to load the data into an in-memory SQLite database and use queries with joins and ORDER BY clauses to extract the data in the form and order needed rather than to try to code the same operations manually. Using an SQL database internally in this way also gives the program greater flexibility since new columns and indices can be added without having to recode every query.</source>
          <target state="translated">多種多様な方法でふるいにかけたり並べ替えたりしなければならない大量のデータを持つプログラムでは、同じ操作を手動でコーディングするよりも、インメモリのSQLiteデータベースにデータをロードし、結合やORDER BY句を使用したクエリを使用して、必要な形式や順序でデータを抽出した方が、より簡単かつ迅速にデータを取得できることがよくあります。また、この方法で内部的にSQLデータベースを使用することで、新しいカラムやインデックスを追加しても、すべてのクエリを再コード化する必要がないため、プログラムの柔軟性が向上します。</target>
        </trans-unit>
        <trans-unit id="9dd6714e0fb0a2d212f83820882b4bc1eae38324" translate="yes" xml:space="preserve">
          <source>For queries that use OR expressions, or those that use LIMIT or return many rows, the 'y' matchinfo option may be faster than 'x'.</source>
          <target state="translated">OR式を使用するクエリ、LIMITを使用するクエリ、または多数の行を返すクエリでは、'y' matchinfoオプションの方が'x'よりも高速な場合があります。</target>
        </trans-unit>
        <trans-unit id="0c9ccc0a52d5200b9388c921b60acbab7d6fb34e" translate="yes" xml:space="preserve">
          <source>For queries, extract results by calling &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; in between two calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;.</source>
          <target state="translated">クエリの、発呼による抽出結果&lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column（）&lt;/a&gt;への2回の呼び出しの間に&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c5bf18084dc0d97ae369c3088b48ef4a87de7f25" translate="yes" xml:space="preserve">
          <source>For reading database files that are unusually high-risk, such as database files that are received from remote machines, and possibly from anonymous contributors, the following extra precautions might be justified. These added defenses come with performance costs, however, and so may not be appropriate in every situation:</source>
          <target state="translated">リモートマシンから受信したデータベースファイルや、匿名の投稿者から受信した可能性のあるデータベースファイルなど、異常にリスクの高いデータベースファイルの読み込みについては、以下のような追加の予防策が正当化されるかもしれません。しかし、これらの追加の防御策にはパフォーマンスコストがかかるため、すべての状況で適切とは限りません。</target>
        </trans-unit>
        <trans-unit id="85d9929e5f003ec622c68d9ac564cf73c6c4c155" translate="yes" xml:space="preserve">
          <source>For reading existing zip archives, the Zipfile module provides a &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; that accepts a single argument. If the argument is a text value, then it is a path to a zip archive to read from the file-system. Or, if the argument is an SQL blob, then it is the zip archive data itself.</source>
          <target state="translated">既存のzipアーカイブを読み取るために、Zipfileモジュールは、単一の引数を受け入れる&lt;a href=&quot;vtab#tabfunc2&quot;&gt;テーブル値関数&lt;/a&gt;を提供します。引数がテキスト値の場合は、ファイルシステムから読み取るzipアーカイブへのパスです。または、引数がSQL blobの場合、それはzipアーカイブデータ自体です。</target>
        </trans-unit>
        <trans-unit id="9867027f324defd1a582c5a9d9007cb8936fd6ce" translate="yes" xml:space="preserve">
          <source>For reasons of backwards compatibility, the &quot;automerge=1&quot; command sets the automerge parameter to 8, not 1 (a value of 1 would make no sense anyway, as merging data from a single segment is a no-op).</source>
          <target state="translated">後方互換性の理由から、&quot;automerge=1 &quot;コマンドはautomergeパラメータを1ではなく8に設定しています(1という値は、1つのセグメントからデータをマージすることができないため、どちらにしても意味がありません)。</target>
        </trans-unit>
        <trans-unit id="a23d1c74ece13b6a1e6d02aa92a4e6d015b8a626" translate="yes" xml:space="preserve">
          <source>For regular functions, the &lt;b&gt;xFunc&lt;/b&gt; callback is invoked once for each function call. The implementation of xFunc should call one of the &lt;b&gt;sqlite_set_result_...&lt;/b&gt; interfaces to return its result. The &lt;b&gt;sqlite_user_data()&lt;/b&gt; routine can be used to retrieve the &lt;b&gt;pUserData&lt;/b&gt; pointer that was passed in when the function was registered.</source>
          <target state="translated">通常の関数の場合、&lt;b&gt;xFunc&lt;/b&gt;コールバックは関数呼び出しごとに1回呼び出されます。xFuncの実装は、&lt;b&gt;sqlite_set_result _...&lt;/b&gt;インターフェースの1つを呼び出して、その結果を返す&lt;b&gt;必要があります&lt;/b&gt;。&lt;b&gt;sqlite_user_data（）&lt;/b&gt;ルーチンは、取得するために使用することができ&lt;b&gt;pUserDataの&lt;/b&gt;機能が登録されたときに渡されたポインタを。</target>
        </trans-unit>
        <trans-unit id="d0ed67ff8b79adf22c16c2b1f3556a389aea4a01" translate="yes" xml:space="preserve">
          <source>For resilience when confronted with historical SQL statements, SQLite will sometimes bend the quoting rules above:</source>
          <target state="translated">歴史的なSQL文に直面したときの回復力のために、SQLiteは時に上記の引用規則を曲げてしまうことがあります。</target>
        </trans-unit>
        <trans-unit id="e7eae9c3102a4115cf6fa58568800e787b48e7a4" translate="yes" xml:space="preserve">
          <source>For security reasons, extension loaded is turned off by default and must be enabled by a prior call to &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt;.</source>
          <target state="translated">セキュリティ上の理由から、ロードされた拡張機能はデフォルトでオフになっており、事前の&lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension（）の&lt;/a&gt;呼び出しで有効にする必要があります。</target>
        </trans-unit>
        <trans-unit id="c4880044a5796d62d55405bede28ef5f4f52805b" translate="yes" xml:space="preserve">
          <source>For security reasons, extension loading is turned off by default. In order to use either the C-language or SQL extension loading functions, one must first enable extension loading using the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;,1,NULL) C-language API in your application.</source>
          <target state="translated">セキュリティ上の理由から、拡張機能のロードはデフォルトでオフになっています。C言語またはSQL拡張ロード関数を使用するには、&lt;a href=&quot;c3ref/db_config&quot;&gt;最初にアプリケーションでsqlite3_db_config&lt;/a&gt;（db、&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;、1、NULL）C言語API を使用して拡張ロードを有効にする必要があります。</target>
        </trans-unit>
        <trans-unit id="90f079fcf7344dc268fa3af2372e90f48b6aca40" translate="yes" xml:space="preserve">
          <source>For security reasons, it is recommended that applications first set &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema=OFF&lt;/a&gt; or run the &quot;&lt;a href=&quot;#config&quot;&gt;db config trusted_schema 0&lt;/a&gt;&quot; method before using this method.</source>
          <target state="translated">For security reasons, it is recommended that applications first set &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema=OFF&lt;/a&gt; or run the &quot;&lt;a href=&quot;#config&quot;&gt;db config trusted_schema 0&lt;/a&gt;&quot; method before using this method.</target>
        </trans-unit>
        <trans-unit id="92cbc8f2d6b97260523c5a56f27aa3c653ce65fe" translate="yes" xml:space="preserve">
          <source>For signed numeric substitutions, include a &quot;+&quot; sign before positive numbers. A &quot;-&quot; sign always appears before negative numbers regardless of flag settings.</source>
          <target state="translated">符号付き数値置換の場合は、正の数値の前に &quot;+&quot;記号を入れます。フラグの設定に関わらず、負の数値の前には常に&quot;-&quot;記号が表示されます。</target>
        </trans-unit>
        <trans-unit id="0a389ef1f84e1f5ea12705422f16f304415d7e84" translate="yes" xml:space="preserve">
          <source>For signed numeric substitutions, prepend a single space before positive numbers.</source>
          <target state="translated">符号付き数値置換の場合は、正の数の前にスペースを1つ挿入します。</target>
        </trans-unit>
        <trans-unit id="8361cfb2d567750344a1d16c228e8f02d706a6ad" translate="yes" xml:space="preserve">
          <source>For simple queries against a single table with few indexes, there is usually an obvious choice for the best algorithm. But for larger and more complex queries, such as multi-way joins with many indexes and subqueries, there can be hundreds, thousands, or millions of reasonable algorithms for computing the result. The job of the query planner is to choose the single &quot;best&quot; query plan from this multitude of possibilities.</source>
          <target state="translated">インデックスの少ない単一のテーブルに対する単純なクエリでは、通常、最適なアルゴリズムの選択は明白です。しかし、多数のインデックスや副問い合わせを含む多元結合のような大規模で複雑な問い合わせでは、結果を計算するための合理的なアルゴリズムが何百、何千、何百万も存在することがあります。クエリプランナの仕事は、このような多数の可能性の中から、単一の「最良の」クエリプランを選択することです。</target>
        </trans-unit>
        <trans-unit id="a9d77b186d3d3bf7ae8219371bcb8b76fedae519" translate="yes" xml:space="preserve">
          <source>For small databases and modern CPUs, there is usually no reason not to pass &quot;--sample 100&quot;. However, gathering data distribution statistics can be expensive for large database tables. If the operation is too slow, try passing a smaller value for the --sample option.</source>
          <target state="translated">小規模なデータベースや最新のCPUの場合、通常は&quot;-sample 100 &quot;を渡さない理由はありません。しかし、データの分布統計を収集するのは、大規模なデータベーステーブルではコストがかかる場合があります。操作が遅すぎる場合は、-sampleオプションに小さな値を渡してみてください。</target>
        </trans-unit>
        <trans-unit id="a4a24ddee4d5daf8ddd5ba8dfd7d48787ebb03b7" translate="yes" xml:space="preserve">
          <source>For string substitutions (%s, %z, %q, %Q, or %w) the precision is the number of byte or character used from the argument. The number is bytes by default but is characters if the &quot;!&quot; flag is present. If there is no precision, then the entire string is substituted. Examples: &quot;%.3s&quot; substitutes the first 3 bytes of the argument string. &quot;%!.3s&quot; substitutes the first three characters of the argument string.</source>
          <target state="translated">文字列置換 (%s,%z,%q,%Q,または %w)の場合、精度は引数から使用されるバイト数または文字数です。既定ではバイト数ですが、&quot;!&quot; フラグがある場合は文字数になります。精度がない場合は、文字列全体が置換されます。例)&quot;%.3s &quot;は、文字列全体を置換します。&quot;%.3s&quot; は、引数文字列の最初の3バイトを置換します。&quot;%!3s&quot; は、引数文字列の最初の 3 文字を置換します。</target>
        </trans-unit>
        <trans-unit id="e7573ff9c5daeb6537cacfee96e59061a43495a3" translate="yes" xml:space="preserve">
          <source>For subprograms, there is a bitmask in the VdbeFrame that determines whether or not the jump should be taken. The bitmask is necessary because the self-altering code trick does not work for recursive triggers.</source>
          <target state="translated">サブプログラムの場合、VdbeFrameには、ジャンプを取るべきかどうかを決定するビットマスクがあります。自己変更コードのトリックは再帰的なトリガーでは機能しないので、ビットマスクは必要です。</target>
        </trans-unit>
        <trans-unit id="1ef6b92612835372e131287be2c793df5805bcf9" translate="yes" xml:space="preserve">
          <source>For table columns, the datatype is determined by the type declaration of the CREATE TABLE statement. The datatype is text if and only if the type declaration contains one or more of the following strings:</source>
          <target state="translated">テーブルの列の場合、データ型はCREATE TABLE文の型宣言によって決定されます。データ型は、型宣言が以下の文字列のうち1つ以上を含む場合にのみ、テキストです。</target>
        </trans-unit>
        <trans-unit id="7117d5cbbb5730360ccac5d30c1470b52beef293" translate="yes" xml:space="preserve">
          <source>For testing on embedded systems, the mkth3.tcl script and the compiler steps shown above are performed on an ordinary workstation using a cross-compiler, then the resulting test program is transferred onto the device to be run.</source>
          <target state="translated">組込みシステム上でのテストのために、mkth3.tclスクリプトと上記のコンパイラステップはクロスコンパイラを使って通常のワークステーション上で実行され、結果として得られたテストプログラムは実行されるデバイスに転送されます。</target>
        </trans-unit>
        <trans-unit id="d2eb4ede923268e657583d146fd6fd411d8b52aa" translate="yes" xml:space="preserve">
          <source>For the --insert command, all files listed are inserted into the archive. For the --update command, files are only inserted if they do not previously exist in the archive, or if their &quot;mtime&quot; or &quot;mode&quot; is different from what is currently in the archive.</source>
          <target state="translated">insert コマンドでは、リストされているすべてのファイルがアーカイブに挿入されます。updateコマンドでは、ファイルがアーカイブ内に存在しない場合、または &quot;mtime &quot;または &quot;mode &quot;が現在のアーカイブ内のものと異なる場合にのみ挿入されます。</target>
        </trans-unit>
        <trans-unit id="0d9d2265812b12b9762e700ccc4ceb3931ebf930" translate="yes" xml:space="preserve">
          <source>For the C-language interfaces, the argument is an integer which is interpreted as a character. For the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt; the argument is a string from which the first character is extracted and displayed.</source>
          <target state="translated">C言語インターフェースの場合、引数は文字として解釈される整数です。以下のため&lt;a href=&quot;lang_corefunc#printf&quot;&gt;のprintf（）SQL関数&lt;/a&gt;の引数は、最初の文字を抽出して表示された文字列です。</target>
        </trans-unit>
        <trans-unit id="c95ceb997c597a8e6a21b33cbd1c20d5ac14d94b" translate="yes" xml:space="preserve">
          <source>For the GLOB operator, the column must be indexed using the built-in BINARY collating sequence.</source>
          <target state="translated">GLOB演算子では、組み込みのBINARY照合シーケンスを使用して列をインデックス化する必要があります。</target>
        </trans-unit>
        <trans-unit id="8b7943406433a1489b27536ff1cedb40c6a83fc4" translate="yes" xml:space="preserve">
          <source>For the LIKE operator, if &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like&lt;/a&gt; mode is enabled then the column must indexed using BINARY collating sequence, or if &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like&lt;/a&gt; mode is disabled then the column must indexed using built-in NOCASE collating sequence.</source>
          <target state="translated">LIKE演算子の場合、場合&lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_likeの&lt;/a&gt;モードが有効になっている、列の必見は、照合順序BINARYを使用して索引付け、または場合&lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_likeの&lt;/a&gt;モードが無効になっている、列の必須内蔵NOCASE照合順序使用して索引付け。</target>
        </trans-unit>
        <trans-unit id="394b73aae0d0953d9f85a4d75a67f00c2d16e226" translate="yes" xml:space="preserve">
          <source>For the SELECT statement above, the optimizer can use the ex2i1 index to lookup rows of ex2 that contain x=5 and then test each row against the y=6 term. Or it can use the ex2i2 index to lookup rows of ex2 that contain y=6 then test each of those rows against the x=5 term.</source>
          <target state="translated">上記のSELECT文では、オプティマイザはex2i1インデックスを使用してx=5を含むex2の行を検索し、各行をy=6項と比較してテストすることができます。または、ex2i2インデックスを使用して、y=6を含むex2の行を検索し、それらの各行をx=5項と比較してテストすることができます。</target>
        </trans-unit>
        <trans-unit id="6880a2956aa62196c20844c37991ebf1c9cc0265" translate="yes" xml:space="preserve">
          <source>For the character substitution (%c) a precision N greater than 1 causes the character to be repeated N times. This is a non-standard extension found only in SQLite.</source>
          <target state="translated">文字置換 (%c)では、精度 N が 1 より大きい場合、文字が N 回繰り返されます。これは、SQLite でのみ見られる非標準の拡張機能です。</target>
        </trans-unit>
        <trans-unit id="cbfa8c438ab75aa5b53746b3a61a2493fdc0fcad" translate="yes" xml:space="preserve">
          <source>For the common case where we want the busy callback to sleep, the SQLite library provides a convenience routine &lt;b&gt;sqlite_busy_timeout&lt;/b&gt;. The first argument to &lt;b&gt;sqlite_busy_timeout&lt;/b&gt; is a pointer to an open SQLite database and the second argument is a number of milliseconds. After &lt;b&gt;sqlite_busy_timeout&lt;/b&gt; has been executed, the SQLite library will wait for the lock to clear for at least the number of milliseconds specified before it returns SQLITE_BUSY. Specifying zero milliseconds for the timeout restores the default behavior.</source>
          <target state="translated">ビジーコールバックをスリープさせる一般的なケースでは、SQLiteライブラリは便利なルーチン&lt;b&gt;sqlite_busy_timeoutを&lt;/b&gt;提供します。&lt;b&gt;sqlite_busy_timeout&lt;/b&gt;の最初の引数は開いているSQLiteデータベースへのポインターで、2番目の引数はミリ秒数です。後&lt;b&gt;sqlite_busy_timeoutが&lt;/b&gt;実行された、SQLiteのライブラリーは、それがSQLITE_BUSYを返す前に、指定されたミリ秒単位の少なくとも数だけクリアするためにロックを待機します。タイムアウトにゼロミリ秒を指定すると、デフォルトの動作に戻ります。</target>
        </trans-unit>
        <trans-unit id="77995af2794868d5e3e1a545ee53f68c9abf9c9a" translate="yes" xml:space="preserve">
          <source>For the index above and WHERE clause like this:</source>
          <target state="translated">上記のようなインデックスとWHERE句の場合。</target>
        </trans-unit>
        <trans-unit id="bb541928f8f21ef53252b3fcd58c0333fdfa446f" translate="yes" xml:space="preserve">
          <source>For the most part, ordinary rowid tables and WITHOUT ROWID tables are interchangeable. But there are some additional restrictions on WITHOUT ROWID tables that do not apply to ordinary rowid tables:</source>
          <target state="translated">ほとんどの場合、通常のROWIDテーブルとWITHOUT ROWIDテーブルは互換性があります。しかし、WITHOUT ROWIDテーブルには、通常のROWIDテーブルには適用されない追加の制限がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="bee902327ddee3eaa34014db30d1eb9d18663957" translate="yes" xml:space="preserve">
          <source>For the purpose of computing window functions, the result set of a query is divided into one or more &quot;partitions&quot;. A partition consists of all rows that have the same value for all terms of the PARTITION BY clause in the window-defn. If there is no PARTITION BY clause, then the entire result set of the query is a single partition. Window-function processing is performed separately for each partition.</source>
          <target state="translated">ウィンドウ関数を計算するために、クエリの結果セットは1つ以上の「パーティション」に分割されます。パーティションは、window-defnのPARTITION BY句のすべての項で同じ値を持つすべての行から構成されます。PARTITION BY句がない場合、クエリの結果セット全体が1つのパーティションとなります。ウィンドウ関数の処理は、パーティションごとに別々に実行されます。</target>
        </trans-unit>
        <trans-unit id="b3fd877f7b6778afbc1e68eb5017d97a2b27eeb2" translate="yes" xml:space="preserve">
          <source>For the purpose of the &lt;b&gt;sqlite_complete&lt;/b&gt; function, an SQL statement is complete if it ends in a semicolon.</source>
          <target state="translated">&lt;b&gt;sqlite_complete&lt;/b&gt;関数の目的のために、SQLステートメントがセミコロンで終わっている場合、SQLステートメントは完全です。</target>
        </trans-unit>
        <trans-unit id="3bdae1911eb2b3c855db66c9e8e796a26c988410" translate="yes" xml:space="preserve">
          <source>For the purposes of determining duplicate rows for the results of compound SELECT operators, NULL values are considered equal to other NULL values and distinct from all non-NULL values. The collation sequence used to compare two text values is determined as if the columns of the left and right-hand SELECT statements were the left and right-hand operands of the equals (=) operator, except that greater precedence is not assigned to a collation sequence specified with the postfix COLLATE operator. No affinity transformations are applied to any values when comparing rows as part of a compound SELECT.</source>
          <target state="translated">複合SELECT演算子の結果の重複行を判定するために、NULL値は他のNULL値と同等であり、すべての非NULL値とは区別されます。2つのテキスト値を比較するために使用される照合順序は、左手と右手のSELECT文の列がequals (=)演算子の左手と右手のオペランドであるかのように決定されますが、後置COLLATE演算子で指定された照合順序には、より大きな優先順位は割り当てられません。複合SELECTの一部として行を比較する際には、どの値にも親和変換は適用されません。</target>
        </trans-unit>
        <trans-unit id="593804fd692754b9bd9050d15e0853bf78663ff7" translate="yes" xml:space="preserve">
          <source>For the purposes of determining validity, leading and trailing whitespace on JSON inputs is ignored. Interior whitespace is also ignored, in accordance with the JSON spec. These routines accept exactly the &lt;a href=&quot;http://www.rfc-editor.org/rfc/rfc7159.txt&quot;&gt;rfc-7159 JSON syntax&lt;/a&gt; &amp;mdash; no more and no less.</source>
          <target state="translated">有効性を判断するために、JSON入力の先頭と末尾の空白は無視されます。JSON仕様に従って、内部の空白も無視されます。これらのルーチンは、&lt;a href=&quot;http://www.rfc-editor.org/rfc/rfc7159.txt&quot;&gt;rfc-7159 JSON構文&lt;/a&gt;を正確に受け入れます &amp;mdash;それ以上でもそれ以下でもありません。</target>
        </trans-unit>
        <trans-unit id="4f71629a5f8d309dcb7934e2a9e496e90193e44f" translate="yes" xml:space="preserve">
          <source>For the purposes of sorting rows, values are compared in the same way as for &lt;a href=&quot;datatype3#comparisons&quot;&gt;comparison expressions&lt;/a&gt;. The collation sequence used to compare two text values is determined as follows:</source>
          <target state="translated">行を並べ替えるために、値は&lt;a href=&quot;datatype3#comparisons&quot;&gt;比較式&lt;/a&gt;と同じ方法で比較されます。2つのテキスト値の比較に使用される照合順序は、次のように決定されます。</target>
        </trans-unit>
        <trans-unit id="15ea441aee0df5dfef81b948679ce855bde68d24" translate="yes" xml:space="preserve">
          <source>For the purposes of the previous four items, two database connections that use the same &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; and which enable &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;PRAGMA read_uncommitted&lt;/a&gt; are considered to be the same database connection, not separate database connections.</source>
          <target state="translated">前の4つの項目では、同じ&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュ&lt;/a&gt;を使用し、&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;PRAGMA read_uncommitted&lt;/a&gt;を有効にする2つのデータベース接続は、別々のデータベース接続ではなく、同じデータベース接続と見なされます。</target>
        </trans-unit>
        <trans-unit id="206270d8fd15072121eb3d0a56144d865640f2b5" translate="yes" xml:space="preserve">
          <source>For the purposes of the previous two paragraphs, two database connections that have the same &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; and which have enabled &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;PRAGMA read_uncommitted&lt;/a&gt; are considered to be the same database connection.</source>
          <target state="translated">前の2つの段落では、同じ&lt;a href=&quot;sharedcache&quot;&gt;共有キャッシュ&lt;/a&gt;を持ち、&lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;PRAGMA read_uncommitted&lt;/a&gt;を有効にした2つのデータベース接続は、同じデータベース接続と見なされます。</target>
        </trans-unit>
        <trans-unit id="a17e59e38b9d3bf2b2df3849089638f1437b4d1e" translate="yes" xml:space="preserve">
          <source>For the purposes of this API, a transaction is said to have been rolled back if an explicit &quot;ROLLBACK&quot; statement is executed, or an error or constraint causes an implicit rollback to occur. The rollback callback is not invoked if a transaction is automatically rolled back because the database connection is closed.</source>
          <target state="translated">本APIでは、明示的な &quot;ROLLBACK &quot;ステートメントが実行された場合、またはエラーや制約により暗黙のロールバックが発生した場合、トランザクションはロールバックされたとみなされます。データベース接続が閉じられているためにトランザクションが自動的にロールバックされた場合、ロールバックコールバックは呼び出されません。</target>
        </trans-unit>
        <trans-unit id="57f69f1f3e95239c1d08d8e626c461a431a40ba6" translate="yes" xml:space="preserve">
          <source>For the purposes of this pragma, the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command is considered a schema change, since &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; will usual alter the &quot;rootpage&quot; values for entries in the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master table&lt;/a&gt;.</source>
          <target state="translated">このプラグマでは、&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;コマンドは通常、スキーマの変更と見なされます。これは、&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;は通常、&lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_masterテーブルの&lt;/a&gt;エントリの「ルートページ」値を変更するためです。</target>
        </trans-unit>
        <trans-unit id="a9b750853d344854f9aa1e24acbcd47fcdfc4ad1" translate="yes" xml:space="preserve">
          <source>For the purposes of this pragma, the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command is considered a schema change, since &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; will usual alter the &quot;rootpage&quot; values for entries in the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema table&lt;/a&gt;.</source>
          <target state="translated">For the purposes of this pragma, the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command is considered a schema change, since &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; will usual alter the &quot;rootpage&quot; values for entries in the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema table&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="4e03b6c7391fbf0bc56188a8c09cd4a7c0b4cdfb" translate="yes" xml:space="preserve">
          <source>For the purposes of this routine, an &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; is considered to be successful even if it is subsequently rolled back.</source>
          <target state="translated">このルーチンの目的上、&lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;は、後でロールバックされた場合でも成功したと見なされます。</target>
        </trans-unit>
        <trans-unit id="4c58e719af76025bd3937a17763f87efc5e13c1f" translate="yes" xml:space="preserve">
          <source>For the purposes of this routine, an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; is considered to be successful even if it is subsequently rolled back.</source>
          <target state="translated">このルーチンの目的上、&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;は、後でロールバックされた場合でも成功したと見なされます。</target>
        </trans-unit>
        <trans-unit id="105a62f9f913b7c3c03726a4a42a2b6ed86624fa" translate="yes" xml:space="preserve">
          <source>For the purposes of unique indices, all NULL values are considered different from all other NULL values and are thus unique. This is one of the two possible interpretations of the SQL-92 standard (the language in the standard is ambiguous). The interpretation used by SQLite is the same and is the interpretation followed by PostgreSQL, MySQL, Firebird, and Oracle. Informix and Microsoft SQL Server follow the other interpretation of the standard, which is that all NULL values are equal to one another.</source>
          <target state="translated">一意なインデックスの目的のために、すべての NULL 値は他のすべての NULL 値とは異なるものとみなされ、したがって一意であるとみなされます。これは、SQL-92標準の2つの可能な解釈のうちの1つです(標準の言語は曖昧です)。SQLiteで使用されている解釈は同じで、PostgreSQL、MySQL、Firebird、Oracleで採用されている解釈です。Informix と Microsoft SQL Server は、もう一つの解釈に従っています。</target>
        </trans-unit>
        <trans-unit id="713e891998daa01c37d2616d81cfb2bf2962ac1e" translate="yes" xml:space="preserve">
          <source>For the right-hand table of a LEFT JOIN, compute the values of expressions directly rather than loading precomputed values out of an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt; as the expression index might not contain the correct value. Ticket &lt;a href=&quot;https://sqlite.org/src/info/7fa8049685b50b5aeb0c2&quot;&gt;7fa8049685b50b5aeb0c2&lt;/a&gt;</source>
          <target state="translated">LEFT JOINの右側のテーブルでは、&lt;a href=&quot;expridx&quot;&gt;式のインデックス&lt;/a&gt;に正しい値が含まれていない可能性があるため、式のインデックスから事前に計算された値を読み込むのではなく、式の値を直接計算します。チケット&lt;a href=&quot;https://sqlite.org/src/info/7fa8049685b50b5aeb0c2&quot;&gt;7fa8049685b50b5aeb0c2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5c9ca201b99a3489f4b36f53a1d0536e05b123a3" translate="yes" xml:space="preserve">
          <source>For the second case, when the table already exists, every row of the CSV file, including the first row, is assumed to be actual content. If the CSV file contains an initial row of column labels, that row will be read as data and inserted into the table. To avoid this, make sure that table does not previously exist.</source>
          <target state="translated">2つ目のケースでは、テーブルが既に存在する場合、最初の行を含むCSVファイルの全行が実際の内容であると仮定します。CSV ファイルに列ラベルの最初の行が含まれている場合、その行はデータとして読み込まれてテーブルに挿入されます。これを避けるためには、テーブルが既に存在していないことを確認してください。</target>
        </trans-unit>
        <trans-unit id="7bf6df3d98c9980bb0d46166ad84f0bd8834c9ba" translate="yes" xml:space="preserve">
          <source>For the second case, when the table already exists, every row of the CSV file, including the first row, is assumed to be actual content. If the CSV file contains an initial row of column labels, you can cause the .import command to skip that initial row using the &quot;--skip 1&quot; option.</source>
          <target state="translated">2つ目のケースでは、テーブルが既に存在する場合、最初の行を含むCSVファイルの全行が実際の内容であると仮定します。CSVファイルに列ラベルの最初の行が含まれている場合、&quot;--skip 1 &quot;オプションを使用して、.importコマンドでその最初の行をスキップさせることができます。</target>
        </trans-unit>
        <trans-unit id="5d66c18babb7715bc31a6fed2788e6b8d32bfce2" translate="yes" xml:space="preserve">
          <source>For the sqlite3_result_text16(), sqlite3_result_text16le(), and sqlite3_result_text16be() routines, and for sqlite3_result_text64() when the encoding is not UTF8, if the input UTF16 begins with a byte-order mark (BOM, U+FEFF) then the BOM is removed from the string and the rest of the string is interpreted according to the byte-order specified by the BOM. The byte-order specified by the BOM at the beginning of the text overrides the byte-order specified by the interface procedure. So, for example, if sqlite3_result_text16le() is invoked with text that begins with bytes 0xfe, 0xff (a big-endian byte-order mark) then the first two bytes of input are skipped and the remaining input is interpreted as UTF16BE text.</source>
          <target state="translated">sqlite3_result_text16()、sqlite3_result_text16le()、sqlite3_result_text16be()ルーチン、およびエンコーディングがUTF8でない場合のsqlite3_result_text64()では、入力UTF16がバイトオーダーマーク(BOM,U+FEFF)で始まる場合、BOMは文字列から削除され、残りの文字列はBOMで指定されたバイトオーダーに従って解釈されます。テキストの先頭にあるBOMで指定されたバイト順は、インターフェイスプロシージャで指定されたバイト順よりも優先されます。例えば、sqlite3_result_text16le()がバイト0xfe,0xff(ビッグエンディアンのバイト順マーク)で始まるテキストで呼び出された場合、入力の最初の2バイトはスキップされ、残りの入力はUTF16BEテキストとして解釈されます。</target>
        </trans-unit>
        <trans-unit id="814f69ac0546d66f0db75207e5064bf283a12829" translate="yes" xml:space="preserve">
          <source>For these reasons, many complex queries may use less memory and run faster using FTS5.</source>
          <target state="translated">これらの理由から、多くの複雑なクエリでは、FTS5を使用することで、より少ないメモリ使用量で、より高速に実行される可能性があります。</target>
        </trans-unit>
        <trans-unit id="7fe943bac7177b3cc26bc016acdb488812414486" translate="yes" xml:space="preserve">
          <source>For these substitutions, the precision is the number of bytes or characters taken from the argument, not the number of bytes or characters that are written into the output.</source>
          <target state="translated">これらの置換では、精度は引数から取り出されるバイト数や文字数であり、出力に書き込まれるバイト数や文字数ではありません。</target>
        </trans-unit>
        <trans-unit id="ddecb7fc6ac9ebf678a969f318e2c93050dc15ef" translate="yes" xml:space="preserve">
          <source>For this first experiment, nothing else about the file format is changed. The OpenDocument is still a pile-of-files, only now each file is a row in an SQLite database rather than an entry in a ZIP archive. This simple change does not use the power of a relational database. Even so, this simple change shows some improvements.</source>
          <target state="translated">この最初の実験では、ファイル形式については何も変更していません。OpenDocument は相変わらずファイルの山ですが、各ファイルは ZIP アーカイブのエントリではなく、SQLite データベースの行になっています。この単純な変更では、リレーショナルデータベースの力は使われていません。それでも、この単純な変更はいくつかの改善点を示しています。</target>
        </trans-unit>
        <trans-unit id="fbfd34ac3082b66cb73eae2395605bfffd9afee2" translate="yes" xml:space="preserve">
          <source>For this form, the &amp;lt;expr&amp;gt; does not have to be an integer. It can evaluate to a real number as long as it is constant and non-negative.</source>
          <target state="translated">この形式では、&amp;lt;expr&amp;gt;は整数である必要はありません。定数で負でない限り、実数に評価できます。</target>
        </trans-unit>
        <trans-unit id="752d2cd19688f392b69d1efc9ea4707b6423ad4e" translate="yes" xml:space="preserve">
          <source>For this particular UPDATE test, MySQL is consistently five or ten times slower than PostgreSQL and SQLite. I do not know why. MySQL is normally a very fast engine. Perhaps this problem has been addressed in later versions of MySQL.</source>
          <target state="translated">この特定のUPDATEテストでは、MySQLはPostgreSQLやSQLiteに比べて一貫して5倍も10倍も遅くなっています。その理由はわかりません。MySQLは通常、非常に高速なエンジンです。おそらく、この問題はMySQLの後のバージョンで対処されているのでしょう。</target>
        </trans-unit>
        <trans-unit id="9db0e6302461b7556c4838a4a6492fc335414fcc" translate="yes" xml:space="preserve">
          <source>For usage hints and a summary of all options, simply give the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; the -A option with no additional arguments:</source>
          <target state="translated">使用のヒントとすべてのオプションの概要については、追加の引数なしで&lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;に-Aオプションを指定するだけです。</target>
        </trans-unit>
        <trans-unit id="c9239816897eb996f78a6efe04536d4eaf0b8d55" translate="yes" xml:space="preserve">
          <source>Force the value in register P1 to be an integer. If the value in P1 is not an integer and cannot be converted into an integer without data loss, then jump immediately to P2, or if P2==0 raise an SQLITE_MISMATCH exception.</source>
          <target state="translated">レジスタP1の値を強制的に整数にします。P1 の値が整数ではなく、データを失うことなく整数に変換できない場合は、直ちに P2 にジャンプするか、P2==0 の場合は SQLITE_MISMATCH 例外を発生させます。</target>
        </trans-unit>
        <trans-unit id="e1652af1b46a8724b09c6398e58d043cf684e88e" translate="yes" xml:space="preserve">
          <source>Force the value in register P1 to be the type defined by P2.</source>
          <target state="translated">レジスタP1の値をP2で定義された型に強制的にします。</target>
        </trans-unit>
        <trans-unit id="c3788028d350f50070224e2ffa767d1574a8ab2d" translate="yes" xml:space="preserve">
          <source>Foreign Key Constraints</source>
          <target state="translated">海外キー制約</target>
        </trans-unit>
        <trans-unit id="8ea9876246ba7c653355a0ce27076bc76b4c8469" translate="yes" xml:space="preserve">
          <source>Foreign key ON DELETE and ON UPDATE clauses are used to configure actions that take place when deleting rows from the parent table (ON DELETE), or modifying the parent key values of existing rows (ON UPDATE). A single foreign key constraint may have different actions configured for ON DELETE and ON UPDATE. Foreign key actions are similar to triggers in many ways.</source>
          <target state="translated">外部キーON DELETE句とON UPDATE句は、親テーブルから行を削除したり(ON DELETE)、既存の行の親キー値を変更したり(ON UPDATE)するときに実行されるアクションを構成するために使用されます。単一の外部キー制約は、ON DELETEとON UPDATEに対して異なるアクションを構成することができます。外部キーアクションは、多くの点でトリガーに似ています。</target>
        </trans-unit>
        <trans-unit id="474365badbb1f3b57e5eb366037b4f712db8f5d1" translate="yes" xml:space="preserve">
          <source>Foreign key actions</source>
          <target state="translated">海外のキーアクション</target>
        </trans-unit>
        <trans-unit id="d3465e4f63b19b36c358f39673e35fd218b96287" translate="yes" xml:space="preserve">
          <source>Foreign key constraints are disabled by default (for backwards compatibility), so must be enabled separately for each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. (Note, however, that future releases of SQLite might change so that foreign key constraints enabled by default. Careful developers will not make any assumptions about whether or not foreign keys are enabled by default but will instead enable or disable them as necessary.) The application can also use a &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; statement to determine if foreign keys are currently enabled. The following command-line session demonstrates this:</source>
          <target state="translated">外部キー制約はデフォルトで無効になっているため（下位互換性のため）、&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;ごとに個別に有効にする必要があります。（ただし、SQLiteの将来のリリースでは、外部キー制約がデフォルトで有効になるように変更される可能性があります。注意深く開発者は、外部キーがデフォルトで有効かどうかについては想定せず、必要に応じて外部キーを有効または無効にします。）アプリケーションは、&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt;ステートメントを使用して、外部キーが現在有効になっているかどうかを判別することもできます。次のコマンドラインセッションは、これを示しています。</target>
        </trans-unit>
        <trans-unit id="fadb49ecb31870fa195b79a63507d69332246c87" translate="yes" xml:space="preserve">
          <source>Foreign key constraints are enabled</source>
          <target state="translated">外部キー制約が有効</target>
        </trans-unit>
        <trans-unit id="ce28942b103c42389428127f519c6795e562c011" translate="yes" xml:space="preserve">
          <source>Format 1 is understood by all versions of SQLite back to &lt;a href=&quot;https://sqlite.org/releaselog/3_0_0.html&quot;&gt;version 3.0.0&lt;/a&gt; (2004-06-18).</source>
          <target state="translated">形式1は、SQLiteのすべてのバージョンで認識され、バージョン&lt;a href=&quot;https://sqlite.org/releaselog/3_0_0.html&quot;&gt;3.0.0&lt;/a&gt;（2004-06-18）に戻ります。</target>
        </trans-unit>
        <trans-unit id="bb846b850c6fa3ff33f8d13f455d688d28aa22d8" translate="yes" xml:space="preserve">
          <source>Format 2 adds the ability of rows within the same table to have a varying number of columns, in order to support the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; functionality. Support for reading and writing format 2 was added in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_1_3.html&quot;&gt;version 3.1.3&lt;/a&gt; on 2005-02-20.</source>
          <target state="translated">形式2は、&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt;機能をサポートするために、同じテーブル内の行がさまざまな数の列を持つ機能を追加します。2005-02-20のSQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_1_3.html&quot;&gt;バージョン3.1.3&lt;/a&gt;では、フォーマット2の読み取りと書き込みのサポートが追加されました。</target>
        </trans-unit>
        <trans-unit id="e74a0202e30c00da07d8e3f647ad619d797750ee" translate="yes" xml:space="preserve">
          <source>Format 3 adds the ability of extra columns added by &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; to have non-NULL default values. This capability was added in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_1_4.html&quot;&gt;version 3.1.4&lt;/a&gt; on 2005-03-11.</source>
          <target state="translated">形式3は、&lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt;によって追加された追加の列がNULL以外のデフォルト値を持つ機能を追加します。この機能は、2005-03-11のSQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_1_4.html&quot;&gt;バージョン3.1.4&lt;/a&gt;で追加されました。</target>
        </trans-unit>
        <trans-unit id="6f87214a5c89d4a264dcabc8b3ff76d0ecb7e6ab" translate="yes" xml:space="preserve">
          <source>Format 4 causes SQLite to respect the &lt;a href=&quot;lang_createindex#descidx&quot;&gt;DESC keyword&lt;/a&gt; on index declarations. (The DESC keyword is ignored in indexes for formats 1, 2, and 3.) Format 4 also adds two new boolean record type values (&lt;a href=&quot;fileformat2#serialtype&quot;&gt;serial types&lt;/a&gt; 8 and 9). Support for format 4 was added in SQLite 3.3.0 on 2006-01-10.</source>
          <target state="translated">形式4では、SQLite はインデックス宣言の&lt;a href=&quot;lang_createindex#descidx&quot;&gt;DESCキーワード&lt;/a&gt;を尊重します。（DESCキーワードは、フォーマット1、2、および3のインデックスでは無視されます。）フォーマット4は、2つの新しいブールレコードタイプ値（&lt;a href=&quot;fileformat2#serialtype&quot;&gt;シリアルタイプ&lt;/a&gt; 8および9）も追加します。フォーマット4のサポートは、2006-01-10のSQLite 3.3.0で追加されました。</target>
        </trans-unit>
        <trans-unit id="d2e4ea8f983e7648b4500b3c2517f1581f43edb0" translate="yes" xml:space="preserve">
          <source>Formats 2 through 10 may be optionally followed by a timezone indicator of the form &quot;</source>
          <target state="translated">フォーマット2から10は、オプションで &quot;の形式のタイムゾーンインジケータが続くことがあります。</target>
        </trans-unit>
        <trans-unit id="ff2a0eb4d03de61d70053787eab6804fcec445da" translate="yes" xml:space="preserve">
          <source>Formatted String Printing Functions</source>
          <target state="translated">整形済み文字列印刷機能</target>
        </trans-unit>
        <trans-unit id="73cdbab7825af4beabbe4e8fccce8b346886e89f" translate="yes" xml:space="preserve">
          <source>Fossil gives me peace of mind that I have everything ... synced to the server with a single command.... I never get this peace of mind with git.</source>
          <target state="translated">Fossil を使うと、コマンドひとつですべてがサーバーに同期されているという安心感があります...。gitではこんな安心感は得られません。</target>
        </trans-unit>
        <trans-unit id="968f45bf8ccf7ca67b780b2bdd22df3354350003" translate="yes" xml:space="preserve">
          <source>Fossil is a completely stand-alone program, so install it simply by putting the &quot;fossil&quot; or &quot;fossil.exe&quot; executable someplace on your $PATH or %PATH%. After you have Fossil installed, do this:</source>
          <target state="translated">Fossilは完全にスタンドアロンのプログラムなので、&quot;fossil &quot;または &quot;fossil.exe &quot;実行ファイルを$PATHまたは%PATH%のどこかに置いてインストールしてください。Fossilをインストールしたら、次のようにします。</target>
        </trans-unit>
        <trans-unit id="94257cd970f113fc11ecc5cc6011f7bfff67e319" translate="yes" xml:space="preserve">
          <source>Fossil is easy to install and use. Here are the steps for unix. (Windows is similar.)</source>
          <target state="translated">フォッシルは簡単にインストールして使えます。以下はunixの手順です。(Windowsも同様です。)</target>
        </trans-unit>
        <trans-unit id="233904fc6b6c8ee70d33af66e4cb04bfc0af5c1f" translate="yes" xml:space="preserve">
          <source>Fossil vs. Git</source>
          <target state="translated">フォッシル vs.Git</target>
        </trans-unit>
        <trans-unit id="bbba84135de6b052c2210e74e0cc5b2a9d359ddb" translate="yes" xml:space="preserve">
          <source>Found</source>
          <target state="translated">Found</target>
        </trans-unit>
        <trans-unit id="71c33b1cffd26b04e4533bd5c542bd8028125150" translate="yes" xml:space="preserve">
          <source>Four independently developed test harnesses</source>
          <target state="translated">独自に開発した4つのテストハーネス</target>
        </trans-unit>
        <trans-unit id="a9521a3d73988a064707ebf1e7a52b3d8155b49c" translate="yes" xml:space="preserve">
          <source>Frame boundary</source>
          <target state="translated">フレーム境界</target>
        </trans-unit>
        <trans-unit id="77433082b8e51b0f02140d5bb2ad80c6960db0b1" translate="yes" xml:space="preserve">
          <source>Frame type</source>
          <target state="translated">フレームタイプ</target>
        </trans-unit>
        <trans-unit id="6e84d556b35797f261b67f9c140d77ba6a16046e" translate="yes" xml:space="preserve">
          <source>Free Memory Used By A Database Connection</source>
          <target state="translated">データベース接続で使用されるフリーメモリ</target>
        </trans-unit>
        <trans-unit id="c3f00513ee103316a9c102f8d540f97f3d93a05d" translate="yes" xml:space="preserve">
          <source>Freelist leaf pages contain no information. SQLite avoids reading or writing freelist leaf pages in order to reduce disk I/O.</source>
          <target state="translated">フリーリストのリーフページには何の情報も含まれていません。SQLite はディスクの I/O を減らすために、フリーリストのリーフページを読み書きしないようにしています。</target>
        </trans-unit>
        <trans-unit id="71c292b702c9c6ddbea2af4ccdda270456dc5dd4" translate="yes" xml:space="preserve">
          <source>Frequent inserts, updates, and deletes can cause the database file to become fragmented - where data for a single table or index is scattered around the database file. Running VACUUM ensures that each table and index is largely stored contiguously within the database file. In some cases, VACUUM may also reduce the number of partially filled pages in the database, reducing the size of the database file further.</source>
          <target state="translated">頻繁に挿入、更新、削除を行うと、データベースファイルが断片化し、単一のテーブルやインデックスのデータがデータベースファイル内に散らばってしまうことがあります。VACUUMを実行することで、各テーブルとインデックスがデータベースファイル内でほぼ連続して保存されるようになります。場合によっては、VACUUMは、データベース内の部分的に充填されたページの数を減らし、データベースファイルのサイズをさらに縮小することもあります。</target>
        </trans-unit>
        <trans-unit id="d790b402d79ac1a723c790313bcd679999474630" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions</source>
          <target state="translated">よくある質問</target>
        </trans-unit>
        <trans-unit id="4dca8789d725335eabc320e5fd334c48abe46050" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;, extensions can be loaded using the &quot;.load&quot; dot-command. For example:</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;コマンドラインシェル&lt;/a&gt;から、「。load」ドットコマンドを使用して拡張機能をロードできます。例えば：</target>
        </trans-unit>
        <trans-unit id="9622d74f0a066cde3991b933210f9d9f6547b468" translate="yes" xml:space="preserve">
          <source>From the point of view of a single process, a database file can be in one of five locking states:</source>
          <target state="translated">単一プロセスの観点から見ると、データベースファイルは5つのロック状態のうちの1つになります。</target>
        </trans-unit>
        <trans-unit id="f2bf6ce9c451768f240ac82fe10e69d266839161" translate="yes" xml:space="preserve">
          <source>From the point of view of the uppers layers of the SQLite stack, each open database file uses exactly one VFS. But in practice, a particular VFS might just be a thin wrapper around another VFS that does the real work. We call a wrapper VFS a &quot;shim&quot;.</source>
          <target state="translated">SQLite スタックの上位レイヤの観点から見ると、各オープンデータベースファイルは正確に一つの VFS を使用しています。しかし実際には、ある特定のVFSは、実際の作業を行う別のVFSの薄いラッパーに過ぎないかもしれません。このようなラッパーVFSを「シム」と呼んでいます。</target>
        </trans-unit>
        <trans-unit id="b51b364d89abfa3baa92bcc31eb6e45de7419ef6" translate="yes" xml:space="preserve">
          <source>From the users point of view, FTS tables are similar to ordinary SQLite tables in many ways. Data may be added to, modified within and removed from FTS tables using the INSERT, UPDATE and DELETE commands just as it may be with ordinary tables. Similarly, the SELECT command may be used to query data. The following list summarizes the differences between FTS and ordinary tables:</source>
          <target state="translated">ビューのユーザーの観点から、FTSテーブルは、多くの点で通常のSQLiteテーブルに似ています。データは、通常のテーブルと同様にINSERT、UPDATE、DELETEコマンドを使用して、FTSテーブルに追加、変更、削除することができます。同様に、SELECTコマンドを使用してデータを問い合わせることができます。以下のリストは、FTSテーブルと通常のテーブルの違いをまとめたものです。</target>
        </trans-unit>
        <trans-unit id="27c4a8e9b8642a933f67723d0e4be1b9a0f44d80" translate="yes" xml:space="preserve">
          <source>From this we get the following output</source>
          <target state="translated">この結果、次のような出力が得られます。</target>
        </trans-unit>
        <trans-unit id="2180268f2a9a9fda782b57bf8e01a18a029a7a96" translate="yes" xml:space="preserve">
          <source>Fulfill God's commandments daily in your deeds.</source>
          <target state="translated">あなたの行いの中で、毎日神の戒めを満たしてください。</target>
        </trans-unit>
        <trans-unit id="b471a096b84cc0494684e033a051e31af5d4baaa" translate="yes" xml:space="preserve">
          <source>Fulfill not the desires of the flesh; hate your own will.</source>
          <target state="translated">肉の欲望を満たすのではなく、自分の意志を憎みなさい。</target>
        </trans-unit>
        <trans-unit id="c55154da9bee9185f44dff21df8abc2c3aabdcae" translate="yes" xml:space="preserve">
          <source>Full unicode case folding is supported in SQLite if it is compiled with the &lt;a href=&quot;compile#enable_icu&quot;&gt;-DSQLITE_ENABLE_ICU&lt;/a&gt; option and linked against the &lt;a href=&quot;http://site.icu-project.org/&quot;&gt;International Components for Unicode&lt;/a&gt; library.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_icu&quot;&gt;-DSQLITE_ENABLE_ICU&lt;/a&gt;オプションを使用してコンパイルされ、&lt;a href=&quot;http://site.icu-project.org/&quot;&gt;International Components for Unicode&lt;/a&gt;ライブラリに対してリンクされている場合、完全なUnicodeの大文字小文字変換がSQLiteでサポートされます。</target>
        </trans-unit>
        <trans-unit id="90b0c8025a15a6f38263adcf72861e6ab67a9305" translate="yes" xml:space="preserve">
          <source>Full-Featured SQL</source>
          <target state="translated">フル機能のSQL</target>
        </trans-unit>
        <trans-unit id="9e0f1c37b71547a59fac0e69533c4df840ff38fe" translate="yes" xml:space="preserve">
          <source>Full-Text Search</source>
          <target state="translated">フルテキスト検索</target>
        </trans-unit>
        <trans-unit id="369603a7ebe96771eca2b1d07435e9996bd963f3" translate="yes" xml:space="preserve">
          <source>Full-text search</source>
          <target state="translated">全文検索</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="9365da4d7427ae049cd7228599ffdbf56ca765df" translate="yes" xml:space="preserve">
          <source>Function &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt; is called to clean up resources allocated by &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt;.</source>
          <target state="translated">関数&lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish（）&lt;/a&gt;は、&lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init（）&lt;/a&gt;によって割り当てられたリソースをクリーンアップするために呼び出されます。</target>
        </trans-unit>
        <trans-unit id="6ee739a58d0601e439d67d32ce677eb6f284f6f0" translate="yes" xml:space="preserve">
          <source>Function &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt; is called to create an &lt;a href=&quot;c3ref/backup&quot;&gt;sqlite3_backup&lt;/a&gt; object to copy data between the two databases (either from a file and into the in-memory database, or vice-versa).</source>
          <target state="translated">関数&lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init（）&lt;/a&gt;が呼び出されて、2つのデータベース間でデータをコピーする&lt;a href=&quot;c3ref/backup&quot;&gt;sqlite3_backup&lt;/a&gt;オブジェクトを作成します（ファイルからメモリ内データベースへ、またはその逆）。</target>
        </trans-unit>
        <trans-unit id="3518bc62cbd77290edb8df852902f3d26b669db7" translate="yes" xml:space="preserve">
          <source>Function &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt; is called to create an &lt;a href=&quot;c3ref/backup&quot;&gt;sqlite3_backup&lt;/a&gt; object to copy data from database pDb to the backup database file identified by zFilename.</source>
          <target state="translated">関数&lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init（）&lt;/a&gt;が呼び出され、&lt;a href=&quot;c3ref/backup&quot;&gt;sqlite3_backup&lt;/a&gt;オブジェクトを作成して、データベースpDbからzFilenameで識別されるバックアップデータベースファイルにデータをコピーします。</target>
        </trans-unit>
        <trans-unit id="391bd2c3bef8e5815ac8dc9e143dc5e9f29edc4b" translate="yes" xml:space="preserve">
          <source>Function &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; is called with a parameter of 5 to copy 5 pages of database pDb to the backup database (file zFilename).</source>
          <target state="translated">関数&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step（）&lt;/a&gt;がパラメーター5で呼び出され、データベースpDbの5ページをバックアップデータベース（ファイルzFilename）にコピーします。</target>
        </trans-unit>
        <trans-unit id="38d0016fe914d4211802e56c1b039ba739bf3a21" translate="yes" xml:space="preserve">
          <source>Function &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; is called with a parameter of &lt;code&gt;-1&lt;/code&gt; to copy the entire source database to the destination.</source>
          <target state="translated">関数&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step（）&lt;/a&gt;が &lt;code&gt;-1&lt;/code&gt; のパラメーターで呼び出され、ソースデータベース全体を宛先にコピーします。</target>
        </trans-unit>
        <trans-unit id="a019467e942226e7593baeafe04451d52208ddbd" translate="yes" xml:space="preserve">
          <source>Function Auxiliary Data</source>
          <target state="translated">機能補助データ</target>
        </trans-unit>
        <trans-unit id="95b0294dd891e754097881615649b65fc6ba31c5" translate="yes" xml:space="preserve">
          <source>Function Flags</source>
          <target state="translated">関数フラグ</target>
        </trans-unit>
        <trans-unit id="17555700d9f22f47c91cbb0e6dcdac3a03a90e07" translate="yes" xml:space="preserve">
          <source>Function implementations use the following APIs to acquire context and to report results:</source>
          <target state="translated">関数の実装では、以下のAPIを使用してコンテキストを取得し、結果を報告します。</target>
        </trans-unit>
        <trans-unit id="7db899803172ac5c12cb30190a927b06044d501c" translate="yes" xml:space="preserve">
          <source>Function sqlite3_backup_step(B,N) will copy up to N pages between the source and destination databases specified by &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object B. If N is negative, all remaining source pages are copied. If sqlite3_backup_step(B,N) successfully copies N pages and there are still more pages to be copied, then the function returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;. If sqlite3_backup_step(B,N) successfully finishes copying all pages from source to destination, then it returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;. If an error occurs while running sqlite3_backup_step(B,N), then an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned. As well as &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; and &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, a call to sqlite3_backup_step() may return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt;, or an &lt;a href=&quot;#SQLITE_ABORT_ROLLBACK&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt; extended error code.</source>
          <target state="translated">関数sqlite3_backup_step（B、N）は、&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt;オブジェクトBで指定されたソースデータベースと宛先データベース間で最大Nページをコピーします。Nが負の場合、残りのすべてのソースページがコピーされます。 sqlite3_backup_step（B、N）がNページのコピーに成功しても、コピーするページがまだある場合、関数は&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OKを&lt;/a&gt;返します。 sqlite3_backup_step（B、N）がソースから宛先へのすべてのページのコピーを正常に&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;完了すると、SQLITE_DONEを&lt;/a&gt;返します。 sqlite3_backup_step（B、N）の実行中にエラーが発生した場合、エラー&lt;a href=&quot;rescode&quot;&gt;コード&lt;/a&gt;が返されます。&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;と&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;だけでなく、sqlite3_backup_step（）を呼び出すとSQLITE_READONLYが返され&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;ます&lt;/a&gt;。&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt;、または&lt;a href=&quot;#SQLITE_ABORT_ROLLBACK&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt;拡張エラーコード。</target>
        </trans-unit>
        <trans-unit id="9255837a8368562d39b56b025c25a117e386acd6" translate="yes" xml:space="preserve">
          <source>Function sqlite3_backup_step(B,N) will copy up to N pages between the source and destination databases specified by &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object B. If N is negative, all remaining source pages are copied. If sqlite3_backup_step(B,N) successfully copies N pages and there are still more pages to be copied, then the function returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;. If sqlite3_backup_step(B,N) successfully finishes copying all pages from source to destination, then it returns &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;. If an error occurs while running sqlite3_backup_step(B,N), then an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned. As well as &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; and &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, a call to sqlite3_backup_step() may return &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;, &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, &lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt;, or an &lt;a href=&quot;../rescode#ioerr_access&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt; extended error code.</source>
          <target state="translated">関数sqlite3_backup_step（B、N）は、&lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt;オブジェクトBで指定されたソースデータベースと宛先データベース間で最大Nページをコピーします。Nが負の場合、残りのすべてのソースページがコピーされます。 sqlite3_backup_step（B、N）がNページのコピーに成功しても、コピーするページがまだある場合、関数は&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OKを&lt;/a&gt;返します。 sqlite3_backup_step（B、N）がソースから宛先へのすべてのページのコピーを正常に&lt;a href=&quot;../rescode#done&quot;&gt;完了すると、SQLITE_DONEを&lt;/a&gt;返します。 sqlite3_backup_step（B、N）の実行中にエラーが発生した場合、エラー&lt;a href=&quot;../rescode&quot;&gt;コード&lt;/a&gt;が返されます。&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;と&lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;だけでなく、sqlite3_backup_step（）を呼び出すとSQLITE_READONLYが返され&lt;a href=&quot;../rescode#readonly&quot;&gt;ます&lt;/a&gt;。&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;、&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;、&lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt;、または&lt;a href=&quot;../rescode#ioerr_access&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt;拡張エラーコード。</target>
        </trans-unit>
        <trans-unit id="02506e4ca51a17167d74a2f8b901e6d46a621915" translate="yes" xml:space="preserve">
          <source>Function sqlite3rbu_step() is called on the RBU handle until either the RBU vacuum is finished, an error occurs or the application wishes to suspend the RBU vacuum.</source>
          <target state="translated">関数sqlite3rbu_step()は、RBUのバキュームが終了するか、エラーが発生するか、アプリケーションがRBUのバキュームを中断することを望むかのいずれかになるまで、RBUハンドル上で呼び出されます。</target>
        </trans-unit>
        <trans-unit id="c29dbde42f9e09b5fa1fe9e874978bd60461ca23" translate="yes" xml:space="preserve">
          <source>Function0</source>
          <target state="translated">Function0</target>
        </trans-unit>
        <trans-unit id="885fce7082ac7fe77b80dbde8d190b12ddbee6ea" translate="yes" xml:space="preserve">
          <source>Functionality Testing</source>
          <target state="translated">機能テスト</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="5a1198fbca49df3b9353761343f6ab00ba7526e3" translate="yes" xml:space="preserve">
          <source>Functions:</source>
          <target state="translated">Functions:</target>
        </trans-unit>
        <trans-unit id="1ddc4309220e5ca80653bda487622cf643ea376d" translate="yes" xml:space="preserve">
          <source>Fundamental Datatypes</source>
          <target state="translated">基本データ型</target>
        </trans-unit>
        <trans-unit id="f728c83ebd508ddfa64fa9b670d3c24c116a1c08" translate="yes" xml:space="preserve">
          <source>Further performance improves can be made by using the &lt;a href=&quot;mmap&quot;&gt;memory-mapped I/O&lt;/a&gt; feature of SQLite. In the next chart, the entire 1GB database file is memory mapped and blobs are read (in random order) using the &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; interface. With these optimizations, SQLite is twice as fast as Android or MacOS-X and over 10 times faster than Windows.</source>
          <target state="translated">SQLiteの&lt;a href=&quot;mmap&quot;&gt;メモリマップI / O&lt;/a&gt;機能を使用すると、パフォーマンスをさらに向上させることができます。次のグラフでは、1GBのデータベースファイル全体がメモリマップされ、&lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read（）&lt;/a&gt;インターフェイスを使用してblobが（ランダムな順序で）読み取られます。これらの最適化により、SQLiteはAndroidまたはMacOS-Xの2倍、Windowsの10倍以上高速です。</target>
        </trans-unit>
        <trans-unit id="215d209e37d2a11fed7e914dfee16f71ee55be90" translate="yes" xml:space="preserve">
          <source>Further suppose that column x contains values spread out between 0 and 1,000,000 and column y contains values that span between 0 and 1,000. In that scenario, the range constraint on column x should reduce the search space by a factor of 10,000 whereas the range constraint on column y should reduce the search space by a factor of only 10. So the ex2i1 index should be preferred.</source>
          <target state="translated">さらに、列 x には 0 から 1,000,000,000 の間に広がる値が含まれ、列 y には 0 から 1,000 の間に広がる値が含まれているとします。このシナリオでは、列xの範囲制約は検索空間を10,000分の1に削減し、列yの範囲制約は検索空間を10分の1に削減しなければなりません。したがって、ex2i1インデックスが好まれるべきである。</target>
        </trans-unit>
        <trans-unit id="09aabcfb38f7cb10806136de02a602b19c076fd6" translate="yes" xml:space="preserve">
          <source>Further to keeping &lt;b&gt;n&lt;/b&gt; small, one desires to keep the size of the largest memory allocations under control. Large requests to the general-purpose memory allocator might come from several sources:</source>
          <target state="translated">さらに維持に&lt;b&gt;N&lt;/b&gt;小さい、一つは制御下最大メモリ割り当てのサイズを維持することを望みます。汎用メモリアロケータへの大きなリクエストは、いくつかのソースから送信される可能性があります。</target>
        </trans-unit>
        <trans-unit id="4a74f247651044b2313a36316a7929616b6d570a" translate="yes" xml:space="preserve">
          <source>Furthermore, a single SQLite database holding 10-kilobyte blobs uses about 20% less disk space than storing the blobs in individual files.</source>
          <target state="translated">さらに、10キロバイトのブロブを保持する1つのSQLiteデータベースは、ブロブを個々のファイルに保存するよりも約20%少ないディスク容量を使用します。</target>
        </trans-unit>
        <trans-unit id="8bd50359d3a17558a2d398e2f44b82ca134e4e80" translate="yes" xml:space="preserve">
          <source>Future releases may add new output columns and may change the order of legacy columns. Further detail about the meaning of each column in the SQLITE_STMT virtual table is provided below:</source>
          <target state="translated">今後のリリースでは、新しい出力カラムが追加されたり、従来のカラムの順序が変更される可能性があります。SQLITE_STMT 仮想テーブルの各カラムの意味についての詳細は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="6831b46470717c86c7d25cb9cedff9f9bee20302" translate="yes" xml:space="preserve">
          <source>Future releases of SQLite might enable those interfaces by default and instead offer an SQLITE_OMIT_DESERIALIZE option to leave them out.</source>
          <target state="translated">今後のSQLiteのリリースでは、これらのインターフェイスをデフォルトで有効にし、代わりにSQLITE_OMIT_DESERIALIZEオプションを提供して、これらのインターフェイスを除外することができるようになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="69eed414fd6ede90f6e232a4b640df2129c7213e" translate="yes" xml:space="preserve">
          <source>Future versions of SQLite may extend the list of errors which might cause automatic transaction rollback. Future versions of SQLite might change the error response. In particular, we may choose to simplify the interface in future versions of SQLite by causing the errors above to force an unconditional rollback.</source>
          <target state="translated">将来のバージョンの SQLite では、トランザクションの自動ロールバックを引き起こす可能性のあるエラーのリストが拡張される可能性があります。将来のバージョンのSQLiteでは、エラー応答が変更されるかもしれません。特に、将来のバージョンのSQLiteでは、上記のエラーを発生させて無条件にロールバックを強制することで、インターフェイスを簡素化することを選択するかもしれません。</target>
        </trans-unit>
        <trans-unit id="b0b58ce3a5e420ed148b6052399ca3a065dfe3cb" translate="yes" xml:space="preserve">
          <source>Future versions of SQLite might enable the batch-atomic-write capability by default, at which point this compile-time option will become superfluous.</source>
          <target state="translated">将来のバージョンの SQLite では、デフォルトで batch-atomic-write 機能が有効になるかもしれませんが、その時点ではこのコンパイル時オプションは不要になります。</target>
        </trans-unit>
        <trans-unit id="75a65696cc2dd88673f048a8e620acbe3511d286" translate="yes" xml:space="preserve">
          <source>Fuzz testing and &lt;a href=&quot;testing#mcdc&quot;&gt;100% MC/DC testing&lt;/a&gt; are in tension with one another. That is to say, code tested to 100% MC/DC will tend to be more vulnerable to problems found by fuzzing and code that performs well during fuzz testing will tend to have (much) less than 100% MC/DC. This is because MC/DC testing discourages &lt;a href=&quot;testing#defcode&quot;&gt;defensive code&lt;/a&gt; with unreachable branches, but without defensive code, a fuzzer is more likely to find a path that causes problems. MC/DC testing seems to work well for building code that is robust during typical normal use, whereas fuzz testing is good for building code that is robust against malicious attack.</source>
          <target state="translated">Fuzz testing and &lt;a href=&quot;testing#mcdc&quot;&gt;100% MC/DC testing&lt;/a&gt; are in tension with one another. That is to say, code tested to 100% MC/DC will tend to be more vulnerable to problems found by fuzzing and code that performs well during fuzz testing will tend to have (much) less than 100% MC/DC. This is because MC/DC testing discourages &lt;a href=&quot;testing#defcode&quot;&gt;defensive code&lt;/a&gt; with unreachable branches, but without defensive code, a fuzzer is more likely to find a path that causes problems. MC/DC testing seems to work well for building code that is robust during typical normal use, whereas fuzz testing is good for building code that is robust against malicious attack.</target>
        </trans-unit>
        <trans-unit id="7aac4860a695a884103c23bef4fe10cea8ac21a0" translate="yes" xml:space="preserve">
          <source>Fuzz tests</source>
          <target state="translated">ファズテスト</target>
        </trans-unit>
        <trans-unit id="cbf13864eb622e042fd70afc25b332a98febed1d" translate="yes" xml:space="preserve">
          <source>GCC-7 generates binaries that are smaller and faster than GCC-5, though the difference is not that great.</source>
          <target state="translated">GCC-7はGCC-5よりも小さくて速いバイナリを生成しますが、その差はそれほど大きくありません。</target>
        </trans-unit>
        <trans-unit id="82cb2940a14f458fe56d211dffdcd12595e8b940" translate="yes" xml:space="preserve">
          <source>GENERATED</source>
          <target state="translated">GENERATED</target>
        </trans-unit>
        <trans-unit id="3c1c8852a41864ea17cea1296e10f38e7d36f590" translate="yes" xml:space="preserve">
          <source>GIT - Git source code repository</source>
          <target state="translated">GIT-Git ソースコードリポジトリ</target>
        </trans-unit>
        <trans-unit id="801660e770a91f34fb13ac91a9b5cbd2d98c6d3a" translate="yes" xml:space="preserve">
          <source>GLOB</source>
          <target state="translated">GLOB</target>
        </trans-unit>
        <trans-unit id="ea5a383494f81c4f464965d03bf916c41d68ced5" translate="yes" xml:space="preserve">
          <source>GROUP</source>
          <target state="translated">GROUP</target>
        </trans-unit>
        <trans-unit id="992f3cd91fffb522eba0b5e27b68c643f2967283" translate="yes" xml:space="preserve">
          <source>GROUP BY now considers NULLs to be equal again, as it should</source>
          <target state="translated">GROUP BY は、NULL を再び等しいとみなすようになりました。</target>
        </trans-unit>
        <trans-unit id="1f8969d436579977f5b13e27e290ffdb25736672" translate="yes" xml:space="preserve">
          <source>GROUPS</source>
          <target state="translated">GROUPS</target>
        </trans-unit>
        <trans-unit id="47abf252888b506642430a87f17ad2e364853ea7" translate="yes" xml:space="preserve">
          <source>GROUPS frames</source>
          <target state="translated">GROUPSフレーム</target>
        </trans-unit>
        <trans-unit id="5023fde21a93efcc45f3ef1278a03020db274d7f" translate="yes" xml:space="preserve">
          <source>Ge</source>
          <target state="translated">Ge</target>
        </trans-unit>
        <trans-unit id="5f5383c13d2f60a6733afafdeaf91505cfcc253b" translate="yes" xml:space="preserve">
          <source>Generalized ALTER TABLE procedure</source>
          <target state="translated">一般化されたALTER TABLE手続き</target>
        </trans-unit>
        <trans-unit id="200f1a824c74356136271be8f5cec761b8361890" translate="yes" xml:space="preserve">
          <source>Generalized the IS and IS NOT operators to take arbitrary expressions on their right-hand side.</source>
          <target state="translated">ISとIS NOT演算子を一般化し、任意の式を右辺で取るようにしました。</target>
        </trans-unit>
        <trans-unit id="b3419155244f27d32ab3d7f4be3add6bd08da9d5" translate="yes" xml:space="preserve">
          <source>Generally speaking, there are three separate subsystems within SQLite that can be modified or overridden at compile-time. The mutex subsystem is used to serialize access to SQLite resources that are shared among threads. The memory allocation subsystem is used to allocate memory required by SQLite objects and for the database cache. Finally, the &lt;a href=&quot;c3ref/vfs&quot;&gt;Virtual File System&lt;/a&gt; subsystem is used to provide a portable interface between SQLite and the underlying operating system and especially the file system. We call these three subsystems the &quot;interface&quot; subsystems of SQLite.</source>
          <target state="translated">一般的に言えば、SQLiteには、コンパイル時に変更またはオーバーライドできる3つの独立したサブシステムがあります。 mutexサブシステムは、スレッド間で共有されるSQLiteリソースへのアクセスをシリアル化するために使用されます。メモリ割り当てサブシステムは、SQLiteオブジェクトとデータベースキャッシュに必要なメモリを割り当てるために使用されます。最後に、&lt;a href=&quot;c3ref/vfs&quot;&gt;仮想ファイルシステム&lt;/a&gt;サブシステムを使用して、SQLiteと基盤となるオペレーティングシステム、特にファイルシステムとの間にポータブルインターフェイスを提供します。これら3つのサブシステムをSQLiteの「インターフェース」サブシステムと呼びます。</target>
        </trans-unit>
        <trans-unit id="03b11aad395b9bb3b854450c1f0acff0112439bd" translate="yes" xml:space="preserve">
          <source>Generate A Changeset From A Session Object</source>
          <target state="translated">セッションオブジェクトからチェンジセットを生成する</target>
        </trans-unit>
        <trans-unit id="771f6c81129288bd0dca35edc653f4896b8a38b9" translate="yes" xml:space="preserve">
          <source>Generate A Patchset From A Session Object</source>
          <target state="translated">セッションオブジェクトからパッチセットを生成する</target>
        </trans-unit>
        <trans-unit id="c543fcc61a656cc087657032229c13b299493cc4" translate="yes" xml:space="preserve">
          <source>Generate all multiples of 5 less than or equal to 100:</source>
          <target state="translated">100以下の5の倍数をすべて生成します。</target>
        </trans-unit>
        <trans-unit id="79e208b13cb09ea92286261229fb60357b5683cd" translate="yes" xml:space="preserve">
          <source>Generate the 20 random integer values:</source>
          <target state="translated">20個のランダムな整数値を生成します。</target>
        </trans-unit>
        <trans-unit id="46614740c9601066a8714b11664b1eb75a5a0bb4" translate="yes" xml:space="preserve">
          <source>Generating the results of a simple SELECT statement is presented as a four step process in the description below:</source>
          <target state="translated">単純なSELECT文の結果を生成することは、以下の説明では4つのステップのプロセスとして示されています。</target>
        </trans-unit>
        <trans-unit id="0060bdc4470d529ca18bce37edc0d7a0701d9b10" translate="yes" xml:space="preserve">
          <source>Geopoly</source>
          <target state="translated">Geopoly</target>
        </trans-unit>
        <trans-unit id="c4340d254981277ce14859ec23653c0dac4e3963" translate="yes" xml:space="preserve">
          <source>Geopoly operates on &quot;simple&quot; polygons - that is, polygons for which the boundary does not intersect itself. Geopoly thus extends the capabilities of the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; which can only deal with rectangular areas. On the other hand, the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; is able to handle between 1 and 5 coordinate dimensions, whereas Geopoly is restricted to 2-dimensional shapes only.</source>
          <target state="translated">Geopolyは「単純な」ポリゴン、つまり境界がそれ自体と交差しないポリゴンで動作します。したがって、Geopolyは、&lt;a href=&quot;rtree&quot;&gt;R-Tree拡張機能&lt;/a&gt;を拡張します。これは、長方形の領域のみを処理できます。一方、&lt;a href=&quot;rtree&quot;&gt;R-Tree拡張機能&lt;/a&gt;は1から5の座標次元を処理できますが、Geopolyは2次元の形状のみに制限されています。</target>
        </trans-unit>
        <trans-unit id="6dd9a0429b5e12a110f96aed0989c67466586ea1" translate="yes" xml:space="preserve">
          <source>Geopoly stores all polygons internally using a binary format. A binary polygon consists of a 4-byte header following by an array of coordinate pairs in which each dimension of each coordinate is a 32-bit floating point number.</source>
          <target state="translated">Geopoly は、すべてのポリゴンをバイナリ形式で内部的に保存します。バイナリポリゴンは、4バイトのヘッダと、各座標の各次元が32ビットの浮動小数点数である座標ペアの配列で構成されています。</target>
        </trans-unit>
        <trans-unit id="230fd79e9ac234b116998f305ec36a626773a0c1" translate="yes" xml:space="preserve">
          <source>Get a copy of the prebuilt binaries for your machine, or get a copy of the sources and compile them yourself. Visit the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download&lt;/a&gt; page for more information.</source>
          <target state="translated">マシンのビルド済みバイナリのコピーを入手するか、ソースのコピーを入手して自分でコンパイルします。詳細については、&lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;ダウンロード&lt;/a&gt;ページにアクセスしてください。</target>
        </trans-unit>
        <trans-unit id="f22b4172b2caeb752e5b6845137b0e1c3132162f" translate="yes" xml:space="preserve">
          <source>Get a new integer record number (a.k.a &quot;rowid&quot;) used as the key to a table. The record number is not previously used as a key in the database table that cursor P1 points to. The new record number is written written to register P2.</source>
          <target state="translated">テーブルのキーとして使用される新しい整数のレコード番号(別名「rowid」)を取得します。このレコード番号は、カーソルP1が指し示すデータベーステーブルのキーとして以前に使用されたものではありません。新しいレコード番号はレジスタP2に書き込まれます。</target>
        </trans-unit>
        <trans-unit id="2c8ad3eda2ae8758b9937a69c2cdf3d37bc6a82b" translate="yes" xml:space="preserve">
          <source>Get extension loading working on Cygwin.</source>
          <target state="translated">Cygwinで拡張機能の読み込みが動作するようにします。</target>
        </trans-unit>
        <trans-unit id="70d300a9221d054ecf73f3a432c241cce5538fb1" translate="yes" xml:space="preserve">
          <source>Get the SQLITE_ENABLE_LOCKING_STYLE macro working again on Mac OS X.</source>
          <target state="translated">Mac OS X で SQLITE_ENABLE_LOCKING_STYLE マクロが再び動作するようになりました。</target>
        </trans-unit>
        <trans-unit id="191ab3ffcff8c3d125f02fa19cf1b4772a774563" translate="yes" xml:space="preserve">
          <source>Get the library working correctly when compiled with GCC option &quot;-fstrict-aliasing&quot;.</source>
          <target state="translated">GCCオプション&quot;-fstrict-aliasing &quot;でコンパイルしたときに、ライブラリが正しく動作するようにしました。</target>
        </trans-unit>
        <trans-unit id="e33fe52a421a08f566920837d8eaa9b7577c26cc" translate="yes" xml:space="preserve">
          <source>Git allows you to go backwards in time easily. Given the latest check-in on a branch, Git lets you see all the ancestors of that check-in. But Git makes it difficult to move in the other direction. Given some historical check-in, it is quite challenging in Git to find out what came next. It can be done, but it is sufficiently difficult that people rarely do it. Common interfaces for Git, such as GitHub, do not support the ability.</source>
          <target state="translated">Gitを使えば、簡単に過去に遡ることができます。あるブランチの最新のチェックインが与えられると、Gitはそのチェックインのすべての先祖を見ることができます。しかし、Gitは逆方向への移動を困難にします。ある程度の歴史的なチェックインを考えると、次に何が来たのかを調べるのはGitではかなり困難です。それは可能ですが、十分に困難なので、ほとんどの人がそれをすることはありません。GitHubのようなGitの共通インターフェースは、この機能をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="b6fbc2ab6d8b00135f72a297ae81133b9c538d92" translate="yes" xml:space="preserve">
          <source>Git commands (and/or options on commands) for moving and comparing content between all of these locations.</source>
          <target state="translated">これらすべての場所の間でコンテンツを移動したり比較したりするための Git コマンド (および/またはコマンドのオプション)です。</target>
        </trans-unit>
        <trans-unit id="913e20aa0e82cacccbed30743753b5fea41f9dd9" translate="yes" xml:space="preserve">
          <source>Git is complex software. One needs an installer of some kind to put Git on a developer workstation, or to upgrade to a newer version of Git. Setting up a Git server is non-trivial, and so most users have to use a third-party service such as GitHub or GitLab, and thus introduce additional (unnecessary) dependencies into the project.</source>
          <target state="translated">Git は複雑なソフトウェアです。開発者のワークステーションにGitをインストールしたり、新しいバージョンのGitにアップグレードしたりするには、何らかのインストーラーが必要です。Gitサーバーを設定するのは至難の業なので、ほとんどのユーザーはGitHubやGitLabのようなサードパーティのサービスを使わなければならず、プロジェクトに追加の(不要な)依存関係を導入しなければなりません。</target>
        </trans-unit>
        <trans-unit id="ee613d9b4f6dfc0f80be0bd2cfff2ea77808bbb6" translate="yes" xml:space="preserve">
          <source>Git keeps the complete DAG of the check-in sequence. But branch tags are local information that is not synced and not retained once a branch closes. This makes review of historical branches tedious.</source>
          <target state="translated">Git はチェックインシーケンスの完全な DAG を保持しています。しかし、ブランチタグはローカル情報であり、ブランチが閉じても同期されず、保持されません。そのため、履歴のあるブランチを確認するのが面倒になります。</target>
        </trans-unit>
        <trans-unit id="48b3160f0b763f1616179debce43562e664f02d9" translate="yes" xml:space="preserve">
          <source>GitHub and GitLab offer nothing comparable. The closest I have found is the &lt;a href=&quot;https://github.com/sqlite/sqlite/network&quot;&gt;network&lt;/a&gt;, which is slow to render (unless it is already cached), does not offer nearly as much details, and scarcely works on mobile. The &lt;a href=&quot;https://github.com/sqlite/sqlite/commits/master&quot;&gt;commits&lt;/a&gt; view of GitHub provides more detail, renders quickly, and works on mobile, but only shows a single branch at a time, so I cannot easily know if I've seen all of the recent changes. And even if GitHub/GitLab did offer better interfaces, both are third-party services. They are not a core part of Git. Hence, using them introduces yet another dependency into the project.</source>
          <target state="translated">GitHubとGitLabは比較できるものを何も提供していません。私が見つけた最も近いものは&lt;a href=&quot;https://github.com/sqlite/sqlite/network&quot;&gt;ネットワークです&lt;/a&gt;。（すでにキャッシュされている場合を除いて）レンダリングが遅く、詳細がほとんど提供されておらず、モバイルではほとんど機能しません。GitHub の&lt;a href=&quot;https://github.com/sqlite/sqlite/commits/master&quot;&gt;コミット&lt;/a&gt;ビューは、より詳細で迅速にレンダリングされ、モバイルで機能しますが、一度に1つのブランチしか表示しないため、最近の変更をすべて確認したかどうかは簡単にはわかりません。GitHub / GitLabがより優れたインターフェースを提供したとしても、どちらもサードパーティのサービスです。これらはGitの中核部分ではありません。したがって、それらを使用すると、プロジェクトにさらに別の依存関係が生じます。</target>
        </trans-unit>
        <trans-unit id="ba7606fea498a9e876c11c77be2a94dc96cb33f9" translate="yes" xml:space="preserve">
          <source>Given a page number P and a maximum WAL frame index M, return the largest WAL frame index for page P that does not exceed M, or return NULL if there are no frames for page P that do not exceed M.</source>
          <target state="translated">ページ番号Pと最大WALフレームインデックスMが与えられた場合,ページPの最大WALフレームインデックスでMを超えないものを返します.</target>
        </trans-unit>
        <trans-unit id="d4a9375f517c74831802a20b14cf1be5743c9399" translate="yes" xml:space="preserve">
          <source>Given a single SQL statement, there might be dozens, hundreds, or even thousands of ways to implement that statement, depending on the complexity of the statement itself and of the underlying database schema. The task of the query planner is to select an algorithm from among the many choices that provides the answer with a minimum of disk I/O and CPU overhead.</source>
          <target state="translated">1つのSQL文が与えられた場合、そのSQL文を実装する方法は、その文自体の複雑さや基礎となるデータベーススキーマの複雑さに応じて、何十通り、何百通り、あるいは何千通りもあるかもしれません。クエリプランナのタスクは、多くの選択肢の中から、ディスクI/OとCPUのオーバーヘッドを最小限に抑えて答えを提供するアルゴリズムを選択することです。</target>
        </trans-unit>
        <trans-unit id="f6bcca46f0f74a9ae01ce42d9f7404d2419d51ad" translate="yes" xml:space="preserve">
          <source>Given all of the information above, the job of the xBestIndex method it to figure out the best way to search the virtual table.</source>
          <target state="translated">上記のすべての情報を考えると、xBestIndexメソッドの仕事は、仮想テーブルを検索するための最良の方法を見つけることです。</target>
        </trans-unit>
        <trans-unit id="3214b13dd0b542c059230864a7a5bcd2b12ab804" translate="yes" xml:space="preserve">
          <source>Given an input string X, this routine attempts to determine the dominant script of that input and returns the ISO-15924 numeric code for that script. The current implementation understands the following scripts:</source>
          <target state="translated">入力文字列 X が与えられると、このルーチンは、その入力の支配的なスクリプトを決定しようとし、そのスクリプトの ISO-15924 数値コードを返します。現在の実装では、以下のスクリプトを理解できます。</target>
        </trans-unit>
        <trans-unit id="c57b59e0dd1b427eb5c7b60fabfb8b9d76033a70" translate="yes" xml:space="preserve">
          <source>Given the definition of X1 above, the following expressions have historically evaluated to FALSE in SQLite, though the correct answer is actually NULL:</source>
          <target state="translated">上記の X1 の定義を考えると、以下の式は歴史的に SQLite で FALSE と評価されてきましたが、正しい答えは実際には NULL です。</target>
        </trans-unit>
        <trans-unit id="bd2ada8cc33bdc4785b371a48d725c0e9ca58446" translate="yes" xml:space="preserve">
          <source>Given the new multi-column Idx3 index, it is now possible for SQLite to find the price of California oranges using only 2 binary searches:</source>
          <target state="translated">新しいマルチカラム Idx3 インデックスを使用すると、SQLite では 2 つのバイナリ検索だけでカリフォルニアオレンジの価格を検索できるようになりました。</target>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="617490ec40d56766edf8aff111990bee9834d1c1" translate="yes" xml:space="preserve">
          <source>Gosub</source>
          <target state="translated">Gosub</target>
        </trans-unit>
        <trans-unit id="0a9ffc4a328e6d21b11f3b8312d08e5b413aec49" translate="yes" xml:space="preserve">
          <source>Goto</source>
          <target state="translated">Goto</target>
        </trans-unit>
        <trans-unit id="1dee13ac09a18c736a85fb7212501ca3f0535655" translate="yes" xml:space="preserve">
          <source>Gt</source>
          <target state="translated">Gt</target>
        </trans-unit>
        <trans-unit id="60f4e65b35154fc853b0c67ac464ba87691c1af9" translate="yes" xml:space="preserve">
          <source>Guard your tongue against evil and depraved speech.</source>
          <target state="translated">悪と堕落した言葉から舌を守りなさい。</target>
        </trans-unit>
        <trans-unit id="3472b7100ee6c34d2c985ec6e738e904962356df" translate="yes" xml:space="preserve">
          <source>HAVING</source>
          <target state="translated">HAVING</target>
        </trans-unit>
        <trans-unit id="a4c7ee9ba5c961273e153da9b6004699add74ac0" translate="yes" xml:space="preserve">
          <source>HH:MM</source>
          <target state="translated">HH:MM</target>
        </trans-unit>
        <trans-unit id="4a05a9c514dbbe7b13aeee7ffbbac9804dba7f74" translate="yes" xml:space="preserve">
          <source>HH:MM:SS</source>
          <target state="translated">HH:MM:SS</target>
        </trans-unit>
        <trans-unit id="4fe76e489c6dd906a0f1a9c53aab6e472da095e8" translate="yes" xml:space="preserve">
          <source>HH:MM:SS.SSS</source>
          <target state="translated">HH:MM:SS.SSS</target>
        </trans-unit>
        <trans-unit id="65f5a5cdef2d1220d932d3711961b5f933bef00b" translate="yes" xml:space="preserve">
          <source>HHHHHHHH</source>
          <target state="translated">HHHHHHHH</target>
        </trans-unit>
        <trans-unit id="cbc6ab8d850f8cff446447123804da23a703c293" translate="yes" xml:space="preserve">
          <source>Halt</source>
          <target state="translated">Halt</target>
        </trans-unit>
        <trans-unit id="c9efb4e35e5411aedaf0542890d4f34de7fdc553" translate="yes" xml:space="preserve">
          <source>HaltIfNull</source>
          <target state="translated">HaltIfNull</target>
        </trans-unit>
        <trans-unit id="eda901a16a2ed9d0d0e178d305fa51f41c885dd9" translate="yes" xml:space="preserve">
          <source>Has the same PRIMARY KEY definition.</source>
          <target state="translated">同じPRIMARY KEYの定義を持っています。</target>
        </trans-unit>
        <trans-unit id="7b3c15bec716c58e30bb9a01cc52d490760b69bf" translate="yes" xml:space="preserve">
          <source>Has the same name,</source>
          <target state="translated">同じ名前を持っています。</target>
        </trans-unit>
        <trans-unit id="96ee9d0e4b354db6f1aac2ad6a31abd4bc3e74ca" translate="yes" xml:space="preserve">
          <source>Has the same set of columns declared in the same order, and</source>
          <target state="translated">同じ順序で宣言された同じカラムのセットを持ち</target>
        </trans-unit>
        <trans-unit id="71024d7461751155928cb62c4bbb4edb8155f4cb" translate="yes" xml:space="preserve">
          <source>Hate no one.</source>
          <target state="translated">誰も憎まない。</target>
        </trans-unit>
        <trans-unit id="f5e9b1bebb569eb2b57a7ab4d85d0681e37d4262" translate="yes" xml:space="preserve">
          <source>Having SQLite take ownership of the type strings would impose a performance cost on all applications, even applications that do not use the pointer-passing interfaces. SQLite passes values around as instances of the &lt;a href=&quot;c3ref/value&quot;&gt;sqlite3_value&lt;/a&gt; object. That object has a destructor, which because of the fact that sqlite3_value objects are used for nearly everything, is invoked frequently. If the destructor needs to check to see if there is a pointer type string that needs to be freed, that is a few extra CPU cycles that need to be burned on each call to the destructor. Those cycles add up. We would be willing to bear the cost of the extra CPU cycles if pointer-passing was a commonly used programming paradigm, but pointer-passing is rare, and so it seems unwise to impose a run-time cost on billions and billions of applications that do not use pointer passing just for convenience of a few applications that do.</source>
          <target state="translated">SQLiteが文字列型の所有権を取得するようにすると、すべてのアプリケーション（ポインタ渡しインターフェイスを使用しないアプリケーションを含む）にパフォーマンスコストがかかります。 SQLiteは&lt;a href=&quot;c3ref/value&quot;&gt;sqlite3_valueの&lt;/a&gt;インスタンスとして値を渡しますオブジェクト。そのオブジェクトにはデストラクタがあり、sqlite3_valueオブジェクトがほぼすべてに使用されるため、頻繁に呼び出されます。デストラクタが解放する必要があるポインタ型の文字列があるかどうかを確認する必要がある場合、それはデストラクタへの各呼び出しで焼き付ける必要があるいくつかの余分なCPUサイクルです。これらのサイクルが加算されます。ポインターの受け渡しが一般的に使用されているプログラミングパラダイムである場合は、追加のCPUサイクルのコストを負担してもかまいませんが、ポインターの受け渡しはまれであるため、数十億および数十億のアプリケーションにランタイムコストを課すのは賢明ではありません。ポインタを渡すいくつかのアプリケーションの便宜のためだけに、ポインタの受け渡しを使用しないでください。</target>
        </trans-unit>
        <trans-unit id="3880fcd08d24da661937a86693cfca26882a3b4e" translate="yes" xml:space="preserve">
          <source>Hazards of upgrading to the NGQP</source>
          <target state="translated">NGQPへのアップグレードの危険性</target>
        </trans-unit>
        <trans-unit id="5050e4d38d7df11eb3b253f0629fcc46c260dc76" translate="yes" xml:space="preserve">
          <source>Header string: 0xd9, 0xd5, 0x05, 0xf9, 0x20, 0xa1, 0x63, 0xd7</source>
          <target state="translated">ヘッダー文字列。0xd9、0xd5、0x05、0xf9、0x20、0xa1、0x63、0xd7</target>
        </trans-unit>
        <trans-unit id="4bc19fb4af9f917cd00992c6391f45202ff0d0ec" translate="yes" xml:space="preserve">
          <source>Hence, a good rule of thumb is that your database schema should never contain two indices where one index is a prefix of the other. Drop the index with fewer columns. SQLite will still be able to do efficient lookups with the longer index.</source>
          <target state="translated">したがって、データベーススキーマには、一方のインデックスがもう一方のインデックスの接頭辞になっているような2つのインデックスを含むべきではないというのが良い経験則です。カラム数の少ないインデックスを削除してください。SQLiteは長いインデックスを使っても効率的な検索を行うことができます。</target>
        </trans-unit>
        <trans-unit id="e3f076946ec3be55b66dffc59ab395c4e63eeb8f" translate="yes" xml:space="preserve">
          <source>Hence, by adding extra &quot;output&quot; columns onto the end of an index, one can avoid having to reference the original table and thereby cut the number of binary searches for a query in half. This is a constant-factor improvement in performance (roughly a doubling of the speed). But on the other hand, it is also just a refinement; A two-fold performance increase is not nearly as dramatic as the one-million-fold increase seen when the table was first indexed. And for most queries, the difference between 1 microsecond and 2 microseconds is unlikely to be noticed.</source>
          <target state="translated">したがって、インデックスの末尾に余分な「出力」カラムを追加することで、元のテーブルを参照する必要がなくなり、それによってクエリのバイナリ検索の数を半分に減らすことができます。これは、パフォーマンスの恒常的な向上です(速度が約2倍になります)。2倍の性能向上は、テーブルが最初にインデックス化されたときに見られた100万倍の性能向上ほど劇的ではありません。そして、ほとんどのクエリでは、1マイクロ秒と2マイクロ秒の差に気づくことはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="b665f7a53251e88b80c18ae95a6e2a7570ff2c9e" translate="yes" xml:space="preserve">
          <source>Hence, in comparison to other approaches, the use of an SQLite database as an application file format has compelling advantages. Here are a few of these advantages, enumerated and expounded:</source>
          <target state="translated">したがって、他のアプローチと比較して、アプリケーションファイル形式としてSQLiteデータベースを使用することには説得力のある利点があります。ここでは、これらの利点のいくつかを列挙して説明します。</target>
        </trans-unit>
        <trans-unit id="39e8db1d33a3457396e45de0c0793052727a641e" translate="yes" xml:space="preserve">
          <source>Hence, the content encoding for a WITHOUT ROWID table is the same as the content encoding for an ordinary rowid table, except that the order of the columns is rearranged so that PRIMARY KEY columns come first, and the content is used as the key in an index b-tree rather than as the data in a table b-tree. The special encoding rules for columns with REAL affinity apply to WITHOUT ROWID tables the same as they do with rowid tables.</source>
          <target state="translated">したがって、WITHOUT ROWIDテーブルのコンテンツエンコーディングは、通常のROWIDテーブルのコンテンツエンコーディングと同じですが、列の順序がPRIMARY KEY列が最初に来るように並べ替えられ、コンテンツはテーブルb-treeのデータとしてではなく、インデックスb-treeのキーとして使用されます。REALアフィニティを持つカラムのための特別なエンコーディング規則は、ROWIDテーブルの場合と同様に、WITHOUT ROWIDテーブルにも適用されます。</target>
        </trans-unit>
        <trans-unit id="999cfa83416c7b736dc3f3dfa6e7f25b9ba6e98f" translate="yes" xml:space="preserve">
          <source>Here again, version 2.7.0 of SQLite used to run at about the same speed as MySQL. But now version 2.7.6 is over two times faster than MySQL and over twenty times faster than PostgreSQL.</source>
          <target state="translated">ここでも、SQLiteのバージョン2.7.0は、以前はMySQLとほぼ同じ速度で動作していました。しかし、現在ではバージョン2.7.6はMySQLの2倍以上、PostgreSQLの20倍以上の速度で動作しています。</target>
        </trans-unit>
        <trans-unit id="c79a9d1055558ef2d9992c6424392d62b259c2a6" translate="yes" xml:space="preserve">
          <source>Here are some existing and postulated uses for virtual tables:</source>
          <target state="translated">ここでは、仮想テーブルの既存の用途と想定される用途をいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="f0580ad7def68334eac7c2c033faae47fa33aa31" translate="yes" xml:space="preserve">
          <source>Here are the syntax details:</source>
          <target state="translated">以下、構文の詳細です。</target>
        </trans-unit>
        <trans-unit id="c84ee5f5403083ecda923ec1470b2d4f31fd0f00" translate="yes" xml:space="preserve">
          <source>Here is a complete template extension that you can copy/paste to get started:</source>
          <target state="translated">ここでは、コピー&amp;ペーストして始めることができる完全なテンプレート拡張機能をご紹介します。</target>
        </trans-unit>
        <trans-unit id="537d394cf0d1eecb92a9cbe8efc7e1a703bdd18e" translate="yes" xml:space="preserve">
          <source>Here is a query that computes the average height over everyone in Alice's organization, including Alice:</source>
          <target state="translated">これは、アリスを含むアリスの組織内の全員の平均身長を計算するクエリです。</target>
        </trans-unit>
        <trans-unit id="dd42feed9698b376dcb10e9aa54e385c734b65a6" translate="yes" xml:space="preserve">
          <source>Here is a query to show the tree structure in a breadth-first pattern:</source>
          <target state="translated">ここでは、木の構造をブレッドファーストパターンで表示するクエリです。</target>
        </trans-unit>
        <trans-unit id="b68ea20ab0a8004dffe949b080033114856a05ba" translate="yes" xml:space="preserve">
          <source>Here is a simple example of omitting a LEFT JOIN:</source>
          <target state="translated">ここでは、left joinを省略した簡単な例を紹介します。</target>
        </trans-unit>
        <trans-unit id="22d888f42ada11de3c14b5860a924536cf19b222" translate="yes" xml:space="preserve">
          <source>Here is a slightly different way to describe the aPgno values: If you think of all aPgno values as a contiguous array, then the database page number stored in the i-th frame of the WAL file is stored in aPgno[i]. Of course, aPgno is not a contiguous array. The first 4062 entries are on the first 32768-byte unit of the shm file and subsequent values are in 4096 entry chunks in later units of the shm file.</source>
          <target state="translated">ここで、aPgno値の記述方法を少し変えてみましょう。すべてのaPgno値を連続配列と考えると、WALファイルのi番目のフレームに格納されているデータベースページ番号は、aPgno[i]に格納されます。もちろん、aPgnoは連続配列ではありません。最初の4062エントリはshmファイルの最初の32768バイト単位にあり、それ以降の値はshmファイルの後の単位にある4096エントリのチャンクにあります。</target>
        </trans-unit>
        <trans-unit id="eeed83aeb26a72a7167e0caa92d0a130551072b7" translate="yes" xml:space="preserve">
          <source>Here is a summary of what the core interfaces do:</source>
          <target state="translated">ここでは、コアインターフェースが何をしているのかをまとめてみました。</target>
        </trans-unit>
        <trans-unit id="8a2373a91d98c2486bbd1ed6e2138a7e77394ed5" translate="yes" xml:space="preserve">
          <source>Here is a variation on the previous example:</source>
          <target state="translated">先ほどの例のバリエーションです。</target>
        </trans-unit>
        <trans-unit id="1319ba3fc57ef36ac27efdbc47123bdd4cb7f431" translate="yes" xml:space="preserve">
          <source>Here is an alternative description of the same computation:</source>
          <target state="translated">ここでは、同じ計算の別の説明をします。</target>
        </trans-unit>
        <trans-unit id="44eacff0724c9f996876f69099ca0b2726a97ade" translate="yes" xml:space="preserve">
          <source>Here is an alternative way of describing the hash look-up algorithm: Start with h = (P * 383)%8192 and look at aHash[h] and subsequent entries, wrapping around to zero when h reaches 8192, until finding an entry with aHash[h]==0. All aPgno entries having a page number of P will have an index that is one of the aHash[h] values thusly computed. But not all the computed aHash[h] values will meet the matching criteria, so you must check them independently. The speed advantage comes about because normally this set of h values is very small.</source>
          <target state="translated">ハッシュ検索アルゴリズムを記述する別の方法を以下に示します。h=(P*383)%8192から始めて、aHash[h]とそれ以降のエントリを調べ、hが8192に達した時点でゼロに折り返し、aHash[h]==0のエントリが見つかるまで探します。 ページ番号がPのすべてのaPgnoエントリは、このようにして計算されたaHash[h]値の1つであるインデックスを持ちます。しかし、計算されたaHash[h]値のすべてが一致するわけではないので、それらを個別にチェックする必要があります。通常,このh値の集合は非常に小さいので,速度の面での利点があります.</target>
        </trans-unit>
        <trans-unit id="1a49c4bb8c6fe24c99e1160edbe5f45003dd833d" translate="yes" xml:space="preserve">
          <source>Here is an example using the built-in row_number() window function:</source>
          <target state="translated">組み込みの row_number()ウィンドウ関数を使用した例を示します。</target>
        </trans-unit>
        <trans-unit id="1ed2d64e0577782df2f1f708b1c461ee5ebea46a" translate="yes" xml:space="preserve">
          <source>Here is what is going to happen: The first SELECT statement will construct rows of the result and save each row as the key of an entry in the transient table. The data for each entry in the transient table is a never used so we fill it in with an empty string. The second SELECT statement also constructs rows, but the rows constructed by the second SELECT are removed from the transient table. That is why we want the rows to be stored in the key of the SQLite file instead of in the data -- so they can be easily located and deleted.</source>
          <target state="translated">ここで何が起こるかを説明します。最初のSELECT文で結果の行を構築し、各行を過渡表のエントリのキーとして保存します。トランジェント・テーブルの各エントリのデータは決して使用されないので、空の文字列で埋めます。2番目のSELECT文も行を構築しますが、2番目のSELECTで構築された行は過渡テーブルから削除されます。そのため、行はデータの中ではなくSQLiteファイルのキーに格納したいのですが、そうすれば簡単に位置を特定して削除することができます。</target>
        </trans-unit>
        <trans-unit id="7a844050eead2e7f9a21cd042c8a0efba1c399bc" translate="yes" xml:space="preserve">
          <source>Here is what the program must do. First it has to locate all of the records in the table &quot;examp&quot; that are to be deleted. This is done using a loop very much like the loop used in the SELECT examples above. Once all records have been located, then we can go back through and delete them one by one. Note that we cannot delete each record as soon as we find it. We have to locate all records first, then go back and delete them. This is because the SQLite database backend might change the scan order after a delete operation. And if the scan order changes in the middle of the scan, some records might be visited more than once and other records might not be visited at all.</source>
          <target state="translated">ここでは、プログラムが何をしなければならないかです。最初に削除されるテーブル &quot;examp &quot;内のすべてのレコードを見つけなければなりません。これは、上記のSELECTの例で使用されているループと非常によく似たループを使用して行われます。すべてのレコードを見つけたら、それを1つずつ削除することができます。レコードを見つけたらすぐに削除することはできないことに注意してください。最初にすべてのレコードを見つけてから、さかのぼって削除しなければなりません。これは、SQLiteデータベースのバックエンドが削除操作の後にスキャン順序を変更する可能性があるためです。また、スキャンの途中でスキャン順序が変わると、いくつかのレコードが複数回訪問されたり、他のレコードが全く訪問されなかったりする可能性があります。</target>
        </trans-unit>
        <trans-unit id="6ed0e64b4172a16a9716e7e75ddd35007c4f6e5a" translate="yes" xml:space="preserve">
          <source>Here is what you do to start experimenting with SQLite without having to do a lot of tedious reading and configuration:</source>
          <target state="translated">面倒な読み込みや設定をたくさんしなくても、SQLiteの実験を始めるにはどうすればいいのかをご紹介します。</target>
        </trans-unit>
        <trans-unit id="c11a956fd1daf361e07b9a2963b5331668a6cb09" translate="yes" xml:space="preserve">
          <source>Here the apostrophe has been escaped and the SQL statement is well-formed. When generating SQL on-the-fly from data that might contain a single-quote character ('), it is always a good idea to use the SQLite printf routines and the %q formatting option instead of &lt;b&gt;sprintf&lt;/b&gt;.</source>
          <target state="translated">ここではアポストロフィがエスケープされており、SQLステートメントは整形式です。単一引用符文字（ '）を含む可能性のあるデータからオンザフライでSQLを生成する場合、&lt;b&gt;sprintfの&lt;/b&gt;代わりにSQLite printfルーチンと％qフォーマットオプションを使用することは常に良い考えです。</target>
        </trans-unit>
        <trans-unit id="53844b42e0f15c4e9c92f326da701e5edff51b64" translate="yes" xml:space="preserve">
          <source>Here the inequalities are on columns x and y which are not the left-most index columns. Hence, the histogram data which is collected no left-most column of indices is useless in helping to choose between the range constraints on columns x and y.</source>
          <target state="translated">ここでは、不等式は、左端のインデックス列ではない列xとyにあります。したがって、インデックスの左端の列が収集されていないヒストグラムデータは、列xとyの範囲制約を選択するのに役に立たない。</target>
        </trans-unit>
        <trans-unit id="54b1a90f72334cf67c79da3608b8cff7cc194a79" translate="yes" xml:space="preserve">
          <source>Hexadecimal</source>
          <target state="translated">Hexadecimal</target>
        </trans-unit>
        <trans-unit id="f3f781093bc605abee81ccbeb636a20f530bbe5d" translate="yes" xml:space="preserve">
          <source>Hexadecimal integer literals</source>
          <target state="translated">16進整数リテラル</target>
        </trans-unit>
        <trans-unit id="35e13960711ca47c62471d92f2b4029ee7852496" translate="yes" xml:space="preserve">
          <source>Hexadecimal integer literals follow the C-language notation of &quot;0x&quot; or &quot;0X&quot; followed by hexadecimal digits. For example, 0x1234 means the same as 4660 and 0x8000000000000000 means the same as -9223372036854775808. Hexadecimal integer literals are interpreted as 64-bit two's-complement integers and are thus limited to sixteen significant digits of precision. Support for hexadecimal integers was added to SQLite version 3.8.6 (2014-08-15). For backwards compatibility, the &quot;0x&quot; hexadecimal integer notation is only understood by the SQL language parser, not by the type conversions routines. String variables that contain text formatted like hexadecimal integers are not interpreted as hexadecimal integers when coercing the string value into an integer due to a &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST expression&lt;/a&gt; or for a &lt;a href=&quot;datatype3#affinity&quot;&gt;column affinity&lt;/a&gt; transformation or prior to performing a numeric operation or for any other run-time conversions. When coercing a string value in the format of a hexadecimal integer into an integer value, the conversion process stops when the 'x' character is seen so the resulting integer value is always zero. SQLite only understands the hexadecimal integer notation when it appears in the SQL statement text, not when it appears as part of the content of the database.</source>
          <target state="translated">16進整数リテラルは、C言語表記の「0x」または「0X」の後に16進数字が続きます。たとえば、0x1234は4660と同じ意味であり、0x8000000000000000は-9223372036854775808と同じ意味です。 16進整数リテラルは64ビットの2の補数の整数として解釈されるため、有効桁数は16桁に制限されています。 16進整数のサポートがSQLiteバージョン3.8.6（2014-08-15）に追加されました。下位互換性のために、「0x」16進整数表記は、SQL言語パーサーによってのみ理解され、型変換ルーチンでは理解されません。16進整数のようにフォーマットされたテキストを含む文字列変数は、 &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST式&lt;/a&gt;または&lt;a href=&quot;datatype3#affinity&quot;&gt;列アフィニティの&lt;/a&gt;ために文字列値を整数に強制変換するときに16進整数として解釈されません変換、または数値演算を実行する前、またはその他のランタイム変換。16進整数の形式の文字列値を整数値に強制変換する場合、「x」文字が表示されると変換プロセスが停止するため、結果の整数値は常にゼロになります。SQLiteは、データベースのコンテンツの一部として表示される場合ではなく、SQLステートメントのテキストに表示される場合にのみ、16進整数表記を理解します。</target>
        </trans-unit>
        <trans-unit id="4413e5afdd76b08f7a57f3501dcd353af75c6909" translate="yes" xml:space="preserve">
          <source>Hexadecimal integers</source>
          <target state="translated">16進整数</target>
        </trans-unit>
        <trans-unit id="34ad49fd08b5d8ebfe6309e8a94dbdda68560346" translate="yes" xml:space="preserve">
          <source>Hidden column</source>
          <target state="translated">隠しカラム</target>
        </trans-unit>
        <trans-unit id="47adea5ce487ea3890476b37d1c95b4a2f866391" translate="yes" xml:space="preserve">
          <source>Hidden columns are not included in the expansion of a &quot;*&quot; expression in the result set of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;, and</source>
          <target state="translated">隠し列は結果セットの中の「*」という表現の拡張に含まれていない&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;、および</target>
        </trans-unit>
        <trans-unit id="20096dd8d3b8c2cfd4d3a69c38df377eed777771" translate="yes" xml:space="preserve">
          <source>Hidden columns are not included in the implicit column-list used by an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statement that lacks an explicit column-list.</source>
          <target state="translated">非表示の列は、明示的な列リストのない&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;ステートメントで使用される暗黙的な列リストには含まれません。</target>
        </trans-unit>
        <trans-unit id="b7668a93e533ae2c015270865d5e714d07d437f1" translate="yes" xml:space="preserve">
          <source>Hidden columns are not listed in the dataset returned by &quot;&lt;a href=&quot;pragma#pragma_table_info&quot;&gt;PRAGMA table_info&lt;/a&gt;&quot;,</source>
          <target state="translated">非表示の列は、「&lt;a href=&quot;pragma#pragma_table_info&quot;&gt;PRAGMA table_info&lt;/a&gt;」によって返されるデータセットにリストされていません。</target>
        </trans-unit>
        <trans-unit id="c4cf7b97c327f9d39106315e4a050c0b0f137cef" translate="yes" xml:space="preserve">
          <source>Hierarchical Query Examples</source>
          <target state="translated">階層型クエリの例</target>
        </trans-unit>
        <trans-unit id="62ae978c372dd625e1ad5bee3c09efecd27ef87c" translate="yes" xml:space="preserve">
          <source>High Reliability</source>
          <target state="translated">高い信頼性</target>
        </trans-unit>
        <trans-unit id="5b43fa59ed80a4a74e2345ca9a7be4d00498a5de" translate="yes" xml:space="preserve">
          <source>High-Level Query Language</source>
          <target state="translated">ハイレベルクエリ言語</target>
        </trans-unit>
        <trans-unit id="f0be6eee61b3f35036173bb461da267d072410b3" translate="yes" xml:space="preserve">
          <source>High-security Value</source>
          <target state="translated">安全性の高い価値</target>
        </trans-unit>
        <trans-unit id="d4e0f8e3d3d0dc08399c35d69b24eda9dfffeab6" translate="yes" xml:space="preserve">
          <source>Higher level logic within SQLite will normally intercept the error code and create a temporary in-memory shared memory region so that the current process can at least read the content of the database. This result code should not reach the application interface layer.</source>
          <target state="translated">SQLite 内の高レベルのロジックは通常、エラーコードを傍受して一時的なメモリ内共有メモリ領域を作成し、現在のプロセスが少なくともデータベースの内容を読み取れるようにします。この結果コードは、アプリケーションインターフェイス層には到達しないはずです。</target>
        </trans-unit>
        <trans-unit id="8ec8e6f8b27cff894766ae4e4215e6f333126ae8" translate="yes" xml:space="preserve">
          <source>Highest precedence (tightest grouping).</source>
          <target state="translated">最優先順位が高い(グループ分けがきつい)。</target>
        </trans-unit>
        <trans-unit id="9d8bc8b9f1a6b46c231d4505eec0f99894497892" translate="yes" xml:space="preserve">
          <source>Hint: applications can generate globally unique identifiers using this function together with &lt;a href=&quot;lang_corefunc#hex&quot;&gt;hex()&lt;/a&gt; and/or &lt;a href=&quot;lang_corefunc#lower&quot;&gt;lower()&lt;/a&gt; like this:</source>
          <target state="translated">ヒント：アプリケーションは、この関数を次のように&lt;a href=&quot;lang_corefunc#hex&quot;&gt;hex（）&lt;/a&gt;および/または&lt;a href=&quot;lang_corefunc#lower&quot;&gt;lower（）&lt;/a&gt;と組み合わせて使用​​して、グローバルに一意の識別子を生成できます。</target>
        </trans-unit>
        <trans-unit id="13895cc550db90756c2c44f981469cdd85261a1d" translate="yes" xml:space="preserve">
          <source>Hints for Debugging SQLite</source>
          <target state="translated">SQLiteをデバッグするためのヒント</target>
        </trans-unit>
        <trans-unit id="6b205a779ffaeec5fb12feda7165de7c06e54bbe" translate="yes" xml:space="preserve">
          <source>Historical test cases from &lt;a href=&quot;testing#aflfuzz&quot;&gt;AFL&lt;/a&gt;, &lt;a href=&quot;testing#ossfuzz&quot;&gt;OSS Fuzz&lt;/a&gt;, and &lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;dbsqlfuzz&lt;/a&gt; are collected in a set of database files in the main SQLite source tree and then rerun by the &quot;fuzzcheck&quot; utility program whenever one runs &quot;make test&quot;. Fuzzcheck only runs a few thousand &quot;interesting&quot; cases out of the hundreds of millions of cases that the various fuzzers have examined over the years. &quot;Interesting&quot; cases are cases that exhibit previously unseen behavior. Actual bugs found by fuzzers are always included among the interesting test cases, but most of the cases run by fuzzcheck were never actual bugs.</source>
          <target state="translated">&lt;a href=&quot;testing#aflfuzz&quot;&gt;AFL&lt;/a&gt;、&lt;a href=&quot;testing#ossfuzz&quot;&gt;OSS Fuzz&lt;/a&gt;、および&lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;dbsqlfuzzの&lt;/a&gt;履歴テストケースは、メインのSQLiteソースツリーの一連のデータベースファイルに収集され、「make test」を実行するたびに「fuzzcheck」ユーティリティプログラムによって再実行されます。 Fuzzcheckは、さまざまなファザーが長年にわたって調査した数億件のケースのうち、数千の「興味深い」ケースのみを実行します。 「興味深い」ケースとは、以前には目にしなかった動作を示すケースです。 fuzzerによって検出された実際のバグは常に興味深いテストケースに含まれますが、fuzzcheckによって実行されたケースのほとんどは実際のバグではありませんでした。</target>
        </trans-unit>
        <trans-unit id="67fec9a6d19b7573beec194f9c1e57c883f7bff1" translate="yes" xml:space="preserve">
          <source>Historically, backups (copies) of SQLite databases have been created using the following method:</source>
          <target state="translated">歴史的に、SQLiteデータベースのバックアップ(コピー)は以下の方法で作成されてきました。</target>
        </trans-unit>
        <trans-unit id="a7796946d81b3e384b117135d383fc5e5877941f" translate="yes" xml:space="preserve">
          <source>Historically, the bytecode engine in SQLite is called the &quot;Virtual DataBase Engine&quot; or &quot;VDBE&quot;. This website uses the terms &quot;bytecode engine&quot;, &quot;VDBE&quot;, &quot;virtual machine&quot;, and &quot;bytecode virtual machine&quot; interchangeably, as they all mean the same thing.</source>
          <target state="translated">歴史的には、SQLite のバイトコードエンジンは「Virtual DataBase Engine」または「VDBE」と呼ばれています。このウェブサイトでは、&quot;バイトコードエンジン&quot;、&quot;VDBE&quot;、&quot;仮想マシン&quot;、&quot;バイトコード仮想マシン &quot;という用語を互換的に使用しています。</target>
        </trans-unit>
        <trans-unit id="186352c9ed4b1d5538fac7c967930c7dfb52b78f" translate="yes" xml:space="preserve">
          <source>Historically, the return value from xFindFunction() was either zero or one. Zero means that the function is not overloaded and one means that it is overload. The ability to return values of &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; or greater was added in version 3.25.0 (2018-09-15). If xFindFunction returns &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; or greater, than means that the function takes two arguments and the function can be used as a boolean in the WHERE clause of a query and that the virtual table is able to exploit that function to speed up the query result. When xFindFunction returns &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; or larger, the value returned becomes the sqlite3_index_info.aConstraint.op value for one of the constraints passed into &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex()&lt;/a&gt; and the second argument becomes the value corresponding to that constraint that is passed to &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter()&lt;/a&gt;. This enables the xBestIndex()/xFilter implementations to use the function to speed its search.</source>
          <target state="translated">歴史的に、xFindFunction（）からの戻り値は0または1でした。ゼロは関数がオーバーロードされていないことを意味し、1は関数がオーバーロードされていることを意味します。&lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt;以上の値を返す機能は、バージョン3.25.0（2018-09-15）で追加されました。 xFindFunctionが&lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt;以上を返す場合は、関数が2つの引数を取り、その関数をクエリのWHERE句でブール値として使用でき、仮想テーブルがその関数を利用してクエリ結果を高速化できることを意味します。 xFindFunctionが&lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt;以上を返す場合、返される値は、&lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex（）に&lt;/a&gt;渡された制約の1つに対するsqlite3_index_info.aConstraint.op値になります。2番目の引数は、&lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter（）に&lt;/a&gt;渡される制約に対応する値になります。これにより、xBestIndex（）/ xFilter実装が関数を使用して検索を高速化できます。</target>
        </trans-unit>
        <trans-unit id="48f87256a37f996b34f071b6b4ef5f1805966dbd" translate="yes" xml:space="preserve">
          <source>Historically, this was not considered a threat. The argument was that if a hostile agent is able to inject arbitrary SQL text into the application, then that agent is already in full control of the application, so letting the hostile agent forge a pointer does not give the agent any new capability.</source>
          <target state="translated">歴史的に、これは脅威とは考えられていませんでした。議論は、もし敵対的なエージェントがアプリケーションに任意のSQLテキストを注入することができるならば、そのエージェントはすでにアプリケーションを完全に制御しているので、敵対的なエージェントにポインタを偽造させることは、エージェントに新しい能力を与えないというものでした。</target>
        </trans-unit>
        <trans-unit id="bfbddd574d4f950742d8e5d7a49607c23d347f95" translate="yes" xml:space="preserve">
          <source>Honor all.</source>
          <target state="translated">敬意を表します。</target>
        </trans-unit>
        <trans-unit id="645a5172c51f2105b78cb24101222af4c2581b31" translate="yes" xml:space="preserve">
          <source>Honor the &lt;a href=&quot;c3ref/c_deserialize_freeonclose&quot;&gt;SQLITE_DESERIALIZE_READONLY&lt;/a&gt; flag, which was previously described in the documentation, but was previously a no-op.</source>
          <target state="translated">以前はドキュメントで説明されていましたが、以前は何もしていなかった&lt;a href=&quot;c3ref/c_deserialize_freeonclose&quot;&gt;SQLITE_DESERIALIZE_READONLY&lt;/a&gt;フラグを尊重してください。</target>
        </trans-unit>
        <trans-unit id="2fff26aa56e0db9e63e42ae6a74896b210340408" translate="yes" xml:space="preserve">
          <source>Honor the ORDER BY and LIMIT clause of a SELECT even if the result set is used for an INSERT.</source>
          <target state="translated">結果セットがINSERTに使用されている場合でも、SELECTのORDER BY句とLIMIT句を尊重します。</target>
        </trans-unit>
        <trans-unit id="972205ef02943c809b85189066f29ea5a922b1d8" translate="yes" xml:space="preserve">
          <source>Host parameter names can begin with '@' for compatibility with SQL Server.</source>
          <target state="translated">ホストのパラメータ名は、SQL Serverとの互換性のために'@'で始めることができます。</target>
        </trans-unit>
        <trans-unit id="2107ab6c47208816e9f85a68b6f666b821dd323b" translate="yes" xml:space="preserve">
          <source>Hot Journal Detection</source>
          <target state="translated">ホットジャーナル検出</target>
        </trans-unit>
        <trans-unit id="387adc1437f284bb8f7d821272256c3791f7c532" translate="yes" xml:space="preserve">
          <source>Hot Journal Rollback</source>
          <target state="translated">ホットジャーナルのロールバック</target>
        </trans-unit>
        <trans-unit id="51a2396551270d6b1b9b0daa06c843f02294bf7a" translate="yes" xml:space="preserve">
          <source>Hot journal files</source>
          <target state="translated">ホットジャーナルファイル</target>
        </trans-unit>
        <trans-unit id="33f85488d44d0b31b265f227edf83b283232673c" translate="yes" xml:space="preserve">
          <source>Hot journal rollback</source>
          <target state="translated">ホットジャーナルのロールバック</target>
        </trans-unit>
        <trans-unit id="72b9d3b59a2cd3c6b5726c2ec8f20f5cbd8fc2c8" translate="yes" xml:space="preserve">
          <source>How &lt;a href=&quot;queryplanner&quot;&gt;indexing&lt;/a&gt; works.</source>
          <target state="translated">どのように&lt;a href=&quot;queryplanner&quot;&gt;インデックス&lt;/a&gt;作品。</target>
        </trans-unit>
        <trans-unit id="de544e283cfebc5d70d3d7b590e023e13a9bf879" translate="yes" xml:space="preserve">
          <source>How Memory-Mapped I/O Works</source>
          <target state="translated">メモリマップドI/Oの仕組み</target>
        </trans-unit>
        <trans-unit id="56b803311ab7e3e616ef538b11ad7fad3dcd0741" translate="yes" xml:space="preserve">
          <source>How SQLite Is Tested</source>
          <target state="translated">SQLite のテスト方法</target>
        </trans-unit>
        <trans-unit id="f0b874a1265664f2f8c8240dcb0a141334e57668" translate="yes" xml:space="preserve">
          <source>How To Compile SQLite</source>
          <target state="translated">SQLiteをコンパイルする方法</target>
        </trans-unit>
        <trans-unit id="bac0366a300ac4acaffdcf4c3d4ee83a4619271d" translate="yes" xml:space="preserve">
          <source>How To Corrupt</source>
          <target state="translated">堕落させる方法</target>
        </trans-unit>
        <trans-unit id="07961a03bdae1448ec20af2c6389f109c109cecd" translate="yes" xml:space="preserve">
          <source>How To Corrupt An SQLite Database File</source>
          <target state="translated">SQLiteデータベースファイルを破損させる方法</target>
        </trans-unit>
        <trans-unit id="ac75035a65466ee12d9ad12dabe0ea72bf4078bd" translate="yes" xml:space="preserve">
          <source>How To Corrupt Your Database Files</source>
          <target state="translated">データベースファイルを破損させる方法</target>
        </trans-unit>
        <trans-unit id="6c4dc04d73e3b62534455f3b1b128df4687ca99e" translate="yes" xml:space="preserve">
          <source>How To Download Canonical SQLite Source Code</source>
          <target state="translated">Canonical SQLiteのソースコードをダウンロードする方法</target>
        </trans-unit>
        <trans-unit id="023a32566bba30a34815129fd5e3cc90c1e899ca" translate="yes" xml:space="preserve">
          <source>How VACUUM works</source>
          <target state="translated">バキュームの仕組み</target>
        </trans-unit>
        <trans-unit id="996ef93cbabdf3a445d79226e8fa6d9c24a881f0" translate="yes" xml:space="preserve">
          <source>How are the syntax diagrams (a.k.a. &quot;railroad&quot; diagrams) for SQLite generated?</source>
          <target state="translated">SQLite の構文図(別名「鉄道」図)はどのように生成されていますか?</target>
        </trans-unit>
        <trans-unit id="fc0899650d804dfcac8dc2104606bf9268efcf1e" translate="yes" xml:space="preserve">
          <source>How collation is determined</source>
          <target state="translated">照合の決め方</target>
        </trans-unit>
        <trans-unit id="9a3218133ebd28240c94b4e7364a4f7e2e221ee5" translate="yes" xml:space="preserve">
          <source>How do I add or delete columns from an existing table in SQLite.</source>
          <target state="translated">SQLiteで既存のテーブルからカラムを追加または削除するにはどうすればよいですか?</target>
        </trans-unit>
        <trans-unit id="30aeec19cd6396142e3416e018900e8041d11cdb" translate="yes" xml:space="preserve">
          <source>How do I create an AUTOINCREMENT field?</source>
          <target state="translated">オートインクリメントフィールドを作成するには?</target>
        </trans-unit>
        <trans-unit id="a6cedc80b4e8057201d930bd24da72e7284f5f18" translate="yes" xml:space="preserve">
          <source>How do I list all tables/indices contained in an SQLite database</source>
          <target state="translated">SQLite データベースに含まれるすべてのテーブル/インデックスをリストアップする方法</target>
        </trans-unit>
        <trans-unit id="94a002c7d3ab3f319a7a958c2ffad735eae889c1" translate="yes" xml:space="preserve">
          <source>How do I use a string literal that contains an embedded single-quote (') character?</source>
          <target state="translated">シングルクォート(')文字が埋め込まれた文字列リテラルを使用するには?</target>
        </trans-unit>
        <trans-unit id="df2742c7cfd9e0aab79b47f5b91d0027a0daa0fc" translate="yes" xml:space="preserve">
          <source>How many executable files are in the archive?</source>
          <target state="translated">アーカイブにはいくつの実行ファイルがありますか?</target>
        </trans-unit>
        <trans-unit id="463cdf2e00bc03ffb0a58ce75a36b28173bad1d1" translate="yes" xml:space="preserve">
          <source>How vacuum works</source>
          <target state="translated">真空の仕組み</target>
        </trans-unit>
        <trans-unit id="c2ebee163b547a5e69c6b8f18b3ce7ade428f296" translate="yes" xml:space="preserve">
          <source>However, client/server database engines (such as PostgreSQL, MySQL, or Oracle) usually support a higher level of concurrency and allow multiple processes to be writing to the same database at the same time. This is possible in a client/server database because there is always a single well-controlled server process available to coordinate access. If your application has a need for a lot of concurrency, then you should consider using a client/server database. But experience suggests that most applications need much less concurrency than their designers imagine.</source>
          <target state="translated">しかし、クライアント/サーバデータベースエンジン(PostgreSQL、MySQL、Oracleなど)は通常、より高いレベルの同時実行性をサポートしており、複数のプロセスが同時に同じデータベースに書き込むことを可能にしています。クライアント/サーバデータベースでは、アクセスを調整するために利用可能な単一のよく制御されたサーバプロセスが常に存在するため、これが可能になります。もしアプリケーションが大量の同時実行を必要とする場合は、クライアント/サーバーデータベースの使用を検討すべきです。しかし、経験上、ほとんどのアプリケーションでは、設計者が想像しているよりもはるかに少ない同時実行性しか必要としないことがわかっています。</target>
        </trans-unit>
        <trans-unit id="a6ddbe53650906819e58dd27910958633c3e2cfa" translate="yes" xml:space="preserve">
          <source>However, for a &quot;contained-within&quot; style query, rounding the bounding boxes outward might cause some entries to be excluded from the result set if the edge of the entry bounding box corresponds to the edge of the query bounding box. To guard against this, applications should expand their contained-within query boxes slightly (by 0.000012%) by rounding down the lower coordinates and rounding up the top coordinates, in each dimension.</source>
          <target state="translated">しかし、&quot;included-within &quot;スタイルのクエリでは、エントリのバウンディングボックスの端がクエリのバウンディングボックスの端と一致する場合、バウンディングボックスを外側に丸めてしまうと、いくつかのエントリが結果集合から除外されてしまう可能性があります。これを防ぐために、アプリケーションは、各次元において、下側の座標を丸め、上側の座標を丸めて、包含された内部クエリボックスをわずかに(0.000012%)拡張しなければなりません。</target>
        </trans-unit>
        <trans-unit id="036059da8b4b48b5c802bde550324a35ba2a35da" translate="yes" xml:space="preserve">
          <source>However, highly tuned and specialized applications may want or need to replace some of SQLite's built-in system interfaces with alternative implementations more suitable for the needs of the application. SQLite is designed to be easily reconfigured at compile-time to meet the specific needs of individual projects. Among the compile-time configuration options for SQLite are these:</source>
          <target state="translated">しかし、高度に調整された特殊なアプリケーションでは、SQLite の組み込みシステムインターフェースの一部を、アプリケーションのニーズに適した代替の実装に置き換える必要があるかもしれません。SQLite は、個々のプロジェクトの特定のニーズを満たすために、コンパイル時に簡単に再設定できるように設計されています。SQLite のコンパイル時の設定オプションには、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="9070a26476fc8018912ec09ceeee6b8f4a55c4f3" translate="yes" xml:space="preserve">
          <source>However, if a</source>
          <target state="translated">しかし、もし</target>
        </trans-unit>
        <trans-unit id="96aad563dbeff373bd60c0d93a4ac2c049bba808" translate="yes" xml:space="preserve">
          <source>However, if a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation creates real tables (sometimes referred to as &quot;shadow&quot; tables) within the database to store its data in, then sqldiff.exe does calculate the difference between these. This can have surprising effects if the resulting SQL script is then run on a database that is not</source>
          <target state="translated">ただし、&lt;a href=&quot;vtab&quot;&gt;仮想テーブルの&lt;/a&gt;実装がデータベース内に実際のテーブル（「シャドウ」テーブルと呼ばれることもあります）を作成してデータを格納する場合、sqldiff.exeはこれらの差を計算します。結果のSQLスクリプトが次に実行されていないデータベースで実行された場合、これは驚くべき効果をもたらす可能性があります。</target>
        </trans-unit>
        <trans-unit id="90ac212208b638040cc57dde761531e1857cf547" translate="yes" xml:space="preserve">
          <source>However, if a database has many concurrent overlapping readers and there is always at least one active reader, then no checkpoints will be able to complete and hence the WAL file will grow without bound.</source>
          <target state="translated">しかし、データベースが多数の同時重複リーダを持ち、常に少なくとも1つのアクティブなリーダが存在する場合、チェックポイントを完了することができず、その結果、WALファイルは無制限に成長してしまいます。</target>
        </trans-unit>
        <trans-unit id="908b33a654e5b5eaa50e924611f16debc0d52007" translate="yes" xml:space="preserve">
          <source>However, if in-memory database pInMemory has just been opened (and is therefore completely empty) before being passed to function loadOrSaveDb(), then it is still possible to change its page size using an SQLite &quot;PRAGMA page_size&quot; command. Function loadOrSaveDb() could detect this case, and attempt to set the page-size of the in-memory database to the page-size of database zFilename before invoking the online backup API functions.</source>
          <target state="translated">しかし、インメモリ・データベース pInMemory が関数 loadOrSaveDb()に渡される前にオープンされたばかりの(したがって完全に空の)場合、SQLite の &quot;PRAGMA page_size&quot; コマンドを使用してそのページ・サイズを変更することが可能です。関数 loadOrSaveDb()はこのケースを検出し、オンライン・バックアップ API 関数を呼び出す前に、インメモリ・データベースのページ・サイズをデータベース zFilename のページ・サイズに設定しようとすることができます。</target>
        </trans-unit>
        <trans-unit id="9282d84ef089a46651581dc23d9984a0b853a197" translate="yes" xml:space="preserve">
          <source>However, the application must guarantee that the destination &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is not passed to any other API (by any thread) after sqlite3_backup_init() is called and before the corresponding call to sqlite3_backup_finish(). SQLite does not currently check to see if the application incorrectly accesses the destination &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; and so no error code is reported, but the operations may malfunction nevertheless. Use of the destination database connection while a backup is in progress might also also cause a mutex deadlock.</source>
          <target state="translated">ただし、アプリケーションは、sqlite3_backup_init（）が呼び出された後、対応するsqlite3_backup_finish（）が呼び出される前に、宛先&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt;が他のAPIに（スレッドによって）渡されないことを保証する必要があります。 SQLiteは現在、アプリケーションが宛先&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続に&lt;/a&gt;誤ってアクセスしているかどうかを確認しないため、エラーコードは報告されませんが、それでも操作が誤動作する可能性があります。バックアップの進行中に宛先データベース接続を使用すると、ミューテックスデッドロックも発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="6bd67d83c5ac9c5a6146085621d60822aa5f256c" translate="yes" xml:space="preserve">
          <source>However, the application must guarantee that the destination &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is not passed to any other API (by any thread) after sqlite3_backup_init() is called and before the corresponding call to sqlite3_backup_finish(). SQLite does not currently check to see if the application incorrectly accesses the destination &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; and so no error code is reported, but the operations may malfunction nevertheless. Use of the destination database connection while a backup is in progress might also also cause a mutex deadlock.</source>
          <target state="translated">ただし、アプリケーションは、sqlite3_backup_init（）が呼び出された後、対応するsqlite3_backup_finish（）が呼び出される前に、宛先&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt;が他のAPIに（スレッドによって）渡されないことを保証する必要があります。SQLiteは現在、アプリケーションが宛先&lt;a href=&quot;sqlite3&quot;&gt;データベース接続に&lt;/a&gt;誤ってアクセスしているかどうかを確認しないため、エラーコードは報告されませんが、それでも操作が誤動作する可能性があります。バックアップの進行中に宛先データベース接続を使用すると、ミューテックスデッドロックも発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="2051ec90af96c4dbbb12c8a2bb3921b04fb0a7f2" translate="yes" xml:space="preserve">
          <source>However, the b-tree for a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table is in the same format as an index b-tree. Thus, an index b-tree can be accessed as if it were a WITHOUT ROWID table.</source>
          <target state="translated">ただし、&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルのbツリーは、インデックスbツリーと同じ形式です。したがって、WITHOUT ROWIDテーブルであるかのように、インデックスBツリーにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="bdab598cbadf7cd7b2bb8bc0bda2ecbe3c4ceb3a" translate="yes" xml:space="preserve">
          <source>Hundreds of virtual tables that publish various aspects of the host computer, such as the process table, user lists, active network connections, and so forth. OsQuery is a separate project, started by Facebook, hosted on &lt;a href=&quot;https://github.com/facebook/osquery&quot;&gt;GitHub&lt;/a&gt;, and intended for security analysis and intrusion detection OsQuery is not a part of the SQLite project, but is included in this list because it demonstrates how the SQL language and the SQLite virtual table mechanism can be leveraged to provide elegant solutions to important real-world problems.</source>
          <target state="translated">プロセステーブル、ユーザーリスト、アクティブなネットワーク接続など、ホストコンピューターのさまざまな側面を公開する数百の仮想テーブル。 OsQueryは、Facebookによって開始さ&lt;a href=&quot;https://github.com/facebook/osquery&quot;&gt;れ&lt;/a&gt;、GitHubでホストされ、セキュリティ分析と侵入検知を目的とした独立したプロジェクトです。OsQueryはSQLiteプロジェクトの一部ではありませんが、SQL言語とSQLite仮想テーブルの方法を示すため、このリストに含まれていますメカニズムを活用して、現実世界の重要な問題に対するエレガントなソリューションを提供できます。</target>
        </trans-unit>
        <trans-unit id="6d245e7140689124e74b20cb072465076d95b006" translate="yes" xml:space="preserve">
          <source>I accidentally deleted some important information from my SQLite database. How can I recover it?</source>
          <target state="translated">誤ってSQLiteデータベースから重要な情報を削除してしまいました。どのようにそれを回復することができますか?</target>
        </trans-unit>
        <trans-unit id="dc9c3207dff5659b4c310cd90f15260ed36f68c7" translate="yes" xml:space="preserve">
          <source>I am told that Git users commonly install third-party graphical viewers for Git, many of which do a better job of showing recent activity on the project. That is great, but these are still more third-party applications that must be installed and managed separately. Many are platform-specific. (One of the better ones, &lt;a href=&quot;https://gitup.co/&quot;&gt;GitUp&lt;/a&gt;, only works on Mac, for example.) All require that you first sync your local repository then bring up their graphical interface on your desktop. And even with all that, I still cannot see what I typically want to see without multiple clicks. Checking on project status from a phone while away from the office is not an option.</source>
          <target state="translated">Gitユーザーは通常、Gitのサードパーティのグラフィカルビューアをインストールすると言われています。Gitの多くは、プロジェクトの最近のアクティビティをより適切に表示します。それはすばらしいことですが、これらはさらにインストールして個別に管理する必要があるサードパーティのアプリケーションです。多くはプラットフォーム固有です。 （&lt;a href=&quot;https://gitup.co/&quot;&gt;GitUp&lt;/a&gt;などの優れた機能の1つは、たとえばMacでのみ機能します。）まず、ローカルリポジトリを同期してから、デスクトップにグラフィカルインターフェースを表示する必要があります。それでも、何回もクリックしないと、通常見たいものを見ることができません。オフィスから離れているときに電話でプロジェクトのステータスを確認することはできません。</target>
        </trans-unit>
        <trans-unit id="a5d8bfaba744d8865014e1b5776daef69b8ba64a" translate="yes" xml:space="preserve">
          <source>I am told that the default PostgreSQL configuration in RedHat 7.3 is unnecessarily conservative (it is designed to work on a machine with 8MB of RAM) and that PostgreSQL could be made to run a lot faster with some knowledgeable configuration tuning. Matt Sergeant reports that he has tuned his PostgreSQL installation and rerun the tests shown below. His results show that PostgreSQL and MySQL run at about the same speed. For Matt's results, visit</source>
          <target state="translated">私は、RedHat 7.3のデフォルトのPostgreSQLの設定が不必要に保守的であり(8MBのRAMを持つマシンで動作するように設計されています)、PostgreSQLは知識のある設定チューニングを行うことで、より高速に動作させることができると聞いています。Matt Sergeantは、PostgreSQLのインストールをチューニングし、以下に示すテストを再実行したことを報告しています。彼の結果は、PostgreSQLとMySQLがほぼ同じ速度で動作することを示しています。Mattの結果については、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="c4b4aed72c495e6b69cc90a12c1002093ba09a73" translate="yes" xml:space="preserve">
          <source>I deleted a lot of data but the database file did not get any smaller. Is this a bug?</source>
          <target state="translated">たくさんのデータを削除しましたが、データベースファイルが小さくなりませんでした。これはバグなのでしょうか?</target>
        </trans-unit>
        <trans-unit id="30c131b4d60b85b44b7c7e76894246c9eeed47f8" translate="yes" xml:space="preserve">
          <source>I get a compiler error if I use the SQLITE_OMIT_... compile-time options when building SQLite.</source>
          <target state="translated">SQLiteを構築する際にSQLITE_OMIT_...コンパイル時オプションを使用すると、コンパイラエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="96380689d1c266e443557fac220e162eb248fe7f" translate="yes" xml:space="preserve">
          <source>I get some compiler warnings when I compile SQLite. Isn't this a problem? Doesn't it indicate poor code quality?</source>
          <target state="translated">SQLiteをコンパイルするとコンパイラの警告が出ます。これは問題ではないのでしょうか?コードの品質が悪いことを示しているのではないでしょうか?</target>
        </trans-unit>
        <trans-unit id="b0631d514fcfd330a2105540a0b813b7c7b65c3f" translate="yes" xml:space="preserve">
          <source>I/O error testing is similar in concept to OOM testing; I/O errors are simulated and checks are made to verify that SQLite responds correctly to the simulated errors. I/O errors are simulated in both the TCL and TH3 test harnesses by inserting a new &lt;a href=&quot;c3ref/vfs&quot;&gt;Virtual File System object&lt;/a&gt; that is specially rigged to simulate an I/O error after a set number of I/O operations. As with OOM error testing, the I/O error simulators can be set to fail just once, or to fail continuously after the first failure. Tests are run in a loop, slowly increasing the point of failure until the test case runs to completion without error. The loop is run twice, once with the I/O error simulator set to simulate only a single failure and a second time with it set to fail all I/O operations after the first failure.</source>
          <target state="translated">I / Oエラーテストの概念はOOMテストと似ています。 I / Oエラーがシミュレートされ、SQLiteがシミュレートされたエラーに正しく応答することを確認するためのチェックが行われます。 I / Oエラーは、TCLとTH3の両方のテストハーネスでシミュレートされ&lt;a href=&quot;c3ref/vfs&quot;&gt;ます。&lt;/a&gt;新しい仮想ファイルシステムオブジェクトを挿入すると、設定された数のI / O操作後にI / Oエラーをシミュレートします。 OOMエラーテストと同様に、I / Oエラーシミュレータは、1回だけ失敗するように設定することも、最初の失敗後に継続的に失敗するように設定することもできます。テストはループで実行され、テストケースがエラーなしで完了まで実行されるまで、障害点が徐々に増加します。ループは2回実行されます。1回目は、単一の障害のみをシミュレートするようにI / Oエラーシミュレータを設定し、2回目は、最初の障害後にすべてのI / O操作を失敗させるように設定します。</target>
        </trans-unit>
        <trans-unit id="7e39c1a666c2fd143f11a87457de9e9888317484" translate="yes" xml:space="preserve">
          <source>I/O error testing seeks to verify that SQLite responds sanely to failed I/O operations. I/O errors might result from a full disk drive, malfunctioning disk hardware, network outages when using a network file system, system configuration or permission changes that occur in the middle of an SQL operation, or other hardware or operating system malfunctions. Whatever the cause, it is important that SQLite be able to respond correctly to these errors and I/O error testing seeks to verify that it does.</source>
          <target state="translated">I/Oエラーのテストでは、失敗したI/O操作に対してSQLiteが正常に応答しているかどうかを確認します。I/Oエラーは、ディスクドライブが一杯になった、ディスクハードウェアの故障、ネットワークファイルシステムを使用しているときのネットワークの停止、SQL操作の途中で発生したシステム構成や権限の変更、その他のハードウェアやオペレーティングシステムの故障などが原因で発生する可能性があります。原因が何であれ、SQLiteがこれらのエラーに正しく応答できることが重要であり、I/Oエラーテストではそれを確認することを目的としています。</target>
        </trans-unit>
        <trans-unit id="8d8651647c9490ad914b1a9a6e6d44929ce46c04" translate="yes" xml:space="preserve">
          <source>I/O error tests</source>
          <target state="translated">入出力エラーテスト</target>
        </trans-unit>
        <trans-unit id="35d92e9f60aece05bafa666d5e6093c27b070d38" translate="yes" xml:space="preserve">
          <source>I/O errors in the OS-interface generate error logging events. The message to these events gives the line number in the source code where the error originated and the filename associated with the event when there is a corresponding file.</source>
          <target state="translated">OS インターフェースの I/O エラーは、エラー・ロギング・イベントを生成します。これらのイベントへのメッセージは、エラーが発生したソースコードの行番号と、対応するファイルがある場合はイベントに関連付けられたファイル名を示します。</target>
        </trans-unit>
        <trans-unit id="d998ed8c49ae368254ded62fce1c76a6c0d44f30" translate="yes" xml:space="preserve">
          <source>I/O performance is measured using the &lt;a href=&quot;https://www.sqlite.org/src/file/test/kvtest.c&quot;&gt;kvtest.c&lt;/a&gt; program from the SQLite source tree. To compile this test program, first gather the kvtest.c source file into a directory with the &lt;a href=&quot;amalgamation&quot;&gt;SQLite amalgamation&lt;/a&gt; source files &quot;sqlite3.c&quot; and &quot;sqlite3.h&quot;. Then on unix, run a command like the following:</source>
          <target state="translated">I / Oパフォーマンスは、SQLiteソースツリーの&lt;a href=&quot;https://www.sqlite.org/src/file/test/kvtest.c&quot;&gt;kvtest.c&lt;/a&gt;プログラムを使用して測定されます。このテストプログラムをコンパイルするには、最初にkvtest.cソースファイルを&lt;a href=&quot;amalgamation&quot;&gt;SQLite融合&lt;/a&gt;ソースファイル「sqlite3.c」と「sqlite3.h」のあるディレクトリに収集します。次に、UNIXで次のようなコマンドを実行します。</target>
        </trans-unit>
        <trans-unit id="e779dca751c9ced361a0eadbe7916be59d02dc09" translate="yes" xml:space="preserve">
          <source>I/O performance varies widely depending on operating system and hardware. Make your own measurements before drawing conclusions.</source>
          <target state="translated">I/O性能は、オペレーティングシステムとハードウェアによって大きく異なります。結論を出す前に、独自の測定を行ってください。</target>
        </trans-unit>
        <trans-unit id="267e452e4d048aacef682e30a9d368c22e7501e4" translate="yes" xml:space="preserve">
          <source>IDF(q&lt;sub&gt;i&lt;/sub&gt;)</source>
          <target state="translated">IDF(q&lt;sub&gt;i&lt;/sub&gt;)</target>
        </trans-unit>
        <trans-unit id="7be63e2881f7da8faa393bfe0ce4667f10916b66" translate="yes" xml:space="preserve">
          <source>IF</source>
          <target state="translated">IF</target>
        </trans-unit>
        <trans-unit id="235cae5b9c97fbc3364fb92af44d64b71392dbb2" translate="yes" xml:space="preserve">
          <source>IF EXISTS and IF NOT EXISTS clauses on CREATE/DROP TABLE/INDEX.</source>
          <target state="translated">CREATE/DROP TABLE/INDEXのIF EXISTS句とIF NOT EXISTS句。</target>
        </trans-unit>
        <trans-unit id="c9226f99dd645a71848cf0585c15059d7de868f4" translate="yes" xml:space="preserve">
          <source>IGNORE</source>
          <target state="translated">IGNORE</target>
        </trans-unit>
        <trans-unit id="8ae3e8381a64e36db57a5344790db89d7de90954" translate="yes" xml:space="preserve">
          <source>IMMEDIATE</source>
          <target state="translated">IMMEDIATE</target>
        </trans-unit>
        <trans-unit id="3b63a4da1415c242da17f132d0e00d086153fa66" translate="yes" xml:space="preserve">
          <source>IMMEDIATE cause the database connection to start a new write immediately, without waiting for a write statement. The BEGIN IMMEDIATE might fail with &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if another write transaction is already active on another database connection.</source>
          <target state="translated">IMMEDIATE cause the database connection to start a new write immediately, without waiting for a write statement. The BEGIN IMMEDIATE might fail with &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if another write transaction is already active on another database connection.</target>
        </trans-unit>
        <trans-unit id="1f94ea3de1605903ae5123660f5457eb8bd32e9f" translate="yes" xml:space="preserve">
          <source>IMMEDIATE cause the database connection to start a new write immediately, without waiting for a writes statement. The BEGIN IMMEDIATE might fail with &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if another write transaction is already active on another database connection.</source>
          <target state="translated">IMMEDIATEを指定すると、データベース接続は、書き込みステートメントを待たずに、新しい書き込みをすぐに開始します。別のデータベース接続で別の書き込みトランザクションがすでにアクティブになっている場合、BEGIN IMMEDIATEは&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSYで&lt;/a&gt;失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="a4db76ad8831e1ebbbc52031b1ae484c99975878" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The estimatedRows field was added to the sqlite3_index_info structure for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06). If a virtual table extension is used with an SQLite version earlier than 3.8.2, the results of attempting to read or write the estimatedRows field are undefined (but are likely to include crashing the application). The estimatedRows field should therefore only be used if &lt;a href=&quot;#sqlite3_libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; returns a value greater than or equal to 3008002. Similarly, the idxFlags field was added for &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). It may therefore only be used if sqlite3_libversion_number() returns a value greater than or equal to 3009000.</source>
          <target state="translated">IMPORTANT: The estimatedRows field was added to the sqlite3_index_info structure for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06). If a virtual table extension is used with an SQLite version earlier than 3.8.2, the results of attempting to read or write the estimatedRows field are undefined (but are likely to include crashing the application). The estimatedRows field should therefore only be used if &lt;a href=&quot;#sqlite3_libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; returns a value greater than or equal to 3008002. Similarly, the idxFlags field was added for &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). It may therefore only be used if sqlite3_libversion_number() returns a value greater than or equal to 3009000.</target>
        </trans-unit>
        <trans-unit id="0f10a7701656ba82f20f9690db33f263b9944c35" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The estimatedRows field was added to the sqlite3_index_info structure for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06). If a virtual table extension is used with an SQLite version earlier than 3.8.2, the results of attempting to read or write the estimatedRows field are undefined (but are likely to include crashing the application). The estimatedRows field should therefore only be used if &lt;a href=&quot;libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; returns a value greater than or equal to 3008002. Similarly, the idxFlags field was added for &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). It may therefore only be used if sqlite3_libversion_number() returns a value greater than or equal to 3009000.</source>
          <target state="translated">IMPORTANT: The estimatedRows field was added to the sqlite3_index_info structure for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06). If a virtual table extension is used with an SQLite version earlier than 3.8.2, the results of attempting to read or write the estimatedRows field are undefined (but are likely to include crashing the application). The estimatedRows field should therefore only be used if &lt;a href=&quot;libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; returns a value greater than or equal to 3008002. Similarly, the idxFlags field was added for &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). It may therefore only be used if sqlite3_libversion_number() returns a value greater than or equal to 3009000.</target>
        </trans-unit>
        <trans-unit id="ac8fb933cd53d38ff3f25855409c3725df641570" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The estimatedRows field was added to the sqlite3_index_info structure for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06). If a virtual table extension is used with an SQLite version earlier than 3.8.2, the results of attempting to read or write the estimatedRows field are undefined (but are likely to included crashing the application). The estimatedRows field should therefore only be used if &lt;a href=&quot;#sqlite3_libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; returns a value greater than or equal to 3008002. Similarly, the idxFlags field was added for &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). It may therefore only be used if sqlite3_libversion_number() returns a value greater than or equal to 3009000.</source>
          <target state="translated">重要：見積り行フィールドは、SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;バージョン3.8.2&lt;/a&gt;（2013-12-06）のsqlite3_index_info構造に追加されました。仮想テーブル拡張が3.8.2より前のバージョンのSQLiteで使用されている場合、stimulatedRowsフィールドの読み取りまたは書き込みを試みた結果は未定義です（ただし、アプリケーションのクラッシュが含まれる可能性があります）。したがって、stimulatedRowsフィールドは、&lt;a href=&quot;#sqlite3_libversion&quot;&gt;sqlite3_libversion_number（）&lt;/a&gt;が3008002以上の値を返す場合にのみ使用する必要があります。同様に、idxFlagsフィールドは&lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;バージョン3.9.0&lt;/a&gt;（2015-10-14）で追加されました。したがって、sqlite3_libversion_number（）が3009000以上の値を返す場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="f7788b148a07ca2844906ea43293afae622f959f" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The estimatedRows field was added to the sqlite3_index_info structure for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06). If a virtual table extension is used with an SQLite version earlier than 3.8.2, the results of attempting to read or write the estimatedRows field are undefined (but are likely to included crashing the application). The estimatedRows field should therefore only be used if &lt;a href=&quot;libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; returns a value greater than or equal to 3008002. Similarly, the idxFlags field was added for &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). It may therefore only be used if sqlite3_libversion_number() returns a value greater than or equal to 3009000.</source>
          <target state="translated">重要：見積り行フィールドは、SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;バージョン3.8.2&lt;/a&gt;（2013-12-06）のsqlite3_index_info構造に追加されました。仮想テーブル拡張が3.8.2より前のバージョンのSQLiteで使用されている場合、stimulatedRowsフィールドの読み取りまたは書き込みを試みた結果は未定義です（ただし、アプリケーションのクラッシュが含まれる可能性があります）。したがって、stimulatedRowsフィールドは、&lt;a href=&quot;libversion&quot;&gt;sqlite3_libversion_number（）&lt;/a&gt;が3008002以上の値を返す場合にのみ使用する必要があります。同様に、idxFlagsフィールドは&lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;バージョン3.9.0&lt;/a&gt;（2015-10-14）で追加されました。したがって、sqlite3_libversion_number（）が3009000以上の値を返す場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="6fca55ca3c828a46bfe96a10e69f572b61ce540c" translate="yes" xml:space="preserve">
          <source>IN</source>
          <target state="translated">IN</target>
        </trans-unit>
        <trans-unit id="9e93d8e547641024337c9f88c37aeeb56b09cfd4" translate="yes" xml:space="preserve">
          <source>IN operator</source>
          <target state="translated">インオペレータ</target>
        </trans-unit>
        <trans-unit id="2704c1d8c3fc215c38ee176f6cc30e434a22b7d7" translate="yes" xml:space="preserve">
          <source>INDEX</source>
          <target state="translated">INDEX</target>
        </trans-unit>
        <trans-unit id="d34941b7cef935d2b4b0705a24e87fad9ef16cef" translate="yes" xml:space="preserve">
          <source>INDEXED</source>
          <target state="translated">INDEXED</target>
        </trans-unit>
        <trans-unit id="0a477a77f065212096e980b210eda0227cabf37c" translate="yes" xml:space="preserve">
          <source>INDEXED BY</source>
          <target state="translated">インデックス化された</target>
        </trans-unit>
        <trans-unit id="fd4d2f0d5aa850e30c0830c19e27d0fa4c65c7a7" translate="yes" xml:space="preserve">
          <source>INITIALLY</source>
          <target state="translated">INITIALLY</target>
        </trans-unit>
        <trans-unit id="88d86d54436967d4b4599d22d53c2a3db38390e6" translate="yes" xml:space="preserve">
          <source>INNER</source>
          <target state="translated">INNER</target>
        </trans-unit>
        <trans-unit id="c20ea07e32d25c072a65368c234d6f5a88f4521a" translate="yes" xml:space="preserve">
          <source>INSERT</source>
          <target state="translated">INSERT</target>
        </trans-unit>
        <trans-unit id="06c4e866c3ade62ba74b04b1ef54dce90603c067" translate="yes" xml:space="preserve">
          <source>INSERT Changes</source>
          <target state="translated">INSERT変更</target>
        </trans-unit>
        <trans-unit id="4e7c6a59e9c103dd735d95fe84726b20fe104acf" translate="yes" xml:space="preserve">
          <source>INSERT INTO demo2(command) VALUES(&quot;reset&quot;);</source>
          <target state="translated">INSERT INTO demo2(command)VALUES(&quot;reset&quot;)。</target>
        </trans-unit>
        <trans-unit id="ed9844477a7bb01e976b863376804eb769331989" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 SELECT b,a,c FROM t2;</source>
          <target state="translated">INSERT INTO t1 SELECT b,a,c FROM t2.</target>
        </trans-unit>
        <trans-unit id="767dcfed1e7a66d267a3220fbe439232373351ee" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(1,10719,'ten thousand seven hundred nineteen');</source>
          <target state="translated">INSERT INTO t1 VALUES(1,10719,'10,000,700,19').</target>
        </trans-unit>
        <trans-unit id="a30ee5b0b970fc276bf5d3453cfa994508fd0177" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(1,13153,'thirteen thousand one hundred fifty three');</source>
          <target state="translated">INSERT INTO t1 VALUES(1,13153,'13,000,1503').</target>
        </trans-unit>
        <trans-unit id="4bc6de27aceadc240c8dd43059a82f9a9561379b" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(1000,94142,'ninety four thousand one hundred forty two');</source>
          <target state="translated">INSERT INTO t1 VALUES(1000,94142,'ninetty four thousand one hundred forty two').</target>
        </trans-unit>
        <trans-unit id="62d9636f68aa675dabacb22b938d9f2be06b55e0" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(11999,72836,'seventy two thousand eight hundred thirty six');</source>
          <target state="translated">INSERT INTO t1 VALUES(11999,72836,'772,000 8,300,316').</target>
        </trans-unit>
        <trans-unit id="f0fbe2df8c33450eafb90fd96d71291641e02aa4" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(12000,64231,'sixty four thousand two hundred thirty one');</source>
          <target state="translated">INSERT INTO t1 VALUES(12000,64231,'s sixty four thousand two hundred thirty one').</target>
        </trans-unit>
        <trans-unit id="31a76630ad88d2e05dde2c415d8576db8ec6caf9" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(2,75560,'seventy five thousand five hundred sixty');</source>
          <target state="translated">INSERT INTO t1 VALUES(2,75560,'70万5,000 5,600').</target>
        </trans-unit>
        <trans-unit id="215d5732ce27fd223582c712aaa4660a83a173d4" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(998,66289,'sixty six thousand two hundred eighty nine');</source>
          <target state="translated">INSERT INTO t1 VALUES(998,66289,'sixty six six thousand two hundred8y nine')。</target>
        </trans-unit>
        <trans-unit id="4b533e1d2a14d2013c249801c64abee1873ad0e7" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(999,24322,'twenty four thousand three hundred twenty two');</source>
          <target state="translated">INSERT INTO t1 VALUES(999,24322,'twenty four thousand three hundred twenty two').</target>
        </trans-unit>
        <trans-unit id="c97d31d96ba9608129ccb018853e9ea9cb6076d1" translate="yes" xml:space="preserve">
          <source>INSERT INTO t2 SELECT * FROM t1;</source>
          <target state="translated">INSERT INTO t2 SELECT*FROM t1.</target>
        </trans-unit>
        <trans-unit id="18573be7d634b7266c9f3fabe6799c0e9de399b2" translate="yes" xml:space="preserve">
          <source>INSERT INTO t2 SELECT b,a,c FROM t1;</source>
          <target state="translated">INSERT INTO t2 SELECT b,a,c FROM t1.</target>
        </trans-unit>
        <trans-unit id="6654bc4310d1eef443b5f0f2c1641262634e1e66" translate="yes" xml:space="preserve">
          <source>INSERT INTO t2 VALUES(1,59672,'fifty nine thousand six hundred seventy two');</source>
          <target state="translated">INSERT INTO t2 VALUES(1,59672,'fifty nine thousand six hundred seventy two').</target>
        </trans-unit>
        <trans-unit id="94d1d27ed943c864c7cfd96715bf162e7beab100" translate="yes" xml:space="preserve">
          <source>INSERT INTO t2 VALUES(24999,89569,'eighty nine thousand five hundred sixty nine');</source>
          <target state="translated">INSERT INTO t2 VALUES(24999,89569,'889,000,500,600')。</target>
        </trans-unit>
        <trans-unit id="253860cdd49bceb80fa941fa6a7a8aa222a2af3e" translate="yes" xml:space="preserve">
          <source>INSERT INTO t2 VALUES(25000,94666,'ninety four thousand six hundred sixty six');</source>
          <target state="translated">INSERT INTO t2 VALUES(25000,94666,'ninety four thousand six hundred sixty six').</target>
        </trans-unit>
        <trans-unit id="0e8f253b1b555988f2df4dcb60865d19307f1b0c" translate="yes" xml:space="preserve">
          <source>INSERT INTO t3 VALUES(24999,88509,'eighty eight thousand five hundred nine');</source>
          <target state="translated">INSERT INTO t3 VALUES(24999,88509,'八千五百九')。</target>
        </trans-unit>
        <trans-unit id="00be643bf7f738dedf700c9b2a35f10694c7941a" translate="yes" xml:space="preserve">
          <source>INSERT INTO t3 VALUES(25000,84791,'eighty four thousand seven hundred ninety one');</source>
          <target state="translated">INSERT INTO t3 VALUES(25000,84791,'884,000 7,900,91').</target>
        </trans-unit>
        <trans-unit id="eb2365c71aa4f9cd4a1bfec486fd83fcbdda7977" translate="yes" xml:space="preserve">
          <source>INSERT INTO tab1 VALUES(?,?,?);</source>
          <target state="translated">INSERT INTO tab1 VALUES(?,?)</target>
        </trans-unit>
        <trans-unit id="0666a7f2affc6b3653a4c2bdf54c9b4bb98361ed" translate="yes" xml:space="preserve">
          <source>INSERT INTO xyz(xyz) VALUES('automerge=N');</source>
          <target state="translated">INSERT INTO xyz(xyz)VALUES('automerge=N').</target>
        </trans-unit>
        <trans-unit id="4e8b9a8e297bede64cc05b119a6cea847e694a59" translate="yes" xml:space="preserve">
          <source>INSERT INTO xyz(xyz) VALUES('integrity-check');</source>
          <target state="translated">INSERT INTO xyz(xyz)VALUES('integrity-check')。</target>
        </trans-unit>
        <trans-unit id="f5e0d229ccc9b20df140de91fa55ac169f3840fe" translate="yes" xml:space="preserve">
          <source>INSERT INTO xyz(xyz) VALUES('merge=X,Y');</source>
          <target state="translated">INSERT INTO xyz(xyz)VALUES('merge=X,Y').</target>
        </trans-unit>
        <trans-unit id="5af88d4a59ba50ff893198ed67ae451d74a117e2" translate="yes" xml:space="preserve">
          <source>INSERT INTO xyz(xyz) VALUES('optimize');</source>
          <target state="translated">INSERT INTO xyz(xyz)VALUES('optimize')。</target>
        </trans-unit>
        <trans-unit id="13f47444da210de43c60aab402a316dfe2becb56" translate="yes" xml:space="preserve">
          <source>INSERT INTO xyz(xyz) VALUES('rebuild');</source>
          <target state="translated">INSERT INTO xyz(xyz)VALUES('rebuild')。</target>
        </trans-unit>
        <trans-unit id="631e931c19e40aa3da1ce6f0902d43d9a508af25" translate="yes" xml:space="preserve">
          <source>INSERT and UPDATE statements now always apply &lt;a href=&quot;datatype3#affinity&quot;&gt;column affinity&lt;/a&gt; before computing &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;. This bug fix could, in theory, cause problems for legacy databases with unorthodox CHECK constraints the require the input type for an INSERT is different from the declared column type. See ticket &lt;a href=&quot;https://sqlite.org/src/info/86ba67afafded936&quot;&gt;86ba67afafded936&lt;/a&gt; for more information.</source>
          <target state="translated">INSERT and UPDATE statements now always apply &lt;a href=&quot;datatype3#affinity&quot;&gt;column affinity&lt;/a&gt; before computing &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;. This bug fix could, in theory, cause problems for legacy databases with unorthodox CHECK constraints the require the input type for an INSERT is different from the declared column type. See ticket &lt;a href=&quot;https://sqlite.org/src/info/86ba67afafded936&quot;&gt;86ba67afafded936&lt;/a&gt; for more information.</target>
        </trans-unit>
        <trans-unit id="2f103f7920401a2a0647c3f2159a7c89eabff571" translate="yes" xml:space="preserve">
          <source>INSERT is really slow - I can only do few dozen INSERTs per second</source>
          <target state="translated">INSERTは本当に遅い-私は1秒間に数十回のINSERTしかできません。</target>
        </trans-unit>
        <trans-unit id="62d1399645f66158b7511abeddf89f395dea5fde" translate="yes" xml:space="preserve">
          <source>INSERT runs a little faster when the source is a SELECT statement.</source>
          <target state="translated">INSERTは、ソースがSELECT文の場合、少し速く実行されます。</target>
        </trans-unit>
        <trans-unit id="aeb597e62b4ad26deac5b62c60062c710ea90371" translate="yes" xml:space="preserve">
          <source>INSTEAD</source>
          <target state="translated">INSTEAD</target>
        </trans-unit>
        <trans-unit id="2300ac39d09a99728ae682403c03797ee8da658b" translate="yes" xml:space="preserve">
          <source>INSTEAD OF trigger</source>
          <target state="translated">トリガーの代わりに</target>
        </trans-unit>
        <trans-unit id="d8374d53c837e126cb6abc0132fba2a1f9a3a9c8" translate="yes" xml:space="preserve">
          <source>INSTEAD OF triggers</source>
          <target state="translated">トリガーの代わりに</target>
        </trans-unit>
        <trans-unit id="793985cddb68d46ef51b688aecf85864c9e06813" translate="yes" xml:space="preserve">
          <source>INT</source>
          <target state="translated">INT</target>
        </trans-unit>
        <trans-unit id="a3a0ec55e3e26ee54417c786dfad5d709ecb7c40" translate="yes" xml:space="preserve">
          <source>INT2</source>
          <target state="translated">INT2</target>
        </trans-unit>
        <trans-unit id="021a30ffe1ce8750cb57ce941d7fb3d04090b37c" translate="yes" xml:space="preserve">
          <source>INT8</source>
          <target state="translated">INT8</target>
        </trans-unit>
        <trans-unit id="0fe37e40e5dab3ac411c2ddca6d21991e811acfa" translate="yes" xml:space="preserve">
          <source>INTEGER</source>
          <target state="translated">INTEGER</target>
        </trans-unit>
        <trans-unit id="e3752510d6a9d0fb8f3974168ca6bea1a562a9ac" translate="yes" xml:space="preserve">
          <source>INTEGER PRIMARY KEY columns can be used to implement the equivalent of AUTOINCREMENT. If you try to insert a NULL into an INTEGER PRIMARY KEY column, the column will actually be filled with an integer that is one greater than the largest key already in the table. Or if the largest key is 2147483647, then the column will be filled with a random integer. Either way, the INTEGER PRIMARY KEY column will be assigned a unique integer. You can retrieve this integer using the &lt;b&gt;sqlite_last_insert_rowid()&lt;/b&gt; API function or using the &lt;b&gt;last_insert_rowid()&lt;/b&gt; SQL function in a subsequent SELECT statement.</source>
          <target state="translated">INTEGER PRIMARY KEY列を使用して、AUTOINCREMENTと同等の機能を実装できます。INTEGER PRIMARY KEY列にNULLを挿入しようとすると、実際には、列は、テーブルに既に存在する最大のキーよりも1大きい整数で埋められます。または、最大のキーが2147483647の場合、列はランダムな整数で埋められます。どちらの方法でも、INTEGER PRIMARY KEY列には一意の整数が割り当てられます。この整数を取得するには、&lt;b&gt;sqlite_last_insert_rowid（）&lt;/b&gt; API関数を使用するか、後続のSELECTステートメントで&lt;b&gt;last_insert_rowid（）&lt;/b&gt; SQL関数を使用します。</target>
        </trans-unit>
        <trans-unit id="6f436e25f27f33e27c6053472309a17baa61d133" translate="yes" xml:space="preserve">
          <source>INTERFACE</source>
          <target state="translated">INTERFACE</target>
        </trans-unit>
        <trans-unit id="3230de938114213aa9c2d1e95f291cad51ede171" translate="yes" xml:space="preserve">
          <source>INTERSECT</source>
          <target state="translated">INTERSECT</target>
        </trans-unit>
        <trans-unit id="ce45b16212fe00c28d1a00de9cdfe954aa5bdc83" translate="yes" xml:space="preserve">
          <source>INTO</source>
          <target state="translated">INTO</target>
        </trans-unit>
        <trans-unit id="ec4a2a5056d72d8e03345caaebf4607d163e6dd7" translate="yes" xml:space="preserve">
          <source>IS</source>
          <target state="translated">IS</target>
        </trans-unit>
        <trans-unit id="819809f7649d3da66fd65a40dff83509ed2b98d0" translate="yes" xml:space="preserve">
          <source>IS NOT</source>
          <target state="translated">ではない</target>
        </trans-unit>
        <trans-unit id="437390c0773d23a0b0e272480ef7204b356f23ad" translate="yes" xml:space="preserve">
          <source>IS operator</source>
          <target state="translated">アイエスえんざんし</target>
        </trans-unit>
        <trans-unit id="4e93120a53b25e7642cc15924ececcc7c79ac693" translate="yes" xml:space="preserve">
          <source>ISNULL</source>
          <target state="translated">ISNULL</target>
        </trans-unit>
        <trans-unit id="c8c6b6fe3176986c9e57f2648e139dfd273d0908" translate="yes" xml:space="preserve">
          <source>Ideally, all changes for an entire write transaction are buffered in the page cache until the end of the transaction. When the user commits the transaction, all changes are applied to the database file in the most efficient way possible, taking into account the assumptions enumerated in section</source>
          <target state="translated">理想的には、書き込みトランザクション全体に対するすべての変更は、トランザクションが終了するまでページキャッシュにバッファリングされる。ユーザがトランザクションをコミットするとき、すべての変更は、セクション</target>
        </trans-unit>
        <trans-unit id="3aa28748de853653631eccc0d256aed420f0eed1" translate="yes" xml:space="preserve">
          <source>Ideally, applications should &lt;a href=&quot;#sqlite3_finalize&quot;&gt;finalize&lt;/a&gt; all &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;close&lt;/a&gt; all &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handles&lt;/a&gt;, and &lt;a href=&quot;#sqlite3backupfinish&quot;&gt;finish&lt;/a&gt; all &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects associated with the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object prior to attempting to close the object. If the database connection is associated with unfinalized prepared statements, BLOB handlers, and/or unfinished sqlite3_backup objects then sqlite3_close() will leave the database connection open and return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;. If sqlite3_close_v2() is called with unfinalized prepared statements, unclosed BLOB handlers, and/or unfinished sqlite3_backups, it returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; regardless, but instead of deallocating the database connection immediately, it marks the database connection as an unusable &quot;zombie&quot; and makes arrangements to automatically deallocate the database connection after all prepared statements are finalized, all BLOB handles are closed, and all backups have finished. The sqlite3_close_v2() interface is intended for use with host languages that are garbage collected, and where the order in which destructors are called is arbitrary.</source>
          <target state="translated">Ideally, applications should &lt;a href=&quot;#sqlite3_finalize&quot;&gt;finalize&lt;/a&gt; all &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;close&lt;/a&gt; all &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handles&lt;/a&gt;, and &lt;a href=&quot;#sqlite3backupfinish&quot;&gt;finish&lt;/a&gt; all &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects associated with the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object prior to attempting to close the object. If the database connection is associated with unfinalized prepared statements, BLOB handlers, and/or unfinished sqlite3_backup objects then sqlite3_close() will leave the database connection open and return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;. If sqlite3_close_v2() is called with unfinalized prepared statements, unclosed BLOB handlers, and/or unfinished sqlite3_backups, it returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; regardless, but instead of deallocating the database connection immediately, it marks the database connection as an unusable &quot;zombie&quot; and makes arrangements to automatically deallocate the database connection after all prepared statements are finalized, all BLOB handles are closed, and all backups have finished. The sqlite3_close_v2() interface is intended for use with host languages that are garbage collected, and where the order in which destructors are called is arbitrary.</target>
        </trans-unit>
        <trans-unit id="c6a04cc62fe27e532be18f141495602f090fc2e2" translate="yes" xml:space="preserve">
          <source>Ideally, applications should &lt;a href=&quot;finalize&quot;&gt;finalize&lt;/a&gt; all &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;blob_close&quot;&gt;close&lt;/a&gt; all &lt;a href=&quot;blob&quot;&gt;BLOB handles&lt;/a&gt;, and &lt;a href=&quot;backup_finish#sqlite3backupfinish&quot;&gt;finish&lt;/a&gt; all &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects associated with the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object prior to attempting to close the object. If the database connection is associated with unfinalized prepared statements, BLOB handlers, and/or unfinished sqlite3_backup objects then sqlite3_close() will leave the database connection open and return &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. If sqlite3_close_v2() is called with unfinalized prepared statements, unclosed BLOB handlers, and/or unfinished sqlite3_backups, it returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; regardless, but instead of deallocating the database connection immediately, it marks the database connection as an unusable &quot;zombie&quot; and makes arrangements to automatically deallocate the database connection after all prepared statements are finalized, all BLOB handles are closed, and all backups have finished. The sqlite3_close_v2() interface is intended for use with host languages that are garbage collected, and where the order in which destructors are called is arbitrary.</source>
          <target state="translated">Ideally, applications should &lt;a href=&quot;finalize&quot;&gt;finalize&lt;/a&gt; all &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;blob_close&quot;&gt;close&lt;/a&gt; all &lt;a href=&quot;blob&quot;&gt;BLOB handles&lt;/a&gt;, and &lt;a href=&quot;backup_finish#sqlite3backupfinish&quot;&gt;finish&lt;/a&gt; all &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects associated with the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object prior to attempting to close the object. If the database connection is associated with unfinalized prepared statements, BLOB handlers, and/or unfinished sqlite3_backup objects then sqlite3_close() will leave the database connection open and return &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. If sqlite3_close_v2() is called with unfinalized prepared statements, unclosed BLOB handlers, and/or unfinished sqlite3_backups, it returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; regardless, but instead of deallocating the database connection immediately, it marks the database connection as an unusable &quot;zombie&quot; and makes arrangements to automatically deallocate the database connection after all prepared statements are finalized, all BLOB handles are closed, and all backups have finished. The sqlite3_close_v2() interface is intended for use with host languages that are garbage collected, and where the order in which destructors are called is arbitrary.</target>
        </trans-unit>
        <trans-unit id="6acc0ba610f36525f417357719583f041f6f89df" translate="yes" xml:space="preserve">
          <source>Identify all methods for important objects in the interface documentation. (&lt;a href=&quot;c3ref/context&quot;&gt;example&lt;/a&gt;)</source>
          <target state="translated">インターフェイスドキュメントで重要なオブジェクトのすべてのメソッドを特定します。（&lt;a href=&quot;c3ref/context&quot;&gt;例&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="b22904746b6da6e6da1cdf65a007a3a92ddeb189" translate="yes" xml:space="preserve">
          <source>IdxDelete</source>
          <target state="translated">IdxDelete</target>
        </trans-unit>
        <trans-unit id="366f895979adef772b50f0a751ee770dc166bab5" translate="yes" xml:space="preserve">
          <source>IdxGE</source>
          <target state="translated">IdxGE</target>
        </trans-unit>
        <trans-unit id="267d8b7b66c2e63c7420b46c7edd1ef118e13442" translate="yes" xml:space="preserve">
          <source>IdxGT</source>
          <target state="translated">IdxGT</target>
        </trans-unit>
        <trans-unit id="bdc0a8ea07737acbd00822ec9e49840776244c14" translate="yes" xml:space="preserve">
          <source>IdxInsert</source>
          <target state="translated">IdxInsert</target>
        </trans-unit>
        <trans-unit id="ba9bc003fbf28927e55ed674e6312a7b981c1435" translate="yes" xml:space="preserve">
          <source>IdxLE</source>
          <target state="translated">IdxLE</target>
        </trans-unit>
        <trans-unit id="11ede54300baae62726a3150e6c2f825098c4577" translate="yes" xml:space="preserve">
          <source>IdxLT</source>
          <target state="translated">IdxLT</target>
        </trans-unit>
        <trans-unit id="c82f35a450e8e6ba85d6a5ba639866e8424ba8d9" translate="yes" xml:space="preserve">
          <source>IdxRowid</source>
          <target state="translated">IdxRowid</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="7194c23292e4ec0e7bfbbaa15bc21cc90107f2f5" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object V was initialized using &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_pointer(S,I,P,X,D)&lt;/a&gt; or &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_pointer(C,P,X,D)&lt;/a&gt; and if X and Y are strings that compare equal according to strcmp(X,Y), then sqlite3_value_pointer(V,Y) will return the pointer P. Otherwise, sqlite3_value_pointer(V,Y) returns a NULL. The sqlite3_bind_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">場合&lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt;オブジェクトVを用いて初期化された&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;（S、I、P、X、D）sqlite3_bind_pointerを&lt;/a&gt;又は&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_pointer（C、P、X、D）&lt;/a&gt;とX及びYは、その後のstrcmpに等しい係る比較文字列（X、Y）を、ある場合sqlite3_value_pointer（V、Y）はポインターPを返します。それ以外の場合、sqlite3_value_pointer（V、Y）はNULLを返します。 sqlite3_bind_pointer（）ルーチンは、SQLite 3.20.0に追加された&lt;a href=&quot;bindptr&quot;&gt;ポインター受け渡しインターフェースの&lt;/a&gt;一部です。</target>
        </trans-unit>
        <trans-unit id="6f26b5b5b34df807b99862702ef8a28042e009ca" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../uri&quot;&gt;URI filename&lt;/a&gt; interpretation is enabled, and the filename argument begins with &quot;file:&quot;, then the filename is interpreted as a URI. URI filename interpretation is enabled if the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flag is set in the third argument to sqlite3_open_v2(), or if it has been enabled globally using the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt; option with the &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; method or by the &lt;a href=&quot;../compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; compile-time option. URI filename interpretation is turned off by default, but future releases of SQLite might enable URI filename interpretation by default. See &quot;&lt;a href=&quot;../uri&quot;&gt;URI filenames&lt;/a&gt;&quot; for additional information.</source>
          <target state="translated">場合&lt;a href=&quot;../uri&quot;&gt;URIファイル名の&lt;/a&gt;解釈が有効になっている、とfilename引数で始まる「ファイル：」、そしてファイル名はURIと解釈されます。&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;フラグがsqlite3_open_v2（）の3番目の引数で設定されている場合、または&lt;a href=&quot;config&quot;&gt;sqlite3_config（）&lt;/a&gt;メソッドで&lt;a href=&quot;c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;オプションを使用するか、&lt;a href=&quot;../compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt;コンパイル時オプションによってグローバルに有効にされている場合、URIファイル名の解釈が有効になります。 URIファイル名の解釈はデフォルトでオフになっていますが、SQLiteの将来のリリースでは、URIファイル名の解釈がデフォルトで有効になる可能性があります。詳細については、「&lt;a href=&quot;../uri&quot;&gt;URIファイル名&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="05071756ec11a7890791b184fe1e16795132ff77" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt; are &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;enabled&lt;/a&gt; and a column with a &lt;a href=&quot;syntax/foreign-key-clause&quot;&gt;REFERENCES clause&lt;/a&gt; is added, the column must have a default value of NULL.</source>
          <target state="translated">場合は&lt;a href=&quot;foreignkeys&quot;&gt;、外部キー制約が&lt;/a&gt;されている&lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;有効&lt;/a&gt;と持つ列&lt;a href=&quot;syntax/foreign-key-clause&quot;&gt;REFERENCES句が&lt;/a&gt;追加され、列がNULLのデフォルト値を持っている必要があります。</target>
        </trans-unit>
        <trans-unit id="4f1ff78b03ab38bd9d7bc0c0b70bf71a047d9c7f" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt; are enabled, a DROP TABLE command performs an implicit &lt;a href=&quot;lang_delete&quot;&gt;DELETE FROM&lt;/a&gt; command before removing the table from the database schema. Any triggers attached to the table are dropped from the database schema before the implicit DELETE FROM is executed, so this cannot cause any triggers to fire. By contrast, an implicit DELETE FROM does cause any configured &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; to take place. If the implicit DELETE FROM executed as part of a DROP TABLE command violates any immediate foreign key constraints, an error is returned and the table is not dropped. If the implicit DELETE FROM causes any deferred foreign key constraints to be violated, and the violations still exist when the transaction is committed, an error is returned at the time of commit.</source>
          <target state="translated">場合は&lt;a href=&quot;foreignkeys&quot;&gt;、外部キー制約が&lt;/a&gt;有効になっている、DROP TABLEコマンドは、暗黙の実行&lt;a href=&quot;lang_delete&quot;&gt;FROM DELETE&lt;/a&gt;データベーススキーマからテーブルを削除する前にコマンドを。テーブルにアタッチされているトリガーは、暗黙的なDELETE FROMが実行される前にデータベーススキーマから削除されるため、トリガーが起動することはありません。対照的に、暗黙的なDELETE FROMは、構成済みの&lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;外部キーアクションを&lt;/a&gt;引き起こします行われます。DROP TABLEコマンドの一部として実行された暗黙のDELETE FROMが即時の外部キー制約に違反している場合、エラーが返され、テーブルは削除されません。暗黙のDELETE FROMによって遅延外部キー制約に違反し、トランザクションがコミットされたときに違反がまだ存在する場合、コミット時にエラーが返されます。</target>
        </trans-unit>
        <trans-unit id="5f1e27999e2bb2ba42de86bd45d31998c0603f29" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode&lt;/a&gt; is set to OFF (thus disabling the rollback journal file) then the behavior of the ROLLBACK command is undefined.</source>
          <target state="translated">場合&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;プラグマjournal_modeが&lt;/a&gt;（したがって、ロールバック・ジャーナル・ファイルを無効にする）OFFに設定され、その後ROLLBACKコマンドの動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="ff29cd60491f93076673fb75bedc0744960c9309" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;EXCLUSIVE locking mode&lt;/a&gt; is set prior to the first WAL-mode database access, then SQLite never attempts to call any of the shared-memory methods and hence no shared-memory wal-index is ever created. In that case, the database connection remains in EXCLUSIVE mode as long as the journal mode is WAL; attempts to change the locking mode using &quot;&lt;code&gt;PRAGMA locking_mode=NORMAL;&lt;/code&gt;&quot; are no-ops. The only way to change out of EXCLUSIVE locking mode is to first change out of WAL journal mode.</source>
          <target state="translated">場合&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;排他的ロックモードが&lt;/a&gt;最初WALモードデータベースアクセスの前に設定され、その後、共有メモリのいずれかの方法、従ってない共有メモリウォルマートインデックスを呼び出すためのSQLite決して試みはこれまでに作成されています。その場合、データベース接続は、ジャーナルモードがWALである限り、EXCLUSIVEモードのままです。 「 &lt;code&gt;PRAGMA locking_mode=NORMAL;&lt;/code&gt; 」を使用してロックモードを変更しようとすると、何も起こりません。 EXCLUSIVEロックモードを変更する唯一の方法は、最初にWALジャーナルモードを変更することです。</target>
        </trans-unit>
        <trans-unit id="53ecc95d367e022d4f668ded862caf4b37a61a3f" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; interpretation is enabled, and the filename argument begins with &quot;file:&quot;, then the filename is interpreted as a URI. URI filename interpretation is enabled if the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flag is set in the third argument to sqlite3_open_v2(), or if it has been enabled globally using the &lt;a href=&quot;#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt; option with the &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; method or by the &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; compile-time option. URI filename interpretation is turned off by default, but future releases of SQLite might enable URI filename interpretation by default. See &quot;&lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt;&quot; for additional information.</source>
          <target state="translated">場合&lt;a href=&quot;uri&quot;&gt;URIファイル名の&lt;/a&gt;解釈が有効になっている、とfilename引数で始まる「ファイル：」、そしてファイル名はURIと解釈されます。&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;フラグがsqlite3_open_v2（）の3番目の引数で設定されている場合、または&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config（）&lt;/a&gt;メソッドで&lt;a href=&quot;#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;オプションを使用するか、&lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt;コンパイル時オプションによってグローバルに有効にされている場合、URIファイル名の解釈が有効になります。 URIファイル名の解釈はデフォルトでオフになっていますが、SQLiteの将来のリリースでは、URIファイル名の解釈がデフォルトで有効になる可能性があります。詳細については、「&lt;a href=&quot;uri&quot;&gt;URIファイル名&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="0b1cbecea1bfc84769a23d468c11c6578d2f04c8" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object V was initialized using &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_pointer(S,I,P,X,D)&lt;/a&gt; or &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_pointer(C,P,X,D)&lt;/a&gt; and if X and Y are strings that compare equal according to strcmp(X,Y), then sqlite3_value_pointer(V,Y) will return the pointer P. Otherwise, sqlite3_value_pointer(V,Y) returns a NULL. The sqlite3_bind_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">場合&lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt;オブジェクトVを用いて初期化された&lt;a href=&quot;bind_blob&quot;&gt;（S、I、P、X、D）sqlite3_bind_pointerを&lt;/a&gt;又は&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_pointer（C、P、X、D）&lt;/a&gt;とX及びYは、その後のstrcmpに等しい係る比較文字列（X、Y）を、ある場合sqlite3_value_pointer（V、Y）はポインターPを返します。それ以外の場合、sqlite3_value_pointer（V、Y）はNULLを返します。 sqlite3_bind_pointer（）ルーチンは、SQLite 3.20.0に追加された&lt;a href=&quot;../bindptr&quot;&gt;ポインター受け渡しインターフェースの&lt;/a&gt;一部です。</target>
        </trans-unit>
        <trans-unit id="efa51497a7f80ea6cb0e82aee000934c754a4257" translate="yes" xml:space="preserve">
          <source>If A&amp;lt;B THEN B&amp;gt;A.</source>
          <target state="translated">A &amp;lt;B THEN B&amp;gt; Aの場合。</target>
        </trans-unit>
        <trans-unit id="af85ab5198e03592c9a1e93f75055ff7f7b4d432" translate="yes" xml:space="preserve">
          <source>If A&amp;lt;B and B&amp;lt;C then A&amp;lt;C.</source>
          <target state="translated">A &amp;lt;BおよびB &amp;lt;Cの場合、A &amp;lt;Cです。</target>
        </trans-unit>
        <trans-unit id="ee7bb0a19c51474ba2d6ea010cd538d977b0b7a6" translate="yes" xml:space="preserve">
          <source>If A==B and B==C then A==C.</source>
          <target state="translated">A==BでB==Cならば、A==Cとなります。</target>
        </trans-unit>
        <trans-unit id="ad62f244096def890ab26a681e8f0120126f5af5" translate="yes" xml:space="preserve">
          <source>If A==B then B==A.</source>
          <target state="translated">A==Bならば、B==Aとなります。</target>
        </trans-unit>
        <trans-unit id="215c914a1a9a516e367b5ac91682005ac659922c" translate="yes" xml:space="preserve">
          <source>If AUTOVACUUM is enabled then it is possible that another root page might be moved into the newly deleted root page in order to keep all root pages contiguous at the beginning of the database. The former value of the root page that moved - its value before the move occurred - is stored in register P2. If no page movement was required (because the table being dropped was already the last one in the database) then a zero is stored in register P2. If AUTOVACUUM is disabled then a zero is stored in register P2.</source>
          <target state="translated">AUTOVACUUMが有効になっている場合、データベースの開始時にすべてのルートページが連続している状態を維持するために、別のルートページが新しく削除されたルートページに移動される可能性があります。移動したルートページの前の値-移動が発生する前の値-は、レジスタP2に格納されます。ページ移動が必要なかった場合(削除されるテーブルがデータベース内の最後のテーブルだったため)、レジスタP2にゼロが格納されます。AUTOVACUUMが無効になっている場合、ゼロがレジスタP2に格納されます。</target>
        </trans-unit>
        <trans-unit id="ed950ba22e4eb6cfb3232df6ec7b67b59a4df463" translate="yes" xml:space="preserve">
          <source>If CHANGESET_REPLACE is returned by an SQLITE_CHANGESET_CONFLICT conflict handler, then the conflicting row is removed from the database and a second attempt to apply the change is made. If this second attempt fails, the original row is restored to the database before continuing.</source>
          <target state="translated">CHANGESET_REPLACEがSQLITE_CHANGESET_CONFLICTコンフリクトハンドラによって返された場合、コンフリクトしている行はデータベースから削除され、変更を適用するための2回目の試行が行われます。この 2 回目の試みが失敗した場合、元の行はデータベースにリストアされてから続行されます。</target>
        </trans-unit>
        <trans-unit id="30467096b4dd78c0d45cf667e992ae71e7009c64" translate="yes" xml:space="preserve">
          <source>If CHANGESET_REPLACE is returned by an SQLITE_CHANGESET_DATA conflict handler, then the conflicting row is either updated or deleted, depending on the type of change.</source>
          <target state="translated">CHANGESET_REPLACE が SQLITE_CHANGESET_DATA 競合ハンドラによって返された場合、競合する行は変更の種類に応じて更新または削除されます。</target>
        </trans-unit>
        <trans-unit id="1a6c0fd79d5064239e68ae7d0df720319dab8e2b" translate="yes" xml:space="preserve">
          <source>If F is a NULL pointer, then sqlite3_uri_parameter(F,P) returns NULL and sqlite3_uri_boolean(F,P,B) returns B. If F is not a NULL pointer and is not a database file pathname pointer that SQLite passed into the xOpen VFS method, then the behavior of this routine is undefined and probably undesirable.</source>
          <target state="translated">FがNULLポインタの場合、sqlite3_uri_parameter(F,P)はNULLを返し、sqlite3_uri_boolean(F,P,B)はBを返します。 FがNULLポインタではなく、SQLiteがxOpen VFSメソッドに渡したデータベースファイルのパス名ポインタではない場合、このルーチンの動作は未定義であり、おそらく望ましくありません。</target>
        </trans-unit>
        <trans-unit id="7f60624c5c0f9adef9d93c9ed8179bc298264376" translate="yes" xml:space="preserve">
          <source>If F is a NULL pointer, then sqlite3_uri_parameter(F,P) returns NULL and sqlite3_uri_boolean(F,P,B) returns B. If F is not a NULL pointer and is not a database file pathname pointer that the SQLite core passed into the xOpen VFS method, then the behavior of this routine is undefined and probably undesirable.</source>
          <target state="translated">FがNULLポインタの場合、sqlite3_uri_parameter(F,P)はNULLを返し、sqlite3_uri_boolean(F,P,B)はBを返します。 FがNULLポインタではなく、SQLiteコアがxOpen VFSメソッドに渡したデータベースファイルのパス名ポインタではない場合、このルーチンの動作は未定義であり、おそらく望ましくありません。</target>
        </trans-unit>
        <trans-unit id="4646f7a7f8236532256725ec4112b997f511c7d6" translate="yes" xml:space="preserve">
          <source>If F is a suitable filename (as described in the previous paragraph) and if P is the name of the query parameter, then sqlite3_uri_parameter(F,P) returns the value of the P parameter if it exists or a NULL pointer if P does not appear as a query parameter on F. If P is a query parameter of F and it has no explicit value, then sqlite3_uri_parameter(F,P) returns a pointer to an empty string.</source>
          <target state="translated">Fが適切なファイル名(前段落で説明したように)であり、Pが問い合わせパラメータの名前である場合、sqlite3_uri_parameter(F,P)はPパラメータが存在する場合はその値を返し、PがFの問い合わせパラメータとして現れない場合はNULLポインタを返します。</target>
        </trans-unit>
        <trans-unit id="9276605b0b0a889bb4c7aa5fcec85c6fc6240625" translate="yes" xml:space="preserve">
          <source>If F is the database filename pointer passed into the xOpen() method of a VFS implementation when the flags parameter to xOpen() has one or more of the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; or &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_MAIN_DB&lt;/a&gt; bits set and P is the name of the query parameter, then sqlite3_uri_parameter(F,P) returns the value of the P parameter if it exists or a NULL pointer if P does not appear as a query parameter on F. If P is a query parameter of F has no explicit value, then sqlite3_uri_parameter(F,P) returns a pointer to an empty string.</source>
          <target state="translated">FがVFS実装のxOpen（）メソッドに渡されるデータベースファイル名ポインターであり、xOpen（）へのフラグパラメーターに1つ以上の&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;または&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_MAIN_DB&lt;/a&gt;ビットが設定され、Pがクエリパラメーターの名前である場合、sqlite3_uri_parameter（ F、P）は、Pパラメータが存在する場合はPパラメータの値を返し、PがFのクエリパラメータとして表示されない場合はNULLポインタを返します。PがFのクエリパラメータである場合、Fに明示的な値がない場合、sqlite3_uri_parameter（F、P）空の文字列へのポインタを返します。</target>
        </trans-unit>
        <trans-unit id="8ba138ee3e59443a69735dbcd87f0f8269dd9564" translate="yes" xml:space="preserve">
          <source>If F is the database filename pointer passed into the xOpen() method of a VFS implementation when the flags parameter to xOpen() has one or more of the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; or &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_MAIN_DB&lt;/a&gt; bits set and P is the name of the query parameter, then sqlite3_uri_parameter(F,P) returns the value of the P parameter if it exists or a NULL pointer if P does not appear as a query parameter on F. If P is a query parameter of F has no explicit value, then sqlite3_uri_parameter(F,P) returns a pointer to an empty string.</source>
          <target state="translated">FがVFS実装のxOpen（）メソッドに渡されるデータベースファイル名ポインターであり、xOpen（）へのフラグパラメーターに1つ以上の&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt;または&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_MAIN_DB&lt;/a&gt;ビットが設定され、Pがクエリパラメーターの名前である場合、sqlite3_uri_parameter（ F、P）は、Pパラメータが存在する場合はPパラメータの値を返し、PがFのクエリパラメータとして表示されない場合はNULLポインタを返します。PがFのクエリパラメータである場合、Fに明示的な値がない場合、sqlite3_uri_parameter（F、P）空の文字列へのポインタを返します。</target>
        </trans-unit>
        <trans-unit id="96db4246a2920821a0342bd0eb3ee7ac297124f4" translate="yes" xml:space="preserve">
          <source>If F is the name of an sqlite database file, journal file, or WAL file passed by the SQLite core into the VFS, or if F is a database filename obtained from &lt;a href=&quot;#sqlite3_db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, then sqlite3_filename_journal(F) returns the name of the corresponding rollback journal file.</source>
          <target state="translated">If F is the name of an sqlite database file, journal file, or WAL file passed by the SQLite core into the VFS, or if F is a database filename obtained from &lt;a href=&quot;#sqlite3_db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, then sqlite3_filename_journal(F) returns the name of the corresponding rollback journal file.</target>
        </trans-unit>
        <trans-unit id="c5222d2f3de406b301b9d249247c656c5b47394f" translate="yes" xml:space="preserve">
          <source>If F is the name of an sqlite database file, journal file, or WAL file passed by the SQLite core into the VFS, then sqlite3_filename_database(F) returns the name of the corresponding database file.</source>
          <target state="translated">FがSQLiteコアからVFSに渡されたsqliteデータベースファイル、ジャーナルファイル、またはWALファイルの名前である場合、sqlite3_filename_database(F)は対応するデータベースファイルの名前を返します。</target>
        </trans-unit>
        <trans-unit id="dbbd8f58db83b28c968f4a1fd0df5ad504ea9fa0" translate="yes" xml:space="preserve">
          <source>If F is the name of an sqlite database file, journal file, or WAL file that was passed by the SQLite core into the VFS, or if F is a database filename obtained from &lt;a href=&quot;#sqlite3_db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, then sqlite3_filename_wal(F) returns the name of the corresponding WAL file.</source>
          <target state="translated">If F is the name of an sqlite database file, journal file, or WAL file that was passed by the SQLite core into the VFS, or if F is a database filename obtained from &lt;a href=&quot;#sqlite3_db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt;, then sqlite3_filename_wal(F) returns the name of the corresponding WAL file.</target>
        </trans-unit>
        <trans-unit id="298246b211caead4a1410b71d74279a5d314bec4" translate="yes" xml:space="preserve">
          <source>If FILE is a ZIP archive rather than an SQLite Archive, the &quot;.archive&quot; command and the &quot;-A&quot; command-line option still work. This is accomplished using of the &lt;a href=&quot;zipfile&quot;&gt;zipfile&lt;/a&gt; extension. Hence, the following commands are roughly equivalent, differing only in output formatting:</source>
          <target state="translated">FILEがSQLiteアーカイブではなくZIPアーカイブの場合、「。archive」コマンドと「-A」コマンドラインオプションは引き続き機能します。これは、&lt;a href=&quot;zipfile&quot;&gt;zipfile&lt;/a&gt;拡張子を使用して行われます。したがって、次のコマンドはほぼ同じで、出力フォーマットのみが異なります。</target>
        </trans-unit>
        <trans-unit id="d860543f88997bfbcee9b4b76e89b05bba6e3e47" translate="yes" xml:space="preserve">
          <source>If M is -1 in the initial journal header, then the number of page records that follow is computed by computing how many page records will fit in the available space of the remainder of the journal file.</source>
          <target state="translated">最初のジャーナル・ヘッダで M が -1 の場合、その後に続くページ・レコードの数は、ジャーナル・ファイルの残りのスペースに収まるページ・レコードの数を計算して計算されます。</target>
        </trans-unit>
        <trans-unit id="9d3a57a4870ed12272e250deed6ea841c224df1b" translate="yes" xml:space="preserve">
          <source>If NORMAL locking mode is in effect for the first WAL-mode database access, then the shared-memory wal-index is created. This means that the underlying VFS must support the &quot;version 2&quot; shared-memory. If the VFS does not support shared-memory methods, then the attempt to open a database that is already in WAL mode, or the attempt convert a database into WAL mode, will fail. As long as exactly one connection is using a shared-memory wal-index, the locking mode can be changed freely between NORMAL and EXCLUSIVE. It is only when the shared-memory wal-index is omitted, when the locking mode is EXCLUSIVE prior to the first WAL-mode database access, that the locking mode is stuck in EXCLUSIVE.</source>
          <target state="translated">最初のWALモードデータベースアクセスに対してNORMALロックモードが有効な場合、共有メモリのWAL-INDEXが作成されます。これは、基礎となるVFSが「バージョン2」の共有メモリをサポートしていなければならないことを意味します。VFSが共有メモリ方式をサポートしていない場合、すでにWALモードになっているデータベースを開こうとしたり、データベースをWALモードに変換しようとすると失敗します。正確に1つの接続が共有メモリのwal-indexを使用している限り、ロックモードはNORMALとEXCLUSIVEの間で自由に変更することができます。共有メモリのwal-indexが省略された場合、最初のWALモードのデータベースアクセスの前にロックモードがEXCLUSIVEになっている場合にのみ、ロックモードがEXCLUSIVEでスタックします。</target>
        </trans-unit>
        <trans-unit id="084a98d24eb789b16e0f410999491d6ca6f68655" translate="yes" xml:space="preserve">
          <source>If NULL is inserted into the mode column, then the mode of the new archive entry is automatically set to either 33188 (-rw-r--r--) or 16877 (drwxr-xr-x), depending on whether or not the values specified for columns &quot;sz&quot;, &quot;data&quot; and &quot;rawdata&quot; indicate that the new entry is a directory.</source>
          <target state="translated">mode 列に NULL が挿入された場合、新しいアーカイブエントリのモードは自動的に 33188 (-rw-r--r--)か 16877 (drwxr-xr-x)のいずれかに設定されます。</target>
        </trans-unit>
        <trans-unit id="4101f8cb88698edd15d7c951de1289b2d8eaa71c" translate="yes" xml:space="preserve">
          <source>If NULL is inserted into the mtime column, then the timestamp of the new entry is set to the current time. Otherwise, the specified value is interpreted as an integer and used as is.</source>
          <target state="translated">mtime列にNULLが挿入された場合、新しいエントリのタイムスタンプは現在の時刻に設定されます。そうでなければ、指定された値は整数として解釈され、そのまま使用されます。</target>
        </trans-unit>
        <trans-unit id="43806989f629698fba47d7f7a7bc8a167120b2e8" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_area(P) returns the area enclosed by that polygon. If P is not a polygon, geopoly_area(P) returns NULL.</source>
          <target state="translated">P が多角形である場合、geopoly_area(P)はその多角形で囲まれた領域を返します。Pが多角形でない場合、geopoly_area(P)はNULLを返します。</target>
        </trans-unit>
        <trans-unit id="7923fadf3f55cd9b6d47a16ad18e97575f464043" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_bbox(P) returns a new polygon that is the smallest (axis-aligned) rectangle completely enclosing P. If P is not a polygon, geopoly_bbox(P) returns NULL.</source>
          <target state="translated">P が多角形である場合,geopoly_bbox(P)は,P を完全に囲む最小の(軸合わせされた)矩形である新しい多角形を返します.</target>
        </trans-unit>
        <trans-unit id="231cf86fd88561789cf32053e3b5a58ac30a1c90" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_blob(P) returns the binary encoding of that polygon as a BLOB. If P is not a polygon, geopoly_blob(P) returns NULL.</source>
          <target state="translated">Pがポリゴンの場合、 geopoly_blob(P)はそのポリゴンのバイナリエンコーディングをBLOBとして返します。P がポリゴンでない場合は、 geopoly_blob(P)は NULL を返します。</target>
        </trans-unit>
        <trans-unit id="85466629c4fd74bf6816a1cb264ff5557384a47f" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_contains_point(P,X,Y) returns a non-zero integer if and only if the coordinate X,Y is inside or on the boundary of the polygon P. If P is not a polygon, geopoly_contains_point(P,X,Y) returns NULL.</source>
          <target state="translated">P が多角形であれば、座標 X,Y が多角形 P の内側または境界上にある場合に限り、 geopoly_contains_point(P,X,Y)は 0 以外の整数を返します。</target>
        </trans-unit>
        <trans-unit id="01d01cedd541548c033da5a76ae2b943d566e364" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_json(P) returns the GeoJSON representation of that polygon as a TEXT string. If P is not a polygon, geopoly_json(P) returns NULL.</source>
          <target state="translated">P がポリゴンの場合、geopoly_json(P)はそのポリゴンの GeoJSON 表現を TEXT 文字列として返します。Pがポリゴンでない場合、geopoly_json(P)はNULLを返します。</target>
        </trans-unit>
        <trans-unit id="4d96f5fac84b02e3eed71829015c2301166a1102" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_svg(P,...) returns a text string which is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;Scalable Vector Graphics (SVG)&lt;/a&gt; representation of that polygon. If there is more one argument, then second and subsequent arguments are added as attributes to each SVG glyph. For example:</source>
          <target state="translated">Pがポリゴンの場合、geopoly_svg（P、...）は、そのポリゴンの&lt;a href=&quot;https://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;Scalable Vector Graphics（SVG）&lt;/a&gt;表現であるテキスト文字列を返します。引数が複数ある場合は、2番目以降の引数が属性として各SVGグリフに追加されます。例えば：</target>
        </trans-unit>
        <trans-unit id="8bf89c8791c7886430f52d199af4522be0892c2c" translate="yes" xml:space="preserve">
          <source>If P is not a polygon, geopoly_svg(P,...) returns NULL.</source>
          <target state="translated">P が多角形でない場合,geopoly_svg(P,...)は NULL を返します.</target>
        </trans-unit>
        <trans-unit id="8d6c1d000f406140de377a0a6166c3f4f4ee6ecf" translate="yes" xml:space="preserve">
          <source>If P&amp;gt;X and K&amp;gt;X then the first M bytes of P are stored on the btree page and the remaining P-M bytes are stored on overflow pages.</source>
          <target state="translated">P&amp;gt; XおよびK&amp;gt; Xの場合、Pの最初のMバイトはbtreeページに格納され、残りのPMバイトはオーバーフローページに格納されます。</target>
        </trans-unit>
        <trans-unit id="40c35ab59089c6d8a3b822955c4be859755a9e2b" translate="yes" xml:space="preserve">
          <source>If P&amp;gt;X and K&amp;lt;=X then the first K bytes of P are stored on the btree page and the remaining P-K bytes are stored on overflow pages.</source>
          <target state="translated">P&amp;gt; XおよびK &amp;lt;= Xの場合、Pの最初のKバイトはbtreeページに格納され、残りのPKバイトはオーバーフローページに格納されます。</target>
        </trans-unit>
        <trans-unit id="fa33ffa92f81891eff9dffa21d7e8d38e3faa786" translate="yes" xml:space="preserve">
          <source>If P&amp;lt;=X then all P bytes of payload are stored directly on the btree page without overflow.</source>
          <target state="translated">P &amp;lt;= Xの場合、ペイロードのすべてのPバイトがオーバーフローせずにbtreeページに直接格納されます。</target>
        </trans-unit>
        <trans-unit id="a69350651a4faef3f95c007babd7352f8f77d85e" translate="yes" xml:space="preserve">
          <source>If P1 and P2 are both polygons, then the geopoly_overlap(P1,P2) function returns a non-zero integer if there is any overlap between P1 and P2, or it returns zero if P1 and P2 completely disjoint. If either P1 or P2 is not a polygon, this routine returns NULL.</source>
          <target state="translated">P1 と P2 が共に多角形である場合、geopoly_overlap(P1,P2)関数は、P1 と P2 の間に重なりがある場合には 0 以外の整数を返し、P1 と P2 が完全に不連続である場合には 0 を返します。P1 または P2 のどちらかが多角形でない場合、このルーチンは NULL を返します。</target>
        </trans-unit>
        <trans-unit id="3222b98590b837273b0d4239ca32f6bb0d30ac83" translate="yes" xml:space="preserve">
          <source>If P1 and P2 are both polygons, then the geopoly_within(P1,P2) function returns a non-zero integer if P1 is completely contained within P2, or it returns zero if any part of P1 is outside of P2. If P1 and P2 are the same polygon, this routine returns non-zero. If either P1 or P2 is not a polygon, this routine returns NULL.</source>
          <target state="translated">P1とP2が両方とも多角形である場合、geopoly_within(P1,P2)関数は、P1が完全にP2内に含まれている場合には0以外の整数を返し、P1の一部がP2の外にある場合には0を返します。P1 と P2 が同じ多角形であれば、このルーチンは 0 以外の整数を返します。P1 または P2 のどちらかが多角形でない場合、このルーチンは NULL を返します。</target>
        </trans-unit>
        <trans-unit id="dd9f5db9ef38463d2501fa9dc6b70e3f4750a4f2" translate="yes" xml:space="preserve">
          <source>If P1 and P2 are both polygons, then the geopoly_within(P1,P2) function returns a non-zero integer if P2 is completely contained within P1, or it returns zero if any part of P2 is outside of P1. If P1 and P2 are the same polygon, this routine returns non-zero. If either P1 or P2 is not a polygon, this routine returns NULL.</source>
          <target state="translated">P1とP2が両方とも多角形である場合、geopoly_within(P1,P2)関数は、P2が完全にP1内に含まれている場合は0以外の整数を返し、P2の一部がP1の外にある場合は0を返します。P1 と P2 が同じ多角形であれば、このルーチンは 0 以外の値を返します。P1 または P2 のどちらかが多角形でない場合、このルーチンは NULL を返します。</target>
        </trans-unit>
        <trans-unit id="4157b5ffd90247cfe9008c1ae67666efa84d2bdb" translate="yes" xml:space="preserve">
          <source>If P1 is 0, then all SQL statements become expired. If P1 is non-zero, then only the currently executing statement is expired.</source>
          <target state="translated">P1が0の場合、すべてのSQL文が期限切れになります。P1が0以外の場合、現在実行中のステートメントのみが期限切れとなります。</target>
        </trans-unit>
        <trans-unit id="7196e8103cc1b57f49e64f9cffafd04bf56cea94" translate="yes" xml:space="preserve">
          <source>If P1 is non-zero, then the jump is taken if the database constraint-counter is zero (the one that counts deferred constraint violations). If P1 is zero, the jump is taken if the statement constraint-counter is zero (immediate foreign key constraint violations).</source>
          <target state="translated">P1が0以外の場合、データベース制約カウンタが0の場合にジャンプが実行されます(遅延制約違反をカウントするもの)。P1が0の場合、文の制約カウンタが0の場合にジャンプが行われます(即時外部キー制約違反をカウントするもの)。</target>
        </trans-unit>
        <trans-unit id="e76da0aa98d442426a710c17ffdd5c83f500e5de" translate="yes" xml:space="preserve">
          <source>If P1 is not zero, then it is a register that a subsequent min() or max() aggregate will set to 1 if the current row is not the minimum or maximum. The P1 register is initialized to 0 by this instruction.</source>
          <target state="translated">P1が0でない場合は、現在の行が最小値または最大値でない場合、後続のmin()またはmax()の集約が1に設定するレジスタです。この命令によりP1レジスタは0に初期化されます。</target>
        </trans-unit>
        <trans-unit id="12e05de4c2b1f6e3dffb8fed2e435034a63c1753" translate="yes" xml:space="preserve">
          <source>If P2 is 0, then SQL statements are expired immediately. If P2 is 1, then running SQL statements are allowed to continue to run to completion. The P2==1 case occurs when a CREATE INDEX or similar schema change happens that might help the statement run faster but which does not affect the correctness of operation.</source>
          <target state="translated">P2が0の場合、SQL文は直ちに期限切れとなります。P2が1の場合、実行中のSQL文は完了まで実行を続けることができます。P2==1の場合は、CREATE INDEXや類似のスキーマの変更が発生した場合に発生しますが、それがステートメントの実行速度を向上させるかもしれませんが、操作の正確性には影響しません。</target>
        </trans-unit>
        <trans-unit id="b95c82eece8cdb232cd3c969e9f714560a3483ed" translate="yes" xml:space="preserve">
          <source>If P2 is not zero, jump to instruction P2.</source>
          <target state="translated">P2が0でない場合は、命令P2にジャンプします。</target>
        </trans-unit>
        <trans-unit id="624ae34f34a46b97a6ede8c6928e2854d808cc50" translate="yes" xml:space="preserve">
          <source>If P2 is not zero, then it is a register holding a string which is the file into which the result of vacuum should be written. When P2 is zero, the vacuum overwrites the original database.</source>
          <target state="translated">P2が0でない場合、それは文字列を保持するレジスタであり、バキュームの結果が書き込まれるべきファイルです。P2が0の場合、バキュームは元のデータベースを上書きします。</target>
        </trans-unit>
        <trans-unit id="7f685a86b5e506b77efdf72c9ec8070a39f8b40d" translate="yes" xml:space="preserve">
          <source>If P2 is the SCHEMA_VERSION cookie (cookie number 1) then the internal schema version is set to P3-P5. The &quot;PRAGMA schema_version=N&quot; statement has P5 set to 1, so that the internal schema version will be different from the database schema version, resulting in a schema reset.</source>
          <target state="translated">P2がSCHEMA_VERSIONクッキー(クッキー番号1)の場合、内部スキーマバージョンはP3-P5に設定されます。PRAGMA schema_version=N&quot; ステートメントは P5 を 1 に設定しているので、内部スキーマのバージョンはデータベースのスキーマのバージョンとは異なり、結果としてスキーマがリセットされます。</target>
        </trans-unit>
        <trans-unit id="4101c4124c3fe6e483990efc85814b11a364af14" translate="yes" xml:space="preserve">
          <source>If P2!=0 then the coroutine implementation immediately follows this opcode. So jump over the coroutine implementation to address P2.</source>
          <target state="translated">もしP2!=0であれば、コアーチンの実装はこのオペコードのすぐ後に続きます。そのため、P2をアドレスにするために、コアーチンの実装を飛び越えてください。</target>
        </trans-unit>
        <trans-unit id="95acd6cd81e68312a7b3f200adb71394407e2187" translate="yes" xml:space="preserve">
          <source>If P2==1 then no insert is performed. argv[0] is the rowid of a row to delete.</source>
          <target state="translated">argv[0]は削除する行の行IDです。</target>
        </trans-unit>
        <trans-unit id="4b3305a3179f27393cd2b3c6dff28468fd2e27f2" translate="yes" xml:space="preserve">
          <source>If P3 is not zero and the content of register P3 is equal to P5, then the datatype of the register P2 is converted to BLOB. The content is the same sequence of bytes, it is merely interpreted as a BLOB instead of a string, as if it had been CAST. In other words:</source>
          <target state="translated">P3が0ではなく、レジスタP3の内容がP5と等しい場合、レジスタP2のデータ型はBLOBに変換されます。内容は同じバイト列であり、文字列ではなくBLOBとして解釈されるだけで、あたかもCASTされていたかのように解釈されます。言い換えれば</target>
        </trans-unit>
        <trans-unit id="7b12a88585bcaf8799451da77eaddd8eae80e136" translate="yes" xml:space="preserve">
          <source>If P3 is not zero, then it is an address to jump to if an SQLITE_CORRUPT error is encountered.</source>
          <target state="translated">P3 がゼロでない場合は、SQLITE_CORRUPT エラーが発生した場合にジャンプするアドレスです。</target>
        </trans-unit>
        <trans-unit id="c8b8a297f15c969bf51cec7bd085ee38d68f8af2" translate="yes" xml:space="preserve">
          <source>If P3!=0 then the content of the P2 register is unsuitable for use in OP_Result and any OP_Result will invalidate the P2 register content. The P2 register content is invalidated by opcodes like &lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt; or by any use of another cursor pointing to the same table.</source>
          <target state="translated">P3！= 0の場合、P2レジスタの内容はOP_Resultでの使用には不適切であり、OP_ResultはP2レジスタの内容を無効にします。P2レジスタの内容は、&lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt;などのオペコードによって、または同じテーブルを指す別のカーソルを使用することによって無効になります。</target>
        </trans-unit>
        <trans-unit id="f0e377e900f9f81e14b13484040277f239153040" translate="yes" xml:space="preserve">
          <source>If P3!=0 then this opcode is allowed to make an ephemeral pointer into the database page. That means that the content of the output register will be invalidated as soon as the cursor moves - including moves caused by other cursors that &quot;save&quot; the current cursors position in order that they can write to the same table. If P3==0 then a copy of the data is made into memory. P3!=0 is faster, but P3==0 is safer.</source>
          <target state="translated">P3!=0の場合、このオペコードはデータベースページへのエフェメラルポインタを作ることが許されています。つまり、カーソルが移動するとすぐに出力レジスタの内容が無効になることを意味します-他のカーソルが同じテーブルに書き込むことができるように現在のカーソルの位置を「保存」する他のカーソルによる移動を含む。P3==0ならば、データのコピーがメモリに作られます。P3!=0の方が速いですが、P3==0の方が安全です。</target>
        </trans-unit>
        <trans-unit id="261dff5d4c60a753fca80ceb7a30b1ccde835d53" translate="yes" xml:space="preserve">
          <source>If P3&amp;gt;0 then P3 is a register in the root frame of this VDBE that holds the largest previously generated record number. No new record numbers are allowed to be less than this value. When this value reaches its maximum, an SQLITE_FULL error is generated. The P3 register is updated with the ' generated record number. This P3 mechanism is used to help implement the AUTOINCREMENT feature.</source>
          <target state="translated">P3&amp;gt; 0の場合、P3は、このVDBEのルートフレーム内のレジスタであり、以前に生成された最大のレコード番号を保持します。新しいレコード番号をこの値より小さくすることはできません。この値が最大値に達すると、SQLITE_FULLエラーが生成されます。P3レジスタは、生成されたレコード番号で更新されます。このP3メカニズムは、AUTOINCREMENT機能の実装を支援するために使用されます。</target>
        </trans-unit>
        <trans-unit id="b537aafa079e151774c7dbac498d69a9800ce496" translate="yes" xml:space="preserve">
          <source>If P3==0 and P4==0 then r[P2] := r[P1] IS TRUE</source>
          <target state="translated">P3==0、P4==0の場合、r[P2]:=r[P1]IS TRUEとなります。</target>
        </trans-unit>
        <trans-unit id="4abb01d048e9054de1718b2c97d7bca8f72ca3fd" translate="yes" xml:space="preserve">
          <source>If P3==0 and P4==1 then r[P2] := r[P1] IS NOT TRUE</source>
          <target state="translated">P3==0,P4==1 の場合、r[P2]:=r[P1]は真ではありません。</target>
        </trans-unit>
        <trans-unit id="dffd9f3f7dcda52e1f25f401261075e7728503f3" translate="yes" xml:space="preserve">
          <source>If P3==0, then an exact count is obtained, which involves visiting every btree page of the table. But if P3 is non-zero, an estimate is returned based on the current cursor position.</source>
          <target state="translated">P3==0であれば、テーブルのすべてのbtreeページを訪問することを含む正確なカウントが得られます。しかし、P3が0でない場合、現在のカーソル位置に基づいた推定値が返されます。</target>
        </trans-unit>
        <trans-unit id="e0f5592c3dfac53b5b17bcf906b1b3d9b28a160a" translate="yes" xml:space="preserve">
          <source>If P3==1 and P4==0 then r[P2] := r[P1] IS NOT FALSE</source>
          <target state="translated">P3==1,P4==0 の場合、r[P2]:=r[P1]は偽りではありません。</target>
        </trans-unit>
        <trans-unit id="ec92d66dd345ec321132b256dce88d1a72413c5f" translate="yes" xml:space="preserve">
          <source>If P3==1 and P4==1 then r[P2] := r[P1] IS FALSE</source>
          <target state="translated">P3==1、P4==1の場合、r[P2]:=r[P1]IS FALSEとなります。</target>
        </trans-unit>
        <trans-unit id="ec8063043e0a9cad56cc57c55e1e58a5f2b9e719" translate="yes" xml:space="preserve">
          <source>If P4 is NULL then all index fields have the affinity BLOB.</source>
          <target state="translated">P4がNULLの場合、すべてのインデックスフィールドはアフィニティBLOBを持つ。</target>
        </trans-unit>
        <trans-unit id="0409d4d0ae010acb4eb82b5c67e7d26a4e78a377" translate="yes" xml:space="preserve">
          <source>If P4 is not NULL then it points to a Table object. In this case either the update or pre-update hook, or both, may be invoked. The P1 cursor must have been positioned using &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; prior to invoking this opcode in this case. Specifically, if one is configured, the pre-update hook is invoked if P4 is not NULL. The update-hook is invoked if one is configured, P4 is not NULL, and the OPFLAG_NCHANGE flag is set in P2.</source>
          <target state="translated">P4がNULLでない場合、それはTableオブジェクトを指します。この場合、更新フックまたは更新前フックのいずれか、あるいはその両方を呼び出すことができます。この場合、このオペコードを呼び出す前に、P1カーソルが&lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt;を使用して配置されている必要があります。特に、1つが構成されている場合、P4がNULLでない場合、更新前フックが呼び出されます。update-hookは、構成されていて、P4がNULLでなく、OPFLAG_NCHANGEフラグがP2に設定されている場合に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="833039fcfc9ba1341a8bac648d6011bebc9ef640" translate="yes" xml:space="preserve">
          <source>If P4 is not null then it is an error message string.</source>
          <target state="translated">P4 が NULL でない場合は、エラーメッセージの文字列となります。</target>
        </trans-unit>
        <trans-unit id="323b07c0a29678efca20be714e85be9034012831" translate="yes" xml:space="preserve">
          <source>If P4 is not zero, then it is the number of values in the unpacked key of reg(P2). In that case, P3 is the index of the first register for the unpacked key. The availability of the unpacked key can sometimes be an optimization.</source>
          <target state="translated">P4が0でない場合は、reg(P2)のアンパックドキーの値の数である。その場合、P3は、アンパックドキーの最初のレジスタのインデックスである。アンパックされた鍵の利用可能性は、最適化されている場合もある。</target>
        </trans-unit>
        <trans-unit id="7f6b94d7be2c05fd8f0bc6b7de40e344824f8d5b" translate="yes" xml:space="preserve">
          <source>If P4==0 then register P3 holds a blob constructed by &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;. If P4&amp;gt;0 then register P3 is the first of P4 registers that form an unpacked record.</source>
          <target state="translated">P4 == 0の場合、レジスタP3は&lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;によって構築されたblobを保持します。P4&amp;gt; 0の場合、レジスタP3は、アンパックされたレコードを形成する最初のP4レジスタです。</target>
        </trans-unit>
        <trans-unit id="ea0d786e8193b3191b8e71dcd7cd40efa9daf92e" translate="yes" xml:space="preserve">
          <source>If P5 has the OPFLAG_APPEND bit set, that is a hint to the b-tree layer that this insert is likely to be an append.</source>
          <target state="translated">P5 に OPFLAG_APPEND ビットが設定されている場合、それは、この挿入が追加である可能性が高いことを b-tree レイヤに示すヒントとなります。</target>
        </trans-unit>
        <trans-unit id="b63e95392a3322ead1cda4df48bfef1df78fcfb5" translate="yes" xml:space="preserve">
          <source>If P5 has the OPFLAG_NCHANGE bit set, then the change counter is incremented by this instruction. If the OPFLAG_NCHANGE bit is clear, then the change counter is unchanged.</source>
          <target state="translated">P5 の OPFLAG_NCHANGE ビットがセットされている場合は、この命令により変更カウンタがインクリメントされます。OPFLAG_NCHANGEビットがクリアされている場合、変更カウンタは変更されません。</target>
        </trans-unit>
        <trans-unit id="1ea732c0486f9121ffc851f241dea7753a429516" translate="yes" xml:space="preserve">
          <source>If P5 has the OPFLAG_PERMUTE bit set, then the order of comparison is determined by the most recent &lt;a href=&quot;opcode#Permutation&quot;&gt;Permutation&lt;/a&gt; operator. If the OPFLAG_PERMUTE bit is clear, then register are compared in sequential order.</source>
          <target state="translated">P5にOPFLAG_PERMUTEビットが設定されている場合、比較の順序は最新の&lt;a href=&quot;opcode#Permutation&quot;&gt;置換&lt;/a&gt;演算子によって決定されます。OPFLAG_PERMUTEビットがクリアされている場合、レジスタは順番に比較されます。</target>
        </trans-unit>
        <trans-unit id="d566e20d0304652ba9b826870e3331951b73f1a1" translate="yes" xml:space="preserve">
          <source>If P5 is non-zero, then recursive program invocation is enabled.</source>
          <target state="translated">P5が0以外の場合、再帰的プログラム呼び出しが有効になります。</target>
        </trans-unit>
        <trans-unit id="8cc4989073012226802ebb0b0b0287d0ebbc4c24" translate="yes" xml:space="preserve">
          <source>If P5 is not zero and P4 is NULL, then everything after the &quot;:&quot; is omitted.</source>
          <target state="translated">P5が0ではなく、P4がNULLの場合は、&quot;:&quot;以降は省略されます。</target>
        </trans-unit>
        <trans-unit id="6140b6bc786ef6328163c583ea74afbbf1b0203f" translate="yes" xml:space="preserve">
          <source>If P5 is not zero, the check is done on the auxiliary database file, not the main database file.</source>
          <target state="translated">P5が0でない場合、チェックはメインデータベースファイルではなく、補助データベースファイルに対して行われます。</target>
        </trans-unit>
        <trans-unit id="4031180a3fa926570f402abdb205aa9088ecbac2" translate="yes" xml:space="preserve">
          <source>If P5 is not zero, then raise an SQLITE_CORRUPT_INDEX error if no matching index entry is found. This happens when running an UPDATE or DELETE statement and the index entry to be updated or deleted is not found. For some uses of &lt;a href=&quot;opcode#IdxDelete&quot;&gt;IdxDelete&lt;/a&gt; (example: the EXCEPT operator) it does not matter that no matching entry is found. For those cases, P5 is zero.</source>
          <target state="translated">If P5 is not zero, then raise an SQLITE_CORRUPT_INDEX error if no matching index entry is found. This happens when running an UPDATE or DELETE statement and the index entry to be updated or deleted is not found. For some uses of &lt;a href=&quot;opcode#IdxDelete&quot;&gt;IdxDelete&lt;/a&gt; (example: the EXCEPT operator) it does not matter that no matching entry is found. For those cases, P5 is zero.</target>
        </trans-unit>
        <trans-unit id="6f3d5e8ef0f60d316b59356518575a2f176eb4d7" translate="yes" xml:space="preserve">
          <source>If P5 is positive and the jump is taken, then event counter number P5-1 in the prepared statement is incremented.</source>
          <target state="translated">P5が正でジャンプが行われた場合には、準備された文のイベントカウンタ番号P5-1がインクリメントされる。</target>
        </trans-unit>
        <trans-unit id="e77300f272721b16413737d1f5909b28a7b7a6ee" translate="yes" xml:space="preserve">
          <source>If P5 is set, then all released registers have their type set to MEM_Undefined so that any subsequent attempt to read the released register (before it is reinitialized) will generate an assertion fault.</source>
          <target state="translated">P5 が設定されている場合、すべてのリリースされたレジスタのタイプは MEM_Undefined に設定されているため、その後にリリースされたレジスタを読み出そうとすると (再初期化される前に)アサーション・フォルトが発生します。</target>
        </trans-unit>
        <trans-unit id="6d64a234f707179617701bb23c32b6ab90539344" translate="yes" xml:space="preserve">
          <source>If P5!=0 then this opcode also checks the schema cookie against P3 and the schema generation counter against P4. The cookie changes its value whenever the database schema changes. This operation is used to detect when that the cookie has changed and that the current process needs to reread the schema. If the schema cookie in P3 differs from the schema cookie in the database header or if the schema generation counter in P4 differs from the current generation counter, then an SQLITE_SCHEMA error is raised and execution halts. The sqlite3_step() wrapper function might then reprepare the statement and rerun it from the beginning.</source>
          <target state="translated">P5!=0の場合、このオペコードはスキーマクッキーをP3と照合し、スキーマ生成カウンタをP4と照合します。データベーススキーマが変更されるたびにクッキーはその値を変更します。この操作は、クッキーが変更され、現在のプロセスがスキーマを再読み込みする必要があることを検出するために使用されます。P3のスキーマクッキーがデータベースヘッダのスキーマクッキーと異なる場合、またはP4のスキーマ生成カウンタが現在の生成カウンタと異なる場合、SQLITE_SCHEMAエラーが発生し、実行が停止します。その後、sqlite3_step()ラッパー関数は文を再準備して最初から再実行するかもしれません。</target>
        </trans-unit>
        <trans-unit id="79b8df381ad1ae2bdf21bac462376aead762296f" translate="yes" xml:space="preserve">
          <source>If RBU is used to update a large BLOB value within a target database, it may be more efficient to store a patch or delta that can be used to modify the existing BLOB instead of an entirely new value within the RBU database. RBU allows deltas to be specified in two ways:</source>
          <target state="translated">RBUがターゲットデータベース内の大きなBLOB値を更新するために使用される場合、RBUデータベース内に全く新しい値を格納するのではなく、既存のBLOBを変更するために使用できるパッチまたはデルタを格納する方が効率的である場合があります。RBUでは、デルタを2つの方法で指定することができます。</target>
        </trans-unit>
        <trans-unit id="f32404d913415ab312a2d32bca5267050dc55433" translate="yes" xml:space="preserve">
          <source>If SQLITE_DEFAULT_WAL_SYNCHRONOUS differs from SQLITE_DEFAULT_SYNCHRONOUS, and if the application has not modified the synchronous setting for the database file using the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; statement, then the synchronous setting is changed to value defined by SQLITE_DEFAULT_WAL_SYNCHRONOUS when the database connection switches into WAL mode for the first time. If the SQLITE_DEFAULT_WAL_SYNCHRONOUS value is not overridden at compile-time, then it will always be the same as &lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS&lt;/a&gt; and so no automatic synchronous setting changes will ever occur.</source>
          <target state="translated">SQLITE_DEFAULT_WAL_SYNCHRONOUSがSQLITE_DEFAULT_SYNCHRONOUSと異なり、アプリケーションが&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA同期&lt;/a&gt;ステートメントを使用してデータベースファイルの同期設定を変更していない場合、データベース接続が初めてWALモードに切り替わると、同期設定はSQLITE_DEFAULT_WAL_SYNCHRONOUSで定義された値に変更されます。 SQLITE_DEFAULT_WAL_SYNCHRONOUS値がコンパイル時にオーバーライドされない場合、常に&lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS&lt;/a&gt;と同じになるため、自動同期設定の変更は発生しません。</target>
        </trans-unit>
        <trans-unit id="35daf76480440bed2a0456819e4a2256b8e77c1e" translate="yes" xml:space="preserve">
          <source>If SQLITE_NULLEQ is set in P5 then the result of comparison is always either true or false and is never NULL. If both operands are NULL then the result of comparison is true. If either operand is NULL then the result is false. If neither operand is NULL the result is the same as it would be if the SQLITE_NULLEQ flag were omitted from P5.</source>
          <target state="translated">P5でSQLITE_NULLEQが設定されている場合、比較の結果は常に真か偽のどちらかであり、決してNULLではありません。両方のオペランドがNULLの場合、比較結果は真です。どちらか一方のオペランドがNULLの場合、結果は偽です。どちらのオペランドもNULLでない場合、結果はP5でSQLITE_NULLEQフラグが省略された場合と同じです。</target>
        </trans-unit>
        <trans-unit id="b5e1e68a469214facd1d655d6dbff18739ace55a" translate="yes" xml:space="preserve">
          <source>If SQLite discovers that the sqlite_sequence table has any other format, it returns the SQLITE_CORRUPT_SEQUENCE error.</source>
          <target state="translated">SQLiteがsqlite_sequenceテーブルが他のフォーマットを持っていることを発見した場合、SQLITE_CORRUPT_SEQUENCEエラーを返します。</target>
        </trans-unit>
        <trans-unit id="015569a0e55d69ecf2d3dec3d6ece8f0bde61846" translate="yes" xml:space="preserve">
          <source>If SQLite ever returns SQLITE_MISUSE from any interface, that means that the application is incorrectly coded and needs to be fixed. Do not ship an application that sometimes returns SQLITE_MISUSE from a standard SQLite interface because that application contains potentially serious bugs.</source>
          <target state="translated">SQLite が何らかのインターフェイスから SQLITE_MISUSE を返すことがある場合、それはそのアプリケーションが正しくコードされておらず、修正する必要があることを意味します。標準SQLiteインタフェースからSQLITE_MISUSEを返すことがあるアプリケーションを出荷しないでください。</target>
        </trans-unit>
        <trans-unit id="60b69a270887c8a40e3999f62767f4e29079be3d" translate="yes" xml:space="preserve">
          <source>If SQLite has been compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, then the parser_trace pragma can be used to turn on tracing for the SQL parser used internally by SQLite. This feature is used for debugging SQLite itself.</source>
          <target state="translated">SQLiteが&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;コンパイル時オプションでコンパイルされている場合、parser_traceプラグマを使用して、SQLiteが内部で使用するSQLパーサーのトレースをオンにすることができます。この機能は、SQLite自体のデバッグに使用されます。</target>
        </trans-unit>
        <trans-unit id="3e93855bd0fdb13d2772a4cf88fefeb516093bf0" translate="yes" xml:space="preserve">
          <source>If SQLite has been compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, then the vdbe_addoptrace pragma can be used to cause a complete VDBE opcodes to be displayed as they are created during code generation. This feature is used for debugging SQLite itself. See the &lt;a href=&quot;vdbe#trace&quot;&gt;VDBE documentation&lt;/a&gt; for more information.</source>
          <target state="translated">SQLiteが&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;コンパイル時オプションでコンパイルされている場合、vdbe_addoptraceプラグマを使用して、コード生成中に作成された完全なVDBE opcodeを表示できます。この機能は、SQLite自体のデバッグに使用されます。詳細については、&lt;a href=&quot;vdbe#trace&quot;&gt;VDBEのドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="ed1cfc408ef29e4c5084ed94c91a1453ae1e7d68" translate="yes" xml:space="preserve">
          <source>If SQLite has been compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, then the vdbe_debug pragma is a shorthand for three other debug-only pragmas: vdbe_addoptrace, vdbe_listing, and vdbe_trace. This feature is used for debugging SQLite itself. See the &lt;a href=&quot;vdbe#trace&quot;&gt;VDBE documentation&lt;/a&gt; for more information.</source>
          <target state="translated">SQLiteが&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;コンパイル時オプションでコンパイルされている場合、vdbe_debugプラグマは、他の3つのデバッグ専用プラグマ（vdbe_addoptrace、vdbe_listing、vdbe_trace）の省略形です。この機能は、SQLite自体のデバッグに使用されます。詳細については、&lt;a href=&quot;vdbe#trace&quot;&gt;VDBEのドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="1e32eb3dd2a790d29e0b70974d295922571079df" translate="yes" xml:space="preserve">
          <source>If SQLite has been compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, then the vdbe_listing pragma can be used to cause a complete listing of the virtual machine opcodes to appear on standard output as each statement is evaluated. With listing is on, the entire content of a program is printed just prior to beginning execution. The statement executes normally after the listing is printed. This feature is used for debugging SQLite itself. See the &lt;a href=&quot;vdbe#trace&quot;&gt;VDBE documentation&lt;/a&gt; for more information.</source>
          <target state="translated">SQLiteが&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;コンパイル時オプションでコンパイルされている場合、vdbe_listingプラグマを使用して、各ステートメントが評価されるときに仮想マシンのオペコードの完全なリストを標準出力に表示できます。リストがオンの場合、プログラムの内容全体が実行を開始する直前に印刷されます。リストが印刷された後、ステートメントは通常どおり実行されます。この機能は、SQLite自体のデバッグに使用されます。詳細については、&lt;a href=&quot;vdbe#trace&quot;&gt;VDBEのドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="cefc8fedb890f68ef15ff1358f045bdc3b72901b" translate="yes" xml:space="preserve">
          <source>If SQLite has been compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, then the vdbe_trace pragma can be used to cause virtual machine opcodes to be printed on standard output as they are evaluated. This feature is used for debugging SQLite. See the &lt;a href=&quot;vdbe#trace&quot;&gt;VDBE documentation&lt;/a&gt; for more information.</source>
          <target state="translated">SQLiteが&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;コンパイル時オプションでコンパイルされている場合、vdbe_traceプラグマを使用すると、仮想マシンのオペコードが評価されるときに標準出力に出力されます。この機能はSQLiteのデバッグに使用されます。詳細については、&lt;a href=&quot;vdbe#trace&quot;&gt;VDBEのドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="5153e53873f4aff61d1f8d367f68545fed69c0e7" translate="yes" xml:space="preserve">
          <source>If SQLite has not been initialized using &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; prior to invoking sqlite3_complete16() then sqlite3_initialize() is invoked automatically by sqlite3_complete16(). If that initialization fails, then the return value from sqlite3_complete16() will be non-zero regardless of whether or not the input SQL is complete.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;を使用してsqlite3_complete16（）を呼び出す前にSQLiteが初期化されていない場合、sqlite3_initialize（）はsqlite3_complete16（）によって自動的に呼び出されます。その初期化が失敗した場合、sqlite3_complete16（）からの戻り値は、入力SQLが完了しているかどうかに関係なくゼロ以外になります。</target>
        </trans-unit>
        <trans-unit id="3c965f677e7c54456f9a69dea9325df1caaec3d9" translate="yes" xml:space="preserve">
          <source>If SQLite has not been initialized using &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; prior to invoking sqlite3_complete16() then sqlite3_initialize() is invoked automatically by sqlite3_complete16(). If that initialization fails, then the return value from sqlite3_complete16() will be non-zero regardless of whether or not the input SQL is complete.</source>
          <target state="translated">&lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize（）&lt;/a&gt;を使用してsqlite3_complete16（）を呼び出す前にSQLiteが初期化されていない場合、sqlite3_initialize（）はsqlite3_complete16（）によって自動的に呼び出されます。その初期化が失敗した場合、sqlite3_complete16（）からの戻り値は、入力SQLが完了しているかどうかに関係なくゼロ以外になります。</target>
        </trans-unit>
        <trans-unit id="6d6bbb3059e334920732ba9450708b663008dcc7" translate="yes" xml:space="preserve">
          <source>If SQLite is built with the &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt; compile-time option then the syntax of the UPDATE statement is extended with optional ORDER BY and LIMIT clauses as follows:</source>
          <target state="translated">SQLiteが&lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt;コンパイル時オプションを使用して構築されている場合、UPDATEステートメントの構文は、次のようにオプションのORDER BYおよびLIMIT句で拡張されます。</target>
        </trans-unit>
        <trans-unit id="44ff2e47de1d4a52252bdf0898ff4b68826c3d7a" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled for Windows with the &lt;a href=&quot;compile#win32_malloc&quot;&gt;SQLITE_WIN32_MALLOC&lt;/a&gt; compile-time option, then a different, thin wrapper is used around HeapAlloc(), HeapReAlloc(), and HeapFree(). The thin wrapper uses the configured SQLite heap, which will be different from the default process heap if the &lt;a href=&quot;compile#win32_heap_create&quot;&gt;SQLITE_WIN32_HEAP_CREATE&lt;/a&gt; compile-time option is used. In addition, when an allocation is made or freed, HeapValidate() will be called if SQLite is compiled with assert() enabled and the &lt;a href=&quot;compile#win32_malloc_validate&quot;&gt;SQLITE_WIN32_MALLOC_VALIDATE&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLiteが&lt;a href=&quot;compile#win32_malloc&quot;&gt;SQLITE_WIN32_MALLOC&lt;/a&gt;コンパイル時オプションを使用してWindows用にコンパイルされている場合、HeapAlloc（）、HeapReAlloc（）、およびHeapFree（）の周りに別の薄いラッパーが使用されます。シンラッパーは、構成されたSQLiteヒープを使用します。これは、&lt;a href=&quot;compile#win32_heap_create&quot;&gt;SQLITE_WIN32_HEAP_CREATE&lt;/a&gt;コンパイル時オプションが使用されている場合のデフォルトのプロセスヒープとは異なります。また、assert（）を有効にして&lt;a href=&quot;compile#win32_malloc_validate&quot;&gt;SQLITE_WIN32_MALLOC_VALIDATE&lt;/a&gt;コンパイル時オプションを指定してSQLiteをコンパイルすると、割り当てが作成または解放されたときにHeapValidate（）が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="517e1af932491e30c32e06c4fd9e534300edd652" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with &lt;a href=&quot;compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt; then another zero-malloc memory allocator, similar to memsys5, is included in the source tree. The memsys3 allocator, like memsys5, must be activated by a call to &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;,...). Memsys3 uses the memory buffer supplied as its source for all memory allocations. The difference between memsys3 and memsys5 is that memsys3 uses a different memory allocation algorithm that seems to work well in practice, but which does not provide mathematical guarantees against memory fragmentation and breakdown. Memsys3 was a predecessor to memsys5. The SQLite developers now believe that memsys5 is superior to memsys3 and that all applications that need a zero-malloc memory allocator should use memsys5 in preference to memsys3. Memsys3 is considered both experimental and deprecated and will likely be removed from the source tree in a future release of SQLite.</source>
          <target state="translated">SQLiteが&lt;a href=&quot;compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3を使用して&lt;/a&gt;コンパイルされている場合、memsys5と同様に、別のゼロmallocメモリアロケーターがソースツリーに含まれます。 memsys5のようなmemsys3アロケーターは、&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;（&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;への呼び出しによってアクティブ化される必要があります。、...）。 Memsys3は、すべてのメモリ割り当てのソースとして提供されるメモリバッファを使用します。 memsys3とmemsys5の違いは、memsys3は実際にはうまく機能しているように見えるメモリ割り当てアルゴリズムを使用しているが、これはメモリの断片化と破壊に対する数学的保証を提供しないことです。 Memsys3はmemsys5の前身でした。 SQLite開発者は、memsys5がmemsys3より優れていること、およびゼロmallocメモリーアロケーターを必要とするすべてのアプリケーションがmemsys3よりもmemsys5を使用する必要があると信じています。 Memsys3は実験的で非推奨とみなされており、SQLiteの将来のリリースでソースツリーから削除される可能性があります。</target>
        </trans-unit>
        <trans-unit id="a20ff9c15584045a4ca98d16d24d41c5ba218767" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt; compile-time option, then the syntax of the DELETE statement is extended by the addition of optional ORDER BY and LIMIT clauses:</source>
          <target state="translated">SQLiteが&lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt;コンパイル時オプションでコンパイルされている場合、DELETEステートメントの構文は、オプションのORDER BY句とLIMIT句の追加によって拡張されます。</target>
        </trans-unit>
        <trans-unit id="0e66b56024c7560826b0783e73206c696c2fa3db" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; compile-time option, then a different, heavy wrapper is used around system malloc(), realloc(), and free(). The heavy wrapper allocates around 100 bytes of extra space with each allocation. The extra space is used to place sentinel values at both ends of the allocation returned to the SQLite core. When an allocation is freed, these sentinels are checked to make sure the SQLite core did not overrun the buffer in either direction. When the system library is GLIBC, the heavy wrapper also makes use of the GNU backtrace() function to examine the stack and record the ancestor functions of the malloc() call. When running the SQLite test suite, the heavy wrapper also records the name of the current test case. These latter two features are useful for tracking down the source of memory leaks detected by the test suite.</source>
          <target state="translated">SQLiteが&lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUGで&lt;/a&gt;コンパイルされている場合コンパイル時オプションの場合、システムのmalloc（）、realloc（）、およびfree（）の周りに別の重いラッパーが使用されます。重いラッパーは、割り当てごとに約100バイトの追加スペースを割り当てます。余分なスペースは、SQLiteコアに返される割り当ての両端にセンチネル値を配置するために使用されます。割り当てが解放されると、これらの標識がチェックされ、SQLiteコアがどちらの方向にもバッファーをオーバーランしなかったことを確認します。システムライブラリがGLIBCの場合、重いラッパーは、GNU backtrace（）関数を使用してスタックを調べ、malloc（）呼び出しの祖先関数を記録します。 SQLiteテストスイートを実行すると、ヘビーラッパーは現在のテストケースの名前も記録します。後者の2つの機能は、テストスイートによって検出されたメモリリークの原因を追跡するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="bdb5f255b340a7c8ea5f9ec1a27271eaa4afef49" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the &lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC&lt;/a&gt; option, then the &lt;a href=&quot;malloc#defaultalloc&quot;&gt;default memory allocator&lt;/a&gt; is omitted and replaced by a stub memory allocator that never allocates any memory. Any calls to the stub memory allocator will report back that no memory is available.</source>
          <target state="translated">SQLiteが&lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC&lt;/a&gt;オプションを指定してコンパイルされている場合、&lt;a href=&quot;malloc#defaultalloc&quot;&gt;デフォルトのメモリアロケータ&lt;/a&gt;は省略され、メモリを割り当てないスタブメモリアロケータに置き換えられます。スタブメモリアロケータを呼び出すと、使用可能なメモリがないことが報告されます。</target>
        </trans-unit>
        <trans-unit id="a81969949fdea82f85b5652d9dfeed54c87f7d37" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the SQLITE_MUTEX_APPDEF preprocessor macro defined (with &quot;-DSQLITE_MUTEX_APPDEF=1&quot;), then no mutex implementation is included with the library. In this case the application must supply a custom mutex implementation using the &lt;a href=&quot;#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; option of the sqlite3_config() function before calling sqlite3_initialize() or any other public sqlite3_ function that calls sqlite3_initialize().</source>
          <target state="translated">SQLiteがSQLITE_MUTEX_APPDEFプリプロセッサマクロを定義してコンパイルされている場合（ &quot;-DSQLITE_MUTEX_APPDEF = 1&quot;を使用）、ライブラリにはミューテックス実装が含まれていません。この場合、アプリケーションは、sqlite3_initialize（）またはsqlite3_initialize（）を呼び出す他のパブリックsqlite3_関数を呼び出す前に、sqlite3_config（）関数の&lt;a href=&quot;#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt;オプションを使用してカスタムmutex実装を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="3612fbeb4e5912d3519c058afb830d2ca96819e8" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the SQLITE_MUTEX_APPDEF preprocessor macro defined (with &quot;-DSQLITE_MUTEX_APPDEF=1&quot;), then no mutex implementation is included with the library. In this case the application must supply a custom mutex implementation using the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; option of the sqlite3_config() function before calling sqlite3_initialize() or any other public sqlite3_ function that calls sqlite3_initialize().</source>
          <target state="translated">SQLiteがSQLITE_MUTEX_APPDEFプリプロセッサマクロを定義してコンパイルされている場合（ &quot;-DSQLITE_MUTEX_APPDEF = 1&quot;を使用）、ライブラリにはミューテックス実装が含まれていません。この場合、アプリケーションは、sqlite3_initialize（）またはsqlite3_initialize（）を呼び出す他のパブリックsqlite3_関数を呼び出す前に、sqlite3_config（）関数の&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt;オプションを使用してカスタムmutex実装を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="3e4d7ea4d24bcad6503f112a75cb8cf3b594762c" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the THREADSAFE preprocessor macro set to 1, then it is safe to use SQLite from two or more threads of the same process at the same time. But each thread should have its own &lt;b&gt;sqlite*&lt;/b&gt; pointer returned from &lt;b&gt;sqlite_open&lt;/b&gt;. It is never safe for two or more threads to access the same &lt;b&gt;sqlite*&lt;/b&gt; pointer at the same time.</source>
          <target state="translated">SQLiteがTHREADSAFEプリプロセッサマクロを1に設定してコンパイルされている場合、同じプロセスの2つ以上のスレッドから同時にSQLiteを使用しても安全です。ただし、各スレッドには、&lt;b&gt;sqlite_open&lt;/b&gt;から返される独自の&lt;b&gt;sqlite *&lt;/b&gt;ポインターが&lt;b&gt;必要&lt;/b&gt;です。 2つ以上のスレッドが同じ&lt;b&gt;sqlite *&lt;/b&gt;ポインターに同時にアクセスすることは決して安全ではありません。</target>
        </trans-unit>
        <trans-unit id="710dfc358000c04c6f29b5a8b9d1e58f09170c01" translate="yes" xml:space="preserve">
          <source>If SQLite is working with multiple databases at the same time (using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command) then each database has its own rollback journal. But there is also a separate aggregate journal called the &lt;em&gt;master journal&lt;/em&gt;. The master journal does not contain page data used for rolling back changes. Instead the master journal contains the names of the individual database rollback journals for each of the ATTACHed databases. Each of the individual database rollback journals also contain the name of the master journal. If there are no ATTACHed databases (or if none of the ATTACHed database is participating in the current transaction) no master journal is created and the normal rollback journal contains an empty string in the place normally reserved for recording the name of the master journal.</source>
          <target state="translated">SQLiteが複数のデータベースを同時に操作している場合（&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;コマンドを使用）、各データベースには独自のロールバックジャーナルがあります。ただし、&lt;em&gt;マスタージャーナル&lt;/em&gt;と呼ばれる別の集約ジャーナルもあります。マスタージャーナルには、変更のロールバックに使用されるページデータは含まれていません。代わりに、マスタージャーナルには、アタッチされた各データベースの個々のデータベースロールバックジャーナルの名前が含まれています。個々のデータベースのロールバックジャーナルにはそれぞれ、マスタージャーナルの名前も含まれています。 ATTACHされたデータベースがない場合（またはATTACHされたデータベースが現在のトランザクションに参加していない場合）は、マスタージャーナルは作成されず、通常のロールバックジャーナルには、マスタージャーナルの名前を記録するために通常予約されている場所に空の文字列が含まれます。</target>
        </trans-unit>
        <trans-unit id="e3d682297850435cbed4a4f23333530d1946cfd2" translate="yes" xml:space="preserve">
          <source>If SQLite is working with multiple databases at the same time (using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command) then each database has its own rollback journal. But there is also a separate aggregate journal called the &lt;em&gt;super-journal&lt;/em&gt;. The super-journal does not contain page data used for rolling back changes. Instead the super-journal contains the names of the individual database rollback journals for each of the ATTACHed databases. Each of the individual database rollback journals also contain the name of the super-journal. If there are no ATTACHed databases (or if none of the ATTACHed database is participating in the current transaction) no super-journal is created and the normal rollback journal contains an empty string in the place normally reserved for recording the name of the super-journal.</source>
          <target state="translated">If SQLite is working with multiple databases at the same time (using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command) then each database has its own rollback journal. But there is also a separate aggregate journal called the &lt;em&gt;super-journal&lt;/em&gt;. The super-journal does not contain page data used for rolling back changes. Instead the super-journal contains the names of the individual database rollback journals for each of the ATTACHed databases. Each of the individual database rollback journals also contain the name of the super-journal. If there are no ATTACHed databases (or if none of the ATTACHed database is participating in the current transaction) no super-journal is created and the normal rollback journal contains an empty string in the place normally reserved for recording the name of the super-journal.</target>
        </trans-unit>
        <trans-unit id="5896c61835dd6f9792c99d8e8f334dcf5e7f29e5" translate="yes" xml:space="preserve">
          <source>If SQLite needs a page-cache entry that is larger than &quot;sz&quot; bytes or if it needs more than N entries, it falls back to using the general-purpose memory allocator.</source>
          <target state="translated">SQLite では、&quot;sz&quot; バイトよりも大きなページキャッシュエントリが必要な場合や、N 個以上のエントリが必要な場合は、汎用メモリアロケータを使用することになります。</target>
        </trans-unit>
        <trans-unit id="4aa68767277ee1001967243f3227f1d8f761e4eb" translate="yes" xml:space="preserve">
          <source>If SQLite recognizes a table as a shadow table, and if the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; flag is set, then the shadow table is read-only for ordinary SQL statements. The shadow table can still be written, but only by SQL that is invoked from within one of the methods of some virtual table implementation.</source>
          <target state="translated">SQLiteがテーブルをシャドウテーブルとして認識し、&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt;フラグが設定されている場合、シャドウテーブルは通常のSQLステートメントでは読み取り専用です。シャドウテーブルは引き続き書き込み可能ですが、一部の仮想テーブル実装のメソッドの1つから呼び出されるSQLによってのみ書き込まれます。</target>
        </trans-unit>
        <trans-unit id="c334cbe953204cf334f3f0300d4576308ac4cfdc" translate="yes" xml:space="preserve">
          <source>If URI filenames are recognized when the database connection is originally opened, then URI filenames will also be recognized on &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statements. Similarly, if URI filenames are not recognized when the database connection is first opened, they will not be recognized by &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;.</source>
          <target state="translated">データベース接続が最初に開かれたときにURIファイル名が認識される場合、URIファイル名も&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;ステートメントで認識されます。同様に、データベース接続が最初に開かれたときにURIファイル名が認識されない場合、それらは&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;によって認識されません。</target>
        </trans-unit>
        <trans-unit id="20f2ccdd4e7b5b66dd50ba0f757be7113d0c9526" translate="yes" xml:space="preserve">
          <source>If W is AND-connected terms and X is OR-connected terms and if any term of W appears as a term of X, then the partial index is usable.</source>
          <target state="translated">WがAND連結項、XがOR連結項であり、Wの項がXの項として現れる場合、部分インデックスは使用可能である。</target>
        </trans-unit>
        <trans-unit id="5ee5624c5ac84e77c145fe142470f12976a4d91a" translate="yes" xml:space="preserve">
          <source>If X is a memory allocation previously obtained from sqlite3_malloc(), sqlite3_malloc64(), sqlite3_realloc(), or sqlite3_realloc64(), then sqlite3_msize(X) returns the size of that memory allocation in bytes. The value returned by sqlite3_msize(X) might be larger than the number of bytes requested when X was allocated. If X is a NULL pointer then sqlite3_msize(X) returns zero. If X points to something that is not the beginning of memory allocation, or if it points to a formerly valid memory allocation that has now been freed, then the behavior of sqlite3_msize(X) is undefined and possibly harmful.</source>
          <target state="translated">Xが以前にsqlite3_malloc(),sqlite3_malloc64(),sqlite3_realloc(),sqlite3_realloc64()で取得したメモリ割り当てであれば、sqlite3_msize(X)はそのメモリ割り当てのサイズをバイト単位で返します。sqlite3_msize(X)が返す値は、Xが割り当てられたときに要求されたバイト数よりも大きいかもしれません。XがNULLポインタの場合、sqlite3_msize(X)は0を返します。Xがメモリ割り当ての最初ではないものを指していたり、以前に有効だったメモリ割り当てが解放されたものを指している場合、sqlite3_msize(X)の動作は未定義であり、有害な可能性があります。</target>
        </trans-unit>
        <trans-unit id="b1b66964d31ddb28c71bf027a0d38468bda02bb0" translate="yes" xml:space="preserve">
          <source>If X is greater than or equal to zero, go back to step 3.</source>
          <target state="translated">Xが0以上の場合は、ステップ3に戻ります。</target>
        </trans-unit>
        <trans-unit id="b3fb68847c867d6e5aec8b5513dabb7e57278079" translate="yes" xml:space="preserve">
          <source>If X is non-zero, then the virtual table implementation guarantees that if &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; returns &lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, it will do so before any modifications to internal or persistent data structures have been made. If the &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode is ABORT, FAIL, IGNORE or ROLLBACK, SQLite is able to roll back a statement or database transaction, and abandon or continue processing the current SQL statement as appropriate. If the ON CONFLICT mode is REPLACE and the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method returns &lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, SQLite handles this as if the ON CONFLICT mode had been ABORT.</source>
          <target state="translated">Xがゼロ以外の場合、仮想テーブルの実装は、&lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;が&lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINTを&lt;/a&gt;返す場合、内部または永続データ構造に変更が加えられる前にそれを行うことを保証します。場合は&lt;a href=&quot;../lang_conflict&quot;&gt;ON競合&lt;/a&gt;モードは、ABORT、FAIL、IGNOREまたはROLLBACKで、SQLiteは文またはデータベーストランザクションをロールバックすることができ、かつ放棄または必要に応じて、現在のSQL文の処理を継続します。 ON CONFLICTモードがREPLACEであり、&lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;メソッドが&lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINTを&lt;/a&gt;返す場合、SQLiteはON CONFLICTモードがABORTであるかのように処理します。</target>
        </trans-unit>
        <trans-unit id="c0b29678a870c29e379cb0f8c76e93d5c6f694fd" translate="yes" xml:space="preserve">
          <source>If X is non-zero, then the virtual table implementation guarantees that if &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, it will do so before any modifications to internal or persistent data structures have been made. If the &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode is ABORT, FAIL, IGNORE or ROLLBACK, SQLite is able to roll back a statement or database transaction, and abandon or continue processing the current SQL statement as appropriate. If the ON CONFLICT mode is REPLACE and the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, SQLite handles this as if the ON CONFLICT mode had been ABORT.</source>
          <target state="translated">Xがゼロ以外の場合、仮想テーブルの実装は、&lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;が&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINTを&lt;/a&gt;返す場合、内部または永続データ構造に変更が加えられる前にそれを行うことを保証します。場合は&lt;a href=&quot;lang_conflict&quot;&gt;ON競合&lt;/a&gt;モードは、ABORT、FAIL、IGNOREまたはROLLBACKで、SQLiteは文またはデータベーストランザクションをロールバックすることができ、かつ放棄または必要に応じて、現在のSQL文の処理を継続します。 ON CONFLICTモードがREPLACEであり、&lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt;メソッドが&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINTを&lt;/a&gt;返す場合、SQLiteはON CONFLICTモードがABORTであるかのように処理します。</target>
        </trans-unit>
        <trans-unit id="30772a96ac944f5d807fde7afed09facbb4c72a3" translate="yes" xml:space="preserve">
          <source>If X is the name of a rollback or WAL-mode journal file that is passed into the xOpen method of &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;, then sqlite3_database_file_object(X) returns a pointer to the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object that represents the main database file.</source>
          <target state="translated">If X is the name of a rollback or WAL-mode journal file that is passed into the xOpen method of &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;, then sqlite3_database_file_object(X) returns a pointer to the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object that represents the main database file.</target>
        </trans-unit>
        <trans-unit id="90405f680f9fd6c0b9fd6e8fd54aba076154778a" translate="yes" xml:space="preserve">
          <source>If X starts a transaction that will initially only read but X knows it will eventually want to write and does not want to be troubled with possible SQLITE_BUSY_SNAPSHOT errors that arise because another connection jumped ahead of it in line, then X can issue &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; to start its transaction instead of just an ordinary BEGIN. The &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; command goes ahead and starts a write transaction, and thus blocks all other writers. If the &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; operation succeeds, then no subsequent operations in that transaction will ever fail with an &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error.</source>
          <target state="translated">Xが最初は読み取りのみのトランザクションを開始するが、Xが最終的に書き込みを行い、別の接続がその行の前にジャンプしたために発生する可能性のあるSQLITE_BUSY_SNAPSHOTエラーに悩まされないことを知っている場合、Xは&lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt;を発行して開始できます。通常のBEGINではなく、そのトランザクション。&lt;a href=&quot;lang_transaction#immediate&quot;&gt;IMMEDIATE BEGIN&lt;/a&gt;コマンドは、すべての他の作家を強行し、ライト・トランザクションを開始し、これによりブロック。&lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt;操作が成功した場合、そのトランザクションの後続の操作が&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;エラーで失敗することはありません。</target>
        </trans-unit>
        <trans-unit id="0eea241e4d0bdc37c50e93c325fbb23bd791a257" translate="yes" xml:space="preserve">
          <source>If a &quot;*&quot; character follows a string within an FTS expression, then the final token extracted from the string is marked as a &lt;b&gt;prefix token&lt;/b&gt;. As you might expect, a prefix token matches any document token of which it is a prefix. For example, the first two queries in the following block will match any document that contains the token &quot;one&quot; immediately followed by the token &quot;two&quot; and then any token that begins with &quot;thr&quot;.</source>
          <target state="translated">「*」文字がFTS式内の文字列に続く場合、文字列から抽出された最後のトークンは、&lt;b&gt;プレフィックストークン&lt;/b&gt;としてマークされ&lt;b&gt;ます&lt;/b&gt;。ご想像のとおり、接頭辞トークンは、それが接頭辞であるドキュメントトークンと一致します。たとえば、次のブロックの最初の2つのクエリは、トークン「1」の直後にトークン「2」が続き、次に「thr」で始まるトークンを含むすべてのドキュメントに一致します。</target>
        </trans-unit>
        <trans-unit id="3fc71a5654e7dbcda099553445308929a409041e" translate="yes" xml:space="preserve">
          <source>If a &quot;DROP TABLE&quot; or &quot;DROP INDEX&quot; SQL command is executed, and the same database connection currently has one or more actively executing SELECT statements, then SQLITE_LOCKED is returned. If &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; is called in this case, then the specified callback will be invoked immediately. Re-attempting the &quot;DROP TABLE&quot; or &quot;DROP INDEX&quot; statement will return another SQLITE_LOCKED error. In the implementation of sqlite3_blocking_step() shown to the left, this could cause an infinite loop.</source>
          <target state="translated">「DROP TABLE」または「DROP INDEX」SQLコマンドが実行され、同じデータベース接続に現在1つ以上のアクティブに実行されているSELECTステートメントがある場合、SQLITE_LOCKEDが返されます。この場合、&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify（）&lt;/a&gt;が呼び出されると、指定されたコールバックがすぐに呼び出されます。 「DROP TABLE」または「DROP INDEX」ステートメントを再試行すると、別のSQLITE_LOCKEDエラーが返されます。左に示すsqlite3_blocking_step（）の実装では、これにより無限ループが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="12bc34a5236123febe1cd1188da174890c26f97b" translate="yes" xml:space="preserve">
          <source>If a &quot;^&quot; character appears immediately before a phrase that is not part of a NEAR query, then that phrase only matches a document only if it starts at the first token in a column. The &quot;^&quot; syntax may be combined with a &lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;column filter&lt;/a&gt;, but may not be inserted into the middle of a phrase.</source>
          <target state="translated">「^」文字がNEARクエリの一部ではないフレーズの直前にある場合、そのフレーズは、列の最初のトークンで始まる場合にのみドキュメントと一致します。 「^」構文は&lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;列フィルター&lt;/a&gt;と組み合わせることができますが、フレーズの途中に挿入することはできません。</target>
        </trans-unit>
        <trans-unit id="73147d85cef7d3f5b1649d52c7fae3bdc6d30054" translate="yes" xml:space="preserve">
          <source>If a &quot;create file&quot; operation is executed by SQLite, and then the created file</source>
          <target state="translated">SQLiteで「ファイルの作成」操作が実行され、作成されたファイルが</target>
        </trans-unit>
        <trans-unit id="84d99b586ac4808874504752037c1f68b1dc681c" translate="yes" xml:space="preserve">
          <source>If a &quot;truncate file&quot; operation is executed by SQLite, and then the truncated file</source>
          <target state="translated">SQLiteで「ファイルを切り捨てる」操作が実行され、切り捨てられたファイルが</target>
        </trans-unit>
        <trans-unit id="a177cd3b97251df1bda061d91a729d6e25be393e" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../wal#walfile&quot;&gt;WAL file&lt;/a&gt; remains on disk after all database connections close (either through the use of the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;file control&lt;/a&gt; or because the last process to have the database opened exited without calling &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt;) and a new connection is subsequently opened on that database and &lt;a href=&quot;../wal#walfile&quot;&gt;WAL file&lt;/a&gt;, the &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface will only be able to open the last transaction added to the WAL file even though the WAL file contains other valid transactions.</source>
          <target state="translated">場合&lt;a href=&quot;../wal#walfile&quot;&gt;WALファイル&lt;/a&gt;をすべて閉じデータベース接続後にディスク上に残っている（いずれかを使用して&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WALの&lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;ファイル制御&lt;/a&gt;データベースを持っているか、最後のプロセス理由を呼び出さずに終了した開かれた&lt;a href=&quot;close&quot;&gt;sqlite3_close（）&lt;/a&gt;と新しい接続を）、その後、そのデータベースに開かれ、&lt;a href=&quot;../wal#walfile&quot;&gt;WALファイル&lt;/a&gt;、&lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open（）&lt;/a&gt;インターフェースは、WALファイルに他の有効なトランザクションが含まれている場合でも、WALファイルに追加された最後のトランザクションのみを開くことができます。</target>
        </trans-unit>
        <trans-unit id="ce5e78d94d5947b9e328c1516e3f265b0f48637a" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; is generated from &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; then the statement is automatically re-prepared if the schema changes, up to &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; times (default: 50). The &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface will only return SQLITE_SCHEMA back to the application if the failure persists after these many retries.</source>
          <target state="translated">場合&lt;a href=&quot;c3ref/stmt&quot;&gt;プリペアドステートメントを&lt;/a&gt;から生成される&lt;a href=&quot;c3ref/prepare&quot;&gt;（sqlite3_prepare_v2） &lt;/a&gt;、その後の文は、スキーマの変更、までの場合は再作成し、自動的にある&lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRYの&lt;/a&gt;時間（デフォルト：50）。&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step（）&lt;/a&gt;障害解決しない場合は、インタフェースのみ、これらの多くの再試行後にアプリケーションにSQLITE_SCHEMAバックを返します。</target>
        </trans-unit>
        <trans-unit id="3249186023e31b2ef81a917670edb42184c4e1e6" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; operation occurs on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; as a pending read or write, then the pending read or write may fail with an SQLITE_ABORT or &lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt; error.</source>
          <target state="translated">場合&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACKの&lt;/a&gt;動作は同じで発生する&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;保留中の読取りまたは書込みのような、その後ペンディング読み取りまたは書き込みがSQLITE_ABORTまたはで失敗することがあり&lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACKの&lt;/a&gt;エラー。</target>
        </trans-unit>
        <trans-unit id="a092e1c1463db0502720c4f04f6df73156ddbd46" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;wal#walfile&quot;&gt;WAL file&lt;/a&gt; remains on disk after all database connections close (either through the use of the &lt;a href=&quot;#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;file control&lt;/a&gt; or because the last process to have the database opened exited without calling &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt;) and a new connection is subsequently opened on that database and &lt;a href=&quot;wal#walfile&quot;&gt;WAL file&lt;/a&gt;, the &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface will only be able to open the last transaction added to the WAL file even though the WAL file contains other valid transactions.</source>
          <target state="translated">場合&lt;a href=&quot;wal#walfile&quot;&gt;WALファイル&lt;/a&gt;をすべて閉じデータベース接続後にディスク上に残っている（いずれかを使用して&lt;a href=&quot;#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WALの&lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;ファイル制御&lt;/a&gt;データベースを持っているか、最後のプロセス理由を呼び出さずに終了した開かれた&lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close（）&lt;/a&gt;と新しい接続を）、その後、そのデータベースに開かれ、&lt;a href=&quot;wal#walfile&quot;&gt;WALファイル&lt;/a&gt;、&lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open（）&lt;/a&gt;インターフェースは、WALファイルに他の有効なトランザクションが含まれている場合でも、WALファイルに追加された最後のトランザクションのみを開くことができます。</target>
        </trans-unit>
        <trans-unit id="fa0658f406309a7c36c783a199e98aa7bfe2c3be" translate="yes" xml:space="preserve">
          <source>If a BEFORE UPDATE or BEFORE DELETE trigger modifies or deletes a row that was to have been updated or deleted, then the result of the subsequent update or delete operation is undefined. Furthermore, if a BEFORE trigger modifies or deletes a row, then it is undefined whether or not AFTER triggers that would have otherwise run on those rows will in fact run.</source>
          <target state="translated">BEFORE UPDATE または BEFORE DELETE トリガが更新または削除されるはずの行を変更または削除した場合、その後の更新または削除操作の結果は未定義です。さらに、BEFORE トリガが行を変更または削除する場合、それらの行で実行されるはずの AFTER トリガが実際に実行されるかどうかは未定義です。</target>
        </trans-unit>
        <trans-unit id="a3ab52a71f2c1fab71f9f4f7d4dd870ab7b02c55" translate="yes" xml:space="preserve">
          <source>If a COMMIT statement (or the RELEASE of a transaction SAVEPOINT) fails because the database is currently in a state that violates a deferred foreign key constraint and there are currently &lt;a href=&quot;lang_savepoint&quot;&gt;nested savepoints&lt;/a&gt;, the nested savepoints remain open.</source>
          <target state="translated">データベースが延期外部キー制約に違反して現在がある状態で、現在あるため、ステートメント（またはトランザクションのSAVEPOINTのRELEASE）が失敗した場合は、COMMIT &lt;a href=&quot;lang_savepoint&quot;&gt;、ネストされたセーブポイントは&lt;/a&gt;、ネストされたセーブポイントは開いたまま。</target>
        </trans-unit>
        <trans-unit id="4862567128635ae0bf91b3eee8827f7e081e0187" translate="yes" xml:space="preserve">
          <source>If a DELETE statement has a LIMIT clause, the maximum number of rows that will be deleted is found by evaluating the accompanying expression and casting it to an integer value. If the result of the evaluating the LIMIT clause cannot be losslessly converted to an integer value, it is an error. A negative LIMIT value is interpreted as &quot;no limit&quot;. If the DELETE statement also has an OFFSET clause, then it is similarly evaluated and cast to an integer value. Again, it is an error if the value cannot be losslessly converted to an integer. If there is no OFFSET clause, or the calculated integer value is negative, the effective OFFSET value is zero.</source>
          <target state="translated">DELETE文にLIMIT句がある場合、削除される行の最大数は、付随する式を評価して整数値にキャストすることで求められます。LIMIT句の評価結果が整数値にロスレスに変換できない場合は、エラーとなります。負のLIMIT値は「制限なし」と解釈されます。DELETE文にOFFSET句がある場合、同様に評価され、整数値にキャストされます。ここでも、値を可逆的に整数に変換できない場合はエラーとなります。OFFSET句がない場合、または計算された整数値が負の場合、有効なOFFSET値はゼロになります。</target>
        </trans-unit>
        <trans-unit id="a8ebe41fb4265f7abee56db5ee7b5c4f78f4ea2f" translate="yes" xml:space="preserve">
          <source>If a FILTER clause is provided, then only rows for which the</source>
          <target state="translated">FILTER句が指定されている場合、その行の中で</target>
        </trans-unit>
        <trans-unit id="94816fac33b04eac89bfe331f82f9493ef356c93" translate="yes" xml:space="preserve">
          <source>If a FROM clause is specified, the data on which a simple SELECT query operates comes from the one or more tables or subqueries (SELECT statements in parentheses) specified following the FROM keyword. A subquery specified in the table-or-subquery following the FROM clause in a simple SELECT statement is handled as if it was a table containing the data returned by executing the subquery statement. Each column of the subquery has the &lt;a href=&quot;datatype3#collation&quot;&gt;collation sequence&lt;/a&gt; and &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt; of the corresponding expression in the subquery statement.</source>
          <target state="translated">FROM句が指定されている場合、単純なSELECTクエリの対象となるデータは、FROMキーワードの後に​​指定された1つ以上のテーブルまたはサブクエリ（括弧内のSELECTステートメント）から取得されます。単純なSELECTステートメントのFROM句に続くtable-or-subqueryで指定されたサブクエリは、サブクエリステートメントを実行して返されたデータを含むテーブルであるかのように処理されます。サブクエリの各列には、サブクエリステートメントの対応する式の&lt;a href=&quot;datatype3#collation&quot;&gt;照合順序&lt;/a&gt;と&lt;a href=&quot;datatype3#affinity&quot;&gt;類似性&lt;/a&gt;があります。</target>
        </trans-unit>
        <trans-unit id="257e2a863a3526135a72b7350cb70ec4620d0ce5" translate="yes" xml:space="preserve">
          <source>If a HAVING clause is specified, it is evaluated once for each group of rows as a &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt;. If the result of evaluating the HAVING clause is false, the group is discarded. If the HAVING clause is an aggregate expression, it is evaluated across all rows in the group. If a HAVING clause is a non-aggregate expression, it is evaluated with respect to an arbitrarily selected row from the group. The HAVING expression may refer to values, even aggregate functions, that are not in the result.</source>
          <target state="translated">HAVING句を指定すると、行のグループごとに&lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;ブール式&lt;/a&gt;として1回評価されます。 HAVING句の評価結果がfalseの場合、グループは破棄されます。 HAVING句が集計式の場合、グループ内のすべての行にわたって評価されます。 HAVING句が非集計式である場合、グループから任意に選択された行に対して評価されます。 HAVING式は、結果に含まれていない値（集約関数でさえ）を参照する場合があります。</target>
        </trans-unit>
        <trans-unit id="30445e74b001ab802719baf4ad36071ade7519f0" translate="yes" xml:space="preserve">
          <source>If a LIMIT clause is present, it might be possible to avoid scanning the entire table.</source>
          <target state="translated">LIMIT句がある場合は、テーブル全体をスキャンしないようにすることができるかもしれません。</target>
        </trans-unit>
        <trans-unit id="948b4ac14d2baa3362d0ca28f059b73564c6f3e7" translate="yes" xml:space="preserve">
          <source>If a Linux &lt;a href=&quot;http://en.wikipedia.org/wiki/Ext3&quot;&gt;ext3&lt;/a&gt; filesystem is mounted without the &quot;barrier=1&quot; option in the &lt;a href=&quot;http://en.wikipedia.org/wiki/fstab&quot;&gt;/etc/fstab&lt;/a&gt; and the disk drive write cache is enabled then filesystem corruption can occur following a power loss or OS crash. Whether or not corruption can occur depends on the details of the disk control hardware; corruption is more likely with inexpensive consumer-grade disks and less of a problem for enterprise-class storage devices with advanced features such as non-volatile write caches. Various ext3 experts &lt;a href=&quot;http://www.redhat.com/archives/ext3-users/2010-July/msg00001.html&quot;&gt; confirm this behavior&lt;/a&gt;. We are told that most Linux distributions do not use barrier=1 and do not disable the write cache so most Linux distributions are vulnerable to this problem. Note that this is an operating system and hardware issue and that there is nothing that SQLite can do to work around it. &lt;a href=&quot;http://ozlabs.org/~rusty/index.cgi/tech/2009-10-20.html&quot;&gt; Other database engines&lt;/a&gt; have also run into this same problem.</source>
          <target state="translated">Linux &lt;a href=&quot;http://en.wikipedia.org/wiki/Ext3&quot;&gt;ext3&lt;/a&gt;ファイルシステムが&lt;a href=&quot;http://en.wikipedia.org/wiki/fstab&quot;&gt;/ etc / fstab&lt;/a&gt;の「barrier = 1」オプションなしでマウントされており、ディスクドライブの書き込みキャッシュが有効になっている場合、停電またはOSのクラッシュ後にファイルシステムの破損が発生する可能性があります。破損が発生するかどうかは、ディスク制御ハードウェアの詳細によって異なります。破損は、安価なコンシューマーグレードのディスクで発生する可能性が高く、不揮発性書き込みキャッシュなどの高度な機能を備えたエンタープライズクラスのストレージデバイスでは問題が少ないです。さまざまなext3エキスパートが&lt;a href=&quot;http://www.redhat.com/archives/ext3-users/2010-July/msg00001.html&quot;&gt;この動作を確認します&lt;/a&gt;。ほとんどのLinuxディストリビューションはバリア= 1を使用せず、書き込みキャッシュを無効にしないため、ほとんどのLinuxディストリビューションはこの問題に対して脆弱です。これはオペレーティングシステムとハードウェアの問題であり、SQLiteがそれを回避するためにできることは何もないことに注意してください。&lt;a href=&quot;http://ozlabs.org/~rusty/index.cgi/tech/2009-10-20.html&quot;&gt;他のデータベースエンジンで&lt;/a&gt;もこの同じ問題が発生しています。</target>
        </trans-unit>
        <trans-unit id="99b0a8e8602a0a06983153315092cfd9796ad41e" translate="yes" xml:space="preserve">
          <source>If a NOT NULL constraint is specified, then the column must have a default value other than NULL.</source>
          <target state="translated">NOT NULL 制約が指定された場合、列は NULL 以外のデフォルト値を持つ必要があります。</target>
        </trans-unit>
        <trans-unit id="55be5a331b8cf28f9f746d3f7eb6341aa17eff02" translate="yes" xml:space="preserve">
          <source>If a SELECT query contains an ORDER BY, GROUP BY or DISTINCT clause, SQLite may need to use a temporary b-tree structure to sort the output rows. Or, it might &lt;a href=&quot;queryplanner#sorting&quot;&gt;use an index&lt;/a&gt;. Using an index is almost always much more efficient than performing a sort. If a temporary b-tree is required, a record is added to the EXPLAIN QUERY PLAN output with the &quot;detail&quot; field set to a string value of the form &quot;USE TEMP B-TREE FOR xxx&quot;, where xxx is one of &quot;ORDER BY&quot;, &quot;GROUP BY&quot; or &quot;DISTINCT&quot;. For example:</source>
          <target state="translated">SELECTクエリにORDER BY、GROUP BY、またはDISTINCT句が含まれている場合、SQLiteは一時的なBツリー構造を使用して出力行をソートする必要がある場合があります。または、&lt;a href=&quot;queryplanner#sorting&quot;&gt;インデックスを使用する場合があります&lt;/a&gt;。ほとんどの場合、インデックスを使用する方が、ソートを実行するよりもはるかに効率的です。一時的なbツリーが必要な場合、「詳細」フィールドを「USE TEMP B-TREE FOR xxx」という形式の文字列値に設定して、EXPLAIN QUERY PLAN出力にレコードを追加します。ここで、xxxは「ORDER BY」、「GROUP BY」、または「DISTINCT」。例えば：</target>
        </trans-unit>
        <trans-unit id="5b44dbe4fb9e1c6ef0606b8af702048ca0e438cc" translate="yes" xml:space="preserve">
          <source>If a SELECT statement that returns more than one row does not have an ORDER BY clause, the order in which the rows are returned is undefined. Or, if a SELECT statement does have an ORDER BY clause, then the list of expressions attached to the ORDER BY determine the order in which rows are returned to the user.</source>
          <target state="translated">複数の行を返すSELECT文にORDER BY句がない場合、返される行の順序は未定義です。あるいは、SELECT文にORDER BY句がある場合、ORDER BYに付随する式のリストが、ユーザに返される行の順序を決定します。</target>
        </trans-unit>
        <trans-unit id="1b3cef981ef6c33ad4faa712cdaf3b903f15861f" translate="yes" xml:space="preserve">
          <source>If a UNION operator connects the initial-select with the recursive-select, then only add rows to the queue if no identical row has been previously added to the queue. Repeated rows are discarded before being added to the queue even if the repeated rows have already been extracted from the queue by the recursion step. If the operator is UNION ALL, then all rows generated by both the initial-select and the recursive-select are always added to the queue even if they are repeats. When determining if a row is repeated, NULL values compare equal to one another and not equal to any other value.</source>
          <target state="translated">UNION演算子が初期選択と再帰選択を接続している場合、以前に同じ行がキューに追加されていない場合にのみ、行をキューに追加します。繰り返しの行は、たとえその繰り返しの行が再帰ステップによって既にキューから抽出されていたとしても、キューに追加される前に破棄されます。演算子が UNION ALL の場合、初期選択と再帰選択の両方によって生成されたすべての行は、たとえそれらが繰り返し行であっても、常にキューに追加されます。行が繰り返されているかどうかを判断する際には、NULL値は互いに等しく比較され、他の値とは等しくありません。</target>
        </trans-unit>
        <trans-unit id="56d92b47e4081e5a6e548ebb6f898e186d052899" translate="yes" xml:space="preserve">
          <source>If a WHEN clause is supplied, the SQL statements specified are only executed if the WHEN clause is true. If no WHEN clause is supplied, the SQL statements are executed every time the trigger fires.</source>
          <target state="translated">WHEN句が指定された場合、指定されたSQL文はWHEN句が真の場合にのみ実行されます。WHEN句が与えられなかった場合、トリガが発生するたびにSQL文が実行されます。</target>
        </trans-unit>
        <trans-unit id="85a070271019d9b24039a7b30649256cb4c49fd9" translate="yes" xml:space="preserve">
          <source>If a WHERE clause is specified, the WHERE expression is evaluated for each row in the input data as a &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt;. Only rows for which the WHERE clause expression evaluates to true are included from the dataset before continuing. Rows are excluded from the result if the WHERE clause evaluates to either false or NULL.</source>
          <target state="translated">WHERE句が指定されている場合、WHERE式は入力データの各行に対して&lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;ブール式&lt;/a&gt;として評価されます。続行する前に、WHERE句の式がtrueと評価される行のみがデータセットから含まれます。 WHERE句の評価がfalseまたはNULLの場合、行は結果から除外されます。</target>
        </trans-unit>
        <trans-unit id="99314068471e46954e8f897765afda682981e6bc" translate="yes" xml:space="preserve">
          <source>If a build of SQLite does not include the FTS modules, then any attempt to prepare an SQL statement to create an FTS3 or FTS4 table or to drop or access an existing FTS table in any way will fail. The error message returned will be similar to &quot;no such module: ftsN&quot; (where N is either 3 or 4).</source>
          <target state="translated">SQLite のビルドに FTS モジュールが含まれていない場合、FTS3 または FTS4 テーブルを作成したり、既存の FTS テーブルを削除したりアクセスしたりする SQL 文を準備しようとしても失敗します。返されるエラーメッセージは、&quot;no such module:ftsN&quot; (ここで、N は 3 または 4 のいずれかです)のようなものになります。</target>
        </trans-unit>
        <trans-unit id="c07dc39ee71e6a6e8537165278b706aabd6e81bd" translate="yes" xml:space="preserve">
          <source>If a call to sqlite3_step() that attempts to write to a database table returns SQLITE_LOCKED, then more than one other connection may be holding a read-lock on the database table in question. In this case SQLite simply selects one of those other connections arbitrarily and issues the unlock-notify callback when that connection's transaction is finished. Whether the call to sqlite3_step() was blocked by one or many connections, when the corresponding unlock-notify callback is issued it is not guaranteed that the required lock is available, only that it may be.</source>
          <target state="translated">データベーステーブルへの書き込みを試みたsqlite3_step()の呼び出しがSQLITE_LOCKEDを返す場合、問題のデータベーステーブルに対して複数の他の接続がリードロックを保持している可能性があります。この場合、SQLiteは単に他の接続のうちの1つを任意に選択し、その接続のトランザクションが終了したときにunlock-notifyコールバックを発行します。sqlite3_step()の呼び出しが1つのコネクションによってブロックされていようが、多数のコネクションによってブロックされていようが、対応する unlock-notifyコールバックが発行されたときに、必要なロックが利用可能であることを保証するものではありません。</target>
        </trans-unit>
        <trans-unit id="12e866adc40a794d5a50cd7647771628a0fe472b" translate="yes" xml:space="preserve">
          <source>If a character specified as part of the argument to &quot;tokenchars=&quot; is considered to be a token character by default, it is ignored. This is true even if it has been marked as a separator by an earlier &quot;separators=&quot; option. Similarly, if a character specified as part of a &quot;separators=&quot; option is treated as a separator character by default, it is ignored. If multiple &quot;tokenchars=&quot; or &quot;separators=&quot; options are specified, all are processed. For example:</source>
          <target state="translated">tokenchars=&quot; の引数の一部として指定された文字が、デフォルトではトークン文字とみなされている場合、それは無視されます。これは、以前の &quot;separators=&quot; オプションで区切り文字としてマークされていた場合でも同様です。同様に、&quot;separators=&quot;オプションの一部として指定された文字がデフォルトでセパレータ文字として扱われている場合、それは無視されます。複数の &quot;tokenchars=&quot; または &quot;separators=&quot; オプションが指定されている場合は、すべて処理されます。例えば、&quot;tokenchars=&quot;または &quot;separators=&quot;オプションを複数指定した場合は、すべて処理されます。</target>
        </trans-unit>
        <trans-unit id="4047a69992390b90bb1e651abb363899dad3ce20" translate="yes" xml:space="preserve">
          <source>If a collating function fails any of the above constraints and that collating function is registered and used, then the behavior of SQLite is undefined.</source>
          <target state="translated">照合関数が上記の制約のいずれかに失敗し、その照合関数が登録されて使用されている場合、SQLiteの動作は未定義となります。</target>
        </trans-unit>
        <trans-unit id="4a25d30fe6f01a94e32b9a3c4b8ab96f2806f18f" translate="yes" xml:space="preserve">
          <source>If a column datatype contains the special keyword &quot;HIDDEN&quot; (in any combination of upper and lower case letters) then that keyword it is omitted from the column datatype name and the column is marked as a hidden column internally. A hidden column differs from a normal column in three respects:</source>
          <target state="translated">列のデータ型に特別なキーワード &quot;HIDDEN&quot; が含まれている場合は、そのキーワードは列のデータ型名から省略され、その列は内部的に hidden 列としてマークされます。隠された列は、3つの点で通常の列とは異なります。</target>
        </trans-unit>
        <trans-unit id="4a3060f5f06633a8fd81221c196cda03a0efe5c5" translate="yes" xml:space="preserve">
          <source>If a column filter specification is preceded by a &quot;-&quot; character, then it is interpreted as a list of column not to match against. For example:</source>
          <target state="translated">カラムフィルタ指定の前に&quot;-&quot;文字が付けられている場合は、マッチしないカラムのリストとして解釈されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="4784be250e1d29a9c62d93440a67186e8f2d433e" translate="yes" xml:space="preserve">
          <source>If a column has the type INTEGER PRIMARY KEY AUTOINCREMENT then a slightly different ROWID selection algorithm is used. The ROWID chosen for the new row is at least one larger than the largest ROWID that has ever before existed in that same table. If the table has never before contained any data, then a ROWID of 1 is used. If the largest possible ROWID has previously been inserted, then new INSERTs are not allowed and any attempt to insert a new row will fail with an SQLITE_FULL error. Only ROWID values from previous transactions that were committed are considered. ROWID values that were rolled back are ignored and can be reused.</source>
          <target state="translated">列の型が INTEGER PRIMARY KEY AUTOINCREMENT の場合は、少し異なる ROWID 選択アルゴリズムが使用されます。新しい行に選択される ROWID は、同じテーブルに過去に存在した最大の ROWID よりも少なくとも 1 つ大きいものです。テーブルにデータが一度も含まれていない場合は、1のROWIDが使用されます。可能な限り最大の ROWID が以前に挿入されていた場合、新しい INSERT は許可されず、新しい行を挿入しようとすると SQLITE_FULL エラーで失敗します。コミットされた以前のトランザクションの ROWID 値のみが考慮されます。ロールバックされた ROWID 値は無視され、再利用することができます。</target>
        </trans-unit>
        <trans-unit id="85779fa11fd249fc0a9433b1c9e912b143d1abd7" translate="yes" xml:space="preserve">
          <source>If a column-name list follows the view-name, then that list determines the names of the columns for the view. If the column-name list is omitted, then the names of the columns in the view are derived from the names of the result-set columns in the &lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt;. The use of column-name list is recommended. Or, if column-name list is omitted, then the result columns in the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement that defines the view should have well-defined names using the &quot;&lt;a href=&quot;syntax/result-column&quot;&gt;AS column-alias&lt;/a&gt;&quot; syntax. SQLite allows you to create views that depend on automatically generated column names, but you should avoid using them since the rules used to generate column names are not a defined part of the interface and might change in future releases of SQLite.</source>
          <target state="translated">column-nameリストがview-nameの後に続く場合、そのリストはビューの列の名前を決定します。 column-nameリストが省略されている場合、ビューの列の名前は、&lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmtの&lt;/a&gt;結果セット列の名前から派生します。 column-nameリストの使用をお勧めします。または、column-nameリストが省略されている場合、ビューを定義する&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;ステートメントの結果列には、 &quot; &lt;a href=&quot;syntax/result-column&quot;&gt;AS column-alias&lt;/a&gt; &quot;構文を使用して明確に定義された名前が必要です。 SQLiteでは、自動的に生成された列名に依存するビューを作成できますが、列名の生成に使用されるルールはインターフェースの定義された部分ではなく、SQLiteの将来のリリースで変更される可能性があるため、これらの使用は避けてください。</target>
        </trans-unit>
        <trans-unit id="7f7aaafed42977493a2413f4303512821df4e3b2" translate="yes" xml:space="preserve">
          <source>If a conflict handler returns this value no special action is taken. The change that caused the conflict is not applied. The session module continues to the next change in the changeset.</source>
          <target state="translated">競合ハンドラがこの値を返した場合、特別なアクションは実行されません。コンフリクトの原因となった変更は適用されません。セッションモジュールは、チェンジセットの次の変更に継続します。</target>
        </trans-unit>
        <trans-unit id="a40b2d39f56dad1b134a26af2fe2ae696281adc1" translate="yes" xml:space="preserve">
          <source>If a covering index can be used for a query, then the multiple rowid lookups can be avoided and the cost of the query drops dramatically.</source>
          <target state="translated">カバーリングインデックスをクエリに使用できる場合は、複数の行IDのルックアップを避けることができ、クエリのコストは劇的に低下します。</target>
        </trans-unit>
        <trans-unit id="653b4381ff1ad3607fbc3061d7b4f5d80ed74deb" translate="yes" xml:space="preserve">
          <source>If a crash or power failure occurs and results in a hot journal but that journal is deleted, the next process to open the database will not know that it contains changes that need to be rolled back. The rollback will not occur and the database will be left in an inconsistent state. Rollback journals might be deleted for any number of reasons:</source>
          <target state="translated">クラッシュや停電が発生してホット・ジャーナルが発生したが、そのジャーナルが削除された場合、データベースを開く次のプロセスでは、ロールバックする必要のある変更が含まれていることがわかりません。ロールバックは発生せず、データベースは一貫性のない状態のままになります。ロールバック・ジャーナルは、いくつかの理由で削除される可能性があります。</target>
        </trans-unit>
        <trans-unit id="dbc53ced19579b45a05b723b3063167292a44232" translate="yes" xml:space="preserve">
          <source>If a crash or power loss does occur and a hot journal is left on the disk, it is essential that the original database file and the hot journal remain on disk with their original names until the database file is opened by another SQLite process and rolled back. During recovery at &lt;a href=&quot;#section_4_2&quot;&gt;step 4.2&lt;/a&gt; SQLite locates the hot journal by looking for a file in the same directory as the database being opened and whose name is derived from the name of the file being opened. If either the original database file or the hot journal have been moved or renamed, then the hot journal will not be seen and the database will not be rolled back.</source>
          <target state="translated">クラッシュまたは停電が発生し、ホットジャーナルがディスクに残っている場合、元のデータベースファイルとホットジャーナルは、データベースファイルが別のSQLiteプロセスによって開かれてロールバックされるまで、元の名前でディスクに残ることが重要です。 。&lt;a href=&quot;#section_4_2&quot;&gt;ステップ4.2での&lt;/a&gt;リカバリー中に、SQLiteは、開かれているデータベースと同じディレクトリーで、開かれているファイルの名前から派生した名前のファイルを探すことにより、ホットジャーナルを見つけます。元のデータベースファイルまたはホットジャーナルが移動または名前変更されている場合、ホットジャーナルは表示されず、データベースはロールバックされません。</target>
        </trans-unit>
        <trans-unit id="fb8183919d1fc07417b2707b8092ba7a7a08090d" translate="yes" xml:space="preserve">
          <source>If a crash or power loss occurs in the middle of a transaction, then the rollback journal file is left on disk. The next time another application attempts to open the database file, it notices the presence of the abandoned rollback journal (we call it a &quot;hot journal&quot; in this circumstance) and uses the information in the journal to restore the database to its state prior to the start of the incomplete transaction. This is how SQLite implements atomic commit.</source>
          <target state="translated">トランザクションの途中でクラッシュや停電が発生した場合、ロールバック・ジャーナル・ファイルはディスク上に残されます。次に別のアプリケーションがデータベースファイルを開こうとすると、放棄されたロールバックジャーナル(この状況では「ホットジャーナル」と呼んでいます)の存在に気付き、ジャーナル内の情報を使ってデータベースを不完全なトランザクションの開始前の状態に復元します。これが SQLite がアトミックコミットを実装する方法です。</target>
        </trans-unit>
        <trans-unit id="ac9f0e2592a2df4c51e939a4b5d49b41b7d7ebcb" translate="yes" xml:space="preserve">
          <source>If a database connection is opened with the &quot;-uri 1&quot; option, then &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; are honored by the &quot;backup&quot; and &quot;restore&quot; commands.</source>
          <target state="translated">「-uri 1」オプションを使用してデータベース接続が開かれている場合、&lt;a href=&quot;uri&quot;&gt;URIファイル名&lt;/a&gt;は「backup」および「restore」コマンドによって受け入れられます。</target>
        </trans-unit>
        <trans-unit id="d5923feff2a2aef8fc7abf4f600aff34fc785066" translate="yes" xml:space="preserve">
          <source>If a database connection is operating in &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; or in &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;persistent journal mode&lt;/a&gt; (PRAGMA journal_mode=persist) then after committing a transaction the &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; file may remain in the file-system. This increases performance for subsequent transactions since overwriting an existing file is faster than append to a file, but it also consumes file-system space. After a large transaction (e.g. a &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;), the rollback journal file may consume a very large amount of space.</source>
          <target state="translated">データベース接続が&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;排他ロックモード&lt;/a&gt;または&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;永続ジャーナルモード&lt;/a&gt;（PRAGMA journal_mode = persist）で動作している場合、トランザクションをコミットした後、&lt;a href=&quot;lockingv3#rollback&quot;&gt;ロールバックジャーナル&lt;/a&gt;ファイルがファイルシステムに残ることがあります。既存のファイルを上書きする方がファイルに追加するより高速なので、これにより後続のトランザクションのパフォーマンスが向上しますが、ファイルシステムのスペースも消費します。大きなトランザクション（&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUMなど&lt;/a&gt;）の後、ロールバックジャーナルファイルは非常に大量のスペースを消費する場合があります。</target>
        </trans-unit>
        <trans-unit id="5f55f04439258c2d344a35f29269aa9db3e5202b" translate="yes" xml:space="preserve">
          <source>If a database file is accessed using 8+3 naming rather than the default long filename, then it must be consistently accessed using 8+3 naming by every database connection every time it is opened, or else there is a risk of database corruption. The auxiliary &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; and &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; files are essential to SQLite for being about to recover from a crash. If an application is using 8+3 names and crashes, then the information needed to safely recover from the crash is stored in files with the &quot;&lt;code&gt;.nal&lt;/code&gt;&quot; or &quot;&lt;code&gt;.wal&lt;/code&gt;&quot; extension. If the next application to open the database does not specify the &quot;&lt;code&gt;8_3_names=1&lt;/code&gt;&quot; URI parameter, then SQLite will use the long filenames to try to locate the rollback journal or write-ahead log files. It will not find them, since they were saved using 8+3 names by the application that crashed, and hence the database will not be properly recovered and will likely go corrupt.</source>
          <target state="translated">デフォルトの長いファイル名ではなく8 + 3ネーミングを使用してデータベースファイルにアクセスする場合は、開かれるたびにすべてのデータベース接続で8 + 3ネーミングを使用して一貫してアクセスする必要があります。そうしないと、データベースが破損するおそれがあります。SQLiteがクラッシュから回復しようとするためには、補助&lt;a href=&quot;lockingv3#rollback&quot;&gt;ロールバックジャーナル&lt;/a&gt;と&lt;a href=&quot;wal&quot;&gt;先行書き込みログ&lt;/a&gt;ファイルが不可欠です。アプリケーションが8 + 3の名前とクラッシュを使用している場合、クラッシュから安全に回復するために必要な情報は、 &lt;code&gt;.nal&lt;/code&gt; が「.nal」または「 &lt;code&gt;.wal&lt;/code&gt; 」のファイルに保存されます。データベースを開く次のアプリケーションで &quot; &lt;code&gt;8_3_names=1&lt;/code&gt; &quot;URIパラメータの場合、SQLiteは長いファイル名を使用してロールバックジャーナルまたは先読みログファイルを見つけようとします。クラッシュしたアプリケーションによって8 + 3の名前を使用して保存されたため、これらのファイルは見つからないため、データベース正しく回復されず、破損する可能性があります。</target>
        </trans-unit>
        <trans-unit id="bd70a20b8f5f47bbbe011a3bee3a583fecc50caa" translate="yes" xml:space="preserve">
          <source>If a database is written by SQLite version 3.7.0 or later and then written again by SQLite version 3.6.23 or earlier in such a way as to make the size of the database file decrease, then the next time that SQLite version 3.7.0 access the database file, it might report that the database file is corrupt. The database file is not really corrupt, however. Version 3.7.0 was simply being overly zealous in its corruption detection.</source>
          <target state="translated">SQLite バージョン 3.7.0 以降でデータベースを書き込んだ後、SQLite バージョン 3.6.23 以前でデータベースファイルのサイズを小さくするような方法で再度書き込んだ場合、次に SQLite バージョン 3.7.0 がデータベースファイルにアクセスしたときに、データベースファイルが破損していると報告されることがあります。しかし、データベースファイルは実際には壊れていません。バージョン3.7.0は単に破損検出に熱心になりすぎただけです。</target>
        </trans-unit>
        <trans-unit id="c0e8b12ff7ad15986137c5d5f01f4e0ef949a4a6" translate="yes" xml:space="preserve">
          <source>If a database were originally created using SQLite version 3.7.0, then written by SQLite version 3.6.23.1 such that the size of the database file increased, then written again by SQLite version 3.7.0, the database file could go corrupt.</source>
          <target state="translated">もともとSQLiteバージョン3.7.0でデータベースを作成し、SQLiteバージョン3.6.23.1で書き込んでデータベースファイルのサイズが大きくなった後、再度SQLiteバージョン3.7.0で書き込んだ場合、データベースファイルが破損してしまう可能性があります。</target>
        </trans-unit>
        <trans-unit id="f7f861f58b781638426cc97ad65bbe6addfa6a62" translate="yes" xml:space="preserve">
          <source>If a keyword in double quotes (ex: &lt;b&gt;&quot;key&quot;&lt;/b&gt; or &lt;b&gt;&quot;glob&quot;&lt;/b&gt;) is used in a context where it cannot be resolved to an identifier but where a string literal is allowed, then the token is understood to be a string literal instead of an identifier.</source>
          <target state="translated">二重引用符で囲まれたキーワード（例：&lt;b&gt;&quot;key&quot;&lt;/b&gt;または&lt;b&gt;&quot;glob&quot;&lt;/b&gt;）が、識別子に解決できないが文字列リテラルが許可されているコンテキストで使用されている場合、トークンは文字列リテラルではなく、識別子。</target>
        </trans-unit>
        <trans-unit id="ff734731d1dd61e745b8c19a93e379fd051ea7fb" translate="yes" xml:space="preserve">
          <source>If a keyword in single quotes (ex: &lt;b&gt;'key'&lt;/b&gt; or &lt;b&gt;'glob'&lt;/b&gt;) is used in a context where an identifier is allowed but where a string literal is not allowed, then the token is understood to be an identifier instead of a string literal.</source>
          <target state="translated">単一引用符で囲まれたキーワード（例：&lt;b&gt;'key'&lt;/b&gt;または&lt;b&gt;'glob'&lt;/b&gt;）が、識別子は許可されているが文字列リテラルは許可されていないコンテキストで使用される場合、トークンは文字列リテラルではなく識別子であると理解されます。</target>
        </trans-unit>
        <trans-unit id="fd8582b07f28c43cf6305e6462fb4a6db23b8ea7" translate="yes" xml:space="preserve">
          <source>If a matchable phrase is part of a series of phrases connected by NEAR operators in the FTS query expression, then each phrase match must be sufficiently close to other phrase matches of the relevant types to satisfy the NEAR condition.</source>
          <target state="translated">一致可能なフレーズが、FTS クエリ式の NEAR 演算子によって接続された一連のフレーズの一部である場合、各フレーズの一致は、NEAR 条件を満たすために、関連するタイプの他のフレーズの一致に十分に近接していなければなりません。</target>
        </trans-unit>
        <trans-unit id="a2a6d03cae632eedbf962d2919113c9e0642d81c" translate="yes" xml:space="preserve">
          <source>If a memory allocation error occurs, sqlite3_create_filename() might return a NULL pointer. The memory obtained from sqlite3_create_filename(X) must be released by a corresponding call to sqlite3_free_filename(Y).</source>
          <target state="translated">メモリ割り当てエラーが発生した場合、sqlite3_create_filename()はNULLポインタを返すかもしれません。sqlite3_create_filename(X)で得られたメモリは、対応するsqlite3_free_filename(Y)の呼び出しによって解放されなければなりません。</target>
        </trans-unit>
        <trans-unit id="16ba62507a795aad87688bd7a66b598560ff99c0" translate="yes" xml:space="preserve">
          <source>If a named virtual table that uses the dbstat module is desired, then the recommended way to create an instance of the dbstat virtual table is as follows:</source>
          <target state="translated">dbstatモジュールを使用する名前付き仮想テーブルが必要な場合は、以下のようにdbstat仮想テーブルのインスタンスを作成することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f0a2ba4a4cc7d08c018b4dbe8137dc10439214b7" translate="yes" xml:space="preserve">
          <source>If a numeric literal has a decimal point or an exponentiation clause or if its magnitude is less than -9223372036854775808 or greater than 9223372036854775807, then it is a floating point literal. Otherwise is it is an integer literal. The &quot;E&quot; character that begins the exponentiation clause of a floating point literal can be either upper or lower case. The &quot;.&quot; character is always used as the decimal point even if the locale setting specifies &quot;,&quot; for this role - the use of &quot;,&quot; for the decimal point would result in syntactic ambiguity.</source>
          <target state="translated">数値リテラルに小数点または指数節がある場合、またはその大きさが-9223372036854775808より小さいか、9223372036854775807より大きい場合、それは浮動小数点リテラルです。それ以外の場合は整数リテラルです。浮動小数点リテラルの指数化句の先頭にある &quot;E &quot;文字は、大文字または小文字のどちらでも構いません。ロケール設定でこの役割のために&quot;,&quot;が指定されている場合でも、&quot;.&quot;は常に小数点として使用されます-小数点に&quot;,&quot;を使用すると、構文的に曖昧になります。</target>
        </trans-unit>
        <trans-unit id="8cf3813aebca15b6b5e1583aeffa06f6925412e6" translate="yes" xml:space="preserve">
          <source>If a page contains no cells (which is only possible for a root page of a table that contains no rows) then the offset to the cell content area will equal the page size minus the bytes of reserved space. If the database uses a 65536-byte page size and the reserved space is zero (the usual value for reserved space) then the cell content offset of an empty page wants to be 65536. However, that integer is too large to be stored in a 2-byte unsigned integer, so a value of 0 is used in its place.</source>
          <target state="translated">ページにセルが含まれていない場合(これは行を含まないテーブルのルートページでのみ可能です)、セル内容領域へのオフセットはページサイズから予約領域のバイト数を引いたものになります。データベースが65536バイトのページサイズを使用しており、予約領域がゼロ(予約領域の通常の値)である場合、空ページのセルコンテンツオフセットは65536になります。しかし、この整数は2バイトの符号なし整数に格納するには大きすぎるため、0の値が代わりに使用されます。</target>
        </trans-unit>
        <trans-unit id="c99e07bc95c7e7eeb5ce8d8ce056128a45cab0ab" translate="yes" xml:space="preserve">
          <source>If a parameter name begins with a &quot;:&quot;, then it is assumed to be a value to bind to the SQL statement before executing it. The value is always bound as text. It is an error if the specified SQL parameter does not exist. For example:</source>
          <target state="translated">パラメータ名が&quot;:&quot;で始まる場合、それはSQL文を実行する前にバインドする値であると見なされます。値は常にテキストとしてバインドされます。指定されたSQLパラメータが存在しない場合はエラーとなります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="a3a6677c34d1c31ace005a4fa6f3930c2040066e" translate="yes" xml:space="preserve">
          <source>If a power failure or operating system crash occurs at this point, the transaction will not rollback when the system reboots even though there are rollback journals present. The difference is the master journal pathname in the header of the rollback journal. Upon restart, SQLite only considers a journal to be hot and will only playback the journal if there is no master journal filename in the header (which is the case for a single-file commit) or if the master journal file still exists on disk.</source>
          <target state="translated">この時点で電源障害やオペレーティングシステムのクラッシュが発生した場合、ロールバックジャーナルが存在していてもシステムが再起動したときにトランザクションはロールバックされません。違いは、ロールバック・ジャーナルのヘッダーにあるマスター・ジャーナル・パス名です。再起動時には、SQLite はジャーナルをホットジャーナルとみなし、ヘッダーにマスタージャーナルファイル名がない場合(シングルファイルコミットの場合がこれにあたります)、またはマスタージャーナルファイルがディスク上にまだ存在する場合にのみジャーナルを再生します。</target>
        </trans-unit>
        <trans-unit id="df0966ae095afce680bcbe564721893f2e27c89b" translate="yes" xml:space="preserve">
          <source>If a power failure or operating system crash occurs at this point, the transaction will not rollback when the system reboots even though there are rollback journals present. The difference is the super-journal pathname in the header of the rollback journal. Upon restart, SQLite only considers a journal to be hot and will only playback the journal if there is no super-journal filename in the header (which is the case for a single-file commit) or if the super-journal file still exists on disk.</source>
          <target state="translated">この時点で電源障害やオペレーティングシステムのクラッシュが発生した場合、ロールバックジャーナルが存在していてもシステムが再起動したときにトランザクションはロールバックされません。違いは、ロールバック・ジャーナルのヘッダーにあるスーパー・ジャーナル・パス名です。再起動時には、SQLite はジャーナルがホットであるとのみみなし、ヘッダーにスーパージャーナルのファイル名がない場合(シングルファイルコミットの場合)、またはスーパージャーナルのファイルがディスク上にまだ存在する場合にのみジャーナルを再生します。</target>
        </trans-unit>
        <trans-unit id="f031e4113363c1780559d56fb503c736f7031cb4" translate="yes" xml:space="preserve">
          <source>If a power failure or operating system failure occurs while copying the database file the backup database may be corrupted following system recovery.</source>
          <target state="translated">データベース ファイルのコピー中に電源障害またはオペレーティング システム障害が発生した場合、システム リカバリ後にバックアップ データベースが破損する可能性があります。</target>
        </trans-unit>
        <trans-unit id="d63fd60747c59caf947d214389cf965d0e528d08" translate="yes" xml:space="preserve">
          <source>If a query contains an ORDER BY clause with multiple terms, it might be that SQLite can use indices to cause rows to come out in the order of some prefix of the terms in the ORDER BY but that later terms in the ORDER BY are not satisfied. In that case, SQLite does block sorting. Suppose the ORDER BY clause has four terms and the natural order of the query results in rows appearing in order of the first two terms. As each row is output by the query engine and enters the sorter, the outputs in the current row corresponding to the first two terms of the ORDER BY are compared against the previous row. If they have changed, the current sort is finished and output and a new sort is started. This results in a slightly faster sort. But the bigger advantages are that many fewer rows need to be held in memory, reducing memory requirements, and outputs can begin to appear before the core query has run to completion.</source>
          <target state="translated">クエリに複数の単語を含む ORDER BY 句が含まれている場合、SQLite がインデックスを使用して ORDER BY の単語のプレフィックスの順に行を出力することができますが、それ以降の ORDER BY の単語が満たされていない場合があります。この場合、SQLite はブロックソートを行います。例えば、ORDER BY 句には 4 つの項があり、クエリの自然な順序では、最初の 2 つの項から順に行が出力されるとします。各行がクエリエンジンによって出力され、ソーターに入ると、ORDER BYの最初の2つの項に対応する現在の行の出力が前の行と比較されます。それらが変更されている場合は、現在のソートが終了して出力され、新しいソートが開始されます。その結果、ソートが若干速くなります。しかし、より大きな利点は、メモリに保持する必要のある行の数が少なくて済むため、メモリの必要量が減り、コアクエリが完了する前に出力を開始することができることです。</target>
        </trans-unit>
        <trans-unit id="ec318f6e2d2904b05a3f02946f0559cc8fefaa28" translate="yes" xml:space="preserve">
          <source>If a query contains no aggregate functions at all, then a GROUP BY clause can be added as a substitute for the DISTINCT ON clause. In other words, output rows are filtered so that only one row is shown for each distinct set of values in the GROUP BY clause. If two or more output rows would have otherwise had the same set of values for the GROUP BY columns, then one of the rows is chosen arbitrarily. (SQLite supports DISTINCT but not DISTINCT ON, whose functionality is provided instead by GROUP BY.)</source>
          <target state="translated">クエリに集約関数が全く含まれていない場合、GROUP BY句をDISTINCT ON句の代わりに追加することができます。言い換えれば、出力行はフィルタリングされ、GROUP BY句の異なる値のセットに対して1つの行のみが表示されるようになります。2 つ以上の出力行が、GROUP BY 列の値のセットが同じでなければならない場合は、そのうちの 1 つの行が任意に選択されます (SQLite は DISTINCT ON 節をサポートしています)。(SQLite は DISTINCT をサポートしていますが、DISTINCT ON はサポートしていません。)</target>
        </trans-unit>
        <trans-unit id="bdf63c23188158127b26cd2c4807de45ccf6dea6" translate="yes" xml:space="preserve">
          <source>If a query contains no aggregate functions at all, then a GROUP BY clause can be added as a substitute of DISTINCT ON clause. In other words, output rows are filtered so that only one row is shows for each distinct set of values in the GROUP BY clause. If two or more output rows would have otherwise had the same set of values for the GROUP BY columns, then one of the rows is chosen arbitrarily.</source>
          <target state="translated">クエリに集約関数が全く含まれていない場合は、GROUP BY句をDISTINCT ON句の代わりに追加することができます。言い換えれば、出力行は、GROUP BY句の異なる値のセットに対して1つの行のみが表示されるようにフィルタリングされます。2つ以上の出力行が、そうでなければGROUP BY列の値のセットが同じであった場合、そのうちの1つの行が任意に選択されます。</target>
        </trans-unit>
        <trans-unit id="cab66c0bca9a377eb02b4b0ac5090404c2d874c0" translate="yes" xml:space="preserve">
          <source>If a read/write client invokes &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control&lt;/a&gt;(&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;) prior to shutdown, then at shutdown a checkpoint is still run, but the shm file and wal file are not deleted. This allows subsequent read-only clients to connect to and read the database.</source>
          <target state="translated">読み取り/書き込みクライアントがシャットダウンの前に&lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control&lt;/a&gt;（&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;）を呼び出す場合、シャットダウン時にチェックポイントは引き続き実行されますが、shmファイルとwalファイルは削除されません。これにより、後続の読み取り専用クライアントがデータベースに接続して読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="337133b7d09a387cf87665a4c7d79ff39c533386" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the modified non-primary key fields contains a value different from an original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. Since UPDATE changes only contain values for non-primary key fields that are to be modified, only those fields need to match the original values to avoid the SQLITE_CHANGESET_DATA conflict-handler callback.</source>
          <target state="translated">主キー値が一致する行が見つかったが、変更された非主キーフィールドの1つ以上に、チェンジセットに格納されている元の行値とは異なる値が含まれている場合、2番目の引数として&lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt;を使用して競合ハンドラ関数が呼び出されます。 。UPDATEの変更には、変更される非主キーフィールドの値のみが含まれるため、SQLITE_CHANGESET_DATA競合ハンドラーコールバックを回避するには、これらのフィールドのみが元の値と一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="35c7138a2b7260bc49d6f60cf430df710c00202b" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the modified non-primary key fields contains a value different from an original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. Since UPDATE changes only contain values for non-primary key fields that are to be modified, only those fields need to match the original values to avoid the SQLITE_CHANGESET_DATA conflict-handler callback.</source>
          <target state="translated">主キー値が一致する行が見つかったが、変更された非主キーフィールドの1つ以上に、チェンジセットに格納されている元の行値とは異なる値が含まれている場合、2番目の引数として&lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt;を使用して競合ハンドラ関数が呼び出されます。 。UPDATEの変更には、変更される非主キーフィールドの値のみが含まれるため、SQLITE_CHANGESET_DATA競合ハンドラーコールバックを回避するには、これらのフィールドのみが元の値と一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="1b234b4b89cfdd9943a23340845cb2723771c58a" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the non-primary key fields contains a value different from the original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. If the database table has more columns than are recorded in the changeset, only the values of those non-primary key fields are compared against the current database contents - any trailing database table columns are ignored.</source>
          <target state="translated">主キー値が一致する行が見つかったが、非主キーフィールドの1つ以上に、変更セットに格納されている元の行値とは異なる値が含まれている場合、&lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLのCHANGESET_DATA&lt;/a&gt;を2番目の引数として使用して、競合ハンドラー関数が呼び出されます。変更セットに記録されているよりも多くの列がデータベーステーブルにある場合、それらの非主キーフィールドの値のみが現在のデータベースの内容と比較されます。後続のデータベーステーブルの列は無視されます。</target>
        </trans-unit>
        <trans-unit id="ca3b8d6b7470e9a00b63341bcac487b0076109fe" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the non-primary key fields contains a value different from the original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. If the database table has more columns than are recorded in the changeset, only the values of those non-primary key fields are compared against the current database contents - any trailing database table columns are ignored.</source>
          <target state="translated">主キー値が一致する行が見つかったが、非主キーフィールドの1つ以上に、変更セットに格納されている元の行値とは異なる値が含まれている場合、&lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLのCHANGESET_DATA&lt;/a&gt;を2番目の引数として使用して、競合ハンドラー関数が呼び出されます。変更セットに記録されているよりも多くの列がデータベーステーブルにある場合、それらの非主キーフィールドの値のみが現在のデータベースの内容と比較されます。後続のデータベーステーブルの列は無視されます。</target>
        </trans-unit>
        <trans-unit id="e400ae567f256dbdcc0abe528516e66e2c791942" translate="yes" xml:space="preserve">
          <source>If a schema name is specified as part of an object reference, it must be either &quot;main&quot;, or &quot;temp&quot; or the schema-name of an attached database. Like other SQL identifiers, schema names are case-insensitive. If a schema name is specified, then only that one schema is searched for the named object.</source>
          <target state="translated">スキーマ名がオブジェクト参照の一部として指定されている場合は、&quot;main&quot;、&quot;temp&quot;、またはアタッチされているデータベースのスキーマ名のいずれかでなければなりません。他の SQL 識別子と同様に、スキーマ名は大文字小文字を区別しません。スキーマ名が指定された場合、指定されたオブジェクトに対してはそのスキーマのみが検索されます。</target>
        </trans-unit>
        <trans-unit id="a287d9b64545db85e7dfa26422162809454f183b" translate="yes" xml:space="preserve">
          <source>If a schema-name is specified, it must be either &quot;main&quot;, &quot;temp&quot;, or the name of an &lt;a href=&quot;lang_attach&quot;&gt;attached database&lt;/a&gt;. In this case the new table is created in the named database. If the &quot;TEMP&quot; or &quot;TEMPORARY&quot; keyword occurs between the &quot;CREATE&quot; and &quot;TABLE&quot; then the new table is created in the temp database. It is an error to specify both a schema-name and the TEMP or TEMPORARY keyword, unless the schema-name is &quot;temp&quot;. If no schema name is specified and the TEMP keyword is not present then the table is created in the main database.</source>
          <target state="translated">schema-nameを指定する場合は、「main」、「temp」、または&lt;a href=&quot;lang_attach&quot;&gt;接続されているデータベースの&lt;/a&gt;名前のいずれかである必要があります。この場合、新しいテーブルは指定されたデータベースに作成されます。 「TEMP」または「TEMPORARY」キーワードが「CREATE」と「TABLE」の間にある場合、新しいテーブルが一時データベースに作成されます。 schema-nameが &quot;temp&quot;でない限り、schema-nameとTEMPまたはTEMPORARYキーワードの両方を指定するとエラーになります。スキーマ名が指定されておらず、TEMPキーワードが存在しない場合、テーブルはメインデータベースに作成されます。</target>
        </trans-unit>
        <trans-unit id="d186fac3c43b0ebe9fb52f2e0bcd9b8dc9321942" translate="yes" xml:space="preserve">
          <source>If a schema-name is specified, then the view is created in the specified database. It is an error to specify both a schema-name and the TEMP keyword on a VIEW, unless the schema-name is &quot;temp&quot;. If no schema name is specified, and the TEMP keyword is not present, the VIEW is created in the main database.</source>
          <target state="translated">スキーマ名を指定すると、指定したデータベースにビューが作成されます。スキーマ名が &quot;temp&quot; でない限り、VIEW でスキーマ名と TEMP キーワードの両方を指定するとエラーになります。スキーマ名が指定されず、TEMP キーワードが存在しない場合、ビューはメイン データベースに作成されます。</target>
        </trans-unit>
        <trans-unit id="5a3b25f9ef77a5c2a55ede994e4212a6c3bae634" translate="yes" xml:space="preserve">
          <source>If a search token (on the right-hand side of the MATCH operator) in &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; begins with &quot;^&quot; then that token must be the first in its field of the document. &lt;b&gt;** Potentially Incompatible Change **&lt;/b&gt;</source>
          <target state="translated">&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4の&lt;/a&gt;検索トークン（MATCH演算子の右側）が&quot;^&quot;で始まる場合、そのトークンはドキュメントのフィールドの最初でなければなりません。&lt;b&gt;**互換性がない可能性のある変更**&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e0b0e745b5660b6e63d47617f06b59c6fe2aec60" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;#sqlite3_changes&quot;&gt;sqlite3_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_changes&quot;&gt;sqlite3_changes（）の&lt;/a&gt;実行中に別のスレッドが同じデータベース接続に変更を加えると、返される値は予測不可能で意味がありません。</target>
        </trans-unit>
        <trans-unit id="e161385bf705ff3ca3325998e8904218252e0a24" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes（）の&lt;/a&gt;実行中に別のスレッドが同じデータベース接続に変更を加えると、返される値は予測不能で意味がありません。</target>
        </trans-unit>
        <trans-unit id="48949b30f7cc8dfe518df452770028dcf8268e04" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;changes&quot;&gt;sqlite3_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">&lt;a href=&quot;changes&quot;&gt;sqlite3_changes（）の&lt;/a&gt;実行中に別のスレッドが同じデータベース接続に変更を加えると、返される値は予測不可能で意味がありません。</target>
        </trans-unit>
        <trans-unit id="e69017ebf8db42f4c918537142f058b4e1e4b99c" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">&lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes（）の&lt;/a&gt;実行中に別のスレッドが同じデータベース接続に変更を加えると、返される値は予測不能で意味がありません。</target>
        </trans-unit>
        <trans-unit id="67e0dff317f2ea719a9272889d4afc4730b1b5fc" translate="yes" xml:space="preserve">
          <source>If a separate thread performs a new &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; on the same database connection while the &lt;a href=&quot;last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; function is running and thus changes the last insert &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;, then the value returned by &lt;a href=&quot;last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; is unpredictable and might not equal either the old or the new last insert &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）&lt;/a&gt;関数の実行中に別のスレッドが同じデータベース接続で新しい&lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;を実行し、それによって最後の挿入&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;を変更した場合、&lt;a href=&quot;last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）から&lt;/a&gt;返される値は予測不能であり、古いものと新しいもののどちらにも等しくない可能性があります&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;ROWIDを&lt;/a&gt;挿入します。</target>
        </trans-unit>
        <trans-unit id="f8a05ae1d1d14adcdf537d4865ddc934cf60a0a4" translate="yes" xml:space="preserve">
          <source>If a separate thread performs a new &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; on the same database connection while the &lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; function is running and thus changes the last insert &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;, then the value returned by &lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; is unpredictable and might not equal either the old or the new last insert &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）&lt;/a&gt;関数の実行中に別のスレッドが同じデータベース接続で新しい&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;を実行し、それによって最後の挿入&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;を変更した場合、&lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid（）から&lt;/a&gt;返される値は予測不能であり、古いものと新しいもののどちらにも等しくない可能性があります&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWIDを&lt;/a&gt;挿入します。</target>
        </trans-unit>
        <trans-unit id="9c0a40f4902327b395568a304aa57a5c4039b9e5" translate="yes" xml:space="preserve">
          <source>If a single database file has multiple links (either hard or soft links) then that is just another way of saying that the file has multiple names. If two or more processes open the database using different names, then they will use different rollback journals and WAL files. That means that if one process crashes, the other process will be unable to recover the transaction in progress because it will be looking in the wrong place for the appropriate journal.</source>
          <target state="translated">1つのデータベースファイルに複数のリンク(ハードリンクまたはソフトリンク)がある場合、それはファイルに複数の名前があることを意味します。2つ以上のプロセスが異なる名前を使用してデータベースを開く場合、それらのプロセスは異なるロールバックジャーナルとWALファイルを使用します。つまり、一方のプロセスがクラッシュした場合、他方のプロセスは適切なジャーナルを探す場所を間違えてしまうため、進行中のトランザクションを回復することができないということです。</target>
        </trans-unit>
        <trans-unit id="54992194ecdfbf1a36948d0111a0401fc51b1ec9" translate="yes" xml:space="preserve">
          <source>If a single row is affected by more than one operation within a session, then the change is considered indirect if all operations meet the criteria for an indirect change above, or direct otherwise.</source>
          <target state="translated">1つの行がセッション内で複数の操作によって影響を受ける場合、すべての操作が上記の間接的な変更の基準を満たしていれば、その変更は間接的なものとみなされ、そうでなければ直接なものとみなされます。</target>
        </trans-unit>
        <trans-unit id="8aed35bc8fc658c89e5539bc9b828e9558656314" translate="yes" xml:space="preserve">
          <source>If a statement modifies the contents of the database so that an immediate foreign key constraint is in violation at the conclusion the statement, an exception is thrown and the effects of the statement are reverted. By contrast, if a statement modifies the contents of the database such that a deferred foreign key constraint is violated, the violation is not reported immediately. Deferred foreign key constraints are not checked until the transaction tries to &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;. For as long as the user has an open transaction, the database is allowed to exist in a state that violates any number of deferred foreign key constraints. However, &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; will fail as long as foreign key constraints remain in violation.</source>
          <target state="translated">ステートメントがデータベースの内容を変更して、ステートメントの終了時に即時外部キー制約に違反する場合、例外がスローされ、ステートメントの効果が元に戻ります。対照的に、ステートメントがデータベースの内容を変更して遅延外部キー制約に違反した場合、違反はすぐには報告されません。遅延外部キー制約は、トランザクションが&lt;a href=&quot;lang_transaction&quot;&gt;COMMITを&lt;/a&gt;試みるまでチェックされません。ユーザーが開いているトランザクションを持っている限り、データベースは、任意の数の遅延外部キー制約に違反する状態で存在することができます。ただし、外部キー制約が違反している限り、&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;は失敗します。</target>
        </trans-unit>
        <trans-unit id="4a9fe68ac2f3c48ea32a43f2c5cf9be89d342ee4" translate="yes" xml:space="preserve">
          <source>If a subquery cannot be &lt;a href=&quot;optoverview#flattening&quot;&gt;flattened&lt;/a&gt; into the outer query, it might still be possible to enhance performance by &quot;pushing down&quot; WHERE clause terms from the outer query into the subquery. Consider an example:</source>
          <target state="translated">サブクエリを外部クエリに&lt;a href=&quot;optoverview#flattening&quot;&gt;フラット化&lt;/a&gt;できない場合でも、外部クエリからサブクエリにWHERE句の用語を「プッシュダウン」することにより、パフォーマンスを向上させることができる場合があります。例を考えてみましょう：</target>
        </trans-unit>
        <trans-unit id="cfbdc72faddc3dd92eaf2d66d72d9166e0ce65e3" translate="yes" xml:space="preserve">
          <source>If a system failure occurs at any time after a &quot;delete file&quot; operation (call to the VFS xDelete() method) returns successfully, it is assumed that the file-system will not contain the deleted file following system recovery.</source>
          <target state="translated">ファイルの削除」操作(VFS xDelete()メソッドの呼び出し)が成功した後にシステム障害が発生した場合、システム回復後にファイルシステムに削除されたファイルが含まれないことが想定されます。</target>
        </trans-unit>
        <trans-unit id="c32e1e0b557aefde59c28d931cf3e5d6733099fd" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during a &quot;delete file&quot; operation, it is assumed that following system recovery the file-system will either contain the file being deleted in the state it was in before the operation was attempted, or not contain the file at all. It is assumed that it is not possible for the file to have become corrupted purely as a result of a failure occurring during a &quot;delete file&quot; operation.</source>
          <target state="translated">ファイルの削除」操作中にシステム障害が発生した場合、システム復旧後のファイルシステムには、削除しようとしているファイルが操作前の状態で格納されるか、ファイルが全く格納されないことが想定されています。ファイルの削除」操作中に発生した障害の結果、純粋にファイルが破損することはありえないと想定されます。</target>
        </trans-unit>
        <trans-unit id="91f96ef24748138cdd82c09ceabe7f648ae9cf43" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;create file&quot; operation, but before the created file has been</source>
          <target state="translated">ファイルの作成」操作中または操作後にシステム障害が発生した場合で、作成したファイルが</target>
        </trans-unit>
        <trans-unit id="1fcfee495c57582bc4c6e63019680717056464ec" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;truncate file&quot; operation, but before the truncated file has been</source>
          <target state="translated">ファイルの切り捨て」操作中または操作後に、切り捨てられたファイルが切り捨てられる前にシステム障害が発生した場合</target>
        </trans-unit>
        <trans-unit id="e3c60bc044d7ebf2be0e926e292ed7263d6ed54a" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;write file&quot; operation that causes the file to grow, but before the corresponding file has been</source>
          <target state="translated">ファイルの書き込み」操作中または操作後にシステム障害が発生してファイルが成長したが、対応するファイルが成長する前に</target>
        </trans-unit>
        <trans-unit id="0de8e98595413448f2b535870f8da207b8048237" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;write file&quot; operation, but before the corresponding file has been</source>
          <target state="translated">ファイルへの書き込み」操作中または操作後に、対応するファイルが作成される前にシステム障害が発生した場合</target>
        </trans-unit>
        <trans-unit id="12d84c274c03171c71b26275c99f75f3392362a6" translate="yes" xml:space="preserve">
          <source>If a system failure occurs on a system that supports the</source>
          <target state="translated">をサポートしているシステムでシステム障害が発生した場合</target>
        </trans-unit>
        <trans-unit id="70f739b455c168080412690c97f5940222b8f766" translate="yes" xml:space="preserve">
          <source>If a system supports</source>
          <target state="translated">システムが</target>
        </trans-unit>
        <trans-unit id="ec9800aa0fd4fbf6e94d5e57566c8304e2f2782b" translate="yes" xml:space="preserve">
          <source>If a system supports the</source>
          <target state="translated">をサポートしているシステムであれば</target>
        </trans-unit>
        <trans-unit id="16f55a3959edd0a92c0395b9cf4c3468da074f4f" translate="yes" xml:space="preserve">
          <source>If a table contains a column of type &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, then that column becomes an alias for the ROWID. You can then access the ROWID using any of four different names, the original three names described above or the name given to the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column. All these names are aliases for one another and work equally well in any context.</source>
          <target state="translated">テーブルに&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;型の列が含まれている場合、その列はROWIDのエイリアスになります。その後、4つの異なる名前、上記の元の3つの名前、または&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;列に指定された名前を使用して、ROWIDにアクセスできます。これらの名前はすべて相互のエイリアスであり、どのようなコンテキストでも同様に機能します。</target>
        </trans-unit>
        <trans-unit id="a73b6736040e74c7d625fd213eca9757c75eee19" translate="yes" xml:space="preserve">
          <source>If a table has a single column primary key and the declared type of that column is &quot;INTEGER&quot; and the table is not a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, then the column is known as an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;. See &lt;a href=&quot;lang_createtable#rowid&quot;&gt;below&lt;/a&gt; for a description of the special properties and behaviors associated with an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;.</source>
          <target state="translated">テーブルに単一列の主キーがあり、その列の宣言されたタイプが「INTEGER」であり、テーブルが&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルでない場合、その列は&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;と呼ばれます。&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEYに&lt;/a&gt;関連する特別なプロパティと動作の説明については、&lt;a href=&quot;lang_createtable#rowid&quot;&gt;以下&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="5e353db8a7a970978b864076f23349bbe29b3cd1" translate="yes" xml:space="preserve">
          <source>If a term in X is of the form &quot;z IS NOT NULL&quot; and if a term in W is a comparison operator on &quot;z&quot; other than &quot;IS&quot;, then those terms match.</source>
          <target state="translated">X の項が &quot;z IS NOT NULL&quot; の形式であり、W の項が &quot;IS&quot; 以外の &quot;z&quot; の比較演算子である場合、それらの項は一致します。</target>
        </trans-unit>
        <trans-unit id="d7704041f8ff8a11a4c662eef3d671025a3e5ebe" translate="yes" xml:space="preserve">
          <source>If a term of the WHERE clause is of the following form:</source>
          <target state="translated">WHERE句の項が以下の形式の場合。</target>
        </trans-unit>
        <trans-unit id="e5d671a1040d0448cbcd3997833359da102571a4" translate="yes" xml:space="preserve">
          <source>If a transaction involves multiple databases, then a more complex commit sequence is used, as follows:</source>
          <target state="translated">トランザクションが複数のデータベースを含む場合は、以下のように、より複雑なコミットシーケンスが使用されます。</target>
        </trans-unit>
        <trans-unit id="1b08d45fd51c4591fce14d3b424e9dccc579bef5" translate="yes" xml:space="preserve">
          <source>If a transaction is aborted due to an application crash, an operating system crash, or a hardware power failure or crash, then the database may be left in an inconsistent state. The next time SQLite attempts to open the database file, the presence of the rollback journal file will be detected and the journal will be automatically played back to restore the database to its state at the start of the incomplete transaction.</source>
          <target state="translated">アプリケーションのクラッシュ、オペレーティングシステムのクラッシュ、またはハードウェアの電源障害やクラッシュによってトランザクションが中断された場合、データベースは矛盾した状態のままになることがあります。次回SQLiteがデータベースファイルを開こうとすると、ロールバックジャーナルファイルの存在が検出され、ジャーナルが自動的に再生されてデータベースが不完全なトランザクションの開始時の状態に復元されます。</target>
        </trans-unit>
        <trans-unit id="b139c7ece8944c0ce3ad448cfb0c14ea14a36c67" translate="yes" xml:space="preserve">
          <source>If a write-transaction is open on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D when the &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk. A dirty page may be in use if a database cursor created by an active SQL statement is reading from it, or if it is page 1 of a database file (page 1 is always &quot;in use&quot;). The &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface flushes caches for all schemas - &quot;main&quot;, &quot;temp&quot;, and any &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; databases.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush（D）&lt;/a&gt;インターフェースが呼び出されたときに&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt; Dで書き込みトランザクションが開いている場合、現在使用されていないページャーキャッシュ内のダーティページがディスクに書き込まれます。アクティブなSQLステートメントによって作成されたデータベースカーソルがダーティページを読み取っている場合、またはダーティページがデータベースファイルのページ1である場合（ページ1は常に「使用中」）、ダーティページが使用されている可能性があります。&lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush（D）&lt;/a&gt;インターフェースは、すべてのスキーマのキャッシュをフラッシュ- 「メイン」、「TEMP」、および任意の&lt;a href=&quot;lang_attach&quot;&gt;添付の&lt;/a&gt;データベース。</target>
        </trans-unit>
        <trans-unit id="94598ac271e5cdca4a0d9c950ece2e2fde3c85ae" translate="yes" xml:space="preserve">
          <source>If a write-transaction is open on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D when the &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk. A dirty page may be in use if a database cursor created by an active SQL statement is reading from it, or if it is page 1 of a database file (page 1 is always &quot;in use&quot;). The &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface flushes caches for all schemas - &quot;main&quot;, &quot;temp&quot;, and any &lt;a href=&quot;../lang_attach&quot;&gt;attached&lt;/a&gt; databases.</source>
          <target state="translated">&lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush（D）&lt;/a&gt;インターフェースが呼び出されたときに&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt; Dで書き込みトランザクションが開いている場合、現在使用されていないページャーキャッシュ内のダーティページがディスクに書き込まれます。アクティブなSQLステートメントによって作成されたデータベースカーソルがダーティページを読み取っている場合、またはダーティページがデータベースファイルのページ1である場合（ページ1は常に「使用中」）、ダーティページが使用されている可能性があります。&lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush（D）&lt;/a&gt;インターフェースは、すべてのスキーマのキャッシュをフラッシュ- 「メイン」、「TEMP」、および任意の&lt;a href=&quot;../lang_attach&quot;&gt;添付の&lt;/a&gt;データベース。</target>
        </trans-unit>
        <trans-unit id="9d687ea67d2673f11d5b429c0195a169c2caa77a" translate="yes" xml:space="preserve">
          <source>If a write-transaction is started and the Vdbe.usesStmtJournal flag is true (this flag is set if the Vdbe may modify more than one row and may throw an ABORT exception), a statement transaction may also be opened. More specifically, a statement transaction is opened iff the database connection is currently not in autocommit mode, or if there are other active statements. A statement transaction allows the changes made by this VDBE to be rolled back after an error without having to roll back the entire transaction. If no error is encountered, the statement transaction will automatically commit when the VDBE halts.</source>
          <target state="translated">書き込みトランザクションが開始され、Vdbe.usesStmtJournalフラグがtrueの場合(このフラグは、Vdbeが複数の行を変更し、ABORT例外を投げる可能性がある場合に設定されます)、ステートメントトランザクションもオープンされる可能性があります。より具体的には、データベース接続が現在オートコミットモードではない場合、または他にアクティブなステートメントがある場合、ステートメント・トランザクションが開かれます。ステートメント・トランザクションは、トランザクション全体をロールバックすることなく、エラー後にこのVDBEによって行われた変更をロールバックすることを可能にする。エラーが発生しなかった場合、ステートメント・トランザクションはVDBEが停止したときに自動的にコミットされる。</target>
        </trans-unit>
        <trans-unit id="7e874d6b40d57619d9fa5fb8dd75a92de53ed059" translate="yes" xml:space="preserve">
          <source>If all three of the steps enumerated above are executed successfully, then it is safe to modify the content of the</source>
          <target state="translated">上に列挙した3つのステップのすべてが正常に実行された場合、それは</target>
        </trans-unit>
        <trans-unit id="8a9cfb8256efd43eaa74ef64ff226cfbf427865f" translate="yes" xml:space="preserve">
          <source>If an &quot;ALTER TABLE ... RENAME TO&quot; command is used to rename a table that is the parent table of one or more foreign key constraints, the definitions of the foreign key constraints are modified to refer to the parent table by its new name. The text of the child CREATE TABLE statement or statements stored in the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema table&lt;/a&gt; are modified to reflect the new parent table name.</source>
          <target state="translated">If an &quot;ALTER TABLE ... RENAME TO&quot; command is used to rename a table that is the parent table of one or more foreign key constraints, the definitions of the foreign key constraints are modified to refer to the parent table by its new name. The text of the child CREATE TABLE statement or statements stored in the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema table&lt;/a&gt; are modified to reflect the new parent table name.</target>
        </trans-unit>
        <trans-unit id="76124bb023821e31ac6f5cbf1f8b54083a3ec643" translate="yes" xml:space="preserve">
          <source>If an &quot;ALTER TABLE ... RENAME TO&quot; command is used to rename a table that is the parent table of one or more foreign key constraints, the definitions of the foreign key constraints are modified to refer to the parent table by its new name. The text of the child CREATE TABLE statement or statements stored in the sqlite_master table are modified to reflect the new parent table name.</source>
          <target state="translated">ALTER TABLE ...RENAME TO &quot;コマンドが、1つ以上の外部キー制約の親テーブルであるテーブルの名前を変更するために使用された場合、外部キー制約の定義は、新しい名前で親テーブルを参照するように変更されます。sqlite_masterテーブルに格納されている子CREATE TABLE文またはステートメントのテキストは、新しい親テーブル名を反映するように変更されます。</target>
        </trans-unit>
        <trans-unit id="7603e9a69b7a72c62bbc679327133633953ff9aa" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is destroyed while a transaction is open, the transaction is automatically rolled back.</source>
          <target state="translated">場合は&lt;a href=&quot;#sqlite3&quot;&gt;sqlite3の&lt;/a&gt;トランザクションが開いている間は、オブジェクトが破壊され、トランザクションが自動的にロールバックされます。</target>
        </trans-unit>
        <trans-unit id="53a3481d0fa9e30b2f0d27a6044ee94e1a62bb9b" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; occurs within a trigger then this routine will return the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the inserted row as long as the trigger is running. Once the trigger program ends, the value returned by this routine reverts to what it was before the trigger was fired.</source>
          <target state="translated">トリガー内で&lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;が発生した場合、このルーチンは、トリガーが実行されている限り、挿入された行の&lt;a href=&quot;../lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;を返します。トリガープログラムが終了すると、このルーチンによって返される値は、トリガーが起動される前の値に戻ります。</target>
        </trans-unit>
        <trans-unit id="877e1b4a7430ba11b48b32c5598ad0c65dc34442" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; occurs within a trigger then this routine will return the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the inserted row as long as the trigger is running. Once the trigger program ends, the value returned by this routine reverts to what it was before the trigger was fired.</source>
          <target state="translated">トリガー内で&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;が発生した場合、このルーチンは、トリガーが実行されている限り、挿入された行の&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;を返します。トリガープログラムが終了すると、このルーチンによって返される値は、トリガーが起動される前の値に戻ります。</target>
        </trans-unit>
        <trans-unit id="b95cb40fc8352b696796b3bff79e2f006b1ce07a" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is destroyed while a transaction is open, the transaction is automatically rolled back.</source>
          <target state="translated">場合は&lt;a href=&quot;sqlite3&quot;&gt;sqlite3の&lt;/a&gt;トランザクションが開いている間は、オブジェクトが破壊され、トランザクションが自動的にロールバックされます。</target>
        </trans-unit>
        <trans-unit id="9f62d9384e44621989efc3c00f1a3ba721b2e39d" translate="yes" xml:space="preserve">
          <source>If an FTS5 table is configured with columnsize=0 but is not a &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless table&lt;/a&gt;, the xColumnSize API function still works, but runs much more slowly. In this case, instead of reading the value to return directly from the database, it reads the text value itself and count the tokens within it on demand.</source>
          <target state="translated">FTS5テーブルがcolumnsize = 0で構成されているが、コンテンツのない&lt;a href=&quot;fts5#contentless_tables&quot;&gt;テーブル&lt;/a&gt;ではない場合、xColumnSize API関数は引き続き機能しますが、実行速度ははるかに遅くなります。この場合、データベースから直接返す値を読み取る代わりに、テキスト値自体を読み取り、要求に応じてその中のトークンをカウントします。</target>
        </trans-unit>
        <trans-unit id="a593df8166351f80d07eb58cb262614d9dbc8634" translate="yes" xml:space="preserve">
          <source>If an INSERT statement attempts to insert a NULL value into a rowid or integer primary key column, the system chooses an integer value to use as the rowid automatically. A detailed description of how this is done is provided &lt;a href=&quot;autoinc&quot;&gt;separately&lt;/a&gt;.</source>
          <target state="translated">INSERTステートメントがNULL値をROWIDまたは整数の主キー列に挿入しようとした場合、システムは、ROWIDとして使用する整数値を自動的に選択します。これがどのように行われるかの詳細な説明は、&lt;a href=&quot;autoinc&quot;&gt;別途&lt;/a&gt;提供されます。</target>
        </trans-unit>
        <trans-unit id="ba4158b1467dce3a1f2ceab9abb8de00b0fe4463" translate="yes" xml:space="preserve">
          <source>If an ORDER BY clause is present, it determines the order in which rows are extracted from the queue in step 2a. If there is no ORDER BY clause, then the order in which rows are extracted is undefined. (In the current implementation, the queue becomes a FIFO if the ORDER BY clause is omitted, but applications should not depend on that fact since it might change.)</source>
          <target state="translated">ORDER BY句が存在する場合、それはステップ2aでキューから行が抽出される順序を決定します。ORDER BY 句が存在しない場合、行が抽出される順序は未定義です。(現在の実装では、ORDER BY句が省略された場合、キューはFIFOになりますが、アプリケーションは変更される可能性があるので、その事実に依存すべきではありません)。</target>
        </trans-unit>
        <trans-unit id="22141c686821647d4155d6b151a8d8fa154cd1a8" translate="yes" xml:space="preserve">
          <source>If an SQL operation is very nearly finished at the time when sqlite3_interrupt() is called, then it might not have an opportunity to be interrupted and might continue to completion.</source>
          <target state="translated">sqlite3_interrupt()が呼ばれた時点でSQL操作がほぼ終了している場合は、中断する機会がなく、完了まで継続する可能性があります。</target>
        </trans-unit>
        <trans-unit id="923eabd2cf996c975383b0dccd3e5fb8dc063dde" translate="yes" xml:space="preserve">
          <source>If an SQL statement is limited to be a million bytes in length, then obviously you will not be able to insert multi-million byte strings by embedding them as literals inside of INSERT statements. But you should not do that anyway. Use host &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; for your data. Prepare short SQL statements like this:</source>
          <target state="translated">SQLステートメントの長さが100万バイトに制限されている場合は、INSERTステートメント内にリテラルとして埋め込んでも、数百万バイトの文字列を挿入することはできません。しかし、とにかくそれを行うべきではありません。データにホスト&lt;a href=&quot;lang_expr#varparam&quot;&gt;パラメータ&lt;/a&gt;を使用します。次のような短いSQLステートメントを準備します。</target>
        </trans-unit>
        <trans-unit id="a519000750401db43c985f6fefc862d71c74bede" translate="yes" xml:space="preserve">
          <source>If an SQL table is created using the &quot;WITHOUT ROWID&quot; clause at the end of its CREATE TABLE statement, then that table is a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table and uses a different on-disk representation. A WITHOUT ROWID table uses an index b-tree rather than a table b-tree for storage. The key for each entry in the WITHOUT ROWID b-tree is a record composed of the columns of the PRIMARY KEY followed by all remaining columns of the table. The primary key columns appear in the order they they were declared in the PRIMARY KEY clause and the remaining columns appear in the order they occur in the CREATE TABLE statement.</source>
          <target state="translated">SQLテーブルがCREATE TABLEステートメントの最後にある「WITHOUT ROWID」句を使用して作成されている場合、そのテーブルは&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt;テーブルであり、別のディスク上の表現を使用します。WITHOUT ROWIDテーブルは、テーブルbツリーではなくインデックスbツリーを使用して格納します。WITHOUT ROWID Bツリーの各エントリのキーは、PRIMARY KEYの列とそれに続くテーブルの残りのすべての列で構成されるレコードです。主キー列は、PRIMARY KEY句で宣言された順序で表示され、残りの列は、CREATE TABLEステートメントで発生した順序で表示されます。</target>
        </trans-unit>
        <trans-unit id="7a1f15ef308e23ec2fc80a29e25882265ebf0786" translate="yes" xml:space="preserve">
          <source>If an UPDATE statement attempts to set an integer primary key or rowid column to a NULL or blob value, or to a string or real value that cannot be losslessly converted to an integer, a &quot;datatype mismatch&quot; error occurs and the statement is aborted. If an INSERT statement attempts to insert a blob value, or a string or real value that cannot be losslessly converted to an integer into an integer primary key or rowid column, a &quot;datatype mismatch&quot; error occurs and the statement is aborted.</source>
          <target state="translated">UPDATE 文が、整数の主キーまたは rowid 列を NULL または blob 値、または可逆的に整数に変換できない文字列または実数値に設定しようとすると、&quot;datatype mismatch&quot; エラーが発生し、文が中断されます。INSERT 文が、ブロブ値、または可逆的に整数に変換できない文字列または実数値を整数の主キーまたは rowid 列に挿入しようとすると、&quot;datatype mismatch&quot; エラーが発生し、文が中断されます。</target>
        </trans-unit>
        <trans-unit id="284b34da69fbf9cd89926df318af7634184253b9" translate="yes" xml:space="preserve">
          <source>If an UPDATE statement has a LIMIT clause, the maximum number of rows that will be updated is found by evaluating the accompanying expression and casting it to an integer value. A negative value is interpreted as &quot;no limit&quot;.</source>
          <target state="translated">UPDATE文にLIMIT句がある場合、更新される行の最大数は、付属の式を評価して整数値にキャストすることで求められます。負の値は「制限なし」と解釈されます。</target>
        </trans-unit>
        <trans-unit id="35654cca0e06875d8f71c06cdb825a502007ac27" translate="yes" xml:space="preserve">
          <source>If an application issues a SELECT statement on a single table like &quot;</source>
          <target state="translated">アプリケーションが、&quot; のような単一のテーブルに対して SELECT 文を発行した場合</target>
        </trans-unit>
        <trans-unit id="3c9847a3fc8345f21ef2aae877b6da29936db6dc" translate="yes" xml:space="preserve">
          <source>If an application puts SQLite in &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; using the pragma:</source>
          <target state="translated">アプリケーションがプラグマを使用してSQLiteを&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;排他ロックモードにする&lt;/a&gt;場合：</target>
        </trans-unit>
        <trans-unit id="16930c87a89e5aa4dacec21b97a534c286412312" translate="yes" xml:space="preserve">
          <source>If an application using asynchronous IO executes transactions in quick succession, other database users may be effectively locked out of the database. This is because when a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; is executed, a database lock is established immediately. But when the corresponding COMMIT or ROLLBACK occurs, the lock is not released until the relevant part of the write-queue has been flushed through. As a result, if a COMMIT is followed by a BEGIN before the write-queue is flushed through, the database is never unlocked,preventing other processes from accessing the database.</source>
          <target state="translated">非同期IOを使用するアプリケーションが連続してトランザクションを実行すると、他のデータベースユーザーがデータベースから事実上ロックアウトされる可能性があります。これは、&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;が実行されると、データベースロックがすぐに確立されるためです。ただし、対応するCOMMITまたはROLLBACKが発生すると、書き込みキューの関連部分がフラッシュされるまで、ロックは解放されません。その結果、書き込みキューがフラッシュされる前にCOMMITの後にBEGINが続く場合、データベースはロック解除されず、他のプロセスがデータベースにアクセスできなくなります。</target>
        </trans-unit>
        <trans-unit id="dec67a679cc10b4fb4ca0df679f1b42a8a809bf0" translate="yes" xml:space="preserve">
          <source>If an attempt to acquire a</source>
          <target state="translated">を取得しようとすると</target>
        </trans-unit>
        <trans-unit id="ae2dad7a2ac6f9639d4f707a82a9b585c9a56bd8" translate="yes" xml:space="preserve">
          <source>If an attempt to upgrade to an</source>
          <target state="translated">にアップグレードしようとすると</target>
        </trans-unit>
        <trans-unit id="0f4ee50fd2b5b886cf93345554e2cb331273f09d" translate="yes" xml:space="preserve">
          <source>If an error (e.g. an OOM condition) occurs within this function, the auxiliary data is set to NULL and an error code returned. If the xDelete parameter was not NULL, it is invoked on the auxiliary data pointer before returning.</source>
          <target state="translated">この関数内でエラー(OOM条件など)が発生した場合、補助データはNULLに設定され、エラーコードが返されます。xDeleteパラメータがNULLでなかった場合は、返す前に補助データポインタで呼び出されます。</target>
        </trans-unit>
        <trans-unit id="8045cc0ef3fd13ca44d5e4369a94674b9f7300cd" translate="yes" xml:space="preserve">
          <source>If an error occurs in any of the three main backup API routines then the &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; and &lt;a href=&quot;c3ref/errcode&quot;&gt;message&lt;/a&gt; are attached to the destination &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. Additionally, if &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; encounters an error, then the &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned by both the &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; call itself, and by the subsequent call to &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt;. So a call to &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt; does not overwrite an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; stored in the destination &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; by &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt;. This feature is used in the example code to reduce amount of error handling required. The return values of the &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; and &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt; calls are ignored and the error code indicating the success or failure of the copy operation collected from the destination &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; afterward.</source>
          <target state="translated">3つのメインバックアップAPIルーチンのいずれかでエラーが発生した場合、エラー&lt;a href=&quot;rescode&quot;&gt;コード&lt;/a&gt;と&lt;a href=&quot;c3ref/errcode&quot;&gt;メッセージ&lt;/a&gt;が宛先&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続に&lt;/a&gt;添付されます。さらに、もし&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step（）&lt;/a&gt;次に、エラーが発生した&lt;a href=&quot;rescode&quot;&gt;エラーコードが&lt;/a&gt;両方によって返され&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;（）sqlite3_backup_step&lt;/a&gt;自体を呼び出し、以降の呼び出しによって&lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish（） &lt;/a&gt;。そうへの呼び出し&lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish（）が&lt;/a&gt;上書きされない&lt;a href=&quot;rescode&quot;&gt;エラーコード&lt;/a&gt;先に格納された&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;によって&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_stepを（）&lt;/a&gt;。この機能はサンプルコードで使用され、必要なエラー処理の量を減らします。&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step（）&lt;/a&gt;および&lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish（）&lt;/a&gt;呼び出しの戻り値は無視され、コピー先の&lt;a href=&quot;c3ref/sqlite3&quot;&gt;データベース接続&lt;/a&gt;から収集されたコピー操作の成功または失敗を示すエラーコードが後で収集されます。</target>
        </trans-unit>
        <trans-unit id="e8416d9f169797cd1d1df3d689a0f3981d1e1914" translate="yes" xml:space="preserve">
          <source>If an error occurs while evaluating the SQL statements passed into sqlite3_exec(), then execution of the current statement stops and subsequent statements are skipped. If the 5th parameter to sqlite3_exec() is not NULL then any error message is written into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and passed back through the 5th parameter. To avoid memory leaks, the application should invoke &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; on error message strings returned through the 5th parameter of sqlite3_exec() after the error message string is no longer needed. If the 5th parameter to sqlite3_exec() is not NULL and no errors occur, then sqlite3_exec() sets the pointer in its 5th parameter to NULL before returning.</source>
          <target state="translated">sqlite3_exec（）に渡されたSQLステートメントの評価中にエラーが発生した場合、現在のステートメントの実行は停止し、後続のステートメントはスキップされます。 sqlite3_exec（）の5番目のパラメーターがNULLでない場合、エラーメッセージは&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;から取得したメモリに書き込まれ、5番目のパラメーターを介して渡されます。メモリリークを回避するために、アプリケーションは、エラーメッセージ文字列が不要になった後、sqlite3_exec（）の5番目のパラメータを通じて返されるエラーメッセージ文字列で&lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free（）&lt;/a&gt;を呼び出す必要があります。 sqlite3_exec（）の5番目のパラメーターがNULLではなく、エラーが発生しない場合、sqlite3_exec（）は5番目のパラメーターのポインターをNULLに設定してから戻ります。</target>
        </trans-unit>
        <trans-unit id="67c739deca1fc659fe9011cffdf430f71e9a737b" translate="yes" xml:space="preserve">
          <source>If an error occurs while evaluating the SQL statements passed into sqlite3_exec(), then execution of the current statement stops and subsequent statements are skipped. If the 5th parameter to sqlite3_exec() is not NULL then any error message is written into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and passed back through the 5th parameter. To avoid memory leaks, the application should invoke &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; on error message strings returned through the 5th parameter of sqlite3_exec() after the error message string is no longer needed. If the 5th parameter to sqlite3_exec() is not NULL and no errors occur, then sqlite3_exec() sets the pointer in its 5th parameter to NULL before returning.</source>
          <target state="translated">sqlite3_exec（）に渡されたSQLステートメントの評価中にエラーが発生した場合、現在のステートメントの実行は停止し、後続のステートメントはスキップされます。 sqlite3_exec（）の5番目のパラメーターがNULLでない場合、エラーメッセージは&lt;a href=&quot;free&quot;&gt;sqlite3_malloc（）&lt;/a&gt;から取得したメモリに書き込まれ、5番目のパラメーターを介して渡されます。メモリリークを回避するために、アプリケーションは、エラーメッセージ文字列が不要になった後、sqlite3_exec（）の5番目のパラメータを通じて返されるエラーメッセージ文字列で&lt;a href=&quot;free&quot;&gt;sqlite3_free（）&lt;/a&gt;を呼び出す必要があります。 sqlite3_exec（）の5番目のパラメーターがNULLではなく、エラーが発生しない場合、sqlite3_exec（）は5番目のパラメーターのポインターをNULLに設定してから戻ります。</target>
        </trans-unit>
        <trans-unit id="194a0b44e46a56e474b265407cd79a961ab1ee3b" translate="yes" xml:space="preserve">
          <source>If an error occurs within sqlite3_backup_init(D,N,S,M), then NULL is returned and an error code and error message are stored in the destination &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D. The error code and message for the failed call to sqlite3_backup_init() can be retrieved using the &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;, and/or &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt; functions. A successful call to sqlite3_backup_init() returns a pointer to an &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object. The &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object may be used with the sqlite3_backup_step() and sqlite3_backup_finish() functions to perform the specified backup operation.</source>
          <target state="translated">sqlite3_backup_init（D、N、S、M）内でエラーが発生した場合、NULLが返され、エラーコードとエラーメッセージが宛先&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続&lt;/a&gt; Dに格納されます。sqlite3_backup_init（）の呼び出しが失敗した場合のエラーコードとメッセージは&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;、&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;、または&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg16（）&lt;/a&gt;関数を使用して取得する。 sqlite3_backup_init（）の呼び出しが成功すると、&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt;オブジェクトへのポインタが返されます。&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backupの&lt;/a&gt;オブジェクトが指定されたバックアップ操作を実行するsqlite3_backup_step（）とsqlite3_backup_finish（）関数で使用されてもよいです。</target>
        </trans-unit>
        <trans-unit id="1200818faf5a8fe2f6854c6a6851d33b2f623b3d" translate="yes" xml:space="preserve">
          <source>If an error occurs within sqlite3_backup_init(D,N,S,M), then NULL is returned and an error code and error message are stored in the destination &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D. The error code and message for the failed call to sqlite3_backup_init() can be retrieved using the &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt;, &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;, and/or &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt; functions. A successful call to sqlite3_backup_init() returns a pointer to an &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object. The &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object may be used with the sqlite3_backup_step() and sqlite3_backup_finish() functions to perform the specified backup operation.</source>
          <target state="translated">sqlite3_backup_init（D、N、S、M）内でエラーが発生した場合、NULLが返され、エラーコードとエラーメッセージが宛先&lt;a href=&quot;sqlite3&quot;&gt;データベース接続&lt;/a&gt; Dに格納されます。sqlite3_backup_init（）の呼び出しが失敗した場合のエラーコードとメッセージは&lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;、&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg（）&lt;/a&gt;、または&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg16（）&lt;/a&gt;関数を使用して取得する。 sqlite3_backup_init（）の呼び出しが成功すると、&lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt;オブジェクトへのポインタが返されます。&lt;a href=&quot;backup&quot;&gt;sqlite3_backupの&lt;/a&gt;オブジェクトが指定されたバックアップ操作を実行するsqlite3_backup_step（）とsqlite3_backup_finish（）関数で使用されてもよいです。</target>
        </trans-unit>
        <trans-unit id="100ded69e0a780b44961df68d1032c0e7c075797" translate="yes" xml:space="preserve">
          <source>If an error occurs, an SQLite error code is returned and the output variables (*pnData) and (*ppData) are set to 0. Otherwise, SQLITE_OK is returned and the output variables are set to the size of and a pointer to the output buffer, respectively. In this case it is the responsibility of the caller to eventually free the buffer using a call to sqlite3_free().</source>
          <target state="translated">エラーが発生した場合、SQLiteエラーコードが返され、出力変数(*pnData)と(*ppData)に0が設定されます。 そうでなければ、SQLITE_OKが返され、出力変数にはそれぞれ出力バッファのサイズとポインタが設定されます。この場合、最終的にsqlite3_free()を呼び出してバッファを解放するのは呼び出し元の責任です。</target>
        </trans-unit>
        <trans-unit id="622e26e115262f02ac7f60da2462323cdc540b9f" translate="yes" xml:space="preserve">
          <source>If an error occurs, an SQLite error code is returned. Possible error codes include SQLITE_CORRUPT (if the changeset buffer is corrupt) or SQLITE_NOMEM.</source>
          <target state="translated">エラーが発生した場合、SQLite エラーコードが返されます。考えられるエラーコードには、SQLITE_CORRUPT (チェンジセットバッファが破損している場合)や SQLITE_NOMEM があります。</target>
        </trans-unit>
        <trans-unit id="e455ebdd54ae8a16893e6de74ee6f1db7c5e35d7" translate="yes" xml:space="preserve">
          <source>If an error was encountered within a call to an sqlite3changeset_xxx() function (for example an &lt;a href=&quot;../rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; in &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; or an &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; in &lt;a href=&quot;sqlite3changeset_new&quot;&gt;sqlite3changeset_new()&lt;/a&gt;) then an error code corresponding to that error is returned by this function. Otherwise, SQLITE_OK is returned. This is to allow the following pattern (pseudo-code):</source>
          <target state="translated">エラーがsqlite3changeset_xxx（）関数の呼び出し（例えば内で発生した場合&lt;a href=&quot;../rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt;で&lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）&lt;/a&gt;または&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;における&lt;a href=&quot;sqlite3changeset_new&quot;&gt;（）sqlite3changeset_new&lt;/a&gt;）、そのエラーに対応するエラーコードは、この関数によって返されます。それ以外の場合、SQLITE_OKが返されます。これは、次のパターン（疑似コード）を許可するためのものです。</target>
        </trans-unit>
        <trans-unit id="1bc5bca387ff960fe9687401573a47507a4fa49f" translate="yes" xml:space="preserve">
          <source>If an error was encountered within a call to an sqlite3changeset_xxx() function (for example an &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; in &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; or an &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; in &lt;a href=&quot;#sqlite3changeset_new&quot;&gt;sqlite3changeset_new()&lt;/a&gt;) then an error code corresponding to that error is returned by this function. Otherwise, SQLITE_OK is returned. This is to allow the following pattern (pseudo-code):</source>
          <target state="translated">エラーがsqlite3changeset_xxx（）関数の呼び出し（例えば内で発生した場合&lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt;で&lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next（）&lt;/a&gt;または&lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;における&lt;a href=&quot;#sqlite3changeset_new&quot;&gt;（）sqlite3changeset_new&lt;/a&gt;）、そのエラーに対応するエラーコードは、この関数によって返されます。それ以外の場合、SQLITE_OKが返されます。これは、次のパターン（疑似コード）を許可するためのものです。</target>
        </trans-unit>
        <trans-unit id="1b680ceb7d64040ce2b6564485c5ca5b1c9689a0" translate="yes" xml:space="preserve">
          <source>If an fts5vocab table is created in the temp database, it may be associated with an FTS5 table in any attached database. In order to attach the fts5vocab table to an FTS5 table located in a database other than &quot;temp&quot;, the name of the database is inserted before the FTS5 table name in the CREATE VIRTUAL TABLE arguments. For example:</source>
          <target state="translated">temp データベースに fts5vocab テーブルが作成された場合、どのようなアタッチされたデータベースの FTS5 テーブルにも関連付けることができます。temp」以外のデータベースにあるFTS5テーブルにfts5vocabテーブルをアタッチするには、CREATE VIRTUAL TABLE引数でFTS5テーブル名の前にデータベース名を挿入します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="3334fd5a8f49d3b3b23387e0ded39340f08eab83" translate="yes" xml:space="preserve">
          <source>If an index is available on the ORDER BY column, that index can be used for sorting. Consider the request for all items sorted by &quot;fruit&quot;:</source>
          <target state="translated">ORDER BYカラムにインデックスがある場合、そのインデックスをソートに使用することができます。fruit」でソートされたすべてのアイテムのリクエストを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="7ff3ecb138d9749f1bf1bb734a03098e601b851c" translate="yes" xml:space="preserve">
          <source>If an index is created using a statement like this:</source>
          <target state="translated">このようなステートメントを使用してインデックスを作成した場合。</target>
        </trans-unit>
        <trans-unit id="19ed5776fff64746115879da20e80724a2114442" translate="yes" xml:space="preserve">
          <source>If an instance-list grows so large that it exceeds the &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; limit, FTS3/4 is unable to handle it. FTS5 does not have this problem.</source>
          <target state="translated">インスタンスリストが大きくなり&lt;a href=&quot;limits#max_length&quot;&gt;すぎてSQLITE_MAX_LENGTHの&lt;/a&gt;制限を超えた場合、FTS3 / 4はそれを処理できません。FTS5にはこの問題はありません。</target>
        </trans-unit>
        <trans-unit id="e669868d5fcfe552cb1dbbc9c2998f5505f629e6" translate="yes" xml:space="preserve">
          <source>If an interface fails with SQLITE_MISUSE, that means the interface was invoked incorrectly by the application. In that case, the error code and message may or may not be set.</source>
          <target state="translated">インターフェイスが SQLITE_MISUSE で失敗した場合、それはアプリケーションによってインターフェイスが誤って呼び出されたことを意味します。その場合、エラーコードとメッセージは設定されているか、設定されていないかもしれません。</target>
        </trans-unit>
        <trans-unit id="582fb0780f4838faf9f9c1524bd108b2fc64370c" translate="yes" xml:space="preserve">
          <source>If an out-of-memory error occurs, then the return value from these routines is the same as if the column had contained an SQL NULL value. Valid SQL NULL returns can be distinguished from out-of-memory errors by invoking the &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; immediately after the suspect return value is obtained and before any other SQLite interface is called on the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">メモリ不足エラーが発生した場合、これらのルーチンからの戻り値は、列にSQL NULL値が含まれていた場合と同じです。有効なSQL NULL戻り値は、疑わしい戻り値が取得された直後で、同じ&lt;a href=&quot;#sqlite3&quot;&gt;データベース接続で&lt;/a&gt;他のSQLiteインターフェイスが呼び出される前に&lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;を呼び出すことにより、メモリ不足エラーと区別できます。</target>
        </trans-unit>
        <trans-unit id="5851016a3fb15ec26147b80722e832005884d3e4" translate="yes" xml:space="preserve">
          <source>If an out-of-memory error occurs, then the return value from these routines is the same as if the column had contained an SQL NULL value. Valid SQL NULL returns can be distinguished from out-of-memory errors by invoking the &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; immediately after the suspect return value is obtained and before any other SQLite interface is called on the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">メモリ不足エラーが発生した場合、これらのルーチンからの戻り値は、列にSQL NULL値が含まれていた場合と同じです。有効なSQL NULL戻り値は、疑わしい戻り値が取得された直後で、同じ&lt;a href=&quot;sqlite3&quot;&gt;データベース接続で&lt;/a&gt;他のSQLiteインターフェイスが呼び出される前に&lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode（）&lt;/a&gt;を呼び出すことにより、メモリ不足エラーと区別できます。</target>
        </trans-unit>
        <trans-unit id="53a860ff4ceaa780f514879a263f3e2bd7a64b45" translate="yes" xml:space="preserve">
          <source>If an sqlite3_exec() callback returns non-zero, the sqlite3_exec() routine returns SQLITE_ABORT without invoking the callback again and without running any subsequent SQL statements.</source>
          <target state="translated">sqlite3_exec()コールバックが0以外の値を返した場合、sqlite3_exec()ルーチンは、コールバックを再度呼び出さず、それ以降のSQL文を実行せずにSQLITE_ABORTを返します。</target>
        </trans-unit>
        <trans-unit id="86f2a1856f49f287cef6815b989e3bcfc9f7c019" translate="yes" xml:space="preserve">
          <source>If an update is only partially applied to the target database by the time sqlite3rbu_close() is called, state information is saved within the state database if it exists, or otherwise in the RBU database. This allows subsequent processes to automatically resume the RBU update from where it left off. If state information is stored in the RBU database, it can be removed by dropping all tables whose names begin with &quot;rbu_&quot;.</source>
          <target state="translated">sqlite3rbu_close()が呼び出されるまでにターゲット・データベースに更新が部分的にしか適用されない場合、状態情報は状態データベースが存在する場合は状態データベース内に、そうでない場合はRBUデータベース内に保存されます。これにより、後続のプロセスは、RBU更新を中断したところから自動的に再開することができます。状態情報がRBUデータベースに保存されている場合、名前が &quot;rbu_&quot;で始まるすべてのテーブルを削除することで削除することができる。</target>
        </trans-unit>
        <trans-unit id="bd175412c5f187514ee87168844f1bedfa975635" translate="yes" xml:space="preserve">
          <source>If an xToken() callback returns any value other than SQLITE_OK, then the tokenization should be abandoned and the xTokenize() method should immediately return a copy of the xToken() return value. Or, if the input buffer is exhausted, xTokenize() should return SQLITE_OK. Finally, if an error occurs with the xTokenize() implementation itself, it may abandon the tokenization and return any error code other than SQLITE_OK or SQLITE_DONE.</source>
          <target state="translated">xToken()コールバックが SQLITE_OK 以外の値を返す場合は、トークン化を放棄して xTokenize()メソッドは直ちに xToken()の戻り値のコピーを返すべきです。あるいは、入力バッファを使い切った場合は、xTokenize()は SQLITE_OK を返すべきです。最後に、xTokenize()の実装自体にエラーが発生した場合、トークン化を放棄して SQLITE_OK または SQLITE_DONE 以外のエラーコードを返すことがあります。</target>
        </trans-unit>
        <trans-unit id="0be452758cf5838f411f1a08b26770962254070e" translate="yes" xml:space="preserve">
          <source>If and only if the previously described conversion of OR to an IN operator does not work, the second OR-clause optimization is attempted. Suppose the OR clause consists of multiple subterms as follows:</source>
          <target state="translated">前述のORからIN演算子への変換がうまくいかない場合にのみ、2番目のOR句の最適化を試みます。OR句が以下のように複数のサブタームで構成されているとします。</target>
        </trans-unit>
        <trans-unit id="1d92fd7f31be8d1f3061a17050b41ab1479f4bcd" translate="yes" xml:space="preserve">
          <source>If another database connection has the database mode open in &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; then all queries against the database will return &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. Both Chrome and Firefox open their database files in exclusive locking mode, so attempts to read Chrome or Firefox databases while the applications are running will run into this problem, for example.</source>
          <target state="translated">別のデータベース接続がデータベースモードを&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;排他ロックモードで&lt;/a&gt;開いている場合、データベースに対するすべてのクエリは&lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;を返します。ChromeとFirefoxはどちらもデータベースファイルを排他ロックモードで開くため、たとえば、アプリケーションの実行中にChromeまたはFirefoxデータベースを読み取ろうとすると、この問題が発生します。</target>
        </trans-unit>
        <trans-unit id="52c07a908a81f106b3dd1bc1b1492081c7a35d47" translate="yes" xml:space="preserve">
          <source>If another thread changes the autocommit status of the database connection while this routine is running, then the return value is undefined.</source>
          <target state="translated">このルーチンの実行中に別のスレッドがデータベース接続のオートコミット状態を変更した場合、戻り値は未定義です。</target>
        </trans-unit>
        <trans-unit id="8503a498072091f7cabc2db6a10e976de9bc12b1" translate="yes" xml:space="preserve">
          <source>If another thread or process writes to the source database while this function is sleeping, then SQLite detects this and usually restarts the backup process when sqlite3_backup_step() is next called. There is one exception to this rule: If the source database is not an in-memory database, and the write is performed from within the same process as the backup operation and uses the same database handle (pDb), then the destination database (the one opened using connection pFile) is automatically updated along with the source. The backup process may then be continued after the sqlite3_sleep() call returns as if nothing had happened.</source>
          <target state="translated">この関数がスリープしている間に別のスレッドやプロセスがソース・データベースに書き込みを行った場合、SQLiteはこれを検出し、sqlite3_backup_step()が次に呼び出されたときに通常はバックアップ・プロセスを再起動します。このルールには1つの例外があります:ソースデータベースがインメモリデータベースではなく、書き込みがバックアップ処理と同じプロセス内で行われ、同じデータベースハンドル(pDb)を使用している場合、宛先データベース(接続pFileを使用してオープンされたデータベース)はソースと共に自動的に更新されます。バックアップ処理はsqlite3_sleep()コールが何も起きなかったかのように戻った後も継続されます。</target>
        </trans-unit>
        <trans-unit id="b9f8be087686590dab771595e5bd54b7d246dba5" translate="yes" xml:space="preserve">
          <source>If any errors are encountered during compilation, an error message is written into memory obtained from &lt;b&gt;malloc&lt;/b&gt; and the 5th parameter is made to point to that memory. If the 5th parameter is NULL, then no error message is generated. If the 5th parameter is not NULL, then the calling function should dispose of the memory containing the error message by calling &lt;b&gt;sqlite_freemem&lt;/b&gt;.</source>
          <target state="translated">コンパイル中にエラーが発生した場合、エラーメッセージが&lt;b&gt;malloc&lt;/b&gt;から取得されたメモリに書き込まれ、5番目のパラメータがそのメモリを指すようになります。 5番目のパラメータがNULLの場合、エラーメッセージは生成されません。 5番目のパラメータがNULLでない場合、呼び出し元の関数は&lt;b&gt;sqlite_freemem&lt;/b&gt;を呼び出して、エラーメッセージを含むメモリを&lt;b&gt;破棄する必要があり&lt;/b&gt;ます。</target>
        </trans-unit>
        <trans-unit id="83125f64332cc16259858298cfafac27aca598bf" translate="yes" xml:space="preserve">
          <source>If any of the special-case entries shows above are omitted, then the value of 100 is used for insertion and deletion and 150 is used for substitution. To disable the default insertion, deletion, and/or substitution set their respective cost to 10000 or more.</source>
          <target state="translated">上記の特殊文字列が省略された場合は、挿入・削除に100、置換に150を使用します。デフォルトの挿入・削除・置換を無効にするには、それぞれのコストを10000以上に設定してください。</target>
        </trans-unit>
        <trans-unit id="8b09289d91105f4036d96455156f97ad8f84efdf" translate="yes" xml:space="preserve">
          <source>If any of the sqlite3_bind_*() routines are called with a NULL pointer for the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; or with a prepared statement for which &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; has been called more recently than &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, then the call will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. If any sqlite3_bind_() routine is passed a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; that has been finalized, the result is undefined and probably harmful.</source>
          <target state="translated">sqlite3_bindのいずれか_ *（）ルーチンがためにNULLポインタで呼び出された場合は&lt;a href=&quot;#sqlite3_stmt&quot;&gt;プリペアドステートメント&lt;/a&gt;またはのために準備されたステートメントで&lt;a href=&quot;#sqlite3_step&quot;&gt;（sqlite3_step）&lt;/a&gt;最近になっ超えると呼ばれてきた&lt;a href=&quot;#sqlite3_reset&quot;&gt;（sqlite3_reset） &lt;/a&gt;、コールは戻ります&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSEを&lt;/a&gt;。 sqlite3_bind_（）ルーチンに、ファイナライズ済みの&lt;a href=&quot;#sqlite3_stmt&quot;&gt;準備済みステートメント&lt;/a&gt;が渡された場合、結果は定義されておらず、おそらく有害です。</target>
        </trans-unit>
        <trans-unit id="4d6ffdf1dd2e882d0d92b18297a217958bf3b943" translate="yes" xml:space="preserve">
          <source>If any of the sqlite3_bind_*() routines are called with a NULL pointer for the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; or with a prepared statement for which &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; has been called more recently than &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, then the call will return &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. If any sqlite3_bind_() routine is passed a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; that has been finalized, the result is undefined and probably harmful.</source>
          <target state="translated">sqlite3_bindのいずれか_ *（）ルーチンがためにNULLポインタで呼び出された場合は&lt;a href=&quot;stmt&quot;&gt;プリペアドステートメント&lt;/a&gt;またはのために準備されたステートメントで&lt;a href=&quot;step&quot;&gt;（sqlite3_step）&lt;/a&gt;最近になっ超えると呼ばれてきた&lt;a href=&quot;reset&quot;&gt;（sqlite3_reset） &lt;/a&gt;、コールは戻ります&lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSEを&lt;/a&gt;。 sqlite3_bind_（）ルーチンに、ファイナライズ済みの&lt;a href=&quot;stmt&quot;&gt;準備済みステートメント&lt;/a&gt;が渡された場合、結果は定義されておらず、おそらく有害です。</target>
        </trans-unit>
        <trans-unit id="ecc451199e804c2d9bbaab7eeb8ae7260c861c03" translate="yes" xml:space="preserve">
          <source>If any of these options are defined, then the same set of SQLITE_OMIT_* options must also be defined when using the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; tool to generate the parse.c file and when compiling the 'mkkeywordhash' tool which generates the keywordhash.h file. Because of this, these options may only be used when the library is built from canonical source, not from the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. Some SQLITE_OMIT_* options might work, or appear to work, when used with the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. But this is not guaranteed. In general, always compile from canonical sources in order to take advantage of SQLITE_OMIT_* options.</source>
          <target state="translated">これらのオプションのいずれかが定義されている場合、&lt;a href=&quot;lemon&quot;&gt;レモンパーサージェネレーター&lt;/a&gt;ツールを使用してparse.cファイルを生成するとき、およびkeywordhash.hファイルを生成する 'mkkeywordhash'ツールをコンパイルするときに、同じSQLITE_OMIT_ *オプションのセットも定義する必要があります。このため、これらのオプションは、ライブラリが&lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;からではなく、正規のソースから構築されている場合にのみ使用できます。一部のSQLITE_OMIT_ *オプションは、&lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;と一緒に使用すると機能するか、機能しているように見えます。しかし、これは保証されていません。一般に、SQLITE_OMIT_ *オプションを利用するには、常に正規のソースからコンパイルしてください。</target>
        </trans-unit>
        <trans-unit id="066af8ac5653f5f78e3e77b86a9535152f8106eb" translate="yes" xml:space="preserve">
          <source>If any other constraint violation occurs while applying a change (i.e. a UNIQUE, CHECK or NOT NULL constraint), the conflict handler is invoked with CHANGESET_CONSTRAINT as the second argument.</source>
          <target state="translated">変更の適用中に他の制約違反が発生した場合(すなわち、UNIQUE、CHECK、NOT NULL 制約)、第二引数として CHANGESET_CONSTRAINT を使用してコンフリクトハンドラが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="c1ffcbd8edc1e59c920bc1e42ef8ae6a08f1c489" translate="yes" xml:space="preserve">
          <source>If any other error occurs while flushing dirty pages to disk (for example an IO error or out-of-memory condition), then processing is abandoned and an SQLite &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned to the caller immediately.</source>
          <target state="translated">ダーティページをディスクにフラッシュしている間に他のエラー（IOエラーやメモリ不足状態など）が発生した場合、処理は中止され、SQLite &lt;a href=&quot;../rescode&quot;&gt;エラーコード&lt;/a&gt;が呼び出し元にすぐに返されます。</target>
        </trans-unit>
        <trans-unit id="547159ba42f3dd194cd2ac6c73df9dfb51226b89" translate="yes" xml:space="preserve">
          <source>If any other error occurs while flushing dirty pages to disk (for example an IO error or out-of-memory condition), then processing is abandoned and an SQLite &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned to the caller immediately.</source>
          <target state="translated">ダーティページをディスクにフラッシュしている間に他のエラー（IOエラーやメモリ不足状態など）が発生した場合、処理は中止され、SQLite &lt;a href=&quot;rescode&quot;&gt;エラーコード&lt;/a&gt;が呼び出し元にすぐに返されます。</target>
        </trans-unit>
        <trans-unit id="ed9a42f661215804821abb386ff5f31ffa1294e2" translate="yes" xml:space="preserve">
          <source>If any prior errors have occurred while constructing the dynamic string in sqlite3_str X, then the &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method will return an appropriate error code. The &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; following any out-of-memory error, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; if the size of the dynamic string exceeds &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if there have been no errors.</source>
          <target state="translated">sqlite3_str Xで動的文字列を構築しているときに以前のエラーが発生した場合、&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode（X）&lt;/a&gt;メソッドは適切なエラーコードを返します。&lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode（X）&lt;/a&gt;メソッド戻り、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;任意のメモリ不足エラー、または以下&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_TOOBIG&lt;/a&gt;動的文字列のサイズを超える場合&lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;、又は&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OKに&lt;/a&gt;エラーがなかった場合。</target>
        </trans-unit>
        <trans-unit id="2797997123bd9f48d4b03d213989316f5ee2db3a" translate="yes" xml:space="preserve">
          <source>If any prior errors have occurred while constructing the dynamic string in sqlite3_str X, then the &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method will return an appropriate error code. The &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method returns &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; following any out-of-memory error, or &lt;a href=&quot;../rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; if the size of the dynamic string exceeds &lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;, or &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if there have been no errors.</source>
          <target state="translated">sqlite3_str Xで動的文字列を構築しているときに以前のエラーが発生した場合、&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode（X）&lt;/a&gt;メソッドは適切なエラーコードを返します。&lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode（X）&lt;/a&gt;メソッド戻り、&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;任意のメモリ不足エラー、または以下&lt;a href=&quot;../rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt;動的文字列のサイズを超える場合&lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;、又は&lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OKに&lt;/a&gt;エラーがなかった場合。</target>
        </trans-unit>
        <trans-unit id="8cf62e1e5822970ab1a0772544bba1f6a9886bdb" translate="yes" xml:space="preserve">
          <source>If any views refer to table X in a way that is affected by the schema change, then drop those views using &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt; and recreate them with whatever changes are necessary to accommodate the schema change using &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;.</source>
          <target state="translated">スキーマの変更の影響を受けるビューでテーブルXを参照している場合は、&lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt;を使用してそれらのビューを削除し、&lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;を使用してスキーマの変更に対応するために必要な変更を加えて再作成します。</target>
        </trans-unit>
        <trans-unit id="f4bcba20e82a98be0954f7a995f190f8be3b9e76" translate="yes" xml:space="preserve">
          <source>If argument P3 is non-zero, then it indicates that the sorter may assume that a stable sort considering the first P3 fields of each key is sufficient to produce the required results.</source>
          <target state="translated">引数P3が0でない場合、ソーターは各キーの最初のP3フィールドを考慮した安定したソートが必要な結果を生成するのに十分であると仮定してもよいことを示しています。</target>
        </trans-unit>
        <trans-unit id="35693c95846989c47eb6a922b6389598e5e5c2ef" translate="yes" xml:space="preserve">
          <source>If argument pnCol is not NULL, then *pnCol is set to the number of columns in the table.</source>
          <target state="translated">引数pnColがNULLでない場合、*pnColにはテーブルの列数が設定されます。</target>
        </trans-unit>
        <trans-unit id="6eebf7ee5a909998cdac6e1af93d8bf0c4b9e6a9" translate="yes" xml:space="preserve">
          <source>If argument pzTab is not NULL, then *pzTab is set to point to a nul-terminated utf-8 encoded string containing the name of the table affected by the current change. The buffer remains valid until either sqlite3changeset_next() is called on the iterator or until the conflict-handler function returns. If pnCol is not NULL, then *pnCol is set to the number of columns in the table affected by the change. If pbIndirect is not NULL, then *pbIndirect is set to true (1) if the change is an indirect change, or false (0) otherwise. See the documentation for &lt;a href=&quot;#sqlite3session_indirect&quot;&gt;sqlite3session_indirect()&lt;/a&gt; for a description of direct and indirect changes. Finally, if pOp is not NULL, then *pOp is set to one of &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the type of change that the iterator currently points to.</source>
          <target state="translated">引数pzTabがNULLでない場合、* pzTabは、現在の変更の影響を受けるテーブルの名前を含む、ヌル文字で終了するutf-8エンコードされた文字列を指すように設定されます。イテレーターでsqlite3changeset_next（）が呼び出されるまで、または競合ハンドラー関数が戻るまで、バッファーは有効なままです。 pnColがNULLでない場合、* pnColは、変更の影響を受けるテーブル内の列数に設定されます。 pbIndirectがNULLでない場合、* pbIndirectは、変更が間接的な変更である場合はtrue（1）に設定され、そうでない場合はfalse（0）に設定されます。直接的および間接的な変更の説明については、&lt;a href=&quot;#sqlite3session_indirect&quot;&gt;sqlite3session_indirect（）の&lt;/a&gt;ドキュメントを参照してください。最後に、pOpがNULLでない場合、* pOpは&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;、&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE、&lt;/a&gt;または&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATEの&lt;/a&gt;いずれかに設定されます。、イテレータが現在指している変更のタイプによって異なります。</target>
        </trans-unit>
        <trans-unit id="eeb423ada7e3f3af8ece536280a90cde13ccf0f0" translate="yes" xml:space="preserve">
          <source>If argument pzTab is not NULL, then *pzTab is set to point to a nul-terminated utf-8 encoded string containing the name of the table affected by the current change. The buffer remains valid until either sqlite3changeset_next() is called on the iterator or until the conflict-handler function returns. If pnCol is not NULL, then *pnCol is set to the number of columns in the table affected by the change. If pbIndirect is not NULL, then *pbIndirect is set to true (1) if the change is an indirect change, or false (0) otherwise. See the documentation for &lt;a href=&quot;sqlite3session_indirect&quot;&gt;sqlite3session_indirect()&lt;/a&gt; for a description of direct and indirect changes. Finally, if pOp is not NULL, then *pOp is set to one of &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; or &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the type of change that the iterator currently points to.</source>
          <target state="translated">引数pzTabがNULLでない場合、* pzTabは、現在の変更の影響を受けるテーブルの名前を含む、ヌル文字で終了するutf-8エンコードされた文字列を指すように設定されます。イテレーターでsqlite3changeset_next（）が呼び出されるまで、または競合ハンドラー関数が戻るまで、バッファーは有効なままです。 pnColがNULLでない場合、* pnColは、変更の影響を受けるテーブル内の列数に設定されます。 pbIndirectがNULLでない場合、* pbIndirectは、変更が間接的な変更である場合はtrue（1）に設定され、そうでない場合はfalse（0）に設定されます。直接的および間接的な変更の説明については、&lt;a href=&quot;sqlite3session_indirect&quot;&gt;sqlite3session_indirect（）の&lt;/a&gt;ドキュメントを参照してください。最後に、pOpがNULLでない場合、* pOpは&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;、&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_DELETE、&lt;/a&gt;または&lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATEの&lt;/a&gt;いずれかに設定されます。、イテレータが現在指している変更のタイプによって異なります。</target>
        </trans-unit>
        <trans-unit id="012db9d404feeb7b242a5f104e807e9ebcf5e6cc" translate="yes" xml:space="preserve">
          <source>If argument zTab is not NULL, then it is the name of a table to attach to the session object passed as the first argument. All subsequent changes made to the table while the session object is enabled will be recorded. See documentation for &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; for further details.</source>
          <target state="translated">引数zTabがNULLでない場合、それは最初の引数として渡されたセッションオブジェクトにアタッチするテーブルの名前です。セッションオブジェクトが有効になっている間にテーブルに加えられた変更はすべて記録されます。詳細については、&lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset（）の&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="1874355cfa55a648a95d55d6cc4ad4d5d5a5435f" translate="yes" xml:space="preserve">
          <source>If argument zTab is not NULL, then it is the name of a table to attach to the session object passed as the first argument. All subsequent changes made to the table while the session object is enabled will be recorded. See documentation for &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; for further details.</source>
          <target state="translated">引数zTabがNULLでない場合、それは最初の引数として渡されたセッションオブジェクトにアタッチするテーブルの名前です。セッションオブジェクトが有効になっている間にテーブルに加えられた変更はすべて記録されます。詳細については、&lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset（）の&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="21fcaf7a804fb18a6bdf460073dabd9a55d816ad" translate="yes" xml:space="preserve">
          <source>If both SQLITE_STOREP2 and SQLITE_KEEPNULL flags are set then the content of r[P2] is only changed if the new value is NULL or 0 (false). In other words, a prior r[P2] value will not be overwritten by 1 (true).</source>
          <target state="translated">SQLITE_STOREP2 と SQLITE_KEEPNULL フラグの両方が設定されている場合、新しい値が NULL または 0 (False)の場合にのみ r[P2]の内容が変更されます。言い換えれば、以前の r[P2]の値は 1 (true)で上書きされません。</target>
        </trans-unit>
        <trans-unit id="f091230c98fc9fb42f84687fff668e2e8782487e" translate="yes" xml:space="preserve">
          <source>If both SQLITE_STOREP2 and SQLITE_KEEPNULL flags are set then the content of r[P2] is only changed if the new value is NULL or 1 (true). In other words, a prior r[P2] value will not be overwritten by 0 (false).</source>
          <target state="translated">SQLITE_STOREP2 と SQLITE_KEEPNULL フラグの両方が設定されている場合、r[P2]の内容は、新しい値が NULL または 1 (真)の場合にのみ変更されます。つまり、以前の r[P2]の値は 0 (False)で上書きされません。</target>
        </trans-unit>
        <trans-unit id="b35b42f8226135f60e30979149548acecdb3cd9a" translate="yes" xml:space="preserve">
          <source>If both pragmas &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;full_column_names&lt;/a&gt; are OFF then case (2) applies.</source>
          <target state="translated">プラグマ&lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt;と&lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;full_column_namesの&lt;/a&gt;両方がOFFの場合、ケース（2）が適用されます。</target>
        </trans-unit>
        <trans-unit id="c1ea5de7bdcea197233ed39232910d2d33159cd2" translate="yes" xml:space="preserve">
          <source>If certain kinds of errors occur on a statement within a multi-statement transaction (errors including &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_FULL&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_IOERR&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;, and &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;) then the transaction might be rolled back automatically. The only way to find out whether SQLite automatically rolled back the transaction after an error is to use this function.</source>
          <target state="translated">マルチステートメントトランザクション内のステートメントで特定の種類のエラー（&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_FULL&lt;/a&gt;、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_IOERR&lt;/a&gt;、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;、&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;、および&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;を含むエラー）が発生した場合、トランザクションは自動的にロールバックされる可能性があります。エラー後にSQLiteがトランザクションを自動的にロールバックしたかどうかを確認する唯一の方法は、この関数を使用することです。</target>
        </trans-unit>
        <trans-unit id="063cf3d6b1f8d89a285c8317271a90d08b9bd66c" translate="yes" xml:space="preserve">
          <source>If certain kinds of errors occur on a statement within a multi-statement transaction (errors including &lt;a href=&quot;../rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;, &lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;, &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, and &lt;a href=&quot;../rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;) then the transaction might be rolled back automatically. The only way to find out whether SQLite automatically rolled back the transaction after an error is to use this function.</source>
          <target state="translated">マルチステートメントトランザクション内のステートメントで特定の種類のエラー（&lt;a href=&quot;../rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;、&lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;、&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;、&lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;、および&lt;a href=&quot;../rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;を含むエラー）が発生した場合、トランザクションは自動的にロールバックされる可能性があります。エラー後にSQLiteがトランザクションを自動的にロールバックしたかどうかを確認する唯一の方法は、この関数を使用することです。</target>
        </trans-unit>
        <trans-unit id="65b57925e204e3ebe11c23e15127d898a0e33ca6" translate="yes" xml:space="preserve">
          <source>If certain kinds of errors occur within a transaction, the transaction may or may not be rolled back automatically. The errors that can cause an automatic rollback include:</source>
          <target state="translated">ある種のエラーがトランザクション内で発生した場合、トランザクションは自動的にロールバックされる場合とされない場合があります。自動ロールバックの原因となるエラーには、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="debbf4ee0f449f15f2b2fad59057f8a4eccd847a" translate="yes" xml:space="preserve">
          <source>If changes occur on the same database connection after a query starts running but before the query completes, then it is undefined whether or not the query will see those changes.</source>
          <target state="translated">クエリが実行を開始した後、クエリが完了する前に同じデータベース接続で変更が発生した場合、クエリがそれらの変更を見るかどうかは未定義です。</target>
        </trans-unit>
        <trans-unit id="92abf58210ebaa6ec510b645429d6e91e6ca04d8" translate="yes" xml:space="preserve">
          <source>If changes occur on the same database connection after a query starts running but before the query completes, then the query might return a changed row more than once, or it might return a row that was previously deleted.</source>
          <target state="translated">クエリの実行開始後、クエリが完了する前に同じデータベース接続で変更が発生した場合、クエリは変更された行を複数回返したり、以前に削除された行を返したりする可能性があります。</target>
        </trans-unit>
        <trans-unit id="437112dad4bafb7626f6351c41b7b34b2abfaca6" translate="yes" xml:space="preserve">
          <source>If changing into or out of WAL mode the procedure is more complicated.</source>
          <target state="translated">WALモードへの切り替え、またはWALモードからの切り替えの場合は、手順が複雑になります。</target>
        </trans-unit>
        <trans-unit id="f754396c33d700ad2fd9dbdfe823fd9ae27672f4" translate="yes" xml:space="preserve">
          <source>If column names are explicitly provided for the FTS table as part of the CREATE VIRTUAL TABLE statement, then a datatype name may be optionally specified for each column. This is pure syntactic sugar, the supplied typenames are not used by FTS or the SQLite core for any purpose. The same applies to any constraints specified along with an FTS column name - they are parsed but not used or recorded by the system in any way.</source>
          <target state="translated">CREATE VIRTUAL TABLE文の一部としてFTSテーブルに明示的にカラム名が提供されている場合、各カラムにはオプションでデータ型名を指定することができます。これは純粋な構文上の問題であり、提供された型名はFTSやSQLiteコアがどのような目的でも使用することはありません。同じことが、FTSカラム名と共に指定された制約にも適用されます-それらは解析されますが、システムによって使用されたり記録されたりすることはありません。</target>
        </trans-unit>
        <trans-unit id="4ec154d4b803f19da5aae8c26059349f5ffc0b8b" translate="yes" xml:space="preserve">
          <source>If conflict is with a remote UPDATE and the resolution is OMIT, then the old.* values are rebased using the new.* values in the remote change. Or, if the resolution is REPLACE, then the change is copied into the rebased changeset with updates to columns also updated by the conflicting remote UPDATE removed. If this means no columns would be updated, the change is omitted.</source>
          <target state="translated">競合がリモートUPDATEで、解決方法がOMITの場合、old.*値は、リモート変更のnew.*値を使用してリベースされます。または、解決方法がREPLACEの場合、競合するリモートUPDATEによって更新されたカラムの更新が削除された状態で、変更がリベースされたチェンジセットにコピーされます。これにより列が更新されない場合は、変更は省略されます。</target>
        </trans-unit>
        <trans-unit id="eacad9fb0a3ce1ea1edfa735ab3f942dbf9e8cd8" translate="yes" xml:space="preserve">
          <source>If cursor P1 is an index, then the content is the key of the row. If cursor P2 is a table, then the content extracted is the data.</source>
          <target state="translated">カーソルP1がインデックスであれば、抽出された内容はその行のキーである。カーソルP2がテーブルであれば、抽出された内容はデータである。</target>
        </trans-unit>
        <trans-unit id="ecd4bc0795e5315c7b840830ae1ae10db7944fd7" translate="yes" xml:space="preserve">
          <source>If cursor P1 is not open, jump to instruction P2. Otherwise, fall through.</source>
          <target state="translated">カーソルP1が開いていない場合は、命令P2にジャンプします。それ以外の場合はフォールスルー。</target>
        </trans-unit>
        <trans-unit id="b0e0c624719d0c72631b398ea85cd293212feef6" translate="yes" xml:space="preserve">
          <source>If cursor P1 refers to an SQL table (B-Tree that uses integer keys), use the value in register P3 as a key. If cursor P1 refers to an SQL index, then P3 is the first in an array of P4 registers that are used as an unpacked index key.</source>
          <target state="translated">カーソルP1がSQLテーブル(整数キーを使用するBツリー)を参照している場合、レジスタP3の値をキーとして使用します。カーソルP1がSQLインデックスを参照している場合、P3は、アンパックされたインデックスキーとして使用されるP4レジスタの配列の最初のものです。</target>
        </trans-unit>
        <trans-unit id="eed3ade81291c8b1e43812aa13b2f866776f9f36" translate="yes" xml:space="preserve">
          <source>If cursor P1 refers to an SQL table (B-Tree that uses integer keys), use the value in register P3 as the key. If cursor P1 refers to an SQL index, then P3 is the first in an array of P4 registers that are used as an unpacked index key.</source>
          <target state="translated">カーソルP1がSQLテーブル(整数キーを使用するB-Tree)を参照している場合、レジスタP3の値をキーとして使用します。カーソルP1がSQLインデックスを参照している場合、P3は、アンパックされたインデックスキーとして使用されるP4レジスタの配列の最初のものです。</target>
        </trans-unit>
        <trans-unit id="bde1d5766ee802e72c51189e7fb68596781976ad" translate="yes" xml:space="preserve">
          <source>If cursor P1 was previously moved via &lt;a href=&quot;opcode#DeferredSeek&quot;&gt;DeferredSeek&lt;/a&gt;, complete that seek operation now, without further delay. If the cursor seek has already occurred, this instruction is a no-op.</source>
          <target state="translated">If cursor P1 was previously moved via &lt;a href=&quot;opcode#DeferredSeek&quot;&gt;DeferredSeek&lt;/a&gt;, complete that seek operation now, without further delay. If the cursor seek has already occurred, this instruction is a no-op.</target>
        </trans-unit>
        <trans-unit id="b9a382b280888652763d650554446d773be05c07" translate="yes" xml:space="preserve">
          <source>If data is of type &lt;b&gt;text&lt;/b&gt; then the comparison is determined by the standard C data comparison functions &lt;b&gt;memcmp()&lt;/b&gt; or &lt;b&gt;strcmp()&lt;/b&gt;. The comparison looks at bytes from two inputs one by one and returns the first non-zero difference. Strings are '\000' terminated so shorter strings sort before longer strings, as you would expect.</source>
          <target state="translated">データ型である場合&lt;b&gt;、テキスト&lt;/b&gt;、比較関数は、標準のCデータを比較することによって決定される&lt;b&gt;memcmp（）を&lt;/b&gt;または&lt;b&gt;のstrcmp（）を&lt;/b&gt;。比較では、2つの入力からのバイトを1つずつ調べ、最初のゼロ以外の差を返します。文字列は '\ 000'で終了するので、予想どおり、短い文字列は長い文字列の前にソートされます。</target>
        </trans-unit>
        <trans-unit id="0120d2592940874456695d5517c48510978290bc" translate="yes" xml:space="preserve">
          <source>If database zDb is the name of an attached database that is not in WAL mode, SQLITE_OK is returned and both *pnLog and *pnCkpt set to -1. If zDb is not NULL (or a zero length string) and is not the name of any attached database, SQLITE_ERROR is returned to the caller.</source>
          <target state="translated">データベース zDb が WAL モードではない添付データベースの名前である場合、SQLITE_OK が返され、*pnLog と *pnCkpt の両方が -1 に設定されます。zDb が NULL (または長さ 0 の文字列)ではなく、接続されているデータベースの名前ではない場合は、SQLITE_ERROR がコール元に返されます。</target>
        </trans-unit>
        <trans-unit id="ed9f3d01c8cb63f65cf1f8cb1ada863d801c5821" translate="yes" xml:space="preserve">
          <source>If defined, support for sub-selects and the IN() operator are omitted.</source>
          <target state="translated">定義されている場合は、サブセレクトとIN()演算子のサポートは省略されます。</target>
        </trans-unit>
        <trans-unit id="5f4710e921e7c9706b1a7d0affff80c102083b4a" translate="yes" xml:space="preserve">
          <source>If desired, you can verify the new database by running this command:</source>
          <target state="translated">必要に応じて、このコマンドを実行して新しいデータベースを検証することができます。</target>
        </trans-unit>
        <trans-unit id="d0b0b6a44b8709f88072f86b2bad9194c580b896" translate="yes" xml:space="preserve">
          <source>If either P1 or P2 is 0 (false) then the result is 0 even if the other input is NULL. A NULL and true or two NULLs give a NULL output.</source>
          <target state="translated">P1 または P2 のどちらかが 0 (false)の場合、他の入力が NULL であっても結果は 0 になります。NULLと真、または2つのNULLがあればNULL出力となります。</target>
        </trans-unit>
        <trans-unit id="0c5f4e14888f22c44de9608417d3500cbb09c876" translate="yes" xml:space="preserve">
          <source>If either P1 or P2 is nonzero (true) then the result is 1 (true) even if the other input is NULL. A NULL and false or two NULLs give a NULL output.</source>
          <target state="translated">P1 または P2 のどちらかが 0 以外の値(真)の場合、他の入力が NULL であっても結果は 1(真)となります。NULLとFalse、または2つのNULLを指定すると、NULL出力となります。</target>
        </trans-unit>
        <trans-unit id="f718f36fc0872a36f2f90015ef098011701953fd" translate="yes" xml:space="preserve">
          <source>If either P3 or the sorter contains a NULL in one of their significant fields (not counting the P4 fields at the end which are ignored) then the comparison is assumed to be equal.</source>
          <target state="translated">P3またはソーターのいずれかが有効なフィールドの1つにNULLを含む場合(最後のP4フィールドは無視されますがカウントされません)、比較は等しいと仮定されます。</target>
        </trans-unit>
        <trans-unit id="cb70cc2d7081446ae1bd92c809ed77dcb6489c40" translate="yes" xml:space="preserve">
          <source>If either X&lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; or X&lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt; are non-numeric, then the boundary is the first row for which the expression &quot;X&lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; IS X&lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt;&quot; is true.</source>
          <target state="translated">X &lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt;またはX &lt;sub&gt;&lt;small&gt;cの&lt;/small&gt;&lt;/sub&gt;いずれかが数値でない場合、境界は式「X &lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; IS X &lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt;」が真である最初の行です。</target>
        </trans-unit>
        <trans-unit id="40afda50342c1866ef5c9245fe131f4faa8b196a" translate="yes" xml:space="preserve">
          <source>If either operand has an explicit collating function assignment using the postfix &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, then the explicit collating function is used for comparison, with precedence to the collating function of the left operand.</source>
          <target state="translated">いずれかのオペランドに後&lt;a href=&quot;lang_expr#collateop&quot;&gt;置COLLATE演算子&lt;/a&gt;を使用した明示的な照合関数の割り当てがある場合、明示的な照合関数が比較に使用され、左側のオペランドの照合関数が優先されます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
